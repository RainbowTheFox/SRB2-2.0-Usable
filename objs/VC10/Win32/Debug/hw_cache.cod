; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\hw_cache.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_patchformat
PUBLIC	_textureformat
PUBLIC	_firetranslucent
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_firetranslucent DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?gr_lods@?1??HWR_ResizeBlock@@9@9 DD 08H		; `HWR_ResizeBlock'::`2'::gr_lods
	DD	07H
	DD	06H
	DD	05H
	DD	04H
	DD	03H
	DD	02H
	DD	01H
	DD	00H
	ORG $+4
?gr_aspects@?1??HWR_ResizeBlock@@9@9 DD 00H		; `HWR_ResizeBlock'::`2'::gr_aspects
	DD	0437f0000r			; 255
	DD	0437f0000r			; 255
	DD	01H
	DD	0437f0000r			; 255
	DD	042fe0000r			; 127
	DD	02H
	DD	0437f0000r			; 255
	DD	0427c0000r			; 63
	DD	03H
	DD	0437f0000r			; 255
	DD	041f80000r			; 31
	DD	00H
	DD	0437f0000r			; 255
	DD	0437f0000r			; 255
	DD	0ffffffffH
	DD	042fe0000r			; 127
	DD	0437f0000r			; 255
	DD	0fffffffeH
	DD	0427c0000r			; 63
	DD	0437f0000r			; 255
	DD	0fffffffdH
	DD	041f80000r			; 31
	DD	0437f0000r			; 255
_format2bpp DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	04H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	ORG $+4
_picmode2GR DD	05H
	DD	00H
	DD	0dH
	DD	00H
	DD	06H
CONST	ENDS
_DATA	SEGMENT
_patchformat DD	0eH
_textureformat DD 05H
_DATA	ENDS
PUBLIC	_HWR_MakePatch
PUBLIC	_HWR_PrepLevelCache
PUBLIC	_HWR_InitTextureCache
PUBLIC	_HWR_FreeTextureCache
PUBLIC	_HWR_GetFlat
PUBLIC	_HWR_GetTexture
PUBLIC	_HWR_GetPatch
PUBLIC	_HWR_GetMappedPatch
PUBLIC	_HWR_GetPic
PUBLIC	_HWR_SetPalette
PUBLIC	??_C@_0DL@JJMIDDCD@HWR_DrawPatchInCache?3?5no?5drawer@ ; `string'
PUBLIC	??_C@_0BL@HBNBDKNI@3D?5can?8t?5alloc?5gr_textures@ ; `string'
PUBLIC	??_C@_0BD@JKLFCLJF@HWR_GetMappedPatch@		; `string'
PUBLIC	??_C@_0BC@GFOKFIGO@?$CFs?3?5Out?5of?5memory@	; `string'
PUBLIC	__real@3f800000
EXTRN	_memset:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_I_Error:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_ReadLump:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_Z_FreeTags:PROC
EXTRN	_Z_ChangeTag2:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_TagUsage:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_cv_grgammared:BYTE
EXTRN	_cv_grgammagreen:BYTE
EXTRN	_cv_grgammablue:BYTE
EXTRN	_hwdriver:BYTE
EXTRN	_colormaps:DWORD
EXTRN	_textures:DWORD
EXTRN	_numwadfiles:WORD
EXTRN	_wadfiles:BYTE
EXTRN	_pLocalPalette:DWORD
EXTRN	_transtables:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_blocksize DD	01H DUP (?)
_blockwidth DD	01H DUP (?)
_blockheight DD	01H DUP (?)
_gr_numtextures DD 01H DUP (?)
_gr_textures DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0BC@GFOKFIGO@?$CFs?3?5Out?5of?5memory@
CONST	SEGMENT
??_C@_0BC@GFOKFIGO@?$CFs?3?5Out?5of?5memory@ DB '%s: Out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JKLFCLJF@HWR_GetMappedPatch@
CONST	SEGMENT
??_C@_0BD@JKLFCLJF@HWR_GetMappedPatch@ DB 'HWR_GetMappedPatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HBNBDKNI@3D?5can?8t?5alloc?5gr_textures@
CONST	SEGMENT
??_C@_0BL@HBNBDKNI@3D?5can?8t?5alloc?5gr_textures@ DB '3D can''t alloc gr'
	DB	'_textures', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JJMIDDCD@HWR_DrawPatchInCache?3?5no?5drawer@
CONST	SEGMENT
??_C@_0DL@JJMIDDCD@HWR_DrawPatchInCache?3?5no?5drawer@ DB 'HWR_DrawPatchI'
	DB	'nCache: no drawer defined for this bpp (%d)', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_DrawPicInCache
_TEXT	SEGMENT
tv95 = -112						; size = 4
tv132 = -112						; size = 4
_col$ = -44						; size = 4
_picbpp$ = -40						; size = 4
_texel$ = -33						; size = 1
_src$ = -32						; size = 4
_dest$ = -28						; size = 4
_stepy$ = -24						; size = 4
_stepx$ = -20						; size = 4
_posy$ = -16						; size = 4
_posx$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_block$ = 8						; size = 4
_pblockwidth$ = 12					; size = 4
_pblockheight$ = 16					; size = 4
_blockmodulo$ = 20					; size = 4
_pic$ = 24						; size = 4
_bpp$ = 28						; size = 4
_HWR_DrawPicInCache PROC				; COMDAT

; 728  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 729  : 	INT32 i,j;
; 730  : 	fixed_t posx, posy, stepx, stepy;
; 731  : 	UINT8 *dest, *src, texel;
; 732  : 	INT32 picbpp;
; 733  : 	RGBA_t col;
; 734  : 
; 735  : 	stepy = ((INT32)SHORT(pic->height)<<FRACBITS)/pblockheight;

  00009	8b 45 18	 mov	 eax, DWORD PTR _pic$[ebp]
  0000c	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00010	c1 e0 10	 shl	 eax, 16			; 00000010H
  00013	99		 cdq
  00014	f7 7d 10	 idiv	 DWORD PTR _pblockheight$[ebp]
  00017	89 45 e8	 mov	 DWORD PTR _stepy$[ebp], eax

; 736  : 	stepx = ((INT32)SHORT(pic->width)<<FRACBITS)/pblockwidth;

  0001a	8b 45 18	 mov	 eax, DWORD PTR _pic$[ebp]
  0001d	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00020	c1 e0 10	 shl	 eax, 16			; 00000010H
  00023	99		 cdq
  00024	f7 7d 0c	 idiv	 DWORD PTR _pblockwidth$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR _stepx$[ebp], eax

; 737  : 	picbpp = format2bpp[picmode2GR[pic->mode]];

  0002a	8b 45 18	 mov	 eax, DWORD PTR _pic$[ebp]
  0002d	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00031	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _picmode2GR[ecx*4]
  00038	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _format2bpp[edx*4]
  0003f	89 45 d8	 mov	 DWORD PTR _picbpp$[ebp], eax

; 738  : 	posy = 0;

  00042	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _posy$[ebp], 0

; 739  : 	for (j = 0; j < pblockheight; j++)

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00050	eb 09		 jmp	 SHORT $LN4@HWR_DrawPi
$LN2@HWR_DrawPi:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00055	83 c0 01	 add	 eax, 1
  00058	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@HWR_DrawPi:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0005e	3b 45 10	 cmp	 eax, DWORD PTR _pblockheight$[ebp]
  00061	0f 8d ae 01 00
	00		 jge	 $LN3@HWR_DrawPi

; 740  : 	{
; 741  : 		posx = 0;

  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _posx$[ebp], 0

; 742  : 		dest = &block[j*blockmodulo];

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00071	0f af 45 14	 imul	 eax, DWORD PTR _blockmodulo$[ebp]
  00075	03 45 08	 add	 eax, DWORD PTR _block$[ebp]
  00078	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 743  : 		src = &pic->data[(posy>>FRACBITS)*SHORT(pic->width)*picbpp];

  0007b	8b 45 f0	 mov	 eax, DWORD PTR _posy$[ebp]
  0007e	c1 f8 10	 sar	 eax, 16			; 00000010H
  00081	8b 4d 18	 mov	 ecx, DWORD PTR _pic$[ebp]
  00084	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00087	0f af c2	 imul	 eax, edx
  0008a	0f af 45 d8	 imul	 eax, DWORD PTR _picbpp$[ebp]
  0008e	8b 4d 18	 mov	 ecx, DWORD PTR _pic$[ebp]
  00091	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00095	89 55 e0	 mov	 DWORD PTR _src$[ebp], edx

; 744  : 		for (i = 0; i < pblockwidth;i++)

  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0009f	eb 09		 jmp	 SHORT $LN7@HWR_DrawPi
$LN5@HWR_DrawPi:
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a4	83 c0 01	 add	 eax, 1
  000a7	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HWR_DrawPi:
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	3b 45 0c	 cmp	 eax, DWORD PTR _pblockwidth$[ebp]
  000b0	0f 8d 51 01 00
	00		 jge	 $LN6@HWR_DrawPi

; 745  : 		{
; 746  : 			switch (pic->mode)

  000b6	8b 45 18	 mov	 eax, DWORD PTR _pic$[ebp]
  000b9	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000bd	89 4d 90	 mov	 DWORD PTR tv95[ebp], ecx
  000c0	83 7d 90 04	 cmp	 DWORD PTR tv95[ebp], 4
  000c4	0f 87 2f 01 00
	00		 ja	 $LN8@HWR_DrawPi
  000ca	8b 55 90	 mov	 edx, DWORD PTR tv95[ebp]
  000cd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN22@HWR_DrawPi[edx*4]
$LN12@HWR_DrawPi:

; 747  : 			{ // source bpp
; 748  : 				case PALETTE :
; 749  : 					texel = src[(posx+FRACUNIT/2)>>FRACBITS];

  000d4	8b 45 f4	 mov	 eax, DWORD PTR _posx$[ebp]
  000d7	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  000dc	c1 f8 10	 sar	 eax, 16			; 00000010H
  000df	8b 4d e0	 mov	 ecx, DWORD PTR _src$[ebp]
  000e2	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  000e5	88 55 df	 mov	 BYTE PTR _texel$[ebp], dl

; 750  : 					switch (bpp)

  000e8	8b 45 1c	 mov	 eax, DWORD PTR _bpp$[ebp]
  000eb	89 45 90	 mov	 DWORD PTR tv132[ebp], eax
  000ee	8b 4d 90	 mov	 ecx, DWORD PTR tv132[ebp]
  000f1	83 e9 01	 sub	 ecx, 1
  000f4	89 4d 90	 mov	 DWORD PTR tv132[ebp], ecx
  000f7	83 7d 90 03	 cmp	 DWORD PTR tv132[ebp], 3
  000fb	0f 87 91 00 00
	00		 ja	 $LN10@HWR_DrawPi
  00101	8b 55 90	 mov	 edx, DWORD PTR tv132[ebp]
  00104	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN23@HWR_DrawPi[edx*4]
$LN13@HWR_DrawPi:

; 751  : 					{ // destination bpp
; 752  : 						case 1 :
; 753  : 							*dest++ = texel; break;

  0010b	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0010e	8a 4d df	 mov	 cl, BYTE PTR _texel$[ebp]
  00111	88 08		 mov	 BYTE PTR [eax], cl
  00113	8b 55 e4	 mov	 edx, DWORD PTR _dest$[ebp]
  00116	83 c2 01	 add	 edx, 1
  00119	89 55 e4	 mov	 DWORD PTR _dest$[ebp], edx
  0011c	eb 74		 jmp	 SHORT $LN10@HWR_DrawPi
$LN14@HWR_DrawPi:

; 754  : 						case 2 :
; 755  : 							*(UINT16 *)dest = (UINT16)(texel | 0xff00);

  0011e	0f b6 45 df	 movzx	 eax, BYTE PTR _texel$[ebp]
  00122	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  00127	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0012a	66 89 01	 mov	 WORD PTR [ecx], ax

; 756  : 							dest +=2;

  0012d	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00130	83 c0 02	 add	 eax, 2
  00133	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 757  : 							break;

  00136	eb 5a		 jmp	 SHORT $LN10@HWR_DrawPi
$LN15@HWR_DrawPi:

; 758  : 						case 3 :
; 759  : 							col = V_GetColor(texel);

  00138	0f b6 45 df	 movzx	 eax, BYTE PTR _texel$[ebp]
  0013c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00141	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  00147	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0014a	89 55 d4	 mov	 DWORD PTR _col$[ebp], edx

; 760  : 							((RGBA_t *)dest)->s.red   = col.s.red;

  0014d	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00150	8a 4d d4	 mov	 cl, BYTE PTR _col$[ebp]
  00153	88 08		 mov	 BYTE PTR [eax], cl

; 761  : 							((RGBA_t *)dest)->s.green = col.s.green;

  00155	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00158	8a 4d d5	 mov	 cl, BYTE PTR _col$[ebp+1]
  0015b	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 762  : 							((RGBA_t *)dest)->s.blue  = col.s.blue;

  0015e	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00161	8a 4d d6	 mov	 cl, BYTE PTR _col$[ebp+2]
  00164	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 763  : 							dest += 3;

  00167	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0016a	83 c0 03	 add	 eax, 3
  0016d	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 764  : 							break;

  00170	eb 20		 jmp	 SHORT $LN10@HWR_DrawPi
$LN16@HWR_DrawPi:

; 765  : 						case 4 :
; 766  : 							*(RGBA_t *)dest = V_GetColor(texel);

  00172	0f b6 45 df	 movzx	 eax, BYTE PTR _texel$[ebp]
  00176	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  00181	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00184	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00187	89 10		 mov	 DWORD PTR [eax], edx

; 767  : 							dest += 4;

  00189	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0018c	83 c0 04	 add	 eax, 4
  0018f	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax
$LN10@HWR_DrawPi:

; 768  : 							break;
; 769  : 					}
; 770  : 					break;

  00192	eb 65		 jmp	 SHORT $LN8@HWR_DrawPi
$LN17@HWR_DrawPi:

; 771  : 				case INTENSITY :
; 772  : 					*dest++ = src[(posx+FRACUNIT/2)>>FRACBITS];

  00194	8b 45 f4	 mov	 eax, DWORD PTR _posx$[ebp]
  00197	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  0019c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0019f	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  001a2	8b 55 e0	 mov	 edx, DWORD PTR _src$[ebp]
  001a5	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001a8	88 01		 mov	 BYTE PTR [ecx], al
  001aa	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  001ad	83 c1 01	 add	 ecx, 1
  001b0	89 4d e4	 mov	 DWORD PTR _dest$[ebp], ecx

; 773  : 					break;

  001b3	eb 44		 jmp	 SHORT $LN8@HWR_DrawPi
$LN18@HWR_DrawPi:

; 774  : 				case INTENSITY_ALPHA : // assume dest bpp = 2
; 775  : 					*(UINT16*)dest = *((INT16 *)src + ((posx+FRACUNIT/2)>>FRACBITS));

  001b5	8b 45 f4	 mov	 eax, DWORD PTR _posx$[ebp]
  001b8	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  001bd	c1 f8 10	 sar	 eax, 16			; 00000010H
  001c0	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  001c3	8b 55 e0	 mov	 edx, DWORD PTR _src$[ebp]
  001c6	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  001ca	66 89 01	 mov	 WORD PTR [ecx], ax

; 776  : 					dest += 2;

  001cd	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  001d0	83 c0 02	 add	 eax, 2
  001d3	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 777  : 					break;

  001d6	eb 21		 jmp	 SHORT $LN8@HWR_DrawPi

; 778  : 				case RGB24 :
; 779  : 					break;  // not supported yet

  001d8	eb 1f		 jmp	 SHORT $LN8@HWR_DrawPi
$LN20@HWR_DrawPi:

; 780  : 				case RGBA32 : // assume dest bpp = 4
; 781  : 					dest += 4;

  001da	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  001dd	83 c0 04	 add	 eax, 4
  001e0	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 782  : 					*(UINT32 *)dest = *((UINT32 *)src + ((posx+FRACUNIT/2)>>FRACBITS));

  001e3	8b 45 f4	 mov	 eax, DWORD PTR _posx$[ebp]
  001e6	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  001eb	c1 f8 10	 sar	 eax, 16			; 00000010H
  001ee	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  001f1	8b 55 e0	 mov	 edx, DWORD PTR _src$[ebp]
  001f4	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  001f7	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@HWR_DrawPi:

; 783  : 					break;
; 784  : 			}
; 785  : 			posx += stepx;

  001f9	8b 45 f4	 mov	 eax, DWORD PTR _posx$[ebp]
  001fc	03 45 ec	 add	 eax, DWORD PTR _stepx$[ebp]
  001ff	89 45 f4	 mov	 DWORD PTR _posx$[ebp], eax

; 786  : 		}

  00202	e9 9a fe ff ff	 jmp	 $LN5@HWR_DrawPi
$LN6@HWR_DrawPi:

; 787  : 		posy += stepy;

  00207	8b 45 f0	 mov	 eax, DWORD PTR _posy$[ebp]
  0020a	03 45 e8	 add	 eax, DWORD PTR _stepy$[ebp]
  0020d	89 45 f0	 mov	 DWORD PTR _posy$[ebp], eax

; 788  : 	}

  00210	e9 3d fe ff ff	 jmp	 $LN2@HWR_DrawPi
$LN3@HWR_DrawPi:

; 789  : }

  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	5b		 pop	 ebx
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
$LN22@HWR_DrawPi:
  0021c	00 00 00 00	 DD	 $LN12@HWR_DrawPi
  00220	00 00 00 00	 DD	 $LN17@HWR_DrawPi
  00224	00 00 00 00	 DD	 $LN18@HWR_DrawPi
  00228	00 00 00 00	 DD	 $LN8@HWR_DrawPi
  0022c	00 00 00 00	 DD	 $LN20@HWR_DrawPi
$LN23@HWR_DrawPi:
  00230	00 00 00 00	 DD	 $LN13@HWR_DrawPi
  00234	00 00 00 00	 DD	 $LN14@HWR_DrawPi
  00238	00 00 00 00	 DD	 $LN15@HWR_DrawPi
  0023c	00 00 00 00	 DD	 $LN16@HWR_DrawPi
_HWR_DrawPicInCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_LoadMappedPatch
_TEXT	SEGMENT
_patch$1 = -4						; size = 4
_grmip$ = 8						; size = 4
_gpatch$ = 12						; size = 4
_HWR_LoadMappedPatch PROC				; COMDAT

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 643  : 	if (!grmip->downloaded && !grmip->grInfo.data)

  00009	8b 45 08	 mov	 eax, DWORD PTR _grmip$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	75 3d		 jne	 SHORT $LN2@HWR_LoadMa
  00012	8b 45 08	 mov	 eax, DWORD PTR _grmip$[ebp]
  00015	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00019	75 34		 jne	 SHORT $LN2@HWR_LoadMa

; 644  : 	{
; 645  : 		patch_t *patch = W_CacheLumpNum(gpatch->patchlump, PU_STATIC);

  0001b	6a 01		 push	 1
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00020	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR _patch$1[ebp], eax

; 646  : 		HWR_MakePatch(patch, gpatch, grmip);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _grmip$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 fc	 mov	 edx, DWORD PTR _patch$1[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _HWR_MakePatch
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 
; 648  : 		Z_Free(patch);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _patch$1[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _Z_Free
  0004c	83 c4 04	 add	 esp, 4
$LN2@HWR_LoadMa:

; 649  : 	}
; 650  : 
; 651  : 	HWD.pfnSetTexture(grmip);

  0004f	8b 45 08	 mov	 eax, DWORD PTR _grmip$[ebp]
  00052	50		 push	 eax
  00053	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  00059	90		 npad	 1

; 652  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_HWR_LoadMappedPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_CacheFlat
_TEXT	SEGMENT
tv71 = -80						; size = 4
_pflatsize$ = -12					; size = 4
_size$ = -8						; size = 4
_block$ = -4						; size = 4
_grMipmap$ = 8						; size = 4
_flatlumpnum$ = 12					; size = 4
_HWR_CacheFlat PROC					; COMDAT

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 577  : 	UINT8 *block;
; 578  : 	size_t size, pflatsize;
; 579  : 
; 580  : 	// setup the texture info
; 581  : 	grMipmap->grInfo.smallLodLog2 = GR_LOD_LOG2_64;

  00009	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0000c	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6

; 582  : 	grMipmap->grInfo.largeLodLog2 = GR_LOD_LOG2_64;

  00012	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00015	c7 40 04 06 00
	00 00		 mov	 DWORD PTR [eax+4], 6

; 583  : 	grMipmap->grInfo.aspectRatioLog2 = GR_ASPECT_LOG2_1x1;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 584  : 	grMipmap->grInfo.format = GR_TEXFMT_P_8;

  00026	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00029	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [eax+12], 5

; 585  : 	grMipmap->flags = TF_WRAPXY|TF_CHROMAKEYED;

  00030	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00033	c7 40 14 13 00
	00 00		 mov	 DWORD PTR [eax+20], 19	; 00000013H

; 586  : 
; 587  : 	size = W_LumpLength(flatlumpnum);

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _flatlumpnum$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _W_LumpLength
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 588  : 
; 589  : 	switch (size)

  00049	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
  0004c	89 45 b0	 mov	 DWORD PTR tv71[ebp], eax
  0004f	81 7d b0 00 00
	04 00		 cmp	 DWORD PTR tv71[ebp], 262144 ; 00040000H
  00056	77 26		 ja	 SHORT $LN12@HWR_CacheF
  00058	81 7d b0 00 00
	04 00		 cmp	 DWORD PTR tv71[ebp], 262144 ; 00040000H
  0005f	74 43		 je	 SHORT $LN6@HWR_CacheF
  00061	81 7d b0 00 04
	00 00		 cmp	 DWORD PTR tv71[ebp], 1024 ; 00000400H
  00068	74 55		 je	 SHORT $LN9@HWR_CacheF
  0006a	81 7d b0 00 40
	00 00		 cmp	 DWORD PTR tv71[ebp], 16384 ; 00004000H
  00071	74 43		 je	 SHORT $LN8@HWR_CacheF
  00073	81 7d b0 00 00
	01 00		 cmp	 DWORD PTR tv71[ebp], 65536 ; 00010000H
  0007a	74 31		 je	 SHORT $LN7@HWR_CacheF
  0007c	eb 4a		 jmp	 SHORT $LN10@HWR_CacheF
$LN12@HWR_CacheF:
  0007e	81 7d b0 00 00
	10 00		 cmp	 DWORD PTR tv71[ebp], 1048576 ; 00100000H
  00085	74 14		 je	 SHORT $LN5@HWR_CacheF
  00087	81 7d b0 00 00
	40 00		 cmp	 DWORD PTR tv71[ebp], 4194304 ; 00400000H
  0008e	74 02		 je	 SHORT $LN4@HWR_CacheF
  00090	eb 36		 jmp	 SHORT $LN10@HWR_CacheF
$LN4@HWR_CacheF:

; 590  : 	{
; 591  : 		case 4194304: // 2048x2048 lump
; 592  : 			pflatsize = 2048;

  00092	c7 45 f4 00 08
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 2048 ; 00000800H

; 593  : 			break;

  00099	eb 34		 jmp	 SHORT $LN2@HWR_CacheF
$LN5@HWR_CacheF:

; 594  : 		case 1048576: // 1024x1024 lump
; 595  : 			pflatsize = 1024;

  0009b	c7 45 f4 00 04
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 1024 ; 00000400H

; 596  : 			break;

  000a2	eb 2b		 jmp	 SHORT $LN2@HWR_CacheF
$LN6@HWR_CacheF:

; 597  : 		case 262144:// 512x512 lump
; 598  : 			pflatsize = 512;

  000a4	c7 45 f4 00 02
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 512 ; 00000200H

; 599  : 			break;

  000ab	eb 22		 jmp	 SHORT $LN2@HWR_CacheF
$LN7@HWR_CacheF:

; 600  : 		case 65536: // 256x256 lump
; 601  : 			pflatsize = 256;

  000ad	c7 45 f4 00 01
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 256 ; 00000100H

; 602  : 			break;

  000b4	eb 19		 jmp	 SHORT $LN2@HWR_CacheF
$LN8@HWR_CacheF:

; 603  : 		case 16384: // 128x128 lump
; 604  : 			pflatsize = 128;

  000b6	c7 45 f4 80 00
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 128 ; 00000080H

; 605  : 			break;

  000bd	eb 10		 jmp	 SHORT $LN2@HWR_CacheF
$LN9@HWR_CacheF:

; 606  : 		case 1024: // 32x32 lump
; 607  : 			pflatsize = 32;

  000bf	c7 45 f4 20 00
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 32 ; 00000020H

; 608  : 			break;

  000c6	eb 07		 jmp	 SHORT $LN2@HWR_CacheF
$LN10@HWR_CacheF:

; 609  : 		default: // 64x64 lump
; 610  : 			pflatsize = 64;

  000c8	c7 45 f4 40 00
	00 00		 mov	 DWORD PTR _pflatsize$[ebp], 64 ; 00000040H
$LN2@HWR_CacheF:

; 611  : 			break;
; 612  : 	}
; 613  : 	grMipmap->width  = (UINT16)pflatsize;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000d2	66 8b 4d f4	 mov	 cx, WORD PTR _pflatsize$[ebp]
  000d6	66 89 48 1a	 mov	 WORD PTR [eax+26], cx

; 614  : 	grMipmap->height = (UINT16)pflatsize;

  000da	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000dd	66 8b 4d f4	 mov	 cx, WORD PTR _pflatsize$[ebp]
  000e1	66 89 48 18	 mov	 WORD PTR [eax+24], cx

; 615  : 
; 616  : 	// the flat raw data needn't be converted with palettized textures
; 617  : 	block = Z_Malloc(W_LumpLength(flatlumpnum),

  000e5	6a 00		 push	 0
  000e7	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000ea	83 c0 10	 add	 eax, 16			; 00000010H
  000ed	50		 push	 eax
  000ee	6a 66		 push	 102			; 00000066H
  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _flatlumpnum$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _W_LumpLength
  000f9	83 c4 04	 add	 esp, 4
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _Z_MallocAlign
  00102	83 c4 10	 add	 esp, 16			; 00000010H
  00105	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 618  : 		PU_HWRCACHE, &grMipmap->grInfo.data);
; 619  : 
; 620  : 	W_ReadLump(flatlumpnum, grMipmap->grInfo.data);

  00108	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0010b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0010e	51		 push	 ecx
  0010f	8b 55 0c	 mov	 edx, DWORD PTR _flatlumpnum$[ebp]
  00112	52		 push	 edx
  00113	e8 00 00 00 00	 call	 _W_ReadLump
  00118	83 c4 08	 add	 esp, 8

; 621  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
_HWR_CacheFlat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_GenerateTexture
_TEXT	SEGMENT
_col$1 = -32						; size = 4
_j$2 = -28						; size = 4
_skyspecial$ = -24					; size = 4
_i$ = -20						; size = 4
_realpatch$ = -16					; size = 4
_patch$ = -12						; size = 4
_texture$ = -8						; size = 4
_block$ = -4						; size = 4
_texnum$ = 8						; size = 4
_grtex$ = 12						; size = 4
_HWR_GenerateTexture PROC				; COMDAT

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 330  : 	UINT8 *block;
; 331  : 	texture_t *texture;
; 332  : 	texpatch_t *patch;
; 333  : 	patch_t *realpatch;
; 334  : 
; 335  : 	INT32 i;
; 336  : 	boolean skyspecial = false; //poor hack for Legacy large skies..

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _skyspecial$[ebp], 0

; 337  : 
; 338  : 	texture = textures[texnum];

  00010	8b 45 08	 mov	 eax, DWORD PTR _texnum$[ebp]
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  00019	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0001c	89 55 f8	 mov	 DWORD PTR _texture$[ebp], edx

; 339  : 
; 340  : 	// hack the Legacy skies..
; 341  : 	if (texture->name[0] == 'S' &&
; 342  : 	    texture->name[1] == 'K' &&
; 343  : 	    texture->name[2] == 'Y' &&

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	6b c8 00	 imul	 ecx, eax, 0
  00027	8b 55 f8	 mov	 edx, DWORD PTR _texture$[ebp]
  0002a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0002e	83 f8 53	 cmp	 eax, 83			; 00000053H
  00031	75 60		 jne	 SHORT $LN14@HWR_Genera
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	c1 e0 00	 shl	 eax, 0
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _texture$[ebp]
  0003e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00042	83 fa 4b	 cmp	 edx, 75			; 0000004bH
  00045	75 4c		 jne	 SHORT $LN14@HWR_Genera
  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	d1 e0		 shl	 eax, 1
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _texture$[ebp]
  00051	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00055	83 fa 59	 cmp	 edx, 89			; 00000059H
  00058	75 39		 jne	 SHORT $LN14@HWR_Genera
  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	c1 e0 02	 shl	 eax, 2
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _texture$[ebp]
  00065	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00069	85 d2		 test	 edx, edx
  0006b	74 13		 je	 SHORT $LN16@HWR_Genera
  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	6b c8 05	 imul	 ecx, eax, 5
  00075	8b 55 f8	 mov	 edx, DWORD PTR _texture$[ebp]
  00078	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0007c	85 c0		 test	 eax, eax
  0007e	75 13		 jne	 SHORT $LN14@HWR_Genera
$LN16@HWR_Genera:

; 344  : 	    (texture->name[4] == 0 ||
; 345  : 	     texture->name[5] == 0)
; 346  : 	   )
; 347  : 	{
; 348  : 		skyspecial = true;

  00080	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _skyspecial$[ebp], 1

; 349  : 		grtex->mipmap.flags = TF_WRAPXY; // don't use the chromakey for sky

  00087	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  0008a	c7 40 14 03 00
	00 00		 mov	 DWORD PTR [eax+20], 3

; 350  : 	}

  00091	eb 0a		 jmp	 SHORT $LN15@HWR_Genera
$LN14@HWR_Genera:

; 351  : 	else
; 352  : 		grtex->mipmap.flags = TF_CHROMAKEYED | TF_WRAPXY;

  00093	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  00096	c7 40 14 13 00
	00 00		 mov	 DWORD PTR [eax+20], 19	; 00000013H
$LN15@HWR_Genera:

; 353  : 
; 354  : 	HWR_ResizeBlock (texture->width, texture->height, &grtex->mipmap.grInfo);

  0009d	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _texture$[ebp]
  000a4	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  000a8	52		 push	 edx
  000a9	8b 45 f8	 mov	 eax, DWORD PTR _texture$[ebp]
  000ac	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _HWR_ResizeBlock
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 355  : 	grtex->mipmap.width = (UINT16)blockwidth;

  000b9	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  000bc	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _blockwidth
  000c3	66 89 48 1a	 mov	 WORD PTR [eax+26], cx

; 356  : 	grtex->mipmap.height = (UINT16)blockheight;

  000c7	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  000ca	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _blockheight
  000d1	66 89 48 18	 mov	 WORD PTR [eax+24], cx

; 357  : 	grtex->mipmap.grInfo.format = textureformat;

  000d5	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textureformat
  000de	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 358  : 
; 359  : 	block = MakeBlock(&grtex->mipmap);

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _MakeBlock
  000ea	83 c4 04	 add	 esp, 4
  000ed	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 360  : 
; 361  : 	if (skyspecial) //Hurdler: not efficient, but better than holes in the sky (and it's done only at level loading)

  000f0	83 7d e8 00	 cmp	 DWORD PTR _skyspecial$[ebp], 0
  000f4	0f 84 ae 00 00
	00		 je	 $LN3@HWR_Genera

; 362  : 	{
; 363  : 		INT32 j;
; 364  : 		RGBA_t col;
; 365  : 
; 366  : 		col = V_GetColor(HWR_CHROMAKEY_EQUIVALENTCOLORINDEX);

  000fa	b8 04 00 00 00	 mov	 eax, 4
  000ff	6b c8 1f	 imul	 ecx, eax, 31
  00102	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pLocalPalette
  00108	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0010b	89 45 e0	 mov	 DWORD PTR _col$1[ebp], eax

; 367  : 		for (j = 0; j < blockheight; j++)

  0010e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  00115	eb 09		 jmp	 SHORT $LN4@HWR_Genera
$LN2@HWR_Genera:
  00117	8b 45 e4	 mov	 eax, DWORD PTR _j$2[ebp]
  0011a	83 c0 01	 add	 eax, 1
  0011d	89 45 e4	 mov	 DWORD PTR _j$2[ebp], eax
$LN4@HWR_Genera:
  00120	8b 45 e4	 mov	 eax, DWORD PTR _j$2[ebp]
  00123	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blockheight
  00129	7d 7d		 jge	 SHORT $LN3@HWR_Genera

; 368  : 		{
; 369  : 			for (i = 0; i < blockwidth; i++)

  0012b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00132	eb 09		 jmp	 SHORT $LN7@HWR_Genera
$LN5@HWR_Genera:
  00134	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00137	83 c0 01	 add	 eax, 1
  0013a	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HWR_Genera:
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00140	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blockwidth
  00146	7d 5b		 jge	 SHORT $LN6@HWR_Genera

; 370  : 			{
; 371  : 				block[4*(j*blockwidth+i)+0] = col.s.red;

  00148	8b 45 e4	 mov	 eax, DWORD PTR _j$2[ebp]
  0014b	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _blockwidth
  00152	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00155	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  00158	8a 55 e0	 mov	 dl, BYTE PTR _col$1[ebp]
  0015b	88 14 81	 mov	 BYTE PTR [ecx+eax*4], dl

; 372  : 				block[4*(j*blockwidth+i)+1] = col.s.green;

  0015e	8b 45 e4	 mov	 eax, DWORD PTR _j$2[ebp]
  00161	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _blockwidth
  00168	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  0016e	8a 55 e1	 mov	 dl, BYTE PTR _col$1[ebp+1]
  00171	88 54 81 01	 mov	 BYTE PTR [ecx+eax*4+1], dl

; 373  : 				block[4*(j*blockwidth+i)+2] = col.s.blue;

  00175	8b 45 e4	 mov	 eax, DWORD PTR _j$2[ebp]
  00178	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _blockwidth
  0017f	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00182	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  00185	8a 55 e2	 mov	 dl, BYTE PTR _col$1[ebp+2]
  00188	88 54 81 02	 mov	 BYTE PTR [ecx+eax*4+2], dl

; 374  : 				block[4*(j*blockwidth+i)+3] = 0xff;

  0018c	8b 45 e4	 mov	 eax, DWORD PTR _j$2[ebp]
  0018f	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _blockwidth
  00196	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00199	8b 4d fc	 mov	 ecx, DWORD PTR _block$[ebp]
  0019c	c6 44 81 03 ff	 mov	 BYTE PTR [ecx+eax*4+3], 255 ; 000000ffH

; 375  : 			}

  001a1	eb 91		 jmp	 SHORT $LN5@HWR_Genera
$LN6@HWR_Genera:

; 376  : 		}

  001a3	e9 6f ff ff ff	 jmp	 $LN2@HWR_Genera
$LN3@HWR_Genera:

; 377  : 	}
; 378  : 
; 379  : 	// Composite the columns together.
; 380  : 	for (i = 0, patch = texture->patches; i < texture->patchcount; i++, patch++)

  001a8	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001af	8b 45 f8	 mov	 eax, DWORD PTR _texture$[ebp]
  001b2	83 c0 10	 add	 eax, 16			; 00000010H
  001b5	89 45 f4	 mov	 DWORD PTR _patch$[ebp], eax
  001b8	eb 12		 jmp	 SHORT $LN10@HWR_Genera
$LN8@HWR_Genera:
  001ba	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001bd	83 c0 01	 add	 eax, 1
  001c0	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  001c3	8b 4d f4	 mov	 ecx, DWORD PTR _patch$[ebp]
  001c6	83 c1 08	 add	 ecx, 8
  001c9	89 4d f4	 mov	 DWORD PTR _patch$[ebp], ecx
$LN10@HWR_Genera:
  001cc	8b 45 f8	 mov	 eax, DWORD PTR _texture$[ebp]
  001cf	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  001d3	39 4d ec	 cmp	 DWORD PTR _i$[ebp], ecx
  001d6	7d 78		 jge	 SHORT $LN9@HWR_Genera

; 381  : 	{
; 382  : 		realpatch = W_CacheLumpNum (patch->patch, PU_CACHE);

  001d8	6a 65		 push	 101			; 00000065H
  001da	8b 45 f4	 mov	 eax, DWORD PTR _patch$[ebp]
  001dd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 _W_CacheLumpNum
  001e6	83 c4 08	 add	 esp, 8
  001e9	89 45 f0	 mov	 DWORD PTR _realpatch$[ebp], eax

; 383  : 		HWR_DrawPatchInCache(&grtex->mipmap,

  001ec	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  001ef	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001f2	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _format2bpp[ecx*4]
  001f9	52		 push	 edx
  001fa	8b 45 f0	 mov	 eax, DWORD PTR _realpatch$[ebp]
  001fd	50		 push	 eax
  001fe	8b 4d f4	 mov	 ecx, DWORD PTR _patch$[ebp]
  00201	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00205	52		 push	 edx
  00206	8b 45 f4	 mov	 eax, DWORD PTR _patch$[ebp]
  00209	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0020c	51		 push	 ecx
  0020d	8b 55 f8	 mov	 edx, DWORD PTR _texture$[ebp]
  00210	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  00214	50		 push	 eax
  00215	8b 4d f8	 mov	 ecx, DWORD PTR _texture$[ebp]
  00218	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0021c	52		 push	 edx
  0021d	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  00220	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00223	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _blockwidth
  00229	0f af 14 8d 00
	00 00 00	 imul	 edx, DWORD PTR _format2bpp[ecx*4]
  00231	52		 push	 edx
  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockheight
  00237	50		 push	 eax
  00238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockwidth
  0023e	51		 push	 ecx
  0023f	8b 55 0c	 mov	 edx, DWORD PTR _grtex$[ebp]
  00242	52		 push	 edx
  00243	e8 00 00 00 00	 call	 _HWR_DrawPatchInCache
  00248	83 c4 28	 add	 esp, 40			; 00000028H

; 384  : 		                     blockwidth, blockheight,
; 385  : 		                     blockwidth*format2bpp[grtex->mipmap.grInfo.format],
; 386  : 		                     texture->width, texture->height,
; 387  : 		                     patch->originx, patch->originy,
; 388  : 		                     realpatch,
; 389  : 		                     format2bpp[grtex->mipmap.grInfo.format]);
; 390  : 	}

  0024b	e9 6a ff ff ff	 jmp	 $LN8@HWR_Genera
$LN9@HWR_Genera:

; 391  : 	//Hurdler: not efficient at all but I don't remember exactly how HWR_DrawPatchInCache works :(
; 392  : 	if (format2bpp[grtex->mipmap.grInfo.format]==4)

  00250	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  00253	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00256	83 3c 8d 00 00
	00 00 04	 cmp	 DWORD PTR _format2bpp[ecx*4], 4
  0025e	75 3d		 jne	 SHORT $LN12@HWR_Genera

; 393  : 	{
; 394  : 		for (i = 3; i < blocksize; i += 4)

  00260	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
  00267	eb 09		 jmp	 SHORT $LN13@HWR_Genera
$LN11@HWR_Genera:
  00269	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0026c	83 c0 04	 add	 eax, 4
  0026f	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN13@HWR_Genera:
  00272	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00275	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blocksize
  0027b	7d 20		 jge	 SHORT $LN12@HWR_Genera

; 395  : 		{
; 396  : 			if (block[i] == 0)

  0027d	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00280	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00283	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00286	85 c9		 test	 ecx, ecx
  00288	75 11		 jne	 SHORT $LN19@HWR_Genera

; 397  : 			{
; 398  : 				grtex->mipmap.flags |= TF_TRANSPARENT;

  0028a	8b 45 0c	 mov	 eax, DWORD PTR _grtex$[ebp]
  0028d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00290	83 c9 40	 or	 ecx, 64			; 00000040H
  00293	8b 55 0c	 mov	 edx, DWORD PTR _grtex$[ebp]
  00296	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 399  : 				break;

  00299	eb 02		 jmp	 SHORT $LN12@HWR_Genera
$LN19@HWR_Genera:

; 400  : 			}
; 401  : 		}

  0029b	eb cc		 jmp	 SHORT $LN11@HWR_Genera
$LN12@HWR_Genera:

; 402  : 	}
; 403  : 
; 404  : 	// make it purgable from zone memory
; 405  : 	// use PU_PURGELEVEL so we can Z_FreeTags all at once
; 406  : 	Z_ChangeTag (block, PU_HWRCACHE);

  0029d	6a 66		 push	 102			; 00000066H
  0029f	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 _Z_ChangeTag2
  002a8	83 c4 08	 add	 esp, 8

; 407  : 
; 408  : 	grtex->scaleX = 1.0f/(texture->width*FRACUNIT);

  002ab	8b 45 f8	 mov	 eax, DWORD PTR _texture$[ebp]
  002ae	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  002b2	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002b5	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  002b9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  002c1	f3 0f 5e c8	 divss	 xmm1, xmm0
  002c5	8b 55 0c	 mov	 edx, DWORD PTR _grtex$[ebp]
  002c8	f3 0f 11 4a 2c	 movss	 DWORD PTR [edx+44], xmm1

; 409  : 	grtex->scaleY = 1.0f/(texture->height*FRACUNIT);

  002cd	8b 45 f8	 mov	 eax, DWORD PTR _texture$[ebp]
  002d0	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  002d4	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002d7	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  002db	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  002e3	f3 0f 5e c8	 divss	 xmm1, xmm0
  002e7	8b 55 0c	 mov	 edx, DWORD PTR _grtex$[ebp]
  002ea	f3 0f 11 4a 30	 movss	 DWORD PTR [edx+48], xmm1

; 410  : }

  002ef	5f		 pop	 edi
  002f0	5e		 pop	 esi
  002f1	5b		 pop	 ebx
  002f2	8b e5		 mov	 esp, ebp
  002f4	5d		 pop	 ebp
  002f5	c3		 ret	 0
_HWR_GenerateTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _MakeBlock
_TEXT	SEGMENT
tv74 = -80						; size = 4
_i$ = -12						; size = 4
_block$ = -8						; size = 4
_bpp$ = -4						; size = 4
_grMipmap$ = 8						; size = 4
_MakeBlock PROC						; COMDAT

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 302  : 	INT32 bpp;
; 303  : 	UINT8 *block;
; 304  : 	INT32 i;
; 305  : 
; 306  : 	bpp =  format2bpp[grMipmap->grInfo.format];

  00009	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _format2bpp[ecx*4]
  00016	89 55 fc	 mov	 DWORD PTR _bpp$[ebp], edx

; 307  : 	block = Z_Malloc(blocksize*bpp, PU_STATIC, &(grMipmap->grInfo.data));

  00019	6a 00		 push	 0
  0001b	8b 45 08	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0001e	83 c0 10	 add	 eax, 16			; 00000010H
  00021	50		 push	 eax
  00022	6a 01		 push	 1
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blocksize
  0002a	0f af 4d fc	 imul	 ecx, DWORD PTR _bpp$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _Z_MallocAlign
  00034	83 c4 10	 add	 esp, 16			; 00000010H
  00037	89 45 f8	 mov	 DWORD PTR _block$[ebp], eax

; 308  : 
; 309  : 	switch (bpp)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _bpp$[ebp]
  0003d	89 45 b0	 mov	 DWORD PTR tv74[ebp], eax
  00040	83 7d b0 01	 cmp	 DWORD PTR tv74[ebp], 1
  00044	74 0e		 je	 SHORT $LN7@MakeBlock
  00046	83 7d b0 02	 cmp	 DWORD PTR tv74[ebp], 2
  0004a	74 21		 je	 SHORT $LN8@MakeBlock
  0004c	83 7d b0 04	 cmp	 DWORD PTR tv74[ebp], 4
  00050	74 4b		 je	 SHORT $LN9@MakeBlock
  00052	eb 60		 jmp	 SHORT $LN2@MakeBlock
$LN7@MakeBlock:

; 310  : 	{
; 311  : 		case 1: memset(block, HWR_PATCHES_CHROMAKEY_COLORINDEX, blocksize); break;

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _blocksize
  00059	50		 push	 eax
  0005a	68 f7 00 00 00	 push	 247			; 000000f7H
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _block$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _memset
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	eb 47		 jmp	 SHORT $LN2@MakeBlock
$LN8@MakeBlock:

; 312  : 		case 2:
; 313  : 				// fill background with chromakey, alpha = 0
; 314  : 				for (i = 0; i < blocksize; i++)

  0006d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00074	eb 09		 jmp	 SHORT $LN6@MakeBlock
$LN4@MakeBlock:
  00076	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN6@MakeBlock:
  0007f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00082	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blocksize
  00088	7d 11		 jge	 SHORT $LN5@MakeBlock

; 315  : 				//[segabor]
; 316  : 					*((UINT16 *)block+i) = ((0x00 <<8) | HWR_CHROMAKEY_EQUIVALENTCOLORINDEX);

  0008a	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  0008f	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00092	8b 55 f8	 mov	 edx, DWORD PTR _block$[ebp]
  00095	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00099	eb db		 jmp	 SHORT $LN4@MakeBlock
$LN5@MakeBlock:

; 317  : 				break;

  0009b	eb 17		 jmp	 SHORT $LN2@MakeBlock
$LN9@MakeBlock:

; 318  : 		case 4: memset(block,0,blocksize*4); break;

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _blocksize
  000a2	c1 e0 02	 shl	 eax, 2
  000a5	50		 push	 eax
  000a6	6a 00		 push	 0
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _block$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _memset
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@MakeBlock:

; 319  : 	}
; 320  : 
; 321  : 	return block;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _block$[ebp]

; 322  : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_MakeBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_ResizeBlock
_TEXT	SEGMENT
_min$ = -16						; size = 4
_max$ = -12						; size = 4
_k$ = -8						; size = 4
_j$ = -4						; size = 4
_originalwidth$ = 8					; size = 4
_originalheight$ = 12					; size = 4
_grInfo$ = 16						; size = 4
_HWR_ResizeBlock PROC					; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 186  : 	//   Build the full textures from patches.
; 187  : 	static const GrLOD_t gr_lods[9] =
; 188  : 	{
; 189  : 		GR_LOD_LOG2_256,
; 190  : 		GR_LOD_LOG2_128,
; 191  : 		GR_LOD_LOG2_64,
; 192  : 		GR_LOD_LOG2_32,
; 193  : 		GR_LOD_LOG2_16,
; 194  : 		GR_LOD_LOG2_8,
; 195  : 		GR_LOD_LOG2_4,
; 196  : 		GR_LOD_LOG2_2,
; 197  : 		GR_LOD_LOG2_1
; 198  : 	};
; 199  : 
; 200  : 	typedef struct
; 201  : 	{
; 202  : 		GrAspectRatio_t aspect;
; 203  : 		float           max_s;
; 204  : 		float           max_t;
; 205  : 	} booring_aspect_t;
; 206  : 
; 207  : 	static const booring_aspect_t gr_aspects[8] =
; 208  : 	{
; 209  : 		{GR_ASPECT_LOG2_1x1, 255, 255},
; 210  : 		{GR_ASPECT_LOG2_2x1, 255, 127},
; 211  : 		{GR_ASPECT_LOG2_4x1, 255,  63},
; 212  : 		{GR_ASPECT_LOG2_8x1, 255,  31},
; 213  : 
; 214  : 		{GR_ASPECT_LOG2_1x1, 255, 255},
; 215  : 		{GR_ASPECT_LOG2_1x2, 127, 255},
; 216  : 		{GR_ASPECT_LOG2_1x4,  63, 255},
; 217  : 		{GR_ASPECT_LOG2_1x8,  31, 255}
; 218  : 	};
; 219  : 
; 220  : 	INT32     j,k;
; 221  : 	INT32     max,min;
; 222  : 
; 223  : 	// find a power of 2 width/height
; 224  : 	//size up to nearest power of 2
; 225  : 	blockwidth = 1;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _blockwidth, 1
$LN2@HWR_Resize:

; 226  : 	while (blockwidth < originalwidth)

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  00018	3b 45 08	 cmp	 eax, DWORD PTR _originalwidth$[ebp]
  0001b	7d 0e		 jge	 SHORT $LN3@HWR_Resize

; 227  : 		blockwidth <<= 1;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  00022	d1 e0		 shl	 eax, 1
  00024	a3 00 00 00 00	 mov	 DWORD PTR _blockwidth, eax
  00029	eb e8		 jmp	 SHORT $LN2@HWR_Resize
$LN3@HWR_Resize:

; 228  : 	// scale down the original graphics to fit in 256
; 229  : 	if (blockwidth > 2048)

  0002b	81 3d 00 00 00
	00 00 08 00 00	 cmp	 DWORD PTR _blockwidth, 2048 ; 00000800H
  00035	7e 0a		 jle	 SHORT $LN12@HWR_Resize

; 230  : 		blockwidth = 2048;

  00037	c7 05 00 00 00
	00 00 08 00 00	 mov	 DWORD PTR _blockwidth, 2048 ; 00000800H
$LN12@HWR_Resize:

; 231  : 		//I_Error("3D GenerateTexture : too big");
; 232  : 
; 233  : 	//size up to nearest power of 2
; 234  : 	blockheight = 1;

  00041	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _blockheight, 1
$LN4@HWR_Resize:

; 235  : 	while (blockheight < originalheight)

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockheight
  00050	3b 45 0c	 cmp	 eax, DWORD PTR _originalheight$[ebp]
  00053	7d 0e		 jge	 SHORT $LN5@HWR_Resize

; 236  : 		blockheight <<= 1;

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockheight
  0005a	d1 e0		 shl	 eax, 1
  0005c	a3 00 00 00 00	 mov	 DWORD PTR _blockheight, eax
  00061	eb e8		 jmp	 SHORT $LN4@HWR_Resize
$LN5@HWR_Resize:

; 237  : 	// scale down the original graphics to fit in 256
; 238  : 	if (blockheight > 2048)

  00063	81 3d 00 00 00
	00 00 08 00 00	 cmp	 DWORD PTR _blockheight, 2048 ; 00000800H
  0006d	7e 0a		 jle	 SHORT $LN13@HWR_Resize

; 239  : 		blockheight = 2048;

  0006f	c7 05 00 00 00
	00 00 08 00 00	 mov	 DWORD PTR _blockheight, 2048 ; 00000800H
$LN13@HWR_Resize:

; 240  : 		//I_Error("3D GenerateTexture : too big");
; 241  : 
; 242  : 	// do the boring LOD stuff.. blech!
; 243  : 	if (blockwidth >= blockheight)

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  0007e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blockheight
  00084	7c 12		 jl	 SHORT $LN14@HWR_Resize

; 244  : 	{
; 245  : 		max = blockwidth;

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  0008b	89 45 f4	 mov	 DWORD PTR _max$[ebp], eax

; 246  : 		min = blockheight;

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockheight
  00093	89 45 f0	 mov	 DWORD PTR _min$[ebp], eax

; 247  : 	}

  00096	eb 10		 jmp	 SHORT $LN15@HWR_Resize
$LN14@HWR_Resize:

; 248  : 	else
; 249  : 	{
; 250  : 		max = blockheight;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockheight
  0009d	89 45 f4	 mov	 DWORD PTR _max$[ebp], eax

; 251  : 		min = blockwidth;

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  000a5	89 45 f0	 mov	 DWORD PTR _min$[ebp], eax
$LN15@HWR_Resize:

; 252  : 	}
; 253  : 
; 254  : 	for (k = 2048, j = 0; k > max; j++)

  000a8	c7 45 f8 00 08
	00 00		 mov	 DWORD PTR _k$[ebp], 2048 ; 00000800H
  000af	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000b6	eb 09		 jmp	 SHORT $LN8@HWR_Resize
$LN6@HWR_Resize:
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN8@HWR_Resize:
  000c1	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  000c4	3b 45 f4	 cmp	 eax, DWORD PTR _max$[ebp]
  000c7	7e 0a		 jle	 SHORT $LN7@HWR_Resize

; 255  : 		k>>=1;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  000cc	d1 f8		 sar	 eax, 1
  000ce	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
  000d1	eb e5		 jmp	 SHORT $LN6@HWR_Resize
$LN7@HWR_Resize:

; 256  : 	grInfo->smallLodLog2 = gr_lods[j];

  000d3	8b 45 10	 mov	 eax, DWORD PTR _grInfo$[ebp]
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _j$[ebp]
  000d9	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gr_lods@?1??HWR_ResizeBlock@@9@9[ecx*4]
  000e0	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 	grInfo->largeLodLog2 = gr_lods[j];

  000e2	8b 45 10	 mov	 eax, DWORD PTR _grInfo$[ebp]
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _j$[ebp]
  000e8	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gr_lods@?1??HWR_ResizeBlock@@9@9[ecx*4]
  000ef	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 258  : 
; 259  : 	for (k = max, j = 0; k > min && j < 4; j++)

  000f2	8b 45 f4	 mov	 eax, DWORD PTR _max$[ebp]
  000f5	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
  000f8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000ff	eb 09		 jmp	 SHORT $LN11@HWR_Resize
$LN9@HWR_Resize:
  00101	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN11@HWR_Resize:
  0010a	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  0010d	3b 45 f0	 cmp	 eax, DWORD PTR _min$[ebp]
  00110	7e 10		 jle	 SHORT $LN10@HWR_Resize
  00112	83 7d fc 04	 cmp	 DWORD PTR _j$[ebp], 4
  00116	7d 0a		 jge	 SHORT $LN10@HWR_Resize

; 260  : 		k>>=1;

  00118	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  0011b	d1 f8		 sar	 eax, 1
  0011d	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
  00120	eb df		 jmp	 SHORT $LN9@HWR_Resize
$LN10@HWR_Resize:

; 261  : 	// aspect ratio too small for 3Dfx (eg: 8x128 is 1x16 : use 1x8)
; 262  : 	if (j == 4)

  00122	83 7d fc 04	 cmp	 DWORD PTR _j$[ebp], 4
  00126	75 2c		 jne	 SHORT $LN18@HWR_Resize

; 263  : 	{
; 264  : 		j = 3;

  00128	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _j$[ebp], 3

; 265  : 		//CONS_Printf("HWR_ResizeBlock : bad aspect ratio %dx%d\n", blockwidth,blockheight);
; 266  : 		if (blockwidth < blockheight)

  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  00134	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blockheight
  0013a	7d 0d		 jge	 SHORT $LN17@HWR_Resize

; 267  : 			blockwidth = max>>3;

  0013c	8b 45 f4	 mov	 eax, DWORD PTR _max$[ebp]
  0013f	c1 f8 03	 sar	 eax, 3
  00142	a3 00 00 00 00	 mov	 DWORD PTR _blockwidth, eax
  00147	eb 0b		 jmp	 SHORT $LN18@HWR_Resize
$LN17@HWR_Resize:

; 268  : 		else
; 269  : 			blockheight = max>>3;

  00149	8b 45 f4	 mov	 eax, DWORD PTR _max$[ebp]
  0014c	c1 f8 03	 sar	 eax, 3
  0014f	a3 00 00 00 00	 mov	 DWORD PTR _blockheight, eax
$LN18@HWR_Resize:

; 270  : 	}
; 271  : 	if (blockwidth < blockheight)

  00154	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  00159	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _blockheight
  0015f	7d 09		 jge	 SHORT $LN19@HWR_Resize

; 272  : 		j += 4;

  00161	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  00164	83 c0 04	 add	 eax, 4
  00167	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN19@HWR_Resize:

; 273  : 	grInfo->aspectRatioLog2 = gr_aspects[j].aspect;

  0016a	6b 45 fc 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  0016e	8b 4d 10	 mov	 ecx, DWORD PTR _grInfo$[ebp]
  00171	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR ?gr_aspects@?1??HWR_ResizeBlock@@9@9[eax]
  00177	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 274  : 
; 275  : 	blocksize = blockwidth * blockheight;

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  0017f	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _blockheight
  00186	a3 00 00 00 00	 mov	 DWORD PTR _blocksize, eax

; 276  : 
; 277  : 	//CONS_Printf("Width is %d, Height is %d\n", blockwidth, blockheight);
; 278  : }

  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
_HWR_ResizeBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_DrawPatchInCache
_TEXT	SEGMENT
tv93 = -144						; size = 4
tv186 = -144						; size = 4
_texel$1 = -73						; size = 1
_block$ = -72						; size = 4
_alpha$ = -65						; size = 1
_patchcol$ = -64					; size = 4
_source$ = -60						; size = 4
_dest$ = -56						; size = 4
_colortemp$ = -52					; size = 4
_scale_y$ = -48						; size = 4
_count$ = -44						; size = 4
_position$ = -40					; size = 4
_yfracstep$ = -36					; size = 4
_yfrac$ = -32						; size = 4
_xfracstep$ = -28					; size = 4
_xfrac$ = -24						; size = 4
_ncols$ = -20						; size = 4
_col$ = -16						; size = 4
_x2$ = -12						; size = 4
_x1$ = -8						; size = 4
_x$ = -4						; size = 4
_mipmap$ = 8						; size = 4
_pblockwidth$ = 12					; size = 4
_pblockheight$ = 16					; size = 4
_blockmodulo$ = 20					; size = 4
_ptexturewidth$ = 24					; size = 4
_ptextureheight$ = 28					; size = 4
_originx$ = 32						; size = 4
_originy$ = 36						; size = 4
_realpatch$ = 40					; size = 4
_bpp$ = 44						; size = 4
_HWR_DrawPatchInCache PROC				; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 51   : 	INT32 x, x1, x2;
; 52   : 	INT32 col, ncols;
; 53   : 	fixed_t xfrac, xfracstep;
; 54   : 	fixed_t yfrac, yfracstep, position, count;
; 55   : 	fixed_t scale_y;
; 56   : 	RGBA_t colortemp;
; 57   : 	UINT8 *dest;
; 58   : 	const UINT8 *source;
; 59   : 	const column_t *patchcol;
; 60   : 	UINT8 alpha;
; 61   : 	UINT8 *block = mipmap->grInfo.data;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _mipmap$[ebp]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	89 4d b8	 mov	 DWORD PTR _block$[ebp], ecx

; 62   : 
; 63   : 	x1 = originx;

  00015	8b 45 20	 mov	 eax, DWORD PTR _originx$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _x1$[ebp], eax

; 64   : 	x2 = x1 + SHORT(realpatch->width);

  0001b	8b 45 28	 mov	 eax, DWORD PTR _realpatch$[ebp]
  0001e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00021	03 4d f8	 add	 ecx, DWORD PTR _x1$[ebp]
  00024	89 4d f4	 mov	 DWORD PTR _x2$[ebp], ecx

; 65   : 
; 66   : 	if (x1 < 0)

  00027	83 7d f8 00	 cmp	 DWORD PTR _x1$[ebp], 0
  0002b	7d 09		 jge	 SHORT $LN11@HWR_DrawPa

; 67   : 		x = 0;

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00034	eb 06		 jmp	 SHORT $LN12@HWR_DrawPa
$LN11@HWR_DrawPa:

; 68   : 	else
; 69   : 		x = x1;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _x1$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN12@HWR_DrawPa:

; 70   : 
; 71   : 	if (x2 > ptexturewidth)

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _x2$[ebp]
  0003f	3b 45 18	 cmp	 eax, DWORD PTR _ptexturewidth$[ebp]
  00042	7e 06		 jle	 SHORT $LN13@HWR_DrawPa

; 72   : 		x2 = ptexturewidth;

  00044	8b 45 18	 mov	 eax, DWORD PTR _ptexturewidth$[ebp]
  00047	89 45 f4	 mov	 DWORD PTR _x2$[ebp], eax
$LN13@HWR_DrawPa:

; 73   : 
; 74   : 	if (!ptexturewidth)

  0004a	83 7d 18 00	 cmp	 DWORD PTR _ptexturewidth$[ebp], 0
  0004e	75 05		 jne	 SHORT $LN14@HWR_DrawPa

; 75   : 		return;

  00050	e9 cf 02 00 00	 jmp	 $LN3@HWR_DrawPa
$LN14@HWR_DrawPa:

; 76   : 
; 77   : 	col = x * pblockwidth / ptexturewidth;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00058	0f af 45 0c	 imul	 eax, DWORD PTR _pblockwidth$[ebp]
  0005c	99		 cdq
  0005d	f7 7d 18	 idiv	 DWORD PTR _ptexturewidth$[ebp]
  00060	89 45 f0	 mov	 DWORD PTR _col$[ebp], eax

; 78   : 	ncols = ((x2 - x) * pblockwidth) / ptexturewidth;

  00063	8b 45 f4	 mov	 eax, DWORD PTR _x2$[ebp]
  00066	2b 45 fc	 sub	 eax, DWORD PTR _x$[ebp]
  00069	0f af 45 0c	 imul	 eax, DWORD PTR _pblockwidth$[ebp]
  0006d	99		 cdq
  0006e	f7 7d 18	 idiv	 DWORD PTR _ptexturewidth$[ebp]
  00071	89 45 ec	 mov	 DWORD PTR _ncols$[ebp], eax

; 79   : 
; 80   : /*
; 81   : 	CONS_Printf("patch %dx%d texture %dx%d block %dx%d\n", SHORT(realpatch->width),
; 82   : 															SHORT(realpatch->height),
; 83   : 															ptexturewidth,
; 84   : 															textureheight,
; 85   : 															pblockwidth,pblockheight);
; 86   : 	CONS_Printf("      col %d ncols %d x %d\n", col, ncols, x);
; 87   : */
; 88   : 
; 89   : 	// source advance
; 90   : 	xfrac = 0;

  00074	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _xfrac$[ebp], 0

; 91   : 	if (x1 < 0)

  0007b	83 7d f8 00	 cmp	 DWORD PTR _x1$[ebp], 0
  0007f	7d 0b		 jge	 SHORT $LN15@HWR_DrawPa

; 92   : 		xfrac = -x1<<FRACBITS;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _x1$[ebp]
  00084	f7 d8		 neg	 eax
  00086	c1 e0 10	 shl	 eax, 16			; 00000010H
  00089	89 45 e8	 mov	 DWORD PTR _xfrac$[ebp], eax
$LN15@HWR_DrawPa:

; 93   : 
; 94   : 	xfracstep = (ptexturewidth << FRACBITS) / pblockwidth;

  0008c	8b 45 18	 mov	 eax, DWORD PTR _ptexturewidth$[ebp]
  0008f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00092	99		 cdq
  00093	f7 7d 0c	 idiv	 DWORD PTR _pblockwidth$[ebp]
  00096	89 45 e4	 mov	 DWORD PTR _xfracstep$[ebp], eax

; 95   : 	yfracstep = (ptextureheight<< FRACBITS) / pblockheight;

  00099	8b 45 1c	 mov	 eax, DWORD PTR _ptextureheight$[ebp]
  0009c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0009f	99		 cdq
  000a0	f7 7d 10	 idiv	 DWORD PTR _pblockheight$[ebp]
  000a3	89 45 dc	 mov	 DWORD PTR _yfracstep$[ebp], eax

; 96   : 	if (bpp < 1 || bpp > 4)

  000a6	83 7d 2c 01	 cmp	 DWORD PTR _bpp$[ebp], 1
  000aa	7c 06		 jl	 SHORT $LN17@HWR_DrawPa
  000ac	83 7d 2c 04	 cmp	 DWORD PTR _bpp$[ebp], 4
  000b0	7e 11		 jle	 SHORT $LN16@HWR_DrawPa
$LN17@HWR_DrawPa:

; 97   : 		I_Error("HWR_DrawPatchInCache: no drawer defined for this bpp (%d)\n",bpp);

  000b2	8b 45 2c	 mov	 eax, DWORD PTR _bpp$[ebp]
  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@JJMIDDCD@HWR_DrawPatchInCache?3?5no?5drawer@
  000bb	e8 00 00 00 00	 call	 _I_Error
  000c0	83 c4 08	 add	 esp, 8
$LN16@HWR_DrawPa:

; 98   : 
; 99   : 	for (block += col*bpp; ncols--; block += bpp, xfrac += xfracstep)

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _col$[ebp]
  000c6	0f af 45 2c	 imul	 eax, DWORD PTR _bpp$[ebp]
  000ca	03 45 b8	 add	 eax, DWORD PTR _block$[ebp]
  000cd	89 45 b8	 mov	 DWORD PTR _block$[ebp], eax
  000d0	eb 12		 jmp	 SHORT $LN4@HWR_DrawPa
$LN2@HWR_DrawPa:
  000d2	8b 45 b8	 mov	 eax, DWORD PTR _block$[ebp]
  000d5	03 45 2c	 add	 eax, DWORD PTR _bpp$[ebp]
  000d8	89 45 b8	 mov	 DWORD PTR _block$[ebp], eax
  000db	8b 4d e8	 mov	 ecx, DWORD PTR _xfrac$[ebp]
  000de	03 4d e4	 add	 ecx, DWORD PTR _xfracstep$[ebp]
  000e1	89 4d e8	 mov	 DWORD PTR _xfrac$[ebp], ecx
$LN4@HWR_DrawPa:
  000e4	8b 45 ec	 mov	 eax, DWORD PTR _ncols$[ebp]
  000e7	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR _ncols$[ebp]
  000f0	83 e9 01	 sub	 ecx, 1
  000f3	89 4d ec	 mov	 DWORD PTR _ncols$[ebp], ecx
  000f6	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv93[ebp], 0
  000fd	0f 84 21 02 00
	00		 je	 $LN3@HWR_DrawPa

; 100  : 	{
; 101  : 		patchcol = (const column_t *)((const UINT8 *)realpatch

  00103	8b 45 e8	 mov	 eax, DWORD PTR _xfrac$[ebp]
  00106	c1 f8 10	 sar	 eax, 16			; 00000010H
  00109	8b 4d 28	 mov	 ecx, DWORD PTR _realpatch$[ebp]
  0010c	8b 55 28	 mov	 edx, DWORD PTR _realpatch$[ebp]
  0010f	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  00113	89 55 c0	 mov	 DWORD PTR _patchcol$[ebp], edx

; 102  : 		 + LONG(realpatch->columnofs[xfrac>>FRACBITS]));
; 103  : 
; 104  : 		scale_y = (pblockheight << FRACBITS) / ptextureheight;

  00116	8b 45 10	 mov	 eax, DWORD PTR _pblockheight$[ebp]
  00119	c1 e0 10	 shl	 eax, 16			; 00000010H
  0011c	99		 cdq
  0011d	f7 7d 1c	 idiv	 DWORD PTR _ptextureheight$[ebp]
  00120	89 45 d0	 mov	 DWORD PTR _scale_y$[ebp], eax
$LN5@HWR_DrawPa:

; 105  : 
; 106  : 		while (patchcol->topdelta != 0xff)

  00123	8b 45 c0	 mov	 eax, DWORD PTR _patchcol$[ebp]
  00126	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00129	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0012f	0f 84 ea 01 00
	00		 je	 $LN6@HWR_DrawPa

; 107  : 		{
; 108  : 			source = (const UINT8 *)patchcol + 3;

  00135	8b 45 c0	 mov	 eax, DWORD PTR _patchcol$[ebp]
  00138	83 c0 03	 add	 eax, 3
  0013b	89 45 c4	 mov	 DWORD PTR _source$[ebp], eax

; 109  : 			count  = ((patchcol->length * scale_y) + (FRACUNIT/2)) >> FRACBITS;

  0013e	8b 45 c0	 mov	 eax, DWORD PTR _patchcol$[ebp]
  00141	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00145	0f af 4d d0	 imul	 ecx, DWORD PTR _scale_y$[ebp]
  00149	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  0014f	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00152	89 4d d4	 mov	 DWORD PTR _count$[ebp], ecx

; 110  : 			position = originy + patchcol->topdelta;

  00155	8b 45 c0	 mov	 eax, DWORD PTR _patchcol$[ebp]
  00158	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0015b	03 4d 24	 add	 ecx, DWORD PTR _originy$[ebp]
  0015e	89 4d d8	 mov	 DWORD PTR _position$[ebp], ecx

; 111  : 
; 112  : 			yfrac = 0;

  00161	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _yfrac$[ebp], 0

; 113  : 			//yfracstep = (patchcol->length << FRACBITS) / count;
; 114  : 			if (position < 0)

  00168	83 7d d8 00	 cmp	 DWORD PTR _position$[ebp], 0
  0016c	7d 27		 jge	 SHORT $LN18@HWR_DrawPa

; 115  : 			{
; 116  : 				yfrac = -position<<FRACBITS;

  0016e	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  00171	f7 d8		 neg	 eax
  00173	c1 e0 10	 shl	 eax, 16			; 00000010H
  00176	89 45 e0	 mov	 DWORD PTR _yfrac$[ebp], eax

; 117  : 				count += (((position * scale_y) + (FRACUNIT/2)) >> FRACBITS);

  00179	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  0017c	0f af 45 d0	 imul	 eax, DWORD PTR _scale_y$[ebp]
  00180	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  00185	c1 f8 10	 sar	 eax, 16			; 00000010H
  00188	03 45 d4	 add	 eax, DWORD PTR _count$[ebp]
  0018b	89 45 d4	 mov	 DWORD PTR _count$[ebp], eax

; 118  : 				position = 0;

  0018e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _position$[ebp], 0
$LN18@HWR_DrawPa:

; 119  : 			}
; 120  : 
; 121  : 			position = ((position * scale_y) + (FRACUNIT/2)) >> FRACBITS;

  00195	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  00198	0f af 45 d0	 imul	 eax, DWORD PTR _scale_y$[ebp]
  0019c	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  001a1	c1 f8 10	 sar	 eax, 16			; 00000010H
  001a4	89 45 d8	 mov	 DWORD PTR _position$[ebp], eax

; 122  : 
; 123  : 			if (position < 0)

  001a7	83 7d d8 00	 cmp	 DWORD PTR _position$[ebp], 0
  001ab	7d 07		 jge	 SHORT $LN19@HWR_DrawPa

; 124  : 				position = 0;

  001ad	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _position$[ebp], 0
$LN19@HWR_DrawPa:

; 125  : 
; 126  : 			if (position + count >= pblockheight)

  001b4	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  001b7	03 45 d4	 add	 eax, DWORD PTR _count$[ebp]
  001ba	3b 45 10	 cmp	 eax, DWORD PTR _pblockheight$[ebp]
  001bd	7c 09		 jl	 SHORT $LN20@HWR_DrawPa

; 127  : 				count = pblockheight - position;

  001bf	8b 45 10	 mov	 eax, DWORD PTR _pblockheight$[ebp]
  001c2	2b 45 d8	 sub	 eax, DWORD PTR _position$[ebp]
  001c5	89 45 d4	 mov	 DWORD PTR _count$[ebp], eax
$LN20@HWR_DrawPa:

; 128  : 
; 129  : 			dest = block + (position*blockmodulo);

  001c8	8b 45 d8	 mov	 eax, DWORD PTR _position$[ebp]
  001cb	0f af 45 14	 imul	 eax, DWORD PTR _blockmodulo$[ebp]
  001cf	03 45 b8	 add	 eax, DWORD PTR _block$[ebp]
  001d2	89 45 c8	 mov	 DWORD PTR _dest$[ebp], eax
$LN7@HWR_DrawPa:

; 130  : 			while (count > 0)

  001d5	83 7d d4 00	 cmp	 DWORD PTR _count$[ebp], 0
  001d9	0f 8e 2a 01 00
	00		 jle	 $LN8@HWR_DrawPa

; 131  : 			{
; 132  : 				UINT8 texel;
; 133  : 				count--;

  001df	8b 45 d4	 mov	 eax, DWORD PTR _count$[ebp]
  001e2	83 e8 01	 sub	 eax, 1
  001e5	89 45 d4	 mov	 DWORD PTR _count$[ebp], eax

; 134  : 
; 135  : 				texel = source[yfrac>>FRACBITS];

  001e8	8b 45 e0	 mov	 eax, DWORD PTR _yfrac$[ebp]
  001eb	c1 f8 10	 sar	 eax, 16			; 00000010H
  001ee	8b 4d c4	 mov	 ecx, DWORD PTR _source$[ebp]
  001f1	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001f4	88 55 b7	 mov	 BYTE PTR _texel$1[ebp], dl

; 136  : 
; 137  : 				if (firetranslucent && (transtables[(texel<<8)+0x40000]!=texel))

  001f7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _firetranslucent, 0
  001fe	74 23		 je	 SHORT $LN21@HWR_DrawPa
  00200	0f b6 45 b7	 movzx	 eax, BYTE PTR _texel$1[ebp]
  00204	c1 e0 08	 shl	 eax, 8
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _transtables
  0020d	0f b6 94 01 00
	00 04 00	 movzx	 edx, BYTE PTR [ecx+eax+262144]
  00215	0f b6 45 b7	 movzx	 eax, BYTE PTR _texel$1[ebp]
  00219	3b d0		 cmp	 edx, eax
  0021b	74 06		 je	 SHORT $LN21@HWR_DrawPa

; 138  : 					alpha = 0x80;

  0021d	c6 45 bf 80	 mov	 BYTE PTR _alpha$[ebp], 128 ; 00000080H
  00221	eb 04		 jmp	 SHORT $LN22@HWR_DrawPa
$LN21@HWR_DrawPa:

; 139  : 				else
; 140  : 					alpha = 0xff;

  00223	c6 45 bf ff	 mov	 BYTE PTR _alpha$[ebp], 255 ; 000000ffH
$LN22@HWR_DrawPa:

; 141  : 
; 142  : 				//Hurdler: not perfect, but better than holes
; 143  : 				if (texel == HWR_PATCHES_CHROMAKEY_COLORINDEX && (mipmap->flags & TF_CHROMAKEYED))

  00227	0f b6 45 b7	 movzx	 eax, BYTE PTR _texel$1[ebp]
  0022b	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00230	75 11		 jne	 SHORT $LN23@HWR_DrawPa
  00232	8b 45 08	 mov	 eax, DWORD PTR _mipmap$[ebp]
  00235	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00238	83 e1 10	 and	 ecx, 16			; 00000010H
  0023b	74 06		 je	 SHORT $LN23@HWR_DrawPa

; 144  : 					texel = HWR_CHROMAKEY_EQUIVALENTCOLORINDEX;

  0023d	c6 45 b7 1f	 mov	 BYTE PTR _texel$1[ebp], 31 ; 0000001fH
  00241	eb 19		 jmp	 SHORT $LN25@HWR_DrawPa
$LN23@HWR_DrawPa:

; 145  : 				//Hurdler: 25/04/2000: now support colormap in hardware mode
; 146  : 				else if (mipmap->colormap)

  00243	8b 45 08	 mov	 eax, DWORD PTR _mipmap$[ebp]
  00246	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0024a	74 10		 je	 SHORT $LN25@HWR_DrawPa

; 147  : 					texel = mipmap->colormap[texel];

  0024c	0f b6 45 b7	 movzx	 eax, BYTE PTR _texel$1[ebp]
  00250	8b 4d 08	 mov	 ecx, DWORD PTR _mipmap$[ebp]
  00253	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00256	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00259	88 45 b7	 mov	 BYTE PTR _texel$1[ebp], al
$LN25@HWR_DrawPa:

; 148  : 
; 149  : 				// hope compiler will get this switch out of the loops (dreams...)
; 150  : 				// gcc do it ! but vcc not ! (why don't use cygwin gcc for win32 ?)
; 151  : 				// Alam: SRB2 uses Mingw, HUGS
; 152  : 				switch (bpp)

  0025c	8b 45 2c	 mov	 eax, DWORD PTR _bpp$[ebp]
  0025f	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], eax
  00265	83 bd 70 ff ff
	ff 02		 cmp	 DWORD PTR tv186[ebp], 2
  0026c	74 14		 je	 SHORT $LN26@HWR_DrawPa
  0026e	83 bd 70 ff ff
	ff 03		 cmp	 DWORD PTR tv186[ebp], 3
  00275	74 20		 je	 SHORT $LN27@HWR_DrawPa
  00277	83 bd 70 ff ff
	ff 04		 cmp	 DWORD PTR tv186[ebp], 4
  0027e	74 48		 je	 SHORT $LN28@HWR_DrawPa
  00280	eb 68		 jmp	 SHORT $LN29@HWR_DrawPa
$LN26@HWR_DrawPa:

; 153  : 				{
; 154  : 					case 2 : *((UINT16 *)dest) = (UINT16)((alpha<<8) | texel);

  00282	0f b6 45 bf	 movzx	 eax, BYTE PTR _alpha$[ebp]
  00286	c1 e0 08	 shl	 eax, 8
  00289	0f b6 4d b7	 movzx	 ecx, BYTE PTR _texel$1[ebp]
  0028d	0b c1		 or	 eax, ecx
  0028f	8b 55 c8	 mov	 edx, DWORD PTR _dest$[ebp]
  00292	66 89 02	 mov	 WORD PTR [edx], ax

; 155  : 					         break;

  00295	eb 5b		 jmp	 SHORT $LN9@HWR_DrawPa
$LN27@HWR_DrawPa:

; 156  : 					case 3 : colortemp = V_GetColor(texel);

  00297	0f b6 45 b7	 movzx	 eax, BYTE PTR _texel$1[ebp]
  0029b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  002a6	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002a9	89 55 cc	 mov	 DWORD PTR _colortemp$[ebp], edx

; 157  : 					         ((RGBA_t *)dest)->s.red   = colortemp.s.red;

  002ac	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002af	8a 4d cc	 mov	 cl, BYTE PTR _colortemp$[ebp]
  002b2	88 08		 mov	 BYTE PTR [eax], cl

; 158  : 					         ((RGBA_t *)dest)->s.green = colortemp.s.green;

  002b4	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002b7	8a 4d cd	 mov	 cl, BYTE PTR _colortemp$[ebp+1]
  002ba	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 159  : 					         ((RGBA_t *)dest)->s.blue  = colortemp.s.blue;

  002bd	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002c0	8a 4d ce	 mov	 cl, BYTE PTR _colortemp$[ebp+2]
  002c3	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 160  : 					         break;

  002c6	eb 2a		 jmp	 SHORT $LN9@HWR_DrawPa
$LN28@HWR_DrawPa:

; 161  : 					case 4 : *((RGBA_t *)dest) = V_GetColor(texel);

  002c8	0f b6 45 b7	 movzx	 eax, BYTE PTR _texel$1[ebp]
  002cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  002d7	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002da	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002dd	89 10		 mov	 DWORD PTR [eax], edx

; 162  : 					         ((RGBA_t *)dest)->s.alpha = alpha;

  002df	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002e2	8a 4d bf	 mov	 cl, BYTE PTR _alpha$[ebp]
  002e5	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 163  : 					         break;

  002e8	eb 08		 jmp	 SHORT $LN9@HWR_DrawPa
$LN29@HWR_DrawPa:

; 164  : 					// default is 1
; 165  : 					default: *dest = texel;

  002ea	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002ed	8a 4d b7	 mov	 cl, BYTE PTR _texel$1[ebp]
  002f0	88 08		 mov	 BYTE PTR [eax], cl
$LN9@HWR_DrawPa:

; 166  : 					         break;
; 167  : 				}
; 168  : 
; 169  : 				dest += blockmodulo;

  002f2	8b 45 c8	 mov	 eax, DWORD PTR _dest$[ebp]
  002f5	03 45 14	 add	 eax, DWORD PTR _blockmodulo$[ebp]
  002f8	89 45 c8	 mov	 DWORD PTR _dest$[ebp], eax

; 170  : 				yfrac += yfracstep;

  002fb	8b 45 e0	 mov	 eax, DWORD PTR _yfrac$[ebp]
  002fe	03 45 dc	 add	 eax, DWORD PTR _yfracstep$[ebp]
  00301	89 45 e0	 mov	 DWORD PTR _yfrac$[ebp], eax

; 171  : 			}

  00304	e9 cc fe ff ff	 jmp	 $LN7@HWR_DrawPa
$LN8@HWR_DrawPa:

; 172  : 			patchcol = (const column_t *)((const UINT8 *)patchcol + patchcol->length + 4);

  00309	8b 45 c0	 mov	 eax, DWORD PTR _patchcol$[ebp]
  0030c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00310	8b 55 c0	 mov	 edx, DWORD PTR _patchcol$[ebp]
  00313	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00317	89 45 c0	 mov	 DWORD PTR _patchcol$[ebp], eax

; 173  : 		}

  0031a	e9 04 fe ff ff	 jmp	 $LN5@HWR_DrawPa
$LN6@HWR_DrawPa:

; 174  : 	}

  0031f	e9 ae fd ff ff	 jmp	 $LN2@HWR_DrawPa
$LN3@HWR_DrawPa:

; 175  : }

  00324	5f		 pop	 edi
  00325	5e		 pop	 esi
  00326	5b		 pop	 ebx
  00327	8b e5		 mov	 esp, ebp
  00329	5d		 pop	 ebp
  0032a	c3		 ret	 0
_HWR_DrawPatchInCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_SetPalette
_TEXT	SEGMENT
_gamma_correction$ = -4					; size = 4
_palette$ = 8						; size = 4
_HWR_SetPalette PROC					; COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  : 	//Hudler: 16/10/99: added for OpenGL gamma correction
; 537  : #ifdef HARDWAREFIX
; 538  : 	RGBA_t gamma_correction = {0x00000000};

  00009	33 c0		 xor	 eax, eax
  0000b	89 45 fc	 mov	 DWORD PTR _gamma_correction$[ebp], eax

; 539  : #else
; 540  : 	RGBA_t gamma_correction = {0x7F7F7F7F};
; 541  : #endif
; 542  : 
; 543  : 	//Hurdler 16/10/99: added for OpenGL gamma correction
; 544  : 	gamma_correction.s.red   = (UINT8)cv_grgammared.value;

  0000e	a0 14 00 00 00	 mov	 al, BYTE PTR _cv_grgammared+20
  00013	88 45 fc	 mov	 BYTE PTR _gamma_correction$[ebp], al

; 545  : 	gamma_correction.s.green = (UINT8)cv_grgammagreen.value;

  00016	a0 14 00 00 00	 mov	 al, BYTE PTR _cv_grgammagreen+20
  0001b	88 45 fd	 mov	 BYTE PTR _gamma_correction$[ebp+1], al

; 546  : 	gamma_correction.s.blue  = (UINT8)cv_grgammablue.value;

  0001e	a0 14 00 00 00	 mov	 al, BYTE PTR _cv_grgammablue+20
  00023	88 45 fe	 mov	 BYTE PTR _gamma_correction$[ebp+2], al

; 547  : 	HWD.pfnSetPalette(palette, &gamma_correction);

  00026	8d 45 fc	 lea	 eax, DWORD PTR _gamma_correction$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  0002d	51		 push	 ecx
  0002e	ff 15 04 00 00
	00		 call	 DWORD PTR _hwdriver+4
  00034	90		 npad	 1

; 548  : 
; 549  : 	// hardware driver will flush there own cache if cache is non paletized
; 550  : 	// now flush data texture cache so 32 bit texture are recomputed
; 551  : 	if (patchformat == GR_RGBA || textureformat == GR_RGBA)

  00035	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _patchformat, 6
  0003c	74 09		 je	 SHORT $LN3@HWR_SetPal
  0003e	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _textureformat, 6
  00045	75 0c		 jne	 SHORT $LN2@HWR_SetPal
$LN3@HWR_SetPal:

; 552  : 		Z_FreeTags(PU_HWRCACHE, PU_HWRCACHE);

  00047	6a 66		 push	 102			; 00000066H
  00049	6a 66		 push	 102			; 00000066H
  0004b	e8 00 00 00 00	 call	 _Z_FreeTags
  00050	83 c4 08	 add	 esp, 8
$LN2@HWR_SetPal:

; 553  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_HWR_SetPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_GetPic
_TEXT	SEGMENT
tv148 = -92						; size = 4
tv154 = -92						; size = 4
_newheight$1 = -24					; size = 4
_newwidth$2 = -20					; size = 4
_len$3 = -16						; size = 4
_block$4 = -12						; size = 4
_pic$5 = -8						; size = 4
_grpatch$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_HWR_GetPic PROC					; COMDAT

; 796  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 797  : 	GLPatch_t *grpatch;
; 798  : 
; 799  : 	grpatch = &(wadfiles[lumpnum>>16]->hwrcache[lumpnum & 0xffff]);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0000f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00016	8b 55 08	 mov	 edx, DWORD PTR _lumpnum$[ebp]
  00019	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0001f	c1 e2 06	 shl	 edx, 6
  00022	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  00025	89 55 fc	 mov	 DWORD PTR _grpatch$[ebp], edx

; 800  : 
; 801  : 	if (!grpatch->mipmap.downloaded && !grpatch->mipmap.grInfo.data)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0002b	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0002f	0f 85 26 02 00
	00		 jne	 $LN2@HWR_GetPic
  00035	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00038	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0003c	0f 85 19 02 00
	00		 jne	 $LN2@HWR_GetPic

; 802  : 	{
; 803  : 		pic_t *pic;
; 804  : 		UINT8 *block;
; 805  : 		size_t len;
; 806  : 		INT32 newwidth, newheight;
; 807  : 
; 808  : 		pic = W_CacheLumpNum(lumpnum, PU_STATIC);

  00042	6a 01		 push	 1
  00044	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0004d	83 c4 08	 add	 esp, 8
  00050	89 45 f8	 mov	 DWORD PTR _pic$5[ebp], eax

; 809  : 		grpatch->width = SHORT(pic->width);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _pic$5[ebp]
  00059	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0005c	66 89 10	 mov	 WORD PTR [eax], dx

; 810  : 		grpatch->height = SHORT(pic->height);

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _pic$5[ebp]
  00065	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00069	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 811  : 		len = W_LumpLength(lumpnum) - sizeof (pic_t);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _W_LumpLength
  00076	83 c4 04	 add	 esp, 4
  00079	83 e8 08	 sub	 eax, 8
  0007c	89 45 f0	 mov	 DWORD PTR _len$3[ebp], eax

; 812  : 
; 813  : 		grpatch->leftoffset = 0;

  0007f	33 c0		 xor	 eax, eax
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _grpatch$[ebp]
  00084	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 814  : 		grpatch->topoffset = 0;

  00088	33 c0		 xor	 eax, eax
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _grpatch$[ebp]
  0008d	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 815  : 
; 816  : 		// find the good 3dfx size (boring spec)
; 817  : 		HWR_ResizeBlock (grpatch->width, grpatch->height, &grpatch->mipmap.grInfo);

  00091	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00094	83 c0 14	 add	 eax, 20			; 00000014H
  00097	50		 push	 eax
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _grpatch$[ebp]
  0009b	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0009f	52		 push	 edx
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000a3	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _HWR_ResizeBlock
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 818  : 		grpatch->mipmap.width = (UINT16)blockwidth;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000b2	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _blockwidth
  000b9	66 89 48 2e	 mov	 WORD PTR [eax+46], cx

; 819  : 		grpatch->mipmap.height = (UINT16)blockheight;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000c0	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _blockheight
  000c7	66 89 48 2c	 mov	 WORD PTR [eax+44], cx

; 820  : 
; 821  : 		if (pic->mode == PALETTE)

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _pic$5[ebp]
  000ce	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000d2	85 c9		 test	 ecx, ecx
  000d4	75 0e		 jne	 SHORT $LN3@HWR_GetPic

; 822  : 			grpatch->mipmap.grInfo.format = textureformat; // can be set by driver

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textureformat
  000df	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  000e2	eb 14		 jmp	 SHORT $LN4@HWR_GetPic
$LN3@HWR_GetPic:

; 823  : 		else
; 824  : 			grpatch->mipmap.grInfo.format = picmode2GR[pic->mode];

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _pic$5[ebp]
  000e7	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000eb	8b 55 fc	 mov	 edx, DWORD PTR _grpatch$[ebp]
  000ee	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR _picmode2GR[ecx*4]
  000f5	89 42 20	 mov	 DWORD PTR [edx+32], eax
$LN4@HWR_GetPic:

; 825  : 
; 826  : 		Z_Free(grpatch->mipmap.grInfo.data);

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000fb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _Z_Free
  00104	83 c4 04	 add	 esp, 4

; 827  : 
; 828  : 		// allocate block
; 829  : 		block = MakeBlock(&grpatch->mipmap);

  00107	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0010a	83 c0 14	 add	 eax, 20			; 00000014H
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _MakeBlock
  00113	83 c4 04	 add	 esp, 4
  00116	89 45 f4	 mov	 DWORD PTR _block$4[ebp], eax

; 830  : 
; 831  : 		// no rounddown, do not size up patches, so they don't look 'scaled'
; 832  : 		newwidth  = min(SHORT(pic->width),blockwidth);

  00119	8b 45 f8	 mov	 eax, DWORD PTR _pic$5[ebp]
  0011c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0011f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _blockwidth
  00125	7d 0b		 jge	 SHORT $LN8@HWR_GetPic
  00127	8b 55 f8	 mov	 edx, DWORD PTR _pic$5[ebp]
  0012a	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0012d	89 45 a4	 mov	 DWORD PTR tv148[ebp], eax
  00130	eb 09		 jmp	 SHORT $LN9@HWR_GetPic
$LN8@HWR_GetPic:
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockwidth
  00138	89 4d a4	 mov	 DWORD PTR tv148[ebp], ecx
$LN9@HWR_GetPic:
  0013b	8b 55 a4	 mov	 edx, DWORD PTR tv148[ebp]
  0013e	89 55 ec	 mov	 DWORD PTR _newwidth$2[ebp], edx

; 833  : 		newheight = min(SHORT(pic->height),blockheight);

  00141	8b 45 f8	 mov	 eax, DWORD PTR _pic$5[ebp]
  00144	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00148	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _blockheight
  0014e	7d 0c		 jge	 SHORT $LN10@HWR_GetPic
  00150	8b 55 f8	 mov	 edx, DWORD PTR _pic$5[ebp]
  00153	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  00157	89 45 a4	 mov	 DWORD PTR tv154[ebp], eax
  0015a	eb 09		 jmp	 SHORT $LN11@HWR_GetPic
$LN10@HWR_GetPic:
  0015c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockheight
  00162	89 4d a4	 mov	 DWORD PTR tv154[ebp], ecx
$LN11@HWR_GetPic:
  00165	8b 55 a4	 mov	 edx, DWORD PTR tv154[ebp]
  00168	89 55 e8	 mov	 DWORD PTR _newheight$1[ebp], edx

; 834  : 
; 835  : 		if (grpatch->width  == blockwidth &&
; 836  : 			grpatch->height == blockheight &&

  0016b	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0016e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00171	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _blockwidth
  00177	75 50		 jne	 SHORT $LN5@HWR_GetPic
  00179	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0017c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00180	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _blockheight
  00186	75 41		 jne	 SHORT $LN5@HWR_GetPic
  00188	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0018b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0018e	8b 55 f8	 mov	 edx, DWORD PTR _pic$5[ebp]
  00191	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00195	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _picmode2GR[eax*4]
  0019c	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR _format2bpp[ecx*4]
  001a3	3b 04 95 00 00
	00 00		 cmp	 eax, DWORD PTR _format2bpp[edx*4]
  001aa	75 1d		 jne	 SHORT $LN5@HWR_GetPic

; 837  : 			format2bpp[grpatch->mipmap.grInfo.format] == format2bpp[picmode2GR[pic->mode]])
; 838  : 		{
; 839  : 			// no conversion needed
; 840  : 			M_Memcpy(grpatch->mipmap.grInfo.data, pic->data,len);

  001ac	8b 45 f0	 mov	 eax, DWORD PTR _len$3[ebp]
  001af	50		 push	 eax
  001b0	8b 4d f8	 mov	 ecx, DWORD PTR _pic$5[ebp]
  001b3	83 c1 08	 add	 ecx, 8
  001b6	51		 push	 ecx
  001b7	8b 55 fc	 mov	 edx, DWORD PTR _grpatch$[ebp]
  001ba	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001bd	50		 push	 eax
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 841  : 		}

  001c7	eb 3a		 jmp	 SHORT $LN6@HWR_GetPic
$LN5@HWR_GetPic:

; 842  : 		else
; 843  : 			HWR_DrawPicInCache(block, newwidth, newheight,

  001c9	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  001cc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001cf	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _format2bpp[ecx*4]
  001d6	52		 push	 edx
  001d7	8b 45 f8	 mov	 eax, DWORD PTR _pic$5[ebp]
  001da	50		 push	 eax
  001db	8b 4d fc	 mov	 ecx, DWORD PTR _grpatch$[ebp]
  001de	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  001e6	0f af 04 95 00
	00 00 00	 imul	 eax, DWORD PTR _format2bpp[edx*4]
  001ee	50		 push	 eax
  001ef	8b 4d e8	 mov	 ecx, DWORD PTR _newheight$1[ebp]
  001f2	51		 push	 ecx
  001f3	8b 55 ec	 mov	 edx, DWORD PTR _newwidth$2[ebp]
  001f6	52		 push	 edx
  001f7	8b 45 f4	 mov	 eax, DWORD PTR _block$4[ebp]
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 _HWR_DrawPicInCache
  00200	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@HWR_GetPic:

; 844  : 			                   blockwidth*format2bpp[grpatch->mipmap.grInfo.format],
; 845  : 			                   pic,
; 846  : 			                   format2bpp[grpatch->mipmap.grInfo.format]);
; 847  : 
; 848  : 		Z_ChangeTag(pic, PU_CACHE);

  00203	6a 65		 push	 101			; 00000065H
  00205	8b 45 f8	 mov	 eax, DWORD PTR _pic$5[ebp]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _Z_ChangeTag2
  0020e	83 c4 08	 add	 esp, 8

; 849  : 		Z_ChangeTag(block, PU_HWRCACHE);

  00211	6a 66		 push	 102			; 00000066H
  00213	8b 45 f4	 mov	 eax, DWORD PTR _block$4[ebp]
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 _Z_ChangeTag2
  0021c	83 c4 08	 add	 esp, 8

; 850  : 
; 851  : 		grpatch->mipmap.flags = 0;

  0021f	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00222	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 852  : 		grpatch->max_s = (float)newwidth  / (float)blockwidth;

  00229	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _newwidth$2[ebp]
  0022e	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _blockwidth
  00236	f3 0f 5e c1	 divss	 xmm0, xmm1
  0023a	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0023d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 853  : 		grpatch->max_t = (float)newheight / (float)blockheight;

  00242	f3 0f 2a 45 e8	 cvtsi2ss xmm0, DWORD PTR _newheight$1[ebp]
  00247	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _blockheight
  0024f	f3 0f 5e c1	 divss	 xmm0, xmm1
  00253	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00256	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
$LN2@HWR_GetPic:

; 854  : 	}
; 855  : 	HWD.pfnSetTexture(&grpatch->mipmap);

  0025b	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0025e	83 c0 14	 add	 eax, 20			; 00000014H
  00261	50		 push	 eax
  00262	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  00268	90		 npad	 1

; 856  : 	//CONS_Printf("picloaded at %x as texture %d\n",grpatch->mipmap.grInfo.data, grpatch->mipmap.downloaded);
; 857  : 
; 858  : 	return grpatch;

  00269	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]

; 859  : }

  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi
  0026e	5b		 pop	 ebx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
_HWR_GetPic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_GetMappedPatch
_TEXT	SEGMENT
_newmip$ = -8						; size = 4
_grmip$ = -4						; size = 4
_gpatch$ = 8						; size = 4
_colormap$ = 12						; size = 4
_HWR_GetMappedPatch PROC				; COMDAT

; 680  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 681  : 	GLMipmap_t *grmip, *newmip;
; 682  : 
; 683  : 	if (colormap == colormaps || colormap == NULL)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _colormap$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _colormaps
  00012	74 06		 je	 SHORT $LN6@HWR_GetMap
  00014	83 7d 0c 00	 cmp	 DWORD PTR _colormap$[ebp], 0
  00018	75 11		 jne	 SHORT $LN5@HWR_GetMap
$LN6@HWR_GetMap:

; 684  : 	{
; 685  : 		// Load the default (green) color in doom cache (temporary?) AND hardware cache
; 686  : 		HWR_GetPatch(gpatch);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _HWR_GetPatch
  00023	83 c4 04	 add	 esp, 4

; 687  : 		return;

  00026	e9 83 00 00 00	 jmp	 $LN1@HWR_GetMap
$LN5@HWR_GetMap:

; 688  : 	}
; 689  : 
; 690  : 	// search for the mimmap
; 691  : 	// skip the first (no colormap translated)
; 692  : 	for (grmip = &gpatch->mipmap; grmip->nextcolormap; )

  0002b	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  0002e	83 c0 14	 add	 eax, 20			; 00000014H
  00031	89 45 fc	 mov	 DWORD PTR _grmip$[ebp], eax
$LN2@HWR_GetMap:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  00037	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0003b	74 28		 je	 SHORT $LN3@HWR_GetMap

; 693  : 	{
; 694  : 		grmip = grmip->nextcolormap;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  00040	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00043	89 4d fc	 mov	 DWORD PTR _grmip$[ebp], ecx

; 695  : 		if (grmip->colormap == colormap)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  00049	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0004c	3b 4d 0c	 cmp	 ecx, DWORD PTR _colormap$[ebp]
  0004f	75 12		 jne	 SHORT $LN7@HWR_GetMap

; 696  : 		{
; 697  : 			HWR_LoadMappedPatch(grmip, gpatch);

  00051	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _grmip$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _HWR_LoadMappedPatch
  0005e	83 c4 08	 add	 esp, 8

; 698  : 			return;

  00061	eb 4b		 jmp	 SHORT $LN1@HWR_GetMap
$LN7@HWR_GetMap:

; 699  : 		}
; 700  : 	}

  00063	eb cf		 jmp	 SHORT $LN2@HWR_GetMap
$LN3@HWR_GetMap:

; 701  : 	// not found, create it!
; 702  : 	// If we are here, the sprite with the current colormap is not already in hardware memory
; 703  : 
; 704  : 	//BP: WARNING: don't free it manually without clearing the cache of harware renderer
; 705  : 	//              (it have a liste of mipmap)
; 706  : 	//    this malloc is cleared in HWR_FreeTextureCache
; 707  : 	//    (...) unfortunately z_malloc fragment alot the memory :(so malloc is better
; 708  : 	newmip = calloc(1, sizeof (*newmip));

  00065	6a 2c		 push	 44			; 0000002cH
  00067	6a 01		 push	 1
  00069	e8 00 00 00 00	 call	 _calloc
  0006e	83 c4 08	 add	 esp, 8
  00071	89 45 f8	 mov	 DWORD PTR _newmip$[ebp], eax

; 709  : 	if (newmip == NULL)

  00074	83 7d f8 00	 cmp	 DWORD PTR _newmip$[ebp], 0
  00078	75 12		 jne	 SHORT $LN8@HWR_GetMap

; 710  : 		I_Error("%s: Out of memory", "HWR_GetMappedPatch");

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JKLFCLJF@HWR_GetMappedPatch@
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GFOKFIGO@?$CFs?3?5Out?5of?5memory@
  00084	e8 00 00 00 00	 call	 _I_Error
  00089	83 c4 08	 add	 esp, 8
$LN8@HWR_GetMap:

; 711  : 	grmip->nextcolormap = newmip;

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _newmip$[ebp]
  00092	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 712  : 
; 713  : 	newmip->colormap = colormap;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _newmip$[ebp]
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _colormap$[ebp]
  0009b	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 714  : 	HWR_LoadMappedPatch(newmip, gpatch);

  0009e	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _newmip$[ebp]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _HWR_LoadMappedPatch
  000ab	83 c4 08	 add	 esp, 8
$LN1@HWR_GetMap:

; 715  : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
_HWR_GetMappedPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_GetPatch
_TEXT	SEGMENT
_ptr$1 = -4						; size = 4
_gpatch$ = 8						; size = 4
_HWR_GetPatch PROC					; COMDAT

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 659  : 	// is it in hardware cache
; 660  : 	if (!gpatch->mipmap.downloaded && !gpatch->mipmap.grInfo.data)

  00009	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  0000c	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00010	75 40		 jne	 SHORT $LN2@HWR_GetPat
  00012	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00015	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00019	75 37		 jne	 SHORT $LN2@HWR_GetPat

; 661  : 	{
; 662  : 		// load the software patch, PU_STATIC or the Z_Malloc for hardware patch will
; 663  : 		// flush the software patch before the conversion! oh yeah I suffered
; 664  : 		patch_t *ptr = W_CacheLumpNum(gpatch->patchlump, PU_STATIC);

  0001b	6a 01		 push	 1
  0001d	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00020	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR _ptr$1[ebp], eax

; 665  : 		HWR_MakePatch(ptr, gpatch, &gpatch->mipmap);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00032	83 c0 14	 add	 eax, 20			; 00000014H
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _ptr$1[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _HWR_MakePatch
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 666  : 
; 667  : 		// this is inefficient.. but the hardware patch in heap is purgeable so it should
; 668  : 		// not fragment memory, and besides the REAL cache here is the hardware memory
; 669  : 		Z_Free(ptr);

  00046	8b 45 fc	 mov	 eax, DWORD PTR _ptr$1[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _Z_Free
  0004f	83 c4 04	 add	 esp, 4
$LN2@HWR_GetPat:

; 670  : 	}
; 671  : 
; 672  : 	HWD.pfnSetTexture(&gpatch->mipmap);

  00052	8b 45 08	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00055	83 c0 14	 add	 eax, 20			; 00000014H
  00058	50		 push	 eax
  00059	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  0005f	90		 npad	 1

; 673  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_HWR_GetPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_GetTexture
_TEXT	SEGMENT
_grtex$ = -4						; size = 4
_tex$ = 8						; size = 4
_HWR_GetTexture PROC					; COMDAT

; 559  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 560  : 	GLTexture_t *grtex;
; 561  : #ifdef PARANOIA
; 562  : 	if ((unsigned)tex >= gr_numtextures)
; 563  : 		I_Error(" HWR_GetTexture: tex >= numtextures\n");
; 564  : #endif
; 565  : 	grtex = &gr_textures[tex];

  00009	6b 45 08 34	 imul	 eax, DWORD PTR _tex$[ebp], 52
  0000d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _gr_textures
  00013	89 45 fc	 mov	 DWORD PTR _grtex$[ebp], eax

; 566  : 
; 567  : 	if (!grtex->mipmap.grInfo.data && !grtex->mipmap.downloaded)

  00016	8b 45 fc	 mov	 eax, DWORD PTR _grtex$[ebp]
  00019	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0001d	75 19		 jne	 SHORT $LN2@HWR_GetTex
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _grtex$[ebp]
  00022	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00026	75 10		 jne	 SHORT $LN2@HWR_GetTex

; 568  : 		HWR_GenerateTexture(tex, grtex);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _grtex$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _tex$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _HWR_GenerateTexture
  00035	83 c4 08	 add	 esp, 8
$LN2@HWR_GetTex:

; 569  : 
; 570  : 	HWD.pfnSetTexture(&grtex->mipmap);

  00038	8b 45 fc	 mov	 eax, DWORD PTR _grtex$[ebp]
  0003b	50		 push	 eax
  0003c	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  00042	90		 npad	 1

; 571  : 	return grtex;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _grtex$[ebp]

; 572  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_HWR_GetTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_GetFlat
_TEXT	SEGMENT
_grmip$ = -4						; size = 4
_flatlumpnum$ = 8					; size = 4
_HWR_GetFlat PROC					; COMDAT

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 	GLMipmap_t *grmip;
; 628  : 
; 629  : 	grmip = &(wadfiles[WADFILENUM(flatlumpnum)]->hwrcache[LUMPNUM(flatlumpnum)].mipmap);

  00009	8b 45 08	 mov	 eax, DWORD PTR _flatlumpnum$[ebp]
  0000c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0000f	0f b7 c8	 movzx	 ecx, ax
  00012	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _wadfiles[ecx*4]
  00019	8b 45 08	 mov	 eax, DWORD PTR _flatlumpnum$[ebp]
  0001c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00021	0f b7 c8	 movzx	 ecx, ax
  00024	c1 e1 06	 shl	 ecx, 6
  00027	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  0002a	8d 44 0a 14	 lea	 eax, DWORD PTR [edx+ecx+20]
  0002e	89 45 fc	 mov	 DWORD PTR _grmip$[ebp], eax

; 630  : 
; 631  : 	if (!grmip->downloaded && !grmip->grInfo.data)

  00031	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  00034	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00038	75 19		 jne	 SHORT $LN2@HWR_GetFla
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  0003d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00041	75 10		 jne	 SHORT $LN2@HWR_GetFla

; 632  : 		HWR_CacheFlat(grmip, flatlumpnum);

  00043	8b 45 08	 mov	 eax, DWORD PTR _flatlumpnum$[ebp]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _grmip$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _HWR_CacheFlat
  00050	83 c4 08	 add	 esp, 8
$LN2@HWR_GetFla:

; 633  : 
; 634  : 	HWD.pfnSetTexture(grmip);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _grmip$[ebp]
  00056	50		 push	 eax
  00057	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  0005d	90		 npad	 1

; 635  : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_HWR_GetFlat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_FreeTextureCache
_TEXT	SEGMENT
_grmip$1 = -16						; size = 4
_grpatch$2 = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_HWR_FreeTextureCache PROC				; COMDAT

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 488  : 	INT32 i,j;
; 489  : 	// free references to the textures
; 490  : 	HWD.pfnClearMipMapCache();

  00009	ff 15 28 00 00
	00		 call	 DWORD PTR _hwdriver+40
  0000f	90		 npad	 1

; 491  : 
; 492  : 	// free all hardware-converted graphics cached in the heap
; 493  : 	// our gool is only the textures since user of the texture is the texture cache
; 494  : 	if (Z_TagUsage(PU_HWRCACHE)) Z_FreeTags (PU_HWRCACHE, PU_HWRCACHE);

  00010	6a 66		 push	 102			; 00000066H
  00012	e8 00 00 00 00	 call	 _Z_TagUsage
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 0c		 je	 SHORT $LN10@HWR_FreeTe
  0001e	6a 66		 push	 102			; 00000066H
  00020	6a 66		 push	 102			; 00000066H
  00022	e8 00 00 00 00	 call	 _Z_FreeTags
  00027	83 c4 08	 add	 esp, 8
$LN10@HWR_FreeTe:

; 495  : 	// Alam: free the Z_Blocks before freeing it's users
; 496  : 
; 497  : 	// free all skin after each level: must be done after pfnClearMipMapCache!
; 498  : 	for (j = 0; j < numwadfiles; j++)

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@HWR_FreeTe
$LN2@HWR_FreeTe:
  00033	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@HWR_FreeTe:
  0003c	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  00043	39 45 f8	 cmp	 DWORD PTR _j$[ebp], eax
  00046	7d 6b		 jge	 SHORT $LN3@HWR_FreeTe

; 499  : 		for (i = 0; i < wadfiles[j]->numlumps; i++)

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004f	eb 09		 jmp	 SHORT $LN7@HWR_FreeTe
$LN5@HWR_FreeTe:
  00051	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HWR_FreeTe:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0005d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00064	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00068	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  0006b	7d 44		 jge	 SHORT $LN6@HWR_FreeTe

; 500  : 		{
; 501  : 			GLPatch_t *grpatch = &(wadfiles[j]->hwrcache[i]);

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00070	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00077	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0007a	c1 e2 06	 shl	 edx, 6
  0007d	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  00080	89 55 f4	 mov	 DWORD PTR _grpatch$2[ebp], edx
$LN8@HWR_FreeTe:

; 502  : 			while (grpatch->mipmap.nextcolormap)

  00083	8b 45 f4	 mov	 eax, DWORD PTR _grpatch$2[ebp]
  00086	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0008a	74 23		 je	 SHORT $LN9@HWR_FreeTe

; 503  : 			{
; 504  : 				GLMipmap_t *grmip = grpatch->mipmap.nextcolormap;

  0008c	8b 45 f4	 mov	 eax, DWORD PTR _grpatch$2[ebp]
  0008f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00092	89 4d f0	 mov	 DWORD PTR _grmip$1[ebp], ecx

; 505  : 				grpatch->mipmap.nextcolormap = grmip->nextcolormap;

  00095	8b 45 f4	 mov	 eax, DWORD PTR _grpatch$2[ebp]
  00098	8b 4d f0	 mov	 ecx, DWORD PTR _grmip$1[ebp]
  0009b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0009e	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 506  : 				free(grmip);

  000a1	8b 45 f0	 mov	 eax, DWORD PTR _grmip$1[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _free
  000aa	83 c4 04	 add	 esp, 4

; 507  : 			}

  000ad	eb d4		 jmp	 SHORT $LN8@HWR_FreeTe
$LN9@HWR_FreeTe:

; 508  : 		}

  000af	eb a0		 jmp	 SHORT $LN5@HWR_FreeTe
$LN6@HWR_FreeTe:
  000b1	eb 80		 jmp	 SHORT $LN2@HWR_FreeTe
$LN3@HWR_FreeTe:

; 509  : 
; 510  : 	// now the heap don't have any 'user' pointing to our
; 511  : 	// texturecache info, we can free it
; 512  : 	if (gr_textures)

  000b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_textures, 0
  000ba	74 0e		 je	 SHORT $LN11@HWR_FreeTe

; 513  : 		free(gr_textures);

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_textures
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _free
  000c7	83 c4 04	 add	 esp, 4
$LN11@HWR_FreeTe:

; 514  : 	gr_textures = NULL;

  000ca	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_textures, 0

; 515  : 	gr_numtextures = 0;

  000d4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_numtextures, 0

; 516  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_HWR_FreeTextureCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_InitTextureCache
_TEXT	SEGMENT
_HWR_InitTextureCache PROC				; COMDAT

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 482  : 	gr_numtextures = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_numtextures, 0

; 483  : 	gr_textures = NULL;

  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_textures, 0

; 484  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_HWR_InitTextureCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_PrepLevelCache
_TEXT	SEGMENT
_pnumtextures$ = 8					; size = 4
_HWR_PrepLevelCache PROC				; COMDAT

; 519  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 520  : 	// problem: the mipmap cache management hold a list of mipmaps.. but they are
; 521  : 	//           reallocated on each level..
; 522  : 	//sub-optimal, but 1) just need re-download stuff in hardware cache VERY fast
; 523  : 	//   2) sprite/menu stuff mixed with level textures so can't do anything else
; 524  : 
; 525  : 	// we must free it since numtextures changed
; 526  : 	HWR_FreeTextureCache();

  00009	e8 00 00 00 00	 call	 _HWR_FreeTextureCache
  0000e	90		 npad	 1

; 527  : 
; 528  : 	gr_numtextures = pnumtextures;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pnumtextures$[ebp]
  00012	a3 00 00 00 00	 mov	 DWORD PTR _gr_numtextures, eax

; 529  : 	gr_textures = calloc(pnumtextures, sizeof (*gr_textures));

  00017	6a 34		 push	 52			; 00000034H
  00019	8b 45 08	 mov	 eax, DWORD PTR _pnumtextures$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _calloc
  00022	83 c4 08	 add	 esp, 8
  00025	a3 00 00 00 00	 mov	 DWORD PTR _gr_textures, eax

; 530  : 	if (gr_textures == NULL)

  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_textures, 0
  00031	75 0d		 jne	 SHORT $LN2@HWR_PrepLe

; 531  : 		I_Error("3D can't alloc gr_textures");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HBNBDKNI@3D?5can?8t?5alloc?5gr_textures@
  00038	e8 00 00 00 00	 call	 _I_Error
  0003d	83 c4 04	 add	 esp, 4
$LN2@HWR_PrepLe:

; 532  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_HWR_PrepLevelCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_cache.c
;	COMDAT _HWR_MakePatch
_TEXT	SEGMENT
tv134 = -80						; size = 4
tv140 = -80						; size = 4
_newheight$ = -12					; size = 4
_newwidth$ = -8						; size = 4
_block$ = -4						; size = 4
_patch$ = 8						; size = 4
_grPatch$ = 12						; size = 4
_grMipmap$ = 16						; size = 4
_HWR_MakePatch PROC					; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 417  : 	UINT8 *block;
; 418  : 	INT32 newwidth, newheight;
; 419  : 
; 420  : 	// don't do it twice (like a cache)
; 421  : 	if (grMipmap->width == 0)

  00009	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0000c	0f b7 48 1a	 movzx	 ecx, WORD PTR [eax+26]
  00010	85 c9		 test	 ecx, ecx
  00012	0f 85 85 00 00
	00		 jne	 $LN2@HWR_MakePa

; 422  : 	{
; 423  : 		// save the original patch header so that the GLPatch can be casted
; 424  : 		// into a standard patch_t struct and the existing code can get the
; 425  : 		// orginal patch dimensions and offsets.
; 426  : 		grPatch->width = SHORT(patch->width);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _grPatch$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _patch$[ebp]
  0001e	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00021	66 89 10	 mov	 WORD PTR [eax], dx

; 427  : 		grPatch->height = SHORT(patch->height);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _grPatch$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _patch$[ebp]
  0002a	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  0002e	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 428  : 		grPatch->leftoffset = SHORT(patch->leftoffset);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _grPatch$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _patch$[ebp]
  00038	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0003c	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 429  : 		grPatch->topoffset = SHORT(patch->topoffset);

  00040	8b 45 0c	 mov	 eax, DWORD PTR _grPatch$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _patch$[ebp]
  00046	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  0004a	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 430  : 
; 431  : 		// find the good 3dfx size (boring spec)
; 432  : 		HWR_ResizeBlock (SHORT(patch->width), SHORT(patch->height), &grMipmap->grInfo);

  0004e	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _patch$[ebp]
  00055	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  00059	52		 push	 edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR _patch$[ebp]
  0005d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 _HWR_ResizeBlock
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 433  : 		grMipmap->width = (UINT16)blockwidth;

  00069	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0006c	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _blockwidth
  00073	66 89 48 1a	 mov	 WORD PTR [eax+26], cx

; 434  : 		grMipmap->height = (UINT16)blockheight;

  00077	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  0007a	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _blockheight
  00081	66 89 48 18	 mov	 WORD PTR [eax+24], cx

; 435  : 
; 436  : 		// no wrap around, no chroma key
; 437  : 		grMipmap->flags = 0;

  00085	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00088	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 438  : 		// setup the texture info
; 439  : 		grMipmap->grInfo.format = patchformat;

  0008f	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _patchformat
  00098	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 440  : 	}

  0009b	eb 2b		 jmp	 SHORT $LN3@HWR_MakePa
$LN2@HWR_MakePa:

; 441  : 	else
; 442  : 	{
; 443  : 		blockwidth = grMipmap->width;

  0009d	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000a0	0f b7 48 1a	 movzx	 ecx, WORD PTR [eax+26]
  000a4	89 0d 00 00 00
	00		 mov	 DWORD PTR _blockwidth, ecx

; 444  : 		blockheight = grMipmap->height;

  000aa	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000ad	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  000b1	89 0d 00 00 00
	00		 mov	 DWORD PTR _blockheight, ecx

; 445  : 		blocksize = blockwidth * blockheight;

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockwidth
  000bc	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _blockheight
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _blocksize, eax
$LN3@HWR_MakePa:

; 446  : 	}
; 447  : 
; 448  : 	Z_Free(grMipmap->grInfo.data);

  000c8	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000cb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _Z_Free
  000d4	83 c4 04	 add	 esp, 4

; 449  : 	grMipmap->grInfo.data = NULL;

  000d7	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000da	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 450  : 
; 451  : 	block = MakeBlock(grMipmap);

  000e1	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _MakeBlock
  000ea	83 c4 04	 add	 esp, 4
  000ed	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 452  : 
; 453  : 	// no rounddown, do not size up patches, so they don't look 'scaled'
; 454  : 	newwidth  = min(SHORT(patch->width), blockwidth);

  000f0	8b 45 08	 mov	 eax, DWORD PTR _patch$[ebp]
  000f3	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000f6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _blockwidth
  000fc	7d 0b		 jge	 SHORT $LN5@HWR_MakePa
  000fe	8b 55 08	 mov	 edx, DWORD PTR _patch$[ebp]
  00101	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00104	89 45 b0	 mov	 DWORD PTR tv134[ebp], eax
  00107	eb 09		 jmp	 SHORT $LN6@HWR_MakePa
$LN5@HWR_MakePa:
  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockwidth
  0010f	89 4d b0	 mov	 DWORD PTR tv134[ebp], ecx
$LN6@HWR_MakePa:
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv134[ebp]
  00115	89 55 f8	 mov	 DWORD PTR _newwidth$[ebp], edx

; 455  : 	newheight = min(SHORT(patch->height), blockheight);

  00118	8b 45 08	 mov	 eax, DWORD PTR _patch$[ebp]
  0011b	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0011f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _blockheight
  00125	7d 0c		 jge	 SHORT $LN7@HWR_MakePa
  00127	8b 55 08	 mov	 edx, DWORD PTR _patch$[ebp]
  0012a	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  0012e	89 45 b0	 mov	 DWORD PTR tv140[ebp], eax
  00131	eb 09		 jmp	 SHORT $LN8@HWR_MakePa
$LN7@HWR_MakePa:
  00133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockheight
  00139	89 4d b0	 mov	 DWORD PTR tv140[ebp], ecx
$LN8@HWR_MakePa:
  0013c	8b 55 b0	 mov	 edx, DWORD PTR tv140[ebp]
  0013f	89 55 f4	 mov	 DWORD PTR _newheight$[ebp], edx

; 456  : 
; 457  : 	HWR_DrawPatchInCache(grMipmap,

  00142	8b 45 10	 mov	 eax, DWORD PTR _grMipmap$[ebp]
  00145	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00148	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _format2bpp[ecx*4]
  0014f	52		 push	 edx
  00150	8b 45 08	 mov	 eax, DWORD PTR _patch$[ebp]
  00153	50		 push	 eax
  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _patch$[ebp]
  0015b	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0015f	52		 push	 edx
  00160	8b 45 08	 mov	 eax, DWORD PTR _patch$[ebp]
  00163	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00166	51		 push	 ecx
  00167	8b 55 10	 mov	 edx, DWORD PTR _grMipmap$[ebp]
  0016a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockwidth
  00173	0f af 0c 85 00
	00 00 00	 imul	 ecx, DWORD PTR _format2bpp[eax*4]
  0017b	51		 push	 ecx
  0017c	8b 55 f4	 mov	 edx, DWORD PTR _newheight$[ebp]
  0017f	52		 push	 edx
  00180	8b 45 f8	 mov	 eax, DWORD PTR _newwidth$[ebp]
  00183	50		 push	 eax
  00184	8b 4d 10	 mov	 ecx, DWORD PTR _grMipmap$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 _HWR_DrawPatchInCache
  0018d	83 c4 28	 add	 esp, 40			; 00000028H

; 458  : 	                     newwidth, newheight,
; 459  : 	                     blockwidth*format2bpp[grMipmap->grInfo.format],
; 460  : 	                     SHORT(patch->width), SHORT(patch->height),
; 461  : 	                     0, 0,
; 462  : 	                     patch,
; 463  : 	                     format2bpp[grMipmap->grInfo.format]);
; 464  : 
; 465  : 	grPatch->max_s = (float)newwidth / (float)blockwidth;

  00190	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _newwidth$[ebp]
  00195	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _blockwidth
  0019d	f3 0f 5e c1	 divss	 xmm0, xmm1
  001a1	8b 45 0c	 mov	 eax, DWORD PTR _grPatch$[ebp]
  001a4	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 466  : 	grPatch->max_t = (float)newheight / (float)blockheight;

  001a9	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _newheight$[ebp]
  001ae	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _blockheight
  001b6	f3 0f 5e c1	 divss	 xmm0, xmm1
  001ba	8b 45 0c	 mov	 eax, DWORD PTR _grPatch$[ebp]
  001bd	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 467  : 
; 468  : 	// Now that the texture has been built in cache, it is purgable from zone memory.
; 469  : 	Z_ChangeTag (block, PU_HWRCACHE);

  001c2	6a 66		 push	 102			; 00000066H
  001c4	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 _Z_ChangeTag2
  001cd	83 c4 08	 add	 esp, 8

; 470  : }

  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c3		 ret	 0
_HWR_MakePatch ENDP
_TEXT	ENDS
END
