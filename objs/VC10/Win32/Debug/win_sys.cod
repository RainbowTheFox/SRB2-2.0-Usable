; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\win_sys.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_sound_started
PUBLIC	_graphics_started
PUBLIC	_keyboard_started
PUBLIC	_MSHWheelMessage
PUBLIC	??_C@_0M@GCIMPDEH@cpuaffinity@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
EXTRN	_GUID_ConstantForce:BYTE
EXTRN	_GUID_RampForce:BYTE
EXTRN	_GUID_Square:BYTE
EXTRN	_GUID_Sine:BYTE
EXTRN	_GUID_Triangle:BYTE
EXTRN	_GUID_SawtoothUp:BYTE
EXTRN	_GUID_SawtoothDown:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_sound_started DB 01H DUP (?)
	ALIGN	4

_graphics_started DB 01H DUP (?)
	ALIGN	4

_keyboard_started DB 01H DUP (?)
	ALIGN	4

_MSHWheelMessage DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_win9x:DWORD
COMM	_bDX0300:DWORD
_DATA	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GCIMPDEH@cpuaffinity@
CONST	SEGMENT
??_C@_0M@GCIMPDEH@cpuaffinity@ DB 'cpuaffinity', 00H	; `string'
CONST	ENDS
CONST	SEGMENT
_DIETable DD	FLAT:_GUID_ConstantForce
	DD	FLAT:_GUID_RampForce
	DD	FLAT:_GUID_Square
	DD	FLAT:_GUID_Sine
	DD	FLAT:_GUID_Triangle
	DD	FLAT:_GUID_SawtoothUp
	DD	FLAT:_GUID_SawtoothDown
	DD	0ffffffffH
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_vsprintf
PUBLIC	_sprintf
PUBLIC	_I_Error
PUBLIC	_I_GetKey
PUBLIC	_I_WaitVBL
PUBLIC	_I_BeginRead
PUBLIC	_I_EndRead
PUBLIC	_I_GetFreeMem
PUBLIC	_I_GetTime
PUBLIC	_I_Sleep
PUBLIC	_I_GetEvent
PUBLIC	_I_OsPolling
PUBLIC	_I_BaseTiccmd
PUBLIC	_I_BaseTiccmd2
PUBLIC	_I_Quit
PUBLIC	_I_Tactile
PUBLIC	_I_Tactile2
PUBLIC	_I_InitJoystick
PUBLIC	_I_InitJoystick2
PUBLIC	_I_NumJoys
PUBLIC	_I_GetJoyName
PUBLIC	_I_SetupMumble
PUBLIC	_I_UpdateMumble
PUBLIC	_I_OutputMsg
PUBLIC	_I_StartupMouse
PUBLIC	_I_StartupMouse2
PUBLIC	_I_StartupKeyboard
PUBLIC	_I_StartupTimer
PUBLIC	_I_AddExitFunc
PUBLIC	_I_RemoveExitFunc
PUBLIC	_I_StartupSystem
PUBLIC	_I_ShutdownSystem
PUBLIC	_I_GetDiskFreeSpace
PUBLIC	_I_GetUserName
PUBLIC	_I_mkdir
PUBLIC	_I_CPUInfo
PUBLIC	_I_GetJoystickEvents
PUBLIC	_I_GetJoystick2Events
PUBLIC	_I_GetMouseEvents
PUBLIC	_I_GetEnv
PUBLIC	_I_PutEnv
PUBLIC	_I_RegisterSysCommands
PUBLIC	_I_GetSysMouseEvents
PUBLIC	_LoadDirectInput
PUBLIC	_I_BeginProfile
PUBLIC	_I_EndProfile
PUBLIC	_I_ShowLastError
PUBLIC	_I_RestartSysMouse
PUBLIC	_I_DoStartupMouse
PUBLIC	??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@		; `string'
PUBLIC	??_C@_0BG@ICIDLEJE@I_BeginProfile?5failed@	; `string'
PUBLIC	??_C@_0BE@EEFIPHAL@I_EndProfile?5failed@	; `string'
PUBLIC	??_C@_0BG@EFGNEMMJ@I_EndProfile?5overflow@	; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0O@MBBOFCJA@?9gettickcount@		; `string'
PUBLIC	??_C@_0BG@CHODMMMD@Using?5GetTickCount?$CI?$CJ?6@ ; `string'
PUBLIC	??_C@_0BF@HIGGEAIG@SRB2?5Recursive?5Error@	; `string'
PUBLIC	??_C@_0P@PKDMOCMC@I_Error?$CI?$CJ?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0L@HDMHDCFA@SRB2?5Error@			; `string'
PUBLIC	??_C@_06BBOHFMBE@ENDOOM@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BE@NBJMEAKN@Error?5detected?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0BO@LBJCGNPE@I_Quit?$CI?$CJ?3?5end?5of?5logstream?4?$AN?6@ ; `string'
PUBLIC	??_C@_09EJJCJJPM@?9noendtxt@			; `string'
PUBLIC	??_C@_01LIIJDEN@?$AN@				; `string'
PUBLIC	??_C@_0BH@CFODMEHN@GetLastError?3?5Unknown?6@	; `string'
PUBLIC	??_C@_0N@HICKNDGL@GetLastError@			; `string'
PUBLIC	??_C@_0BB@CDGKGPGK@GetLastError?3?5?$CFs@	; `string'
PUBLIC	??_C@_0CI@HMIBAJHL@?$ACCould?5not?5create?5IDirectInput?5@ ; `string'
PUBLIC	??_C@_0CF@MJPBPFFC@Could?5not?5create?5IDirectInput?5d@ ; `string'
PUBLIC	??_C@_0CF@KCELBNNB@?$ACRead?5Error?5on?5secondary?5mouse?5@ ; `string'
PUBLIC	??_C@_0GG@KJGNAMBA@?$ACCan?8t?5open?5?$CFs?3?5Access?5denied?6T@ ; `string'
PUBLIC	??_C@_0BK@KLMPAIBH@?$ACCan?8t?5open?5?$CFs?3?5error?5?$CFd?6@ ; `string'
PUBLIC	??_C@_08GPADOFHN@?9nomouse@			; `string'
PUBLIC	??_C@_0CC@MPELICFG@?7Mouse?5will?5not?5use?5DirectInput@ ; `string'
PUBLIC	??_C@_0BP@MNDEIMNB@Couldn?8t?5set?5mouse?5data?5format@ ; `string'
PUBLIC	??_C@_0BP@IGFGLPOP@Couldn?8t?5set?5mouse?5buffer?5size@ ; `string'
PUBLIC	??_C@_0BO@MCGALMJM@Couldn?8t?5set?5mouse?5coop?5level@ ; `string'
PUBLIC	??_C@_0BM@NLCOHANC@Couldn?8t?5create?5mouse?5input@ ; `string'
PUBLIC	??_C@_0BD@CBEGCOGG@I_ShutdownMouse?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_09EBBEIMPI@?$CFc?$CFd?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0CI@BOBKDHHM@DIEnumJoysticks?$CI?$CJ?3?5CreateDevice@ ; `string'
PUBLIC	??_C@_0CL@HNLAIKDI@DIEnumJoysticks?$CI?$CJ?3?5GetCapabilit@ ; `string'
PUBLIC	??_C@_0EE@IFFBDPHG@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@ ; `string'
PUBLIC	??_C@_0CJ@OAGCDABJ@DIEnumJoysticks?$CI?$CJ?3?5SetDataForma@ ; `string'
PUBLIC	??_C@_0CP@BMGKCBPE@DIEnumJoysticks?$CI?$CJ?3?5SetCooperati@ ; `string'
PUBLIC	??_C@_0DI@IGHPGEBO@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DJ@NNPAHDAI@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DJ@GADKBPMG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DK@CMIFLPAN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DK@PBBDGGII@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DK@EMNJAKEG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DJ@EHEKMKPD@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0DJ@PKIAKGDN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ ; `string'
PUBLIC	??_C@_0CK@KMBLEGGG@DIEnumJoysticks?$CI?$CJ?3?5QueryInterfa@ ; `string'
PUBLIC	??_C@_06MIIKPKO@?9nojoy@			; `string'
PUBLIC	??_C@_0BD@LCNJCENL@Joystick?5disabled?6@	; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BP@PKLGBKMF@Looking?5for?5joystick?5devices?3?6@ ; `string'
PUBLIC	??_C@_0CH@EMBOCGPJ@?6I_InitJoystick?$CI?$CJ?3?5EnumDevices?5@ ; `string'
PUBLIC	??_C@_0M@OIPHNGKP@none?5found?6@		; `string'
PUBLIC	??_C@_0L@CJHFOLIP@none?5used?6@			; `string'
PUBLIC	??_C@_0EK@EBIAMJEC@?$ACSet?5the?5use_joystick?5variable?5@ ; `string'
PUBLIC	??_C@_0CL@LHFCLCKD@I_InitJoystick?3?5SetCooperativeL@ ; `string'
PUBLIC	??_C@_0BO@GGPBHPCK@Joystick?5already?5initialized?6@ ; `string'
PUBLIC	??_C@_0CJ@FPCBGFNL@DIEnumJoysticks2?$CI?$CJ?3?5CreateDevic@ ; `string'
PUBLIC	??_C@_0CM@JIABBHGO@DIEnumJoysticks2?$CI?$CJ?3?5GetCapabili@ ; `string'
PUBLIC	??_C@_0EE@JILFPGDB@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@ ; `string'
PUBLIC	??_C@_0CK@KIJBDNAA@DIEnumJoysticks2?$CI?$CJ?3?5SetDataForm@ ; `string'
PUBLIC	??_C@_0DA@CKHJNDCH@DIEnumJoysticks2?$CI?$CJ?3?5SetCooperat@ ; `string'
PUBLIC	??_C@_0DJ@JCKOGIDG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DK@OIFBAKPO@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DK@FFJLGGDA@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DL@HIGOEJFN@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DL@KFPIJANI@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DL@BIDCPMBG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DK@HCOLLDAF@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0DK@MPCBNPML@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ ; `string'
PUBLIC	??_C@_0CL@MIDIBNKL@DIEnumJoysticks2?$CI?$CJ?3?5QueryInterf@ ; `string'
PUBLIC	??_C@_0BE@GDGHMOCG@Joystick2?5disabled?6@	; `string'
PUBLIC	??_C@_0CI@IPGCHNBF@?6I_InitJoystick2?$CI?$CJ?3?5EnumDevices@ ; `string'
PUBLIC	??_C@_0EL@NIGDHMKK@?$ACSet?5the?5use_joystick2?5variable@ ; `string'
PUBLIC	??_C@_0CM@JLJEILBJ@I_InitJoystick2?3?5SetCooperative@ ; `string'
PUBLIC	??_C@_0BP@EOHHKFHE@Joystick2?5already?5initialized?6@ ; `string'
PUBLIC	??_C@_0BG@EGEPHJIA@I_ShutdownJoystick?$CI?$CJ?6@ ; `string'
PUBLIC	??_C@_0BH@LPPGDECM@I_ShutdownJoystick2?$CI?$CJ?6@ ; `string'
PUBLIC	??_C@_0CE@ODDENDCH@I_GetJoystickEvents?$CI?$CJ?3?5Poll?5FAI@ ; `string'
PUBLIC	??_C@_0CO@MNKDPIKA@I_GetJoystickEvents?$CI?$CJ?3?5GetDevic@ ; `string'
PUBLIC	??_C@_0CF@DNBGLDEG@I_GetJoystick2Events?$CI?$CJ?3?5Poll?5FA@ ; `string'
PUBLIC	??_C@_0CP@BMFKANEO@I_GetJoystickEvents2?$CI?$CJ?3?5GetDevi@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0CC@JJKCEPAA@?6I_NumJoys?$CI?$CJ?3?5EnumDevices?5FAILE@ ; `string'
PUBLIC	??_C@_0CF@EPEJCJNA@?6I_GetJoyName?$CI?$CJ?3?5EnumDevices?5FA@ ; `string'
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll@		; `string'
PUBLIC	??_C@_0BB@LOCJLGON@OpenFileMappingA@		; `string'
PUBLIC	??_C@_0O@IGIELGBD@MapViewOfFile@		; `string'
PUBLIC	??_C@_0L@KNGEHEON@MumbleLink@			; `string'
PUBLIC	??_C@_0CE@BOBKPIDJ@?$ACI_StartupKeyboard?$CI?$CJ?3?5called?5tw@ ; `string'
PUBLIC	??_C@_0CC@CMFDNOIJ@Couldn?8t?5set?5keyboard?5data?5form@ ; `string'
PUBLIC	??_C@_0CC@GHDBONLH@Couldn?8t?5set?5keyboard?5buffer?5si@ ; `string'
PUBLIC	??_C@_0CB@KLKKPMNH@Couldn?8t?5set?5keyboard?5coop?5leve@ ; `string'
PUBLIC	??_C@_0BP@KDGLGFGC@Couldn?8t?5create?5keyboard?5input@ ; `string'
PUBLIC	??_C@_0BG@NMBKBOKM@I_ShutdownKeyboard?$CI?$CJ?6@ ; `string'
PUBLIC	??_C@_0L@HKAJIFBE@DINPUT?4DLL@			; `string'
PUBLIC	??_C@_0BD@BGJEDEPJ@DirectInputCreateA@		; `string'
PUBLIC	??_C@_0BN@FFKALFMN@DIERR_BETADIRECTINPUTVERSION@ ; `string'
PUBLIC	??_C@_0BD@PCBHGFBD@DIERR_INVALIDPARAM@		; `string'
PUBLIC	??_C@_0BM@FGIBEKPK@DIERR_OLDDIRECTINPUTVERSION@	; `string'
PUBLIC	??_C@_0BC@IHLCNKJJ@DIERR_OUTOFMEMORY@		; `string'
PUBLIC	??_C@_07NFANNNEC@UNKNOWN@			; `string'
PUBLIC	??_C@_0CJ@PIDEDPNF@Couldn?8t?5create?5DirectInput?5?$CIre@ ; `string'
PUBLIC	??_C@_0BL@MOBEGLHJ@?$ACUsing?5DirectX3?5interface?6@ ; `string'
PUBLIC	??_C@_0BE@GEACJGAH@GetDiskFreeSpaceExA@		; `string'
PUBLIC	??_C@_04OOEKJIOI@USER@				; `string'
PUBLIC	??_C@_04CCHAHKJA@user@				; `string'
PUBLIC	??_C@_08JMMIJEMM@USERNAME@			; `string'
PUBLIC	??_C@_08ODGEKKOL@username@			; `string'
PUBLIC	??_C@_0BK@NHEOCAHP@IsProcessorFeaturePresent@	; `string'
PUBLIC	??_C@_0BC@PMJGPBJJ@GetCurrentProcess@		; `string'
PUBLIC	??_C@_0BH@EJFHALGI@GetProcessAffinityMask@	; `string'
PUBLIC	??_C@_0BH@EIHJCMLH@SetProcessAffinityMask@	; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@4081abe4b73fefb5
PUBLIC	__real@47800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetDiskFreeSpaceA@20:PROC
EXTRN	__imp__GetFileType@4:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__ClearCommError@12:PROC
EXTRN	__imp__SetupComm@12:PROC
EXTRN	__imp__EscapeCommFunction@8:PROC
EXTRN	__imp__GetCommState@8:PROC
EXTRN	__imp__PurgeComm@8:PROC
EXTRN	__imp__SetCommMask@8:PROC
EXTRN	__imp__SetCommState@8:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__GetUserNameA@8:PROC
EXTRN	__imp__wvsprintfA@12:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__WaitMessage@0:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__MapVirtualKeyA@8:PROC
EXTRN	__imp__SetCapture@4:PROC
EXTRN	__imp__ReleaseCapture@0:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__SetCursorPos@8:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ClipCursor@4:PROC
EXTRN	__imp__SystemParametersInfoA@16:PROC
EXTRN	__imp__GetConsoleMode@8:PROC
EXTRN	__imp__GetNumberOfConsoleInputEvents@8:PROC
EXTRN	__imp__ReadConsoleInputA@16:PROC
EXTRN	__imp__WriteConsoleA@20:PROC
EXTRN	__imp__GetConsoleScreenBufferInfo@8:PROC
EXTRN	__imp__SetConsoleScreenBufferSize@8:PROC
EXTRN	__imp__SetConsoleCursorPosition@8:PROC
EXTRN	__imp__SetConsoleTextAttribute@8:PROC
EXTRN	__imp__WriteConsoleOutputCharacterA@20:PROC
EXTRN	__imp__ReadConsoleOutputCharacterA@20:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	_getenv:PROC
EXTRN	_putenv:PROC
EXTRN	_strlcpy:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fflush:PROC
EXTRN	_getchar:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	_hypot:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_CV_RegisterVar:PROC
EXTRN	_CV_StealthSetValue:PROC
EXTRN	_W_Shutdown:PROC
EXTRN	_W_CheckNumForName:PROC
EXTRN	_W_GetNumForName:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_M_SaveConfig:PROC
EXTRN	_I_ShutdownGraphics:PROC
EXTRN	_D_SaveBan:PROC
EXTRN	_D_QuitNetGame:PROC
EXTRN	_G_SaveGameData:PROC
EXTRN	_G_CheckDemoStatus:PROC
EXTRN	_D_PostEvent:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_Z_Free:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allshl:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtol3:PROC
EXTRN	_vid:BYTE
EXTRN	_cdaudio_started:BYTE
EXTRN	_events:BYTE
EXTRN	_eventhead:DWORD
EXTRN	_eventtail:DWORD
EXTRN	_netgame:DWORD
EXTRN	_menuactive:DWORD
EXTRN	_cv_usemouse:BYTE
EXTRN	_cv_usejoystick:BYTE
EXTRN	_cv_usejoystick2:BYTE
EXTRN	_cv_mouse2port:BYTE
EXTRN	_cv_usemouse2:BYTE
EXTRN	_cv_sleep:BYTE
EXTRN	_dedicated:DWORD
EXTRN	_demorecording:DWORD
EXTRN	_gamekeydown:BYTE
EXTRN	_hWndMain:DWORD
EXTRN	_logstream:DWORD
EXTRN	_appActive:DWORD
EXTRN	_nodinput:DWORD
EXTRN	_Joystick:QWORD
EXTRN	_Joystick2:QWORD
EXTRN	_IID_IDirectInputDevice2A:BYTE
EXTRN	_GUID_SysMouse:BYTE
EXTRN	_GUID_SysKeyboard:BYTE
EXTRN	_c_dfDIMouse:BYTE
EXTRN	_c_dfDIKeyboard:BYTE
EXTRN	_c_dfDIJoystick:BYTE
EXTRN	_bAppFullScreen:DWORD
EXTRN	_windowPosX:DWORD
EXTRN	_windowPosY:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_lpDI	DD	01H DUP (?)
_lpDIK	DD	01H DUP (?)
_lpDIM	DD	01H DUP (?)
_lpDIJ	DD	01H DUP (?)
_lpDIE	DD	07H DUP (?)
_lpDIJA	DD	01H DUP (?)
_lpDIJ2	DD	01H DUP (?)
_lpDIE2	DD	07H DUP (?)
_lpDIJ2A DD	01H DUP (?)
_mouse_enabled DD 01H DUP (?)
_joystick_detected DD 01H DUP (?)
_joystick2_detected DD 01H DUP (?)
_entering_con_command DD 01H DUP (?)
	ALIGN	8

_emptycmd DQ	01H DUP (?)
_emptycmd2 DQ	01H DUP (?)
_winnt	DD	01H DUP (?)
	ALIGN	8

_ProfileCount DQ 01H DUP (?)
_hacktics DD	01H DUP (?)
_starttickcount DD 01H DUP (?)
?basetime@?2??I_GetTime@@9@9 DQ 01H DUP (?)		; `I_GetTime'::`3'::basetime
?frequency@?2??I_GetTime@@9@9 DQ 01H DUP (?)		; `I_GetTime'::`3'::frequency
_errorcount DD	01H DUP (?)
_shutdowning DD	01H DUP (?)
?coordNextWrite@?2??I_OutputMsg@@9@9 DD 01H DUP (?)	; `I_OutputMsg'::`3'::coordNextWrite
_quit_funcs DD	010H DUP (?)
_handlermouse2x DD 01H DUP (?)
_handlermouse2y DD 01H DUP (?)
_handlermouse2buttons DD 01H DUP (?)
?bytenum@?1??I_PoolMouse2@@9@9 DB 01H DUP (?)		; `I_PoolMouse2'::`2'::bytenum
	ALIGN	4

?combytes@?1??I_PoolMouse2@@9@9 DB 04H DUP (?)		; `I_PoolMouse2'::`2'::combytes
_center_x DD	01H DUP (?)
_center_y DD	01H DUP (?)
_old_mparms DD	03H DUP (?)
_restore_mouse DD 01H DUP (?)
_old_mouse_state DD 01H DUP (?)
?lastbuttons2@?2??I_GetMouseEvents@@9@9 DB 01H DUP (?)	; `I_GetMouseEvents'::`3'::lastbuttons2
	ALIGN	4

_iJoyNum DB	01H DUP (?)
	ALIGN	4

_JoyInfo DB	0cH DUP (?)
_iJoy2Num DB	01H DUP (?)
	ALIGN	4

_JoyInfo2 DB	0cH DUP (?)
_lastjoybuttons DQ 01H DUP (?)
_lastjoyhats DQ	01H DUP (?)
_lastjoy2buttons DQ 01H DUP (?)
_lastjoy2hats DQ 01H DUP (?)
_numofjoy DD	01H DUP (?)
_joyname DB	0104H DUP (?)
_lm	DD	01H DUP (?)
_hMapObject DD	01H DUP (?)
?KeyboardLost@?1??I_GetKeyboardEvents@@9@9 DD 01H DUP (?) ; `I_GetKeyboardEvents'::`2'::KeyboardLost
?RepeatKeyTics@?1??I_GetKeyboardEvents@@9@9 DD 01H DUP (?) ; `I_GetKeyboardEvents'::`2'::RepeatKeyTics
?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9 DD 01H DUP (?) ; `I_GetKeyboardEvents'::`2'::RepeatKeyCode
_DInputDLL DD	01H DUP (?)
_pfnDirectInputCreateA DD 01H DUP (?)
?pfnGetDiskFreeSpaceEx@?1??I_GetDiskFreeSpace@@9@9 DD 01H DUP (?) ; `I_GetDiskFreeSpace'::`2'::pfnGetDiskFreeSpaceEx
?testwin95@?1??I_GetDiskFreeSpace@@9@9 DD 01H DUP (?)	; `I_GetDiskFreeSpace'::`2'::testwin95
?username@?1??I_GetUserName@@9@9 DB 016H DUP (?)	; `I_GetUserName'::`2'::username
	ALIGN	4

?WIN_CPUInfo@?1??I_CPUInfo@@9@9 DD 01H DUP (?)		; `I_CPUInfo'::`2'::WIN_CPUInfo
_pfnGetCurrentProcess DD 01H DUP (?)
_pfnGetProcessAffinityMask DD 01H DUP (?)
_pfnSetProcessAffinityMask DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@4081abe4b73fefb5
CONST	SEGMENT
__real@4081abe4b73fefb5 DQ 04081abe4b73fefb5r	; 565.487
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0BH@EIHJCMLH@SetProcessAffinityMask@
CONST	SEGMENT
??_C@_0BH@EIHJCMLH@SetProcessAffinityMask@ DB 'SetProcessAffinityMask', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EJFHALGI@GetProcessAffinityMask@
CONST	SEGMENT
??_C@_0BH@EJFHALGI@GetProcessAffinityMask@ DB 'GetProcessAffinityMask', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PMJGPBJJ@GetCurrentProcess@
CONST	SEGMENT
??_C@_0BC@PMJGPBJJ@GetCurrentProcess@ DB 'GetCurrentProcess', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NHEOCAHP@IsProcessorFeaturePresent@
CONST	SEGMENT
??_C@_0BK@NHEOCAHP@IsProcessorFeaturePresent@ DB 'IsProcessorFeaturePrese'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08ODGEKKOL@username@
CONST	SEGMENT
??_C@_08ODGEKKOL@username@ DB 'username', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JMMIJEMM@USERNAME@
CONST	SEGMENT
??_C@_08JMMIJEMM@USERNAME@ DB 'USERNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CCHAHKJA@user@
CONST	SEGMENT
??_C@_04CCHAHKJA@user@ DB 'user', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOEKJIOI@USER@
CONST	SEGMENT
??_C@_04OOEKJIOI@USER@ DB 'USER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEACJGAH@GetDiskFreeSpaceExA@
CONST	SEGMENT
??_C@_0BE@GEACJGAH@GetDiskFreeSpaceExA@ DB 'GetDiskFreeSpaceExA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MOBEGLHJ@?$ACUsing?5DirectX3?5interface?6@
CONST	SEGMENT
??_C@_0BL@MOBEGLHJ@?$ACUsing?5DirectX3?5interface?6@ DB 02H, 'Using Direc'
	DB	'tX3 interface', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PIDEDPNF@Couldn?8t?5create?5DirectInput?5?$CIre@
CONST	SEGMENT
??_C@_0CJ@PIDEDPNF@Couldn?8t?5create?5DirectInput?5?$CIre@ DB 'Couldn''t '
	DB	'create DirectInput (reason: %s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFANNNEC@UNKNOWN@
CONST	SEGMENT
??_C@_07NFANNNEC@UNKNOWN@ DB 'UNKNOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHLCNKJJ@DIERR_OUTOFMEMORY@
CONST	SEGMENT
??_C@_0BC@IHLCNKJJ@DIERR_OUTOFMEMORY@ DB 'DIERR_OUTOFMEMORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FGIBEKPK@DIERR_OLDDIRECTINPUTVERSION@
CONST	SEGMENT
??_C@_0BM@FGIBEKPK@DIERR_OLDDIRECTINPUTVERSION@ DB 'DIERR_OLDDIRECTINPUTV'
	DB	'ERSION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCBHGFBD@DIERR_INVALIDPARAM@
CONST	SEGMENT
??_C@_0BD@PCBHGFBD@DIERR_INVALIDPARAM@ DB 'DIERR_INVALIDPARAM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FFKALFMN@DIERR_BETADIRECTINPUTVERSION@
CONST	SEGMENT
??_C@_0BN@FFKALFMN@DIERR_BETADIRECTINPUTVERSION@ DB 'DIERR_BETADIRECTINPU'
	DB	'TVERSION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGJEDEPJ@DirectInputCreateA@
CONST	SEGMENT
??_C@_0BD@BGJEDEPJ@DirectInputCreateA@ DB 'DirectInputCreateA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKAJIFBE@DINPUT?4DLL@
CONST	SEGMENT
??_C@_0L@HKAJIFBE@DINPUT?4DLL@ DB 'DINPUT.DLL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NMBKBOKM@I_ShutdownKeyboard?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BG@NMBKBOKM@I_ShutdownKeyboard?$CI?$CJ?6@ DB 'I_ShutdownKeyboard()'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KDGLGFGC@Couldn?8t?5create?5keyboard?5input@
CONST	SEGMENT
??_C@_0BP@KDGLGFGC@Couldn?8t?5create?5keyboard?5input@ DB 'Couldn''t crea'
	DB	'te keyboard input', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KLKKPMNH@Couldn?8t?5set?5keyboard?5coop?5leve@
CONST	SEGMENT
??_C@_0CB@KLKKPMNH@Couldn?8t?5set?5keyboard?5coop?5leve@ DB 'Couldn''t se'
	DB	't keyboard coop level', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GHDBONLH@Couldn?8t?5set?5keyboard?5buffer?5si@
CONST	SEGMENT
??_C@_0CC@GHDBONLH@Couldn?8t?5set?5keyboard?5buffer?5si@ DB 'Couldn''t se'
	DB	't keyboard buffer size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMFDNOIJ@Couldn?8t?5set?5keyboard?5data?5form@
CONST	SEGMENT
??_C@_0CC@CMFDNOIJ@Couldn?8t?5set?5keyboard?5data?5form@ DB 'Couldn''t se'
	DB	't keyboard data format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BOBKPIDJ@?$ACI_StartupKeyboard?$CI?$CJ?3?5called?5tw@
CONST	SEGMENT
??_C@_0CE@BOBKPIDJ@?$ACI_StartupKeyboard?$CI?$CJ?3?5called?5tw@ DB 02H, 'I'
	DB	'_StartupKeyboard(): called twice', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNGEHEON@MumbleLink@
CONST	SEGMENT
??_C@_0L@KNGEHEON@MumbleLink@ DB 'MumbleLink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGIELGBD@MapViewOfFile@
CONST	SEGMENT
??_C@_0O@IGIELGBD@MapViewOfFile@ DB 'MapViewOfFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LOCJLGON@OpenFileMappingA@
CONST	SEGMENT
??_C@_0BB@LOCJLGON@OpenFileMappingA@ DB 'OpenFileMappingA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll@ DB 'kernel32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EPEJCJNA@?6I_GetJoyName?$CI?$CJ?3?5EnumDevices?5FA@
CONST	SEGMENT
??_C@_0CF@EPEJCJNA@?6I_GetJoyName?$CI?$CJ?3?5EnumDevices?5FA@ DB 0aH, 'I_'
	DB	'GetJoyName(): EnumDevices FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JJKCEPAA@?6I_NumJoys?$CI?$CJ?3?5EnumDevices?5FAILE@
CONST	SEGMENT
??_C@_0CC@JJKCEPAA@?6I_NumJoys?$CI?$CJ?3?5EnumDevices?5FAILE@ DB 0aH, 'I_'
	DB	'NumJoys(): EnumDevices FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BMFKANEO@I_GetJoystickEvents2?$CI?$CJ?3?5GetDevi@
CONST	SEGMENT
??_C@_0CP@BMFKANEO@I_GetJoystickEvents2?$CI?$CJ?3?5GetDevi@ DB 'I_GetJoys'
	DB	'tickEvents2(): GetDeviceState FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DNBGLDEG@I_GetJoystick2Events?$CI?$CJ?3?5Poll?5FA@
CONST	SEGMENT
??_C@_0CF@DNBGLDEG@I_GetJoystick2Events?$CI?$CJ?3?5Poll?5FA@ DB 'I_GetJoy'
	DB	'stick2Events(): Poll FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MNKDPIKA@I_GetJoystickEvents?$CI?$CJ?3?5GetDevic@
CONST	SEGMENT
??_C@_0CO@MNKDPIKA@I_GetJoystickEvents?$CI?$CJ?3?5GetDevic@ DB 'I_GetJoys'
	DB	'tickEvents(): GetDeviceState FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ODDENDCH@I_GetJoystickEvents?$CI?$CJ?3?5Poll?5FAI@
CONST	SEGMENT
??_C@_0CE@ODDENDCH@I_GetJoystickEvents?$CI?$CJ?3?5Poll?5FAI@ DB 'I_GetJoy'
	DB	'stickEvents(): Poll FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LPPGDECM@I_ShutdownJoystick2?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BH@LPPGDECM@I_ShutdownJoystick2?$CI?$CJ?6@ DB 'I_ShutdownJoystick2'
	DB	'()', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EGEPHJIA@I_ShutdownJoystick?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BG@EGEPHJIA@I_ShutdownJoystick?$CI?$CJ?6@ DB 'I_ShutdownJoystick()'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EOHHKFHE@Joystick2?5already?5initialized?6@
CONST	SEGMENT
??_C@_0BP@EOHHKFHE@Joystick2?5already?5initialized?6@ DB 'Joystick2 alrea'
	DB	'dy initialized', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JLJEILBJ@I_InitJoystick2?3?5SetCooperative@
CONST	SEGMENT
??_C@_0CM@JLJEILBJ@I_InitJoystick2?3?5SetCooperative@ DB 'I_InitJoystick2'
	DB	': SetCooperativeLevel FAILED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NIGDHMKK@?$ACSet?5the?5use_joystick2?5variable@
CONST	SEGMENT
??_C@_0EL@NIGDHMKK@?$ACSet?5the?5use_joystick2?5variable@ DB 02H, 'Set th'
	DB	'e use_joystick2 variable to one of the enumerated joysticks n'
	DB	'umber', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IPGCHNBF@?6I_InitJoystick2?$CI?$CJ?3?5EnumDevices@
CONST	SEGMENT
??_C@_0CI@IPGCHNBF@?6I_InitJoystick2?$CI?$CJ?3?5EnumDevices@ DB 0aH, 'I_I'
	DB	'nitJoystick2(): EnumDevices FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GDGHMOCG@Joystick2?5disabled?6@
CONST	SEGMENT
??_C@_0BE@GDGHMOCG@Joystick2?5disabled?6@ DB 'Joystick2 disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MIDIBNKL@DIEnumJoysticks2?$CI?$CJ?3?5QueryInterf@
CONST	SEGMENT
??_C@_0CL@MIDIBNKL@DIEnumJoysticks2?$CI?$CJ?3?5QueryInterf@ DB 'DIEnumJoy'
	DB	'sticks2(): QueryInterface FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@MPCBNPML@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DK@MPCBNPML@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for V DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HCOLLDAF@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DK@HCOLLDAF@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for U DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BIDCPMBG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DL@BIDCPMBG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for RZ DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KFPIJANI@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DL@KFPIJANI@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for RY DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HIGOEJFN@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DL@HIGOEJFN@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for RX DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FFJLGGDA@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DK@FFJLGGDA@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for Z DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OIFBAKPO@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DK@OIFBAKPO@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for Y DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JCKOGIDG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
CONST	SEGMENT
??_C@_0DJ@JCKOGIDG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@ DB 'DIEnumJ'
	DB	'oysticks2(): couldn''t SetProperty for X DEAD ZONE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CKHJNDCH@DIEnumJoysticks2?$CI?$CJ?3?5SetCooperat@
CONST	SEGMENT
??_C@_0DA@CKHJNDCH@DIEnumJoysticks2?$CI?$CJ?3?5SetCooperat@ DB 'DIEnumJoy'
	DB	'sticks2(): SetCooperativeLevel FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KIJBDNAA@DIEnumJoysticks2?$CI?$CJ?3?5SetDataForm@
CONST	SEGMENT
??_C@_0CK@KIJBDNAA@DIEnumJoysticks2?$CI?$CJ?3?5SetDataForm@ DB 'DIEnumJoy'
	DB	'sticks2(): SetDataFormat FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JILFPGDB@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@
CONST	SEGMENT
??_C@_0EE@JILFPGDB@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@ DB 'Capab'
	DB	'ilities: %lu axes, %lu buttons, %lu POVs, poll %u, Gamepad %u'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JIABBHGO@DIEnumJoysticks2?$CI?$CJ?3?5GetCapabili@
CONST	SEGMENT
??_C@_0CM@JIABBHGO@DIEnumJoysticks2?$CI?$CJ?3?5GetCapabili@ DB 'DIEnumJoy'
	DB	'sticks2(): GetCapabilities FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FPCBGFNL@DIEnumJoysticks2?$CI?$CJ?3?5CreateDevic@
CONST	SEGMENT
??_C@_0CJ@FPCBGFNL@DIEnumJoysticks2?$CI?$CJ?3?5CreateDevic@ DB 'DIEnumJoy'
	DB	'sticks2(): CreateDevice FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GGPBHPCK@Joystick?5already?5initialized?6@
CONST	SEGMENT
??_C@_0BO@GGPBHPCK@Joystick?5already?5initialized?6@ DB 'Joystick already'
	DB	' initialized', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LHFCLCKD@I_InitJoystick?3?5SetCooperativeL@
CONST	SEGMENT
??_C@_0CL@LHFCLCKD@I_InitJoystick?3?5SetCooperativeL@ DB 'I_InitJoystick:'
	DB	' SetCooperativeLevel FAILED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@EBIAMJEC@?$ACSet?5the?5use_joystick?5variable?5@
CONST	SEGMENT
??_C@_0EK@EBIAMJEC@?$ACSet?5the?5use_joystick?5variable?5@ DB 02H, 'Set t'
	DB	'he use_joystick variable to one of the enumerated joystick nu'
	DB	'mbers', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJHFOLIP@none?5used?6@
CONST	SEGMENT
??_C@_0L@CJHFOLIP@none?5used?6@ DB 'none used', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OIPHNGKP@none?5found?6@
CONST	SEGMENT
??_C@_0M@OIPHNGKP@none?5found?6@ DB 'none found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EMBOCGPJ@?6I_InitJoystick?$CI?$CJ?3?5EnumDevices?5@
CONST	SEGMENT
??_C@_0CH@EMBOCGPJ@?6I_InitJoystick?$CI?$CJ?3?5EnumDevices?5@ DB 0aH, 'I_'
	DB	'InitJoystick(): EnumDevices FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PKLGBKMF@Looking?5for?5joystick?5devices?3?6@
CONST	SEGMENT
??_C@_0BP@PKLGBKMF@Looking?5for?5joystick?5devices?3?6@ DB 'Looking for j'
	DB	'oystick devices:', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LCNJCENL@Joystick?5disabled?6@
CONST	SEGMENT
??_C@_0BD@LCNJCENL@Joystick?5disabled?6@ DB 'Joystick disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIIKPKO@?9nojoy@
CONST	SEGMENT
??_C@_06MIIKPKO@?9nojoy@ DB '-nojoy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KMBLEGGG@DIEnumJoysticks?$CI?$CJ?3?5QueryInterfa@
CONST	SEGMENT
??_C@_0CK@KMBLEGGG@DIEnumJoysticks?$CI?$CJ?3?5QueryInterfa@ DB 'DIEnumJoy'
	DB	'sticks(): QueryInterface FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PKIAKGDN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DJ@PKIAKGDN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for V DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EHEKMKPD@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DJ@EHEKMKPD@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for U DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EMNJAKEG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DK@EMNJAKEG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for RZ DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PBBDGGII@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DK@PBBDGGII@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for RY DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CMIFLPAN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DK@CMIFLPAN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for RX DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GADKBPMG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DJ@GADKBPMG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for Z DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NNPAHDAI@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DJ@NNPAHDAI@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for Y DEAD ZONE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@IGHPGEBO@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
CONST	SEGMENT
??_C@_0DI@IGHPGEBO@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@ DB 'DIEnumJ'
	DB	'oysticks(): couldn''t SetProperty for X DEAD ZONE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BMGKCBPE@DIEnumJoysticks?$CI?$CJ?3?5SetCooperati@
CONST	SEGMENT
??_C@_0CP@BMGKCBPE@DIEnumJoysticks?$CI?$CJ?3?5SetCooperati@ DB 'DIEnumJoy'
	DB	'sticks(): SetCooperativeLevel FAILED', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OAGCDABJ@DIEnumJoysticks?$CI?$CJ?3?5SetDataForma@
CONST	SEGMENT
??_C@_0CJ@OAGCDABJ@DIEnumJoysticks?$CI?$CJ?3?5SetDataForma@ DB 'DIEnumJoy'
	DB	'sticks(): SetDataFormat FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@IFFBDPHG@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@
CONST	SEGMENT
??_C@_0EE@IFFBDPHG@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@ DB 'Capab'
	DB	'ilities: %lu axes, %lu buttons, %lu POVs, poll %u, Gamepad %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HNLAIKDI@DIEnumJoysticks?$CI?$CJ?3?5GetCapabilit@
CONST	SEGMENT
??_C@_0CL@HNLAIKDI@DIEnumJoysticks?$CI?$CJ?3?5GetCapabilit@ DB 'DIEnumJoy'
	DB	'sticks(): GetCapabilities FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BOBKDHHM@DIEnumJoysticks?$CI?$CJ?3?5CreateDevice@
CONST	SEGMENT
??_C@_0CI@BOBKDHHM@DIEnumJoysticks?$CI?$CJ?3?5CreateDevice@ DB 'DIEnumJoy'
	DB	'sticks(): CreateDevice FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EBBEIMPI@?$CFc?$CFd?3?5?$CFs?6@
CONST	SEGMENT
??_C@_09EBBEIMPI@?$CFc?$CFd?3?5?$CFs?6@ DB '%c%d: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CBEGCOGG@I_ShutdownMouse?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BD@CBEGCOGG@I_ShutdownMouse?$CI?$CJ?6@ DB 'I_ShutdownMouse()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NLCOHANC@Couldn?8t?5create?5mouse?5input@
CONST	SEGMENT
??_C@_0BM@NLCOHANC@Couldn?8t?5create?5mouse?5input@ DB 'Couldn''t create '
	DB	'mouse input', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MCGALMJM@Couldn?8t?5set?5mouse?5coop?5level@
CONST	SEGMENT
??_C@_0BO@MCGALMJM@Couldn?8t?5set?5mouse?5coop?5level@ DB 'Couldn''t set '
	DB	'mouse coop level', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IGFGLPOP@Couldn?8t?5set?5mouse?5buffer?5size@
CONST	SEGMENT
??_C@_0BP@IGFGLPOP@Couldn?8t?5set?5mouse?5buffer?5size@ DB 'Couldn''t set'
	DB	' mouse buffer size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MNDEIMNB@Couldn?8t?5set?5mouse?5data?5format@
CONST	SEGMENT
??_C@_0BP@MNDEIMNB@Couldn?8t?5set?5mouse?5data?5format@ DB 'Couldn''t set'
	DB	' mouse data format', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MPELICFG@?7Mouse?5will?5not?5use?5DirectInput@
CONST	SEGMENT
??_C@_0CC@MPELICFG@?7Mouse?5will?5not?5use?5DirectInput@ DB 09H, 'Mouse w'
	DB	'ill not use DirectInput.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPADOFHN@?9nomouse@
CONST	SEGMENT
??_C@_08GPADOFHN@?9nomouse@ DB '-nomouse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KLMPAIBH@?$ACCan?8t?5open?5?$CFs?3?5error?5?$CFd?6@
CONST	SEGMENT
??_C@_0BK@KLMPAIBH@?$ACCan?8t?5open?5?$CFs?3?5error?5?$CFd?6@ DB 02H, 'Ca'
	DB	'n''t open %s: error %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@KJGNAMBA@?$ACCan?8t?5open?5?$CFs?3?5Access?5denied?6T@
CONST	SEGMENT
??_C@_0GG@KJGNAMBA@?$ACCan?8t?5open?5?$CFs?3?5Access?5denied?6T@ DB 02H, 'C'
	DB	'an''t open %s: Access denied', 0aH, 'The port is probably alr'
	DB	'eady used by another device (mouse, modem,...)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KCELBNNB@?$ACRead?5Error?5on?5secondary?5mouse?5@
CONST	SEGMENT
??_C@_0CF@KCELBNNB@?$ACRead?5Error?5on?5secondary?5mouse?5@ DB 02H, 'Read'
	DB	' Error on secondary mouse port', 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_mouse2filehandle DD 0ffffffffH
_new_mparms DD	00H
	DD	00H
	DD	01H
_needjoy DD	0ffffffffH
	ORG $+4
_ASCIINames DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	08H
	DB	09H
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	09dH
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03bH
	DB	027H
	DB	060H
	DB	0b6H
	DB	05cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	0b7H
	DB	02aH
	DB	0b8H
	DB	020H
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d3H
	DB	00H
	DB	00H
	DB	00H
	DB	0d7H
	DB	0d8H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	09eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0d3H
	DB	00H
	DB	0e4H
	DB	00H
	DB	00H
	DB	0b9H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	00H
	DB	0e9H
	DB	00H
	DB	0ebH
	DB	00H
	DB	0edH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f1H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_cv_cpuaffinity DD FLAT:??_C@_0M@GCIMPDEH@cpuaffinity@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	03H
	DD	00H
	DD	FLAT:_CPUAffinity_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0CF@MJPBPFFC@Could?5not?5create?5IDirectInput?5d@
CONST	SEGMENT
??_C@_0CF@MJPBPFFC@Could?5not?5create?5IDirectInput?5d@ DB 'Could not cre'
	DB	'ate IDirectInput device', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HMIBAJHL@?$ACCould?5not?5create?5IDirectInput?5@
CONST	SEGMENT
??_C@_0CI@HMIBAJHL@?$ACCould?5not?5create?5IDirectInput?5@ DB 02H, 'Could'
	DB	' not create IDirectInput device 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDGKGPGK@GetLastError?3?5?$CFs@
CONST	SEGMENT
??_C@_0BB@CDGKGPGK@GetLastError?3?5?$CFs@ DB 'GetLastError: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HICKNDGL@GetLastError@
CONST	SEGMENT
??_C@_0N@HICKNDGL@GetLastError@ DB 'GetLastError', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFODMEHN@GetLastError?3?5Unknown?6@
CONST	SEGMENT
??_C@_0BH@CFODMEHN@GetLastError?3?5Unknown?6@ DB 'GetLastError: Unknown', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LIIJDEN@?$AN@
CONST	SEGMENT
??_C@_01LIIJDEN@?$AN@ DB 0dH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EJJCJJPM@?9noendtxt@
CONST	SEGMENT
??_C@_09EJJCJJPM@?9noendtxt@ DB '-noendtxt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LBJCGNPE@I_Quit?$CI?$CJ?3?5end?5of?5logstream?4?$AN?6@
CONST	SEGMENT
??_C@_0BO@LBJCGNPE@I_Quit?$CI?$CJ?3?5end?5of?5logstream?4?$AN?6@ DB 'I_Qu'
	DB	'it(): end of logstream.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NBJMEAKN@Error?5detected?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BE@NBJMEAKN@Error?5detected?5?$CI?$CFd?$CJ@ DB 'Error detected (%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBOHFMBE@ENDOOM@
CONST	SEGMENT
??_C@_06BBOHFMBE@ENDOOM@ DB 'ENDOOM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDMHDCFA@SRB2?5Error@
CONST	SEGMENT
??_C@_0L@HDMHDCFA@SRB2?5Error@ DB 'SRB2 Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PKDMOCMC@I_Error?$CI?$CJ?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@PKDMOCMC@I_Error?$CI?$CJ?3?5?$CFs?6@ DB 'I_Error(): %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HIGGEAIG@SRB2?5Recursive?5Error@
CONST	SEGMENT
??_C@_0BF@HIGGEAIG@SRB2?5Recursive?5Error@ DB 'SRB2 Recursive Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CHODMMMD@Using?5GetTickCount?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BG@CHODMMMD@Using?5GetTickCount?$CI?$CJ?6@ DB 'Using GetTickCount('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBBOFCJA@?9gettickcount@
CONST	SEGMENT
??_C@_0O@MBBOFCJA@?9gettickcount@ DB '-gettickcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EFGNEMMJ@I_EndProfile?5overflow@
CONST	SEGMENT
??_C@_0BG@EFGNEMMJ@I_EndProfile?5overflow@ DB 'I_EndProfile overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EEFIPHAL@I_EndProfile?5failed@
CONST	SEGMENT
??_C@_0BE@EEFIPHAL@I_EndProfile?5failed@ DB 'I_EndProfile failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ICIDLEJE@I_BeginProfile?5failed@
CONST	SEGMENT
??_C@_0BG@ICIDLEJE@I_BeginProfile?5failed@ DB 'I_BeginProfile failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@
CONST	SEGMENT
??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@ DB 'MSWHEEL_ROLLMSG', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	069bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	069bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	04cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01b8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0151H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0f4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	024aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0aeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0afH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0193H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	065H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01a7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01a7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0268H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0175H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0136H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03baH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	07b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	07b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0172H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0148H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0f5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	039H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0198H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _GetAffinityFuncs
_TEXT	SEGMENT
_h$ = -4						; size = 4
_GetAffinityFuncs PROC					; COMDAT

; 3622 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3623 : 	HMODULE h = GetModuleHandleA("kernel32.dll");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00014	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax

; 3624 : 	pfnGetCurrentProcess = (p_GetCurrentProcess)GetProcAddress(h, "GetCurrentProcess");

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PMJGPBJJ@GetCurrentProcess@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00026	a3 00 00 00 00	 mov	 DWORD PTR _pfnGetCurrentProcess, eax

; 3625 : 	pfnGetProcessAffinityMask = (p_GetProcessAffinityMask)GetProcAddress(h, "GetProcessAffinityMask");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EJFHALGI@GetProcessAffinityMask@
  00030	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0003a	a3 00 00 00 00	 mov	 DWORD PTR _pfnGetProcessAffinityMask, eax

; 3626 : 	pfnSetProcessAffinityMask = (p_SetProcessAffinityMask)GetProcAddress(h, "SetProcessAffinityMask");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EIHJCMLH@SetProcessAffinityMask@
  00044	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0004e	a3 00 00 00 00	 mov	 DWORD PTR _pfnSetProcessAffinityMask, eax

; 3627 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_GetAffinityFuncs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _CPUAffinity_OnChange
_TEXT	SEGMENT
_selfpid$ = -12						; size = 4
_dwSysMask$ = -8					; size = 4
_dwProcMask$ = -4					; size = 4
_CPUAffinity_OnChange PROC				; COMDAT

; 3630 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3631 : 	DWORD_PTR dwProcMask, dwSysMask;
; 3632 : 	HANDLE selfpid;
; 3633 : 
; 3634 : 	if (!pfnGetCurrentProcess || !pfnGetProcessAffinityMask || !pfnSetProcessAffinityMask)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnGetCurrentProcess, 0
  00010	74 12		 je	 SHORT $LN4@CPUAffinit
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnGetProcessAffinityMask, 0
  00019	74 09		 je	 SHORT $LN4@CPUAffinit
  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnSetProcessAffinityMask, 0
  00022	75 04		 jne	 SHORT $LN2@CPUAffinit
$LN4@CPUAffinit:

; 3635 : 		return;

  00024	eb 68		 jmp	 SHORT $LN6@CPUAffinit
  00026	eb 09		 jmp	 SHORT $LN3@CPUAffinit
$LN2@CPUAffinit:

; 3636 : 	else
; 3637 : 		selfpid = pfnGetCurrentProcess();

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnGetCurrentProcess
  0002e	89 45 f4	 mov	 DWORD PTR _selfpid$[ebp], eax
$LN3@CPUAffinit:

; 3638 : 
; 3639 : 	pfnGetProcessAffinityMask(selfpid, &dwProcMask, &dwSysMask);

  00031	8d 45 f8	 lea	 eax, DWORD PTR _dwSysMask$[ebp]
  00034	50		 push	 eax
  00035	8d 4d fc	 lea	 ecx, DWORD PTR _dwProcMask$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 f4	 mov	 edx, DWORD PTR _selfpid$[ebp]
  0003c	52		 push	 edx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnGetProcessAffinityMask
  00043	90		 npad	 1

; 3640 : 
; 3641 : 	/* If resulting mask is zero, don't change anything and fall back to
; 3642 : 	 * actual mask.
; 3643 : 	 */
; 3644 : 	if(dwSysMask & cv_cpuaffinity.value)

  00044	8b 45 f8	 mov	 eax, DWORD PTR _dwSysMask$[ebp]
  00047	23 05 14 00 00
	00		 and	 eax, DWORD PTR _cv_cpuaffinity+20
  0004d	74 2e		 je	 SHORT $LN5@CPUAffinit

; 3645 : 	{
; 3646 : 		pfnSetProcessAffinityMask(selfpid, dwSysMask & cv_cpuaffinity.value);

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _dwSysMask$[ebp]
  00052	23 05 14 00 00
	00		 and	 eax, DWORD PTR _cv_cpuaffinity+20
  00058	50		 push	 eax
  00059	8b 4d f4	 mov	 ecx, DWORD PTR _selfpid$[ebp]
  0005c	51		 push	 ecx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnSetProcessAffinityMask
  00063	90		 npad	 1

; 3647 : 		CV_StealthSetValue(&cv_cpuaffinity, (int)(dwSysMask & cv_cpuaffinity.value));

  00064	8b 45 f8	 mov	 eax, DWORD PTR _dwSysMask$[ebp]
  00067	23 05 14 00 00
	00		 and	 eax, DWORD PTR _cv_cpuaffinity+20
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET _cv_cpuaffinity
  00073	e8 00 00 00 00	 call	 _CV_StealthSetValue
  00078	83 c4 08	 add	 esp, 8

; 3648 : 	}

  0007b	eb 11		 jmp	 SHORT $LN6@CPUAffinit
$LN5@CPUAffinit:

; 3649 : 	else
; 3650 : 		CV_StealthSetValue(&cv_cpuaffinity, (int)dwProcMask);

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _dwProcMask$[ebp]
  00080	50		 push	 eax
  00081	68 00 00 00 00	 push	 OFFSET _cv_cpuaffinity
  00086	e8 00 00 00 00	 call	 _CV_StealthSetValue
  0008b	83 c4 08	 add	 esp, 8
$LN6@CPUAffinit:

; 3651 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_CPUAffinity_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownDirectInput
_TEXT	SEGMENT
_I_ShutdownDirectInput PROC				; COMDAT

; 3392 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3393 : 	if (lpDI)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDI, 0
  00010	74 14		 je	 SHORT $LN2@I_Shutdown

; 3394 : 		IDirectInput_Release(lpDI);

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  00017	50		 push	 eax
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDI
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	ff d0		 call	 eax
  00025	90		 npad	 1
$LN2@I_Shutdown:

; 3395 : 	lpDI = NULL;

  00026	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDI, 0

; 3396 : 	UnLoadDirectInput();

  00030	e8 00 00 00 00	 call	 _UnLoadDirectInput
  00035	90		 npad	 1

; 3397 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_I_ShutdownDirectInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _UnLoadDirectInput
_TEXT	SEGMENT
_UnLoadDirectInput PROC					; COMDAT

; 3379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3380 : 	if (!DInputDLL)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DInputDLL, 0
  00010	75 02		 jne	 SHORT $LN2@UnLoadDire

; 3381 : 		return;

  00012	eb 21		 jmp	 SHORT $LN1@UnLoadDire
$LN2@UnLoadDire:

; 3382 : 	FreeLibrary(DInputDLL);

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _DInputDLL
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00020	90		 npad	 1

; 3383 : 	pfnDirectInputCreateA = NULL;

  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pfnDirectInputCreateA, 0

; 3384 : 	DInputDLL = NULL;

  0002b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DInputDLL, 0
$LN1@UnLoadDire:

; 3385 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_UnLoadDirectInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _DIEnumJoysticksCount@8
_TEXT	SEGMENT
_lpddi$ = 8						; size = 4
_pvRef$ = 12						; size = 4
_DIEnumJoysticksCount@8 PROC				; COMDAT

; 3007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3008 : 	numofjoy++;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _numofjoy
  0000e	83 c0 01	 add	 eax, 1
  00011	a3 00 00 00 00	 mov	 DWORD PTR _numofjoy, eax

; 3009 : 	if (needjoy == numofjoy && pvRef && pvRef == (void *)joyname && lpddi
; 3010 : 		&& lpddi->tszProductName)

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _needjoy
  0001b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofjoy
  00021	75 3e		 jne	 SHORT $LN2@DIEnumJoys
  00023	83 7d 0c 00	 cmp	 DWORD PTR _pvRef$[ebp], 0
  00027	74 38		 je	 SHORT $LN2@DIEnumJoys
  00029	81 7d 0c 00 00
	00 00		 cmp	 DWORD PTR _pvRef$[ebp], OFFSET _joyname
  00030	75 2f		 jne	 SHORT $LN2@DIEnumJoys
  00032	83 7d 08 00	 cmp	 DWORD PTR _lpddi$[ebp], 0
  00036	74 29		 je	 SHORT $LN2@DIEnumJoys
  00038	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  0003b	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00040	74 1f		 je	 SHORT $LN2@DIEnumJoys

; 3011 : 	{
; 3012 : 		sprintf(joyname,"%s",lpddi->tszProductName);

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  00045	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00050	68 00 00 00 00	 push	 OFFSET _joyname
  00055	e8 00 00 00 00	 call	 _sprintf
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3013 : 		return DIENUM_STOP;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 05		 jmp	 SHORT $LN1@DIEnumJoys
$LN2@DIEnumJoys:

; 3014 : 	}
; 3015 : 	//else if (devparm) I_OutputMsg("DIEnumJoysticksCount need help!");
; 3016 : 	return DIENUM_CONTINUE;

  00061	b8 01 00 00 00	 mov	 eax, 1
$LN1@DIEnumJoys:

; 3017 : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
_DIEnumJoysticksCount@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _DIEnumJoysticks2@8
_TEXT	SEGMENT
tv79 = -160						; size = 4
tv141 = -160						; size = 4
tv149 = -160						; size = 4
_tp$1 = -92						; size = 4
_rp$2 = -88						; size = 4
_i$3 = -84						; size = 4
_bUseThisOne$ = -80					; size = 4
_caps$ = -76						; size = 44
_diprg$ = -32						; size = 24
_pdev$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpddi$ = 8						; size = 4
_pvRef$ = 12						; size = 4
_DIEnumJoysticks2@8 PROC				; COMDAT

; 2021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2022 : 	LPDIRECTINPUTDEVICEA pdev;
; 2023 : 	DIPROPRANGE          diprg;
; 2024 : 	DIDEVCAPS            caps;
; 2025 : 	BOOL                 bUseThisOne = FALSE;

  00016	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _bUseThisOne$[ebp], 0

; 2026 : 
; 2027 : 	iJoy2Num++;

  0001d	a0 00 00 00 00	 mov	 al, BYTE PTR _iJoy2Num
  00022	04 01		 add	 al, 1
  00024	a2 00 00 00 00	 mov	 BYTE PTR _iJoy2Num, al

; 2028 : 
; 2029 : 	//faB: if cv holds a string description of joystick, the value from atoi() is 0
; 2030 : 	//     else, the value was probably set by user at console to one of the previsouly
; 2031 : 	//     enumerated joysticks
; 2032 : 	if (((consvar_t *)pvRef)->value == iJoy2Num || !strcmp(((consvar_t *)pvRef)->string, lpddi->tszProductName))

  00029	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoy2Num
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  00033	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  00036	74 1c		 je	 SHORT $LN6@DIEnumJoys
  00038	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  0003b	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00040	50		 push	 eax
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  00044	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _strcmp
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	75 07		 jne	 SHORT $LN5@DIEnumJoys
$LN6@DIEnumJoys:

; 2033 : 		bUseThisOne = TRUE;

  00054	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _bUseThisOne$[ebp], 1
$LN5@DIEnumJoys:

; 2034 : 
; 2035 : 	//CONS_Printf(" cv joy2 is %s\n", ((consvar_t *)pvRef)->string);
; 2036 : 
; 2037 : 	// print out device name
; 2038 : 	CONS_Printf("%c%d: %s\n",

  0005b	83 7d b0 00	 cmp	 DWORD PTR _bUseThisOne$[ebp], 0
  0005f	74 0c		 je	 SHORT $LN56@DIEnumJoys
  00061	c7 85 60 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR tv79[ebp], 2
  0006b	eb 0a		 jmp	 SHORT $LN57@DIEnumJoys
$LN56@DIEnumJoys:
  0006d	c7 85 60 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR tv79[ebp], 32	; 00000020H
$LN57@DIEnumJoys:
  00077	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  0007a	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0007f	50		 push	 eax
  00080	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _iJoy2Num
  00087	51		 push	 ecx
  00088	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  0008e	52		 push	 edx
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_09EBBEIMPI@?$CFc?$CFd?3?5?$CFs?6@
  00094	e8 00 00 00 00	 call	 _CONS_Printf
  00099	83 c4 10	 add	 esp, 16			; 00000010H

; 2039 : 	            (bUseThisOne) ? '\2' : ' ',   // show name in white if this is the one we will use
; 2040 : 	            iJoy2Num,
; 2041 : 	            //(GET_DIDEVICE_SUBTYPE(lpddi->dwDevType) == DIDEVTYPEJOYSTICK_GAMEPAD) ? "Gamepad " : "Joystick",
; 2042 : 	            lpddi->tszProductName); //, lpddi->tszInstanceName);
; 2043 : 
; 2044 : 	// use specified joystick (cv_usejoystick.value in pvRef)
; 2045 : 	if (!bUseThisOne)

  0009c	83 7d b0 00	 cmp	 DWORD PTR _bUseThisOne$[ebp], 0
  000a0	75 0a		 jne	 SHORT $LN7@DIEnumJoys

; 2046 : 		return DIENUM_CONTINUE;

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	e9 ec 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN7@DIEnumJoys:

; 2047 : 
; 2048 : 	((consvar_t *)pvRef)->value = iJoy2Num;

  000ac	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoy2Num
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  000b6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 2049 : 	if (IDirectInput_CreateDevice (lpDI, &lpddi->guidInstance,
; 2050 : 	                               &pdev, NULL) != DI_OK)

  000b9	6a 00		 push	 0
  000bb	8d 45 f8	 lea	 eax, DWORD PTR _pdev$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _lpddi$[ebp]
  000c2	83 c1 04	 add	 ecx, 4
  000c5	51		 push	 ecx
  000c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDI
  000cc	52		 push	 edx
  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  000d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000d7	ff d2		 call	 edx
  000d9	85 c0		 test	 eax, eax
  000db	74 17		 je	 SHORT $LN8@DIEnumJoys

; 2051 : 	{
; 2052 : 		// if it failed, then we can't use this joystick for some
; 2053 : 		// bizarre reason.  (Maybe the user unplugged it while we
; 2054 : 		// were in the middle of enumerating it.)  So continue enumerating
; 2055 : 		CONS_Printf("DIEnumJoysticks2(): CreateDevice FAILED\n");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FPCBGFNL@DIEnumJoysticks2?$CI?$CJ?3?5CreateDevic@
  000e2	e8 00 00 00 00	 call	 _CONS_Printf
  000e7	83 c4 04	 add	 esp, 4

; 2056 : 		return DIENUM_CONTINUE;

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	e9 a4 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN8@DIEnumJoys:

; 2057 : 	}
; 2058 : 
; 2059 : 
; 2060 : 	// get the Device capabilities
; 2061 : 	//
; 2062 : 	caps.dwSize = sizeof (DIDEVCAPS_DX3);

  000f4	c7 45 b4 18 00
	00 00		 mov	 DWORD PTR _caps$[ebp], 24 ; 00000018H

; 2063 : 	if (FAILED(IDirectInputDevice_GetCapabilities (pdev, &caps)))

  000fb	8d 45 b4	 lea	 eax, DWORD PTR _caps$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  00106	8b 02		 mov	 eax, DWORD PTR [edx]
  00108	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0010b	ff d1		 call	 ecx
  0010d	85 c0		 test	 eax, eax
  0010f	7d 26		 jge	 SHORT $LN9@DIEnumJoys

; 2064 : 	{
; 2065 : 		CONS_Printf("DIEnumJoysticks2(): GetCapabilities FAILED\n");

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@JIABBHGO@DIEnumJoysticks2?$CI?$CJ?3?5GetCapabili@
  00116	e8 00 00 00 00	 call	 _CONS_Printf
  0011b	83 c4 04	 add	 esp, 4

; 2066 : 		IDirectInputDevice_Release (pdev);

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00121	50		 push	 eax
  00122	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00125	8b 11		 mov	 edx, DWORD PTR [ecx]
  00127	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0012a	ff d0		 call	 eax
  0012c	90		 npad	 1

; 2067 : 		return DIENUM_CONTINUE;

  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	e9 61 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN9@DIEnumJoys:

; 2068 : 	}
; 2069 : 	if (!(caps.dwFlags & DIDC_ATTACHED))   // should be, since we enumerate only attached devices

  00137	8b 45 b8	 mov	 eax, DWORD PTR _caps$[ebp+4]
  0013a	83 e0 01	 and	 eax, 1
  0013d	75 0a		 jne	 SHORT $LN10@DIEnumJoys

; 2070 : 		return DIENUM_CONTINUE;

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	e9 4f 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN10@DIEnumJoys:

; 2071 : 
; 2072 : 	Joystick2.bJoyNeedPoll = ((caps.dwFlags & DIDC_POLLEDDATAFORMAT) != 0);

  00149	8b 45 b8	 mov	 eax, DWORD PTR _caps$[ebp+4]
  0014c	83 e0 08	 and	 eax, 8
  0014f	74 0c		 je	 SHORT $LN58@DIEnumJoys
  00151	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv141[ebp], 1
  0015b	eb 0a		 jmp	 SHORT $LN59@DIEnumJoys
$LN58@DIEnumJoys:
  0015d	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
$LN59@DIEnumJoys:
  00167	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv141[ebp]
  0016d	89 0d 00 00 00
	00		 mov	 DWORD PTR _Joystick2, ecx

; 2073 : 
; 2074 : 	if (caps.dwFlags & DIDC_FORCEFEEDBACK)

  00173	8b 45 b8	 mov	 eax, DWORD PTR _caps$[ebp+4]
  00176	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0017b	74 0c		 je	 SHORT $LN11@DIEnumJoys

; 2075 : 		JoyInfo2.ForceAxises = 0;

  0017d	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _JoyInfo2+8, 0
  00187	eb 0a		 jmp	 SHORT $LN12@DIEnumJoys
$LN11@DIEnumJoys:

; 2076 : 	else
; 2077 : 		JoyInfo2.ForceAxises = -1;

  00189	c7 05 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _JoyInfo2+8, -1
$LN12@DIEnumJoys:

; 2078 : 
; 2079 : 	Joystick2.bGamepadStyle = (GET_DIDEVICE_SUBTYPE(caps.dwDevType) == DIDEVTYPEJOYSTICK_GAMEPAD);

  00193	8b 45 bc	 mov	 eax, DWORD PTR _caps$[ebp+8]
  00196	c1 e8 08	 shr	 eax, 8
  00199	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019e	0f b6 c8	 movzx	 ecx, al
  001a1	83 f9 04	 cmp	 ecx, 4
  001a4	75 0c		 jne	 SHORT $LN60@DIEnumJoys
  001a6	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv149[ebp], 1
  001b0	eb 0a		 jmp	 SHORT $LN61@DIEnumJoys
$LN60@DIEnumJoys:
  001b2	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
$LN61@DIEnumJoys:
  001bc	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv149[ebp]
  001c2	89 15 04 00 00
	00		 mov	 DWORD PTR _Joystick2+4, edx

; 2080 : 	//DEBUG CONS_Printf("Gamepad: %d\n", Joystick2.bGamepadStyle);
; 2081 : 
; 2082 : 
; 2083 : 	CONS_Printf("Capabilities: %lu axes, %lu buttons, %lu POVs, poll %u, Gamepad %u\n",

  001c8	a1 04 00 00 00	 mov	 eax, DWORD PTR _Joystick2+4
  001cd	50		 push	 eax
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Joystick2
  001d4	51		 push	 ecx
  001d5	8b 55 c8	 mov	 edx, DWORD PTR _caps$[ebp+20]
  001d8	52		 push	 edx
  001d9	8b 45 c4	 mov	 eax, DWORD PTR _caps$[ebp+16]
  001dc	50		 push	 eax
  001dd	8b 4d c0	 mov	 ecx, DWORD PTR _caps$[ebp+12]
  001e0	51		 push	 ecx
  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JILFPGDB@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@
  001e6	e8 00 00 00 00	 call	 _CONS_Printf
  001eb	83 c4 18	 add	 esp, 24			; 00000018H

; 2084 : 	             caps.dwAxes, caps.dwButtons, caps.dwPOVs, Joystick2.bJoyNeedPoll, Joystick2.bGamepadStyle);
; 2085 : 
; 2086 : 
; 2087 : 	// Set the data format to "simple joystick" - a predefined data format
; 2088 : 	//
; 2089 : 	// A data format specifies which controls on a device we
; 2090 : 	// are interested in, and how they should be reported.
; 2091 : 	//
; 2092 : 	// This tells DirectInput that we will be passing a
; 2093 : 	// DIJOYSTATE structure to IDirectInputDevice::GetDeviceState.
; 2094 : 	if (IDirectInputDevice_SetDataFormat (pdev, &c_dfDIJoystick) != DI_OK)

  001ee	68 00 00 00 00	 push	 OFFSET _c_dfDIJoystick
  001f3	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  001f6	50		 push	 eax
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  001fa	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fc	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  001ff	ff d0		 call	 eax
  00201	85 c0		 test	 eax, eax
  00203	74 26		 je	 SHORT $LN13@DIEnumJoys

; 2095 : 	{
; 2096 : 		CONS_Printf("DIEnumJoysticks2(): SetDataFormat FAILED\n");

  00205	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KIJBDNAA@DIEnumJoysticks2?$CI?$CJ?3?5SetDataForm@
  0020a	e8 00 00 00 00	 call	 _CONS_Printf
  0020f	83 c4 04	 add	 esp, 4

; 2097 : 		IDirectInputDevice_Release (pdev);

  00212	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00215	50		 push	 eax
  00216	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00219	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0021e	ff d0		 call	 eax
  00220	90		 npad	 1

; 2098 : 		return DIENUM_CONTINUE;

  00221	b8 01 00 00 00	 mov	 eax, 1
  00226	e9 6d 04 00 00	 jmp	 $LN1@DIEnumJoys
$LN13@DIEnumJoys:

; 2099 : 	}
; 2100 : 
; 2101 : 	// Set the cooperativity level to let DirectInput know how
; 2102 : 	// this device should interact with the system and with other
; 2103 : 	// DirectInput applications.
; 2104 : 	if (IDirectInputDevice_SetCooperativeLevel (pdev, hWndMain,
; 2105 : 	         DISCL_EXCLUSIVE | DISCL_FOREGROUND) != DI_OK)

  0022b	6a 05		 push	 5
  0022d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00232	50		 push	 eax
  00233	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00236	51		 push	 ecx
  00237	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0023a	8b 02		 mov	 eax, DWORD PTR [edx]
  0023c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0023f	ff d1		 call	 ecx
  00241	85 c0		 test	 eax, eax
  00243	74 26		 je	 SHORT $LN14@DIEnumJoys

; 2106 : 	{
; 2107 : 		CONS_Printf("DIEnumJoysticks2(): SetCooperativeLevel FAILED\n");

  00245	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CKHJNDCH@DIEnumJoysticks2?$CI?$CJ?3?5SetCooperat@
  0024a	e8 00 00 00 00	 call	 _CONS_Printf
  0024f	83 c4 04	 add	 esp, 4

; 2108 : 		IDirectInputDevice_Release (pdev);

  00252	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00255	50		 push	 eax
  00256	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00259	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0025e	ff d0		 call	 eax
  00260	90		 npad	 1

; 2109 : 		return DIENUM_CONTINUE;

  00261	b8 01 00 00 00	 mov	 eax, 1
  00266	e9 2d 04 00 00	 jmp	 $LN1@DIEnumJoys
$LN14@DIEnumJoys:

; 2110 : 	}
; 2111 : 
; 2112 : 	// set the range of the joystick axis
; 2113 : 	diprg.diph.dwSize       = sizeof (DIPROPRANGE);

  0026b	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _diprg$[ebp], 24 ; 00000018H

; 2114 : 	diprg.diph.dwHeaderSize = sizeof (DIPROPHEADER);

  00272	c7 45 e4 10 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+4], 16 ; 00000010H

; 2115 : 	diprg.diph.dwHow        = DIPH_BYOFFSET;

  00279	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+12], 1

; 2116 : 	diprg.lMin              = -JOYAXISRANGE;    // value for extreme left

  00280	c7 45 f0 01 fc
	ff ff		 mov	 DWORD PTR _diprg$[ebp+16], -1023 ; fffffc01H

; 2117 : 	diprg.lMax              = +JOYAXISRANGE;    // value for extreme right

  00287	c7 45 f4 ff 03
	00 00		 mov	 DWORD PTR _diprg$[ebp+20], 1023 ; 000003ffH

; 2118 : 
; 2119 : 	diprg.diph.dwObj = DIJOFS_X;    // set the x-axis range

  0028e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 0

; 2120 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00295	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00298	50		 push	 eax
  00299	6a 04		 push	 4
  0029b	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0029e	51		 push	 ecx
  0029f	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  002a2	8b 02		 mov	 eax, DWORD PTR [edx]
  002a4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002a7	ff d1		 call	 ecx
  002a9	85 c0		 test	 eax, eax
  002ab	7d 09		 jge	 SHORT $LN15@DIEnumJoys

; 2121 : 	{
; 2122 : 		//goto SetPropFail;
; 2123 : 		JoyInfo2.X = FALSE;

  002ad	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2, 0

; 2124 : 	}

  002b4	eb 07		 jmp	 SHORT $LN16@DIEnumJoys
$LN15@DIEnumJoys:

; 2125 : 	else JoyInfo2.X = TRUE;

  002b6	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2, 1
$LN16@DIEnumJoys:

; 2126 : 
; 2127 : 	diprg.diph.dwObj = DIJOFS_Y;    // set the y-axis range

  002bd	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 4

; 2128 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  002c4	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  002c7	50		 push	 eax
  002c8	6a 04		 push	 4
  002ca	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  002cd	51		 push	 ecx
  002ce	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  002d1	8b 02		 mov	 eax, DWORD PTR [edx]
  002d3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002d6	ff d1		 call	 ecx
  002d8	85 c0		 test	 eax, eax
  002da	7d 09		 jge	 SHORT $LN17@DIEnumJoys

; 2129 : 	{
; 2130 : //SetPropFail:
; 2131 : //		CONS_Printf("DIEnumJoysticks(): SetProperty FAILED\n");
; 2132 : //		IDirectInputDevice_Release (pdev);
; 2133 : //		return DIENUM_CONTINUE;
; 2134 : 		JoyInfo2.Y = FALSE;

  002dc	c6 05 01 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+1, 0

; 2135 : 	}

  002e3	eb 07		 jmp	 SHORT $LN18@DIEnumJoys
$LN17@DIEnumJoys:

; 2136 : 	else JoyInfo2.Y = TRUE;

  002e5	c6 05 01 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+1, 1
$LN18@DIEnumJoys:

; 2137 : 
; 2138 : 	diprg.diph.dwObj = DIJOFS_Z;    // set the z-axis range

  002ec	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 8

; 2139 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  002f3	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  002f6	50		 push	 eax
  002f7	6a 04		 push	 4
  002f9	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  002fc	51		 push	 ecx
  002fd	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  00300	8b 02		 mov	 eax, DWORD PTR [edx]
  00302	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00305	ff d1		 call	 ecx
  00307	85 c0		 test	 eax, eax
  00309	7d 09		 jge	 SHORT $LN19@DIEnumJoys

; 2140 : 	{
; 2141 : 		//CONS_Printf("DIJOFS_Z not found\n");
; 2142 : 		JoyInfo2.Z = FALSE;

  0030b	c6 05 02 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+2, 0

; 2143 : 	}

  00312	eb 07		 jmp	 SHORT $LN20@DIEnumJoys
$LN19@DIEnumJoys:

; 2144 : 	else JoyInfo2.Z = TRUE;

  00314	c6 05 02 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+2, 1
$LN20@DIEnumJoys:

; 2145 : 
; 2146 : 	diprg.diph.dwObj = DIJOFS_RX;   // set the x-rudder range

  0031b	c7 45 e8 0c 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 12 ; 0000000cH

; 2147 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00322	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00325	50		 push	 eax
  00326	6a 04		 push	 4
  00328	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0032b	51		 push	 ecx
  0032c	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0032f	8b 02		 mov	 eax, DWORD PTR [edx]
  00331	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00334	ff d1		 call	 ecx
  00336	85 c0		 test	 eax, eax
  00338	7d 09		 jge	 SHORT $LN21@DIEnumJoys

; 2148 : 	{
; 2149 : 		//CONS_Printf("DIJOFS_RX (x-rudder) not found\n");
; 2150 : 		JoyInfo2.Rx = FALSE;

  0033a	c6 05 03 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+3, 0

; 2151 : 	}

  00341	eb 07		 jmp	 SHORT $LN22@DIEnumJoys
$LN21@DIEnumJoys:

; 2152 : 	else JoyInfo2.Rx = TRUE;

  00343	c6 05 03 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+3, 1
$LN22@DIEnumJoys:

; 2153 : 
; 2154 : 	diprg.diph.dwObj = DIJOFS_RY;   // set the y-rudder range

  0034a	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 16 ; 00000010H

; 2155 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00351	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00354	50		 push	 eax
  00355	6a 04		 push	 4
  00357	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0035a	51		 push	 ecx
  0035b	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0035e	8b 02		 mov	 eax, DWORD PTR [edx]
  00360	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00363	ff d1		 call	 ecx
  00365	85 c0		 test	 eax, eax
  00367	7d 09		 jge	 SHORT $LN23@DIEnumJoys

; 2156 : 	{
; 2157 : 		//CONS_Printf("DIJOFS_RY (y-rudder) not found\n");
; 2158 : 		JoyInfo2.Ry = FALSE;

  00369	c6 05 04 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+4, 0

; 2159 : 	}

  00370	eb 07		 jmp	 SHORT $LN24@DIEnumJoys
$LN23@DIEnumJoys:

; 2160 : 	else JoyInfo2.Ry = TRUE;

  00372	c6 05 04 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+4, 1
$LN24@DIEnumJoys:

; 2161 : 
; 2162 : 	diprg.diph.dwObj = DIJOFS_RZ;   // set the z-rudder range

  00379	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 20 ; 00000014H

; 2163 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00380	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00383	50		 push	 eax
  00384	6a 04		 push	 4
  00386	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00389	51		 push	 ecx
  0038a	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0038d	8b 02		 mov	 eax, DWORD PTR [edx]
  0038f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00392	ff d1		 call	 ecx
  00394	85 c0		 test	 eax, eax
  00396	7d 09		 jge	 SHORT $LN25@DIEnumJoys

; 2164 : 	{
; 2165 : 		//CONS_Printf("DIJOFS_RZ (z-rudder) not found\n");
; 2166 : 		JoyInfo2.Rz = FALSE;

  00398	c6 05 05 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+5, 0

; 2167 : 	}

  0039f	eb 07		 jmp	 SHORT $LN26@DIEnumJoys
$LN25@DIEnumJoys:

; 2168 : 	else JoyInfo2.Rz = TRUE;

  003a1	c6 05 05 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+5, 1
$LN26@DIEnumJoys:

; 2169 : 	diprg.diph.dwObj = DIJOFS_SLIDER(0);   // set the x-misc range

  003a8	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 24 ; 00000018H

; 2170 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  003af	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  003b2	50		 push	 eax
  003b3	6a 04		 push	 4
  003b5	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  003b8	51		 push	 ecx
  003b9	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  003bc	8b 02		 mov	 eax, DWORD PTR [edx]
  003be	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003c1	ff d1		 call	 ecx
  003c3	85 c0		 test	 eax, eax
  003c5	7d 09		 jge	 SHORT $LN27@DIEnumJoys

; 2171 : 	{
; 2172 : 		//CONS_Printf("DIJOFS_RZ (x-misc) not found\n");
; 2173 : 		JoyInfo2.U = FALSE;

  003c7	c6 05 06 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+6, 0

; 2174 : 	}

  003ce	eb 07		 jmp	 SHORT $LN28@DIEnumJoys
$LN27@DIEnumJoys:

; 2175 : 	else JoyInfo2.U = TRUE;

  003d0	c6 05 06 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+6, 1
$LN28@DIEnumJoys:

; 2176 : 
; 2177 : 	diprg.diph.dwObj = DIJOFS_SLIDER(1);   // set the y-misc range

  003d7	c7 45 e8 1c 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 28 ; 0000001cH

; 2178 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  003de	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  003e1	50		 push	 eax
  003e2	6a 04		 push	 4
  003e4	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  003e7	51		 push	 ecx
  003e8	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  003eb	8b 02		 mov	 eax, DWORD PTR [edx]
  003ed	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003f0	ff d1		 call	 ecx
  003f2	85 c0		 test	 eax, eax
  003f4	7d 09		 jge	 SHORT $LN29@DIEnumJoys

; 2179 : 	{
; 2180 : 		//CONS_Printf("DIJOFS_RZ (y-misc) not found\n");
; 2181 : 		JoyInfo2.V = FALSE;

  003f6	c6 05 07 00 00
	00 00		 mov	 BYTE PTR _JoyInfo2+7, 0

; 2182 : 	}

  003fd	eb 07		 jmp	 SHORT $LN30@DIEnumJoys
$LN29@DIEnumJoys:

; 2183 : 	else JoyInfo2.V = TRUE;

  003ff	c6 05 07 00 00
	00 01		 mov	 BYTE PTR _JoyInfo2+7, 1
$LN30@DIEnumJoys:

; 2184 : 
; 2185 : 	// set X axis dead zone to 25% (to avoid accidental turning)
; 2186 : 	if (!Joystick2.bGamepadStyle)

  00406	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick2+4, 0
  0040d	0f 85 80 01 00
	00		 jne	 $LN47@DIEnumJoys

; 2187 : 	{
; 2188 : 		if (JoyInfo2.X)

  00413	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2
  0041a	85 c0		 test	 eax, eax
  0041c	74 25		 je	 SHORT $LN33@DIEnumJoys

; 2189 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_X,

  0041e	6a 00		 push	 0
  00420	6a 01		 push	 1
  00422	6a 00		 push	 0
  00424	6a 05		 push	 5
  00426	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0042f	83 c4 14	 add	 esp, 20			; 00000014H
  00432	85 c0		 test	 eax, eax
  00434	7d 0d		 jge	 SHORT $LN33@DIEnumJoys

; 2190 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2191 : 			{
; 2192 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for X DEAD ZONE");

  00436	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@JCKOGIDG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  0043b	e8 00 00 00 00	 call	 _CONS_Printf
  00440	83 c4 04	 add	 esp, 4
$LN33@DIEnumJoys:

; 2193 : 				//IDirectInputDevice_Release (pdev);
; 2194 : 				//return DIENUM_CONTINUE;
; 2195 : 			}
; 2196 : 		if (JoyInfo2.Y)

  00443	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+1
  0044a	85 c0		 test	 eax, eax
  0044c	74 25		 je	 SHORT $LN35@DIEnumJoys

; 2197 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_Y,

  0044e	6a 00		 push	 0
  00450	6a 01		 push	 1
  00452	6a 04		 push	 4
  00454	6a 05		 push	 5
  00456	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0045f	83 c4 14	 add	 esp, 20			; 00000014H
  00462	85 c0		 test	 eax, eax
  00464	7d 0d		 jge	 SHORT $LN35@DIEnumJoys

; 2198 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2199 : 			{
; 2200 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for Y DEAD ZONE\n");

  00466	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@OIFBAKPO@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  0046b	e8 00 00 00 00	 call	 _CONS_Printf
  00470	83 c4 04	 add	 esp, 4
$LN35@DIEnumJoys:

; 2201 : 				//IDirectInputDevice_Release (pdev);
; 2202 : 				//return DIENUM_CONTINUE;
; 2203 : 			}
; 2204 : 		if (JoyInfo2.Z)

  00473	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+2
  0047a	85 c0		 test	 eax, eax
  0047c	74 25		 je	 SHORT $LN37@DIEnumJoys

; 2205 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_Z,

  0047e	6a 00		 push	 0
  00480	6a 01		 push	 1
  00482	6a 08		 push	 8
  00484	6a 05		 push	 5
  00486	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00489	50		 push	 eax
  0048a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0048f	83 c4 14	 add	 esp, 20			; 00000014H
  00492	85 c0		 test	 eax, eax
  00494	7d 0d		 jge	 SHORT $LN37@DIEnumJoys

; 2206 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2207 : 			{
; 2208 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for Z DEAD ZONE\n");

  00496	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@FFJLGGDA@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  0049b	e8 00 00 00 00	 call	 _CONS_Printf
  004a0	83 c4 04	 add	 esp, 4
$LN37@DIEnumJoys:

; 2209 : 				//IDirectInputDevice_Release (pdev);
; 2210 : 				//return DIENUM_CONTINUE;
; 2211 : 			}
; 2212 : 		if (JoyInfo2.Rx)

  004a3	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+3
  004aa	85 c0		 test	 eax, eax
  004ac	74 25		 je	 SHORT $LN39@DIEnumJoys

; 2213 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_RX,

  004ae	6a 00		 push	 0
  004b0	6a 01		 push	 1
  004b2	6a 0c		 push	 12			; 0000000cH
  004b4	6a 05		 push	 5
  004b6	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  004b9	50		 push	 eax
  004ba	e8 00 00 00 00	 call	 _SetDIDwordProperty
  004bf	83 c4 14	 add	 esp, 20			; 00000014H
  004c2	85 c0		 test	 eax, eax
  004c4	7d 0d		 jge	 SHORT $LN39@DIEnumJoys

; 2214 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2215 : 			{
; 2216 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for RX DEAD ZONE\n");

  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HIGOEJFN@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  004cb	e8 00 00 00 00	 call	 _CONS_Printf
  004d0	83 c4 04	 add	 esp, 4
$LN39@DIEnumJoys:

; 2217 : 				//IDirectInputDevice_Release (pdev);
; 2218 : 				//return DIENUM_CONTINUE;
; 2219 : 			}
; 2220 : 		if (JoyInfo2.Ry)

  004d3	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+4
  004da	85 c0		 test	 eax, eax
  004dc	74 25		 je	 SHORT $LN41@DIEnumJoys

; 2221 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_RY,

  004de	6a 00		 push	 0
  004e0	6a 01		 push	 1
  004e2	6a 10		 push	 16			; 00000010H
  004e4	6a 05		 push	 5
  004e6	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  004e9	50		 push	 eax
  004ea	e8 00 00 00 00	 call	 _SetDIDwordProperty
  004ef	83 c4 14	 add	 esp, 20			; 00000014H
  004f2	85 c0		 test	 eax, eax
  004f4	7d 0d		 jge	 SHORT $LN41@DIEnumJoys

; 2222 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2223 : 			{
; 2224 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for RY DEAD ZONE\n");

  004f6	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@KFPIJANI@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  004fb	e8 00 00 00 00	 call	 _CONS_Printf
  00500	83 c4 04	 add	 esp, 4
$LN41@DIEnumJoys:

; 2225 : 				//IDirectInputDevice_Release (pdev);
; 2226 : 				//return DIENUM_CONTINUE;
; 2227 : 			}
; 2228 : 		if (JoyInfo2.Rz)

  00503	0f b6 05 05 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+5
  0050a	85 c0		 test	 eax, eax
  0050c	74 25		 je	 SHORT $LN43@DIEnumJoys

; 2229 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_RZ,

  0050e	6a 00		 push	 0
  00510	6a 01		 push	 1
  00512	6a 14		 push	 20			; 00000014H
  00514	6a 05		 push	 5
  00516	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00519	50		 push	 eax
  0051a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0051f	83 c4 14	 add	 esp, 20			; 00000014H
  00522	85 c0		 test	 eax, eax
  00524	7d 0d		 jge	 SHORT $LN43@DIEnumJoys

; 2230 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2231 : 			{
; 2232 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for RZ DEAD ZONE\n");

  00526	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@BIDCPMBG@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  0052b	e8 00 00 00 00	 call	 _CONS_Printf
  00530	83 c4 04	 add	 esp, 4
$LN43@DIEnumJoys:

; 2233 : 				//IDirectInputDevice_Release (pdev);
; 2234 : 				//return DIENUM_CONTINUE;
; 2235 : 			}
; 2236 : 		if (JoyInfo2.U)

  00533	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+6
  0053a	85 c0		 test	 eax, eax
  0053c	74 25		 je	 SHORT $LN45@DIEnumJoys

; 2237 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_SLIDER(0),

  0053e	6a 00		 push	 0
  00540	6a 01		 push	 1
  00542	6a 18		 push	 24			; 00000018H
  00544	6a 05		 push	 5
  00546	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00549	50		 push	 eax
  0054a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0054f	83 c4 14	 add	 esp, 20			; 00000014H
  00552	85 c0		 test	 eax, eax
  00554	7d 0d		 jge	 SHORT $LN45@DIEnumJoys

; 2238 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2239 : 			{
; 2240 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for U DEAD ZONE\n");

  00556	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HCOLLDAF@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  0055b	e8 00 00 00 00	 call	 _CONS_Printf
  00560	83 c4 04	 add	 esp, 4
$LN45@DIEnumJoys:

; 2241 : 				//IDirectInputDevice_Release (pdev);
; 2242 : 				//return DIENUM_CONTINUE;
; 2243 : 			}
; 2244 : 		if (JoyInfo2.V)

  00563	0f b6 05 07 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+7
  0056a	85 c0		 test	 eax, eax
  0056c	74 25		 je	 SHORT $LN47@DIEnumJoys

; 2245 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_SLIDER(1),

  0056e	6a 00		 push	 0
  00570	6a 01		 push	 1
  00572	6a 1c		 push	 28			; 0000001cH
  00574	6a 05		 push	 5
  00576	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00579	50		 push	 eax
  0057a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0057f	83 c4 14	 add	 esp, 20			; 00000014H
  00582	85 c0		 test	 eax, eax
  00584	7d 0d		 jge	 SHORT $LN47@DIEnumJoys

; 2246 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 2247 : 			{
; 2248 : 				CONS_Printf("DIEnumJoysticks2(): couldn't SetProperty for V DEAD ZONE\n");

  00586	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@MPCBNPML@DIEnumJoysticks2?$CI?$CJ?3?5couldn?8t?5Se@
  0058b	e8 00 00 00 00	 call	 _CONS_Printf
  00590	83 c4 04	 add	 esp, 4
$LN47@DIEnumJoys:

; 2249 : 				//IDirectInputDevice_Release (pdev);
; 2250 : 				//return DIENUM_CONTINUE;
; 2251 : 			}
; 2252 : 	}
; 2253 : 
; 2254 : 	// query for IDirectInputDevice2 - we need this to poll the joystick
; 2255 : 	if (bDX0300)

  00593	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDX0300, 0
  0059a	74 3e		 je	 SHORT $LN48@DIEnumJoys

; 2256 : 	{
; 2257 : 		FFType i = EvilForce;

  0059c	c7 45 ac ff ff
	ff ff		 mov	 DWORD PTR _i$3[ebp], -1

; 2258 : 		// we won't use the poll
; 2259 : 		lpDIJA = NULL;

  005a3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIJA, 0

; 2260 : 		for (i = 0; i > NumberofForces; i++)

  005ad	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  005b4	eb 09		 jmp	 SHORT $LN4@DIEnumJoys
$LN2@DIEnumJoys:
  005b6	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  005b9	83 c0 01	 add	 eax, 1
  005bc	89 45 ac	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@DIEnumJoys:
  005bf	83 7d ac 07	 cmp	 DWORD PTR _i$3[ebp], 7
  005c3	7e 10		 jle	 SHORT $LN3@DIEnumJoys

; 2261 : 			lpDIE[i] = NULL;

  005c5	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  005c8	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _lpDIE[eax*4], 0
  005d3	eb e1		 jmp	 SHORT $LN2@DIEnumJoys
$LN3@DIEnumJoys:

; 2262 : 	}

  005d5	e9 b4 00 00 00	 jmp	 $LN54@DIEnumJoys
$LN48@DIEnumJoys:

; 2263 : 	else
; 2264 : 	{
; 2265 : 		LPDIRECTINPUTDEVICE2A *rp = &lpDIJ2A;

  005da	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _rp$2[ebp], OFFSET _lpDIJ2A

; 2266 : 		LPVOID *tp  = (LPVOID *)rp;

  005e1	8b 45 a8	 mov	 eax, DWORD PTR _rp$2[ebp]
  005e4	89 45 a4	 mov	 DWORD PTR _tp$1[ebp], eax

; 2267 : 		if (FAILED(IDirectInputDevice_QueryInterface(pdev, &IID_IDirectInputDevice2, tp)))

  005e7	8b 45 a4	 mov	 eax, DWORD PTR _tp$1[ebp]
  005ea	50		 push	 eax
  005eb	68 00 00 00 00	 push	 OFFSET _IID_IDirectInputDevice2A
  005f0	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  005f3	51		 push	 ecx
  005f4	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  005f7	8b 02		 mov	 eax, DWORD PTR [edx]
  005f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fb	ff d1		 call	 ecx
  005fd	85 c0		 test	 eax, eax
  005ff	7d 23		 jge	 SHORT $LN50@DIEnumJoys

; 2268 : 		{
; 2269 : 			CONS_Printf("DIEnumJoysticks2(): QueryInterface FAILED\n");

  00601	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MIDIBNKL@DIEnumJoysticks2?$CI?$CJ?3?5QueryInterf@
  00606	e8 00 00 00 00	 call	 _CONS_Printf
  0060b	83 c4 04	 add	 esp, 4

; 2270 : 			IDirectInputDevice_Release (pdev);

  0060e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00611	50		 push	 eax
  00612	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00615	8b 11		 mov	 edx, DWORD PTR [ecx]
  00617	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0061a	ff d0		 call	 eax
  0061c	90		 npad	 1

; 2271 : 			return DIENUM_CONTINUE;

  0061d	b8 01 00 00 00	 mov	 eax, 1
  00622	eb 74		 jmp	 SHORT $LN1@DIEnumJoys
$LN50@DIEnumJoys:

; 2272 : 		}
; 2273 : 
; 2274 : 		if (lpDIJ2A && JoyInfo2.ForceAxises != -1)

  00624	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2A, 0
  0062b	74 61		 je	 SHORT $LN54@DIEnumJoys
  0062d	83 3d 08 00 00
	00 ff		 cmp	 DWORD PTR _JoyInfo2+8, -1
  00634	74 58		 je	 SHORT $LN54@DIEnumJoys

; 2275 : 		{
; 2276 : 			// Since we will be playing force feedback effects, we should disable the
; 2277 : 			// auto-centering spring.
; 2278 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_AUTOCENTER, 0, DIPH_DEVICE, FALSE)))

  00636	6a 00		 push	 0
  00638	6a 00		 push	 0
  0063a	6a 00		 push	 0
  0063c	6a 09		 push	 9
  0063e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00641	50		 push	 eax
  00642	e8 00 00 00 00	 call	 _SetDIDwordProperty
  00647	83 c4 14	 add	 esp, 20			; 00000014H

; 2279 : 			{
; 2280 : 				//NOP
; 2281 : 			}
; 2282 : 
; 2283 : 			// Enumerate and count the axes of the joystick
; 2284 : 			if (FAILED(IDirectInputDevice_EnumObjects(pdev, EnumAxesCallback,

  0064a	6a 03		 push	 3
  0064c	68 08 00 00 00	 push	 OFFSET _JoyInfo2+8
  00651	68 00 00 00 00	 push	 OFFSET _EnumAxesCallback@8
  00656	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00659	50		 push	 eax
  0065a	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0065d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0065f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00662	ff d0		 call	 eax
  00664	85 c0		 test	 eax, eax
  00666	7d 0c		 jge	 SHORT $LN53@DIEnumJoys

; 2285 : 				(LPVOID)&JoyInfo2.ForceAxises, DIDFT_AXIS)))
; 2286 : 			{
; 2287 : 				JoyInfo2.ForceAxises = -1;

  00668	c7 05 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _JoyInfo2+8, -1

; 2288 : 			}

  00672	eb 1a		 jmp	 SHORT $LN54@DIEnumJoys
$LN53@DIEnumJoys:

; 2289 : 			else
; 2290 : 			{
; 2291 : 				SetupAllForces(lpDIJ2A,lpDIE2,JoyInfo2.ForceAxises);

  00674	a1 08 00 00 00	 mov	 eax, DWORD PTR _JoyInfo2+8
  00679	50		 push	 eax
  0067a	68 00 00 00 00	 push	 OFFSET _lpDIE2
  0067f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2A
  00685	51		 push	 ecx
  00686	e8 00 00 00 00	 call	 _SetupAllForces
  0068b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@DIEnumJoys:

; 2292 : 			}
; 2293 : 		}
; 2294 : 	}
; 2295 : 
; 2296 : 	// we successfully created an IDirectInputDevice.  So stop looking
; 2297 : 	// for another one.
; 2298 : 	lpDIJ2 = pdev;

  0068e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00691	a3 00 00 00 00	 mov	 DWORD PTR _lpDIJ2, eax

; 2299 : 	return DIENUM_STOP;

  00696	33 c0		 xor	 eax, eax
$LN1@DIEnumJoys:

; 2300 : }

  00698	5f		 pop	 edi
  00699	5e		 pop	 esi
  0069a	5b		 pop	 ebx
  0069b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0069e	33 cd		 xor	 ecx, ebp
  006a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a5	8b e5		 mov	 esp, ebp
  006a7	5d		 pop	 ebp
  006a8	c2 08 00	 ret	 8
_DIEnumJoysticks2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _DIEnumJoysticks@8
_TEXT	SEGMENT
tv79 = -160						; size = 4
tv141 = -160						; size = 4
tv149 = -160						; size = 4
_tp$1 = -92						; size = 4
_rp$2 = -88						; size = 4
_i$3 = -84						; size = 4
_bUseThisOne$ = -80					; size = 4
_caps$ = -76						; size = 44
_diprg$ = -32						; size = 24
_pdev$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpddi$ = 8						; size = 4
_pvRef$ = 12						; size = 4
_DIEnumJoysticks@8 PROC					; COMDAT

; 1660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1661 : 	LPDIRECTINPUTDEVICEA pdev;
; 1662 : 	DIPROPRANGE          diprg;
; 1663 : 	DIDEVCAPS            caps;
; 1664 : 	BOOL                 bUseThisOne = FALSE;

  00016	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _bUseThisOne$[ebp], 0

; 1665 : 
; 1666 : 	iJoyNum++;

  0001d	a0 00 00 00 00	 mov	 al, BYTE PTR _iJoyNum
  00022	04 01		 add	 al, 1
  00024	a2 00 00 00 00	 mov	 BYTE PTR _iJoyNum, al

; 1667 : 
; 1668 : 	//faB: if cv holds a string description of joystick, the value from atoi() is 0
; 1669 : 	//     else, the value was probably set by user at console to one of the previously
; 1670 : 	//     enumerated joysticks
; 1671 : 	if (((consvar_t *)pvRef)->value == iJoyNum || !strcmp(((consvar_t *)pvRef)->string, lpddi->tszProductName))

  00029	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoyNum
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  00033	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  00036	74 1c		 je	 SHORT $LN6@DIEnumJoys
  00038	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  0003b	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00040	50		 push	 eax
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  00044	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _strcmp
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	75 07		 jne	 SHORT $LN5@DIEnumJoys
$LN6@DIEnumJoys:

; 1672 : 		bUseThisOne = TRUE;

  00054	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _bUseThisOne$[ebp], 1
$LN5@DIEnumJoys:

; 1673 : 
; 1674 : 	//CONS_Printf(" cv joy is %s\n", ((consvar_t *)pvRef)->string);
; 1675 : 
; 1676 : 	// print out device name
; 1677 : 	CONS_Printf("%c%d: %s\n",

  0005b	83 7d b0 00	 cmp	 DWORD PTR _bUseThisOne$[ebp], 0
  0005f	74 0c		 je	 SHORT $LN56@DIEnumJoys
  00061	c7 85 60 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR tv79[ebp], 2
  0006b	eb 0a		 jmp	 SHORT $LN57@DIEnumJoys
$LN56@DIEnumJoys:
  0006d	c7 85 60 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR tv79[ebp], 32	; 00000020H
$LN57@DIEnumJoys:
  00077	8b 45 08	 mov	 eax, DWORD PTR _lpddi$[ebp]
  0007a	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0007f	50		 push	 eax
  00080	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _iJoyNum
  00087	51		 push	 ecx
  00088	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  0008e	52		 push	 edx
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_09EBBEIMPI@?$CFc?$CFd?3?5?$CFs?6@
  00094	e8 00 00 00 00	 call	 _CONS_Printf
  00099	83 c4 10	 add	 esp, 16			; 00000010H

; 1678 : 	            (bUseThisOne) ? '\2' : ' ',   // show name in white if this is the one we will use
; 1679 : 	            iJoyNum,
; 1680 : 	            //(GET_DIDEVICE_SUBTYPE(lpddi->dwDevType) == DIDEVTYPEJOYSTICK_GAMEPAD) ? "Gamepad " : "Joystick",
; 1681 : 	            lpddi->tszProductName); //, lpddi->tszInstanceName);
; 1682 : 
; 1683 : 	// use specified joystick (cv_usejoystick.value in pvRef)
; 1684 : 	if (!bUseThisOne)

  0009c	83 7d b0 00	 cmp	 DWORD PTR _bUseThisOne$[ebp], 0
  000a0	75 0a		 jne	 SHORT $LN7@DIEnumJoys

; 1685 : 		return DIENUM_CONTINUE;

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	e9 ec 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN7@DIEnumJoys:

; 1686 : 
; 1687 : 	((consvar_t *)pvRef)->value = iJoyNum;

  000ac	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoyNum
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _pvRef$[ebp]
  000b6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1688 : 	if (IDirectInput_CreateDevice(lpDI, &lpddi->guidInstance,
; 1689 : 	                              &pdev, NULL) != DI_OK)

  000b9	6a 00		 push	 0
  000bb	8d 45 f8	 lea	 eax, DWORD PTR _pdev$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _lpddi$[ebp]
  000c2	83 c1 04	 add	 ecx, 4
  000c5	51		 push	 ecx
  000c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDI
  000cc	52		 push	 edx
  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  000d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000d7	ff d2		 call	 edx
  000d9	85 c0		 test	 eax, eax
  000db	74 17		 je	 SHORT $LN8@DIEnumJoys

; 1690 : 	{
; 1691 : 		// if it failed, then we can't use this joystick for some
; 1692 : 		// bizarre reason.  (Maybe the user unplugged it while we
; 1693 : 		// were in the middle of enumerating it.)  So continue enumerating
; 1694 : 		CONS_Printf("DIEnumJoysticks(): CreateDevice FAILED\n");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@BOBKDHHM@DIEnumJoysticks?$CI?$CJ?3?5CreateDevice@
  000e2	e8 00 00 00 00	 call	 _CONS_Printf
  000e7	83 c4 04	 add	 esp, 4

; 1695 : 		return DIENUM_CONTINUE;

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	e9 a4 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN8@DIEnumJoys:

; 1696 : 	}
; 1697 : 
; 1698 : 	// get the Device capabilities
; 1699 : 	//
; 1700 : 	caps.dwSize = sizeof (DIDEVCAPS_DX3);

  000f4	c7 45 b4 18 00
	00 00		 mov	 DWORD PTR _caps$[ebp], 24 ; 00000018H

; 1701 : 	if (FAILED(IDirectInputDevice_GetCapabilities (pdev, &caps)))

  000fb	8d 45 b4	 lea	 eax, DWORD PTR _caps$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  00106	8b 02		 mov	 eax, DWORD PTR [edx]
  00108	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0010b	ff d1		 call	 ecx
  0010d	85 c0		 test	 eax, eax
  0010f	7d 26		 jge	 SHORT $LN9@DIEnumJoys

; 1702 : 	{
; 1703 : 		CONS_Printf("DIEnumJoysticks(): GetCapabilities FAILED\n");

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HNLAIKDI@DIEnumJoysticks?$CI?$CJ?3?5GetCapabilit@
  00116	e8 00 00 00 00	 call	 _CONS_Printf
  0011b	83 c4 04	 add	 esp, 4

; 1704 : 		IDirectInputDevice_Release (pdev);

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00121	50		 push	 eax
  00122	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00125	8b 11		 mov	 edx, DWORD PTR [ecx]
  00127	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0012a	ff d0		 call	 eax
  0012c	90		 npad	 1

; 1705 : 		return DIENUM_CONTINUE;

  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	e9 61 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN9@DIEnumJoys:

; 1706 : 	}
; 1707 : 	if (!(caps.dwFlags & DIDC_ATTACHED))   // should be, since we enumerate only attached devices

  00137	8b 45 b8	 mov	 eax, DWORD PTR _caps$[ebp+4]
  0013a	83 e0 01	 and	 eax, 1
  0013d	75 0a		 jne	 SHORT $LN10@DIEnumJoys

; 1708 : 		return DIENUM_CONTINUE;

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	e9 4f 05 00 00	 jmp	 $LN1@DIEnumJoys
$LN10@DIEnumJoys:

; 1709 : 
; 1710 : 	Joystick.bJoyNeedPoll = ((caps.dwFlags & DIDC_POLLEDDATAFORMAT) != 0);

  00149	8b 45 b8	 mov	 eax, DWORD PTR _caps$[ebp+4]
  0014c	83 e0 08	 and	 eax, 8
  0014f	74 0c		 je	 SHORT $LN58@DIEnumJoys
  00151	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv141[ebp], 1
  0015b	eb 0a		 jmp	 SHORT $LN59@DIEnumJoys
$LN58@DIEnumJoys:
  0015d	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
$LN59@DIEnumJoys:
  00167	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv141[ebp]
  0016d	89 0d 00 00 00
	00		 mov	 DWORD PTR _Joystick, ecx

; 1711 : 
; 1712 : 	if (caps.dwFlags & DIDC_FORCEFEEDBACK)

  00173	8b 45 b8	 mov	 eax, DWORD PTR _caps$[ebp+4]
  00176	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0017b	74 0c		 je	 SHORT $LN11@DIEnumJoys

; 1713 : 		JoyInfo.ForceAxises = 0;

  0017d	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _JoyInfo+8, 0
  00187	eb 0a		 jmp	 SHORT $LN12@DIEnumJoys
$LN11@DIEnumJoys:

; 1714 : 	else
; 1715 : 		JoyInfo.ForceAxises = -1;

  00189	c7 05 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _JoyInfo+8, -1
$LN12@DIEnumJoys:

; 1716 : 
; 1717 : 	Joystick.bGamepadStyle = (GET_DIDEVICE_SUBTYPE(caps.dwDevType) == DIDEVTYPEJOYSTICK_GAMEPAD);

  00193	8b 45 bc	 mov	 eax, DWORD PTR _caps$[ebp+8]
  00196	c1 e8 08	 shr	 eax, 8
  00199	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019e	0f b6 c8	 movzx	 ecx, al
  001a1	83 f9 04	 cmp	 ecx, 4
  001a4	75 0c		 jne	 SHORT $LN60@DIEnumJoys
  001a6	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv149[ebp], 1
  001b0	eb 0a		 jmp	 SHORT $LN61@DIEnumJoys
$LN60@DIEnumJoys:
  001b2	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
$LN61@DIEnumJoys:
  001bc	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv149[ebp]
  001c2	89 15 04 00 00
	00		 mov	 DWORD PTR _Joystick+4, edx

; 1718 : 	//DEBUG CONS_Printf("Gamepad: %d\n", Joystick.bGamepadStyle);
; 1719 : 
; 1720 : 
; 1721 : 	CONS_Printf("Capabilities: %lu axes, %lu buttons, %lu POVs, poll %u, Gamepad %d\n",

  001c8	a1 04 00 00 00	 mov	 eax, DWORD PTR _Joystick+4
  001cd	50		 push	 eax
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Joystick
  001d4	51		 push	 ecx
  001d5	8b 55 c8	 mov	 edx, DWORD PTR _caps$[ebp+20]
  001d8	52		 push	 edx
  001d9	8b 45 c4	 mov	 eax, DWORD PTR _caps$[ebp+16]
  001dc	50		 push	 eax
  001dd	8b 4d c0	 mov	 ecx, DWORD PTR _caps$[ebp+12]
  001e0	51		 push	 ecx
  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@IFFBDPHG@Capabilities?3?5?$CFlu?5axes?0?5?$CFlu?5but@
  001e6	e8 00 00 00 00	 call	 _CONS_Printf
  001eb	83 c4 18	 add	 esp, 24			; 00000018H

; 1722 : 	            caps.dwAxes, caps.dwButtons, caps.dwPOVs, Joystick.bJoyNeedPoll, Joystick.bGamepadStyle);
; 1723 : 
; 1724 : 	// Set the data format to "simple joystick" - a predefined data format
; 1725 : 	//
; 1726 : 	// A data format specifies which controls on a device we
; 1727 : 	// are interested in, and how they should be reported.
; 1728 : 	//
; 1729 : 	// This tells DirectInput that we will be passing a
; 1730 : 	// DIJOYSTATE structure to IDirectInputDevice::GetDeviceState.
; 1731 : 	if (IDirectInputDevice_SetDataFormat (pdev, &c_dfDIJoystick) != DI_OK)

  001ee	68 00 00 00 00	 push	 OFFSET _c_dfDIJoystick
  001f3	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  001f6	50		 push	 eax
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  001fa	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fc	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  001ff	ff d0		 call	 eax
  00201	85 c0		 test	 eax, eax
  00203	74 26		 je	 SHORT $LN13@DIEnumJoys

; 1732 : 	{
; 1733 : 		CONS_Printf("DIEnumJoysticks(): SetDataFormat FAILED\n");

  00205	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OAGCDABJ@DIEnumJoysticks?$CI?$CJ?3?5SetDataForma@
  0020a	e8 00 00 00 00	 call	 _CONS_Printf
  0020f	83 c4 04	 add	 esp, 4

; 1734 : 		IDirectInputDevice_Release (pdev);

  00212	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00215	50		 push	 eax
  00216	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00219	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0021e	ff d0		 call	 eax
  00220	90		 npad	 1

; 1735 : 		return DIENUM_CONTINUE;

  00221	b8 01 00 00 00	 mov	 eax, 1
  00226	e9 6d 04 00 00	 jmp	 $LN1@DIEnumJoys
$LN13@DIEnumJoys:

; 1736 : 	}
; 1737 : 
; 1738 : 	// Set the cooperativity level to let DirectInput know how
; 1739 : 	// this device should interact with the system and with other
; 1740 : 	// DirectInput applications.
; 1741 : 	if (IDirectInputDevice_SetCooperativeLevel (pdev, hWndMain,
; 1742 : 	 DISCL_EXCLUSIVE | DISCL_FOREGROUND) != DI_OK)

  0022b	6a 05		 push	 5
  0022d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00232	50		 push	 eax
  00233	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00236	51		 push	 ecx
  00237	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0023a	8b 02		 mov	 eax, DWORD PTR [edx]
  0023c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0023f	ff d1		 call	 ecx
  00241	85 c0		 test	 eax, eax
  00243	74 26		 je	 SHORT $LN14@DIEnumJoys

; 1743 : 	{
; 1744 : 		CONS_Printf("DIEnumJoysticks(): SetCooperativeLevel FAILED\n");

  00245	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BMGKCBPE@DIEnumJoysticks?$CI?$CJ?3?5SetCooperati@
  0024a	e8 00 00 00 00	 call	 _CONS_Printf
  0024f	83 c4 04	 add	 esp, 4

; 1745 : 		IDirectInputDevice_Release (pdev);

  00252	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00255	50		 push	 eax
  00256	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00259	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0025e	ff d0		 call	 eax
  00260	90		 npad	 1

; 1746 : 		return DIENUM_CONTINUE;

  00261	b8 01 00 00 00	 mov	 eax, 1
  00266	e9 2d 04 00 00	 jmp	 $LN1@DIEnumJoys
$LN14@DIEnumJoys:

; 1747 : 	}
; 1748 : 
; 1749 : 	// set the range of the joystick axis
; 1750 : 	diprg.diph.dwSize       = sizeof (DIPROPRANGE);

  0026b	c7 45 e0 18 00
	00 00		 mov	 DWORD PTR _diprg$[ebp], 24 ; 00000018H

; 1751 : 	diprg.diph.dwHeaderSize = sizeof (DIPROPHEADER);

  00272	c7 45 e4 10 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+4], 16 ; 00000010H

; 1752 : 	diprg.diph.dwHow        = DIPH_BYOFFSET;

  00279	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+12], 1

; 1753 : 	diprg.lMin              = -JOYAXISRANGE;    // value for extreme left

  00280	c7 45 f0 01 fc
	ff ff		 mov	 DWORD PTR _diprg$[ebp+16], -1023 ; fffffc01H

; 1754 : 	diprg.lMax              = +JOYAXISRANGE;    // value for extreme right

  00287	c7 45 f4 ff 03
	00 00		 mov	 DWORD PTR _diprg$[ebp+20], 1023 ; 000003ffH

; 1755 : 
; 1756 : 	diprg.diph.dwObj = DIJOFS_X;    // set the x-axis range

  0028e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 0

; 1757 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00295	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00298	50		 push	 eax
  00299	6a 04		 push	 4
  0029b	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0029e	51		 push	 ecx
  0029f	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  002a2	8b 02		 mov	 eax, DWORD PTR [edx]
  002a4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002a7	ff d1		 call	 ecx
  002a9	85 c0		 test	 eax, eax
  002ab	7d 09		 jge	 SHORT $LN15@DIEnumJoys

; 1758 : 	{
; 1759 : 		//goto SetPropFail;
; 1760 : 		JoyInfo.X = FALSE;

  002ad	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _JoyInfo, 0

; 1761 : 	}

  002b4	eb 07		 jmp	 SHORT $LN16@DIEnumJoys
$LN15@DIEnumJoys:

; 1762 : 	else JoyInfo.X = TRUE;

  002b6	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _JoyInfo, 1
$LN16@DIEnumJoys:

; 1763 : 
; 1764 : 	diprg.diph.dwObj = DIJOFS_Y;    // set the y-axis range

  002bd	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 4

; 1765 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  002c4	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  002c7	50		 push	 eax
  002c8	6a 04		 push	 4
  002ca	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  002cd	51		 push	 ecx
  002ce	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  002d1	8b 02		 mov	 eax, DWORD PTR [edx]
  002d3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002d6	ff d1		 call	 ecx
  002d8	85 c0		 test	 eax, eax
  002da	7d 09		 jge	 SHORT $LN17@DIEnumJoys

; 1766 : 	{
; 1767 : //SetPropFail:
; 1768 : //		CONS_Printf("DIEnumJoysticks(): SetProperty FAILED\n");
; 1769 : //		IDirectInputDevice_Release (pdev);
; 1770 : //		return DIENUM_CONTINUE;
; 1771 : 		JoyInfo.Y = FALSE;

  002dc	c6 05 01 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+1, 0

; 1772 : 	}

  002e3	eb 07		 jmp	 SHORT $LN18@DIEnumJoys
$LN17@DIEnumJoys:

; 1773 : 	else JoyInfo.Y = TRUE;

  002e5	c6 05 01 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+1, 1
$LN18@DIEnumJoys:

; 1774 : 
; 1775 : 	diprg.diph.dwObj = DIJOFS_Z;    // set the z-axis range

  002ec	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 8

; 1776 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  002f3	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  002f6	50		 push	 eax
  002f7	6a 04		 push	 4
  002f9	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  002fc	51		 push	 ecx
  002fd	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  00300	8b 02		 mov	 eax, DWORD PTR [edx]
  00302	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00305	ff d1		 call	 ecx
  00307	85 c0		 test	 eax, eax
  00309	7d 09		 jge	 SHORT $LN19@DIEnumJoys

; 1777 : 	{
; 1778 : 		//CONS_Printf("DIJOFS_Z not found\n");
; 1779 : 		JoyInfo.Z = FALSE;

  0030b	c6 05 02 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+2, 0

; 1780 : 	}

  00312	eb 07		 jmp	 SHORT $LN20@DIEnumJoys
$LN19@DIEnumJoys:

; 1781 : 	else JoyInfo.Z = TRUE;

  00314	c6 05 02 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+2, 1
$LN20@DIEnumJoys:

; 1782 : 
; 1783 : 	diprg.diph.dwObj = DIJOFS_RX;   // set the x-rudder range

  0031b	c7 45 e8 0c 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 12 ; 0000000cH

; 1784 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00322	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00325	50		 push	 eax
  00326	6a 04		 push	 4
  00328	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0032b	51		 push	 ecx
  0032c	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0032f	8b 02		 mov	 eax, DWORD PTR [edx]
  00331	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00334	ff d1		 call	 ecx
  00336	85 c0		 test	 eax, eax
  00338	7d 09		 jge	 SHORT $LN21@DIEnumJoys

; 1785 : 	{
; 1786 : 		//CONS_Printf("DIJOFS_RX (x-rudder) not found\n");
; 1787 : 		JoyInfo.Rx = FALSE;

  0033a	c6 05 03 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+3, 0

; 1788 : 	}

  00341	eb 07		 jmp	 SHORT $LN22@DIEnumJoys
$LN21@DIEnumJoys:

; 1789 : 	else JoyInfo.Rx = TRUE;

  00343	c6 05 03 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+3, 1
$LN22@DIEnumJoys:

; 1790 : 
; 1791 : 	diprg.diph.dwObj = DIJOFS_RY;   // set the y-rudder range

  0034a	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 16 ; 00000010H

; 1792 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00351	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00354	50		 push	 eax
  00355	6a 04		 push	 4
  00357	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0035a	51		 push	 ecx
  0035b	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0035e	8b 02		 mov	 eax, DWORD PTR [edx]
  00360	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00363	ff d1		 call	 ecx
  00365	85 c0		 test	 eax, eax
  00367	7d 09		 jge	 SHORT $LN23@DIEnumJoys

; 1793 : 	{
; 1794 : 		//CONS_Printf("DIJOFS_RY (y-rudder) not found\n");
; 1795 : 		JoyInfo.Ry = FALSE;

  00369	c6 05 04 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+4, 0

; 1796 : 	}

  00370	eb 07		 jmp	 SHORT $LN24@DIEnumJoys
$LN23@DIEnumJoys:

; 1797 : 	else JoyInfo.Ry = TRUE;

  00372	c6 05 04 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+4, 1
$LN24@DIEnumJoys:

; 1798 : 
; 1799 : 	diprg.diph.dwObj = DIJOFS_RZ;   // set the z-rudder range

  00379	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 20 ; 00000014H

; 1800 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  00380	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  00383	50		 push	 eax
  00384	6a 04		 push	 4
  00386	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00389	51		 push	 ecx
  0038a	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  0038d	8b 02		 mov	 eax, DWORD PTR [edx]
  0038f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00392	ff d1		 call	 ecx
  00394	85 c0		 test	 eax, eax
  00396	7d 09		 jge	 SHORT $LN25@DIEnumJoys

; 1801 : 	{
; 1802 : 		//CONS_Printf("DIJOFS_RZ (z-rudder) not found\n");
; 1803 : 		JoyInfo.Rz = FALSE;

  00398	c6 05 05 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+5, 0

; 1804 : 	}

  0039f	eb 07		 jmp	 SHORT $LN26@DIEnumJoys
$LN25@DIEnumJoys:

; 1805 : 	else JoyInfo.Rz = TRUE;

  003a1	c6 05 05 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+5, 1
$LN26@DIEnumJoys:

; 1806 : 	diprg.diph.dwObj = DIJOFS_SLIDER(0);   // set the x-misc range

  003a8	c7 45 e8 18 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 24 ; 00000018H

; 1807 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  003af	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  003b2	50		 push	 eax
  003b3	6a 04		 push	 4
  003b5	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  003b8	51		 push	 ecx
  003b9	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  003bc	8b 02		 mov	 eax, DWORD PTR [edx]
  003be	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003c1	ff d1		 call	 ecx
  003c3	85 c0		 test	 eax, eax
  003c5	7d 09		 jge	 SHORT $LN27@DIEnumJoys

; 1808 : 	{
; 1809 : 		//CONS_Printf("DIJOFS_RZ (x-misc) not found\n");
; 1810 : 		JoyInfo.U = FALSE;

  003c7	c6 05 06 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+6, 0

; 1811 : 	}

  003ce	eb 07		 jmp	 SHORT $LN28@DIEnumJoys
$LN27@DIEnumJoys:

; 1812 : 	else JoyInfo.U = TRUE;

  003d0	c6 05 06 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+6, 1
$LN28@DIEnumJoys:

; 1813 : 
; 1814 : 	diprg.diph.dwObj = DIJOFS_SLIDER(1);   // set the y-misc range

  003d7	c7 45 e8 1c 00
	00 00		 mov	 DWORD PTR _diprg$[ebp+8], 28 ; 0000001cH

; 1815 : 	if (FAILED(IDirectInputDevice_SetProperty(pdev, DIPROP_RANGE, &diprg.diph)))

  003de	8d 45 e0	 lea	 eax, DWORD PTR _diprg$[ebp]
  003e1	50		 push	 eax
  003e2	6a 04		 push	 4
  003e4	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  003e7	51		 push	 ecx
  003e8	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  003eb	8b 02		 mov	 eax, DWORD PTR [edx]
  003ed	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003f0	ff d1		 call	 ecx
  003f2	85 c0		 test	 eax, eax
  003f4	7d 09		 jge	 SHORT $LN29@DIEnumJoys

; 1816 : 	{
; 1817 : 		//CONS_Printf("DIJOFS_RZ (y-misc) not found\n");
; 1818 : 		JoyInfo.V = FALSE;

  003f6	c6 05 07 00 00
	00 00		 mov	 BYTE PTR _JoyInfo+7, 0

; 1819 : 	}

  003fd	eb 07		 jmp	 SHORT $LN30@DIEnumJoys
$LN29@DIEnumJoys:

; 1820 : 	else JoyInfo.V = TRUE;

  003ff	c6 05 07 00 00
	00 01		 mov	 BYTE PTR _JoyInfo+7, 1
$LN30@DIEnumJoys:

; 1821 : 
; 1822 : 	// set X axis dead zone to 25% (to avoid accidental turning)
; 1823 : 	if (!Joystick.bGamepadStyle)

  00406	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick+4, 0
  0040d	0f 85 80 01 00
	00		 jne	 $LN47@DIEnumJoys

; 1824 : 	{
; 1825 : 		if (JoyInfo.X)

  00413	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo
  0041a	85 c0		 test	 eax, eax
  0041c	74 25		 je	 SHORT $LN33@DIEnumJoys

; 1826 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_X,

  0041e	6a 00		 push	 0
  00420	6a 01		 push	 1
  00422	6a 00		 push	 0
  00424	6a 05		 push	 5
  00426	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0042f	83 c4 14	 add	 esp, 20			; 00000014H
  00432	85 c0		 test	 eax, eax
  00434	7d 0d		 jge	 SHORT $LN33@DIEnumJoys

; 1827 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1828 : 			{
; 1829 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for X DEAD ZONE");

  00436	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@IGHPGEBO@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  0043b	e8 00 00 00 00	 call	 _CONS_Printf
  00440	83 c4 04	 add	 esp, 4
$LN33@DIEnumJoys:

; 1830 : 				//IDirectInputDevice_Release (pdev);
; 1831 : 				//return DIENUM_CONTINUE;
; 1832 : 			}
; 1833 : 		if (JoyInfo.Y)

  00443	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+1
  0044a	85 c0		 test	 eax, eax
  0044c	74 25		 je	 SHORT $LN35@DIEnumJoys

; 1834 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_Y,

  0044e	6a 00		 push	 0
  00450	6a 01		 push	 1
  00452	6a 04		 push	 4
  00454	6a 05		 push	 5
  00456	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0045f	83 c4 14	 add	 esp, 20			; 00000014H
  00462	85 c0		 test	 eax, eax
  00464	7d 0d		 jge	 SHORT $LN35@DIEnumJoys

; 1835 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1836 : 			{
; 1837 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for Y DEAD ZONE\n");

  00466	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@NNPAHDAI@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  0046b	e8 00 00 00 00	 call	 _CONS_Printf
  00470	83 c4 04	 add	 esp, 4
$LN35@DIEnumJoys:

; 1838 : 				//IDirectInputDevice_Release (pdev);
; 1839 : 				//return DIENUM_CONTINUE;
; 1840 : 			}
; 1841 : 		if (JoyInfo.Z)

  00473	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+2
  0047a	85 c0		 test	 eax, eax
  0047c	74 25		 je	 SHORT $LN37@DIEnumJoys

; 1842 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_Z,

  0047e	6a 00		 push	 0
  00480	6a 01		 push	 1
  00482	6a 08		 push	 8
  00484	6a 05		 push	 5
  00486	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00489	50		 push	 eax
  0048a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0048f	83 c4 14	 add	 esp, 20			; 00000014H
  00492	85 c0		 test	 eax, eax
  00494	7d 0d		 jge	 SHORT $LN37@DIEnumJoys

; 1843 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1844 : 			{
; 1845 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for Z DEAD ZONE\n");

  00496	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@GADKBPMG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  0049b	e8 00 00 00 00	 call	 _CONS_Printf
  004a0	83 c4 04	 add	 esp, 4
$LN37@DIEnumJoys:

; 1846 : 				//IDirectInputDevice_Release (pdev);
; 1847 : 				//return DIENUM_CONTINUE;
; 1848 : 			}
; 1849 : 		if (JoyInfo.Rx)

  004a3	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+3
  004aa	85 c0		 test	 eax, eax
  004ac	74 25		 je	 SHORT $LN39@DIEnumJoys

; 1850 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_RX,

  004ae	6a 00		 push	 0
  004b0	6a 01		 push	 1
  004b2	6a 0c		 push	 12			; 0000000cH
  004b4	6a 05		 push	 5
  004b6	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  004b9	50		 push	 eax
  004ba	e8 00 00 00 00	 call	 _SetDIDwordProperty
  004bf	83 c4 14	 add	 esp, 20			; 00000014H
  004c2	85 c0		 test	 eax, eax
  004c4	7d 0d		 jge	 SHORT $LN39@DIEnumJoys

; 1851 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1852 : 			{
; 1853 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for RX DEAD ZONE\n");

  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@CMIFLPAN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  004cb	e8 00 00 00 00	 call	 _CONS_Printf
  004d0	83 c4 04	 add	 esp, 4
$LN39@DIEnumJoys:

; 1854 : 				//IDirectInputDevice_Release (pdev);
; 1855 : 				//return DIENUM_CONTINUE;
; 1856 : 			}
; 1857 : 		if (JoyInfo.Ry)

  004d3	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+4
  004da	85 c0		 test	 eax, eax
  004dc	74 25		 je	 SHORT $LN41@DIEnumJoys

; 1858 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_RY,

  004de	6a 00		 push	 0
  004e0	6a 01		 push	 1
  004e2	6a 10		 push	 16			; 00000010H
  004e4	6a 05		 push	 5
  004e6	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  004e9	50		 push	 eax
  004ea	e8 00 00 00 00	 call	 _SetDIDwordProperty
  004ef	83 c4 14	 add	 esp, 20			; 00000014H
  004f2	85 c0		 test	 eax, eax
  004f4	7d 0d		 jge	 SHORT $LN41@DIEnumJoys

; 1859 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1860 : 			{
; 1861 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for RY DEAD ZONE\n");

  004f6	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@PBBDGGII@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  004fb	e8 00 00 00 00	 call	 _CONS_Printf
  00500	83 c4 04	 add	 esp, 4
$LN41@DIEnumJoys:

; 1862 : 				//IDirectInputDevice_Release (pdev);
; 1863 : 				//return DIENUM_CONTINUE;
; 1864 : 			}
; 1865 : 		if (JoyInfo.Rz)

  00503	0f b6 05 05 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+5
  0050a	85 c0		 test	 eax, eax
  0050c	74 25		 je	 SHORT $LN43@DIEnumJoys

; 1866 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_RZ,

  0050e	6a 00		 push	 0
  00510	6a 01		 push	 1
  00512	6a 14		 push	 20			; 00000014H
  00514	6a 05		 push	 5
  00516	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00519	50		 push	 eax
  0051a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0051f	83 c4 14	 add	 esp, 20			; 00000014H
  00522	85 c0		 test	 eax, eax
  00524	7d 0d		 jge	 SHORT $LN43@DIEnumJoys

; 1867 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1868 : 			{
; 1869 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for RZ DEAD ZONE\n");

  00526	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EMNJAKEG@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  0052b	e8 00 00 00 00	 call	 _CONS_Printf
  00530	83 c4 04	 add	 esp, 4
$LN43@DIEnumJoys:

; 1870 : 				//IDirectInputDevice_Release (pdev);
; 1871 : 				//return DIENUM_CONTINUE;
; 1872 : 			}
; 1873 : 		if (JoyInfo.U)

  00533	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+6
  0053a	85 c0		 test	 eax, eax
  0053c	74 25		 je	 SHORT $LN45@DIEnumJoys

; 1874 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_SLIDER(0),

  0053e	6a 00		 push	 0
  00540	6a 01		 push	 1
  00542	6a 18		 push	 24			; 00000018H
  00544	6a 05		 push	 5
  00546	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00549	50		 push	 eax
  0054a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0054f	83 c4 14	 add	 esp, 20			; 00000014H
  00552	85 c0		 test	 eax, eax
  00554	7d 0d		 jge	 SHORT $LN45@DIEnumJoys

; 1875 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1876 : 			{
; 1877 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for U DEAD ZONE\n");

  00556	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@EHEKMKPD@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  0055b	e8 00 00 00 00	 call	 _CONS_Printf
  00560	83 c4 04	 add	 esp, 4
$LN45@DIEnumJoys:

; 1878 : 				//IDirectInputDevice_Release (pdev);
; 1879 : 				//return DIENUM_CONTINUE;
; 1880 : 			}
; 1881 : 		if (JoyInfo.V)

  00563	0f b6 05 07 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+7
  0056a	85 c0		 test	 eax, eax
  0056c	74 25		 je	 SHORT $LN47@DIEnumJoys

; 1882 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_SLIDER(1),

  0056e	6a 00		 push	 0
  00570	6a 01		 push	 1
  00572	6a 1c		 push	 28			; 0000001cH
  00574	6a 05		 push	 5
  00576	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00579	50		 push	 eax
  0057a	e8 00 00 00 00	 call	 _SetDIDwordProperty
  0057f	83 c4 14	 add	 esp, 20			; 00000014H
  00582	85 c0		 test	 eax, eax
  00584	7d 0d		 jge	 SHORT $LN47@DIEnumJoys

; 1883 : 			                              DIPH_BYOFFSET, DIDEADZONE)))
; 1884 : 			{
; 1885 : 				CONS_Printf("DIEnumJoysticks(): couldn't SetProperty for V DEAD ZONE\n");

  00586	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@PKIAKGDN@DIEnumJoysticks?$CI?$CJ?3?5couldn?8t?5Set@
  0058b	e8 00 00 00 00	 call	 _CONS_Printf
  00590	83 c4 04	 add	 esp, 4
$LN47@DIEnumJoys:

; 1886 : 				//IDirectInputDevice_Release (pdev);
; 1887 : 				//return DIENUM_CONTINUE;
; 1888 : 			}
; 1889 : 	}
; 1890 : 
; 1891 : 	// query for IDirectInputDevice2 - we need this to poll the joystick
; 1892 : 	if (bDX0300)

  00593	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDX0300, 0
  0059a	74 3e		 je	 SHORT $LN48@DIEnumJoys

; 1893 : 	{
; 1894 : 		FFType i = EvilForce;

  0059c	c7 45 ac ff ff
	ff ff		 mov	 DWORD PTR _i$3[ebp], -1

; 1895 : 		// we won't use the poll
; 1896 : 		lpDIJA = NULL;

  005a3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIJA, 0

; 1897 : 		for (i = 0; i > NumberofForces; i++)

  005ad	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  005b4	eb 09		 jmp	 SHORT $LN4@DIEnumJoys
$LN2@DIEnumJoys:
  005b6	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  005b9	83 c0 01	 add	 eax, 1
  005bc	89 45 ac	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@DIEnumJoys:
  005bf	83 7d ac 07	 cmp	 DWORD PTR _i$3[ebp], 7
  005c3	7e 10		 jle	 SHORT $LN3@DIEnumJoys

; 1898 : 			lpDIE[i] = NULL;

  005c5	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  005c8	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _lpDIE[eax*4], 0
  005d3	eb e1		 jmp	 SHORT $LN2@DIEnumJoys
$LN3@DIEnumJoys:

; 1899 : 	}

  005d5	e9 b4 00 00 00	 jmp	 $LN54@DIEnumJoys
$LN48@DIEnumJoys:

; 1900 : 	else
; 1901 : 	{
; 1902 : 		LPDIRECTINPUTDEVICE2A *rp = &lpDIJA;

  005da	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _rp$2[ebp], OFFSET _lpDIJA

; 1903 : 		LPVOID *tp  = (LPVOID *)rp;

  005e1	8b 45 a8	 mov	 eax, DWORD PTR _rp$2[ebp]
  005e4	89 45 a4	 mov	 DWORD PTR _tp$1[ebp], eax

; 1904 : 		if (FAILED(IDirectInputDevice_QueryInterface(pdev, &IID_IDirectInputDevice2, tp)))

  005e7	8b 45 a4	 mov	 eax, DWORD PTR _tp$1[ebp]
  005ea	50		 push	 eax
  005eb	68 00 00 00 00	 push	 OFFSET _IID_IDirectInputDevice2A
  005f0	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  005f3	51		 push	 ecx
  005f4	8b 55 f8	 mov	 edx, DWORD PTR _pdev$[ebp]
  005f7	8b 02		 mov	 eax, DWORD PTR [edx]
  005f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fb	ff d1		 call	 ecx
  005fd	85 c0		 test	 eax, eax
  005ff	7d 23		 jge	 SHORT $LN50@DIEnumJoys

; 1905 : 		{
; 1906 : 			CONS_Printf("DIEnumJoysticks(): QueryInterface FAILED\n");

  00601	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KMBLEGGG@DIEnumJoysticks?$CI?$CJ?3?5QueryInterfa@
  00606	e8 00 00 00 00	 call	 _CONS_Printf
  0060b	83 c4 04	 add	 esp, 4

; 1907 : 			IDirectInputDevice_Release (pdev);

  0060e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00611	50		 push	 eax
  00612	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  00615	8b 11		 mov	 edx, DWORD PTR [ecx]
  00617	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0061a	ff d0		 call	 eax
  0061c	90		 npad	 1

; 1908 : 			return DIENUM_CONTINUE;

  0061d	b8 01 00 00 00	 mov	 eax, 1
  00622	eb 74		 jmp	 SHORT $LN1@DIEnumJoys
$LN50@DIEnumJoys:

; 1909 : 		}
; 1910 : 
; 1911 : 		if (lpDIJA && JoyInfo.ForceAxises != -1)

  00624	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJA, 0
  0062b	74 61		 je	 SHORT $LN54@DIEnumJoys
  0062d	83 3d 08 00 00
	00 ff		 cmp	 DWORD PTR _JoyInfo+8, -1
  00634	74 58		 je	 SHORT $LN54@DIEnumJoys

; 1912 : 		{
; 1913 : 			// Since we will be playing force feedback effects, we should disable the
; 1914 : 			// auto-centering spring.
; 1915 : 			if (FAILED(SetDIDwordProperty(pdev, DIPROP_AUTOCENTER, 0, DIPH_DEVICE, FALSE)))

  00636	6a 00		 push	 0
  00638	6a 00		 push	 0
  0063a	6a 00		 push	 0
  0063c	6a 09		 push	 9
  0063e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00641	50		 push	 eax
  00642	e8 00 00 00 00	 call	 _SetDIDwordProperty
  00647	83 c4 14	 add	 esp, 20			; 00000014H

; 1916 : 			{
; 1917 : 				//NOP
; 1918 : 			}
; 1919 : 
; 1920 : 			// Enumerate and count the axes of the joystick
; 1921 : 			if (FAILED(IDirectInputDevice_EnumObjects(pdev, EnumAxesCallback,

  0064a	6a 03		 push	 3
  0064c	68 08 00 00 00	 push	 OFFSET _JoyInfo+8
  00651	68 00 00 00 00	 push	 OFFSET _EnumAxesCallback@8
  00656	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00659	50		 push	 eax
  0065a	8b 4d f8	 mov	 ecx, DWORD PTR _pdev$[ebp]
  0065d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0065f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00662	ff d0		 call	 eax
  00664	85 c0		 test	 eax, eax
  00666	7d 0c		 jge	 SHORT $LN53@DIEnumJoys

; 1922 : 				(LPVOID)&JoyInfo.ForceAxises, DIDFT_AXIS)))
; 1923 : 			{
; 1924 : 				JoyInfo.ForceAxises = -1;

  00668	c7 05 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _JoyInfo+8, -1

; 1925 : 			}

  00672	eb 1a		 jmp	 SHORT $LN54@DIEnumJoys
$LN53@DIEnumJoys:

; 1926 : 			else
; 1927 : 			{
; 1928 : 				SetupAllForces(lpDIJA,lpDIE,JoyInfo.ForceAxises);

  00674	a1 08 00 00 00	 mov	 eax, DWORD PTR _JoyInfo+8
  00679	50		 push	 eax
  0067a	68 00 00 00 00	 push	 OFFSET _lpDIE
  0067f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJA
  00685	51		 push	 ecx
  00686	e8 00 00 00 00	 call	 _SetupAllForces
  0068b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@DIEnumJoys:

; 1929 : 			}
; 1930 : 		}
; 1931 : 	}
; 1932 : 
; 1933 : 	// we successfully created an IDirectInputDevice.  So stop looking
; 1934 : 	// for another one.
; 1935 : 	lpDIJ = pdev;

  0068e	8b 45 f8	 mov	 eax, DWORD PTR _pdev$[ebp]
  00691	a3 00 00 00 00	 mov	 DWORD PTR _lpDIJ, eax

; 1936 : 	return DIENUM_STOP;

  00696	33 c0		 xor	 eax, eax
$LN1@DIEnumJoys:

; 1937 : }

  00698	5f		 pop	 edi
  00699	5e		 pop	 esi
  0069a	5b		 pop	 ebx
  0069b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0069e	33 cd		 xor	 ecx, ebp
  006a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a5	8b e5		 mov	 esp, ebp
  006a7	5d		 pop	 ebp
  006a8	c2 08 00	 ret	 8
_DIEnumJoysticks@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _SetDIDwordProperty
_TEXT	SEGMENT
_dipdw$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_pdev$ = 8						; size = 4
_guidProperty$ = 12					; size = 4
_dwObject$ = 16						; size = 4
_dwHow$ = 20						; size = 4
_dwValue$ = 24						; size = 4
_SetDIDwordProperty PROC				; COMDAT

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1640 : 	DIPROPDWORD dipdw;
; 1641 : 
; 1642 : 	dipdw.diph.dwSize       = sizeof (dipdw);

  00013	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _dipdw$[ebp], 20 ; 00000014H

; 1643 : 	dipdw.diph.dwHeaderSize = sizeof (dipdw.diph);

  0001a	c7 45 ec 10 00
	00 00		 mov	 DWORD PTR _dipdw$[ebp+4], 16 ; 00000010H

; 1644 : 	dipdw.diph.dwObj        = dwObject;

  00021	8b 45 10	 mov	 eax, DWORD PTR _dwObject$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _dipdw$[ebp+8], eax

; 1645 : 	dipdw.diph.dwHow        = dwHow;

  00027	8b 45 14	 mov	 eax, DWORD PTR _dwHow$[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR _dipdw$[ebp+12], eax

; 1646 : 	dipdw.dwData            = dwValue;

  0002d	8b 45 18	 mov	 eax, DWORD PTR _dwValue$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR _dipdw$[ebp+16], eax

; 1647 : 
; 1648 : 	return IDirectInputDevice_SetProperty(pdev, guidProperty, &dipdw.diph);

  00033	8d 45 e8	 lea	 eax, DWORD PTR _dipdw$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _guidProperty$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _pdev$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pdev$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00047	ff d2		 call	 edx

; 1649 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_SetDIDwordProperty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _SetForceTacile
_TEXT	SEGMENT
_dMagnitude$1 = -108					; size = 8
_pf$ = -100						; size = 16
_rf$ = -84						; size = 8
_cf$ = -76						; size = 4
_rglDirection$ = -72					; size = 8
_Magnitude$ = -64					; size = 4
_hr$ = -60						; size = 4
_eff$ = -56						; size = 52
__$ArrayPad$ = -4					; size = 4
_SDIE$ = 8						; size = 4
_FF$ = 12						; size = 4
_FFAXIS$ = 16						; size = 4
_EffectType$ = 20					; size = 4
_SetForceTacile PROC					; COMDAT

; 1545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1546 : 	DIEFFECT eff;
; 1547 : 	HRESULT hr;
; 1548 : 	LONG Magnitude;
; 1549 : 	LONG rglDirection[2] = { 0, 0 };

  00016	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _rglDirection$[ebp], 0
  0001d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _rglDirection$[ebp+4], 0

; 1550 : 	DICONSTANTFORCE cf = { 0 }; // LONG lMagnitude

  00024	33 c0		 xor	 eax, eax
  00026	89 45 b4	 mov	 DWORD PTR _cf$[ebp], eax

; 1551 : 	DIRAMPFORCE rf = {0,0}; // LONG lStart, lEnd;

  00029	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp], 0
  00030	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp+4], 0

; 1552 : 	DIPERIODIC pf = {0,0,0,0};

  00037	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp], 0
  0003e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp+4], 0
  00045	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp+8], 0
  0004c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp+12], 0

; 1553 : 	if (!FF)

  00053	83 7d 0c 00	 cmp	 DWORD PTR _FF$[ebp], 0
  00057	75 0f		 jne	 SHORT $LN2@SetForceTa

; 1554 : 		IDirectInputEffect_Stop(SDIE);

  00059	8b 45 08	 mov	 eax, DWORD PTR _SDIE$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _SDIE$[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00065	ff d0		 call	 eax
  00067	90		 npad	 1
$LN2@SetForceTa:

; 1555 : 	Magnitude = FF->Magnitude;

  00068	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  0006b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0006e	89 4d c0	 mov	 DWORD PTR _Magnitude$[ebp], ecx

; 1556 : 	ZeroMemory(&eff, sizeof (eff));

  00071	6a 34		 push	 52			; 00000034H
  00073	6a 00		 push	 0
  00075	8d 45 c8	 lea	 eax, DWORD PTR _eff$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _memset
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1557 : 	eff.dwSize                  = sizeof (eff);

  00081	c7 45 c8 34 00
	00 00		 mov	 DWORD PTR _eff$[ebp], 52 ; 00000034H

; 1558 : 	//DIEP_START
; 1559 : 	eff.dwFlags                 = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS; // Cartesian and data format offsets

  00088	c7 45 cc 12 00
	00 00		 mov	 DWORD PTR _eff$[ebp+4], 18 ; 00000012H

; 1560 : 	//DIEP_DURATION
; 1561 : 	eff.dwDuration              = FF->Duration;

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  00092	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00095	89 4d d0	 mov	 DWORD PTR _eff$[ebp+8], ecx

; 1562 : 	//DIEP_GAIN
; 1563 : 	eff.dwGain                  = FF->Gain;

  00098	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  0009b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0009e	89 4d d8	 mov	 DWORD PTR _eff$[ebp+16], ecx

; 1564 : 	//DIEP_DIRECTION
; 1565 : 	eff.rglDirection            = rglDirection;

  000a1	8d 45 b8	 lea	 eax, DWORD PTR _rglDirection$[ebp]
  000a4	89 45 ec	 mov	 DWORD PTR _eff$[ebp+36], eax

; 1566 : 	//DIEP_TYPESPECIFICPARAMS
; 1567 : 	if (FFAXIS > 1)

  000a7	83 7d 10 01	 cmp	 DWORD PTR _FFAXIS$[ebp], 1
  000ab	76 5f		 jbe	 SHORT $LN3@SetForceTa

; 1568 : 	{
; 1569 : 		double dMagnitude;
; 1570 : 		dMagnitude                  = (double)Magnitude;

  000ad	f2 0f 2a 45 c0	 cvtsi2sd xmm0, DWORD PTR _Magnitude$[ebp]
  000b2	f2 0f 11 45 94	 movsd	 QWORD PTR _dMagnitude$1[ebp], xmm0

; 1571 : 		dMagnitude                  = hypot(dMagnitude, dMagnitude);

  000b7	83 ec 08	 sub	 esp, 8
  000ba	f2 0f 10 45 94	 movsd	 xmm0, QWORD PTR _dMagnitude$1[ebp]
  000bf	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c4	83 ec 08	 sub	 esp, 8
  000c7	f2 0f 10 45 94	 movsd	 xmm0, QWORD PTR _dMagnitude$1[ebp]
  000cc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d1	e8 00 00 00 00	 call	 _hypot
  000d6	83 c4 10	 add	 esp, 16			; 00000010H
  000d9	dd 5d 94	 fstp	 QWORD PTR _dMagnitude$1[ebp]

; 1572 : 		Magnitude                   = (DWORD)dMagnitude;

  000dc	f2 0f 10 45 94	 movsd	 xmm0, QWORD PTR _dMagnitude$1[ebp]
  000e1	e8 00 00 00 00	 call	 __dtol3
  000e6	89 45 c0	 mov	 DWORD PTR _Magnitude$[ebp], eax

; 1573 : 		rglDirection[0]             = FF->ForceX;

  000e9	b8 04 00 00 00	 mov	 eax, 4
  000ee	6b c8 00	 imul	 ecx, eax, 0
  000f1	8b 55 0c	 mov	 edx, DWORD PTR _FF$[ebp]
  000f4	8b 02		 mov	 eax, DWORD PTR [edx]
  000f6	89 44 0d b8	 mov	 DWORD PTR _rglDirection$[ebp+ecx], eax

; 1574 : 		rglDirection[1]             = FF->ForceY;

  000fa	b8 04 00 00 00	 mov	 eax, 4
  000ff	c1 e0 00	 shl	 eax, 0
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _FF$[ebp]
  00105	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00108	89 54 05 b8	 mov	 DWORD PTR _rglDirection$[ebp+eax], edx
$LN3@SetForceTa:

; 1575 : 	}
; 1576 : 	if (EffectType == ConstantForce)

  0010c	83 7d 14 00	 cmp	 DWORD PTR _EffectType$[ebp], 0
  00110	75 15		 jne	 SHORT $LN4@SetForceTa

; 1577 : 	{
; 1578 : 		cf.lMagnitude               = Magnitude;

  00112	8b 45 c0	 mov	 eax, DWORD PTR _Magnitude$[ebp]
  00115	89 45 b4	 mov	 DWORD PTR _cf$[ebp], eax

; 1579 : 		eff.cbTypeSpecificParams    = sizeof (cf);

  00118	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _eff$[ebp+44], 4

; 1580 : 		eff.lpvTypeSpecificParams   = &cf;

  0011f	8d 45 b4	 lea	 eax, DWORD PTR _cf$[ebp]
  00122	89 45 f8	 mov	 DWORD PTR _eff$[ebp+48], eax

; 1581 : 	}

  00125	eb 61		 jmp	 SHORT $LN8@SetForceTa
$LN4@SetForceTa:

; 1582 : 	else if (EffectType == RampForce)

  00127	83 7d 14 01	 cmp	 DWORD PTR _EffectType$[ebp], 1
  0012b	75 21		 jne	 SHORT $LN6@SetForceTa

; 1583 : 	{
; 1584 : 		rf.lStart                   = FF->Start;

  0012d	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  00130	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00133	89 4d ac	 mov	 DWORD PTR _rf$[ebp], ecx

; 1585 : 		rf.lEnd                     = FF->End;

  00136	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  00139	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0013c	89 4d b0	 mov	 DWORD PTR _rf$[ebp+4], ecx

; 1586 : 		eff.cbTypeSpecificParams    = sizeof (rf);

  0013f	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _eff$[ebp+44], 8

; 1587 : 		eff.lpvTypeSpecificParams   = &rf;

  00146	8d 45 ac	 lea	 eax, DWORD PTR _rf$[ebp]
  00149	89 45 f8	 mov	 DWORD PTR _eff$[ebp+48], eax

; 1588 : 	}

  0014c	eb 3a		 jmp	 SHORT $LN8@SetForceTa
$LN6@SetForceTa:

; 1589 : 	else if (EffectType >= SquareForce && SawtoothDownForce >= EffectType)

  0014e	83 7d 14 02	 cmp	 DWORD PTR _EffectType$[ebp], 2
  00152	7c 34		 jl	 SHORT $LN8@SetForceTa
  00154	83 7d 14 06	 cmp	 DWORD PTR _EffectType$[ebp], 6
  00158	7f 2e		 jg	 SHORT $LN8@SetForceTa

; 1590 : 	{
; 1591 : 		pf.dwMagnitude              = Magnitude;

  0015a	8b 45 c0	 mov	 eax, DWORD PTR _Magnitude$[ebp]
  0015d	89 45 9c	 mov	 DWORD PTR _pf$[ebp], eax

; 1592 : 		pf.lOffset                  = FF->Offset;

  00160	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  00163	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00166	89 4d a0	 mov	 DWORD PTR _pf$[ebp+4], ecx

; 1593 : 		pf.dwPhase                  = FF->Phase;

  00169	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  0016c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0016f	89 4d a4	 mov	 DWORD PTR _pf$[ebp+8], ecx

; 1594 : 		pf.dwPeriod                 = FF->Period;

  00172	8b 45 0c	 mov	 eax, DWORD PTR _FF$[ebp]
  00175	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00178	89 4d a8	 mov	 DWORD PTR _pf$[ebp+12], ecx

; 1595 : 		eff.cbTypeSpecificParams    = sizeof (pf);

  0017b	c7 45 f4 10 00
	00 00		 mov	 DWORD PTR _eff$[ebp+44], 16 ; 00000010H

; 1596 : 		eff.lpvTypeSpecificParams   = &pf;

  00182	8d 45 9c	 lea	 eax, DWORD PTR _pf$[ebp]
  00185	89 45 f8	 mov	 DWORD PTR _eff$[ebp+48], eax
$LN8@SetForceTa:

; 1597 : 	}
; 1598 : 
; 1599 : 	LimitEffect(&eff, EffectType);

  00188	8b 45 14	 mov	 eax, DWORD PTR _EffectType$[ebp]
  0018b	50		 push	 eax
  0018c	8d 4d c8	 lea	 ecx, DWORD PTR _eff$[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 _LimitEffect
  00195	83 c4 08	 add	 esp, 8

; 1600 : 
; 1601 : 	hr = IDirectInputEffect_SetParameters(SDIE, &eff,

  00198	68 45 01 00 20	 push	 536871237		; 20000145H
  0019d	8d 45 c8	 lea	 eax, DWORD PTR _eff$[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _SDIE$[ebp]
  001a4	51		 push	 ecx
  001a5	8b 55 08	 mov	 edx, DWORD PTR _SDIE$[ebp]
  001a8	8b 02		 mov	 eax, DWORD PTR [edx]
  001aa	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001ad	ff d1		 call	 ecx
  001af	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 1602 : 	 DIEP_START|DIEP_DURATION|DIEP_GAIN|DIEP_DIRECTION|DIEP_TYPESPECIFICPARAMS);
; 1603 : 	return hr;

  001b2	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]

; 1604 : }

  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
_SetForceTacile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _LimitEffect
_TEXT	SEGMENT
_pDP$ = -8						; size = 4
_pCF$ = -4						; size = 4
_eff$ = 8						; size = 4
_EffectType$ = 12					; size = 4
_LimitEffect PROC					; COMDAT

; 1518 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1519 : 	LPDICONSTANTFORCE pCF = eff->lpvTypeSpecificParams;

  00009	8b 45 08	 mov	 eax, DWORD PTR _eff$[ebp]
  0000c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000f	89 4d fc	 mov	 DWORD PTR _pCF$[ebp], ecx

; 1520 : 	LPDIPERIODIC pDP= eff->lpvTypeSpecificParams;

  00012	8b 45 08	 mov	 eax, DWORD PTR _eff$[ebp]
  00015	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00018	89 4d f8	 mov	 DWORD PTR _pDP$[ebp], ecx

; 1521 : 	if (eff->rglDirection)
; 1522 : 	{
; 1523 : 	}
; 1524 : /*	if (eff->dwDuration != INFINITE && eff->dwDuration < 0)
; 1525 : 	{
; 1526 : 		eff->dwDuration = 0;
; 1527 : 	}*/
; 1528 : 	if (eff->dwGain != 0)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _eff$[ebp]
  0001e	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00022	74 16		 je	 SHORT $LN4@LimitEffec

; 1529 : 	{
; 1530 : 		if (eff->dwGain > DI_FFNOMINALMAX)

  00024	8b 45 08	 mov	 eax, DWORD PTR _eff$[ebp]
  00027	81 78 10 10 27
	00 00		 cmp	 DWORD PTR [eax+16], 10000 ; 00002710H
  0002e	76 0a		 jbe	 SHORT $LN4@LimitEffec

; 1531 : 			eff->dwGain = DI_FFNOMINALMAX;

  00030	8b 45 08	 mov	 eax, DWORD PTR _eff$[ebp]
  00033	c7 40 10 10 27
	00 00		 mov	 DWORD PTR [eax+16], 10000 ; 00002710H
$LN4@LimitEffec:

; 1532 : 		//else if (eff->dwGain < -DI_FFNOMINALMAX)
; 1533 : 		//	eff->dwGain = DI_FFNOMINALMAX;
; 1534 : 	}
; 1535 : 	if (EffectType == ConstantForce && pCF->lMagnitude)
; 1536 : 	{
; 1537 : 	}
; 1538 : 	else if (EffectType >= SquareForce && SawtoothDownForce >= EffectType && pDP)
; 1539 : 	{
; 1540 : 	}
; 1541 : 
; 1542 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_LimitEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _SetupAllForces
_TEXT	SEGMENT
_ForceType$ = -4					; size = 4
_DJI$ = 8						; size = 4
_DJE$ = 12						; size = 4
_FFAXIS$ = 16						; size = 4
_SetupAllForces PROC					; COMDAT

; 1499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1500 : 	FFType ForceType = EvilForce;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ForceType$[ebp], -1

; 1501 : 	if (DJI == lpDIJA)

  00010	8b 45 08	 mov	 eax, DWORD PTR _DJI$[ebp]
  00013	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lpDIJA
  00019	75 46		 jne	 SHORT $LN5@SetupAllFo

; 1502 : 	{
; 1503 : 		IDirectInputDevice2_EnumEffects(DJI,DIEnumEffectsCallback1,&DJE[ConstantForce],DIEFT_CONSTANTFORCE);

  0001b	6a 01		 push	 1
  0001d	b8 04 00 00 00	 mov	 eax, 4
  00022	6b c8 00	 imul	 ecx, eax, 0
  00025	03 4d 0c	 add	 ecx, DWORD PTR _DJE$[ebp]
  00028	51		 push	 ecx
  00029	68 00 00 00 00	 push	 OFFSET _DIEnumEffectsCallback1@8
  0002e	8b 55 08	 mov	 edx, DWORD PTR _DJI$[ebp]
  00031	52		 push	 edx
  00032	8b 45 08	 mov	 eax, DWORD PTR _DJI$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0003a	ff d2		 call	 edx
  0003c	90		 npad	 1

; 1504 : 		IDirectInputDevice2_EnumEffects(DJI,DIEnumEffectsCallback1,&DJE[RampForce],DIEFT_RAMPFORCE);

  0003d	6a 02		 push	 2
  0003f	b8 04 00 00 00	 mov	 eax, 4
  00044	c1 e0 00	 shl	 eax, 0
  00047	03 45 0c	 add	 eax, DWORD PTR _DJE$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET _DIEnumEffectsCallback1@8
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _DJI$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _DJI$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0005c	ff d1		 call	 ecx
  0005e	90		 npad	 1

; 1505 : 	}

  0005f	eb 4f		 jmp	 SHORT $LN7@SetupAllFo
$LN5@SetupAllFo:

; 1506 : 	else if (DJI == lpDIJA)

  00061	8b 45 08	 mov	 eax, DWORD PTR _DJI$[ebp]
  00064	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lpDIJA
  0006a	75 44		 jne	 SHORT $LN7@SetupAllFo

; 1507 : 	{
; 1508 : 		IDirectInputDevice2_EnumEffects(DJI,DIEnumEffectsCallback2,&DJE[ConstantForce],DIEFT_CONSTANTFORCE);

  0006c	6a 01		 push	 1
  0006e	b8 04 00 00 00	 mov	 eax, 4
  00073	6b c8 00	 imul	 ecx, eax, 0
  00076	03 4d 0c	 add	 ecx, DWORD PTR _DJE$[ebp]
  00079	51		 push	 ecx
  0007a	68 00 00 00 00	 push	 OFFSET _DIEnumEffectsCallback2@8
  0007f	8b 55 08	 mov	 edx, DWORD PTR _DJI$[ebp]
  00082	52		 push	 edx
  00083	8b 45 08	 mov	 eax, DWORD PTR _DJI$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0008b	ff d2		 call	 edx
  0008d	90		 npad	 1

; 1509 : 		IDirectInputDevice2_EnumEffects(DJI,DIEnumEffectsCallback2,&DJE[RampForce],DIEFT_RAMPFORCE);

  0008e	6a 02		 push	 2
  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	c1 e0 00	 shl	 eax, 0
  00098	03 45 0c	 add	 eax, DWORD PTR _DJE$[ebp]
  0009b	50		 push	 eax
  0009c	68 00 00 00 00	 push	 OFFSET _DIEnumEffectsCallback2@8
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _DJI$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 08	 mov	 edx, DWORD PTR _DJI$[ebp]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000ad	ff d1		 call	 ecx
  000af	90		 npad	 1
$LN7@SetupAllFo:

; 1510 : 	}
; 1511 : 	for (ForceType = SquareForce; ForceType >  NumberofForces && DIETable[ForceType] != (REFGUID)-1; ForceType++)

  000b0	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _ForceType$[ebp], 2
  000b7	eb 09		 jmp	 SHORT $LN4@SetupAllFo
$LN2@SetupAllFo:
  000b9	8b 45 fc	 mov	 eax, DWORD PTR _ForceType$[ebp]
  000bc	83 c0 01	 add	 eax, 1
  000bf	89 45 fc	 mov	 DWORD PTR _ForceType$[ebp], eax
$LN4@SetupAllFo:
  000c2	83 7d fc 07	 cmp	 DWORD PTR _ForceType$[ebp], 7
  000c6	7e 45		 jle	 SHORT $LN3@SetupAllFo
  000c8	8b 45 fc	 mov	 eax, DWORD PTR _ForceType$[ebp]
  000cb	83 3c 85 00 00
	00 00 ff	 cmp	 DWORD PTR _DIETable[eax*4], -1
  000d3	74 38		 je	 SHORT $LN3@SetupAllFo

; 1512 : 		if (DIETable[ForceType])

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _ForceType$[ebp]
  000d8	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _DIETable[eax*4], 0
  000e0	74 29		 je	 SHORT $LN8@SetupAllFo

; 1513 : 			SetupForceTacile(DJI,&DJE[ForceType], FFAXIS, ForceType, DIETable[ForceType]);

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _ForceType$[ebp]
  000e5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _DIETable[eax*4]
  000ec	51		 push	 ecx
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _ForceType$[ebp]
  000f0	52		 push	 edx
  000f1	8b 45 10	 mov	 eax, DWORD PTR _FFAXIS$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _ForceType$[ebp]
  000f8	8b 55 0c	 mov	 edx, DWORD PTR _DJE$[ebp]
  000fb	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000fe	50		 push	 eax
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _DJI$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _SetupForceTacile
  00108	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@SetupAllFo:
  0010b	eb ac		 jmp	 SHORT $LN2@SetupAllFo
$LN3@SetupAllFo:

; 1514 : 	return S_OK;

  0010d	33 c0		 xor	 eax, eax

; 1515 : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_SetupAllForces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _DIEnumEffectsCallback2@8
_TEXT	SEGMENT
_DJE$ = -4						; size = 4
_pdei$ = 8						; size = 4
_pvRef$ = 12						; size = 4
_DIEnumEffectsCallback2@8 PROC				; COMDAT

; 1471 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1472 : 	LPDIRECTINPUTEFFECT *DJE = pvRef;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pvRef$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _DJE$[ebp], eax

; 1473 : 	if (DIEFT_GETTYPE(pdei->dwEffType) == DIEFT_CONSTANTFORCE)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00012	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00015	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001b	0f b6 d1	 movzx	 edx, cl
  0001e	83 fa 01	 cmp	 edx, 1
  00021	75 2a		 jne	 SHORT $LN3@DIEnumEffe

; 1474 : 	{
; 1475 : 		if (SUCCEEDED(SetupForceTacile(lpDIJ2A,DJE, JoyInfo2.ForceAxises, ConstantForce, &pdei->guid)))

  00023	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00026	83 c0 04	 add	 eax, 4
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _JoyInfo2+8
  00032	51		 push	 ecx
  00033	8b 55 fc	 mov	 edx, DWORD PTR _DJE$[ebp]
  00036	52		 push	 edx
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2A
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _SetupForceTacile
  00042	83 c4 14	 add	 esp, 20			; 00000014H
  00045	85 c0		 test	 eax, eax
  00047	7c 04		 jl	 SHORT $LN3@DIEnumEffe

; 1476 : 			return DIENUM_STOP;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 43		 jmp	 SHORT $LN1@DIEnumEffe
$LN3@DIEnumEffe:

; 1477 : 	}
; 1478 : 	if (DIEFT_GETTYPE(pdei->dwEffType) == DIEFT_RAMPFORCE)

  0004d	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00050	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00053	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00059	0f b6 d1	 movzx	 edx, cl
  0005c	83 fa 02	 cmp	 edx, 2
  0005f	75 2a		 jne	 SHORT $LN5@DIEnumEffe

; 1479 : 	{
; 1480 : 		if (SUCCEEDED(SetupForceTacile(lpDIJ2A,DJE, JoyInfo2.ForceAxises, RampForce, &pdei->guid)))

  00061	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00064	83 c0 04	 add	 eax, 4
  00067	50		 push	 eax
  00068	6a 01		 push	 1
  0006a	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _JoyInfo2+8
  00070	51		 push	 ecx
  00071	8b 55 fc	 mov	 edx, DWORD PTR _DJE$[ebp]
  00074	52		 push	 edx
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2A
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _SetupForceTacile
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	85 c0		 test	 eax, eax
  00085	7c 04		 jl	 SHORT $LN5@DIEnumEffe

; 1481 : 			return DIENUM_STOP;

  00087	33 c0		 xor	 eax, eax
  00089	eb 05		 jmp	 SHORT $LN1@DIEnumEffe
$LN5@DIEnumEffe:

; 1482 : 	}
; 1483 : 	return DIENUM_CONTINUE;

  0008b	b8 01 00 00 00	 mov	 eax, 1
$LN1@DIEnumEffe:

; 1484 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
_DIEnumEffectsCallback2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _DIEnumEffectsCallback1@8
_TEXT	SEGMENT
_DJE$ = -4						; size = 4
_pdei$ = 8						; size = 4
_pvRef$ = 12						; size = 4
_DIEnumEffectsCallback1@8 PROC				; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1456 : 	LPDIRECTINPUTEFFECT *DJE = pvRef;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pvRef$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _DJE$[ebp], eax

; 1457 : 	if (DIEFT_GETTYPE(pdei->dwEffType) == DIEFT_CONSTANTFORCE)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00012	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00015	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001b	0f b6 d1	 movzx	 edx, cl
  0001e	83 fa 01	 cmp	 edx, 1
  00021	75 2a		 jne	 SHORT $LN3@DIEnumEffe

; 1458 : 	{
; 1459 : 		if (SUCCEEDED(SetupForceTacile(lpDIJA,DJE, JoyInfo.ForceAxises, ConstantForce, &pdei->guid)))

  00023	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00026	83 c0 04	 add	 eax, 4
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _JoyInfo+8
  00032	51		 push	 ecx
  00033	8b 55 fc	 mov	 edx, DWORD PTR _DJE$[ebp]
  00036	52		 push	 edx
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJA
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _SetupForceTacile
  00042	83 c4 14	 add	 esp, 20			; 00000014H
  00045	85 c0		 test	 eax, eax
  00047	7c 04		 jl	 SHORT $LN3@DIEnumEffe

; 1460 : 			return DIENUM_STOP;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 43		 jmp	 SHORT $LN1@DIEnumEffe
$LN3@DIEnumEffe:

; 1461 : 	}
; 1462 : 	if (DIEFT_GETTYPE(pdei->dwEffType) == DIEFT_RAMPFORCE)

  0004d	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00050	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00053	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00059	0f b6 d1	 movzx	 edx, cl
  0005c	83 fa 02	 cmp	 edx, 2
  0005f	75 2a		 jne	 SHORT $LN5@DIEnumEffe

; 1463 : 	{
; 1464 : 		if (SUCCEEDED(SetupForceTacile(lpDIJA,DJE, JoyInfo.ForceAxises, RampForce, &pdei->guid)))

  00061	8b 45 08	 mov	 eax, DWORD PTR _pdei$[ebp]
  00064	83 c0 04	 add	 eax, 4
  00067	50		 push	 eax
  00068	6a 01		 push	 1
  0006a	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _JoyInfo+8
  00070	51		 push	 ecx
  00071	8b 55 fc	 mov	 edx, DWORD PTR _DJE$[ebp]
  00074	52		 push	 edx
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJA
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _SetupForceTacile
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	85 c0		 test	 eax, eax
  00085	7c 04		 jl	 SHORT $LN5@DIEnumEffe

; 1465 : 			return DIENUM_STOP;

  00087	33 c0		 xor	 eax, eax
  00089	eb 05		 jmp	 SHORT $LN1@DIEnumEffe
$LN5@DIEnumEffe:

; 1466 : 	}
; 1467 : 	return DIENUM_CONTINUE;

  0008b	b8 01 00 00 00	 mov	 eax, 1
$LN1@DIEnumEffe:

; 1468 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
_DIEnumEffectsCallback1@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _SetupForceTacile
_TEXT	SEGMENT
_pf$ = -104						; size = 16
_rf$ = -88						; size = 8
_cf$ = -80						; size = 4
_rglDirection$ = -76					; size = 8
_rgdwAxes$ = -68					; size = 8
_eff$ = -60						; size = 52
_hr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_DJI$ = 8						; size = 4
_DJE$ = 12						; size = 4
_FFAXIS$ = 16						; size = 4
_EffectType$ = 20					; size = 4
_EffectGUID$ = 24					; size = 4
_SetupForceTacile PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1403 : 	HRESULT hr;
; 1404 : 	DIEFFECT eff;
; 1405 : 	DWORD rgdwAxes[2] = { DIJOFS_X, DIJOFS_Y };

  00016	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _rgdwAxes$[ebp], 0
  0001d	c7 45 c0 04 00
	00 00		 mov	 DWORD PTR _rgdwAxes$[ebp+4], 4

; 1406 : 	LONG rglDirection[2] = { 0, 0 };

  00024	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _rglDirection$[ebp], 0
  0002b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _rglDirection$[ebp+4], 0

; 1407 : 	DICONSTANTFORCE cf = { 0 }; // LONG lMagnitude

  00032	33 c0		 xor	 eax, eax
  00034	89 45 b0	 mov	 DWORD PTR _cf$[ebp], eax

; 1408 : 	DIRAMPFORCE rf = {0,0}; // LONG lStart, lEnd;

  00037	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp], 0
  0003e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp+4], 0

; 1409 : 	DIPERIODIC pf = {0,0,0,0};

  00045	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp], 0
  0004c	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp+4], 0
  00053	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp+8], 0
  0005a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _pf$[ebp+12], 0

; 1410 : 	ZeroMemory(&eff, sizeof (eff));

  00061	6a 34		 push	 52			; 00000034H
  00063	6a 00		 push	 0
  00065	8d 45 c4	 lea	 eax, DWORD PTR _eff$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _memset
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1411 : 	if (FFAXIS > 2)

  00071	83 7d 10 02	 cmp	 DWORD PTR _FFAXIS$[ebp], 2
  00075	76 07		 jbe	 SHORT $LN2@SetupForce

; 1412 : 		FFAXIS = 2; //up to 2 FFAXIS

  00077	c7 45 10 02 00
	00 00		 mov	 DWORD PTR _FFAXIS$[ebp], 2
$LN2@SetupForce:

; 1413 : 	eff.dwSize                  = sizeof (DIEFFECT);

  0007e	c7 45 c4 34 00
	00 00		 mov	 DWORD PTR _eff$[ebp], 52 ; 00000034H

; 1414 : 	eff.dwFlags                 = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS; // Cartesian and data format offsets

  00085	c7 45 c8 12 00
	00 00		 mov	 DWORD PTR _eff$[ebp+4], 18 ; 00000012H

; 1415 : 	eff.dwDuration              = INFINITE;

  0008c	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _eff$[ebp+8], -1

; 1416 : 	eff.dwSamplePeriod          = 0;

  00093	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _eff$[ebp+12], 0

; 1417 : 	eff.dwGain                  = DI_FFNOMINALMAX;

  0009a	c7 45 d4 10 27
	00 00		 mov	 DWORD PTR _eff$[ebp+16], 10000 ; 00002710H

; 1418 : 	eff.dwTriggerButton         = DIEB_NOTRIGGER;

  000a1	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR _eff$[ebp+20], -1

; 1419 : 	eff.dwTriggerRepeatInterval = 0;

  000a8	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _eff$[ebp+24], 0

; 1420 : 	eff.cAxes                   = FFAXIS;

  000af	8b 45 10	 mov	 eax, DWORD PTR _FFAXIS$[ebp]
  000b2	89 45 e0	 mov	 DWORD PTR _eff$[ebp+28], eax

; 1421 : 	eff.rgdwAxes                = rgdwAxes;

  000b5	8d 45 bc	 lea	 eax, DWORD PTR _rgdwAxes$[ebp]
  000b8	89 45 e4	 mov	 DWORD PTR _eff$[ebp+32], eax

; 1422 : 	eff.rglDirection            = rglDirection;

  000bb	8d 45 b4	 lea	 eax, DWORD PTR _rglDirection$[ebp]
  000be	89 45 e8	 mov	 DWORD PTR _eff$[ebp+36], eax

; 1423 : 	eff.lpEnvelope              = NULL;

  000c1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _eff$[ebp+40], 0

; 1424 : 	eff.lpvTypeSpecificParams   = NULL;

  000c8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _eff$[ebp+48], 0

; 1425 : 	if (EffectType == ConstantForce)

  000cf	83 7d 14 00	 cmp	 DWORD PTR _EffectType$[ebp], 0
  000d3	75 0f		 jne	 SHORT $LN3@SetupForce

; 1426 : 	{
; 1427 : 		eff.cbTypeSpecificParams    = sizeof (cf);

  000d5	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _eff$[ebp+44], 4

; 1428 : 		eff.lpvTypeSpecificParams   = &cf;

  000dc	8d 45 b0	 lea	 eax, DWORD PTR _cf$[ebp]
  000df	89 45 f4	 mov	 DWORD PTR _eff$[ebp+48], eax

; 1429 : 	}

  000e2	eb 2e		 jmp	 SHORT $LN7@SetupForce
$LN3@SetupForce:

; 1430 : 	else if (EffectType == RampForce)

  000e4	83 7d 14 01	 cmp	 DWORD PTR _EffectType$[ebp], 1
  000e8	75 0f		 jne	 SHORT $LN5@SetupForce

; 1431 : 	{
; 1432 : 		eff.cbTypeSpecificParams    = sizeof (rf);

  000ea	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _eff$[ebp+44], 8

; 1433 : 		eff.lpvTypeSpecificParams   = &rf;

  000f1	8d 45 a8	 lea	 eax, DWORD PTR _rf$[ebp]
  000f4	89 45 f4	 mov	 DWORD PTR _eff$[ebp+48], eax

; 1434 : 	}

  000f7	eb 19		 jmp	 SHORT $LN7@SetupForce
$LN5@SetupForce:

; 1435 : 	else if (EffectType >= SquareForce && SawtoothDownForce >= EffectType)

  000f9	83 7d 14 02	 cmp	 DWORD PTR _EffectType$[ebp], 2
  000fd	7c 13		 jl	 SHORT $LN7@SetupForce
  000ff	83 7d 14 06	 cmp	 DWORD PTR _EffectType$[ebp], 6
  00103	7f 0d		 jg	 SHORT $LN7@SetupForce

; 1436 : 	{
; 1437 : 		eff.cbTypeSpecificParams    = sizeof (pf);

  00105	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _eff$[ebp+44], 16 ; 00000010H

; 1438 : 		eff.lpvTypeSpecificParams   = &pf;

  0010c	8d 45 98	 lea	 eax, DWORD PTR _pf$[ebp]
  0010f	89 45 f4	 mov	 DWORD PTR _eff$[ebp+48], eax
$LN7@SetupForce:

; 1439 : 	}
; 1440 : 
; 1441 : 	// Create the prepared effect
; 1442 : 	if (FAILED(hr = IDirectInputDevice2_CreateEffect(DJI, EffectGUID,

  00112	6a 00		 push	 0
  00114	8b 45 0c	 mov	 eax, DWORD PTR _DJE$[ebp]
  00117	50		 push	 eax
  00118	8d 4d c4	 lea	 ecx, DWORD PTR _eff$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 18	 mov	 edx, DWORD PTR _EffectGUID$[ebp]
  0011f	52		 push	 edx
  00120	8b 45 08	 mov	 eax, DWORD PTR _DJI$[ebp]
  00123	50		 push	 eax
  00124	8b 4d 08	 mov	 ecx, DWORD PTR _DJI$[ebp]
  00127	8b 11		 mov	 edx, DWORD PTR [ecx]
  00129	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0012c	ff d0		 call	 eax
  0012e	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  00131	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00135	7d 05		 jge	 SHORT $LN8@SetupForce

; 1443 : 	 &eff, DJE, NULL)))
; 1444 : 	{
; 1445 : 		return hr;

  00137	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  0013a	eb 12		 jmp	 SHORT $LN1@SetupForce
$LN8@SetupForce:

; 1446 : 	}
; 1447 : 
; 1448 : 	if (NULL == *DJE)

  0013c	8b 45 0c	 mov	 eax, DWORD PTR _DJE$[ebp]
  0013f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00142	75 07		 jne	 SHORT $LN9@SetupForce

; 1449 : 		return E_FAIL;

  00144	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00149	eb 03		 jmp	 SHORT $LN1@SetupForce
$LN9@SetupForce:

; 1450 : 
; 1451 : 	return hr;

  0014b	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
$LN1@SetupForce:

; 1452 : }

  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	33 cd		 xor	 ecx, ebp
  00156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
_SetupForceTacile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _EnumAxesCallback@8
_TEXT	SEGMENT
_pdwNumForceFeedbackAxis$ = -4				; size = 4
_pdidoi$ = 8						; size = 4
_pContext$ = 12						; size = 4
_EnumAxesCallback@8 PROC				; COMDAT

; 1391 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 : 	DWORD* pdwNumForceFeedbackAxis = (DWORD*) pContext;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pContext$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pdwNumForceFeedbackAxis$[ebp], eax

; 1393 : 
; 1394 : 	if ((pdidoi->dwFlags & DIDOI_FFACTUATOR) != 0)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pdidoi$[ebp]
  00012	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00015	83 e1 01	 and	 ecx, 1
  00018	74 0d		 je	 SHORT $LN2@EnumAxesCa

; 1395 : 		(*pdwNumForceFeedbackAxis)++;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _pdwNumForceFeedbackAxis$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	83 c1 01	 add	 ecx, 1
  00022	8b 55 fc	 mov	 edx, DWORD PTR _pdwNumForceFeedbackAxis$[ebp]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
$LN2@EnumAxesCa:

; 1396 : 
; 1397 : 	return DIENUM_CONTINUE;

  00027	b8 01 00 00 00	 mov	 eax, 1

; 1398 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_EnumAxesCallback@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownSysMouse
_TEXT	SEGMENT
_I_ShutdownSysMouse PROC				; COMDAT

; 1111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1112 : 	if (restore_mouse)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _restore_mouse, 0
  00010	74 12		 je	 SHORT $LN2@I_Shutdown

; 1113 : 		SystemParametersInfo(SPI_SETMOUSE, 0, old_mparms, 0);

  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET _old_mparms
  00019	6a 00		 push	 0
  0001b	6a 04		 push	 4
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16
  00023	90		 npad	 1
$LN2@I_Shutdown:

; 1114 : 	ClipCursor(NULL);

  00024	6a 00		 push	 0
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClipCursor@4
  0002c	90		 npad	 1

; 1115 : 	ReleaseCapture();

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0
  00033	90		 npad	 1

; 1116 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_I_ShutdownSysMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_DoStartupSysMouse
_TEXT	SEGMENT
_w_rect$ = -24						; size = 16
_valid$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_DoStartupSysMouse PROC				; COMDAT

; 1078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1079 : 	boolean valid;
; 1080 : 	RECT w_rect;
; 1081 : 
; 1082 : 	valid = SystemParametersInfo(SPI_GETMOUSE, 0, old_mparms, 0);

  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET _old_mparms
  0001a	6a 00		 push	 0
  0001c	6a 03		 push	 3
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16
  00024	89 45 f8	 mov	 DWORD PTR _valid$[ebp], eax

; 1083 : 	if (valid)

  00027	83 7d f8 00	 cmp	 DWORD PTR _valid$[ebp], 0
  0002b	74 30		 je	 SHORT $LN2@I_DoStartu

; 1084 : 	{
; 1085 : 		new_mparms[2] = old_mparms[2];

  0002d	b8 04 00 00 00	 mov	 eax, 4
  00032	d1 e0		 shl	 eax, 1
  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	d1 e1		 shl	 ecx, 1
  0003b	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _old_mparms[eax]
  00041	89 91 00 00 00
	00		 mov	 DWORD PTR _new_mparms[ecx], edx

; 1086 : 		restore_mouse = SystemParametersInfo(SPI_SETMOUSE, 0, new_mparms, 0);

  00047	6a 00		 push	 0
  00049	68 00 00 00 00	 push	 OFFSET _new_mparms
  0004e	6a 00		 push	 0
  00050	6a 04		 push	 4
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SystemParametersInfoA@16
  00058	a3 00 00 00 00	 mov	 DWORD PTR _restore_mouse, eax
$LN2@I_DoStartu:

; 1087 : 	}
; 1088 : 
; 1089 : 	if (bAppFullScreen)

  0005d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  00064	74 10		 je	 SHORT $LN3@I_DoStartu

; 1090 : 	{
; 1091 : 		w_rect.top = 0;

  00066	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _w_rect$[ebp+4], 0

; 1092 : 		w_rect.left = 0;

  0006d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _w_rect$[ebp], 0

; 1093 : 	}

  00074	eb 10		 jmp	 SHORT $LN4@I_DoStartu
$LN3@I_DoStartu:

; 1094 : 	else
; 1095 : 	{
; 1096 : 		w_rect.top = windowPosY;

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowPosY
  0007b	89 45 ec	 mov	 DWORD PTR _w_rect$[ebp+4], eax

; 1097 : 		w_rect.left = windowPosX;

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowPosX
  00083	89 45 e8	 mov	 DWORD PTR _w_rect$[ebp], eax
$LN4@I_DoStartu:

; 1098 : 	}
; 1099 : 
; 1100 : 	w_rect.bottom = w_rect.top + VIDHEIGHT;

  00086	8b 45 ec	 mov	 eax, DWORD PTR _w_rect$[ebp+4]
  00089	03 05 10 00 00
	00		 add	 eax, DWORD PTR _vid+16
  0008f	89 45 f4	 mov	 DWORD PTR _w_rect$[ebp+12], eax

; 1101 : 	w_rect.right = w_rect.left + VIDWIDTH;

  00092	8b 45 e8	 mov	 eax, DWORD PTR _w_rect$[ebp]
  00095	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0009b	89 45 f0	 mov	 DWORD PTR _w_rect$[ebp+8], eax

; 1102 : 	center_x = w_rect.left + (VIDWIDTH >> 1);

  0009e	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000a3	d1 f8		 sar	 eax, 1
  000a5	03 45 e8	 add	 eax, DWORD PTR _w_rect$[ebp]
  000a8	a3 00 00 00 00	 mov	 DWORD PTR _center_x, eax

; 1103 : 	center_y = w_rect.top + (VIDHEIGHT >> 1);

  000ad	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  000b2	d1 f8		 sar	 eax, 1
  000b4	03 45 ec	 add	 eax, DWORD PTR _w_rect$[ebp+4]
  000b7	a3 00 00 00 00	 mov	 DWORD PTR _center_y, eax

; 1104 : 	SetCursor(NULL);

  000bc	6a 00		 push	 0
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  000c4	90		 npad	 1

; 1105 : 	SetCursorPos(center_x, center_y);

  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _center_y
  000ca	50		 push	 eax
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _center_x
  000d1	51		 push	 ecx
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursorPos@8
  000d8	90		 npad	 1

; 1106 : 	SetCapture(hWndMain);

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCapture@4
  000e5	90		 npad	 1

; 1107 : 	ClipCursor(&w_rect);

  000e6	8d 45 e8	 lea	 eax, DWORD PTR _w_rect$[ebp]
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClipCursor@4
  000f0	90		 npad	 1

; 1108 : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	33 cd		 xor	 ecx, ebp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
_I_DoStartupSysMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_PoolMouse2
_TEXT	SEGMENT
tv68 = -356						; size = 4
_dy$ = -286						; size = 1
_dx$ = -285						; size = 1
_i$ = -284						; size = 4
_dwLength$ = -280					; size = 4
_dwErrorFlags$ = -276					; size = 4
_ComStat$ = -272					; size = 12
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_I_PoolMouse2 PROC					; COMDAT

; 960  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 961  : 	BYTE buffer[MOUSECOMBUFFERSIZE];
; 962  : 	COMSTAT ComStat;
; 963  : 	DWORD dwErrorFlags, dwLength, i;
; 964  : 	CHAR dx, dy;
; 965  : 	static BYTE bytenum, combytes[4];
; 966  : 
; 967  : 	ClearCommError(mouse2filehandle, &dwErrorFlags, &ComStat);

  00016	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _ComStat$[ebp]
  0001c	50		 push	 eax
  0001d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dwErrorFlags$[ebp]
  00023	51		 push	 ecx
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _mouse2filehandle
  0002a	52		 push	 edx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClearCommError@12
  00031	90		 npad	 1

; 968  : 	dwLength = min(MOUSECOMBUFFERSIZE, ComStat.cbInQue);

  00032	81 bd f4 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR _ComStat$[ebp+4], 256 ; 00000100H
  0003c	76 0c		 jbe	 SHORT $LN17@I_PoolMous
  0003e	c7 85 9c fe ff
	ff 00 01 00 00	 mov	 DWORD PTR tv68[ebp], 256 ; 00000100H
  00048	eb 0c		 jmp	 SHORT $LN18@I_PoolMous
$LN17@I_PoolMous:
  0004a	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ComStat$[ebp+4]
  00050	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN18@I_PoolMous:
  00056	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  0005c	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _dwLength$[ebp], ecx

; 969  : 
; 970  : 	if (dwLength > 0)

  00062	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _dwLength$[ebp], 0
  00069	0f 86 d8 01 00
	00		 jbe	 $LN3@I_PoolMous

; 971  : 	{
; 972  : 		if (!ReadFile(mouse2filehandle, buffer, dwLength, &dwLength, NULL))

  0006f	6a 00		 push	 0
  00071	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _dwLength$[ebp]
  00077	50		 push	 eax
  00078	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _dwLength$[ebp]
  0007e	51		 push	 ecx
  0007f	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _buffer$[ebp]
  00085	52		 push	 edx
  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00092	85 c0		 test	 eax, eax
  00094	75 12		 jne	 SHORT $LN6@I_PoolMous

; 973  : 		{
; 974  : 			CONS_Printf("\2Read Error on secondary mouse port\n");

  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KCELBNNB@?$ACRead?5Error?5on?5secondary?5mouse?5@
  0009b	e8 00 00 00 00	 call	 _CONS_Printf
  000a0	83 c4 04	 add	 esp, 4

; 975  : 			return;

  000a3	e9 9f 01 00 00	 jmp	 $LN3@I_PoolMous
$LN6@I_PoolMous:

; 976  : 		}
; 977  : 
; 978  : 		// parse the mouse packets
; 979  : 		for (i = 0; i < dwLength; i++)

  000a8	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000b2	eb 0f		 jmp	 SHORT $LN4@I_PoolMous
$LN2@I_PoolMous:
  000b4	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_PoolMous:
  000c3	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000c9	3b 85 e8 fe ff
	ff		 cmp	 eax, DWORD PTR _dwLength$[ebp]
  000cf	0f 83 72 01 00
	00		 jae	 $LN3@I_PoolMous

; 980  : 		{
; 981  : 			if ((buffer[i] & 64) == 64)

  000d5	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000db	0f b6 8c 05 fc
	fe ff ff	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  000e3	83 e1 40	 and	 ecx, 64			; 00000040H
  000e6	74 07		 je	 SHORT $LN7@I_PoolMous

; 982  : 				bytenum = 0;

  000e8	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9, 0
$LN7@I_PoolMous:

; 983  : 
; 984  : 			if (bytenum < 4)

  000ef	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9
  000f6	83 f8 04	 cmp	 eax, 4
  000f9	7d 1a		 jge	 SHORT $LN8@I_PoolMous

; 985  : 				combytes[bytenum] = buffer[i];

  000fb	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9
  00102	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00108	8a 94 0d fc fe
	ff ff		 mov	 dl, BYTE PTR _buffer$[ebp+ecx]
  0010f	88 90 00 00 00
	00		 mov	 BYTE PTR ?combytes@?1??I_PoolMouse2@@9@9[eax], dl
$LN8@I_PoolMous:

; 986  : 			bytenum++;

  00115	a0 00 00 00 00	 mov	 al, BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9
  0011a	04 01		 add	 al, 1
  0011c	a2 00 00 00 00	 mov	 BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9, al

; 987  : 
; 988  : 			if (bytenum == 1)

  00121	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9
  00128	83 f8 01	 cmp	 eax, 1
  0012b	75 33		 jne	 SHORT $LN9@I_PoolMous

; 989  : 			{
; 990  : 				handlermouse2buttons &= ~3;

  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR _handlermouse2buttons
  00132	83 e0 fc	 and	 eax, -4			; fffffffcH
  00135	a3 00 00 00 00	 mov	 DWORD PTR _handlermouse2buttons, eax

; 991  : 				handlermouse2buttons |= ((combytes[0] & (32+16)) >>4);

  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	6b c8 00	 imul	 ecx, eax, 0
  00142	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?combytes@?1??I_PoolMouse2@@9@9[ecx]
  00149	83 e2 30	 and	 edx, 48			; 00000030H
  0014c	c1 fa 04	 sar	 edx, 4
  0014f	0b 15 00 00 00
	00		 or	 edx, DWORD PTR _handlermouse2buttons
  00155	89 15 00 00 00
	00		 mov	 DWORD PTR _handlermouse2buttons, edx

; 992  : 			}

  0015b	e9 e2 00 00 00	 jmp	 $LN15@I_PoolMous
$LN9@I_PoolMous:

; 993  : 			else if (bytenum == 3)

  00160	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9
  00167	83 f8 03	 cmp	 eax, 3
  0016a	0f 85 97 00 00
	00		 jne	 $LN11@I_PoolMous

; 994  : 			{
; 995  : 				dx = (CHAR)((combytes[0] &  3) << 6);

  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	6b c8 00	 imul	 ecx, eax, 0
  00178	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?combytes@?1??I_PoolMouse2@@9@9[ecx]
  0017f	83 e2 03	 and	 edx, 3
  00182	c1 e2 06	 shl	 edx, 6
  00185	88 95 e3 fe ff
	ff		 mov	 BYTE PTR _dx$[ebp], dl

; 996  : 				dy = (CHAR)((combytes[0] & 12) << 4);

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	6b c8 00	 imul	 ecx, eax, 0
  00193	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?combytes@?1??I_PoolMouse2@@9@9[ecx]
  0019a	83 e2 0c	 and	 edx, 12			; 0000000cH
  0019d	c1 e2 04	 shl	 edx, 4
  001a0	88 95 e2 fe ff
	ff		 mov	 BYTE PTR _dy$[ebp], dl

; 997  : 				dx = (CHAR)(dx + combytes[1]);

  001a6	0f be 85 e3 fe
	ff ff		 movsx	 eax, BYTE PTR _dx$[ebp]
  001ad	b9 01 00 00 00	 mov	 ecx, 1
  001b2	c1 e1 00	 shl	 ecx, 0
  001b5	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?combytes@?1??I_PoolMouse2@@9@9[ecx]
  001bc	03 c2		 add	 eax, edx
  001be	88 85 e3 fe ff
	ff		 mov	 BYTE PTR _dx$[ebp], al

; 998  : 				dy = (CHAR)(dy + combytes[2]);

  001c4	0f be 85 e2 fe
	ff ff		 movsx	 eax, BYTE PTR _dy$[ebp]
  001cb	b9 01 00 00 00	 mov	 ecx, 1
  001d0	d1 e1		 shl	 ecx, 1
  001d2	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR ?combytes@?1??I_PoolMouse2@@9@9[ecx]
  001d9	03 c2		 add	 eax, edx
  001db	88 85 e2 fe ff
	ff		 mov	 BYTE PTR _dy$[ebp], al

; 999  : 				handlermouse2x += dx;

  001e1	0f be 85 e3 fe
	ff ff		 movsx	 eax, BYTE PTR _dx$[ebp]
  001e8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _handlermouse2x
  001ee	a3 00 00 00 00	 mov	 DWORD PTR _handlermouse2x, eax

; 1000 : 				handlermouse2y += dy;

  001f3	0f be 85 e2 fe
	ff ff		 movsx	 eax, BYTE PTR _dy$[ebp]
  001fa	03 05 00 00 00
	00		 add	 eax, DWORD PTR _handlermouse2y
  00200	a3 00 00 00 00	 mov	 DWORD PTR _handlermouse2y, eax

; 1001 : 			}

  00205	eb 3b		 jmp	 SHORT $LN15@I_PoolMous
$LN11@I_PoolMous:

; 1002 : 			else if (bytenum == 4) // fourth byte (logitech mouses)

  00207	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?bytenum@?1??I_PoolMouse2@@9@9
  0020e	83 f8 04	 cmp	 eax, 4
  00211	75 2f		 jne	 SHORT $LN15@I_PoolMous

; 1003 : 			{
; 1004 : 				if (buffer[i] & 32)

  00213	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00219	0f b6 8c 05 fc
	fe ff ff	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  00221	83 e1 20	 and	 ecx, 32			; 00000020H
  00224	74 0f		 je	 SHORT $LN14@I_PoolMous

; 1005 : 					handlermouse2buttons |= 4;

  00226	a1 00 00 00 00	 mov	 eax, DWORD PTR _handlermouse2buttons
  0022b	83 c8 04	 or	 eax, 4
  0022e	a3 00 00 00 00	 mov	 DWORD PTR _handlermouse2buttons, eax
  00233	eb 0d		 jmp	 SHORT $LN15@I_PoolMous
$LN14@I_PoolMous:

; 1006 : 				else
; 1007 : 					handlermouse2buttons &= ~4;

  00235	a1 00 00 00 00	 mov	 eax, DWORD PTR _handlermouse2buttons
  0023a	83 e0 fb	 and	 eax, -5			; fffffffbH
  0023d	a3 00 00 00 00	 mov	 DWORD PTR _handlermouse2buttons, eax
$LN15@I_PoolMous:

; 1008 : 			}
; 1009 : 		}

  00242	e9 6d fe ff ff	 jmp	 $LN2@I_PoolMous
$LN3@I_PoolMous:

; 1010 : 	}
; 1011 : }

  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024d	33 cd		 xor	 ecx, ebp
  0024f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c3		 ret	 0
_I_PoolMouse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownMouse2
_TEXT	SEGMENT
_i$1 = -24						; size = 4
_event$2 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_I_ShutdownMouse2 PROC					; COMDAT

; 929  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 930  : 	if (mouse2filehandle != INVALID_HANDLE_VALUE)

  00013	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mouse2filehandle, -1
  0001a	0f 84 8b 00 00
	00		 je	 $LN5@I_Shutdown

; 931  : 	{
; 932  : 		event_t event;
; 933  : 		UINT i;
; 934  : 
; 935  : 		SetCommMask(mouse2filehandle, 0);

  00020	6a 00		 push	 0
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCommMask@8
  0002e	90		 npad	 1

; 936  : 
; 937  : 		EscapeCommFunction(mouse2filehandle, CLRDTR);

  0002f	6a 06		 push	 6
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EscapeCommFunction@8
  0003d	90		 npad	 1

; 938  : 		EscapeCommFunction(mouse2filehandle, CLRRTS);

  0003e	6a 04		 push	 4
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EscapeCommFunction@8
  0004c	90		 npad	 1

; 939  : 
; 940  : 		PurgeComm(mouse2filehandle, PURGE_TXABORT|PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);

  0004d	6a 0f		 push	 15			; 0000000fH
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PurgeComm@8
  0005b	90		 npad	 1

; 941  : 
; 942  : 		CloseHandle(mouse2filehandle);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  00061	50		 push	 eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00068	90		 npad	 1

; 943  : 
; 944  : 		// emulate the up of all mouse buttons
; 945  : 		for (i = 0; i < MOUSEBUTTONS; i++)

  00069	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00070	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  00072	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@I_Shutdown:
  0007b	83 7d e8 08	 cmp	 DWORD PTR _i$1[ebp], 8
  0007f	73 20		 jae	 SHORT $LN3@I_Shutdown

; 946  : 		{
; 947  : 			event.type = ev_keyup;

  00081	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _event$2[ebp], 1

; 948  : 			event.data1 = KEY_2MOUSE1 + i;

  00088	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  0008b	05 70 01 00 00	 add	 eax, 368		; 00000170H
  00090	89 45 f0	 mov	 DWORD PTR _event$2[ebp+4], eax

; 949  : 			D_PostEvent(&event);

  00093	8d 45 ec	 lea	 eax, DWORD PTR _event$2[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _D_PostEvent
  0009c	83 c4 04	 add	 esp, 4

; 950  : 		}

  0009f	eb d1		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 951  : 
; 952  : 		mouse2filehandle = INVALID_HANDLE_VALUE;

  000a1	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _mouse2filehandle, -1
$LN5@I_Shutdown:

; 953  : 	}
; 954  : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
_I_ShutdownMouse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownMouse
_TEXT	SEGMENT
_event$ = -24						; size = 16
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_ShutdownMouse PROC					; COMDAT

; 1228 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1229 : 	int i;
; 1230 : 	event_t event;
; 1231 : 
; 1232 : 	CONS_Printf("I_ShutdownMouse()\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CBEGCOGG@I_ShutdownMouse?$CI?$CJ?6@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 1233 : 
; 1234 : 	if (lpDIM)

  00020	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIM, 0
  00027	74 32		 je	 SHORT $LN5@I_Shutdown

; 1235 : 	{
; 1236 : 		IDirectInputDevice_Unacquire(lpDIM);

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIM
  0002e	50		 push	 eax
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIM
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0003a	ff d0		 call	 eax
  0003c	90		 npad	 1

; 1237 : 		IDirectInputDevice_Release(lpDIM);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIM
  00042	50		 push	 eax
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIM
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004e	ff d0		 call	 eax
  00050	90		 npad	 1

; 1238 : 		lpDIM = NULL;

  00051	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIM, 0
$LN5@I_Shutdown:

; 1239 : 	}
; 1240 : 
; 1241 : 	// emulate the up of all mouse buttons
; 1242 : 	for (i = 0; i < MOUSEBUTTONS; i++)

  0005b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00062	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  00064	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_Shutdown:
  0006d	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  00071	7d 20		 jge	 SHORT $LN3@I_Shutdown

; 1243 : 	{
; 1244 : 		event.type = ev_keyup;

  00073	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1

; 1245 : 		event.data1 = KEY_MOUSE1 + i;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00082	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 1246 : 		D_PostEvent(&event);

  00085	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _D_PostEvent
  0008e	83 c4 04	 add	 esp, 4

; 1247 : 	}

  00091	eb d1		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 1248 : 	if (nodinput)

  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  0009a	74 06		 je	 SHORT $LN6@I_Shutdown

; 1249 : 		I_ShutdownSysMouse();

  0009c	e8 00 00 00 00	 call	 _I_ShutdownSysMouse
  000a1	90		 npad	 1
$LN6@I_Shutdown:

; 1250 : 
; 1251 : 	mouse_enabled = false;

  000a2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mouse_enabled, 0

; 1252 : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b2	33 cd		 xor	 ecx, ebp
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_I_ShutdownMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _CreateDevice2A
_TEXT	SEGMENT
_tp$1 = -24						; size = 4
_rp$2 = -20						; size = 4
_lpdid2$ = -16						; size = 4
_lpdid1$ = -12						; size = 4
_hr2$ = -8						; size = 4
_hr$ = -4						; size = 4
_di$ = 8						; size = 4
_pguid$ = 12						; size = 4
_lpDEV$ = 16						; size = 4
_lpDEV2$ = 20						; size = 4
_CreateDevice2A PROC					; COMDAT

; 872  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 873  : 	HRESULT hr, hr2;
; 874  : 	LPDIRECTINPUTDEVICEA lpdid1;
; 875  : 	LPDIRECTINPUTDEVICE2A lpdid2 = NULL;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _lpdid2$[ebp], 0

; 876  : 
; 877  : 	hr = IDirectInput_CreateDevice(di, pguid, &lpdid1, NULL);

  00010	6a 00		 push	 0
  00012	8d 45 f4	 lea	 eax, DWORD PTR _lpdid1$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _pguid$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _di$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR _di$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00026	ff d2		 call	 edx
  00028	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 878  : 
; 879  : 	if (SUCCEEDED(hr))

  0002b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002f	7c 50		 jl	 SHORT $LN2@CreateDevi

; 880  : 	{
; 881  : 		// get Device2 but only if we are not in DirectInput version 3
; 882  : 		if (!bDX0300 && lpDEV2)

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDX0300, 0
  00038	75 45		 jne	 SHORT $LN5@CreateDevi
  0003a	83 7d 14 00	 cmp	 DWORD PTR _lpDEV2$[ebp], 0
  0003e	74 3f		 je	 SHORT $LN5@CreateDevi

; 883  : 		{
; 884  : 			LPDIRECTINPUTDEVICE2A *rp = &lpdid2;

  00040	8d 45 f0	 lea	 eax, DWORD PTR _lpdid2$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR _rp$2[ebp], eax

; 885  : 			LPVOID *tp  = (LPVOID *)rp;

  00046	8b 45 ec	 mov	 eax, DWORD PTR _rp$2[ebp]
  00049	89 45 e8	 mov	 DWORD PTR _tp$1[ebp], eax

; 886  : 			hr2 = IDirectInputDevice_QueryInterface(lpdid1, &IID_IDirectInputDevice2, tp);

  0004c	8b 45 e8	 mov	 eax, DWORD PTR _tp$1[ebp]
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET _IID_IDirectInputDevice2A
  00055	8b 4d f4	 mov	 ecx, DWORD PTR _lpdid1$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 f4	 mov	 edx, DWORD PTR _lpdid1$[ebp]
  0005c	8b 02		 mov	 eax, DWORD PTR [edx]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	ff d1		 call	 ecx
  00062	89 45 f8	 mov	 DWORD PTR _hr2$[ebp], eax

; 887  : 			if (FAILED(hr2))

  00065	83 7d f8 00	 cmp	 DWORD PTR _hr2$[ebp], 0
  00069	7d 14		 jge	 SHORT $LN5@CreateDevi

; 888  : 			{
; 889  : 				CONS_Printf("\2Could not create IDirectInput device 2");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HMIBAJHL@?$ACCould?5not?5create?5IDirectInput?5@
  00070	e8 00 00 00 00	 call	 _CONS_Printf
  00075	83 c4 04	 add	 esp, 4

; 890  : 				lpdid2 = NULL;

  00078	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _lpdid2$[ebp], 0
$LN5@CreateDevi:

; 891  : 			}
; 892  : 		}
; 893  : 	}

  0007f	eb 0d		 jmp	 SHORT $LN3@CreateDevi
$LN2@CreateDevi:

; 894  : 	else
; 895  : 		I_Error("Could not create IDirectInput device");

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MJPBPFFC@Could?5not?5create?5IDirectInput?5d@
  00086	e8 00 00 00 00	 call	 _I_Error
  0008b	83 c4 04	 add	 esp, 4
$LN3@CreateDevi:

; 896  : 
; 897  : 	*lpDEV = lpdid1;

  0008e	8b 45 10	 mov	 eax, DWORD PTR _lpDEV$[ebp]
  00091	8b 4d f4	 mov	 ecx, DWORD PTR _lpdid1$[ebp]
  00094	89 08		 mov	 DWORD PTR [eax], ecx

; 898  : 	if (lpDEV2) // only if we requested it

  00096	83 7d 14 00	 cmp	 DWORD PTR _lpDEV2$[ebp], 0
  0009a	74 08		 je	 SHORT $LN6@CreateDevi

; 899  : 		*lpDEV2 = lpdid2;

  0009c	8b 45 14	 mov	 eax, DWORD PTR _lpDEV2$[ebp]
  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _lpdid2$[ebp]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@CreateDevi:

; 900  : }

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_CreateDevice2A ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _ShowEndTxt
_TEXT	SEGMENT
_endoomnum$ = -68					; size = 4
_data$ = -64						; size = 4
_ptext$ = -60						; size = 4
_let$ = -53						; size = 1
_bytesWritten$ = -52					; size = 4
_resizewin$ = -48					; size = 4
_backupcon$ = -44					; size = 22
_nlflag$ = -20						; size = 4
_att$ = -16						; size = 2
_j$ = -12						; size = 2
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_co$ = 8						; size = 4
_ShowEndTxt PROC					; COMDAT

; 684  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 685  : 	int i;
; 686  : 	UINT16 j, att = 0;

  00016	33 c0		 xor	 eax, eax
  00018	66 89 45 f0	 mov	 WORD PTR _att$[ebp], ax

; 687  : 	int nlflag = 1;

  0001c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _nlflag$[ebp], 1

; 688  : 	CONSOLE_SCREEN_BUFFER_INFO backupcon;
; 689  : 	COORD resizewin = {80,-1};

  00023	b8 50 00 00 00	 mov	 eax, 80			; 00000050H
  00028	66 89 45 d0	 mov	 WORD PTR _resizewin$[ebp], ax
  0002c	83 c8 ff	 or	 eax, -1
  0002f	66 89 45 d2	 mov	 WORD PTR _resizewin$[ebp+2], ax

; 690  : 	DWORD bytesWritten;
; 691  : 	CHAR let = 0;

  00033	c6 45 cb 00	 mov	 BYTE PTR _let$[ebp], 0

; 692  : 	UINT16 *ptext;
; 693  : 	LPVOID data;
; 694  : 	lumpnum_t endoomnum = W_GetNumForName("ENDOOM");

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_06BBOHFMBE@ENDOOM@
  0003c	e8 00 00 00 00	 call	 _W_GetNumForName
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 bc	 mov	 DWORD PTR _endoomnum$[ebp], eax

; 695  : 	//HANDLE ci = GetStdHandle(STD_INPUT_HANDLE);
; 696  : 
; 697  : 	/* get the lump with the text */
; 698  : 	data = ptext = W_CacheLumpNum(endoomnum, PU_CACHE);

  00047	6a 65		 push	 101			; 00000065H
  00049	8b 45 bc	 mov	 eax, DWORD PTR _endoomnum$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00052	83 c4 08	 add	 esp, 8
  00055	89 45 c4	 mov	 DWORD PTR _ptext$[ebp], eax
  00058	8b 4d c4	 mov	 ecx, DWORD PTR _ptext$[ebp]
  0005b	89 4d c0	 mov	 DWORD PTR _data$[ebp], ecx

; 699  : 
; 700  : 	backupcon.wAttributes = FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE; // Just in case

  0005e	b8 07 00 00 00	 mov	 eax, 7
  00063	66 89 45 dc	 mov	 WORD PTR _backupcon$[ebp+8], ax

; 701  : 	GetConsoleScreenBufferInfo(co, &backupcon); //Store old state

  00067	8d 45 d4	 lea	 eax, DWORD PTR _backupcon$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _co$[ebp]
  0006e	51		 push	 ecx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleScreenBufferInfo@8
  00075	90		 npad	 1

; 702  : 	resizewin.Y = backupcon.dwSize.Y;

  00076	66 8b 45 d6	 mov	 ax, WORD PTR _backupcon$[ebp+2]
  0007a	66 89 45 d2	 mov	 WORD PTR _resizewin$[ebp+2], ax

; 703  : 	if (backupcon.dwSize.X < resizewin.X)

  0007e	0f bf 45 d4	 movsx	 eax, WORD PTR _backupcon$[ebp]
  00082	0f bf 4d d0	 movsx	 ecx, WORD PTR _resizewin$[ebp]
  00086	3b c1		 cmp	 eax, ecx
  00088	7d 0f		 jge	 SHORT $LN5@ShowEndTxt

; 704  : 		SetConsoleScreenBufferSize(co, resizewin);

  0008a	8b 45 d0	 mov	 eax, DWORD PTR _resizewin$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _co$[ebp]
  00091	51		 push	 ecx
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleScreenBufferSize@8
  00098	90		 npad	 1
$LN5@ShowEndTxt:

; 705  : 
; 706  : 	for (i = 1; i <= 80*25; i++) // print 80x25 text and deal with the attributes too

  00099	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000a0	eb 09		 jmp	 SHORT $LN4@ShowEndTxt
$LN2@ShowEndTxt:
  000a2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a5	83 c0 01	 add	 eax, 1
  000a8	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@ShowEndTxt:
  000ab	81 7d f8 d0 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 2000 ; 000007d0H
  000b2	0f 8f b6 00 00
	00		 jg	 $LN3@ShowEndTxt

; 707  : 	{
; 708  : 		j = (UINT16)(*ptext >> 8); // attribute first

  000b8	8b 45 c4	 mov	 eax, DWORD PTR _ptext$[ebp]
  000bb	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000be	c1 f9 08	 sar	 ecx, 8
  000c1	66 89 4d f4	 mov	 WORD PTR _j$[ebp], cx

; 709  : 		let = (char)(*ptext & 0xff); // text senond

  000c5	8b 45 c4	 mov	 eax, DWORD PTR _ptext$[ebp]
  000c8	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000cb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d1	88 4d cb	 mov	 BYTE PTR _let$[ebp], cl

; 710  : 		if (j != att) // attribute changed?

  000d4	0f b7 45 f4	 movzx	 eax, WORD PTR _j$[ebp]
  000d8	0f b7 4d f0	 movzx	 ecx, WORD PTR _att$[ebp]
  000dc	3b c1		 cmp	 eax, ecx
  000de	74 18		 je	 SHORT $LN6@ShowEndTxt

; 711  : 		{
; 712  : 			att = j; // save current attribute

  000e0	66 8b 45 f4	 mov	 ax, WORD PTR _j$[ebp]
  000e4	66 89 45 f0	 mov	 WORD PTR _att$[ebp], ax

; 713  : 			SetConsoleTextAttribute(co, j); //set fg and bg color for buffer

  000e8	0f b7 45 f4	 movzx	 eax, WORD PTR _j$[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _co$[ebp]
  000f0	51		 push	 ecx
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleTextAttribute@8
  000f7	90		 npad	 1
$LN6@ShowEndTxt:

; 714  : 		}
; 715  : 
; 716  : 		WriteConsoleA(co, &let, 1, &bytesWritten, NULL); // now the text

  000f8	6a 00		 push	 0
  000fa	8d 45 cc	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  000fd	50		 push	 eax
  000fe	6a 01		 push	 1
  00100	8d 4d cb	 lea	 ecx, DWORD PTR _let$[ebp]
  00103	51		 push	 ecx
  00104	8b 55 08	 mov	 edx, DWORD PTR _co$[ebp]
  00107	52		 push	 edx
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleA@20
  0010e	90		 npad	 1

; 717  : 
; 718  : 		if (nlflag && !(i % 80) && backupcon.dwSize.X > resizewin.X) // do we need a nl?

  0010f	83 7d ec 00	 cmp	 DWORD PTR _nlflag$[ebp], 0
  00113	74 4b		 je	 SHORT $LN7@ShowEndTxt
  00115	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00118	99		 cdq
  00119	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0011e	f7 f9		 idiv	 ecx
  00120	85 d2		 test	 edx, edx
  00122	75 3c		 jne	 SHORT $LN7@ShowEndTxt
  00124	0f bf 45 d4	 movsx	 eax, WORD PTR _backupcon$[ebp]
  00128	0f bf 4d d0	 movsx	 ecx, WORD PTR _resizewin$[ebp]
  0012c	3b c1		 cmp	 eax, ecx
  0012e	7e 30		 jle	 SHORT $LN7@ShowEndTxt

; 719  : 		{
; 720  : 			att = backupcon.wAttributes;

  00130	66 8b 45 dc	 mov	 ax, WORD PTR _backupcon$[ebp+8]
  00134	66 89 45 f0	 mov	 WORD PTR _att$[ebp], ax

; 721  : 			SetConsoleTextAttribute(co, att); // all attributes off

  00138	0f b7 45 f0	 movzx	 eax, WORD PTR _att$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _co$[ebp]
  00140	51		 push	 ecx
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleTextAttribute@8
  00147	90		 npad	 1

; 722  : 			WriteConsoleA(co, "\n", 1, &bytesWritten, NULL); // newline to console

  00148	6a 00		 push	 0
  0014a	8d 45 cc	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  0014d	50		 push	 eax
  0014e	6a 01		 push	 1
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00155	8b 4d 08	 mov	 ecx, DWORD PTR _co$[ebp]
  00158	51		 push	 ecx
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleA@20
  0015f	90		 npad	 1
$LN7@ShowEndTxt:

; 723  : 		}
; 724  : 		ptext++;

  00160	8b 45 c4	 mov	 eax, DWORD PTR _ptext$[ebp]
  00163	83 c0 02	 add	 eax, 2
  00166	89 45 c4	 mov	 DWORD PTR _ptext$[ebp], eax

; 725  : 	}

  00169	e9 34 ff ff ff	 jmp	 $LN2@ShowEndTxt
$LN3@ShowEndTxt:

; 726  : 	SetConsoleTextAttribute(co, backupcon.wAttributes); // all attributes off

  0016e	0f b7 45 dc	 movzx	 eax, WORD PTR _backupcon$[ebp+8]
  00172	50		 push	 eax
  00173	8b 4d 08	 mov	 ecx, DWORD PTR _co$[ebp]
  00176	51		 push	 ecx
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleTextAttribute@8
  0017d	90		 npad	 1

; 727  : 	//if (nlflag)
; 728  : 	//	WriteConsoleA(co, "\n", 1, &bytesWritten, NULL);
; 729  : 
; 730  : 	getchar(); //pause!

  0017e	e8 00 00 00 00	 call	 _getchar
  00183	90		 npad	 1

; 731  : 
; 732  : 	Z_Free(data);

  00184	8b 45 c0	 mov	 eax, DWORD PTR _data$[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 _Z_Free
  0018d	83 c4 04	 add	 esp, 4

; 733  : }

  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00196	33 cd		 xor	 ecx, ebp
  00198	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
_ShowEndTxt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownTimer
_TEXT	SEGMENT
_I_ShutdownTimer PROC					; COMDAT

; 445  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 446  : 	timeEndPeriod(1);

  00009	6a 01		 push	 1
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4
  00011	90		 npad	 1

; 447  : }

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_I_ShutdownTimer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetConsoleEvents
_TEXT	SEGMENT
tv82 = -144						; size = 4
tv85 = -144						; size = 4
tv152 = -144						; size = 4
_t$ = -76						; size = 4
_input$ = -72						; size = 20
_CSBI$ = -52						; size = 22
_co$ = -28						; size = 4
_ci$ = -24						; size = 4
_ev$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_I_GetConsoleEvents PROC				; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 318  : 	event_t ev = {0,0,0,0};

  00016	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 0
  0001d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 0
  00024	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp+8], 0
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp+12], 0

; 319  : 	HANDLE ci = GetStdHandle(STD_INPUT_HANDLE);

  00032	6a f6		 push	 -10			; fffffff6H
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  0003a	89 45 e8	 mov	 DWORD PTR _ci$[ebp], eax

; 320  : 	HANDLE co = GetStdHandle(STD_OUTPUT_HANDLE);

  0003d	6a f5		 push	 -11			; fffffff5H
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00045	89 45 e4	 mov	 DWORD PTR _co$[ebp], eax
$LN2@I_GetConso:

; 321  : 	CONSOLE_SCREEN_BUFFER_INFO CSBI;
; 322  : 	INPUT_RECORD input;
; 323  : 	DWORD t;
; 324  : 
; 325  : 	while (I_ReadyConsole(ci) && ReadConsoleInput(ci, &input, 1, &t) && t)

  00048	8b 45 e8	 mov	 eax, DWORD PTR _ci$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _I_ReadyConsole
  00051	83 c4 04	 add	 esp, 4
  00054	85 c0		 test	 eax, eax
  00056	0f 84 96 01 00
	00		 je	 $LN3@I_GetConso
  0005c	8d 45 b4	 lea	 eax, DWORD PTR _t$[ebp]
  0005f	50		 push	 eax
  00060	6a 01		 push	 1
  00062	8d 4d b8	 lea	 ecx, DWORD PTR _input$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 e8	 mov	 edx, DWORD PTR _ci$[ebp]
  00069	52		 push	 edx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadConsoleInputA@16
  00070	85 c0		 test	 eax, eax
  00072	0f 84 7a 01 00
	00		 je	 $LN3@I_GetConso
  00078	83 7d b4 00	 cmp	 DWORD PTR _t$[ebp], 0
  0007c	0f 84 70 01 00
	00		 je	 $LN3@I_GetConso

; 326  : 	{
; 327  : 		ZeroMemory(&ev, sizeof(ev));

  00082	6a 10		 push	 16			; 00000010H
  00084	6a 00		 push	 0
  00086	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _memset
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 328  : 		switch (input.EventType)

  00092	0f b7 45 b8	 movzx	 eax, WORD PTR _input$[ebp]
  00096	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  0009c	83 bd 70 ff ff
	ff 01		 cmp	 DWORD PTR tv82[ebp], 1
  000a3	74 05		 je	 SHORT $LN10@I_GetConso
  000a5	e9 43 01 00 00	 jmp	 $LN4@I_GetConso
$LN10@I_GetConso:

; 329  : 		{
; 330  : 			case KEY_EVENT:
; 331  : 				if (input.Event.KeyEvent.bKeyDown)

  000aa	83 7d bc 00	 cmp	 DWORD PTR _input$[ebp+4], 0
  000ae	0f 84 04 01 00
	00		 je	 $LN11@I_GetConso

; 332  : 				{
; 333  : 					ev.type = ev_console;

  000b4	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 2

; 334  : 					entering_con_command = true;

  000bb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _entering_con_command, 1

; 335  : 					switch (input.Event.KeyEvent.wVirtualKeyCode)

  000c5	0f b7 45 c2	 movzx	 eax, WORD PTR _input$[ebp+10]
  000c9	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  000cf	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  000d5	83 e9 09	 sub	 ecx, 9
  000d8	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
  000de	83 bd 70 ff ff
	ff 12		 cmp	 DWORD PTR tv85[ebp], 18	; 00000012H
  000e5	77 30		 ja	 SHORT $LN17@I_GetConso
  000e7	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  000ed	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN29@I_GetConso[edx]
  000f4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN30@I_GetConso[eax*4]
$LN13@I_GetConso:

; 336  : 					{
; 337  : 						case VK_ESCAPE:
; 338  : 						case VK_TAB:
; 339  : 							ev.data1 = KEY_NULL;

  000fb	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 0

; 340  : 							break;

  00102	eb 23		 jmp	 SHORT $LN6@I_GetConso
$LN15@I_GetConso:

; 341  : 						case VK_SHIFT:
; 342  : 							ev.data1 = KEY_LSHIFT;

  00104	c7 45 f0 b6 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 182 ; 000000b6H

; 343  : 							break;

  0010b	eb 1a		 jmp	 SHORT $LN6@I_GetConso
$LN16@I_GetConso:

; 344  : 						case VK_RETURN:
; 345  : 							entering_con_command = false;

  0010d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _entering_con_command, 0
$LN17@I_GetConso:

; 346  : 							// Fall through.
; 347  : 						default:
; 348  : 							ev.data1 = MapVirtualKey(input.Event.KeyEvent.wVirtualKeyCode,2); // convert in to char

  00117	6a 02		 push	 2
  00119	0f b7 45 c2	 movzx	 eax, WORD PTR _input$[ebp+10]
  0011d	50		 push	 eax
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapVirtualKeyA@8
  00124	89 45 f0	 mov	 DWORD PTR _ev$[ebp+4], eax
$LN6@I_GetConso:

; 349  : 					}
; 350  : 					if (co != INVALID_HANDLE_VALUE && GetFileType(co) == FILE_TYPE_CHAR && GetConsoleMode(co, &t))

  00127	83 7d e4 ff	 cmp	 DWORD PTR _co$[ebp], -1
  0012b	0f 84 85 00 00
	00		 je	 $LN20@I_GetConso
  00131	8b 45 e4	 mov	 eax, DWORD PTR _co$[ebp]
  00134	50		 push	 eax
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileType@4
  0013b	83 f8 02	 cmp	 eax, 2
  0013e	75 76		 jne	 SHORT $LN20@I_GetConso
  00140	8d 45 b4	 lea	 eax, DWORD PTR _t$[ebp]
  00143	50		 push	 eax
  00144	8b 4d e4	 mov	 ecx, DWORD PTR _co$[ebp]
  00147	51		 push	 ecx
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleMode@8
  0014e	85 c0		 test	 eax, eax
  00150	74 64		 je	 SHORT $LN20@I_GetConso

; 351  : 					{
; 352  : 						if (ev.data1 && ev.data1 != KEY_LSHIFT && ev.data1 != KEY_RSHIFT)

  00152	83 7d f0 00	 cmp	 DWORD PTR _ev$[ebp+4], 0
  00156	74 29		 je	 SHORT $LN19@I_GetConso
  00158	81 7d f0 b6 00
	00 00		 cmp	 DWORD PTR _ev$[ebp+4], 182 ; 000000b6H
  0015f	74 20		 je	 SHORT $LN19@I_GetConso
  00161	81 7d f0 b7 00
	00 00		 cmp	 DWORD PTR _ev$[ebp+4], 183 ; 000000b7H
  00168	74 17		 je	 SHORT $LN19@I_GetConso

; 353  : 						{
; 354  : #ifdef UNICODE
; 355  : 							WriteConsole(co, &input.Event.KeyEvent.uChar.UnicodeChar, 1, &t, NULL);
; 356  : #else
; 357  : 							WriteConsole(co, &input.Event.KeyEvent.uChar.AsciiChar, 1, &t, NULL);

  0016a	6a 00		 push	 0
  0016c	8d 45 b4	 lea	 eax, DWORD PTR _t$[ebp]
  0016f	50		 push	 eax
  00170	6a 01		 push	 1
  00172	8d 4d c6	 lea	 ecx, DWORD PTR _input$[ebp+14]
  00175	51		 push	 ecx
  00176	8b 55 e4	 mov	 edx, DWORD PTR _co$[ebp]
  00179	52		 push	 edx
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleA@20
  00180	90		 npad	 1
$LN19@I_GetConso:

; 358  : #endif
; 359  : 						}
; 360  : 						if (input.Event.KeyEvent.wVirtualKeyCode == VK_BACK
; 361  : 							&& GetConsoleScreenBufferInfo(co,&CSBI))

  00181	0f b7 45 c2	 movzx	 eax, WORD PTR _input$[ebp+10]
  00185	83 f8 08	 cmp	 eax, 8
  00188	75 2c		 jne	 SHORT $LN20@I_GetConso
  0018a	8d 45 cc	 lea	 eax, DWORD PTR _CSBI$[ebp]
  0018d	50		 push	 eax
  0018e	8b 4d e4	 mov	 ecx, DWORD PTR _co$[ebp]
  00191	51		 push	 ecx
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleScreenBufferInfo@8
  00198	85 c0		 test	 eax, eax
  0019a	74 1a		 je	 SHORT $LN20@I_GetConso

; 362  : 						{
; 363  : 							WriteConsoleOutputCharacterA(co, " ",1, CSBI.dwCursorPosition, &t);

  0019c	8d 45 b4	 lea	 eax, DWORD PTR _t$[ebp]
  0019f	50		 push	 eax
  001a0	8b 4d d0	 mov	 ecx, DWORD PTR _CSBI$[ebp+4]
  001a3	51		 push	 ecx
  001a4	6a 01		 push	 1
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  001ab	8b 55 e4	 mov	 edx, DWORD PTR _co$[ebp]
  001ae	52		 push	 edx
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleOutputCharacterA@20
  001b5	90		 npad	 1
$LN20@I_GetConso:

; 364  : 						}
; 365  : 					}
; 366  : 				}

  001b6	eb 23		 jmp	 SHORT $LN8@I_GetConso
$LN11@I_GetConso:

; 367  : 				else
; 368  : 				{
; 369  : 					ev.type = ev_keyup;

  001b8	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 1

; 370  : 					switch (input.Event.KeyEvent.wVirtualKeyCode)

  001bf	0f b7 45 c2	 movzx	 eax, WORD PTR _input$[ebp+10]
  001c3	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
  001c9	83 bd 70 ff ff
	ff 10		 cmp	 DWORD PTR tv152[ebp], 16 ; 00000010H
  001d0	74 02		 je	 SHORT $LN21@I_GetConso
  001d2	eb 07		 jmp	 SHORT $LN22@I_GetConso
$LN21@I_GetConso:

; 371  : 					{
; 372  : 						case VK_SHIFT:
; 373  : 							ev.data1 = KEY_LSHIFT;

  001d4	c7 45 f0 b6 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 182 ; 000000b6H
$LN22@I_GetConso:
$LN8@I_GetConso:

; 374  : 							break;
; 375  : 						default:
; 376  : 							break;
; 377  : 					}
; 378  : 				}
; 379  : 				if (ev.data1) D_PostEvent(&ev);

  001db	83 7d f0 00	 cmp	 DWORD PTR _ev$[ebp+4], 0
  001df	74 0c		 je	 SHORT $LN23@I_GetConso
  001e1	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 _D_PostEvent
  001ea	83 c4 04	 add	 esp, 4
$LN23@I_GetConso:
$LN4@I_GetConso:

; 380  : 				break;
; 381  : 			case MOUSE_EVENT:
; 382  : 			case WINDOW_BUFFER_SIZE_EVENT:
; 383  : 			case MENU_EVENT:
; 384  : 			case FOCUS_EVENT:
; 385  : 				break;
; 386  : 		}
; 387  : 	}

  001ed	e9 56 fe ff ff	 jmp	 $LN2@I_GetConso
$LN3@I_GetConso:

; 388  : }

  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
  001f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f8	33 cd		 xor	 ecx, ebp
  001fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
  00203	90		 npad	 1
$LN30@I_GetConso:
  00204	00 00 00 00	 DD	 $LN13@I_GetConso
  00208	00 00 00 00	 DD	 $LN16@I_GetConso
  0020c	00 00 00 00	 DD	 $LN15@I_GetConso
  00210	00 00 00 00	 DD	 $LN17@I_GetConso
$LN29@I_GetConso:
  00214	00		 DB	 0
  00215	03		 DB	 3
  00216	03		 DB	 3
  00217	03		 DB	 3
  00218	01		 DB	 1
  00219	03		 DB	 3
  0021a	03		 DB	 3
  0021b	02		 DB	 2
  0021c	03		 DB	 3
  0021d	03		 DB	 3
  0021e	03		 DB	 3
  0021f	03		 DB	 3
  00220	03		 DB	 3
  00221	03		 DB	 3
  00222	03		 DB	 3
  00223	03		 DB	 3
  00224	03		 DB	 3
  00225	03		 DB	 3
  00226	00		 DB	 0
_I_GetConsoleEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ReadyConsole
_TEXT	SEGMENT
tv81 = -72						; size = 4
_gotinput$ = -4						; size = 4
_ci$ = 8						; size = 4
_I_ReadyConsole PROC					; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 308  : 	DWORD gotinput;
; 309  : 	if (ci == INVALID_HANDLE_VALUE) return FALSE;

  00009	83 7d 08 ff	 cmp	 DWORD PTR _ci$[ebp], -1
  0000d	75 04		 jne	 SHORT $LN2@I_ReadyCon
  0000f	33 c0		 xor	 eax, eax
  00011	eb 68		 jmp	 SHORT $LN1@I_ReadyCon
$LN2@I_ReadyCon:

; 310  : 	if (WaitForSingleObject(ci,0) != WAIT_OBJECT_0) return FALSE;

  00013	6a 00		 push	 0
  00015	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0001f	85 c0		 test	 eax, eax
  00021	74 04		 je	 SHORT $LN3@I_ReadyCon
  00023	33 c0		 xor	 eax, eax
  00025	eb 54		 jmp	 SHORT $LN1@I_ReadyCon
$LN3@I_ReadyCon:

; 311  : 	if (GetFileType(ci) != FILE_TYPE_CHAR) return FALSE;

  00027	8b 45 08	 mov	 eax, DWORD PTR _ci$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileType@4
  00031	83 f8 02	 cmp	 eax, 2
  00034	74 04		 je	 SHORT $LN4@I_ReadyCon
  00036	33 c0		 xor	 eax, eax
  00038	eb 41		 jmp	 SHORT $LN1@I_ReadyCon
$LN4@I_ReadyCon:

; 312  : 	if (!GetConsoleMode(ci, &gotinput)) return FALSE;

  0003a	8d 45 fc	 lea	 eax, DWORD PTR _gotinput$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00041	51		 push	 ecx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleMode@8
  00048	85 c0		 test	 eax, eax
  0004a	75 04		 jne	 SHORT $LN5@I_ReadyCon
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 2b		 jmp	 SHORT $LN1@I_ReadyCon
$LN5@I_ReadyCon:

; 313  : 	return (GetNumberOfConsoleInputEvents(ci, &gotinput) && gotinput);

  00050	8d 45 fc	 lea	 eax, DWORD PTR _gotinput$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetNumberOfConsoleInputEvents@8
  0005e	85 c0		 test	 eax, eax
  00060	74 0f		 je	 SHORT $LN7@I_ReadyCon
  00062	83 7d fc 00	 cmp	 DWORD PTR _gotinput$[ebp], 0
  00066	74 09		 je	 SHORT $LN7@I_ReadyCon
  00068	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  0006f	eb 07		 jmp	 SHORT $LN8@I_ReadyCon
$LN7@I_ReadyCon:
  00071	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN8@I_ReadyCon:
  00078	8b 45 b8	 mov	 eax, DWORD PTR tv81[ebp]
$LN1@I_ReadyCon:

; 314  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_I_ReadyConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_DetectWin9x
_TEXT	SEGMENT
tv66 = -220						; size = 4
_osvi$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
_I_DetectWin9x PROC					; COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 179  : 	OSVERSIONINFO osvi;
; 180  : 
; 181  : 	osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

  00016	c7 85 68 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _osvi$[ebp], 148 ; 00000094H

; 182  : 	GetVersionEx(&osvi);

  00020	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _osvi$[ebp]
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4
  0002d	90		 npad	 1

; 183  : 
; 184  : 	winnt = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);

  0002e	83 bd 78 ff ff
	ff 02		 cmp	 DWORD PTR _osvi$[ebp+16], 2
  00035	75 0c		 jne	 SHORT $LN3@I_DetectWi
  00037	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00041	eb 0a		 jmp	 SHORT $LN4@I_DetectWi
$LN3@I_DetectWi:
  00043	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@I_DetectWi:
  0004d	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  00053	a3 00 00 00 00	 mov	 DWORD PTR _winnt, eax

; 185  : 	// 95 or 98 what the hell
; 186  : 	win9x = true;

  00058	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _win9x, 1

; 187  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_I_DetectWin9x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownJoystick2
_TEXT	SEGMENT
_event$ = -24						; size = 16
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_ShutdownJoystick2 PROC				; COMDAT

; 2458 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2459 : 	int i;
; 2460 : 	event_t event;
; 2461 : 
; 2462 : 	lastjoy2buttons = lastjoy2hats = 0;

  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _lastjoy2hats, xmm0
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastjoy2hats
  00023	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _lastjoy2hats+4
  00029	a3 00 00 00 00	 mov	 DWORD PTR _lastjoy2buttons, eax
  0002e	89 0d 04 00 00
	00		 mov	 DWORD PTR _lastjoy2buttons+4, ecx

; 2463 : 
; 2464 : 	event.type = ev_keyup;

  00034	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1

; 2465 : 
; 2466 : 	// emulate the up of all joystick buttons
; 2467 : 	for (i = 0;i < JOYBUTTONS;i++)

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00042	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_Shutdown:
  0004d	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00051	7d 19		 jge	 SHORT $LN3@I_Shutdown

; 2468 : 	{
; 2469 : 		event.data1 = KEY_2JOY1+i;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00056	05 78 01 00 00	 add	 eax, 376		; 00000178H
  0005b	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 2470 : 		D_PostEvent(&event);

  0005e	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _D_PostEvent
  00067	83 c4 04	 add	 esp, 4

; 2471 : 	}

  0006a	eb d8		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 2472 : 
; 2473 : 	// emulate the up of all joystick hats
; 2474 : 	for (i = 0;i < JOYHATS*4;i++)

  0006c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@I_Shutdown
$LN5@I_Shutdown:
  00075	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@I_Shutdown:
  0007e	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00082	7d 19		 jge	 SHORT $LN6@I_Shutdown

; 2475 : 	{
; 2476 : 		event.data1 = KEY_2HAT1+i;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00087	05 98 01 00 00	 add	 eax, 408		; 00000198H
  0008c	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 2477 : 		D_PostEvent(&event);

  0008f	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _D_PostEvent
  00098	83 c4 04	 add	 esp, 4

; 2478 : 	}

  0009b	eb d8		 jmp	 SHORT $LN5@I_Shutdown
$LN6@I_Shutdown:

; 2479 : 
; 2480 : 	// reset joystick position
; 2481 : 	event.type = ev_joystick2;

  0009d	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR _event$[ebp], 6

; 2482 : 	for (i = 0;i < JOYAXISSET; i++)

  000a4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ab	eb 09		 jmp	 SHORT $LN10@I_Shutdown
$LN8@I_Shutdown:
  000ad	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b0	83 c0 01	 add	 eax, 1
  000b3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@I_Shutdown:
  000b6	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  000ba	7d 14		 jge	 SHORT $LN9@I_Shutdown

; 2483 : 	{
; 2484 : 		event.data1 = i;

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 2485 : 		D_PostEvent(&event);

  000c2	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _D_PostEvent
  000cb	83 c4 04	 add	 esp, 4

; 2486 : 	}

  000ce	eb dd		 jmp	 SHORT $LN8@I_Shutdown
$LN9@I_Shutdown:

; 2487 : 
; 2488 : 	if (joystick2_detected)

  000d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _joystick2_detected, 0
  000d7	74 0d		 je	 SHORT $LN14@I_Shutdown

; 2489 : 		CONS_Printf("I_ShutdownJoystick2()\n");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LPPGDECM@I_ShutdownJoystick2?$CI?$CJ?6@
  000de	e8 00 00 00 00	 call	 _CONS_Printf
  000e3	83 c4 04	 add	 esp, 4
$LN14@I_Shutdown:

; 2490 : 
; 2491 : 	for (i = 0; i > NumberofForces; i++)

  000e6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ed	eb 09		 jmp	 SHORT $LN13@I_Shutdown
$LN11@I_Shutdown:
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f2	83 c0 01	 add	 eax, 1
  000f5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@I_Shutdown:
  000f8	83 7d f8 07	 cmp	 DWORD PTR _i$[ebp], 7
  000fc	7e 3a		 jle	 SHORT $LN12@I_Shutdown

; 2492 : 	{
; 2493 : 		if (lpDIE2[i])

  000fe	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00101	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _lpDIE2[eax*4], 0
  00109	74 2b		 je	 SHORT $LN15@I_Shutdown

; 2494 : 		{
; 2495 : 			IDirectInputEffect_Release(lpDIE2[i]);

  0010b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0010e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lpDIE2[eax*4]
  00115	51		 push	 ecx
  00116	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00119	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _lpDIE2[edx*4]
  00120	8b 08		 mov	 ecx, DWORD PTR [eax]
  00122	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00125	ff d2		 call	 edx
  00127	90		 npad	 1

; 2496 : 			lpDIE2[i] = NULL;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0012b	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _lpDIE2[eax*4], 0
$LN15@I_Shutdown:

; 2497 : 		}
; 2498 : 	}

  00136	eb b7		 jmp	 SHORT $LN11@I_Shutdown
$LN12@I_Shutdown:

; 2499 : 	if (lpDIJ2)

  00138	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2, 0
  0013f	74 32		 je	 SHORT $LN16@I_Shutdown

; 2500 : 	{
; 2501 : 		IDirectInputDevice_Unacquire(lpDIJ2);

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2
  00146	50		 push	 eax
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2
  0014d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00152	ff d0		 call	 eax
  00154	90		 npad	 1

; 2502 : 		IDirectInputDevice_Release(lpDIJ2);

  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2
  0015a	50		 push	 eax
  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2
  00161	8b 11		 mov	 edx, DWORD PTR [ecx]
  00163	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00166	ff d0		 call	 eax
  00168	90		 npad	 1

; 2503 : 		lpDIJ2 = NULL;

  00169	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIJ2, 0
$LN16@I_Shutdown:

; 2504 : 	}
; 2505 : 	if (lpDIJ2A)

  00173	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2A, 0
  0017a	74 1e		 je	 SHORT $LN17@I_Shutdown

; 2506 : 	{
; 2507 : 		IDirectInputDevice2_Release(lpDIJ2A);

  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2A
  00181	50		 push	 eax
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2A
  00188	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0018d	ff d0		 call	 eax
  0018f	90		 npad	 1

; 2508 : 		lpDIJ2A = NULL;

  00190	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIJ2A, 0
$LN17@I_Shutdown:

; 2509 : 	}
; 2510 : 	joystick2_detected = false;

  0019a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _joystick2_detected, 0

; 2511 : }

  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 cd		 xor	 ecx, ebp
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c3		 ret	 0
_I_ShutdownJoystick2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownJoystick
_TEXT	SEGMENT
_event$ = -24						; size = 16
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_ShutdownJoystick PROC				; COMDAT

; 2393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2394 : 	int i;
; 2395 : 	event_t event;
; 2396 : 
; 2397 : 	lastjoybuttons = lastjoyhats = 0;

  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _lastjoyhats, xmm0
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastjoyhats
  00023	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _lastjoyhats+4
  00029	a3 00 00 00 00	 mov	 DWORD PTR _lastjoybuttons, eax
  0002e	89 0d 04 00 00
	00		 mov	 DWORD PTR _lastjoybuttons+4, ecx

; 2398 : 
; 2399 : 	event.type = ev_keyup;

  00034	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1

; 2400 : 
; 2401 : 	// emulate the up of all joystick buttons
; 2402 : 	for (i = 0;i < JOYBUTTONS;i++)

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00042	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_Shutdown:
  0004d	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00051	7d 19		 jge	 SHORT $LN3@I_Shutdown

; 2403 : 	{
; 2404 : 		event.data1 = KEY_JOY1+i;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00056	05 08 01 00 00	 add	 eax, 264		; 00000108H
  0005b	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 2405 : 		D_PostEvent(&event);

  0005e	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _D_PostEvent
  00067	83 c4 04	 add	 esp, 4

; 2406 : 	}

  0006a	eb d8		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 2407 : 
; 2408 : 	// emulate the up of all joystick hats
; 2409 : 	for (i = 0;i < JOYHATS*4;i++)

  0006c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@I_Shutdown
$LN5@I_Shutdown:
  00075	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@I_Shutdown:
  0007e	83 7d f8 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00082	7d 19		 jge	 SHORT $LN6@I_Shutdown

; 2410 : 	{
; 2411 : 		event.data1 = KEY_HAT1+i;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00087	05 28 01 00 00	 add	 eax, 296		; 00000128H
  0008c	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 2412 : 		D_PostEvent(&event);

  0008f	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _D_PostEvent
  00098	83 c4 04	 add	 esp, 4

; 2413 : 	}

  0009b	eb d8		 jmp	 SHORT $LN5@I_Shutdown
$LN6@I_Shutdown:

; 2414 : 
; 2415 : 	// reset joystick position
; 2416 : 	event.type = ev_joystick;

  0009d	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _event$[ebp], 4

; 2417 : 	for (i = 0;i < JOYAXISSET; i++)

  000a4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ab	eb 09		 jmp	 SHORT $LN10@I_Shutdown
$LN8@I_Shutdown:
  000ad	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b0	83 c0 01	 add	 eax, 1
  000b3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@I_Shutdown:
  000b6	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  000ba	7d 14		 jge	 SHORT $LN9@I_Shutdown

; 2418 : 	{
; 2419 : 		event.data1 = i;

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 2420 : 		D_PostEvent(&event);

  000c2	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _D_PostEvent
  000cb	83 c4 04	 add	 esp, 4

; 2421 : 	}

  000ce	eb dd		 jmp	 SHORT $LN8@I_Shutdown
$LN9@I_Shutdown:

; 2422 : 
; 2423 : 	if (joystick_detected)

  000d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _joystick_detected, 0
  000d7	74 0d		 je	 SHORT $LN14@I_Shutdown

; 2424 : 		CONS_Printf("I_ShutdownJoystick()\n");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EGEPHJIA@I_ShutdownJoystick?$CI?$CJ?6@
  000de	e8 00 00 00 00	 call	 _CONS_Printf
  000e3	83 c4 04	 add	 esp, 4
$LN14@I_Shutdown:

; 2425 : 
; 2426 : 	for (i = 0; i > NumberofForces; i++)

  000e6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ed	eb 09		 jmp	 SHORT $LN13@I_Shutdown
$LN11@I_Shutdown:
  000ef	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f2	83 c0 01	 add	 eax, 1
  000f5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@I_Shutdown:
  000f8	83 7d f8 07	 cmp	 DWORD PTR _i$[ebp], 7
  000fc	7e 3a		 jle	 SHORT $LN12@I_Shutdown

; 2427 : 	{
; 2428 : 		if (lpDIE[i])

  000fe	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00101	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _lpDIE[eax*4], 0
  00109	74 2b		 je	 SHORT $LN15@I_Shutdown

; 2429 : 		{
; 2430 : 			IDirectInputEffect_Release(lpDIE[i]);

  0010b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0010e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lpDIE[eax*4]
  00115	51		 push	 ecx
  00116	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00119	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _lpDIE[edx*4]
  00120	8b 08		 mov	 ecx, DWORD PTR [eax]
  00122	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00125	ff d2		 call	 edx
  00127	90		 npad	 1

; 2431 : 			lpDIE[i] = NULL;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0012b	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _lpDIE[eax*4], 0
$LN15@I_Shutdown:

; 2432 : 
; 2433 : 		}
; 2434 : 	}

  00136	eb b7		 jmp	 SHORT $LN11@I_Shutdown
$LN12@I_Shutdown:

; 2435 : 	if (lpDIJ)

  00138	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ, 0
  0013f	74 32		 je	 SHORT $LN16@I_Shutdown

; 2436 : 	{
; 2437 : 		IDirectInputDevice_Unacquire(lpDIJ);

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ
  00146	50		 push	 eax
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ
  0014d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00152	ff d0		 call	 eax
  00154	90		 npad	 1

; 2438 : 		IDirectInputDevice_Release(lpDIJ);

  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ
  0015a	50		 push	 eax
  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ
  00161	8b 11		 mov	 edx, DWORD PTR [ecx]
  00163	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00166	ff d0		 call	 eax
  00168	90		 npad	 1

; 2439 : 		lpDIJ = NULL;

  00169	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIJ, 0
$LN16@I_Shutdown:

; 2440 : 	}
; 2441 : 	if (lpDIJA)

  00173	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJA, 0
  0017a	74 1e		 je	 SHORT $LN17@I_Shutdown

; 2442 : 	{
; 2443 : 		IDirectInputDevice2_Release(lpDIJA);

  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJA
  00181	50		 push	 eax
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJA
  00188	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0018d	ff d0		 call	 eax
  0018f	90		 npad	 1

; 2444 : 		lpDIJA = NULL;

  00190	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIJA, 0
$LN17@I_Shutdown:

; 2445 : 	}
; 2446 : 	joystick_detected = false;

  0019a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _joystick_detected, 0

; 2447 : }

  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 cd		 xor	 ecx, ebp
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c3		 ret	 0
_I_ShutdownJoystick ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetKeyboardEvents
_TEXT	SEGMENT
_event$ = -548						; size = 16
_ch$ = -532						; size = 4
_hr$ = -528						; size = 4
_d$ = -524						; size = 4
_dwItems$ = -520					; size = 4
_rgdod$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_I_GetKeyboardEvents PROC				; COMDAT

; 3252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 02 00
	00		 sub	 esp, 676		; 000002a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3253 : 	static BOOL KeyboardLost = false;
; 3254 : 
; 3255 : 	// simply repeat the last pushed key every xx tics,
; 3256 : 	// make more user friendly input for Console and game Menus
; 3257 : #define KEY_REPEAT_DELAY (TICRATE/17) // TICRATE tics, repeat every 1/3 second
; 3258 : 	static LONG RepeatKeyTics = 0;
; 3259 : 	static int RepeatKeyCode;
; 3260 : 
; 3261 : 	DIDEVICEOBJECTDATA rgdod[DI_KEYBOARD_BUFFERSIZE];
; 3262 : 	DWORD dwItems, d;
; 3263 : 	HRESULT hr;
; 3264 : 	int ch;
; 3265 : 
; 3266 : 	event_t event;
; 3267 : 	ZeroMemory(&event,sizeof (event));

  00016	6a 10		 push	 16			; 00000010H
  00018	6a 00		 push	 0
  0001a	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3268 : 
; 3269 : 	if (!keyboard_started)

  00029	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _keyboard_started
  00030	85 c0		 test	 eax, eax
  00032	75 05		 jne	 SHORT $LN5@I_GetKeybo

; 3270 : 		return;

  00034	e9 2c 02 00 00	 jmp	 $LN20@I_GetKeybo
$LN5@I_GetKeybo:

; 3271 : 
; 3272 : 	if (!appActive && RepeatKeyCode) // Stop when lost focus

  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _appActive, 0
  00040	75 37		 jne	 SHORT $getBufferedData$22
  00042	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9, 0
  00049	74 2e		 je	 SHORT $getBufferedData$22

; 3273 : 	{
; 3274 : 		event.type = ev_keyup;

  0004b	c7 85 dc fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _event$[ebp], 1

; 3275 : 		event.data1 = RepeatKeyCode;

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9
  0005a	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _event$[ebp+4], eax

; 3276 : 		D_PostEvent(&event);

  00060	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _D_PostEvent
  0006c	83 c4 04	 add	 esp, 4

; 3277 : 		RepeatKeyCode = 0;

  0006f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9, 0
$getBufferedData$22:

; 3278 : 	}
; 3279 : getBufferedData:
; 3280 : 	dwItems = DI_KEYBOARD_BUFFERSIZE;

  00079	c7 85 f8 fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _dwItems$[ebp], 32 ; 00000020H

; 3281 : 	hr = IDirectInputDevice_GetDeviceData(lpDIK, sizeof (DIDEVICEOBJECTDATA), rgdod, &dwItems, 0);

  00083	6a 00		 push	 0
  00085	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _dwItems$[ebp]
  0008b	50		 push	 eax
  0008c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _rgdod$[ebp]
  00092	51		 push	 ecx
  00093	6a 10		 push	 16			; 00000010H
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIK
  0009b	52		 push	 edx
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIK
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000a6	ff d2		 call	 edx
  000a8	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 3282 : 
; 3283 : 	// If data stream was interrupted, reacquire the device and try again.
; 3284 : 	if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED)

  000ae	81 bd f0 fd ff
	ff 1e 00 07 80	 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  000b8	74 0c		 je	 SHORT $LN8@I_GetKeybo
  000ba	81 bd f0 fd ff
	ff 0c 00 07 80	 cmp	 DWORD PTR _hr$[ebp], -2147024884 ; 8007000cH
  000c4	75 33		 jne	 SHORT $LN7@I_GetKeybo
$LN8@I_GetKeybo:

; 3285 : 	{
; 3286 : 		// why it succeeds to acquire just after I don't understand.. so I set the flag BEFORE
; 3287 : 		KeyboardLost = true;

  000c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?KeyboardLost@?1??I_GetKeyboardEvents@@9@9, 1

; 3288 : 
; 3289 : 		hr = IDirectInputDevice_Acquire(lpDIK);

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIK
  000d5	50		 push	 eax
  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIK
  000dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000de	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000e1	ff d0		 call	 eax
  000e3	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 3290 : 		if (SUCCEEDED(hr))

  000e9	83 bd f0 fd ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  000f0	7c 02		 jl	 SHORT $LN9@I_GetKeybo

; 3291 : 			goto getBufferedData;

  000f2	eb 85		 jmp	 SHORT $getBufferedData$22
$LN9@I_GetKeybo:

; 3292 : 		return;

  000f4	e9 6c 01 00 00	 jmp	 $LN20@I_GetKeybo
$LN7@I_GetKeybo:

; 3293 : 	}
; 3294 : 
; 3295 : 	// we lost data, get device actual state to recover lost information
; 3296 : 	if (hr == DI_BUFFEROVERFLOW)
; 3297 : 	{
; 3298 : 		/// \note either uncomment or delete block
; 3299 : 		//I_Error("DI buffer overflow (keyboard)");
; 3300 : 		//I_RecoverKeyboardState ();
; 3301 : 
; 3302 : 		//hr = IDirectInputDevice_GetDeviceState (lpDIM, sizeof (keys), &diMouseState);
; 3303 : 	}
; 3304 : 
; 3305 : 	// We got buffered input, act on it
; 3306 : 	if (SUCCEEDED(hr))

  000f9	83 bd f0 fd ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  00100	0f 8c 5f 01 00
	00		 jl	 $LN20@I_GetKeybo

; 3307 : 	{
; 3308 : 		// if we previously lost keyboard data, recover its current state
; 3309 : 		if (KeyboardLost)

  00106	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?KeyboardLost@?1??I_GetKeyboardEvents@@9@9, 0
  0010d	74 1e		 je	 SHORT $LN12@I_GetKeybo

; 3310 : 		{
; 3311 : 			/// \bug hack simply clears the keys so we don't have the last pressed keys
; 3312 : 			/// still active.. to have to re-trigger it is not much trouble for the user.
; 3313 : 			ZeroMemory(gamekeydown, NUMKEYS);

  0010f	68 00 01 00 00	 push	 256			; 00000100H
  00114	6a 00		 push	 0
  00116	68 00 00 00 00	 push	 OFFSET _gamekeydown
  0011b	e8 00 00 00 00	 call	 _memset
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3314 : 			KeyboardLost = false;

  00123	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?KeyboardLost@?1??I_GetKeyboardEvents@@9@9, 0
$LN12@I_GetKeybo:

; 3315 : 		}
; 3316 : 
; 3317 : 		// dwItems contains number of elements read (could be 0)
; 3318 : 		for (d = 0; d < dwItems; d++)

  0012d	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _d$[ebp], 0
  00137	eb 0f		 jmp	 SHORT $LN4@I_GetKeybo
$LN2@I_GetKeybo:
  00139	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0013f	83 c0 01	 add	 eax, 1
  00142	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _d$[ebp], eax
$LN4@I_GetKeybo:
  00148	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0014e	3b 85 f8 fd ff
	ff		 cmp	 eax, DWORD PTR _dwItems$[ebp]
  00154	0f 83 8e 00 00
	00		 jae	 $LN3@I_GetKeybo

; 3319 : 		{
; 3320 : 			// dwOfs member is DIK_* value
; 3321 : 			// dwData member 0x80 bit set press down, clear is release
; 3322 : 
; 3323 : 			if (rgdod[d].dwData & 0x80)

  0015a	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00160	c1 e0 04	 shl	 eax, 4
  00163	8b 8c 05 00 fe
	ff ff		 mov	 ecx, DWORD PTR _rgdod$[ebp+eax+4]
  0016a	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00170	74 0c		 je	 SHORT $LN13@I_GetKeybo

; 3324 : 				event.type = ev_keydown;

  00172	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp], 0
  0017c	eb 0a		 jmp	 SHORT $LN14@I_GetKeybo
$LN13@I_GetKeybo:

; 3325 : 			else
; 3326 : 				event.type = ev_keyup;

  0017e	c7 85 dc fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _event$[ebp], 1
$LN14@I_GetKeybo:

; 3327 : 
; 3328 : 			ch = rgdod[d].dwOfs & 0xFF;

  00188	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0018e	c1 e0 04	 shl	 eax, 4
  00191	8b 8c 05 fc fd
	ff ff		 mov	 ecx, DWORD PTR _rgdod$[ebp+eax]
  00198	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0019e	89 8d ec fd ff
	ff		 mov	 DWORD PTR _ch$[ebp], ecx

; 3329 : 			if (ASCIINames[ch])

  001a4	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _ch$[ebp]
  001aa	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ASCIINames[eax]
  001b1	85 c9		 test	 ecx, ecx
  001b3	74 15		 je	 SHORT $LN15@I_GetKeybo

; 3330 : 				event.data1 = ASCIINames[ch];

  001b5	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _ch$[ebp]
  001bb	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ASCIINames[eax]
  001c2	89 8d e0 fd ff
	ff		 mov	 DWORD PTR _event$[ebp+4], ecx
  001c8	eb 0a		 jmp	 SHORT $LN16@I_GetKeybo
$LN15@I_GetKeybo:

; 3331 : 			else
; 3332 : 				event.data1 = 0x80;

  001ca	c7 85 e0 fd ff
	ff 80 00 00 00	 mov	 DWORD PTR _event$[ebp+4], 128 ; 00000080H
$LN16@I_GetKeybo:

; 3333 : 
; 3334 : 			D_PostEvent(&event);

  001d4	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _D_PostEvent
  001e0	83 c4 04	 add	 esp, 4

; 3335 : 		}

  001e3	e9 51 ff ff ff	 jmp	 $LN2@I_GetKeybo
$LN3@I_GetKeybo:

; 3336 : 
; 3337 : 		// Key Repeat
; 3338 : 		if (dwItems)

  001e8	83 bd f8 fd ff
	ff 00		 cmp	 DWORD PTR _dwItems$[ebp], 0
  001ef	74 2d		 je	 SHORT $LN17@I_GetKeybo

; 3339 : 		{
; 3340 : 			// new key events, so stop repeating key
; 3341 : 			RepeatKeyCode = 0;

  001f1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9, 0

; 3342 : 			// delay is tripled for first repeating key
; 3343 : 			RepeatKeyTics = hacktics + (KEY_REPEAT_DELAY*2);

  001fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _hacktics
  00200	83 c0 04	 add	 eax, 4
  00203	a3 00 00 00 00	 mov	 DWORD PTR ?RepeatKeyTics@?1??I_GetKeyboardEvents@@9@9, eax

; 3344 : 			if (event.type == ev_keydown) // use the last event!

  00208	83 bd dc fd ff
	ff 00		 cmp	 DWORD PTR _event$[ebp], 0
  0020f	75 0b		 jne	 SHORT $LN19@I_GetKeybo

; 3345 : 				RepeatKeyCode = event.data1;

  00211	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _event$[ebp+4]
  00217	a3 00 00 00 00	 mov	 DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9, eax
$LN19@I_GetKeybo:

; 3346 : 		}

  0021c	eb 47		 jmp	 SHORT $LN20@I_GetKeybo
$LN17@I_GetKeybo:

; 3347 : 		else
; 3348 : 		{
; 3349 : 			// no new keys, repeat last pushed key after some time
; 3350 : 			if (RepeatKeyCode && hacktics - RepeatKeyTics > KEY_REPEAT_DELAY)

  0021e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9, 0
  00225	74 3e		 je	 SHORT $LN20@I_GetKeybo
  00227	a1 00 00 00 00	 mov	 eax, DWORD PTR _hacktics
  0022c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?RepeatKeyTics@?1??I_GetKeyboardEvents@@9@9
  00232	83 f8 02	 cmp	 eax, 2
  00235	7e 2e		 jle	 SHORT $LN20@I_GetKeybo

; 3351 : 			{
; 3352 : 				event.type = ev_keydown;

  00237	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp], 0

; 3353 : 				event.data1 = RepeatKeyCode;

  00241	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RepeatKeyCode@?1??I_GetKeyboardEvents@@9@9
  00246	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _event$[ebp+4], eax

; 3354 : 				D_PostEvent(&event);

  0024c	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 _D_PostEvent
  00258	83 c4 04	 add	 esp, 4

; 3355 : 
; 3356 : 				RepeatKeyTics = hacktics;

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hacktics
  00260	a3 00 00 00 00	 mov	 DWORD PTR ?RepeatKeyTics@?1??I_GetKeyboardEvents@@9@9, eax
$LN20@I_GetKeybo:

; 3357 : 			}
; 3358 : 		}
; 3359 : 	}
; 3360 : }

  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5b		 pop	 ebx
  00268	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	c3		 ret	 0
_I_GetKeyboardEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownKeyboard
_TEXT	SEGMENT
_I_ShutdownKeyboard PROC				; COMDAT

; 3231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3232 : 	if (!keyboard_started)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _keyboard_started
  00010	85 c0		 test	 eax, eax
  00012	75 02		 jne	 SHORT $LN2@I_Shutdown

; 3233 : 		return;

  00014	eb 4f		 jmp	 SHORT $LN1@I_Shutdown
$LN2@I_Shutdown:

; 3234 : 
; 3235 : 	CONS_Printf("I_ShutdownKeyboard()\n");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NMBKBOKM@I_ShutdownKeyboard?$CI?$CJ?6@
  0001b	e8 00 00 00 00	 call	 _CONS_Printf
  00020	83 c4 04	 add	 esp, 4

; 3236 : 
; 3237 : 	if (lpDIK)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIK, 0
  0002a	74 32		 je	 SHORT $LN3@I_Shutdown

; 3238 : 	{
; 3239 : 		IDirectInputDevice_Unacquire(lpDIK);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIK
  00031	50		 push	 eax
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIK
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0003d	ff d0		 call	 eax
  0003f	90		 npad	 1

; 3240 : 		IDirectInputDevice_Release(lpDIK);

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIK
  00045	50		 push	 eax
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIK
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00051	ff d0		 call	 eax
  00053	90		 npad	 1

; 3241 : 		lpDIK = NULL;

  00054	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lpDIK, 0
$LN3@I_Shutdown:

; 3242 : 	}
; 3243 : 
; 3244 : 	keyboard_started = false;

  0005e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _keyboard_started, 0
$LN1@I_Shutdown:

; 3245 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_I_ShutdownKeyboard ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_DoStartupMouse
_TEXT	SEGMENT
_dip$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_I_DoStartupMouse PROC					; COMDAT

; 1172 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1173 : 	DIPROPDWORD dip;
; 1174 : 
; 1175 : 	// mouse detection may be skipped by setting usemouse false
; 1176 : 	if (!cv_usemouse.value || M_CheckParm("-nomouse"))

  00013	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_usemouse+20, 0
  0001a	74 11		 je	 SHORT $LN3@I_DoStartu
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_08GPADOFHN@?9nomouse@
  00021	e8 00 00 00 00	 call	 _M_CheckParm
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 0f		 je	 SHORT $LN2@I_DoStartu
$LN3@I_DoStartu:

; 1177 : 	{
; 1178 : 		mouse_enabled = false;

  0002d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mouse_enabled, 0

; 1179 : 		return;

  00037	e9 36 01 00 00	 jmp	 $LN1@I_DoStartu
$LN2@I_DoStartu:

; 1180 : 	}
; 1181 : 
; 1182 : 	if (nodinput)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  00043	74 2f		 je	 SHORT $LN4@I_DoStartu

; 1183 : 	{
; 1184 : 		CONS_Printf("\tMouse will not use DirectInput.\n");

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MPELICFG@?7Mouse?5will?5not?5use?5DirectInput@
  0004a	e8 00 00 00 00	 call	 _CONS_Printf
  0004f	83 c4 04	 add	 esp, 4

; 1185 : 		// System mouse input will be initiated by VID_SetMode
; 1186 : 		I_AddExitFunc(I_ShutdownMouse);

  00052	68 00 00 00 00	 push	 OFFSET _I_ShutdownMouse
  00057	e8 00 00 00 00	 call	 _I_AddExitFunc
  0005c	83 c4 04	 add	 esp, 4

; 1187 : 
; 1188 : 		MSHWheelMessage = RegisterWindowMessage(MSH_MOUSEWHEEL);

  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterWindowMessageA@4
  0006a	a3 00 00 00 00	 mov	 DWORD PTR _MSHWheelMessage, eax

; 1189 : 	}

  0006f	e9 f4 00 00 00	 jmp	 $LN8@I_DoStartu
$LN4@I_DoStartu:

; 1190 : 	else if (!lpDIM) // acquire the mouse only once

  00074	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIM, 0
  0007b	0f 85 e7 00 00
	00		 jne	 $LN8@I_DoStartu

; 1191 : 	{
; 1192 : 		CreateDevice2A(lpDI, &GUID_SysMouse, &lpDIM, NULL);

  00081	6a 00		 push	 0
  00083	68 00 00 00 00	 push	 OFFSET _lpDIM
  00088	68 00 00 00 00	 push	 OFFSET _GUID_SysMouse
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _CreateDevice2A
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 1193 : 
; 1194 : 		if (lpDIM)

  0009b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIM, 0
  000a2	0f 84 b3 00 00
	00		 je	 $LN7@I_DoStartu

; 1195 : 		{
; 1196 : 			if (FAILED(IDirectInputDevice_SetDataFormat(lpDIM, &c_dfDIMouse)))

  000a8	68 00 00 00 00	 push	 OFFSET _c_dfDIMouse
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIM
  000b2	50		 push	 eax
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIM
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000be	ff d0		 call	 eax
  000c0	85 c0		 test	 eax, eax
  000c2	7d 0d		 jge	 SHORT $LN9@I_DoStartu

; 1197 : 				I_Error("Couldn't set mouse data format");

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MNDEIMNB@Couldn?8t?5set?5mouse?5data?5format@
  000c9	e8 00 00 00 00	 call	 _I_Error
  000ce	83 c4 04	 add	 esp, 4
$LN9@I_DoStartu:

; 1198 : 
; 1199 : 			// create buffer for buffered data
; 1200 : 			dip.diph.dwSize = sizeof (dip);

  000d1	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _dip$[ebp], 20 ; 00000014H

; 1201 : 			dip.diph.dwHeaderSize = sizeof (dip.diph);

  000d8	c7 45 ec 10 00
	00 00		 mov	 DWORD PTR _dip$[ebp+4], 16 ; 00000010H

; 1202 : 			dip.diph.dwObj = 0;

  000df	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dip$[ebp+8], 0

; 1203 : 			dip.diph.dwHow = DIPH_DEVICE;

  000e6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dip$[ebp+12], 0

; 1204 : 			dip.dwData = DI_MOUSE_BUFFERSIZE;

  000ed	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _dip$[ebp+16], 16 ; 00000010H

; 1205 : 			if (FAILED(IDirectInputDevice_SetProperty(lpDIM, DIPROP_BUFFERSIZE, &dip.diph)))

  000f4	8d 45 e8	 lea	 eax, DWORD PTR _dip$[ebp]
  000f7	50		 push	 eax
  000f8	6a 01		 push	 1
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIM
  00100	51		 push	 ecx
  00101	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIM
  00107	8b 02		 mov	 eax, DWORD PTR [edx]
  00109	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0010c	ff d1		 call	 ecx
  0010e	85 c0		 test	 eax, eax
  00110	7d 0d		 jge	 SHORT $LN10@I_DoStartu

; 1206 : 				I_Error("Couldn't set mouse buffer size");

  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IGFGLPOP@Couldn?8t?5set?5mouse?5buffer?5size@
  00117	e8 00 00 00 00	 call	 _I_Error
  0011c	83 c4 04	 add	 esp, 4
$LN10@I_DoStartu:

; 1207 : 
; 1208 : 			if (FAILED(IDirectInputDevice_SetCooperativeLevel(lpDIM, hWndMain,

  0011f	6a 05		 push	 5
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00126	50		 push	 eax
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIM
  0012d	51		 push	 ecx
  0012e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIM
  00134	8b 02		 mov	 eax, DWORD PTR [edx]
  00136	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00139	ff d1		 call	 ecx
  0013b	85 c0		 test	 eax, eax
  0013d	7d 0d		 jge	 SHORT $LN11@I_DoStartu

; 1209 : 				DISCL_EXCLUSIVE|DISCL_FOREGROUND)))
; 1210 : 			{
; 1211 : 				I_Error("Couldn't set mouse coop level");

  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MCGALMJM@Couldn?8t?5set?5mouse?5coop?5level@
  00144	e8 00 00 00 00	 call	 _I_Error
  00149	83 c4 04	 add	 esp, 4
$LN11@I_DoStartu:

; 1212 : 			}
; 1213 : 			I_AddExitFunc(I_ShutdownMouse);

  0014c	68 00 00 00 00	 push	 OFFSET _I_ShutdownMouse
  00151	e8 00 00 00 00	 call	 _I_AddExitFunc
  00156	83 c4 04	 add	 esp, 4

; 1214 : 		}

  00159	eb 0d		 jmp	 SHORT $LN8@I_DoStartu
$LN7@I_DoStartu:

; 1215 : 		else
; 1216 : 			I_Error("Couldn't create mouse input");

  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NLCOHANC@Couldn?8t?5create?5mouse?5input@
  00160	e8 00 00 00 00	 call	 _I_Error
  00165	83 c4 04	 add	 esp, 4
$LN8@I_DoStartu:

; 1217 : 	}
; 1218 : 
; 1219 : 	// if re-enabled while running, just set mouse_enabled true again,
; 1220 : 	// do not acquire the mouse more than once
; 1221 : 	mouse_enabled = true;

  00168	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _mouse_enabled, 1
$LN1@I_DoStartu:

; 1222 : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
_I_DoStartupMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_RestartSysMouse
_TEXT	SEGMENT
_I_RestartSysMouse PROC					; COMDAT

; 1119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1120 : 	if (nodinput)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  00010	74 0c		 je	 SHORT $LN2@I_RestartS

; 1121 : 	{
; 1122 : 		I_ShutdownSysMouse();

  00012	e8 00 00 00 00	 call	 _I_ShutdownSysMouse
  00017	90		 npad	 1

; 1123 : 		I_DoStartupSysMouse();

  00018	e8 00 00 00 00	 call	 _I_DoStartupSysMouse
  0001d	90		 npad	 1
$LN2@I_RestartS:

; 1124 : 	}
; 1125 : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_I_RestartSysMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShowLastError
_TEXT	SEGMENT
_LE$ = -8						; size = 4
_lpMsgBuf$ = -4						; size = 4
_MB$ = 8						; size = 4
_I_ShowLastError PROC					; COMDAT

; 790  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 791  : 	LPSTR lpMsgBuf = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpMsgBuf$[ebp], 0

; 792  : 	const DWORD LE = GetLastError();

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00016	89 45 f8	 mov	 DWORD PTR _LE$[ebp], eax

; 793  : 
; 794  : 	if (LE == 0xdeadbeef) return; // Not a real error

  00019	81 7d f8 ef be
	ad de		 cmp	 DWORD PTR _LE$[ebp], -559038737 ; deadbeefH
  00020	75 02		 jne	 SHORT $LN2@I_ShowLast
  00022	eb 70		 jmp	 SHORT $LN1@I_ShowLast
$LN2@I_ShowLast:

; 795  : 
; 796  : 	FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,

  00024	6a 00		 push	 0
  00026	6a 00		 push	 0
  00028	8d 45 fc	 lea	 eax, DWORD PTR _lpMsgBuf$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 04 00 00	 push	 1024			; 00000400H
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _LE$[ebp]
  00034	51		 push	 ecx
  00035	6a 00		 push	 0
  00037	68 00 13 00 00	 push	 4864			; 00001300H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28
  00042	90		 npad	 1

; 797  : 		NULL, LE, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
; 798  : 		(LPVOID)&lpMsgBuf, 0, NULL);
; 799  : 
; 800  : 	if (!lpMsgBuf)

  00043	83 7d fc 00	 cmp	 DWORD PTR _lpMsgBuf$[ebp], 0
  00047	75 0f		 jne	 SHORT $LN3@I_ShowLast

; 801  : 	{
; 802  : 		CONS_Printf("GetLastError: Unknown\n");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFODMEHN@GetLastError?3?5Unknown?6@
  0004e	e8 00 00 00 00	 call	 _CONS_Printf
  00053	83 c4 04	 add	 esp, 4

; 803  : 		return;

  00056	eb 3c		 jmp	 SHORT $LN1@I_ShowLast
$LN3@I_ShowLast:

; 804  : 	}
; 805  : 
; 806  : 	// Display the string
; 807  : 	if (MB && LE) MessageBoxA(NULL, lpMsgBuf, "GetLastError", MB_OK|MB_ICONINFORMATION);

  00058	83 7d 08 00	 cmp	 DWORD PTR _MB$[ebp], 0
  0005c	74 1a		 je	 SHORT $LN4@I_ShowLast
  0005e	83 7d f8 00	 cmp	 DWORD PTR _LE$[ebp], 0
  00062	74 14		 je	 SHORT $LN4@I_ShowLast
  00064	6a 40		 push	 64			; 00000040H
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HICKNDGL@GetLastError@
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _lpMsgBuf$[ebp]
  0006e	50		 push	 eax
  0006f	6a 00		 push	 0
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00077	90		 npad	 1
$LN4@I_ShowLast:

; 808  : 
; 809  : 	// put it in text console and log if any
; 810  : 	I_OutputMsg("GetLastError: %s", lpMsgBuf);

  00078	8b 45 fc	 mov	 eax, DWORD PTR _lpMsgBuf$[ebp]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CDGKGPGK@GetLastError?3?5?$CFs@
  00081	e8 00 00 00 00	 call	 _I_OutputMsg
  00086	83 c4 08	 add	 esp, 8

; 811  : 
; 812  : 	// Free the buffer.
; 813  : 	LocalFree(lpMsgBuf);

  00089	8b 45 fc	 mov	 eax, DWORD PTR _lpMsgBuf$[ebp]
  0008c	50		 push	 eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4
  00093	90		 npad	 1
$LN1@I_ShowLast:

; 814  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_I_ShowLastError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_EndProfile
_TEXT	SEGMENT
tv80 = -84						; size = 8
_ret$ = -12						; size = 4
_CurrTime$ = -8						; size = 8
_I_EndProfile PROC					; COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 216  : 	LARGE_INTEGER CurrTime;
; 217  : 	DWORD ret;
; 218  : 	if (!QueryPerformanceCounter (&CurrTime))

  00009	8d 45 f8	 lea	 eax, DWORD PTR _CurrTime$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00013	85 c0		 test	 eax, eax
  00015	75 0d		 jne	 SHORT $LN2@I_EndProfi

; 219  : 		I_Error("I_EndProfile failed");

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@EEFIPHAL@I_EndProfile?5failed@
  0001c	e8 00 00 00 00	 call	 _I_Error
  00021	83 c4 04	 add	 esp, 4
$LN2@I_EndProfi:

; 220  : 	if (CurrTime.QuadPart - ProfileCount.QuadPart > (LONGLONG)0xFFFFFFFFUL)

  00024	8b 45 f8	 mov	 eax, DWORD PTR _CurrTime$[ebp]
  00027	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ProfileCount
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _CurrTime$[ebp+4]
  00030	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR _ProfileCount+4
  00036	89 45 ac	 mov	 DWORD PTR tv80[ebp], eax
  00039	89 4d b0	 mov	 DWORD PTR tv80[ebp+4], ecx
  0003c	83 7d b0 00	 cmp	 DWORD PTR tv80[ebp+4], 0
  00040	7c 15		 jl	 SHORT $LN3@I_EndProfi
  00042	7f 06		 jg	 SHORT $LN5@I_EndProfi
  00044	83 7d ac ff	 cmp	 DWORD PTR tv80[ebp], -1
  00048	76 0d		 jbe	 SHORT $LN3@I_EndProfi
$LN5@I_EndProfi:

; 221  : 		I_Error("I_EndProfile overflow");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EFGNEMMJ@I_EndProfile?5overflow@
  0004f	e8 00 00 00 00	 call	 _I_Error
  00054	83 c4 04	 add	 esp, 4
$LN3@I_EndProfi:

; 222  : 	ret = (DWORD)(CurrTime.QuadPart - ProfileCount.QuadPart);

  00057	8b 45 f8	 mov	 eax, DWORD PTR _CurrTime$[ebp]
  0005a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ProfileCount
  00060	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 223  : 	// we can call I_EndProfile() several time, I_BeginProfile() need be called just once
; 224  : 	ProfileCount = CurrTime;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _CurrTime$[ebp]
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _CurrTime$[ebp+4]
  00069	a3 00 00 00 00	 mov	 DWORD PTR _ProfileCount, eax
  0006e	89 0d 04 00 00
	00		 mov	 DWORD PTR _ProfileCount+4, ecx

; 225  : 
; 226  : 	return ret;

  00074	8b 45 f4	 mov	 eax, DWORD PTR _ret$[ebp]

; 227  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_I_EndProfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_BeginProfile
_TEXT	SEGMENT
_I_BeginProfile PROC					; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 208  : 	if (!QueryPerformanceCounter(&ProfileCount))

  00009	68 00 00 00 00	 push	 OFFSET _ProfileCount
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00014	85 c0		 test	 eax, eax
  00016	75 0d		 jne	 SHORT $LN2@I_BeginPro

; 209  : 		I_Error("I_BeginProfile failed"); // can't profile without the high res timer

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@ICIDLEJE@I_BeginProfile?5failed@
  0001d	e8 00 00 00 00	 call	 _I_Error
  00022	83 c4 04	 add	 esp, 4
$LN2@I_BeginPro:

; 210  : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_I_BeginProfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _LoadDirectInput
_TEXT	SEGMENT
_LoadDirectInput PROC					; COMDAT

; 3367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3368 : 	// load dinput.dll
; 3369 : 	DInputDLL = LoadLibraryA("DINPUT.DLL");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HKAJIFBE@DINPUT?4DLL@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00014	a3 00 00 00 00	 mov	 DWORD PTR _DInputDLL, eax

; 3370 : 	if (DInputDLL == NULL)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DInputDLL, 0
  00020	75 04		 jne	 SHORT $LN2@LoadDirect

; 3371 : 		return false;

  00022	33 c0		 xor	 eax, eax
  00024	eb 28		 jmp	 SHORT $LN1@LoadDirect
$LN2@LoadDirect:

; 3372 : 	pfnDirectInputCreateA = (DICreateA)GetProcAddress(DInputDLL, "DirectInputCreateA");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BGJEDEPJ@DirectInputCreateA@
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _DInputDLL
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	a3 00 00 00 00	 mov	 DWORD PTR _pfnDirectInputCreateA, eax

; 3373 : 	if (pfnDirectInputCreateA == NULL)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnDirectInputCreateA, 0
  00043	75 04		 jne	 SHORT $LN3@LoadDirect

; 3374 : 		return false;

  00045	33 c0		 xor	 eax, eax
  00047	eb 05		 jmp	 SHORT $LN1@LoadDirect
$LN3@LoadDirect:

; 3375 : 	return true;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN1@LoadDirect:

; 3376 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_LoadDirectInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetSysMouseEvents
_TEXT	SEGMENT
_c_pos$ = -40						; size = 8
_ymickeys$ = -32					; size = 4
_xmickeys$ = -28					; size = 4
_event$ = -24						; size = 16
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mouse_state$ = 8					; size = 4
_I_GetSysMouseEvents PROC				; COMDAT

; 1128 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1129 : 	UINT i;
; 1130 : 	event_t event;
; 1131 : 	int xmickeys = 0, ymickeys = 0;

  00013	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _xmickeys$[ebp], 0
  0001a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ymickeys$[ebp], 0

; 1132 : 	POINT c_pos;
; 1133 : 
; 1134 : 	for (i = 0; i < MAX_MOUSE_BTNS; i++)

  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00028	eb 09		 jmp	 SHORT $LN4@I_GetSysMo
$LN2@I_GetSysMo:
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_GetSysMo:
  00033	83 7d f8 05	 cmp	 DWORD PTR _i$[ebp], 5
  00037	0f 83 83 00 00
	00		 jae	 $LN3@I_GetSysMo

; 1135 : 	{
; 1136 : 		// check if button pressed
; 1137 : 		if ((mouse_state & (1 << i)) && !(old_mouse_state & (1 << i)))

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00045	d3 e0		 shl	 eax, cl
  00047	23 45 08	 and	 eax, DWORD PTR _mouse_state$[ebp]
  0004a	74 30		 je	 SHORT $LN5@I_GetSysMo
  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00054	d3 e0		 shl	 eax, cl
  00056	23 05 00 00 00
	00		 and	 eax, DWORD PTR _old_mouse_state
  0005c	75 1e		 jne	 SHORT $LN5@I_GetSysMo

; 1138 : 		{
; 1139 : 			event.type = ev_keydown;

  0005e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _event$[ebp], 0

; 1140 : 			event.data1 = KEY_MOUSE1 + i;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00068	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0006d	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 1141 : 			D_PostEvent(&event);

  00070	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _D_PostEvent
  00079	83 c4 04	 add	 esp, 4
$LN5@I_GetSysMo:

; 1142 : 		}
; 1143 : 		// check if button released
; 1144 : 		if (!(mouse_state & (1 << i)) && (old_mouse_state & (1 << i)))

  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00084	d3 e0		 shl	 eax, cl
  00086	23 45 08	 and	 eax, DWORD PTR _mouse_state$[ebp]
  00089	75 30		 jne	 SHORT $LN6@I_GetSysMo
  0008b	b8 01 00 00 00	 mov	 eax, 1
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00093	d3 e0		 shl	 eax, cl
  00095	23 05 00 00 00
	00		 and	 eax, DWORD PTR _old_mouse_state
  0009b	74 1e		 je	 SHORT $LN6@I_GetSysMo

; 1145 : 		{
; 1146 : 			event.type = ev_keyup;

  0009d	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1

; 1147 : 			event.data1 = KEY_MOUSE1 + i;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a7	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000ac	89 45 ec	 mov	 DWORD PTR _event$[ebp+4], eax

; 1148 : 			D_PostEvent(&event);

  000af	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _D_PostEvent
  000b8	83 c4 04	 add	 esp, 4
$LN6@I_GetSysMo:

; 1149 : 		}
; 1150 : 	}

  000bb	e9 6a ff ff ff	 jmp	 $LN2@I_GetSysMo
$LN3@I_GetSysMo:

; 1151 : 	old_mouse_state = mouse_state;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _mouse_state$[ebp]
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _old_mouse_state, eax

; 1152 : 
; 1153 : 	// proceed mouse movements
; 1154 : 	GetCursorPos(&c_pos);

  000c8	8d 45 d8	 lea	 eax, DWORD PTR _c_pos$[ebp]
  000cb	50		 push	 eax
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  000d2	90		 npad	 1

; 1155 : 	xmickeys = c_pos.x - center_x;

  000d3	8b 45 d8	 mov	 eax, DWORD PTR _c_pos$[ebp]
  000d6	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _center_x
  000dc	89 45 e4	 mov	 DWORD PTR _xmickeys$[ebp], eax

; 1156 : 	ymickeys = c_pos.y - center_y;

  000df	8b 45 dc	 mov	 eax, DWORD PTR _c_pos$[ebp+4]
  000e2	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _center_y
  000e8	89 45 e0	 mov	 DWORD PTR _ymickeys$[ebp], eax

; 1157 : 
; 1158 : 	if (xmickeys || ymickeys)

  000eb	83 7d e4 00	 cmp	 DWORD PTR _xmickeys$[ebp], 0
  000ef	75 06		 jne	 SHORT $LN8@I_GetSysMo
  000f1	83 7d e0 00	 cmp	 DWORD PTR _ymickeys$[ebp], 0
  000f5	74 3c		 je	 SHORT $LN7@I_GetSysMo
$LN8@I_GetSysMo:

; 1159 : 	{
; 1160 : 		event.type  = ev_mouse;

  000f7	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _event$[ebp], 3

; 1161 : 		event.data1 = 0;

  000fe	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 0

; 1162 : 		event.data2 = xmickeys;

  00105	8b 45 e4	 mov	 eax, DWORD PTR _xmickeys$[ebp]
  00108	89 45 f0	 mov	 DWORD PTR _event$[ebp+8], eax

; 1163 : 		event.data3 = -ymickeys;

  0010b	8b 45 e0	 mov	 eax, DWORD PTR _ymickeys$[ebp]
  0010e	f7 d8		 neg	 eax
  00110	89 45 f4	 mov	 DWORD PTR _event$[ebp+12], eax

; 1164 : 		D_PostEvent(&event);

  00113	8d 45 e8	 lea	 eax, DWORD PTR _event$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _D_PostEvent
  0011c	83 c4 04	 add	 esp, 4

; 1165 : 		SetCursorPos(center_x, center_y);

  0011f	a1 00 00 00 00	 mov	 eax, DWORD PTR _center_y
  00124	50		 push	 eax
  00125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _center_x
  0012b	51		 push	 ecx
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursorPos@8
  00132	90		 npad	 1
$LN7@I_GetSysMo:

; 1166 : 	}
; 1167 : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00139	33 cd		 xor	 ecx, ebp
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
_I_GetSysMouseEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_RegisterSysCommands
_TEXT	SEGMENT
_I_RegisterSysCommands PROC				; COMDAT

; 3654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3655 : 	GetAffinityFuncs();

  00009	e8 00 00 00 00	 call	 _GetAffinityFuncs
  0000e	90		 npad	 1

; 3656 : 	CV_RegisterVar(&cv_cpuaffinity);

  0000f	68 00 00 00 00	 push	 OFFSET _cv_cpuaffinity
  00014	e8 00 00 00 00	 call	 _CV_RegisterVar
  00019	83 c4 04	 add	 esp, 4

; 3657 : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_I_RegisterSysCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_PutEnv
_TEXT	SEGMENT
_variable$ = 8						; size = 4
_I_PutEnv PROC						; COMDAT

; 3571 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3572 : 	return putenv(variable);

  00009	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _putenv
  00012	83 c4 04	 add	 esp, 4

; 3573 : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_I_PutEnv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetEnv
_TEXT	SEGMENT
_name$ = 8						; size = 4
_I_GetEnv PROC						; COMDAT

; 3566 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3567 : 	return getenv(name);

  00009	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _getenv
  00012	83 c4 04	 add	 esp, 4

; 3568 : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_I_GetEnv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetMouseEvents
_TEXT	SEGMENT
_k$1 = -308						; size = 4
_j$2 = -304						; size = 4
_i$3 = -300						; size = 4
_ymickeys$ = -296					; size = 4
_xmickeys$ = -292					; size = 4
_event$ = -288						; size = 16
_hr$ = -272						; size = 4
_d$ = -268						; size = 4
_dwItems$ = -264					; size = 4
_rgdod$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_I_GetMouseEvents PROC					; COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1259 : 	DIDEVICEOBJECTDATA rgdod[DI_MOUSE_BUFFERSIZE];
; 1260 : 	DWORD dwItems, d;
; 1261 : 	HRESULT hr;
; 1262 : 
; 1263 : 	event_t event;
; 1264 : 	int xmickeys, ymickeys;
; 1265 : 
; 1266 : 	if (mouse2filehandle != INVALID_HANDLE_VALUE)

  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mouse2filehandle, -1
  0001d	0f 84 2a 01 00
	00		 je	 $LN13@I_GetMouse

; 1267 : 	{
; 1268 : 		//mouse movement
; 1269 : 		static UINT8 lastbuttons2 = 0;
; 1270 : 
; 1271 : 		I_PoolMouse2();

  00023	e8 00 00 00 00	 call	 _I_PoolMouse2
  00028	90		 npad	 1

; 1272 : 		// post key event for buttons
; 1273 : 		if (handlermouse2buttons != lastbuttons2)

  00029	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?lastbuttons2@?2??I_GetMouseEvents@@9@9
  00030	39 05 00 00 00
	00		 cmp	 DWORD PTR _handlermouse2buttons, eax
  00036	0f 84 ac 00 00
	00		 je	 $LN3@I_GetMouse

; 1274 : 		{
; 1275 : 			int i, j = 1, k;

  0003c	c7 85 d0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$2[ebp], 1

; 1276 : 			k = handlermouse2buttons ^ lastbuttons2; // only changed bit to 1

  00046	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?lastbuttons2@?2??I_GetMouseEvents@@9@9
  0004d	33 05 00 00 00
	00		 xor	 eax, DWORD PTR _handlermouse2buttons
  00053	89 85 cc fe ff
	ff		 mov	 DWORD PTR _k$1[ebp], eax

; 1277 : 			lastbuttons2 = (UINT8)handlermouse2buttons;

  00059	a0 00 00 00 00	 mov	 al, BYTE PTR _handlermouse2buttons
  0005e	a2 00 00 00 00	 mov	 BYTE PTR ?lastbuttons2@?2??I_GetMouseEvents@@9@9, al

; 1278 : 
; 1279 : 			for (i = 0; i < MOUSEBUTTONS; i++, j <<= 1)

  00063	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$3[ebp], 0
  0006d	eb 1d		 jmp	 SHORT $LN4@I_GetMouse
$LN2@I_GetMouse:
  0006f	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _i$3[ebp], eax
  0007e	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$2[ebp]
  00084	d1 e1		 shl	 ecx, 1
  00086	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _j$2[ebp], ecx
$LN4@I_GetMouse:
  0008c	83 bd d4 fe ff
	ff 08		 cmp	 DWORD PTR _i$3[ebp], 8
  00093	7d 53		 jge	 SHORT $LN3@I_GetMouse

; 1280 : 				if (k & j)

  00095	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _k$1[ebp]
  0009b	23 85 d0 fe ff
	ff		 and	 eax, DWORD PTR _j$2[ebp]
  000a1	74 43		 je	 SHORT $LN10@I_GetMouse

; 1281 : 				{
; 1282 : 					if (handlermouse2buttons & j)

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _handlermouse2buttons
  000a8	23 85 d0 fe ff
	ff		 and	 eax, DWORD PTR _j$2[ebp]
  000ae	74 0c		 je	 SHORT $LN11@I_GetMouse

; 1283 : 						event.type = ev_keydown;

  000b0	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp], 0
  000ba	eb 0a		 jmp	 SHORT $LN12@I_GetMouse
$LN11@I_GetMouse:

; 1284 : 					else
; 1285 : 						event.type = ev_keyup;

  000bc	c7 85 e0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _event$[ebp], 1
$LN12@I_GetMouse:

; 1286 : 					event.data1 = KEY_2MOUSE1 + i;

  000c6	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  000cc	05 70 01 00 00	 add	 eax, 368		; 00000170H
  000d1	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _event$[ebp+4], eax

; 1287 : 					D_PostEvent(&event);

  000d7	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _D_PostEvent
  000e3	83 c4 04	 add	 esp, 4
$LN10@I_GetMouse:

; 1288 : 				}

  000e6	eb 87		 jmp	 SHORT $LN2@I_GetMouse
$LN3@I_GetMouse:

; 1289 : 		}
; 1290 : 
; 1291 : 		if (handlermouse2x || handlermouse2y)

  000e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _handlermouse2x, 0
  000ef	75 09		 jne	 SHORT $LN14@I_GetMouse
  000f1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _handlermouse2y, 0
  000f8	74 53		 je	 SHORT $LN13@I_GetMouse
$LN14@I_GetMouse:

; 1292 : 		{
; 1293 : 			event.type = ev_mouse2;

  000fa	c7 85 e0 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR _event$[ebp], 5

; 1294 : 			event.data1 = 0;

  00104	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp+4], 0

; 1295 : 			event.data2 = handlermouse2x<<1;

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR _handlermouse2x
  00113	d1 e0		 shl	 eax, 1
  00115	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _event$[ebp+8], eax

; 1296 : 			event.data3 = -handlermouse2y<<1;

  0011b	a1 00 00 00 00	 mov	 eax, DWORD PTR _handlermouse2y
  00120	f7 d8		 neg	 eax
  00122	d1 e0		 shl	 eax, 1
  00124	89 85 ec fe ff
	ff		 mov	 DWORD PTR _event$[ebp+12], eax

; 1297 : 			handlermouse2x = 0;

  0012a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _handlermouse2x, 0

; 1298 : 			handlermouse2y = 0;

  00134	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _handlermouse2y, 0

; 1299 : 
; 1300 : 			D_PostEvent(&event);

  0013e	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _D_PostEvent
  0014a	83 c4 04	 add	 esp, 4
$LN13@I_GetMouse:

; 1301 : 		}
; 1302 : 	}
; 1303 : 
; 1304 : 	if (!mouse_enabled || nodinput)

  0014d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mouse_enabled, 0
  00154	74 09		 je	 SHORT $LN16@I_GetMouse
  00156	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  0015d	74 05		 je	 SHORT $getBufferedData$35
$LN16@I_GetMouse:

; 1305 : 		return;

  0015f	e9 53 02 00 00	 jmp	 $LN32@I_GetMouse
$getBufferedData$35:

; 1306 : 
; 1307 : getBufferedData:
; 1308 : 	dwItems = DI_MOUSE_BUFFERSIZE;

  00164	c7 85 f8 fe ff
	ff 10 00 00 00	 mov	 DWORD PTR _dwItems$[ebp], 16 ; 00000010H

; 1309 : 	hr = IDirectInputDevice_GetDeviceData(lpDIM, sizeof (DIDEVICEOBJECTDATA), rgdod, &dwItems, 0);

  0016e	6a 00		 push	 0
  00170	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _dwItems$[ebp]
  00176	50		 push	 eax
  00177	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _rgdod$[ebp]
  0017d	51		 push	 ecx
  0017e	6a 10		 push	 16			; 00000010H
  00180	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIM
  00186	52		 push	 edx
  00187	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIM
  0018c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018e	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00191	ff d2		 call	 edx
  00193	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 1310 : 
; 1311 : 	// If data stream was interrupted, reacquire the device and try again.
; 1312 : 	if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED)

  00199	81 bd f0 fe ff
	ff 1e 00 07 80	 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  001a3	74 0c		 je	 SHORT $LN18@I_GetMouse
  001a5	81 bd f0 fe ff
	ff 0c 00 07 80	 cmp	 DWORD PTR _hr$[ebp], -2147024884 ; 8007000cH
  001af	75 24		 jne	 SHORT $LN19@I_GetMouse
$LN18@I_GetMouse:

; 1313 : 	{
; 1314 : 		hr = IDirectInputDevice_Acquire(lpDIM);

  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIM
  001b6	50		 push	 eax
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIM
  001bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bf	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001c2	ff d0		 call	 eax
  001c4	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _hr$[ebp], eax

; 1315 : 		if (SUCCEEDED(hr))

  001ca	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  001d1	7c 02		 jl	 SHORT $LN19@I_GetMouse

; 1316 : 			goto getBufferedData;

  001d3	eb 8f		 jmp	 SHORT $getBufferedData$35
$LN19@I_GetMouse:

; 1317 : 	}
; 1318 : 
; 1319 : 	// We got buffered input, act on it
; 1320 : 	if (SUCCEEDED(hr))

  001d5	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _hr$[ebp], 0
  001dc	0f 8c d5 01 00
	00		 jl	 $LN32@I_GetMouse

; 1321 : 	{
; 1322 : 		xmickeys = ymickeys = 0;

  001e2	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ymickeys$[ebp], 0
  001ec	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _ymickeys$[ebp]
  001f2	89 85 dc fe ff
	ff		 mov	 DWORD PTR _xmickeys$[ebp], eax

; 1323 : 
; 1324 : 		// dwItems contains number of elements read (could be 0)
; 1325 : 		for (d = 0; d < dwItems; d++)

  001f8	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _d$[ebp], 0
  00202	eb 0f		 jmp	 SHORT $LN7@I_GetMouse
$LN5@I_GetMouse:
  00204	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0020a	83 c0 01	 add	 eax, 1
  0020d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _d$[ebp], eax
$LN7@I_GetMouse:
  00213	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00219	3b 85 f8 fe ff
	ff		 cmp	 eax, DWORD PTR _dwItems$[ebp]
  0021f	0f 83 43 01 00
	00		 jae	 $LN6@I_GetMouse

; 1326 : 		{
; 1327 : 			if (rgdod[d].dwOfs >= DIMOFS_BUTTON0 &&

  00225	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0022b	c1 e0 04	 shl	 eax, 4
  0022e	83 bc 05 fc fe
	ff ff 0c	 cmp	 DWORD PTR _rgdod$[ebp+eax], 12 ; 0000000cH
  00236	72 71		 jb	 SHORT $LN21@I_GetMouse
  00238	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0023e	c1 e0 04	 shl	 eax, 4
  00241	83 bc 05 fc fe
	ff ff 14	 cmp	 DWORD PTR _rgdod$[ebp+eax], 20 ; 00000014H
  00249	73 5e		 jae	 SHORT $LN21@I_GetMouse

; 1328 : 				rgdod[d].dwOfs <  DIMOFS_BUTTON0 + MOUSEBUTTONS)
; 1329 : 			{
; 1330 : 				if (rgdod[d].dwData & 0x80) // Button down

  0024b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00251	c1 e0 04	 shl	 eax, 4
  00254	8b 8c 05 00 ff
	ff ff		 mov	 ecx, DWORD PTR _rgdod$[ebp+eax+4]
  0025b	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00261	74 0c		 je	 SHORT $LN23@I_GetMouse

; 1331 : 					event.type = ev_keydown;

  00263	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp], 0
  0026d	eb 0a		 jmp	 SHORT $LN24@I_GetMouse
$LN23@I_GetMouse:

; 1332 : 				else
; 1333 : 					event.type = ev_keyup; // Button up

  0026f	c7 85 e0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _event$[ebp], 1
$LN24@I_GetMouse:

; 1334 : 
; 1335 : 				event.data1 = rgdod[d].dwOfs - DIMOFS_BUTTON0 + KEY_MOUSE1;

  00279	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  0027f	c1 e0 04	 shl	 eax, 4
  00282	8b 8c 05 fc fe
	ff ff		 mov	 ecx, DWORD PTR _rgdod$[ebp+eax]
  00289	81 c1 f4 00 00
	00		 add	 ecx, 244		; 000000f4H
  0028f	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _event$[ebp+4], ecx

; 1336 : 				D_PostEvent(&event);

  00295	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 _D_PostEvent
  002a1	83 c4 04	 add	 esp, 4

; 1337 : 			}

  002a4	e9 ba 00 00 00	 jmp	 $LN29@I_GetMouse
$LN21@I_GetMouse:

; 1338 : 			else if (rgdod[d].dwOfs == DIMOFS_X)

  002a9	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  002af	c1 e0 04	 shl	 eax, 4
  002b2	83 bc 05 fc fe
	ff ff 00	 cmp	 DWORD PTR _rgdod$[ebp+eax], 0
  002ba	75 21		 jne	 SHORT $LN25@I_GetMouse

; 1339 : 				xmickeys += rgdod[d].dwData;

  002bc	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  002c2	c1 e0 04	 shl	 eax, 4
  002c5	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _xmickeys$[ebp]
  002cb	03 8c 05 00 ff
	ff ff		 add	 ecx, DWORD PTR _rgdod$[ebp+eax+4]
  002d2	89 8d dc fe ff
	ff		 mov	 DWORD PTR _xmickeys$[ebp], ecx
  002d8	e9 86 00 00 00	 jmp	 $LN29@I_GetMouse
$LN25@I_GetMouse:

; 1340 : 			else if (rgdod[d].dwOfs == DIMOFS_Y)

  002dd	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  002e3	c1 e0 04	 shl	 eax, 4
  002e6	83 bc 05 fc fe
	ff ff 04	 cmp	 DWORD PTR _rgdod$[ebp+eax], 4
  002ee	75 1e		 jne	 SHORT $LN27@I_GetMouse

; 1341 : 				ymickeys += rgdod[d].dwData;

  002f0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  002f6	c1 e0 04	 shl	 eax, 4
  002f9	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _ymickeys$[ebp]
  002ff	03 8c 05 00 ff
	ff ff		 add	 ecx, DWORD PTR _rgdod$[ebp+eax+4]
  00306	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _ymickeys$[ebp], ecx
  0030c	eb 55		 jmp	 SHORT $LN29@I_GetMouse
$LN27@I_GetMouse:

; 1342 : 
; 1343 : 			else if (rgdod[d].dwOfs == DIMOFS_Z)

  0030e	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00314	c1 e0 04	 shl	 eax, 4
  00317	83 bc 05 fc fe
	ff ff 08	 cmp	 DWORD PTR _rgdod$[ebp+eax], 8
  0031f	75 42		 jne	 SHORT $LN29@I_GetMouse

; 1344 : 			{
; 1345 : 				// z-axes the wheel
; 1346 : 				if ((int)rgdod[d].dwData > 0)

  00321	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _d$[ebp]
  00327	c1 e0 04	 shl	 eax, 4
  0032a	83 bc 05 00 ff
	ff ff 00	 cmp	 DWORD PTR _rgdod$[ebp+eax+4], 0
  00332	7e 0c		 jle	 SHORT $LN30@I_GetMouse

; 1347 : 					event.data1 = KEY_MOUSEWHEELUP;

  00334	c7 85 e4 fe ff
	ff e0 01 00 00	 mov	 DWORD PTR _event$[ebp+4], 480 ; 000001e0H
  0033e	eb 0a		 jmp	 SHORT $LN31@I_GetMouse
$LN30@I_GetMouse:

; 1348 : 				else
; 1349 : 					event.data1 = KEY_MOUSEWHEELDOWN;

  00340	c7 85 e4 fe ff
	ff e1 01 00 00	 mov	 DWORD PTR _event$[ebp+4], 481 ; 000001e1H
$LN31@I_GetMouse:

; 1350 : 				event.type = ev_keydown;

  0034a	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp], 0

; 1351 : 				D_PostEvent(&event);

  00354	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 _D_PostEvent
  00360	83 c4 04	 add	 esp, 4
$LN29@I_GetMouse:

; 1352 : 			}
; 1353 : 
; 1354 : 		}

  00363	e9 9c fe ff ff	 jmp	 $LN5@I_GetMouse
$LN6@I_GetMouse:

; 1355 : 
; 1356 : 		if (xmickeys || ymickeys)

  00368	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _xmickeys$[ebp], 0
  0036f	75 09		 jne	 SHORT $LN33@I_GetMouse
  00371	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _ymickeys$[ebp], 0
  00378	74 3d		 je	 SHORT $LN32@I_GetMouse
$LN33@I_GetMouse:

; 1357 : 		{
; 1358 : 			event.type = ev_mouse;

  0037a	c7 85 e0 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _event$[ebp], 3

; 1359 : 			event.data1 = 0;

  00384	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _event$[ebp+4], 0

; 1360 : 			event.data2 = xmickeys;

  0038e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _xmickeys$[ebp]
  00394	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _event$[ebp+8], eax

; 1361 : 			event.data3 = -ymickeys;

  0039a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _ymickeys$[ebp]
  003a0	f7 d8		 neg	 eax
  003a2	89 85 ec fe ff
	ff		 mov	 DWORD PTR _event$[ebp+12], eax

; 1362 : 			D_PostEvent(&event);

  003a8	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _event$[ebp]
  003ae	50		 push	 eax
  003af	e8 00 00 00 00	 call	 _D_PostEvent
  003b4	83 c4 04	 add	 esp, 4
$LN32@I_GetMouse:

; 1363 : 		}
; 1364 : 	}
; 1365 : }

  003b7	5f		 pop	 edi
  003b8	5e		 pop	 esi
  003b9	5b		 pop	 ebx
  003ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bd	33 cd		 xor	 ecx, ebp
  003bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c4	8b e5		 mov	 esp, ebp
  003c6	5d		 pop	 ebp
  003c7	c3		 ret	 0
_I_GetMouseEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetJoystick2Events
_TEXT	SEGMENT
tv500 = -228						; size = 8
tv510 = -228						; size = 8
tv545 = -228						; size = 8
tv555 = -228						; size = 8
_newhats$1 = -156					; size = 8
_j$2 = -148						; size = 8
_newbuttons$3 = -140					; size = 8
_j$4 = -132						; size = 8
_event$ = -124						; size = 16
_joyhats$ = -108					; size = 8
_joybuttons$ = -100					; size = 8
_i$ = -92						; size = 4
_js$ = -88						; size = 80
_hr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_GetJoystick2Events PROC				; COMDAT

; 2762 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2763 : 	HRESULT hr;
; 2764 : 	DIJOYSTATE js; // DirectInput joystick state
; 2765 : 	int i;
; 2766 : 	UINT64 joybuttons = 0;

  00016	0f 57 c0	 xorps	 xmm0, xmm0
  00019	66 0f 13 45 9c	 movlpd	 QWORD PTR _joybuttons$[ebp], xmm0

; 2767 : 	UINT64 joyhats = 0;

  0001e	0f 57 c0	 xorps	 xmm0, xmm0
  00021	66 0f 13 45 94	 movlpd	 QWORD PTR _joyhats$[ebp], xmm0

; 2768 : 	event_t event;
; 2769 : 
; 2770 : 	if (!lpDIJ2)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2, 0
  0002d	75 05		 jne	 SHORT $LN17@I_GetJoyst

; 2771 : 		return;

  0002f	e9 7a 07 00 00	 jmp	 $LN1@I_GetJoyst
$LN17@I_GetJoyst:
$LN2@I_GetJoyst:

; 2772 : 
; 2773 : 	// if input is lost then acquire and keep trying
; 2774 : 	for (;;)
; 2775 : 	{
; 2776 : 		// poll the joystick to read the current state
; 2777 : 		// if the device doesn't require polling, this function returns almost instantly
; 2778 : 		if (lpDIJ2A)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2A, 0
  0003b	74 44		 je	 SHORT $LN22@I_GetJoyst

; 2779 : 		{
; 2780 : 			hr = IDirectInputDevice2_Poll(lpDIJ2A);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2A
  00042	50		 push	 eax
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2A
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0004e	ff d0		 call	 eax
  00050	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2781 : 			if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED)

  00053	81 7d f8 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  0005a	74 09		 je	 SHORT $LN21@I_GetJoyst
  0005c	81 7d f8 0c 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024884 ; 8007000cH
  00063	75 04		 jne	 SHORT $LN19@I_GetJoyst
$LN21@I_GetJoyst:

; 2782 : 				goto acquire;

  00065	eb 67		 jmp	 SHORT $acquire$96
  00067	eb 18		 jmp	 SHORT $LN22@I_GetJoyst
$LN19@I_GetJoyst:

; 2783 : 			else if (FAILED(hr))

  00069	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006d	7d 12		 jge	 SHORT $LN22@I_GetJoyst

; 2784 : 			{
; 2785 : 				CONS_Printf("I_GetJoystick2Events(): Poll FAILED\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DNBGLDEG@I_GetJoystick2Events?$CI?$CJ?3?5Poll?5FA@
  00074	e8 00 00 00 00	 call	 _CONS_Printf
  00079	83 c4 04	 add	 esp, 4

; 2786 : 				return;

  0007c	e9 2d 07 00 00	 jmp	 $LN1@I_GetJoyst
$LN22@I_GetJoyst:

; 2787 : 			}
; 2788 : 		}
; 2789 : 
; 2790 : 		// get the input's device state, and put the state in dims
; 2791 : 		hr = IDirectInputDevice_GetDeviceState(lpDIJ2, sizeof (DIJOYSTATE), &js);

  00081	8d 45 a8	 lea	 eax, DWORD PTR _js$[ebp]
  00084	50		 push	 eax
  00085	6a 50		 push	 80			; 00000050H
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2
  0008d	51		 push	 ecx
  0008e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIJ2
  00094	8b 02		 mov	 eax, DWORD PTR [edx]
  00096	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00099	ff d1		 call	 ecx
  0009b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2792 : 
; 2793 : 		if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED)

  0009e	81 7d f8 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  000a5	74 09		 je	 SHORT $LN25@I_GetJoyst
  000a7	81 7d f8 0c 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024884 ; 8007000cH
  000ae	75 04		 jne	 SHORT $LN23@I_GetJoyst
$LN25@I_GetJoyst:

; 2794 : 		{
; 2795 : 			// DirectInput is telling us that the input stream has
; 2796 : 			// been interrupted.  We aren't tracking any state
; 2797 : 			// between polls, so we don't have any special reset
; 2798 : 			// that needs to be done.  We just re-acquire and
; 2799 : 			// try again.
; 2800 : 			goto acquire;

  000b0	eb 1c		 jmp	 SHORT $acquire$96

; 2801 : 		}

  000b2	eb 18		 jmp	 SHORT $LN26@I_GetJoyst
$LN23@I_GetJoyst:

; 2802 : 		else if (FAILED(hr))

  000b4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7d 12		 jge	 SHORT $LN26@I_GetJoyst

; 2803 : 		{
; 2804 : 			CONS_Printf("I_GetJoystickEvents2(): GetDeviceState FAILED\n");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BMFKANEO@I_GetJoystickEvents2?$CI?$CJ?3?5GetDevi@
  000bf	e8 00 00 00 00	 call	 _CONS_Printf
  000c4	83 c4 04	 add	 esp, 4

; 2805 : 			return;

  000c7	e9 e2 06 00 00	 jmp	 $LN1@I_GetJoyst
$LN26@I_GetJoyst:

; 2806 : 		}
; 2807 : 
; 2808 : 		break;

  000cc	eb 21		 jmp	 SHORT $LN3@I_GetJoyst
$acquire$96:

; 2809 : acquire:
; 2810 : 		if (FAILED(IDirectInputDevice_Acquire(lpDIJ2)))

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2
  000d3	50		 push	 eax
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2
  000da	8b 11		 mov	 edx, DWORD PTR [ecx]
  000dc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000df	ff d0		 call	 eax
  000e1	85 c0		 test	 eax, eax
  000e3	7d 05		 jge	 SHORT $LN27@I_GetJoyst

; 2811 : 			return;

  000e5	e9 c4 06 00 00	 jmp	 $LN1@I_GetJoyst
$LN27@I_GetJoyst:

; 2812 : 	}

  000ea	e9 45 ff ff ff	 jmp	 $LN2@I_GetJoyst
$LN3@I_GetJoyst:

; 2813 : 
; 2814 : 	// look for as many buttons as g_input code supports, we don't use the others
; 2815 : 	for (i = JOYBUTTONS_MIN - 1; i >= 0; i--)

  000ef	c7 45 a4 1f 00
	00 00		 mov	 DWORD PTR _i$[ebp], 31	; 0000001fH
  000f6	eb 09		 jmp	 SHORT $LN7@I_GetJoyst
$LN5@I_GetJoyst:
  000f8	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  000fb	83 e8 01	 sub	 eax, 1
  000fe	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@I_GetJoyst:
  00101	83 7d a4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00105	7c 30		 jl	 SHORT $LN6@I_GetJoyst

; 2816 : 	{
; 2817 : 		joybuttons <<= 1;

  00107	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  0010a	8b 55 a0	 mov	 edx, DWORD PTR _joybuttons$[ebp+4]
  0010d	b1 01		 mov	 cl, 1
  0010f	e8 00 00 00 00	 call	 __allshl
  00114	89 45 9c	 mov	 DWORD PTR _joybuttons$[ebp], eax
  00117	89 55 a0	 mov	 DWORD PTR _joybuttons$[ebp+4], edx

; 2818 : 		if (js.rgbButtons[i])

  0011a	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	0f b6 4c 05 d8	 movzx	 ecx, BYTE PTR _js$[ebp+eax+48]
  00122	85 c9		 test	 ecx, ecx
  00124	74 0f		 je	 SHORT $LN28@I_GetJoyst

; 2819 : 			joybuttons |= 1;

  00126	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  00129	83 c8 01	 or	 eax, 1
  0012c	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  0012f	89 45 9c	 mov	 DWORD PTR _joybuttons$[ebp], eax
  00132	89 4d a0	 mov	 DWORD PTR _joybuttons$[ebp+4], ecx
$LN28@I_GetJoyst:

; 2820 : 	}

  00135	eb c1		 jmp	 SHORT $LN5@I_GetJoyst
$LN6@I_GetJoyst:

; 2821 : 
; 2822 : 	for (i = JOYHATS_MIN -1; i >=0; i--)

  00137	c7 45 a4 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
  0013e	eb 09		 jmp	 SHORT $LN10@I_GetJoyst
$LN8@I_GetJoyst:
  00140	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00143	83 e8 01	 sub	 eax, 1
  00146	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@I_GetJoyst:
  00149	83 7d a4 00	 cmp	 DWORD PTR _i$[ebp], 0
  0014d	0f 8c 3a 01 00
	00		 jl	 $LN9@I_GetJoyst

; 2823 : 	{
; 2824 : 		if (js.rgdwPOV[i] != 0xffff && js.rgdwPOV[i] != 0xffffffff)

  00153	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00156	81 7c 85 c8 ff
	ff 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 65535 ; 0000ffffH
  0015e	0f 84 24 01 00
	00		 je	 $LN36@I_GetJoyst
  00164	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00167	83 7c 85 c8 ff	 cmp	 DWORD PTR _js$[ebp+eax*4+32], -1
  0016c	0f 84 16 01 00
	00		 je	 $LN36@I_GetJoyst

; 2825 : 		{
; 2826 : 			if     (js.rgdwPOV[i] > 270 * DI_DEGREES || js.rgdwPOV[i] <  90 * DI_DEGREES)

  00172	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00175	81 7c 85 c8 78
	69 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 27000 ; 00006978H
  0017d	77 0d		 ja	 SHORT $LN32@I_GetJoyst
  0017f	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00182	81 7c 85 c8 28
	23 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 9000 ; 00002328H
  0018a	73 2b		 jae	 SHORT $LN30@I_GetJoyst
$LN32@I_GetJoyst:

; 2827 : 				joyhats |= (UINT64)1<<(0 + 4*(UINT64)i); // UP

  0018c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0018f	99		 cdq
  00190	6a 00		 push	 0
  00192	6a 04		 push	 4
  00194	52		 push	 edx
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 __allmul
  0019b	8b c8		 mov	 ecx, eax
  0019d	b8 01 00 00 00	 mov	 eax, 1
  001a2	33 d2		 xor	 edx, edx
  001a4	e8 00 00 00 00	 call	 __allshl
  001a9	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  001ac	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  001af	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  001b2	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
  001b5	eb 46		 jmp	 SHORT $LN33@I_GetJoyst
$LN30@I_GetJoyst:

; 2828 : 			else if (js.rgdwPOV[i] >  90 * DI_DEGREES && js.rgdwPOV[i] < 270 * DI_DEGREES)

  001b7	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001ba	81 7c 85 c8 28
	23 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 9000 ; 00002328H
  001c2	76 39		 jbe	 SHORT $LN33@I_GetJoyst
  001c4	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001c7	81 7c 85 c8 78
	69 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 27000 ; 00006978H
  001cf	73 2c		 jae	 SHORT $LN33@I_GetJoyst

; 2829 : 				joyhats |= (UINT64)1<<(1 + 4*(UINT64)i); // DOWN

  001d1	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001d4	99		 cdq
  001d5	6a 00		 push	 0
  001d7	6a 04		 push	 4
  001d9	52		 push	 edx
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 __allmul
  001e0	8b c8		 mov	 ecx, eax
  001e2	83 c1 01	 add	 ecx, 1
  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	33 d2		 xor	 edx, edx
  001ec	e8 00 00 00 00	 call	 __allshl
  001f1	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  001f4	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  001f7	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  001fa	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
$LN33@I_GetJoyst:

; 2830 : 			if     (js.rgdwPOV[i] >   0 * DI_DEGREES && js.rgdwPOV[i] < 180 * DI_DEGREES)

  001fd	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00200	83 7c 85 c8 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 0
  00205	76 3b		 jbe	 SHORT $LN34@I_GetJoyst
  00207	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0020a	81 7c 85 c8 50
	46 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 18000 ; 00004650H
  00212	73 2e		 jae	 SHORT $LN34@I_GetJoyst

; 2831 : 				joyhats |= (UINT64)1<<(3 + 4*(UINT64)i); // LEFT

  00214	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00217	99		 cdq
  00218	6a 00		 push	 0
  0021a	6a 04		 push	 4
  0021c	52		 push	 edx
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 __allmul
  00223	8b c8		 mov	 ecx, eax
  00225	83 c1 03	 add	 ecx, 3
  00228	b8 01 00 00 00	 mov	 eax, 1
  0022d	33 d2		 xor	 edx, edx
  0022f	e8 00 00 00 00	 call	 __allshl
  00234	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  00237	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  0023a	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  0023d	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
  00240	eb 46		 jmp	 SHORT $LN36@I_GetJoyst
$LN34@I_GetJoyst:

; 2832 : 			else if (js.rgdwPOV[i] > 180 * DI_DEGREES && js.rgdwPOV[i] < 360 * DI_DEGREES)

  00242	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00245	81 7c 85 c8 50
	46 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 18000 ; 00004650H
  0024d	76 39		 jbe	 SHORT $LN36@I_GetJoyst
  0024f	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00252	81 7c 85 c8 a0
	8c 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 36000 ; 00008ca0H
  0025a	73 2c		 jae	 SHORT $LN36@I_GetJoyst

; 2833 : 				joyhats |= (UINT64)1<<(2 + 4*(UINT64)i); // RIGHT

  0025c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0025f	99		 cdq
  00260	6a 00		 push	 0
  00262	6a 04		 push	 4
  00264	52		 push	 edx
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 __allmul
  0026b	8b c8		 mov	 ecx, eax
  0026d	83 c1 02	 add	 ecx, 2
  00270	b8 01 00 00 00	 mov	 eax, 1
  00275	33 d2		 xor	 edx, edx
  00277	e8 00 00 00 00	 call	 __allshl
  0027c	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  0027f	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  00282	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  00285	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
$LN36@I_GetJoyst:

; 2834 : 		}
; 2835 : 	}

  00288	e9 b3 fe ff ff	 jmp	 $LN8@I_GetJoyst
$LN9@I_GetJoyst:

; 2836 : 
; 2837 : 	if (joybuttons != lastjoy2buttons)

  0028d	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  00290	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lastjoy2buttons
  00296	75 0f		 jne	 SHORT $LN94@I_GetJoyst
  00298	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  0029b	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _lastjoy2buttons+4
  002a1	0f 84 01 01 00
	00		 je	 $LN12@I_GetJoyst
$LN94@I_GetJoyst:

; 2838 : 	{
; 2839 : 		UINT64 j = 1; // keep only bits that changed since last time

  002a7	33 c0		 xor	 eax, eax
  002a9	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$4[ebp], 1
  002b3	89 45 80	 mov	 DWORD PTR _j$4[ebp+4], eax

; 2840 : 		UINT64 newbuttons = joybuttons ^ lastjoy2buttons;

  002b6	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  002b9	33 05 00 00 00
	00		 xor	 eax, DWORD PTR _lastjoy2buttons
  002bf	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  002c2	33 0d 04 00 00
	00		 xor	 ecx, DWORD PTR _lastjoy2buttons+4
  002c8	89 85 74 ff ff
	ff		 mov	 DWORD PTR _newbuttons$3[ebp], eax
  002ce	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _newbuttons$3[ebp+4], ecx

; 2841 : 		lastjoy2buttons = joybuttons;

  002d4	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  002d7	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  002da	a3 00 00 00 00	 mov	 DWORD PTR _lastjoy2buttons, eax
  002df	89 0d 04 00 00
	00		 mov	 DWORD PTR _lastjoy2buttons+4, ecx

; 2842 : 
; 2843 : 		for (i = 0; i < JOYBUTTONS && i < JOYBUTTONS_MAX; i++, j <<= 1)

  002e5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002ec	eb 22		 jmp	 SHORT $LN13@I_GetJoyst
$LN11@I_GetJoyst:
  002ee	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  002f1	83 c0 01	 add	 eax, 1
  002f4	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
  002f7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  002fd	8b 55 80	 mov	 edx, DWORD PTR _j$4[ebp+4]
  00300	b1 01		 mov	 cl, 1
  00302	e8 00 00 00 00	 call	 __allshl
  00307	89 85 7c ff ff
	ff		 mov	 DWORD PTR _j$4[ebp], eax
  0030d	89 55 80	 mov	 DWORD PTR _j$4[ebp+4], edx
$LN13@I_GetJoyst:
  00310	83 7d a4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00314	0f 8d 8e 00 00
	00		 jge	 $LN12@I_GetJoyst
  0031a	83 7d a4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0031e	0f 8d 84 00 00
	00		 jge	 $LN12@I_GetJoyst

; 2844 : 		{
; 2845 : 			if (newbuttons & j) // button changed state?

  00324	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _newbuttons$3[ebp]
  0032a	23 85 7c ff ff
	ff		 and	 eax, DWORD PTR _j$4[ebp]
  00330	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _newbuttons$3[ebp+4]
  00336	23 4d 80	 and	 ecx, DWORD PTR _j$4[ebp+4]
  00339	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv500[ebp], eax
  0033f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv500[ebp+4], ecx
  00345	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv500[ebp]
  0034b	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv500[ebp+4]
  00351	74 50		 je	 SHORT $LN38@I_GetJoyst

; 2846 : 			{
; 2847 : 				if (joybuttons & j)

  00353	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  00356	23 85 7c ff ff
	ff		 and	 eax, DWORD PTR _j$4[ebp]
  0035c	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  0035f	23 4d 80	 and	 ecx, DWORD PTR _j$4[ebp+4]
  00362	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv510[ebp], eax
  00368	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv510[ebp+4], ecx
  0036e	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv510[ebp]
  00374	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv510[ebp+4]
  0037a	74 09		 je	 SHORT $LN39@I_GetJoyst

; 2848 : 					event.type = ev_keydown;

  0037c	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _event$[ebp], 0
  00383	eb 07		 jmp	 SHORT $LN40@I_GetJoyst
$LN39@I_GetJoyst:

; 2849 : 				else
; 2850 : 					event.type = ev_keyup;

  00385	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1
$LN40@I_GetJoyst:

; 2851 : 				event.data1 = KEY_2JOY1 + i;

  0038c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0038f	05 78 01 00 00	 add	 eax, 376		; 00000178H
  00394	89 45 88	 mov	 DWORD PTR _event$[ebp+4], eax

; 2852 : 				D_PostEvent(&event);

  00397	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  0039a	50		 push	 eax
  0039b	e8 00 00 00 00	 call	 _D_PostEvent
  003a0	83 c4 04	 add	 esp, 4
$LN38@I_GetJoyst:

; 2853 : 			}
; 2854 : 		}

  003a3	e9 46 ff ff ff	 jmp	 $LN11@I_GetJoyst
$LN12@I_GetJoyst:

; 2855 : 	}
; 2856 : 
; 2857 : 	if (joyhats != lastjoy2hats)

  003a8	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  003ab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lastjoy2hats
  003b1	75 0f		 jne	 SHORT $LN95@I_GetJoyst
  003b3	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  003b6	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _lastjoy2hats+4
  003bc	0f 84 10 01 00
	00		 je	 $LN15@I_GetJoyst
$LN95@I_GetJoyst:

; 2858 : 	{
; 2859 : 		UINT64 j = 1; // keep only bits that changed since last time

  003c2	33 c0		 xor	 eax, eax
  003c4	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$2[ebp], 1
  003ce	89 85 70 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp+4], eax

; 2860 : 		UINT64 newhats = joyhats ^ lastjoy2hats;

  003d4	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  003d7	33 05 00 00 00
	00		 xor	 eax, DWORD PTR _lastjoy2hats
  003dd	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  003e0	33 0d 04 00 00
	00		 xor	 ecx, DWORD PTR _lastjoy2hats+4
  003e6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _newhats$1[ebp], eax
  003ec	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _newhats$1[ebp+4], ecx

; 2861 : 		lastjoy2hats = joyhats;

  003f2	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  003f5	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  003f8	a3 00 00 00 00	 mov	 DWORD PTR _lastjoy2hats, eax
  003fd	89 0d 04 00 00
	00		 mov	 DWORD PTR _lastjoy2hats+4, ecx

; 2862 : 
; 2863 : 		for (i = 0; i < JOYHATS*4 && i < JOYHATS_MAX*4; i++, j <<= 1)

  00403	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0040a	eb 28		 jmp	 SHORT $LN16@I_GetJoyst
$LN14@I_GetJoyst:
  0040c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0040f	83 c0 01	 add	 eax, 1
  00412	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
  00415	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  0041b	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _j$2[ebp+4]
  00421	b1 01		 mov	 cl, 1
  00423	e8 00 00 00 00	 call	 __allshl
  00428	89 85 6c ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
  0042e	89 95 70 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp+4], edx
$LN16@I_GetJoyst:
  00434	83 7d a4 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00438	0f 8d 94 00 00
	00		 jge	 $LN15@I_GetJoyst
  0043e	83 7d a4 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00442	0f 8d 8a 00 00
	00		 jge	 $LN15@I_GetJoyst

; 2864 : 		{
; 2865 : 			if (newhats & j) // button changed state?

  00448	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _newhats$1[ebp]
  0044e	23 85 6c ff ff
	ff		 and	 eax, DWORD PTR _j$2[ebp]
  00454	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _newhats$1[ebp+4]
  0045a	23 8d 70 ff ff
	ff		 and	 ecx, DWORD PTR _j$2[ebp+4]
  00460	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv545[ebp], eax
  00466	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv545[ebp+4], ecx
  0046c	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv545[ebp]
  00472	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv545[ebp+4]
  00478	74 53		 je	 SHORT $LN42@I_GetJoyst

; 2866 : 			{
; 2867 : 				if (joyhats & j)

  0047a	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  0047d	23 85 6c ff ff
	ff		 and	 eax, DWORD PTR _j$2[ebp]
  00483	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  00486	23 8d 70 ff ff
	ff		 and	 ecx, DWORD PTR _j$2[ebp+4]
  0048c	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv555[ebp], eax
  00492	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv555[ebp+4], ecx
  00498	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv555[ebp]
  0049e	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv555[ebp+4]
  004a4	74 09		 je	 SHORT $LN43@I_GetJoyst

; 2868 : 					event.type = ev_keydown;

  004a6	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _event$[ebp], 0
  004ad	eb 07		 jmp	 SHORT $LN44@I_GetJoyst
$LN43@I_GetJoyst:

; 2869 : 				else
; 2870 : 					event.type = ev_keyup;

  004af	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1
$LN44@I_GetJoyst:

; 2871 : 				event.data1 = KEY_2HAT1 + i;

  004b6	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  004b9	05 98 01 00 00	 add	 eax, 408		; 00000198H
  004be	89 45 88	 mov	 DWORD PTR _event$[ebp+4], eax

; 2872 : 				D_PostEvent(&event);

  004c1	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 _D_PostEvent
  004ca	83 c4 04	 add	 esp, 4
$LN42@I_GetJoyst:

; 2873 : 			}
; 2874 : 		}

  004cd	e9 3a ff ff ff	 jmp	 $LN14@I_GetJoyst
$LN15@I_GetJoyst:

; 2875 : 
; 2876 : 	}
; 2877 : 
; 2878 : 	// send joystick axis positions
; 2879 : 	event.type = ev_joystick2;

  004d2	c7 45 84 06 00
	00 00		 mov	 DWORD PTR _event$[ebp], 6

; 2880 : 	event.data1 = event.data2 = event.data3 = 0;

  004d9	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  004e0	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  004e3	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
  004e6	8b 4d 8c	 mov	 ecx, DWORD PTR _event$[ebp+8]
  004e9	89 4d 88	 mov	 DWORD PTR _event$[ebp+4], ecx

; 2881 : 
; 2882 : 	if (Joystick2.bGamepadStyle)

  004ec	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick2+4, 0
  004f3	74 5c		 je	 SHORT $LN45@I_GetJoyst

; 2883 : 	{
; 2884 : 		// gamepad control type, on or off, live or die
; 2885 : 		if (JoyInfo2.X)

  004f5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2
  004fc	85 c0		 test	 eax, eax
  004fe	74 22		 je	 SHORT $LN50@I_GetJoyst

; 2886 : 		{
; 2887 : 			if (js.lX < -(JOYAXISRANGE/2))

  00500	81 7d a8 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp], -511 ; fffffe01H
  00507	7d 09		 jge	 SHORT $LN48@I_GetJoyst

; 2888 : 				event.data2 = -1;

  00509	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  00510	eb 10		 jmp	 SHORT $LN50@I_GetJoyst
$LN48@I_GetJoyst:

; 2889 : 			else if (js.lX > JOYAXISRANGE/2)

  00512	81 7d a8 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp], 511 ; 000001ffH
  00519	7e 07		 jle	 SHORT $LN50@I_GetJoyst

; 2890 : 				event.data2 = 1;

  0051b	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN50@I_GetJoyst:

; 2891 : 		}
; 2892 : 		if (JoyInfo2.Y)

  00522	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+1
  00529	85 c0		 test	 eax, eax
  0052b	74 22		 je	 SHORT $LN54@I_GetJoyst

; 2893 : 		{
; 2894 : 			if (js.lY < -(JOYAXISRANGE/2))

  0052d	81 7d ac 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+4], -511 ; fffffe01H
  00534	7d 09		 jge	 SHORT $LN52@I_GetJoyst

; 2895 : 				event.data3 = -1;

  00536	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  0053d	eb 10		 jmp	 SHORT $LN54@I_GetJoyst
$LN52@I_GetJoyst:

; 2896 : 			else if (js.lY > JOYAXISRANGE/2)

  0053f	81 7d ac ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+4], 511 ; 000001ffH
  00546	7e 07		 jle	 SHORT $LN54@I_GetJoyst

; 2897 : 				event.data3 = 1;

  00548	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN54@I_GetJoyst:

; 2898 : 		}
; 2899 : 	}

  0054f	eb 22		 jmp	 SHORT $LN56@I_GetJoyst
$LN45@I_GetJoyst:

; 2900 : 	else
; 2901 : 	{
; 2902 : 		// analog control style, just send the raw data
; 2903 : 		if (JoyInfo2.X)  event.data2 = js.lX; // x axis

  00551	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2
  00558	85 c0		 test	 eax, eax
  0055a	74 06		 je	 SHORT $LN55@I_GetJoyst
  0055c	8b 45 a8	 mov	 eax, DWORD PTR _js$[ebp]
  0055f	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
$LN55@I_GetJoyst:

; 2904 : 		if (JoyInfo2.Y)  event.data3 = js.lY; // y axis

  00562	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+1
  00569	85 c0		 test	 eax, eax
  0056b	74 06		 je	 SHORT $LN56@I_GetJoyst
  0056d	8b 45 ac	 mov	 eax, DWORD PTR _js$[ebp+4]
  00570	89 45 90	 mov	 DWORD PTR _event$[ebp+12], eax
$LN56@I_GetJoyst:

; 2905 : 	}
; 2906 : 
; 2907 : 	D_PostEvent(&event);

  00573	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  00576	50		 push	 eax
  00577	e8 00 00 00 00	 call	 _D_PostEvent
  0057c	83 c4 04	 add	 esp, 4

; 2908 : #if JOYAXISSET > 1
; 2909 : 	event.data1 = 1;

  0057f	c7 45 88 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 1

; 2910 : 	event.data2 = event.data3 = 0;

  00586	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  0058d	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  00590	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax

; 2911 : 
; 2912 : 	if (Joystick2.bGamepadStyle)

  00593	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick2+4, 0
  0059a	74 5c		 je	 SHORT $LN57@I_GetJoyst

; 2913 : 	{
; 2914 : 		// gamepad control type, on or off, live or die
; 2915 : 		if (JoyInfo2.Z)

  0059c	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+2
  005a3	85 c0		 test	 eax, eax
  005a5	74 22		 je	 SHORT $LN62@I_GetJoyst

; 2916 : 		{
; 2917 : 			if (js.lZ < -(JOYAXISRANGE/2))

  005a7	81 7d b0 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+8], -511 ; fffffe01H
  005ae	7d 09		 jge	 SHORT $LN60@I_GetJoyst

; 2918 : 				event.data2 = -1;

  005b0	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  005b7	eb 10		 jmp	 SHORT $LN62@I_GetJoyst
$LN60@I_GetJoyst:

; 2919 : 			else if (js.lZ > JOYAXISRANGE/2)

  005b9	81 7d b0 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+8], 511 ; 000001ffH
  005c0	7e 07		 jle	 SHORT $LN62@I_GetJoyst

; 2920 : 				event.data2 = 1;

  005c2	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN62@I_GetJoyst:

; 2921 : 		}
; 2922 : 		if (JoyInfo2.Rx)

  005c9	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+3
  005d0	85 c0		 test	 eax, eax
  005d2	74 22		 je	 SHORT $LN66@I_GetJoyst

; 2923 : 		{
; 2924 : 			if (js.lRx < -(JOYAXISRANGE/2))

  005d4	81 7d b4 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+12], -511 ; fffffe01H
  005db	7d 09		 jge	 SHORT $LN64@I_GetJoyst

; 2925 : 				event.data3 = -1;

  005dd	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  005e4	eb 10		 jmp	 SHORT $LN66@I_GetJoyst
$LN64@I_GetJoyst:

; 2926 : 			else if (js.lRx > JOYAXISRANGE/2)

  005e6	81 7d b4 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+12], 511 ; 000001ffH
  005ed	7e 07		 jle	 SHORT $LN66@I_GetJoyst

; 2927 : 				event.data3 = 1;

  005ef	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN66@I_GetJoyst:

; 2928 : 		}
; 2929 : 	}

  005f6	eb 22		 jmp	 SHORT $LN68@I_GetJoyst
$LN57@I_GetJoyst:

; 2930 : 	else
; 2931 : 	{
; 2932 : 		// analog control style, just send the raw data
; 2933 : 		if (JoyInfo2.Z)  event.data2 = js.lZ;  // z axis

  005f8	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+2
  005ff	85 c0		 test	 eax, eax
  00601	74 06		 je	 SHORT $LN67@I_GetJoyst
  00603	8b 45 b0	 mov	 eax, DWORD PTR _js$[ebp+8]
  00606	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
$LN67@I_GetJoyst:

; 2934 : 		if (JoyInfo2.Rx) event.data3 = js.lRx; // rx axis

  00609	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+3
  00610	85 c0		 test	 eax, eax
  00612	74 06		 je	 SHORT $LN68@I_GetJoyst
  00614	8b 45 b4	 mov	 eax, DWORD PTR _js$[ebp+12]
  00617	89 45 90	 mov	 DWORD PTR _event$[ebp+12], eax
$LN68@I_GetJoyst:

; 2935 : 	}
; 2936 : 
; 2937 : 	D_PostEvent(&event);

  0061a	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 _D_PostEvent
  00623	83 c4 04	 add	 esp, 4

; 2938 : #endif
; 2939 : #if JOYAXISSET > 2
; 2940 : 	event.data1 = 2;

  00626	c7 45 88 02 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 2

; 2941 : 	event.data2 = event.data3 = 0;

  0062d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  00634	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  00637	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax

; 2942 : 
; 2943 : 	if (Joystick2.bGamepadStyle)

  0063a	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick2+4, 0
  00641	74 5c		 je	 SHORT $LN69@I_GetJoyst

; 2944 : 	{
; 2945 : 		// gamepad control type, on or off, live or die
; 2946 : 		if (JoyInfo2.Rx)

  00643	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+3
  0064a	85 c0		 test	 eax, eax
  0064c	74 22		 je	 SHORT $LN74@I_GetJoyst

; 2947 : 		{
; 2948 : 			if (js.lRy < -(JOYAXISRANGE/2))

  0064e	81 7d b8 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+16], -511 ; fffffe01H
  00655	7d 09		 jge	 SHORT $LN72@I_GetJoyst

; 2949 : 				event.data2 = -1;

  00657	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  0065e	eb 10		 jmp	 SHORT $LN74@I_GetJoyst
$LN72@I_GetJoyst:

; 2950 : 			else if (js.lRy > JOYAXISRANGE/2)

  00660	81 7d b8 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+16], 511 ; 000001ffH
  00667	7e 07		 jle	 SHORT $LN74@I_GetJoyst

; 2951 : 				event.data2 = 1;

  00669	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN74@I_GetJoyst:

; 2952 : 		}
; 2953 : 		if (JoyInfo2.Rz)

  00670	0f b6 05 05 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+5
  00677	85 c0		 test	 eax, eax
  00679	74 22		 je	 SHORT $LN78@I_GetJoyst

; 2954 : 		{
; 2955 : 			if (js.lRz < -(JOYAXISRANGE/2))

  0067b	81 7d bc 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+20], -511 ; fffffe01H
  00682	7d 09		 jge	 SHORT $LN76@I_GetJoyst

; 2956 : 				event.data3 = -1;

  00684	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  0068b	eb 10		 jmp	 SHORT $LN78@I_GetJoyst
$LN76@I_GetJoyst:

; 2957 : 			else if (js.lRz > JOYAXISRANGE/2)

  0068d	81 7d bc ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+20], 511 ; 000001ffH
  00694	7e 07		 jle	 SHORT $LN78@I_GetJoyst

; 2958 : 				event.data3 = 1;

  00696	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN78@I_GetJoyst:

; 2959 : 		}
; 2960 : 	}

  0069d	eb 22		 jmp	 SHORT $LN80@I_GetJoyst
$LN69@I_GetJoyst:

; 2961 : 	else
; 2962 : 	{
; 2963 : 		// analog control style, just send the raw data
; 2964 : 		if (JoyInfo2.Ry) event.data2 = js.lRy; // ry axis

  0069f	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+4
  006a6	85 c0		 test	 eax, eax
  006a8	74 06		 je	 SHORT $LN79@I_GetJoyst
  006aa	8b 45 b8	 mov	 eax, DWORD PTR _js$[ebp+16]
  006ad	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
$LN79@I_GetJoyst:

; 2965 : 		if (JoyInfo2.Rz) event.data3 = js.lRz; // rz axis

  006b0	0f b6 05 05 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+5
  006b7	85 c0		 test	 eax, eax
  006b9	74 06		 je	 SHORT $LN80@I_GetJoyst
  006bb	8b 45 bc	 mov	 eax, DWORD PTR _js$[ebp+20]
  006be	89 45 90	 mov	 DWORD PTR _event$[ebp+12], eax
$LN80@I_GetJoyst:

; 2966 : 	}
; 2967 : 
; 2968 : 	D_PostEvent(&event);

  006c1	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  006c4	50		 push	 eax
  006c5	e8 00 00 00 00	 call	 _D_PostEvent
  006ca	83 c4 04	 add	 esp, 4

; 2969 : #endif
; 2970 : #if JOYAXISSET > 3
; 2971 : 	event.data1 = 3;

  006cd	c7 45 88 03 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 3

; 2972 : 	event.data2 = event.data3 = 0;

  006d4	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  006db	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  006de	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax

; 2973 : 	if (Joystick2.bGamepadStyle)

  006e1	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick2+4, 0
  006e8	0f 84 80 00 00
	00		 je	 $LN81@I_GetJoyst

; 2974 : 	{
; 2975 : 		// gamepad control type, on or off, live or die
; 2976 : 		if (JoyInfo2.U)

  006ee	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+6
  006f5	85 c0		 test	 eax, eax
  006f7	74 34		 je	 SHORT $LN86@I_GetJoyst

; 2977 : 		{
; 2978 : 			if (js.rglSlider[0] < -(JOYAXISRANGE/2))

  006f9	b8 04 00 00 00	 mov	 eax, 4
  006fe	6b c8 00	 imul	 ecx, eax, 0
  00701	81 7c 0d c0 01
	fe ff ff	 cmp	 DWORD PTR _js$[ebp+ecx+24], -511 ; fffffe01H
  00709	7d 09		 jge	 SHORT $LN84@I_GetJoyst

; 2979 : 				event.data2 = -1;

  0070b	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  00712	eb 19		 jmp	 SHORT $LN86@I_GetJoyst
$LN84@I_GetJoyst:

; 2980 : 			else if (js.rglSlider[0] > JOYAXISRANGE/2)

  00714	b8 04 00 00 00	 mov	 eax, 4
  00719	6b c8 00	 imul	 ecx, eax, 0
  0071c	81 7c 0d c0 ff
	01 00 00	 cmp	 DWORD PTR _js$[ebp+ecx+24], 511 ; 000001ffH
  00724	7e 07		 jle	 SHORT $LN86@I_GetJoyst

; 2981 : 				event.data2 = 1;

  00726	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN86@I_GetJoyst:

; 2982 : 		}
; 2983 : 		if (JoyInfo2.V)

  0072d	0f b6 05 07 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+7
  00734	85 c0		 test	 eax, eax
  00736	74 34		 je	 SHORT $LN90@I_GetJoyst

; 2984 : 		{
; 2985 : 			if (js.rglSlider[1] < -(JOYAXISRANGE/2))

  00738	b8 04 00 00 00	 mov	 eax, 4
  0073d	c1 e0 00	 shl	 eax, 0
  00740	81 7c 05 c0 01
	fe ff ff	 cmp	 DWORD PTR _js$[ebp+eax+24], -511 ; fffffe01H
  00748	7d 09		 jge	 SHORT $LN88@I_GetJoyst

; 2986 : 				event.data3 = -1;

  0074a	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  00751	eb 19		 jmp	 SHORT $LN90@I_GetJoyst
$LN88@I_GetJoyst:

; 2987 : 			else if (js.rglSlider[1] > JOYAXISRANGE/2)

  00753	b8 04 00 00 00	 mov	 eax, 4
  00758	c1 e0 00	 shl	 eax, 0
  0075b	81 7c 05 c0 ff
	01 00 00	 cmp	 DWORD PTR _js$[ebp+eax+24], 511 ; 000001ffH
  00763	7e 07		 jle	 SHORT $LN90@I_GetJoyst

; 2988 : 				event.data3 = 1;

  00765	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN90@I_GetJoyst:

; 2989 : 		}
; 2990 : 	}

  0076c	eb 34		 jmp	 SHORT $LN92@I_GetJoyst
$LN81@I_GetJoyst:

; 2991 : 	else
; 2992 : 	{
; 2993 : 		// analog control style, just send the raw data
; 2994 : 		if (JoyInfo2.U)  event.data2 = js.rglSlider[0]; // U axis

  0076e	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+6
  00775	85 c0		 test	 eax, eax
  00777	74 0f		 je	 SHORT $LN91@I_GetJoyst
  00779	b8 04 00 00 00	 mov	 eax, 4
  0077e	6b c8 00	 imul	 ecx, eax, 0
  00781	8b 54 0d c0	 mov	 edx, DWORD PTR _js$[ebp+ecx+24]
  00785	89 55 8c	 mov	 DWORD PTR _event$[ebp+8], edx
$LN91@I_GetJoyst:

; 2995 : 		if (JoyInfo2.V)  event.data3 = js.rglSlider[1]; // V axis

  00788	0f b6 05 07 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo2+7
  0078f	85 c0		 test	 eax, eax
  00791	74 0f		 je	 SHORT $LN92@I_GetJoyst
  00793	b8 04 00 00 00	 mov	 eax, 4
  00798	c1 e0 00	 shl	 eax, 0
  0079b	8b 4c 05 c0	 mov	 ecx, DWORD PTR _js$[ebp+eax+24]
  0079f	89 4d 90	 mov	 DWORD PTR _event$[ebp+12], ecx
$LN92@I_GetJoyst:

; 2996 : 	}
; 2997 : 	D_PostEvent(&event);

  007a2	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  007a5	50		 push	 eax
  007a6	e8 00 00 00 00	 call	 _D_PostEvent
  007ab	83 c4 04	 add	 esp, 4
$LN1@I_GetJoyst:

; 2998 : #endif
; 2999 : }

  007ae	5f		 pop	 edi
  007af	5e		 pop	 esi
  007b0	5b		 pop	 ebx
  007b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007b4	33 cd		 xor	 ecx, ebp
  007b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007bb	8b e5		 mov	 esp, ebp
  007bd	5d		 pop	 ebp
  007be	c3		 ret	 0
_I_GetJoystick2Events ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetJoystickEvents
_TEXT	SEGMENT
tv500 = -228						; size = 8
tv510 = -228						; size = 8
tv545 = -228						; size = 8
tv555 = -228						; size = 8
_newhats$1 = -156					; size = 8
_j$2 = -148						; size = 8
_newbuttons$3 = -140					; size = 8
_j$4 = -132						; size = 8
_event$ = -124						; size = 16
_joyhats$ = -108					; size = 8
_joybuttons$ = -100					; size = 8
_i$ = -92						; size = 4
_js$ = -88						; size = 80
_hr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_GetJoystickEvents PROC				; COMDAT

; 2518 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2519 : 	HRESULT hr;
; 2520 : 	DIJOYSTATE js; // DirectInput joystick state
; 2521 : 	int i;
; 2522 : 	UINT64 joybuttons = 0;

  00016	0f 57 c0	 xorps	 xmm0, xmm0
  00019	66 0f 13 45 9c	 movlpd	 QWORD PTR _joybuttons$[ebp], xmm0

; 2523 : 	UINT64 joyhats = 0;

  0001e	0f 57 c0	 xorps	 xmm0, xmm0
  00021	66 0f 13 45 94	 movlpd	 QWORD PTR _joyhats$[ebp], xmm0

; 2524 : 	event_t event;
; 2525 : 
; 2526 : 	if (!lpDIJ)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ, 0
  0002d	75 05		 jne	 SHORT $LN17@I_GetJoyst

; 2527 : 		return;

  0002f	e9 7a 07 00 00	 jmp	 $LN1@I_GetJoyst
$LN17@I_GetJoyst:
$LN2@I_GetJoyst:

; 2528 : 
; 2529 : 	// if input is lost then acquire and keep trying
; 2530 : 	for (;;)
; 2531 : 	{
; 2532 : 		// poll the joystick to read the current state
; 2533 : 		// if the device doesn't require polling, this function returns almost instantly
; 2534 : 		if (lpDIJA)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJA, 0
  0003b	74 44		 je	 SHORT $LN22@I_GetJoyst

; 2535 : 		{
; 2536 : 			hr = IDirectInputDevice2_Poll(lpDIJA);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJA
  00042	50		 push	 eax
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJA
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  0004e	ff d0		 call	 eax
  00050	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2537 : 			if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED)

  00053	81 7d f8 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  0005a	74 09		 je	 SHORT $LN21@I_GetJoyst
  0005c	81 7d f8 0c 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024884 ; 8007000cH
  00063	75 04		 jne	 SHORT $LN19@I_GetJoyst
$LN21@I_GetJoyst:

; 2538 : 				goto acquire;

  00065	eb 67		 jmp	 SHORT $acquire$96
  00067	eb 18		 jmp	 SHORT $LN22@I_GetJoyst
$LN19@I_GetJoyst:

; 2539 : 			else if (FAILED(hr))

  00069	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006d	7d 12		 jge	 SHORT $LN22@I_GetJoyst

; 2540 : 			{
; 2541 : 				CONS_Printf("I_GetJoystickEvents(): Poll FAILED\n");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@ODDENDCH@I_GetJoystickEvents?$CI?$CJ?3?5Poll?5FAI@
  00074	e8 00 00 00 00	 call	 _CONS_Printf
  00079	83 c4 04	 add	 esp, 4

; 2542 : 				return;

  0007c	e9 2d 07 00 00	 jmp	 $LN1@I_GetJoyst
$LN22@I_GetJoyst:

; 2543 : 			}
; 2544 : 		}
; 2545 : 
; 2546 : 		// get the input's device state, and put the state in dims
; 2547 : 		hr = IDirectInputDevice_GetDeviceState(lpDIJ, sizeof (DIJOYSTATE), &js);

  00081	8d 45 a8	 lea	 eax, DWORD PTR _js$[ebp]
  00084	50		 push	 eax
  00085	6a 50		 push	 80			; 00000050H
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ
  0008d	51		 push	 ecx
  0008e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIJ
  00094	8b 02		 mov	 eax, DWORD PTR [edx]
  00096	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00099	ff d1		 call	 ecx
  0009b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2548 : 
; 2549 : 		if (hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED)

  0009e	81 7d f8 1e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024866 ; 8007001eH
  000a5	74 09		 je	 SHORT $LN25@I_GetJoyst
  000a7	81 7d f8 0c 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024884 ; 8007000cH
  000ae	75 04		 jne	 SHORT $LN23@I_GetJoyst
$LN25@I_GetJoyst:

; 2550 : 		{
; 2551 : 			// DirectInput is telling us that the input stream has
; 2552 : 			// been interrupted.  We aren't tracking any state
; 2553 : 			// between polls, so we don't have any special reset
; 2554 : 			// that needs to be done.  We just re-acquire and
; 2555 : 			// try again.
; 2556 : 			goto acquire;

  000b0	eb 1c		 jmp	 SHORT $acquire$96

; 2557 : 		}

  000b2	eb 18		 jmp	 SHORT $LN26@I_GetJoyst
$LN23@I_GetJoyst:

; 2558 : 		else if (FAILED(hr))

  000b4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b8	7d 12		 jge	 SHORT $LN26@I_GetJoyst

; 2559 : 		{
; 2560 : 			CONS_Printf("I_GetJoystickEvents(): GetDeviceState FAILED\n");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MNKDPIKA@I_GetJoystickEvents?$CI?$CJ?3?5GetDevic@
  000bf	e8 00 00 00 00	 call	 _CONS_Printf
  000c4	83 c4 04	 add	 esp, 4

; 2561 : 			return;

  000c7	e9 e2 06 00 00	 jmp	 $LN1@I_GetJoyst
$LN26@I_GetJoyst:

; 2562 : 		}
; 2563 : 
; 2564 : 		break;

  000cc	eb 21		 jmp	 SHORT $LN3@I_GetJoyst
$acquire$96:

; 2565 : acquire:
; 2566 : 		if (FAILED(IDirectInputDevice_Acquire(lpDIJ)))

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ
  000d3	50		 push	 eax
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ
  000da	8b 11		 mov	 edx, DWORD PTR [ecx]
  000dc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000df	ff d0		 call	 eax
  000e1	85 c0		 test	 eax, eax
  000e3	7d 05		 jge	 SHORT $LN27@I_GetJoyst

; 2567 : 			return;

  000e5	e9 c4 06 00 00	 jmp	 $LN1@I_GetJoyst
$LN27@I_GetJoyst:

; 2568 : 	}

  000ea	e9 45 ff ff ff	 jmp	 $LN2@I_GetJoyst
$LN3@I_GetJoyst:

; 2569 : 
; 2570 : 	// look for as many buttons as g_input code supports, we don't use the others
; 2571 : 	for (i = JOYBUTTONS_MIN - 1; i >= 0; i--)

  000ef	c7 45 a4 1f 00
	00 00		 mov	 DWORD PTR _i$[ebp], 31	; 0000001fH
  000f6	eb 09		 jmp	 SHORT $LN7@I_GetJoyst
$LN5@I_GetJoyst:
  000f8	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  000fb	83 e8 01	 sub	 eax, 1
  000fe	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@I_GetJoyst:
  00101	83 7d a4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00105	7c 30		 jl	 SHORT $LN6@I_GetJoyst

; 2572 : 	{
; 2573 : 		joybuttons <<= 1;

  00107	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  0010a	8b 55 a0	 mov	 edx, DWORD PTR _joybuttons$[ebp+4]
  0010d	b1 01		 mov	 cl, 1
  0010f	e8 00 00 00 00	 call	 __allshl
  00114	89 45 9c	 mov	 DWORD PTR _joybuttons$[ebp], eax
  00117	89 55 a0	 mov	 DWORD PTR _joybuttons$[ebp+4], edx

; 2574 : 		if (js.rgbButtons[i])

  0011a	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	0f b6 4c 05 d8	 movzx	 ecx, BYTE PTR _js$[ebp+eax+48]
  00122	85 c9		 test	 ecx, ecx
  00124	74 0f		 je	 SHORT $LN28@I_GetJoyst

; 2575 : 			joybuttons |= 1;

  00126	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  00129	83 c8 01	 or	 eax, 1
  0012c	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  0012f	89 45 9c	 mov	 DWORD PTR _joybuttons$[ebp], eax
  00132	89 4d a0	 mov	 DWORD PTR _joybuttons$[ebp+4], ecx
$LN28@I_GetJoyst:

; 2576 : 	}

  00135	eb c1		 jmp	 SHORT $LN5@I_GetJoyst
$LN6@I_GetJoyst:

; 2577 : 
; 2578 : 	for (i = JOYHATS_MIN -1; i >=0; i--)

  00137	c7 45 a4 03 00
	00 00		 mov	 DWORD PTR _i$[ebp], 3
  0013e	eb 09		 jmp	 SHORT $LN10@I_GetJoyst
$LN8@I_GetJoyst:
  00140	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00143	83 e8 01	 sub	 eax, 1
  00146	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@I_GetJoyst:
  00149	83 7d a4 00	 cmp	 DWORD PTR _i$[ebp], 0
  0014d	0f 8c 3a 01 00
	00		 jl	 $LN9@I_GetJoyst

; 2579 : 	{
; 2580 : 		if (js.rgdwPOV[i] != 0xffff && js.rgdwPOV[i] != 0xffffffff)

  00153	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00156	81 7c 85 c8 ff
	ff 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 65535 ; 0000ffffH
  0015e	0f 84 24 01 00
	00		 je	 $LN36@I_GetJoyst
  00164	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00167	83 7c 85 c8 ff	 cmp	 DWORD PTR _js$[ebp+eax*4+32], -1
  0016c	0f 84 16 01 00
	00		 je	 $LN36@I_GetJoyst

; 2581 : 		{
; 2582 : 			if     (js.rgdwPOV[i] > 270 * DI_DEGREES || js.rgdwPOV[i] <  90 * DI_DEGREES)

  00172	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00175	81 7c 85 c8 78
	69 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 27000 ; 00006978H
  0017d	77 0d		 ja	 SHORT $LN32@I_GetJoyst
  0017f	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00182	81 7c 85 c8 28
	23 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 9000 ; 00002328H
  0018a	73 2b		 jae	 SHORT $LN30@I_GetJoyst
$LN32@I_GetJoyst:

; 2583 : 				joyhats |= (UINT64)1<<(0 + 4*(UINT64)i); // UP

  0018c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0018f	99		 cdq
  00190	6a 00		 push	 0
  00192	6a 04		 push	 4
  00194	52		 push	 edx
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 __allmul
  0019b	8b c8		 mov	 ecx, eax
  0019d	b8 01 00 00 00	 mov	 eax, 1
  001a2	33 d2		 xor	 edx, edx
  001a4	e8 00 00 00 00	 call	 __allshl
  001a9	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  001ac	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  001af	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  001b2	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
  001b5	eb 46		 jmp	 SHORT $LN33@I_GetJoyst
$LN30@I_GetJoyst:

; 2584 : 			else if (js.rgdwPOV[i] >  90 * DI_DEGREES && js.rgdwPOV[i] < 270 * DI_DEGREES)

  001b7	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001ba	81 7c 85 c8 28
	23 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 9000 ; 00002328H
  001c2	76 39		 jbe	 SHORT $LN33@I_GetJoyst
  001c4	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001c7	81 7c 85 c8 78
	69 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 27000 ; 00006978H
  001cf	73 2c		 jae	 SHORT $LN33@I_GetJoyst

; 2585 : 				joyhats |= (UINT64)1<<(1 + 4*(UINT64)i); // DOWN

  001d1	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001d4	99		 cdq
  001d5	6a 00		 push	 0
  001d7	6a 04		 push	 4
  001d9	52		 push	 edx
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 __allmul
  001e0	8b c8		 mov	 ecx, eax
  001e2	83 c1 01	 add	 ecx, 1
  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	33 d2		 xor	 edx, edx
  001ec	e8 00 00 00 00	 call	 __allshl
  001f1	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  001f4	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  001f7	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  001fa	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
$LN33@I_GetJoyst:

; 2586 : 			if     (js.rgdwPOV[i] >   0 * DI_DEGREES && js.rgdwPOV[i] < 180 * DI_DEGREES)

  001fd	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00200	83 7c 85 c8 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 0
  00205	76 3b		 jbe	 SHORT $LN34@I_GetJoyst
  00207	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0020a	81 7c 85 c8 50
	46 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 18000 ; 00004650H
  00212	73 2e		 jae	 SHORT $LN34@I_GetJoyst

; 2587 : 				joyhats |= (UINT64)1<<(3 + 4*(UINT64)i); // LEFT

  00214	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00217	99		 cdq
  00218	6a 00		 push	 0
  0021a	6a 04		 push	 4
  0021c	52		 push	 edx
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 __allmul
  00223	8b c8		 mov	 ecx, eax
  00225	83 c1 03	 add	 ecx, 3
  00228	b8 01 00 00 00	 mov	 eax, 1
  0022d	33 d2		 xor	 edx, edx
  0022f	e8 00 00 00 00	 call	 __allshl
  00234	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  00237	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  0023a	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  0023d	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
  00240	eb 46		 jmp	 SHORT $LN36@I_GetJoyst
$LN34@I_GetJoyst:

; 2588 : 			else if (js.rgdwPOV[i] > 180 * DI_DEGREES && js.rgdwPOV[i] < 360 * DI_DEGREES)

  00242	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00245	81 7c 85 c8 50
	46 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 18000 ; 00004650H
  0024d	76 39		 jbe	 SHORT $LN36@I_GetJoyst
  0024f	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  00252	81 7c 85 c8 a0
	8c 00 00	 cmp	 DWORD PTR _js$[ebp+eax*4+32], 36000 ; 00008ca0H
  0025a	73 2c		 jae	 SHORT $LN36@I_GetJoyst

; 2589 : 				joyhats |= (UINT64)1<<(2 + 4*(UINT64)i); // RIGHT

  0025c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0025f	99		 cdq
  00260	6a 00		 push	 0
  00262	6a 04		 push	 4
  00264	52		 push	 edx
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 __allmul
  0026b	8b c8		 mov	 ecx, eax
  0026d	83 c1 02	 add	 ecx, 2
  00270	b8 01 00 00 00	 mov	 eax, 1
  00275	33 d2		 xor	 edx, edx
  00277	e8 00 00 00 00	 call	 __allshl
  0027c	0b 45 94	 or	 eax, DWORD PTR _joyhats$[ebp]
  0027f	0b 55 98	 or	 edx, DWORD PTR _joyhats$[ebp+4]
  00282	89 45 94	 mov	 DWORD PTR _joyhats$[ebp], eax
  00285	89 55 98	 mov	 DWORD PTR _joyhats$[ebp+4], edx
$LN36@I_GetJoyst:

; 2590 : 		}
; 2591 : 	}

  00288	e9 b3 fe ff ff	 jmp	 $LN8@I_GetJoyst
$LN9@I_GetJoyst:

; 2592 : 
; 2593 : 	if (joybuttons != lastjoybuttons)

  0028d	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  00290	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lastjoybuttons
  00296	75 0f		 jne	 SHORT $LN94@I_GetJoyst
  00298	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  0029b	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _lastjoybuttons+4
  002a1	0f 84 01 01 00
	00		 je	 $LN12@I_GetJoyst
$LN94@I_GetJoyst:

; 2594 : 	{
; 2595 : 		UINT64 j = 1; // keep only bits that changed since last time

  002a7	33 c0		 xor	 eax, eax
  002a9	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$4[ebp], 1
  002b3	89 45 80	 mov	 DWORD PTR _j$4[ebp+4], eax

; 2596 : 		UINT64 newbuttons = joybuttons ^ lastjoybuttons;

  002b6	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  002b9	33 05 00 00 00
	00		 xor	 eax, DWORD PTR _lastjoybuttons
  002bf	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  002c2	33 0d 04 00 00
	00		 xor	 ecx, DWORD PTR _lastjoybuttons+4
  002c8	89 85 74 ff ff
	ff		 mov	 DWORD PTR _newbuttons$3[ebp], eax
  002ce	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _newbuttons$3[ebp+4], ecx

; 2597 : 		lastjoybuttons = joybuttons;

  002d4	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  002d7	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  002da	a3 00 00 00 00	 mov	 DWORD PTR _lastjoybuttons, eax
  002df	89 0d 04 00 00
	00		 mov	 DWORD PTR _lastjoybuttons+4, ecx

; 2598 : 
; 2599 : 		for (i = 0; i < JOYBUTTONS && i < JOYBUTTONS_MAX; i++, j <<= 1)

  002e5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002ec	eb 22		 jmp	 SHORT $LN13@I_GetJoyst
$LN11@I_GetJoyst:
  002ee	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  002f1	83 c0 01	 add	 eax, 1
  002f4	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
  002f7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _j$4[ebp]
  002fd	8b 55 80	 mov	 edx, DWORD PTR _j$4[ebp+4]
  00300	b1 01		 mov	 cl, 1
  00302	e8 00 00 00 00	 call	 __allshl
  00307	89 85 7c ff ff
	ff		 mov	 DWORD PTR _j$4[ebp], eax
  0030d	89 55 80	 mov	 DWORD PTR _j$4[ebp+4], edx
$LN13@I_GetJoyst:
  00310	83 7d a4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00314	0f 8d 8e 00 00
	00		 jge	 $LN12@I_GetJoyst
  0031a	83 7d a4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0031e	0f 8d 84 00 00
	00		 jge	 $LN12@I_GetJoyst

; 2600 : 		{
; 2601 : 			if (newbuttons & j) // button changed state?

  00324	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _newbuttons$3[ebp]
  0032a	23 85 7c ff ff
	ff		 and	 eax, DWORD PTR _j$4[ebp]
  00330	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _newbuttons$3[ebp+4]
  00336	23 4d 80	 and	 ecx, DWORD PTR _j$4[ebp+4]
  00339	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv500[ebp], eax
  0033f	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv500[ebp+4], ecx
  00345	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv500[ebp]
  0034b	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv500[ebp+4]
  00351	74 50		 je	 SHORT $LN38@I_GetJoyst

; 2602 : 			{
; 2603 : 				if (joybuttons & j)

  00353	8b 45 9c	 mov	 eax, DWORD PTR _joybuttons$[ebp]
  00356	23 85 7c ff ff
	ff		 and	 eax, DWORD PTR _j$4[ebp]
  0035c	8b 4d a0	 mov	 ecx, DWORD PTR _joybuttons$[ebp+4]
  0035f	23 4d 80	 and	 ecx, DWORD PTR _j$4[ebp+4]
  00362	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv510[ebp], eax
  00368	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv510[ebp+4], ecx
  0036e	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv510[ebp]
  00374	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv510[ebp+4]
  0037a	74 09		 je	 SHORT $LN39@I_GetJoyst

; 2604 : 					event.type = ev_keydown;

  0037c	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _event$[ebp], 0
  00383	eb 07		 jmp	 SHORT $LN40@I_GetJoyst
$LN39@I_GetJoyst:

; 2605 : 				else
; 2606 : 					event.type = ev_keyup;

  00385	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1
$LN40@I_GetJoyst:

; 2607 : 				event.data1 = KEY_JOY1 + i;

  0038c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0038f	05 08 01 00 00	 add	 eax, 264		; 00000108H
  00394	89 45 88	 mov	 DWORD PTR _event$[ebp+4], eax

; 2608 : 				D_PostEvent(&event);

  00397	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  0039a	50		 push	 eax
  0039b	e8 00 00 00 00	 call	 _D_PostEvent
  003a0	83 c4 04	 add	 esp, 4
$LN38@I_GetJoyst:

; 2609 : 			}
; 2610 : 		}

  003a3	e9 46 ff ff ff	 jmp	 $LN11@I_GetJoyst
$LN12@I_GetJoyst:

; 2611 : 	}
; 2612 : 
; 2613 : 	if (joyhats != lastjoyhats)

  003a8	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  003ab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lastjoyhats
  003b1	75 0f		 jne	 SHORT $LN95@I_GetJoyst
  003b3	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  003b6	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _lastjoyhats+4
  003bc	0f 84 10 01 00
	00		 je	 $LN15@I_GetJoyst
$LN95@I_GetJoyst:

; 2614 : 	{
; 2615 : 		UINT64 j = 1; // keep only bits that changed since last time

  003c2	33 c0		 xor	 eax, eax
  003c4	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$2[ebp], 1
  003ce	89 85 70 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp+4], eax

; 2616 : 		UINT64 newhats = joyhats ^ lastjoyhats;

  003d4	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  003d7	33 05 00 00 00
	00		 xor	 eax, DWORD PTR _lastjoyhats
  003dd	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  003e0	33 0d 04 00 00
	00		 xor	 ecx, DWORD PTR _lastjoyhats+4
  003e6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _newhats$1[ebp], eax
  003ec	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _newhats$1[ebp+4], ecx

; 2617 : 		lastjoyhats = joyhats;

  003f2	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  003f5	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  003f8	a3 00 00 00 00	 mov	 DWORD PTR _lastjoyhats, eax
  003fd	89 0d 04 00 00
	00		 mov	 DWORD PTR _lastjoyhats+4, ecx

; 2618 : 
; 2619 : 		for (i = 0; i < JOYHATS*4 && i < JOYHATS_MAX*4; i++, j <<= 1)

  00403	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0040a	eb 28		 jmp	 SHORT $LN16@I_GetJoyst
$LN14@I_GetJoyst:
  0040c	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0040f	83 c0 01	 add	 eax, 1
  00412	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax
  00415	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  0041b	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _j$2[ebp+4]
  00421	b1 01		 mov	 cl, 1
  00423	e8 00 00 00 00	 call	 __allshl
  00428	89 85 6c ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
  0042e	89 95 70 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp+4], edx
$LN16@I_GetJoyst:
  00434	83 7d a4 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00438	0f 8d 94 00 00
	00		 jge	 $LN15@I_GetJoyst
  0043e	83 7d a4 10	 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00442	0f 8d 8a 00 00
	00		 jge	 $LN15@I_GetJoyst

; 2620 : 		{
; 2621 : 			if (newhats & j) // button changed state?

  00448	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _newhats$1[ebp]
  0044e	23 85 6c ff ff
	ff		 and	 eax, DWORD PTR _j$2[ebp]
  00454	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _newhats$1[ebp+4]
  0045a	23 8d 70 ff ff
	ff		 and	 ecx, DWORD PTR _j$2[ebp+4]
  00460	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv545[ebp], eax
  00466	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv545[ebp+4], ecx
  0046c	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv545[ebp]
  00472	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv545[ebp+4]
  00478	74 53		 je	 SHORT $LN42@I_GetJoyst

; 2622 : 			{
; 2623 : 				if (joyhats & j)

  0047a	8b 45 94	 mov	 eax, DWORD PTR _joyhats$[ebp]
  0047d	23 85 6c ff ff
	ff		 and	 eax, DWORD PTR _j$2[ebp]
  00483	8b 4d 98	 mov	 ecx, DWORD PTR _joyhats$[ebp+4]
  00486	23 8d 70 ff ff
	ff		 and	 ecx, DWORD PTR _j$2[ebp+4]
  0048c	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv555[ebp], eax
  00492	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv555[ebp+4], ecx
  00498	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv555[ebp]
  0049e	0b 95 20 ff ff
	ff		 or	 edx, DWORD PTR tv555[ebp+4]
  004a4	74 09		 je	 SHORT $LN43@I_GetJoyst

; 2624 : 					event.type = ev_keydown;

  004a6	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _event$[ebp], 0
  004ad	eb 07		 jmp	 SHORT $LN44@I_GetJoyst
$LN43@I_GetJoyst:

; 2625 : 				else
; 2626 : 					event.type = ev_keyup;

  004af	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _event$[ebp], 1
$LN44@I_GetJoyst:

; 2627 : 				event.data1 = KEY_HAT1 + i;

  004b6	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  004b9	05 28 01 00 00	 add	 eax, 296		; 00000128H
  004be	89 45 88	 mov	 DWORD PTR _event$[ebp+4], eax

; 2628 : 				D_PostEvent(&event);

  004c1	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 _D_PostEvent
  004ca	83 c4 04	 add	 esp, 4
$LN42@I_GetJoyst:

; 2629 : 			}
; 2630 : 		}

  004cd	e9 3a ff ff ff	 jmp	 $LN14@I_GetJoyst
$LN15@I_GetJoyst:

; 2631 : 
; 2632 : 	}
; 2633 : 
; 2634 : 	// send joystick axis positions
; 2635 : 	event.type = ev_joystick;

  004d2	c7 45 84 04 00
	00 00		 mov	 DWORD PTR _event$[ebp], 4

; 2636 : 	event.data1 = event.data2 = event.data3 = 0;

  004d9	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  004e0	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  004e3	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
  004e6	8b 4d 8c	 mov	 ecx, DWORD PTR _event$[ebp+8]
  004e9	89 4d 88	 mov	 DWORD PTR _event$[ebp+4], ecx

; 2637 : 
; 2638 : 	if (Joystick.bGamepadStyle)

  004ec	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick+4, 0
  004f3	74 5c		 je	 SHORT $LN45@I_GetJoyst

; 2639 : 	{
; 2640 : 		// gamepad control type, on or off, live or die
; 2641 : 		if (JoyInfo.X)

  004f5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo
  004fc	85 c0		 test	 eax, eax
  004fe	74 22		 je	 SHORT $LN50@I_GetJoyst

; 2642 : 		{
; 2643 : 			if (js.lX < -(JOYAXISRANGE/2))

  00500	81 7d a8 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp], -511 ; fffffe01H
  00507	7d 09		 jge	 SHORT $LN48@I_GetJoyst

; 2644 : 				event.data2 = -1;

  00509	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  00510	eb 10		 jmp	 SHORT $LN50@I_GetJoyst
$LN48@I_GetJoyst:

; 2645 : 			else if (js.lX > JOYAXISRANGE/2)

  00512	81 7d a8 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp], 511 ; 000001ffH
  00519	7e 07		 jle	 SHORT $LN50@I_GetJoyst

; 2646 : 				event.data2 = 1;

  0051b	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN50@I_GetJoyst:

; 2647 : 		}
; 2648 : 		if (JoyInfo.Y)

  00522	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+1
  00529	85 c0		 test	 eax, eax
  0052b	74 22		 je	 SHORT $LN54@I_GetJoyst

; 2649 : 		{
; 2650 : 			if (js.lY < -(JOYAXISRANGE/2))

  0052d	81 7d ac 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+4], -511 ; fffffe01H
  00534	7d 09		 jge	 SHORT $LN52@I_GetJoyst

; 2651 : 				event.data3 = -1;

  00536	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  0053d	eb 10		 jmp	 SHORT $LN54@I_GetJoyst
$LN52@I_GetJoyst:

; 2652 : 			else if (js.lY > JOYAXISRANGE/2)

  0053f	81 7d ac ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+4], 511 ; 000001ffH
  00546	7e 07		 jle	 SHORT $LN54@I_GetJoyst

; 2653 : 				event.data3 = 1;

  00548	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN54@I_GetJoyst:

; 2654 : 		}
; 2655 : 	}

  0054f	eb 22		 jmp	 SHORT $LN56@I_GetJoyst
$LN45@I_GetJoyst:

; 2656 : 	else
; 2657 : 	{
; 2658 : 		// analog control style, just send the raw data
; 2659 : 		if (JoyInfo.X)  event.data2 = js.lX; // x axis

  00551	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo
  00558	85 c0		 test	 eax, eax
  0055a	74 06		 je	 SHORT $LN55@I_GetJoyst
  0055c	8b 45 a8	 mov	 eax, DWORD PTR _js$[ebp]
  0055f	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
$LN55@I_GetJoyst:

; 2660 : 		if (JoyInfo.Y)  event.data3 = js.lY; // y axis

  00562	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+1
  00569	85 c0		 test	 eax, eax
  0056b	74 06		 je	 SHORT $LN56@I_GetJoyst
  0056d	8b 45 ac	 mov	 eax, DWORD PTR _js$[ebp+4]
  00570	89 45 90	 mov	 DWORD PTR _event$[ebp+12], eax
$LN56@I_GetJoyst:

; 2661 : 	}
; 2662 : 
; 2663 : 	D_PostEvent(&event);

  00573	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  00576	50		 push	 eax
  00577	e8 00 00 00 00	 call	 _D_PostEvent
  0057c	83 c4 04	 add	 esp, 4

; 2664 : #if JOYAXISSET > 1
; 2665 : 	event.data1 = 1;

  0057f	c7 45 88 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 1

; 2666 : 	event.data2 = event.data3 = 0;

  00586	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  0058d	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  00590	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax

; 2667 : 
; 2668 : 	if (Joystick.bGamepadStyle)

  00593	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick+4, 0
  0059a	74 5c		 je	 SHORT $LN57@I_GetJoyst

; 2669 : 	{
; 2670 : 		// gamepad control type, on or off, live or die
; 2671 : 		if (JoyInfo.Z)

  0059c	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+2
  005a3	85 c0		 test	 eax, eax
  005a5	74 22		 je	 SHORT $LN62@I_GetJoyst

; 2672 : 		{
; 2673 : 			if (js.lZ < -(JOYAXISRANGE/2))

  005a7	81 7d b0 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+8], -511 ; fffffe01H
  005ae	7d 09		 jge	 SHORT $LN60@I_GetJoyst

; 2674 : 				event.data2 = -1;

  005b0	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  005b7	eb 10		 jmp	 SHORT $LN62@I_GetJoyst
$LN60@I_GetJoyst:

; 2675 : 			else if (js.lZ > JOYAXISRANGE/2)

  005b9	81 7d b0 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+8], 511 ; 000001ffH
  005c0	7e 07		 jle	 SHORT $LN62@I_GetJoyst

; 2676 : 				event.data2 = 1;

  005c2	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN62@I_GetJoyst:

; 2677 : 		}
; 2678 : 		if (JoyInfo.Rx)

  005c9	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+3
  005d0	85 c0		 test	 eax, eax
  005d2	74 22		 je	 SHORT $LN66@I_GetJoyst

; 2679 : 		{
; 2680 : 			if (js.lRx < -(JOYAXISRANGE/2))

  005d4	81 7d b4 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+12], -511 ; fffffe01H
  005db	7d 09		 jge	 SHORT $LN64@I_GetJoyst

; 2681 : 				event.data3 = -1;

  005dd	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  005e4	eb 10		 jmp	 SHORT $LN66@I_GetJoyst
$LN64@I_GetJoyst:

; 2682 : 			else if (js.lRx > JOYAXISRANGE/2)

  005e6	81 7d b4 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+12], 511 ; 000001ffH
  005ed	7e 07		 jle	 SHORT $LN66@I_GetJoyst

; 2683 : 				event.data3 = 1;

  005ef	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN66@I_GetJoyst:

; 2684 : 		}
; 2685 : 	}

  005f6	eb 22		 jmp	 SHORT $LN68@I_GetJoyst
$LN57@I_GetJoyst:

; 2686 : 	else
; 2687 : 	{
; 2688 : 		// analog control style, just send the raw data
; 2689 : 		if (JoyInfo.Z)  event.data2 = js.lZ;  // z axis

  005f8	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+2
  005ff	85 c0		 test	 eax, eax
  00601	74 06		 je	 SHORT $LN67@I_GetJoyst
  00603	8b 45 b0	 mov	 eax, DWORD PTR _js$[ebp+8]
  00606	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
$LN67@I_GetJoyst:

; 2690 : 		if (JoyInfo.Rx) event.data3 = js.lRx; // rx axis

  00609	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+3
  00610	85 c0		 test	 eax, eax
  00612	74 06		 je	 SHORT $LN68@I_GetJoyst
  00614	8b 45 b4	 mov	 eax, DWORD PTR _js$[ebp+12]
  00617	89 45 90	 mov	 DWORD PTR _event$[ebp+12], eax
$LN68@I_GetJoyst:

; 2691 : 	}
; 2692 : 
; 2693 : 	D_PostEvent(&event);

  0061a	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 _D_PostEvent
  00623	83 c4 04	 add	 esp, 4

; 2694 : #endif
; 2695 : #if JOYAXISSET > 2
; 2696 : 	event.data1 = 2;

  00626	c7 45 88 02 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 2

; 2697 : 	event.data2 = event.data3 = 0;

  0062d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  00634	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  00637	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax

; 2698 : 
; 2699 : 	if (Joystick.bGamepadStyle)

  0063a	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick+4, 0
  00641	74 5c		 je	 SHORT $LN69@I_GetJoyst

; 2700 : 	{
; 2701 : 		// gamepad control type, on or off, live or die
; 2702 : 		if (JoyInfo.Rx)

  00643	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+3
  0064a	85 c0		 test	 eax, eax
  0064c	74 22		 je	 SHORT $LN74@I_GetJoyst

; 2703 : 		{
; 2704 : 			if (js.lRy < -(JOYAXISRANGE/2))

  0064e	81 7d b8 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+16], -511 ; fffffe01H
  00655	7d 09		 jge	 SHORT $LN72@I_GetJoyst

; 2705 : 				event.data2 = -1;

  00657	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  0065e	eb 10		 jmp	 SHORT $LN74@I_GetJoyst
$LN72@I_GetJoyst:

; 2706 : 			else if (js.lRy > JOYAXISRANGE/2)

  00660	81 7d b8 ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+16], 511 ; 000001ffH
  00667	7e 07		 jle	 SHORT $LN74@I_GetJoyst

; 2707 : 				event.data2 = 1;

  00669	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN74@I_GetJoyst:

; 2708 : 		}
; 2709 : 		if (JoyInfo.Rz)

  00670	0f b6 05 05 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+5
  00677	85 c0		 test	 eax, eax
  00679	74 22		 je	 SHORT $LN78@I_GetJoyst

; 2710 : 		{
; 2711 : 			if (js.lRz < -(JOYAXISRANGE/2))

  0067b	81 7d bc 01 fe
	ff ff		 cmp	 DWORD PTR _js$[ebp+20], -511 ; fffffe01H
  00682	7d 09		 jge	 SHORT $LN76@I_GetJoyst

; 2712 : 				event.data3 = -1;

  00684	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  0068b	eb 10		 jmp	 SHORT $LN78@I_GetJoyst
$LN76@I_GetJoyst:

; 2713 : 			else if (js.lRz > JOYAXISRANGE/2)

  0068d	81 7d bc ff 01
	00 00		 cmp	 DWORD PTR _js$[ebp+20], 511 ; 000001ffH
  00694	7e 07		 jle	 SHORT $LN78@I_GetJoyst

; 2714 : 				event.data3 = 1;

  00696	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN78@I_GetJoyst:

; 2715 : 		}
; 2716 : 	}

  0069d	eb 22		 jmp	 SHORT $LN80@I_GetJoyst
$LN69@I_GetJoyst:

; 2717 : 	else
; 2718 : 	{
; 2719 : 		// analog control style, just send the raw data
; 2720 : 		if (JoyInfo.Ry) event.data2 = js.lRy; // ry axis

  0069f	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+4
  006a6	85 c0		 test	 eax, eax
  006a8	74 06		 je	 SHORT $LN79@I_GetJoyst
  006aa	8b 45 b8	 mov	 eax, DWORD PTR _js$[ebp+16]
  006ad	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax
$LN79@I_GetJoyst:

; 2721 : 		if (JoyInfo.Rz) event.data3 = js.lRz; // rz axis

  006b0	0f b6 05 05 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+5
  006b7	85 c0		 test	 eax, eax
  006b9	74 06		 je	 SHORT $LN80@I_GetJoyst
  006bb	8b 45 bc	 mov	 eax, DWORD PTR _js$[ebp+20]
  006be	89 45 90	 mov	 DWORD PTR _event$[ebp+12], eax
$LN80@I_GetJoyst:

; 2722 : 	}
; 2723 : 
; 2724 : 	D_PostEvent(&event);

  006c1	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  006c4	50		 push	 eax
  006c5	e8 00 00 00 00	 call	 _D_PostEvent
  006ca	83 c4 04	 add	 esp, 4

; 2725 : #endif
; 2726 : #if JOYAXISSET > 3
; 2727 : 	event.data1 = 3;

  006cd	c7 45 88 03 00
	00 00		 mov	 DWORD PTR _event$[ebp+4], 3

; 2728 : 	event.data2 = event.data3 = 0;

  006d4	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 0
  006db	8b 45 90	 mov	 eax, DWORD PTR _event$[ebp+12]
  006de	89 45 8c	 mov	 DWORD PTR _event$[ebp+8], eax

; 2729 : 	if (Joystick.bGamepadStyle)

  006e1	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _Joystick+4, 0
  006e8	0f 84 80 00 00
	00		 je	 $LN81@I_GetJoyst

; 2730 : 	{
; 2731 : 		// gamepad control type, on or off, live or die
; 2732 : 		if (JoyInfo.U)

  006ee	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+6
  006f5	85 c0		 test	 eax, eax
  006f7	74 34		 je	 SHORT $LN86@I_GetJoyst

; 2733 : 		{
; 2734 : 			if (js.rglSlider[0] < -(JOYAXISRANGE/2))

  006f9	b8 04 00 00 00	 mov	 eax, 4
  006fe	6b c8 00	 imul	 ecx, eax, 0
  00701	81 7c 0d c0 01
	fe ff ff	 cmp	 DWORD PTR _js$[ebp+ecx+24], -511 ; fffffe01H
  00709	7d 09		 jge	 SHORT $LN84@I_GetJoyst

; 2735 : 				event.data2 = -1;

  0070b	c7 45 8c ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+8], -1
  00712	eb 19		 jmp	 SHORT $LN86@I_GetJoyst
$LN84@I_GetJoyst:

; 2736 : 			else if (js.rglSlider[0] > JOYAXISRANGE/2)

  00714	b8 04 00 00 00	 mov	 eax, 4
  00719	6b c8 00	 imul	 ecx, eax, 0
  0071c	81 7c 0d c0 ff
	01 00 00	 cmp	 DWORD PTR _js$[ebp+ecx+24], 511 ; 000001ffH
  00724	7e 07		 jle	 SHORT $LN86@I_GetJoyst

; 2737 : 				event.data2 = 1;

  00726	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+8], 1
$LN86@I_GetJoyst:

; 2738 : 		}
; 2739 : 		if (JoyInfo.V)

  0072d	0f b6 05 07 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+7
  00734	85 c0		 test	 eax, eax
  00736	74 34		 je	 SHORT $LN90@I_GetJoyst

; 2740 : 		{
; 2741 : 			if (js.rglSlider[1] < -(JOYAXISRANGE/2))

  00738	b8 04 00 00 00	 mov	 eax, 4
  0073d	c1 e0 00	 shl	 eax, 0
  00740	81 7c 05 c0 01
	fe ff ff	 cmp	 DWORD PTR _js$[ebp+eax+24], -511 ; fffffe01H
  00748	7d 09		 jge	 SHORT $LN88@I_GetJoyst

; 2742 : 				event.data3 = -1;

  0074a	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR _event$[ebp+12], -1
  00751	eb 19		 jmp	 SHORT $LN90@I_GetJoyst
$LN88@I_GetJoyst:

; 2743 : 			else if (js.rglSlider[1] > JOYAXISRANGE/2)

  00753	b8 04 00 00 00	 mov	 eax, 4
  00758	c1 e0 00	 shl	 eax, 0
  0075b	81 7c 05 c0 ff
	01 00 00	 cmp	 DWORD PTR _js$[ebp+eax+24], 511 ; 000001ffH
  00763	7e 07		 jle	 SHORT $LN90@I_GetJoyst

; 2744 : 				event.data3 = 1;

  00765	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _event$[ebp+12], 1
$LN90@I_GetJoyst:

; 2745 : 		}
; 2746 : 	}

  0076c	eb 34		 jmp	 SHORT $LN92@I_GetJoyst
$LN81@I_GetJoyst:

; 2747 : 	else
; 2748 : 	{
; 2749 : 		// analog control style, just send the raw data
; 2750 : 		if (JoyInfo.U)  event.data2 = js.rglSlider[0]; // U axis

  0076e	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+6
  00775	85 c0		 test	 eax, eax
  00777	74 0f		 je	 SHORT $LN91@I_GetJoyst
  00779	b8 04 00 00 00	 mov	 eax, 4
  0077e	6b c8 00	 imul	 ecx, eax, 0
  00781	8b 54 0d c0	 mov	 edx, DWORD PTR _js$[ebp+ecx+24]
  00785	89 55 8c	 mov	 DWORD PTR _event$[ebp+8], edx
$LN91@I_GetJoyst:

; 2751 : 		if (JoyInfo.V)  event.data3 = js.rglSlider[1]; // V axis

  00788	0f b6 05 07 00
	00 00		 movzx	 eax, BYTE PTR _JoyInfo+7
  0078f	85 c0		 test	 eax, eax
  00791	74 0f		 je	 SHORT $LN92@I_GetJoyst
  00793	b8 04 00 00 00	 mov	 eax, 4
  00798	c1 e0 00	 shl	 eax, 0
  0079b	8b 4c 05 c0	 mov	 ecx, DWORD PTR _js$[ebp+eax+24]
  0079f	89 4d 90	 mov	 DWORD PTR _event$[ebp+12], ecx
$LN92@I_GetJoyst:

; 2752 : 	}
; 2753 : 	D_PostEvent(&event);

  007a2	8d 45 84	 lea	 eax, DWORD PTR _event$[ebp]
  007a5	50		 push	 eax
  007a6	e8 00 00 00 00	 call	 _D_PostEvent
  007ab	83 c4 04	 add	 esp, 4
$LN1@I_GetJoyst:

; 2754 : #endif
; 2755 : }

  007ae	5f		 pop	 edi
  007af	5e		 pop	 esi
  007b0	5b		 pop	 ebx
  007b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007b4	33 cd		 xor	 ecx, ebp
  007b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007bb	8b e5		 mov	 esp, ebp
  007bd	5d		 pop	 ebp
  007be	c3		 ret	 0
_I_GetJoystickEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_CPUInfo
_TEXT	SEGMENT
tv75 = -108						; size = 4
tv82 = -108						; size = 4
tv89 = -108						; size = 4
tv128 = -108						; size = 4
tv135 = -108						; size = 4
tv142 = -108						; size = 4
tv149 = -108						; size = 4
tv156 = -108						; size = 4
tv163 = -108						; size = 4
tv170 = -108						; size = 4
tv177 = -108						; size = 4
tv184 = -108						; size = 4
tv191 = -108						; size = 4
tv198 = -108						; size = 4
tv205 = -108						; size = 4
tv212 = -108						; size = 4
tv223 = -108						; size = 4
tv229 = -108						; size = 4
_pfnCPUID$ = -40					; size = 4
_SI$ = -36						; size = 36
_I_CPUInfo PROC						; COMDAT

; 3578 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3579 : 	static CPUInfoFlags WIN_CPUInfo;
; 3580 : 	SYSTEM_INFO SI;
; 3581 : 	p_IsProcessorFeaturePresent pfnCPUID = (p_IsProcessorFeaturePresent)GetProcAddress(GetModuleHandleA("kernel32.dll"), "IsProcessorFeaturePresent");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NHEOCAHP@IsProcessorFeaturePresent@
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00020	89 45 d8	 mov	 DWORD PTR _pfnCPUID$[ebp], eax

; 3582 : 
; 3583 : 	ZeroMemory(&WIN_CPUInfo,sizeof (WIN_CPUInfo));

  00023	6a 04		 push	 4
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3584 : 	if (pfnCPUID)

  00034	83 7d d8 00	 cmp	 DWORD PTR _pfnCPUID$[ebp], 0
  00038	0f 84 47 02 00
	00		 je	 $LN2@I_CPUInfo

; 3585 : 	{
; 3586 : 		WIN_CPUInfo.FPPE       = pfnCPUID( 0); //PF_FLOATING_POINT_PRECISION_ERRATA

  0003e	6a 00		 push	 0
  00040	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00043	89 45 94	 mov	 DWORD PTR tv75[ebp], eax
  00046	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  00049	83 e0 01	 and	 eax, 1
  0004c	c1 e0 0e	 shl	 eax, 14			; 0000000eH
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00055	81 e1 ff bf ff
	ff		 and	 ecx, -16385		; ffffbfffH
  0005b	0b c8		 or	 ecx, eax
  0005d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3587 : 		WIN_CPUInfo.FPE        = pfnCPUID( 1); //PF_FLOATING_POINT_EMULATED

  00063	6a 01		 push	 1
  00065	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00068	89 45 94	 mov	 DWORD PTR tv82[ebp], eax
  0006b	8b 45 94	 mov	 eax, DWORD PTR tv82[ebp]
  0006e	83 e0 01	 and	 eax, 1
  00071	c1 e0 13	 shl	 eax, 19			; 00000013H
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  0007a	81 e1 ff ff f7
	ff		 and	 ecx, -524289		; fff7ffffH
  00080	0b c8		 or	 ecx, eax
  00082	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3588 : 		WIN_CPUInfo.cmpxchg    = pfnCPUID( 2); //PF_COMPARE_EXCHANGE_DOUBLE

  00088	6a 02		 push	 2
  0008a	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  0008d	89 45 94	 mov	 DWORD PTR tv89[ebp], eax
  00090	8b 45 94	 mov	 eax, DWORD PTR tv89[ebp]
  00093	83 e0 01	 and	 eax, 1
  00096	c1 e0 10	 shl	 eax, 16			; 00000010H
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  0009f	81 e1 ff ff fe
	ff		 and	 ecx, -65537		; fffeffffH
  000a5	0b c8		 or	 ecx, eax
  000a7	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3589 : 		WIN_CPUInfo.MMX        = pfnCPUID( 3); //PF_MMX_INSTRUCTIONS_AVAILABLE

  000ad	6a 03		 push	 3
  000af	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  000b2	89 45 94	 mov	 DWORD PTR tv128[ebp], eax
  000b5	8b 45 94	 mov	 eax, DWORD PTR tv128[ebp]
  000b8	83 e0 01	 and	 eax, 1
  000bb	c1 e0 03	 shl	 eax, 3
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  000c4	83 e1 f7	 and	 ecx, -9			; fffffff7H
  000c7	0b c8		 or	 ecx, eax
  000c9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3590 : 		WIN_CPUInfo.PPCMM64    = pfnCPUID( 4); //PF_PPC_MOVEMEM_64BIT_OK

  000cf	6a 04		 push	 4
  000d1	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  000d4	89 45 94	 mov	 DWORD PTR tv135[ebp], eax
  000d7	8b 45 94	 mov	 eax, DWORD PTR tv135[ebp]
  000da	83 e0 01	 and	 eax, 1
  000dd	c1 e0 15	 shl	 eax, 21			; 00000015H
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  000e6	81 e1 ff ff df
	ff		 and	 ecx, -2097153		; ffdfffffH
  000ec	0b c8		 or	 ecx, eax
  000ee	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3591 : 		WIN_CPUInfo.ALPHAbyte  = pfnCPUID( 5); //PF_ALPHA_BYTE_INSTRUCTIONS

  000f4	6a 05		 push	 5
  000f6	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  000f9	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  000fc	8b 45 94	 mov	 eax, DWORD PTR tv142[ebp]
  000ff	83 e0 01	 and	 eax, 1
  00102	c1 e0 16	 shl	 eax, 22			; 00000016H
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  0010b	81 e1 ff ff bf
	ff		 and	 ecx, -4194305		; ffbfffffH
  00111	0b c8		 or	 ecx, eax
  00113	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3592 : 		WIN_CPUInfo.SSE        = pfnCPUID( 6); //PF_XMMI_INSTRUCTIONS_AVAILABLE

  00119	6a 06		 push	 6
  0011b	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  0011e	89 45 94	 mov	 DWORD PTR tv149[ebp], eax
  00121	8b 45 94	 mov	 eax, DWORD PTR tv149[ebp]
  00124	83 e0 01	 and	 eax, 1
  00127	c1 e0 08	 shl	 eax, 8
  0012a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00130	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  00136	0b c8		 or	 ecx, eax
  00138	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3593 : 		WIN_CPUInfo.AMD3DNow   = pfnCPUID( 7); //PF_3DNOW_INSTRUCTIONS_AVAILABLE

  0013e	6a 07		 push	 7
  00140	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00143	89 45 94	 mov	 DWORD PTR tv156[ebp], eax
  00146	8b 45 94	 mov	 eax, DWORD PTR tv156[ebp]
  00149	83 e0 01	 and	 eax, 1
  0014c	c1 e0 06	 shl	 eax, 6
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00155	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  00158	0b c8		 or	 ecx, eax
  0015a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3594 : 		WIN_CPUInfo.RDTSC      = pfnCPUID( 8); //PF_RDTSC_INSTRUCTION_AVAILABLE

  00160	6a 08		 push	 8
  00162	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00165	89 45 94	 mov	 DWORD PTR tv163[ebp], eax
  00168	8b 45 94	 mov	 eax, DWORD PTR tv163[ebp]
  0016b	83 e0 01	 and	 eax, 1
  0016e	c1 e0 02	 shl	 eax, 2
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00177	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0017a	0b c8		 or	 ecx, eax
  0017c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3595 : 		WIN_CPUInfo.PAE        = pfnCPUID( 9); //PF_PAE_ENABLED

  00182	6a 09		 push	 9
  00184	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00187	89 45 94	 mov	 DWORD PTR tv170[ebp], eax
  0018a	8b 45 94	 mov	 eax, DWORD PTR tv170[ebp]
  0018d	83 e0 01	 and	 eax, 1
  00190	c1 e0 17	 shl	 eax, 23			; 00000017H
  00193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00199	81 e1 ff ff 7f
	ff		 and	 ecx, -8388609		; ff7fffffH
  0019f	0b c8		 or	 ecx, eax
  001a1	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3596 : 		WIN_CPUInfo.SSE2       = pfnCPUID(10); //PF_XMMI64_INSTRUCTIONS_AVAILABLE

  001a7	6a 0a		 push	 10			; 0000000aH
  001a9	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  001ac	89 45 94	 mov	 DWORD PTR tv177[ebp], eax
  001af	8b 45 94	 mov	 eax, DWORD PTR tv177[ebp]
  001b2	83 e0 01	 and	 eax, 1
  001b5	c1 e0 09	 shl	 eax, 9
  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  001be	81 e1 ff fd ff
	ff		 and	 ecx, -513		; fffffdffH
  001c4	0b c8		 or	 ecx, eax
  001c6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3597 : 		//WIN_CPUInfo.blank    = pfnCPUID(11); //PF_SSE_DAZ_MODE_AVAILABLE
; 3598 : 		WIN_CPUInfo.DEP        = pfnCPUID(12); //PF_NX_ENABLED

  001cc	6a 0c		 push	 12			; 0000000cH
  001ce	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  001d1	89 45 94	 mov	 DWORD PTR tv184[ebp], eax
  001d4	8b 45 94	 mov	 eax, DWORD PTR tv184[ebp]
  001d7	83 e0 01	 and	 eax, 1
  001da	c1 e0 14	 shl	 eax, 20			; 00000014H
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  001e3	81 e1 ff ff ef
	ff		 and	 ecx, -1048577		; ffefffffH
  001e9	0b c8		 or	 ecx, eax
  001eb	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3599 : 		WIN_CPUInfo.SSE3       = pfnCPUID(13); //PF_SSE3_INSTRUCTIONS_AVAILABLE

  001f1	6a 0d		 push	 13			; 0000000dH
  001f3	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  001f6	89 45 94	 mov	 DWORD PTR tv191[ebp], eax
  001f9	8b 45 94	 mov	 eax, DWORD PTR tv191[ebp]
  001fc	83 e0 01	 and	 eax, 1
  001ff	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00202	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00208	81 e1 ff fb ff
	ff		 and	 ecx, -1025		; fffffbffH
  0020e	0b c8		 or	 ecx, eax
  00210	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3600 : 		WIN_CPUInfo.cmpxchg16b = pfnCPUID(14); //PF_COMPARE_EXCHANGE128

  00216	6a 0e		 push	 14			; 0000000eH
  00218	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  0021b	89 45 94	 mov	 DWORD PTR tv198[ebp], eax
  0021e	8b 45 94	 mov	 eax, DWORD PTR tv198[ebp]
  00221	83 e0 01	 and	 eax, 1
  00224	c1 e0 11	 shl	 eax, 17			; 00000011H
  00227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  0022d	81 e1 ff ff fd
	ff		 and	 ecx, -131073		; fffdffffH
  00233	0b c8		 or	 ecx, eax
  00235	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3601 : 		WIN_CPUInfo.cmp8xchg16 = pfnCPUID(15); //PF_COMPARE64_EXCHANGE128

  0023b	6a 0f		 push	 15			; 0000000fH
  0023d	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00240	89 45 94	 mov	 DWORD PTR tv205[ebp], eax
  00243	8b 45 94	 mov	 eax, DWORD PTR tv205[ebp]
  00246	83 e0 01	 and	 eax, 1
  00249	c1 e0 12	 shl	 eax, 18			; 00000012H
  0024c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00252	81 e1 ff ff fb
	ff		 and	 ecx, -262145		; fffbffffH
  00258	0b c8		 or	 ecx, eax
  0025a	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3602 : 		WIN_CPUInfo.PFC        = pfnCPUID(16); //PF_CHANNELS_ENABLED

  00260	6a 10		 push	 16			; 00000010H
  00262	ff 55 d8	 call	 DWORD PTR _pfnCPUID$[ebp]
  00265	89 45 94	 mov	 DWORD PTR tv212[ebp], eax
  00268	8b 45 94	 mov	 eax, DWORD PTR tv212[ebp]
  0026b	83 e0 01	 and	 eax, 1
  0026e	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00271	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  00277	81 e1 ff 7f ff
	ff		 and	 ecx, -32769		; ffff7fffH
  0027d	0b c8		 or	 ecx, eax
  0027f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx
$LN2@I_CPUInfo:

; 3603 : 	}
; 3604 : 	GetSystemInfo(&SI);

  00285	8d 45 dc	 lea	 eax, DWORD PTR _SI$[ebp]
  00288	50		 push	 eax
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4
  0028f	90		 npad	 1

; 3605 : 	WIN_CPUInfo.CPUs = SI.dwNumberOfProcessors;

  00290	8b 45 f0	 mov	 eax, DWORD PTR _SI$[ebp+20]
  00293	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00298	c1 e0 18	 shl	 eax, 24			; 00000018H
  0029b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  002a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  002a7	0b c8		 or	 ecx, eax
  002a9	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3606 : 	WIN_CPUInfo.IA64 = (SI.dwProcessorType == 2200); // PROCESSOR_INTEL_IA64

  002af	81 7d f4 98 08
	00 00		 cmp	 DWORD PTR _SI$[ebp+24], 2200 ; 00000898H
  002b6	75 09		 jne	 SHORT $LN4@I_CPUInfo
  002b8	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv223[ebp], 1
  002bf	eb 07		 jmp	 SHORT $LN5@I_CPUInfo
$LN4@I_CPUInfo:
  002c1	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv223[ebp], 0
$LN5@I_CPUInfo:
  002c8	8b 45 94	 mov	 eax, DWORD PTR tv223[ebp]
  002cb	83 e0 01	 and	 eax, 1
  002ce	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  002d7	81 e1 ff f7 ff
	ff		 and	 ecx, -2049		; fffff7ffH
  002dd	0b c8		 or	 ecx, eax
  002df	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3607 : 	WIN_CPUInfo.AMD64 = (SI.dwProcessorType == 8664); // PROCESSOR_AMD_X8664

  002e5	81 7d f4 d8 21
	00 00		 cmp	 DWORD PTR _SI$[ebp+24], 8664 ; 000021d8H
  002ec	75 09		 jne	 SHORT $LN6@I_CPUInfo
  002ee	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv229[ebp], 1
  002f5	eb 07		 jmp	 SHORT $LN7@I_CPUInfo
$LN6@I_CPUInfo:
  002f7	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv229[ebp], 0
$LN7@I_CPUInfo:
  002fe	8b 45 94	 mov	 eax, DWORD PTR tv229[ebp]
  00301	83 e0 01	 and	 eax, 1
  00304	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00307	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9
  0030d	81 e1 ff ef ff
	ff		 and	 ecx, -4097		; ffffefffH
  00313	0b c8		 or	 ecx, eax
  00315	89 0d 00 00 00
	00		 mov	 DWORD PTR ?WIN_CPUInfo@?1??I_CPUInfo@@9@9, ecx

; 3608 : 	return &WIN_CPUInfo;

  0031b	b8 00 00 00 00	 mov	 eax, OFFSET ?WIN_CPUInfo@?1??I_CPUInfo@@9@9

; 3609 : }

  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
  00322	5b		 pop	 ebx
  00323	8b e5		 mov	 esp, ebp
  00325	5d		 pop	 ebp
  00326	c3		 ret	 0
_I_CPUInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_mkdir
_TEXT	SEGMENT
_dirname$ = 8						; size = 4
_unixright$ = 12					; size = 4
_I_mkdir PROC						; COMDAT

; 3560 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3561 : 	UNREFERENCED_PARAMETER(unixright); /// \todo should implement ntright under nt...
; 3562 : 	return CreateDirectoryA(dirname, NULL);

  00009	6a 00		 push	 0
  0000b	8b 45 08	 mov	 eax, DWORD PTR _dirname$[ebp]
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 3563 : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_I_mkdir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetUserName
_TEXT	SEGMENT
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_I_GetUserName PROC					; COMDAT

; 3527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3528 : 	static char username[MAXPLAYERNAME+1];
; 3529 : 	char *p;
; 3530 : 	DWORD i = MAXPLAYERNAME;

  00009	c7 45 f8 15 00
	00 00		 mov	 DWORD PTR _i$[ebp], 21	; 00000015H

; 3531 : 
; 3532 : 	if (!GetUserNameA(username, &i))

  00010	8d 45 f8	 lea	 eax, DWORD PTR _i$[ebp]
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET ?username@?1??I_GetUserName@@9@9
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetUserNameA@8
  0001f	85 c0		 test	 eax, eax
  00021	75 6f		 jne	 SHORT $LN2@I_GetUserN

; 3533 : 	{
; 3534 : 		p = getenv("USER");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_04OOEKJIOI@USER@
  00028	e8 00 00 00 00	 call	 _getenv
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 3535 : 		if (!p)

  00033	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  00037	75 46		 jne	 SHORT $LN6@I_GetUserN

; 3536 : 		{
; 3537 : 			p = getenv("user");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_04CCHAHKJA@user@
  0003e	e8 00 00 00 00	 call	 _getenv
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 3538 : 			if (!p)

  00049	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0004d	75 30		 jne	 SHORT $LN6@I_GetUserN

; 3539 : 			{
; 3540 : 				p = getenv("USERNAME");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_08JMMIJEMM@USERNAME@
  00054	e8 00 00 00 00	 call	 _getenv
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 3541 : 				if (!p)

  0005f	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  00063	75 1a		 jne	 SHORT $LN6@I_GetUserN

; 3542 : 				{
; 3543 : 					p = getenv("username");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_08ODGEKKOL@username@
  0006a	e8 00 00 00 00	 call	 _getenv
  0006f	83 c4 04	 add	 esp, 4
  00072	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 3544 : 					if (!p)

  00075	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  00079	75 04		 jne	 SHORT $LN6@I_GetUserN

; 3545 : 					{
; 3546 : 						return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 2d		 jmp	 SHORT $LN1@I_GetUserN
$LN6@I_GetUserN:

; 3547 : 					}
; 3548 : 				}
; 3549 : 			}
; 3550 : 		}
; 3551 : 		strlcpy(username, p, sizeof (username));

  0007f	6a 16		 push	 22			; 00000016H
  00081	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00084	50		 push	 eax
  00085	68 00 00 00 00	 push	 OFFSET ?username@?1??I_GetUserName@@9@9
  0008a	e8 00 00 00 00	 call	 _strlcpy
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@I_GetUserN:

; 3552 : 	}
; 3553 : 
; 3554 : 	if (!strlen(username))

  00092	68 00 00 00 00	 push	 OFFSET ?username@?1??I_GetUserName@@9@9
  00097	e8 00 00 00 00	 call	 _strlen
  0009c	83 c4 04	 add	 esp, 4
  0009f	85 c0		 test	 eax, eax
  000a1	75 04		 jne	 SHORT $LN7@I_GetUserN

; 3555 : 		return NULL;

  000a3	33 c0		 xor	 eax, eax
  000a5	eb 05		 jmp	 SHORT $LN1@I_GetUserN
$LN7@I_GetUserN:

; 3556 : 	return username;

  000a7	b8 00 00 00 00	 mov	 eax, OFFSET ?username@?1??I_GetUserName@@9@9
$LN1@I_GetUserN:

; 3557 : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_I_GetUserName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetDiskFreeSpace
_TEXT	SEGMENT
_TotalNumberOfClusters$1 = -32				; size = 4
_NumberOfFreeClusters$2 = -28				; size = 4
_BytesPerSector$3 = -24					; size = 4
_SectorsPerCluster$4 = -20				; size = 4
_lfreespace$ = -16					; size = 8
_usedbytes$ = -8					; size = 8
_freespace$ = 8						; size = 4
_I_GetDiskFreeSpace PROC				; COMDAT

; 3500 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3501 : 	static p_GetDiskFreeSpaceExA pfnGetDiskFreeSpaceEx = NULL;
; 3502 : 	static boolean testwin95 = false;
; 3503 : 	ULARGE_INTEGER usedbytes, lfreespace;
; 3504 : 
; 3505 : 	if (!testwin95)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?testwin95@?1??I_GetDiskFreeSpace@@9@9, 0
  00010	75 26		 jne	 SHORT $LN2@I_GetDiskF

; 3506 : 	{
; 3507 : 		pfnGetDiskFreeSpaceEx = (p_GetDiskFreeSpaceExA)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetDiskFreeSpaceExA");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GEACJGAH@GetDiskFreeSpaceExA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00029	a3 00 00 00 00	 mov	 DWORD PTR ?pfnGetDiskFreeSpaceEx@?1??I_GetDiskFreeSpace@@9@9, eax

; 3508 : 		testwin95 = true;

  0002e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?testwin95@?1??I_GetDiskFreeSpace@@9@9, 1
$LN2@I_GetDiskF:

; 3509 : 	}
; 3510 : 	if (pfnGetDiskFreeSpaceEx)

  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pfnGetDiskFreeSpaceEx@?1??I_GetDiskFreeSpace@@9@9, 0
  0003f	74 36		 je	 SHORT $LN3@I_GetDiskF

; 3511 : 	{
; 3512 : 		if (pfnGetDiskFreeSpaceEx(NULL, &lfreespace, &usedbytes, NULL))

  00041	6a 00		 push	 0
  00043	8d 45 f8	 lea	 eax, DWORD PTR _usedbytes$[ebp]
  00046	50		 push	 eax
  00047	8d 4d f0	 lea	 ecx, DWORD PTR _lfreespace$[ebp]
  0004a	51		 push	 ecx
  0004b	6a 00		 push	 0
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?pfnGetDiskFreeSpaceEx@?1??I_GetDiskFreeSpace@@9@9
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN5@I_GetDiskF

; 3513 : 			*freespace = lfreespace.QuadPart;

  00057	8b 45 08	 mov	 eax, DWORD PTR _freespace$[ebp]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _lfreespace$[ebp]
  0005d	8b 55 f4	 mov	 edx, DWORD PTR _lfreespace$[ebp+4]
  00060	89 08		 mov	 DWORD PTR [eax], ecx
  00062	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00065	eb 0e		 jmp	 SHORT $LN6@I_GetDiskF
$LN5@I_GetDiskF:

; 3514 : 		else
; 3515 : 			*freespace = INT32_MAX;

  00067	8b 45 08	 mov	 eax, DWORD PTR _freespace$[ebp]
  0006a	33 c9		 xor	 ecx, ecx
  0006c	c7 00 ff ff ff
	7f		 mov	 DWORD PTR [eax], 2147483647 ; 7fffffffH
  00072	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN6@I_GetDiskF:

; 3516 : 	}

  00075	eb 2e		 jmp	 SHORT $LN4@I_GetDiskF
$LN3@I_GetDiskF:

; 3517 : 	else
; 3518 : 	{
; 3519 : 		DWORD SectorsPerCluster, BytesPerSector, NumberOfFreeClusters, TotalNumberOfClusters;
; 3520 : 		GetDiskFreeSpace(NULL, &SectorsPerCluster, &BytesPerSector,

  00077	8d 45 e0	 lea	 eax, DWORD PTR _TotalNumberOfClusters$1[ebp]
  0007a	50		 push	 eax
  0007b	8d 4d e4	 lea	 ecx, DWORD PTR _NumberOfFreeClusters$2[ebp]
  0007e	51		 push	 ecx
  0007f	8d 55 e8	 lea	 edx, DWORD PTR _BytesPerSector$3[ebp]
  00082	52		 push	 edx
  00083	8d 45 ec	 lea	 eax, DWORD PTR _SectorsPerCluster$4[ebp]
  00086	50		 push	 eax
  00087	6a 00		 push	 0
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDiskFreeSpaceA@20
  0008f	90		 npad	 1

; 3521 : 			&NumberOfFreeClusters, &TotalNumberOfClusters);
; 3522 : 		*freespace = BytesPerSector * SectorsPerCluster * NumberOfFreeClusters;

  00090	8b 45 e8	 mov	 eax, DWORD PTR _BytesPerSector$3[ebp]
  00093	0f af 45 ec	 imul	 eax, DWORD PTR _SectorsPerCluster$4[ebp]
  00097	0f af 45 e4	 imul	 eax, DWORD PTR _NumberOfFreeClusters$2[ebp]
  0009b	33 c9		 xor	 ecx, ecx
  0009d	8b 55 08	 mov	 edx, DWORD PTR _freespace$[ebp]
  000a0	89 02		 mov	 DWORD PTR [edx], eax
  000a2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN4@I_GetDiskF:

; 3523 : 	}
; 3524 : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_I_GetDiskFreeSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_ShutdownSystem
_TEXT	SEGMENT
_c$ = -4						; size = 4
_I_ShutdownSystem PROC					; COMDAT

; 3488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3489 : 	int c;
; 3490 : 
; 3491 : 	for (c = MAX_QUIT_FUNCS - 1; c >= 0; c--)

  00009	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR _c$[ebp], 15	; 0000000fH
  00010	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00015	83 e8 01	 sub	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
$LN4@I_Shutdown:
  0001b	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0001f	7c 1c		 jl	 SHORT $LN3@I_Shutdown

; 3492 : 		if (quit_funcs[c])

  00021	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00024	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _quit_funcs[eax*4], 0
  0002c	74 0d		 je	 SHORT $LN5@I_Shutdown

; 3493 : 			(*quit_funcs[c])();

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00031	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _quit_funcs[eax*4]
  00038	ff d1		 call	 ecx
  0003a	90		 npad	 1
$LN5@I_Shutdown:
  0003b	eb d5		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 3494 : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_I_ShutdownSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_StartupSystem
_TEXT	SEGMENT
tv79 = -80						; size = 4
_sErr$1 = -12						; size = 4
_myInstance$ = -8					; size = 4
_hr$ = -4						; size = 4
_I_StartupSystem PROC					; COMDAT

; 3403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3404 : 	HRESULT hr;
; 3405 : 	HINSTANCE myInstance = GetModuleHandle(NULL);

  00009	6a 00		 push	 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00011	89 45 f8	 mov	 DWORD PTR _myInstance$[ebp], eax

; 3406 : 
; 3407 : 	// some 'more global than globals' things to initialize here ?
; 3408 : 	graphics_started = keyboard_started = sound_started = cdaudio_started = false;

  00014	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _cdaudio_started, 0
  0001b	a0 00 00 00 00	 mov	 al, BYTE PTR _cdaudio_started
  00020	a2 00 00 00 00	 mov	 BYTE PTR _sound_started, al
  00025	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _sound_started
  0002b	88 0d 00 00 00
	00		 mov	 BYTE PTR _keyboard_started, cl
  00031	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR _keyboard_started
  00037	88 15 00 00 00
	00		 mov	 BYTE PTR _graphics_started, dl

; 3409 : 
; 3410 : 	I_DetectWin9x();

  0003d	e8 00 00 00 00	 call	 _I_DetectWin9x
  00042	90		 npad	 1

; 3411 : 
; 3412 : 	// check for OS type and version here?
; 3413 : #ifdef NDEBUG
; 3414 : 
; 3415 : #ifdef BUGTRAP
; 3416 : 	if(!IsBugTrapLoaded())
; 3417 : 	{
; 3418 : #endif
; 3419 : 		signal(SIGABRT, signal_handler);
; 3420 : 		signal(SIGFPE, signal_handler);
; 3421 : 		signal(SIGILL, signal_handler);
; 3422 : 		signal(SIGSEGV, signal_handler);
; 3423 : 		signal(SIGTERM, signal_handler);
; 3424 : 		signal(SIGINT, signal_handler);
; 3425 : #ifdef BUGTRAP
; 3426 : 	}
; 3427 : #endif
; 3428 : 
; 3429 : #endif
; 3430 : 
; 3431 : 	I_SetupMumble();

  00043	e8 00 00 00 00	 call	 _I_SetupMumble
  00048	90		 npad	 1

; 3432 : 
; 3433 : 	if (!pfnDirectInputCreateA)

  00049	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnDirectInputCreateA, 0
  00050	75 0a		 jne	 SHORT $LN4@I_StartupS

; 3434 : 		return 1;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	e9 e8 00 00 00	 jmp	 $LN1@I_StartupS
$LN4@I_StartupS:

; 3435 : 	// create DirectInput - so that I_StartupKeyboard/Mouse can be called later on
; 3436 : 	// from D_SRB2Main just like DOS version
; 3437 : 	hr = pfnDirectInputCreateA(myInstance, DIRECTINPUT_VERSION, &lpDI, NULL);

  0005c	6a 00		 push	 0
  0005e	68 00 00 00 00	 push	 OFFSET _lpDI
  00063	68 00 05 00 00	 push	 1280			; 00000500H
  00068	8b 45 f8	 mov	 eax, DWORD PTR _myInstance$[ebp]
  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnDirectInputCreateA
  00072	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3438 : 
; 3439 : 	if (SUCCEEDED(hr))

  00075	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00079	7c 0f		 jl	 SHORT $LN5@I_StartupS

; 3440 : 		bDX0300 = FALSE;

  0007b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDX0300, 0
  00085	e9 ab 00 00 00	 jmp	 $LN6@I_StartupS
$LN5@I_StartupS:

; 3441 : 	else
; 3442 : 	{
; 3443 : 		// try opening DirectX3 interface for NT compatibility
; 3444 : 		hr = pfnDirectInputCreateA(myInstance, DXVERSION_NTCOMPATIBLE, &lpDI, NULL);

  0008a	6a 00		 push	 0
  0008c	68 00 00 00 00	 push	 OFFSET _lpDI
  00091	68 00 03 00 00	 push	 768			; 00000300H
  00096	8b 45 f8	 mov	 eax, DWORD PTR _myInstance$[ebp]
  00099	50		 push	 eax
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnDirectInputCreateA
  000a0	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3445 : 
; 3446 : 		if (FAILED(hr))

  000a3	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a7	7d 75		 jge	 SHORT $LN7@I_StartupS

; 3447 : 		{
; 3448 : 			const char *sErr;
; 3449 : 			switch (hr)

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  000ac	89 45 b0	 mov	 DWORD PTR tv79[ebp], eax
  000af	81 7d b0 7e 04
	07 80		 cmp	 DWORD PTR tv79[ebp], -2147023746 ; 8007047eH
  000b6	7f 1d		 jg	 SHORT $LN15@I_StartupS
  000b8	81 7d b0 7e 04
	07 80		 cmp	 DWORD PTR tv79[ebp], -2147023746 ; 8007047eH
  000bf	74 31		 je	 SHORT $LN11@I_StartupS
  000c1	81 7d b0 0e 00
	07 80		 cmp	 DWORD PTR tv79[ebp], -2147024882 ; 8007000eH
  000c8	74 31		 je	 SHORT $LN12@I_StartupS
  000ca	81 7d b0 57 00
	07 80		 cmp	 DWORD PTR tv79[ebp], -2147024809 ; 80070057H
  000d1	74 16		 je	 SHORT $LN10@I_StartupS
  000d3	eb 2f		 jmp	 SHORT $LN13@I_StartupS
$LN15@I_StartupS:
  000d5	81 7d b0 81 04
	07 80		 cmp	 DWORD PTR tv79[ebp], -2147023743 ; 80070481H
  000dc	74 02		 je	 SHORT $LN9@I_StartupS
  000de	eb 24		 jmp	 SHORT $LN13@I_StartupS
$LN9@I_StartupS:

; 3450 : 			{
; 3451 : 				case DIERR_BETADIRECTINPUTVERSION:
; 3452 : 					sErr = "DIERR_BETADIRECTINPUTVERSION";

  000e0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sErr$1[ebp], OFFSET ??_C@_0BN@FFKALFMN@DIERR_BETADIRECTINPUTVERSION@

; 3453 : 					break;

  000e7	eb 22		 jmp	 SHORT $LN2@I_StartupS
$LN10@I_StartupS:

; 3454 : 				case DIERR_INVALIDPARAM:
; 3455 : 					sErr = "DIERR_INVALIDPARAM";

  000e9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sErr$1[ebp], OFFSET ??_C@_0BD@PCBHGFBD@DIERR_INVALIDPARAM@

; 3456 : 					break;

  000f0	eb 19		 jmp	 SHORT $LN2@I_StartupS
$LN11@I_StartupS:

; 3457 : 				case DIERR_OLDDIRECTINPUTVERSION :
; 3458 : 					sErr = "DIERR_OLDDIRECTINPUTVERSION";

  000f2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sErr$1[ebp], OFFSET ??_C@_0BM@FGIBEKPK@DIERR_OLDDIRECTINPUTVERSION@

; 3459 : 					break;

  000f9	eb 10		 jmp	 SHORT $LN2@I_StartupS
$LN12@I_StartupS:

; 3460 : 				case DIERR_OUTOFMEMORY:
; 3461 : 					sErr = "DIERR_OUTOFMEMORY";

  000fb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sErr$1[ebp], OFFSET ??_C@_0BC@IHLCNKJJ@DIERR_OUTOFMEMORY@

; 3462 : 					break;

  00102	eb 07		 jmp	 SHORT $LN2@I_StartupS
$LN13@I_StartupS:

; 3463 : 				default:
; 3464 : 					sErr = "UNKNOWN";

  00104	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sErr$1[ebp], OFFSET ??_C@_07NFANNNEC@UNKNOWN@
$LN2@I_StartupS:

; 3465 : 					break;
; 3466 : 			}
; 3467 : 			I_Error("Couldn't create DirectInput (reason: %s)", sErr);

  0010b	8b 45 f4	 mov	 eax, DWORD PTR _sErr$1[ebp]
  0010e	50		 push	 eax
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@PIDEDPNF@Couldn?8t?5create?5DirectInput?5?$CIre@
  00114	e8 00 00 00 00	 call	 _I_Error
  00119	83 c4 08	 add	 esp, 8

; 3468 : 		}

  0011c	eb 0d		 jmp	 SHORT $LN8@I_StartupS
$LN7@I_StartupS:

; 3469 : 		else
; 3470 : 			CONS_Printf("\2Using DirectX3 interface\n");

  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MOBEGLHJ@?$ACUsing?5DirectX3?5interface?6@
  00123	e8 00 00 00 00	 call	 _CONS_Printf
  00128	83 c4 04	 add	 esp, 4
$LN8@I_StartupS:

; 3471 : 
; 3472 : 		// only use DirectInput3 compatible structures and calls
; 3473 : 		bDX0300 = TRUE;

  0012b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bDX0300, 1
$LN6@I_StartupS:

; 3474 : 	}
; 3475 : 	I_AddExitFunc(I_ShutdownDirectInput);

  00135	68 00 00 00 00	 push	 OFFSET _I_ShutdownDirectInput
  0013a	e8 00 00 00 00	 call	 _I_AddExitFunc
  0013f	83 c4 04	 add	 esp, 4

; 3476 : 	return 0;

  00142	33 c0		 xor	 eax, eax
$LN1@I_StartupS:

; 3477 : }

  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
_I_StartupSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_RemoveExitFunc
_TEXT	SEGMENT
_c$ = -4						; size = 4
_func$ = 8						; size = 4
_I_RemoveExitFunc PROC					; COMDAT

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 847  : 	int c;
; 848  : 
; 849  : 	for (c = 0; c < MAX_QUIT_FUNCS; c++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@I_RemoveEx
$LN2@I_RemoveEx:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
$LN4@I_RemoveEx:
  0001b	83 7d fc 10	 cmp	 DWORD PTR _c$[ebp], 16	; 00000010H
  0001f	7d 4a		 jge	 SHORT $LN3@I_RemoveEx

; 850  : 	{
; 851  : 		if (quit_funcs[c] == func)

  00021	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00024	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _quit_funcs[eax*4]
  0002b	3b 4d 08	 cmp	 ecx, DWORD PTR _func$[ebp]
  0002e	75 39		 jne	 SHORT $LN7@I_RemoveEx
$LN5@I_RemoveEx:

; 852  : 		{
; 853  : 			while (c < MAX_QUIT_FUNCS - 1)

  00030	83 7d fc 0f	 cmp	 DWORD PTR _c$[ebp], 15	; 0000000fH
  00034	7d 1f		 jge	 SHORT $LN6@I_RemoveEx

; 854  : 			{
; 855  : 				quit_funcs[c] = quit_funcs[c+1];

  00036	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0003c	8b 14 8d 04 00
	00 00		 mov	 edx, DWORD PTR _quit_funcs[ecx*4+4]
  00043	89 14 85 00 00
	00 00		 mov	 DWORD PTR _quit_funcs[eax*4], edx

; 856  : 				c++;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0004d	83 c0 01	 add	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 857  : 			}

  00053	eb db		 jmp	 SHORT $LN5@I_RemoveEx
$LN6@I_RemoveEx:

; 858  : 			quit_funcs[MAX_QUIT_FUNCS-1] = NULL;

  00055	b8 04 00 00 00	 mov	 eax, 4
  0005a	6b c8 0f	 imul	 ecx, eax, 15
  0005d	c7 81 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _quit_funcs[ecx], 0

; 859  : 			break;

  00067	eb 02		 jmp	 SHORT $LN3@I_RemoveEx
$LN7@I_RemoveEx:

; 860  : 		}
; 861  : 	}

  00069	eb a7		 jmp	 SHORT $LN2@I_RemoveEx
$LN3@I_RemoveEx:

; 862  : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_I_RemoveExitFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_AddExitFunc
_TEXT	SEGMENT
_c$ = -4						; size = 4
_func$ = 8						; size = 4
_I_AddExitFunc PROC					; COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 831  : 	int c;
; 832  : 
; 833  : 	for (c = 0; c < MAX_QUIT_FUNCS; c++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@I_AddExitF
$LN2@I_AddExitF:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
$LN4@I_AddExitF:
  0001b	83 7d fc 10	 cmp	 DWORD PTR _c$[ebp], 16	; 00000010H
  0001f	7d 1e		 jge	 SHORT $LN3@I_AddExitF

; 834  : 	{
; 835  : 		if (!quit_funcs[c])

  00021	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00024	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _quit_funcs[eax*4], 0
  0002c	75 0f		 jne	 SHORT $LN5@I_AddExitF

; 836  : 		{
; 837  : 			quit_funcs[c] = func;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _func$[ebp]
  00034	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _quit_funcs[eax*4], ecx

; 838  : 			break;

  0003b	eb 02		 jmp	 SHORT $LN3@I_AddExitF
$LN5@I_AddExitF:

; 839  : 		}
; 840  : 	}

  0003d	eb d3		 jmp	 SHORT $LN2@I_AddExitF
$LN3@I_AddExitF:

; 841  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_I_AddExitFunc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_StartupTimer
_TEXT	SEGMENT
_I_StartupTimer PROC					; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 456  : 	// for win2k time bug
; 457  : 	if (M_CheckParm("-gettickcount"))

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MBBOFCJA@?9gettickcount@
  0000e	e8 00 00 00 00	 call	 _M_CheckParm
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	74 18		 je	 SHORT $LN2@I_StartupT

; 458  : 	{
; 459  : 		starttickcount = GetTickCount();

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00020	a3 00 00 00 00	 mov	 DWORD PTR _starttickcount, eax

; 460  : 		CONS_Printf("Using GetTickCount()\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CHODMMMD@Using?5GetTickCount?$CI?$CJ?6@
  0002a	e8 00 00 00 00	 call	 _CONS_Printf
  0002f	83 c4 04	 add	 esp, 4
$LN2@I_StartupT:

; 461  : 	}
; 462  : 	timeBeginPeriod(1);

  00032	6a 01		 push	 1
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4
  0003a	90		 npad	 1

; 463  : 	I_AddExitFunc(I_ShutdownTimer);

  0003b	68 00 00 00 00	 push	 OFFSET _I_ShutdownTimer
  00040	e8 00 00 00 00	 call	 _I_AddExitFunc
  00045	83 c4 04	 add	 esp, 4

; 464  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_I_StartupTimer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_StartupKeyboard
_TEXT	SEGMENT
_dip$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_I_StartupKeyboard PROC					; COMDAT

; 3175 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3176 : 	DIPROPDWORD dip;
; 3177 : 
; 3178 : 	if (dedicated || !lpDI)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0001a	75 09		 jne	 SHORT $LN3@I_StartupK
  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDI, 0
  00023	75 05		 jne	 SHORT $LN2@I_StartupK
$LN3@I_StartupK:

; 3179 : 		return;

  00025	e9 45 01 00 00	 jmp	 $LN1@I_StartupK
$LN2@I_StartupK:

; 3180 : 
; 3181 : 	// make sure the app window has the focus or DirectInput acquire keyboard won't work
; 3182 : 	if (hWndMain)

  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hWndMain, 0
  00031	74 29		 je	 SHORT $LN4@I_StartupK

; 3183 : 	{
; 3184 : 		SetFocus(hWndMain);

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
  0003f	90		 npad	 1

; 3185 : 		ShowWindow(hWndMain, SW_SHOW);

  00040	6a 05		 push	 5
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
  0004e	90		 npad	 1

; 3186 : 		UpdateWindow(hWndMain);

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4
  0005b	90		 npad	 1
$LN4@I_StartupK:

; 3187 : 	}
; 3188 : 
; 3189 : 	// detect error
; 3190 : 	if (lpDIK)

  0005c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIK, 0
  00063	74 12		 je	 SHORT $LN5@I_StartupK

; 3191 : 	{
; 3192 : 		CONS_Printf("\2I_StartupKeyboard(): called twice\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BOBKPIDJ@?$ACI_StartupKeyboard?$CI?$CJ?3?5called?5tw@
  0006a	e8 00 00 00 00	 call	 _CONS_Printf
  0006f	83 c4 04	 add	 esp, 4

; 3193 : 		return;

  00072	e9 f8 00 00 00	 jmp	 $LN1@I_StartupK
$LN5@I_StartupK:

; 3194 : 	}
; 3195 : 
; 3196 : 	CreateDevice2A(lpDI, &GUID_SysKeyboard, &lpDIK, NULL);

  00077	6a 00		 push	 0
  00079	68 00 00 00 00	 push	 OFFSET _lpDIK
  0007e	68 00 00 00 00	 push	 OFFSET _GUID_SysKeyboard
  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _CreateDevice2A
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 3197 : 
; 3198 : 	if (lpDIK)

  00091	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIK, 0
  00098	0f 84 a6 00 00
	00		 je	 $LN6@I_StartupK

; 3199 : 	{
; 3200 : 		if (FAILED(IDirectInputDevice_SetDataFormat(lpDIK, &c_dfDIKeyboard)))

  0009e	68 00 00 00 00	 push	 OFFSET _c_dfDIKeyboard
  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIK
  000a8	50		 push	 eax
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIK
  000af	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b1	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000b4	ff d0		 call	 eax
  000b6	85 c0		 test	 eax, eax
  000b8	7d 0d		 jge	 SHORT $LN8@I_StartupK

; 3201 : 			I_Error("Couldn't set keyboard data format");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@CMFDNOIJ@Couldn?8t?5set?5keyboard?5data?5form@
  000bf	e8 00 00 00 00	 call	 _I_Error
  000c4	83 c4 04	 add	 esp, 4
$LN8@I_StartupK:

; 3202 : 
; 3203 : 		// create buffer for buffered data
; 3204 : 		dip.diph.dwSize = sizeof (dip);

  000c7	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _dip$[ebp], 20 ; 00000014H

; 3205 : 		dip.diph.dwHeaderSize = sizeof (dip.diph);

  000ce	c7 45 ec 10 00
	00 00		 mov	 DWORD PTR _dip$[ebp+4], 16 ; 00000010H

; 3206 : 		dip.diph.dwObj = 0;

  000d5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dip$[ebp+8], 0

; 3207 : 		dip.diph.dwHow = DIPH_DEVICE;

  000dc	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dip$[ebp+12], 0

; 3208 : 		dip.dwData = DI_KEYBOARD_BUFFERSIZE;

  000e3	c7 45 f8 20 00
	00 00		 mov	 DWORD PTR _dip$[ebp+16], 32 ; 00000020H

; 3209 : 		if (FAILED(IDirectInputDevice_SetProperty(lpDIK, DIPROP_BUFFERSIZE, &dip.diph)))

  000ea	8d 45 e8	 lea	 eax, DWORD PTR _dip$[ebp]
  000ed	50		 push	 eax
  000ee	6a 01		 push	 1
  000f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIK
  000f6	51		 push	 ecx
  000f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIK
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00102	ff d1		 call	 ecx
  00104	85 c0		 test	 eax, eax
  00106	7d 0d		 jge	 SHORT $LN9@I_StartupK

; 3210 : 			I_Error("Couldn't set keyboard buffer size");

  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GHDBONLH@Couldn?8t?5set?5keyboard?5buffer?5si@
  0010d	e8 00 00 00 00	 call	 _I_Error
  00112	83 c4 04	 add	 esp, 4
$LN9@I_StartupK:

; 3211 : 
; 3212 : 		if (FAILED(IDirectInputDevice_SetCooperativeLevel(lpDIK, hWndMain,

  00115	6a 06		 push	 6
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  0011c	50		 push	 eax
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIK
  00123	51		 push	 ecx
  00124	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIK
  0012a	8b 02		 mov	 eax, DWORD PTR [edx]
  0012c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0012f	ff d1		 call	 ecx
  00131	85 c0		 test	 eax, eax
  00133	7d 0d		 jge	 SHORT $LN10@I_StartupK

; 3213 : 			DISCL_NONEXCLUSIVE|DISCL_FOREGROUND)))
; 3214 : 		{
; 3215 : 			I_Error("Couldn't set keyboard coop level");

  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KLKKPMNH@Couldn?8t?5set?5keyboard?5coop?5leve@
  0013a	e8 00 00 00 00	 call	 _I_Error
  0013f	83 c4 04	 add	 esp, 4
$LN10@I_StartupK:

; 3216 : 		}
; 3217 : 	}

  00142	eb 0d		 jmp	 SHORT $LN7@I_StartupK
$LN6@I_StartupK:

; 3218 : 	else
; 3219 : 		I_Error("Couldn't create keyboard input");

  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@KDGLGFGC@Couldn?8t?5create?5keyboard?5input@
  00149	e8 00 00 00 00	 call	 _I_Error
  0014e	83 c4 04	 add	 esp, 4
$LN7@I_StartupK:

; 3220 : 
; 3221 : 	I_AddExitFunc(I_ShutdownKeyboard);

  00151	68 00 00 00 00	 push	 OFFSET _I_ShutdownKeyboard
  00156	e8 00 00 00 00	 call	 _I_AddExitFunc
  0015b	83 c4 04	 add	 esp, 4

; 3222 : 	hacktics = 0; // see definition

  0015e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hacktics, 0

; 3223 : 	keyboard_started = true;

  00168	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _keyboard_started, 1
$LN1@I_StartupK:

; 3224 : }

  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx
  00172	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00175	33 cd		 xor	 ecx, ebp
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c3		 ret	 0
_I_StartupKeyboard ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_StartupMouse2
_TEXT	SEGMENT
_e$1 = -36						; size = 4
_dcb$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_I_StartupMouse2 PROC					; COMDAT

; 1015 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1016 : 	DCB dcb;
; 1017 : 
; 1018 : 	if (mouse2filehandle != INVALID_HANDLE_VALUE)

  00013	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mouse2filehandle, -1
  0001a	74 06		 je	 SHORT $LN2@I_StartupM

; 1019 : 		I_ShutdownMouse2();

  0001c	e8 00 00 00 00	 call	 _I_ShutdownMouse2
  00021	90		 npad	 1
$LN2@I_StartupM:

; 1020 : 
; 1021 : 	if (!cv_usemouse2.value)

  00022	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_usemouse2+20, 0
  00029	75 05		 jne	 SHORT $LN3@I_StartupM

; 1022 : 		return;

  0002b	e9 15 01 00 00	 jmp	 $LN1@I_StartupM
$LN3@I_StartupM:

; 1023 : 
; 1024 : 	if (mouse2filehandle != INVALID_HANDLE_VALUE)

  00030	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mouse2filehandle, -1
  00037	74 6d		 je	 SHORT $LN5@I_StartupM

; 1025 : 	{
; 1026 : 		// COM file handle
; 1027 : 		mouse2filehandle = CreateFileA(cv_mouse2port.string, GENERIC_READ|GENERIC_WRITE,

  00039	6a 00		 push	 0
  0003b	68 80 00 00 00	 push	 128			; 00000080H
  00040	6a 03		 push	 3
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0004b	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_mouse2port+24
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00057	a3 00 00 00 00	 mov	 DWORD PTR _mouse2filehandle, eax

; 1028 : 		                               0, // exclusive access
; 1029 : 		                               NULL, // no security attrs
; 1030 : 		                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
; 1031 : 		if (mouse2filehandle == INVALID_HANDLE_VALUE)

  0005c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mouse2filehandle, -1
  00063	75 41		 jne	 SHORT $LN5@I_StartupM

; 1032 : 		{
; 1033 : 			int e = GetLastError();

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0006b	89 45 dc	 mov	 DWORD PTR _e$1[ebp], eax

; 1034 : 			if (e == 5)

  0006e	83 7d dc 05	 cmp	 DWORD PTR _e$1[ebp], 5
  00072	75 15		 jne	 SHORT $LN6@I_StartupM

; 1035 : 				CONS_Printf("\2Can't open %s: Access denied\n"

  00074	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_mouse2port+24
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@KJGNAMBA@?$ACCan?8t?5open?5?$CFs?3?5Access?5denied?6T@
  0007f	e8 00 00 00 00	 call	 _CONS_Printf
  00084	83 c4 08	 add	 esp, 8
  00087	eb 18		 jmp	 SHORT $LN7@I_StartupM
$LN6@I_StartupM:

; 1036 : 					"The port is probably already used by another device (mouse, modem,...)\n",
; 1037 : 						cv_mouse2port.string);
; 1038 : 			else
; 1039 : 				CONS_Printf("\2Can't open %s: error %d\n", cv_mouse2port.string, e);

  00089	8b 45 dc	 mov	 eax, DWORD PTR _e$1[ebp]
  0008c	50		 push	 eax
  0008d	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR _cv_mouse2port+24
  00093	51		 push	 ecx
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KLMPAIBH@?$ACCan?8t?5open?5?$CFs?3?5error?5?$CFd?6@
  00099	e8 00 00 00 00	 call	 _CONS_Printf
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@I_StartupM:

; 1040 : 			return;

  000a1	e9 9f 00 00 00	 jmp	 $LN1@I_StartupM
$LN5@I_StartupM:

; 1041 : 		}
; 1042 : 	}
; 1043 : 
; 1044 : 	// buffers
; 1045 : 	SetupComm(mouse2filehandle, MOUSECOMBUFFERSIZE, MOUSECOMBUFFERSIZE);

  000a6	68 00 01 00 00	 push	 256			; 00000100H
  000ab	68 00 01 00 00	 push	 256			; 00000100H
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupComm@12
  000bc	90		 npad	 1

; 1046 : 
; 1047 : 	// purge buffers
; 1048 : 	PurgeComm(mouse2filehandle, PURGE_TXABORT|PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);

  000bd	6a 0f		 push	 15			; 0000000fH
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _mouse2filehandle
  000c4	50		 push	 eax
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PurgeComm@8
  000cb	90		 npad	 1

; 1049 : 
; 1050 : 	// setup port to 1200 7N1
; 1051 : 	dcb.DCBlength = sizeof (DCB);

  000cc	c7 45 e0 1c 00
	00 00		 mov	 DWORD PTR _dcb$[ebp], 28 ; 0000001cH

; 1052 : 
; 1053 : 	GetCommState(mouse2filehandle, &dcb);

  000d3	8d 45 e0	 lea	 eax, DWORD PTR _dcb$[ebp]
  000d6	50		 push	 eax
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse2filehandle
  000dd	51		 push	 ecx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommState@8
  000e4	90		 npad	 1

; 1054 : 
; 1055 : 	dcb.BaudRate = CBR_1200;

  000e5	c7 45 e4 b0 04
	00 00		 mov	 DWORD PTR _dcb$[ebp+4], 1200 ; 000004b0H

; 1056 : 	dcb.ByteSize = 7;

  000ec	c6 45 f2 07	 mov	 BYTE PTR _dcb$[ebp+18], 7

; 1057 : 	dcb.Parity = NOPARITY;

  000f0	c6 45 f3 00	 mov	 BYTE PTR _dcb$[ebp+19], 0

; 1058 : 	dcb.StopBits = ONESTOPBIT;

  000f4	c6 45 f4 00	 mov	 BYTE PTR _dcb$[ebp+20], 0

; 1059 : 
; 1060 : 	dcb.fDtrControl = DTR_CONTROL_ENABLE;

  000f8	8b 45 e8	 mov	 eax, DWORD PTR _dcb$[ebp+8]
  000fb	83 e0 cf	 and	 eax, -49		; ffffffcfH
  000fe	83 c8 10	 or	 eax, 16			; 00000010H
  00101	89 45 e8	 mov	 DWORD PTR _dcb$[ebp+8], eax

; 1061 : 	dcb.fRtsControl = RTS_CONTROL_ENABLE;

  00104	8b 45 e8	 mov	 eax, DWORD PTR _dcb$[ebp+8]
  00107	25 ff cf ff ff	 and	 eax, -12289		; ffffcfffH
  0010c	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  00111	89 45 e8	 mov	 DWORD PTR _dcb$[ebp+8], eax

; 1062 : 
; 1063 : 	dcb.fBinary = dcb.fParity = TRUE;

  00114	8b 45 e8	 mov	 eax, DWORD PTR _dcb$[ebp+8]
  00117	83 c8 02	 or	 eax, 2
  0011a	89 45 e8	 mov	 DWORD PTR _dcb$[ebp+8], eax
  0011d	8b 4d e8	 mov	 ecx, DWORD PTR _dcb$[ebp+8]
  00120	83 c9 01	 or	 ecx, 1
  00123	89 4d e8	 mov	 DWORD PTR _dcb$[ebp+8], ecx

; 1064 : 
; 1065 : 	SetCommState(mouse2filehandle, &dcb);

  00126	8d 45 e0	 lea	 eax, DWORD PTR _dcb$[ebp]
  00129	50		 push	 eax
  0012a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mouse2filehandle
  00130	51		 push	 ecx
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCommState@8
  00137	90		 npad	 1

; 1066 : 
; 1067 : 	I_AddExitFunc(I_ShutdownMouse2);

  00138	68 00 00 00 00	 push	 OFFSET _I_ShutdownMouse2
  0013d	e8 00 00 00 00	 call	 _I_AddExitFunc
  00142	83 c4 04	 add	 esp, 4
$LN1@I_StartupM:

; 1068 : }

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014b	33 cd		 xor	 ecx, ebp
  0014d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
_I_StartupMouse2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_StartupMouse
_TEXT	SEGMENT
_I_StartupMouse PROC					; COMDAT

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 915  : 	// this gets called when cv_usemouse is initted
; 916  : 	// for the win32 version, we want to startup the mouse later
; 917  : 	if (menuactive)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _menuactive, 0
  00010	74 17		 je	 SHORT $LN4@I_StartupM

; 918  : 	{
; 919  : 		if (cv_usemouse.value)

  00012	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_usemouse+20, 0
  00019	74 08		 je	 SHORT $LN3@I_StartupM

; 920  : 			I_DoStartupMouse();

  0001b	e8 00 00 00 00	 call	 _I_DoStartupMouse
  00020	90		 npad	 1
  00021	eb 06		 jmp	 SHORT $LN4@I_StartupM
$LN3@I_StartupM:

; 921  : 		else
; 922  : 			I_ShutdownMouse();

  00023	e8 00 00 00 00	 call	 _I_ShutdownMouse
  00028	90		 npad	 1
$LN4@I_StartupM:

; 923  : 	}
; 924  : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_I_StartupMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_OutputMsg
_TEXT	SEGMENT
_blank$1 = -180						; size = 4
_csbi$2 = -176						; size = 22
_oldLength$3 = -152					; size = 4
_oldLines$4 = -148					; size = 4
_txt$ = -144						; size = 128
_argptr$ = -16						; size = 4
_bytesWritten$ = -12					; size = 4
_co$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_fmt$ = 8						; size = 4
_I_OutputMsg PROC					; COMDAT

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 535  : 	HANDLE co = GetStdHandle(STD_OUTPUT_HANDLE);

  00016	6a f5		 push	 -11			; fffffff5H
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  0001e	89 45 f8	 mov	 DWORD PTR _co$[ebp], eax

; 536  : 	DWORD bytesWritten;
; 537  : 	va_list argptr;
; 538  : 	char txt[128];
; 539  : 
; 540  : 	va_start(argptr,fmt);

  00021	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  00024	89 45 f0	 mov	 DWORD PTR _argptr$[ebp], eax

; 541  : 	vsprintf(txt, fmt, argptr);

  00027	8b 45 f0	 mov	 eax, DWORD PTR _argptr$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0002e	51		 push	 ecx
  0002f	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _vsprintf
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 	va_end(argptr);

  0003e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _argptr$[ebp], 0

; 543  : 
; 544  : 	OutputDebugStringA(txt);

  00045	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  00052	90		 npad	 1

; 545  : 
; 546  : #ifdef LOGMESSAGES
; 547  : 	if (logstream != INVALID_HANDLE_VALUE)

  00053	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _logstream, -1
  0005a	74 2a		 je	 SHORT $LN2@I_OutputMs

; 548  : 		WriteFile (logstream, txt, (DWORD)strlen(txt), &bytesWritten, NULL);

  0005c	6a 00		 push	 0
  0005e	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00061	50		 push	 eax
  00062	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _txt$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _strlen
  0006e	83 c4 04	 add	 esp, 4
  00071	50		 push	 eax
  00072	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  00078	52		 push	 edx
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _logstream
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00085	90		 npad	 1
$LN2@I_OutputMs:

; 549  : #endif
; 550  : 
; 551  : 	if (co == INVALID_HANDLE_VALUE)

  00086	83 7d f8 ff	 cmp	 DWORD PTR _co$[ebp], -1
  0008a	75 05		 jne	 SHORT $LN3@I_OutputMs

; 552  : 		return;

  0008c	e9 1d 02 00 00	 jmp	 $LN5@I_OutputMs
$LN3@I_OutputMs:

; 553  : 
; 554  : 	if (GetFileType(co) == FILE_TYPE_CHAR && GetConsoleMode(co, &bytesWritten))

  00091	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileType@4
  0009b	83 f8 02	 cmp	 eax, 2
  0009e	0f 85 e2 01 00
	00		 jne	 $LN4@I_OutputMs
  000a4	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _co$[ebp]
  000ab	51		 push	 ecx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleMode@8
  000b2	85 c0		 test	 eax, eax
  000b4	0f 84 cc 01 00
	00		 je	 $LN4@I_OutputMs

; 555  : 	{
; 556  : 		static COORD coordNextWrite = {0,0};
; 557  : 		LPVOID oldLines = NULL;

  000ba	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _oldLines$4[ebp], 0

; 558  : 		INT oldLength;
; 559  : 		CONSOLE_SCREEN_BUFFER_INFO csbi;
; 560  : 
; 561  : 		// Save the lines that we're going to obliterate.
; 562  : 		GetConsoleScreenBufferInfo(co, &csbi);

  000c4	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _csbi$2[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _co$[ebp]
  000ce	51		 push	 ecx
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleScreenBufferInfo@8
  000d5	90		 npad	 1

; 563  : 		oldLength = csbi.dwSize.X * (csbi.dwCursorPosition.Y - coordNextWrite.Y) + csbi.dwCursorPosition.X - coordNextWrite.X;

  000d6	0f bf 85 50 ff
	ff ff		 movsx	 eax, WORD PTR _csbi$2[ebp]
  000dd	0f bf 8d 56 ff
	ff ff		 movsx	 ecx, WORD PTR _csbi$2[ebp+6]
  000e4	0f bf 15 02 00
	00 00		 movsx	 edx, WORD PTR ?coordNextWrite@?2??I_OutputMsg@@9@9+2
  000eb	2b ca		 sub	 ecx, edx
  000ed	0f af c1	 imul	 eax, ecx
  000f0	0f bf 8d 54 ff
	ff ff		 movsx	 ecx, WORD PTR _csbi$2[ebp+4]
  000f7	03 c1		 add	 eax, ecx
  000f9	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?coordNextWrite@?2??I_OutputMsg@@9@9
  00100	2b c2		 sub	 eax, edx
  00102	89 85 68 ff ff
	ff		 mov	 DWORD PTR _oldLength$3[ebp], eax

; 564  : 
; 565  : 		if (oldLength > 0)

  00108	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _oldLength$3[ebp], 0
  0010f	0f 8e e1 00 00
	00		 jle	 $LN6@I_OutputMs

; 566  : 		{
; 567  : 			LPVOID blank = malloc(oldLength);

  00115	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _oldLength$3[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _malloc
  00121	83 c4 04	 add	 esp, 4
  00124	89 85 4c ff ff
	ff		 mov	 DWORD PTR _blank$1[ebp], eax

; 568  : 			if (!blank) return;

  0012a	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _blank$1[ebp], 0
  00131	75 05		 jne	 SHORT $LN7@I_OutputMs
  00133	e9 76 01 00 00	 jmp	 $LN5@I_OutputMs
$LN7@I_OutputMs:

; 569  : 			memset(blank, ' ', oldLength); // Blank out.

  00138	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _oldLength$3[ebp]
  0013e	50		 push	 eax
  0013f	6a 20		 push	 32			; 00000020H
  00141	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _blank$1[ebp]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 _memset
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 570  : 			oldLines = malloc(oldLength*sizeof(TCHAR));

  00150	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _oldLength$3[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _malloc
  0015c	83 c4 04	 add	 esp, 4
  0015f	89 85 6c ff ff
	ff		 mov	 DWORD PTR _oldLines$4[ebp], eax

; 571  : 			if (!oldLines)

  00165	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _oldLines$4[ebp], 0
  0016c	75 14		 jne	 SHORT $LN8@I_OutputMs

; 572  : 			{
; 573  : 				free(blank);

  0016e	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _blank$1[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _free
  0017a	83 c4 04	 add	 esp, 4

; 574  : 				return;

  0017d	e9 2c 01 00 00	 jmp	 $LN5@I_OutputMs
$LN8@I_OutputMs:

; 575  : 			}
; 576  : 
; 577  : 			ReadConsoleOutputCharacter(co, oldLines, oldLength, coordNextWrite, &bytesWritten);

  00182	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00185	50		 push	 eax
  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?coordNextWrite@?2??I_OutputMsg@@9@9
  0018c	51		 push	 ecx
  0018d	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _oldLength$3[ebp]
  00193	52		 push	 edx
  00194	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _oldLines$4[ebp]
  0019a	50		 push	 eax
  0019b	8b 4d f8	 mov	 ecx, DWORD PTR _co$[ebp]
  0019e	51		 push	 ecx
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadConsoleOutputCharacterA@20
  001a5	90		 npad	 1

; 578  : 
; 579  : 			// Move to where we what to print - which is where we would've been,
; 580  : 			// had console input not been in the way,
; 581  : 			SetConsoleCursorPosition(co, coordNextWrite);

  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?coordNextWrite@?2??I_OutputMsg@@9@9
  001ab	50		 push	 eax
  001ac	8b 4d f8	 mov	 ecx, DWORD PTR _co$[ebp]
  001af	51		 push	 ecx
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorPosition@8
  001b6	90		 npad	 1

; 582  : 
; 583  : 			WriteConsoleA(co, blank, oldLength, &bytesWritten, NULL);

  001b7	6a 00		 push	 0
  001b9	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  001bc	50		 push	 eax
  001bd	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _oldLength$3[ebp]
  001c3	51		 push	 ecx
  001c4	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _blank$1[ebp]
  001ca	52		 push	 edx
  001cb	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  001ce	50		 push	 eax
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleA@20
  001d5	90		 npad	 1

; 584  : 			free(blank);

  001d6	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _blank$1[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _free
  001e2	83 c4 04	 add	 esp, 4

; 585  : 
; 586  : 			// And back to where we want to print again.
; 587  : 			SetConsoleCursorPosition(co, coordNextWrite);

  001e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?coordNextWrite@?2??I_OutputMsg@@9@9
  001ea	50		 push	 eax
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _co$[ebp]
  001ee	51		 push	 ecx
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCursorPosition@8
  001f5	90		 npad	 1
$LN6@I_OutputMs:

; 588  : 		}
; 589  : 
; 590  : 		// Actually write the string now!
; 591  : 		WriteConsoleA(co, txt, (DWORD)strlen(txt), &bytesWritten, NULL);

  001f6	6a 00		 push	 0
  001f8	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  001fb	50		 push	 eax
  001fc	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _txt$[ebp]
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 _strlen
  00208	83 c4 04	 add	 esp, 4
  0020b	50		 push	 eax
  0020c	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  00212	52		 push	 edx
  00213	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  00216	50		 push	 eax
  00217	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleA@20
  0021d	90		 npad	 1

; 592  : 
; 593  : 		// Next time, output where we left off.
; 594  : 		GetConsoleScreenBufferInfo(co, &csbi);

  0021e	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _csbi$2[ebp]
  00224	50		 push	 eax
  00225	8b 4d f8	 mov	 ecx, DWORD PTR _co$[ebp]
  00228	51		 push	 ecx
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleScreenBufferInfo@8
  0022f	90		 npad	 1

; 595  : 		coordNextWrite = csbi.dwCursorPosition;

  00230	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _csbi$2[ebp+4]
  00236	a3 00 00 00 00	 mov	 DWORD PTR ?coordNextWrite@?2??I_OutputMsg@@9@9, eax

; 596  : 
; 597  : 		// Restore what was overwritten.
; 598  : 		if (oldLines && entering_con_command)

  0023b	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _oldLines$4[ebp], 0
  00242	74 28		 je	 SHORT $LN9@I_OutputMs
  00244	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _entering_con_command, 0
  0024b	74 1f		 je	 SHORT $LN9@I_OutputMs

; 599  : 			WriteConsole(co, oldLines, oldLength, &bytesWritten, NULL);

  0024d	6a 00		 push	 0
  0024f	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00252	50		 push	 eax
  00253	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _oldLength$3[ebp]
  00259	51		 push	 ecx
  0025a	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _oldLines$4[ebp]
  00260	52		 push	 edx
  00261	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  00264	50		 push	 eax
  00265	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteConsoleA@20
  0026b	90		 npad	 1
$LN9@I_OutputMs:

; 600  : 		if (oldLines) free(oldLines);

  0026c	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _oldLines$4[ebp], 0
  00273	74 0f		 je	 SHORT $LN10@I_OutputMs
  00275	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _oldLines$4[ebp]
  0027b	50		 push	 eax
  0027c	e8 00 00 00 00	 call	 _free
  00281	83 c4 04	 add	 esp, 4
$LN10@I_OutputMs:

; 601  : 	}

  00284	eb 28		 jmp	 SHORT $LN5@I_OutputMs
$LN4@I_OutputMs:

; 602  : 	else // Redirected to a file.
; 603  : 		WriteFile(co, txt, (DWORD)strlen(txt), &bytesWritten, NULL);

  00286	6a 00		 push	 0
  00288	8d 45 f4	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  0028b	50		 push	 eax
  0028c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _txt$[ebp]
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 _strlen
  00298	83 c4 04	 add	 esp, 4
  0029b	50		 push	 eax
  0029c	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  002a2	52		 push	 edx
  002a3	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  002a6	50		 push	 eax
  002a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  002ad	90		 npad	 1
$LN5@I_OutputMs:

; 604  : }

  002ae	5f		 pop	 edi
  002af	5e		 pop	 esi
  002b0	5b		 pop	 ebx
  002b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b4	33 cd		 xor	 ecx, ebp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
_I_OutputMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_UpdateMumble
_TEXT	SEGMENT
tv183 = -76						; size = 4
tv193 = -76						; size = 4
_f_angle$ = -8						; size = 8
_MPos$ = 8						; size = 4
_I_UpdateMumble PROC					; COMDAT

; 3083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3084 : 	double f_angle = 0.0l;

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	f2 0f 11 45 f8	 movsd	 QWORD PTR _f_angle$[ebp], xmm0

; 3085 : 	if (!lm || !MPos)

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lm, 0
  00018	74 06		 je	 SHORT $LN3@I_UpdateMu
  0001a	83 7d 08 00	 cmp	 DWORD PTR _MPos$[ebp], 0
  0001e	75 05		 jne	 SHORT $LN2@I_UpdateMu
$LN3@I_UpdateMu:

; 3086 : 		return;

  00020	e9 7e 01 00 00	 jmp	 $LN1@I_UpdateMu
$LN2@I_UpdateMu:

; 3087 : 
; 3088 : 	lm->fPosition[0] = FIXED_TO_FLOAT(MPos->fPosition[0]);

  00025	b8 04 00 00 00	 mov	 eax, 4
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	8b 55 08	 mov	 edx, DWORD PTR _MPos$[ebp]
  00030	f3 0f 2a 04 0a	 cvtsi2ss xmm0, DWORD PTR [edx+ecx]
  00035	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	6b c8 00	 imul	 ecx, eax, 0
  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lm
  0004b	f3 0f 11 44 0a
	08		 movss	 DWORD PTR [edx+ecx+8], xmm0

; 3089 : 	lm->fPosition[1] = FIXED_TO_FLOAT(MPos->fPosition[1]);

  00051	b8 04 00 00 00	 mov	 eax, 4
  00056	c1 e0 00	 shl	 eax, 0
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _MPos$[ebp]
  0005c	f3 0f 2a 04 01	 cvtsi2ss xmm0, DWORD PTR [ecx+eax]
  00061	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00069	ba 04 00 00 00	 mov	 edx, 4
  0006e	c1 e2 00	 shl	 edx, 0
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _lm
  00076	f3 0f 11 44 10
	08		 movss	 DWORD PTR [eax+edx+8], xmm0

; 3090 : 	lm->fPosition[2] = FIXED_TO_FLOAT(MPos->fPosition[2]);

  0007c	b8 04 00 00 00	 mov	 eax, 4
  00081	d1 e0		 shl	 eax, 1
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _MPos$[ebp]
  00086	f3 0f 2a 04 01	 cvtsi2ss xmm0, DWORD PTR [ecx+eax]
  0008b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00093	ba 04 00 00 00	 mov	 edx, 4
  00098	d1 e2		 shl	 edx, 1
  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _lm
  0009f	f3 0f 11 44 10
	08		 movss	 DWORD PTR [eax+edx+8], xmm0

; 3091 : 	if (MPos->fFront != 0.0l)

  000a5	8b 45 08	 mov	 eax, DWORD PTR _MPos$[ebp]
  000a8	f2 0f 10 40 10	 movsd	 xmm0, QWORD PTR [eax+16]
  000ad	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000b5	9f		 lahf
  000b6	f6 c4 44	 test	 ah, 68			; 00000044H
  000b9	7b 15		 jnp	 SHORT $LN4@I_UpdateMu

; 3092 : 		f_angle = (double)((MPos->fFront) / (180.0l * M_PIl));

  000bb	8b 45 08	 mov	 eax, DWORD PTR _MPos$[ebp]
  000be	f2 0f 10 40 10	 movsd	 xmm0, QWORD PTR [eax+16]
  000c3	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4081abe4b73fefb5
  000cb	f2 0f 11 45 f8	 movsd	 QWORD PTR _f_angle$[ebp], xmm0
$LN4@I_UpdateMu:

; 3093 : 	lm->fFront[0] = (float)cos(f_angle);

  000d0	83 ec 08	 sub	 esp, 8
  000d3	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _f_angle$[ebp]
  000d8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000dd	e8 00 00 00 00	 call	 _cos
  000e2	83 c4 08	 add	 esp, 8
  000e5	d9 5d b4	 fstp	 DWORD PTR tv183[ebp]
  000e8	d9 45 b4	 fld	 DWORD PTR tv183[ebp]
  000eb	b8 04 00 00 00	 mov	 eax, 4
  000f0	6b c8 00	 imul	 ecx, eax, 0
  000f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lm
  000f9	d9 5c 0a 14	 fstp	 DWORD PTR [edx+ecx+20]

; 3094 : 	lm->fFront[1] = 0.0f;

  000fd	b8 04 00 00 00	 mov	 eax, 4
  00102	c1 e0 00	 shl	 eax, 0
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lm
  0010b	0f 57 c0	 xorps	 xmm0, xmm0
  0010e	f3 0f 11 44 01
	14		 movss	 DWORD PTR [ecx+eax+20], xmm0

; 3095 : 	lm->fFront[2] = (float)sin(f_angle);

  00114	83 ec 08	 sub	 esp, 8
  00117	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _f_angle$[ebp]
  0011c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00121	e8 00 00 00 00	 call	 _sin
  00126	83 c4 08	 add	 esp, 8
  00129	d9 5d b4	 fstp	 DWORD PTR tv193[ebp]
  0012c	d9 45 b4	 fld	 DWORD PTR tv193[ebp]
  0012f	b8 04 00 00 00	 mov	 eax, 4
  00134	d1 e0		 shl	 eax, 1
  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lm
  0013c	d9 5c 01 14	 fstp	 DWORD PTR [ecx+eax+20]

; 3096 : 	lm->fTop[0] = 0.0f;

  00140	b8 04 00 00 00	 mov	 eax, 4
  00145	6b c8 00	 imul	 ecx, eax, 0
  00148	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lm
  0014e	0f 57 c0	 xorps	 xmm0, xmm0
  00151	f3 0f 11 44 0a
	20		 movss	 DWORD PTR [edx+ecx+32], xmm0

; 3097 : 	lm->fTop[1] = 1.0f;

  00157	b8 04 00 00 00	 mov	 eax, 4
  0015c	c1 e0 00	 shl	 eax, 0
  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lm
  00165	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016d	f3 0f 11 44 01
	20		 movss	 DWORD PTR [ecx+eax+32], xmm0

; 3098 : 	lm->fTop[2] = 0.0f;

  00173	b8 04 00 00 00	 mov	 eax, 4
  00178	d1 e0		 shl	 eax, 1
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lm
  00180	0f 57 c0	 xorps	 xmm0, xmm0
  00183	f3 0f 11 44 01
	20		 movss	 DWORD PTR [ecx+eax+32], xmm0

; 3099 : 
; 3100 : 	lm->uiVersion = 1;

  00189	a1 00 00 00 00	 mov	 eax, DWORD PTR _lm
  0018e	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 3101 : 	lm->uiTick = GetTickCount();

  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lm
  001a0	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN1@I_UpdateMu:

; 3102 : }

  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	5b		 pop	 ebx
  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c3		 ret	 0
_I_UpdateMumble ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_SetupMumble
_TEXT	SEGMENT
_pfnmmap$ = -28						; size = 4
_pfnshm_open$ = -24					; size = 4
_h$ = -20						; size = 4
_GameW$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_I_SetupMumble PROC					; COMDAT

; 3062 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3063 : 	const wchar_t GameW[] = {'S','R','B','2',0};

  00013	b8 53 00 00 00	 mov	 eax, 83			; 00000053H
  00018	66 89 45 f0	 mov	 WORD PTR _GameW$[ebp], ax
  0001c	b8 52 00 00 00	 mov	 eax, 82			; 00000052H
  00021	66 89 45 f2	 mov	 WORD PTR _GameW$[ebp+2], ax
  00025	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0002a	66 89 45 f4	 mov	 WORD PTR _GameW$[ebp+4], ax
  0002e	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00033	66 89 45 f6	 mov	 WORD PTR _GameW$[ebp+6], ax
  00037	33 c0		 xor	 eax, eax
  00039	66 89 45 f8	 mov	 WORD PTR _GameW$[ebp+8], ax

; 3064 : 	HMODULE h = GetModuleHandleA("kernel32.dll");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00048	89 45 ec	 mov	 DWORD PTR _h$[ebp], eax

; 3065 : 	p_OpenFileMappingA pfnshm_open = (p_OpenFileMappingA)GetProcAddress(h, "OpenFileMappingA");

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LOCJLGON@OpenFileMappingA@
  00050	8b 45 ec	 mov	 eax, DWORD PTR _h$[ebp]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0005a	89 45 e8	 mov	 DWORD PTR _pfnshm_open$[ebp], eax

; 3066 : 	p_MapViewOfFile pfnmmap = (p_MapViewOfFile)GetProcAddress(h, "MapViewOfFile");

  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IGIELGBD@MapViewOfFile@
  00062	8b 45 ec	 mov	 eax, DWORD PTR _h$[ebp]
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0006c	89 45 e4	 mov	 DWORD PTR _pfnmmap$[ebp], eax

; 3067 : 	if (!pfnshm_open || !pfnmmap)

  0006f	83 7d e8 00	 cmp	 DWORD PTR _pfnshm_open$[ebp], 0
  00073	74 06		 je	 SHORT $LN3@I_SetupMum
  00075	83 7d e4 00	 cmp	 DWORD PTR _pfnmmap$[ebp], 0
  00079	75 02		 jne	 SHORT $LN2@I_SetupMum
$LN3@I_SetupMum:

; 3068 : 		return;

  0007b	eb 75		 jmp	 SHORT $LN1@I_SetupMum
$LN2@I_SetupMum:

; 3069 : 	hMapObject = pfnshm_open(FILE_MAP_ALL_ACCESS, FALSE, "MumbleLink");

  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KNGEHEON@MumbleLink@
  00082	6a 00		 push	 0
  00084	68 1f 00 0f 00	 push	 983071			; 000f001fH
  00089	ff 55 e8	 call	 DWORD PTR _pfnshm_open$[ebp]
  0008c	a3 00 00 00 00	 mov	 DWORD PTR _hMapObject, eax

; 3070 : 	if (hMapObject == NULL) // Alam: odd, NULL check on a HANDLE

  00091	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hMapObject, 0
  00098	75 02		 jne	 SHORT $LN4@I_SetupMum

; 3071 : 		return;

  0009a	eb 56		 jmp	 SHORT $LN1@I_SetupMum
$LN4@I_SetupMum:

; 3072 : 
; 3073 : 	lm = (LinkedMem_p) pfnmmap(hMapObject, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(LinkedMem_t));

  0009c	68 2c 02 00 00	 push	 556			; 0000022cH
  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	68 1f 00 0f 00	 push	 983071			; 000f001fH
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  000af	50		 push	 eax
  000b0	ff 55 e4	 call	 DWORD PTR _pfnmmap$[ebp]
  000b3	a3 00 00 00 00	 mov	 DWORD PTR _lm, eax

; 3074 : 	if (lm == NULL) {

  000b8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lm, 0
  000bf	75 19		 jne	 SHORT $LN5@I_SetupMum

; 3075 : 		CloseHandle(hMapObject);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hMapObject
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000cd	90		 npad	 1

; 3076 : 		hMapObject = NULL;

  000ce	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hMapObject, 0

; 3077 : 		return;

  000d8	eb 18		 jmp	 SHORT $LN1@I_SetupMum
$LN5@I_SetupMum:

; 3078 : 	}
; 3079 : 	CopyMemory(lm->name, GameW, sizeof(GameW));

  000da	6a 0a		 push	 10			; 0000000aH
  000dc	8d 45 f0	 lea	 eax, DWORD PTR _GameW$[ebp]
  000df	50		 push	 eax
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lm
  000e6	83 c1 2c	 add	 ecx, 44			; 0000002cH
  000e9	51		 push	 ecx
  000ea	e8 00 00 00 00	 call	 _memcpy
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@I_SetupMum:

; 3080 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_I_SetupMumble ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetJoyName
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_joyindex$ = 8						; size = 4
_I_GetJoyName PROC					; COMDAT

; 3033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3034 : 	HRESULT hr;
; 3035 : 	needjoy = joyindex;

  00009	8b 45 08	 mov	 eax, DWORD PTR _joyindex$[ebp]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR _needjoy, eax

; 3036 : 	numofjoy = 0;

  00011	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numofjoy, 0

; 3037 : 	ZeroMemory(joyname,sizeof (joyname));

  0001b	68 04 01 00 00	 push	 260			; 00000104H
  00020	6a 00		 push	 0
  00022	68 00 00 00 00	 push	 OFFSET _joyname
  00027	e8 00 00 00 00	 call	 _memset
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3038 : 	hr = IDirectInput_EnumDevices(lpDI, DIDEVTYPE_JOYSTICK,

  0002f	6a 01		 push	 1
  00031	68 00 00 00 00	 push	 OFFSET _joyname
  00036	68 00 00 00 00	 push	 OFFSET _DIEnumJoysticksCount@8
  0003b	6a 04		 push	 4
  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  00042	50		 push	 eax
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDI
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004e	ff d0		 call	 eax
  00050	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3039 : 		DIEnumJoysticksCount, (LPVOID)joyname, DIEDFL_ATTACHEDONLY);
; 3040 : 	if (FAILED(hr))

  00053	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00057	7d 0d		 jge	 SHORT $LN2@I_GetJoyNa

; 3041 : 			CONS_Printf("\nI_GetJoyName(): EnumDevices FAILED\n");

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@EPEJCJNA@?6I_GetJoyName?$CI?$CJ?3?5EnumDevices?5FA@
  0005e	e8 00 00 00 00	 call	 _CONS_Printf
  00063	83 c4 04	 add	 esp, 4
$LN2@I_GetJoyNa:

; 3042 : 	if (joyname[0] == 0) return NULL;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	6b c8 00	 imul	 ecx, eax, 0
  0006e	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR _joyname[ecx]
  00075	85 d2		 test	 edx, edx
  00077	75 04		 jne	 SHORT $LN3@I_GetJoyNa
  00079	33 c0		 xor	 eax, eax
  0007b	eb 05		 jmp	 SHORT $LN1@I_GetJoyNa
$LN3@I_GetJoyNa:

; 3043 : 	return joyname;

  0007d	b8 00 00 00 00	 mov	 eax, OFFSET _joyname
$LN1@I_GetJoyNa:

; 3044 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_I_GetJoyName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_NumJoys
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_I_NumJoys PROC						; COMDAT

; 3020 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3021 : 	HRESULT hr;
; 3022 : 	needjoy = -1;

  00009	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _needjoy, -1

; 3023 : 	numofjoy = 0;

  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numofjoy, 0

; 3024 : 	hr = IDirectInput_EnumDevices(lpDI, DIDEVTYPE_JOYSTICK,

  0001d	6a 01		 push	 1
  0001f	68 00 00 00 00	 push	 OFFSET _numofjoy
  00024	68 00 00 00 00	 push	 OFFSET _DIEnumJoysticksCount@8
  00029	6a 04		 push	 4
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  00030	50		 push	 eax
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDI
  00037	8b 11		 mov	 edx, DWORD PTR [ecx]
  00039	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0003c	ff d0		 call	 eax
  0003e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 3025 : 		DIEnumJoysticksCount, (LPVOID)&numofjoy, DIEDFL_ATTACHEDONLY);
; 3026 : 	if (FAILED(hr))

  00041	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00045	7d 0d		 jge	 SHORT $LN2@I_NumJoys

; 3027 : 			CONS_Printf("\nI_NumJoys(): EnumDevices FAILED\n");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JJKCEPAA@?6I_NumJoys?$CI?$CJ?3?5EnumDevices?5FAILE@
  0004c	e8 00 00 00 00	 call	 _CONS_Printf
  00051	83 c4 04	 add	 esp, 4
$LN2@I_NumJoys:

; 3028 : 	return numofjoy;

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _numofjoy

; 3029 : 
; 3030 : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_I_NumJoys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_InitJoystick2
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_I_InitJoystick2 PROC					; COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2310 : 	HRESULT hr;
; 2311 : 
; 2312 : 	// cleanup
; 2313 : 	I_ShutdownJoystick2 ();

  00009	e8 00 00 00 00	 call	 _I_ShutdownJoystick2
  0000e	90		 npad	 1

; 2314 : 
; 2315 : 	joystick2_detected = false;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _joystick2_detected, 0

; 2316 : 
; 2317 : 	// joystick detection can be skipped by setting use_joystick to 0
; 2318 : 	if (!lpDI || M_CheckParm("-nojoy"))

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDI, 0
  00020	74 11		 je	 SHORT $LN4@I_InitJoys
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_06MIIKPKO@?9nojoy@
  00027	e8 00 00 00 00	 call	 _M_CheckParm
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	74 14		 je	 SHORT $LN2@I_InitJoys
$LN4@I_InitJoys:

; 2319 : 	{
; 2320 : 		CONS_Printf("Joystick2 disabled\n");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GDGHMOCG@Joystick2?5disabled?6@
  00038	e8 00 00 00 00	 call	 _CONS_Printf
  0003d	83 c4 04	 add	 esp, 4

; 2321 : 		return;

  00040	e9 4d 01 00 00	 jmp	 $LN1@I_InitJoys

; 2322 : 	}

  00045	eb 1c		 jmp	 SHORT $LN5@I_InitJoys
$LN2@I_InitJoys:

; 2323 : 	else
; 2324 : 		// don't do anything at the registration of the joystick cvar,
; 2325 : 		// until config is loaded
; 2326 : 		if (!strcmp(cv_usejoystick2.string, "0"))

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  0004c	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_usejoystick2+24
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _strcmp
  00057	83 c4 08	 add	 esp, 8
  0005a	85 c0		 test	 eax, eax
  0005c	75 05		 jne	 SHORT $LN5@I_InitJoys

; 2327 : 			return;

  0005e	e9 2f 01 00 00	 jmp	 $LN1@I_InitJoys
$LN5@I_InitJoys:

; 2328 : 
; 2329 : 	// acquire the joystick only once
; 2330 : 	if (!lpDIJ2)

  00063	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2, 0
  0006a	0f 85 0b 01 00
	00		 jne	 $LN6@I_InitJoys

; 2331 : 	{
; 2332 : 		joystick2_detected = false;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _joystick2_detected, 0

; 2333 : 
; 2334 : 		CONS_Printf("Looking for joystick devices:\n");

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PKLGBKMF@Looking?5for?5joystick?5devices?3?6@
  0007f	e8 00 00 00 00	 call	 _CONS_Printf
  00084	83 c4 04	 add	 esp, 4

; 2335 : 		iJoy2Num = 0;

  00087	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _iJoy2Num, 0

; 2336 : 		hr = IDirectInput_EnumDevices(lpDI, DIDEVTYPE_JOYSTICK,

  0008e	6a 01		 push	 1
  00090	68 00 00 00 00	 push	 OFFSET _cv_usejoystick2
  00095	68 00 00 00 00	 push	 OFFSET _DIEnumJoysticks2@8
  0009a	6a 04		 push	 4
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  000a1	50		 push	 eax
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDI
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000ad	ff d0		 call	 eax
  000af	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 2337 : 		                              DIEnumJoysticks2,
; 2338 : 		                              (LPVOID)&cv_usejoystick2,    // our user parameter is joystick number
; 2339 : 		                              DIEDFL_ATTACHEDONLY);
; 2340 : 		if (FAILED(hr))

  000b2	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000b6	7d 1c		 jge	 SHORT $LN8@I_InitJoys

; 2341 : 		{
; 2342 : 			CONS_Printf("\nI_InitJoystick2(): EnumDevices FAILED\n");

  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IPGCHNBF@?6I_InitJoystick2?$CI?$CJ?3?5EnumDevices@
  000bd	e8 00 00 00 00	 call	 _CONS_Printf
  000c2	83 c4 04	 add	 esp, 4

; 2343 : 			cv_usejoystick2.value = 0;

  000c5	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_usejoystick2+20, 0

; 2344 : 			return;

  000cf	e9 be 00 00 00	 jmp	 $LN1@I_InitJoys
$LN8@I_InitJoys:

; 2345 : 		}
; 2346 : 
; 2347 : 		if (!lpDIJ2)

  000d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2, 0
  000db	75 58		 jne	 SHORT $LN9@I_InitJoys

; 2348 : 		{
; 2349 : 			if (iJoy2Num == 0)

  000dd	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoy2Num
  000e4	85 c0		 test	 eax, eax
  000e6	75 0f		 jne	 SHORT $LN10@I_InitJoys

; 2350 : 				CONS_Printf("none found\n");

  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OIPHNGKP@none?5found?6@
  000ed	e8 00 00 00 00	 call	 _CONS_Printf
  000f2	83 c4 04	 add	 esp, 4
  000f5	eb 32		 jmp	 SHORT $LN12@I_InitJoys
$LN10@I_InitJoys:

; 2351 : 			else
; 2352 : 			{
; 2353 : 				CONS_Printf("none used\n");

  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CJHFOLIP@none?5used?6@
  000fc	e8 00 00 00 00	 call	 _CONS_Printf
  00101	83 c4 04	 add	 esp, 4

; 2354 : 				if (cv_usejoystick2.value > 0 &&

  00104	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_usejoystick2+20, 0
  0010b	7e 1c		 jle	 SHORT $LN12@I_InitJoys
  0010d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoy2Num
  00114	39 05 14 00 00
	00		 cmp	 DWORD PTR _cv_usejoystick2+20, eax
  0011a	7e 0d		 jle	 SHORT $LN12@I_InitJoys

; 2355 : 				    cv_usejoystick2.value > iJoy2Num)
; 2356 : 				{
; 2357 : 					CONS_Printf("\2Set the use_joystick2 variable to one of the"

  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NIGDHMKK@?$ACSet?5the?5use_joystick2?5variable@
  00121	e8 00 00 00 00	 call	 _CONS_Printf
  00126	83 c4 04	 add	 esp, 4
$LN12@I_InitJoys:

; 2358 : 					            " enumerated joysticks number\n");
; 2359 : 				}
; 2360 : 			}
; 2361 : 			cv_usejoystick2.value = 0;

  00129	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_usejoystick2+20, 0

; 2362 : 			return;

  00133	eb 5d		 jmp	 SHORT $LN1@I_InitJoys
$LN9@I_InitJoys:

; 2363 : 		}
; 2364 : 
; 2365 : 		I_AddExitFunc (I_ShutdownJoystick2);

  00135	68 00 00 00 00	 push	 OFFSET _I_ShutdownJoystick2
  0013a	e8 00 00 00 00	 call	 _I_AddExitFunc
  0013f	83 c4 04	 add	 esp, 4

; 2366 : 
; 2367 : 		// set coop level
; 2368 : 		if (FAILED(IDirectInputDevice_SetCooperativeLevel (lpDIJ2, hWndMain, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND)))

  00142	6a 06		 push	 6
  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00149	50		 push	 eax
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2
  00150	51		 push	 ecx
  00151	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIJ2
  00157	8b 02		 mov	 eax, DWORD PTR [edx]
  00159	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0015c	ff d1		 call	 ecx
  0015e	85 c0		 test	 eax, eax
  00160	7d 0d		 jge	 SHORT $LN13@I_InitJoys

; 2369 : 			I_Error("I_InitJoystick2: SetCooperativeLevel FAILED");

  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@JLJEILBJ@I_InitJoystick2?3?5SetCooperative@
  00167	e8 00 00 00 00	 call	 _I_Error
  0016c	83 c4 04	 add	 esp, 4
$LN13@I_InitJoys:

; 2370 : 
; 2371 : 		// later
; 2372 : 		//if (FAILED(IDirectInputDevice_Acquire (lpDIJ2)))
; 2373 : 		//    I_Error("Couldn't acquire Joystick2");
; 2374 : 
; 2375 : 		joystick2_detected = true;

  0016f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _joystick2_detected, 1

; 2376 : 	}

  00179	eb 0d		 jmp	 SHORT $LN7@I_InitJoys
$LN6@I_InitJoys:

; 2377 : 	else
; 2378 : 		CONS_Printf("Joystick2 already initialized\n");

  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EOHHKFHE@Joystick2?5already?5initialized?6@
  00180	e8 00 00 00 00	 call	 _CONS_Printf
  00185	83 c4 04	 add	 esp, 4
$LN7@I_InitJoys:

; 2379 : 
; 2380 : 	//faB: we don't unacquire joystick, so let's just pretend we re-acquired it
; 2381 : 	joystick2_detected = true;

  00188	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _joystick2_detected, 1
$LN1@I_InitJoys:

; 2382 : }

  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5b		 pop	 ebx
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
_I_InitJoystick2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_InitJoystick
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_I_InitJoystick PROC					; COMDAT

; 1945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1946 : 	HRESULT hr;
; 1947 : 
; 1948 : 	// cleanup
; 1949 : 	I_ShutdownJoystick();

  00009	e8 00 00 00 00	 call	 _I_ShutdownJoystick
  0000e	90		 npad	 1

; 1950 : 
; 1951 : 	//joystick detection can be skipped by setting use_joystick to 0
; 1952 : 	if (!lpDI || M_CheckParm("-nojoy"))

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDI, 0
  00016	74 11		 je	 SHORT $LN4@I_InitJoys
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_06MIIKPKO@?9nojoy@
  0001d	e8 00 00 00 00	 call	 _M_CheckParm
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 14		 je	 SHORT $LN2@I_InitJoys
$LN4@I_InitJoys:

; 1953 : 	{
; 1954 : 		CONS_Printf("Joystick disabled\n");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LCNJCENL@Joystick?5disabled?6@
  0002e	e8 00 00 00 00	 call	 _CONS_Printf
  00033	83 c4 04	 add	 esp, 4

; 1955 : 		return;

  00036	e9 43 01 00 00	 jmp	 $LN1@I_InitJoys

; 1956 : 	}

  0003b	eb 1c		 jmp	 SHORT $LN5@I_InitJoys
$LN2@I_InitJoys:

; 1957 : 	else
; 1958 : 		// don't do anything at the registration of the joystick cvar,
; 1959 : 		// until config is loaded
; 1960 : 		if (!strcmp(cv_usejoystick.string, "0"))

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  00042	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_usejoystick+24
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strcmp
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	75 05		 jne	 SHORT $LN5@I_InitJoys

; 1961 : 			return;

  00054	e9 25 01 00 00	 jmp	 $LN1@I_InitJoys
$LN5@I_InitJoys:

; 1962 : 
; 1963 : 	// acquire the joystick only once
; 1964 : 	if (!lpDIJ)

  00059	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ, 0
  00060	0f 85 01 01 00
	00		 jne	 $LN6@I_InitJoys

; 1965 : 	{
; 1966 : 		joystick_detected = false;

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _joystick_detected, 0

; 1967 : 
; 1968 : 		CONS_Printf("Looking for joystick devices:\n");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PKLGBKMF@Looking?5for?5joystick?5devices?3?6@
  00075	e8 00 00 00 00	 call	 _CONS_Printf
  0007a	83 c4 04	 add	 esp, 4

; 1969 : 		iJoyNum = 0;

  0007d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _iJoyNum, 0

; 1970 : 		hr = IDirectInput_EnumDevices(lpDI, DIDEVTYPE_JOYSTICK, DIEnumJoysticks,

  00084	6a 01		 push	 1
  00086	68 00 00 00 00	 push	 OFFSET _cv_usejoystick
  0008b	68 00 00 00 00	 push	 OFFSET _DIEnumJoysticks@8
  00090	6a 04		 push	 4
  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDI
  00097	50		 push	 eax
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDI
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a3	ff d0		 call	 eax
  000a5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 1971 : 			(void *)&cv_usejoystick, // our user parameter is joystick number
; 1972 : 			DIEDFL_ATTACHEDONLY);
; 1973 : 		if (FAILED(hr))

  000a8	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ac	7d 1c		 jge	 SHORT $LN8@I_InitJoys

; 1974 : 		{
; 1975 : 			CONS_Printf("\nI_InitJoystick(): EnumDevices FAILED\n");

  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@EMBOCGPJ@?6I_InitJoystick?$CI?$CJ?3?5EnumDevices?5@
  000b3	e8 00 00 00 00	 call	 _CONS_Printf
  000b8	83 c4 04	 add	 esp, 4

; 1976 : 			cv_usejoystick.value = 0;

  000bb	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_usejoystick+20, 0

; 1977 : 			return;

  000c5	e9 b4 00 00 00	 jmp	 $LN1@I_InitJoys
$LN8@I_InitJoys:

; 1978 : 		}
; 1979 : 
; 1980 : 		if (!lpDIJ)

  000ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ, 0
  000d1	75 58		 jne	 SHORT $LN9@I_InitJoys

; 1981 : 		{
; 1982 : 			if (!iJoyNum)

  000d3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoyNum
  000da	85 c0		 test	 eax, eax
  000dc	75 0f		 jne	 SHORT $LN10@I_InitJoys

; 1983 : 				CONS_Printf("none found\n");

  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OIPHNGKP@none?5found?6@
  000e3	e8 00 00 00 00	 call	 _CONS_Printf
  000e8	83 c4 04	 add	 esp, 4
  000eb	eb 32		 jmp	 SHORT $LN12@I_InitJoys
$LN10@I_InitJoys:

; 1984 : 			else
; 1985 : 			{
; 1986 : 				CONS_Printf("none used\n");

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CJHFOLIP@none?5used?6@
  000f2	e8 00 00 00 00	 call	 _CONS_Printf
  000f7	83 c4 04	 add	 esp, 4

; 1987 : 				if (cv_usejoystick.value > 0 && cv_usejoystick.value > iJoyNum)

  000fa	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_usejoystick+20, 0
  00101	7e 1c		 jle	 SHORT $LN12@I_InitJoys
  00103	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _iJoyNum
  0010a	39 05 14 00 00
	00		 cmp	 DWORD PTR _cv_usejoystick+20, eax
  00110	7e 0d		 jle	 SHORT $LN12@I_InitJoys

; 1988 : 				{
; 1989 : 					CONS_Printf("\2Set the use_joystick variable to one of the"

  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@EBIAMJEC@?$ACSet?5the?5use_joystick?5variable?5@
  00117	e8 00 00 00 00	 call	 _CONS_Printf
  0011c	83 c4 04	 add	 esp, 4
$LN12@I_InitJoys:

; 1990 : 						" enumerated joystick numbers\n");
; 1991 : 				}
; 1992 : 			}
; 1993 : 			cv_usejoystick.value = 0;

  0011f	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_usejoystick+20, 0

; 1994 : 			return;

  00129	eb 53		 jmp	 SHORT $LN1@I_InitJoys
$LN9@I_InitJoys:

; 1995 : 		}
; 1996 : 
; 1997 : 		I_AddExitFunc(I_ShutdownJoystick);

  0012b	68 00 00 00 00	 push	 OFFSET _I_ShutdownJoystick
  00130	e8 00 00 00 00	 call	 _I_AddExitFunc
  00135	83 c4 04	 add	 esp, 4

; 1998 : 
; 1999 : 		// set coop level
; 2000 : 		if (FAILED(IDirectInputDevice_SetCooperativeLevel(lpDIJ, hWndMain,

  00138	6a 06		 push	 6
  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  0013f	50		 push	 eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ
  00146	51		 push	 ecx
  00147	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lpDIJ
  0014d	8b 02		 mov	 eax, DWORD PTR [edx]
  0014f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00152	ff d1		 call	 ecx
  00154	85 c0		 test	 eax, eax
  00156	7d 0d		 jge	 SHORT $LN13@I_InitJoys

; 2001 : 		 DISCL_NONEXCLUSIVE|DISCL_FOREGROUND)))
; 2002 : 		{
; 2003 : 			I_Error("I_InitJoystick: SetCooperativeLevel FAILED");

  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LHFCLCKD@I_InitJoystick?3?5SetCooperativeL@
  0015d	e8 00 00 00 00	 call	 _I_Error
  00162	83 c4 04	 add	 esp, 4
$LN13@I_InitJoys:

; 2004 : 		}
; 2005 : 	}

  00165	eb 0d		 jmp	 SHORT $LN7@I_InitJoys
$LN6@I_InitJoys:

; 2006 : 	else
; 2007 : 		CONS_Printf("Joystick already initialized\n");

  00167	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GGPBHPCK@Joystick?5already?5initialized?6@
  0016c	e8 00 00 00 00	 call	 _CONS_Printf
  00171	83 c4 04	 add	 esp, 4
$LN7@I_InitJoys:

; 2008 : 
; 2009 : 	// we don't unacquire joystick, so let's just pretend we re-acquired it
; 2010 : 	joystick_detected = true;

  00174	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _joystick_detected, 1
$LN1@I_InitJoys:

; 2011 : }

  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
_I_InitJoystick ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_Tactile2
_TEXT	SEGMENT
_Type$ = 8						; size = 4
_Effect$ = 12						; size = 4
_I_Tactile2 PROC					; COMDAT

; 1619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1620 : 	if (!lpDIJ2A) return;

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJ2A, 0
  00010	75 02		 jne	 SHORT $LN2@I_Tactile2
  00012	eb 72		 jmp	 SHORT $LN1@I_Tactile2
$LN2@I_Tactile2:

; 1621 : 	if (FAILED(IDirectInputDevice2_Acquire(lpDIJ2A)))

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2A
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2A
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00025	ff d0		 call	 eax
  00027	85 c0		 test	 eax, eax
  00029	7d 02		 jge	 SHORT $LN3@I_Tactile2

; 1622 : 		return;

  0002b	eb 59		 jmp	 SHORT $LN1@I_Tactile2
$LN3@I_Tactile2:

; 1623 : 	if (Type == EvilForce)

  0002d	83 7d 08 ff	 cmp	 DWORD PTR _Type$[ebp], -1
  00031	75 16		 jne	 SHORT $LN4@I_Tactile2

; 1624 : 		IDirectInputDevice2_SendForceFeedbackCommand(lpDIJ2A,DISFFC_STOPALL);

  00033	6a 02		 push	 2
  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJ2A
  0003a	50		 push	 eax
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJ2A
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00046	ff d0		 call	 eax
  00048	90		 npad	 1
$LN4@I_Tactile2:

; 1625 : 	if (Type <= EvilForce || Type > NumberofForces || !lpDIE2[Type])

  00049	83 7d 08 ff	 cmp	 DWORD PTR _Type$[ebp], -1
  0004d	7e 13		 jle	 SHORT $LN6@I_Tactile2
  0004f	83 7d 08 07	 cmp	 DWORD PTR _Type$[ebp], 7
  00053	7f 0d		 jg	 SHORT $LN6@I_Tactile2
  00055	8b 45 08	 mov	 eax, DWORD PTR _Type$[ebp]
  00058	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _lpDIE2[eax*4], 0
  00060	75 02		 jne	 SHORT $LN5@I_Tactile2
$LN6@I_Tactile2:

; 1626 : 		return;

  00062	eb 22		 jmp	 SHORT $LN1@I_Tactile2
$LN5@I_Tactile2:

; 1627 : 	SetForceTacile(lpDIE2[Type],Effect, JoyInfo2.ForceAxises, Type);

  00064	8b 45 08	 mov	 eax, DWORD PTR _Type$[ebp]
  00067	50		 push	 eax
  00068	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _JoyInfo2+8
  0006e	51		 push	 ecx
  0006f	8b 55 0c	 mov	 edx, DWORD PTR _Effect$[ebp]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _Type$[ebp]
  00076	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lpDIE2[eax*4]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _SetForceTacile
  00083	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@I_Tactile2:

; 1628 : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_I_Tactile2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_Tactile
_TEXT	SEGMENT
_Type$ = 8						; size = 4
_Effect$ = 12						; size = 4
_I_Tactile PROC						; COMDAT

; 1607 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1608 : 	if (!lpDIJA) return;

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lpDIJA, 0
  00010	75 02		 jne	 SHORT $LN2@I_Tactile
  00012	eb 72		 jmp	 SHORT $LN1@I_Tactile
$LN2@I_Tactile:

; 1609 : 	if (FAILED(IDirectInputDevice2_Acquire(lpDIJA)))

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJA
  00019	50		 push	 eax
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJA
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00025	ff d0		 call	 eax
  00027	85 c0		 test	 eax, eax
  00029	7d 02		 jge	 SHORT $LN3@I_Tactile

; 1610 : 		return;

  0002b	eb 59		 jmp	 SHORT $LN1@I_Tactile
$LN3@I_Tactile:

; 1611 : 	if (Type == EvilForce)

  0002d	83 7d 08 ff	 cmp	 DWORD PTR _Type$[ebp], -1
  00031	75 16		 jne	 SHORT $LN4@I_Tactile

; 1612 : 		IDirectInputDevice2_SendForceFeedbackCommand(lpDIJA,DISFFC_STOPALL);

  00033	6a 02		 push	 2
  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _lpDIJA
  0003a	50		 push	 eax
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lpDIJA
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00046	ff d0		 call	 eax
  00048	90		 npad	 1
$LN4@I_Tactile:

; 1613 : 	if (Type <= EvilForce || Type > NumberofForces || !lpDIE[Type])

  00049	83 7d 08 ff	 cmp	 DWORD PTR _Type$[ebp], -1
  0004d	7e 13		 jle	 SHORT $LN6@I_Tactile
  0004f	83 7d 08 07	 cmp	 DWORD PTR _Type$[ebp], 7
  00053	7f 0d		 jg	 SHORT $LN6@I_Tactile
  00055	8b 45 08	 mov	 eax, DWORD PTR _Type$[ebp]
  00058	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _lpDIE[eax*4], 0
  00060	75 02		 jne	 SHORT $LN5@I_Tactile
$LN6@I_Tactile:

; 1614 : 		return;

  00062	eb 22		 jmp	 SHORT $LN1@I_Tactile
$LN5@I_Tactile:

; 1615 : 	SetForceTacile(lpDIE[Type], Effect, JoyInfo.ForceAxises, Type);

  00064	8b 45 08	 mov	 eax, DWORD PTR _Type$[ebp]
  00067	50		 push	 eax
  00068	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _JoyInfo+8
  0006e	51		 push	 ecx
  0006f	8b 55 0c	 mov	 edx, DWORD PTR _Effect$[ebp]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _Type$[ebp]
  00076	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lpDIE[eax*4]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _SetForceTacile
  00083	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@I_Tactile:

; 1616 : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_I_Tactile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_Quit
_TEXT	SEGMENT
_mode$ = -8						; size = 4
_co$ = -4						; size = 4
_I_Quit	PROC						; COMDAT

; 740  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 741  : 	HANDLE co = GetStdHandle(STD_OUTPUT_HANDLE);

  00009	6a f5		 push	 -11			; fffffff5H
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00011	89 45 fc	 mov	 DWORD PTR _co$[ebp], eax

; 742  : 	DWORD mode;
; 743  : 	// when recording a demo, should exit using 'q',
; 744  : 	// but sometimes we forget and use Alt+F4, so save here too.
; 745  : 	if (demorecording)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demorecording, 0
  0001b	74 06		 je	 SHORT $LN2@I_Quit

; 746  : 		G_CheckDemoStatus();

  0001d	e8 00 00 00 00	 call	 _G_CheckDemoStatus
  00022	90		 npad	 1
$LN2@I_Quit:

; 747  : 
; 748  : 	M_SaveConfig(NULL); // save game config, cvars..

  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 _M_SaveConfig
  0002a	83 c4 04	 add	 esp, 4

; 749  : #ifndef NONET
; 750  : 	D_SaveBan(); // save the ban list

  0002d	e8 00 00 00 00	 call	 _D_SaveBan
  00032	90		 npad	 1

; 751  : #endif
; 752  : 	G_SaveGameData();

  00033	e8 00 00 00 00	 call	 _G_SaveGameData
  00038	90		 npad	 1

; 753  : 
; 754  : 	// maybe it needs that the ticcount continues,
; 755  : 	// or something else that will be finished by I_ShutdownSystem(),
; 756  : 	// so do it before.
; 757  : 	D_QuitNetGame();

  00039	e8 00 00 00 00	 call	 _D_QuitNetGame
  0003e	90		 npad	 1

; 758  : 
; 759  : 	// shutdown everything that was started
; 760  : 	I_ShutdownSystem();

  0003f	e8 00 00 00 00	 call	 _I_ShutdownSystem
  00044	90		 npad	 1

; 761  : 
; 762  : 	if (shutdowning || errorcount)

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _shutdowning, 0
  0004c	75 09		 jne	 SHORT $LN4@I_Quit
  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _errorcount, 0
  00055	74 13		 je	 SHORT $LN3@I_Quit
$LN4@I_Quit:

; 763  : 		I_Error("Error detected (%d)", errorcount);

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _errorcount
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NBJMEAKN@Error?5detected?5?$CI?$CFd?$CJ@
  00062	e8 00 00 00 00	 call	 _I_Error
  00067	83 c4 08	 add	 esp, 8
$LN3@I_Quit:

; 764  : 
; 765  : #ifdef LOGMESSAGES
; 766  : 	if (logstream != INVALID_HANDLE_VALUE)

  0006a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _logstream, -1
  00071	74 24		 je	 SHORT $LN5@I_Quit

; 767  : 	{
; 768  : 		I_OutputMsg("I_Quit(): end of logstream.\r\n");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LBJCGNPE@I_Quit?$CI?$CJ?3?5end?5of?5logstream?4?$AN?6@
  00078	e8 00 00 00 00	 call	 _I_OutputMsg
  0007d	83 c4 04	 add	 esp, 4

; 769  : 		CloseHandle(logstream);

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _logstream
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0008c	90		 npad	 1

; 770  : 		logstream = INVALID_HANDLE_VALUE;

  0008d	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _logstream, -1
$LN5@I_Quit:

; 771  : 	}
; 772  : #endif
; 773  : 	if (!M_CheckParm("-noendtxt") && W_CheckNumForName("ENDOOM")!=LUMPERROR
; 774  : 		&& co != INVALID_HANDLE_VALUE && GetFileType(co) == FILE_TYPE_CHAR
; 775  : 		&& GetConsoleMode(co, &mode))

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_09EJJCJJPM@?9noendtxt@
  0009c	e8 00 00 00 00	 call	 _M_CheckParm
  000a1	83 c4 04	 add	 esp, 4
  000a4	85 c0		 test	 eax, eax
  000a6	75 52		 jne	 SHORT $LN6@I_Quit
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_06BBOHFMBE@ENDOOM@
  000ad	e8 00 00 00 00	 call	 _W_CheckNumForName
  000b2	83 c4 04	 add	 esp, 4
  000b5	83 f8 ff	 cmp	 eax, -1
  000b8	74 40		 je	 SHORT $LN6@I_Quit
  000ba	83 7d fc ff	 cmp	 DWORD PTR _co$[ebp], -1
  000be	74 3a		 je	 SHORT $LN6@I_Quit
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _co$[ebp]
  000c3	50		 push	 eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileType@4
  000ca	83 f8 02	 cmp	 eax, 2
  000cd	75 2b		 jne	 SHORT $LN6@I_Quit
  000cf	8d 45 f8	 lea	 eax, DWORD PTR _mode$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _co$[ebp]
  000d6	51		 push	 ecx
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleMode@8
  000dd	85 c0		 test	 eax, eax
  000df	74 19		 je	 SHORT $LN6@I_Quit

; 776  : 	{
; 777  : 		printf("\r");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_01LIIJDEN@?$AN@
  000e6	e8 00 00 00 00	 call	 _printf
  000eb	83 c4 04	 add	 esp, 4

; 778  : 		ShowEndTxt(co);

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _co$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _ShowEndTxt
  000f7	83 c4 04	 add	 esp, 4
$LN6@I_Quit:

; 779  : 	}
; 780  : 	fflush(stderr);

  000fa	6a 02		 push	 2
  000fc	e8 00 00 00 00	 call	 ___acrt_iob_func
  00101	83 c4 04	 add	 esp, 4
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _fflush
  0010a	83 c4 04	 add	 esp, 4

; 781  : 	W_Shutdown();

  0010d	e8 00 00 00 00	 call	 _W_Shutdown
  00112	90		 npad	 1

; 782  : 	exit(0);

  00113	6a 00		 push	 0
  00115	e8 00 00 00 00	 call	 _exit
  0011a	90		 npad	 1
$LN1@I_Quit:

; 783  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
_I_Quit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_BaseTiccmd2
_TEXT	SEGMENT
_I_BaseTiccmd2 PROC					; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 159  : 	return &emptycmd2;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET _emptycmd2

; 160  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_I_BaseTiccmd2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_BaseTiccmd
_TEXT	SEGMENT
_I_BaseTiccmd PROC					; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 153  : 	return &emptycmd;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET _emptycmd

; 154  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_I_BaseTiccmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_OsPolling
_TEXT	SEGMENT
$T1 = -104						; size = 4
$T2 = -100						; size = 4
_ci$ = -32						; size = 4
_msg$ = -28						; size = 28
_I_OsPolling PROC					; COMDAT

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 408  : 	MSG msg;
; 409  : 	HANDLE ci = GetStdHandle(STD_INPUT_HANDLE);

  00009	6a f6		 push	 -10			; fffffff6H
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00011	89 45 e0	 mov	 DWORD PTR _ci$[ebp], eax
$LN4@I_OsPollin:

; 410  : 
; 411  : 	// we need to dispatch messages to the window
; 412  : 	// so the window procedure can respond to messages and PostEvent() for keys
; 413  : 	// during D_SRB2Main startup.
; 414  : 	// this one replaces the main loop of windows since I_OsPolling is called in the main loop
; 415  : 	do
; 416  : 	{
; 417  : 		while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))

  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00026	85 c0		 test	 eax, eax
  00028	74 34		 je	 SHORT $LN6@I_OsPollin

; 418  : 		{
; 419  : 			if (GetMessage(&msg, NULL, 0, 0))

  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageA@16
  0003a	85 c0		 test	 eax, eax
  0003c	74 18		 je	 SHORT $LN7@I_OsPollin

; 420  : 			{
; 421  : 				TranslateMessage(&msg);

  0003e	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4
  00048	90		 npad	 1

; 422  : 				DispatchMessage(&msg);

  00049	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4
  00053	90		 npad	 1

; 423  : 			}

  00054	eb 06		 jmp	 SHORT $LN8@I_OsPollin
$LN7@I_OsPollin:

; 424  : 			else // winspec : this is quit message
; 425  : 				I_Quit();

  00056	e8 00 00 00 00	 call	 _I_Quit
  0005b	90		 npad	 1
$LN8@I_OsPollin:

; 426  : 		}

  0005c	eb b6		 jmp	 SHORT $LN4@I_OsPollin
$LN6@I_OsPollin:

; 427  : 		if (!appActive && !netgame && !I_ReadyConsole(ci))

  0005e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _appActive, 0
  00065	75 20		 jne	 SHORT $LN9@I_OsPollin
  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0006e	75 17		 jne	 SHORT $LN9@I_OsPollin
  00070	8b 45 e0	 mov	 eax, DWORD PTR _ci$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _I_ReadyConsole
  00079	83 c4 04	 add	 esp, 4
  0007c	85 c0		 test	 eax, eax
  0007e	75 07		 jne	 SHORT $LN9@I_OsPollin

; 428  : 			WaitMessage();

  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitMessage@0
  00086	90		 npad	 1
$LN9@I_OsPollin:

; 429  : 	} while (!appActive && !netgame && !I_ReadyConsole(ci));

  00087	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _appActive, 0
  0008e	75 1d		 jne	 SHORT $LN10@I_OsPollin
  00090	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00097	75 14		 jne	 SHORT $LN10@I_OsPollin
  00099	8b 45 e0	 mov	 eax, DWORD PTR _ci$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _I_ReadyConsole
  000a2	83 c4 04	 add	 esp, 4
  000a5	85 c0		 test	 eax, eax
  000a7	0f 84 67 ff ff
	ff		 je	 $LN4@I_OsPollin
$LN10@I_OsPollin:

; 430  : 
; 431  : 	// this is called by the network synchronization,
; 432  : 	// check keys and allow escaping
; 433  : 	I_GetEvent();

  000ad	e8 00 00 00 00	 call	 _I_GetEvent
  000b2	90		 npad	 1

; 434  : 
; 435  : 	// reset "emulated keys"
; 436  : 	gamekeydown[KEY_MOUSEWHEELUP] = 0;

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	69 c8 e0 01 00
	00		 imul	 ecx, eax, 480
  000be	89 4d 9c	 mov	 DWORD PTR $T2[ebp], ecx
  000c1	81 7d 9c e4 01
	00 00		 cmp	 DWORD PTR $T2[ebp], 484	; 000001e4H
  000c8	73 02		 jae	 SHORT $LN12@I_OsPollin
  000ca	eb 06		 jmp	 SHORT $LN13@I_OsPollin
$LN12@I_OsPollin:
  000cc	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  000d1	90		 npad	 1
$LN13@I_OsPollin:
  000d2	8b 55 9c	 mov	 edx, DWORD PTR $T2[ebp]
  000d5	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _gamekeydown[edx], 0

; 437  : 	gamekeydown[KEY_MOUSEWHEELDOWN] = 0;

  000dc	b8 01 00 00 00	 mov	 eax, 1
  000e1	69 c8 e1 01 00
	00		 imul	 ecx, eax, 481
  000e7	89 4d 98	 mov	 DWORD PTR $T1[ebp], ecx
  000ea	81 7d 98 e4 01
	00 00		 cmp	 DWORD PTR $T1[ebp], 484	; 000001e4H
  000f1	73 02		 jae	 SHORT $LN14@I_OsPollin
  000f3	eb 06		 jmp	 SHORT $LN15@I_OsPollin
$LN14@I_OsPollin:
  000f5	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  000fa	90		 npad	 1
$LN15@I_OsPollin:
  000fb	8b 55 98	 mov	 edx, DWORD PTR $T1[ebp]
  000fe	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _gamekeydown[edx], 0
$LN1@I_OsPollin:

; 438  : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_I_OsPolling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetEvent
_TEXT	SEGMENT
_I_GetEvent PROC					; COMDAT

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 396  : 	I_GetConsoleEvents();

  00009	e8 00 00 00 00	 call	 _I_GetConsoleEvents
  0000e	90		 npad	 1

; 397  : 	I_GetKeyboardEvents();

  0000f	e8 00 00 00 00	 call	 _I_GetKeyboardEvents
  00014	90		 npad	 1

; 398  : 	I_GetMouseEvents();

  00015	e8 00 00 00 00	 call	 _I_GetMouseEvents
  0001a	90		 npad	 1

; 399  : 	I_GetJoystickEvents();

  0001b	e8 00 00 00 00	 call	 _I_GetJoystickEvents
  00020	90		 npad	 1

; 400  : 	I_GetJoystick2Events();

  00021	e8 00 00 00 00	 call	 _I_GetJoystick2Events
  00026	90		 npad	 1

; 401  : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_I_GetEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_Sleep
_TEXT	SEGMENT
_I_Sleep PROC						; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	if (cv_sleep.value != -1)

  00009	83 3d 14 00 00
	00 ff		 cmp	 DWORD PTR _cv_sleep+20, -1
  00010	74 0d		 je	 SHORT $LN2@I_Sleep

; 281  : 		Sleep(cv_sleep.value);

  00012	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_sleep+20
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0001e	90		 npad	 1
$LN2@I_Sleep:

; 282  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_I_Sleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetTime
_TEXT	SEGMENT
_currtime$1 = -12					; size = 8
_newtics$ = -4						; size = 4
_I_GetTime PROC						; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 240  : 	tic_t newtics = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _newtics$[ebp], 0

; 241  : 
; 242  : 	if (!starttickcount) // high precision timer

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _starttickcount, 0
  00017	0f 85 b0 00 00
	00		 jne	 $LN2@I_GetTime

; 243  : 	{
; 244  : 		LARGE_INTEGER currtime; // use only LowPart if high resolution counter is not available
; 245  : 		static LARGE_INTEGER basetime = {{0, 0}};
; 246  : 
; 247  : 		// use this if High Resolution timer is found
; 248  : 		static LARGE_INTEGER frequency;
; 249  : 
; 250  : 		if (!basetime.LowPart)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?basetime@?2??I_GetTime@@9@9, 0
  00024	75 28		 jne	 SHORT $LN6@I_GetTime

; 251  : 		{
; 252  : 			if (!QueryPerformanceFrequency(&frequency))

  00026	68 00 00 00 00	 push	 OFFSET ?frequency@?2??I_GetTime@@9@9
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  00031	85 c0		 test	 eax, eax
  00033	75 0d		 jne	 SHORT $LN5@I_GetTime

; 253  : 				frequency.QuadPart = 0;

  00035	0f 57 c0	 xorps	 xmm0, xmm0
  00038	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR ?frequency@?2??I_GetTime@@9@9, xmm0
  00040	eb 0c		 jmp	 SHORT $LN6@I_GetTime
$LN5@I_GetTime:

; 254  : 			else
; 255  : 				QueryPerformanceCounter(&basetime);

  00042	68 00 00 00 00	 push	 OFFSET ?basetime@?2??I_GetTime@@9@9
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0004d	90		 npad	 1
$LN6@I_GetTime:

; 256  : 		}
; 257  : 
; 258  : 		if (frequency.LowPart && QueryPerformanceCounter(&currtime))

  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?frequency@?2??I_GetTime@@9@9, 0
  00055	74 45		 je	 SHORT $LN7@I_GetTime
  00057	8d 45 f4	 lea	 eax, DWORD PTR _currtime$1[ebp]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00061	85 c0		 test	 eax, eax
  00063	74 37		 je	 SHORT $LN7@I_GetTime

; 259  : 		{
; 260  : 			newtics = (int)((currtime.QuadPart - basetime.QuadPart) * TICRATE

  00065	8b 45 f4	 mov	 eax, DWORD PTR _currtime$1[ebp]
  00068	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?basetime@?2??I_GetTime@@9@9
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _currtime$1[ebp+4]
  00071	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR ?basetime@?2??I_GetTime@@9@9+4
  00077	6a 00		 push	 0
  00079	6a 23		 push	 35			; 00000023H
  0007b	51		 push	 ecx
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 __allmul
  00082	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?frequency@?2??I_GetTime@@9@9+4
  00088	51		 push	 ecx
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?frequency@?2??I_GetTime@@9@9
  0008f	51		 push	 ecx
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 __alldiv
  00097	89 45 fc	 mov	 DWORD PTR _newtics$[ebp], eax

; 261  : 				/ frequency.QuadPart);
; 262  : 		}

  0009a	eb 2f		 jmp	 SHORT $LN8@I_GetTime
$LN7@I_GetTime:

; 263  : 		else
; 264  : 		{
; 265  : 			currtime.LowPart = timeGetTime();

  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  000a2	89 45 f4	 mov	 DWORD PTR _currtime$1[ebp], eax

; 266  : 			if (!basetime.LowPart)

  000a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?basetime@?2??I_GetTime@@9@9, 0
  000ac	75 08		 jne	 SHORT $LN9@I_GetTime

; 267  : 				basetime.LowPart = currtime.LowPart;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR _currtime$1[ebp]
  000b1	a3 00 00 00 00	 mov	 DWORD PTR ?basetime@?2??I_GetTime@@9@9, eax
$LN9@I_GetTime:

; 268  : 			newtics = ((currtime.LowPart - basetime.LowPart)/(1000/TICRATE));

  000b6	8b 45 f4	 mov	 eax, DWORD PTR _currtime$1[ebp]
  000b9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?basetime@?2??I_GetTime@@9@9
  000bf	33 d2		 xor	 edx, edx
  000c1	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000c6	f7 f1		 div	 ecx
  000c8	89 45 fc	 mov	 DWORD PTR _newtics$[ebp], eax
$LN8@I_GetTime:

; 269  : 		}
; 270  : 	}

  000cb	eb 18		 jmp	 SHORT $LN3@I_GetTime
$LN2@I_GetTime:

; 271  : 	else
; 272  : 		newtics = (GetTickCount() - starttickcount)/(1000/TICRATE);

  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000d3	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _starttickcount
  000d9	33 d2		 xor	 edx, edx
  000db	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000e0	f7 f1		 div	 ecx
  000e2	89 45 fc	 mov	 DWORD PTR _newtics$[ebp], eax
$LN3@I_GetTime:

; 273  : 
; 274  : 	hacktics = newtics; // a local counter for keyboard repeat key

  000e5	8b 45 fc	 mov	 eax, DWORD PTR _newtics$[ebp]
  000e8	a3 00 00 00 00	 mov	 DWORD PTR _hacktics, eax

; 275  : 	return newtics;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _newtics$[ebp]

; 276  : }

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_I_GetTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetFreeMem
_TEXT	SEGMENT
_info$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_total$ = 8						; size = 4
_I_GetFreeMem PROC					; COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 192  : 	MEMORYSTATUS info;
; 193  : 
; 194  : 	info.dwLength = sizeof (MEMORYSTATUS);

  00013	c7 45 dc 20 00
	00 00		 mov	 DWORD PTR _info$[ebp], 32 ; 00000020H

; 195  : 	GlobalMemoryStatus(&info);

  0001a	8d 45 dc	 lea	 eax, DWORD PTR _info$[ebp]
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4
  00024	90		 npad	 1

; 196  : 	if (total)

  00025	83 7d 08 00	 cmp	 DWORD PTR _total$[ebp], 0
  00029	74 08		 je	 SHORT $LN2@I_GetFreeM

; 197  : 		*total = (UINT32)info.dwTotalPhys;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _total$[ebp]
  0002e	8b 4d e4	 mov	 ecx, DWORD PTR _info$[ebp+8]
  00031	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@I_GetFreeM:

; 198  : 	return (UINT32)info.dwAvailPhys;

  00033	8b 45 e8	 mov	 eax, DWORD PTR _info$[ebp+12]

; 199  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	33 cd		 xor	 ecx, ebp
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_I_GetFreeMem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_EndRead
_TEXT	SEGMENT
_I_EndRead PROC						; COMDAT

; 301  : void I_EndRead(void) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_I_EndRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_BeginRead
_TEXT	SEGMENT
_I_BeginRead PROC					; COMDAT

; 297  : void I_BeginRead(void) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_I_BeginRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_WaitVBL
_TEXT	SEGMENT
_count$ = 8						; size = 4
_I_WaitVBL PROC						; COMDAT

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 287  : 	count = 0;

  00009	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 288  : }

  00010	5f		 pop	 edi
  00011	5e		 pop	 esi
  00012	5b		 pop	 ebx
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_I_WaitVBL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_GetKey
_TEXT	SEGMENT
_ev$ = -4						; size = 4
_I_GetKey PROC						; COMDAT

; 3153 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3154 : 	event_t *ev;
; 3155 : 
; 3156 : 	if (eventtail != eventhead)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventtail
  0000e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _eventhead
  00014	74 3e		 je	 SHORT $LN4@I_GetKey

; 3157 : 	{
; 3158 : 		ev = &events[eventtail];

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventtail
  0001b	c1 e0 04	 shl	 eax, 4
  0001e	05 00 00 00 00	 add	 eax, OFFSET _events
  00023	89 45 fc	 mov	 DWORD PTR _ev$[ebp], eax

; 3159 : 		eventtail = (eventtail+1) & (MAXEVENTS-1);

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventtail
  0002b	83 c0 01	 add	 eax, 1
  0002e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00031	a3 00 00 00 00	 mov	 DWORD PTR _eventtail, eax

; 3160 : 		if (ev->type == ev_keydown || ev->type == ev_console)

  00036	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  00039	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003c	74 08		 je	 SHORT $LN5@I_GetKey
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  00041	83 38 02	 cmp	 DWORD PTR [eax], 2
  00044	75 0a		 jne	 SHORT $LN3@I_GetKey
$LN5@I_GetKey:

; 3161 : 			return ev->data1;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  00049	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004c	eb 08		 jmp	 SHORT $LN1@I_GetKey
  0004e	eb 04		 jmp	 SHORT $LN4@I_GetKey
$LN3@I_GetKey:

; 3162 : 		else
; 3163 : 			return 0;

  00050	33 c0		 xor	 eax, eax
  00052	eb 02		 jmp	 SHORT $LN1@I_GetKey
$LN4@I_GetKey:

; 3164 : 	}
; 3165 : 	return 0;

  00054	33 c0		 xor	 eax, eax
$LN1@I_GetKey:

; 3166 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_I_GetKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_sys.c
;	COMDAT _I_Error
_TEXT	SEGMENT
_txt$ = -8200						; size = 8192
_argptr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_error$ = 8						; size = 4
_I_Error PROC						; COMDAT

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 22 00 00	 mov	 eax, 8712		; 00002208H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 610  : 	va_list argptr;
; 611  : 	char txt[8192];
; 612  : 
; 613  : 	// added 11-2-98 recursive error detecting
; 614  : 	if (shutdowning)

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _shutdowning, 0
  00021	0f 84 a9 00 00
	00		 je	 $LN6@I_Error

; 615  : 	{
; 616  : 		errorcount++;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _errorcount
  0002c	83 c0 01	 add	 eax, 1
  0002f	a3 00 00 00 00	 mov	 DWORD PTR _errorcount, eax

; 617  : 		// try to shutdown each subsystem separately
; 618  : 		if (errorcount == 5)

  00034	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _errorcount, 5
  0003b	75 06		 jne	 SHORT $LN3@I_Error

; 619  : 			I_ShutdownGraphics();

  0003d	e8 00 00 00 00	 call	 _I_ShutdownGraphics
  00042	90		 npad	 1
$LN3@I_Error:

; 620  : 		if (errorcount == 6)

  00043	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _errorcount, 6
  0004a	75 06		 jne	 SHORT $LN4@I_Error

; 621  : 			I_ShutdownSystem();

  0004c	e8 00 00 00 00	 call	 _I_ShutdownSystem
  00051	90		 npad	 1
$LN4@I_Error:

; 622  : 		if (errorcount == 7)

  00052	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _errorcount, 7
  00059	75 10		 jne	 SHORT $LN5@I_Error

; 623  : 		{
; 624  : 			M_SaveConfig(NULL);

  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 _M_SaveConfig
  00062	83 c4 04	 add	 esp, 4

; 625  : 			G_SaveGameData();

  00065	e8 00 00 00 00	 call	 _G_SaveGameData
  0006a	90		 npad	 1
$LN5@I_Error:

; 626  : 		}
; 627  : 		if (errorcount > 20)

  0006b	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR _errorcount, 20 ; 00000014H
  00072	7e 5c		 jle	 SHORT $LN6@I_Error

; 628  : 		{
; 629  : 			// Don't print garbage
; 630  : 			va_start(argptr,error);

  00074	8d 45 0c	 lea	 eax, DWORD PTR _error$[ebp+4]
  00077	89 45 f8	 mov	 DWORD PTR _argptr$[ebp], eax

; 631  : 			vsprintf(txt, error, argptr);

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _argptr$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _error$[ebp]
  00081	51		 push	 ecx
  00082	8d 95 f8 df ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 _vsprintf
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 632  : 			va_end(argptr);

  00091	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _argptr$[ebp], 0

; 633  : 
; 634  : 			OutputDebugStringA(txt);

  00098	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  000a5	90		 npad	 1

; 635  : 			MessageBoxA(hWndMain, txt, "SRB2 Recursive Error", MB_OK|MB_ICONERROR);

  000a6	6a 10		 push	 16			; 00000010H
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HIGGEAIG@SRB2?5Recursive?5Error@
  000ad	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  000b3	50		 push	 eax
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  000ba	51		 push	 ecx
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000c1	90		 npad	 1

; 636  : 			W_Shutdown();

  000c2	e8 00 00 00 00	 call	 _W_Shutdown
  000c7	90		 npad	 1

; 637  : 			exit(-1); // recursive errors detected

  000c8	6a ff		 push	 -1
  000ca	e8 00 00 00 00	 call	 _exit
  000cf	90		 npad	 1
$LN6@I_Error:

; 638  : 		}
; 639  : 	}
; 640  : 	shutdowning = true;

  000d0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _shutdowning, 1

; 641  : 
; 642  : 	// put message to stderr
; 643  : 	va_start(argptr, error);

  000da	8d 45 0c	 lea	 eax, DWORD PTR _error$[ebp+4]
  000dd	89 45 f8	 mov	 DWORD PTR _argptr$[ebp], eax

; 644  : 	wvsprintfA(txt, error, argptr);

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _argptr$[ebp]
  000e3	50		 push	 eax
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _error$[ebp]
  000e7	51		 push	 ecx
  000e8	8d 95 f8 df ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  000ee	52		 push	 edx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wvsprintfA@12
  000f5	90		 npad	 1

; 645  : 	va_end(argptr);

  000f6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _argptr$[ebp], 0

; 646  : 
; 647  : 	CONS_Printf("I_Error(): %s\n", txt);

  000fd	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00103	50		 push	 eax
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PKDMOCMC@I_Error?$CI?$CJ?3?5?$CFs?6@
  00109	e8 00 00 00 00	 call	 _CONS_Printf
  0010e	83 c4 08	 add	 esp, 8

; 648  : 
; 649  : 	// saving one time is enough!
; 650  : 	if (!errorcount)

  00111	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _errorcount, 0
  00118	75 16		 jne	 SHORT $LN7@I_Error

; 651  : 	{
; 652  : 		M_SaveConfig(NULL); // save game config, cvars..

  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 _M_SaveConfig
  00121	83 c4 04	 add	 esp, 4

; 653  : #ifndef NONET
; 654  : 		D_SaveBan(); // save the ban list

  00124	e8 00 00 00 00	 call	 _D_SaveBan
  00129	90		 npad	 1

; 655  : #endif
; 656  : 		G_SaveGameData();

  0012a	e8 00 00 00 00	 call	 _G_SaveGameData
  0012f	90		 npad	 1
$LN7@I_Error:

; 657  : 	}
; 658  : 
; 659  : 	// save demo, could be useful for debug
; 660  : 	// NOTE: demos are normally not saved here.
; 661  : 	if (demorecording)

  00130	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demorecording, 0
  00137	74 06		 je	 SHORT $LN8@I_Error

; 662  : 		G_CheckDemoStatus();

  00139	e8 00 00 00 00	 call	 _G_CheckDemoStatus
  0013e	90		 npad	 1
$LN8@I_Error:

; 663  : 
; 664  : 	D_QuitNetGame();

  0013f	e8 00 00 00 00	 call	 _D_QuitNetGame
  00144	90		 npad	 1

; 665  : 
; 666  : 	// shutdown everything that was started
; 667  : 	I_ShutdownSystem();

  00145	e8 00 00 00 00	 call	 _I_ShutdownSystem
  0014a	90		 npad	 1

; 668  : 
; 669  : #ifdef LOGMESSAGES
; 670  : 	if (logstream != INVALID_HANDLE_VALUE)

  0014b	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _logstream, -1
  00152	74 17		 je	 SHORT $LN9@I_Error

; 671  : 	{
; 672  : 		CloseHandle(logstream);

  00154	a1 00 00 00 00	 mov	 eax, DWORD PTR _logstream
  00159	50		 push	 eax
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00160	90		 npad	 1

; 673  : 		logstream = INVALID_HANDLE_VALUE;

  00161	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _logstream, -1
$LN9@I_Error:

; 674  : 	}
; 675  : #endif
; 676  : 
; 677  : 	MessageBoxA(hWndMain, txt, "SRB2 Error", MB_OK|MB_ICONERROR);

  0016b	6a 10		 push	 16			; 00000010H
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HDMHDCFA@SRB2?5Error@
  00172	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00178	50		 push	 eax
  00179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  0017f	51		 push	 ecx
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00186	90		 npad	 1

; 678  : 
; 679  : 	W_Shutdown();

  00187	e8 00 00 00 00	 call	 _W_Shutdown
  0018c	90		 npad	 1

; 680  : 	exit(-1);

  0018d	6a ff		 push	 -1
  0018f	e8 00 00 00 00	 call	 _exit
  00194	90		 npad	 1
$LN1@I_Error:

; 681  : }

  00195	5f		 pop	 edi
  00196	5e		 pop	 esi
  00197	5b		 pop	 ebx
  00198	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	33 cd		 xor	 ecx, ebp
  0019d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
_I_Error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1474 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1475 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	e8 00 00 00 00	 call	 ___acrt_iob_func
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __vfprintf_l
  00029	83 c4 10	 add	 esp, 16			; 00000010H
  0002c	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
