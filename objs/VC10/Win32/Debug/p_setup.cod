; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\p_setup.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_numstarposts:DWORD
COMM	_playerstarts:DWORD:020H
COMM	_bluectfstarts:DWORD:020H
COMM	_redctfstarts:DWORD:020H
COMM	_tagstarts:DWORD:020H
COMM	_rejectmatrix:DWORD
COMM	_blockmaplump:DWORD
COMM	_blockmap:DWORD
COMM	_bmapwidth:DWORD
COMM	_bmapheight:DWORD
COMM	_bmaporgx:DWORD
COMM	_bmaporgy:DWORD
COMM	_blocklinks:DWORD
COMM	_mapmd5:BYTE:010H
COMM	_deathmatchstarts:DWORD:040H
COMM	_numdmstarts:DWORD
COMM	_numcoopstarts:DWORD
COMM	_numredctfstarts:DWORD
COMM	_numbluectfstarts:DWORD
COMM	_levelloading:DWORD
COMM	_lastloadedmaplumpnum:DWORD
COMM	_numlevelflats:DWORD
COMM	_levelflats:DWORD
COMM	_nummapthings:DWORD
COMM	_mapthings:DWORD
COMM	_numvertexes:DWORD
COMM	_vertexes:DWORD
COMM	_numsegs:DWORD
COMM	_segs:DWORD
COMM	_numsectors:DWORD
COMM	_sectors:DWORD
COMM	_numsubsectors:DWORD
COMM	_subsectors:DWORD
COMM	_numnodes:DWORD
COMM	_nodes:DWORD
COMM	_numlines:DWORD
COMM	_lines:DWORD
COMM	_numsides:DWORD
COMM	_sides:DWORD
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_P_AddLevelFlat
PUBLIC	_P_SetupLevelSky
PUBLIC	_P_SpawnSecretItems
PUBLIC	_P_LoadThingsOnly
PUBLIC	_P_RehitStarposts
PUBLIC	_P_SetupLevel
PUBLIC	_P_AddWadFile
PUBLIC	_P_DelWadFile
PUBLIC	_P_RunSOC
PUBLIC	_P_WriteThings
PUBLIC	_P_PrecacheLevelFlats
PUBLIC	_P_InitMapHeaders
PUBLIC	_P_ClearMapHeaderInfo
PUBLIC	_P_SegLength
PUBLIC	??_C@_03OACELNE@?$CFhd@				; `string'
PUBLIC	??_C@_04NLFBEIIO@Map?5@				; `string'
PUBLIC	??_C@_0O@GJJOFLPO@?5is?5corrupt?3?5@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0FA@HIKBONJC@Invalid?5or?5corrupt?5map?4?6Look?5in@ ; `string'
PUBLIC	??_C@_09MADBCAME@LEVELNAME@			; `string'
PUBLIC	??_C@_08OOGGCINI@SUBTITLE@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_03FBBILEHC@ACT@				; `string'
PUBLIC	??_C@_0M@GOKBOJDC@TYPEOFLEVEL@			; `string'
PUBLIC	??_C@_09HFCIMBHH@NEXTLEVEL@			; `string'
PUBLIC	??_C@_09MHGCKDNO@MUSICSLOT@			; `string'
PUBLIC	??_C@_0P@HOGKHGAO@FORCECHARACTER@		; `string'
PUBLIC	??_C@_07HKOGDAHK@WEATHER@			; `string'
PUBLIC	??_C@_06HEFJHGKD@SKYNUM@			; `string'
PUBLIC	??_C@_0M@PDGEIADF@INTERSCREEN@			; `string'
PUBLIC	??_C@_0L@OPDCCGFG@SCRIPTNAME@			; `string'
PUBLIC	??_C@_0N@BKNFDAOL@SCRIPTISLUMP@			; `string'
PUBLIC	??_C@_0P@DFENKLKN@PRECUTSCENENUM@		; `string'
PUBLIC	??_C@_0M@HBBFKHJP@CUTSCENENUM@			; `string'
PUBLIC	??_C@_09JPDDLCMH@COUNTDOWN@			; `string'
PUBLIC	??_C@_06MOHHBCJH@NOZONE@			; `string'
PUBLIC	??_C@_06JMIOFMHI@HIDDEN@			; `string'
PUBLIC	??_C@_09GKCLDIIP@NOSSMUSIC@			; `string'
PUBLIC	??_C@_0L@LHJOPLBJ@SPEEDMUSIC@			; `string'
PUBLIC	??_C@_08KPPNBABB@NORELOAD@			; `string'
PUBLIC	??_C@_0L@IKBJCDCO@TIMEATTACK@			; `string'
PUBLIC	??_C@_0M@JIALMPNC@LEVELSELECT@			; `string'
PUBLIC	??_C@_06BEHDNBAE@RUNSOC@			; `string'
PUBLIC	??_C@_0BD@NCJFJPLM@?$CD?5uload?5for?5map?5?$CFd@ ; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_07ICGPEHOB@PALLETE@			; `string'
PUBLIC	??_C@_0BG@IDLKBOPF@Level?5has?5no?5vertices@	; `string'
PUBLIC	??_C@_0BC@DFHLPIAF@Level?5has?5no?5segs@	; `string'
PUBLIC	??_C@_0EL@NCGEIFGK@Level?5has?5no?5subsectors?5?$CIdid?5yo@ ; `string'
PUBLIC	??_C@_0BB@PHOHEBBD@flat?5?$CD?$CF03Iu?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@OLDEIAOF@Too?5many?5flats?5in?5level?6@ ; `string'
PUBLIC	??_C@_0BF@EOKOOIH@Level?5has?5no?5sectors@	; `string'
PUBLIC	??_C@_0CJ@LDMLPKHB@Ran?5out?5of?5memory?5while?5loading@ ; `string'
PUBLIC	??_C@_0CG@BIJHGKIL@You?5need?5to?5unlock?5this?5level?5f@ ; `string'
PUBLIC	??_C@_0DH@ONBGHNBN@You?5need?5to?5unlock?5this?5level?5i@ ; `string'
PUBLIC	??_C@_06COAGKCEK@F_SKY1@			; `string'
PUBLIC	??_C@_0BD@ILKLNMIK@Level?5has?5no?5nodes@	; `string'
PUBLIC	??_C@_0CH@OAFMGKAJ@No?5more?5free?5memory?5for?5thingwr@ ; `string'
PUBLIC	??_C@_0BA@DADEGEMD@newthings?$CFd?4lmp@		; `string'
PUBLIC	??_C@_0BI@MICEHDEL@newthings?$CFd?4lmp?5saved?4?6@ ; `string'
PUBLIC	??_C@_0BG@FKLCMBOF@Level?5has?5no?5linedefs@	; `string'
PUBLIC	??_C@_0DN@DBCMDBON@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@ ; `string'
PUBLIC	??_C@_0DD@IAEFGEEH@P_LoadLineDefs?3?5linedef?5?$CFIu?5mis@ ; `string'
PUBLIC	??_C@_0EL@MAEEJAN@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@ ; `string'
PUBLIC	??_C@_09PGPPHINJ@?9compress@			; `string'
PUBLIC	??_C@_0CE@MBHMHGNG@Old?5sides?5is?5?$CFIu?0?5new?5sides?5is?5@ ; `string'
PUBLIC	??_C@_0BG@INLLBDAL@Level?5has?5no?5sidedefs@	; `string'
PUBLIC	??_C@_0DM@DEMECFOO@P_LoadSideDefs2?3?5sidedef?5?$CFu?5has@ ; `string'
PUBLIC	??_C@_0BB@FGCFFNMG@P_CreateBlockMap@		; `string'
PUBLIC	??_C@_0CC@IJGCFEOJ@?$CFs?3?5Out?5of?5memory?5making?5blockm@ ; `string'
PUBLIC	??_C@_0CC@HFBFKHEL@Out?5of?5Memory?5in?5P_CreateBlockM@ ; `string'
PUBLIC	??_C@_08CBJBDJDL@BLOCKMAP@			; `string'
PUBLIC	??_C@_0FD@EKDPMGBO@P_GroupLines?3?5ss?9?$DOfirstline?5inv@ ; `string'
PUBLIC	??_C@_0EE@MHIKDAMB@P_GroupLines?3?5seg?9?$DOsidedef?5is?5N@ ; `string'
PUBLIC	??_C@_0FJ@PGNAEKK@P_GroupLines?3?5seg?9?$DOsidedef?5refe@ ; `string'
PUBLIC	??_C@_0FM@CAHNKHED@P_GroupLines?3?5seg?9?$DOsidedef?9?$DOsec@ ; `string'
PUBLIC	??_C@_0BJ@KPGIHEEF@P_GroupLines?3?5miscounted@	; `string'
PUBLIC	??_C@_05GCBGCHNN@SKY?$CFd@			; `string'
PUBLIC	??_C@_0M@ICPNFHLJ@Making?5MD5?6@		; `string'
PUBLIC	??_C@_0BK@FECFKGNA@MD5?5calc?5took?5?$CFf?5seconds?6@ ; `string'
PUBLIC	??_C@_0CF@MGGLDKKC@You?5have?5to?5unlock?5this?5level?5f@ ; `string'
PUBLIC	??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@ ; `string'
PUBLIC	??_C@_08NNCMPFKC@exec?5?$CFs?6@			; `string'
PUBLIC	??_C@_09HINHNCGO@skin2?5?$CFs?6@		; `string'
PUBLIC	??_C@_08ILPMIBDL@skin?5?$CFs?6@			; `string'
PUBLIC	??_C@_0EJ@LCKKENJK@No?5player?5currently?5available?5t@ ; `string'
PUBLIC	??_C@_04DDPNCCIM@?4soc@				; `string'
PUBLIC	??_C@_0BG@HHLOHKHJ@Loading?5SOC?5lump?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@DOPEPGLB@couldn?8t?5load?5wad?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@BDHJKOOJ@Sound?5?$CF?48s?5replaced?6@	; `string'
PUBLIC	??_C@_0BF@GAOBMGJC@Music?5?$CF?48s?5replaced?6@	; `string'
PUBLIC	??_C@_0BF@DLLBJHGC@?$CFIu?5sounds?5replaced?6@	; `string'
PUBLIC	??_C@_0BF@EFBEAKFB@?$CFIu?5musics?5replaced?6@	; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0P@GEDPLKLD@no?5maps?5added?6@		; `string'
PUBLIC	??_C@_0FB@NNLECNHE@Current?5map?5?$CFd?5replaced?5by?5adde@ ; `string'
PUBLIC	__real@420c0000
PUBLIC	__real@47800000
PUBLIC	__real@bff0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memset:PROC
EXTRN	_strstr:PROC
EXTRN	_strncpy:PROC
EXTRN	_strnicmp:PROC
EXTRN	_strupr:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_abs:PROC
EXTRN	_atoi:PROC
EXTRN	_strlcpy:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_hypot:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_COM_BufInsertText:PROC
EXTRN	_COM_BufExecute:PROC
EXTRN	_CV_Set:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_CV_StealthSetValue:PROC
EXTRN	_W_LoadWadFile:PROC
EXTRN	_W_UnloadWadFile:PROC
EXTRN	_W_CheckNameForNum:PROC
EXTRN	_W_CheckNumForName:PROC
EXTRN	_W_GetNumForName:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_ReadLump:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_FixedHypot:PROC
EXTRN	_S_RemoveSoundFx:PROC
EXTRN	_P_InitCachedActions:PROC
EXTRN	_P_RunCachedActions:PROC
EXTRN	_P_SpawnMapThing:PROC
EXTRN	_P_SpawnHoopsAndRings:PROC
EXTRN	_P_SpawnPrecipitation:PROC
EXTRN	_SendNetXCmd:PROC
EXTRN	_G_BuildMapName:PROC
EXTRN	_G_DoReborn:PROC
EXTRN	_G_DeathMatchSpawnPlayer:PROC
EXTRN	_G_CoopSpawnPlayer:PROC
EXTRN	_G_SaveGame:PROC
EXTRN	_G_IsSpecialStage:PROC
EXTRN	_M_ClearBox:PROC
EXTRN	_M_AddToBox:PROC
EXTRN	_P_SetTarget:PROC
EXTRN	_P_PointOnLineSide:PROC
EXTRN	_P_InitThinkers:PROC
EXTRN	_P_ResetPlayer:PROC
EXTRN	_P_SpawnMobj:PROC
EXTRN	_P_RemoveMobj:PROC
EXTRN	_P_SetMobjState:PROC
EXTRN	_P_MobjThinker:PROC
EXTRN	_P_MapStart:PROC
EXTRN	_P_MapEnd:PROC
EXTRN	_P_UnsetThingPosition:PROC
EXTRN	_P_SetThingPosition:PROC
EXTRN	_P_Initsecnode:PROC
EXTRN	_P_ClearStarPost:PROC
EXTRN	_P_InitPicAnims:PROC
EXTRN	_P_SetupLevelFlatAnims:PROC
EXTRN	_P_SpawnSpecials:PROC
EXTRN	_P_SetMobjStateNF:PROC
EXTRN	_I_FreeSfx:PROC
EXTRN	_I_PlayCD:PROC
EXTRN	_I_FinishUpdate:PROC
EXTRN	_R_SetupSkyDraw:PROC
EXTRN	_I_GetTime:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_R_LoadTextures:PROC
EXTRN	_R_FlushTextureCache:PROC
EXTRN	_R_GetFlat:PROC
EXTRN	_R_PrecacheLevel:PROC
EXTRN	_R_GetFlatNumForName:PROC
EXTRN	_R_TextureNumForName:PROC
EXTRN	_R_CheckTextureNumForName:PROC
EXTRN	_R_ReInitColormaps:PROC
EXTRN	_R_CreateColormap:PROC
EXTRN	_R_MakeColormaps:PROC
EXTRN	_R_AddSpriteDefs:PROC
EXTRN	_R_DelSpriteDefs:PROC
EXTRN	_SetPlayerSkinByNum:PROC
EXTRN	_R_AddSkins:PROC
EXTRN	_R_DelSkins:PROC
EXTRN	_S_StopSounds:PROC
EXTRN	_S_ClearSfx:PROC
EXTRN	_S_Start:PROC
EXTRN	_S_StopSoundByNum:PROC
EXTRN	_ST_Start:PROC
EXTRN	_ST_UnloadGraphics:PROC
EXTRN	_ST_LoadGraphics:PROC
EXTRN	_ST_ReloadSkinFaceGraphics:PROC
EXTRN	_Z_FreeTags:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_Z_ReallocAlign:PROC
EXTRN	_HU_LoadGraphics:PROC
EXTRN	_HU_clearChatChars:PROC
EXTRN	_HU_ClearCEcho:PROC
EXTRN	_CON_ReSetupBackColormap:PROC
EXTRN	_CON_Drawer:PROC
EXTRN	_CON_LogMessage:PROC
EXTRN	_M_MapNumber:PROC
EXTRN	_FIL_WriteFile:PROC
EXTRN	_P_Random:PROC
EXTRN	_DEH_WriteUndoline:PROC
EXTRN	_DEH_LoadDehackedLump:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_md5_buffer:PROC
EXTRN	_HWR_CreatePlanePolygons:PROC
EXTRN	_HWR_PrepLevelCache:PROC
EXTRN	_HWR_CorrectSWTricks:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_ultimatemode:BYTE
EXTRN	_M_Memcpy:DWORD
EXTRN	_devparm:DWORD
EXTRN	_numwadfiles:WORD
EXTRN	_wadfiles:BYTE
EXTRN	_S_sfx:BYTE
EXTRN	_states:BYTE
EXTRN	_huntemeralds:BYTE
EXTRN	_numhuntemeralds:DWORD
EXTRN	_runemeraldmanager:DWORD
EXTRN	_playerstatetics:BYTE
EXTRN	_gamemap:WORD
EXTRN	_maptol:WORD
EXTRN	_globalweather:BYTE
EXTRN	_cursaveslot:DWORD
EXTRN	_lastmapsaved:WORD
EXTRN	_gamecomplete:DWORD
EXTRN	_modifiedgame:DWORD
EXTRN	_savemoddata:DWORD
EXTRN	_timeattacking:DWORD
EXTRN	_netgame:DWORD
EXTRN	_multiplayer:DWORD
EXTRN	_gametype:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_circuitmap:DWORD
EXTRN	_cv_debug:DWORD
EXTRN	_postimgtype:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_countdowntimer:DWORD
EXTRN	_countdowntimeup:BYTE
EXTRN	_nextmapoverride:WORD
EXTRN	_nextmapgametype:DWORD
EXTRN	_skipstats:DWORD
EXTRN	_totalrings:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	_emeralds:WORD
EXTRN	_numemblems:DWORD
EXTRN	_nummaprings:DWORD
EXTRN	_emblemlocations:BYTE
EXTRN	_mapvisited:BYTE
EXTRN	_tokenbits:DWORD
EXTRN	_hunt1:DWORD
EXTRN	_hunt2:DWORD
EXTRN	_hunt3:DWORD
EXTRN	_countdown:DWORD
EXTRN	_countdown2:DWORD
EXTRN	_grade:DWORD
EXTRN	_precache:DWORD
EXTRN	_cv_playercolor:BYTE
EXTRN	_cv_playercolor2:BYTE
EXTRN	_cv_skin2:BYTE
EXTRN	_cv_useranalog:BYTE
EXTRN	_cv_useranalog2:BYTE
EXTRN	_cv_analog:BYTE
EXTRN	_cv_analog2:BYTE
EXTRN	_cv_runscripts:BYTE
EXTRN	_server:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_players:BYTE
EXTRN	_playeringame:BYTE
EXTRN	_demoplayback:DWORD
EXTRN	_demorecording:DWORD
EXTRN	_timeinmap:DWORD
EXTRN	_localaiming:DWORD
EXTRN	_localaiming2:DWORD
EXTRN	_leveltime:DWORD
EXTRN	_polyblocklinks:DWORD
EXTRN	_thinkercap:BYTE
EXTRN	_camera:BYTE
EXTRN	_cv_cam_dist:BYTE
EXTRN	_cv_cam_height:BYTE
EXTRN	_cv_cam_speed:BYTE
EXTRN	_cv_cam_rotate:BYTE
EXTRN	_cv_cam2_dist:BYTE
EXTRN	_cv_cam2_height:BYTE
EXTRN	_cv_cam2_rotate:BYTE
EXTRN	_iquehead:DWORD
EXTRN	_iquetail:DWORD
EXTRN	_savedata:BYTE
EXTRN	_rendermode:DWORD
EXTRN	_skytexture:DWORD
EXTRN	_skyflatnum:DWORD
EXTRN	_levelskynum:DWORD
EXTRN	_globallevelskynum:DWORD
EXTRN	_extra_colormaps:BYTE
EXTRN	_numtextures:DWORD
EXTRN	_numskins:DWORD
EXTRN	_skins:BYTE
EXTRN	_cv_chasecam:BYTE
EXTRN	_cv_chasecam2:BYTE
EXTRN	_cv_grfov:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_maplumpname DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT ??_C@_0FB@NNLECNHE@Current?5map?5?$CFd?5replaced?5by?5adde@
CONST	SEGMENT
??_C@_0FB@NNLECNHE@Current?5map?5?$CFd?5replaced?5by?5adde@ DB 'Current m'
	DB	'ap %d replaced by added file, ending the level to ensure cons'
	DB	'istiency.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GEDPLKLD@no?5maps?5added?6@
CONST	SEGMENT
??_C@_0P@GEDPLKLD@no?5maps?5added?6@ DB 'no maps added', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EFBEAKFB@?$CFIu?5musics?5replaced?6@
CONST	SEGMENT
??_C@_0BF@EFBEAKFB@?$CFIu?5musics?5replaced?6@ DB '%Iu musics replaced', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DLLBJHGC@?$CFIu?5sounds?5replaced?6@
CONST	SEGMENT
??_C@_0BF@DLLBJHGC@?$CFIu?5sounds?5replaced?6@ DB '%Iu sounds replaced', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GAOBMGJC@Music?5?$CF?48s?5replaced?6@
CONST	SEGMENT
??_C@_0BF@GAOBMGJC@Music?5?$CF?48s?5replaced?6@ DB 'Music %.8s replaced', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BDHJKOOJ@Sound?5?$CF?48s?5replaced?6@
CONST	SEGMENT
??_C@_0BF@BDHJKOOJ@Sound?5?$CF?48s?5replaced?6@ DB 'Sound %.8s replaced', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOPEPGLB@couldn?8t?5load?5wad?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@DOPEPGLB@couldn?8t?5load?5wad?5file?5?$CFs?6@ DB 'couldn''t loa'
	DB	'd wad file %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HHLOHKHJ@Loading?5SOC?5lump?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@HHLOHKHJ@Loading?5SOC?5lump?3?5?$CFs?6@ DB 'Loading SOC lump: %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04DDPNCCIM@?4soc@
CONST	SEGMENT
??_C@_04DDPNCCIM@?4soc@ DB '.soc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@LCKKENJK@No?5player?5currently?5available?5t@
CONST	SEGMENT
??_C@_0EJ@LCKKENJK@No?5player?5currently?5available?5t@ DB 'No player cur'
	DB	'rently available to become IT. Awaiting available players.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILPMIBDL@skin?5?$CFs?6@
CONST	SEGMENT
??_C@_08ILPMIBDL@skin?5?$CFs?6@ DB 'skin %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HINHNCGO@skin2?5?$CFs?6@
CONST	SEGMENT
??_C@_09HINHNCGO@skin2?5?$CFs?6@ DB 'skin2 %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNCMPFKC@exec?5?$CFs?6@
CONST	SEGMENT
??_C@_08NNCMPFKC@exec?5?$CFs?6@ DB 'exec %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@
CONST	SEGMENT
??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@ DB 'SOC Err'
	DB	'or: script lump %s not found/not valid.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MGGLDKKC@You?5have?5to?5unlock?5this?5level?5f@
CONST	SEGMENT
??_C@_0CF@MGGLDKKC@You?5have?5to?5unlock?5this?5level?5f@ DB 'You have to'
	DB	' unlock this level first!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FECFKGNA@MD5?5calc?5took?5?$CFf?5seconds?6@
CONST	SEGMENT
??_C@_0BK@FECFKGNA@MD5?5calc?5took?5?$CFf?5seconds?6@ DB 'MD5 calc took %'
	DB	'f seconds', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICPNFHLJ@Making?5MD5?6@
CONST	SEGMENT
??_C@_0M@ICPNFHLJ@Making?5MD5?6@ DB 'Making MD5', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCBGCHNN@SKY?$CFd@
CONST	SEGMENT
??_C@_05GCBGCHNN@SKY?$CFd@ DB 'SKY%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KPGIHEEF@P_GroupLines?3?5miscounted@
CONST	SEGMENT
??_C@_0BJ@KPGIHEEF@P_GroupLines?3?5miscounted@ DB 'P_GroupLines: miscount'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@CAHNKHED@P_GroupLines?3?5seg?9?$DOsidedef?9?$DOsec@
CONST	SEGMENT
??_C@_0FM@CAHNKHED@P_GroupLines?3?5seg?9?$DOsidedef?9?$DOsec@ DB 'P_Group'
	DB	'Lines: seg->sidedef->sector is NULL (subsector %Iu, firstline'
	DB	' is %d, sidedef is %Iu)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@PGNAEKK@P_GroupLines?3?5seg?9?$DOsidedef?5refe@
CONST	SEGMENT
??_C@_0FJ@PGNAEKK@P_GroupLines?3?5seg?9?$DOsidedef?5refe@ DB 'P_GroupLine'
	DB	's: seg->sidedef refers to sidedef %Iu of %Iu (subsector %Iu, '
	DB	'firstline is %d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@MHIKDAMB@P_GroupLines?3?5seg?9?$DOsidedef?5is?5N@
CONST	SEGMENT
??_C@_0EE@MHIKDAMB@P_GroupLines?3?5seg?9?$DOsidedef?5is?5N@ DB 'P_GroupLi'
	DB	'nes: seg->sidedef is NULL (subsector %Iu, firstline is %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@EKDPMGBO@P_GroupLines?3?5ss?9?$DOfirstline?5inv@
CONST	SEGMENT
??_C@_0FD@EKDPMGBO@P_GroupLines?3?5ss?9?$DOfirstline?5inv@ DB 'P_GroupLin'
	DB	'es: ss->firstline invalid (subsector %Iu, firstline refers to'
	DB	' %d of %Iu)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08CBJBDJDL@BLOCKMAP@
CONST	SEGMENT
??_C@_08CBJBDJDL@BLOCKMAP@ DB 'BLOCKMAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HFBFKHEL@Out?5of?5Memory?5in?5P_CreateBlockM@
CONST	SEGMENT
??_C@_0CC@HFBFKHEL@Out?5of?5Memory?5in?5P_CreateBlockM@ DB 'Out of Memory'
	DB	' in P_CreateBlockMap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IJGCFEOJ@?$CFs?3?5Out?5of?5memory?5making?5blockm@
CONST	SEGMENT
??_C@_0CC@IJGCFEOJ@?$CFs?3?5Out?5of?5memory?5making?5blockm@ DB '%s: Out '
	DB	'of memory making blockmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGCFFNMG@P_CreateBlockMap@
CONST	SEGMENT
??_C@_0BB@FGCFFNMG@P_CreateBlockMap@ DB 'P_CreateBlockMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DEMECFOO@P_LoadSideDefs2?3?5sidedef?5?$CFu?5has@
CONST	SEGMENT
??_C@_0DM@DEMECFOO@P_LoadSideDefs2?3?5sidedef?5?$CFu?5has@ DB 'P_LoadSide'
	DB	'Defs2: sidedef %u has out-of-range sector num %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@INLLBDAL@Level?5has?5no?5sidedefs@
CONST	SEGMENT
??_C@_0BG@INLLBDAL@Level?5has?5no?5sidedefs@ DB 'Level has no sidedefs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MBHMHGNG@Old?5sides?5is?5?$CFIu?0?5new?5sides?5is?5@
CONST	SEGMENT
??_C@_0CE@MBHMHGNG@Old?5sides?5is?5?$CFIu?0?5new?5sides?5is?5@ DB 'Old si'
	DB	'des is %Iu, new sides is %Iu', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PGPPHINJ@?9compress@
CONST	SEGMENT
??_C@_09PGPPHINJ@?9compress@ DB '-compress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MAEEJAN@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@
CONST	SEGMENT
??_C@_0EL@MAEEJAN@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@ DB 'P_LoadLineD'
	DB	'efs: linedef %Iu has two-sided flag set, but no second sidede'
	DB	'f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IAEFGEEH@P_LoadLineDefs?3?5linedef?5?$CFIu?5mis@
CONST	SEGMENT
??_C@_0DD@IAEFGEEH@P_LoadLineDefs?3?5linedef?5?$CFIu?5mis@ DB 'P_LoadLine'
	DB	'Defs: linedef %Iu missing first sidedef', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@DBCMDBON@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@
CONST	SEGMENT
??_C@_0DN@DBCMDBON@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@ DB 'P_LoadLine'
	DB	'Defs: linedef %Iu has out-of-range sidedef number', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FKLCMBOF@Level?5has?5no?5linedefs@
CONST	SEGMENT
??_C@_0BG@FKLCMBOF@Level?5has?5no?5linedefs@ DB 'Level has no linedefs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MICEHDEL@newthings?$CFd?4lmp?5saved?4?6@
CONST	SEGMENT
??_C@_0BI@MICEHDEL@newthings?$CFd?4lmp?5saved?4?6@ DB 'newthings%d.lmp sa'
	DB	'ved.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DADEGEMD@newthings?$CFd?4lmp@
CONST	SEGMENT
??_C@_0BA@DADEGEMD@newthings?$CFd?4lmp@ DB 'newthings%d.lmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OAFMGKAJ@No?5more?5free?5memory?5for?5thingwr@
CONST	SEGMENT
??_C@_0CH@OAFMGKAJ@No?5more?5free?5memory?5for?5thingwr@ DB 'No more free'
	DB	' memory for thingwriting!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ILKLNMIK@Level?5has?5no?5nodes@
CONST	SEGMENT
??_C@_0BD@ILKLNMIK@Level?5has?5no?5nodes@ DB 'Level has no nodes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06COAGKCEK@F_SKY1@
CONST	SEGMENT
??_C@_06COAGKCEK@F_SKY1@ DB 'F_SKY1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ONBGHNBN@You?5need?5to?5unlock?5this?5level?5i@
CONST	SEGMENT
??_C@_0DH@ONBGHNBN@You?5need?5to?5unlock?5this?5level?5i@ DB 'You need to'
	DB	' unlock this level in single player first!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BIJHGKIL@You?5need?5to?5unlock?5this?5level?5f@
CONST	SEGMENT
??_C@_0CG@BIJHGKIL@You?5need?5to?5unlock?5this?5level?5f@ DB 'You need to'
	DB	' unlock this level first!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LDMLPKHB@Ran?5out?5of?5memory?5while?5loading@
CONST	SEGMENT
??_C@_0CJ@LDMLPKHB@Ran?5out?5of?5memory?5while?5loading@ DB 'Ran out of m'
	DB	'emory while loading sectors', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EOKOOIH@Level?5has?5no?5sectors@
CONST	SEGMENT
??_C@_0BF@EOKOOIH@Level?5has?5no?5sectors@ DB 'Level has no sectors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OLDEIAOF@Too?5many?5flats?5in?5level?6@
CONST	SEGMENT
??_C@_0BJ@OLDEIAOF@Too?5many?5flats?5in?5level?6@ DB 'Too many flats in l'
	DB	'evel', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHOHEBBD@flat?5?$CD?$CF03Iu?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@PHOHEBBD@flat?5?$CD?$CF03Iu?3?5?$CFs?6@ DB 'flat #%03Iu: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NCGEIFGK@Level?5has?5no?5subsectors?5?$CIdid?5yo@
CONST	SEGMENT
??_C@_0EL@NCGEIFGK@Level?5has?5no?5subsectors?5?$CIdid?5yo@ DB 'Level has'
	DB	' no subsectors (did you forget to run it through a nodesbuild'
	DB	'er?)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DFHLPIAF@Level?5has?5no?5segs@
CONST	SEGMENT
??_C@_0BC@DFHLPIAF@Level?5has?5no?5segs@ DB 'Level has no segs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDLKBOPF@Level?5has?5no?5vertices@
CONST	SEGMENT
??_C@_0BG@IDLKBOPF@Level?5has?5no?5vertices@ DB 'Level has no vertices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ICGPEHOB@PALLETE@
CONST	SEGMENT
??_C@_07ICGPEHOB@PALLETE@ DB 'PALLETE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NCJFJPLM@?$CD?5uload?5for?5map?5?$CFd@
CONST	SEGMENT
??_C@_0BD@NCJFJPLM@?$CD?5uload?5for?5map?5?$CFd@ DB '# uload for map %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BEHDNBAE@RUNSOC@
CONST	SEGMENT
??_C@_06BEHDNBAE@RUNSOC@ DB 'RUNSOC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIALMPNC@LEVELSELECT@
CONST	SEGMENT
??_C@_0M@JIALMPNC@LEVELSELECT@ DB 'LEVELSELECT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKBJCDCO@TIMEATTACK@
CONST	SEGMENT
??_C@_0L@IKBJCDCO@TIMEATTACK@ DB 'TIMEATTACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPPNBABB@NORELOAD@
CONST	SEGMENT
??_C@_08KPPNBABB@NORELOAD@ DB 'NORELOAD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHJOPLBJ@SPEEDMUSIC@
CONST	SEGMENT
??_C@_0L@LHJOPLBJ@SPEEDMUSIC@ DB 'SPEEDMUSIC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKCLDIIP@NOSSMUSIC@
CONST	SEGMENT
??_C@_09GKCLDIIP@NOSSMUSIC@ DB 'NOSSMUSIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMIOFMHI@HIDDEN@
CONST	SEGMENT
??_C@_06JMIOFMHI@HIDDEN@ DB 'HIDDEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MOHHBCJH@NOZONE@
CONST	SEGMENT
??_C@_06MOHHBCJH@NOZONE@ DB 'NOZONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JPDDLCMH@COUNTDOWN@
CONST	SEGMENT
??_C@_09JPDDLCMH@COUNTDOWN@ DB 'COUNTDOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFKHJP@CUTSCENENUM@
CONST	SEGMENT
??_C@_0M@HBBFKHJP@CUTSCENENUM@ DB 'CUTSCENENUM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFENKLKN@PRECUTSCENENUM@
CONST	SEGMENT
??_C@_0P@DFENKLKN@PRECUTSCENENUM@ DB 'PRECUTSCENENUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BKNFDAOL@SCRIPTISLUMP@
CONST	SEGMENT
??_C@_0N@BKNFDAOL@SCRIPTISLUMP@ DB 'SCRIPTISLUMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPDCCGFG@SCRIPTNAME@
CONST	SEGMENT
??_C@_0L@OPDCCGFG@SCRIPTNAME@ DB 'SCRIPTNAME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PDGEIADF@INTERSCREEN@
CONST	SEGMENT
??_C@_0M@PDGEIADF@INTERSCREEN@ DB 'INTERSCREEN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HEFJHGKD@SKYNUM@
CONST	SEGMENT
??_C@_06HEFJHGKD@SKYNUM@ DB 'SKYNUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HKOGDAHK@WEATHER@
CONST	SEGMENT
??_C@_07HKOGDAHK@WEATHER@ DB 'WEATHER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOGKHGAO@FORCECHARACTER@
CONST	SEGMENT
??_C@_0P@HOGKHGAO@FORCECHARACTER@ DB 'FORCECHARACTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHGCKDNO@MUSICSLOT@
CONST	SEGMENT
??_C@_09MHGCKDNO@MUSICSLOT@ DB 'MUSICSLOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFCIMBHH@NEXTLEVEL@
CONST	SEGMENT
??_C@_09HFCIMBHH@NEXTLEVEL@ DB 'NEXTLEVEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOKBOJDC@TYPEOFLEVEL@
CONST	SEGMENT
??_C@_0M@GOKBOJDC@TYPEOFLEVEL@ DB 'TYPEOFLEVEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FBBILEHC@ACT@
CONST	SEGMENT
??_C@_03FBBILEHC@ACT@ DB 'ACT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOGGCINI@SUBTITLE@
CONST	SEGMENT
??_C@_08OOGGCINI@SUBTITLE@ DB 'SUBTITLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MADBCAME@LEVELNAME@
CONST	SEGMENT
??_C@_09MADBCAME@LEVELNAME@ DB 'LEVELNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@HIKBONJC@Invalid?5or?5corrupt?5map?4?6Look?5in@
CONST	SEGMENT
??_C@_0FA@HIKBONJC@Invalid?5or?5corrupt?5map?4?6Look?5in@ DB 'Invalid or '
	DB	'corrupt map.', 0aH, 'Look in log file or text console for tec'
	DB	'hnical details.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GJJOFLPO@?5is?5corrupt?3?5@
CONST	SEGMENT
??_C@_0O@GJJOFLPO@?5is?5corrupt?3?5@ DB ' is corrupt: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NLFBEIIO@Map?5@
CONST	SEGMENT
??_C@_04NLFBEIIO@Map?5@ DB 'Map ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OACELNE@?$CFhd@
CONST	SEGMENT
??_C@_03OACELNE@?$CFhd@ DB '%hd', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	017dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	038aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03c5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	09eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0bdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0f89H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	04fH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_MakeMapMD5
_TEXT	SEGMENT
_datasides$ = -104					; size = 4
_datathings$ = -100					; size = 4
_datasectors$ = -96					; size = 4
_datalines$ = -92					; size = 4
_i$ = -85						; size = 1
_resmd5$ = -84						; size = 16
_sidedefmd5$ = -68					; size = 16
_thingmd5$ = -52					; size = 16
_sectormd5$ = -36					; size = 16
_linemd5$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_maplumpnum$ = 8					; size = 4
_dest$ = 12						; size = 4
_P_MakeMapMD5 PROC					; COMDAT

; 1964 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1965 : 	unsigned char linemd5[16];
; 1966 : 	unsigned char sectormd5[16];
; 1967 : 	unsigned char thingmd5[16];
; 1968 : 	unsigned char sidedefmd5[16];
; 1969 : 	unsigned char resmd5[16];
; 1970 : 	UINT8 i;
; 1971 : 
; 1972 : 	// Create a hash for the current map
; 1973 : 	// get the actual lumps!
; 1974 : 	UINT8 *datalines   = W_CacheLumpNum(maplumpnum + ML_LINEDEFS, PU_CACHE);

  00016	6a 65		 push	 101			; 00000065H
  00018	8b 45 08	 mov	 eax, DWORD PTR _maplumpnum$[ebp]
  0001b	83 c0 02	 add	 eax, 2
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 a4	 mov	 DWORD PTR _datalines$[ebp], eax

; 1975 : 	UINT8 *datasectors = W_CacheLumpNum(maplumpnum + ML_SECTORS, PU_CACHE);

  0002a	6a 65		 push	 101			; 00000065H
  0002c	8b 45 08	 mov	 eax, DWORD PTR _maplumpnum$[ebp]
  0002f	83 c0 08	 add	 eax, 8
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00038	83 c4 08	 add	 esp, 8
  0003b	89 45 a0	 mov	 DWORD PTR _datasectors$[ebp], eax

; 1976 : 	UINT8 *datathings  = W_CacheLumpNum(maplumpnum + ML_THINGS, PU_CACHE);

  0003e	6a 65		 push	 101			; 00000065H
  00040	8b 45 08	 mov	 eax, DWORD PTR _maplumpnum$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0004c	83 c4 08	 add	 esp, 8
  0004f	89 45 9c	 mov	 DWORD PTR _datathings$[ebp], eax

; 1977 : 	UINT8 *datasides   = W_CacheLumpNum(maplumpnum + ML_SIDEDEFS, PU_CACHE);

  00052	6a 65		 push	 101			; 00000065H
  00054	8b 45 08	 mov	 eax, DWORD PTR _maplumpnum$[ebp]
  00057	83 c0 03	 add	 eax, 3
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00060	83 c4 08	 add	 esp, 8
  00063	89 45 98	 mov	 DWORD PTR _datasides$[ebp], eax

; 1978 : 
; 1979 : 	P_MakeBufferMD5((char*)datalines,   W_LumpLength(maplumpnum + ML_LINEDEFS), linemd5);

  00066	8d 45 ec	 lea	 eax, DWORD PTR _linemd5$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _maplumpnum$[ebp]
  0006d	83 c1 02	 add	 ecx, 2
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _W_LumpLength
  00076	83 c4 04	 add	 esp, 4
  00079	50		 push	 eax
  0007a	8b 55 a4	 mov	 edx, DWORD PTR _datalines$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _P_MakeBufferMD5
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1980 : 	P_MakeBufferMD5((char*)datasectors, W_LumpLength(maplumpnum + ML_SECTORS),  sectormd5);

  00086	8d 45 dc	 lea	 eax, DWORD PTR _sectormd5$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _maplumpnum$[ebp]
  0008d	83 c1 08	 add	 ecx, 8
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _W_LumpLength
  00096	83 c4 04	 add	 esp, 4
  00099	50		 push	 eax
  0009a	8b 55 a0	 mov	 edx, DWORD PTR _datasectors$[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _P_MakeBufferMD5
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1981 : 	P_MakeBufferMD5((char*)datathings,  W_LumpLength(maplumpnum + ML_THINGS),   thingmd5);

  000a6	8d 45 cc	 lea	 eax, DWORD PTR _thingmd5$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _maplumpnum$[ebp]
  000ad	83 c1 01	 add	 ecx, 1
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _W_LumpLength
  000b6	83 c4 04	 add	 esp, 4
  000b9	50		 push	 eax
  000ba	8b 55 9c	 mov	 edx, DWORD PTR _datathings$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _P_MakeBufferMD5
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1982 : 	P_MakeBufferMD5((char*)datasides,   W_LumpLength(maplumpnum + ML_SIDEDEFS), sidedefmd5);

  000c6	8d 45 bc	 lea	 eax, DWORD PTR _sidedefmd5$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _maplumpnum$[ebp]
  000cd	83 c1 03	 add	 ecx, 3
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _W_LumpLength
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	8b 55 98	 mov	 edx, DWORD PTR _datasides$[ebp]
  000dd	52		 push	 edx
  000de	e8 00 00 00 00	 call	 _P_MakeBufferMD5
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1983 : 
; 1984 : 	Z_Free(datalines);

  000e6	8b 45 a4	 mov	 eax, DWORD PTR _datalines$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _Z_Free
  000ef	83 c4 04	 add	 esp, 4

; 1985 : 	Z_Free(datasectors);

  000f2	8b 45 a0	 mov	 eax, DWORD PTR _datasectors$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _Z_Free
  000fb	83 c4 04	 add	 esp, 4

; 1986 : 	Z_Free(datathings);

  000fe	8b 45 9c	 mov	 eax, DWORD PTR _datathings$[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _Z_Free
  00107	83 c4 04	 add	 esp, 4

; 1987 : 	Z_Free(datasides);

  0010a	8b 45 98	 mov	 eax, DWORD PTR _datasides$[ebp]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _Z_Free
  00113	83 c4 04	 add	 esp, 4

; 1988 : 
; 1989 : 	for (i = 0; i < 16; i++)

  00116	c6 45 ab 00	 mov	 BYTE PTR _i$[ebp], 0
  0011a	eb 08		 jmp	 SHORT $LN4@P_MakeMapM
$LN2@P_MakeMapM:
  0011c	8a 45 ab	 mov	 al, BYTE PTR _i$[ebp]
  0011f	04 01		 add	 al, 1
  00121	88 45 ab	 mov	 BYTE PTR _i$[ebp], al
$LN4@P_MakeMapM:
  00124	0f b6 45 ab	 movzx	 eax, BYTE PTR _i$[ebp]
  00128	83 f8 10	 cmp	 eax, 16			; 00000010H
  0012b	7d 3a		 jge	 SHORT $LN3@P_MakeMapM

; 1990 : 		resmd5[i] = (linemd5[i] + sectormd5[i] + thingmd5[i] + sidedefmd5[i]) & 0xFF;

  0012d	0f b6 45 ab	 movzx	 eax, BYTE PTR _i$[ebp]
  00131	0f b6 4c 05 ec	 movzx	 ecx, BYTE PTR _linemd5$[ebp+eax]
  00136	0f b6 55 ab	 movzx	 edx, BYTE PTR _i$[ebp]
  0013a	0f b6 44 15 dc	 movzx	 eax, BYTE PTR _sectormd5$[ebp+edx]
  0013f	03 c8		 add	 ecx, eax
  00141	0f b6 55 ab	 movzx	 edx, BYTE PTR _i$[ebp]
  00145	0f b6 44 15 cc	 movzx	 eax, BYTE PTR _thingmd5$[ebp+edx]
  0014a	03 c8		 add	 ecx, eax
  0014c	0f b6 55 ab	 movzx	 edx, BYTE PTR _i$[ebp]
  00150	0f b6 44 15 bc	 movzx	 eax, BYTE PTR _sidedefmd5$[ebp+edx]
  00155	03 c8		 add	 ecx, eax
  00157	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0015d	0f b6 55 ab	 movzx	 edx, BYTE PTR _i$[ebp]
  00161	88 4c 15 ac	 mov	 BYTE PTR _resmd5$[ebp+edx], cl
  00165	eb b5		 jmp	 SHORT $LN2@P_MakeMapM
$LN3@P_MakeMapM:

; 1991 : 
; 1992 : 	M_Memcpy(dest, &resmd5, 16);

  00167	6a 10		 push	 16			; 00000010H
  00169	8d 45 ac	 lea	 eax, DWORD PTR _resmd5$[ebp]
  0016c	50		 push	 eax
  0016d	8b 4d 0c	 mov	 ecx, DWORD PTR _dest$[ebp]
  00170	51		 push	 ecx
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1993 : }

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00180	33 cd		 xor	 ecx, ebp
  00182	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
_P_MakeMapMD5 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_MakeBufferMD5
_TEXT	SEGMENT
tv90 = -80						; size = 8
tv87 = -72						; size = 4
_t$ = -4						; size = 4
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_resblock$ = 16						; size = 4
_P_MakeBufferMD5 PROC					; COMDAT

; 1940 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1941 : #ifdef NOMD5
; 1942 : 	(void)buffer;
; 1943 : 	(void)len;
; 1944 : 	memset(resblock, 0x00, 16);
; 1945 : 	return 1;
; 1946 : #else
; 1947 : 	tic_t t = I_GetTime();

  00009	e8 00 00 00 00	 call	 _I_GetTime
  0000e	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1948 : #ifndef _arch_dreamcast
; 1949 : 	if (devparm)

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00018	74 0d		 je	 SHORT $LN2@P_MakeBuff

; 1950 : #endif
; 1951 : 	CONS_Printf("Making MD5\n");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@ICPNFHLJ@Making?5MD5?6@
  0001f	e8 00 00 00 00	 call	 _CONS_Printf
  00024	83 c4 04	 add	 esp, 4
$LN2@P_MakeBuff:

; 1952 : 	if (md5_buffer(buffer, len, resblock) == NULL)

  00027	8b 45 10	 mov	 eax, DWORD PTR _resblock$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _md5_buffer
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	85 c0		 test	 eax, eax
  0003d	75 07		 jne	 SHORT $LN3@P_MakeBuff

; 1953 : 		return 1;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	eb 55		 jmp	 SHORT $LN1@P_MakeBuff
$LN3@P_MakeBuff:

; 1954 : #ifndef _arch_dreamcast
; 1955 : 	if (devparm)

  00046	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  0004d	74 4a		 je	 SHORT $LN4@P_MakeBuff

; 1956 : #endif
; 1957 : 	CONS_Printf("MD5 calc took %f seconds\n",

  0004f	e8 00 00 00 00	 call	 _I_GetTime
  00054	2b 45 fc	 sub	 eax, DWORD PTR _t$[ebp]
  00057	89 45 b8	 mov	 DWORD PTR tv87[ebp], eax
  0005a	f2 0f 2a 45 b8	 cvtsi2sd xmm0, DWORD PTR tv87[ebp]
  0005f	8b 45 b8	 mov	 eax, DWORD PTR tv87[ebp]
  00062	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00065	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0006e	f2 0f 11 45 b0	 movsd	 QWORD PTR tv90[ebp], xmm0
  00073	f2 0f 5a 45 b0	 cvtsd2ss xmm0, QWORD PTR tv90[ebp]
  00078	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@420c0000
  00080	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00084	83 ec 08	 sub	 esp, 8
  00087	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FECFKGNA@MD5?5calc?5took?5?$CFf?5seconds?6@
  00091	e8 00 00 00 00	 call	 _CONS_Printf
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@P_MakeBuff:

; 1958 : 		(float)(I_GetTime() - t)/TICRATE);
; 1959 : 	return 0;

  00099	33 c0		 xor	 eax, eax
$LN1@P_MakeBuff:

; 1960 : #endif
; 1961 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_P_MakeBufferMD5 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LevelInitStuff
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_P_LevelInitStuff PROC					; COMDAT

; 1813 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1814 : 	INT32 i, j;
; 1815 : 
; 1816 : 	circuitmap = false;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _circuitmap, 0

; 1817 : 	numstarposts = 0;

  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numstarposts, 0

; 1818 : 	totalrings = timeinmap = 0;

  0001d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _timeinmap, 0
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _timeinmap
  0002c	a3 00 00 00 00	 mov	 DWORD PTR _totalrings, eax

; 1819 : 
; 1820 : 	for (i = 0; i < MAXPLAYERS; i++)

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00038	eb 09		 jmp	 SHORT $LN4@P_LevelIni
$LN2@P_LevelIni:
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	83 c0 01	 add	 eax, 1
  00040	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_LevelIni:
  00043	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00047	0f 8d e4 01 00
	00		 jge	 $LN3@P_LevelIni

; 1821 : 	{
; 1822 : 		// Initialize the player state duration table.
; 1823 : 		for (j = 0; j < S_PLAY_SUPERTRANS9+1; j++)

  0004d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00054	eb 09		 jmp	 SHORT $LN7@P_LevelIni
$LN5@P_LevelIni:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@P_LevelIni:
  0005f	83 7d f8 3a	 cmp	 DWORD PTR _j$[ebp], 58	; 0000003aH
  00063	7d 1d		 jge	 SHORT $LN6@P_LevelIni

; 1824 : 			playerstatetics[i][j] = states[j].tics;

  00065	6b 45 f8 1c	 imul	 eax, DWORD PTR _j$[ebp], 28
  00069	69 4d fc e8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 232
  00070	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00073	8b 80 08 00 00
	00		 mov	 eax, DWORD PTR _states[eax+8]
  00079	89 84 91 00 00
	00 00		 mov	 DWORD PTR _playerstatetics[ecx+edx*4], eax
  00080	eb d4		 jmp	 SHORT $LN5@P_LevelIni
$LN6@P_LevelIni:

; 1825 : 
; 1826 : 		if (netgame || multiplayer)

  00082	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00089	75 09		 jne	 SHORT $LN9@P_LevelIni
  0008b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00092	74 2f		 je	 SHORT $LN11@P_LevelIni
$LN9@P_LevelIni:

; 1827 : 		{
; 1828 : 			// In Co-Op, replenish a user's lives if they are depleted.
; 1829 : 			if (ultimatemode)

  00094	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _ultimatemode
  0009b	85 c0		 test	 eax, eax
  0009d	74 13		 je	 SHORT $LN10@P_LevelIni

; 1830 : 				players[i].lives = 1;

  0009f	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000a6	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR _players[eax+256], 1
  000b0	eb 11		 jmp	 SHORT $LN11@P_LevelIni
$LN10@P_LevelIni:

; 1831 : 			else
; 1832 : 				players[i].lives = 3;

  000b2	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000b9	c7 80 00 01 00
	00 03 00 00 00	 mov	 DWORD PTR _players[eax+256], 3
$LN11@P_LevelIni:

; 1833 : 		}
; 1834 : 
; 1835 : 		players[i].realtime = countdown = countdown2 = 0;

  000c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _countdown2, 0
  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _countdown2
  000d2	a3 00 00 00 00	 mov	 DWORD PTR _countdown, eax
  000d7	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  000de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _countdown
  000e4	89 91 54 01 00
	00		 mov	 DWORD PTR _players[ecx+340], edx

; 1836 : 
; 1837 : 		players[i].xtralife = players[i].deadtimer = players[i].numboxes = players[i].totalring = players[i].laps = 0;

  000ea	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000f1	c7 80 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+348], 0
  000fb	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  00102	c7 81 50 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[ecx+336], 0
  0010c	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  00113	c7 82 4c 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[edx+332], 0
  0011d	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00124	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+296], 0
  0012e	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  00135	c7 81 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[ecx+264], 0

; 1838 : 		players[i].health = 1;

  0013f	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00146	c7 80 28 00 00
	00 01 00 00 00	 mov	 DWORD PTR _players[eax+40], 1

; 1839 : 		players[i].nightstime = players[i].mare = 0;

  00150	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00157	c6 80 d4 01 00
	00 00		 mov	 BYTE PTR _players[eax+468], 0
  0015e	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  00165	c7 81 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[ecx+452], 0

; 1840 : 		P_SetTarget(&players[i].capsule, NULL);

  0016f	6a 00		 push	 0
  00171	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00178	05 d0 01 00 00	 add	 eax, OFFSET _players+464
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _P_SetTarget
  00183	83 c4 08	 add	 esp, 8

; 1841 : 		players[i].aiming = players[i].dbginfo = 0;

  00186	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0018d	c7 80 68 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+360], 0
  00197	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  0019e	c7 81 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[ecx+32], 0

; 1842 : 		players[i].pflags &= ~PF_TIMEOVER;

  001a8	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001af	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  001b5	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  001bb	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  001c2	89 8a ac 00 00
	00		 mov	 DWORD PTR _players[edx+172], ecx

; 1843 : 
; 1844 : 		if (gametype == GT_RACE && players[i].lives < 3)

  001c8	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  001cf	83 f8 02	 cmp	 eax, 2
  001d2	75 21		 jne	 SHORT $LN12@P_LevelIni
  001d4	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001db	83 b8 00 01 00
	00 03		 cmp	 DWORD PTR _players[eax+256], 3
  001e2	7d 11		 jge	 SHORT $LN12@P_LevelIni

; 1845 : 			players[i].lives = 3;

  001e4	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001eb	c7 80 00 01 00
	00 03 00 00 00	 mov	 DWORD PTR _players[eax+256], 3
$LN12@P_LevelIni:

; 1846 : 
; 1847 : 		players[i].exiting = 0;

  001f5	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001fc	c7 80 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+304], 0

; 1848 : 		P_ResetPlayer(&players[i]);

  00206	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0020d	05 00 00 00 00	 add	 eax, OFFSET _players
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _P_ResetPlayer
  00218	83 c4 04	 add	 esp, 4

; 1849 : 
; 1850 : 		players[i].mo = NULL;

  0021b	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00222	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax], 0

; 1851 : 	}

  0022c	e9 09 fe ff ff	 jmp	 $LN2@P_LevelIni
$LN3@P_LevelIni:

; 1852 : 
; 1853 : 	hunt1 = hunt2 = hunt3 = NULL;

  00231	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hunt3, 0
  0023b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hunt3
  00240	a3 00 00 00 00	 mov	 DWORD PTR _hunt2, eax
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hunt2
  0024b	89 0d 00 00 00
	00		 mov	 DWORD PTR _hunt1, ecx

; 1854 : 
; 1855 : 	leveltime = 0;

  00251	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _leveltime, 0

; 1856 : 
; 1857 : 	localaiming = 0;

  0025b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _localaiming, 0

; 1858 : 	localaiming2 = 0;

  00265	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _localaiming2, 0

; 1859 : 
; 1860 : 	if (mapheaderinfo[gamemap-1].countdown)

  0026f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00276	83 e8 01	 sub	 eax, 1
  00279	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0027f	0f bf 91 1e 01
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+286]
  00286	85 d2		 test	 edx, edx
  00288	74 21		 je	 SHORT $LN13@P_LevelIni

; 1861 : 		countdowntimer = mapheaderinfo[gamemap-1].countdown * TICRATE;

  0028a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00291	83 e8 01	 sub	 eax, 1
  00294	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0029a	0f bf 91 1e 01
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+286]
  002a1	6b c2 23	 imul	 eax, edx, 35
  002a4	a3 00 00 00 00	 mov	 DWORD PTR _countdowntimer, eax
  002a9	eb 0a		 jmp	 SHORT $LN14@P_LevelIni
$LN13@P_LevelIni:

; 1862 : 	else
; 1863 : 		countdowntimer = 0;

  002ab	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _countdowntimer, 0
$LN14@P_LevelIni:

; 1864 : 
; 1865 : 	countdowntimeup = false; // DuuuuuuuuuhhhH!H!H!!

  002b5	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _countdowntimeup, 0

; 1866 : }

  002bc	5f		 pop	 edi
  002bd	5e		 pop	 esi
  002be	5b		 pop	 ebx
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
_P_LevelInitStuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_GroupLines
_TEXT	SEGMENT
_bbox$ = -56						; size = 16
_seg$ = -40						; size = 4
_sidei$ = -36						; size = 4
_ss$ = -32						; size = 4
_sector$ = -28						; size = 4
_li$ = -24						; size = 4
_total$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_linebuffer$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_P_GroupLines PROC					; COMDAT

; 1680 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1681 : 	line_t **linebuffer;
; 1682 : 	size_t i, j, total = 0;

  00013	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _total$[ebp], 0

; 1683 : 	line_t *li = lines;

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  0001f	89 45 e8	 mov	 DWORD PTR _li$[ebp], eax

; 1684 : 	sector_t *sector = sectors;

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00027	89 45 e4	 mov	 DWORD PTR _sector$[ebp], eax

; 1685 : 	subsector_t *ss = subsectors;

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR _subsectors
  0002f	89 45 e0	 mov	 DWORD PTR _ss$[ebp], eax

; 1686 : 	size_t sidei;
; 1687 : 	seg_t *seg;
; 1688 : 	fixed_t bbox[4];
; 1689 : 
; 1690 : 	// look up sector number for each subsector
; 1691 : 	for (i = 0; i < numsubsectors; i++, ss++)

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00039	eb 12		 jmp	 SHORT $LN4@P_GroupLin
$LN2@P_GroupLin:
  0003b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00044	8b 4d e0	 mov	 ecx, DWORD PTR _ss$[ebp]
  00047	83 c1 14	 add	 ecx, 20			; 00000014H
  0004a	89 4d e0	 mov	 DWORD PTR _ss$[ebp], ecx
$LN4@P_GroupLin:
  0004d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00050	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsubsectors
  00056	0f 83 2c 01 00
	00		 jae	 $LN3@P_GroupLin

; 1692 : 	{
; 1693 : 		if (ss->firstline >= numsegs)

  0005c	8b 45 e0	 mov	 eax, DWORD PTR _ss$[ebp]
  0005f	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00063	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numsegs
  00069	72 26		 jb	 SHORT $LN14@P_GroupLin

; 1694 : 			CorruptMapError(va("P_GroupLines: ss->firstline invalid "

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsegs
  00070	50		 push	 eax
  00071	8b 4d e0	 mov	 ecx, DWORD PTR _ss$[ebp]
  00074	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00078	52		 push	 edx
  00079	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	50		 push	 eax
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@EKDPMGBO@P_GroupLines?3?5ss?9?$DOfirstline?5inv@
  00082	e8 00 00 00 00	 call	 _va
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _CorruptMapError
  00090	90		 npad	 1
$LN14@P_GroupLin:

; 1695 : 				"(subsector %"PRIdS", firstline refers to %d of %"PRIdS")", i, ss->firstline,
; 1696 : 				numsegs));
; 1697 : 		seg = &segs[ss->firstline];

  00091	8b 45 e0	 mov	 eax, DWORD PTR _ss$[ebp]
  00094	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00098	6b d1 3c	 imul	 edx, ecx, 60
  0009b	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  000a1	89 55 d8	 mov	 DWORD PTR _seg$[ebp], edx

; 1698 : 		sidei = (size_t)(seg->sidedef - sides);

  000a4	8b 45 d8	 mov	 eax, DWORD PTR _seg$[ebp]
  000a7	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000aa	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sides
  000b0	99		 cdq
  000b1	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000b6	f7 f9		 idiv	 ecx
  000b8	89 45 dc	 mov	 DWORD PTR _sidei$[ebp], eax

; 1699 : 		if (!seg->sidedef)

  000bb	8b 45 d8	 mov	 eax, DWORD PTR _seg$[ebp]
  000be	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  000c2	75 20		 jne	 SHORT $LN15@P_GroupLin

; 1700 : 			CorruptMapError(va("P_GroupLines: seg->sidedef is NULL "

  000c4	8b 45 e0	 mov	 eax, DWORD PTR _ss$[ebp]
  000c7	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  000cb	51		 push	 ecx
  000cc	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000cf	52		 push	 edx
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@MHIKDAMB@P_GroupLines?3?5seg?9?$DOsidedef?5is?5N@
  000d5	e8 00 00 00 00	 call	 _va
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _CorruptMapError
  000e3	90		 npad	 1
$LN15@P_GroupLin:

; 1701 : 				"(subsector %"PRIdS", firstline is %d)", i, ss->firstline));
; 1702 : 		if (seg->sidedef - sides < 0 || seg->sidedef - sides > (UINT16)numsides)

  000e4	8b 45 d8	 mov	 eax, DWORD PTR _seg$[ebp]
  000e7	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000ea	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sides
  000f0	99		 cdq
  000f1	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  000f6	f7 f9		 idiv	 ecx
  000f8	85 c0		 test	 eax, eax
  000fa	7c 1f		 jl	 SHORT $LN17@P_GroupLin
  000fc	8b 45 d8	 mov	 eax, DWORD PTR _seg$[ebp]
  000ff	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00102	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sides
  00108	99		 cdq
  00109	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0010e	f7 f9		 idiv	 ecx
  00110	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR _numsides
  00117	3b c2		 cmp	 eax, edx
  00119	7e 2a		 jle	 SHORT $LN16@P_GroupLin
$LN17@P_GroupLin:

; 1703 : 			CorruptMapError(va("P_GroupLines: seg->sidedef refers to sidedef %"PRIdS" of %"PRIdS" "

  0011b	8b 45 e0	 mov	 eax, DWORD PTR _ss$[ebp]
  0011e	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00122	51		 push	 ecx
  00123	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00126	52		 push	 edx
  00127	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsides
  0012c	50		 push	 eax
  0012d	8b 4d dc	 mov	 ecx, DWORD PTR _sidei$[ebp]
  00130	51		 push	 ecx
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@PGNAEKK@P_GroupLines?3?5seg?9?$DOsidedef?5refe@
  00136	e8 00 00 00 00	 call	 _va
  0013b	83 c4 14	 add	 esp, 20			; 00000014H
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _CorruptMapError
  00144	90		 npad	 1
$LN16@P_GroupLin:

; 1704 : 				"(subsector %"PRIdS", firstline is %d)", sidei, numsides,
; 1705 : 				i, ss->firstline));
; 1706 : 		if (!seg->sidedef->sector)

  00145	8b 45 d8	 mov	 eax, DWORD PTR _seg$[ebp]
  00148	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0014b	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0014f	75 24		 jne	 SHORT $LN18@P_GroupLin

; 1707 : 			CorruptMapError(va("P_GroupLines: seg->sidedef->sector is NULL "

  00151	8b 45 dc	 mov	 eax, DWORD PTR _sidei$[ebp]
  00154	50		 push	 eax
  00155	8b 4d e0	 mov	 ecx, DWORD PTR _ss$[ebp]
  00158	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0015c	52		 push	 edx
  0015d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00160	50		 push	 eax
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@CAHNKHED@P_GroupLines?3?5seg?9?$DOsidedef?9?$DOsec@
  00166	e8 00 00 00 00	 call	 _va
  0016b	83 c4 10	 add	 esp, 16			; 00000010H
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _CorruptMapError
  00174	90		 npad	 1
$LN18@P_GroupLin:

; 1708 : 				"(subsector %"PRIdS", firstline is %d, sidedef is %"PRIdS")", i, ss->firstline,
; 1709 : 				sidei));
; 1710 : 		ss->sector = seg->sidedef->sector;

  00175	8b 45 d8	 mov	 eax, DWORD PTR _seg$[ebp]
  00178	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0017b	8b 55 e0	 mov	 edx, DWORD PTR _ss$[ebp]
  0017e	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00181	89 02		 mov	 DWORD PTR [edx], eax

; 1711 : 	}

  00183	e9 b3 fe ff ff	 jmp	 $LN2@P_GroupLin
$LN3@P_GroupLin:

; 1712 : 
; 1713 : 	// count number of lines in each sector
; 1714 : 	for (i = 0; i < numlines; i++, li++)

  00188	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0018f	eb 12		 jmp	 SHORT $LN7@P_GroupLin
$LN5@P_GroupLin:
  00191	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00194	83 c0 01	 add	 eax, 1
  00197	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  0019a	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  0019d	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001a0	89 4d e8	 mov	 DWORD PTR _li$[ebp], ecx
$LN7@P_GroupLin:
  001a3	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001a6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  001ac	73 61		 jae	 SHORT $LN6@P_GroupLin

; 1715 : 	{
; 1716 : 		total++;

  001ae	8b 45 ec	 mov	 eax, DWORD PTR _total$[ebp]
  001b1	83 c0 01	 add	 eax, 1
  001b4	89 45 ec	 mov	 DWORD PTR _total$[ebp], eax

; 1717 : 		li->frontsector->linecount++;

  001b7	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001ba	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001bd	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  001c3	83 c2 01	 add	 edx, 1
  001c6	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001c9	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001cc	89 91 88 00 00
	00		 mov	 DWORD PTR [ecx+136], edx

; 1718 : 
; 1719 : 		if (li->backsector && li->backsector != li->frontsector)

  001d2	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001d5	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  001d9	74 32		 je	 SHORT $LN19@P_GroupLin
  001db	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001de	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  001e1	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  001e4	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  001e7	74 24		 je	 SHORT $LN19@P_GroupLin

; 1720 : 		{
; 1721 : 			li->backsector->linecount++;

  001e9	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001ec	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001ef	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  001f5	83 c2 01	 add	 edx, 1
  001f8	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001fb	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001fe	89 91 88 00 00
	00		 mov	 DWORD PTR [ecx+136], edx

; 1722 : 			total++;

  00204	8b 45 ec	 mov	 eax, DWORD PTR _total$[ebp]
  00207	83 c0 01	 add	 eax, 1
  0020a	89 45 ec	 mov	 DWORD PTR _total$[ebp], eax
$LN19@P_GroupLin:

; 1723 : 		}
; 1724 : 	}

  0020d	eb 82		 jmp	 SHORT $LN5@P_GroupLin
$LN6@P_GroupLin:

; 1725 : 
; 1726 : 	// build line tables for each sector
; 1727 : 	linebuffer = Z_Calloc(total * sizeof (*linebuffer), PU_LEVEL, NULL);

  0020f	6a 00		 push	 0
  00211	6a 00		 push	 0
  00213	6a 32		 push	 50			; 00000032H
  00215	8b 45 ec	 mov	 eax, DWORD PTR _total$[ebp]
  00218	c1 e0 02	 shl	 eax, 2
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 _Z_CallocAlign
  00221	83 c4 10	 add	 esp, 16			; 00000010H
  00224	89 45 f8	 mov	 DWORD PTR _linebuffer$[ebp], eax

; 1728 : 	for (i = 0; i < numsectors; i++, sector++)

  00227	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0022e	eb 15		 jmp	 SHORT $LN10@P_GroupLin
$LN8@P_GroupLin:
  00230	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00233	83 c0 01	 add	 eax, 1
  00236	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  00239	8b 4d e4	 mov	 ecx, DWORD PTR _sector$[ebp]
  0023c	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  00242	89 4d e4	 mov	 DWORD PTR _sector$[ebp], ecx
$LN10@P_GroupLin:
  00245	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00248	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  0024e	0f 83 33 01 00
	00		 jae	 $LN9@P_GroupLin

; 1729 : 	{
; 1730 : 		M_ClearBox(bbox);

  00254	8d 45 c8	 lea	 eax, DWORD PTR _bbox$[ebp]
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 _M_ClearBox
  0025d	83 c4 04	 add	 esp, 4

; 1731 : 		sector->lines = linebuffer;

  00260	8b 45 e4	 mov	 eax, DWORD PTR _sector$[ebp]
  00263	8b 4d f8	 mov	 ecx, DWORD PTR _linebuffer$[ebp]
  00266	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx

; 1732 : 		li = lines;

  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  00271	89 45 e8	 mov	 DWORD PTR _li$[ebp], eax

; 1733 : 		for (j = 0; j < numlines; j++, li++)

  00274	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0027b	eb 12		 jmp	 SHORT $LN13@P_GroupLin
$LN11@P_GroupLin:
  0027d	8b 45 f0	 mov	 eax, DWORD PTR _j$[ebp]
  00280	83 c0 01	 add	 eax, 1
  00283	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax
  00286	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  00289	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0028c	89 4d e8	 mov	 DWORD PTR _li$[ebp], ecx
$LN13@P_GroupLin:
  0028f	8b 45 f0	 mov	 eax, DWORD PTR _j$[ebp]
  00292	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00298	73 68		 jae	 SHORT $LN12@P_GroupLin

; 1734 : 		{
; 1735 : 			if (li->frontsector == sector || li->backsector == sector)

  0029a	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  0029d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  002a0	3b 4d e4	 cmp	 ecx, DWORD PTR _sector$[ebp]
  002a3	74 0b		 je	 SHORT $LN21@P_GroupLin
  002a5	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  002a8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002ab	3b 4d e4	 cmp	 ecx, DWORD PTR _sector$[ebp]
  002ae	75 4d		 jne	 SHORT $LN20@P_GroupLin
$LN21@P_GroupLin:

; 1736 : 			{
; 1737 : 				*linebuffer = li;

  002b0	8b 45 f8	 mov	 eax, DWORD PTR _linebuffer$[ebp]
  002b3	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  002b6	89 08		 mov	 DWORD PTR [eax], ecx

; 1738 : 				linebuffer++;

  002b8	8b 45 f8	 mov	 eax, DWORD PTR _linebuffer$[ebp]
  002bb	83 c0 04	 add	 eax, 4
  002be	89 45 f8	 mov	 DWORD PTR _linebuffer$[ebp], eax

; 1739 : 				M_AddToBox(bbox, li->v1->x, li->v1->y);

  002c1	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  002c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002c9	52		 push	 edx
  002ca	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  002cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d1	52		 push	 edx
  002d2	8d 45 c8	 lea	 eax, DWORD PTR _bbox$[ebp]
  002d5	50		 push	 eax
  002d6	e8 00 00 00 00	 call	 _M_AddToBox
  002db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1740 : 				M_AddToBox(bbox, li->v2->x, li->v2->y);

  002de	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  002e1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002e7	52		 push	 edx
  002e8	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  002eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	52		 push	 edx
  002f1	8d 45 c8	 lea	 eax, DWORD PTR _bbox$[ebp]
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 _M_AddToBox
  002fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@P_GroupLin:

; 1741 : 			}
; 1742 : 		}

  002fd	e9 7b ff ff ff	 jmp	 $LN11@P_GroupLin
$LN12@P_GroupLin:

; 1743 : 		if ((size_t)(linebuffer - sector->lines) != sector->linecount)

  00302	8b 45 e4	 mov	 eax, DWORD PTR _sector$[ebp]
  00305	8b 4d f8	 mov	 ecx, DWORD PTR _linebuffer$[ebp]
  00308	2b 88 8c 00 00
	00		 sub	 ecx, DWORD PTR [eax+140]
  0030e	c1 f9 02	 sar	 ecx, 2
  00311	8b 55 e4	 mov	 edx, DWORD PTR _sector$[ebp]
  00314	3b 8a 88 00 00
	00		 cmp	 ecx, DWORD PTR [edx+136]
  0031a	74 0b		 je	 SHORT $LN22@P_GroupLin

; 1744 : 			CorruptMapError("P_GroupLines: miscounted");

  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KPGIHEEF@P_GroupLines?3?5miscounted@
  00321	e8 00 00 00 00	 call	 _CorruptMapError
  00326	90		 npad	 1
$LN22@P_GroupLin:

; 1745 : 
; 1746 : 		// set the degenmobj_t to the middle of the bounding box
; 1747 : 		sector->soundorg.x = (((bbox[BOXRIGHT]>>FRACBITS) + (bbox[BOXLEFT]>>FRACBITS))/2)<<FRACBITS;

  00327	b8 04 00 00 00	 mov	 eax, 4
  0032c	6b c8 03	 imul	 ecx, eax, 3
  0032f	8b 44 0d c8	 mov	 eax, DWORD PTR _bbox$[ebp+ecx]
  00333	c1 f8 10	 sar	 eax, 16			; 00000010H
  00336	ba 04 00 00 00	 mov	 edx, 4
  0033b	d1 e2		 shl	 edx, 1
  0033d	8b 4c 15 c8	 mov	 ecx, DWORD PTR _bbox$[ebp+edx]
  00341	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00344	03 c1		 add	 eax, ecx
  00346	99		 cdq
  00347	2b c2		 sub	 eax, edx
  00349	d1 f8		 sar	 eax, 1
  0034b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0034e	8b 55 e4	 mov	 edx, DWORD PTR _sector$[ebp]
  00351	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 1748 : 		sector->soundorg.y = (((bbox[BOXTOP]>>FRACBITS) + (bbox[BOXBOTTOM]>>FRACBITS))/2)<<FRACBITS;

  00354	b8 04 00 00 00	 mov	 eax, 4
  00359	6b c8 00	 imul	 ecx, eax, 0
  0035c	8b 44 0d c8	 mov	 eax, DWORD PTR _bbox$[ebp+ecx]
  00360	c1 f8 10	 sar	 eax, 16			; 00000010H
  00363	ba 04 00 00 00	 mov	 edx, 4
  00368	c1 e2 00	 shl	 edx, 0
  0036b	8b 4c 15 c8	 mov	 ecx, DWORD PTR _bbox$[ebp+edx]
  0036f	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00372	03 c1		 add	 eax, ecx
  00374	99		 cdq
  00375	2b c2		 sub	 eax, edx
  00377	d1 f8		 sar	 eax, 1
  00379	c1 e0 10	 shl	 eax, 16			; 00000010H
  0037c	8b 55 e4	 mov	 edx, DWORD PTR _sector$[ebp]
  0037f	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 1749 : 	}

  00382	e9 a9 fe ff ff	 jmp	 $LN8@P_GroupLin
$LN9@P_GroupLin:

; 1750 : }

  00387	5f		 pop	 edi
  00388	5e		 pop	 esi
  00389	5b		 pop	 ebx
  0038a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038d	33 cd		 xor	 ecx, ebp
  0038f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00394	8b e5		 mov	 esp, ebp
  00396	5d		 pop	 ebp
  00397	c3		 ret	 0
_P_GroupLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadBlockMap
_TEXT	SEGMENT
tv155 = -88						; size = 4
_t$1 = -20						; size = 2
_wadblockmaplump$2 = -16				; size = 4
_i$3 = -12						; size = 4
_lumpname$ = -8						; size = 4
_count$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadBlockMap PROC					; COMDAT

; 1589 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1590 : #if 0
; 1591 : 	(void)lumpnum;
; 1592 : 	return false;
; 1593 : #else
; 1594 : 	size_t count;
; 1595 : 	const char *lumpname = W_CheckNameForNum(lumpnum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_CheckNameForNum
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 f8	 mov	 DWORD PTR _lumpname$[ebp], eax

; 1596 : 
; 1597 : 	// Check if the lump exists, and if it's named "BLOCKMAP"
; 1598 : 	if (!lumpname || memcmp(lumpname, "BLOCKMAP", 8) != 0)

  00018	83 7d f8 00	 cmp	 DWORD PTR _lumpname$[ebp], 0
  0001c	74 17		 je	 SHORT $LN6@P_LoadBloc
  0001e	6a 08		 push	 8
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_08CBJBDJDL@BLOCKMAP@
  00025	8b 45 f8	 mov	 eax, DWORD PTR _lumpname$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _memcmp
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	85 c0		 test	 eax, eax
  00033	74 07		 je	 SHORT $LN5@P_LoadBloc
$LN6@P_LoadBloc:

; 1599 : 	{
; 1600 : 		return false;

  00035	33 c0		 xor	 eax, eax
  00037	e9 24 02 00 00	 jmp	 $LN1@P_LoadBloc
$LN5@P_LoadBloc:

; 1601 : 	}
; 1602 : 
; 1603 : 	count = W_LumpLength(lumpnum);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _W_LumpLength
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 1604 : 
; 1605 : 	if (!count || count >= 0x20000)

  0004b	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0004f	74 09		 je	 SHORT $LN8@P_LoadBloc
  00051	81 7d fc 00 00
	02 00		 cmp	 DWORD PTR _count$[ebp], 131072 ; 00020000H
  00058	72 07		 jb	 SHORT $LN7@P_LoadBloc
$LN8@P_LoadBloc:

; 1606 : 		return false;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 ff 01 00 00	 jmp	 $LN1@P_LoadBloc
$LN7@P_LoadBloc:

; 1607 : 
; 1608 : 	{
; 1609 : 		size_t i;
; 1610 : 		INT16 *wadblockmaplump = malloc(count); //INT16 *wadblockmaplump = W_CacheLumpNum (lump, PU_LEVEL);

  00061	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _malloc
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 f0	 mov	 DWORD PTR _wadblockmaplump$2[ebp], eax

; 1611 : 
; 1612 : 		if (wadblockmaplump) W_ReadLump(lumpnum, wadblockmaplump);

  00070	83 7d f0 00	 cmp	 DWORD PTR _wadblockmaplump$2[ebp], 0
  00074	74 12		 je	 SHORT $LN9@P_LoadBloc
  00076	8b 45 f0	 mov	 eax, DWORD PTR _wadblockmaplump$2[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _lumpnum$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _W_ReadLump
  00083	83 c4 08	 add	 esp, 8
  00086	eb 07		 jmp	 SHORT $LN10@P_LoadBloc
$LN9@P_LoadBloc:

; 1613 : 		else return false;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 d1 01 00 00	 jmp	 $LN1@P_LoadBloc
$LN10@P_LoadBloc:

; 1614 : 		count /= 2;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00092	d1 e8		 shr	 eax, 1
  00094	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 1615 : 		blockmaplump = Z_Calloc(sizeof (*blockmaplump) * count, PU_LEVEL, 0);

  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	6a 32		 push	 50			; 00000032H
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000a0	c1 e0 02	 shl	 eax, 2
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _Z_CallocAlign
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
  000ac	a3 00 00 00 00	 mov	 DWORD PTR _blockmaplump, eax

; 1616 : 
; 1617 : 		// killough 3/1/98: Expand wad blockmap into larger internal one,
; 1618 : 		// by treating all offsets except -1 as unsigned and zero-extending
; 1619 : 		// them. This potentially doubles the size of blockmaps allowed,
; 1620 : 		// because Doom originally considered the offsets as always signed.
; 1621 : 
; 1622 : 		blockmaplump[0] = SHORT(wadblockmaplump[0]);

  000b1	b8 02 00 00 00	 mov	 eax, 2
  000b6	6b c8 00	 imul	 ecx, eax, 0
  000b9	ba 04 00 00 00	 mov	 edx, 4
  000be	6b c2 00	 imul	 eax, edx, 0
  000c1	8b 55 f0	 mov	 edx, DWORD PTR _wadblockmaplump$2[ebp]
  000c4	0f bf 0c 0a	 movsx	 ecx, WORD PTR [edx+ecx]
  000c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _blockmaplump
  000ce	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 1623 : 		blockmaplump[1] = SHORT(wadblockmaplump[1]);

  000d1	b8 02 00 00 00	 mov	 eax, 2
  000d6	c1 e0 00	 shl	 eax, 0
  000d9	b9 04 00 00 00	 mov	 ecx, 4
  000de	c1 e1 00	 shl	 ecx, 0
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _wadblockmaplump$2[ebp]
  000e4	0f bf 04 02	 movsx	 eax, WORD PTR [edx+eax]
  000e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _blockmaplump
  000ee	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 1624 : 		blockmaplump[2] = (INT32)(SHORT(wadblockmaplump[2])) & 0xffff;

  000f1	b8 02 00 00 00	 mov	 eax, 2
  000f6	d1 e0		 shl	 eax, 1
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _wadblockmaplump$2[ebp]
  000fb	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  000ff	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00105	b8 04 00 00 00	 mov	 eax, 4
  0010a	d1 e0		 shl	 eax, 1
  0010c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  00112	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 1625 : 		blockmaplump[3] = (INT32)(SHORT(wadblockmaplump[3])) & 0xffff;

  00115	b8 02 00 00 00	 mov	 eax, 2
  0011a	6b c8 03	 imul	 ecx, eax, 3
  0011d	8b 55 f0	 mov	 edx, DWORD PTR _wadblockmaplump$2[ebp]
  00120	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00124	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00129	b9 04 00 00 00	 mov	 ecx, 4
  0012e	6b d1 03	 imul	 edx, ecx, 3
  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  00137	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 1626 : 
; 1627 : 		for (i = 4; i < count; i++)

  0013a	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 4
  00141	eb 09		 jmp	 SHORT $LN4@P_LoadBloc
$LN2@P_LoadBloc:
  00143	8b 45 f4	 mov	 eax, DWORD PTR _i$3[ebp]
  00146	83 c0 01	 add	 eax, 1
  00149	89 45 f4	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@P_LoadBloc:
  0014c	8b 45 f4	 mov	 eax, DWORD PTR _i$3[ebp]
  0014f	3b 45 fc	 cmp	 eax, DWORD PTR _count$[ebp]
  00152	73 3d		 jae	 SHORT $LN3@P_LoadBloc

; 1628 : 		{
; 1629 : 			INT16 t = SHORT(wadblockmaplump[i]);          // killough 3/1/98

  00154	8b 45 f4	 mov	 eax, DWORD PTR _i$3[ebp]
  00157	8b 4d f0	 mov	 ecx, DWORD PTR _wadblockmaplump$2[ebp]
  0015a	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0015e	66 89 55 ec	 mov	 WORD PTR _t$1[ebp], dx

; 1630 : 			blockmaplump[i] = t == -1 ? (INT32)-1 : (INT32) t & 0xffff;

  00162	0f bf 45 ec	 movsx	 eax, WORD PTR _t$1[ebp]
  00166	83 f8 ff	 cmp	 eax, -1
  00169	75 09		 jne	 SHORT $LN12@P_LoadBloc
  0016b	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR tv155[ebp], -1
  00172	eb 0d		 jmp	 SHORT $LN13@P_LoadBloc
$LN12@P_LoadBloc:
  00174	0f bf 4d ec	 movsx	 ecx, WORD PTR _t$1[ebp]
  00178	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0017e	89 4d a8	 mov	 DWORD PTR tv155[ebp], ecx
$LN13@P_LoadBloc:
  00181	8b 55 f4	 mov	 edx, DWORD PTR _i$3[ebp]
  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockmaplump
  00189	8b 4d a8	 mov	 ecx, DWORD PTR tv155[ebp]
  0018c	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 1631 : 		}

  0018f	eb b2		 jmp	 SHORT $LN2@P_LoadBloc
$LN3@P_LoadBloc:

; 1632 : 
; 1633 : 		free(wadblockmaplump);

  00191	8b 45 f0	 mov	 eax, DWORD PTR _wadblockmaplump$2[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _free
  0019a	83 c4 04	 add	 esp, 4

; 1634 : 
; 1635 : 		bmaporgx = blockmaplump[0]<<FRACBITS;

  0019d	b8 04 00 00 00	 mov	 eax, 4
  001a2	6b c8 00	 imul	 ecx, eax, 0
  001a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _blockmaplump
  001ab	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001ae	c1 e0 10	 shl	 eax, 16			; 00000010H
  001b1	a3 00 00 00 00	 mov	 DWORD PTR _bmaporgx, eax

; 1636 : 		bmaporgy = blockmaplump[1]<<FRACBITS;

  001b6	b8 04 00 00 00	 mov	 eax, 4
  001bb	c1 e0 00	 shl	 eax, 0
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  001c4	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001c7	c1 e2 10	 shl	 edx, 16			; 00000010H
  001ca	89 15 00 00 00
	00		 mov	 DWORD PTR _bmaporgy, edx

; 1637 : 		bmapwidth = blockmaplump[2];

  001d0	b8 04 00 00 00	 mov	 eax, 4
  001d5	d1 e0		 shl	 eax, 1
  001d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  001dd	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001e0	89 15 00 00 00
	00		 mov	 DWORD PTR _bmapwidth, edx

; 1638 : 		bmapheight = blockmaplump[3];

  001e6	b8 04 00 00 00	 mov	 eax, 4
  001eb	6b c8 03	 imul	 ecx, eax, 3
  001ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _blockmaplump
  001f4	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001f7	a3 00 00 00 00	 mov	 DWORD PTR _bmapheight, eax

; 1639 : 	}
; 1640 : 
; 1641 : 	// clear out mobj chains
; 1642 : 	count = sizeof (*blocklinks)* bmapwidth*bmapheight;

  001fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmapwidth
  00201	c1 e0 02	 shl	 eax, 2
  00204	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapheight
  0020b	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 1643 : 	blocklinks = Z_Calloc(count, PU_LEVEL, NULL);

  0020e	6a 00		 push	 0
  00210	6a 00		 push	 0
  00212	6a 32		 push	 50			; 00000032H
  00214	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 _Z_CallocAlign
  0021d	83 c4 10	 add	 esp, 16			; 00000010H
  00220	a3 00 00 00 00	 mov	 DWORD PTR _blocklinks, eax

; 1644 : 	blockmap = blockmaplump+4;

  00225	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockmaplump
  0022a	83 c0 10	 add	 eax, 16			; 00000010H
  0022d	a3 00 00 00 00	 mov	 DWORD PTR _blockmap, eax

; 1645 : 
; 1646 : #ifdef POLYOBJECTS
; 1647 : 	// haleyjd 2/22/06: setup polyobject blockmap
; 1648 : 	count = sizeof(*polyblocklinks) * bmapwidth * bmapheight;

  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmapwidth
  00237	c1 e0 02	 shl	 eax, 2
  0023a	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapheight
  00241	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 1649 : 	polyblocklinks = Z_Calloc(count, PU_LEVEL, NULL);

  00244	6a 00		 push	 0
  00246	6a 00		 push	 0
  00248	6a 32		 push	 50			; 00000032H
  0024a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 _Z_CallocAlign
  00253	83 c4 10	 add	 esp, 16			; 00000010H
  00256	a3 00 00 00 00	 mov	 DWORD PTR _polyblocklinks, eax

; 1650 : #endif
; 1651 : 	return true;

  0025b	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_LoadBloc:

; 1652 : /* Original
; 1653 : 		blockmaplump = W_CacheLumpNum(lump, PU_LEVEL);
; 1654 : 		blockmap = blockmaplump+4;
; 1655 : 		count = W_LumpLength (lump)/2;
; 1656 : 
; 1657 : 		for (i = 0; i < count; i++)
; 1658 : 			blockmaplump[i] = SHORT(blockmaplump[i]);
; 1659 : 
; 1660 : 		bmaporgx = blockmaplump[0]<<FRACBITS;
; 1661 : 		bmaporgy = blockmaplump[1]<<FRACBITS;
; 1662 : 		bmapwidth = blockmaplump[2];
; 1663 : 		bmapheight = blockmaplump[3];
; 1664 : 	}
; 1665 : 
; 1666 : 	// clear out mobj chains
; 1667 : 	count = sizeof (*blocklinks)*bmapwidth*bmapheight;
; 1668 : 	blocklinks = Z_Calloc(count, PU_LEVEL, NULL);
; 1669 : 	return true;
; 1670 : 	*/
; 1671 : #endif
; 1672 : }

  00260	5f		 pop	 edi
  00261	5e		 pop	 esi
  00262	5b		 pop	 ebx
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
_P_LoadBlockMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_CreateBlockMap
_TEXT	SEGMENT
tv325 = -168						; size = 4
_count$1 = -100						; size = 4
_bp$2 = -96						; size = 4
_ndx$3 = -92						; size = 4
_count$4 = -88						; size = 4
_b$5 = -84						; size = 4
_temp$6 = -80						; size = 4
_temp$7 = -76						; size = 4
_curblocky$8 = -72					; size = 4
_curblockx$9 = -68					; size = 4
_v2y$10 = -64						; size = 4
_v2x$11 = -60						; size = 4
_byend$12 = -56						; size = 4
_bystart$13 = -52					; size = 4
_bxend$14 = -48						; size = 4
_bxstart$15 = -44					; size = 4
_y$16 = -40						; size = 4
_x$17 = -36						; size = 4
_straight$18 = -32					; size = 4
_bmap$19 = -28						; size = 4
_tot$20 = -24						; size = 4
_maxy$ = -20						; size = 4
_maxx$ = -16						; size = 4
_miny$ = -12						; size = 4
_minx$ = -8						; size = 4
_i$ = -4						; size = 4
_P_CreateBlockMap PROC					; COMDAT

; 1391 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1392 : 	register size_t i;
; 1393 : 	fixed_t minx = INT32_MAX, miny = INT32_MAX, maxx = INT32_MIN, maxy = INT32_MIN;

  0000c	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _minx$[ebp], 2147483647 ; 7fffffffH
  00013	c7 45 f4 ff ff
	ff 7f		 mov	 DWORD PTR _miny$[ebp], 2147483647 ; 7fffffffH
  0001a	c7 45 f0 00 00
	00 80		 mov	 DWORD PTR _maxx$[ebp], -2147483648 ; 80000000H
  00021	c7 45 ec 00 00
	00 80		 mov	 DWORD PTR _maxy$[ebp], -2147483648 ; 80000000H

; 1394 : 	// First find limits of map
; 1395 : 
; 1396 : 	for (i = 0; i < numvertexes; i++)

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@P_CreateBl
$LN2@P_CreateBl:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_CreateBl:
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numvertexes
  00043	0f 83 ad 00 00
	00		 jae	 $LN3@P_CreateBl

; 1397 : 	{
; 1398 : 		if (vertexes[i].x>>FRACBITS < minx)

  00049	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  00053	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00056	c1 fa 10	 sar	 edx, 16			; 00000010H
  00059	3b 55 f8	 cmp	 edx, DWORD PTR _minx$[ebp]
  0005c	7d 15		 jge	 SHORT $LN23@P_CreateBl

; 1399 : 			minx = vertexes[i].x>>FRACBITS;

  0005e	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  00068	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0006b	c1 fa 10	 sar	 edx, 16			; 00000010H
  0006e	89 55 f8	 mov	 DWORD PTR _minx$[ebp], edx
  00071	eb 28		 jmp	 SHORT $LN25@P_CreateBl
$LN23@P_CreateBl:

; 1400 : 		else if (vertexes[i].x>>FRACBITS > maxx)

  00073	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  0007d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00080	c1 fa 10	 sar	 edx, 16			; 00000010H
  00083	3b 55 f0	 cmp	 edx, DWORD PTR _maxx$[ebp]
  00086	7e 13		 jle	 SHORT $LN25@P_CreateBl

; 1401 : 			maxx = vertexes[i].x>>FRACBITS;

  00088	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  00092	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00095	c1 fa 10	 sar	 edx, 16			; 00000010H
  00098	89 55 f0	 mov	 DWORD PTR _maxx$[ebp], edx
$LN25@P_CreateBl:

; 1402 : 		if (vertexes[i].y>>FRACBITS < miny)

  0009b	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  000a5	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000a9	c1 fa 10	 sar	 edx, 16			; 00000010H
  000ac	3b 55 f4	 cmp	 edx, DWORD PTR _miny$[ebp]
  000af	7d 16		 jge	 SHORT $LN26@P_CreateBl

; 1403 : 			miny = vertexes[i].y>>FRACBITS;

  000b1	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  000bb	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000bf	c1 fa 10	 sar	 edx, 16			; 00000010H
  000c2	89 55 f4	 mov	 DWORD PTR _miny$[ebp], edx
  000c5	eb 2a		 jmp	 SHORT $LN28@P_CreateBl
$LN26@P_CreateBl:

; 1404 : 		else if (vertexes[i].y>>FRACBITS > maxy)

  000c7	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  000d1	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000d5	c1 fa 10	 sar	 edx, 16			; 00000010H
  000d8	3b 55 ec	 cmp	 edx, DWORD PTR _maxy$[ebp]
  000db	7e 14		 jle	 SHORT $LN28@P_CreateBl

; 1405 : 			maxy = vertexes[i].y>>FRACBITS;

  000dd	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  000e7	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000eb	c1 fa 10	 sar	 edx, 16			; 00000010H
  000ee	89 55 ec	 mov	 DWORD PTR _maxy$[ebp], edx
$LN28@P_CreateBl:

; 1406 : 	}

  000f1	e9 3b ff ff ff	 jmp	 $LN2@P_CreateBl
$LN3@P_CreateBl:

; 1407 : 
; 1408 : 	// Save blockmap parameters
; 1409 : 	bmaporgx = minx << FRACBITS;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _minx$[ebp]
  000f9	c1 e0 10	 shl	 eax, 16			; 00000010H
  000fc	a3 00 00 00 00	 mov	 DWORD PTR _bmaporgx, eax

; 1410 : 	bmaporgy = miny << FRACBITS;

  00101	8b 45 f4	 mov	 eax, DWORD PTR _miny$[ebp]
  00104	c1 e0 10	 shl	 eax, 16			; 00000010H
  00107	a3 00 00 00 00	 mov	 DWORD PTR _bmaporgy, eax

; 1411 : 	bmapwidth = ((maxx-minx) >> MAPBTOFRAC) + 1;

  0010c	8b 45 f0	 mov	 eax, DWORD PTR _maxx$[ebp]
  0010f	2b 45 f8	 sub	 eax, DWORD PTR _minx$[ebp]
  00112	c1 f8 07	 sar	 eax, 7
  00115	83 c0 01	 add	 eax, 1
  00118	a3 00 00 00 00	 mov	 DWORD PTR _bmapwidth, eax

; 1412 : 	bmapheight = ((maxy-miny) >> MAPBTOFRAC)+ 1;

  0011d	8b 45 ec	 mov	 eax, DWORD PTR _maxy$[ebp]
  00120	2b 45 f4	 sub	 eax, DWORD PTR _miny$[ebp]
  00123	c1 f8 07	 sar	 eax, 7
  00126	83 c0 01	 add	 eax, 1
  00129	a3 00 00 00 00	 mov	 DWORD PTR _bmapheight, eax

; 1413 : 
; 1414 : 	// Compute blockmap, which is stored as a 2d array of variable-sized lists.
; 1415 : 	//
; 1416 : 	// Pseudocode:
; 1417 : 	//
; 1418 : 	// For each linedef:
; 1419 : 	//
; 1420 : 	//   Map the starting and ending vertices to blocks.
; 1421 : 	//
; 1422 : 	//   Starting in the starting vertex's block, do:
; 1423 : 	//
; 1424 : 	//     Add linedef to current block's list, dynamically resizing it.
; 1425 : 	//
; 1426 : 	//     If current block is the same as the ending vertex's block, exit loop.
; 1427 : 	//
; 1428 : 	//     Move to an adjacent block by moving towards the ending block in
; 1429 : 	//     either the x or y direction, to the block which contains the linedef.
; 1430 : 
; 1431 : 	{
; 1432 : 		typedef struct
; 1433 : 		{
; 1434 : 			INT32 n, nalloc;
; 1435 : 			INT32 *list;
; 1436 : 		} bmap_t; // blocklist structure
; 1437 : 
; 1438 : 		size_t tot = bmapwidth * bmapheight; // size of blockmap

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmapwidth
  00133	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapheight
  0013a	89 45 e8	 mov	 DWORD PTR _tot$20[ebp], eax

; 1439 : 		bmap_t *bmap = calloc(tot, sizeof (*bmap)); // array of blocklists

  0013d	6a 0c		 push	 12			; 0000000cH
  0013f	8b 45 e8	 mov	 eax, DWORD PTR _tot$20[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _calloc
  00148	83 c4 08	 add	 esp, 8
  0014b	89 45 e4	 mov	 DWORD PTR _bmap$19[ebp], eax

; 1440 : 		boolean straight;
; 1441 : 
; 1442 : 		if (bmap == NULL) I_Error("%s: Out of memory making blockmap", "P_CreateBlockMap");

  0014e	83 7d e4 00	 cmp	 DWORD PTR _bmap$19[ebp], 0
  00152	75 12		 jne	 SHORT $LN29@P_CreateBl
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FGCFFNMG@P_CreateBlockMap@
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IJGCFEOJ@?$CFs?3?5Out?5of?5memory?5making?5blockm@
  0015e	e8 00 00 00 00	 call	 _I_Error
  00163	83 c4 08	 add	 esp, 8
$LN29@P_CreateBl:

; 1443 : 
; 1444 : 		for (i = 0; i < numlines; i++)

  00166	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0016d	eb 09		 jmp	 SHORT $LN7@P_CreateBl
$LN5@P_CreateBl:
  0016f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00172	83 c0 01	 add	 eax, 1
  00175	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_CreateBl:
  00178	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0017b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00181	0f 83 bb 02 00
	00		 jae	 $LN6@P_CreateBl

; 1445 : 		{
; 1446 : 			// starting coordinates
; 1447 : 			INT32 x = (lines[i].v1->x>>FRACBITS) - minx;

  00187	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0018b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00191	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00194	8b 02		 mov	 eax, DWORD PTR [edx]
  00196	c1 f8 10	 sar	 eax, 16			; 00000010H
  00199	2b 45 f8	 sub	 eax, DWORD PTR _minx$[ebp]
  0019c	89 45 dc	 mov	 DWORD PTR _x$17[ebp], eax

; 1448 : 			INT32 y = (lines[i].v1->y>>FRACBITS) - miny;

  0019f	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  001a9	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001ac	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001af	c1 f8 10	 sar	 eax, 16			; 00000010H
  001b2	2b 45 f4	 sub	 eax, DWORD PTR _miny$[ebp]
  001b5	89 45 d8	 mov	 DWORD PTR _y$16[ebp], eax

; 1449 : 			INT32 bxstart, bxend, bystart, byend, v2x, v2y, curblockx, curblocky;
; 1450 : 
; 1451 : 			v2x = lines[i].v2->x>>FRACBITS;

  001b8	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  001c2	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  001c6	8b 02		 mov	 eax, DWORD PTR [edx]
  001c8	c1 f8 10	 sar	 eax, 16			; 00000010H
  001cb	89 45 c4	 mov	 DWORD PTR _v2x$11[ebp], eax

; 1452 : 			v2y = lines[i].v2->y>>FRACBITS;

  001ce	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  001d8	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  001dc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001df	c1 f8 10	 sar	 eax, 16			; 00000010H
  001e2	89 45 c0	 mov	 DWORD PTR _v2y$10[ebp], eax

; 1453 : 
; 1454 : 			// Draw a "box" around the line.
; 1455 : 			bxstart = (x >> MAPBTOFRAC);

  001e5	8b 45 dc	 mov	 eax, DWORD PTR _x$17[ebp]
  001e8	c1 f8 07	 sar	 eax, 7
  001eb	89 45 d4	 mov	 DWORD PTR _bxstart$15[ebp], eax

; 1456 : 			bystart = (y >> MAPBTOFRAC);

  001ee	8b 45 d8	 mov	 eax, DWORD PTR _y$16[ebp]
  001f1	c1 f8 07	 sar	 eax, 7
  001f4	89 45 cc	 mov	 DWORD PTR _bystart$13[ebp], eax

; 1457 : 
; 1458 : 			v2x -= minx;

  001f7	8b 45 c4	 mov	 eax, DWORD PTR _v2x$11[ebp]
  001fa	2b 45 f8	 sub	 eax, DWORD PTR _minx$[ebp]
  001fd	89 45 c4	 mov	 DWORD PTR _v2x$11[ebp], eax

; 1459 : 			v2y -= miny;

  00200	8b 45 c0	 mov	 eax, DWORD PTR _v2y$10[ebp]
  00203	2b 45 f4	 sub	 eax, DWORD PTR _miny$[ebp]
  00206	89 45 c0	 mov	 DWORD PTR _v2y$10[ebp], eax

; 1460 : 
; 1461 : 			bxend = ((v2x) >> MAPBTOFRAC);

  00209	8b 45 c4	 mov	 eax, DWORD PTR _v2x$11[ebp]
  0020c	c1 f8 07	 sar	 eax, 7
  0020f	89 45 d0	 mov	 DWORD PTR _bxend$14[ebp], eax

; 1462 : 			byend = ((v2y) >> MAPBTOFRAC);

  00212	8b 45 c0	 mov	 eax, DWORD PTR _v2y$10[ebp]
  00215	c1 f8 07	 sar	 eax, 7
  00218	89 45 c8	 mov	 DWORD PTR _byend$12[ebp], eax

; 1463 : 
; 1464 : 			if (bxend < bxstart)

  0021b	8b 45 d0	 mov	 eax, DWORD PTR _bxend$14[ebp]
  0021e	3b 45 d4	 cmp	 eax, DWORD PTR _bxstart$15[ebp]
  00221	7d 12		 jge	 SHORT $LN30@P_CreateBl

; 1465 : 			{
; 1466 : 				INT32 temp = bxstart;

  00223	8b 45 d4	 mov	 eax, DWORD PTR _bxstart$15[ebp]
  00226	89 45 b4	 mov	 DWORD PTR _temp$7[ebp], eax

; 1467 : 				bxstart = bxend;

  00229	8b 45 d0	 mov	 eax, DWORD PTR _bxend$14[ebp]
  0022c	89 45 d4	 mov	 DWORD PTR _bxstart$15[ebp], eax

; 1468 : 				bxend = temp;

  0022f	8b 45 b4	 mov	 eax, DWORD PTR _temp$7[ebp]
  00232	89 45 d0	 mov	 DWORD PTR _bxend$14[ebp], eax
$LN30@P_CreateBl:

; 1469 : 			}
; 1470 : 
; 1471 : 			if (byend < bystart)

  00235	8b 45 c8	 mov	 eax, DWORD PTR _byend$12[ebp]
  00238	3b 45 cc	 cmp	 eax, DWORD PTR _bystart$13[ebp]
  0023b	7d 12		 jge	 SHORT $LN31@P_CreateBl

; 1472 : 			{
; 1473 : 				INT32 temp = bystart;

  0023d	8b 45 cc	 mov	 eax, DWORD PTR _bystart$13[ebp]
  00240	89 45 b0	 mov	 DWORD PTR _temp$6[ebp], eax

; 1474 : 				bystart = byend;

  00243	8b 45 c8	 mov	 eax, DWORD PTR _byend$12[ebp]
  00246	89 45 cc	 mov	 DWORD PTR _bystart$13[ebp], eax

; 1475 : 				byend = temp;

  00249	8b 45 b0	 mov	 eax, DWORD PTR _temp$6[ebp]
  0024c	89 45 c8	 mov	 DWORD PTR _byend$12[ebp], eax
$LN31@P_CreateBl:

; 1476 : 			}
; 1477 : 
; 1478 : 			// Catch straight lines
; 1479 : 			// This fixes the error where straight lines
; 1480 : 			// directly on a blockmap boundary would not
; 1481 : 			// be included in the proper blocks.
; 1482 : 			if (lines[i].v1->y == lines[i].v2->y)

  0024f	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00259	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0025c	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00266	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  0026a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0026d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00270	75 1b		 jne	 SHORT $LN32@P_CreateBl

; 1483 : 			{
; 1484 : 				straight = true;

  00272	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _straight$18[ebp], 1

; 1485 : 				bystart--;

  00279	8b 45 cc	 mov	 eax, DWORD PTR _bystart$13[ebp]
  0027c	83 e8 01	 sub	 eax, 1
  0027f	89 45 cc	 mov	 DWORD PTR _bystart$13[ebp], eax

; 1486 : 				byend++;

  00282	8b 45 c8	 mov	 eax, DWORD PTR _byend$12[ebp]
  00285	83 c0 01	 add	 eax, 1
  00288	89 45 c8	 mov	 DWORD PTR _byend$12[ebp], eax

; 1487 : 			}

  0028b	eb 43		 jmp	 SHORT $LN35@P_CreateBl
$LN32@P_CreateBl:

; 1488 : 			else if (lines[i].v1->x == lines[i].v2->x)

  0028d	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00297	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0029a	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0029e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  002a4	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  002a8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  002aa	3b 08		 cmp	 ecx, DWORD PTR [eax]
  002ac	75 1b		 jne	 SHORT $LN34@P_CreateBl

; 1489 : 			{
; 1490 : 				straight = true;

  002ae	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _straight$18[ebp], 1

; 1491 : 				bxstart--;

  002b5	8b 45 d4	 mov	 eax, DWORD PTR _bxstart$15[ebp]
  002b8	83 e8 01	 sub	 eax, 1
  002bb	89 45 d4	 mov	 DWORD PTR _bxstart$15[ebp], eax

; 1492 : 				bxend++;

  002be	8b 45 d0	 mov	 eax, DWORD PTR _bxend$14[ebp]
  002c1	83 c0 01	 add	 eax, 1
  002c4	89 45 d0	 mov	 DWORD PTR _bxend$14[ebp], eax

; 1493 : 			}

  002c7	eb 07		 jmp	 SHORT $LN35@P_CreateBl
$LN34@P_CreateBl:

; 1494 : 			else
; 1495 : 				straight = false;

  002c9	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _straight$18[ebp], 0
$LN35@P_CreateBl:

; 1496 : 
; 1497 : 			// Now we simply iterate block-by-block until we reach the end block.
; 1498 : 			for (curblockx = bxstart; curblockx <= bxend; curblockx++)

  002d0	8b 45 d4	 mov	 eax, DWORD PTR _bxstart$15[ebp]
  002d3	89 45 bc	 mov	 DWORD PTR _curblockx$9[ebp], eax
  002d6	eb 09		 jmp	 SHORT $LN10@P_CreateBl
$LN8@P_CreateBl:
  002d8	8b 45 bc	 mov	 eax, DWORD PTR _curblockx$9[ebp]
  002db	83 c0 01	 add	 eax, 1
  002de	89 45 bc	 mov	 DWORD PTR _curblockx$9[ebp], eax
$LN10@P_CreateBl:
  002e1	8b 45 bc	 mov	 eax, DWORD PTR _curblockx$9[ebp]
  002e4	3b 45 d0	 cmp	 eax, DWORD PTR _bxend$14[ebp]
  002e7	0f 8f 50 01 00
	00		 jg	 $LN9@P_CreateBl

; 1499 : 			for (curblocky = bystart; curblocky <= byend; curblocky++)

  002ed	8b 45 cc	 mov	 eax, DWORD PTR _bystart$13[ebp]
  002f0	89 45 b8	 mov	 DWORD PTR _curblocky$8[ebp], eax
  002f3	eb 09		 jmp	 SHORT $LN13@P_CreateBl
$LN11@P_CreateBl:
  002f5	8b 45 b8	 mov	 eax, DWORD PTR _curblocky$8[ebp]
  002f8	83 c0 01	 add	 eax, 1
  002fb	89 45 b8	 mov	 DWORD PTR _curblocky$8[ebp], eax
$LN13@P_CreateBl:
  002fe	8b 45 b8	 mov	 eax, DWORD PTR _curblocky$8[ebp]
  00301	3b 45 c8	 cmp	 eax, DWORD PTR _byend$12[ebp]
  00304	0f 8f 2e 01 00
	00		 jg	 $LN12@P_CreateBl

; 1500 : 			{
; 1501 : 				size_t b = curblocky * bmapwidth + curblockx;

  0030a	8b 45 b8	 mov	 eax, DWORD PTR _curblocky$8[ebp]
  0030d	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  00314	03 45 bc	 add	 eax, DWORD PTR _curblockx$9[ebp]
  00317	89 45 ac	 mov	 DWORD PTR _b$5[ebp], eax

; 1502 : 
; 1503 : 				if (b >= tot)

  0031a	8b 45 ac	 mov	 eax, DWORD PTR _b$5[ebp]
  0031d	3b 45 e8	 cmp	 eax, DWORD PTR _tot$20[ebp]
  00320	72 02		 jb	 SHORT $LN36@P_CreateBl

; 1504 : 					continue;

  00322	eb d1		 jmp	 SHORT $LN11@P_CreateBl
$LN36@P_CreateBl:

; 1505 : 
; 1506 : 				if (!straight && !(LineInBlock((fixed_t)x, (fixed_t)y, (fixed_t)v2x, (fixed_t)v2y, (fixed_t)(curblockx << MAPBTOFRAC), (fixed_t)(curblocky << MAPBTOFRAC))))

  00324	83 7d e0 00	 cmp	 DWORD PTR _straight$18[ebp], 0
  00328	75 2c		 jne	 SHORT $LN37@P_CreateBl
  0032a	8b 45 b8	 mov	 eax, DWORD PTR _curblocky$8[ebp]
  0032d	c1 e0 07	 shl	 eax, 7
  00330	50		 push	 eax
  00331	8b 4d bc	 mov	 ecx, DWORD PTR _curblockx$9[ebp]
  00334	c1 e1 07	 shl	 ecx, 7
  00337	51		 push	 ecx
  00338	8b 55 c0	 mov	 edx, DWORD PTR _v2y$10[ebp]
  0033b	52		 push	 edx
  0033c	8b 45 c4	 mov	 eax, DWORD PTR _v2x$11[ebp]
  0033f	50		 push	 eax
  00340	8b 4d d8	 mov	 ecx, DWORD PTR _y$16[ebp]
  00343	51		 push	 ecx
  00344	8b 55 dc	 mov	 edx, DWORD PTR _x$17[ebp]
  00347	52		 push	 edx
  00348	e8 00 00 00 00	 call	 _LineInBlock
  0034d	83 c4 18	 add	 esp, 24			; 00000018H
  00350	85 c0		 test	 eax, eax
  00352	75 02		 jne	 SHORT $LN37@P_CreateBl

; 1507 : 					continue;

  00354	eb 9f		 jmp	 SHORT $LN11@P_CreateBl
$LN37@P_CreateBl:

; 1508 : 
; 1509 : 				// Increase size of allocated list if necessary
; 1510 : 				if (bmap[b].n >= bmap[b].nalloc)

  00356	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  0035a	6b 4d ac 0c	 imul	 ecx, DWORD PTR _b$5[ebp], 12
  0035e	8b 55 e4	 mov	 edx, DWORD PTR _bmap$19[ebp]
  00361	8b 75 e4	 mov	 esi, DWORD PTR _bmap$19[ebp]
  00364	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00367	3b 44 0e 04	 cmp	 eax, DWORD PTR [esi+ecx+4]
  0036b	0f 8c 90 00 00
	00		 jl	 $LN41@P_CreateBl

; 1511 : 				{
; 1512 : 					// Graue 02-29-2004: make code more readable, don't realloc a null pointer
; 1513 : 					// (because it crashes for me, and because the comp.lang.c FAQ says so)
; 1514 : 					if (bmap[b].nalloc == 0)

  00371	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  00375	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  00378	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0037d	75 11		 jne	 SHORT $LN39@P_CreateBl

; 1515 : 						bmap[b].nalloc = 8;

  0037f	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  00383	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  00386	c7 44 01 04 08
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 8
  0038e	eb 18		 jmp	 SHORT $LN40@P_CreateBl
$LN39@P_CreateBl:

; 1516 : 					else
; 1517 : 						bmap[b].nalloc *= 2;

  00390	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  00394	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  00397	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0039b	d1 e2		 shl	 edx, 1
  0039d	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  003a1	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  003a4	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN40@P_CreateBl:

; 1518 : 					bmap[b].list = Z_Realloc(bmap[b].list, bmap[b].nalloc * sizeof (*bmap->list), PU_CACHE, &bmap[b].list);

  003a8	6a 00		 push	 0
  003aa	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  003ae	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  003b1	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  003b5	52		 push	 edx
  003b6	6a 65		 push	 101			; 00000065H
  003b8	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  003bc	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  003bf	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  003c3	c1 e2 02	 shl	 edx, 2
  003c6	52		 push	 edx
  003c7	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  003cb	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  003ce	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 _Z_ReallocAlign
  003d8	83 c4 14	 add	 esp, 20			; 00000014H
  003db	6b 4d ac 0c	 imul	 ecx, DWORD PTR _b$5[ebp], 12
  003df	8b 55 e4	 mov	 edx, DWORD PTR _bmap$19[ebp]
  003e2	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 1519 : 					if (!bmap[b].list)

  003e6	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  003ea	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  003ed	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  003f2	75 0d		 jne	 SHORT $LN41@P_CreateBl

; 1520 : 						I_Error("Out of Memory in P_CreateBlockMap");

  003f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HFBFKHEL@Out?5of?5Memory?5in?5P_CreateBlockM@
  003f9	e8 00 00 00 00	 call	 _I_Error
  003fe	83 c4 04	 add	 esp, 4
$LN41@P_CreateBl:

; 1521 : 				}
; 1522 : 
; 1523 : 				// Add linedef to end of list
; 1524 : 				bmap[b].list[bmap[b].n++] = (INT32)i;

  00401	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  00405	6b 4d ac 0c	 imul	 ecx, DWORD PTR _b$5[ebp], 12
  00409	8b 55 e4	 mov	 edx, DWORD PTR _bmap$19[ebp]
  0040c	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0040f	8b 55 e4	 mov	 edx, DWORD PTR _bmap$19[ebp]
  00412	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00416	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00419	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  0041c	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  00420	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  00423	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00426	83 c2 01	 add	 edx, 1
  00429	6b 45 ac 0c	 imul	 eax, DWORD PTR _b$5[ebp], 12
  0042d	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  00430	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 1525 : 			}

  00433	e9 bd fe ff ff	 jmp	 $LN11@P_CreateBl
$LN12@P_CreateBl:
  00438	e9 9b fe ff ff	 jmp	 $LN8@P_CreateBl
$LN9@P_CreateBl:

; 1526 : 		}

  0043d	e9 2d fd ff ff	 jmp	 $LN5@P_CreateBl
$LN6@P_CreateBl:

; 1527 : 
; 1528 : 		// Compute the total size of the blockmap.
; 1529 : 		//
; 1530 : 		// Compression of empty blocks is performed by reserving two offset words
; 1531 : 		// at tot and tot+1.
; 1532 : 		//
; 1533 : 		// 4 words, unused if this routine is called, are reserved at the start.
; 1534 : 		{
; 1535 : 			size_t count = tot + 6; // we need at least 1 word per block, plus reserved's

  00442	8b 45 e8	 mov	 eax, DWORD PTR _tot$20[ebp]
  00445	83 c0 06	 add	 eax, 6
  00448	89 45 a8	 mov	 DWORD PTR _count$4[ebp], eax

; 1536 : 
; 1537 : 			for (i = 0; i < tot; i++)

  0044b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00452	eb 09		 jmp	 SHORT $LN16@P_CreateBl
$LN14@P_CreateBl:
  00454	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00457	83 c0 01	 add	 eax, 1
  0045a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@P_CreateBl:
  0045d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00460	3b 45 e8	 cmp	 eax, DWORD PTR _tot$20[ebp]
  00463	73 23		 jae	 SHORT $LN15@P_CreateBl

; 1538 : 				if (bmap[i].n)

  00465	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00469	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  0046c	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00470	74 14		 je	 SHORT $LN42@P_CreateBl

; 1539 : 					count += bmap[i].n + 2; // 1 header word + 1 trailer word + blocklist

  00472	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00476	8b 4d e4	 mov	 ecx, DWORD PTR _bmap$19[ebp]
  00479	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0047c	8b 45 a8	 mov	 eax, DWORD PTR _count$4[ebp]
  0047f	8d 4c 10 02	 lea	 ecx, DWORD PTR [eax+edx+2]
  00483	89 4d a8	 mov	 DWORD PTR _count$4[ebp], ecx
$LN42@P_CreateBl:
  00486	eb cc		 jmp	 SHORT $LN14@P_CreateBl
$LN15@P_CreateBl:

; 1540 : 
; 1541 : 			// Allocate blockmap lump with computed count
; 1542 : 			blockmaplump = Z_Calloc(sizeof (*blockmaplump) * count, PU_LEVEL, NULL);

  00488	6a 00		 push	 0
  0048a	6a 00		 push	 0
  0048c	6a 32		 push	 50			; 00000032H
  0048e	8b 45 a8	 mov	 eax, DWORD PTR _count$4[ebp]
  00491	c1 e0 02	 shl	 eax, 2
  00494	50		 push	 eax
  00495	e8 00 00 00 00	 call	 _Z_CallocAlign
  0049a	83 c4 10	 add	 esp, 16			; 00000010H
  0049d	a3 00 00 00 00	 mov	 DWORD PTR _blockmaplump, eax

; 1543 : 		}
; 1544 : 
; 1545 : 		// Now compress the blockmap.
; 1546 : 		{
; 1547 : 			size_t ndx = tot += 4; // Advance index to start of linedef lists

  004a2	8b 45 e8	 mov	 eax, DWORD PTR _tot$20[ebp]
  004a5	83 c0 04	 add	 eax, 4
  004a8	89 45 e8	 mov	 DWORD PTR _tot$20[ebp], eax
  004ab	8b 4d e8	 mov	 ecx, DWORD PTR _tot$20[ebp]
  004ae	89 4d a4	 mov	 DWORD PTR _ndx$3[ebp], ecx

; 1548 : 			bmap_t *bp = bmap; // Start of uncompressed blockmap

  004b1	8b 45 e4	 mov	 eax, DWORD PTR _bmap$19[ebp]
  004b4	89 45 a0	 mov	 DWORD PTR _bp$2[ebp], eax

; 1549 : 
; 1550 : 			blockmaplump[ndx++] = 0; // Store an empty blockmap list at start

  004b7	8b 45 a4	 mov	 eax, DWORD PTR _ndx$3[ebp]
  004ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  004c0	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  004c7	8b 55 a4	 mov	 edx, DWORD PTR _ndx$3[ebp]
  004ca	83 c2 01	 add	 edx, 1
  004cd	89 55 a4	 mov	 DWORD PTR _ndx$3[ebp], edx

; 1551 : 			blockmaplump[ndx++] = -1; // (Used for compression)

  004d0	8b 45 a4	 mov	 eax, DWORD PTR _ndx$3[ebp]
  004d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  004d9	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [ecx+eax*4], -1
  004e0	8b 55 a4	 mov	 edx, DWORD PTR _ndx$3[ebp]
  004e3	83 c2 01	 add	 edx, 1
  004e6	89 55 a4	 mov	 DWORD PTR _ndx$3[ebp], edx

; 1552 : 
; 1553 : 			for (i = 4; i < tot; i++, bp++)

  004e9	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR _i$[ebp], 4
  004f0	eb 12		 jmp	 SHORT $LN19@P_CreateBl
$LN17@P_CreateBl:
  004f2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004f5	83 c0 01	 add	 eax, 1
  004f8	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  004fb	8b 4d a0	 mov	 ecx, DWORD PTR _bp$2[ebp]
  004fe	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00501	89 4d a0	 mov	 DWORD PTR _bp$2[ebp], ecx
$LN19@P_CreateBl:
  00504	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00507	3b 45 e8	 cmp	 eax, DWORD PTR _tot$20[ebp]
  0050a	0f 83 b7 00 00
	00		 jae	 $LN18@P_CreateBl

; 1554 : 				if (bp->n) // Non-empty blocklist

  00510	8b 45 a0	 mov	 eax, DWORD PTR _bp$2[ebp]
  00513	83 38 00	 cmp	 DWORD PTR [eax], 0
  00516	0f 84 97 00 00
	00		 je	 $LN43@P_CreateBl

; 1555 : 				{
; 1556 : 					blockmaplump[blockmaplump[i] = (INT32)(ndx++)] = 0; // Store index & header

  0051c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0051f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  00525	8b 55 a4	 mov	 edx, DWORD PTR _ndx$3[ebp]
  00528	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  0052b	8b 45 a4	 mov	 eax, DWORD PTR _ndx$3[ebp]
  0052e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  00534	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0
  0053b	8b 55 a4	 mov	 edx, DWORD PTR _ndx$3[ebp]
  0053e	83 c2 01	 add	 edx, 1
  00541	89 55 a4	 mov	 DWORD PTR _ndx$3[ebp], edx
$LN22@P_CreateBl:

; 1557 : 					do
; 1558 : 						blockmaplump[ndx++] = bp->list[--bp->n]; // Copy linedef list

  00544	8b 45 a0	 mov	 eax, DWORD PTR _bp$2[ebp]
  00547	8b 08		 mov	 ecx, DWORD PTR [eax]
  00549	83 e9 01	 sub	 ecx, 1
  0054c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv325[ebp], ecx
  00552	8b 55 a0	 mov	 edx, DWORD PTR _bp$2[ebp]
  00555	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv325[ebp]
  0055b	89 02		 mov	 DWORD PTR [edx], eax
  0055d	8b 4d a0	 mov	 ecx, DWORD PTR _bp$2[ebp]
  00560	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00563	8b 45 a4	 mov	 eax, DWORD PTR _ndx$3[ebp]
  00566	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  0056c	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR tv325[ebp]
  00572	8b 14 b2	 mov	 edx, DWORD PTR [edx+esi*4]
  00575	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00578	8b 45 a4	 mov	 eax, DWORD PTR _ndx$3[ebp]
  0057b	83 c0 01	 add	 eax, 1
  0057e	89 45 a4	 mov	 DWORD PTR _ndx$3[ebp], eax

; 1559 : 					while (bp->n);

  00581	8b 45 a0	 mov	 eax, DWORD PTR _bp$2[ebp]
  00584	83 38 00	 cmp	 DWORD PTR [eax], 0
  00587	75 bb		 jne	 SHORT $LN22@P_CreateBl

; 1560 : 					blockmaplump[ndx++] = -1; // Store trailer

  00589	8b 45 a4	 mov	 eax, DWORD PTR _ndx$3[ebp]
  0058c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  00592	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [ecx+eax*4], -1
  00599	8b 55 a4	 mov	 edx, DWORD PTR _ndx$3[ebp]
  0059c	83 c2 01	 add	 edx, 1
  0059f	89 55 a4	 mov	 DWORD PTR _ndx$3[ebp], edx

; 1561 : 					Z_Free(bp->list); // Free linedef list

  005a2	8b 45 a0	 mov	 eax, DWORD PTR _bp$2[ebp]
  005a5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005a8	51		 push	 ecx
  005a9	e8 00 00 00 00	 call	 _Z_Free
  005ae	83 c4 04	 add	 esp, 4

; 1562 : 				}

  005b1	eb 0f		 jmp	 SHORT $LN44@P_CreateBl
$LN43@P_CreateBl:

; 1563 : 				else // Empty blocklist: point to reserved empty blocklist
; 1564 : 					blockmaplump[i] = (INT32)tot;

  005b3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  005b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  005bc	8b 55 e8	 mov	 edx, DWORD PTR _tot$20[ebp]
  005bf	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$LN44@P_CreateBl:
  005c2	e9 2b ff ff ff	 jmp	 $LN17@P_CreateBl
$LN18@P_CreateBl:

; 1565 : 
; 1566 : 			free(bmap); // Free uncompressed blockmap

  005c7	8b 45 e4	 mov	 eax, DWORD PTR _bmap$19[ebp]
  005ca	50		 push	 eax
  005cb	e8 00 00 00 00	 call	 _free
  005d0	83 c4 04	 add	 esp, 4

; 1567 : 		}
; 1568 : 	}
; 1569 : 	{
; 1570 : 		size_t count = sizeof (*blocklinks) * bmapwidth * bmapheight;

  005d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmapwidth
  005d8	c1 e0 02	 shl	 eax, 2
  005db	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapheight
  005e2	89 45 9c	 mov	 DWORD PTR _count$1[ebp], eax

; 1571 : 		// clear out mobj chains (copied from from P_LoadBlockMap)
; 1572 : 		blocklinks = Z_Calloc(count, PU_LEVEL, NULL);

  005e5	6a 00		 push	 0
  005e7	6a 00		 push	 0
  005e9	6a 32		 push	 50			; 00000032H
  005eb	8b 45 9c	 mov	 eax, DWORD PTR _count$1[ebp]
  005ee	50		 push	 eax
  005ef	e8 00 00 00 00	 call	 _Z_CallocAlign
  005f4	83 c4 10	 add	 esp, 16			; 00000010H
  005f7	a3 00 00 00 00	 mov	 DWORD PTR _blocklinks, eax

; 1573 : 		blockmap = blockmaplump + 4;

  005fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockmaplump
  00601	83 c0 10	 add	 eax, 16			; 00000010H
  00604	a3 00 00 00 00	 mov	 DWORD PTR _blockmap, eax

; 1574 : 
; 1575 : #ifdef POLYOBJECTS
; 1576 : 		// haleyjd 2/22/06: setup polyobject blockmap
; 1577 : 		count = sizeof(*polyblocklinks) * bmapwidth * bmapheight;

  00609	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmapwidth
  0060e	c1 e0 02	 shl	 eax, 2
  00611	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapheight
  00618	89 45 9c	 mov	 DWORD PTR _count$1[ebp], eax

; 1578 : 		polyblocklinks = Z_Calloc(count, PU_LEVEL, NULL);

  0061b	6a 00		 push	 0
  0061d	6a 00		 push	 0
  0061f	6a 32		 push	 50			; 00000032H
  00621	8b 45 9c	 mov	 eax, DWORD PTR _count$1[ebp]
  00624	50		 push	 eax
  00625	e8 00 00 00 00	 call	 _Z_CallocAlign
  0062a	83 c4 10	 add	 esp, 16			; 00000010H
  0062d	a3 00 00 00 00	 mov	 DWORD PTR _polyblocklinks, eax

; 1579 : #endif
; 1580 : 	}
; 1581 : }

  00632	5f		 pop	 edi
  00633	5e		 pop	 esi
  00634	5b		 pop	 ebx
  00635	8b e5		 mov	 esp, ebp
  00637	5d		 pop	 ebp
  00638	c3		 ret	 0
_P_CreateBlockMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _LineInBlock
_TEXT	SEGMENT
_vtest$ = -204						; size = 12
_vbox$ = -192						; size = 12
_testline$ = -180					; size = 76
_boxline$ = -104					; size = 76
_bbox$ = -28						; size = 16
_by2$ = -12						; size = 4
_bx2$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cx1$ = 8						; size = 4
_cy1$ = 12						; size = 4
_cx2$ = 16						; size = 4
_cy2$ = 20						; size = 4
_bx1$ = 24						; size = 4
_by1$ = 28						; size = 4
_LineInBlock PROC					; COMDAT

; 1292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1293 : 	fixed_t bx2 = bx1 + MAPBLOCKUNITS;

  00016	8b 45 18	 mov	 eax, DWORD PTR _bx1$[ebp]
  00019	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0001e	89 45 f8	 mov	 DWORD PTR _bx2$[ebp], eax

; 1294 : 	fixed_t by2 = by1 + MAPBLOCKUNITS;

  00021	8b 45 1c	 mov	 eax, DWORD PTR _by1$[ebp]
  00024	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00029	89 45 f4	 mov	 DWORD PTR _by2$[ebp], eax

; 1295 : 	fixed_t bbox[4];
; 1296 : 	line_t boxline, testline;
; 1297 : 	vertex_t vbox, vtest;
; 1298 : 
; 1299 : 	// Trivial rejection
; 1300 : 	if (cx1 < bx1 && cx2 < bx1)

  0002c	8b 45 08	 mov	 eax, DWORD PTR _cx1$[ebp]
  0002f	3b 45 18	 cmp	 eax, DWORD PTR _bx1$[ebp]
  00032	7d 0f		 jge	 SHORT $LN2@LineInBloc
  00034	8b 45 10	 mov	 eax, DWORD PTR _cx2$[ebp]
  00037	3b 45 18	 cmp	 eax, DWORD PTR _bx1$[ebp]
  0003a	7d 07		 jge	 SHORT $LN2@LineInBloc

; 1301 : 		return false;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 7f 03 00 00	 jmp	 $LN1@LineInBloc
$LN2@LineInBloc:

; 1302 : 
; 1303 : 	if (cx1 > bx2 && cx2 > bx2)

  00043	8b 45 08	 mov	 eax, DWORD PTR _cx1$[ebp]
  00046	3b 45 f8	 cmp	 eax, DWORD PTR _bx2$[ebp]
  00049	7e 0f		 jle	 SHORT $LN3@LineInBloc
  0004b	8b 45 10	 mov	 eax, DWORD PTR _cx2$[ebp]
  0004e	3b 45 f8	 cmp	 eax, DWORD PTR _bx2$[ebp]
  00051	7e 07		 jle	 SHORT $LN3@LineInBloc

; 1304 : 		return false;

  00053	33 c0		 xor	 eax, eax
  00055	e9 68 03 00 00	 jmp	 $LN1@LineInBloc
$LN3@LineInBloc:

; 1305 : 
; 1306 : 	if (cy1 < by1 && cy2 < by1)

  0005a	8b 45 0c	 mov	 eax, DWORD PTR _cy1$[ebp]
  0005d	3b 45 1c	 cmp	 eax, DWORD PTR _by1$[ebp]
  00060	7d 0f		 jge	 SHORT $LN4@LineInBloc
  00062	8b 45 14	 mov	 eax, DWORD PTR _cy2$[ebp]
  00065	3b 45 1c	 cmp	 eax, DWORD PTR _by1$[ebp]
  00068	7d 07		 jge	 SHORT $LN4@LineInBloc

; 1307 : 		return false;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 51 03 00 00	 jmp	 $LN1@LineInBloc
$LN4@LineInBloc:

; 1308 : 
; 1309 : 	if (cy1 > by2 && cy2 > by2)

  00071	8b 45 0c	 mov	 eax, DWORD PTR _cy1$[ebp]
  00074	3b 45 f4	 cmp	 eax, DWORD PTR _by2$[ebp]
  00077	7e 0f		 jle	 SHORT $LN5@LineInBloc
  00079	8b 45 14	 mov	 eax, DWORD PTR _cy2$[ebp]
  0007c	3b 45 f4	 cmp	 eax, DWORD PTR _by2$[ebp]
  0007f	7e 07		 jle	 SHORT $LN5@LineInBloc

; 1310 : 		return false;

  00081	33 c0		 xor	 eax, eax
  00083	e9 3a 03 00 00	 jmp	 $LN1@LineInBloc
$LN5@LineInBloc:

; 1311 : 
; 1312 : 	// Rats, guess we gotta check
; 1313 : 	// if the line intersects
; 1314 : 	// any sides of the block.
; 1315 : 	cx1 <<= FRACBITS;

  00088	8b 45 08	 mov	 eax, DWORD PTR _cx1$[ebp]
  0008b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0008e	89 45 08	 mov	 DWORD PTR _cx1$[ebp], eax

; 1316 : 	cy1 <<= FRACBITS;

  00091	8b 45 0c	 mov	 eax, DWORD PTR _cy1$[ebp]
  00094	c1 e0 10	 shl	 eax, 16			; 00000010H
  00097	89 45 0c	 mov	 DWORD PTR _cy1$[ebp], eax

; 1317 : 	cx2 <<= FRACBITS;

  0009a	8b 45 10	 mov	 eax, DWORD PTR _cx2$[ebp]
  0009d	c1 e0 10	 shl	 eax, 16			; 00000010H
  000a0	89 45 10	 mov	 DWORD PTR _cx2$[ebp], eax

; 1318 : 	cy2 <<= FRACBITS;

  000a3	8b 45 14	 mov	 eax, DWORD PTR _cy2$[ebp]
  000a6	c1 e0 10	 shl	 eax, 16			; 00000010H
  000a9	89 45 14	 mov	 DWORD PTR _cy2$[ebp], eax

; 1319 : 	bx1 <<= FRACBITS;

  000ac	8b 45 18	 mov	 eax, DWORD PTR _bx1$[ebp]
  000af	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b2	89 45 18	 mov	 DWORD PTR _bx1$[ebp], eax

; 1320 : 	by1 <<= FRACBITS;

  000b5	8b 45 1c	 mov	 eax, DWORD PTR _by1$[ebp]
  000b8	c1 e0 10	 shl	 eax, 16			; 00000010H
  000bb	89 45 1c	 mov	 DWORD PTR _by1$[ebp], eax

; 1321 : 	bx2 <<= FRACBITS;

  000be	8b 45 f8	 mov	 eax, DWORD PTR _bx2$[ebp]
  000c1	c1 e0 10	 shl	 eax, 16			; 00000010H
  000c4	89 45 f8	 mov	 DWORD PTR _bx2$[ebp], eax

; 1322 : 	by2 <<= FRACBITS;

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _by2$[ebp]
  000ca	c1 e0 10	 shl	 eax, 16			; 00000010H
  000cd	89 45 f4	 mov	 DWORD PTR _by2$[ebp], eax

; 1323 : 
; 1324 : 	bbox[BOXTOP] = by2;

  000d0	b8 04 00 00 00	 mov	 eax, 4
  000d5	6b c8 00	 imul	 ecx, eax, 0
  000d8	8b 55 f4	 mov	 edx, DWORD PTR _by2$[ebp]
  000db	89 54 0d e4	 mov	 DWORD PTR _bbox$[ebp+ecx], edx

; 1325 : 	bbox[BOXBOTTOM] = by1;

  000df	b8 04 00 00 00	 mov	 eax, 4
  000e4	c1 e0 00	 shl	 eax, 0
  000e7	8b 4d 1c	 mov	 ecx, DWORD PTR _by1$[ebp]
  000ea	89 4c 05 e4	 mov	 DWORD PTR _bbox$[ebp+eax], ecx

; 1326 : 	bbox[BOXRIGHT] = bx2;

  000ee	b8 04 00 00 00	 mov	 eax, 4
  000f3	6b c8 03	 imul	 ecx, eax, 3
  000f6	8b 55 f8	 mov	 edx, DWORD PTR _bx2$[ebp]
  000f9	89 54 0d e4	 mov	 DWORD PTR _bbox$[ebp+ecx], edx

; 1327 : 	bbox[BOXLEFT] = bx1;

  000fd	b8 04 00 00 00	 mov	 eax, 4
  00102	d1 e0		 shl	 eax, 1
  00104	8b 4d 18	 mov	 ecx, DWORD PTR _bx1$[ebp]
  00107	89 4c 05 e4	 mov	 DWORD PTR _bbox$[ebp+eax], ecx

; 1328 : 	boxline.v1 = &vbox;

  0010b	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _vbox$[ebp]
  00111	89 45 98	 mov	 DWORD PTR _boxline$[ebp], eax

; 1329 : 	testline.v1 = &vtest;

  00114	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _vtest$[ebp]
  0011a	89 85 4c ff ff
	ff		 mov	 DWORD PTR _testline$[ebp], eax

; 1330 : 
; 1331 : 	testline.v1->x = cx1;

  00120	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _testline$[ebp]
  00126	8b 4d 08	 mov	 ecx, DWORD PTR _cx1$[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 1332 : 	testline.v1->y = cy1;

  0012b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _testline$[ebp]
  00131	8b 4d 0c	 mov	 ecx, DWORD PTR _cy1$[ebp]
  00134	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1333 : 	testline.dx = cx2 - cx1;

  00137	8b 45 10	 mov	 eax, DWORD PTR _cx2$[ebp]
  0013a	2b 45 08	 sub	 eax, DWORD PTR _cx1$[ebp]
  0013d	89 85 54 ff ff
	ff		 mov	 DWORD PTR _testline$[ebp+8], eax

; 1334 : 	testline.dy = cy2 - cy1;

  00143	8b 45 14	 mov	 eax, DWORD PTR _cy2$[ebp]
  00146	2b 45 0c	 sub	 eax, DWORD PTR _cy1$[ebp]
  00149	89 85 58 ff ff
	ff		 mov	 DWORD PTR _testline$[ebp+12], eax

; 1335 : 
; 1336 : 	// Test line against bottom edge of box
; 1337 : 	boxline.v1->x = bx1;

  0014f	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00152	8b 4d 18	 mov	 ecx, DWORD PTR _bx1$[ebp]
  00155	89 08		 mov	 DWORD PTR [eax], ecx

; 1338 : 	boxline.v1->y = by1;

  00157	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  0015a	8b 4d 1c	 mov	 ecx, DWORD PTR _by1$[ebp]
  0015d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1339 : 	boxline.dx = bx2 - bx1;

  00160	8b 45 f8	 mov	 eax, DWORD PTR _bx2$[ebp]
  00163	2b 45 18	 sub	 eax, DWORD PTR _bx1$[ebp]
  00166	89 45 a0	 mov	 DWORD PTR _boxline$[ebp+8], eax

; 1340 : 	boxline.dy = 0;

  00169	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _boxline$[ebp+12], 0

; 1341 : 
; 1342 : 	if (P_PointOnLineSide(cx1, cy1, &boxline) != P_PointOnLineSide(cx2, cy2, &boxline)
; 1343 : 		&& P_PointOnLineSide(boxline.v1->x, boxline.v1->y, &testline) != P_PointOnLineSide(boxline.v1->x+boxline.dx, boxline.v1->y+boxline.dy, &testline))

  00170	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  00173	50		 push	 eax
  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _cy1$[ebp]
  00177	51		 push	 ecx
  00178	8b 55 08	 mov	 edx, DWORD PTR _cx1$[ebp]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
  00184	8b f0		 mov	 esi, eax
  00186	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d 14	 mov	 ecx, DWORD PTR _cy2$[ebp]
  0018d	51		 push	 ecx
  0018e	8b 55 10	 mov	 edx, DWORD PTR _cx2$[ebp]
  00191	52		 push	 edx
  00192	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019a	3b f0		 cmp	 esi, eax
  0019c	74 4e		 je	 SHORT $LN6@LineInBloc
  0019e	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _testline$[ebp]
  001a4	50		 push	 eax
  001a5	8b 4d 98	 mov	 ecx, DWORD PTR _boxline$[ebp]
  001a8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ab	52		 push	 edx
  001ac	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  001af	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b1	51		 push	 ecx
  001b2	e8 00 00 00 00	 call	 _P_PointOnLineSide
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ba	8b f0		 mov	 esi, eax
  001bc	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _testline$[ebp]
  001c2	52		 push	 edx
  001c3	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  001c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c9	03 4d a4	 add	 ecx, DWORD PTR _boxline$[ebp+12]
  001cc	51		 push	 ecx
  001cd	8b 55 98	 mov	 edx, DWORD PTR _boxline$[ebp]
  001d0	8b 02		 mov	 eax, DWORD PTR [edx]
  001d2	03 45 a0	 add	 eax, DWORD PTR _boxline$[ebp+8]
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 _P_PointOnLineSide
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH
  001de	3b f0		 cmp	 esi, eax
  001e0	74 0a		 je	 SHORT $LN6@LineInBloc

; 1344 : 		return true;

  001e2	b8 01 00 00 00	 mov	 eax, 1
  001e7	e9 d6 01 00 00	 jmp	 $LN1@LineInBloc
$LN6@LineInBloc:

; 1345 : 
; 1346 : 	// Right edge of box
; 1347 : 	boxline.v1->x = bx2;

  001ec	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR _bx2$[ebp]
  001f2	89 08		 mov	 DWORD PTR [eax], ecx

; 1348 : 	boxline.v1->y = by1;

  001f4	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  001f7	8b 4d 1c	 mov	 ecx, DWORD PTR _by1$[ebp]
  001fa	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1349 : 	boxline.dx = 0;

  001fd	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _boxline$[ebp+8], 0

; 1350 : 	boxline.dy = by2-by1;

  00204	8b 45 f4	 mov	 eax, DWORD PTR _by2$[ebp]
  00207	2b 45 1c	 sub	 eax, DWORD PTR _by1$[ebp]
  0020a	89 45 a4	 mov	 DWORD PTR _boxline$[ebp+12], eax

; 1351 : 
; 1352 : 	if (P_PointOnLineSide(cx1, cy1, &boxline) != P_PointOnLineSide(cx2, cy2, &boxline)
; 1353 : 		&& P_PointOnLineSide(boxline.v1->x, boxline.v1->y, &testline) != P_PointOnLineSide(boxline.v1->x+boxline.dx, boxline.v1->y+boxline.dy, &testline))

  0020d	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  00210	50		 push	 eax
  00211	8b 4d 0c	 mov	 ecx, DWORD PTR _cy1$[ebp]
  00214	51		 push	 ecx
  00215	8b 55 08	 mov	 edx, DWORD PTR _cx1$[ebp]
  00218	52		 push	 edx
  00219	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0021e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00221	8b f0		 mov	 esi, eax
  00223	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  00226	50		 push	 eax
  00227	8b 4d 14	 mov	 ecx, DWORD PTR _cy2$[ebp]
  0022a	51		 push	 ecx
  0022b	8b 55 10	 mov	 edx, DWORD PTR _cx2$[ebp]
  0022e	52		 push	 edx
  0022f	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00234	83 c4 0c	 add	 esp, 12			; 0000000cH
  00237	3b f0		 cmp	 esi, eax
  00239	74 4e		 je	 SHORT $LN7@LineInBloc
  0023b	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _testline$[ebp]
  00241	50		 push	 eax
  00242	8b 4d 98	 mov	 ecx, DWORD PTR _boxline$[ebp]
  00245	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00248	52		 push	 edx
  00249	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  0024c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00254	83 c4 0c	 add	 esp, 12			; 0000000cH
  00257	8b f0		 mov	 esi, eax
  00259	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _testline$[ebp]
  0025f	52		 push	 edx
  00260	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00263	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00266	03 4d a4	 add	 ecx, DWORD PTR _boxline$[ebp+12]
  00269	51		 push	 ecx
  0026a	8b 55 98	 mov	 edx, DWORD PTR _boxline$[ebp]
  0026d	8b 02		 mov	 eax, DWORD PTR [edx]
  0026f	03 45 a0	 add	 eax, DWORD PTR _boxline$[ebp+8]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00278	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027b	3b f0		 cmp	 esi, eax
  0027d	74 0a		 je	 SHORT $LN7@LineInBloc

; 1354 : 		return true;

  0027f	b8 01 00 00 00	 mov	 eax, 1
  00284	e9 39 01 00 00	 jmp	 $LN1@LineInBloc
$LN7@LineInBloc:

; 1355 : 
; 1356 : 	// Top edge of box
; 1357 : 	boxline.v1->x = bx1;

  00289	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  0028c	8b 4d 18	 mov	 ecx, DWORD PTR _bx1$[ebp]
  0028f	89 08		 mov	 DWORD PTR [eax], ecx

; 1358 : 	boxline.v1->y = by2;

  00291	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00294	8b 4d f4	 mov	 ecx, DWORD PTR _by2$[ebp]
  00297	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1359 : 	boxline.dx = bx2 - bx1;

  0029a	8b 45 f8	 mov	 eax, DWORD PTR _bx2$[ebp]
  0029d	2b 45 18	 sub	 eax, DWORD PTR _bx1$[ebp]
  002a0	89 45 a0	 mov	 DWORD PTR _boxline$[ebp+8], eax

; 1360 : 	boxline.dy = 0;

  002a3	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _boxline$[ebp+12], 0

; 1361 : 
; 1362 : 	if (P_PointOnLineSide(cx1, cy1, &boxline) != P_PointOnLineSide(cx2, cy2, &boxline)
; 1363 : 		&& P_PointOnLineSide(boxline.v1->x, boxline.v1->y, &testline) != P_PointOnLineSide(boxline.v1->x+boxline.dx, boxline.v1->y+boxline.dy, &testline))

  002aa	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  002ad	50		 push	 eax
  002ae	8b 4d 0c	 mov	 ecx, DWORD PTR _cy1$[ebp]
  002b1	51		 push	 ecx
  002b2	8b 55 08	 mov	 edx, DWORD PTR _cx1$[ebp]
  002b5	52		 push	 edx
  002b6	e8 00 00 00 00	 call	 _P_PointOnLineSide
  002bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002be	8b f0		 mov	 esi, eax
  002c0	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  002c3	50		 push	 eax
  002c4	8b 4d 14	 mov	 ecx, DWORD PTR _cy2$[ebp]
  002c7	51		 push	 ecx
  002c8	8b 55 10	 mov	 edx, DWORD PTR _cx2$[ebp]
  002cb	52		 push	 edx
  002cc	e8 00 00 00 00	 call	 _P_PointOnLineSide
  002d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d4	3b f0		 cmp	 esi, eax
  002d6	74 4e		 je	 SHORT $LN8@LineInBloc
  002d8	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _testline$[ebp]
  002de	50		 push	 eax
  002df	8b 4d 98	 mov	 ecx, DWORD PTR _boxline$[ebp]
  002e2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002e5	52		 push	 edx
  002e6	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  002e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002eb	51		 push	 ecx
  002ec	e8 00 00 00 00	 call	 _P_PointOnLineSide
  002f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f4	8b f0		 mov	 esi, eax
  002f6	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _testline$[ebp]
  002fc	52		 push	 edx
  002fd	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00300	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00303	03 4d a4	 add	 ecx, DWORD PTR _boxline$[ebp+12]
  00306	51		 push	 ecx
  00307	8b 55 98	 mov	 edx, DWORD PTR _boxline$[ebp]
  0030a	8b 02		 mov	 eax, DWORD PTR [edx]
  0030c	03 45 a0	 add	 eax, DWORD PTR _boxline$[ebp+8]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00315	83 c4 0c	 add	 esp, 12			; 0000000cH
  00318	3b f0		 cmp	 esi, eax
  0031a	74 0a		 je	 SHORT $LN8@LineInBloc

; 1364 : 		return true;

  0031c	b8 01 00 00 00	 mov	 eax, 1
  00321	e9 9c 00 00 00	 jmp	 $LN1@LineInBloc
$LN8@LineInBloc:

; 1365 : 
; 1366 : 	// Left edge of box
; 1367 : 	boxline.v1->x = bx1;

  00326	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00329	8b 4d 18	 mov	 ecx, DWORD PTR _bx1$[ebp]
  0032c	89 08		 mov	 DWORD PTR [eax], ecx

; 1368 : 	boxline.v1->y = by1;

  0032e	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00331	8b 4d 1c	 mov	 ecx, DWORD PTR _by1$[ebp]
  00334	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1369 : 	boxline.dx = 0;

  00337	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _boxline$[ebp+8], 0

; 1370 : 	boxline.dy = by2-by1;

  0033e	8b 45 f4	 mov	 eax, DWORD PTR _by2$[ebp]
  00341	2b 45 1c	 sub	 eax, DWORD PTR _by1$[ebp]
  00344	89 45 a4	 mov	 DWORD PTR _boxline$[ebp+12], eax

; 1371 : 
; 1372 : 	if (P_PointOnLineSide(cx1, cy1, &boxline) != P_PointOnLineSide(cx2, cy2, &boxline)
; 1373 : 		&& P_PointOnLineSide(boxline.v1->x, boxline.v1->y, &testline) != P_PointOnLineSide(boxline.v1->x+boxline.dx, boxline.v1->y+boxline.dy, &testline))

  00347	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  0034a	50		 push	 eax
  0034b	8b 4d 0c	 mov	 ecx, DWORD PTR _cy1$[ebp]
  0034e	51		 push	 ecx
  0034f	8b 55 08	 mov	 edx, DWORD PTR _cx1$[ebp]
  00352	52		 push	 edx
  00353	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00358	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035b	8b f0		 mov	 esi, eax
  0035d	8d 45 98	 lea	 eax, DWORD PTR _boxline$[ebp]
  00360	50		 push	 eax
  00361	8b 4d 14	 mov	 ecx, DWORD PTR _cy2$[ebp]
  00364	51		 push	 ecx
  00365	8b 55 10	 mov	 edx, DWORD PTR _cx2$[ebp]
  00368	52		 push	 edx
  00369	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0036e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00371	3b f0		 cmp	 esi, eax
  00373	74 4b		 je	 SHORT $LN9@LineInBloc
  00375	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _testline$[ebp]
  0037b	50		 push	 eax
  0037c	8b 4d 98	 mov	 ecx, DWORD PTR _boxline$[ebp]
  0037f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00382	52		 push	 edx
  00383	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  00386	8b 08		 mov	 ecx, DWORD PTR [eax]
  00388	51		 push	 ecx
  00389	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0038e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00391	8b f0		 mov	 esi, eax
  00393	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _testline$[ebp]
  00399	52		 push	 edx
  0039a	8b 45 98	 mov	 eax, DWORD PTR _boxline$[ebp]
  0039d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003a0	03 4d a4	 add	 ecx, DWORD PTR _boxline$[ebp+12]
  003a3	51		 push	 ecx
  003a4	8b 55 98	 mov	 edx, DWORD PTR _boxline$[ebp]
  003a7	8b 02		 mov	 eax, DWORD PTR [edx]
  003a9	03 45 a0	 add	 eax, DWORD PTR _boxline$[ebp+8]
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 _P_PointOnLineSide
  003b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b5	3b f0		 cmp	 esi, eax
  003b7	74 07		 je	 SHORT $LN9@LineInBloc

; 1374 : 		return true;

  003b9	b8 01 00 00 00	 mov	 eax, 1
  003be	eb 02		 jmp	 SHORT $LN1@LineInBloc
$LN9@LineInBloc:

; 1375 : 
; 1376 : 	return false;

  003c0	33 c0		 xor	 eax, eax
$LN1@LineInBloc:

; 1377 : }

  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
_LineInBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadSideDefs2
_TEXT	SEGMENT
tv1191 = -184						; size = 4
tv594 = -184						; size = 4
tv1192 = -180						; size = 4
tv595 = -180						; size = 4
tv1193 = -176						; size = 4
tv596 = -176						; size = 4
tv557 = -172						; size = 4
tv1449 = -172						; size = 4
tv852 = -172						; size = 4
tv1154 = -172						; size = 4
tv558 = -168						; size = 4
tv1450 = -168						; size = 4
tv853 = -168						; size = 4
tv1155 = -168						; size = 4
tv559 = -164						; size = 4
tv1451 = -164						; size = 4
tv1156 = -164						; size = 4
tv854 = -164						; size = 4
tv1111 = -160						; size = 4
tv514 = -160						; size = 4
tv1406 = -160						; size = 4
tv809 = -160						; size = 4
tv1407 = -156						; size = 4
tv1112 = -156						; size = 4
tv810 = -156						; size = 4
tv515 = -156						; size = 4
tv1408 = -152						; size = 4
tv516 = -152						; size = 4
tv1113 = -152						; size = 4
tv811 = -152						; size = 4
tv471 = -148						; size = 4
tv1068 = -148						; size = 4
tv766 = -148						; size = 4
tv1363 = -148						; size = 4
tv472 = -144						; size = 4
tv1069 = -144						; size = 4
tv1364 = -144						; size = 4
tv767 = -144						; size = 4
tv1365 = -140						; size = 4
tv1070 = -140						; size = 4
tv768 = -140						; size = 4
tv473 = -140						; size = 4
tv428 = -136						; size = 4
tv1025 = -136						; size = 4
tv723 = -136						; size = 4
tv1320 = -136						; size = 4
tv1026 = -132						; size = 4
tv429 = -132						; size = 4
tv724 = -132						; size = 4
tv1321 = -132						; size = 4
tv725 = -128						; size = 4
tv1027 = -128						; size = 4
tv430 = -128						; size = 4
tv1322 = -128						; size = 4
tv983 = -124						; size = 4
tv386 = -124						; size = 4
tv1278 = -124						; size = 4
tv681 = -124						; size = 4
tv984 = -120						; size = 4
tv387 = -120						; size = 4
tv1279 = -120						; size = 4
tv682 = -120						; size = 4
tv985 = -116						; size = 4
tv388 = -116						; size = 4
tv1280 = -116						; size = 4
tv683 = -116						; size = 4
tv941 = -112						; size = 4
tv1236 = -112						; size = 4
tv639 = -112						; size = 4
tv344 = -112						; size = 4
tv942 = -108						; size = 4
tv345 = -108						; size = 4
tv640 = -108						; size = 4
tv1237 = -108						; size = 4
tv346 = -104						; size = 4
tv135 = -104						; size = 4
tv1502 = -104						; size = 4
tv1238 = -104						; size = 4
tv943 = -104						; size = 4
tv641 = -104						; size = 4
_col$1 = -36						; size = 4
_col$2 = -32						; size = 4
_sector_num$3 = -28					; size = 2
_sec$4 = -24						; size = 4
_sd$5 = -20						; size = 4
_msd$6 = -16						; size = 4
_num$ = -12						; size = 4
_i$ = -8						; size = 2
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadSideDefs2 PROC					; COMDAT

; 1116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1117 : 	UINT8 *data = W_CacheLumpNum(lumpnum, PU_STATIC);

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00017	83 c4 08	 add	 esp, 8
  0001a	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 1118 : 	UINT16 i;
; 1119 : 	INT32 num;
; 1120 : 
; 1121 : 	for (i = 0; i < numsides; i++)

  0001d	33 c0		 xor	 eax, eax
  0001f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00023	eb 0c		 jmp	 SHORT $LN4@P_LoadSide
$LN2@P_LoadSide:
  00025	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00029	66 83 c0 01	 add	 ax, 1
  0002d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN4@P_LoadSide:
  00031	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00035	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsides
  0003b	0f 83 8a 1e 00
	00		 jae	 $LN3@P_LoadSide

; 1122 : 	{
; 1123 : 		register mapsidedef_t *msd = (mapsidedef_t *)data + i;

  00041	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00045	6b c8 1e	 imul	 ecx, eax, 30
  00048	03 4d fc	 add	 ecx, DWORD PTR _data$[ebp]
  0004b	89 4d f0	 mov	 DWORD PTR _msd$6[ebp], ecx

; 1124 : 		register side_t *sd = sides + i;

  0004e	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00052	6b c8 1c	 imul	 ecx, eax, 28
  00055	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  0005b	89 4d ec	 mov	 DWORD PTR _sd$5[ebp], ecx

; 1125 : 		register sector_t *sec;
; 1126 : 
; 1127 : 		sd->textureoffset = SHORT(msd->textureoffset)<<FRACBITS;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  00061	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00064	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00067	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  0006a	89 0a		 mov	 DWORD PTR [edx], ecx

; 1128 : 		sd->rowoffset = SHORT(msd->rowoffset)<<FRACBITS;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  0006f	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00073	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00076	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  00079	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1129 : 
; 1130 : 		{ /* cph 2006/09/30 - catch out-of-range sector numbers; use sector 0 instead */
; 1131 : 			UINT16 sector_num = SHORT(msd->sector);

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  0007f	66 8b 48 1c	 mov	 cx, WORD PTR [eax+28]
  00083	66 89 4d e4	 mov	 WORD PTR _sector_num$3[ebp], cx

; 1132 : 
; 1133 : 			if (sector_num >= numsectors)

  00087	0f b7 45 e4	 movzx	 eax, WORD PTR _sector_num$3[ebp]
  0008b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00091	72 1d		 jb	 SHORT $LN7@P_LoadSide

; 1134 : 			{
; 1135 : 				CONS_Printf("P_LoadSideDefs2: sidedef %u has out-of-range sector num %u\n", i, sector_num);

  00093	0f b7 45 e4	 movzx	 eax, WORD PTR _sector_num$3[ebp]
  00097	50		 push	 eax
  00098	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  0009c	51		 push	 ecx
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DEMECFOO@P_LoadSideDefs2?3?5sidedef?5?$CFu?5has@
  000a2	e8 00 00 00 00	 call	 _CONS_Printf
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1136 : 				sector_num = 0;

  000aa	33 c0		 xor	 eax, eax
  000ac	66 89 45 e4	 mov	 WORD PTR _sector_num$3[ebp], ax
$LN7@P_LoadSide:

; 1137 : 			}
; 1138 : 			sd->sector = sec = &sectors[sector_num];

  000b0	0f b7 45 e4	 movzx	 eax, WORD PTR _sector_num$3[ebp]
  000b4	69 c8 f8 00 00
	00		 imul	 ecx, eax, 248
  000ba	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  000c0	89 4d e8	 mov	 DWORD PTR _sec$4[ebp], ecx
  000c3	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  000c6	8b 45 e8	 mov	 eax, DWORD PTR _sec$4[ebp]
  000c9	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1139 : 		}
; 1140 : 
; 1141 : 		// refined to allow colormaps to work as wall textures if invalid as colormaps
; 1142 : 		// but valid as textures.
; 1143 : 
; 1144 : 		sd->sector = sec = &sectors[SHORT(msd->sector)];

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  000cf	0f bf 48 1c	 movsx	 ecx, WORD PTR [eax+28]
  000d3	69 d1 f8 00 00
	00		 imul	 edx, ecx, 248
  000d9	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  000df	89 55 e8	 mov	 DWORD PTR _sec$4[ebp], edx
  000e2	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _sec$4[ebp]
  000e8	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1145 : 
; 1146 : 		// Colormaps!
; 1147 : 		switch (sd->special)

  000eb	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  000ee	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  000f2	89 4d 98	 mov	 DWORD PTR tv135[ebp], ecx
  000f5	83 7d 98 3f	 cmp	 DWORD PTR tv135[ebp], 63 ; 0000003fH
  000f9	74 0e		 je	 SHORT $LN8@P_LoadSide
  000fb	81 7d 98 5e 02
	00 00		 cmp	 DWORD PTR tv135[ebp], 606 ; 0000025eH
  00102	74 05		 je	 SHORT $LN8@P_LoadSide
  00104	e9 df 1c 00 00	 jmp	 $LN11@P_LoadSide
$LN8@P_LoadSide:

; 1148 : 		{
; 1149 : 			case 63: // variable colormap via 242 linedef
; 1150 : 			case 606: //SoM: 4/4/2000: Just colormap transfer
; 1151 : 				// SoM: R_CreateColormap will only create a colormap in software mode...
; 1152 : 				// Perhaps we should just call it instead of doing the calculations here.
; 1153 : 				if (rendermode == render_soft || rendermode == render_none)

  00109	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00110	74 0d		 je	 SHORT $LN12@P_LoadSide
  00112	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00119	0f 85 06 01 00
	00		 jne	 $LN10@P_LoadSide
$LN12@P_LoadSide:

; 1154 : 				{
; 1155 : 					if (msd->toptexture[0] == '#' || msd->bottomtexture[0] == '#')

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	6b c8 00	 imul	 ecx, eax, 0
  00127	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  0012a	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  0012f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00132	74 15		 je	 SHORT $LN15@P_LoadSide
  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	6b c8 00	 imul	 ecx, eax, 0
  0013c	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  0013f	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  00144	83 f8 23	 cmp	 eax, 35			; 00000023H
  00147	75 3c		 jne	 SHORT $LN13@P_LoadSide
$LN15@P_LoadSide:

; 1156 : 					{
; 1157 : 						sec->midmap = R_CreateColormap(msd->toptexture, msd->midtexture,

  00149	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  0014c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0014f	50		 push	 eax
  00150	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00153	83 c1 14	 add	 ecx, 20			; 00000014H
  00156	51		 push	 ecx
  00157	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  0015a	83 c2 04	 add	 edx, 4
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _R_CreateColormap
  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
  00166	8b 4d e8	 mov	 ecx, DWORD PTR _sec$4[ebp]
  00169	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 1158 : 							msd->bottomtexture);
; 1159 : 						sd->toptexture = sd->bottomtexture = 0;

  0016c	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  0016f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00176	8b 4d ec	 mov	 ecx, DWORD PTR _sd$5[ebp]
  00179	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 1160 : 					}

  00180	e9 96 00 00 00	 jmp	 $LN21@P_LoadSide
$LN13@P_LoadSide:

; 1161 : 					else
; 1162 : 					{
; 1163 : 						if ((num = R_CheckTextureNumForName(msd->toptexture, i)) == -1)

  00185	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  0018d	83 c1 04	 add	 ecx, 4
  00190	51		 push	 ecx
  00191	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  00196	83 c4 08	 add	 esp, 8
  00199	89 45 f4	 mov	 DWORD PTR _num$[ebp], eax
  0019c	83 7d f4 ff	 cmp	 DWORD PTR _num$[ebp], -1
  001a0	75 0c		 jne	 SHORT $LN16@P_LoadSide

; 1164 : 							sd->toptexture = 0;

  001a2	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  001a5	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001ac	eb 09		 jmp	 SHORT $LN17@P_LoadSide
$LN16@P_LoadSide:

; 1165 : 						else
; 1166 : 							sd->toptexture = num;

  001ae	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  001b1	8b 4d f4	 mov	 ecx, DWORD PTR _num$[ebp]
  001b4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN17@P_LoadSide:

; 1167 : 						if ((num = R_CheckTextureNumForName(msd->midtexture, i)) == -1)

  001b7	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  001bb	50		 push	 eax
  001bc	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  001bf	83 c1 14	 add	 ecx, 20			; 00000014H
  001c2	51		 push	 ecx
  001c3	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  001c8	83 c4 08	 add	 esp, 8
  001cb	89 45 f4	 mov	 DWORD PTR _num$[ebp], eax
  001ce	83 7d f4 ff	 cmp	 DWORD PTR _num$[ebp], -1
  001d2	75 0c		 jne	 SHORT $LN18@P_LoadSide

; 1168 : 							sd->midtexture = 0;

  001d4	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  001d7	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  001de	eb 09		 jmp	 SHORT $LN19@P_LoadSide
$LN18@P_LoadSide:

; 1169 : 						else
; 1170 : 							sd->midtexture = num;

  001e0	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  001e3	8b 4d f4	 mov	 ecx, DWORD PTR _num$[ebp]
  001e6	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN19@P_LoadSide:

; 1171 : 						if ((num = R_CheckTextureNumForName(msd->bottomtexture, i)) == -1)

  001e9	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  001ed	50		 push	 eax
  001ee	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  001f1	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  001fa	83 c4 08	 add	 esp, 8
  001fd	89 45 f4	 mov	 DWORD PTR _num$[ebp], eax
  00200	83 7d f4 ff	 cmp	 DWORD PTR _num$[ebp], -1
  00204	75 0c		 jne	 SHORT $LN20@P_LoadSide

; 1172 : 							sd->bottomtexture = 0;

  00206	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  00209	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00210	eb 09		 jmp	 SHORT $LN21@P_LoadSide
$LN20@P_LoadSide:

; 1173 : 						else
; 1174 : 							sd->bottomtexture = num;

  00212	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  00215	8b 4d f4	 mov	 ecx, DWORD PTR _num$[ebp]
  00218	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN21@P_LoadSide:

; 1175 : 					}
; 1176 : 					break;

  0021b	e9 a6 1c 00 00	 jmp	 $LN5@P_LoadSide

; 1177 : 				}

  00220	e9 c3 1b 00 00	 jmp	 $LN11@P_LoadSide
$LN10@P_LoadSide:

; 1178 : #ifdef HWRENDER
; 1179 : 				else
; 1180 : 				{
; 1181 : 					// for now, full support of toptexture only
; 1182 : 					if ((msd->toptexture[0] == '#' && msd->toptexture[1] && msd->toptexture[2] && msd->toptexture[3] && msd->toptexture[4] && msd->toptexture[5] && msd->toptexture[6])
; 1183 : 						|| (msd->bottomtexture[0] == '#' && msd->bottomtexture[1] && msd->bottomtexture[2] && msd->bottomtexture[3] && msd->bottomtexture[4] && msd->bottomtexture[5] && msd->bottomtexture[6]))

  00225	b8 01 00 00 00	 mov	 eax, 1
  0022a	6b c8 00	 imul	 ecx, eax, 0
  0022d	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00230	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  00235	83 f8 23	 cmp	 eax, 35			; 00000023H
  00238	75 7b		 jne	 SHORT $LN25@P_LoadSide
  0023a	b8 01 00 00 00	 mov	 eax, 1
  0023f	c1 e0 00	 shl	 eax, 0
  00242	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00245	0f be 54 01 04	 movsx	 edx, BYTE PTR [ecx+eax+4]
  0024a	85 d2		 test	 edx, edx
  0024c	74 67		 je	 SHORT $LN25@P_LoadSide
  0024e	b8 01 00 00 00	 mov	 eax, 1
  00253	d1 e0		 shl	 eax, 1
  00255	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00258	0f be 54 01 04	 movsx	 edx, BYTE PTR [ecx+eax+4]
  0025d	85 d2		 test	 edx, edx
  0025f	74 54		 je	 SHORT $LN25@P_LoadSide
  00261	b8 01 00 00 00	 mov	 eax, 1
  00266	6b c8 03	 imul	 ecx, eax, 3
  00269	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  0026c	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  00271	85 c0		 test	 eax, eax
  00273	74 40		 je	 SHORT $LN25@P_LoadSide
  00275	b8 01 00 00 00	 mov	 eax, 1
  0027a	c1 e0 02	 shl	 eax, 2
  0027d	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00280	0f be 54 01 04	 movsx	 edx, BYTE PTR [ecx+eax+4]
  00285	85 d2		 test	 edx, edx
  00287	74 2c		 je	 SHORT $LN25@P_LoadSide
  00289	b8 01 00 00 00	 mov	 eax, 1
  0028e	6b c8 05	 imul	 ecx, eax, 5
  00291	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00294	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  00299	85 c0		 test	 eax, eax
  0029b	74 18		 je	 SHORT $LN25@P_LoadSide
  0029d	b8 01 00 00 00	 mov	 eax, 1
  002a2	6b c8 06	 imul	 ecx, eax, 6
  002a5	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  002a8	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  002ad	85 c0		 test	 eax, eax
  002af	0f 85 a8 00 00
	00		 jne	 $LN24@P_LoadSide
$LN25@P_LoadSide:
  002b5	b8 01 00 00 00	 mov	 eax, 1
  002ba	6b c8 00	 imul	 ecx, eax, 0
  002bd	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  002c0	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  002c5	83 f8 23	 cmp	 eax, 35			; 00000023H
  002c8	0f 85 7f 1a 00
	00		 jne	 $LN22@P_LoadSide
  002ce	b8 01 00 00 00	 mov	 eax, 1
  002d3	c1 e0 00	 shl	 eax, 0
  002d6	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  002d9	0f be 54 01 0c	 movsx	 edx, BYTE PTR [ecx+eax+12]
  002de	85 d2		 test	 edx, edx
  002e0	0f 84 67 1a 00
	00		 je	 $LN22@P_LoadSide
  002e6	b8 01 00 00 00	 mov	 eax, 1
  002eb	d1 e0		 shl	 eax, 1
  002ed	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  002f0	0f be 54 01 0c	 movsx	 edx, BYTE PTR [ecx+eax+12]
  002f5	85 d2		 test	 edx, edx
  002f7	0f 84 50 1a 00
	00		 je	 $LN22@P_LoadSide
  002fd	b8 01 00 00 00	 mov	 eax, 1
  00302	6b c8 03	 imul	 ecx, eax, 3
  00305	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00308	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  0030d	85 c0		 test	 eax, eax
  0030f	0f 84 38 1a 00
	00		 je	 $LN22@P_LoadSide
  00315	b8 01 00 00 00	 mov	 eax, 1
  0031a	c1 e0 02	 shl	 eax, 2
  0031d	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00320	0f be 54 01 0c	 movsx	 edx, BYTE PTR [ecx+eax+12]
  00325	85 d2		 test	 edx, edx
  00327	0f 84 20 1a 00
	00		 je	 $LN22@P_LoadSide
  0032d	b8 01 00 00 00	 mov	 eax, 1
  00332	6b c8 05	 imul	 ecx, eax, 5
  00335	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00338	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  0033d	85 c0		 test	 eax, eax
  0033f	0f 84 08 1a 00
	00		 je	 $LN22@P_LoadSide
  00345	b8 01 00 00 00	 mov	 eax, 1
  0034a	6b c8 06	 imul	 ecx, eax, 6
  0034d	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00350	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  00355	85 c0		 test	 eax, eax
  00357	0f 84 f0 19 00
	00		 je	 $LN22@P_LoadSide
$LN24@P_LoadSide:

; 1184 : 					{
; 1185 : 						char *col;
; 1186 : 
; 1187 : 						sec->midmap = R_CreateColormap(msd->toptexture, msd->midtexture,

  0035d	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  00360	83 c0 0c	 add	 eax, 12			; 0000000cH
  00363	50		 push	 eax
  00364	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00367	83 c1 14	 add	 ecx, 20			; 00000014H
  0036a	51		 push	 ecx
  0036b	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  0036e	83 c2 04	 add	 edx, 4
  00371	52		 push	 edx
  00372	e8 00 00 00 00	 call	 _R_CreateColormap
  00377	83 c4 0c	 add	 esp, 12			; 0000000cH
  0037a	8b 4d e8	 mov	 ecx, DWORD PTR _sec$4[ebp]
  0037d	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 1188 : 							msd->bottomtexture);
; 1189 : 						sd->toptexture = sd->bottomtexture = 0;

  00380	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  00383	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0038a	8b 4d ec	 mov	 ecx, DWORD PTR _sd$5[ebp]
  0038d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 1190 : 
; 1191 : 						sec->extra_colormap = &extra_colormaps[sec->midmap];

  00394	8b 45 e8	 mov	 eax, DWORD PTR _sec$4[ebp]
  00397	6b 48 7c 28	 imul	 ecx, DWORD PTR [eax+124], 40
  0039b	81 c1 00 00 00
	00		 add	 ecx, OFFSET _extra_colormaps
  003a1	8b 55 e8	 mov	 edx, DWORD PTR _sec$4[ebp]
  003a4	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 1192 : 
; 1193 : 						if (msd->toptexture[0] == '#' && msd->toptexture[1] && msd->toptexture[2] && msd->toptexture[3] && msd->toptexture[4] && msd->toptexture[5] && msd->toptexture[6])

  003aa	b8 01 00 00 00	 mov	 eax, 1
  003af	6b c8 00	 imul	 ecx, eax, 0
  003b2	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  003b5	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  003ba	83 f8 23	 cmp	 eax, 35			; 00000023H
  003bd	0f 85 a6 0c 00
	00		 jne	 $LN26@P_LoadSide
  003c3	b8 01 00 00 00	 mov	 eax, 1
  003c8	c1 e0 00	 shl	 eax, 0
  003cb	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  003ce	0f be 54 01 04	 movsx	 edx, BYTE PTR [ecx+eax+4]
  003d3	85 d2		 test	 edx, edx
  003d5	0f 84 8e 0c 00
	00		 je	 $LN26@P_LoadSide
  003db	b8 01 00 00 00	 mov	 eax, 1
  003e0	d1 e0		 shl	 eax, 1
  003e2	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  003e5	0f be 54 01 04	 movsx	 edx, BYTE PTR [ecx+eax+4]
  003ea	85 d2		 test	 edx, edx
  003ec	0f 84 77 0c 00
	00		 je	 $LN26@P_LoadSide
  003f2	b8 01 00 00 00	 mov	 eax, 1
  003f7	6b c8 03	 imul	 ecx, eax, 3
  003fa	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  003fd	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  00402	85 c0		 test	 eax, eax
  00404	0f 84 5f 0c 00
	00		 je	 $LN26@P_LoadSide
  0040a	b8 01 00 00 00	 mov	 eax, 1
  0040f	c1 e0 02	 shl	 eax, 2
  00412	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  00415	0f be 54 01 04	 movsx	 edx, BYTE PTR [ecx+eax+4]
  0041a	85 d2		 test	 edx, edx
  0041c	0f 84 47 0c 00
	00		 je	 $LN26@P_LoadSide
  00422	b8 01 00 00 00	 mov	 eax, 1
  00427	6b c8 05	 imul	 ecx, eax, 5
  0042a	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  0042d	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  00432	85 c0		 test	 eax, eax
  00434	0f 84 2f 0c 00
	00		 je	 $LN26@P_LoadSide
  0043a	b8 01 00 00 00	 mov	 eax, 1
  0043f	6b c8 06	 imul	 ecx, eax, 6
  00442	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00445	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  0044a	85 c0		 test	 eax, eax
  0044c	0f 84 17 0c 00
	00		 je	 $LN26@P_LoadSide

; 1194 : 						{
; 1195 : 							col = msd->toptexture;

  00452	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  00455	83 c0 04	 add	 eax, 4
  00458	89 45 e0	 mov	 DWORD PTR _col$2[ebp], eax

; 1196 : 
; 1197 : #define HEX2INT(x) (x >= '0' && x <= '9' ? x - '0' : x >= 'a' && x <= 'f' ? x - 'a' + 10 : x >= 'A' && x <= 'F' ? x - 'A' + 10 : 0)
; 1198 : #define ALPHA2INT(x) (x >= 'a' && x <= 'z' ? x - 'a' : x >= 'A' && x <= 'Z' ? x - 'A' : x >= '0' && x <= '9' ? 25 : 0)
; 1199 : 							if (msd->toptexture[7])

  0045b	b8 01 00 00 00	 mov	 eax, 1
  00460	6b c8 07	 imul	 ecx, eax, 7
  00463	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  00466	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  0046b	85 c0		 test	 eax, eax
  0046d	0f 84 6e 06 00
	00		 je	 $LN28@P_LoadSide

; 1200 : 							{
; 1201 : 								sec->extra_colormap->rgba =

  00473	b8 01 00 00 00	 mov	 eax, 1
  00478	c1 e0 00	 shl	 eax, 0
  0047b	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0047e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00482	83 fa 30	 cmp	 edx, 48			; 00000030H
  00485	7c 2e		 jl	 SHORT $LN44@P_LoadSide
  00487	b8 01 00 00 00	 mov	 eax, 1
  0048c	c1 e0 00	 shl	 eax, 0
  0048f	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00492	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00496	83 fa 39	 cmp	 edx, 57			; 00000039H
  00499	7f 1a		 jg	 SHORT $LN44@P_LoadSide
  0049b	b8 01 00 00 00	 mov	 eax, 1
  004a0	c1 e0 00	 shl	 eax, 0
  004a3	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  004a6	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  004aa	83 ea 30	 sub	 edx, 48			; 00000030H
  004ad	89 55 98	 mov	 DWORD PTR tv346[ebp], edx
  004b0	e9 91 00 00 00	 jmp	 $LN49@P_LoadSide
$LN44@P_LoadSide:
  004b5	b8 01 00 00 00	 mov	 eax, 1
  004ba	c1 e0 00	 shl	 eax, 0
  004bd	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  004c0	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  004c4	83 fa 61	 cmp	 edx, 97			; 00000061H
  004c7	7c 2b		 jl	 SHORT $LN45@P_LoadSide
  004c9	b8 01 00 00 00	 mov	 eax, 1
  004ce	c1 e0 00	 shl	 eax, 0
  004d1	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  004d4	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  004d8	83 fa 66	 cmp	 edx, 102		; 00000066H
  004db	7f 17		 jg	 SHORT $LN45@P_LoadSide
  004dd	b8 01 00 00 00	 mov	 eax, 1
  004e2	c1 e0 00	 shl	 eax, 0
  004e5	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  004e8	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  004ec	83 ea 57	 sub	 edx, 87			; 00000057H
  004ef	89 55 94	 mov	 DWORD PTR tv345[ebp], edx
  004f2	eb 4c		 jmp	 SHORT $LN48@P_LoadSide
$LN45@P_LoadSide:
  004f4	b8 01 00 00 00	 mov	 eax, 1
  004f9	c1 e0 00	 shl	 eax, 0
  004fc	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  004ff	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00503	83 fa 41	 cmp	 edx, 65			; 00000041H
  00506	7c 2b		 jl	 SHORT $LN46@P_LoadSide
  00508	b8 01 00 00 00	 mov	 eax, 1
  0050d	c1 e0 00	 shl	 eax, 0
  00510	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00513	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00517	83 fa 46	 cmp	 edx, 70			; 00000046H
  0051a	7f 17		 jg	 SHORT $LN46@P_LoadSide
  0051c	b8 01 00 00 00	 mov	 eax, 1
  00521	c1 e0 00	 shl	 eax, 0
  00524	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00527	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0052b	83 ea 37	 sub	 edx, 55			; 00000037H
  0052e	89 55 90	 mov	 DWORD PTR tv344[ebp], edx
  00531	eb 07		 jmp	 SHORT $LN47@P_LoadSide
$LN46@P_LoadSide:
  00533	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv344[ebp], 0
$LN47@P_LoadSide:
  0053a	8b 45 90	 mov	 eax, DWORD PTR tv344[ebp]
  0053d	89 45 94	 mov	 DWORD PTR tv345[ebp], eax
$LN48@P_LoadSide:
  00540	8b 4d 94	 mov	 ecx, DWORD PTR tv345[ebp]
  00543	89 4d 98	 mov	 DWORD PTR tv346[ebp], ecx
$LN49@P_LoadSide:
  00546	ba 01 00 00 00	 mov	 edx, 1
  0054b	d1 e2		 shl	 edx, 1
  0054d	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00550	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00554	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00557	7c 2c		 jl	 SHORT $LN50@P_LoadSide
  00559	ba 01 00 00 00	 mov	 edx, 1
  0055e	d1 e2		 shl	 edx, 1
  00560	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00563	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00567	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0056a	7f 19		 jg	 SHORT $LN50@P_LoadSide
  0056c	ba 01 00 00 00	 mov	 edx, 1
  00571	d1 e2		 shl	 edx, 1
  00573	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00576	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0057a	83 e9 30	 sub	 ecx, 48			; 00000030H
  0057d	89 4d 8c	 mov	 DWORD PTR tv388[ebp], ecx
  00580	e9 8b 00 00 00	 jmp	 $LN55@P_LoadSide
$LN50@P_LoadSide:
  00585	ba 01 00 00 00	 mov	 edx, 1
  0058a	d1 e2		 shl	 edx, 1
  0058c	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0058f	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00593	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00596	7c 29		 jl	 SHORT $LN51@P_LoadSide
  00598	ba 01 00 00 00	 mov	 edx, 1
  0059d	d1 e2		 shl	 edx, 1
  0059f	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  005a2	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  005a6	83 f9 66	 cmp	 ecx, 102		; 00000066H
  005a9	7f 16		 jg	 SHORT $LN51@P_LoadSide
  005ab	ba 01 00 00 00	 mov	 edx, 1
  005b0	d1 e2		 shl	 edx, 1
  005b2	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  005b5	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  005b9	83 e9 57	 sub	 ecx, 87			; 00000057H
  005bc	89 4d 88	 mov	 DWORD PTR tv387[ebp], ecx
  005bf	eb 49		 jmp	 SHORT $LN54@P_LoadSide
$LN51@P_LoadSide:
  005c1	ba 01 00 00 00	 mov	 edx, 1
  005c6	d1 e2		 shl	 edx, 1
  005c8	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  005cb	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  005cf	83 f9 41	 cmp	 ecx, 65			; 00000041H
  005d2	7c 29		 jl	 SHORT $LN52@P_LoadSide
  005d4	ba 01 00 00 00	 mov	 edx, 1
  005d9	d1 e2		 shl	 edx, 1
  005db	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  005de	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  005e2	83 f9 46	 cmp	 ecx, 70			; 00000046H
  005e5	7f 16		 jg	 SHORT $LN52@P_LoadSide
  005e7	ba 01 00 00 00	 mov	 edx, 1
  005ec	d1 e2		 shl	 edx, 1
  005ee	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  005f1	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  005f5	83 e9 37	 sub	 ecx, 55			; 00000037H
  005f8	89 4d 84	 mov	 DWORD PTR tv386[ebp], ecx
  005fb	eb 07		 jmp	 SHORT $LN53@P_LoadSide
$LN52@P_LoadSide:
  005fd	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv386[ebp], 0
$LN53@P_LoadSide:
  00604	8b 55 84	 mov	 edx, DWORD PTR tv386[ebp]
  00607	89 55 88	 mov	 DWORD PTR tv387[ebp], edx
$LN54@P_LoadSide:
  0060a	8b 45 88	 mov	 eax, DWORD PTR tv387[ebp]
  0060d	89 45 8c	 mov	 DWORD PTR tv388[ebp], eax
$LN55@P_LoadSide:
  00610	b9 01 00 00 00	 mov	 ecx, 1
  00615	6b d1 03	 imul	 edx, ecx, 3
  00618	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0061b	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0061f	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00622	7c 2e		 jl	 SHORT $LN56@P_LoadSide
  00624	ba 01 00 00 00	 mov	 edx, 1
  00629	6b c2 03	 imul	 eax, edx, 3
  0062c	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0062f	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00633	83 fa 39	 cmp	 edx, 57			; 00000039H
  00636	7f 1a		 jg	 SHORT $LN56@P_LoadSide
  00638	b8 01 00 00 00	 mov	 eax, 1
  0063d	6b c8 03	 imul	 ecx, eax, 3
  00640	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00643	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00647	83 e8 30	 sub	 eax, 48			; 00000030H
  0064a	89 45 80	 mov	 DWORD PTR tv430[ebp], eax
  0064d	e9 a3 00 00 00	 jmp	 $LN61@P_LoadSide
$LN56@P_LoadSide:
  00652	b9 01 00 00 00	 mov	 ecx, 1
  00657	6b d1 03	 imul	 edx, ecx, 3
  0065a	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0065d	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00661	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00664	7c 2e		 jl	 SHORT $LN57@P_LoadSide
  00666	ba 01 00 00 00	 mov	 edx, 1
  0066b	6b c2 03	 imul	 eax, edx, 3
  0066e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00671	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00675	83 fa 66	 cmp	 edx, 102		; 00000066H
  00678	7f 1a		 jg	 SHORT $LN57@P_LoadSide
  0067a	b8 01 00 00 00	 mov	 eax, 1
  0067f	6b c8 03	 imul	 ecx, eax, 3
  00682	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00685	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00689	83 e8 57	 sub	 eax, 87			; 00000057H
  0068c	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv429[ebp], eax
  00692	eb 58		 jmp	 SHORT $LN60@P_LoadSide
$LN57@P_LoadSide:
  00694	b9 01 00 00 00	 mov	 ecx, 1
  00699	6b d1 03	 imul	 edx, ecx, 3
  0069c	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0069f	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  006a3	83 f9 41	 cmp	 ecx, 65			; 00000041H
  006a6	7c 2e		 jl	 SHORT $LN58@P_LoadSide
  006a8	ba 01 00 00 00	 mov	 edx, 1
  006ad	6b c2 03	 imul	 eax, edx, 3
  006b0	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  006b3	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  006b7	83 fa 46	 cmp	 edx, 70			; 00000046H
  006ba	7f 1a		 jg	 SHORT $LN58@P_LoadSide
  006bc	b8 01 00 00 00	 mov	 eax, 1
  006c1	6b c8 03	 imul	 ecx, eax, 3
  006c4	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  006c7	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  006cb	83 e8 37	 sub	 eax, 55			; 00000037H
  006ce	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv428[ebp], eax
  006d4	eb 0a		 jmp	 SHORT $LN59@P_LoadSide
$LN58@P_LoadSide:
  006d6	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv428[ebp], 0
$LN59@P_LoadSide:
  006e0	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv428[ebp]
  006e6	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv429[ebp], ecx
$LN60@P_LoadSide:
  006ec	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv429[ebp]
  006f2	89 55 80	 mov	 DWORD PTR tv430[ebp], edx
$LN61@P_LoadSide:
  006f5	b8 01 00 00 00	 mov	 eax, 1
  006fa	c1 e0 02	 shl	 eax, 2
  006fd	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00700	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00704	83 fa 30	 cmp	 edx, 48			; 00000030H
  00707	7c 31		 jl	 SHORT $LN62@P_LoadSide
  00709	b8 01 00 00 00	 mov	 eax, 1
  0070e	c1 e0 02	 shl	 eax, 2
  00711	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00714	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00718	83 fa 39	 cmp	 edx, 57			; 00000039H
  0071b	7f 1d		 jg	 SHORT $LN62@P_LoadSide
  0071d	b8 01 00 00 00	 mov	 eax, 1
  00722	c1 e0 02	 shl	 eax, 2
  00725	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00728	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0072c	83 ea 30	 sub	 edx, 48			; 00000030H
  0072f	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv473[ebp], edx
  00735	e9 a6 00 00 00	 jmp	 $LN67@P_LoadSide
$LN62@P_LoadSide:
  0073a	b8 01 00 00 00	 mov	 eax, 1
  0073f	c1 e0 02	 shl	 eax, 2
  00742	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00745	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00749	83 fa 61	 cmp	 edx, 97			; 00000061H
  0074c	7c 2e		 jl	 SHORT $LN63@P_LoadSide
  0074e	b8 01 00 00 00	 mov	 eax, 1
  00753	c1 e0 02	 shl	 eax, 2
  00756	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00759	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0075d	83 fa 66	 cmp	 edx, 102		; 00000066H
  00760	7f 1a		 jg	 SHORT $LN63@P_LoadSide
  00762	b8 01 00 00 00	 mov	 eax, 1
  00767	c1 e0 02	 shl	 eax, 2
  0076a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0076d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00771	83 ea 57	 sub	 edx, 87			; 00000057H
  00774	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv472[ebp], edx
  0077a	eb 58		 jmp	 SHORT $LN66@P_LoadSide
$LN63@P_LoadSide:
  0077c	b8 01 00 00 00	 mov	 eax, 1
  00781	c1 e0 02	 shl	 eax, 2
  00784	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00787	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0078b	83 fa 41	 cmp	 edx, 65			; 00000041H
  0078e	7c 2e		 jl	 SHORT $LN64@P_LoadSide
  00790	b8 01 00 00 00	 mov	 eax, 1
  00795	c1 e0 02	 shl	 eax, 2
  00798	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0079b	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0079f	83 fa 46	 cmp	 edx, 70			; 00000046H
  007a2	7f 1a		 jg	 SHORT $LN64@P_LoadSide
  007a4	b8 01 00 00 00	 mov	 eax, 1
  007a9	c1 e0 02	 shl	 eax, 2
  007ac	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  007af	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  007b3	83 ea 37	 sub	 edx, 55			; 00000037H
  007b6	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv471[ebp], edx
  007bc	eb 0a		 jmp	 SHORT $LN65@P_LoadSide
$LN64@P_LoadSide:
  007be	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv471[ebp], 0
$LN65@P_LoadSide:
  007c8	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv471[ebp]
  007ce	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv472[ebp], eax
$LN66@P_LoadSide:
  007d4	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv472[ebp]
  007da	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv473[ebp], ecx
$LN67@P_LoadSide:
  007e0	ba 01 00 00 00	 mov	 edx, 1
  007e5	6b c2 05	 imul	 eax, edx, 5
  007e8	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  007eb	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  007ef	83 fa 30	 cmp	 edx, 48			; 00000030H
  007f2	7c 31		 jl	 SHORT $LN68@P_LoadSide
  007f4	b8 01 00 00 00	 mov	 eax, 1
  007f9	6b c8 05	 imul	 ecx, eax, 5
  007fc	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  007ff	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00803	83 f8 39	 cmp	 eax, 57			; 00000039H
  00806	7f 1d		 jg	 SHORT $LN68@P_LoadSide
  00808	b9 01 00 00 00	 mov	 ecx, 1
  0080d	6b d1 05	 imul	 edx, ecx, 5
  00810	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00813	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00817	83 e9 30	 sub	 ecx, 48			; 00000030H
  0081a	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv516[ebp], ecx
  00820	e9 a6 00 00 00	 jmp	 $LN73@P_LoadSide
$LN68@P_LoadSide:
  00825	ba 01 00 00 00	 mov	 edx, 1
  0082a	6b c2 05	 imul	 eax, edx, 5
  0082d	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00830	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00834	83 fa 61	 cmp	 edx, 97			; 00000061H
  00837	7c 2e		 jl	 SHORT $LN69@P_LoadSide
  00839	b8 01 00 00 00	 mov	 eax, 1
  0083e	6b c8 05	 imul	 ecx, eax, 5
  00841	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00844	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00848	83 f8 66	 cmp	 eax, 102		; 00000066H
  0084b	7f 1a		 jg	 SHORT $LN69@P_LoadSide
  0084d	b9 01 00 00 00	 mov	 ecx, 1
  00852	6b d1 05	 imul	 edx, ecx, 5
  00855	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00858	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0085c	83 e9 57	 sub	 ecx, 87			; 00000057H
  0085f	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv515[ebp], ecx
  00865	eb 58		 jmp	 SHORT $LN72@P_LoadSide
$LN69@P_LoadSide:
  00867	ba 01 00 00 00	 mov	 edx, 1
  0086c	6b c2 05	 imul	 eax, edx, 5
  0086f	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00872	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00876	83 fa 41	 cmp	 edx, 65			; 00000041H
  00879	7c 2e		 jl	 SHORT $LN70@P_LoadSide
  0087b	b8 01 00 00 00	 mov	 eax, 1
  00880	6b c8 05	 imul	 ecx, eax, 5
  00883	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00886	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0088a	83 f8 46	 cmp	 eax, 70			; 00000046H
  0088d	7f 1a		 jg	 SHORT $LN70@P_LoadSide
  0088f	b9 01 00 00 00	 mov	 ecx, 1
  00894	6b d1 05	 imul	 edx, ecx, 5
  00897	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0089a	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0089e	83 e9 37	 sub	 ecx, 55			; 00000037H
  008a1	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv514[ebp], ecx
  008a7	eb 0a		 jmp	 SHORT $LN71@P_LoadSide
$LN70@P_LoadSide:
  008a9	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv514[ebp], 0
$LN71@P_LoadSide:
  008b3	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv514[ebp]
  008b9	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv515[ebp], edx
$LN72@P_LoadSide:
  008bf	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv515[ebp]
  008c5	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv516[ebp], eax
$LN73@P_LoadSide:
  008cb	b9 01 00 00 00	 mov	 ecx, 1
  008d0	6b d1 06	 imul	 edx, ecx, 6
  008d3	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  008d6	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  008da	83 f9 30	 cmp	 ecx, 48			; 00000030H
  008dd	7c 31		 jl	 SHORT $LN74@P_LoadSide
  008df	ba 01 00 00 00	 mov	 edx, 1
  008e4	6b c2 06	 imul	 eax, edx, 6
  008e7	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  008ea	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  008ee	83 fa 39	 cmp	 edx, 57			; 00000039H
  008f1	7f 1d		 jg	 SHORT $LN74@P_LoadSide
  008f3	b8 01 00 00 00	 mov	 eax, 1
  008f8	6b c8 06	 imul	 ecx, eax, 6
  008fb	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  008fe	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00902	83 e8 30	 sub	 eax, 48			; 00000030H
  00905	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv559[ebp], eax
  0090b	e9 a6 00 00 00	 jmp	 $LN79@P_LoadSide
$LN74@P_LoadSide:
  00910	b9 01 00 00 00	 mov	 ecx, 1
  00915	6b d1 06	 imul	 edx, ecx, 6
  00918	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0091b	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0091f	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00922	7c 2e		 jl	 SHORT $LN75@P_LoadSide
  00924	ba 01 00 00 00	 mov	 edx, 1
  00929	6b c2 06	 imul	 eax, edx, 6
  0092c	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0092f	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00933	83 fa 66	 cmp	 edx, 102		; 00000066H
  00936	7f 1a		 jg	 SHORT $LN75@P_LoadSide
  00938	b8 01 00 00 00	 mov	 eax, 1
  0093d	6b c8 06	 imul	 ecx, eax, 6
  00940	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00943	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00947	83 e8 57	 sub	 eax, 87			; 00000057H
  0094a	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv558[ebp], eax
  00950	eb 58		 jmp	 SHORT $LN78@P_LoadSide
$LN75@P_LoadSide:
  00952	b9 01 00 00 00	 mov	 ecx, 1
  00957	6b d1 06	 imul	 edx, ecx, 6
  0095a	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0095d	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00961	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00964	7c 2e		 jl	 SHORT $LN76@P_LoadSide
  00966	ba 01 00 00 00	 mov	 edx, 1
  0096b	6b c2 06	 imul	 eax, edx, 6
  0096e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00971	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00975	83 fa 46	 cmp	 edx, 70			; 00000046H
  00978	7f 1a		 jg	 SHORT $LN76@P_LoadSide
  0097a	b8 01 00 00 00	 mov	 eax, 1
  0097f	6b c8 06	 imul	 ecx, eax, 6
  00982	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00985	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00989	83 e8 37	 sub	 eax, 55			; 00000037H
  0098c	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv557[ebp], eax
  00992	eb 0a		 jmp	 SHORT $LN77@P_LoadSide
$LN76@P_LoadSide:
  00994	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv557[ebp], 0
$LN77@P_LoadSide:
  0099e	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv557[ebp]
  009a4	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv558[ebp], ecx
$LN78@P_LoadSide:
  009aa	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv558[ebp]
  009b0	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv559[ebp], edx
$LN79@P_LoadSide:
  009b6	b8 01 00 00 00	 mov	 eax, 1
  009bb	6b c8 07	 imul	 ecx, eax, 7
  009be	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  009c1	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  009c5	83 f8 61	 cmp	 eax, 97			; 00000061H
  009c8	7c 31		 jl	 SHORT $LN80@P_LoadSide
  009ca	b9 01 00 00 00	 mov	 ecx, 1
  009cf	6b d1 07	 imul	 edx, ecx, 7
  009d2	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  009d5	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  009d9	83 f9 7a	 cmp	 ecx, 122		; 0000007aH
  009dc	7f 1d		 jg	 SHORT $LN80@P_LoadSide
  009de	ba 01 00 00 00	 mov	 edx, 1
  009e3	6b c2 07	 imul	 eax, edx, 7
  009e6	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  009e9	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  009ed	83 ea 61	 sub	 edx, 97			; 00000061H
  009f0	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv596[ebp], edx
  009f6	e9 98 00 00 00	 jmp	 $LN85@P_LoadSide
$LN80@P_LoadSide:
  009fb	b8 01 00 00 00	 mov	 eax, 1
  00a00	6b c8 07	 imul	 ecx, eax, 7
  00a03	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00a06	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00a0a	83 f8 41	 cmp	 eax, 65			; 00000041H
  00a0d	7c 2e		 jl	 SHORT $LN81@P_LoadSide
  00a0f	b9 01 00 00 00	 mov	 ecx, 1
  00a14	6b d1 07	 imul	 edx, ecx, 7
  00a17	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00a1a	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00a1e	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  00a21	7f 1a		 jg	 SHORT $LN81@P_LoadSide
  00a23	ba 01 00 00 00	 mov	 edx, 1
  00a28	6b c2 07	 imul	 eax, edx, 7
  00a2b	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00a2e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00a32	83 ea 41	 sub	 edx, 65			; 00000041H
  00a35	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv595[ebp], edx
  00a3b	eb 4a		 jmp	 SHORT $LN84@P_LoadSide
$LN81@P_LoadSide:
  00a3d	b8 01 00 00 00	 mov	 eax, 1
  00a42	6b c8 07	 imul	 ecx, eax, 7
  00a45	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00a48	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00a4c	83 f8 30	 cmp	 eax, 48			; 00000030H
  00a4f	7c 20		 jl	 SHORT $LN82@P_LoadSide
  00a51	b9 01 00 00 00	 mov	 ecx, 1
  00a56	6b d1 07	 imul	 edx, ecx, 7
  00a59	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00a5c	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00a60	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00a63	7f 0c		 jg	 SHORT $LN82@P_LoadSide
  00a65	c7 85 48 ff ff
	ff 19 00 00 00	 mov	 DWORD PTR tv594[ebp], 25 ; 00000019H
  00a6f	eb 0a		 jmp	 SHORT $LN83@P_LoadSide
$LN82@P_LoadSide:
  00a71	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv594[ebp], 0
$LN83@P_LoadSide:
  00a7b	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv594[ebp]
  00a81	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv595[ebp], edx
$LN84@P_LoadSide:
  00a87	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv595[ebp]
  00a8d	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv596[ebp], eax
$LN85@P_LoadSide:
  00a93	8b 4d 98	 mov	 ecx, DWORD PTR tv346[ebp]
  00a96	c1 e1 04	 shl	 ecx, 4
  00a99	03 4d 8c	 add	 ecx, DWORD PTR tv388[ebp]
  00a9c	8b 55 80	 mov	 edx, DWORD PTR tv430[ebp]
  00a9f	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00aa2	03 ca		 add	 ecx, edx
  00aa4	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv473[ebp]
  00aaa	c1 e0 08	 shl	 eax, 8
  00aad	03 c8		 add	 ecx, eax
  00aaf	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv516[ebp]
  00ab5	c1 e2 14	 shl	 edx, 20			; 00000014H
  00ab8	03 ca		 add	 ecx, edx
  00aba	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv559[ebp]
  00ac0	c1 e0 10	 shl	 eax, 16			; 00000010H
  00ac3	03 c8		 add	 ecx, eax
  00ac5	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv596[ebp]
  00acb	c1 e2 18	 shl	 edx, 24			; 00000018H
  00ace	03 ca		 add	 ecx, edx
  00ad0	8b 45 e8	 mov	 eax, DWORD PTR _sec$4[ebp]
  00ad3	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  00ad9	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1202 : 									(HEX2INT(col[1]) << 4) + (HEX2INT(col[2]) << 0) +
; 1203 : 									(HEX2INT(col[3]) << 12) + (HEX2INT(col[4]) << 8) +
; 1204 : 									(HEX2INT(col[5]) << 20) + (HEX2INT(col[6]) << 16) +
; 1205 : 									(ALPHA2INT(col[7]) << 24);
; 1206 : 							}

  00adc	e9 86 05 00 00	 jmp	 $LN29@P_LoadSide
$LN28@P_LoadSide:

; 1207 : 							else
; 1208 : 							{
; 1209 : 								sec->extra_colormap->rgba =

  00ae1	b8 01 00 00 00	 mov	 eax, 1
  00ae6	c1 e0 00	 shl	 eax, 0
  00ae9	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00aec	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00af0	83 fa 30	 cmp	 edx, 48			; 00000030H
  00af3	7c 2e		 jl	 SHORT $LN86@P_LoadSide
  00af5	b8 01 00 00 00	 mov	 eax, 1
  00afa	c1 e0 00	 shl	 eax, 0
  00afd	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b00	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b04	83 fa 39	 cmp	 edx, 57			; 00000039H
  00b07	7f 1a		 jg	 SHORT $LN86@P_LoadSide
  00b09	b8 01 00 00 00	 mov	 eax, 1
  00b0e	c1 e0 00	 shl	 eax, 0
  00b11	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b14	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b18	83 ea 30	 sub	 edx, 48			; 00000030H
  00b1b	89 55 98	 mov	 DWORD PTR tv641[ebp], edx
  00b1e	e9 91 00 00 00	 jmp	 $LN91@P_LoadSide
$LN86@P_LoadSide:
  00b23	b8 01 00 00 00	 mov	 eax, 1
  00b28	c1 e0 00	 shl	 eax, 0
  00b2b	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b2e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b32	83 fa 61	 cmp	 edx, 97			; 00000061H
  00b35	7c 2b		 jl	 SHORT $LN87@P_LoadSide
  00b37	b8 01 00 00 00	 mov	 eax, 1
  00b3c	c1 e0 00	 shl	 eax, 0
  00b3f	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b42	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b46	83 fa 66	 cmp	 edx, 102		; 00000066H
  00b49	7f 17		 jg	 SHORT $LN87@P_LoadSide
  00b4b	b8 01 00 00 00	 mov	 eax, 1
  00b50	c1 e0 00	 shl	 eax, 0
  00b53	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b56	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b5a	83 ea 57	 sub	 edx, 87			; 00000057H
  00b5d	89 55 94	 mov	 DWORD PTR tv640[ebp], edx
  00b60	eb 4c		 jmp	 SHORT $LN90@P_LoadSide
$LN87@P_LoadSide:
  00b62	b8 01 00 00 00	 mov	 eax, 1
  00b67	c1 e0 00	 shl	 eax, 0
  00b6a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b6d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b71	83 fa 41	 cmp	 edx, 65			; 00000041H
  00b74	7c 2b		 jl	 SHORT $LN88@P_LoadSide
  00b76	b8 01 00 00 00	 mov	 eax, 1
  00b7b	c1 e0 00	 shl	 eax, 0
  00b7e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b81	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b85	83 fa 46	 cmp	 edx, 70			; 00000046H
  00b88	7f 17		 jg	 SHORT $LN88@P_LoadSide
  00b8a	b8 01 00 00 00	 mov	 eax, 1
  00b8f	c1 e0 00	 shl	 eax, 0
  00b92	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00b95	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00b99	83 ea 37	 sub	 edx, 55			; 00000037H
  00b9c	89 55 90	 mov	 DWORD PTR tv639[ebp], edx
  00b9f	eb 07		 jmp	 SHORT $LN89@P_LoadSide
$LN88@P_LoadSide:
  00ba1	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv639[ebp], 0
$LN89@P_LoadSide:
  00ba8	8b 45 90	 mov	 eax, DWORD PTR tv639[ebp]
  00bab	89 45 94	 mov	 DWORD PTR tv640[ebp], eax
$LN90@P_LoadSide:
  00bae	8b 4d 94	 mov	 ecx, DWORD PTR tv640[ebp]
  00bb1	89 4d 98	 mov	 DWORD PTR tv641[ebp], ecx
$LN91@P_LoadSide:
  00bb4	ba 01 00 00 00	 mov	 edx, 1
  00bb9	d1 e2		 shl	 edx, 1
  00bbb	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00bbe	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00bc2	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00bc5	7c 2c		 jl	 SHORT $LN92@P_LoadSide
  00bc7	ba 01 00 00 00	 mov	 edx, 1
  00bcc	d1 e2		 shl	 edx, 1
  00bce	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00bd1	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00bd5	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00bd8	7f 19		 jg	 SHORT $LN92@P_LoadSide
  00bda	ba 01 00 00 00	 mov	 edx, 1
  00bdf	d1 e2		 shl	 edx, 1
  00be1	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00be4	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00be8	83 e9 30	 sub	 ecx, 48			; 00000030H
  00beb	89 4d 8c	 mov	 DWORD PTR tv683[ebp], ecx
  00bee	e9 8b 00 00 00	 jmp	 $LN97@P_LoadSide
$LN92@P_LoadSide:
  00bf3	ba 01 00 00 00	 mov	 edx, 1
  00bf8	d1 e2		 shl	 edx, 1
  00bfa	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00bfd	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c01	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00c04	7c 29		 jl	 SHORT $LN93@P_LoadSide
  00c06	ba 01 00 00 00	 mov	 edx, 1
  00c0b	d1 e2		 shl	 edx, 1
  00c0d	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00c10	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c14	83 f9 66	 cmp	 ecx, 102		; 00000066H
  00c17	7f 16		 jg	 SHORT $LN93@P_LoadSide
  00c19	ba 01 00 00 00	 mov	 edx, 1
  00c1e	d1 e2		 shl	 edx, 1
  00c20	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00c23	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c27	83 e9 57	 sub	 ecx, 87			; 00000057H
  00c2a	89 4d 88	 mov	 DWORD PTR tv682[ebp], ecx
  00c2d	eb 49		 jmp	 SHORT $LN96@P_LoadSide
$LN93@P_LoadSide:
  00c2f	ba 01 00 00 00	 mov	 edx, 1
  00c34	d1 e2		 shl	 edx, 1
  00c36	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00c39	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c3d	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00c40	7c 29		 jl	 SHORT $LN94@P_LoadSide
  00c42	ba 01 00 00 00	 mov	 edx, 1
  00c47	d1 e2		 shl	 edx, 1
  00c49	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00c4c	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c50	83 f9 46	 cmp	 ecx, 70			; 00000046H
  00c53	7f 16		 jg	 SHORT $LN94@P_LoadSide
  00c55	ba 01 00 00 00	 mov	 edx, 1
  00c5a	d1 e2		 shl	 edx, 1
  00c5c	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00c5f	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c63	83 e9 37	 sub	 ecx, 55			; 00000037H
  00c66	89 4d 84	 mov	 DWORD PTR tv681[ebp], ecx
  00c69	eb 07		 jmp	 SHORT $LN95@P_LoadSide
$LN94@P_LoadSide:
  00c6b	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv681[ebp], 0
$LN95@P_LoadSide:
  00c72	8b 55 84	 mov	 edx, DWORD PTR tv681[ebp]
  00c75	89 55 88	 mov	 DWORD PTR tv682[ebp], edx
$LN96@P_LoadSide:
  00c78	8b 45 88	 mov	 eax, DWORD PTR tv682[ebp]
  00c7b	89 45 8c	 mov	 DWORD PTR tv683[ebp], eax
$LN97@P_LoadSide:
  00c7e	b9 01 00 00 00	 mov	 ecx, 1
  00c83	6b d1 03	 imul	 edx, ecx, 3
  00c86	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00c89	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00c8d	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00c90	7c 2e		 jl	 SHORT $LN98@P_LoadSide
  00c92	ba 01 00 00 00	 mov	 edx, 1
  00c97	6b c2 03	 imul	 eax, edx, 3
  00c9a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00c9d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00ca1	83 fa 39	 cmp	 edx, 57			; 00000039H
  00ca4	7f 1a		 jg	 SHORT $LN98@P_LoadSide
  00ca6	b8 01 00 00 00	 mov	 eax, 1
  00cab	6b c8 03	 imul	 ecx, eax, 3
  00cae	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00cb1	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00cb5	83 e8 30	 sub	 eax, 48			; 00000030H
  00cb8	89 45 80	 mov	 DWORD PTR tv725[ebp], eax
  00cbb	e9 a3 00 00 00	 jmp	 $LN103@P_LoadSide
$LN98@P_LoadSide:
  00cc0	b9 01 00 00 00	 mov	 ecx, 1
  00cc5	6b d1 03	 imul	 edx, ecx, 3
  00cc8	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00ccb	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00ccf	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00cd2	7c 2e		 jl	 SHORT $LN99@P_LoadSide
  00cd4	ba 01 00 00 00	 mov	 edx, 1
  00cd9	6b c2 03	 imul	 eax, edx, 3
  00cdc	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00cdf	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00ce3	83 fa 66	 cmp	 edx, 102		; 00000066H
  00ce6	7f 1a		 jg	 SHORT $LN99@P_LoadSide
  00ce8	b8 01 00 00 00	 mov	 eax, 1
  00ced	6b c8 03	 imul	 ecx, eax, 3
  00cf0	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00cf3	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00cf7	83 e8 57	 sub	 eax, 87			; 00000057H
  00cfa	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv724[ebp], eax
  00d00	eb 58		 jmp	 SHORT $LN102@P_LoadSide
$LN99@P_LoadSide:
  00d02	b9 01 00 00 00	 mov	 ecx, 1
  00d07	6b d1 03	 imul	 edx, ecx, 3
  00d0a	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00d0d	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00d11	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00d14	7c 2e		 jl	 SHORT $LN100@P_LoadSide
  00d16	ba 01 00 00 00	 mov	 edx, 1
  00d1b	6b c2 03	 imul	 eax, edx, 3
  00d1e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00d21	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00d25	83 fa 46	 cmp	 edx, 70			; 00000046H
  00d28	7f 1a		 jg	 SHORT $LN100@P_LoadSide
  00d2a	b8 01 00 00 00	 mov	 eax, 1
  00d2f	6b c8 03	 imul	 ecx, eax, 3
  00d32	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00d35	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00d39	83 e8 37	 sub	 eax, 55			; 00000037H
  00d3c	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv723[ebp], eax
  00d42	eb 0a		 jmp	 SHORT $LN101@P_LoadSide
$LN100@P_LoadSide:
  00d44	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv723[ebp], 0
$LN101@P_LoadSide:
  00d4e	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv723[ebp]
  00d54	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv724[ebp], ecx
$LN102@P_LoadSide:
  00d5a	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv724[ebp]
  00d60	89 55 80	 mov	 DWORD PTR tv725[ebp], edx
$LN103@P_LoadSide:
  00d63	b8 01 00 00 00	 mov	 eax, 1
  00d68	c1 e0 02	 shl	 eax, 2
  00d6b	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00d6e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00d72	83 fa 30	 cmp	 edx, 48			; 00000030H
  00d75	7c 31		 jl	 SHORT $LN104@P_LoadSide
  00d77	b8 01 00 00 00	 mov	 eax, 1
  00d7c	c1 e0 02	 shl	 eax, 2
  00d7f	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00d82	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00d86	83 fa 39	 cmp	 edx, 57			; 00000039H
  00d89	7f 1d		 jg	 SHORT $LN104@P_LoadSide
  00d8b	b8 01 00 00 00	 mov	 eax, 1
  00d90	c1 e0 02	 shl	 eax, 2
  00d93	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00d96	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00d9a	83 ea 30	 sub	 edx, 48			; 00000030H
  00d9d	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv768[ebp], edx
  00da3	e9 a6 00 00 00	 jmp	 $LN109@P_LoadSide
$LN104@P_LoadSide:
  00da8	b8 01 00 00 00	 mov	 eax, 1
  00dad	c1 e0 02	 shl	 eax, 2
  00db0	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00db3	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00db7	83 fa 61	 cmp	 edx, 97			; 00000061H
  00dba	7c 2e		 jl	 SHORT $LN105@P_LoadSide
  00dbc	b8 01 00 00 00	 mov	 eax, 1
  00dc1	c1 e0 02	 shl	 eax, 2
  00dc4	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00dc7	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00dcb	83 fa 66	 cmp	 edx, 102		; 00000066H
  00dce	7f 1a		 jg	 SHORT $LN105@P_LoadSide
  00dd0	b8 01 00 00 00	 mov	 eax, 1
  00dd5	c1 e0 02	 shl	 eax, 2
  00dd8	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00ddb	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00ddf	83 ea 57	 sub	 edx, 87			; 00000057H
  00de2	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv767[ebp], edx
  00de8	eb 58		 jmp	 SHORT $LN108@P_LoadSide
$LN105@P_LoadSide:
  00dea	b8 01 00 00 00	 mov	 eax, 1
  00def	c1 e0 02	 shl	 eax, 2
  00df2	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00df5	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00df9	83 fa 41	 cmp	 edx, 65			; 00000041H
  00dfc	7c 2e		 jl	 SHORT $LN106@P_LoadSide
  00dfe	b8 01 00 00 00	 mov	 eax, 1
  00e03	c1 e0 02	 shl	 eax, 2
  00e06	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00e09	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00e0d	83 fa 46	 cmp	 edx, 70			; 00000046H
  00e10	7f 1a		 jg	 SHORT $LN106@P_LoadSide
  00e12	b8 01 00 00 00	 mov	 eax, 1
  00e17	c1 e0 02	 shl	 eax, 2
  00e1a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00e1d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00e21	83 ea 37	 sub	 edx, 55			; 00000037H
  00e24	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv766[ebp], edx
  00e2a	eb 0a		 jmp	 SHORT $LN107@P_LoadSide
$LN106@P_LoadSide:
  00e2c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv766[ebp], 0
$LN107@P_LoadSide:
  00e36	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv766[ebp]
  00e3c	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv767[ebp], eax
$LN108@P_LoadSide:
  00e42	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv767[ebp]
  00e48	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv768[ebp], ecx
$LN109@P_LoadSide:
  00e4e	ba 01 00 00 00	 mov	 edx, 1
  00e53	6b c2 05	 imul	 eax, edx, 5
  00e56	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00e59	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00e5d	83 fa 30	 cmp	 edx, 48			; 00000030H
  00e60	7c 31		 jl	 SHORT $LN110@P_LoadSide
  00e62	b8 01 00 00 00	 mov	 eax, 1
  00e67	6b c8 05	 imul	 ecx, eax, 5
  00e6a	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00e6d	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00e71	83 f8 39	 cmp	 eax, 57			; 00000039H
  00e74	7f 1d		 jg	 SHORT $LN110@P_LoadSide
  00e76	b9 01 00 00 00	 mov	 ecx, 1
  00e7b	6b d1 05	 imul	 edx, ecx, 5
  00e7e	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00e81	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00e85	83 e9 30	 sub	 ecx, 48			; 00000030H
  00e88	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv811[ebp], ecx
  00e8e	e9 a6 00 00 00	 jmp	 $LN115@P_LoadSide
$LN110@P_LoadSide:
  00e93	ba 01 00 00 00	 mov	 edx, 1
  00e98	6b c2 05	 imul	 eax, edx, 5
  00e9b	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00e9e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00ea2	83 fa 61	 cmp	 edx, 97			; 00000061H
  00ea5	7c 2e		 jl	 SHORT $LN111@P_LoadSide
  00ea7	b8 01 00 00 00	 mov	 eax, 1
  00eac	6b c8 05	 imul	 ecx, eax, 5
  00eaf	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00eb2	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00eb6	83 f8 66	 cmp	 eax, 102		; 00000066H
  00eb9	7f 1a		 jg	 SHORT $LN111@P_LoadSide
  00ebb	b9 01 00 00 00	 mov	 ecx, 1
  00ec0	6b d1 05	 imul	 edx, ecx, 5
  00ec3	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00ec6	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00eca	83 e9 57	 sub	 ecx, 87			; 00000057H
  00ecd	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv810[ebp], ecx
  00ed3	eb 58		 jmp	 SHORT $LN114@P_LoadSide
$LN111@P_LoadSide:
  00ed5	ba 01 00 00 00	 mov	 edx, 1
  00eda	6b c2 05	 imul	 eax, edx, 5
  00edd	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00ee0	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00ee4	83 fa 41	 cmp	 edx, 65			; 00000041H
  00ee7	7c 2e		 jl	 SHORT $LN112@P_LoadSide
  00ee9	b8 01 00 00 00	 mov	 eax, 1
  00eee	6b c8 05	 imul	 ecx, eax, 5
  00ef1	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00ef4	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00ef8	83 f8 46	 cmp	 eax, 70			; 00000046H
  00efb	7f 1a		 jg	 SHORT $LN112@P_LoadSide
  00efd	b9 01 00 00 00	 mov	 ecx, 1
  00f02	6b d1 05	 imul	 edx, ecx, 5
  00f05	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00f08	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00f0c	83 e9 37	 sub	 ecx, 55			; 00000037H
  00f0f	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv809[ebp], ecx
  00f15	eb 0a		 jmp	 SHORT $LN113@P_LoadSide
$LN112@P_LoadSide:
  00f17	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv809[ebp], 0
$LN113@P_LoadSide:
  00f21	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv809[ebp]
  00f27	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv810[ebp], edx
$LN114@P_LoadSide:
  00f2d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv810[ebp]
  00f33	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv811[ebp], eax
$LN115@P_LoadSide:
  00f39	b9 01 00 00 00	 mov	 ecx, 1
  00f3e	6b d1 06	 imul	 edx, ecx, 6
  00f41	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00f44	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00f48	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00f4b	7c 31		 jl	 SHORT $LN116@P_LoadSide
  00f4d	ba 01 00 00 00	 mov	 edx, 1
  00f52	6b c2 06	 imul	 eax, edx, 6
  00f55	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00f58	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00f5c	83 fa 39	 cmp	 edx, 57			; 00000039H
  00f5f	7f 1d		 jg	 SHORT $LN116@P_LoadSide
  00f61	b8 01 00 00 00	 mov	 eax, 1
  00f66	6b c8 06	 imul	 ecx, eax, 6
  00f69	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00f6c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00f70	83 e8 30	 sub	 eax, 48			; 00000030H
  00f73	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv854[ebp], eax
  00f79	e9 a6 00 00 00	 jmp	 $LN121@P_LoadSide
$LN116@P_LoadSide:
  00f7e	b9 01 00 00 00	 mov	 ecx, 1
  00f83	6b d1 06	 imul	 edx, ecx, 6
  00f86	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00f89	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00f8d	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00f90	7c 2e		 jl	 SHORT $LN117@P_LoadSide
  00f92	ba 01 00 00 00	 mov	 edx, 1
  00f97	6b c2 06	 imul	 eax, edx, 6
  00f9a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00f9d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00fa1	83 fa 66	 cmp	 edx, 102		; 00000066H
  00fa4	7f 1a		 jg	 SHORT $LN117@P_LoadSide
  00fa6	b8 01 00 00 00	 mov	 eax, 1
  00fab	6b c8 06	 imul	 ecx, eax, 6
  00fae	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00fb1	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00fb5	83 e8 57	 sub	 eax, 87			; 00000057H
  00fb8	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv853[ebp], eax
  00fbe	eb 58		 jmp	 SHORT $LN120@P_LoadSide
$LN117@P_LoadSide:
  00fc0	b9 01 00 00 00	 mov	 ecx, 1
  00fc5	6b d1 06	 imul	 edx, ecx, 6
  00fc8	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  00fcb	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00fcf	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00fd2	7c 2e		 jl	 SHORT $LN118@P_LoadSide
  00fd4	ba 01 00 00 00	 mov	 edx, 1
  00fd9	6b c2 06	 imul	 eax, edx, 6
  00fdc	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  00fdf	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00fe3	83 fa 46	 cmp	 edx, 70			; 00000046H
  00fe6	7f 1a		 jg	 SHORT $LN118@P_LoadSide
  00fe8	b8 01 00 00 00	 mov	 eax, 1
  00fed	6b c8 06	 imul	 ecx, eax, 6
  00ff0	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  00ff3	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00ff7	83 e8 37	 sub	 eax, 55			; 00000037H
  00ffa	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv852[ebp], eax
  01000	eb 0a		 jmp	 SHORT $LN119@P_LoadSide
$LN118@P_LoadSide:
  01002	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv852[ebp], 0
$LN119@P_LoadSide:
  0100c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv852[ebp]
  01012	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv853[ebp], ecx
$LN120@P_LoadSide:
  01018	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv853[ebp]
  0101e	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv854[ebp], edx
$LN121@P_LoadSide:
  01024	8b 45 98	 mov	 eax, DWORD PTR tv641[ebp]
  01027	c1 e0 04	 shl	 eax, 4
  0102a	03 45 8c	 add	 eax, DWORD PTR tv683[ebp]
  0102d	8b 4d 80	 mov	 ecx, DWORD PTR tv725[ebp]
  01030	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  01033	03 c1		 add	 eax, ecx
  01035	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv768[ebp]
  0103b	c1 e2 08	 shl	 edx, 8
  0103e	03 c2		 add	 eax, edx
  01040	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv811[ebp]
  01046	c1 e1 14	 shl	 ecx, 20			; 00000014H
  01049	03 c1		 add	 eax, ecx
  0104b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv854[ebp]
  01051	c1 e2 10	 shl	 edx, 16			; 00000010H
  01054	8d 84 10 00 00
	00 19		 lea	 eax, DWORD PTR [eax+edx+419430400]
  0105b	8b 4d e8	 mov	 ecx, DWORD PTR _sec$4[ebp]
  0105e	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  01064	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN29@P_LoadSide:

; 1210 : 									(HEX2INT(col[1]) << 4) + (HEX2INT(col[2]) << 0) +
; 1211 : 									(HEX2INT(col[3]) << 12) + (HEX2INT(col[4]) << 8) +
; 1212 : 									(HEX2INT(col[5]) << 20) + (HEX2INT(col[6]) << 16) +
; 1213 : 									(25 << 24);
; 1214 : 							}
; 1215 : 						}

  01067	eb 10		 jmp	 SHORT $LN27@P_LoadSide
$LN26@P_LoadSide:

; 1216 : 						else
; 1217 : 						{
; 1218 : 							sec->extra_colormap->rgba = 0;

  01069	8b 45 e8	 mov	 eax, DWORD PTR _sec$4[ebp]
  0106c	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  01072	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN27@P_LoadSide:

; 1219 : 						}
; 1220 : 
; 1221 : 						if (msd->bottomtexture[0] == '#' && msd->bottomtexture[1] && msd->bottomtexture[2] && msd->bottomtexture[3] && msd->bottomtexture[4] && msd->bottomtexture[5] && msd->bottomtexture[6])

  01079	b8 01 00 00 00	 mov	 eax, 1
  0107e	6b c8 00	 imul	 ecx, eax, 0
  01081	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  01084	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  01089	83 f8 23	 cmp	 eax, 35			; 00000023H
  0108c	0f 85 a6 0c 00
	00		 jne	 $LN30@P_LoadSide
  01092	b8 01 00 00 00	 mov	 eax, 1
  01097	c1 e0 00	 shl	 eax, 0
  0109a	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  0109d	0f be 54 01 0c	 movsx	 edx, BYTE PTR [ecx+eax+12]
  010a2	85 d2		 test	 edx, edx
  010a4	0f 84 8e 0c 00
	00		 je	 $LN30@P_LoadSide
  010aa	b8 01 00 00 00	 mov	 eax, 1
  010af	d1 e0		 shl	 eax, 1
  010b1	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  010b4	0f be 54 01 0c	 movsx	 edx, BYTE PTR [ecx+eax+12]
  010b9	85 d2		 test	 edx, edx
  010bb	0f 84 77 0c 00
	00		 je	 $LN30@P_LoadSide
  010c1	b8 01 00 00 00	 mov	 eax, 1
  010c6	6b c8 03	 imul	 ecx, eax, 3
  010c9	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  010cc	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  010d1	85 c0		 test	 eax, eax
  010d3	0f 84 5f 0c 00
	00		 je	 $LN30@P_LoadSide
  010d9	b8 01 00 00 00	 mov	 eax, 1
  010de	c1 e0 02	 shl	 eax, 2
  010e1	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  010e4	0f be 54 01 0c	 movsx	 edx, BYTE PTR [ecx+eax+12]
  010e9	85 d2		 test	 edx, edx
  010eb	0f 84 47 0c 00
	00		 je	 $LN30@P_LoadSide
  010f1	b8 01 00 00 00	 mov	 eax, 1
  010f6	6b c8 05	 imul	 ecx, eax, 5
  010f9	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  010fc	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  01101	85 c0		 test	 eax, eax
  01103	0f 84 2f 0c 00
	00		 je	 $LN30@P_LoadSide
  01109	b8 01 00 00 00	 mov	 eax, 1
  0110e	6b c8 06	 imul	 ecx, eax, 6
  01111	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  01114	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  01119	85 c0		 test	 eax, eax
  0111b	0f 84 17 0c 00
	00		 je	 $LN30@P_LoadSide

; 1222 : 						{
; 1223 : 							col = msd->bottomtexture;

  01121	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  01124	83 c0 0c	 add	 eax, 12			; 0000000cH
  01127	89 45 e0	 mov	 DWORD PTR _col$2[ebp], eax

; 1224 : 
; 1225 : 							if (msd->bottomtexture[7])

  0112a	b8 01 00 00 00	 mov	 eax, 1
  0112f	6b c8 07	 imul	 ecx, eax, 7
  01132	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  01135	0f be 44 0a 0c	 movsx	 eax, BYTE PTR [edx+ecx+12]
  0113a	85 c0		 test	 eax, eax
  0113c	0f 84 6e 06 00
	00		 je	 $LN32@P_LoadSide

; 1226 : 							{
; 1227 : 								sec->extra_colormap->fadergba =

  01142	b8 01 00 00 00	 mov	 eax, 1
  01147	c1 e0 00	 shl	 eax, 0
  0114a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0114d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01151	83 fa 30	 cmp	 edx, 48			; 00000030H
  01154	7c 2e		 jl	 SHORT $LN122@P_LoadSide
  01156	b8 01 00 00 00	 mov	 eax, 1
  0115b	c1 e0 00	 shl	 eax, 0
  0115e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01161	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01165	83 fa 39	 cmp	 edx, 57			; 00000039H
  01168	7f 1a		 jg	 SHORT $LN122@P_LoadSide
  0116a	b8 01 00 00 00	 mov	 eax, 1
  0116f	c1 e0 00	 shl	 eax, 0
  01172	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01175	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01179	83 ea 30	 sub	 edx, 48			; 00000030H
  0117c	89 55 98	 mov	 DWORD PTR tv943[ebp], edx
  0117f	e9 91 00 00 00	 jmp	 $LN127@P_LoadSide
$LN122@P_LoadSide:
  01184	b8 01 00 00 00	 mov	 eax, 1
  01189	c1 e0 00	 shl	 eax, 0
  0118c	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0118f	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01193	83 fa 61	 cmp	 edx, 97			; 00000061H
  01196	7c 2b		 jl	 SHORT $LN123@P_LoadSide
  01198	b8 01 00 00 00	 mov	 eax, 1
  0119d	c1 e0 00	 shl	 eax, 0
  011a0	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  011a3	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  011a7	83 fa 66	 cmp	 edx, 102		; 00000066H
  011aa	7f 17		 jg	 SHORT $LN123@P_LoadSide
  011ac	b8 01 00 00 00	 mov	 eax, 1
  011b1	c1 e0 00	 shl	 eax, 0
  011b4	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  011b7	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  011bb	83 ea 57	 sub	 edx, 87			; 00000057H
  011be	89 55 94	 mov	 DWORD PTR tv942[ebp], edx
  011c1	eb 4c		 jmp	 SHORT $LN126@P_LoadSide
$LN123@P_LoadSide:
  011c3	b8 01 00 00 00	 mov	 eax, 1
  011c8	c1 e0 00	 shl	 eax, 0
  011cb	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  011ce	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  011d2	83 fa 41	 cmp	 edx, 65			; 00000041H
  011d5	7c 2b		 jl	 SHORT $LN124@P_LoadSide
  011d7	b8 01 00 00 00	 mov	 eax, 1
  011dc	c1 e0 00	 shl	 eax, 0
  011df	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  011e2	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  011e6	83 fa 46	 cmp	 edx, 70			; 00000046H
  011e9	7f 17		 jg	 SHORT $LN124@P_LoadSide
  011eb	b8 01 00 00 00	 mov	 eax, 1
  011f0	c1 e0 00	 shl	 eax, 0
  011f3	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  011f6	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  011fa	83 ea 37	 sub	 edx, 55			; 00000037H
  011fd	89 55 90	 mov	 DWORD PTR tv941[ebp], edx
  01200	eb 07		 jmp	 SHORT $LN125@P_LoadSide
$LN124@P_LoadSide:
  01202	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv941[ebp], 0
$LN125@P_LoadSide:
  01209	8b 45 90	 mov	 eax, DWORD PTR tv941[ebp]
  0120c	89 45 94	 mov	 DWORD PTR tv942[ebp], eax
$LN126@P_LoadSide:
  0120f	8b 4d 94	 mov	 ecx, DWORD PTR tv942[ebp]
  01212	89 4d 98	 mov	 DWORD PTR tv943[ebp], ecx
$LN127@P_LoadSide:
  01215	ba 01 00 00 00	 mov	 edx, 1
  0121a	d1 e2		 shl	 edx, 1
  0121c	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0121f	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01223	83 f9 30	 cmp	 ecx, 48			; 00000030H
  01226	7c 2c		 jl	 SHORT $LN128@P_LoadSide
  01228	ba 01 00 00 00	 mov	 edx, 1
  0122d	d1 e2		 shl	 edx, 1
  0122f	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01232	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01236	83 f9 39	 cmp	 ecx, 57			; 00000039H
  01239	7f 19		 jg	 SHORT $LN128@P_LoadSide
  0123b	ba 01 00 00 00	 mov	 edx, 1
  01240	d1 e2		 shl	 edx, 1
  01242	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01245	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01249	83 e9 30	 sub	 ecx, 48			; 00000030H
  0124c	89 4d 8c	 mov	 DWORD PTR tv985[ebp], ecx
  0124f	e9 8b 00 00 00	 jmp	 $LN133@P_LoadSide
$LN128@P_LoadSide:
  01254	ba 01 00 00 00	 mov	 edx, 1
  01259	d1 e2		 shl	 edx, 1
  0125b	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0125e	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01262	83 f9 61	 cmp	 ecx, 97			; 00000061H
  01265	7c 29		 jl	 SHORT $LN129@P_LoadSide
  01267	ba 01 00 00 00	 mov	 edx, 1
  0126c	d1 e2		 shl	 edx, 1
  0126e	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01271	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01275	83 f9 66	 cmp	 ecx, 102		; 00000066H
  01278	7f 16		 jg	 SHORT $LN129@P_LoadSide
  0127a	ba 01 00 00 00	 mov	 edx, 1
  0127f	d1 e2		 shl	 edx, 1
  01281	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01284	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01288	83 e9 57	 sub	 ecx, 87			; 00000057H
  0128b	89 4d 88	 mov	 DWORD PTR tv984[ebp], ecx
  0128e	eb 49		 jmp	 SHORT $LN132@P_LoadSide
$LN129@P_LoadSide:
  01290	ba 01 00 00 00	 mov	 edx, 1
  01295	d1 e2		 shl	 edx, 1
  01297	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0129a	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0129e	83 f9 41	 cmp	 ecx, 65			; 00000041H
  012a1	7c 29		 jl	 SHORT $LN130@P_LoadSide
  012a3	ba 01 00 00 00	 mov	 edx, 1
  012a8	d1 e2		 shl	 edx, 1
  012aa	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  012ad	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  012b1	83 f9 46	 cmp	 ecx, 70			; 00000046H
  012b4	7f 16		 jg	 SHORT $LN130@P_LoadSide
  012b6	ba 01 00 00 00	 mov	 edx, 1
  012bb	d1 e2		 shl	 edx, 1
  012bd	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  012c0	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  012c4	83 e9 37	 sub	 ecx, 55			; 00000037H
  012c7	89 4d 84	 mov	 DWORD PTR tv983[ebp], ecx
  012ca	eb 07		 jmp	 SHORT $LN131@P_LoadSide
$LN130@P_LoadSide:
  012cc	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv983[ebp], 0
$LN131@P_LoadSide:
  012d3	8b 55 84	 mov	 edx, DWORD PTR tv983[ebp]
  012d6	89 55 88	 mov	 DWORD PTR tv984[ebp], edx
$LN132@P_LoadSide:
  012d9	8b 45 88	 mov	 eax, DWORD PTR tv984[ebp]
  012dc	89 45 8c	 mov	 DWORD PTR tv985[ebp], eax
$LN133@P_LoadSide:
  012df	b9 01 00 00 00	 mov	 ecx, 1
  012e4	6b d1 03	 imul	 edx, ecx, 3
  012e7	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  012ea	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  012ee	83 f9 30	 cmp	 ecx, 48			; 00000030H
  012f1	7c 2e		 jl	 SHORT $LN134@P_LoadSide
  012f3	ba 01 00 00 00	 mov	 edx, 1
  012f8	6b c2 03	 imul	 eax, edx, 3
  012fb	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  012fe	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01302	83 fa 39	 cmp	 edx, 57			; 00000039H
  01305	7f 1a		 jg	 SHORT $LN134@P_LoadSide
  01307	b8 01 00 00 00	 mov	 eax, 1
  0130c	6b c8 03	 imul	 ecx, eax, 3
  0130f	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01312	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01316	83 e8 30	 sub	 eax, 48			; 00000030H
  01319	89 45 80	 mov	 DWORD PTR tv1027[ebp], eax
  0131c	e9 a3 00 00 00	 jmp	 $LN139@P_LoadSide
$LN134@P_LoadSide:
  01321	b9 01 00 00 00	 mov	 ecx, 1
  01326	6b d1 03	 imul	 edx, ecx, 3
  01329	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0132c	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01330	83 f9 61	 cmp	 ecx, 97			; 00000061H
  01333	7c 2e		 jl	 SHORT $LN135@P_LoadSide
  01335	ba 01 00 00 00	 mov	 edx, 1
  0133a	6b c2 03	 imul	 eax, edx, 3
  0133d	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01340	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01344	83 fa 66	 cmp	 edx, 102		; 00000066H
  01347	7f 1a		 jg	 SHORT $LN135@P_LoadSide
  01349	b8 01 00 00 00	 mov	 eax, 1
  0134e	6b c8 03	 imul	 ecx, eax, 3
  01351	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01354	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01358	83 e8 57	 sub	 eax, 87			; 00000057H
  0135b	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv1026[ebp], eax
  01361	eb 58		 jmp	 SHORT $LN138@P_LoadSide
$LN135@P_LoadSide:
  01363	b9 01 00 00 00	 mov	 ecx, 1
  01368	6b d1 03	 imul	 edx, ecx, 3
  0136b	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0136e	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01372	83 f9 41	 cmp	 ecx, 65			; 00000041H
  01375	7c 2e		 jl	 SHORT $LN136@P_LoadSide
  01377	ba 01 00 00 00	 mov	 edx, 1
  0137c	6b c2 03	 imul	 eax, edx, 3
  0137f	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01382	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01386	83 fa 46	 cmp	 edx, 70			; 00000046H
  01389	7f 1a		 jg	 SHORT $LN136@P_LoadSide
  0138b	b8 01 00 00 00	 mov	 eax, 1
  01390	6b c8 03	 imul	 ecx, eax, 3
  01393	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01396	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0139a	83 e8 37	 sub	 eax, 55			; 00000037H
  0139d	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv1025[ebp], eax
  013a3	eb 0a		 jmp	 SHORT $LN137@P_LoadSide
$LN136@P_LoadSide:
  013a5	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1025[ebp], 0
$LN137@P_LoadSide:
  013af	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv1025[ebp]
  013b5	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv1026[ebp], ecx
$LN138@P_LoadSide:
  013bb	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv1026[ebp]
  013c1	89 55 80	 mov	 DWORD PTR tv1027[ebp], edx
$LN139@P_LoadSide:
  013c4	b8 01 00 00 00	 mov	 eax, 1
  013c9	c1 e0 02	 shl	 eax, 2
  013cc	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  013cf	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  013d3	83 fa 30	 cmp	 edx, 48			; 00000030H
  013d6	7c 31		 jl	 SHORT $LN140@P_LoadSide
  013d8	b8 01 00 00 00	 mov	 eax, 1
  013dd	c1 e0 02	 shl	 eax, 2
  013e0	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  013e3	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  013e7	83 fa 39	 cmp	 edx, 57			; 00000039H
  013ea	7f 1d		 jg	 SHORT $LN140@P_LoadSide
  013ec	b8 01 00 00 00	 mov	 eax, 1
  013f1	c1 e0 02	 shl	 eax, 2
  013f4	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  013f7	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  013fb	83 ea 30	 sub	 edx, 48			; 00000030H
  013fe	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv1070[ebp], edx
  01404	e9 a6 00 00 00	 jmp	 $LN145@P_LoadSide
$LN140@P_LoadSide:
  01409	b8 01 00 00 00	 mov	 eax, 1
  0140e	c1 e0 02	 shl	 eax, 2
  01411	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01414	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01418	83 fa 61	 cmp	 edx, 97			; 00000061H
  0141b	7c 2e		 jl	 SHORT $LN141@P_LoadSide
  0141d	b8 01 00 00 00	 mov	 eax, 1
  01422	c1 e0 02	 shl	 eax, 2
  01425	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01428	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0142c	83 fa 66	 cmp	 edx, 102		; 00000066H
  0142f	7f 1a		 jg	 SHORT $LN141@P_LoadSide
  01431	b8 01 00 00 00	 mov	 eax, 1
  01436	c1 e0 02	 shl	 eax, 2
  01439	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0143c	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01440	83 ea 57	 sub	 edx, 87			; 00000057H
  01443	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv1069[ebp], edx
  01449	eb 58		 jmp	 SHORT $LN144@P_LoadSide
$LN141@P_LoadSide:
  0144b	b8 01 00 00 00	 mov	 eax, 1
  01450	c1 e0 02	 shl	 eax, 2
  01453	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01456	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0145a	83 fa 41	 cmp	 edx, 65			; 00000041H
  0145d	7c 2e		 jl	 SHORT $LN142@P_LoadSide
  0145f	b8 01 00 00 00	 mov	 eax, 1
  01464	c1 e0 02	 shl	 eax, 2
  01467	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0146a	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0146e	83 fa 46	 cmp	 edx, 70			; 00000046H
  01471	7f 1a		 jg	 SHORT $LN142@P_LoadSide
  01473	b8 01 00 00 00	 mov	 eax, 1
  01478	c1 e0 02	 shl	 eax, 2
  0147b	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0147e	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01482	83 ea 37	 sub	 edx, 55			; 00000037H
  01485	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv1068[ebp], edx
  0148b	eb 0a		 jmp	 SHORT $LN143@P_LoadSide
$LN142@P_LoadSide:
  0148d	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1068[ebp], 0
$LN143@P_LoadSide:
  01497	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv1068[ebp]
  0149d	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv1069[ebp], eax
$LN144@P_LoadSide:
  014a3	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv1069[ebp]
  014a9	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv1070[ebp], ecx
$LN145@P_LoadSide:
  014af	ba 01 00 00 00	 mov	 edx, 1
  014b4	6b c2 05	 imul	 eax, edx, 5
  014b7	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  014ba	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  014be	83 fa 30	 cmp	 edx, 48			; 00000030H
  014c1	7c 31		 jl	 SHORT $LN146@P_LoadSide
  014c3	b8 01 00 00 00	 mov	 eax, 1
  014c8	6b c8 05	 imul	 ecx, eax, 5
  014cb	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  014ce	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  014d2	83 f8 39	 cmp	 eax, 57			; 00000039H
  014d5	7f 1d		 jg	 SHORT $LN146@P_LoadSide
  014d7	b9 01 00 00 00	 mov	 ecx, 1
  014dc	6b d1 05	 imul	 edx, ecx, 5
  014df	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  014e2	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  014e6	83 e9 30	 sub	 ecx, 48			; 00000030H
  014e9	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv1113[ebp], ecx
  014ef	e9 a6 00 00 00	 jmp	 $LN151@P_LoadSide
$LN146@P_LoadSide:
  014f4	ba 01 00 00 00	 mov	 edx, 1
  014f9	6b c2 05	 imul	 eax, edx, 5
  014fc	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  014ff	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01503	83 fa 61	 cmp	 edx, 97			; 00000061H
  01506	7c 2e		 jl	 SHORT $LN147@P_LoadSide
  01508	b8 01 00 00 00	 mov	 eax, 1
  0150d	6b c8 05	 imul	 ecx, eax, 5
  01510	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01513	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01517	83 f8 66	 cmp	 eax, 102		; 00000066H
  0151a	7f 1a		 jg	 SHORT $LN147@P_LoadSide
  0151c	b9 01 00 00 00	 mov	 ecx, 1
  01521	6b d1 05	 imul	 edx, ecx, 5
  01524	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01527	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0152b	83 e9 57	 sub	 ecx, 87			; 00000057H
  0152e	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv1112[ebp], ecx
  01534	eb 58		 jmp	 SHORT $LN150@P_LoadSide
$LN147@P_LoadSide:
  01536	ba 01 00 00 00	 mov	 edx, 1
  0153b	6b c2 05	 imul	 eax, edx, 5
  0153e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01541	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01545	83 fa 41	 cmp	 edx, 65			; 00000041H
  01548	7c 2e		 jl	 SHORT $LN148@P_LoadSide
  0154a	b8 01 00 00 00	 mov	 eax, 1
  0154f	6b c8 05	 imul	 ecx, eax, 5
  01552	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01555	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01559	83 f8 46	 cmp	 eax, 70			; 00000046H
  0155c	7f 1a		 jg	 SHORT $LN148@P_LoadSide
  0155e	b9 01 00 00 00	 mov	 ecx, 1
  01563	6b d1 05	 imul	 edx, ecx, 5
  01566	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01569	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0156d	83 e9 37	 sub	 ecx, 55			; 00000037H
  01570	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1111[ebp], ecx
  01576	eb 0a		 jmp	 SHORT $LN149@P_LoadSide
$LN148@P_LoadSide:
  01578	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1111[ebp], 0
$LN149@P_LoadSide:
  01582	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv1111[ebp]
  01588	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1112[ebp], edx
$LN150@P_LoadSide:
  0158e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv1112[ebp]
  01594	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv1113[ebp], eax
$LN151@P_LoadSide:
  0159a	b9 01 00 00 00	 mov	 ecx, 1
  0159f	6b d1 06	 imul	 edx, ecx, 6
  015a2	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  015a5	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  015a9	83 f9 30	 cmp	 ecx, 48			; 00000030H
  015ac	7c 31		 jl	 SHORT $LN152@P_LoadSide
  015ae	ba 01 00 00 00	 mov	 edx, 1
  015b3	6b c2 06	 imul	 eax, edx, 6
  015b6	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  015b9	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  015bd	83 fa 39	 cmp	 edx, 57			; 00000039H
  015c0	7f 1d		 jg	 SHORT $LN152@P_LoadSide
  015c2	b8 01 00 00 00	 mov	 eax, 1
  015c7	6b c8 06	 imul	 ecx, eax, 6
  015ca	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  015cd	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  015d1	83 e8 30	 sub	 eax, 48			; 00000030H
  015d4	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv1156[ebp], eax
  015da	e9 a6 00 00 00	 jmp	 $LN157@P_LoadSide
$LN152@P_LoadSide:
  015df	b9 01 00 00 00	 mov	 ecx, 1
  015e4	6b d1 06	 imul	 edx, ecx, 6
  015e7	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  015ea	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  015ee	83 f9 61	 cmp	 ecx, 97			; 00000061H
  015f1	7c 2e		 jl	 SHORT $LN153@P_LoadSide
  015f3	ba 01 00 00 00	 mov	 edx, 1
  015f8	6b c2 06	 imul	 eax, edx, 6
  015fb	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  015fe	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01602	83 fa 66	 cmp	 edx, 102		; 00000066H
  01605	7f 1a		 jg	 SHORT $LN153@P_LoadSide
  01607	b8 01 00 00 00	 mov	 eax, 1
  0160c	6b c8 06	 imul	 ecx, eax, 6
  0160f	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01612	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01616	83 e8 57	 sub	 eax, 87			; 00000057H
  01619	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv1155[ebp], eax
  0161f	eb 58		 jmp	 SHORT $LN156@P_LoadSide
$LN153@P_LoadSide:
  01621	b9 01 00 00 00	 mov	 ecx, 1
  01626	6b d1 06	 imul	 edx, ecx, 6
  01629	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0162c	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01630	83 f9 41	 cmp	 ecx, 65			; 00000041H
  01633	7c 2e		 jl	 SHORT $LN154@P_LoadSide
  01635	ba 01 00 00 00	 mov	 edx, 1
  0163a	6b c2 06	 imul	 eax, edx, 6
  0163d	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01640	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01644	83 fa 46	 cmp	 edx, 70			; 00000046H
  01647	7f 1a		 jg	 SHORT $LN154@P_LoadSide
  01649	b8 01 00 00 00	 mov	 eax, 1
  0164e	6b c8 06	 imul	 ecx, eax, 6
  01651	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01654	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01658	83 e8 37	 sub	 eax, 55			; 00000037H
  0165b	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv1154[ebp], eax
  01661	eb 0a		 jmp	 SHORT $LN155@P_LoadSide
$LN154@P_LoadSide:
  01663	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1154[ebp], 0
$LN155@P_LoadSide:
  0166d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv1154[ebp]
  01673	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv1155[ebp], ecx
$LN156@P_LoadSide:
  01679	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv1155[ebp]
  0167f	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv1156[ebp], edx
$LN157@P_LoadSide:
  01685	b8 01 00 00 00	 mov	 eax, 1
  0168a	6b c8 07	 imul	 ecx, eax, 7
  0168d	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01690	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01694	83 f8 61	 cmp	 eax, 97			; 00000061H
  01697	7c 31		 jl	 SHORT $LN158@P_LoadSide
  01699	b9 01 00 00 00	 mov	 ecx, 1
  0169e	6b d1 07	 imul	 edx, ecx, 7
  016a1	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  016a4	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  016a8	83 f9 7a	 cmp	 ecx, 122		; 0000007aH
  016ab	7f 1d		 jg	 SHORT $LN158@P_LoadSide
  016ad	ba 01 00 00 00	 mov	 edx, 1
  016b2	6b c2 07	 imul	 eax, edx, 7
  016b5	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  016b8	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  016bc	83 ea 61	 sub	 edx, 97			; 00000061H
  016bf	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv1193[ebp], edx
  016c5	e9 98 00 00 00	 jmp	 $LN163@P_LoadSide
$LN158@P_LoadSide:
  016ca	b8 01 00 00 00	 mov	 eax, 1
  016cf	6b c8 07	 imul	 ecx, eax, 7
  016d2	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  016d5	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  016d9	83 f8 41	 cmp	 eax, 65			; 00000041H
  016dc	7c 2e		 jl	 SHORT $LN159@P_LoadSide
  016de	b9 01 00 00 00	 mov	 ecx, 1
  016e3	6b d1 07	 imul	 edx, ecx, 7
  016e6	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  016e9	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  016ed	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  016f0	7f 1a		 jg	 SHORT $LN159@P_LoadSide
  016f2	ba 01 00 00 00	 mov	 edx, 1
  016f7	6b c2 07	 imul	 eax, edx, 7
  016fa	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  016fd	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01701	83 ea 41	 sub	 edx, 65			; 00000041H
  01704	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv1192[ebp], edx
  0170a	eb 4a		 jmp	 SHORT $LN162@P_LoadSide
$LN159@P_LoadSide:
  0170c	b8 01 00 00 00	 mov	 eax, 1
  01711	6b c8 07	 imul	 ecx, eax, 7
  01714	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01717	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0171b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0171e	7c 20		 jl	 SHORT $LN160@P_LoadSide
  01720	b9 01 00 00 00	 mov	 ecx, 1
  01725	6b d1 07	 imul	 edx, ecx, 7
  01728	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0172b	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0172f	83 f9 39	 cmp	 ecx, 57			; 00000039H
  01732	7f 0c		 jg	 SHORT $LN160@P_LoadSide
  01734	c7 85 48 ff ff
	ff 19 00 00 00	 mov	 DWORD PTR tv1191[ebp], 25 ; 00000019H
  0173e	eb 0a		 jmp	 SHORT $LN161@P_LoadSide
$LN160@P_LoadSide:
  01740	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1191[ebp], 0
$LN161@P_LoadSide:
  0174a	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv1191[ebp]
  01750	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv1192[ebp], edx
$LN162@P_LoadSide:
  01756	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv1192[ebp]
  0175c	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv1193[ebp], eax
$LN163@P_LoadSide:
  01762	8b 4d 98	 mov	 ecx, DWORD PTR tv943[ebp]
  01765	c1 e1 04	 shl	 ecx, 4
  01768	03 4d 8c	 add	 ecx, DWORD PTR tv985[ebp]
  0176b	8b 55 80	 mov	 edx, DWORD PTR tv1027[ebp]
  0176e	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  01771	03 ca		 add	 ecx, edx
  01773	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1070[ebp]
  01779	c1 e0 08	 shl	 eax, 8
  0177c	03 c8		 add	 ecx, eax
  0177e	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv1113[ebp]
  01784	c1 e2 14	 shl	 edx, 20			; 00000014H
  01787	03 ca		 add	 ecx, edx
  01789	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv1156[ebp]
  0178f	c1 e0 10	 shl	 eax, 16			; 00000010H
  01792	03 c8		 add	 ecx, eax
  01794	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv1193[ebp]
  0179a	c1 e2 18	 shl	 edx, 24			; 00000018H
  0179d	03 ca		 add	 ecx, edx
  0179f	8b 45 e8	 mov	 eax, DWORD PTR _sec$4[ebp]
  017a2	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  017a8	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1228 : 									(HEX2INT(col[1]) << 4) + (HEX2INT(col[2]) << 0) +
; 1229 : 									(HEX2INT(col[3]) << 12) + (HEX2INT(col[4]) << 8) +
; 1230 : 									(HEX2INT(col[5]) << 20) + (HEX2INT(col[6]) << 16) +
; 1231 : 									(ALPHA2INT(col[7]) << 24);
; 1232 : 							}

  017ab	e9 86 05 00 00	 jmp	 $LN33@P_LoadSide
$LN32@P_LoadSide:

; 1233 : 							else
; 1234 : 							{
; 1235 : 								sec->extra_colormap->fadergba =

  017b0	b8 01 00 00 00	 mov	 eax, 1
  017b5	c1 e0 00	 shl	 eax, 0
  017b8	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  017bb	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  017bf	83 fa 30	 cmp	 edx, 48			; 00000030H
  017c2	7c 2e		 jl	 SHORT $LN164@P_LoadSide
  017c4	b8 01 00 00 00	 mov	 eax, 1
  017c9	c1 e0 00	 shl	 eax, 0
  017cc	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  017cf	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  017d3	83 fa 39	 cmp	 edx, 57			; 00000039H
  017d6	7f 1a		 jg	 SHORT $LN164@P_LoadSide
  017d8	b8 01 00 00 00	 mov	 eax, 1
  017dd	c1 e0 00	 shl	 eax, 0
  017e0	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  017e3	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  017e7	83 ea 30	 sub	 edx, 48			; 00000030H
  017ea	89 55 98	 mov	 DWORD PTR tv1238[ebp], edx
  017ed	e9 91 00 00 00	 jmp	 $LN169@P_LoadSide
$LN164@P_LoadSide:
  017f2	b8 01 00 00 00	 mov	 eax, 1
  017f7	c1 e0 00	 shl	 eax, 0
  017fa	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  017fd	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01801	83 fa 61	 cmp	 edx, 97			; 00000061H
  01804	7c 2b		 jl	 SHORT $LN165@P_LoadSide
  01806	b8 01 00 00 00	 mov	 eax, 1
  0180b	c1 e0 00	 shl	 eax, 0
  0180e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01811	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01815	83 fa 66	 cmp	 edx, 102		; 00000066H
  01818	7f 17		 jg	 SHORT $LN165@P_LoadSide
  0181a	b8 01 00 00 00	 mov	 eax, 1
  0181f	c1 e0 00	 shl	 eax, 0
  01822	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01825	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01829	83 ea 57	 sub	 edx, 87			; 00000057H
  0182c	89 55 94	 mov	 DWORD PTR tv1237[ebp], edx
  0182f	eb 4c		 jmp	 SHORT $LN168@P_LoadSide
$LN165@P_LoadSide:
  01831	b8 01 00 00 00	 mov	 eax, 1
  01836	c1 e0 00	 shl	 eax, 0
  01839	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0183c	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01840	83 fa 41	 cmp	 edx, 65			; 00000041H
  01843	7c 2b		 jl	 SHORT $LN166@P_LoadSide
  01845	b8 01 00 00 00	 mov	 eax, 1
  0184a	c1 e0 00	 shl	 eax, 0
  0184d	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01850	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01854	83 fa 46	 cmp	 edx, 70			; 00000046H
  01857	7f 17		 jg	 SHORT $LN166@P_LoadSide
  01859	b8 01 00 00 00	 mov	 eax, 1
  0185e	c1 e0 00	 shl	 eax, 0
  01861	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01864	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01868	83 ea 37	 sub	 edx, 55			; 00000037H
  0186b	89 55 90	 mov	 DWORD PTR tv1236[ebp], edx
  0186e	eb 07		 jmp	 SHORT $LN167@P_LoadSide
$LN166@P_LoadSide:
  01870	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv1236[ebp], 0
$LN167@P_LoadSide:
  01877	8b 45 90	 mov	 eax, DWORD PTR tv1236[ebp]
  0187a	89 45 94	 mov	 DWORD PTR tv1237[ebp], eax
$LN168@P_LoadSide:
  0187d	8b 4d 94	 mov	 ecx, DWORD PTR tv1237[ebp]
  01880	89 4d 98	 mov	 DWORD PTR tv1238[ebp], ecx
$LN169@P_LoadSide:
  01883	ba 01 00 00 00	 mov	 edx, 1
  01888	d1 e2		 shl	 edx, 1
  0188a	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0188d	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01891	83 f9 30	 cmp	 ecx, 48			; 00000030H
  01894	7c 2c		 jl	 SHORT $LN170@P_LoadSide
  01896	ba 01 00 00 00	 mov	 edx, 1
  0189b	d1 e2		 shl	 edx, 1
  0189d	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  018a0	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  018a4	83 f9 39	 cmp	 ecx, 57			; 00000039H
  018a7	7f 19		 jg	 SHORT $LN170@P_LoadSide
  018a9	ba 01 00 00 00	 mov	 edx, 1
  018ae	d1 e2		 shl	 edx, 1
  018b0	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  018b3	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  018b7	83 e9 30	 sub	 ecx, 48			; 00000030H
  018ba	89 4d 8c	 mov	 DWORD PTR tv1280[ebp], ecx
  018bd	e9 8b 00 00 00	 jmp	 $LN175@P_LoadSide
$LN170@P_LoadSide:
  018c2	ba 01 00 00 00	 mov	 edx, 1
  018c7	d1 e2		 shl	 edx, 1
  018c9	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  018cc	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  018d0	83 f9 61	 cmp	 ecx, 97			; 00000061H
  018d3	7c 29		 jl	 SHORT $LN171@P_LoadSide
  018d5	ba 01 00 00 00	 mov	 edx, 1
  018da	d1 e2		 shl	 edx, 1
  018dc	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  018df	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  018e3	83 f9 66	 cmp	 ecx, 102		; 00000066H
  018e6	7f 16		 jg	 SHORT $LN171@P_LoadSide
  018e8	ba 01 00 00 00	 mov	 edx, 1
  018ed	d1 e2		 shl	 edx, 1
  018ef	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  018f2	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  018f6	83 e9 57	 sub	 ecx, 87			; 00000057H
  018f9	89 4d 88	 mov	 DWORD PTR tv1279[ebp], ecx
  018fc	eb 49		 jmp	 SHORT $LN174@P_LoadSide
$LN171@P_LoadSide:
  018fe	ba 01 00 00 00	 mov	 edx, 1
  01903	d1 e2		 shl	 edx, 1
  01905	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01908	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0190c	83 f9 41	 cmp	 ecx, 65			; 00000041H
  0190f	7c 29		 jl	 SHORT $LN172@P_LoadSide
  01911	ba 01 00 00 00	 mov	 edx, 1
  01916	d1 e2		 shl	 edx, 1
  01918	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0191b	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0191f	83 f9 46	 cmp	 ecx, 70			; 00000046H
  01922	7f 16		 jg	 SHORT $LN172@P_LoadSide
  01924	ba 01 00 00 00	 mov	 edx, 1
  01929	d1 e2		 shl	 edx, 1
  0192b	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0192e	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01932	83 e9 37	 sub	 ecx, 55			; 00000037H
  01935	89 4d 84	 mov	 DWORD PTR tv1278[ebp], ecx
  01938	eb 07		 jmp	 SHORT $LN173@P_LoadSide
$LN172@P_LoadSide:
  0193a	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv1278[ebp], 0
$LN173@P_LoadSide:
  01941	8b 55 84	 mov	 edx, DWORD PTR tv1278[ebp]
  01944	89 55 88	 mov	 DWORD PTR tv1279[ebp], edx
$LN174@P_LoadSide:
  01947	8b 45 88	 mov	 eax, DWORD PTR tv1279[ebp]
  0194a	89 45 8c	 mov	 DWORD PTR tv1280[ebp], eax
$LN175@P_LoadSide:
  0194d	b9 01 00 00 00	 mov	 ecx, 1
  01952	6b d1 03	 imul	 edx, ecx, 3
  01955	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01958	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0195c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0195f	7c 2e		 jl	 SHORT $LN176@P_LoadSide
  01961	ba 01 00 00 00	 mov	 edx, 1
  01966	6b c2 03	 imul	 eax, edx, 3
  01969	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  0196c	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01970	83 fa 39	 cmp	 edx, 57			; 00000039H
  01973	7f 1a		 jg	 SHORT $LN176@P_LoadSide
  01975	b8 01 00 00 00	 mov	 eax, 1
  0197a	6b c8 03	 imul	 ecx, eax, 3
  0197d	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01980	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01984	83 e8 30	 sub	 eax, 48			; 00000030H
  01987	89 45 80	 mov	 DWORD PTR tv1322[ebp], eax
  0198a	e9 a3 00 00 00	 jmp	 $LN181@P_LoadSide
$LN176@P_LoadSide:
  0198f	b9 01 00 00 00	 mov	 ecx, 1
  01994	6b d1 03	 imul	 edx, ecx, 3
  01997	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  0199a	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0199e	83 f9 61	 cmp	 ecx, 97			; 00000061H
  019a1	7c 2e		 jl	 SHORT $LN177@P_LoadSide
  019a3	ba 01 00 00 00	 mov	 edx, 1
  019a8	6b c2 03	 imul	 eax, edx, 3
  019ab	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  019ae	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  019b2	83 fa 66	 cmp	 edx, 102		; 00000066H
  019b5	7f 1a		 jg	 SHORT $LN177@P_LoadSide
  019b7	b8 01 00 00 00	 mov	 eax, 1
  019bc	6b c8 03	 imul	 ecx, eax, 3
  019bf	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  019c2	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  019c6	83 e8 57	 sub	 eax, 87			; 00000057H
  019c9	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv1321[ebp], eax
  019cf	eb 58		 jmp	 SHORT $LN180@P_LoadSide
$LN177@P_LoadSide:
  019d1	b9 01 00 00 00	 mov	 ecx, 1
  019d6	6b d1 03	 imul	 edx, ecx, 3
  019d9	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  019dc	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  019e0	83 f9 41	 cmp	 ecx, 65			; 00000041H
  019e3	7c 2e		 jl	 SHORT $LN178@P_LoadSide
  019e5	ba 01 00 00 00	 mov	 edx, 1
  019ea	6b c2 03	 imul	 eax, edx, 3
  019ed	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  019f0	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  019f4	83 fa 46	 cmp	 edx, 70			; 00000046H
  019f7	7f 1a		 jg	 SHORT $LN178@P_LoadSide
  019f9	b8 01 00 00 00	 mov	 eax, 1
  019fe	6b c8 03	 imul	 ecx, eax, 3
  01a01	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01a04	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01a08	83 e8 37	 sub	 eax, 55			; 00000037H
  01a0b	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv1320[ebp], eax
  01a11	eb 0a		 jmp	 SHORT $LN179@P_LoadSide
$LN178@P_LoadSide:
  01a13	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1320[ebp], 0
$LN179@P_LoadSide:
  01a1d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv1320[ebp]
  01a23	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv1321[ebp], ecx
$LN180@P_LoadSide:
  01a29	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv1321[ebp]
  01a2f	89 55 80	 mov	 DWORD PTR tv1322[ebp], edx
$LN181@P_LoadSide:
  01a32	b8 01 00 00 00	 mov	 eax, 1
  01a37	c1 e0 02	 shl	 eax, 2
  01a3a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01a3d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01a41	83 fa 30	 cmp	 edx, 48			; 00000030H
  01a44	7c 31		 jl	 SHORT $LN182@P_LoadSide
  01a46	b8 01 00 00 00	 mov	 eax, 1
  01a4b	c1 e0 02	 shl	 eax, 2
  01a4e	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01a51	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01a55	83 fa 39	 cmp	 edx, 57			; 00000039H
  01a58	7f 1d		 jg	 SHORT $LN182@P_LoadSide
  01a5a	b8 01 00 00 00	 mov	 eax, 1
  01a5f	c1 e0 02	 shl	 eax, 2
  01a62	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01a65	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01a69	83 ea 30	 sub	 edx, 48			; 00000030H
  01a6c	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv1365[ebp], edx
  01a72	e9 a6 00 00 00	 jmp	 $LN187@P_LoadSide
$LN182@P_LoadSide:
  01a77	b8 01 00 00 00	 mov	 eax, 1
  01a7c	c1 e0 02	 shl	 eax, 2
  01a7f	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01a82	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01a86	83 fa 61	 cmp	 edx, 97			; 00000061H
  01a89	7c 2e		 jl	 SHORT $LN183@P_LoadSide
  01a8b	b8 01 00 00 00	 mov	 eax, 1
  01a90	c1 e0 02	 shl	 eax, 2
  01a93	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01a96	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01a9a	83 fa 66	 cmp	 edx, 102		; 00000066H
  01a9d	7f 1a		 jg	 SHORT $LN183@P_LoadSide
  01a9f	b8 01 00 00 00	 mov	 eax, 1
  01aa4	c1 e0 02	 shl	 eax, 2
  01aa7	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01aaa	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01aae	83 ea 57	 sub	 edx, 87			; 00000057H
  01ab1	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv1364[ebp], edx
  01ab7	eb 58		 jmp	 SHORT $LN186@P_LoadSide
$LN183@P_LoadSide:
  01ab9	b8 01 00 00 00	 mov	 eax, 1
  01abe	c1 e0 02	 shl	 eax, 2
  01ac1	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01ac4	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01ac8	83 fa 41	 cmp	 edx, 65			; 00000041H
  01acb	7c 2e		 jl	 SHORT $LN184@P_LoadSide
  01acd	b8 01 00 00 00	 mov	 eax, 1
  01ad2	c1 e0 02	 shl	 eax, 2
  01ad5	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01ad8	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01adc	83 fa 46	 cmp	 edx, 70			; 00000046H
  01adf	7f 1a		 jg	 SHORT $LN184@P_LoadSide
  01ae1	b8 01 00 00 00	 mov	 eax, 1
  01ae6	c1 e0 02	 shl	 eax, 2
  01ae9	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01aec	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01af0	83 ea 37	 sub	 edx, 55			; 00000037H
  01af3	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv1363[ebp], edx
  01af9	eb 0a		 jmp	 SHORT $LN185@P_LoadSide
$LN184@P_LoadSide:
  01afb	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1363[ebp], 0
$LN185@P_LoadSide:
  01b05	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv1363[ebp]
  01b0b	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv1364[ebp], eax
$LN186@P_LoadSide:
  01b11	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv1364[ebp]
  01b17	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv1365[ebp], ecx
$LN187@P_LoadSide:
  01b1d	ba 01 00 00 00	 mov	 edx, 1
  01b22	6b c2 05	 imul	 eax, edx, 5
  01b25	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01b28	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01b2c	83 fa 30	 cmp	 edx, 48			; 00000030H
  01b2f	7c 31		 jl	 SHORT $LN188@P_LoadSide
  01b31	b8 01 00 00 00	 mov	 eax, 1
  01b36	6b c8 05	 imul	 ecx, eax, 5
  01b39	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01b3c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01b40	83 f8 39	 cmp	 eax, 57			; 00000039H
  01b43	7f 1d		 jg	 SHORT $LN188@P_LoadSide
  01b45	b9 01 00 00 00	 mov	 ecx, 1
  01b4a	6b d1 05	 imul	 edx, ecx, 5
  01b4d	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01b50	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01b54	83 e9 30	 sub	 ecx, 48			; 00000030H
  01b57	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv1408[ebp], ecx
  01b5d	e9 a6 00 00 00	 jmp	 $LN193@P_LoadSide
$LN188@P_LoadSide:
  01b62	ba 01 00 00 00	 mov	 edx, 1
  01b67	6b c2 05	 imul	 eax, edx, 5
  01b6a	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01b6d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01b71	83 fa 61	 cmp	 edx, 97			; 00000061H
  01b74	7c 2e		 jl	 SHORT $LN189@P_LoadSide
  01b76	b8 01 00 00 00	 mov	 eax, 1
  01b7b	6b c8 05	 imul	 ecx, eax, 5
  01b7e	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01b81	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01b85	83 f8 66	 cmp	 eax, 102		; 00000066H
  01b88	7f 1a		 jg	 SHORT $LN189@P_LoadSide
  01b8a	b9 01 00 00 00	 mov	 ecx, 1
  01b8f	6b d1 05	 imul	 edx, ecx, 5
  01b92	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01b95	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01b99	83 e9 57	 sub	 ecx, 87			; 00000057H
  01b9c	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv1407[ebp], ecx
  01ba2	eb 58		 jmp	 SHORT $LN192@P_LoadSide
$LN189@P_LoadSide:
  01ba4	ba 01 00 00 00	 mov	 edx, 1
  01ba9	6b c2 05	 imul	 eax, edx, 5
  01bac	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01baf	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01bb3	83 fa 41	 cmp	 edx, 65			; 00000041H
  01bb6	7c 2e		 jl	 SHORT $LN190@P_LoadSide
  01bb8	b8 01 00 00 00	 mov	 eax, 1
  01bbd	6b c8 05	 imul	 ecx, eax, 5
  01bc0	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01bc3	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01bc7	83 f8 46	 cmp	 eax, 70			; 00000046H
  01bca	7f 1a		 jg	 SHORT $LN190@P_LoadSide
  01bcc	b9 01 00 00 00	 mov	 ecx, 1
  01bd1	6b d1 05	 imul	 edx, ecx, 5
  01bd4	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01bd7	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01bdb	83 e9 37	 sub	 ecx, 55			; 00000037H
  01bde	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1406[ebp], ecx
  01be4	eb 0a		 jmp	 SHORT $LN191@P_LoadSide
$LN190@P_LoadSide:
  01be6	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1406[ebp], 0
$LN191@P_LoadSide:
  01bf0	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv1406[ebp]
  01bf6	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1407[ebp], edx
$LN192@P_LoadSide:
  01bfc	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv1407[ebp]
  01c02	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv1408[ebp], eax
$LN193@P_LoadSide:
  01c08	b9 01 00 00 00	 mov	 ecx, 1
  01c0d	6b d1 06	 imul	 edx, ecx, 6
  01c10	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01c13	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01c17	83 f9 30	 cmp	 ecx, 48			; 00000030H
  01c1a	7c 31		 jl	 SHORT $LN194@P_LoadSide
  01c1c	ba 01 00 00 00	 mov	 edx, 1
  01c21	6b c2 06	 imul	 eax, edx, 6
  01c24	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01c27	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01c2b	83 fa 39	 cmp	 edx, 57			; 00000039H
  01c2e	7f 1d		 jg	 SHORT $LN194@P_LoadSide
  01c30	b8 01 00 00 00	 mov	 eax, 1
  01c35	6b c8 06	 imul	 ecx, eax, 6
  01c38	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01c3b	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01c3f	83 e8 30	 sub	 eax, 48			; 00000030H
  01c42	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv1451[ebp], eax
  01c48	e9 a6 00 00 00	 jmp	 $LN199@P_LoadSide
$LN194@P_LoadSide:
  01c4d	b9 01 00 00 00	 mov	 ecx, 1
  01c52	6b d1 06	 imul	 edx, ecx, 6
  01c55	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01c58	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01c5c	83 f9 61	 cmp	 ecx, 97			; 00000061H
  01c5f	7c 2e		 jl	 SHORT $LN195@P_LoadSide
  01c61	ba 01 00 00 00	 mov	 edx, 1
  01c66	6b c2 06	 imul	 eax, edx, 6
  01c69	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01c6c	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01c70	83 fa 66	 cmp	 edx, 102		; 00000066H
  01c73	7f 1a		 jg	 SHORT $LN195@P_LoadSide
  01c75	b8 01 00 00 00	 mov	 eax, 1
  01c7a	6b c8 06	 imul	 ecx, eax, 6
  01c7d	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01c80	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01c84	83 e8 57	 sub	 eax, 87			; 00000057H
  01c87	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv1450[ebp], eax
  01c8d	eb 58		 jmp	 SHORT $LN198@P_LoadSide
$LN195@P_LoadSide:
  01c8f	b9 01 00 00 00	 mov	 ecx, 1
  01c94	6b d1 06	 imul	 edx, ecx, 6
  01c97	8b 45 e0	 mov	 eax, DWORD PTR _col$2[ebp]
  01c9a	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  01c9e	83 f9 41	 cmp	 ecx, 65			; 00000041H
  01ca1	7c 2e		 jl	 SHORT $LN196@P_LoadSide
  01ca3	ba 01 00 00 00	 mov	 edx, 1
  01ca8	6b c2 06	 imul	 eax, edx, 6
  01cab	8b 4d e0	 mov	 ecx, DWORD PTR _col$2[ebp]
  01cae	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01cb2	83 fa 46	 cmp	 edx, 70			; 00000046H
  01cb5	7f 1a		 jg	 SHORT $LN196@P_LoadSide
  01cb7	b8 01 00 00 00	 mov	 eax, 1
  01cbc	6b c8 06	 imul	 ecx, eax, 6
  01cbf	8b 55 e0	 mov	 edx, DWORD PTR _col$2[ebp]
  01cc2	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  01cc6	83 e8 37	 sub	 eax, 55			; 00000037H
  01cc9	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv1449[ebp], eax
  01ccf	eb 0a		 jmp	 SHORT $LN197@P_LoadSide
$LN196@P_LoadSide:
  01cd1	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1449[ebp], 0
$LN197@P_LoadSide:
  01cdb	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv1449[ebp]
  01ce1	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv1450[ebp], ecx
$LN198@P_LoadSide:
  01ce7	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv1450[ebp]
  01ced	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv1451[ebp], edx
$LN199@P_LoadSide:
  01cf3	8b 45 98	 mov	 eax, DWORD PTR tv1238[ebp]
  01cf6	c1 e0 04	 shl	 eax, 4
  01cf9	03 45 8c	 add	 eax, DWORD PTR tv1280[ebp]
  01cfc	8b 4d 80	 mov	 ecx, DWORD PTR tv1322[ebp]
  01cff	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  01d02	03 c1		 add	 eax, ecx
  01d04	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv1365[ebp]
  01d0a	c1 e2 08	 shl	 edx, 8
  01d0d	03 c2		 add	 eax, edx
  01d0f	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  01d15	c1 e1 14	 shl	 ecx, 20			; 00000014H
  01d18	03 c1		 add	 eax, ecx
  01d1a	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv1451[ebp]
  01d20	c1 e2 10	 shl	 edx, 16			; 00000010H
  01d23	8d 84 10 00 00
	00 19		 lea	 eax, DWORD PTR [eax+edx+419430400]
  01d2a	8b 4d e8	 mov	 ecx, DWORD PTR _sec$4[ebp]
  01d2d	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  01d33	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN33@P_LoadSide:

; 1236 : 									(HEX2INT(col[1]) << 4) + (HEX2INT(col[2]) << 0) +
; 1237 : 									(HEX2INT(col[3]) << 12) + (HEX2INT(col[4]) << 8) +
; 1238 : 									(HEX2INT(col[5]) << 20) + (HEX2INT(col[6]) << 16) +
; 1239 : 									(25 << 24);
; 1240 : 							}
; 1241 : #undef ALPHA2INT
; 1242 : #undef HEX2INT
; 1243 : 						}

  01d36	eb 10		 jmp	 SHORT $LN31@P_LoadSide
$LN30@P_LoadSide:

; 1244 : 						else
; 1245 : 						{
; 1246 : 							sec->extra_colormap->fadergba = 0x19000000;

  01d38	8b 45 e8	 mov	 eax, DWORD PTR _sec$4[ebp]
  01d3b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  01d41	c7 41 1c 00 00
	00 19		 mov	 DWORD PTR [ecx+28], 419430400 ; 19000000H
$LN31@P_LoadSide:

; 1247 : 						}
; 1248 : 					}

  01d48	e9 96 00 00 00	 jmp	 $LN39@P_LoadSide
$LN22@P_LoadSide:

; 1249 : 					else
; 1250 : 					{
; 1251 : 						if ((num = R_CheckTextureNumForName(msd->toptexture, i)) == -1)

  01d4d	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01d51	50		 push	 eax
  01d52	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01d55	83 c1 04	 add	 ecx, 4
  01d58	51		 push	 ecx
  01d59	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  01d5e	83 c4 08	 add	 esp, 8
  01d61	89 45 f4	 mov	 DWORD PTR _num$[ebp], eax
  01d64	83 7d f4 ff	 cmp	 DWORD PTR _num$[ebp], -1
  01d68	75 0c		 jne	 SHORT $LN34@P_LoadSide

; 1252 : 							sd->toptexture = 0;

  01d6a	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01d6d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  01d74	eb 09		 jmp	 SHORT $LN35@P_LoadSide
$LN34@P_LoadSide:

; 1253 : 						else
; 1254 : 							sd->toptexture = num;

  01d76	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01d79	8b 4d f4	 mov	 ecx, DWORD PTR _num$[ebp]
  01d7c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN35@P_LoadSide:

; 1255 : 
; 1256 : 						if ((num = R_CheckTextureNumForName(msd->midtexture, i)) == -1)

  01d7f	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01d83	50		 push	 eax
  01d84	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01d87	83 c1 14	 add	 ecx, 20			; 00000014H
  01d8a	51		 push	 ecx
  01d8b	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  01d90	83 c4 08	 add	 esp, 8
  01d93	89 45 f4	 mov	 DWORD PTR _num$[ebp], eax
  01d96	83 7d f4 ff	 cmp	 DWORD PTR _num$[ebp], -1
  01d9a	75 0c		 jne	 SHORT $LN36@P_LoadSide

; 1257 : 							sd->midtexture = 0;

  01d9c	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01d9f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  01da6	eb 09		 jmp	 SHORT $LN37@P_LoadSide
$LN36@P_LoadSide:

; 1258 : 						else
; 1259 : 							sd->midtexture = num;

  01da8	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01dab	8b 4d f4	 mov	 ecx, DWORD PTR _num$[ebp]
  01dae	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN37@P_LoadSide:

; 1260 : 
; 1261 : 						if ((num = R_CheckTextureNumForName(msd->bottomtexture, i)) == -1)

  01db1	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01db5	50		 push	 eax
  01db6	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01db9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01dbc	51		 push	 ecx
  01dbd	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  01dc2	83 c4 08	 add	 esp, 8
  01dc5	89 45 f4	 mov	 DWORD PTR _num$[ebp], eax
  01dc8	83 7d f4 ff	 cmp	 DWORD PTR _num$[ebp], -1
  01dcc	75 0c		 jne	 SHORT $LN38@P_LoadSide

; 1262 : 							sd->bottomtexture = 0;

  01dce	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01dd1	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  01dd8	eb 09		 jmp	 SHORT $LN39@P_LoadSide
$LN38@P_LoadSide:

; 1263 : 						else
; 1264 : 							sd->bottomtexture = num;

  01dda	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01ddd	8b 4d f4	 mov	 ecx, DWORD PTR _num$[ebp]
  01de0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN39@P_LoadSide:

; 1265 : 					}
; 1266 : 					break;

  01de3	e9 de 00 00 00	 jmp	 $LN5@P_LoadSide
$LN11@P_LoadSide:

; 1267 : 				}
; 1268 : #endif
; 1269 : 
; 1270 : 			default: // normal cases
; 1271 : 				if (msd->toptexture[0] == '#')

  01de8	b8 01 00 00 00	 mov	 eax, 1
  01ded	6b c8 00	 imul	 ecx, eax, 0
  01df0	8b 55 f0	 mov	 edx, DWORD PTR _msd$6[ebp]
  01df3	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  01df8	83 f8 23	 cmp	 eax, 35			; 00000023H
  01dfb	75 7b		 jne	 SHORT $LN41@P_LoadSide

; 1272 : 				{
; 1273 : 					char *col = msd->toptexture;

  01dfd	8b 45 f0	 mov	 eax, DWORD PTR _msd$6[ebp]
  01e00	83 c0 04	 add	 eax, 4
  01e03	89 45 dc	 mov	 DWORD PTR _col$1[ebp], eax

; 1274 : 					sd->toptexture = sd->bottomtexture =

  01e06	b8 01 00 00 00	 mov	 eax, 1
  01e0b	c1 e0 00	 shl	 eax, 0
  01e0e	8b 4d dc	 mov	 ecx, DWORD PTR _col$1[ebp]
  01e11	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  01e15	83 ea 30	 sub	 edx, 48			; 00000030H
  01e18	6b c2 64	 imul	 eax, edx, 100
  01e1b	b9 01 00 00 00	 mov	 ecx, 1
  01e20	d1 e1		 shl	 ecx, 1
  01e22	8b 55 dc	 mov	 edx, DWORD PTR _col$1[ebp]
  01e25	0f be 0c 0a	 movsx	 ecx, BYTE PTR [edx+ecx]
  01e29	83 e9 30	 sub	 ecx, 48			; 00000030H
  01e2c	6b d1 0a	 imul	 edx, ecx, 10
  01e2f	03 c2		 add	 eax, edx
  01e31	b9 01 00 00 00	 mov	 ecx, 1
  01e36	6b d1 03	 imul	 edx, ecx, 3
  01e39	8b 4d dc	 mov	 ecx, DWORD PTR _col$1[ebp]
  01e3c	0f be 14 11	 movsx	 edx, BYTE PTR [ecx+edx]
  01e40	8d 44 10 d0	 lea	 eax, DWORD PTR [eax+edx-48]
  01e44	83 c0 01	 add	 eax, 1
  01e47	89 45 98	 mov	 DWORD PTR tv1502[ebp], eax
  01e4a	8b 4d ec	 mov	 ecx, DWORD PTR _sd$5[ebp]
  01e4d	8b 55 98	 mov	 edx, DWORD PTR tv1502[ebp]
  01e50	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  01e53	8b 45 ec	 mov	 eax, DWORD PTR _sd$5[ebp]
  01e56	8b 4d 98	 mov	 ecx, DWORD PTR tv1502[ebp]
  01e59	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1275 : 						((col[1]-'0')*100 + (col[2]-'0')*10 + col[3]-'0') + 1;
; 1276 : 					sd->midtexture = R_TextureNumForName(msd->midtexture, i);

  01e5c	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01e60	50		 push	 eax
  01e61	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01e64	83 c1 14	 add	 ecx, 20			; 00000014H
  01e67	51		 push	 ecx
  01e68	e8 00 00 00 00	 call	 _R_TextureNumForName
  01e6d	83 c4 08	 add	 esp, 8
  01e70	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  01e73	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1277 : 				}

  01e76	eb 4e		 jmp	 SHORT $LN42@P_LoadSide
$LN41@P_LoadSide:

; 1278 : 				else
; 1279 : 				{
; 1280 : 					sd->midtexture = R_TextureNumForName(msd->midtexture, i);

  01e78	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01e7c	50		 push	 eax
  01e7d	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01e80	83 c1 14	 add	 ecx, 20			; 00000014H
  01e83	51		 push	 ecx
  01e84	e8 00 00 00 00	 call	 _R_TextureNumForName
  01e89	83 c4 08	 add	 esp, 8
  01e8c	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  01e8f	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1281 : 					sd->toptexture = R_TextureNumForName(msd->toptexture, i);

  01e92	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01e96	50		 push	 eax
  01e97	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01e9a	83 c1 04	 add	 ecx, 4
  01e9d	51		 push	 ecx
  01e9e	e8 00 00 00 00	 call	 _R_TextureNumForName
  01ea3	83 c4 08	 add	 esp, 8
  01ea6	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  01ea9	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1282 : 					sd->bottomtexture = R_TextureNumForName(msd->bottomtexture, i);

  01eac	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  01eb0	50		 push	 eax
  01eb1	8b 4d f0	 mov	 ecx, DWORD PTR _msd$6[ebp]
  01eb4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01eb7	51		 push	 ecx
  01eb8	e8 00 00 00 00	 call	 _R_TextureNumForName
  01ebd	83 c4 08	 add	 esp, 8
  01ec0	8b 55 ec	 mov	 edx, DWORD PTR _sd$5[ebp]
  01ec3	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN42@P_LoadSide:
$LN5@P_LoadSide:

; 1283 : 				}
; 1284 : 				break;
; 1285 : 		}
; 1286 : 	}

  01ec6	e9 5a e1 ff ff	 jmp	 $LN2@P_LoadSide
$LN3@P_LoadSide:

; 1287 : 
; 1288 : 	Z_Free(data);

  01ecb	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  01ece	50		 push	 eax
  01ecf	e8 00 00 00 00	 call	 _Z_Free
  01ed4	83 c4 04	 add	 esp, 4

; 1289 : }

  01ed7	5f		 pop	 edi
  01ed8	5e		 pop	 esi
  01ed9	5b		 pop	 ebx
  01eda	8b e5		 mov	 esp, ebp
  01edc	5d		 pop	 ebp
  01edd	c3		 ret	 0
_P_LoadSideDefs2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadSideDefs
_TEXT	SEGMENT
_lumpnum$ = 8						; size = 4
_P_LoadSideDefs PROC					; COMDAT

; 1106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1107 : 	numsides = W_LumpLength(lumpnum) / sizeof (mapsidedef_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	33 d2		 xor	 edx, edx
  00017	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  0001c	f7 f1		 div	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _numsides, eax

; 1108 : 	if (numsides <= 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsides, 0
  0002a	77 0d		 ja	 SHORT $LN2@P_LoadSide

; 1109 : 		I_Error("Level has no sidedefs");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@INLLBDAL@Level?5has?5no?5sidedefs@
  00031	e8 00 00 00 00	 call	 _I_Error
  00036	83 c4 04	 add	 esp, 4
$LN2@P_LoadSide:

; 1110 : 	sides = Z_Calloc(numsides * sizeof (*sides), PU_LEVEL, NULL);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 32		 push	 50			; 00000032H
  0003f	6b 05 00 00 00
	00 1c		 imul	 eax, DWORD PTR _numsides, 28
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _Z_CallocAlign
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	a3 00 00 00 00	 mov	 DWORD PTR _sides, eax

; 1111 : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_P_LoadSideDefs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadLineDefs2
_TEXT	SEGMENT
tv67 = -96						; size = 4
tv89 = -96						; size = 4
tv211 = -96						; size = 4
tv247 = -96						; size = 4
tv288 = -96						; size = 4
_k$1 = -28						; size = 4
_j$2 = -24						; size = 4
_z$3 = -20						; size = 4
_numnewsides$4 = -16					; size = 4
_newsides$5 = -12					; size = 4
_ld$ = -8						; size = 4
_i$ = -4						; size = 4
_P_LoadLineDefs2 PROC					; COMDAT

; 1022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1023 : 	size_t i = numlines;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  0000e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 1024 : 	register line_t *ld = lines;

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  00016	89 45 f8	 mov	 DWORD PTR _ld$[ebp], eax

; 1025 : 	for (;i--;ld++)

  00019	eb 09		 jmp	 SHORT $LN4@P_LoadLine
$LN2@P_LoadLine:
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _ld$[ebp]
  0001e	83 c0 4c	 add	 eax, 76			; 0000004cH
  00021	89 45 f8	 mov	 DWORD PTR _ld$[ebp], eax
$LN4@P_LoadLine:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00027	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002d	83 e9 01	 sub	 ecx, 1
  00030	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00033	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00037	0f 84 a5 01 00
	00		 je	 $LN3@P_LoadLine

; 1026 : 	{
; 1027 : 		ld->frontsector = sides[ld->sidenum[0]].sector; //e6y: Can't be -1 here

  0003d	b8 02 00 00 00	 mov	 eax, 2
  00042	6b c8 00	 imul	 ecx, eax, 0
  00045	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  00048	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0004d	6b c8 1c	 imul	 ecx, eax, 28
  00050	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  00058	8b 4c 08 14	 mov	 ecx, DWORD PTR [eax+ecx+20]
  0005c	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 1028 : 		ld->backsector  = ld->sidenum[1] != 0xffff ? sides[ld->sidenum[1]].sector : 0;

  0005f	b8 02 00 00 00	 mov	 eax, 2
  00064	c1 e0 00	 shl	 eax, 0
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  0006a	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  0006f	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00075	74 22		 je	 SHORT $LN31@P_LoadLine
  00077	b8 02 00 00 00	 mov	 eax, 2
  0007c	c1 e0 00	 shl	 eax, 0
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  00082	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  00087	6b c2 1c	 imul	 eax, edx, 28
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  00090	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00094	89 55 a0	 mov	 DWORD PTR tv89[ebp], edx
  00097	eb 07		 jmp	 SHORT $LN32@P_LoadLine
$LN31@P_LoadLine:
  00099	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN32@P_LoadLine:
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _ld$[ebp]
  000a3	8b 4d a0	 mov	 ecx, DWORD PTR tv89[ebp]
  000a6	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 1029 : 
; 1030 : 		// Repeat count for midtexture
; 1031 : 		if ((ld->flags & ML_EFFECT5) && (ld->sidenum[1] != 0xffff))

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _ld$[ebp]
  000ac	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  000b0	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  000b6	0f 84 21 01 00
	00		 je	 $LN20@P_LoadLine
  000bc	b8 02 00 00 00	 mov	 eax, 2
  000c1	c1 e0 00	 shl	 eax, 0
  000c4	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  000c7	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  000cc	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  000d2	0f 84 05 01 00
	00		 je	 $LN20@P_LoadLine

; 1032 : 		{
; 1033 : 			sides[ld->sidenum[0]].repeatcnt = (INT16)(((unsigned)sides[ld->sidenum[0]].textureoffset >> FRACBITS) >> 12);

  000d8	b8 02 00 00 00	 mov	 eax, 2
  000dd	6b c8 00	 imul	 ecx, eax, 0
  000e0	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  000e3	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  000e8	6b c8 1c	 imul	 ecx, eax, 28
  000eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  000f1	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000f4	c1 e8 10	 shr	 eax, 16			; 00000010H
  000f7	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000fa	b9 02 00 00 00	 mov	 ecx, 2
  000ff	6b d1 00	 imul	 edx, ecx, 0
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  00105	0f b7 54 11 16	 movzx	 edx, WORD PTR [ecx+edx+22]
  0010a	6b ca 1c	 imul	 ecx, edx, 28
  0010d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00113	66 89 44 0a 1a	 mov	 WORD PTR [edx+ecx+26], ax

; 1034 : 			sides[ld->sidenum[0]].textureoffset = (((unsigned)sides[ld->sidenum[0]].textureoffset >> FRACBITS) & 2047) << FRACBITS;

  00118	b8 02 00 00 00	 mov	 eax, 2
  0011d	6b c8 00	 imul	 ecx, eax, 0
  00120	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  00123	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00128	6b c8 1c	 imul	 ecx, eax, 28
  0012b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00131	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00134	c1 e8 10	 shr	 eax, 16			; 00000010H
  00137	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0013c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0013f	b9 02 00 00 00	 mov	 ecx, 2
  00144	6b d1 00	 imul	 edx, ecx, 0
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  0014a	0f b7 54 11 16	 movzx	 edx, WORD PTR [ecx+edx+22]
  0014f	6b ca 1c	 imul	 ecx, edx, 28
  00152	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00158	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 1035 : 			sides[ld->sidenum[1]].repeatcnt = (INT16)(((unsigned)sides[ld->sidenum[1]].textureoffset >> FRACBITS) >> 12);

  0015b	b8 02 00 00 00	 mov	 eax, 2
  00160	c1 e0 00	 shl	 eax, 0
  00163	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  00166	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  0016b	6b c2 1c	 imul	 eax, edx, 28
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  00174	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00177	c1 ea 10	 shr	 edx, 16			; 00000010H
  0017a	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  0017d	b8 02 00 00 00	 mov	 eax, 2
  00182	c1 e0 00	 shl	 eax, 0
  00185	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  00188	0f b7 44 01 16	 movzx	 eax, WORD PTR [ecx+eax+22]
  0018d	6b c8 1c	 imul	 ecx, eax, 28
  00190	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  00195	66 89 54 08 1a	 mov	 WORD PTR [eax+ecx+26], dx

; 1036 : 			sides[ld->sidenum[1]].textureoffset = (((unsigned)sides[ld->sidenum[1]].textureoffset >> FRACBITS) & 2047) << FRACBITS;

  0019a	b8 02 00 00 00	 mov	 eax, 2
  0019f	c1 e0 00	 shl	 eax, 0
  001a2	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  001a5	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  001aa	6b c2 1c	 imul	 eax, edx, 28
  001ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  001b3	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001b6	c1 ea 10	 shr	 edx, 16			; 00000010H
  001b9	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  001bf	c1 e2 10	 shl	 edx, 16			; 00000010H
  001c2	b8 02 00 00 00	 mov	 eax, 2
  001c7	c1 e0 00	 shl	 eax, 0
  001ca	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  001cd	0f b7 44 01 16	 movzx	 eax, WORD PTR [ecx+eax+22]
  001d2	6b c8 1c	 imul	 ecx, eax, 28
  001d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  001da	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
$LN20@P_LoadLine:

; 1037 : 		}
; 1038 : 	}

  001dd	e9 39 fe ff ff	 jmp	 $LN2@P_LoadLine
$LN3@P_LoadLine:

; 1039 : 
; 1040 : 	// Optimize sidedefs
; 1041 : 	if (M_CheckParm("-compress"))

  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_09PGPPHINJ@?9compress@
  001e7	e8 00 00 00 00	 call	 _M_CheckParm
  001ec	83 c4 04	 add	 esp, 4
  001ef	85 c0		 test	 eax, eax
  001f1	0f 84 78 02 00
	00		 je	 $LN21@P_LoadLine

; 1042 : 	{
; 1043 : 		side_t *newsides;
; 1044 : 		size_t numnewsides = 0;

  001f7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _numnewsides$4[ebp], 0

; 1045 : 		size_t z;
; 1046 : 
; 1047 : 		for (i = 0; i < numsides; i++)

  001fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00205	eb 09		 jmp	 SHORT $LN7@P_LoadLine
$LN5@P_LoadLine:
  00207	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0020a	83 c0 01	 add	 eax, 1
  0020d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_LoadLine:
  00210	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00213	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsides
  00219	0f 83 a0 01 00
	00		 jae	 $LN6@P_LoadLine

; 1048 : 		{
; 1049 : 			size_t j, k;
; 1050 : 			if (sides[i].sector == NULL)

  0021f	6b 45 fc 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  00229	83 7c 01 14 00	 cmp	 DWORD PTR [ecx+eax+20], 0
  0022e	75 02		 jne	 SHORT $LN22@P_LoadLine

; 1051 : 				continue;

  00230	eb d5		 jmp	 SHORT $LN5@P_LoadLine
$LN22@P_LoadLine:

; 1052 : 
; 1053 : 			for (k = numlines, ld = lines; k--; ld++)

  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  00237	89 45 e4	 mov	 DWORD PTR _k$1[ebp], eax
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00240	89 4d f8	 mov	 DWORD PTR _ld$[ebp], ecx
  00243	eb 09		 jmp	 SHORT $LN10@P_LoadLine
$LN8@P_LoadLine:
  00245	8b 45 f8	 mov	 eax, DWORD PTR _ld$[ebp]
  00248	83 c0 4c	 add	 eax, 76			; 0000004cH
  0024b	89 45 f8	 mov	 DWORD PTR _ld$[ebp], eax
$LN10@P_LoadLine:
  0024e	8b 45 e4	 mov	 eax, DWORD PTR _k$1[ebp]
  00251	89 45 a0	 mov	 DWORD PTR tv211[ebp], eax
  00254	8b 4d e4	 mov	 ecx, DWORD PTR _k$1[ebp]
  00257	83 e9 01	 sub	 ecx, 1
  0025a	89 4d e4	 mov	 DWORD PTR _k$1[ebp], ecx
  0025d	83 7d a0 00	 cmp	 DWORD PTR tv211[ebp], 0
  00261	74 54		 je	 SHORT $LN9@P_LoadLine

; 1054 : 			{
; 1055 : 				if (ld->sidenum[0] == i)

  00263	b8 02 00 00 00	 mov	 eax, 2
  00268	6b c8 00	 imul	 ecx, eax, 0
  0026b	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  0026e	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00273	3b 45 fc	 cmp	 eax, DWORD PTR _i$[ebp]
  00276	75 14		 jne	 SHORT $LN23@P_LoadLine

; 1056 : 					ld->sidenum[0] = (UINT16)numnewsides;

  00278	b8 02 00 00 00	 mov	 eax, 2
  0027d	6b c8 00	 imul	 ecx, eax, 0
  00280	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  00283	66 8b 45 f0	 mov	 ax, WORD PTR _numnewsides$4[ebp]
  00287	66 89 44 0a 16	 mov	 WORD PTR [edx+ecx+22], ax
$LN23@P_LoadLine:

; 1057 : 
; 1058 : 				if (ld->sidenum[1] == i)

  0028c	b8 02 00 00 00	 mov	 eax, 2
  00291	c1 e0 00	 shl	 eax, 0
  00294	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  00297	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  0029c	3b 55 fc	 cmp	 edx, DWORD PTR _i$[ebp]
  0029f	75 14		 jne	 SHORT $LN24@P_LoadLine

; 1059 : 					ld->sidenum[1] = (UINT16)numnewsides;

  002a1	b8 02 00 00 00	 mov	 eax, 2
  002a6	c1 e0 00	 shl	 eax, 0
  002a9	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  002ac	66 8b 55 f0	 mov	 dx, WORD PTR _numnewsides$4[ebp]
  002b0	66 89 54 01 16	 mov	 WORD PTR [ecx+eax+22], dx
$LN24@P_LoadLine:

; 1060 : 			}

  002b5	eb 8e		 jmp	 SHORT $LN8@P_LoadLine
$LN9@P_LoadLine:

; 1061 : 
; 1062 : 			for (j = i+1; j < numsides; j++)

  002b7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002ba	83 c0 01	 add	 eax, 1
  002bd	89 45 e8	 mov	 DWORD PTR _j$2[ebp], eax
  002c0	eb 09		 jmp	 SHORT $LN13@P_LoadLine
$LN11@P_LoadLine:
  002c2	8b 45 e8	 mov	 eax, DWORD PTR _j$2[ebp]
  002c5	83 c0 01	 add	 eax, 1
  002c8	89 45 e8	 mov	 DWORD PTR _j$2[ebp], eax
$LN13@P_LoadLine:
  002cb	8b 45 e8	 mov	 eax, DWORD PTR _j$2[ebp]
  002ce	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsides
  002d4	0f 83 d7 00 00
	00		 jae	 $LN12@P_LoadLine

; 1063 : 			{
; 1064 : 				if (sides[j].sector == NULL)

  002da	6b 45 e8 1c	 imul	 eax, DWORD PTR _j$2[ebp], 28
  002de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  002e4	83 7c 01 14 00	 cmp	 DWORD PTR [ecx+eax+20], 0
  002e9	75 02		 jne	 SHORT $LN25@P_LoadLine

; 1065 : 					continue;

  002eb	eb d5		 jmp	 SHORT $LN11@P_LoadLine
$LN25@P_LoadLine:

; 1066 : 
; 1067 : 				if (!memcmp(&sides[i], &sides[j], sizeof(side_t)))

  002ed	6a 1c		 push	 28			; 0000001cH
  002ef	6b 45 e8 1c	 imul	 eax, DWORD PTR _j$2[ebp], 28
  002f3	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sides
  002f9	50		 push	 eax
  002fa	6b 4d fc 1c	 imul	 ecx, DWORD PTR _i$[ebp], 28
  002fe	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  00304	51		 push	 ecx
  00305	e8 00 00 00 00	 call	 _memcmp
  0030a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030d	85 c0		 test	 eax, eax
  0030f	0f 85 97 00 00
	00		 jne	 $LN26@P_LoadLine

; 1068 : 				{
; 1069 : 					// Find the linedefs that belong to this one
; 1070 : 					for (k = numlines, ld = lines; k--; ld++)

  00315	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  0031a	89 45 e4	 mov	 DWORD PTR _k$1[ebp], eax
  0031d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00323	89 4d f8	 mov	 DWORD PTR _ld$[ebp], ecx
  00326	eb 09		 jmp	 SHORT $LN16@P_LoadLine
$LN14@P_LoadLine:
  00328	8b 45 f8	 mov	 eax, DWORD PTR _ld$[ebp]
  0032b	83 c0 4c	 add	 eax, 76			; 0000004cH
  0032e	89 45 f8	 mov	 DWORD PTR _ld$[ebp], eax
$LN16@P_LoadLine:
  00331	8b 45 e4	 mov	 eax, DWORD PTR _k$1[ebp]
  00334	89 45 a0	 mov	 DWORD PTR tv247[ebp], eax
  00337	8b 4d e4	 mov	 ecx, DWORD PTR _k$1[ebp]
  0033a	83 e9 01	 sub	 ecx, 1
  0033d	89 4d e4	 mov	 DWORD PTR _k$1[ebp], ecx
  00340	83 7d a0 00	 cmp	 DWORD PTR tv247[ebp], 0
  00344	74 54		 je	 SHORT $LN15@P_LoadLine

; 1071 : 					{
; 1072 : 						if (ld->sidenum[0] == j)

  00346	b8 02 00 00 00	 mov	 eax, 2
  0034b	6b c8 00	 imul	 ecx, eax, 0
  0034e	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  00351	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00356	3b 45 e8	 cmp	 eax, DWORD PTR _j$2[ebp]
  00359	75 14		 jne	 SHORT $LN27@P_LoadLine

; 1073 : 							ld->sidenum[0] = (UINT16)numnewsides;

  0035b	b8 02 00 00 00	 mov	 eax, 2
  00360	6b c8 00	 imul	 ecx, eax, 0
  00363	8b 55 f8	 mov	 edx, DWORD PTR _ld$[ebp]
  00366	66 8b 45 f0	 mov	 ax, WORD PTR _numnewsides$4[ebp]
  0036a	66 89 44 0a 16	 mov	 WORD PTR [edx+ecx+22], ax
$LN27@P_LoadLine:

; 1074 : 
; 1075 : 						if (ld->sidenum[1] == j)

  0036f	b8 02 00 00 00	 mov	 eax, 2
  00374	c1 e0 00	 shl	 eax, 0
  00377	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  0037a	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  0037f	3b 55 e8	 cmp	 edx, DWORD PTR _j$2[ebp]
  00382	75 14		 jne	 SHORT $LN28@P_LoadLine

; 1076 : 							ld->sidenum[1] = (UINT16)numnewsides;

  00384	b8 02 00 00 00	 mov	 eax, 2
  00389	c1 e0 00	 shl	 eax, 0
  0038c	8b 4d f8	 mov	 ecx, DWORD PTR _ld$[ebp]
  0038f	66 8b 55 f0	 mov	 dx, WORD PTR _numnewsides$4[ebp]
  00393	66 89 54 01 16	 mov	 WORD PTR [ecx+eax+22], dx
$LN28@P_LoadLine:

; 1077 : 					}

  00398	eb 8e		 jmp	 SHORT $LN14@P_LoadLine
$LN15@P_LoadLine:

; 1078 : 					sides[j].sector = NULL; // Flag for deletion

  0039a	6b 45 e8 1c	 imul	 eax, DWORD PTR _j$2[ebp], 28
  0039e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  003a4	c7 44 01 14 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+20], 0
$LN26@P_LoadLine:

; 1079 : 				}
; 1080 : 			}

  003ac	e9 11 ff ff ff	 jmp	 $LN11@P_LoadLine
$LN12@P_LoadLine:

; 1081 : 			numnewsides++;

  003b1	8b 45 f0	 mov	 eax, DWORD PTR _numnewsides$4[ebp]
  003b4	83 c0 01	 add	 eax, 1
  003b7	89 45 f0	 mov	 DWORD PTR _numnewsides$4[ebp], eax

; 1082 : 		}

  003ba	e9 48 fe ff ff	 jmp	 $LN5@P_LoadLine
$LN6@P_LoadLine:

; 1083 : 
; 1084 : 		// We're loading crap into this block anyhow, so no point in zeroing it out.
; 1085 : 		newsides = Z_Malloc(numnewsides * sizeof(*newsides), PU_LEVEL, NULL);

  003bf	6a 00		 push	 0
  003c1	6a 00		 push	 0
  003c3	6a 32		 push	 50			; 00000032H
  003c5	6b 45 f0 1c	 imul	 eax, DWORD PTR _numnewsides$4[ebp], 28
  003c9	50		 push	 eax
  003ca	e8 00 00 00 00	 call	 _Z_MallocAlign
  003cf	83 c4 10	 add	 esp, 16			; 00000010H
  003d2	89 45 f4	 mov	 DWORD PTR _newsides$5[ebp], eax

; 1086 : 
; 1087 : 		// Copy the sides to their new block of memory.
; 1088 : 		for (i = 0, z = 0; i < numsides; i++)

  003d5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003dc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _z$3[ebp], 0
  003e3	eb 09		 jmp	 SHORT $LN19@P_LoadLine
$LN17@P_LoadLine:
  003e5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003e8	83 c0 01	 add	 eax, 1
  003eb	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN19@P_LoadLine:
  003ee	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003f1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsides
  003f7	73 40		 jae	 SHORT $LN18@P_LoadLine

; 1089 : 		{
; 1090 : 			if (sides[i].sector != NULL)

  003f9	6b 45 fc 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  003fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  00403	83 7c 01 14 00	 cmp	 DWORD PTR [ecx+eax+20], 0
  00408	74 2d		 je	 SHORT $LN29@P_LoadLine

; 1091 : 				M_Memcpy(&newsides[z++], &sides[i], sizeof(side_t));

  0040a	6b 45 ec 1c	 imul	 eax, DWORD PTR _z$3[ebp], 28
  0040e	03 45 f4	 add	 eax, DWORD PTR _newsides$5[ebp]
  00411	89 45 a0	 mov	 DWORD PTR tv288[ebp], eax
  00414	6a 1c		 push	 28			; 0000001cH
  00416	6b 4d fc 1c	 imul	 ecx, DWORD PTR _i$[ebp], 28
  0041a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  00420	51		 push	 ecx
  00421	8b 55 a0	 mov	 edx, DWORD PTR tv288[ebp]
  00424	52		 push	 edx
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0042b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042e	8b 45 ec	 mov	 eax, DWORD PTR _z$3[ebp]
  00431	83 c0 01	 add	 eax, 1
  00434	89 45 ec	 mov	 DWORD PTR _z$3[ebp], eax
$LN29@P_LoadLine:

; 1092 : 		}

  00437	eb ac		 jmp	 SHORT $LN17@P_LoadLine
$LN18@P_LoadLine:

; 1093 : 
; 1094 : 		CONS_Printf("Old sides is %"PRIdS", new sides is %"PRIdS"\n", numsides, numnewsides);

  00439	8b 45 f0	 mov	 eax, DWORD PTR _numnewsides$4[ebp]
  0043c	50		 push	 eax
  0043d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numsides
  00443	51		 push	 ecx
  00444	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MBHMHGNG@Old?5sides?5is?5?$CFIu?0?5new?5sides?5is?5@
  00449	e8 00 00 00 00	 call	 _CONS_Printf
  0044e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1095 : 
; 1096 : 		Z_Free(sides);

  00451	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 _Z_Free
  0045c	83 c4 04	 add	 esp, 4

; 1097 : 		sides = newsides;

  0045f	8b 45 f4	 mov	 eax, DWORD PTR _newsides$5[ebp]
  00462	a3 00 00 00 00	 mov	 DWORD PTR _sides, eax

; 1098 : 		numsides = numnewsides;

  00467	8b 45 f0	 mov	 eax, DWORD PTR _numnewsides$4[ebp]
  0046a	a3 00 00 00 00	 mov	 DWORD PTR _numsides, eax
$LN21@P_LoadLine:

; 1099 : 	}
; 1100 : }

  0046f	5f		 pop	 edi
  00470	5e		 pop	 esi
  00471	5b		 pop	 ebx
  00472	8b e5		 mov	 esp, ebp
  00474	5d		 pop	 ebp
  00475	c3		 ret	 0
_P_LoadLineDefs2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadLineDefs
_TEXT	SEGMENT
tv92 = -96						; size = 4
tv129 = -96						; size = 4
_j$1 = -25						; size = 1
_v2$ = -24						; size = 4
_v1$ = -20						; size = 4
_ld$ = -16						; size = 4
_mld$ = -12						; size = 4
_i$ = -8						; size = 4
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadLineDefs PROC					; COMDAT

; 913  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 914  : 	UINT8 *data;
; 915  : 	size_t i;
; 916  : 	maplinedef_t *mld;
; 917  : 	line_t *ld;
; 918  : 	vertex_t *v1, *v2;
; 919  : 
; 920  : 	numlines = W_LumpLength(lumpnum) / sizeof (maplinedef_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	33 d2		 xor	 edx, edx
  00017	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0001c	f7 f1		 div	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _numlines, eax

; 921  : 	if (numlines <= 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numlines, 0
  0002a	77 0d		 ja	 SHORT $LN8@P_LoadLine

; 922  : 		I_Error("Level has no linedefs");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FKLCMBOF@Level?5has?5no?5linedefs@
  00031	e8 00 00 00 00	 call	 _I_Error
  00036	83 c4 04	 add	 esp, 4
$LN8@P_LoadLine:

; 923  : 	lines = Z_Calloc(numlines * sizeof (*lines), PU_LEVEL, NULL);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 32		 push	 50			; 00000032H
  0003f	6b 05 00 00 00
	00 4c		 imul	 eax, DWORD PTR _numlines, 76
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _Z_CallocAlign
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	a3 00 00 00 00	 mov	 DWORD PTR _lines, eax

; 924  : 	data = W_CacheLumpNum(lumpnum, PU_STATIC);

  00054	6a 01		 push	 1
  00056	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0005f	83 c4 08	 add	 esp, 8
  00062	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 925  : 
; 926  : 	mld = (maplinedef_t *)data;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00068	89 45 f4	 mov	 DWORD PTR _mld$[ebp], eax

; 927  : 	ld = lines;

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  00070	89 45 f0	 mov	 DWORD PTR _ld$[ebp], eax

; 928  : 	for (i = 0; i < numlines; i++, mld++, ld++)

  00073	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007a	eb 1b		 jmp	 SHORT $LN4@P_LoadLine
$LN2@P_LoadLine:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _mld$[ebp]
  00088	83 c1 0e	 add	 ecx, 14			; 0000000eH
  0008b	89 4d f4	 mov	 DWORD PTR _mld$[ebp], ecx
  0008e	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  00091	83 c2 4c	 add	 edx, 76			; 0000004cH
  00094	89 55 f0	 mov	 DWORD PTR _ld$[ebp], edx
$LN4@P_LoadLine:
  00097	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  000a0	0f 83 70 03 00
	00		 jae	 $LN3@P_LoadLine

; 929  : 	{
; 930  : 		ld->flags = SHORT(mld->flags);

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _mld$[ebp]
  000ac	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  000b0	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 931  : 		ld->special = SHORT(mld->special);

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _mld$[ebp]
  000ba	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  000be	66 89 50 12	 mov	 WORD PTR [eax+18], dx

; 932  : 		ld->tag = SHORT(mld->tag);

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR _mld$[ebp]
  000c8	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  000cc	66 89 50 14	 mov	 WORD PTR [eax+20], dx

; 933  : 		v1 = ld->v1 = &vertexes[SHORT(mld->v1)];

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _mld$[ebp]
  000d3	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000d6	6b d1 0c	 imul	 edx, ecx, 12
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _vertexes
  000de	03 c2		 add	 eax, edx
  000e0	89 45 a0	 mov	 DWORD PTR tv92[ebp], eax
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  000e6	8b 55 a0	 mov	 edx, DWORD PTR tv92[ebp]
  000e9	89 11		 mov	 DWORD PTR [ecx], edx
  000eb	8b 45 a0	 mov	 eax, DWORD PTR tv92[ebp]
  000ee	89 45 ec	 mov	 DWORD PTR _v1$[ebp], eax

; 934  : 		v2 = ld->v2 = &vertexes[SHORT(mld->v2)];

  000f1	8b 45 f4	 mov	 eax, DWORD PTR _mld$[ebp]
  000f4	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000f8	6b d1 0c	 imul	 edx, ecx, 12
  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _vertexes
  00100	03 c2		 add	 eax, edx
  00102	89 45 a0	 mov	 DWORD PTR tv129[ebp], eax
  00105	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  00108	8b 55 a0	 mov	 edx, DWORD PTR tv129[ebp]
  0010b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0010e	8b 45 a0	 mov	 eax, DWORD PTR tv129[ebp]
  00111	89 45 e8	 mov	 DWORD PTR _v2$[ebp], eax

; 935  : 		ld->dx = v2->x - v1->x;

  00114	8b 45 e8	 mov	 eax, DWORD PTR _v2$[ebp]
  00117	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  0011a	8b 10		 mov	 edx, DWORD PTR [eax]
  0011c	2b 11		 sub	 edx, DWORD PTR [ecx]
  0011e	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00121	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 936  : 		ld->dy = v2->y - v1->y;

  00124	8b 45 e8	 mov	 eax, DWORD PTR _v2$[ebp]
  00127	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  0012a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0012d	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00130	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00133	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 937  : 
; 938  : #ifdef WALLSPLATS
; 939  : 		ld->splats = NULL;
; 940  : #endif
; 941  : 
; 942  : 		if (!ld->dx)

  00136	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00139	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0013d	75 0c		 jne	 SHORT $LN9@P_LoadLine

; 943  : 			ld->slopetype = ST_VERTICAL;

  0013f	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00142	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
  00149	eb 45		 jmp	 SHORT $LN14@P_LoadLine
$LN9@P_LoadLine:

; 944  : 		else if (!ld->dy)

  0014b	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  0014e	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00152	75 0c		 jne	 SHORT $LN11@P_LoadLine

; 945  : 			ld->slopetype = ST_HORIZONTAL;

  00154	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00157	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  0015e	eb 30		 jmp	 SHORT $LN14@P_LoadLine
$LN11@P_LoadLine:

; 946  : 		else if (FixedDiv(ld->dy, ld->dx) > 0)

  00160	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00163	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00166	51		 push	 ecx
  00167	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  0016a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _FixedDiv
  00173	83 c4 08	 add	 esp, 8
  00176	85 c0		 test	 eax, eax
  00178	7e 0c		 jle	 SHORT $LN13@P_LoadLine

; 947  : 			ld->slopetype = ST_POSITIVE;

  0017a	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  0017d	c7 40 2c 02 00
	00 00		 mov	 DWORD PTR [eax+44], 2
  00184	eb 0a		 jmp	 SHORT $LN14@P_LoadLine
$LN13@P_LoadLine:

; 948  : 		else
; 949  : 			ld->slopetype = ST_NEGATIVE;

  00186	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00189	c7 40 2c 03 00
	00 00		 mov	 DWORD PTR [eax+44], 3
$LN14@P_LoadLine:

; 950  : 
; 951  : 		if (v1->x < v2->x)

  00190	8b 45 ec	 mov	 eax, DWORD PTR _v1$[ebp]
  00193	8b 4d e8	 mov	 ecx, DWORD PTR _v2$[ebp]
  00196	8b 10		 mov	 edx, DWORD PTR [eax]
  00198	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0019a	7d 29		 jge	 SHORT $LN15@P_LoadLine

; 952  : 		{
; 953  : 			ld->bbox[BOXLEFT] = v1->x;

  0019c	b8 04 00 00 00	 mov	 eax, 4
  001a1	d1 e0		 shl	 eax, 1
  001a3	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  001a6	8b 55 ec	 mov	 edx, DWORD PTR _v1$[ebp]
  001a9	8b 12		 mov	 edx, DWORD PTR [edx]
  001ab	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 954  : 			ld->bbox[BOXRIGHT] = v2->x;

  001af	b8 04 00 00 00	 mov	 eax, 4
  001b4	6b c8 03	 imul	 ecx, eax, 3
  001b7	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  001ba	8b 45 e8	 mov	 eax, DWORD PTR _v2$[ebp]
  001bd	8b 00		 mov	 eax, DWORD PTR [eax]
  001bf	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 955  : 		}

  001c3	eb 27		 jmp	 SHORT $LN16@P_LoadLine
$LN15@P_LoadLine:

; 956  : 		else
; 957  : 		{
; 958  : 			ld->bbox[BOXLEFT] = v2->x;

  001c5	b8 04 00 00 00	 mov	 eax, 4
  001ca	d1 e0		 shl	 eax, 1
  001cc	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  001cf	8b 55 e8	 mov	 edx, DWORD PTR _v2$[ebp]
  001d2	8b 12		 mov	 edx, DWORD PTR [edx]
  001d4	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 959  : 			ld->bbox[BOXRIGHT] = v1->x;

  001d8	b8 04 00 00 00	 mov	 eax, 4
  001dd	6b c8 03	 imul	 ecx, eax, 3
  001e0	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  001e3	8b 45 ec	 mov	 eax, DWORD PTR _v1$[ebp]
  001e6	8b 00		 mov	 eax, DWORD PTR [eax]
  001e8	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax
$LN16@P_LoadLine:

; 960  : 		}
; 961  : 
; 962  : 		if (v1->y < v2->y)

  001ec	8b 45 ec	 mov	 eax, DWORD PTR _v1$[ebp]
  001ef	8b 4d e8	 mov	 ecx, DWORD PTR _v2$[ebp]
  001f2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001f5	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001f8	7d 2c		 jge	 SHORT $LN17@P_LoadLine

; 963  : 		{
; 964  : 			ld->bbox[BOXBOTTOM] = v1->y;

  001fa	b8 04 00 00 00	 mov	 eax, 4
  001ff	c1 e0 00	 shl	 eax, 0
  00202	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  00205	8b 55 ec	 mov	 edx, DWORD PTR _v1$[ebp]
  00208	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0020b	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 965  : 			ld->bbox[BOXTOP] = v2->y;

  0020f	b8 04 00 00 00	 mov	 eax, 4
  00214	6b c8 00	 imul	 ecx, eax, 0
  00217	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  0021a	8b 45 e8	 mov	 eax, DWORD PTR _v2$[ebp]
  0021d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00220	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 966  : 		}

  00224	eb 2a		 jmp	 SHORT $LN18@P_LoadLine
$LN17@P_LoadLine:

; 967  : 		else
; 968  : 		{
; 969  : 			ld->bbox[BOXBOTTOM] = v2->y;

  00226	b8 04 00 00 00	 mov	 eax, 4
  0022b	c1 e0 00	 shl	 eax, 0
  0022e	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  00231	8b 55 e8	 mov	 edx, DWORD PTR _v2$[ebp]
  00234	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00237	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 970  : 			ld->bbox[BOXTOP] = v1->y;

  0023b	b8 04 00 00 00	 mov	 eax, 4
  00240	6b c8 00	 imul	 ecx, eax, 0
  00243	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  00246	8b 45 ec	 mov	 eax, DWORD PTR _v1$[ebp]
  00249	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0024c	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax
$LN18@P_LoadLine:

; 971  : 		}
; 972  : 
; 973  : 		ld->sidenum[0] = SHORT(mld->sidenum[0]);

  00250	b8 02 00 00 00	 mov	 eax, 2
  00255	6b c8 00	 imul	 ecx, eax, 0
  00258	ba 02 00 00 00	 mov	 edx, 2
  0025d	6b c2 00	 imul	 eax, edx, 0
  00260	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  00263	8b 75 f4	 mov	 esi, DWORD PTR _mld$[ebp]
  00266	66 8b 4c 0e 0a	 mov	 cx, WORD PTR [esi+ecx+10]
  0026b	66 89 4c 02 16	 mov	 WORD PTR [edx+eax+22], cx

; 974  : 		ld->sidenum[1] = SHORT(mld->sidenum[1]);

  00270	b8 02 00 00 00	 mov	 eax, 2
  00275	c1 e0 00	 shl	 eax, 0
  00278	b9 02 00 00 00	 mov	 ecx, 2
  0027d	c1 e1 00	 shl	 ecx, 0
  00280	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  00283	8b 75 f4	 mov	 esi, DWORD PTR _mld$[ebp]
  00286	66 8b 44 06 0a	 mov	 ax, WORD PTR [esi+eax+10]
  0028b	66 89 44 0a 16	 mov	 WORD PTR [edx+ecx+22], ax

; 975  : 
; 976  : 		{
; 977  : 			// cph 2006/09/30 - fix sidedef errors right away.
; 978  : 			// cph 2002/07/20 - these errors are fatal if not fixed, so apply them
; 979  : 			UINT8 j;
; 980  : 
; 981  : 			for (j=0; j < 2; j++)

  00290	c6 45 e7 00	 mov	 BYTE PTR _j$1[ebp], 0
  00294	eb 08		 jmp	 SHORT $LN7@P_LoadLine
$LN5@P_LoadLine:
  00296	8a 45 e7	 mov	 al, BYTE PTR _j$1[ebp]
  00299	04 01		 add	 al, 1
  0029b	88 45 e7	 mov	 BYTE PTR _j$1[ebp], al
$LN7@P_LoadLine:
  0029e	0f b6 45 e7	 movzx	 eax, BYTE PTR _j$1[ebp]
  002a2	83 f8 02	 cmp	 eax, 2
  002a5	7d 57		 jge	 SHORT $LN6@P_LoadLine

; 982  : 			{
; 983  : 				if (ld->sidenum[j] != 0xffff && ld->sidenum[j] >= (UINT16)numsides)

  002a7	0f b6 45 e7	 movzx	 eax, BYTE PTR _j$1[ebp]
  002ab	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  002ae	0f b7 54 41 16	 movzx	 edx, WORD PTR [ecx+eax*2+22]
  002b3	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  002b9	74 41		 je	 SHORT $LN19@P_LoadLine
  002bb	0f b6 45 e7	 movzx	 eax, BYTE PTR _j$1[ebp]
  002bf	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  002c2	0f b7 54 41 16	 movzx	 edx, WORD PTR [ecx+eax*2+22]
  002c7	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numsides
  002ce	3b d0		 cmp	 edx, eax
  002d0	7c 2a		 jl	 SHORT $LN19@P_LoadLine

; 984  : 				{
; 985  : 					ld->sidenum[j] = 0xffff;

  002d2	0f b6 45 e7	 movzx	 eax, BYTE PTR _j$1[ebp]
  002d6	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  002db	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  002de	66 89 4c 42 16	 mov	 WORD PTR [edx+eax*2+22], cx

; 986  : 					CONS_Printf("P_LoadLineDefs: linedef %"PRIdS" has out-of-range sidedef number\n",numlines-i-1);

  002e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  002e8	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  002eb	83 e8 01	 sub	 eax, 1
  002ee	50		 push	 eax
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@DBCMDBON@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@
  002f4	e8 00 00 00 00	 call	 _CONS_Printf
  002f9	83 c4 08	 add	 esp, 8
$LN19@P_LoadLine:

; 987  : 				}
; 988  : 			}

  002fc	eb 98		 jmp	 SHORT $LN5@P_LoadLine
$LN6@P_LoadLine:

; 989  : 		}
; 990  : 
; 991  : 		ld->frontsector = ld->backsector = NULL;

  002fe	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00301	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
  00308	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  0030b	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 992  : 		ld->validcount = 0;

  00312	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00315	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 993  : 		ld->firsttag = ld->nexttag = -1;

  0031c	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  0031f	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [eax+68], -1
  00326	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  00329	c7 41 40 ff ff
	ff ff		 mov	 DWORD PTR [ecx+64], -1

; 994  : 		// killough 11/98: fix common wad errors (missing sidedefs):
; 995  : 
; 996  : 		if (ld->sidenum[0] == 0xffff)

  00330	b8 02 00 00 00	 mov	 eax, 2
  00335	6b c8 00	 imul	 ecx, eax, 0
  00338	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  0033b	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00340	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00345	75 2b		 jne	 SHORT $LN20@P_LoadLine

; 997  : 		{
; 998  : 			ld->sidenum[0] = 0;  // Substitute dummy sidedef for missing right side

  00347	b8 02 00 00 00	 mov	 eax, 2
  0034c	6b c8 00	 imul	 ecx, eax, 0
  0034f	33 d2		 xor	 edx, edx
  00351	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00354	66 89 54 08 16	 mov	 WORD PTR [eax+ecx+22], dx

; 999  : 			// cph - print a warning about the bug
; 1000 : 			CONS_Printf("P_LoadLineDefs: linedef %"PRIdS" missing first sidedef\n",numlines-i-1);

  00359	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  0035e	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  00361	83 e8 01	 sub	 eax, 1
  00364	50		 push	 eax
  00365	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@IAEFGEEH@P_LoadLineDefs?3?5linedef?5?$CFIu?5mis@
  0036a	e8 00 00 00 00	 call	 _CONS_Printf
  0036f	83 c4 08	 add	 esp, 8
$LN20@P_LoadLine:

; 1001 : 		}
; 1002 : 
; 1003 : 		if ((ld->sidenum[1] == 0xffff) && (ld->flags & ML_TWOSIDED))

  00372	b8 02 00 00 00	 mov	 eax, 2
  00377	c1 e0 00	 shl	 eax, 0
  0037a	8b 4d f0	 mov	 ecx, DWORD PTR _ld$[ebp]
  0037d	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  00382	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00388	75 36		 jne	 SHORT $LN21@P_LoadLine
  0038a	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  0038d	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00391	83 e1 04	 and	 ecx, 4
  00394	74 2a		 je	 SHORT $LN21@P_LoadLine

; 1004 : 		{
; 1005 : 			ld->flags &= ~ML_TWOSIDED;  // Clear 2s flag for missing left side

  00396	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00399	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0039d	83 e1 fb	 and	 ecx, -5			; fffffffbH
  003a0	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  003a3	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 1006 : 			// cph - print a warning about the bug
; 1007 : 			CONS_Printf("P_LoadLineDefs: linedef %"PRIdS" has two-sided flag set, but no second sidedef\n",numlines-i-1);

  003a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  003ac	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  003af	83 e8 01	 sub	 eax, 1
  003b2	50		 push	 eax
  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@MAEEJAN@P_LoadLineDefs?3?5linedef?5?$CFIu?5has@
  003b8	e8 00 00 00 00	 call	 _CONS_Printf
  003bd	83 c4 08	 add	 esp, 8
$LN21@P_LoadLine:

; 1008 : 		}
; 1009 : 
; 1010 : 		if (ld->sidenum[0] != 0xffff && ld->special)

  003c0	b8 02 00 00 00	 mov	 eax, 2
  003c5	6b c8 00	 imul	 ecx, eax, 0
  003c8	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  003cb	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  003d0	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  003d5	74 30		 je	 SHORT $LN22@P_LoadLine
  003d7	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  003da	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  003de	85 c9		 test	 ecx, ecx
  003e0	74 25		 je	 SHORT $LN22@P_LoadLine

; 1011 : 			sides[ld->sidenum[0]].special = ld->special;

  003e2	b8 02 00 00 00	 mov	 eax, 2
  003e7	6b c8 00	 imul	 ecx, eax, 0
  003ea	8b 55 f0	 mov	 edx, DWORD PTR _ld$[ebp]
  003ed	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  003f2	6b c8 1c	 imul	 ecx, eax, 28
  003f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  003fb	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  003fe	66 8b 40 12	 mov	 ax, WORD PTR [eax+18]
  00402	66 89 44 0a 18	 mov	 WORD PTR [edx+ecx+24], ax
$LN22@P_LoadLine:

; 1012 : 
; 1013 : #ifdef POLYOBJECTS
; 1014 : 		ld->polyobj = NULL;

  00407	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  0040a	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 1015 : #endif
; 1016 : 	}

  00411	e9 66 fc ff ff	 jmp	 $LN2@P_LoadLine
$LN3@P_LoadLine:

; 1017 : 
; 1018 : 	Z_Free(data);

  00416	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 _Z_Free
  0041f	83 c4 04	 add	 esp, 4

; 1019 : }

  00422	5f		 pop	 edi
  00423	5e		 pop	 esi
  00424	5b		 pop	 ebx
  00425	8b e5		 mov	 esp, ebp
  00427	5d		 pop	 ebp
  00428	c3		 ret	 0
_P_LoadLineDefs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_SpawnEmblems
_TEXT	SEGMENT
_emblemmobj$ = -8					; size = 4
_i$ = -4						; size = 4
_P_SpawnEmblems PROC					; COMDAT

; 814  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 815  : 	INT32 i;
; 816  : 	mobj_t *emblemmobj;
; 817  : 
; 818  : 	for (i = 0; i < numemblems - 2; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_SpawnEmb
$LN2@P_SpawnEmb:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_SpawnEmb:
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _numemblems
  00020	83 e8 02	 sub	 eax, 2
  00023	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00026	0f 8d 94 01 00
	00		 jge	 $LN3@P_SpawnEmb

; 819  : 	{
; 820  : 		if (emblemlocations[i].level != gamemap)

  0002c	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00030	0f bf 88 08 00
	00 00		 movsx	 ecx, WORD PTR _emblemlocations[eax+8]
  00037	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR _gamemap
  0003e	3b ca		 cmp	 ecx, edx
  00040	74 02		 je	 SHORT $LN5@P_SpawnEmb

; 821  : 			continue;

  00042	eb ce		 jmp	 SHORT $LN2@P_SpawnEmb
$LN5@P_SpawnEmb:

; 822  : 
; 823  : 		emblemmobj = P_SpawnMobj(emblemlocations[i].x<<FRACBITS, emblemlocations[i].y<<FRACBITS,

  00044	6a 36		 push	 54			; 00000036H
  00046	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0004a	0f bf 88 04 00
	00 00		 movsx	 ecx, WORD PTR _emblemlocations[eax+4]
  00051	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00054	51		 push	 ecx
  00055	6b 55 fc 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00059	0f bf 82 02 00
	00 00		 movsx	 eax, WORD PTR _emblemlocations[edx+2]
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	50		 push	 eax
  00064	6b 4d fc 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  00068	0f bf 91 00 00
	00 00		 movsx	 edx, WORD PTR _emblemlocations[ecx]
  0006f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _P_SpawnMobj
  00078	83 c4 10	 add	 esp, 16			; 00000010H
  0007b	89 45 f8	 mov	 DWORD PTR _emblemmobj$[ebp], eax

; 824  : 			emblemlocations[i].z<<FRACBITS, MT_EMBLEM);
; 825  : 
; 826  : 		P_SetMobjStateNF(emblemmobj, emblemmobj->info->spawnstate);

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  00081	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00087	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008a	52		 push	 edx
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _P_SetMobjStateNF
  00094	83 c4 08	 add	 esp, 8

; 827  : 
; 828  : 		emblemmobj->health = i+1;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	83 c0 01	 add	 eax, 1
  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _emblemmobj$[ebp]
  000a0	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax

; 829  : 
; 830  : 		// Absorb the color of the player you belong to.
; 831  : 		// Note: "Everyone" emblems use Sonic's color.
; 832  : 		emblemmobj->flags |= MF_TRANSLATION;

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  000a9	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000ac	81 c9 00 00 00
	04		 or	 ecx, 67108864		; 04000000H
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  000b5	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 833  : 		if (emblemlocations[i].player < numskins)

  000b8	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000bc	0f b6 88 06 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+6]
  000c3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numskins
  000c9	7d 28		 jge	 SHORT $LN6@P_SpawnEmb

; 834  : 			emblemmobj->color = (UINT8)atoi(skins[emblemlocations[i].player].prefcolor);

  000cb	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000cf	0f b6 88 06 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+6]
  000d6	69 d1 ec 00 00
	00		 imul	 edx, ecx, 236
  000dc	81 c2 81 00 00
	00		 add	 edx, OFFSET _skins+129
  000e2	52		 push	 edx
  000e3	e8 00 00 00 00	 call	 _atoi
  000e8	83 c4 04	 add	 esp, 4
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _emblemmobj$[ebp]
  000ee	88 41 68	 mov	 BYTE PTR [ecx+104], al
  000f1	eb 1d		 jmp	 SHORT $LN7@P_SpawnEmb
$LN6@P_SpawnEmb:

; 835  : 		else
; 836  : 			emblemmobj->color = (UINT8)atoi(skins[0].prefcolor);

  000f3	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  000f8	6b c8 00	 imul	 ecx, eax, 0
  000fb	81 c1 81 00 00
	00		 add	 ecx, OFFSET _skins+129
  00101	51		 push	 ecx
  00102	e8 00 00 00 00	 call	 _atoi
  00107	83 c4 04	 add	 esp, 4
  0010a	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  0010d	88 42 68	 mov	 BYTE PTR [edx+104], al
$LN7@P_SpawnEmb:

; 837  : 
; 838  : 		if (emblemlocations[i].collected
; 839  : 			|| (emblemlocations[i].player != players[0].skin && emblemlocations[i].player != 255))

  00110	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00114	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+10]
  0011b	85 c9		 test	 ecx, ecx
  0011d	75 2e		 jne	 SHORT $LN10@P_SpawnEmb
  0011f	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00123	0f b6 88 06 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+6]
  0012a	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  0012f	6b c2 00	 imul	 eax, edx, 0
  00132	3b 88 b8 00 00
	00		 cmp	 ecx, DWORD PTR _players[eax+184]
  00138	74 6f		 je	 SHORT $LN8@P_SpawnEmb
  0013a	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0013e	0f b6 88 06 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+6]
  00145	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0014b	74 5c		 je	 SHORT $LN8@P_SpawnEmb
$LN10@P_SpawnEmb:

; 840  : 		{
; 841  : 			P_UnsetThingPosition(emblemmobj);

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  00156	83 c4 04	 add	 esp, 4

; 842  : 			emblemmobj->flags |= MF_NOCLIP;

  00159	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  0015c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0015f	81 c9 00 10 00
	00		 or	 ecx, 4096		; 00001000H
  00165	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  00168	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 843  : 			emblemmobj->flags &= ~MF_SPECIAL;

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  0016e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00171	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00174	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  00177	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 844  : 			emblemmobj->flags |= MF_NOBLOCKMAP;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  0017d	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00180	83 c9 10	 or	 ecx, 16			; 00000010H
  00183	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  00186	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 845  : 			emblemmobj->frame |= (tr_trans50<<FF_TRANSSHIFT);

  00189	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  0018c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0018f	81 c9 00 00 05
	00		 or	 ecx, 327680		; 00050000H
  00195	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  00198	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 846  : 			P_SetThingPosition(emblemmobj);

  0019b	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _P_SetThingPosition
  001a4	83 c4 04	 add	 esp, 4

; 847  : 		}

  001a7	eb 12		 jmp	 SHORT $LN9@P_SpawnEmb
$LN8@P_SpawnEmb:

; 848  : 		else
; 849  : 			emblemmobj->frame &= ~FF_TRANSMASK;

  001a9	8b 45 f8	 mov	 eax, DWORD PTR _emblemmobj$[ebp]
  001ac	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001af	81 e1 ff ff f0
	ff		 and	 ecx, -983041		; fff0ffffH
  001b5	8b 55 f8	 mov	 edx, DWORD PTR _emblemmobj$[ebp]
  001b8	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$LN9@P_SpawnEmb:

; 850  : 	}

  001bb	e9 52 fe ff ff	 jmp	 $LN2@P_SpawnEmb
$LN3@P_SpawnEmb:

; 851  : }

  001c0	5f		 pop	 edi
  001c1	5e		 pop	 esi
  001c2	5b		 pop	 ebx
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
_P_SpawnEmblems ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadThings
_TEXT	SEGMENT
tv133 = -100						; size = 4
tv175 = -100						; size = 4
tv183 = -100						; size = 4
tv264 = -100						; size = 4
_timeout$1 = -32					; size = 4
_emer3$2 = -28						; size = 4
_emer2$3 = -24						; size = 4
_emer1$4 = -20						; size = 4
_datastart$ = -16					; size = 4
_data$ = -12						; size = 4
_mt$ = -8						; size = 4
_i$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadThings PROC					; COMDAT

; 675  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 676  : 	size_t i;
; 677  : 	mapthing_t *mt;
; 678  : 	UINT8 *data, *datastart;
; 679  : 
; 680  : 	nummapthings = W_LumpLength(lumpnum) / (5 * sizeof (INT16));

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	33 d2		 xor	 edx, edx
  00017	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0001c	f7 f1		 div	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _nummapthings, eax

; 681  : 	mapthings = Z_Calloc(nummapthings * sizeof (*mapthings), PU_LEVEL, NULL);

  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 32		 push	 50			; 00000032H
  00029	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR _nummapthings, 20
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _Z_CallocAlign
  00036	83 c4 10	 add	 esp, 16			; 00000010H
  00039	a3 00 00 00 00	 mov	 DWORD PTR _mapthings, eax

; 682  : 
; 683  : 	tokenbits = 0;

  0003e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tokenbits, 0

; 684  : 	runemeraldmanager = false;

  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _runemeraldmanager, 0

; 685  : 	nummaprings = 0;

  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nummaprings, 0

; 686  : 
; 687  : 	// Spawn axis points first so they are
; 688  : 	// at the front of the list for fast searching.
; 689  : 	data = datastart = W_CacheLumpNum(lumpnum, PU_LEVEL);

  0005c	6a 32		 push	 50			; 00000032H
  0005e	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00067	83 c4 08	 add	 esp, 8
  0006a	89 45 f0	 mov	 DWORD PTR _datastart$[ebp], eax
  0006d	8b 4d f0	 mov	 ecx, DWORD PTR _datastart$[ebp]
  00070	89 4d f4	 mov	 DWORD PTR _data$[ebp], ecx

; 690  : 	mt = mapthings;

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapthings
  00078	89 45 f8	 mov	 DWORD PTR _mt$[ebp], eax

; 691  : 	for (i = 0; i < nummapthings; i++, mt++)

  0007b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00082	eb 12		 jmp	 SHORT $LN4@P_LoadThin
$LN2@P_LoadThin:
  00084	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _mt$[ebp]
  00090	83 c1 14	 add	 ecx, 20			; 00000014H
  00093	89 4d f8	 mov	 DWORD PTR _mt$[ebp], ecx
$LN4@P_LoadThin:
  00096	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00099	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nummapthings
  0009f	0f 83 d3 00 00
	00		 jae	 $LN3@P_LoadThin

; 692  : 	{
; 693  : 		mt->x = READINT16(data);

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _data$[ebp]
  000ab	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000ae	66 89 10	 mov	 WORD PTR [eax], dx
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _data$[ebp]
  000b4	83 c0 02	 add	 eax, 2
  000b7	89 45 f4	 mov	 DWORD PTR _data$[ebp], eax

; 694  : 		mt->y = READINT16(data);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  000bd	8b 4d f4	 mov	 ecx, DWORD PTR _data$[ebp]
  000c0	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000c3	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  000c7	8b 45 f4	 mov	 eax, DWORD PTR _data$[ebp]
  000ca	83 c0 02	 add	 eax, 2
  000cd	89 45 f4	 mov	 DWORD PTR _data$[ebp], eax

; 695  : 		mt->angle = READINT16(data);

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  000d3	8b 4d f4	 mov	 ecx, DWORD PTR _data$[ebp]
  000d6	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000d9	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  000dd	8b 45 f4	 mov	 eax, DWORD PTR _data$[ebp]
  000e0	83 c0 02	 add	 eax, 2
  000e3	89 45 f4	 mov	 DWORD PTR _data$[ebp], eax

; 696  : 		mt->type = READUINT16(data);

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _data$[ebp]
  000ec	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000ef	66 89 50 06	 mov	 WORD PTR [eax+6], dx
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _data$[ebp]
  000f6	83 c0 02	 add	 eax, 2
  000f9	89 45 f4	 mov	 DWORD PTR _data$[ebp], eax

; 697  : 		mt->options = READUINT16(data);

  000fc	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR _data$[ebp]
  00102	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00105	66 89 50 08	 mov	 WORD PTR [eax+8], dx
  00109	8b 45 f4	 mov	 eax, DWORD PTR _data$[ebp]
  0010c	83 c0 02	 add	 eax, 2
  0010f	89 45 f4	 mov	 DWORD PTR _data$[ebp], eax

; 698  : 		mt->extrainfo = (UINT8)(mt->type >> 12);

  00112	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00115	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00119	c1 f9 0c	 sar	 ecx, 12			; 0000000cH
  0011c	8b 55 f8	 mov	 edx, DWORD PTR _mt$[ebp]
  0011f	88 4a 0c	 mov	 BYTE PTR [edx+12], cl

; 699  : 
; 700  : 		mt->type &= 4095;

  00122	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00125	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00129	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _mt$[ebp]
  00132	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 701  : 
; 702  : 		switch (mt->type)

  00136	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00139	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0013d	89 4d 9c	 mov	 DWORD PTR tv133[ebp], ecx
  00140	81 7d 9c a4 06
	00 00		 cmp	 DWORD PTR tv133[ebp], 1700 ; 000006a4H
  00147	74 14		 je	 SHORT $LN19@P_LoadThin
  00149	81 7d 9c a5 06
	00 00		 cmp	 DWORD PTR tv133[ebp], 1701 ; 000006a5H
  00150	74 0b		 je	 SHORT $LN19@P_LoadThin
  00152	81 7d 9c a6 06
	00 00		 cmp	 DWORD PTR tv133[ebp], 1702 ; 000006a6H
  00159	74 02		 je	 SHORT $LN19@P_LoadThin
  0015b	eb 16		 jmp	 SHORT $LN22@P_LoadThin
$LN19@P_LoadThin:

; 703  : 		{
; 704  : 			case 1700: // MT_AXIS
; 705  : 			case 1701: // MT_AXISTRANSFER
; 706  : 			case 1702: // MT_AXISTRANSFERLINE
; 707  : 				mt->mobj = NULL;

  0015d	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00160	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 708  : 				P_SpawnMapThing(mt);

  00167	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _P_SpawnMapThing
  00170	83 c4 04	 add	 esp, 4
$LN22@P_LoadThin:

; 709  : 				break;
; 710  : 			default:
; 711  : 				break;
; 712  : 		}
; 713  : 	}

  00173	e9 0c ff ff ff	 jmp	 $LN2@P_LoadThin
$LN3@P_LoadThin:

; 714  : 	Z_Free(datastart);

  00178	8b 45 f0	 mov	 eax, DWORD PTR _datastart$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _Z_Free
  00181	83 c4 04	 add	 esp, 4

; 715  : 
; 716  : 	mt = mapthings;

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapthings
  00189	89 45 f8	 mov	 DWORD PTR _mt$[ebp], eax

; 717  : 	numhuntemeralds = 0;

  0018c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numhuntemeralds, 0

; 718  : 	for (i = 0; i < nummapthings; i++, mt++)

  00196	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0019d	eb 12		 jmp	 SHORT $LN9@P_LoadThin
$LN7@P_LoadThin:
  0019f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  001a8	8b 4d f8	 mov	 ecx, DWORD PTR _mt$[ebp]
  001ab	83 c1 14	 add	 ecx, 20			; 00000014H
  001ae	89 4d f8	 mov	 DWORD PTR _mt$[ebp], ecx
$LN9@P_LoadThin:
  001b1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001b4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nummapthings
  001ba	73 75		 jae	 SHORT $LN8@P_LoadThin

; 719  : 	{
; 720  : 		// Z for objects
; 721  : 		mt->z = (INT16)(R_PointInSubsector(mt->x << FRACBITS, mt->y << FRACBITS)

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  001bf	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  001c3	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001c6	51		 push	 ecx
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _mt$[ebp]
  001ca	0f bf 02	 movsx	 eax, WORD PTR [edx]
  001cd	c1 e0 10	 shl	 eax, 16			; 00000010H
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _R_PointInSubsector
  001d6	83 c4 08	 add	 esp, 8
  001d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001db	8b 11		 mov	 edx, DWORD PTR [ecx]
  001dd	c1 fa 10	 sar	 edx, 16			; 00000010H
  001e0	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  001e3	66 89 50 0a	 mov	 WORD PTR [eax+10], dx

; 722  : 			->sector->floorheight>>FRACBITS);
; 723  : 
; 724  : 		if (mt->type == 1700 // MT_AXIS
; 725  : 			|| mt->type == 1701 // MT_AXISTRANSFER
; 726  : 			|| mt->type == 1702) // MT_AXISTRANSFERLINE

  001e7	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  001ea	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  001ee	81 f9 a4 06 00
	00		 cmp	 ecx, 1700		; 000006a4H
  001f4	74 1e		 je	 SHORT $LN24@P_LoadThin
  001f6	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  001f9	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  001fd	81 f9 a5 06 00
	00		 cmp	 ecx, 1701		; 000006a5H
  00203	74 0f		 je	 SHORT $LN24@P_LoadThin
  00205	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00208	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0020c	81 f9 a6 06 00
	00		 cmp	 ecx, 1702		; 000006a6H
  00212	75 02		 jne	 SHORT $LN23@P_LoadThin
$LN24@P_LoadThin:

; 727  : 			continue; // These were already spawned

  00214	eb 89		 jmp	 SHORT $LN7@P_LoadThin
$LN23@P_LoadThin:

; 728  : 
; 729  : 		mt->mobj = NULL;

  00216	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00219	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 730  : 		P_SpawnMapThing(mt);

  00220	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 _P_SpawnMapThing
  00229	83 c4 04	 add	 esp, 4

; 731  : 	}

  0022c	e9 6e ff ff ff	 jmp	 $LN7@P_LoadThin
$LN8@P_LoadThin:

; 732  : 
; 733  : 	// random emeralds for hunt
; 734  : 	if (numhuntemeralds)

  00231	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numhuntemeralds, 0
  00238	0f 84 79 01 00
	00		 je	 $LN30@P_LoadThin

; 735  : 	{
; 736  : 		INT32 emer1, emer2, emer3;
; 737  : 		INT32 timeout = 0; // keeps from getting stuck

  0023e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _timeout$1[ebp], 0

; 738  : 
; 739  : 		emer1 = emer2 = emer3 = 0;

  00245	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _emer3$2[ebp], 0
  0024c	8b 45 e4	 mov	 eax, DWORD PTR _emer3$2[ebp]
  0024f	89 45 e8	 mov	 DWORD PTR _emer2$3[ebp], eax
  00252	8b 4d e8	 mov	 ecx, DWORD PTR _emer2$3[ebp]
  00255	89 4d ec	 mov	 DWORD PTR _emer1$4[ebp], ecx

; 740  : 
; 741  : 		//increment spawn numbers because zero is valid.
; 742  : 		emer1 = (P_Random() % numhuntemeralds) + 1;

  00258	e8 00 00 00 00	 call	 _P_Random
  0025d	0f b6 c0	 movzx	 eax, al
  00260	99		 cdq
  00261	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _numhuntemeralds
  00267	83 c2 01	 add	 edx, 1
  0026a	89 55 ec	 mov	 DWORD PTR _emer1$4[ebp], edx
$LN10@P_LoadThin:

; 743  : 		while (timeout++ < 100)

  0026d	8b 45 e0	 mov	 eax, DWORD PTR _timeout$1[ebp]
  00270	89 45 9c	 mov	 DWORD PTR tv175[ebp], eax
  00273	8b 4d e0	 mov	 ecx, DWORD PTR _timeout$1[ebp]
  00276	83 c1 01	 add	 ecx, 1
  00279	89 4d e0	 mov	 DWORD PTR _timeout$1[ebp], ecx
  0027c	83 7d 9c 64	 cmp	 DWORD PTR tv175[ebp], 100 ; 00000064H
  00280	7d 21		 jge	 SHORT $LN11@P_LoadThin

; 744  : 		{
; 745  : 			emer2 = (P_Random() % numhuntemeralds) + 1;

  00282	e8 00 00 00 00	 call	 _P_Random
  00287	0f b6 c0	 movzx	 eax, al
  0028a	99		 cdq
  0028b	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _numhuntemeralds
  00291	83 c2 01	 add	 edx, 1
  00294	89 55 e8	 mov	 DWORD PTR _emer2$3[ebp], edx

; 746  : 
; 747  : 			if (emer2 != emer1)

  00297	8b 45 e8	 mov	 eax, DWORD PTR _emer2$3[ebp]
  0029a	3b 45 ec	 cmp	 eax, DWORD PTR _emer1$4[ebp]
  0029d	74 02		 je	 SHORT $LN26@P_LoadThin

; 748  : 				break;

  0029f	eb 02		 jmp	 SHORT $LN11@P_LoadThin
$LN26@P_LoadThin:

; 749  : 		}

  002a1	eb ca		 jmp	 SHORT $LN10@P_LoadThin
$LN11@P_LoadThin:

; 750  : 
; 751  : 		timeout = 0;

  002a3	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _timeout$1[ebp], 0
$LN12@P_LoadThin:

; 752  : 		while (timeout++ < 100)

  002aa	8b 45 e0	 mov	 eax, DWORD PTR _timeout$1[ebp]
  002ad	89 45 9c	 mov	 DWORD PTR tv183[ebp], eax
  002b0	8b 4d e0	 mov	 ecx, DWORD PTR _timeout$1[ebp]
  002b3	83 c1 01	 add	 ecx, 1
  002b6	89 4d e0	 mov	 DWORD PTR _timeout$1[ebp], ecx
  002b9	83 7d 9c 64	 cmp	 DWORD PTR tv183[ebp], 100 ; 00000064H
  002bd	7d 29		 jge	 SHORT $LN13@P_LoadThin

; 753  : 		{
; 754  : 			emer3 = (P_Random() % numhuntemeralds) + 1;

  002bf	e8 00 00 00 00	 call	 _P_Random
  002c4	0f b6 c0	 movzx	 eax, al
  002c7	99		 cdq
  002c8	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _numhuntemeralds
  002ce	83 c2 01	 add	 edx, 1
  002d1	89 55 e4	 mov	 DWORD PTR _emer3$2[ebp], edx

; 755  : 
; 756  : 			if (emer3 != emer2 && emer3 != emer1)

  002d4	8b 45 e4	 mov	 eax, DWORD PTR _emer3$2[ebp]
  002d7	3b 45 e8	 cmp	 eax, DWORD PTR _emer2$3[ebp]
  002da	74 0a		 je	 SHORT $LN27@P_LoadThin
  002dc	8b 45 e4	 mov	 eax, DWORD PTR _emer3$2[ebp]
  002df	3b 45 ec	 cmp	 eax, DWORD PTR _emer1$4[ebp]
  002e2	74 02		 je	 SHORT $LN27@P_LoadThin

; 757  : 				break;

  002e4	eb 02		 jmp	 SHORT $LN13@P_LoadThin
$LN27@P_LoadThin:

; 758  : 		}

  002e6	eb c2		 jmp	 SHORT $LN12@P_LoadThin
$LN13@P_LoadThin:

; 759  : 
; 760  : 		//decrement spawn values to the actual number because zero is valid.
; 761  : 		if (emer1)

  002e8	83 7d ec 00	 cmp	 DWORD PTR _emer1$4[ebp], 0
  002ec	74 3f		 je	 SHORT $LN28@P_LoadThin

; 762  : 			P_SpawnMobj(huntemeralds[emer1 - 1]->x<<FRACBITS,

  002ee	6a 3e		 push	 62			; 0000003eH
  002f0	8b 45 ec	 mov	 eax, DWORD PTR _emer1$4[ebp]
  002f3	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  002fa	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  002fe	c1 e2 10	 shl	 edx, 16			; 00000010H
  00301	52		 push	 edx
  00302	8b 45 ec	 mov	 eax, DWORD PTR _emer1$4[ebp]
  00305	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  0030c	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  00310	c1 e2 10	 shl	 edx, 16			; 00000010H
  00313	52		 push	 edx
  00314	8b 45 ec	 mov	 eax, DWORD PTR _emer1$4[ebp]
  00317	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  0031e	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00321	c1 e2 10	 shl	 edx, 16			; 00000010H
  00324	52		 push	 edx
  00325	e8 00 00 00 00	 call	 _P_SpawnMobj
  0032a	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@P_LoadThin:

; 763  : 				huntemeralds[emer1 - 1]->y<<FRACBITS,
; 764  : 				huntemeralds[emer1 - 1]->z<<FRACBITS, MT_EMERHUNT);
; 765  : 
; 766  : 		if (emer2)

  0032d	83 7d e8 00	 cmp	 DWORD PTR _emer2$3[ebp], 0
  00331	74 3f		 je	 SHORT $LN29@P_LoadThin

; 767  : 			P_SpawnMobj(huntemeralds[emer2 - 1]->x<<FRACBITS,

  00333	6a 3e		 push	 62			; 0000003eH
  00335	8b 45 e8	 mov	 eax, DWORD PTR _emer2$3[ebp]
  00338	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  0033f	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  00343	c1 e2 10	 shl	 edx, 16			; 00000010H
  00346	52		 push	 edx
  00347	8b 45 e8	 mov	 eax, DWORD PTR _emer2$3[ebp]
  0034a	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  00351	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  00355	c1 e2 10	 shl	 edx, 16			; 00000010H
  00358	52		 push	 edx
  00359	8b 45 e8	 mov	 eax, DWORD PTR _emer2$3[ebp]
  0035c	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  00363	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00366	c1 e2 10	 shl	 edx, 16			; 00000010H
  00369	52		 push	 edx
  0036a	e8 00 00 00 00	 call	 _P_SpawnMobj
  0036f	83 c4 10	 add	 esp, 16			; 00000010H
$LN29@P_LoadThin:

; 768  : 				huntemeralds[emer2 - 1]->y<<FRACBITS,
; 769  : 				huntemeralds[emer2 - 1]->z<<FRACBITS, MT_EMERHUNT);
; 770  : 
; 771  : 		if (emer3)

  00372	83 7d e4 00	 cmp	 DWORD PTR _emer3$2[ebp], 0
  00376	74 3f		 je	 SHORT $LN30@P_LoadThin

; 772  : 			P_SpawnMobj(huntemeralds[emer3 - 1]->x<<FRACBITS,

  00378	6a 3e		 push	 62			; 0000003eH
  0037a	8b 45 e4	 mov	 eax, DWORD PTR _emer3$2[ebp]
  0037d	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  00384	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  00388	c1 e2 10	 shl	 edx, 16			; 00000010H
  0038b	52		 push	 edx
  0038c	8b 45 e4	 mov	 eax, DWORD PTR _emer3$2[ebp]
  0038f	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  00396	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0039a	c1 e2 10	 shl	 edx, 16			; 00000010H
  0039d	52		 push	 edx
  0039e	8b 45 e4	 mov	 eax, DWORD PTR _emer3$2[ebp]
  003a1	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _huntemeralds[eax*4-4]
  003a8	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  003ab	c1 e2 10	 shl	 edx, 16			; 00000010H
  003ae	52		 push	 edx
  003af	e8 00 00 00 00	 call	 _P_SpawnMobj
  003b4	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@P_LoadThin:

; 773  : 				huntemeralds[emer3 - 1]->y<<FRACBITS,
; 774  : 				huntemeralds[emer3 - 1]->z<<FRACBITS, MT_EMERHUNT);
; 775  : 	}
; 776  : 
; 777  : 	// Run through the list of mapthings again to spawn hoops and rings
; 778  : 	mt = mapthings;

  003b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapthings
  003bc	89 45 f8	 mov	 DWORD PTR _mt$[ebp], eax

; 779  : 	for (i = 0; i < nummapthings; i++, mt++)

  003bf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003c6	eb 12		 jmp	 SHORT $LN16@P_LoadThin
$LN14@P_LoadThin:
  003c8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003cb	83 c0 01	 add	 eax, 1
  003ce	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  003d1	8b 4d f8	 mov	 ecx, DWORD PTR _mt$[ebp]
  003d4	83 c1 14	 add	 ecx, 20			; 00000014H
  003d7	89 4d f8	 mov	 DWORD PTR _mt$[ebp], ecx
$LN16@P_LoadThin:
  003da	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003dd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nummapthings
  003e3	0f 83 c4 00 00
	00		 jae	 $LN15@P_LoadThin

; 780  : 	{
; 781  : 		switch (mt->type) //todo: change all of these to the mobj[type].doomednum so that this area is more flexible.

  003e9	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  003ec	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  003f0	89 4d 9c	 mov	 DWORD PTR tv264[ebp], ecx
  003f3	81 7d 9c 58 02
	00 00		 cmp	 DWORD PTR tv264[ebp], 600 ; 00000258H
  003fa	7f 29		 jg	 SHORT $LN49@P_LoadThin
  003fc	81 7d 9c 58 02
	00 00		 cmp	 DWORD PTR tv264[ebp], 600 ; 00000258H
  00403	74 62		 je	 SHORT $LN31@P_LoadThin
  00405	81 7d 9c 2c 01
	00 00		 cmp	 DWORD PTR tv264[ebp], 300 ; 0000012cH
  0040c	74 59		 je	 SHORT $LN31@P_LoadThin
  0040e	81 7d 9c 34 01
	00 00		 cmp	 DWORD PTR tv264[ebp], 308 ; 00000134H
  00415	74 50		 je	 SHORT $LN31@P_LoadThin
  00417	81 7d 9c 35 01
	00 00		 cmp	 DWORD PTR tv264[ebp], 309 ; 00000135H
  0041e	74 47		 je	 SHORT $LN31@P_LoadThin
  00420	e9 83 00 00 00	 jmp	 $LN47@P_LoadThin
$LN49@P_LoadThin:
  00425	81 7d 9c a9 06
	00 00		 cmp	 DWORD PTR tv264[ebp], 1705 ; 000006a9H
  0042c	7f 25		 jg	 SHORT $LN50@P_LoadThin
  0042e	81 7d 9c a9 06
	00 00		 cmp	 DWORD PTR tv264[ebp], 1705 ; 000006a9H
  00435	74 30		 je	 SHORT $LN31@P_LoadThin
  00437	8b 55 9c	 mov	 edx, DWORD PTR tv264[ebp]
  0043a	81 ea 59 02 00
	00		 sub	 edx, 601		; 00000259H
  00440	89 55 9c	 mov	 DWORD PTR tv264[ebp], edx
  00443	83 7d 9c 08	 cmp	 DWORD PTR tv264[ebp], 8
  00447	77 5f		 ja	 SHORT $LN47@P_LoadThin
  00449	8b 45 9c	 mov	 eax, DWORD PTR tv264[ebp]
  0044c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN51@P_LoadThin[eax*4]
$LN50@P_LoadThin:
  00453	81 7d 9c aa 06
	00 00		 cmp	 DWORD PTR tv264[ebp], 1706 ; 000006aaH
  0045a	74 0b		 je	 SHORT $LN31@P_LoadThin
  0045c	81 7d 9c 08 07
	00 00		 cmp	 DWORD PTR tv264[ebp], 1800 ; 00000708H
  00463	74 02		 je	 SHORT $LN31@P_LoadThin
  00465	eb 41		 jmp	 SHORT $LN47@P_LoadThin
$LN31@P_LoadThin:

; 782  : 		{
; 783  : 			case 300:
; 784  : 			case 308:
; 785  : 			case 309:
; 786  : 			case 600:
; 787  : 			case 601:
; 788  : 			case 602:
; 789  : 			case 603:
; 790  : 			case 604:
; 791  : 			case 605:
; 792  : 			case 606:
; 793  : 			case 607:
; 794  : 			case 608:
; 795  : 			case 609:
; 796  : 			case 1705:
; 797  : 			case 1706:
; 798  : 			case 1800:
; 799  : 				mt->mobj = NULL;

  00467	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  0046a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 800  : 
; 801  : 				// Z for objects Tails 05-26-2002
; 802  : 				mt->z = (INT16)(R_PointInSubsector(mt->x << FRACBITS, mt->y << FRACBITS)

  00471	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00474	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00478	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0047b	51		 push	 ecx
  0047c	8b 55 f8	 mov	 edx, DWORD PTR _mt$[ebp]
  0047f	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00482	c1 e0 10	 shl	 eax, 16			; 00000010H
  00485	50		 push	 eax
  00486	e8 00 00 00 00	 call	 _R_PointInSubsector
  0048b	83 c4 08	 add	 esp, 8
  0048e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00490	8b 11		 mov	 edx, DWORD PTR [ecx]
  00492	c1 fa 10	 sar	 edx, 16			; 00000010H
  00495	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  00498	66 89 50 0a	 mov	 WORD PTR [eax+10], dx

; 803  : 					->sector->floorheight>>FRACBITS);
; 804  : 
; 805  : 				P_SpawnHoopsAndRings (mt);

  0049c	8b 45 f8	 mov	 eax, DWORD PTR _mt$[ebp]
  0049f	50		 push	 eax
  004a0	e8 00 00 00 00	 call	 _P_SpawnHoopsAndRings
  004a5	83 c4 04	 add	 esp, 4
$LN47@P_LoadThin:

; 806  : 				break;
; 807  : 			default:
; 808  : 				break;
; 809  : 		}
; 810  : 	}

  004a8	e9 1b ff ff ff	 jmp	 $LN14@P_LoadThin
$LN15@P_LoadThin:

; 811  : }

  004ad	5f		 pop	 edi
  004ae	5e		 pop	 esi
  004af	5b		 pop	 ebx
  004b0	8b e5		 mov	 esp, ebp
  004b2	5d		 pop	 ebp
  004b3	c3		 ret	 0
$LN51@P_LoadThin:
  004b4	00 00 00 00	 DD	 $LN31@P_LoadThin
  004b8	00 00 00 00	 DD	 $LN31@P_LoadThin
  004bc	00 00 00 00	 DD	 $LN31@P_LoadThin
  004c0	00 00 00 00	 DD	 $LN31@P_LoadThin
  004c4	00 00 00 00	 DD	 $LN31@P_LoadThin
  004c8	00 00 00 00	 DD	 $LN31@P_LoadThin
  004cc	00 00 00 00	 DD	 $LN31@P_LoadThin
  004d0	00 00 00 00	 DD	 $LN31@P_LoadThin
  004d4	00 00 00 00	 DD	 $LN31@P_LoadThin
_P_LoadThings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadNodes
_TEXT	SEGMENT
_no$ = -20						; size = 4
_mn$ = -16						; size = 4
_k$ = -10						; size = 1
_j$ = -9						; size = 1
_i$ = -8						; size = 4
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadNodes PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 639  : 	UINT8 *data;
; 640  : 	size_t i;
; 641  : 	UINT8 j, k;
; 642  : 	mapnode_t *mn;
; 643  : 	node_t *no;
; 644  : 
; 645  : 	numnodes = W_LumpLength(lumpnum) / sizeof (mapnode_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	33 d2		 xor	 edx, edx
  00017	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001c	f7 f1		 div	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _numnodes, eax

; 646  : 	if (numnodes <= 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numnodes, 0
  0002a	77 0d		 ja	 SHORT $LN11@P_LoadNode

; 647  : 		I_Error("Level has no nodes");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ILKLNMIK@Level?5has?5no?5nodes@
  00031	e8 00 00 00 00	 call	 _I_Error
  00036	83 c4 04	 add	 esp, 4
$LN11@P_LoadNode:

; 648  : 	nodes = Z_Calloc(numnodes * sizeof (*nodes), PU_LEVEL, NULL);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 32		 push	 50			; 00000032H
  0003f	6b 05 00 00 00
	00 34		 imul	 eax, DWORD PTR _numnodes, 52
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _Z_CallocAlign
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	a3 00 00 00 00	 mov	 DWORD PTR _nodes, eax

; 649  : 	data = W_CacheLumpNum(lumpnum, PU_STATIC);

  00054	6a 01		 push	 1
  00056	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0005f	83 c4 08	 add	 esp, 8
  00062	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 650  : 
; 651  : 	mn = (mapnode_t *)data;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00068	89 45 f0	 mov	 DWORD PTR _mn$[ebp], eax

; 652  : 	no = nodes;

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _nodes
  00070	89 45 ec	 mov	 DWORD PTR _no$[ebp], eax

; 653  : 
; 654  : 	for (i = 0; i < numnodes; i++, no++, mn++)

  00073	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007a	eb 1b		 jmp	 SHORT $LN4@P_LoadNode
$LN2@P_LoadNode:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _no$[ebp]
  00088	83 c1 34	 add	 ecx, 52			; 00000034H
  0008b	89 4d ec	 mov	 DWORD PTR _no$[ebp], ecx
  0008e	8b 55 f0	 mov	 edx, DWORD PTR _mn$[ebp]
  00091	83 c2 1c	 add	 edx, 28			; 0000001cH
  00094	89 55 f0	 mov	 DWORD PTR _mn$[ebp], edx
$LN4@P_LoadNode:
  00097	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numnodes
  000a0	0f 83 b8 00 00
	00		 jae	 $LN3@P_LoadNode

; 655  : 	{
; 656  : 		no->x = SHORT(mn->x)<<FRACBITS;

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _mn$[ebp]
  000a9	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000ac	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000af	8b 55 ec	 mov	 edx, DWORD PTR _no$[ebp]
  000b2	89 0a		 mov	 DWORD PTR [edx], ecx

; 657  : 		no->y = SHORT(mn->y)<<FRACBITS;

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _mn$[ebp]
  000b7	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000bb	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000be	8b 55 ec	 mov	 edx, DWORD PTR _no$[ebp]
  000c1	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 658  : 		no->dx = SHORT(mn->dx)<<FRACBITS;

  000c4	8b 45 f0	 mov	 eax, DWORD PTR _mn$[ebp]
  000c7	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000cb	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000ce	8b 55 ec	 mov	 edx, DWORD PTR _no$[ebp]
  000d1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 659  : 		no->dy = SHORT(mn->dy)<<FRACBITS;

  000d4	8b 45 f0	 mov	 eax, DWORD PTR _mn$[ebp]
  000d7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000db	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000de	8b 55 ec	 mov	 edx, DWORD PTR _no$[ebp]
  000e1	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 660  : 		for (j = 0; j < 2; j++)

  000e4	c6 45 f7 00	 mov	 BYTE PTR _j$[ebp], 0
  000e8	eb 08		 jmp	 SHORT $LN7@P_LoadNode
$LN5@P_LoadNode:
  000ea	8a 45 f7	 mov	 al, BYTE PTR _j$[ebp]
  000ed	04 01		 add	 al, 1
  000ef	88 45 f7	 mov	 BYTE PTR _j$[ebp], al
$LN7@P_LoadNode:
  000f2	0f b6 45 f7	 movzx	 eax, BYTE PTR _j$[ebp]
  000f6	83 f8 02	 cmp	 eax, 2
  000f9	7d 5e		 jge	 SHORT $LN6@P_LoadNode

; 661  : 		{
; 662  : 			no->children[j] = SHORT(mn->children[j]);

  000fb	0f b6 45 f7	 movzx	 eax, BYTE PTR _j$[ebp]
  000ff	0f b6 4d f7	 movzx	 ecx, BYTE PTR _j$[ebp]
  00103	8b 55 ec	 mov	 edx, DWORD PTR _no$[ebp]
  00106	8b 75 f0	 mov	 esi, DWORD PTR _mn$[ebp]
  00109	66 8b 44 46 18	 mov	 ax, WORD PTR [esi+eax*2+24]
  0010e	66 89 44 4a 30	 mov	 WORD PTR [edx+ecx*2+48], ax

; 663  : 			for (k = 0; k < 4; k++)

  00113	c6 45 f6 00	 mov	 BYTE PTR _k$[ebp], 0
  00117	eb 08		 jmp	 SHORT $LN10@P_LoadNode
$LN8@P_LoadNode:
  00119	8a 45 f6	 mov	 al, BYTE PTR _k$[ebp]
  0011c	04 01		 add	 al, 1
  0011e	88 45 f6	 mov	 BYTE PTR _k$[ebp], al
$LN10@P_LoadNode:
  00121	0f b6 45 f6	 movzx	 eax, BYTE PTR _k$[ebp]
  00125	83 f8 04	 cmp	 eax, 4
  00128	7d 2d		 jge	 SHORT $LN9@P_LoadNode

; 664  : 				no->bbox[j][k] = SHORT(mn->bbox[j][k])<<FRACBITS;

  0012a	0f b6 45 f7	 movzx	 eax, BYTE PTR _j$[ebp]
  0012e	8b 4d f0	 mov	 ecx, DWORD PTR _mn$[ebp]
  00131	8d 54 c1 08	 lea	 edx, DWORD PTR [ecx+eax*8+8]
  00135	0f b6 45 f6	 movzx	 eax, BYTE PTR _k$[ebp]
  00139	0f bf 0c 42	 movsx	 ecx, WORD PTR [edx+eax*2]
  0013d	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00140	0f b6 55 f7	 movzx	 edx, BYTE PTR _j$[ebp]
  00144	c1 e2 04	 shl	 edx, 4
  00147	8b 45 ec	 mov	 eax, DWORD PTR _no$[ebp]
  0014a	8d 54 10 10	 lea	 edx, DWORD PTR [eax+edx+16]
  0014e	0f b6 45 f6	 movzx	 eax, BYTE PTR _k$[ebp]
  00152	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00155	eb c2		 jmp	 SHORT $LN8@P_LoadNode
$LN9@P_LoadNode:

; 665  : 		}

  00157	eb 91		 jmp	 SHORT $LN5@P_LoadNode
$LN6@P_LoadNode:

; 666  : 	}

  00159	e9 1e ff ff ff	 jmp	 $LN2@P_LoadNode
$LN3@P_LoadNode:

; 667  : 
; 668  : 	Z_Free(data);

  0015e	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _Z_Free
  00167	83 c4 04	 add	 esp, 4

; 669  : }

  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
_P_LoadNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadSectors
_TEXT	SEGMENT
_foundflats$ = -20					; size = 4
_ss$ = -16						; size = 4
_ms$ = -12						; size = 4
_i$ = -8						; size = 4
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadSectors PROC					; COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 513  : 	UINT8 *data;
; 514  : 	size_t i;
; 515  : 	mapsector_t *ms;
; 516  : 	sector_t *ss;
; 517  : 	levelflat_t *foundflats;
; 518  : 
; 519  : 	numsectors = W_LumpLength(lumpnum) / sizeof (mapsector_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	33 d2		 xor	 edx, edx
  00017	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  0001c	f7 f1		 div	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _numsectors, eax

; 520  : 	if (numsectors <= 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsectors, 0
  0002a	77 0d		 ja	 SHORT $LN5@P_LoadSect

; 521  : 		I_Error("Level has no sectors");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EOKOOIH@Level?5has?5no?5sectors@
  00031	e8 00 00 00 00	 call	 _I_Error
  00036	83 c4 04	 add	 esp, 4
$LN5@P_LoadSect:

; 522  : 	sectors = Z_Calloc(numsectors*sizeof (*sectors), PU_LEVEL, NULL);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 32		 push	 50			; 00000032H
  0003f	69 05 00 00 00
	00 f8 00 00 00	 imul	 eax, DWORD PTR _numsectors, 248
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _Z_CallocAlign
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	a3 00 00 00 00	 mov	 DWORD PTR _sectors, eax

; 523  : 	data = W_CacheLumpNum(lumpnum,PU_STATIC);

  00057	6a 01		 push	 1
  00059	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00062	83 c4 08	 add	 esp, 8
  00065	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 524  : 
; 525  : 	//Fab : FIXME: allocate for whatever number of flats
; 526  : 	//           512 different flats per level should be plenty
; 527  : 
; 528  : 	foundflats = calloc(MAXLEVELFLATS, sizeof (*foundflats));

  00068	6a 20		 push	 32			; 00000020H
  0006a	68 00 01 00 00	 push	 256			; 00000100H
  0006f	e8 00 00 00 00	 call	 _calloc
  00074	83 c4 08	 add	 esp, 8
  00077	89 45 ec	 mov	 DWORD PTR _foundflats$[ebp], eax

; 529  : 	if (foundflats == NULL)

  0007a	83 7d ec 00	 cmp	 DWORD PTR _foundflats$[ebp], 0
  0007e	75 0d		 jne	 SHORT $LN6@P_LoadSect

; 530  : 		I_Error("Ran out of memory while loading sectors\n");

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@LDMLPKHB@Ran?5out?5of?5memory?5while?5loading@
  00085	e8 00 00 00 00	 call	 _I_Error
  0008a	83 c4 04	 add	 esp, 4
$LN6@P_LoadSect:

; 531  : 
; 532  : 	numlevelflats = 0;

  0008d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numlevelflats, 0

; 533  : 
; 534  : 	ms = (mapsector_t *)data;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  0009a	89 45 f4	 mov	 DWORD PTR _ms$[ebp], eax

; 535  : 	ss = sectors;

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  000a2	89 45 f0	 mov	 DWORD PTR _ss$[ebp], eax

; 536  : 	for (i = 0; i < numsectors; i++, ss++, ms++)

  000a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ac	eb 1e		 jmp	 SHORT $LN4@P_LoadSect
$LN2@P_LoadSect:
  000ae	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b1	83 c0 01	 add	 eax, 1
  000b4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _ss$[ebp]
  000ba	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  000c0	89 4d f0	 mov	 DWORD PTR _ss$[ebp], ecx
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _ms$[ebp]
  000c6	83 c2 1a	 add	 edx, 26			; 0000001aH
  000c9	89 55 f4	 mov	 DWORD PTR _ms$[ebp], edx
$LN4@P_LoadSect:
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  000d5	0f 83 8e 03 00
	00		 jae	 $LN3@P_LoadSect

; 537  : 	{
; 538  : 		ss->floorheight = SHORT(ms->floorheight)<<FRACBITS;

  000db	8b 45 f4	 mov	 eax, DWORD PTR _ms$[ebp]
  000de	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000e1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000e4	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  000e7	89 0a		 mov	 DWORD PTR [edx], ecx

; 539  : 		ss->ceilingheight = SHORT(ms->ceilingheight)<<FRACBITS;

  000e9	8b 45 f4	 mov	 eax, DWORD PTR _ms$[ebp]
  000ec	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000f0	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000f3	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  000f6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 540  : 
; 541  : 		//
; 542  : 		//  flats
; 543  : 		//
; 544  : 		ss->floorpic = P_AddLevelFlat(ms->floorpic, foundflats);

  000f9	8b 45 ec	 mov	 eax, DWORD PTR _foundflats$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  00100	83 c1 04	 add	 ecx, 4
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 _P_AddLevelFlat
  00109	83 c4 08	 add	 esp, 8
  0010c	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  0010f	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 545  : 		ss->ceilingpic = P_AddLevelFlat(ms->ceilingpic, foundflats);

  00112	8b 45 ec	 mov	 eax, DWORD PTR _foundflats$[ebp]
  00115	50		 push	 eax
  00116	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  00119	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0011c	51		 push	 ecx
  0011d	e8 00 00 00 00	 call	 _P_AddLevelFlat
  00122	83 c4 08	 add	 esp, 8
  00125	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  00128	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 546  : 
; 547  : 		ss->lightlevel = SHORT(ms->lightlevel);

  0012b	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0012e	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  00131	66 8b 51 14	 mov	 dx, WORD PTR [ecx+20]
  00135	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 548  : 		ss->special = SHORT(ms->special);

  00139	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0013c	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  0013f	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  00143	66 89 50 12	 mov	 WORD PTR [eax+18], dx

; 549  : 		ss->tag = SHORT(ms->tag);

  00147	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0014a	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  0014d	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00151	66 89 50 14	 mov	 WORD PTR [eax+20], dx

; 550  : 		ss->nexttag = ss->firsttag = -1;

  00155	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00158	c7 40 1c ff ff
	ff ff		 mov	 DWORD PTR [eax+28], -1
  0015f	8b 4d f0	 mov	 ecx, DWORD PTR _ss$[ebp]
  00162	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [ecx+24], -1

; 551  : 
; 552  : 		memset(&ss->soundorg, 0, sizeof(ss->soundorg));

  00169	6a 1c		 push	 28			; 0000001cH
  0016b	6a 00		 push	 0
  0016d	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00170	83 c0 20	 add	 eax, 32			; 00000020H
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _memset
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH

; 553  : 		ss->validcount = 0;

  0017c	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0017f	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 554  : 
; 555  : 		ss->thinglist = NULL;

  00186	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00189	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 556  : 		ss->touching_thinglist = NULL;

  00190	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00193	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], 0

; 557  : 		ss->preciplist = NULL;

  0019d	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001a0	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0

; 558  : 		ss->touching_preciplist = NULL;

  001aa	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001ad	c7 80 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+244], 0

; 559  : 
; 560  : 		ss->floordata = NULL;

  001b7	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001ba	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 561  : 		ss->ceilingdata = NULL;

  001c1	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001c4	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 562  : 		ss->lightingdata = NULL;

  001cb	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001ce	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 563  : 
; 564  : 		ss->linecount = 0;

  001d5	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001d8	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], 0

; 565  : 		ss->lines = NULL;

  001e2	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001e5	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+140], 0

; 566  : 
; 567  : 		ss->heightsec = -1;

  001ef	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001f2	c7 40 68 ff ff
	ff ff		 mov	 DWORD PTR [eax+104], -1

; 568  : 		ss->floorlightsec = -1;

  001f9	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  001fc	c7 40 6c ff ff
	ff ff		 mov	 DWORD PTR [eax+108], -1

; 569  : 		ss->ceilinglightsec = -1;

  00203	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00206	c7 40 70 ff ff
	ff ff		 mov	 DWORD PTR [eax+112], -1

; 570  : 		ss->crumblestate = 0;

  0020d	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00210	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 571  : 		ss->ffloors = NULL;

  00217	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0021a	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], 0

; 572  : 		ss->lightlist = NULL;

  00224	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00227	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], 0

; 573  : 		ss->numlights = 0;

  00231	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00234	c7 80 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+168], 0

; 574  : 		ss->attached = NULL;

  0023e	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00241	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0

; 575  : 		ss->attachedsolid = NULL;

  0024b	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0024e	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+152], 0

; 576  : 		ss->numattached = 0;

  00258	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0025b	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 577  : 		ss->maxattached = 1;

  00265	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00268	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 578  : 		ss->moved = true;

  00272	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00275	c7 80 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+172], 1

; 579  : 
; 580  : 		ss->extra_colormap = NULL;

  0027f	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00282	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0

; 581  : 
; 582  : 		ss->floor_xoffs = ss->ceiling_xoffs = ss->floor_yoffs = ss->ceiling_yoffs = 0;

  0028c	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0028f	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0
  00296	8b 4d f0	 mov	 ecx, DWORD PTR _ss$[ebp]
  00299	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
  002a0	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  002a3	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0
  002aa	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  002ad	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 583  : 		ss->floorpic_angle = ss->ceilingpic_angle = 0;

  002b4	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  002b7	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0
  002be	8b 4d f0	 mov	 ecx, DWORD PTR _ss$[ebp]
  002c1	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0

; 584  : 		ss->bottommap = ss->midmap = ss->topmap = -1;

  002c8	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  002cb	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+128], -1
  002d5	8b 4d f0	 mov	 ecx, DWORD PTR _ss$[ebp]
  002d8	c7 41 7c ff ff
	ff ff		 mov	 DWORD PTR [ecx+124], -1
  002df	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  002e2	c7 42 78 ff ff
	ff ff		 mov	 DWORD PTR [edx+120], -1

; 585  : 		ss->gravity = NULL;

  002e9	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  002ec	c7 80 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+216], 0

; 586  : 		ss->cullheight = NULL;

  002f6	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  002f9	c7 80 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+228], 0

; 587  : 		ss->verticalflip = false;

  00303	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00306	c7 80 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+220], 0

; 588  : 		ss->flags = 0;

  00310	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00313	c7 80 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+224], 0

; 589  : 		ss->flags |= SF_FLIPSPECIAL_FLOOR;

  0031d	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00320	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00326	83 c9 01	 or	 ecx, 1
  00329	8b 55 f0	 mov	 edx, DWORD PTR _ss$[ebp]
  0032c	89 8a e0 00 00
	00		 mov	 DWORD PTR [edx+224], ecx

; 590  : 
; 591  : 		ss->floorspeed = 0;

  00332	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00335	c7 80 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+232], 0

; 592  : 		ss->ceilspeed = 0;

  0033f	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00342	c7 80 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+236], 0

; 593  : 
; 594  : #ifdef HWRENDER // ----- for special tricks with HW renderer -----
; 595  : 		ss->pseudoSector = false;

  0034c	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0034f	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+180], 0

; 596  : 		ss->virtualFloor = false;

  00359	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  0035c	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+184], 0

; 597  : 		ss->virtualCeiling = false;

  00366	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00369	c7 80 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+192], 0

; 598  : 		ss->sectorLines = NULL;

  00373	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00376	c7 80 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+200], 0

; 599  : 		ss->stackList = NULL;

  00380	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00383	c7 80 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+204], 0

; 600  : 		ss->lineoutLength = -1.0l;

  0038d	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00390	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@bff0000000000000
  00398	f2 0f 11 80 d0
	00 00 00	 movsd	 QWORD PTR [eax+208], xmm0

; 601  : #endif // ----- end special tricks -----
; 602  : 
; 603  : 		// Keep players out of secret levels!
; 604  : 		if (!dedicated) // to prevent dedicated server error.

  003a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  003a7	0f 85 b7 00 00
	00		 jne	 $LN15@P_LoadSect

; 605  : 		{
; 606  : 			// Keep players out of secret levels!
; 607  : 			if (ss->tag == 4240 && !(grade & 2)) // Mario

  003ad	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  003b0	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  003b4	81 f9 90 10 00
	00		 cmp	 ecx, 4240		; 00001090H
  003ba	75 1c		 jne	 SHORT $LN8@P_LoadSect
  003bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  003c1	83 e0 02	 and	 eax, 2
  003c4	75 12		 jne	 SHORT $LN8@P_LoadSect

; 608  : 				I_Error("You need to unlock this level first!\n");

  003c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BIJHGKIL@You?5need?5to?5unlock?5this?5level?5f@
  003cb	e8 00 00 00 00	 call	 _I_Error
  003d0	83 c4 04	 add	 esp, 4
  003d3	e9 8c 00 00 00	 jmp	 $LN15@P_LoadSect
$LN8@P_LoadSect:

; 609  : 			else if (ss->tag == 4250 && !(grade & 16)) // NiGHTS

  003d8	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  003db	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  003df	81 f9 9a 10 00
	00		 cmp	 ecx, 4250		; 0000109aH
  003e5	75 19		 jne	 SHORT $LN10@P_LoadSect
  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  003ec	83 e0 10	 and	 eax, 16			; 00000010H
  003ef	75 0f		 jne	 SHORT $LN10@P_LoadSect

; 610  : 				I_Error("You need to unlock this level first!\n");

  003f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BIJHGKIL@You?5need?5to?5unlock?5this?5level?5f@
  003f6	e8 00 00 00 00	 call	 _I_Error
  003fb	83 c4 04	 add	 esp, 4
  003fe	eb 64		 jmp	 SHORT $LN15@P_LoadSect
$LN10@P_LoadSect:

; 611  : 			else if (ss->tag == 4260 && (modifiedgame || netgame || multiplayer) && !(grade & 2048)) // NAGZ

  00400	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  00403	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00407	81 f9 a4 10 00
	00		 cmp	 ecx, 4260		; 000010a4H
  0040d	75 55		 jne	 SHORT $LN15@P_LoadSect
  0040f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _modifiedgame, 0
  00416	75 12		 jne	 SHORT $LN13@P_LoadSect
  00418	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0041f	75 09		 jne	 SHORT $LN13@P_LoadSect
  00421	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00428	74 3a		 je	 SHORT $LN15@P_LoadSect
$LN13@P_LoadSect:
  0042a	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  0042f	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00434	75 2e		 jne	 SHORT $LN15@P_LoadSect

; 612  : 			{
; 613  : 				if (netgame || multiplayer)

  00436	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0043d	75 09		 jne	 SHORT $LN16@P_LoadSect
  0043f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00446	74 0f		 je	 SHORT $LN14@P_LoadSect
$LN16@P_LoadSect:

; 614  : 					I_Error("You need to unlock this level in single player first!\n");

  00448	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ONBGHNBN@You?5need?5to?5unlock?5this?5level?5i@
  0044d	e8 00 00 00 00	 call	 _I_Error
  00452	83 c4 04	 add	 esp, 4
  00455	eb 0d		 jmp	 SHORT $LN15@P_LoadSect
$LN14@P_LoadSect:

; 615  : 				else
; 616  : 					I_Error("You need to unlock this level first!\n");

  00457	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BIJHGKIL@You?5need?5to?5unlock?5this?5level?5f@
  0045c	e8 00 00 00 00	 call	 _I_Error
  00461	83 c4 04	 add	 esp, 4
$LN15@P_LoadSect:

; 617  : 			}
; 618  : 		}
; 619  : 	}

  00464	e9 45 fc ff ff	 jmp	 $LN2@P_LoadSect
$LN3@P_LoadSect:

; 620  : 
; 621  : 	Z_Free(data);

  00469	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  0046c	50		 push	 eax
  0046d	e8 00 00 00 00	 call	 _Z_Free
  00472	83 c4 04	 add	 esp, 4

; 622  : 
; 623  : 	// set the sky flat num
; 624  : 	skyflatnum = P_AddLevelFlat("F_SKY1", foundflats);

  00475	8b 45 ec	 mov	 eax, DWORD PTR _foundflats$[ebp]
  00478	50		 push	 eax
  00479	68 00 00 00 00	 push	 OFFSET ??_C@_06COAGKCEK@F_SKY1@
  0047e	e8 00 00 00 00	 call	 _P_AddLevelFlat
  00483	83 c4 08	 add	 esp, 8
  00486	a3 00 00 00 00	 mov	 DWORD PTR _skyflatnum, eax

; 625  : 
; 626  : 	// copy table for global usage
; 627  : 	levelflats = M_Memcpy(Z_Calloc(numlevelflats * sizeof (*levelflats), PU_LEVEL, NULL), foundflats, numlevelflats * sizeof (levelflat_t));

  0048b	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlevelflats
  00490	c1 e0 05	 shl	 eax, 5
  00493	50		 push	 eax
  00494	8b 4d ec	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00497	51		 push	 ecx
  00498	6a 00		 push	 0
  0049a	6a 00		 push	 0
  0049c	6a 32		 push	 50			; 00000032H
  0049e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numlevelflats
  004a4	c1 e2 05	 shl	 edx, 5
  004a7	52		 push	 edx
  004a8	e8 00 00 00 00	 call	 _Z_CallocAlign
  004ad	83 c4 10	 add	 esp, 16			; 00000010H
  004b0	50		 push	 eax
  004b1	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  004b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ba	a3 00 00 00 00	 mov	 DWORD PTR _levelflats, eax

; 628  : 	free(foundflats);

  004bf	8b 45 ec	 mov	 eax, DWORD PTR _foundflats$[ebp]
  004c2	50		 push	 eax
  004c3	e8 00 00 00 00	 call	 _free
  004c8	83 c4 04	 add	 esp, 4

; 629  : 
; 630  : 	// search for animated flats and set up
; 631  : 	P_SetupLevelFlatAnims();

  004cb	e8 00 00 00 00	 call	 _P_SetupLevelFlatAnims
  004d0	90		 npad	 1

; 632  : }

  004d1	5f		 pop	 edi
  004d2	5e		 pop	 esi
  004d3	5b		 pop	 ebx
  004d4	8b e5		 mov	 esp, ebp
  004d6	5d		 pop	 ebp
  004d7	c3		 ret	 0
_P_LoadSectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadSubsectors
_TEXT	SEGMENT
_ss$ = -16						; size = 4
_ms$ = -12						; size = 4
_i$ = -8						; size = 4
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadSubsectors PROC					; COMDAT

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 418  : 	void *data;
; 419  : 	size_t i;
; 420  : 	mapsubsector_t *ms;
; 421  : 	subsector_t *ss;
; 422  : 
; 423  : 	numsubsectors = W_LumpLength(lumpnum) / sizeof (mapsubsector_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	c1 e8 02	 shr	 eax, 2
  00018	a3 00 00 00 00	 mov	 DWORD PTR _numsubsectors, eax

; 424  : 	if (numsubsectors <= 0)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsubsectors, 0
  00024	77 0d		 ja	 SHORT $LN5@P_LoadSubs

; 425  : 		I_Error("Level has no subsectors (did you forget to run it through a nodesbuilder?)");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NCGEIFGK@Level?5has?5no?5subsectors?5?$CIdid?5yo@
  0002b	e8 00 00 00 00	 call	 _I_Error
  00030	83 c4 04	 add	 esp, 4
$LN5@P_LoadSubs:

; 426  : 	ss = subsectors = Z_Calloc(numsubsectors * sizeof (*subsectors), PU_LEVEL, NULL);

  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 32		 push	 50			; 00000032H
  00039	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR _numsubsectors, 20
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _Z_CallocAlign
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	a3 00 00 00 00	 mov	 DWORD PTR _subsectors, eax
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _subsectors
  00054	89 4d f0	 mov	 DWORD PTR _ss$[ebp], ecx

; 427  : 	data = W_CacheLumpNum(lumpnum,PU_STATIC);

  00057	6a 01		 push	 1
  00059	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00062	83 c4 08	 add	 esp, 8
  00065	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 428  : 
; 429  : 	ms = (mapsubsector_t *)data;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR _ms$[ebp], eax

; 430  : 
; 431  : 	for (i = 0; i < numsubsectors; i++, ss++, ms++)

  0006e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00075	eb 1b		 jmp	 SHORT $LN4@P_LoadSubs
$LN2@P_LoadSubs:
  00077	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _ss$[ebp]
  00083	83 c1 14	 add	 ecx, 20			; 00000014H
  00086	89 4d f0	 mov	 DWORD PTR _ss$[ebp], ecx
  00089	8b 55 f4	 mov	 edx, DWORD PTR _ms$[ebp]
  0008c	83 c2 04	 add	 edx, 4
  0008f	89 55 f4	 mov	 DWORD PTR _ms$[ebp], edx
$LN4@P_LoadSubs:
  00092	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00095	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsubsectors
  0009b	73 30		 jae	 SHORT $LN3@P_LoadSubs

; 432  : 	{
; 433  : 		ss->sector = NULL;

  0009d	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  000a0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 434  : 		ss->numlines = SHORT(ms->numsegs);

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  000ac	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000af	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 435  : 		ss->firstline = SHORT(ms->firstseg);

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _ms$[ebp]
  000b9	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000bd	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 436  : #ifdef FLOORSPLATS
; 437  : 		ss->splats = NULL;
; 438  : #endif
; 439  : 		ss->validcount = 0;

  000c1	8b 45 f0	 mov	 eax, DWORD PTR _ss$[ebp]
  000c4	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 440  : 	}

  000cb	eb aa		 jmp	 SHORT $LN2@P_LoadSubs
$LN3@P_LoadSubs:

; 441  : 
; 442  : 	Z_Free(data);

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _Z_Free
  000d6	83 c4 04	 add	 esp, 4

; 443  : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_P_LoadSubsectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadSegs
_TEXT	SEGMENT
_ldef$ = -28						; size = 4
_li$ = -24						; size = 4
_ml$ = -20						; size = 4
_side$ = -16						; size = 4
_linedef$ = -12						; size = 4
_i$ = -8						; size = 4
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadSegs PROC					; COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 361  : 	UINT8 *data;
; 362  : 	size_t i;
; 363  : 	INT32 linedef, side;
; 364  : 	mapseg_t *ml;
; 365  : 	seg_t *li;
; 366  : 	line_t *ldef;
; 367  : 
; 368  : 	numsegs = W_LumpLength(lumpnum) / sizeof (mapseg_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	33 d2		 xor	 edx, edx
  00017	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001c	f7 f1		 div	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _numsegs, eax

; 369  : 	if (numsegs <= 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsegs, 0
  0002a	77 0d		 ja	 SHORT $LN5@P_LoadSegs

; 370  : 		I_Error("Level has no segs"); // instead of crashing

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DFHLPIAF@Level?5has?5no?5segs@
  00031	e8 00 00 00 00	 call	 _I_Error
  00036	83 c4 04	 add	 esp, 4
$LN5@P_LoadSegs:

; 371  : 	segs = Z_Calloc(numsegs * sizeof (*segs), PU_LEVEL, NULL);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 32		 push	 50			; 00000032H
  0003f	6b 05 00 00 00
	00 3c		 imul	 eax, DWORD PTR _numsegs, 60
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _Z_CallocAlign
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
  0004f	a3 00 00 00 00	 mov	 DWORD PTR _segs, eax

; 372  : 	data = W_CacheLumpNum(lumpnum, PU_STATIC);

  00054	6a 01		 push	 1
  00056	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0005f	83 c4 08	 add	 esp, 8
  00062	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 373  : 
; 374  : 	ml = (mapseg_t *)data;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00068	89 45 ec	 mov	 DWORD PTR _ml$[ebp], eax

; 375  : 	li = segs;

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _segs
  00070	89 45 e8	 mov	 DWORD PTR _li$[ebp], eax

; 376  : 	for (i = 0; i < numsegs; i++, li++, ml++)

  00073	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007a	eb 1b		 jmp	 SHORT $LN4@P_LoadSegs
$LN2@P_LoadSegs:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00085	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  00088	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0008b	89 4d e8	 mov	 DWORD PTR _li$[ebp], ecx
  0008e	8b 55 ec	 mov	 edx, DWORD PTR _ml$[ebp]
  00091	83 c2 0c	 add	 edx, 12			; 0000000cH
  00094	89 55 ec	 mov	 DWORD PTR _ml$[ebp], edx
$LN4@P_LoadSegs:
  00097	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsegs
  000a0	0f 83 35 01 00
	00		 jae	 $LN3@P_LoadSegs

; 377  : 	{
; 378  : 		li->v1 = &vertexes[SHORT(ml->v1)];

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _ml$[ebp]
  000a9	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000ac	6b d1 0c	 imul	 edx, ecx, 12
  000af	03 15 00 00 00
	00		 add	 edx, DWORD PTR _vertexes
  000b5	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  000b8	89 10		 mov	 DWORD PTR [eax], edx

; 379  : 		li->v2 = &vertexes[SHORT(ml->v2)];

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _ml$[ebp]
  000bd	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000c1	6b d1 0c	 imul	 edx, ecx, 12
  000c4	03 15 00 00 00
	00		 add	 edx, DWORD PTR _vertexes
  000ca	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  000cd	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 380  : 
; 381  : #ifdef HWRENDER // not win32 only 19990829 by Kin
; 382  : 		// used for the hardware render
; 383  : 		if (rendermode != render_soft && rendermode != render_none)

  000d0	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000d7	74 25		 je	 SHORT $LN6@P_LoadSegs
  000d9	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  000e0	74 1c		 je	 SHORT $LN6@P_LoadSegs

; 384  : 		{
; 385  : 			li->flength = P_SegLengthf(li);

  000e2	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _P_SegLengthf
  000eb	83 c4 04	 add	 esp, 4
  000ee	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  000f1	d9 59 24	 fstp	 DWORD PTR [ecx+36]

; 386  : 			//Hurdler: 04/12/2000: for now, only used in hardware mode
; 387  : 			li->lightmaps = NULL; // list of static lightmap for this seg

  000f4	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  000f7	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN6@P_LoadSegs:

; 388  : 		}
; 389  : #endif
; 390  : 
; 391  : 		li->angle = (SHORT(ml->angle))<<FRACBITS;

  000fe	8b 45 ec	 mov	 eax, DWORD PTR _ml$[ebp]
  00101	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00105	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00108	8b 55 e8	 mov	 edx, DWORD PTR _li$[ebp]
  0010b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 392  : 		li->offset = (SHORT(ml->offset))<<FRACBITS;

  0010e	8b 45 ec	 mov	 eax, DWORD PTR _ml$[ebp]
  00111	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00115	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00118	8b 55 e8	 mov	 edx, DWORD PTR _li$[ebp]
  0011b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 393  : 		linedef = SHORT(ml->linedef);

  0011e	8b 45 ec	 mov	 eax, DWORD PTR _ml$[ebp]
  00121	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00125	89 4d f4	 mov	 DWORD PTR _linedef$[ebp], ecx

; 394  : 		ldef = &lines[linedef];

  00128	6b 45 f4 4c	 imul	 eax, DWORD PTR _linedef$[ebp], 76
  0012c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00132	89 45 e4	 mov	 DWORD PTR _ldef$[ebp], eax

; 395  : 		li->linedef = ldef;

  00135	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  00138	8b 4d e4	 mov	 ecx, DWORD PTR _ldef$[ebp]
  0013b	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 396  : 		li->side = side = SHORT(ml->side);

  0013e	8b 45 ec	 mov	 eax, DWORD PTR _ml$[ebp]
  00141	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00145	89 4d f0	 mov	 DWORD PTR _side$[ebp], ecx
  00148	8b 55 e8	 mov	 edx, DWORD PTR _li$[ebp]
  0014b	8b 45 f0	 mov	 eax, DWORD PTR _side$[ebp]
  0014e	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 397  : 		li->sidedef = &sides[ldef->sidenum[side]];

  00151	8b 45 f0	 mov	 eax, DWORD PTR _side$[ebp]
  00154	8b 4d e4	 mov	 ecx, DWORD PTR _ldef$[ebp]
  00157	0f b7 54 41 16	 movzx	 edx, WORD PTR [ecx+eax*2+22]
  0015c	6b c2 1c	 imul	 eax, edx, 28
  0015f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sides
  00165	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  00168	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 398  : 		li->frontsector = sides[ldef->sidenum[side]].sector;

  0016b	8b 45 f0	 mov	 eax, DWORD PTR _side$[ebp]
  0016e	8b 4d e4	 mov	 ecx, DWORD PTR _ldef$[ebp]
  00171	0f b7 54 41 16	 movzx	 edx, WORD PTR [ecx+eax*2+22]
  00176	6b c2 1c	 imul	 eax, edx, 28
  00179	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  0017c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00182	8b 44 02 14	 mov	 eax, DWORD PTR [edx+eax+20]
  00186	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 399  : 		if (ldef-> flags & ML_TWOSIDED)

  00189	8b 45 e4	 mov	 eax, DWORD PTR _ldef$[ebp]
  0018c	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00190	83 e1 04	 and	 ecx, 4
  00193	74 23		 je	 SHORT $LN7@P_LoadSegs

; 400  : 			li->backsector = sides[ldef->sidenum[side^1]].sector;

  00195	8b 45 f0	 mov	 eax, DWORD PTR _side$[ebp]
  00198	83 f0 01	 xor	 eax, 1
  0019b	8b 4d e4	 mov	 ecx, DWORD PTR _ldef$[ebp]
  0019e	0f b7 54 41 16	 movzx	 edx, WORD PTR [ecx+eax*2+22]
  001a3	6b c2 1c	 imul	 eax, edx, 28
  001a6	8b 4d e8	 mov	 ecx, DWORD PTR _li$[ebp]
  001a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  001af	8b 44 02 14	 mov	 eax, DWORD PTR [edx+eax+20]
  001b3	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  001b6	eb 0a		 jmp	 SHORT $LN8@P_LoadSegs
$LN7@P_LoadSegs:

; 401  : 		else
; 402  : 			li->backsector = 0;

  001b8	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001bb	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
$LN8@P_LoadSegs:

; 403  : 
; 404  : 		li->numlights = 0;

  001c2	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001c5	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 405  : 		li->rlights = NULL;

  001cc	8b 45 e8	 mov	 eax, DWORD PTR _li$[ebp]
  001cf	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 406  : 	}

  001d6	e9 a1 fe ff ff	 jmp	 $LN2@P_LoadSegs
$LN3@P_LoadSegs:

; 407  : 
; 408  : 	Z_Free(data);

  001db	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _Z_Free
  001e4	83 c4 04	 add	 esp, 4

; 409  : }

  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
_P_LoadSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_SegLengthf
_TEXT	SEGMENT
tv134 = -76						; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_seg$ = 8						; size = 4
_P_SegLengthf PROC					; COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 344  : 	float dx, dy;
; 345  : 
; 346  : 	// make a vector (start at origin)
; 347  : 	dx = FIXED_TO_FLOAT(seg->v2->x - seg->v1->x);

  00009	8b 45 08	 mov	 eax, DWORD PTR _seg$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _seg$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	2b 08		 sub	 ecx, DWORD PTR [eax]
  00018	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0001c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00024	f3 0f 11 45 fc	 movss	 DWORD PTR _dx$[ebp], xmm0

; 348  : 	dy = FIXED_TO_FLOAT(seg->v2->y - seg->v1->y);

  00029	8b 45 08	 mov	 eax, DWORD PTR _seg$[ebp]
  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _seg$[ebp]
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00037	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0003a	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0003e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00046	f3 0f 11 45 f8	 movss	 DWORD PTR _dy$[ebp], xmm0

; 349  : 
; 350  : 	return (float)hypot(dx, dy);

  0004b	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _dy$[ebp]
  00050	83 ec 08	 sub	 esp, 8
  00053	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00058	f3 0f 5a 45 fc	 cvtss2sd xmm0, DWORD PTR _dx$[ebp]
  0005d	83 ec 08	 sub	 esp, 8
  00060	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00065	e8 00 00 00 00	 call	 _hypot
  0006a	83 c4 10	 add	 esp, 16			; 00000010H
  0006d	d9 5d b4	 fstp	 DWORD PTR tv134[ebp]
  00070	d9 45 b4	 fld	 DWORD PTR tv134[ebp]

; 351  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_P_SegLengthf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadVertexes
_TEXT	SEGMENT
_li$ = -16						; size = 4
_ml$ = -12						; size = 4
_i$ = -8						; size = 4
_data$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_LoadVertexes PROC					; COMDAT

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 288  : 	UINT8 *data;
; 289  : 	size_t i;
; 290  : 	mapvertex_t *ml;
; 291  : 	vertex_t *li;
; 292  : 
; 293  : 	// Determine number of lumps:
; 294  : 	//  total lump length / vertex record length.
; 295  : 	numvertexes = W_LumpLength(lumpnum) / sizeof (mapvertex_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _W_LumpLength
  00012	83 c4 04	 add	 esp, 4
  00015	c1 e8 02	 shr	 eax, 2
  00018	a3 00 00 00 00	 mov	 DWORD PTR _numvertexes, eax

; 296  : 
; 297  : 	if (numvertexes <= 0)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numvertexes, 0
  00024	77 0d		 ja	 SHORT $LN5@P_LoadVert

; 298  : 		I_Error("Level has no vertices"); // instead of crashing

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IDLKBOPF@Level?5has?5no?5vertices@
  0002b	e8 00 00 00 00	 call	 _I_Error
  00030	83 c4 04	 add	 esp, 4
$LN5@P_LoadVert:

; 299  : 
; 300  : 	// Allocate zone memory for buffer.
; 301  : 	vertexes = Z_Calloc(numvertexes * sizeof (*vertexes), PU_LEVEL, NULL);

  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 32		 push	 50			; 00000032H
  00039	6b 05 00 00 00
	00 0c		 imul	 eax, DWORD PTR _numvertexes, 12
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _Z_CallocAlign
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	a3 00 00 00 00	 mov	 DWORD PTR _vertexes, eax

; 302  : 
; 303  : 	// Load data into cache.
; 304  : 	data = W_CacheLumpNum(lumpnum, PU_STATIC);

  0004e	6a 01		 push	 1
  00050	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00059	83 c4 08	 add	 esp, 8
  0005c	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 305  : 
; 306  : 	ml = (mapvertex_t *)data;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00062	89 45 f4	 mov	 DWORD PTR _ml$[ebp], eax

; 307  : 	li = vertexes;

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _vertexes
  0006a	89 45 f0	 mov	 DWORD PTR _li$[ebp], eax

; 308  : 
; 309  : 	// Copy and convert vertex coordinates, internal representation as fixed.
; 310  : 	for (i = 0; i < numvertexes; i++, li++, ml++)

  0006d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00074	eb 1b		 jmp	 SHORT $LN4@P_LoadVert
$LN2@P_LoadVert:
  00076	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _li$[ebp]
  00082	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00085	89 4d f0	 mov	 DWORD PTR _li$[ebp], ecx
  00088	8b 55 f4	 mov	 edx, DWORD PTR _ml$[ebp]
  0008b	83 c2 04	 add	 edx, 4
  0008e	89 55 f4	 mov	 DWORD PTR _ml$[ebp], edx
$LN4@P_LoadVert:
  00091	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00094	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numvertexes
  0009a	73 20		 jae	 SHORT $LN3@P_LoadVert

; 311  : 	{
; 312  : 		li->x = SHORT(ml->x)<<FRACBITS;

  0009c	8b 45 f4	 mov	 eax, DWORD PTR _ml$[ebp]
  0009f	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000a2	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000a5	8b 55 f0	 mov	 edx, DWORD PTR _li$[ebp]
  000a8	89 0a		 mov	 DWORD PTR [edx], ecx

; 313  : 		li->y = SHORT(ml->y)<<FRACBITS;

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _ml$[ebp]
  000ad	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000b1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000b4	8b 55 f0	 mov	 edx, DWORD PTR _li$[ebp]
  000b7	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 314  : 	}

  000ba	eb ba		 jmp	 SHORT $LN2@P_LoadVert
$LN3@P_LoadVert:

; 315  : 
; 316  : 	// Free buffer memory.
; 317  : 	Z_Free(data);

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _Z_Free
  000c5	83 c4 04	 add	 esp, 4

; 318  : }

  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_P_LoadVertexes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadMapHeader
_TEXT	SEGMENT
$T1 = -84						; size = 4
_lumpnum$ = -16						; size = 4
_mapheader$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
_mapnum$ = 8						; size = 2
_P_LoadMapHeader PROC					; COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 263  : 	char mapheader[7];
; 264  : 	lumpnum_t lumpnum;
; 265  : 
; 266  : 	strncpy(mapheader, G_BuildMapName(mapnum), 5);

  00013	6a 05		 push	 5
  00015	0f bf 45 08	 movsx	 eax, WORD PTR _mapnum$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _G_BuildMapName
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	8d 4d f4	 lea	 ecx, DWORD PTR _mapheader$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _strncpy
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : 
; 268  : 	mapheader[5] = 'D'; // New header

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	6b c8 05	 imul	 ecx, eax, 5
  00037	c6 44 0d f4 44	 mov	 BYTE PTR _mapheader$[ebp+ecx], 68 ; 00000044H

; 269  : 	mapheader[6] = '\0';

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	6b c8 06	 imul	 ecx, eax, 6
  00044	89 4d ac	 mov	 DWORD PTR $T1[ebp], ecx
  00047	83 7d ac 07	 cmp	 DWORD PTR $T1[ebp], 7
  0004b	73 02		 jae	 SHORT $LN4@P_LoadMapH
  0004d	eb 06		 jmp	 SHORT $LN5@P_LoadMapH
$LN4@P_LoadMapH:
  0004f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00054	90		 npad	 1
$LN5@P_LoadMapH:
  00055	8b 55 ac	 mov	 edx, DWORD PTR $T1[ebp]
  00058	c6 44 15 f4 00	 mov	 BYTE PTR _mapheader$[ebp+edx], 0

; 270  : 
; 271  : 	lumpnum = W_CheckNumForName(mapheader);

  0005d	8d 45 f4	 lea	 eax, DWORD PTR _mapheader$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _W_CheckNumForName
  00066	83 c4 04	 add	 esp, 4
  00069	89 45 f0	 mov	 DWORD PTR _lumpnum$[ebp], eax

; 272  : 
; 273  : 	if (!(lumpnum == LUMPERROR || W_LumpLength(lumpnum) == 0))

  0006c	83 7d f0 ff	 cmp	 DWORD PTR _lumpnum$[ebp], -1
  00070	74 29		 je	 SHORT $LN2@P_LoadMapH
  00072	8b 45 f0	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _W_LumpLength
  0007b	83 c4 04	 add	 esp, 4
  0007e	85 c0		 test	 eax, eax
  00080	74 19		 je	 SHORT $LN2@P_LoadMapH

; 274  : 	{
; 275  : 		P_ClearSingleMapHeaderInfo(mapnum);

  00082	0f b7 45 08	 movzx	 eax, WORD PTR _mapnum$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _P_ClearSingleMapHeaderInfo
  0008c	83 c4 04	 add	 esp, 4

; 276  : 		DEH_LoadDehackedLump(lumpnum);

  0008f	8b 45 f0	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _DEH_LoadDehackedLump
  00098	83 c4 04	 add	 esp, 4
$LN2@P_LoadMapH:

; 277  : 		return;
; 278  : 	}
; 279  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_P_LoadMapHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_ClearSingleMapHeaderInfo
_TEXT	SEGMENT
_num$ = -4						; size = 2
_i$ = 8							; size = 2
_P_ClearSingleMapHeaderInfo PROC			; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 164  : 	const INT16 num = (INT16)(i-1);

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _i$[ebp]
  0000d	83 e8 01	 sub	 eax, 1
  00010	66 89 45 fc	 mov	 WORD PTR _num$[ebp], ax

; 165  : 	DEH_WriteUndoline("LEVELNAME", mapheaderinfo[num].lvlttl, UNDO_NONE);

  00014	6a 00		 push	 0
  00016	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0001a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00020	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00026	51		 push	 ecx
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_09MADBCAME@LEVELNAME@
  0002c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 166  : 	mapheaderinfo[num].lvlttl[0] = '\0';

  00034	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00038	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0003e	ba 01 00 00 00	 mov	 edx, 1
  00043	6b c2 00	 imul	 eax, edx, 0
  00046	c6 84 01 00 00
	00 00 00	 mov	 BYTE PTR _mapheaderinfo[ecx+eax], 0

; 167  : 	DEH_WriteUndoline("SUBTITLE", mapheaderinfo[num].subttl, UNDO_NONE);

  0004e	6a 00		 push	 0
  00050	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00054	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0005a	81 c1 21 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+33
  00060	51		 push	 ecx
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_08OOGGCINI@SUBTITLE@
  00066	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 168  : 	mapheaderinfo[num].subttl[0] = '\0';

  0006e	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00072	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00078	ba 01 00 00 00	 mov	 edx, 1
  0007d	6b c2 00	 imul	 eax, edx, 0
  00080	c6 84 01 21 00
	00 00 00	 mov	 BYTE PTR _mapheaderinfo[ecx+eax+33], 0

; 169  : 	DEH_WriteUndoline("ACT", va("%d", mapheaderinfo[num].actnum), UNDO_NONE);

  00088	6a 00		 push	 0
  0008a	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0008e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00094	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  0009b	52		 push	 edx
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000a1	e8 00 00 00 00	 call	 _va
  000a6	83 c4 08	 add	 esp, 8
  000a9	50		 push	 eax
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_03FBBILEHC@ACT@
  000af	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 170  : 	mapheaderinfo[num].actnum = 0;

  000b7	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  000bb	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  000c1	c6 81 42 00 00
	00 00		 mov	 BYTE PTR _mapheaderinfo[ecx+66], 0

; 171  : 	DEH_WriteUndoline("TYPEOFLEVEL", va("%d", mapheaderinfo[num].typeoflevel), UNDO_NONE);

  000c8	6a 00		 push	 0
  000ca	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  000ce	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  000d4	0f bf 91 44 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+68]
  000db	52		 push	 edx
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000e1	e8 00 00 00 00	 call	 _va
  000e6	83 c4 08	 add	 esp, 8
  000e9	50		 push	 eax
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GOKBOJDC@TYPEOFLEVEL@
  000ef	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 	mapheaderinfo[num].typeoflevel = 0;

  000f7	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  000fb	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00101	33 d2		 xor	 edx, edx
  00103	66 89 91 44 00
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+68], dx

; 173  : 	DEH_WriteUndoline("NEXTLEVEL", va("%d", mapheaderinfo[num].nextlevel), UNDO_NONE);

  0010a	6a 00		 push	 0
  0010c	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00110	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00116	0f bf 91 46 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+70]
  0011d	52		 push	 edx
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00123	e8 00 00 00 00	 call	 _va
  00128	83 c4 08	 add	 esp, 8
  0012b	50		 push	 eax
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_09HFCIMBHH@NEXTLEVEL@
  00131	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 174  : 	mapheaderinfo[num].nextlevel = (INT16)(i + 1);

  00139	0f bf 45 08	 movsx	 eax, WORD PTR _i$[ebp]
  0013d	83 c0 01	 add	 eax, 1
  00140	0f bf 4d fc	 movsx	 ecx, WORD PTR _num$[ebp]
  00144	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  0014a	66 89 82 46 00
	00 00		 mov	 WORD PTR _mapheaderinfo[edx+70], ax

; 175  : 	DEH_WriteUndoline("MUSICSLOT", va("%d", mapheaderinfo[num].musicslot), UNDO_NONE);

  00151	6a 00		 push	 0
  00153	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00157	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0015d	8b 91 48 00 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+72]
  00163	52		 push	 edx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00169	e8 00 00 00 00	 call	 _va
  0016e	83 c4 08	 add	 esp, 8
  00171	50		 push	 eax
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_09MHGCKDNO@MUSICSLOT@
  00177	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 176  : 	mapheaderinfo[num].musicslot = mus_map01m + num;

  0017f	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00183	83 c0 01	 add	 eax, 1
  00186	0f bf 4d fc	 movsx	 ecx, WORD PTR _num$[ebp]
  0018a	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  00190	89 82 48 00 00
	00		 mov	 DWORD PTR _mapheaderinfo[edx+72], eax

; 177  : 	DEH_WriteUndoline("FORCECHARACTER", va("%d", mapheaderinfo[num].forcecharacter), UNDO_NONE);

  00196	6a 00		 push	 0
  00198	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0019c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001a2	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  001a9	52		 push	 edx
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001af	e8 00 00 00 00	 call	 _va
  001b4	83 c4 08	 add	 esp, 8
  001b7	50		 push	 eax
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HOGKHGAO@FORCECHARACTER@
  001bd	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 178  : 	mapheaderinfo[num].forcecharacter = 255;

  001c5	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  001c9	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001cf	c6 81 4c 00 00
	00 ff		 mov	 BYTE PTR _mapheaderinfo[ecx+76], 255 ; 000000ffH

; 179  : 	DEH_WriteUndoline("WEATHER", va("%d", mapheaderinfo[num].weather), UNDO_NONE);

  001d6	6a 00		 push	 0
  001d8	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  001dc	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001e2	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  001e9	52		 push	 edx
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001ef	e8 00 00 00 00	 call	 _va
  001f4	83 c4 08	 add	 esp, 8
  001f7	50		 push	 eax
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_07HKOGDAHK@WEATHER@
  001fd	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00202	83 c4 0c	 add	 esp, 12			; 0000000cH

; 180  : 	mapheaderinfo[num].weather = 0;

  00205	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00209	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0020f	c6 81 4d 00 00
	00 00		 mov	 BYTE PTR _mapheaderinfo[ecx+77], 0

; 181  : 	DEH_WriteUndoline("SKYNUM", va("%d", mapheaderinfo[num].skynum), UNDO_NONE);

  00216	6a 00		 push	 0
  00218	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0021c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00222	0f bf 91 4e 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+78]
  00229	52		 push	 edx
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0022f	e8 00 00 00 00	 call	 _va
  00234	83 c4 08	 add	 esp, 8
  00237	50		 push	 eax
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_06HEFJHGKD@SKYNUM@
  0023d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH

; 182  : 	mapheaderinfo[num].skynum = i;

  00245	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00249	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0024f	66 8b 55 08	 mov	 dx, WORD PTR _i$[ebp]
  00253	66 89 91 4e 00
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+78], dx

; 183  : 	DEH_WriteUndoline("INTERSCREEN", mapheaderinfo[num].interscreen, UNDO_NONE);

  0025a	6a 00		 push	 0
  0025c	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00260	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00266	81 c1 50 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+80
  0026c	51		 push	 ecx
  0026d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PDGEIADF@INTERSCREEN@
  00272	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00277	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 	mapheaderinfo[num].interscreen[0] = '#';

  0027a	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0027e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00284	ba 01 00 00 00	 mov	 edx, 1
  00289	6b c2 00	 imul	 eax, edx, 0
  0028c	c6 84 01 50 00
	00 00 23	 mov	 BYTE PTR _mapheaderinfo[ecx+eax+80], 35 ; 00000023H

; 185  : 	DEH_WriteUndoline("SCRIPTNAME", mapheaderinfo[num].scriptname, UNDO_NONE);

  00294	6a 00		 push	 0
  00296	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0029a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002a0	81 c1 58 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+88
  002a6	51		 push	 ecx
  002a7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OPDCCGFG@SCRIPTNAME@
  002ac	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  002b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 	mapheaderinfo[num].scriptname[0] = '#';

  002b4	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  002b8	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002be	ba 01 00 00 00	 mov	 edx, 1
  002c3	6b c2 00	 imul	 eax, edx, 0
  002c6	c6 84 01 58 00
	00 00 23	 mov	 BYTE PTR _mapheaderinfo[ecx+eax+88], 35 ; 00000023H

; 187  : 	DEH_WriteUndoline("SCRIPTISLUMP", va("%d", mapheaderinfo[num].scriptislump), UNDO_NONE);

  002ce	6a 00		 push	 0
  002d0	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  002d4	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002da	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+280]
  002e0	52		 push	 edx
  002e1	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  002e6	e8 00 00 00 00	 call	 _va
  002eb	83 c4 08	 add	 esp, 8
  002ee	50		 push	 eax
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BKNFDAOL@SCRIPTISLUMP@
  002f4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  002f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  : 	mapheaderinfo[num].scriptislump = false;

  002fc	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00300	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00306	c7 81 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+280], 0

; 189  : 	DEH_WriteUndoline("PRECUTSCENENUM", va("%d", mapheaderinfo[num].precutscenenum), UNDO_NONE);

  00310	6a 00		 push	 0
  00312	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00316	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0031c	0f b6 91 1c 01
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+284]
  00323	52		 push	 edx
  00324	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00329	e8 00 00 00 00	 call	 _va
  0032e	83 c4 08	 add	 esp, 8
  00331	50		 push	 eax
  00332	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DFENKLKN@PRECUTSCENENUM@
  00337	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0033c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  : 	mapheaderinfo[num].precutscenenum = 0;

  0033f	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00343	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00349	c6 81 1c 01 00
	00 00		 mov	 BYTE PTR _mapheaderinfo[ecx+284], 0

; 191  : 	DEH_WriteUndoline("CUTSCENENUM", va("%d", mapheaderinfo[num].cutscenenum), UNDO_NONE);

  00350	6a 00		 push	 0
  00352	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00356	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0035c	0f b6 91 1d 01
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+285]
  00363	52		 push	 edx
  00364	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00369	e8 00 00 00 00	 call	 _va
  0036e	83 c4 08	 add	 esp, 8
  00371	50		 push	 eax
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HBBFKHJP@CUTSCENENUM@
  00377	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0037c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 192  : 	mapheaderinfo[num].cutscenenum = 0;

  0037f	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00383	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00389	c6 81 1d 01 00
	00 00		 mov	 BYTE PTR _mapheaderinfo[ecx+285], 0

; 193  : 	DEH_WriteUndoline("COUNTDOWN", va("%d", mapheaderinfo[num].countdown), UNDO_NONE);

  00390	6a 00		 push	 0
  00392	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00396	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0039c	0f bf 91 1e 01
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+286]
  003a3	52		 push	 edx
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  003a9	e8 00 00 00 00	 call	 _va
  003ae	83 c4 08	 add	 esp, 8
  003b1	50		 push	 eax
  003b2	68 00 00 00 00	 push	 OFFSET ??_C@_09JPDDLCMH@COUNTDOWN@
  003b7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  003bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  : 	mapheaderinfo[num].countdown = 0;

  003bf	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  003c3	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  003c9	33 d2		 xor	 edx, edx
  003cb	66 89 91 1e 01
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+286], dx

; 195  : 	DEH_WriteUndoline("NOZONE", va("%d", mapheaderinfo[num].nozone), UNDO_NONE);

  003d2	6a 00		 push	 0
  003d4	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  003d8	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  003de	8b 91 20 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+288]
  003e4	52		 push	 edx
  003e5	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  003ea	e8 00 00 00 00	 call	 _va
  003ef	83 c4 08	 add	 esp, 8
  003f2	50		 push	 eax
  003f3	68 00 00 00 00	 push	 OFFSET ??_C@_06MOHHBCJH@NOZONE@
  003f8	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  003fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 	mapheaderinfo[num].nozone = false;

  00400	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00404	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0040a	c7 81 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+288], 0

; 197  : 	DEH_WriteUndoline("HIDDEN", va("%d", mapheaderinfo[num].hideinmenu), UNDO_NONE);

  00414	6a 00		 push	 0
  00416	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0041a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00420	8b 91 24 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+292]
  00426	52		 push	 edx
  00427	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0042c	e8 00 00 00 00	 call	 _va
  00431	83 c4 08	 add	 esp, 8
  00434	50		 push	 eax
  00435	68 00 00 00 00	 push	 OFFSET ??_C@_06JMIOFMHI@HIDDEN@
  0043a	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0043f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  : 	mapheaderinfo[num].hideinmenu = false;

  00442	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00446	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0044c	c7 81 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+292], 0

; 199  : 	DEH_WriteUndoline("NOSSMUSIC", va("%d", mapheaderinfo[num].nossmusic), UNDO_NONE);

  00456	6a 00		 push	 0
  00458	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0045c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00462	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+296]
  00468	52		 push	 edx
  00469	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0046e	e8 00 00 00 00	 call	 _va
  00473	83 c4 08	 add	 esp, 8
  00476	50		 push	 eax
  00477	68 00 00 00 00	 push	 OFFSET ??_C@_09GKCLDIIP@NOSSMUSIC@
  0047c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00481	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 	mapheaderinfo[num].nossmusic = false;

  00484	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00488	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0048e	c7 81 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+296], 0

; 201  : 	DEH_WriteUndoline("SPEEDMUSIC", va("%d", mapheaderinfo[num].speedmusic), UNDO_NONE);

  00498	6a 00		 push	 0
  0049a	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0049e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  004a4	8b 91 2c 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+300]
  004aa	52		 push	 edx
  004ab	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004b0	e8 00 00 00 00	 call	 _va
  004b5	83 c4 08	 add	 esp, 8
  004b8	50		 push	 eax
  004b9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHJOPLBJ@SPEEDMUSIC@
  004be	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  004c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 	mapheaderinfo[num].speedmusic = false;

  004c6	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  004ca	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  004d0	c7 81 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+300], 0

; 203  : 	DEH_WriteUndoline("NORELOAD", va("%d", mapheaderinfo[num].noreload), UNDO_NONE);

  004da	6a 00		 push	 0
  004dc	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  004e0	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  004e6	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+304]
  004ec	52		 push	 edx
  004ed	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004f2	e8 00 00 00 00	 call	 _va
  004f7	83 c4 08	 add	 esp, 8
  004fa	50		 push	 eax
  004fb	68 00 00 00 00	 push	 OFFSET ??_C@_08KPPNBABB@NORELOAD@
  00500	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00505	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 	mapheaderinfo[num].noreload = false;

  00508	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0050c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00512	c7 81 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+304], 0

; 205  : 	DEH_WriteUndoline("TIMEATTACK", va("%d", mapheaderinfo[num].timeattack), UNDO_NONE);

  0051c	6a 00		 push	 0
  0051e	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00522	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00528	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+308]
  0052e	52		 push	 edx
  0052f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00534	e8 00 00 00 00	 call	 _va
  00539	83 c4 08	 add	 esp, 8
  0053c	50		 push	 eax
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IKBJCDCO@TIMEATTACK@
  00542	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00547	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  : 	mapheaderinfo[num].timeattack = false;

  0054a	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0054e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00554	c7 81 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+308], 0

; 207  : 	DEH_WriteUndoline("LEVELSELECT", va("%d", mapheaderinfo[num].levelselect), UNDO_NONE);

  0055e	6a 00		 push	 0
  00560	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00564	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0056a	8b 91 38 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+312]
  00570	52		 push	 edx
  00571	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00576	e8 00 00 00 00	 call	 _va
  0057b	83 c4 08	 add	 esp, 8
  0057e	50		 push	 eax
  0057f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JIALMPNC@LEVELSELECT@
  00584	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00589	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  : 	mapheaderinfo[num].levelselect = false;

  0058c	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  00590	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00596	c7 81 38 01 00
	00 00 00 00 00	 mov	 DWORD PTR _mapheaderinfo[ecx+312], 0

; 209  : 	DEH_WriteUndoline("RUNSOC", mapheaderinfo[num].runsoc, UNDO_NONE);

  005a0	6a 00		 push	 0
  005a2	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  005a6	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  005ac	81 c1 40 01 00
	00		 add	 ecx, OFFSET _mapheaderinfo+320
  005b2	51		 push	 ecx
  005b3	68 00 00 00 00	 push	 OFFSET ??_C@_06BEHDNBAE@RUNSOC@
  005b8	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  : 	mapheaderinfo[num].runsoc[0] = '#';

  005c0	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  005c4	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  005ca	ba 01 00 00 00	 mov	 edx, 1
  005cf	6b c2 00	 imul	 eax, edx, 0
  005d2	c6 84 01 40 01
	00 00 23	 mov	 BYTE PTR _mapheaderinfo[ecx+eax+320], 35 ; 00000023H

; 211  : 	DEH_WriteUndoline(va("# uload for map %d", i), NULL, UNDO_DONE);

  005da	6a 00		 push	 0
  005dc	6a 00		 push	 0
  005de	0f bf 45 08	 movsx	 eax, WORD PTR _i$[ebp]
  005e2	50		 push	 eax
  005e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NCJFJPLM@?$CD?5uload?5for?5map?5?$CFd@
  005e8	e8 00 00 00 00	 call	 _va
  005ed	83 c4 08	 add	 esp, 8
  005f0	50		 push	 eax
  005f1	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 212  : 	DEH_WriteUndoline("PALLETE", va("%u", mapheaderinfo[num].palette), UNDO_NONE);

  005f9	6a 00		 push	 0
  005fb	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  005ff	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00605	0f b7 91 80 01
	00 00		 movzx	 edx, WORD PTR _mapheaderinfo[ecx+384]
  0060c	52		 push	 edx
  0060d	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00612	e8 00 00 00 00	 call	 _va
  00617	83 c4 08	 add	 esp, 8
  0061a	50		 push	 eax
  0061b	68 00 00 00 00	 push	 OFFSET ??_C@_07ICGPEHOB@PALLETE@
  00620	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00625	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  : 	mapheaderinfo[num].palette = UINT16_MAX;

  00628	0f bf 45 fc	 movsx	 eax, WORD PTR _num$[ebp]
  0062c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00632	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00637	66 89 91 80 01
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+384], dx

; 214  : }

  0063e	5f		 pop	 edi
  0063f	5e		 pop	 esi
  00640	5b		 pop	 ebx
  00641	8b e5		 mov	 esp, ebp
  00643	5d		 pop	 ebp
  00644	c3		 ret	 0
_P_ClearSingleMapHeaderInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _CorruptMapError
_TEXT	SEGMENT
_mapnum$ = -12						; size = 10
_msg$ = 8						; size = 4
_CorruptMapError PROC					; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 145  : 	// don't use va() because the calling function probably uses it
; 146  : 	char mapnum[10];
; 147  : 
; 148  : 	sprintf(mapnum, "%hd", gamemap);

  00009	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_03OACELNE@?$CFhd@
  00016	8d 4d f4	 lea	 ecx, DWORD PTR _mapnum$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _sprintf
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 	CON_LogMessage("Map ");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_04NLFBEIIO@Map?5@
  00027	e8 00 00 00 00	 call	 _CON_LogMessage
  0002c	83 c4 04	 add	 esp, 4

; 150  : 	CON_LogMessage(mapnum);

  0002f	8d 45 f4	 lea	 eax, DWORD PTR _mapnum$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _CON_LogMessage
  00038	83 c4 04	 add	 esp, 4

; 151  : 	CON_LogMessage(" is corrupt: ");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GJJOFLPO@?5is?5corrupt?3?5@
  00040	e8 00 00 00 00	 call	 _CON_LogMessage
  00045	83 c4 04	 add	 esp, 4

; 152  : 	CON_LogMessage(msg);

  00048	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _CON_LogMessage
  00051	83 c4 04	 add	 esp, 4

; 153  : 	CON_LogMessage("\n");

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00059	e8 00 00 00 00	 call	 _CON_LogMessage
  0005e	83 c4 04	 add	 esp, 4

; 154  : 	I_Error("Invalid or corrupt map.\nLook in log file or text console for technical details.");

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@HIKBONJC@Invalid?5or?5corrupt?5map?4?6Look?5in@
  00066	e8 00 00 00 00	 call	 _I_Error
  0006b	83 c4 04	 add	 esp, 4

; 155  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_CorruptMapError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_SegLength
_TEXT	SEGMENT
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_seg$ = 8						; size = 4
_P_SegLength PROC					; COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 332  : 	fixed_t dx, dy;
; 333  : 
; 334  : 	// make a vector (start at origin)
; 335  : 	dx = seg->v2->x - seg->v1->x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _seg$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _seg$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	2b 08		 sub	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR _dx$[ebp], ecx

; 336  : 	dy = seg->v2->y - seg->v1->y;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _seg$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	8b 55 08	 mov	 edx, DWORD PTR _seg$[ebp]
  00024	8b 02		 mov	 eax, DWORD PTR [edx]
  00026	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00029	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0002c	89 4d f8	 mov	 DWORD PTR _dy$[ebp], ecx

; 337  : 
; 338  : 	return FixedHypot(dx, dy);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _dy$[ebp]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _dx$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _FixedHypot
  0003c	83 c4 08	 add	 esp, 8

; 339  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_P_SegLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_ClearMapHeaderInfo
_TEXT	SEGMENT
_i$ = -4						; size = 2
_P_ClearMapHeaderInfo PROC				; COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 222  : 	INT16 i;
; 223  : 
; 224  : 	for (i = 1; i <= NUMMAPS; i++)

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
  00012	eb 0c		 jmp	 SHORT $LN4@P_ClearMap
$LN2@P_ClearMap:
  00014	66 8b 45 fc	 mov	 ax, WORD PTR _i$[ebp]
  00018	66 83 c0 01	 add	 ax, 1
  0001c	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
$LN4@P_ClearMap:
  00020	0f bf 45 fc	 movsx	 eax, WORD PTR _i$[ebp]
  00024	3d 0b 04 00 00	 cmp	 eax, 1035		; 0000040bH
  00029	7f 0f		 jg	 SHORT $LN3@P_ClearMap

; 225  : 		P_ClearSingleMapHeaderInfo(i);

  0002b	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _P_ClearSingleMapHeaderInfo
  00035	83 c4 04	 add	 esp, 4
  00038	eb da		 jmp	 SHORT $LN2@P_ClearMap
$LN3@P_ClearMap:

; 226  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_P_ClearMapHeaderInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_InitMapHeaders
_TEXT	SEGMENT
$T1 = -92						; size = 4
_mapnum$ = -24						; size = 4
_moremapnumbers$ = -20					; size = 4
_lumpnum$ = -16						; size = 4
_mapheader$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
_P_InitMapHeaders PROC					; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 236  : 	char mapheader[7];
; 237  : 	lumpnum_t lumpnum;
; 238  : 	INT32 moremapnumbers, mapnum;
; 239  : 
; 240  : 	for (mapnum = 1; mapnum <= NUMMAPS; mapnum++)

  00013	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _mapnum$[ebp], 1
  0001a	eb 09		 jmp	 SHORT $LN4@P_InitMapH
$LN2@P_InitMapH:
  0001c	8b 45 e8	 mov	 eax, DWORD PTR _mapnum$[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 e8	 mov	 DWORD PTR _mapnum$[ebp], eax
$LN4@P_InitMapH:
  00025	81 7d e8 0b 04
	00 00		 cmp	 DWORD PTR _mapnum$[ebp], 1035 ; 0000040bH
  0002c	0f 8f 88 00 00
	00		 jg	 $LN3@P_InitMapH

; 241  : 	{
; 242  : 		moremapnumbers = mapnum - 1;

  00032	8b 45 e8	 mov	 eax, DWORD PTR _mapnum$[ebp]
  00035	83 e8 01	 sub	 eax, 1
  00038	89 45 ec	 mov	 DWORD PTR _moremapnumbers$[ebp], eax

; 243  : 
; 244  : 		strncpy(mapheader, G_BuildMapName(mapnum), 5);

  0003b	6a 05		 push	 5
  0003d	8b 45 e8	 mov	 eax, DWORD PTR _mapnum$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _G_BuildMapName
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	8d 4d f4	 lea	 ecx, DWORD PTR _mapheader$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _strncpy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 245  : 
; 246  : 		mapheader[5] = 'D'; // New header

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	6b c8 05	 imul	 ecx, eax, 5
  0005e	c6 44 0d f4 44	 mov	 BYTE PTR _mapheader$[ebp+ecx], 68 ; 00000044H

; 247  : 		mapheader[6] = '\0';

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	6b c8 06	 imul	 ecx, eax, 6
  0006b	89 4d a4	 mov	 DWORD PTR $T1[ebp], ecx
  0006e	83 7d a4 07	 cmp	 DWORD PTR $T1[ebp], 7
  00072	73 02		 jae	 SHORT $LN7@P_InitMapH
  00074	eb 06		 jmp	 SHORT $LN8@P_InitMapH
$LN7@P_InitMapH:
  00076	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0007b	90		 npad	 1
$LN8@P_InitMapH:
  0007c	8b 55 a4	 mov	 edx, DWORD PTR $T1[ebp]
  0007f	c6 44 15 f4 00	 mov	 BYTE PTR _mapheader$[ebp+edx], 0

; 248  : 
; 249  : 		lumpnum = W_CheckNumForName(mapheader);

  00084	8d 45 f4	 lea	 eax, DWORD PTR _mapheader$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _W_CheckNumForName
  0008d	83 c4 04	 add	 esp, 4
  00090	89 45 f0	 mov	 DWORD PTR _lumpnum$[ebp], eax

; 250  : 
; 251  : 		if (!(lumpnum == LUMPERROR || W_LumpLength(lumpnum) == 0))

  00093	83 7d f0 ff	 cmp	 DWORD PTR _lumpnum$[ebp], -1
  00097	74 1c		 je	 SHORT $LN5@P_InitMapH
  00099	8b 45 f0	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _W_LumpLength
  000a2	83 c4 04	 add	 esp, 4
  000a5	85 c0		 test	 eax, eax
  000a7	74 0c		 je	 SHORT $LN5@P_InitMapH

; 252  : 			DEH_LoadDehackedLump(lumpnum);

  000a9	8b 45 f0	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _DEH_LoadDehackedLump
  000b2	83 c4 04	 add	 esp, 4
$LN5@P_InitMapH:

; 253  : 	}

  000b5	e9 62 ff ff ff	 jmp	 $LN2@P_InitMapH
$LN3@P_InitMapH:

; 254  : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	33 cd		 xor	 ecx, ebp
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
_P_InitMapHeaders ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_PrecacheLevelFlats
_TEXT	SEGMENT
_flatmemory$ = -12					; size = 4
_i$ = -8						; size = 4
_lump$ = -4						; size = 4
_P_PrecacheLevelFlats PROC				; COMDAT

; 459  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 460  : 	lumpnum_t lump;
; 461  : 	size_t i, flatmemory = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _flatmemory$[ebp], 0

; 462  : 
; 463  : 	//SoM: 4/18/2000: New flat code to make use of levelflats.
; 464  : 	for (i = 0; i < numlevelflats; i++)

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@P_Precache
$LN2@P_Precache:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_Precache:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00025	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlevelflats
  0002b	73 3c		 jae	 SHORT $LN3@P_Precache

; 465  : 	{
; 466  : 		lump = levelflats[i].lumpnum;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00030	c1 e0 05	 shl	 eax, 5
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _levelflats
  00039	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0003d	89 55 fc	 mov	 DWORD PTR _lump$[ebp], edx

; 467  : 		if (devparm)

  00040	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00047	74 12		 je	 SHORT $LN5@P_Precache

; 468  : 			flatmemory += W_LumpLength(lump);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _lump$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _W_LumpLength
  00052	83 c4 04	 add	 esp, 4
  00055	03 45 f4	 add	 eax, DWORD PTR _flatmemory$[ebp]
  00058	89 45 f4	 mov	 DWORD PTR _flatmemory$[ebp], eax
$LN5@P_Precache:

; 469  : 		R_GetFlat(lump);

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _lump$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _R_GetFlat
  00064	83 c4 04	 add	 esp, 4

; 470  : 	}

  00067	eb b0		 jmp	 SHORT $LN2@P_Precache
$LN3@P_Precache:

; 471  : 	return flatmemory;

  00069	8b 45 f4	 mov	 eax, DWORD PTR _flatmemory$[ebp]

; 472  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_P_PrecacheLevelFlats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_WriteThings
_TEXT	SEGMENT
_p_tmp$1 = -52						; size = 4
_p_tmp$2 = -48						; size = 4
_p_tmp$3 = -44						; size = 4
_p_tmp$4 = -40						; size = 4
_p_tmp$5 = -36						; size = 4
_temp$ = -32						; size = 2
_savebuf_p$ = -28					; size = 4
_savebuffer$ = -24					; size = 4
_datastart$ = -20					; size = 4
_data$ = -16						; size = 4
_mt$ = -12						; size = 4
_length$ = -8						; size = 4
_i$ = -4						; size = 4
_lumpnum$ = 8						; size = 4
_P_WriteThings PROC					; COMDAT

; 868  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 869  : 	size_t i, length;
; 870  : 	mapthing_t *mt;
; 871  : 	UINT8 *data, *datastart;
; 872  : 	UINT8 *savebuffer, *savebuf_p;
; 873  : 	INT16 temp;
; 874  : 
; 875  : 	data = datastart = W_CacheLumpNum(lumpnum, PU_LEVEL);

  00009	6a 32		 push	 50			; 00000032H
  0000b	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 ec	 mov	 DWORD PTR _datastart$[ebp], eax
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _datastart$[ebp]
  0001d	89 4d f0	 mov	 DWORD PTR _data$[ebp], ecx

; 876  : 
; 877  : 	savebuf_p = savebuffer = (UINT8 *)malloc(nummapthings * sizeof (mapthing_t));

  00020	6b 05 00 00 00
	00 14		 imul	 eax, DWORD PTR _nummapthings, 20
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _malloc
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 e8	 mov	 DWORD PTR _savebuffer$[ebp], eax
  00033	8b 4d e8	 mov	 ecx, DWORD PTR _savebuffer$[ebp]
  00036	89 4d e4	 mov	 DWORD PTR _savebuf_p$[ebp], ecx

; 878  : 
; 879  : 	if (!savebuf_p)

  00039	83 7d e4 00	 cmp	 DWORD PTR _savebuf_p$[ebp], 0
  0003d	75 12		 jne	 SHORT $LN20@P_WriteThi

; 880  : 	{
; 881  : 		CONS_Printf("No more free memory for thingwriting!\n");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OAFMGKAJ@No?5more?5free?5memory?5for?5thingwr@
  00044	e8 00 00 00 00	 call	 _CONS_Printf
  00049	83 c4 04	 add	 esp, 4

; 882  : 		return;

  0004c	e9 6b 01 00 00	 jmp	 $LN1@P_WriteThi
$LN20@P_WriteThi:

; 883  : 	}
; 884  : 
; 885  : 	mt = mapthings;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapthings
  00056	89 45 f4	 mov	 DWORD PTR _mt$[ebp], eax

; 886  : 	for (i = 0; i < nummapthings; i++, mt++)

  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00060	eb 12		 jmp	 SHORT $LN4@P_WriteThi
$LN2@P_WriteThi:
  00062	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR _mt$[ebp]
  0006e	83 c1 14	 add	 ecx, 20			; 00000014H
  00071	89 4d f4	 mov	 DWORD PTR _mt$[ebp], ecx
$LN4@P_WriteThi:
  00074	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00077	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nummapthings
  0007d	0f 83 d6 00 00
	00		 jae	 $LN3@P_WriteThi
$LN7@P_WriteThi:

; 887  : 	{
; 888  : 		WRITEINT16(savebuf_p, mt->x);

  00083	8b 45 e4	 mov	 eax, DWORD PTR _savebuf_p$[ebp]
  00086	89 45 dc	 mov	 DWORD PTR _p_tmp$5[ebp], eax
  00089	8b 45 dc	 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _mt$[ebp]
  0008f	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00092	66 89 10	 mov	 WORD PTR [eax], dx
  00095	8b 45 dc	 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  00098	83 c0 02	 add	 eax, 2
  0009b	89 45 dc	 mov	 DWORD PTR _p_tmp$5[ebp], eax
  0009e	8b 45 dc	 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  000a1	89 45 e4	 mov	 DWORD PTR _savebuf_p$[ebp], eax
  000a4	33 c0		 xor	 eax, eax
  000a6	75 db		 jne	 SHORT $LN7@P_WriteThi
$LN6@P_WriteThi:

; 889  : 		WRITEINT16(savebuf_p, mt->y);

  000a8	8b 45 e4	 mov	 eax, DWORD PTR _savebuf_p$[ebp]
  000ab	89 45 d8	 mov	 DWORD PTR _p_tmp$4[ebp], eax
  000ae	8b 45 d8	 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _mt$[ebp]
  000b4	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  000b8	66 89 10	 mov	 WORD PTR [eax], dx
  000bb	8b 45 d8	 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  000be	83 c0 02	 add	 eax, 2
  000c1	89 45 d8	 mov	 DWORD PTR _p_tmp$4[ebp], eax
  000c4	8b 45 d8	 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  000c7	89 45 e4	 mov	 DWORD PTR _savebuf_p$[ebp], eax
  000ca	33 c0		 xor	 eax, eax
  000cc	75 da		 jne	 SHORT $LN6@P_WriteThi
$LN9@P_WriteThi:

; 890  : 
; 891  : 		WRITEINT16(savebuf_p, mt->angle);

  000ce	8b 45 e4	 mov	 eax, DWORD PTR _savebuf_p$[ebp]
  000d1	89 45 d4	 mov	 DWORD PTR _p_tmp$3[ebp], eax
  000d4	8b 45 d4	 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR _mt$[ebp]
  000da	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  000de	66 89 10	 mov	 WORD PTR [eax], dx
  000e1	8b 45 d4	 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  000e4	83 c0 02	 add	 eax, 2
  000e7	89 45 d4	 mov	 DWORD PTR _p_tmp$3[ebp], eax
  000ea	8b 45 d4	 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  000ed	89 45 e4	 mov	 DWORD PTR _savebuf_p$[ebp], eax
  000f0	33 c0		 xor	 eax, eax
  000f2	75 da		 jne	 SHORT $LN9@P_WriteThi

; 892  : 
; 893  : 		temp = (INT16)(mt->type + ((INT16)mt->extrainfo << 12));

  000f4	8b 45 f4	 mov	 eax, DWORD PTR _mt$[ebp]
  000f7	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  000fb	8b 55 f4	 mov	 edx, DWORD PTR _mt$[ebp]
  000fe	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00102	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00105	03 c8		 add	 ecx, eax
  00107	66 89 4d e0	 mov	 WORD PTR _temp$[ebp], cx
$LN16@P_WriteThi:

; 894  : 		WRITEINT16(savebuf_p, temp);

  0010b	8b 45 e4	 mov	 eax, DWORD PTR _savebuf_p$[ebp]
  0010e	89 45 d0	 mov	 DWORD PTR _p_tmp$2[ebp], eax
  00111	8b 45 d0	 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00114	66 8b 4d e0	 mov	 cx, WORD PTR _temp$[ebp]
  00118	66 89 08	 mov	 WORD PTR [eax], cx
  0011b	8b 45 d0	 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  0011e	83 c0 02	 add	 eax, 2
  00121	89 45 d0	 mov	 DWORD PTR _p_tmp$2[ebp], eax
  00124	8b 45 d0	 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00127	89 45 e4	 mov	 DWORD PTR _savebuf_p$[ebp], eax
  0012a	33 c0		 xor	 eax, eax
  0012c	75 dd		 jne	 SHORT $LN16@P_WriteThi
$LN15@P_WriteThi:

; 895  : 		WRITEUINT16(savebuf_p, mt->options);

  0012e	8b 45 e4	 mov	 eax, DWORD PTR _savebuf_p$[ebp]
  00131	89 45 cc	 mov	 DWORD PTR _p_tmp$1[ebp], eax
  00134	8b 45 cc	 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  00137	8b 4d f4	 mov	 ecx, DWORD PTR _mt$[ebp]
  0013a	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  0013e	66 89 10	 mov	 WORD PTR [eax], dx
  00141	8b 45 cc	 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  00144	83 c0 02	 add	 eax, 2
  00147	89 45 cc	 mov	 DWORD PTR _p_tmp$1[ebp], eax
  0014a	8b 45 cc	 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  0014d	89 45 e4	 mov	 DWORD PTR _savebuf_p$[ebp], eax
  00150	33 c0		 xor	 eax, eax
  00152	75 da		 jne	 SHORT $LN15@P_WriteThi

; 896  : 	}

  00154	e9 09 ff ff ff	 jmp	 $LN2@P_WriteThi
$LN3@P_WriteThi:

; 897  : 
; 898  : 	Z_Free(datastart);

  00159	8b 45 ec	 mov	 eax, DWORD PTR _datastart$[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _Z_Free
  00162	83 c4 04	 add	 esp, 4

; 899  : 
; 900  : 	length = savebuf_p - savebuffer;

  00165	8b 45 e4	 mov	 eax, DWORD PTR _savebuf_p$[ebp]
  00168	2b 45 e8	 sub	 eax, DWORD PTR _savebuffer$[ebp]
  0016b	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 901  : 
; 902  : 	FIL_WriteFile(va("newthings%d.lmp", gamemap), savebuffer, length);

  0016e	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]
  00171	50		 push	 eax
  00172	8b 4d e8	 mov	 ecx, DWORD PTR _savebuffer$[ebp]
  00175	51		 push	 ecx
  00176	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR _gamemap
  0017d	52		 push	 edx
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DADEGEMD@newthings?$CFd?4lmp@
  00183	e8 00 00 00 00	 call	 _va
  00188	83 c4 08	 add	 esp, 8
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _FIL_WriteFile
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH

; 903  : 	free(savebuffer);

  00194	8b 45 e8	 mov	 eax, DWORD PTR _savebuffer$[ebp]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _free
  0019d	83 c4 04	 add	 esp, 4

; 904  : 	savebuf_p = NULL;

  001a0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _savebuf_p$[ebp], 0

; 905  : 
; 906  : 	CONS_Printf("newthings%d.lmp saved.\n", gamemap);

  001a7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MICEHDEL@newthings?$CFd?4lmp?5saved?4?6@
  001b4	e8 00 00 00 00	 call	 _CONS_Printf
  001b9	83 c4 08	 add	 esp, 8
$LN1@P_WriteThi:

; 907  : }

  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_P_WriteThings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_RunSOC
_TEXT	SEGMENT
_lump$ = -4						; size = 4
_socfilename$ = 8					; size = 4
_P_RunSOC PROC						; COMDAT

; 2436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2437 : 	lumpnum_t lump;
; 2438 : 
; 2439 : 	if (strstr(socfilename, ".soc") != NULL)

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_04DDPNCCIM@?4soc@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _socfilename$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _strstr
  00017	83 c4 08	 add	 esp, 8
  0001a	85 c0		 test	 eax, eax
  0001c	74 10		 je	 SHORT $LN2@P_RunSOC

; 2440 : 		return P_AddWadFile(socfilename, NULL);

  0001e	6a 00		 push	 0
  00020	8b 45 08	 mov	 eax, DWORD PTR _socfilename$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _P_AddWadFile
  00029	83 c4 08	 add	 esp, 8
  0002c	eb 3b		 jmp	 SHORT $LN1@P_RunSOC
$LN2@P_RunSOC:

; 2441 : 
; 2442 : 	lump = W_CheckNumForName(socfilename);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _socfilename$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _W_CheckNumForName
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 fc	 mov	 DWORD PTR _lump$[ebp], eax

; 2443 : 	if (lump == LUMPERROR)

  0003d	83 7d fc ff	 cmp	 DWORD PTR _lump$[ebp], -1
  00041	75 04		 jne	 SHORT $LN3@P_RunSOC

; 2444 : 		return false;

  00043	33 c0		 xor	 eax, eax
  00045	eb 22		 jmp	 SHORT $LN1@P_RunSOC
$LN3@P_RunSOC:

; 2445 : 
; 2446 : 	CONS_Printf("Loading SOC lump: %s\n", socfilename);

  00047	8b 45 08	 mov	 eax, DWORD PTR _socfilename$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HHLOHKHJ@Loading?5SOC?5lump?3?5?$CFs?6@
  00050	e8 00 00 00 00	 call	 _CONS_Printf
  00055	83 c4 08	 add	 esp, 8

; 2447 : 	DEH_LoadDehackedLump(lump);

  00058	8b 45 fc	 mov	 eax, DWORD PTR _lump$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _DEH_LoadDehackedLump
  00061	83 c4 04	 add	 esp, 4

; 2448 : 
; 2449 : 	return true;

  00064	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_RunSOC:

; 2450 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_P_RunSOC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_DelWadFile
_TEXT	SEGMENT
_lumpnum$ = -12						; size = 4
_wadnum$ = -8						; size = 2
_i$ = -4						; size = 4
_P_DelWadFile PROC					; COMDAT

; 2591 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2592 : 	sfxenum_t i;
; 2593 : 	const UINT16 wadnum = (UINT16)(numwadfiles - 1);

  00009	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  00010	83 e8 01	 sub	 eax, 1
  00013	66 89 45 f8	 mov	 WORD PTR _wadnum$[ebp], ax

; 2594 : 	const lumpnum_t lumpnum = numwadfiles<<16;

  00017	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  0001e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00021	89 45 f4	 mov	 DWORD PTR _lumpnum$[ebp], eax

; 2595 : 	//lumpinfo_t *lumpinfo = wadfiles[wadnum]->lumpinfo;
; 2596 : 	R_DelSkins(wadnum);

  00024	0f b7 45 f8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _R_DelSkins
  0002e	83 c4 04	 add	 esp, 4

; 2597 : 	R_DelSpriteDefs(wadnum);

  00031	0f b7 45 f8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _R_DelSpriteDefs
  0003b	83 c4 04	 add	 esp, 4

; 2598 : 	for (i = 0; i < NUMSFX; i++)

  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN4@P_DelWadFi
$LN2@P_DelWadFi:
  00047	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_DelWadFi:
  00050	81 7d fc 63 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  00057	7d 63		 jge	 SHORT $LN3@P_DelWadFi

; 2599 : 	{
; 2600 : 		if (S_sfx[i].lumpnum != LUMPERROR && S_sfx[i].lumpnum >= lumpnum)

  00059	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  0005d	83 b8 24 00 00
	00 ff		 cmp	 DWORD PTR _S_sfx[eax+36], -1
  00064	74 54		 je	 SHORT $LN6@P_DelWadFi
  00066	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  0006a	8b 88 24 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+36]
  00070	3b 4d f4	 cmp	 ecx, DWORD PTR _lumpnum$[ebp]
  00073	72 45		 jb	 SHORT $LN6@P_DelWadFi

; 2601 : 		{
; 2602 : 			S_StopSoundByNum(i);

  00075	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _S_StopSoundByNum
  0007e	83 c4 04	 add	 esp, 4

; 2603 : 			S_RemoveSoundFx(i);

  00081	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _S_RemoveSoundFx
  0008a	83 c4 04	 add	 esp, 4

; 2604 : 			if (S_sfx[i].lumpnum != LUMPERROR)

  0008d	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00091	83 b8 24 00 00
	00 ff		 cmp	 DWORD PTR _S_sfx[eax+36], -1
  00098	74 20		 je	 SHORT $LN6@P_DelWadFi

; 2605 : 			{
; 2606 : 				I_FreeSfx(&S_sfx[i]);

  0009a	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  0009e	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _I_FreeSfx
  000a9	83 c4 04	 add	 esp, 4

; 2607 : 				S_sfx[i].lumpnum = LUMPERROR;

  000ac	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  000b0	c7 80 24 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _S_sfx[eax+36], -1
$LN6@P_DelWadFi:

; 2608 : 			}
; 2609 : 		}
; 2610 : 	}

  000ba	eb 8b		 jmp	 SHORT $LN2@P_DelWadFi
$LN3@P_DelWadFi:

; 2611 : 	W_UnloadWadFile(wadnum);

  000bc	0f b7 45 f8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _W_UnloadWadFile
  000c6	83 c4 04	 add	 esp, 4

; 2612 : 	R_LoadTextures();

  000c9	e8 00 00 00 00	 call	 _R_LoadTextures
  000ce	90		 npad	 1

; 2613 : 	return false;

  000cf	33 c0		 xor	 eax, eax

; 2614 : }

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_P_DelWadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_AddWadFile
_TEXT	SEGMENT
_replacedcurrentmap$ = -48				; size = 4
_texturechange$ = -44					; size = 4
_lumpinfo$ = -40					; size = 4
_name$ = -36						; size = 4
_num$ = -32						; size = 2
_firstmapreplaced$ = -28				; size = 2
_wadnum$ = -24						; size = 2
_numlumps$ = -20					; size = 2
_mreplaces$ = -16					; size = 4
_sreplaces$ = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_wadfilename$ = 8					; size = 4
_firstmapname$ = 12					; size = 4
_P_AddWadFile PROC					; COMDAT

; 2457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2458 : 	size_t i, j, sreplaces = 0, mreplaces = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sreplaces$[ebp], 0
  00010	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mreplaces$[ebp], 0

; 2459 : 	UINT16 numlumps, wadnum;
; 2460 : 	INT16 firstmapreplaced = 0, num;

  00017	33 c0		 xor	 eax, eax
  00019	66 89 45 e4	 mov	 WORD PTR _firstmapreplaced$[ebp], ax

; 2461 : 	char *name;
; 2462 : 	lumpinfo_t *lumpinfo;
; 2463 : 	boolean texturechange = false;

  0001d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _texturechange$[ebp], 0

; 2464 : 	boolean replacedcurrentmap = false;

  00024	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _replacedcurrentmap$[ebp], 0

; 2465 : 
; 2466 : 	if ((numlumps = W_LoadWadFile(wadfilename)) == INT16_MAX)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _wadfilename$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _W_LoadWadFile
  00034	83 c4 04	 add	 esp, 4
  00037	66 89 45 ec	 mov	 WORD PTR _numlumps$[ebp], ax
  0003b	0f b7 4d ec	 movzx	 ecx, WORD PTR _numlumps$[ebp]
  0003f	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00045	75 1a		 jne	 SHORT $LN11@P_AddWadFi

; 2467 : 	{
; 2468 : 		CONS_Printf("couldn't load wad file %s\n", wadfilename);

  00047	8b 45 08	 mov	 eax, DWORD PTR _wadfilename$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DOPEPGLB@couldn?8t?5load?5wad?5file?5?$CFs?6@
  00050	e8 00 00 00 00	 call	 _CONS_Printf
  00055	83 c4 08	 add	 esp, 8

; 2469 : 		return false;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 98 03 00 00	 jmp	 $LN1@P_AddWadFi

; 2470 : 	}

  0005f	eb 0e		 jmp	 SHORT $LN12@P_AddWadFi
$LN11@P_AddWadFi:

; 2471 : 	else wadnum = (UINT16)(numwadfiles-1);

  00061	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  00068	83 e8 01	 sub	 eax, 1
  0006b	66 89 45 e8	 mov	 WORD PTR _wadnum$[ebp], ax
$LN12@P_AddWadFi:

; 2472 : 
; 2473 : 	//
; 2474 : 	// search for sound replacements
; 2475 : 	//
; 2476 : 	lumpinfo = wadfiles[wadnum]->lumpinfo;

  0006f	0f b7 45 e8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00073	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  0007a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007d	89 55 d8	 mov	 DWORD PTR _lumpinfo$[ebp], edx

; 2477 : 	for (i = 0; i < numlumps; i++, lumpinfo++)

  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00087	eb 12		 jmp	 SHORT $LN4@P_AddWadFi
$LN2@P_AddWadFi:
  00089	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00092	8b 4d d8	 mov	 ecx, DWORD PTR _lumpinfo$[ebp]
  00095	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00098	89 4d d8	 mov	 DWORD PTR _lumpinfo$[ebp], ecx
$LN4@P_AddWadFi:
  0009b	0f b7 45 ec	 movzx	 eax, WORD PTR _numlumps$[ebp]
  0009f	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000a2	0f 83 fd 00 00
	00		 jae	 $LN3@P_AddWadFi

; 2478 : 	{
; 2479 : 		name = lumpinfo->name;

  000a8	8b 45 d8	 mov	 eax, DWORD PTR _lumpinfo$[ebp]
  000ab	83 c0 08	 add	 eax, 8
  000ae	89 45 dc	 mov	 DWORD PTR _name$[ebp], eax

; 2480 : 		if (name[0] == 'D')

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	6b c8 00	 imul	 ecx, eax, 0
  000b9	8b 55 dc	 mov	 edx, DWORD PTR _name$[ebp]
  000bc	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000c0	83 f8 44	 cmp	 eax, 68			; 00000044H
  000c3	0f 85 d0 00 00
	00		 jne	 $LN18@P_AddWadFi

; 2481 : 		{
; 2482 : 			if (name[1] == 'S') for (j = 1; j < NUMSFX; j++)

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	c1 e0 00	 shl	 eax, 0
  000d1	8b 4d dc	 mov	 ecx, DWORD PTR _name$[ebp]
  000d4	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  000d8	83 fa 53	 cmp	 edx, 83			; 00000053H
  000db	0f 85 81 00 00
	00		 jne	 $LN14@P_AddWadFi
  000e1	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  000e8	eb 09		 jmp	 SHORT $LN7@P_AddWadFi
$LN5@P_AddWadFi:
  000ea	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@P_AddWadFi:
  000f3	81 7d f8 63 07
	00 00		 cmp	 DWORD PTR _j$[ebp], 1891 ; 00000763H
  000fa	73 64		 jae	 SHORT $LN6@P_AddWadFi

; 2483 : 			{
; 2484 : 				if (S_sfx[j].name && !strnicmp(S_sfx[j].name, name + 2, 6))

  000fc	6b 45 f8 2c	 imul	 eax, DWORD PTR _j$[ebp], 44
  00100	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _S_sfx[eax], 0
  00107	74 55		 je	 SHORT $LN16@P_AddWadFi
  00109	6a 06		 push	 6
  0010b	8b 45 dc	 mov	 eax, DWORD PTR _name$[ebp]
  0010e	83 c0 02	 add	 eax, 2
  00111	50		 push	 eax
  00112	6b 4d f8 2c	 imul	 ecx, DWORD PTR _j$[ebp], 44
  00116	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _S_sfx[ecx]
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 _strnicmp
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
  00125	85 c0		 test	 eax, eax
  00127	75 35		 jne	 SHORT $LN16@P_AddWadFi

; 2485 : 				{
; 2486 : 					// the sound will be reloaded when needed,
; 2487 : 					// since sfx->data will be NULL
; 2488 : 					if (devparm)

  00129	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00130	74 11		 je	 SHORT $LN17@P_AddWadFi

; 2489 : 						I_OutputMsg("Sound %.8s replaced\n", name);

  00132	8b 45 dc	 mov	 eax, DWORD PTR _name$[ebp]
  00135	50		 push	 eax
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BDHJKOOJ@Sound?5?$CF?48s?5replaced?6@
  0013b	e8 00 00 00 00	 call	 _I_OutputMsg
  00140	83 c4 08	 add	 esp, 8
$LN17@P_AddWadFi:

; 2490 : 
; 2491 : 					I_FreeSfx(&S_sfx[j]);

  00143	6b 45 f8 2c	 imul	 eax, DWORD PTR _j$[ebp], 44
  00147	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _I_FreeSfx
  00152	83 c4 04	 add	 esp, 4

; 2492 : 
; 2493 : 					sreplaces++;

  00155	8b 45 f4	 mov	 eax, DWORD PTR _sreplaces$[ebp]
  00158	83 c0 01	 add	 eax, 1
  0015b	89 45 f4	 mov	 DWORD PTR _sreplaces$[ebp], eax
$LN16@P_AddWadFi:

; 2494 : 				}
; 2495 : 			}

  0015e	eb 8a		 jmp	 SHORT $LN5@P_AddWadFi
$LN6@P_AddWadFi:
  00160	eb 37		 jmp	 SHORT $LN18@P_AddWadFi
$LN14@P_AddWadFi:

; 2496 : 			else if (name[1] == '_')

  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	c1 e0 00	 shl	 eax, 0
  0016a	8b 4d dc	 mov	 ecx, DWORD PTR _name$[ebp]
  0016d	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00171	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  00174	75 23		 jne	 SHORT $LN18@P_AddWadFi

; 2497 : 			{
; 2498 : 				if (devparm)

  00176	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  0017d	74 11		 je	 SHORT $LN19@P_AddWadFi

; 2499 : 					I_OutputMsg("Music %.8s replaced\n", name);

  0017f	8b 45 dc	 mov	 eax, DWORD PTR _name$[ebp]
  00182	50		 push	 eax
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GAOBMGJC@Music?5?$CF?48s?5replaced?6@
  00188	e8 00 00 00 00	 call	 _I_OutputMsg
  0018d	83 c4 08	 add	 esp, 8
$LN19@P_AddWadFi:

; 2500 : 				mreplaces++;

  00190	8b 45 f0	 mov	 eax, DWORD PTR _mreplaces$[ebp]
  00193	83 c0 01	 add	 eax, 1
  00196	89 45 f0	 mov	 DWORD PTR _mreplaces$[ebp], eax
$LN18@P_AddWadFi:

; 2501 : 			}
; 2502 : 		}
; 2503 : #if 0
; 2504 : 		//
; 2505 : 		// search for texturechange replacements
; 2506 : 		//
; 2507 : 		else if (!memcmp(name, "TEXTURE1", 8) || !memcmp(name, "TEXTURE2", 8)
; 2508 : 			|| !memcmp(name, "PNAMES", 6))
; 2509 : #endif
; 2510 : 			texturechange = true;

  00199	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _texturechange$[ebp], 1

; 2511 : 	}

  001a0	e9 e4 fe ff ff	 jmp	 $LN2@P_AddWadFi
$LN3@P_AddWadFi:

; 2512 : 	if (!devparm && sreplaces)

  001a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  001ac	75 17		 jne	 SHORT $LN20@P_AddWadFi
  001ae	83 7d f4 00	 cmp	 DWORD PTR _sreplaces$[ebp], 0
  001b2	74 11		 je	 SHORT $LN20@P_AddWadFi

; 2513 : 		CONS_Printf("%"PRIdS" sounds replaced\n", sreplaces);

  001b4	8b 45 f4	 mov	 eax, DWORD PTR _sreplaces$[ebp]
  001b7	50		 push	 eax
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DLLBJHGC@?$CFIu?5sounds?5replaced?6@
  001bd	e8 00 00 00 00	 call	 _CONS_Printf
  001c2	83 c4 08	 add	 esp, 8
$LN20@P_AddWadFi:

; 2514 : 	if (!devparm && mreplaces)

  001c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  001cc	75 17		 jne	 SHORT $LN21@P_AddWadFi
  001ce	83 7d f0 00	 cmp	 DWORD PTR _mreplaces$[ebp], 0
  001d2	74 11		 je	 SHORT $LN21@P_AddWadFi

; 2515 : 		CONS_Printf("%"PRIdS" musics replaced\n", mreplaces);

  001d4	8b 45 f0	 mov	 eax, DWORD PTR _mreplaces$[ebp]
  001d7	50		 push	 eax
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EFBEAKFB@?$CFIu?5musics?5replaced?6@
  001dd	e8 00 00 00 00	 call	 _CONS_Printf
  001e2	83 c4 08	 add	 esp, 8
$LN21@P_AddWadFi:

; 2516 : 
; 2517 : 	//
; 2518 : 	// search for sprite replacements
; 2519 : 	//
; 2520 : 	R_AddSpriteDefs(wadnum);

  001e5	0f b7 45 e8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _R_AddSpriteDefs
  001ef	83 c4 04	 add	 esp, 4

; 2521 : 
; 2522 : 	// Reload it all anyway, just in case they
; 2523 : 	// added some textures but didn't insert a
; 2524 : 	// TEXTURE1/PNAMES/etc. list.
; 2525 : 	if (texturechange) // initialized in the sound check

  001f2	83 7d d4 00	 cmp	 DWORD PTR _texturechange$[ebp], 0
  001f6	74 08		 je	 SHORT $LN22@P_AddWadFi

; 2526 : 		R_LoadTextures(); // numtexture changes

  001f8	e8 00 00 00 00	 call	 _R_LoadTextures
  001fd	90		 npad	 1
  001fe	eb 06		 jmp	 SHORT $LN23@P_AddWadFi
$LN22@P_AddWadFi:

; 2527 : 	else
; 2528 : 		R_FlushTextureCache(); // just reload it from file

  00200	e8 00 00 00 00	 call	 _R_FlushTextureCache
  00205	90		 npad	 1
$LN23@P_AddWadFi:

; 2529 : 
; 2530 : 	// Flush and reload HUD graphics
; 2531 : 	ST_UnloadGraphics();

  00206	e8 00 00 00 00	 call	 _ST_UnloadGraphics
  0020b	90		 npad	 1

; 2532 : 	HU_LoadGraphics();

  0020c	e8 00 00 00 00	 call	 _HU_LoadGraphics
  00211	90		 npad	 1

; 2533 : 	ST_LoadGraphics();

  00212	e8 00 00 00 00	 call	 _ST_LoadGraphics
  00217	90		 npad	 1

; 2534 : 	ST_ReloadSkinFaceGraphics();

  00218	e8 00 00 00 00	 call	 _ST_ReloadSkinFaceGraphics
  0021d	90		 npad	 1

; 2535 : 
; 2536 : 	//
; 2537 : 	// look for skins
; 2538 : 	//
; 2539 : 	R_AddSkins(wadnum); // faB: wadfile index in wadfiles[]

  0021e	0f b7 45 e8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 _R_AddSkins
  00228	83 c4 04	 add	 esp, 4

; 2540 : 
; 2541 : 	//
; 2542 : 	// search for maps
; 2543 : 	//
; 2544 : 	lumpinfo = wadfiles[wadnum]->lumpinfo;

  0022b	0f b7 45 e8	 movzx	 eax, WORD PTR _wadnum$[ebp]
  0022f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00236	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00239	89 55 d8	 mov	 DWORD PTR _lumpinfo$[ebp], edx

; 2545 : 	for (i = 0; i < numlumps; i++, lumpinfo++)

  0023c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00243	eb 12		 jmp	 SHORT $LN10@P_AddWadFi
$LN8@P_AddWadFi:
  00245	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00248	83 c0 01	 add	 eax, 1
  0024b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0024e	8b 4d d8	 mov	 ecx, DWORD PTR _lumpinfo$[ebp]
  00251	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00254	89 4d d8	 mov	 DWORD PTR _lumpinfo$[ebp], ecx
$LN10@P_AddWadFi:
  00257	0f b7 45 ec	 movzx	 eax, WORD PTR _numlumps$[ebp]
  0025b	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0025e	0f 83 1d 01 00
	00		 jae	 $LN9@P_AddWadFi

; 2546 : 	{
; 2547 : 		name = lumpinfo->name;

  00264	8b 45 d8	 mov	 eax, DWORD PTR _lumpinfo$[ebp]
  00267	83 c0 08	 add	 eax, 8
  0026a	89 45 dc	 mov	 DWORD PTR _name$[ebp], eax

; 2548 : 		num = firstmapreplaced;

  0026d	66 8b 45 e4	 mov	 ax, WORD PTR _firstmapreplaced$[ebp]
  00271	66 89 45 e0	 mov	 WORD PTR _num$[ebp], ax

; 2549 : 
; 2550 : 		if (name[0] == 'M' && name[1] == 'A' && name[2] == 'P') // Ignore the headers

  00275	b8 01 00 00 00	 mov	 eax, 1
  0027a	6b c8 00	 imul	 ecx, eax, 0
  0027d	8b 55 dc	 mov	 edx, DWORD PTR _name$[ebp]
  00280	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00284	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00287	0f 85 bd 00 00
	00		 jne	 $LN24@P_AddWadFi
  0028d	b8 01 00 00 00	 mov	 eax, 1
  00292	c1 e0 00	 shl	 eax, 0
  00295	8b 4d dc	 mov	 ecx, DWORD PTR _name$[ebp]
  00298	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0029c	83 fa 41	 cmp	 edx, 65			; 00000041H
  0029f	0f 85 a5 00 00
	00		 jne	 $LN24@P_AddWadFi
  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	d1 e0		 shl	 eax, 1
  002ac	8b 4d dc	 mov	 ecx, DWORD PTR _name$[ebp]
  002af	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  002b3	83 fa 50	 cmp	 edx, 80			; 00000050H
  002b6	0f 85 8e 00 00
	00		 jne	 $LN24@P_AddWadFi

; 2551 : 		{
; 2552 : 			num = (INT16)M_MapNumber(name[3], name[4]);

  002bc	b8 01 00 00 00	 mov	 eax, 1
  002c1	c1 e0 02	 shl	 eax, 2
  002c4	8b 4d dc	 mov	 ecx, DWORD PTR _name$[ebp]
  002c7	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002cb	52		 push	 edx
  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	6b c8 03	 imul	 ecx, eax, 3
  002d4	8b 55 dc	 mov	 edx, DWORD PTR _name$[ebp]
  002d7	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  002db	50		 push	 eax
  002dc	e8 00 00 00 00	 call	 _M_MapNumber
  002e1	83 c4 08	 add	 esp, 8
  002e4	66 89 45 e0	 mov	 WORD PTR _num$[ebp], ax

; 2553 : 
; 2554 : 			//If you replaced the map you're on, end the level when done.
; 2555 : 			if (num == gamemap)

  002e8	0f bf 45 e0	 movsx	 eax, WORD PTR _num$[ebp]
  002ec	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _gamemap
  002f3	3b c1		 cmp	 eax, ecx
  002f5	75 07		 jne	 SHORT $LN25@P_AddWadFi

; 2556 : 				replacedcurrentmap = true;

  002f7	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _replacedcurrentmap$[ebp], 1
$LN25@P_AddWadFi:

; 2557 : 
; 2558 : 			if (name[5] == 'D')

  002fe	b8 01 00 00 00	 mov	 eax, 1
  00303	6b c8 05	 imul	 ecx, eax, 5
  00306	8b 55 dc	 mov	 edx, DWORD PTR _name$[ebp]
  00309	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0030d	83 f8 44	 cmp	 eax, 68			; 00000044H
  00310	75 0f		 jne	 SHORT $LN26@P_AddWadFi

; 2559 : 				P_LoadMapHeader(num);

  00312	0f b7 45 e0	 movzx	 eax, WORD PTR _num$[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 _P_LoadMapHeader
  0031c	83 c4 04	 add	 esp, 4
  0031f	eb 18		 jmp	 SHORT $LN28@P_AddWadFi
$LN26@P_AddWadFi:

; 2560 : 			else if (name[5]!='\0')

  00321	b8 01 00 00 00	 mov	 eax, 1
  00326	6b c8 05	 imul	 ecx, eax, 5
  00329	8b 55 dc	 mov	 edx, DWORD PTR _name$[ebp]
  0032c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00330	85 c0		 test	 eax, eax
  00332	74 05		 je	 SHORT $LN28@P_AddWadFi

; 2561 : 				continue;

  00334	e9 0c ff ff ff	 jmp	 $LN8@P_AddWadFi
$LN28@P_AddWadFi:

; 2562 : 
; 2563 : 			CONS_Printf("%s\n", name);

  00339	8b 45 dc	 mov	 eax, DWORD PTR _name$[ebp]
  0033c	50		 push	 eax
  0033d	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  00342	e8 00 00 00 00	 call	 _CONS_Printf
  00347	83 c4 08	 add	 esp, 8
$LN24@P_AddWadFi:

; 2564 : 		}
; 2565 : 
; 2566 : 		if (num && (num < firstmapreplaced || !firstmapreplaced))

  0034a	0f bf 45 e0	 movsx	 eax, WORD PTR _num$[ebp]
  0034e	85 c0		 test	 eax, eax
  00350	74 2a		 je	 SHORT $LN31@P_AddWadFi
  00352	0f bf 45 e0	 movsx	 eax, WORD PTR _num$[ebp]
  00356	0f bf 4d e4	 movsx	 ecx, WORD PTR _firstmapreplaced$[ebp]
  0035a	3b c1		 cmp	 eax, ecx
  0035c	7c 08		 jl	 SHORT $LN30@P_AddWadFi
  0035e	0f bf 45 e4	 movsx	 eax, WORD PTR _firstmapreplaced$[ebp]
  00362	85 c0		 test	 eax, eax
  00364	75 16		 jne	 SHORT $LN31@P_AddWadFi
$LN30@P_AddWadFi:

; 2567 : 		{
; 2568 : 			firstmapreplaced = num;

  00366	66 8b 45 e0	 mov	 ax, WORD PTR _num$[ebp]
  0036a	66 89 45 e4	 mov	 WORD PTR _firstmapreplaced$[ebp], ax

; 2569 : 			if (firstmapname)

  0036e	83 7d 0c 00	 cmp	 DWORD PTR _firstmapname$[ebp], 0
  00372	74 08		 je	 SHORT $LN31@P_AddWadFi

; 2570 : 				*firstmapname = name;

  00374	8b 45 0c	 mov	 eax, DWORD PTR _firstmapname$[ebp]
  00377	8b 4d dc	 mov	 ecx, DWORD PTR _name$[ebp]
  0037a	89 08		 mov	 DWORD PTR [eax], ecx
$LN31@P_AddWadFi:

; 2571 : 		}
; 2572 : 	}

  0037c	e9 c4 fe ff ff	 jmp	 $LN8@P_AddWadFi
$LN9@P_AddWadFi:

; 2573 : 	if (!firstmapreplaced)

  00381	0f bf 45 e4	 movsx	 eax, WORD PTR _firstmapreplaced$[ebp]
  00385	85 c0		 test	 eax, eax
  00387	75 0d		 jne	 SHORT $LN32@P_AddWadFi

; 2574 : 		CONS_Printf("no maps added\n");

  00389	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GEDPLKLD@no?5maps?5added?6@
  0038e	e8 00 00 00 00	 call	 _CONS_Printf
  00393	83 c4 04	 add	 esp, 4
$LN32@P_AddWadFi:

; 2575 : 
; 2576 : 	// reload status bar (warning should have valid player!)
; 2577 : 	if (gamestate == GS_LEVEL)

  00396	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  0039d	75 06		 jne	 SHORT $LN33@P_AddWadFi

; 2578 : 		ST_Start();

  0039f	e8 00 00 00 00	 call	 _ST_Start
  003a4	90		 npad	 1
$LN33@P_AddWadFi:

; 2579 : 
; 2580 : 	if (replacedcurrentmap && gamestate == GS_LEVEL && (netgame || multiplayer))

  003a5	83 7d d0 00	 cmp	 DWORD PTR _replacedcurrentmap$[ebp], 0
  003a9	74 47		 je	 SHORT $LN36@P_AddWadFi
  003ab	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  003b2	75 3e		 jne	 SHORT $LN36@P_AddWadFi
  003b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  003bb	75 09		 jne	 SHORT $LN35@P_AddWadFi
  003bd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  003c4	74 2c		 je	 SHORT $LN36@P_AddWadFi
$LN35@P_AddWadFi:

; 2581 : 	{
; 2582 : 		CONS_Printf("Current map %d replaced by added file, ending the level to ensure consistiency.\n", gamemap);

  003c6	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  003cd	50		 push	 eax
  003ce	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@NNLECNHE@Current?5map?5?$CFd?5replaced?5by?5adde@
  003d3	e8 00 00 00 00	 call	 _CONS_Printf
  003d8	83 c4 08	 add	 esp, 8

; 2583 : 		if (server)

  003db	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  003e2	74 0e		 je	 SHORT $LN36@P_AddWadFi

; 2584 : 			SendNetXCmd(XD_EXITLEVEL, NULL, 0);

  003e4	6a 00		 push	 0
  003e6	6a 00		 push	 0
  003e8	6a 07		 push	 7
  003ea	e8 00 00 00 00	 call	 _SendNetXCmd
  003ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@P_AddWadFi:

; 2585 : 	}
; 2586 : 
; 2587 : 	return true;

  003f2	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_AddWadFi:

; 2588 : }

  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx
  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c3		 ret	 0
_P_AddWadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_SetupLevel
_TEXT	SEGMENT
tv359 = -284						; size = 4
$T1 = -280						; size = 4
_playersactive$2 = -212					; size = 128
_realnumplayers$3 = -84					; size = 4
_skincmd$4 = -80					; size = 33
_newname$5 = -44					; size = 9
_lumpnum$6 = -32					; size = 4
_ss$ = -28						; size = 4
_loadedbm$ = -24					; size = 4
_fromnetsave$ = -20					; size = 4
_loademblems$ = -16					; size = 4
_loadprecip$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_map$ = 8						; size = 4
_skipprecip$ = 12					; size = 4
_P_SetupLevel PROC					; COMDAT

; 2002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2003 : 	INT32 i, loadprecip = 1;

  00016	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _loadprecip$[ebp], 1

; 2004 : 	INT32 loademblems = 1;

  0001d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _loademblems$[ebp], 1

; 2005 : 	INT32 fromnetsave = 0;

  00024	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fromnetsave$[ebp], 0

; 2006 : 	boolean loadedbm = false;

  0002b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _loadedbm$[ebp], 0

; 2007 : 	sector_t *ss;
; 2008 : 
; 2009 : 	levelloading = true;

  00032	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _levelloading, 1

; 2010 : 
; 2011 : 	// This is needed. Don't touch.
; 2012 : 	maptol = mapheaderinfo[gamemap-1].typeoflevel;

  0003c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00043	83 e8 01	 sub	 eax, 1
  00046	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0004c	66 8b 91 44 00
	00 00		 mov	 dx, WORD PTR _mapheaderinfo[ecx+68]
  00053	66 89 15 00 00
	00 00		 mov	 WORD PTR _maptol, dx

; 2013 : 
; 2014 : 	if (!(grade & 2) && (maptol & TOL_SRB1) && !dedicated) // to prevent dedicated server error.

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  0005f	83 e0 02	 and	 eax, 2
  00062	75 24		 jne	 SHORT $LN17@P_SetupLev
  00064	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  0006b	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00070	74 16		 je	 SHORT $LN17@P_SetupLev
  00072	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00079	75 0d		 jne	 SHORT $LN17@P_SetupLev

; 2015 : 		I_Error("You have to unlock this level first!");

  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MGGLDKKC@You?5have?5to?5unlock?5this?5level?5f@
  00080	e8 00 00 00 00	 call	 _I_Error
  00085	83 c4 04	 add	 esp, 4
$LN17@P_SetupLev:

; 2016 : 
; 2017 : 	HU_clearChatChars();

  00088	e8 00 00 00 00	 call	 _HU_clearChatChars
  0008d	90		 npad	 1

; 2018 : 
; 2019 : 	CON_Drawer(); // let the user know what we are going to do

  0008e	e8 00 00 00 00	 call	 _CON_Drawer
  00093	90		 npad	 1

; 2020 : 	I_FinishUpdate(); // page flip or blit buffer

  00094	e8 00 00 00 00	 call	 _I_FinishUpdate
  00099	90		 npad	 1

; 2021 : 
; 2022 : 	// Initialize sector node list.
; 2023 : 	P_Initsecnode();

  0009a	e8 00 00 00 00	 call	 _P_Initsecnode
  0009f	90		 npad	 1

; 2024 : 
; 2025 : 	if (netgame || multiplayer)

  000a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000a7	75 09		 jne	 SHORT $LN19@P_SetupLev
  000a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  000b0	74 0a		 je	 SHORT $LN18@P_SetupLev
$LN19@P_SetupLev:

; 2026 : 		cv_debug = 0;

  000b2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_debug, 0
$LN18@P_SetupLev:

; 2027 : 
; 2028 : 	// Clear CECHO messages
; 2029 : 	HU_ClearCEcho();

  000bc	e8 00 00 00 00	 call	 _HU_ClearCEcho
  000c1	90		 npad	 1

; 2030 : 
; 2031 : 	if (mapheaderinfo[gamemap-1].runsoc[0] != '#')

  000c2	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000c9	83 e8 01	 sub	 eax, 1
  000cc	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  000d2	ba 01 00 00 00	 mov	 edx, 1
  000d7	6b c2 00	 imul	 eax, edx, 0
  000da	0f be 8c 01 40
	01 00 00	 movsx	 ecx, BYTE PTR _mapheaderinfo[ecx+eax+320]
  000e2	83 f9 23	 cmp	 ecx, 35			; 00000023H
  000e5	74 1f		 je	 SHORT $LN20@P_SetupLev

; 2032 : 		P_RunSOC(mapheaderinfo[gamemap-1].runsoc);

  000e7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000ee	83 e8 01	 sub	 eax, 1
  000f1	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  000f7	81 c1 40 01 00
	00		 add	 ecx, OFFSET _mapheaderinfo+320
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _P_RunSOC
  00103	83 c4 04	 add	 esp, 4
$LN20@P_SetupLev:

; 2033 : 
; 2034 : 	if (cv_runscripts.value && mapheaderinfo[gamemap-1].scriptname[0] != '#')

  00106	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_runscripts+20, 0
  0010d	0f 84 19 01 00
	00		 je	 $noscript$87
  00113	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0011a	83 e8 01	 sub	 eax, 1
  0011d	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00123	ba 01 00 00 00	 mov	 edx, 1
  00128	6b c2 00	 imul	 eax, edx, 0
  0012b	0f be 8c 01 58
	00 00 00	 movsx	 ecx, BYTE PTR _mapheaderinfo[ecx+eax+88]
  00133	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00136	0f 84 f0 00 00
	00		 je	 $noscript$87

; 2035 : 	{
; 2036 : 		if (mapheaderinfo[gamemap-1].scriptislump)

  0013c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00143	83 e8 01	 sub	 eax, 1
  00146	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0014c	83 b9 18 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[ecx+280], 0
  00153	0f 84 a0 00 00
	00		 je	 $LN22@P_SetupLev

; 2037 : 		{
; 2038 : 			lumpnum_t lumpnum;
; 2039 : 			char newname[9];
; 2040 : 
; 2041 : 			strncpy(newname, mapheaderinfo[gamemap-1].scriptname, 8);

  00159	6a 08		 push	 8
  0015b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00162	83 e8 01	 sub	 eax, 1
  00165	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0016b	81 c1 58 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+88
  00171	51		 push	 ecx
  00172	8d 55 d4	 lea	 edx, DWORD PTR _newname$5[ebp]
  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 _strncpy
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2042 : 
; 2043 : 			newname[8] = '\0';

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	c1 e0 03	 shl	 eax, 3
  00186	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0018c	83 bd e8 fe ff
	ff 09		 cmp	 DWORD PTR $T1[ebp], 9
  00193	73 02		 jae	 SHORT $LN83@P_SetupLev
  00195	eb 06		 jmp	 SHORT $LN84@P_SetupLev
$LN83@P_SetupLev:
  00197	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0019c	90		 npad	 1
$LN84@P_SetupLev:
  0019d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  001a3	c6 44 0d d4 00	 mov	 BYTE PTR _newname$5[ebp+ecx], 0

; 2044 : 
; 2045 : 			lumpnum = W_CheckNumForName(newname);

  001a8	8d 45 d4	 lea	 eax, DWORD PTR _newname$5[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _W_CheckNumForName
  001b1	83 c4 04	 add	 esp, 4
  001b4	89 45 e0	 mov	 DWORD PTR _lumpnum$6[ebp], eax

; 2046 : 
; 2047 : 			if (lumpnum == LUMPERROR || W_LumpLength(lumpnum) == 0)

  001b7	83 7d e0 ff	 cmp	 DWORD PTR _lumpnum$6[ebp], -1
  001bb	74 10		 je	 SHORT $LN25@P_SetupLev
  001bd	8b 45 e0	 mov	 eax, DWORD PTR _lumpnum$6[ebp]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 _W_LumpLength
  001c6	83 c4 04	 add	 esp, 4
  001c9	85 c0		 test	 eax, eax
  001cb	75 13		 jne	 SHORT $LN24@P_SetupLev
$LN25@P_SetupLev:

; 2048 : 			{
; 2049 : 				CONS_Printf("SOC Error: script lump %s not found/not valid.\n", newname);

  001cd	8d 45 d4	 lea	 eax, DWORD PTR _newname$5[ebp]
  001d0	50		 push	 eax
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@
  001d6	e8 00 00 00 00	 call	 _CONS_Printf
  001db	83 c4 08	 add	 esp, 8

; 2050 : 				goto noscript;

  001de	eb 4c		 jmp	 SHORT $noscript$87
$LN24@P_SetupLev:

; 2051 : 			}
; 2052 : 
; 2053 : 			COM_BufInsertText(W_CacheLumpNum(lumpnum, PU_CACHE));

  001e0	6a 65		 push	 101			; 00000065H
  001e2	8b 45 e0	 mov	 eax, DWORD PTR _lumpnum$6[ebp]
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 _W_CacheLumpNum
  001eb	83 c4 08	 add	 esp, 8
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _COM_BufInsertText
  001f4	83 c4 04	 add	 esp, 4

; 2054 : 		}

  001f7	eb 2d		 jmp	 SHORT $LN23@P_SetupLev
$LN22@P_SetupLev:

; 2055 : 		else
; 2056 : 		{
; 2057 : 			COM_BufAddText(va("exec %s\n", mapheaderinfo[gamemap-1].scriptname));

  001f9	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00200	83 e8 01	 sub	 eax, 1
  00203	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00209	81 c1 58 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+88
  0020f	51		 push	 ecx
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_08NNCMPFKC@exec?5?$CFs?6@
  00215	e8 00 00 00 00	 call	 _va
  0021a	83 c4 08	 add	 esp, 8
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _COM_BufAddText
  00223	83 c4 04	 add	 esp, 4
$LN23@P_SetupLev:

; 2058 : 		}
; 2059 : 		COM_BufExecute(); // Run it!

  00226	e8 00 00 00 00	 call	 _COM_BufExecute
  0022b	90		 npad	 1
$noscript$87:

; 2060 : 	}
; 2061 : noscript:
; 2062 : 
; 2063 : 	P_LevelInitStuff();

  0022c	e8 00 00 00 00	 call	 _P_LevelInitStuff
  00231	90		 npad	 1

; 2064 : 
; 2065 : 	postimgtype = postimg_none;

  00232	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _postimgtype, 0

; 2066 : 
; 2067 : 	if (mapheaderinfo[gamemap-1].forcecharacter != 255)

  0023c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00243	83 e8 01	 sub	 eax, 1
  00246	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0024c	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  00253	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00259	0f 84 8b 02 00
	00		 je	 $LN33@P_SetupLev

; 2068 : 	{
; 2069 : 		char skincmd[33];
; 2070 : 		if (splitscreen)

  0025f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00266	74 64		 je	 SHORT $LN27@P_SetupLev

; 2071 : 		{
; 2072 : 			sprintf(skincmd, "skin2 %s\n", skins[mapheaderinfo[gamemap-1].forcecharacter].name);

  00268	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0026f	83 e8 01	 sub	 eax, 1
  00272	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00278	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  0027f	69 c2 ec 00 00
	00		 imul	 eax, edx, 236
  00285	05 00 00 00 00	 add	 eax, OFFSET _skins
  0028a	50		 push	 eax
  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_09HINHNCGO@skin2?5?$CFs?6@
  00290	8d 4d b0	 lea	 ecx, DWORD PTR _skincmd$4[ebp]
  00293	51		 push	 ecx
  00294	e8 00 00 00 00	 call	 _sprintf
  00299	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2073 : 			CV_Set(&cv_skin2, skins[mapheaderinfo[gamemap-1].forcecharacter].name);

  0029c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  002a3	83 e8 01	 sub	 eax, 1
  002a6	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002ac	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  002b3	69 c2 ec 00 00
	00		 imul	 eax, edx, 236
  002b9	05 00 00 00 00	 add	 eax, OFFSET _skins
  002be	50		 push	 eax
  002bf	68 00 00 00 00	 push	 OFFSET _cv_skin2
  002c4	e8 00 00 00 00	 call	 _CV_Set
  002c9	83 c4 08	 add	 esp, 8
$LN27@P_SetupLev:

; 2074 : 		}
; 2075 : 
; 2076 : 		sprintf(skincmd, "skin %s\n", skins[mapheaderinfo[gamemap-1].forcecharacter].name);

  002cc	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  002d3	83 e8 01	 sub	 eax, 1
  002d6	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002dc	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  002e3	69 c2 ec 00 00
	00		 imul	 eax, edx, 236
  002e9	05 00 00 00 00	 add	 eax, OFFSET _skins
  002ee	50		 push	 eax
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_08ILPMIBDL@skin?5?$CFs?6@
  002f4	8d 4d b0	 lea	 ecx, DWORD PTR _skincmd$4[ebp]
  002f7	51		 push	 ecx
  002f8	e8 00 00 00 00	 call	 _sprintf
  002fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2077 : 
; 2078 : 		COM_BufAddText(skincmd);

  00300	8d 45 b0	 lea	 eax, DWORD PTR _skincmd$4[ebp]
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 _COM_BufAddText
  00309	83 c4 04	 add	 esp, 4

; 2079 : 
; 2080 : 		if (!netgame)

  0030c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00313	0f 85 d1 01 00
	00		 jne	 $LN33@P_SetupLev

; 2081 : 		{
; 2082 : 			if (splitscreen)

  00319	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00320	0f 84 e2 00 00
	00		 je	 $LN31@P_SetupLev

; 2083 : 			{
; 2084 : 				SetPlayerSkinByNum(secondarydisplayplayer, mapheaderinfo[gamemap-1].forcecharacter);

  00326	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0032d	83 e8 01	 sub	 eax, 1
  00330	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00336	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  0033d	52		 push	 edx
  0033e	a1 00 00 00 00	 mov	 eax, DWORD PTR _secondarydisplayplayer
  00343	50		 push	 eax
  00344	e8 00 00 00 00	 call	 _SetPlayerSkinByNum
  00349	83 c4 08	 add	 esp, 8

; 2085 : 				if (cv_playercolor2.value != players[secondarydisplayplayer].prefcolor)

  0034c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00356	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _cv_playercolor2+20
  0035c	3b 88 fc 00 00
	00		 cmp	 ecx, DWORD PTR _players[eax+252]
  00362	0f 84 a0 00 00
	00		 je	 $LN31@P_SetupLev

; 2086 : 				{
; 2087 : 					CV_StealthSetValue(&cv_playercolor2, players[secondarydisplayplayer].prefcolor);

  00368	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00372	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+252]
  00378	51		 push	 ecx
  00379	68 00 00 00 00	 push	 OFFSET _cv_playercolor2
  0037e	e8 00 00 00 00	 call	 _CV_StealthSetValue
  00383	83 c4 08	 add	 esp, 8

; 2088 : 					players[secondarydisplayplayer].skincolor = players[secondarydisplayplayer].prefcolor;

  00386	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00390	69 0d 00 00 00
	00 fc 01 00 00	 imul	 ecx, DWORD PTR _secondarydisplayplayer, 508
  0039a	8b 90 fc 00 00
	00		 mov	 edx, DWORD PTR _players[eax+252]
  003a0	89 91 b4 00 00
	00		 mov	 DWORD PTR _players[ecx+180], edx

; 2089 : 
; 2090 : 					// a copy of color
; 2091 : 					if (players[secondarydisplayplayer].mo)

  003a6	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003b0	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  003b7	74 4f		 je	 SHORT $LN31@P_SetupLev

; 2092 : 					{
; 2093 : 						players[secondarydisplayplayer].mo->flags |= MF_TRANSLATION;

  003b9	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003c3	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  003c9	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  003cc	81 ca 00 00 00
	04		 or	 edx, 67108864		; 04000000H
  003d2	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003dc	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  003e2	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 2094 : 						players[secondarydisplayplayer].mo->color = (UINT8)players[secondarydisplayplayer].skincolor;

  003e5	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003ef	69 0d 00 00 00
	00 fc 01 00 00	 imul	 ecx, DWORD PTR _secondarydisplayplayer, 508
  003f9	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  003ff	8a 80 b4 00 00
	00		 mov	 al, BYTE PTR _players[eax+180]
  00405	88 42 68	 mov	 BYTE PTR [edx+104], al
$LN31@P_SetupLev:

; 2095 : 					}
; 2096 : 				}
; 2097 : 			}
; 2098 : 
; 2099 : 			SetPlayerSkinByNum(consoleplayer, mapheaderinfo[gamemap-1].forcecharacter);

  00408	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0040f	83 e8 01	 sub	 eax, 1
  00412	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00418	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  0041f	52		 push	 edx
  00420	a1 00 00 00 00	 mov	 eax, DWORD PTR _consoleplayer
  00425	50		 push	 eax
  00426	e8 00 00 00 00	 call	 _SetPlayerSkinByNum
  0042b	83 c4 08	 add	 esp, 8

; 2100 : 			// normal player colors in single player
; 2101 : 			if (cv_playercolor.value != players[consoleplayer].prefcolor)

  0042e	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00438	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _cv_playercolor+20
  0043e	3b 88 fc 00 00
	00		 cmp	 ecx, DWORD PTR _players[eax+252]
  00444	0f 84 a0 00 00
	00		 je	 $LN33@P_SetupLev

; 2102 : 			{
; 2103 : 				CV_StealthSetValue(&cv_playercolor, players[consoleplayer].prefcolor);

  0044a	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00454	8b 88 fc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+252]
  0045a	51		 push	 ecx
  0045b	68 00 00 00 00	 push	 OFFSET _cv_playercolor
  00460	e8 00 00 00 00	 call	 _CV_StealthSetValue
  00465	83 c4 08	 add	 esp, 8

; 2104 : 				players[consoleplayer].skincolor = players[consoleplayer].prefcolor;

  00468	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00472	69 0d 00 00 00
	00 fc 01 00 00	 imul	 ecx, DWORD PTR _consoleplayer, 508
  0047c	8b 90 fc 00 00
	00		 mov	 edx, DWORD PTR _players[eax+252]
  00482	89 91 b4 00 00
	00		 mov	 DWORD PTR _players[ecx+180], edx

; 2105 : 
; 2106 : 				// a copy of color
; 2107 : 				if (players[consoleplayer].mo)

  00488	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00492	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00499	74 4f		 je	 SHORT $LN33@P_SetupLev

; 2108 : 				{
; 2109 : 					players[consoleplayer].mo->flags |= MF_TRANSLATION;

  0049b	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  004a5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  004ab	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  004ae	81 ca 00 00 00
	04		 or	 edx, 67108864		; 04000000H
  004b4	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  004be	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  004c4	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 2110 : 					players[consoleplayer].mo->color = (UINT8)(players[consoleplayer].skincolor);

  004c7	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  004d1	69 0d 00 00 00
	00 fc 01 00 00	 imul	 ecx, DWORD PTR _consoleplayer, 508
  004db	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  004e1	8a 80 b4 00 00
	00		 mov	 al, BYTE PTR _players[eax+180]
  004e7	88 42 68	 mov	 BYTE PTR [edx+104], al
$LN33@P_SetupLev:

; 2111 : 				}
; 2112 : 			}
; 2113 : 		}
; 2114 : 	}
; 2115 : 
; 2116 : 	if (!dedicated)

  004ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  004f1	0f 85 c4 00 00
	00		 jne	 $LN39@P_SetupLev

; 2117 : 	{
; 2118 : 		if (maptol & TOL_2D)

  004f7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  004fe	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00503	74 11		 je	 SHORT $LN35@P_SetupLev

; 2119 : 		{
; 2120 : 			CV_SetValue(&cv_cam_speed, 0);

  00505	6a 00		 push	 0
  00507	68 00 00 00 00	 push	 OFFSET _cv_cam_speed
  0050c	e8 00 00 00 00	 call	 _CV_SetValue
  00511	83 c4 08	 add	 esp, 8

; 2121 : 		}

  00514	eb 2c		 jmp	 SHORT $LN37@P_SetupLev
$LN35@P_SetupLev:

; 2122 : 		else if (!cv_cam_speed.changed && !(maptol & TOL_2D))

  00516	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam_speed+34
  0051d	85 c0		 test	 eax, eax
  0051f	75 21		 jne	 SHORT $LN37@P_SetupLev
  00521	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  00528	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0052d	75 13		 jne	 SHORT $LN37@P_SetupLev

; 2123 : 			CV_Set(&cv_cam_speed, cv_cam_speed.defaultvalue);

  0052f	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam_speed+4
  00534	50		 push	 eax
  00535	68 00 00 00 00	 push	 OFFSET _cv_cam_speed
  0053a	e8 00 00 00 00	 call	 _CV_Set
  0053f	83 c4 08	 add	 esp, 8
$LN37@P_SetupLev:

; 2124 : 
; 2125 : 		// chasecam on in chaos, race, coop
; 2126 : 		// chasecam off in match, tag, capture the flag
; 2127 : 		if (!cv_chasecam.changed)

  00542	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_chasecam+34
  00549	85 c0		 test	 eax, eax
  0054b	75 50		 jne	 SHORT $LN38@P_SetupLev

; 2128 : 			CV_SetValue(&cv_chasecam,

  0054d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00554	83 f8 02	 cmp	 eax, 2
  00557	74 26		 je	 SHORT $LN85@P_SetupLev
  00559	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _gametype
  00560	85 c9		 test	 ecx, ecx
  00562	74 1b		 je	 SHORT $LN85@P_SetupLev
  00564	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR _maptol
  0056b	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00571	75 0c		 jne	 SHORT $LN85@P_SetupLev
  00573	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv359[ebp], 0
  0057d	eb 0a		 jmp	 SHORT $LN86@P_SetupLev
$LN85@P_SetupLev:
  0057f	c7 85 e4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv359[ebp], 1
$LN86@P_SetupLev:
  00589	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv359[ebp]
  0058f	50		 push	 eax
  00590	68 00 00 00 00	 push	 OFFSET _cv_chasecam
  00595	e8 00 00 00 00	 call	 _CV_SetValue
  0059a	83 c4 08	 add	 esp, 8
$LN38@P_SetupLev:

; 2129 : 				(gametype == GT_RACE || gametype == GT_COOP
; 2130 : #ifdef CHAOSISNOTDEADYET
; 2131 : 				|| gametype == GT_CHAOS
; 2132 : #endif
; 2133 : 				) || (maptol & TOL_2D));
; 2134 : 
; 2135 : 		// same for second player
; 2136 : 		if (!cv_chasecam2.changed)

  0059d	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_chasecam2+34
  005a4	85 c0		 test	 eax, eax
  005a6	75 13		 jne	 SHORT $LN39@P_SetupLev

; 2137 : 			CV_SetValue(&cv_chasecam2, cv_chasecam.value);

  005a8	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_chasecam+20
  005ad	50		 push	 eax
  005ae	68 00 00 00 00	 push	 OFFSET _cv_chasecam2
  005b3	e8 00 00 00 00	 call	 _CV_SetValue
  005b8	83 c4 08	 add	 esp, 8
$LN39@P_SetupLev:

; 2138 : 	}
; 2139 : 
; 2140 : 	// Initial height of PointOfView
; 2141 : 	// will be set by player think.
; 2142 : 	players[consoleplayer].viewz = 1;

  005bb	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  005c5	c7 80 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _players[eax+16], 1

; 2143 : 
; 2144 : 	// Make sure all sounds are stopped before Z_FreeTags.
; 2145 : 	S_StopSounds();

  005cf	e8 00 00 00 00	 call	 _S_StopSounds
  005d4	90		 npad	 1

; 2146 : 	S_ClearSfx();

  005d5	e8 00 00 00 00	 call	 _S_ClearSfx
  005da	90		 npad	 1

; 2147 : 
; 2148 : 	for (ss = sectors; sectors+numsectors != ss; ss++)

  005db	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  005e0	89 45 e4	 mov	 DWORD PTR _ss$[ebp], eax
  005e3	eb 0b		 jmp	 SHORT $LN4@P_SetupLev
$LN2@P_SetupLev:
  005e5	8b 45 e4	 mov	 eax, DWORD PTR _ss$[ebp]
  005e8	05 f8 00 00 00	 add	 eax, 248		; 000000f8H
  005ed	89 45 e4	 mov	 DWORD PTR _ss$[ebp], eax
$LN4@P_SetupLev:
  005f0	69 05 00 00 00
	00 f8 00 00 00	 imul	 eax, DWORD PTR _numsectors, 248
  005fa	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00600	3b 45 e4	 cmp	 eax, DWORD PTR _ss$[ebp]
  00603	74 26		 je	 SHORT $LN3@P_SetupLev

; 2149 : 	{
; 2150 : 		Z_Free(ss->attached);

  00605	8b 45 e4	 mov	 eax, DWORD PTR _ss$[ebp]
  00608	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0060e	51		 push	 ecx
  0060f	e8 00 00 00 00	 call	 _Z_Free
  00614	83 c4 04	 add	 esp, 4

; 2151 : 		Z_Free(ss->attachedsolid);

  00617	8b 45 e4	 mov	 eax, DWORD PTR _ss$[ebp]
  0061a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00620	51		 push	 ecx
  00621	e8 00 00 00 00	 call	 _Z_Free
  00626	83 c4 04	 add	 esp, 4

; 2152 : 	}

  00629	eb ba		 jmp	 SHORT $LN2@P_SetupLev
$LN3@P_SetupLev:

; 2153 : 
; 2154 : 	Z_FreeTags(PU_LEVEL, PU_PURGELEVEL - 1);

  0062b	6a 63		 push	 99			; 00000063H
  0062d	6a 32		 push	 50			; 00000032H
  0062f	e8 00 00 00 00	 call	 _Z_FreeTags
  00634	83 c4 08	 add	 esp, 8

; 2155 : 
; 2156 : #if defined (WALLSPLATS) || defined (FLOORSPLATS)
; 2157 : 	// clear the splats from previous level
; 2158 : 	R_ClearLevelSplats();
; 2159 : #endif
; 2160 : 
; 2161 : 	P_InitThinkers();

  00637	e8 00 00 00 00	 call	 _P_InitThinkers
  0063c	90		 npad	 1

; 2162 : 	P_InitCachedActions();

  0063d	e8 00 00 00 00	 call	 _P_InitCachedActions
  00642	90		 npad	 1

; 2163 : 
; 2164 : 	/// \note for not spawning precipitation, etc. when loading netgame snapshots
; 2165 : 	if (skipprecip)

  00643	83 7d 0c 00	 cmp	 DWORD PTR _skipprecip$[ebp], 0
  00647	74 15		 je	 SHORT $LN40@P_SetupLev

; 2166 : 	{
; 2167 : 		fromnetsave = 1;

  00649	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _fromnetsave$[ebp], 1

; 2168 : 		loadprecip = 0;

  00650	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _loadprecip$[ebp], 0

; 2169 : 		loademblems = 0;

  00657	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _loademblems$[ebp], 0
$LN40@P_SetupLev:

; 2170 : 	}
; 2171 : 
; 2172 : 	// internal game map
; 2173 : 	lastloadedmaplumpnum = W_GetNumForName(maplumpname = G_BuildMapName(map));

  0065e	8b 45 08	 mov	 eax, DWORD PTR _map$[ebp]
  00661	50		 push	 eax
  00662	e8 00 00 00 00	 call	 _G_BuildMapName
  00667	83 c4 04	 add	 esp, 4
  0066a	a3 00 00 00 00	 mov	 DWORD PTR _maplumpname, eax
  0066f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _maplumpname
  00675	51		 push	 ecx
  00676	e8 00 00 00 00	 call	 _W_GetNumForName
  0067b	83 c4 04	 add	 esp, 4
  0067e	a3 00 00 00 00	 mov	 DWORD PTR _lastloadedmaplumpnum, eax

; 2174 : 
; 2175 : 	R_ReInitColormaps(mapheaderinfo[map-1].palette);

  00683	8b 45 08	 mov	 eax, DWORD PTR _map$[ebp]
  00686	83 e8 01	 sub	 eax, 1
  00689	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0068f	0f b7 91 80 01
	00 00		 movzx	 edx, WORD PTR _mapheaderinfo[ecx+384]
  00696	52		 push	 edx
  00697	e8 00 00 00 00	 call	 _R_ReInitColormaps
  0069c	83 c4 04	 add	 esp, 4

; 2176 : 	CON_ReSetupBackColormap(mapheaderinfo[map-1].palette);

  0069f	8b 45 08	 mov	 eax, DWORD PTR _map$[ebp]
  006a2	83 e8 01	 sub	 eax, 1
  006a5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  006ab	0f b7 91 80 01
	00 00		 movzx	 edx, WORD PTR _mapheaderinfo[ecx+384]
  006b2	52		 push	 edx
  006b3	e8 00 00 00 00	 call	 _CON_ReSetupBackColormap
  006b8	83 c4 04	 add	 esp, 4

; 2177 : 
; 2178 : 	// Start the music!
; 2179 : 	S_Start();

  006bb	e8 00 00 00 00	 call	 _S_Start
  006c0	90		 npad	 1

; 2180 : 
; 2181 : 	// now part of level loading since in future each level may have
; 2182 : 	// its own anim texture sequences, switches etc.
; 2183 : 	P_InitPicAnims();

  006c1	e8 00 00 00 00	 call	 _P_InitPicAnims
  006c6	90		 npad	 1

; 2184 : 
; 2185 : 	// SRB2 determines the sky texture to be used depending on the map header.
; 2186 : 	if (!dedicated)

  006c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  006ce	75 2c		 jne	 SHORT $LN41@P_SetupLev

; 2187 : 	{
; 2188 : 		P_SetupLevelSky(mapheaderinfo[gamemap-1].skynum);

  006d0	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  006d7	83 e8 01	 sub	 eax, 1
  006da	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  006e0	0f bf 91 4e 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+78]
  006e7	52		 push	 edx
  006e8	e8 00 00 00 00	 call	 _P_SetupLevelSky
  006ed	83 c4 04	 add	 esp, 4

; 2189 : 		globallevelskynum = levelskynum;

  006f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelskynum
  006f5	a3 00 00 00 00	 mov	 DWORD PTR _globallevelskynum, eax

; 2190 : 	}

  006fa	eb 27		 jmp	 SHORT $LN42@P_SetupLev
$LN41@P_SetupLev:

; 2191 : 	else
; 2192 : 		globallevelskynum = levelskynum = mapheaderinfo[gamemap-1].skynum;

  006fc	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00703	83 e8 01	 sub	 eax, 1
  00706	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0070c	0f bf 91 4e 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+78]
  00713	89 15 00 00 00
	00		 mov	 DWORD PTR _levelskynum, edx
  00719	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelskynum
  0071e	a3 00 00 00 00	 mov	 DWORD PTR _globallevelskynum, eax
$LN42@P_SetupLev:

; 2193 : 
; 2194 : 	P_MakeMapMD5(lastloadedmaplumpnum, &mapmd5);

  00723	68 00 00 00 00	 push	 OFFSET _mapmd5
  00728	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  0072d	50		 push	 eax
  0072e	e8 00 00 00 00	 call	 _P_MakeMapMD5
  00733	83 c4 08	 add	 esp, 8

; 2195 : 
; 2196 : 	// note: most of this ordering is important
; 2197 : 	loadedbm = P_LoadBlockMap(lastloadedmaplumpnum + ML_BLOCKMAP);

  00736	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  0073b	83 c0 0a	 add	 eax, 10			; 0000000aH
  0073e	50		 push	 eax
  0073f	e8 00 00 00 00	 call	 _P_LoadBlockMap
  00744	83 c4 04	 add	 esp, 4
  00747	89 45 e8	 mov	 DWORD PTR _loadedbm$[ebp], eax

; 2198 : 
; 2199 : 	P_LoadVertexes(lastloadedmaplumpnum + ML_VERTEXES);

  0074a	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  0074f	83 c0 04	 add	 eax, 4
  00752	50		 push	 eax
  00753	e8 00 00 00 00	 call	 _P_LoadVertexes
  00758	83 c4 04	 add	 esp, 4

; 2200 : 	P_LoadSectors(lastloadedmaplumpnum + ML_SECTORS);

  0075b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  00760	83 c0 08	 add	 eax, 8
  00763	50		 push	 eax
  00764	e8 00 00 00 00	 call	 _P_LoadSectors
  00769	83 c4 04	 add	 esp, 4

; 2201 : 
; 2202 : 	P_LoadSideDefs(lastloadedmaplumpnum + ML_SIDEDEFS);

  0076c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  00771	83 c0 03	 add	 eax, 3
  00774	50		 push	 eax
  00775	e8 00 00 00 00	 call	 _P_LoadSideDefs
  0077a	83 c4 04	 add	 esp, 4

; 2203 : 
; 2204 : 	P_LoadLineDefs(lastloadedmaplumpnum + ML_LINEDEFS);

  0077d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  00782	83 c0 02	 add	 eax, 2
  00785	50		 push	 eax
  00786	e8 00 00 00 00	 call	 _P_LoadLineDefs
  0078b	83 c4 04	 add	 esp, 4

; 2205 : 	if (!loadedbm)

  0078e	83 7d e8 00	 cmp	 DWORD PTR _loadedbm$[ebp], 0
  00792	75 06		 jne	 SHORT $LN43@P_SetupLev

; 2206 : 		P_CreateBlockMap(); // Graue 02-29-2004

  00794	e8 00 00 00 00	 call	 _P_CreateBlockMap
  00799	90		 npad	 1
$LN43@P_SetupLev:

; 2207 : 	P_LoadSideDefs2(lastloadedmaplumpnum + ML_SIDEDEFS);

  0079a	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  0079f	83 c0 03	 add	 eax, 3
  007a2	50		 push	 eax
  007a3	e8 00 00 00 00	 call	 _P_LoadSideDefs2
  007a8	83 c4 04	 add	 esp, 4

; 2208 : 
; 2209 : 	R_MakeColormaps();

  007ab	e8 00 00 00 00	 call	 _R_MakeColormaps
  007b0	90		 npad	 1

; 2210 : 	P_LoadLineDefs2();

  007b1	e8 00 00 00 00	 call	 _P_LoadLineDefs2
  007b6	90		 npad	 1

; 2211 : 	P_LoadSubsectors(lastloadedmaplumpnum + ML_SSECTORS);

  007b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  007bc	83 c0 06	 add	 eax, 6
  007bf	50		 push	 eax
  007c0	e8 00 00 00 00	 call	 _P_LoadSubsectors
  007c5	83 c4 04	 add	 esp, 4

; 2212 : 	P_LoadNodes(lastloadedmaplumpnum + ML_NODES);

  007c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  007cd	83 c0 07	 add	 eax, 7
  007d0	50		 push	 eax
  007d1	e8 00 00 00 00	 call	 _P_LoadNodes
  007d6	83 c4 04	 add	 esp, 4

; 2213 : 	P_LoadSegs(lastloadedmaplumpnum + ML_SEGS);

  007d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  007de	83 c0 05	 add	 eax, 5
  007e1	50		 push	 eax
  007e2	e8 00 00 00 00	 call	 _P_LoadSegs
  007e7	83 c4 04	 add	 esp, 4

; 2214 : 	rejectmatrix = W_CacheLumpNum(lastloadedmaplumpnum + ML_REJECT, PU_LEVEL);

  007ea	6a 32		 push	 50			; 00000032H
  007ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  007f1	83 c0 09	 add	 eax, 9
  007f4	50		 push	 eax
  007f5	e8 00 00 00 00	 call	 _W_CacheLumpNum
  007fa	83 c4 08	 add	 esp, 8
  007fd	a3 00 00 00 00	 mov	 DWORD PTR _rejectmatrix, eax

; 2215 : 	P_GroupLines();

  00802	e8 00 00 00 00	 call	 _P_GroupLines
  00807	90		 npad	 1

; 2216 : 
; 2217 : 	numdmstarts = numredctfstarts = numbluectfstarts = 0;

  00808	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numbluectfstarts, 0
  00812	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbluectfstarts
  00817	a3 00 00 00 00	 mov	 DWORD PTR _numredctfstarts, eax
  0081c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numredctfstarts
  00822	89 0d 00 00 00
	00		 mov	 DWORD PTR _numdmstarts, ecx

; 2218 : 
; 2219 : 	// reset the player starts
; 2220 : 	for (i = 0; i < MAXPLAYERS; i++)

  00828	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0082f	eb 09		 jmp	 SHORT $LN7@P_SetupLev
$LN5@P_SetupLev:
  00831	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00834	83 c0 01	 add	 eax, 1
  00837	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_SetupLev:
  0083a	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0083e	7d 10		 jge	 SHORT $LN6@P_SetupLev

; 2221 : 		playerstarts[i] = NULL;

  00840	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00843	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _playerstarts[eax*4], 0
  0084e	eb e1		 jmp	 SHORT $LN5@P_SetupLev
$LN6@P_SetupLev:

; 2222 : 
; 2223 : 	P_MapStart();

  00850	e8 00 00 00 00	 call	 _P_MapStart
  00855	90		 npad	 1

; 2224 : 
; 2225 : 	P_LoadThings(lastloadedmaplumpnum + ML_THINGS);

  00856	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  0085b	83 c0 01	 add	 eax, 1
  0085e	50		 push	 eax
  0085f	e8 00 00 00 00	 call	 _P_LoadThings
  00864	83 c4 04	 add	 esp, 4

; 2226 : 
; 2227 : 	P_SpawnSecretItems(loademblems);

  00867	8b 45 f0	 mov	 eax, DWORD PTR _loademblems$[ebp]
  0086a	50		 push	 eax
  0086b	e8 00 00 00 00	 call	 _P_SpawnSecretItems
  00870	83 c4 04	 add	 esp, 4

; 2228 : 
; 2229 : 	for (numcoopstarts = 0; numcoopstarts < MAXPLAYERS; numcoopstarts++)

  00873	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numcoopstarts, 0
  0087d	eb 0d		 jmp	 SHORT $LN10@P_SetupLev
$LN8@P_SetupLev:
  0087f	a1 00 00 00 00	 mov	 eax, DWORD PTR _numcoopstarts
  00884	83 c0 01	 add	 eax, 1
  00887	a3 00 00 00 00	 mov	 DWORD PTR _numcoopstarts, eax
$LN10@P_SetupLev:
  0088c	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR _numcoopstarts, 32 ; 00000020H
  00893	7d 13		 jge	 SHORT $LN9@P_SetupLev

; 2230 : 		if (!playerstarts[numcoopstarts])

  00895	a1 00 00 00 00	 mov	 eax, DWORD PTR _numcoopstarts
  0089a	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playerstarts[eax*4], 0
  008a2	75 02		 jne	 SHORT $LN44@P_SetupLev

; 2231 : 			break;

  008a4	eb 02		 jmp	 SHORT $LN9@P_SetupLev
$LN44@P_SetupLev:
  008a6	eb d7		 jmp	 SHORT $LN8@P_SetupLev
$LN9@P_SetupLev:

; 2232 : 
; 2233 : 	// set up world state
; 2234 : 	P_SpawnSpecials(fromnetsave);

  008a8	8b 45 ec	 mov	 eax, DWORD PTR _fromnetsave$[ebp]
  008ab	50		 push	 eax
  008ac	e8 00 00 00 00	 call	 _P_SpawnSpecials
  008b1	83 c4 04	 add	 esp, 4

; 2235 : 
; 2236 : 	if (loadprecip) //  ugly hack for P_NetUnArchiveMisc (and P_LoadNetGame)

  008b4	83 7d f4 00	 cmp	 DWORD PTR _loadprecip$[ebp], 0
  008b8	74 06		 je	 SHORT $LN45@P_SetupLev

; 2237 : 		P_SpawnPrecipitation();

  008ba	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  008bf	90		 npad	 1
$LN45@P_SetupLev:

; 2238 : 
; 2239 : 	globalweather = mapheaderinfo[gamemap-1].weather;

  008c0	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  008c7	83 e8 01	 sub	 eax, 1
  008ca	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  008d0	8a 91 4d 00 00
	00		 mov	 dl, BYTE PTR _mapheaderinfo[ecx+77]
  008d6	88 15 00 00 00
	00		 mov	 BYTE PTR _globalweather, dl

; 2240 : 
; 2241 : // Moved this down. This modifies the seg information which causes polyobjects to break.
; 2242 : // By moving it down below P_SpawnSpecials(), polyobjects can now function properly. -Jazz
; 2243 : #ifdef HWRENDER // not win32 only 19990829 by Kin
; 2244 : 	if (rendermode != render_soft && rendermode != render_none)

  008dc	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  008e3	74 20		 je	 SHORT $LN46@P_SetupLev
  008e5	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  008ec	74 17		 je	 SHORT $LN46@P_SetupLev

; 2245 : 	{
; 2246 : 		// Correct missing sidedefs & deep water trick
; 2247 : 		HWR_CorrectSWTricks();

  008ee	e8 00 00 00 00	 call	 _HWR_CorrectSWTricks
  008f3	90		 npad	 1

; 2248 : 		HWR_CreatePlanePolygons((INT32)numnodes - 1);

  008f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _numnodes
  008f9	83 e8 01	 sub	 eax, 1
  008fc	50		 push	 eax
  008fd	e8 00 00 00 00	 call	 _HWR_CreatePlanePolygons
  00902	83 c4 04	 add	 esp, 4
$LN46@P_SetupLev:

; 2249 : 	}
; 2250 : #endif
; 2251 : 
; 2252 : 	for (i = 0; i < MAXPLAYERS; i++)

  00905	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0090c	eb 09		 jmp	 SHORT $LN13@P_SetupLev
$LN11@P_SetupLev:
  0090e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00911	83 c0 01	 add	 eax, 1
  00914	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@P_SetupLev:
  00917	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0091b	0f 8d d0 00 00
	00		 jge	 $LN12@P_SetupLev

; 2253 : 		if (playeringame[i])

  00921	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00924	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0092c	0f 84 ba 00 00
	00		 je	 $LN52@P_SetupLev

; 2254 : 		{
; 2255 : 			players[i].pflags &= ~PF_NIGHTSMODE;

  00932	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00939	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  0093f	81 e1 ff ff df
	ff		 and	 ecx, -2097153		; ffdfffffH
  00945	69 55 f8 fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  0094c	89 8a ac 00 00
	00		 mov	 DWORD PTR _players[edx+172], ecx

; 2256 : 
; 2257 : 			if (gametype == GT_MATCH
; 2258 : #ifdef CHAOSISNOTDEADYET
; 2259 : 				|| gametype == GT_CHAOS
; 2260 : #endif
; 2261 : 				|| gametype == GT_TAG)

  00952	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00959	83 f8 01	 cmp	 eax, 1
  0095c	74 0c		 je	 SHORT $LN50@P_SetupLev
  0095e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00965	83 f8 03	 cmp	 eax, 3
  00968	75 1f		 jne	 SHORT $LN48@P_SetupLev
$LN50@P_SetupLev:

; 2262 : 			{
; 2263 : 				players[i].mo = NULL;

  0096a	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00971	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax], 0

; 2264 : 				G_DoReborn(i);

  0097b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0097e	50		 push	 eax
  0097f	e8 00 00 00 00	 call	 _G_DoReborn
  00984	83 c4 04	 add	 esp, 4

; 2265 : 			}

  00987	eb 63		 jmp	 SHORT $LN52@P_SetupLev
$LN48@P_SetupLev:

; 2266 : 			else // gametype is GT_COOP or GT_RACE
; 2267 : 			{
; 2268 : 				players[i].mo = NULL;

  00989	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00990	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax], 0

; 2269 : 
; 2270 : 				if (players[i].starposttime)

  0099a	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  009a1	83 b8 90 01 00
	00 00		 cmp	 DWORD PTR _players[eax+400], 0
  009a8	74 34		 je	 SHORT $LN51@P_SetupLev

; 2271 : 				{
; 2272 : 					G_CoopSpawnPlayer(i, true);

  009aa	6a 01		 push	 1
  009ac	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  009af	50		 push	 eax
  009b0	e8 00 00 00 00	 call	 _G_CoopSpawnPlayer
  009b5	83 c4 08	 add	 esp, 8

; 2273 : 					P_ClearStarPost(&players[i], players[i].starpostnum);

  009b8	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  009bf	8b 88 8c 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+396]
  009c5	51		 push	 ecx
  009c6	69 55 f8 fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  009cd	81 c2 00 00 00
	00		 add	 edx, OFFSET _players
  009d3	52		 push	 edx
  009d4	e8 00 00 00 00	 call	 _P_ClearStarPost
  009d9	83 c4 08	 add	 esp, 8

; 2274 : 				}

  009dc	eb 0e		 jmp	 SHORT $LN52@P_SetupLev
$LN51@P_SetupLev:

; 2275 : 				else
; 2276 : 					G_CoopSpawnPlayer(i, false);

  009de	6a 00		 push	 0
  009e0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  009e3	50		 push	 eax
  009e4	e8 00 00 00 00	 call	 _G_CoopSpawnPlayer
  009e9	83 c4 08	 add	 esp, 8
$LN52@P_SetupLev:

; 2277 : 			}
; 2278 : 		}

  009ec	e9 1d ff ff ff	 jmp	 $LN11@P_SetupLev
$LN12@P_SetupLev:

; 2279 : 
; 2280 : 	if (gametype == GT_TAG)

  009f1	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  009f8	83 f8 03	 cmp	 eax, 3
  009fb	0f 85 4f 01 00
	00		 jne	 $LN56@P_SetupLev

; 2281 : 	{
; 2282 : 		INT32 realnumplayers = 0;

  00a01	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _realnumplayers$3[ebp], 0

; 2283 : 		INT32 playersactive[MAXPLAYERS];
; 2284 : 
; 2285 : 		//I just realized how problematic this code can be.
; 2286 : 		//D_NumPlayers() will not always cover the scope of the netgame.
; 2287 : 		//What if one player is node 0 and the other node 31?
; 2288 : 		//The solution? Make a temp array of all players that are currently playing and pick from them.
; 2289 : 		//Future todo? When a player leaves, shift all nodes down so D_NumPlayers() can be used as intended?
; 2290 : 		//Also, you'd never have to loop through all 32 players slots to find anything ever again. =P -Jazz
; 2291 : 		for (i = 0; i < MAXPLAYERS; i++)

  00a08	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00a0f	eb 09		 jmp	 SHORT $LN16@P_SetupLev
$LN14@P_SetupLev:
  00a11	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a14	83 c0 01	 add	 eax, 1
  00a17	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN16@P_SetupLev:
  00a1a	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00a1e	7d 37		 jge	 SHORT $LN15@P_SetupLev

; 2292 : 		{
; 2293 : 			if (playeringame[i] && !players[i].spectator)

  00a20	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a23	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00a2b	74 28		 je	 SHORT $LN54@P_SetupLev
  00a2d	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00a34	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  00a3b	85 c9		 test	 ecx, ecx
  00a3d	75 16		 jne	 SHORT $LN54@P_SetupLev

; 2294 : 			{
; 2295 : 				playersactive[realnumplayers] = i; //stores the player's node in the array.

  00a3f	8b 45 ac	 mov	 eax, DWORD PTR _realnumplayers$3[ebp]
  00a42	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00a45	89 8c 85 2c ff
	ff ff		 mov	 DWORD PTR _playersactive$2[ebp+eax*4], ecx

; 2296 : 				realnumplayers++;

  00a4c	8b 45 ac	 mov	 eax, DWORD PTR _realnumplayers$3[ebp]
  00a4f	83 c0 01	 add	 eax, 1
  00a52	89 45 ac	 mov	 DWORD PTR _realnumplayers$3[ebp], eax
$LN54@P_SetupLev:

; 2297 : 			}
; 2298 : 		}

  00a55	eb ba		 jmp	 SHORT $LN14@P_SetupLev
$LN15@P_SetupLev:

; 2299 : 
; 2300 : 		if (realnumplayers) //this should also fix the dedicated crash bug. You only pick a player if one exists to be picked.

  00a57	83 7d ac 00	 cmp	 DWORD PTR _realnumplayers$3[ebp], 0
  00a5b	0f 84 e2 00 00
	00		 je	 $LN55@P_SetupLev

; 2301 : 		{
; 2302 : 			i = P_Random() % realnumplayers;

  00a61	e8 00 00 00 00	 call	 _P_Random
  00a66	0f b6 c0	 movzx	 eax, al
  00a69	99		 cdq
  00a6a	f7 7d ac	 idiv	 DWORD PTR _realnumplayers$3[ebp]
  00a6d	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 2303 : 			players[playersactive[i]].pflags |= PF_TAGIT; //choose our initial tagger before map starts.

  00a70	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a73	69 8c 85 2c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playersactive$2[ebp+eax*4], 508
  00a7e	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+172]
  00a84	81 ca 00 00 00
	10		 or	 edx, 268435456		; 10000000H
  00a8a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a8d	69 8c 85 2c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playersactive$2[ebp+eax*4], 508
  00a98	89 91 ac 00 00
	00		 mov	 DWORD PTR _players[ecx+172], edx

; 2304 : 
; 2305 : 			// Taken and modified from G_DoReborn()
; 2306 : 			// Remove the player so he can respawn elsewhere.
; 2307 : 			// first dissasociate the corpse
; 2308 : 			if (players[playersactive[i]].mo)

  00a9e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00aa1	69 8c 85 2c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playersactive$2[ebp+eax*4], 508
  00aac	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _players[ecx], 0
  00ab3	74 79		 je	 SHORT $LN57@P_SetupLev

; 2309 : 			{
; 2310 : 				players[playersactive[i]].mo->player = NULL;

  00ab5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00ab8	69 8c 85 2c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playersactive$2[ebp+eax*4], 508
  00ac3	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  00ac9	c7 82 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+164], 0

; 2311 : 				players[playersactive[i]].mo->flags2 &= ~MF2_DONTDRAW;

  00ad3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00ad6	69 8c 85 2c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playersactive$2[ebp+eax*4], 508
  00ae1	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  00ae7	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [edx+136]
  00aed	25 ff ff bf ff	 and	 eax, -4194305		; ffbfffffH
  00af2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00af5	69 94 8d 2c ff
	ff ff fc 01 00
	00		 imul	 edx, DWORD PTR _playersactive$2[ebp+ecx*4], 508
  00b00	8b 8a 00 00 00
	00		 mov	 ecx, DWORD PTR _players[edx]
  00b06	89 81 88 00 00
	00		 mov	 DWORD PTR [ecx+136], eax

; 2312 : 				// Don't leave your carcass stuck 10-billion feet in the ground!
; 2313 : 				P_SetMobjState(players[playersactive[i]].mo, S_DISS);

  00b0c	68 4f 06 00 00	 push	 1615			; 0000064fH
  00b11	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00b14	69 8c 85 2c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playersactive$2[ebp+eax*4], 508
  00b1f	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  00b25	52		 push	 edx
  00b26	e8 00 00 00 00	 call	 _P_SetMobjState
  00b2b	83 c4 08	 add	 esp, 8
$LN57@P_SetupLev:

; 2314 : 			}
; 2315 : 
; 2316 : 			G_DeathMatchSpawnPlayer(playersactive[i]); //respawn the lucky player in his dedicated spawn location.

  00b2e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00b31	8b 8c 85 2c ff
	ff ff		 mov	 ecx, DWORD PTR _playersactive$2[ebp+eax*4]
  00b38	51		 push	 ecx
  00b39	e8 00 00 00 00	 call	 _G_DeathMatchSpawnPlayer
  00b3e	83 c4 04	 add	 esp, 4

; 2317 : 		}

  00b41	eb 0d		 jmp	 SHORT $LN56@P_SetupLev
$LN55@P_SetupLev:

; 2318 : 		else
; 2319 : 			CONS_Printf("No player currently available to become IT. Awaiting available players.\n");

  00b43	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@LCKKENJK@No?5player?5currently?5available?5t@
  00b48	e8 00 00 00 00	 call	 _CONS_Printf
  00b4d	83 c4 04	 add	 esp, 4
$LN56@P_SetupLev:

; 2320 : 
; 2321 : 	}
; 2322 : 
; 2323 : 	if (!dedicated)

  00b50	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00b57	0f 85 97 01 00
	00		 jne	 $LN58@P_SetupLev

; 2324 : 	{
; 2325 : 		if (players[displayplayer].mo)

  00b5d	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00b67	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00b6e	74 64		 je	 SHORT $LN59@P_SetupLev

; 2326 : 		{
; 2327 : 			camera.x = players[displayplayer].mo->x;

  00b70	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00b7a	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00b80	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00b83	89 15 10 00 00
	00		 mov	 DWORD PTR _camera+16, edx

; 2328 : 			camera.y = players[displayplayer].mo->y;

  00b89	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00b93	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00b99	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00b9c	89 15 14 00 00
	00		 mov	 DWORD PTR _camera+20, edx

; 2329 : 			camera.z = players[displayplayer].mo->z;

  00ba2	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00bac	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00bb2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00bb5	89 15 18 00 00
	00		 mov	 DWORD PTR _camera+24, edx

; 2330 : 			camera.angle = players[displayplayer].mo->angle;

  00bbb	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00bc5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00bcb	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00bce	89 15 1c 00 00
	00		 mov	 DWORD PTR _camera+28, edx
$LN59@P_SetupLev:

; 2331 : 		}
; 2332 : 
; 2333 : 		if (!cv_cam_height.changed)

  00bd4	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam_height+34
  00bdb	85 c0		 test	 eax, eax
  00bdd	75 13		 jne	 SHORT $LN60@P_SetupLev

; 2334 : 			CV_Set(&cv_cam_height, cv_cam_height.defaultvalue);

  00bdf	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam_height+4
  00be4	50		 push	 eax
  00be5	68 00 00 00 00	 push	 OFFSET _cv_cam_height
  00bea	e8 00 00 00 00	 call	 _CV_Set
  00bef	83 c4 08	 add	 esp, 8
$LN60@P_SetupLev:

; 2335 : 
; 2336 : 		if (!cv_cam_dist.changed)

  00bf2	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam_dist+34
  00bf9	85 c0		 test	 eax, eax
  00bfb	75 13		 jne	 SHORT $LN61@P_SetupLev

; 2337 : 			CV_Set(&cv_cam_dist, cv_cam_dist.defaultvalue);

  00bfd	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam_dist+4
  00c02	50		 push	 eax
  00c03	68 00 00 00 00	 push	 OFFSET _cv_cam_dist
  00c08	e8 00 00 00 00	 call	 _CV_Set
  00c0d	83 c4 08	 add	 esp, 8
$LN61@P_SetupLev:

; 2338 : 
; 2339 : 		if (!cv_cam_rotate.changed)

  00c10	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam_rotate+34
  00c17	85 c0		 test	 eax, eax
  00c19	75 13		 jne	 SHORT $LN62@P_SetupLev

; 2340 : 			CV_Set(&cv_cam_rotate, cv_cam_rotate.defaultvalue);

  00c1b	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam_rotate+4
  00c20	50		 push	 eax
  00c21	68 00 00 00 00	 push	 OFFSET _cv_cam_rotate
  00c26	e8 00 00 00 00	 call	 _CV_Set
  00c2b	83 c4 08	 add	 esp, 8
$LN62@P_SetupLev:

; 2341 : 
; 2342 : 		if (!cv_cam2_height.changed)

  00c2e	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam2_height+34
  00c35	85 c0		 test	 eax, eax
  00c37	75 13		 jne	 SHORT $LN63@P_SetupLev

; 2343 : 			CV_Set(&cv_cam2_height, cv_cam2_height.defaultvalue);

  00c39	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam2_height+4
  00c3e	50		 push	 eax
  00c3f	68 00 00 00 00	 push	 OFFSET _cv_cam2_height
  00c44	e8 00 00 00 00	 call	 _CV_Set
  00c49	83 c4 08	 add	 esp, 8
$LN63@P_SetupLev:

; 2344 : 
; 2345 : 		if (!cv_cam2_dist.changed)

  00c4c	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam2_dist+34
  00c53	85 c0		 test	 eax, eax
  00c55	75 13		 jne	 SHORT $LN64@P_SetupLev

; 2346 : 			CV_Set(&cv_cam2_dist, cv_cam2_dist.defaultvalue);

  00c57	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam2_dist+4
  00c5c	50		 push	 eax
  00c5d	68 00 00 00 00	 push	 OFFSET _cv_cam2_dist
  00c62	e8 00 00 00 00	 call	 _CV_Set
  00c67	83 c4 08	 add	 esp, 8
$LN64@P_SetupLev:

; 2347 : 
; 2348 : 		if (!cv_cam2_rotate.changed)

  00c6a	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_cam2_rotate+34
  00c71	85 c0		 test	 eax, eax
  00c73	75 13		 jne	 SHORT $LN65@P_SetupLev

; 2349 : 			CV_Set(&cv_cam2_rotate, cv_cam2_rotate.defaultvalue);

  00c75	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_cam2_rotate+4
  00c7a	50		 push	 eax
  00c7b	68 00 00 00 00	 push	 OFFSET _cv_cam2_rotate
  00c80	e8 00 00 00 00	 call	 _CV_Set
  00c85	83 c4 08	 add	 esp, 8
$LN65@P_SetupLev:

; 2350 : 
; 2351 : 		if (!cv_useranalog.value)

  00c88	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_useranalog+20, 0
  00c8f	75 34		 jne	 SHORT $LN68@P_SetupLev

; 2352 : 		{
; 2353 : 			if (!cv_analog.changed)

  00c91	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_analog+34
  00c98	85 c0		 test	 eax, eax
  00c9a	75 0f		 jne	 SHORT $LN67@P_SetupLev

; 2354 : 				CV_SetValue(&cv_analog, 0);

  00c9c	6a 00		 push	 0
  00c9e	68 00 00 00 00	 push	 OFFSET _cv_analog
  00ca3	e8 00 00 00 00	 call	 _CV_SetValue
  00ca8	83 c4 08	 add	 esp, 8
$LN67@P_SetupLev:

; 2355 : 			if (!cv_analog2.changed)

  00cab	0f be 05 22 00
	00 00		 movsx	 eax, BYTE PTR _cv_analog2+34
  00cb2	85 c0		 test	 eax, eax
  00cb4	75 0f		 jne	 SHORT $LN68@P_SetupLev

; 2356 : 				CV_SetValue(&cv_analog2, 0);

  00cb6	6a 00		 push	 0
  00cb8	68 00 00 00 00	 push	 OFFSET _cv_analog2
  00cbd	e8 00 00 00 00	 call	 _CV_SetValue
  00cc2	83 c4 08	 add	 esp, 8
$LN68@P_SetupLev:

; 2357 : 		}
; 2358 : 
; 2359 : #ifdef HWRENDER
; 2360 : 		if (rendermode != render_soft && rendermode != render_none)

  00cc5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00ccc	74 1c		 je	 SHORT $LN69@P_SetupLev
  00cce	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00cd5	74 13		 je	 SHORT $LN69@P_SetupLev

; 2361 : 			CV_Set(&cv_grfov, cv_grfov.defaultvalue);

  00cd7	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_grfov+4
  00cdc	50		 push	 eax
  00cdd	68 00 00 00 00	 push	 OFFSET _cv_grfov
  00ce2	e8 00 00 00 00	 call	 _CV_Set
  00ce7	83 c4 08	 add	 esp, 8
$LN69@P_SetupLev:

; 2362 : #endif
; 2363 : 
; 2364 : 		displayplayer = consoleplayer; // Start with your OWN view, please!

  00cea	a1 00 00 00 00	 mov	 eax, DWORD PTR _consoleplayer
  00cef	a3 00 00 00 00	 mov	 DWORD PTR _displayplayer, eax
$LN58@P_SetupLev:

; 2365 : 	}
; 2366 : 
; 2367 : 	if (cv_useranalog.value)

  00cf4	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_useranalog+20, 0
  00cfb	74 0f		 je	 SHORT $LN70@P_SetupLev

; 2368 : 		CV_SetValue(&cv_analog, true);

  00cfd	6a 01		 push	 1
  00cff	68 00 00 00 00	 push	 OFFSET _cv_analog
  00d04	e8 00 00 00 00	 call	 _CV_SetValue
  00d09	83 c4 08	 add	 esp, 8
$LN70@P_SetupLev:

; 2369 : 
; 2370 : 	if (splitscreen && cv_useranalog2.value)

  00d0c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00d13	74 18		 je	 SHORT $LN71@P_SetupLev
  00d15	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_useranalog2+20, 0
  00d1c	74 0f		 je	 SHORT $LN71@P_SetupLev

; 2371 : 		CV_SetValue(&cv_analog2, true);

  00d1e	6a 01		 push	 1
  00d20	68 00 00 00 00	 push	 OFFSET _cv_analog2
  00d25	e8 00 00 00 00	 call	 _CV_SetValue
  00d2a	83 c4 08	 add	 esp, 8
$LN71@P_SetupLev:

; 2372 : 
; 2373 : 	if (twodlevel)

  00d2d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  00d34	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d39	74 30		 je	 SHORT $LN72@P_SetupLev

; 2374 : 	{
; 2375 : 		CV_SetValue(&cv_cam_dist, 320);

  00d3b	68 40 01 00 00	 push	 320			; 00000140H
  00d40	68 00 00 00 00	 push	 OFFSET _cv_cam_dist
  00d45	e8 00 00 00 00	 call	 _CV_SetValue
  00d4a	83 c4 08	 add	 esp, 8

; 2376 : 		CV_SetValue(&cv_analog2, false);

  00d4d	6a 00		 push	 0
  00d4f	68 00 00 00 00	 push	 OFFSET _cv_analog2
  00d54	e8 00 00 00 00	 call	 _CV_SetValue
  00d59	83 c4 08	 add	 esp, 8

; 2377 : 		CV_SetValue(&cv_analog, false);

  00d5c	6a 00		 push	 0
  00d5e	68 00 00 00 00	 push	 OFFSET _cv_analog
  00d63	e8 00 00 00 00	 call	 _CV_SetValue
  00d68	83 c4 08	 add	 esp, 8
$LN72@P_SetupLev:

; 2378 : 	}
; 2379 : 
; 2380 : 	// clear special respawning que
; 2381 : 	iquehead = iquetail = 0;

  00d6b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _iquetail, 0
  00d75	a1 00 00 00 00	 mov	 eax, DWORD PTR _iquetail
  00d7a	a3 00 00 00 00	 mov	 DWORD PTR _iquehead, eax

; 2382 : 
; 2383 : 	// Fab : 19-07-98 : start cd music for this level (note: can be remapped)
; 2384 : 	I_PlayCD((UINT8)(map + 1), false);

  00d7f	6a 00		 push	 0
  00d81	8b 45 08	 mov	 eax, DWORD PTR _map$[ebp]
  00d84	83 c0 01	 add	 eax, 1
  00d87	50		 push	 eax
  00d88	e8 00 00 00 00	 call	 _I_PlayCD
  00d8d	83 c4 08	 add	 esp, 8

; 2385 : 
; 2386 : 	// preload graphics
; 2387 : #ifdef HWRENDER // not win32 only 19990829 by Kin
; 2388 : 	if (rendermode != render_soft && rendermode != render_none)

  00d90	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00d97	74 17		 je	 SHORT $LN73@P_SetupLev
  00d99	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00da0	74 0e		 je	 SHORT $LN73@P_SetupLev

; 2389 : 	{
; 2390 : 		HWR_PrepLevelCache(numtextures);

  00da2	a1 00 00 00 00	 mov	 eax, DWORD PTR _numtextures
  00da7	50		 push	 eax
  00da8	e8 00 00 00 00	 call	 _HWR_PrepLevelCache
  00dad	83 c4 04	 add	 esp, 4
$LN73@P_SetupLev:

; 2391 : 	}
; 2392 : #endif
; 2393 : 
; 2394 : 	P_MapEnd();

  00db0	e8 00 00 00 00	 call	 _P_MapEnd
  00db5	90		 npad	 1

; 2395 : 
; 2396 : 
; 2397 : 
; 2398 : 	if (precache || dedicated)

  00db6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _precache, 0
  00dbd	75 09		 jne	 SHORT $LN75@P_SetupLev
  00dbf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00dc6	74 06		 je	 SHORT $LN74@P_SetupLev
$LN75@P_SetupLev:

; 2399 : 		R_PrecacheLevel();

  00dc8	e8 00 00 00 00	 call	 _R_PrecacheLevel
  00dcd	90		 npad	 1
$LN74@P_SetupLev:

; 2400 : 
; 2401 : 	nextmapoverride = 0;

  00dce	33 c0		 xor	 eax, eax
  00dd0	66 a3 00 00 00
	00		 mov	 WORD PTR _nextmapoverride, ax

; 2402 : 	nextmapgametype = -1;

  00dd6	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nextmapgametype, -1

; 2403 : 	skipstats = false;

  00de0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _skipstats, 0

; 2404 : 
; 2405 : 	if (!(netgame || multiplayer) && (!modifiedgame || savemoddata))

  00dea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00df1	75 29		 jne	 SHORT $LN76@P_SetupLev
  00df3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00dfa	75 20		 jne	 SHORT $LN76@P_SetupLev
  00dfc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _modifiedgame, 0
  00e03	74 09		 je	 SHORT $LN77@P_SetupLev
  00e05	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _savemoddata, 0
  00e0c	74 0e		 je	 SHORT $LN76@P_SetupLev
$LN77@P_SetupLev:

; 2406 : 		mapvisited[gamemap-1] = true;

  00e0e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00e15	c6 80 ff ff ff
	ff 01		 mov	 BYTE PTR _mapvisited[eax-1], 1
$LN76@P_SetupLev:

; 2407 : 
; 2408 : 	levelloading = false;

  00e1c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _levelloading, 0

; 2409 : 
; 2410 : 	P_RunCachedActions();

  00e26	e8 00 00 00 00	 call	 _P_RunCachedActions
  00e2b	90		 npad	 1

; 2411 : 
; 2412 : 	if (!(netgame || multiplayer || demoplayback || demorecording || timeattacking || players[consoleplayer].lives <= 0)
; 2413 : 		&& (!modifiedgame || savemoddata) && cursaveslot != -1 && !ultimatemode
; 2414 : 		&& !mapheaderinfo[gamemap-1].hideinmenu
; 2415 : 		&& (!G_IsSpecialStage(gamemap)) && gamemap != lastmapsaved && (mapheaderinfo[gamemap-1].actnum < 2 || gamecomplete))

  00e2c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00e33	0f 85 e7 00 00
	00		 jne	 $LN78@P_SetupLev
  00e39	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00e40	0f 85 da 00 00
	00		 jne	 $LN78@P_SetupLev
  00e46	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demoplayback, 0
  00e4d	0f 85 cd 00 00
	00		 jne	 $LN78@P_SetupLev
  00e53	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demorecording, 0
  00e5a	0f 85 c0 00 00
	00		 jne	 $LN78@P_SetupLev
  00e60	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  00e67	0f 85 b3 00 00
	00		 jne	 $LN78@P_SetupLev
  00e6d	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00e77	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR _players[eax+256], 0
  00e7e	0f 8e 9c 00 00
	00		 jle	 $LN78@P_SetupLev
  00e84	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _modifiedgame, 0
  00e8b	74 0d		 je	 SHORT $LN79@P_SetupLev
  00e8d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _savemoddata, 0
  00e94	0f 84 86 00 00
	00		 je	 $LN78@P_SetupLev
$LN79@P_SetupLev:
  00e9a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _cursaveslot, -1
  00ea1	74 7d		 je	 SHORT $LN78@P_SetupLev
  00ea3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _ultimatemode
  00eaa	85 c0		 test	 eax, eax
  00eac	75 72		 jne	 SHORT $LN78@P_SetupLev
  00eae	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00eb5	83 e8 01	 sub	 eax, 1
  00eb8	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00ebe	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[ecx+292], 0
  00ec5	75 59		 jne	 SHORT $LN78@P_SetupLev
  00ec7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00ece	50		 push	 eax
  00ecf	e8 00 00 00 00	 call	 _G_IsSpecialStage
  00ed4	83 c4 04	 add	 esp, 4
  00ed7	85 c0		 test	 eax, eax
  00ed9	75 45		 jne	 SHORT $LN78@P_SetupLev
  00edb	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00ee2	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _lastmapsaved
  00ee9	3b c1		 cmp	 eax, ecx
  00eeb	74 33		 je	 SHORT $LN78@P_SetupLev
  00eed	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00ef4	83 e8 01	 sub	 eax, 1
  00ef7	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00efd	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00f04	83 fa 02	 cmp	 edx, 2
  00f07	7c 09		 jl	 SHORT $LN80@P_SetupLev
  00f09	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gamecomplete, 0
  00f10	74 0e		 je	 SHORT $LN78@P_SetupLev
$LN80@P_SetupLev:

; 2416 : 		G_SaveGame((UINT32)cursaveslot);

  00f12	a1 00 00 00 00	 mov	 eax, DWORD PTR _cursaveslot
  00f17	50		 push	 eax
  00f18	e8 00 00 00 00	 call	 _G_SaveGame
  00f1d	83 c4 04	 add	 esp, 4
$LN78@P_SetupLev:

; 2417 : 
; 2418 : 	if (savedata.lives > 0)

  00f20	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _savedata+8, 0
  00f27	7e 58		 jle	 SHORT $LN81@P_SetupLev

; 2419 : 	{
; 2420 : 		players[consoleplayer].continues = savedata.continues;

  00f29	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00f33	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _savedata+12
  00f39	89 88 04 01 00
	00		 mov	 DWORD PTR _players[eax+260], ecx

; 2421 : 		players[consoleplayer].lives = savedata.lives;

  00f3f	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00f49	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _savedata+8
  00f4f	89 88 00 01 00
	00		 mov	 DWORD PTR _players[eax+256], ecx

; 2422 : 		players[consoleplayer].score = savedata.score;

  00f55	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00f5f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _savedata+4
  00f65	89 88 bc 00 00
	00		 mov	 DWORD PTR _players[eax+188], ecx

; 2423 : 		emeralds = savedata.emeralds;

  00f6b	66 a1 10 00 00
	00		 mov	 ax, WORD PTR _savedata+16
  00f71	66 a3 00 00 00
	00		 mov	 WORD PTR _emeralds, ax

; 2424 : 		savedata.lives = 0;

  00f77	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _savedata+8, 0
$LN81@P_SetupLev:

; 2425 : 	}
; 2426 : 
; 2427 : 	return true;

  00f81	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_SetupLev:

; 2428 : }

  00f86	5f		 pop	 edi
  00f87	5e		 pop	 esi
  00f88	5b		 pop	 ebx
  00f89	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f8c	33 cd		 xor	 ecx, ebp
  00f8e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f93	8b e5		 mov	 esp, ebp
  00f95	5d		 pop	 ebp
  00f96	c3		 ret	 0
_P_SetupLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_RehitStarposts
_TEXT	SEGMENT
_i$ = -12						; size = 4
_think$ = -8						; size = 4
_mo$ = -4						; size = 4
_P_RehitStarposts PROC					; COMDAT

; 1874 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1875 : 	// Search through all the thinkers.
; 1876 : 	mobj_t *mo;
; 1877 : 	thinker_t *think;
; 1878 : 	INT32 i;
; 1879 : 
; 1880 : 	for (think = thinkercap.next; think != &thinkercap; think = think->next)

  00009	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0000e	89 45 f8	 mov	 DWORD PTR _think$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@P_RehitSta
$LN2@P_RehitSta:
  00013	8b 45 f8	 mov	 eax, DWORD PTR _think$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	89 4d f8	 mov	 DWORD PTR _think$[ebp], ecx
$LN4@P_RehitSta:
  0001c	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _think$[ebp], OFFSET _thinkercap
  00023	0f 84 88 00 00
	00		 je	 $LN3@P_RehitSta

; 1881 : 	{
; 1882 : 		if (think->function.acp1 != (actionf_p1)P_MobjThinker)

  00029	8b 45 f8	 mov	 eax, DWORD PTR _think$[ebp]
  0002c	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  00033	74 02		 je	 SHORT $LN8@P_RehitSta

; 1883 : 			continue; // not a mobj thinker

  00035	eb dc		 jmp	 SHORT $LN2@P_RehitSta
$LN8@P_RehitSta:

; 1884 : 
; 1885 : 		mo = (mobj_t *)think;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _think$[ebp]
  0003a	89 45 fc	 mov	 DWORD PTR _mo$[ebp], eax

; 1886 : 
; 1887 : 		if (mo->type != MT_STARPOST)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _mo$[ebp]
  00040	83 78 7c 4a	 cmp	 DWORD PTR [eax+124], 74	; 0000004aH
  00044	74 02		 je	 SHORT $LN9@P_RehitSta

; 1888 : 			continue;

  00046	eb cb		 jmp	 SHORT $LN2@P_RehitSta
$LN9@P_RehitSta:

; 1889 : 
; 1890 : 		for (i = 0; i < MAXPLAYERS; i++)

  00048	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004f	eb 09		 jmp	 SHORT $LN7@P_RehitSta
$LN5@P_RehitSta:
  00051	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_RehitSta:
  0005a	83 7d f4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0005e	7d 4c		 jge	 SHORT $LN6@P_RehitSta

; 1891 : 		{
; 1892 : 			if (!playeringame[i])

  00060	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00063	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0006b	75 02		 jne	 SHORT $LN10@P_RehitSta

; 1893 : 				continue;

  0006d	eb e2		 jmp	 SHORT $LN5@P_RehitSta
$LN10@P_RehitSta:

; 1894 : 
; 1895 : 			if (players[i].starpostbit & (1<<(mo->health-1)))

  0006f	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _mo$[ebp]
  00079	8b 89 8c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+140]
  0007f	83 e9 01	 sub	 ecx, 1
  00082	ba 01 00 00 00	 mov	 edx, 1
  00087	d3 e2		 shl	 edx, cl
  00089	23 90 98 01 00
	00		 and	 edx, DWORD PTR _players[eax+408]
  0008f	74 19		 je	 SHORT $LN11@P_RehitSta

; 1896 : 				P_SetMobjState(mo, mo->info->seestate);

  00091	8b 45 fc	 mov	 eax, DWORD PTR _mo$[ebp]
  00094	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0009a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0009d	52		 push	 edx
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _mo$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _P_SetMobjState
  000a7	83 c4 08	 add	 esp, 8
$LN11@P_RehitSta:

; 1897 : 		}

  000aa	eb a5		 jmp	 SHORT $LN5@P_RehitSta
$LN6@P_RehitSta:

; 1898 : 	}

  000ac	e9 62 ff ff ff	 jmp	 $LN2@P_RehitSta
$LN3@P_RehitSta:

; 1899 : }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_P_RehitStarposts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_LoadThingsOnly
_TEXT	SEGMENT
_think$ = -8						; size = 4
_mo$ = -4						; size = 4
_P_LoadThingsOnly PROC					; COMDAT

; 1907 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1908 : 	// Search through all the thinkers.
; 1909 : 	mobj_t *mo;
; 1910 : 	thinker_t *think;
; 1911 : 
; 1912 : 	for (think = thinkercap.next; think != &thinkercap; think = think->next)

  00009	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0000e	89 45 f8	 mov	 DWORD PTR _think$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@P_LoadThin
$LN2@P_LoadThin:
  00013	8b 45 f8	 mov	 eax, DWORD PTR _think$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	89 4d f8	 mov	 DWORD PTR _think$[ebp], ecx
$LN4@P_LoadThin:
  0001c	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _think$[ebp], OFFSET _thinkercap
  00023	74 28		 je	 SHORT $LN3@P_LoadThin

; 1913 : 	{
; 1914 : 		if (think->function.acp1 != (actionf_p1)P_MobjThinker)

  00025	8b 45 f8	 mov	 eax, DWORD PTR _think$[ebp]
  00028	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  0002f	74 02		 je	 SHORT $LN5@P_LoadThin

; 1915 : 			continue; // not a mobj thinker

  00031	eb e0		 jmp	 SHORT $LN2@P_LoadThin
$LN5@P_LoadThin:

; 1916 : 
; 1917 : 		mo = (mobj_t *)think;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _think$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR _mo$[ebp], eax

; 1918 : 
; 1919 : 		if (mo)

  00039	83 7d fc 00	 cmp	 DWORD PTR _mo$[ebp], 0
  0003d	74 0c		 je	 SHORT $LN6@P_LoadThin

; 1920 : 			P_RemoveMobj(mo);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _mo$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _P_RemoveMobj
  00048	83 c4 04	 add	 esp, 4
$LN6@P_LoadThin:

; 1921 : 	}

  0004b	eb c6		 jmp	 SHORT $LN2@P_LoadThin
$LN3@P_LoadThin:

; 1922 : 
; 1923 : 	P_LevelInitStuff();

  0004d	e8 00 00 00 00	 call	 _P_LevelInitStuff
  00052	90		 npad	 1

; 1924 : 
; 1925 : 	P_LoadThings(lastloadedmaplumpnum + ML_THINGS);

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  00058	83 c0 01	 add	 eax, 1
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _P_LoadThings
  00061	83 c4 04	 add	 esp, 4

; 1926 : 
; 1927 : 	P_SpawnSecretItems(true);

  00064	6a 01		 push	 1
  00066	e8 00 00 00 00	 call	 _P_SpawnSecretItems
  0006b	83 c4 04	 add	 esp, 4

; 1928 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_P_LoadThingsOnly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_SpawnSecretItems
_TEXT	SEGMENT
_loademblems$ = 8					; size = 4
_P_SpawnSecretItems PROC				; COMDAT

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 855  : 	// Now let's spawn those funky emblem things! Tails 12-08-2002
; 856  : 	if (netgame || multiplayer || (modifiedgame && !savemoddata) || timeattacking) // No cheating!!

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00010	75 24		 jne	 SHORT $LN3@P_SpawnSec
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00019	75 1b		 jne	 SHORT $LN3@P_SpawnSec
  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _modifiedgame, 0
  00022	74 09		 je	 SHORT $LN4@P_SpawnSec
  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _savemoddata, 0
  0002b	74 09		 je	 SHORT $LN3@P_SpawnSec
$LN4@P_SpawnSec:
  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  00034	74 02		 je	 SHORT $LN2@P_SpawnSec
$LN3@P_SpawnSec:

; 857  : 		return;

  00036	eb 3b		 jmp	 SHORT $LN6@P_SpawnSec
$LN2@P_SpawnSec:

; 858  : 
; 859  : 	if (loademblems)

  00038	83 7d 08 00	 cmp	 DWORD PTR _loademblems$[ebp], 0
  0003c	74 06		 je	 SHORT $LN5@P_SpawnSec

; 860  : 		P_SpawnEmblems();

  0003e	e8 00 00 00 00	 call	 _P_SpawnEmblems
  00043	90		 npad	 1
$LN5@P_SpawnSec:

; 861  : 
; 862  : 	if(gamemap == 11)

  00044	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0004b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0004e	75 23		 jne	 SHORT $LN6@P_SpawnSec

; 863  : 		P_SpawnMobj(04220000000*-1, 0554000000*-1, ONFLOORZ, MT_PXVI)->angle = ANGLE_270;

  00050	68 34 01 00 00	 push	 308			; 00000134H
  00055	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0005a	68 00 00 50 fa	 push	 -95420416		; fa500000H
  0005f	68 00 00 c0 dd	 push	 -574619648		; ddc00000H
  00064	e8 00 00 00 00	 call	 _P_SpawnMobj
  00069	83 c4 10	 add	 esp, 16			; 00000010H
  0006c	c7 40 24 00 00
	00 c0		 mov	 DWORD PTR [eax+36], -1073741824 ; c0000000H
$LN6@P_SpawnSec:

; 864  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_P_SpawnSecretItems ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_SetupLevelSky
_TEXT	SEGMENT
_skytexname$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_skynum$ = 8						; size = 4
_P_SetupLevelSky PROC					; COMDAT

; 1793 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1794 : 	char skytexname[12];
; 1795 : 
; 1796 : 	sprintf(skytexname, "SKY%d", skynum);

  00013	8b 45 08	 mov	 eax, DWORD PTR _skynum$[ebp]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_05GCBGCHNN@SKY?$CFd@
  0001c	8d 4d f0	 lea	 ecx, DWORD PTR _skytexname$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _sprintf
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1797 : 	skytexture = R_TextureNumForName(skytexname, 0xffff);

  00028	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0002d	8d 45 f0	 lea	 eax, DWORD PTR _skytexname$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _R_TextureNumForName
  00036	83 c4 08	 add	 esp, 8
  00039	a3 00 00 00 00	 mov	 DWORD PTR _skytexture, eax

; 1798 : 	levelskynum = skynum;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _skynum$[ebp]
  00041	a3 00 00 00 00	 mov	 DWORD PTR _levelskynum, eax

; 1799 : 
; 1800 : 	// scale up the old skies, if needed
; 1801 : 	R_SetupSkyDraw();

  00046	e8 00 00 00 00	 call	 _R_SetupSkyDraw
  0004b	90		 npad	 1

; 1802 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00052	33 cd		 xor	 ecx, ebp
  00054	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_P_SetupLevelSky ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_setup.c
;	COMDAT _P_AddLevelFlat
_TEXT	SEGMENT
_i$ = -4						; size = 4
_flatname$ = 8						; size = 4
_levelflat$ = 12					; size = 4
_P_AddLevelFlat PROC					; COMDAT

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 479  : 	size_t i;
; 480  : 
; 481  : 	//
; 482  : 	//  first scan through the already found flats
; 483  : 	//
; 484  : 	for (i = 0; i < numlevelflats; i++, levelflat++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 12		 jmp	 SHORT $LN4@P_AddLevel
$LN2@P_AddLevel:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _levelflat$[ebp]
  0001e	83 c1 20	 add	 ecx, 32			; 00000020H
  00021	89 4d 0c	 mov	 DWORD PTR _levelflat$[ebp], ecx
$LN4@P_AddLevel:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00027	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlevelflats
  0002d	73 1a		 jae	 SHORT $LN3@P_AddLevel

; 485  : 		if (strnicmp(levelflat->name,flatname,8)==0)

  0002f	6a 08		 push	 8
  00031	8b 45 08	 mov	 eax, DWORD PTR _flatname$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _levelflat$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strnicmp
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	85 c0		 test	 eax, eax
  00043	75 02		 jne	 SHORT $LN5@P_AddLevel

; 486  : 			break;

  00045	eb 02		 jmp	 SHORT $LN3@P_AddLevel
$LN5@P_AddLevel:
  00047	eb c9		 jmp	 SHORT $LN2@P_AddLevel
$LN3@P_AddLevel:

; 487  : 
; 488  : 	// that flat was already found in the level, return the id
; 489  : 	if (i == numlevelflats)

  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlevelflats
  00052	75 77		 jne	 SHORT $LN8@P_AddLevel

; 490  : 	{
; 491  : 		// store the name
; 492  : 		strlcpy(levelflat->name, flatname, sizeof (levelflat->name));

  00054	6a 09		 push	 9
  00056	8b 45 08	 mov	 eax, DWORD PTR _flatname$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _levelflat$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _strlcpy
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 493  : 		strupr(levelflat->name);

  00066	8b 45 0c	 mov	 eax, DWORD PTR _levelflat$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _strupr
  0006f	83 c4 04	 add	 esp, 4

; 494  : 
; 495  : 		// store the flat lump number
; 496  : 		levelflat->lumpnum = R_GetFlatNumForName(flatname);

  00072	8b 45 08	 mov	 eax, DWORD PTR _flatname$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _R_GetFlatNumForName
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _levelflat$[ebp]
  00081	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 497  : 
; 498  : 		if (devparm)

  00084	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  0008b	74 18		 je	 SHORT $LN7@P_AddLevel

; 499  : 			I_OutputMsg("flat #%03"PRIdS": %s\n", numlevelflats, levelflat->name);

  0008d	8b 45 0c	 mov	 eax, DWORD PTR _levelflat$[ebp]
  00090	50		 push	 eax
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numlevelflats
  00097	51		 push	 ecx
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PHOHEBBD@flat?5?$CD?$CF03Iu?3?5?$CFs?6@
  0009d	e8 00 00 00 00	 call	 _I_OutputMsg
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@P_AddLevel:

; 500  : 
; 501  : 		numlevelflats++;

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlevelflats
  000aa	83 c0 01	 add	 eax, 1
  000ad	a3 00 00 00 00	 mov	 DWORD PTR _numlevelflats, eax

; 502  : 
; 503  : 		if (numlevelflats >= MAXLEVELFLATS)

  000b2	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR _numlevelflats, 256 ; 00000100H
  000bc	72 0d		 jb	 SHORT $LN8@P_AddLevel

; 504  : 			I_Error("Too many flats in level\n");

  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OLDEIAOF@Too?5many?5flats?5in?5level?6@
  000c3	e8 00 00 00 00	 call	 _I_Error
  000c8	83 c4 04	 add	 esp, 4
$LN8@P_AddLevel:

; 505  : 	}
; 506  : 
; 507  : 	// level flat id
; 508  : 	return (INT32)i;

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 509  : }

  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
_P_AddLevelFlat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
