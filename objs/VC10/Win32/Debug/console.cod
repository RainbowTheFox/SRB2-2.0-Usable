; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\console.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_con_startup
PUBLIC	_cons_backcolor
PUBLIC	??_C@_0M@EGMNGPCL@con_hudtime@			; `string'
PUBLIC	??_C@_01BMBHCPLG@5@				; `string'
PUBLIC	??_C@_0N@FFNIDBAC@con_hudlines@			; `string'
PUBLIC	??_C@_03KGHEHEMH@MIN@				; `string'
PUBLIC	??_C@_03LEPPJAKI@MAX@				; `string'
PUBLIC	??_C@_09ICJCHCKB@con_speed@			; `string'
PUBLIC	??_C@_01KJLJFBPL@8@				; `string'
PUBLIC	??_C@_0L@LKCBDKAM@con_height@			; `string'
PUBLIC	??_C@_02PNFIDHGF@50@				; `string'
PUBLIC	??_C@_0M@EBPKCBLF@translucent@			; `string'
PUBLIC	??_C@_07LJIPPALJ@picture@			; `string'
PUBLIC	??_C@_0M@MHGLOMJK@con_backpic@			; `string'
PUBLIC	??_C@_05PLKILNHI@White@				; `string'
PUBLIC	??_C@_06LMIDBFFB@Orange@			; `string'
PUBLIC	??_C@_04CAKOHOCJ@Blue@				; `string'
PUBLIC	??_C@_05GGOIJPPE@Green@				; `string'
PUBLIC	??_C@_04KFNAIHAE@Gray@				; `string'
PUBLIC	??_C@_03PADCEAKC@Red@				; `string'
PUBLIC	??_C@_0O@COPBAJAC@con_backcolor@		; `string'
PUBLIC	??_C@_01EKENIIDA@3@				; `string'
EXTRN	_CV_Unsigned:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_con_recalc:DWORD
_DATA	ENDS
_BSS	SEGMENT
_con_startup DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_con_clipviewtop:DWORD
COMM	_con_destlines:DWORD
COMM	_con_clearlines:DWORD
COMM	_con_hudupdate:DWORD
COMM	_yellowmap:DWORD
COMM	_purplemap:DWORD
COMM	_lgreenmap:DWORD
COMM	_bluemap:DWORD
COMM	_graymap:DWORD
COMM	_redmap:DWORD
COMM	_orangemap:DWORD
COMM	_cwhitemap:DWORD
COMM	_corangemap:DWORD
COMM	_cbluemap:DWORD
COMM	_cgreenmap:DWORD
COMM	_cgraymap:DWORD
COMM	_credmap:DWORD
_DATA	ENDS
;	COMDAT ??_C@_01EKENIIDA@3@
CONST	SEGMENT
??_C@_01EKENIIDA@3@ DB '3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COPBAJAC@con_backcolor@
CONST	SEGMENT
??_C@_0O@COPBAJAC@con_backcolor@ DB 'con_backcolor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PADCEAKC@Red@
CONST	SEGMENT
??_C@_03PADCEAKC@Red@ DB 'Red', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KFNAIHAE@Gray@
CONST	SEGMENT
??_C@_04KFNAIHAE@Gray@ DB 'Gray', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGOIJPPE@Green@
CONST	SEGMENT
??_C@_05GGOIJPPE@Green@ DB 'Green', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAKOHOCJ@Blue@
CONST	SEGMENT
??_C@_04CAKOHOCJ@Blue@ DB 'Blue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMIDBFFB@Orange@
CONST	SEGMENT
??_C@_06LMIDBFFB@Orange@ DB 'Orange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PLKILNHI@White@
CONST	SEGMENT
??_C@_05PLKILNHI@White@ DB 'White', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHGLOMJK@con_backpic@
CONST	SEGMENT
??_C@_0M@MHGLOMJK@con_backpic@ DB 'con_backpic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LJIPPALJ@picture@
CONST	SEGMENT
??_C@_07LJIPPALJ@picture@ DB 'picture', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EBPKCBLF@translucent@
CONST	SEGMENT
??_C@_0M@EBPKCBLF@translucent@ DB 'translucent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PNFIDHGF@50@
CONST	SEGMENT
??_C@_02PNFIDHGF@50@ DB '50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LKCBDKAM@con_height@
CONST	SEGMENT
??_C@_0L@LKCBDKAM@con_height@ DB 'con_height', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8@
CONST	SEGMENT
??_C@_01KJLJFBPL@8@ DB '8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICJCHCKB@con_speed@
CONST	SEGMENT
??_C@_09ICJCHCKB@con_speed@ DB 'con_speed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEPPJAKI@MAX@
CONST	SEGMENT
??_C@_03LEPPJAKI@MAX@ DB 'MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGHEHEMH@MIN@
CONST	SEGMENT
??_C@_03KGHEHEMH@MIN@ DB 'MIN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFNIDBAC@con_hudlines@
CONST	SEGMENT
??_C@_0N@FFNIDBAC@con_hudlines@ DB 'con_hudlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5@
CONST	SEGMENT
??_C@_01BMBHCPLG@5@ DB '5', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EGMNGPCL@con_hudtime@
CONST	SEGMENT
??_C@_0M@EGMNGPCL@con_hudtime@ DB 'con_hudtime', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_cons_backcolor DD FLAT:??_C@_0O@COPBAJAC@con_backcolor@
	DD	FLAT:??_C@_01EKENIIDA@3@
	DD	01H
	DD	FLAT:_backcolor_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_speed_cons_t DD 01H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	0ffH
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_backpic_cons_t DD 00H
	DD	FLAT:??_C@_0M@EBPKCBLF@translucent@
	DD	01H
	DD	FLAT:??_C@_07LJIPPALJ@picture@
	DD	00H
	DD	00H
_backcolor_cons_t DD 00H
	DD	FLAT:??_C@_05PLKILNHI@White@
	DD	01H
	DD	FLAT:??_C@_06LMIDBFFB@Orange@
	DD	02H
	DD	FLAT:??_C@_04CAKOHOCJ@Blue@
	DD	03H
	DD	FLAT:??_C@_05GGOIJPPE@Green@
	DD	04H
	DD	FLAT:??_C@_04KFNAIHAE@Gray@
	DD	05H
	DD	FLAT:??_C@_03PADCEAKC@Red@
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	_vsprintf
PUBLIC	_CONS_Printf
PUBLIC	_CON_Init
PUBLIC	_CON_Responder
PUBLIC	_CON_ReSetupBackColormap
PUBLIC	_CON_ClearHUD
PUBLIC	_CON_Ticker
PUBLIC	_CON_Drawer
PUBLIC	_CONS_Error
PUBLIC	_CON_ToggleOff
PUBLIC	_CON_LogMessage
PUBLIC	??_C@_0CH@NDJNLIOG@Number?5of?5console?5HUD?5lines?5is?5@ ; `string'
PUBLIC	??_C@_0BB@KCCBKCP@English?5keymap?4?6@		; `string'
PUBLIC	??_C@_0BM@JGANNBIL@bind?5?$DMkeyname?$DO?5?$FL?$DMcommand?$DO?$FN?6@ ; `string'
PUBLIC	??_C@_0P@PKKOPABJ@?$ACbind?5table?5?3?6@	; `string'
PUBLIC	??_C@_0L@NMGFNGKI@?$CFs?5?3?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_06HMIKAKIK@Empty?6@			; `string'
PUBLIC	??_C@_0BC@LFFNNDEA@Invalid?5key?5name?6@	; `string'
PUBLIC	??_C@_07FLMOFAHC@PLAYPAL@			; `string'
PUBLIC	??_C@_08PALAOBIJ@CONSBACK@			; `string'
PUBLIC	??_C@_03LCPHGAHP@cls@				; `string'
PUBLIC	??_C@_07CNNBJDHA@english@			; `string'
PUBLIC	??_C@_04NPNJNMMP@bind@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0N@MIEJCNHC@SRB2?5Warning@		; `string'
PUBLIC	??_C@_03EOCGEGFG@?$AC?$CFs@			; `string'
PUBLIC	??_C@_0BJ@PJPAHPCN@Press?5ENTER?5to?5continue?6@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_atoi:PROC
EXTRN	_fflush:PROC
EXTRN	_fputs:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_GetKey:PROC
EXTRN	_COM_AddCommand:PROC
EXTRN	_COM_Argc:PROC
EXTRN	_COM_Argv:PROC
EXTRN	_COM_CompleteCommand:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_CV_RegisterVar:PROC
EXTRN	_CV_CompleteVar:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_G_CheckDemoStatus:PROC
EXTRN	_G_KeynumToString:PROC
EXTRN	_G_KeyStringtoNum:PROC
EXTRN	_W_CacheLumpName:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_R_GetPalname:PROC
EXTRN	_V_DrawScaledPatch:PROC
EXTRN	_V_DrawFadeConsBack:PROC
EXTRN	_V_DrawCharacter:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_StrDup:PROC
EXTRN	_I_OsPolling:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_M_StartControlPanel:PROC
EXTRN	_I_LoadingScreen:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_gamestate:DWORD
EXTRN	_M_Memcpy:DWORD
EXTRN	_timeattacking:DWORD
EXTRN	_viewwindowy:DWORD
EXTRN	_debugfile:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_gamecontrol:BYTE
EXTRN	_vid:BYTE
EXTRN	_shiftxform:DWORD
EXTRN	_english_shiftxform:BYTE
EXTRN	_chat_on:DWORD
EXTRN	_cv_allcaps:BYTE
EXTRN	_rendermode:DWORD
EXTRN	_graphics_started:BYTE
EXTRN	_logstream:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_con_started DD	01H DUP (?)
_con_tick DD	01H DUP (?)
_consoletoggle DD 01H DUP (?)
_consoleready DD 01H DUP (?)
_con_curlines DD 01H DUP (?)
_con_hudlines DD 01H DUP (?)
_con_hudtime DD	014H DUP (?)
_con_line DD	01H DUP (?)
_con_cx	DD	01H DUP (?)
_con_cy	DD	01H DUP (?)
_con_totallines DD 01H DUP (?)
_con_width DD	01H DUP (?)
_con_scrollup DD 01H DUP (?)
_inputlines DB	02000H DUP (?)
_inputline DD	01H DUP (?)
_inputhist DD	01H DUP (?)
_input_cx DD	01H DUP (?)
_con_backpic DD	01H DUP (?)
_con_buffer DB	04000H DUP (?)
_bindtable DD	01e4H DUP (?)
?shiftdown@?1??CON_Responder@@9@9 DD 01H DUP (?)	; `CON_Responder'::`2'::shiftdown
?completion@?1??CON_Responder@@9@9 DB 050H DUP (?)	; `CON_Responder'::`2'::completion
?comskips@?1??CON_Responder@@9@9 DD 01H DUP (?)		; `CON_Responder'::`2'::comskips
?varskips@?1??CON_Responder@@9@9 DD 01H DUP (?)		; `CON_Responder'::`2'::varskips
_BSS	ENDS
;	COMDAT ??_C@_0BJ@PJPAHPCN@Press?5ENTER?5to?5continue?6@
CONST	SEGMENT
??_C@_0BJ@PJPAHPCN@Press?5ENTER?5to?5continue?6@ DB 'Press ENTER to conti'
	DB	'nue', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03EOCGEGFG@?$AC?$CFs@
CONST	SEGMENT
??_C@_03EOCGEGFG@?$AC?$CFs@ DB 02H, '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MIEJCNHC@SRB2?5Warning@
CONST	SEGMENT
??_C@_0N@MIEJCNHC@SRB2?5Warning@ DB 'SRB2 Warning', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04NPNJNMMP@bind@
CONST	SEGMENT
??_C@_04NPNJNMMP@bind@ DB 'bind', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNNBJDHA@english@
CONST	SEGMENT
??_C@_07CNNBJDHA@english@ DB 'english', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCPHGAHP@cls@
CONST	SEGMENT
??_C@_03LCPHGAHP@cls@ DB 'cls', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PALAOBIJ@CONSBACK@
CONST	SEGMENT
??_C@_08PALAOBIJ@CONSBACK@ DB 'CONSBACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLMOFAHC@PLAYPAL@
CONST	SEGMENT
??_C@_07FLMOFAHC@PLAYPAL@ DB 'PLAYPAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LFFNNDEA@Invalid?5key?5name?6@
CONST	SEGMENT
??_C@_0BC@LFFNNDEA@Invalid?5key?5name?6@ DB 'Invalid key name', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMIKAKIK@Empty?6@
CONST	SEGMENT
??_C@_06HMIKAKIK@Empty?6@ DB 'Empty', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMGFNGKI@?$CFs?5?3?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0L@NMGFNGKI@?$CFs?5?3?5?$CC?$CFs?$CC?6@ DB '%s : "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PKKOPABJ@?$ACbind?5table?5?3?6@
CONST	SEGMENT
??_C@_0P@PKKOPABJ@?$ACbind?5table?5?3?6@ DB 02H, 'bind table :', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JGANNBIL@bind?5?$DMkeyname?$DO?5?$FL?$DMcommand?$DO?$FN?6@
CONST	SEGMENT
??_C@_0BM@JGANNBIL@bind?5?$DMkeyname?$DO?5?$FL?$DMcommand?$DO?$FN?6@ DB 'b'
	DB	'ind <keyname> [<command>]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KCCBKCP@English?5keymap?4?6@
CONST	SEGMENT
??_C@_0BB@KCCBKCP@English?5keymap?4?6@ DB 'English keymap.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NDJNLIOG@Number?5of?5console?5HUD?5lines?5is?5@
CONST	SEGMENT
??_C@_0CH@NDJNLIOG@Number?5of?5console?5HUD?5lines?5is?5@ DB 'Number of c'
	DB	'onsole HUD lines is now %d', 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_con_forcepic DD 01H
_cons_msgtimeout DD FLAT:??_C@_0M@EGMNGPCL@con_hudtime@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	01H
	DD	FLAT:_CV_Unsigned
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cons_hudlines DD FLAT:??_C@_0N@FFNIDBAC@con_hudlines@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	03H
	DD	FLAT:_CV_Unsigned
	DD	FLAT:_CONS_hudlines_Change
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cons_speed DD	FLAT:??_C@_09ICJCHCKB@con_speed@
	DD	FLAT:??_C@_01KJLJFBPL@8@
	DD	03H
	DD	FLAT:_speed_cons_t
	DD	FLAT:_CONS_speed_Change
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cons_height DD	FLAT:??_C@_0L@LKCBDKAM@con_height@
	DD	FLAT:??_C@_02PNFIDHGF@50@
	DD	01H
	DD	FLAT:_CV_Unsigned
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cons_backpic DD FLAT:??_C@_0M@MHGLOMJK@con_backpic@
	DD	FLAT:??_C@_0M@EBPKCBLF@translucent@
	DD	01H
	DD	FLAT:_backpic_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0203H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0177H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0815H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	014H
	DB	0cfH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_DrawConsole
_TEXT	SEGMENT
tv130 = -96						; size = 4
tv146 = -96						; size = 4
_charflags$ = -28					; size = 4
_x2$ = -24						; size = 4
_w$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_CON_DrawConsole PROC					; COMDAT

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1216 : 	UINT8 *p;
; 1217 : 	size_t i, x;
; 1218 : 	INT32 y;
; 1219 : 	INT32 w = 0, x2 = 0;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00010	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x2$[ebp], 0

; 1220 : 	INT32 charflags = 0;

  00017	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _charflags$[ebp], 0

; 1221 : 
; 1222 : 	if (con_curlines <= 0)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_curlines, 0
  00025	7f 05		 jg	 SHORT $LN10@CON_DrawCo

; 1223 : 		return;

  00027	e9 28 02 00 00	 jmp	 $LN21@CON_DrawCo
$LN10@CON_DrawCo:

; 1224 : 
; 1225 : 	//FIXME: refresh borders only when console bg is translucent
; 1226 : 	con_clearlines = con_curlines; // clear console draw from view borders

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00031	a3 00 00 00 00	 mov	 DWORD PTR _con_clearlines, eax

; 1227 : 	con_hudupdate = true; // always refresh while console is on

  00036	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _con_hudupdate, 1

; 1228 : 
; 1229 : 	// draw console background
; 1230 : 	if (cons_backpic.value || con_forcepic)

  00040	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cons_backpic+20, 0
  00047	75 09		 jne	 SHORT $LN13@CON_DrawCo
  00049	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_forcepic, 0
  00050	74 41		 je	 SHORT $LN11@CON_DrawCo
$LN13@CON_DrawCo:

; 1231 : 	{
; 1232 : 		if (rendermode != render_soft)

  00052	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00059	74 16		 je	 SHORT $LN14@CON_DrawCo

; 1233 : 			V_DrawScaledPatch(0, 0, 0, con_backpic);

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_backpic
  00060	50		 push	 eax
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	6a 00		 push	 0
  00067	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	eb 20		 jmp	 SHORT $LN16@CON_DrawCo
$LN14@CON_DrawCo:

; 1234 : 		else if (rendermode != render_none)

  00071	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00078	74 17		 je	 SHORT $LN16@CON_DrawCo

; 1235 : 			CON_DrawBackpic(con_backpic, 0, vid.width); // picture as background

  0007a	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0007f	50		 push	 eax
  00080	6a 00		 push	 0
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_backpic
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _CON_DrawBackpic
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CON_DrawCo:

; 1236 : 	}

  00091	eb 30		 jmp	 SHORT $LN17@CON_DrawCo
$LN11@CON_DrawCo:

; 1237 : 	else
; 1238 : 	{
; 1239 : 		x2 = vid.width;

  00093	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00098	89 45 e8	 mov	 DWORD PTR _x2$[ebp], eax

; 1240 : 		// Hurdler: what's the correct value of w and x2 in hardware mode???
; 1241 : 		if (rendermode != render_none) V_DrawFadeConsBack(w, 0, x2, con_curlines, cons_backcolor.value); // translucent background

  0009b	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  000a2	74 1f		 je	 SHORT $LN17@CON_DrawCo
  000a4	a1 14 00 00 00	 mov	 eax, DWORD PTR _cons_backcolor+20
  000a9	50		 push	 eax
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_curlines
  000b0	51		 push	 ecx
  000b1	8b 55 e8	 mov	 edx, DWORD PTR _x2$[ebp]
  000b4	52		 push	 edx
  000b5	6a 00		 push	 0
  000b7	8b 45 ec	 mov	 eax, DWORD PTR _w$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _V_DrawFadeConsBack
  000c0	83 c4 14	 add	 esp, 20			; 00000014H
$LN17@CON_DrawCo:

; 1242 : 	}
; 1243 : 
; 1244 : 	// draw console text lines from top to bottom
; 1245 : 	if (con_curlines < 20) // 8+8+4

  000c3	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR _con_curlines, 20 ; 00000014H
  000ca	7d 05		 jge	 SHORT $LN18@CON_DrawCo

; 1246 : 		return;

  000cc	e9 83 01 00 00	 jmp	 $LN21@CON_DrawCo
$LN18@CON_DrawCo:

; 1247 : 
; 1248 : 	i = con_cy - con_scrollup;

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  000d6	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _con_scrollup
  000dc	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 1249 : 
; 1250 : 	// skip the last empty line due to the cursor being at the start of a new line
; 1251 : 	if (!con_scrollup && !con_cx)

  000df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_scrollup, 0
  000e6	75 12		 jne	 SHORT $LN19@CON_DrawCo
  000e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_cx, 0
  000ef	75 09		 jne	 SHORT $LN19@CON_DrawCo

; 1252 : 		i--;

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	83 e8 01	 sub	 eax, 1
  000f7	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN19@CON_DrawCo:

; 1253 : 
; 1254 : 	i -= (con_curlines - 20) / 8;

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  000ff	83 e8 14	 sub	 eax, 20			; 00000014H
  00102	99		 cdq
  00103	83 e2 07	 and	 edx, 7
  00106	03 c2		 add	 eax, edx
  00108	c1 f8 03	 sar	 eax, 3
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0010e	2b c8		 sub	 ecx, eax
  00110	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx

; 1255 : 
; 1256 : 	if (rendermode == render_none) return;

  00113	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0011a	75 05		 jne	 SHORT $LN20@CON_DrawCo
  0011c	e9 33 01 00 00	 jmp	 $LN21@CON_DrawCo
$LN20@CON_DrawCo:

; 1257 : 
; 1258 : 	for (y = (con_curlines-20) % 8; y <= con_curlines-20; y += 8, i++)

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00126	83 e8 14	 sub	 eax, 20			; 00000014H
  00129	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0012e	79 05		 jns	 SHORT $LN27@CON_DrawCo
  00130	48		 dec	 eax
  00131	83 c8 f8	 or	 eax, -8			; fffffff8H
  00134	40		 inc	 eax
$LN27@CON_DrawCo:
  00135	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
  00138	eb 12		 jmp	 SHORT $LN4@CON_DrawCo
$LN2@CON_DrawCo:
  0013a	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0013d	83 c0 08	 add	 eax, 8
  00140	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
  00143	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00146	83 c1 01	 add	 ecx, 1
  00149	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@CON_DrawCo:
  0014c	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00151	83 e8 14	 sub	 eax, 20			; 00000014H
  00154	39 45 f0	 cmp	 DWORD PTR _y$[ebp], eax
  00157	0f 8f d2 00 00
	00		 jg	 $LN3@CON_DrawCo

; 1259 : 	{
; 1260 : 		p = (UINT8 *)&con_buffer[((i > 0 ? i : 0)%con_totallines)*con_width];

  0015d	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00161	76 08		 jbe	 SHORT $LN23@CON_DrawCo
  00163	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00166	89 45 a0	 mov	 DWORD PTR tv130[ebp], eax
  00169	eb 07		 jmp	 SHORT $LN24@CON_DrawCo
$LN23@CON_DrawCo:
  0016b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$LN24@CON_DrawCo:
  00172	8b 45 a0	 mov	 eax, DWORD PTR tv130[ebp]
  00175	33 d2		 xor	 edx, edx
  00177	f7 35 00 00 00
	00		 div	 DWORD PTR _con_totallines
  0017d	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _con_width
  00184	81 c2 00 00 00
	00		 add	 edx, OFFSET _con_buffer
  0018a	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 1261 : 
; 1262 : 		for (x = 0; x < con_width; x++, p++)

  0018d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00194	eb 12		 jmp	 SHORT $LN7@CON_DrawCo
$LN5@CON_DrawCo:
  00196	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00199	83 c0 01	 add	 eax, 1
  0019c	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  001a2	83 c1 01	 add	 ecx, 1
  001a5	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx
$LN7@CON_DrawCo:
  001a8	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  001ab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_width
  001b1	73 77		 jae	 SHORT $LN6@CON_DrawCo
$LN8@CON_DrawCo:

; 1263 : 		{
; 1264 : 			while (*p & 0x80)

  001b3	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001b6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001b9	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  001bf	74 1a		 je	 SHORT $LN9@CON_DrawCo

; 1265 : 			{
; 1266 : 				charflags = (*p & 0x7f) << 8;

  001c1	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001c7	83 e1 7f	 and	 ecx, 127		; 0000007fH
  001ca	c1 e1 08	 shl	 ecx, 8
  001cd	89 4d e4	 mov	 DWORD PTR _charflags$[ebp], ecx

; 1267 : 				p++;

  001d0	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001d3	83 c0 01	 add	 eax, 1
  001d6	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 1268 : 			}

  001d9	eb d8		 jmp	 SHORT $LN8@CON_DrawCo
$LN9@CON_DrawCo:

; 1269 : 			V_DrawCharacter((INT32)(x+1)<<3, y, (INT32)(*p)|charflags|V_NOSCALEPATCH|V_NOSCALESTART, !cv_allcaps.value);

  001db	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_allcaps+20, 0
  001e2	75 09		 jne	 SHORT $LN25@CON_DrawCo
  001e4	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
  001eb	eb 07		 jmp	 SHORT $LN26@CON_DrawCo
$LN25@CON_DrawCo:
  001ed	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
$LN26@CON_DrawCo:
  001f4	8b 45 a0	 mov	 eax, DWORD PTR tv146[ebp]
  001f7	50		 push	 eax
  001f8	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  001fb	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001fe	0b 55 e4	 or	 edx, DWORD PTR _charflags$[ebp]
  00201	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00207	81 ca 00 00 01
	00		 or	 edx, 65536		; 00010000H
  0020d	52		 push	 edx
  0020e	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00211	50		 push	 eax
  00212	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00215	8d 14 cd 08 00
	00 00		 lea	 edx, DWORD PTR [ecx*8+8]
  0021c	52		 push	 edx
  0021d	e8 00 00 00 00	 call	 _V_DrawCharacter
  00222	83 c4 10	 add	 esp, 16			; 00000010H

; 1270 : 		}

  00225	e9 6c ff ff ff	 jmp	 $LN5@CON_DrawCo
$LN6@CON_DrawCo:

; 1271 : 	}

  0022a	e9 0b ff ff ff	 jmp	 $LN2@CON_DrawCo
$LN3@CON_DrawCo:

; 1272 : 
; 1273 : 	// draw prompt if enough place (not while game startup)
; 1274 : 	if ((con_curlines == con_destlines) && (con_curlines >= 20) && !con_startup)

  0022f	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00234	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_destlines
  0023a	75 18		 jne	 SHORT $LN21@CON_DrawCo
  0023c	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR _con_curlines, 20 ; 00000014H
  00243	7c 0f		 jl	 SHORT $LN21@CON_DrawCo
  00245	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_startup, 0
  0024c	75 06		 jne	 SHORT $LN21@CON_DrawCo

; 1275 : 		CON_DrawInput();

  0024e	e8 00 00 00 00	 call	 _CON_DrawInput
  00253	90		 npad	 1
$LN21@CON_DrawCo:

; 1276 : }

  00254	5f		 pop	 edi
  00255	5e		 pop	 esi
  00256	5b		 pop	 ebx
  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c3		 ret	 0
_CON_DrawConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_DrawHudlines
_TEXT	SEGMENT
tv90 = -88						; size = 4
tv133 = -88						; size = 4
_charflags$ = -20					; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_CON_DrawHudlines PROC					; COMDAT

; 1114 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1115 : 	UINT8 *p;
; 1116 : 	size_t i, x;
; 1117 : 	INT32 y;
; 1118 : 	INT32 charflags = 0;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _charflags$[ebp], 0

; 1119 : 
; 1120 : 	if (con_hudlines <= 0)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_hudlines, 0
  00017	7f 05		 jg	 SHORT $LN10@CON_DrawHu

; 1121 : 		return;

  00019	e9 79 01 00 00	 jmp	 $LN1@CON_DrawHu
$LN10@CON_DrawHu:

; 1122 : 
; 1123 : 	if (chat_on)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _chat_on, 0
  00025	74 09		 je	 SHORT $LN11@CON_DrawHu

; 1124 : 		y = 8; // leave place for chat input in the first row of text

  00027	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _y$[ebp], 8
  0002e	eb 07		 jmp	 SHORT $LN12@CON_DrawHu
$LN11@CON_DrawHu:

; 1125 : 	else
; 1126 : 		y = 0;

  00030	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
$LN12@CON_DrawHu:

; 1127 : 
; 1128 : 	for (i = con_cy - con_hudlines+1; i <= con_cy; i++)

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  0003c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _con_hudlines
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00048	eb 09		 jmp	 SHORT $LN4@CON_DrawHu
$LN2@CON_DrawHu:
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004d	83 c0 01	 add	 eax, 1
  00050	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CON_DrawHu:
  00053	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00056	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_cy
  0005c	0f 87 2d 01 00
	00		 ja	 $LN3@CON_DrawHu

; 1129 : 	{
; 1130 : 		if ((signed)i < 0)

  00062	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00066	7d 02		 jge	 SHORT $LN13@CON_DrawHu

; 1131 : 			continue;

  00068	eb e0		 jmp	 SHORT $LN2@CON_DrawHu
$LN13@CON_DrawHu:

; 1132 : 		if (con_hudtime[i%con_hudlines] == 0)

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006d	33 d2		 xor	 edx, edx
  0006f	f7 35 00 00 00
	00		 div	 DWORD PTR _con_hudlines
  00075	83 3c 95 00 00
	00 00 00	 cmp	 DWORD PTR _con_hudtime[edx*4], 0
  0007d	75 02		 jne	 SHORT $LN14@CON_DrawHu

; 1133 : 			continue;

  0007f	eb c9		 jmp	 SHORT $LN2@CON_DrawHu
$LN14@CON_DrawHu:

; 1134 : 
; 1135 : 		p = (UINT8 *)&con_buffer[(i%con_totallines)*con_width];

  00081	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00084	33 d2		 xor	 edx, edx
  00086	f7 35 00 00 00
	00		 div	 DWORD PTR _con_totallines
  0008c	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _con_width
  00093	81 c2 00 00 00
	00		 add	 edx, OFFSET _con_buffer
  00099	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 1136 : 
; 1137 : 		for (x = 0; x < con_width; x++, p++)

  0009c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  000a3	eb 12		 jmp	 SHORT $LN7@CON_DrawHu
$LN5@CON_DrawHu:
  000a5	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000b1	83 c1 01	 add	 ecx, 1
  000b4	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx
$LN7@CON_DrawHu:
  000b7	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  000ba	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_width
  000c0	73 73		 jae	 SHORT $LN6@CON_DrawHu
$LN8@CON_DrawHu:

; 1138 : 		{
; 1139 : 			while (*p & 0x80) // Graue 06-19-2004

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000c5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c8	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  000ce	74 1a		 je	 SHORT $LN9@CON_DrawHu

; 1140 : 			{
; 1141 : 				charflags = (*p & 0x7f) << 8;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000d3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d6	83 e1 7f	 and	 ecx, 127		; 0000007fH
  000d9	c1 e1 08	 shl	 ecx, 8
  000dc	89 4d ec	 mov	 DWORD PTR _charflags$[ebp], ecx

; 1142 : 				p++;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 1143 : 			}

  000e8	eb d8		 jmp	 SHORT $LN8@CON_DrawHu
$LN9@CON_DrawHu:

; 1144 : 			V_DrawCharacter((INT32)(x)<<3, y, (INT32)(*p) | charflags | V_NOSCALEPATCH|V_NOSCALESTART, !cv_allcaps.value);

  000ea	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_allcaps+20, 0
  000f1	75 09		 jne	 SHORT $LN16@CON_DrawHu
  000f3	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv90[ebp], 1
  000fa	eb 07		 jmp	 SHORT $LN17@CON_DrawHu
$LN16@CON_DrawHu:
  000fc	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$LN17@CON_DrawHu:
  00103	8b 45 a8	 mov	 eax, DWORD PTR tv90[ebp]
  00106	50		 push	 eax
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0010a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0010d	0b 55 ec	 or	 edx, DWORD PTR _charflags$[ebp]
  00110	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00116	81 ca 00 00 01
	00		 or	 edx, 65536		; 00010000H
  0011c	52		 push	 edx
  0011d	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00120	50		 push	 eax
  00121	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00124	c1 e1 03	 shl	 ecx, 3
  00127	51		 push	 ecx
  00128	e8 00 00 00 00	 call	 _V_DrawCharacter
  0012d	83 c4 10	 add	 esp, 16			; 00000010H

; 1145 : 		}

  00130	e9 70 ff ff ff	 jmp	 $LN5@CON_DrawHu
$LN6@CON_DrawHu:

; 1146 : 
; 1147 : 		V_DrawCharacter((INT32)(x)<<3, y, (p[x]&0xff)|V_NOSCALEPATCH|V_NOSCALESTART, !cv_allcaps.value);

  00135	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_allcaps+20, 0
  0013c	75 09		 jne	 SHORT $LN18@CON_DrawHu
  0013e	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
  00145	eb 07		 jmp	 SHORT $LN19@CON_DrawHu
$LN18@CON_DrawHu:
  00147	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN19@CON_DrawHu:
  0014e	8b 45 a8	 mov	 eax, DWORD PTR tv133[ebp]
  00151	50		 push	 eax
  00152	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00155	03 4d f4	 add	 ecx, DWORD PTR _x$[ebp]
  00158	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0015b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00161	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00167	81 ca 00 00 01
	00		 or	 edx, 65536		; 00010000H
  0016d	52		 push	 edx
  0016e	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00171	50		 push	 eax
  00172	8b 4d f4	 mov	 ecx, DWORD PTR _x$[ebp]
  00175	c1 e1 03	 shl	 ecx, 3
  00178	51		 push	 ecx
  00179	e8 00 00 00 00	 call	 _V_DrawCharacter
  0017e	83 c4 10	 add	 esp, 16			; 00000010H

; 1148 : 		y += 8;

  00181	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00184	83 c0 08	 add	 eax, 8
  00187	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax

; 1149 : 	}

  0018a	e9 bb fe ff ff	 jmp	 $LN2@CON_DrawHu
$LN3@CON_DrawHu:

; 1150 : 
; 1151 : 	// top screen lines that might need clearing when view is reduced
; 1152 : 	con_clearlines = y; // this is handled by HU_Erase();

  0018f	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00192	a3 00 00 00 00	 mov	 DWORD PTR _con_clearlines, eax
$LN1@CON_DrawHu:

; 1153 : }

  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5b		 pop	 ebx
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
_CON_DrawHudlines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_DrawInput
_TEXT	SEGMENT
tv77 = -80						; size = 4
tv93 = -80						; size = 4
tv128 = -80						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_p$ = -4						; size = 4
_CON_DrawInput PROC					; COMDAT

; 1090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1091 : 	char *p;
; 1092 : 	size_t x;
; 1093 : 	INT32 y;
; 1094 : 
; 1095 : 	// input line scrolls left if it gets too long
; 1096 : 	p = inputlines[inputline];

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  0000e	c1 e0 08	 shl	 eax, 8
  00011	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  00016	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 1097 : 	if (input_cx >= con_width-11)

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  0001e	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00021	39 05 00 00 00
	00		 cmp	 DWORD PTR _input_cx, eax
  00027	72 1a		 jb	 SHORT $LN5@CON_DrawIn

; 1098 : 		p += input_cx - (con_width-11) + 1;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  0002e	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  00037	2b c8		 sub	 ecx, eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0003c	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00040	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
$LN5@CON_DrawIn:

; 1099 : 
; 1100 : 	y = con_curlines - 12;

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00048	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0004b	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax

; 1101 : 
; 1102 : 	for (x = 0; x < con_width-11; x++)

  0004e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00055	eb 09		 jmp	 SHORT $LN4@CON_DrawIn
$LN2@CON_DrawIn:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
$LN4@CON_DrawIn:
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  00065	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00068	39 45 f8	 cmp	 DWORD PTR _x$[ebp], eax
  0006b	73 4c		 jae	 SHORT $LN3@CON_DrawIn

; 1103 : 		V_DrawCharacter((INT32)(x+1)<<3, y, p[x]|V_NOSCALEPATCH|V_NOSCALESTART, !cv_allcaps.value);

  0006d	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_allcaps+20, 0
  00074	75 09		 jne	 SHORT $LN8@CON_DrawIn
  00076	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  0007d	eb 07		 jmp	 SHORT $LN9@CON_DrawIn
$LN8@CON_DrawIn:
  0007f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN9@CON_DrawIn:
  00086	8b 45 b0	 mov	 eax, DWORD PTR tv77[ebp]
  00089	50		 push	 eax
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0008d	03 4d f8	 add	 ecx, DWORD PTR _x$[ebp]
  00090	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00093	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00099	81 ca 00 00 01
	00		 or	 edx, 65536		; 00010000H
  0009f	52		 push	 edx
  000a0	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  000a7	8d 14 cd 08 00
	00 00		 lea	 edx, DWORD PTR [ecx*8+8]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 _V_DrawCharacter
  000b4	83 c4 10	 add	 esp, 16			; 00000010H
  000b7	eb 9e		 jmp	 SHORT $LN2@CON_DrawIn
$LN3@CON_DrawIn:

; 1104 : 
; 1105 : 	// draw the blinking cursor
; 1106 : 	//
; 1107 : 	x = (input_cx >= con_width-11) ? (con_width-11) - 1 : input_cx;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  000be	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000c1	39 05 00 00 00
	00		 cmp	 DWORD PTR _input_cx, eax
  000c7	72 0e		 jb	 SHORT $LN10@CON_DrawIn
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_width
  000cf	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  000d2	89 4d b0	 mov	 DWORD PTR tv93[ebp], ecx
  000d5	eb 09		 jmp	 SHORT $LN11@CON_DrawIn
$LN10@CON_DrawIn:
  000d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _input_cx
  000dd	89 55 b0	 mov	 DWORD PTR tv93[ebp], edx
$LN11@CON_DrawIn:
  000e0	8b 45 b0	 mov	 eax, DWORD PTR tv93[ebp]
  000e3	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax

; 1108 : 	if (con_tick < 4)

  000e6	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _con_tick, 4
  000ed	73 39		 jae	 SHORT $LN6@CON_DrawIn

; 1109 : 		V_DrawCharacter((INT32)(x+1)<<3, y, '_'|V_NOSCALEPATCH|V_NOSCALESTART, !cv_allcaps.value);

  000ef	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_allcaps+20, 0
  000f6	75 09		 jne	 SHORT $LN12@CON_DrawIn
  000f8	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  000ff	eb 07		 jmp	 SHORT $LN13@CON_DrawIn
$LN12@CON_DrawIn:
  00101	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
$LN13@CON_DrawIn:
  00108	8b 45 b0	 mov	 eax, DWORD PTR tv128[ebp]
  0010b	50		 push	 eax
  0010c	68 5f 00 09 00	 push	 589919			; 0009005fH
  00111	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  00114	51		 push	 ecx
  00115	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00118	8d 04 d5 08 00
	00 00		 lea	 eax, DWORD PTR [edx*8+8]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _V_DrawCharacter
  00125	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@CON_DrawIn:

; 1110 : }

  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
_CON_DrawInput ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_Linefeed
_TEXT	SEGMENT
_CON_Linefeed PROC					; COMDAT

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 875  : 	// set time for heads up messages
; 876  : 	con_hudtime[con_cy%con_hudlines] = cons_msgtimeout.value*TICRATE;

  00009	6b 0d 14 00 00
	00 23		 imul	 ecx, DWORD PTR _cons_msgtimeout+20, 35
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  00015	33 d2		 xor	 edx, edx
  00017	f7 35 00 00 00
	00		 div	 DWORD PTR _con_hudlines
  0001d	89 0c 95 00 00
	00 00		 mov	 DWORD PTR _con_hudtime[edx*4], ecx

; 877  : 
; 878  : 	con_cy++;

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  00029	83 c0 01	 add	 eax, 1
  0002c	a3 00 00 00 00	 mov	 DWORD PTR _con_cy, eax

; 879  : 	con_cx = 0;

  00031	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_cx, 0

; 880  : 
; 881  : 	con_line = &con_buffer[(con_cy%con_totallines)*con_width];

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  00040	33 d2		 xor	 edx, edx
  00042	f7 35 00 00 00
	00		 div	 DWORD PTR _con_totallines
  00048	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _con_width
  0004f	81 c2 00 00 00
	00		 add	 edx, OFFSET _con_buffer
  00055	89 15 00 00 00
	00		 mov	 DWORD PTR _con_line, edx

; 882  : 	memset(con_line, ' ', con_width);

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  00060	50		 push	 eax
  00061	6a 20		 push	 32			; 00000020H
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_line
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _memset
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 883  : 
; 884  : 	// make sure the view borders are refreshed if hud messages scroll
; 885  : 	con_hudupdate = true; // see HU_Erase()

  00072	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _con_hudupdate, 1

; 886  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_CON_Linefeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_MoveConsole
_TEXT	SEGMENT
_CON_MoveConsole PROC					; COMDAT

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 484  : 	// up/down move to dest
; 485  : 	if (con_curlines < con_destlines)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  0000e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_destlines
  00014	7d 38		 jge	 SHORT $LN2@CON_MoveCo

; 486  : 	{
; 487  : 		con_curlines += (INT32)(cons_speed.value*vid.fdupy)/NEWTICRATERATIO;

  00016	f3 0f 2a 05 14
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _cons_speed+20
  0001e	f3 0f 59 05 2c
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+44
  00026	f3 0f 2c c0	 cvttss2si eax, xmm0
  0002a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _con_curlines
  00030	a3 00 00 00 00	 mov	 DWORD PTR _con_curlines, eax

; 488  : 		if (con_curlines > con_destlines)

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  0003a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_destlines
  00040	7e 0a		 jle	 SHORT $LN4@CON_MoveCo

; 489  : 			con_curlines = con_destlines;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_destlines
  00047	a3 00 00 00 00	 mov	 DWORD PTR _con_curlines, eax
$LN4@CON_MoveCo:

; 490  : 	}

  0004c	eb 46		 jmp	 SHORT $LN6@CON_MoveCo
$LN2@CON_MoveCo:

; 491  : 	else if (con_curlines > con_destlines)

  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00053	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_destlines
  00059	7e 39		 jle	 SHORT $LN6@CON_MoveCo

; 492  : 	{
; 493  : 		con_curlines -= (INT32)(cons_speed.value*vid.fdupy)/NEWTICRATERATIO;

  0005b	f3 0f 2a 05 14
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _cons_speed+20
  00063	f3 0f 59 05 2c
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+44
  0006b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_curlines
  00075	2b c8		 sub	 ecx, eax
  00077	89 0d 00 00 00
	00		 mov	 DWORD PTR _con_curlines, ecx

; 494  : 		if (con_curlines < con_destlines)

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  00082	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_destlines
  00088	7d 0a		 jge	 SHORT $LN6@CON_MoveCo

; 495  : 			con_curlines = con_destlines;

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_destlines
  0008f	a3 00 00 00 00	 mov	 DWORD PTR _con_curlines, eax
$LN6@CON_MoveCo:

; 496  : 	}
; 497  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_CON_MoveConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_SetupBackColormap
_TEXT	SEGMENT
_pal$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_CON_SetupBackColormap PROC				; COMDAT

; 277  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 278  : 	INT32 i, j, k;
; 279  : 	UINT8 *pal;
; 280  : 
; 281  : 	cwhitemap   = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 01		 push	 1
  0000f	68 00 01 00 00	 push	 256			; 00000100H
  00014	e8 00 00 00 00	 call	 _Z_MallocAlign
  00019	83 c4 10	 add	 esp, 16			; 00000010H
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _cwhitemap, eax

; 282  : 	corangemap  = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	6a 01		 push	 1
  00027	68 00 01 00 00	 push	 256			; 00000100H
  0002c	e8 00 00 00 00	 call	 _Z_MallocAlign
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	a3 00 00 00 00	 mov	 DWORD PTR _corangemap, eax

; 283  : 	cbluemap    = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 01		 push	 1
  0003f	68 00 01 00 00	 push	 256			; 00000100H
  00044	e8 00 00 00 00	 call	 _Z_MallocAlign
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	a3 00 00 00 00	 mov	 DWORD PTR _cbluemap, eax

; 284  : 	cgreenmap   = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	6a 01		 push	 1
  00057	68 00 01 00 00	 push	 256			; 00000100H
  0005c	e8 00 00 00 00	 call	 _Z_MallocAlign
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	a3 00 00 00 00	 mov	 DWORD PTR _cgreenmap, eax

; 285  : 	cgraymap    = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	6a 01		 push	 1
  0006f	68 00 01 00 00	 push	 256			; 00000100H
  00074	e8 00 00 00 00	 call	 _Z_MallocAlign
  00079	83 c4 10	 add	 esp, 16			; 00000010H
  0007c	a3 00 00 00 00	 mov	 DWORD PTR _cgraymap, eax

; 286  : 	credmap     = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00081	6a 00		 push	 0
  00083	6a 00		 push	 0
  00085	6a 01		 push	 1
  00087	68 00 01 00 00	 push	 256			; 00000100H
  0008c	e8 00 00 00 00	 call	 _Z_MallocAlign
  00091	83 c4 10	 add	 esp, 16			; 00000010H
  00094	a3 00 00 00 00	 mov	 DWORD PTR _credmap, eax

; 287  : 
; 288  : 	yellowmap = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	6a 01		 push	 1
  0009f	68 00 01 00 00	 push	 256			; 00000100H
  000a4	e8 00 00 00 00	 call	 _Z_MallocAlign
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
  000ac	a3 00 00 00 00	 mov	 DWORD PTR _yellowmap, eax

; 289  : 	graymap   = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  000b1	6a 00		 push	 0
  000b3	6a 00		 push	 0
  000b5	6a 01		 push	 1
  000b7	68 00 01 00 00	 push	 256			; 00000100H
  000bc	e8 00 00 00 00	 call	 _Z_MallocAlign
  000c1	83 c4 10	 add	 esp, 16			; 00000010H
  000c4	a3 00 00 00 00	 mov	 DWORD PTR _graymap, eax

; 290  : 	purplemap = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	6a 01		 push	 1
  000cf	68 00 01 00 00	 push	 256			; 00000100H
  000d4	e8 00 00 00 00	 call	 _Z_MallocAlign
  000d9	83 c4 10	 add	 esp, 16			; 00000010H
  000dc	a3 00 00 00 00	 mov	 DWORD PTR _purplemap, eax

; 291  : 	lgreenmap = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  000e1	6a 00		 push	 0
  000e3	6a 00		 push	 0
  000e5	6a 01		 push	 1
  000e7	68 00 01 00 00	 push	 256			; 00000100H
  000ec	e8 00 00 00 00	 call	 _Z_MallocAlign
  000f1	83 c4 10	 add	 esp, 16			; 00000010H
  000f4	a3 00 00 00 00	 mov	 DWORD PTR _lgreenmap, eax

; 292  : 	bluemap   = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  000f9	6a 00		 push	 0
  000fb	6a 00		 push	 0
  000fd	6a 01		 push	 1
  000ff	68 00 01 00 00	 push	 256			; 00000100H
  00104	e8 00 00 00 00	 call	 _Z_MallocAlign
  00109	83 c4 10	 add	 esp, 16			; 00000010H
  0010c	a3 00 00 00 00	 mov	 DWORD PTR _bluemap, eax

; 293  : 	redmap    = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00111	6a 00		 push	 0
  00113	6a 00		 push	 0
  00115	6a 01		 push	 1
  00117	68 00 01 00 00	 push	 256			; 00000100H
  0011c	e8 00 00 00 00	 call	 _Z_MallocAlign
  00121	83 c4 10	 add	 esp, 16			; 00000010H
  00124	a3 00 00 00 00	 mov	 DWORD PTR _redmap, eax

; 294  : 	orangemap = (UINT8 *)Z_Malloc(256, PU_STATIC, NULL);

  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	6a 01		 push	 1
  0012f	68 00 01 00 00	 push	 256			; 00000100H
  00134	e8 00 00 00 00	 call	 _Z_MallocAlign
  00139	83 c4 10	 add	 esp, 16			; 00000010H
  0013c	a3 00 00 00 00	 mov	 DWORD PTR _orangemap, eax

; 295  : 
; 296  : 	pal = W_CacheLumpName("PLAYPAL", PU_CACHE);

  00141	6a 65		 push	 101			; 00000065H
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_07FLMOFAHC@PLAYPAL@
  00148	e8 00 00 00 00	 call	 _W_CacheLumpName
  0014d	83 c4 08	 add	 esp, 8
  00150	89 45 f0	 mov	 DWORD PTR _pal$[ebp], eax

; 297  : 
; 298  : 	// setup the green translucent background colormaps
; 299  : 	for (i = 0, k = 0; i < 768; i += 3, k++)

  00153	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0015a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00161	eb 12		 jmp	 SHORT $LN4@CON_SetupB
$LN2@CON_SetupB:
  00163	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00166	83 c0 03	 add	 eax, 3
  00169	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0016c	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  0016f	83 c1 01	 add	 ecx, 1
  00172	89 4d f4	 mov	 DWORD PTR _k$[ebp], ecx
$LN4@CON_SetupB:
  00175	81 7d fc 00 03
	00 00		 cmp	 DWORD PTR _i$[ebp], 768	; 00000300H
  0017c	0f 8d b9 00 00
	00		 jge	 $LN3@CON_SetupB

; 300  : 	{
; 301  : 		j = pal[i] + pal[i+1] + pal[i+2];

  00182	8b 45 f0	 mov	 eax, DWORD PTR _pal$[ebp]
  00185	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00188	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0018b	8b 55 f0	 mov	 edx, DWORD PTR _pal$[ebp]
  0018e	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00191	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00195	03 c8		 add	 ecx, eax
  00197	8b 55 f0	 mov	 edx, DWORD PTR _pal$[ebp]
  0019a	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0019d	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  001a1	03 c8		 add	 ecx, eax
  001a3	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx

; 302  : 		cwhitemap[k] = (UINT8)(15 - (j>>6));

  001a6	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  001a9	c1 f8 06	 sar	 eax, 6
  001ac	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  001b1	2b c8		 sub	 ecx, eax
  001b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cwhitemap
  001b9	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  001bc	88 0a		 mov	 BYTE PTR [edx], cl

; 303  : 		corangemap[k] = (UINT8)(95 - (j>>6));

  001be	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  001c1	c1 f8 06	 sar	 eax, 6
  001c4	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  001c9	2b c8		 sub	 ecx, eax
  001cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _corangemap
  001d1	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  001d4	88 0a		 mov	 BYTE PTR [edx], cl

; 304  : 		cbluemap[k] = (UINT8)(239 - (j>>6));

  001d6	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  001d9	c1 f8 06	 sar	 eax, 6
  001dc	b9 ef 00 00 00	 mov	 ecx, 239		; 000000efH
  001e1	2b c8		 sub	 ecx, eax
  001e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cbluemap
  001e9	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  001ec	88 0a		 mov	 BYTE PTR [edx], cl

; 305  : 		cgreenmap[k] = (UINT8)(175 - (j>>6));

  001ee	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  001f1	c1 f8 06	 sar	 eax, 6
  001f4	b9 af 00 00 00	 mov	 ecx, 175		; 000000afH
  001f9	2b c8		 sub	 ecx, eax
  001fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cgreenmap
  00201	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  00204	88 0a		 mov	 BYTE PTR [edx], cl

; 306  : 		cgraymap[k] = (UINT8)(31 - (j>>6));

  00206	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00209	c1 f8 06	 sar	 eax, 6
  0020c	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00211	2b c8		 sub	 ecx, eax
  00213	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _cgraymap
  00219	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  0021c	88 0a		 mov	 BYTE PTR [edx], cl

; 307  : 		credmap[k] = (UINT8)(143 - (j>>6));

  0021e	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00221	c1 f8 06	 sar	 eax, 6
  00224	b9 8f 00 00 00	 mov	 ecx, 143		; 0000008fH
  00229	2b c8		 sub	 ecx, eax
  0022b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _credmap
  00231	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  00234	88 0a		 mov	 BYTE PTR [edx], cl

; 308  : 	}

  00236	e9 28 ff ff ff	 jmp	 $LN2@CON_SetupB
$LN3@CON_SetupB:

; 309  : 
; 310  : 	// setup the other colormaps, for console text
; 311  : 
; 312  : 	// these don't need to be aligned, unless you convert the
; 313  : 	// V_DrawMappedPatch() into optimised asm.
; 314  : 
; 315  : 	for (i = 0; i < 256; i++)

  0023b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00242	eb 09		 jmp	 SHORT $LN7@CON_SetupB
$LN5@CON_SetupB:
  00244	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00247	83 c0 01	 add	 eax, 1
  0024a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@CON_SetupB:
  0024d	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00254	7d 5d		 jge	 SHORT $LN6@CON_SetupB

; 316  : 	{
; 317  : 		yellowmap[i] = (UINT8)i; // remap each color to itself...

  00256	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  0025b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0025e	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  00261	88 08		 mov	 BYTE PTR [eax], cl

; 318  : 		graymap[i] = (UINT8)i;

  00263	a1 00 00 00 00	 mov	 eax, DWORD PTR _graymap
  00268	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0026b	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  0026e	88 08		 mov	 BYTE PTR [eax], cl

; 319  : 		purplemap[i] = (UINT8)i;

  00270	a1 00 00 00 00	 mov	 eax, DWORD PTR _purplemap
  00275	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00278	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  0027b	88 08		 mov	 BYTE PTR [eax], cl

; 320  : 		lgreenmap[i] = (UINT8)i;

  0027d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  00282	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00285	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  00288	88 08		 mov	 BYTE PTR [eax], cl

; 321  : 		bluemap[i] = (UINT8)i;

  0028a	a1 00 00 00 00	 mov	 eax, DWORD PTR _bluemap
  0028f	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00292	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  00295	88 08		 mov	 BYTE PTR [eax], cl

; 322  : 		redmap[i] = (UINT8)i;

  00297	a1 00 00 00 00	 mov	 eax, DWORD PTR _redmap
  0029c	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0029f	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  002a2	88 08		 mov	 BYTE PTR [eax], cl

; 323  : 		orangemap[i] = (UINT8)i;

  002a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _orangemap
  002a9	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  002ac	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  002af	88 08		 mov	 BYTE PTR [eax], cl

; 324  : 	}

  002b1	eb 91		 jmp	 SHORT $LN5@CON_SetupB
$LN6@CON_SetupB:

; 325  : 
; 326  : 	yellowmap[3] = (UINT8)103;

  002b3	b8 01 00 00 00	 mov	 eax, 1
  002b8	6b c8 03	 imul	 ecx, eax, 3
  002bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _yellowmap
  002c1	c6 04 0a 67	 mov	 BYTE PTR [edx+ecx], 103	; 00000067H

; 327  : 	yellowmap[9] = (UINT8)115;

  002c5	b8 01 00 00 00	 mov	 eax, 1
  002ca	6b c8 09	 imul	 ecx, eax, 9
  002cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _yellowmap
  002d3	c6 04 0a 73	 mov	 BYTE PTR [edx+ecx], 115	; 00000073H

; 328  : 	purplemap[3] = (UINT8)195;

  002d7	b8 01 00 00 00	 mov	 eax, 1
  002dc	6b c8 03	 imul	 ecx, eax, 3
  002df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _purplemap
  002e5	c6 04 0a c3	 mov	 BYTE PTR [edx+ecx], 195	; 000000c3H

; 329  : 	purplemap[9] = (UINT8)198;

  002e9	b8 01 00 00 00	 mov	 eax, 1
  002ee	6b c8 09	 imul	 ecx, eax, 9
  002f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _purplemap
  002f7	c6 04 0a c6	 mov	 BYTE PTR [edx+ecx], 198	; 000000c6H

; 330  : 	lgreenmap[3] = (UINT8)162;

  002fb	b8 01 00 00 00	 mov	 eax, 1
  00300	6b c8 03	 imul	 ecx, eax, 3
  00303	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lgreenmap
  00309	c6 04 0a a2	 mov	 BYTE PTR [edx+ecx], 162	; 000000a2H

; 331  : 	lgreenmap[9] = (UINT8)170;

  0030d	b8 01 00 00 00	 mov	 eax, 1
  00312	6b c8 09	 imul	 ecx, eax, 9
  00315	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lgreenmap
  0031b	c6 04 0a aa	 mov	 BYTE PTR [edx+ecx], 170	; 000000aaH

; 332  : 	bluemap[3]   = (UINT8)228;

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	6b c8 03	 imul	 ecx, eax, 3
  00327	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bluemap
  0032d	c6 04 0a e4	 mov	 BYTE PTR [edx+ecx], 228	; 000000e4H

; 333  : 	bluemap[9]   = (UINT8)238;

  00331	b8 01 00 00 00	 mov	 eax, 1
  00336	6b c8 09	 imul	 ecx, eax, 9
  00339	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bluemap
  0033f	c6 04 0a ee	 mov	 BYTE PTR [edx+ecx], 238	; 000000eeH

; 334  : 	graymap[3]   = (UINT8)10;

  00343	b8 01 00 00 00	 mov	 eax, 1
  00348	6b c8 03	 imul	 ecx, eax, 3
  0034b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _graymap
  00351	c6 04 0a 0a	 mov	 BYTE PTR [edx+ecx], 10	; 0000000aH

; 335  : 	graymap[9]   = (UINT8)15;

  00355	b8 01 00 00 00	 mov	 eax, 1
  0035a	6b c8 09	 imul	 ecx, eax, 9
  0035d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _graymap
  00363	c6 04 0a 0f	 mov	 BYTE PTR [edx+ecx], 15	; 0000000fH

; 336  : 	redmap[3]    = (UINT8)124;

  00367	b8 01 00 00 00	 mov	 eax, 1
  0036c	6b c8 03	 imul	 ecx, eax, 3
  0036f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _redmap
  00375	c6 04 0a 7c	 mov	 BYTE PTR [edx+ecx], 124	; 0000007cH

; 337  : 	redmap[9]    = (UINT8)127;

  00379	b8 01 00 00 00	 mov	 eax, 1
  0037e	6b c8 09	 imul	 ecx, eax, 9
  00381	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _redmap
  00387	c6 04 0a 7f	 mov	 BYTE PTR [edx+ecx], 127	; 0000007fH

; 338  : 	orangemap[3] = (UINT8)85;

  0038b	b8 01 00 00 00	 mov	 eax, 1
  00390	6b c8 03	 imul	 ecx, eax, 3
  00393	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _orangemap
  00399	c6 04 0a 55	 mov	 BYTE PTR [edx+ecx], 85	; 00000055H

; 339  : 	orangemap[9] = (UINT8)90;

  0039d	b8 01 00 00 00	 mov	 eax, 1
  003a2	6b c8 09	 imul	 ecx, eax, 9
  003a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _orangemap
  003ab	c6 04 0a 5a	 mov	 BYTE PTR [edx+ecx], 90	; 0000005aH

; 340  : }

  003af	5f		 pop	 edi
  003b0	5e		 pop	 esi
  003b1	5b		 pop	 ebx
  003b2	8b e5		 mov	 esp, ebp
  003b4	5d		 pop	 ebp
  003b5	c3		 ret	 0
_CON_SetupBackColormap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_Bind_f
_TEXT	SEGMENT
_key$ = -8						; size = 4
_na$ = -4						; size = 4
_CONS_Bind_f PROC					; COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 200  : 	size_t na;
; 201  : 	INT32 key;
; 202  : 
; 203  : 	na = COM_Argc();

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	89 45 fc	 mov	 DWORD PTR _na$[ebp], eax

; 204  : 
; 205  : 	if (na != 2 && na != 3)

  00011	83 7d fc 02	 cmp	 DWORD PTR _na$[ebp], 2
  00015	0f 84 96 00 00
	00		 je	 $LN5@CONS_Bind_
  0001b	83 7d fc 03	 cmp	 DWORD PTR _na$[ebp], 3
  0001f	0f 84 8c 00 00
	00		 je	 $LN5@CONS_Bind_

; 206  : 	{
; 207  : 		CONS_Printf("bind <keyname> [<command>]\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JGANNBIL@bind?5?$DMkeyname?$DO?5?$FL?$DMcommand?$DO?$FN?6@
  0002a	e8 00 00 00 00	 call	 _CONS_Printf
  0002f	83 c4 04	 add	 esp, 4

; 208  : 		CONS_Printf("\2bind table :\n");

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PKKOPABJ@?$ACbind?5table?5?3?6@
  00037	e8 00 00 00 00	 call	 _CONS_Printf
  0003c	83 c4 04	 add	 esp, 4

; 209  : 		na = 0;

  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _na$[ebp], 0

; 210  : 		for (key = 0; key < NUMINPUTS; key++)

  00046	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0
  0004d	eb 09		 jmp	 SHORT $LN4@CONS_Bind_
$LN2@CONS_Bind_:
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	89 45 f8	 mov	 DWORD PTR _key$[ebp], eax
$LN4@CONS_Bind_:
  00058	81 7d f8 e4 01
	00 00		 cmp	 DWORD PTR _key$[ebp], 484 ; 000001e4H
  0005f	7d 3b		 jge	 SHORT $LN3@CONS_Bind_

; 211  : 			if (bindtable[key])

  00061	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  00064	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _bindtable[eax*4], 0
  0006c	74 2c		 je	 SHORT $LN6@CONS_Bind_

; 212  : 			{
; 213  : 				CONS_Printf("%s : \"%s\"\n", G_KeynumToString(key), bindtable[key]);

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  00071	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _bindtable[eax*4]
  00078	51		 push	 ecx
  00079	8b 55 f8	 mov	 edx, DWORD PTR _key$[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _G_KeynumToString
  00082	83 c4 04	 add	 esp, 4
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NMGFNGKI@?$CFs?5?3?5?$CC?$CFs?$CC?6@
  0008b	e8 00 00 00 00	 call	 _CONS_Printf
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 214  : 				na = 1;

  00093	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _na$[ebp], 1
$LN6@CONS_Bind_:

; 215  : 			}

  0009a	eb b3		 jmp	 SHORT $LN2@CONS_Bind_
$LN3@CONS_Bind_:

; 216  : 		if (!na)

  0009c	83 7d fc 00	 cmp	 DWORD PTR _na$[ebp], 0
  000a0	75 0d		 jne	 SHORT $LN7@CONS_Bind_

; 217  : 			CONS_Printf("Empty\n");

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_06HMIKAKIK@Empty?6@
  000a7	e8 00 00 00 00	 call	 _CONS_Printf
  000ac	83 c4 04	 add	 esp, 4
$LN7@CONS_Bind_:

; 218  : 		return;

  000af	eb 6f		 jmp	 SHORT $LN9@CONS_Bind_
$LN5@CONS_Bind_:

; 219  : 	}
; 220  : 
; 221  : 	key = G_KeyStringtoNum(COM_Argv(1));

  000b1	6a 01		 push	 1
  000b3	e8 00 00 00 00	 call	 _COM_Argv
  000b8	83 c4 04	 add	 esp, 4
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _G_KeyStringtoNum
  000c1	83 c4 04	 add	 esp, 4
  000c4	89 45 f8	 mov	 DWORD PTR _key$[ebp], eax

; 222  : 	if (!key)

  000c7	83 7d f8 00	 cmp	 DWORD PTR _key$[ebp], 0
  000cb	75 0f		 jne	 SHORT $LN8@CONS_Bind_

; 223  : 	{
; 224  : 		CONS_Printf("Invalid key name\n");

  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LFFNNDEA@Invalid?5key?5name?6@
  000d2	e8 00 00 00 00	 call	 _CONS_Printf
  000d7	83 c4 04	 add	 esp, 4

; 225  : 		return;

  000da	eb 44		 jmp	 SHORT $LN9@CONS_Bind_
$LN8@CONS_Bind_:

; 226  : 	}
; 227  : 
; 228  : 	Z_Free(bindtable[key]);

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  000df	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _bindtable[eax*4]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 _Z_Free
  000ec	83 c4 04	 add	 esp, 4

; 229  : 	bindtable[key] = NULL;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _key$[ebp]
  000f2	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _bindtable[eax*4], 0

; 230  : 
; 231  : 	if (na == 3)

  000fd	83 7d fc 03	 cmp	 DWORD PTR _na$[ebp], 3
  00101	75 1d		 jne	 SHORT $LN9@CONS_Bind_

; 232  : 		bindtable[key] = Z_StrDup(COM_Argv(2));

  00103	6a 02		 push	 2
  00105	e8 00 00 00 00	 call	 _COM_Argv
  0010a	83 c4 04	 add	 esp, 4
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _Z_StrDup
  00113	83 c4 04	 add	 esp, 4
  00116	8b 4d f8	 mov	 ecx, DWORD PTR _key$[ebp]
  00119	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _bindtable[ecx*4], eax
$LN9@CONS_Bind_:

; 233  : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_CONS_Bind_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_English_f
_TEXT	SEGMENT
_CONS_English_f PROC					; COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 192  : 	shiftxform = english_shiftxform;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _shiftxform, OFFSET _english_shiftxform

; 193  : 	CONS_Printf("English keymap.\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KCCBKCP@English?5keymap?4?6@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 194  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_CONS_English_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_Clear_f
_TEXT	SEGMENT
_CONS_Clear_f PROC					; COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 180  : 	memset(con_buffer, 0, CON_BUFFERSIZE);

  00009	68 00 40 00 00	 push	 16384			; 00004000H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _con_buffer
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  : 
; 182  : 	con_cx = 0;

  0001d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_cx, 0

; 183  : 	con_cy = con_totallines-1;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_totallines
  0002c	83 e8 01	 sub	 eax, 1
  0002f	a3 00 00 00 00	 mov	 DWORD PTR _con_cy, eax

; 184  : 	con_line = &con_buffer[con_cy*con_width];

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  00039	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _con_width
  00040	05 00 00 00 00	 add	 eax, OFFSET _con_buffer
  00045	a3 00 00 00 00	 mov	 DWORD PTR _con_line, eax

; 185  : 	con_scrollup = 0;

  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_scrollup, 0

; 186  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_CONS_Clear_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_Print
_TEXT	SEGMENT
_controlchars$ = -8					; size = 4
_l$ = -4						; size = 4
_msg$ = 8						; size = 4
_CON_Print PROC						; COMDAT

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 891  : 	size_t l;
; 892  : 	INT32 controlchars = 0; // for color changing

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 0

; 893  : 
; 894  : 	if (*msg == '\3') // chat text, makes ding sound

  00010	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00013	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00016	83 f9 03	 cmp	 ecx, 3
  00019	75 0e		 jne	 SHORT $LN15@CON_Print

; 895  : 		S_StartSound(NULL, sfx_radio);

  0001b	6a 7d		 push	 125			; 0000007dH
  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 _S_StartSound
  00024	83 c4 08	 add	 esp, 8
  00027	eb 1d		 jmp	 SHORT $LN17@CON_Print
$LN15@CON_Print:

; 896  : 	else if (*msg == '\4') // chat action, dings and is in yellow

  00029	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0002c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0002f	83 f9 04	 cmp	 ecx, 4
  00032	75 12		 jne	 SHORT $LN17@CON_Print

; 897  : 	{
; 898  : 		*msg = '\x82'; // yellow

  00034	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00037	c6 00 82	 mov	 BYTE PTR [eax], -126	; ffffff82H

; 899  : 		S_StartSound(NULL, sfx_radio);

  0003a	6a 7d		 push	 125			; 0000007dH
  0003c	6a 00		 push	 0
  0003e	e8 00 00 00 00	 call	 _S_StartSound
  00043	83 c4 08	 add	 esp, 8
$LN17@CON_Print:

; 900  : 	}
; 901  : 
; 902  : 	if (!(*msg & 0x80))

  00046	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00049	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004c	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00052	75 24		 jne	 SHORT $LN18@CON_Print

; 903  : 	{
; 904  : 		con_line[con_cx++] = '\x80';

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_line
  00059	03 05 00 00 00
	00		 add	 eax, DWORD PTR _con_cx
  0005f	c6 00 80	 mov	 BYTE PTR [eax], -128	; ffffff80H
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_cx
  00068	83 c1 01	 add	 ecx, 1
  0006b	89 0d 00 00 00
	00		 mov	 DWORD PTR _con_cx, ecx

; 905  : 		controlchars = 1;

  00071	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 1
$LN18@CON_Print:

; 906  : 	}
; 907  : 
; 908  : 	while (*msg)

  00078	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0007b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007e	85 c9		 test	 ecx, ecx
  00080	0f 84 06 02 00
	00		 je	 $LN3@CON_Print
$LN33@CON_Print:

; 909  : 	{
; 910  : 		// skip non-printable characters and white spaces
; 911  : 		while (*msg && *msg <= ' ')

  00086	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00089	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008c	85 c9		 test	 ecx, ecx
  0008e	0f 84 55 01 00
	00		 je	 $LN5@CON_Print
  00094	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00097	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009a	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009d	0f 8f 46 01 00
	00		 jg	 $LN5@CON_Print

; 912  : 		{
; 913  : 			if (*msg & 0x80)

  000a3	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  000a6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a9	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  000af	74 38		 je	 SHORT $LN19@CON_Print

; 914  : 			{
; 915  : 				con_line[con_cx++] = *(msg++);

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_line
  000b6	03 05 00 00 00
	00		 add	 eax, DWORD PTR _con_cx
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  000bf	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c1	88 10		 mov	 BYTE PTR [eax], dl
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cx
  000c8	83 c0 01	 add	 eax, 1
  000cb	a3 00 00 00 00	 mov	 DWORD PTR _con_cx, eax
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  000d3	83 c1 01	 add	 ecx, 1
  000d6	89 4d 08	 mov	 DWORD PTR _msg$[ebp], ecx

; 916  : 				controlchars++;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _controlchars$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 f8	 mov	 DWORD PTR _controlchars$[ebp], eax

; 917  : 				continue;

  000e2	eb a2		 jmp	 SHORT $LN33@CON_Print

; 918  : 			}

  000e4	e9 f2 00 00 00	 jmp	 $LN29@CON_Print
$LN19@CON_Print:

; 919  : 			else if (*msg == '\r') // carriage return

  000e9	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  000ec	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ef	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000f2	75 1f		 jne	 SHORT $LN21@CON_Print

; 920  : 			{
; 921  : 				con_cy--;

  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  000f9	83 e8 01	 sub	 eax, 1
  000fc	a3 00 00 00 00	 mov	 DWORD PTR _con_cy, eax

; 922  : 				CON_Linefeed();

  00101	e8 00 00 00 00	 call	 _CON_Linefeed
  00106	90		 npad	 1

; 923  : 				controlchars = 0;

  00107	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 0

; 924  : 			}

  0010e	e9 c8 00 00 00	 jmp	 $LN29@CON_Print
$LN21@CON_Print:

; 925  : 			else if (*msg == '\n') // linefeed

  00113	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00116	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00119	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0011c	75 12		 jne	 SHORT $LN23@CON_Print

; 926  : 			{
; 927  : 				CON_Linefeed();

  0011e	e8 00 00 00 00	 call	 _CON_Linefeed
  00123	90		 npad	 1

; 928  : 				controlchars = 0;

  00124	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 0

; 929  : 			}

  0012b	e9 ab 00 00 00	 jmp	 $LN29@CON_Print
$LN23@CON_Print:

; 930  : 			else if (*msg == ' ') // space

  00130	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00133	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00136	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00139	75 41		 jne	 SHORT $LN25@CON_Print

; 931  : 			{
; 932  : 				con_line[con_cx++] = ' ';

  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_line
  00140	03 05 00 00 00
	00		 add	 eax, DWORD PTR _con_cx
  00146	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_cx
  0014f	83 c1 01	 add	 ecx, 1
  00152	89 0d 00 00 00
	00		 mov	 DWORD PTR _con_cx, ecx

; 933  : 				if (con_cx - controlchars >= con_width-11)

  00158	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cx
  0015d	2b 45 f8	 sub	 eax, DWORD PTR _controlchars$[ebp]
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_width
  00166	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00169	3b c1		 cmp	 eax, ecx
  0016b	72 0d		 jb	 SHORT $LN27@CON_Print

; 934  : 				{
; 935  : 					CON_Linefeed();

  0016d	e8 00 00 00 00	 call	 _CON_Linefeed
  00172	90		 npad	 1

; 936  : 					controlchars = 0;

  00173	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 0
$LN27@CON_Print:

; 937  : 				}
; 938  : 			}

  0017a	eb 5f		 jmp	 SHORT $LN29@CON_Print
$LN25@CON_Print:

; 939  : 			else if (*msg == '\t')

  0017c	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0017f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00182	83 f9 09	 cmp	 ecx, 9
  00185	75 54		 jne	 SHORT $LN29@CON_Print
$LN8@CON_Print:

; 940  : 			{
; 941  : 				// adds tab spaces for nice layout in console
; 942  : 
; 943  : 				do
; 944  : 				{
; 945  : 					con_line[con_cx++] = ' ';

  00187	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_line
  0018c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _con_cx
  00192	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  00195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_cx
  0019b	83 c1 01	 add	 ecx, 1
  0019e	89 0d 00 00 00
	00		 mov	 DWORD PTR _con_cx, ecx

; 946  : 				} while ((con_cx - controlchars) % 4 != 0);

  001a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cx
  001a9	2b 45 f8	 sub	 eax, DWORD PTR _controlchars$[ebp]
  001ac	33 d2		 xor	 edx, edx
  001ae	b9 04 00 00 00	 mov	 ecx, 4
  001b3	f7 f1		 div	 ecx
  001b5	85 d2		 test	 edx, edx
  001b7	75 ce		 jne	 SHORT $LN8@CON_Print

; 947  : 
; 948  : 				if (con_cx - controlchars >= con_width-11)

  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cx
  001be	2b 45 f8	 sub	 eax, DWORD PTR _controlchars$[ebp]
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_width
  001c7	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  001ca	3b c1		 cmp	 eax, ecx
  001cc	72 0d		 jb	 SHORT $LN29@CON_Print

; 949  : 				{
; 950  : 					CON_Linefeed();

  001ce	e8 00 00 00 00	 call	 _CON_Linefeed
  001d3	90		 npad	 1

; 951  : 					controlchars = 0;

  001d4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 0
$LN29@CON_Print:

; 952  : 				}
; 953  : 			}
; 954  : 			msg++;

  001db	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  001de	83 c0 01	 add	 eax, 1
  001e1	89 45 08	 mov	 DWORD PTR _msg$[ebp], eax

; 955  : 		}

  001e4	e9 9d fe ff ff	 jmp	 $LN33@CON_Print
$LN5@CON_Print:

; 956  : 
; 957  : 		if (*msg == '\0')

  001e9	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  001ec	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001ef	85 c9		 test	 ecx, ecx
  001f1	75 05		 jne	 SHORT $LN30@CON_Print

; 958  : 			return;

  001f3	e9 94 00 00 00	 jmp	 $LN3@CON_Print
$LN30@CON_Print:

; 959  : 
; 960  : 		// printable character
; 961  : 		for (l = 0; l < (con_width-11) && msg[l] > ' '; l++)

  001f8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _l$[ebp], 0
  001ff	eb 09		 jmp	 SHORT $LN11@CON_Print
$LN9@CON_Print:
  00201	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  00204	83 c0 01	 add	 eax, 1
  00207	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax
$LN11@CON_Print:
  0020a	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  0020f	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00212	39 45 fc	 cmp	 DWORD PTR _l$[ebp], eax
  00215	73 10		 jae	 SHORT $LN10@CON_Print
  00217	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0021a	03 45 fc	 add	 eax, DWORD PTR _l$[ebp]
  0021d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00220	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00223	7e 02		 jle	 SHORT $LN10@CON_Print

; 962  : 			;

  00225	eb da		 jmp	 SHORT $LN9@CON_Print
$LN10@CON_Print:

; 963  : 
; 964  : 		// word wrap
; 965  : 		if ((con_cx - controlchars) + l > con_width-11)

  00227	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cx
  0022c	2b 45 f8	 sub	 eax, DWORD PTR _controlchars$[ebp]
  0022f	03 45 fc	 add	 eax, DWORD PTR _l$[ebp]
  00232	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_width
  00238	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0023b	3b c1		 cmp	 eax, ecx
  0023d	76 0d		 jbe	 SHORT $LN31@CON_Print

; 966  : 		{
; 967  : 			CON_Linefeed();

  0023f	e8 00 00 00 00	 call	 _CON_Linefeed
  00244	90		 npad	 1

; 968  : 			controlchars = 0;

  00245	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _controlchars$[ebp], 0
$LN31@CON_Print:

; 969  : 		}
; 970  : 
; 971  : 		// a word at a time
; 972  : 		for (; l > 0; l--)

  0024c	eb 09		 jmp	 SHORT $LN14@CON_Print
$LN12@CON_Print:
  0024e	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  00251	83 e8 01	 sub	 eax, 1
  00254	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax
$LN14@CON_Print:
  00257	83 7d fc 00	 cmp	 DWORD PTR _l$[ebp], 0
  0025b	76 2a		 jbe	 SHORT $LN13@CON_Print

; 973  : 			con_line[con_cx++] = *(msg++);

  0025d	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_line
  00262	03 05 00 00 00
	00		 add	 eax, DWORD PTR _con_cx
  00268	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  0026b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0026d	88 10		 mov	 BYTE PTR [eax], dl
  0026f	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cx
  00274	83 c0 01	 add	 eax, 1
  00277	a3 00 00 00 00	 mov	 DWORD PTR _con_cx, eax
  0027c	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  0027f	83 c1 01	 add	 ecx, 1
  00282	89 4d 08	 mov	 DWORD PTR _msg$[ebp], ecx
  00285	eb c7		 jmp	 SHORT $LN12@CON_Print
$LN13@CON_Print:

; 974  : 	}

  00287	e9 ec fd ff ff	 jmp	 $LN18@CON_Print
$LN3@CON_Print:

; 975  : }

  0028c	5f		 pop	 edi
  0028d	5e		 pop	 esi
  0028e	5b		 pop	 ebx
  0028f	8b e5		 mov	 esp, ebp
  00291	5d		 pop	 ebp
  00292	c3		 ret	 0
_CON_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_DrawBackpic
_TEXT	SEGMENT
_pic$ = 8						; size = 4
_startx$ = 12						; size = 4
_destwidth$ = 16					; size = 4
_CON_DrawBackpic PROC					; COMDAT

; 1160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1161 : 	startx = destwidth = 0;

  00009	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _destwidth$[ebp], 0
  00010	8b 45 10	 mov	 eax, DWORD PTR _destwidth$[ebp]
  00013	89 45 0c	 mov	 DWORD PTR _startx$[ebp], eax

; 1162 : 	V_DrawScaledPatch(0, 0, 0, pic);

  00016	8b 45 08	 mov	 eax, DWORD PTR _pic$[ebp]
  00019	50		 push	 eax
  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 1163 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_CON_DrawBackpic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_speed_Change
_TEXT	SEGMENT
_CONS_speed_Change PROC					; COMDAT

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 172  : 	if (cons_speed.value < 1)

  00009	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _cons_speed+20, 1
  00010	7d 0f		 jge	 SHORT $LN2@CONS_speed

; 173  : 		CV_SetValue(&cons_speed, 1);

  00012	6a 01		 push	 1
  00014	68 00 00 00 00	 push	 OFFSET _cons_speed
  00019	e8 00 00 00 00	 call	 _CV_SetValue
  0001e	83 c4 08	 add	 esp, 8
$LN2@CONS_speed:

; 174  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_CONS_speed_Change ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_hudlines_Change
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CONS_hudlines_Change PROC				; COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 152  : 	INT32 i;
; 153  : 
; 154  : 	// Clear the currently displayed lines
; 155  : 	for (i = 0; i < con_hudlines; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CONS_hudli
$LN2@CONS_hudli:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CONS_hudli:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_hudlines
  00024	7d 10		 jge	 SHORT $LN3@CONS_hudli

; 156  : 		con_hudtime[i] = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _con_hudtime[eax*4], 0
  00034	eb dc		 jmp	 SHORT $LN2@CONS_hudli
$LN3@CONS_hudli:

; 157  : 
; 158  : 	if (cons_hudlines.value < 1)

  00036	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _cons_hudlines+20, 1
  0003d	7d 0c		 jge	 SHORT $LN5@CONS_hudli

; 159  : 		cons_hudlines.value = 1;

  0003f	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cons_hudlines+20, 1
  00049	eb 13		 jmp	 SHORT $LN7@CONS_hudli
$LN5@CONS_hudli:

; 160  : 	else if (cons_hudlines.value > MAXHUDLINES)

  0004b	83 3d 14 00 00
	00 14		 cmp	 DWORD PTR _cons_hudlines+20, 20 ; 00000014H
  00052	7e 0a		 jle	 SHORT $LN7@CONS_hudli

; 161  : 		cons_hudlines.value = MAXHUDLINES;

  00054	c7 05 14 00 00
	00 14 00 00 00	 mov	 DWORD PTR _cons_hudlines+20, 20 ; 00000014H
$LN7@CONS_hudli:

; 162  : 
; 163  : 	con_hudlines = cons_hudlines.value;

  0005e	a1 14 00 00 00	 mov	 eax, DWORD PTR _cons_hudlines+20
  00063	a3 00 00 00 00	 mov	 DWORD PTR _con_hudlines, eax

; 164  : 
; 165  : 	CONS_Printf("Number of console HUD lines is now %d\n", con_hudlines);

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_hudlines
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NDJNLIOG@Number?5of?5console?5HUD?5lines?5is?5@
  00073	e8 00 00 00 00	 call	 _CONS_Printf
  00078	83 c4 08	 add	 esp, 8

; 166  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_CONS_hudlines_Change ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_RecalcSize
_TEXT	SEGMENT
$T1 = -33308						; size = 4
_string$ = -32792					; size = 16384
_tmp_buffer$ = -16408					; size = 16384
_oldcon_cy$ = -24					; size = 4
_i$ = -20						; size = 4
_oldnumlines$ = -16					; size = 4
_oldcon_width$ = -12					; size = 4
_conw$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CON_RecalcSize PROC					; COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 1c 82 00 00	 mov	 eax, 33308		; 0000821cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 423  : 	size_t conw, oldcon_width, oldnumlines, i, oldcon_cy;
; 424  : 	XBOXSTATIC char tmp_buffer[CON_BUFFERSIZE];
; 425  : 	XBOXSTATIC char string[CON_BUFFERSIZE]; // BP: it is a line but who know
; 426  : 
; 427  : 	con_recalc = false;

  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_recalc, 0

; 428  : 
; 429  : 	conw = (vid.width>>3) - 2;

  00024	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00029	c1 f8 03	 sar	 eax, 3
  0002c	83 e8 02	 sub	 eax, 2
  0002f	89 45 f8	 mov	 DWORD PTR _conw$[ebp], eax

; 430  : 
; 431  : 	if (con_curlines == 200) // first init

  00032	81 3d 00 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _con_curlines, 200 ; 000000c8H
  0003c	75 14		 jne	 SHORT $LN7@CON_Recalc

; 432  : 	{
; 433  : 		con_curlines = vid.height;

  0003e	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00043	a3 00 00 00 00	 mov	 DWORD PTR _con_curlines, eax

; 434  : 		con_destlines = vid.height;

  00048	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0004d	a3 00 00 00 00	 mov	 DWORD PTR _con_destlines, eax
$LN7@CON_Recalc:

; 435  : 	}
; 436  : 
; 437  : 	// check for change of video width
; 438  : 	if (conw == con_width)

  00052	8b 45 f8	 mov	 eax, DWORD PTR _conw$[ebp]
  00055	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_width
  0005b	75 05		 jne	 SHORT $LN8@CON_Recalc

; 439  : 		return; // didn't change

  0005d	e9 9e 01 00 00	 jmp	 $LN3@CON_Recalc
$LN8@CON_Recalc:

; 440  : 
; 441  : 	oldcon_width = con_width;

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  00067	89 45 f4	 mov	 DWORD PTR _oldcon_width$[ebp], eax

; 442  : 	oldnumlines = con_totallines;

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_totallines
  0006f	89 45 f0	 mov	 DWORD PTR _oldnumlines$[ebp], eax

; 443  : 	oldcon_cy = con_cy;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  00077	89 45 e8	 mov	 DWORD PTR _oldcon_cy$[ebp], eax

; 444  : 	M_Memcpy(tmp_buffer, con_buffer, CON_BUFFERSIZE);

  0007a	68 00 40 00 00	 push	 16384			; 00004000H
  0007f	68 00 00 00 00	 push	 OFFSET _con_buffer
  00084	8d 85 e8 bf ff
	ff		 lea	 eax, DWORD PTR _tmp_buffer$[ebp]
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 445  : 
; 446  : 	if (conw < 1)

  00094	83 7d f8 01	 cmp	 DWORD PTR _conw$[ebp], 1
  00098	73 0c		 jae	 SHORT $LN9@CON_Recalc

; 447  : 		con_width = (BASEVIDWIDTH>>3) - 2;

  0009a	c7 05 00 00 00
	00 26 00 00 00	 mov	 DWORD PTR _con_width, 38 ; 00000026H
  000a4	eb 08		 jmp	 SHORT $LN10@CON_Recalc
$LN9@CON_Recalc:

; 448  : 	else
; 449  : 		con_width = conw;

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _conw$[ebp]
  000a9	a3 00 00 00 00	 mov	 DWORD PTR _con_width, eax
$LN10@CON_Recalc:

; 450  : 
; 451  : 	con_width += 11; // Graue 06-19-2004 up to 11 control chars per line

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_width
  000b3	83 c0 0b	 add	 eax, 11			; 0000000bH
  000b6	a3 00 00 00 00	 mov	 DWORD PTR _con_width, eax

; 452  : 
; 453  : 	con_totallines = CON_BUFFERSIZE / con_width;

  000bb	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  000c0	33 d2		 xor	 edx, edx
  000c2	f7 35 00 00 00
	00		 div	 DWORD PTR _con_width
  000c8	a3 00 00 00 00	 mov	 DWORD PTR _con_totallines, eax

; 454  : 	memset(con_buffer, ' ', CON_BUFFERSIZE);

  000cd	68 00 40 00 00	 push	 16384			; 00004000H
  000d2	6a 20		 push	 32			; 00000020H
  000d4	68 00 00 00 00	 push	 OFFSET _con_buffer
  000d9	e8 00 00 00 00	 call	 _memset
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 455  : 
; 456  : 	con_cx = 0;

  000e1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_cx, 0

; 457  : 	con_cy = con_totallines-1;

  000eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_totallines
  000f0	83 e8 01	 sub	 eax, 1
  000f3	a3 00 00 00 00	 mov	 DWORD PTR _con_cy, eax

; 458  : 	con_line = &con_buffer[con_cy*con_width];

  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_cy
  000fd	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _con_width
  00104	05 00 00 00 00	 add	 eax, OFFSET _con_buffer
  00109	a3 00 00 00 00	 mov	 DWORD PTR _con_line, eax

; 459  : 	con_scrollup = 0;

  0010e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_scrollup, 0

; 460  : 
; 461  : 	// re-arrange console text buffer to keep text
; 462  : 	if (oldcon_width) // not the first time

  00118	83 7d f4 00	 cmp	 DWORD PTR _oldcon_width$[ebp], 0
  0011c	0f 84 de 00 00
	00		 je	 $LN3@CON_Recalc

; 463  : 	{
; 464  : 		for (i = oldcon_cy + 1; i < oldcon_cy + oldnumlines; i++)

  00122	8b 45 e8	 mov	 eax, DWORD PTR _oldcon_cy$[ebp]
  00125	83 c0 01	 add	 eax, 1
  00128	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  0012b	eb 09		 jmp	 SHORT $LN4@CON_Recalc
$LN2@CON_Recalc:
  0012d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CON_Recalc:
  00136	8b 45 e8	 mov	 eax, DWORD PTR _oldcon_cy$[ebp]
  00139	03 45 f0	 add	 eax, DWORD PTR _oldnumlines$[ebp]
  0013c	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  0013f	0f 83 bb 00 00
	00		 jae	 $LN3@CON_Recalc

; 465  : 		{
; 466  : 			if (tmp_buffer[(i%oldnumlines)*oldcon_width])

  00145	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00148	33 d2		 xor	 edx, edx
  0014a	f7 75 f0	 div	 DWORD PTR _oldnumlines$[ebp]
  0014d	0f af 55 f4	 imul	 edx, DWORD PTR _oldcon_width$[ebp]
  00151	0f be 84 15 e8
	bf ff ff	 movsx	 eax, BYTE PTR _tmp_buffer$[ebp+edx]
  00159	85 c0		 test	 eax, eax
  0015b	0f 84 9a 00 00
	00		 je	 $LN12@CON_Recalc

; 467  : 			{
; 468  : 				M_Memcpy(string, &tmp_buffer[(i%oldnumlines)*oldcon_width], oldcon_width);

  00161	8b 45 f4	 mov	 eax, DWORD PTR _oldcon_width$[ebp]
  00164	50		 push	 eax
  00165	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00168	33 d2		 xor	 edx, edx
  0016a	f7 75 f0	 div	 DWORD PTR _oldnumlines$[ebp]
  0016d	0f af 55 f4	 imul	 edx, DWORD PTR _oldcon_width$[ebp]
  00171	8d 8c 15 e8 bf
	ff ff		 lea	 ecx, DWORD PTR _tmp_buffer$[ebp+edx]
  00178	51		 push	 ecx
  00179	8d 95 e8 7f ff
	ff		 lea	 edx, DWORD PTR _string$[ebp]
  0017f	52		 push	 edx
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00186	83 c4 0c	 add	 esp, 12			; 0000000cH

; 469  : 				conw = oldcon_width - 1;

  00189	8b 45 f4	 mov	 eax, DWORD PTR _oldcon_width$[ebp]
  0018c	83 e8 01	 sub	 eax, 1
  0018f	89 45 f8	 mov	 DWORD PTR _conw$[ebp], eax
$LN5@CON_Recalc:

; 470  : 				while (string[conw] == ' ' && conw)

  00192	8b 45 f8	 mov	 eax, DWORD PTR _conw$[ebp]
  00195	0f be 8c 05 e8
	7f ff ff	 movsx	 ecx, BYTE PTR _string$[ebp+eax]
  0019d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  001a0	75 11		 jne	 SHORT $LN6@CON_Recalc
  001a2	83 7d f8 00	 cmp	 DWORD PTR _conw$[ebp], 0
  001a6	74 0b		 je	 SHORT $LN6@CON_Recalc

; 471  : 					conw--;

  001a8	8b 45 f8	 mov	 eax, DWORD PTR _conw$[ebp]
  001ab	83 e8 01	 sub	 eax, 1
  001ae	89 45 f8	 mov	 DWORD PTR _conw$[ebp], eax
  001b1	eb df		 jmp	 SHORT $LN5@CON_Recalc
$LN6@CON_Recalc:

; 472  : 				string[conw+1] = '\n';

  001b3	8b 45 f8	 mov	 eax, DWORD PTR _conw$[ebp]
  001b6	c6 84 05 e9 7f
	ff ff 0a	 mov	 BYTE PTR _string$[ebp+eax+1], 10 ; 0000000aH

; 473  : 				string[conw+2] = '\0';

  001be	8b 45 f8	 mov	 eax, DWORD PTR _conw$[ebp]
  001c1	83 c0 02	 add	 eax, 2
  001c4	89 85 e4 7d ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  001ca	81 bd e4 7d ff
	ff 00 40 00 00	 cmp	 DWORD PTR $T1[ebp], 16384 ; 00004000H
  001d4	73 02		 jae	 SHORT $LN14@CON_Recalc
  001d6	eb 06		 jmp	 SHORT $LN15@CON_Recalc
$LN14@CON_Recalc:
  001d8	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  001dd	90		 npad	 1
$LN15@CON_Recalc:
  001de	8b 8d e4 7d ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  001e4	c6 84 0d e8 7f
	ff ff 00	 mov	 BYTE PTR _string$[ebp+ecx], 0

; 474  : 				CON_Print(string);

  001ec	8d 85 e8 7f ff
	ff		 lea	 eax, DWORD PTR _string$[ebp]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 _CON_Print
  001f8	83 c4 04	 add	 esp, 4
$LN12@CON_Recalc:

; 475  : 			}
; 476  : 		}

  001fb	e9 2d ff ff ff	 jmp	 $LN2@CON_Recalc
$LN3@CON_Recalc:

; 477  : 	}
; 478  : }

  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00206	33 cd		 xor	 ecx, ebp
  00208	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
_CON_RecalcSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_InputInit
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CON_InputInit PROC					; COMDAT

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 404  : 	INT32 i;
; 405  : 
; 406  : 	// prepare the first prompt line
; 407  : 	memset(inputlines, 0, sizeof (inputlines));

  00009	68 00 20 00 00	 push	 8192			; 00002000H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _inputlines
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 408  : 	for (i = 0; i < 32; i++)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@CON_InputI
$LN2@CON_InputI:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CON_InputI:
  0002f	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00033	7d 18		 jge	 SHORT $LN3@CON_InputI

; 409  : 		inputlines[i][0] = CON_PROMPTCHAR;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00038	c1 e0 08	 shl	 eax, 8
  0003b	b9 01 00 00 00	 mov	 ecx, 1
  00040	6b d1 00	 imul	 edx, ecx, 0
  00043	c6 84 10 00 00
	00 00 3e	 mov	 BYTE PTR _inputlines[eax+edx], 62 ; 0000003eH
  0004b	eb d9		 jmp	 SHORT $LN2@CON_InputI
$LN3@CON_InputI:

; 410  : 	inputline = 0;

  0004d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _inputline, 0

; 411  : 	input_cx = 1;

  00057	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _input_cx, 1

; 412  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_CON_InputInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_LogMessage
_TEXT	SEGMENT
tv65 = -216						; size = 4
_e$ = -148						; size = 4
_p$ = -144						; size = 4
_ls$ = -140						; size = 4
_t$ = -136						; size = 4
_txt$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CON_LogMessage PROC					; COMDAT

; 978  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 979  : 	XBOXSTATIC char txt[128], *t;
; 980  : #if defined (LOGMESSAGES) && defined (_WINDOWS)
; 981  : 	const boolean ls = (logstream != INVALID_HANDLE_VALUE);

  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _logstream, -1
  0001d	74 0c		 je	 SHORT $LN11@CON_LogMes
  0001f	c7 85 28 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  00029	eb 0a		 jmp	 SHORT $LN12@CON_LogMes
$LN11@CON_LogMes:
  0002b	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN12@CON_LogMes:
  00035	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ls$[ebp], eax

; 982  : #endif
; 983  : 	const char *p = msg, *e = txt+sizeof (txt)-2;

  00041	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00044	89 85 70 ff ff
	ff		 mov	 DWORD PTR _p$[ebp], eax
  0004a	8d 45 fa	 lea	 eax, DWORD PTR _txt$[ebp+126]
  0004d	89 85 6c ff ff
	ff		 mov	 DWORD PTR _e$[ebp], eax

; 984  : 
; 985  : 	for (t = txt; *p != '\0'; p++)

  00053	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00059	89 85 78 ff ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
  0005f	eb 0f		 jmp	 SHORT $LN4@CON_LogMes
$LN2@CON_LogMes:
  00061	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _p$[ebp], eax
$LN4@CON_LogMes:
  00070	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  00076	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00079	85 c9		 test	 ecx, ecx
  0007b	0f 84 d6 00 00
	00		 je	 $LN3@CON_LogMes

; 986  : 	{
; 987  : 		if (*p == '\n' || *p >= ' ') // don't log or console print CON_Print's control characters

  00081	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  00087	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008a	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0008d	74 0e		 je	 SHORT $LN6@CON_LogMes
  0008f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  00095	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00098	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009b	7c 68		 jl	 SHORT $LN5@CON_LogMes
$LN6@CON_LogMes:

; 988  : 		{
; 989  : #if defined (LOGMESSAGES) && defined (_WINDOWS)
; 990  : 			if (*p == '\n' && (p == msg || *(p-1) != '\r') && ls)

  0009d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  000a3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a6	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000a9	75 3b		 jne	 SHORT $LN7@CON_LogMes
  000ab	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  000b1	3b 45 08	 cmp	 eax, DWORD PTR _msg$[ebp]
  000b4	74 0f		 je	 SHORT $LN8@CON_LogMes
  000b6	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  000bc	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  000c0	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  000c3	74 21		 je	 SHORT $LN7@CON_LogMes
$LN8@CON_LogMes:
  000c5	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _ls$[ebp], 0
  000cc	74 18		 je	 SHORT $LN7@CON_LogMes

; 991  : 				*t++ = '\r';

  000ce	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  000d4	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH
  000d7	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _t$[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _t$[ebp], ecx
$LN7@CON_LogMes:

; 992  : #endif
; 993  : 			*t++ = *p;

  000e6	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  000ec	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _p$[ebp]
  000f2	8a 11		 mov	 dl, BYTE PTR [ecx]
  000f4	88 10		 mov	 BYTE PTR [eax], dl
  000f6	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  000fc	83 c0 01	 add	 eax, 1
  000ff	89 85 78 ff ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
$LN5@CON_LogMes:

; 994  : 		}
; 995  : 
; 996  : 		if (t >= e)

  00105	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  0010b	3b 85 6c ff ff
	ff		 cmp	 eax, DWORD PTR _e$[ebp]
  00111	72 3f		 jb	 SHORT $LN9@CON_LogMes

; 997  : 		{
; 998  : 			*t = '\0'; //end of string

  00113	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  00119	c6 00 00	 mov	 BYTE PTR [eax], 0

; 999  : 			I_OutputMsg("%s", txt); //print string

  0011c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00122	50		 push	 eax
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00128	e8 00 00 00 00	 call	 _I_OutputMsg
  0012d	83 c4 08	 add	 esp, 8

; 1000 : 			t = txt; //reset t pointer

  00130	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00136	89 85 78 ff ff
	ff		 mov	 DWORD PTR _t$[ebp], eax

; 1001 : 			memset(txt,'\0', sizeof (txt)); //reset txt

  0013c	68 80 00 00 00	 push	 128			; 00000080H
  00141	6a 00		 push	 0
  00143	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 _memset
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CON_LogMes:

; 1002 : 		}
; 1003 : 	}

  00152	e9 0a ff ff ff	 jmp	 $LN2@CON_LogMes
$LN3@CON_LogMes:

; 1004 : 	*t = '\0'; //end of string

  00157	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  0015d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1005 : 	I_OutputMsg("%s", txt);

  00160	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  00166	50		 push	 eax
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0016c	e8 00 00 00 00	 call	 _I_OutputMsg
  00171	83 c4 08	 add	 esp, 8

; 1006 : }

  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017a	33 cd		 xor	 ecx, ebp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
_CON_LogMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_ToggleOff
_TEXT	SEGMENT
_CON_ToggleOff PROC					; COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 513  : 	if (!con_destlines)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_destlines, 0
  00010	75 02		 jne	 SHORT $LN2@CON_Toggle

; 514  : 		return;

  00012	eb 2e		 jmp	 SHORT $LN1@CON_Toggle
$LN2@CON_Toggle:

; 515  : 
; 516  : 	con_destlines = 0;

  00014	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_destlines, 0

; 517  : 	con_curlines = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_curlines, 0

; 518  : 	CON_ClearHUD();

  00028	e8 00 00 00 00	 call	 _CON_ClearHUD
  0002d	90		 npad	 1

; 519  : 	con_forcepic = 0;

  0002e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_forcepic, 0

; 520  : 	con_clipviewtop = -1; // remove console clipping of view

  00038	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _con_clipviewtop, -1
$LN1@CON_Toggle:

; 521  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_CON_ToggleOff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_Error
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CONS_Error PROC					; COMDAT

; 1067 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1068 : #ifdef RPC_NO_WINDOWS_H
; 1069 : 	if (!graphics_started)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _graphics_started
  00010	85 c0		 test	 eax, eax
  00012	75 1b		 jne	 SHORT $LN4@CONS_Error

; 1070 : 	{
; 1071 : 		MessageBoxA(vid.WndParent, msg, "SRB2 Warning", MB_OK);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MIEJCNHC@SRB2?5Warning@
  0001b	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0001e	50		 push	 eax
  0001f	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR _vid+56
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  0002c	90		 npad	 1

; 1072 : 		return;

  0002d	eb 30		 jmp	 SHORT $LN3@CONS_Error
$LN4@CONS_Error:

; 1073 : 	}
; 1074 : #endif
; 1075 : 	CONS_Printf("\2%s", msg); // write error msg in different colour

  0002f	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_03EOCGEGFG@?$AC?$CFs@
  00038	e8 00 00 00 00	 call	 _CONS_Printf
  0003d	83 c4 08	 add	 esp, 8

; 1076 : 	CONS_Printf("Press ENTER to continue\n");

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PJPAHPCN@Press?5ENTER?5to?5continue?6@
  00045	e8 00 00 00 00	 call	 _CONS_Printf
  0004a	83 c4 04	 add	 esp, 4
$LN2@CONS_Error:

; 1077 : 
; 1078 : 	// dirty quick hack, but for the good cause
; 1079 : 	while (I_GetKey() != KEY_ENTER)

  0004d	e8 00 00 00 00	 call	 _I_GetKey
  00052	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00055	74 08		 je	 SHORT $LN3@CONS_Error

; 1080 : 		I_OsPolling();

  00057	e8 00 00 00 00	 call	 _I_OsPolling
  0005c	90		 npad	 1
  0005d	eb ee		 jmp	 SHORT $LN2@CONS_Error
$LN3@CONS_Error:

; 1081 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_CONS_Error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_Drawer
_TEXT	SEGMENT
_CON_Drawer PROC					; COMDAT

; 1281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1282 : 	if (!con_started || !graphics_started)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_started, 0
  00010	74 0b		 je	 SHORT $LN3@CON_Drawer
  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _graphics_started
  00019	85 c0		 test	 eax, eax
  0001b	75 02		 jne	 SHORT $LN2@CON_Drawer
$LN3@CON_Drawer:

; 1283 : 		return;

  0001d	eb 4a		 jmp	 SHORT $LN7@CON_Drawer
$LN2@CON_Drawer:

; 1284 : 
; 1285 : 	if (con_recalc)

  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_recalc, 0
  00026	74 06		 je	 SHORT $LN4@CON_Drawer

; 1286 : 		CON_RecalcSize();

  00028	e8 00 00 00 00	 call	 _CON_RecalcSize
  0002d	90		 npad	 1
$LN4@CON_Drawer:

; 1287 : 
; 1288 : 	if (con_curlines > 0)

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_curlines, 0
  00035	7e 08		 jle	 SHORT $LN5@CON_Drawer

; 1289 : 		CON_DrawConsole();

  00037	e8 00 00 00 00	 call	 _CON_DrawConsole
  0003c	90		 npad	 1
  0003d	eb 2a		 jmp	 SHORT $LN7@CON_Drawer
$LN5@CON_Drawer:

; 1290 : 	else if (gamestate == GS_LEVEL || gamestate == GS_INTERMISSION || gamestate == GS_CUTSCENE || gamestate == GS_CREDITS)

  0003f	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  00046	74 1b		 je	 SHORT $LN8@CON_Drawer
  00048	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _gamestate, 2
  0004f	74 12		 je	 SHORT $LN8@CON_Drawer
  00051	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _gamestate, 7
  00058	74 09		 je	 SHORT $LN8@CON_Drawer
  0005a	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR _gamestate, 10 ; 0000000aH
  00061	75 06		 jne	 SHORT $LN7@CON_Drawer
$LN8@CON_Drawer:

; 1291 : 		CON_DrawHudlines();

  00063	e8 00 00 00 00	 call	 _CON_DrawHudlines
  00068	90		 npad	 1
$LN7@CON_Drawer:

; 1292 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_CON_Drawer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_Ticker
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CON_Ticker PROC					; COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 527  : 	INT32 i;
; 528  : 
; 529  : 	// cursor blinking
; 530  : 	con_tick++;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_tick
  0000e	83 c0 01	 add	 eax, 1
  00011	a3 00 00 00 00	 mov	 DWORD PTR _con_tick, eax

; 531  : 	con_tick &= 7;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_tick
  0001b	83 e0 07	 and	 eax, 7
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _con_tick, eax

; 532  : 
; 533  : 	// console key was pushed
; 534  : 	if (consoletoggle)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _consoletoggle, 0
  0002a	74 77		 je	 SHORT $LN7@CON_Ticker

; 535  : 	{
; 536  : 		consoletoggle = false;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _consoletoggle, 0

; 537  : 
; 538  : 		// toggle off console
; 539  : 		if (con_destlines > 0)

  00036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_destlines, 0
  0003d	7e 12		 jle	 SHORT $LN6@CON_Ticker

; 540  : 		{
; 541  : 			con_destlines = 0;

  0003f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_destlines, 0

; 542  : 			CON_ClearHUD();

  00049	e8 00 00 00 00	 call	 _CON_ClearHUD
  0004e	90		 npad	 1

; 543  : 		}

  0004f	eb 52		 jmp	 SHORT $LN7@CON_Ticker
$LN6@CON_Ticker:

; 544  : 		else
; 545  : 		{
; 546  : 			// toggle console in
; 547  : 			con_destlines = (cons_height.value*vid.height)/100;

  00051	a1 14 00 00 00	 mov	 eax, DWORD PTR _cons_height+20
  00056	0f af 05 10 00
	00 00		 imul	 eax, DWORD PTR _vid+16
  0005d	99		 cdq
  0005e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00063	f7 f9		 idiv	 ecx
  00065	a3 00 00 00 00	 mov	 DWORD PTR _con_destlines, eax

; 548  : 			if (con_destlines < 20)

  0006a	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR _con_destlines, 20 ; 00000014H
  00071	7d 0c		 jge	 SHORT $LN8@CON_Ticker

; 549  : 				con_destlines = 20;

  00073	c7 05 00 00 00
	00 14 00 00 00	 mov	 DWORD PTR _con_destlines, 20 ; 00000014H
  0007d	eb 17		 jmp	 SHORT $LN10@CON_Ticker
$LN8@CON_Ticker:

; 550  : 			else if (con_destlines > vid.height)

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_destlines
  00084	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  0008a	7e 0a		 jle	 SHORT $LN10@CON_Ticker

; 551  : 				con_destlines = vid.height;

  0008c	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00091	a3 00 00 00 00	 mov	 DWORD PTR _con_destlines, eax
$LN10@CON_Ticker:

; 552  : 
; 553  : 			con_destlines &= ~0x3; // multiple of text row height

  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_destlines
  0009b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0009e	a3 00 00 00 00	 mov	 DWORD PTR _con_destlines, eax
$LN7@CON_Ticker:

; 554  : 		}
; 555  : 	}
; 556  : 
; 557  : 	// console movement
; 558  : 	if (con_destlines != con_curlines)

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_destlines
  000a8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_curlines
  000ae	74 06		 je	 SHORT $LN11@CON_Ticker

; 559  : 		CON_MoveConsole();

  000b0	e8 00 00 00 00	 call	 _CON_MoveConsole
  000b5	90		 npad	 1
$LN11@CON_Ticker:

; 560  : 
; 561  : 	// clip the view, so that the part under the console is not drawn
; 562  : 	con_clipviewtop = -1;

  000b6	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _con_clipviewtop, -1

; 563  : 	if (cons_backpic.value) // clip only when using an opaque background

  000c0	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cons_backpic+20, 0
  000c7	74 2f		 je	 SHORT $LN14@CON_Ticker

; 564  : 	{
; 565  : 		if (con_curlines > 0)

  000c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_curlines, 0
  000d0	7e 13		 jle	 SHORT $LN13@CON_Ticker

; 566  : 			con_clipviewtop = con_curlines - viewwindowy - 1 - 10;

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  000d7	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _viewwindowy
  000dd	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000e0	a3 00 00 00 00	 mov	 DWORD PTR _con_clipviewtop, eax
$LN13@CON_Ticker:

; 567  : 		// NOTE: BIG HACK::SUBTRACT 10, SO THAT WATER DON'T COPY LINES OF THE CONSOLE
; 568  : 		//       WINDOW!!! (draw some more lines behind the bottom of the console)
; 569  : 		if (con_clipviewtop < 0)

  000e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_clipviewtop, 0
  000ec	7d 0a		 jge	 SHORT $LN14@CON_Ticker

; 570  : 			con_clipviewtop = -1; // maybe not necessary, provided it's < 0

  000ee	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _con_clipviewtop, -1
$LN14@CON_Ticker:

; 571  : 	}
; 572  : 
; 573  : 	// check if console ready for prompt
; 574  : 	if (con_destlines >= 20)

  000f8	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR _con_destlines, 20 ; 00000014H
  000ff	7c 0c		 jl	 SHORT $LN15@CON_Ticker

; 575  : 		consoleready = true;

  00101	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _consoleready, 1
  0010b	eb 0a		 jmp	 SHORT $LN16@CON_Ticker
$LN15@CON_Ticker:

; 576  : 	else
; 577  : 		consoleready = false;

  0010d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _consoleready, 0
$LN16@CON_Ticker:

; 578  : 
; 579  : 	// make overlay messages disappear after a while
; 580  : 	for (i = 0; i < con_hudlines; i++)

  00117	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011e	eb 09		 jmp	 SHORT $LN4@CON_Ticker
$LN2@CON_Ticker:
  00120	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00123	83 c0 01	 add	 eax, 1
  00126	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CON_Ticker:
  00129	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0012c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_hudlines
  00132	7d 34		 jge	 SHORT $LN3@CON_Ticker

; 581  : 	{
; 582  : 		con_hudtime[i]--;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00137	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _con_hudtime[eax*4]
  0013e	83 e9 01	 sub	 ecx, 1
  00141	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00144	89 0c 95 00 00
	00 00		 mov	 DWORD PTR _con_hudtime[edx*4], ecx

; 583  : 		if (con_hudtime[i] < 0)

  0014b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0014e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _con_hudtime[eax*4], 0
  00156	7d 0e		 jge	 SHORT $LN17@CON_Ticker

; 584  : 			con_hudtime[i] = 0;

  00158	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0015b	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _con_hudtime[eax*4], 0
$LN17@CON_Ticker:

; 585  : 	}

  00166	eb b8		 jmp	 SHORT $LN2@CON_Ticker
$LN3@CON_Ticker:

; 586  : }

  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
_CON_Ticker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_ClearHUD
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CON_ClearHUD PROC					; COMDAT

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 503  : 	INT32 i;
; 504  : 
; 505  : 	for (i = 0; i < con_hudlines; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CON_ClearH
$LN2@CON_ClearH:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CON_ClearH:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _con_hudlines
  00024	7d 10		 jge	 SHORT $LN3@CON_ClearH

; 506  : 		con_hudtime[i] = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _con_hudtime[eax*4], 0
  00034	eb dc		 jmp	 SHORT $LN2@CON_ClearH
$LN3@CON_ClearH:

; 507  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_CON_ClearHUD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_ReSetupBackColormap
_TEXT	SEGMENT
_pal$ = -16						; size = 4
_k$ = -9						; size = 1
_j$ = -8						; size = 2
_i$ = -4						; size = 2
_num$ = 8						; size = 2
_CON_ReSetupBackColormap PROC				; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 259  : 	UINT16 i, j;
; 260  : 	UINT8 k;
; 261  : 	UINT8 *pal = W_CacheLumpName(R_GetPalname(num), PU_CACHE);

  00009	6a 65		 push	 101			; 00000065H
  0000b	0f b7 45 08	 movzx	 eax, WORD PTR _num$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _R_GetPalname
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _W_CacheLumpName
  0001e	83 c4 08	 add	 esp, 8
  00021	89 45 f0	 mov	 DWORD PTR _pal$[ebp], eax

; 262  : 
; 263  : 	// setup the green translucent background colormaps
; 264  : 	for (i = 0, k = 0; i < 768; i += 3, k++)

  00024	33 c0		 xor	 eax, eax
  00026	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
  0002a	c6 45 f7 00	 mov	 BYTE PTR _k$[ebp], 0
  0002e	eb 14		 jmp	 SHORT $LN4@CON_ReSetu
$LN2@CON_ReSetu:
  00030	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00034	83 c0 03	 add	 eax, 3
  00037	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
  0003b	8a 4d f7	 mov	 cl, BYTE PTR _k$[ebp]
  0003e	80 c1 01	 add	 cl, 1
  00041	88 4d f7	 mov	 BYTE PTR _k$[ebp], cl
$LN4@CON_ReSetu:
  00044	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00048	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  0004d	0f 8d cc 00 00
	00		 jge	 $LN3@CON_ReSetu

; 265  : 	{
; 266  : 		j = pal[i] + pal[i+1] + pal[i+2];

  00053	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _pal$[ebp]
  0005a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0005e	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _pal$[ebp]
  00065	0f b6 44 01 01	 movzx	 eax, BYTE PTR [ecx+eax+1]
  0006a	03 d0		 add	 edx, eax
  0006c	0f b7 4d fc	 movzx	 ecx, WORD PTR _i$[ebp]
  00070	8b 45 f0	 mov	 eax, DWORD PTR _pal$[ebp]
  00073	0f b6 4c 08 02	 movzx	 ecx, BYTE PTR [eax+ecx+2]
  00078	03 d1		 add	 edx, ecx
  0007a	66 89 55 f8	 mov	 WORD PTR _j$[ebp], dx

; 267  : 		cwhitemap[k] = (UINT8)(15 - (j>>6));

  0007e	0f b7 45 f8	 movzx	 eax, WORD PTR _j$[ebp]
  00082	c1 f8 06	 sar	 eax, 6
  00085	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0008a	2b c8		 sub	 ecx, eax
  0008c	0f b6 55 f7	 movzx	 edx, BYTE PTR _k$[ebp]
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _cwhitemap
  00095	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 268  : 		corangemap[k] = (UINT8)(95 - (j>>6));

  00098	0f b7 45 f8	 movzx	 eax, WORD PTR _j$[ebp]
  0009c	c1 f8 06	 sar	 eax, 6
  0009f	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  000a4	2b c8		 sub	 ecx, eax
  000a6	0f b6 55 f7	 movzx	 edx, BYTE PTR _k$[ebp]
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _corangemap
  000af	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 269  : 		cbluemap[k] = (UINT8)(239 - (j>>6));

  000b2	0f b7 45 f8	 movzx	 eax, WORD PTR _j$[ebp]
  000b6	c1 f8 06	 sar	 eax, 6
  000b9	b9 ef 00 00 00	 mov	 ecx, 239		; 000000efH
  000be	2b c8		 sub	 ecx, eax
  000c0	0f b6 55 f7	 movzx	 edx, BYTE PTR _k$[ebp]
  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _cbluemap
  000c9	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 270  : 		cgreenmap[k] = (UINT8)(175 - (j>>6));

  000cc	0f b7 45 f8	 movzx	 eax, WORD PTR _j$[ebp]
  000d0	c1 f8 06	 sar	 eax, 6
  000d3	b9 af 00 00 00	 mov	 ecx, 175		; 000000afH
  000d8	2b c8		 sub	 ecx, eax
  000da	0f b6 55 f7	 movzx	 edx, BYTE PTR _k$[ebp]
  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR _cgreenmap
  000e3	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 271  : 		cgraymap[k] = (UINT8)(31 - (j>>6));

  000e6	0f b7 45 f8	 movzx	 eax, WORD PTR _j$[ebp]
  000ea	c1 f8 06	 sar	 eax, 6
  000ed	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  000f2	2b c8		 sub	 ecx, eax
  000f4	0f b6 55 f7	 movzx	 edx, BYTE PTR _k$[ebp]
  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _cgraymap
  000fd	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 272  : 		credmap[k] = (UINT8)(143 - (j>>6));

  00100	0f b7 45 f8	 movzx	 eax, WORD PTR _j$[ebp]
  00104	c1 f8 06	 sar	 eax, 6
  00107	b9 8f 00 00 00	 mov	 ecx, 143		; 0000008fH
  0010c	2b c8		 sub	 ecx, eax
  0010e	0f b6 55 f7	 movzx	 edx, BYTE PTR _k$[ebp]
  00112	a1 00 00 00 00	 mov	 eax, DWORD PTR _credmap
  00117	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 273  : 	}

  0011a	e9 11 ff ff ff	 jmp	 $LN2@CON_ReSetu
$LN3@CON_ReSetu:

; 274  : }

  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
_CON_ReSetupBackColormap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_Responder
_TEXT	SEGMENT
$T1 = -96						; size = 4
_keypad_translation$2 = -28				; size = 13
_key$ = -12						; size = 4
_cmd$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ev$ = 8						; size = 4
_CON_Responder PROC					; COMDAT

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 592  : 	static boolean shiftdown;
; 593  : 
; 594  : 	// sequential completions a la 4dos
; 595  : 	static char completion[80];
; 596  : 	static INT32 comskips, varskips;
; 597  : 
; 598  : 	const char *cmd = "";

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cmd$[ebp], OFFSET ??_C@_00CNPNBAHC@@

; 599  : 	INT32 key;
; 600  : 
; 601  : 	if (chat_on)

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _chat_on, 0
  00021	74 07		 je	 SHORT $LN8@CON_Respon

; 602  : 		return false;

  00023	33 c0		 xor	 eax, eax
  00025	e9 e8 07 00 00	 jmp	 $LN1@CON_Respon
$LN8@CON_Respon:

; 603  : 
; 604  : 	// special keys state
; 605  : 	if ((ev->data1 == KEY_LSHIFT || ev->data1 == KEY_RSHIFT) && ev->type == ev_keyup)

  0002a	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  0002d	81 78 04 b6 00
	00 00		 cmp	 DWORD PTR [eax+4], 182	; 000000b6H
  00034	74 0c		 je	 SHORT $LN10@CON_Respon
  00036	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  00039	81 78 04 b7 00
	00 00		 cmp	 DWORD PTR [eax+4], 183	; 000000b7H
  00040	75 19		 jne	 SHORT $LN9@CON_Respon
$LN10@CON_Respon:
  00042	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  00045	83 38 01	 cmp	 DWORD PTR [eax], 1
  00048	75 11		 jne	 SHORT $LN9@CON_Respon

; 606  : 	{
; 607  : 		shiftdown = false;

  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?shiftdown@?1??CON_Responder@@9@9, 0

; 608  : 		return false;

  00054	33 c0		 xor	 eax, eax
  00056	e9 b7 07 00 00	 jmp	 $LN1@CON_Respon
$LN9@CON_Respon:

; 609  : 	}
; 610  : 
; 611  : 	// let go keyup events, don't eat them
; 612  : 	if (ev->type != ev_keydown && ev->type != ev_console)

  0005b	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  0005e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00061	74 0f		 je	 SHORT $LN11@CON_Respon
  00063	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  00066	83 38 02	 cmp	 DWORD PTR [eax], 2
  00069	74 07		 je	 SHORT $LN11@CON_Respon

; 613  : 		return false;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 a0 07 00 00	 jmp	 $LN1@CON_Respon
$LN11@CON_Respon:

; 614  : 
; 615  : 	key = ev->data1;

  00072	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  00075	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00078	89 4d f4	 mov	 DWORD PTR _key$[ebp], ecx

; 616  : 
; 617  : 	// check for console toggle key
; 618  : 	if (ev->type != ev_console)

  0007b	8b 45 08	 mov	 eax, DWORD PTR _ev$[ebp]
  0007e	83 38 02	 cmp	 DWORD PTR [eax], 2
  00081	0f 84 f7 00 00
	00		 je	 $LN18@CON_Respon

; 619  : 	{
; 620  : 		if (key == gamecontrol[gc_console][0] || key == gamecontrol[gc_console][1])

  00087	b8 08 00 00 00	 mov	 eax, 8
  0008c	6b c8 21	 imul	 ecx, eax, 33
  0008f	ba 04 00 00 00	 mov	 edx, 4
  00094	6b c2 00	 imul	 eax, edx, 0
  00097	8b 55 f4	 mov	 edx, DWORD PTR _key$[ebp]
  0009a	3b 94 01 00 00
	00 00		 cmp	 edx, DWORD PTR _gamecontrol[ecx+eax]
  000a1	74 1c		 je	 SHORT $LN14@CON_Respon
  000a3	b8 08 00 00 00	 mov	 eax, 8
  000a8	6b c8 21	 imul	 ecx, eax, 33
  000ab	ba 04 00 00 00	 mov	 edx, 4
  000b0	c1 e2 00	 shl	 edx, 0
  000b3	8b 45 f4	 mov	 eax, DWORD PTR _key$[ebp]
  000b6	3b 84 11 00 00
	00 00		 cmp	 eax, DWORD PTR _gamecontrol[ecx+edx]
  000bd	75 3d		 jne	 SHORT $LN13@CON_Respon
$LN14@CON_Respon:

; 621  : 		{
; 622  : 			consoletoggle = true;

  000bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _consoletoggle, 1

; 623  : 
; 624  : 			if (timeattacking)

  000c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  000d0	74 20		 je	 SHORT $LN15@CON_Respon

; 625  : 			{
; 626  : 				G_CheckDemoStatus();

  000d2	e8 00 00 00 00	 call	 _G_CheckDemoStatus
  000d7	90		 npad	 1

; 627  : 				timeattacking = true;

  000d8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _timeattacking, 1

; 628  : 				M_StartControlPanel();

  000e2	e8 00 00 00 00	 call	 _M_StartControlPanel
  000e7	90		 npad	 1

; 629  : 				consoletoggle = false;

  000e8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _consoletoggle, 0
$LN15@CON_Respon:

; 630  : 			}
; 631  : 
; 632  : 			return true;

  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	e9 16 07 00 00	 jmp	 $LN1@CON_Respon
$LN13@CON_Respon:

; 633  : 		}
; 634  : 
; 635  : 		// check other keys only if console prompt is active
; 636  : 		if (!consoleready && key < NUMINPUTS) // metzgermeister: boundary check!!

  000fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _consoleready, 0
  00103	75 50		 jne	 SHORT $LN16@CON_Respon
  00105	81 7d f4 e4 01
	00 00		 cmp	 DWORD PTR _key$[ebp], 484 ; 000001e4H
  0010c	7d 47		 jge	 SHORT $LN16@CON_Respon

; 637  : 		{
; 638  : 			if (bindtable[key] && !timeattacking)

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _key$[ebp]
  00111	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _bindtable[eax*4], 0
  00119	74 33		 je	 SHORT $LN17@CON_Respon
  0011b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  00122	75 2a		 jne	 SHORT $LN17@CON_Respon

; 639  : 			{
; 640  : 				COM_BufAddText(bindtable[key]);

  00124	8b 45 f4	 mov	 eax, DWORD PTR _key$[ebp]
  00127	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _bindtable[eax*4]
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 _COM_BufAddText
  00134	83 c4 04	 add	 esp, 4

; 641  : 				COM_BufAddText("\n");

  00137	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0013c	e8 00 00 00 00	 call	 _COM_BufAddText
  00141	83 c4 04	 add	 esp, 4

; 642  : 				return true;

  00144	b8 01 00 00 00	 mov	 eax, 1
  00149	e9 c4 06 00 00	 jmp	 $LN1@CON_Respon
$LN17@CON_Respon:

; 643  : 			}
; 644  : 			return false;

  0014e	33 c0		 xor	 eax, eax
  00150	e9 bd 06 00 00	 jmp	 $LN1@CON_Respon
$LN16@CON_Respon:

; 645  : 		}
; 646  : 
; 647  : 		// escape key toggle off console
; 648  : 		if (key == KEY_ESCAPE)

  00155	83 7d f4 1b	 cmp	 DWORD PTR _key$[ebp], 27 ; 0000001bH
  00159	75 23		 jne	 SHORT $LN18@CON_Respon

; 649  : 		{
; 650  : 			consoletoggle = true;

  0015b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _consoletoggle, 1

; 651  : 
; 652  : 			if (timeattacking)

  00165	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  0016c	74 06		 je	 SHORT $LN19@CON_Respon

; 653  : 				G_CheckDemoStatus();

  0016e	e8 00 00 00 00	 call	 _G_CheckDemoStatus
  00173	90		 npad	 1
$LN19@CON_Respon:

; 654  : 
; 655  : 			return true;

  00174	b8 01 00 00 00	 mov	 eax, 1
  00179	e9 94 06 00 00	 jmp	 $LN1@CON_Respon
$LN18@CON_Respon:

; 656  : 		}
; 657  : 
; 658  : 	}
; 659  : 
; 660  : 	// eat shift only if console active
; 661  : 	if (key == KEY_LSHIFT || key == KEY_RSHIFT)

  0017e	81 7d f4 b6 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 182 ; 000000b6H
  00185	74 09		 je	 SHORT $LN21@CON_Respon
  00187	81 7d f4 b7 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 183 ; 000000b7H
  0018e	75 14		 jne	 SHORT $LN20@CON_Respon
$LN21@CON_Respon:

; 662  : 	{
; 663  : 		shiftdown = true;

  00190	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?shiftdown@?1??CON_Responder@@9@9, 1

; 664  : 		return true;

  0019a	b8 01 00 00 00	 mov	 eax, 1
  0019f	e9 6e 06 00 00	 jmp	 $LN1@CON_Respon
$LN20@CON_Respon:

; 665  : 	}
; 666  : 
; 667  : 	// command completion forward (tab) and backward (shift-tab)
; 668  : 	if (key == KEY_TAB)

  001a4	83 7d f4 09	 cmp	 DWORD PTR _key$[ebp], 9
  001a8	0f 85 18 02 00
	00		 jne	 $LN22@CON_Respon

; 669  : 	{
; 670  : 		// sequential command completion forward and backward
; 671  : 
; 672  : 		// remember typing for several completions (a-la-4dos)
; 673  : 		if (inputlines[inputline][input_cx-1] != ' ')

  001ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  001b3	c1 e0 08	 shl	 eax, 8
  001b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  001bc	0f be 94 08 ff
	ff ff ff	 movsx	 edx, BYTE PTR _inputlines[eax+ecx-1]
  001c4	83 fa 20	 cmp	 edx, 32			; 00000020H
  001c7	74 71		 je	 SHORT $LN23@CON_Respon

; 674  : 		{
; 675  : 			if (strlen(inputlines[inputline]+1) < 80)

  001c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  001ce	c1 e0 08	 shl	 eax, 8
  001d1	05 01 00 00 00	 add	 eax, OFFSET _inputlines+1
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _strlen
  001dc	83 c4 04	 add	 esp, 4
  001df	83 f8 50	 cmp	 eax, 80			; 00000050H
  001e2	73 1d		 jae	 SHORT $LN25@CON_Respon

; 676  : 				strcpy(completion, inputlines[inputline]+1);

  001e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  001e9	c1 e0 08	 shl	 eax, 8
  001ec	05 01 00 00 00	 add	 eax, OFFSET _inputlines+1
  001f1	50		 push	 eax
  001f2	68 00 00 00 00	 push	 OFFSET ?completion@?1??CON_Responder@@9@9
  001f7	e8 00 00 00 00	 call	 _strcpy
  001fc	83 c4 08	 add	 esp, 8
  001ff	eb 23		 jmp	 SHORT $LN26@CON_Respon
$LN25@CON_Respon:

; 677  : 			else
; 678  : 				completion[0] = 0;

  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	6b c8 00	 imul	 ecx, eax, 0
  00209	89 4d a0	 mov	 DWORD PTR $T1[ebp], ecx
  0020c	83 7d a0 50	 cmp	 DWORD PTR $T1[ebp], 80	; 00000050H
  00210	73 02		 jae	 SHORT $LN72@CON_Respon
  00212	eb 06		 jmp	 SHORT $LN73@CON_Respon
$LN72@CON_Respon:
  00214	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00219	90		 npad	 1
$LN73@CON_Respon:
  0021a	8b 55 a0	 mov	 edx, DWORD PTR $T1[ebp]
  0021d	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?completion@?1??CON_Responder@@9@9[edx], 0
$LN26@CON_Respon:

; 679  : 
; 680  : 			comskips = varskips = 0;

  00224	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?varskips@?1??CON_Responder@@9@9, 0
  0022e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?varskips@?1??CON_Responder@@9@9
  00233	a3 00 00 00 00	 mov	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, eax

; 681  : 		}

  00238	eb 6f		 jmp	 SHORT $LN34@CON_Respon
$LN23@CON_Respon:

; 682  : 		else
; 683  : 		{
; 684  : 			if (shiftdown)

  0023a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?shiftdown@?1??CON_Responder@@9@9, 0
  00241	74 41		 je	 SHORT $LN27@CON_Respon

; 685  : 			{
; 686  : 				if (comskips < 0)

  00243	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, 0
  0024a	7d 20		 jge	 SHORT $LN29@CON_Respon

; 687  : 				{
; 688  : 					if (--varskips < 0)

  0024c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?varskips@?1??CON_Responder@@9@9
  00251	83 e8 01	 sub	 eax, 1
  00254	a3 00 00 00 00	 mov	 DWORD PTR ?varskips@?1??CON_Responder@@9@9, eax
  00259	79 0f		 jns	 SHORT $LN31@CON_Respon

; 689  : 						comskips = -comskips - 2;

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?comskips@?1??CON_Responder@@9@9
  00260	f7 d8		 neg	 eax
  00262	83 e8 02	 sub	 eax, 2
  00265	a3 00 00 00 00	 mov	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, eax
$LN31@CON_Respon:

; 690  : 				}

  0026a	eb 16		 jmp	 SHORT $LN32@CON_Respon
$LN29@CON_Respon:

; 691  : 				else if (comskips > 0)

  0026c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, 0
  00273	7e 0d		 jle	 SHORT $LN32@CON_Respon

; 692  : 					comskips--;

  00275	a1 00 00 00 00	 mov	 eax, DWORD PTR ?comskips@?1??CON_Responder@@9@9
  0027a	83 e8 01	 sub	 eax, 1
  0027d	a3 00 00 00 00	 mov	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, eax
$LN32@CON_Respon:

; 693  : 			}

  00282	eb 25		 jmp	 SHORT $LN34@CON_Respon
$LN27@CON_Respon:

; 694  : 			else
; 695  : 			{
; 696  : 				if (comskips < 0)

  00284	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, 0
  0028b	7d 0f		 jge	 SHORT $LN33@CON_Respon

; 697  : 					varskips++;

  0028d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?varskips@?1??CON_Responder@@9@9
  00292	83 c0 01	 add	 eax, 1
  00295	a3 00 00 00 00	 mov	 DWORD PTR ?varskips@?1??CON_Responder@@9@9, eax
  0029a	eb 0d		 jmp	 SHORT $LN34@CON_Respon
$LN33@CON_Respon:

; 698  : 				else
; 699  : 					comskips++;

  0029c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?comskips@?1??CON_Responder@@9@9
  002a1	83 c0 01	 add	 eax, 1
  002a4	a3 00 00 00 00	 mov	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, eax
$LN34@CON_Respon:

; 700  : 			}
; 701  : 		}
; 702  : 
; 703  : 		if (comskips >= 0)

  002a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, 0
  002b0	7c 2b		 jl	 SHORT $LN36@CON_Respon

; 704  : 		{
; 705  : 			cmd = COM_CompleteCommand(completion, comskips);

  002b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?comskips@?1??CON_Responder@@9@9
  002b7	50		 push	 eax
  002b8	68 00 00 00 00	 push	 OFFSET ?completion@?1??CON_Responder@@9@9
  002bd	e8 00 00 00 00	 call	 _COM_CompleteCommand
  002c2	83 c4 08	 add	 esp, 8
  002c5	89 45 f8	 mov	 DWORD PTR _cmd$[ebp], eax

; 706  : 			if (!cmd)

  002c8	83 7d f8 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  002cc	75 0f		 jne	 SHORT $LN36@CON_Respon

; 707  : 				// dirty: make sure if comskips is zero, to have a neg value
; 708  : 				comskips = -comskips - 1;

  002ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?comskips@?1??CON_Responder@@9@9
  002d3	f7 d8		 neg	 eax
  002d5	83 e8 01	 sub	 eax, 1
  002d8	a3 00 00 00 00	 mov	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, eax
$LN36@CON_Respon:

; 709  : 		}
; 710  : 		if (comskips < 0)

  002dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, 0
  002e4	7d 16		 jge	 SHORT $LN37@CON_Respon

; 711  : 			cmd = CV_CompleteVar(completion, varskips);

  002e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?varskips@?1??CON_Responder@@9@9
  002eb	50		 push	 eax
  002ec	68 00 00 00 00	 push	 OFFSET ?completion@?1??CON_Responder@@9@9
  002f1	e8 00 00 00 00	 call	 _CV_CompleteVar
  002f6	83 c4 08	 add	 esp, 8
  002f9	89 45 f8	 mov	 DWORD PTR _cmd$[ebp], eax
$LN37@CON_Respon:

; 712  : 
; 713  : 		if (cmd)

  002fc	83 7d f8 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  00300	0f 84 88 00 00
	00		 je	 $LN38@CON_Respon

; 714  : 		{
; 715  : 			memset(inputlines[inputline]+1, 0, CON_MAXPROMPTCHARS-1);

  00306	68 ff 00 00 00	 push	 255			; 000000ffH
  0030b	6a 00		 push	 0
  0030d	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  00312	c1 e0 08	 shl	 eax, 8
  00315	05 01 00 00 00	 add	 eax, OFFSET _inputlines+1
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 _memset
  00320	83 c4 0c	 add	 esp, 12			; 0000000cH

; 716  : 			strcpy(inputlines[inputline]+1, cmd);

  00323	8b 45 f8	 mov	 eax, DWORD PTR _cmd$[ebp]
  00326	50		 push	 eax
  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _inputline
  0032d	c1 e1 08	 shl	 ecx, 8
  00330	81 c1 01 00 00
	00		 add	 ecx, OFFSET _inputlines+1
  00336	51		 push	 ecx
  00337	e8 00 00 00 00	 call	 _strcpy
  0033c	83 c4 08	 add	 esp, 8

; 717  : 			input_cx = strlen(cmd) + 1;

  0033f	8b 45 f8	 mov	 eax, DWORD PTR _cmd$[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 _strlen
  00348	83 c4 04	 add	 esp, 4
  0034b	83 c0 01	 add	 eax, 1
  0034e	a3 00 00 00 00	 mov	 DWORD PTR _input_cx, eax

; 718  : 			inputlines[inputline][input_cx] = ' ';

  00353	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  00358	c1 e0 08	 shl	 eax, 8
  0035b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  00361	c6 84 08 00 00
	00 00 20	 mov	 BYTE PTR _inputlines[eax+ecx], 32 ; 00000020H

; 719  : 			input_cx++;

  00369	a1 00 00 00 00	 mov	 eax, DWORD PTR _input_cx
  0036e	83 c0 01	 add	 eax, 1
  00371	a3 00 00 00 00	 mov	 DWORD PTR _input_cx, eax

; 720  : 			inputlines[inputline][input_cx] = 0;

  00376	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  0037b	c1 e0 08	 shl	 eax, 8
  0037e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  00384	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR _inputlines[eax+ecx], 0

; 721  : 		}

  0038c	eb 2e		 jmp	 SHORT $LN42@CON_Respon
$LN38@CON_Respon:

; 722  : 		else
; 723  : 		{
; 724  : 			if (comskips > 0)

  0038e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, 0
  00395	7e 0f		 jle	 SHORT $LN40@CON_Respon

; 725  : 				comskips--;

  00397	a1 00 00 00 00	 mov	 eax, DWORD PTR ?comskips@?1??CON_Responder@@9@9
  0039c	83 e8 01	 sub	 eax, 1
  0039f	a3 00 00 00 00	 mov	 DWORD PTR ?comskips@?1??CON_Responder@@9@9, eax
  003a4	eb 16		 jmp	 SHORT $LN42@CON_Respon
$LN40@CON_Respon:

; 726  : 			else if (varskips > 0)

  003a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?varskips@?1??CON_Responder@@9@9, 0
  003ad	7e 0d		 jle	 SHORT $LN42@CON_Respon

; 727  : 				varskips--;

  003af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?varskips@?1??CON_Responder@@9@9
  003b4	83 e8 01	 sub	 eax, 1
  003b7	a3 00 00 00 00	 mov	 DWORD PTR ?varskips@?1??CON_Responder@@9@9, eax
$LN42@CON_Respon:

; 728  : 		}
; 729  : 
; 730  : 		return true;

  003bc	b8 01 00 00 00	 mov	 eax, 1
  003c1	e9 4c 04 00 00	 jmp	 $LN1@CON_Respon
$LN22@CON_Respon:

; 731  : 	}
; 732  : 
; 733  : 	// move up (backward) in console textbuffer
; 734  : 	if (key == KEY_PGUP)

  003c6	81 7d f4 e7 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 231 ; 000000e7H
  003cd	75 34		 jne	 SHORT $LN43@CON_Respon

; 735  : 	{
; 736  : 		if (con_scrollup < (con_totallines-((con_curlines-16)>>3)))

  003cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  003d4	83 e8 10	 sub	 eax, 16			; 00000010H
  003d7	c1 f8 03	 sar	 eax, 3
  003da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_totallines
  003e0	2b c8		 sub	 ecx, eax
  003e2	39 0d 00 00 00
	00		 cmp	 DWORD PTR _con_scrollup, ecx
  003e8	73 0d		 jae	 SHORT $LN45@CON_Respon

; 737  : 			con_scrollup++;

  003ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_scrollup
  003ef	83 c0 01	 add	 eax, 1
  003f2	a3 00 00 00 00	 mov	 DWORD PTR _con_scrollup, eax
$LN45@CON_Respon:

; 738  : 		return true;

  003f7	b8 01 00 00 00	 mov	 eax, 1
  003fc	e9 11 04 00 00	 jmp	 $LN1@CON_Respon

; 739  : 	}

  00401	eb 29		 jmp	 SHORT $LN46@CON_Respon
$LN43@CON_Respon:

; 740  : 	else if (key == KEY_PGDN)

  00403	81 7d f4 ef 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 239 ; 000000efH
  0040a	75 20		 jne	 SHORT $LN46@CON_Respon

; 741  : 	{
; 742  : 		if (con_scrollup > 0)

  0040c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_scrollup, 0
  00413	76 0d		 jbe	 SHORT $LN47@CON_Respon

; 743  : 			con_scrollup--;

  00415	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_scrollup
  0041a	83 e8 01	 sub	 eax, 1
  0041d	a3 00 00 00 00	 mov	 DWORD PTR _con_scrollup, eax
$LN47@CON_Respon:

; 744  : 		return true;

  00422	b8 01 00 00 00	 mov	 eax, 1
  00427	e9 e6 03 00 00	 jmp	 $LN1@CON_Respon
$LN46@CON_Respon:

; 745  : 	}
; 746  : 
; 747  : 	if (key == KEY_HOME) // oldest text in buffer

  0042c	81 7d f4 e5 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 229 ; 000000e5H
  00433	75 25		 jne	 SHORT $LN48@CON_Respon

; 748  : 	{
; 749  : 		con_scrollup = (con_totallines-((con_curlines-16)>>3));

  00435	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_curlines
  0043a	83 e8 10	 sub	 eax, 16			; 00000010H
  0043d	c1 f8 03	 sar	 eax, 3
  00440	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_totallines
  00446	2b c8		 sub	 ecx, eax
  00448	89 0d 00 00 00
	00		 mov	 DWORD PTR _con_scrollup, ecx

; 750  : 		return true;

  0044e	b8 01 00 00 00	 mov	 eax, 1
  00453	e9 ba 03 00 00	 jmp	 $LN1@CON_Respon

; 751  : 	}

  00458	eb 1d		 jmp	 SHORT $LN50@CON_Respon
$LN48@CON_Respon:

; 752  : 	else if (key == KEY_END) // most recent text in buffer

  0045a	81 7d f4 ed 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 237 ; 000000edH
  00461	75 14		 jne	 SHORT $LN50@CON_Respon

; 753  : 	{
; 754  : 		con_scrollup = 0;

  00463	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_scrollup, 0

; 755  : 		return true;

  0046d	b8 01 00 00 00	 mov	 eax, 1
  00472	e9 9b 03 00 00	 jmp	 $LN1@CON_Respon
$LN50@CON_Respon:

; 756  : 	}
; 757  : 
; 758  : 	// command enter
; 759  : 	if (key == KEY_ENTER)

  00477	83 7d f4 0d	 cmp	 DWORD PTR _key$[ebp], 13 ; 0000000dH
  0047b	0f 85 b4 00 00
	00		 jne	 $LN51@CON_Respon

; 760  : 	{
; 761  : 		if (input_cx < 2)

  00481	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _input_cx, 2
  00488	73 0a		 jae	 SHORT $LN52@CON_Respon

; 762  : 			return true;

  0048a	b8 01 00 00 00	 mov	 eax, 1
  0048f	e9 7e 03 00 00	 jmp	 $LN1@CON_Respon
$LN52@CON_Respon:

; 763  : 
; 764  : 		// push the command
; 765  : 		COM_BufAddText(inputlines[inputline]+1);

  00494	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  00499	c1 e0 08	 shl	 eax, 8
  0049c	05 01 00 00 00	 add	 eax, OFFSET _inputlines+1
  004a1	50		 push	 eax
  004a2	e8 00 00 00 00	 call	 _COM_BufAddText
  004a7	83 c4 04	 add	 esp, 4

; 766  : 		COM_BufAddText("\n");

  004aa	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  004af	e8 00 00 00 00	 call	 _COM_BufAddText
  004b4	83 c4 04	 add	 esp, 4

; 767  : 
; 768  : 		CONS_Printf("%s\n", inputlines[inputline]);

  004b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  004bc	c1 e0 08	 shl	 eax, 8
  004bf	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  004c4	50		 push	 eax
  004c5	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  004ca	e8 00 00 00 00	 call	 _CONS_Printf
  004cf	83 c4 08	 add	 esp, 8

; 769  : 
; 770  : 		inputline = (inputline+1) & 31;

  004d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  004d7	83 c0 01	 add	 eax, 1
  004da	83 e0 1f	 and	 eax, 31			; 0000001fH
  004dd	a3 00 00 00 00	 mov	 DWORD PTR _inputline, eax

; 771  : 		inputhist = inputline;

  004e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  004e7	a3 00 00 00 00	 mov	 DWORD PTR _inputhist, eax

; 772  : 
; 773  : 		memset(inputlines[inputline], 0, CON_MAXPROMPTCHARS);

  004ec	68 00 01 00 00	 push	 256			; 00000100H
  004f1	6a 00		 push	 0
  004f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  004f8	c1 e0 08	 shl	 eax, 8
  004fb	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 _memset
  00506	83 c4 0c	 add	 esp, 12			; 0000000cH

; 774  : 		inputlines[inputline][0] = CON_PROMPTCHAR;

  00509	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  0050e	c1 e0 08	 shl	 eax, 8
  00511	b9 01 00 00 00	 mov	 ecx, 1
  00516	6b d1 00	 imul	 edx, ecx, 0
  00519	c6 84 10 00 00
	00 00 3e	 mov	 BYTE PTR _inputlines[eax+edx], 62 ; 0000003eH

; 775  : 		input_cx = 1;

  00521	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _input_cx, 1

; 776  : 
; 777  : 		return true;

  0052b	b8 01 00 00 00	 mov	 eax, 1
  00530	e9 dd 02 00 00	 jmp	 $LN1@CON_Respon
$LN51@CON_Respon:

; 778  : 	}
; 779  : 
; 780  : 	// backspace command prompt
; 781  : 	if (key == KEY_BACKSPACE)

  00535	83 7d f4 08	 cmp	 DWORD PTR _key$[ebp], 8
  00539	75 36		 jne	 SHORT $LN53@CON_Respon

; 782  : 	{
; 783  : 		if (input_cx > 1)

  0053b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _input_cx, 1
  00542	76 23		 jbe	 SHORT $LN54@CON_Respon

; 784  : 		{
; 785  : 			input_cx--;

  00544	a1 00 00 00 00	 mov	 eax, DWORD PTR _input_cx
  00549	83 e8 01	 sub	 eax, 1
  0054c	a3 00 00 00 00	 mov	 DWORD PTR _input_cx, eax

; 786  : 			inputlines[inputline][input_cx] = 0;

  00551	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  00556	c1 e0 08	 shl	 eax, 8
  00559	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  0055f	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR _inputlines[eax+ecx], 0
$LN54@CON_Respon:

; 787  : 		}
; 788  : 		return true;

  00567	b8 01 00 00 00	 mov	 eax, 1
  0056c	e9 a1 02 00 00	 jmp	 $LN1@CON_Respon
$LN53@CON_Respon:

; 789  : 	}
; 790  : 
; 791  : 	// move back in input history
; 792  : 	if (key == KEY_UPARROW)

  00571	81 7d f4 e6 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 230 ; 000000e6H
  00578	0f 85 a7 00 00
	00		 jne	 $LN55@CON_Respon
$LN4@CON_Respon:

; 793  : 	{
; 794  : 		// copy one of the previous inputlines to the current
; 795  : 		do
; 796  : 		{
; 797  : 			inputhist = (inputhist - 1) & 31; // cycle back

  0057e	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  00583	83 e8 01	 sub	 eax, 1
  00586	83 e0 1f	 and	 eax, 31			; 0000001fH
  00589	a3 00 00 00 00	 mov	 DWORD PTR _inputhist, eax

; 798  : 		} while (inputhist != inputline && !inputlines[inputhist][1]);

  0058e	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  00593	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _inputline
  00599	74 1c		 je	 SHORT $LN56@CON_Respon
  0059b	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  005a0	c1 e0 08	 shl	 eax, 8
  005a3	b9 01 00 00 00	 mov	 ecx, 1
  005a8	c1 e1 00	 shl	 ecx, 0
  005ab	0f be 94 08 00
	00 00 00	 movsx	 edx, BYTE PTR _inputlines[eax+ecx]
  005b3	85 d2		 test	 edx, edx
  005b5	74 c7		 je	 SHORT $LN4@CON_Respon
$LN56@CON_Respon:

; 799  : 
; 800  : 		// stop at the last history input line, which is the
; 801  : 		// current line + 1 because we cycle through the 32 input lines
; 802  : 		if (inputhist == inputline)

  005b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  005bc	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _inputline
  005c2	75 10		 jne	 SHORT $LN57@CON_Respon

; 803  : 			inputhist = (inputline + 1) & 31;

  005c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  005c9	83 c0 01	 add	 eax, 1
  005cc	83 e0 1f	 and	 eax, 31			; 0000001fH
  005cf	a3 00 00 00 00	 mov	 DWORD PTR _inputhist, eax
$LN57@CON_Respon:

; 804  : 
; 805  : 		M_Memcpy(inputlines[inputline], inputlines[inputhist], CON_MAXPROMPTCHARS);

  005d4	68 00 01 00 00	 push	 256			; 00000100H
  005d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  005de	c1 e0 08	 shl	 eax, 8
  005e1	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  005e6	50		 push	 eax
  005e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _inputline
  005ed	c1 e1 08	 shl	 ecx, 8
  005f0	81 c1 00 00 00
	00		 add	 ecx, OFFSET _inputlines
  005f6	51		 push	 ecx
  005f7	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  005fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 806  : 		input_cx = strlen(inputlines[inputline]);

  00600	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  00605	c1 e0 08	 shl	 eax, 8
  00608	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  0060d	50		 push	 eax
  0060e	e8 00 00 00 00	 call	 _strlen
  00613	83 c4 04	 add	 esp, 4
  00616	a3 00 00 00 00	 mov	 DWORD PTR _input_cx, eax

; 807  : 
; 808  : 		return true;

  0061b	b8 01 00 00 00	 mov	 eax, 1
  00620	e9 ed 01 00 00	 jmp	 $LN1@CON_Respon
$LN55@CON_Respon:

; 809  : 	}
; 810  : 
; 811  : 	// move forward in input history
; 812  : 	if (key == KEY_DOWNARROW)

  00625	81 7d f4 ee 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 238 ; 000000eeH
  0062c	0f 85 e9 00 00
	00		 jne	 $LN58@CON_Respon

; 813  : 	{
; 814  : 		if (inputhist == inputline)

  00632	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  00637	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _inputline
  0063d	75 0a		 jne	 SHORT $LN59@CON_Respon

; 815  : 			return true;

  0063f	b8 01 00 00 00	 mov	 eax, 1
  00644	e9 c9 01 00 00	 jmp	 $LN1@CON_Respon
$LN59@CON_Respon:

; 816  : 		do
; 817  : 		{
; 818  : 			inputhist = (inputhist + 1) & 31;

  00649	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  0064e	83 c0 01	 add	 eax, 1
  00651	83 e0 1f	 and	 eax, 31			; 0000001fH
  00654	a3 00 00 00 00	 mov	 DWORD PTR _inputhist, eax

; 819  : 		} while (inputhist != inputline && !inputlines[inputhist][1]);

  00659	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  0065e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _inputline
  00664	74 1c		 je	 SHORT $LN60@CON_Respon
  00666	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  0066b	c1 e0 08	 shl	 eax, 8
  0066e	b9 01 00 00 00	 mov	 ecx, 1
  00673	c1 e1 00	 shl	 ecx, 0
  00676	0f be 94 08 00
	00 00 00	 movsx	 edx, BYTE PTR _inputlines[eax+ecx]
  0067e	85 d2		 test	 edx, edx
  00680	74 c7		 je	 SHORT $LN59@CON_Respon
$LN60@CON_Respon:

; 820  : 
; 821  : 		memset(inputlines[inputline], 0, CON_MAXPROMPTCHARS);

  00682	68 00 01 00 00	 push	 256			; 00000100H
  00687	6a 00		 push	 0
  00689	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  0068e	c1 e0 08	 shl	 eax, 8
  00691	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  00696	50		 push	 eax
  00697	e8 00 00 00 00	 call	 _memset
  0069c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 822  : 
; 823  : 		// back to currentline
; 824  : 		if (inputhist == inputline)

  0069f	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  006a4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _inputline
  006aa	75 24		 jne	 SHORT $LN61@CON_Respon

; 825  : 		{
; 826  : 			inputlines[inputline][0] = CON_PROMPTCHAR;

  006ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  006b1	c1 e0 08	 shl	 eax, 8
  006b4	b9 01 00 00 00	 mov	 ecx, 1
  006b9	6b d1 00	 imul	 edx, ecx, 0
  006bc	c6 84 10 00 00
	00 00 3e	 mov	 BYTE PTR _inputlines[eax+edx], 62 ; 0000003eH

; 827  : 			input_cx = 1;

  006c4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _input_cx, 1

; 828  : 		}

  006ce	eb 41		 jmp	 SHORT $LN62@CON_Respon
$LN61@CON_Respon:

; 829  : 		else
; 830  : 		{
; 831  : 			strcpy(inputlines[inputline], inputlines[inputhist]);

  006d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputhist
  006d5	c1 e0 08	 shl	 eax, 8
  006d8	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  006dd	50		 push	 eax
  006de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _inputline
  006e4	c1 e1 08	 shl	 ecx, 8
  006e7	81 c1 00 00 00
	00		 add	 ecx, OFFSET _inputlines
  006ed	51		 push	 ecx
  006ee	e8 00 00 00 00	 call	 _strcpy
  006f3	83 c4 08	 add	 esp, 8

; 832  : 			input_cx = strlen(inputlines[inputline]);

  006f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  006fb	c1 e0 08	 shl	 eax, 8
  006fe	05 00 00 00 00	 add	 eax, OFFSET _inputlines
  00703	50		 push	 eax
  00704	e8 00 00 00 00	 call	 _strlen
  00709	83 c4 04	 add	 esp, 4
  0070c	a3 00 00 00 00	 mov	 DWORD PTR _input_cx, eax
$LN62@CON_Respon:

; 833  : 		}
; 834  : 		return true;

  00711	b8 01 00 00 00	 mov	 eax, 1
  00716	e9 f7 00 00 00	 jmp	 $LN1@CON_Respon
$LN58@CON_Respon:

; 835  : 	}
; 836  : 
; 837  : 	// allow people to use keypad in console (good for typing IP addresses) - Calum
; 838  : 	if (key >= KEY_KEYPAD7 && key <= KEY_KPADDEL)

  0071b	81 7d f4 c7 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 199 ; 000000c7H
  00722	7c 4d		 jl	 SHORT $LN63@CON_Respon
  00724	81 7d f4 d3 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 211 ; 000000d3H
  0072b	7f 44		 jg	 SHORT $LN63@CON_Respon

; 839  : 	{
; 840  : 		XBOXSTATIC char keypad_translation[] = {'7','8','9','-',

  0072d	c6 45 e4 37	 mov	 BYTE PTR _keypad_translation$2[ebp], 55 ; 00000037H
  00731	c6 45 e5 38	 mov	 BYTE PTR _keypad_translation$2[ebp+1], 56 ; 00000038H
  00735	c6 45 e6 39	 mov	 BYTE PTR _keypad_translation$2[ebp+2], 57 ; 00000039H
  00739	c6 45 e7 2d	 mov	 BYTE PTR _keypad_translation$2[ebp+3], 45 ; 0000002dH
  0073d	c6 45 e8 34	 mov	 BYTE PTR _keypad_translation$2[ebp+4], 52 ; 00000034H
  00741	c6 45 e9 35	 mov	 BYTE PTR _keypad_translation$2[ebp+5], 53 ; 00000035H
  00745	c6 45 ea 36	 mov	 BYTE PTR _keypad_translation$2[ebp+6], 54 ; 00000036H
  00749	c6 45 eb 2b	 mov	 BYTE PTR _keypad_translation$2[ebp+7], 43 ; 0000002bH
  0074d	c6 45 ec 31	 mov	 BYTE PTR _keypad_translation$2[ebp+8], 49 ; 00000031H
  00751	c6 45 ed 32	 mov	 BYTE PTR _keypad_translation$2[ebp+9], 50 ; 00000032H
  00755	c6 45 ee 33	 mov	 BYTE PTR _keypad_translation$2[ebp+10], 51 ; 00000033H
  00759	c6 45 ef 30	 mov	 BYTE PTR _keypad_translation$2[ebp+11], 48 ; 00000030H
  0075d	c6 45 f0 2e	 mov	 BYTE PTR _keypad_translation$2[ebp+12], 46 ; 0000002eH

; 841  : 		                                        '4','5','6','+',
; 842  : 		                                        '1','2','3',
; 843  : 		                                        '0','.'};
; 844  : 
; 845  : 		key = keypad_translation[key - KEY_KEYPAD7];

  00761	8b 45 f4	 mov	 eax, DWORD PTR _key$[ebp]
  00764	0f be 8c 05 1d
	ff ff ff	 movsx	 ecx, BYTE PTR _keypad_translation$2[ebp+eax-199]
  0076c	89 4d f4	 mov	 DWORD PTR _key$[ebp], ecx

; 846  : 	}

  0076f	eb 10		 jmp	 SHORT $LN65@CON_Respon
$LN63@CON_Respon:

; 847  : 	else if (key == KEY_KPADSLASH)

  00771	81 7d f4 e4 00
	00 00		 cmp	 DWORD PTR _key$[ebp], 228 ; 000000e4H
  00778	75 07		 jne	 SHORT $LN65@CON_Respon

; 848  : 		key = '/';

  0077a	c7 45 f4 2f 00
	00 00		 mov	 DWORD PTR _key$[ebp], 47 ; 0000002fH
$LN65@CON_Respon:

; 849  : 
; 850  : 	if (shiftdown)

  00781	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?shiftdown@?1??CON_Responder@@9@9, 0
  00788	74 0e		 je	 SHORT $LN66@CON_Respon

; 851  : 		key = shiftxform[key];

  0078a	a1 00 00 00 00	 mov	 eax, DWORD PTR _shiftxform
  0078f	03 45 f4	 add	 eax, DWORD PTR _key$[ebp]
  00792	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00795	89 4d f4	 mov	 DWORD PTR _key$[ebp], ecx
$LN66@CON_Respon:

; 852  : 
; 853  : 	// enter a char into the command prompt
; 854  : 	if (key < 32 || key > 127)

  00798	83 7d f4 20	 cmp	 DWORD PTR _key$[ebp], 32 ; 00000020H
  0079c	7c 06		 jl	 SHORT $LN68@CON_Respon
  0079e	83 7d f4 7f	 cmp	 DWORD PTR _key$[ebp], 127 ; 0000007fH
  007a2	7e 04		 jle	 SHORT $LN67@CON_Respon
$LN68@CON_Respon:

; 855  : 		return false;

  007a4	33 c0		 xor	 eax, eax
  007a6	eb 6a		 jmp	 SHORT $LN1@CON_Respon
$LN67@CON_Respon:

; 856  : 
; 857  : 	// add key to cmd line here
; 858  : 	if (input_cx < CON_MAXPROMPTCHARS)

  007a8	81 3d 00 00 00
	00 00 01 00 00	 cmp	 DWORD PTR _input_cx, 256 ; 00000100H
  007b2	73 59		 jae	 SHORT $LN69@CON_Respon

; 859  : 	{
; 860  : 		if (key >= 'A' && key <= 'Z' && !shiftdown) //this is only really necessary for dedicated servers

  007b4	83 7d f4 41	 cmp	 DWORD PTR _key$[ebp], 65 ; 00000041H
  007b8	7c 18		 jl	 SHORT $LN70@CON_Respon
  007ba	83 7d f4 5a	 cmp	 DWORD PTR _key$[ebp], 90 ; 0000005aH
  007be	7f 12		 jg	 SHORT $LN70@CON_Respon
  007c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?shiftdown@?1??CON_Responder@@9@9, 0
  007c7	75 09		 jne	 SHORT $LN70@CON_Respon

; 861  : 			key = key + 'a' - 'A';

  007c9	8b 45 f4	 mov	 eax, DWORD PTR _key$[ebp]
  007cc	83 c0 20	 add	 eax, 32			; 00000020H
  007cf	89 45 f4	 mov	 DWORD PTR _key$[ebp], eax
$LN70@CON_Respon:

; 862  : 
; 863  : 		inputlines[inputline][input_cx] = (char)key;

  007d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  007d7	c1 e0 08	 shl	 eax, 8
  007da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  007e0	8a 55 f4	 mov	 dl, BYTE PTR _key$[ebp]
  007e3	88 94 08 00 00
	00 00		 mov	 BYTE PTR _inputlines[eax+ecx], dl

; 864  : 		inputlines[inputline][input_cx + 1] = 0;

  007ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _inputline
  007ef	c1 e0 08	 shl	 eax, 8
  007f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_cx
  007f8	c6 84 08 01 00
	00 00 00	 mov	 BYTE PTR _inputlines[eax+ecx+1], 0

; 865  : 		input_cx++;

  00800	a1 00 00 00 00	 mov	 eax, DWORD PTR _input_cx
  00805	83 c0 01	 add	 eax, 1
  00808	a3 00 00 00 00	 mov	 DWORD PTR _input_cx, eax
$LN69@CON_Respon:

; 866  : 	}
; 867  : 
; 868  : 	return true;

  0080d	b8 01 00 00 00	 mov	 eax, 1
$LN1@CON_Respon:

; 869  : }

  00812	5f		 pop	 edi
  00813	5e		 pop	 esi
  00814	5b		 pop	 ebx
  00815	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00818	33 cd		 xor	 ecx, ebp
  0081a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0081f	8b e5		 mov	 esp, ebp
  00821	5d		 pop	 ebp
  00822	c3		 ret	 0
_CON_Responder ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CON_Init
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CON_Init PROC						; COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 346  : 	INT32 i;
; 347  : 
; 348  : 	for (i = 0; i < NUMINPUTS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CON_Init
$LN2@CON_Init:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CON_Init:
  0001b	81 7d fc e4 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 484	; 000001e4H
  00022	7d 10		 jge	 SHORT $LN3@CON_Init

; 349  : 		bindtable[i] = NULL;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00027	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _bindtable[eax*4], 0
  00032	eb de		 jmp	 SHORT $LN2@CON_Init
$LN3@CON_Init:

; 350  : 
; 351  : 	// clear all lines
; 352  : 	memset(con_buffer, 0, CON_BUFFERSIZE);

  00034	68 00 40 00 00	 push	 16384			; 00004000H
  00039	6a 00		 push	 0
  0003b	68 00 00 00 00	 push	 OFFSET _con_buffer
  00040	e8 00 00 00 00	 call	 _memset
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 353  : 
; 354  : 	// make sure it is ready for the loading screen
; 355  : 	con_width = 0;

  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_width, 0

; 356  : 	CON_RecalcSize();

  00052	e8 00 00 00 00	 call	 _CON_RecalcSize
  00057	90		 npad	 1

; 357  : 
; 358  : 	CON_SetupBackColormap();

  00058	e8 00 00 00 00	 call	 _CON_SetupBackColormap
  0005d	90		 npad	 1

; 359  : 
; 360  : 	//note: CON_Ticker should always execute at least once before D_Display()
; 361  : 	con_clipviewtop = -1; // -1 does not clip

  0005e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _con_clipviewtop, -1

; 362  : 
; 363  : 	con_hudlines = atoi(cons_hudlines.defaultvalue);

  00068	a1 04 00 00 00	 mov	 eax, DWORD PTR _cons_hudlines+4
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _atoi
  00073	83 c4 04	 add	 esp, 4
  00076	a3 00 00 00 00	 mov	 DWORD PTR _con_hudlines, eax

; 364  : 
; 365  : 	// setup console input filtering
; 366  : 	CON_InputInit();

  0007b	e8 00 00 00 00	 call	 _CON_InputInit
  00080	90		 npad	 1

; 367  : 
; 368  : 	// load console background pic
; 369  : 	con_backpic = (patch_t *)W_CacheLumpName("CONSBACK",PU_STATIC);

  00081	6a 01		 push	 1
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_08PALAOBIJ@CONSBACK@
  00088	e8 00 00 00 00	 call	 _W_CacheLumpName
  0008d	83 c4 08	 add	 esp, 8
  00090	a3 00 00 00 00	 mov	 DWORD PTR _con_backpic, eax

; 370  : 
; 371  : 	// register our commands
; 372  : 	//
; 373  : 	COM_AddCommand("cls", CONS_Clear_f);

  00095	68 00 00 00 00	 push	 OFFSET _CONS_Clear_f
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_03LCPHGAHP@cls@
  0009f	e8 00 00 00 00	 call	 _COM_AddCommand
  000a4	83 c4 08	 add	 esp, 8

; 374  : 	COM_AddCommand("english", CONS_English_f);

  000a7	68 00 00 00 00	 push	 OFFSET _CONS_English_f
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_07CNNBJDHA@english@
  000b1	e8 00 00 00 00	 call	 _COM_AddCommand
  000b6	83 c4 08	 add	 esp, 8

; 375  : 	// set console full screen for game startup MAKE SURE VID_Init() done !!!
; 376  : 	con_destlines = vid.height;

  000b9	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  000be	a3 00 00 00 00	 mov	 DWORD PTR _con_destlines, eax

; 377  : 	con_curlines = vid.height;

  000c3	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  000c8	a3 00 00 00 00	 mov	 DWORD PTR _con_curlines, eax

; 378  : 
; 379  : 
; 380  : 	if (!dedicated)

  000cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  000d4	0f 85 80 00 00
	00		 jne	 $LN5@CON_Init

; 381  : 	{
; 382  : 		con_started = true;

  000da	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _con_started, 1

; 383  : 		con_startup = true; // need explicit screen refresh until we are in Doom loop

  000e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _con_startup, 1

; 384  : 		consoletoggle = false;

  000ee	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _consoletoggle, 0

; 385  : 		CV_RegisterVar(&cons_msgtimeout);

  000f8	68 00 00 00 00	 push	 OFFSET _cons_msgtimeout
  000fd	e8 00 00 00 00	 call	 _CV_RegisterVar
  00102	83 c4 04	 add	 esp, 4

; 386  : 		CV_RegisterVar(&cons_hudlines);

  00105	68 00 00 00 00	 push	 OFFSET _cons_hudlines
  0010a	e8 00 00 00 00	 call	 _CV_RegisterVar
  0010f	83 c4 04	 add	 esp, 4

; 387  : 		CV_RegisterVar(&cons_speed);

  00112	68 00 00 00 00	 push	 OFFSET _cons_speed
  00117	e8 00 00 00 00	 call	 _CV_RegisterVar
  0011c	83 c4 04	 add	 esp, 4

; 388  : 		CV_RegisterVar(&cons_height);

  0011f	68 00 00 00 00	 push	 OFFSET _cons_height
  00124	e8 00 00 00 00	 call	 _CV_RegisterVar
  00129	83 c4 04	 add	 esp, 4

; 389  : 		CV_RegisterVar(&cons_backpic);

  0012c	68 00 00 00 00	 push	 OFFSET _cons_backpic
  00131	e8 00 00 00 00	 call	 _CV_RegisterVar
  00136	83 c4 04	 add	 esp, 4

; 390  : 		CV_RegisterVar(&cons_backcolor);

  00139	68 00 00 00 00	 push	 OFFSET _cons_backcolor
  0013e	e8 00 00 00 00	 call	 _CV_RegisterVar
  00143	83 c4 04	 add	 esp, 4

; 391  : 		COM_AddCommand("bind", CONS_Bind_f);

  00146	68 00 00 00 00	 push	 OFFSET _CONS_Bind_f
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_04NPNJNMMP@bind@
  00150	e8 00 00 00 00	 call	 _COM_AddCommand
  00155	83 c4 08	 add	 esp, 8

; 392  : 	}

  00158	eb 1e		 jmp	 SHORT $LN6@CON_Init
$LN5@CON_Init:

; 393  : 	else
; 394  : 	{
; 395  : 		con_started = true;

  0015a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _con_started, 1

; 396  : 		con_startup = false; // need explicit screen refresh until we are in Doom loop

  00164	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_startup, 0

; 397  : 		consoletoggle = true;

  0016e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _consoletoggle, 1
$LN6@CON_Init:

; 398  : 	}
; 399  : }

  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
_CON_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\console.c
;	COMDAT _CONS_Printf
_TEXT	SEGMENT
_txt$ = -8200						; size = 8192
_argptr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_fmt$ = 8						; size = 4
_CONS_Printf PROC					; COMDAT

; 1012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 22 00 00	 mov	 eax, 8712		; 00002208H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 1013 : 	va_list argptr;
; 1014 : 	XBOXSTATIC char txt[8192];
; 1015 : 
; 1016 : 	va_start(argptr, fmt);

  0001a	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0001d	89 45 f8	 mov	 DWORD PTR _argptr$[ebp], eax

; 1017 : 	vsprintf(txt, fmt, argptr);

  00020	8b 45 f8	 mov	 eax, DWORD PTR _argptr$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00027	51		 push	 ecx
  00028	8d 95 f8 df ff
	ff		 lea	 edx, DWORD PTR _txt$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 _vsprintf
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1018 : 	va_end(argptr);

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _argptr$[ebp], 0

; 1019 : 
; 1020 : 	// echo console prints to log file
; 1021 : #ifndef _arch_dreamcast
; 1022 : 	DEBFILE(txt);

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00045	74 23		 je	 SHORT $LN2@CONS_Print
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0004c	50		 push	 eax
  0004d	8d 8d f8 df ff
	ff		 lea	 ecx, DWORD PTR _txt$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _fputs
  00059	83 c4 08	 add	 esp, 8
  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _fflush
  00067	83 c4 04	 add	 esp, 4
$LN2@CONS_Print:

; 1023 : #endif
; 1024 : 
; 1025 : 	if (!con_started)

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_started, 0
  00071	75 02		 jne	 SHORT $LN3@CONS_Print

; 1026 : 	{
; 1027 : #if defined (_XBOX) && defined (__GNUC__)
; 1028 : 		if (!keyboard_started) debugPrint(txt);
; 1029 : #endif
; 1030 : #ifdef PC_DOS
; 1031 : 		CON_LogMessage(txt);
; 1032 : 		return;
; 1033 : #endif
; 1034 : 	}

  00073	eb 0f		 jmp	 SHORT $LN4@CONS_Print
$LN3@CONS_Print:

; 1035 : 	else
; 1036 : 		// write message in con text buffer
; 1037 : 		CON_Print(txt);

  00075	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _CON_Print
  00081	83 c4 04	 add	 esp, 4
$LN4@CONS_Print:

; 1038 : 
; 1039 : #ifndef PC_DOS
; 1040 : 	CON_LogMessage(txt);

  00084	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _CON_LogMessage
  00090	83 c4 04	 add	 esp, 4

; 1041 : #endif
; 1042 : 
; 1043 : 	// make sure new text is visible
; 1044 : 	con_scrollup = 0;

  00093	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_scrollup, 0

; 1045 : 
; 1046 : 	// if not in display loop, force screen update
; 1047 : 	if (con_startup)

  0009d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_startup, 0
  000a4	74 26		 je	 SHORT $LN5@CONS_Print

; 1048 : 	{
; 1049 : #if (defined (_WINDOWS)) || (defined (__OS2__) && !defined (SDL))
; 1050 : 		// show startup screen and message using only 'software' graphics
; 1051 : 		// (rendermode may be hardware accelerated, but the video mode is not set yet)
; 1052 : 		CON_DrawBackpic(con_backpic, 0, vid.width); // put console background

  000a6	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000ab	50		 push	 eax
  000ac	6a 00		 push	 0
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_backpic
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _CON_DrawBackpic
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1053 : 		I_LoadingScreen(txt);

  000bd	8d 85 f8 df ff
	ff		 lea	 eax, DWORD PTR _txt$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _I_LoadingScreen
  000c9	83 c4 04	 add	 esp, 4
$LN5@CONS_Print:

; 1054 : #else
; 1055 : 		// here we display the console background and console text
; 1056 : 		// (no hardware accelerated support for these versions)
; 1057 : 		CON_Drawer();
; 1058 : 		I_FinishUpdate(); // page flip or blit buffer
; 1059 : #endif
; 1060 : 	}
; 1061 : }

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d2	33 cd		 xor	 ecx, ebp
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_CONS_Printf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1474 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1475 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
