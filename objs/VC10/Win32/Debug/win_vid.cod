; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\win_vid.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_specialmodes
PUBLIC	_cv_vidwait
PUBLIC	_rendermode
PUBLIC	??_C@_05DHPMCAIC@Never@				; `string'
PUBLIC	??_C@_03GCDBBDDL@Off@				; `string'
PUBLIC	??_C@_02IAAGKKDJ@On@				; `string'
PUBLIC	??_C@_08BDPHNIKO@vid_wait@			; `string'
PUBLIC	??_C@_07LEPFLFDH@stretch@			; `string'
PUBLIC	??_C@_05BJHEOINP@ontop@				; `string'
EXTRN	_CV_OnOff:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_highcolor:DWORD
_DATA	ENDS
;	COMDAT ??_C@_05BJHEOINP@ontop@
CONST	SEGMENT
??_C@_05BJHEOINP@ontop@ DB 'ontop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEPFLFDH@stretch@
CONST	SEGMENT
??_C@_07LEPFLFDH@stretch@ DB 'stretch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BDPHNIKO@vid_wait@
CONST	SEGMENT
??_C@_08BDPHNIKO@vid_wait@ DB 'vid_wait', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DHPMCAIC@Never@
CONST	SEGMENT
??_C@_05DHPMCAIC@Never@ DB 'Never', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_specialmodes DD 00H
	DD	FLAT:_winmode1
	DD	0140H
	DD	0c8H
	DD	0140H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	FLAT:_VID_SetWindowedDisplayMode@8
	DD	00H
	DD	00H
	DD	FLAT:_winmode2
	DD	0280H
	DD	0190H
	DD	0280H
	DD	01H
	DD	01H
	DD	02H
	DD	00H
	DD	FLAT:_VID_SetWindowedDisplayMode@8
	DD	00H
_cv_vidwait DD	FLAT:??_C@_08BDPHNIKO@vid_wait@
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	FLAT:_OnTop_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_rendermode DD	01H
_CV_NeverOnOff DD 0ffffffffH
	DD	FLAT:??_C@_05DHPMCAIC@Never@
	DD	00H
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	00H
	DD	00H
_winmode1 DB	'320x200W', 00H
	ORG $+3
_winmode2 DB	'640x400W', 00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_I_StartupGraphics
PUBLIC	_I_ShutdownGraphics
PUBLIC	_I_SetPalette
PUBLIC	_VID_NumModes
PUBLIC	_VID_GetModeForSize
PUBLIC	_VID_SetMode
PUBLIC	_VID_GetModeName
PUBLIC	_I_UpdateNoBlit
PUBLIC	_I_FinishUpdate
PUBLIC	_I_UpdateNoVsync
PUBLIC	_I_ReadScreen
PUBLIC	_I_LoadingScreen
PUBLIC	??_C@_07IAIJOHNP@?9opengl@			; `string'
PUBLIC	??_C@_0BG@MLPCPEFM@I_ShutdownGraphics?$CI?$CJ?6@ ; `string'
PUBLIC	??_C@_0L@CMLCODLF@FPS?3?5?$CFd?1?$CFu@		; `string'
PUBLIC	??_C@_0DA@KBOMMIFH@I_ReadScreen?3?5called?5while?5in?5n@ ; `string'
PUBLIC	??_C@_0BH@PNEOILDK@mode?5?$CFd?5x?5?$CFd?5x?5?$CFd?5bpp?6@ ; `string'
PUBLIC	??_C@_0BJ@EBEHACAA@mode?5skipped?5?$CItoo?5many?$CJ?6@ ; `string'
PUBLIC	??_C@_07JILPJHEE@?$CF4dx?$CF4d@			; `string'
PUBLIC	??_C@_07JNPAIBMB@?$CF4dx?$CF3d@			; `string'
PUBLIC	??_C@_07FNBIKJMK@?$CF3dx?$CF4d@			; `string'
PUBLIC	??_C@_07FIFHLPEP@?$CF3dx?$CF3d@			; `string'
PUBLIC	??_C@_06EGEBBOP@?9width@			; `string'
PUBLIC	??_C@_04EKBMMNPE@?9win@				; `string'
PUBLIC	??_C@_0N@DMEBCDJH@vid_nummodes@			; `string'
PUBLIC	??_C@_0N@JFLAADMP@vid_modeinfo@			; `string'
PUBLIC	??_C@_0N@HDFMBOAH@vid_modelist@			; `string'
PUBLIC	??_C@_08ICHJJAPN@vid_mode@			; `string'
PUBLIC	??_C@_0N@PBCLHOFP@r_opengl?4dll@		; `string'
PUBLIC	??_C@_0BN@IMOKCPEI@Unknown?5hardware?5render?5mode@ ; `string'
PUBLIC	??_C@_0EL@LGEPIIFI@WARNING?3?5This?5r_opengl?5version?5@ ; `string'
PUBLIC	??_C@_0BK@CGJIEHBD@Error?5initializing?5OpenGL@	; `string'
PUBLIC	??_C@_0EH@BDGLHHIM@Cannot?5run?5in?5highcolor?5?9?5No?515@ ; `string'
PUBLIC	??_C@_0BM@CBHGFNBK@No?5display?5modes?5available?4@ ; `string'
PUBLIC	??_C@_0CB@MHJFAOJC@?$CD?$CF02d?3?5?$CFdx?$CFdx?$CFdbpp?5?$CIdesc?3?5?8?$CFs?8?$CJ@ ; `string'
PUBLIC	??_C@_0BD@HEOCAMLO@VID_SWDM?$CI?$CJ?3?5No?5mem@	; `string'
PUBLIC	??_C@_0BJ@BKPKBPAG@VID_SWDM?$CI?$CJ?3?5GetDC?5FAILED@ ; `string'
PUBLIC	??_C@_0CA@EOJIJPFH@VID_error?3?5No?5video?5mode?5found?6@ ; `string'
PUBLIC	??_C@_0BP@EDOALGEF@VID_error?3?5Mode?5not?5available?6@ ; `string'
PUBLIC	??_C@_0BB@KNDMGALM@VID_SetMode?$CI?$CFd?$CJ?6@	; `string'
PUBLIC	??_C@_0BI@EKIJDNMH@Unknown?5video?5mode?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CA@NGDGMNIC@Not?5enough?5mem?5for?5VID_SetMode?6@ ; `string'
PUBLIC	??_C@_0DE@POJIHOK@Couldn?8t?5set?5video?5mode?5because@ ; `string'
PUBLIC	??_C@_0DH@LAELGJLA@Couldn?8t?5set?5video?5mode?5because@ ; `string'
PUBLIC	??_C@_0CM@ODHFEKKC@Couldn?8t?5set?5video?5mode?5?$CFd?5?$CI?$CFdx@ ; `string'
PUBLIC	??_C@_0BJ@JIGKODNM@Mode?5changed?5to?5?$CFd?5?$CI?$CFs?$CJ?6@ ; `string'
PUBLIC	??_C@_0BP@MEPMMKEL@?$CFd?5video?5mode?$CIs?$CJ?5available?$CIs?$CJ?6@ ; `string'
PUBLIC	??_C@_0BE@CDAICPIH@No?5such?5video?5mode?6@	; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BG@EPIJCCGN@width?3?5?$CFd?6height?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0DJ@LCDFHGPM@bytes?5per?5scanline?3?5?$CFd?6bytes?5pe@ ; `string'
PUBLIC	??_C@_07LCGEOBC@?$CFd?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BC@LPDHNBAA@?$CFd?3?5?$CFs?5?$CIhicolor?$CJ?6@ ; `string'
PUBLIC	??_C@_0CF@JADPPDDK@vid_mode?5?$DMmodenum?$DO?5?3?5set?5video?5@ ; `string'
PUBLIC	__real@3f200000
PUBLIC	__real@3fcccccd
EXTRN	_memset:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__SetBkMode@8:PROC
EXTRN	__imp__SetDIBitsToDevice@48:PROC
EXTRN	__imp__SetTextColor@8:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__MoveWindow@24:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__DrawTextA@20:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__AdjustWindowRectEx@16:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	_atoi:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_COM_AddCommand:PROC
EXTRN	_COM_Argc:PROC
EXTRN	_COM_Argv:PROC
EXTRN	_CV_RegisterVar:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_I_GetTime:PROC
EXTRN	_I_AddExitFunc:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_V_DrawString:PROC
EXTRN	_V_StringWidth:PROC
EXTRN	_VID_BlitLinearScreen:PROC
EXTRN	_EnumDirectDrawDisplayModes:PROC
EXTRN	_CreateDirectDrawInstance:PROC
EXTRN	_InitDirectDrawe:PROC
EXTRN	_CloseDirectDraw:PROC
EXTRN	_ReleaseChtuff:PROC
EXTRN	_ScreenFlip:PROC
EXTRN	_SetDDPalette:PROC
EXTRN	_LockScreen:PROC
EXTRN	_UnlockScreen:PROC
EXTRN	_I_RestartSysMouse:PROC
EXTRN	_Init3DDriver:PROC
EXTRN	_Shutdown3DDriver:PROC
EXTRN	_HWR_Startup:PROC
EXTRN	_HWR_Shutdown:PROC
EXTRN	_HWR_drawAMline:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_devparm:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_graphics_started:BYTE
EXTRN	_vid:BYTE
EXTRN	_setmodeneeded:DWORD
EXTRN	_cv_scr_width:BYTE
EXTRN	_cv_scr_height:BYTE
EXTRN	_cv_scr_depth:BYTE
EXTRN	_cv_fullscreen:BYTE
EXTRN	_screens:BYTE
EXTRN	_cv_ticrate:BYTE
EXTRN	_bAppFullScreen:DWORD
EXTRN	_ScreenHeight:DWORD
EXTRN	_ScreenPitch:DWORD
EXTRN	_ScreenPtr:DWORD
EXTRN	_paused:BYTE
EXTRN	_hWndMain:DWORD
EXTRN	_hwdriver:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_bDIBMode DD	01H DUP (?)
_bmiMain DD	01H DUP (?)
_hDCMain DD	01H DUP (?)
_extra_modes DB	0528H DUP (?)
_names	DB	012cH DUP (?)
_numvidmodes DD	01H DUP (?)
_pvidmodes DD	01H DUP (?)
_pcurrentmode DD 01H DUP (?)
_bWinParm DD	01H DUP (?)
_fpsgraph DD	023H DUP (?)
?lasttic@?1??displayticrate@@9@9 DD 01H DUP (?)		; `displayticrate'::`2'::lasttic
?skip@?1??I_SkipFrame@@9@9 DD 01H DUP (?)		; `I_SkipFrame'::`2'::skip
_nummodes DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3fcccccd
CONST	SEGMENT
__real@3fcccccd DD 03fcccccdr			; 1.6
CONST	ENDS
;	COMDAT __real@3f200000
CONST	SEGMENT
__real@3f200000 DD 03f200000r			; 0.625
CONST	ENDS
;	COMDAT ??_C@_0CF@JADPPDDK@vid_mode?5?$DMmodenum?$DO?5?3?5set?5video?5@
CONST	SEGMENT
??_C@_0CF@JADPPDDK@vid_mode?5?$DMmodenum?$DO?5?3?5set?5video?5@ DB 'vid_m'
	DB	'ode <modenum> : set video mode', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LPDHNBAA@?$CFd?3?5?$CFs?5?$CIhicolor?$CJ?6@
CONST	SEGMENT
??_C@_0BC@LPDHNBAA@?$CFd?3?5?$CFs?5?$CIhicolor?$CJ?6@ DB '%d: %s (hicolor'
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCGEOBC@?$CFd?3?5?$CFs?6@
CONST	SEGMENT
??_C@_07LCGEOBC@?$CFd?3?5?$CFs?6@ DB '%d: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LCDFHGPM@bytes?5per?5scanline?3?5?$CFd?6bytes?5pe@
CONST	SEGMENT
??_C@_0DJ@LCDFHGPM@bytes?5per?5scanline?3?5?$CFd?6bytes?5pe@ DB 'bytes pe'
	DB	'r scanline: %d', 0aH, 'bytes per pixel: %d', 0aH, 'numpages: '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EPIJCCGN@width?3?5?$CFd?6height?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BG@EPIJCCGN@width?3?5?$CFd?6height?3?5?$CFd?6@ DB 'width: %d', 0aH
	DB	'height: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CDAICPIH@No?5such?5video?5mode?6@
CONST	SEGMENT
??_C@_0BE@CDAICPIH@No?5such?5video?5mode?6@ DB 'No such video mode', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MEPMMKEL@?$CFd?5video?5mode?$CIs?$CJ?5available?$CIs?$CJ?6@
CONST	SEGMENT
??_C@_0BP@MEPMMKEL@?$CFd?5video?5mode?$CIs?$CJ?5available?$CIs?$CJ?6@ DB '%'
	DB	'd video mode(s) available(s)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JIGKODNM@Mode?5changed?5to?5?$CFd?5?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0BJ@JIGKODNM@Mode?5changed?5to?5?$CFd?5?$CI?$CFs?$CJ?6@ DB 'Mode ch'
	DB	'anged to %d (%s)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ODHFEKKC@Couldn?8t?5set?5video?5mode?5?$CFd?5?$CI?$CFdx@
CONST	SEGMENT
??_C@_0CM@ODHFEKKC@Couldn?8t?5set?5video?5mode?5?$CFd?5?$CI?$CFdx@ DB 'Co'
	DB	'uldn''t set video mode %d (%dx%d %d bits)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@LAELGJLA@Couldn?8t?5set?5video?5mode?5because@
CONST	SEGMENT
??_C@_0DH@LAELGJLA@Couldn?8t?5set?5video?5mode?5because@ DB 'Couldn''t se'
	DB	't video mode because it failed the change?', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@POJIHOK@Couldn?8t?5set?5video?5mode?5because@
CONST	SEGMENT
??_C@_0DE@POJIHOK@Couldn?8t?5set?5video?5mode?5because@ DB 'Couldn''t set'
	DB	' video mode because it failed the test', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NGDGMNIC@Not?5enough?5mem?5for?5VID_SetMode?6@
CONST	SEGMENT
??_C@_0CA@NGDGMNIC@Not?5enough?5mem?5for?5VID_SetMode?6@ DB 'Not enough m'
	DB	'em for VID_SetMode', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKIJDNMH@Unknown?5video?5mode?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@EKIJDNMH@Unknown?5video?5mode?3?5?$CFd?6@ DB 'Unknown video mod'
	DB	'e: %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KNDMGALM@VID_SetMode?$CI?$CFd?$CJ?6@
CONST	SEGMENT
??_C@_0BB@KNDMGALM@VID_SetMode?$CI?$CFd?$CJ?6@ DB 'VID_SetMode(%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EDOALGEF@VID_error?3?5Mode?5not?5available?6@
CONST	SEGMENT
??_C@_0BP@EDOALGEF@VID_error?3?5Mode?5not?5available?6@ DB 'VID_error: Mo'
	DB	'de not available', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EOJIJPFH@VID_error?3?5No?5video?5mode?5found?6@
CONST	SEGMENT
??_C@_0CA@EOJIJPFH@VID_error?3?5No?5video?5mode?5found?6@ DB 'VID_error: '
	DB	'No video mode found', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BKPKBPAG@VID_SWDM?$CI?$CJ?3?5GetDC?5FAILED@
CONST	SEGMENT
??_C@_0BJ@BKPKBPAG@VID_SWDM?$CI?$CJ?3?5GetDC?5FAILED@ DB 'VID_SWDM(): Get'
	DB	'DC FAILED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HEOCAMLO@VID_SWDM?$CI?$CJ?3?5No?5mem@
CONST	SEGMENT
??_C@_0BD@HEOCAMLO@VID_SWDM?$CI?$CJ?3?5No?5mem@ DB 'VID_SWDM(): No mem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MHJFAOJC@?$CD?$CF02d?3?5?$CFdx?$CFdx?$CFdbpp?5?$CIdesc?3?5?8?$CFs?8?$CJ@
CONST	SEGMENT
??_C@_0CB@MHJFAOJC@?$CD?$CF02d?3?5?$CFdx?$CFdx?$CFdbpp?5?$CIdesc?3?5?8?$CFs?8?$CJ@ DB '#'
	DB	'%02d: %dx%dx%dbpp (desc: ''%s'')', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CBHGFNBK@No?5display?5modes?5available?4@
CONST	SEGMENT
??_C@_0BM@CBHGFNBK@No?5display?5modes?5available?4@ DB 'No display modes '
	DB	'available.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@BDGLHHIM@Cannot?5run?5in?5highcolor?5?9?5No?515@
CONST	SEGMENT
??_C@_0EH@BDGLHHIM@Cannot?5run?5in?5highcolor?5?9?5No?515@ DB 'Cannot run'
	DB	' in highcolor - No 15bit highcolor DirectX video mode found.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CGJIEHBD@Error?5initializing?5OpenGL@
CONST	SEGMENT
??_C@_0BK@CGJIEHBD@Error?5initializing?5OpenGL@ DB 'Error initializing Op'
	DB	'enGL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LGEPIIFI@WARNING?3?5This?5r_opengl?5version?5@
CONST	SEGMENT
??_C@_0EL@LGEPIIFI@WARNING?3?5This?5r_opengl?5version?5@ DB 'WARNING: Thi'
	DB	's r_opengl version is not supported, use it at your own risk.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IMOKCPEI@Unknown?5hardware?5render?5mode@
CONST	SEGMENT
??_C@_0BN@IMOKCPEI@Unknown?5hardware?5render?5mode@ DB 'Unknown hardware '
	DB	'render mode', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBCLHOFP@r_opengl?4dll@
CONST	SEGMENT
??_C@_0N@PBCLHOFP@r_opengl?4dll@ DB 'r_opengl.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICHJJAPN@vid_mode@
CONST	SEGMENT
??_C@_08ICHJJAPN@vid_mode@ DB 'vid_mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HDFMBOAH@vid_modelist@
CONST	SEGMENT
??_C@_0N@HDFMBOAH@vid_modelist@ DB 'vid_modelist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFLAADMP@vid_modeinfo@
CONST	SEGMENT
??_C@_0N@JFLAADMP@vid_modeinfo@ DB 'vid_modeinfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DMEBCDJH@vid_nummodes@
CONST	SEGMENT
??_C@_0N@DMEBCDJH@vid_nummodes@ DB 'vid_nummodes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKBMMNPE@?9win@
CONST	SEGMENT
??_C@_04EKBMMNPE@?9win@ DB '-win', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGEBBOP@?9width@
CONST	SEGMENT
??_C@_06EGEBBOP@?9width@ DB '-width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FIFHLPEP@?$CF3dx?$CF3d@
CONST	SEGMENT
??_C@_07FIFHLPEP@?$CF3dx?$CF3d@ DB '%3dx%3d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FNBIKJMK@?$CF3dx?$CF4d@
CONST	SEGMENT
??_C@_07FNBIKJMK@?$CF3dx?$CF4d@ DB '%3dx%4d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNPAIBMB@?$CF4dx?$CF3d@
CONST	SEGMENT
??_C@_07JNPAIBMB@?$CF4dx?$CF3d@ DB '%4dx%3d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JILPJHEE@?$CF4dx?$CF4d@
CONST	SEGMENT
??_C@_07JILPJHEE@?$CF4dx?$CF4d@ DB '%4dx%4d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EBEHACAA@mode?5skipped?5?$CItoo?5many?$CJ?6@
CONST	SEGMENT
??_C@_0BJ@EBEHACAA@mode?5skipped?5?$CItoo?5many?$CJ?6@ DB 'mode skipped ('
	DB	'too many)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PNEOILDK@mode?5?$CFd?5x?5?$CFd?5x?5?$CFd?5bpp?6@
CONST	SEGMENT
??_C@_0BH@PNEOILDK@mode?5?$CFd?5x?5?$CFd?5x?5?$CFd?5bpp?6@ DB 'mode %d x '
	DB	'%d x %d bpp', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KBOMMIFH@I_ReadScreen?3?5called?5while?5in?5n@
CONST	SEGMENT
??_C@_0DA@KBOMMIFH@I_ReadScreen?3?5called?5while?5in?5n@ DB 'I_ReadScreen'
	DB	': called while in non-software mode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMLCODLF@FPS?3?5?$CFd?1?$CFu@
CONST	SEGMENT
??_C@_0L@CMLCODLF@FPS?3?5?$CFd?1?$CFu@ DB 'FPS: %d/%u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MLPCPEFM@I_ShutdownGraphics?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BG@MLPCPEFM@I_ShutdownGraphics?$CI?$CJ?6@ DB 'I_ShutdownGraphics()'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07IAIJOHNP@?9opengl@
CONST	SEGMENT
??_C@_07IAIJOHNP@?9opengl@ DB '-opengl', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
_cv_stretch DD	FLAT:??_C@_07LEPFLFDH@stretch@
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	0201H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_ontop DD	FLAT:??_C@_05BJHEOINP@ontop@
	DD	FLAT:??_C@_05DHPMCAIC@Never@
	DD	00H
	DD	FLAT:_CV_NeverOnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02f6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01e3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0105H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0d5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	011eH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _WindowMode_Init
_TEXT	SEGMENT
_reqx$ = -4						; size = 4
_WindowMode_Init PROC					; COMDAT

; 695  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 696  : 	int reqx = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _reqx$[ebp], 0

; 697  : 
; 698  : 	specialmodes[NUMSPECIALMODES-1].pnext = pvidmodes;

  00010	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00015	6b c8 00	 imul	 ecx, eax, 0
  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pvidmodes
  0001e	89 91 00 00 00
	00		 mov	 DWORD PTR _specialmodes[ecx], edx

; 699  : 
; 700  : 	if (M_CheckParm("-width") && M_IsNextParm())

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_06EGEBBOP@?9width@
  00029	e8 00 00 00 00	 call	 _M_CheckParm
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 1a		 je	 SHORT $LN2@WindowMode
  00035	e8 00 00 00 00	 call	 _M_IsNextParm
  0003a	85 c0		 test	 eax, eax
  0003c	74 11		 je	 SHORT $LN2@WindowMode

; 701  : 		reqx = atoi(M_GetNextParm());

  0003e	e8 00 00 00 00	 call	 _M_GetNextParm
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _atoi
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 fc	 mov	 DWORD PTR _reqx$[ebp], eax
$LN2@WindowMode:

; 702  : 
; 703  : 	if (reqx > BASEVIDWIDTH)

  0004f	81 7d fc 40 01
	00 00		 cmp	 DWORD PTR _reqx$[ebp], 320 ; 00000140H
  00056	7e 14		 jle	 SHORT $LN3@WindowMode

; 704  : 		pvidmodes = &specialmodes[1];

  00058	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  0005d	c1 e0 00	 shl	 eax, 0
  00060	05 00 00 00 00	 add	 eax, OFFSET _specialmodes
  00065	a3 00 00 00 00	 mov	 DWORD PTR _pvidmodes, eax
  0006a	eb 14		 jmp	 SHORT $LN4@WindowMode
$LN3@WindowMode:

; 705  : 	else
; 706  : 		pvidmodes = &specialmodes[0];

  0006c	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00071	6b c8 00	 imul	 ecx, eax, 0
  00074	81 c1 00 00 00
	00		 add	 ecx, OFFSET _specialmodes
  0007a	89 0d 00 00 00
	00		 mov	 DWORD PTR _pvidmodes, ecx
$LN4@WindowMode:

; 707  : 
; 708  : 	numvidmodes += NUMSPECIALMODES;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR _numvidmodes
  00085	83 c0 01	 add	 eax, 1
  00088	a3 00 00 00 00	 mov	 DWORD PTR _numvidmodes, eax

; 709  : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_WindowMode_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_GetExtraModes
_TEXT	SEGMENT
_VID_GetExtraModes PROC					; COMDAT

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 677  : 	nummodes = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nummodes, 0

; 678  : 	EnumDirectDrawDisplayModes(GetExtraModesCallback);

  00013	68 00 00 00 00	 push	 OFFSET _GetExtraModesCallback
  00018	e8 00 00 00 00	 call	 _EnumDirectDrawDisplayModes
  0001d	83 c4 04	 add	 esp, 4

; 679  : 
; 680  : 	// add the extra modes (not 320x200) at the start of the mode list (if there are any)
; 681  : 	if (nummodes)

  00020	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nummodes, 0
  00027	74 39		 je	 SHORT $LN2@VID_GetExt

; 682  : 	{
; 683  : 		extra_modes[nummodes-1].pnext = NULL;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _nummodes
  0002e	83 e8 01	 sub	 eax, 1
  00031	6b c8 2c	 imul	 ecx, eax, 44
  00034	c7 81 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _extra_modes[ecx], 0

; 684  : 		pvidmodes = &extra_modes[0];

  0003e	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00043	6b c8 00	 imul	 ecx, eax, 0
  00046	81 c1 00 00 00
	00		 add	 ecx, OFFSET _extra_modes
  0004c	89 0d 00 00 00
	00		 mov	 DWORD PTR _pvidmodes, ecx

; 685  : 		numvidmodes += nummodes;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _numvidmodes
  00057	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nummodes
  0005d	a3 00 00 00 00	 mov	 DWORD PTR _numvidmodes, eax
$LN2@VID_GetExt:

; 686  : 	}
; 687  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_VID_GetExtraModes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _GetExtraModesCallback
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_bpp$ = 16						; size = 4
_GetExtraModesCallback PROC				; COMDAT

; 603  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 604  : 	CONS_Printf("mode %d x %d x %d bpp\n", width, height, bpp);

  00009	8b 45 10	 mov	 eax, DWORD PTR _bpp$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _width$[ebp]
  00014	52		 push	 edx
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PNEOILDK@mode?5?$CFd?5x?5?$CFd?5x?5?$CFd?5bpp?6@
  0001a	e8 00 00 00 00	 call	 _CONS_Printf
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 605  : 
; 606  : 	// skip all unwanted modes
; 607  : 	if (highcolor && bpp != 15)

  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _highcolor, 0
  00029	74 0b		 je	 SHORT $LN2@GetExtraMo
  0002b	83 7d 10 0f	 cmp	 DWORD PTR _bpp$[ebp], 15 ; 0000000fH
  0002f	74 05		 je	 SHORT $LN2@GetExtraMo

; 608  : 		goto skip;

  00031	e9 6b 02 00 00	 jmp	 $skip$14
$LN2@GetExtraMo:

; 609  : 	if (!highcolor && bpp != 8)

  00036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _highcolor, 0
  0003d	75 0b		 jne	 SHORT $LN3@GetExtraMo
  0003f	83 7d 10 08	 cmp	 DWORD PTR _bpp$[ebp], 8
  00043	74 05		 je	 SHORT $LN3@GetExtraMo

; 610  : 		goto skip;

  00045	e9 57 02 00 00	 jmp	 $skip$14
$LN3@GetExtraMo:

; 611  : 
; 612  : 	if (bpp > 16 || width > MAXVIDWIDTH || height > MAXVIDHEIGHT)

  0004a	83 7d 10 10	 cmp	 DWORD PTR _bpp$[ebp], 16 ; 00000010H
  0004e	7f 12		 jg	 SHORT $LN5@GetExtraMo
  00050	81 7d 08 80 07
	00 00		 cmp	 DWORD PTR _width$[ebp], 1920 ; 00000780H
  00057	7f 09		 jg	 SHORT $LN5@GetExtraMo
  00059	81 7d 0c b0 04
	00 00		 cmp	 DWORD PTR _height$[ebp], 1200 ; 000004b0H
  00060	7e 05		 jle	 SHORT $LN4@GetExtraMo
$LN5@GetExtraMo:

; 613  : 		goto skip;

  00062	e9 3a 02 00 00	 jmp	 $skip$14
$LN4@GetExtraMo:

; 614  : 
; 615  : 	// check if we have space for this mode
; 616  : 	if (nummodes >= MAX_EXTRA_MODES)

  00067	83 3d 00 00 00
	00 1e		 cmp	 DWORD PTR _nummodes, 30	; 0000001eH
  0006e	7c 14		 jl	 SHORT $LN6@GetExtraMo

; 617  : 	{
; 618  : 		CONS_Printf("mode skipped (too many)\n");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EBEHACAA@mode?5skipped?5?$CItoo?5many?$CJ?6@
  00075	e8 00 00 00 00	 call	 _CONS_Printf
  0007a	83 c4 04	 add	 esp, 4

; 619  : 		return FALSE;

  0007d	33 c0		 xor	 eax, eax
  0007f	e9 22 02 00 00	 jmp	 $LN1@GetExtraMo
$LN6@GetExtraMo:

; 620  : 	}
; 621  : 
; 622  : 	// store mode info
; 623  : 	extra_modes[nummodes].pnext = &extra_modes[nummodes+1];

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _nummodes
  00089	83 c0 01	 add	 eax, 1
  0008c	6b c8 2c	 imul	 ecx, eax, 44
  0008f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _extra_modes
  00095	6b 15 00 00 00
	00 2c		 imul	 edx, DWORD PTR _nummodes, 44
  0009c	89 8a 00 00 00
	00		 mov	 DWORD PTR _extra_modes[edx], ecx

; 624  : 	if (width > 999)

  000a2	81 7d 08 e7 03
	00 00		 cmp	 DWORD PTR _width$[ebp], 999 ; 000003e7H
  000a9	0f 8e 96 00 00
	00		 jle	 $LN7@GetExtraMo

; 625  : 	{
; 626  : 		if (height > 999)

  000af	81 7d 0c e7 03
	00 00		 cmp	 DWORD PTR _height$[ebp], 999 ; 000003e7H
  000b6	7e 45		 jle	 SHORT $LN9@GetExtraMo

; 627  : 		{
; 628  : 			sprintf(&names[nummodes][0], "%4dx%4d", width, height);

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  000bf	51		 push	 ecx
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_07JILPJHEE@?$CF4dx?$CF4d@
  000c5	6b 15 00 00 00
	00 0a		 imul	 edx, DWORD PTR _nummodes, 10
  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	6b c8 00	 imul	 ecx, eax, 0
  000d4	8d 94 0a 00 00
	00 00		 lea	 edx, DWORD PTR _names[edx+ecx]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 _sprintf
  000e1	83 c4 10	 add	 esp, 16			; 00000010H

; 629  : 			names[nummodes][9] = 0;

  000e4	6b 05 00 00 00
	00 0a		 imul	 eax, DWORD PTR _nummodes, 10
  000eb	b9 01 00 00 00	 mov	 ecx, 1
  000f0	6b d1 09	 imul	 edx, ecx, 9
  000f3	c6 84 10 00 00
	00 00 00	 mov	 BYTE PTR _names[eax+edx], 0

; 630  : 		}

  000fb	eb 43		 jmp	 SHORT $LN10@GetExtraMo
$LN9@GetExtraMo:

; 631  : 		else
; 632  : 		{
; 633  : 			sprintf(&names[nummodes][0], "%4dx%3d", width, height);

  000fd	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  00100	50		 push	 eax
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  00104	51		 push	 ecx
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_07JNPAIBMB@?$CF4dx?$CF3d@
  0010a	6b 15 00 00 00
	00 0a		 imul	 edx, DWORD PTR _nummodes, 10
  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	6b c8 00	 imul	 ecx, eax, 0
  00119	8d 94 0a 00 00
	00 00		 lea	 edx, DWORD PTR _names[edx+ecx]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _sprintf
  00126	83 c4 10	 add	 esp, 16			; 00000010H

; 634  : 			names[nummodes][8] = 0;

  00129	6b 05 00 00 00
	00 0a		 imul	 eax, DWORD PTR _nummodes, 10
  00130	b9 01 00 00 00	 mov	 ecx, 1
  00135	c1 e1 03	 shl	 ecx, 3
  00138	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR _names[eax+ecx], 0
$LN10@GetExtraMo:

; 635  : 		}
; 636  : 	}

  00140	e9 91 00 00 00	 jmp	 $LN12@GetExtraMo
$LN7@GetExtraMo:

; 637  : 	else
; 638  : 	{
; 639  : 		if (height > 999)

  00145	81 7d 0c e7 03
	00 00		 cmp	 DWORD PTR _height$[ebp], 999 ; 000003e7H
  0014c	7e 45		 jle	 SHORT $LN11@GetExtraMo

; 640  : 		{
; 641  : 			sprintf(&names[nummodes][0], "%3dx%4d", width, height);

  0014e	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  00151	50		 push	 eax
  00152	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  00155	51		 push	 ecx
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_07FNBIKJMK@?$CF3dx?$CF4d@
  0015b	6b 15 00 00 00
	00 0a		 imul	 edx, DWORD PTR _nummodes, 10
  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	6b c8 00	 imul	 ecx, eax, 0
  0016a	8d 94 0a 00 00
	00 00		 lea	 edx, DWORD PTR _names[edx+ecx]
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 _sprintf
  00177	83 c4 10	 add	 esp, 16			; 00000010H

; 642  : 			names[nummodes][8] = 0;

  0017a	6b 05 00 00 00
	00 0a		 imul	 eax, DWORD PTR _nummodes, 10
  00181	b9 01 00 00 00	 mov	 ecx, 1
  00186	c1 e1 03	 shl	 ecx, 3
  00189	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR _names[eax+ecx], 0

; 643  : 		}

  00191	eb 43		 jmp	 SHORT $LN12@GetExtraMo
$LN11@GetExtraMo:

; 644  : 		else
; 645  : 		{
; 646  : 			sprintf(&names[nummodes][0], "%3dx%3d", width, height);

  00193	8b 45 0c	 mov	 eax, DWORD PTR _height$[ebp]
  00196	50		 push	 eax
  00197	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  0019a	51		 push	 ecx
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_07FIFHLPEP@?$CF3dx?$CF3d@
  001a0	6b 15 00 00 00
	00 0a		 imul	 edx, DWORD PTR _nummodes, 10
  001a7	b8 01 00 00 00	 mov	 eax, 1
  001ac	6b c8 00	 imul	 ecx, eax, 0
  001af	8d 94 0a 00 00
	00 00		 lea	 edx, DWORD PTR _names[edx+ecx]
  001b6	52		 push	 edx
  001b7	e8 00 00 00 00	 call	 _sprintf
  001bc	83 c4 10	 add	 esp, 16			; 00000010H

; 647  : 			names[nummodes][7] = 0;

  001bf	6b 05 00 00 00
	00 0a		 imul	 eax, DWORD PTR _nummodes, 10
  001c6	b9 01 00 00 00	 mov	 ecx, 1
  001cb	6b d1 07	 imul	 edx, ecx, 7
  001ce	c6 84 10 00 00
	00 00 00	 mov	 BYTE PTR _names[eax+edx], 0
$LN12@GetExtraMo:

; 648  : 		}
; 649  : 	}
; 650  : 
; 651  : 	extra_modes[nummodes].name = &names[nummodes][0];

  001d6	6b 05 00 00 00
	00 0a		 imul	 eax, DWORD PTR _nummodes, 10
  001dd	b9 01 00 00 00	 mov	 ecx, 1
  001e2	6b d1 00	 imul	 edx, ecx, 0
  001e5	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR _names[eax+edx]
  001ec	6b 0d 00 00 00
	00 2c		 imul	 ecx, DWORD PTR _nummodes, 44
  001f3	89 81 04 00 00
	00		 mov	 DWORD PTR _extra_modes[ecx+4], eax

; 652  : 	extra_modes[nummodes].width = width;

  001f9	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00200	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  00203	89 88 08 00 00
	00		 mov	 DWORD PTR _extra_modes[eax+8], ecx

; 653  : 	extra_modes[nummodes].height = height;

  00209	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00210	8b 4d 0c	 mov	 ecx, DWORD PTR _height$[ebp]
  00213	89 88 0c 00 00
	00		 mov	 DWORD PTR _extra_modes[eax+12], ecx

; 654  : 
; 655  : 	// exactly, the current FinishUdpate() gets the rowbytes itself after locking the video buffer
; 656  : 	// so for now we put anything here
; 657  : 	extra_modes[nummodes].rowbytes = width;

  00219	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00220	8b 4d 08	 mov	 ecx, DWORD PTR _width$[ebp]
  00223	89 88 10 00 00
	00		 mov	 DWORD PTR _extra_modes[eax+16], ecx

; 658  : 	extra_modes[nummodes].windowed = false;

  00229	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00230	c7 80 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _extra_modes[eax+24], 0

; 659  : 	extra_modes[nummodes].misc = 0; // unused

  0023a	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00241	c7 80 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _extra_modes[eax+40], 0

; 660  : 	extra_modes[nummodes].pextradata = NULL;

  0024b	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00252	c7 80 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR _extra_modes[eax+32], 0

; 661  : 	extra_modes[nummodes].setmode = VID_SetDirectDrawMode;

  0025c	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00263	c7 80 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR _extra_modes[eax+36], OFFSET _VID_SetDirectDrawMode@8

; 662  : 
; 663  : 	extra_modes[nummodes].numpages = 2; // double-buffer (but this value is unused)

  0026d	6b 05 00 00 00
	00 2c		 imul	 eax, DWORD PTR _nummodes, 44
  00274	c7 80 1c 00 00
	00 02 00 00 00	 mov	 DWORD PTR _extra_modes[eax+28], 2

; 664  : 
; 665  : 	extra_modes[nummodes].bytesperpixel = (bpp+1)>>3;

  0027e	8b 45 10	 mov	 eax, DWORD PTR _bpp$[ebp]
  00281	83 c0 01	 add	 eax, 1
  00284	c1 f8 03	 sar	 eax, 3
  00287	6b 0d 00 00 00
	00 2c		 imul	 ecx, DWORD PTR _nummodes, 44
  0028e	89 81 14 00 00
	00		 mov	 DWORD PTR _extra_modes[ecx+20], eax

; 666  : 
; 667  : 	nummodes++;

  00294	a1 00 00 00 00	 mov	 eax, DWORD PTR _nummodes
  00299	83 c0 01	 add	 eax, 1
  0029c	a3 00 00 00 00	 mov	 DWORD PTR _nummodes, eax
$skip$14:

; 668  : skip:
; 669  : 	return TRUE;

  002a1	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetExtraMo:

; 670  : }

  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
_GetExtraModesCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_SkipFrame
_TEXT	SEGMENT
tv66 = -68						; size = 4
tv67 = -68						; size = 4
_I_SkipFrame PROC					; COMDAT

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 368  : 	static boolean skip = false;
; 369  : 
; 370  : 	if (render_soft != rendermode)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 04		 je	 SHORT $LN4@I_SkipFram

; 371  : 		return false;

  00012	33 c0		 xor	 eax, eax
  00014	eb 55		 jmp	 SHORT $LN2@I_SkipFram
$LN4@I_SkipFram:

; 372  : 
; 373  : 	skip = !skip;

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?skip@?1??I_SkipFrame@@9@9, 0
  0001d	75 09		 jne	 SHORT $LN11@I_SkipFram
  0001f	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN12@I_SkipFram
$LN11@I_SkipFram:
  00028	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN12@I_SkipFram:
  0002f	8b 45 bc	 mov	 eax, DWORD PTR tv66[ebp]
  00032	a3 00 00 00 00	 mov	 DWORD PTR ?skip@?1??I_SkipFrame@@9@9, eax

; 374  : 	switch (gamestate)

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _gamestate
  0003c	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
  0003f	83 7d bc 01	 cmp	 DWORD PTR tv67[ebp], 1
  00043	74 0e		 je	 SHORT $LN5@I_SkipFram
  00045	83 7d bc 0b	 cmp	 DWORD PTR tv67[ebp], 11	; 0000000bH
  00049	74 17		 je	 SHORT $LN6@I_SkipFram
  0004b	83 7d bc 0d	 cmp	 DWORD PTR tv67[ebp], 13	; 0000000dH
  0004f	74 11		 je	 SHORT $LN6@I_SkipFram
  00051	eb 16		 jmp	 SHORT $LN9@I_SkipFram
$LN5@I_SkipFram:

; 375  : 	{
; 376  : 		case GS_LEVEL:
; 377  : 			if (!paused)

  00053	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  0005a	85 c0		 test	 eax, eax
  0005c	75 04		 jne	 SHORT $LN6@I_SkipFram

; 378  : 				return false;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 09		 jmp	 SHORT $LN2@I_SkipFram
$LN6@I_SkipFram:

; 379  : 		case GS_TIMEATTACK:
; 380  : 		case GS_WAITINGPLAYERS:
; 381  : 			return skip; // Skip odd frames

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?skip@?1??I_SkipFrame@@9@9
  00067	eb 02		 jmp	 SHORT $LN2@I_SkipFram
$LN9@I_SkipFram:

; 382  : 		default:
; 383  : 			return false;

  00069	33 c0		 xor	 eax, eax
$LN2@I_SkipFram:

; 384  : 	}
; 385  : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_I_SkipFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _displayticrate
_TEXT	SEGMENT
_p$1 = -56						; size = 16
_k$2 = -40						; size = 4
_s$3 = -36						; size = 11
_t$ = -24						; size = 4
_tics$ = -20						; size = 4
_i$ = -16						; size = 4
_l$ = -12						; size = 4
_j$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_displayticrate PROC					; COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 293  : 	int j,l,i;
; 294  : 	static tic_t lasttic;
; 295  : 	tic_t tics,t;
; 296  : 
; 297  : 	t = I_GetTime();

  00013	e8 00 00 00 00	 call	 _I_GetTime
  00018	89 45 e8	 mov	 DWORD PTR _t$[ebp], eax

; 298  : 	tics = (t - lasttic)/NEWTICRATERATIO;

  0001b	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  0001e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?lasttic@?1??displayticrate@@9@9
  00024	89 45 ec	 mov	 DWORD PTR _tics$[ebp], eax

; 299  : 	lasttic = t;

  00027	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?lasttic@?1??displayticrate@@9@9, eax

; 300  : 	if (tics > OLDTICRATE) tics = OLDTICRATE;

  0002f	83 7d ec 23	 cmp	 DWORD PTR _tics$[ebp], 35 ; 00000023H
  00033	76 07		 jbe	 SHORT $LN26@displaytic
  00035	c7 45 ec 23 00
	00 00		 mov	 DWORD PTR _tics$[ebp], 35 ; 00000023H
$LN26@displaytic:

; 301  : 
; 302  : 	for (i=0;i<OLDTICRATE-1;i++)

  0003c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN4@displaytic
$LN2@displaytic:
  00045	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@displaytic:
  0004e	83 7d f0 22	 cmp	 DWORD PTR _i$[ebp], 34	; 00000022H
  00052	7d 16		 jge	 SHORT $LN3@displaytic

; 303  : 		fpsgraph[i]=fpsgraph[i+1];

  00054	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  0005a	8b 14 8d 04 00
	00 00		 mov	 edx, DWORD PTR _fpsgraph[ecx*4+4]
  00061	89 14 85 00 00
	00 00		 mov	 DWORD PTR _fpsgraph[eax*4], edx
  00068	eb db		 jmp	 SHORT $LN2@displaytic
$LN3@displaytic:

; 304  : 	fpsgraph[OLDTICRATE-1]=OLDTICRATE-tics;

  0006a	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  0006f	2b 45 ec	 sub	 eax, DWORD PTR _tics$[ebp]
  00072	b9 04 00 00 00	 mov	 ecx, 4
  00077	6b d1 22	 imul	 edx, ecx, 34
  0007a	89 82 00 00 00
	00		 mov	 DWORD PTR _fpsgraph[edx], eax

; 305  : 
; 306  : 	if (value == 1 || value == 3)

  00080	83 7d 08 01	 cmp	 DWORD PTR _value$[ebp], 1
  00084	74 06		 je	 SHORT $LN28@displaytic
  00086	83 7d 08 03	 cmp	 DWORD PTR _value$[ebp], 3
  0008a	75 49		 jne	 SHORT $LN27@displaytic
$LN28@displaytic:

; 307  : 	{
; 308  : 		char s[11];
; 309  : 		sprintf(s, "FPS: %d/%u", OLDTICRATE-tics+1, OLDTICRATE);

  0008c	6a 23		 push	 35			; 00000023H
  0008e	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  00093	2b 45 ec	 sub	 eax, DWORD PTR _tics$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CMLCODLF@FPS?3?5?$CFd?1?$CFu@
  0009f	8d 4d dc	 lea	 ecx, DWORD PTR _s$3[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _sprintf
  000a8	83 c4 10	 add	 esp, 16			; 00000010H

; 310  : 		V_DrawString(BASEVIDWIDTH - V_StringWidth(s), BASEVIDHEIGHT-ST_HEIGHT+24, V_YELLOWMAP, s);

  000ab	8d 45 dc	 lea	 eax, DWORD PTR _s$3[ebp]
  000ae	50		 push	 eax
  000af	68 00 00 10 00	 push	 1048576			; 00100000H
  000b4	68 c0 00 00 00	 push	 192			; 000000c0H
  000b9	8d 4d dc	 lea	 ecx, DWORD PTR _s$3[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 _V_StringWidth
  000c2	83 c4 04	 add	 esp, 4
  000c5	ba 40 01 00 00	 mov	 edx, 320		; 00000140H
  000ca	2b d0		 sub	 edx, eax
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _V_DrawString
  000d2	83 c4 10	 add	 esp, 16			; 00000010H
$LN27@displaytic:

; 311  : 	}
; 312  : 	if (value == 1)

  000d5	83 7d 08 01	 cmp	 DWORD PTR _value$[ebp], 1
  000d9	75 05		 jne	 SHORT $LN29@displaytic

; 313  : 		return;

  000db	e9 13 02 00 00	 jmp	 $LN24@displaytic
$LN29@displaytic:

; 314  : 
; 315  : 	if (rendermode == render_soft)

  000e0	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000e7	0f 85 08 01 00
	00		 jne	 $LN30@displaytic

; 316  : 	{
; 317  : 		int k;
; 318  : 		// draw dots
; 319  : 		for (j=0;j<=OLDTICRATE*SCALE*vid.dupy;j+=2*SCALE*vid.dupy)

  000ed	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000f4	eb 0d		 jmp	 SHORT $LN7@displaytic
$LN5@displaytic:
  000f6	6b 05 24 00 00
	00 06		 imul	 eax, DWORD PTR _vid+36, 6
  000fd	03 45 f8	 add	 eax, DWORD PTR _j$[ebp]
  00100	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@displaytic:
  00103	6b 05 24 00 00
	00 69		 imul	 eax, DWORD PTR _vid+36, 105
  0010a	39 45 f8	 cmp	 DWORD PTR _j$[ebp], eax
  0010d	7f 5a		 jg	 SHORT $LN6@displaytic

; 320  : 		{
; 321  : 			l=(vid.height-1-j)*vid.width*vid.bpp;

  0010f	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00114	83 e8 01	 sub	 eax, 1
  00117	2b 45 f8	 sub	 eax, DWORD PTR _j$[ebp]
  0011a	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00121	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  00128	89 45 f4	 mov	 DWORD PTR _l$[ebp], eax

; 322  : 			for (i=0;i<OLDTICRATE*SCALE*vid.dupx;i+=2*SCALE*vid.dupx)

  0012b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00132	eb 0d		 jmp	 SHORT $LN10@displaytic
$LN8@displaytic:
  00134	6b 05 20 00 00
	00 06		 imul	 eax, DWORD PTR _vid+32, 6
  0013b	03 45 f0	 add	 eax, DWORD PTR _i$[ebp]
  0013e	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN10@displaytic:
  00141	6b 05 20 00 00
	00 69		 imul	 eax, DWORD PTR _vid+32, 105
  00148	39 45 f0	 cmp	 DWORD PTR _i$[ebp], eax
  0014b	7d 1a		 jge	 SHORT $LN9@displaytic

; 323  : 				screens[0][l+i]=0xff;

  0014d	b8 04 00 00 00	 mov	 eax, 4
  00152	6b c8 00	 imul	 ecx, eax, 0
  00155	8b 55 f4	 mov	 edx, DWORD PTR _l$[ebp]
  00158	03 55 f0	 add	 edx, DWORD PTR _i$[ebp]
  0015b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  00161	c6 04 10 ff	 mov	 BYTE PTR [eax+edx], 255	; 000000ffH
  00165	eb cd		 jmp	 SHORT $LN8@displaytic
$LN9@displaytic:

; 324  : 		}

  00167	eb 8d		 jmp	 SHORT $LN5@displaytic
$LN6@displaytic:

; 325  : 
; 326  : 		// draw the graph
; 327  : 		for (i=0;i<OLDTICRATE;i++)

  00169	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00170	eb 09		 jmp	 SHORT $LN13@displaytic
$LN11@displaytic:
  00172	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00175	83 c0 01	 add	 eax, 1
  00178	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN13@displaytic:
  0017b	83 7d f0 23	 cmp	 DWORD PTR _i$[ebp], 35	; 00000023H
  0017f	7d 6f		 jge	 SHORT $LN12@displaytic

; 328  : 			for (k=0;k<SCALE*vid.dupx;k++)

  00181	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _k$2[ebp], 0
  00188	eb 09		 jmp	 SHORT $LN16@displaytic
$LN14@displaytic:
  0018a	8b 45 d8	 mov	 eax, DWORD PTR _k$2[ebp]
  0018d	83 c0 01	 add	 eax, 1
  00190	89 45 d8	 mov	 DWORD PTR _k$2[ebp], eax
$LN16@displaytic:
  00193	6b 05 20 00 00
	00 03		 imul	 eax, DWORD PTR _vid+32, 3
  0019a	39 45 d8	 cmp	 DWORD PTR _k$2[ebp], eax
  0019d	7d 4f		 jge	 SHORT $LN15@displaytic

; 329  : 				PUTDOT(i*SCALE*vid.dupx+k, vid.height-1-(fpsgraph[i]*SCALE*vid.dupy),0xff);

  0019f	b8 04 00 00 00	 mov	 eax, 4
  001a4	6b c8 00	 imul	 ecx, eax, 0
  001a7	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  001ad	83 ea 01	 sub	 edx, 1
  001b0	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001b3	6b 04 85 00 00
	00 00 03	 imul	 eax, DWORD PTR _fpsgraph[eax*4], 3
  001bb	0f af 05 24 00
	00 00		 imul	 eax, DWORD PTR _vid+36
  001c2	2b d0		 sub	 edx, eax
  001c4	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  001cb	6b 45 f0 03	 imul	 eax, DWORD PTR _i$[ebp], 3
  001cf	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  001d6	03 55 d8	 add	 edx, DWORD PTR _k$2[ebp]
  001d9	03 c2		 add	 eax, edx
  001db	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  001e2	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[ecx]
  001e8	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH
  001ec	eb 9c		 jmp	 SHORT $LN14@displaytic
$LN15@displaytic:
  001ee	eb 82		 jmp	 SHORT $LN11@displaytic
$LN12@displaytic:

; 330  : 	}

  001f0	e9 fe 00 00 00	 jmp	 $LN24@displaytic
$LN30@displaytic:

; 331  : #ifdef HWRENDER
; 332  : 	else
; 333  : 	{
; 334  : 		fline_t p;
; 335  : 		for (j=0;j<=OLDTICRATE*SCALE*vid.dupy;j+=2*SCALE*vid.dupy)

  001f5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  001fc	eb 0d		 jmp	 SHORT $LN19@displaytic
$LN17@displaytic:
  001fe	6b 05 24 00 00
	00 06		 imul	 eax, DWORD PTR _vid+36, 6
  00205	03 45 f8	 add	 eax, DWORD PTR _j$[ebp]
  00208	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN19@displaytic:
  0020b	6b 05 24 00 00
	00 69		 imul	 eax, DWORD PTR _vid+36, 105
  00212	39 45 f8	 cmp	 DWORD PTR _j$[ebp], eax
  00215	7f 60		 jg	 SHORT $LN18@displaytic

; 336  : 		{
; 337  : 			l=(vid.height-1-j);

  00217	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0021c	83 e8 01	 sub	 eax, 1
  0021f	2b 45 f8	 sub	 eax, DWORD PTR _j$[ebp]
  00222	89 45 f4	 mov	 DWORD PTR _l$[ebp], eax

; 338  : 			for (i=0;i<OLDTICRATE*SCALE*vid.dupx;i+=2*SCALE*vid.dupx)

  00225	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0022c	eb 0d		 jmp	 SHORT $LN22@displaytic
$LN20@displaytic:
  0022e	6b 05 20 00 00
	00 06		 imul	 eax, DWORD PTR _vid+32, 6
  00235	03 45 f0	 add	 eax, DWORD PTR _i$[ebp]
  00238	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN22@displaytic:
  0023b	6b 05 20 00 00
	00 69		 imul	 eax, DWORD PTR _vid+32, 105
  00242	39 45 f0	 cmp	 DWORD PTR _i$[ebp], eax
  00245	7d 2e		 jge	 SHORT $LN21@displaytic

; 339  : 			{
; 340  : 				p.a.x = i;

  00247	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0024a	89 45 c8	 mov	 DWORD PTR _p$1[ebp], eax

; 341  : 				p.a.y = l;

  0024d	8b 45 f4	 mov	 eax, DWORD PTR _l$[ebp]
  00250	89 45 cc	 mov	 DWORD PTR _p$1[ebp+4], eax

; 342  : 				p.b.x = i+1;

  00253	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00256	83 c0 01	 add	 eax, 1
  00259	89 45 d0	 mov	 DWORD PTR _p$1[ebp+8], eax

; 343  : 				p.b.y = l;

  0025c	8b 45 f4	 mov	 eax, DWORD PTR _l$[ebp]
  0025f	89 45 d4	 mov	 DWORD PTR _p$1[ebp+12], eax

; 344  : 				HWR_drawAMline(&p, 0xff);

  00262	68 ff 00 00 00	 push	 255			; 000000ffH
  00267	8d 45 c8	 lea	 eax, DWORD PTR _p$1[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _HWR_drawAMline
  00270	83 c4 08	 add	 esp, 8

; 345  : 			}

  00273	eb b9		 jmp	 SHORT $LN20@displaytic
$LN21@displaytic:

; 346  : 		}

  00275	eb 87		 jmp	 SHORT $LN17@displaytic
$LN18@displaytic:

; 347  : 
; 348  : 		for (i=1;i<OLDTICRATE;i++)

  00277	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0027e	eb 09		 jmp	 SHORT $LN25@displaytic
$LN23@displaytic:
  00280	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00283	83 c0 01	 add	 eax, 1
  00286	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN25@displaytic:
  00289	83 7d f0 23	 cmp	 DWORD PTR _i$[ebp], 35	; 00000023H
  0028d	7d 64		 jge	 SHORT $LN24@displaytic

; 349  : 		{
; 350  : 			p.a.x = SCALE * (i-1);

  0028f	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00292	83 e8 01	 sub	 eax, 1
  00295	6b c8 03	 imul	 ecx, eax, 3
  00298	89 4d c8	 mov	 DWORD PTR _p$1[ebp], ecx

; 351  : 			p.a.y = vid.height-1-fpsgraph[i-1]*SCALE*vid.dupy;

  0029b	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  002a0	83 e8 01	 sub	 eax, 1
  002a3	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  002a6	6b 14 8d fc ff
	ff ff 03	 imul	 edx, DWORD PTR _fpsgraph[ecx*4-4], 3
  002ae	0f af 15 24 00
	00 00		 imul	 edx, DWORD PTR _vid+36
  002b5	2b c2		 sub	 eax, edx
  002b7	89 45 cc	 mov	 DWORD PTR _p$1[ebp+4], eax

; 352  : 			p.b.x = SCALE * i;

  002ba	6b 45 f0 03	 imul	 eax, DWORD PTR _i$[ebp], 3
  002be	89 45 d0	 mov	 DWORD PTR _p$1[ebp+8], eax

; 353  : 			p.b.y = vid.height-1-fpsgraph[i]*SCALE*vid.dupy;

  002c1	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  002c6	83 e8 01	 sub	 eax, 1
  002c9	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  002cc	6b 14 8d 00 00
	00 00 03	 imul	 edx, DWORD PTR _fpsgraph[ecx*4], 3
  002d4	0f af 15 24 00
	00 00		 imul	 edx, DWORD PTR _vid+36
  002db	2b c2		 sub	 eax, edx
  002dd	89 45 d4	 mov	 DWORD PTR _p$1[ebp+12], eax

; 354  : 			HWR_drawAMline(&p, 0xff);

  002e0	68 ff 00 00 00	 push	 255			; 000000ffH
  002e5	8d 45 c8	 lea	 eax, DWORD PTR _p$1[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _HWR_drawAMline
  002ee	83 c4 08	 add	 esp, 8

; 355  : 		}

  002f1	eb 8d		 jmp	 SHORT $LN23@displaytic
$LN24@displaytic:

; 356  : 	}
; 357  : #endif
; 358  : }

  002f3	5f		 pop	 edi
  002f4	5e		 pop	 esi
  002f5	5b		 pop	 ebx
  002f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f9	33 cd		 xor	 ecx, ebp
  002fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c3		 ret	 0
_displayticrate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_FreeAndAllocVidbuffer
_TEXT	SEGMENT
_vidbuffersize$ = -4					; size = 4
_lvid$ = 8						; size = 4
_VID_FreeAndAllocVidbuffer PROC				; COMDAT

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1018 : 	const DWORD vidbuffersize = (lvid->width * lvid->height * lvid->bpp * NUMSCREENS);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lvid$[ebp]
  0000f	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00012	0f af 51 10	 imul	 edx, DWORD PTR [ecx+16]
  00016	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  00019	0f af 50 30	 imul	 edx, DWORD PTR [eax+48]
  0001d	6b ca 05	 imul	 ecx, edx, 5
  00020	89 4d fc	 mov	 DWORD PTR _vidbuffersize$[ebp], ecx

; 1019 : 
; 1020 : 	// free allocated buffer for previous video mode
; 1021 : 	if (lvid->buffer)

  00023	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  00026	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002a	74 0e		 je	 SHORT $LN2@VID_FreeAn

; 1022 : 		GlobalFree(lvid->buffer);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	51		 push	 ecx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  00039	90		 npad	 1
$LN2@VID_FreeAn:

; 1023 : 
; 1024 : 	// allocate & clear the new screen buffer
; 1025 : 	lvid->buffer = GlobalAlloc(GPTR, vidbuffersize);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _vidbuffersize$[ebp]
  0003d	50		 push	 eax
  0003e	6a 40		 push	 64			; 00000040H
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _lvid$[ebp]
  00049	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1026 : 	if (!lvid->buffer)

  0004c	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0004f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00053	75 04		 jne	 SHORT $LN3@VID_FreeAn

; 1027 : 		return FALSE;

  00055	33 c0		 xor	 eax, eax
  00057	eb 1a		 jmp	 SHORT $LN1@VID_FreeAn
$LN3@VID_FreeAn:

; 1028 : 
; 1029 : 	ZeroMemory(lvid->buffer, vidbuffersize);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _vidbuffersize$[ebp]
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _lvid$[ebp]
  00062	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _memset
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1030 : #ifdef DEBUG
; 1031 : 	CONS_Printf("VID_FreeAndAllocVidbuffer done, vidbuffersize: %x\n",vidbuffersize);
; 1032 : #endif
; 1033 : 	return TRUE;

  0006e	b8 01 00 00 00	 mov	 eax, 1
$LN1@VID_FreeAn:

; 1034 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_VID_FreeAndAllocVidbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_Init
_TEXT	SEGMENT
tv85 = -84						; size = 4
tv130 = -84						; size = 4
_hwdversion$1 = -16					; size = 4
_drvname$2 = -12					; size = 4
_iMode$ = -8						; size = 4
_pv$ = -4						; size = 4
_VID_Init PROC						; COMDAT

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 717  : #ifdef _DEBUG
; 718  : 	vmode_t *pv;
; 719  : 	int iMode;
; 720  : #endif
; 721  : 
; 722  : 	// if '-win' is specified on the command line, do not add DirectDraw modes
; 723  : 	bWinParm = M_CheckParm("-win");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_04EKBMMNPE@?9win@
  0000e	e8 00 00 00 00	 call	 _M_CheckParm
  00013	83 c4 04	 add	 esp, 4
  00016	a3 00 00 00 00	 mov	 DWORD PTR _bWinParm, eax

; 724  : 
; 725  : 	COM_AddCommand("vid_nummodes", VID_Command_NumModes_f);

  0001b	68 00 00 00 00	 push	 OFFSET _VID_Command_NumModes_f
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DMEBCDJH@vid_nummodes@
  00025	e8 00 00 00 00	 call	 _COM_AddCommand
  0002a	83 c4 08	 add	 esp, 8

; 726  : 	COM_AddCommand("vid_modeinfo", VID_Command_ModeInfo_f);

  0002d	68 00 00 00 00	 push	 OFFSET _VID_Command_ModeInfo_f
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JFLAADMP@vid_modeinfo@
  00037	e8 00 00 00 00	 call	 _COM_AddCommand
  0003c	83 c4 08	 add	 esp, 8

; 727  : 	COM_AddCommand("vid_modelist", VID_Command_ModeList_f);

  0003f	68 00 00 00 00	 push	 OFFSET _VID_Command_ModeList_f
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HDFMBOAH@vid_modelist@
  00049	e8 00 00 00 00	 call	 _COM_AddCommand
  0004e	83 c4 08	 add	 esp, 8

; 728  : 	COM_AddCommand("vid_mode", VID_Command_Mode_f);

  00051	68 00 00 00 00	 push	 OFFSET _VID_Command_Mode_f
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_08ICHJJAPN@vid_mode@
  0005b	e8 00 00 00 00	 call	 _COM_AddCommand
  00060	83 c4 08	 add	 esp, 8

; 729  : 
; 730  : 	CV_RegisterVar(&cv_vidwait);

  00063	68 00 00 00 00	 push	 OFFSET _cv_vidwait
  00068	e8 00 00 00 00	 call	 _CV_RegisterVar
  0006d	83 c4 04	 add	 esp, 4

; 731  : 	CV_RegisterVar(&cv_stretch);

  00070	68 00 00 00 00	 push	 OFFSET _cv_stretch
  00075	e8 00 00 00 00	 call	 _CV_RegisterVar
  0007a	83 c4 04	 add	 esp, 4

; 732  : 	CV_RegisterVar(&cv_ontop);

  0007d	68 00 00 00 00	 push	 OFFSET _cv_ontop
  00082	e8 00 00 00 00	 call	 _CV_RegisterVar
  00087	83 c4 04	 add	 esp, 4

; 733  : 
; 734  : 	// setup the videmodes list,
; 735  : 	// note that mode 0 must always be VGA mode 0x13
; 736  : 	pvidmodes = pcurrentmode = NULL;

  0008a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pcurrentmode, 0
  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  00099	a3 00 00 00 00	 mov	 DWORD PTR _pvidmodes, eax

; 737  : 	numvidmodes = 0;

  0009e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numvidmodes, 0

; 738  : 
; 739  : 	//DisableAero();
; 740  : 
; 741  : 	// store the main window handle in viddef struct
; 742  : 	SetWindowPos(hWndMain, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOSENDCHANGING|SWP_NOSIZE|SWP_NOMOVE);

  000a8	68 13 04 00 00	 push	 1043			; 00000413H
  000ad	6a 00		 push	 0
  000af	6a 00		 push	 0
  000b1	6a 00		 push	 0
  000b3	6a 00		 push	 0
  000b5	6a fe		 push	 -2			; fffffffeH
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  000c3	90		 npad	 1

; 743  : 	vid.WndParent = hWndMain;

  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  000c9	a3 38 00 00 00	 mov	 DWORD PTR _vid+56, eax

; 744  : 	vid.buffer = NULL;

  000ce	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _vid+4, 0

; 745  : 
; 746  : 	// we startup in windowed mode using DIB bitmap
; 747  : 	// we will use DirectDraw when switching fullScreen and entering main game loop
; 748  : 	bDIBMode = TRUE;

  000d8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bDIBMode, 1

; 749  : 	bAppFullScreen = FALSE;

  000e2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bAppFullScreen, 0

; 750  : 
; 751  : #ifdef HWRENDER
; 752  : 	// initialize the appropriate display device
; 753  : 	if (rendermode != render_soft)

  000ec	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000f3	0f 84 a8 00 00
	00		 je	 $LN13@VID_Init

; 754  : 	{
; 755  : 		const char *drvname = NULL;

  000f9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _drvname$2[ebp], 0

; 756  : 
; 757  : 		switch (rendermode)

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR _rendermode
  00105	89 45 ac	 mov	 DWORD PTR tv85[ebp], eax
  00108	83 7d ac 02	 cmp	 DWORD PTR tv85[ebp], 2
  0010c	74 02		 je	 SHORT $LN10@VID_Init
  0010e	eb 09		 jmp	 SHORT $LN11@VID_Init
$LN10@VID_Init:

; 758  : 		{
; 759  : 			case render_opengl:
; 760  : 				drvname = "r_opengl.dll";

  00110	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _drvname$2[ebp], OFFSET ??_C@_0N@PBCLHOFP@r_opengl?4dll@

; 761  : 				break;

  00117	eb 0d		 jmp	 SHORT $LN2@VID_Init
$LN11@VID_Init:

; 762  : 			default:
; 763  : 				I_Error("Unknown hardware render mode");

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IMOKCPEI@Unknown?5hardware?5render?5mode@
  0011e	e8 00 00 00 00	 call	 _I_Error
  00123	83 c4 04	 add	 esp, 4
$LN2@VID_Init:

; 764  : 		}
; 765  : 
; 766  : 		// load the DLL
; 767  : 		if (drvname && Init3DDriver(drvname))

  00126	83 7d f4 00	 cmp	 DWORD PTR _drvname$2[ebp], 0
  0012a	74 4e		 je	 SHORT $LN12@VID_Init
  0012c	8b 45 f4	 mov	 eax, DWORD PTR _drvname$2[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _Init3DDriver
  00135	83 c4 04	 add	 esp, 4
  00138	85 c0		 test	 eax, eax
  0013a	74 3e		 je	 SHORT $LN12@VID_Init

; 768  : 		{
; 769  : 			int hwdversion = HWD.pfnGetRenderVersion();

  0013c	ff 15 40 00 00
	00		 call	 DWORD PTR _hwdriver+64
  00142	89 45 f0	 mov	 DWORD PTR _hwdversion$1[ebp], eax

; 770  : 			if (hwdversion != VERSION)

  00145	81 7d f0 c8 00
	00 00		 cmp	 DWORD PTR _hwdversion$1[ebp], 200 ; 000000c8H
  0014c	74 0d		 je	 SHORT $LN14@VID_Init

; 771  : 				CONS_Printf("WARNING: This r_opengl version is not supported, use it at your own risk.\n");

  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LGEPIIFI@WARNING?3?5This?5r_opengl?5version?5@
  00153	e8 00 00 00 00	 call	 _CONS_Printf
  00158	83 c4 04	 add	 esp, 4
$LN14@VID_Init:

; 772  : 
; 773  : 			// perform initialisations
; 774  : 			HWD.pfnInit(I_Error);

  0015b	68 00 00 00 00	 push	 OFFSET _I_Error
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR _hwdriver
  00166	90		 npad	 1

; 775  : 			// get available display modes for the device
; 776  : 			HWD.pfnGetModeList(&pvidmodes, &numvidmodes);

  00167	68 00 00 00 00	 push	 OFFSET _numvidmodes
  0016c	68 00 00 00 00	 push	 OFFSET _pvidmodes
  00171	ff 15 44 00 00
	00		 call	 DWORD PTR _hwdriver+68
  00177	90		 npad	 1

; 777  : 		}

  00178	eb 27		 jmp	 SHORT $LN13@VID_Init
$LN12@VID_Init:

; 778  : 		else
; 779  : 		{
; 780  : 			switch (rendermode)

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR _rendermode
  0017f	89 45 ac	 mov	 DWORD PTR tv130[ebp], eax
  00182	83 7d ac 02	 cmp	 DWORD PTR tv130[ebp], 2
  00186	74 02		 je	 SHORT $LN15@VID_Init
  00188	eb 0d		 jmp	 SHORT $LN16@VID_Init
$LN15@VID_Init:

; 781  : 			{
; 782  : 				case render_opengl:
; 783  : 					I_Error("Error initializing OpenGL");

  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CGJIEHBD@Error?5initializing?5OpenGL@
  0018f	e8 00 00 00 00	 call	 _I_Error
  00194	83 c4 04	 add	 esp, 4
$LN16@VID_Init:

; 784  : 				default:
; 785  : 					break;
; 786  : 			}
; 787  : 			rendermode = render_soft;

  00197	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _rendermode, 1
$LN13@VID_Init:

; 788  : 		}
; 789  : 	}
; 790  : 
; 791  : 	if (rendermode == render_soft)

  001a1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  001a8	75 24		 jne	 SHORT $LN20@VID_Init

; 792  : #endif
; 793  : 		if (!bWinParm)

  001aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bWinParm, 0
  001b1	75 1b		 jne	 SHORT $LN20@VID_Init

; 794  : 		{
; 795  : 			if (!CreateDirectDrawInstance())

  001b3	e8 00 00 00 00	 call	 _CreateDirectDrawInstance
  001b8	85 c0		 test	 eax, eax
  001ba	75 0c		 jne	 SHORT $LN19@VID_Init

; 796  : 				bWinParm = TRUE;

  001bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bWinParm, 1
  001c6	eb 06		 jmp	 SHORT $LN20@VID_Init
$LN19@VID_Init:

; 797  : 			else // get available display modes for the device
; 798  : 				VID_GetExtraModes();

  001c8	e8 00 00 00 00	 call	 _VID_GetExtraModes
  001cd	90		 npad	 1
$LN20@VID_Init:

; 799  : 		}
; 800  : 
; 801  : 	// the game boots in 320x200 standard VGA, but
; 802  : 	// we need a highcolor mode to run the game in highcolor
; 803  : 	if (highcolor && !numvidmodes)

  001ce	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _highcolor, 0
  001d5	74 16		 je	 SHORT $LN21@VID_Init
  001d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numvidmodes, 0
  001de	75 0d		 jne	 SHORT $LN21@VID_Init

; 804  : 		I_Error("Cannot run in highcolor - No 15bit highcolor DirectX video mode found.");

  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@BDGLHHIM@Cannot?5run?5in?5highcolor?5?9?5No?515@
  001e5	e8 00 00 00 00	 call	 _I_Error
  001ea	83 c4 04	 add	 esp, 4
$LN21@VID_Init:

; 805  : 
; 806  : 	// add windowed mode at the start of the list, very important!
; 807  : 	WindowMode_Init();

  001ed	e8 00 00 00 00	 call	 _WindowMode_Init
  001f2	90		 npad	 1

; 808  : 
; 809  : 	if (!numvidmodes)

  001f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numvidmodes, 0
  001fa	75 0d		 jne	 SHORT $LN22@VID_Init

; 810  : 		I_Error("No display modes available.");

  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CBHGFNBK@No?5display?5modes?5available?4@
  00201	e8 00 00 00 00	 call	 _I_Error
  00206	83 c4 04	 add	 esp, 4
$LN22@VID_Init:

; 811  : 
; 812  : #ifdef _DEBUG // DEBUG
; 813  : 	for (iMode = 0, pv = pvidmodes; pv; pv = pv->pnext, iMode++)

  00209	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iMode$[ebp], 0
  00210	a1 00 00 00 00	 mov	 eax, DWORD PTR _pvidmodes
  00215	89 45 fc	 mov	 DWORD PTR _pv$[ebp], eax
  00218	eb 11		 jmp	 SHORT $LN8@VID_Init
$LN6@VID_Init:
  0021a	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  0021d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021f	89 4d fc	 mov	 DWORD PTR _pv$[ebp], ecx
  00222	8b 55 f8	 mov	 edx, DWORD PTR _iMode$[ebp]
  00225	83 c2 01	 add	 edx, 1
  00228	89 55 f8	 mov	 DWORD PTR _iMode$[ebp], edx
$LN8@VID_Init:
  0022b	83 7d fc 00	 cmp	 DWORD PTR _pv$[ebp], 0
  0022f	74 2f		 je	 SHORT $LN7@VID_Init

; 814  : 		CONS_Printf("#%02d: %dx%dx%dbpp (desc: '%s')\n", iMode, pv->width, pv->height,

  00231	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  00234	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00237	51		 push	 ecx
  00238	8b 55 fc	 mov	 edx, DWORD PTR _pv$[ebp]
  0023b	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0023e	50		 push	 eax
  0023f	8b 4d fc	 mov	 ecx, DWORD PTR _pv$[ebp]
  00242	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00245	52		 push	 edx
  00246	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  00249	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024c	51		 push	 ecx
  0024d	8b 55 f8	 mov	 edx, DWORD PTR _iMode$[ebp]
  00250	52		 push	 edx
  00251	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MHJFAOJC@?$CD?$CF02d?3?5?$CFdx?$CFdx?$CFdbpp?5?$CIdesc?3?5?8?$CFs?8?$CJ@
  00256	e8 00 00 00 00	 call	 _CONS_Printf
  0025b	83 c4 18	 add	 esp, 24			; 00000018H
  0025e	eb ba		 jmp	 SHORT $LN6@VID_Init
$LN7@VID_Init:

; 815  : 			pv->bytesperpixel, pv->name);
; 816  : #endif
; 817  : 
; 818  : 	// set the startup screen in a window
; 819  : 	VID_SetMode(0);

  00260	6a 00		 push	 0
  00262	e8 00 00 00 00	 call	 _VID_SetMode
  00267	83 c4 04	 add	 esp, 4

; 820  : }

  0026a	5f		 pop	 edi
  0026b	5e		 pop	 esi
  0026c	5b		 pop	 ebx
  0026d	8b e5		 mov	 esp, ebp
  0026f	5d		 pop	 ebp
  00270	c3		 ret	 0
_VID_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_GetModePtr
_TEXT	SEGMENT
tv68 = -72						; size = 4
_pv$ = -4						; size = 4
_modenum$ = 8						; size = 4
_VID_GetModePtr PROC					; COMDAT

; 889  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 890  : 	vmode_t *pv;
; 891  : 
; 892  : 	pv = pvidmodes;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _pvidmodes
  0000e	89 45 fc	 mov	 DWORD PTR _pv$[ebp], eax

; 893  : 	if (!pv)

  00011	83 7d fc 00	 cmp	 DWORD PTR _pv$[ebp], 0
  00015	75 0d		 jne	 SHORT $LN4@VID_GetMod

; 894  : 		I_Error("VID_error: No video mode found\n");

  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EOJIJPFH@VID_error?3?5No?5video?5mode?5found?6@
  0001c	e8 00 00 00 00	 call	 _I_Error
  00021	83 c4 04	 add	 esp, 4
$LN4@VID_GetMod:

; 895  : 
; 896  : 	while (modenum--)

  00024	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  00027	89 45 b8	 mov	 DWORD PTR tv68[ebp], eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _modenum$[ebp]
  0002d	83 e9 01	 sub	 ecx, 1
  00030	89 4d 08	 mov	 DWORD PTR _modenum$[ebp], ecx
  00033	83 7d b8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00037	74 1d		 je	 SHORT $LN3@VID_GetMod

; 897  : 	{
; 898  : 		pv = pv->pnext;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d fc	 mov	 DWORD PTR _pv$[ebp], ecx

; 899  : 		if (!pv)

  00041	83 7d fc 00	 cmp	 DWORD PTR _pv$[ebp], 0
  00045	75 0d		 jne	 SHORT $LN5@VID_GetMod

; 900  : 			I_Error("VID_error: Mode not available\n");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EDOALGEF@VID_error?3?5Mode?5not?5available?6@
  0004c	e8 00 00 00 00	 call	 _I_Error
  00051	83 c4 04	 add	 esp, 4
$LN5@VID_GetMod:

; 901  : 	}

  00054	eb ce		 jmp	 SHORT $LN4@VID_GetMod
$LN3@VID_GetMod:

; 902  : 	return pv;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]

; 903  : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_VID_GetModePtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_SetDirectDrawMode@8
_TEXT	SEGMENT
_lvid$ = 8						; size = 4
_currentmode$ = 12					; size = 4
_VID_SetDirectDrawMode@8 PROC				; COMDAT

; 1043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1044 : 	UNREFERENCED_PARAMETER(currentmode);
; 1045 : #ifdef DEBUG
; 1046 : 	CONS_Printf("VID_SetDirectDrawMode...\n");
; 1047 : #endif
; 1048 : 
; 1049 : 	// DD modes do double-buffer page flipping, but the game engine doesn't need this..
; 1050 : 	lvid->u.numpages = 2;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0000c	c7 40 14 02 00
	00 00		 mov	 DWORD PTR [eax+20], 2

; 1051 : 
; 1052 : 	// release ddraw surfaces etc..
; 1053 : 	ReleaseChtuff();

  00013	e8 00 00 00 00	 call	 _ReleaseChtuff
  00018	90		 npad	 1

; 1054 : 
; 1055 : 	// clean up any old vid buffer lying around, alloc new if needed
; 1056 : 	if (!VID_FreeAndAllocVidbuffer(lvid))

  00019	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _VID_FreeAndAllocVidbuffer
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	75 05		 jne	 SHORT $LN2@VID_SetDir

; 1057 : 		return -1; // no mem

  00029	83 c8 ff	 or	 eax, -1
  0002c	eb 7b		 jmp	 SHORT $LN1@VID_SetDir
$LN2@VID_SetDir:

; 1058 : 
; 1059 : 	// should clear video mem here
; 1060 : 
; 1061 : 	// note use lvid->bpp instead of 8...will this be needed? will we support other than 256color
; 1062 : 	// in software ?
; 1063 : 	if (!InitDirectDrawe(hWndMain, lvid->width, lvid->height, 8, TRUE)) // TRUE currently always full screen

  0002e	6a 01		 push	 1
  00030	6a 08		 push	 8
  00032	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  00035	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _lvid$[ebp]
  0003c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0003f	50		 push	 eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _InitDirectDrawe
  0004c	83 c4 14	 add	 esp, 20			; 00000014H
  0004f	85 c0		 test	 eax, eax
  00051	75 04		 jne	 SHORT $LN3@VID_SetDir

; 1064 : 		return 0;               // could not set mode

  00053	33 c0		 xor	 eax, eax
  00055	eb 52		 jmp	 SHORT $LN1@VID_SetDir
$LN3@VID_SetDir:

; 1065 : 
; 1066 : 	// this is NOT used with DirectDraw modes, game engine should never use this directly
; 1067 : 	// but rather render to memory bitmap buffer
; 1068 : 	lvid->direct = NULL;

  00057	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0005a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1069 : 
; 1070 : 	if (!cv_stretch.value && (float)vid.width/vid.height != ((float)BASEVIDWIDTH/BASEVIDHEIGHT))

  00061	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_stretch+20, 0
  00068	75 3a		 jne	 SHORT $LN4@VID_SetDir
  0006a	f3 0f 2a 05 0c
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+12
  00072	f3 0f 2a 0d 10
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _vid+16
  0007a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0007e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3fcccccd
  00085	9f		 lahf
  00086	f6 c4 44	 test	 ah, 68			; 00000044H
  00089	7b 19		 jnp	 SHORT $LN4@VID_SetDir

; 1071 : 		vid.height = (int)(vid.width * ((float)BASEVIDHEIGHT/BASEVIDWIDTH));// Adjust the height to match

  0008b	f3 0f 2a 05 0c
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+12
  00093	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f200000
  0009b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0009f	a3 10 00 00 00	 mov	 DWORD PTR _vid+16, eax
$LN4@VID_SetDir:

; 1072 : 
; 1073 : 	return 1;

  000a4	b8 01 00 00 00	 mov	 eax, 1
$LN1@VID_SetDir:

; 1074 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
_VID_SetDirectDrawMode@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_Command_Mode_f
_TEXT	SEGMENT
_modenum$ = -4						; size = 4
_VID_Command_Mode_f PROC				; COMDAT

; 1138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1139 : 	int modenum;
; 1140 : 
; 1141 : 	if (COM_Argc() != 2)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 02	 cmp	 eax, 2
  00011	74 0f		 je	 SHORT $LN2@VID_Comman

; 1142 : 	{
; 1143 : 		CONS_Printf("vid_mode <modenum> : set video mode\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JADPPDDK@vid_mode?5?$DMmodenum?$DO?5?3?5set?5video?5@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 1144 : 		return;

  00020	eb 40		 jmp	 SHORT $LN4@VID_Comman
$LN2@VID_Comman:

; 1145 : 	}
; 1146 : 
; 1147 : 	modenum = atoi(COM_Argv(1));

  00022	6a 01		 push	 1
  00024	e8 00 00 00 00	 call	 _COM_Argv
  00029	83 c4 04	 add	 esp, 4
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _atoi
  00032	83 c4 04	 add	 esp, 4
  00035	89 45 fc	 mov	 DWORD PTR _modenum$[ebp], eax

; 1148 : 
; 1149 : 	if (modenum > VID_NumModes() || modenum < 1) // don't accept the windowed mode 0

  00038	e8 00 00 00 00	 call	 _VID_NumModes
  0003d	39 45 fc	 cmp	 DWORD PTR _modenum$[ebp], eax
  00040	7f 06		 jg	 SHORT $LN5@VID_Comman
  00042	83 7d fc 01	 cmp	 DWORD PTR _modenum$[ebp], 1
  00046	7d 0f		 jge	 SHORT $LN3@VID_Comman
$LN5@VID_Comman:

; 1150 : 		CONS_Printf("No such video mode\n");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CDAICPIH@No?5such?5video?5mode?6@
  0004d	e8 00 00 00 00	 call	 _CONS_Printf
  00052	83 c4 04	 add	 esp, 4
  00055	eb 0b		 jmp	 SHORT $LN4@VID_Comman
$LN3@VID_Comman:

; 1151 : 	else
; 1152 : 		setmodeneeded = modenum + 1; // request vid mode change

  00057	8b 45 fc	 mov	 eax, DWORD PTR _modenum$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	a3 00 00 00 00	 mov	 DWORD PTR _setmodeneeded, eax
$LN4@VID_Comman:

; 1153 : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_VID_Command_Mode_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_Command_ModeList_f
_TEXT	SEGMENT
_pv$ = -16						; size = 4
_pinfo$ = -12						; size = 4
_numodes$ = -8						; size = 4
_i$ = -4						; size = 4
_VID_Command_ModeList_f PROC				; COMDAT

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1118 : 	int i, numodes;
; 1119 : 	const char *pinfo;
; 1120 : 	vmode_t *pv;
; 1121 : 
; 1122 : 	numodes = VID_NumModes();

  00009	e8 00 00 00 00	 call	 _VID_NumModes
  0000e	89 45 f8	 mov	 DWORD PTR _numodes$[ebp], eax

; 1123 : 	for (i = NUMSPECIALMODES; i <= numodes; i++)

  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00018	eb 09		 jmp	 SHORT $LN4@VID_Comman
$LN2@VID_Comman:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@VID_Comman:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00026	3b 45 f8	 cmp	 eax, DWORD PTR _numodes$[ebp]
  00029	7f 55		 jg	 SHORT $LN3@VID_Comman

; 1124 : 	{
; 1125 : 		pv = VID_GetModePtr(i);

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _VID_GetModePtr
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 1126 : 		pinfo = VID_GetModeName(i);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _VID_GetModeName
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 f4	 mov	 DWORD PTR _pinfo$[ebp], eax

; 1127 : 
; 1128 : 		if (pv->bytesperpixel == 1)

  00049	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  0004c	83 78 14 01	 cmp	 DWORD PTR [eax+20], 1
  00050	75 17		 jne	 SHORT $LN5@VID_Comman

; 1129 : 			CONS_Printf("%d: %s\n", i, pinfo);

  00052	8b 45 f4	 mov	 eax, DWORD PTR _pinfo$[ebp]
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00059	51		 push	 ecx
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_07LCGEOBC@?$CFd?3?5?$CFs?6@
  0005f	e8 00 00 00 00	 call	 _CONS_Printf
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	eb 15		 jmp	 SHORT $LN6@VID_Comman
$LN5@VID_Comman:

; 1130 : 		else
; 1131 : 			CONS_Printf("%d: %s (hicolor)\n", i, pinfo);

  00069	8b 45 f4	 mov	 eax, DWORD PTR _pinfo$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@LPDHNBAA@?$CFd?3?5?$CFs?5?$CIhicolor?$CJ?6@
  00076	e8 00 00 00 00	 call	 _CONS_Printf
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@VID_Comman:

; 1132 : 	}

  0007e	eb 9a		 jmp	 SHORT $LN2@VID_Comman
$LN3@VID_Comman:

; 1133 : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_VID_Command_ModeList_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_Command_ModeInfo_f
_TEXT	SEGMENT
_modenum$ = -8						; size = 4
_pv$ = -4						; size = 4
_VID_Command_ModeInfo_f PROC				; COMDAT

; 1090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1091 : 	vmode_t *pv;
; 1092 : 	int modenum;
; 1093 : 
; 1094 : 	if (COM_Argc() != 2)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 02	 cmp	 eax, 2
  00011	74 0a		 je	 SHORT $LN2@VID_Comman

; 1095 : 		modenum = vid.modenum; // describe the current mode

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _vid
  00018	89 45 f8	 mov	 DWORD PTR _modenum$[ebp], eax
  0001b	eb 16		 jmp	 SHORT $LN3@VID_Comman
$LN2@VID_Comman:

; 1096 : 	else
; 1097 : 		modenum = atoi(COM_Argv(1)); // the given mode number

  0001d	6a 01		 push	 1
  0001f	e8 00 00 00 00	 call	 _COM_Argv
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _atoi
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f8	 mov	 DWORD PTR _modenum$[ebp], eax
$LN3@VID_Comman:

; 1098 : 
; 1099 : 	if (modenum > VID_NumModes() || modenum < NUMSPECIALMODES) // don't accept the windowed modes

  00033	e8 00 00 00 00	 call	 _VID_NumModes
  00038	39 45 f8	 cmp	 DWORD PTR _modenum$[ebp], eax
  0003b	7f 06		 jg	 SHORT $LN5@VID_Comman
  0003d	83 7d f8 01	 cmp	 DWORD PTR _modenum$[ebp], 1
  00041	7d 0f		 jge	 SHORT $LN4@VID_Comman
$LN5@VID_Comman:

; 1100 : 	{
; 1101 : 		CONS_Printf("No such video mode\n");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CDAICPIH@No?5such?5video?5mode?6@
  00048	e8 00 00 00 00	 call	 _CONS_Printf
  0004d	83 c4 04	 add	 esp, 4

; 1102 : 		return;

  00050	eb 6f		 jmp	 SHORT $LN6@VID_Comman
$LN4@VID_Comman:

; 1103 : 	}
; 1104 : 
; 1105 : 	pv = VID_GetModePtr(modenum);

  00052	8b 45 f8	 mov	 eax, DWORD PTR _modenum$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _VID_GetModePtr
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 fc	 mov	 DWORD PTR _pv$[ebp], eax

; 1106 : 
; 1107 : 	CONS_Printf("%s\n", VID_GetModeName(modenum));

  00061	8b 45 f8	 mov	 eax, DWORD PTR _modenum$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _VID_GetModeName
  0006a	83 c4 04	 add	 esp, 4
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  00073	e8 00 00 00 00	 call	 _CONS_Printf
  00078	83 c4 08	 add	 esp, 8

; 1108 : 	CONS_Printf("width: %d\nheight: %d\n", pv->width, pv->height);

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  0007e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00081	51		 push	 ecx
  00082	8b 55 fc	 mov	 edx, DWORD PTR _pv$[ebp]
  00085	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00088	50		 push	 eax
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EPIJCCGN@width?3?5?$CFd?6height?3?5?$CFd?6@
  0008e	e8 00 00 00 00	 call	 _CONS_Printf
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1109 : 	if (rendermode == render_soft)

  00096	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0009d	75 22		 jne	 SHORT $LN6@VID_Comman

; 1110 : 		CONS_Printf("bytes per scanline: %d\nbytes per pixel: %d\nnumpages: %d\n",

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  000a2	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000a5	51		 push	 ecx
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _pv$[ebp]
  000a9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ac	50		 push	 eax
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _pv$[ebp]
  000b0	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000b3	52		 push	 edx
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@LCDFHGPM@bytes?5per?5scanline?3?5?$CFd?6bytes?5pe@
  000b9	e8 00 00 00 00	 call	 _CONS_Printf
  000be	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@VID_Comman:

; 1111 : 			pv->rowbytes, pv->bytesperpixel, pv->numpages);
; 1112 : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_VID_Command_ModeInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_Command_NumModes_f
_TEXT	SEGMENT
_VID_Command_NumModes_f PROC				; COMDAT

; 1083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1084 : 	CONS_Printf("%d video mode(s) available(s)\n", VID_NumModes());

  00009	e8 00 00 00 00	 call	 _VID_NumModes
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MEPMMKEL@?$CFd?5video?5mode?$CIs?$CJ?5available?$CIs?$CJ?6@
  00014	e8 00 00 00 00	 call	 _CONS_Printf
  00019	83 c4 08	 add	 esp, 8

; 1085 : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_VID_Command_NumModes_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_SetWindowedDisplayMode@8
_TEXT	SEGMENT
_h$ = -36						; size = 4
_w$ = -32						; size = 4
_y$ = -28						; size = 4
_x$ = -24						; size = 4
_bounds$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lvid$ = 8						; size = 4
_currentmode$ = 12					; size = 4
_VID_SetWindowedDisplayMode@8 PROC			; COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 831  : 	RECT bounds;
; 832  : 	int x = 0, y = 0, w = 0, h = 0;

  00013	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  0001a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00021	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00028	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0

; 833  : 
; 834  : 	UNREFERENCED_PARAMETER(currentmode);
; 835  : #ifdef DEBUG
; 836  : 	CONS_Printf("VID_SetWindowedDisplayMode()\n");
; 837  : #endif
; 838  : 
; 839  : 	lvid->u.numpages = 1; // not used

  0002f	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  00032	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1

; 840  : 	lvid->direct = NULL; // DOS remains

  00039	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  0003c	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 841  : 	lvid->buffer = NULL;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  00046	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 842  : 
; 843  : 	// allocate screens
; 844  : 	if (!VID_FreeAndAllocVidbuffer(lvid))

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _VID_FreeAndAllocVidbuffer
  00056	83 c4 04	 add	 esp, 4
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN2@VID_SetWin

; 845  : 		return -1;

  0005d	83 c8 ff	 or	 eax, -1
  00060	e9 7b 01 00 00	 jmp	 $LN1@VID_SetWin
$LN2@VID_SetWin:

; 846  : 
; 847  : 	// lvid->buffer should be NULL here!
; 848  : 
; 849  : 	bmiMain = GlobalAlloc(GPTR, sizeof (BITMAPINFO) + (sizeof (RGBQUAD)*256));

  00065	68 2c 04 00 00	 push	 1068			; 0000042cH
  0006a	6a 40		 push	 64			; 00000040H
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00072	a3 00 00 00 00	 mov	 DWORD PTR _bmiMain, eax

; 850  : 	if (!bmiMain)

  00077	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bmiMain, 0
  0007e	75 0d		 jne	 SHORT $LN3@VID_SetWin

; 851  : 		I_Error("VID_SWDM(): No mem");

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HEOCAMLO@VID_SWDM?$CI?$CJ?3?5No?5mem@
  00085	e8 00 00 00 00	 call	 _I_Error
  0008a	83 c4 04	 add	 esp, 4
$LN3@VID_SetWin:

; 852  : 
; 853  : 	// setup a BITMAPINFO to allow copying our video buffer to the desktop,
; 854  : 	// with color conversion as needed
; 855  : 	bmiMain->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  00092	c7 00 28 00 00
	00		 mov	 DWORD PTR [eax], 40	; 00000028H

; 856  : 	bmiMain->bmiHeader.biWidth = lvid->width;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _lvid$[ebp]
  000a0	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a3	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 857  : 	bmiMain->bmiHeader.biHeight= -(lvid->height);

  000a6	8b 45 08	 mov	 eax, DWORD PTR _lvid$[ebp]
  000a9	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ac	f7 d9		 neg	 ecx
  000ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bmiMain
  000b4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 858  : 	bmiMain->bmiHeader.biPlanes = 1;

  000b7	b8 01 00 00 00	 mov	 eax, 1
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bmiMain
  000c2	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 859  : 	bmiMain->bmiHeader.biBitCount = 8;

  000c6	b8 08 00 00 00	 mov	 eax, 8
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bmiMain
  000d1	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 860  : 	bmiMain->bmiHeader.biCompression = BI_RGB;

  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  000da	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 861  : 
; 862  : 	// center window on the desktop
; 863  : 	GetWindowRect(hWndMain, &bounds);

  000e1	8d 45 ec	 lea	 eax, DWORD PTR _bounds$[ebp]
  000e4	50		 push	 eax
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  000eb	51		 push	 ecx
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  000f2	90		 npad	 1

; 864  : 	AdjustWindowRectEx(&bounds, GetWindowLong(hWndMain, GWL_STYLE), 0, 0);

  000f3	6a 00		 push	 0
  000f5	6a 00		 push	 0
  000f7	6a f0		 push	 -16			; fffffff0H
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  00105	50		 push	 eax
  00106	8d 4d ec	 lea	 ecx, DWORD PTR _bounds$[ebp]
  00109	51		 push	 ecx
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AdjustWindowRectEx@16
  00110	90		 npad	 1

; 865  : 	w = bounds.right-bounds.left; //lvid->width

  00111	8b 45 f4	 mov	 eax, DWORD PTR _bounds$[ebp+8]
  00114	2b 45 ec	 sub	 eax, DWORD PTR _bounds$[ebp]
  00117	89 45 e0	 mov	 DWORD PTR _w$[ebp], eax

; 866  : 	h = bounds.bottom-bounds.top; //lvid->height

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _bounds$[ebp+12]
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _bounds$[ebp+4]
  00120	89 45 dc	 mov	 DWORD PTR _h$[ebp], eax

; 867  : 	x = (GetSystemMetrics(SM_CXSCREEN)-w)/2;

  00123	6a 00		 push	 0
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0012b	2b 45 e0	 sub	 eax, DWORD PTR _w$[ebp]
  0012e	99		 cdq
  0012f	2b c2		 sub	 eax, edx
  00131	d1 f8		 sar	 eax, 1
  00133	89 45 e8	 mov	 DWORD PTR _x$[ebp], eax

; 868  : 	y = (GetSystemMetrics(SM_CYSCREEN)-h)/2;

  00136	6a 01		 push	 1
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0013e	2b 45 dc	 sub	 eax, DWORD PTR _h$[ebp]
  00141	99		 cdq
  00142	2b c2		 sub	 eax, edx
  00144	d1 f8		 sar	 eax, 1
  00146	89 45 e4	 mov	 DWORD PTR _y$[ebp], eax

; 869  : 
; 870  : 	if (devparm)

  00149	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00150	74 26		 je	 SHORT $LN4@VID_SetWin

; 871  : 		MoveWindow(hWndMain, x<<1, y<<1, w, h, TRUE);

  00152	6a 01		 push	 1
  00154	8b 45 dc	 mov	 eax, DWORD PTR _h$[ebp]
  00157	50		 push	 eax
  00158	8b 4d e0	 mov	 ecx, DWORD PTR _w$[ebp]
  0015b	51		 push	 ecx
  0015c	8b 55 e4	 mov	 edx, DWORD PTR _y$[ebp]
  0015f	d1 e2		 shl	 edx, 1
  00161	52		 push	 edx
  00162	8b 45 e8	 mov	 eax, DWORD PTR _x$[ebp]
  00165	d1 e0		 shl	 eax, 1
  00167	50		 push	 eax
  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  0016e	51		 push	 ecx
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  00175	90		 npad	 1
  00176	eb 20		 jmp	 SHORT $LN5@VID_SetWin
$LN4@VID_SetWin:

; 872  : 	else
; 873  : 		MoveWindow(hWndMain, x, y, w, h, TRUE);

  00178	6a 01		 push	 1
  0017a	8b 45 dc	 mov	 eax, DWORD PTR _h$[ebp]
  0017d	50		 push	 eax
  0017e	8b 4d e0	 mov	 ecx, DWORD PTR _w$[ebp]
  00181	51		 push	 ecx
  00182	8b 55 e4	 mov	 edx, DWORD PTR _y$[ebp]
  00185	52		 push	 edx
  00186	8b 45 e8	 mov	 eax, DWORD PTR _x$[ebp]
  00189	50		 push	 eax
  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  00190	51		 push	 ecx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MoveWindow@24
  00197	90		 npad	 1
$LN5@VID_SetWin:

; 874  : 
; 875  : 	SetFocus(hWndMain);

  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  0019d	50		 push	 eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
  001a4	90		 npad	 1

; 876  : 	ShowWindow(hWndMain, SW_SHOW);

  001a5	6a 05		 push	 5
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  001ac	50		 push	 eax
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
  001b3	90		 npad	 1

; 877  : 
; 878  : 	hDCMain = GetDC(hWndMain);

  001b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  001b9	50		 push	 eax
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  001c0	a3 00 00 00 00	 mov	 DWORD PTR _hDCMain, eax

; 879  : 	if (!hDCMain)

  001c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hDCMain, 0
  001cc	75 0d		 jne	 SHORT $LN6@VID_SetWin

; 880  : 		I_Error("VID_SWDM(): GetDC FAILED");

  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BKPKBPAG@VID_SWDM?$CI?$CJ?3?5GetDC?5FAILED@
  001d3	e8 00 00 00 00	 call	 _I_Error
  001d8	83 c4 04	 add	 esp, 4
$LN6@VID_SetWin:

; 881  : 
; 882  : 	return 1;

  001db	b8 01 00 00 00	 mov	 eax, 1
$LN1@VID_SetWin:

; 883  : }

  001e0	5f		 pop	 edi
  001e1	5e		 pop	 esi
  001e2	5b		 pop	 ebx
  001e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e6	33 cd		 xor	 ecx, ebp
  001e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 08 00	 ret	 8
_VID_SetWindowedDisplayMode@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _OnTop_OnChange
_TEXT	SEGMENT
_h$ = -40						; size = 4
_w$ = -36						; size = 4
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_bounds$ = -24						; size = 16
_uFlags$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_OnTop_OnChange PROC					; COMDAT

; 388  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 389  : 	const UINT uFlags = SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER;

  00013	c7 45 f8 17 00
	00 00		 mov	 DWORD PTR _uFlags$[ebp], 23 ; 00000017H

; 390  : 	RECT bounds;
; 391  : 	int x = 0, y = 0, w = 0, h = 0;

  0001a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00021	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00028	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  0002f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0

; 392  : 
; 393  : 	if (!hWndMain || bAppFullScreen || cv_ontop.value == -1)

  00036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hWndMain, 0
  0003d	74 12		 je	 SHORT $LN3@OnTop_OnCh
  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  00046	75 09		 jne	 SHORT $LN3@OnTop_OnCh
  00048	83 3d 14 00 00
	00 ff		 cmp	 DWORD PTR _cv_ontop+20, -1
  0004f	75 05		 jne	 SHORT $LN2@OnTop_OnCh
$LN3@OnTop_OnCh:

; 394  : 		return;

  00051	e9 ac 00 00 00	 jmp	 $LN5@OnTop_OnCh
$LN2@OnTop_OnCh:

; 395  : 
; 396  : 	GetWindowRect(hWndMain, &bounds);

  00056	8d 45 e8	 lea	 eax, DWORD PTR _bounds$[ebp]
  00059	50		 push	 eax
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  00060	51		 push	 ecx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00067	90		 npad	 1

; 397  : 	AdjustWindowRectEx(&bounds, GetWindowLong(hWndMain, GWL_STYLE), 0, 0);

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a f0		 push	 -16			; fffffff0H
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  0007a	50		 push	 eax
  0007b	8d 4d e8	 lea	 ecx, DWORD PTR _bounds$[ebp]
  0007e	51		 push	 ecx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AdjustWindowRectEx@16
  00085	90		 npad	 1

; 398  : 	w = bounds.right - (x = bounds.left); h = bounds.bottom - (y = bounds.top);

  00086	8b 45 e8	 mov	 eax, DWORD PTR _bounds$[ebp]
  00089	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _bounds$[ebp+8]
  0008f	2b 4d e4	 sub	 ecx, DWORD PTR _x$[ebp]
  00092	89 4d dc	 mov	 DWORD PTR _w$[ebp], ecx
  00095	8b 45 ec	 mov	 eax, DWORD PTR _bounds$[ebp+4]
  00098	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _bounds$[ebp+12]
  0009e	2b 4d e0	 sub	 ecx, DWORD PTR _y$[ebp]
  000a1	89 4d d8	 mov	 DWORD PTR _h$[ebp], ecx

; 399  : 
; 400  : 	if (cv_ontop.value && !paused)

  000a4	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_ontop+20, 0
  000ab	74 31		 je	 SHORT $LN4@OnTop_OnCh
  000ad	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  000b4	85 c0		 test	 eax, eax
  000b6	75 26		 jne	 SHORT $LN4@OnTop_OnCh

; 401  : 		SetWindowPos(hWndMain, HWND_TOP      , x, y, w, h, uFlags);

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _uFlags$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d d8	 mov	 ecx, DWORD PTR _h$[ebp]
  000bf	51		 push	 ecx
  000c0	8b 55 dc	 mov	 edx, DWORD PTR _w$[ebp]
  000c3	52		 push	 edx
  000c4	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  000c7	50		 push	 eax
  000c8	8b 4d e4	 mov	 ecx, DWORD PTR _x$[ebp]
  000cb	51		 push	 ecx
  000cc	6a 00		 push	 0
  000ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hWndMain
  000d4	52		 push	 edx
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  000db	90		 npad	 1
  000dc	eb 24		 jmp	 SHORT $LN5@OnTop_OnCh
$LN4@OnTop_OnCh:

; 402  : 	else
; 403  : 		SetWindowPos(hWndMain, HWND_NOTOPMOST, x, y, w, h, uFlags);

  000de	8b 45 f8	 mov	 eax, DWORD PTR _uFlags$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d d8	 mov	 ecx, DWORD PTR _h$[ebp]
  000e5	51		 push	 ecx
  000e6	8b 55 dc	 mov	 edx, DWORD PTR _w$[ebp]
  000e9	52		 push	 edx
  000ea	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d e4	 mov	 ecx, DWORD PTR _x$[ebp]
  000f1	51		 push	 ecx
  000f2	6a fe		 push	 -2			; fffffffeH
  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hWndMain
  000fa	52		 push	 edx
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  00101	90		 npad	 1
$LN5@OnTop_OnCh:

; 404  : }

  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00108	33 cd		 xor	 ecx, ebp
  0010a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
_OnTop_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_LoadingScreen
_TEXT	SEGMENT
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_I_LoadingScreen PROC					; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 485  : 	RECT rect;
; 486  : 
; 487  : 	// paranoia
; 488  : 	if (!hDCMain || !bmiMain || !vid.buffer)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hDCMain, 0
  0001a	74 12		 je	 SHORT $LN3@I_LoadingS
  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bmiMain, 0
  00023	74 09		 je	 SHORT $LN3@I_LoadingS
  00025	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _vid+4, 0
  0002c	75 05		 jne	 SHORT $LN2@I_LoadingS
$LN3@I_LoadingS:

; 489  : 		return;

  0002e	e9 9f 00 00 00	 jmp	 $LN4@I_LoadingS
$LN2@I_LoadingS:

; 490  : 
; 491  : 	GetClientRect(vid.WndParent, &rect);

  00033	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00036	50		 push	 eax
  00037	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR _vid+56
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00044	90		 npad	 1

; 492  : 
; 493  : 	SetDIBitsToDevice(hDCMain, 0, 0, vid.width, vid.height, 0, 0, 0, vid.height, vid.buffer, bmiMain, DIB_RGB_COLORS);

  00045	6a 00		 push	 0
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  0004c	50		 push	 eax
  0004d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _vid+4
  00053	51		 push	 ecx
  00054	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  0005a	52		 push	 edx
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00066	50		 push	 eax
  00067	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0006d	51		 push	 ecx
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDCMain
  00078	52		 push	 edx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDIBitsToDevice@48
  0007f	90		 npad	 1

; 494  : 
; 495  : 	if (msg)

  00080	83 7d 08 00	 cmp	 DWORD PTR _msg$[ebp], 0
  00084	74 4c		 je	 SHORT $LN4@I_LoadingS

; 496  : 	{
; 497  : 		if (rect.bottom - rect.top > 32)

  00086	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+12]
  00089	2b 45 f0	 sub	 eax, DWORD PTR _rect$[ebp+4]
  0008c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008f	7e 09		 jle	 SHORT $LN5@I_LoadingS

; 498  : 			rect.top = rect.bottom - 32; // put msg on bottom of window

  00091	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+12]
  00094	83 e8 20	 sub	 eax, 32			; 00000020H
  00097	89 45 f0	 mov	 DWORD PTR _rect$[ebp+4], eax
$LN5@I_LoadingS:

; 499  : 		SetBkMode(hDCMain, TRANSPARENT);

  0009a	6a 01		 push	 1
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDCMain
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8
  000a8	90		 npad	 1

; 500  : 		SetTextColor(hDCMain, RGB(0x00, 0x00, 0x00));

  000a9	6a 00		 push	 0
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDCMain
  000b0	50		 push	 eax
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  000b7	90		 npad	 1

; 501  : 		DrawTextA(hDCMain, msg, -1, &rect, DT_WORDBREAK|DT_CENTER);

  000b8	6a 11		 push	 17			; 00000011H
  000ba	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  000bd	50		 push	 eax
  000be	6a ff		 push	 -1
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  000c3	51		 push	 ecx
  000c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDCMain
  000ca	52		 push	 edx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawTextA@20
  000d1	90		 npad	 1
$LN4@I_LoadingS:

; 502  : 	}
; 503  : }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d8	33 cd		 xor	 ecx, ebp
  000da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
_I_LoadingScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_ReadScreen
_TEXT	SEGMENT
_scr$ = 8						; size = 4
_I_ReadScreen PROC					; COMDAT

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 510  : 	// DEBUGGING
; 511  : 	if (rendermode != render_soft)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 0d		 je	 SHORT $LN2@I_ReadScre

; 512  : 		I_Error("I_ReadScreen: called while in non-software mode");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KBOMMIFH@I_ReadScreen?3?5called?5while?5in?5n@
  00017	e8 00 00 00 00	 call	 _I_Error
  0001c	83 c4 04	 add	 esp, 4
$LN2@I_ReadScre:

; 513  : 	VID_BlitLinearScreen(screens[0], scr, vid.width*vid.bpp, vid.height, vid.width*vid.bpp,

  0001f	a1 08 00 00 00	 mov	 eax, DWORD PTR _vid+8
  00024	50		 push	 eax
  00025	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0002b	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  00032	51		 push	 ecx
  00033	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  00039	52		 push	 edx
  0003a	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0003f	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _scr$[ebp]
  0004a	51		 push	 ecx
  0004b	ba 04 00 00 00	 mov	 edx, 4
  00050	6b c2 00	 imul	 eax, edx, 0
  00053	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  0005f	83 c4 18	 add	 esp, 24			; 00000018H

; 514  : 		vid.rowbytes);
; 515  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_I_ReadScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_UpdateNoVsync
_TEXT	SEGMENT
_real_vidwait$ = -4					; size = 4
_I_UpdateNoVsync PROC					; COMDAT

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 474  : 	int real_vidwait = cv_vidwait.value;

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_vidwait+20
  0000e	89 45 fc	 mov	 DWORD PTR _real_vidwait$[ebp], eax

; 475  : 	cv_vidwait.value = 0;

  00011	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_vidwait+20, 0

; 476  : 	I_FinishUpdate();

  0001b	e8 00 00 00 00	 call	 _I_FinishUpdate
  00020	90		 npad	 1

; 477  : 	cv_vidwait.value = real_vidwait;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _real_vidwait$[ebp]
  00024	a3 14 00 00 00	 mov	 DWORD PTR _cv_vidwait+20, eax

; 478  : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_I_UpdateNoVsync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_FinishUpdate
_TEXT	SEGMENT
_half_excess$1 = -8					; size = 4
_ptr$2 = -4						; size = 4
_I_FinishUpdate PROC					; COMDAT

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 411  : 	if (rendermode == render_none)

  00009	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00010	75 05		 jne	 SHORT $LN2@I_FinishUp

; 412  : 		return;

  00012	e9 c7 01 00 00	 jmp	 $LN11@I_FinishUp
$LN2@I_FinishUp:

; 413  : 
; 414  : 	if (I_SkipFrame())

  00017	e8 00 00 00 00	 call	 _I_SkipFrame
  0001c	85 c0		 test	 eax, eax
  0001e	74 05		 je	 SHORT $LN3@I_FinishUp

; 415  : 		return;

  00020	e9 b9 01 00 00	 jmp	 $LN11@I_FinishUp
$LN3@I_FinishUp:

; 416  : 
; 417  : 	// display a graph of ticrate
; 418  : 	if (cv_ticrate.value)

  00025	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_ticrate+20, 0
  0002c	74 0e		 je	 SHORT $LN4@I_FinishUp

; 419  : 		displayticrate(cv_ticrate.value);

  0002e	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_ticrate+20
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _displayticrate
  00039	83 c4 04	 add	 esp, 4
$LN4@I_FinishUp:

; 420  : 
; 421  : 	//
; 422  : 	if (bDIBMode)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDIBMode, 0
  00043	74 60		 je	 SHORT $LN5@I_FinishUp

; 423  : 	{
; 424  : 		// paranoia
; 425  : 		if (!hDCMain || !bmiMain || !vid.buffer)

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hDCMain, 0
  0004c	74 12		 je	 SHORT $LN8@I_FinishUp
  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bmiMain, 0
  00055	74 09		 je	 SHORT $LN8@I_FinishUp
  00057	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _vid+4, 0
  0005e	75 05		 jne	 SHORT $LN7@I_FinishUp
$LN8@I_FinishUp:

; 426  : 			return;

  00060	e9 79 01 00 00	 jmp	 $LN11@I_FinishUp
$LN7@I_FinishUp:

; 427  : 		// main game loop, still in a window (-win parm)
; 428  : 		SetDIBitsToDevice(hDCMain, 0, 0, vid.width, vid.height, 0, 0, 0, vid.height, vid.buffer, bmiMain,

  00065	6a 00		 push	 0
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  0006c	50		 push	 eax
  0006d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _vid+4
  00073	51		 push	 ecx
  00074	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  0007a	52		 push	 edx
  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00086	50		 push	 eax
  00087	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0008d	51		 push	 ecx
  0008e	6a 00		 push	 0
  00090	6a 00		 push	 0
  00092	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hDCMain
  00098	52		 push	 edx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDIBitsToDevice@48
  0009f	90		 npad	 1

; 429  : 			DIB_RGB_COLORS);
; 430  : 	}

  000a0	e9 39 01 00 00	 jmp	 $LN11@I_FinishUp
$LN5@I_FinishUp:

; 431  : 	else
; 432  : #ifdef HWRENDER
; 433  : 	if (rendermode != render_soft)

  000a5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000ac	74 12		 je	 SHORT $LN9@I_FinishUp

; 434  : 		HWD.pfnFinishUpdate(cv_vidwait.value);

  000ae	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_vidwait+20
  000b3	50		 push	 eax
  000b4	ff 15 08 00 00
	00		 call	 DWORD PTR _hwdriver+8
  000ba	90		 npad	 1
  000bb	e9 1e 01 00 00	 jmp	 $LN11@I_FinishUp
$LN9@I_FinishUp:

; 435  : 	else
; 436  : #endif
; 437  : 	{
; 438  : 		// DIRECT DRAW
; 439  : 		// copy virtual screen to real screen
; 440  : 		// can fail when not active (alt-tab)
; 441  : 		if (LockScreen())

  000c0	e8 00 00 00 00	 call	 _LockScreen
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 11 01 00
	00		 je	 $LN11@I_FinishUp

; 442  : 		{
; 443  : 			/// \todo use directX blit here!!? a blit might use hardware with access
; 444  : 			/// to main memory on recent hardware, and software blit of directX may be
; 445  : 			/// optimized for p2 or mmx??
; 446  : 			if (ScreenHeight > vid.height)

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenHeight
  000d2	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  000d8	0f 8e a6 00 00
	00		 jle	 $LN12@I_FinishUp

; 447  : 			{
; 448  : 				UINT8 *ptr = (UINT8 *)ScreenPtr;

  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenPtr
  000e3	89 45 fc	 mov	 DWORD PTR _ptr$2[ebp], eax

; 449  : 				size_t half_excess = ScreenPitch*(ScreenHeight-vid.height)/2;

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenHeight
  000eb	2b 05 10 00 00
	00		 sub	 eax, DWORD PTR _vid+16
  000f1	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _ScreenPitch
  000f8	99		 cdq
  000f9	2b c2		 sub	 eax, edx
  000fb	d1 f8		 sar	 eax, 1
  000fd	89 45 f8	 mov	 DWORD PTR _half_excess$1[ebp], eax

; 450  : 				memset(ptr, 0x1F, half_excess);

  00100	8b 45 f8	 mov	 eax, DWORD PTR _half_excess$1[ebp]
  00103	50		 push	 eax
  00104	6a 1f		 push	 31			; 0000001fH
  00106	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$2[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 _memset
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 451  : 				ptr += half_excess;

  00112	8b 45 fc	 mov	 eax, DWORD PTR _ptr$2[ebp]
  00115	03 45 f8	 add	 eax, DWORD PTR _half_excess$1[ebp]
  00118	89 45 fc	 mov	 DWORD PTR _ptr$2[ebp], eax

; 452  : 				VID_BlitLinearScreen(screens[0], ptr, vid.width*vid.bpp, vid.height,

  0011b	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenPitch
  00120	50		 push	 eax
  00121	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00127	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  0012e	51		 push	 ecx
  0012f	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  00135	52		 push	 edx
  00136	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0013b	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  00142	50		 push	 eax
  00143	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$2[ebp]
  00146	51		 push	 ecx
  00147	ba 04 00 00 00	 mov	 edx, 4
  0014c	6b c2 00	 imul	 eax, edx, 0
  0014f	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  0015b	83 c4 18	 add	 esp, 24			; 00000018H

; 453  : 					vid.width*vid.bpp, ScreenPitch);
; 454  : 				ptr += vid.height*ScreenPitch;

  0015e	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00163	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _ScreenPitch
  0016a	03 45 fc	 add	 eax, DWORD PTR _ptr$2[ebp]
  0016d	89 45 fc	 mov	 DWORD PTR _ptr$2[ebp], eax

; 455  : 				memset(ptr, 0x1F, half_excess);

  00170	8b 45 f8	 mov	 eax, DWORD PTR _half_excess$1[ebp]
  00173	50		 push	 eax
  00174	6a 1f		 push	 31			; 0000001fH
  00176	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$2[ebp]
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 _memset
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 456  : 			}

  00182	eb 46		 jmp	 SHORT $LN13@I_FinishUp
$LN12@I_FinishUp:

; 457  : 			else
; 458  : 				VID_BlitLinearScreen(screens[0], (UINT8 *)ScreenPtr, vid.width*vid.bpp, vid.height,

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenPitch
  00189	50		 push	 eax
  0018a	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00190	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  00197	51		 push	 ecx
  00198	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  0019e	52		 push	 edx
  0019f	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  001a4	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  001ab	50		 push	 eax
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenPtr
  001b2	51		 push	 ecx
  001b3	ba 04 00 00 00	 mov	 edx, 4
  001b8	6b c2 00	 imul	 eax, edx, 0
  001bb	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  001c1	51		 push	 ecx
  001c2	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  001c7	83 c4 18	 add	 esp, 24			; 00000018H
$LN13@I_FinishUp:

; 459  : 					vid.width*vid.bpp, ScreenPitch);
; 460  : 
; 461  : 			UnlockScreen();

  001ca	e8 00 00 00 00	 call	 _UnlockScreen
  001cf	90		 npad	 1

; 462  : 
; 463  : 			// swap screens
; 464  : 			ScreenFlip(cv_vidwait.value);

  001d0	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_vidwait+20
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 _ScreenFlip
  001db	83 c4 04	 add	 esp, 4
$LN11@I_FinishUp:

; 465  : 		}
; 466  : 	}
; 467  : }

  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c3		 ret	 0
_I_FinishUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_UpdateNoBlit
_TEXT	SEGMENT
_I_UpdateNoBlit PROC					; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 283  : 	// what is this?
; 284  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_I_UpdateNoBlit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_GetModeName
_TEXT	SEGMENT
_modenum$ = 8						; size = 4
_VID_GetModeName PROC					; COMDAT

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 910  : 	return (VID_GetModePtr(modenum))->name;

  00009	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _VID_GetModePtr
  00012	83 c4 04	 add	 esp, 4
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 911  : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_VID_GetModeName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_SetMode
_TEXT	SEGMENT
tv89 = -80						; size = 4
_poldmode$ = -12					; size = 4
_pnewmode$ = -8						; size = 4
_vstat$ = -4						; size = 4
_modenum$ = 8						; size = 4
_VID_SetMode PROC					; COMDAT

; 917  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 918  : 	int vstat;
; 919  : 	vmode_t *pnewmode;
; 920  : 	vmode_t *poldmode;
; 921  : 
; 922  : 	if (dedicated)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00010	74 07		 je	 SHORT $LN2@VID_SetMod

; 923  : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 3e 02 00 00	 jmp	 $LN1@VID_SetMod
$LN2@VID_SetMod:

; 924  : 
; 925  : 	CONS_Printf("VID_SetMode(%d)\n", modenum);

  00019	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KNDMGALM@VID_SetMode?$CI?$CFd?$CJ?6@
  00022	e8 00 00 00 00	 call	 _CONS_Printf
  00027	83 c4 08	 add	 esp, 8

; 926  : 
; 927  : 	// if mode 0 (windowed) we must not be fullscreen already,
; 928  : 	// if other mode, check it is not mode 0 and existing
; 929  : 	if (modenum || bAppFullScreen)

  0002a	83 7d 08 00	 cmp	 DWORD PTR _modenum$[ebp], 0
  0002e	75 09		 jne	 SHORT $LN4@VID_SetMod
  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  00037	74 34		 je	 SHORT $LN8@VID_SetMod
$LN4@VID_SetMod:

; 930  : 	{
; 931  : 		if (modenum > numvidmodes || modenum < NUMSPECIALMODES)

  00039	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  0003c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numvidmodes
  00042	7f 06		 jg	 SHORT $LN6@VID_SetMod
  00044	83 7d 08 01	 cmp	 DWORD PTR _modenum$[ebp], 1
  00048	7d 23		 jge	 SHORT $LN8@VID_SetMod
$LN6@VID_SetMod:

; 932  : 		{
; 933  : 			if (!pcurrentmode)

  0004a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pcurrentmode, 0
  00051	75 09		 jne	 SHORT $LN7@VID_SetMod

; 934  : 				modenum = 0; // revert to the default base vid mode

  00053	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _modenum$[ebp], 0
  0005a	eb 11		 jmp	 SHORT $LN8@VID_SetMod
$LN7@VID_SetMod:

; 935  : 			else
; 936  : 				I_Error("Unknown video mode: %d\n", modenum);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EKIJDNMH@Unknown?5video?5mode?3?5?$CFd?6@
  00065	e8 00 00 00 00	 call	 _I_Error
  0006a	83 c4 08	 add	 esp, 8
$LN8@VID_SetMod:

; 937  : 		}
; 938  : 	}
; 939  : 
; 940  : 	pnewmode = VID_GetModePtr(modenum);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _VID_GetModePtr
  00076	83 c4 04	 add	 esp, 4
  00079	89 45 f8	 mov	 DWORD PTR _pnewmode$[ebp], eax

; 941  : 
; 942  : 	// dont switch to the same display mode
; 943  : 	if (pnewmode == pcurrentmode)

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _pnewmode$[ebp]
  0007f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _pcurrentmode
  00085	75 0a		 jne	 SHORT $LN9@VID_SetMod

; 944  : 		return 1;

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	e9 c6 01 00 00	 jmp	 $LN1@VID_SetMod
$LN9@VID_SetMod:

; 945  : 
; 946  : 	// initialize the new mode
; 947  : 	poldmode = pcurrentmode;

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  00096	89 45 f4	 mov	 DWORD PTR _poldmode$[ebp], eax

; 948  : 	pcurrentmode = pnewmode;

  00099	8b 45 f8	 mov	 eax, DWORD PTR _pnewmode$[ebp]
  0009c	a3 00 00 00 00	 mov	 DWORD PTR _pcurrentmode, eax

; 949  : 
; 950  : 	// initialize vidbuffer size for setmode
; 951  : 	vid.width = pcurrentmode->width;

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  000a6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a9	89 0d 0c 00 00
	00		 mov	 DWORD PTR _vid+12, ecx

; 952  : 	vid.height = pcurrentmode->height;

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  000b4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000b7	89 0d 10 00 00
	00		 mov	 DWORD PTR _vid+16, ecx

; 953  : 	vid.rowbytes = pcurrentmode->rowbytes;

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  000c2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c5	89 0d 08 00 00
	00		 mov	 DWORD PTR _vid+8, ecx

; 954  : 	vid.bpp = pcurrentmode->bytesperpixel;

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  000d0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d3	89 0d 30 00 00
	00		 mov	 DWORD PTR _vid+48, ecx

; 955  : 	if (modenum) // if not 320x200 windowed mode, it's actually a hack

  000d9	83 7d 08 00	 cmp	 DWORD PTR _modenum$[ebp], 0
  000dd	74 7a		 je	 SHORT $LN11@VID_SetMod

; 956  : 	{
; 957  : 		if (rendermode == render_opengl)

  000df	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _rendermode, 2
  000e6	75 71		 jne	 SHORT $LN11@VID_SetMod

; 958  : 		{
; 959  : 			// don't accept depth < 16 for OpenGL mode (too much ugly)
; 960  : 			if (cv_scr_depth.value < 16)

  000e8	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR _cv_scr_depth+20, 16 ; 00000010H
  000ef	7d 0f		 jge	 SHORT $LN12@VID_SetMod

; 961  : 				CV_SetValue(&cv_scr_depth,  16);

  000f1	6a 10		 push	 16			; 00000010H
  000f3	68 00 00 00 00	 push	 OFFSET _cv_scr_depth
  000f8	e8 00 00 00 00	 call	 _CV_SetValue
  000fd	83 c4 08	 add	 esp, 8
$LN12@VID_SetMod:

; 962  : 			vid.bpp = cv_scr_depth.value/8;

  00100	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_scr_depth+20
  00105	99		 cdq
  00106	83 e2 07	 and	 edx, 7
  00109	03 c2		 add	 eax, edx
  0010b	c1 f8 03	 sar	 eax, 3
  0010e	a3 30 00 00 00	 mov	 DWORD PTR _vid+48, eax

; 963  : 			vid.u.windowed = (bWinParm || !cv_fullscreen.value);

  00113	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bWinParm, 0
  0011a	75 12		 jne	 SHORT $LN25@VID_SetMod
  0011c	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_fullscreen+20, 0
  00123	74 09		 je	 SHORT $LN25@VID_SetMod
  00125	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  0012c	eb 07		 jmp	 SHORT $LN26@VID_SetMod
$LN25@VID_SetMod:
  0012e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
$LN26@VID_SetMod:
  00135	8b 45 b0	 mov	 eax, DWORD PTR tv89[ebp]
  00138	a3 14 00 00 00	 mov	 DWORD PTR _vid+20, eax

; 964  : 			pcurrentmode->bytesperpixel = vid.bpp;

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  00142	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _vid+48
  00148	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 965  : 			pcurrentmode->windowed = vid.u.windowed;

  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  00150	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _vid+20
  00156	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN11@VID_SetMod:

; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	vstat = (*pcurrentmode->setmode)(&vid, pcurrentmode);

  00159	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  0015e	50		 push	 eax
  0015f	68 00 00 00 00	 push	 OFFSET _vid
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pcurrentmode
  0016a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0016d	ff d2		 call	 edx
  0016f	89 45 fc	 mov	 DWORD PTR _vstat$[ebp], eax

; 970  : 
; 971  : 	if (vstat == -1)

  00172	83 7d fc ff	 cmp	 DWORD PTR _vstat$[ebp], -1
  00176	75 0f		 jne	 SHORT $LN13@VID_SetMod

; 972  : 		I_Error("Not enough mem for VID_SetMode\n");

  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NGDGMNIC@Not?5enough?5mem?5for?5VID_SetMode?6@
  0017d	e8 00 00 00 00	 call	 _I_Error
  00182	83 c4 04	 add	 esp, 4
  00185	eb 74		 jmp	 SHORT $LN20@VID_SetMod
$LN13@VID_SetMod:

; 973  : 	else if (vstat == -2)

  00187	83 7d fc fe	 cmp	 DWORD PTR _vstat$[ebp], -2 ; fffffffeH
  0018b	75 0f		 jne	 SHORT $LN15@VID_SetMod

; 974  : 		I_Error("Couldn't set video mode because it failed the test\n");

  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@POJIHOK@Couldn?8t?5set?5video?5mode?5because@
  00192	e8 00 00 00 00	 call	 _I_Error
  00197	83 c4 04	 add	 esp, 4
  0019a	eb 5f		 jmp	 SHORT $LN20@VID_SetMod
$LN15@VID_SetMod:

; 975  : 	else if (vstat == -3)

  0019c	83 7d fc fd	 cmp	 DWORD PTR _vstat$[ebp], -3 ; fffffffdH
  001a0	75 0f		 jne	 SHORT $LN17@VID_SetMod

; 976  : 		I_Error("Couldn't set video mode because it failed the change?\n");

  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@LAELGJLA@Couldn?8t?5set?5video?5mode?5because@
  001a7	e8 00 00 00 00	 call	 _I_Error
  001ac	83 c4 04	 add	 esp, 4
  001af	eb 4a		 jmp	 SHORT $LN20@VID_SetMod
$LN17@VID_SetMod:

; 977  : 	else if (!vstat)

  001b1	83 7d fc 00	 cmp	 DWORD PTR _vstat$[ebp], 0
  001b5	75 2a		 jne	 SHORT $LN19@VID_SetMod

; 978  : 		I_Error("Couldn't set video mode %d (%dx%d %d bits)\n", modenum, vid.width, vid.height, (vid.bpp*8));// hardware could not setup mode

  001b7	a1 30 00 00 00	 mov	 eax, DWORD PTR _vid+48
  001bc	c1 e0 03	 shl	 eax, 3
  001bf	50		 push	 eax
  001c0	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001c6	51		 push	 ecx
  001c7	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  001cd	52		 push	 edx
  001ce	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  001d1	50		 push	 eax
  001d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ODHFEKKC@Couldn?8t?5set?5video?5mode?5?$CFd?5?$CI?$CFdx@
  001d7	e8 00 00 00 00	 call	 _I_Error
  001dc	83 c4 14	 add	 esp, 20			; 00000014H
  001df	eb 1a		 jmp	 SHORT $LN20@VID_SetMod
$LN19@VID_SetMod:

; 979  : 	else
; 980  : 		CONS_Printf("Mode changed to %d (%s)\n", modenum, pcurrentmode->name);

  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _pcurrentmode
  001e6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e9	51		 push	 ecx
  001ea	8b 55 08	 mov	 edx, DWORD PTR _modenum$[ebp]
  001ed	52		 push	 edx
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JIGKODNM@Mode?5changed?5to?5?$CFd?5?$CI?$CFs?$CJ?6@
  001f3	e8 00 00 00 00	 call	 _CONS_Printf
  001f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@VID_SetMod:

; 981  : 
; 982  : 	vid.modenum = modenum;

  001fb	8b 45 08	 mov	 eax, DWORD PTR _modenum$[ebp]
  001fe	a3 00 00 00 00	 mov	 DWORD PTR _vid, eax

; 983  : 
; 984  : 	// tell game engine to recalc all tables and realloc buffers based on new values
; 985  : 	vid.recalc = 1;

  00203	c7 05 18 00 00
	00 01 00 00 00	 mov	 DWORD PTR _vid+24, 1

; 986  : 
; 987  : 	if (modenum < NUMSPECIALMODES)

  0020d	83 7d 08 01	 cmp	 DWORD PTR _modenum$[ebp], 1
  00211	7d 16		 jge	 SHORT $LN21@VID_SetMod

; 988  : 	{
; 989  : 		// we are in startup windowed mode
; 990  : 		bAppFullScreen = FALSE;

  00213	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bAppFullScreen, 0

; 991  : 		bDIBMode = TRUE;

  0021d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bDIBMode, 1

; 992  : 	}

  00227	eb 23		 jmp	 SHORT $LN23@VID_SetMod
$LN21@VID_SetMod:

; 993  : 	else
; 994  : 	{
; 995  : 		// we switch to fullscreen
; 996  : 		bAppFullScreen = TRUE;

  00229	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bAppFullScreen, 1

; 997  : 		bDIBMode = FALSE;

  00233	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bDIBMode, 0

; 998  : #ifdef HWRENDER
; 999  : 		if (rendermode != render_soft)

  0023d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00244	74 06		 je	 SHORT $LN23@VID_SetMod

; 1000 : 		{
; 1001 : 			// purge all patch graphics stored in software format
; 1002 : 			//Z_FreeTags (PU_PURGELEVEL, PU_PURGELEVEL+100);
; 1003 : 			HWR_Startup();

  00246	e8 00 00 00 00	 call	 _HWR_Startup
  0024b	90		 npad	 1
$LN23@VID_SetMod:

; 1004 : 		}
; 1005 : #endif
; 1006 : 	}
; 1007 : 
; 1008 : 	I_RestartSysMouse();

  0024c	e8 00 00 00 00	 call	 _I_RestartSysMouse
  00251	90		 npad	 1

; 1009 : 	return 1;

  00252	b8 01 00 00 00	 mov	 eax, 1
$LN1@VID_SetMod:

; 1010 : }

  00257	5f		 pop	 edi
  00258	5e		 pop	 esi
  00259	5b		 pop	 ebx
  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c3		 ret	 0
_VID_SetMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_GetModeForSize
_TEXT	SEGMENT
_modenum$ = -8						; size = 4
_pv$ = -4						; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_VID_GetModeForSize PROC				; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 570  : 	vmode_t *pv;
; 571  : 	int modenum;
; 572  : 
; 573  : #if NUMSPECIALMODES > 1
; 574  : "fix this: pv must point the first fullscreen mode in vidmodes list"
; 575  : #endif
; 576  : 
; 577  : 	// skip the 1st special mode so that it finds only fullscreen modes
; 578  : 	pv = pvidmodes->pnext;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _pvidmodes
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR _pv$[ebp], ecx

; 579  : 
; 580  : 	for (modenum = 1; pv; pv = pv->pnext, modenum++)

  00013	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _modenum$[ebp], 1
  0001a	eb 11		 jmp	 SHORT $LN4@VID_GetMod
$LN2@VID_GetMod:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	89 4d fc	 mov	 DWORD PTR _pv$[ebp], ecx
  00024	8b 55 f8	 mov	 edx, DWORD PTR _modenum$[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _modenum$[ebp], edx
$LN4@VID_GetMod:
  0002d	83 7d fc 00	 cmp	 DWORD PTR _pv$[ebp], 0
  00031	74 1d		 je	 SHORT $LN3@VID_GetMod

; 581  : 		if (pv->width == (unsigned)w && pv->height == (unsigned)h)

  00033	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  00036	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00039	3b 4d 08	 cmp	 ecx, DWORD PTR _w$[ebp]
  0003c	75 10		 jne	 SHORT $LN5@VID_GetMod
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  00041	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00044	3b 4d 0c	 cmp	 ecx, DWORD PTR _h$[ebp]
  00047	75 05		 jne	 SHORT $LN5@VID_GetMod

; 582  : 			return modenum;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _modenum$[ebp]
  0004c	eb 41		 jmp	 SHORT $LN1@VID_GetMod
$LN5@VID_GetMod:
  0004e	eb cc		 jmp	 SHORT $LN2@VID_GetMod
$LN3@VID_GetMod:

; 583  : 
; 584  : 	// if not found, return the first mode available,
; 585  : 	// preferably a full screen mode (all modes after the 'specialmodes')
; 586  : 	if (numvidmodes > NUMSPECIALMODES)

  00050	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _numvidmodes, 1
  00057	7e 34		 jle	 SHORT $LN6@VID_GetMod

; 587  : 	{
; 588  : 		// Try default video mode first
; 589  : 		if (w != cv_scr_width.value && h != cv_scr_height.value)

  00059	8b 45 08	 mov	 eax, DWORD PTR _w$[ebp]
  0005c	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _cv_scr_width+20
  00062	74 22		 je	 SHORT $LN7@VID_GetMod
  00064	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  00067	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _cv_scr_height+20
  0006d	74 17		 je	 SHORT $LN7@VID_GetMod

; 590  : 			return VID_GetModeForSize(cv_scr_width.value, cv_scr_height.value);

  0006f	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_scr_height+20
  00074	50		 push	 eax
  00075	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _cv_scr_width+20
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 _VID_GetModeForSize
  00081	83 c4 08	 add	 esp, 8
  00084	eb 09		 jmp	 SHORT $LN1@VID_GetMod
$LN7@VID_GetMod:

; 591  : 
; 592  : 		return NUMSPECIALMODES; // use first full screen mode

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	eb 02		 jmp	 SHORT $LN1@VID_GetMod
$LN6@VID_GetMod:

; 593  : 	}
; 594  : 
; 595  : 	return 0; // no fullscreen mode, use windowed mode

  0008d	33 c0		 xor	 eax, eax
$LN1@VID_GetMod:

; 596  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_VID_GetModeForSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _VID_NumModes
_TEXT	SEGMENT
_VID_NumModes PROC					; COMDAT

; 562  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 563  : 	return numvidmodes - NUMSPECIALMODES; //faB: dont accept the windowed mode 0

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _numvidmodes
  0000e	83 e8 01	 sub	 eax, 1

; 564  : }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_VID_NumModes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_SetPalette
_TEXT	SEGMENT
_mainpal$1 = -1036					; size = 1024
_pColors$2 = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_palette$ = 8						; size = 4
_I_SetPalette PROC					; COMDAT

; 521  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 04 00
	00		 sub	 esp, 1228		; 000004ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 522  : 	int i;
; 523  : 
; 524  : 	if (bDIBMode)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDIBMode, 0
  0001d	74 79		 je	 SHORT $LN8@I_SetPalet

; 525  : 	{
; 526  : 		// set palette in RGBQUAD format, NOT THE SAME ORDER as PALETTEENTRY, grmpf!
; 527  : 		RGBQUAD *pColors;
; 528  : 		pColors = (RGBQUAD *)((LPBYTE)bmiMain + bmiMain->bmiHeader.biSize);

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bmiMain
  0002a	03 08		 add	 ecx, DWORD PTR [eax]
  0002c	89 4d f4	 mov	 DWORD PTR _pColors$2[ebp], ecx

; 529  : 		ZeroMemory(pColors, sizeof (RGBQUAD)*256);

  0002f	68 00 04 00 00	 push	 1024			; 00000400H
  00034	6a 00		 push	 0
  00036	8b 45 f4	 mov	 eax, DWORD PTR _pColors$2[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _memset
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 		for (i = 0; i < 256; i++, pColors++, palette++)

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00049	eb 1b		 jmp	 SHORT $LN4@I_SetPalet
$LN2@I_SetPalet:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _pColors$2[ebp]
  00057	83 c1 04	 add	 ecx, 4
  0005a	89 4d f4	 mov	 DWORD PTR _pColors$2[ebp], ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _palette$[ebp]
  00060	83 c2 04	 add	 edx, 4
  00063	89 55 08	 mov	 DWORD PTR _palette$[ebp], edx
$LN4@I_SetPalet:
  00066	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  0006d	7d 24		 jge	 SHORT $LN3@I_SetPalet

; 531  : 		{
; 532  : 			pColors->rgbRed = palette->s.red;

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _pColors$2[ebp]
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  00075	8a 11		 mov	 dl, BYTE PTR [ecx]
  00077	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 533  : 			pColors->rgbGreen = palette->s.green;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR _pColors$2[ebp]
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  00080	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00083	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 534  : 			pColors->rgbBlue = palette->s.blue;

  00086	8b 45 f4	 mov	 eax, DWORD PTR _pColors$2[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  0008c	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0008f	88 10		 mov	 BYTE PTR [eax], dl

; 535  : 		}

  00091	eb b8		 jmp	 SHORT $LN2@I_SetPalet
$LN3@I_SetPalet:

; 536  : 	}

  00093	e9 83 00 00 00	 jmp	 $LN10@I_SetPalet
$LN8@I_SetPalet:

; 537  : 	else
; 538  : #ifdef HWRENDER
; 539  : 	if (rendermode == render_soft)

  00098	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0009f	75 7a		 jne	 SHORT $LN10@I_SetPalet

; 540  : #endif
; 541  : 	{
; 542  : 		PALETTEENTRY mainpal[256];
; 543  : 
; 544  : 		// this clears the 'flag' for each color in palette
; 545  : 		ZeroMemory(mainpal, sizeof mainpal);

  000a1	68 00 04 00 00	 push	 1024			; 00000400H
  000a6	6a 00		 push	 0
  000a8	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _mainpal$1[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _memset
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 546  : 
; 547  : 		// set palette in PALETTEENTRY format
; 548  : 		for (i = 0; i < 256; i++, palette++)

  000b7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000be	eb 12		 jmp	 SHORT $LN7@I_SetPalet
$LN5@I_SetPalet:
  000c0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c3	83 c0 01	 add	 eax, 1
  000c6	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  000cc	83 c1 04	 add	 ecx, 4
  000cf	89 4d 08	 mov	 DWORD PTR _palette$[ebp], ecx
$LN7@I_SetPalet:
  000d2	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  000d9	7d 31		 jge	 SHORT $LN6@I_SetPalet

; 549  : 		{
; 550  : 			mainpal[i].peRed = palette->s.red;

  000db	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  000e1	8a 11		 mov	 dl, BYTE PTR [ecx]
  000e3	88 94 85 f4 fb
	ff ff		 mov	 BYTE PTR _mainpal$1[ebp+eax*4], dl

; 551  : 			mainpal[i].peGreen = palette->s.green;

  000ea	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  000f0	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000f3	88 94 85 f5 fb
	ff ff		 mov	 BYTE PTR _mainpal$1[ebp+eax*4+1], dl

; 552  : 			mainpal[i].peBlue = palette->s.blue;

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _palette$[ebp]
  00100	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00103	88 94 85 f6 fb
	ff ff		 mov	 BYTE PTR _mainpal$1[ebp+eax*4+2], dl

; 553  : 		}

  0010a	eb b4		 jmp	 SHORT $LN5@I_SetPalet
$LN6@I_SetPalet:

; 554  : 		SetDDPalette(mainpal);         // set DirectDraw palette

  0010c	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _mainpal$1[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _SetDDPalette
  00118	83 c4 04	 add	 esp, 4
$LN10@I_SetPalet:

; 555  : 	}
; 556  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00121	33 cd		 xor	 ecx, ebp
  00123	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c3		 ret	 0
_I_SetPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_ShutdownGraphics
_TEXT	SEGMENT
_oldrendermode$ = -4					; size = 4
_I_ShutdownGraphics PROC				; COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 226  : #ifdef HWRENDER
; 227  : 	const rendermode_t oldrendermode = rendermode;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _rendermode
  0000e	89 45 fc	 mov	 DWORD PTR _oldrendermode$[ebp], eax

; 228  : #endif
; 229  : 
; 230  : // This is BAD because it makes the I_Error box screw up!
; 231  : //	rendermode = render_none;
; 232  : 
; 233  : 	if (!graphics_started)

  00011	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _graphics_started
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN2@I_Shutdown

; 234  : 		return;

  0001c	e9 a3 00 00 00	 jmp	 $LN1@I_Shutdown
$LN2@I_Shutdown:

; 235  : 
; 236  : 	CONS_Printf("I_ShutdownGraphics()\n");

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MLPCPEFM@I_ShutdownGraphics?$CI?$CJ?6@
  00026	e8 00 00 00 00	 call	 _CONS_Printf
  0002b	83 c4 04	 add	 esp, 4

; 237  : 
; 238  : 	//FreeConsole();
; 239  : 
; 240  : 	//ResetAero();
; 241  : 
; 242  : 	// release windowed startup stuff
; 243  : 	if (hDCMain)

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hDCMain, 0
  00035	74 1e		 je	 SHORT $LN3@I_Shutdown

; 244  : 	{
; 245  : 		ReleaseDC(hWndMain, hDCMain);

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _hDCMain
  0003c	50		 push	 eax
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  00043	51		 push	 ecx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  0004a	90		 npad	 1

; 246  : 		hDCMain = NULL;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hDCMain, 0
$LN3@I_Shutdown:

; 247  : 	}
; 248  : 	if (bmiMain)

  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bmiMain, 0
  0005c	74 17		 je	 SHORT $LN4@I_Shutdown

; 249  : 	{
; 250  : 		GlobalFree(bmiMain);

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmiMain
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  0006a	90		 npad	 1

; 251  : 		bmiMain = NULL;

  0006b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bmiMain, 0
$LN4@I_Shutdown:

; 252  : 	}
; 253  : 
; 254  : #ifdef HWRENDER
; 255  : 	if (oldrendermode != render_soft)

  00075	83 7d fc 01	 cmp	 DWORD PTR _oldrendermode$[ebp], 1
  00079	74 13		 je	 SHORT $LN5@I_Shutdown

; 256  : 	{
; 257  : 		HWR_Shutdown(); // free stuff from the hardware renderer

  0007b	e8 00 00 00 00	 call	 _HWR_Shutdown
  00080	90		 npad	 1

; 258  : 		HWD.pfnShutdown(); // close 3d card display

  00081	ff 15 48 00 00
	00		 call	 DWORD PTR _hwdriver+72
  00087	90		 npad	 1

; 259  : 		Shutdown3DDriver(); // free the driver DLL

  00088	e8 00 00 00 00	 call	 _Shutdown3DDriver
  0008d	90		 npad	 1
$LN5@I_Shutdown:

; 260  : 	}
; 261  : #endif
; 262  : 
; 263  : 	// free the last video mode screen buffers
; 264  : 	if (vid.buffer)

  0008e	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _vid+4, 0
  00095	74 17		 je	 SHORT $LN6@I_Shutdown

; 265  : 	{
; 266  : 		GlobalFree(vid.buffer);

  00097	a1 04 00 00 00	 mov	 eax, DWORD PTR _vid+4
  0009c	50		 push	 eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  000a3	90		 npad	 1

; 267  : 		vid.buffer = NULL;

  000a4	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _vid+4, 0
$LN6@I_Shutdown:

; 268  : 	}
; 269  : 
; 270  : #ifdef HWRENDER
; 271  : 	if (rendermode == render_soft)

  000ae	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000b5	75 06		 jne	 SHORT $LN7@I_Shutdown

; 272  : #endif
; 273  : 		CloseDirectDraw();

  000b7	e8 00 00 00 00	 call	 _CloseDirectDraw
  000bc	90		 npad	 1
$LN7@I_Shutdown:

; 274  : 
; 275  : 	graphics_started = false;

  000bd	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _graphics_started, 0
$LN1@I_Shutdown:

; 276  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
_I_ShutdownGraphics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_vid.c
;	COMDAT _I_StartupGraphics
_TEXT	SEGMENT
_I_StartupGraphics PROC					; COMDAT

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 200  : 	if (graphics_started)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _graphics_started
  00010	85 c0		 test	 eax, eax
  00012	74 04		 je	 SHORT $LN2@I_StartupG

; 201  : 		return;

  00014	eb 61		 jmp	 SHORT $LN8@I_StartupG
  00016	eb 27		 jmp	 SHORT $LN5@I_StartupG
$LN2@I_StartupG:

; 202  : 
; 203  : #ifdef HWRENDER
; 204  : 	else if (M_CheckParm("-opengl"))

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_07IAIJOHNP@?9opengl@
  0001d	e8 00 00 00 00	 call	 _M_CheckParm
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 0c		 je	 SHORT $LN4@I_StartupG

; 205  : 		rendermode = render_opengl;

  00029	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _rendermode, 2
  00033	eb 0a		 jmp	 SHORT $LN5@I_StartupG
$LN4@I_StartupG:

; 206  : 	else
; 207  : #endif
; 208  : 		rendermode = render_soft;

  00035	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _rendermode, 1
$LN5@I_StartupG:

; 209  : 
; 210  : 	if (dedicated)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00046	74 0c		 je	 SHORT $LN6@I_StartupG

; 211  : 		rendermode = render_none;

  00048	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _rendermode, 3
  00052	eb 06		 jmp	 SHORT $LN7@I_StartupG
$LN6@I_StartupG:

; 212  : 	else
; 213  : 		VID_Init();

  00054	e8 00 00 00 00	 call	 _VID_Init
  00059	90		 npad	 1
$LN7@I_StartupG:

; 214  : 
; 215  : 	// register exit code for graphics
; 216  : 	I_AddExitFunc(I_ShutdownGraphics);

  0005a	68 00 00 00 00	 push	 OFFSET _I_ShutdownGraphics
  0005f	e8 00 00 00 00	 call	 _I_AddExitFunc
  00064	83 c4 04	 add	 esp, 4

; 217  : 	if (!dedicated) graphics_started = true;

  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0006e	75 07		 jne	 SHORT $LN8@I_StartupG
  00070	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _graphics_started, 1
$LN8@I_StartupG:

; 218  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_I_StartupGraphics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
