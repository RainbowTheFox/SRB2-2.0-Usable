; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\hw_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_granisotropicmode_cons_t
PUBLIC	_cv_grfov
PUBLIC	_cv_grmd2
PUBLIC	_cv_grfogdensity
PUBLIC	_cv_grfiltermode
PUBLIC	_cv_granisotropicmode
PUBLIC	_cv_grcorrecttricks
PUBLIC	_cv_grsolvetjoin
PUBLIC	??_C@_03KGHEHEMH@MIN@				; `string'
PUBLIC	??_C@_03LEPPJAKI@MAX@				; `string'
PUBLIC	??_C@_07COOCJBJB@Nearest@			; `string'
PUBLIC	??_C@_08DLDNHHDN@Bilinear@			; `string'
PUBLIC	??_C@_09KAHAONAF@Trilinear@			; `string'
PUBLIC	??_C@_0P@LLHPLAOD@Linear_Nearest@		; `string'
PUBLIC	??_C@_0P@NDMMCAFH@Nearest_Linear@		; `string'
PUBLIC	??_C@_0P@FNOJEIGN@Nearest_Mipmap@		; `string'
PUBLIC	_drawsky
PUBLIC	??_C@_0N@IFCNMGME@gr_clipwalls@			; `string'
PUBLIC	??_C@_03GCDBBDDL@Off@				; `string'
PUBLIC	??_C@_07GMIELGC@gr_beta@			; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_06PEIIFMII@gr_fov@			; `string'
PUBLIC	??_C@_02PEECMOAB@90@				; `string'
PUBLIC	??_C@_0O@BJBEMDAE@gr_fogdensity@		; `string'
PUBLIC	??_C@_03GLMKKOKP@150@				; `string'
PUBLIC	??_C@_0O@JOBKFGEH@gr_filtermode@		; `string'
PUBLIC	??_C@_0BD@FFELLCOO@gr_anisotropicmode@		; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0BB@IJGGDDPK@gr_correcttricks@		; `string'
PUBLIC	??_C@_02IAAGKKDJ@On@				; `string'
PUBLIC	??_C@_0O@IBNFDMGB@gr_solvetjoin@		; `string'
PUBLIC	??_C@_03FNJAPEGP@Old@				; `string'
PUBLIC	??_C@_06LLMJLOGJ@gr_md2@			; `string'
EXTRN	_CV_OnOff:BYTE
EXTRN	_CV_Unsigned:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_gr_viewwidth:DWORD
COMM	_gr_viewheight:DWORD
COMM	_gr_baseviewwindowy:DWORD
COMM	_gr_viewwindowx:DWORD
COMM	_gr_basewindowcentery:DWORD
COMM	_hwbbox:DWORD
COMM	_atransform:BYTE:02cH
COMM	_hwdriver:BYTE:064H
_DATA	ENDS
CONST	SEGMENT
_lighttable DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03727c5acr			; 1e-05
	DD	03727c5acr			; 1e-05
	DD	037a7c5acr			; 2e-05
	DD	037fba882r			; 3e-05
	DD	03827c5acr			; 4e-05
	DD	0387ba882r			; 6e-05
	DD	038a7c5acr			; 8e-05
	DD	038d1b717r			; 0.0001
	DD	03908509cr			; 0.00013
	DD	039324207r			; 0.00017
	DD	03951b717r			; 0.0002
	DD	03983126fr			; 0.00025
	DD	0399d4952r			; 0.0003
	DD	039b78034r			; 0.00035
	DD	039d6f545r			; 0.00041
	DD	039fba882r			; 0.00048
	DD	03a12ccf7r			; 0.00056
	DD	03a27c5acr			; 0.00064
	DD	03a3f5d79r			; 0.00073
	DD	03a59945br			; 0.00083
	DD	03a766a55r			; 0.00094
	DD	03a8aefb3r			; 0.00106
	DD	03a9bf9c6r			; 0.00119
	DD	03aad03dar			; 0.00132
	DD	03ac0ad04r			; 0.00147
	DD	03ad5a5b9r			; 0.00163
	DD	03aebedfar			; 0.0018
	DD	03b01c2e3r			; 0.00198
	DD	03b0e368fr			; 0.00217
	DD	03b1b5200r			; 0.00237
	DD	03b29bcfdr			; 0.00259
	DD	03b3827far			; 0.00281
	DD	03b47e282r			; 0.00305
	DD	03b58ec96r			; 0.00331
	DD	03b6a9e6fr			; 0.00358
	DD	03b7cf80er			; 0.00386
	DD	03b88509cr			; 0.00416
	DD	03b927914r			; 0.00447
	DD	03b9cf56fr			; 0.00479
	DD	03ba86d72r			; 0.00514
	DD	03bb43958r			; 0.0055
	DD	03bc05921r			; 0.00587
	DD	03bcd20b0r			; 0.00626
	DD	03bda9004r			; 0.00667
	DD	03be8a71er			; 0.0071
	DD	03bf7121br			; 0.00754
	DD	03c03126fr			; 0.008
	DD	03c0aefb3r			; 0.00848
	DD	03c1320dar			; 0.00898
	DD	03c1ba5e3r			; 0.0095
	DD	03c2454der			; 0.01003
	DD	03c2d81aer			; 0.01059
	DD	03c370260r			; 0.01117
	DD	03c40d6f5r			; 0.01177
	DD	03c4aff6dr			; 0.01239
	DD	03c557bc8r			; 0.01303
	DD	03c604c06r			; 0.01369
	DD	03c6b7026r			; 0.01437
	DD	03c77121br			; 0.01508
	DD	03c8183f9r			; 0.01581
	DD	03c87a8d6r			; 0.01656
	DD	03c8e0c9er			; 0.01734
	DD	03c949a56r			; 0.01814
	DD	03c9b5200r			; 0.01896
	DD	03ca24895r			; 0.01981
	DD	03ca97e13r			; 0.02069
	DD	03cb0dd83r			; 0.02159
	DD	03cb866e4r			; 0.02251
	DD	03cc02f30r			; 0.02346
	DD	03cc83665r			; 0.02444
	DD	03cd0678cr			; 0.02544
	DD	03cd8d79dr			; 0.02647
	DD	03ce18698r			; 0.02753
	DD	03cea747er			; 0.02862
	DD	03cf38c54r			; 0.02973
	DD	03cfcf80er			; 0.03088
	DD	03d0346dcr			; 0.03205
	DD	03d083127r			; 0.03325
	DD	03d0d3ae7r			; 0.03448
	DD	03d126e98r			; 0.03575
	DD	03d17b741r			; 0.03704
	DD	03d1d1f60r			; 0.03836
	DD	03d22a6f4r			; 0.03971
	DD	03d285879r			; 0.0411
	DD	03d2e2974r			; 0.04252
	DD	03d340f67r			; 0.04396
	DD	03d3a29c7r			; 0.04545
	DD	03d405921r			; 0.04696
	DD	03d46b26cr			; 0.04851
	DD	03d4d2b2cr			; 0.05009
	DD	03d53cdddr			; 0.05171
	DD	03d5a9004r			; 0.05336
	DD	03d61719fr			; 0.05504
	DD	03d687d2cr			; 0.05676
	DD	03d6fb2abr			; 0.05852
	DD	03d77079er			; 0.06031
	DD	03d7e8683r			; 0.06214
	DD	03d83126fr			; 0.064
	DD	03d86f694r			; 0.0659
	DD	03d8aefb3r			; 0.06784
	DD	03d8ef88cr			; 0.06981
	DD	03d931b9br			; 0.07183
	DD	03d974e66r			; 0.07388
	DD	03d9b9629r			; 0.07597
	DD	03d9ff2e5r			; 0.0781
	DD	03da46499r			; 0.08027
	DD	03da8eb46r			; 0.08248
	DD	03dad86ecr			; 0.08473
	DD	03db2378br			; 0.08702
	DD	03db6fd22r			; 0.08935
	DD	03dbbd7b2r			; 0.09172
	DD	03dc0cc79r			; 0.09414
	DD	03dc5d0far			; 0.09659
	DD	03dcaefb3r			; 0.09909
	DD	03dd02364r			; 0.10163
	DD	03dd56c0dr			; 0.10421
	DD	03ddaceeer			; 0.10684
	DD	03de046c7r			; 0.10951
	DD	03de5d8d8r			; 0.11223
	DD	03deb7fe1r			; 0.11499
	DD	03df13be2r			; 0.11779
	DD	03df7121br			; 0.12064
	DD	03dfd028ar			; 0.12354
	DD	03e0183f9r			; 0.12648
	DD	03e04912ar			; 0.12946
	DD	03e07ae14r			; 0.1325
	DD	03e0ad57cr			; 0.13558
	DD	03e0e09ffr			; 0.13871
	DD	03e1148fer			; 0.14188
	DD	03e1497b7r			; 0.14511
	DD	03e17f0edr			; 0.14838
	DD	03e1b573fr			; 0.1517
	DD	03e1ecaacr			; 0.15507
	DD	03e224dd3r			; 0.1585
	DD	03e25db77r			; 0.16197
	DD	03e297636r			; 0.16549
	DD	03e2d1e11r			; 0.16906
	DD	03e30d307r			; 0.17268
	DD	03e349518r			; 0.17635
	DD	03e3866e4r			; 0.18008
	DD	03e3c45ccr			; 0.18386
	DD	03e4031cfr			; 0.18769
	DD	03e442aedr			; 0.19157
	DD	03e4833c6r			; 0.19551
	DD	03e4c49bar			; 0.1995
	DD	03e506ccar			; 0.20354
	DD	03e549f95r			; 0.20764
	DD	03e58df7ar			; 0.21179
	DD	03e5d2f1br			; 0.216
	DD	03e618bd6r			; 0.22026
	DD	03e65f84dr			; 0.22458
	DD	03e6a747er			; 0.22896
	DD	03e6efdcar			; 0.23339
	DD	03e7396d1r			; 0.23788
	DD	03e783cf3r			; 0.24242
	DD	03e7cf2d0r			; 0.24702
	DD	03e80dc33r			; 0.25168
	DD	03e8346dcr			; 0.2564
	DD	03e85b963r			; 0.26118
	DD	03e8833c6r			; 0.26602
	DD	03e8ab4b7r			; 0.27091
	DD	03e8d3ed5r			; 0.27587
	DD	03e8fd0d0r			; 0.28089
	DD	03e926959r			; 0.28596
	DD	03e950b0fr			; 0.2911
	DD	03e97b4a2r			; 0.2963
	DD	03e9a6613r			; 0.30156
	DD	03e9d1f60r			; 0.30688
	DD	03e9fe08br			; 0.31226
	DD	03ea2aae3r			; 0.31771
	DD	03ea57d18r			; 0.32322
	DD	03ea8572ar			; 0.32879
	DD	03eab3a69r			; 0.33443
	DD	03eae2585r			; 0.34013
	DD	03eb1187er			; 0.34589
	DD	03eb414a5r			; 0.35172
	DD	03eb718a8r			; 0.35761
	DD	03eba25d9r			; 0.36357
	DD	03ebd3c36r			; 0.3696
	DD	03ec05a71r			; 0.37569
	DD	03ec381d8r			; 0.38185
	DD	03ec6b26cr			; 0.38808
	DD	03ec9eaddr			; 0.39437
	DD	03ecd2c7cr			; 0.40073
	DD	03ed07747r			; 0.40716
	DD	03ed3cb3er			; 0.41366
	DD	03ed72713r			; 0.42022
	DD	03eda8d65r			; 0.42686
	DD	03eddfb94r			; 0.43356
	DD	03ee1743fr			; 0.44034
	DD	03ee4f4c7r			; 0.44718
	DD	03ee87fccr			; 0.4541
	DD	03eec12aer			; 0.46108
	DD	03eefb00cr			; 0.46814
	DD	03ef35697r			; 0.47527
	DD	03ef7064fr			; 0.48247
	DD	03efabf34r			; 0.48974
	DD	03efe8295r			; 0.49709
	DD	03f012791r			; 0.50451
	DD	03f03126fr			; 0.512
	DD	03f05028ar			; 0.51957
	DD	03f06f73cr			; 0.52721
	DD	03f08f084r			; 0.53492
	DD	03f0aef0br			; 0.54271
	DD	03f0cf2d0r			; 0.55058
	DD	03f0efb2br			; 0.55852
	DD	03f1108c4r			; 0.56654
	DD	03f131af4r			; 0.57463
	DD	03f153261r			; 0.5828
	DD	03f174f0er			; 0.59105
	DD	03f197050r			; 0.59937
	DD	03f1b96d1r			; 0.60777
	DD	03f1dc28fr			; 0.61625
	DD	03f1ff38cr			; 0.62481
	DD	03f2229c7r			; 0.63345
	DD	03f246541r			; 0.64217
	DD	03f26a551r			; 0.65096
	DD	03f28eb46r			; 0.65984
	DD	03f2b367ar			; 0.6688
	DD	03f2d8644r			; 0.67783
	DD	03f2fdbf5r			; 0.68695
	DD	03f3236e3r			; 0.69615
	DD	03f3497b7r			; 0.70544
	DD	03f36fd22r			; 0.7148
	DD	03f396873r			; 0.72425
	DD	03f3bd902r			; 0.73378
	DD	03f3e4ecfr			; 0.74339
	DD	03f40c9dar			; 0.75308
	DD	03f434acbr			; 0.76286
	DD	03f45d1a2r			; 0.77273
	DD	03f485db7r			; 0.78268
	DD	03f4aef0br			; 0.79271
	DD	03f4d8644r			; 0.80283
	DD	03f502364r			; 0.81304
	DD	03f52c5c1r			; 0.82333
	DD	03f556e05r			; 0.83371
	DD	03f581b86r			; 0.84417
	DD	03f5aceeer			; 0.85472
	DD	03f5d883cr			; 0.86536
	DD	03f60476fr			; 0.87609
	DD	03f630c89r			; 0.88691
	DD	03f65d6e0r			; 0.89781
	DD	03f68a71er			; 0.9088
	DD	03f6b7de9r			; 0.91989
	DD	03f6e59f3r			; 0.93106
	DD	03f713be2r			; 0.94232
	DD	03f74245fr			; 0.95368
	DD	03f77121br			; 0.96512
	DD	03f7a05bcr			; 0.97665
	DD	03f7cffebr			; 0.98828
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03727c5acr			; 1e-05
	DD	037a7c5acr			; 2e-05
	DD	037fba882r			; 3e-05
	DD	03851b717r			; 5e-05
	DD	03892ccf7r			; 7e-05
	DD	038d1b717r			; 0.0001
	DD	03912ccf7r			; 0.00014
	DD	039473abdr			; 0.00019
	DD	0397ba882r			; 0.00024
	DD	039a2877fr			; 0.00031
	DD	039c73abdr			; 0.00038
	DD	039f66a55r			; 0.00047
	DD	03a156c0dr			; 0.00057
	DD	03a34e11er			; 0.00069
	DD	03a54562er			; 0.00081
	DD	03a7ba882r			; 0.00096
	DD	03a92ccf7r			; 0.00112
	DD	03aa91538r			; 0.00129
	DD	03ac1fc8fr			; 0.00148
	DD	03aded289r			; 0.0017
	DD	03afcf80er			; 0.00193
	DD	03b0ede55r			; 0.00218
	DD	03b20902er			; 0.00245
	DD	03b339192r			; 0.00274
	DD	03b488a48r			; 0.00306
	DD	03b5ed289r			; 0.0034
	DD	03b766a55r			; 0.00376
	DD	03b87fcb9r			; 0.00415
	DD	03b956c0dr			; 0.00456
	DD	03ba3d70ar			; 0.005
	DD	03bb33db0r			; 0.00547
	DD	03bc39ffdr			; 0.00597
	DD	03bd4aa11r			; 0.00649
	DD	03be6afcdr			; 0.00704
	DD	03bfa0514r			; 0.00763
	DD	03c072b02r			; 0.00825
	DD	03c11a75dr			; 0.00889
	DD	03c1ccb7dr			; 0.00957
	DD	03c289763r			; 0.01029
	DD	03c34e11er			; 0.01104
	DD	03c41a8acr			; 0.01182
	DD	03c4f1801r			; 0.01264
	DD	03c5d2f1br			; 0.0135
	DD	03c6bc409r			; 0.01439
	DD	03c7b00bdr			; 0.01532
	DD	03c858794r			; 0.0163
	DD	03c8dcdb3r			; 0.01731
	DD	03c9667b6r			; 0.01836
	DD	03c9f559br			; 0.01945
	DD	03ca89763r			; 0.02058
	DD	03cb24207r			; 0.02176
	DD	03cbc408er			; 0.02298
	DD	03cc692f7r			; 0.02424
	DD	03cd14e3cr			; 0.02555
	DD	03cdc5d64r			; 0.0269
	DD	03ce7d567r			; 0.0283
	DD	03cf3a14dr			; 0.02974
	DD	03cffd60fr			; 0.03123
	DD	03d0639d6r			; 0.03277
	DD	03d0cbd12r			; 0.03436
	DD	03d1374bcr			; 0.036
	DD	03d1a5658r			; 0.03768
	DD	03d2176der			; 0.03942
	DD	03d28c155r			; 0.0412
	DD	03d304ab6r			; 0.04304
	DD	03d380885r			; 0.04493
	DD	03d3ffac2r			; 0.04687
	DD	03d48216cr			; 0.04886
	DD	03d508701r			; 0.05091
	DD	03d592104r			; 0.05301
	DD	03d61f9f0r			; 0.05517
	DD	03d6b074ar			; 0.05738
	DD	03d744913r			; 0.05964
	DD	03d7dc9c5r			; 0.06196
	DD	03d83c4b1r			; 0.06434
	DD	03d88beb6r			; 0.06677
	DD	03d8dd830r			; 0.06926
	DD	03d93111fr			; 0.07181
	DD	03d986445r			; 0.07441
	DD	03d9dd6e0r			; 0.07707
	DD	03da368f1r			; 0.07979
	DD	03da91a76r			; 0.08257
	DD	03daeeb70r			; 0.08541
	DD	03db4dbe0r			; 0.08831
	DD	03dbae686r			; 0.09126
	DD	03dc115dfr			; 0.09428
	DD	03dc75f70r			; 0.09735
	DD	03dcdc875r			; 0.10048
	DD	03dd4562er			; 0.10368
	DD	03ddafe1er			; 0.10693
	DD	03de1cac1r			; 0.11025
	DD	03de8b19ar			; 0.11362
	DD	03defbd27r			; 0.11706
	DD	03df6e829r			; 0.12056
	DD	03dfe2d62r			; 0.12411
	DD	03e02cba7r			; 0.12773
	DD	03e069058r			; 0.13141
	DD	03e0a64c3r			; 0.13515
	DD	03e0e48e9r			; 0.13895
	DD	03e123cc9r			; 0.14281
	DD	03e164064r			; 0.14673
	DD	03e1a5658r			; 0.15072
	DD	03e1e7968r			; 0.15476
	DD	03e22ac32r			; 0.15886
	DD	03e26f156r			; 0.16303
	DD	03e2b4396r			; 0.16725
	DD	03e2fa58fr			; 0.17153
	DD	03e341744r			; 0.17587
	DD	03e389b52r			; 0.18028
	DD	03e3d2c7cr			; 0.18474
	DD	03e41cd60r			; 0.18926
	DD	03e467b5fr			; 0.19383
	DD	03e4b3bb8r			; 0.19847
	DD	03e50092dr			; 0.20316
	DD	03e54e65cr			; 0.20791
	DD	03e59d346r			; 0.21272
	DD	03e5ecfear			; 0.21759
	DD	03e63d9a9r			; 0.22251
	DD	03e68f084r			; 0.22748
	DD	03e6e171ar			; 0.23251
	DD	03e734d6ar			; 0.2376
	DD	03e7890d6r			; 0.24274
	DD	03e7de15dr			; 0.24793
	DD	03e81a0cfr			; 0.25318
	DD	03e84577er			; 0.25848
	DD	03e8714bar			; 0.26383
	DD	03e89d884r			; 0.26923
	DD	03e8ca2dbr			; 0.27468
	DD	03e8f73c1r			; 0.28018
	DD	03e924b34r			; 0.28573
	DD	03e952935r			; 0.29133
	DD	03e980c74r			; 0.29697
	DD	03e9af640r			; 0.30266
	DD	03e9de69br			; 0.3084
	DD	03ea0dc33r			; 0.31418
	DD	03ea3d85ar			; 0.32001
	DD	03ea6d9ber			; 0.32588
	DD	03ea9e061r			; 0.33179
	DD	03eacec42r			; 0.33774
	DD	03eaffeb0r			; 0.34374
	DD	03eb3150er			; 0.34977
	DD	03eb631f9r			; 0.35585
	DD	03eb952d2r			; 0.36196
	DD	03ebc779ar			; 0.3681
	DD	03ebfa1a1r			; 0.37428
	DD	03ec2d0e5r			; 0.3805
	DD	03ec60419r			; 0.38675
	DD	03ec93c8ar			; 0.39304
	DD	03ecc779ar			; 0.39935
	DD	03ecfb7e9r			; 0.4057
	DD	03ed2fad7r			; 0.41207
	DD	03ed641b3r			; 0.41847
	DD	03ed98c7er			; 0.4249
	DD	03edcdb38r			; 0.43136
	DD	03ee02c91r			; 0.43784
	DD	03ee38088r			; 0.44434
	DD	03ee6d86fr			; 0.45087
	DD	03eea31a5r			; 0.45741
	DD	03eed8ec9r			; 0.46398
	DD	03ef0ee8dr			; 0.47057
	DD	03ef44fa0r			; 0.47717
	DD	03ef7b353r			; 0.48379
	DD	03efb1855r			; 0.49042
	DD	03efe7ff6r			; 0.49707
	DD	03f00f473r			; 0.50373
	DD	03f02aa3br			; 0.51041
	DD	03f046003r			; 0.51709
	DD	03f061672r			; 0.52378
	DD	03f07cd8ar			; 0.53048
	DD	03f0984a1r			; 0.53718
	DD	03f0b3c60r			; 0.54389
	DD	03f0cf4c7r			; 0.55061
	DD	03f0eac86r			; 0.55732
	DD	03f1064edr			; 0.56404
	DD	03f121cacr			; 0.57075
	DD	03f13d513r			; 0.57747
	DD	03f158cd2r			; 0.58418
	DD	03f174491r			; 0.59089
	DD	03f18fba9r			; 0.59759
	DD	03f1ab2c0r			; 0.60429
	DD	03f1c6888r			; 0.61097
	DD	03f1e1e4fr			; 0.61765
	DD	03f1fd36fr			; 0.62432
	DD	03f2187e8r			; 0.63098
	DD	03f233b10r			; 0.63762
	DD	03f24ed91r			; 0.64425
	DD	03f269ec3r			; 0.65086
	DD	03f284f4cr			; 0.65746
	DD	03f29fe87r			; 0.66404
	DD	03f2bac71r			; 0.6706
	DD	03f2d590cr			; 0.67714
	DD	03f2f03b0r			; 0.68365
	DD	03f30adacr			; 0.69015
	DD	03f3255b0r			; 0.69662
	DD	03f33fc65r			; 0.70307
	DD	03f35a07br			; 0.70948
	DD	03f3743e9r			; 0.71588
	DD	03f38e4b8r			; 0.72224
	DD	03f3a8390r			; 0.72857
	DD	03f3c2118r			; 0.73488
	DD	03f3dbc02r			; 0.74115
	DD	03f3f54f3r			; 0.74739
	DD	03f40eb46r			; 0.75359
	DD	03f427fa2r			; 0.75976
	DD	03f44115er			; 0.76589
	DD	03f45a123r			; 0.77199
	DD	03f472e49r			; 0.77805
	DD	03f48b8d0r			; 0.78407
	DD	03f4a40b8r			; 0.79005
	DD	03f4bc600r			; 0.79599
	DD	03f4d48aar			; 0.80189
	DD	03f4ec80cr			; 0.80774
	DD	03f5044d0r			; 0.81355
	DD	03f51bef5r			; 0.81932
	DD	03f5335d2r			; 0.82504
	DD	03f54aa11r			; 0.83072
	DD	03f561b09r			; 0.83635
	DD	03f578961r			; 0.84194
	DD	03f58f3cbr			; 0.84747
	DD	03f5a5b96r			; 0.85296
	DD	03f5bc01ar			; 0.8584
	DD	03f5d20b0r			; 0.86378
	DD	03f5e7ea6r			; 0.86912
	DD	03f5fd955r			; 0.87441
	DD	03f613016r			; 0.87964
	DD	03f628390r			; 0.88482
	DD	03f63d3c3r			; 0.88995
	DD	03f6520b0r			; 0.89503
	DD	03f6669adr			; 0.90005
	DD	03f67af64r			; 0.90502
	DD	03f68f12cr			; 0.90993
	DD	03f6a2fadr			; 0.91479
	DD	03f6b6a40r			; 0.91959
	DD	03f6ca18cr			; 0.92434
	DD	03f6dd4e9r			; 0.92903
	DD	03f6f0457r			; 0.93366
	DD	03f70307fr			; 0.93824
	DD	03f7158b8r			; 0.94276
	DD	03f727daar			; 0.94723
	DD	03f739e06r			; 0.95163
	DD	03f74bb1br			; 0.95598
	DD	03f75d441r			; 0.96027
	DD	03f76ea21r			; 0.96451
	DD	03f77fb6ar			; 0.96868
	DD	03f79096cr			; 0.9728
	DD	03f7a137fr			; 0.97686
	DD	03f7b19a4r			; 0.98086
	DD	03f7c1c82r			; 0.98481
	DD	03f7d1acar			; 0.98869
	DD	03f7e15car			; 0.99252
	DD	03f7f0cddr			; 0.99629
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03727c5acr			; 1e-05
	DD	037a7c5acr			; 2e-05
	DD	037fba882r			; 3e-05
	DD	03851b717r			; 5e-05
	DD	038a7c5acr			; 8e-05
	DD	03908509cr			; 0.00013
	DD	0393cbe62r			; 0.00018
	DD	03983126fr			; 0.00025
	DD	039ad03dar			; 0.00033
	DD	039dc3372r			; 0.00042
	DD	03a0d8ec9r			; 0.00054
	DD	03a2fa2f0r			; 0.00067
	DD	03a59945br			; 0.00083
	DD	03a8461far			; 0.00101
	DD	03a9e98ddr			; 0.00121
	DD	03abb6ed6r			; 0.00143
	DD	03adc3372r			; 0.00168
	DD	03b007358r			; 0.00196
	DD	03b14c448r			; 0.00227
	DD	03b2b0c89r			; 0.00261
	DD	03b43f3e0r			; 0.00299
	DD	03b5e2ac3r			; 0.00339
	DD	03b7b00bdr			; 0.00383
	DD	03b8d3ae7r			; 0.00431
	DD	03b9e44far			; 0.00483
	DD	03bb04ab6r			; 0.00538
	DD	03bc3f3e0r			; 0.00598
	DD	03bd898b3r			; 0.00661
	DD	03beee0f4r			; 0.00729
	DD	03c036651r			; 0.00802
	DD	03c1003efr			; 0.00879
	DD	03c1d7343r			; 0.00961
	DD	03c2bb44er			; 0.01048
	DD	03c3ac711r			; 0.0114
	DD	03c4aab8ar			; 0.01237
	DD	03c5b8bacr			; 0.0134
	DD	03c6d1394r			; 0.01447
	DD	03c7fc116r			; 0.01561
	DD	03c89a027r			; 0.0168
	DD	03c93c89fr			; 0.01804
	DD	03c9e83e4r			; 0.01935
	DD	03ca9bcfdr			; 0.02072
	DD	03cb573ebr			; 0.02215
	DD	03cc1a8acr			; 0.02364
	DD	03cce703br			; 0.0252
	DD	03cdbb59er			; 0.02682
	DD	03ce978d5r			; 0.0285
	DD	03cf7e3d2r			; 0.03026
	DD	03d036651r			; 0.03208
	DD	03d0b2420r			; 0.03397
	DD	03d1335d2r			; 0.03594
	DD	03d1b866er			; 0.03797
	DD	03d242071r			; 0.04007
	DD	03d2d0e56r			; 0.04225
	DD	03d36501er			; 0.04451
	DD	03d3fdb4dr			; 0.04684
	DD	03d49afe2r			; 0.04924
	DD	03d53d85ar			; 0.05172
	DD	03d5e54b5r			; 0.05428
	DD	03d691a76r			; 0.05691
	DD	03d743e96r			; 0.05963
	DD	03d7fac1dr			; 0.06242
	DD	03d85bc02r			; 0.0653
	DD	03d8bc6a8r			; 0.06825
	DD	03d92007er			; 0.07129
	DD	03d986445r			; 0.07441
	DD	03d9ef1fer			; 0.07761
	DD	03da5a9a8r			; 0.08089
	DD	03dac9082r			; 0.08426
	DD	03db3a14dr			; 0.08771
	DD	03dbae148r			; 0.09125
	DD	03dc24b34r			; 0.09487
	DD	03dc9df11r			; 0.09857
	DD	03dd1a21fr			; 0.10236
	DD	03dd98f1dr			; 0.10623
	DD	03de1ab4br			; 0.11019
	DD	03de9f16br			; 0.11423
	DD	03df266bar			; 0.11836
	DD	03dfb05fbr			; 0.12257
	DD	03e01ea36r			; 0.12687
	DD	03e066666r			; 0.13125
	DD	03e0af790r			; 0.13571
	DD	03e0fa2f0r			; 0.14027
	DD	03e1460aar			; 0.1449
	DD	03e1935fcr			; 0.14962
	DD	03e1e2047r			; 0.15442
	DD	03e232229r			; 0.15931
	DD	03e283665r			; 0.16427
	DD	03e2d6239r			; 0.16932
	DD	03e32a305r			; 0.17445
	DD	03e37f8cbr			; 0.17966
	DD	03e3d6627r			; 0.18496
	DD	03e42e5der			; 0.19033
	DD	03e487a8dr			; 0.19578
	DD	03e4e2196r			; 0.2013
	DD	03e53e037r			; 0.20691
	DD	03e59b131r			; 0.21259
	DD	03e5f9485r			; 0.21834
	DD	03e658cd2r			; 0.22417
	DD	03e6b9778r			; 0.23007
	DD	03e71b717r			; 0.23605
	DD	03e77e671r			; 0.24209
	DD	03e7e2824r			; 0.2482
	DD	03e823e18r			; 0.25438
	DD	03e85714cr			; 0.26063
	DD	03e88ac5cr			; 0.26694
	DD	03e8bf099r			; 0.27332
	DD	03e8f3cb4r			; 0.27976
	DD	03e9290acr			; 0.28626
	DD	03e95ec81r			; 0.29282
	DD	03e995033r			; 0.29944
	DD	03e9cba73r			; 0.30611
	DD	03ea02c91r			; 0.31284
	DD	03ea3a53cr			; 0.31962
	DD	03ea725c4r			; 0.32646
	DD	03eaaab8ar			; 0.33334
	DD	03eae37dfr			; 0.34027
	DD	03eb1c971r			; 0.34724
	DD	03eb56191r			; 0.35426
	DD	03eb8feefr			; 0.36132
	DD	03ebca18cr			; 0.36842
	DD	03ec04966r			; 0.37556
	DD	03ec3f530r			; 0.38273
	DD	03ec7a637r			; 0.38994
	DD	03ecb5b2dr			; 0.39718
	DD	03ecf1412r			; 0.40445
	DD	03ed2cf96r			; 0.41174
	DD	03ed69058r			; 0.41907
	DD	03eda5269r			; 0.42641
	DD	03ede186ar			; 0.43378
	DD	03ee1dfb9r			; 0.44116
	DD	03ee5a9a8r			; 0.44856
	DD	03ee97636r			; 0.45598
	DD	03eed42c4r			; 0.4634
	DD	03ef111f1r			; 0.47084
	DD	03ef4e11er			; 0.47828
	DD	03ef8b19ar			; 0.48573
	DD	03efc8366r			; 0.49319
	DD	03f0029f1r			; 0.50064
	DD	03f021230r			; 0.50809
	DD	03f03fa6er			; 0.51554
	DD	03f05e204r			; 0.52298
	DD	03f07c99br			; 0.53042
	DD	03f09afe2r			; 0.53784
	DD	03f0b9581r			; 0.54525
	DD	03f0d7a78r			; 0.55265
	DD	03f0f5d79r			; 0.56002
	DD	03f113fd1r			; 0.56738
	DD	03f1320dar			; 0.57472
	DD	03f14ffebr			; 0.58203
	DD	03f16ddadr			; 0.58932
	DD	03f18b978r			; 0.59658
	DD	03f1a934br			; 0.60381
	DD	03f1c6b27r			; 0.61101
	DD	03f1e4064r			; 0.61817
	DD	03f201301r			; 0.62529
	DD	03f21e3a8r			; 0.63238
	DD	03f23b1afr			; 0.63943
	DD	03f257c70r			; 0.64643
	DD	03f274491r			; 0.65339
	DD	03f290a13r			; 0.66031
	DD	03f2acba7r			; 0.66717
	DD	03f2c8a9cr			; 0.67399
	DD	03f2e45a2r			; 0.68075
	DD	03f2ffd61r			; 0.68746
	DD	03f31b1d9r			; 0.69412
	DD	03f336263r			; 0.70072
	DD	03f350efer			; 0.70726
	DD	03f36b852r			; 0.71375
	DD	03f385d10r			; 0.72017
	DD	03f39fddfr			; 0.72653
	DD	03f3b9a17r			; 0.73282
	DD	03f3d3261r			; 0.73905
	DD	03f3ec6bdr			; 0.74522
	DD	03f4055dar			; 0.75131
	DD	03f41e109r			; 0.75734
	DD	03f4367a1r			; 0.7633
	DD	03f44e8fbr			; 0.76918
	DD	03f466666r			; 0.775
	DD	03f47de94r			; 0.78074
	DD	03f495183r			; 0.7864
	DD	03f4abfdbr			; 0.79199
	DD	03f4c299er			; 0.79751
	DD	03f4d8e22r			; 0.80295
	DD	03f4eed67r			; 0.80831
	DD	03f50476fr			; 0.81359
	DD	03f519ce0r			; 0.8188
	DD	03f52ed14r			; 0.82393
	DD	03f543809r			; 0.82898
	DD	03f557d18r			; 0.83394
	DD	03f56bd90r			; 0.83883
	DD	03f57f8cbr			; 0.84364
	DD	03f592e1fr			; 0.84836
	DD	03f5a5eddr			; 0.85301
	DD	03f5b8a5dr			; 0.85758
	DD	03f5caff7r			; 0.86206
	DD	03f5dd053r			; 0.86646
	DD	03f5eeb70r			; 0.87078
	DD	03f600150r			; 0.87502
	DD	03f6111f1r			; 0.87918
	DD	03f621d54r			; 0.88326
	DD	03f632379r			; 0.88726
	DD	03f64245fr			; 0.89118
	DD	03f651f60r			; 0.89501
	DD	03f6615car			; 0.89877
	DD	03f6706f7r			; 0.90245
	DD	03f67f2e5r			; 0.90605
	DD	03f68d994r			; 0.90957
	DD	03f69bb06r			; 0.91301
	DD	03f6a97e1r			; 0.91638
	DD	03f6b6ed6r			; 0.91966
	DD	03f6c41ddr			; 0.92288
	DD	03f6d0efer			; 0.92601
	DD	03f6dd830r			; 0.92908
	DD	03f6e9b7cr			; 0.93206
	DD	03f6f5ad9r			; 0.93498
	DD	03f7014f9r			; 0.93782
	DD	03f70ca82r			; 0.94059
	DD	03f717b74r			; 0.94329
	DD	03f7227d0r			; 0.94592
	DD	03f72cf96r			; 0.94848
	DD	03f7372c5r			; 0.95097
	DD	03f74115er			; 0.95339
	DD	03f74ac08r			; 0.95575
	DD	03f75421cr			; 0.95804
	DD	03f75d441r			; 0.96027
	DD	03f766278r			; 0.96244
	DD	03f76ec18r			; 0.96454
	DD	03f7771c9r			; 0.96658
	DD	03f77f38cr			; 0.96856
	DD	03f787208r			; 0.97049
	DD	03f78ebeer			; 0.97235
	DD	03f79628dr			; 0.97416
	DD	03f79d53dr			; 0.97591
	DD	03f7a43fer			; 0.9776
	DD	03f7aaf79r			; 0.97924
	DD	03f7b17adr			; 0.98083
	DD	03f7b7c9ar			; 0.98237
	DD	03f7bde40r			; 0.98386
	DD	03f7c3c9fr			; 0.9853
	DD	03f7c97b7r			; 0.98669
	DD	03f7cef89r			; 0.98803
	DD	03f7d44bbr			; 0.98933
	DD	03f7d96a7r			; 0.99058
	DD	03f7de5f3r			; 0.99179
	DD	03f7e31f9r			; 0.99295
	DD	03f7e7c07r			; 0.99408
	DD	03f7ec2cer			; 0.99516
	DD	03f7f06f7r			; 0.9962
	DD	03f7f4928r			; 0.99721
	DD	03f7f8812r			; 0.99817
	DD	03f7fc505r			; 0.9991
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03727c5acr			; 1e-05
	DD	037a7c5acr			; 2e-05
	DD	03851b717r			; 5e-05
	DD	038a7c5acr			; 8e-05
	DD	038fba882r			; 0.00012
	DD	039473abdr			; 0.00019
	DD	03988509cr			; 0.00026
	DD	039bcbe62r			; 0.00036
	DD	039fba882r			; 0.00048
	DD	03a252696r			; 0.00063
	DD	03a51b717r			; 0.0008
	DD	03a81c2e3r			; 0.00099
	DD	03a9fe868r			; 0.00122
	DD	03ac1fc8fr			; 0.00148
	DD	03ae94ee4r			; 0.00178
	DD	03b0a47edr			; 0.00211
	DD	03b232f45r			; 0.00249
	DD	03b3e0dedr			; 0.0029
	DD	03b5b8bacr			; 0.00335
	DD	03b7cf80er			; 0.00386
	DD	03b902de0r			; 0.0044
	DD	03ba3d70ar			; 0.005
	DD	03bb923a3r			; 0.00565
	DD	03bd0678cr			; 0.00636
	DD	03be8fb01r			; 0.00711
	DD	03c01ecd5r			; 0.00793
	DD	03c1057d1r			; 0.00881
	DD	03c1fbe77r			; 0.00975
	DD	03c3020c5r			; 0.01075
	DD	03c41a8acr			; 0.01182
	DD	03c542c3dr			; 0.01295
	DD	03c67ff58r			; 0.01416
	DD	03c7cce1cr			; 0.01543
	DD	03c897636r			; 0.01678
	DD	03c952d23r			; 0.01821
	DD	03ca176der			; 0.01971
	DD	03cae685er			; 0.02129
	DD	03cbc01a3r			; 0.02295
	DD	03cca42afr			; 0.02469
	DD	03cd94079r			; 0.02652
	DD	03ce8e608r			; 0.02843
	DD	03cf94856r			; 0.03043
	DD	03d0533b1r			; 0.03252
	DD	03d0e171ar			; 0.03469
	DD	03d17635er			; 0.03696
	DD	03d21187er			; 0.03933
	DD	03d2b2181r			; 0.04178
	DD	03d359360r			; 0.04433
	DD	03d406e1ar			; 0.04698
	DD	03d4bb1afr			; 0.04973
	DD	03d575e20r			; 0.05258
	DD	03d6368f1r			; 0.05552
	DD	03d6fe719r			; 0.05857
	DD	03d7cce1cr			; 0.06172
	DD	03d85143cr			; 0.06498
	DD	03d8bf5d8r			; 0.06834
	DD	03d930be1r			; 0.0718
	DD	03d9a5b96r			; 0.07537
	DD	03da1e4f7r			; 0.07905
	DD	03da9a2c6r			; 0.08283
	DD	03db19a41r			; 0.08672
	DD	03db9cb68r			; 0.09072
	DD	03dc2363br			; 0.09483
	DD	03dcadabar			; 0.09905
	DD	03dd3b3a7r			; 0.10337
	DD	03ddccb7dr			; 0.10781
	DD	03de61d00r			; 0.11236
	DD	03defa2f0r			; 0.11701
	DD	03df967cbr			; 0.12178
	DD	03e01b08ar			; 0.12665
	DD	03e06ca04r			; 0.13163
	DD	03e0c02f3r			; 0.13673
	DD	03e115619r			; 0.14193
	DD	03e16c615r			; 0.14724
	DD	03e1c5048r			; 0.15265
	DD	03e21f751r			; 0.15817
	DD	03e27bb30r			; 0.1638
	DD	03e2d9be5r			; 0.16954
	DD	03e3396d1r			; 0.17538
	DD	03e39abf3r			; 0.18132
	DD	03e3fddecr			; 0.18737
	DD	03e46277cr			; 0.19351
	DD	03e4c8de3r			; 0.19976
	DD	03e530be1r			; 0.2061
	DD	03e59a6b5r			; 0.21255
	DD	03e605682r			; 0.21908
	DD	03e672325r			; 0.22572
	DD	03e6e04c0r			; 0.23244
	DD	03e750093r			; 0.23926
	DD	03e7c115er			; 0.24616
	DD	03e819e30r			; 0.25316
	DD	03e853cder			; 0.26023
	DD	03e88e758r			; 0.26739
	DD	03e8c9d9dr			; 0.27464
	DD	03e905d10r			; 0.28196
	DD	03e9425afr			; 0.28935
	DD	03e97fa1ar			; 0.29683
	DD	03e9bd662r			; 0.30437
	DD	03e9fbbd8r			; 0.31198
	DD	03ea3aa7ar			; 0.31966
	DD	03ea7a0f9r			; 0.3274
	DD	03eaba0a5r			; 0.33521
	DD	03eafa6dfr			; 0.34307
	DD	03eb3b4f6r			; 0.35099
	DD	03eb7c99br			; 0.35896
	DD	03ebbe61dr			; 0.36699
	DD	03ec007ddr			; 0.37506
	DD	03ec42edcr			; 0.38317
	DD	03ec85c68r			; 0.39133
	DD	03ecc8de3r			; 0.39952
	DD	03ed0c49cr			; 0.40775
	DD	03ed4ff43r			; 0.41601
	DD	03ed93c8ar			; 0.42429
	DD	03edd7f0fr			; 0.43261
	DD	03ee1c2e3r			; 0.44094
	DD	03ee60957r			; 0.44929
	DD	03eea5269r			; 0.45766
	DD	03eee9ccbr			; 0.46604
	DD	03ef2e87dr			; 0.47443
	DD	03ef7357er			; 0.48283
	DD	03efb8130r			; 0.49122
	DD	03effce31r			; 0.49962
	DD	03f020cf2r			; 0.50801
	DD	03f043223r			; 0.51639
	DD	03f0656acr			; 0.52476
	DD	03f087a8dr			; 0.53312
	DD	03f0a9d1fr			; 0.54146
	DD	03f0cbe62r			; 0.54978
	DD	03f0eddadr			; 0.55807
	DD	03f10fb01r			; 0.56633
	DD	03f131705r			; 0.57457
	DD	03f15306ar			; 0.58277
	DD	03f174730r			; 0.59093
	DD	03f195b57r			; 0.59905
	DD	03f1b6cdfr			; 0.60713
	DD	03f1d7b20r			; 0.61516
	DD	03f1f861ar			; 0.62314
	DD	03f218dcer			; 0.63107
	DD	03f23923ar			; 0.63895
	DD	03f259210r			; 0.64676
	DD	03f278e9fr			; 0.65452
	DD	03f298698r			; 0.66221
	DD	03f2b7aa2r			; 0.66984
	DD	03f2d696er			; 0.67739
	DD	03f2f544cr			; 0.68488
	DD	03f3139ebr			; 0.69229
	DD	03f331af4r			; 0.69963
	DD	03f34f6ber			; 0.70689
	DD	03f36cd4br			; 0.71407
	DD	03f389e99r			; 0.72117
	DD	03f3a6a01r			; 0.72818
	DD	03f3c302br			; 0.73511
	DD	03f3df06fr			; 0.74195
	DD	03f3faacer			; 0.7487
	DD	03f415f46r			; 0.75536
	DD	03f430d30r			; 0.76192
	DD	03f44b535r			; 0.76839
	DD	03f465754r			; 0.77477
	DD	03f47f2e5r			; 0.78105
	DD	03f4987e8r			; 0.78723
	DD	03f4b165dr			; 0.79331
	DD	03f4c9eedr			; 0.7993
	DD	03f4e2047r			; 0.80518
	DD	03f4f9b13r			; 0.81096
	DD	03f510f52r			; 0.81664
	DD	03f527c5br			; 0.82221
	DD	03f53e2d6r			; 0.82768
	DD	03f5542c4r			; 0.83305
	DD	03f569c24r			; 0.83832
	DD	03f57eda6r			; 0.84347
	DD	03f593943r			; 0.84853
	DD	03f5a7daar			; 0.85348
	DD	03f5bbadcr			; 0.85832
	DD	03f5cf180r			; 0.86306
	DD	03f5e2196r			; 0.8677
	DD	03f5f4a77r			; 0.87223
	DD	03f606ccar			; 0.87666
	DD	03f6187e8r			; 0.88098
	DD	03f629d1fr			; 0.88521
	DD	03f63ab22r			; 0.88933
	DD	03f64b1eer			; 0.89334
	DD	03f65b2d5r			; 0.89726
	DD	03f66ad2er			; 0.90108
	DD	03f67a0f9r			; 0.9048
	DD	03f688e37r			; 0.90842
	DD	03f6974e6r			; 0.91194
	DD	03f6a55b0r			; 0.91537
	DD	03f6b2fecr			; 0.9187
	DD	03f6c039br			; 0.92193
	DD	03f6cd20br			; 0.92508
	DD	03f6d99edr			; 0.92813
	DD	03f6e5bear			; 0.93109
	DD	03f6f1801r			; 0.93396
	DD	03f6fced9r			; 0.93675
	DD	03f707fccr			; 0.93945
	DD	03f712ad8r			; 0.94206
	DD	03f71d0a6r			; 0.94459
	DD	03f727137r			; 0.94704
	DD	03f730c89r			; 0.94941
	DD	03f73a1f5r			; 0.95169
	DD	03f743372r			; 0.95391
	DD	03f74bf0ar			; 0.95604
	DD	03f75460br			; 0.9581
	DD	03f75c875r			; 0.96009
	DD	03f76464ar			; 0.96201
	DD	03f76bf87r			; 0.96386
	DD	03f77342fr			; 0.96564
	DD	03f77a440r			; 0.96735
	DD	03f781062r			; 0.969
	DD	03f787896r			; 0.97059
	DD	03f78dcdbr			; 0.97212
	DD	03f793c8ar			; 0.97358
	DD	03f7998f2r			; 0.97499
	DD	03f79f16br			; 0.97634
	DD	03f7a469dr			; 0.97764
	DD	03f7a97e1r			; 0.97888
	DD	03f7ae5der			; 0.98007
	DD	03f7b313cr			; 0.98122
	DD	03f7b78abr			; 0.98231
	DD	03f7bbd7br			; 0.98336
	DD	03f7bff04r			; 0.98436
	DD	03f7c3d47r			; 0.98531
	DD	03f7c7992r			; 0.98623
	DD	03f7cb296r			; 0.9871
	DD	03f7ce8fbr			; 0.98793
	DD	03f7d1d69r			; 0.98873
	DD	03f7d4f37r			; 0.98949
	DD	03f7d7e67r			; 0.99021
	DD	03f7dab9fr			; 0.9909
	DD	03f7dd639r			; 0.99155
	DD	03f7dff82r			; 0.99218
	DD	03f7e262dr			; 0.99277
	DD	03f7e4ae0r			; 0.99333
	DD	03f7e6e44r			; 0.99387
	DD	03f7e8f08r			; 0.99437
	DD	03f7eaf25r			; 0.99486
	DD	03f7ecca3r			; 0.99531
	DD	03f7ee979r			; 0.99575
	DD	03f7f0457r			; 0.99616
	DD	03f7f1d3fr			; 0.99654
	DD	03f7f357er			; 0.99691
	DD	03f7f4c6er			; 0.99726
	DD	03f7f620fr			; 0.99759
	DD	03f7f7660r			; 0.9979
	DD	03f7f8961r			; 0.99819
	DD	03f7f9bbbr			; 0.99847
	DD	03f7facc5r			; 0.99873
	DD	03f7fbc7fr			; 0.99897
	DD	03f7fcb92r			; 0.9992
	DD	03f7fd9fdr			; 0.99942
	DD	03f7fe7c0r			; 0.99963
	DD	03f7ff434r			; 0.99982
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03727c5acr			; 1e-05
	DD	037fba882r			; 3e-05
	DD	0387ba882r			; 6e-05
	DD	038d1b717r			; 0.0001
	DD	039324207r			; 0.00017
	DD	03983126fr			; 0.00025
	DD	039b78034r			; 0.00035
	DD	039fba882r			; 0.00048
	DD	03a27c5acr			; 0.00064
	DD	03a59945br			; 0.00083
	DD	03a8aefb3r			; 0.00106
	DD	03aad03dar			; 0.00132
	DD	03ad5a5b9r			; 0.00163
	DD	03b011b1er			; 0.00197
	DD	03b1b5200r			; 0.00237
	DD	03b3827far			; 0.00281
	DD	03b5844d0r			; 0.0033
	DD	03b7c5048r			; 0.00385
	DD	03b922531r			; 0.00446
	DD	03ba8198fr			; 0.00513
	DD	03bbfb15br			; 0.00585
	DD	03bd9e83er			; 0.00665
	DD	03bf61672r			; 0.00751
	DD	03c0a71der			; 0.00845
	DD	03c1ad42cr			; 0.00945
	DD	03c2caff7r			; 0.01054
	DD	03c3fb15br			; 0.0117
	DD	03c542c3dr			; 0.01295
	DD	03c69f6a9r			; 0.01428
	DD	03c808851r			; 0.01569
	DD	03c8cd20br			; 0.01719
	DD	03c99ed7cr			; 0.01879
	DD	03ca7c5acr			; 0.02048
	DD	03cb66f93r			; 0.02227
	DD	03cc5d639r			; 0.02415
	DD	03cd6238er			; 0.02614
	DD	03ce72da1r			; 0.02822
	DD	03cf9335dr			; 0.03042
	DD	03d060568r			; 0.03272
	DD	03d0fe47ar			; 0.03513
	DD	03d1a36e3r			; 0.03765
	DD	03d24fca4r			; 0.04028
	DD	03d30403ar			; 0.04303
	DD	03d3bf727r			; 0.04589
	DD	03d482be9r			; 0.04887
	DD	03d54e8fbr			; 0.05198
	DD	03d621965r			; 0.0552
	DD	03d6fd220r			; 0.05855
	DD	03d7e08afr			; 0.06202
	DD	03d865e89r			; 0.06561
	DD	03d8dfce3r			; 0.06933
	DD	03d95df65r			; 0.07318
	DD	03d9e0610r			; 0.07716
	DD	03da670e3r			; 0.08127
	DD	03daf1aa0r			; 0.0855
	DD	03db80dc3r			; 0.08987
	DD	03dc1450fr			; 0.09437
	DD	03dcac083r			; 0.099
	DD	03dd4801fr			; 0.10376
	DD	03dde8922r			; 0.10866
	DD	03de8d64dr			; 0.11369
	DD	03df36263r			; 0.11884
	DD	03dfe3d1dr			; 0.12414
	DD	03e04ab60r			; 0.12956
	DD	03e0a5ce6r			; 0.13512
	DD	03e102de0r			; 0.1408
	DD	03e16238er			; 0.14662
	DD	03e1c3b4fr			; 0.15257
	DD	03e227525r			; 0.15865
	DD	03e28ce70r			; 0.16485
	DD	03e2f49cfr			; 0.17118
	DD	03e35e743r			; 0.17764
	DD	03e3ca6car			; 0.18423
	DD	03e438327r			; 0.19093
	DD	03e4a8199r			; 0.19776
	DD	03e519f80r			; 0.20471
	DD	03e58da3cr			; 0.21177
	DD	03e60346er			; 0.21895
	DD	03e67ae14r			; 0.22625
	DD	03e6f41f2r			; 0.23365
	DD	03e76f545r			; 0.24117
	DD	03e7ec2cer			; 0.24879
	DD	03e835697r			; 0.25652
	DD	03e8758e2r			; 0.26435
	DD	03e8b6849r			; 0.27228
	DD	03e8f837br			; 0.2803
	DD	03e93abc9r			; 0.28842
	DD	03e97de94r			; 0.29662
	DD	03e9c1e79r			; 0.30492
	DD	03ea0678cr			; 0.31329
	DD	03ea4bc6ar			; 0.32175
	DD	03ea91a76r			; 0.33028
	DD	03ead82fdr			; 0.33889
	DD	03eb1f362r			; 0.34756
	DD	03eb66cf4r			; 0.3563
	DD	03ebaee63r			; 0.3651
	DD	03ebf77afr			; 0.37396
	DD	03ec40789r			; 0.38287
	DD	03ec89df1r			; 0.39183
	DD	03ecd3ae7r			; 0.40084
	DD	03ed1dd1ar			; 0.40989
	DD	03ed6833cr			; 0.41897
	DD	03edb2e9dr			; 0.42809
	DD	03edfdc9cr			; 0.43723
	DD	03ee48e8ar			; 0.4464
	DD	03ee94318r			; 0.45559
	DD	03eedf8f4r			; 0.46479
	DD	03ef2b170r			; 0.47401
	DD	03ef769ecr			; 0.48323
	DD	03efc2268r			; 0.49245
	DD	03f006d72r			; 0.50167
	DD	03f02c908r			; 0.51088
	DD	03f0523f6r			; 0.52008
	DD	03f077e3dr			; 0.52927
	DD	03f09d68cr			; 0.53843
	DD	03f0c2d8cr			; 0.54757
	DD	03f0e8295r			; 0.55668
	DD	03f10d4fer			; 0.56575
	DD	03f132570r			; 0.57479
	DD	03f157343r			; 0.58379
	DD	03f17bdcfr			; 0.59274
	DD	03f1a0514r			; 0.60164
	DD	03f1c486br			; 0.61048
	DD	03f1e887br			; 0.61927
	DD	03f20c3f4r			; 0.62799
	DD	03f22fb7fr			; 0.63665
	DD	03f252e73r			; 0.64524
	DD	03f275cd1r			; 0.65376
	DD	03f2985f0r			; 0.6622
	DD	03f2ba9d2r			; 0.67056
	DD	03f2dc7cer			; 0.67883
	DD	03f2fe08br			; 0.68702
	DD	03f31f2bbr			; 0.69511
	DD	03f33ffacr			; 0.70312
	DD	03f360610r			; 0.71103
	DD	03f3805e6r			; 0.71884
	DD	03f39ff2er			; 0.72655
	DD	03f3bf141r			; 0.73415
	DD	03f3ddcc6r			; 0.74165
	DD	03f3fc116r			; 0.74904
	DD	03f419e30r			; 0.75632
	DD	03f43736dr			; 0.76348
	DD	03f454174r			; 0.77053
	DD	03f470846r			; 0.77747
	DD	03f48c693r			; 0.78428
	DD	03f4a7daar			; 0.79098
	DD	03f4c2ce4r			; 0.79756
	DD	03f4dd399r			; 0.80401
	DD	03f4f7319r			; 0.81035
	DD	03f51096cr			; 0.81655
	DD	03f529889r			; 0.82264
	DD	03f541e79r			; 0.82859
	DD	03f559d34r			; 0.83443
	DD	03f5712c2r			; 0.84013
	DD	03f588073r			; 0.84571
	DD	03f59e647r			; 0.85117
	DD	03f5b42eer			; 0.85649
	DD	03f5c97b7r			; 0.86169
	DD	03f5de4a4r			; 0.86677
	DD	03f5f290br			; 0.87172
	DD	03f6064edr			; 0.87654
	DD	03f6198f2r			; 0.88124
	DD	03f62c472r			; 0.88581
	DD	03f63e814r			; 0.89026
	DD	03f6503dar			; 0.89459
	DD	03f6617c2r			; 0.8988
	DD	03f6723cdr			; 0.90289
	DD	03f6827far			; 0.90686
	DD	03f69244ar			; 0.91071
	DD	03f6a1965r			; 0.91445
	DD	03f6b06a3r			; 0.91807
	DD	03f6bec03r			; 0.92157
	DD	03f6ccad5r			; 0.92497
	DD	03f6da273r			; 0.92826
	DD	03f6e7232r			; 0.93143
	DD	03f6f3b64r			; 0.9345
	DD	03f6ffe09r			; 0.93747
	DD	03f70ba1fr			; 0.94034
	DD	03f716f00r			; 0.9431
	DD	03f721dfcr			; 0.94577
	DD	03f72c5c1r			; 0.94833
	DD	03f736849r			; 0.95081
	DD	03f740443r			; 0.95319
	DD	03f749a56r			; 0.95548
	DD	03f752a84r			; 0.95768
	DD	03f75b574r			; 0.9598
	DD	03f763a7er			; 0.96183
	DD	03f76ba49r			; 0.96378
	DD	03f7734d7r			; 0.96565
	DD	03f77aa26r			; 0.96744
	DD	03f781adfr			; 0.96916
	DD	03f788701r			; 0.97081
	DD	03f78ede5r			; 0.97238
	DD	03f795033r			; 0.97388
	DD	03f79ae92r			; 0.97532
	DD	03f7a085br			; 0.97669
	DD	03f7a5eddr			; 0.97801
	DD	03f7ab0c9r			; 0.97926
	DD	03f7afec5r			; 0.98045
	DD	03f7b48d4r			; 0.98158
	DD	03f7b8f9br			; 0.98266
	DD	03f7bd31cr			; 0.98369
	DD	03f7c1355r			; 0.98467
	DD	03f7c5048r			; 0.9856
	DD	03f7c89f4r			; 0.98648
	DD	03f7cc101r			; 0.98732
	DD	03f7cf4c7r			; 0.98811
	DD	03f7d25eer			; 0.98886
	DD	03f7d551dr			; 0.98958
	DD	03f7d8106r			; 0.99025
	DD	03f7daaf8r			; 0.99089
	DD	03f7dd24ar			; 0.99149
	DD	03f7df7a5r			; 0.99206
	DD	03f7e1b09r			; 0.9926
	DD	03f7e3c75r			; 0.99311
	DD	03f7e5bear			; 0.99359
	DD	03f7e7968r			; 0.99404
	DD	03f7e94eer			; 0.99446
	DD	03f7eaf25r			; 0.99486
	DD	03f7ec765r			; 0.99523
	DD	03f7edefcr			; 0.99559
	DD	03f7ef49dr			; 0.99592
	DD	03f7f08eer			; 0.99623
	DD	03f7f1befr			; 0.99652
	DD	03f7f2da1r			; 0.99679
	DD	03f7f3eabr			; 0.99705
	DD	03f7f4e66r			; 0.99729
	DD	03f7f5cd1r			; 0.99751
	DD	03f7f6a94r			; 0.99772
	DD	03f7f77afr			; 0.99792
	DD	03f7f837br			; 0.9981
	DD	03f7f8e9fr			; 0.99827
	DD	03f7f991cr			; 0.99843
	DD	03f7fa249r			; 0.99857
	DD	03f7fab75r			; 0.99871
	DD	03f7fb3far			; 0.99884
	DD	03f7fbbd8r			; 0.99896
	DD	03f7fc30dr			; 0.99907
	DD	03f7fc99br			; 0.99917
	DD	03f7fcf81r			; 0.99926
	DD	03f7fd567r			; 0.99935
	DD	03f7fdaa5r			; 0.99943
	DD	03f7fdfe3r			; 0.99951
	DD	03f7fe47ar			; 0.99958
	DD	03f7fe868r			; 0.99964
	DD	03f7fec57r			; 0.9997
	DD	03f7fef9er			; 0.99975
	DD	03f7ff2e5r			; 0.9998
	DD	03f7ff62br			; 0.99985
	DD	03f7ff8cbr			; 0.99989
	DD	03f7ffb6ar			; 0.99993
	DD	03f7ffe09r			; 0.99997
	DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_06LLMJLOGJ@gr_md2@
CONST	SEGMENT
??_C@_06LLMJLOGJ@gr_md2@ DB 'gr_md2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FNJAPEGP@Old@
CONST	SEGMENT
??_C@_03FNJAPEGP@Old@ DB 'Old', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IBNFDMGB@gr_solvetjoin@
CONST	SEGMENT
??_C@_0O@IBNFDMGB@gr_solvetjoin@ DB 'gr_solvetjoin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IJGGDDPK@gr_correcttricks@
CONST	SEGMENT
??_C@_0BB@IJGGDDPK@gr_correcttricks@ DB 'gr_correcttricks', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFELLCOO@gr_anisotropicmode@
CONST	SEGMENT
??_C@_0BD@FFELLCOO@gr_anisotropicmode@ DB 'gr_anisotropicmode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JOBKFGEH@gr_filtermode@
CONST	SEGMENT
??_C@_0O@JOBKFGEH@gr_filtermode@ DB 'gr_filtermode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GLMKKOKP@150@
CONST	SEGMENT
??_C@_03GLMKKOKP@150@ DB '150', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BJBEMDAE@gr_fogdensity@
CONST	SEGMENT
??_C@_0O@BJBEMDAE@gr_fogdensity@ DB 'gr_fogdensity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PEECMOAB@90@
CONST	SEGMENT
??_C@_02PEECMOAB@90@ DB '90', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PEIIFMII@gr_fov@
CONST	SEGMENT
??_C@_06PEIIFMII@gr_fov@ DB 'gr_fov', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMIELGC@gr_beta@
CONST	SEGMENT
??_C@_07GMIELGC@gr_beta@ DB 'gr_beta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFCNMGME@gr_clipwalls@
CONST	SEGMENT
??_C@_0N@IFCNMGME@gr_clipwalls@ DB 'gr_clipwalls', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNOJEIGN@Nearest_Mipmap@
CONST	SEGMENT
??_C@_0P@FNOJEIGN@Nearest_Mipmap@ DB 'Nearest_Mipmap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NDMMCAFH@Nearest_Linear@
CONST	SEGMENT
??_C@_0P@NDMMCAFH@Nearest_Linear@ DB 'Nearest_Linear', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LLHPLAOD@Linear_Nearest@
CONST	SEGMENT
??_C@_0P@LLHPLAOD@Linear_Nearest@ DB 'Linear_Nearest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KAHAONAF@Trilinear@
CONST	SEGMENT
??_C@_09KAHAONAF@Trilinear@ DB 'Trilinear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLDNHHDN@Bilinear@
CONST	SEGMENT
??_C@_08DLDNHHDN@Bilinear@ DB 'Bilinear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07COOCJBJB@Nearest@
CONST	SEGMENT
??_C@_07COOCJBJB@Nearest@ DB 'Nearest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEPPJAKI@MAX@
CONST	SEGMENT
??_C@_03LEPPJAKI@MAX@ DB 'MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGHEHEMH@MIN@
CONST	SEGMENT
??_C@_03KGHEHEMH@MIN@ DB 'MIN', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_granisotropicmode_cons_t DD 01H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	010H
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_cv_grfov DD	FLAT:??_C@_06PEIIFMII@gr_fov@
	DD	FLAT:??_C@_02PEECMOAB@90@
	DD	012H
	DD	FLAT:_grfov_cons_t
	DD	FLAT:_CV_grFov_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grmd2 DD	FLAT:??_C@_06LLMJLOGJ@gr_md2@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	00H
	DD	FLAT:_CV_MD2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grfogdensity DD FLAT:??_C@_0O@BJBEMDAE@gr_fogdensity@
	DD	FLAT:??_C@_03GLMKKOKP@150@
	DD	00H
	DD	FLAT:_CV_Unsigned
	DD	FLAT:_CV_FogDensity_ONChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grfiltermode DD FLAT:??_C@_0O@JOBKFGEH@gr_filtermode@
	DD	FLAT:??_C@_07COOCJBJB@Nearest@
	DD	02H
	DD	FLAT:_grfiltermode_cons_t
	DD	FLAT:_CV_filtermode_ONChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_granisotropicmode DD FLAT:??_C@_0BD@FFELLCOO@gr_anisotropicmode@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	02H
	DD	FLAT:_granisotropicmode_cons_t
	DD	FLAT:_CV_anisotropic_ONChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grcorrecttricks DD FLAT:??_C@_0BB@IJGGDDPK@gr_correcttricks@
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	00H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grsolvetjoin DD FLAT:??_C@_0O@IBNFDMGB@gr_solvetjoin@
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	00H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_grfov_cons_t DD 00H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	0b30000H
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_grfiltermode_cons_t DD 00H
	DD	FLAT:??_C@_07COOCJBJB@Nearest@
	DD	01H
	DD	FLAT:??_C@_08DLDNHHDN@Bilinear@
	DD	02H
	DD	FLAT:??_C@_09KAHAONAF@Trilinear@
	DD	03H
	DD	FLAT:??_C@_0P@LLHPLAOD@Linear_Nearest@
	DD	04H
	DD	FLAT:??_C@_0P@NDMMCAFH@Nearest_Linear@
	DD	05H
	DD	FLAT:??_C@_0P@FNOJEIGN@Nearest_Mipmap@
	DD	00H
	DD	00H
_drawsky DD	01H
_CV_MD2	DD	00H
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	02H
	DD	FLAT:??_C@_03FNJAPEGP@Old@
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	_HWR_Startup
PUBLIC	_HWR_Shutdown
PUBLIC	_HWR_RenderPlayerView
PUBLIC	_HWR_InitTextureMapping
PUBLIC	_HWR_SetViewSize
PUBLIC	_HWR_AddCommands
PUBLIC	_transform
PUBLIC	_HWR_TranstableToAlpha
PUBLIC	_HWR_SetPaletteColor
PUBLIC	_HWR_GetTextureUsed
PUBLIC	_HWR_DoPostProcessor
PUBLIC	_HWR_StartScreenWipe
PUBLIC	_HWR_EndScreenWipe
PUBLIC	_HWR_DoScreenWipe
PUBLIC	_HWR_PrepFadeToBlack
PUBLIC	_HWR_DrawIntermissionBG
PUBLIC	_HWR_Lighting
PUBLIC	_LightLevelToLum
PUBLIC	_HWR_AddTransparentFloor
PUBLIC	??_C@_0DF@NEHIKJG@polygon?5size?5of?5?$CFd?5exceeds?5max?5@ ; `string'
PUBLIC	??_C@_06OJKJKEJ@?$CFd?9?$CFd?$HM@		; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6@				; `string'
PUBLIC	??_C@_0EO@KAIJHMKB@Warning?3?5Mobj?5of?5type?5?$CFi?5with?5i@ ; `string'
PUBLIC	??_C@_0FJ@NMFIBIGD@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@ ; `string'
PUBLIC	??_C@_0BN@JHLLNGNP@Patch?5info?5headers?3?5?$CF7Iu?5kb?6@ ; `string'
PUBLIC	??_C@_0BN@OJPDBFNN@3D?5Texture?5cache?5?5?3?5?$CF7Iu?5kb?6@ ; `string'
PUBLIC	??_C@_0BN@HKDLFOAP@Plane?5polygon?5?5?5?5?5?3?5?$CF7Iu?5kb?6@ ; `string'
PUBLIC	??_C@_08EPIIELDA@gr_stats@			; `string'
PUBLIC	??_C@_0P@OBNNGKIE@HWR_Startup?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_07JPGFNJGE@FWATER1@			; `string'
PUBLIC	??_C@_06JBMCCDFI@WATER0@			; `string'
PUBLIC	??_C@_0BA@BOHMIMOL@HWR_Shutdown?$CI?$CJ?6@	; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3d0f5c29
PUBLIC	__real@3d340000
PUBLIC	__real@3e6147ae
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3fcccccd
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40400000
PUBLIC	__real@4076800000000000
PUBLIC	__real@407f5c29
PUBLIC	__real@40800000
PUBLIC	__real@40900000
PUBLIC	__real@40b00000
PUBLIC	__real@41300000
PUBLIC	__real@42000000
PUBLIC	__real@42240000
PUBLIC	__real@42480000
PUBLIC	__real@42800000
PUBLIC	__real@42c80000
PUBLIC	__real@42fe0000
PUBLIC	__real@43000000
PUBLIC	__real@43480000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43a00000
PUBLIC	__real@44000000
PUBLIC	__real@4434c299
PUBLIC	__real@44800000
PUBLIC	__real@44cff0b8
PUBLIC	__real@45000000
PUBLIC	__real@45a32000
PUBLIC	__real@471d2300
PUBLIC	__real@47800000
PUBLIC	__real@bf800000
PUBLIC	__real@c0800000
PUBLIC	__real@c2480000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_abs:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_FixedAngle:PROC
EXTRN	_COM_AddCommand:PROC
EXTRN	_CV_RegisterVar:PROC
EXTRN	_CV_Set:PROC
EXTRN	_NetUpdate:PROC
EXTRN	_HWR_InitPolyPool:PROC
EXTRN	_HWR_FreePolyPool:PROC
EXTRN	_HWR_InitTextureCache:PROC
EXTRN	_HWR_FreeTextureCache:PROC
EXTRN	_HWR_FreeExtraSubsectors:PROC
EXTRN	_HWR_GetFlat:PROC
EXTRN	_HWR_GetTexture:PROC
EXTRN	_HWR_GetMappedPatch:PROC
EXTRN	_HWR_InitMD2:PROC
EXTRN	_HWR_DrawMD2:PROC
EXTRN	_I_FinishUpdate:PROC
EXTRN	_P_ReturnThrustX:PROC
EXTRN	_P_ReturnThrustY:PROC
EXTRN	_P_SetPlayerMobjState:PROC
EXTRN	_P_SetMobjState:PROC
EXTRN	_R_PointOnSide:PROC
EXTRN	_R_PointToAngle:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_R_SetupFrame:PROC
EXTRN	_R_SortPolyObjects:PROC
EXTRN	_R_FakeFlat:PROC
EXTRN	_R_GetPlaneLight:PROC
EXTRN	_R_Prep3DFloors:PROC
EXTRN	_W_CheckNumForName:PROC
EXTRN	_W_GetNumForName:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_CachePatchNum:PROC
EXTRN	_Z_CheckHeap:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_Z_ReallocAlign:PROC
EXTRN	_Z_TagUsage:PROC
EXTRN	_ST_doPaletteStuff:PROC
EXTRN	_I_OsPolling:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol3:PROC
EXTRN	_gamestate:DWORD
EXTRN	_M_Memcpy:DWORD
EXTRN	_finesine:BYTE
EXTRN	_finecosine:DWORD
EXTRN	_finetangent:BYTE
EXTRN	_sprnames:BYTE
EXTRN	_maptol:WORD
EXTRN	_netgame:DWORD
EXTRN	_multiplayer:DWORD
EXTRN	_splitscreen:DWORD
EXTRN	_cv_debug:DWORD
EXTRN	_postimgtype:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_cv_objectplace:BYTE
EXTRN	_vid:BYTE
EXTRN	_cv_grrenderquality:BYTE
EXTRN	_cv_grfog:BYTE
EXTRN	_cv_grsoftwarefog:BYTE
EXTRN	_extrasubsectors:DWORD
EXTRN	_gr_patch_scalex:DWORD
EXTRN	_gr_patch_scaley:DWORD
EXTRN	_patchformat:DWORD
EXTRN	_textureformat:DWORD
EXTRN	_md2_models:BYTE
EXTRN	_md2_playermodels:BYTE
EXTRN	_rendermode:DWORD
EXTRN	_leveltime:DWORD
EXTRN	_cv_cam_rotate:BYTE
EXTRN	_cv_cam2_rotate:BYTE
EXTRN	_stplyr:DWORD
EXTRN	_levelflats:DWORD
EXTRN	_textureheight:DWORD
EXTRN	_spritecachedinfo:DWORD
EXTRN	_colormaps:DWORD
EXTRN	_texturetranslation:DWORD
EXTRN	_numsprites:DWORD
EXTRN	_sprites:DWORD
EXTRN	_segs:DWORD
EXTRN	_sectors:DWORD
EXTRN	_numsubsectors:DWORD
EXTRN	_subsectors:DWORD
EXTRN	_numnodes:DWORD
EXTRN	_nodes:DWORD
EXTRN	_sides:DWORD
EXTRN	_viewx:DWORD
EXTRN	_viewy:DWORD
EXTRN	_viewz:DWORD
EXTRN	_viewangle:DWORD
EXTRN	_aimingangle:DWORD
EXTRN	_sscount:DWORD
EXTRN	_textures:DWORD
EXTRN	_viewcos:DWORD
EXTRN	_viewsin:DWORD
EXTRN	_validcount:DWORD
EXTRN	_cv_limitdraw:BYTE
EXTRN	_cv_shadow:BYTE
EXTRN	_cv_shadowoffs:BYTE
EXTRN	_checkcoord:BYTE
EXTRN	_numpolys:DWORD
EXTRN	_po_ptrs:DWORD
EXTRN	_skytexture:DWORD
EXTRN	_skyflatnum:DWORD
EXTRN	_skins:BYTE
EXTRN	_translationtables:BYTE
EXTRN	_defaulttranslationtables:DWORD
EXTRN	_bosstranslationtables:DWORD
EXTRN	_players:BYTE
EXTRN	_localangle:DWORD
EXTRN	_localangle2:DWORD
EXTRN	_localaiming:DWORD
EXTRN	_localaiming2:DWORD
EXTRN	_objectsdrawn:WORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_gr_clipangle DD 01H DUP (?)
_gr_viewangletox DD 01000H DUP (?)
_gr_xtoviewangle DD 0781H DUP (?)
_gr_basecentery DD 01H DUP (?)
_gr_centerx DD	01H DUP (?)
_gr_centery DD	01H DUP (?)
_gr_viewwindowy DD 01H DUP (?)
_gr_windowcenterx DD 01H DUP (?)
_gr_windowcentery DD 01H DUP (?)
_gr_pspritexscale DD 01H DUP (?)
_gr_pspriteyscale DD 01H DUP (?)
_gr_curline DD	01H DUP (?)
_gr_sidedef DD	01H DUP (?)
_gr_linedef DD	01H DUP (?)
_gr_frontsector DD 01H DUP (?)
_gr_backsector DD 01H DUP (?)
_dup_viewx DD	01H DUP (?)
_dup_viewy DD	01H DUP (?)
_dup_viewz DD	01H DUP (?)
_dup_viewangle DD 01H DUP (?)
_gr_viewx DD	01H DUP (?)
_gr_viewy DD	01H DUP (?)
_gr_viewz DD	01H DUP (?)
_gr_viewsin DD	01H DUP (?)
_gr_viewcos DD	01H DUP (?)
_gr_viewludsin DD 01H DUP (?)
_gr_viewludcos DD 01H DUP (?)
_gr_fovlud DD	01H DUP (?)
_lightleveltonumlut DB 0100H DUP (?)
_planeVerts DB	0c000H DUP (?)
_hw_newend DD	01H DUP (?)
_gr_solidsegs DQ 03c1H DUP (?)
_doomwaterflat DD 01H DUP (?)
_gr_vissprites DB 01a000H DUP (?)
_gr_vissprite_p DD 01H DUP (?)
_gr_overflowsprite DB 034H DUP (?)
_gr_vsprsortedhead DB 034H DUP (?)
_wallinfo DD	01H DUP (?)
_numwalls DD	01H DUP (?)
_numplanes DD	01H DUP (?)
_planeinfo DD	01H DUP (?)
_drawcount DD	01H DUP (?)
_sectorlight DB	01H DUP (?)
	ALIGN	4

?startupdone@?1??HWR_Startup@@9@9 DD 01H DUP (?)	; `HWR_Startup'::`2'::startupdone
	ALIGN	8

?disStart@?2??HWR_DoPostProcessor@@9@9 DQ 01H DUP (?)	; `HWR_DoPostProcessor'::`3'::disStart
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c2480000
CONST	SEGMENT
__real@c2480000 DD 0c2480000r			; -50
CONST	ENDS
;	COMDAT __real@c0800000
CONST	SEGMENT
__real@c0800000 DD 0c0800000r			; -4
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@471d2300
CONST	SEGMENT
__real@471d2300 DD 0471d2300r			; 40227
CONST	ENDS
;	COMDAT __real@45a32000
CONST	SEGMENT
__real@45a32000 DD 045a32000r			; 5220
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@44cff0b8
CONST	SEGMENT
__real@44cff0b8 DD 044cff0b8r			; 1663.52
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@4434c299
CONST	SEGMENT
__real@4434c299 DD 04434c299r			; 723.041
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42240000
CONST	SEGMENT
__real@42240000 DD 042240000r			; 41
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@40b00000
CONST	SEGMENT
__real@40b00000 DD 040b00000r			; 5.5
CONST	ENDS
;	COMDAT __real@40900000
CONST	SEGMENT
__real@40900000 DD 040900000r			; 4.5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@407f5c29
CONST	SEGMENT
__real@407f5c29 DD 0407f5c29r			; 3.99
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fcccccd
CONST	SEGMENT
__real@3fcccccd DD 03fcccccdr			; 1.6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3e6147ae
CONST	SEGMENT
__real@3e6147ae DD 03e6147aer			; 0.22
CONST	ENDS
;	COMDAT __real@3d340000
CONST	SEGMENT
__real@3d340000 DD 03d340000r			; 0.0439453
CONST	ENDS
;	COMDAT __real@3d0f5c29
CONST	SEGMENT
__real@3d0f5c29 DD 03d0f5c29r			; 0.035
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BA@BOHMIMOL@HWR_Shutdown?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BA@BOHMIMOL@HWR_Shutdown?$CI?$CJ?6@ DB 'HWR_Shutdown()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBMCCDFI@WATER0@
CONST	SEGMENT
??_C@_06JBMCCDFI@WATER0@ DB 'WATER0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPGFNJGE@FWATER1@
CONST	SEGMENT
??_C@_07JPGFNJGE@FWATER1@ DB 'FWATER1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OBNNGKIE@HWR_Startup?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0P@OBNNGKIE@HWR_Startup?$CI?$CJ?6@ DB 'HWR_Startup()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPIIELDA@gr_stats@
CONST	SEGMENT
??_C@_08EPIIELDA@gr_stats@ DB 'gr_stats', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HKDLFOAP@Plane?5polygon?5?5?5?5?5?3?5?$CF7Iu?5kb?6@
CONST	SEGMENT
??_C@_0BN@HKDLFOAP@Plane?5polygon?5?5?5?5?5?3?5?$CF7Iu?5kb?6@ DB 'Plane p'
	DB	'olygon     : %7Iu kb', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OJPDBFNN@3D?5Texture?5cache?5?5?3?5?$CF7Iu?5kb?6@
CONST	SEGMENT
??_C@_0BN@OJPDBFNN@3D?5Texture?5cache?5?5?3?5?$CF7Iu?5kb?6@ DB '3D Textur'
	DB	'e cache  : %7Iu kb', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JHLLNGNP@Patch?5info?5headers?3?5?$CF7Iu?5kb?6@
CONST	SEGMENT
??_C@_0BN@JHLLNGNP@Patch?5info?5headers?3?5?$CF7Iu?5kb?6@ DB 'Patch info '
	DB	'headers: %7Iu kb', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@NMFIBIGD@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@
CONST	SEGMENT
??_C@_0FJ@NMFIBIGD@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@ DB 'Warning'
	DB	': Mobj of type %d with invalid sprite frame (%u/%Iu) of %s de'
	DB	'tected and removed.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@KAIJHMKB@Warning?3?5Mobj?5of?5type?5?$CFi?5with?5i@
CONST	SEGMENT
??_C@_0EO@KAIJHMKB@Warning?3?5Mobj?5of?5type?5?$CFi?5with?5i@ DB 'Warning'
	DB	': Mobj of type %i with invalid sprite data (%d) detected and '
	DB	'removed.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6@ DB 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJKJKEJ@?$CFd?9?$CFd?$HM@
CONST	SEGMENT
??_C@_06OJKJKEJ@?$CFd?9?$CFd?$HM@ DB '%d-%d|', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NEHIKJG@polygon?5size?5of?5?$CFd?5exceeds?5max?5@
CONST	SEGMENT
??_C@_0DF@NEHIKJG@polygon?5size?5of?5?$CFd?5exceeds?5max?5@ DB 'polygon s'
	DB	'ize of %d exceeds max value of %d vertices', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_cv_grclipwalls DD FLAT:??_C@_0N@IFCNMGME@gr_clipwalls@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	00H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grbeta DD	FLAT:??_C@_07GMIELGC@gr_beta@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	00H
	DD	FLAT:_CV_Unsigned
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_HWRWipeCounter DD 03f800000r			; 1
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0426H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c3dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02274H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	014fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0496H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddEngineCommands
_TEXT	SEGMENT
_HWR_AddEngineCommands PROC				; COMDAT

; 4906 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4907 : 	// engine state variables
; 4908 : 	CV_RegisterVar(&cv_grclipwalls);

  00009	68 00 00 00 00	 push	 OFFSET _cv_grclipwalls
  0000e	e8 00 00 00 00	 call	 _CV_RegisterVar
  00013	83 c4 04	 add	 esp, 4

; 4909 : 
; 4910 : 	// engine development mode variables
; 4911 : 	// - usage may vary from version to version..
; 4912 : 	CV_RegisterVar(&cv_grbeta);

  00016	68 00 00 00 00	 push	 OFFSET _cv_grbeta
  0001b	e8 00 00 00 00	 call	 _CV_RegisterVar
  00020	83 c4 04	 add	 esp, 4

; 4913 : 
; 4914 : 	// engine commands
; 4915 : 	COM_AddCommand("gr_stats", Command_GrStats_f);

  00023	68 00 00 00 00	 push	 OFFSET _Command_GrStats_f
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_08EPIIELDA@gr_stats@
  0002d	e8 00 00 00 00	 call	 _COM_AddCommand
  00032	83 c4 08	 add	 esp, 8

; 4916 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_HWR_AddEngineCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _Command_GrStats_f
_TEXT	SEGMENT
_Command_GrStats_f PROC					; COMDAT

; 4877 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4878 : 	Z_CheckHeap(9875); // debug

  00009	68 93 26 00 00	 push	 9875			; 00002693H
  0000e	e8 00 00 00 00	 call	 _Z_CheckHeap
  00013	83 c4 04	 add	 esp, 4

; 4879 : 
; 4880 : 	CONS_Printf("Patch info headers: %7"PRIdS" kb\n", Z_TagUsage(PU_HWRPATCHINFO)>>10);

  00016	6a 05		 push	 5
  00018	e8 00 00 00 00	 call	 _Z_TagUsage
  0001d	83 c4 04	 add	 esp, 4
  00020	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JHLLNGNP@Patch?5info?5headers?3?5?$CF7Iu?5kb?6@
  00029	e8 00 00 00 00	 call	 _CONS_Printf
  0002e	83 c4 08	 add	 esp, 8

; 4881 : 	CONS_Printf("3D Texture cache  : %7"PRIdS" kb\n", Z_TagUsage(PU_HWRCACHE)>>10);

  00031	6a 66		 push	 102			; 00000066H
  00033	e8 00 00 00 00	 call	 _Z_TagUsage
  00038	83 c4 04	 add	 esp, 4
  0003b	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OJPDBFNN@3D?5Texture?5cache?5?5?3?5?$CF7Iu?5kb?6@
  00044	e8 00 00 00 00	 call	 _CONS_Printf
  00049	83 c4 08	 add	 esp, 8

; 4882 : 	CONS_Printf("Plane polygon     : %7"PRIdS" kb\n", Z_TagUsage(PU_HWRPLANE)>>10);

  0004c	6a 34		 push	 52			; 00000034H
  0004e	e8 00 00 00 00	 call	 _Z_TagUsage
  00053	83 c4 04	 add	 esp, 4
  00056	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00059	50		 push	 eax
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HKDLFOAP@Plane?5polygon?5?5?5?5?5?3?5?$CF7Iu?5kb?6@
  0005f	e8 00 00 00 00	 call	 _CONS_Printf
  00064	83 c4 08	 add	 esp, 8

; 4883 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_Command_GrStats_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClearView
_TEXT	SEGMENT
_HWR_ClearView PROC					; COMDAT

; 4541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4542 : 	//  3--2
; 4543 : 	//  | /|
; 4544 : 	//  |/ |
; 4545 : 	//  0--1
; 4546 : 
; 4547 : 	/// \bug faB - enable depth mask, disable color mask
; 4548 : 
; 4549 : 	HWD.pfnGClipRect((INT32)gr_viewwindowx,

  00009	51		 push	 ecx
  0000a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@407f5c29
  00012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00017	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewwindowy
  0001f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR _gr_viewheight
  00027	f3 0f 2c c0	 cvttss2si eax, xmm0
  0002b	50		 push	 eax
  0002c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewwindowx
  00034	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR _gr_viewwidth
  0003c	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00040	51		 push	 ecx
  00041	f3 0f 2c 15 00
	00 00 00	 cvttss2si edx, DWORD PTR _gr_viewwindowy
  00049	52		 push	 edx
  0004a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR _gr_viewwindowx
  00052	50		 push	 eax
  00053	ff 15 24 00 00
	00		 call	 DWORD PTR _hwdriver+36
  00059	90		 npad	 1

; 4550 : 	                 (INT32)gr_viewwindowy,
; 4551 : 	                 (INT32)(gr_viewwindowx + gr_viewwidth),
; 4552 : 	                 (INT32)(gr_viewwindowy + gr_viewheight),
; 4553 : 	                 3.99f);
; 4554 : 	HWD.pfnClearBuffer(false, true, 0);

  0005a	6a 00		 push	 0
  0005c	6a 01		 push	 1
  0005e	6a 00		 push	 0
  00060	ff 15 18 00 00
	00		 call	 DWORD PTR _hwdriver+24
  00066	90		 npad	 1

; 4555 : 
; 4556 : 	//disable clip window - set to full size
; 4557 : 	// rem by Hurdler
; 4558 : 	// HWD.pfnGClipRect(0, 0, vid.width, vid.height);
; 4559 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_HWR_ClearView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DrawSkyBackground
_TEXT	SEGMENT
tv301 = -184						; size = 8
tv187 = -176						; size = 4
tv203 = -176						; size = 4
tv234 = -176						; size = 4
tv250 = -176						; size = 4
tv298 = -176						; size = 4
_f$ = -108						; size = 4
_angle$ = -104						; size = 4
_v$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_player$ = 8						; size = 4
_HWR_DrawSkyBackground PROC				; COMDAT

; 4489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4490 : 	FOutVector v[4];
; 4491 : 	angle_t angle;
; 4492 : 	float f;
; 4493 : 
; 4494 : //  3--2
; 4495 : //  | /|
; 4496 : //  |/ |
; 4497 : //  0--1
; 4498 : 
; 4499 : 	player = NULL;

  00016	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _player$[ebp], 0

; 4500 : 	HWR_GetTexture(skytexture);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _HWR_GetTexture
  00028	83 c4 04	 add	 esp, 4

; 4501 : 
; 4502 : 	//Hurdler: the sky is the only texture who need 4.0f instead of 1.0
; 4503 : 	//         because it's called just after clearing the screen
; 4504 : 	//         and thus, the near clipping plane is set to 3.99
; 4505 : 	v[0].x = v[3].x = -4.0f;

  0002b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00030	6b c8 03	 imul	 ecx, eax, 3
  00033	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0800000
  0003b	f3 0f 11 44 0d
	9c		 movss	 DWORD PTR _v$[ebp+ecx], xmm0
  00041	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00046	6b c2 00	 imul	 eax, edx, 0
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0800000
  00051	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _v$[ebp+eax], xmm0

; 4506 : 	v[1].x = v[2].x =  4.0f;

  00057	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0005c	d1 e0		 shl	 eax, 1
  0005e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  00066	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _v$[ebp+eax], xmm0
  0006c	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00071	c1 e1 00	 shl	 ecx, 0
  00074	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0007c	f3 0f 11 44 0d
	9c		 movss	 DWORD PTR _v$[ebp+ecx], xmm0

; 4507 : 	v[0].y = v[1].y = -4.0f;

  00082	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00087	c1 e0 00	 shl	 eax, 0
  0008a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0800000
  00092	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _v$[ebp+eax+4], xmm0
  00098	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0009d	6b d1 00	 imul	 edx, ecx, 0
  000a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0800000
  000a8	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _v$[ebp+edx+4], xmm0

; 4508 : 	v[2].y = v[3].y =  4.0f;

  000ae	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000b3	6b c8 03	 imul	 ecx, eax, 3
  000b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  000be	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _v$[ebp+ecx+4], xmm0
  000c4	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  000c9	d1 e2		 shl	 edx, 1
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  000d3	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _v$[ebp+edx+4], xmm0

; 4509 : 
; 4510 : 	v[0].z = v[1].z = v[2].z = v[3].z = 4.0f;

  000d9	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000de	6b c8 03	 imul	 ecx, eax, 3
  000e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  000e9	f3 0f 11 44 0d
	a4		 movss	 DWORD PTR _v$[ebp+ecx+8], xmm0
  000ef	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  000f4	d1 e2		 shl	 edx, 1
  000f6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  000fe	f3 0f 11 44 15
	a4		 movss	 DWORD PTR _v$[ebp+edx+8], xmm0
  00104	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00109	c1 e0 00	 shl	 eax, 0
  0010c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  00114	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _v$[ebp+eax+8], xmm0
  0011a	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0011f	6b d1 00	 imul	 edx, ecx, 0
  00122	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0012a	f3 0f 11 44 15
	a4		 movss	 DWORD PTR _v$[ebp+edx+8], xmm0

; 4511 : 
; 4512 : 	if (textures[skytexture]->width > 256)

  00130	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  00135	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  0013b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0013e	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00142	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00147	7e 7a		 jle	 SHORT $LN2@HWR_DrawSk

; 4513 : 		angle = (angle_t)((float)(dup_viewangle + gr_xtoviewangle[0])

  00149	b8 04 00 00 00	 mov	 eax, 4
  0014e	6b c8 00	 imul	 ecx, eax, 0
  00151	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewangle
  00157	03 91 00 00 00
	00		 add	 edx, DWORD PTR _gr_xtoviewangle[ecx]
  0015d	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv298[ebp], edx
  00163	f2 0f 2a 85 50
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv298[ebp]
  0016b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv298[ebp]
  00171	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00174	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0017d	f2 0f 11 85 48
	ff ff ff	 movsd	 QWORD PTR tv301[ebp], xmm0
  00185	f2 0f 5a 85 48
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv301[ebp]
  0018d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _skytexture
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _textures
  00199	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0019c	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  001a0	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  001a4	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@43800000
  001ac	f3 0f 5e c1	 divss	 xmm0, xmm1
  001b0	e8 00 00 00 00	 call	 __ftol3
  001b5	33 d2		 xor	 edx, edx
  001b7	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  001bc	f7 f1		 div	 ecx
  001be	89 55 98	 mov	 DWORD PTR _angle$[ebp], edx
  001c1	eb 1f		 jmp	 SHORT $LN3@HWR_DrawSk
$LN2@HWR_DrawSk:

; 4514 : 						/((float)textures[skytexture]->width/256.0f))
; 4515 : 							%(ANGLE_90-1);
; 4516 : 	else
; 4517 : 		angle = (dup_viewangle + gr_xtoviewangle[0])%(ANGLE_90-1);

  001c3	b8 04 00 00 00	 mov	 eax, 4
  001c8	6b c8 00	 imul	 ecx, eax, 0
  001cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewangle
  001d0	03 81 00 00 00
	00		 add	 eax, DWORD PTR _gr_xtoviewangle[ecx]
  001d6	33 d2		 xor	 edx, edx
  001d8	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  001dd	f7 f1		 div	 ecx
  001df	89 55 98	 mov	 DWORD PTR _angle$[ebp], edx
$LN3@HWR_DrawSk:

; 4518 : 
; 4519 : 	f = (float)((textures[skytexture]->width/2)

  001e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  001ed	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001f0	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  001f4	99		 cdq
  001f5	2b c2		 sub	 eax, edx
  001f7	d1 f8		 sar	 eax, 1
  001f9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001fd	8b 45 98	 mov	 eax, DWORD PTR _angle$[ebp]
  00200	c1 f8 14	 sar	 eax, 20			; 00000014H
  00203	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00208	2b c8		 sub	 ecx, eax
  0020a	81 e1 ff 1f 00
	00		 and	 ecx, 8191		; 00001fffH
  00210	f3 0f 2a 0c 8d
	00 00 00 00	 cvtsi2ss xmm1, DWORD PTR _finetangent[ecx*4]
  00219	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@47800000
  00221	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00225	f3 0f 11 45 94	 movss	 DWORD PTR _f$[ebp], xmm0

; 4520 : 	            * FIXED_TO_FLOAT(finetangent[(2048
; 4521 : 	 - ((INT32)angle>>(ANGLETOFINESHIFT + 1))) & FINEMASK]));
; 4522 : 
; 4523 : 	v[0].sow = v[3].sow = 0.22f+(f)/(textures[skytexture]->width/2);

  0022a	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  0022f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  00235	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00238	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0023c	99		 cdq
  0023d	2b c2		 sub	 eax, edx
  0023f	d1 f8		 sar	 eax, 1
  00241	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00245	f3 0f 10 4d 94	 movss	 xmm1, DWORD PTR _f$[ebp]
  0024a	f3 0f 5e c8	 divss	 xmm1, xmm0
  0024e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e6147ae
  00256	f3 0f 58 c1	 addss	 xmm0, xmm1
  0025a	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR tv187[ebp], xmm0
  00262	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00267	6b c8 03	 imul	 ecx, eax, 3
  0026a	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv187[ebp]
  00272	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _v$[ebp+ecx+16], xmm0
  00278	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0027d	6b c2 00	 imul	 eax, edx, 0
  00280	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv187[ebp]
  00288	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _v$[ebp+eax+16], xmm0

; 4524 : 	v[2].sow = v[1].sow = 0.22f+(f+(127))/(textures[skytexture]->width/2);

  0028e	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _f$[ebp]
  00293	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42fe0000
  0029b	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  002a6	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002a9	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  002ad	99		 cdq
  002ae	2b c2		 sub	 eax, edx
  002b0	d1 f8		 sar	 eax, 1
  002b2	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  002b6	f3 0f 5e c1	 divss	 xmm0, xmm1
  002ba	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3e6147ae
  002c2	f3 0f 58 c8	 addss	 xmm1, xmm0
  002c6	f3 0f 11 8d 50
	ff ff ff	 movss	 DWORD PTR tv203[ebp], xmm1
  002ce	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002d3	c1 e0 00	 shl	 eax, 0
  002d6	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv203[ebp]
  002de	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _v$[ebp+eax+16], xmm0
  002e4	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  002e9	d1 e1		 shl	 ecx, 1
  002eb	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv203[ebp]
  002f3	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _v$[ebp+ecx+16], xmm0

; 4525 : 
; 4526 : 	f = (float)((textures[skytexture]->height/2)

  002f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  00304	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00307	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  0030b	99		 cdq
  0030c	2b c2		 sub	 eax, edx
  0030e	d1 f8		 sar	 eax, 1
  00310	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00314	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimingangle
  00319	c1 f8 14	 sar	 eax, 20			; 00000014H
  0031c	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00321	2b c8		 sub	 ecx, eax
  00323	81 e1 ff 1f 00
	00		 and	 ecx, 8191		; 00001fffH
  00329	f3 0f 2a 0c 8d
	00 00 00 00	 cvtsi2ss xmm1, DWORD PTR _finetangent[ecx*4]
  00332	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@47800000
  0033a	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0033e	f3 0f 11 45 94	 movss	 DWORD PTR _f$[ebp], xmm0

; 4527 : 	            * FIXED_TO_FLOAT(finetangent[(2048
; 4528 : 	 - ((INT32)aimingangle>>(ANGLETOFINESHIFT + 1))) & FINEMASK]));
; 4529 : 
; 4530 : 	v[3].tow = v[2].tow = 0.22f+(f)/(textures[skytexture]->height/2);

  00343	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  00348	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  0034e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00351	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  00355	99		 cdq
  00356	2b c2		 sub	 eax, edx
  00358	d1 f8		 sar	 eax, 1
  0035a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0035e	f3 0f 10 4d 94	 movss	 xmm1, DWORD PTR _f$[ebp]
  00363	f3 0f 5e c8	 divss	 xmm1, xmm0
  00367	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e6147ae
  0036f	f3 0f 58 c1	 addss	 xmm0, xmm1
  00373	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR tv234[ebp], xmm0
  0037b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00380	d1 e0		 shl	 eax, 1
  00382	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv234[ebp]
  0038a	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _v$[ebp+eax+20], xmm0
  00390	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00395	6b d1 03	 imul	 edx, ecx, 3
  00398	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv234[ebp]
  003a0	f3 0f 11 44 15
	b0		 movss	 DWORD PTR _v$[ebp+edx+20], xmm0

; 4531 : 	v[0].tow = v[1].tow = 0.22f+(f+(127))/(textures[skytexture]->height/2);

  003a6	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _f$[ebp]
  003ab	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42fe0000
  003b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _skytexture
  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textures
  003be	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  003c1	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  003c5	99		 cdq
  003c6	2b c2		 sub	 eax, edx
  003c8	d1 f8		 sar	 eax, 1
  003ca	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  003ce	f3 0f 5e c1	 divss	 xmm0, xmm1
  003d2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3e6147ae
  003da	f3 0f 58 c8	 addss	 xmm1, xmm0
  003de	f3 0f 11 8d 50
	ff ff ff	 movss	 DWORD PTR tv250[ebp], xmm1
  003e6	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  003eb	c1 e0 00	 shl	 eax, 0
  003ee	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv250[ebp]
  003f6	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _v$[ebp+eax+20], xmm0
  003fc	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00401	6b d1 00	 imul	 edx, ecx, 0
  00404	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR tv250[ebp]
  0040c	f3 0f 11 44 15
	b0		 movss	 DWORD PTR _v$[ebp+edx+20], xmm0

; 4532 : 
; 4533 : 	HWD.pfnDrawPolygon(NULL, v, 4, 0);

  00412	6a 00		 push	 0
  00414	6a 04		 push	 4
  00416	8d 45 9c	 lea	 eax, DWORD PTR _v$[ebp]
  00419	50		 push	 eax
  0041a	6a 00		 push	 0
  0041c	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  00422	90		 npad	 1

; 4534 : }

  00423	5f		 pop	 edi
  00424	5e		 pop	 esi
  00425	5b		 pop	 ebx
  00426	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00429	33 cd		 xor	 ecx, ebp
  0042b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00430	8b e5		 mov	 esp, ebp
  00432	5d		 pop	 ebp
  00433	c3		 ret	 0
_HWR_DrawSkyBackground ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DrawMD2S
_TEXT	SEGMENT
_spr$1 = -4						; size = 4
_HWR_DrawMD2S PROC					; COMDAT

; 4090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4091 : 	if (gr_vissprite_p > gr_vissprites)

  00009	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _gr_vissprite_p, OFFSET _gr_vissprites
  00013	0f 86 ce 00 00
	00		 jbe	 $LN3@HWR_DrawMD

; 4092 : 	{
; 4093 : 		gr_vissprite_t *spr;
; 4094 : 
; 4095 : 		// draw all MD2 back to front
; 4096 : 		for (spr = gr_vsprsortedhead.next;

  00019	a1 04 00 00 00	 mov	 eax, DWORD PTR _gr_vsprsortedhead+4
  0001e	89 45 fc	 mov	 DWORD PTR _spr$1[ebp], eax
  00021	eb 09		 jmp	 SHORT $LN4@HWR_DrawMD
$LN2@HWR_DrawMD:

; 4098 : 			spr = spr->next)

  00023	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	89 4d fc	 mov	 DWORD PTR _spr$1[ebp], ecx
$LN4@HWR_DrawMD:

; 4097 : 			spr != &gr_vsprsortedhead;

  0002c	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _spr$1[ebp], OFFSET _gr_vsprsortedhead
  00033	0f 84 ae 00 00
	00		 je	 $LN3@HWR_DrawMD

; 4099 : 		{
; 4100 : #ifdef HWPRECIP
; 4101 : 			if (!spr->precip)
; 4102 : 			{
; 4103 : #endif
; 4104 : 				if (spr->mobj && spr->mobj->skin)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  0003c	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00040	74 66		 je	 SHORT $LN6@HWR_DrawMD
  00042	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  00045	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00048	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  0004c	74 5a		 je	 SHORT $LN6@HWR_DrawMD

; 4105 : 				{
; 4106 : 					if ((md2_playermodels[(skin_t*)spr->mobj->skin-skins].notfound == false) && (md2_playermodels[(skin_t*)spr->mobj->skin-skins].scale > 0.0f))

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  00051	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00054	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00057	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  0005c	99		 cdq
  0005d	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  00062	f7 f9		 idiv	 ecx
  00064	6b d0 38	 imul	 edx, eax, 56
  00067	83 ba 30 00 00
	00 00		 cmp	 DWORD PTR _md2_playermodels[edx+48], 0
  0006e	75 36		 jne	 SHORT $LN8@HWR_DrawMD
  00070	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  00073	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00076	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00079	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  0007e	99		 cdq
  0007f	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  00084	f7 f9		 idiv	 ecx
  00086	6b d0 38	 imul	 edx, eax, 56
  00089	f3 0f 10 82 20
	00 00 00	 movss	 xmm0, DWORD PTR _md2_playermodels[edx+32]
  00091	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00098	76 0c		 jbe	 SHORT $LN8@HWR_DrawMD

; 4107 : 						HWR_DrawMD2(spr);

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _HWR_DrawMD2
  000a3	83 c4 04	 add	 esp, 4
$LN8@HWR_DrawMD:

; 4108 : 				}

  000a6	eb 3a		 jmp	 SHORT $LN9@HWR_DrawMD
$LN6@HWR_DrawMD:

; 4109 : 				else if (md2_models[spr->mobj->sprite].notfound == false && md2_models[spr->mobj->sprite].scale > 0.0f)

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  000ab	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000ae	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  000b2	83 ba 30 00 00
	00 00		 cmp	 DWORD PTR _md2_models[edx+48], 0
  000b9	75 27		 jne	 SHORT $LN9@HWR_DrawMD
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  000be	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c1	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  000c5	f3 0f 10 82 20
	00 00 00	 movss	 xmm0, DWORD PTR _md2_models[edx+32]
  000cd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000d4	76 0c		 jbe	 SHORT $LN9@HWR_DrawMD

; 4110 : 					HWR_DrawMD2(spr);

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _HWR_DrawMD2
  000df	83 c4 04	 add	 esp, 4
$LN9@HWR_DrawMD:

; 4111 : #ifdef HWPRECIP
; 4112 : 			}
; 4113 : #endif
; 4114 : 		}

  000e2	e9 3c ff ff ff	 jmp	 $LN2@HWR_DrawMD
$LN3@HWR_DrawMD:

; 4115 : 	}
; 4116 : }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
_HWR_DrawMD2S ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DrawSprites
_TEXT	SEGMENT
_spr$1 = -4						; size = 4
_HWR_DrawSprites PROC					; COMDAT

; 4060 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4061 : 	if (gr_vissprite_p > gr_vissprites)

  00009	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _gr_vissprite_p, OFFSET _gr_vissprites
  00013	0f 86 a4 00 00
	00		 jbe	 $LN3@HWR_DrawSp

; 4062 : 	{
; 4063 : 		gr_vissprite_t *spr;
; 4064 : 
; 4065 : 		// draw all vissprites back to front
; 4066 : 		for (spr = gr_vsprsortedhead.next;

  00019	a1 04 00 00 00	 mov	 eax, DWORD PTR _gr_vsprsortedhead+4
  0001e	89 45 fc	 mov	 DWORD PTR _spr$1[ebp], eax
  00021	eb 09		 jmp	 SHORT $LN4@HWR_DrawSp
$LN2@HWR_DrawSp:

; 4068 : 		     spr = spr->next)

  00023	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	89 4d fc	 mov	 DWORD PTR _spr$1[ebp], ecx
$LN4@HWR_DrawSp:

; 4067 : 		     spr != &gr_vsprsortedhead;

  0002c	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _spr$1[ebp], OFFSET _gr_vsprsortedhead
  00033	0f 84 84 00 00
	00		 je	 $LN3@HWR_DrawSp

; 4069 : 		{
; 4070 : #ifdef HWPRECIP
; 4071 : 			if (spr->precip)
; 4072 : 				HWR_DrawPrecipitationSprite(spr);
; 4073 : 			else
; 4074 : #endif
; 4075 : 				if (spr->mobj->skin)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  0003c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0003f	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  00043	74 42		 je	 SHORT $LN6@HWR_DrawSp

; 4076 : 				{
; 4077 : 					if (!cv_grmd2.value || (cv_grmd2.value && md2_playermodels[(skin_t*)spr->mobj->skin-skins].notfound == true))

  00045	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  0004c	74 2b		 je	 SHORT $LN9@HWR_DrawSp
  0004e	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  00055	74 2e		 je	 SHORT $LN8@HWR_DrawSp
  00057	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  0005a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0005d	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00060	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  00065	99		 cdq
  00066	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  0006b	f7 f9		 idiv	 ecx
  0006d	6b d0 38	 imul	 edx, eax, 56
  00070	83 ba 30 00 00
	00 01		 cmp	 DWORD PTR _md2_playermodels[edx+48], 1
  00077	75 0c		 jne	 SHORT $LN8@HWR_DrawSp
$LN9@HWR_DrawSp:

; 4078 : 						HWR_DrawSprite(spr);

  00079	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _HWR_DrawSprite
  00082	83 c4 04	 add	 esp, 4
$LN8@HWR_DrawSp:

; 4079 : 				}

  00085	eb 31		 jmp	 SHORT $LN10@HWR_DrawSp
$LN6@HWR_DrawSp:

; 4080 : 				else if (!cv_grmd2.value || (cv_grmd2.value && md2_models[spr->mobj->sprite].notfound == true))

  00087	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  0008e	74 1c		 je	 SHORT $LN11@HWR_DrawSp
  00090	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  00097	74 1f		 je	 SHORT $LN10@HWR_DrawSp
  00099	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  0009c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0009f	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  000a3	83 ba 30 00 00
	00 01		 cmp	 DWORD PTR _md2_models[edx+48], 1
  000aa	75 0c		 jne	 SHORT $LN10@HWR_DrawSp
$LN11@HWR_DrawSp:

; 4081 : 					HWR_DrawSprite(spr);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _spr$1[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _HWR_DrawSprite
  000b5	83 c4 04	 add	 esp, 4
$LN10@HWR_DrawSp:

; 4082 : 		}

  000b8	e9 66 ff ff ff	 jmp	 $LN2@HWR_DrawSp
$LN3@HWR_DrawSp:

; 4083 : 	}
; 4084 : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_HWR_DrawSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_CreateDrawNodes
_TEXT	SEGMENT
tv195 = -108						; size = 4
tv171 = -104						; size = 4
_temp$1 = -36						; size = 4
_shift$ = -32						; size = 4
_sortindex$ = -28					; size = 4
_sortnode$ = -24					; size = 4
_pviewz$ = -20						; size = 4
_loop$ = -16						; size = 4
_prev$ = -12						; size = 4
_p$ = -8						; size = 4
_i$ = -4						; size = 4
_HWR_CreateDrawNodes PROC				; COMDAT

; 3925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3926 : 	UINT32 i = 0, p = 0, prev = 0, loop;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _prev$[ebp], 0

; 3927 : 	const fixed_t pviewz = dup_viewz;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewz
  00023	89 45 ec	 mov	 DWORD PTR _pviewz$[ebp], eax

; 3928 : 
; 3929 : 	// Dump EVERYTHING into a huge drawnode list. Then we'll sort it!
; 3930 : 	// Could this be optimized into _AddTransparentWall/_AddTransparentPlane?
; 3931 : 	// Hell yes! But sort algorithm must be modified to use a linked list.
; 3932 : 	gr_drawnode_t *sortnode = Z_Calloc((sizeof(planeinfo_t)*numplanes)

  00026	6a 00		 push	 0
  00028	6a 00		 push	 0
  0002a	6a 01		 push	 1
  0002c	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numwalls
  00039	c1 e1 07	 shl	 ecx, 7
  0003c	03 c1		 add	 eax, ecx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _Z_CallocAlign
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 e8	 mov	 DWORD PTR _sortnode$[ebp], eax

; 3933 : 									+ (sizeof(wallinfo_t)*numwalls)
; 3934 : 									,PU_STATIC, NULL);
; 3935 : 	// todo:
; 3936 : 	// However, in reality we shouldn't be re-copying and shifting all this information
; 3937 : 	// that is already lying around. This should all be in some sort of linked list or lists. -Jazz
; 3938 : 	size_t *sortindex = Z_Calloc(sizeof(size_t) * (numplanes + numwalls), PU_STATIC, NULL);

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 01		 push	 1
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _numplanes
  00055	03 05 00 00 00
	00		 add	 eax, DWORD PTR _numwalls
  0005b	c1 e0 02	 shl	 eax, 2
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _Z_CallocAlign
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	89 45 e4	 mov	 DWORD PTR _sortindex$[ebp], eax

; 3939 : 
; 3940 : 	// If true, swap the draw order.
; 3941 : 	boolean shift = false;

  0006a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 0

; 3942 : 
; 3943 : 	for (i = 0; i < numplanes; i++, p++)

  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 12		 jmp	 SHORT $LN4@HWR_Create
$LN2@HWR_Create:
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00086	83 c1 01	 add	 ecx, 1
  00089	89 4d f8	 mov	 DWORD PTR _p$[ebp], ecx
$LN4@HWR_Create:
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numplanes
  00095	73 22		 jae	 SHORT $LN3@HWR_Create

; 3944 : 	{
; 3945 : 		sortnode[p].plane = &planeinfo[i];

  00097	6b 45 fc 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  0009b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _planeinfo
  000a1	6b 4d f8 0c	 imul	 ecx, DWORD PTR _p$[ebp], 12
  000a5	8b 55 e8	 mov	 edx, DWORD PTR _sortnode$[ebp]
  000a8	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 3946 : 		sortindex[p] = p;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000ae	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  000b1	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000b4	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 3947 : 	}

  000b7	eb c1		 jmp	 SHORT $LN2@HWR_Create
$LN3@HWR_Create:

; 3948 : 
; 3949 : 	for (i = 0; i < numwalls; i++, p++)

  000b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c0	eb 12		 jmp	 SHORT $LN7@HWR_Create
$LN5@HWR_Create:
  000c2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c5	83 c0 01	 add	 eax, 1
  000c8	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  000ce	83 c1 01	 add	 ecx, 1
  000d1	89 4d f8	 mov	 DWORD PTR _p$[ebp], ecx
$LN7@HWR_Create:
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numwalls
  000dd	73 25		 jae	 SHORT $LN6@HWR_Create

; 3950 : 	{
; 3951 : 		sortnode[p].wall = &wallinfo[i];

  000df	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e2	c1 e0 07	 shl	 eax, 7
  000e5	03 05 00 00 00
	00		 add	 eax, DWORD PTR _wallinfo
  000eb	6b 4d f8 0c	 imul	 ecx, DWORD PTR _p$[ebp], 12
  000ef	8b 55 e8	 mov	 edx, DWORD PTR _sortnode$[ebp]
  000f2	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 3952 : 		sortindex[p] = p;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000f9	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  000fc	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000ff	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 3953 : 	}

  00102	eb be		 jmp	 SHORT $LN5@HWR_Create
$LN6@HWR_Create:

; 3954 : 
; 3955 : 	// p is the number of stuff to sort
; 3956 : 
; 3957 : 	// Add the 3D floors, thicksides, and masked textures...
; 3958 : 	// Instead of going through drawsegs, we need to iterate
; 3959 : 	// through the lists of masked textures and
; 3960 : 	// translucent ffloors being drawn.
; 3961 : 
; 3962 : 	// This is a bubble sort! Wahoo!
; 3963 : 
; 3964 : 	// Stuff is sorted:
; 3965 : 	//      sortnode[sortindex[0]]   = farthest away
; 3966 : 	//      sortnode[sortindex[p-1]] = closest
; 3967 : 	// "i" should be closer. "prev" should be further.
; 3968 : 	// The lower drawcount is, the further it is from the screen.
; 3969 : 
; 3970 : 	for (loop = 0; loop < p; loop++)

  00104	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _loop$[ebp], 0
  0010b	eb 09		 jmp	 SHORT $LN10@HWR_Create
$LN8@HWR_Create:
  0010d	8b 45 f0	 mov	 eax, DWORD PTR _loop$[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 45 f0	 mov	 DWORD PTR _loop$[ebp], eax
$LN10@HWR_Create:
  00116	8b 45 f0	 mov	 eax, DWORD PTR _loop$[ebp]
  00119	3b 45 f8	 cmp	 eax, DWORD PTR _p$[ebp]
  0011c	0f 83 2e 02 00
	00		 jae	 $LN9@HWR_Create

; 3971 : 	{
; 3972 : 		for (i = 1; i < p; i++)

  00122	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00129	eb 09		 jmp	 SHORT $LN13@HWR_Create
$LN11@HWR_Create:
  0012b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0012e	83 c0 01	 add	 eax, 1
  00131	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@HWR_Create:
  00134	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00137	3b 45 f8	 cmp	 eax, DWORD PTR _p$[ebp]
  0013a	0f 83 0b 02 00
	00		 jae	 $LN12@HWR_Create

; 3973 : 		{
; 3974 : 			prev = i-1;

  00140	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00143	83 e8 01	 sub	 eax, 1
  00146	89 45 f4	 mov	 DWORD PTR _prev$[ebp], eax

; 3975 : 			if (sortnode[sortindex[i]].plane)

  00149	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0014c	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0014f	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00153	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00156	83 3c 10 00	 cmp	 DWORD PTR [eax+edx], 0
  0015a	0f 84 0d 01 00
	00		 je	 $LN17@HWR_Create

; 3976 : 			{
; 3977 : 				// What are we comparing it with?
; 3978 : 				if (sortnode[sortindex[prev]].plane)

  00160	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00163	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00166	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0016a	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  0016d	83 3c 10 00	 cmp	 DWORD PTR [eax+edx], 0
  00171	0f 84 ad 00 00
	00		 je	 $LN19@HWR_Create

; 3979 : 				{
; 3980 : 					// Plane (i) is further away than plane (prev)
; 3981 : 					if (ABS(sortnode[sortindex[i]].plane->fixedheight - pviewz) > ABS(sortnode[sortindex[prev]].plane->fixedheight - pviewz))

  00177	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0017a	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0017d	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00181	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00184	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00187	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0018a	2b 55 ec	 sub	 edx, DWORD PTR _pviewz$[ebp]
  0018d	79 1d		 jns	 SHORT $LN37@HWR_Create
  0018f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00192	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00195	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00199	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  0019c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0019f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a2	2b 55 ec	 sub	 edx, DWORD PTR _pviewz$[ebp]
  001a5	f7 da		 neg	 edx
  001a7	89 55 98	 mov	 DWORD PTR tv171[ebp], edx
  001aa	eb 19		 jmp	 SHORT $LN38@HWR_Create
$LN37@HWR_Create:
  001ac	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001af	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  001b2	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  001b6	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  001b9	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001bc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001bf	2b 55 ec	 sub	 edx, DWORD PTR _pviewz$[ebp]
  001c2	89 55 98	 mov	 DWORD PTR tv171[ebp], edx
$LN38@HWR_Create:
  001c5	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  001c8	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  001cb	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  001cf	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  001d2	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001d8	2b 55 ec	 sub	 edx, DWORD PTR _pviewz$[ebp]
  001db	79 1d		 jns	 SHORT $LN39@HWR_Create
  001dd	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  001e0	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  001e3	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  001e7	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  001ea	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001ed	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001f0	2b 55 ec	 sub	 edx, DWORD PTR _pviewz$[ebp]
  001f3	f7 da		 neg	 edx
  001f5	89 55 94	 mov	 DWORD PTR tv195[ebp], edx
  001f8	eb 19		 jmp	 SHORT $LN40@HWR_Create
$LN39@HWR_Create:
  001fa	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  001fd	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00200	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00204	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00207	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0020a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0020d	2b 55 ec	 sub	 edx, DWORD PTR _pviewz$[ebp]
  00210	89 55 94	 mov	 DWORD PTR tv195[ebp], edx
$LN40@HWR_Create:
  00213	8b 45 98	 mov	 eax, DWORD PTR tv171[ebp]
  00216	3b 45 94	 cmp	 eax, DWORD PTR tv195[ebp]
  00219	7e 07		 jle	 SHORT $LN21@HWR_Create

; 3982 : 						shift = true;

  0021b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 1
$LN21@HWR_Create:

; 3983 : 				}

  00222	eb 44		 jmp	 SHORT $LN23@HWR_Create
$LN19@HWR_Create:

; 3984 : 				else if (sortnode[sortindex[prev]].wall)

  00224	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00227	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0022a	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0022e	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00231	83 7c 10 04 00	 cmp	 DWORD PTR [eax+edx+4], 0
  00236	74 30		 je	 SHORT $LN23@HWR_Create

; 3985 : 				{
; 3986 : 					// Plane (i) is further than wall (prev)
; 3987 : 					if (sortnode[sortindex[i]].plane->drawcount > sortnode[sortindex[prev]].wall->drawcount)

  00238	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0023b	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0023e	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00242	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00245	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00248	8b 55 f4	 mov	 edx, DWORD PTR _prev$[ebp]
  0024b	8b 45 e4	 mov	 eax, DWORD PTR _sortindex$[ebp]
  0024e	6b 14 90 0c	 imul	 edx, DWORD PTR [eax+edx*4], 12
  00252	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00255	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  00259	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0025c	3b 42 70	 cmp	 eax, DWORD PTR [edx+112]
  0025f	7e 07		 jle	 SHORT $LN23@HWR_Create

; 3988 : 						shift = true;

  00261	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 1
$LN23@HWR_Create:

; 3989 : 				}
; 3990 : 			}

  00268	e9 a2 00 00 00	 jmp	 $LN29@HWR_Create
$LN17@HWR_Create:

; 3991 : 			else if (sortnode[sortindex[i]].wall)

  0026d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00270	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00273	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00277	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  0027a	83 7c 10 04 00	 cmp	 DWORD PTR [eax+edx+4], 0
  0027f	0f 84 8a 00 00
	00		 je	 $LN29@HWR_Create

; 3992 : 			{
; 3993 : 				// What are we comparing it with?
; 3994 : 				if (sortnode[sortindex[prev]].plane)

  00285	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00288	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0028b	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0028f	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00292	83 3c 10 00	 cmp	 DWORD PTR [eax+edx], 0
  00296	74 32		 je	 SHORT $LN25@HWR_Create

; 3995 : 				{
; 3996 : 					// Wall (i) is further than plane(prev)
; 3997 : 					if (sortnode[sortindex[i]].wall->drawcount > sortnode[sortindex[prev]].plane->drawcount)

  00298	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0029b	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0029e	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  002a2	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  002a5	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  002a9	8b 55 f4	 mov	 edx, DWORD PTR _prev$[ebp]
  002ac	8b 45 e4	 mov	 eax, DWORD PTR _sortindex$[ebp]
  002af	6b 14 90 0c	 imul	 edx, DWORD PTR [eax+edx*4], 12
  002b3	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  002b6	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  002b9	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  002bc	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  002bf	7e 07		 jle	 SHORT $LN27@HWR_Create

; 3998 : 						shift = true;

  002c1	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 1
$LN27@HWR_Create:

; 3999 : 				}

  002c8	eb 45		 jmp	 SHORT $LN29@HWR_Create
$LN25@HWR_Create:

; 4000 : 				else if (sortnode[sortindex[prev]].wall)

  002ca	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  002cd	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  002d0	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  002d4	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  002d7	83 7c 10 04 00	 cmp	 DWORD PTR [eax+edx+4], 0
  002dc	74 31		 je	 SHORT $LN29@HWR_Create

; 4001 : 				{
; 4002 : 					// Wall (i) is further than wall (prev)
; 4003 : 					if (sortnode[sortindex[i]].wall->drawcount > sortnode[sortindex[prev]].wall->drawcount)

  002de	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002e1	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  002e4	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  002e8	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  002eb	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  002ef	8b 55 f4	 mov	 edx, DWORD PTR _prev$[ebp]
  002f2	8b 45 e4	 mov	 eax, DWORD PTR _sortindex$[ebp]
  002f5	6b 14 90 0c	 imul	 edx, DWORD PTR [eax+edx*4], 12
  002f9	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  002fc	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  00300	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00303	3b 42 70	 cmp	 eax, DWORD PTR [edx+112]
  00306	7e 07		 jle	 SHORT $LN29@HWR_Create

; 4004 : 						shift = true;

  00308	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 1
$LN29@HWR_Create:

; 4005 : 				}
; 4006 : 			}
; 4007 : 
; 4008 : 			if (shift)

  0030f	83 7d e0 00	 cmp	 DWORD PTR _shift$[ebp], 0
  00313	74 31		 je	 SHORT $LN30@HWR_Create

; 4009 : 			{
; 4010 : 				size_t temp;
; 4011 : 
; 4012 : 				temp = sortindex[prev];

  00315	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00318	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0031b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0031e	89 55 dc	 mov	 DWORD PTR _temp$1[ebp], edx

; 4013 : 				sortindex[prev] = sortindex[i];

  00321	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00324	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00327	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0032a	8b 75 e4	 mov	 esi, DWORD PTR _sortindex$[ebp]
  0032d	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  00330	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 4014 : 				sortindex[i] = temp;

  00333	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00336	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00339	8b 55 dc	 mov	 edx, DWORD PTR _temp$1[ebp]
  0033c	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 4015 : 
; 4016 : 				shift = false;

  0033f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _shift$[ebp], 0
$LN30@HWR_Create:

; 4017 : 			}
; 4018 : 
; 4019 : 		} //i++

  00346	e9 e0 fd ff ff	 jmp	 $LN11@HWR_Create
$LN12@HWR_Create:

; 4020 : 	} // loop++

  0034b	e9 bd fd ff ff	 jmp	 $LN8@HWR_Create
$LN9@HWR_Create:

; 4021 : 
; 4022 : 	HWD.pfnSetTransform(&atransform);

  00350	68 00 00 00 00	 push	 OFFSET _atransform
  00355	ff 15 38 00 00
	00		 call	 DWORD PTR _hwdriver+56
  0035b	90		 npad	 1

; 4023 : 	// Okay! Let's draw it all! Woo!
; 4024 : 	for (i = 0; i < p; i++)

  0035c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00363	eb 09		 jmp	 SHORT $LN16@HWR_Create
$LN14@HWR_Create:
  00365	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00368	83 c0 01	 add	 eax, 1
  0036b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@HWR_Create:
  0036e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00371	3b 45 f8	 cmp	 eax, DWORD PTR _p$[ebp]
  00374	0f 83 f4 01 00
	00		 jae	 $LN15@HWR_Create

; 4025 : 	{
; 4026 : 		if (sortnode[sortindex[i]].plane)

  0037a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0037d	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00380	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00384	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00387	83 3c 10 00	 cmp	 DWORD PTR [eax+edx], 0
  0038b	0f 84 04 01 00
	00		 je	 $LN31@HWR_Create

; 4027 : 		{
; 4028 : 			// We aren't traversing the BSP tree, so make gr_frontsector null to avoid crashes.
; 4029 : 			gr_frontsector = NULL;

  00391	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_frontsector, 0

; 4030 : 
; 4031 : 			if (!(sortnode[sortindex[i]].plane->blend & PF_NoTexture))

  0039b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0039e	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  003a1	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  003a5	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  003a8	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  003ab	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  003ae	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  003b4	75 1c		 jne	 SHORT $LN33@HWR_Create

; 4032 : 				HWR_GetFlat(sortnode[sortindex[i]].plane->lumpnum);

  003b6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003b9	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  003bc	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  003c0	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  003c3	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  003c6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003c9	52		 push	 edx
  003ca	e8 00 00 00 00	 call	 _HWR_GetFlat
  003cf	83 c4 04	 add	 esp, 4
$LN33@HWR_Create:

; 4033 : 			HWR_RenderPlane(NULL, sortnode[sortindex[i]].plane->xsub, sortnode[sortindex[i]].plane->fixedheight, sortnode[sortindex[i]].plane->blend, sortnode[sortindex[i]].plane->lightlevel,

  003d2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003d5	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  003d8	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  003dc	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  003df	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  003e2	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  003e5	52		 push	 edx
  003e6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003e9	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  003ec	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  003f0	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  003f3	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  003f6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003f9	52		 push	 edx
  003fa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003fd	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00400	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00404	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00407	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0040a	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  0040e	52		 push	 edx
  0040f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00412	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00415	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00419	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  0041c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0041f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00422	52		 push	 edx
  00423	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00426	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00429	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0042d	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00430	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00433	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00436	52		 push	 edx
  00437	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0043a	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0043d	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00441	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00444	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00447	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0044a	52		 push	 edx
  0044b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0044e	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00451	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00455	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00458	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0045b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0045e	52		 push	 edx
  0045f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00462	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00465	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00469	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  0046c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0046f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00472	52		 push	 edx
  00473	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00476	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00479	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0047d	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00480	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00483	8b 11		 mov	 edx, DWORD PTR [ecx]
  00485	52		 push	 edx
  00486	6a 00		 push	 0
  00488	e8 00 00 00 00	 call	 _HWR_RenderPlane
  0048d	83 c4 28	 add	 esp, 40			; 00000028H

; 4034 : 				sortnode[sortindex[i]].plane->lumpnum, sortnode[sortindex[i]].plane->FOFSector, sortnode[sortindex[i]].plane->alpha, sortnode[sortindex[i]].plane->fogplane, sortnode[sortindex[i]].plane->planecolormap);
; 4035 : 		}

  00490	e9 d4 00 00 00	 jmp	 $LN34@HWR_Create
$LN31@HWR_Create:

; 4036 : 		else if (sortnode[sortindex[i]].wall)

  00495	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00498	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0049b	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0049f	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  004a2	83 7c 10 04 00	 cmp	 DWORD PTR [eax+edx+4], 0
  004a7	0f 84 bc 00 00
	00		 je	 $LN34@HWR_Create

; 4037 : 		{
; 4038 : 			if (!(sortnode[sortindex[i]].wall->blend & PF_NoTexture))

  004ad	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004b0	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  004b3	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  004b7	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  004ba	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  004be	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  004c1	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  004c7	75 1d		 jne	 SHORT $LN35@HWR_Create

; 4039 : 				HWR_GetTexture(sortnode[sortindex[i]].wall->texnum);

  004c9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004cc	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  004cf	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  004d3	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  004d6	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  004da	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  004dd	52		 push	 edx
  004de	e8 00 00 00 00	 call	 _HWR_GetTexture
  004e3	83 c4 04	 add	 esp, 4
$LN35@HWR_Create:

; 4040 : 			HWR_RenderWall(sortnode[sortindex[i]].wall->wallVerts, &sortnode[sortindex[i]].wall->Surf, sortnode[sortindex[i]].wall->blend, sortnode[sortindex[i]].wall->fogwall,

  004e6	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004e9	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  004ec	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  004f0	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  004f3	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  004f7	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  004fa	52		 push	 edx
  004fb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004fe	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00501	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00505	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00508	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  0050c	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  0050f	52		 push	 edx
  00510	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00513	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00516	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0051a	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  0051d	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00521	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00524	52		 push	 edx
  00525	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00528	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  0052b	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  0052f	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00532	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00536	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00539	52		 push	 edx
  0053a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0053d	8b 4d e4	 mov	 ecx, DWORD PTR _sortindex$[ebp]
  00540	6b 14 81 0c	 imul	 edx, DWORD PTR [ecx+eax*4], 12
  00544	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00547	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  0054b	83 c1 60	 add	 ecx, 96			; 00000060H
  0054e	51		 push	 ecx
  0054f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00552	8b 45 e4	 mov	 eax, DWORD PTR _sortindex$[ebp]
  00555	6b 0c 90 0c	 imul	 ecx, DWORD PTR [eax+edx*4], 12
  00559	8b 55 e8	 mov	 edx, DWORD PTR _sortnode$[ebp]
  0055c	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00560	50		 push	 eax
  00561	e8 00 00 00 00	 call	 _HWR_RenderWall
  00566	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@HWR_Create:

; 4041 : 				sortnode[sortindex[i]].wall->lightlevel, sortnode[sortindex[i]].wall->wallcolormap);
; 4042 : 		}
; 4043 : 	}

  00569	e9 f7 fd ff ff	 jmp	 $LN14@HWR_Create
$LN15@HWR_Create:

; 4044 : 
; 4045 : 	numwalls = 0;

  0056e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numwalls, 0

; 4046 : 	numplanes = 0;

  00578	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numplanes, 0

; 4047 : 
; 4048 : 	// No mem leaks, please.
; 4049 : 	Z_Free(sortnode);

  00582	8b 45 e8	 mov	 eax, DWORD PTR _sortnode$[ebp]
  00585	50		 push	 eax
  00586	e8 00 00 00 00	 call	 _Z_Free
  0058b	83 c4 04	 add	 esp, 4

; 4050 : 	Z_Free(sortindex);

  0058e	8b 45 e4	 mov	 eax, DWORD PTR _sortindex$[ebp]
  00591	50		 push	 eax
  00592	e8 00 00 00 00	 call	 _Z_Free
  00597	83 c4 04	 add	 esp, 4

; 4051 : }

  0059a	5f		 pop	 edi
  0059b	5e		 pop	 esi
  0059c	5b		 pop	 ebx
  0059d	8b e5		 mov	 esp, ebp
  0059f	5d		 pop	 ebp
  005a0	c3		 ret	 0
_HWR_CreateDrawNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_RenderWall
_TEXT	SEGMENT
_alpha$ = -109						; size = 1
_wv$ = -108						; size = 4
_i$ = -101						; size = 1
_trVerts$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_wallVerts$ = 8						; size = 4
_pSurf$ = 12						; size = 4
_blend$ = 16						; size = 4
_fogwall$ = 20						; size = 4
_lightlevel$ = 24					; size = 4
_wallcolormap$ = 28					; size = 4
_HWR_RenderWall PROC					; COMDAT

; 5142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 5143 : 	FOutVector  trVerts[4];
; 5144 : 	UINT8       i;
; 5145 : 	FOutVector  *wv;
; 5146 : 
; 5147 : 	// transform
; 5148 : 	wv = trVerts;

  00016	8d 45 9c	 lea	 eax, DWORD PTR _trVerts$[ebp]
  00019	89 45 94	 mov	 DWORD PTR _wv$[ebp], eax

; 5149 : 	// it sounds really stupid to do this conversion with the new T&L code
; 5150 : 	// we should directly put the right information in the right structure
; 5151 : 	// wallVerts3D seems ok, doesn't need FOutVector
; 5152 : 	// also remove the light copy
; 5153 : 	for (i = 0; i < 4; i++, wv++, wallVerts++)

  0001c	c6 45 9b 00	 mov	 BYTE PTR _i$[ebp], 0
  00020	eb 1a		 jmp	 SHORT $LN4@HWR_Render
$LN2@HWR_Render:
  00022	8a 45 9b	 mov	 al, BYTE PTR _i$[ebp]
  00025	04 01		 add	 al, 1
  00027	88 45 9b	 mov	 BYTE PTR _i$[ebp], al
  0002a	8b 4d 94	 mov	 ecx, DWORD PTR _wv$[ebp]
  0002d	83 c1 18	 add	 ecx, 24			; 00000018H
  00030	89 4d 94	 mov	 DWORD PTR _wv$[ebp], ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  00036	83 c2 18	 add	 edx, 24			; 00000018H
  00039	89 55 08	 mov	 DWORD PTR _wallVerts$[ebp], edx
$LN4@HWR_Render:
  0003c	0f b6 45 9b	 movzx	 eax, BYTE PTR _i$[ebp]
  00040	83 f8 04	 cmp	 eax, 4
  00043	7d 3c		 jge	 SHORT $LN3@HWR_Render

; 5154 : 	{
; 5155 : 		wv->sow = wallVerts->s;

  00045	8b 45 94	 mov	 eax, DWORD PTR _wv$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0004b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004e	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 5156 : 		wv->tow = wallVerts->t;

  00051	8b 45 94	 mov	 eax, DWORD PTR _wv$[ebp]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00057	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0005a	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 5157 : 		wv->x   = wallVerts->x;

  0005d	8b 45 94	 mov	 eax, DWORD PTR _wv$[ebp]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	89 10		 mov	 DWORD PTR [eax], edx

; 5158 : 		wv->y   = wallVerts->y;

  00067	8b 45 94	 mov	 eax, DWORD PTR _wv$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0006d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00070	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 5159 : 		wv->z = wallVerts->z;

  00073	8b 45 94	 mov	 eax, DWORD PTR _wv$[ebp]
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00079	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 5160 : 	}

  0007f	eb a1		 jmp	 SHORT $LN2@HWR_Render
$LN3@HWR_Render:

; 5161 : 
; 5162 : 	UINT8 alpha = pSurf->FlatColor.s.alpha; // retain the alpha

  00081	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00084	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  00087	88 4d 93	 mov	 BYTE PTR _alpha$[ebp], cl

; 5163 : 
; 5164 : 	// Lighting is done here instead so that fog isn't drawn incorrectly on transparent walls after sorting
; 5165 : 	if (wallcolormap)

  0008a	83 7d 1c 00	 cmp	 DWORD PTR _wallcolormap$[ebp], 0
  0008e	74 6a		 je	 SHORT $LN5@HWR_Render

; 5166 : 	{
; 5167 : 		if (fogwall)

  00090	83 7d 14 00	 cmp	 DWORD PTR _fogwall$[ebp], 0
  00094	74 32		 je	 SHORT $LN7@HWR_Render

; 5168 : 			pSurf->FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), wallcolormap->rgba, wallcolormap->fadergba, true, false);

  00096	6a 00		 push	 0
  00098	6a 01		 push	 1
  0009a	8b 45 1c	 mov	 eax, DWORD PTR _wallcolormap$[ebp]
  0009d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000a0	51		 push	 ecx
  000a1	8b 55 1c	 mov	 edx, DWORD PTR _wallcolormap$[ebp]
  000a4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a7	50		 push	 eax
  000a8	8b 4d 18	 mov	 ecx, DWORD PTR _lightlevel$[ebp]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 _LightLevelToLum
  000b1	83 c4 04	 add	 esp, 4
  000b4	0f b6 d0	 movzx	 edx, al
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 _HWR_Lighting
  000bd	83 c4 14	 add	 esp, 20			; 00000014H
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _pSurf$[ebp]
  000c3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000c6	eb 30		 jmp	 SHORT $LN8@HWR_Render
$LN7@HWR_Render:

; 5169 : 		else
; 5170 : 			pSurf->FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), wallcolormap->rgba, wallcolormap->fadergba, false, false);

  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	8b 45 1c	 mov	 eax, DWORD PTR _wallcolormap$[ebp]
  000cf	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000d2	51		 push	 ecx
  000d3	8b 55 1c	 mov	 edx, DWORD PTR _wallcolormap$[ebp]
  000d6	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000d9	50		 push	 eax
  000da	8b 4d 18	 mov	 ecx, DWORD PTR _lightlevel$[ebp]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 _LightLevelToLum
  000e3	83 c4 04	 add	 esp, 4
  000e6	0f b6 d0	 movzx	 edx, al
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _HWR_Lighting
  000ef	83 c4 14	 add	 esp, 20			; 00000014H
  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _pSurf$[ebp]
  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN8@HWR_Render:

; 5171 : 	}

  000f8	eb 5a		 jmp	 SHORT $LN10@HWR_Render
$LN5@HWR_Render:

; 5172 : 	else
; 5173 : 	{
; 5174 : 		if (fogwall)

  000fa	83 7d 14 00	 cmp	 DWORD PTR _fogwall$[ebp], 0
  000fe	74 2b		 je	 SHORT $LN9@HWR_Render

; 5175 : 			pSurf->FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), NORMALFOG, FADEFOG, true, false);

  00100	6a 00		 push	 0
  00102	6a 01		 push	 1
  00104	68 00 00 00 19	 push	 419430400		; 19000000H
  00109	6a 00		 push	 0
  0010b	8b 45 18	 mov	 eax, DWORD PTR _lightlevel$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _LightLevelToLum
  00114	83 c4 04	 add	 esp, 4
  00117	0f b6 c8	 movzx	 ecx, al
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 _HWR_Lighting
  00120	83 c4 14	 add	 esp, 20			; 00000014H
  00123	8b 55 0c	 mov	 edx, DWORD PTR _pSurf$[ebp]
  00126	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00129	eb 29		 jmp	 SHORT $LN10@HWR_Render
$LN9@HWR_Render:

; 5176 : 		else
; 5177 : 			pSurf->FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), NORMALFOG, FADEFOG, false, false);

  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	68 00 00 00 19	 push	 419430400		; 19000000H
  00134	6a 00		 push	 0
  00136	8b 45 18	 mov	 eax, DWORD PTR _lightlevel$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _LightLevelToLum
  0013f	83 c4 04	 add	 esp, 4
  00142	0f b6 c8	 movzx	 ecx, al
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _HWR_Lighting
  0014b	83 c4 14	 add	 esp, 20			; 00000014H
  0014e	8b 55 0c	 mov	 edx, DWORD PTR _pSurf$[ebp]
  00151	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN10@HWR_Render:

; 5178 : 	}
; 5179 : 
; 5180 : 	pSurf->FlatColor.s.alpha = alpha; // put the alpha back after lighting

  00154	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00157	8a 4d 93	 mov	 cl, BYTE PTR _alpha$[ebp]
  0015a	88 48 07	 mov	 BYTE PTR [eax+7], cl

; 5181 : 
; 5182 : 	if (blend & PF_Environment)

  0015d	8b 45 10	 mov	 eax, DWORD PTR _blend$[ebp]
  00160	83 e0 08	 and	 eax, 8
  00163	74 26		 je	 SHORT $LN11@HWR_Render

; 5183 : 		HWD.pfnDrawPolygon(pSurf, trVerts, 4, blend|PF_Modulated|PF_Clip|PF_Occlude); // PF_Occlude must be used for solid objects

  00165	8b 45 10	 mov	 eax, DWORD PTR _blend$[ebp]
  00168	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  0016d	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00172	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00177	50		 push	 eax
  00178	6a 04		 push	 4
  0017a	8d 4d 9c	 lea	 ecx, DWORD PTR _trVerts$[ebp]
  0017d	51		 push	 ecx
  0017e	8b 55 0c	 mov	 edx, DWORD PTR _pSurf$[ebp]
  00181	52		 push	 edx
  00182	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  00188	90		 npad	 1
  00189	eb 1f		 jmp	 SHORT $LN12@HWR_Render
$LN11@HWR_Render:

; 5184 : 	else
; 5185 : 		HWD.pfnDrawPolygon(pSurf, trVerts, 4, blend|PF_Modulated|PF_Clip); // No PF_Occlude means overlapping (incorrect) transparency

  0018b	8b 45 10	 mov	 eax, DWORD PTR _blend$[ebp]
  0018e	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  00193	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00198	50		 push	 eax
  00199	6a 04		 push	 4
  0019b	8d 4d 9c	 lea	 ecx, DWORD PTR _trVerts$[ebp]
  0019e	51		 push	 ecx
  0019f	8b 55 0c	 mov	 edx, DWORD PTR _pSurf$[ebp]
  001a2	52		 push	 edx
  001a3	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  001a9	90		 npad	 1
$LN12@HWR_Render:

; 5186 : 
; 5187 : #ifdef WALLSPLATS
; 5188 : 	if (gr_curline->linedef->splats && cv_splats.value)
; 5189 : 		HWR_DrawSegsSplats(pSurf);
; 5190 : #endif
; 5191 : }

  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5b		 pop	 ebx
  001ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b0	33 cd		 xor	 ecx, ebp
  001b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c3		 ret	 0
_HWR_RenderWall ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_SortVisSprites
_TEXT	SEGMENT
_bestdist$ = -72					; size = 4
_unsorted$ = -68					; size = 52
_best$ = -16						; size = 4
_ds$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_HWR_SortVisSprites PROC				; COMDAT

; 3790 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3791 : 	size_t i, count;
; 3792 : 	gr_vissprite_t *ds;
; 3793 : 	gr_vissprite_t *best = NULL;

  0000c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _best$[ebp], 0

; 3794 : 	gr_vissprite_t unsorted;
; 3795 : 	float bestdist;
; 3796 : 
; 3797 : 	count = gr_vissprite_p - gr_vissprites;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vissprite_p
  00018	2d 00 00 00 00	 sub	 eax, OFFSET _gr_vissprites
  0001d	99		 cdq
  0001e	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00023	f7 f9		 idiv	 ecx
  00025	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 3798 : 
; 3799 : 	unsorted.next = unsorted.prev = &unsorted;

  00028	8d 45 bc	 lea	 eax, DWORD PTR _unsorted$[ebp]
  0002b	89 45 bc	 mov	 DWORD PTR _unsorted$[ebp], eax
  0002e	8b 4d bc	 mov	 ecx, DWORD PTR _unsorted$[ebp]
  00031	89 4d c0	 mov	 DWORD PTR _unsorted$[ebp+4], ecx

; 3800 : 
; 3801 : 	if (!count)

  00034	83 7d f8 00	 cmp	 DWORD PTR _count$[ebp], 0
  00038	75 05		 jne	 SHORT $LN11@HWR_SortVi

; 3802 : 		return;

  0003a	e9 31 01 00 00	 jmp	 $LN6@HWR_SortVi
$LN11@HWR_SortVi:

; 3803 : 
; 3804 : 	for (ds = gr_vissprites; ds < gr_vissprite_p; ds++)

  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ds$[ebp], OFFSET _gr_vissprites
  00046	eb 09		 jmp	 SHORT $LN4@HWR_SortVi
$LN2@HWR_SortVi:
  00048	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0004b	83 c0 34	 add	 eax, 52			; 00000034H
  0004e	89 45 f4	 mov	 DWORD PTR _ds$[ebp], eax
$LN4@HWR_SortVi:
  00051	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00054	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _gr_vissprite_p
  0005a	73 19		 jae	 SHORT $LN3@HWR_SortVi

; 3805 : 	{
; 3806 : 		ds->next = ds+1;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0005f	83 c0 34	 add	 eax, 52			; 00000034H
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _ds$[ebp]
  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3807 : 		ds->prev = ds-1;

  00068	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0006b	83 e8 34	 sub	 eax, 52			; 00000034H
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _ds$[ebp]
  00071	89 01		 mov	 DWORD PTR [ecx], eax

; 3808 : 	}

  00073	eb d3		 jmp	 SHORT $LN2@HWR_SortVi
$LN3@HWR_SortVi:

; 3809 : 
; 3810 : 	gr_vissprites[0].prev = &unsorted;

  00075	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  0007a	6b c8 00	 imul	 ecx, eax, 0
  0007d	8d 55 bc	 lea	 edx, DWORD PTR _unsorted$[ebp]
  00080	89 91 00 00 00
	00		 mov	 DWORD PTR _gr_vissprites[ecx], edx

; 3811 : 	unsorted.next = &gr_vissprites[0];

  00086	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  0008b	6b c8 00	 imul	 ecx, eax, 0
  0008e	81 c1 00 00 00
	00		 add	 ecx, OFFSET _gr_vissprites
  00094	89 4d c0	 mov	 DWORD PTR _unsorted$[ebp+4], ecx

; 3812 : 	(gr_vissprite_p-1)->next = &unsorted;

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vissprite_p
  0009c	8d 4d bc	 lea	 ecx, DWORD PTR _unsorted$[ebp]
  0009f	89 48 d0	 mov	 DWORD PTR [eax-48], ecx

; 3813 : 	unsorted.prev = gr_vissprite_p-1;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vissprite_p
  000a7	83 e8 34	 sub	 eax, 52			; 00000034H
  000aa	89 45 bc	 mov	 DWORD PTR _unsorted$[ebp], eax

; 3814 : 
; 3815 : 	// pull the vissprites out by scale
; 3816 : 	gr_vsprsortedhead.next = gr_vsprsortedhead.prev = &gr_vsprsortedhead;

  000ad	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_vsprsortedhead, OFFSET _gr_vsprsortedhead
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vsprsortedhead
  000bc	a3 04 00 00 00	 mov	 DWORD PTR _gr_vsprsortedhead+4, eax

; 3817 : 	for (i = 0; i < count; i++)

  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c8	eb 09		 jmp	 SHORT $LN7@HWR_SortVi
$LN5@HWR_SortVi:
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HWR_SortVi:
  000d3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d6	3b 45 f8	 cmp	 eax, DWORD PTR _count$[ebp]
  000d9	0f 83 91 00 00
	00		 jae	 $LN6@HWR_SortVi

; 3818 : 	{
; 3819 : 		bestdist = ZCLIP_PLANE-1;

  000df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  000e7	f3 0f 11 45 b8	 movss	 DWORD PTR _bestdist$[ebp], xmm0

; 3820 : 		for (ds = unsorted.next; ds != &unsorted; ds = ds->next)

  000ec	8b 45 c0	 mov	 eax, DWORD PTR _unsorted$[ebp+4]
  000ef	89 45 f4	 mov	 DWORD PTR _ds$[ebp], eax
  000f2	eb 09		 jmp	 SHORT $LN10@HWR_SortVi
$LN8@HWR_SortVi:
  000f4	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  000f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fa	89 4d f4	 mov	 DWORD PTR _ds$[ebp], ecx
$LN10@HWR_SortVi:
  000fd	8d 45 bc	 lea	 eax, DWORD PTR _unsorted$[ebp]
  00100	39 45 f4	 cmp	 DWORD PTR _ds$[ebp], eax
  00103	74 23		 je	 SHORT $LN9@HWR_SortVi

; 3821 : 		{
; 3822 : 			if (ds->tz > bestdist)

  00105	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00108	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0010d	0f 2f 45 b8	 comiss	 xmm0, DWORD PTR _bestdist$[ebp]
  00111	76 13		 jbe	 SHORT $LN12@HWR_SortVi

; 3823 : 			{
; 3824 : 				bestdist = ds->tz;

  00113	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00116	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0011b	f3 0f 11 45 b8	 movss	 DWORD PTR _bestdist$[ebp], xmm0

; 3825 : 				best = ds;

  00120	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00123	89 45 f0	 mov	 DWORD PTR _best$[ebp], eax
$LN12@HWR_SortVi:

; 3826 : 			}
; 3827 : 		}

  00126	eb cc		 jmp	 SHORT $LN8@HWR_SortVi
$LN9@HWR_SortVi:

; 3828 : 		best->next->prev = best->prev;

  00128	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  0012b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012e	8b 55 f0	 mov	 edx, DWORD PTR _best$[ebp]
  00131	8b 02		 mov	 eax, DWORD PTR [edx]
  00133	89 01		 mov	 DWORD PTR [ecx], eax

; 3829 : 		best->prev->next = best->next;

  00135	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	8b 55 f0	 mov	 edx, DWORD PTR _best$[ebp]
  0013d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00140	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3830 : 		best->next = &gr_vsprsortedhead;

  00143	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00146	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _gr_vsprsortedhead

; 3831 : 		best->prev = gr_vsprsortedhead.prev;

  0014d	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_vsprsortedhead
  00156	89 08		 mov	 DWORD PTR [eax], ecx

; 3832 : 		gr_vsprsortedhead.prev->next = best;

  00158	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vsprsortedhead
  0015d	8b 4d f0	 mov	 ecx, DWORD PTR _best$[ebp]
  00160	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3833 : 		gr_vsprsortedhead.prev = best;

  00163	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00166	a3 00 00 00 00	 mov	 DWORD PTR _gr_vsprsortedhead, eax

; 3834 : 	}

  0016b	e9 5a ff ff ff	 jmp	 $LN5@HWR_SortVi
$LN6@HWR_SortVi:

; 3835 : }

  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
_HWR_SortVisSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DrawSprite
_TEXT	SEGMENT
tv277 = -380						; size = 4
tv254 = -380						; size = 4
tv293 = -376						; size = 4
tv306 = -376						; size = 4
tv319 = -376						; size = 4
tv340 = -376						; size = 4
tv361 = -376						; size = 4
tv377 = -376						; size = 4
tv473 = -376						; size = 4
tv70 = -376						; size = 4
tv670 = -376						; size = 4
tv685 = -376						; size = 4
tv714 = -376						; size = 4
tv729 = -376						; size = 4
tv749 = -376						; size = 4
tv776 = -376						; size = 4
tv790 = -376						; size = 4
tv808 = -376						; size = 4
tv842 = -376						; size = 4
tv856 = -376						; size = 4
tv872 = -376						; size = 4
tv885 = -376						; size = 4
tv898 = -376						; size = 4
tv914 = -376						; size = 4
tv996 = -376						; size = 4
tv2182 = -376						; size = 4
tv152 = -376						; size = 4
tv168 = -376						; size = 4
tv183 = -376						; size = 4
tv217 = -376						; size = 4
tv231 = -376						; size = 4
tv2184 = -376						; size = 4
_blend$1 = -308						; size = 4
_light$2 = -304						; size = 4
_colormap$3 = -300					; size = 4
_lightlevel$4 = -293					; size = 1
_sector$5 = -292					; size = 4
_light$6 = -288						; size = 4
_colormap$7 = -284					; size = 4
_lightlevel$8 = -277					; size = 1
_sector$9 = -276					; size = 4
_scale$10 = -272					; size = 4
_radius$11 = -268					; size = 4
_floorz$12 = -264					; size = 4
_shadowdir$13 = -260					; size = 4
_mobjfloor$14 = -256					; size = 4
_floorheight$15 = -252					; size = 4
_sSurf$16 = -248					; size = 8
_swallVerts$17 = -240					; size = 96
_temp$18 = -144						; size = 4
_scale$19 = -140					; size = 4
_radius$20 = -136					; size = 4
_hires$ = -132						; size = 4
_Surf$ = -128						; size = 8
_gpatch$ = -120						; size = 4
_wv$ = -116						; size = 4
_wallVerts$ = -112					; size = 96
_tr_y$ = -16						; size = 4
_tr_x$ = -12						; size = 4
_i$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
_spr$ = 8						; size = 4
_HWR_DrawSprite PROC					; COMDAT

; 3255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3256 : 	UINT8 i;
; 3257 : 	float tr_x, tr_y;
; 3258 : 	FOutVector wallVerts[4];
; 3259 : 	FOutVector *wv;
; 3260 : 	GLPatch_t *gpatch; // sprite patch converted to hardware
; 3261 : 	FSurfaceInfo Surf;
; 3262 : 	const boolean hires = (spr->mobj && spr->mobj->flags & MF_HIRES);

  00016	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00019	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0001d	74 1c		 je	 SHORT $LN75@HWR_DrawSp
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00022	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00025	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00028	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0002d	74 0c		 je	 SHORT $LN75@HWR_DrawSp
  0002f	c7 85 88 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
  00039	eb 0a		 jmp	 SHORT $LN76@HWR_DrawSp
$LN75@HWR_DrawSp:
  0003b	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN76@HWR_DrawSp:
  00045	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  0004b	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _hires$[ebp], ecx

; 3263 : 
; 3264 : 	if (!spr->mobj)

  00051	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00054	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00058	75 05		 jne	 SHORT $LN8@HWR_DrawSp

; 3265 : 		return;

  0005a	e9 db 1b 00 00	 jmp	 $LN68@HWR_DrawSp
$LN8@HWR_DrawSp:

; 3266 : 
; 3267 : 	if (!spr->mobj->subsector)

  0005f	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00062	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00065	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00069	75 05		 jne	 SHORT $LN9@HWR_DrawSp

; 3268 : 		return;

  0006b	e9 ca 1b 00 00	 jmp	 $LN68@HWR_DrawSp
$LN9@HWR_DrawSp:

; 3269 : 
; 3270 : 	// cache sprite graphics
; 3271 : 	//12/12/99: Hurdler:
; 3272 : 	//          OK, I don't change anything for MD2 support because I want to be
; 3273 : 	//          sure to do it the right way. So actually, we keep normal sprite
; 3274 : 	//          in memory and we add the md2 model if it exists for that sprite
; 3275 : 
; 3276 : 	gpatch = W_CachePatchNum(spr->patchlumpnum, PU_CACHE);

  00070	6a 65		 push	 101			; 00000065H
  00072	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00075	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _W_CachePatchNum
  0007e	83 c4 08	 add	 esp, 8
  00081	89 45 88	 mov	 DWORD PTR _gpatch$[ebp], eax

; 3277 : 
; 3278 : 	// create the sprite billboard
; 3279 : 	//
; 3280 : 	//  3--2
; 3281 : 	//  | /|
; 3282 : 	//  |/ |
; 3283 : 	//  0--1
; 3284 : 	wallVerts[0].x = wallVerts[3].x = spr->x1;

  00084	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00089	6b c8 03	 imul	 ecx, eax, 3
  0008c	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  0008f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00092	89 44 0d 90	 mov	 DWORD PTR _wallVerts$[ebp+ecx], eax
  00096	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0009b	6b d1 03	 imul	 edx, ecx, 3
  0009e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000a3	6b c8 00	 imul	 ecx, eax, 0
  000a6	8b 54 15 90	 mov	 edx, DWORD PTR _wallVerts$[ebp+edx]
  000aa	89 54 0d 90	 mov	 DWORD PTR _wallVerts$[ebp+ecx], edx

; 3285 : 	wallVerts[2].x = wallVerts[1].x = spr->x2;

  000ae	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000b3	c1 e0 00	 shl	 eax, 0
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  000b9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000bc	89 54 05 90	 mov	 DWORD PTR _wallVerts$[ebp+eax], edx
  000c0	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000c5	c1 e0 00	 shl	 eax, 0
  000c8	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  000cd	d1 e1		 shl	 ecx, 1
  000cf	8b 54 05 90	 mov	 edx, DWORD PTR _wallVerts$[ebp+eax]
  000d3	89 54 0d 90	 mov	 DWORD PTR _wallVerts$[ebp+ecx], edx

; 3286 : 	wallVerts[2].y = wallVerts[3].y = spr->ty;

  000d7	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000dc	6b c8 03	 imul	 ecx, eax, 3
  000df	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  000e2	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000e5	89 44 0d 94	 mov	 DWORD PTR _wallVerts$[ebp+ecx+4], eax
  000e9	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  000ee	6b d1 03	 imul	 edx, ecx, 3
  000f1	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000f6	d1 e0		 shl	 eax, 1
  000f8	8b 4c 15 94	 mov	 ecx, DWORD PTR _wallVerts$[ebp+edx+4]
  000fc	89 4c 05 94	 mov	 DWORD PTR _wallVerts$[ebp+eax+4], ecx

; 3287 : 	wallVerts[0].y = wallVerts[1].y = spr->ty - gpatch->height;

  00100	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00103	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00107	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0010b	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  0010e	f3 0f 10 4a 14	 movss	 xmm1, DWORD PTR [edx+20]
  00113	f3 0f 5c c8	 subss	 xmm1, xmm0
  00117	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv152[ebp], xmm1
  0011f	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00124	c1 e0 00	 shl	 eax, 0
  00127	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv152[ebp]
  0012f	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  00135	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0013a	6b d1 00	 imul	 edx, ecx, 0
  0013d	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv152[ebp]
  00145	f3 0f 11 44 15
	94		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 3288 : 
; 3289 : 	if (hires)

  0014b	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _hires$[ebp], 0
  00152	0f 84 bb 00 00
	00		 je	 $LN10@HWR_DrawSp

; 3290 : 	{
; 3291 : 		wallVerts[0].x = wallVerts[3].x += (spr->x2-spr->x1)/4;

  00158	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0015d	6b c8 03	 imul	 ecx, eax, 3
  00160	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00163	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00166	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  0016b	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  00170	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00178	f3 0f 10 4c 0d
	90		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+ecx]
  0017e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00182	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv168[ebp], xmm1
  0018a	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0018f	6b d1 03	 imul	 edx, ecx, 3
  00192	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv168[ebp]
  0019a	f3 0f 11 44 15
	90		 movss	 DWORD PTR _wallVerts$[ebp+edx], xmm0
  001a0	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  001a5	6b c8 00	 imul	 ecx, eax, 0
  001a8	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv168[ebp]
  001b0	f3 0f 11 44 0d
	90		 movss	 DWORD PTR _wallVerts$[ebp+ecx], xmm0

; 3292 : 		wallVerts[2].x = wallVerts[1].x -= (spr->x2-spr->x1)/4;

  001b6	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  001bb	c1 e0 00	 shl	 eax, 0
  001be	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  001c1	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  001c4	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [ecx+12]
  001c9	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]
  001ce	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  001d6	f3 0f 10 4c 05
	90		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+eax]
  001dc	f3 0f 5c c8	 subss	 xmm1, xmm0
  001e0	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv183[ebp], xmm1
  001e8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  001ed	c1 e0 00	 shl	 eax, 0
  001f0	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv183[ebp]
  001f8	f3 0f 11 44 05
	90		 movss	 DWORD PTR _wallVerts$[ebp+eax], xmm0
  001fe	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00203	d1 e1		 shl	 ecx, 1
  00205	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv183[ebp]
  0020d	f3 0f 11 44 0d
	90		 movss	 DWORD PTR _wallVerts$[ebp+ecx], xmm0
$LN10@HWR_DrawSp:

; 3293 : 	}
; 3294 : 
; 3295 : 	if(spr->mobj && spr->mobj->scale != 100)

  00213	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00216	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0021a	0f 84 b8 04 00
	00		 je	 $LN13@HWR_DrawSp
  00220	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00223	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00226	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  0022d	83 fa 64	 cmp	 edx, 100		; 00000064H
  00230	0f 84 a2 04 00
	00		 je	 $LN13@HWR_DrawSp

; 3296 : 	{
; 3297 : 		const float radius = (spr->x2-spr->x1)/2;

  00236	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00239	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0023c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00241	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00246	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0024e	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _radius$20[ebp], xmm0

; 3298 : 		const float scale = (float)(100-spr->mobj->scale);

  00256	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00259	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0025c	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  00263	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00268	2b c2		 sub	 eax, edx
  0026a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0026e	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _scale$19[ebp], xmm0

; 3299 : 		if(spr->mobj->flags & MF_HIRES)

  00276	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00279	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0027c	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0027f	81 e2 00 00 08
	00		 and	 edx, 524288		; 00080000H
  00285	0f 84 4d 02 00
	00		 je	 $LN12@HWR_DrawSp

; 3300 : 		{
; 3301 : 			wallVerts[0].x = wallVerts[3].x += FLOATSCALE(radius,scale)/2;

  0028b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00290	6b c8 03	 imul	 ecx, eax, 3
  00293	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _scale$19[ebp]
  0029b	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _radius$20[ebp]
  002a3	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  002ab	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002b3	f3 0f 10 4c 0d
	90		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+ecx]
  002b9	f3 0f 58 c8	 addss	 xmm1, xmm0
  002bd	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv217[ebp], xmm1
  002c5	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  002ca	6b c2 03	 imul	 eax, edx, 3
  002cd	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv217[ebp]
  002d5	f3 0f 11 44 05
	90		 movss	 DWORD PTR _wallVerts$[ebp+eax], xmm0
  002db	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  002e0	6b d1 00	 imul	 edx, ecx, 0
  002e3	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv217[ebp]
  002eb	f3 0f 11 44 15
	90		 movss	 DWORD PTR _wallVerts$[ebp+edx], xmm0

; 3302 : 			wallVerts[2].x = wallVerts[1].x -= FLOATSCALE(radius,scale)/2;

  002f1	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002f6	c1 e0 00	 shl	 eax, 0
  002f9	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _scale$19[ebp]
  00301	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _radius$20[ebp]
  00309	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00311	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00319	f3 0f 10 4c 05
	90		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+eax]
  0031f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00323	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv231[ebp], xmm1
  0032b	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00330	c1 e1 00	 shl	 ecx, 0
  00333	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv231[ebp]
  0033b	f3 0f 11 44 0d
	90		 movss	 DWORD PTR _wallVerts$[ebp+ecx], xmm0
  00341	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00346	d1 e2		 shl	 edx, 1
  00348	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv231[ebp]
  00350	f3 0f 11 44 15
	90		 movss	 DWORD PTR _wallVerts$[ebp+edx], xmm0

; 3303 : 			wallVerts[0].y = wallVerts[1].y += FLOATSCALE(abs(gpatch->topoffset-gpatch->height),scale/2);

  00356	be 18 00 00 00	 mov	 esi, 24			; 00000018H
  0035b	c1 e6 00	 shl	 esi, 0
  0035e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _scale$19[ebp]
  00366	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0036e	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00371	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00375	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00378	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  0037c	2b c8		 sub	 ecx, eax
  0037e	51		 push	 ecx
  0037f	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv2182[ebp], xmm0
  00387	e8 00 00 00 00	 call	 _abs
  0038c	83 c4 04	 add	 esp, 4
  0038f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00393	f3 0f 10 8d 88
	fe ff ff	 movss	 xmm1, DWORD PTR tv2182[ebp]
  0039b	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0039f	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  003a7	f3 0f 10 44 35
	94		 movss	 xmm0, DWORD PTR _wallVerts$[ebp+esi+4]
  003ad	f3 0f 58 c1	 addss	 xmm0, xmm1
  003b1	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR tv254[ebp], xmm0
  003b9	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  003be	c1 e1 00	 shl	 ecx, 0
  003c1	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv254[ebp]
  003c9	f3 0f 11 44 0d
	94		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  003cf	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  003d4	6b c2 00	 imul	 eax, edx, 0
  003d7	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv254[ebp]
  003df	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0

; 3304 : 			wallVerts[2].y = wallVerts[3].y += FLOATSCALE(abs(gpatch->topoffset-gpatch->height),scale/2);

  003e5	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  003ea	6b f0 03	 imul	 esi, eax, 3
  003ed	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _scale$19[ebp]
  003f5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  003fd	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00400	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00404	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00407	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0040b	2b d1		 sub	 edx, ecx
  0040d	52		 push	 edx
  0040e	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv2184[ebp], xmm0
  00416	e8 00 00 00 00	 call	 _abs
  0041b	83 c4 04	 add	 esp, 4
  0041e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00422	f3 0f 10 8d 88
	fe ff ff	 movss	 xmm1, DWORD PTR tv2184[ebp]
  0042a	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0042e	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  00436	f3 0f 10 44 35
	94		 movss	 xmm0, DWORD PTR _wallVerts$[ebp+esi+4]
  0043c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00440	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR tv277[ebp], xmm0
  00448	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0044d	6b c2 03	 imul	 eax, edx, 3
  00450	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv277[ebp]
  00458	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  0045e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00463	d1 e1		 shl	 ecx, 1
  00465	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv277[ebp]
  0046d	f3 0f 11 44 0d
	94		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0

; 3305 : 			wallVerts[2].y = wallVerts[3].y -= FLOATSCALE(gpatch->height,scale);

  00473	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00478	6b c8 03	 imul	 ecx, eax, 3
  0047b	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  0047e	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00482	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00486	f3 0f 59 85 74
	ff ff ff	 mulss	 xmm0, DWORD PTR _scale$19[ebp]
  0048e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00496	f3 0f 10 4c 0d
	94		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+ecx+4]
  0049c	f3 0f 5c c8	 subss	 xmm1, xmm0
  004a0	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv293[ebp], xmm1
  004a8	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  004ad	6b d1 03	 imul	 edx, ecx, 3
  004b0	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv293[ebp]
  004b8	f3 0f 11 44 15
	94		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0
  004be	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004c3	d1 e0		 shl	 eax, 1
  004c5	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv293[ebp]
  004cd	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0

; 3306 : 		}

  004d3	e9 00 02 00 00	 jmp	 $LN13@HWR_DrawSp
$LN12@HWR_DrawSp:

; 3307 : 		else
; 3308 : 		{
; 3309 : 			wallVerts[0].x = wallVerts[3].x += FLOATSCALE(radius,scale);

  004d8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004dd	6b c8 03	 imul	 ecx, eax, 3
  004e0	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _scale$19[ebp]
  004e8	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _radius$20[ebp]
  004f0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  004f8	f3 0f 10 4c 0d
	90		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+ecx]
  004fe	f3 0f 58 c8	 addss	 xmm1, xmm0
  00502	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv306[ebp], xmm1
  0050a	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0050f	6b c2 03	 imul	 eax, edx, 3
  00512	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv306[ebp]
  0051a	f3 0f 11 44 05
	90		 movss	 DWORD PTR _wallVerts$[ebp+eax], xmm0
  00520	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00525	6b d1 00	 imul	 edx, ecx, 0
  00528	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv306[ebp]
  00530	f3 0f 11 44 15
	90		 movss	 DWORD PTR _wallVerts$[ebp+edx], xmm0

; 3310 : 			wallVerts[2].x = wallVerts[1].x -= FLOATSCALE(radius,scale);

  00536	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0053b	c1 e0 00	 shl	 eax, 0
  0053e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _scale$19[ebp]
  00546	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _radius$20[ebp]
  0054e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00556	f3 0f 10 4c 05
	90		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+eax]
  0055c	f3 0f 5c c8	 subss	 xmm1, xmm0
  00560	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv319[ebp], xmm1
  00568	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0056d	c1 e1 00	 shl	 ecx, 0
  00570	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv319[ebp]
  00578	f3 0f 11 44 0d
	90		 movss	 DWORD PTR _wallVerts$[ebp+ecx], xmm0
  0057e	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00583	d1 e2		 shl	 edx, 1
  00585	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv319[ebp]
  0058d	f3 0f 11 44 15
	90		 movss	 DWORD PTR _wallVerts$[ebp+edx], xmm0

; 3311 : 			wallVerts[0].y = wallVerts[1].y += FLOATSCALE(abs(gpatch->topoffset-gpatch->height),scale);

  00593	be 18 00 00 00	 mov	 esi, 24			; 00000018H
  00598	c1 e6 00	 shl	 esi, 0
  0059b	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  0059e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  005a2	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  005a5	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  005a9	2b c8		 sub	 ecx, eax
  005ab	51		 push	 ecx
  005ac	e8 00 00 00 00	 call	 _abs
  005b1	83 c4 04	 add	 esp, 4
  005b4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  005b8	f3 0f 59 85 74
	ff ff ff	 mulss	 xmm0, DWORD PTR _scale$19[ebp]
  005c0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  005c8	f3 0f 10 4c 35
	94		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+esi+4]
  005ce	f3 0f 58 c8	 addss	 xmm1, xmm0
  005d2	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv340[ebp], xmm1
  005da	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  005df	c1 e1 00	 shl	 ecx, 0
  005e2	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv340[ebp]
  005ea	f3 0f 11 44 0d
	94		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  005f0	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  005f5	6b c2 00	 imul	 eax, edx, 0
  005f8	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv340[ebp]
  00600	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0

; 3312 : 			wallVerts[2].y = wallVerts[3].y += FLOATSCALE(abs(gpatch->topoffset-gpatch->height),scale);

  00606	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0060b	6b f0 03	 imul	 esi, eax, 3
  0060e	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00611	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00615	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00618	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0061c	2b d1		 sub	 edx, ecx
  0061e	52		 push	 edx
  0061f	e8 00 00 00 00	 call	 _abs
  00624	83 c4 04	 add	 esp, 4
  00627	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0062b	f3 0f 59 85 74
	ff ff ff	 mulss	 xmm0, DWORD PTR _scale$19[ebp]
  00633	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0063b	f3 0f 10 4c 35
	94		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+esi+4]
  00641	f3 0f 58 c8	 addss	 xmm1, xmm0
  00645	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv361[ebp], xmm1
  0064d	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00652	6b c2 03	 imul	 eax, edx, 3
  00655	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv361[ebp]
  0065d	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  00663	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00668	d1 e1		 shl	 ecx, 1
  0066a	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv361[ebp]
  00672	f3 0f 11 44 0d
	94		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0

; 3313 : 			wallVerts[2].y = wallVerts[3].y -= FLOATSCALE(gpatch->height,scale);

  00678	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0067d	6b c8 03	 imul	 ecx, eax, 3
  00680	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00683	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00687	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0068b	f3 0f 59 85 74
	ff ff ff	 mulss	 xmm0, DWORD PTR _scale$19[ebp]
  00693	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0069b	f3 0f 10 4c 0d
	94		 movss	 xmm1, DWORD PTR _wallVerts$[ebp+ecx+4]
  006a1	f3 0f 5c c8	 subss	 xmm1, xmm0
  006a5	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv377[ebp], xmm1
  006ad	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  006b2	6b d1 03	 imul	 edx, ecx, 3
  006b5	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv377[ebp]
  006bd	f3 0f 11 44 15
	94		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0
  006c3	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  006c8	d1 e0		 shl	 eax, 1
  006ca	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv377[ebp]
  006d2	f3 0f 11 44 05
	94		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
$LN13@HWR_DrawSp:

; 3314 : 		}
; 3315 : 	}
; 3316 : 
; 3317 : 	// make a wall polygon (with 2 triangles), using the floor/ceiling heights,
; 3318 : 	// and the 2d map coords of start/end vertices
; 3319 : 	wallVerts[0].z = wallVerts[1].z = wallVerts[2].z = wallVerts[3].z = spr->tz;

  006d8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  006dd	6b c8 03	 imul	 ecx, eax, 3
  006e0	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  006e3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  006e6	89 44 0d 98	 mov	 DWORD PTR _wallVerts$[ebp+ecx+8], eax
  006ea	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  006ef	6b d1 03	 imul	 edx, ecx, 3
  006f2	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  006f7	d1 e0		 shl	 eax, 1
  006f9	8b 4c 15 98	 mov	 ecx, DWORD PTR _wallVerts$[ebp+edx+8]
  006fd	89 4c 05 98	 mov	 DWORD PTR _wallVerts$[ebp+eax+8], ecx
  00701	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00706	d1 e2		 shl	 edx, 1
  00708	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0070d	c1 e0 00	 shl	 eax, 0
  00710	8b 4c 15 98	 mov	 ecx, DWORD PTR _wallVerts$[ebp+edx+8]
  00714	89 4c 05 98	 mov	 DWORD PTR _wallVerts$[ebp+eax+8], ecx
  00718	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0071d	c1 e2 00	 shl	 edx, 0
  00720	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00725	6b c8 00	 imul	 ecx, eax, 0
  00728	8b 54 15 98	 mov	 edx, DWORD PTR _wallVerts$[ebp+edx+8]
  0072c	89 54 0d 98	 mov	 DWORD PTR _wallVerts$[ebp+ecx+8], edx

; 3320 : 
; 3321 : 	// transform
; 3322 : 	wv = wallVerts;

  00730	8d 45 90	 lea	 eax, DWORD PTR _wallVerts$[ebp]
  00733	89 45 8c	 mov	 DWORD PTR _wv$[ebp], eax

; 3323 : 
; 3324 : 	for (i = 0; i < 4; i++,wv++)

  00736	c6 45 fb 00	 mov	 BYTE PTR _i$[ebp], 0
  0073a	eb 11		 jmp	 SHORT $LN4@HWR_DrawSp
$LN2@HWR_DrawSp:
  0073c	8a 45 fb	 mov	 al, BYTE PTR _i$[ebp]
  0073f	04 01		 add	 al, 1
  00741	88 45 fb	 mov	 BYTE PTR _i$[ebp], al
  00744	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  00747	83 c1 18	 add	 ecx, 24			; 00000018H
  0074a	89 4d 8c	 mov	 DWORD PTR _wv$[ebp], ecx
$LN4@HWR_DrawSp:
  0074d	0f b6 45 fb	 movzx	 eax, BYTE PTR _i$[ebp]
  00751	83 f8 04	 cmp	 eax, 4
  00754	0f 8d a1 00 00
	00		 jge	 $LN3@HWR_DrawSp

; 3325 : 	{
; 3326 : 		//look up/down ----TOTAL SUCKS!!!--- do the 2 in one!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; 3327 : 		tr_x = wv->z;

  0075a	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  0075d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00762	f3 0f 11 45 f4	 movss	 DWORD PTR _tr_x$[ebp], xmm0

; 3328 : 		tr_y = wv->y;

  00767	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  0076a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0076f	f3 0f 11 45 f0	 movss	 DWORD PTR _tr_y$[ebp], xmm0

; 3329 : 		wv->y = (tr_x * gr_viewludcos) + (tr_y * gr_viewludsin);

  00774	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  00779	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewludcos
  00781	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  00786	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewludsin
  0078e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00792	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  00795	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 3330 : 		wv->z = (tr_x * gr_viewludsin) - (tr_y * gr_viewludcos);

  0079a	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  0079f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewludsin
  007a7	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  007ac	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewludcos
  007b4	f3 0f 5c c1	 subss	 xmm0, xmm1
  007b8	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  007bb	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 3331 : 		// ---------------------- mega lame test ----------------------------------
; 3332 : 
; 3333 : 		//scale y before frustum so that frustum can be scaled to screen height
; 3334 : 		wv->y *= ORIGINAL_ASPECT * gr_fovlud;

  007c0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fcccccd
  007c8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_fovlud
  007d0	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  007d3	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  007d8	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  007db	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 3335 : 		wv->x *= gr_fovlud;

  007e0	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  007e3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  007e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_fovlud
  007ef	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  007f2	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 3336 : 	}

  007f6	e9 41 ff ff ff	 jmp	 $LN2@HWR_DrawSp
$LN3@HWR_DrawSp:

; 3337 : 
; 3338 : 	if (spr->flip)

  007fb	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  007fe	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00802	74 4d		 je	 SHORT $LN14@HWR_DrawSp

; 3339 : 	{
; 3340 : 		wallVerts[0].sow = wallVerts[3].sow = gpatch->max_s;

  00804	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00809	6b c8 03	 imul	 ecx, eax, 3
  0080c	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  0080f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00812	89 44 0d a0	 mov	 DWORD PTR _wallVerts$[ebp+ecx+16], eax
  00816	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0081b	6b d1 03	 imul	 edx, ecx, 3
  0081e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00823	6b c8 00	 imul	 ecx, eax, 0
  00826	8b 54 15 a0	 mov	 edx, DWORD PTR _wallVerts$[ebp+edx+16]
  0082a	89 54 0d a0	 mov	 DWORD PTR _wallVerts$[ebp+ecx+16], edx

; 3341 : 		wallVerts[2].sow = wallVerts[1].sow = 0;

  0082e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00833	c1 e0 00	 shl	 eax, 0
  00836	0f 57 c0	 xorps	 xmm0, xmm0
  00839	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  0083f	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00844	d1 e1		 shl	 ecx, 1
  00846	0f 57 c0	 xorps	 xmm0, xmm0
  00849	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0

; 3342 : 	}else{

  0084f	eb 4b		 jmp	 SHORT $LN15@HWR_DrawSp
$LN14@HWR_DrawSp:

; 3343 : 		wallVerts[0].sow = wallVerts[3].sow = 0;

  00851	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00856	6b c8 03	 imul	 ecx, eax, 3
  00859	0f 57 c0	 xorps	 xmm0, xmm0
  0085c	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  00862	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00867	6b c2 00	 imul	 eax, edx, 0
  0086a	0f 57 c0	 xorps	 xmm0, xmm0
  0086d	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 3344 : 		wallVerts[2].sow = wallVerts[1].sow = gpatch->max_s;

  00873	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00878	c1 e0 00	 shl	 eax, 0
  0087b	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  0087e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00881	89 54 05 a0	 mov	 DWORD PTR _wallVerts$[ebp+eax+16], edx
  00885	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0088a	c1 e0 00	 shl	 eax, 0
  0088d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00892	d1 e1		 shl	 ecx, 1
  00894	8b 54 05 a0	 mov	 edx, DWORD PTR _wallVerts$[ebp+eax+16]
  00898	89 54 0d a0	 mov	 DWORD PTR _wallVerts$[ebp+ecx+16], edx
$LN15@HWR_DrawSp:

; 3345 : 	}
; 3346 : 
; 3347 : 	wallVerts[3].tow = wallVerts[2].tow = 0;

  0089c	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  008a1	d1 e0		 shl	 eax, 1
  008a3	0f 57 c0	 xorps	 xmm0, xmm0
  008a6	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _wallVerts$[ebp+eax+20], xmm0
  008ac	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  008b1	6b d1 03	 imul	 edx, ecx, 3
  008b4	0f 57 c0	 xorps	 xmm0, xmm0
  008b7	f3 0f 11 44 15
	a4		 movss	 DWORD PTR _wallVerts$[ebp+edx+20], xmm0

; 3348 : 
; 3349 : 	if (hires)

  008bd	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _hires$[ebp], 0
  008c4	74 46		 je	 SHORT $LN16@HWR_DrawSp

; 3350 : 		wallVerts[0].tow = wallVerts[1].tow = gpatch->max_t*2;

  008c6	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  008c9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  008ce	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  008d6	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv473[ebp], xmm0
  008de	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  008e3	c1 e1 00	 shl	 ecx, 0
  008e6	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv473[ebp]
  008ee	f3 0f 11 44 0d
	a4		 movss	 DWORD PTR _wallVerts$[ebp+ecx+20], xmm0
  008f4	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  008f9	6b c2 00	 imul	 eax, edx, 0
  008fc	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv473[ebp]
  00904	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _wallVerts$[ebp+eax+20], xmm0
  0090a	eb 2a		 jmp	 SHORT $LN17@HWR_DrawSp
$LN16@HWR_DrawSp:

; 3351 : 	else
; 3352 : 		wallVerts[0].tow = wallVerts[1].tow = gpatch->max_t;

  0090c	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00911	c1 e0 00	 shl	 eax, 0
  00914	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00917	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0091a	89 54 05 a4	 mov	 DWORD PTR _wallVerts$[ebp+eax+20], edx
  0091e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00923	c1 e0 00	 shl	 eax, 0
  00926	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0092b	6b d1 00	 imul	 edx, ecx, 0
  0092e	8b 44 05 a4	 mov	 eax, DWORD PTR _wallVerts$[ebp+eax+20]
  00932	89 44 15 a4	 mov	 DWORD PTR _wallVerts$[ebp+edx+20], eax
$LN17@HWR_DrawSp:

; 3353 : 
; 3354 : 	// flip the texture coords
; 3355 : 	if (spr->vflip)

  00936	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00939	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0093d	0f 84 86 00 00
	00		 je	 $LN18@HWR_DrawSp

; 3356 : 	{
; 3357 : 		FLOAT temp = wallVerts[0].tow;

  00943	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00948	6b c8 00	 imul	 ecx, eax, 0
  0094b	f3 0f 10 44 0d
	a4		 movss	 xmm0, DWORD PTR _wallVerts$[ebp+ecx+20]
  00951	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _temp$18[ebp], xmm0

; 3358 : 		wallVerts[0].tow = wallVerts[3].tow;

  00959	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0095e	6b c8 03	 imul	 ecx, eax, 3
  00961	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00966	6b c2 00	 imul	 eax, edx, 0
  00969	8b 4c 0d a4	 mov	 ecx, DWORD PTR _wallVerts$[ebp+ecx+20]
  0096d	89 4c 05 a4	 mov	 DWORD PTR _wallVerts$[ebp+eax+20], ecx

; 3359 : 		wallVerts[3].tow = temp;

  00971	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00976	6b c8 03	 imul	 ecx, eax, 3
  00979	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _temp$18[ebp]
  00981	f3 0f 11 44 0d
	a4		 movss	 DWORD PTR _wallVerts$[ebp+ecx+20], xmm0

; 3360 : 		temp = wallVerts[1].tow;

  00987	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0098c	c1 e0 00	 shl	 eax, 0
  0098f	f3 0f 10 44 05
	a4		 movss	 xmm0, DWORD PTR _wallVerts$[ebp+eax+20]
  00995	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _temp$18[ebp], xmm0

; 3361 : 		wallVerts[1].tow = wallVerts[2].tow;

  0099d	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  009a2	d1 e0		 shl	 eax, 1
  009a4	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  009a9	c1 e1 00	 shl	 ecx, 0
  009ac	8b 54 05 a4	 mov	 edx, DWORD PTR _wallVerts$[ebp+eax+20]
  009b0	89 54 0d a4	 mov	 DWORD PTR _wallVerts$[ebp+ecx+20], edx

; 3362 : 		wallVerts[2].tow = temp;

  009b4	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  009b9	d1 e0		 shl	 eax, 1
  009bb	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _temp$18[ebp]
  009c3	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _wallVerts$[ebp+eax+20], xmm0
$LN18@HWR_DrawSp:

; 3363 : 	}
; 3364 : 
; 3365 : 	// cache the patch in the graphics card memory
; 3366 : 	//12/12/99: Hurdler: same comment as above (for md2)
; 3367 : 	//Hurdler: 25/04/2000: now support colormap in hardware mode
; 3368 : 	HWR_GetMappedPatch(gpatch, spr->colormap);

  009c9	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  009cc	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  009cf	51		 push	 ecx
  009d0	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  009d3	52		 push	 edx
  009d4	e8 00 00 00 00	 call	 _HWR_GetMappedPatch
  009d9	83 c4 08	 add	 esp, 8

; 3369 : 
; 3370 : 	// Draw shadow BEFORE SPRITE.
; 3371 : 	if (cv_shadow.value // Shadows enabled
; 3372 : 		&& !(spr->mobj->flags & MF_SCENERY && spr->mobj->flags & MF_SPAWNCEILING && spr->mobj->flags & MF_NOGRAVITY) // Ceiling scenery have no shadow.
; 3373 : 		&& !(spr->mobj->flags2 & MF2_DEBRIS) // Debris have no corona or shadow.
; 3374 : 		&& (spr->mobj->z >= spr->mobj->floorz)) // Without this, your shadow shows on the floor, even after you die and fall through the ground.

  009dc	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_shadow+20, 0
  009e3	0f 84 c6 0e 00
	00		 je	 $noshadow$77
  009e9	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  009ec	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  009ef	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  009f2	81 e2 00 00 00
	02		 and	 edx, 33554432		; 02000000H
  009f8	74 26		 je	 SHORT $LN20@HWR_DrawSp
  009fa	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  009fd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a00	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00a03	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00a09	74 15		 je	 SHORT $LN20@HWR_DrawSp
  00a0b	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a0e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a11	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00a14	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00a1a	0f 85 8f 0e 00
	00		 jne	 $noshadow$77
$LN20@HWR_DrawSp:
  00a20	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a23	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a26	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  00a2c	83 e2 40	 and	 edx, 64			; 00000040H
  00a2f	0f 85 7a 0e 00
	00		 jne	 $noshadow$77
  00a35	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a38	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a3b	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00a3e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00a41	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00a44	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00a47	0f 8c 62 0e 00
	00		 jl	 $noshadow$77

; 3375 : 	{
; 3376 : 		////////////////////
; 3377 : 		// SHADOW SPRITE! //
; 3378 : 		////////////////////
; 3379 : 		FOutVector swallVerts[4];
; 3380 : 		FSurfaceInfo sSurf;
; 3381 : 		fixed_t floorheight, mobjfloor;
; 3382 : 
; 3383 : 		mobjfloor = HWR_OpaqueFloorAtPos(

  00a4d	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a50	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a53	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00a56	52		 push	 edx
  00a57	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a5a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a5d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00a60	52		 push	 edx
  00a61	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a64	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a67	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00a6a	52		 push	 edx
  00a6b	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00a6e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00a71	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00a74	52		 push	 edx
  00a75	e8 00 00 00 00	 call	 _HWR_OpaqueFloorAtPos
  00a7a	83 c4 10	 add	 esp, 16			; 00000010H
  00a7d	89 85 00 ff ff
	ff		 mov	 DWORD PTR _mobjfloor$14[ebp], eax

; 3384 : 			spr->mobj->x, spr->mobj->y,
; 3385 : 			spr->mobj->z, spr->mobj->height);
; 3386 : 		if (cv_shadowoffs.value)

  00a83	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_shadowoffs+20, 0
  00a8a	0f 84 a8 01 00
	00		 je	 $LN21@HWR_DrawSp

; 3387 : 		{
; 3388 : 			angle_t shadowdir;
; 3389 : 
; 3390 : 			// Set direction
; 3391 : 			if (splitscreen && stplyr != &players[displayplayer])

  00a90	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00a97	74 33		 je	 SHORT $LN23@HWR_DrawSp
  00a99	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00aa3	05 00 00 00 00	 add	 eax, OFFSET _players
  00aa8	39 05 00 00 00
	00		 cmp	 DWORD PTR _stplyr, eax
  00aae	74 1c		 je	 SHORT $LN23@HWR_DrawSp

; 3392 : 				shadowdir = localangle2 + FixedAngle(cv_cam2_rotate.value);

  00ab0	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_cam2_rotate+20
  00ab5	50		 push	 eax
  00ab6	e8 00 00 00 00	 call	 _FixedAngle
  00abb	83 c4 04	 add	 esp, 4
  00abe	03 05 00 00 00
	00		 add	 eax, DWORD PTR _localangle2
  00ac4	89 85 fc fe ff
	ff		 mov	 DWORD PTR _shadowdir$13[ebp], eax
  00aca	eb 1a		 jmp	 SHORT $LN24@HWR_DrawSp
$LN23@HWR_DrawSp:

; 3393 : 			else
; 3394 : 				shadowdir = localangle + FixedAngle(cv_cam_rotate.value);

  00acc	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_cam_rotate+20
  00ad1	50		 push	 eax
  00ad2	e8 00 00 00 00	 call	 _FixedAngle
  00ad7	83 c4 04	 add	 esp, 4
  00ada	03 05 00 00 00
	00		 add	 eax, DWORD PTR _localangle
  00ae0	89 85 fc fe ff
	ff		 mov	 DWORD PTR _shadowdir$13[ebp], eax
$LN24@HWR_DrawSp:

; 3395 : 
; 3396 : 			// Find floorheight
; 3397 : 			floorheight = HWR_OpaqueFloorAtPos(

  00ae6	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00ae9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00aec	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00aef	52		 push	 edx
  00af0	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00af3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00af6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00af9	52		 push	 edx
  00afa	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00afd	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00b00	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00b03	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00b06	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00b09	2b 85 00 ff ff
	ff		 sub	 eax, DWORD PTR _mobjfloor$14[ebp]
  00b0f	50		 push	 eax
  00b10	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _shadowdir$13[ebp]
  00b16	51		 push	 ecx
  00b17	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00b1a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00b1d	50		 push	 eax
  00b1e	e8 00 00 00 00	 call	 _P_ReturnThrustY
  00b23	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b26	03 46 14	 add	 eax, DWORD PTR [esi+20]
  00b29	50		 push	 eax
  00b2a	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00b2d	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00b30	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00b33	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00b36	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b39	2b 8d 00 ff ff
	ff		 sub	 ecx, DWORD PTR _mobjfloor$14[ebp]
  00b3f	51		 push	 ecx
  00b40	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _shadowdir$13[ebp]
  00b46	52		 push	 edx
  00b47	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00b4a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00b4d	51		 push	 ecx
  00b4e	e8 00 00 00 00	 call	 _P_ReturnThrustX
  00b53	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b56	03 46 10	 add	 eax, DWORD PTR [esi+16]
  00b59	50		 push	 eax
  00b5a	e8 00 00 00 00	 call	 _HWR_OpaqueFloorAtPos
  00b5f	83 c4 10	 add	 esp, 16			; 00000010H
  00b62	89 85 04 ff ff
	ff		 mov	 DWORD PTR _floorheight$15[ebp], eax

; 3398 : 				spr->mobj->x + P_ReturnThrustX(spr->mobj, shadowdir, spr->mobj->z - mobjfloor),
; 3399 : 				spr->mobj->y + P_ReturnThrustY(spr->mobj, shadowdir, spr->mobj->z - mobjfloor),
; 3400 : 				spr->mobj->z, spr->mobj->height);
; 3401 : 
; 3402 : 			// The shadow is falling ABOVE it's mobj?
; 3403 : 			// Don't draw it, then!
; 3404 : 			if (spr->mobj->z < floorheight)

  00b68	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00b6b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00b6e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00b71	3b 95 04 ff ff
	ff		 cmp	 edx, DWORD PTR _floorheight$15[ebp]
  00b77	7d 0a		 jge	 SHORT $LN25@HWR_DrawSp

; 3405 : 				goto noshadow;

  00b79	e9 31 0d 00 00	 jmp	 $noshadow$77
  00b7e	e9 95 00 00 00	 jmp	 $LN27@HWR_DrawSp
$LN25@HWR_DrawSp:

; 3406 : 			else
; 3407 : 			{
; 3408 : 				fixed_t floorz;
; 3409 : 				floorz = HWR_OpaqueFloorAtPos(

  00b83	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00b86	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00b89	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00b8c	52		 push	 edx
  00b8d	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00b90	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00b93	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00b96	52		 push	 edx
  00b97	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00b9a	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00b9d	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00ba0	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00ba3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00ba6	2b 85 04 ff ff
	ff		 sub	 eax, DWORD PTR _floorheight$15[ebp]
  00bac	50		 push	 eax
  00bad	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _shadowdir$13[ebp]
  00bb3	51		 push	 ecx
  00bb4	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00bb7	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00bba	50		 push	 eax
  00bbb	e8 00 00 00 00	 call	 _P_ReturnThrustY
  00bc0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bc3	03 46 14	 add	 eax, DWORD PTR [esi+20]
  00bc6	50		 push	 eax
  00bc7	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00bca	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00bcd	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00bd0	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00bd3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00bd6	2b 8d 04 ff ff
	ff		 sub	 ecx, DWORD PTR _floorheight$15[ebp]
  00bdc	51		 push	 ecx
  00bdd	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _shadowdir$13[ebp]
  00be3	52		 push	 edx
  00be4	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00be7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00bea	51		 push	 ecx
  00beb	e8 00 00 00 00	 call	 _P_ReturnThrustX
  00bf0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bf3	03 46 10	 add	 eax, DWORD PTR [esi+16]
  00bf6	50		 push	 eax
  00bf7	e8 00 00 00 00	 call	 _HWR_OpaqueFloorAtPos
  00bfc	83 c4 10	 add	 esp, 16			; 00000010H
  00bff	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _floorz$12[ebp], eax

; 3410 : 					spr->mobj->x + P_ReturnThrustX(spr->mobj, shadowdir, spr->mobj->z - floorheight),
; 3411 : 					spr->mobj->y + P_ReturnThrustY(spr->mobj, shadowdir, spr->mobj->z - floorheight),
; 3412 : 					spr->mobj->z, spr->mobj->height);
; 3413 : 				// The shadow would be falling on a wall? Don't draw it, then.
; 3414 : 				// Would draw midair otherwise.
; 3415 : 				if (floorz < floorheight)

  00c05	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _floorz$12[ebp]
  00c0b	3b 85 04 ff ff
	ff		 cmp	 eax, DWORD PTR _floorheight$15[ebp]
  00c11	7d 05		 jge	 SHORT $LN27@HWR_DrawSp

; 3416 : 					goto noshadow;

  00c13	e9 97 0c 00 00	 jmp	 $noshadow$77
$LN27@HWR_DrawSp:

; 3417 : 			}
; 3418 : 
; 3419 : 			floorheight = FixedInt(spr->mobj->z - floorheight);

  00c18	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00c1b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00c1e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00c21	2b 95 04 ff ff
	ff		 sub	 edx, DWORD PTR _floorheight$15[ebp]
  00c27	52		 push	 edx
  00c28	e8 00 00 00 00	 call	 _FixedInt
  00c2d	83 c4 04	 add	 esp, 4
  00c30	89 85 04 ff ff
	ff		 mov	 DWORD PTR _floorheight$15[ebp], eax

; 3420 : 		}

  00c36	eb 1e		 jmp	 SHORT $LN22@HWR_DrawSp
$LN21@HWR_DrawSp:

; 3421 : 		else
; 3422 : 			floorheight = FixedInt(spr->mobj->z - mobjfloor);

  00c38	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00c3b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00c3e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00c41	2b 95 00 ff ff
	ff		 sub	 edx, DWORD PTR _mobjfloor$14[ebp]
  00c47	52		 push	 edx
  00c48	e8 00 00 00 00	 call	 _FixedInt
  00c4d	83 c4 04	 add	 esp, 4
  00c50	89 85 04 ff ff
	ff		 mov	 DWORD PTR _floorheight$15[ebp], eax
$LN22@HWR_DrawSp:

; 3423 : 
; 3424 : 		// create the sprite billboard
; 3425 : 		//
; 3426 : 		//  3--2
; 3427 : 		//  | /|
; 3428 : 		//  |/ |
; 3429 : 		//  0--1
; 3430 : 		swallVerts[0].x = swallVerts[3].x = spr->x1;

  00c56	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00c5b	6b c8 03	 imul	 ecx, eax, 3
  00c5e	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00c61	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c64	89 84 0d 10 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+ecx], eax
  00c6b	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00c70	6b d1 03	 imul	 edx, ecx, 3
  00c73	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00c78	6b c8 00	 imul	 ecx, eax, 0
  00c7b	8b 94 15 10 ff
	ff ff		 mov	 edx, DWORD PTR _swallVerts$17[ebp+edx]
  00c82	89 94 0d 10 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+ecx], edx

; 3431 : 		swallVerts[2].x = swallVerts[1].x = spr->x2;

  00c89	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00c8e	c1 e0 00	 shl	 eax, 0
  00c91	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00c94	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00c97	89 94 05 10 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+eax], edx
  00c9e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00ca3	c1 e0 00	 shl	 eax, 0
  00ca6	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00cab	d1 e1		 shl	 ecx, 1
  00cad	8b 94 05 10 ff
	ff ff		 mov	 edx, DWORD PTR _swallVerts$17[ebp+eax]
  00cb4	89 94 0d 10 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+ecx], edx

; 3432 : 
; 3433 : 		if (hires)

  00cbb	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _hires$[ebp], 0
  00cc2	0f 84 54 02 00
	00		 je	 $LN28@HWR_DrawSp

; 3434 : 		{
; 3435 : 			swallVerts[0].x = swallVerts[3].x += (spr->x2-spr->x1)/4;

  00cc8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00ccd	6b c8 03	 imul	 ecx, eax, 3
  00cd0	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00cd3	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00cd6	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  00cdb	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  00ce0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00ce8	f3 0f 10 8c 0d
	10 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+ecx]
  00cf1	f3 0f 58 c8	 addss	 xmm1, xmm0
  00cf5	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv670[ebp], xmm1
  00cfd	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00d02	6b d1 03	 imul	 edx, ecx, 3
  00d05	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv670[ebp]
  00d0d	f3 0f 11 84 15
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx], xmm0
  00d16	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00d1b	6b c8 00	 imul	 ecx, eax, 0
  00d1e	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv670[ebp]
  00d26	f3 0f 11 84 0d
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx], xmm0

; 3436 : 			swallVerts[2].x = swallVerts[1].x -= (spr->x2-spr->x1)/4;

  00d2f	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00d34	c1 e0 00	 shl	 eax, 0
  00d37	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00d3a	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00d3d	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [ecx+12]
  00d42	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]
  00d47	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00d4f	f3 0f 10 8c 05
	10 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+eax]
  00d58	f3 0f 5c c8	 subss	 xmm1, xmm0
  00d5c	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv685[ebp], xmm1
  00d64	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00d69	c1 e0 00	 shl	 eax, 0
  00d6c	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv685[ebp]
  00d74	f3 0f 11 84 05
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax], xmm0
  00d7d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00d82	d1 e1		 shl	 ecx, 1
  00d84	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv685[ebp]
  00d8c	f3 0f 11 84 0d
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx], xmm0

; 3437 : 
; 3438 : 			// Always a pixel above the floor, perfectly flat.
; 3439 : 			swallVerts[0].y = swallVerts[1].y = swallVerts[2].y = swallVerts[3].y =

  00d95	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00d98	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00d9c	99		 cdq
  00d9d	2b c2		 sub	 eax, edx
  00d9f	d1 f8		 sar	 eax, 1
  00da1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00da5	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00da8	f3 0f 10 49 14	 movss	 xmm1, DWORD PTR [ecx+20]
  00dad	f3 0f 5c c8	 subss	 xmm1, xmm0
  00db1	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00db4	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00db8	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00dbb	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  00dbf	2b c2		 sub	 eax, edx
  00dc1	99		 cdq
  00dc2	2b c2		 sub	 eax, edx
  00dc4	d1 f8		 sar	 eax, 1
  00dc6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00dca	f3 0f 5c c8	 subss	 xmm1, xmm0
  00dce	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _floorheight$15[ebp]
  00dd4	83 e8 01	 sub	 eax, 1
  00dd7	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00ddb	f3 0f 5c c8	 subss	 xmm1, xmm0
  00ddf	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv714[ebp], xmm1
  00de7	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00dec	6b d1 03	 imul	 edx, ecx, 3
  00def	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv714[ebp]
  00df7	f3 0f 11 84 15
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+4], xmm0
  00e00	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00e05	d1 e0		 shl	 eax, 1
  00e07	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv714[ebp]
  00e0f	f3 0f 11 84 05
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+4], xmm0
  00e18	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00e1d	c1 e1 00	 shl	 ecx, 0
  00e20	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv714[ebp]
  00e28	f3 0f 11 84 0d
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+4], xmm0
  00e31	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00e36	6b c2 00	 imul	 eax, edx, 0
  00e39	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv714[ebp]
  00e41	f3 0f 11 84 05
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+4], xmm0

; 3440 : 				spr->ty - gpatch->height/2 - (gpatch->topoffset-gpatch->height)/2 - (floorheight-1);
; 3441 : 
; 3442 : 			// Spread out top away from the camera. (Fixme: Make it always move out in the same direction!... somehow.)
; 3443 : 			swallVerts[0].z = swallVerts[1].z = spr->tz - (gpatch->height-gpatch->topoffset)/2;

  00e4a	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00e4d	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00e51	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00e54	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00e58	2b c2		 sub	 eax, edx
  00e5a	99		 cdq
  00e5b	2b c2		 sub	 eax, edx
  00e5d	d1 f8		 sar	 eax, 1
  00e5f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00e63	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00e66	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  00e6b	f3 0f 5c c8	 subss	 xmm1, xmm0
  00e6f	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv729[ebp], xmm1
  00e77	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00e7c	c1 e1 00	 shl	 ecx, 0
  00e7f	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv729[ebp]
  00e87	f3 0f 11 84 0d
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+8], xmm0
  00e90	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00e95	6b c2 00	 imul	 eax, edx, 0
  00e98	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv729[ebp]
  00ea0	f3 0f 11 84 05
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+8], xmm0

; 3444 : 			swallVerts[2].z = swallVerts[3].z = spr->tz + gpatch->height/2 - (gpatch->height-gpatch->topoffset)/2;

  00ea9	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00eac	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00eb0	99		 cdq
  00eb1	2b c2		 sub	 eax, edx
  00eb3	d1 f8		 sar	 eax, 1
  00eb5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00eb9	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00ebc	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00ec1	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00ec4	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00ec8	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  00ecb	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00ecf	2b c2		 sub	 eax, edx
  00ed1	99		 cdq
  00ed2	2b c2		 sub	 eax, edx
  00ed4	d1 f8		 sar	 eax, 1
  00ed6	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00eda	f3 0f 5c c1	 subss	 xmm0, xmm1
  00ede	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv749[ebp], xmm0
  00ee6	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00eeb	6b c8 03	 imul	 ecx, eax, 3
  00eee	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv749[ebp]
  00ef6	f3 0f 11 84 0d
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+8], xmm0
  00eff	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00f04	d1 e2		 shl	 edx, 1
  00f06	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv749[ebp]
  00f0e	f3 0f 11 84 15
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+8], xmm0

; 3445 : 		}

  00f17	e9 69 01 00 00	 jmp	 $LN29@HWR_DrawSp
$LN28@HWR_DrawSp:

; 3446 : 		else
; 3447 : 		{
; 3448 : 			// Always a pixel above the floor, perfectly flat.
; 3449 : 			swallVerts[0].y = swallVerts[1].y = swallVerts[2].y = swallVerts[3].y =

  00f1c	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00f1f	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00f23	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00f27	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00f2a	f3 0f 10 4a 14	 movss	 xmm1, DWORD PTR [edx+20]
  00f2f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00f33	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00f36	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00f3a	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00f3d	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  00f41	2b c8		 sub	 ecx, eax
  00f43	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00f47	f3 0f 5c c8	 subss	 xmm1, xmm0
  00f4b	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _floorheight$15[ebp]
  00f51	83 c1 03	 add	 ecx, 3
  00f54	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00f58	f3 0f 5c c8	 subss	 xmm1, xmm0
  00f5c	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv776[ebp], xmm1
  00f64	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00f69	6b c2 03	 imul	 eax, edx, 3
  00f6c	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv776[ebp]
  00f74	f3 0f 11 84 05
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+4], xmm0
  00f7d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00f82	d1 e1		 shl	 ecx, 1
  00f84	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv776[ebp]
  00f8c	f3 0f 11 84 0d
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+4], xmm0
  00f95	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00f9a	c1 e2 00	 shl	 edx, 0
  00f9d	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv776[ebp]
  00fa5	f3 0f 11 84 15
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+4], xmm0
  00fae	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00fb3	6b c8 00	 imul	 ecx, eax, 0
  00fb6	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv776[ebp]
  00fbe	f3 0f 11 84 0d
	14 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+4], xmm0

; 3450 : 				spr->ty - gpatch->height - (gpatch->topoffset-gpatch->height) - (floorheight+3);
; 3451 : 
; 3452 : 			// Spread out top away from the camera. (Fixme: Make it always move out in the same direction!... somehow.)
; 3453 : 			swallVerts[0].z = swallVerts[1].z = spr->tz - (gpatch->height-gpatch->topoffset);

  00fc7	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00fca	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00fce	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00fd1	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00fd5	2b c8		 sub	 ecx, eax
  00fd7	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00fdb	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00fde	f3 0f 10 49 10	 movss	 xmm1, DWORD PTR [ecx+16]
  00fe3	f3 0f 5c c8	 subss	 xmm1, xmm0
  00fe7	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv790[ebp], xmm1
  00fef	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00ff4	c1 e2 00	 shl	 edx, 0
  00ff7	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv790[ebp]
  00fff	f3 0f 11 84 15
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+8], xmm0
  01008	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0100d	6b c8 00	 imul	 ecx, eax, 0
  01010	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv790[ebp]
  01018	f3 0f 11 84 0d
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+8], xmm0

; 3454 : 			swallVerts[2].z = swallVerts[3].z = spr->tz + gpatch->height - (gpatch->height-gpatch->topoffset);

  01021	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  01024	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  01028	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0102c	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  0102f	f3 0f 58 42 10	 addss	 xmm0, DWORD PTR [edx+16]
  01034	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  01037	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0103b	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  0103e	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  01042	2b c8		 sub	 ecx, eax
  01044	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  01048	f3 0f 5c c1	 subss	 xmm0, xmm1
  0104c	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv808[ebp], xmm0
  01054	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01059	6b d1 03	 imul	 edx, ecx, 3
  0105c	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv808[ebp]
  01064	f3 0f 11 84 15
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+8], xmm0
  0106d	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01072	d1 e0		 shl	 eax, 1
  01074	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv808[ebp]
  0107c	f3 0f 11 84 05
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+8], xmm0
$LN29@HWR_DrawSp:

; 3455 : 		}
; 3456 : 
; 3457 : 		// Huh setting the Y higher? Also moving this before to stop the alterations affecting it after scaling.
; 3458 : 		if (spr->mobj && spr->mobj->scale != 100)

  01085	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01088	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0108c	0f 84 ec 02 00
	00		 je	 $LN32@HWR_DrawSp
  01092	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01095	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01098	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  0109f	83 fa 64	 cmp	 edx, 100		; 00000064H
  010a2	0f 84 d6 02 00
	00		 je	 $LN32@HWR_DrawSp

; 3459 : 		{
; 3460 : 			const float radius = (spr->x2-spr->x1)/2;

  010a8	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  010ab	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  010ae	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  010b3	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  010b8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  010c0	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _radius$11[ebp], xmm0

; 3461 : 			const float scale = (float)(100-spr->mobj->scale);

  010c8	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  010cb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  010ce	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  010d5	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  010da	2b c2		 sub	 eax, edx
  010dc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  010e0	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _scale$10[ebp], xmm0

; 3462 : 			if(spr->mobj->flags & MF_HIRES)

  010e8	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  010eb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  010ee	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  010f1	81 e2 00 00 08
	00		 and	 edx, 524288		; 00080000H
  010f7	0f 84 4b 01 00
	00		 je	 $LN31@HWR_DrawSp

; 3463 : 			{
; 3464 : 				swallVerts[0].x = swallVerts[3].x += FLOATSCALE(radius,scale)/2;

  010fd	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01102	6b c8 03	 imul	 ecx, eax, 3
  01105	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _scale$10[ebp]
  0110d	f3 0f 59 85 f4
	fe ff ff	 mulss	 xmm0, DWORD PTR _radius$11[ebp]
  01115	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0111d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  01125	f3 0f 10 8c 0d
	10 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+ecx]
  0112e	f3 0f 58 c8	 addss	 xmm1, xmm0
  01132	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv842[ebp], xmm1
  0113a	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0113f	6b c2 03	 imul	 eax, edx, 3
  01142	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv842[ebp]
  0114a	f3 0f 11 84 05
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax], xmm0
  01153	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01158	6b d1 00	 imul	 edx, ecx, 0
  0115b	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv842[ebp]
  01163	f3 0f 11 84 15
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx], xmm0

; 3465 : 				swallVerts[2].x = swallVerts[1].x -= FLOATSCALE(radius,scale)/2;

  0116c	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01171	c1 e0 00	 shl	 eax, 0
  01174	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _scale$10[ebp]
  0117c	f3 0f 59 85 f4
	fe ff ff	 mulss	 xmm0, DWORD PTR _radius$11[ebp]
  01184	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0118c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  01194	f3 0f 10 8c 05
	10 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+eax]
  0119d	f3 0f 5c c8	 subss	 xmm1, xmm0
  011a1	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv856[ebp], xmm1
  011a9	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  011ae	c1 e1 00	 shl	 ecx, 0
  011b1	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv856[ebp]
  011b9	f3 0f 11 84 0d
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx], xmm0
  011c2	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  011c7	d1 e2		 shl	 edx, 1
  011c9	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv856[ebp]
  011d1	f3 0f 11 84 15
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx], xmm0

; 3466 : 				swallVerts[2].z = swallVerts[3].z -= FLOATSCALE(gpatch->height,scale);

  011da	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  011df	6b c8 03	 imul	 ecx, eax, 3
  011e2	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  011e5	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  011e9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  011ed	f3 0f 59 85 f0
	fe ff ff	 mulss	 xmm0, DWORD PTR _scale$10[ebp]
  011f5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  011fd	f3 0f 10 8c 0d
	18 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+ecx+8]
  01206	f3 0f 5c c8	 subss	 xmm1, xmm0
  0120a	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv872[ebp], xmm1
  01212	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01217	6b d1 03	 imul	 edx, ecx, 3
  0121a	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv872[ebp]
  01222	f3 0f 11 84 15
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+8], xmm0
  0122b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01230	d1 e0		 shl	 eax, 1
  01232	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv872[ebp]
  0123a	f3 0f 11 84 05
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+8], xmm0

; 3467 : 			}

  01243	e9 36 01 00 00	 jmp	 $LN32@HWR_DrawSp
$LN31@HWR_DrawSp:

; 3468 : 			else
; 3469 : 			{
; 3470 : 				swallVerts[0].x = swallVerts[3].x += FLOATSCALE(radius,scale);

  01248	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0124d	6b c8 03	 imul	 ecx, eax, 3
  01250	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _scale$10[ebp]
  01258	f3 0f 59 85 f4
	fe ff ff	 mulss	 xmm0, DWORD PTR _radius$11[ebp]
  01260	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  01268	f3 0f 10 8c 0d
	10 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+ecx]
  01271	f3 0f 58 c8	 addss	 xmm1, xmm0
  01275	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv885[ebp], xmm1
  0127d	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01282	6b c2 03	 imul	 eax, edx, 3
  01285	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv885[ebp]
  0128d	f3 0f 11 84 05
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax], xmm0
  01296	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0129b	6b d1 00	 imul	 edx, ecx, 0
  0129e	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv885[ebp]
  012a6	f3 0f 11 84 15
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx], xmm0

; 3471 : 				swallVerts[2].x = swallVerts[1].x -= FLOATSCALE(radius,scale);

  012af	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  012b4	c1 e0 00	 shl	 eax, 0
  012b7	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _scale$10[ebp]
  012bf	f3 0f 59 85 f4
	fe ff ff	 mulss	 xmm0, DWORD PTR _radius$11[ebp]
  012c7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  012cf	f3 0f 10 8c 05
	10 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+eax]
  012d8	f3 0f 5c c8	 subss	 xmm1, xmm0
  012dc	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv898[ebp], xmm1
  012e4	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  012e9	c1 e1 00	 shl	 ecx, 0
  012ec	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv898[ebp]
  012f4	f3 0f 11 84 0d
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx], xmm0
  012fd	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01302	d1 e2		 shl	 edx, 1
  01304	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv898[ebp]
  0130c	f3 0f 11 84 15
	10 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx], xmm0

; 3472 : 				swallVerts[2].z = swallVerts[3].z -= FLOATSCALE(gpatch->height,scale);

  01315	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0131a	6b c8 03	 imul	 ecx, eax, 3
  0131d	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  01320	0f bf 42 02	 movsx	 eax, WORD PTR [edx+2]
  01324	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  01328	f3 0f 59 85 f0
	fe ff ff	 mulss	 xmm0, DWORD PTR _scale$10[ebp]
  01330	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  01338	f3 0f 10 8c 0d
	18 ff ff ff	 movss	 xmm1, DWORD PTR _swallVerts$17[ebp+ecx+8]
  01341	f3 0f 5c c8	 subss	 xmm1, xmm0
  01345	f3 0f 11 8d 88
	fe ff ff	 movss	 DWORD PTR tv914[ebp], xmm1
  0134d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01352	6b d1 03	 imul	 edx, ecx, 3
  01355	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv914[ebp]
  0135d	f3 0f 11 84 15
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+8], xmm0
  01366	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0136b	d1 e0		 shl	 eax, 1
  0136d	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv914[ebp]
  01375	f3 0f 11 84 05
	18 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+8], xmm0
$LN32@HWR_DrawSp:

; 3473 : 			}
; 3474 : 		}
; 3475 : 
; 3476 : 		// transform
; 3477 : 		wv = swallVerts;

  0137e	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _swallVerts$17[ebp]
  01384	89 45 8c	 mov	 DWORD PTR _wv$[ebp], eax

; 3478 : 
; 3479 : 		for (i = 0; i < 4; i++,wv++)

  01387	c6 45 fb 00	 mov	 BYTE PTR _i$[ebp], 0
  0138b	eb 11		 jmp	 SHORT $LN7@HWR_DrawSp
$LN5@HWR_DrawSp:
  0138d	8a 45 fb	 mov	 al, BYTE PTR _i$[ebp]
  01390	04 01		 add	 al, 1
  01392	88 45 fb	 mov	 BYTE PTR _i$[ebp], al
  01395	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  01398	83 c1 18	 add	 ecx, 24			; 00000018H
  0139b	89 4d 8c	 mov	 DWORD PTR _wv$[ebp], ecx
$LN7@HWR_DrawSp:
  0139e	0f b6 45 fb	 movzx	 eax, BYTE PTR _i$[ebp]
  013a2	83 f8 04	 cmp	 eax, 4
  013a5	0f 8d da 00 00
	00		 jge	 $LN6@HWR_DrawSp

; 3480 : 		{
; 3481 : 			// Offset away from the camera based on height from floor.
; 3482 : 			if (cv_shadowoffs.value)

  013ab	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_shadowoffs+20, 0
  013b2	74 18		 je	 SHORT $LN33@HWR_DrawSp

; 3483 : 				wv->z += floorheight;

  013b4	f3 0f 2a 85 04
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _floorheight$15[ebp]
  013bc	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  013bf	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  013c4	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  013c7	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
$LN33@HWR_DrawSp:

; 3484 : 			wv->z += 3;

  013cc	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  013cf	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  013d4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40400000
  013dc	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  013df	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 3485 : 
; 3486 : 			//look up/down ----TOTAL SUCKS!!!--- do the 2 in one!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; 3487 : 			tr_x = wv->z;

  013e4	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  013e7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  013ec	f3 0f 11 45 f4	 movss	 DWORD PTR _tr_x$[ebp], xmm0

; 3488 : 			tr_y = wv->y;

  013f1	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  013f4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  013f9	f3 0f 11 45 f0	 movss	 DWORD PTR _tr_y$[ebp], xmm0

; 3489 : 			wv->y = (tr_x * gr_viewludcos) + (tr_y * gr_viewludsin);

  013fe	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  01403	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewludcos
  0140b	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  01410	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewludsin
  01418	f3 0f 58 c1	 addss	 xmm0, xmm1
  0141c	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  0141f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 3490 : 			wv->z = (tr_x * gr_viewludsin) - (tr_y * gr_viewludcos);

  01424	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  01429	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewludsin
  01431	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  01436	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewludcos
  0143e	f3 0f 5c c1	 subss	 xmm0, xmm1
  01442	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  01445	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 3491 : 			// ---------------------- mega lame test ----------------------------------
; 3492 : 
; 3493 : 			//scale y before frustum so that frustum can be scaled to screen height
; 3494 : 			wv->y *= ORIGINAL_ASPECT * gr_fovlud;

  0144a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fcccccd
  01452	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_fovlud
  0145a	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  0145d	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  01462	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  01465	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 3495 : 			wv->x *= gr_fovlud;

  0146a	8b 45 8c	 mov	 eax, DWORD PTR _wv$[ebp]
  0146d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01471	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_fovlud
  01479	8b 4d 8c	 mov	 ecx, DWORD PTR _wv$[ebp]
  0147c	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 3496 : 		}

  01480	e9 08 ff ff ff	 jmp	 $LN5@HWR_DrawSp
$LN6@HWR_DrawSp:

; 3497 : 
; 3498 : 		if (spr->flip)

  01485	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01488	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0148c	74 5c		 je	 SHORT $LN34@HWR_DrawSp

; 3499 : 		{
; 3500 : 			swallVerts[0].sow = swallVerts[3].sow = gpatch->max_s;

  0148e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01493	6b c8 03	 imul	 ecx, eax, 3
  01496	8b 55 88	 mov	 edx, DWORD PTR _gpatch$[ebp]
  01499	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0149c	89 84 0d 20 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+ecx+16], eax
  014a3	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  014a8	6b d1 03	 imul	 edx, ecx, 3
  014ab	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  014b0	6b c8 00	 imul	 ecx, eax, 0
  014b3	8b 94 15 20 ff
	ff ff		 mov	 edx, DWORD PTR _swallVerts$17[ebp+edx+16]
  014ba	89 94 0d 20 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+ecx+16], edx

; 3501 : 			swallVerts[2].sow = swallVerts[1].sow = 0;

  014c1	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  014c6	c1 e0 00	 shl	 eax, 0
  014c9	0f 57 c0	 xorps	 xmm0, xmm0
  014cc	f3 0f 11 84 05
	20 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+16], xmm0
  014d5	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  014da	d1 e1		 shl	 ecx, 1
  014dc	0f 57 c0	 xorps	 xmm0, xmm0
  014df	f3 0f 11 84 0d
	20 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+16], xmm0

; 3502 : 		}

  014e8	eb 5a		 jmp	 SHORT $LN35@HWR_DrawSp
$LN34@HWR_DrawSp:

; 3503 : 		else
; 3504 : 		{
; 3505 : 			swallVerts[0].sow = swallVerts[3].sow = 0;

  014ea	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  014ef	6b c8 03	 imul	 ecx, eax, 3
  014f2	0f 57 c0	 xorps	 xmm0, xmm0
  014f5	f3 0f 11 84 0d
	20 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+16], xmm0
  014fe	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01503	6b c2 00	 imul	 eax, edx, 0
  01506	0f 57 c0	 xorps	 xmm0, xmm0
  01509	f3 0f 11 84 05
	20 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+16], xmm0

; 3506 : 			swallVerts[2].sow = swallVerts[1].sow = gpatch->max_s;

  01512	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01517	c1 e0 00	 shl	 eax, 0
  0151a	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  0151d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01520	89 94 05 20 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+eax+16], edx
  01527	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0152c	c1 e0 00	 shl	 eax, 0
  0152f	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01534	d1 e1		 shl	 ecx, 1
  01536	8b 94 05 20 ff
	ff ff		 mov	 edx, DWORD PTR _swallVerts$17[ebp+eax+16]
  0153d	89 94 0d 20 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+ecx+16], edx
$LN35@HWR_DrawSp:

; 3507 : 		}
; 3508 : 		swallVerts[3].tow = swallVerts[2].tow = 0;

  01544	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01549	d1 e0		 shl	 eax, 1
  0154b	0f 57 c0	 xorps	 xmm0, xmm0
  0154e	f3 0f 11 84 05
	24 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+20], xmm0
  01557	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0155c	6b d1 03	 imul	 edx, ecx, 3
  0155f	0f 57 c0	 xorps	 xmm0, xmm0
  01562	f3 0f 11 84 15
	24 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+edx+20], xmm0

; 3509 : 
; 3510 : 		if (hires)

  0156b	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _hires$[ebp], 0
  01572	74 4c		 je	 SHORT $LN36@HWR_DrawSp

; 3511 : 			swallVerts[0].tow = swallVerts[1].tow = gpatch->max_t*2;

  01574	8b 45 88	 mov	 eax, DWORD PTR _gpatch$[ebp]
  01577	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0157c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  01584	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR tv996[ebp], xmm0
  0158c	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01591	c1 e1 00	 shl	 ecx, 0
  01594	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv996[ebp]
  0159c	f3 0f 11 84 0d
	24 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+ecx+20], xmm0
  015a5	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  015aa	6b c2 00	 imul	 eax, edx, 0
  015ad	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR tv996[ebp]
  015b5	f3 0f 11 84 05
	24 ff ff ff	 movss	 DWORD PTR _swallVerts$17[ebp+eax+20], xmm0
  015be	eb 33		 jmp	 SHORT $LN37@HWR_DrawSp
$LN36@HWR_DrawSp:

; 3512 : 		else
; 3513 : 			swallVerts[0].tow = swallVerts[1].tow = gpatch->max_t;

  015c0	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  015c5	c1 e0 00	 shl	 eax, 0
  015c8	8b 4d 88	 mov	 ecx, DWORD PTR _gpatch$[ebp]
  015cb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  015ce	89 94 05 24 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+eax+20], edx
  015d5	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  015da	c1 e0 00	 shl	 eax, 0
  015dd	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  015e2	6b d1 00	 imul	 edx, ecx, 0
  015e5	8b 84 05 24 ff
	ff ff		 mov	 eax, DWORD PTR _swallVerts$17[ebp+eax+20]
  015ec	89 84 15 24 ff
	ff ff		 mov	 DWORD PTR _swallVerts$17[ebp+edx+20], eax
$LN37@HWR_DrawSp:

; 3514 : 
; 3515 : 		sSurf.FlatColor.s.red = 0x00;

  015f3	c6 85 0c ff ff
	ff 00		 mov	 BYTE PTR _sSurf$16[ebp+4], 0

; 3516 : 		sSurf.FlatColor.s.blue = 0x00;

  015fa	c6 85 0e ff ff
	ff 00		 mov	 BYTE PTR _sSurf$16[ebp+6], 0

; 3517 : 		sSurf.FlatColor.s.green = 0x00;

  01601	c6 85 0d ff ff
	ff 00		 mov	 BYTE PTR _sSurf$16[ebp+5], 0

; 3518 : 
; 3519 : 		if (spr->mobj->frame & FF_TRANSMASK || spr->mobj->flags2 & MF2_SHADOW)

  01608	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0160b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0160e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01611	81 e2 00 00 0f
	00		 and	 edx, 983040		; 000f0000H
  01617	75 18		 jne	 SHORT $LN40@HWR_DrawSp
  01619	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0161c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0161f	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  01625	81 e2 00 00 00
	01		 and	 edx, 16777216		; 01000000H
  0162b	0f 84 98 01 00
	00		 je	 $LN38@HWR_DrawSp
$LN40@HWR_DrawSp:

; 3520 : 		{
; 3521 : #ifdef HARDWAREFIX
; 3522 : 			sector_t *sector = spr->mobj->subsector->sector;

  01631	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01634	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01637	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0163a	8b 02		 mov	 eax, DWORD PTR [edx]
  0163c	89 85 ec fe ff
	ff		 mov	 DWORD PTR _sector$9[ebp], eax

; 3523 : 			UINT8 lightlevel = LightLevelToLum(sector->lightlevel);

  01642	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  01648	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0164c	51		 push	 ecx
  0164d	e8 00 00 00 00	 call	 _LightLevelToLum
  01652	83 c4 04	 add	 esp, 4
  01655	88 85 eb fe ff
	ff		 mov	 BYTE PTR _lightlevel$8[ebp], al

; 3524 : 			extracolormap_t *colormap = sector->extra_colormap;

  0165b	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  01661	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  01667	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _colormap$7[ebp], ecx

; 3525 : 
; 3526 : 			if (sector->numlights)

  0166d	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  01673	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  0167a	0f 84 a9 00 00
	00		 je	 $LN41@HWR_DrawSp

; 3527 : 			{
; 3528 : 				INT32 light = R_GetPlaneLight(sector, spr->mobj->floorz, false);

  01680	6a 00		 push	 0
  01682	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01685	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01688	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0168b	52		 push	 edx
  0168c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  01692	50		 push	 eax
  01693	e8 00 00 00 00	 call	 _R_GetPlaneLight
  01698	83 c4 0c	 add	 esp, 12			; 0000000cH
  0169b	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _light$6[ebp], eax

; 3529 : 
; 3530 : 				if (!(spr->mobj->frame & FF_FULLBRIGHT))

  016a1	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  016a4	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  016a7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  016aa	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  016b0	75 2b		 jne	 SHORT $LN43@HWR_DrawSp

; 3531 : 					lightlevel = LightLevelToLum(*sector->lightlist[light].lightlevel);

  016b2	6b 85 e0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$6[ebp], 20
  016b9	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _sector$9[ebp]
  016bf	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  016c5	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  016c9	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  016cc	51		 push	 ecx
  016cd	e8 00 00 00 00	 call	 _LightLevelToLum
  016d2	83 c4 04	 add	 esp, 4
  016d5	88 85 eb fe ff
	ff		 mov	 BYTE PTR _lightlevel$8[ebp], al
  016db	eb 13		 jmp	 SHORT $LN44@HWR_DrawSp
$LN43@HWR_DrawSp:

; 3532 : 				else
; 3533 : 					lightlevel = LightLevelToLum(255);

  016dd	68 ff 00 00 00	 push	 255			; 000000ffH
  016e2	e8 00 00 00 00	 call	 _LightLevelToLum
  016e7	83 c4 04	 add	 esp, 4
  016ea	88 85 eb fe ff
	ff		 mov	 BYTE PTR _lightlevel$8[ebp], al
$LN44@HWR_DrawSp:

; 3534 : 
; 3535 : 				if (sector->lightlist[light].extra_colormap)

  016f0	6b 85 e0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$6[ebp], 20
  016f7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _sector$9[ebp]
  016fd	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01703	83 7c 02 08 00	 cmp	 DWORD PTR [edx+eax+8], 0
  01708	74 1d		 je	 SHORT $LN45@HWR_DrawSp

; 3536 : 					colormap = sector->lightlist[light].extra_colormap;

  0170a	6b 85 e0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$6[ebp], 20
  01711	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _sector$9[ebp]
  01717	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0171d	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  01721	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _colormap$7[ebp], eax
$LN45@HWR_DrawSp:

; 3537 : 			}

  01727	eb 3a		 jmp	 SHORT $LN46@HWR_DrawSp
$LN41@HWR_DrawSp:

; 3538 : 			else
; 3539 : 			{
; 3540 : 				lightlevel = LightLevelToLum(sector->lightlevel);

  01729	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  0172f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  01733	51		 push	 ecx
  01734	e8 00 00 00 00	 call	 _LightLevelToLum
  01739	83 c4 04	 add	 esp, 4
  0173c	88 85 eb fe ff
	ff		 mov	 BYTE PTR _lightlevel$8[ebp], al

; 3541 : 
; 3542 : 				if (sector->extra_colormap)

  01742	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  01748	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  0174f	74 12		 je	 SHORT $LN46@HWR_DrawSp

; 3543 : 					colormap = sector->extra_colormap;

  01751	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _sector$9[ebp]
  01757	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0175d	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _colormap$7[ebp], ecx
$LN46@HWR_DrawSp:

; 3544 : 			}
; 3545 : 
; 3546 : 			if (colormap)

  01763	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _colormap$7[ebp], 0
  0176a	74 35		 je	 SHORT $LN47@HWR_DrawSp

; 3547 : 				sSurf.FlatColor.rgba = HWR_Lighting(lightlevel/2, colormap->rgba, colormap->fadergba, false, true);

  0176c	6a 01		 push	 1
  0176e	6a 00		 push	 0
  01770	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _colormap$7[ebp]
  01776	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01779	51		 push	 ecx
  0177a	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _colormap$7[ebp]
  01780	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01783	50		 push	 eax
  01784	0f b6 85 eb fe
	ff ff		 movzx	 eax, BYTE PTR _lightlevel$8[ebp]
  0178b	99		 cdq
  0178c	2b c2		 sub	 eax, edx
  0178e	d1 f8		 sar	 eax, 1
  01790	50		 push	 eax
  01791	e8 00 00 00 00	 call	 _HWR_Lighting
  01796	83 c4 14	 add	 esp, 20			; 00000014H
  01799	89 85 0c ff ff
	ff		 mov	 DWORD PTR _sSurf$16[ebp+4], eax
  0179f	eb 26		 jmp	 SHORT $LN48@HWR_DrawSp
$LN47@HWR_DrawSp:

; 3548 : 			else
; 3549 : 				sSurf.FlatColor.rgba = HWR_Lighting(lightlevel/2, NORMALFOG, FADEFOG, false, true);

  017a1	6a 01		 push	 1
  017a3	6a 00		 push	 0
  017a5	68 00 00 00 19	 push	 419430400		; 19000000H
  017aa	6a 00		 push	 0
  017ac	0f b6 85 eb fe
	ff ff		 movzx	 eax, BYTE PTR _lightlevel$8[ebp]
  017b3	99		 cdq
  017b4	2b c2		 sub	 eax, edx
  017b6	d1 f8		 sar	 eax, 1
  017b8	50		 push	 eax
  017b9	e8 00 00 00 00	 call	 _HWR_Lighting
  017be	83 c4 14	 add	 esp, 20			; 00000014H
  017c1	89 85 0c ff ff
	ff		 mov	 DWORD PTR _sSurf$16[ebp+4], eax
$LN48@HWR_DrawSp:

; 3550 : #else
; 3551 : 			// sprite lighting by modulating the RGB components
; 3552 : 			sSurf.FlatColor.s.red = sSurf.FlatColor.s.green = sSurf.FlatColor.s.blue = (UINT8)(spr->sectorlight/2);
; 3553 : #endif
; 3554 : 		}

  017c7	eb 07		 jmp	 SHORT $LN39@HWR_DrawSp
$LN38@HWR_DrawSp:

; 3555 : 		else
; 3556 : #ifdef HARDWAREFIX
; 3557 : 			Surf.FlatColor.rgba = NORMALFOG;

  017c9	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _Surf$[ebp+4], 0
$LN39@HWR_DrawSp:

; 3558 : #else
; 3559 : 			sSurf.FlatColor.s.red = sSurf.FlatColor.s.green = sSurf.FlatColor.s.blue = 0x00;
; 3560 : #endif
; 3561 : 
; 3562 : 		/// \todo do the test earlier
; 3563 : 		if (!cv_grmd2.value || (md2_models[spr->mobj->sprite].scale < 0.0f) || (md2_models[spr->mobj->sprite].notfound = true) || (md2_playermodels[(skin_t*)spr->mobj->skin-skins].scale < 0.0f) || (md2_playermodels[(skin_t*)spr->mobj->skin-skins].notfound = true))

  017d0	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  017d7	0f 84 84 00 00
	00		 je	 $LN50@HWR_DrawSp
  017dd	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  017e0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  017e3	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  017e7	0f 57 c0	 xorps	 xmm0, xmm0
  017ea	0f 2f 82 20 00
	00 00		 comiss	 xmm0, DWORD PTR _md2_models[edx+32]
  017f1	77 6e		 ja	 SHORT $LN50@HWR_DrawSp
  017f3	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  017f6	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  017f9	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  017fd	c7 82 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_models[edx+48], 1
  01807	b8 01 00 00 00	 mov	 eax, 1
  0180c	85 c0		 test	 eax, eax
  0180e	75 51		 jne	 SHORT $LN50@HWR_DrawSp
  01810	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01813	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01816	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  01819	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  0181e	99		 cdq
  0181f	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  01824	f7 f9		 idiv	 ecx
  01826	6b d0 38	 imul	 edx, eax, 56
  01829	0f 57 c0	 xorps	 xmm0, xmm0
  0182c	0f 2f 82 20 00
	00 00		 comiss	 xmm0, DWORD PTR _md2_playermodels[edx+32]
  01833	77 2c		 ja	 SHORT $LN50@HWR_DrawSp
  01835	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01838	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0183b	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  0183e	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  01843	99		 cdq
  01844	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  01849	f7 f9		 idiv	 ecx
  0184b	6b d0 38	 imul	 edx, eax, 56
  0184e	c7 82 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_playermodels[edx+48], 1
  01858	b8 01 00 00 00	 mov	 eax, 1
  0185d	85 c0		 test	 eax, eax
  0185f	74 4e		 je	 SHORT $noshadow$77
$LN50@HWR_DrawSp:

; 3564 : 		{
; 3565 : 			if (0x80 > floorheight/4)

  01861	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _floorheight$15[ebp]
  01867	99		 cdq
  01868	83 e2 03	 and	 edx, 3
  0186b	03 c2		 add	 eax, edx
  0186d	c1 f8 02	 sar	 eax, 2
  01870	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  01875	7d 38		 jge	 SHORT $noshadow$77

; 3566 : 			{
; 3567 : 				sSurf.FlatColor.s.alpha = (UINT8)(0x80 - floorheight/4);

  01877	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _floorheight$15[ebp]
  0187d	99		 cdq
  0187e	83 e2 03	 and	 edx, 3
  01881	03 c2		 add	 eax, edx
  01883	c1 f8 02	 sar	 eax, 2
  01886	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0188b	2b c8		 sub	 ecx, eax
  0188d	88 8d 0f ff ff
	ff		 mov	 BYTE PTR _sSurf$16[ebp+7], cl

; 3568 : 				HWD.pfnDrawPolygon(&sSurf, swallVerts, 4, PF_Translucent|PF_Modulated|PF_Clip);

  01893	68 02 10 00 40	 push	 1073745922		; 40001002H
  01898	6a 04		 push	 4
  0189a	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _swallVerts$17[ebp]
  018a0	50		 push	 eax
  018a1	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _sSurf$16[ebp]
  018a7	51		 push	 ecx
  018a8	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  018ae	90		 npad	 1
$noshadow$77:

; 3569 : 			}
; 3570 : 		}
; 3571 : 	}
; 3572 : 
; 3573 : noshadow:
; 3574 : 
; 3575 : 	// This needs to be AFTER the shadows so that the regular sprites aren't drawn completely black.
; 3576 : 	// sprite lighting by modulating the RGB components
; 3577 : 	/// \todo coloured
; 3578 : #ifndef HARDWAREFIX
; 3579 : 	Surf.FlatColor.s.red = Surf.FlatColor.s.green = Surf.FlatColor.s.blue = spr->sectorlight;
; 3580 : #endif
; 3581 : 
; 3582 : 	// colormap test
; 3583 : 	{
; 3584 : #ifdef HARDWAREFIX
; 3585 : 		sector_t *sector = spr->mobj->subsector->sector;

  018af	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  018b2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  018b5	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  018b8	8b 02		 mov	 eax, DWORD PTR [edx]
  018ba	89 85 dc fe ff
	ff		 mov	 DWORD PTR _sector$5[ebp], eax

; 3586 : 		UINT8 lightlevel = LightLevelToLum(sector->lightlevel);

  018c0	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  018c6	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  018ca	51		 push	 ecx
  018cb	e8 00 00 00 00	 call	 _LightLevelToLum
  018d0	83 c4 04	 add	 esp, 4
  018d3	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al

; 3587 : 		extracolormap_t *colormap = sector->extra_colormap;

  018d9	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  018df	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  018e5	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _colormap$3[ebp], ecx

; 3588 : 
; 3589 : 		if (sector->numlights)

  018eb	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  018f1	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  018f8	0f 84 ac 01 00
	00		 je	 $LN52@HWR_DrawSp

; 3590 : 		{
; 3591 : 			INT32 light = R_GetPlaneLight(sector, spr->mobj->z, false);

  018fe	6a 00		 push	 0
  01900	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01903	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01906	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01909	52		 push	 edx
  0190a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  01910	50		 push	 eax
  01911	e8 00 00 00 00	 call	 _R_GetPlaneLight
  01916	83 c4 0c	 add	 esp, 12			; 0000000cH
  01919	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _light$2[ebp], eax

; 3592 : 
; 3593 : 			if ((sector->lightlist[light].height > (spr->mobj->z + spr->mobj->height)) && !(sector->lightlist[light].flags & FF_NOSHADE))

  0191f	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  01926	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  0192c	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01932	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  01935	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  01938	8b 75 08	 mov	 esi, DWORD PTR _spr$[ebp]
  0193b	8b 76 24	 mov	 esi, DWORD PTR [esi+36]
  0193e	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  01941	03 4e 44	 add	 ecx, DWORD PTR [esi+68]
  01944	39 0c 02	 cmp	 DWORD PTR [edx+eax], ecx
  01947	0f 8e ab 00 00
	00		 jle	 $LN54@HWR_DrawSp
  0194d	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  01954	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  0195a	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01960	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  01964	83 e0 40	 and	 eax, 64			; 00000040H
  01967	0f 85 8b 00 00
	00		 jne	 $LN54@HWR_DrawSp

; 3594 : 			{
; 3595 : 				if (!(spr->mobj->frame & FF_FULLBRIGHT))

  0196d	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01970	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01973	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01976	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  0197c	75 2b		 jne	 SHORT $LN56@HWR_DrawSp

; 3596 : 					lightlevel = LightLevelToLum(*sector->lightlist[light].lightlevel);

  0197e	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  01985	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  0198b	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01991	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  01995	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01998	51		 push	 ecx
  01999	e8 00 00 00 00	 call	 _LightLevelToLum
  0199e	83 c4 04	 add	 esp, 4
  019a1	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
  019a7	eb 13		 jmp	 SHORT $LN57@HWR_DrawSp
$LN56@HWR_DrawSp:

; 3597 : 				else
; 3598 : 					lightlevel = LightLevelToLum(255);

  019a9	68 ff 00 00 00	 push	 255			; 000000ffH
  019ae	e8 00 00 00 00	 call	 _LightLevelToLum
  019b3	83 c4 04	 add	 esp, 4
  019b6	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
$LN57@HWR_DrawSp:

; 3599 : 
; 3600 : 				if (sector->lightlist[light].extra_colormap)

  019bc	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  019c3	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  019c9	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  019cf	83 7c 02 08 00	 cmp	 DWORD PTR [edx+eax+8], 0
  019d4	74 1d		 je	 SHORT $LN58@HWR_DrawSp

; 3601 : 					colormap = sector->lightlist[light].extra_colormap;

  019d6	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  019dd	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  019e3	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  019e9	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  019ed	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _colormap$3[ebp], eax
$LN58@HWR_DrawSp:

; 3602 : 			}

  019f3	e9 b0 00 00 00	 jmp	 $LN61@HWR_DrawSp
$LN54@HWR_DrawSp:

; 3603 : 			else // If we can't use the light at its bottom, we'll use the light at its top
; 3604 : 			{
; 3605 : 				light = R_GetPlaneLight(sector, spr->mobj->z + spr->mobj->height, false);

  019f8	6a 00		 push	 0
  019fa	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  019fd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01a00	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  01a03	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  01a06	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  01a09	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  01a0c	51		 push	 ecx
  01a0d	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _sector$5[ebp]
  01a13	52		 push	 edx
  01a14	e8 00 00 00 00	 call	 _R_GetPlaneLight
  01a19	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a1c	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _light$2[ebp], eax

; 3606 : 
; 3607 : 				if (!(spr->mobj->frame & FF_FULLBRIGHT))

  01a22	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01a25	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01a28	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01a2b	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  01a31	75 2b		 jne	 SHORT $LN59@HWR_DrawSp

; 3608 : 					lightlevel = LightLevelToLum(*sector->lightlist[light].lightlevel);

  01a33	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  01a3a	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  01a40	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01a46	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  01a4a	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  01a4d	51		 push	 ecx
  01a4e	e8 00 00 00 00	 call	 _LightLevelToLum
  01a53	83 c4 04	 add	 esp, 4
  01a56	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
  01a5c	eb 13		 jmp	 SHORT $LN60@HWR_DrawSp
$LN59@HWR_DrawSp:

; 3609 : 				else
; 3610 : 					lightlevel = LightLevelToLum(255);

  01a5e	68 ff 00 00 00	 push	 255			; 000000ffH
  01a63	e8 00 00 00 00	 call	 _LightLevelToLum
  01a68	83 c4 04	 add	 esp, 4
  01a6b	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
$LN60@HWR_DrawSp:

; 3611 : 
; 3612 : 				if (sector->lightlist[light].extra_colormap)

  01a71	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  01a78	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  01a7e	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01a84	83 7c 02 08 00	 cmp	 DWORD PTR [edx+eax+8], 0
  01a89	74 1d		 je	 SHORT $LN61@HWR_DrawSp

; 3613 : 					colormap = sector->lightlist[light].extra_colormap;

  01a8b	6b 85 d0 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$2[ebp], 20
  01a92	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _sector$5[ebp]
  01a98	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01a9e	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  01aa2	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _colormap$3[ebp], eax
$LN61@HWR_DrawSp:

; 3614 : 			}
; 3615 : 		}

  01aa8	eb 60		 jmp	 SHORT $LN64@HWR_DrawSp
$LN52@HWR_DrawSp:

; 3616 : 		else
; 3617 : 		{
; 3618 : 			if (!(spr->mobj->frame & FF_FULLBRIGHT))

  01aaa	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01aad	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01ab0	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01ab3	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  01ab9	75 1b		 jne	 SHORT $LN62@HWR_DrawSp

; 3619 : 				lightlevel = LightLevelToLum(sector->lightlevel);

  01abb	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  01ac1	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  01ac5	51		 push	 ecx
  01ac6	e8 00 00 00 00	 call	 _LightLevelToLum
  01acb	83 c4 04	 add	 esp, 4
  01ace	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
  01ad4	eb 13		 jmp	 SHORT $LN63@HWR_DrawSp
$LN62@HWR_DrawSp:

; 3620 : 			else
; 3621 : 				lightlevel = LightLevelToLum(255);

  01ad6	68 ff 00 00 00	 push	 255			; 000000ffH
  01adb	e8 00 00 00 00	 call	 _LightLevelToLum
  01ae0	83 c4 04	 add	 esp, 4
  01ae3	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
$LN63@HWR_DrawSp:

; 3622 : 
; 3623 : 			if (sector->extra_colormap)

  01ae9	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  01aef	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  01af6	74 12		 je	 SHORT $LN64@HWR_DrawSp

; 3624 : 				colormap = sector->extra_colormap;

  01af8	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _sector$5[ebp]
  01afe	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  01b04	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _colormap$3[ebp], ecx
$LN64@HWR_DrawSp:

; 3625 : 		}
; 3626 : 
; 3627 : 		if (spr->mobj->frame & FF_FULLBRIGHT)

  01b0a	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01b0d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01b10	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01b13	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  01b19	74 13		 je	 SHORT $LN65@HWR_DrawSp

; 3628 : 			lightlevel = LightLevelToLum(255);

  01b1b	68 ff 00 00 00	 push	 255			; 000000ffH
  01b20	e8 00 00 00 00	 call	 _LightLevelToLum
  01b25	83 c4 04	 add	 esp, 4
  01b28	88 85 db fe ff
	ff		 mov	 BYTE PTR _lightlevel$4[ebp], al
$LN65@HWR_DrawSp:

; 3629 : 
; 3630 : 		if (colormap)

  01b2e	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _colormap$3[ebp], 0
  01b35	74 2d		 je	 SHORT $LN66@HWR_DrawSp

; 3631 : 			Surf.FlatColor.rgba = HWR_Lighting(lightlevel, colormap->rgba, colormap->fadergba, false, false);

  01b37	6a 00		 push	 0
  01b39	6a 00		 push	 0
  01b3b	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _colormap$3[ebp]
  01b41	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01b44	51		 push	 ecx
  01b45	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _colormap$3[ebp]
  01b4b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01b4e	50		 push	 eax
  01b4f	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _lightlevel$4[ebp]
  01b56	51		 push	 ecx
  01b57	e8 00 00 00 00	 call	 _HWR_Lighting
  01b5c	83 c4 14	 add	 esp, 20			; 00000014H
  01b5f	89 45 84	 mov	 DWORD PTR _Surf$[ebp+4], eax
  01b62	eb 1e		 jmp	 SHORT $LN67@HWR_DrawSp
$LN66@HWR_DrawSp:

; 3632 : 		else
; 3633 : 			Surf.FlatColor.rgba = HWR_Lighting(lightlevel, NORMALFOG, FADEFOG, false, false);

  01b64	6a 00		 push	 0
  01b66	6a 00		 push	 0
  01b68	68 00 00 00 19	 push	 419430400		; 19000000H
  01b6d	6a 00		 push	 0
  01b6f	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _lightlevel$4[ebp]
  01b76	50		 push	 eax
  01b77	e8 00 00 00 00	 call	 _HWR_Lighting
  01b7c	83 c4 14	 add	 esp, 20			; 00000014H
  01b7f	89 45 84	 mov	 DWORD PTR _Surf$[ebp+4], eax
$LN67@HWR_DrawSp:

; 3634 : #else
; 3635 : 
; 3636 : 		sector_t *sector = spr->mobj->subsector->sector;
; 3637 : 
; 3638 : 		if (sector->ffloors)
; 3639 : 		{
; 3640 : 			ffloor_t *caster = sector->lightlist[R_GetPlaneLight(sector, spr->mobj->z, false)].caster;
; 3641 : 			sector = caster ? &sectors[caster->secnum] : sector;
; 3642 : 		}
; 3643 : 		{
; 3644 : 			RGBA_t temp;
; 3645 : 			INT32 alpha;
; 3646 : 
; 3647 : 			temp.rgba = sector->extra_colormap->rgba;
; 3648 : 			alpha = (26 - temp.s.alpha)*spr->sectorlight;
; 3649 : 			Surf.FlatColor.s.red = (UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 3650 : 			Surf.FlatColor.s.blue = (UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 3651 : 			Surf.FlatColor.s.green = (UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 3652 : 			Surf.FlatColor.s.alpha = 0xff;
; 3653 : 		}
; 3654 : #endif
; 3655 : 	}
; 3656 : 
; 3657 : 	/// \todo do the test earlier
; 3658 : 	if (!cv_grmd2.value || (md2_models[spr->mobj->sprite].scale < 0.0f))

  01b82	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  01b89	74 1a		 je	 SHORT $LN69@HWR_DrawSp
  01b8b	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01b8e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01b91	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  01b95	0f 57 c0	 xorps	 xmm0, xmm0
  01b98	0f 2f 82 20 00
	00 00		 comiss	 xmm0, DWORD PTR _md2_models[edx+32]
  01b9f	0f 86 95 00 00
	00		 jbe	 $LN68@HWR_DrawSp
$LN69@HWR_DrawSp:

; 3659 : 	{
; 3660 : 		FBITFIELD blend = 0;

  01ba5	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _blend$1[ebp], 0

; 3661 : 		if (spr->mobj->flags2 & MF2_SHADOW)

  01baf	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01bb2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01bb5	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  01bbb	81 e2 00 00 00
	01		 and	 edx, 16777216		; 01000000H
  01bc1	74 10		 je	 SHORT $LN70@HWR_DrawSp

; 3662 : 		{
; 3663 : 			Surf.FlatColor.s.alpha = 0x40;

  01bc3	c6 45 87 40	 mov	 BYTE PTR _Surf$[ebp+7], 64 ; 00000040H

; 3664 : 			blend = PF_Translucent;

  01bc7	c7 85 cc fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _blend$1[ebp], 2

; 3665 : 		}

  01bd1	eb 45		 jmp	 SHORT $LN73@HWR_DrawSp
$LN70@HWR_DrawSp:

; 3666 : 		else if (spr->mobj->frame & FF_TRANSMASK)

  01bd3	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  01bd6	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  01bd9	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01bdc	81 e2 00 00 0f
	00		 and	 edx, 983040		; 000f0000H
  01be2	74 26		 je	 SHORT $LN72@HWR_DrawSp

; 3667 : 			blend = HWR_TranstableToAlpha((spr->mobj->frame & FF_TRANSMASK)>>FF_TRANSSHIFT, &Surf);

  01be4	8d 45 80	 lea	 eax, DWORD PTR _Surf$[ebp]
  01be7	50		 push	 eax
  01be8	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  01beb	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01bee	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01bf1	25 00 00 0f 00	 and	 eax, 983040		; 000f0000H
  01bf6	c1 e8 10	 shr	 eax, 16			; 00000010H
  01bf9	50		 push	 eax
  01bfa	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  01bff	83 c4 08	 add	 esp, 8
  01c02	89 85 cc fe ff
	ff		 mov	 DWORD PTR _blend$1[ebp], eax
  01c08	eb 0e		 jmp	 SHORT $LN73@HWR_DrawSp
$LN72@HWR_DrawSp:

; 3668 : 		else
; 3669 : 		{
; 3670 : 			// BP: i agree that is little better in environement but it don't
; 3671 : 			//     work properly under glide nor with fogcolor to ffffff :(
; 3672 : 			// Hurdler: PF_Environement would be cool, but we need to fix
; 3673 : 			//          the issue with the fog before
; 3674 : 			Surf.FlatColor.s.alpha = 0xFF;

  01c0a	c6 45 87 ff	 mov	 BYTE PTR _Surf$[ebp+7], 255 ; 000000ffH

; 3675 : 			blend = PF_Translucent|PF_Occlude;

  01c0e	c7 85 cc fe ff
	ff 02 01 00 00	 mov	 DWORD PTR _blend$1[ebp], 258 ; 00000102H
$LN73@HWR_DrawSp:

; 3676 : 		}
; 3677 : 
; 3678 : 		HWD.pfnDrawPolygon(&Surf, wallVerts, 4, blend|PF_Modulated|PF_Clip);

  01c18	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _blend$1[ebp]
  01c1e	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  01c23	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  01c28	50		 push	 eax
  01c29	6a 04		 push	 4
  01c2b	8d 4d 90	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  01c2e	51		 push	 ecx
  01c2f	8d 55 80	 lea	 edx, DWORD PTR _Surf$[ebp]
  01c32	52		 push	 edx
  01c33	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  01c39	90		 npad	 1
$LN68@HWR_DrawSp:

; 3679 : 	}
; 3680 : }

  01c3a	5f		 pop	 edi
  01c3b	5e		 pop	 esi
  01c3c	5b		 pop	 ebx
  01c3d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c40	33 cd		 xor	 ecx, ebp
  01c42	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c47	8b e5		 mov	 esp, ebp
  01c49	5d		 pop	 ebp
  01c4a	c3		 ret	 0
_HWR_DrawSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_OpaqueFloorAtPos
_TEXT	SEGMENT
_thingtop$1 = -24					; size = 4
_delta2$2 = -20						; size = 4
_delta1$3 = -16						; size = 4
_rover$4 = -12						; size = 4
_floorz$ = -8						; size = 4
_sec$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_height$ = 20						; size = 4
_HWR_OpaqueFloorAtPos PROC				; COMDAT

; 3220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3221 : 	const sector_t *sec = R_PointInSubsector(x, y)->sector;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _R_PointInSubsector
  00016	83 c4 08	 add	 esp, 8
  00019	8b 10		 mov	 edx, DWORD PTR [eax]
  0001b	89 55 fc	 mov	 DWORD PTR _sec$[ebp], edx

; 3222 : 	fixed_t floorz = sec->floorheight;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f8	 mov	 DWORD PTR _floorz$[ebp], ecx

; 3223 : 
; 3224 : 	if (sec->ffloors)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00029	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00030	0f 84 f1 00 00
	00		 je	 $LN3@HWR_Opaque

; 3225 : 	{
; 3226 : 		ffloor_t *rover;
; 3227 : 		fixed_t delta1, delta2;
; 3228 : 		const fixed_t thingtop = z + height;

  00036	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  00039	03 45 14	 add	 eax, DWORD PTR _height$[ebp]
  0003c	89 45 e8	 mov	 DWORD PTR _thingtop$1[ebp], eax

; 3229 : 
; 3230 : 		for (rover = sec->ffloors; rover; rover = rover->next)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00042	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00048	89 4d f4	 mov	 DWORD PTR _rover$4[ebp], ecx
  0004b	eb 09		 jmp	 SHORT $LN4@HWR_Opaque
$LN2@HWR_Opaque:
  0004d	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00050	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00053	89 4d f4	 mov	 DWORD PTR _rover$4[ebp], ecx
$LN4@HWR_Opaque:
  00056	83 7d f4 00	 cmp	 DWORD PTR _rover$4[ebp], 0
  0005a	0f 84 c7 00 00
	00		 je	 $LN3@HWR_Opaque

; 3231 : 		{
; 3232 : 			if (!(rover->flags & FF_EXISTS)
; 3233 : 			|| !(rover->flags & FF_RENDERPLANES)
; 3234 : 			|| rover->flags & FF_TRANSLUCENT
; 3235 : 			|| rover->flags & FF_FOG
; 3236 : 			|| rover->flags & FF_INVERTPLANES)

  00060	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00063	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00066	83 e1 01	 and	 ecx, 1
  00069	74 35		 je	 SHORT $LN7@HWR_Opaque
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0006e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00071	83 e1 10	 and	 ecx, 16			; 00000010H
  00074	74 2a		 je	 SHORT $LN7@HWR_Opaque
  00076	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00079	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0007c	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00082	75 1c		 jne	 SHORT $LN7@HWR_Opaque
  00084	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00087	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0008a	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  00090	75 0e		 jne	 SHORT $LN7@HWR_Opaque
  00092	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00095	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00098	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0009e	74 02		 je	 SHORT $LN6@HWR_Opaque
$LN7@HWR_Opaque:

; 3237 : 				continue;

  000a0	eb ab		 jmp	 SHORT $LN2@HWR_Opaque
$LN6@HWR_Opaque:

; 3238 : 
; 3239 : 			delta1 = z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2));

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000a5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000a8	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000ab	8b 02		 mov	 eax, DWORD PTR [edx]
  000ad	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000b0	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000b3	8b 00		 mov	 eax, DWORD PTR [eax]
  000b5	2b 02		 sub	 eax, DWORD PTR [edx]
  000b7	99		 cdq
  000b8	2b c2		 sub	 eax, edx
  000ba	d1 f8		 sar	 eax, 1
  000bc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000be	03 c8		 add	 ecx, eax
  000c0	8b 55 10	 mov	 edx, DWORD PTR _z$[ebp]
  000c3	2b d1		 sub	 edx, ecx
  000c5	89 55 f0	 mov	 DWORD PTR _delta1$3[ebp], edx

; 3240 : 			delta2 = thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2));

  000c8	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000cb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ce	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000d1	8b 02		 mov	 eax, DWORD PTR [edx]
  000d3	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000d6	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	2b 02		 sub	 eax, DWORD PTR [edx]
  000dd	99		 cdq
  000de	2b c2		 sub	 eax, edx
  000e0	d1 f8		 sar	 eax, 1
  000e2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e4	03 c8		 add	 ecx, eax
  000e6	8b 55 e8	 mov	 edx, DWORD PTR _thingtop$1[ebp]
  000e9	2b d1		 sub	 edx, ecx
  000eb	89 55 ec	 mov	 DWORD PTR _delta2$2[ebp], edx

; 3241 : 			if (*rover->topheight > floorz && abs(delta1) < abs(delta2))

  000ee	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f5	3b 55 f8	 cmp	 edx, DWORD PTR _floorz$[ebp]
  000f8	7e 28		 jle	 SHORT $LN8@HWR_Opaque
  000fa	8b 45 f0	 mov	 eax, DWORD PTR _delta1$3[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _abs
  00103	83 c4 04	 add	 esp, 4
  00106	8b f0		 mov	 esi, eax
  00108	8b 4d ec	 mov	 ecx, DWORD PTR _delta2$2[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 _abs
  00111	83 c4 04	 add	 esp, 4
  00114	3b f0		 cmp	 esi, eax
  00116	7d 0a		 jge	 SHORT $LN8@HWR_Opaque

; 3242 : 				floorz = *rover->topheight;

  00118	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0011b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011f	89 55 f8	 mov	 DWORD PTR _floorz$[ebp], edx
$LN8@HWR_Opaque:

; 3243 : 		}

  00122	e9 26 ff ff ff	 jmp	 $LN2@HWR_Opaque
$LN3@HWR_Opaque:

; 3244 : 	}
; 3245 : 
; 3246 : 	return floorz;

  00127	8b 45 f8	 mov	 eax, DWORD PTR _floorz$[ebp]

; 3247 : }

  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
_HWR_OpaqueFloorAtPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_NewVisSprite
_TEXT	SEGMENT
_HWR_NewVisSprite PROC					; COMDAT

; 3210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3211 : 	if (gr_vissprite_p == &gr_vissprites[MAXVISSPRITES])

  00009	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  0000e	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00011	05 00 00 00 00	 add	 eax, OFFSET _gr_vissprites
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR _gr_vissprite_p, eax
  0001c	75 07		 jne	 SHORT $LN2@HWR_NewVis

; 3212 : 		return &gr_overflowsprite;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET _gr_overflowsprite
  00023	eb 15		 jmp	 SHORT $LN1@HWR_NewVis
$LN2@HWR_NewVis:

; 3213 : 
; 3214 : 	gr_vissprite_p++;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vissprite_p
  0002a	83 c0 34	 add	 eax, 52			; 00000034H
  0002d	a3 00 00 00 00	 mov	 DWORD PTR _gr_vissprite_p, eax

; 3215 : 	return gr_vissprite_p-1;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_vissprite_p
  00037	83 e8 34	 sub	 eax, 52			; 00000034H
$LN1@HWR_NewVis:

; 3216 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_HWR_NewVisSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClearSprites
_TEXT	SEGMENT
_HWR_ClearSprites PROC					; COMDAT

; 3199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3200 : 	gr_vissprite_p = gr_vissprites;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gr_vissprite_p, OFFSET _gr_vissprites

; 3201 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_HWR_ClearSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_RenderBSPNode
_TEXT	SEGMENT
_side$ = -8						; size = 4
_bsp$ = -4						; size = 4
_bspnum$ = 8						; size = 4
_HWR_RenderBSPNode PROC					; COMDAT

; 3023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3024 : 	/*//GZDoom code
; 3025 : 	if(bspnum == -1)
; 3026 : 	{
; 3027 : 		HWR_Subsector(subsectors);
; 3028 : 		return;
; 3029 : 	}
; 3030 : 	while(!((size_t)bspnum&(~NF_SUBSECTOR))) // Keep going until found a subsector
; 3031 : 	{
; 3032 : 		node_t *bsp = &nodes[bspnum];
; 3033 : 
; 3034 : 		// Decide which side the view point is on
; 3035 : 		INT32 side = R_PointOnSide(dup_viewx, dup_viewy, bsp);
; 3036 : 
; 3037 : 		// Recursively divide front space (toward the viewer)
; 3038 : 		HWR_RenderBSPNode(bsp->children[side]);
; 3039 : 
; 3040 : 		// Possibly divide back space (away from viewer)
; 3041 : 		side ^= 1;
; 3042 : 
; 3043 : 		if (!HWR_CheckBBox(bsp->bbox[side]))
; 3044 : 			return;
; 3045 : 
; 3046 : 		bspnum = bsp->children[side];
; 3047 : 	}
; 3048 : 
; 3049 : 	HWR_Subsector(bspnum-1);
; 3050 : */
; 3051 : 	node_t *bsp = &nodes[bspnum];

  00009	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  0000d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  00013	89 45 fc	 mov	 DWORD PTR _bsp$[ebp], eax

; 3052 : 
; 3053 : 	// Decide which side the view point is on
; 3054 : 	INT32 side;
; 3055 : 
; 3056 : 	// Found a subsector?
; 3057 : 	if (bspnum & NF_SUBSECTOR)

  00016	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  00019	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0001e	74 28		 je	 SHORT $LN2@HWR_Render

; 3058 : 	{
; 3059 : 		if (bspnum == -1)

  00020	83 7d 08 ff	 cmp	 DWORD PTR _bspnum$[ebp], -1
  00024	75 0c		 jne	 SHORT $LN3@HWR_Render

; 3060 : 		{
; 3061 : 			//*(gr_drawsubsector_p++) = 0;
; 3062 : 			HWR_Subsector(0);

  00026	6a 00		 push	 0
  00028	e8 00 00 00 00	 call	 _HWR_Subsector
  0002d	83 c4 04	 add	 esp, 4

; 3063 : 		}

  00030	eb 11		 jmp	 SHORT $LN4@HWR_Render
$LN3@HWR_Render:

; 3064 : 		else
; 3065 : 		{
; 3066 : 			//*(gr_drawsubsector_p++) = bspnum&(~NF_SUBSECTOR);
; 3067 : 			HWR_Subsector(bspnum&(~NF_SUBSECTOR));

  00032	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  00035	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _HWR_Subsector
  00040	83 c4 04	 add	 esp, 4
$LN4@HWR_Render:

; 3068 : 		}
; 3069 : 		return;

  00043	e9 8e 00 00 00	 jmp	 $LN5@HWR_Render
$LN2@HWR_Render:

; 3070 : 	}
; 3071 : 
; 3072 : 	// Decide which side the view point is on.
; 3073 : 	side = R_PointOnSide(dup_viewx, dup_viewy, bsp);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _bsp$[ebp]
  0004b	50		 push	 eax
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dup_viewy
  00052	51		 push	 ecx
  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewx
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _R_PointOnSide
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	89 45 f8	 mov	 DWORD PTR _side$[ebp], eax

; 3074 : 
; 3075 : 	// BP: big hack for a test in lighning ref : 1249753487AB
; 3076 : 	hwbbox = bsp->bbox[side];

  00065	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  00068	c1 e0 04	 shl	 eax, 4
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  0006e	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  00072	89 15 00 00 00
	00		 mov	 DWORD PTR _hwbbox, edx

; 3077 : 
; 3078 : 	// Recursively divide front space.
; 3079 : 	HWR_RenderBSPNode(bsp->children[side]);

  00078	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  0007e	0f b7 54 41 30	 movzx	 edx, WORD PTR [ecx+eax*2+48]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _HWR_RenderBSPNode
  00089	83 c4 04	 add	 esp, 4

; 3080 : 
; 3081 : 	// Possibly divide back space.
; 3082 : 	if (HWR_CheckBBox(bsp->bbox[side^1]))

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  0008f	83 f0 01	 xor	 eax, 1
  00092	c1 e0 04	 shl	 eax, 4
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  00098	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _HWR_CheckBBox
  000a2	83 c4 04	 add	 esp, 4
  000a5	85 c0		 test	 eax, eax
  000a7	74 2d		 je	 SHORT $LN5@HWR_Render

; 3083 : 	{
; 3084 : 		// BP: big hack for a test in lighning ref : 1249753487AB
; 3085 : 		hwbbox = bsp->bbox[side^1];

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  000ac	83 f0 01	 xor	 eax, 1
  000af	c1 e0 04	 shl	 eax, 4
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  000b5	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  000b9	89 15 00 00 00
	00		 mov	 DWORD PTR _hwbbox, edx

; 3086 : 		HWR_RenderBSPNode(bsp->children[side^1]);

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  000c2	83 f0 01	 xor	 eax, 1
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  000c8	0f b7 54 41 30	 movzx	 edx, WORD PTR [ecx+eax*2+48]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 _HWR_RenderBSPNode
  000d3	83 c4 04	 add	 esp, 4
$LN5@HWR_Render:

; 3087 : 	}
; 3088 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_HWR_RenderBSPNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_Subsector
_TEXT	SEGMENT
tv285 = -372						; size = 4
tv355 = -372						; size = 4
tv376 = -372						; size = 4
tv407 = -372						; size = 4
tv474 = -372						; size = 4
tv544 = -372						; size = 4
tv565 = -372						; size = 4
tv596 = -372						; size = 4
tv647 = -372						; size = 4
_po$1 = -304						; size = 4
_alpha$2 = -298						; size = 1
_alpha$3 = -297						; size = 1
_rover$4 = -296						; size = 4
_ceilingcolormap$ = -292				; size = 4
_floorcolormap$ = -288					; size = 4
_wh$ = -284						; size = 4
_light$ = -280						; size = 4
_locCeilingHeight$ = -276				; size = 4
_locFloorHeight$ = -272					; size = 4
_ceilinglightlevel$ = -268				; size = 4
_floorlightlevel$ = -264				; size = 4
_tempsec$ = -260					; size = 248
_sub$ = -12						; size = 4
_line$ = -8						; size = 4
_count$ = -4						; size = 2
_num$ = 8						; size = 4
_HWR_Subsector PROC					; COMDAT

; 2641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2642 : 	INT16 count;
; 2643 : 	seg_t *line;
; 2644 : 	subsector_t *sub;
; 2645 : 	sector_t tempsec; //SoM: 4/7/2000
; 2646 : 	INT32 floorlightlevel;
; 2647 : 	INT32 ceilinglightlevel;
; 2648 : 	INT32 locFloorHeight, locCeilingHeight;
; 2649 : 	INT32 light = 0;

  0000c	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _light$[ebp], 0

; 2650 : 	fixed_t wh;
; 2651 : 	extracolormap_t *floorcolormap;
; 2652 : 	extracolormap_t *ceilingcolormap;
; 2653 : 
; 2654 : #ifdef PARANOIA //no risk while developing, enough debugging nights!
; 2655 : 	if (num >= addsubsector)
; 2656 : 		I_Error("HWR_Subsector: ss %"PRIdS" with numss = %"PRIdS", addss = %"PRIdS"\n",
; 2657 : 			num, numsubsectors, addsubsector);
; 2658 : 
; 2659 : 	/*if (num >= numsubsectors)
; 2660 : 		I_Error("HWR_Subsector: ss %i with numss = %i",
; 2661 : 		        num,
; 2662 : 		        numsubsectors);*/
; 2663 : #endif
; 2664 : 
; 2665 : 	if (num < numsubsectors)

  00016	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00019	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsubsectors
  0001f	73 45		 jae	 SHORT $LN9@HWR_Subsec

; 2666 : 	{
; 2667 : 		sscount++;

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _sscount
  00026	83 c0 01	 add	 eax, 1
  00029	a3 00 00 00 00	 mov	 DWORD PTR _sscount, eax

; 2668 : 		// subsector
; 2669 : 		sub = &subsectors[num];

  0002e	6b 45 08 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  00032	03 05 00 00 00
	00		 add	 eax, DWORD PTR _subsectors
  00038	89 45 f4	 mov	 DWORD PTR _sub$[ebp], eax

; 2670 : 		// sector
; 2671 : 		gr_frontsector = sub->sector;

  0003b	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	89 0d 00 00 00
	00		 mov	 DWORD PTR _gr_frontsector, ecx

; 2672 : 		// how many linedefs
; 2673 : 		count = sub->numlines;

  00046	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00049	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0004d	66 89 4d fc	 mov	 WORD PTR _count$[ebp], cx

; 2674 : 		// first line seg
; 2675 : 		line = &segs[sub->firstline];

  00051	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00054	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00058	6b d1 3c	 imul	 edx, ecx, 60
  0005b	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  00061	89 55 f8	 mov	 DWORD PTR _line$[ebp], edx

; 2676 : 	}

  00064	eb 29		 jmp	 SHORT $LN10@HWR_Subsec
$LN9@HWR_Subsec:

; 2677 : 	else
; 2678 : 	{
; 2679 : 		// there are no segs but only planes
; 2680 : 		sub = &subsectors[0];

  00066	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0006b	6b c8 00	 imul	 ecx, eax, 0
  0006e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _subsectors
  00074	89 4d f4	 mov	 DWORD PTR _sub$[ebp], ecx

; 2681 : 		gr_frontsector = sub->sector;

  00077	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	89 0d 00 00 00
	00		 mov	 DWORD PTR _gr_frontsector, ecx

; 2682 : 		count = 0;

  00082	33 c0		 xor	 eax, eax
  00084	66 89 45 fc	 mov	 WORD PTR _count$[ebp], ax

; 2683 : 		line = NULL;

  00088	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _line$[ebp], 0
$LN10@HWR_Subsec:

; 2684 : 	}
; 2685 : 
; 2686 : 	//SoM: 4/7/2000: Test to make Boom water work in Hardware mode.
; 2687 : 	gr_frontsector = R_FakeFlat(gr_frontsector, &tempsec, &floorlightlevel,

  0008f	6a 00		 push	 0
  00091	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _ceilinglightlevel$[ebp]
  00097	50		 push	 eax
  00098	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _floorlightlevel$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _tempsec$[ebp]
  000a5	52		 push	 edx
  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _R_FakeFlat
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
  000b4	a3 00 00 00 00	 mov	 DWORD PTR _gr_frontsector, eax

; 2688 : 								&ceilinglightlevel, false);
; 2689 : 	//FIXME: Use floorlightlevel and ceilinglightlevel insted of lightlevel.
; 2690 : 
; 2691 : 	floorcolormap = ceilingcolormap = gr_frontsector->extra_colormap;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000be	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  000c4	89 8d dc fe ff
	ff		 mov	 DWORD PTR _ceilingcolormap$[ebp], ecx
  000ca	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _ceilingcolormap$[ebp]
  000d0	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _floorcolormap$[ebp], edx

; 2692 : 
; 2693 : 	// ------------------------------------------------------------------------
; 2694 : 	// sector lighting, DISABLED because it's done in HWR_StoreWallRange
; 2695 : 	// ------------------------------------------------------------------------
; 2696 : 	/// \todo store a RGBA instead of just intensity, allow coloured sector lighting
; 2697 : 	//light = (FUBYTE)(sub->sector->lightlevel & 0xFF) / 255.0f;
; 2698 : 	//gr_cursectorlight.red   = light;
; 2699 : 	//gr_cursectorlight.green = light;
; 2700 : 	//gr_cursectorlight.blue  = light;
; 2701 : 	//gr_cursectorlight.alpha = light;
; 2702 : 
; 2703 : // ----- for special tricks with HW renderer -----
; 2704 : 	if (gr_frontsector->pseudoSector)

  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000db	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  000e2	74 27		 je	 SHORT $LN11@HWR_Subsec

; 2705 : 	{
; 2706 : 		locFloorHeight = gr_frontsector->virtualFloorheight;

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000e9	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR [eax+188]
  000ef	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _locFloorHeight$[ebp], ecx

; 2707 : 		locCeilingHeight = gr_frontsector->virtualCeilingheight;

  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000fa	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00100	89 8d ec fe ff
	ff		 mov	 DWORD PTR _locCeilingHeight$[ebp], ecx

; 2708 : 	}

  00106	e9 99 00 00 00	 jmp	 $LN18@HWR_Subsec
$LN11@HWR_Subsec:

; 2709 : 	else if (gr_frontsector->virtualFloor)

  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00110	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  00117	74 42		 je	 SHORT $LN13@HWR_Subsec

; 2710 : 	{
; 2711 : 		locFloorHeight = gr_frontsector->virtualFloorheight;

  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0011e	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR [eax+188]
  00124	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _locFloorHeight$[ebp], ecx

; 2712 : 		if (gr_frontsector->virtualCeiling)

  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0012f	83 b8 c0 00 00
	00 00		 cmp	 DWORD PTR [eax+192], 0
  00136	74 13		 je	 SHORT $LN15@HWR_Subsec

; 2713 : 			locCeilingHeight = gr_frontsector->virtualCeilingheight;

  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0013d	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00143	89 8d ec fe ff
	ff		 mov	 DWORD PTR _locCeilingHeight$[ebp], ecx
  00149	eb 0e		 jmp	 SHORT $LN16@HWR_Subsec
$LN15@HWR_Subsec:

; 2714 : 		else
; 2715 : 			locCeilingHeight = gr_frontsector->ceilingheight;

  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00150	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00153	89 8d ec fe ff
	ff		 mov	 DWORD PTR _locCeilingHeight$[ebp], ecx
$LN16@HWR_Subsec:

; 2716 : 	}

  00159	eb 49		 jmp	 SHORT $LN18@HWR_Subsec
$LN13@HWR_Subsec:

; 2717 : 	else if (gr_frontsector->virtualCeiling)

  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00160	83 b8 c0 00 00
	00 00		 cmp	 DWORD PTR [eax+192], 0
  00167	74 20		 je	 SHORT $LN17@HWR_Subsec

; 2718 : 	{
; 2719 : 		locCeilingHeight = gr_frontsector->virtualCeilingheight;

  00169	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0016e	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00174	89 8d ec fe ff
	ff		 mov	 DWORD PTR _locCeilingHeight$[ebp], ecx

; 2720 : 		locFloorHeight   = gr_frontsector->floorheight;

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _locFloorHeight$[ebp], ecx

; 2721 : 	}

  00187	eb 1b		 jmp	 SHORT $LN18@HWR_Subsec
$LN17@HWR_Subsec:

; 2722 : 	else
; 2723 : 	{
; 2724 : 		locFloorHeight   = gr_frontsector->floorheight;

  00189	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0018e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00190	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _locFloorHeight$[ebp], ecx

; 2725 : 		locCeilingHeight = gr_frontsector->ceilingheight;

  00196	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0019b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019e	89 8d ec fe ff
	ff		 mov	 DWORD PTR _locCeilingHeight$[ebp], ecx
$LN18@HWR_Subsec:

; 2726 : 	}
; 2727 : // ----- end special tricks -----
; 2728 : 
; 2729 : 	if (gr_frontsector->ffloors)

  001a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  001a9	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  001b0	0f 84 53 01 00
	00		 je	 $LN19@HWR_Subsec

; 2730 : 	{
; 2731 : 		if (gr_frontsector->moved)

  001b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  001bb	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [eax+172], 0
  001c2	74 79		 je	 SHORT $LN20@HWR_Subsec

; 2732 : 		{
; 2733 : 			gr_frontsector->numlights = sub->sector->numlights = 0;

  001c4	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  001c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c9	c7 81 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+168], 0
  001d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  001d9	c7 82 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+168], 0

; 2734 : 			R_Prep3DFloors(gr_frontsector);

  001e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 _R_Prep3DFloors
  001ee	83 c4 04	 add	 esp, 4

; 2735 : 			sub->sector->lightlist = gr_frontsector->lightlist;

  001f1	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  001f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  001fc	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00202	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax

; 2736 : 			sub->sector->numlights = gr_frontsector->numlights;

  00208	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  0020b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00213	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  00219	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 2737 : 			sub->sector->moved = gr_frontsector->moved = false;

  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00224	c7 80 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+172], 0
  0022e	8b 4d f4	 mov	 ecx, DWORD PTR _sub$[ebp]
  00231	8b 11		 mov	 edx, DWORD PTR [ecx]
  00233	c7 82 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+172], 0
$LN20@HWR_Subsec:

; 2738 : 		}
; 2739 : 
; 2740 : 		light = R_GetPlaneLight(gr_frontsector, locFloorHeight, false);

  0023d	6a 00		 push	 0
  0023f	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _locFloorHeight$[ebp]
  00245	50		 push	 eax
  00246	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  0024c	51		 push	 ecx
  0024d	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00252	83 c4 0c	 add	 esp, 12			; 0000000cH
  00255	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2741 : 		if (gr_frontsector->floorlightsec == -1)

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00260	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  00264	75 20		 jne	 SHORT $LN21@HWR_Subsec

; 2742 : 			floorlightlevel = *gr_frontsector->lightlist[light].lightlevel;

  00266	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00273	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00279	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  0027d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00280	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _floorlightlevel$[ebp], ecx
$LN21@HWR_Subsec:

; 2743 : 		floorcolormap = gr_frontsector->lightlist[light].extra_colormap;

  00286	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  0028d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00293	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00299	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  0029d	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _floorcolormap$[ebp], eax

; 2744 : 
; 2745 : 		light = R_GetPlaneLight(gr_frontsector, locCeilingHeight, false);

  002a3	6a 00		 push	 0
  002a5	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _locCeilingHeight$[ebp]
  002ab	50		 push	 eax
  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 _R_GetPlaneLight
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bb	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2746 : 		if (gr_frontsector->ceilinglightsec == -1)

  002c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  002c6	83 78 70 ff	 cmp	 DWORD PTR [eax+112], -1
  002ca	75 20		 jne	 SHORT $LN22@HWR_Subsec

; 2747 : 			ceilinglightlevel = *gr_frontsector->lightlist[light].lightlevel;

  002cc	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  002d9	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  002df	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  002e3	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002e6	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _ceilinglightlevel$[ebp], ecx
$LN22@HWR_Subsec:

; 2748 : 		ceilingcolormap = gr_frontsector->lightlist[light].extra_colormap;

  002ec	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  002f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  002f9	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  002ff	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00303	89 85 dc fe ff
	ff		 mov	 DWORD PTR _ceilingcolormap$[ebp], eax
$LN19@HWR_Subsec:

; 2749 : 	}
; 2750 : 
; 2751 : 	sub->sector->extra_colormap = gr_frontsector->extra_colormap;

  00309	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00314	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0031a	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 2752 : 
; 2753 : 	// render floor ?
; 2754 : #ifdef DOPLANES
; 2755 : 	// yeah, easy backface cull! :)
; 2756 : 	if (locFloorHeight < dup_viewz)

  00320	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _locFloorHeight$[ebp]
  00326	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dup_viewz
  0032c	0f 8d 95 00 00
	00		 jge	 $LN24@HWR_Subsec

; 2757 : 	{
; 2758 : 		if (gr_frontsector->floorpic != skyflatnum)

  00332	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00337	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0033a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  00340	0f 84 81 00 00
	00		 je	 $LN24@HWR_Subsec

; 2759 : 		{
; 2760 : 			if (sub->validcount != validcount)

  00346	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00349	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0034c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00352	74 73		 je	 SHORT $LN26@HWR_Subsec

; 2761 : 			{
; 2762 : 				HWR_GetFlat(levelflats[gr_frontsector->floorpic].lumpnum);

  00354	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00359	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0035c	c1 e1 05	 shl	 ecx, 5
  0035f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _levelflats
  00365	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 _HWR_GetFlat
  0036f	83 c4 04	 add	 esp, 4

; 2763 : 				HWR_RenderPlane(gr_frontsector, &extrasubsectors[num], locFloorHeight, PF_Occlude, floorlightlevel, levelflats[gr_frontsector->floorpic].lumpnum, NULL, 255, false, floorcolormap);

  00372	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _floorcolormap$[ebp]
  00378	50		 push	 eax
  00379	6a 00		 push	 0
  0037b	68 ff 00 00 00	 push	 255			; 000000ffH
  00380	6a 00		 push	 0
  00382	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00388	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0038b	c1 e2 05	 shl	 edx, 5
  0038e	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelflats
  00393	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  00397	51		 push	 ecx
  00398	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _floorlightlevel$[ebp]
  0039e	52		 push	 edx
  0039f	68 00 01 00 00	 push	 256			; 00000100H
  003a4	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _locFloorHeight$[ebp]
  003aa	50		 push	 eax
  003ab	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  003ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _extrasubsectors
  003b4	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  003b7	50		 push	 eax
  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  003be	51		 push	 ecx
  003bf	e8 00 00 00 00	 call	 _HWR_RenderPlane
  003c4	83 c4 28	 add	 esp, 40			; 00000028H
$LN26@HWR_Subsec:
$LN24@HWR_Subsec:

; 2764 : 			}
; 2765 : 		}
; 2766 : 		else
; 2767 : 		{
; 2768 : #ifdef POLYSKY
; 2769 : 			HWR_RenderSkyPlane(&extrasubsectors[num], locFloorHeight);
; 2770 : #endif
; 2771 : 		}
; 2772 : 	}
; 2773 : 
; 2774 : 	if (locCeilingHeight > dup_viewz)

  003c7	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _locCeilingHeight$[ebp]
  003cd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dup_viewz
  003d3	0f 8e 8c 00 00
	00		 jle	 $LN28@HWR_Subsec

; 2775 : 	{
; 2776 : 		if (gr_frontsector->ceilingpic != skyflatnum)

  003d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  003de	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003e1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  003e7	74 7c		 je	 SHORT $LN28@HWR_Subsec

; 2777 : 		{
; 2778 : 			if (sub->validcount != validcount)

  003e9	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  003ec	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003ef	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  003f5	74 6e		 je	 SHORT $LN30@HWR_Subsec

; 2779 : 			{
; 2780 : 				HWR_GetFlat(levelflats[gr_frontsector->ceilingpic].lumpnum);

  003f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  003fc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003ff	c1 e1 05	 shl	 ecx, 5
  00402	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _levelflats
  00408	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0040c	50		 push	 eax
  0040d	e8 00 00 00 00	 call	 _HWR_GetFlat
  00412	83 c4 04	 add	 esp, 4

; 2781 : 				HWR_RenderPlane(NULL, &extrasubsectors[num], locCeilingHeight, PF_Occlude, ceilinglightlevel, levelflats[gr_frontsector->ceilingpic].lumpnum,NULL, 255, false, ceilingcolormap);

  00415	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _ceilingcolormap$[ebp]
  0041b	50		 push	 eax
  0041c	6a 00		 push	 0
  0041e	68 ff 00 00 00	 push	 255			; 000000ffH
  00423	6a 00		 push	 0
  00425	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  0042b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0042e	c1 e2 05	 shl	 edx, 5
  00431	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelflats
  00436	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  0043a	51		 push	 ecx
  0043b	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _ceilinglightlevel$[ebp]
  00441	52		 push	 edx
  00442	68 00 01 00 00	 push	 256			; 00000100H
  00447	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _locCeilingHeight$[ebp]
  0044d	50		 push	 eax
  0044e	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  00451	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _extrasubsectors
  00457	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0045a	50		 push	 eax
  0045b	6a 00		 push	 0
  0045d	e8 00 00 00 00	 call	 _HWR_RenderPlane
  00462	83 c4 28	 add	 esp, 40			; 00000028H
$LN30@HWR_Subsec:
$LN28@HWR_Subsec:

; 2782 : 			}
; 2783 : 		}
; 2784 : 		else
; 2785 : 		{
; 2786 : #ifdef POLYSKY
; 2787 : 			HWR_RenderSkyPlane(&extrasubsectors[num], locCeilingHeight);
; 2788 : #endif
; 2789 : 		}
; 2790 : 	}
; 2791 : 
; 2792 : #ifndef POLYSKY
; 2793 : 	// Moved here because before, when above the ceiling and the floor does not have the sky flat, it doesn't draw the sky
; 2794 : 	if (gr_frontsector->ceilingpic == skyflatnum || gr_frontsector->floorpic == skyflatnum)

  00465	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0046a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0046d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  00473	74 10		 je	 SHORT $LN32@HWR_Subsec
  00475	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0047a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0047d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  00483	75 0a		 jne	 SHORT $LN31@HWR_Subsec
$LN32@HWR_Subsec:

; 2795 : 	{
; 2796 : 		drawsky = true;

  00485	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _drawsky, 1
$LN31@HWR_Subsec:

; 2797 : 	}
; 2798 : #endif
; 2799 : 
; 2800 : #ifdef R_FAKEFLOORS
; 2801 : 	if (gr_frontsector->ffloors)

  0048f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00494	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0049b	0f 84 a3 08 00
	00		 je	 $LN3@HWR_Subsec

; 2802 : 	{
; 2803 : 		/// \todo fix light, xoffs, yoffs, extracolormap ?
; 2804 : 		ffloor_t * rover;
; 2805 : 
; 2806 : 		R_Prep3DFloors(gr_frontsector);

  004a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  004a6	50		 push	 eax
  004a7	e8 00 00 00 00	 call	 _R_Prep3DFloors
  004ac	83 c4 04	 add	 esp, 4

; 2807 : 		for (rover = gr_frontsector->ffloors;

  004af	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  004b4	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  004ba	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _rover$4[ebp], ecx
  004c0	eb 0f		 jmp	 SHORT $LN4@HWR_Subsec
$LN2@HWR_Subsec:

; 2808 : 			rover; rover = rover->next)

  004c2	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  004c8	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  004cb	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _rover$4[ebp], ecx
$LN4@HWR_Subsec:
  004d1	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _rover$4[ebp], 0
  004d8	0f 84 66 08 00
	00		 je	 $LN3@HWR_Subsec

; 2809 : 		{
; 2810 : 
; 2811 : 			if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_RENDERPLANES))

  004de	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  004e4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  004e7	83 e1 01	 and	 ecx, 1
  004ea	74 0e		 je	 SHORT $LN35@HWR_Subsec
  004ec	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  004f2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  004f5	83 e1 10	 and	 ecx, 16			; 00000010H
  004f8	75 02		 jne	 SHORT $LN34@HWR_Subsec
$LN35@HWR_Subsec:

; 2812 : 				continue;

  004fa	eb c6		 jmp	 SHORT $LN2@HWR_Subsec
$LN34@HWR_Subsec:

; 2813 : 			if (sub->validcount == validcount)

  004fc	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  004ff	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00502	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00508	75 02		 jne	 SHORT $LN36@HWR_Subsec

; 2814 : 				continue;

  0050a	eb b6		 jmp	 SHORT $LN2@HWR_Subsec
$LN36@HWR_Subsec:

; 2815 : 
; 2816 : 			if (*rover->bottomheight <= gr_frontsector->ceilingheight &&
; 2817 : 			    *rover->bottomheight >= gr_frontsector->floorheight &&

  0050c	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00512	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00515	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  0051b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0051d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00520	0f 8f 06 04 00
	00		 jg	 $LN46@HWR_Subsec
  00526	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0052c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0052f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00535	8b 01		 mov	 eax, DWORD PTR [ecx]
  00537	3b 02		 cmp	 eax, DWORD PTR [edx]
  00539	0f 8c ed 03 00
	00		 jl	 $LN46@HWR_Subsec
  0053f	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00545	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00548	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  0054e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00550	7d 11		 jge	 SHORT $LN39@HWR_Subsec
  00552	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00558	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0055b	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00561	74 3d		 je	 SHORT $LN40@HWR_Subsec
$LN39@HWR_Subsec:
  00563	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00569	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0056c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  00572	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00574	0f 8e b2 03 00
	00		 jle	 $LN46@HWR_Subsec
  0057a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00580	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00583	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00589	75 15		 jne	 SHORT $LN40@HWR_Subsec
  0058b	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00591	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00594	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0059a	0f 84 8c 03 00
	00		 je	 $LN46@HWR_Subsec
$LN40@HWR_Subsec:

; 2818 : 			    ((dup_viewz < *rover->bottomheight && !(rover->flags & FF_INVERTPLANES)) ||
; 2819 : 			     (dup_viewz > *rover->bottomheight && (rover->flags & FF_BOTHPLANES || rover->flags & FF_INVERTPLANES))))
; 2820 : 			{
; 2821 : 				if (rover->flags & FF_FOG)

  005a0	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  005a6	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  005a9	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  005af	0f 84 5e 01 00
	00		 je	 $LN41@HWR_Subsec

; 2822 : 				{
; 2823 : 					UINT8 alpha;
; 2824 : 
; 2825 : 					light = R_GetPlaneLight(gr_frontsector, *rover->bottomheight, dup_viewz < *rover->bottomheight ? true : false);

  005b5	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  005bb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  005c4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  005c6	7d 0c		 jge	 SHORT $LN62@HWR_Subsec
  005c8	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv285[ebp], 1
  005d2	eb 0a		 jmp	 SHORT $LN63@HWR_Subsec
$LN62@HWR_Subsec:
  005d4	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv285[ebp], 0
$LN63@HWR_Subsec:
  005de	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  005e4	50		 push	 eax
  005e5	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  005eb	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005ee	8b 02		 mov	 eax, DWORD PTR [edx]
  005f0	50		 push	 eax
  005f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  005f7	51		 push	 ecx
  005f8	e8 00 00 00 00	 call	 _R_GetPlaneLight
  005fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00600	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2826 : 
; 2827 : 					if (rover->master->frontsector->extra_colormap)

  00606	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0060c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0060f	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00612	83 ba b0 00 00
	00 00		 cmp	 DWORD PTR [edx+176], 0
  00619	74 57		 je	 SHORT $LN43@HWR_Subsec

; 2828 : 						alpha = HWR_FogBlockAlpha(*gr_frontsector->lightlist[light].lightlevel, rover->master->frontsector->extra_colormap->rgba, rover->master->frontsector->extra_colormap->fadergba);

  0061b	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00621	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00624	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00627	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0062d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00630	51		 push	 ecx
  00631	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00637	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0063a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0063d	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00643	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00646	50		 push	 eax
  00647	6b 8d e8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _light$[ebp], 20
  0064e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00654	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0065a	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  0065e	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00661	52		 push	 edx
  00662	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  00667	83 c4 0c	 add	 esp, 12			; 0000000cH
  0066a	88 85 d7 fe ff
	ff		 mov	 BYTE PTR _alpha$3[ebp], al
  00670	eb 30		 jmp	 SHORT $LN44@HWR_Subsec
$LN43@HWR_Subsec:

; 2829 : 					else
; 2830 : 						alpha = HWR_FogBlockAlpha(*gr_frontsector->lightlist[light].lightlevel, NORMALFOG, FADEFOG);

  00672	68 00 00 00 19	 push	 419430400		; 19000000H
  00677	6a 00		 push	 0
  00679	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  00680	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00686	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0068c	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00690	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00693	51		 push	 ecx
  00694	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  00699	83 c4 0c	 add	 esp, 12			; 0000000cH
  0069c	88 85 d7 fe ff
	ff		 mov	 BYTE PTR _alpha$3[ebp], al
$LN44@HWR_Subsec:

; 2831 : 
; 2832 : 					HWR_AddTransparentFloor(0,

  006a2	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  006a8	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  006ab	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  006ae	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  006b4	50		 push	 eax
  006b5	6a 01		 push	 1
  006b7	68 02 20 00 00	 push	 8194			; 00002002H
  006bc	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  006c2	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  006c5	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  006c8	50		 push	 eax
  006c9	0f b6 8d d7 fe
	ff ff		 movzx	 ecx, BYTE PTR _alpha$3[ebp]
  006d0	51		 push	 ecx
  006d1	6b 95 e8 fe ff
	ff 14		 imul	 edx, DWORD PTR _light$[ebp], 20
  006d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  006dd	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  006e3	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  006e7	0f bf 02	 movsx	 eax, WORD PTR [edx]
  006ea	50		 push	 eax
  006eb	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  006f1	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006f4	8b 02		 mov	 eax, DWORD PTR [edx]
  006f6	50		 push	 eax
  006f7	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  006fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _extrasubsectors
  00700	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00703	50		 push	 eax
  00704	6a 00		 push	 0
  00706	e8 00 00 00 00	 call	 _HWR_AddTransparentFloor
  0070b	83 c4 24	 add	 esp, 36			; 00000024H

; 2833 : 					                       &extrasubsectors[num],
; 2834 : 					                       *rover->bottomheight,
; 2835 : 					                       *gr_frontsector->lightlist[light].lightlevel,
; 2836 : 					                       alpha, rover->master->frontsector, PF_Translucent|PF_NoTexture,
; 2837 : 										   true, rover->master->frontsector->extra_colormap);
; 2838 : 				}

  0070e	e9 19 02 00 00	 jmp	 $LN46@HWR_Subsec
$LN41@HWR_Subsec:

; 2839 : 				else if (rover->flags & FF_TRANSLUCENT) // SoM: Flags are more efficient

  00713	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00719	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0071c	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00722	0f 84 0c 01 00
	00		 je	 $LN45@HWR_Subsec

; 2840 : 				{
; 2841 : 					light = R_GetPlaneLight(gr_frontsector, *rover->bottomheight, dup_viewz < *rover->bottomheight ? true : false);

  00728	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0072e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00731	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  00737	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00739	7d 0c		 jge	 SHORT $LN64@HWR_Subsec
  0073b	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv355[ebp], 1
  00745	eb 0a		 jmp	 SHORT $LN65@HWR_Subsec
$LN64@HWR_Subsec:
  00747	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv355[ebp], 0
$LN65@HWR_Subsec:
  00751	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv355[ebp]
  00757	50		 push	 eax
  00758	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  0075e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00761	8b 02		 mov	 eax, DWORD PTR [edx]
  00763	50		 push	 eax
  00764	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  0076a	51		 push	 ecx
  0076b	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00770	83 c4 0c	 add	 esp, 12			; 0000000cH
  00773	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2842 : #ifndef SORTING
; 2843 : 					HWR_Add3DWater(levelflats[*rover->bottompic].lumpnum,
; 2844 : 					               &extrasubsectors[num],
; 2845 : 					               *rover->bottomheight,
; 2846 : 					               *gr_frontsector->lightlist[light].lightlevel,
; 2847 : 					               rover->alpha, rover->master->frontsector);
; 2848 : #else
; 2849 : 					HWR_AddTransparentFloor(levelflats[*rover->bottompic].lumpnum,

  00779	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0077f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00782	83 e9 01	 sub	 ecx, 1
  00785	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0078b	7e 0c		 jle	 SHORT $LN66@HWR_Subsec
  0078d	c7 85 8c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv376[ebp], 255 ; 000000ffH
  00797	eb 12		 jmp	 SHORT $LN67@HWR_Subsec
$LN66@HWR_Subsec:
  00799	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  0079f	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  007a2	83 e8 01	 sub	 eax, 1
  007a5	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv376[ebp], eax
$LN67@HWR_Subsec:
  007ab	6b 8d e8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _light$[ebp], 20
  007b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  007b8	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  007be	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  007c2	51		 push	 ecx
  007c3	6a 00		 push	 0
  007c5	6a 02		 push	 2
  007c7	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  007cd	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  007d0	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  007d3	51		 push	 ecx
  007d4	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR tv376[ebp]
  007da	52		 push	 edx
  007db	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  007e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  007e8	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  007ee	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  007f2	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  007f5	51		 push	 ecx
  007f6	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  007fc	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  007ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00801	51		 push	 ecx
  00802	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  00805	a1 00 00 00 00	 mov	 eax, DWORD PTR _extrasubsectors
  0080a	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0080d	51		 push	 ecx
  0080e	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00814	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00817	8b 08		 mov	 ecx, DWORD PTR [eax]
  00819	c1 e1 05	 shl	 ecx, 5
  0081c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _levelflats
  00822	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00826	50		 push	 eax
  00827	e8 00 00 00 00	 call	 _HWR_AddTransparentFloor
  0082c	83 c4 24	 add	 esp, 36			; 00000024H

; 2850 : 					                       &extrasubsectors[num],
; 2851 : 					                       *rover->bottomheight,
; 2852 : 					                       *gr_frontsector->lightlist[light].lightlevel,
; 2853 : 					                       rover->alpha-1 > 255 ? 255 : rover->alpha-1, rover->master->frontsector, PF_Translucent,
; 2854 : 										   false, gr_frontsector->lightlist[light].extra_colormap);
; 2855 : #endif
; 2856 : 				}

  0082f	e9 f8 00 00 00	 jmp	 $LN46@HWR_Subsec
$LN45@HWR_Subsec:

; 2857 : 				else
; 2858 : 				{
; 2859 : 					HWR_GetFlat(levelflats[*rover->bottompic].lumpnum);

  00834	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0083a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0083d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0083f	c1 e2 05	 shl	 edx, 5
  00842	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelflats
  00847	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  0084b	51		 push	 ecx
  0084c	e8 00 00 00 00	 call	 _HWR_GetFlat
  00851	83 c4 04	 add	 esp, 4

; 2860 : 					light = R_GetPlaneLight(gr_frontsector, *rover->bottomheight, dup_viewz < *rover->bottomheight ? true : false);

  00854	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0085a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0085d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  00863	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00865	7d 0c		 jge	 SHORT $LN68@HWR_Subsec
  00867	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv407[ebp], 1
  00871	eb 0a		 jmp	 SHORT $LN69@HWR_Subsec
$LN68@HWR_Subsec:
  00873	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv407[ebp], 0
$LN69@HWR_Subsec:
  0087d	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv407[ebp]
  00883	50		 push	 eax
  00884	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  0088a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0088d	8b 02		 mov	 eax, DWORD PTR [edx]
  0088f	50		 push	 eax
  00890	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00896	51		 push	 ecx
  00897	e8 00 00 00 00	 call	 _R_GetPlaneLight
  0089c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0089f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2861 : 					HWR_RenderPlane(NULL, &extrasubsectors[num], *rover->bottomheight, PF_Occlude, *gr_frontsector->lightlist[light].lightlevel, levelflats[*rover->bottompic].lumpnum,

  008a5	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  008ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  008b2	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  008b8	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  008bc	50		 push	 eax
  008bd	6a 00		 push	 0
  008bf	68 ff 00 00 00	 push	 255			; 000000ffH
  008c4	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  008ca	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  008cd	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  008d0	50		 push	 eax
  008d1	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  008d7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  008da	8b 02		 mov	 eax, DWORD PTR [edx]
  008dc	c1 e0 05	 shl	 eax, 5
  008df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _levelflats
  008e5	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  008e9	52		 push	 edx
  008ea	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  008f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  008f7	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  008fd	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00901	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00904	51		 push	 ecx
  00905	68 00 01 00 00	 push	 256			; 00000100H
  0090a	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00910	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00913	8b 08		 mov	 ecx, DWORD PTR [eax]
  00915	51		 push	 ecx
  00916	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  00919	a1 00 00 00 00	 mov	 eax, DWORD PTR _extrasubsectors
  0091e	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00921	51		 push	 ecx
  00922	6a 00		 push	 0
  00924	e8 00 00 00 00	 call	 _HWR_RenderPlane
  00929	83 c4 28	 add	 esp, 40			; 00000028H
$LN46@HWR_Subsec:

; 2862 : 					                rover->master->frontsector, 255, false, gr_frontsector->lightlist[light].extra_colormap);
; 2863 : 				}
; 2864 : 			}
; 2865 : 			if (*rover->topheight >= gr_frontsector->floorheight &&
; 2866 : 			    *rover->topheight <= gr_frontsector->ceilingheight &&

  0092c	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00932	8b 08		 mov	 ecx, DWORD PTR [eax]
  00934	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  0093a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0093c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0093e	0f 8c fb 03 00
	00		 jl	 $LN56@HWR_Subsec
  00944	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0094a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0094c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00952	8b 01		 mov	 eax, DWORD PTR [ecx]
  00954	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00957	0f 8f e2 03 00
	00		 jg	 $LN56@HWR_Subsec
  0095d	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00963	8b 08		 mov	 ecx, DWORD PTR [eax]
  00965	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  0096b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0096d	7e 11		 jle	 SHORT $LN49@HWR_Subsec
  0096f	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00975	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00978	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0097e	74 3c		 je	 SHORT $LN50@HWR_Subsec
$LN49@HWR_Subsec:
  00980	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00986	8b 08		 mov	 ecx, DWORD PTR [eax]
  00988	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  0098e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00990	0f 8d a9 03 00
	00		 jge	 $LN56@HWR_Subsec
  00996	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  0099c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0099f	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  009a5	75 15		 jne	 SHORT $LN50@HWR_Subsec
  009a7	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  009ad	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  009b0	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  009b6	0f 84 83 03 00
	00		 je	 $LN56@HWR_Subsec
$LN50@HWR_Subsec:

; 2867 : 			    ((dup_viewz > *rover->topheight && !(rover->flags & FF_INVERTPLANES)) ||
; 2868 : 			     (dup_viewz < *rover->topheight && (rover->flags & FF_BOTHPLANES || rover->flags & FF_INVERTPLANES))))
; 2869 : 			{
; 2870 : 				if (rover->flags & FF_FOG)

  009bc	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  009c2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  009c5	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  009cb	0f 84 5b 01 00
	00		 je	 $LN51@HWR_Subsec

; 2871 : 				{
; 2872 : 					UINT8 alpha;
; 2873 : 
; 2874 : 					light = R_GetPlaneLight(gr_frontsector, *rover->topheight, dup_viewz < *rover->topheight ? true : false);

  009d1	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  009d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  009df	3b 11		 cmp	 edx, DWORD PTR [ecx]
  009e1	7d 0c		 jge	 SHORT $LN70@HWR_Subsec
  009e3	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv474[ebp], 1
  009ed	eb 0a		 jmp	 SHORT $LN71@HWR_Subsec
$LN70@HWR_Subsec:
  009ef	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv474[ebp], 0
$LN71@HWR_Subsec:
  009f9	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv474[ebp]
  009ff	50		 push	 eax
  00a00	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00a06	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a08	8b 02		 mov	 eax, DWORD PTR [edx]
  00a0a	50		 push	 eax
  00a0b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00a11	51		 push	 ecx
  00a12	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00a17	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a1a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2875 : 
; 2876 : 					if (rover->master->frontsector->extra_colormap)

  00a20	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00a26	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00a29	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00a2c	83 ba b0 00 00
	00 00		 cmp	 DWORD PTR [edx+176], 0
  00a33	74 57		 je	 SHORT $LN53@HWR_Subsec

; 2877 : 						alpha = HWR_FogBlockAlpha(*gr_frontsector->lightlist[light].lightlevel, rover->master->frontsector->extra_colormap->rgba, rover->master->frontsector->extra_colormap->fadergba);

  00a35	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00a3b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00a3e	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00a41	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00a47	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00a4a	51		 push	 ecx
  00a4b	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00a51	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00a54	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00a57	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00a5d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00a60	50		 push	 eax
  00a61	6b 8d e8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _light$[ebp], 20
  00a68	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00a6e	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00a74	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  00a78	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00a7b	52		 push	 edx
  00a7c	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  00a81	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a84	88 85 d6 fe ff
	ff		 mov	 BYTE PTR _alpha$2[ebp], al
  00a8a	eb 30		 jmp	 SHORT $LN54@HWR_Subsec
$LN53@HWR_Subsec:

; 2878 : 					else
; 2879 : 						alpha = HWR_FogBlockAlpha(*gr_frontsector->lightlist[light].lightlevel, NORMALFOG, FADEFOG);

  00a8c	68 00 00 00 19	 push	 419430400		; 19000000H
  00a91	6a 00		 push	 0
  00a93	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  00a9a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00aa0	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00aa6	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00aaa	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00aad	51		 push	 ecx
  00aae	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  00ab3	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ab6	88 85 d6 fe ff
	ff		 mov	 BYTE PTR _alpha$2[ebp], al
$LN54@HWR_Subsec:

; 2880 : 
; 2881 : 					HWR_AddTransparentFloor(0,

  00abc	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00ac2	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00ac5	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00ac8	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00ace	50		 push	 eax
  00acf	6a 01		 push	 1
  00ad1	68 02 20 00 00	 push	 8194			; 00002002H
  00ad6	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00adc	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00adf	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00ae2	50		 push	 eax
  00ae3	0f b6 8d d6 fe
	ff ff		 movzx	 ecx, BYTE PTR _alpha$2[ebp]
  00aea	51		 push	 ecx
  00aeb	6b 95 e8 fe ff
	ff 14		 imul	 edx, DWORD PTR _light$[ebp], 20
  00af2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00af7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00afd	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  00b01	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00b04	50		 push	 eax
  00b05	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00b0b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b0d	8b 02		 mov	 eax, DWORD PTR [edx]
  00b0f	50		 push	 eax
  00b10	8b 4d 08	 mov	 ecx, DWORD PTR _num$[ebp]
  00b13	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _extrasubsectors
  00b19	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00b1c	50		 push	 eax
  00b1d	6a 00		 push	 0
  00b1f	e8 00 00 00 00	 call	 _HWR_AddTransparentFloor
  00b24	83 c4 24	 add	 esp, 36			; 00000024H

; 2882 : 					                       &extrasubsectors[num],
; 2883 : 					                       *rover->topheight,
; 2884 : 					                       *gr_frontsector->lightlist[light].lightlevel,
; 2885 : 					                       alpha, rover->master->frontsector, PF_Translucent|PF_NoTexture,
; 2886 : 										   true, rover->master->frontsector->extra_colormap);
; 2887 : 				}

  00b27	e9 13 02 00 00	 jmp	 $LN56@HWR_Subsec
$LN51@HWR_Subsec:

; 2888 : 				else if (rover->flags & FF_TRANSLUCENT)

  00b2c	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00b32	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00b35	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00b3b	0f 84 09 01 00
	00		 je	 $LN55@HWR_Subsec

; 2889 : 				{
; 2890 : 					light = R_GetPlaneLight(gr_frontsector, *rover->topheight, dup_viewz < *rover->topheight ? true : false);

  00b41	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00b47	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b49	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  00b4f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00b51	7d 0c		 jge	 SHORT $LN72@HWR_Subsec
  00b53	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv544[ebp], 1
  00b5d	eb 0a		 jmp	 SHORT $LN73@HWR_Subsec
$LN72@HWR_Subsec:
  00b5f	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv544[ebp], 0
$LN73@HWR_Subsec:
  00b69	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv544[ebp]
  00b6f	50		 push	 eax
  00b70	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00b76	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b78	8b 02		 mov	 eax, DWORD PTR [edx]
  00b7a	50		 push	 eax
  00b7b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00b81	51		 push	 ecx
  00b82	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00b87	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b8a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2891 : #ifndef SORTING
; 2892 : 					HWR_Add3DWater(levelflats[*rover->toppic].lumpnum,
; 2893 : 					                          &extrasubsectors[num],
; 2894 : 					                          *rover->topheight,
; 2895 : 					                          *gr_frontsector->lightlist[light].lightlevel,
; 2896 : 					                          rover->alpha, rover->master->frontsector);
; 2897 : #else
; 2898 : 					HWR_AddTransparentFloor(levelflats[*rover->toppic].lumpnum,

  00b90	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00b96	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00b99	83 e9 01	 sub	 ecx, 1
  00b9c	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00ba2	7e 0c		 jle	 SHORT $LN74@HWR_Subsec
  00ba4	c7 85 8c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv565[ebp], 255 ; 000000ffH
  00bae	eb 12		 jmp	 SHORT $LN75@HWR_Subsec
$LN74@HWR_Subsec:
  00bb0	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00bb6	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00bb9	83 e8 01	 sub	 eax, 1
  00bbc	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv565[ebp], eax
$LN75@HWR_Subsec:
  00bc2	6b 8d e8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _light$[ebp], 20
  00bc9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00bcf	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00bd5	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  00bd9	51		 push	 ecx
  00bda	6a 00		 push	 0
  00bdc	6a 02		 push	 2
  00bde	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00be4	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00be7	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00bea	51		 push	 ecx
  00beb	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR tv565[ebp]
  00bf1	52		 push	 edx
  00bf2	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  00bf9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00bff	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00c05	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00c09	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00c0c	51		 push	 ecx
  00c0d	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00c13	8b 02		 mov	 eax, DWORD PTR [edx]
  00c15	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c17	51		 push	 ecx
  00c18	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  00c1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _extrasubsectors
  00c20	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00c23	51		 push	 ecx
  00c24	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00c2a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00c2d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c2f	c1 e1 05	 shl	 ecx, 5
  00c32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _levelflats
  00c38	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00c3c	50		 push	 eax
  00c3d	e8 00 00 00 00	 call	 _HWR_AddTransparentFloor
  00c42	83 c4 24	 add	 esp, 36			; 00000024H

; 2899 : 					                        &extrasubsectors[num],
; 2900 : 					                        *rover->topheight,
; 2901 : 					                        *gr_frontsector->lightlist[light].lightlevel,
; 2902 : 					                        rover->alpha-1 > 255 ? 255 : rover->alpha-1, rover->master->frontsector, PF_Translucent,
; 2903 : 											false, gr_frontsector->lightlist[light].extra_colormap);
; 2904 : #endif
; 2905 : 
; 2906 : 				}

  00c45	e9 f5 00 00 00	 jmp	 $LN56@HWR_Subsec
$LN55@HWR_Subsec:

; 2907 : 				else
; 2908 : 				{
; 2909 : 					HWR_GetFlat(levelflats[*rover->toppic].lumpnum);

  00c4a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00c50	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c53	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c55	c1 e2 05	 shl	 edx, 5
  00c58	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelflats
  00c5d	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  00c61	51		 push	 ecx
  00c62	e8 00 00 00 00	 call	 _HWR_GetFlat
  00c67	83 c4 04	 add	 esp, 4

; 2910 : 					light = R_GetPlaneLight(gr_frontsector, *rover->topheight, dup_viewz < *rover->topheight ? true : false);

  00c6a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _rover$4[ebp]
  00c70	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c72	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewz
  00c78	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00c7a	7d 0c		 jge	 SHORT $LN76@HWR_Subsec
  00c7c	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv596[ebp], 1
  00c86	eb 0a		 jmp	 SHORT $LN77@HWR_Subsec
$LN76@HWR_Subsec:
  00c88	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv596[ebp], 0
$LN77@HWR_Subsec:
  00c92	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv596[ebp]
  00c98	50		 push	 eax
  00c99	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00c9f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ca1	8b 02		 mov	 eax, DWORD PTR [edx]
  00ca3	50		 push	 eax
  00ca4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00caa	51		 push	 ecx
  00cab	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00cb0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cb3	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _light$[ebp], eax

; 2911 : 					HWR_RenderPlane(NULL, &extrasubsectors[num], *rover->topheight, PF_Occlude, *gr_frontsector->lightlist[light].lightlevel, levelflats[*rover->toppic].lumpnum,

  00cb9	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  00cc0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00cc6	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00ccc	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00cd0	50		 push	 eax
  00cd1	6a 00		 push	 0
  00cd3	68 ff 00 00 00	 push	 255			; 000000ffH
  00cd8	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00cde	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00ce1	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00ce4	50		 push	 eax
  00ce5	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _rover$4[ebp]
  00ceb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00cee	8b 02		 mov	 eax, DWORD PTR [edx]
  00cf0	c1 e0 05	 shl	 eax, 5
  00cf3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _levelflats
  00cf9	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00cfd	52		 push	 edx
  00cfe	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  00d05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00d0b	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00d11	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00d15	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00d18	51		 push	 ecx
  00d19	68 00 01 00 00	 push	 256			; 00000100H
  00d1e	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _rover$4[ebp]
  00d24	8b 02		 mov	 eax, DWORD PTR [edx]
  00d26	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d28	51		 push	 ecx
  00d29	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  00d2c	a1 00 00 00 00	 mov	 eax, DWORD PTR _extrasubsectors
  00d31	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00d34	51		 push	 ecx
  00d35	6a 00		 push	 0
  00d37	e8 00 00 00 00	 call	 _HWR_RenderPlane
  00d3c	83 c4 28	 add	 esp, 40			; 00000028H
$LN56@HWR_Subsec:

; 2912 : 					                  rover->master->frontsector, 255, false, gr_frontsector->lightlist[light].extra_colormap);
; 2913 : 				}
; 2914 : 			}
; 2915 : 		}

  00d3f	e9 7e f7 ff ff	 jmp	 $LN2@HWR_Subsec
$LN3@HWR_Subsec:

; 2916 : 	}
; 2917 : #endif
; 2918 : #endif //doplanes
; 2919 : 
; 2920 : #ifdef POLYOBJECTS
; 2921 : 	// Draw all the polyobjects in this subsector
; 2922 : 	if (sub->polyList)

  00d44	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00d47	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00d4b	74 4e		 je	 SHORT $LN57@HWR_Subsec

; 2923 : 	{
; 2924 : 		polyobj_t *po = sub->polyList;

  00d4d	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00d50	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00d53	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _po$1[ebp], ecx

; 2925 : 
; 2926 : 		numpolys = 0;

  00d59	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numpolys, 0
$LN5@HWR_Subsec:

; 2927 : 
; 2928 : 		// Count all the polyobjects, reset the list, and recount them
; 2929 : 		while (po)

  00d63	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _po$1[ebp], 0
  00d6a	74 1d		 je	 SHORT $LN6@HWR_Subsec

; 2930 : 		{
; 2931 : 			++numpolys;

  00d6c	a1 00 00 00 00	 mov	 eax, DWORD PTR _numpolys
  00d71	83 c0 01	 add	 eax, 1
  00d74	a3 00 00 00 00	 mov	 DWORD PTR _numpolys, eax

; 2932 : 			po = (polyobj_t *)(po->link.next);

  00d79	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _po$1[ebp]
  00d7f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d81	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _po$1[ebp], ecx

; 2933 : 		}

  00d87	eb da		 jmp	 SHORT $LN5@HWR_Subsec
$LN6@HWR_Subsec:

; 2934 : 
; 2935 : 		// Sort polyobjects
; 2936 : 		R_SortPolyObjects(sub);

  00d89	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00d8c	50		 push	 eax
  00d8d	e8 00 00 00 00	 call	 _R_SortPolyObjects
  00d92	83 c4 04	 add	 esp, 4

; 2937 : 
; 2938 : 		// Draw polyobject lines.
; 2939 : 		HWR_AddPolyObjectSegs();

  00d95	e8 00 00 00 00	 call	 _HWR_AddPolyObjectSegs
  00d9a	90		 npad	 1
$LN57@HWR_Subsec:

; 2940 : 
; 2941 : 		// Draw polyobject planes
; 2942 : 		//HWR_AddPolyObjectPlanes();
; 2943 : 	}
; 2944 : #endif
; 2945 : 
; 2946 : // Hurder ici se passe les choses INT32essantes!
; 2947 : // on vient de tracer le sol et le plafond
; 2948 : // on trace prent d'abord les sprites et ensuite les murs
; 2949 : // hurdler: faux: on ajoute seulement les sprites, le murs sont trac d'abord
; 2950 : 	if (line)

  00d9b	83 7d f8 00	 cmp	 DWORD PTR _line$[ebp], 0
  00d9f	74 52		 je	 SHORT $LN8@HWR_Subsec

; 2951 : 	{
; 2952 : 		// draw sprites first, coz they are clipped to the solidsegs of
; 2953 : 		// subsectors more 'in front'
; 2954 : 		HWR_AddSprites(gr_frontsector);

  00da1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00da6	50		 push	 eax
  00da7	e8 00 00 00 00	 call	 _HWR_AddSprites
  00dac	83 c4 04	 add	 esp, 4

; 2955 : 
; 2956 : 		//Hurdler: at this point validcount must be the same, but is not because
; 2957 : 		//         gr_frontsector doesn't point anymore to sub->sector due to
; 2958 : 		//         the call gr_frontsector = R_FakeFlat(...)
; 2959 : 		//         if it's not done, the sprite is drawn more than once,
; 2960 : 		//         what looks really bad with translucency or dynamic light,
; 2961 : 		//         without talking about the overdraw of course.
; 2962 : 		sub->sector->validcount = validcount;/// \todo fix that in a better way

  00daf	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00db2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00db4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _validcount
  00dba	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
$LN7@HWR_Subsec:

; 2963 : 
; 2964 : 		while (count--)

  00dbd	0f bf 45 fc	 movsx	 eax, WORD PTR _count$[ebp]
  00dc1	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv647[ebp], eax
  00dc7	66 8b 4d fc	 mov	 cx, WORD PTR _count$[ebp]
  00dcb	66 83 e9 01	 sub	 cx, 1
  00dcf	66 89 4d fc	 mov	 WORD PTR _count$[ebp], cx
  00dd3	83 bd 8c fe ff
	ff 00		 cmp	 DWORD PTR tv647[ebp], 0
  00dda	74 17		 je	 SHORT $LN8@HWR_Subsec

; 2965 : 		{
; 2966 : 				HWR_AddLine(line);

  00ddc	8b 45 f8	 mov	 eax, DWORD PTR _line$[ebp]
  00ddf	50		 push	 eax
  00de0	e8 00 00 00 00	 call	 _HWR_AddLine
  00de5	83 c4 04	 add	 esp, 4

; 2967 : 				line++;

  00de8	8b 45 f8	 mov	 eax, DWORD PTR _line$[ebp]
  00deb	83 c0 3c	 add	 eax, 60			; 0000003cH
  00dee	89 45 f8	 mov	 DWORD PTR _line$[ebp], eax

; 2968 : 		}

  00df1	eb ca		 jmp	 SHORT $LN7@HWR_Subsec
$LN8@HWR_Subsec:

; 2969 : 	}
; 2970 : 
; 2971 : //20/08/99: Changed by Hurdler (taken from faB's code)
; 2972 : #ifdef DOPLANES
; 2973 : 	// -------------------- WATER IN DEV. TEST ------------------------
; 2974 : 	//dck hack : use abs(tag) for waterheight
; 2975 : 	if (gr_frontsector->tag < 0)

  00df3	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00df8	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00dfc	85 c9		 test	 ecx, ecx
  00dfe	0f 8d 9e 00 00
	00		 jge	 $LN60@HWR_Subsec

; 2976 : 	{
; 2977 : 		wh = ((-gr_frontsector->tag) <<FRACBITS) + (FRACUNIT/2);

  00e04	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00e09	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00e0d	f7 d9		 neg	 ecx
  00e0f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00e12	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  00e18	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _wh$[ebp], ecx

; 2978 : 		if (wh > gr_frontsector->floorheight &&

  00e1e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00e23	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _wh$[ebp]
  00e29	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00e2b	7e 75		 jle	 SHORT $LN60@HWR_Subsec
  00e2d	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00e32	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _wh$[ebp]
  00e38	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00e3b	7d 65		 jge	 SHORT $LN60@HWR_Subsec

; 2979 : 			wh < gr_frontsector->ceilingheight)
; 2980 : 		{
; 2981 : 			HWR_GetFlat(doomwaterflat);

  00e3d	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomwaterflat
  00e42	50		 push	 eax
  00e43	e8 00 00 00 00	 call	 _HWR_GetFlat
  00e48	83 c4 04	 add	 esp, 4

; 2982 : 			HWR_RenderPlane(gr_frontsector,

  00e4b	6b 85 e8 fe ff
	ff 14		 imul	 eax, DWORD PTR _light$[ebp], 20
  00e52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00e58	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00e5e	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00e62	50		 push	 eax
  00e63	6a 00		 push	 0
  00e65	68 ff 00 00 00	 push	 255			; 000000ffH
  00e6a	6a 00		 push	 0
  00e6c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomwaterflat
  00e72	51		 push	 ecx
  00e73	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00e79	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00e7d	50		 push	 eax
  00e7e	6a 02		 push	 2
  00e80	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _wh$[ebp]
  00e86	51		 push	 ecx
  00e87	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  00e8a	a1 00 00 00 00	 mov	 eax, DWORD PTR _extrasubsectors
  00e8f	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00e92	51		 push	 ecx
  00e93	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00e99	52		 push	 edx
  00e9a	e8 00 00 00 00	 call	 _HWR_RenderPlane
  00e9f	83 c4 28	 add	 esp, 40			; 00000028H
$LN60@HWR_Subsec:

; 2983 : 				&extrasubsectors[num], wh, PF_Translucent,
; 2984 : 				gr_frontsector->lightlevel, doomwaterflat,
; 2985 : 				NULL, 255, false, gr_frontsector->lightlist[light].extra_colormap);
; 2986 : 		}
; 2987 : 	}
; 2988 : 	// -------------------- WATER IN DEV. TEST ------------------------
; 2989 : #endif
; 2990 : 	sub->validcount = validcount;

  00ea2	8b 45 f4	 mov	 eax, DWORD PTR _sub$[ebp]
  00ea5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00eab	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2991 : }

  00eae	5f		 pop	 edi
  00eaf	5e		 pop	 esi
  00eb0	5b		 pop	 ebx
  00eb1	8b e5		 mov	 esp, ebp
  00eb3	5d		 pop	 ebp
  00eb4	c3		 ret	 0
_HWR_Subsector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddPolyObjectSegs
_TEXT	SEGMENT
_pv2$ = -20						; size = 4
_pv1$ = -16						; size = 4
_gr_fakeline$ = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_HWR_AddPolyObjectSegs PROC				; COMDAT

; 2598 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2599 : 	size_t i, j;
; 2600 : 	seg_t *gr_fakeline = Z_Calloc(sizeof(seg_t), PU_STATIC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 01		 push	 1
  0000f	6a 3c		 push	 60			; 0000003cH
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 f4	 mov	 DWORD PTR _gr_fakeline$[ebp], eax

; 2601 : 	polyvertex_t *pv1 = Z_Calloc(sizeof(polyvertex_t), PU_STATIC, NULL);

  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	6a 01		 push	 1
  00022	6a 0c		 push	 12			; 0000000cH
  00024	e8 00 00 00 00	 call	 _Z_CallocAlign
  00029	83 c4 10	 add	 esp, 16			; 00000010H
  0002c	89 45 f0	 mov	 DWORD PTR _pv1$[ebp], eax

; 2602 : 	polyvertex_t *pv2 = Z_Calloc(sizeof(polyvertex_t), PU_STATIC, NULL);

  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 01		 push	 1
  00035	6a 0c		 push	 12			; 0000000cH
  00037	e8 00 00 00 00	 call	 _Z_CallocAlign
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	89 45 ec	 mov	 DWORD PTR _pv2$[ebp], eax

; 2603 : 
; 2604 : 	// Sort through all the polyobjects
; 2605 : 	for (i = 0; i < numpolys; ++i)

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@HWR_AddPol
$LN2@HWR_AddPol:
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HWR_AddPol:
  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numpolys
  0005d	0f 83 dc 00 00
	00		 jae	 $LN3@HWR_AddPol

; 2606 : 	{
; 2607 : 		// Render the polyobject's lines
; 2608 : 		for (j = 0; j < po_ptrs[i]->segCount; ++j)

  00063	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0006a	eb 09		 jmp	 SHORT $LN7@HWR_AddPol
$LN5@HWR_AddPol:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@HWR_AddPol:
  00075	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _po_ptrs
  0007e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00081	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00084	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00087	0f 83 ad 00 00
	00		 jae	 $LN6@HWR_AddPol

; 2609 : 		{
; 2610 : 			// Copy the info of a polyobject's seg, then convert it to OpenGL floating point
; 2611 : 			M_Memcpy(gr_fakeline, po_ptrs[i]->segs[j], sizeof(seg_t));

  0008d	6a 3c		 push	 60			; 0000003cH
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _po_ptrs
  00098	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0009b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  000a1	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000a4	52		 push	 edx
  000a5	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  000a8	50		 push	 eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2612 : 
; 2613 : 			// Now convert the line to float and add it to be rendered
; 2614 : 			pv1->x = FIXED_TO_FLOAT(gr_fakeline->v1->x);

  000b2	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	f3 0f 2a 01	 cvtsi2ss xmm0, DWORD PTR [ecx]
  000bb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  000c3	8b 55 f0	 mov	 edx, DWORD PTR _pv1$[ebp]
  000c6	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 2615 : 			pv1->y = FIXED_TO_FLOAT(gr_fakeline->v1->y);

  000ca	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  000cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cf	f3 0f 2a 41 04	 cvtsi2ss xmm0, DWORD PTR [ecx+4]
  000d4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  000dc	8b 55 f0	 mov	 edx, DWORD PTR _pv1$[ebp]
  000df	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 2616 : 			pv2->x = FIXED_TO_FLOAT(gr_fakeline->v2->x);

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  000e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ea	f3 0f 2a 01	 cvtsi2ss xmm0, DWORD PTR [ecx]
  000ee	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  000f6	8b 55 ec	 mov	 edx, DWORD PTR _pv2$[ebp]
  000f9	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 2617 : 			pv2->y = FIXED_TO_FLOAT(gr_fakeline->v2->y);

  000fd	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  00100	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00103	f3 0f 2a 41 04	 cvtsi2ss xmm0, DWORD PTR [ecx+4]
  00108	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00110	8b 55 ec	 mov	 edx, DWORD PTR _pv2$[ebp]
  00113	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 2618 : 
; 2619 : 			gr_fakeline->v1 = (vertex_t *)pv1;

  00118	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  0011b	8b 4d f0	 mov	 ecx, DWORD PTR _pv1$[ebp]
  0011e	89 08		 mov	 DWORD PTR [eax], ecx

; 2620 : 			gr_fakeline->v2 = (vertex_t *)pv2;

  00120	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  00123	8b 4d ec	 mov	 ecx, DWORD PTR _pv2$[ebp]
  00126	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2621 : 
; 2622 : 			HWR_AddLine(gr_fakeline);

  00129	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _HWR_AddLine
  00132	83 c4 04	 add	 esp, 4

; 2623 : 		}

  00135	e9 32 ff ff ff	 jmp	 $LN5@HWR_AddPol
$LN6@HWR_AddPol:

; 2624 : 	}

  0013a	e9 0c ff ff ff	 jmp	 $LN2@HWR_AddPol
$LN3@HWR_AddPol:

; 2625 : 
; 2626 : 	// Free temporary data no longer needed
; 2627 : 	Z_Free(pv2);

  0013f	8b 45 ec	 mov	 eax, DWORD PTR _pv2$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _Z_Free
  00148	83 c4 04	 add	 esp, 4

; 2628 : 	Z_Free(pv1);

  0014b	8b 45 f0	 mov	 eax, DWORD PTR _pv1$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _Z_Free
  00154	83 c4 04	 add	 esp, 4

; 2629 : 	Z_Free(gr_fakeline);

  00157	8b 45 f4	 mov	 eax, DWORD PTR _gr_fakeline$[ebp]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _Z_Free
  00160	83 c4 04	 add	 esp, 4

; 2630 : }

  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
_HWR_AddPolyObjectSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_CheckBBox
_TEXT	SEGMENT
_tspan$ = -44						; size = 4
_span$ = -40						; size = 4
_angle2$ = -36						; size = 4
_angle1$ = -32						; size = 4
_py2$ = -28						; size = 4
_px2$ = -24						; size = 4
_py1$ = -20						; size = 4
_px1$ = -16						; size = 4
_sx2$ = -12						; size = 4
_sx1$ = -8						; size = 4
_boxpos$ = -4						; size = 4
_bspcoord$ = 8						; size = 4
_HWR_CheckBBox PROC					; COMDAT

; 2510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2511 : 	INT32 boxpos, sx1, sx2;
; 2512 : 	fixed_t px1, py1, px2, py2;
; 2513 : 	angle_t angle1, angle2, span, tspan;
; 2514 : 
; 2515 : 	// Find the corners of the box
; 2516 : 	// that define the edges from current viewpoint.
; 2517 : 	if (dup_viewx <= bspcoord[BOXLEFT])

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	d1 e0		 shl	 eax, 1
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewx
  00019	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  0001c	7f 09		 jg	 SHORT $LN2@HWR_CheckB

; 2518 : 		boxpos = 0;

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _boxpos$[ebp], 0
  00025	eb 25		 jmp	 SHORT $LN5@HWR_CheckB
$LN2@HWR_CheckB:

; 2519 : 	else if (dup_viewx < bspcoord[BOXRIGHT])

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 03	 imul	 ecx, eax, 3
  0002f	8b 55 08	 mov	 edx, DWORD PTR _bspcoord$[ebp]
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewx
  00037	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  0003a	7d 09		 jge	 SHORT $LN4@HWR_CheckB

; 2520 : 		boxpos = 1;

  0003c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _boxpos$[ebp], 1
  00043	eb 07		 jmp	 SHORT $LN5@HWR_CheckB
$LN4@HWR_CheckB:

; 2521 : 	else
; 2522 : 		boxpos = 2;

  00045	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _boxpos$[ebp], 2
$LN5@HWR_CheckB:

; 2523 : 
; 2524 : 	if (dup_viewy >= bspcoord[BOXTOP])

  0004c	b8 04 00 00 00	 mov	 eax, 4
  00051	6b c8 00	 imul	 ecx, eax, 0
  00054	8b 55 08	 mov	 edx, DWORD PTR _bspcoord$[ebp]
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewy
  0005c	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  0005f	7c 08		 jl	 SHORT $LN6@HWR_CheckB

; 2525 : 		boxpos |= 0;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  00064	89 45 fc	 mov	 DWORD PTR _boxpos$[ebp], eax
  00067	eb 2a		 jmp	 SHORT $LN9@HWR_CheckB
$LN6@HWR_CheckB:

; 2526 : 	else if (dup_viewy > bspcoord[BOXBOTTOM])

  00069	b8 04 00 00 00	 mov	 eax, 4
  0006e	c1 e0 00	 shl	 eax, 0
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dup_viewy
  0007a	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  0007d	7e 0b		 jle	 SHORT $LN8@HWR_CheckB

; 2527 : 		boxpos |= 1<<2;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  00082	83 c8 04	 or	 eax, 4
  00085	89 45 fc	 mov	 DWORD PTR _boxpos$[ebp], eax
  00088	eb 09		 jmp	 SHORT $LN9@HWR_CheckB
$LN8@HWR_CheckB:

; 2528 : 	else
; 2529 : 		boxpos |= 2<<2;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  0008d	83 c8 08	 or	 eax, 8
  00090	89 45 fc	 mov	 DWORD PTR _boxpos$[ebp], eax
$LN9@HWR_CheckB:

; 2530 : 
; 2531 : 	if (boxpos == 5)

  00093	83 7d fc 05	 cmp	 DWORD PTR _boxpos$[ebp], 5
  00097	75 0a		 jne	 SHORT $LN10@HWR_CheckB

; 2532 : 		return true;

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	e9 94 01 00 00	 jmp	 $LN1@HWR_CheckB
$LN10@HWR_CheckB:

; 2533 : 
; 2534 : 	px1 = bspcoord[checkcoord[boxpos][0]];

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000a6	c1 e0 04	 shl	 eax, 4
  000a9	b9 04 00 00 00	 mov	 ecx, 4
  000ae	6b d1 00	 imul	 edx, ecx, 0
  000b1	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR _checkcoord[eax+edx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  000bb	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000be	89 55 f0	 mov	 DWORD PTR _px1$[ebp], edx

; 2535 : 	py1 = bspcoord[checkcoord[boxpos][1]];

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000c4	c1 e0 04	 shl	 eax, 4
  000c7	b9 04 00 00 00	 mov	 ecx, 4
  000cc	c1 e1 00	 shl	 ecx, 0
  000cf	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _checkcoord[eax+ecx]
  000d6	8b 45 08	 mov	 eax, DWORD PTR _bspcoord$[ebp]
  000d9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000dc	89 4d ec	 mov	 DWORD PTR _py1$[ebp], ecx

; 2536 : 	px2 = bspcoord[checkcoord[boxpos][2]];

  000df	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000e2	c1 e0 04	 shl	 eax, 4
  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	d1 e1		 shl	 ecx, 1
  000ec	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _checkcoord[eax+ecx]
  000f3	8b 45 08	 mov	 eax, DWORD PTR _bspcoord$[ebp]
  000f6	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000f9	89 4d e8	 mov	 DWORD PTR _px2$[ebp], ecx

; 2537 : 	py2 = bspcoord[checkcoord[boxpos][3]];

  000fc	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000ff	c1 e0 04	 shl	 eax, 4
  00102	b9 04 00 00 00	 mov	 ecx, 4
  00107	6b d1 03	 imul	 edx, ecx, 3
  0010a	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR _checkcoord[eax+edx]
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  00114	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00117	89 55 e4	 mov	 DWORD PTR _py2$[ebp], edx

; 2538 : 
; 2539 : 	// check clip list for an open space
; 2540 : 	angle1 = R_PointToAngle(px1, py1) - dup_viewangle;

  0011a	8b 45 ec	 mov	 eax, DWORD PTR _py1$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _px1$[ebp]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 _R_PointToAngle
  00127	83 c4 08	 add	 esp, 8
  0012a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dup_viewangle
  00130	89 45 e0	 mov	 DWORD PTR _angle1$[ebp], eax

; 2541 : 	angle2 = R_PointToAngle(px2, py2) - dup_viewangle;

  00133	8b 45 e4	 mov	 eax, DWORD PTR _py2$[ebp]
  00136	50		 push	 eax
  00137	8b 4d e8	 mov	 ecx, DWORD PTR _px2$[ebp]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _R_PointToAngle
  00140	83 c4 08	 add	 esp, 8
  00143	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dup_viewangle
  00149	89 45 dc	 mov	 DWORD PTR _angle2$[ebp], eax

; 2542 : 
; 2543 : 	span = angle1 - angle2;

  0014c	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  0014f	2b 45 dc	 sub	 eax, DWORD PTR _angle2$[ebp]
  00152	89 45 d8	 mov	 DWORD PTR _span$[ebp], eax

; 2544 : 
; 2545 : 	// Sitting on a line?
; 2546 : 	if (span >= ANGLE_180)

  00155	81 7d d8 00 00
	00 80		 cmp	 DWORD PTR _span$[ebp], -2147483648 ; 80000000H
  0015c	72 0a		 jb	 SHORT $LN11@HWR_CheckB

; 2547 : 		return true;

  0015e	b8 01 00 00 00	 mov	 eax, 1
  00163	e9 cf 00 00 00	 jmp	 $LN1@HWR_CheckB
$LN11@HWR_CheckB:

; 2548 : 
; 2549 : 	tspan = angle1 + gr_clipangle;

  00168	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  0016b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _gr_clipangle
  00171	89 45 d4	 mov	 DWORD PTR _tspan$[ebp], eax

; 2550 : 
; 2551 : 	if (tspan > 2*gr_clipangle)

  00174	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  00179	d1 e0		 shl	 eax, 1
  0017b	39 45 d4	 cmp	 DWORD PTR _tspan$[ebp], eax
  0017e	76 26		 jbe	 SHORT $LN12@HWR_CheckB

; 2552 : 	{
; 2553 : 		tspan -= 2*gr_clipangle;

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  00185	d1 e0		 shl	 eax, 1
  00187	8b 4d d4	 mov	 ecx, DWORD PTR _tspan$[ebp]
  0018a	2b c8		 sub	 ecx, eax
  0018c	89 4d d4	 mov	 DWORD PTR _tspan$[ebp], ecx

; 2554 : 
; 2555 : 		// Totally off the left edge?
; 2556 : 		if (tspan >= span)

  0018f	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  00192	3b 45 d8	 cmp	 eax, DWORD PTR _span$[ebp]
  00195	72 07		 jb	 SHORT $LN13@HWR_CheckB

; 2557 : 			return false;

  00197	33 c0		 xor	 eax, eax
  00199	e9 99 00 00 00	 jmp	 $LN1@HWR_CheckB
$LN13@HWR_CheckB:

; 2558 : 
; 2559 : 		angle1 = gr_clipangle;

  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  001a3	89 45 e0	 mov	 DWORD PTR _angle1$[ebp], eax
$LN12@HWR_CheckB:

; 2560 : 	}
; 2561 : 	tspan = gr_clipangle - angle2;

  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  001ab	2b 45 dc	 sub	 eax, DWORD PTR _angle2$[ebp]
  001ae	89 45 d4	 mov	 DWORD PTR _tspan$[ebp], eax

; 2562 : 	if (tspan > 2*gr_clipangle)

  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  001b6	d1 e0		 shl	 eax, 1
  001b8	39 45 d4	 cmp	 DWORD PTR _tspan$[ebp], eax
  001bb	76 25		 jbe	 SHORT $LN14@HWR_CheckB

; 2563 : 	{
; 2564 : 		tspan -= 2*gr_clipangle;

  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  001c2	d1 e0		 shl	 eax, 1
  001c4	8b 4d d4	 mov	 ecx, DWORD PTR _tspan$[ebp]
  001c7	2b c8		 sub	 ecx, eax
  001c9	89 4d d4	 mov	 DWORD PTR _tspan$[ebp], ecx

; 2565 : 
; 2566 : 		// Totally off the left edge?
; 2567 : 		if (tspan >= span)

  001cc	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  001cf	3b 45 d8	 cmp	 eax, DWORD PTR _span$[ebp]
  001d2	72 04		 jb	 SHORT $LN15@HWR_CheckB

; 2568 : 			return false;

  001d4	33 c0		 xor	 eax, eax
  001d6	eb 5f		 jmp	 SHORT $LN1@HWR_CheckB
$LN15@HWR_CheckB:

; 2569 : 
; 2570 : 		angle2 = (angle_t)-(signed)gr_clipangle;

  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  001dd	f7 d8		 neg	 eax
  001df	89 45 dc	 mov	 DWORD PTR _angle2$[ebp], eax
$LN14@HWR_CheckB:

; 2571 : 	}
; 2572 : 
; 2573 : 	// Find the first clippost
; 2574 : 	//  that touches the source post
; 2575 : 	//  (adjacent pixels are touching).
; 2576 : 	angle1 = (angle1+ANGLE_90)>>ANGLETOFINESHIFT;

  001e2	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  001e5	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  001ea	c1 e8 13	 shr	 eax, 19			; 00000013H
  001ed	89 45 e0	 mov	 DWORD PTR _angle1$[ebp], eax

; 2577 : 	angle2 = (angle2+ANGLE_90)>>ANGLETOFINESHIFT;

  001f0	8b 45 dc	 mov	 eax, DWORD PTR _angle2$[ebp]
  001f3	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  001f8	c1 e8 13	 shr	 eax, 19			; 00000013H
  001fb	89 45 dc	 mov	 DWORD PTR _angle2$[ebp], eax

; 2578 : 	sx1 = gr_viewangletox[angle1];

  001fe	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  00201	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _gr_viewangletox[eax*4]
  00208	89 4d f8	 mov	 DWORD PTR _sx1$[ebp], ecx

; 2579 : 	sx2 = gr_viewangletox[angle2];

  0020b	8b 45 dc	 mov	 eax, DWORD PTR _angle2$[ebp]
  0020e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _gr_viewangletox[eax*4]
  00215	89 4d f4	 mov	 DWORD PTR _sx2$[ebp], ecx

; 2580 : 
; 2581 : 	// Does not cross a pixel.
; 2582 : 	if (sx1 == sx2)

  00218	8b 45 f8	 mov	 eax, DWORD PTR _sx1$[ebp]
  0021b	3b 45 f4	 cmp	 eax, DWORD PTR _sx2$[ebp]
  0021e	75 04		 jne	 SHORT $LN16@HWR_CheckB

; 2583 : 		return false;

  00220	33 c0		 xor	 eax, eax
  00222	eb 13		 jmp	 SHORT $LN1@HWR_CheckB
$LN16@HWR_CheckB:

; 2584 : 
; 2585 : 	return HWR_ClipToSolidSegs(sx1, sx2 - 1);

  00224	8b 45 f4	 mov	 eax, DWORD PTR _sx2$[ebp]
  00227	83 e8 01	 sub	 eax, 1
  0022a	50		 push	 eax
  0022b	8b 4d f8	 mov	 ecx, DWORD PTR _sx1$[ebp]
  0022e	51		 push	 ecx
  0022f	e8 00 00 00 00	 call	 _HWR_ClipToSolidSegs
  00234	83 c4 08	 add	 esp, 8
$LN1@HWR_CheckB:

; 2586 : }

  00237	5f		 pop	 edi
  00238	5e		 pop	 esi
  00239	5b		 pop	 ebx
  0023a	8b e5		 mov	 esp, ebp
  0023c	5d		 pop	 ebp
  0023d	c3		 ret	 0
_HWR_CheckBBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddLine
_TEXT	SEGMENT
_tempsec$ = -272					; size = 248
_tspan$ = -24						; size = 4
_span$ = -20						; size = 4
_angle2$ = -16						; size = 4
_angle1$ = -12						; size = 4
_x2$ = -8						; size = 4
_x1$ = -4						; size = 4
_line$ = 8						; size = 4
_HWR_AddLine PROC					; COMDAT

; 2355 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2356 : 	INT32 x1, x2;
; 2357 : 	angle_t angle1, angle2;
; 2358 : 	angle_t span, tspan;
; 2359 : 
; 2360 : 	// SoM: Backsector needs to be run through R_FakeFlat
; 2361 : 	sector_t tempsec;
; 2362 : 
; 2363 : 	if (line->polyseg && !(line->polyseg->flags & POF_RENDERSIDES))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000f	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00013	74 16		 je	 SHORT $LN2@HWR_AddLin
  00015	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00018	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001b	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00021	83 e2 08	 and	 edx, 8
  00024	75 05		 jne	 SHORT $LN2@HWR_AddLin

; 2364 : 		return;

  00026	e9 a8 02 00 00	 jmp	 $LN1@HWR_AddLin
$LN2@HWR_AddLin:

; 2365 : 
; 2366 : 	gr_curline = line;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0002e	a3 00 00 00 00	 mov	 DWORD PTR _gr_curline, eax

; 2367 : 
; 2368 : 	// OPTIMIZE: quickly reject orthogonal back sides.
; 2369 : 	angle1 = R_PointToAngle(FLOAT_TO_FIXED(((polyvertex_t *)gr_curline->v1)->x),

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0003f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  00047	f3 0f 2c d0	 cvttss2si edx, xmm0
  0004b	52		 push	 edx
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00057	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  0005f	f3 0f 2c d0	 cvttss2si edx, xmm0
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _R_PointToAngle
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax

; 2370 : 	                        FLOAT_TO_FIXED(((polyvertex_t *)gr_curline->v1)->y));
; 2371 : 	angle2 = R_PointToAngle(FLOAT_TO_FIXED(((polyvertex_t *)gr_curline->v2)->x),

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00074	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00077	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0007c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  00084	f3 0f 2c d0	 cvttss2si edx, xmm0
  00088	52		 push	 edx
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  0008e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00091	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00095	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  0009d	f3 0f 2c d0	 cvttss2si edx, xmm0
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 _R_PointToAngle
  000a7	83 c4 08	 add	 esp, 8
  000aa	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax

; 2372 : 	                        FLOAT_TO_FIXED(((polyvertex_t *)gr_curline->v2)->y));
; 2373 : 
; 2374 : 	// Clip to view edges.
; 2375 : 	span = angle1 - angle2;

  000ad	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  000b0	2b 45 f0	 sub	 eax, DWORD PTR _angle2$[ebp]
  000b3	89 45 ec	 mov	 DWORD PTR _span$[ebp], eax

; 2376 : 
; 2377 : 	// backface culling : span is < ANGLE_180 if ang1 > ang2 : the seg is facing
; 2378 : 	if (span >= ANGLE_180)

  000b6	81 7d ec 00 00
	00 80		 cmp	 DWORD PTR _span$[ebp], -2147483648 ; 80000000H
  000bd	72 05		 jb	 SHORT $LN3@HWR_AddLin

; 2379 : 		return;

  000bf	e9 0f 02 00 00	 jmp	 $LN1@HWR_AddLin
$LN3@HWR_AddLin:

; 2380 : 
; 2381 : 	// Global angle needed by segcalc.
; 2382 : 	//rw_angle1 = angle1;
; 2383 : 	angle1 -= dup_viewangle;

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  000c7	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dup_viewangle
  000cd	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax

; 2384 : 	angle2 -= dup_viewangle;

  000d0	8b 45 f0	 mov	 eax, DWORD PTR _angle2$[ebp]
  000d3	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dup_viewangle
  000d9	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax

; 2385 : 
; 2386 : 	tspan = angle1 + gr_clipangle;

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  000df	03 05 00 00 00
	00		 add	 eax, DWORD PTR _gr_clipangle
  000e5	89 45 e8	 mov	 DWORD PTR _tspan$[ebp], eax

; 2387 : 	if (tspan > 2*gr_clipangle)

  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  000ed	d1 e0		 shl	 eax, 1
  000ef	39 45 e8	 cmp	 DWORD PTR _tspan$[ebp], eax
  000f2	76 24		 jbe	 SHORT $LN4@HWR_AddLin

; 2388 : 	{
; 2389 : 		tspan -= 2*gr_clipangle;

  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  000f9	d1 e0		 shl	 eax, 1
  000fb	8b 4d e8	 mov	 ecx, DWORD PTR _tspan$[ebp]
  000fe	2b c8		 sub	 ecx, eax
  00100	89 4d e8	 mov	 DWORD PTR _tspan$[ebp], ecx

; 2390 : 
; 2391 : 		// Totally off the left edge?
; 2392 : 		if (tspan >= span)

  00103	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  00106	3b 45 ec	 cmp	 eax, DWORD PTR _span$[ebp]
  00109	72 05		 jb	 SHORT $LN5@HWR_AddLin

; 2393 : 			return;

  0010b	e9 c3 01 00 00	 jmp	 $LN1@HWR_AddLin
$LN5@HWR_AddLin:

; 2394 : 
; 2395 : 		angle1 = gr_clipangle;

  00110	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  00115	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax
$LN4@HWR_AddLin:

; 2396 : 	}
; 2397 : 	tspan = gr_clipangle - angle2;

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  0011d	2b 45 f0	 sub	 eax, DWORD PTR _angle2$[ebp]
  00120	89 45 e8	 mov	 DWORD PTR _tspan$[ebp], eax

; 2398 : 	if (tspan > 2*gr_clipangle)

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  00128	d1 e0		 shl	 eax, 1
  0012a	39 45 e8	 cmp	 DWORD PTR _tspan$[ebp], eax
  0012d	76 26		 jbe	 SHORT $LN6@HWR_AddLin

; 2399 : 	{
; 2400 : 		tspan -= 2*gr_clipangle;

  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  00134	d1 e0		 shl	 eax, 1
  00136	8b 4d e8	 mov	 ecx, DWORD PTR _tspan$[ebp]
  00139	2b c8		 sub	 ecx, eax
  0013b	89 4d e8	 mov	 DWORD PTR _tspan$[ebp], ecx

; 2401 : 
; 2402 : 		// Totally off the left edge?
; 2403 : 		if (tspan >= span)

  0013e	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  00141	3b 45 ec	 cmp	 eax, DWORD PTR _span$[ebp]
  00144	72 05		 jb	 SHORT $LN7@HWR_AddLin

; 2404 : 			return;

  00146	e9 88 01 00 00	 jmp	 $LN1@HWR_AddLin
$LN7@HWR_AddLin:

; 2405 : 
; 2406 : 		angle2 = (angle_t)-(signed)gr_clipangle;

  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_clipangle
  00150	f7 d8		 neg	 eax
  00152	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax
$LN6@HWR_AddLin:

; 2407 : 	}
; 2408 : 
; 2409 : #if 0
; 2410 : 	{
; 2411 : 		float fx1,fx2,fy1,fy2;
; 2412 : 		//BP: test with a better projection than viewangletox[R_PointToAngle(angle)]
; 2413 : 		// do not enable this at release 4 mul and 2 div
; 2414 : 		fx1 = ((polyvertex_t *)(line->v1))->x-gr_viewx;
; 2415 : 		fy1 = ((polyvertex_t *)(line->v1))->y-gr_viewy;
; 2416 : 		fy2 = (fx1 * gr_viewcos + fy1 * gr_viewsin);
; 2417 : 		if (fy2 < 0)
; 2418 : 			// the point is back
; 2419 : 			fx1 = 0;
; 2420 : 		else
; 2421 : 			fx1 = gr_windowcenterx + (fx1 * gr_viewsin - fy1 * gr_viewcos) * gr_centerx / fy2;
; 2422 : 
; 2423 : 		fx2 = ((polyvertex_t *)(line->v2))->x-gr_viewx;
; 2424 : 		fy2 = ((polyvertex_t *)(line->v2))->y-gr_viewy;
; 2425 : 		fy1 = (fx2 * gr_viewcos + fy2 * gr_viewsin);
; 2426 : 		if (fy1 < 0)
; 2427 : 			// the point is back
; 2428 : 			fx2 = vid.width;
; 2429 : 		else
; 2430 : 			fx2 = gr_windowcenterx + (fx2 * gr_viewsin - fy2 * gr_viewcos) * gr_centerx / fy1;
; 2431 : 
; 2432 : 		x1 = fx1+0.5f;
; 2433 : 		x2 = fx2+0.5f;
; 2434 : 	}
; 2435 : #else
; 2436 : 	// The seg is in the view range,
; 2437 : 	// but not necessarily visible.
; 2438 : 	angle1 = (angle1+ANGLE_90)>>ANGLETOFINESHIFT;

  00155	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  00158	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  0015d	c1 e8 13	 shr	 eax, 19			; 00000013H
  00160	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax

; 2439 : 	angle2 = (angle2+ANGLE_90)>>ANGLETOFINESHIFT;

  00163	8b 45 f0	 mov	 eax, DWORD PTR _angle2$[ebp]
  00166	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  0016b	c1 e8 13	 shr	 eax, 19			; 00000013H
  0016e	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax

; 2440 : 
; 2441 : 	x1 = gr_viewangletox[angle1];

  00171	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  00174	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _gr_viewangletox[eax*4]
  0017b	89 4d fc	 mov	 DWORD PTR _x1$[ebp], ecx

; 2442 : 	x2 = gr_viewangletox[angle2];

  0017e	8b 45 f0	 mov	 eax, DWORD PTR _angle2$[ebp]
  00181	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _gr_viewangletox[eax*4]
  00188	89 4d f8	 mov	 DWORD PTR _x2$[ebp], ecx

; 2443 : #endif
; 2444 : 	// Does not cross a pixel?
; 2445 : //    if (x1 == x2)
; 2446 : /*    {
; 2447 : 		// BP: HERE IS THE MAIN PROBLEM !
; 2448 : 		//CONS_Printf("tineline\n");
; 2449 : 		return;
; 2450 : 	}
; 2451 : */
; 2452 : 	gr_backsector = line->backsector;

  0018b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0018e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00191	89 0d 00 00 00
	00		 mov	 DWORD PTR _gr_backsector, ecx

; 2453 : 
; 2454 : 	// Single sided line?
; 2455 : 	if (!gr_backsector)

  00197	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_backsector, 0
  0019e	75 05		 jne	 SHORT $LN8@HWR_AddLin

; 2456 : 		goto clipsolid;

  001a0	e9 11 01 00 00	 jmp	 $clipsolid$17
$LN8@HWR_AddLin:

; 2457 : 
; 2458 : 	gr_backsector = R_FakeFlat(gr_backsector, &tempsec, NULL, NULL, true);

  001a5	6a 01		 push	 1
  001a7	6a 00		 push	 0
  001a9	6a 00		 push	 0
  001ab	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _tempsec$[ebp]
  001b1	50		 push	 eax
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_backsector
  001b8	51		 push	 ecx
  001b9	e8 00 00 00 00	 call	 _R_FakeFlat
  001be	83 c4 14	 add	 esp, 20			; 00000014H
  001c1	a3 00 00 00 00	 mov	 DWORD PTR _gr_backsector, eax

; 2459 : 
; 2460 : 	// Closed door.
; 2461 : 	if (gr_backsector->ceilingheight <= gr_frontsector->floorheight ||

  001c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  001d1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001d4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001d6	7e 12		 jle	 SHORT $LN10@HWR_AddLin
  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  001e3	8b 10		 mov	 edx, DWORD PTR [eax]
  001e5	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001e8	7c 05		 jl	 SHORT $LN9@HWR_AddLin
$LN10@HWR_AddLin:

; 2462 : 	    gr_backsector->floorheight >= gr_frontsector->ceilingheight)
; 2463 : 		goto clipsolid;

  001ea	e9 c7 00 00 00	 jmp	 $clipsolid$17
$LN9@HWR_AddLin:

; 2464 : 
; 2465 : 	// Window.
; 2466 : 	if (gr_backsector->ceilingheight != gr_frontsector->ceilingheight ||

  001ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  001f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  001fa	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001fd	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00200	75 11		 jne	 SHORT $LN12@HWR_AddLin
  00202	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00207	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  0020d	8b 10		 mov	 edx, DWORD PTR [eax]
  0020f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00211	74 02		 je	 SHORT $LN11@HWR_AddLin
$LN12@HWR_AddLin:

; 2467 : 	    gr_backsector->floorheight != gr_frontsector->floorheight)
; 2468 : 		goto clippass;

  00213	eb 72		 jmp	 SHORT $clippass$18
$LN11@HWR_AddLin:

; 2469 : 
; 2470 : 	// Reject empty lines used for triggers and special events.
; 2471 : 	// Identical floor and ceiling on both sides,
; 2472 : 	//  identical light levels on both sides,
; 2473 : 	//  and no middle texture.
; 2474 : 	if (
; 2475 : #ifdef POLYOBJECTS
; 2476 : 	    !line->polyseg
; 2477 : #endif
; 2478 : 	    && gr_backsector->ceilingpic == gr_frontsector->ceilingpic
; 2479 : 	    && gr_backsector->floorpic == gr_frontsector->floorpic
; 2480 : 	    && gr_backsector->lightlevel == gr_frontsector->lightlevel
; 2481 : 	    && gr_curline->sidedef->midtexture == 0
; 2482 : 	    && !gr_backsector->ffloors && !gr_frontsector->ffloors)

  00215	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00218	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0021c	75 69		 jne	 SHORT $clippass$18
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  00229	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0022c	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0022f	75 56		 jne	 SHORT $clippass$18
  00231	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_frontsector
  0023c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0023f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00242	75 43		 jne	 SHORT $clippass$18
  00244	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00249	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0024d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  00253	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00257	3b c8		 cmp	 ecx, eax
  00259	75 2c		 jne	 SHORT $clippass$18
  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00260	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00263	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00267	75 1e		 jne	 SHORT $clippass$18
  00269	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  0026e	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00275	75 10		 jne	 SHORT $clippass$18
  00277	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0027c	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00283	75 02		 jne	 SHORT $clippass$18

; 2483 : 		// SoM: For 3D sides... Boris, would you like to take a
; 2484 : 		// crack at rendering 3D sides? You would need to add the
; 2485 : 		// above check and add code to HWR_StoreWallRange...
; 2486 : 	{
; 2487 : 		return;

  00285	eb 4c		 jmp	 SHORT $LN1@HWR_AddLin
$clippass$18:

; 2488 : 	}
; 2489 : 
; 2490 : clippass:
; 2491 : 	if (x1 == x2)

  00287	8b 45 fc	 mov	 eax, DWORD PTR _x1$[ebp]
  0028a	3b 45 f8	 cmp	 eax, DWORD PTR _x2$[ebp]
  0028d	75 12		 jne	 SHORT $LN14@HWR_AddLin

; 2492 : 		{  x2++;x1 -= 2; }

  0028f	8b 45 f8	 mov	 eax, DWORD PTR _x2$[ebp]
  00292	83 c0 01	 add	 eax, 1
  00295	89 45 f8	 mov	 DWORD PTR _x2$[ebp], eax
  00298	8b 45 fc	 mov	 eax, DWORD PTR _x1$[ebp]
  0029b	83 e8 02	 sub	 eax, 2
  0029e	89 45 fc	 mov	 DWORD PTR _x1$[ebp], eax
$LN14@HWR_AddLin:

; 2493 : 	HWR_ClipPassWallSegment(x1, x2-1);

  002a1	8b 45 f8	 mov	 eax, DWORD PTR _x2$[ebp]
  002a4	83 e8 01	 sub	 eax, 1
  002a7	50		 push	 eax
  002a8	8b 4d fc	 mov	 ecx, DWORD PTR _x1$[ebp]
  002ab	51		 push	 ecx
  002ac	e8 00 00 00 00	 call	 _HWR_ClipPassWallSegment
  002b1	83 c4 08	 add	 esp, 8

; 2494 : 	return;

  002b4	eb 1d		 jmp	 SHORT $LN1@HWR_AddLin
$clipsolid$17:

; 2495 : 
; 2496 : clipsolid:
; 2497 : 	if (x1 == x2)

  002b6	8b 45 fc	 mov	 eax, DWORD PTR _x1$[ebp]
  002b9	3b 45 f8	 cmp	 eax, DWORD PTR _x2$[ebp]
  002bc	75 02		 jne	 SHORT $LN15@HWR_AddLin

; 2498 : 		goto clippass;

  002be	eb c7		 jmp	 SHORT $clippass$18
$LN15@HWR_AddLin:

; 2499 : 	HWR_ClipSolidWallSegment(x1, x2-1);

  002c0	8b 45 f8	 mov	 eax, DWORD PTR _x2$[ebp]
  002c3	83 e8 01	 sub	 eax, 1
  002c6	50		 push	 eax
  002c7	8b 4d fc	 mov	 ecx, DWORD PTR _x1$[ebp]
  002ca	51		 push	 ecx
  002cb	e8 00 00 00 00	 call	 _HWR_ClipSolidWallSegment
  002d0	83 c4 08	 add	 esp, 8
$LN1@HWR_AddLin:

; 2500 : }

  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx
  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c3		 ret	 0
_HWR_AddLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClearClipSegs
_TEXT	SEGMENT
_HWR_ClearClipSegs PROC					; COMDAT

; 2341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2342 : 	gr_solidsegs[0].first = -0x7fffffff;

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	c7 81 00 00 00
	00 01 00 00 80	 mov	 DWORD PTR _gr_solidsegs[ecx], -2147483647 ; 80000001H

; 2343 : 	gr_solidsegs[0].last = -1;

  0001b	b8 08 00 00 00	 mov	 eax, 8
  00020	6b c8 00	 imul	 ecx, eax, 0
  00023	c7 81 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _gr_solidsegs[ecx+4], -1

; 2344 : 	gr_solidsegs[1].first = vid.width; //viewwidth;

  0002d	b8 08 00 00 00	 mov	 eax, 8
  00032	c1 e0 00	 shl	 eax, 0
  00035	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0003b	89 88 00 00 00
	00		 mov	 DWORD PTR _gr_solidsegs[eax], ecx

; 2345 : 	gr_solidsegs[1].last = 0x7fffffff;

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	c1 e0 00	 shl	 eax, 0
  00049	c7 80 04 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR _gr_solidsegs[eax+4], 2147483647 ; 7fffffffH

; 2346 : 	hw_newend = gr_solidsegs+2;

  00053	c7 05 00 00 00
	00 10 00 00 00	 mov	 DWORD PTR _hw_newend, OFFSET _gr_solidsegs+16

; 2347 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_HWR_ClearClipSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClipToSolidSegs
_TEXT	SEGMENT
_start$ = -4						; size = 4
_first$ = 8						; size = 4
_last$ = 12						; size = 4
_HWR_ClipToSolidSegs PROC				; COMDAT

; 2318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2319 : 	cliprange_t * start;
; 2320 : 
; 2321 : 	// Find the first range that touches the range
; 2322 : 	//  (adjacent pixels are touching).
; 2323 : 	start = gr_solidsegs;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _gr_solidsegs
$LN2@HWR_ClipTo:

; 2324 : 	while (start->last < first-1)

  00010	8b 45 08	 mov	 eax, DWORD PTR _first$[ebp]
  00013	83 e8 01	 sub	 eax, 1
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _start$[ebp]
  00019	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  0001c	7d 0b		 jge	 SHORT $LN3@HWR_ClipTo

; 2325 : 		start++;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax
  00027	eb e7		 jmp	 SHORT $LN2@HWR_ClipTo
$LN3@HWR_ClipTo:

; 2326 : 
; 2327 : 	if (first < start->first)

  00029	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  0002f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00031	7d 07		 jge	 SHORT $LN4@HWR_ClipTo

; 2328 : 		return true;

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	eb 14		 jmp	 SHORT $LN1@HWR_ClipTo
$LN4@HWR_ClipTo:

; 2329 : 
; 2330 : 	// Bottom contained in start?
; 2331 : 	if (last <= start->last)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00040	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00043	7f 04		 jg	 SHORT $LN5@HWR_ClipTo

; 2332 : 		return false;

  00045	33 c0		 xor	 eax, eax
  00047	eb 05		 jmp	 SHORT $LN1@HWR_ClipTo
$LN5@HWR_ClipTo:

; 2333 : 
; 2334 : 	return true;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN1@HWR_ClipTo:

; 2335 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_HWR_ClipToSolidSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClipPassWallSegment
_TEXT	SEGMENT
tv91 = -84						; size = 4
tv150 = -84						; size = 4
tv168 = -84						; size = 4
tv202 = -84						; size = 4
_poorhack$ = -16					; size = 4
_highfrac$ = -12					; size = 4
_lowfrac$ = -8						; size = 4
_start$ = -4						; size = 4
_first$ = 8						; size = 4
_last$ = 12						; size = 4
_HWR_ClipPassWallSegment PROC				; COMDAT

; 2226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2227 : 	cliprange_t *start;
; 2228 : 	float lowfrac, highfrac;
; 2229 : 	//to allow noclipwalls but still solidseg reject of non-visible walls
; 2230 : 	boolean poorhack = false;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 0

; 2231 : 
; 2232 : 	// Find the first range that touches the range
; 2233 : 	//  (adjacent pixels are touching).
; 2234 : 	start = gr_solidsegs;

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _gr_solidsegs
$LN2@HWR_ClipPa:

; 2235 : 	while (start->last < first - 1)

  00017	8b 45 08	 mov	 eax, DWORD PTR _first$[ebp]
  0001a	83 e8 01	 sub	 eax, 1
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _start$[ebp]
  00020	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00023	7d 0b		 jge	 SHORT $LN3@HWR_ClipPa

; 2236 : 		start++;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00028	83 c0 08	 add	 eax, 8
  0002b	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax
  0002e	eb e7		 jmp	 SHORT $LN2@HWR_ClipPa
$LN3@HWR_ClipPa:

; 2237 : 
; 2238 : 	if (first < start->first)

  00030	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  00036	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00038	0f 8d d7 00 00
	00		 jge	 $LN9@HWR_ClipPa

; 2239 : 	{
; 2240 : 		if (last < start->first-1)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	83 e9 01	 sub	 ecx, 1
  00046	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00049	7d 28		 jge	 SHORT $LN7@HWR_ClipPa

; 2241 : 		{
; 2242 : 			// Post is entirely visible (above start).
; 2243 : 			HWR_StoreWallRange(0, 1);

  0004b	83 ec 08	 sub	 esp, 8
  0004e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00056	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0005b	83 ec 08	 sub	 esp, 8
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00066	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 2244 : 			return;

  0006e	e9 e9 02 00 00	 jmp	 $LN22@HWR_ClipPa
$LN7@HWR_ClipPa:

; 2245 : 		}
; 2246 : 
; 2247 : 		// There is a fragment above *start.
; 2248 : 		if (!cv_grclipwalls.value)

  00073	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  0007a	75 32		 jne	 SHORT $LN8@HWR_ClipPa

; 2249 : 		{	//20/08/99: Changed by Hurdler (taken from faB's code)
; 2250 : 			if (!poorhack) HWR_StoreWallRange(0, 1);

  0007c	83 7d f0 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  00080	75 23		 jne	 SHORT $LN10@HWR_ClipPa
  00082	83 ec 08	 sub	 esp, 8
  00085	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0008d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00092	83 ec 08	 sub	 esp, 8
  00095	0f 57 c0	 xorps	 xmm0, xmm0
  00098	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0009d	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  000a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@HWR_ClipPa:

; 2251 : 			poorhack = true;

  000a5	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2252 : 		}

  000ac	eb 67		 jmp	 SHORT $LN9@HWR_ClipPa
$LN8@HWR_ClipPa:

; 2253 : 		else
; 2254 : 		{
; 2255 : 			highfrac = HWR_ClipViewSegment(min(start->first + 1,

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  000b9	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  000bc	7d 0d		 jge	 SHORT $LN25@HWR_ClipPa
  000be	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	83 c1 01	 add	 ecx, 1
  000c6	89 4d ac	 mov	 DWORD PTR tv91[ebp], ecx
  000c9	eb 09		 jmp	 SHORT $LN26@HWR_ClipPa
$LN25@HWR_ClipPa:
  000cb	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  000ce	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d1	89 45 ac	 mov	 DWORD PTR tv91[ebp], eax
$LN26@HWR_ClipPa:
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_curline
  000da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000dd	52		 push	 edx
  000de	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	51		 push	 ecx
  000e6	8b 55 ac	 mov	 edx, DWORD PTR tv91[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	d9 5d f4	 fstp	 DWORD PTR _highfrac$[ebp]

; 2256 : 				start->last), (polyvertex_t *)gr_curline->v1,
; 2257 : 				(polyvertex_t *)gr_curline->v2);
; 2258 : 			HWR_StoreWallRange(0, highfrac);

  000f5	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _highfrac$[ebp]
  000fa	83 ec 08	 sub	 esp, 8
  000fd	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00102	83 ec 08	 sub	 esp, 8
  00105	0f 57 c0	 xorps	 xmm0, xmm0
  00108	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0010d	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  00112	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@HWR_ClipPa:

; 2259 : 		}
; 2260 : 	}
; 2261 : 
; 2262 : 	// Bottom contained in start?
; 2263 : 	if (last <= start->last)

  00115	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00118	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  0011b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0011e	7f 05		 jg	 SHORT $LN11@HWR_ClipPa

; 2264 : 		return;

  00120	e9 37 02 00 00	 jmp	 $LN22@HWR_ClipPa
$LN11@HWR_ClipPa:

; 2265 : 
; 2266 : 	while (last >= (start+1)->first-1)

  00125	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00128	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012b	83 e9 01	 sub	 ecx, 1
  0012e	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00131	0f 8c 0e 01 00
	00		 jl	 $LN5@HWR_ClipPa

; 2267 : 	{
; 2268 : 		// There is a fragment between two posts.
; 2269 : 		if (!cv_grclipwalls.value)

  00137	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  0013e	75 35		 jne	 SHORT $LN12@HWR_ClipPa

; 2270 : 		{
; 2271 : 			if (!poorhack) HWR_StoreWallRange(0, 1);

  00140	83 7d f0 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  00144	75 23		 jne	 SHORT $LN14@HWR_ClipPa
  00146	83 ec 08	 sub	 esp, 8
  00149	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00151	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00156	83 ec 08	 sub	 esp, 8
  00159	0f 57 c0	 xorps	 xmm0, xmm0
  0015c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00161	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  00166	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@HWR_ClipPa:

; 2272 : 			poorhack = true;

  00169	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2273 : 		}

  00170	e9 b2 00 00 00	 jmp	 $LN13@HWR_ClipPa
$LN12@HWR_ClipPa:

; 2274 : 		else
; 2275 : 		{
; 2276 : 			lowfrac  = HWR_ClipViewSegment(max(start->last-1,start->first), (polyvertex_t *)gr_curline->v1, (polyvertex_t *)gr_curline->v2);

  00175	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00178	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0017b	83 e9 01	 sub	 ecx, 1
  0017e	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  00181	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00183	7e 0e		 jle	 SHORT $LN27@HWR_ClipPa
  00185	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00188	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018b	83 e9 01	 sub	 ecx, 1
  0018e	89 4d ac	 mov	 DWORD PTR tv150[ebp], ecx
  00191	eb 08		 jmp	 SHORT $LN28@HWR_ClipPa
$LN27@HWR_ClipPa:
  00193	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  00196	8b 02		 mov	 eax, DWORD PTR [edx]
  00198	89 45 ac	 mov	 DWORD PTR tv150[ebp], eax
$LN28@HWR_ClipPa:
  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_curline
  001a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a4	52		 push	 edx
  001a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  001aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ac	51		 push	 ecx
  001ad	8b 55 ac	 mov	 edx, DWORD PTR tv150[ebp]
  001b0	52		 push	 edx
  001b1	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b9	d9 5d f8	 fstp	 DWORD PTR _lowfrac$[ebp]

; 2277 : 			highfrac = HWR_ClipViewSegment(min((start+1)->first+1,(start+1)->last), (polyvertex_t *)gr_curline->v1, (polyvertex_t *)gr_curline->v2);

  001bc	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  001bf	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001c2	83 c1 01	 add	 ecx, 1
  001c5	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  001c8	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  001cb	7d 0e		 jge	 SHORT $LN29@HWR_ClipPa
  001cd	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  001d0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d3	83 c1 01	 add	 ecx, 1
  001d6	89 4d ac	 mov	 DWORD PTR tv168[ebp], ecx
  001d9	eb 09		 jmp	 SHORT $LN30@HWR_ClipPa
$LN29@HWR_ClipPa:
  001db	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  001de	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001e1	89 45 ac	 mov	 DWORD PTR tv168[ebp], eax
$LN30@HWR_ClipPa:
  001e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_curline
  001ea	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ed	52		 push	 edx
  001ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  001f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f5	51		 push	 ecx
  001f6	8b 55 ac	 mov	 edx, DWORD PTR tv168[ebp]
  001f9	52		 push	 edx
  001fa	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  001ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00202	d9 5d f4	 fstp	 DWORD PTR _highfrac$[ebp]

; 2278 : 			HWR_StoreWallRange(lowfrac, highfrac);

  00205	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _highfrac$[ebp]
  0020a	83 ec 08	 sub	 esp, 8
  0020d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00212	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _lowfrac$[ebp]
  00217	83 ec 08	 sub	 esp, 8
  0021a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0021f	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  00224	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@HWR_ClipPa:

; 2279 : 		}
; 2280 : 		start++;

  00227	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0022a	83 c0 08	 add	 eax, 8
  0022d	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax

; 2281 : 
; 2282 : 		if (last <= start->last)

  00230	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00233	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00236	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00239	7f 05		 jg	 SHORT $LN15@HWR_ClipPa

; 2283 : 			return;

  0023b	e9 1c 01 00 00	 jmp	 $LN22@HWR_ClipPa
$LN15@HWR_ClipPa:

; 2284 : 	}

  00240	e9 e0 fe ff ff	 jmp	 $LN11@HWR_ClipPa
$LN5@HWR_ClipPa:

; 2285 : 
; 2286 : 	if (first == start->first+1) // 1 line texture

  00245	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00248	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024a	83 c1 01	 add	 ecx, 1
  0024d	39 4d 08	 cmp	 DWORD PTR _first$[ebp], ecx
  00250	75 63		 jne	 SHORT $LN16@HWR_ClipPa

; 2287 : 	{
; 2288 : 		if (!cv_grclipwalls.value)

  00252	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  00259	75 32		 jne	 SHORT $LN18@HWR_ClipPa

; 2289 : 		{
; 2290 : 			if (!poorhack) HWR_StoreWallRange(0, 1);

  0025b	83 7d f0 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  0025f	75 23		 jne	 SHORT $LN20@HWR_ClipPa
  00261	83 ec 08	 sub	 esp, 8
  00264	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0026c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00271	83 ec 08	 sub	 esp, 8
  00274	0f 57 c0	 xorps	 xmm0, xmm0
  00277	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0027c	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  00281	83 c4 10	 add	 esp, 16			; 00000010H
$LN20@HWR_ClipPa:

; 2291 : 			poorhack = true;

  00284	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2292 : 		}

  0028b	eb 23		 jmp	 SHORT $LN19@HWR_ClipPa
$LN18@HWR_ClipPa:

; 2293 : 		else
; 2294 : 			HWR_StoreWallRange(0, 1);

  0028d	83 ec 08	 sub	 esp, 8
  00290	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00298	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0029d	83 ec 08	 sub	 esp, 8
  002a0	0f 57 c0	 xorps	 xmm0, xmm0
  002a3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002a8	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  002ad	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@HWR_ClipPa:

; 2295 : 	}

  002b0	e9 a7 00 00 00	 jmp	 $LN22@HWR_ClipPa
$LN16@HWR_ClipPa:

; 2296 : 	else
; 2297 : 	{
; 2298 : 		// There is a fragment after *next.
; 2299 : 		if (!cv_grclipwalls.value)

  002b5	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  002bc	75 32		 jne	 SHORT $LN21@HWR_ClipPa

; 2300 : 		{
; 2301 : 			if (!poorhack) HWR_StoreWallRange(0,1);

  002be	83 7d f0 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  002c2	75 23		 jne	 SHORT $LN23@HWR_ClipPa
  002c4	83 ec 08	 sub	 esp, 8
  002c7	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  002cf	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002d4	83 ec 08	 sub	 esp, 8
  002d7	0f 57 c0	 xorps	 xmm0, xmm0
  002da	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002df	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  002e4	83 c4 10	 add	 esp, 16			; 00000010H
$LN23@HWR_ClipPa:

; 2302 : 			poorhack = true;

  002e7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2303 : 		}

  002ee	eb 6c		 jmp	 SHORT $LN22@HWR_ClipPa
$LN21@HWR_ClipPa:

; 2304 : 		else
; 2305 : 		{
; 2306 : 			lowfrac = HWR_ClipViewSegment(max(start->last - 1,

  002f0	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  002f3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002f6	83 e9 01	 sub	 ecx, 1
  002f9	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  002fc	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  002fe	7e 0e		 jle	 SHORT $LN31@HWR_ClipPa
  00300	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00303	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00306	83 e9 01	 sub	 ecx, 1
  00309	89 4d ac	 mov	 DWORD PTR tv202[ebp], ecx
  0030c	eb 08		 jmp	 SHORT $LN32@HWR_ClipPa
$LN31@HWR_ClipPa:
  0030e	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  00311	8b 02		 mov	 eax, DWORD PTR [edx]
  00313	89 45 ac	 mov	 DWORD PTR tv202[ebp], eax
$LN32@HWR_ClipPa:
  00316	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_curline
  0031c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0031f	52		 push	 edx
  00320	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00325	8b 08		 mov	 ecx, DWORD PTR [eax]
  00327	51		 push	 ecx
  00328	8b 55 ac	 mov	 edx, DWORD PTR tv202[ebp]
  0032b	52		 push	 edx
  0032c	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  00331	83 c4 0c	 add	 esp, 12			; 0000000cH
  00334	d9 5d f8	 fstp	 DWORD PTR _lowfrac$[ebp]

; 2307 : 				start->first), (polyvertex_t *)gr_curline->v1,
; 2308 : 				(polyvertex_t *)gr_curline->v2);
; 2309 : 			HWR_StoreWallRange(lowfrac, 1);

  00337	83 ec 08	 sub	 esp, 8
  0033a	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00342	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00347	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _lowfrac$[ebp]
  0034c	83 ec 08	 sub	 esp, 8
  0034f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00354	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  00359	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@HWR_ClipPa:

; 2310 : 		}
; 2311 : 	}
; 2312 : }

  0035c	5f		 pop	 edi
  0035d	5e		 pop	 esi
  0035e	5b		 pop	 ebx
  0035f	8b e5		 mov	 esp, ebp
  00361	5d		 pop	 ebp
  00362	c3		 ret	 0
_HWR_ClipPassWallSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClipSolidWallSegment
_TEXT	SEGMENT
tv205 = -92						; size = 4
tv204 = -88						; size = 4
_poorhack$ = -20					; size = 4
_highfrac$ = -16					; size = 4
_lowfrac$ = -12						; size = 4
_start$ = -8						; size = 4
_next$ = -4						; size = 4
_first$ = 8						; size = 4
_last$ = 12						; size = 4
_HWR_ClipSolidWallSegment PROC				; COMDAT

; 2092 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2093 : 	cliprange_t *next, *start;
; 2094 : 	float lowfrac, highfrac;
; 2095 : 	boolean poorhack = false;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 0

; 2096 : 
; 2097 : 	// Find the first range that touches the range
; 2098 : 	//  (adjacent pixels are touching).
; 2099 : 	start = gr_solidsegs;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _gr_solidsegs
$LN2@HWR_ClipSo:

; 2100 : 	while (start->last < first-1)

  00017	8b 45 08	 mov	 eax, DWORD PTR _first$[ebp]
  0001a	83 e8 01	 sub	 eax, 1
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _start$[ebp]
  00020	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00023	7d 0b		 jge	 SHORT $LN3@HWR_ClipSo

; 2101 : 		start++;

  00025	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00028	83 c0 08	 add	 eax, 8
  0002b	89 45 f8	 mov	 DWORD PTR _start$[ebp], eax
  0002e	eb e7		 jmp	 SHORT $LN2@HWR_ClipSo
$LN3@HWR_ClipSo:

; 2102 : 
; 2103 : 	if (first < start->first)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  00036	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00038	0f 8d 0c 01 00
	00		 jge	 $LN10@HWR_ClipSo

; 2104 : 	{
; 2105 : 		if (last < start->first-1)

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	83 e9 01	 sub	 ecx, 1
  00046	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00049	7d 77		 jge	 SHORT $LN11@HWR_ClipSo

; 2106 : 		{
; 2107 : 			// Post is entirely visible (above start),
; 2108 : 			//  so insert a new clippost.
; 2109 : 			HWR_StoreWallRange(first, last);

  0004b	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _last$[ebp]
  00050	83 ec 08	 sub	 esp, 8
  00053	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00058	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _first$[ebp]
  0005d	83 ec 08	 sub	 esp, 8
  00060	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00065	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  0006a	83 c4 10	 add	 esp, 16			; 00000010H

; 2110 : 
; 2111 : 			next = hw_newend;

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hw_newend
  00072	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 2112 : 			hw_newend++;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _hw_newend
  0007a	83 c0 08	 add	 eax, 8
  0007d	a3 00 00 00 00	 mov	 DWORD PTR _hw_newend, eax
$LN4@HWR_ClipSo:

; 2113 : 
; 2114 : 			while (next != start)

  00082	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00085	3b 45 f8	 cmp	 eax, DWORD PTR _start$[ebp]
  00088	74 1c		 je	 SHORT $LN5@HWR_ClipSo

; 2115 : 			{
; 2116 : 				*next = *(next-1);

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0008d	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00090	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00093	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00096	89 08		 mov	 DWORD PTR [eax], ecx
  00098	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2117 : 				next--;

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0009e	83 e8 08	 sub	 eax, 8
  000a1	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 2118 : 			}

  000a4	eb dc		 jmp	 SHORT $LN4@HWR_ClipSo
$LN5@HWR_ClipSo:

; 2119 : 
; 2120 : 			next->first = first;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  000ac	89 08		 mov	 DWORD PTR [eax], ecx

; 2121 : 			next->last = last;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000b1	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  000b4	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2122 : 			printsolidsegs();

  000b7	e8 00 00 00 00	 call	 _printsolidsegs
  000bc	90		 npad	 1

; 2123 : 			return;

  000bd	e9 e1 02 00 00	 jmp	 $LN1@HWR_ClipSo
$LN11@HWR_ClipSo:

; 2124 : 		}
; 2125 : 
; 2126 : 		// There is a fragment above *start.
; 2127 : 		if (!cv_grclipwalls.value)

  000c2	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  000c9	75 31		 jne	 SHORT $LN12@HWR_ClipSo

; 2128 : 		{
; 2129 : 			if (!poorhack) HWR_StoreWallRange(first, last);

  000cb	83 7d ec 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  000cf	75 22		 jne	 SHORT $LN14@HWR_ClipSo
  000d1	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _last$[ebp]
  000d6	83 ec 08	 sub	 esp, 8
  000d9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000de	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _first$[ebp]
  000e3	83 ec 08	 sub	 esp, 8
  000e6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000eb	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  000f0	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@HWR_ClipSo:

; 2130 : 			poorhack = true;

  000f3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2131 : 		}

  000fa	eb 46		 jmp	 SHORT $LN13@HWR_ClipSo
$LN12@HWR_ClipSo:

; 2132 : 		else
; 2133 : 		{
; 2134 : 			highfrac = HWR_ClipViewSegment(start->first+1, (polyvertex_t *)gr_curline->v1, (polyvertex_t *)gr_curline->v2);

  000fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00101	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00104	51		 push	 ecx
  00105	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_curline
  0010b	8b 02		 mov	 eax, DWORD PTR [edx]
  0010d	50		 push	 eax
  0010e	8b 4d f8	 mov	 ecx, DWORD PTR _start$[ebp]
  00111	8b 11		 mov	 edx, DWORD PTR [ecx]
  00113	83 c2 01	 add	 edx, 1
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	d9 5d f0	 fstp	 DWORD PTR _highfrac$[ebp]

; 2135 : 			HWR_StoreWallRange(0, highfrac);

  00122	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _highfrac$[ebp]
  00127	83 ec 08	 sub	 esp, 8
  0012a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0012f	83 ec 08	 sub	 esp, 8
  00132	0f 57 c0	 xorps	 xmm0, xmm0
  00135	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0013a	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  0013f	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@HWR_ClipSo:

; 2136 : 		}
; 2137 : 		// Now adjust the clip size.
; 2138 : 		start->first = first;

  00142	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  00148	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@HWR_ClipSo:

; 2139 : 	}
; 2140 : 
; 2141 : 	// Bottom contained in start?
; 2142 : 	if (last <= start->last)

  0014a	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  0014d	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00150	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00153	7f 0b		 jg	 SHORT $LN15@HWR_ClipSo

; 2143 : 	{
; 2144 : 		printsolidsegs();

  00155	e8 00 00 00 00	 call	 _printsolidsegs
  0015a	90		 npad	 1

; 2145 : 		return;

  0015b	e9 43 02 00 00	 jmp	 $LN1@HWR_ClipSo
$LN15@HWR_ClipSo:

; 2146 : 	}
; 2147 : 	next = start;

  00160	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00163	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
$LN6@HWR_ClipSo:

; 2148 : 	while (last >= (next+1)->first-1)

  00166	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00169	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0016c	83 e9 01	 sub	 ecx, 1
  0016f	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00172	0f 8c d4 00 00
	00		 jl	 $LN7@HWR_ClipSo

; 2149 : 	{
; 2150 : 		// There is a fragment between two posts.
; 2151 : 		if (!cv_grclipwalls.value)

  00178	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  0017f	75 31		 jne	 SHORT $LN16@HWR_ClipSo

; 2152 : 		{
; 2153 : 			if (!poorhack) HWR_StoreWallRange(first,last);

  00181	83 7d ec 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  00185	75 22		 jne	 SHORT $LN18@HWR_ClipSo
  00187	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _last$[ebp]
  0018c	83 ec 08	 sub	 esp, 8
  0018f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00194	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _first$[ebp]
  00199	83 ec 08	 sub	 esp, 8
  0019c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001a1	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  001a6	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@HWR_ClipSo:

; 2154 : 			poorhack = true;

  001a9	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2155 : 		}

  001b0	eb 70		 jmp	 SHORT $LN17@HWR_ClipSo
$LN16@HWR_ClipSo:

; 2156 : 		else
; 2157 : 		{
; 2158 : 			lowfrac  = HWR_ClipViewSegment(next->last-1, (polyvertex_t *)gr_curline->v1, (polyvertex_t *)gr_curline->v2);

  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  001b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ba	51		 push	 ecx
  001bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_curline
  001c1	8b 02		 mov	 eax, DWORD PTR [edx]
  001c3	50		 push	 eax
  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  001c7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ca	83 ea 01	 sub	 edx, 1
  001cd	52		 push	 edx
  001ce	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d6	d9 5d f4	 fstp	 DWORD PTR _lowfrac$[ebp]

; 2159 : 			highfrac = HWR_ClipViewSegment((next+1)->first+1, (polyvertex_t *)gr_curline->v1, (polyvertex_t *)gr_curline->v2);

  001d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  001de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e1	51		 push	 ecx
  001e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_curline
  001e8	8b 02		 mov	 eax, DWORD PTR [edx]
  001ea	50		 push	 eax
  001eb	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  001ee	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001f1	83 c2 01	 add	 edx, 1
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fd	d9 5d f0	 fstp	 DWORD PTR _highfrac$[ebp]

; 2160 : 			HWR_StoreWallRange(lowfrac, highfrac);

  00200	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _highfrac$[ebp]
  00205	83 ec 08	 sub	 esp, 8
  00208	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0020d	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _lowfrac$[ebp]
  00212	83 ec 08	 sub	 esp, 8
  00215	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0021a	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  0021f	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@HWR_ClipSo:

; 2161 : 		}
; 2162 : 		next++;

  00222	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00225	83 c0 08	 add	 eax, 8
  00228	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 2163 : 
; 2164 : 		if (last <= next->last)

  0022b	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0022e	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00231	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00234	7f 11		 jg	 SHORT $LN19@HWR_ClipSo

; 2165 : 		{
; 2166 : 			// Bottom is contained in next.
; 2167 : 			// Adjust the clip size.
; 2168 : 			start->last = next->last;

  00236	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00239	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  0023c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0023f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2169 : 			goto crunch;

  00242	e9 03 01 00 00	 jmp	 $crunch$30
$LN19@HWR_ClipSo:

; 2170 : 		}
; 2171 : 	}

  00247	e9 1a ff ff ff	 jmp	 $LN6@HWR_ClipSo
$LN7@HWR_ClipSo:

; 2172 : 
; 2173 : 	if (first == next->first+1) // 1 line texture

  0024c	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0024f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00251	83 c1 01	 add	 ecx, 1
  00254	39 4d 08	 cmp	 DWORD PTR _first$[ebp], ecx
  00257	75 62		 jne	 SHORT $LN20@HWR_ClipSo

; 2174 : 	{
; 2175 : 		if (!cv_grclipwalls.value)

  00259	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  00260	75 31		 jne	 SHORT $LN22@HWR_ClipSo

; 2176 : 		{
; 2177 : 			if (!poorhack) HWR_StoreWallRange(first,last);

  00262	83 7d ec 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  00266	75 22		 jne	 SHORT $LN24@HWR_ClipSo
  00268	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _last$[ebp]
  0026d	83 ec 08	 sub	 esp, 8
  00270	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00275	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _first$[ebp]
  0027a	83 ec 08	 sub	 esp, 8
  0027d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00282	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  00287	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@HWR_ClipSo:

; 2178 : 			poorhack = true;

  0028a	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2179 : 		}

  00291	eb 23		 jmp	 SHORT $LN23@HWR_ClipSo
$LN22@HWR_ClipSo:

; 2180 : 		else
; 2181 : 			HWR_StoreWallRange(0, 1);

  00293	83 ec 08	 sub	 esp, 8
  00296	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0029e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002a3	83 ec 08	 sub	 esp, 8
  002a6	0f 57 c0	 xorps	 xmm0, xmm0
  002a9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002ae	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  002b3	83 c4 10	 add	 esp, 16			; 00000010H
$LN23@HWR_ClipSo:

; 2182 : 	}

  002b6	e9 86 00 00 00	 jmp	 $LN26@HWR_ClipSo
$LN20@HWR_ClipSo:

; 2183 : 	else
; 2184 : 	{
; 2185 : 	// There is a fragment after *next.
; 2186 : 		if (!cv_grclipwalls.value)

  002bb	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grclipwalls+20, 0
  002c2	75 31		 jne	 SHORT $LN25@HWR_ClipSo

; 2187 : 		{
; 2188 : 			if (!poorhack) HWR_StoreWallRange(first,last);

  002c4	83 7d ec 00	 cmp	 DWORD PTR _poorhack$[ebp], 0
  002c8	75 22		 jne	 SHORT $LN27@HWR_ClipSo
  002ca	f2 0f 2a 45 0c	 cvtsi2sd xmm0, DWORD PTR _last$[ebp]
  002cf	83 ec 08	 sub	 esp, 8
  002d2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002d7	f2 0f 2a 45 08	 cvtsi2sd xmm0, DWORD PTR _first$[ebp]
  002dc	83 ec 08	 sub	 esp, 8
  002df	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002e4	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  002e9	83 c4 10	 add	 esp, 16			; 00000010H
$LN27@HWR_ClipSo:

; 2189 : 			poorhack = true;

  002ec	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _poorhack$[ebp], 1

; 2190 : 		}

  002f3	eb 4c		 jmp	 SHORT $LN26@HWR_ClipSo
$LN25@HWR_ClipSo:

; 2191 : 		else
; 2192 : 		{
; 2193 : 			lowfrac  = HWR_ClipViewSegment(next->last-1, (polyvertex_t *)gr_curline->v1, (polyvertex_t *)gr_curline->v2);

  002f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  002fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002fd	51		 push	 ecx
  002fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_curline
  00304	8b 02		 mov	 eax, DWORD PTR [edx]
  00306	50		 push	 eax
  00307	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  0030a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0030d	83 ea 01	 sub	 edx, 1
  00310	52		 push	 edx
  00311	e8 00 00 00 00	 call	 _HWR_ClipViewSegment
  00316	83 c4 0c	 add	 esp, 12			; 0000000cH
  00319	d9 5d f4	 fstp	 DWORD PTR _lowfrac$[ebp]

; 2194 : 			HWR_StoreWallRange(lowfrac, 1);

  0031c	83 ec 08	 sub	 esp, 8
  0031f	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00327	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0032c	f3 0f 5a 45 f4	 cvtss2sd xmm0, DWORD PTR _lowfrac$[ebp]
  00331	83 ec 08	 sub	 esp, 8
  00334	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00339	e8 00 00 00 00	 call	 _HWR_StoreWallRange
  0033e	83 c4 10	 add	 esp, 16			; 00000010H
$LN26@HWR_ClipSo:

; 2195 : 		}
; 2196 : 	}
; 2197 : 
; 2198 : 	// Adjust the clip size.
; 2199 : 	start->last = last;

  00341	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00344	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00347	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$crunch$30:

; 2200 : 
; 2201 : 	// Remove start+1 to next from the clip list,
; 2202 : 	// because start now covers their area.
; 2203 : crunch:
; 2204 : 	if (next == start)

  0034a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0034d	3b 45 f8	 cmp	 eax, DWORD PTR _start$[ebp]
  00350	75 08		 jne	 SHORT $LN28@HWR_ClipSo

; 2205 : 	{
; 2206 : 		printsolidsegs();

  00352	e8 00 00 00 00	 call	 _printsolidsegs
  00357	90		 npad	 1

; 2207 : 		// Post just extended past the bottom of one post.
; 2208 : 		return;

  00358	eb 49		 jmp	 SHORT $LN1@HWR_ClipSo
$LN28@HWR_ClipSo:

; 2209 : 	}
; 2210 : 
; 2211 : 
; 2212 : 	while (next++ != hw_newend)

  0035a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0035d	89 45 a8	 mov	 DWORD PTR tv204[ebp], eax
  00360	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hw_newend
  00366	89 4d a4	 mov	 DWORD PTR tv205[ebp], ecx
  00369	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0036c	83 c2 08	 add	 edx, 8
  0036f	89 55 fc	 mov	 DWORD PTR _next$[ebp], edx
  00372	8b 45 a8	 mov	 eax, DWORD PTR tv204[ebp]
  00375	3b 45 a4	 cmp	 eax, DWORD PTR tv205[ebp]
  00378	74 1b		 je	 SHORT $LN9@HWR_ClipSo

; 2213 : 	{
; 2214 : 		// Remove a post.
; 2215 : 		*++start = *next;

  0037a	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  0037d	83 c0 08	 add	 eax, 8
  00380	89 45 f8	 mov	 DWORD PTR _start$[ebp], eax
  00383	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00386	8b 11		 mov	 edx, DWORD PTR [ecx]
  00388	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0038b	8b 4d f8	 mov	 ecx, DWORD PTR _start$[ebp]
  0038e	89 11		 mov	 DWORD PTR [ecx], edx
  00390	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2216 : 	}

  00393	eb c5		 jmp	 SHORT $LN28@HWR_ClipSo
$LN9@HWR_ClipSo:

; 2217 : 
; 2218 : 	hw_newend = start;

  00395	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00398	a3 00 00 00 00	 mov	 DWORD PTR _hw_newend, eax

; 2219 : 	printsolidsegs();

  0039d	e8 00 00 00 00	 call	 _printsolidsegs
  003a2	90		 npad	 1
$LN1@HWR_ClipSo:

; 2220 : }

  003a3	5f		 pop	 edi
  003a4	5e		 pop	 esi
  003a5	5b		 pop	 ebx
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
_HWR_ClipSolidWallSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _printsolidsegs
_TEXT	SEGMENT
_start$ = -4						; size = 4
_printsolidsegs PROC					; COMDAT

; 2079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2080 : 	cliprange_t *       start;
; 2081 : 	if (!hw_newend || cv_grbeta.value != 2)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hw_newend, 0
  00010	74 09		 je	 SHORT $LN6@printsolid
  00012	83 3d 14 00 00
	00 02		 cmp	 DWORD PTR _cv_grbeta+20, 2
  00019	74 02		 je	 SHORT $LN5@printsolid
$LN6@printsolid:

; 2082 : 		return;

  0001b	eb 46		 jmp	 SHORT $LN1@printsolid
$LN5@printsolid:

; 2083 : 	for (start = gr_solidsegs;start != hw_newend;start++)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _gr_solidsegs
  00024	eb 09		 jmp	 SHORT $LN4@printsolid
$LN2@printsolid:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax
$LN4@printsolid:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00032	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _hw_newend
  00038	74 1c		 je	 SHORT $LN3@printsolid

; 2084 : 		CONS_Printf("%d-%d|",start->first,start->last);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	51		 push	 ecx
  00041	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_06OJKJKEJ@?$CFd?9?$CFd?$HM@
  0004c	e8 00 00 00 00	 call	 _CONS_Printf
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	eb d0		 jmp	 SHORT $LN2@printsolid
$LN3@printsolid:

; 2085 : 	CONS_Printf("\n\n");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_02PHMGELLB@?6?6@
  0005b	e8 00 00 00 00	 call	 _CONS_Printf
  00060	83 c4 04	 add	 esp, 4
$LN1@printsolid:

; 2086 : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_printsolidsegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_StoreWallRange
_TEXT	SEGMENT
tv537 = -340						; size = 4
tv543 = -340						; size = 4
tv545 = -340						; size = 4
tv547 = -340						; size = 4
tv570 = -340						; size = 4
tv581 = -340						; size = 4
tv589 = -340						; size = 4
tv597 = -340						; size = 4
tv607 = -340						; size = 4
tv617 = -340						; size = 4
tv620 = -340						; size = 4
tv513 = -340						; size = 4
tv705 = -340						; size = 4
tv716 = -340						; size = 4
tv724 = -340						; size = 4
tv732 = -340						; size = 4
tv742 = -340						; size = 4
tv752 = -340						; size = 4
tv791 = -340						; size = 4
tv797 = -340						; size = 4
tv833 = -340						; size = 4
tv843 = -340						; size = 4
tv927 = -340						; size = 4
tv241 = -340						; size = 4
tv252 = -340						; size = 4
tv260 = -340						; size = 4
tv268 = -340						; size = 4
tv278 = -340						; size = 4
tv288 = -340						; size = 4
tv345 = -340						; size = 4
tv356 = -340						; size = 4
tv364 = -340						; size = 4
tv372 = -340						; size = 4
tv382 = -340						; size = 4
tv392 = -340						; size = 4
tv935 = -340						; size = 4
tv943 = -340						; size = 4
tv1007 = -340						; size = 4
tv1088 = -340						; size = 4
tv1098 = -340						; size = 4
tv1159 = -340						; size = 4
tv1182 = -340						; size = 4
tv1190 = -340						; size = 4
tv1198 = -340						; size = 4
tv1262 = -340						; size = 4
tv904 = -340						; size = 4
tv507 = -340						; size = 4
_blendmode$1 = -272					; size = 4
_blendmode$2 = -268					; size = 4
_blendmode$3 = -264					; size = 4
_blendmode$4 = -260					; size = 4
_lowcut$5 = -256					; size = 4
_highcut$6 = -252					; size = 4
_rover$7 = -244						; size = 4
_texturevpeg$8 = -240					; size = 4
_low$9 = -236						; size = 4
_high$10 = -232						; size = 4
_repeats$11 = -228					; size = 4
_texturevpeg$12 = -224					; size = 4
_highcut$13 = -220					; size = 4
_lowcut$14 = -216					; size = 4
_polybottom$15 = -212					; size = 4
_polytop$16 = -208					; size = 4
_popenbottom$17 = -204					; size = 4
_popentop$18 = -200					; size = 4
_back$19 = -196						; size = 4
_front$20 = -192					; size = 4
_blendmode$21 = -188					; size = 4
_texturevpegbottom$22 = -184				; size = 4
_texturevpegtop$23 = -180				; size = 4
_texturehpeg$24 = -176					; size = 4
_Surf$ = -172						; size = 8
_colormap$ = -164					; size = 4
_lightnum$ = -160					; size = 4
_l$ = -156						; size = 4
_h$ = -152						; size = 4
_gr_midtexture$ = -148					; size = 4
_cliphigh$ = -144					; size = 4
_cliplow$ = -140					; size = 4
_grTex$ = -136						; size = 4
_worldlow$ = -132					; size = 4
_worldhigh$ = -128					; size = 4
_worldbottom$ = -124					; size = 4
_worldtop$ = -120					; size = 4
_ve$ = -116						; size = 8
_vs$ = -108						; size = 8
_wallVerts$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_startfrac$ = 8						; size = 8
_endfrac$ = 16						; size = 8
_HWR_StoreWallRange PROC				; COMDAT

; 1431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1432 : 	wallVert3D wallVerts[4];
; 1433 : 	v2d_t vs, ve; // start, end vertices of 2d line (view from above)
; 1434 : 
; 1435 : 	fixed_t worldtop, worldbottom;
; 1436 : 	fixed_t worldhigh = 0, worldlow = 0;

  00016	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _worldhigh$[ebp], 0
  0001d	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _worldlow$[ebp], 0

; 1437 : 
; 1438 : 	GLTexture_t *grTex = NULL;

  00027	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _grTex$[ebp], 0

; 1439 : 	float cliplow = 0.0f, cliphigh = 0.0f;

  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _cliplow$[ebp], xmm0
  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _cliphigh$[ebp], xmm0

; 1440 : 	INT32 gr_midtexture;
; 1441 : 	fixed_t h, l; // 3D sides and 2s middle textures
; 1442 : 
; 1443 : 	FUINT lightnum = 0; // shut up compiler

  00047	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _lightnum$[ebp], 0

; 1444 : 	extracolormap_t *colormap;
; 1445 : 	FSurfaceInfo Surf;
; 1446 : 
; 1447 : 	if (startfrac > endfrac)

  00051	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _startfrac$[ebp]
  00056	66 0f 2f 45 10	 comisd	 xmm0, QWORD PTR _endfrac$[ebp]
  0005b	76 05		 jbe	 SHORT $LN10@HWR_StoreW

; 1448 : 		return;

  0005d	e9 0f 22 00 00	 jmp	 $LN8@HWR_StoreW
$LN10@HWR_StoreW:

; 1449 : 
; 1450 : 	gr_sidedef = gr_curline->sidedef;

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00067	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006a	89 0d 00 00 00
	00		 mov	 DWORD PTR _gr_sidedef, ecx

; 1451 : 	gr_linedef = gr_curline->linedef;

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00075	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00078	89 0d 00 00 00
	00		 mov	 DWORD PTR _gr_linedef, ecx

; 1452 : 
; 1453 : 	if (gr_frontsector->heightsec != -1)

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00083	83 78 68 ff	 cmp	 DWORD PTR [eax+104], -1
  00087	74 33		 je	 SHORT $LN11@HWR_StoreW

; 1454 : 	{
; 1455 : 		worldtop = sectors[gr_frontsector->heightsec].ceilingheight;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0008e	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0009b	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0009f	89 45 88	 mov	 DWORD PTR _worldtop$[ebp], eax

; 1456 : 		worldbottom = sectors[gr_frontsector->heightsec].floorheight;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000a7	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  000ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  000b4	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000b7	89 45 84	 mov	 DWORD PTR _worldbottom$[ebp], eax

; 1457 : 	}

  000ba	eb 15		 jmp	 SHORT $LN12@HWR_StoreW
$LN11@HWR_StoreW:

; 1458 : 	else
; 1459 : 	{
; 1460 : 		worldtop    = gr_frontsector->ceilingheight;

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c4	89 4d 88	 mov	 DWORD PTR _worldtop$[ebp], ecx

; 1461 : 		worldbottom = gr_frontsector->floorheight;

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  000cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ce	89 4d 84	 mov	 DWORD PTR _worldbottom$[ebp], ecx
$LN12@HWR_StoreW:

; 1462 : 	}
; 1463 : 
; 1464 : 	vs.x = ((polyvertex_t *)gr_curline->v1)->x;

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  000d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d8	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  000dc	f3 0f 11 45 94	 movss	 DWORD PTR _vs$[ebp], xmm0

; 1465 : 	vs.y = ((polyvertex_t *)gr_curline->v1)->y;

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  000ed	f3 0f 11 45 98	 movss	 DWORD PTR _vs$[ebp+4], xmm0

; 1466 : 	ve.x = ((polyvertex_t *)gr_curline->v2)->x;

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  000f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fa	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  000fe	f3 0f 11 45 8c	 movss	 DWORD PTR _ve$[ebp], xmm0

; 1467 : 	ve.y = ((polyvertex_t *)gr_curline->v2)->y;

  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00108	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010b	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00110	f3 0f 11 45 90	 movss	 DWORD PTR _ve$[ebp+4], xmm0

; 1468 : 
; 1469 : 	// remember vertices ordering
; 1470 : 	//  3--2
; 1471 : 	//  | /|
; 1472 : 	//  |/ |
; 1473 : 	//  0--1
; 1474 : 	// make a wall polygon (with 2 triangles), using the floor/ceiling heights,
; 1475 : 	// and the 2d map coords of start/end vertices
; 1476 : 	wallVerts[0].x = wallVerts[3].x = vs.x;

  00115	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0011a	6b c8 03	 imul	 ecx, eax, 3
  0011d	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _vs$[ebp]
  00122	f3 0f 11 44 0d
	9c		 movss	 DWORD PTR _wallVerts$[ebp+ecx], xmm0
  00128	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0012d	6b c2 00	 imul	 eax, edx, 0
  00130	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _vs$[ebp]
  00135	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _wallVerts$[ebp+eax], xmm0

; 1477 : 	wallVerts[0].z = wallVerts[3].z = vs.y;

  0013b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00140	6b c8 03	 imul	 ecx, eax, 3
  00143	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _vs$[ebp+4]
  00148	f3 0f 11 44 0d
	a4		 movss	 DWORD PTR _wallVerts$[ebp+ecx+8], xmm0
  0014e	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00153	6b c2 00	 imul	 eax, edx, 0
  00156	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _vs$[ebp+4]
  0015b	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _wallVerts$[ebp+eax+8], xmm0

; 1478 : 	wallVerts[2].x = wallVerts[1].x = ve.x;

  00161	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00166	c1 e0 00	 shl	 eax, 0
  00169	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _ve$[ebp]
  0016e	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _wallVerts$[ebp+eax], xmm0
  00174	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00179	d1 e1		 shl	 ecx, 1
  0017b	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _ve$[ebp]
  00180	f3 0f 11 44 0d
	9c		 movss	 DWORD PTR _wallVerts$[ebp+ecx], xmm0

; 1479 : 	wallVerts[2].z = wallVerts[1].z = ve.y;

  00186	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0018b	c1 e0 00	 shl	 eax, 0
  0018e	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _ve$[ebp+4]
  00193	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _wallVerts$[ebp+eax+8], xmm0
  00199	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0019e	d1 e1		 shl	 ecx, 1
  001a0	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _ve$[ebp+4]
  001a5	f3 0f 11 44 0d
	a4		 movss	 DWORD PTR _wallVerts$[ebp+ecx+8], xmm0

; 1480 : 	wallVerts[0].w = wallVerts[1].w = wallVerts[2].w = wallVerts[3].w = 1.0f;

  001ab	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  001b0	6b c8 03	 imul	 ecx, eax, 3
  001b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001bb	f3 0f 11 44 0d
	b0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+20], xmm0
  001c1	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  001c6	d1 e2		 shl	 edx, 1
  001c8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001d0	f3 0f 11 44 15
	b0		 movss	 DWORD PTR _wallVerts$[ebp+edx+20], xmm0
  001d6	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  001db	c1 e0 00	 shl	 eax, 0
  001de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001e6	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _wallVerts$[ebp+eax+20], xmm0
  001ec	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  001f1	6b d1 00	 imul	 edx, ecx, 0
  001f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001fc	f3 0f 11 44 15
	b0		 movss	 DWORD PTR _wallVerts$[ebp+edx+20], xmm0

; 1481 : 
; 1482 : 	if (drawtextured)

  00202	b8 01 00 00 00	 mov	 eax, 1
  00207	85 c0		 test	 eax, eax
  00209	0f 84 f2 00 00
	00		 je	 $LN17@HWR_StoreW

; 1483 : 	{
; 1484 : 		// x offset the texture
; 1485 : 		fixed_t texturehpeg = gr_sidedef->textureoffset + gr_curline->offset;

  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00214	8b 08		 mov	 ecx, DWORD PTR [eax]
  00216	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_curline
  0021c	03 4a 0c	 add	 ecx, DWORD PTR [edx+12]
  0021f	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _texturehpeg$24[ebp], ecx

; 1486 : 
; 1487 : 		// clip texture s start/end coords with solidsegs
; 1488 : 		if (startfrac > 0.0f && startfrac < 1.0f)

  00225	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _startfrac$[ebp]
  0022a	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00232	76 44		 jbe	 SHORT $LN14@HWR_StoreW
  00234	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0023c	66 0f 2f 45 08	 comisd	 xmm0, QWORD PTR _startfrac$[ebp]
  00241	76 35		 jbe	 SHORT $LN14@HWR_StoreW

; 1489 : 			cliplow = (float)(texturehpeg + (gr_curline->flength*FRACUNIT) * startfrac);

  00243	f2 0f 2a 85 50
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR _texturehpeg$24[ebp]
  0024b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00250	f3 0f 10 48 24	 movss	 xmm1, DWORD PTR [eax+36]
  00255	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@47800000
  0025d	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  00261	f2 0f 59 4d 08	 mulsd	 xmm1, QWORD PTR _startfrac$[ebp]
  00266	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0026a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0026e	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _cliplow$[ebp], xmm0
  00276	eb 10		 jmp	 SHORT $LN15@HWR_StoreW
$LN14@HWR_StoreW:

; 1490 : 		else
; 1491 : 			cliplow = (float)texturehpeg;

  00278	f3 0f 2a 85 50
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _texturehpeg$24[ebp]
  00280	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _cliplow$[ebp], xmm0
$LN15@HWR_StoreW:

; 1492 : 
; 1493 : 		if (endfrac > 0.0f && endfrac < 1.0f)

  00288	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _endfrac$[ebp]
  0028d	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00295	76 44		 jbe	 SHORT $LN16@HWR_StoreW
  00297	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0029f	66 0f 2f 45 10	 comisd	 xmm0, QWORD PTR _endfrac$[ebp]
  002a4	76 35		 jbe	 SHORT $LN16@HWR_StoreW

; 1494 : 			cliphigh = (float)(texturehpeg + (gr_curline->flength*FRACUNIT) * endfrac);

  002a6	f2 0f 2a 85 50
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR _texturehpeg$24[ebp]
  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  002b3	f3 0f 10 48 24	 movss	 xmm1, DWORD PTR [eax+36]
  002b8	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@47800000
  002c0	f3 0f 5a c9	 cvtss2sd xmm1, xmm1
  002c4	f2 0f 59 4d 10	 mulsd	 xmm1, QWORD PTR _endfrac$[ebp]
  002c9	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002cd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002d1	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _cliphigh$[ebp], xmm0
  002d9	eb 26		 jmp	 SHORT $LN17@HWR_StoreW
$LN16@HWR_StoreW:

; 1495 : 		else
; 1496 : 			cliphigh = (float)(texturehpeg + (gr_curline->flength*FRACUNIT));

  002db	f3 0f 2a 85 50
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _texturehpeg$24[ebp]
  002e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  002e8	f3 0f 10 48 24	 movss	 xmm1, DWORD PTR [eax+36]
  002ed	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@47800000
  002f5	f3 0f 58 c1	 addss	 xmm0, xmm1
  002f9	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _cliphigh$[ebp], xmm0
$LN17@HWR_StoreW:

; 1497 : 	}
; 1498 : 
; 1499 : #ifdef HARDWAREFIX
; 1500 : 	lightnum = gr_frontsector->lightlevel;

  00301	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00306	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0030a	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _lightnum$[ebp], ecx

; 1501 : 	colormap = gr_frontsector->extra_colormap;

  00310	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00315	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0031b	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _colormap$[ebp], ecx

; 1502 : #else
; 1503 : 	//  use different light tables
; 1504 : 	//  for horizontal / vertical / diagonal
; 1505 : 	//  note: try to get the same visual feel as the original
; 1506 : 	Surf.FlatColor.s.alpha = 0xff;
; 1507 : 
; 1508 : 	lightnum = LightLevelToLum(gr_frontsector->lightlevel);
; 1509 : 
; 1510 : 	if (((polyvertex_t *)gr_curline->v1)->y == ((polyvertex_t *)gr_curline->v2)->y
; 1511 : 		&& lightnum >= (255/LIGHTLEVELS))
; 1512 : 	{
; 1513 : 		lightnum -= 255/LIGHTLEVELS;
; 1514 : 	}
; 1515 : 	else if (((polyvertex_t *)gr_curline->v1)->x == ((polyvertex_t *)gr_curline->v2)->x
; 1516 : 		&& lightnum < 255 - (255/LIGHTLEVELS))
; 1517 : 	{
; 1518 : 		lightnum += 255/LIGHTLEVELS;
; 1519 : 	}
; 1520 : 
; 1521 : 	// store Surface->FlatColor to modulate wall texture
; 1522 : 	Surf.FlatColor.s.red = Surf.FlatColor.s.green = Surf.FlatColor.s.blue =
; 1523 : 		(UINT8)lightnum;
; 1524 : #endif
; 1525 : 
; 1526 : 	if (gr_frontsector)

  00321	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_frontsector, 0
  00328	74 07		 je	 SHORT $LN18@HWR_StoreW

; 1527 : 	{
; 1528 : 		Surf.FlatColor.s.alpha = 255;

  0032a	c6 85 5b ff ff
	ff ff		 mov	 BYTE PTR _Surf$[ebp+7], 255 ; 000000ffH
$LN18@HWR_StoreW:

; 1529 : #ifndef HARDWAREFIX
; 1530 : 		{
; 1531 : 			RGBA_t temp;
; 1532 : 			INT32 alpha;
; 1533 : 
; 1534 : 			temp.rgba = sector->extra_colormap->rgba;
; 1535 : 			alpha = (INT32)((26 - temp.s.alpha)*lightnum);
; 1536 : 			Surf.FlatColor.s.red =
; 1537 : 				(UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 1538 : 			Surf.FlatColor.s.blue =
; 1539 : 				(UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 1540 : 			Surf.FlatColor.s.green =
; 1541 : 				(UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 1542 : 			Surf.FlatColor.s.alpha = 0xff;
; 1543 : 		}
; 1544 : #endif
; 1545 : 	}
; 1546 : 
; 1547 : 	if (gr_backsector)

  00331	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_backsector, 0
  00338	0f 84 6f 0e 00
	00		 je	 $LN19@HWR_StoreW

; 1548 : 	{
; 1549 : 		// two sided line
; 1550 : 		if (gr_backsector->heightsec != -1)

  0033e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00343	83 78 68 ff	 cmp	 DWORD PTR [eax+104], -1
  00347	74 36		 je	 SHORT $LN21@HWR_StoreW

; 1551 : 		{
; 1552 : 			worldhigh = sectors[gr_backsector->heightsec].ceilingheight;

  00349	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  0034e	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  00355	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0035b	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0035f	89 45 80	 mov	 DWORD PTR _worldhigh$[ebp], eax

; 1553 : 			worldlow = sectors[gr_backsector->heightsec].floorheight;

  00362	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00367	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  0036e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00374	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00377	89 85 7c ff ff
	ff		 mov	 DWORD PTR _worldlow$[ebp], eax

; 1554 : 		}

  0037d	eb 18		 jmp	 SHORT $LN22@HWR_StoreW
$LN21@HWR_StoreW:

; 1555 : 		else
; 1556 : 		{
; 1557 : 			worldhigh = gr_backsector->ceilingheight;

  0037f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  00384	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00387	89 4d 80	 mov	 DWORD PTR _worldhigh$[ebp], ecx

; 1558 : 			worldlow  = gr_backsector->floorheight;

  0038a	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  0038f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00391	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _worldlow$[ebp], ecx
$LN22@HWR_StoreW:

; 1559 : 		}
; 1560 : 
; 1561 : 		// hack to allow height changes in outdoor areas
; 1562 : 		// This is what gets rid of the upper textures if there should be sky
; 1563 : 		if (gr_frontsector->ceilingpic == skyflatnum &&

  00397	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0039c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0039f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  003a5	75 16		 jne	 SHORT $LN23@HWR_StoreW
  003a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  003ac	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003af	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  003b5	75 06		 jne	 SHORT $LN23@HWR_StoreW

; 1564 : 			gr_backsector->ceilingpic  == skyflatnum)
; 1565 : 		{
; 1566 : 			worldtop = worldhigh;

  003b7	8b 45 80	 mov	 eax, DWORD PTR _worldhigh$[ebp]
  003ba	89 45 88	 mov	 DWORD PTR _worldtop$[ebp], eax
$LN23@HWR_StoreW:

; 1567 : 		}
; 1568 : 
; 1569 : 		// check TOP TEXTURE
; 1570 : 		if (worldhigh < worldtop && texturetranslation[gr_sidedef->toptexture]
; 1571 : #ifdef POLYOBJECTS // polyobjects don't have top textures, silly.
; 1572 : 		&& !gr_curline->polyseg

  003bd	8b 45 80	 mov	 eax, DWORD PTR _worldhigh$[ebp]
  003c0	3b 45 88	 cmp	 eax, DWORD PTR _worldtop$[ebp]
  003c3	0f 8d ed 02 00
	00		 jge	 $LN31@HWR_StoreW
  003c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  003ce	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  003d7	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  003db	0f 84 d5 02 00
	00		 je	 $LN31@HWR_StoreW
  003e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  003e6	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  003ea	0f 85 c6 02 00
	00		 jne	 $LN31@HWR_StoreW

; 1573 : #endif
; 1574 : 			)
; 1575 : 		{
; 1576 : 			if (drawtextured)

  003f0	b8 01 00 00 00	 mov	 eax, 1
  003f5	85 c0		 test	 eax, eax
  003f7	0f 84 8d 01 00
	00		 je	 $LN25@HWR_StoreW

; 1577 : 			{
; 1578 : 				fixed_t texturevpegtop; // top
; 1579 : 
; 1580 : 				grTex = HWR_GetTexture(texturetranslation[gr_sidedef->toptexture]);

  003fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00402	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00405	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  0040b	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 _HWR_GetTexture
  00414	83 c4 04	 add	 esp, 4
  00417	89 85 78 ff ff
	ff		 mov	 DWORD PTR _grTex$[ebp], eax

; 1581 : 
; 1582 : 				// PEGGING
; 1583 : 				if (gr_linedef->flags & ML_DONTPEGTOP)

  0041d	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00422	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00426	83 e1 08	 and	 ecx, 8
  00429	74 0c		 je	 SHORT $LN26@HWR_StoreW

; 1584 : 					texturevpegtop = 0;

  0042b	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _texturevpegtop$23[ebp], 0
  00435	eb 1d		 jmp	 SHORT $LN27@HWR_StoreW
$LN26@HWR_StoreW:

; 1585 : 				else
; 1586 : 					texturevpegtop = worldhigh + textureheight[gr_sidedef->toptexture] - worldtop;

  00437	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  0043c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0043f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _textureheight
  00445	8b 45 80	 mov	 eax, DWORD PTR _worldhigh$[ebp]
  00448	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  0044b	2b 45 88	 sub	 eax, DWORD PTR _worldtop$[ebp]
  0044e	89 85 4c ff ff
	ff		 mov	 DWORD PTR _texturevpegtop$23[ebp], eax
$LN27@HWR_StoreW:

; 1587 : 
; 1588 : 				texturevpegtop += gr_sidedef->rowoffset;

  00454	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00459	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _texturevpegtop$23[ebp]
  0045f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00462	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _texturevpegtop$23[ebp], ecx

; 1589 : 
; 1590 : 				wallVerts[3].t = wallVerts[2].t = texturevpegtop * grTex->scaleY;

  00468	f3 0f 2a 85 4c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _texturevpegtop$23[ebp]
  00470	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00476	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  0047b	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv241[ebp], xmm0
  00483	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00488	d1 e1		 shl	 ecx, 1
  0048a	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv241[ebp]
  00492	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  00498	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0049d	6b c2 03	 imul	 eax, edx, 3
  004a0	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv241[ebp]
  004a8	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 1591 : 				wallVerts[0].t = wallVerts[1].t = (texturevpegtop + worldtop - worldhigh) * grTex->scaleY;

  004ae	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _texturevpegtop$23[ebp]
  004b4	03 45 88	 add	 eax, DWORD PTR _worldtop$[ebp]
  004b7	2b 45 80	 sub	 eax, DWORD PTR _worldhigh$[ebp]
  004ba	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004be	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _grTex$[ebp]
  004c4	f3 0f 59 41 30	 mulss	 xmm0, DWORD PTR [ecx+48]
  004c9	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv252[ebp], xmm0
  004d1	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  004d6	c1 e2 00	 shl	 edx, 0
  004d9	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv252[ebp]
  004e1	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0
  004e7	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004ec	6b c8 00	 imul	 ecx, eax, 0
  004ef	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv252[ebp]
  004f7	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0

; 1592 : 				wallVerts[0].s = wallVerts[3].s = cliplow * grTex->scaleX;

  004fd	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00503	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _cliplow$[ebp]
  0050b	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00510	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv260[ebp], xmm0
  00518	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0051d	6b d1 03	 imul	 edx, ecx, 3
  00520	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv260[ebp]
  00528	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
  0052e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00533	6b c8 00	 imul	 ecx, eax, 0
  00536	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv260[ebp]
  0053e	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 1593 : 				wallVerts[2].s = wallVerts[1].s = cliphigh * grTex->scaleX;

  00544	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  0054a	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _cliphigh$[ebp]
  00552	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00557	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv268[ebp], xmm0
  0055f	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00564	c1 e1 00	 shl	 ecx, 0
  00567	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv268[ebp]
  0056f	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  00575	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0057a	d1 e2		 shl	 edx, 1
  0057c	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv268[ebp]
  00584	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
$LN25@HWR_StoreW:

; 1594 : 			}
; 1595 : 
; 1596 : 			// set top/bottom coords
; 1597 : 			wallVerts[2].y = wallVerts[3].y = FIXED_TO_FLOAT(worldtop);

  0058a	f3 0f 2a 45 88	 cvtsi2ss xmm0, DWORD PTR _worldtop$[ebp]
  0058f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00597	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv278[ebp], xmm0
  0059f	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  005a4	6b c8 03	 imul	 ecx, eax, 3
  005a7	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv278[ebp]
  005af	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  005b5	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  005ba	d1 e2		 shl	 edx, 1
  005bc	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv278[ebp]
  005c4	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1598 : 			wallVerts[0].y = wallVerts[1].y = FIXED_TO_FLOAT(worldhigh);

  005ca	f3 0f 2a 45 80	 cvtsi2ss xmm0, DWORD PTR _worldhigh$[ebp]
  005cf	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  005d7	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv288[ebp], xmm0
  005df	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  005e4	c1 e0 00	 shl	 eax, 0
  005e7	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv288[ebp]
  005ef	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  005f5	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  005fa	6b d1 00	 imul	 edx, ecx, 0
  005fd	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv288[ebp]
  00605	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1599 : 
; 1600 : 			if (gr_frontsector->numlights)

  0060b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00610	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00617	74 32		 je	 SHORT $LN28@HWR_StoreW

; 1601 : 				HWR_SplitWall(gr_frontsector, wallVerts, texturetranslation[gr_sidedef->toptexture], &Surf, FF_CUTSOLIDS);

  00619	68 80 00 00 00	 push	 128			; 00000080H
  0061e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  00624	50		 push	 eax
  00625	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_sidedef
  0062b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0062e	a1 00 00 00 00	 mov	 eax, DWORD PTR _texturetranslation
  00633	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00636	51		 push	 ecx
  00637	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  0063a	52		 push	 edx
  0063b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00640	50		 push	 eax
  00641	e8 00 00 00 00	 call	 _HWR_SplitWall
  00646	83 c4 14	 add	 esp, 20			; 00000014H
  00649	eb 6b		 jmp	 SHORT $LN31@HWR_StoreW
$LN28@HWR_StoreW:

; 1602 : 			else if (grTex->mipmap.flags & TF_TRANSPARENT)

  0064b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00651	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00654	83 e1 40	 and	 ecx, 64			; 00000040H
  00657	74 3a		 je	 SHORT $LN30@HWR_StoreW

; 1603 : 				HWR_AddTransparentWall(wallVerts, &Surf, texturetranslation[gr_sidedef->toptexture], PF_Environment, false, lightnum, colormap);

  00659	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  0065f	50		 push	 eax
  00660	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  00666	51		 push	 ecx
  00667	6a 00		 push	 0
  00669	6a 08		 push	 8
  0066b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_sidedef
  00671	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00674	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _texturetranslation
  0067a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0067d	52		 push	 edx
  0067e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  00684	50		 push	 eax
  00685	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  00688	51		 push	 ecx
  00689	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  0068e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00691	eb 23		 jmp	 SHORT $LN31@HWR_StoreW
$LN30@HWR_StoreW:

; 1604 : 			else
; 1605 : 				HWR_ProjectWall(wallVerts, &Surf, PF_Masked, lightnum, colormap);

  00693	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  00699	50		 push	 eax
  0069a	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  006a0	51		 push	 ecx
  006a1	6a 01		 push	 1
  006a3	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  006a9	52		 push	 edx
  006aa	8d 45 9c	 lea	 eax, DWORD PTR _wallVerts$[ebp]
  006ad	50		 push	 eax
  006ae	e8 00 00 00 00	 call	 _HWR_ProjectWall
  006b3	83 c4 14	 add	 esp, 20			; 00000014H
$LN31@HWR_StoreW:

; 1606 : 		}
; 1607 : 
; 1608 : 		// check BOTTOM TEXTURE
; 1609 : 		if (worldlow > worldbottom && texturetranslation[gr_sidedef->bottomtexture]
; 1610 : #ifdef POLYOBJECTS // polyobjects don't have bottom textures, silly.
; 1611 : 		&& !gr_curline->polyseg

  006b6	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _worldlow$[ebp]
  006bc	3b 45 84	 cmp	 eax, DWORD PTR _worldbottom$[ebp]
  006bf	0f 8e ef 02 00
	00		 jle	 $LN39@HWR_StoreW
  006c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  006ca	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  006cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  006d3	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  006d7	0f 84 d7 02 00
	00		 je	 $LN39@HWR_StoreW
  006dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  006e2	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  006e6	0f 85 c8 02 00
	00		 jne	 $LN39@HWR_StoreW

; 1612 : #endif
; 1613 : 			) //only if VISIBLE!!!
; 1614 : 		{
; 1615 : 			if (drawtextured)

  006ec	b8 01 00 00 00	 mov	 eax, 1
  006f1	85 c0		 test	 eax, eax
  006f3	0f 84 8c 01 00
	00		 je	 $LN33@HWR_StoreW

; 1616 : 			{
; 1617 : 				fixed_t texturevpegbottom = 0; // bottom

  006f9	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _texturevpegbottom$22[ebp], 0

; 1618 : 
; 1619 : 				grTex = HWR_GetTexture(texturetranslation[gr_sidedef->bottomtexture]);

  00703	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00708	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0070b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  00711	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00714	50		 push	 eax
  00715	e8 00 00 00 00	 call	 _HWR_GetTexture
  0071a	83 c4 04	 add	 esp, 4
  0071d	89 85 78 ff ff
	ff		 mov	 DWORD PTR _grTex$[ebp], eax

; 1620 : 
; 1621 : 				// PEGGING
; 1622 : 				if (gr_linedef->flags & ML_DONTPEGBOTTOM)

  00723	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00728	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0072c	83 e1 10	 and	 ecx, 16			; 00000010H
  0072f	74 11		 je	 SHORT $LN34@HWR_StoreW

; 1623 : 					texturevpegbottom = worldtop - worldlow;

  00731	8b 45 88	 mov	 eax, DWORD PTR _worldtop$[ebp]
  00734	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _worldlow$[ebp]
  0073a	89 85 48 ff ff
	ff		 mov	 DWORD PTR _texturevpegbottom$22[ebp], eax
  00740	eb 0a		 jmp	 SHORT $LN35@HWR_StoreW
$LN34@HWR_StoreW:

; 1624 : 				else
; 1625 : 					texturevpegbottom = 0;

  00742	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _texturevpegbottom$22[ebp], 0
$LN35@HWR_StoreW:

; 1626 : 
; 1627 : 				texturevpegbottom += gr_sidedef->rowoffset;

  0074c	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00751	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _texturevpegbottom$22[ebp]
  00757	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0075a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _texturevpegbottom$22[ebp], ecx

; 1628 : 
; 1629 : 				wallVerts[3].t = wallVerts[2].t = texturevpegbottom * grTex->scaleY;

  00760	f3 0f 2a 85 48
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _texturevpegbottom$22[ebp]
  00768	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  0076e	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  00773	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv345[ebp], xmm0
  0077b	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00780	d1 e1		 shl	 ecx, 1
  00782	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv345[ebp]
  0078a	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  00790	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00795	6b c2 03	 imul	 eax, edx, 3
  00798	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv345[ebp]
  007a0	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 1630 : 				wallVerts[0].t = wallVerts[1].t = (texturevpegbottom + worldlow - worldbottom) * grTex->scaleY;

  007a6	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _texturevpegbottom$22[ebp]
  007ac	03 85 7c ff ff
	ff		 add	 eax, DWORD PTR _worldlow$[ebp]
  007b2	2b 45 84	 sub	 eax, DWORD PTR _worldbottom$[ebp]
  007b5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  007b9	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _grTex$[ebp]
  007bf	f3 0f 59 41 30	 mulss	 xmm0, DWORD PTR [ecx+48]
  007c4	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv356[ebp], xmm0
  007cc	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  007d1	c1 e2 00	 shl	 edx, 0
  007d4	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv356[ebp]
  007dc	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0
  007e2	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  007e7	6b c8 00	 imul	 ecx, eax, 0
  007ea	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv356[ebp]
  007f2	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0

; 1631 : 				wallVerts[0].s = wallVerts[3].s = cliplow * grTex->scaleX;

  007f8	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  007fe	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _cliplow$[ebp]
  00806	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  0080b	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv364[ebp], xmm0
  00813	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00818	6b d1 03	 imul	 edx, ecx, 3
  0081b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv364[ebp]
  00823	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
  00829	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0082e	6b c8 00	 imul	 ecx, eax, 0
  00831	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv364[ebp]
  00839	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 1632 : 				wallVerts[2].s = wallVerts[1].s = cliphigh * grTex->scaleX;

  0083f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00845	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _cliphigh$[ebp]
  0084d	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00852	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv372[ebp], xmm0
  0085a	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0085f	c1 e1 00	 shl	 ecx, 0
  00862	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv372[ebp]
  0086a	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  00870	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00875	d1 e2		 shl	 edx, 1
  00877	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv372[ebp]
  0087f	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
$LN33@HWR_StoreW:

; 1633 : 			}
; 1634 : 
; 1635 : 			// set top/bottom coords
; 1636 : 			wallVerts[2].y = wallVerts[3].y = FIXED_TO_FLOAT(worldlow);

  00885	f3 0f 2a 85 7c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _worldlow$[ebp]
  0088d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00895	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv382[ebp], xmm0
  0089d	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  008a2	6b c8 03	 imul	 ecx, eax, 3
  008a5	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv382[ebp]
  008ad	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  008b3	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  008b8	d1 e2		 shl	 edx, 1
  008ba	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv382[ebp]
  008c2	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1637 : 			wallVerts[0].y = wallVerts[1].y = FIXED_TO_FLOAT(worldbottom);

  008c8	f3 0f 2a 45 84	 cvtsi2ss xmm0, DWORD PTR _worldbottom$[ebp]
  008cd	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  008d5	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv392[ebp], xmm0
  008dd	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  008e2	c1 e0 00	 shl	 eax, 0
  008e5	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv392[ebp]
  008ed	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  008f3	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  008f8	6b d1 00	 imul	 edx, ecx, 0
  008fb	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv392[ebp]
  00903	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1638 : 
; 1639 : 			if (gr_frontsector->numlights)

  00909	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0090e	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00915	74 32		 je	 SHORT $LN36@HWR_StoreW

; 1640 : 				HWR_SplitWall(gr_frontsector, wallVerts, texturetranslation[gr_sidedef->bottomtexture], &Surf, FF_CUTSOLIDS);

  00917	68 80 00 00 00	 push	 128			; 00000080H
  0091c	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  00922	50		 push	 eax
  00923	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_sidedef
  00929	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0092c	a1 00 00 00 00	 mov	 eax, DWORD PTR _texturetranslation
  00931	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00934	51		 push	 ecx
  00935	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  00938	52		 push	 edx
  00939	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0093e	50		 push	 eax
  0093f	e8 00 00 00 00	 call	 _HWR_SplitWall
  00944	83 c4 14	 add	 esp, 20			; 00000014H
  00947	eb 6b		 jmp	 SHORT $LN39@HWR_StoreW
$LN36@HWR_StoreW:

; 1641 : 			else if (grTex->mipmap.flags & TF_TRANSPARENT)

  00949	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  0094f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00952	83 e1 40	 and	 ecx, 64			; 00000040H
  00955	74 3a		 je	 SHORT $LN38@HWR_StoreW

; 1642 : 				HWR_AddTransparentWall(wallVerts, &Surf, texturetranslation[gr_sidedef->bottomtexture], PF_Environment, false, lightnum, colormap);

  00957	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  0095d	50		 push	 eax
  0095e	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  00964	51		 push	 ecx
  00965	6a 00		 push	 0
  00967	6a 08		 push	 8
  00969	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_sidedef
  0096f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00972	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _texturetranslation
  00978	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0097b	52		 push	 edx
  0097c	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  00982	50		 push	 eax
  00983	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  00986	51		 push	 ecx
  00987	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  0098c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0098f	eb 23		 jmp	 SHORT $LN39@HWR_StoreW
$LN38@HWR_StoreW:

; 1643 : 			else
; 1644 : 				HWR_ProjectWall(wallVerts, &Surf, PF_Masked, lightnum, colormap);

  00991	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  00997	50		 push	 eax
  00998	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0099e	51		 push	 ecx
  0099f	6a 01		 push	 1
  009a1	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  009a7	52		 push	 edx
  009a8	8d 45 9c	 lea	 eax, DWORD PTR _wallVerts$[ebp]
  009ab	50		 push	 eax
  009ac	e8 00 00 00 00	 call	 _HWR_ProjectWall
  009b1	83 c4 14	 add	 esp, 20			; 00000014H
$LN39@HWR_StoreW:

; 1645 : 		}
; 1646 : 		gr_midtexture = texturetranslation[gr_sidedef->midtexture];

  009b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  009b9	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  009bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  009c2	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  009c5	89 85 6c ff ff
	ff		 mov	 DWORD PTR _gr_midtexture$[ebp], eax

; 1647 : 		if (gr_midtexture)

  009cb	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _gr_midtexture$[ebp], 0
  009d2	0f 84 d0 07 00
	00		 je	 $LN90@HWR_StoreW

; 1648 : 		{
; 1649 : 			FBITFIELD blendmode;
; 1650 : 			sector_t *front, *back;
; 1651 : 			fixed_t  popentop, popenbottom, polytop, polybottom, lowcut, highcut;
; 1652 : 			fixed_t     texturevpeg = 0;

  009d8	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _texturevpeg$12[ebp], 0

; 1653 : 			INT32 repeats;
; 1654 : 
; 1655 : 			if (gr_linedef->frontsector->heightsec != -1)

  009e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  009e7	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  009ea	83 79 68 ff	 cmp	 DWORD PTR [ecx+104], -1
  009ee	74 1d		 je	 SHORT $LN41@HWR_StoreW

; 1656 : 				front = &sectors[gr_linedef->frontsector->heightsec];

  009f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  009f5	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  009f8	69 51 68 f8 00
	00 00		 imul	 edx, DWORD PTR [ecx+104], 248
  009ff	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  00a05	89 95 40 ff ff
	ff		 mov	 DWORD PTR _front$20[ebp], edx
  00a0b	eb 0e		 jmp	 SHORT $LN42@HWR_StoreW
$LN41@HWR_StoreW:

; 1657 : 			else
; 1658 : 				front = gr_linedef->frontsector;

  00a0d	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00a12	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00a15	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _front$20[ebp], ecx
$LN42@HWR_StoreW:

; 1659 : 
; 1660 : 			if (gr_linedef->backsector->heightsec != -1)

  00a1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00a20	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00a23	83 79 68 ff	 cmp	 DWORD PTR [ecx+104], -1
  00a27	74 1d		 je	 SHORT $LN43@HWR_StoreW

; 1661 : 				back = &sectors[gr_linedef->backsector->heightsec];

  00a29	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00a2e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00a31	69 51 68 f8 00
	00 00		 imul	 edx, DWORD PTR [ecx+104], 248
  00a38	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  00a3e	89 95 3c ff ff
	ff		 mov	 DWORD PTR _back$19[ebp], edx
  00a44	eb 0e		 jmp	 SHORT $LN44@HWR_StoreW
$LN43@HWR_StoreW:

; 1662 : 			else
; 1663 : 				back = gr_linedef->backsector;

  00a46	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00a4b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00a4e	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _back$19[ebp], ecx
$LN44@HWR_StoreW:

; 1664 : 
; 1665 : 			if (gr_sidedef->repeatcnt)

  00a54	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00a59	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00a5d	85 c9		 test	 ecx, ecx
  00a5f	74 17		 je	 SHORT $LN45@HWR_StoreW

; 1666 : 				repeats = 1 + gr_sidedef->repeatcnt;

  00a61	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00a66	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00a6a	83 c1 01	 add	 ecx, 1
  00a6d	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _repeats$11[ebp], ecx
  00a73	e9 aa 00 00 00	 jmp	 $LN48@HWR_StoreW
$LN45@HWR_StoreW:

; 1667 : 			else if (gr_linedef->flags & ML_EFFECT5)

  00a78	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00a7d	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00a81	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00a87	0f 84 8b 00 00
	00		 je	 $LN47@HWR_StoreW

; 1668 : 			{
; 1669 : 				fixed_t high, low;
; 1670 : 
; 1671 : 				if (front->ceilingheight > back->ceilingheight)

  00a8d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00a93	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _back$19[ebp]
  00a99	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00a9c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00a9f	7e 11		 jle	 SHORT $LN49@HWR_StoreW

; 1672 : 					high = back->ceilingheight;

  00aa1	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _back$19[ebp]
  00aa7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00aaa	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _high$10[ebp], ecx
  00ab0	eb 0f		 jmp	 SHORT $LN50@HWR_StoreW
$LN49@HWR_StoreW:

; 1673 : 				else
; 1674 : 					high = front->ceilingheight;

  00ab2	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00ab8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00abb	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _high$10[ebp], ecx
$LN50@HWR_StoreW:

; 1675 : 
; 1676 : 				if (front->floorheight > back->floorheight)

  00ac1	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00ac7	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _back$19[ebp]
  00acd	8b 10		 mov	 edx, DWORD PTR [eax]
  00acf	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00ad1	7e 10		 jle	 SHORT $LN51@HWR_StoreW

; 1677 : 					low = front->floorheight;

  00ad3	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00ad9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00adb	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _low$9[ebp], ecx
  00ae1	eb 0e		 jmp	 SHORT $LN52@HWR_StoreW
$LN51@HWR_StoreW:

; 1678 : 				else
; 1679 : 					low = back->floorheight;

  00ae3	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _back$19[ebp]
  00ae9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00aeb	89 8d 14 ff ff
	ff		 mov	 DWORD PTR _low$9[ebp], ecx
$LN52@HWR_StoreW:

; 1680 : 
; 1681 : 				repeats = (high - low)/textureheight[gr_sidedef->midtexture];

  00af1	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _high$10[ebp]
  00af7	2b 85 14 ff ff
	ff		 sub	 eax, DWORD PTR _low$9[ebp]
  00afd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_sidedef
  00b03	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00b06	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _textureheight
  00b0c	99		 cdq
  00b0d	f7 3c 8e	 idiv	 DWORD PTR [esi+ecx*4]
  00b10	89 85 1c ff ff
	ff		 mov	 DWORD PTR _repeats$11[ebp], eax

; 1682 : 			}

  00b16	eb 0a		 jmp	 SHORT $LN48@HWR_StoreW
$LN47@HWR_StoreW:

; 1683 : 			else
; 1684 : 				repeats = 1;

  00b18	c7 85 1c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _repeats$11[ebp], 1
$LN48@HWR_StoreW:

; 1685 : 
; 1686 : 			// SoM: a little note: This code re-arranging will
; 1687 : 			// fix the bug in Nimrod map02. popentop and popenbottom
; 1688 : 			// record the limits the texture can be displayed in.
; 1689 : 			// polytop and polybottom, are the ideal (i.e. unclipped)
; 1690 : 			// heights of the polygon, and h & l, are the final (clipped)
; 1691 : 			// poly coords.
; 1692 : 
; 1693 : #ifdef POLYOBJECTS
; 1694 : 			// NOTE: With polyobjects, whenever you need to check the properties of the polyobject sector it belongs to,
; 1695 : 			// you must use the linedef's backsector to be correct
; 1696 : 			// From CB
; 1697 : 			if (gr_curline->polyseg)

  00b22	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00b27	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00b2b	74 1f		 je	 SHORT $LN53@HWR_StoreW

; 1698 : 			{
; 1699 : 				popentop = back->ceilingheight;

  00b2d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _back$19[ebp]
  00b33	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b36	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _popentop$18[ebp], ecx

; 1700 : 				popenbottom = back->floorheight;

  00b3c	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _back$19[ebp]
  00b42	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b44	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _popenbottom$17[ebp], ecx

; 1701 : 			}

  00b4a	eb 7c		 jmp	 SHORT $LN54@HWR_StoreW
$LN53@HWR_StoreW:

; 1702 : #endif
; 1703 : 			else
; 1704 : 			{
; 1705 : 				popentop = front->ceilingheight < back->ceilingheight ? front->ceilingheight : back->ceilingheight;

  00b4c	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00b52	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _back$19[ebp]
  00b58	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00b5b	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00b5e	7d 11		 jge	 SHORT $LN148@HWR_StoreW
  00b60	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00b66	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b69	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv507[ebp], ecx
  00b6f	eb 0f		 jmp	 SHORT $LN149@HWR_StoreW
$LN148@HWR_StoreW:
  00b71	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _back$19[ebp]
  00b77	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00b7a	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv507[ebp], eax
$LN149@HWR_StoreW:
  00b80	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv507[ebp]
  00b86	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _popentop$18[ebp], ecx

; 1706 : 				popenbottom = front->floorheight > back->floorheight ? front->floorheight : back->floorheight;

  00b8c	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00b92	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _back$19[ebp]
  00b98	8b 10		 mov	 edx, DWORD PTR [eax]
  00b9a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00b9c	7e 10		 jle	 SHORT $LN150@HWR_StoreW
  00b9e	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00ba4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ba6	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv513[ebp], ecx
  00bac	eb 0e		 jmp	 SHORT $LN151@HWR_StoreW
$LN150@HWR_StoreW:
  00bae	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _back$19[ebp]
  00bb4	8b 02		 mov	 eax, DWORD PTR [edx]
  00bb6	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv513[ebp], eax
$LN151@HWR_StoreW:
  00bbc	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv513[ebp]
  00bc2	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _popenbottom$17[ebp], ecx
$LN54@HWR_StoreW:

; 1707 : 			}
; 1708 : 
; 1709 : 			if (gr_linedef->flags & ML_DONTPEGBOTTOM)

  00bc8	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00bcd	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00bd1	83 e1 10	 and	 ecx, 16			; 00000010H
  00bd4	74 38		 je	 SHORT $LN55@HWR_StoreW

; 1710 : 			{
; 1711 : 				polybottom = popenbottom + gr_sidedef->rowoffset;

  00bd6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00bdb	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _popenbottom$17[ebp]
  00be1	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00be4	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _polybottom$15[ebp], ecx

; 1712 : 				polytop = polybottom + textureheight[gr_midtexture]*repeats;

  00bea	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _gr_midtexture$[ebp]
  00bf0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textureheight
  00bf6	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00bf9	0f af 95 1c ff
	ff ff		 imul	 edx, DWORD PTR _repeats$11[ebp]
  00c00	03 95 2c ff ff
	ff		 add	 edx, DWORD PTR _polybottom$15[ebp]
  00c06	89 95 30 ff ff
	ff		 mov	 DWORD PTR _polytop$16[ebp], edx

; 1713 : 			}

  00c0c	eb 38		 jmp	 SHORT $LN56@HWR_StoreW
$LN55@HWR_StoreW:

; 1714 : 			else
; 1715 : 			{
; 1716 : 				polytop = popentop + gr_sidedef->rowoffset;

  00c0e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00c13	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _popentop$18[ebp]
  00c19	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00c1c	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _polytop$16[ebp], ecx

; 1717 : 				polybottom = polytop - textureheight[gr_midtexture]*repeats;

  00c22	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _gr_midtexture$[ebp]
  00c28	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _textureheight
  00c2e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00c31	0f af 95 1c ff
	ff ff		 imul	 edx, DWORD PTR _repeats$11[ebp]
  00c38	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _polytop$16[ebp]
  00c3e	2b c2		 sub	 eax, edx
  00c40	89 85 2c ff ff
	ff		 mov	 DWORD PTR _polybottom$15[ebp], eax
$LN56@HWR_StoreW:

; 1718 : 			}
; 1719 : 
; 1720 : 			// CB
; 1721 : #ifdef POLYOBJECTS
; 1722 : 			// NOTE: With polyobjects, whenever you need to check the properties of the polyobject sector it belongs to,
; 1723 : 			// you must use the linedef's backsector to be correct
; 1724 : 			if (gr_curline->polyseg)

  00c46	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_curline
  00c4b	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00c4f	74 1a		 je	 SHORT $LN57@HWR_StoreW

; 1725 : 			{
; 1726 : 				lowcut = polybottom;

  00c51	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _polybottom$15[ebp]
  00c57	89 85 28 ff ff
	ff		 mov	 DWORD PTR _lowcut$14[ebp], eax

; 1727 : 				highcut = polytop;

  00c5d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _polytop$16[ebp]
  00c63	89 85 24 ff ff
	ff		 mov	 DWORD PTR _highcut$13[ebp], eax

; 1728 : 			}

  00c69	eb 7c		 jmp	 SHORT $LN58@HWR_StoreW
$LN57@HWR_StoreW:

; 1729 : #endif
; 1730 : 			else
; 1731 : 			{
; 1732 : 				// The cut-off values of a linedef can always be constant, since every line has an absoulute front and or back sector
; 1733 : 				lowcut = front->floorheight > back->floorheight ? front->floorheight : back->floorheight;

  00c6b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00c71	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _back$19[ebp]
  00c77	8b 10		 mov	 edx, DWORD PTR [eax]
  00c79	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00c7b	7e 10		 jle	 SHORT $LN152@HWR_StoreW
  00c7d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00c83	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c85	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv537[ebp], ecx
  00c8b	eb 0e		 jmp	 SHORT $LN153@HWR_StoreW
$LN152@HWR_StoreW:
  00c8d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _back$19[ebp]
  00c93	8b 02		 mov	 eax, DWORD PTR [edx]
  00c95	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv537[ebp], eax
$LN153@HWR_StoreW:
  00c9b	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv537[ebp]
  00ca1	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _lowcut$14[ebp], ecx

; 1734 : 				highcut = front->ceilingheight < back->ceilingheight ? front->ceilingheight : back->ceilingheight;

  00ca7	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00cad	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _back$19[ebp]
  00cb3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00cb6	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00cb9	7d 11		 jge	 SHORT $LN154@HWR_StoreW
  00cbb	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _front$20[ebp]
  00cc1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00cc4	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv543[ebp], ecx
  00cca	eb 0f		 jmp	 SHORT $LN155@HWR_StoreW
$LN154@HWR_StoreW:
  00ccc	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _back$19[ebp]
  00cd2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00cd5	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv543[ebp], eax
$LN155@HWR_StoreW:
  00cdb	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv543[ebp]
  00ce1	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _highcut$13[ebp], ecx
$LN58@HWR_StoreW:

; 1735 : 			}
; 1736 : 
; 1737 : 			h = polytop > highcut ? highcut : polytop;

  00ce7	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _polytop$16[ebp]
  00ced	3b 85 24 ff ff
	ff		 cmp	 eax, DWORD PTR _highcut$13[ebp]
  00cf3	7e 0e		 jle	 SHORT $LN156@HWR_StoreW
  00cf5	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _highcut$13[ebp]
  00cfb	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv545[ebp], ecx
  00d01	eb 0c		 jmp	 SHORT $LN157@HWR_StoreW
$LN156@HWR_StoreW:
  00d03	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR _polytop$16[ebp]
  00d09	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv545[ebp], edx
$LN157@HWR_StoreW:
  00d0f	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv545[ebp]
  00d15	89 85 68 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax

; 1738 : 			l = polybottom < lowcut ? lowcut : polybottom;

  00d1b	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _polybottom$15[ebp]
  00d21	3b 85 28 ff ff
	ff		 cmp	 eax, DWORD PTR _lowcut$14[ebp]
  00d27	7d 0e		 jge	 SHORT $LN158@HWR_StoreW
  00d29	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _lowcut$14[ebp]
  00d2f	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv547[ebp], ecx
  00d35	eb 0c		 jmp	 SHORT $LN159@HWR_StoreW
$LN158@HWR_StoreW:
  00d37	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _polybottom$15[ebp]
  00d3d	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv547[ebp], edx
$LN159@HWR_StoreW:
  00d43	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv547[ebp]
  00d49	89 85 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], eax

; 1739 : 
; 1740 : 			if (drawtextured)

  00d4f	b8 01 00 00 00	 mov	 eax, 1
  00d54	85 c0		 test	 eax, eax
  00d56	0f 84 89 01 00
	00		 je	 $LN59@HWR_StoreW

; 1741 : 			{
; 1742 : 				// PEGGING
; 1743 : 				if (gr_linedef->flags & ML_DONTPEGBOTTOM)

  00d5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00d61	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00d65	83 e1 10	 and	 ecx, 16			; 00000010H
  00d68	74 2c		 je	 SHORT $LN60@HWR_StoreW

; 1744 : 					texturevpeg = textureheight[gr_sidedef->midtexture]*repeats - h + polybottom;

  00d6a	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  00d6f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00d72	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _textureheight
  00d78	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00d7b	0f af 85 1c ff
	ff ff		 imul	 eax, DWORD PTR _repeats$11[ebp]
  00d82	2b 85 68 ff ff
	ff		 sub	 eax, DWORD PTR _h$[ebp]
  00d88	03 85 2c ff ff
	ff		 add	 eax, DWORD PTR _polybottom$15[ebp]
  00d8e	89 85 20 ff ff
	ff		 mov	 DWORD PTR _texturevpeg$12[ebp], eax
  00d94	eb 12		 jmp	 SHORT $LN61@HWR_StoreW
$LN60@HWR_StoreW:

; 1745 : 				else
; 1746 : 					texturevpeg = polytop - h;

  00d96	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _polytop$16[ebp]
  00d9c	2b 85 68 ff ff
	ff		 sub	 eax, DWORD PTR _h$[ebp]
  00da2	89 85 20 ff ff
	ff		 mov	 DWORD PTR _texturevpeg$12[ebp], eax
$LN61@HWR_StoreW:

; 1747 : 
; 1748 : 				grTex = HWR_GetTexture(gr_midtexture);

  00da8	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _gr_midtexture$[ebp]
  00dae	50		 push	 eax
  00daf	e8 00 00 00 00	 call	 _HWR_GetTexture
  00db4	83 c4 04	 add	 esp, 4
  00db7	89 85 78 ff ff
	ff		 mov	 DWORD PTR _grTex$[ebp], eax

; 1749 : 
; 1750 : 				wallVerts[3].t = wallVerts[2].t = texturevpeg * grTex->scaleY;

  00dbd	f3 0f 2a 85 20
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _texturevpeg$12[ebp]
  00dc5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00dcb	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  00dd0	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv570[ebp], xmm0
  00dd8	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00ddd	d1 e1		 shl	 ecx, 1
  00ddf	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv570[ebp]
  00de7	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  00ded	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00df2	6b c2 03	 imul	 eax, edx, 3
  00df5	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv570[ebp]
  00dfd	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 1751 : 				wallVerts[0].t = wallVerts[1].t = (h - l + texturevpeg) * grTex->scaleY;

  00e03	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  00e09	2b 85 64 ff ff
	ff		 sub	 eax, DWORD PTR _l$[ebp]
  00e0f	03 85 20 ff ff
	ff		 add	 eax, DWORD PTR _texturevpeg$12[ebp]
  00e15	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00e19	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _grTex$[ebp]
  00e1f	f3 0f 59 41 30	 mulss	 xmm0, DWORD PTR [ecx+48]
  00e24	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv581[ebp], xmm0
  00e2c	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00e31	c1 e2 00	 shl	 edx, 0
  00e34	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv581[ebp]
  00e3c	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0
  00e42	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00e47	6b c8 00	 imul	 ecx, eax, 0
  00e4a	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv581[ebp]
  00e52	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0

; 1752 : 				wallVerts[0].s = wallVerts[3].s = cliplow * grTex->scaleX;

  00e58	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00e5e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _cliplow$[ebp]
  00e66	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00e6b	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv589[ebp], xmm0
  00e73	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00e78	6b d1 03	 imul	 edx, ecx, 3
  00e7b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv589[ebp]
  00e83	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
  00e89	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00e8e	6b c8 00	 imul	 ecx, eax, 0
  00e91	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv589[ebp]
  00e99	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 1753 : 				wallVerts[2].s = wallVerts[1].s = cliphigh * grTex->scaleX;

  00e9f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  00ea5	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _cliphigh$[ebp]
  00ead	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00eb2	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv597[ebp], xmm0
  00eba	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00ebf	c1 e1 00	 shl	 ecx, 0
  00ec2	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv597[ebp]
  00eca	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  00ed0	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00ed5	d1 e2		 shl	 edx, 1
  00ed7	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv597[ebp]
  00edf	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
$LN59@HWR_StoreW:

; 1754 : 			}
; 1755 : 
; 1756 : 			// set top/bottom coords
; 1757 : 			// Take the texture peg into account, rather than changing the offsets past
; 1758 : 			// where the polygon might not be.
; 1759 : 			wallVerts[2].y = wallVerts[3].y = FIXED_TO_FLOAT(h);

  00ee5	f3 0f 2a 85 68
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _h$[ebp]
  00eed	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00ef5	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv607[ebp], xmm0
  00efd	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00f02	6b c8 03	 imul	 ecx, eax, 3
  00f05	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv607[ebp]
  00f0d	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  00f13	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00f18	d1 e2		 shl	 edx, 1
  00f1a	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv607[ebp]
  00f22	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1760 : 			wallVerts[0].y = wallVerts[1].y = FIXED_TO_FLOAT(l);

  00f28	f3 0f 2a 85 64
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _l$[ebp]
  00f30	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00f38	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv617[ebp], xmm0
  00f40	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00f45	c1 e0 00	 shl	 eax, 0
  00f48	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv617[ebp]
  00f50	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  00f56	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00f5b	6b d1 00	 imul	 edx, ecx, 0
  00f5e	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv617[ebp]
  00f66	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1761 : 
; 1762 : 			// set alpha for transparent walls (new boom and legacy linedef types)
; 1763 : 			// ooops ! this do not work at all because render order we should render it in backtofront order
; 1764 : 			switch (gr_linedef->special)

  00f6c	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  00f71	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00f75	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv620[ebp], ecx
  00f7b	81 bd ac fe ff
	ff 84 03 00 00	 cmp	 DWORD PTR tv620[ebp], 900 ; 00000384H
  00f85	7f 3f		 jg	 SHORT $LN160@HWR_StoreW
  00f87	81 bd ac fe ff
	ff 84 03 00 00	 cmp	 DWORD PTR tv620[ebp], 900 ; 00000384H
  00f91	74 5f		 je	 SHORT $LN62@HWR_StoreW
  00f93	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv620[ebp]
  00f99	83 ea 66	 sub	 edx, 102		; 00000066H
  00f9c	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv620[ebp], edx
  00fa2	81 bd ac fe ff
	ff 9a 00 00 00	 cmp	 DWORD PTR tv620[ebp], 154 ; 0000009aH
  00fac	0f 87 39 01 00
	00		 ja	 $LN85@HWR_StoreW
  00fb2	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv620[ebp]
  00fb8	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN169@HWR_StoreW[eax]
  00fbf	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN170@HWR_StoreW[ecx*4]
$LN160@HWR_StoreW:
  00fc6	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv620[ebp]
  00fcc	81 ea 85 03 00
	00		 sub	 edx, 901		; 00000385H
  00fd2	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv620[ebp], edx
  00fd8	83 bd ac fe ff
	ff 07		 cmp	 DWORD PTR tv620[ebp], 7
  00fdf	0f 87 06 01 00
	00		 ja	 $LN85@HWR_StoreW
  00fe5	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv620[ebp]
  00feb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN171@HWR_StoreW[eax*4]
$LN62@HWR_StoreW:

; 1765 : 			{
; 1766 : 				case 900:
; 1767 : 					blendmode = HWR_TranstableToAlpha(tr_trans10, &Surf);

  00ff2	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  00ff8	50		 push	 eax
  00ff9	6a 01		 push	 1
  00ffb	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  01000	83 c4 08	 add	 esp, 8
  01003	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1768 : 					break;

  01009	e9 e7 00 00 00	 jmp	 $LN2@HWR_StoreW
$LN63@HWR_StoreW:

; 1769 : 				case 901:
; 1770 : 					blendmode = HWR_TranstableToAlpha(tr_trans20, &Surf);

  0100e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  01014	50		 push	 eax
  01015	6a 02		 push	 2
  01017	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  0101c	83 c4 08	 add	 esp, 8
  0101f	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1771 : 					break;

  01025	e9 cb 00 00 00	 jmp	 $LN2@HWR_StoreW
$LN64@HWR_StoreW:

; 1772 : 				case 902:
; 1773 : 					blendmode = HWR_TranstableToAlpha(tr_trans30, &Surf);

  0102a	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  01030	50		 push	 eax
  01031	6a 03		 push	 3
  01033	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  01038	83 c4 08	 add	 esp, 8
  0103b	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1774 : 					break;

  01041	e9 af 00 00 00	 jmp	 $LN2@HWR_StoreW
$LN65@HWR_StoreW:

; 1775 : 				case 903:
; 1776 : 					blendmode = HWR_TranstableToAlpha(tr_trans40, &Surf);

  01046	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  0104c	50		 push	 eax
  0104d	6a 04		 push	 4
  0104f	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  01054	83 c4 08	 add	 esp, 8
  01057	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1777 : 					break;

  0105d	e9 93 00 00 00	 jmp	 $LN2@HWR_StoreW
$LN66@HWR_StoreW:

; 1778 : 				case 904:
; 1779 : 					blendmode = HWR_TranstableToAlpha(tr_trans50, &Surf);

  01062	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  01068	50		 push	 eax
  01069	6a 05		 push	 5
  0106b	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  01070	83 c4 08	 add	 esp, 8
  01073	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1780 : 					break;

  01079	eb 7a		 jmp	 SHORT $LN2@HWR_StoreW
$LN67@HWR_StoreW:

; 1781 : 				case 905:
; 1782 : 					blendmode = HWR_TranstableToAlpha(tr_trans60, &Surf);

  0107b	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  01081	50		 push	 eax
  01082	6a 06		 push	 6
  01084	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  01089	83 c4 08	 add	 esp, 8
  0108c	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1783 : 					break;

  01092	eb 61		 jmp	 SHORT $LN2@HWR_StoreW
$LN68@HWR_StoreW:

; 1784 : 				case 906:
; 1785 : 					blendmode = HWR_TranstableToAlpha(tr_trans70, &Surf);

  01094	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  0109a	50		 push	 eax
  0109b	6a 07		 push	 7
  0109d	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  010a2	83 c4 08	 add	 esp, 8
  010a5	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1786 : 					break;

  010ab	eb 48		 jmp	 SHORT $LN2@HWR_StoreW
$LN69@HWR_StoreW:

; 1787 : 				case 907:
; 1788 : 					blendmode = HWR_TranstableToAlpha(tr_trans80, &Surf);

  010ad	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  010b3	50		 push	 eax
  010b4	6a 08		 push	 8
  010b6	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  010bb	83 c4 08	 add	 esp, 8
  010be	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1789 : 					break;

  010c4	eb 2f		 jmp	 SHORT $LN2@HWR_StoreW
$LN70@HWR_StoreW:

; 1790 : 				case 908:
; 1791 : 					blendmode = HWR_TranstableToAlpha(tr_trans90, &Surf);

  010c6	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  010cc	50		 push	 eax
  010cd	6a 09		 push	 9
  010cf	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  010d4	83 c4 08	 add	 esp, 8
  010d7	89 85 44 ff ff
	ff		 mov	 DWORD PTR _blendmode$21[ebp], eax

; 1792 : 					break;

  010dd	eb 16		 jmp	 SHORT $LN2@HWR_StoreW
$LN71@HWR_StoreW:

; 1793 : 				//  Translucent
; 1794 : 				case 102:
; 1795 : 				case 121:
; 1796 : 				case 123:
; 1797 : 				case 141:
; 1798 : 				case 142:
; 1799 : 				case 144:
; 1800 : 				case 145:
; 1801 : 				case 174:
; 1802 : 				case 175:
; 1803 : 				case 192:
; 1804 : 				case 195:
; 1805 : 				case 221:
; 1806 : 				case 256:
; 1807 : 				case 253:
; 1808 : 					blendmode = PF_Translucent;

  010df	c7 85 44 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _blendmode$21[ebp], 2

; 1809 : 					break;

  010e9	eb 0a		 jmp	 SHORT $LN2@HWR_StoreW
$LN85@HWR_StoreW:

; 1810 : 				default:
; 1811 : 					blendmode = PF_Masked;

  010eb	c7 85 44 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _blendmode$21[ebp], 1
$LN2@HWR_StoreW:

; 1812 : 					break;
; 1813 : 			}
; 1814 : 			if (grTex->mipmap.flags & TF_TRANSPARENT)

  010f5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  010fb	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  010fe	83 e1 40	 and	 ecx, 64			; 00000040H
  01101	74 0a		 je	 SHORT $LN86@HWR_StoreW

; 1815 : 				blendmode = PF_Environment;

  01103	c7 85 44 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR _blendmode$21[ebp], 8
$LN86@HWR_StoreW:

; 1816 : 
; 1817 : 			if (gr_frontsector->numlights)

  0110d	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01112	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  01119	74 27		 je	 SHORT $LN87@HWR_StoreW

; 1818 : 				HWR_SplitWall(gr_frontsector, wallVerts, gr_midtexture, &Surf, FF_CUTSOLIDS);

  0111b	68 80 00 00 00	 push	 128			; 00000080H
  01120	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  01126	50		 push	 eax
  01127	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _gr_midtexture$[ebp]
  0112d	51		 push	 ecx
  0112e	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  01131	52		 push	 edx
  01132	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01137	50		 push	 eax
  01138	e8 00 00 00 00	 call	 _HWR_SplitWall
  0113d	83 c4 14	 add	 esp, 20			; 00000014H
  01140	eb 66		 jmp	 SHORT $LN90@HWR_StoreW
$LN87@HWR_StoreW:

; 1819 : 			else if (!(blendmode & PF_Masked))

  01142	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _blendmode$21[ebp]
  01148	83 e0 01	 and	 eax, 1
  0114b	75 33		 jne	 SHORT $LN89@HWR_StoreW

; 1820 : 				HWR_AddTransparentWall(wallVerts, &Surf, gr_midtexture, blendmode, false, lightnum, colormap);

  0114d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01153	50		 push	 eax
  01154	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0115a	51		 push	 ecx
  0115b	6a 00		 push	 0
  0115d	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _blendmode$21[ebp]
  01163	52		 push	 edx
  01164	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _gr_midtexture$[ebp]
  0116a	50		 push	 eax
  0116b	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _Surf$[ebp]
  01171	51		 push	 ecx
  01172	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  01175	52		 push	 edx
  01176	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  0117b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0117e	eb 28		 jmp	 SHORT $LN90@HWR_StoreW
$LN89@HWR_StoreW:

; 1821 : 			else
; 1822 : 				HWR_ProjectWall(wallVerts, &Surf, blendmode, lightnum, colormap);

  01180	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01186	50		 push	 eax
  01187	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0118d	51		 push	 ecx
  0118e	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR _blendmode$21[ebp]
  01194	52		 push	 edx
  01195	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  0119b	50		 push	 eax
  0119c	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  0119f	51		 push	 ecx
  011a0	e8 00 00 00 00	 call	 _HWR_ProjectWall
  011a5	83 c4 14	 add	 esp, 20			; 00000014H
$LN90@HWR_StoreW:

; 1823 : 
; 1824 : 			// If there is a colormap change, remove it.
; 1825 : /*			if (!(Surf.FlatColor.s.red + Surf.FlatColor.s.green + Surf.FlatColor.s.blue == Surf.FlatColor.s.red/3)
; 1826 : 			{
; 1827 : 				Surf.FlatColor.s.red = Surf.FlatColor.s.green = Surf.FlatColor.s.blue = 0xff;
; 1828 : 				Surf.FlatColor.rgba = 0xffffffff;
; 1829 : 			}*/
; 1830 : 		}
; 1831 : 	}

  011a8	e9 c1 02 00 00	 jmp	 $LN98@HWR_StoreW
$LN19@HWR_StoreW:

; 1832 : 	else
; 1833 : 	{
; 1834 : 		// Single sided line... Deal only with the middletexture (if one exists)
; 1835 : 		gr_midtexture = texturetranslation[gr_sidedef->midtexture];

  011ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  011b2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  011b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  011bb	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  011be	89 85 6c ff ff
	ff		 mov	 DWORD PTR _gr_midtexture$[ebp], eax

; 1836 : 		if (gr_midtexture)

  011c4	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _gr_midtexture$[ebp], 0
  011cb	0f 84 9d 02 00
	00		 je	 $LN98@HWR_StoreW

; 1837 : 		{
; 1838 : 			if (drawtextured)

  011d1	b8 01 00 00 00	 mov	 eax, 1
  011d6	85 c0		 test	 eax, eax
  011d8	0f 84 7b 01 00
	00		 je	 $LN92@HWR_StoreW

; 1839 : 			{
; 1840 : 				fixed_t     texturevpeg;
; 1841 : 				// PEGGING
; 1842 : 				if (gr_linedef->flags & ML_DONTPEGBOTTOM)

  011de	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_linedef
  011e3	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  011e7	83 e1 10	 and	 ecx, 16			; 00000010H
  011ea	74 28		 je	 SHORT $LN93@HWR_StoreW

; 1843 : 					texturevpeg = worldbottom + textureheight[gr_sidedef->midtexture] - worldtop + gr_sidedef->rowoffset;

  011ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  011f1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  011f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _textureheight
  011fa	8b 45 84	 mov	 eax, DWORD PTR _worldbottom$[ebp]
  011fd	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  01200	2b 45 88	 sub	 eax, DWORD PTR _worldtop$[ebp]
  01203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_sidedef
  01209	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0120c	89 85 10 ff ff
	ff		 mov	 DWORD PTR _texturevpeg$8[ebp], eax
  01212	eb 0e		 jmp	 SHORT $LN94@HWR_StoreW
$LN93@HWR_StoreW:

; 1844 : 				else
; 1845 : 					// top of texture at top
; 1846 : 					texturevpeg = gr_sidedef->rowoffset;

  01214	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_sidedef
  01219	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0121c	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _texturevpeg$8[ebp], ecx
$LN94@HWR_StoreW:

; 1847 : 
; 1848 : 				grTex = HWR_GetTexture(gr_midtexture);

  01222	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _gr_midtexture$[ebp]
  01228	50		 push	 eax
  01229	e8 00 00 00 00	 call	 _HWR_GetTexture
  0122e	83 c4 04	 add	 esp, 4
  01231	89 85 78 ff ff
	ff		 mov	 DWORD PTR _grTex$[ebp], eax

; 1849 : 
; 1850 : 				wallVerts[3].t = wallVerts[2].t = texturevpeg * grTex->scaleY;

  01237	f3 0f 2a 85 10
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _texturevpeg$8[ebp]
  0123f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01245	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  0124a	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv705[ebp], xmm0
  01252	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01257	d1 e1		 shl	 ecx, 1
  01259	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv705[ebp]
  01261	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  01267	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0126c	6b c2 03	 imul	 eax, edx, 3
  0126f	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv705[ebp]
  01277	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 1851 : 				wallVerts[0].t = wallVerts[1].t = (texturevpeg + worldtop - worldbottom) * grTex->scaleY;

  0127d	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _texturevpeg$8[ebp]
  01283	03 45 88	 add	 eax, DWORD PTR _worldtop$[ebp]
  01286	2b 45 84	 sub	 eax, DWORD PTR _worldbottom$[ebp]
  01289	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0128d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _grTex$[ebp]
  01293	f3 0f 59 41 30	 mulss	 xmm0, DWORD PTR [ecx+48]
  01298	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv716[ebp], xmm0
  012a0	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  012a5	c1 e2 00	 shl	 edx, 0
  012a8	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv716[ebp]
  012b0	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0
  012b6	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  012bb	6b c8 00	 imul	 ecx, eax, 0
  012be	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv716[ebp]
  012c6	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0

; 1852 : 				wallVerts[0].s = wallVerts[3].s = cliplow * grTex->scaleX;

  012cc	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  012d2	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _cliplow$[ebp]
  012da	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  012df	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv724[ebp], xmm0
  012e7	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  012ec	6b d1 03	 imul	 edx, ecx, 3
  012ef	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv724[ebp]
  012f7	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
  012fd	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01302	6b c8 00	 imul	 ecx, eax, 0
  01305	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv724[ebp]
  0130d	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 1853 : 				wallVerts[2].s = wallVerts[1].s = cliphigh * grTex->scaleX;

  01313	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01319	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _cliphigh$[ebp]
  01321	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  01326	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv732[ebp], xmm0
  0132e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01333	c1 e1 00	 shl	 ecx, 0
  01336	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv732[ebp]
  0133e	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  01344	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01349	d1 e2		 shl	 edx, 1
  0134b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv732[ebp]
  01353	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
$LN92@HWR_StoreW:

; 1854 : 			}
; 1855 : 			// set top/bottom coords
; 1856 : 			wallVerts[2].y = wallVerts[3].y = FIXED_TO_FLOAT(worldtop);

  01359	f3 0f 2a 45 88	 cvtsi2ss xmm0, DWORD PTR _worldtop$[ebp]
  0135e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  01366	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv742[ebp], xmm0
  0136e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01373	6b c8 03	 imul	 ecx, eax, 3
  01376	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv742[ebp]
  0137e	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  01384	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01389	d1 e2		 shl	 edx, 1
  0138b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv742[ebp]
  01393	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1857 : 			wallVerts[0].y = wallVerts[1].y = FIXED_TO_FLOAT(worldbottom);

  01399	f3 0f 2a 45 84	 cvtsi2ss xmm0, DWORD PTR _worldbottom$[ebp]
  0139e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  013a6	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv752[ebp], xmm0
  013ae	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  013b3	c1 e0 00	 shl	 eax, 0
  013b6	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv752[ebp]
  013be	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  013c4	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  013c9	6b d1 00	 imul	 edx, ecx, 0
  013cc	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv752[ebp]
  013d4	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1858 : 
; 1859 : 			// I don't think that solid walls can use translucent linedef types...
; 1860 : 			if (gr_frontsector->numlights)

  013da	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  013df	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  013e6	74 27		 je	 SHORT $LN95@HWR_StoreW

; 1861 : 				HWR_SplitWall(gr_frontsector, wallVerts, gr_midtexture, &Surf, FF_CUTSOLIDS);

  013e8	68 80 00 00 00	 push	 128			; 00000080H
  013ed	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  013f3	50		 push	 eax
  013f4	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _gr_midtexture$[ebp]
  013fa	51		 push	 ecx
  013fb	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  013fe	52		 push	 edx
  013ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01404	50		 push	 eax
  01405	e8 00 00 00 00	 call	 _HWR_SplitWall
  0140a	83 c4 14	 add	 esp, 20			; 00000014H
  0140d	eb 5f		 jmp	 SHORT $LN98@HWR_StoreW
$LN95@HWR_StoreW:

; 1862 : 			else
; 1863 : 			{
; 1864 : 				if (grTex->mipmap.flags & TF_TRANSPARENT)

  0140f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01415	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01418	83 e1 40	 and	 ecx, 64			; 00000040H
  0141b	74 2e		 je	 SHORT $LN97@HWR_StoreW

; 1865 : 					HWR_AddTransparentWall(wallVerts, &Surf, gr_midtexture, PF_Environment, false, lightnum, colormap);

  0141d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01423	50		 push	 eax
  01424	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0142a	51		 push	 ecx
  0142b	6a 00		 push	 0
  0142d	6a 08		 push	 8
  0142f	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _gr_midtexture$[ebp]
  01435	52		 push	 edx
  01436	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  0143c	50		 push	 eax
  0143d	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  01440	51		 push	 ecx
  01441	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  01446	83 c4 1c	 add	 esp, 28			; 0000001cH
  01449	eb 23		 jmp	 SHORT $LN98@HWR_StoreW
$LN97@HWR_StoreW:

; 1866 : 				else
; 1867 : 					HWR_ProjectWall(wallVerts, &Surf, PF_Masked, lightnum, colormap);

  0144b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01451	50		 push	 eax
  01452	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  01458	51		 push	 ecx
  01459	6a 01		 push	 1
  0145b	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  01461	52		 push	 edx
  01462	8d 45 9c	 lea	 eax, DWORD PTR _wallVerts$[ebp]
  01465	50		 push	 eax
  01466	e8 00 00 00 00	 call	 _HWR_ProjectWall
  0146b	83 c4 14	 add	 esp, 20			; 00000014H
$LN98@HWR_StoreW:

; 1868 : 			}
; 1869 : 		}
; 1870 : 	}
; 1871 : 
; 1872 : 
; 1873 : 	//Hurdler: 3d-floors test
; 1874 : #ifdef R_FAKEFLOORS
; 1875 : 	if (gr_frontsector && gr_backsector && gr_frontsector->tag != gr_backsector->tag && (gr_backsector->ffloors || gr_frontsector->ffloors))

  0146e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_frontsector, 0
  01475	0f 84 f6 0d 00
	00		 je	 $LN8@HWR_StoreW
  0147b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_backsector, 0
  01482	0f 84 e9 0d 00
	00		 je	 $LN8@HWR_StoreW
  01488	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0148d	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  01491	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_backsector
  01497	0f bf 42 14	 movsx	 eax, WORD PTR [edx+20]
  0149b	3b c8		 cmp	 ecx, eax
  0149d	0f 84 ce 0d 00
	00		 je	 $LN8@HWR_StoreW
  014a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  014a8	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  014af	75 12		 jne	 SHORT $LN100@HWR_StoreW
  014b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  014b6	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  014bd	0f 84 ae 0d 00
	00		 je	 $LN8@HWR_StoreW
$LN100@HWR_StoreW:

; 1876 : 	{
; 1877 : 		ffloor_t * rover;
; 1878 : 		ffloor_t * r2;
; 1879 : 		fixed_t    highcut = 0, lowcut = 0;

  014c3	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _highcut$6[ebp], 0
  014cd	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _lowcut$5[ebp], 0

; 1880 : 
; 1881 : 		highcut = gr_frontsector->ceilingheight < gr_backsector->ceilingheight ? gr_frontsector->ceilingheight : gr_backsector->ceilingheight;

  014d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  014dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_backsector
  014e2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  014e5	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  014e8	7d 10		 jge	 SHORT $LN161@HWR_StoreW
  014ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  014ef	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  014f2	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv791[ebp], ecx
  014f8	eb 0f		 jmp	 SHORT $LN162@HWR_StoreW
$LN161@HWR_StoreW:
  014fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_backsector
  01500	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01503	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv791[ebp], eax
$LN162@HWR_StoreW:
  01509	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv791[ebp]
  0150f	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _highcut$6[ebp], ecx

; 1882 : 		lowcut = gr_frontsector->floorheight > gr_backsector->floorheight ? gr_frontsector->floorheight : gr_backsector->floorheight;

  01515	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0151a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gr_backsector
  01520	8b 10		 mov	 edx, DWORD PTR [eax]
  01522	3b 11		 cmp	 edx, DWORD PTR [ecx]
  01524	7e 0f		 jle	 SHORT $LN163@HWR_StoreW
  01526	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  0152b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0152d	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv797[ebp], ecx
  01533	eb 0e		 jmp	 SHORT $LN164@HWR_StoreW
$LN163@HWR_StoreW:
  01535	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_backsector
  0153b	8b 02		 mov	 eax, DWORD PTR [edx]
  0153d	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv797[ebp], eax
$LN164@HWR_StoreW:
  01543	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv797[ebp]
  01549	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _lowcut$5[ebp], ecx

; 1883 : 
; 1884 : 		if (gr_backsector->ffloors)

  0154f	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  01554	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0155b	0f 84 7f 06 00
	00		 je	 $LN5@HWR_StoreW

; 1885 : 		{
; 1886 : 			for (rover = gr_backsector->ffloors; rover; rover = rover->next)

  01561	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  01566	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0156c	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _rover$7[ebp], ecx
  01572	eb 0f		 jmp	 SHORT $LN6@HWR_StoreW
$LN4@HWR_StoreW:
  01574	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  0157a	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0157d	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _rover$7[ebp], ecx
$LN6@HWR_StoreW:
  01583	83 bd 0c ff ff
	ff 00		 cmp	 DWORD PTR _rover$7[ebp], 0
  0158a	0f 84 50 06 00
	00		 je	 $LN5@HWR_StoreW

; 1887 : 			{
; 1888 : 				if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_RENDERSIDES) || (rover->flags & FF_INVERTSIDES))

  01590	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01596	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01599	83 e1 01	 and	 ecx, 1
  0159c	74 1f		 je	 SHORT $LN103@HWR_StoreW
  0159e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  015a4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  015a7	83 e1 08	 and	 ecx, 8
  015aa	74 11		 je	 SHORT $LN103@HWR_StoreW
  015ac	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  015b2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  015b5	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  015bb	74 02		 je	 SHORT $LN102@HWR_StoreW
$LN103@HWR_StoreW:

; 1889 : 					continue;

  015bd	eb b5		 jmp	 SHORT $LN4@HWR_StoreW
$LN102@HWR_StoreW:

; 1890 : 				if (*rover->topheight < lowcut || *rover->bottomheight > highcut)

  015bf	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  015c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  015c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  015c9	3b 95 00 ff ff
	ff		 cmp	 edx, DWORD PTR _lowcut$5[ebp]
  015cf	7c 13		 jl	 SHORT $LN105@HWR_StoreW
  015d1	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  015d7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  015da	8b 11		 mov	 edx, DWORD PTR [ecx]
  015dc	3b 95 04 ff ff
	ff		 cmp	 edx, DWORD PTR _highcut$6[ebp]
  015e2	7e 02		 jle	 SHORT $LN104@HWR_StoreW
$LN105@HWR_StoreW:

; 1891 : 					continue;

  015e4	eb 8e		 jmp	 SHORT $LN4@HWR_StoreW
$LN104@HWR_StoreW:

; 1892 : 
; 1893 : 				h = *rover->topheight;

  015e6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  015ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  015ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  015f0	89 95 68 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], edx

; 1894 : 				l = *rover->bottomheight;

  015f6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  015fc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  015ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  01601	89 95 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], edx

; 1895 : 				if (h > highcut)

  01607	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  0160d	3b 85 04 ff ff
	ff		 cmp	 eax, DWORD PTR _highcut$6[ebp]
  01613	7e 0c		 jle	 SHORT $LN106@HWR_StoreW

; 1896 : 					h = highcut;

  01615	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _highcut$6[ebp]
  0161b	89 85 68 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
$LN106@HWR_StoreW:

; 1897 : 				if (l < lowcut)

  01621	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _l$[ebp]
  01627	3b 85 00 ff ff
	ff		 cmp	 eax, DWORD PTR _lowcut$5[ebp]
  0162d	7d 0c		 jge	 SHORT $LN107@HWR_StoreW

; 1898 : 					l = lowcut;

  0162f	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _lowcut$5[ebp]
  01635	89 85 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], eax
$LN107@HWR_StoreW:

; 1899 : 				//Hurdler: HW code starts here
; 1900 : 				//FIXME: check if peging is correct
; 1901 : 				// set top/bottom coords
; 1902 : 				wallVerts[2].y = wallVerts[3].y = FIXED_TO_FLOAT(h);

  0163b	f3 0f 2a 85 68
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _h$[ebp]
  01643	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0164b	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv833[ebp], xmm0
  01653	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01658	6b c8 03	 imul	 ecx, eax, 3
  0165b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv833[ebp]
  01663	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  01669	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0166e	d1 e2		 shl	 edx, 1
  01670	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv833[ebp]
  01678	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1903 : 				wallVerts[0].y = wallVerts[1].y = FIXED_TO_FLOAT(l);

  0167e	f3 0f 2a 85 64
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _l$[ebp]
  01686	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0168e	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv843[ebp], xmm0
  01696	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0169b	c1 e0 00	 shl	 eax, 0
  0169e	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv843[ebp]
  016a6	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  016ac	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  016b1	6b d1 00	 imul	 edx, ecx, 0
  016b4	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv843[ebp]
  016bc	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1904 : 
; 1905 : 				if (rover->flags & FF_FOG)

  016c2	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  016c8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  016cb	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  016d1	0f 84 8b 00 00
	00		 je	 $LN108@HWR_StoreW

; 1906 : 				{
; 1907 : 					wallVerts[3].t = wallVerts[2].t = 0;

  016d7	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  016dc	d1 e0		 shl	 eax, 1
  016de	0f 57 c0	 xorps	 xmm0, xmm0
  016e1	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  016e7	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  016ec	6b d1 03	 imul	 edx, ecx, 3
  016ef	0f 57 c0	 xorps	 xmm0, xmm0
  016f2	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0

; 1908 : 					wallVerts[0].t = wallVerts[1].t = 0;

  016f8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  016fd	c1 e0 00	 shl	 eax, 0
  01700	0f 57 c0	 xorps	 xmm0, xmm0
  01703	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  01709	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0170e	6b d1 00	 imul	 edx, ecx, 0
  01711	0f 57 c0	 xorps	 xmm0, xmm0
  01714	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0

; 1909 : 					wallVerts[0].s = wallVerts[3].s = 0;

  0171a	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0171f	6b c8 03	 imul	 ecx, eax, 3
  01722	0f 57 c0	 xorps	 xmm0, xmm0
  01725	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  0172b	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01730	6b c2 00	 imul	 eax, edx, 0
  01733	0f 57 c0	 xorps	 xmm0, xmm0
  01736	f3 0f 11 44 05
	a8		 movss	 DWORD PTR _wallVerts$[ebp+eax+12], xmm0

; 1910 : 					wallVerts[2].s = wallVerts[1].s = 0;

  0173c	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01741	c1 e0 00	 shl	 eax, 0
  01744	0f 57 c0	 xorps	 xmm0, xmm0
  01747	f3 0f 11 44 05
	a8		 movss	 DWORD PTR _wallVerts$[ebp+eax+12], xmm0
  0174d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01752	d1 e1		 shl	 ecx, 1
  01754	0f 57 c0	 xorps	 xmm0, xmm0
  01757	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 1911 : 				}

  0175d	e9 cd 01 00 00	 jmp	 $LN110@HWR_StoreW
$LN108@HWR_StoreW:

; 1912 : 				else if (drawtextured)

  01762	b8 01 00 00 00	 mov	 eax, 1
  01767	85 c0		 test	 eax, eax
  01769	0f 84 c0 01 00
	00		 je	 $LN110@HWR_StoreW

; 1913 : 				{
; 1914 : 					grTex = HWR_GetTexture(texturetranslation[sides[rover->master->sidenum[0]].midtexture]);

  0176f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01775	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01778	ba 02 00 00 00	 mov	 edx, 2
  0177d	6b c2 00	 imul	 eax, edx, 0
  01780	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  01785	6b d1 1c	 imul	 edx, ecx, 28
  01788	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  0178d	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  01791	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  01797	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0179a	50		 push	 eax
  0179b	e8 00 00 00 00	 call	 _HWR_GetTexture
  017a0	83 c4 04	 add	 esp, 4
  017a3	89 85 78 ff ff
	ff		 mov	 DWORD PTR _grTex$[ebp], eax

; 1915 : 
; 1916 : 					wallVerts[3].t = wallVerts[2].t = (*rover->topheight - h + sides[rover->master->sidenum[0]].rowoffset) * grTex->scaleY;

  017a9	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  017af	8b 08		 mov	 ecx, DWORD PTR [eax]
  017b1	8b 11		 mov	 edx, DWORD PTR [ecx]
  017b3	2b 95 68 ff ff
	ff		 sub	 edx, DWORD PTR _h$[ebp]
  017b9	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  017bf	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  017c2	b8 02 00 00 00	 mov	 eax, 2
  017c7	6b c0 00	 imul	 eax, eax, 0
  017ca	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  017cf	6b c1 1c	 imul	 eax, ecx, 28
  017d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  017d8	03 54 01 04	 add	 edx, DWORD PTR [ecx+eax+4]
  017dc	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  017e0	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _grTex$[ebp]
  017e6	f3 0f 59 42 30	 mulss	 xmm0, DWORD PTR [edx+48]
  017eb	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv904[ebp], xmm0
  017f3	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  017f8	d1 e0		 shl	 eax, 1
  017fa	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv904[ebp]
  01802	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  01808	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0180d	6b d1 03	 imul	 edx, ecx, 3
  01810	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv904[ebp]
  01818	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0

; 1917 : 					wallVerts[0].t = wallVerts[1].t = (h - l + (*rover->topheight - h + sides[rover->master->sidenum[0]].rowoffset)) * grTex->scaleY;

  0181e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  01824	2b 85 64 ff ff
	ff		 sub	 eax, DWORD PTR _l$[ebp]
  0182a	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _rover$7[ebp]
  01830	8b 11		 mov	 edx, DWORD PTR [ecx]
  01832	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01834	2b 8d 68 ff ff
	ff		 sub	 ecx, DWORD PTR _h$[ebp]
  0183a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  01840	8b 52 38	 mov	 edx, DWORD PTR [edx+56]
  01843	be 02 00 00 00	 mov	 esi, 2
  01848	6b f6 00	 imul	 esi, esi, 0
  0184b	0f b7 54 32 16	 movzx	 edx, WORD PTR [edx+esi+22]
  01850	6b d2 1c	 imul	 edx, edx, 28
  01853	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sides
  01859	03 44 16 04	 add	 eax, DWORD PTR [esi+edx+4]
  0185d	03 c8		 add	 ecx, eax
  0185f	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  01863	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01869	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  0186e	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv927[ebp], xmm0
  01876	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0187b	c1 e1 00	 shl	 ecx, 0
  0187e	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv927[ebp]
  01886	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  0188c	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01891	6b c2 00	 imul	 eax, edx, 0
  01894	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv927[ebp]
  0189c	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 1918 : 					wallVerts[0].s = wallVerts[3].s = cliplow * grTex->scaleX;

  018a2	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  018a8	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _cliplow$[ebp]
  018b0	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  018b5	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv935[ebp], xmm0
  018bd	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  018c2	6b d1 03	 imul	 edx, ecx, 3
  018c5	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv935[ebp]
  018cd	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
  018d3	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  018d8	6b c8 00	 imul	 ecx, eax, 0
  018db	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv935[ebp]
  018e3	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 1919 : 					wallVerts[2].s = wallVerts[1].s = cliphigh * grTex->scaleX;

  018e9	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  018ef	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _cliphigh$[ebp]
  018f7	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  018fc	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv943[ebp], xmm0
  01904	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01909	c1 e1 00	 shl	 ecx, 0
  0190c	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv943[ebp]
  01914	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  0191a	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0191f	d1 e2		 shl	 edx, 1
  01921	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv943[ebp]
  01929	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
$LN110@HWR_StoreW:

; 1920 : 				}
; 1921 : 
; 1922 : 				if (rover->flags & FF_FOG)

  0192f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01935	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01938	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  0193e	0f 84 32 01 00
	00		 je	 $LN111@HWR_StoreW

; 1923 : 				{
; 1924 : 					FBITFIELD blendmode;
; 1925 : 
; 1926 : 					blendmode = PF_Translucent|PF_NoTexture;

  01944	c7 85 fc fe ff
	ff 02 20 00 00	 mov	 DWORD PTR _blendmode$4[ebp], 8194 ; 00002002H

; 1927 : 
; 1928 : 					lightnum = rover->master->frontsector->lightlevel;

  0194e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01954	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01957	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0195a	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  0195e	89 85 60 ff ff
	ff		 mov	 DWORD PTR _lightnum$[ebp], eax

; 1929 : 					colormap = rover->master->frontsector->extra_colormap;

  01964	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  0196a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0196d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  01970	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  01976	89 85 5c ff ff
	ff		 mov	 DWORD PTR _colormap$[ebp], eax

; 1930 : 
; 1931 : 					if (rover->master->frontsector->extra_colormap)

  0197c	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01982	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01985	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  01988	83 ba b0 00 00
	00 00		 cmp	 DWORD PTR [edx+176], 0
  0198f	74 4d		 je	 SHORT $LN113@HWR_StoreW

; 1932 : 					{
; 1933 : 
; 1934 : 						Surf.FlatColor.s.alpha = HWR_FogBlockAlpha(rover->master->frontsector->lightlevel,rover->master->frontsector->extra_colormap->rgba,rover->master->frontsector->extra_colormap->fadergba);

  01991	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01997	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0199a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0199d	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  019a3	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  019a6	51		 push	 ecx
  019a7	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  019ad	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  019b0	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  019b3	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  019b9	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  019bc	50		 push	 eax
  019bd	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _rover$7[ebp]
  019c3	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  019c6	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  019c9	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  019cd	51		 push	 ecx
  019ce	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  019d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  019d6	88 85 5b ff ff
	ff		 mov	 BYTE PTR _Surf$[ebp+7], al

; 1935 : 					}

  019dc	eb 26		 jmp	 SHORT $LN114@HWR_StoreW
$LN113@HWR_StoreW:

; 1936 : 					else
; 1937 : 					{
; 1938 : 						Surf.FlatColor.s.alpha = HWR_FogBlockAlpha(rover->master->frontsector->lightlevel,NORMALFOG,FADEFOG);

  019de	68 00 00 00 19	 push	 419430400		; 19000000H
  019e3	6a 00		 push	 0
  019e5	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  019eb	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  019ee	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  019f1	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  019f5	50		 push	 eax
  019f6	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  019fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  019fe	88 85 5b ff ff
	ff		 mov	 BYTE PTR _Surf$[ebp+7], al
$LN114@HWR_StoreW:

; 1939 : 					}
; 1940 : 
; 1941 : 					if (gr_frontsector->numlights)

  01a04	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01a09	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  01a10	74 33		 je	 SHORT $LN115@HWR_StoreW

; 1942 : 						HWR_SplitFog(gr_frontsector, wallVerts, &Surf, rover->flags, lightnum, colormap);

  01a12	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01a18	50		 push	 eax
  01a19	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  01a1f	51		 push	 ecx
  01a20	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  01a26	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01a29	50		 push	 eax
  01a2a	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _Surf$[ebp]
  01a30	51		 push	 ecx
  01a31	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  01a34	52		 push	 edx
  01a35	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01a3a	50		 push	 eax
  01a3b	e8 00 00 00 00	 call	 _HWR_SplitFog
  01a40	83 c4 18	 add	 esp, 24			; 00000018H
  01a43	eb 2c		 jmp	 SHORT $LN116@HWR_StoreW
$LN115@HWR_StoreW:

; 1943 : 					else
; 1944 : 						HWR_AddTransparentWall(wallVerts, &Surf, 0, blendmode, true, lightnum, colormap);

  01a45	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01a4b	50		 push	 eax
  01a4c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  01a52	51		 push	 ecx
  01a53	6a 01		 push	 1
  01a55	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _blendmode$4[ebp]
  01a5b	52		 push	 edx
  01a5c	6a 00		 push	 0
  01a5e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  01a64	50		 push	 eax
  01a65	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  01a68	51		 push	 ecx
  01a69	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  01a6e	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN116@HWR_StoreW:

; 1945 : 				}

  01a71	e9 65 01 00 00	 jmp	 $LN123@HWR_StoreW
$LN111@HWR_StoreW:

; 1946 : 				else
; 1947 : 				{
; 1948 : 					FBITFIELD blendmode = PF_Masked;

  01a76	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _blendmode$3[ebp], 1

; 1949 : 
; 1950 : 					if (rover->flags & FF_TRANSLUCENT)

  01a80	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01a86	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01a89	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  01a8f	74 4b		 je	 SHORT $LN117@HWR_StoreW

; 1951 : 					{
; 1952 : 						blendmode = PF_Translucent;

  01a91	c7 85 f8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _blendmode$3[ebp], 2

; 1953 : 						Surf.FlatColor.s.alpha = (UINT8)rover->alpha-1 > 255 ? 255 : rover->alpha-1;

  01a9b	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01aa1	0f b6 48 4c	 movzx	 ecx, BYTE PTR [eax+76]
  01aa5	83 e9 01	 sub	 ecx, 1
  01aa8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01aae	7e 0c		 jle	 SHORT $LN165@HWR_StoreW
  01ab0	c7 85 ac fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1007[ebp], 255 ; 000000ffH
  01aba	eb 12		 jmp	 SHORT $LN166@HWR_StoreW
$LN165@HWR_StoreW:
  01abc	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  01ac2	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  01ac5	83 e8 01	 sub	 eax, 1
  01ac8	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv1007[ebp], eax
$LN166@HWR_StoreW:
  01ace	8a 8d ac fe ff
	ff		 mov	 cl, BYTE PTR tv1007[ebp]
  01ad4	88 8d 5b ff ff
	ff		 mov	 BYTE PTR _Surf$[ebp+7], cl

; 1954 : 					}

  01ada	eb 18		 jmp	 SHORT $LN119@HWR_StoreW
$LN117@HWR_StoreW:

; 1955 : 					else if (grTex->mipmap.flags & TF_TRANSPARENT)

  01adc	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01ae2	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01ae5	83 e1 40	 and	 ecx, 64			; 00000040H
  01ae8	74 0a		 je	 SHORT $LN119@HWR_StoreW

; 1956 : 					{
; 1957 : 						blendmode = PF_Environment;

  01aea	c7 85 f8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _blendmode$3[ebp], 8
$LN119@HWR_StoreW:

; 1958 : 					}
; 1959 : 
; 1960 : 					if (gr_frontsector->numlights)

  01af4	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01af9	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  01b00	74 55		 je	 SHORT $LN120@HWR_StoreW

; 1961 : 						HWR_SplitWall(gr_frontsector, wallVerts, texturetranslation[sides[rover->master->sidenum[0]].midtexture], &Surf, rover->flags);

  01b02	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01b08	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01b0b	51		 push	 ecx
  01b0c	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  01b12	52		 push	 edx
  01b13	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01b19	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01b1c	ba 02 00 00 00	 mov	 edx, 2
  01b21	6b c2 00	 imul	 eax, edx, 0
  01b24	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  01b29	6b d1 1c	 imul	 edx, ecx, 28
  01b2c	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  01b31	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  01b35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  01b3b	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  01b3e	50		 push	 eax
  01b3f	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  01b42	51		 push	 ecx
  01b43	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_frontsector
  01b49	52		 push	 edx
  01b4a	e8 00 00 00 00	 call	 _HWR_SplitWall
  01b4f	83 c4 14	 add	 esp, 20			; 00000014H
  01b52	e9 84 00 00 00	 jmp	 $LN123@HWR_StoreW
$LN120@HWR_StoreW:

; 1962 : 					else
; 1963 : 					{
; 1964 : 						if (blendmode != PF_Masked)

  01b57	83 bd f8 fe ff
	ff 01		 cmp	 DWORD PTR _blendmode$3[ebp], 1
  01b5e	74 58		 je	 SHORT $LN122@HWR_StoreW

; 1965 : 							HWR_AddTransparentWall(wallVerts, &Surf, texturetranslation[sides[rover->master->sidenum[0]].midtexture], blendmode, false, lightnum, colormap);

  01b60	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01b66	50		 push	 eax
  01b67	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  01b6d	51		 push	 ecx
  01b6e	6a 00		 push	 0
  01b70	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _blendmode$3[ebp]
  01b76	52		 push	 edx
  01b77	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01b7d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01b80	ba 02 00 00 00	 mov	 edx, 2
  01b85	6b c2 00	 imul	 eax, edx, 0
  01b88	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  01b8d	6b d1 1c	 imul	 edx, ecx, 28
  01b90	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  01b95	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  01b99	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  01b9f	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  01ba2	50		 push	 eax
  01ba3	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _Surf$[ebp]
  01ba9	51		 push	 ecx
  01baa	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  01bad	52		 push	 edx
  01bae	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  01bb3	83 c4 1c	 add	 esp, 28			; 0000001cH
  01bb6	eb 23		 jmp	 SHORT $LN123@HWR_StoreW
$LN122@HWR_StoreW:

; 1966 : 						else
; 1967 : 							HWR_ProjectWall(wallVerts, &Surf, PF_Masked, lightnum, colormap);

  01bb8	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  01bbe	50		 push	 eax
  01bbf	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  01bc5	51		 push	 ecx
  01bc6	6a 01		 push	 1
  01bc8	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  01bce	52		 push	 edx
  01bcf	8d 45 9c	 lea	 eax, DWORD PTR _wallVerts$[ebp]
  01bd2	50		 push	 eax
  01bd3	e8 00 00 00 00	 call	 _HWR_ProjectWall
  01bd8	83 c4 14	 add	 esp, 20			; 00000014H
$LN123@HWR_StoreW:

; 1968 : 					}
; 1969 : 				}
; 1970 : 			}

  01bdb	e9 94 f9 ff ff	 jmp	 $LN4@HWR_StoreW
$LN5@HWR_StoreW:

; 1971 : 		}
; 1972 : 
; 1973 : 		if (gr_frontsector->ffloors) // Putting this seperate should allow 2 FOF sectors to be connected without too many errors? I think?

  01be0	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01be5	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  01bec	0f 84 7f 06 00
	00		 je	 $LN8@HWR_StoreW

; 1974 : 		{
; 1975 : 			for (rover = gr_frontsector->ffloors; rover; rover = rover->next)

  01bf2	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  01bf7	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  01bfd	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _rover$7[ebp], ecx
  01c03	eb 0f		 jmp	 SHORT $LN9@HWR_StoreW
$LN7@HWR_StoreW:
  01c05	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c0b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01c0e	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _rover$7[ebp], ecx
$LN9@HWR_StoreW:
  01c14	83 bd 0c ff ff
	ff 00		 cmp	 DWORD PTR _rover$7[ebp], 0
  01c1b	0f 84 50 06 00
	00		 je	 $LN8@HWR_StoreW

; 1976 : 			{
; 1977 : 				if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_RENDERSIDES) || !(rover->flags & FF_ALLSIDES))

  01c21	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c27	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01c2a	83 e1 01	 and	 ecx, 1
  01c2d	74 1f		 je	 SHORT $LN126@HWR_StoreW
  01c2f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c35	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01c38	83 e1 08	 and	 ecx, 8
  01c3b	74 11		 je	 SHORT $LN126@HWR_StoreW
  01c3d	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c43	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01c46	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  01c4c	75 02		 jne	 SHORT $LN125@HWR_StoreW
$LN126@HWR_StoreW:

; 1978 : 					continue;

  01c4e	eb b5		 jmp	 SHORT $LN7@HWR_StoreW
$LN125@HWR_StoreW:

; 1979 : 				if (*rover->topheight < lowcut || *rover->bottomheight > highcut)

  01c50	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c56	8b 08		 mov	 ecx, DWORD PTR [eax]
  01c58	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c5a	3b 95 00 ff ff
	ff		 cmp	 edx, DWORD PTR _lowcut$5[ebp]
  01c60	7c 13		 jl	 SHORT $LN128@HWR_StoreW
  01c62	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c68	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01c6b	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c6d	3b 95 04 ff ff
	ff		 cmp	 edx, DWORD PTR _highcut$6[ebp]
  01c73	7e 02		 jle	 SHORT $LN127@HWR_StoreW
$LN128@HWR_StoreW:

; 1980 : 					continue;

  01c75	eb 8e		 jmp	 SHORT $LN7@HWR_StoreW
$LN127@HWR_StoreW:

; 1981 : 
; 1982 : 				h = *rover->topheight;

  01c77	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c7d	8b 08		 mov	 ecx, DWORD PTR [eax]
  01c7f	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c81	89 95 68 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], edx

; 1983 : 				l = *rover->bottomheight;

  01c87	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01c8d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01c90	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c92	89 95 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], edx

; 1984 : 				if (h > highcut)

  01c98	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  01c9e	3b 85 04 ff ff
	ff		 cmp	 eax, DWORD PTR _highcut$6[ebp]
  01ca4	7e 0c		 jle	 SHORT $LN129@HWR_StoreW

; 1985 : 					h = highcut;

  01ca6	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _highcut$6[ebp]
  01cac	89 85 68 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
$LN129@HWR_StoreW:

; 1986 : 				if (l < lowcut)

  01cb2	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _l$[ebp]
  01cb8	3b 85 00 ff ff
	ff		 cmp	 eax, DWORD PTR _lowcut$5[ebp]
  01cbe	7d 0c		 jge	 SHORT $LN130@HWR_StoreW

; 1987 : 					l = lowcut;

  01cc0	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _lowcut$5[ebp]
  01cc6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _l$[ebp], eax
$LN130@HWR_StoreW:

; 1988 : 				//Hurdler: HW code starts here
; 1989 : 				//FIXME: check if peging is correct
; 1990 : 				// set top/bottom coords
; 1991 : 				wallVerts[2].y = wallVerts[3].y = FIXED_TO_FLOAT(h);

  01ccc	f3 0f 2a 85 68
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _h$[ebp]
  01cd4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  01cdc	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv1088[ebp], xmm0
  01ce4	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01ce9	6b c8 03	 imul	 ecx, eax, 3
  01cec	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1088[ebp]
  01cf4	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _wallVerts$[ebp+ecx+4], xmm0
  01cfa	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01cff	d1 e2		 shl	 edx, 1
  01d01	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1088[ebp]
  01d09	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1992 : 				wallVerts[0].y = wallVerts[1].y = FIXED_TO_FLOAT(l);

  01d0f	f3 0f 2a 85 64
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _l$[ebp]
  01d17	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  01d1f	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv1098[ebp], xmm0
  01d27	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01d2c	c1 e0 00	 shl	 eax, 0
  01d2f	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1098[ebp]
  01d37	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _wallVerts$[ebp+eax+4], xmm0
  01d3d	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01d42	6b d1 00	 imul	 edx, ecx, 0
  01d45	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1098[ebp]
  01d4d	f3 0f 11 44 15
	a0		 movss	 DWORD PTR _wallVerts$[ebp+edx+4], xmm0

; 1993 : 
; 1994 : 				if (rover->flags & FF_FOG)

  01d53	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01d59	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01d5c	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  01d62	0f 84 8b 00 00
	00		 je	 $LN131@HWR_StoreW

; 1995 : 				{
; 1996 : 					wallVerts[3].t = wallVerts[2].t = 0;

  01d68	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01d6d	d1 e0		 shl	 eax, 1
  01d6f	0f 57 c0	 xorps	 xmm0, xmm0
  01d72	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  01d78	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01d7d	6b d1 03	 imul	 edx, ecx, 3
  01d80	0f 57 c0	 xorps	 xmm0, xmm0
  01d83	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0

; 1997 : 					wallVerts[0].t = wallVerts[1].t = 0;

  01d89	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01d8e	c1 e0 00	 shl	 eax, 0
  01d91	0f 57 c0	 xorps	 xmm0, xmm0
  01d94	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  01d9a	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01d9f	6b d1 00	 imul	 edx, ecx, 0
  01da2	0f 57 c0	 xorps	 xmm0, xmm0
  01da5	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0

; 1998 : 					wallVerts[0].s = wallVerts[3].s = 0;

  01dab	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01db0	6b c8 03	 imul	 ecx, eax, 3
  01db3	0f 57 c0	 xorps	 xmm0, xmm0
  01db6	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  01dbc	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01dc1	6b c2 00	 imul	 eax, edx, 0
  01dc4	0f 57 c0	 xorps	 xmm0, xmm0
  01dc7	f3 0f 11 44 05
	a8		 movss	 DWORD PTR _wallVerts$[ebp+eax+12], xmm0

; 1999 : 					wallVerts[2].s = wallVerts[1].s = 0;

  01dcd	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01dd2	c1 e0 00	 shl	 eax, 0
  01dd5	0f 57 c0	 xorps	 xmm0, xmm0
  01dd8	f3 0f 11 44 05
	a8		 movss	 DWORD PTR _wallVerts$[ebp+eax+12], xmm0
  01dde	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01de3	d1 e1		 shl	 ecx, 1
  01de5	0f 57 c0	 xorps	 xmm0, xmm0
  01de8	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 2000 : 				}

  01dee	e9 cd 01 00 00	 jmp	 $LN133@HWR_StoreW
$LN131@HWR_StoreW:

; 2001 : 				else if (drawtextured)

  01df3	b8 01 00 00 00	 mov	 eax, 1
  01df8	85 c0		 test	 eax, eax
  01dfa	0f 84 c0 01 00
	00		 je	 $LN133@HWR_StoreW

; 2002 : 				{
; 2003 : 					grTex = HWR_GetTexture(texturetranslation[sides[rover->master->sidenum[0]].midtexture]);

  01e00	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01e06	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01e09	ba 02 00 00 00	 mov	 edx, 2
  01e0e	6b c2 00	 imul	 eax, edx, 0
  01e11	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  01e16	6b d1 1c	 imul	 edx, ecx, 28
  01e19	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  01e1e	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  01e22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  01e28	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  01e2b	50		 push	 eax
  01e2c	e8 00 00 00 00	 call	 _HWR_GetTexture
  01e31	83 c4 04	 add	 esp, 4
  01e34	89 85 78 ff ff
	ff		 mov	 DWORD PTR _grTex$[ebp], eax

; 2004 : 
; 2005 : 					wallVerts[3].t = wallVerts[2].t = (*rover->topheight - h + sides[rover->master->sidenum[0]].rowoffset) * grTex->scaleY;

  01e3a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01e40	8b 08		 mov	 ecx, DWORD PTR [eax]
  01e42	8b 11		 mov	 edx, DWORD PTR [ecx]
  01e44	2b 95 68 ff ff
	ff		 sub	 edx, DWORD PTR _h$[ebp]
  01e4a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01e50	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01e53	b8 02 00 00 00	 mov	 eax, 2
  01e58	6b c0 00	 imul	 eax, eax, 0
  01e5b	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  01e60	6b c1 1c	 imul	 eax, ecx, 28
  01e63	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  01e69	03 54 01 04	 add	 edx, DWORD PTR [ecx+eax+4]
  01e6d	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  01e71	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _grTex$[ebp]
  01e77	f3 0f 59 42 30	 mulss	 xmm0, DWORD PTR [edx+48]
  01e7c	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv1159[ebp], xmm0
  01e84	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01e89	d1 e0		 shl	 eax, 1
  01e8b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1159[ebp]
  01e93	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0
  01e99	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01e9e	6b d1 03	 imul	 edx, ecx, 3
  01ea1	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1159[ebp]
  01ea9	f3 0f 11 44 15
	ac		 movss	 DWORD PTR _wallVerts$[ebp+edx+16], xmm0

; 2006 : 					wallVerts[0].t = wallVerts[1].t = (h - l + (*rover->topheight - h + sides[rover->master->sidenum[0]].rowoffset)) * grTex->scaleY;

  01eaf	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  01eb5	2b 85 64 ff ff
	ff		 sub	 eax, DWORD PTR _l$[ebp]
  01ebb	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _rover$7[ebp]
  01ec1	8b 11		 mov	 edx, DWORD PTR [ecx]
  01ec3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01ec5	2b 8d 68 ff ff
	ff		 sub	 ecx, DWORD PTR _h$[ebp]
  01ecb	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  01ed1	8b 52 38	 mov	 edx, DWORD PTR [edx+56]
  01ed4	be 02 00 00 00	 mov	 esi, 2
  01ed9	6b f6 00	 imul	 esi, esi, 0
  01edc	0f b7 54 32 16	 movzx	 edx, WORD PTR [edx+esi+22]
  01ee1	6b d2 1c	 imul	 edx, edx, 28
  01ee4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sides
  01eea	03 44 16 04	 add	 eax, DWORD PTR [esi+edx+4]
  01eee	03 c8		 add	 ecx, eax
  01ef0	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  01ef4	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01efa	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  01eff	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv1182[ebp], xmm0
  01f07	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01f0c	c1 e1 00	 shl	 ecx, 0
  01f0f	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1182[ebp]
  01f17	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _wallVerts$[ebp+ecx+16], xmm0
  01f1d	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01f22	6b c2 00	 imul	 eax, edx, 0
  01f25	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1182[ebp]
  01f2d	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _wallVerts$[ebp+eax+16], xmm0

; 2007 : 					wallVerts[0].s = wallVerts[3].s = cliplow * grTex->scaleX;

  01f33	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01f39	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _cliplow$[ebp]
  01f41	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  01f46	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv1190[ebp], xmm0
  01f4e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01f53	6b d1 03	 imul	 edx, ecx, 3
  01f56	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1190[ebp]
  01f5e	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
  01f64	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01f69	6b c8 00	 imul	 ecx, eax, 0
  01f6c	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1190[ebp]
  01f74	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0

; 2008 : 					wallVerts[2].s = wallVerts[1].s = cliphigh * grTex->scaleX;

  01f7a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  01f80	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _cliphigh$[ebp]
  01f88	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  01f8d	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR tv1198[ebp], xmm0
  01f95	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  01f9a	c1 e1 00	 shl	 ecx, 0
  01f9d	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1198[ebp]
  01fa5	f3 0f 11 44 0d
	a8		 movss	 DWORD PTR _wallVerts$[ebp+ecx+12], xmm0
  01fab	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  01fb0	d1 e2		 shl	 edx, 1
  01fb2	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR tv1198[ebp]
  01fba	f3 0f 11 44 15
	a8		 movss	 DWORD PTR _wallVerts$[ebp+edx+12], xmm0
$LN133@HWR_StoreW:

; 2009 : 				}
; 2010 : 
; 2011 : 				if (rover->flags & FF_FOG)

  01fc0	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01fc6	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01fc9	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  01fcf	0f 84 32 01 00
	00		 je	 $LN134@HWR_StoreW

; 2012 : 				{
; 2013 : 					FBITFIELD blendmode;
; 2014 : 
; 2015 : 					blendmode = PF_Translucent|PF_NoTexture;

  01fd5	c7 85 f4 fe ff
	ff 02 20 00 00	 mov	 DWORD PTR _blendmode$2[ebp], 8194 ; 00002002H

; 2016 : 
; 2017 : 					lightnum = rover->master->frontsector->lightlevel;

  01fdf	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01fe5	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01fe8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  01feb	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  01fef	89 85 60 ff ff
	ff		 mov	 DWORD PTR _lightnum$[ebp], eax

; 2018 : 					colormap = rover->master->frontsector->extra_colormap;

  01ff5	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  01ffb	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01ffe	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  02001	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  02007	89 85 5c ff ff
	ff		 mov	 DWORD PTR _colormap$[ebp], eax

; 2019 : 
; 2020 : 					if (rover->master->frontsector->extra_colormap)

  0200d	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  02013	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  02016	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  02019	83 ba b0 00 00
	00 00		 cmp	 DWORD PTR [edx+176], 0
  02020	74 4d		 je	 SHORT $LN136@HWR_StoreW

; 2021 : 					{
; 2022 : 						Surf.FlatColor.s.alpha = HWR_FogBlockAlpha(rover->master->frontsector->lightlevel,rover->master->frontsector->extra_colormap->rgba,rover->master->frontsector->extra_colormap->fadergba);

  02022	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  02028	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0202b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0202e	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  02034	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02037	51		 push	 ecx
  02038	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  0203e	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  02041	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  02044	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0204a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0204d	50		 push	 eax
  0204e	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _rover$7[ebp]
  02054	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  02057	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0205a	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0205e	51		 push	 ecx
  0205f	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  02064	83 c4 0c	 add	 esp, 12			; 0000000cH
  02067	88 85 5b ff ff
	ff		 mov	 BYTE PTR _Surf$[ebp+7], al

; 2023 : 					}

  0206d	eb 26		 jmp	 SHORT $LN137@HWR_StoreW
$LN136@HWR_StoreW:

; 2024 : 					else
; 2025 : 					{
; 2026 : 						Surf.FlatColor.s.alpha = HWR_FogBlockAlpha(rover->master->frontsector->lightlevel,NORMALFOG,FADEFOG);

  0206f	68 00 00 00 19	 push	 419430400		; 19000000H
  02074	6a 00		 push	 0
  02076	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  0207c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0207f	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  02082	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  02086	50		 push	 eax
  02087	e8 00 00 00 00	 call	 _HWR_FogBlockAlpha
  0208c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0208f	88 85 5b ff ff
	ff		 mov	 BYTE PTR _Surf$[ebp+7], al
$LN137@HWR_StoreW:

; 2027 : 					}
; 2028 : 
; 2029 : 					if (gr_backsector->numlights)

  02095	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  0209a	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  020a1	74 33		 je	 SHORT $LN138@HWR_StoreW

; 2030 : 						HWR_SplitFog(gr_backsector, wallVerts, &Surf, rover->flags, lightnum, colormap);

  020a3	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  020a9	50		 push	 eax
  020aa	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  020b0	51		 push	 ecx
  020b1	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  020b7	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  020ba	50		 push	 eax
  020bb	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _Surf$[ebp]
  020c1	51		 push	 ecx
  020c2	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  020c5	52		 push	 edx
  020c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  020cb	50		 push	 eax
  020cc	e8 00 00 00 00	 call	 _HWR_SplitFog
  020d1	83 c4 18	 add	 esp, 24			; 00000018H
  020d4	eb 2c		 jmp	 SHORT $LN139@HWR_StoreW
$LN138@HWR_StoreW:

; 2031 : 					else
; 2032 : 						HWR_AddTransparentWall(wallVerts, &Surf, 0, blendmode, true, lightnum, colormap);

  020d6	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  020dc	50		 push	 eax
  020dd	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  020e3	51		 push	 ecx
  020e4	6a 01		 push	 1
  020e6	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _blendmode$2[ebp]
  020ec	52		 push	 edx
  020ed	6a 00		 push	 0
  020ef	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _Surf$[ebp]
  020f5	50		 push	 eax
  020f6	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  020f9	51		 push	 ecx
  020fa	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  020ff	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN139@HWR_StoreW:

; 2033 : 				}

  02102	e9 65 01 00 00	 jmp	 $LN146@HWR_StoreW
$LN134@HWR_StoreW:

; 2034 : 				else
; 2035 : 				{
; 2036 : 					FBITFIELD blendmode = PF_Masked;

  02107	c7 85 f0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _blendmode$1[ebp], 1

; 2037 : 
; 2038 : 					if (rover->flags & FF_TRANSLUCENT)

  02111	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  02117	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0211a	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  02120	74 4b		 je	 SHORT $LN140@HWR_StoreW

; 2039 : 					{
; 2040 : 						blendmode = PF_Translucent;

  02122	c7 85 f0 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _blendmode$1[ebp], 2

; 2041 : 						Surf.FlatColor.s.alpha = (UINT8)rover->alpha-1 > 255 ? 255 : rover->alpha-1;

  0212c	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  02132	0f b6 48 4c	 movzx	 ecx, BYTE PTR [eax+76]
  02136	83 e9 01	 sub	 ecx, 1
  02139	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0213f	7e 0c		 jle	 SHORT $LN167@HWR_StoreW
  02141	c7 85 ac fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1262[ebp], 255 ; 000000ffH
  0214b	eb 12		 jmp	 SHORT $LN168@HWR_StoreW
$LN167@HWR_StoreW:
  0214d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _rover$7[ebp]
  02153	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  02156	83 e8 01	 sub	 eax, 1
  02159	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv1262[ebp], eax
$LN168@HWR_StoreW:
  0215f	8a 8d ac fe ff
	ff		 mov	 cl, BYTE PTR tv1262[ebp]
  02165	88 8d 5b ff ff
	ff		 mov	 BYTE PTR _Surf$[ebp+7], cl

; 2042 : 					}

  0216b	eb 18		 jmp	 SHORT $LN142@HWR_StoreW
$LN140@HWR_StoreW:

; 2043 : 					else if (grTex->mipmap.flags & TF_TRANSPARENT)

  0216d	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _grTex$[ebp]
  02173	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  02176	83 e1 40	 and	 ecx, 64			; 00000040H
  02179	74 0a		 je	 SHORT $LN142@HWR_StoreW

; 2044 : 					{
; 2045 : 						blendmode = PF_Environment;

  0217b	c7 85 f0 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _blendmode$1[ebp], 8
$LN142@HWR_StoreW:

; 2046 : 					}
; 2047 : 
; 2048 : 					if (gr_backsector->numlights)

  02185	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_backsector
  0218a	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  02191	74 55		 je	 SHORT $LN143@HWR_StoreW

; 2049 : 						HWR_SplitWall(gr_backsector, wallVerts, texturetranslation[sides[rover->master->sidenum[0]].midtexture], &Surf, rover->flags);

  02193	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  02199	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0219c	51		 push	 ecx
  0219d	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  021a3	52		 push	 edx
  021a4	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  021aa	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  021ad	ba 02 00 00 00	 mov	 edx, 2
  021b2	6b c2 00	 imul	 eax, edx, 0
  021b5	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  021ba	6b d1 1c	 imul	 edx, ecx, 28
  021bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  021c2	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  021c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  021cc	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  021cf	50		 push	 eax
  021d0	8d 4d 9c	 lea	 ecx, DWORD PTR _wallVerts$[ebp]
  021d3	51		 push	 ecx
  021d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _gr_backsector
  021da	52		 push	 edx
  021db	e8 00 00 00 00	 call	 _HWR_SplitWall
  021e0	83 c4 14	 add	 esp, 20			; 00000014H
  021e3	e9 84 00 00 00	 jmp	 $LN146@HWR_StoreW
$LN143@HWR_StoreW:

; 2050 : 					else
; 2051 : 					{
; 2052 : 						if (blendmode != PF_Masked)

  021e8	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR _blendmode$1[ebp], 1
  021ef	74 58		 je	 SHORT $LN145@HWR_StoreW

; 2053 : 							HWR_AddTransparentWall(wallVerts, &Surf, texturetranslation[sides[rover->master->sidenum[0]].midtexture], blendmode, false, lightnum, colormap);

  021f1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  021f7	50		 push	 eax
  021f8	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  021fe	51		 push	 ecx
  021ff	6a 00		 push	 0
  02201	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _blendmode$1[ebp]
  02207	52		 push	 edx
  02208	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _rover$7[ebp]
  0220e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  02211	ba 02 00 00 00	 mov	 edx, 2
  02216	6b c2 00	 imul	 eax, edx, 0
  02219	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  0221e	6b d1 1c	 imul	 edx, ecx, 28
  02221	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  02226	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  0222a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _texturetranslation
  02230	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  02233	50		 push	 eax
  02234	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _Surf$[ebp]
  0223a	51		 push	 ecx
  0223b	8d 55 9c	 lea	 edx, DWORD PTR _wallVerts$[ebp]
  0223e	52		 push	 edx
  0223f	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  02244	83 c4 1c	 add	 esp, 28			; 0000001cH
  02247	eb 23		 jmp	 SHORT $LN146@HWR_StoreW
$LN145@HWR_StoreW:

; 2054 : 						else
; 2055 : 							HWR_ProjectWall(wallVerts, &Surf, PF_Masked, lightnum, colormap);

  02249	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$[ebp]
  0224f	50		 push	 eax
  02250	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _lightnum$[ebp]
  02256	51		 push	 ecx
  02257	6a 01		 push	 1
  02259	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _Surf$[ebp]
  0225f	52		 push	 edx
  02260	8d 45 9c	 lea	 eax, DWORD PTR _wallVerts$[ebp]
  02263	50		 push	 eax
  02264	e8 00 00 00 00	 call	 _HWR_ProjectWall
  02269	83 c4 14	 add	 esp, 20			; 00000014H
$LN146@HWR_StoreW:

; 2056 : 					}
; 2057 : 				}
; 2058 : 			}

  0226c	e9 94 f9 ff ff	 jmp	 $LN7@HWR_StoreW
$LN8@HWR_StoreW:

; 2059 : 		}
; 2060 : 	}
; 2061 : #endif
; 2062 : //Hurdler: end of 3d-floors test
; 2063 : }

  02271	5f		 pop	 edi
  02272	5e		 pop	 esi
  02273	5b		 pop	 ebx
  02274	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02277	33 cd		 xor	 ecx, ebp
  02279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0227e	8b e5		 mov	 esp, ebp
  02280	5d		 pop	 ebp
  02281	c3		 ret	 0
  02282	66 90		 npad	 2
$LN170@HWR_StoreW:
  02284	00 00 00 00	 DD	 $LN71@HWR_StoreW
  02288	00 00 00 00	 DD	 $LN85@HWR_StoreW
$LN169@HWR_StoreW:
  0228c	00		 DB	 0
  0228d	01		 DB	 1
  0228e	01		 DB	 1
  0228f	01		 DB	 1
  02290	01		 DB	 1
  02291	01		 DB	 1
  02292	01		 DB	 1
  02293	01		 DB	 1
  02294	01		 DB	 1
  02295	01		 DB	 1
  02296	01		 DB	 1
  02297	01		 DB	 1
  02298	01		 DB	 1
  02299	01		 DB	 1
  0229a	01		 DB	 1
  0229b	01		 DB	 1
  0229c	01		 DB	 1
  0229d	01		 DB	 1
  0229e	01		 DB	 1
  0229f	00		 DB	 0
  022a0	01		 DB	 1
  022a1	00		 DB	 0
  022a2	01		 DB	 1
  022a3	01		 DB	 1
  022a4	01		 DB	 1
  022a5	01		 DB	 1
  022a6	01		 DB	 1
  022a7	01		 DB	 1
  022a8	01		 DB	 1
  022a9	01		 DB	 1
  022aa	01		 DB	 1
  022ab	01		 DB	 1
  022ac	01		 DB	 1
  022ad	01		 DB	 1
  022ae	01		 DB	 1
  022af	01		 DB	 1
  022b0	01		 DB	 1
  022b1	01		 DB	 1
  022b2	01		 DB	 1
  022b3	00		 DB	 0
  022b4	00		 DB	 0
  022b5	01		 DB	 1
  022b6	00		 DB	 0
  022b7	00		 DB	 0
  022b8	01		 DB	 1
  022b9	01		 DB	 1
  022ba	01		 DB	 1
  022bb	01		 DB	 1
  022bc	01		 DB	 1
  022bd	01		 DB	 1
  022be	01		 DB	 1
  022bf	01		 DB	 1
  022c0	01		 DB	 1
  022c1	01		 DB	 1
  022c2	01		 DB	 1
  022c3	01		 DB	 1
  022c4	01		 DB	 1
  022c5	01		 DB	 1
  022c6	01		 DB	 1
  022c7	01		 DB	 1
  022c8	01		 DB	 1
  022c9	01		 DB	 1
  022ca	01		 DB	 1
  022cb	01		 DB	 1
  022cc	01		 DB	 1
  022cd	01		 DB	 1
  022ce	01		 DB	 1
  022cf	01		 DB	 1
  022d0	01		 DB	 1
  022d1	01		 DB	 1
  022d2	01		 DB	 1
  022d3	01		 DB	 1
  022d4	00		 DB	 0
  022d5	00		 DB	 0
  022d6	01		 DB	 1
  022d7	01		 DB	 1
  022d8	01		 DB	 1
  022d9	01		 DB	 1
  022da	01		 DB	 1
  022db	01		 DB	 1
  022dc	01		 DB	 1
  022dd	01		 DB	 1
  022de	01		 DB	 1
  022df	01		 DB	 1
  022e0	01		 DB	 1
  022e1	01		 DB	 1
  022e2	01		 DB	 1
  022e3	01		 DB	 1
  022e4	01		 DB	 1
  022e5	01		 DB	 1
  022e6	00		 DB	 0
  022e7	01		 DB	 1
  022e8	01		 DB	 1
  022e9	00		 DB	 0
  022ea	01		 DB	 1
  022eb	01		 DB	 1
  022ec	01		 DB	 1
  022ed	01		 DB	 1
  022ee	01		 DB	 1
  022ef	01		 DB	 1
  022f0	01		 DB	 1
  022f1	01		 DB	 1
  022f2	01		 DB	 1
  022f3	01		 DB	 1
  022f4	01		 DB	 1
  022f5	01		 DB	 1
  022f6	01		 DB	 1
  022f7	01		 DB	 1
  022f8	01		 DB	 1
  022f9	01		 DB	 1
  022fa	01		 DB	 1
  022fb	01		 DB	 1
  022fc	01		 DB	 1
  022fd	01		 DB	 1
  022fe	01		 DB	 1
  022ff	01		 DB	 1
  02300	01		 DB	 1
  02301	01		 DB	 1
  02302	01		 DB	 1
  02303	00		 DB	 0
  02304	01		 DB	 1
  02305	01		 DB	 1
  02306	01		 DB	 1
  02307	01		 DB	 1
  02308	01		 DB	 1
  02309	01		 DB	 1
  0230a	01		 DB	 1
  0230b	01		 DB	 1
  0230c	01		 DB	 1
  0230d	01		 DB	 1
  0230e	01		 DB	 1
  0230f	01		 DB	 1
  02310	01		 DB	 1
  02311	01		 DB	 1
  02312	01		 DB	 1
  02313	01		 DB	 1
  02314	01		 DB	 1
  02315	01		 DB	 1
  02316	01		 DB	 1
  02317	01		 DB	 1
  02318	01		 DB	 1
  02319	01		 DB	 1
  0231a	01		 DB	 1
  0231b	01		 DB	 1
  0231c	01		 DB	 1
  0231d	01		 DB	 1
  0231e	01		 DB	 1
  0231f	01		 DB	 1
  02320	01		 DB	 1
  02321	01		 DB	 1
  02322	01		 DB	 1
  02323	00		 DB	 0
  02324	01		 DB	 1
  02325	01		 DB	 1
  02326	00		 DB	 0
  02327	90		 npad	 1
$LN171@HWR_StoreW:
  02328	00 00 00 00	 DD	 $LN63@HWR_StoreW
  0232c	00 00 00 00	 DD	 $LN64@HWR_StoreW
  02330	00 00 00 00	 DD	 $LN65@HWR_StoreW
  02334	00 00 00 00	 DD	 $LN66@HWR_StoreW
  02338	00 00 00 00	 DD	 $LN67@HWR_StoreW
  0233c	00 00 00 00	 DD	 $LN68@HWR_StoreW
  02340	00 00 00 00	 DD	 $LN69@HWR_StoreW
  02344	00 00 00 00	 DD	 $LN70@HWR_StoreW
_HWR_StoreWallRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_SplitFog
_TEXT	SEGMENT
tv186 = -120						; size = 4
tv197 = -120						; size = 4
tv230 = -120						; size = 4
tv241 = -120						; size = 4
_alpha$ = -49						; size = 1
_list$ = -48						; size = 4
_i$ = -44						; size = 4
_solid$ = -40						; size = 4
_bheight$ = -36						; size = 4
_height$ = -32						; size = 4
_pegmul$ = -28						; size = 4
_pegb$ = -24						; size = 4
_pegt$ = -20						; size = 4
_bot$ = -16						; size = 4
_top$ = -12						; size = 4
_realbot$ = -8						; size = 4
_realtop$ = -4						; size = 4
_sector$ = 8						; size = 4
_wallVerts$ = 12					; size = 4
_Surf$ = 16						; size = 4
_cutflag$ = 20						; size = 4
_lightnum$ = 24						; size = 4
_colormap$ = 28						; size = 4
_HWR_SplitFog PROC					; COMDAT

; 1271 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1272 : 	/* SoM: split up and light walls according to the
; 1273 : 	 lightlist. This may also include leaving out parts
; 1274 : 	 of the wall that can't be seen */
; 1275 : 	float realtop, realbot, top, bot;
; 1276 : 	float pegt, pegb, pegmul;
; 1277 : 	float height = 0.0f, bheight = 0.0f;

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	f3 0f 11 45 e0	 movss	 DWORD PTR _height$[ebp], xmm0
  00011	0f 57 c0	 xorps	 xmm0, xmm0
  00014	f3 0f 11 45 dc	 movss	 DWORD PTR _bheight$[ebp], xmm0

; 1278 : 	INT32   solid, i;
; 1279 : 	lightlist_t *  list = sector->lightlist;

  00019	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0001c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00022	89 4d d0	 mov	 DWORD PTR _list$[ebp], ecx

; 1280 : #ifdef HARDWAREFIX
; 1281 : 	const UINT8 alpha = Surf->FlatColor.s.alpha;

  00025	8b 45 10	 mov	 eax, DWORD PTR _Surf$[ebp]
  00028	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  0002b	88 4d cf	 mov	 BYTE PTR _alpha$[ebp], cl

; 1282 : #endif
; 1283 : 
; 1284 : 	realtop = top = wallVerts[2].y;

  0002e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00033	d1 e0		 shl	 eax, 1
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00038	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [ecx+eax+4]
  0003e	f3 0f 11 45 f4	 movss	 DWORD PTR _top$[ebp], xmm0
  00043	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _top$[ebp]
  00048	f3 0f 11 45 fc	 movss	 DWORD PTR _realtop$[ebp], xmm0

; 1285 : 	realbot = bot = wallVerts[0].y;

  0004d	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00052	6b c8 00	 imul	 ecx, eax, 0
  00055	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  00058	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [edx+ecx+4]
  0005e	f3 0f 11 45 f0	 movss	 DWORD PTR _bot$[ebp], xmm0
  00063	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _bot$[ebp]
  00068	f3 0f 11 45 f8	 movss	 DWORD PTR _realbot$[ebp], xmm0

; 1286 : 	pegt = wallVerts[2].t;

  0006d	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00072	d1 e0		 shl	 eax, 1
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00077	f3 0f 10 44 01
	10		 movss	 xmm0, DWORD PTR [ecx+eax+16]
  0007d	f3 0f 11 45 ec	 movss	 DWORD PTR _pegt$[ebp], xmm0

; 1287 : 	pegb = wallVerts[0].t;

  00082	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00087	6b c8 00	 imul	 ecx, eax, 0
  0008a	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  0008d	f3 0f 10 44 0a
	10		 movss	 xmm0, DWORD PTR [edx+ecx+16]
  00093	f3 0f 11 45 e8	 movss	 DWORD PTR _pegb$[ebp], xmm0

; 1288 : 	pegmul = (pegb - pegt) / (top - bot);

  00098	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _pegb$[ebp]
  0009d	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _pegt$[ebp]
  000a2	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _top$[ebp]
  000a7	f3 0f 5c 4d f0	 subss	 xmm1, DWORD PTR _bot$[ebp]
  000ac	f3 0f 5e c1	 divss	 xmm0, xmm1
  000b0	f3 0f 11 45 e4	 movss	 DWORD PTR _pegmul$[ebp], xmm0

; 1289 : 
; 1290 : 	for (i = 1; i < sector->numlights; i++)

  000b5	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000bc	eb 09		 jmp	 SHORT $LN4@HWR_SplitF
$LN2@HWR_SplitF:
  000be	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HWR_SplitF:
  000c7	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000ca	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  000cd	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  000d3	0f 8d 81 02 00
	00		 jge	 $LN3@HWR_SplitF

; 1291 : 	{
; 1292 : 		if (top < realbot)

  000d9	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  000de	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _top$[ebp]
  000e2	76 05		 jbe	 SHORT $LN5@HWR_SplitF

; 1293 : 			return;

  000e4	e9 9d 03 00 00	 jmp	 $LN1@HWR_SplitF
$LN5@HWR_SplitF:

; 1294 : 
; 1295 : 	//Hurdler: fix a crashing bug, but is it correct?
; 1296 : //		if (!list[i].caster)
; 1297 : //			continue;
; 1298 : 
; 1299 : 		solid = false;

  000e9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0

; 1300 : 
; 1301 : 		if (list[i].caster)

  000f0	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  000f4	8b 4d d0	 mov	 ecx, DWORD PTR _list$[ebp]
  000f7	83 7c 01 10 00	 cmp	 DWORD PTR [ecx+eax+16], 0
  000fc	0f 84 a2 00 00
	00		 je	 $LN6@HWR_SplitF

; 1302 : 		{
; 1303 : 			if (sector->lightlist[i].caster->flags & FF_SOLID && !(cutflag & FF_EXTRA))

  00102	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00109	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0010f	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00113	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00116	83 e1 06	 and	 ecx, 6
  00119	74 13		 je	 SHORT $LN8@HWR_SplitF
  0011b	8b 45 14	 mov	 eax, DWORD PTR _cutflag$[ebp]
  0011e	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00123	75 09		 jne	 SHORT $LN8@HWR_SplitF

; 1304 : 				solid = true;

  00125	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 1
  0012c	eb 74		 jmp	 SHORT $LN11@HWR_SplitF
$LN8@HWR_SplitF:

; 1305 : 			else if (sector->lightlist[i].caster->flags & FF_CUTEXTRA && cutflag & FF_EXTRA)

  0012e	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00135	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0013b	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  0013f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00142	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00148	74 51		 je	 SHORT $LN10@HWR_SplitF
  0014a	8b 45 14	 mov	 eax, DWORD PTR _cutflag$[ebp]
  0014d	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00152	74 47		 je	 SHORT $LN10@HWR_SplitF

; 1306 : 			{
; 1307 : 				if (sector->lightlist[i].caster->flags & FF_EXTRA)

  00154	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  0015b	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00161	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00165	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00168	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  0016e	74 22		 je	 SHORT $LN12@HWR_SplitF

; 1308 : 				{
; 1309 : 					if (sector->lightlist[i].caster->flags == cutflag)

  00170	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00177	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0017d	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00181	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00184	3b 4d 14	 cmp	 ecx, DWORD PTR _cutflag$[ebp]
  00187	75 07		 jne	 SHORT $LN14@HWR_SplitF

; 1310 : 						solid = true;

  00189	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 1
$LN14@HWR_SplitF:

; 1311 : 				}

  00190	eb 07		 jmp	 SHORT $LN13@HWR_SplitF
$LN12@HWR_SplitF:

; 1312 : 				else
; 1313 : 					solid = true;

  00192	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 1
$LN13@HWR_SplitF:

; 1314 : 			}

  00199	eb 07		 jmp	 SHORT $LN11@HWR_SplitF
$LN10@HWR_SplitF:

; 1315 : 			else
; 1316 : 				solid = false;

  0019b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0
$LN11@HWR_SplitF:

; 1317 : 		}

  001a2	eb 07		 jmp	 SHORT $LN7@HWR_SplitF
$LN6@HWR_SplitF:

; 1318 : 		else
; 1319 : 			solid = false;

  001a4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0
$LN7@HWR_SplitF:

; 1320 : 
; 1321 : 		height = FIXED_TO_FLOAT(list[i].height);

  001ab	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  001af	8b 4d d0	 mov	 ecx, DWORD PTR _list$[ebp]
  001b2	f3 0f 2a 04 01	 cvtsi2ss xmm0, DWORD PTR [ecx+eax]
  001b7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001bf	f3 0f 11 45 e0	 movss	 DWORD PTR _height$[ebp], xmm0

; 1322 : 
; 1323 : 		if (solid)

  001c4	83 7d d8 00	 cmp	 DWORD PTR _solid$[ebp], 0
  001c8	74 1f		 je	 SHORT $LN15@HWR_SplitF

; 1324 : 			bheight = FIXED_TO_FLOAT(*list[i].caster->bottomheight);

  001ca	6b 45 d4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  001ce	8b 4d d0	 mov	 ecx, DWORD PTR _list$[ebp]
  001d1	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  001d5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001d8	f3 0f 2a 00	 cvtsi2ss xmm0, DWORD PTR [eax]
  001dc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001e4	f3 0f 11 45 dc	 movss	 DWORD PTR _bheight$[ebp], xmm0
$LN15@HWR_SplitF:

; 1325 : 
; 1326 : 		if (height >= top)

  001e9	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _height$[ebp]
  001ee	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _top$[ebp]
  001f2	72 20		 jb	 SHORT $LN16@HWR_SplitF

; 1327 : 		{
; 1328 : 			if (solid && top > bheight)

  001f4	83 7d d8 00	 cmp	 DWORD PTR _solid$[ebp], 0
  001f8	74 15		 je	 SHORT $LN17@HWR_SplitF
  001fa	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _top$[ebp]
  001ff	0f 2f 45 dc	 comiss	 xmm0, DWORD PTR _bheight$[ebp]
  00203	76 0a		 jbe	 SHORT $LN17@HWR_SplitF

; 1329 : 				top = bheight;

  00205	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _bheight$[ebp]
  0020a	f3 0f 11 45 f4	 movss	 DWORD PTR _top$[ebp], xmm0
$LN17@HWR_SplitF:

; 1330 : 			continue;

  0020f	e9 aa fe ff ff	 jmp	 $LN2@HWR_SplitF
$LN16@HWR_SplitF:

; 1331 : 		}
; 1332 : 
; 1333 : 		//Found a break;
; 1334 : 		bot = height;

  00214	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _height$[ebp]
  00219	f3 0f 11 45 f0	 movss	 DWORD PTR _bot$[ebp], xmm0

; 1335 : 
; 1336 : 		if (bot < realbot)

  0021e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  00223	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _bot$[ebp]
  00227	76 0a		 jbe	 SHORT $LN18@HWR_SplitF

; 1337 : 			bot = realbot;

  00229	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  0022e	f3 0f 11 45 f0	 movss	 DWORD PTR _bot$[ebp], xmm0
$LN18@HWR_SplitF:

; 1338 : 
; 1339 : 		{
; 1340 : 
; 1341 : 
; 1342 : #ifndef HARDWAREFIX
; 1343 : 			lightnum = LightLevelToLum(*list[i-1].lightlevel);
; 1344 : 			// store Surface->FlatColor to modulate wall texture
; 1345 : 			Surf->FlatColor.s.red = Surf->FlatColor.s.green = Surf->FlatColor.s.blue =
; 1346 : 				(UINT8)lightnum;
; 1347 : #endif
; 1348 : 
; 1349 : #ifdef HARDWAREFIX
; 1350 : 			Surf->FlatColor.s.alpha = alpha;

  00233	8b 45 10	 mov	 eax, DWORD PTR _Surf$[ebp]
  00236	8a 4d cf	 mov	 cl, BYTE PTR _alpha$[ebp]
  00239	88 48 07	 mov	 BYTE PTR [eax+7], cl

; 1351 : #else
; 1352 : 			{
; 1353 : 				RGBA_t temp;
; 1354 : 				INT32 alpha;
; 1355 : 
; 1356 : 				temp.rgba = psector->extra_colormap->rgba;
; 1357 : 				alpha = (INT32)((26 - temp.s.alpha)*lightnum);
; 1358 : 
; 1359 : 				Surf->FlatColor.s.red =
; 1360 : 					(UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 1361 : 				Surf->FlatColor.s.blue =
; 1362 : 					(UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 1363 : 				Surf->FlatColor.s.green =
; 1364 : 					(UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 1365 : 				Surf->FlatColor.s.alpha = 0xff;
; 1366 : 			}
; 1367 : #endif
; 1368 : 		}
; 1369 : 
; 1370 : 		wallVerts[3].t = wallVerts[2].t = pegt + ((realtop - top) * pegmul);

  0023c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  00241	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _top$[ebp]
  00246	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  0024b	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  00250	f3 0f 58 c8	 addss	 xmm1, xmm0
  00254	f3 0f 11 4d 88	 movss	 DWORD PTR tv186[ebp], xmm1
  00259	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0025e	d1 e0		 shl	 eax, 1
  00260	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00263	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv186[ebp]
  00268	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  0026e	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00273	6b c2 03	 imul	 eax, edx, 3
  00276	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00279	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv186[ebp]
  0027e	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1371 : 		wallVerts[0].t = wallVerts[1].t = pegt + ((realtop - bot) * pegmul);

  00284	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  00289	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _bot$[ebp]
  0028e	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  00293	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  00298	f3 0f 58 c8	 addss	 xmm1, xmm0
  0029c	f3 0f 11 4d 88	 movss	 DWORD PTR tv197[ebp], xmm1
  002a1	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002a6	c1 e0 00	 shl	 eax, 0
  002a9	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  002ac	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv197[ebp]
  002b1	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  002b7	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  002bc	6b c2 00	 imul	 eax, edx, 0
  002bf	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  002c2	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv197[ebp]
  002c7	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1372 : 
; 1373 : 		// set top/bottom coords
; 1374 : 		wallVerts[2].y = wallVerts[3].y = top;

  002cd	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002d2	6b c8 03	 imul	 ecx, eax, 3
  002d5	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  002d8	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _top$[ebp]
  002dd	f3 0f 11 44 0a
	04		 movss	 DWORD PTR [edx+ecx+4], xmm0
  002e3	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002e8	d1 e0		 shl	 eax, 1
  002ea	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  002ed	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _top$[ebp]
  002f2	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1375 : 		wallVerts[0].y = wallVerts[1].y = bot;

  002f8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002fd	c1 e0 00	 shl	 eax, 0
  00300	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00303	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _bot$[ebp]
  00308	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
  0030e	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00313	6b c2 00	 imul	 eax, edx, 0
  00316	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00319	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _bot$[ebp]
  0031e	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1376 : 
; 1377 : 		if (!solid) // Don't draw it if there's more fog behind it

  00324	83 7d d8 00	 cmp	 DWORD PTR _solid$[ebp], 0
  00328	75 21		 jne	 SHORT $LN19@HWR_SplitF

; 1378 : 			HWR_AddTransparentWall(wallVerts, Surf, 0, PF_Translucent|PF_NoTexture, true, lightnum, colormap);

  0032a	8b 45 1c	 mov	 eax, DWORD PTR _colormap$[ebp]
  0032d	50		 push	 eax
  0032e	8b 4d 18	 mov	 ecx, DWORD PTR _lightnum$[ebp]
  00331	51		 push	 ecx
  00332	6a 01		 push	 1
  00334	68 02 20 00 00	 push	 8194			; 00002002H
  00339	6a 00		 push	 0
  0033b	8b 55 10	 mov	 edx, DWORD PTR _Surf$[ebp]
  0033e	52		 push	 edx
  0033f	8b 45 0c	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  00348	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN19@HWR_SplitF:

; 1379 : 
; 1380 : 		top = height;

  0034b	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _height$[ebp]
  00350	f3 0f 11 45 f4	 movss	 DWORD PTR _top$[ebp], xmm0

; 1381 : 	}

  00355	e9 64 fd ff ff	 jmp	 $LN2@HWR_SplitF
$LN3@HWR_SplitF:

; 1382 : 
; 1383 : 	bot = realbot;

  0035a	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  0035f	f3 0f 11 45 f0	 movss	 DWORD PTR _bot$[ebp], xmm0

; 1384 : 	if (top <= realbot)

  00364	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  00369	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _top$[ebp]
  0036d	72 05		 jb	 SHORT $LN20@HWR_SplitF

; 1385 : 		return;

  0036f	e9 12 01 00 00	 jmp	 $LN1@HWR_SplitF
$LN20@HWR_SplitF:

; 1386 : 
; 1387 : 	{
; 1388 : #ifndef HARDWAREFIX
; 1389 : 		lightnum = LightLevelToLum(*list[i-1].lightlevel);
; 1390 : 		// store Surface->FlatColor to modulate wall texture
; 1391 : 		Surf->FlatColor.s.red = Surf->FlatColor.s.green = Surf->FlatColor.s.blue
; 1392 : 			= (UINT8)lightnum;
; 1393 : #endif
; 1394 : 
; 1395 : #ifdef HARDWAREFIX
; 1396 : 		Surf->FlatColor.s.alpha = alpha;

  00374	8b 45 10	 mov	 eax, DWORD PTR _Surf$[ebp]
  00377	8a 4d cf	 mov	 cl, BYTE PTR _alpha$[ebp]
  0037a	88 48 07	 mov	 BYTE PTR [eax+7], cl

; 1397 : #else
; 1398 : 		{
; 1399 : 			RGBA_t  temp;
; 1400 : 			INT32     alpha;
; 1401 : 
; 1402 : 			temp.rgba = psector->extra_colormap->rgba;
; 1403 : 			alpha = (INT32)((26 - temp.s.alpha)*lightnum);
; 1404 : 			Surf->FlatColor.s.red = (UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 1405 : 			Surf->FlatColor.s.blue = (UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 1406 : 			Surf->FlatColor.s.green = (UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 1407 : 			Surf->FlatColor.s.alpha = 0xFF;
; 1408 : 		}
; 1409 : #endif
; 1410 : 	}
; 1411 : 
; 1412 : 	wallVerts[3].t = wallVerts[2].t = pegt + ((realtop - top) * pegmul);

  0037d	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  00382	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _top$[ebp]
  00387	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  0038c	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  00391	f3 0f 58 c8	 addss	 xmm1, xmm0
  00395	f3 0f 11 4d 88	 movss	 DWORD PTR tv230[ebp], xmm1
  0039a	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0039f	d1 e0		 shl	 eax, 1
  003a1	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  003a4	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv230[ebp]
  003a9	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  003af	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  003b4	6b c2 03	 imul	 eax, edx, 3
  003b7	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  003ba	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv230[ebp]
  003bf	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1413 : 	wallVerts[0].t = wallVerts[1].t = pegt + ((realtop - bot) * pegmul);

  003c5	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  003ca	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _bot$[ebp]
  003cf	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  003d4	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  003d9	f3 0f 58 c8	 addss	 xmm1, xmm0
  003dd	f3 0f 11 4d 88	 movss	 DWORD PTR tv241[ebp], xmm1
  003e2	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  003e7	c1 e0 00	 shl	 eax, 0
  003ea	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  003ed	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv241[ebp]
  003f2	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  003f8	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  003fd	6b c2 00	 imul	 eax, edx, 0
  00400	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00403	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv241[ebp]
  00408	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1414 : 
; 1415 : 	// set top/bottom coords
; 1416 : 	wallVerts[2].y = wallVerts[3].y = top;

  0040e	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00413	6b c8 03	 imul	 ecx, eax, 3
  00416	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  00419	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _top$[ebp]
  0041e	f3 0f 11 44 0a
	04		 movss	 DWORD PTR [edx+ecx+4], xmm0
  00424	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00429	d1 e0		 shl	 eax, 1
  0042b	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0042e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _top$[ebp]
  00433	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1417 : 	wallVerts[0].y = wallVerts[1].y = bot;

  00439	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0043e	c1 e0 00	 shl	 eax, 0
  00441	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00444	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _bot$[ebp]
  00449	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
  0044f	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00454	6b c2 00	 imul	 eax, edx, 0
  00457	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0045a	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _bot$[ebp]
  0045f	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1418 : 
; 1419 : 	HWR_AddTransparentWall(wallVerts, Surf, 0, PF_Translucent|PF_NoTexture, true, lightnum, colormap);

  00465	8b 45 1c	 mov	 eax, DWORD PTR _colormap$[ebp]
  00468	50		 push	 eax
  00469	8b 4d 18	 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0046c	51		 push	 ecx
  0046d	6a 01		 push	 1
  0046f	68 02 20 00 00	 push	 8194			; 00002002H
  00474	6a 00		 push	 0
  00476	8b 55 10	 mov	 edx, DWORD PTR _Surf$[ebp]
  00479	52		 push	 edx
  0047a	8b 45 0c	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  0047d	50		 push	 eax
  0047e	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  00483	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@HWR_SplitF:

; 1420 : }

  00486	5f		 pop	 edi
  00487	5e		 pop	 esi
  00488	5b		 pop	 ebx
  00489	8b e5		 mov	 esp, ebp
  0048b	5d		 pop	 ebp
  0048c	c3		 ret	 0
_HWR_SplitFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_SplitWall
_TEXT	SEGMENT
tv207 = -140						; size = 4
tv218 = -140						; size = 4
tv288 = -140						; size = 4
tv299 = -140						; size = 4
_colormap$ = -72					; size = 4
_lightnum$ = -68					; size = 4
_colormap$1 = -64					; size = 4
_lightnum$2 = -60					; size = 4
_alpha$ = -53						; size = 1
_list$ = -52						; size = 4
_i$ = -48						; size = 4
_solid$ = -44						; size = 4
_bheight$ = -40						; size = 4
_height$ = -36						; size = 4
_pegmul$ = -32						; size = 4
_pegb$ = -28						; size = 4
_pegt$ = -24						; size = 4
_bot$ = -20						; size = 4
_top$ = -16						; size = 4
_realbot$ = -12						; size = 4
_realtop$ = -8						; size = 4
_glTex$ = -4						; size = 4
_sector$ = 8						; size = 4
_wallVerts$ = 12					; size = 4
_texnum$ = 16						; size = 4
_Surf$ = 20						; size = 4
_cutflag$ = 24						; size = 4
_HWR_SplitWall PROC					; COMDAT

; 1062 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1063 : 	/* SoM: split up and light walls according to the
; 1064 : 	 lightlist. This may also include leaving out parts
; 1065 : 	 of the wall that can't be seen */
; 1066 : 	GLTexture_t * glTex;
; 1067 : 	float realtop, realbot, top, bot;
; 1068 : 	float pegt, pegb, pegmul;
; 1069 : 	float height = 0.0f, bheight = 0.0f;

  0000c	0f 57 c0	 xorps	 xmm0, xmm0
  0000f	f3 0f 11 45 dc	 movss	 DWORD PTR _height$[ebp], xmm0
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	f3 0f 11 45 d8	 movss	 DWORD PTR _bheight$[ebp], xmm0

; 1070 : 	INT32   solid, i;
; 1071 : 	lightlist_t *  list = sector->lightlist;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0001f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00025	89 4d cc	 mov	 DWORD PTR _list$[ebp], ecx

; 1072 : #ifdef HARDWAREFIX
; 1073 : 	const UINT8 alpha = Surf->FlatColor.s.alpha;

  00028	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  0002b	8a 48 07	 mov	 cl, BYTE PTR [eax+7]
  0002e	88 4d cb	 mov	 BYTE PTR _alpha$[ebp], cl

; 1074 : #endif
; 1075 : 
; 1076 : 	realtop = top = wallVerts[2].y;

  00031	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00036	d1 e0		 shl	 eax, 1
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0003b	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [ecx+eax+4]
  00041	f3 0f 11 45 f0	 movss	 DWORD PTR _top$[ebp], xmm0
  00046	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _top$[ebp]
  0004b	f3 0f 11 45 f8	 movss	 DWORD PTR _realtop$[ebp], xmm0

; 1077 : 	realbot = bot = wallVerts[0].y;

  00050	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00055	6b c8 00	 imul	 ecx, eax, 0
  00058	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  0005b	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [edx+ecx+4]
  00061	f3 0f 11 45 ec	 movss	 DWORD PTR _bot$[ebp], xmm0
  00066	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _bot$[ebp]
  0006b	f3 0f 11 45 f4	 movss	 DWORD PTR _realbot$[ebp], xmm0

; 1078 : 	pegt = wallVerts[2].t;

  00070	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00075	d1 e0		 shl	 eax, 1
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0007a	f3 0f 10 44 01
	10		 movss	 xmm0, DWORD PTR [ecx+eax+16]
  00080	f3 0f 11 45 e8	 movss	 DWORD PTR _pegt$[ebp], xmm0

; 1079 : 	pegb = wallVerts[0].t;

  00085	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0008a	6b c8 00	 imul	 ecx, eax, 0
  0008d	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  00090	f3 0f 10 44 0a
	10		 movss	 xmm0, DWORD PTR [edx+ecx+16]
  00096	f3 0f 11 45 e4	 movss	 DWORD PTR _pegb$[ebp], xmm0

; 1080 : 	pegmul = (pegb - pegt) / (top - bot);

  0009b	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _pegb$[ebp]
  000a0	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR _pegt$[ebp]
  000a5	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _top$[ebp]
  000aa	f3 0f 5c 4d ec	 subss	 xmm1, DWORD PTR _bot$[ebp]
  000af	f3 0f 5e c1	 divss	 xmm0, xmm1
  000b3	f3 0f 11 45 e0	 movss	 DWORD PTR _pegmul$[ebp], xmm0

; 1081 : 
; 1082 : 	for (i = 1; i < sector->numlights; i++)

  000b8	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000bf	eb 09		 jmp	 SHORT $LN4@HWR_SplitW
$LN2@HWR_SplitW:
  000c1	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HWR_SplitW:
  000ca	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000cd	8b 4d d0	 mov	 ecx, DWORD PTR _i$[ebp]
  000d0	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  000d6	0f 8d 73 03 00
	00		 jge	 $LN3@HWR_SplitW

; 1083 : 	{
; 1084 : 		if (top < realbot)

  000dc	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  000e1	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _top$[ebp]
  000e5	76 05		 jbe	 SHORT $LN5@HWR_SplitW

; 1085 : 			return;

  000e7	e9 56 05 00 00	 jmp	 $LN35@HWR_SplitW
$LN5@HWR_SplitW:

; 1086 : 
; 1087 : 	//Hurdler: fix a crashing bug, but is it correct?
; 1088 : //		if (!list[i].caster)
; 1089 : //			continue;
; 1090 : 
; 1091 : 		solid = false;

  000ec	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0

; 1092 : 
; 1093 : 		if (list[i].caster)

  000f3	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  000f7	8b 4d cc	 mov	 ecx, DWORD PTR _list$[ebp]
  000fa	83 7c 01 10 00	 cmp	 DWORD PTR [ecx+eax+16], 0
  000ff	0f 84 a2 00 00
	00		 je	 $LN6@HWR_SplitW

; 1094 : 		{
; 1095 : 			if (sector->lightlist[i].caster->flags & FF_SOLID && !(cutflag & FF_EXTRA))

  00105	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  0010c	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00112	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00116	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00119	83 e1 06	 and	 ecx, 6
  0011c	74 13		 je	 SHORT $LN8@HWR_SplitW
  0011e	8b 45 18	 mov	 eax, DWORD PTR _cutflag$[ebp]
  00121	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00126	75 09		 jne	 SHORT $LN8@HWR_SplitW

; 1096 : 				solid = true;

  00128	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 1
  0012f	eb 74		 jmp	 SHORT $LN11@HWR_SplitW
$LN8@HWR_SplitW:

; 1097 : 			else if (sector->lightlist[i].caster->flags & FF_CUTEXTRA && cutflag & FF_EXTRA)

  00131	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00138	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0013e	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00142	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00145	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  0014b	74 51		 je	 SHORT $LN10@HWR_SplitW
  0014d	8b 45 18	 mov	 eax, DWORD PTR _cutflag$[ebp]
  00150	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00155	74 47		 je	 SHORT $LN10@HWR_SplitW

; 1098 : 			{
; 1099 : 				if (sector->lightlist[i].caster->flags & FF_EXTRA)

  00157	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  0015e	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00164	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00168	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0016b	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  00171	74 22		 je	 SHORT $LN12@HWR_SplitW

; 1100 : 				{
; 1101 : 					if (sector->lightlist[i].caster->flags == cutflag) // Only merge with your own types

  00173	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  0017a	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00180	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  00184	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00187	3b 4d 18	 cmp	 ecx, DWORD PTR _cutflag$[ebp]
  0018a	75 07		 jne	 SHORT $LN14@HWR_SplitW

; 1102 : 						solid = true;

  0018c	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 1
$LN14@HWR_SplitW:

; 1103 : 				}

  00193	eb 07		 jmp	 SHORT $LN13@HWR_SplitW
$LN12@HWR_SplitW:

; 1104 : 				else
; 1105 : 					solid = true;

  00195	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 1
$LN13@HWR_SplitW:

; 1106 : 			}

  0019c	eb 07		 jmp	 SHORT $LN11@HWR_SplitW
$LN10@HWR_SplitW:

; 1107 : 			else
; 1108 : 				solid = false;

  0019e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0
$LN11@HWR_SplitW:

; 1109 : 		}

  001a5	eb 07		 jmp	 SHORT $LN7@HWR_SplitW
$LN6@HWR_SplitW:

; 1110 : 		else
; 1111 : 			solid = false;

  001a7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0
$LN7@HWR_SplitW:

; 1112 : 
; 1113 : 		if (cutflag == FF_CUTSOLIDS) // These are regular walls sent in from StoreWallRange, they shouldn't be cut from this

  001ae	81 7d 18 80 00
	00 00		 cmp	 DWORD PTR _cutflag$[ebp], 128 ; 00000080H
  001b5	75 07		 jne	 SHORT $LN15@HWR_SplitW

; 1114 : 			solid = false;

  001b7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0
$LN15@HWR_SplitW:

; 1115 : 
; 1116 : 		if (cutflag & FF_SOLID) // these weren't being cut before anyway, although they probably should be in the right conditions

  001be	8b 45 18	 mov	 eax, DWORD PTR _cutflag$[ebp]
  001c1	83 e0 06	 and	 eax, 6
  001c4	74 07		 je	 SHORT $LN16@HWR_SplitW

; 1117 : 			solid = false;

  001c6	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0
$LN16@HWR_SplitW:

; 1118 : 
; 1119 : 
; 1120 : 		height = FIXED_TO_FLOAT(list[i].height);

  001cd	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  001d1	8b 4d cc	 mov	 ecx, DWORD PTR _list$[ebp]
  001d4	f3 0f 2a 04 01	 cvtsi2ss xmm0, DWORD PTR [ecx+eax]
  001d9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001e1	f3 0f 11 45 dc	 movss	 DWORD PTR _height$[ebp], xmm0

; 1121 : 		if (solid)

  001e6	83 7d d4 00	 cmp	 DWORD PTR _solid$[ebp], 0
  001ea	74 1f		 je	 SHORT $LN17@HWR_SplitW

; 1122 : 			bheight = FIXED_TO_FLOAT(*list[i].caster->bottomheight);

  001ec	6b 45 d0 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  001f0	8b 4d cc	 mov	 ecx, DWORD PTR _list$[ebp]
  001f3	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  001f7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001fa	f3 0f 2a 00	 cvtsi2ss xmm0, DWORD PTR [eax]
  001fe	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00206	f3 0f 11 45 d8	 movss	 DWORD PTR _bheight$[ebp], xmm0
$LN17@HWR_SplitW:

; 1123 : 
; 1124 : 		if (height >= top)

  0020b	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _height$[ebp]
  00210	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _top$[ebp]
  00214	72 20		 jb	 SHORT $LN18@HWR_SplitW

; 1125 : 		{
; 1126 : 			if (solid && top > bheight)

  00216	83 7d d4 00	 cmp	 DWORD PTR _solid$[ebp], 0
  0021a	74 15		 je	 SHORT $LN19@HWR_SplitW
  0021c	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _top$[ebp]
  00221	0f 2f 45 d8	 comiss	 xmm0, DWORD PTR _bheight$[ebp]
  00225	76 0a		 jbe	 SHORT $LN19@HWR_SplitW

; 1127 : 				top = bheight;

  00227	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _bheight$[ebp]
  0022c	f3 0f 11 45 f0	 movss	 DWORD PTR _top$[ebp], xmm0
$LN19@HWR_SplitW:

; 1128 : 			continue;

  00231	e9 8b fe ff ff	 jmp	 $LN2@HWR_SplitW
$LN18@HWR_SplitW:

; 1129 : 		}
; 1130 : 
; 1131 : 		FUINT lightnum;
; 1132 : 		extracolormap_t *colormap;
; 1133 : 
; 1134 : 		//Found a break;
; 1135 : 		bot = height;

  00236	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _height$[ebp]
  0023b	f3 0f 11 45 ec	 movss	 DWORD PTR _bot$[ebp], xmm0

; 1136 : 
; 1137 : 		if (bot < realbot)

  00240	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  00245	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _bot$[ebp]
  00249	76 0a		 jbe	 SHORT $LN20@HWR_SplitW

; 1138 : 			bot = realbot;

  0024b	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  00250	f3 0f 11 45 ec	 movss	 DWORD PTR _bot$[ebp], xmm0
$LN20@HWR_SplitW:

; 1139 : 
; 1140 : 		{
; 1141 : 
; 1142 : 
; 1143 : #ifndef HARDWAREFIX
; 1144 : 			lightnum = LightLevelToLum(*list[i-1].lightlevel);
; 1145 : 			// store Surface->FlatColor to modulate wall texture
; 1146 : 			Surf->FlatColor.s.red = Surf->FlatColor.s.green = Surf->FlatColor.s.blue =
; 1147 : 				(UINT8)lightnum;
; 1148 : #endif
; 1149 : 
; 1150 : 			// colormap test
; 1151 : #ifdef HARDWAREFIX
; 1152 : 			if (list[i-1].caster)

  00255	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00258	83 e8 01	 sub	 eax, 1
  0025b	6b c8 14	 imul	 ecx, eax, 20
  0025e	8b 55 cc	 mov	 edx, DWORD PTR _list$[ebp]
  00261	83 7c 0a 10 00	 cmp	 DWORD PTR [edx+ecx+16], 0
  00266	74 2b		 je	 SHORT $LN21@HWR_SplitW

; 1153 : 			{
; 1154 : 				lightnum = *list[i-1].lightlevel;

  00268	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  0026b	83 e8 01	 sub	 eax, 1
  0026e	6b c8 14	 imul	 ecx, eax, 20
  00271	8b 55 cc	 mov	 edx, DWORD PTR _list$[ebp]
  00274	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00278	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0027b	89 4d c4	 mov	 DWORD PTR _lightnum$2[ebp], ecx

; 1155 : 				colormap = list[i-1].extra_colormap;

  0027e	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00281	83 e8 01	 sub	 eax, 1
  00284	6b c8 14	 imul	 ecx, eax, 20
  00287	8b 55 cc	 mov	 edx, DWORD PTR _list$[ebp]
  0028a	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  0028e	89 45 c0	 mov	 DWORD PTR _colormap$1[ebp], eax

; 1156 : 			}

  00291	eb 16		 jmp	 SHORT $LN22@HWR_SplitW
$LN21@HWR_SplitW:

; 1157 : 			else
; 1158 : 			{
; 1159 : 				lightnum = sector->lightlevel;

  00293	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00296	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0029a	89 4d c4	 mov	 DWORD PTR _lightnum$2[ebp], ecx

; 1160 : 				colormap = sector->extra_colormap;

  0029d	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  002a0	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002a6	89 4d c0	 mov	 DWORD PTR _colormap$1[ebp], ecx
$LN22@HWR_SplitW:

; 1161 : 			}
; 1162 : #endif
; 1163 : #ifdef HARDWAREFIX
; 1164 : 			Surf->FlatColor.s.alpha = alpha;

  002a9	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  002ac	8a 4d cb	 mov	 cl, BYTE PTR _alpha$[ebp]
  002af	88 48 07	 mov	 BYTE PTR [eax+7], cl

; 1165 : #else
; 1166 : 			{
; 1167 : 				RGBA_t temp;
; 1168 : 				INT32 alpha;
; 1169 : 
; 1170 : 				temp.rgba = psector->extra_colormap->rgba;
; 1171 : 				alpha = (INT32)((26 - temp.s.alpha)*lightnum);
; 1172 : 
; 1173 : 				Surf->FlatColor.s.red =
; 1174 : 					(UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 1175 : 				Surf->FlatColor.s.blue =
; 1176 : 					(UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 1177 : 				Surf->FlatColor.s.green =
; 1178 : 					(UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 1179 : 				Surf->FlatColor.s.alpha = 0xff;
; 1180 : 			}
; 1181 : #endif
; 1182 : 		}
; 1183 : 
; 1184 : 		wallVerts[3].t = wallVerts[2].t = pegt + ((realtop - top) * pegmul);

  002b2	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  002b7	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _top$[ebp]
  002bc	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  002c1	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  002c6	f3 0f 58 c8	 addss	 xmm1, xmm0
  002ca	f3 0f 11 8d 74
	ff ff ff	 movss	 DWORD PTR tv207[ebp], xmm1
  002d2	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  002d7	d1 e0		 shl	 eax, 1
  002d9	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  002dc	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv207[ebp]
  002e4	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  002ea	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  002ef	6b c2 03	 imul	 eax, edx, 3
  002f2	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  002f5	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv207[ebp]
  002fd	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1185 : 		wallVerts[0].t = wallVerts[1].t = pegt + ((realtop - bot) * pegmul);

  00303	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  00308	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _bot$[ebp]
  0030d	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  00312	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  00317	f3 0f 58 c8	 addss	 xmm1, xmm0
  0031b	f3 0f 11 8d 74
	ff ff ff	 movss	 DWORD PTR tv218[ebp], xmm1
  00323	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00328	c1 e0 00	 shl	 eax, 0
  0032b	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0032e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv218[ebp]
  00336	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  0033c	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00341	6b c2 00	 imul	 eax, edx, 0
  00344	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00347	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv218[ebp]
  0034f	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1186 : 
; 1187 : 		// set top/bottom coords
; 1188 : 		wallVerts[2].y = wallVerts[3].y = top;

  00355	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0035a	6b c8 03	 imul	 ecx, eax, 3
  0035d	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  00360	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _top$[ebp]
  00365	f3 0f 11 44 0a
	04		 movss	 DWORD PTR [edx+ecx+4], xmm0
  0036b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00370	d1 e0		 shl	 eax, 1
  00372	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00375	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _top$[ebp]
  0037a	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1189 : 		wallVerts[0].y = wallVerts[1].y = bot;

  00380	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00385	c1 e0 00	 shl	 eax, 0
  00388	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0038b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _bot$[ebp]
  00390	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
  00396	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0039b	6b c2 00	 imul	 eax, edx, 0
  0039e	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  003a1	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _bot$[ebp]
  003a6	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1190 : 
; 1191 : 		glTex = HWR_GetTexture(texnum);

  003ac	8b 45 10	 mov	 eax, DWORD PTR _texnum$[ebp]
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 _HWR_GetTexture
  003b5	83 c4 04	 add	 esp, 4
  003b8	89 45 fc	 mov	 DWORD PTR _glTex$[ebp], eax

; 1192 : 		if (cutflag & FF_TRANSLUCENT)

  003bb	8b 45 18	 mov	 eax, DWORD PTR _cutflag$[ebp]
  003be	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  003c3	74 22		 je	 SHORT $LN23@HWR_SplitW

; 1193 : 			HWR_AddTransparentWall(wallVerts, Surf, texnum, PF_Translucent, false, lightnum, colormap);

  003c5	8b 45 c0	 mov	 eax, DWORD PTR _colormap$1[ebp]
  003c8	50		 push	 eax
  003c9	8b 4d c4	 mov	 ecx, DWORD PTR _lightnum$2[ebp]
  003cc	51		 push	 ecx
  003cd	6a 00		 push	 0
  003cf	6a 02		 push	 2
  003d1	8b 55 10	 mov	 edx, DWORD PTR _texnum$[ebp]
  003d4	52		 push	 edx
  003d5	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  003d8	50		 push	 eax
  003d9	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  003e2	83 c4 1c	 add	 esp, 28			; 0000001cH
  003e5	eb 47		 jmp	 SHORT $LN26@HWR_SplitW
$LN23@HWR_SplitW:

; 1194 : 		else if (glTex->mipmap.flags & TF_TRANSPARENT)

  003e7	8b 45 fc	 mov	 eax, DWORD PTR _glTex$[ebp]
  003ea	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003ed	83 e1 40	 and	 ecx, 64			; 00000040H
  003f0	74 22		 je	 SHORT $LN25@HWR_SplitW

; 1195 : 			HWR_AddTransparentWall(wallVerts, Surf, texnum, PF_Environment, false, lightnum, colormap);

  003f2	8b 45 c0	 mov	 eax, DWORD PTR _colormap$1[ebp]
  003f5	50		 push	 eax
  003f6	8b 4d c4	 mov	 ecx, DWORD PTR _lightnum$2[ebp]
  003f9	51		 push	 ecx
  003fa	6a 00		 push	 0
  003fc	6a 08		 push	 8
  003fe	8b 55 10	 mov	 edx, DWORD PTR _texnum$[ebp]
  00401	52		 push	 edx
  00402	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  00405	50		 push	 eax
  00406	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00409	51		 push	 ecx
  0040a	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  0040f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00412	eb 1a		 jmp	 SHORT $LN26@HWR_SplitW
$LN25@HWR_SplitW:

; 1196 : 		else
; 1197 : 			HWR_ProjectWall(wallVerts, Surf, PF_Masked, lightnum, colormap);

  00414	8b 45 c0	 mov	 eax, DWORD PTR _colormap$1[ebp]
  00417	50		 push	 eax
  00418	8b 4d c4	 mov	 ecx, DWORD PTR _lightnum$2[ebp]
  0041b	51		 push	 ecx
  0041c	6a 01		 push	 1
  0041e	8b 55 14	 mov	 edx, DWORD PTR _Surf$[ebp]
  00421	52		 push	 edx
  00422	8b 45 0c	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  00425	50		 push	 eax
  00426	e8 00 00 00 00	 call	 _HWR_ProjectWall
  0042b	83 c4 14	 add	 esp, 20			; 00000014H
$LN26@HWR_SplitW:

; 1198 : 
; 1199 : 		if (solid)

  0042e	83 7d d4 00	 cmp	 DWORD PTR _solid$[ebp], 0
  00432	74 0c		 je	 SHORT $LN27@HWR_SplitW

; 1200 : 			top = bheight;

  00434	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _bheight$[ebp]
  00439	f3 0f 11 45 f0	 movss	 DWORD PTR _top$[ebp], xmm0
  0043e	eb 0a		 jmp	 SHORT $LN28@HWR_SplitW
$LN27@HWR_SplitW:

; 1201 : 		else
; 1202 : 			top = height;

  00440	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _height$[ebp]
  00445	f3 0f 11 45 f0	 movss	 DWORD PTR _top$[ebp], xmm0
$LN28@HWR_SplitW:

; 1203 : 	}

  0044a	e9 72 fc ff ff	 jmp	 $LN2@HWR_SplitW
$LN3@HWR_SplitW:

; 1204 : 
; 1205 : 	FUINT lightnum;
; 1206 : 	extracolormap_t *colormap;
; 1207 : 
; 1208 : 	bot = realbot;

  0044f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  00454	f3 0f 11 45 ec	 movss	 DWORD PTR _bot$[ebp], xmm0

; 1209 : 	if (top <= realbot)

  00459	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _realbot$[ebp]
  0045e	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _top$[ebp]
  00462	72 05		 jb	 SHORT $LN29@HWR_SplitW

; 1210 : 		return;

  00464	e9 d9 01 00 00	 jmp	 $LN35@HWR_SplitW
$LN29@HWR_SplitW:

; 1211 : 
; 1212 : 	{
; 1213 : #ifndef HARDWAREFIX
; 1214 : 		lightnum = LightLevelToLum(*list[i-1].lightlevel);
; 1215 : 		// store Surface->FlatColor to modulate wall texture
; 1216 : 		Surf->FlatColor.s.red = Surf->FlatColor.s.green = Surf->FlatColor.s.blue
; 1217 : 			= (UINT8)lightnum;
; 1218 : #endif
; 1219 : 
; 1220 : #ifdef HARDWAREFIX
; 1221 : 		if (list[i-1].caster)

  00469	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  0046c	83 e8 01	 sub	 eax, 1
  0046f	6b c8 14	 imul	 ecx, eax, 20
  00472	8b 55 cc	 mov	 edx, DWORD PTR _list$[ebp]
  00475	83 7c 0a 10 00	 cmp	 DWORD PTR [edx+ecx+16], 0
  0047a	74 2b		 je	 SHORT $LN30@HWR_SplitW

; 1222 : 		{
; 1223 : 			lightnum = *list[i-1].lightlevel;

  0047c	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  0047f	83 e8 01	 sub	 eax, 1
  00482	6b c8 14	 imul	 ecx, eax, 20
  00485	8b 55 cc	 mov	 edx, DWORD PTR _list$[ebp]
  00488	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0048c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0048f	89 4d bc	 mov	 DWORD PTR _lightnum$[ebp], ecx

; 1224 : 			colormap = list[i-1].extra_colormap;

  00492	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00495	83 e8 01	 sub	 eax, 1
  00498	6b c8 14	 imul	 ecx, eax, 20
  0049b	8b 55 cc	 mov	 edx, DWORD PTR _list$[ebp]
  0049e	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  004a2	89 45 b8	 mov	 DWORD PTR _colormap$[ebp], eax

; 1225 : 		}

  004a5	eb 16		 jmp	 SHORT $LN31@HWR_SplitW
$LN30@HWR_SplitW:

; 1226 : 		else
; 1227 : 		{
; 1228 : 			lightnum = sector->lightlevel;

  004a7	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  004aa	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  004ae	89 4d bc	 mov	 DWORD PTR _lightnum$[ebp], ecx

; 1229 : 			colormap = sector->extra_colormap;

  004b1	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  004b4	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  004ba	89 4d b8	 mov	 DWORD PTR _colormap$[ebp], ecx
$LN31@HWR_SplitW:

; 1230 : 		}
; 1231 : #endif
; 1232 : #ifdef HARDWAREFIX
; 1233 : 		Surf->FlatColor.s.alpha = alpha;

  004bd	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  004c0	8a 4d cb	 mov	 cl, BYTE PTR _alpha$[ebp]
  004c3	88 48 07	 mov	 BYTE PTR [eax+7], cl

; 1234 : #else
; 1235 : 		{
; 1236 : 			RGBA_t  temp;
; 1237 : 			INT32     alpha;
; 1238 : 
; 1239 : 			temp.rgba = psector->extra_colormap->rgba;
; 1240 : 			alpha = (INT32)((26 - temp.s.alpha)*lightnum);
; 1241 : 			Surf->FlatColor.s.red = (UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 1242 : 			Surf->FlatColor.s.blue = (UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 1243 : 			Surf->FlatColor.s.green = (UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 1244 : 			Surf->FlatColor.s.alpha = 0xFF;
; 1245 : 		}
; 1246 : #endif
; 1247 : 	}
; 1248 : 
; 1249 : 	wallVerts[3].t = wallVerts[2].t = pegt + ((realtop - top) * pegmul);

  004c6	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  004cb	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _top$[ebp]
  004d0	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  004d5	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  004da	f3 0f 58 c8	 addss	 xmm1, xmm0
  004de	f3 0f 11 8d 74
	ff ff ff	 movss	 DWORD PTR tv288[ebp], xmm1
  004e6	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004eb	d1 e0		 shl	 eax, 1
  004ed	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  004f0	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv288[ebp]
  004f8	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  004fe	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00503	6b c2 03	 imul	 eax, edx, 3
  00506	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00509	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv288[ebp]
  00511	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1250 : 	wallVerts[0].t = wallVerts[1].t = pegt + ((realtop - bot) * pegmul);

  00517	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _realtop$[ebp]
  0051c	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _bot$[ebp]
  00521	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _pegmul$[ebp]
  00526	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _pegt$[ebp]
  0052b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0052f	f3 0f 11 8d 74
	ff ff ff	 movss	 DWORD PTR tv299[ebp], xmm1
  00537	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0053c	c1 e0 00	 shl	 eax, 0
  0053f	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00542	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv299[ebp]
  0054a	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0
  00550	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00555	6b c2 00	 imul	 eax, edx, 0
  00558	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0055b	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR tv299[ebp]
  00563	f3 0f 11 44 01
	10		 movss	 DWORD PTR [ecx+eax+16], xmm0

; 1251 : 
; 1252 : 	// set top/bottom coords
; 1253 : 	wallVerts[2].y = wallVerts[3].y = top;

  00569	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0056e	6b c8 03	 imul	 ecx, eax, 3
  00571	8b 55 0c	 mov	 edx, DWORD PTR _wallVerts$[ebp]
  00574	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _top$[ebp]
  00579	f3 0f 11 44 0a
	04		 movss	 DWORD PTR [edx+ecx+4], xmm0
  0057f	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00584	d1 e0		 shl	 eax, 1
  00586	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00589	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _top$[ebp]
  0058e	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1254 : 	wallVerts[0].y = wallVerts[1].y = bot;

  00594	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00599	c1 e0 00	 shl	 eax, 0
  0059c	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0059f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _bot$[ebp]
  005a4	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
  005aa	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  005af	6b c2 00	 imul	 eax, edx, 0
  005b2	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  005b5	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _bot$[ebp]
  005ba	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1255 : 
; 1256 : 	glTex = HWR_GetTexture(texnum);

  005c0	8b 45 10	 mov	 eax, DWORD PTR _texnum$[ebp]
  005c3	50		 push	 eax
  005c4	e8 00 00 00 00	 call	 _HWR_GetTexture
  005c9	83 c4 04	 add	 esp, 4
  005cc	89 45 fc	 mov	 DWORD PTR _glTex$[ebp], eax

; 1257 : 	if (cutflag & FF_TRANSLUCENT)

  005cf	8b 45 18	 mov	 eax, DWORD PTR _cutflag$[ebp]
  005d2	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  005d7	74 22		 je	 SHORT $LN32@HWR_SplitW

; 1258 : 		HWR_AddTransparentWall(wallVerts, Surf, texnum, PF_Translucent, false, lightnum, colormap);

  005d9	8b 45 b8	 mov	 eax, DWORD PTR _colormap$[ebp]
  005dc	50		 push	 eax
  005dd	8b 4d bc	 mov	 ecx, DWORD PTR _lightnum$[ebp]
  005e0	51		 push	 ecx
  005e1	6a 00		 push	 0
  005e3	6a 02		 push	 2
  005e5	8b 55 10	 mov	 edx, DWORD PTR _texnum$[ebp]
  005e8	52		 push	 edx
  005e9	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  005ec	50		 push	 eax
  005ed	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  005f0	51		 push	 ecx
  005f1	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  005f6	83 c4 1c	 add	 esp, 28			; 0000001cH
  005f9	eb 47		 jmp	 SHORT $LN35@HWR_SplitW
$LN32@HWR_SplitW:

; 1259 : 	else if (glTex->mipmap.flags & TF_TRANSPARENT)

  005fb	8b 45 fc	 mov	 eax, DWORD PTR _glTex$[ebp]
  005fe	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00601	83 e1 40	 and	 ecx, 64			; 00000040H
  00604	74 22		 je	 SHORT $LN34@HWR_SplitW

; 1260 : 		HWR_AddTransparentWall(wallVerts, Surf, texnum, PF_Environment, false, lightnum, colormap);

  00606	8b 45 b8	 mov	 eax, DWORD PTR _colormap$[ebp]
  00609	50		 push	 eax
  0060a	8b 4d bc	 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0060d	51		 push	 ecx
  0060e	6a 00		 push	 0
  00610	6a 08		 push	 8
  00612	8b 55 10	 mov	 edx, DWORD PTR _texnum$[ebp]
  00615	52		 push	 edx
  00616	8b 45 14	 mov	 eax, DWORD PTR _Surf$[ebp]
  00619	50		 push	 eax
  0061a	8b 4d 0c	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0061d	51		 push	 ecx
  0061e	e8 00 00 00 00	 call	 _HWR_AddTransparentWall
  00623	83 c4 1c	 add	 esp, 28			; 0000001cH
  00626	eb 1a		 jmp	 SHORT $LN35@HWR_SplitW
$LN34@HWR_SplitW:

; 1261 : 	else
; 1262 : 		HWR_ProjectWall(wallVerts, Surf, PF_Masked, lightnum, colormap);

  00628	8b 45 b8	 mov	 eax, DWORD PTR _colormap$[ebp]
  0062b	50		 push	 eax
  0062c	8b 4d bc	 mov	 ecx, DWORD PTR _lightnum$[ebp]
  0062f	51		 push	 ecx
  00630	6a 01		 push	 1
  00632	8b 55 14	 mov	 edx, DWORD PTR _Surf$[ebp]
  00635	52		 push	 edx
  00636	8b 45 0c	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  00639	50		 push	 eax
  0063a	e8 00 00 00 00	 call	 _HWR_ProjectWall
  0063f	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@HWR_SplitW:

; 1263 : }

  00642	5f		 pop	 edi
  00643	5e		 pop	 esi
  00644	5b		 pop	 ebx
  00645	8b e5		 mov	 esp, ebp
  00647	5d		 pop	 ebp
  00648	c3		 ret	 0
_HWR_SplitWall ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ClipViewSegment
_TEXT	SEGMENT
tv161 = -104						; size = 4
_pclipangle$ = -36					; size = 4
_v2dy$ = -32						; size = 4
_v2dx$ = -28						; size = 4
_v1dy$ = -24						; size = 4
_v1dx$ = -20						; size = 4
_v1y$ = -16						; size = 4
_v1x$ = -12						; size = 4
_den$ = -8						; size = 4
_num$ = -4						; size = 4
_x$ = 8							; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_HWR_ClipViewSegment PROC				; COMDAT

; 1030 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1031 : 	float num, den;
; 1032 : 	float v1x, v1y, v1dx, v1dy, v2dx, v2dy;
; 1033 : 	angle_t pclipangle = gr_xtoviewangle[x];

  00009	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _gr_xtoviewangle[eax*4]
  00013	89 4d dc	 mov	 DWORD PTR _pclipangle$[ebp], ecx

; 1034 : 
; 1035 : 	// a segment of a polygon
; 1036 : 	v1x  = v1->x;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  00019	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001d	f3 0f 11 45 f4	 movss	 DWORD PTR _v1x$[ebp], xmm0

; 1037 : 	v1y  = v1->y;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  00025	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0002a	f3 0f 11 45 f0	 movss	 DWORD PTR _v1y$[ebp], xmm0

; 1038 : 	v1dx = (v2->x - v1->x);

  0002f	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  00035	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00039	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0003d	f3 0f 11 45 ec	 movss	 DWORD PTR _v1dx$[ebp], xmm0

; 1039 : 	v1dy = (v2->y - v1->y);

  00042	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  00048	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004d	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00052	f3 0f 11 45 e8	 movss	 DWORD PTR _v1dy$[ebp], xmm0

; 1040 : 
; 1041 : 	// the clipping line
; 1042 : 	pclipangle = pclipangle + dup_viewangle; //back to normal angle (non-relative)

  00057	8b 45 dc	 mov	 eax, DWORD PTR _pclipangle$[ebp]
  0005a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dup_viewangle
  00060	89 45 dc	 mov	 DWORD PTR _pclipangle$[ebp], eax

; 1043 : 	v2dx = FIXED_TO_FLOAT(FINECOSINE(pclipangle>>ANGLETOFINESHIFT));

  00063	8b 45 dc	 mov	 eax, DWORD PTR _pclipangle$[ebp]
  00066	c1 e8 13	 shr	 eax, 19			; 00000013H
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  0006f	f3 0f 2a 04 81	 cvtsi2ss xmm0, DWORD PTR [ecx+eax*4]
  00074	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0007c	f3 0f 11 45 e4	 movss	 DWORD PTR _v2dx$[ebp], xmm0

; 1044 : 	v2dy = FIXED_TO_FLOAT(FINESINE(pclipangle>>ANGLETOFINESHIFT));

  00081	8b 45 dc	 mov	 eax, DWORD PTR _pclipangle$[ebp]
  00084	c1 e8 13	 shr	 eax, 19			; 00000013H
  00087	f3 0f 2a 04 85
	00 00 00 00	 cvtsi2ss xmm0, DWORD PTR _finesine[eax*4]
  00090	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00098	f3 0f 11 45 e0	 movss	 DWORD PTR _v2dy$[ebp], xmm0

; 1045 : 
; 1046 : 	den = v2dy*v1dx - v2dx*v1dy;

  0009d	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _v2dy$[ebp]
  000a2	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _v1dx$[ebp]
  000a7	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _v2dx$[ebp]
  000ac	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _v1dy$[ebp]
  000b1	f3 0f 5c c1	 subss	 xmm0, xmm1
  000b5	f3 0f 11 45 f8	 movss	 DWORD PTR _den$[ebp], xmm0

; 1047 : 	if (den == 0)

  000ba	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _den$[ebp]
  000bf	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000c6	9f		 lahf
  000c7	f6 c4 44	 test	 ah, 68			; 00000044H
  000ca	7a 08		 jp	 SHORT $LN2@HWR_ClipVi

; 1048 : 		return -1; // parallel

  000cc	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  000d2	eb 3f		 jmp	 SHORT $LN1@HWR_ClipVi
$LN2@HWR_ClipVi:

; 1049 : 
; 1050 : 	// calc the frac along the polygon segment,
; 1051 : 	//num = (v2x - v1x)*v2dy + (v1y - v2y)*v2dx;
; 1052 : 	//num = -v1x * v2dy + v1y * v2dx;
; 1053 : 	num = (gr_viewx - v1x)*v2dy + (v1y - gr_viewy)*v2dx;

  000d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewx
  000dc	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _v1x$[ebp]
  000e1	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _v2dy$[ebp]
  000e6	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v1y$[ebp]
  000eb	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR _gr_viewy
  000f3	f3 0f 59 4d e4	 mulss	 xmm1, DWORD PTR _v2dx$[ebp]
  000f8	f3 0f 58 c1	 addss	 xmm0, xmm1
  000fc	f3 0f 11 45 fc	 movss	 DWORD PTR _num$[ebp], xmm0

; 1054 : 
; 1055 : 	return num / den;

  00101	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _num$[ebp]
  00106	f3 0f 5e 45 f8	 divss	 xmm0, DWORD PTR _den$[ebp]
  0010b	f3 0f 11 45 98	 movss	 DWORD PTR tv161[ebp], xmm0
  00110	d9 45 98	 fld	 DWORD PTR tv161[ebp]
$LN1@HWR_ClipVi:

; 1056 : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
_HWR_ClipViewSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ProjectWall
_TEXT	SEGMENT
_wv$ = -104						; size = 4
_trVerts$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_wallVerts$ = 8						; size = 4
_pSurf$ = 12						; size = 4
_blendmode$ = 16					; size = 4
_lightlevel$ = 20					; size = 4
_wallcolormap$ = 24					; size = 4
_HWR_ProjectWall PROC					; COMDAT

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 969  : 	FOutVector  trVerts[4];
; 970  : 	FOutVector  *wv;
; 971  : 
; 972  : 	// transform
; 973  : 	wv = trVerts;

  00016	8d 45 9c	 lea	 eax, DWORD PTR _trVerts$[ebp]
  00019	89 45 98	 mov	 DWORD PTR _wv$[ebp], eax

; 974  : 	// it sounds really stupid to do this conversion with the new T&L code
; 975  : 	// we should directly put the right information in the right structure
; 976  : 	// wallVerts3D seems ok, doesn't need FOutVector
; 977  : 	// also remove the light copy
; 978  : 
; 979  : 	// More messy to unwrap, but it's also quicker, uses less memory.
; 980  : 	wv->sow = wallVerts->s;

  0001c	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00022	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00025	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 981  : 	wv->tow = wallVerts->t;

  00028	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0002e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00031	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 982  : 	wv->x   = wallVerts->x;

  00034	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	89 10		 mov	 DWORD PTR [eax], edx

; 983  : 	wv->y   = wallVerts->y;

  0003e	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00044	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00047	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 984  : 	wv->z   = wallVerts->z;

  0004a	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00050	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00053	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 985  : 	wv++; wallVerts++;

  00056	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00059	83 c0 18	 add	 eax, 24			; 00000018H
  0005c	89 45 98	 mov	 DWORD PTR _wv$[ebp], eax
  0005f	8b 45 08	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  00062	83 c0 18	 add	 eax, 24			; 00000018H
  00065	89 45 08	 mov	 DWORD PTR _wallVerts$[ebp], eax

; 986  : 	wv->sow = wallVerts->s;

  00068	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0006e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00071	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 987  : 	wv->tow = wallVerts->t;

  00074	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0007a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0007d	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 988  : 	wv->x   = wallVerts->x;

  00080	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00086	8b 11		 mov	 edx, DWORD PTR [ecx]
  00088	89 10		 mov	 DWORD PTR [eax], edx

; 989  : 	wv->y   = wallVerts->y;

  0008a	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00090	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00093	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 990  : 	wv->z   = wallVerts->z;

  00096	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0009c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 991  : 	wv++; wallVerts++;

  000a2	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000a5	83 c0 18	 add	 eax, 24			; 00000018H
  000a8	89 45 98	 mov	 DWORD PTR _wv$[ebp], eax
  000ab	8b 45 08	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  000ae	83 c0 18	 add	 eax, 24			; 00000018H
  000b1	89 45 08	 mov	 DWORD PTR _wallVerts$[ebp], eax

; 992  : 	wv->sow = wallVerts->s;

  000b4	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  000ba	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000bd	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 993  : 	wv->tow = wallVerts->t;

  000c0	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  000c6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000c9	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 994  : 	wv->x   = wallVerts->x;

  000cc	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  000d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d4	89 10		 mov	 DWORD PTR [eax], edx

; 995  : 	wv->y   = wallVerts->y;

  000d6	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000d9	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  000dc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000df	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 996  : 	wv->z   = wallVerts->z;

  000e2	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  000e8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000eb	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 997  : 	wv++; wallVerts++;

  000ee	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  000f1	83 c0 18	 add	 eax, 24			; 00000018H
  000f4	89 45 98	 mov	 DWORD PTR _wv$[ebp], eax
  000f7	8b 45 08	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  000fa	83 c0 18	 add	 eax, 24			; 00000018H
  000fd	89 45 08	 mov	 DWORD PTR _wallVerts$[ebp], eax

; 998  : 	wv->sow = wallVerts->s;

  00100	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00106	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00109	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 999  : 	wv->tow = wallVerts->t;

  0010c	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00112	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00115	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1000 : 	wv->x   = wallVerts->x;

  00118	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  0011e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00120	89 10		 mov	 DWORD PTR [eax], edx

; 1001 : 	wv->y   = wallVerts->y;

  00122	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00125	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00128	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1002 : 	wv->z   = wallVerts->z;

  0012e	8b 45 98	 mov	 eax, DWORD PTR _wv$[ebp]
  00131	8b 4d 08	 mov	 ecx, DWORD PTR _wallVerts$[ebp]
  00134	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00137	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1003 : 
; 1004 : 	if (wallcolormap)

  0013a	83 7d 18 00	 cmp	 DWORD PTR _wallcolormap$[ebp], 0
  0013e	74 32		 je	 SHORT $LN2@HWR_Projec

; 1005 : 	{
; 1006 : 		pSurf->FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), wallcolormap->rgba, wallcolormap->fadergba, false, false);

  00140	6a 00		 push	 0
  00142	6a 00		 push	 0
  00144	8b 45 18	 mov	 eax, DWORD PTR _wallcolormap$[ebp]
  00147	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0014a	51		 push	 ecx
  0014b	8b 55 18	 mov	 edx, DWORD PTR _wallcolormap$[ebp]
  0014e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00151	50		 push	 eax
  00152	8b 4d 14	 mov	 ecx, DWORD PTR _lightlevel$[ebp]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _LightLevelToLum
  0015b	83 c4 04	 add	 esp, 4
  0015e	0f b6 d0	 movzx	 edx, al
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 _HWR_Lighting
  00167	83 c4 14	 add	 esp, 20			; 00000014H
  0016a	8b 4d 0c	 mov	 ecx, DWORD PTR _pSurf$[ebp]
  0016d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1007 : 	}

  00170	eb 29		 jmp	 SHORT $LN3@HWR_Projec
$LN2@HWR_Projec:

; 1008 : 	else
; 1009 : 	{
; 1010 : 		pSurf->FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), NORMALFOG, FADEFOG, false, false);

  00172	6a 00		 push	 0
  00174	6a 00		 push	 0
  00176	68 00 00 00 19	 push	 419430400		; 19000000H
  0017b	6a 00		 push	 0
  0017d	8b 45 14	 mov	 eax, DWORD PTR _lightlevel$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _LightLevelToLum
  00186	83 c4 04	 add	 esp, 4
  00189	0f b6 c8	 movzx	 ecx, al
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 _HWR_Lighting
  00192	83 c4 14	 add	 esp, 20			; 00000014H
  00195	8b 55 0c	 mov	 edx, DWORD PTR _pSurf$[ebp]
  00198	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@HWR_Projec:

; 1011 : 	}
; 1012 : 
; 1013 : 	HWD.pfnDrawPolygon(pSurf, trVerts, 4, blendmode|PF_Modulated|PF_Occlude|PF_Clip);

  0019b	8b 45 10	 mov	 eax, DWORD PTR _blendmode$[ebp]
  0019e	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  001a3	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  001a8	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  001ad	50		 push	 eax
  001ae	6a 04		 push	 4
  001b0	8d 4d 9c	 lea	 ecx, DWORD PTR _trVerts$[ebp]
  001b3	51		 push	 ecx
  001b4	8b 55 0c	 mov	 edx, DWORD PTR _pSurf$[ebp]
  001b7	52		 push	 edx
  001b8	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  001be	90		 npad	 1

; 1014 : 
; 1015 : #ifdef WALLSPLATS
; 1016 : 	if (gr_curline->linedef->splats && cv_splats.value)
; 1017 : 		HWR_DrawSegsSplats(pSurf);
; 1018 : #endif
; 1019 : }

  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c5	33 cd		 xor	 ecx, ebp
  001c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c3		 ret	 0
_HWR_ProjectWall ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddTransparentWall
_TEXT	SEGMENT
_wallVerts$ = 8						; size = 4
_pSurf$ = 12						; size = 4
_texnum$ = 16						; size = 4
_blend$ = 20						; size = 4
_fogwall$ = 24						; size = 4
_lightlevel$ = 28					; size = 4
_wallcolormap$ = 32					; size = 4
_HWR_AddTransparentWall PROC				; COMDAT

; 5090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5091 : 	if (!(numwalls % MAX_TRANSPARENTWALL))

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  0000e	33 d2		 xor	 edx, edx
  00010	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00015	f7 f1		 div	 ecx
  00017	85 d2		 test	 edx, edx
  00019	75 28		 jne	 SHORT $LN2@HWR_AddTra

; 5092 : 	{
; 5093 : 		wallinfo = Z_Realloc(wallinfo,

  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 01		 push	 1
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  00026	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0002b	c1 e0 07	 shl	 eax, 7
  0002e	50		 push	 eax
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _Z_ReallocAlign
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
  0003e	a3 00 00 00 00	 mov	 DWORD PTR _wallinfo, eax
$LN2@HWR_AddTra:

; 5094 : 			(numwalls + MAX_TRANSPARENTWALL) * sizeof *wallinfo, PU_STATIC, NULL);
; 5095 : 	}
; 5096 : 
; 5097 : 	M_Memcpy(wallinfo[numwalls].wallVerts, wallVerts, sizeof (wallinfo[numwalls].wallVerts));

  00043	6a 60		 push	 96			; 00000060H
  00045	8b 45 08	 mov	 eax, DWORD PTR _wallVerts$[ebp]
  00048	50		 push	 eax
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numwalls
  0004f	c1 e1 07	 shl	 ecx, 7
  00052	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _wallinfo
  00058	51		 push	 ecx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5098 : 	M_Memcpy(&wallinfo[numwalls].Surf, pSurf, sizeof (FSurfaceInfo));

  00062	6a 08		 push	 8
  00064	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00067	50		 push	 eax
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numwalls
  0006e	c1 e1 07	 shl	 ecx, 7
  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wallinfo
  00077	8d 44 0a 60	 lea	 eax, DWORD PTR [edx+ecx+96]
  0007b	50		 push	 eax
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5099 : 	wallinfo[numwalls].texnum = texnum;

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  0008a	c1 e0 07	 shl	 eax, 7
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  00093	8b 55 10	 mov	 edx, DWORD PTR _texnum$[ebp]
  00096	89 54 01 68	 mov	 DWORD PTR [ecx+eax+104], edx

; 5100 : 	wallinfo[numwalls].blend = blend;

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  0009f	c1 e0 07	 shl	 eax, 7
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  000a8	8b 55 14	 mov	 edx, DWORD PTR _blend$[ebp]
  000ab	89 54 01 6c	 mov	 DWORD PTR [ecx+eax+108], edx

; 5101 : #ifdef SORTING
; 5102 : 	wallinfo[numwalls].drawcount = drawcount++;

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  000b4	c1 e0 07	 shl	 eax, 7
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  000bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _drawcount
  000c3	89 54 01 70	 mov	 DWORD PTR [ecx+eax+112], edx
  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _drawcount
  000cc	83 c0 01	 add	 eax, 1
  000cf	a3 00 00 00 00	 mov	 DWORD PTR _drawcount, eax

; 5103 : #endif
; 5104 : 	wallinfo[numwalls].fogwall = fogwall;

  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  000d9	c1 e0 07	 shl	 eax, 7
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  000e2	8b 55 18	 mov	 edx, DWORD PTR _fogwall$[ebp]
  000e5	89 54 01 74	 mov	 DWORD PTR [ecx+eax+116], edx

; 5105 : 	wallinfo[numwalls].lightlevel = lightlevel;

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  000ee	c1 e0 07	 shl	 eax, 7
  000f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  000f7	8b 55 1c	 mov	 edx, DWORD PTR _lightlevel$[ebp]
  000fa	89 54 01 78	 mov	 DWORD PTR [ecx+eax+120], edx

; 5106 : 	wallinfo[numwalls].wallcolormap = wallcolormap;

  000fe	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  00103	c1 e0 07	 shl	 eax, 7
  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wallinfo
  0010c	8b 55 20	 mov	 edx, DWORD PTR _wallcolormap$[ebp]
  0010f	89 54 01 7c	 mov	 DWORD PTR [ecx+eax+124], edx

; 5107 : 	numwalls++;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _numwalls
  00118	83 c0 01	 add	 eax, 1
  0011b	a3 00 00 00 00	 mov	 DWORD PTR _numwalls, eax

; 5108 : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
_HWR_AddTransparentWall ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_RenderPlane
_TEXT	SEGMENT
tv81 = -136						; size = 4
_tempytow$ = -68					; size = 4
_tempxsow$ = -64					; size = 4
_Surf$ = -60						; size = 8
_angle$ = -52						; size = 4
_scrolly$ = -48						; size = 4
_scrollx$ = -44						; size = 4
_len$ = -40						; size = 4
_flatflag$ = -36					; size = 4
_fflatsize$ = -32					; size = 4
_flatyref$ = -28					; size = 4
_flatxref$ = -24					; size = 4
_i$ = -20						; size = 4
_nrPlaneVerts$ = -16					; size = 4
_v3d$ = -12						; size = 4
_height$ = -8						; size = 4
_pv$ = -4						; size = 4
_sector$ = 8						; size = 4
_xsub$ = 12						; size = 4
_fixedheight$ = 16					; size = 4
_PolyFlags$ = 20					; size = 4
_lightlevel$ = 24					; size = 4
_lumpnum$ = 28						; size = 4
_FOFsector$ = 32					; size = 4
_alpha$ = 36						; size = 1
_fogplane$ = 40						; size = 4
_planecolormap$ = 44					; size = 4
_HWR_RenderPlane PROC					; COMDAT

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 547  : 	polyvertex_t *  pv;
; 548  : 	float           height; //constant y for all points on the convex flat polygon
; 549  : 	FOutVector      *v3d;
; 550  : 	INT32             nrPlaneVerts;   //verts original define of convex flat polygon
; 551  : 	INT32             i;
; 552  : 	float           flatxref,flatyref;
; 553  : 	float fflatsize;
; 554  : 	INT32 flatflag;
; 555  : 	size_t len;
; 556  : 	float scrollx = 0.0f, scrolly = 0.0f;

  0000c	0f 57 c0	 xorps	 xmm0, xmm0
  0000f	f3 0f 11 45 d4	 movss	 DWORD PTR _scrollx$[ebp], xmm0
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	f3 0f 11 45 d0	 movss	 DWORD PTR _scrolly$[ebp], xmm0

; 557  : 	angle_t angle = 0;

  0001c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _angle$[ebp], 0

; 558  : 	FSurfaceInfo    Surf;
; 559  : 
; 560  : 	// no convex poly were generated for this subsector
; 561  : 	if (!xsub->planepoly)

  00023	8b 45 0c	 mov	 eax, DWORD PTR _xsub$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	75 05		 jne	 SHORT $LN7@HWR_Render

; 562  : 		return;

  0002b	e9 e6 06 00 00	 jmp	 $LN33@HWR_Render
$LN7@HWR_Render:

; 563  : 
; 564  : 	height = FIXED_TO_FLOAT(fixedheight);

  00030	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _fixedheight$[ebp]
  00035	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0003d	f3 0f 11 45 f8	 movss	 DWORD PTR _height$[ebp], xmm0

; 565  : 
; 566  : 	pv  = xsub->planepoly->pts;

  00042	8b 45 0c	 mov	 eax, DWORD PTR _xsub$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	83 c1 04	 add	 ecx, 4
  0004a	89 4d fc	 mov	 DWORD PTR _pv$[ebp], ecx

; 567  : 	nrPlaneVerts = xsub->planepoly->numpts;

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _xsub$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f0	 mov	 DWORD PTR _nrPlaneVerts$[ebp], edx

; 568  : 
; 569  : 	if (nrPlaneVerts < 3)   //not even a triangle ?

  00057	83 7d f0 03	 cmp	 DWORD PTR _nrPlaneVerts$[ebp], 3
  0005b	7d 05		 jge	 SHORT $LN8@HWR_Render

; 570  : 		return;

  0005d	e9 b4 06 00 00	 jmp	 $LN33@HWR_Render
$LN8@HWR_Render:

; 571  : 
; 572  : 	if (nrPlaneVerts > MAXPLANEVERTICES) // FIXME: exceeds plVerts size

  00062	81 7d f0 00 08
	00 00		 cmp	 DWORD PTR _nrPlaneVerts$[ebp], 2048 ; 00000800H
  00069	7e 1b		 jle	 SHORT $LN9@HWR_Render

; 573  : 	{
; 574  : 		CONS_Printf("polygon size of %d exceeds max value of %d vertices\n", nrPlaneVerts, MAXPLANEVERTICES);

  0006b	68 00 08 00 00	 push	 2048			; 00000800H
  00070	8b 45 f0	 mov	 eax, DWORD PTR _nrPlaneVerts$[ebp]
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NEHIKJG@polygon?5size?5of?5?$CFd?5exceeds?5max?5@
  00079	e8 00 00 00 00	 call	 _CONS_Printf
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 575  : 		return;

  00081	e9 90 06 00 00	 jmp	 $LN33@HWR_Render
$LN9@HWR_Render:

; 576  : 	}
; 577  : 
; 578  : 	len = W_LumpLength(lumpnum);

  00086	8b 45 1c	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _W_LumpLength
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR _len$[ebp], eax

; 579  : 
; 580  : 	switch (len)

  00095	8b 45 d8	 mov	 eax, DWORD PTR _len$[ebp]
  00098	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  0009e	81 bd 78 ff ff
	ff 00 00 04 00	 cmp	 DWORD PTR tv81[ebp], 262144 ; 00040000H
  000a8	77 3d		 ja	 SHORT $LN35@HWR_Render
  000aa	81 bd 78 ff ff
	ff 00 00 04 00	 cmp	 DWORD PTR tv81[ebp], 262144 ; 00040000H
  000b4	74 7d		 je	 SHORT $LN12@HWR_Render
  000b6	81 bd 78 ff ff
	ff 00 04 00 00	 cmp	 DWORD PTR tv81[ebp], 1024 ; 00000400H
  000c0	0f 84 af 00 00
	00		 je	 $LN15@HWR_Render
  000c6	81 bd 78 ff ff
	ff 00 40 00 00	 cmp	 DWORD PTR tv81[ebp], 16384 ; 00004000H
  000d0	0f 84 89 00 00
	00		 je	 $LN14@HWR_Render
  000d6	81 bd 78 ff ff
	ff 00 00 01 00	 cmp	 DWORD PTR tv81[ebp], 65536 ; 00010000H
  000e0	74 67		 je	 SHORT $LN13@HWR_Render
  000e2	e9 a4 00 00 00	 jmp	 $LN16@HWR_Render
$LN35@HWR_Render:
  000e7	81 bd 78 ff ff
	ff 00 00 10 00	 cmp	 DWORD PTR tv81[ebp], 1048576 ; 00100000H
  000f1	74 2a		 je	 SHORT $LN11@HWR_Render
  000f3	81 bd 78 ff ff
	ff 00 00 40 00	 cmp	 DWORD PTR tv81[ebp], 4194304 ; 00400000H
  000fd	74 05		 je	 SHORT $LN10@HWR_Render
  000ff	e9 87 00 00 00	 jmp	 $LN16@HWR_Render
$LN10@HWR_Render:

; 581  : 	{
; 582  : 		case 4194304: // 2048x2048 lump
; 583  : 			fflatsize = 2048.0f;

  00104	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@45000000
  0010c	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 584  : 			flatflag = 2047;

  00111	c7 45 dc ff 07
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 2047 ; 000007ffH

; 585  : 			break;

  00118	e9 82 00 00 00	 jmp	 $LN2@HWR_Render
$LN11@HWR_Render:

; 586  : 		case 1048576: // 1024x1024 lump
; 587  : 			fflatsize = 1024.0f;

  0011d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44800000
  00125	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 588  : 			flatflag = 1023;

  0012a	c7 45 dc ff 03
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 1023 ; 000003ffH

; 589  : 			break;

  00131	eb 6c		 jmp	 SHORT $LN2@HWR_Render
$LN12@HWR_Render:

; 590  : 		case 262144:// 512x512 lump
; 591  : 			fflatsize = 512.0f;

  00133	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44000000
  0013b	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 592  : 			flatflag = 511;

  00140	c7 45 dc ff 01
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 511 ; 000001ffH

; 593  : 			break;

  00147	eb 56		 jmp	 SHORT $LN2@HWR_Render
$LN13@HWR_Render:

; 594  : 		case 65536: // 256x256 lump
; 595  : 			fflatsize = 256.0f;

  00149	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43800000
  00151	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 596  : 			flatflag = 255;

  00156	c7 45 dc ff 00
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 255 ; 000000ffH

; 597  : 			break;

  0015d	eb 40		 jmp	 SHORT $LN2@HWR_Render
$LN14@HWR_Render:

; 598  : 		case 16384: // 128x128 lump
; 599  : 			fflatsize = 128.0f;

  0015f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  00167	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 600  : 			flatflag = 127;

  0016c	c7 45 dc 7f 00
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 127 ; 0000007fH

; 601  : 			break;

  00173	eb 2a		 jmp	 SHORT $LN2@HWR_Render
$LN15@HWR_Render:

; 602  : 		case 1024: // 32x32 lump
; 603  : 			fflatsize = 32.0f;

  00175	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42000000
  0017d	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 604  : 			flatflag = 31;

  00182	c7 45 dc 1f 00
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 31 ; 0000001fH

; 605  : 			break;

  00189	eb 14		 jmp	 SHORT $LN2@HWR_Render
$LN16@HWR_Render:

; 606  : 		default: // 64x64 lump
; 607  : 			fflatsize = 64.0f;

  0018b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42800000
  00193	f3 0f 11 45 e0	 movss	 DWORD PTR _fflatsize$[ebp], xmm0

; 608  : 			flatflag = 63;

  00198	c7 45 dc 3f 00
	00 00		 mov	 DWORD PTR _flatflag$[ebp], 63 ; 0000003fH
$LN2@HWR_Render:

; 609  : 			break;
; 610  : 	}
; 611  : 
; 612  : 	// reference point for flat texture coord for each vertex around the polygon
; 613  : 	flatxref = (float)(((fixed_t)pv->x & (~flatflag)) / fflatsize);

  0019f	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  001a2	f3 0f 2c 08	 cvttss2si ecx, DWORD PTR [eax]
  001a6	8b 55 dc	 mov	 edx, DWORD PTR _flatflag$[ebp]
  001a9	f7 d2		 not	 edx
  001ab	23 ca		 and	 ecx, edx
  001ad	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001b1	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  001b6	f3 0f 11 45 e8	 movss	 DWORD PTR _flatxref$[ebp], xmm0

; 614  : 	flatyref = (float)(((fixed_t)pv->y & (~flatflag)) / fflatsize);

  001bb	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  001be	f3 0f 2c 48 04	 cvttss2si ecx, DWORD PTR [eax+4]
  001c3	8b 55 dc	 mov	 edx, DWORD PTR _flatflag$[ebp]
  001c6	f7 d2		 not	 edx
  001c8	23 ca		 and	 ecx, edx
  001ca	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001ce	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  001d3	f3 0f 11 45 e4	 movss	 DWORD PTR _flatyref$[ebp], xmm0

; 615  : 
; 616  : 	// transform
; 617  : 	v3d = planeVerts;

  001d8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _v3d$[ebp], OFFSET _planeVerts

; 618  : 
; 619  : 	if (FOFsector != NULL)

  001df	83 7d 20 00	 cmp	 DWORD PTR _FOFsector$[ebp], 0
  001e3	0f 84 91 00 00
	00		 je	 $LN17@HWR_Render

; 620  : 	{
; 621  : 		if (fixedheight == FOFsector->floorheight) // it's a floor

  001e9	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  001ec	8b 4d 10	 mov	 ecx, DWORD PTR _fixedheight$[ebp]
  001ef	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001f1	75 42		 jne	 SHORT $LN19@HWR_Render

; 622  : 		{
; 623  : 			scrollx = FIXED_TO_FLOAT(FOFsector->floor_xoffs)/fflatsize;

  001f3	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  001f6	f3 0f 2a 40 50	 cvtsi2ss xmm0, DWORD PTR [eax+80]
  001fb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00203	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  00208	f3 0f 11 45 d4	 movss	 DWORD PTR _scrollx$[ebp], xmm0

; 624  : 			scrolly = FIXED_TO_FLOAT(FOFsector->floor_yoffs)/fflatsize;

  0020d	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  00210	f3 0f 2a 40 54	 cvtsi2ss xmm0, DWORD PTR [eax+84]
  00215	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0021d	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  00222	f3 0f 11 45 d0	 movss	 DWORD PTR _scrolly$[ebp], xmm0

; 625  : 			angle = FOFsector->floorpic_angle>>ANGLETOFINESHIFT;

  00227	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  0022a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0022d	c1 e9 13	 shr	 ecx, 19			; 00000013H
  00230	89 4d cc	 mov	 DWORD PTR _angle$[ebp], ecx

; 626  : 		}

  00233	eb 40		 jmp	 SHORT $LN20@HWR_Render
$LN19@HWR_Render:

; 627  : 		else // it's a ceiling
; 628  : 		{
; 629  : 			scrollx = FIXED_TO_FLOAT(FOFsector->ceiling_xoffs)/fflatsize;

  00235	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  00238	f3 0f 2a 40 58	 cvtsi2ss xmm0, DWORD PTR [eax+88]
  0023d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00245	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  0024a	f3 0f 11 45 d4	 movss	 DWORD PTR _scrollx$[ebp], xmm0

; 630  : 			scrolly = FIXED_TO_FLOAT(FOFsector->ceiling_yoffs)/fflatsize;

  0024f	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  00252	f3 0f 2a 40 5c	 cvtsi2ss xmm0, DWORD PTR [eax+92]
  00257	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0025f	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  00264	f3 0f 11 45 d0	 movss	 DWORD PTR _scrolly$[ebp], xmm0

; 631  : 			angle = FOFsector->ceilingpic_angle>>ANGLETOFINESHIFT;

  00269	8b 45 20	 mov	 eax, DWORD PTR _FOFsector$[ebp]
  0026c	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0026f	c1 e9 13	 shr	 ecx, 19			; 00000013H
  00272	89 4d cc	 mov	 DWORD PTR _angle$[ebp], ecx
$LN20@HWR_Render:

; 632  : 		}
; 633  : 	}

  00275	e9 a6 00 00 00	 jmp	 $LN23@HWR_Render
$LN17@HWR_Render:

; 634  : 	else if (gr_frontsector)

  0027a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gr_frontsector, 0
  00281	0f 84 99 00 00
	00		 je	 $LN23@HWR_Render

; 635  : 	{
; 636  : 		if (fixedheight < dup_viewz) // it's a floor

  00287	8b 45 10	 mov	 eax, DWORD PTR _fixedheight$[ebp]
  0028a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dup_viewz
  00290	7d 48		 jge	 SHORT $LN22@HWR_Render

; 637  : 		{
; 638  : 			scrollx = FIXED_TO_FLOAT(gr_frontsector->floor_xoffs)/fflatsize;

  00292	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00297	f3 0f 2a 40 50	 cvtsi2ss xmm0, DWORD PTR [eax+80]
  0029c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  002a4	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  002a9	f3 0f 11 45 d4	 movss	 DWORD PTR _scrollx$[ebp], xmm0

; 639  : 			scrolly = FIXED_TO_FLOAT(gr_frontsector->floor_yoffs)/fflatsize;

  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  002b3	f3 0f 2a 40 54	 cvtsi2ss xmm0, DWORD PTR [eax+84]
  002b8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  002c0	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  002c5	f3 0f 11 45 d0	 movss	 DWORD PTR _scrolly$[ebp], xmm0

; 640  : 			angle = gr_frontsector->floorpic_angle>>ANGLETOFINESHIFT;

  002ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  002cf	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  002d2	c1 e9 13	 shr	 ecx, 19			; 00000013H
  002d5	89 4d cc	 mov	 DWORD PTR _angle$[ebp], ecx

; 641  : 		}

  002d8	eb 46		 jmp	 SHORT $LN23@HWR_Render
$LN22@HWR_Render:

; 642  : 		else // it's a ceiling
; 643  : 		{
; 644  : 			scrollx = FIXED_TO_FLOAT(gr_frontsector->ceiling_xoffs)/fflatsize;

  002da	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  002df	f3 0f 2a 40 58	 cvtsi2ss xmm0, DWORD PTR [eax+88]
  002e4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  002ec	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  002f1	f3 0f 11 45 d4	 movss	 DWORD PTR _scrollx$[ebp], xmm0

; 645  : 			scrolly = FIXED_TO_FLOAT(gr_frontsector->ceiling_yoffs)/fflatsize;

  002f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  002fb	f3 0f 2a 40 5c	 cvtsi2ss xmm0, DWORD PTR [eax+92]
  00300	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00308	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  0030d	f3 0f 11 45 d0	 movss	 DWORD PTR _scrolly$[ebp], xmm0

; 646  : 			angle = gr_frontsector->ceilingpic_angle>>ANGLETOFINESHIFT;

  00312	a1 00 00 00 00	 mov	 eax, DWORD PTR _gr_frontsector
  00317	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0031a	c1 e9 13	 shr	 ecx, 19			; 00000013H
  0031d	89 4d cc	 mov	 DWORD PTR _angle$[ebp], ecx
$LN23@HWR_Render:

; 647  : 		}
; 648  : 	}
; 649  : 
; 650  : 	fixed_t tempxsow, tempytow;
; 651  : 
; 652  : 	if (angle) // Only needs to be done if there's an altered angle

  00320	83 7d cc 00	 cmp	 DWORD PTR _angle$[ebp], 0
  00324	0f 84 64 01 00
	00		 je	 $LN24@HWR_Render

; 653  : 	{
; 654  : 		// This needs to be done so that it scrolls in a different direction after rotation like software
; 655  : 		tempxsow = FLOAT_TO_FIXED(scrollx);

  0032a	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _scrollx$[ebp]
  0032f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  00337	f3 0f 2c c0	 cvttss2si eax, xmm0
  0033b	89 45 c0	 mov	 DWORD PTR _tempxsow$[ebp], eax

; 656  : 		tempytow = FLOAT_TO_FIXED(scrolly);

  0033e	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _scrolly$[ebp]
  00343	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  0034b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0034f	89 45 bc	 mov	 DWORD PTR _tempytow$[ebp], eax

; 657  : 		scrollx = (FIXED_TO_FLOAT(FixedMul(tempxsow, FINECOSINE(angle)) - FixedMul(tempytow, FINESINE(angle))));

  00352	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  00355	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  0035b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0035e	52		 push	 edx
  0035f	8b 45 c0	 mov	 eax, DWORD PTR _tempxsow$[ebp]
  00362	50		 push	 eax
  00363	e8 00 00 00 00	 call	 _FixedMul
  00368	83 c4 08	 add	 esp, 8
  0036b	8b f0		 mov	 esi, eax
  0036d	8b 4d cc	 mov	 ecx, DWORD PTR _angle$[ebp]
  00370	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finesine[ecx*4]
  00377	52		 push	 edx
  00378	8b 45 bc	 mov	 eax, DWORD PTR _tempytow$[ebp]
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 _FixedMul
  00381	83 c4 08	 add	 esp, 8
  00384	2b f0		 sub	 esi, eax
  00386	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  0038a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00392	f3 0f 11 45 d4	 movss	 DWORD PTR _scrollx$[ebp], xmm0

; 658  : 		scrolly = (FIXED_TO_FLOAT(FixedMul(tempxsow, FINESINE(angle)) + FixedMul(tempytow, FINECOSINE(angle))));

  00397	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  0039a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  003a1	51		 push	 ecx
  003a2	8b 55 c0	 mov	 edx, DWORD PTR _tempxsow$[ebp]
  003a5	52		 push	 edx
  003a6	e8 00 00 00 00	 call	 _FixedMul
  003ab	83 c4 08	 add	 esp, 8
  003ae	8b f0		 mov	 esi, eax
  003b0	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  003b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  003b9	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  003bc	52		 push	 edx
  003bd	8b 45 bc	 mov	 eax, DWORD PTR _tempytow$[ebp]
  003c0	50		 push	 eax
  003c1	e8 00 00 00 00	 call	 _FixedMul
  003c6	83 c4 08	 add	 esp, 8
  003c9	03 f0		 add	 esi, eax
  003cb	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  003cf	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  003d7	f3 0f 11 45 d0	 movss	 DWORD PTR _scrolly$[ebp], xmm0

; 659  : 
; 660  : 		// This needs to be done so everything aligns after rotation
; 661  : 		// It would be done so that rotation is done, THEN the translation, but I couldn't get it to rotate AND scroll like software does
; 662  : 		tempxsow = FLOAT_TO_FIXED(flatxref);

  003dc	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _flatxref$[ebp]
  003e1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  003e9	f3 0f 2c c0	 cvttss2si eax, xmm0
  003ed	89 45 c0	 mov	 DWORD PTR _tempxsow$[ebp], eax

; 663  : 		tempytow = FLOAT_TO_FIXED(flatyref);

  003f0	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _flatyref$[ebp]
  003f5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  003fd	f3 0f 2c c0	 cvttss2si eax, xmm0
  00401	89 45 bc	 mov	 DWORD PTR _tempytow$[ebp], eax

; 664  : 		flatxref = (FIXED_TO_FLOAT(FixedMul(tempxsow, FINECOSINE(angle)) - FixedMul(tempytow, FINESINE(angle))));

  00404	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  00407	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  0040d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00410	52		 push	 edx
  00411	8b 45 c0	 mov	 eax, DWORD PTR _tempxsow$[ebp]
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 _FixedMul
  0041a	83 c4 08	 add	 esp, 8
  0041d	8b f0		 mov	 esi, eax
  0041f	8b 4d cc	 mov	 ecx, DWORD PTR _angle$[ebp]
  00422	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finesine[ecx*4]
  00429	52		 push	 edx
  0042a	8b 45 bc	 mov	 eax, DWORD PTR _tempytow$[ebp]
  0042d	50		 push	 eax
  0042e	e8 00 00 00 00	 call	 _FixedMul
  00433	83 c4 08	 add	 esp, 8
  00436	2b f0		 sub	 esi, eax
  00438	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  0043c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00444	f3 0f 11 45 e8	 movss	 DWORD PTR _flatxref$[ebp], xmm0

; 665  : 		flatyref = (FIXED_TO_FLOAT(FixedMul(tempxsow, FINESINE(angle)) + FixedMul(tempytow, FINECOSINE(angle))));

  00449	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  0044c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  00453	51		 push	 ecx
  00454	8b 55 c0	 mov	 edx, DWORD PTR _tempxsow$[ebp]
  00457	52		 push	 edx
  00458	e8 00 00 00 00	 call	 _FixedMul
  0045d	83 c4 08	 add	 esp, 8
  00460	8b f0		 mov	 esi, eax
  00462	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  00465	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  0046b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0046e	52		 push	 edx
  0046f	8b 45 bc	 mov	 eax, DWORD PTR _tempytow$[ebp]
  00472	50		 push	 eax
  00473	e8 00 00 00 00	 call	 _FixedMul
  00478	83 c4 08	 add	 esp, 8
  0047b	03 f0		 add	 esi, eax
  0047d	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  00481	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00489	f3 0f 11 45 e4	 movss	 DWORD PTR _flatyref$[ebp], xmm0
$LN24@HWR_Render:

; 666  : 	}
; 667  : 
; 668  : 	for (i = 0; i < nrPlaneVerts; i++,v3d++,pv++)

  0048e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00495	eb 1b		 jmp	 SHORT $LN6@HWR_Render
$LN4@HWR_Render:
  00497	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0049a	83 c0 01	 add	 eax, 1
  0049d	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  004a0	8b 4d f4	 mov	 ecx, DWORD PTR _v3d$[ebp]
  004a3	83 c1 18	 add	 ecx, 24			; 00000018H
  004a6	89 4d f4	 mov	 DWORD PTR _v3d$[ebp], ecx
  004a9	8b 55 fc	 mov	 edx, DWORD PTR _pv$[ebp]
  004ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  004af	89 55 fc	 mov	 DWORD PTR _pv$[ebp], edx
$LN6@HWR_Render:
  004b2	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  004b5	3b 45 f0	 cmp	 eax, DWORD PTR _nrPlaneVerts$[ebp]
  004b8	0f 8d 3a 01 00
	00		 jge	 $LN5@HWR_Render

; 669  : 	{
; 670  : 		// Hurdler: add scrolling texture on floor/ceiling
; 671  : 		v3d->sow = (float)((pv->x / fflatsize) - flatxref + scrollx);

  004be	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  004c1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004c5	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  004ca	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR _flatxref$[ebp]
  004cf	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _scrollx$[ebp]
  004d4	8b 4d f4	 mov	 ecx, DWORD PTR _v3d$[ebp]
  004d7	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0

; 672  : 		v3d->tow = (float)(flatyref - (pv->y / fflatsize) + scrolly);

  004dc	8b 45 fc	 mov	 eax, DWORD PTR _pv$[ebp]
  004df	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004e4	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _fflatsize$[ebp]
  004e9	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _flatyref$[ebp]
  004ee	f3 0f 5c c8	 subss	 xmm1, xmm0
  004f2	f3 0f 58 4d d0	 addss	 xmm1, DWORD PTR _scrolly$[ebp]
  004f7	8b 4d f4	 mov	 ecx, DWORD PTR _v3d$[ebp]
  004fa	f3 0f 11 49 14	 movss	 DWORD PTR [ecx+20], xmm1

; 673  : 
; 674  : 		//v3d->sow = (float)(pv->x / fflatsize);
; 675  : 		//v3d->tow = (float)(pv->y / fflatsize);
; 676  : 
; 677  : 		// Need to rotate before translate
; 678  : 		if (angle) // Only needs to be done if there's an altered angle

  004ff	83 7d cc 00	 cmp	 DWORD PTR _angle$[ebp], 0
  00503	0f 84 c0 00 00
	00		 je	 $LN25@HWR_Render

; 679  : 		{
; 680  : 			tempxsow = FLOAT_TO_FIXED(v3d->sow);

  00509	8b 45 f4	 mov	 eax, DWORD PTR _v3d$[ebp]
  0050c	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00511	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  00519	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0051d	89 4d c0	 mov	 DWORD PTR _tempxsow$[ebp], ecx

; 681  : 			tempytow = FLOAT_TO_FIXED(v3d->tow);

  00520	8b 45 f4	 mov	 eax, DWORD PTR _v3d$[ebp]
  00523	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00528	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  00530	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00534	89 4d bc	 mov	 DWORD PTR _tempytow$[ebp], ecx

; 682  : 			v3d->sow = (FIXED_TO_FLOAT(FixedMul(tempxsow, FINECOSINE(angle)) - FixedMul(tempytow, FINESINE(angle))));

  00537	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  0053a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00540	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00543	52		 push	 edx
  00544	8b 45 c0	 mov	 eax, DWORD PTR _tempxsow$[ebp]
  00547	50		 push	 eax
  00548	e8 00 00 00 00	 call	 _FixedMul
  0054d	83 c4 08	 add	 esp, 8
  00550	8b f0		 mov	 esi, eax
  00552	8b 4d cc	 mov	 ecx, DWORD PTR _angle$[ebp]
  00555	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finesine[ecx*4]
  0055c	52		 push	 edx
  0055d	8b 45 bc	 mov	 eax, DWORD PTR _tempytow$[ebp]
  00560	50		 push	 eax
  00561	e8 00 00 00 00	 call	 _FixedMul
  00566	83 c4 08	 add	 esp, 8
  00569	2b f0		 sub	 esi, eax
  0056b	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  0056f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00577	8b 4d f4	 mov	 ecx, DWORD PTR _v3d$[ebp]
  0057a	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0

; 683  : 			v3d->tow = (FIXED_TO_FLOAT(-FixedMul(tempxsow, FINESINE(angle)) - FixedMul(tempytow, FINECOSINE(angle))));

  0057f	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  00582	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  00589	51		 push	 ecx
  0058a	8b 55 c0	 mov	 edx, DWORD PTR _tempxsow$[ebp]
  0058d	52		 push	 edx
  0058e	e8 00 00 00 00	 call	 _FixedMul
  00593	83 c4 08	 add	 esp, 8
  00596	8b f0		 mov	 esi, eax
  00598	f7 de		 neg	 esi
  0059a	8b 45 cc	 mov	 eax, DWORD PTR _angle$[ebp]
  0059d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  005a3	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  005a6	52		 push	 edx
  005a7	8b 45 bc	 mov	 eax, DWORD PTR _tempytow$[ebp]
  005aa	50		 push	 eax
  005ab	e8 00 00 00 00	 call	 _FixedMul
  005b0	83 c4 08	 add	 esp, 8
  005b3	2b f0		 sub	 esi, eax
  005b5	f3 0f 2a c6	 cvtsi2ss xmm0, esi
  005b9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  005c1	8b 4d f4	 mov	 ecx, DWORD PTR _v3d$[ebp]
  005c4	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0
$LN25@HWR_Render:

; 684  : 		}
; 685  : 
; 686  : 		//v3d->sow = (float)(v3d->sow - flatxref + scrollx);
; 687  : 		//v3d->tow = (float)(flatyref - v3d->tow + scrolly);
; 688  : 
; 689  : 		v3d->x = pv->x;

  005c9	8b 45 f4	 mov	 eax, DWORD PTR _v3d$[ebp]
  005cc	8b 4d fc	 mov	 ecx, DWORD PTR _pv$[ebp]
  005cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  005d1	89 10		 mov	 DWORD PTR [eax], edx

; 690  : 		v3d->y = height;

  005d3	8b 45 f4	 mov	 eax, DWORD PTR _v3d$[ebp]
  005d6	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _height$[ebp]
  005db	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 691  : 		v3d->z = pv->y;

  005e0	8b 45 f4	 mov	 eax, DWORD PTR _v3d$[ebp]
  005e3	8b 4d fc	 mov	 ecx, DWORD PTR _pv$[ebp]
  005e6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  005e9	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 692  : #ifdef SLOPENESS
; 693  : 		if (sector && sector->special == 65535)
; 694  : 		{
; 695  : 			size_t q;
; 696  : 			for (q = 0; q < sector->linecount; q++)
; 697  : 			{
; 698  : 				if (v3d->x == sector->lines[q]->v1->x>>FRACBITS)
; 699  : 				{
; 700  : 					if (v3d->z == sector->lines[q]->v1->y>>FRACBITS)
; 701  : 					{
; 702  : 						v3d->y += sector->lines[q]->v1->z>>FRACBITS;
; 703  : 						break;
; 704  : 					}
; 705  : 				}
; 706  : 			}
; 707  : 		}
; 708  : #else
; 709  : 		sector = NULL;

  005ec	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _sector$[ebp], 0

; 710  : #endif
; 711  : 	}

  005f3	e9 9f fe ff ff	 jmp	 $LN4@HWR_Render
$LN5@HWR_Render:

; 712  : 
; 713  : 	// only useful for flat coloured triangles
; 714  : 	//Surf.FlatColor = 0xff804020;
; 715  : 
; 716  : 	// use different light tables
; 717  : 	// for horizontal / vertical / diagonal
; 718  : 	// note: try to get the same visual feel as the original
; 719  : #ifndef HARDWAREFIX
; 720  : 	Surf.FlatColor.s.red = Surf.FlatColor.s.green =
; 721  : 	Surf.FlatColor.s.blue = LightLevelToLum(lightlevel); //  Don't take from the frontsector, or the game will crash
; 722  : #endif
; 723  : 
; 724  : /*	// colormap test
; 725  : 	if (gr_frontsector)
; 726  : 	{
; 727  : 		sector_t *psector = gr_frontsector;
; 728  : 
; 729  : 		if (psector->ffloors)
; 730  : 		{
; 731  : 			ffloor_t *caster = psector->lightlist[R_GetPlaneLight(psector, fixedheight, false)].caster;
; 732  : 			psector = caster ? &sectors[caster->secnum] : psector;
; 733  : 
; 734  : 			if (caster)
; 735  : 			{
; 736  : 				lightlevel = psector->lightlevel;
; 737  : #ifndef HARDWAREFIX
; 738  : 				Surf.FlatColor.s.red = Surf.FlatColor.s.green = Surf.FlatColor.s.blue = LightLevelToLum(lightlevel);
; 739  : #endif
; 740  : 			}
; 741  : 		}
; 742  : 		if (psector->extra_colormap)
; 743  : #ifdef HARDWAREFIX
; 744  : 			Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel),psector->extra_colormap->rgba,psector->extra_colormap->fadergba, false, true);
; 745  : 		else
; 746  : 			Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel),NORMALFOG,FADEFOG, false, true);
; 747  : #else
; 748  : 		{
; 749  : 			RGBA_t temp;
; 750  : 			INT32 alpha;
; 751  : 
; 752  : 			temp.rgba = psector->extra_colormap->rgba;
; 753  : 			alpha = (26-temp.s.alpha)*LightLevelToLum(lightlevel);
; 754  : 			Surf.FlatColor.s.red = (UINT8)((alpha + temp.s.alpha*temp.s.red)/26);
; 755  : 			Surf.FlatColor.s.blue = (UINT8)((alpha + temp.s.alpha*temp.s.blue)/26);
; 756  : 			Surf.FlatColor.s.green = (UINT8)((alpha + temp.s.alpha*temp.s.green)/26);
; 757  : 			Surf.FlatColor.s.alpha = 0xff;
; 758  : 		}
; 759  : #endif
; 760  : 	}
; 761  : #ifdef HARDWAREFIX
; 762  : 	else
; 763  : 		Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel),NORMALFOG,FADEFOG, false, true);
; 764  : #endif*/
; 765  : 
; 766  : 	if (planecolormap)

  005f8	83 7d 2c 00	 cmp	 DWORD PTR _planecolormap$[ebp], 0
  005fc	74 64		 je	 SHORT $LN26@HWR_Render

; 767  : 		if (fogplane)

  005fe	83 7d 28 00	 cmp	 DWORD PTR _fogplane$[ebp], 0
  00602	74 2f		 je	 SHORT $LN28@HWR_Render

; 768  : 			Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), planecolormap->rgba, planecolormap->fadergba, true, false);

  00604	6a 00		 push	 0
  00606	6a 01		 push	 1
  00608	8b 45 2c	 mov	 eax, DWORD PTR _planecolormap$[ebp]
  0060b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0060e	51		 push	 ecx
  0060f	8b 55 2c	 mov	 edx, DWORD PTR _planecolormap$[ebp]
  00612	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00615	50		 push	 eax
  00616	8b 4d 18	 mov	 ecx, DWORD PTR _lightlevel$[ebp]
  00619	51		 push	 ecx
  0061a	e8 00 00 00 00	 call	 _LightLevelToLum
  0061f	83 c4 04	 add	 esp, 4
  00622	0f b6 d0	 movzx	 edx, al
  00625	52		 push	 edx
  00626	e8 00 00 00 00	 call	 _HWR_Lighting
  0062b	83 c4 14	 add	 esp, 20			; 00000014H
  0062e	89 45 c8	 mov	 DWORD PTR _Surf$[ebp+4], eax
  00631	eb 2d		 jmp	 SHORT $LN29@HWR_Render
$LN28@HWR_Render:

; 769  : 		else
; 770  : 			Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), planecolormap->rgba, planecolormap->fadergba, false, true);

  00633	6a 01		 push	 1
  00635	6a 00		 push	 0
  00637	8b 45 2c	 mov	 eax, DWORD PTR _planecolormap$[ebp]
  0063a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0063d	51		 push	 ecx
  0063e	8b 55 2c	 mov	 edx, DWORD PTR _planecolormap$[ebp]
  00641	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00644	50		 push	 eax
  00645	8b 4d 18	 mov	 ecx, DWORD PTR _lightlevel$[ebp]
  00648	51		 push	 ecx
  00649	e8 00 00 00 00	 call	 _LightLevelToLum
  0064e	83 c4 04	 add	 esp, 4
  00651	0f b6 d0	 movzx	 edx, al
  00654	52		 push	 edx
  00655	e8 00 00 00 00	 call	 _HWR_Lighting
  0065a	83 c4 14	 add	 esp, 20			; 00000014H
  0065d	89 45 c8	 mov	 DWORD PTR _Surf$[ebp+4], eax
$LN29@HWR_Render:
  00660	eb 54		 jmp	 SHORT $LN31@HWR_Render
$LN26@HWR_Render:

; 771  : 	else
; 772  : 		if (fogplane)

  00662	83 7d 28 00	 cmp	 DWORD PTR _fogplane$[ebp], 0
  00666	74 28		 je	 SHORT $LN30@HWR_Render

; 773  : 			Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), NORMALFOG, FADEFOG, true, false);

  00668	6a 00		 push	 0
  0066a	6a 01		 push	 1
  0066c	68 00 00 00 19	 push	 419430400		; 19000000H
  00671	6a 00		 push	 0
  00673	8b 45 18	 mov	 eax, DWORD PTR _lightlevel$[ebp]
  00676	50		 push	 eax
  00677	e8 00 00 00 00	 call	 _LightLevelToLum
  0067c	83 c4 04	 add	 esp, 4
  0067f	0f b6 c8	 movzx	 ecx, al
  00682	51		 push	 ecx
  00683	e8 00 00 00 00	 call	 _HWR_Lighting
  00688	83 c4 14	 add	 esp, 20			; 00000014H
  0068b	89 45 c8	 mov	 DWORD PTR _Surf$[ebp+4], eax
  0068e	eb 26		 jmp	 SHORT $LN31@HWR_Render
$LN30@HWR_Render:

; 774  : 		else
; 775  : 			Surf.FlatColor.rgba = HWR_Lighting(LightLevelToLum(lightlevel), NORMALFOG, FADEFOG, false, true);

  00690	6a 01		 push	 1
  00692	6a 00		 push	 0
  00694	68 00 00 00 19	 push	 419430400		; 19000000H
  00699	6a 00		 push	 0
  0069b	8b 45 18	 mov	 eax, DWORD PTR _lightlevel$[ebp]
  0069e	50		 push	 eax
  0069f	e8 00 00 00 00	 call	 _LightLevelToLum
  006a4	83 c4 04	 add	 esp, 4
  006a7	0f b6 c8	 movzx	 ecx, al
  006aa	51		 push	 ecx
  006ab	e8 00 00 00 00	 call	 _HWR_Lighting
  006b0	83 c4 14	 add	 esp, 20			; 00000014H
  006b3	89 45 c8	 mov	 DWORD PTR _Surf$[ebp+4], eax
$LN31@HWR_Render:

; 776  : 
; 777  : 	if (PolyFlags & PF_Translucent)

  006b6	8b 45 14	 mov	 eax, DWORD PTR _PolyFlags$[ebp]
  006b9	83 e0 02	 and	 eax, 2
  006bc	74 2f		 je	 SHORT $LN32@HWR_Render

; 778  : 	{
; 779  : 		Surf.FlatColor.s.alpha = alpha;

  006be	8a 45 24	 mov	 al, BYTE PTR _alpha$[ebp]
  006c1	88 45 cb	 mov	 BYTE PTR _Surf$[ebp+7], al

; 780  : 		HWD.pfnDrawPolygon(&Surf, planeVerts, nrPlaneVerts,

  006c4	8b 45 14	 mov	 eax, DWORD PTR _PolyFlags$[ebp]
  006c7	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  006cc	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  006d1	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  006d6	50		 push	 eax
  006d7	8b 4d f0	 mov	 ecx, DWORD PTR _nrPlaneVerts$[ebp]
  006da	51		 push	 ecx
  006db	68 00 00 00 00	 push	 OFFSET _planeVerts
  006e0	8d 55 c4	 lea	 edx, DWORD PTR _Surf$[ebp]
  006e3	52		 push	 edx
  006e4	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  006ea	90		 npad	 1

; 781  : 		                   PolyFlags|PF_Modulated|PF_Occlude|PF_Clip);
; 782  : 	}

  006eb	eb 29		 jmp	 SHORT $LN33@HWR_Render
$LN32@HWR_Render:

; 783  : 	else
; 784  : 	{
; 785  : 		Surf.FlatColor.s.alpha = 0xff;

  006ed	c6 45 cb ff	 mov	 BYTE PTR _Surf$[ebp+7], 255 ; 000000ffH

; 786  : 		HWD.pfnDrawPolygon(&Surf, planeVerts, nrPlaneVerts,

  006f1	8b 45 14	 mov	 eax, DWORD PTR _PolyFlags$[ebp]
  006f4	83 c8 01	 or	 eax, 1
  006f7	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  006fc	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00701	50		 push	 eax
  00702	8b 4d f0	 mov	 ecx, DWORD PTR _nrPlaneVerts$[ebp]
  00705	51		 push	 ecx
  00706	68 00 00 00 00	 push	 OFFSET _planeVerts
  0070b	8d 55 c4	 lea	 edx, DWORD PTR _Surf$[ebp]
  0070e	52		 push	 edx
  0070f	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  00715	90		 npad	 1
$LN33@HWR_Render:

; 787  : 		                   PolyFlags|PF_Masked|PF_Modulated|PF_Clip);
; 788  : 	}
; 789  : }

  00716	5f		 pop	 edi
  00717	5e		 pop	 esi
  00718	5b		 pop	 ebx
  00719	8b e5		 mov	 esp, ebp
  0071b	5d		 pop	 ebp
  0071c	c3		 ret	 0
_HWR_RenderPlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_FogBlockAlpha
_TEXT	SEGMENT
_fogalpha$ = -20					; size = 4
_alpha$ = -16						; size = 4
_surfcolor$ = -12					; size = 4
_fogcolor$ = -8						; size = 4
_realcolor$ = -4					; size = 4
_light$ = 8						; size = 4
_color$ = 12						; size = 4
_fadecolor$ = 16					; size = 4
_HWR_FogBlockAlpha PROC					; COMDAT

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 515  : 	RGBA_t realcolor, fogcolor, surfcolor;
; 516  : 	INT32 alpha, fogalpha;
; 517  : 
; 518  : 	realcolor.rgba = color;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _color$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _realcolor$[ebp], eax

; 519  : 	fogcolor.rgba = fadecolor;

  0000f	8b 45 10	 mov	 eax, DWORD PTR _fadecolor$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _fogcolor$[ebp], eax

; 520  : 
; 521  : 	alpha = (realcolor.s.alpha*255)/25;

  00015	0f b6 45 ff	 movzx	 eax, BYTE PTR _realcolor$[ebp+3]
  00019	69 c0 ff 00 00
	00		 imul	 eax, eax, 255
  0001f	99		 cdq
  00020	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00025	f7 f9		 idiv	 ecx
  00027	89 45 f0	 mov	 DWORD PTR _alpha$[ebp], eax

; 522  : 	fogalpha = (fogcolor.s.alpha*255)/25;

  0002a	0f b6 45 fb	 movzx	 eax, BYTE PTR _fogcolor$[ebp+3]
  0002e	69 c0 ff 00 00
	00		 imul	 eax, eax, 255
  00034	99		 cdq
  00035	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0003a	f7 f9		 idiv	 ecx
  0003c	89 45 ec	 mov	 DWORD PTR _fogalpha$[ebp], eax

; 523  : 
; 524  : 	// Fog blocks seem to get slightly more opaque with more opaque colourmap opacity, and much more opaque with darker brightness
; 525  : 	surfcolor.s.alpha = (UINT8)(CALCLIGHT(light, ((0xFF-light)+alpha)/2)+CALCLIGHT(0xFF-light, ((light)+fogalpha)/2));

  0003f	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _light$[ebp]
  00044	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00049	2b 45 08	 sub	 eax, DWORD PTR _light$[ebp]
  0004c	03 45 f0	 add	 eax, DWORD PTR _alpha$[ebp]
  0004f	99		 cdq
  00050	2b c2		 sub	 eax, edx
  00052	d1 f8		 sar	 eax, 1
  00054	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00058	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00060	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00064	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00069	2b 45 08	 sub	 eax, DWORD PTR _light$[ebp]
  0006c	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00070	8b 45 08	 mov	 eax, DWORD PTR _light$[ebp]
  00073	03 45 ec	 add	 eax, DWORD PTR _fogalpha$[ebp]
  00076	99		 cdq
  00077	2b c2		 sub	 eax, edx
  00079	d1 f8		 sar	 eax, 1
  0007b	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  0007f	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00087	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0008b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0008f	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00093	88 4d f7	 mov	 BYTE PTR _surfcolor$[ebp+3], cl

; 526  : 
; 527  : 	return surfcolor.s.alpha;

  00096	0f b6 45 f7	 movzx	 eax, BYTE PTR _surfcolor$[ebp+3]

; 528  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_HWR_FogBlockAlpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _InitLumLut
_TEXT	SEGMENT
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_InitLumLut PROC					; COMDAT

; 408  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 409  : 	INT32 i, k = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 410  : 	for (i = 0; i < 256; i++)

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@InitLumLut
$LN2@InitLumLut:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@InitLumLut:
  00022	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00029	7d 29		 jge	 SHORT $LN3@InitLumLut

; 411  : 	{
; 412  : 		if (i > 128)

  0002b	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  00032	7e 0b		 jle	 SHORT $LN5@InitLumLut

; 413  : 			k += 2;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00037	83 c0 02	 add	 eax, 2
  0003a	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
  0003d	eb 07		 jmp	 SHORT $LN6@InitLumLut
$LN5@InitLumLut:

; 414  : 		else
; 415  : 			k = 1;

  0003f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _k$[ebp], 1
$LN6@InitLumLut:

; 416  : 		lightleveltonumlut[i] = (UINT8)(k);

  00046	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00049	8a 4d f8	 mov	 cl, BYTE PTR _k$[ebp]
  0004c	88 88 00 00 00
	00		 mov	 BYTE PTR _lightleveltonumlut[eax], cl

; 417  : 	}

  00052	eb c5		 jmp	 SHORT $LN2@InitLumLut
$LN3@InitLumLut:

; 418  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_InitLumLut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _CV_grFov_OnChange
_TEXT	SEGMENT
_CV_grFov_OnChange PROC					; COMDAT

; 4871 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4872 : 	if ((netgame || multiplayer) && !cv_debug && cv_grfov.value != 90*FRACUNIT)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00010	75 09		 jne	 SHORT $LN3@CV_grFov_O
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00019	74 28		 je	 SHORT $LN2@CV_grFov_O
$LN3@CV_grFov_O:
  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  00022	75 1f		 jne	 SHORT $LN2@CV_grFov_O
  00024	81 3d 14 00 00
	00 00 00 5a 00	 cmp	 DWORD PTR _cv_grfov+20, 5898240 ; 005a0000H
  0002e	74 13		 je	 SHORT $LN2@CV_grFov_O

; 4873 : 		CV_Set(&cv_grfov, cv_grfov.defaultvalue);

  00030	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_grfov+4
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET _cv_grfov
  0003b	e8 00 00 00 00	 call	 _CV_Set
  00040	83 c4 08	 add	 esp, 8
$LN2@CV_grFov_O:

; 4874 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_CV_grFov_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _CV_FogDensity_ONChange
_TEXT	SEGMENT
_CV_FogDensity_ONChange PROC				; COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 138  : 	HWD.pfnSetSpecialState(HWD_SET_FOG_DENSITY, cv_grfogdensity.value);

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_grfogdensity+20
  0000e	50		 push	 eax
  0000f	6a 04		 push	 4
  00011	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  00017	90		 npad	 1

; 139  : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_CV_FogDensity_ONChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _CV_anisotropic_ONChange
_TEXT	SEGMENT
_CV_anisotropic_ONChange PROC				; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 148  : 	HWD.pfnSetSpecialState(HWD_SET_TEXTUREANISOTROPICMODE, cv_granisotropicmode.value);

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_granisotropicmode+20
  0000e	50		 push	 eax
  0000f	6a 09		 push	 9
  00011	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  00017	90		 npad	 1

; 149  : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_CV_anisotropic_ONChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _CV_filtermode_ONChange
_TEXT	SEGMENT
_CV_filtermode_ONChange PROC				; COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 143  : 	HWD.pfnSetSpecialState(HWD_SET_TEXTUREFILTERMODE, cv_grfiltermode.value);

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_grfiltermode+20
  0000e	50		 push	 eax
  0000f	6a 08		 push	 8
  00011	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  00017	90		 npad	 1

; 144  : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_CV_filtermode_ONChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddTransparentFloor
_TEXT	SEGMENT
_lumpnum$ = 8						; size = 4
_xsub$ = 12						; size = 4
_fixedheight$ = 16					; size = 4
_lightlevel$ = 20					; size = 4
_alpha$ = 24						; size = 4
_FOFSector$ = 28					; size = 4
_blend$ = 32						; size = 4
_fogplane$ = 36						; size = 4
_planecolormap$ = 40					; size = 4
_HWR_AddTransparentFloor PROC				; COMDAT

; 3901 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3902 : 	if (!(numplanes % MAX_TRANSPARENTFLOOR))

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _numplanes
  0000e	33 d2		 xor	 edx, edx
  00010	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00015	f7 f1		 div	 ecx
  00017	85 d2		 test	 edx, edx
  00019	75 28		 jne	 SHORT $LN2@HWR_AddTra

; 3903 : 	{
; 3904 : 		planeinfo = Z_Realloc(planeinfo,

  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 01		 push	 1
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _numplanes
  00026	05 00 02 00 00	 add	 eax, 512		; 00000200H
  0002b	6b c8 28	 imul	 ecx, eax, 40
  0002e	51		 push	 ecx
  0002f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _planeinfo
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _Z_ReallocAlign
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
  0003e	a3 00 00 00 00	 mov	 DWORD PTR _planeinfo, eax
$LN2@HWR_AddTra:

; 3905 : 			(numplanes + MAX_TRANSPARENTFLOOR) * sizeof *planeinfo, PU_STATIC, NULL);
; 3906 : 	}
; 3907 : 
; 3908 : 	planeinfo[numplanes].fixedheight = fixedheight;

  00043	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  00050	8b 55 10	 mov	 edx, DWORD PTR _fixedheight$[ebp]
  00053	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 3909 : 	planeinfo[numplanes].lightlevel = lightlevel;

  00057	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  00064	8b 55 14	 mov	 edx, DWORD PTR _lightlevel$[ebp]
  00067	89 54 01 08	 mov	 DWORD PTR [ecx+eax+8], edx

; 3910 : 	planeinfo[numplanes].lumpnum = lumpnum;

  0006b	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  00078	8b 55 08	 mov	 edx, DWORD PTR _lumpnum$[ebp]
  0007b	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 3911 : 	planeinfo[numplanes].xsub = xsub;

  0007f	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  0008c	8b 55 0c	 mov	 edx, DWORD PTR _xsub$[ebp]
  0008f	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 3912 : 	planeinfo[numplanes].alpha = alpha;

  00092	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  0009f	8b 55 18	 mov	 edx, DWORD PTR _alpha$[ebp]
  000a2	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx

; 3913 : 	planeinfo[numplanes].FOFSector = FOFSector;

  000a6	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  000b3	8b 55 1c	 mov	 edx, DWORD PTR _FOFSector$[ebp]
  000b6	89 54 01 14	 mov	 DWORD PTR [ecx+eax+20], edx

; 3914 : 	planeinfo[numplanes].blend = blend;

  000ba	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  000c7	8b 55 20	 mov	 edx, DWORD PTR _blend$[ebp]
  000ca	89 54 01 18	 mov	 DWORD PTR [ecx+eax+24], edx

; 3915 : 	planeinfo[numplanes].fogplane = fogplane;

  000ce	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  000db	8b 55 24	 mov	 edx, DWORD PTR _fogplane$[ebp]
  000de	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 3916 : 	planeinfo[numplanes].planecolormap = planecolormap;

  000e2	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  000ef	8b 55 28	 mov	 edx, DWORD PTR _planecolormap$[ebp]
  000f2	89 54 01 20	 mov	 DWORD PTR [ecx+eax+32], edx

; 3917 : 	planeinfo[numplanes].drawcount = drawcount++;

  000f6	6b 05 00 00 00
	00 28		 imul	 eax, DWORD PTR _numplanes, 40
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _planeinfo
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _drawcount
  00109	89 54 01 24	 mov	 DWORD PTR [ecx+eax+36], edx
  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR _drawcount
  00112	83 c0 01	 add	 eax, 1
  00115	a3 00 00 00 00	 mov	 DWORD PTR _drawcount, eax

; 3918 : 	numplanes++;

  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR _numplanes
  0011f	83 c0 01	 add	 eax, 1
  00122	a3 00 00 00 00	 mov	 DWORD PTR _numplanes, eax

; 3919 : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
_HWR_AddTransparentFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_ProjectSprite
_TEXT	SEGMENT
_ang$ = -52						; size = 4
_flip$ = -48						; size = 4
_rot$ = -44						; size = 4
_lumpoff$ = -40						; size = 4
_sprframe$ = -36					; size = 4
_sprdef$ = -32						; size = 4
_x2$ = -28						; size = 4
_x1$ = -24						; size = 4
_tz$ = -20						; size = 4
_tx$ = -16						; size = 4
_tr_y$ = -12						; size = 4
_tr_x$ = -8						; size = 4
_vis$ = -4						; size = 4
_thing$ = 8						; size = 4
_HWR_ProjectSprite PROC					; COMDAT

; 4241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4242 : 	gr_vissprite_t *vis;
; 4243 : 	float tr_x, tr_y;
; 4244 : 	float tx, tz;
; 4245 : 	float x1, x2;
; 4246 : 	spritedef_t *sprdef;
; 4247 : 	spriteframe_t *sprframe;
; 4248 : 	size_t lumpoff;
; 4249 : 	unsigned rot;
; 4250 : 	boolean flip;
; 4251 : 	angle_t ang;
; 4252 : 
; 4253 : 	if (!thing)

  00009	83 7d 08 00	 cmp	 DWORD PTR _thing$[ebp], 0
  0000d	75 05		 jne	 SHORT $LN2@HWR_Projec

; 4254 : 		return;

  0000f	e9 82 04 00 00	 jmp	 $LN1@HWR_Projec
$LN2@HWR_Projec:

; 4255 : 
; 4256 : 	// transform the origin point
; 4257 : 	tr_x = FIXED_TO_FLOAT(thing->x) - gr_viewx;

  00014	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00017	f3 0f 2a 40 10	 cvtsi2ss xmm0, DWORD PTR [eax+16]
  0001c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00024	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewx
  0002c	f3 0f 11 45 f8	 movss	 DWORD PTR _tr_x$[ebp], xmm0

; 4258 : 	tr_y = FIXED_TO_FLOAT(thing->y) - gr_viewy;

  00031	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00034	f3 0f 2a 40 14	 cvtsi2ss xmm0, DWORD PTR [eax+20]
  00039	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00041	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewy
  00049	f3 0f 11 45 f4	 movss	 DWORD PTR _tr_y$[ebp], xmm0

; 4259 : 
; 4260 : 	// rotation around vertical axis
; 4261 : 	tz = (tr_x * gr_viewcos) + (tr_y * gr_viewsin);

  0004e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  00053	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewcos
  0005b	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  00060	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewsin
  00068	f3 0f 58 c1	 addss	 xmm0, xmm1
  0006c	f3 0f 11 45 ec	 movss	 DWORD PTR _tz$[ebp], xmm0

; 4262 : 
; 4263 : 	// thing is behind view plane?
; 4264 : 	if (tz < ZCLIP_PLANE)

  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  00079	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _tz$[ebp]
  0007d	76 05		 jbe	 SHORT $LN3@HWR_Projec

; 4265 : 		return;

  0007f	e9 12 04 00 00	 jmp	 $LN1@HWR_Projec
$LN3@HWR_Projec:

; 4266 : 
; 4267 : 	tx = (tr_x * gr_viewsin) - (tr_y * gr_viewcos);

  00084	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  00089	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewsin
  00091	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  00096	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewcos
  0009e	f3 0f 5c c1	 subss	 xmm0, xmm1
  000a2	f3 0f 11 45 f0	 movss	 DWORD PTR _tx$[ebp], xmm0

; 4268 : 
; 4269 : 	// decide which patch to use for sprite relative to player
; 4270 : 	if ((unsigned)thing->sprite >= numsprites)

  000a7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000aa	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000ad	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numsprites
  000b3	72 4d		 jb	 SHORT $LN4@HWR_Projec

; 4271 : #ifdef RANGECHECK
; 4272 : 		I_Error("HWR_ProjectSprite: invalid sprite number %i ",
; 4273 : 		         thing->sprite);
; 4274 : #else
; 4275 : 	{
; 4276 : 		CONS_Printf("Warning: Mobj of type %i with invalid sprite data (%d) detected and removed.\n", thing->type, thing->sprite);

  000b5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000b8	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000bb	51		 push	 ecx
  000bc	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000bf	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@KAIJHMKB@Warning?3?5Mobj?5of?5type?5?$CFi?5with?5i@
  000c8	e8 00 00 00 00	 call	 _CONS_Printf
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4277 : 		if (thing->player)

  000d0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000d3	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000da	74 10		 je	 SHORT $LN5@HWR_Projec

; 4278 : 			P_SetPlayerMobjState(thing, S_PLAY_STND);

  000dc	6a 01		 push	 1
  000de	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  000e7	83 c4 08	 add	 esp, 8
  000ea	eb 11		 jmp	 SHORT $LN6@HWR_Projec
$LN5@HWR_Projec:

; 4279 : 		else
; 4280 : 			P_SetMobjState(thing, S_DISS);

  000ec	68 4f 06 00 00	 push	 1615			; 0000064fH
  000f1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _P_SetMobjState
  000fa	83 c4 08	 add	 esp, 8
$LN6@HWR_Projec:

; 4281 : 		return;

  000fd	e9 94 03 00 00	 jmp	 $LN1@HWR_Projec
$LN4@HWR_Projec:

; 4282 : 	}
; 4283 : #endif
; 4284 : 
; 4285 : 	rot = thing->frame&FF_FRAMEMASK;

  00102	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00105	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00108	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  0010e	89 4d d4	 mov	 DWORD PTR _rot$[ebp], ecx

; 4286 : 
; 4287 : 	//Fab : 02-08-98: 'skin' override spritedef currently used for skin
; 4288 : 	if (thing->skin)

  00111	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00114	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00118	74 0e		 je	 SHORT $LN7@HWR_Projec

; 4289 : 		sprdef = &((skin_t *)thing->skin)->spritedef;

  0011a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0011d	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00120	83 c1 14	 add	 ecx, 20			; 00000014H
  00123	89 4d e0	 mov	 DWORD PTR _sprdef$[ebp], ecx
  00126	eb 12		 jmp	 SHORT $LN8@HWR_Projec
$LN7@HWR_Projec:

; 4290 : 	else
; 4291 : 		sprdef = &sprites[thing->sprite];

  00128	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0012b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0012e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sprites
  00134	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00137	89 45 e0	 mov	 DWORD PTR _sprdef$[ebp], eax
$LN8@HWR_Projec:

; 4292 : 
; 4293 : 	if (rot >= sprdef->numframes)

  0013a	8b 45 e0	 mov	 eax, DWORD PTR _sprdef$[ebp]
  0013d	8b 4d d4	 mov	 ecx, DWORD PTR _rot$[ebp]
  00140	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00142	72 5e		 jb	 SHORT $LN9@HWR_Projec

; 4294 : #ifdef RANGECHECK
; 4295 : 		I_Error("HWR_ProjectSprite: nvalid sprite frame %u : %u/%"PRIdS" for %s",
; 4296 : 		 thing->sprite, rot, sprdef->numframes, sprnames[thing->sprite]);
; 4297 : #else
; 4298 : 	{
; 4299 : 		CONS_Printf("Warning: Mobj of type %d with invalid sprite frame (%u/%"PRIdS") of %s detected and removed.\n", thing->type, rot, sprdef->numframes, sprnames[thing->sprite]);

  00144	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00147	6b 48 28 05	 imul	 ecx, DWORD PTR [eax+40], 5
  0014b	81 c1 00 00 00
	00		 add	 ecx, OFFSET _sprnames
  00151	51		 push	 ecx
  00152	8b 55 e0	 mov	 edx, DWORD PTR _sprdef$[ebp]
  00155	8b 02		 mov	 eax, DWORD PTR [edx]
  00157	50		 push	 eax
  00158	8b 4d d4	 mov	 ecx, DWORD PTR _rot$[ebp]
  0015b	51		 push	 ecx
  0015c	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0015f	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00162	50		 push	 eax
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@NMFIBIGD@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@
  00168	e8 00 00 00 00	 call	 _CONS_Printf
  0016d	83 c4 14	 add	 esp, 20			; 00000014H

; 4300 : 		if (thing->player)

  00170	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00173	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0017a	74 10		 je	 SHORT $LN10@HWR_Projec

; 4301 : 			P_SetPlayerMobjState(thing, S_PLAY_STND);

  0017c	6a 01		 push	 1
  0017e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  00187	83 c4 08	 add	 esp, 8
  0018a	eb 11		 jmp	 SHORT $LN11@HWR_Projec
$LN10@HWR_Projec:

; 4302 : 		else
; 4303 : 			P_SetMobjState(thing, S_DISS);

  0018c	68 4f 06 00 00	 push	 1615			; 0000064fH
  00191	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _P_SetMobjState
  0019a	83 c4 08	 add	 esp, 8
$LN11@HWR_Projec:

; 4304 : 		return;

  0019d	e9 f4 02 00 00	 jmp	 $LN1@HWR_Projec
$LN9@HWR_Projec:

; 4305 : 	}
; 4306 : #endif
; 4307 : 
; 4308 : 	sprframe = &sprdef->spriteframes[thing->frame & FF_FRAMEMASK];

  001a2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001a5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001a8	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  001ae	6b d1 4c	 imul	 edx, ecx, 76
  001b1	8b 45 e0	 mov	 eax, DWORD PTR _sprdef$[ebp]
  001b4	03 50 04	 add	 edx, DWORD PTR [eax+4]
  001b7	89 55 dc	 mov	 DWORD PTR _sprframe$[ebp], edx

; 4309 : 
; 4310 : 	if (!sprframe)

  001ba	75 05		 jne	 SHORT $LN12@HWR_Projec

; 4311 : #ifdef PARANOIA //heretic hack
; 4312 : 		I_Error("sprframes NULL for sprite %d\n", thing->sprite);
; 4313 : #else
; 4314 : 		return;

  001bc	e9 d5 02 00 00	 jmp	 $LN1@HWR_Projec
$LN12@HWR_Projec:

; 4315 : #endif
; 4316 : 
; 4317 : 	if (sprframe->rotate)

  001c1	8b 45 dc	 mov	 eax, DWORD PTR _sprframe$[ebp]
  001c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001c7	85 c9		 test	 ecx, ecx
  001c9	74 4a		 je	 SHORT $LN13@HWR_Projec

; 4318 : 	{
; 4319 : 		// choose a different rotation based on player view
; 4320 : 		ang = R_PointToAngle(thing->x, thing->y); // uses viewx,viewy

  001cb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001ce	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001d1	51		 push	 ecx
  001d2	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  001d5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 _R_PointToAngle
  001de	83 c4 08	 add	 esp, 8
  001e1	89 45 cc	 mov	 DWORD PTR _ang$[ebp], eax

; 4321 : 		rot = (ang-thing->angle+ANGLE_202h)>>29;

  001e4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001e7	8b 4d cc	 mov	 ecx, DWORD PTR _ang$[ebp]
  001ea	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  001ed	81 e9 00 00 00
	70		 sub	 ecx, 1879048192		; 70000000H
  001f3	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  001f6	89 4d d4	 mov	 DWORD PTR _rot$[ebp], ecx

; 4322 : 		//Fab: lumpid is the index for spritewidth,spriteoffset... tables
; 4323 : 		lumpoff = sprframe->lumpid[rot];

  001f9	8b 45 d4	 mov	 eax, DWORD PTR _rot$[ebp]
  001fc	8b 4d dc	 mov	 ecx, DWORD PTR _sprframe$[ebp]
  001ff	8b 54 81 24	 mov	 edx, DWORD PTR [ecx+eax*4+36]
  00203	89 55 d8	 mov	 DWORD PTR _lumpoff$[ebp], edx

; 4324 : 		flip = (boolean)sprframe->flip[rot];

  00206	8b 45 dc	 mov	 eax, DWORD PTR _sprframe$[ebp]
  00209	03 45 d4	 add	 eax, DWORD PTR _rot$[ebp]
  0020c	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  00210	89 4d d0	 mov	 DWORD PTR _flip$[ebp], ecx

; 4325 : 	}

  00213	eb 2c		 jmp	 SHORT $LN14@HWR_Projec
$LN13@HWR_Projec:

; 4326 : 	else
; 4327 : 	{
; 4328 : 		// use single rotation for all views
; 4329 : 		rot = 0;                        //Fab: for vis->patch below

  00215	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _rot$[ebp], 0

; 4330 : 		lumpoff = sprframe->lumpid[0];     //Fab: see note above

  0021c	b8 04 00 00 00	 mov	 eax, 4
  00221	6b c8 00	 imul	 ecx, eax, 0
  00224	8b 55 dc	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00227	8b 44 0a 24	 mov	 eax, DWORD PTR [edx+ecx+36]
  0022b	89 45 d8	 mov	 DWORD PTR _lumpoff$[ebp], eax

; 4331 : 		flip = (boolean)sprframe->flip[0];

  0022e	b8 01 00 00 00	 mov	 eax, 1
  00233	6b c8 00	 imul	 ecx, eax, 0
  00236	8b 55 dc	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00239	0f b6 44 0a 44	 movzx	 eax, BYTE PTR [edx+ecx+68]
  0023e	89 45 d0	 mov	 DWORD PTR _flip$[ebp], eax
$LN14@HWR_Projec:

; 4332 : 	}
; 4333 : 
; 4334 : 
; 4335 : 	// calculate edges of the shape
; 4336 : 	tx -= FIXED_TO_FLOAT(spritecachedinfo[lumpoff].offset);

  00241	8b 45 d8	 mov	 eax, DWORD PTR _lumpoff$[ebp]
  00244	c1 e0 04	 shl	 eax, 4
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0024d	f3 0f 2a 44 01
	04		 cvtsi2ss xmm0, DWORD PTR [ecx+eax+4]
  00253	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0025b	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _tx$[ebp]
  00260	f3 0f 5c c8	 subss	 xmm1, xmm0
  00264	f3 0f 11 4d f0	 movss	 DWORD PTR _tx$[ebp], xmm1

; 4337 : 
; 4338 : 	// project x
; 4339 : 	x1 = gr_windowcenterx + (tx * gr_centerx / tz);

  00269	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _tx$[ebp]
  0026e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_centerx
  00276	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _tz$[ebp]
  0027b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR _gr_windowcenterx
  00283	f3 0f 11 45 e8	 movss	 DWORD PTR _x1$[ebp], xmm0

; 4340 : 
; 4341 : 	//faB : tr_x doesnt matter
; 4342 : 	// hurdler: it's used in cliptosolidsegs
; 4343 : 	tr_x = x1;

  00288	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0028d	f3 0f 11 45 f8	 movss	 DWORD PTR _tr_x$[ebp], xmm0

; 4344 : 
; 4345 : 	x1 = tx;

  00292	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _tx$[ebp]
  00297	f3 0f 11 45 e8	 movss	 DWORD PTR _x1$[ebp], xmm0

; 4346 : 
; 4347 : 	tx += FIXED_TO_FLOAT(spritecachedinfo[lumpoff].width);

  0029c	8b 45 d8	 mov	 eax, DWORD PTR _lumpoff$[ebp]
  0029f	c1 e0 04	 shl	 eax, 4
  002a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  002a8	f3 0f 2a 04 01	 cvtsi2ss xmm0, DWORD PTR [ecx+eax]
  002ad	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  002b5	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR _tx$[ebp]
  002ba	f3 0f 11 45 f0	 movss	 DWORD PTR _tx$[ebp], xmm0

; 4348 : 	x2 = gr_windowcenterx + (tx * gr_centerx / tz);

  002bf	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _tx$[ebp]
  002c4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_centerx
  002cc	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _tz$[ebp]
  002d1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR _gr_windowcenterx
  002d9	f3 0f 11 45 e4	 movss	 DWORD PTR _x2$[ebp], xmm0

; 4349 : 
; 4350 : 	//
; 4351 : 	// store information in a vissprite
; 4352 : 	//
; 4353 : 	vis = HWR_NewVisSprite();

  002de	e8 00 00 00 00	 call	 _HWR_NewVisSprite
  002e3	89 45 fc	 mov	 DWORD PTR _vis$[ebp], eax

; 4354 : 	vis->x1 = x1;

  002e6	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  002e9	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _x1$[ebp]
  002ee	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 4355 : 	vis->x2 = tx;

  002f3	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  002f6	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _tx$[ebp]
  002fb	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 4356 : 	vis->tz = tz;

  00300	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00303	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _tz$[ebp]
  00308	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 4357 : 	vis->patchlumpnum = sprframe->lumppat[rot];

  0030d	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00310	8b 4d d4	 mov	 ecx, DWORD PTR _rot$[ebp]
  00313	8b 55 dc	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00316	8b 4c 8a 04	 mov	 ecx, DWORD PTR [edx+ecx*4+4]
  0031a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 4358 : 	vis->flip = flip;

  0031d	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00320	8b 4d d0	 mov	 ecx, DWORD PTR _flip$[ebp]
  00323	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 4359 : 	vis->mobj = thing;

  00326	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00329	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0032c	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 4360 : 
; 4361 : 	//Hurdler: 25/04/2000: now support colormap in hardware mode
; 4362 : 	if (thing->flags & MF_TRANSLATION)

  0032f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00332	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00335	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  0033b	0f 84 a0 00 00
	00		 je	 $LN15@HWR_Projec

; 4363 : 	{
; 4364 : 		// New colormap stuff for skins Tails 06-07-2002
; 4365 : #ifdef TRANSFIX
; 4366 : 		if (vis->mobj->skin) // This thing is a player!

  00341	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00344	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00347	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  0034b	74 39		 je	 SHORT $LN17@HWR_Projec

; 4367 : 			vis->colormap = (UINT8 *)translationtables[(skin_t*)vis->mobj->skin-skins] - 256 + ((INT32)vis->mobj->color<<8);

  0034d	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00350	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00353	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00356	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  0035b	99		 cdq
  0035c	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  00361	f7 f9		 idiv	 ecx
  00363	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[eax*4]
  0036a	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  0036d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00370	0f b6 41 68	 movzx	 eax, BYTE PTR [ecx+104]
  00374	c1 e0 08	 shl	 eax, 8
  00377	8d 8c 02 00 ff
	ff ff		 lea	 ecx, DWORD PTR [edx+eax-256]
  0037e	8b 55 fc	 mov	 edx, DWORD PTR _vis$[ebp]
  00381	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
  00384	eb 59		 jmp	 SHORT $LN20@HWR_Projec
$LN17@HWR_Projec:

; 4368 : #else
; 4369 : 		if (vis->mobj->player) // This thing is a player!
; 4370 : 			vis->colormap = (UINT8 *)translationtables[vis->mobj->player->skin] - 256 + ((INT32)vis->mobj->color<<8);
; 4371 : #endif
; 4372 : 		else if ((vis->mobj->flags & MF_BOSS) && (vis->mobj->flags2 & MF2_FRET) && (leveltime & 1)) // Bosses "flash"

  00386	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00389	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0038c	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0038f	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00395	74 29		 je	 SHORT $LN19@HWR_Projec
  00397	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  0039a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0039d	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  003a3	83 e2 10	 and	 edx, 16			; 00000010H
  003a6	74 18		 je	 SHORT $LN19@HWR_Projec
  003a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  003ad	83 e0 01	 and	 eax, 1
  003b0	74 0e		 je	 SHORT $LN19@HWR_Projec

; 4373 : 			vis->colormap = (UINT8 *)bosstranslationtables;

  003b2	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  003b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bosstranslationtables
  003bb	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  003be	eb 1f		 jmp	 SHORT $LN20@HWR_Projec
$LN19@HWR_Projec:

; 4374 : 		else
; 4375 : 			vis->colormap = (UINT8 *)defaulttranslationtables - 256 + ((INT32)vis->mobj->color<<8);

  003c0	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  003c3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  003c6	0f b6 51 68	 movzx	 edx, BYTE PTR [ecx+104]
  003ca	c1 e2 08	 shl	 edx, 8
  003cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  003d2	8d 8c 10 00 ff
	ff ff		 lea	 ecx, DWORD PTR [eax+edx-256]
  003d9	8b 55 fc	 mov	 edx, DWORD PTR _vis$[ebp]
  003dc	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
$LN20@HWR_Projec:

; 4376 : 	}

  003df	eb 0c		 jmp	 SHORT $LN16@HWR_Projec
$LN15@HWR_Projec:

; 4377 : 	else
; 4378 : 		vis->colormap = colormaps;

  003e1	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  003e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _colormaps
  003ea	89 48 30	 mov	 DWORD PTR [eax+48], ecx
$LN16@HWR_Projec:

; 4379 : 
; 4380 : 	// set top/bottom coords
; 4381 : 	if (thing->flags & MF_HIRES)

  003ed	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003f0	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  003f3	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  003f9	74 3b		 je	 SHORT $LN21@HWR_Projec

; 4382 : 		vis->ty = FIXED_TO_FLOAT(thing->z + spritecachedinfo[lumpoff].topoffset/2) - gr_viewz;

  003fb	8b 45 d8	 mov	 eax, DWORD PTR _lumpoff$[ebp]
  003fe	c1 e0 04	 shl	 eax, 4
  00401	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00407	8b 44 01 08	 mov	 eax, DWORD PTR [ecx+eax+8]
  0040b	99		 cdq
  0040c	2b c2		 sub	 eax, edx
  0040e	d1 f8		 sar	 eax, 1
  00410	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00413	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00416	03 c8		 add	 ecx, eax
  00418	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0041c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00424	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewz
  0042c	8b 55 fc	 mov	 edx, DWORD PTR _vis$[ebp]
  0042f	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0
  00434	eb 32		 jmp	 SHORT $LN22@HWR_Projec
$LN21@HWR_Projec:

; 4383 : 	else
; 4384 : 		vis->ty = FIXED_TO_FLOAT(thing->z + spritecachedinfo[lumpoff].topoffset) - gr_viewz;

  00436	8b 45 d8	 mov	 eax, DWORD PTR _lumpoff$[ebp]
  00439	c1 e0 04	 shl	 eax, 4
  0043c	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0043f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00442	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00448	03 54 01 08	 add	 edx, DWORD PTR [ecx+eax+8]
  0044c	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00450	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00458	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewz
  00460	8b 55 fc	 mov	 edx, DWORD PTR _vis$[ebp]
  00463	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0
$LN22@HWR_Projec:

; 4385 : 
; 4386 : 	//CONS_Printf("------------------\nH: sprite  : %d\nH: frame   : %x\nH: type    : %d\nH: sname   : %s\n\n",
; 4387 : 	//            thing->sprite, thing->frame, thing->type, sprnames[thing->sprite]);
; 4388 : 
; 4389 : 	if (thing->eflags & MFE_VERTICALFLIP)

  00468	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0046b	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00471	83 e1 20	 and	 ecx, 32			; 00000020H
  00474	74 0c		 je	 SHORT $LN23@HWR_Projec

; 4390 : 		vis->vflip = true;

  00476	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00479	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
  00480	eb 0a		 jmp	 SHORT $LN24@HWR_Projec
$LN23@HWR_Projec:

; 4391 : 	else
; 4392 : 		vis->vflip = false;

  00482	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  00485	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN24@HWR_Projec:

; 4393 : 
; 4394 : 	vis->precip = false;

  0048c	8b 45 fc	 mov	 eax, DWORD PTR _vis$[ebp]
  0048f	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN1@HWR_Projec:

; 4395 : }

  00496	5f		 pop	 edi
  00497	5e		 pop	 esi
  00498	5b		 pop	 ebx
  00499	8b e5		 mov	 esp, ebp
  0049b	5d		 pop	 ebp
  0049c	c3		 ret	 0
_HWR_ProjectSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddSprites
_TEXT	SEGMENT
tv138 = -84						; size = 4
tv166 = -84						; size = 4
tv182 = -84						; size = 4
_approx_dist$ = -16					; size = 4
_ady$ = -12						; size = 4
_adx$ = -8						; size = 4
_thing$ = -4						; size = 4
_sec$ = 8						; size = 4
_HWR_AddSprites PROC					; COMDAT

; 4124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4125 : 	mobj_t *thing;
; 4126 : #ifdef HWPRECIP
; 4127 : 	precipmobj_t *precipthing;
; 4128 : #endif
; 4129 : 	fixed_t adx, ady, approx_dist;
; 4130 : 
; 4131 : 	// BSP is traversed by subsector.
; 4132 : 	// A sector might have been split into several
; 4133 : 	//  subsectors during BSP building.
; 4134 : 	// Thus we check whether its already added.
; 4135 : 	if (sec->validcount == validcount)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0000c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0000f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00015	75 05		 jne	 SHORT $LN8@HWR_AddSpr

; 4136 : 		return;

  00017	e9 6b 02 00 00	 jmp	 $LN6@HWR_AddSpr
$LN8@HWR_AddSpr:

; 4137 : 
; 4138 : 	// Well, now it will be done.
; 4139 : 	sec->validcount = validcount;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00025	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 4140 : 
; 4141 : 	// sprite lighting
; 4142 : 	sectorlight = LightLevelToLum(sec->lightlevel & 0xff);

  00028	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0002b	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0002f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _LightLevelToLum
  0003b	83 c4 04	 add	 esp, 4
  0003e	a2 00 00 00 00	 mov	 BYTE PTR _sectorlight, al

; 4143 : 
; 4144 : 	// NiGHTS stages have a draw distance limit because of the
; 4145 : 	// HUGE number of SPRiTES!
; 4146 : 	if ((cv_limitdraw.value || maptol & TOL_NIGHTS)
; 4147 : 	 && cv_grrenderquality.value != 3 && players[displayplayer].mo)

  00043	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_limitdraw+20, 0
  0004a	75 10		 jne	 SHORT $LN11@HWR_AddSpr
  0004c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  00053	83 e0 40	 and	 eax, 64			; 00000040H
  00056	0f 84 9c 01 00
	00		 je	 $LN9@HWR_AddSpr
$LN11@HWR_AddSpr:
  0005c	83 3d 14 00 00
	00 03		 cmp	 DWORD PTR _cv_grrenderquality+20, 3
  00063	0f 84 8f 01 00
	00		 je	 $LN9@HWR_AddSpr
  00069	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00073	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  0007a	0f 84 78 01 00
	00		 je	 $LN9@HWR_AddSpr

; 4148 : 	{
; 4149 : 		// Special function for precipitation Tails 08-18-2002
; 4150 : 		for (thing = sec->thinglist; thing; thing = thing->snext)

  00080	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00083	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00086	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
  00089	eb 09		 jmp	 SHORT $LN4@HWR_AddSpr
$LN2@HWR_AddSpr:
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0008e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00091	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
$LN4@HWR_AddSpr:
  00094	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00098	0f 84 55 01 00
	00		 je	 $LN3@HWR_AddSpr

; 4151 : 		{
; 4152 : 			if (!thing)

  0009e	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  000a2	75 02		 jne	 SHORT $LN12@HWR_AddSpr

; 4153 : 				continue;

  000a4	eb e5		 jmp	 SHORT $LN2@HWR_AddSpr
$LN12@HWR_AddSpr:

; 4154 : 
; 4155 : 			if (!(thing->flags2 & MF2_DONTDRAW))

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  000a9	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  000af	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  000b5	0f 85 33 01 00
	00		 jne	 $LN17@HWR_AddSpr

; 4156 : 			{
; 4157 : 				adx = abs(players[displayplayer].mo->x - thing->x);

  000bb	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  000c5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000cb	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  000ce	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000d1	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _abs
  000da	83 c4 04	 add	 esp, 4
  000dd	89 45 f8	 mov	 DWORD PTR _adx$[ebp], eax

; 4158 : 				ady = abs(players[displayplayer].mo->y - thing->y);

  000e0	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  000ea	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000f0	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  000f3	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  000f6	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _abs
  000ff	83 c4 04	 add	 esp, 4
  00102	89 45 f4	 mov	 DWORD PTR _ady$[ebp], eax

; 4159 : 
; 4160 : 				// From _GG1_ p.428. Approx. eucledian distance fast.
; 4161 : 				approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  00105	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  00108	3b 45 f4	 cmp	 eax, DWORD PTR _ady$[ebp]
  0010b	7d 08		 jge	 SHORT $LN23@HWR_AddSpr
  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _adx$[ebp]
  00110	89 4d ac	 mov	 DWORD PTR tv138[ebp], ecx
  00113	eb 06		 jmp	 SHORT $LN24@HWR_AddSpr
$LN23@HWR_AddSpr:
  00115	8b 55 f4	 mov	 edx, DWORD PTR _ady$[ebp]
  00118	89 55 ac	 mov	 DWORD PTR tv138[ebp], edx
$LN24@HWR_AddSpr:
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  0011e	03 45 f4	 add	 eax, DWORD PTR _ady$[ebp]
  00121	8b 4d ac	 mov	 ecx, DWORD PTR tv138[ebp]
  00124	d1 f9		 sar	 ecx, 1
  00126	2b c1		 sub	 eax, ecx
  00128	89 45 f0	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 4162 : 
; 4163 : 				if (approx_dist < LIMIT_DRAW_DIST)

  0012b	81 7d f0 00 00
	00 08		 cmp	 DWORD PTR _approx_dist$[ebp], 134217728 ; 08000000H
  00132	7d 11		 jge	 SHORT $LN14@HWR_AddSpr

; 4164 : 					HWR_ProjectSprite(thing);

  00134	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _HWR_ProjectSprite
  0013d	83 c4 04	 add	 esp, 4
  00140	e9 a9 00 00 00	 jmp	 $LN17@HWR_AddSpr
$LN14@HWR_AddSpr:

; 4165 : 				else if (splitscreen && players[secondarydisplayplayer].mo)

  00145	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0014c	0f 84 9c 00 00
	00		 je	 $LN17@HWR_AddSpr
  00152	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0015c	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00163	0f 84 85 00 00
	00		 je	 $LN17@HWR_AddSpr

; 4166 : 				{
; 4167 : 					adx = abs(players[secondarydisplayplayer].mo->x - thing->x);

  00169	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00173	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00179	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  0017c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0017f	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _abs
  00188	83 c4 04	 add	 esp, 4
  0018b	89 45 f8	 mov	 DWORD PTR _adx$[ebp], eax

; 4168 : 					ady = abs(players[secondarydisplayplayer].mo->y - thing->y);

  0018e	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00198	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  0019e	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  001a1	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  001a4	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _abs
  001ad	83 c4 04	 add	 esp, 4
  001b0	89 45 f4	 mov	 DWORD PTR _ady$[ebp], eax

; 4169 : 
; 4170 : 					// From _GG1_ p.428. Approx. eucledian distance fast.
; 4171 : 					approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  001b3	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  001b6	3b 45 f4	 cmp	 eax, DWORD PTR _ady$[ebp]
  001b9	7d 08		 jge	 SHORT $LN25@HWR_AddSpr
  001bb	8b 4d f8	 mov	 ecx, DWORD PTR _adx$[ebp]
  001be	89 4d ac	 mov	 DWORD PTR tv166[ebp], ecx
  001c1	eb 06		 jmp	 SHORT $LN26@HWR_AddSpr
$LN25@HWR_AddSpr:
  001c3	8b 55 f4	 mov	 edx, DWORD PTR _ady$[ebp]
  001c6	89 55 ac	 mov	 DWORD PTR tv166[ebp], edx
$LN26@HWR_AddSpr:
  001c9	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  001cc	03 45 f4	 add	 eax, DWORD PTR _ady$[ebp]
  001cf	8b 4d ac	 mov	 ecx, DWORD PTR tv166[ebp]
  001d2	d1 f9		 sar	 ecx, 1
  001d4	2b c1		 sub	 eax, ecx
  001d6	89 45 f0	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 4172 : 
; 4173 : 					if (approx_dist < LIMIT_DRAW_DIST)

  001d9	81 7d f0 00 00
	00 08		 cmp	 DWORD PTR _approx_dist$[ebp], 134217728 ; 08000000H
  001e0	7d 0c		 jge	 SHORT $LN17@HWR_AddSpr

; 4174 : 						HWR_ProjectSprite(thing);

  001e2	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 _HWR_ProjectSprite
  001eb	83 c4 04	 add	 esp, 4
$LN17@HWR_AddSpr:

; 4175 : 				}
; 4176 : 			}
; 4177 : 		}

  001ee	e9 98 fe ff ff	 jmp	 $LN2@HWR_AddSpr
$LN3@HWR_AddSpr:

; 4178 : 	}

  001f3	e9 8f 00 00 00	 jmp	 $LN6@HWR_AddSpr
$LN9@HWR_AddSpr:

; 4179 : 	else
; 4180 : 	{
; 4181 : 		// Handle all things in sector.
; 4182 : 		for (thing = sec->thinglist; thing; thing = thing->snext)

  001f8	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  001fb	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001fe	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
  00201	eb 09		 jmp	 SHORT $LN7@HWR_AddSpr
$LN5@HWR_AddSpr:
  00203	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00206	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00209	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
$LN7@HWR_AddSpr:
  0020c	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00210	74 75		 je	 SHORT $LN6@HWR_AddSpr

; 4183 : 		{
; 4184 : 			if (!thing)

  00212	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00216	75 02		 jne	 SHORT $LN18@HWR_AddSpr

; 4185 : 				continue;

  00218	eb e9		 jmp	 SHORT $LN5@HWR_AddSpr
$LN18@HWR_AddSpr:

; 4186 : 
; 4187 : 			if (!(thing->flags2 & MF2_DONTDRAW))

  0021a	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0021d	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00223	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  00229	75 0c		 jne	 SHORT $LN19@HWR_AddSpr

; 4188 : 				HWR_ProjectSprite(thing);

  0022b	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _HWR_ProjectSprite
  00234	83 c4 04	 add	 esp, 4
$LN19@HWR_AddSpr:

; 4189 : 
; 4190 : 			if (cv_objectplace.value
; 4191 : 			&& (!thing->flags2 & MF2_DONTDRAW))

  00237	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_objectplace+20, 0
  0023e	74 37		 je	 SHORT $LN20@HWR_AddSpr
  00240	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00243	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [eax+136], 0
  0024a	75 09		 jne	 SHORT $LN27@HWR_AddSpr
  0024c	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
  00253	eb 07		 jmp	 SHORT $LN28@HWR_AddSpr
$LN27@HWR_AddSpr:
  00255	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
$LN28@HWR_AddSpr:
  0025c	8b 4d ac	 mov	 ecx, DWORD PTR tv182[ebp]
  0025f	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  00265	74 10		 je	 SHORT $LN20@HWR_AddSpr

; 4192 : 				objectsdrawn++;

  00267	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _objectsdrawn
  0026d	66 83 c0 01	 add	 ax, 1
  00271	66 a3 00 00 00
	00		 mov	 WORD PTR _objectsdrawn, ax
$LN20@HWR_AddSpr:

; 4193 : 
; 4194 : 			if (!thing->snext)

  00277	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0027a	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0027e	75 02		 jne	 SHORT $LN21@HWR_AddSpr

; 4195 : 				break;

  00280	eb 05		 jmp	 SHORT $LN6@HWR_AddSpr
$LN21@HWR_AddSpr:

; 4196 : 		}

  00282	e9 7c ff ff ff	 jmp	 $LN5@HWR_AddSpr
$LN6@HWR_AddSpr:

; 4197 : 	}
; 4198 : 
; 4199 : #ifdef HWPRECIP
; 4200 : 	if (playeringame[displayplayer] && players[displayplayer].mo)
; 4201 : 	{
; 4202 : 		for (precipthing = sec->preciplist; precipthing; precipthing = precipthing->snext)
; 4203 : 		{
; 4204 : 			if (!precipthing)
; 4205 : 				continue;
; 4206 : 
; 4207 : 			if (precipthing->invisible)
; 4208 : 				continue;
; 4209 : 
; 4210 : 			adx = abs(players[displayplayer].mo->x - precipthing->x);
; 4211 : 			ady = abs(players[displayplayer].mo->y - precipthing->y);
; 4212 : 
; 4213 : 			// From _GG1_ p.428. Approx. eucledian distance fast.
; 4214 : 			approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);
; 4215 : 
; 4216 : 			// Only draw the precipitation oh-so-far from the player.
; 4217 : 			if (approx_dist < (cv_precipdist.value << FRACBITS))
; 4218 : 				HWR_ProjectPrecipitationSprite(precipthing);
; 4219 : 			else if (splitscreen && players[secondarydisplayplayer].mo)
; 4220 : 			{
; 4221 : 				adx = abs(players[secondarydisplayplayer].mo->x - precipthing->x);
; 4222 : 				ady = abs(players[secondarydisplayplayer].mo->y - precipthing->y);
; 4223 : 
; 4224 : 				// From _GG1_ p.428. Approx. eucledian distance fast.
; 4225 : 				approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);
; 4226 : 
; 4227 : 				if (approx_dist < (cv_precipdist.value << FRACBITS))
; 4228 : 					HWR_ProjectPrecipitationSprite(precipthing);
; 4229 : 			}
; 4230 : 		}
; 4231 : 	}
; 4232 : #endif
; 4233 : }

  00287	5f		 pop	 edi
  00288	5e		 pop	 esi
  00289	5b		 pop	 ebx
  0028a	8b e5		 mov	 esp, ebp
  0028c	5d		 pop	 ebp
  0028d	c3		 ret	 0
_HWR_AddSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _LightLevelToLum
_TEXT	SEGMENT
tv71 = -76						; size = 4
tv70 = -72						; size = 4
tv67 = -68						; size = 4
_l$ = 8							; size = 4
_LightLevelToLum PROC					; COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 388  : /*#ifdef HARDWAREFIX
; 389  : 	if (!cv_grfog.value)
; 390  : 	{
; 391  : 		if(l > 255)
; 392  : 			l = 255;
; 393  : 		else if(l < 0)
; 394  : 			l = 0;
; 395  : 		return lightleveltonumlut[l];
; 396  : 	}
; 397  : #endif*/
; 398  : 	return (UINT8)(255*gld_CalcLightLevel(l));

  00009	81 7d 08 ff 00
	00 00		 cmp	 DWORD PTR _l$[ebp], 255	; 000000ffH
  00010	7d 08		 jge	 SHORT $LN3@LightLevel
  00012	8b 45 08	 mov	 eax, DWORD PTR _l$[ebp]
  00015	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
  00018	eb 07		 jmp	 SHORT $LN4@LightLevel
$LN3@LightLevel:
  0001a	c7 45 bc ff 00
	00 00		 mov	 DWORD PTR tv67[ebp], 255 ; 000000ffH
$LN4@LightLevel:
  00021	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  00025	7e 20		 jle	 SHORT $LN7@LightLevel
  00027	81 7d 08 ff 00
	00 00		 cmp	 DWORD PTR _l$[ebp], 255	; 000000ffH
  0002e	7d 08		 jge	 SHORT $LN5@LightLevel
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _l$[ebp]
  00033	89 4d b8	 mov	 DWORD PTR tv70[ebp], ecx
  00036	eb 07		 jmp	 SHORT $LN6@LightLevel
$LN5@LightLevel:
  00038	c7 45 b8 ff 00
	00 00		 mov	 DWORD PTR tv70[ebp], 255 ; 000000ffH
$LN6@LightLevel:
  0003f	8b 55 b8	 mov	 edx, DWORD PTR tv70[ebp]
  00042	89 55 b4	 mov	 DWORD PTR tv71[ebp], edx
  00045	eb 07		 jmp	 SHORT $LN8@LightLevel
$LN7@LightLevel:
  00047	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN8@LightLevel:
  0004e	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00053	c1 e0 00	 shl	 eax, 0
  00056	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  00059	f3 0f 10 84 88
	00 00 00 00	 movss	 xmm0, DWORD PTR _lighttable[eax+ecx*4]
  00062	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0006a	f3 0f 2c c0	 cvttss2si eax, xmm0

; 399  : /*
; 400  : 	l = lightleveltonumlut[l];
; 401  : 
; 402  : 	if (l > 255)
; 403  : 		l = 255;
; 404  : 	return (UINT8)l;*/
; 405  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_LightLevelToLum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_Lighting
_TEXT	SEGMENT
_fogalpha$ = -20					; size = 4
_alpha$ = -16						; size = 4
_surfcolor$ = -12					; size = 4
_fogcolor$ = -8						; size = 4
_realcolor$ = -4					; size = 4
_light$ = 8						; size = 4
_color$ = 12						; size = 4
_fadecolor$ = 16					; size = 4
_fogblockpoly$ = 20					; size = 4
_plane$ = 24						; size = 4
_HWR_Lighting PROC					; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 429  : 	RGBA_t realcolor, fogcolor, surfcolor;
; 430  : 	INT32 alpha, fogalpha;
; 431  : 
; 432  : 	realcolor.rgba = color;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _color$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _realcolor$[ebp], eax

; 433  : 	fogcolor.rgba = fadecolor;

  0000f	8b 45 10	 mov	 eax, DWORD PTR _fadecolor$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _fogcolor$[ebp], eax

; 434  : 
; 435  : 	alpha = (realcolor.s.alpha*255)/25;

  00015	0f b6 45 ff	 movzx	 eax, BYTE PTR _realcolor$[ebp+3]
  00019	69 c0 ff 00 00
	00		 imul	 eax, eax, 255
  0001f	99		 cdq
  00020	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00025	f7 f9		 idiv	 ecx
  00027	89 45 f0	 mov	 DWORD PTR _alpha$[ebp], eax

; 436  : 	fogalpha = (fogcolor.s.alpha*255)/25;

  0002a	0f b6 45 fb	 movzx	 eax, BYTE PTR _fogcolor$[ebp+3]
  0002e	69 c0 ff 00 00
	00		 imul	 eax, eax, 255
  00034	99		 cdq
  00035	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0003a	f7 f9		 idiv	 ecx
  0003c	89 45 ec	 mov	 DWORD PTR _fogalpha$[ebp], eax

; 437  : 
; 438  : 	if (cv_grfog.value && cv_grsoftwarefog.value) // Only do this when fog is on, software fog mode is on, and the poly is not from a fog block

  0003f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grfog+20, 0
  00046	0f 84 63 01 00
	00		 je	 $LN2@HWR_Lighti
  0004c	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grsoftwarefog+20, 0
  00053	0f 84 56 01 00
	00		 je	 $LN2@HWR_Lighti

; 439  : 	{
; 440  : 		// Modulate the colors by alpha.
; 441  : 		realcolor.s.red = (UINT8)(CALCLIGHT(alpha,realcolor.s.red));

  00059	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _alpha$[ebp]
  0005e	0f b6 45 fc	 movzx	 eax, BYTE PTR _realcolor$[ebp]
  00062	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00066	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0006e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00072	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00076	88 4d fc	 mov	 BYTE PTR _realcolor$[ebp], cl

; 442  : 		realcolor.s.green = (UINT8)(CALCLIGHT(alpha,realcolor.s.green));

  00079	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _alpha$[ebp]
  0007e	0f b6 45 fd	 movzx	 eax, BYTE PTR _realcolor$[ebp+1]
  00082	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00086	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0008e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00092	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00096	88 4d fd	 mov	 BYTE PTR _realcolor$[ebp+1], cl

; 443  : 		realcolor.s.blue = (UINT8)(CALCLIGHT(alpha,realcolor.s.blue));

  00099	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _alpha$[ebp]
  0009e	0f b6 45 fe	 movzx	 eax, BYTE PTR _realcolor$[ebp+2]
  000a2	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  000a6	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  000ae	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000b2	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000b6	88 4d fe	 mov	 BYTE PTR _realcolor$[ebp+2], cl

; 444  : 
; 445  : 		// Set the surface colors and further modulate the colors by light.
; 446  : 		surfcolor.s.red = (UINT8)(CALCLIGHT((0xFF-alpha),255)+CALCLIGHT(realcolor.s.red,255));

  000b9	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000be	2b 45 f0	 sub	 eax, DWORD PTR _alpha$[ebp]
  000c1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000c5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  000cd	0f b6 4d fc	 movzx	 ecx, BYTE PTR _realcolor$[ebp]
  000d1	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  000d5	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f800000
  000dd	f3 0f 58 c1	 addss	 xmm0, xmm1
  000e1	f3 0f 2c d0	 cvttss2si edx, xmm0
  000e5	88 55 f4	 mov	 BYTE PTR _surfcolor$[ebp], dl

; 447  : 		surfcolor.s.green = (UINT8)(CALCLIGHT((0xFF-alpha),255)+CALCLIGHT(realcolor.s.green,255));

  000e8	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000ed	2b 45 f0	 sub	 eax, DWORD PTR _alpha$[ebp]
  000f0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  000fc	0f b6 4d fd	 movzx	 ecx, BYTE PTR _realcolor$[ebp+1]
  00100	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00104	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f800000
  0010c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00110	f3 0f 2c d0	 cvttss2si edx, xmm0
  00114	88 55 f5	 mov	 BYTE PTR _surfcolor$[ebp+1], dl

; 448  : 		surfcolor.s.blue = (UINT8)(CALCLIGHT((0xFF-alpha),255)+CALCLIGHT(realcolor.s.blue,255));

  00117	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0011c	2b 45 f0	 sub	 eax, DWORD PTR _alpha$[ebp]
  0011f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00123	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  0012b	0f b6 4d fe	 movzx	 ecx, BYTE PTR _realcolor$[ebp+2]
  0012f	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00133	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f800000
  0013b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0013f	f3 0f 2c d0	 cvttss2si edx, xmm0
  00143	88 55 f6	 mov	 BYTE PTR _surfcolor$[ebp+2], dl

; 449  : 		surfcolor.s.alpha = 0xFF;

  00146	c6 45 f7 ff	 mov	 BYTE PTR _surfcolor$[ebp+3], 255 ; 000000ffH

; 450  : 
; 451  : 		// Modulate the colors by alpha.
; 452  : 		fogcolor.s.red = (UINT8)(CALCLIGHT(fogalpha,fogcolor.s.red));

  0014a	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  0014f	0f b6 45 f8	 movzx	 eax, BYTE PTR _fogcolor$[ebp]
  00153	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00157	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0015f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00163	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00167	88 4d f8	 mov	 BYTE PTR _fogcolor$[ebp], cl

; 453  : 		fogcolor.s.green = (UINT8)(CALCLIGHT(fogalpha,fogcolor.s.green));

  0016a	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  0016f	0f b6 45 f9	 movzx	 eax, BYTE PTR _fogcolor$[ebp+1]
  00173	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00177	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0017f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00183	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00187	88 4d f9	 mov	 BYTE PTR _fogcolor$[ebp+1], cl

; 454  : 		fogcolor.s.blue = (UINT8)(CALCLIGHT(fogalpha,fogcolor.s.blue));

  0018a	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  0018f	0f b6 45 fa	 movzx	 eax, BYTE PTR _fogcolor$[ebp+2]
  00193	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00197	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0019f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001a3	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001a7	88 4d fa	 mov	 BYTE PTR _fogcolor$[ebp+2], cl

; 455  : 	}

  001aa	e9 8f 02 00 00	 jmp	 $LN3@HWR_Lighti
$LN2@HWR_Lighti:

; 456  : 	else
; 457  : 	{
; 458  : 		// Modulate the colors by alpha.
; 459  : 		realcolor.s.red = (UINT8)(CALCLIGHT(alpha,realcolor.s.red));

  001af	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _alpha$[ebp]
  001b4	0f b6 45 fc	 movzx	 eax, BYTE PTR _realcolor$[ebp]
  001b8	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  001bc	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  001c4	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001c8	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001cc	88 4d fc	 mov	 BYTE PTR _realcolor$[ebp], cl

; 460  : 		realcolor.s.green = (UINT8)(CALCLIGHT(alpha,realcolor.s.green));

  001cf	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _alpha$[ebp]
  001d4	0f b6 45 fd	 movzx	 eax, BYTE PTR _realcolor$[ebp+1]
  001d8	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  001dc	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  001e4	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001e8	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001ec	88 4d fd	 mov	 BYTE PTR _realcolor$[ebp+1], cl

; 461  : 		realcolor.s.blue = (UINT8)(CALCLIGHT(alpha,realcolor.s.blue));

  001ef	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _alpha$[ebp]
  001f4	0f b6 45 fe	 movzx	 eax, BYTE PTR _realcolor$[ebp+2]
  001f8	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  001fc	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00204	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00208	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0020c	88 4d fe	 mov	 BYTE PTR _realcolor$[ebp+2], cl

; 462  : 
; 463  : 		// Set the surface colors and further modulate the colors by light.
; 464  : 		surfcolor.s.red = (UINT8)(CALCLIGHT((0xFF-alpha),light)+CALCLIGHT(realcolor.s.red,light));

  0020f	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00214	2b 45 f0	 sub	 eax, DWORD PTR _alpha$[ebp]
  00217	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0021b	f3 0f 2a 4d 08	 cvtsi2ss xmm1, DWORD PTR _light$[ebp]
  00220	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00228	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0022c	0f b6 4d fc	 movzx	 ecx, BYTE PTR _realcolor$[ebp]
  00230	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00234	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  00239	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00241	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00245	f3 0f 58 c1	 addss	 xmm0, xmm1
  00249	f3 0f 2c d0	 cvttss2si edx, xmm0
  0024d	88 55 f4	 mov	 BYTE PTR _surfcolor$[ebp], dl

; 465  : 		surfcolor.s.green = (UINT8)(CALCLIGHT((0xFF-alpha),light)+CALCLIGHT(realcolor.s.green,light));

  00250	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00255	2b 45 f0	 sub	 eax, DWORD PTR _alpha$[ebp]
  00258	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0025c	f3 0f 2a 4d 08	 cvtsi2ss xmm1, DWORD PTR _light$[ebp]
  00261	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00269	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0026d	0f b6 4d fd	 movzx	 ecx, BYTE PTR _realcolor$[ebp+1]
  00271	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00275	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  0027a	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00282	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00286	f3 0f 58 c1	 addss	 xmm0, xmm1
  0028a	f3 0f 2c d0	 cvttss2si edx, xmm0
  0028e	88 55 f5	 mov	 BYTE PTR _surfcolor$[ebp+1], dl

; 466  : 		surfcolor.s.blue = (UINT8)(CALCLIGHT((0xFF-alpha),light)+CALCLIGHT(realcolor.s.blue,light));

  00291	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00296	2b 45 f0	 sub	 eax, DWORD PTR _alpha$[ebp]
  00299	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0029d	f3 0f 2a 4d 08	 cvtsi2ss xmm1, DWORD PTR _light$[ebp]
  002a2	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  002aa	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002ae	0f b6 4d fe	 movzx	 ecx, BYTE PTR _realcolor$[ebp+2]
  002b2	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  002b6	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  002bb	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  002c3	f3 0f 59 ca	 mulss	 xmm1, xmm2
  002c7	f3 0f 58 c1	 addss	 xmm0, xmm1
  002cb	f3 0f 2c d0	 cvttss2si edx, xmm0
  002cf	88 55 f6	 mov	 BYTE PTR _surfcolor$[ebp+2], dl

; 467  : 
; 468  : 		// Modulate the colors by alpha.
; 469  : 		fogcolor.s.red = (UINT8)(CALCLIGHT(fogalpha,fogcolor.s.red));

  002d2	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  002d7	0f b6 45 f8	 movzx	 eax, BYTE PTR _fogcolor$[ebp]
  002db	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  002df	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  002e7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002eb	f3 0f 2c c8	 cvttss2si ecx, xmm0
  002ef	88 4d f8	 mov	 BYTE PTR _fogcolor$[ebp], cl

; 470  : 		fogcolor.s.green = (UINT8)(CALCLIGHT(fogalpha,fogcolor.s.green));

  002f2	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  002f7	0f b6 45 f9	 movzx	 eax, BYTE PTR _fogcolor$[ebp+1]
  002fb	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  002ff	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00307	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0030b	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0030f	88 4d f9	 mov	 BYTE PTR _fogcolor$[ebp+1], cl

; 471  : 		fogcolor.s.blue = (UINT8)(CALCLIGHT(fogalpha,fogcolor.s.blue));

  00312	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  00317	0f b6 45 fa	 movzx	 eax, BYTE PTR _fogcolor$[ebp+2]
  0031b	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  0031f	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00327	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0032b	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0032f	88 4d fa	 mov	 BYTE PTR _fogcolor$[ebp+2], cl

; 472  : 
; 473  : 		// Set the surface colors and further modulate the colors by light.
; 474  : 		surfcolor.s.red = surfcolor.s.red+((UINT8)(CALCLIGHT((0xFF-fogalpha),(255-light))+CALCLIGHT(fogcolor.s.red,(255-light))));

  00332	0f b6 45 f4	 movzx	 eax, BYTE PTR _surfcolor$[ebp]
  00336	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0033b	2b 4d ec	 sub	 ecx, DWORD PTR _fogalpha$[ebp]
  0033e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00342	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00347	2b 55 08	 sub	 edx, DWORD PTR _light$[ebp]
  0034a	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  0034e	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00356	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0035a	0f b6 4d f8	 movzx	 ecx, BYTE PTR _fogcolor$[ebp]
  0035e	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00362	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00367	2b 55 08	 sub	 edx, DWORD PTR _light$[ebp]
  0036a	f3 0f 2a d2	 cvtsi2ss xmm2, edx
  0036e	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00376	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0037a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0037e	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00382	0f b6 d1	 movzx	 edx, cl
  00385	03 c2		 add	 eax, edx
  00387	88 45 f4	 mov	 BYTE PTR _surfcolor$[ebp], al

; 475  : 		surfcolor.s.green = surfcolor.s.green+((UINT8)(CALCLIGHT((0xFF-fogalpha),(255-light))+CALCLIGHT(fogcolor.s.green,(255-light))));

  0038a	0f b6 45 f5	 movzx	 eax, BYTE PTR _surfcolor$[ebp+1]
  0038e	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00393	2b 4d ec	 sub	 ecx, DWORD PTR _fogalpha$[ebp]
  00396	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0039a	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  0039f	2b 55 08	 sub	 edx, DWORD PTR _light$[ebp]
  003a2	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  003a6	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  003ae	f3 0f 59 c1	 mulss	 xmm0, xmm1
  003b2	0f b6 4d f9	 movzx	 ecx, BYTE PTR _fogcolor$[ebp+1]
  003b6	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  003ba	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  003bf	2b 55 08	 sub	 edx, DWORD PTR _light$[ebp]
  003c2	f3 0f 2a d2	 cvtsi2ss xmm2, edx
  003c6	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  003ce	f3 0f 59 ca	 mulss	 xmm1, xmm2
  003d2	f3 0f 58 c1	 addss	 xmm0, xmm1
  003d6	f3 0f 2c c8	 cvttss2si ecx, xmm0
  003da	0f b6 d1	 movzx	 edx, cl
  003dd	03 c2		 add	 eax, edx
  003df	88 45 f5	 mov	 BYTE PTR _surfcolor$[ebp+1], al

; 476  : 		surfcolor.s.blue = surfcolor.s.blue+((UINT8)(CALCLIGHT((0xFF-fogalpha),(255-light))+CALCLIGHT(fogcolor.s.blue,(255-light))));

  003e2	0f b6 45 f6	 movzx	 eax, BYTE PTR _surfcolor$[ebp+2]
  003e6	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  003eb	2b 4d ec	 sub	 ecx, DWORD PTR _fogalpha$[ebp]
  003ee	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  003f2	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  003f7	2b 55 08	 sub	 edx, DWORD PTR _light$[ebp]
  003fa	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  003fe	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00406	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0040a	0f b6 4d fa	 movzx	 ecx, BYTE PTR _fogcolor$[ebp+2]
  0040e	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00412	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00417	2b 55 08	 sub	 edx, DWORD PTR _light$[ebp]
  0041a	f3 0f 2a d2	 cvtsi2ss xmm2, edx
  0041e	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00426	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0042a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0042e	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00432	0f b6 d1	 movzx	 edx, cl
  00435	03 c2		 add	 eax, edx
  00437	88 45 f6	 mov	 BYTE PTR _surfcolor$[ebp+2], al

; 477  : 		surfcolor.s.alpha = 0xFF;

  0043a	c6 45 f7 ff	 mov	 BYTE PTR _surfcolor$[ebp+3], 255 ; 000000ffH
$LN3@HWR_Lighti:

; 478  : 	}
; 479  : 
; 480  : 	if(cv_grfog.value)

  0043e	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grfog+20, 0
  00445	0f 84 ff 02 00
	00		 je	 $LN4@HWR_Lighti

; 481  : 	{
; 482  : 		if (cv_grsoftwarefog.value)

  0044b	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grsoftwarefog+20, 0
  00452	0f 84 60 01 00
	00		 je	 $LN5@HWR_Lighti

; 483  : 		{
; 484  : 			fogcolor.s.red = (UINT8)((CALCLIGHT(fogcolor.s.red,(255-light)))+(CALCLIGHT(realcolor.s.red,light)));

  00458	0f b6 45 f8	 movzx	 eax, BYTE PTR _fogcolor$[ebp]
  0045c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00460	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00465	2b 4d 08	 sub	 ecx, DWORD PTR _light$[ebp]
  00468	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  0046c	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00474	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00478	0f b6 55 fc	 movzx	 edx, BYTE PTR _realcolor$[ebp]
  0047c	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00480	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  00485	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  0048d	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00491	f3 0f 58 c1	 addss	 xmm0, xmm1
  00495	f3 0f 2c c0	 cvttss2si eax, xmm0
  00499	88 45 f8	 mov	 BYTE PTR _fogcolor$[ebp], al

; 485  : 			fogcolor.s.green = (UINT8)((CALCLIGHT(fogcolor.s.green,(255-light)))+(CALCLIGHT(realcolor.s.green,light)));

  0049c	0f b6 45 f9	 movzx	 eax, BYTE PTR _fogcolor$[ebp+1]
  004a0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004a4	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  004a9	2b 4d 08	 sub	 ecx, DWORD PTR _light$[ebp]
  004ac	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  004b0	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  004b8	f3 0f 59 c1	 mulss	 xmm0, xmm1
  004bc	0f b6 55 fd	 movzx	 edx, BYTE PTR _realcolor$[ebp+1]
  004c0	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  004c4	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  004c9	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  004d1	f3 0f 59 ca	 mulss	 xmm1, xmm2
  004d5	f3 0f 58 c1	 addss	 xmm0, xmm1
  004d9	f3 0f 2c c0	 cvttss2si eax, xmm0
  004dd	88 45 f9	 mov	 BYTE PTR _fogcolor$[ebp+1], al

; 486  : 			fogcolor.s.blue = (UINT8)((CALCLIGHT(fogcolor.s.blue,(255-light)))+(CALCLIGHT(realcolor.s.blue,light)));

  004e0	0f b6 45 fa	 movzx	 eax, BYTE PTR _fogcolor$[ebp+2]
  004e4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004e8	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  004ed	2b 4d 08	 sub	 ecx, DWORD PTR _light$[ebp]
  004f0	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  004f4	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  004fc	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00500	0f b6 55 fe	 movzx	 edx, BYTE PTR _realcolor$[ebp+2]
  00504	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00508	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  0050d	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00515	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00519	f3 0f 58 c1	 addss	 xmm0, xmm1
  0051d	f3 0f 2c c0	 cvttss2si eax, xmm0
  00521	88 45 fa	 mov	 BYTE PTR _fogcolor$[ebp+2], al

; 487  : 
; 488  : 			// Set the fog options.
; 489  : 			if (cv_grsoftwarefog.value == 1 && plane) // With floors, software draws them way darker for their distance

  00524	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _cv_grsoftwarefog+20, 1
  0052b	75 47		 jne	 SHORT $LN7@HWR_Lighti
  0052d	83 7d 18 00	 cmp	 DWORD PTR _plane$[ebp], 0
  00531	74 41		 je	 SHORT $LN7@HWR_Lighti

; 490  : 				HWD.pfnSetSpecialState(HWD_SET_FOG_DENSITY, (INT32)(CALCFOGDENSITYFLOOR(light)));

  00533	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _light$[ebp]
  00538	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41300000
  00540	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00548	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00550	f3 0f 5e c8	 divss	 xmm1, xmm0
  00554	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@471d2300
  0055c	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@44cff0b8
  00564	f3 0f 2c c1	 cvttss2si eax, xmm1
  00568	50		 push	 eax
  00569	6a 04		 push	 4
  0056b	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  00571	90		 npad	 1
  00572	eb 3f		 jmp	 SHORT $LN8@HWR_Lighti
$LN7@HWR_Lighti:

; 491  : 			else // everything else is drawn like walls
; 492  : 				HWD.pfnSetSpecialState(HWD_SET_FOG_DENSITY, (INT32)(CALCFOGDENSITY(light)));

  00574	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _light$[ebp]
  00579	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42240000
  00581	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00589	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00591	f3 0f 5e c8	 divss	 xmm1, xmm0
  00595	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@45a32000
  0059d	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@4434c299
  005a5	f3 0f 2c c1	 cvttss2si eax, xmm1
  005a9	50		 push	 eax
  005aa	6a 04		 push	 4
  005ac	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  005b2	90		 npad	 1
$LN8@HWR_Lighti:

; 493  : 		}

  005b3	e9 67 01 00 00	 jmp	 $LN6@HWR_Lighti
$LN5@HWR_Lighti:

; 494  : 		else
; 495  : 		{
; 496  : 			fogcolor.s.red = (UINT8)((CALCLIGHT(fogcolor.s.red,(255-light)))+(CALCLIGHT(realcolor.s.red,light)));

  005b8	0f b6 45 f8	 movzx	 eax, BYTE PTR _fogcolor$[ebp]
  005bc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  005c0	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  005c5	2b 4d 08	 sub	 ecx, DWORD PTR _light$[ebp]
  005c8	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  005cc	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  005d4	f3 0f 59 c1	 mulss	 xmm0, xmm1
  005d8	0f b6 55 fc	 movzx	 edx, BYTE PTR _realcolor$[ebp]
  005dc	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  005e0	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  005e5	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  005ed	f3 0f 59 ca	 mulss	 xmm1, xmm2
  005f1	f3 0f 58 c1	 addss	 xmm0, xmm1
  005f5	f3 0f 2c c0	 cvttss2si eax, xmm0
  005f9	88 45 f8	 mov	 BYTE PTR _fogcolor$[ebp], al

; 497  : 			fogcolor.s.green = (UINT8)((CALCLIGHT(fogcolor.s.green,(255-light)))+(CALCLIGHT(realcolor.s.green,light)));

  005fc	0f b6 45 f9	 movzx	 eax, BYTE PTR _fogcolor$[ebp+1]
  00600	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00604	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00609	2b 4d 08	 sub	 ecx, DWORD PTR _light$[ebp]
  0060c	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00610	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  00618	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0061c	0f b6 55 fd	 movzx	 edx, BYTE PTR _realcolor$[ebp+1]
  00620	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00624	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  00629	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00631	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00635	f3 0f 58 c1	 addss	 xmm0, xmm1
  00639	f3 0f 2c c0	 cvttss2si eax, xmm0
  0063d	88 45 f9	 mov	 BYTE PTR _fogcolor$[ebp+1], al

; 498  : 			fogcolor.s.blue = (UINT8)((CALCLIGHT(fogcolor.s.blue,(255-light)))+(CALCLIGHT(realcolor.s.blue,light)));

  00640	0f b6 45 fa	 movzx	 eax, BYTE PTR _fogcolor$[ebp+2]
  00644	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00648	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0064d	2b 4d 08	 sub	 ecx, DWORD PTR _light$[ebp]
  00650	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00654	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0065c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00660	0f b6 55 fe	 movzx	 edx, BYTE PTR _realcolor$[ebp+2]
  00664	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00668	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  0066d	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  00675	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00679	f3 0f 58 c1	 addss	 xmm0, xmm1
  0067d	f3 0f 2c c0	 cvttss2si eax, xmm0
  00681	88 45 fa	 mov	 BYTE PTR _fogcolor$[ebp+2], al

; 499  : 
; 500  : 			fogalpha = (UINT8)((CALCLIGHT(fogalpha,(255-light)))+(CALCLIGHT(alpha,light)));

  00684	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _fogalpha$[ebp]
  00689	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0068e	2b 45 08	 sub	 eax, DWORD PTR _light$[ebp]
  00691	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00695	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0069d	f3 0f 59 c1	 mulss	 xmm0, xmm1
  006a1	f3 0f 2a 4d f0	 cvtsi2ss xmm1, DWORD PTR _alpha$[ebp]
  006a6	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  006ab	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@437f0000
  006b3	f3 0f 59 ca	 mulss	 xmm1, xmm2
  006b7	f3 0f 58 c1	 addss	 xmm0, xmm1
  006bb	f3 0f 2c c8	 cvttss2si ecx, xmm0
  006bf	0f b6 d1	 movzx	 edx, cl
  006c2	89 55 ec	 mov	 DWORD PTR _fogalpha$[ebp], edx

; 501  : 
; 502  : 			// Set the fog options.
; 503  : 			light = (UINT8)(CALCLIGHT(light,(255-fogalpha)));

  006c5	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _light$[ebp]
  006ca	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  006cf	2b 45 ec	 sub	 eax, DWORD PTR _fogalpha$[ebp]
  006d2	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  006d6	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  006de	f3 0f 59 c1	 mulss	 xmm0, xmm1
  006e2	f3 0f 2c c8	 cvttss2si ecx, xmm0
  006e6	0f b6 d1	 movzx	 edx, cl
  006e9	89 55 08	 mov	 DWORD PTR _light$[ebp], edx

; 504  : 			HWD.pfnSetSpecialState(HWD_SET_FOG_DENSITY, (INT32)(cv_grfogdensity.value-(cv_grfogdensity.value*(float)light/255.0f)));

  006ec	f3 0f 2a 05 14
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _cv_grfogdensity+20
  006f4	f3 0f 2a 0d 14
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _cv_grfogdensity+20
  006fc	f3 0f 2a 55 08	 cvtsi2ss xmm2, DWORD PTR _light$[ebp]
  00701	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00705	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@437f0000
  0070d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00711	f3 0f 2c c0	 cvttss2si eax, xmm0
  00715	50		 push	 eax
  00716	6a 04		 push	 4
  00718	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  0071e	90		 npad	 1
$LN6@HWR_Lighti:

; 505  : 		}
; 506  : 
; 507  : 		HWD.pfnSetSpecialState(HWD_SET_FOG_COLOR, (fogcolor.s.red*0x10000)+(fogcolor.s.green*0x100)+fogcolor.s.blue);

  0071f	0f b6 45 f8	 movzx	 eax, BYTE PTR _fogcolor$[ebp]
  00723	c1 e0 10	 shl	 eax, 16			; 00000010H
  00726	0f b6 4d f9	 movzx	 ecx, BYTE PTR _fogcolor$[ebp+1]
  0072a	c1 e1 08	 shl	 ecx, 8
  0072d	03 c1		 add	 eax, ecx
  0072f	0f b6 55 fa	 movzx	 edx, BYTE PTR _fogcolor$[ebp+2]
  00733	03 c2		 add	 eax, edx
  00735	50		 push	 eax
  00736	6a 03		 push	 3
  00738	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  0073e	90		 npad	 1

; 508  : 		HWD.pfnSetSpecialState(HWD_SET_FOG_MODE, 1);

  0073f	6a 01		 push	 1
  00741	6a 02		 push	 2
  00743	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  00749	90		 npad	 1
$LN4@HWR_Lighti:

; 509  : 	}
; 510  : 	return surfcolor.rgba;

  0074a	8b 45 f4	 mov	 eax, DWORD PTR _surfcolor$[ebp]

; 511  : }

  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx
  00750	8b e5		 mov	 esp, ebp
  00752	5d		 pop	 ebp
  00753	c3		 ret	 0
_HWR_Lighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DrawIntermissionBG
_TEXT	SEGMENT
_HWR_DrawIntermissionBG PROC				; COMDAT

; 5324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5325 : 	HWD.pfnDrawIntermissionBG();

  00009	ff 15 5c 00 00
	00		 call	 DWORD PTR _hwdriver+92
  0000f	90		 npad	 1

; 5326 : }

  00010	5f		 pop	 edi
  00011	5e		 pop	 esi
  00012	5b		 pop	 ebx
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_HWR_DrawIntermissionBG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_PrepFadeToBlack
_TEXT	SEGMENT
_Surf$ = -112						; size = 8
_flags$ = -104						; size = 4
_v$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_HWR_PrepFadeToBlack PROC				; COMDAT

; 5306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 5307 : 	FOutVector      v[4];
; 5308 : 	INT32 flags;
; 5309 : 	FSurfaceInfo Surf;
; 5310 : 
; 5311 : 	// Overkill variables! :D
; 5312 : 	v[0].x = v[2].y = v[3].x = v[3].y = -50.0f;

  00016	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0001b	6b c8 03	 imul	 ecx, eax, 3
  0001e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  00026	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _v$[ebp+ecx+4], xmm0
  0002c	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00031	6b c2 03	 imul	 eax, edx, 3
  00034	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  0003c	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _v$[ebp+eax], xmm0
  00042	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00047	d1 e1		 shl	 ecx, 1
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  00051	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _v$[ebp+ecx+4], xmm0
  00057	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0005c	6b c2 00	 imul	 eax, edx, 0
  0005f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  00067	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _v$[ebp+eax], xmm0

; 5313 : 	v[0].y = v[1].x = v[1].y = v[2].x = 50.0f;

  0006d	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00072	d1 e0		 shl	 eax, 1
  00074	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  0007c	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _v$[ebp+eax], xmm0
  00082	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00087	c1 e1 00	 shl	 ecx, 0
  0008a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  00092	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _v$[ebp+ecx+4], xmm0
  00098	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0009d	c1 e2 00	 shl	 edx, 0
  000a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  000a8	f3 0f 11 44 15
	9c		 movss	 DWORD PTR _v$[ebp+edx], xmm0
  000ae	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000b3	6b c8 00	 imul	 ecx, eax, 0
  000b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  000be	f3 0f 11 44 0d
	a0		 movss	 DWORD PTR _v$[ebp+ecx+4], xmm0

; 5314 : 	v[0].z = v[1].z = v[2].z = v[3].z = 50.0f;

  000c4	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000c9	6b c8 03	 imul	 ecx, eax, 3
  000cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  000d4	f3 0f 11 44 0d
	a4		 movss	 DWORD PTR _v$[ebp+ecx+8], xmm0
  000da	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  000df	d1 e2		 shl	 edx, 1
  000e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  000e9	f3 0f 11 44 15
	a4		 movss	 DWORD PTR _v$[ebp+edx+8], xmm0
  000ef	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000f4	c1 e0 00	 shl	 eax, 0
  000f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  000ff	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _v$[ebp+eax+8], xmm0
  00105	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0010a	6b d1 00	 imul	 edx, ecx, 0
  0010d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  00115	f3 0f 11 44 15
	a4		 movss	 DWORD PTR _v$[ebp+edx+8], xmm0

; 5315 : 
; 5316 : 	flags = PF_Modulated | PF_Translucent | PF_Clip | PF_NoZClip | PF_NoDepthTest | PF_NoTexture;

  0011b	c7 45 98 02 32
	00 60		 mov	 DWORD PTR _flags$[ebp], 1610625538 ; 60003202H

; 5317 : 	Surf.FlatColor.s.red = Surf.FlatColor.s.green = Surf.FlatColor.s.blue = 0;

  00122	c6 45 96 00	 mov	 BYTE PTR _Surf$[ebp+6], 0
  00126	0f b6 45 96	 movzx	 eax, BYTE PTR _Surf$[ebp+6]
  0012a	88 45 95	 mov	 BYTE PTR _Surf$[ebp+5], al
  0012d	8a 4d 95	 mov	 cl, BYTE PTR _Surf$[ebp+5]
  00130	88 4d 94	 mov	 BYTE PTR _Surf$[ebp+4], cl

; 5318 : 	Surf.FlatColor.s.alpha = 255;

  00133	c6 45 97 ff	 mov	 BYTE PTR _Surf$[ebp+7], 255 ; 000000ffH

; 5319 : 
; 5320 : 	HWD.pfnDrawPolygon(&Surf, v, 4, flags);

  00137	8b 45 98	 mov	 eax, DWORD PTR _flags$[ebp]
  0013a	50		 push	 eax
  0013b	6a 04		 push	 4
  0013d	8d 4d 9c	 lea	 ecx, DWORD PTR _v$[ebp]
  00140	51		 push	 ecx
  00141	8d 55 90	 lea	 edx, DWORD PTR _Surf$[ebp]
  00144	52		 push	 edx
  00145	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  0014b	90		 npad	 1

; 5321 : }

  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00152	33 cd		 xor	 ecx, ebp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
_HWR_PrepFadeToBlack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DoScreenWipe
_TEXT	SEGMENT
_HWR_DoScreenWipe PROC					; COMDAT

; 5329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5330 : 	HWRWipeCounter -= 0.035f;

  00009	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _HWRWipeCounter
  00011	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3d0f5c29
  00019	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _HWRWipeCounter, xmm0

; 5331 : /*
; 5332 : 	if(cv_debug)
; 5333 : 		CONS_Printf("In HWR_DoScreenWipe(). Alpha =%f\n", HWRWipeCounter);
; 5334 : */
; 5335 : 	HWD.pfnDoScreenWipe(HWRWipeCounter);

  00021	51		 push	 ecx
  00022	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _HWRWipeCounter
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002f	ff 15 58 00 00
	00		 call	 DWORD PTR _hwdriver+88
  00035	90		 npad	 1

; 5336 : 
; 5337 : 	I_OsPolling();

  00036	e8 00 00 00 00	 call	 _I_OsPolling
  0003b	90		 npad	 1

; 5338 : 	I_FinishUpdate();

  0003c	e8 00 00 00 00	 call	 _I_FinishUpdate
  00041	90		 npad	 1

; 5339 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_HWR_DoScreenWipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_EndScreenWipe
_TEXT	SEGMENT
_HWR_EndScreenWipe PROC					; COMDAT

; 5295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5296 : 	HWRWipeCounter = 1.0f;

  00009	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00011	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _HWRWipeCounter, xmm0

; 5297 : 	// Spammy!
; 5298 : 	/*if(cv_debug)
; 5299 : 	//	CONS_Printf("In HWR_EndScreenWipe()\n");
; 5300 : */
; 5301 : 	HWD.pfnEndScreenWipe();

  00019	ff 15 54 00 00
	00		 call	 DWORD PTR _hwdriver+84
  0001f	90		 npad	 1

; 5302 : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_HWR_EndScreenWipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_StartScreenWipe
_TEXT	SEGMENT
_HWR_StartScreenWipe PROC				; COMDAT

; 5287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5288 : /*	if(cv_debug)
; 5289 : //		CONS_Printf("In HWR_StartScreenWipe()\n");
; 5290 : */
; 5291 : 	HWD.pfnStartScreenWipe();

  00009	ff 15 50 00 00
	00		 call	 DWORD PTR _hwdriver+80
  0000f	90		 npad	 1

; 5292 : }

  00010	5f		 pop	 edi
  00011	5e		 pop	 esi
  00012	5b		 pop	 ebx
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_HWR_StartScreenWipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_DoPostProcessor
_TEXT	SEGMENT
tv234 = -1996						; size = 4
tv277 = -1992						; size = 4
_Surf$1 = -1732						; size = 8
_flags$2 = -1724					; size = 4
_v$3 = -1720						; size = 96
_flipy$4 = -1623					; size = 1
_y$5 = -1622						; size = 1
_x$6 = -1621						; size = 1
_v$7 = -1620						; size = 800
_FREQUENCY$8 = -820					; size = 4
_AMPLITUDE$9 = -816					; size = 4
_WAVELENGTH$10 = -812					; size = 4
_y$11 = -806						; size = 1
_x$12 = -805						; size = 1
_v$13 = -804						; size = 800
__$ArrayPad$ = -4					; size = 4
_HWR_DoPostProcessor PROC				; COMDAT

; 5205 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 07 00
	00		 sub	 esp, 1996		; 000007ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 5206 : 	// Capture the screen for intermission and screen waving
; 5207 : 	if(gamestate != GS_INTERMISSION)

  00016	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _gamestate, 2
  0001d	74 07		 je	 SHORT $LN14@HWR_DoPost

; 5208 : 		HWD.pfnMakeScreenTexture();

  0001f	ff 15 60 00 00
	00		 call	 DWORD PTR _hwdriver+96
  00025	90		 npad	 1
$LN14@HWR_DoPost:

; 5209 : 
; 5210 : 	if (postimgtype == postimg_water || postimgtype == postimg_heat)

  00026	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _postimgtype, 1
  0002d	74 0d		 je	 SHORT $LN17@HWR_DoPost
  0002f	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _postimgtype, 4
  00036	0f 85 b4 01 00
	00		 jne	 $LN15@HWR_DoPost
$LN17@HWR_DoPost:

; 5211 : 	{
; 5212 : 		// 10 by 10 grid. 2 coordinates (xy)
; 5213 : 		float v[SCREENVERTS][SCREENVERTS][2];
; 5214 : 		static double disStart = 0;
; 5215 : 		UINT8 x, y;
; 5216 : 		INT32 WAVELENGTH;
; 5217 : 		INT32 AMPLITUDE;
; 5218 : 		INT32 FREQUENCY;
; 5219 : 
; 5220 : 		// Modifies the wave.
; 5221 : 		if (postimgtype == postimg_water)

  0003c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _postimgtype, 1
  00043	75 20		 jne	 SHORT $LN18@HWR_DoPost

; 5222 : 		{
; 5223 : 			WAVELENGTH = 20; // Lower is longer

  00045	c7 85 d4 fc ff
	ff 14 00 00 00	 mov	 DWORD PTR _WAVELENGTH$10[ebp], 20 ; 00000014H

; 5224 : 			AMPLITUDE = 20; // Lower is bigger

  0004f	c7 85 d0 fc ff
	ff 14 00 00 00	 mov	 DWORD PTR _AMPLITUDE$9[ebp], 20 ; 00000014H

; 5225 : 			FREQUENCY = 16; // Lower is faster

  00059	c7 85 cc fc ff
	ff 10 00 00 00	 mov	 DWORD PTR _FREQUENCY$8[ebp], 16 ; 00000010H

; 5226 : 		}

  00063	eb 1e		 jmp	 SHORT $LN19@HWR_DoPost
$LN18@HWR_DoPost:

; 5227 : 		else
; 5228 : 		{
; 5229 : 			WAVELENGTH = 10; // Lower is longer

  00065	c7 85 d4 fc ff
	ff 0a 00 00 00	 mov	 DWORD PTR _WAVELENGTH$10[ebp], 10 ; 0000000aH

; 5230 : 			AMPLITUDE = 30; // Lower is bigger

  0006f	c7 85 d0 fc ff
	ff 1e 00 00 00	 mov	 DWORD PTR _AMPLITUDE$9[ebp], 30 ; 0000001eH

; 5231 : 			FREQUENCY = 4; // Lower is faster

  00079	c7 85 cc fc ff
	ff 04 00 00 00	 mov	 DWORD PTR _FREQUENCY$8[ebp], 4
$LN19@HWR_DoPost:

; 5232 : 		}
; 5233 : 
; 5234 : 		for (x = 0; x < SCREENVERTS; x++)

  00083	c6 85 db fc ff
	ff 00		 mov	 BYTE PTR _x$12[ebp], 0
  0008a	eb 0e		 jmp	 SHORT $LN4@HWR_DoPost
$LN2@HWR_DoPost:
  0008c	8a 85 db fc ff
	ff		 mov	 al, BYTE PTR _x$12[ebp]
  00092	04 01		 add	 al, 1
  00094	88 85 db fc ff
	ff		 mov	 BYTE PTR _x$12[ebp], al
$LN4@HWR_DoPost:
  0009a	0f b6 85 db fc
	ff ff		 movzx	 eax, BYTE PTR _x$12[ebp]
  000a1	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000a4	0f 8d 1b 01 00
	00		 jge	 $LN3@HWR_DoPost

; 5235 : 		{
; 5236 : 			for (y = 0; y < SCREENVERTS; y++)

  000aa	c6 85 da fc ff
	ff 00		 mov	 BYTE PTR _y$11[ebp], 0
  000b1	eb 0e		 jmp	 SHORT $LN7@HWR_DoPost
$LN5@HWR_DoPost:
  000b3	8a 85 da fc ff
	ff		 mov	 al, BYTE PTR _y$11[ebp]
  000b9	04 01		 add	 al, 1
  000bb	88 85 da fc ff
	ff		 mov	 BYTE PTR _y$11[ebp], al
$LN7@HWR_DoPost:
  000c1	0f b6 85 da fc
	ff ff		 movzx	 eax, BYTE PTR _y$11[ebp]
  000c8	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000cb	0f 8d ef 00 00
	00		 jge	 $LN6@HWR_DoPost

; 5237 : 			{
; 5238 : 				// Change X position based on its Y position.
; 5239 : 				v[x][y][0] = (x/((float)(SCREENVERTS-1.0f)/9.0f))-4.5f + (float)sin((disStart+(y*WAVELENGTH))/FREQUENCY)/AMPLITUDE;

  000d1	0f b6 85 db fc
	ff ff		 movzx	 eax, BYTE PTR _x$12[ebp]
  000d8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000dc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3f800000
  000e4	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40900000
  000ec	0f b6 8d da fc
	ff ff		 movzx	 ecx, BYTE PTR _y$11[ebp]
  000f3	0f af 8d d4 fc
	ff ff		 imul	 ecx, DWORD PTR _WAVELENGTH$10[ebp]
  000fa	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  000fe	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR ?disStart@?2??HWR_DoPostProcessor@@9@9
  00106	f2 0f 2a 95 cc
	fc ff ff	 cvtsi2sd xmm2, DWORD PTR _FREQUENCY$8[ebp]
  0010e	f2 0f 5e ca	 divsd	 xmm1, xmm2
  00112	83 ec 08	 sub	 esp, 8
  00115	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0011a	f3 0f 11 85 38
	f8 ff ff	 movss	 DWORD PTR tv277[ebp], xmm0
  00122	e8 00 00 00 00	 call	 _sin
  00127	83 c4 08	 add	 esp, 8
  0012a	d9 9d 34 f8 ff
	ff		 fstp	 DWORD PTR tv234[ebp]
  00130	f3 0f 10 85 34
	f8 ff ff	 movss	 xmm0, DWORD PTR tv234[ebp]
  00138	f3 0f 2a 8d d0
	fc ff ff	 cvtsi2ss xmm1, DWORD PTR _AMPLITUDE$9[ebp]
  00140	f3 0f 5e c1	 divss	 xmm0, xmm1
  00144	f3 0f 10 8d 38
	f8 ff ff	 movss	 xmm1, DWORD PTR tv277[ebp]
  0014c	f3 0f 58 c8	 addss	 xmm1, xmm0
  00150	0f b6 95 db fc
	ff ff		 movzx	 edx, BYTE PTR _x$12[ebp]
  00157	6b c2 50	 imul	 eax, edx, 80
  0015a	8d 8c 05 dc fc
	ff ff		 lea	 ecx, DWORD PTR _v$13[ebp+eax]
  00161	0f b6 95 da fc
	ff ff		 movzx	 edx, BYTE PTR _y$11[ebp]
  00168	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  0016b	b9 04 00 00 00	 mov	 ecx, 4
  00170	6b d1 00	 imul	 edx, ecx, 0
  00173	f3 0f 11 0c 10	 movss	 DWORD PTR [eax+edx], xmm1

; 5240 : 				v[x][y][1] = (y/((float)(SCREENVERTS-1.0f)/9.0f))-4.5f;

  00178	0f b6 85 da fc
	ff ff		 movzx	 eax, BYTE PTR _y$11[ebp]
  0017f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00183	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3f800000
  0018b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40900000
  00193	0f b6 8d db fc
	ff ff		 movzx	 ecx, BYTE PTR _x$12[ebp]
  0019a	6b d1 50	 imul	 edx, ecx, 80
  0019d	8d 84 15 dc fc
	ff ff		 lea	 eax, DWORD PTR _v$13[ebp+edx]
  001a4	0f b6 8d da fc
	ff ff		 movzx	 ecx, BYTE PTR _y$11[ebp]
  001ab	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  001ae	b8 04 00 00 00	 mov	 eax, 4
  001b3	c1 e0 00	 shl	 eax, 0
  001b6	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 5241 : 			}

  001bb	e9 f3 fe ff ff	 jmp	 $LN5@HWR_DoPost
$LN6@HWR_DoPost:

; 5242 : 		}

  001c0	e9 c7 fe ff ff	 jmp	 $LN2@HWR_DoPost
$LN3@HWR_DoPost:

; 5243 : 		HWD.pfnPostImgRedraw(v);

  001c5	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _v$13[ebp]
  001cb	50		 push	 eax
  001cc	ff 15 4c 00 00
	00		 call	 DWORD PTR _hwdriver+76
  001d2	90		 npad	 1

; 5244 : 		disStart += 1;

  001d3	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR ?disStart@?2??HWR_DoPostProcessor@@9@9
  001db	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  001e3	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?disStart@?2??HWR_DoPostProcessor@@9@9, xmm0

; 5245 : 	}

  001eb	e9 0f 01 00 00	 jmp	 $LN20@HWR_DoPost
$LN15@HWR_DoPost:

; 5246 : 	else if (postimgtype == postimg_flip) //We like our screens inverted.

  001f0	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _postimgtype, 3
  001f7	0f 85 02 01 00
	00		 jne	 $LN20@HWR_DoPost

; 5247 : 	{
; 5248 : 		// 10 by 10 grid. 2 coordinates (xy)
; 5249 : 		float v[SCREENVERTS][SCREENVERTS][2];
; 5250 : 		UINT8 x, y;
; 5251 : 		UINT8 flipy;
; 5252 : 
; 5253 : 		for (x = 0; x < SCREENVERTS; x++)

  001fd	c6 85 ab f9 ff
	ff 00		 mov	 BYTE PTR _x$6[ebp], 0
  00204	eb 0e		 jmp	 SHORT $LN10@HWR_DoPost
$LN8@HWR_DoPost:
  00206	8a 85 ab f9 ff
	ff		 mov	 al, BYTE PTR _x$6[ebp]
  0020c	04 01		 add	 al, 1
  0020e	88 85 ab f9 ff
	ff		 mov	 BYTE PTR _x$6[ebp], al
$LN10@HWR_DoPost:
  00214	0f b6 85 ab f9
	ff ff		 movzx	 eax, BYTE PTR _x$6[ebp]
  0021b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0021e	0f 8d cd 00 00
	00		 jge	 $LN9@HWR_DoPost

; 5254 : 		{
; 5255 : 			for (y = 0, flipy = SCREENVERTS; y < SCREENVERTS; y++, flipy--)

  00224	c6 85 aa f9 ff
	ff 00		 mov	 BYTE PTR _y$5[ebp], 0
  0022b	c6 85 a9 f9 ff
	ff 0a		 mov	 BYTE PTR _flipy$4[ebp], 10 ; 0000000aH
  00232	eb 1d		 jmp	 SHORT $LN13@HWR_DoPost
$LN11@HWR_DoPost:
  00234	8a 85 aa f9 ff
	ff		 mov	 al, BYTE PTR _y$5[ebp]
  0023a	04 01		 add	 al, 1
  0023c	88 85 aa f9 ff
	ff		 mov	 BYTE PTR _y$5[ebp], al
  00242	8a 8d a9 f9 ff
	ff		 mov	 cl, BYTE PTR _flipy$4[ebp]
  00248	80 e9 01	 sub	 cl, 1
  0024b	88 8d a9 f9 ff
	ff		 mov	 BYTE PTR _flipy$4[ebp], cl
$LN13@HWR_DoPost:
  00251	0f b6 85 aa f9
	ff ff		 movzx	 eax, BYTE PTR _y$5[ebp]
  00258	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0025b	0f 8d 8b 00 00
	00		 jge	 $LN12@HWR_DoPost

; 5256 : 			{
; 5257 : 				// Flip the screen.
; 5258 : 				v[x][y][0] = (x/((float)(SCREENVERTS-1.0f)/9.0f))-4.5f;

  00261	0f b6 85 ab f9
	ff ff		 movzx	 eax, BYTE PTR _x$6[ebp]
  00268	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0026c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3f800000
  00274	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40900000
  0027c	0f b6 8d ab f9
	ff ff		 movzx	 ecx, BYTE PTR _x$6[ebp]
  00283	6b d1 50	 imul	 edx, ecx, 80
  00286	8d 84 15 ac f9
	ff ff		 lea	 eax, DWORD PTR _v$7[ebp+edx]
  0028d	0f b6 8d aa f9
	ff ff		 movzx	 ecx, BYTE PTR _y$5[ebp]
  00294	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  00297	b8 04 00 00 00	 mov	 eax, 4
  0029c	6b c8 00	 imul	 ecx, eax, 0
  0029f	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 5259 : 				v[x][y][1] = (flipy/((float)(SCREENVERTS-1.0f)/9.0f))-5.5f;

  002a4	0f b6 85 a9 f9
	ff ff		 movzx	 eax, BYTE PTR _flipy$4[ebp]
  002ab	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002af	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3f800000
  002b7	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40b00000
  002bf	0f b6 8d ab f9
	ff ff		 movzx	 ecx, BYTE PTR _x$6[ebp]
  002c6	6b d1 50	 imul	 edx, ecx, 80
  002c9	8d 84 15 ac f9
	ff ff		 lea	 eax, DWORD PTR _v$7[ebp+edx]
  002d0	0f b6 8d aa f9
	ff ff		 movzx	 ecx, BYTE PTR _y$5[ebp]
  002d7	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  002da	b8 04 00 00 00	 mov	 eax, 4
  002df	c1 e0 00	 shl	 eax, 0
  002e2	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 5260 : 			}

  002e7	e9 48 ff ff ff	 jmp	 $LN11@HWR_DoPost
$LN12@HWR_DoPost:

; 5261 : 		}

  002ec	e9 15 ff ff ff	 jmp	 $LN8@HWR_DoPost
$LN9@HWR_DoPost:

; 5262 : 		HWD.pfnPostImgRedraw(v);

  002f1	8d 85 ac f9 ff
	ff		 lea	 eax, DWORD PTR _v$7[ebp]
  002f7	50		 push	 eax
  002f8	ff 15 4c 00 00
	00		 call	 DWORD PTR _hwdriver+76
  002fe	90		 npad	 1
$LN20@HWR_DoPost:

; 5263 : 	}
; 5264 : 
; 5265 : 	// Armageddon Blast Flash!
; 5266 : 	// Could this even be considered postprocessor?
; 5267 : 	if (stplyr->bonuscount)

  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _stplyr
  00304	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  0030b	0f 84 82 01 00
	00		 je	 $LN21@HWR_DoPost

; 5268 : 	{
; 5269 : 		FOutVector      v[4];
; 5270 : 		INT32 flags;
; 5271 : 		FSurfaceInfo Surf;
; 5272 : 
; 5273 : 		// Overkill variables! :D
; 5274 : 		v[0].x = v[2].y = v[3].x = v[3].y = -50.0f;

  00311	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00316	6b c8 03	 imul	 ecx, eax, 3
  00319	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  00321	f3 0f 11 84 0d
	4c f9 ff ff	 movss	 DWORD PTR _v$3[ebp+ecx+4], xmm0
  0032a	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  0032f	6b c2 03	 imul	 eax, edx, 3
  00332	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  0033a	f3 0f 11 84 05
	48 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+eax], xmm0
  00343	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00348	d1 e1		 shl	 ecx, 1
  0034a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  00352	f3 0f 11 84 0d
	4c f9 ff ff	 movss	 DWORD PTR _v$3[ebp+ecx+4], xmm0
  0035b	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  00360	6b c2 00	 imul	 eax, edx, 0
  00363	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2480000
  0036b	f3 0f 11 84 05
	48 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+eax], xmm0

; 5275 : 		v[0].y = v[1].x = v[1].y = v[2].x = 50.0f;

  00374	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00379	d1 e0		 shl	 eax, 1
  0037b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  00383	f3 0f 11 84 05
	48 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+eax], xmm0
  0038c	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00391	c1 e1 00	 shl	 ecx, 0
  00394	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  0039c	f3 0f 11 84 0d
	4c f9 ff ff	 movss	 DWORD PTR _v$3[ebp+ecx+4], xmm0
  003a5	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  003aa	c1 e2 00	 shl	 edx, 0
  003ad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  003b5	f3 0f 11 84 15
	48 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+edx], xmm0
  003be	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  003c3	6b c8 00	 imul	 ecx, eax, 0
  003c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  003ce	f3 0f 11 84 0d
	4c f9 ff ff	 movss	 DWORD PTR _v$3[ebp+ecx+4], xmm0

; 5276 : 		v[0].z = v[1].z = v[2].z = v[3].z = 50.0f;

  003d7	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  003dc	6b c8 03	 imul	 ecx, eax, 3
  003df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  003e7	f3 0f 11 84 0d
	50 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+ecx+8], xmm0
  003f0	ba 18 00 00 00	 mov	 edx, 24			; 00000018H
  003f5	d1 e2		 shl	 edx, 1
  003f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  003ff	f3 0f 11 84 15
	50 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+edx+8], xmm0
  00408	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0040d	c1 e0 00	 shl	 eax, 0
  00410	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  00418	f3 0f 11 84 05
	50 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+eax+8], xmm0
  00421	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00426	6b d1 00	 imul	 edx, ecx, 0
  00429	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  00431	f3 0f 11 84 15
	50 f9 ff ff	 movss	 DWORD PTR _v$3[ebp+edx+8], xmm0

; 5277 : 
; 5278 : 		flags = PF_Modulated | PF_Translucent | PF_Clip | PF_NoZClip | PF_NoDepthTest | PF_NoTexture;

  0043a	c7 85 44 f9 ff
	ff 02 32 00 60	 mov	 DWORD PTR _flags$2[ebp], 1610625538 ; 60003202H

; 5279 : 		Surf.FlatColor.s.red = Surf.FlatColor.s.green = Surf.FlatColor.s.blue = 255;

  00444	c6 85 42 f9 ff
	ff ff		 mov	 BYTE PTR _Surf$1[ebp+6], 255 ; 000000ffH
  0044b	8a 85 42 f9 ff
	ff		 mov	 al, BYTE PTR _Surf$1[ebp+6]
  00451	88 85 41 f9 ff
	ff		 mov	 BYTE PTR _Surf$1[ebp+5], al
  00457	8a 8d 41 f9 ff
	ff		 mov	 cl, BYTE PTR _Surf$1[ebp+5]
  0045d	88 8d 40 f9 ff
	ff		 mov	 BYTE PTR _Surf$1[ebp+4], cl

; 5280 : 		Surf.FlatColor.s.alpha = (UINT8)(stplyr->bonuscount*25);

  00463	a1 00 00 00 00	 mov	 eax, DWORD PTR _stplyr
  00468	6b 88 b0 00 00
	00 19		 imul	 ecx, DWORD PTR [eax+176], 25
  0046f	88 8d 43 f9 ff
	ff		 mov	 BYTE PTR _Surf$1[ebp+7], cl

; 5281 : 
; 5282 : 		HWD.pfnDrawPolygon(&Surf, v, 4, flags);

  00475	8b 85 44 f9 ff
	ff		 mov	 eax, DWORD PTR _flags$2[ebp]
  0047b	50		 push	 eax
  0047c	6a 04		 push	 4
  0047e	8d 8d 48 f9 ff
	ff		 lea	 ecx, DWORD PTR _v$3[ebp]
  00484	51		 push	 ecx
  00485	8d 95 3c f9 ff
	ff		 lea	 edx, DWORD PTR _Surf$1[ebp]
  0048b	52		 push	 edx
  0048c	ff 15 10 00 00
	00		 call	 DWORD PTR _hwdriver+16
  00492	90		 npad	 1
$LN21@HWR_DoPost:

; 5283 : 	}
; 5284 : }

  00493	5f		 pop	 edi
  00494	5e		 pop	 esi
  00495	5b		 pop	 ebx
  00496	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00499	33 cd		 xor	 ecx, ebp
  0049b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a0	8b e5		 mov	 esp, ebp
  004a2	5d		 pop	 ebp
  004a3	c3		 ret	 0
_HWR_DoPostProcessor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_GetTextureUsed
_TEXT	SEGMENT
_HWR_GetTextureUsed PROC				; COMDAT

; 5199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5200 : 	return HWD.pfnGetTextureUsed();

  00009	ff 15 3c 00 00
	00		 call	 DWORD PTR _hwdriver+60

; 5201 : }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_HWR_GetTextureUsed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_SetPaletteColor
_TEXT	SEGMENT
_palcolor$ = 8						; size = 4
_HWR_SetPaletteColor PROC				; COMDAT

; 5194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5195 : 	HWD.pfnSetSpecialState(HWD_SET_PALETTECOLOR, palcolor);

  00009	8b 45 08	 mov	 eax, DWORD PTR _palcolor$[ebp]
  0000c	50		 push	 eax
  0000d	6a 07		 push	 7
  0000f	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  00015	90		 npad	 1

; 5196 : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_HWR_SetPaletteColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_TranstableToAlpha
_TEXT	SEGMENT
tv64 = -68						; size = 4
_transtablenum$ = 8					; size = 4
_pSurf$ = 12						; size = 4
_HWR_TranstableToAlpha PROC				; COMDAT

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 934  : 	switch (transtablenum)

  00009	8b 45 08	 mov	 eax, DWORD PTR _transtablenum$[ebp]
  0000c	89 45 bc	 mov	 DWORD PTR tv64[ebp], eax
  0000f	8b 4d bc	 mov	 ecx, DWORD PTR tv64[ebp]
  00012	83 e9 01	 sub	 ecx, 1
  00015	89 4d bc	 mov	 DWORD PTR tv64[ebp], ecx
  00018	83 7d bc 08	 cmp	 DWORD PTR tv64[ebp], 8
  0001c	0f 87 88 00 00
	00		 ja	 $LN2@HWR_Transt
  00022	8b 55 bc	 mov	 edx, DWORD PTR tv64[ebp]
  00025	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@HWR_Transt[edx*4]
$LN4@HWR_Transt:

; 935  : 	{
; 936  : 		case tr_trans10 : pSurf->FlatColor.s.alpha = 0xe6;return  PF_Translucent;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  0002f	c6 40 07 e6	 mov	 BYTE PTR [eax+7], 230	; 000000e6H
  00033	b8 02 00 00 00	 mov	 eax, 2
  00038	eb 75		 jmp	 SHORT $LN1@HWR_Transt
$LN5@HWR_Transt:

; 937  : 		case tr_trans20 : pSurf->FlatColor.s.alpha = 0xcc;return  PF_Translucent;

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  0003d	c6 40 07 cc	 mov	 BYTE PTR [eax+7], 204	; 000000ccH
  00041	b8 02 00 00 00	 mov	 eax, 2
  00046	eb 67		 jmp	 SHORT $LN1@HWR_Transt
$LN6@HWR_Transt:

; 938  : 		case tr_trans30 : pSurf->FlatColor.s.alpha = 0xb3;return  PF_Translucent;

  00048	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  0004b	c6 40 07 b3	 mov	 BYTE PTR [eax+7], 179	; 000000b3H
  0004f	b8 02 00 00 00	 mov	 eax, 2
  00054	eb 59		 jmp	 SHORT $LN1@HWR_Transt
$LN7@HWR_Transt:

; 939  : 		case tr_trans40 : pSurf->FlatColor.s.alpha = 0x99;return  PF_Translucent;

  00056	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00059	c6 40 07 99	 mov	 BYTE PTR [eax+7], 153	; 00000099H
  0005d	b8 02 00 00 00	 mov	 eax, 2
  00062	eb 4b		 jmp	 SHORT $LN1@HWR_Transt
$LN8@HWR_Transt:

; 940  : 		case tr_trans50 : pSurf->FlatColor.s.alpha = 0x80;return  PF_Translucent;

  00064	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00067	c6 40 07 80	 mov	 BYTE PTR [eax+7], 128	; 00000080H
  0006b	b8 02 00 00 00	 mov	 eax, 2
  00070	eb 3d		 jmp	 SHORT $LN1@HWR_Transt
$LN9@HWR_Transt:

; 941  : 		case tr_trans60 : pSurf->FlatColor.s.alpha = 0x66;return  PF_Translucent;

  00072	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00075	c6 40 07 66	 mov	 BYTE PTR [eax+7], 102	; 00000066H
  00079	b8 02 00 00 00	 mov	 eax, 2
  0007e	eb 2f		 jmp	 SHORT $LN1@HWR_Transt
$LN10@HWR_Transt:

; 942  : 		case tr_trans70 : pSurf->FlatColor.s.alpha = 0x4c;return  PF_Translucent;

  00080	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00083	c6 40 07 4c	 mov	 BYTE PTR [eax+7], 76	; 0000004cH
  00087	b8 02 00 00 00	 mov	 eax, 2
  0008c	eb 21		 jmp	 SHORT $LN1@HWR_Transt
$LN11@HWR_Transt:

; 943  : 		case tr_trans80 : pSurf->FlatColor.s.alpha = 0x33;return  PF_Translucent;

  0008e	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  00091	c6 40 07 33	 mov	 BYTE PTR [eax+7], 51	; 00000033H
  00095	b8 02 00 00 00	 mov	 eax, 2
  0009a	eb 13		 jmp	 SHORT $LN1@HWR_Transt
$LN12@HWR_Transt:

; 944  : 		case tr_trans90 : pSurf->FlatColor.s.alpha = 0x19;return  PF_Translucent;

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pSurf$[ebp]
  0009f	c6 40 07 19	 mov	 BYTE PTR [eax+7], 25	; 00000019H
  000a3	b8 02 00 00 00	 mov	 eax, 2
  000a8	eb 05		 jmp	 SHORT $LN1@HWR_Transt
$LN2@HWR_Transt:

; 945  : 	}
; 946  : 	return PF_Translucent;

  000aa	b8 02 00 00 00	 mov	 eax, 2
$LN1@HWR_Transt:

; 947  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
  000b6	66 90		 npad	 2
$LN14@HWR_Transt:
  000b8	00 00 00 00	 DD	 $LN4@HWR_Transt
  000bc	00 00 00 00	 DD	 $LN5@HWR_Transt
  000c0	00 00 00 00	 DD	 $LN6@HWR_Transt
  000c4	00 00 00 00	 DD	 $LN7@HWR_Transt
  000c8	00 00 00 00	 DD	 $LN8@HWR_Transt
  000cc	00 00 00 00	 DD	 $LN9@HWR_Transt
  000d0	00 00 00 00	 DD	 $LN10@HWR_Transt
  000d4	00 00 00 00	 DD	 $LN11@HWR_Transt
  000d8	00 00 00 00	 DD	 $LN12@HWR_Transt
_HWR_TranstableToAlpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _transform
_TEXT	SEGMENT
_tr_y$ = -8						; size = 4
_tr_x$ = -4						; size = 4
_cx$ = 8						; size = 4
_cy$ = 12						; size = 4
_cz$ = 16						; size = 4
_transform PROC						; COMDAT

; 4969 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4970 : 	float tr_x,tr_y;
; 4971 : 	// translation
; 4972 : 	tr_x = *cx - gr_viewx;

  00009	8b 45 08	 mov	 eax, DWORD PTR _cx$[ebp]
  0000c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00010	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewx
  00018	f3 0f 11 45 fc	 movss	 DWORD PTR _tr_x$[ebp], xmm0

; 4973 : 	tr_y = *cz - gr_viewy;

  0001d	8b 45 10	 mov	 eax, DWORD PTR _cz$[ebp]
  00020	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00024	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewy
  0002c	f3 0f 11 45 f8	 movss	 DWORD PTR _tr_y$[ebp], xmm0

; 4974 : //	*cy = *cy;
; 4975 : 
; 4976 : 	// rotation around vertical y axis
; 4977 : 	*cx = (tr_x * gr_viewsin) - (tr_y * gr_viewcos);

  00031	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  00036	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewsin
  0003e	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  00043	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewcos
  0004b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0004f	8b 45 08	 mov	 eax, DWORD PTR _cx$[ebp]
  00052	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 4978 : 	tr_x = (tr_x * gr_viewcos) + (tr_y * gr_viewsin);

  00056	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  0005b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewcos
  00063	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  00068	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewsin
  00070	f3 0f 58 c1	 addss	 xmm0, xmm1
  00074	f3 0f 11 45 fc	 movss	 DWORD PTR _tr_x$[ebp], xmm0

; 4979 : 
; 4980 : 	//look up/down ----TOTAL SUCKS!!!--- do the 2 in one!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; 4981 : 	tr_y = *cy - gr_viewz;

  00079	8b 45 0c	 mov	 eax, DWORD PTR _cy$[ebp]
  0007c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00080	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewz
  00088	f3 0f 11 45 f8	 movss	 DWORD PTR _tr_y$[ebp], xmm0

; 4982 : 
; 4983 : 	*cy = (tr_x * gr_viewludcos) + (tr_y * gr_viewludsin);

  0008d	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  00092	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewludcos
  0009a	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  0009f	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewludsin
  000a7	f3 0f 58 c1	 addss	 xmm0, xmm1
  000ab	8b 45 0c	 mov	 eax, DWORD PTR _cy$[ebp]
  000ae	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 4984 : 	*cz = (tr_x * gr_viewludsin) - (tr_y * gr_viewludcos);

  000b2	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tr_x$[ebp]
  000b7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_viewludsin
  000bf	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _tr_y$[ebp]
  000c4	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR _gr_viewludcos
  000cc	f3 0f 5c c1	 subss	 xmm0, xmm1
  000d0	8b 45 10	 mov	 eax, DWORD PTR _cz$[ebp]
  000d3	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 4985 : 
; 4986 : 	//scale y before frustum so that frustum can be scaled to screen height
; 4987 : 	*cy *= ORIGINAL_ASPECT * gr_fovlud;

  000d7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fcccccd
  000df	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_fovlud
  000e7	8b 45 0c	 mov	 eax, DWORD PTR _cy$[ebp]
  000ea	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR _cy$[ebp]
  000f1	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 4988 : 	*cx *= gr_fovlud;

  000f5	8b 45 08	 mov	 eax, DWORD PTR _cx$[ebp]
  000f8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000fc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_fovlud
  00104	8b 4d 08	 mov	 ecx, DWORD PTR _cx$[ebp]
  00107	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 4989 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
_transform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_AddCommands
_TEXT	SEGMENT
_HWR_AddCommands PROC					; COMDAT

; 4895 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4896 : 	CV_RegisterVar(&cv_grmd2);

  00009	68 00 00 00 00	 push	 OFFSET _cv_grmd2
  0000e	e8 00 00 00 00	 call	 _CV_RegisterVar
  00013	83 c4 04	 add	 esp, 4

; 4897 : 	CV_RegisterVar(&cv_grfov);

  00016	68 00 00 00 00	 push	 OFFSET _cv_grfov
  0001b	e8 00 00 00 00	 call	 _CV_RegisterVar
  00020	83 c4 04	 add	 esp, 4

; 4898 : 	CV_RegisterVar(&cv_grfogdensity);

  00023	68 00 00 00 00	 push	 OFFSET _cv_grfogdensity
  00028	e8 00 00 00 00	 call	 _CV_RegisterVar
  0002d	83 c4 04	 add	 esp, 4

; 4899 : 	CV_RegisterVar(&cv_grfiltermode);

  00030	68 00 00 00 00	 push	 OFFSET _cv_grfiltermode
  00035	e8 00 00 00 00	 call	 _CV_RegisterVar
  0003a	83 c4 04	 add	 esp, 4

; 4900 : 	CV_RegisterVar(&cv_granisotropicmode);

  0003d	68 00 00 00 00	 push	 OFFSET _cv_granisotropicmode
  00042	e8 00 00 00 00	 call	 _CV_RegisterVar
  00047	83 c4 04	 add	 esp, 4

; 4901 : 	CV_RegisterVar(&cv_grcorrecttricks);

  0004a	68 00 00 00 00	 push	 OFFSET _cv_grcorrecttricks
  0004f	e8 00 00 00 00	 call	 _CV_RegisterVar
  00054	83 c4 04	 add	 esp, 4

; 4902 : 	CV_RegisterVar(&cv_grsolvetjoin);

  00057	68 00 00 00 00	 push	 OFFSET _cv_grsolvetjoin
  0005c	e8 00 00 00 00	 call	 _CV_RegisterVar
  00061	83 c4 04	 add	 esp, 4

; 4903 : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_HWR_AddCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_SetViewSize
_TEXT	SEGMENT
_HWR_SetViewSize PROC					; COMDAT

; 4566 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4567 : 	// setup view size
; 4568 : 	gr_viewwidth = (float)vid.width;

  00009	f3 0f 2a 05 0c
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+12
  00011	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewwidth, xmm0

; 4569 : 	gr_viewheight = (float)vid.height;

  00019	f3 0f 2a 05 10
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+16
  00021	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewheight, xmm0

; 4570 : 
; 4571 : 	if (splitscreen)

  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00030	74 18		 je	 SHORT $LN2@HWR_SetVie

; 4572 : 		gr_viewheight /= 2;

  00032	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewheight
  0003a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00042	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewheight, xmm0
$LN2@HWR_SetVie:

; 4573 : 
; 4574 : 	gr_centerx = gr_viewwidth / 2;

  0004a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewwidth
  00052	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0005a	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_centerx, xmm0

; 4575 : 	gr_basecentery = gr_viewheight / 2; //note: this is (gr_centerx * gr_viewheight / gr_viewwidth)

  00062	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewheight
  0006a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00072	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_basecentery, xmm0

; 4576 : 
; 4577 : 	gr_viewwindowx = (vid.width - gr_viewwidth) / 2;

  0007a	f3 0f 2a 05 0c
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+12
  00082	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewwidth
  0008a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00092	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewwindowx, xmm0

; 4578 : 	gr_windowcenterx = (float)(vid.width / 2);

  0009a	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0009f	99		 cdq
  000a0	2b c2		 sub	 eax, edx
  000a2	d1 f8		 sar	 eax, 1
  000a4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000a8	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_windowcenterx, xmm0

; 4579 : 	if (gr_viewwidth == vid.width)

  000b0	f3 0f 2a 05 0c
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+12
  000b8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR _gr_viewwidth
  000c0	0f 2e c8	 ucomiss xmm1, xmm0
  000c3	9f		 lahf
  000c4	f6 c4 44	 test	 ah, 68			; 00000044H
  000c7	7a 25		 jp	 SHORT $LN3@HWR_SetVie

; 4580 : 	{
; 4581 : 		gr_baseviewwindowy = 0;

  000c9	0f 57 c0	 xorps	 xmm0, xmm0
  000cc	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_baseviewwindowy, xmm0

; 4582 : 		gr_basewindowcentery = gr_viewheight / 2;               // window top left corner at 0,0

  000d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewheight
  000dc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000e4	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_basewindowcentery, xmm0

; 4583 : 	}

  000ec	eb 36		 jmp	 SHORT $LN4@HWR_SetVie
$LN3@HWR_SetVie:

; 4584 : 	else
; 4585 : 	{
; 4586 : 		gr_baseviewwindowy = (vid.height-gr_viewheight) / 2;

  000ee	f3 0f 2a 05 10
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+16
  000f6	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR _gr_viewheight
  000fe	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00106	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_baseviewwindowy, xmm0

; 4587 : 		gr_basewindowcentery = (float)(vid.height / 2);

  0010e	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00113	99		 cdq
  00114	2b c2		 sub	 eax, edx
  00116	d1 f8		 sar	 eax, 1
  00118	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0011c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_basewindowcentery, xmm0
$LN4@HWR_SetVie:

; 4588 : 	}
; 4589 : 
; 4590 : 	gr_pspritexscale = gr_viewwidth / BASEVIDWIDTH;

  00124	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewwidth
  0012c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@43a00000
  00134	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_pspritexscale, xmm0

; 4591 : 	gr_pspriteyscale = ((vid.height*gr_pspritexscale*BASEVIDWIDTH)/BASEVIDHEIGHT)/vid.width;

  0013c	f3 0f 2a 05 10
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+16
  00144	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR _gr_pspritexscale
  0014c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43a00000
  00154	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@43480000
  0015c	f3 0f 2a 0d 0c
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _vid+12
  00164	f3 0f 5e c1	 divss	 xmm0, xmm1
  00168	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_pspriteyscale, xmm0

; 4592 : }

  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
_HWR_SetViewSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_InitTextureMapping
_TEXT	SEGMENT
_grviewwidth$ = -28					; size = 4
_grcenterxfrac$ = -24					; size = 4
_grcenterx$ = -20					; size = 4
_focallength$ = -16					; size = 4
_t$ = -12						; size = 4
_x$ = -8						; size = 4
_i$ = -4						; size = 4
_HWR_InitTextureMapping PROC				; COMDAT

; 3118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3119 : 	angle_t i;
; 3120 : 	INT32 x;
; 3121 : 	INT32 t;
; 3122 : 	fixed_t focallength;
; 3123 : 	fixed_t grcenterx;
; 3124 : 	fixed_t grcenterxfrac;
; 3125 : 	INT32 grviewwidth;
; 3126 : 
; 3127 : #define clipanglefov (FIELDOFVIEW>>ANGLETOFINESHIFT)
; 3128 : 
; 3129 : 	grviewwidth = vid.width;

  00009	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0000e	89 45 e4	 mov	 DWORD PTR _grviewwidth$[ebp], eax

; 3130 : 	grcenterx = grviewwidth/2;

  00011	8b 45 e4	 mov	 eax, DWORD PTR _grviewwidth$[ebp]
  00014	99		 cdq
  00015	2b c2		 sub	 eax, edx
  00017	d1 f8		 sar	 eax, 1
  00019	89 45 ec	 mov	 DWORD PTR _grcenterx$[ebp], eax

; 3131 : 	grcenterxfrac = grcenterx<<FRACBITS;

  0001c	8b 45 ec	 mov	 eax, DWORD PTR _grcenterx$[ebp]
  0001f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00022	89 45 e8	 mov	 DWORD PTR _grcenterxfrac$[ebp], eax

; 3132 : 
; 3133 : 	// Use tangent table to generate viewangletox:
; 3134 : 	//  viewangletox will give the next greatest x
; 3135 : 	//  after the view angle.
; 3136 : 	//
; 3137 : 	// Calc focallength
; 3138 : 	//  so FIELDOFVIEW angles covers SCREENWIDTH.
; 3139 : 	focallength = FixedDiv(grcenterxfrac,

  00025	b8 04 00 00 00	 mov	 eax, 4
  0002a	69 c8 00 0c 00
	00		 imul	 ecx, eax, 3072
  00030	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _finetangent[ecx]
  00036	52		 push	 edx
  00037	8b 45 e8	 mov	 eax, DWORD PTR _grcenterxfrac$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _FixedDiv
  00040	83 c4 08	 add	 esp, 8
  00043	89 45 f0	 mov	 DWORD PTR _focallength$[ebp], eax

; 3140 : 		FINETANGENT(FINEANGLES/4+clipanglefov/2));
; 3141 : 
; 3142 : 	for (i = 0; i < FINEANGLES/2; i++)

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004d	eb 09		 jmp	 SHORT $LN4@HWR_InitTe
$LN2@HWR_InitTe:
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HWR_InitTe:
  00058	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR _i$[ebp], 4096 ; 00001000H
  0005f	0f 83 94 00 00
	00		 jae	 $LN3@HWR_InitTe

; 3143 : 	{
; 3144 : 		if (FINETANGENT(i) > FRACUNIT*2)

  00065	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00068	81 3c 85 00 00
	00 00 00 00 02
	00		 cmp	 DWORD PTR _finetangent[eax*4], 131072 ; 00020000H
  00073	7e 09		 jle	 SHORT $LN13@HWR_InitTe

; 3145 : 			t = -1;

  00075	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _t$[ebp], -1
  0007c	eb 69		 jmp	 SHORT $LN19@HWR_InitTe
$LN13@HWR_InitTe:

; 3146 : 		else if (FINETANGENT(i) < -FRACUNIT*2)

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00081	81 3c 85 00 00
	00 00 00 00 fe
	ff		 cmp	 DWORD PTR _finetangent[eax*4], -131072 ; fffe0000H
  0008c	7d 0b		 jge	 SHORT $LN15@HWR_InitTe

; 3147 : 			t = grviewwidth+1;

  0008e	8b 45 e4	 mov	 eax, DWORD PTR _grviewwidth$[ebp]
  00091	83 c0 01	 add	 eax, 1
  00094	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
  00097	eb 4e		 jmp	 SHORT $LN19@HWR_InitTe
$LN15@HWR_InitTe:

; 3148 : 		else
; 3149 : 		{
; 3150 : 			t = FixedMul(FINETANGENT(i), focallength);

  00099	8b 45 f0	 mov	 eax, DWORD PTR _focallength$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000a0	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finetangent[ecx*4]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 _FixedMul
  000ad	83 c4 08	 add	 esp, 8
  000b0	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax

; 3151 : 			t = (grcenterxfrac - t+FRACUNIT-1)>>FRACBITS;

  000b3	8b 45 e8	 mov	 eax, DWORD PTR _grcenterxfrac$[ebp]
  000b6	2b 45 f4	 sub	 eax, DWORD PTR _t$[ebp]
  000b9	05 ff ff 00 00	 add	 eax, 65535		; 0000ffffH
  000be	c1 f8 10	 sar	 eax, 16			; 00000010H
  000c1	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax

; 3152 : 
; 3153 : 			if (t < -1)

  000c4	83 7d f4 ff	 cmp	 DWORD PTR _t$[ebp], -1
  000c8	7d 09		 jge	 SHORT $LN17@HWR_InitTe

; 3154 : 				t = -1;

  000ca	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _t$[ebp], -1
  000d1	eb 14		 jmp	 SHORT $LN19@HWR_InitTe
$LN17@HWR_InitTe:

; 3155 : 			else if (t > grviewwidth+1)

  000d3	8b 45 e4	 mov	 eax, DWORD PTR _grviewwidth$[ebp]
  000d6	83 c0 01	 add	 eax, 1
  000d9	39 45 f4	 cmp	 DWORD PTR _t$[ebp], eax
  000dc	7e 09		 jle	 SHORT $LN19@HWR_InitTe

; 3156 : 				t = grviewwidth+1;

  000de	8b 45 e4	 mov	 eax, DWORD PTR _grviewwidth$[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	89 45 f4	 mov	 DWORD PTR _t$[ebp], eax
$LN19@HWR_InitTe:

; 3157 : 		}
; 3158 : 		gr_viewangletox[i] = t;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ea	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  000ed	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _gr_viewangletox[eax*4], ecx

; 3159 : 	}

  000f4	e9 56 ff ff ff	 jmp	 $LN2@HWR_InitTe
$LN3@HWR_InitTe:

; 3160 : 
; 3161 : 	// Scan viewangletox[] to generate xtoviewangle[]:
; 3162 : 	//  xtoviewangle will give the smallest view angle
; 3163 : 	//  that maps to x.
; 3164 : 	for (x = 0; x <= grviewwidth; x++)

  000f9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00100	eb 09		 jmp	 SHORT $LN7@HWR_InitTe
$LN5@HWR_InitTe:
  00102	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00105	83 c0 01	 add	 eax, 1
  00108	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
$LN7@HWR_InitTe:
  0010b	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0010e	3b 45 e4	 cmp	 eax, DWORD PTR _grviewwidth$[ebp]
  00111	7f 38		 jg	 SHORT $LN6@HWR_InitTe

; 3165 : 	{
; 3166 : 		i = 0;

  00113	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN8@HWR_InitTe:

; 3167 : 		while (gr_viewangletox[i]>x)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _gr_viewangletox[eax*4]
  00124	3b 4d f8	 cmp	 ecx, DWORD PTR _x$[ebp]
  00127	7e 0b		 jle	 SHORT $LN9@HWR_InitTe

; 3168 : 			i++;

  00129	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0012c	83 c0 01	 add	 eax, 1
  0012f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00132	eb e6		 jmp	 SHORT $LN8@HWR_InitTe
$LN9@HWR_InitTe:

; 3169 : 		gr_xtoviewangle[x] = (i<<ANGLETOFINESHIFT) - ANGLE_90;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00137	c1 e0 13	 shl	 eax, 19			; 00000013H
  0013a	2d 00 00 00 40	 sub	 eax, 1073741824		; 40000000H
  0013f	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00142	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _gr_xtoviewangle[ecx*4], eax

; 3170 : 	}

  00149	eb b7		 jmp	 SHORT $LN5@HWR_InitTe
$LN6@HWR_InitTe:

; 3171 : 
; 3172 : 	// Take out the fencepost cases from viewangletox.
; 3173 : 	for (i = 0; i < FINEANGLES/2; i++)

  0014b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00152	eb 09		 jmp	 SHORT $LN12@HWR_InitTe
$LN10@HWR_InitTe:
  00154	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00157	83 c0 01	 add	 eax, 1
  0015a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN12@HWR_InitTe:
  0015d	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR _i$[ebp], 4096 ; 00001000H
  00164	73 3e		 jae	 SHORT $LN11@HWR_InitTe

; 3174 : 	{
; 3175 : 		if (gr_viewangletox[i] == -1)

  00166	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00169	83 3c 85 00 00
	00 00 ff	 cmp	 DWORD PTR _gr_viewangletox[eax*4], -1
  00171	75 10		 jne	 SHORT $LN20@HWR_InitTe

; 3176 : 			gr_viewangletox[i] = 0;

  00173	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00176	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _gr_viewangletox[eax*4], 0
  00181	eb 1f		 jmp	 SHORT $LN22@HWR_InitTe
$LN20@HWR_InitTe:

; 3177 : 		else if (gr_viewangletox[i] == grviewwidth+1)

  00183	8b 45 e4	 mov	 eax, DWORD PTR _grviewwidth$[ebp]
  00186	83 c0 01	 add	 eax, 1
  00189	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0018c	39 04 8d 00 00
	00 00		 cmp	 DWORD PTR _gr_viewangletox[ecx*4], eax
  00193	75 0d		 jne	 SHORT $LN22@HWR_InitTe

; 3178 : 			gr_viewangletox[i]  = grviewwidth;

  00195	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00198	8b 4d e4	 mov	 ecx, DWORD PTR _grviewwidth$[ebp]
  0019b	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _gr_viewangletox[eax*4], ecx
$LN22@HWR_InitTe:

; 3179 : 	}

  001a2	eb b0		 jmp	 SHORT $LN10@HWR_InitTe
$LN11@HWR_InitTe:

; 3180 : 
; 3181 : 	gr_clipangle = gr_xtoviewangle[0];

  001a4	b8 04 00 00 00	 mov	 eax, 4
  001a9	6b c8 00	 imul	 ecx, eax, 0
  001ac	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _gr_xtoviewangle[ecx]
  001b2	89 15 00 00 00
	00		 mov	 DWORD PTR _gr_clipangle, edx

; 3182 : }

  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi
  001ba	5b		 pop	 ebx
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
_HWR_InitTextureMapping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_RenderPlayerView
_TEXT	SEGMENT
tv334 = -84						; size = 8
tv343 = -84						; size = 8
tv360 = -80						; size = 8
tv331 = -76						; size = 4
tv340 = -76						; size = 4
_saved_player$1 = -8					; size = 4
_fpov$ = -4						; size = 4
_viewnumber$ = 8					; size = 4
_player$ = 12						; size = 4
_HWR_RenderPlayerView PROC				; COMDAT

; 4598 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4599 : 	const float fpov = FIXED_TO_FLOAT(cv_grfov.value+player->fovadd);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _player$[ebp]
  0000c	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _cv_grfov+20
  00012	03 88 f8 01 00
	00		 add	 ecx, DWORD PTR [eax+504]
  00018	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0001c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00024	f3 0f 11 45 fc	 movss	 DWORD PTR _fpov$[ebp], xmm0

; 4600 : 	{
; 4601 : 		// do we really need to save player (is it not the same)?
; 4602 : 		player_t *saved_player = stplyr;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _stplyr
  0002e	89 45 f8	 mov	 DWORD PTR _saved_player$1[ebp], eax

; 4603 : 		stplyr = player;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _player$[ebp]
  00034	a3 00 00 00 00	 mov	 DWORD PTR _stplyr, eax

; 4604 : 		ST_doPaletteStuff();

  00039	e8 00 00 00 00	 call	 _ST_doPaletteStuff
  0003e	90		 npad	 1

; 4605 : 		stplyr = saved_player;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _saved_player$1[ebp]
  00042	a3 00 00 00 00	 mov	 DWORD PTR _stplyr, eax

; 4606 : 	}
; 4607 : 
; 4608 : 	// note: sets viewangle, viewx, viewy, viewz
; 4609 : 	R_SetupFrame(player);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _player$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _R_SetupFrame
  00050	83 c4 04	 add	 esp, 4

; 4610 : 
; 4611 : 	// copy view cam position for local use
; 4612 : 	dup_viewx = viewx;

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewx
  00058	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewx, eax

; 4613 : 	dup_viewy = viewy;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewy
  00062	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewy, eax

; 4614 : 	dup_viewz = viewz;

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewz
  0006c	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewz, eax

; 4615 : 	dup_viewangle = viewangle;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewangle
  00076	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewangle, eax

; 4616 : 
; 4617 : 	// set window position
; 4618 : 	gr_centery = gr_basecentery;

  0007b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_basecentery
  00083	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_centery, xmm0

; 4619 : 	gr_viewwindowy = gr_baseviewwindowy;

  0008b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_baseviewwindowy
  00093	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewwindowy, xmm0

; 4620 : 	gr_windowcentery = gr_basewindowcentery;

  0009b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_basewindowcentery
  000a3	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_windowcentery, xmm0

; 4621 : 	if (splitscreen && viewnumber == 1)

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  000b2	74 42		 je	 SHORT $LN2@HWR_Render
  000b4	83 7d 08 01	 cmp	 DWORD PTR _viewnumber$[ebp], 1
  000b8	75 3c		 jne	 SHORT $LN2@HWR_Render

; 4622 : 	{
; 4623 : 		gr_viewwindowy += (vid.height/2);

  000ba	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  000bf	99		 cdq
  000c0	2b c2		 sub	 eax, edx
  000c2	d1 f8		 sar	 eax, 1
  000c4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000c8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR _gr_viewwindowy
  000d0	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewwindowy, xmm0

; 4624 : 		gr_windowcentery += (vid.height/2);

  000d8	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  000dd	99		 cdq
  000de	2b c2		 sub	 eax, edx
  000e0	d1 f8		 sar	 eax, 1
  000e2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e6	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR _gr_windowcentery
  000ee	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_windowcentery, xmm0
$LN2@HWR_Render:

; 4625 : 	}
; 4626 : 
; 4627 : 	// check for new console commands.
; 4628 : 	NetUpdate();

  000f6	e8 00 00 00 00	 call	 _NetUpdate
  000fb	90		 npad	 1

; 4629 : 
; 4630 : 	gr_viewx = FIXED_TO_FLOAT(dup_viewx);

  000fc	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _dup_viewx
  00104	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0010c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewx, xmm0

; 4631 : 	gr_viewy = FIXED_TO_FLOAT(dup_viewy);

  00114	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _dup_viewy
  0011c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00124	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewy, xmm0

; 4632 : 	gr_viewz = FIXED_TO_FLOAT(dup_viewz);

  0012c	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _dup_viewz
  00134	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0013c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewz, xmm0

; 4633 : 	gr_viewsin = FIXED_TO_FLOAT(viewsin);

  00144	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _viewsin
  0014c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00154	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewsin, xmm0

; 4634 : 	gr_viewcos = FIXED_TO_FLOAT(viewcos);

  0015c	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _viewcos
  00164	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0016c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewcos, xmm0

; 4635 : 
; 4636 : 	gr_viewludsin = FIXED_TO_FLOAT(FINECOSINE(aimingangle>>ANGLETOFINESHIFT));

  00174	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimingangle
  00179	c1 e8 13	 shr	 eax, 19			; 00000013H
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00182	f3 0f 2a 04 81	 cvtsi2ss xmm0, DWORD PTR [ecx+eax*4]
  00187	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0018f	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewludsin, xmm0

; 4637 : 	gr_viewludcos = FIXED_TO_FLOAT(-FINESINE(aimingangle>>ANGLETOFINESHIFT));

  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimingangle
  0019c	c1 e8 13	 shr	 eax, 19			; 00000013H
  0019f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  001a6	f7 d9		 neg	 ecx
  001a8	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001ac	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001b4	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_viewludcos, xmm0

; 4638 : 
; 4639 : 	//04/01/2000: Hurdler: added for T&L
; 4640 : 	//                     It should replace all other gr_viewxxx when finished
; 4641 : 	atransform.anglex = (float)(aimingangle>>ANGLETOFINESHIFT)*(360.0f/(float)FINEANGLES);

  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimingangle
  001c1	c1 e8 13	 shr	 eax, 19			; 00000013H
  001c4	89 45 b4	 mov	 DWORD PTR tv331[ebp], eax
  001c7	f2 0f 2a 45 b4	 cvtsi2sd xmm0, DWORD PTR tv331[ebp]
  001cc	8b 4d b4	 mov	 ecx, DWORD PTR tv331[ebp]
  001cf	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001d2	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  001db	f2 0f 11 45 ac	 movsd	 QWORD PTR tv334[ebp], xmm0
  001e0	f2 0f 5a 45 ac	 cvtsd2ss xmm0, QWORD PTR tv334[ebp]
  001e5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3d340000
  001ed	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR _atransform+12, xmm0

; 4642 : 	atransform.angley = (float)(viewangle>>ANGLETOFINESHIFT)*(360.0f/(float)FINEANGLES);

  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewangle
  001fa	c1 e8 13	 shr	 eax, 19			; 00000013H
  001fd	89 45 b4	 mov	 DWORD PTR tv340[ebp], eax
  00200	f2 0f 2a 45 b4	 cvtsi2sd xmm0, DWORD PTR tv340[ebp]
  00205	8b 4d b4	 mov	 ecx, DWORD PTR tv340[ebp]
  00208	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0020b	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00214	f2 0f 11 45 ac	 movsd	 QWORD PTR tv343[ebp], xmm0
  00219	f2 0f 5a 45 ac	 cvtsd2ss xmm0, QWORD PTR tv343[ebp]
  0021e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3d340000
  00226	f3 0f 11 05 10
	00 00 00	 movss	 DWORD PTR _atransform+16, xmm0

; 4643 : 	atransform.x      = gr_viewx;  // FIXED_TO_FLOAT(viewx)

  0022e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewx
  00236	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _atransform, xmm0

; 4644 : 	atransform.y      = gr_viewy;  // FIXED_TO_FLOAT(viewy)

  0023e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewy
  00246	f3 0f 11 05 04
	00 00 00	 movss	 DWORD PTR _atransform+4, xmm0

; 4645 : 	atransform.z      = gr_viewz;  // FIXED_TO_FLOAT(viewz)

  0024e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _gr_viewz
  00256	f3 0f 11 05 08
	00 00 00	 movss	 DWORD PTR _atransform+8, xmm0

; 4646 : 	atransform.scalex = 1;

  0025e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00266	f3 0f 11 05 14
	00 00 00	 movss	 DWORD PTR _atransform+20, xmm0

; 4647 : 	atransform.scaley = ORIGINAL_ASPECT;

  0026e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fcccccd
  00276	f3 0f 11 05 18
	00 00 00	 movss	 DWORD PTR _atransform+24, xmm0

; 4648 : 	atransform.scalez = 1;

  0027e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00286	f3 0f 11 05 1c
	00 00 00	 movss	 DWORD PTR _atransform+28, xmm0

; 4649 : 	atransform.fovxangle = fpov; // Tails

  0028e	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fpov$[ebp]
  00293	f3 0f 11 05 20
	00 00 00	 movss	 DWORD PTR _atransform+32, xmm0

; 4650 : 	atransform.fovyangle = fpov; // Tails

  0029b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fpov$[ebp]
  002a0	f3 0f 11 05 24
	00 00 00	 movss	 DWORD PTR _atransform+36, xmm0

; 4651 : 	atransform.splitscreen = splitscreen;

  002a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _splitscreen
  002ad	a3 28 00 00 00	 mov	 DWORD PTR _atransform+40, eax

; 4652 : 	gr_fovlud = (float)(1.0l/tan((double)(fpov*M_PIl/360l)));

  002b2	f3 0f 5a 45 fc	 cvtss2sd xmm0, DWORD PTR _fpov$[ebp]
  002b7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18
  002bf	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4076800000000000
  002c7	83 ec 08	 sub	 esp, 8
  002ca	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002cf	e8 00 00 00 00	 call	 _tan
  002d4	83 c4 08	 add	 esp, 8
  002d7	dd 5d b0	 fstp	 QWORD PTR tv360[ebp]
  002da	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  002e2	f2 0f 5e 45 b0	 divsd	 xmm0, QWORD PTR tv360[ebp]
  002e7	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002eb	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gr_fovlud, xmm0

; 4653 : 
; 4654 : 	//------------------------------------------------------------------------
; 4655 : 	HWR_ClearView();

  002f3	e8 00 00 00 00	 call	 _HWR_ClearView
  002f8	90		 npad	 1

; 4656 : 
; 4657 : 	/* // I don't think this is ever used.
; 4658 : 	if (cv_grfog.value)
; 4659 : 	{
; 4660 : 		camera_t *camview;
; 4661 : 
; 4662 : 		HWR_FoggingOn(); // First of all, turn it on, set the default user settings too
; 4663 : 
; 4664 : 		if (splitscreen && player == &players[secondarydisplayplayer])
; 4665 : 			camview = &camera2;
; 4666 : 		else
; 4667 : 			camview = &camera;
; 4668 : 
; 4669 : 		if (viewsector)// && player->mo->subsector->sector->extra_colormap)
; 4670 : 		{
; 4671 : 			if (viewsector->ffloors)
; 4672 : 			{
; 4673 : 				ffloor_t *rover;
; 4674 : 
; 4675 : 				for (rover = viewsector->ffloors; rover; rover = rover->next)
; 4676 : 				{
; 4677 : 					if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_SWIMMABLE) || rover->flags & FF_SOLID)
; 4678 : 						continue;
; 4679 : 
; 4680 : 					if (*rover->topheight <= camview->z
; 4681 : 						|| *rover->bottomheight > (camview->z + (camview->height >> 1)))
; 4682 : 						continue;
; 4683 : 
; 4684 : 					if (camview->z + (camview->height >> 1) < *rover->topheight)
; 4685 : 					{
; 4686 : 						UINT32 sectorcolormap; // RGBA value of the sector's colormap
; 4687 : 						RGBA_t rgbcolor; // Convert the value from UINT32 to RGA_t
; 4688 : 						UINT32 fogvalue; // convert the color to FOG from RGBA to RGB
; 4689 : 
; 4690 : 						if (!(rover->master->frontsector->extra_colormap)) // See if there's a colormap in this FOF
; 4691 : 							continue;
; 4692 : 
; 4693 : 						sectorcolormap = rover->master->frontsector->extra_colormap->rgba;
; 4694 : 
; 4695 : 						rgbcolor.rgba = sectorcolormap;
; 4696 : 
; 4697 : 						fogvalue = (rgbcolor.s.red*0x10000)+(rgbcolor.s.green*0x100)+rgbcolor.s.blue;
; 4698 : 
; 4699 : 						HWD.pfnSetSpecialState(HWD_SET_FOG_COLOR, fogvalue);
; 4700 : 						HWD.pfnSetSpecialState(HWD_SET_FOG_DENSITY, cv_grfogdensity.value+128);
; 4701 : 
; 4702 : 					}
; 4703 : 
; 4704 : 				}
; 4705 : 			}
; 4706 : 
; 4707 : 		}
; 4708 : 		else // no custom fog?
; 4709 : 		{
; 4710 : 			HWD.pfnSetSpecialState(HWD_SET_FOG_COLOR, atohex(cv_grfogcolor.string));
; 4711 : 			HWD.pfnSetSpecialState(HWD_SET_FOG_DENSITY, cv_grfogdensity.value);
; 4712 : 		}
; 4713 : 
; 4714 : 	}
; 4715 : 	else
; 4716 : 		HWD.pfnSetSpecialState(HWD_SET_FOG_MODE, 0); // Turn it off
; 4717 : 		*/
; 4718 : 
; 4719 : 	if (drawsky)

  002f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _drawsky, 0
  00300	74 0c		 je	 SHORT $LN3@HWR_Render

; 4720 : 		HWR_DrawSkyBackground(player);

  00302	8b 45 0c	 mov	 eax, DWORD PTR _player$[ebp]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 _HWR_DrawSkyBackground
  0030b	83 c4 04	 add	 esp, 4
$LN3@HWR_Render:

; 4721 : 
; 4722 : 	//Hurdler: it doesn't work in splitscreen mode
; 4723 : 	drawsky = splitscreen;

  0030e	a1 00 00 00 00	 mov	 eax, DWORD PTR _splitscreen
  00313	a3 00 00 00 00	 mov	 DWORD PTR _drawsky, eax

; 4724 : 
; 4725 : 	HWR_ClearSprites();

  00318	e8 00 00 00 00	 call	 _HWR_ClearSprites
  0031d	90		 npad	 1

; 4726 : 
; 4727 : #ifdef SORTING
; 4728 : 	drawcount = 0;

  0031e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _drawcount, 0

; 4729 : #endif
; 4730 : 	HWR_ClearClipSegs();

  00328	e8 00 00 00 00	 call	 _HWR_ClearClipSegs
  0032d	90		 npad	 1

; 4731 : 
; 4732 : 	//04/01/2000: Hurdler: added for T&L
; 4733 : 	//                     Actually it only works on Walls and Planes
; 4734 : 	HWD.pfnSetTransform(&atransform);

  0032e	68 00 00 00 00	 push	 OFFSET _atransform
  00333	ff 15 38 00 00
	00		 call	 DWORD PTR _hwdriver+56
  00339	90		 npad	 1

; 4735 : 
; 4736 : 	validcount++;

  0033a	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  0033f	83 c0 01	 add	 eax, 1
  00342	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 4737 : 
; 4738 : 	HWR_RenderBSPNode((INT32)numnodes-1);

  00347	a1 00 00 00 00	 mov	 eax, DWORD PTR _numnodes
  0034c	83 e8 01	 sub	 eax, 1
  0034f	50		 push	 eax
  00350	e8 00 00 00 00	 call	 _HWR_RenderBSPNode
  00355	83 c4 04	 add	 esp, 4

; 4739 : 
; 4740 : 	// Make a viewangle int so we can render things based on mouselook
; 4741 : 	if (player == &players[consoleplayer])

  00358	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00362	05 00 00 00 00	 add	 eax, OFFSET _players
  00367	39 45 0c	 cmp	 DWORD PTR _player$[ebp], eax
  0036a	75 0c		 jne	 SHORT $LN4@HWR_Render

; 4742 : 		viewangle = localaiming;

  0036c	a1 00 00 00 00	 mov	 eax, DWORD PTR _localaiming
  00371	a3 00 00 00 00	 mov	 DWORD PTR _viewangle, eax
  00376	eb 27		 jmp	 SHORT $LN6@HWR_Render
$LN4@HWR_Render:

; 4743 : 	else if (splitscreen && player == &players[secondarydisplayplayer])

  00378	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0037f	74 1e		 je	 SHORT $LN6@HWR_Render
  00381	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0038b	05 00 00 00 00	 add	 eax, OFFSET _players
  00390	39 45 0c	 cmp	 DWORD PTR _player$[ebp], eax
  00393	75 0a		 jne	 SHORT $LN6@HWR_Render

; 4744 : 		viewangle = localaiming2;

  00395	a1 00 00 00 00	 mov	 eax, DWORD PTR _localaiming2
  0039a	a3 00 00 00 00	 mov	 DWORD PTR _viewangle, eax
$LN6@HWR_Render:

; 4745 : 
; 4746 : 	// Handle stuff when you are looking farther up or down.
; 4747 : 	if ((aimingangle || cv_grfov.value+player->fovadd > 90*FRACUNIT))

  0039f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _aimingangle, 0
  003a6	75 1b		 jne	 SHORT $LN8@HWR_Render
  003a8	8b 45 0c	 mov	 eax, DWORD PTR _player$[ebp]
  003ab	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _cv_grfov+20
  003b1	03 88 f8 01 00
	00		 add	 ecx, DWORD PTR [eax+504]
  003b7	81 f9 00 00 5a
	00		 cmp	 ecx, 5898240		; 005a0000H
  003bd	0f 8e 99 00 00
	00		 jle	 $LN7@HWR_Render
$LN8@HWR_Render:

; 4748 : 	{
; 4749 : 		dup_viewangle += ANGLE_90;

  003c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewangle
  003c8	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  003cd	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewangle, eax

; 4750 : 		HWR_ClearClipSegs();

  003d2	e8 00 00 00 00	 call	 _HWR_ClearClipSegs
  003d7	90		 npad	 1

; 4751 : 		HWR_RenderBSPNode((INT32)numnodes-1); //left

  003d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _numnodes
  003dd	83 e8 01	 sub	 eax, 1
  003e0	50		 push	 eax
  003e1	e8 00 00 00 00	 call	 _HWR_RenderBSPNode
  003e6	83 c4 04	 add	 esp, 4

; 4752 : 
; 4753 : 		dup_viewangle += ANGLE_90;

  003e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewangle
  003ee	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  003f3	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewangle, eax

; 4754 : 		if (((INT32)aimingangle > ANGLE_45 || (INT32)aimingangle<-ANGLE_45))

  003f8	81 3d 00 00 00
	00 00 00 00 20	 cmp	 DWORD PTR _aimingangle, 536870912 ; 20000000H
  00402	7f 0c		 jg	 SHORT $LN10@HWR_Render
  00404	81 3d 00 00 00
	00 00 00 00 e0	 cmp	 DWORD PTR _aimingangle, -536870912 ; e0000000H
  0040e	7d 17		 jge	 SHORT $LN9@HWR_Render
$LN10@HWR_Render:

; 4755 : 		{
; 4756 : 			HWR_ClearClipSegs();

  00410	e8 00 00 00 00	 call	 _HWR_ClearClipSegs
  00415	90		 npad	 1

; 4757 : 			HWR_RenderBSPNode((INT32)numnodes-1); //back

  00416	a1 00 00 00 00	 mov	 eax, DWORD PTR _numnodes
  0041b	83 e8 01	 sub	 eax, 1
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 _HWR_RenderBSPNode
  00424	83 c4 04	 add	 esp, 4
$LN9@HWR_Render:

; 4758 : 		}
; 4759 : 
; 4760 : 		dup_viewangle += ANGLE_90;

  00427	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewangle
  0042c	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  00431	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewangle, eax

; 4761 : 		HWR_ClearClipSegs();

  00436	e8 00 00 00 00	 call	 _HWR_ClearClipSegs
  0043b	90		 npad	 1

; 4762 : 		HWR_RenderBSPNode((INT32)numnodes-1); //right

  0043c	a1 00 00 00 00	 mov	 eax, DWORD PTR _numnodes
  00441	83 e8 01	 sub	 eax, 1
  00444	50		 push	 eax
  00445	e8 00 00 00 00	 call	 _HWR_RenderBSPNode
  0044a	83 c4 04	 add	 esp, 4

; 4763 : 
; 4764 : 		dup_viewangle += ANGLE_90;

  0044d	a1 00 00 00 00	 mov	 eax, DWORD PTR _dup_viewangle
  00452	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  00457	a3 00 00 00 00	 mov	 DWORD PTR _dup_viewangle, eax
$LN7@HWR_Render:

; 4765 : 	}
; 4766 : 
; 4767 : 	// Check for new console commands.
; 4768 : 	NetUpdate();

  0045c	e8 00 00 00 00	 call	 _NetUpdate
  00461	90		 npad	 1

; 4769 : 
; 4770 : 	// Draw MD2 and sprites
; 4771 : #ifdef SORTING
; 4772 : 	HWR_SortVisSprites();

  00462	e8 00 00 00 00	 call	 _HWR_SortVisSprites
  00467	90		 npad	 1

; 4773 : #endif
; 4774 : 	HWR_DrawMD2S();

  00468	e8 00 00 00 00	 call	 _HWR_DrawMD2S
  0046d	90		 npad	 1

; 4775 : 
; 4776 : 	// Draw the sprites like it was done previously without T&L
; 4777 : 	HWD.pfnSetTransform(NULL);

  0046e	6a 00		 push	 0
  00470	ff 15 38 00 00
	00		 call	 DWORD PTR _hwdriver+56
  00476	90		 npad	 1

; 4778 : #ifdef SORTING
; 4779 : 	HWR_DrawSprites();

  00477	e8 00 00 00 00	 call	 _HWR_DrawSprites
  0047c	90		 npad	 1

; 4780 : #endif
; 4781 : #ifdef NEWCORONAS
; 4782 : 	//Hurdler: they must be drawn before translucent planes, what about gl fog?
; 4783 : 	HWR_DrawCoronas();
; 4784 : #endif
; 4785 : 
; 4786 : #ifdef SORTING
; 4787 : 	if (numplanes || numwalls) //Hurdler: render 3D water and transparent walls after everything

  0047d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numplanes, 0
  00484	75 09		 jne	 SHORT $LN12@HWR_Render
  00486	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numwalls, 0
  0048d	74 0f		 je	 SHORT $LN11@HWR_Render
$LN12@HWR_Render:

; 4788 : 	{
; 4789 : 		HWR_CreateDrawNodes();

  0048f	e8 00 00 00 00	 call	 _HWR_CreateDrawNodes
  00494	90		 npad	 1

; 4790 : 		HWD.pfnSetTransform(NULL);

  00495	6a 00		 push	 0
  00497	ff 15 38 00 00
	00		 call	 DWORD PTR _hwdriver+56
  0049d	90		 npad	 1
$LN11@HWR_Render:

; 4791 : 	}
; 4792 : #else
; 4793 : 	if (numfloors || numwalls)
; 4794 : 	{
; 4795 : 		HWD.pfnSetTransform(&atransform);
; 4796 : 		if (numfloors)
; 4797 : 			HWR_Render3DWater();
; 4798 : 		if (numwalls)
; 4799 : 			HWR_RenderTransparentWalls();
; 4800 : 		HWD.pfnSetTransform(NULL);
; 4801 : 	}
; 4802 : #endif
; 4803 : 
; 4804 : 	// put it off for menus etc
; 4805 : 	if (cv_grfog.value)

  0049e	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grfog+20, 0
  004a5	74 0b		 je	 SHORT $LN13@HWR_Render

; 4806 : 		HWD.pfnSetSpecialState(HWD_SET_FOG_MODE, 0);

  004a7	6a 00		 push	 0
  004a9	6a 02		 push	 2
  004ab	ff 15 2c 00 00
	00		 call	 DWORD PTR _hwdriver+44
  004b1	90		 npad	 1
$LN13@HWR_Render:

; 4807 : 
; 4808 : #ifdef SHUFFLE
; 4809 : 	HWR_DoPostProcessor();

  004b2	e8 00 00 00 00	 call	 _HWR_DoPostProcessor
  004b7	90		 npad	 1

; 4810 : #endif
; 4811 : 	// Check for new console commands.
; 4812 : 	NetUpdate();

  004b8	e8 00 00 00 00	 call	 _NetUpdate
  004bd	90		 npad	 1

; 4813 : 
; 4814 : 	//------------------------------------------------------------------------
; 4815 : 
; 4816 : 
; 4817 : 	// added by Hurdler for correct splitscreen
; 4818 : 	// moved here by hurdler so it works with the new near clipping plane
; 4819 : 	HWD.pfnGClipRect(0, 0, vid.width, vid.height, NZCLIP_PLANE);

  004be	51		 push	 ecx
  004bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  004c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cc	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  004d1	50		 push	 eax
  004d2	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  004d8	51		 push	 ecx
  004d9	6a 00		 push	 0
  004db	6a 00		 push	 0
  004dd	ff 15 24 00 00
	00		 call	 DWORD PTR _hwdriver+36
  004e3	90		 npad	 1

; 4820 : }

  004e4	5f		 pop	 edi
  004e5	5e		 pop	 esi
  004e6	5b		 pop	 ebx
  004e7	8b e5		 mov	 esp, ebp
  004e9	5d		 pop	 ebp
  004ea	c3		 ret	 0
_HWR_RenderPlayerView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_Shutdown
_TEXT	SEGMENT
_HWR_Shutdown PROC					; COMDAT

; 4961 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4962 : 	CONS_Printf("HWR_Shutdown()\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BOHMIMOL@HWR_Shutdown?$CI?$CJ?6@
  0000e	e8 00 00 00 00	 call	 _CONS_Printf
  00013	83 c4 04	 add	 esp, 4

; 4963 : 	HWR_FreeExtraSubsectors();

  00016	e8 00 00 00 00	 call	 _HWR_FreeExtraSubsectors
  0001b	90		 npad	 1

; 4964 : 	HWR_FreePolyPool();

  0001c	e8 00 00 00 00	 call	 _HWR_FreePolyPool
  00021	90		 npad	 1

; 4965 : 	HWR_FreeTextureCache();

  00022	e8 00 00 00 00	 call	 _HWR_FreeTextureCache
  00027	90		 npad	 1

; 4966 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_HWR_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_main.c
;	COMDAT _HWR_Startup
_TEXT	SEGMENT
_HWR_Startup PROC					; COMDAT

; 4923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4924 : 	static boolean startupdone = false;
; 4925 : 
; 4926 : 	// setup GLPatch_t scaling
; 4927 : 	gr_patch_scalex = (float)(1.0f / vid.width);

  00009	f3 0f 2a 05 0c
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+12
  00011	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00019	f3 0f 5e c8	 divss	 xmm1, xmm0
  0001d	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR _gr_patch_scalex, xmm1

; 4928 : 	gr_patch_scaley = (float)(1.0f / vid.height);

  00025	f3 0f 2a 05 10
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+16
  0002d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00035	f3 0f 5e c8	 divss	 xmm1, xmm0
  00039	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR _gr_patch_scaley, xmm1

; 4929 : 
; 4930 : 	// initalze light lut translation
; 4931 : 	InitLumLut();

  00041	e8 00 00 00 00	 call	 _InitLumLut
  00046	90		 npad	 1

; 4932 : 
; 4933 : 	// do this once
; 4934 : 	if (!startupdone)

  00047	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?startupdone@?1??HWR_Startup@@9@9, 0
  0004e	75 52		 jne	 SHORT $LN2@HWR_Startu

; 4935 : 	{
; 4936 : 		CONS_Printf("HWR_Startup()\n");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OBNNGKIE@HWR_Startup?$CI?$CJ?6@
  00055	e8 00 00 00 00	 call	 _CONS_Printf
  0005a	83 c4 04	 add	 esp, 4

; 4937 : 		HWR_InitPolyPool();

  0005d	e8 00 00 00 00	 call	 _HWR_InitPolyPool
  00062	90		 npad	 1

; 4938 : 		// add console cmds & vars
; 4939 : 		HWR_AddEngineCommands();

  00063	e8 00 00 00 00	 call	 _HWR_AddEngineCommands
  00068	90		 npad	 1

; 4940 : 		HWR_InitTextureCache();

  00069	e8 00 00 00 00	 call	 _HWR_InitTextureCache
  0006e	90		 npad	 1

; 4941 : 
; 4942 : 		// for test water translucent surface
; 4943 : 		doomwaterflat  = W_CheckNumForName("FWATER1");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_07JPGFNJGE@FWATER1@
  00074	e8 00 00 00 00	 call	 _W_CheckNumForName
  00079	83 c4 04	 add	 esp, 4
  0007c	a3 00 00 00 00	 mov	 DWORD PTR _doomwaterflat, eax

; 4944 : 		if (doomwaterflat == LUMPERROR) // if FWATER1 not found (in doom shareware)

  00081	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _doomwaterflat, -1
  00088	75 12		 jne	 SHORT $LN3@HWR_Startu

; 4945 : 			doomwaterflat = W_GetNumForName("WATER0");

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_06JBMCCDFI@WATER0@
  0008f	e8 00 00 00 00	 call	 _W_GetNumForName
  00094	83 c4 04	 add	 esp, 4
  00097	a3 00 00 00 00	 mov	 DWORD PTR _doomwaterflat, eax
$LN3@HWR_Startu:

; 4946 : 
; 4947 : 		HWR_InitMD2();

  0009c	e8 00 00 00 00	 call	 _HWR_InitMD2
  000a1	90		 npad	 1
$LN2@HWR_Startu:

; 4948 : 	}
; 4949 : 
; 4950 : 	if (rendermode == render_opengl)

  000a2	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _rendermode, 2
  000a9	75 14		 jne	 SHORT $LN4@HWR_Startu

; 4951 : 		textureformat = patchformat = GR_RGBA;

  000ab	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _patchformat, 6
  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _patchformat
  000ba	a3 00 00 00 00	 mov	 DWORD PTR _textureformat, eax
$LN4@HWR_Startu:

; 4952 : 
; 4953 : 	startupdone = true;

  000bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?startupdone@?1??HWR_Startup@@9@9, 1

; 4954 : }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
_HWR_Startup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedInt
_TEXT	SEGMENT
_a$ = 8							; size = 4
_FixedInt PROC						; COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 222  : 	return FixedMul(a, 1);

  00009	6a 01		 push	 1
  0000b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _FixedMul
  00014	83 c4 08	 add	 esp, 8

; 223  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_FixedInt ENDP
_TEXT	ENDS
END
