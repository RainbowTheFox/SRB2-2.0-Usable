; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\hw_trick.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
PUBLIC	_HWR_CorrectSWTricks
PUBLIC	??_C@_0CE@LLOBDHMA@Out?5of?5memory?5in?5addLineToChain@ ; `string'
PUBLIC	??_C@_0CL@BBCGPKOB@Out?5of?5memory?5error?5in?5generate@ ; `string'
PUBLIC	??_C@_07IDPDJOKH@REDWALL@			; `string'
PUBLIC	__real@3fa015bf9217271a
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@401921fb54442d18
PUBLIC	__real@403f6a7a2955385e
EXTRN	_atan2:PROC
EXTRN	_hypot:PROC
EXTRN	_memcpy:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_I_Error:PROC
EXTRN	_R_TextureNumForName:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_cv_grcorrecttricks:BYTE
EXTRN	_numsectors:DWORD
EXTRN	_sectors:DWORD
EXTRN	_numlines:DWORD
EXTRN	_lines:DWORD
EXTRN	_sides:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@403f6a7a2955385e
CONST	SEGMENT
__real@403f6a7a2955385e DQ 0403f6a7a2955385er	; 31.4159
CONST	ENDS
;	COMDAT __real@401921fb54442d18
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@3fa015bf9217271a
CONST	SEGMENT
__real@3fa015bf9217271a DQ 03fa015bf9217271ar	; 0.0314159
CONST	ENDS
;	COMDAT ??_C@_07IDPDJOKH@REDWALL@
CONST	SEGMENT
??_C@_07IDPDJOKH@REDWALL@ DB 'REDWALL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BBCGPKOB@Out?5of?5memory?5error?5in?5generate@
CONST	SEGMENT
??_C@_0CL@BBCGPKOB@Out?5of?5memory?5error?5in?5generate@ DB 'Out of memor'
	DB	'y error in generateStacklist()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LLOBDHMA@Out?5of?5memory?5in?5addLineToChain@
CONST	SEGMENT
??_C@_0CE@LLOBDHMA@Out?5of?5memory?5in?5addLineToChain@ DB 'Out of memory'
	DB	' in addLineToChain(.)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	011cH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _estimateFloorHeight
_TEXT	SEGMENT
_adjSector$ = -4					; size = 4
_thisSector$ = 8					; size = 4
_estimateFloorHeight PROC				; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 738  : 	sector_t *adjSector;
; 739  : 
; 740  : 	if (!thisSector ||
; 741  : 	 !thisSector->sectorLines ||

  00009	83 7d 08 00	 cmp	 DWORD PTR _thisSector$[ebp], 0
  0000d	74 1a		 je	 SHORT $LN3@estimateFl
  0000f	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00012	83 b8 c8 00 00
	00 00		 cmp	 DWORD PTR [eax+200], 0
  00019	74 0e		 je	 SHORT $LN3@estimateFl
  0001b	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  0001e	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00024	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00027	75 04		 jne	 SHORT $LN2@estimateFl
$LN3@estimateFl:

; 742  : 	  !thisSector->sectorLines->line)
; 743  : 	return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 39		 jmp	 SHORT $LN1@estimateFl
$LN2@estimateFl:

; 744  : 
; 745  : 	adjSector = thisSector->sectorLines->line->frontsector;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00030	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0003b	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax

; 746  : 	if (adjSector == thisSector)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _adjSector$[ebp]
  00041	3b 45 08	 cmp	 eax, DWORD PTR _thisSector$[ebp]
  00044	75 11		 jne	 SHORT $LN4@estimateFl

; 747  : 	adjSector = thisSector->sectorLines->line->backsector;

  00046	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00049	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00054	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax
$LN4@estimateFl:

; 748  : 
; 749  : 	if (NULL == adjSector)

  00057	83 7d fc 00	 cmp	 DWORD PTR _adjSector$[ebp], 0
  0005b	75 04		 jne	 SHORT $LN5@estimateFl

; 750  : 	return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 05		 jmp	 SHORT $LN1@estimateFl
$LN5@estimateFl:

; 751  : 
; 752  : 	return adjSector->floorheight;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _adjSector$[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@estimateFl:

; 753  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_estimateFloorHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _estimateCeilHeight
_TEXT	SEGMENT
_adjSector$ = -4					; size = 4
_thisSector$ = 8					; size = 4
_estimateCeilHeight PROC				; COMDAT

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 716  : 	sector_t *adjSector;
; 717  : 
; 718  : 	if (!thisSector ||
; 719  : 	 !thisSector->sectorLines ||

  00009	83 7d 08 00	 cmp	 DWORD PTR _thisSector$[ebp], 0
  0000d	74 1a		 je	 SHORT $LN3@estimateCe
  0000f	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00012	83 b8 c8 00 00
	00 00		 cmp	 DWORD PTR [eax+200], 0
  00019	74 0e		 je	 SHORT $LN3@estimateCe
  0001b	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  0001e	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00024	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00027	75 04		 jne	 SHORT $LN2@estimateCe
$LN3@estimateCe:

; 720  : 	  !thisSector->sectorLines->line)
; 721  : 		return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 3a		 jmp	 SHORT $LN1@estimateCe
$LN2@estimateCe:

; 722  : 
; 723  : 	adjSector = thisSector->sectorLines->line->frontsector;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00030	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0003b	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax

; 724  : 	if (adjSector == thisSector)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _adjSector$[ebp]
  00041	3b 45 08	 cmp	 eax, DWORD PTR _thisSector$[ebp]
  00044	75 11		 jne	 SHORT $LN4@estimateCe

; 725  : 	adjSector = thisSector->sectorLines->line->backsector;

  00046	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00049	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00054	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax
$LN4@estimateCe:

; 726  : 
; 727  : 	if (!adjSector)

  00057	83 7d fc 00	 cmp	 DWORD PTR _adjSector$[ebp], 0
  0005b	75 04		 jne	 SHORT $LN5@estimateCe

; 728  : 		return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 06		 jmp	 SHORT $LN1@estimateCe
$LN5@estimateCe:

; 729  : 
; 730  : 	return adjSector->ceilingheight;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _adjSector$[ebp]
  00064	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
$LN1@estimateCe:

; 731  : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_estimateCeilHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _isFloorFloating
_TEXT	SEGMENT
_nextElem$ = -28					; size = 4
_thisElem$ = -24					; size = 4
_floating$ = -20					; size = 4
_backSector$ = -16					; size = 4
_frontSector$ = -12					; size = 4
_refSector$ = -8					; size = 4
_adjSector$ = -4					; size = 4
_thisSector$ = 8					; size = 4
_isFloorFloating PROC					; COMDAT

; 656  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 657  : 	sector_t *adjSector, *refSector = NULL, *frontSector, *backSector;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _refSector$[ebp], 0

; 658  : 	boolean floating = true;

  00010	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 1

; 659  : 	linechain_t *thisElem, *nextElem;
; 660  : 
; 661  : 	if (!thisSector)

  00017	83 7d 08 00	 cmp	 DWORD PTR _thisSector$[ebp], 0
  0001b	75 07		 jne	 SHORT $LN4@isFloorFlo

; 662  : 		return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 a9 00 00 00	 jmp	 $LN1@isFloorFlo
$LN4@isFloorFlo:

; 663  : 
; 664  : 	nextElem  = thisSector->sectorLines;

  00024	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00027	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0002d	89 4d e4	 mov	 DWORD PTR _nextElem$[ebp], ecx
$LN14@isFloorFlo:

; 665  : 
; 666  : 	while (nextElem) // walk through chain

  00030	83 7d e4 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  00034	74 77		 je	 SHORT $LN3@isFloorFlo

; 667  : 	{
; 668  : 		thisElem = nextElem;

  00036	8b 45 e4	 mov	 eax, DWORD PTR _nextElem$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR _thisElem$[ebp], eax

; 669  : 		nextElem = thisElem->next;

  0003c	8b 45 e8	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	89 4d e4	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 670  : 
; 671  : 		frontSector = thisElem->line->frontsector;

  00045	8b 45 e8	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0004d	89 55 f4	 mov	 DWORD PTR _frontSector$[ebp], edx

; 672  : 		backSector  = thisElem->line->backsector;

  00050	8b 45 e8	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00058	89 55 f0	 mov	 DWORD PTR _backSector$[ebp], edx

; 673  : 
; 674  : 		if (frontSector == thisSector)

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _frontSector$[ebp]
  0005e	3b 45 08	 cmp	 eax, DWORD PTR _thisSector$[ebp]
  00061	75 08		 jne	 SHORT $LN5@isFloorFlo

; 675  : 			adjSector = backSector;

  00063	8b 45 f0	 mov	 eax, DWORD PTR _backSector$[ebp]
  00066	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax
  00069	eb 06		 jmp	 SHORT $LN6@isFloorFlo
$LN5@isFloorFlo:

; 676  : 		else
; 677  : 			adjSector = frontSector;

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _frontSector$[ebp]
  0006e	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax
$LN6@isFloorFlo:

; 678  : 
; 679  : 		if (NULL == adjSector) // assume floating sectors have surrounding sectors

  00071	83 7d fc 00	 cmp	 DWORD PTR _adjSector$[ebp], 0
  00075	75 09		 jne	 SHORT $LN7@isFloorFlo

; 680  : 		{
; 681  : 			floating = false;

  00077	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 0

; 682  : 			break;

  0007e	eb 2d		 jmp	 SHORT $LN3@isFloorFlo
$LN7@isFloorFlo:

; 683  : 		}
; 684  : 
; 685  : 		if (NULL == refSector)

  00080	83 7d f8 00	 cmp	 DWORD PTR _refSector$[ebp], 0
  00084	75 08		 jne	 SHORT $LN8@isFloorFlo

; 686  : 		{
; 687  : 			refSector = adjSector;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _adjSector$[ebp]
  00089	89 45 f8	 mov	 DWORD PTR _refSector$[ebp], eax

; 688  : 			continue;

  0008c	eb a2		 jmp	 SHORT $LN14@isFloorFlo
$LN8@isFloorFlo:

; 689  : 		}
; 690  : 
; 691  : 		// if adjacent sector has same height or more than one adjacent sector exists -> stop
; 692  : 		if (thisSector->floorheight == adjSector->floorheight ||

  0008e	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _adjSector$[ebp]
  00094	8b 10		 mov	 edx, DWORD PTR [eax]
  00096	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00098	74 08		 je	 SHORT $LN10@isFloorFlo
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _refSector$[ebp]
  0009d	3b 45 fc	 cmp	 eax, DWORD PTR _adjSector$[ebp]
  000a0	74 09		 je	 SHORT $LN9@isFloorFlo
$LN10@isFloorFlo:

; 693  : 		   refSector != adjSector)
; 694  : 		{
; 695  : 			floating = false;

  000a2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 0

; 696  : 			break;

  000a9	eb 02		 jmp	 SHORT $LN3@isFloorFlo
$LN9@isFloorFlo:

; 697  : 		}
; 698  : 	}

  000ab	eb 83		 jmp	 SHORT $LN14@isFloorFlo
$LN3@isFloorFlo:

; 699  : 
; 700  : 	// now check for walltextures
; 701  : 	if (floating)

  000ad	83 7d ec 00	 cmp	 DWORD PTR _floating$[ebp], 0
  000b1	74 17		 je	 SHORT $LN12@isFloorFlo

; 702  : 	{
; 703  : 		if (!areBottomtexturesMissing(thisSector))

  000b3	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _areBottomtexturesMissing
  000bc	83 c4 04	 add	 esp, 4
  000bf	85 c0		 test	 eax, eax
  000c1	75 07		 jne	 SHORT $LN12@isFloorFlo

; 704  : 		{
; 705  : 			floating = false;

  000c3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 0
$LN12@isFloorFlo:

; 706  : 		}
; 707  : 	}
; 708  : 	return floating;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _floating$[ebp]
$LN1@isFloorFlo:

; 709  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
_isFloorFloating ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _isCeilingFloating
_TEXT	SEGMENT
_nextElem$ = -28					; size = 4
_thisElem$ = -24					; size = 4
_floating$ = -20					; size = 4
_backSector$ = -16					; size = 4
_frontSector$ = -12					; size = 4
_refSector$ = -8					; size = 4
_adjSector$ = -4					; size = 4
_thisSector$ = 8					; size = 4
_isCeilingFloating PROC					; COMDAT

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 597  : 	sector_t *adjSector, *refSector = NULL, *frontSector, *backSector;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _refSector$[ebp], 0

; 598  : 	boolean floating = true;

  00010	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 1

; 599  : 	linechain_t *thisElem, *nextElem;
; 600  : 
; 601  : 	if (!thisSector)

  00017	83 7d 08 00	 cmp	 DWORD PTR _thisSector$[ebp], 0
  0001b	75 07		 jne	 SHORT $LN4@isCeilingF

; 602  : 		return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 ab 00 00 00	 jmp	 $LN1@isCeilingF
$LN4@isCeilingF:

; 603  : 
; 604  : 	nextElem  = thisSector->sectorLines;

  00024	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00027	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0002d	89 4d e4	 mov	 DWORD PTR _nextElem$[ebp], ecx
$LN14@isCeilingF:

; 605  : 
; 606  : 	while (NULL != nextElem) // walk through chain

  00030	83 7d e4 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  00034	74 79		 je	 SHORT $LN3@isCeilingF

; 607  : 	{
; 608  : 		thisElem = nextElem;

  00036	8b 45 e4	 mov	 eax, DWORD PTR _nextElem$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR _thisElem$[ebp], eax

; 609  : 		nextElem = thisElem->next;

  0003c	8b 45 e8	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	89 4d e4	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 610  : 
; 611  : 		frontSector = thisElem->line->frontsector;

  00045	8b 45 e8	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0004d	89 55 f4	 mov	 DWORD PTR _frontSector$[ebp], edx

; 612  : 		backSector  = thisElem->line->backsector;

  00050	8b 45 e8	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00058	89 55 f0	 mov	 DWORD PTR _backSector$[ebp], edx

; 613  : 
; 614  : 		if (frontSector == thisSector)

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _frontSector$[ebp]
  0005e	3b 45 08	 cmp	 eax, DWORD PTR _thisSector$[ebp]
  00061	75 08		 jne	 SHORT $LN5@isCeilingF

; 615  : 			adjSector = backSector;

  00063	8b 45 f0	 mov	 eax, DWORD PTR _backSector$[ebp]
  00066	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax
  00069	eb 06		 jmp	 SHORT $LN6@isCeilingF
$LN5@isCeilingF:

; 616  : 		else
; 617  : 			adjSector = frontSector;

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _frontSector$[ebp]
  0006e	89 45 fc	 mov	 DWORD PTR _adjSector$[ebp], eax
$LN6@isCeilingF:

; 618  : 
; 619  : 		if (!adjSector) // assume floating sectors have surrounding sectors

  00071	83 7d fc 00	 cmp	 DWORD PTR _adjSector$[ebp], 0
  00075	75 09		 jne	 SHORT $LN7@isCeilingF

; 620  : 		{
; 621  : 			floating = false;

  00077	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 0

; 622  : 			break;

  0007e	eb 2f		 jmp	 SHORT $LN3@isCeilingF
$LN7@isCeilingF:

; 623  : 		}
; 624  : 
; 625  : 		if (!refSector)

  00080	83 7d f8 00	 cmp	 DWORD PTR _refSector$[ebp], 0
  00084	75 08		 jne	 SHORT $LN8@isCeilingF

; 626  : 		{
; 627  : 			refSector = adjSector;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _adjSector$[ebp]
  00089	89 45 f8	 mov	 DWORD PTR _refSector$[ebp], eax

; 628  : 			continue;

  0008c	eb a2		 jmp	 SHORT $LN14@isCeilingF
$LN8@isCeilingF:

; 629  : 		}
; 630  : 
; 631  : 		// if adjacent sector has same height or more than one adjacent sector exists -> stop
; 632  : 		if (thisSector->ceilingheight == adjSector->ceilingheight ||

  0008e	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _adjSector$[ebp]
  00094	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00097	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0009a	74 08		 je	 SHORT $LN10@isCeilingF
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _refSector$[ebp]
  0009f	3b 45 fc	 cmp	 eax, DWORD PTR _adjSector$[ebp]
  000a2	74 09		 je	 SHORT $LN9@isCeilingF
$LN10@isCeilingF:

; 633  : 		   refSector != adjSector)
; 634  : 		{
; 635  : 			floating = false;

  000a4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 0

; 636  : 			break;

  000ab	eb 02		 jmp	 SHORT $LN3@isCeilingF
$LN9@isCeilingF:

; 637  : 		}
; 638  : 	}

  000ad	eb 81		 jmp	 SHORT $LN14@isCeilingF
$LN3@isCeilingF:

; 639  : 
; 640  : 	// now check for walltextures
; 641  : 	if (floating)

  000af	83 7d ec 00	 cmp	 DWORD PTR _floating$[ebp], 0
  000b3	74 17		 je	 SHORT $LN12@isCeilingF

; 642  : 	{
; 643  : 		if (!areToptexturesMissing(thisSector))

  000b5	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _areToptexturesMissing
  000be	83 c4 04	 add	 esp, 4
  000c1	85 c0		 test	 eax, eax
  000c3	75 07		 jne	 SHORT $LN12@isCeilingF

; 644  : 		{
; 645  : 			floating = false;

  000c5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floating$[ebp], 0
$LN12@isCeilingF:

; 646  : 		}
; 647  : 	}
; 648  : 	return floating;

  000cc	8b 45 ec	 mov	 eax, DWORD PTR _floating$[ebp]
$LN1@isCeilingF:

; 649  : }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_isCeilingFloating ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _areBottomtexturesMissing
_TEXT	SEGMENT
tv133 = -96						; size = 4
_sdr$ = -28						; size = 4
_sdl$ = -24						; size = 4
_nomiss$ = -20						; size = 4
_backSector$ = -16					; size = 4
_frontSector$ = -12					; size = 4
_nextElem$ = -8						; size = 4
_thisElem$ = -4						; size = 4
_thisSector$ = 8					; size = 4
_areBottomtexturesMissing PROC				; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 544  : 	linechain_t *thisElem, *nextElem = thisSector->sectorLines;

  00009	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  0000c	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00012	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 545  : 	sector_t *frontSector, *backSector;
; 546  : 	size_t nomiss = 0;

  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nomiss$[ebp], 0
$LN16@areBottomt:

; 547  : 	side_t *sdl, *sdr;
; 548  : 
; 549  : 	while (nextElem) // walk through chain

  0001c	83 7d f8 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  00020	0f 84 c0 00 00
	00		 je	 $LN3@areBottomt

; 550  : 	{
; 551  : 		thisElem = nextElem;

  00026	8b 45 f8	 mov	 eax, DWORD PTR _nextElem$[ebp]
  00029	89 45 fc	 mov	 DWORD PTR _thisElem$[ebp], eax

; 552  : 		nextElem = thisElem->next;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 553  : 
; 554  : 		frontSector = thisElem->line->frontsector;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0003d	89 55 f4	 mov	 DWORD PTR _frontSector$[ebp], edx

; 555  : 		backSector  = thisElem->line->backsector;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00048	89 55 f0	 mov	 DWORD PTR _backSector$[ebp], edx

; 556  : 
; 557  : 		if (frontSector == backSector) // skip damn renderer tricks here

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _frontSector$[ebp]
  0004e	3b 45 f0	 cmp	 eax, DWORD PTR _backSector$[ebp]
  00051	75 02		 jne	 SHORT $LN4@areBottomt

; 558  : 		{
; 559  : 			continue;

  00053	eb c7		 jmp	 SHORT $LN16@areBottomt
$LN4@areBottomt:

; 560  : 		}
; 561  : 
; 562  : 		if (frontSector == NULL || backSector == NULL)

  00055	83 7d f4 00	 cmp	 DWORD PTR _frontSector$[ebp], 0
  00059	74 06		 je	 SHORT $LN6@areBottomt
  0005b	83 7d f0 00	 cmp	 DWORD PTR _backSector$[ebp], 0
  0005f	75 02		 jne	 SHORT $LN5@areBottomt
$LN6@areBottomt:

; 563  : 		{
; 564  : 			continue;

  00061	eb b9		 jmp	 SHORT $LN16@areBottomt
$LN5@areBottomt:

; 565  : 		}
; 566  : 		sdr = &sides[thisElem->line->sidenum[0]];

  00063	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	ba 02 00 00 00	 mov	 edx, 2
  0006d	6b c2 00	 imul	 eax, edx, 0
  00070	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  00075	6b d1 1c	 imul	 edx, ecx, 28
  00078	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sides
  0007e	89 55 e4	 mov	 DWORD PTR _sdr$[ebp], edx

; 567  : 		sdl = &sides[thisElem->line->sidenum[1]];

  00081	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	ba 02 00 00 00	 mov	 edx, 2
  0008b	c1 e2 00	 shl	 edx, 0
  0008e	0f b7 44 11 16	 movzx	 eax, WORD PTR [ecx+edx+22]
  00093	6b c8 1c	 imul	 ecx, eax, 28
  00096	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  0009c	89 4d e8	 mov	 DWORD PTR _sdl$[ebp], ecx

; 568  : 
; 569  : 		if (backSector->floorheight > frontSector->floorheight)

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _backSector$[ebp]
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _frontSector$[ebp]
  000a5	8b 10		 mov	 edx, DWORD PTR [eax]
  000a7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000a9	7e 16		 jle	 SHORT $LN7@areBottomt

; 570  : 		{
; 571  : 			if (sdr->bottomtexture != 0)

  000ab	8b 45 e4	 mov	 eax, DWORD PTR _sdr$[ebp]
  000ae	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000b2	74 0b		 je	 SHORT $LN9@areBottomt

; 572  : 			{
; 573  : 				nomiss++;

  000b4	8b 45 ec	 mov	 eax, DWORD PTR _nomiss$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	89 45 ec	 mov	 DWORD PTR _nomiss$[ebp], eax

; 574  : 				break; // we can stop here if decision criterium is ==0

  000bd	eb 27		 jmp	 SHORT $LN3@areBottomt
$LN9@areBottomt:

; 575  : 			}
; 576  : 		}

  000bf	eb 20		 jmp	 SHORT $LN11@areBottomt
$LN7@areBottomt:

; 577  : 
; 578  : 		else if (backSector->floorheight < frontSector->floorheight)

  000c1	8b 45 f0	 mov	 eax, DWORD PTR _backSector$[ebp]
  000c4	8b 4d f4	 mov	 ecx, DWORD PTR _frontSector$[ebp]
  000c7	8b 10		 mov	 edx, DWORD PTR [eax]
  000c9	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000cb	7d 14		 jge	 SHORT $LN11@areBottomt

; 579  : 		{
; 580  : 			if (sdl->bottomtexture != 0)

  000cd	8b 45 e8	 mov	 eax, DWORD PTR _sdl$[ebp]
  000d0	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000d4	74 0b		 je	 SHORT $LN11@areBottomt

; 581  : 			{
; 582  : 				nomiss++;

  000d6	8b 45 ec	 mov	 eax, DWORD PTR _nomiss$[ebp]
  000d9	83 c0 01	 add	 eax, 1
  000dc	89 45 ec	 mov	 DWORD PTR _nomiss$[ebp], eax

; 583  : 				break; // we can stop here if decision criterium is ==0

  000df	eb 05		 jmp	 SHORT $LN3@areBottomt
$LN11@areBottomt:

; 584  : 			}
; 585  : 		}
; 586  : 	}

  000e1	e9 36 ff ff ff	 jmp	 $LN16@areBottomt
$LN3@areBottomt:

; 587  : 
; 588  : 	//    return missing >= nomiss;
; 589  : 	return nomiss == 0;

  000e6	83 7d ec 00	 cmp	 DWORD PTR _nomiss$[ebp], 0
  000ea	75 09		 jne	 SHORT $LN13@areBottomt
  000ec	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
  000f3	eb 07		 jmp	 SHORT $LN14@areBottomt
$LN13@areBottomt:
  000f5	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN14@areBottomt:
  000fc	8b 45 a0	 mov	 eax, DWORD PTR tv133[ebp]

; 590  : }

  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
_areBottomtexturesMissing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _areToptexturesMissing
_TEXT	SEGMENT
tv133 = -96						; size = 4
_sdr$ = -28						; size = 4
_sdl$ = -24						; size = 4
_nomiss$ = -20						; size = 4
_backSector$ = -16					; size = 4
_frontSector$ = -12					; size = 4
_nextElem$ = -8						; size = 4
_thisElem$ = -4						; size = 4
_thisSector$ = 8					; size = 4
_areToptexturesMissing PROC				; COMDAT

; 491  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 492  : 	linechain_t *thisElem, *nextElem = thisSector->sectorLines;

  00009	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  0000c	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00012	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 493  : 	sector_t *frontSector, *backSector;
; 494  : 	size_t nomiss = 0;

  00015	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nomiss$[ebp], 0
$LN16@areToptext:

; 495  : 	side_t *sdl, *sdr;
; 496  : 
; 497  : 	while (nextElem) // walk through chain

  0001c	83 7d f8 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  00020	0f 84 c4 00 00
	00		 je	 $LN3@areToptext

; 498  : 	{
; 499  : 		thisElem = nextElem;

  00026	8b 45 f8	 mov	 eax, DWORD PTR _nextElem$[ebp]
  00029	89 45 fc	 mov	 DWORD PTR _thisElem$[ebp], eax

; 500  : 		nextElem = thisElem->next;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 501  : 
; 502  : 		frontSector = thisElem->line->frontsector;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0003d	89 55 f4	 mov	 DWORD PTR _frontSector$[ebp], edx

; 503  : 		backSector  = thisElem->line->backsector;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00048	89 55 f0	 mov	 DWORD PTR _backSector$[ebp], edx

; 504  : 
; 505  : 		if (frontSector == backSector) // skip damn renderer tricks here

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _frontSector$[ebp]
  0004e	3b 45 f0	 cmp	 eax, DWORD PTR _backSector$[ebp]
  00051	75 02		 jne	 SHORT $LN4@areToptext

; 506  : 		{
; 507  : 			continue;

  00053	eb c7		 jmp	 SHORT $LN16@areToptext
$LN4@areToptext:

; 508  : 		}
; 509  : 
; 510  : 		if (!frontSector || !backSector)

  00055	83 7d f4 00	 cmp	 DWORD PTR _frontSector$[ebp], 0
  00059	74 06		 je	 SHORT $LN6@areToptext
  0005b	83 7d f0 00	 cmp	 DWORD PTR _backSector$[ebp], 0
  0005f	75 02		 jne	 SHORT $LN5@areToptext
$LN6@areToptext:

; 511  : 		{
; 512  : 			continue;

  00061	eb b9		 jmp	 SHORT $LN16@areToptext
$LN5@areToptext:

; 513  : 		}
; 514  : 
; 515  : 		sdr = &sides[thisElem->line->sidenum[0]];

  00063	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	ba 02 00 00 00	 mov	 edx, 2
  0006d	6b c2 00	 imul	 eax, edx, 0
  00070	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  00075	6b d1 1c	 imul	 edx, ecx, 28
  00078	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sides
  0007e	89 55 e4	 mov	 DWORD PTR _sdr$[ebp], edx

; 516  : 		sdl = &sides[thisElem->line->sidenum[1]];

  00081	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	ba 02 00 00 00	 mov	 edx, 2
  0008b	c1 e2 00	 shl	 edx, 0
  0008e	0f b7 44 11 16	 movzx	 eax, WORD PTR [ecx+edx+22]
  00093	6b c8 1c	 imul	 ecx, eax, 28
  00096	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  0009c	89 4d e8	 mov	 DWORD PTR _sdl$[ebp], ecx

; 517  : 
; 518  : 		if (backSector->ceilingheight < frontSector->ceilingheight)

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _backSector$[ebp]
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _frontSector$[ebp]
  000a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a8	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000ab	7d 16		 jge	 SHORT $LN7@areToptext

; 519  : 		{
; 520  : 			if (sdr->toptexture != 0)

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _sdr$[ebp]
  000b0	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000b4	74 0b		 je	 SHORT $LN9@areToptext

; 521  : 			{
; 522  : 				nomiss++;

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _nomiss$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 ec	 mov	 DWORD PTR _nomiss$[ebp], eax

; 523  : 				break; // we can stop here if decision criterium is ==0

  000bf	eb 29		 jmp	 SHORT $LN3@areToptext
$LN9@areToptext:

; 524  : 			}
; 525  : 		}

  000c1	eb 22		 jmp	 SHORT $LN11@areToptext
$LN7@areToptext:

; 526  : 		else if (backSector->ceilingheight > frontSector->ceilingheight)

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _backSector$[ebp]
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _frontSector$[ebp]
  000c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000cc	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000cf	7e 14		 jle	 SHORT $LN11@areToptext

; 527  : 		{
; 528  : 			if (sdl->toptexture != 0)

  000d1	8b 45 e8	 mov	 eax, DWORD PTR _sdl$[ebp]
  000d4	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000d8	74 0b		 je	 SHORT $LN11@areToptext

; 529  : 			{
; 530  : 				nomiss++;

  000da	8b 45 ec	 mov	 eax, DWORD PTR _nomiss$[ebp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 45 ec	 mov	 DWORD PTR _nomiss$[ebp], eax

; 531  : 				break; // we can stop here if decision criterium is ==0

  000e3	eb 05		 jmp	 SHORT $LN3@areToptext
$LN11@areToptext:

; 532  : 			}
; 533  : 		}
; 534  : 	}

  000e5	e9 32 ff ff ff	 jmp	 $LN16@areToptext
$LN3@areToptext:

; 535  : 
; 536  : 	return nomiss == 0;

  000ea	83 7d ec 00	 cmp	 DWORD PTR _nomiss$[ebp], 0
  000ee	75 09		 jne	 SHORT $LN13@areToptext
  000f0	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
  000f7	eb 07		 jmp	 SHORT $LN14@areToptext
$LN13@areToptext:
  000f9	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN14@areToptext:
  00100	8b 45 a0	 mov	 eax, DWORD PTR tv133[ebp]

; 537  : }

  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
_areToptexturesMissing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _freeStacklists
_TEXT	SEGMENT
_i$ = -4						; size = 4
_freeStacklists PROC					; COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 475  : 	size_t i;
; 476  : 
; 477  : 	for (i = 0; i < numsectors; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@freeStackl
$LN2@freeStackl:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@freeStackl:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00024	73 4e		 jae	 SHORT $LN3@freeStackl

; 478  : 	{
; 479  : 		if (sectors[i].stackList)

  00026	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00033	83 bc 01 cc 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax+204], 0
  0003b	74 35		 je	 SHORT $LN5@freeStackl

; 480  : 		{
; 481  : 			free(sectors[i].stackList);

  0003d	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0004a	8b 94 01 cc 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+204]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 _free
  00057	83 c4 04	 add	 esp, 4

; 482  : 			sectors[i].stackList = NULL;

  0005a	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00067	c7 84 01 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+204], 0
$LN5@freeStackl:

; 483  : 		}
; 484  : 	}

  00072	eb 9e		 jmp	 SHORT $LN2@freeStackl
$LN3@freeStackl:

; 485  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_freeStacklists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _calcLineouts
_TEXT	SEGMENT
_encSector$ = -8					; size = 4
_secCount$ = -4						; size = 4
_sector$ = 8						; size = 4
_calcLineouts PROC					; COMDAT

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 455  : 	size_t secCount = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _secCount$[ebp], 0

; 456  : 	sector_t *encSector = *(sector->stackList);

  00010	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00013	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	89 55 f8	 mov	 DWORD PTR _encSector$[ebp], edx
$LN2@calcLineou:

; 457  : 
; 458  : 	while (NULL != encSector)

  0001e	83 7d f8 00	 cmp	 DWORD PTR _encSector$[ebp], 0
  00022	74 42		 je	 SHORT $LN3@calcLineou

; 459  : 	{
; 460  : 		if (encSector->lineoutLength < 0.0) // if length has not yet been calculated

  00024	8b 45 f8	 mov	 eax, DWORD PTR _encSector$[ebp]
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	66 0f 2f 80 d0
	00 00 00	 comisd	 xmm0, QWORD PTR [eax+208]
  00032	76 15		 jbe	 SHORT $LN4@calcLineou

; 461  : 		{
; 462  : 			encSector->lineoutLength = calcLineoutLength(encSector);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _encSector$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _calcLineoutLength
  0003d	83 c4 04	 add	 esp, 4
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _encSector$[ebp]
  00043	dd 99 d0 00 00
	00		 fstp	 QWORD PTR [ecx+208]
$LN4@calcLineou:

; 463  : 		}
; 464  : 
; 465  : 		secCount++;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _secCount$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 fc	 mov	 DWORD PTR _secCount$[ebp], eax

; 466  : 		encSector = *((sector->stackList) + secCount);

  00052	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00055	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  0005b	8b 55 fc	 mov	 edx, DWORD PTR _secCount$[ebp]
  0005e	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00061	89 45 f8	 mov	 DWORD PTR _encSector$[ebp], eax

; 467  : 	}

  00064	eb b8		 jmp	 SHORT $LN2@calcLineou
$LN3@calcLineou:

; 468  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_calcLineouts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _calcLineoutLength
_TEXT	SEGMENT
tv79 = -84						; size = 8
_length$ = -12						; size = 8
_chain$ = -4						; size = 4
_sector$ = 8						; size = 4
_calcLineoutLength PROC					; COMDAT

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 436  : 	linechain_t *chain;
; 437  : 	double length;
; 438  : 
; 439  : 	length = 0.0;

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	f2 0f 11 45 f4	 movsd	 QWORD PTR _length$[ebp], xmm0

; 440  : 	chain = sector->sectorLines;

  00011	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00014	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0001a	89 4d fc	 mov	 DWORD PTR _chain$[ebp], ecx
$LN2@calcLineou:

; 441  : 
; 442  : 	while (NULL != chain) // sum up lengths of all lines

  0001d	83 7d fc 00	 cmp	 DWORD PTR _chain$[ebp], 0
  00021	74 2b		 je	 SHORT $LN3@calcLineou

; 443  : 	{
; 444  : 		length += lineLength(chain->line);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _chain$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _lineLength
  0002e	83 c4 04	 add	 esp, 4
  00031	dd 5d ac	 fstp	 QWORD PTR tv79[ebp]
  00034	f2 0f 10 45 ac	 movsd	 xmm0, QWORD PTR tv79[ebp]
  00039	f2 0f 58 45 f4	 addsd	 xmm0, QWORD PTR _length$[ebp]
  0003e	f2 0f 11 45 f4	 movsd	 QWORD PTR _length$[ebp], xmm0

; 445  : 		chain = chain->next;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _chain$[ebp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	89 4d fc	 mov	 DWORD PTR _chain$[ebp], ecx

; 446  : 	}

  0004c	eb cf		 jmp	 SHORT $LN2@calcLineou
$LN3@calcLineou:

; 447  : 	return length;

  0004e	dd 45 f4	 fld	 QWORD PTR _length$[ebp]

; 448  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_calcLineoutLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _lineLength
_TEXT	SEGMENT
_length$ = -24						; size = 8
_dy$ = -16						; size = 8
_dx$ = -8						; size = 8
_line$ = 8						; size = 4
_lineLength PROC					; COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 420  : 	double dx, dy, length;
; 421  : 
; 422  : 	dx = (double) line->v1->x - (double) line->v2->x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	f2 0f 2a 01	 cvtsi2sd xmm0, DWORD PTR [ecx]
  00012	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00015	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00018	f2 0f 2a 08	 cvtsi2sd xmm1, DWORD PTR [eax]
  0001c	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00020	f2 0f 11 45 f8	 movsd	 QWORD PTR _dx$[ebp], xmm0

; 423  : 	dy = (double) line->v1->y - (double) line->v2->y;

  00025	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	f2 0f 2a 41 04	 cvtsi2sd xmm0, DWORD PTR [ecx+4]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	f2 0f 2a 48 04	 cvtsi2sd xmm1, DWORD PTR [eax+4]
  0003a	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0003e	f2 0f 11 45 f0	 movsd	 QWORD PTR _dy$[ebp], xmm0

; 424  : 
; 425  : 	length = hypot(dx, dy);

  00043	83 ec 08	 sub	 esp, 8
  00046	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _dy$[ebp]
  0004b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00050	83 ec 08	 sub	 esp, 8
  00053	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _dx$[ebp]
  00058	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0005d	e8 00 00 00 00	 call	 _hypot
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	dd 5d e8	 fstp	 QWORD PTR _length$[ebp]

; 426  : 
; 427  : 	return length;

  00068	dd 45 e8	 fld	 QWORD PTR _length$[ebp]

; 428  : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_lineLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _sortStacklist
_TEXT	SEGMENT
_i$ = -20						; size = 4
_finished$ = -16					; size = 4
_sec2$ = -12						; size = 4
_sec1$ = -8						; size = 4
_list$ = -4						; size = 4
_sector$ = 8						; size = 4
_sortStacklist PROC					; COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 383  : 	sector_t **list;
; 384  : 	sector_t *sec1, *sec2;
; 385  : 	boolean finished;
; 386  : 	size_t i;
; 387  : 
; 388  : 	list = sector->stackList;

  00009	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0000c	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00012	89 4d fc	 mov	 DWORD PTR _list$[ebp], ecx

; 389  : 	finished = false;

  00015	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 0

; 390  : 
; 391  : 	if (!*list)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _list$[ebp]
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	75 02		 jne	 SHORT $LN6@sortStackl

; 392  : 		return; // nothing to sort

  00024	eb 7f		 jmp	 SHORT $LN3@sortStackl
$LN6@sortStackl:

; 393  : 
; 394  : 	while (!finished)

  00026	83 7d f0 00	 cmp	 DWORD PTR _finished$[ebp], 0
  0002a	75 79		 jne	 SHORT $LN3@sortStackl

; 395  : 	{
; 396  : 		i = 0;

  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 397  : 		finished = true;

  00033	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 1
$LN4@sortStackl:

; 398  : 
; 399  : 		while (NULL != *(list+i+1))

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _list$[ebp]
  00040	83 7c 81 04 00	 cmp	 DWORD PTR [ecx+eax*4+4], 0
  00045	74 5c		 je	 SHORT $LN5@sortStackl

; 400  : 		{
; 401  : 			sec1 = *(list+i);

  00047	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _list$[ebp]
  0004d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00050	89 55 f8	 mov	 DWORD PTR _sec1$[ebp], edx

; 402  : 			sec2 = *(list+i+1);

  00053	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _list$[ebp]
  00059	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  0005d	89 55 f4	 mov	 DWORD PTR _sec2$[ebp], edx

; 403  : 
; 404  : 			if (sec1->lineoutLength > sec2->lineoutLength)

  00060	8b 45 f8	 mov	 eax, DWORD PTR _sec1$[ebp]
  00063	8b 4d f4	 mov	 ecx, DWORD PTR _sec2$[ebp]
  00066	f2 0f 10 80 d0
	00 00 00	 movsd	 xmm0, QWORD PTR [eax+208]
  0006e	66 0f 2f 81 d0
	00 00 00	 comisd	 xmm0, QWORD PTR [ecx+208]
  00076	76 20		 jbe	 SHORT $LN7@sortStackl

; 405  : 			{
; 406  : 				*(list+i) = sec2;

  00078	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _list$[ebp]
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _sec2$[ebp]
  00081	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 407  : 				*(list+i+1) = sec1;

  00084	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _list$[ebp]
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _sec1$[ebp]
  0008d	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 408  : 				finished = false;

  00091	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 0
$LN7@sortStackl:

; 409  : 			}
; 410  : 			i++;

  00098	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0009b	83 c0 01	 add	 eax, 1
  0009e	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 411  : 		}

  000a1	eb 97		 jmp	 SHORT $LN4@sortStackl
$LN5@sortStackl:

; 412  : 	}

  000a3	eb 81		 jmp	 SHORT $LN6@sortStackl
$LN3@sortStackl:

; 413  : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_sortStacklist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _generateStacklist
_TEXT	SEGMENT
_checkSector$ = -1040					; size = 4
_locStacklist$ = -1036					; size = 1024
_stackCnt$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_thisSector$ = 8					; size = 4
_generateStacklist PROC					; COMDAT

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 04 00
	00		 sub	 esp, 1232		; 000004d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 340  : 	size_t i, stackCnt = 0;

  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _stackCnt$[ebp], 0

; 341  : 	sector_t *locStacklist[MAXSTACK];
; 342  : 	sector_t *checkSector;
; 343  : 
; 344  : 	for (i = 0; i < numsectors; i++)

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@generateSt
$LN2@generateSt:
  00026	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@generateSt:
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00032	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00038	73 78		 jae	 SHORT $LN3@generateSt

; 345  : 	{
; 346  : 		checkSector = &sectors[i];

  0003a	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00041	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00047	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _checkSector$[ebp], eax

; 347  : 
; 348  : 		if (checkSector == thisSector) // dont check self

  0004d	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _checkSector$[ebp]
  00053	3b 45 08	 cmp	 eax, DWORD PTR _thisSector$[ebp]
  00056	75 02		 jne	 SHORT $LN5@generateSt

; 349  : 			continue;

  00058	eb cc		 jmp	 SHORT $LN2@generateSt
$LN5@generateSt:

; 350  : 
; 351  : 		// buggy sector?
; 352  : 		if (!thisSector->sectorLines)

  0005a	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  0005d	83 b8 c8 00 00
	00 00		 cmp	 DWORD PTR [eax+200], 0
  00064	75 02		 jne	 SHORT $LN6@generateSt

; 353  : 			continue;

  00066	eb be		 jmp	 SHORT $LN2@generateSt
$LN6@generateSt:

; 354  : 
; 355  : 		// check if an arbitrary vertex of thisSector lies inside the checkSector
; 356  : 		if (isVertexInside(thisSector->sectorLines->line->v1, checkSector))

  00068	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _checkSector$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _thisSector$[ebp]
  00072	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00078	8b 02		 mov	 eax, DWORD PTR [edx]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _isVertexInside
  00082	83 c4 08	 add	 esp, 8
  00085	85 c0		 test	 eax, eax
  00087	74 24		 je	 SHORT $LN8@generateSt

; 357  : 		{
; 358  : 			// if so, the thisSector lies inside the checkSector
; 359  : 			locStacklist[stackCnt] = checkSector;

  00089	8b 45 f4	 mov	 eax, DWORD PTR _stackCnt$[ebp]
  0008c	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _checkSector$[ebp]
  00092	89 8c 85 f4 fb
	ff ff		 mov	 DWORD PTR _locStacklist$[ebp+eax*4], ecx

; 360  : 			stackCnt++;

  00099	8b 45 f4	 mov	 eax, DWORD PTR _stackCnt$[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 f4	 mov	 DWORD PTR _stackCnt$[ebp], eax

; 361  : 
; 362  : 			if (MAXSTACK-1 == stackCnt) // beware of the SIGSEGV! and consider terminating NULL!

  000a2	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _stackCnt$[ebp], 255 ; 000000ffH
  000a9	75 02		 jne	 SHORT $LN8@generateSt

; 363  : 				break;

  000ab	eb 05		 jmp	 SHORT $LN3@generateSt
$LN8@generateSt:

; 364  : 		}
; 365  : 	}

  000ad	e9 74 ff ff ff	 jmp	 $LN2@generateSt
$LN3@generateSt:

; 366  : 
; 367  : 	thisSector->stackList = malloc(sizeof (sector_t *) * (stackCnt+1));

  000b2	8b 45 f4	 mov	 eax, DWORD PTR _stackCnt$[ebp]
  000b5	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 _malloc
  000c2	83 c4 04	 add	 esp, 4
  000c5	8b 55 08	 mov	 edx, DWORD PTR _thisSector$[ebp]
  000c8	89 82 cc 00 00
	00		 mov	 DWORD PTR [edx+204], eax

; 368  : 	if (NULL == thisSector->stackList)

  000ce	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  000d1	83 b8 cc 00 00
	00 00		 cmp	 DWORD PTR [eax+204], 0
  000d8	75 0d		 jne	 SHORT $LN9@generateSt

; 369  : 	{
; 370  : 		I_Error("Out of memory error in generateStacklist()");

  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BBCGPKOB@Out?5of?5memory?5error?5in?5generate@
  000df	e8 00 00 00 00	 call	 _I_Error
  000e4	83 c4 04	 add	 esp, 4
$LN9@generateSt:

; 371  : 	}
; 372  : 
; 373  : 	locStacklist[stackCnt] = NULL; // terminating NULL

  000e7	8b 45 f4	 mov	 eax, DWORD PTR _stackCnt$[ebp]
  000ea	c7 84 85 f4 fb
	ff ff 00 00 00
	00		 mov	 DWORD PTR _locStacklist$[ebp+eax*4], 0

; 374  : 
; 375  : 	memcpy(thisSector->stackList, locStacklist, sizeof (sector_t *) * (stackCnt+1));

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _stackCnt$[ebp]
  000f8	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  000ff	51		 push	 ecx
  00100	8d 95 f4 fb ff
	ff		 lea	 edx, DWORD PTR _locStacklist$[ebp]
  00106	52		 push	 edx
  00107	8b 45 08	 mov	 eax, DWORD PTR _thisSector$[ebp]
  0010a	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _memcpy
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 376  : }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011f	33 cd		 xor	 ecx, ebp
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
_generateStacklist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _isVertexInside
_TEXT	SEGMENT
_phi2$ = -68						; size = 8
_phi1$ = -60						; size = 8
_phiMax$ = -52						; size = 8
_phiMin$ = -44						; size = 8
_chain$ = -36						; size = 4
_ye$ = -32						; size = 8
_xe$ = -24						; size = 8
_ya$ = -16						; size = 8
_xa$ = -8						; size = 8
_vertex$ = 8						; size = 4
_sector$ = 12						; size = 4
_isVertexInside PROC					; COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 304  : 	double xa, ya, xe, ye;
; 305  : 	linechain_t *chain;
; 306  : 	double phiMin, phiMax;
; 307  : 	double phi1, phi2;
; 308  : 
; 309  : 	chain = sector->sectorLines;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0000f	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00015	89 4d dc	 mov	 DWORD PTR _chain$[ebp], ecx

; 310  : 	phiMin = phiMax = 10.0l*M_PIl; // some value > \pi

  00018	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@403f6a7a2955385e
  00020	f2 0f 11 45 cc	 movsd	 QWORD PTR _phiMax$[ebp], xmm0
  00025	f2 0f 10 45 cc	 movsd	 xmm0, QWORD PTR _phiMax$[ebp]
  0002a	f2 0f 11 45 d4	 movsd	 QWORD PTR _phiMin$[ebp], xmm0
$LN2@isVertexIn:

; 311  : 
; 312  : 	while (chain)

  0002f	83 7d dc 00	 cmp	 DWORD PTR _chain$[ebp], 0
  00033	0f 84 f4 00 00
	00		 je	 $LN3@isVertexIn

; 313  : 	{
; 314  : 		// start and end vertex
; 315  : 		xa = (double)chain->line->v1->x - (double)vertex->x;

  00039	8b 45 dc	 mov	 eax, DWORD PTR _chain$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	f2 0f 2a 02	 cvtsi2sd xmm0, DWORD PTR [edx]
  00044	8b 45 08	 mov	 eax, DWORD PTR _vertex$[ebp]
  00047	f2 0f 2a 08	 cvtsi2sd xmm1, DWORD PTR [eax]
  0004b	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0004f	f2 0f 11 45 f8	 movsd	 QWORD PTR _xa$[ebp], xmm0

; 316  : 		ya = (double)chain->line->v1->y - (double)vertex->y;

  00054	8b 45 dc	 mov	 eax, DWORD PTR _chain$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	f2 0f 2a 42 04	 cvtsi2sd xmm0, DWORD PTR [edx+4]
  00060	8b 45 08	 mov	 eax, DWORD PTR _vertex$[ebp]
  00063	f2 0f 2a 48 04	 cvtsi2sd xmm1, DWORD PTR [eax+4]
  00068	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0006c	f2 0f 11 45 f0	 movsd	 QWORD PTR _ya$[ebp], xmm0

; 317  : 		xe = (double)chain->line->v2->x - (double)vertex->x;

  00071	8b 45 dc	 mov	 eax, DWORD PTR _chain$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00079	f2 0f 2a 02	 cvtsi2sd xmm0, DWORD PTR [edx]
  0007d	8b 45 08	 mov	 eax, DWORD PTR _vertex$[ebp]
  00080	f2 0f 2a 08	 cvtsi2sd xmm1, DWORD PTR [eax]
  00084	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00088	f2 0f 11 45 e8	 movsd	 QWORD PTR _xe$[ebp], xmm0

; 318  : 		ye = (double)chain->line->v2->y - (double)vertex->y;

  0008d	8b 45 dc	 mov	 eax, DWORD PTR _chain$[ebp]
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	f2 0f 2a 42 04	 cvtsi2sd xmm0, DWORD PTR [edx+4]
  0009a	8b 45 08	 mov	 eax, DWORD PTR _vertex$[ebp]
  0009d	f2 0f 2a 48 04	 cvtsi2sd xmm1, DWORD PTR [eax+4]
  000a2	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000a6	f2 0f 11 45 e0	 movsd	 QWORD PTR _ye$[ebp], xmm0

; 319  : 
; 320  : 		// angle phi of connection between the vertices and the x-axis
; 321  : 		phi1 = atan2(ya, xa);

  000ab	83 ec 08	 sub	 esp, 8
  000ae	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _xa$[ebp]
  000b3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000b8	83 ec 08	 sub	 esp, 8
  000bb	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _ya$[ebp]
  000c0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c5	e8 00 00 00 00	 call	 _atan2
  000ca	83 c4 10	 add	 esp, 16			; 00000010H
  000cd	dd 5d c4	 fstp	 QWORD PTR _phi1$[ebp]

; 322  : 		phi2 = atan2(ye, xe);

  000d0	83 ec 08	 sub	 esp, 8
  000d3	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _xe$[ebp]
  000d8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000dd	83 ec 08	 sub	 esp, 8
  000e0	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _ye$[ebp]
  000e5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ea	e8 00 00 00 00	 call	 _atan2
  000ef	83 c4 10	 add	 esp, 16			; 00000010H
  000f2	dd 5d bc	 fstp	 QWORD PTR _phi2$[ebp]

; 323  : 
; 324  : 		// if we have just started, we can have to create start bounds for phi
; 325  : 
; 326  : 		phiBounds(phi1, phi2, &phiMin, &phiMax);

  000f5	8d 45 cc	 lea	 eax, DWORD PTR _phiMax$[ebp]
  000f8	50		 push	 eax
  000f9	8d 4d d4	 lea	 ecx, DWORD PTR _phiMin$[ebp]
  000fc	51		 push	 ecx
  000fd	83 ec 08	 sub	 esp, 8
  00100	f2 0f 10 45 bc	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00105	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0010a	83 ec 08	 sub	 esp, 8
  0010d	f2 0f 10 45 c4	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00112	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00117	e8 00 00 00 00	 call	 _phiBounds
  0011c	83 c4 18	 add	 esp, 24			; 00000018H

; 327  : 		chain = chain->next;

  0011f	8b 45 dc	 mov	 eax, DWORD PTR _chain$[ebp]
  00122	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00125	89 4d dc	 mov	 DWORD PTR _chain$[ebp], ecx

; 328  : 	}

  00128	e9 02 ff ff ff	 jmp	 $LN2@isVertexIn
$LN3@isVertexIn:

; 329  : 
; 330  : 	return biggerThanPi(phiMin, phiMax);

  0012d	83 ec 08	 sub	 esp, 8
  00130	f2 0f 10 45 cc	 movsd	 xmm0, QWORD PTR _phiMax$[ebp]
  00135	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0013a	83 ec 08	 sub	 esp, 8
  0013d	f2 0f 10 45 d4	 movsd	 xmm0, QWORD PTR _phiMin$[ebp]
  00142	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00147	e8 00 00 00 00	 call	 _biggerThanPi
  0014c	83 c4 10	 add	 esp, 16			; 00000010H

; 331  : }

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
_isVertexInside ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _phiBounds
_TEXT	SEGMENT
_psi7$ = -72						; size = 8
_psi6$ = -64						; size = 8
_psi5$ = -56						; size = 8
_psi4$ = -48						; size = 8
_psi3$ = -40						; size = 8
_psi2$ = -32						; size = 8
_psi1$ = -24						; size = 8
_phi2Tmp$ = -16						; size = 8
_phi1Tmp$ = -8						; size = 8
_phi1$ = 8						; size = 8
_phi2$ = 16						; size = 8
_phiMin$ = 24						; size = 4
_phiMax$ = 28						; size = 4
_phiBounds PROC						; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 201  : 	double phi1Tmp, phi2Tmp;
; 202  : 	double psi1, psi2, psi3, psi4, psi5, psi6, psi7; // for optimization
; 203  : 
; 204  : 	sortPhi(phi1, phi2, &phi1Tmp, &phi2Tmp);

  0000c	8d 45 f0	 lea	 eax, DWORD PTR _phi2Tmp$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR _phi1Tmp$[ebp]
  00013	51		 push	 ecx
  00014	83 ec 08	 sub	 esp, 8
  00017	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  0001c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00021	83 ec 08	 sub	 esp, 8
  00024	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00029	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002e	e8 00 00 00 00	 call	 _sortPhi
  00033	83 c4 18	 add	 esp, 24			; 00000018H

; 205  : 	phi1 = phi1Tmp;

  00036	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _phi1Tmp$[ebp]
  0003b	f2 0f 11 45 08	 movsd	 QWORD PTR _phi1$[ebp], xmm0

; 206  : 	phi2 = phi2Tmp;

  00040	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _phi2Tmp$[ebp]
  00045	f2 0f 11 45 10	 movsd	 QWORD PTR _phi2$[ebp], xmm0

; 207  : 
; 208  : 	// check start condition
; 209  : 	if (*phiMin > M_PIl || *phiMax > M_PIl)

  0004a	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  0004d	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00051	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@400921fb54442d18
  00059	77 11		 ja	 SHORT $LN3@phiBounds
  0005b	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  0005e	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00062	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@400921fb54442d18
  0006a	76 1d		 jbe	 SHORT $LN2@phiBounds
$LN3@phiBounds:

; 210  : 	{
; 211  : 		*phiMin = phi1;

  0006c	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  0006f	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00074	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 212  : 		*phiMax = phi2;

  00078	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  0007b	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00080	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 213  : 		return;

  00084	e9 ce 01 00 00	 jmp	 $LN10@phiBounds
$LN2@phiBounds:

; 214  : 	}
; 215  : 
; 216  : 	// 6 cases:
; 217  : 	// new angles inbetween phiMin, phiMax -> forget it
; 218  : 	// new angles enclose phiMin -> set phiMin
; 219  : 	// new angles enclose phiMax -> set phiMax
; 220  : 	// new angles completely outside phiMin, phiMax -> leave largest area free
; 221  : 	// new angles close the range completely!
; 222  : 	// new angles enlarges range on both sides
; 223  : 
; 224  : 	psi1 = phiDiff(*phiMin, phi1);

  00089	83 ec 08	 sub	 esp, 8
  0008c	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00091	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00096	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  00099	83 ec 08	 sub	 esp, 8
  0009c	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  000a0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a5	e8 00 00 00 00	 call	 _phiDiff
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	dd 5d e8	 fstp	 QWORD PTR _psi1$[ebp]

; 225  : 	psi2 = phiDiff(*phiMin, phi2);

  000b0	83 ec 08	 sub	 esp, 8
  000b3	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  000b8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000bd	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  000c0	83 ec 08	 sub	 esp, 8
  000c3	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  000c7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000cc	e8 00 00 00 00	 call	 _phiDiff
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	dd 5d e0	 fstp	 QWORD PTR _psi2$[ebp]

; 226  : 	psi3 = phiDiff(*phiMax, phi1);

  000d7	83 ec 08	 sub	 esp, 8
  000da	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  000df	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000e4	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  000e7	83 ec 08	 sub	 esp, 8
  000ea	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  000ee	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f3	e8 00 00 00 00	 call	 _phiDiff
  000f8	83 c4 10	 add	 esp, 16			; 00000010H
  000fb	dd 5d d8	 fstp	 QWORD PTR _psi3$[ebp]

; 227  : 	psi4 = phiDiff(*phiMax, phi2);

  000fe	83 ec 08	 sub	 esp, 8
  00101	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00106	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0010b	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  0010e	83 ec 08	 sub	 esp, 8
  00111	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00115	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011a	e8 00 00 00 00	 call	 _phiDiff
  0011f	83 c4 10	 add	 esp, 16			; 00000010H
  00122	dd 5d d0	 fstp	 QWORD PTR _psi4$[ebp]

; 228  : 	psi5 = phiDiff(*phiMin, *phiMax);

  00125	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  00128	83 ec 08	 sub	 esp, 8
  0012b	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  0012f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00134	8b 4d 18	 mov	 ecx, DWORD PTR _phiMin$[ebp]
  00137	83 ec 08	 sub	 esp, 8
  0013a	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  0013e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00143	e8 00 00 00 00	 call	 _phiDiff
  00148	83 c4 10	 add	 esp, 16			; 00000010H
  0014b	dd 5d c8	 fstp	 QWORD PTR _psi5$[ebp]

; 229  : 	psi6 = (double)(2.0l*M_PIl - psi5); // phiDiff(*phiMax, *phiMin);

  0014e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@401921fb54442d18
  00156	f2 0f 5c 45 c8	 subsd	 xmm0, QWORD PTR _psi5$[ebp]
  0015b	f2 0f 11 45 c0	 movsd	 QWORD PTR _psi6$[ebp], xmm0

; 230  : 	psi7 = (double)(2.0l*M_PIl - psi2); // phiDiff(phi2, *phiMin);

  00160	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@401921fb54442d18
  00168	f2 0f 5c 45 e0	 subsd	 xmm0, QWORD PTR _psi2$[ebp]
  0016d	f2 0f 11 45 b8	 movsd	 QWORD PTR _psi7$[ebp], xmm0

; 231  : 
; 232  : 	// case 1 & 5!
; 233  : 	if ((psi1 <= psi5) && (psi2 <= psi5))

  00172	f2 0f 10 45 c8	 movsd	 xmm0, QWORD PTR _psi5$[ebp]
  00177	66 0f 2f 45 e8	 comisd	 xmm0, QWORD PTR _psi1$[ebp]
  0017c	72 3d		 jb	 SHORT $LN6@phiBounds
  0017e	f2 0f 10 45 c8	 movsd	 xmm0, QWORD PTR _psi5$[ebp]
  00183	66 0f 2f 45 e0	 comisd	 xmm0, QWORD PTR _psi2$[ebp]
  00188	72 31		 jb	 SHORT $LN6@phiBounds

; 234  : 	{
; 235  : 		if (psi1 <= psi2) // case 1

  0018a	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _psi2$[ebp]
  0018f	66 0f 2f 45 e8	 comisd	 xmm0, QWORD PTR _psi1$[ebp]
  00194	72 07		 jb	 SHORT $LN5@phiBounds

; 236  : 		{
; 237  : 			return;

  00196	e9 bc 00 00 00	 jmp	 $LN10@phiBounds

; 238  : 		}

  0019b	eb 1e		 jmp	 SHORT $LN6@phiBounds
$LN5@phiBounds:

; 239  : 		else // case 5
; 240  : 		{
; 241  : 			// create some artificial interval here not to get into numerical trouble
; 242  : 			// in fact we know now the sector is completely enclosed -> base for computational optimization
; 243  : 			*phiMax = 0.0l;

  0019d	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  001a0	0f 57 c0	 xorps	 xmm0, xmm0
  001a3	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 244  : 			*phiMin = DELTAPHI;

  001a7	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  001aa	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fa015bf9217271a
  001b2	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 245  : 			return;

  001b6	e9 9c 00 00 00	 jmp	 $LN10@phiBounds
$LN6@phiBounds:

; 246  : 		}
; 247  : 	}
; 248  : 
; 249  : 	// case 2
; 250  : 	if ((psi1 >= psi5) && (psi2 <= psi5))

  001bb	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _psi1$[ebp]
  001c0	66 0f 2f 45 c8	 comisd	 xmm0, QWORD PTR _psi5$[ebp]
  001c5	72 1a		 jb	 SHORT $LN7@phiBounds
  001c7	f2 0f 10 45 c8	 movsd	 xmm0, QWORD PTR _psi5$[ebp]
  001cc	66 0f 2f 45 e0	 comisd	 xmm0, QWORD PTR _psi2$[ebp]
  001d1	72 0e		 jb	 SHORT $LN7@phiBounds

; 251  : 	{
; 252  : 		*phiMin = phi1;

  001d3	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  001d6	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  001db	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 253  : 		return;

  001df	eb 76		 jmp	 SHORT $LN10@phiBounds
$LN7@phiBounds:

; 254  : 	}
; 255  : 
; 256  : 	// case 3
; 257  : 	if ((psi3 >= psi6) && (psi4 <= psi6))

  001e1	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _psi3$[ebp]
  001e6	66 0f 2f 45 c0	 comisd	 xmm0, QWORD PTR _psi6$[ebp]
  001eb	72 1a		 jb	 SHORT $LN8@phiBounds
  001ed	f2 0f 10 45 c0	 movsd	 xmm0, QWORD PTR _psi6$[ebp]
  001f2	66 0f 2f 45 d0	 comisd	 xmm0, QWORD PTR _psi4$[ebp]
  001f7	72 0e		 jb	 SHORT $LN8@phiBounds

; 258  : 	{
; 259  : 		*phiMax = phi2;

  001f9	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  001fc	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00201	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 260  : 		return;

  00205	eb 50		 jmp	 SHORT $LN10@phiBounds
$LN8@phiBounds:

; 261  : 	}
; 262  : 
; 263  : 	// case 4 & 6
; 264  : #ifdef PARANOIA
; 265  : 	if ((psi3 <= psi6) && (psi4 <= psi6)) // FIXME: isn't this case implicitly true anyway??
; 266  : #endif
; 267  : 	{
; 268  : 		if (psi3 <= psi4) //case 4

  00207	f2 0f 10 45 d0	 movsd	 xmm0, QWORD PTR _psi4$[ebp]
  0020c	66 0f 2f 45 d8	 comisd	 xmm0, QWORD PTR _psi3$[ebp]
  00211	72 2c		 jb	 SHORT $LN9@phiBounds

; 269  : 		{
; 270  : 			if (psi3 >= psi7)

  00213	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR _psi3$[ebp]
  00218	66 0f 2f 45 b8	 comisd	 xmm0, QWORD PTR _psi7$[ebp]
  0021d	72 10		 jb	 SHORT $LN11@phiBounds

; 271  : 			{
; 272  : 				*phiMin = phi1;

  0021f	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  00222	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00227	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 273  : 				return;

  0022b	eb 2a		 jmp	 SHORT $LN10@phiBounds

; 274  : 			}

  0022d	eb 0e		 jmp	 SHORT $LN12@phiBounds
$LN11@phiBounds:

; 275  : 			else
; 276  : 			{
; 277  : 				*phiMax = phi2;

  0022f	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  00232	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00237	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 278  : 				return;

  0023b	eb 1a		 jmp	 SHORT $LN10@phiBounds
$LN12@phiBounds:

; 279  : 			}
; 280  : 		}

  0023d	eb 18		 jmp	 SHORT $LN10@phiBounds
$LN9@phiBounds:

; 281  : 		else // case 6
; 282  : 		{
; 283  : 			*phiMin = phi1;

  0023f	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  00242	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00247	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 284  : 			*phiMax = phi2;

  0024b	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  0024e	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00253	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
$LN10@phiBounds:

; 285  : 			return;
; 286  : 		}
; 287  : 	}
; 288  : 
; 289  : #ifdef PARANOIA
; 290  : 	I_OutputMsg("phiMin = %f, phiMax = %f, phi1 = %f, phi2 = %f\n", *phiMin, *phiMax, phi1, phi2);
; 291  : 	I_Error("Holy shit, phiBounds() freaked out\n");
; 292  : #endif
; 293  : }

  00257	5f		 pop	 edi
  00258	5e		 pop	 esi
  00259	5b		 pop	 ebx
  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c3		 ret	 0
_phiBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _biggerThanPi
_TEXT	SEGMENT
tv75 = -72						; size = 8
_phi1$ = 8						; size = 8
_phi2$ = 16						; size = 8
_biggerThanPi PROC					; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 188  : 	if (phiDiff(phi1, phi2) > M_PIl)

  00009	83 ec 08	 sub	 esp, 8
  0000c	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	83 ec 08	 sub	 esp, 8
  00019	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  0001e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00023	e8 00 00 00 00	 call	 _phiDiff
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	dd 5d b8	 fstp	 QWORD PTR tv75[ebp]
  0002e	f2 0f 10 45 b8	 movsd	 xmm0, QWORD PTR tv75[ebp]
  00033	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@400921fb54442d18
  0003b	76 07		 jbe	 SHORT $LN2@biggerThan

; 189  : 		return true;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 02		 jmp	 SHORT $LN1@biggerThan
$LN2@biggerThan:

; 190  : 
; 191  : 	return false;

  00044	33 c0		 xor	 eax, eax
$LN1@biggerThan:

; 192  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_biggerThanPi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _sortPhi
_TEXT	SEGMENT
tv75 = -72						; size = 8
_phi1$ = 8						; size = 8
_phi2$ = 16						; size = 8
_phiMin$ = 24						; size = 4
_phiMax$ = 28						; size = 4
_sortPhi PROC						; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 170  : 	if (phiDiff(phi1, phi2) < M_PIl)

  00009	83 ec 08	 sub	 esp, 8
  0000c	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	83 ec 08	 sub	 esp, 8
  00019	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  0001e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00023	e8 00 00 00 00	 call	 _phiDiff
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	dd 5d b8	 fstp	 QWORD PTR tv75[ebp]
  0002e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@400921fb54442d18
  00036	66 0f 2f 45 b8	 comisd	 xmm0, QWORD PTR tv75[ebp]
  0003b	76 1a		 jbe	 SHORT $LN2@sortPhi

; 171  : 	{
; 172  : 		*phiMin = phi1;

  0003d	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  00040	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  00045	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 173  : 		*phiMax = phi2;

  00049	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  0004c	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  00051	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 174  : 	}

  00055	eb 18		 jmp	 SHORT $LN3@sortPhi
$LN2@sortPhi:

; 175  : 	else
; 176  : 	{
; 177  : 		*phiMin = phi2;

  00057	8b 45 18	 mov	 eax, DWORD PTR _phiMin$[ebp]
  0005a	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phi2$[ebp]
  0005f	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 178  : 		*phiMax = phi1;

  00063	8b 45 1c	 mov	 eax, DWORD PTR _phiMax$[ebp]
  00066	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _phi1$[ebp]
  0006b	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
$LN3@sortPhi:

; 179  : 	}
; 180  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_sortPhi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _phiDiff
_TEXT	SEGMENT
_result$ = -8						; size = 8
_phiMin$ = 8						; size = 8
_phiMax$ = 16						; size = 8
_phiDiff PROC						; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 155  : 	double result;
; 156  : 
; 157  : 	result = phiMax-phiMin;

  00009	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _phiMax$[ebp]
  0000e	f2 0f 5c 45 08	 subsd	 xmm0, QWORD PTR _phiMin$[ebp]
  00013	f2 0f 11 45 f8	 movsd	 QWORD PTR _result$[ebp], xmm0

; 158  : 
; 159  : 	if (result < 0.0l)

  00018	0f 57 c0	 xorps	 xmm0, xmm0
  0001b	66 0f 2f 45 f8	 comisd	 xmm0, QWORD PTR _result$[ebp]
  00020	76 12		 jbe	 SHORT $LN2@phiDiff

; 160  : 		result += 2.0l*M_PIl;

  00022	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _result$[ebp]
  00027	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@401921fb54442d18
  0002f	f2 0f 11 45 f8	 movsd	 QWORD PTR _result$[ebp], xmm0
$LN2@phiDiff:

; 161  : 
; 162  : 	return result;

  00034	dd 45 f8	 fld	 QWORD PTR _result$[ebp]

; 163  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_phiDiff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _isPSectorValid
_TEXT	SEGMENT
_nextElem$ = -8						; size = 4
_thisElem$ = -4						; size = 4
_sector$ = 8						; size = 4
_isPSectorValid PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 128  : 	linechain_t *thisElem, *nextElem;
; 129  : 
; 130  : 	if (!sector->pseudoSector) // check only pseudosectors, others dont care

  00009	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0000c	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  00013	75 04		 jne	 SHORT $LN4@isPSectorV

; 131  : 	{
; 132  : #ifdef PARANOIA
; 133  : 		CONS_Printf("Alert! non-pseudosector fed to isPSectorClosed()\n");
; 134  : #endif
; 135  : 		return false;

  00015	33 c0		 xor	 eax, eax
  00017	eb 3e		 jmp	 SHORT $LN1@isPSectorV
$LN4@isPSectorV:

; 136  : 	}
; 137  : 
; 138  : 	nextElem = sector->sectorLines;

  00019	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0001c	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00022	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx
$LN2@isPSectorV:

; 139  : 
; 140  : 	while (nextElem)

  00025	83 7d f8 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  00029	74 27		 je	 SHORT $LN3@isPSectorV

; 141  : 	{
; 142  : 		thisElem = nextElem;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _nextElem$[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR _thisElem$[ebp], eax

; 143  : 		nextElem = thisElem->next;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 144  : 		if (thisElem->line->frontsector != thisElem->line->backsector)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _thisElem$[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00047	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  0004a	74 04		 je	 SHORT $LN5@isPSectorV

; 145  : 			return false;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 07		 jmp	 SHORT $LN1@isPSectorV
$LN5@isPSectorV:

; 146  : 	}

  00050	eb d3		 jmp	 SHORT $LN2@isPSectorV
$LN3@isPSectorV:

; 147  : 	return true;

  00052	b8 01 00 00 00	 mov	 eax, 1
$LN1@isPSectorV:

; 148  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_isPSectorValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _releaseLineChains
_TEXT	SEGMENT
_i$ = -16						; size = 4
_sector$ = -12						; size = 4
_nextElem$ = -8						; size = 4
_thisElem$ = -4						; size = 4
_releaseLineChains PROC					; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 103  : 	linechain_t *thisElem, *nextElem;
; 104  : 	sector_t *sector;
; 105  : 	size_t i;
; 106  : 
; 107  : 	for (i = 0; i < numsectors; i++)

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@releaseLin
$LN2@releaseLin:
  00012	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@releaseLin:
  0001b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00024	73 4e		 jae	 SHORT $LN3@releaseLin

; 108  : 	{
; 109  : 	sector = &sectors[i];

  00026	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00033	89 45 f4	 mov	 DWORD PTR _sector$[ebp], eax

; 110  : 	nextElem = sector->sectorLines;

  00036	8b 45 f4	 mov	 eax, DWORD PTR _sector$[ebp]
  00039	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0003f	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx
$LN5@releaseLin:

; 111  : 
; 112  : 	while (nextElem)

  00042	83 7d f8 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  00046	74 1d		 je	 SHORT $LN6@releaseLin

; 113  : 	{
; 114  : 		thisElem = nextElem;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _nextElem$[ebp]
  0004b	89 45 fc	 mov	 DWORD PTR _thisElem$[ebp], eax

; 115  : 		nextElem = thisElem->next;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 116  : 		free(thisElem);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _free
  00060	83 c4 04	 add	 esp, 4

; 117  : 	}

  00063	eb dd		 jmp	 SHORT $LN5@releaseLin
$LN6@releaseLin:

; 118  : 
; 119  : 	sector->sectorLines = NULL;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _sector$[ebp]
  00068	c7 80 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+200], 0

; 120  : 	}

  00072	eb 9e		 jmp	 SHORT $LN2@releaseLin
$LN3@releaseLin:

; 121  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_releaseLineChains ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _addLineToChain
_TEXT	SEGMENT
_nextElem$ = -8						; size = 4
_thisElem$ = -4						; size = 4
_sector$ = 8						; size = 4
_line$ = 12						; size = 4
_addLineToChain PROC					; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   : 	linechain_t *thisElem = NULL, *nextElem;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _thisElem$[ebp], 0

; 57   : 
; 58   : 	if (!sector)

  00010	83 7d 08 00	 cmp	 DWORD PTR _sector$[ebp], 0
  00014	75 05		 jne	 SHORT $LN4@addLineToC

; 59   : 		return;

  00016	e9 b7 00 00 00	 jmp	 $LN10@addLineToC
$LN4@addLineToC:

; 60   : 
; 61   : 	nextElem = sector->sectorLines;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0001e	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00024	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx
$LN2@addLineToC:

; 62   : 
; 63   : 	while (nextElem) // walk through chain

  00027	83 7d f8 00	 cmp	 DWORD PTR _nextElem$[ebp], 0
  0002b	74 11		 je	 SHORT $LN3@addLineToC

; 64   : 	{
; 65   : 		thisElem = nextElem;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _nextElem$[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _thisElem$[ebp], eax

; 66   : 		nextElem = thisElem->next;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	89 4d f8	 mov	 DWORD PTR _nextElem$[ebp], ecx

; 67   : 	}

  0003c	eb e9		 jmp	 SHORT $LN2@addLineToC
$LN3@addLineToC:

; 68   : 
; 69   : 	// add a new element into the chain
; 70   : 	if (thisElem)

  0003e	83 7d fc 00	 cmp	 DWORD PTR _thisElem$[ebp], 0
  00042	74 42		 je	 SHORT $LN5@addLineToC

; 71   : 	{
; 72   : 		thisElem->next = malloc(sizeof (linechain_t));

  00044	6a 08		 push	 8
  00046	e8 00 00 00 00	 call	 _malloc
  0004b	83 c4 04	 add	 esp, 4
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _thisElem$[ebp]
  00051	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   : 		if (thisElem->next)

  00054	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00057	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0005b	74 1a		 je	 SHORT $LN7@addLineToC

; 74   : 		{
; 75   : 			thisElem->next->line = line;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  00066	89 11		 mov	 DWORD PTR [ecx], edx

; 76   : 			thisElem->next->next = NULL;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _thisElem$[ebp]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 77   : 		}

  00075	eb 0d		 jmp	 SHORT $LN8@addLineToC
$LN7@addLineToC:

; 78   : 		else
; 79   : 		{
; 80   : 			I_Error("Out of memory in addLineToChain(.)\n");

  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LLOBDHMA@Out?5of?5memory?5in?5addLineToChain@
  0007c	e8 00 00 00 00	 call	 _I_Error
  00081	83 c4 04	 add	 esp, 4
$LN8@addLineToC:

; 81   : 		}
; 82   : 	}

  00084	eb 4c		 jmp	 SHORT $LN10@addLineToC
$LN5@addLineToC:

; 83   : 	else // first element in chain
; 84   : 	{
; 85   : 		sector->sectorLines =  malloc(sizeof (linechain_t));

  00086	6a 08		 push	 8
  00088	e8 00 00 00 00	 call	 _malloc
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00093	89 81 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], eax

; 86   : 		if (sector->sectorLines)

  00099	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0009c	83 b8 c8 00 00
	00 00		 cmp	 DWORD PTR [eax+200], 0
  000a3	74 20		 je	 SHORT $LN9@addLineToC

; 87   : 		{
; 88   : 			sector->sectorLines->line = line;

  000a5	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000a8	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  000ae	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  000b1	89 11		 mov	 DWORD PTR [ecx], edx

; 89   : 			sector->sectorLines->next = NULL;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000b6	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  000bc	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 90   : 		}

  000c3	eb 0d		 jmp	 SHORT $LN10@addLineToC
$LN9@addLineToC:

; 91   : 		else
; 92   : 		{
; 93   : 			I_Error("Out of memory in addLineToChain(.)\n");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LLOBDHMA@Out?5of?5memory?5in?5addLineToChain@
  000ca	e8 00 00 00 00	 call	 _I_Error
  000cf	83 c4 04	 add	 esp, 4
$LN10@addLineToC:

; 94   : 		}
; 95   : 	}
; 96   : }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
_addLineToChain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_trick.c
;	COMDAT _HWR_CorrectSWTricks
_TEXT	SEGMENT
_corrheight$1 = -52					; size = 4
_corrheight$2 = -48					; size = 4
_floatSector$3 = -44					; size = 4
_checkSector$4 = -40					; size = 4
_outSector$ = -36					; size = 4
_sectorList$ = -32					; size = 4
_secr$ = -28						; size = 4
_secl$ = -24						; size = 4
_sdr$ = -20						; size = 4
_sdl$ = -16						; size = 4
_ld$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_HWR_CorrectSWTricks PROC				; COMDAT

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 764  : 	size_t i;
; 765  : 	size_t k;
; 766  : 	line_t *ld;
; 767  : 	side_t *sdl = NULL, *sdr;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _sdl$[ebp], 0

; 768  : 	sector_t *secl, *secr;
; 769  : 	sector_t **sectorList;
; 770  : 	sector_t *outSector;
; 771  : 
; 772  : 	if ((0 == cv_grcorrecttricks.value))

  00010	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grcorrecttricks+20, 0
  00017	75 05		 jne	 SHORT $LN19@HWR_Correc

; 773  : 		return;

  00019	e9 ee 04 00 00	 jmp	 $LN1@HWR_Correc
$LN19@HWR_Correc:

; 774  : 
; 775  : 	// determine lines for sectors
; 776  : 	for (i = 0; i < numlines; i++)

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@HWR_Correc
$LN2@HWR_Correc:
  00027	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HWR_Correc:
  00030	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00039	73 68		 jae	 SHORT $LN3@HWR_Correc

; 777  : 	{
; 778  : 		ld = &lines[i];

  0003b	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0003f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00045	89 45 f4	 mov	 DWORD PTR _ld$[ebp], eax

; 779  : 		secr = ld->frontsector;

  00048	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  0004b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0004e	89 4d e4	 mov	 DWORD PTR _secr$[ebp], ecx

; 780  : 		secl = ld->backsector;

  00051	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  00054	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00057	89 4d e8	 mov	 DWORD PTR _secl$[ebp], ecx

; 781  : 
; 782  : 		if (secr == secl)

  0005a	8b 45 e4	 mov	 eax, DWORD PTR _secr$[ebp]
  0005d	3b 45 e8	 cmp	 eax, DWORD PTR _secl$[ebp]
  00060	75 1f		 jne	 SHORT $LN20@HWR_Correc

; 783  : 		{
; 784  : 			secr->pseudoSector = true; // special renderer trick?

  00062	8b 45 e4	 mov	 eax, DWORD PTR _secr$[ebp]
  00065	c7 80 b4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+180], 1

; 785  : 			addLineToChain(secr, ld);

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  00072	50		 push	 eax
  00073	8b 4d e4	 mov	 ecx, DWORD PTR _secr$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _addLineToChain
  0007c	83 c4 08	 add	 esp, 8

; 786  : 		}

  0007f	eb 20		 jmp	 SHORT $LN21@HWR_Correc
$LN20@HWR_Correc:

; 787  : 		else
; 788  : 		{
; 789  : 			addLineToChain(secr, ld);

  00081	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  00084	50		 push	 eax
  00085	8b 4d e4	 mov	 ecx, DWORD PTR _secr$[ebp]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _addLineToChain
  0008e	83 c4 08	 add	 esp, 8

; 790  : 			addLineToChain(secl, ld);

  00091	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  00094	50		 push	 eax
  00095	8b 4d e8	 mov	 ecx, DWORD PTR _secl$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _addLineToChain
  0009e	83 c4 08	 add	 esp, 8
$LN21@HWR_Correc:

; 791  : 		}
; 792  : 	}

  000a1	eb 84		 jmp	 SHORT $LN2@HWR_Correc
$LN3@HWR_Correc:

; 793  : 
; 794  : 	// preprocessing
; 795  : 	for (i = 0; i < numsectors; i++)

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN7@HWR_Correc
$LN5@HWR_Correc:
  000ac	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000af	83 c0 01	 add	 eax, 1
  000b2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HWR_Correc:
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  000be	73 6b		 jae	 SHORT $LN6@HWR_Correc

; 796  : 	{
; 797  : 		sector_t *checkSector;
; 798  : 
; 799  : 		checkSector = &sectors[i];

  000c0	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  000c7	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  000cd	89 45 d8	 mov	 DWORD PTR _checkSector$4[ebp], eax

; 800  : 
; 801  : 		// identify real pseudosectors first
; 802  : 		if (checkSector->pseudoSector)

  000d0	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  000d3	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  000da	74 1d		 je	 SHORT $LN23@HWR_Correc

; 803  : 		{
; 804  : 			if (!isPSectorValid(checkSector)) // drop invalid pseudo sectors

  000dc	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _isPSectorValid
  000e5	83 c4 04	 add	 esp, 4
  000e8	85 c0		 test	 eax, eax
  000ea	75 0d		 jne	 SHORT $LN23@HWR_Correc

; 805  : 			{
; 806  : 				checkSector->pseudoSector = false;

  000ec	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  000ef	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+180], 0
$LN23@HWR_Correc:

; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 		// determine enclosing sectors for pseudosectors ... used later
; 811  : 		if (checkSector->pseudoSector)

  000f9	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  000fc	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  00103	74 24		 je	 SHORT $LN24@HWR_Correc

; 812  : 		{
; 813  : 			generateStacklist(checkSector);

  00105	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _generateStacklist
  0010e	83 c4 04	 add	 esp, 4

; 814  : 			calcLineouts(checkSector);

  00111	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _calcLineouts
  0011a	83 c4 04	 add	 esp, 4

; 815  : 			sortStacklist(checkSector);

  0011d	8b 45 d8	 mov	 eax, DWORD PTR _checkSector$4[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _sortStacklist
  00126	83 c4 04	 add	 esp, 4
$LN24@HWR_Correc:

; 816  : 		}
; 817  : 	}

  00129	eb 81		 jmp	 SHORT $LN5@HWR_Correc
$LN6@HWR_Correc:

; 818  : 
; 819  : 	// set virtual floor heights for pseudo sectors
; 820  : 	// required for deep water effect e.g.
; 821  : 	for (i = 0; i < numsectors; i++)

  0012b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00132	eb 09		 jmp	 SHORT $LN10@HWR_Correc
$LN8@HWR_Correc:
  00134	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00137	83 c0 01	 add	 eax, 1
  0013a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@HWR_Correc:
  0013d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00140	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00146	0f 83 f7 00 00
	00		 jae	 $LN9@HWR_Correc

; 822  : 	{
; 823  : 		if (sectors[i].pseudoSector)

  0014c	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00159	83 bc 01 b4 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax+180], 0
  00161	0f 84 d7 00 00
	00		 je	 $LN27@HWR_Correc

; 824  : 		{
; 825  : 			sectorList = sectors[i].stackList;

  00167	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00174	8b 94 01 cc 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+204]
  0017b	89 55 e0	 mov	 DWORD PTR _sectorList$[ebp], edx

; 826  : 			k = 0;

  0017e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
$LN11@HWR_Correc:

; 827  : 			while (*(sectorList+k))

  00185	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00188	8b 4d e0	 mov	 ecx, DWORD PTR _sectorList$[ebp]
  0018b	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0018f	74 58		 je	 SHORT $LN12@HWR_Correc

; 828  : 			{
; 829  : 				outSector = *(sectorList+k);

  00191	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00194	8b 4d e0	 mov	 ecx, DWORD PTR _sectorList$[ebp]
  00197	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0019a	89 55 dc	 mov	 DWORD PTR _outSector$[ebp], edx

; 830  : 				if (!outSector->pseudoSector)

  0019d	8b 45 dc	 mov	 eax, DWORD PTR _outSector$[ebp]
  001a0	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  001a7	75 35		 jne	 SHORT $LN26@HWR_Correc

; 831  : 				{
; 832  : 					sectors[i].virtualFloorheight = outSector->floorheight;

  001a9	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  001b6	8b 55 dc	 mov	 edx, DWORD PTR _outSector$[ebp]
  001b9	8b 12		 mov	 edx, DWORD PTR [edx]
  001bb	89 94 01 bc 00
	00 00		 mov	 DWORD PTR [ecx+eax+188], edx

; 833  : 					sectors[i].virtualCeilingheight = outSector->ceilingheight;

  001c2	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  001cf	8b 55 dc	 mov	 edx, DWORD PTR _outSector$[ebp]
  001d2	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001d5	89 94 01 c4 00
	00 00		 mov	 DWORD PTR [ecx+eax+196], edx

; 834  : 					break;

  001dc	eb 0b		 jmp	 SHORT $LN12@HWR_Correc
$LN26@HWR_Correc:

; 835  : 				}
; 836  : 				k++;

  001de	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  001e1	83 c0 01	 add	 eax, 1
  001e4	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax

; 837  : 			}

  001e7	eb 9c		 jmp	 SHORT $LN11@HWR_Correc
$LN12@HWR_Correc:

; 838  : 			if (*(sectorList+k) == NULL) // sorry, did not work :(

  001e9	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  001ec	8b 4d e0	 mov	 ecx, DWORD PTR _sectorList$[ebp]
  001ef	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  001f3	75 49		 jne	 SHORT $LN27@HWR_Correc

; 839  : 			{
; 840  : 				sectors[i].virtualFloorheight = sectors[i].floorheight;

  001f5	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  001fc	69 4d fc f8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 248
  00203	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00209	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  0020f	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  00212	89 84 0a bc 00
	00 00		 mov	 DWORD PTR [edx+ecx+188], eax

; 841  : 				sectors[i].virtualCeilingheight = sectors[i].ceilingheight;

  00219	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00220	69 4d fc f8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 248
  00227	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0022d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  00233	8b 44 06 04	 mov	 eax, DWORD PTR [esi+eax+4]
  00237	89 84 0a c4 00
	00 00		 mov	 DWORD PTR [edx+ecx+196], eax
$LN27@HWR_Correc:

; 842  : 			}
; 843  : 		}
; 844  : 	}

  0023e	e9 f1 fe ff ff	 jmp	 $LN8@HWR_Correc
$LN9@HWR_Correc:

; 845  : #ifdef CORRECT_FLOAT_EXPERIMENTAL
; 846  : 	// correct ceiling/floor heights of totally floating sectors
; 847  : 	for (i = 0; i < numsectors; i++)

  00243	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0024a	eb 09		 jmp	 SHORT $LN15@HWR_Correc
$LN13@HWR_Correc:
  0024c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0024f	83 c0 01	 add	 eax, 1
  00252	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN15@HWR_Correc:
  00255	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00258	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  0025e	0f 83 85 00 00
	00		 jae	 $LN14@HWR_Correc

; 848  : 	{
; 849  : 		sector_t *floatSector;
; 850  : 
; 851  : 		floatSector = &sectors[i];

  00264	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0026b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00271	89 45 d4	 mov	 DWORD PTR _floatSector$3[ebp], eax

; 852  : 
; 853  : 		// correct height of floating sectors
; 854  : 		if (isCeilingFloating(floatSector))

  00274	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 _isCeilingFloating
  0027d	83 c4 04	 add	 esp, 4
  00280	85 c0		 test	 eax, eax
  00282	74 28		 je	 SHORT $LN28@HWR_Correc

; 855  : 		{
; 856  : 			fixed_t corrheight;
; 857  : 
; 858  : 			corrheight = estimateCeilHeight(floatSector);

  00284	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  00287	50		 push	 eax
  00288	e8 00 00 00 00	 call	 _estimateCeilHeight
  0028d	83 c4 04	 add	 esp, 4
  00290	89 45 d0	 mov	 DWORD PTR _corrheight$2[ebp], eax

; 859  : 			floatSector->virtualCeilingheight = corrheight;

  00293	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  00296	8b 4d d0	 mov	 ecx, DWORD PTR _corrheight$2[ebp]
  00299	89 88 c4 00 00
	00		 mov	 DWORD PTR [eax+196], ecx

; 860  : 			floatSector->virtualCeiling = true;

  0029f	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  002a2	c7 80 c0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+192], 1
$LN28@HWR_Correc:

; 861  : 		}
; 862  : 		if (isFloorFloating(floatSector))

  002ac	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 _isFloorFloating
  002b5	83 c4 04	 add	 esp, 4
  002b8	85 c0		 test	 eax, eax
  002ba	74 28		 je	 SHORT $LN29@HWR_Correc

; 863  : 		{
; 864  : 			fixed_t corrheight;
; 865  : 
; 866  : 			corrheight = estimateFloorHeight(floatSector);

  002bc	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 _estimateFloorHeight
  002c5	83 c4 04	 add	 esp, 4
  002c8	89 45 cc	 mov	 DWORD PTR _corrheight$1[ebp], eax

; 867  : 			floatSector->virtualFloorheight = corrheight;

  002cb	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  002ce	8b 4d cc	 mov	 ecx, DWORD PTR _corrheight$1[ebp]
  002d1	89 88 bc 00 00
	00		 mov	 DWORD PTR [eax+188], ecx

; 868  : 			floatSector->virtualFloor = true;

  002d7	8b 45 d4	 mov	 eax, DWORD PTR _floatSector$3[ebp]
  002da	c7 80 b8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+184], 1
$LN29@HWR_Correc:

; 869  : 		}
; 870  : 	}

  002e4	e9 63 ff ff ff	 jmp	 $LN13@HWR_Correc
$LN14@HWR_Correc:

; 871  : #endif
; 872  : 
; 873  : 	// now for the missing textures
; 874  : 	for (i = 0; i < numlines; i++)

  002e9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002f0	eb 09		 jmp	 SHORT $LN18@HWR_Correc
$LN16@HWR_Correc:
  002f2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002f5	83 c0 01	 add	 eax, 1
  002f8	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN18@HWR_Correc:
  002fb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002fe	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00304	0f 83 f6 01 00
	00		 jae	 $LN17@HWR_Correc

; 875  : 	{
; 876  : 		ld = &lines[i];

  0030a	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0030e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00314	89 45 f4	 mov	 DWORD PTR _ld$[ebp], eax

; 877  : 		sdr = &sides[ld->sidenum[0]];

  00317	b8 02 00 00 00	 mov	 eax, 2
  0031c	6b c8 00	 imul	 ecx, eax, 0
  0031f	8b 55 f4	 mov	 edx, DWORD PTR _ld$[ebp]
  00322	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00327	6b c8 1c	 imul	 ecx, eax, 28
  0032a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  00330	89 4d ec	 mov	 DWORD PTR _sdr$[ebp], ecx

; 878  : 		if (ld->sidenum[1] != 0xffff)

  00333	b8 02 00 00 00	 mov	 eax, 2
  00338	c1 e0 00	 shl	 eax, 0
  0033b	8b 4d f4	 mov	 ecx, DWORD PTR _ld$[ebp]
  0033e	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  00343	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00349	74 1c		 je	 SHORT $LN30@HWR_Correc

; 879  : 		{
; 880  : 			sdl = &sides[ld->sidenum[1]];

  0034b	b8 02 00 00 00	 mov	 eax, 2
  00350	c1 e0 00	 shl	 eax, 0
  00353	8b 4d f4	 mov	 ecx, DWORD PTR _ld$[ebp]
  00356	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  0035b	6b c2 1c	 imul	 eax, edx, 28
  0035e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sides
  00364	89 45 f0	 mov	 DWORD PTR _sdl$[ebp], eax
$LN30@HWR_Correc:

; 881  : 		}
; 882  : 
; 883  : 		secr = ld->frontsector;

  00367	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  0036a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0036d	89 4d e4	 mov	 DWORD PTR _secr$[ebp], ecx

; 884  : 		secl = ld->backsector;

  00370	8b 45 f4	 mov	 eax, DWORD PTR _ld$[ebp]
  00373	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00376	89 4d e8	 mov	 DWORD PTR _secl$[ebp], ecx

; 885  : 
; 886  : 		if (secr == secl) // special renderer trick

  00379	8b 45 e4	 mov	 eax, DWORD PTR _secr$[ebp]
  0037c	3b 45 e8	 cmp	 eax, DWORD PTR _secl$[ebp]
  0037f	75 05		 jne	 SHORT $LN31@HWR_Correc

; 887  : 			continue; // we cant correct missing textures here

  00381	e9 6c ff ff ff	 jmp	 $LN16@HWR_Correc
$LN31@HWR_Correc:

; 888  : 
; 889  : 		if (secl) // only if there is a backsector

  00386	83 7d e8 00	 cmp	 DWORD PTR _secl$[ebp], 0
  0038a	0f 84 6b 01 00
	00		 je	 $LN54@HWR_Correc

; 890  : 		{
; 891  : 			if (secr->pseudoSector || secl->pseudoSector)

  00390	8b 45 e4	 mov	 eax, DWORD PTR _secr$[ebp]
  00393	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  0039a	75 0c		 jne	 SHORT $LN34@HWR_Correc
  0039c	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  0039f	83 b8 b4 00 00
	00 00		 cmp	 DWORD PTR [eax+180], 0
  003a6	74 05		 je	 SHORT $LN33@HWR_Correc
$LN34@HWR_Correc:

; 892  : 				continue;

  003a8	e9 45 ff ff ff	 jmp	 $LN16@HWR_Correc
$LN33@HWR_Correc:

; 893  : 			if (!secr->virtualFloor && !secl->virtualFloor)

  003ad	8b 45 e4	 mov	 eax, DWORD PTR _secr$[ebp]
  003b0	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  003b7	0f 85 b4 00 00
	00		 jne	 $LN44@HWR_Correc
  003bd	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  003c0	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  003c7	0f 85 a4 00 00
	00		 jne	 $LN44@HWR_Correc

; 894  : 			{
; 895  : 				if (secl->floorheight > secr->floorheight)

  003cd	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  003d0	8b 4d e4	 mov	 ecx, DWORD PTR _secr$[ebp]
  003d3	8b 10		 mov	 edx, DWORD PTR [eax]
  003d5	3b 11		 cmp	 edx, DWORD PTR [ecx]
  003d7	7e 47		 jle	 SHORT $LN36@HWR_Correc

; 896  : 				{
; 897  : 					// now check if r-sidedef is correct
; 898  : 					if (sdr->bottomtexture == 0)

  003d9	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  003dc	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  003e0	75 3c		 jne	 SHORT $LN40@HWR_Correc

; 899  : 					{
; 900  : 						if (sdr->midtexture == 0)

  003e2	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  003e5	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  003e9	75 27		 jne	 SHORT $LN39@HWR_Correc

; 901  : 							sdr->bottomtexture = R_TextureNumForName("REDWALL", (UINT16)(sdr-sides)); // Tails

  003eb	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  003ee	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sides
  003f4	99		 cdq
  003f5	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  003fa	f7 f9		 idiv	 ecx
  003fc	50		 push	 eax
  003fd	68 00 00 00 00	 push	 OFFSET ??_C@_07IDPDJOKH@REDWALL@
  00402	e8 00 00 00 00	 call	 _R_TextureNumForName
  00407	83 c4 08	 add	 esp, 8
  0040a	8b 55 ec	 mov	 edx, DWORD PTR _sdr$[ebp]
  0040d	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00410	eb 0c		 jmp	 SHORT $LN40@HWR_Correc
$LN39@HWR_Correc:

; 902  : 						else
; 903  : 							sdr->bottomtexture = sdr->midtexture;

  00412	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  00415	8b 4d ec	 mov	 ecx, DWORD PTR _sdr$[ebp]
  00418	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0041b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN40@HWR_Correc:

; 904  : 					}
; 905  : 				}

  0041e	eb 51		 jmp	 SHORT $LN44@HWR_Correc
$LN36@HWR_Correc:

; 906  : 				else if (secl->floorheight < secr->floorheight)

  00420	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  00423	8b 4d e4	 mov	 ecx, DWORD PTR _secr$[ebp]
  00426	8b 10		 mov	 edx, DWORD PTR [eax]
  00428	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0042a	7d 45		 jge	 SHORT $LN44@HWR_Correc

; 907  : 				{
; 908  : 					// now check if l-sidedef is correct
; 909  : 					if (sdl->bottomtexture == 0)

  0042c	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  0042f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00433	75 3c		 jne	 SHORT $LN44@HWR_Correc

; 910  : 					{
; 911  : 						if (sdl->midtexture == 0)

  00435	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  00438	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0043c	75 27		 jne	 SHORT $LN43@HWR_Correc

; 912  : 							sdl->bottomtexture = R_TextureNumForName("REDWALL", (UINT16)(sdl-sides)); // Tails

  0043e	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  00441	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sides
  00447	99		 cdq
  00448	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0044d	f7 f9		 idiv	 ecx
  0044f	50		 push	 eax
  00450	68 00 00 00 00	 push	 OFFSET ??_C@_07IDPDJOKH@REDWALL@
  00455	e8 00 00 00 00	 call	 _R_TextureNumForName
  0045a	83 c4 08	 add	 esp, 8
  0045d	8b 55 f0	 mov	 edx, DWORD PTR _sdl$[ebp]
  00460	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00463	eb 0c		 jmp	 SHORT $LN44@HWR_Correc
$LN43@HWR_Correc:

; 913  : 						else
; 914  : 							sdl->bottomtexture = sdl->midtexture;

  00465	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  00468	8b 4d f0	 mov	 ecx, DWORD PTR _sdl$[ebp]
  0046b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0046e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN44@HWR_Correc:

; 915  : 					}
; 916  : 				}
; 917  : 			}
; 918  : 
; 919  : 			if (!secr->virtualCeiling && !secl->virtualCeiling)

  00471	8b 45 e4	 mov	 eax, DWORD PTR _secr$[ebp]
  00474	83 b8 c0 00 00
	00 00		 cmp	 DWORD PTR [eax+192], 0
  0047b	75 7e		 jne	 SHORT $LN54@HWR_Correc
  0047d	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  00480	83 b8 c0 00 00
	00 00		 cmp	 DWORD PTR [eax+192], 0
  00487	75 72		 jne	 SHORT $LN54@HWR_Correc

; 920  : 			{
; 921  : 					if (secl->ceilingheight < secr->ceilingheight)

  00489	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  0048c	8b 4d e4	 mov	 ecx, DWORD PTR _secr$[ebp]
  0048f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00492	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00495	7d 2c		 jge	 SHORT $LN46@HWR_Correc

; 922  : 				{
; 923  : 					// now check if r-sidedef is correct
; 924  : 					if (sdr->toptexture == 0)

  00497	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  0049a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0049e	75 21		 jne	 SHORT $LN50@HWR_Correc

; 925  : 					{
; 926  : 						if (sdr->midtexture == 0)

  004a0	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  004a3	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  004a7	75 0c		 jne	 SHORT $LN49@HWR_Correc

; 927  : 							sdr->toptexture = 0; // Tails // When this was REDWALL it was causing issues in the sky sometimes

  004a9	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  004ac	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  004b3	eb 0c		 jmp	 SHORT $LN50@HWR_Correc
$LN49@HWR_Correc:

; 928  : 						else
; 929  : 							sdr->toptexture = sdr->midtexture;

  004b5	8b 45 ec	 mov	 eax, DWORD PTR _sdr$[ebp]
  004b8	8b 4d ec	 mov	 ecx, DWORD PTR _sdr$[ebp]
  004bb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  004be	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN50@HWR_Correc:

; 930  : 					}
; 931  : 				}

  004c1	eb 38		 jmp	 SHORT $LN54@HWR_Correc
$LN46@HWR_Correc:

; 932  : 				else if (secl->ceilingheight > secr->ceilingheight)

  004c3	8b 45 e8	 mov	 eax, DWORD PTR _secl$[ebp]
  004c6	8b 4d e4	 mov	 ecx, DWORD PTR _secr$[ebp]
  004c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004cc	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  004cf	7e 2a		 jle	 SHORT $LN54@HWR_Correc

; 933  : 				{
; 934  : 					// now check if l-sidedef is correct
; 935  : 					if (sdl->toptexture == 0)

  004d1	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  004d4	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  004d8	75 21		 jne	 SHORT $LN54@HWR_Correc

; 936  : 					{
; 937  : 						if (sdl->midtexture == 0)

  004da	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  004dd	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  004e1	75 0c		 jne	 SHORT $LN53@HWR_Correc

; 938  : 							sdl->toptexture = 0; // Tails // When this was REDWALL it was causing issues in the sky sometimes

  004e3	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  004e6	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  004ed	eb 0c		 jmp	 SHORT $LN54@HWR_Correc
$LN53@HWR_Correc:

; 939  : 						else
; 940  : 							sdl->toptexture = sdl->midtexture;

  004ef	8b 45 f0	 mov	 eax, DWORD PTR _sdl$[ebp]
  004f2	8b 4d f0	 mov	 ecx, DWORD PTR _sdl$[ebp]
  004f5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  004f8	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN54@HWR_Correc:

; 941  : 					}
; 942  : 				}
; 943  : 			}
; 944  : 		} // if (NULL != secl)
; 945  : 	} // for (i = 0; i < numlines; i++)

  004fb	e9 f2 fd ff ff	 jmp	 $LN16@HWR_Correc
$LN17@HWR_Correc:

; 946  : 
; 947  : 	// release all linechains
; 948  : 	releaseLineChains();

  00500	e8 00 00 00 00	 call	 _releaseLineChains
  00505	90		 npad	 1

; 949  : 	freeStacklists();

  00506	e8 00 00 00 00	 call	 _freeStacklists
  0050b	90		 npad	 1
$LN1@HWR_Correc:

; 950  : }

  0050c	5f		 pop	 edi
  0050d	5e		 pop	 esi
  0050e	5b		 pop	 ebx
  0050f	8b e5		 mov	 esp, ebp
  00511	5d		 pop	 ebp
  00512	c3		 ret	 0
_HWR_CorrectSWTricks ENDP
_TEXT	ENDS
END
