; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\p_tick.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_leveltime:DWORD
COMM	_thinkercap:BYTE:010H
_DATA	ENDS
PUBLIC	_Command_Numthinkers_f
PUBLIC	_Command_CountMobjs_f
PUBLIC	_P_Ticker
PUBLIC	_P_DoTeamscrambling
PUBLIC	_P_RemoveThinkerDelayed
PUBLIC	_P_SetTarget
PUBLIC	_P_InitThinkers
PUBLIC	_P_AddThinker
PUBLIC	_P_RemoveThinker
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0LA@FNICNMBH@numthinkers?5?$DM?$CD?$DO?3?5Count?5number?5o@ ; `string'
PUBLIC	??_C@_0BK@HNHHCFGP@Number?5of?5P_MobjThinker?3?5@ ; `string'
PUBLIC	??_C@_0BK@HGPMHGMJ@Number?5of?5P_RainThinker?3?5@ ; `string'
PUBLIC	??_C@_0BK@PGAFBNCE@Number?5of?5P_SnowThinker?3?5@ ; `string'
PUBLIC	??_C@_0CA@DBKJMADN@Number?5of?5P_NullPrecipThinker?3?5@ ; `string'
PUBLIC	??_C@_0BH@OIGPEGKM@Number?5of?5T_Friction?3?5@	; `string'
PUBLIC	??_C@_0BF@PLCCJBKO@Number?5of?5T_Pusher?3?5@	; `string'
PUBLIC	??_C@_0CD@BGHFHHDB@Number?5of?5P_RemoveThinkerDelaye@ ; `string'
PUBLIC	??_C@_0BN@INBEMBFC@That?5is?5not?5a?5valid?5number?4?6@ ; `string'
PUBLIC	??_C@_03PMGGPEJJ@?$CFd?6@			; `string'
PUBLIC	??_C@_0CJ@GOKGCFIC@Object?5number?5?$CFd?5out?5of?5range?5?$CI@ ; `string'
PUBLIC	??_C@_0DJ@FKAMKOGD@There?5are?5?$CFd?5objects?5of?5type?5?$CFd@ ; `string'
PUBLIC	??_C@_0CD@MCFKLOKE@Count?5of?5active?5objects?5in?5leve@ ; `string'
PUBLIC	??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6@		; `string'
PUBLIC	??_C@_05KOJMJHML@Done?6@			; `string'
PUBLIC	??_C@_0L@FKKLEDAE@?$CFs?5is?5it?$CB?6@		; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@3fb33333
EXTRN	_memset:PROC
EXTRN	_abs:PROC
EXTRN	_atoi:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_P_SnowThinker:PROC
EXTRN	_P_RainThinker:PROC
EXTRN	_P_NullPrecipThinker:PROC
EXTRN	_P_EmeraldManager:PROC
EXTRN	_COM_Argc:PROC
EXTRN	_COM_Argv:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_SendNetXCmd:PROC
EXTRN	_D_NumPlayers:PROC
EXTRN	_GetFreeXCmdSize:PROC
EXTRN	_P_AddPlayerScore:PROC
EXTRN	_P_GiveEmerald:PROC
EXTRN	_P_FreezeObjectplace:PROC
EXTRN	_P_PlayerThink:PROC
EXTRN	_P_PlayerAfterThink:PROC
EXTRN	_P_RespawnSpecials:PROC
EXTRN	_P_RunShields:PROC
EXTRN	_P_MobjThinker:PROC
EXTRN	_P_MapStart:PROC
EXTRN	_P_MapEnd:PROC
EXTRN	_P_DamageMobj:PROC
EXTRN	_P_UpdateSpecials:PROC
EXTRN	_T_Friction:PROC
EXTRN	_T_Pusher:PROC
EXTRN	_Z_Free:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_S_SpeedMusic:PROC
EXTRN	_M_Random:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_runemeraldmanager:DWORD
EXTRN	_gamemap:WORD
EXTRN	_netgame:DWORD
EXTRN	_gametype:WORD
EXTRN	_menuactive:DWORD
EXTRN	_paused:BYTE
EXTRN	_postimgtype:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_sstage_start:WORD
EXTRN	_sstage_end:WORD
EXTRN	_useNightsSS:DWORD
EXTRN	_countdowntimer:DWORD
EXTRN	_countdowntimeup:BYTE
EXTRN	_totalrings:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	_totalplaytime:DWORD
EXTRN	_sstimer:DWORD
EXTRN	_countdown:DWORD
EXTRN	_countdown2:DWORD
EXTRN	_scrambleplayers:ZWORD
EXTRN	_scrambleteams:ZWORD
EXTRN	_scrambletotal:WORD
EXTRN	_scramblecount:WORD
EXTRN	_hidetime:DWORD
EXTRN	_text:BYTE
EXTRN	_cv_matchtype:BYTE
EXTRN	_cv_autobalance:BYTE
EXTRN	_cv_teamscramble:BYTE
EXTRN	_cv_allowteamchange:BYTE
EXTRN	_cv_objectplace:BYTE
EXTRN	_server:DWORD
EXTRN	_player_names:BYTE
EXTRN	_players:BYTE
EXTRN	_playeringame:BYTE
EXTRN	_demoplayback:DWORD
EXTRN	_timeinmap:DWORD
EXTRN	_objectsdrawn:WORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_currentthinker DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3fb33333
CONST	SEGMENT
__real@3fb33333 DD 03fb33333r			; 1.4
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0L@FKKLEDAE@?$CFs?5is?5it?$CB?6@
CONST	SEGMENT
??_C@_0L@FKKLEDAE@?$CFs?5is?5it?$CB?6@ DB '%s is it!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOJMJHML@Done?6@
CONST	SEGMENT
??_C@_05KOJMJHML@Done?6@ DB 'Done', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6@
CONST	SEGMENT
??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6@ DB '%d: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MCFKLOKE@Count?5of?5active?5objects?5in?5leve@
CONST	SEGMENT
??_C@_0CD@MCFKLOKE@Count?5of?5active?5objects?5in?5leve@ DB 'Count of act'
	DB	'ive objects in level:', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FKAMKOGD@There?5are?5?$CFd?5objects?5of?5type?5?$CFd@
CONST	SEGMENT
??_C@_0DJ@FKAMKOGD@There?5are?5?$CFd?5objects?5of?5type?5?$CFd@ DB 'There'
	DB	' are %d objects of type %d currently in the level.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GOKGCFIC@Object?5number?5?$CFd?5out?5of?5range?5?$CI@
CONST	SEGMENT
??_C@_0CJ@GOKGCFIC@Object?5number?5?$CFd?5out?5of?5range?5?$CI@ DB 'Objec'
	DB	't number %d out of range (max %d).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PMGGPEJJ@?$CFd?6@
CONST	SEGMENT
??_C@_03PMGGPEJJ@?$CFd?6@ DB '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@INBEMBFC@That?5is?5not?5a?5valid?5number?4?6@
CONST	SEGMENT
??_C@_0BN@INBEMBFC@That?5is?5not?5a?5valid?5number?4?6@ DB 'That is not a'
	DB	' valid number.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BGHFHHDB@Number?5of?5P_RemoveThinkerDelaye@
CONST	SEGMENT
??_C@_0CD@BGHFHHDB@Number?5of?5P_RemoveThinkerDelaye@ DB 'Number of P_Rem'
	DB	'oveThinkerDelayed: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PLCCJBKO@Number?5of?5T_Pusher?3?5@
CONST	SEGMENT
??_C@_0BF@PLCCJBKO@Number?5of?5T_Pusher?3?5@ DB 'Number of T_Pusher: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OIGPEGKM@Number?5of?5T_Friction?3?5@
CONST	SEGMENT
??_C@_0BH@OIGPEGKM@Number?5of?5T_Friction?3?5@ DB 'Number of T_Friction: '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DBKJMADN@Number?5of?5P_NullPrecipThinker?3?5@
CONST	SEGMENT
??_C@_0CA@DBKJMADN@Number?5of?5P_NullPrecipThinker?3?5@ DB 'Number of P_N'
	DB	'ullPrecipThinker: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PGAFBNCE@Number?5of?5P_SnowThinker?3?5@
CONST	SEGMENT
??_C@_0BK@PGAFBNCE@Number?5of?5P_SnowThinker?3?5@ DB 'Number of P_SnowThi'
	DB	'nker: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HGPMHGMJ@Number?5of?5P_RainThinker?3?5@
CONST	SEGMENT
??_C@_0BK@HGPMHGMJ@Number?5of?5P_RainThinker?3?5@ DB 'Number of P_RainThi'
	DB	'nker: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HNHHCFGP@Number?5of?5P_MobjThinker?3?5@
CONST	SEGMENT
??_C@_0BK@HNHHCFGP@Number?5of?5P_MobjThinker?3?5@ DB 'Number of P_MobjThi'
	DB	'nker: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LA@FNICNMBH@numthinkers?5?$DM?$CD?$DO?3?5Count?5number?5o@
CONST	SEGMENT
??_C@_0LA@FNICNMBH@numthinkers?5?$DM?$CD?$DO?3?5Count?5number?5o@ DB 'num'
	DB	'thinkers <#>: Count number of thinkers', 0aH, 09H, '1: P_Mobj'
	DB	'Thinker', 0aH, 09H, '2: P_RainThinker', 0aH, 09H, '3: P_SnowT'
	DB	'hinker', 0aH, 09H, '4: P_NullPrecipThinker', 0aH, 09H, '5: T_'
	DB	'Friction', 0aH, 09H, '6: T_Pusher', 0aH, 09H, '7: P_RemoveThi'
	DB	'nkerDelayed', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0299H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_DoAutobalanceTeams
_TEXT	SEGMENT
_totalblue$ = -296					; size = 4
_totalred$ = -292					; size = 4
_blueflagcarrier$ = -288				; size = 4
_redflagcarrier$ = -284					; size = 4
_bluearray$ = -280					; size = 128
_redarray$ = -152					; size = 128
_blue$ = -24						; size = 4
_red$ = -20						; size = 4
_i$ = -16						; size = 4
_usvalue$ = -12						; size = 2
_NetPacket$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_P_DoAutobalanceTeams PROC				; COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 303  : 	changeteam_union NetPacket;
; 304  : 	UINT16 usvalue;
; 305  : 	INT32 i=0;

  00016	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 306  : 	INT32 red=0, blue=0;

  0001d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _red$[ebp], 0
  00024	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _blue$[ebp], 0

; 307  : 	INT32 redarray[MAXPLAYERS], bluearray[MAXPLAYERS];
; 308  : 	INT32 redflagcarrier = 0, blueflagcarrier = 0;

  0002b	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _redflagcarrier$[ebp], 0
  00035	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _blueflagcarrier$[ebp], 0

; 309  : 	INT32 totalred = 0, totalblue = 0;

  0003f	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _totalred$[ebp], 0
  00049	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _totalblue$[ebp], 0

; 310  : 
; 311  : 	NetPacket.value.l = NetPacket.value.b = 0;

  00053	33 c0		 xor	 eax, eax
  00055	66 89 45 fa	 mov	 WORD PTR _NetPacket$[ebp+2], ax
  00059	66 8b 4d fa	 mov	 cx, WORD PTR _NetPacket$[ebp+2]
  0005d	66 89 4d f8	 mov	 WORD PTR _NetPacket$[ebp], cx

; 312  : 	memset(redarray, 0, sizeof(redarray));

  00061	68 80 00 00 00	 push	 128			; 00000080H
  00066	6a 00		 push	 0
  00068	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _redarray$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _memset
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : 	memset(bluearray, 0, sizeof(bluearray));

  00077	68 80 00 00 00	 push	 128			; 00000080H
  0007c	6a 00		 push	 0
  0007e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _bluearray$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memset
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 
; 315  : 	// Only do it if we have enough room in the net buffer to send it.
; 316  : 	// Otherwise, come back next time and try again.
; 317  : 	if (sizeof(usvalue) > GetFreeXCmdSize())

  0008d	e8 00 00 00 00	 call	 _GetFreeXCmdSize
  00092	0f b6 c0	 movzx	 eax, al
  00095	83 f8 02	 cmp	 eax, 2
  00098	73 05		 jae	 SHORT $LN5@P_DoAutoba

; 318  : 		return;

  0009a	e9 f7 01 00 00	 jmp	 $LN15@P_DoAutoba
$LN5@P_DoAutoba:

; 319  : 
; 320  : 	//We have to store the players in an array with the rest of their team.
; 321  : 	//We can then pick a random player to be forced to change teams.
; 322  : 	for (i = 0; i < MAXPLAYERS; i++)

  0009f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a6	eb 09		 jmp	 SHORT $LN4@P_DoAutoba
$LN2@P_DoAutoba:
  000a8	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_DoAutoba:
  000b1	83 7d f0 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000b5	0f 8d ae 00 00
	00		 jge	 $LN3@P_DoAutoba

; 323  : 	{
; 324  : 		if (playeringame[i] && players[i].ctfteam)

  000bb	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000be	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000c6	0f 84 98 00 00
	00		 je	 $LN12@P_DoAutoba
  000cc	69 45 f0 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000d3	83 b8 60 01 00
	00 00		 cmp	 DWORD PTR _players[eax+352], 0
  000da	0f 84 84 00 00
	00		 je	 $LN12@P_DoAutoba

; 325  : 		{
; 326  : 			if (players[i].ctfteam == 1)

  000e0	69 45 f0 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000e7	83 b8 60 01 00
	00 01		 cmp	 DWORD PTR _players[eax+352], 1
  000ee	75 3b		 jne	 SHORT $LN7@P_DoAutoba

; 327  : 			{
; 328  : 				if (!players[i].gotflag)

  000f0	69 45 f0 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000f7	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR _players[eax+356]
  000fe	85 c9		 test	 ecx, ecx
  00100	75 18		 jne	 SHORT $LN9@P_DoAutoba

; 329  : 				{
; 330  : 					redarray[red] = i; //store the player's node.

  00102	8b 45 ec	 mov	 eax, DWORD PTR _red$[ebp]
  00105	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00108	89 8c 85 68 ff
	ff ff		 mov	 DWORD PTR _redarray$[ebp+eax*4], ecx

; 331  : 					red++;

  0010f	8b 45 ec	 mov	 eax, DWORD PTR _red$[ebp]
  00112	83 c0 01	 add	 eax, 1
  00115	89 45 ec	 mov	 DWORD PTR _red$[ebp], eax

; 332  : 				}

  00118	eb 0f		 jmp	 SHORT $LN10@P_DoAutoba
$LN9@P_DoAutoba:

; 333  : 				else
; 334  : 					redflagcarrier++;

  0011a	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _redflagcarrier$[ebp]
  00120	83 c0 01	 add	 eax, 1
  00123	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _redflagcarrier$[ebp], eax
$LN10@P_DoAutoba:

; 335  : 			}

  00129	eb 39		 jmp	 SHORT $LN12@P_DoAutoba
$LN7@P_DoAutoba:

; 336  : 			else
; 337  : 			{
; 338  : 				if (!players[i].gotflag)

  0012b	69 45 f0 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00132	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR _players[eax+356]
  00139	85 c9		 test	 ecx, ecx
  0013b	75 18		 jne	 SHORT $LN11@P_DoAutoba

; 339  : 				{
; 340  : 					bluearray[blue] = i; //store the player's node.

  0013d	8b 45 e8	 mov	 eax, DWORD PTR _blue$[ebp]
  00140	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00143	89 8c 85 e8 fe
	ff ff		 mov	 DWORD PTR _bluearray$[ebp+eax*4], ecx

; 341  : 					blue++;

  0014a	8b 45 e8	 mov	 eax, DWORD PTR _blue$[ebp]
  0014d	83 c0 01	 add	 eax, 1
  00150	89 45 e8	 mov	 DWORD PTR _blue$[ebp], eax

; 342  : 				}

  00153	eb 0f		 jmp	 SHORT $LN12@P_DoAutoba
$LN11@P_DoAutoba:

; 343  : 				else
; 344  : 					blueflagcarrier++;

  00155	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _blueflagcarrier$[ebp]
  0015b	83 c0 01	 add	 eax, 1
  0015e	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _blueflagcarrier$[ebp], eax
$LN12@P_DoAutoba:

; 345  : 			}
; 346  : 		}
; 347  : 	}

  00164	e9 3f ff ff ff	 jmp	 $LN2@P_DoAutoba
$LN3@P_DoAutoba:

; 348  : 
; 349  : 	totalred = red + redflagcarrier;

  00169	8b 45 ec	 mov	 eax, DWORD PTR _red$[ebp]
  0016c	03 85 e4 fe ff
	ff		 add	 eax, DWORD PTR _redflagcarrier$[ebp]
  00172	89 85 dc fe ff
	ff		 mov	 DWORD PTR _totalred$[ebp], eax

; 350  : 	totalblue = blue + blueflagcarrier;

  00178	8b 45 e8	 mov	 eax, DWORD PTR _blue$[ebp]
  0017b	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _blueflagcarrier$[ebp]
  00181	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _totalblue$[ebp], eax

; 351  : 
; 352  : 	if ((abs(totalred - totalblue) > cv_autobalance.value))

  00187	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _totalred$[ebp]
  0018d	2b 85 d8 fe ff
	ff		 sub	 eax, DWORD PTR _totalblue$[ebp]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _abs
  00199	83 c4 04	 add	 esp, 4
  0019c	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _cv_autobalance+20
  001a2	0f 8e ee 00 00
	00		 jle	 $LN15@P_DoAutoba

; 353  : 	{
; 354  : 		if (totalred > totalblue)

  001a8	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _totalred$[ebp]
  001ae	3b 85 d8 fe ff
	ff		 cmp	 eax, DWORD PTR _totalblue$[ebp]
  001b4	7e 69		 jle	 SHORT $LN14@P_DoAutoba

; 355  : 		{
; 356  : 			i = M_Random() % red;

  001b6	e8 00 00 00 00	 call	 _M_Random
  001bb	0f b6 c0	 movzx	 eax, al
  001be	99		 cdq
  001bf	f7 7d ec	 idiv	 DWORD PTR _red$[ebp]
  001c2	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx

; 357  : 			NetPacket.packet.newteam = 2;

  001c5	8b 45 f8	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  001c8	25 1f fc ff ff	 and	 eax, -993		; fffffc1fH
  001cd	83 c8 40	 or	 eax, 64			; 00000040H
  001d0	89 45 f8	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 358  : 			NetPacket.packet.playernum = redarray[i];

  001d3	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001d6	8b 8c 85 68 ff
	ff ff		 mov	 ecx, DWORD PTR _redarray$[ebp+eax*4]
  001dd	83 e1 1f	 and	 ecx, 31			; 0000001fH
  001e0	8b 55 f8	 mov	 edx, DWORD PTR _NetPacket$[ebp]
  001e3	83 e2 e0	 and	 edx, -32		; ffffffe0H
  001e6	0b d1		 or	 edx, ecx
  001e8	89 55 f8	 mov	 DWORD PTR _NetPacket$[ebp], edx

; 359  : 			NetPacket.packet.verification = true;

  001eb	8b 45 f8	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  001ee	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  001f3	89 45 f8	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 360  : 			NetPacket.packet.autobalance = true;

  001f6	8b 45 f8	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  001f9	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  001fe	89 45 f8	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 361  : 
; 362  : 			usvalue  = SHORT(NetPacket.value.l|NetPacket.value.b);

  00201	0f b7 45 f8	 movzx	 eax, WORD PTR _NetPacket$[ebp]
  00205	0f b7 4d fa	 movzx	 ecx, WORD PTR _NetPacket$[ebp+2]
  00209	0b c1		 or	 eax, ecx
  0020b	66 89 45 f4	 mov	 WORD PTR _usvalue$[ebp], ax

; 363  : 			SendNetXCmd(XD_TEAMCHANGE, &usvalue, sizeof(usvalue));

  0020f	6a 02		 push	 2
  00211	8d 45 f4	 lea	 eax, DWORD PTR _usvalue$[ebp]
  00214	50		 push	 eax
  00215	6a 0b		 push	 11			; 0000000bH
  00217	e8 00 00 00 00	 call	 _SendNetXCmd
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@P_DoAutoba:

; 364  : 		}
; 365  : 
; 366  : 		if (totalblue > totalred)

  0021f	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _totalblue$[ebp]
  00225	3b 85 dc fe ff
	ff		 cmp	 eax, DWORD PTR _totalred$[ebp]
  0022b	7e 69		 jle	 SHORT $LN15@P_DoAutoba

; 367  : 		{
; 368  : 			i = M_Random() % blue;

  0022d	e8 00 00 00 00	 call	 _M_Random
  00232	0f b6 c0	 movzx	 eax, al
  00235	99		 cdq
  00236	f7 7d e8	 idiv	 DWORD PTR _blue$[ebp]
  00239	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx

; 369  : 			NetPacket.packet.newteam = 1;

  0023c	8b 45 f8	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  0023f	25 1f fc ff ff	 and	 eax, -993		; fffffc1fH
  00244	83 c8 20	 or	 eax, 32			; 00000020H
  00247	89 45 f8	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 370  : 			NetPacket.packet.playernum = bluearray[i];

  0024a	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0024d	8b 8c 85 e8 fe
	ff ff		 mov	 ecx, DWORD PTR _bluearray$[ebp+eax*4]
  00254	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00257	8b 55 f8	 mov	 edx, DWORD PTR _NetPacket$[ebp]
  0025a	83 e2 e0	 and	 edx, -32		; ffffffe0H
  0025d	0b d1		 or	 edx, ecx
  0025f	89 55 f8	 mov	 DWORD PTR _NetPacket$[ebp], edx

; 371  : 			NetPacket.packet.verification = true;

  00262	8b 45 f8	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  00265	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  0026a	89 45 f8	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 372  : 			NetPacket.packet.autobalance = true;

  0026d	8b 45 f8	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  00270	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  00275	89 45 f8	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 373  : 
; 374  : 			usvalue  = SHORT(NetPacket.value.l|NetPacket.value.b);

  00278	0f b7 45 f8	 movzx	 eax, WORD PTR _NetPacket$[ebp]
  0027c	0f b7 4d fa	 movzx	 ecx, WORD PTR _NetPacket$[ebp+2]
  00280	0b c1		 or	 eax, ecx
  00282	66 89 45 f4	 mov	 WORD PTR _usvalue$[ebp], ax

; 375  : 			SendNetXCmd(XD_TEAMCHANGE, &usvalue, sizeof(usvalue));

  00286	6a 02		 push	 2
  00288	8d 45 f4	 lea	 eax, DWORD PTR _usvalue$[ebp]
  0028b	50		 push	 eax
  0028c	6a 0b		 push	 11			; 0000000bH
  0028e	e8 00 00 00 00	 call	 _SendNetXCmd
  00293	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@P_DoAutoba:

; 376  : 		}
; 377  : 	}
; 378  : }

  00296	5f		 pop	 edi
  00297	5e		 pop	 esi
  00298	5b		 pop	 ebx
  00299	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029c	33 cd		 xor	 ecx, ebp
  0029e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a3	8b e5		 mov	 esp, ebp
  002a5	5d		 pop	 ebp
  002a6	c3		 ret	 0
_P_DoAutobalanceTeams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_RunThinkers
_TEXT	SEGMENT
_P_RunThinkers PROC					; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  : 	for (currentthinker = thinkercap.next; currentthinker != &thinkercap; currentthinker = currentthinker->next)

  00009	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _currentthinker, eax
  00013	eb 0e		 jmp	 SHORT $LN4@P_RunThink
$LN2@P_RunThink:
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentthinker
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	89 0d 00 00 00
	00		 mov	 DWORD PTR _currentthinker, ecx
$LN4@P_RunThink:
  00023	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _currentthinker, OFFSET _thinkercap
  0002d	74 21		 je	 SHORT $LN3@P_RunThink

; 290  : 	{
; 291  : 		if (currentthinker->function.acp1)

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentthinker
  00034	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00038	74 14		 je	 SHORT $LN5@P_RunThink

; 292  : 			currentthinker->function.acp1(currentthinker);

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentthinker
  0003f	50		 push	 eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentthinker
  00046	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00049	ff d2		 call	 edx
  0004b	83 c4 04	 add	 esp, 4
$LN5@P_RunThink:

; 293  : 	}

  0004e	eb c5		 jmp	 SHORT $LN2@P_RunThink
$LN3@P_RunThink:

; 294  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_P_RunThinkers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_RemoveThinker
_TEXT	SEGMENT
_thinker$ = 8						; size = 4
_P_RemoveThinker PROC					; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 241  : 	thinker->function.acp1 = P_RemoveThinkerDelayed;

  00009	8b 45 08	 mov	 eax, DWORD PTR _thinker$[ebp]
  0000c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_RemoveThinkerDelayed

; 242  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_P_RemoveThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_AddThinker
_TEXT	SEGMENT
_thinker$ = 8						; size = 4
_P_AddThinker PROC					; COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 183  : 	thinkercap.prev->next = thinker;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _thinkercap
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _thinker$[ebp]
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 184  : 	thinker->next = &thinkercap;

  00014	8b 45 08	 mov	 eax, DWORD PTR _thinker$[ebp]
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _thinkercap

; 185  : 	thinker->prev = thinkercap.prev;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _thinker$[ebp]
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _thinkercap
  00027	89 08		 mov	 DWORD PTR [eax], ecx

; 186  : 	thinkercap.prev = thinker;

  00029	8b 45 08	 mov	 eax, DWORD PTR _thinker$[ebp]
  0002c	a3 00 00 00 00	 mov	 DWORD PTR _thinkercap, eax

; 187  : 
; 188  : 	thinker->references = 0;    // killough 11/98: init reference counter to 0

  00031	8b 45 08	 mov	 eax, DWORD PTR _thinker$[ebp]
  00034	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 189  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_P_AddThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_InitThinkers
_TEXT	SEGMENT
_P_InitThinkers PROC					; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 174  : 	thinkercap.prev = thinkercap.next = &thinkercap;

  00009	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _thinkercap+4, OFFSET _thinkercap
  00013	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00018	a3 00 00 00 00	 mov	 DWORD PTR _thinkercap, eax

; 175  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_P_InitThinkers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_SetTarget
_TEXT	SEGMENT
_mop$ = 8						; size = 4
_targ$ = 12						; size = 4
_P_SetTarget PROC					; COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 258  : 	if (*mop)              // If there was a target already, decrease its refcount

  00009	8b 45 08	 mov	 eax, DWORD PTR _mop$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 13		 je	 SHORT $LN2@P_SetTarge

; 259  : 		(*mop)->thinker.references--;

  00011	8b 45 08	 mov	 eax, DWORD PTR _mop$[ebp]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00019	83 ea 01	 sub	 edx, 1
  0001c	8b 45 08	 mov	 eax, DWORD PTR _mop$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN2@P_SetTarge:

; 260  : if ((*mop = targ) != NULL) // Set new target and if non-NULL, increase its counter

  00024	8b 45 08	 mov	 eax, DWORD PTR _mop$[ebp]
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _targ$[ebp]
  0002a	89 08		 mov	 DWORD PTR [eax], ecx
  0002c	83 7d 0c 00	 cmp	 DWORD PTR _targ$[ebp], 0
  00030	74 0f		 je	 SHORT $LN3@P_SetTarge

; 261  : 		targ->thinker.references++;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _targ$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	83 c1 01	 add	 ecx, 1
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _targ$[ebp]
  0003e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN3@P_SetTarge:

; 262  : 	return targ;

  00041	8b 45 0c	 mov	 eax, DWORD PTR _targ$[ebp]

; 263  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_P_SetTarget ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_RemoveThinkerDelayed
_TEXT	SEGMENT
_next$1 = -8						; size = 4
_thinker$ = -4						; size = 4
_pthinker$ = 8						; size = 4
_P_RemoveThinkerDelayed PROC				; COMDAT

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 211  : 	thinker_t *thinker = pthinker;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pthinker$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _thinker$[ebp], eax

; 212  : 	if (!thinker->references)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _thinker$[ebp]
  00012	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00016	75 36		 jne	 SHORT $LN2@P_RemoveTh

; 213  : 	{
; 214  : 		{
; 215  : 			/* Remove from main thinker list */
; 216  : 			thinker_t *next = thinker->next;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _thinker$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	89 4d f8	 mov	 DWORD PTR _next$1[ebp], ecx

; 217  : 			/* Note that currentthinker is guaranteed to point to us,
; 218  : 			 * and since we're freeing our memory, we had better change that. So
; 219  : 			 * point it to thinker->prev, so the iterator will correctly move on to
; 220  : 			 * thinker->prev->next = thinker->next */
; 221  : 			(next->prev = currentthinker = thinker->prev)->next = next;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _thinker$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 0d 00 00 00
	00		 mov	 DWORD PTR _currentthinker, ecx
  0002c	8b 55 f8	 mov	 edx, DWORD PTR _next$1[ebp]
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentthinker
  00034	89 02		 mov	 DWORD PTR [edx], eax
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentthinker
  0003c	8b 55 f8	 mov	 edx, DWORD PTR _next$1[ebp]
  0003f	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 222  : 		}
; 223  : 		Z_Free(thinker);

  00042	8b 45 fc	 mov	 eax, DWORD PTR _thinker$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _Z_Free
  0004b	83 c4 04	 add	 esp, 4
$LN2@P_RemoveTh:

; 224  :     }
; 225  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_P_RemoveThinkerDelayed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_DoTeamscrambling
_TEXT	SEGMENT
_usvalue$ = -8						; size = 2
_NetPacket$ = -4					; size = 4
_P_DoTeamscrambling PROC				; COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 388  : 	changeteam_union NetPacket;
; 389  : 	UINT16 usvalue;
; 390  : 	NetPacket.value.l = NetPacket.value.b = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 45 fe	 mov	 WORD PTR _NetPacket$[ebp+2], ax
  0000f	66 8b 4d fe	 mov	 cx, WORD PTR _NetPacket$[ebp+2]
  00013	66 89 4d fc	 mov	 WORD PTR _NetPacket$[ebp], cx

; 391  : 
; 392  : 	// Only do it if we have enough room in the net buffer to send it.
; 393  : 	// Otherwise, come back next time and try again.
; 394  : 	if (sizeof(usvalue) > GetFreeXCmdSize())

  00017	e8 00 00 00 00	 call	 _GetFreeXCmdSize
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	83 f8 02	 cmp	 eax, 2
  00022	73 05		 jae	 SHORT $LN2@P_DoTeamsc

; 395  : 		return;

  00024	e9 d7 00 00 00	 jmp	 $LN4@P_DoTeamsc
$LN2@P_DoTeamsc:

; 396  : 
; 397  : 	if (scramblecount < scrambletotal)

  00029	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _scramblecount
  00030	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _scrambletotal
  00037	3b c1		 cmp	 eax, ecx
  00039	0f 8d b2 00 00
	00		 jge	 $LN3@P_DoTeamsc

; 398  : 	{
; 399  : 		if (players[scrambleplayers[scramblecount]].ctfteam != scrambleteams[scramblecount])

  0003f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _scramblecount
  00046	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _scrambleplayers[eax*2]
  0004e	69 d1 fc 01 00
	00		 imul	 edx, ecx, 508
  00054	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _scramblecount
  0005b	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _scrambleteams[eax*2]
  00063	39 8a 60 01 00
	00		 cmp	 DWORD PTR _players[edx+352], ecx
  00069	74 74		 je	 SHORT $LN5@P_DoTeamsc

; 400  : 		{
; 401  : 			NetPacket.packet.newteam = scrambleteams[scramblecount];

  0006b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _scramblecount
  00072	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _scrambleteams[eax*2]
  0007a	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0007d	c1 e1 05	 shl	 ecx, 5
  00080	8b 55 fc	 mov	 edx, DWORD PTR _NetPacket$[ebp]
  00083	81 e2 1f fc ff
	ff		 and	 edx, -993		; fffffc1fH
  00089	0b d1		 or	 edx, ecx
  0008b	89 55 fc	 mov	 DWORD PTR _NetPacket$[ebp], edx

; 402  : 			NetPacket.packet.playernum = scrambleplayers[scramblecount];

  0008e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _scramblecount
  00095	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _scrambleplayers[eax*2]
  0009d	83 e1 1f	 and	 ecx, 31			; 0000001fH
  000a0	8b 55 fc	 mov	 edx, DWORD PTR _NetPacket$[ebp]
  000a3	83 e2 e0	 and	 edx, -32		; ffffffe0H
  000a6	0b d1		 or	 edx, ecx
  000a8	89 55 fc	 mov	 DWORD PTR _NetPacket$[ebp], edx

; 403  : 			NetPacket.packet.verification = true;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  000ae	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  000b3	89 45 fc	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 404  : 			NetPacket.packet.scrambled = true;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _NetPacket$[ebp]
  000b9	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  000be	89 45 fc	 mov	 DWORD PTR _NetPacket$[ebp], eax

; 405  : 
; 406  : 			usvalue = SHORT(NetPacket.value.l|NetPacket.value.b);

  000c1	0f b7 45 fc	 movzx	 eax, WORD PTR _NetPacket$[ebp]
  000c5	0f b7 4d fe	 movzx	 ecx, WORD PTR _NetPacket$[ebp+2]
  000c9	0b c1		 or	 eax, ecx
  000cb	66 89 45 f8	 mov	 WORD PTR _usvalue$[ebp], ax

; 407  : 			SendNetXCmd(XD_TEAMCHANGE, &usvalue, sizeof(usvalue));

  000cf	6a 02		 push	 2
  000d1	8d 45 f8	 lea	 eax, DWORD PTR _usvalue$[ebp]
  000d4	50		 push	 eax
  000d5	6a 0b		 push	 11			; 0000000bH
  000d7	e8 00 00 00 00	 call	 _SendNetXCmd
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@P_DoTeamsc:

; 408  : 		}
; 409  : 
; 410  : 		scramblecount++; //Increment, and get to the next player when we come back here next time.

  000df	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _scramblecount
  000e5	66 83 c0 01	 add	 ax, 1
  000e9	66 a3 00 00 00
	00		 mov	 WORD PTR _scramblecount, ax

; 411  : 	}

  000ef	eb 0f		 jmp	 SHORT $LN4@P_DoTeamsc
$LN3@P_DoTeamsc:

; 412  : 	else
; 413  : 		CV_SetValue(&cv_teamscramble, 0);

  000f1	6a 00		 push	 0
  000f3	68 00 00 00 00	 push	 OFFSET _cv_teamscramble
  000f8	e8 00 00 00 00	 call	 _CV_SetValue
  000fd	83 c4 08	 add	 esp, 8
$LN4@P_DoTeamsc:

; 414  : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
_P_DoTeamscrambling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _P_Ticker
_TEXT	SEGMENT
_spectators$1 = -16					; size = 4
_ssrings$2 = -12					; size = 4
_inwater$3 = -8						; size = 4
_i$ = -4						; size = 4
_P_Ticker PROC						; COMDAT

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 421  : 	INT32 i;
; 422  : 
; 423  : 	//Increment jointime even if paused.
; 424  : 	for (i = 0; i < MAXPLAYERS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_Ticker
$LN2@P_Ticker:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_Ticker:
  0001b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0001f	7d 2c		 jge	 SHORT $LN3@P_Ticker

; 425  : 		if (playeringame[i])

  00021	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00024	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0002c	74 1d		 je	 SHORT $LN35@P_Ticker

; 426  : 			++players[i].jointime;

  0002e	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00035	8b 88 f4 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+500]
  0003b	83 c1 01	 add	 ecx, 1
  0003e	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  00045	89 8a f4 01 00
	00		 mov	 DWORD PTR _players[edx+500], ecx
$LN35@P_Ticker:
  0004b	eb c5		 jmp	 SHORT $LN2@P_Ticker
$LN3@P_Ticker:

; 427  : 
; 428  : 	// Check for pause or menu up in single player
; 429  : 	if (paused || (!netgame && menuactive && !demoplayback))

  0004d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  00054	85 c0		 test	 eax, eax
  00056	75 1b		 jne	 SHORT $LN37@P_Ticker
  00058	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0005f	75 1f		 jne	 SHORT $LN36@P_Ticker
  00061	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _menuactive, 0
  00068	74 16		 je	 SHORT $LN36@P_Ticker
  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demoplayback, 0
  00071	75 0d		 jne	 SHORT $LN36@P_Ticker
$LN37@P_Ticker:

; 430  : 	{
; 431  : 		objectsdrawn = 0;

  00073	33 c0		 xor	 eax, eax
  00075	66 a3 00 00 00
	00		 mov	 WORD PTR _objectsdrawn, ax

; 432  : 		return;

  0007b	e9 9b 06 00 00	 jmp	 $LN1@P_Ticker
$LN36@P_Ticker:

; 433  : 	}
; 434  : 
; 435  : 	postimgtype = postimg_none;

  00080	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _postimgtype, 0

; 436  : 
; 437  : 	P_MapStart();

  0008a	e8 00 00 00 00	 call	 _P_MapStart
  0008f	90		 npad	 1

; 438  : 
; 439  : 	for (i = 0; i < MAXPLAYERS; i++)

  00090	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00097	eb 09		 jmp	 SHORT $LN7@P_Ticker
$LN5@P_Ticker:
  00099	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_Ticker:
  000a2	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000a6	7d 34		 jge	 SHORT $LN6@P_Ticker

; 440  : 		if (playeringame[i] && players[i].mo)

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000b3	74 25		 je	 SHORT $LN38@P_Ticker
  000b5	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000bc	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  000c3	74 15		 je	 SHORT $LN38@P_Ticker

; 441  : 			P_PlayerThink(&players[i]);

  000c5	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000cc	05 00 00 00 00	 add	 eax, OFFSET _players
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _P_PlayerThink
  000d7	83 c4 04	 add	 esp, 4
$LN38@P_Ticker:
  000da	eb bd		 jmp	 SHORT $LN5@P_Ticker
$LN6@P_Ticker:

; 442  : 
; 443  : 	// Keep track of how long they've been playing!
; 444  : 	totalplaytime++;

  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _totalplaytime
  000e1	83 c0 01	 add	 eax, 1
  000e4	a3 00 00 00 00	 mov	 DWORD PTR _totalplaytime, eax

; 445  : 
; 446  : ///////////////////////
; 447  : //SPECIAL STAGE STUFF//
; 448  : ///////////////////////
; 449  : 
; 450  : 	if (!useNightsSS && gamemap >= sstage_start && gamemap <= sstage_end)

  000e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _useNightsSS, 0
  000f0	0f 85 d4 02 00
	00		 jne	 $LN54@P_Ticker
  000f6	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000fd	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _sstage_start
  00104	3b c1		 cmp	 eax, ecx
  00106	0f 8c be 02 00
	00		 jl	 $LN54@P_Ticker
  0010c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00113	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _sstage_end
  0011a	3b c1		 cmp	 eax, ecx
  0011c	0f 8f a8 02 00
	00		 jg	 $LN54@P_Ticker

; 451  : 	{
; 452  : 		boolean inwater = false;

  00122	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _inwater$3[ebp], 0

; 453  : 
; 454  : 		// Can't drown in a special stage
; 455  : 		for (i = 0; i < MAXPLAYERS; i++)

  00129	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00130	eb 09		 jmp	 SHORT $LN10@P_Ticker
$LN8@P_Ticker:
  00132	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00135	83 c0 01	 add	 eax, 1
  00138	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@P_Ticker:
  0013b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0013f	7d 45		 jge	 SHORT $LN9@P_Ticker

; 456  : 		{
; 457  : 			if (!playeringame[i])

  00141	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00144	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0014c	75 02		 jne	 SHORT $LN40@P_Ticker

; 458  : 				continue;

  0014e	eb e2		 jmp	 SHORT $LN8@P_Ticker
$LN40@P_Ticker:

; 459  : 
; 460  : 			players[i].powers[pw_underwater] = players[i].powers[pw_spacetime] = 0;

  00150	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00157	b9 04 00 00 00	 mov	 ecx, 4
  0015c	6b d1 07	 imul	 edx, ecx, 7
  0015f	c7 84 10 38 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _players[eax+edx+56], 0
  0016a	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00171	b9 04 00 00 00	 mov	 ecx, 4
  00176	6b d1 06	 imul	 edx, ecx, 6
  00179	c7 84 10 38 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _players[eax+edx+56], 0

; 461  : 		}

  00184	eb ac		 jmp	 SHORT $LN8@P_Ticker
$LN9@P_Ticker:

; 462  : 
; 463  : 		if (sstimer < 15*TICRATE+6 && sstimer > 7 && mapheaderinfo[gamemap-1].speedmusic)

  00186	81 3d 00 00 00
	00 13 02 00 00	 cmp	 DWORD PTR _sstimer, 531	; 00000213H
  00190	7d 38		 jge	 SHORT $LN41@P_Ticker
  00192	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _sstimer, 7
  00199	7e 2f		 jle	 SHORT $LN41@P_Ticker
  0019b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  001a2	83 e8 01	 sub	 eax, 1
  001a5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001ab	83 b9 2c 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[ecx+300], 0
  001b2	74 16		 je	 SHORT $LN41@P_Ticker

; 464  : 			S_SpeedMusic(1.4f);

  001b4	51		 push	 ecx
  001b5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fb33333
  001bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c2	e8 00 00 00 00	 call	 _S_SpeedMusic
  001c7	83 c4 04	 add	 esp, 4
$LN41@P_Ticker:

; 465  : 
; 466  : 		if (sstimer < 7 && sstimer > 0) // The special stage time is up!

  001ca	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _sstimer, 7
  001d1	0f 8d b5 00 00
	00		 jge	 $LN45@P_Ticker
  001d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sstimer, 0
  001de	0f 8e a8 00 00
	00		 jle	 $LN45@P_Ticker

; 467  : 		{
; 468  : 			sstimer = 0;

  001e4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _sstimer, 0

; 469  : 			for (i = 0; i < MAXPLAYERS; i++)

  001ee	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001f5	eb 09		 jmp	 SHORT $LN13@P_Ticker
$LN11@P_Ticker:
  001f7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001fa	83 c0 01	 add	 eax, 1
  001fd	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@P_Ticker:
  00200	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00204	7d 57		 jge	 SHORT $LN12@P_Ticker

; 470  : 			{
; 471  : 				if (playeringame[i])

  00206	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00209	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00211	74 31		 je	 SHORT $LN43@P_Ticker

; 472  : 				{
; 473  : 					players[i].exiting = (14*TICRATE)/5 + 1;

  00213	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0021a	c7 80 30 01 00
	00 63 00 00 00	 mov	 DWORD PTR _players[eax+304], 99 ; 00000063H

; 474  : 					players[i].pflags &= ~PF_GLIDING;

  00224	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0022b	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  00231	81 e1 ff ff fe
	ff		 and	 ecx, -65537		; fffeffffH
  00237	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  0023e	89 8a ac 00 00
	00		 mov	 DWORD PTR _players[edx+172], ecx
$LN43@P_Ticker:

; 475  : 				}
; 476  : 
; 477  : 				if (i == consoleplayer)

  00244	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00247	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  0024d	75 0c		 jne	 SHORT $LN44@P_Ticker

; 478  : 					S_StartSound(NULL, sfx_lose);

  0024f	6a 5b		 push	 91			; 0000005bH
  00251	6a 00		 push	 0
  00253	e8 00 00 00 00	 call	 _S_StartSound
  00258	83 c4 08	 add	 esp, 8
$LN44@P_Ticker:

; 479  : 			}

  0025b	eb 9a		 jmp	 SHORT $LN11@P_Ticker
$LN12@P_Ticker:

; 480  : 
; 481  : 			if (mapheaderinfo[gamemap-1].speedmusic)

  0025d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00264	83 e8 01	 sub	 eax, 1
  00267	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0026d	83 b9 2c 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[ecx+300], 0
  00274	74 16		 je	 SHORT $LN45@P_Ticker

; 482  : 				S_SpeedMusic(1.0f);

  00276	51		 push	 ecx
  00277	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0027f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00284	e8 00 00 00 00	 call	 _S_SpeedMusic
  00289	83 c4 04	 add	 esp, 4
$LN45@P_Ticker:

; 483  : 		}
; 484  : 
; 485  : 		if (sstimer > 1) // As long as time isn't up...

  0028c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _sstimer, 1
  00293	0f 8e 31 01 00
	00		 jle	 $LN54@P_Ticker

; 486  : 		{
; 487  : 			UINT32 ssrings = 0;

  00299	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ssrings$2[ebp], 0

; 488  : 			// Count up the rings of all the players and see if
; 489  : 			// they've collected the required amount.
; 490  : 			for (i = 0; i < MAXPLAYERS; i++)

  002a0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002a7	eb 09		 jmp	 SHORT $LN16@P_Ticker
$LN14@P_Ticker:
  002a9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002ac	83 c0 01	 add	 eax, 1
  002af	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@P_Ticker:
  002b2	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  002b6	7d 63		 jge	 SHORT $LN15@P_Ticker

; 491  : 				if (playeringame[i])

  002b8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  002bb	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  002c3	74 54		 je	 SHORT $LN48@P_Ticker

; 492  : 				{
; 493  : 					ssrings += (players[i].mo->health-1);

  002c5	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  002cc	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  002d2	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  002d8	8b 45 f4	 mov	 eax, DWORD PTR _ssrings$2[ebp]
  002db	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  002df	89 4d f4	 mov	 DWORD PTR _ssrings$2[ebp], ecx

; 494  : 
; 495  : 					// If in water, deplete timer 6x as fast.
; 496  : 					if ((players[i].mo->eflags & MFE_TOUCHWATER)
; 497  : 						|| (players[i].mo->eflags & MFE_UNDERWATER))

  002e2	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  002e9	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  002ef	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  002f5	83 e2 04	 and	 edx, 4
  002f8	75 18		 jne	 SHORT $LN49@P_Ticker
  002fa	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00301	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00307	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0030d	83 e2 08	 and	 edx, 8
  00310	74 07		 je	 SHORT $LN48@P_Ticker
$LN49@P_Ticker:

; 498  : 						inwater = true;

  00312	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _inwater$3[ebp], 1
$LN48@P_Ticker:

; 499  : 				}

  00319	eb 8e		 jmp	 SHORT $LN14@P_Ticker
$LN15@P_Ticker:

; 500  : 
; 501  : 			if (ssrings >= totalrings && totalrings > 0)

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _ssrings$2[ebp]
  0031e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _totalrings
  00324	72 79		 jb	 SHORT $LN50@P_Ticker
  00326	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _totalrings, 0
  0032d	76 70		 jbe	 SHORT $LN50@P_Ticker

; 502  : 			{
; 503  : 				// Halt all the players
; 504  : 				for (i = 0; i < MAXPLAYERS; i++)

  0032f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00336	eb 09		 jmp	 SHORT $LN19@P_Ticker
$LN17@P_Ticker:
  00338	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0033b	83 c0 01	 add	 eax, 1
  0033e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN19@P_Ticker:
  00341	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00345	7d 48		 jge	 SHORT $LN18@P_Ticker

; 505  : 					if (playeringame[i])

  00347	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0034a	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00352	74 39		 je	 SHORT $LN51@P_Ticker

; 506  : 					{
; 507  : 						players[i].mo->momx = players[i].mo->momy = 0;

  00354	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0035b	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00361	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  00368	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  0036f	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _players[edx]
  00375	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 508  : 						players[i].exiting = (14*TICRATE)/5 + 1;

  0037c	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00383	c7 80 30 01 00
	00 63 00 00 00	 mov	 DWORD PTR _players[eax+304], 99 ; 00000063H
$LN51@P_Ticker:

; 509  : 					}

  0038d	eb a9		 jmp	 SHORT $LN17@P_Ticker
$LN18@P_Ticker:

; 510  : 
; 511  : 				sstimer = 0;

  0038f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _sstimer, 0

; 512  : 
; 513  : 				P_GiveEmerald();

  00399	e8 00 00 00 00	 call	 _P_GiveEmerald
  0039e	90		 npad	 1
$LN50@P_Ticker:

; 514  : 			}
; 515  : 
; 516  : 			// Decrement the timer
; 517  : 			if (!cv_objectplace.value)

  0039f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_objectplace+20, 0
  003a6	75 22		 jne	 SHORT $LN54@P_Ticker

; 518  : 			{
; 519  : 				if (inwater)

  003a8	83 7d f8 00	 cmp	 DWORD PTR _inwater$3[ebp], 0
  003ac	74 0f		 je	 SHORT $LN53@P_Ticker

; 520  : 					sstimer -= 6;

  003ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _sstimer
  003b3	83 e8 06	 sub	 eax, 6
  003b6	a3 00 00 00 00	 mov	 DWORD PTR _sstimer, eax
  003bb	eb 0d		 jmp	 SHORT $LN54@P_Ticker
$LN53@P_Ticker:

; 521  : 				else
; 522  : 					sstimer--;

  003bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _sstimer
  003c2	83 e8 01	 sub	 eax, 1
  003c5	a3 00 00 00 00	 mov	 DWORD PTR _sstimer, eax
$LN54@P_Ticker:

; 523  : 			}
; 524  : 		}
; 525  : 	}
; 526  : /////////////////////////////////////////
; 527  : 
; 528  : 	if (runemeraldmanager)

  003ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _runemeraldmanager, 0
  003d1	74 06		 je	 SHORT $LN55@P_Ticker

; 529  : 		P_EmeraldManager(); // Power stone mode

  003d3	e8 00 00 00 00	 call	 _P_EmeraldManager
  003d8	90		 npad	 1
$LN55@P_Ticker:

; 530  : 
; 531  : 	P_RunThinkers();

  003d9	e8 00 00 00 00	 call	 _P_RunThinkers
  003de	90		 npad	 1

; 532  : 
; 533  : 	// Run any "after all the other thinkers" stuff
; 534  : 	for (i = 0; i < MAXPLAYERS; i++)

  003df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003e6	eb 09		 jmp	 SHORT $LN22@P_Ticker
$LN20@P_Ticker:
  003e8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003eb	83 c0 01	 add	 eax, 1
  003ee	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN22@P_Ticker:
  003f1	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  003f5	7d 34		 jge	 SHORT $LN21@P_Ticker

; 535  : 		if (playeringame[i] && players[i].mo)

  003f7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003fa	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00402	74 25		 je	 SHORT $LN56@P_Ticker
  00404	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0040b	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00412	74 15		 je	 SHORT $LN56@P_Ticker

; 536  : 			P_PlayerAfterThink(&players[i]);

  00414	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0041b	05 00 00 00 00	 add	 eax, OFFSET _players
  00420	50		 push	 eax
  00421	e8 00 00 00 00	 call	 _P_PlayerAfterThink
  00426	83 c4 04	 add	 esp, 4
$LN56@P_Ticker:
  00429	eb bd		 jmp	 SHORT $LN20@P_Ticker
$LN21@P_Ticker:

; 537  : 
; 538  : 	// Run shield positioning
; 539  : 	P_RunShields();

  0042b	e8 00 00 00 00	 call	 _P_RunShields
  00430	90		 npad	 1

; 540  : 
; 541  : 	P_UpdateSpecials();

  00431	e8 00 00 00 00	 call	 _P_UpdateSpecials
  00436	90		 npad	 1

; 542  : 	P_RespawnSpecials();

  00437	e8 00 00 00 00	 call	 _P_RespawnSpecials
  0043c	90		 npad	 1

; 543  : 
; 544  : 	if (cv_objectplace.value)

  0043d	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_objectplace+20, 0
  00444	74 1c		 je	 SHORT $LN58@P_Ticker

; 545  : 	{
; 546  : 		objectsdrawn = 0;

  00446	33 c0		 xor	 eax, eax
  00448	66 a3 00 00 00
	00		 mov	 WORD PTR _objectsdrawn, ax

; 547  : 
; 548  : 		if (P_FreezeObjectplace())

  0044e	e8 00 00 00 00	 call	 _P_FreezeObjectplace
  00453	85 c0		 test	 eax, eax
  00455	74 0b		 je	 SHORT $LN58@P_Ticker

; 549  : 		{
; 550  : 			P_MapEnd();

  00457	e8 00 00 00 00	 call	 _P_MapEnd
  0045c	90		 npad	 1

; 551  : 			return;

  0045d	e9 b9 02 00 00	 jmp	 $LN1@P_Ticker
$LN58@P_Ticker:

; 552  : 		}
; 553  : 	}
; 554  : 
; 555  : 	leveltime++;

  00462	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  00467	83 c0 01	 add	 eax, 1
  0046a	a3 00 00 00 00	 mov	 DWORD PTR _leveltime, eax

; 556  : 	timeinmap++;

  0046f	a1 00 00 00 00	 mov	 eax, DWORD PTR _timeinmap
  00474	83 c0 01	 add	 eax, 1
  00477	a3 00 00 00 00	 mov	 DWORD PTR _timeinmap, eax

; 557  : 
; 558  : 	if (gametype == GT_TAG)

  0047c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00483	83 f8 03	 cmp	 eax, 3
  00486	0f 85 53 01 00
	00		 jne	 $LN30@P_Ticker

; 559  : 	{
; 560  : 		// tell the netgame who the initial IT person is.
; 561  : 		// this can't happen on level load, otherwise you have
; 562  : 		// to open the console to see the message.
; 563  : 		if (leveltime == TICRATE)

  0048c	83 3d 00 00 00
	00 23		 cmp	 DWORD PTR _leveltime, 35 ; 00000023H
  00493	75 48		 jne	 SHORT $LN24@P_Ticker

; 564  : 		{
; 565  : 			for (i=0; i < MAXPLAYERS; i++)

  00495	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0049c	eb 09		 jmp	 SHORT $LN25@P_Ticker
$LN23@P_Ticker:
  0049e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004a1	83 c0 01	 add	 eax, 1
  004a4	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN25@P_Ticker:
  004a7	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  004ab	7d 30		 jge	 SHORT $LN24@P_Ticker

; 566  : 			{
; 567  : 				if (players[i].pflags & PF_TAGIT)

  004ad	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  004b4	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  004ba	81 e1 00 00 00
	10		 and	 ecx, 268435456		; 10000000H
  004c0	74 19		 je	 SHORT $LN61@P_Ticker

; 568  : 				{
; 569  : 					CONS_Printf("%s is it!\n", player_names[i]); // Tell everyone who is it!

  004c2	6b 45 fc 16	 imul	 eax, DWORD PTR _i$[ebp], 22
  004c6	05 00 00 00 00	 add	 eax, OFFSET _player_names
  004cb	50		 push	 eax
  004cc	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FKKLEDAE@?$CFs?5is?5it?$CB?6@
  004d1	e8 00 00 00 00	 call	 _CONS_Printf
  004d6	83 c4 08	 add	 esp, 8

; 570  : 					break;

  004d9	eb 02		 jmp	 SHORT $LN24@P_Ticker
$LN61@P_Ticker:

; 571  : 				}
; 572  : 			}

  004db	eb c1		 jmp	 SHORT $LN23@P_Ticker
$LN24@P_Ticker:

; 573  : 		}
; 574  : 
; 575  : 		//increment survivor scores
; 576  : 		if (leveltime % TICRATE == 0 && leveltime > (hidetime * TICRATE))

  004dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  004e2	33 d2		 xor	 edx, edx
  004e4	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  004e9	f7 f1		 div	 ecx
  004eb	85 d2		 test	 edx, edx
  004ed	0f 85 ec 00 00
	00		 jne	 $LN30@P_Ticker
  004f3	6b 05 00 00 00
	00 23		 imul	 eax, DWORD PTR _hidetime, 35
  004fa	39 05 00 00 00
	00		 cmp	 DWORD PTR _leveltime, eax
  00500	0f 86 d9 00 00
	00		 jbe	 $LN30@P_Ticker

; 577  : 		{
; 578  : 			INT32 spectators = 0;

  00506	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _spectators$1[ebp], 0

; 579  : 
; 580  : 			for (i=0; i < MAXPLAYERS; i++) //count spectators to subtract from the player count.

  0050d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00514	eb 09		 jmp	 SHORT $LN28@P_Ticker
$LN26@P_Ticker:
  00516	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00519	83 c0 01	 add	 eax, 1
  0051c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN28@P_Ticker:
  0051f	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00523	7d 1d		 jge	 SHORT $LN27@P_Ticker

; 581  : 			{
; 582  : 				if (players[i].spectator)

  00525	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0052c	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  00533	85 c9		 test	 ecx, ecx
  00535	74 09		 je	 SHORT $LN63@P_Ticker

; 583  : 					spectators++;

  00537	8b 45 f0	 mov	 eax, DWORD PTR _spectators$1[ebp]
  0053a	83 c0 01	 add	 eax, 1
  0053d	89 45 f0	 mov	 DWORD PTR _spectators$1[ebp], eax
$LN63@P_Ticker:

; 584  : 			}

  00540	eb d4		 jmp	 SHORT $LN26@P_Ticker
$LN27@P_Ticker:

; 585  : 
; 586  : 			for (i=0; i < MAXPLAYERS; i++)

  00542	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00549	eb 09		 jmp	 SHORT $LN31@P_Ticker
$LN29@P_Ticker:
  0054b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0054e	83 c0 01	 add	 eax, 1
  00551	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN31@P_Ticker:
  00554	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00558	0f 8d 81 00 00
	00		 jge	 $LN30@P_Ticker

; 587  : 			{
; 588  : 				if (!(players[i].pflags & PF_TAGIT) && !(players[i].pflags & PF_TAGGED)
; 589  : 					&& !players[i].spectator && playeringame[i] && players[i].playerstate == PST_LIVE)

  0055e	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00565	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  0056b	81 e1 00 00 00
	10		 and	 ecx, 268435456		; 10000000H
  00571	75 67		 jne	 SHORT $LN64@P_Ticker
  00573	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0057a	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  00580	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  00586	75 52		 jne	 SHORT $LN64@P_Ticker
  00588	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0058f	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  00596	85 c9		 test	 ecx, ecx
  00598	75 40		 jne	 SHORT $LN64@P_Ticker
  0059a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0059d	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  005a5	74 33		 je	 SHORT $LN64@P_Ticker
  005a7	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  005ae	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _players[eax+4], 0
  005b5	75 23		 jne	 SHORT $LN64@P_Ticker

; 590  : 					P_AddPlayerScore(&players[i], (D_NumPlayers() - spectators) / 2); //points given is the number of participating players divided by two.

  005b7	e8 00 00 00 00	 call	 _D_NumPlayers
  005bc	2b 45 f0	 sub	 eax, DWORD PTR _spectators$1[ebp]
  005bf	99		 cdq
  005c0	2b c2		 sub	 eax, edx
  005c2	d1 f8		 sar	 eax, 1
  005c4	50		 push	 eax
  005c5	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  005cc	05 00 00 00 00	 add	 eax, OFFSET _players
  005d1	50		 push	 eax
  005d2	e8 00 00 00 00	 call	 _P_AddPlayerScore
  005d7	83 c4 08	 add	 esp, 8
$LN64@P_Ticker:

; 591  : 			}

  005da	e9 6c ff ff ff	 jmp	 $LN29@P_Ticker
$LN30@P_Ticker:

; 592  : 		}
; 593  : 	}
; 594  : 
; 595  : 	if (gametype == GT_CTF || (gametype == GT_MATCH && cv_matchtype.value))

  005df	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  005e6	83 f8 04	 cmp	 eax, 4
  005e9	74 15		 je	 SHORT $LN66@P_Ticker
  005eb	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  005f2	83 f8 01	 cmp	 eax, 1
  005f5	75 6f		 jne	 SHORT $LN70@P_Ticker
  005f7	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  005fe	74 66		 je	 SHORT $LN70@P_Ticker
$LN66@P_Ticker:

; 596  : 	{
; 597  : 		// Automatic team balance for CTF and team match
; 598  : 		if (leveltime % (TICRATE * 5) == 0) //only check once per five seconds for the sake of CPU conservation.

  00600	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  00605	33 d2		 xor	 edx, edx
  00607	b9 af 00 00 00	 mov	 ecx, 175		; 000000afH
  0060c	f7 f1		 div	 ecx
  0060e	85 d2		 test	 edx, edx
  00610	75 2a		 jne	 SHORT $LN68@P_Ticker

; 599  : 		{
; 600  : 			// Do not attempt to autobalance and scramble teams at the same time.
; 601  : 			// Only the server should execute this. No verified admins, please.
; 602  : 			if ((cv_autobalance.value && !cv_teamscramble.value) && cv_allowteamchange.value && server)

  00612	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_autobalance+20, 0
  00619	74 21		 je	 SHORT $LN68@P_Ticker
  0061b	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_teamscramble+20, 0
  00622	75 18		 jne	 SHORT $LN68@P_Ticker
  00624	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_allowteamchange+20, 0
  0062b	74 0f		 je	 SHORT $LN68@P_Ticker
  0062d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  00634	74 06		 je	 SHORT $LN68@P_Ticker

; 603  : 				P_DoAutobalanceTeams();

  00636	e8 00 00 00 00	 call	 _P_DoAutobalanceTeams
  0063b	90		 npad	 1
$LN68@P_Ticker:

; 604  : 		}
; 605  : 
; 606  : 		// Team scramble code for team match and CTF.
; 607  : 		if ((leveltime % (TICRATE/7)) == 0)

  0063c	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  00641	33 d2		 xor	 edx, edx
  00643	b9 05 00 00 00	 mov	 ecx, 5
  00648	f7 f1		 div	 ecx
  0064a	85 d2		 test	 edx, edx
  0064c	75 18		 jne	 SHORT $LN70@P_Ticker

; 608  : 		{
; 609  : 			// If we run out of time in the level, the beauty is that
; 610  : 			// the Y_Ticker() team scramble code will pick it up.
; 611  : 			if (cv_teamscramble.value && server)

  0064e	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_teamscramble+20, 0
  00655	74 0f		 je	 SHORT $LN70@P_Ticker
  00657	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  0065e	74 06		 je	 SHORT $LN70@P_Ticker

; 612  : 				P_DoTeamscrambling();

  00660	e8 00 00 00 00	 call	 _P_DoTeamscrambling
  00665	90		 npad	 1
$LN70@P_Ticker:

; 613  : 		}
; 614  : 	}
; 615  : 
; 616  : 	if (countdowntimer)

  00666	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _countdowntimer, 0
  0066d	74 7a		 je	 SHORT $LN33@P_Ticker

; 617  : 	{
; 618  : 		countdowntimer--;

  0066f	a1 00 00 00 00	 mov	 eax, DWORD PTR _countdowntimer
  00674	83 e8 01	 sub	 eax, 1
  00677	a3 00 00 00 00	 mov	 DWORD PTR _countdowntimer, eax

; 619  : 		if (countdowntimer <= 0)

  0067c	75 6b		 jne	 SHORT $LN33@P_Ticker

; 620  : 		{
; 621  : 			countdowntimer = 0;

  0067e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _countdowntimer, 0

; 622  : 			countdowntimeup = true;

  00688	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _countdowntimeup, 1

; 623  : 			for (i = 0; i < MAXPLAYERS; i++)

  0068f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00696	eb 09		 jmp	 SHORT $LN34@P_Ticker
$LN32@P_Ticker:
  00698	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0069b	83 c0 01	 add	 eax, 1
  0069e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN34@P_Ticker:
  006a1	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  006a5	7d 42		 jge	 SHORT $LN33@P_Ticker

; 624  : 			{
; 625  : 				if (!playeringame[i])

  006a7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  006aa	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  006b2	75 02		 jne	 SHORT $LN73@P_Ticker

; 626  : 					continue;

  006b4	eb e2		 jmp	 SHORT $LN32@P_Ticker
$LN73@P_Ticker:

; 627  : 
; 628  : 				if (!players[i].mo)

  006b6	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  006bd	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  006c4	75 02		 jne	 SHORT $LN74@P_Ticker

; 629  : 					continue;

  006c6	eb d0		 jmp	 SHORT $LN32@P_Ticker
$LN74@P_Ticker:

; 630  : 
; 631  : 				P_DamageMobj(players[i].mo, NULL, NULL, 10000);

  006c8	68 10 27 00 00	 push	 10000			; 00002710H
  006cd	6a 00		 push	 0
  006cf	6a 00		 push	 0
  006d1	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  006d8	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  006de	51		 push	 ecx
  006df	e8 00 00 00 00	 call	 _P_DamageMobj
  006e4	83 c4 10	 add	 esp, 16			; 00000010H

; 632  : 			}

  006e7	eb af		 jmp	 SHORT $LN32@P_Ticker
$LN33@P_Ticker:

; 633  : 		}
; 634  : 	}
; 635  : 
; 636  : 	if (countdown > 1)

  006e9	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _countdown, 1
  006f0	76 0d		 jbe	 SHORT $LN75@P_Ticker

; 637  : 		countdown--;

  006f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _countdown
  006f7	83 e8 01	 sub	 eax, 1
  006fa	a3 00 00 00 00	 mov	 DWORD PTR _countdown, eax
$LN75@P_Ticker:

; 638  : 
; 639  : 	if (countdown2)

  006ff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _countdown2, 0
  00706	74 0d		 je	 SHORT $LN76@P_Ticker

; 640  : 		countdown2--;

  00708	a1 00 00 00 00	 mov	 eax, DWORD PTR _countdown2
  0070d	83 e8 01	 sub	 eax, 1
  00710	a3 00 00 00 00	 mov	 DWORD PTR _countdown2, eax
$LN76@P_Ticker:

; 641  : 
; 642  : 	P_MapEnd();

  00715	e8 00 00 00 00	 call	 _P_MapEnd
  0071a	90		 npad	 1
$LN1@P_Ticker:

; 643  : 
; 644  : //	Z_CheckMemCleanup();
; 645  : }

  0071b	5f		 pop	 edi
  0071c	5e		 pop	 esi
  0071d	5b		 pop	 ebx
  0071e	8b e5		 mov	 esp, ebp
  00720	5d		 pop	 ebp
  00721	c3		 ret	 0
_P_Ticker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _Command_CountMobjs_f
_TEXT	SEGMENT
_j$1 = -16						; size = 4
_count$ = -12						; size = 4
_i$ = -8						; size = 4
_th$ = -4						; size = 4
_Command_CountMobjs_f PROC				; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	thinker_t *th;
; 112  : 	mobjtype_t i;
; 113  : 	INT32 count;
; 114  : 
; 115  : 	if (gamestate != GS_LEVEL)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  00010	74 24		 je	 SHORT $LN14@Command_Co

; 116  : 	{
; 117  : 		CONS_Printf("%s", text[MUSTBEINLEVEL]);

  00012	b8 04 00 00 00	 mov	 eax, 4
  00017	69 c8 fa 00 00
	00		 imul	 ecx, eax, 250
  0001d	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00023	52		 push	 edx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00029	e8 00 00 00 00	 call	 _CONS_Printf
  0002e	83 c4 08	 add	 esp, 8

; 118  : 		return;

  00031	e9 60 01 00 00	 jmp	 $LN1@Command_Co
$LN14@Command_Co:

; 119  : 	}
; 120  : 
; 121  : 	if (COM_Argc() >= 2)

  00036	e8 00 00 00 00	 call	 _COM_Argc
  0003b	83 f8 02	 cmp	 eax, 2
  0003e	0f 82 bf 00 00
	00		 jb	 $LN15@Command_Co

; 122  : 	{
; 123  : 		size_t j;
; 124  : 		for (j = 1; j < COM_Argc(); j++)

  00044	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _j$1[ebp], 1
  0004b	eb 09		 jmp	 SHORT $LN4@Command_Co
$LN2@Command_Co:
  0004d	8b 45 f0	 mov	 eax, DWORD PTR _j$1[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f0	 mov	 DWORD PTR _j$1[ebp], eax
$LN4@Command_Co:
  00056	e8 00 00 00 00	 call	 _COM_Argc
  0005b	39 45 f0	 cmp	 DWORD PTR _j$1[ebp], eax
  0005e	0f 83 9a 00 00
	00		 jae	 $LN3@Command_Co

; 125  : 		{
; 126  : 			i = atoi(COM_Argv(j));

  00064	8b 45 f0	 mov	 eax, DWORD PTR _j$1[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _COM_Argv
  0006d	83 c4 04	 add	 esp, 4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _atoi
  00076	83 c4 04	 add	 esp, 4
  00079	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 127  : 			if (i >= NUMMOBJTYPES)

  0007c	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 446	; 000001beH
  00083	7c 18		 jl	 SHORT $LN16@Command_Co

; 128  : 			{
; 129  : 				CONS_Printf("Object number %d out of range (max %d).\n", i, NUMMOBJTYPES-1);

  00085	68 bd 01 00 00	 push	 445			; 000001bdH
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GOKGCFIC@Object?5number?5?$CFd?5out?5of?5range?5?$CI@
  00093	e8 00 00 00 00	 call	 _CONS_Printf
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  : 				continue;

  0009b	eb b0		 jmp	 SHORT $LN2@Command_Co
$LN16@Command_Co:

; 131  : 			}
; 132  : 
; 133  : 			count = 0;

  0009d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 134  : 
; 135  : 			for (th = thinkercap.next; th != &thinkercap; th = th->next)

  000a4	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  000a9	89 45 fc	 mov	 DWORD PTR _th$[ebp], eax
  000ac	eb 09		 jmp	 SHORT $LN7@Command_Co
$LN5@Command_Co:
  000ae	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b4	89 4d fc	 mov	 DWORD PTR _th$[ebp], ecx
$LN7@Command_Co:
  000b7	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _th$[ebp], OFFSET _thinkercap
  000be	74 24		 je	 SHORT $LN6@Command_Co

; 136  : 			{
; 137  : 				if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000c3	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  000ca	74 02		 je	 SHORT $LN17@Command_Co

; 138  : 					continue;

  000cc	eb e0		 jmp	 SHORT $LN5@Command_Co
$LN17@Command_Co:

; 139  : 
; 140  : 				if (((mobj_t *)th)->type == i)

  000ce	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000d1	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  000d4	3b 4d f8	 cmp	 ecx, DWORD PTR _i$[ebp]
  000d7	75 09		 jne	 SHORT $LN18@Command_Co

; 141  : 					count++;

  000d9	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax
$LN18@Command_Co:

; 142  : 			}

  000e2	eb ca		 jmp	 SHORT $LN5@Command_Co
$LN6@Command_Co:

; 143  : 
; 144  : 			CONS_Printf("There are %d objects of type %d currently in the level.\n", count, i);

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d f4	 mov	 ecx, DWORD PTR _count$[ebp]
  000eb	51		 push	 ecx
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@FKAMKOGD@There?5are?5?$CFd?5objects?5of?5type?5?$CFd@
  000f1	e8 00 00 00 00	 call	 _CONS_Printf
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 		}

  000f9	e9 4f ff ff ff	 jmp	 $LN2@Command_Co
$LN3@Command_Co:

; 146  : 		return;

  000fe	e9 93 00 00 00	 jmp	 $LN1@Command_Co
$LN15@Command_Co:

; 147  : 	}
; 148  : 
; 149  : 	CONS_Printf("Count of active objects in level:\n");

  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@MCFKLOKE@Count?5of?5active?5objects?5in?5leve@
  00108	e8 00 00 00 00	 call	 _CONS_Printf
  0010d	83 c4 04	 add	 esp, 4

; 150  : 
; 151  : 	for (i = 0; i < NUMMOBJTYPES; i++)

  00110	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN10@Command_Co
$LN8@Command_Co:
  00119	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011c	83 c0 01	 add	 eax, 1
  0011f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Command_Co:
  00122	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 446	; 000001beH
  00129	7d 5e		 jge	 SHORT $LN9@Command_Co

; 152  : 	{
; 153  : 		count = 0;

  0012b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 154  : 
; 155  : 		for (th = thinkercap.next; th != &thinkercap; th = th->next)

  00132	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00137	89 45 fc	 mov	 DWORD PTR _th$[ebp], eax
  0013a	eb 09		 jmp	 SHORT $LN13@Command_Co
$LN11@Command_Co:
  0013c	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0013f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00142	89 4d fc	 mov	 DWORD PTR _th$[ebp], ecx
$LN13@Command_Co:
  00145	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _th$[ebp], OFFSET _thinkercap
  0014c	74 24		 je	 SHORT $LN12@Command_Co

; 156  : 		{
; 157  : 			if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00151	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  00158	74 02		 je	 SHORT $LN19@Command_Co

; 158  : 				continue;

  0015a	eb e0		 jmp	 SHORT $LN11@Command_Co
$LN19@Command_Co:

; 159  : 
; 160  : 			if (((mobj_t *)th)->type == i)

  0015c	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0015f	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  00162	3b 4d f8	 cmp	 ecx, DWORD PTR _i$[ebp]
  00165	75 09		 jne	 SHORT $LN20@Command_Co

; 161  : 				count++;

  00167	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax
$LN20@Command_Co:

; 162  : 		}

  00170	eb ca		 jmp	 SHORT $LN11@Command_Co
$LN12@Command_Co:

; 163  : 
; 164  : 		CONS_Printf("%d: %d\n", i, count);

  00172	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  00175	50		 push	 eax
  00176	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00179	51		 push	 ecx
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6@
  0017f	e8 00 00 00 00	 call	 _CONS_Printf
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 	}

  00187	eb 90		 jmp	 SHORT $LN8@Command_Co
$LN9@Command_Co:

; 166  : 	CONS_Printf("Done\n");

  00189	68 00 00 00 00	 push	 OFFSET ??_C@_05KOJMJHML@Done?6@
  0018e	e8 00 00 00 00	 call	 _CONS_Printf
  00193	83 c4 04	 add	 esp, 4
$LN1@Command_Co:

; 167  : }

  00196	5f		 pop	 edi
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
_Command_CountMobjs_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_tick.c
;	COMDAT _Command_Numthinkers_f
_TEXT	SEGMENT
tv76 = -84						; size = 4
_think$ = -16						; size = 4
_action$ = -12						; size = 4
_count$ = -8						; size = 4
_num$ = -4						; size = 4
_Command_Numthinkers_f PROC				; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 44   : 	INT32 num;
; 45   : 	INT32 count = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 46   : 	actionf_p1 action;
; 47   : 	thinker_t *think;
; 48   : 
; 49   : 	if (gamestate != GS_LEVEL)

  00010	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  00017	74 24		 je	 SHORT $LN7@Command_Nu

; 50   : 	{
; 51   : 		CONS_Printf("%s", text[MUSTBEINLEVEL]);

  00019	b8 04 00 00 00	 mov	 eax, 4
  0001e	69 c8 fa 00 00
	00		 imul	 ecx, eax, 250
  00024	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0002a	52		 push	 edx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00030	e8 00 00 00 00	 call	 _CONS_Printf
  00035	83 c4 08	 add	 esp, 8

; 52   : 		return;

  00038	e9 46 01 00 00	 jmp	 $LN1@Command_Nu
$LN7@Command_Nu:

; 53   : 	}
; 54   : 
; 55   : 	if (COM_Argc() < 2)

  0003d	e8 00 00 00 00	 call	 _COM_Argc
  00042	83 f8 02	 cmp	 eax, 2
  00045	73 12		 jae	 SHORT $LN8@Command_Nu

; 56   : 	{
; 57   : 		CONS_Printf("numthinkers <#>: Count number of thinkers\n\t1: P_MobjThinker\n\t2: P_RainThinker\n\t3: P_SnowThinker\n\t4: P_NullPrecipThinker\n\t5: T_Friction\n\t6: T_Pusher\n\t7: P_RemoveThinkerDelayed\n");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0LA@FNICNMBH@numthinkers?5?$DM?$CD?$DO?3?5Count?5number?5o@
  0004c	e8 00 00 00 00	 call	 _CONS_Printf
  00051	83 c4 04	 add	 esp, 4

; 58   : 		return;

  00054	e9 2a 01 00 00	 jmp	 $LN1@Command_Nu
$LN8@Command_Nu:

; 59   : 	}
; 60   : 
; 61   : 	num = atoi(COM_Argv(1));

  00059	6a 01		 push	 1
  0005b	e8 00 00 00 00	 call	 _COM_Argv
  00060	83 c4 04	 add	 esp, 4
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _atoi
  00069	83 c4 04	 add	 esp, 4
  0006c	89 45 fc	 mov	 DWORD PTR _num$[ebp], eax

; 62   : 
; 63   : 	switch (num)

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _num$[ebp]
  00072	89 45 ac	 mov	 DWORD PTR tv76[ebp], eax
  00075	8b 4d ac	 mov	 ecx, DWORD PTR tv76[ebp]
  00078	83 e9 01	 sub	 ecx, 1
  0007b	89 4d ac	 mov	 DWORD PTR tv76[ebp], ecx
  0007e	83 7d ac 06	 cmp	 DWORD PTR tv76[ebp], 6
  00082	0f 87 a7 00 00
	00		 ja	 $LN16@Command_Nu
  00088	8b 55 ac	 mov	 edx, DWORD PTR tv76[ebp]
  0008b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN19@Command_Nu[edx*4]
$LN9@Command_Nu:

; 64   : 	{
; 65   : 		case 1:
; 66   : 			action = (actionf_p1)P_MobjThinker;

  00092	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _P_MobjThinker

; 67   : 			CONS_Printf("Number of P_MobjThinker: ");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HNHHCFGP@Number?5of?5P_MobjThinker?3?5@
  0009e	e8 00 00 00 00	 call	 _CONS_Printf
  000a3	83 c4 04	 add	 esp, 4

; 68   : 			break;

  000a6	e9 93 00 00 00	 jmp	 $LN2@Command_Nu
$LN10@Command_Nu:

; 69   : 		case 2:
; 70   : 			action = (actionf_p1)P_RainThinker;

  000ab	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _P_RainThinker

; 71   : 			CONS_Printf("Number of P_RainThinker: ");

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HGPMHGMJ@Number?5of?5P_RainThinker?3?5@
  000b7	e8 00 00 00 00	 call	 _CONS_Printf
  000bc	83 c4 04	 add	 esp, 4

; 72   : 			break;

  000bf	eb 7d		 jmp	 SHORT $LN2@Command_Nu
$LN11@Command_Nu:

; 73   : 		case 3:
; 74   : 			action = (actionf_p1)P_SnowThinker;

  000c1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _P_SnowThinker

; 75   : 			CONS_Printf("Number of P_SnowThinker: ");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PGAFBNCE@Number?5of?5P_SnowThinker?3?5@
  000cd	e8 00 00 00 00	 call	 _CONS_Printf
  000d2	83 c4 04	 add	 esp, 4

; 76   : 			break;

  000d5	eb 67		 jmp	 SHORT $LN2@Command_Nu
$LN12@Command_Nu:

; 77   : 		case 4:
; 78   : 			action = (actionf_p1)P_NullPrecipThinker;

  000d7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _P_NullPrecipThinker

; 79   : 			CONS_Printf("Number of P_NullPrecipThinker: ");

  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DBKJMADN@Number?5of?5P_NullPrecipThinker?3?5@
  000e3	e8 00 00 00 00	 call	 _CONS_Printf
  000e8	83 c4 04	 add	 esp, 4

; 80   : 			break;

  000eb	eb 51		 jmp	 SHORT $LN2@Command_Nu
$LN13@Command_Nu:

; 81   : 		case 5:
; 82   : 			action = (actionf_p1)T_Friction;

  000ed	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _T_Friction

; 83   : 			CONS_Printf("Number of T_Friction: ");

  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OIGPEGKM@Number?5of?5T_Friction?3?5@
  000f9	e8 00 00 00 00	 call	 _CONS_Printf
  000fe	83 c4 04	 add	 esp, 4

; 84   : 			break;

  00101	eb 3b		 jmp	 SHORT $LN2@Command_Nu
$LN14@Command_Nu:

; 85   : 		case 6:
; 86   : 			action = (actionf_p1)T_Pusher;

  00103	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _T_Pusher

; 87   : 			CONS_Printf("Number of T_Pusher: ");

  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PLCCJBKO@Number?5of?5T_Pusher?3?5@
  0010f	e8 00 00 00 00	 call	 _CONS_Printf
  00114	83 c4 04	 add	 esp, 4

; 88   : 			break;

  00117	eb 25		 jmp	 SHORT $LN2@Command_Nu
$LN15@Command_Nu:

; 89   : 		case 7:
; 90   : 			action = (actionf_p1)P_RemoveThinkerDelayed;

  00119	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _action$[ebp], OFFSET _P_RemoveThinkerDelayed

; 91   : 			CONS_Printf("Number of P_RemoveThinkerDelayed: ");

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BGHFHHDB@Number?5of?5P_RemoveThinkerDelaye@
  00125	e8 00 00 00 00	 call	 _CONS_Printf
  0012a	83 c4 04	 add	 esp, 4

; 92   : 			break;

  0012d	eb 0f		 jmp	 SHORT $LN2@Command_Nu
$LN16@Command_Nu:

; 93   : 		default:
; 94   : 			CONS_Printf("That is not a valid number.\n");

  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@INBEMBFC@That?5is?5not?5a?5valid?5number?4?6@
  00134	e8 00 00 00 00	 call	 _CONS_Printf
  00139	83 c4 04	 add	 esp, 4

; 95   : 			return;

  0013c	eb 45		 jmp	 SHORT $LN1@Command_Nu
$LN2@Command_Nu:

; 96   : 	}
; 97   : 
; 98   : 	for (think = thinkercap.next; think != &thinkercap; think = think->next)

  0013e	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00143	89 45 f0	 mov	 DWORD PTR _think$[ebp], eax
  00146	eb 09		 jmp	 SHORT $LN6@Command_Nu
$LN4@Command_Nu:
  00148	8b 45 f0	 mov	 eax, DWORD PTR _think$[ebp]
  0014b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014e	89 4d f0	 mov	 DWORD PTR _think$[ebp], ecx
$LN6@Command_Nu:
  00151	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _think$[ebp], OFFSET _thinkercap
  00158	74 18		 je	 SHORT $LN5@Command_Nu

; 99   : 	{
; 100  : 		if (think->function.acp1 != action)

  0015a	8b 45 f0	 mov	 eax, DWORD PTR _think$[ebp]
  0015d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00160	3b 4d f4	 cmp	 ecx, DWORD PTR _action$[ebp]
  00163	74 02		 je	 SHORT $LN17@Command_Nu

; 101  : 			continue;

  00165	eb e1		 jmp	 SHORT $LN4@Command_Nu
$LN17@Command_Nu:

; 102  : 
; 103  : 		count++;

  00167	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0016a	83 c0 01	 add	 eax, 1
  0016d	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 104  : 	}

  00170	eb d6		 jmp	 SHORT $LN4@Command_Nu
$LN5@Command_Nu:

; 105  : 
; 106  : 	CONS_Printf("%d\n", count);

  00172	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00175	50		 push	 eax
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_03PMGGPEJJ@?$CFd?6@
  0017b	e8 00 00 00 00	 call	 _CONS_Printf
  00180	83 c4 08	 add	 esp, 8
$LN1@Command_Nu:

; 107  : }

  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
  0018a	66 90		 npad	 2
$LN19@Command_Nu:
  0018c	00 00 00 00	 DD	 $LN9@Command_Nu
  00190	00 00 00 00	 DD	 $LN10@Command_Nu
  00194	00 00 00 00	 DD	 $LN11@Command_Nu
  00198	00 00 00 00	 DD	 $LN12@Command_Nu
  0019c	00 00 00 00	 DD	 $LN13@Command_Nu
  001a0	00 00 00 00	 DD	 $LN14@Command_Nu
  001a4	00 00 00 00	 DD	 $LN15@Command_Nu
_Command_Numthinkers_f ENDP
_TEXT	ENDS
END
