; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\d_netfil.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_downloaddir
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_fileneedednum:DWORD
COMM	_fileneeded:BYTE:01ec0H
_DATA	ENDS
_DATA	SEGMENT
_downloaddir DB	'DOWNLOAD', 00H
	ORG $+247
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_PutFileNeeded
PUBLIC	_D_ParseFileneeded
PUBLIC	_CL_PrepareDownloadSaveGame
PUBLIC	_CL_CheckFiles
PUBLIC	_CL_LoadServerFiles
PUBLIC	_SendRam
PUBLIC	_FiletxTicker
PUBLIC	_Got_Filetxpak
PUBLIC	_SendRequestFile
PUBLIC	_Got_RequestFilePak
PUBLIC	_AbortSendFiles
PUBLIC	_CloseNetFile
PUBLIC	_findfile
PUBLIC	_checkfilemd5
PUBLIC	_nameonly
PUBLIC	_nameonlylength
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0DP@GIFIEBLC@Too?5many?5wad?5files?5added?5to?5hos@ ; `string'
PUBLIC	??_C@_0M@EEIMJBNI@?9nodownload@			; `string'
PUBLIC	??_C@_0O@KHFMAOIF@?5?5?$CC?$CFs?$CC?5?$CI?$CFdKB?$CJ@ ; `string'
PUBLIC	??_C@_0L@GDEBAJHI@?5not?5found@			; `string'
PUBLIC	??_C@_0BL@BPCPJEJG@?5has?5wrong?5md5sum?0?5needs?3?5@ ; `string'
PUBLIC	??_C@_04NOJCDH@?$CF02x@				; `string'
PUBLIC	??_C@_0CD@DAIMMJBJ@?5?$CIserver?5has?5downloading?5disabl@ ; `string'
PUBLIC	??_C@_0CD@MMPLPGPI@?5?$CItoo?5big?5to?5download?5from?5serv@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0GO@FEEPMNPI@To?5play?5on?5this?5server?5you?5shou@ ; `string'
PUBLIC	??_C@_0HB@PJBPNCAO@To?5play?5on?5this?5server?5you?5need@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0GE@EFCCCBLE@To?5play?5on?5this?5server?5you?5must@ ; `string'
PUBLIC	??_C@_08KDKGJCBO@?9nofiles@			; `string'
PUBLIC	??_C@_0BE@FAMPCCLJ@searching?5for?5?8?$CFs?8?5@	; `string'
PUBLIC	??_C@_0BA@KMEFLLPP@already?5loaded?6@		; `string'
PUBLIC	??_C@_09MBGLDLF@found?5?$CFd?6@			; `string'
PUBLIC	??_C@_0CD@DEBLFHAF@Wrong?5version?5of?5important?5file@ ; `string'
PUBLIC	??_C@_0DF@BNNELPEK@File?5?$CFs?5should?5only?5contain?5mus@ ; `string'
PUBLIC	??_C@_0CJ@KNJKMGLE@File?5?$CFs?5found?5but?5with?5differen@ ; `string'
PUBLIC	??_C@_0CH@JMJHKCBO@Try?5to?5load?5file?5?$CFs?5with?5status@ ; `string'
PUBLIC	??_C@_0BH@JNKNPLBN@SendFile?3?5No?5more?5ram?6@	; `string'
PUBLIC	??_C@_0BK@ELOOOFIN@?$CFs?5not?5found?5in?5wadfiles?6@ ; `string'
PUBLIC	??_C@_0CB@EJGJFIOI@Client?5?$CFd?5request?5?$CFs?3?5not?5found@ ; `string'
PUBLIC	??_C@_0DB@OKLPELFN@Client?5?$CFd?5request?5?$CFs?3?5file?5too?5@ ; `string'
PUBLIC	??_C@_0BP@ICLCPLH@Sending?5file?5?$CFs?5?$CIid?$DN?$CFd?$CJ?5to?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BG@NCLGLKKP@SendRam?3?5No?5more?5ram?6@	; `string'
PUBLIC	??_C@_0CH@ELOMIMPL@Sending?5ram?5?$CFp?$CIsize?3?$CFu?$CJ?5to?5?$CFd?5?$CI@ ; `string'
PUBLIC	??_C@_0CH@KMDIGICE@filetosend?$DN?$CFd?5but?5no?5filetosend@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BH@NDPNNCIO@File?5?$CFs?5does?5not?5exist@ ; `string'
PUBLIC	??_C@_0BM@OICNIHOA@filesize?5of?5?$CFs?5is?5too?5large@ ; `string'
PUBLIC	??_C@_0BN@DENMFBMH@Error?5getting?5filesize?5of?5?$CFs@ ; `string'
PUBLIC	??_C@_0DJ@MJPBHDKL@FiletxTicker?3?5can?8t?5read?5?$CFIu?5by@ ; `string'
PUBLIC	??_C@_0BO@POFLMOLC@fileframent?5not?5needed?5?$CFd?$DO?$CFd?6@ ; `string'
PUBLIC	??_C@_0CD@HOEMBJME@Got_Filetxpak?3?5allready?5open?5fi@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0CC@IJMDJKC@Can?8t?5create?5file?5?$CFs?3?5disk?5full@ ; `string'
PUBLIC	??_C@_07OHMLJGBL@?$AN?$CFs?4?4?4?6@		; `string'
PUBLIC	??_C@_0CD@NHMJMAME@Can?8t?5write?5?$CFs?3?5disk?5full?5?$DP?5or?5@ ; `string'
PUBLIC	??_C@_0BF@HGMKIEKL@?$AN?$CFs?5?$CFuK?1?$CFuK?5?$CF?41fK?1s?6@ ; `string'
PUBLIC	??_C@_0BF@LFICHMKE@Downloading?5files?4?4?4@	; `string'
PUBLIC	??_C@_04PKPJKNNM@?$AN?$CFs?6@			; `string'
PUBLIC	??_C@_0BB@DOKKCPOJ@?$CFdK?1?$CFdK?5?$CF?41fK?1s?6@ ; `string'
PUBLIC	??_C@_0BB@LFFELOBI@?$CFuK?1?$DP?$DPK?5?$CF?41fK?1s?6@ ; `string'
PUBLIC	??_C@_0BP@FOOJHAOG@Received?5a?5file?5not?5requested?6@ ; `string'
PUBLIC	??_C@_0BP@DHCAKMFN@Couldn?8t?5open?5?$CFs?5for?5md5?5check@ ; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	__real@4090000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_fclose:PROC
EXTRN	_ferror:PROC
EXTRN	_fflush:PROC
EXTRN	_fopen:PROC
EXTRN	_fputs:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_fwrite:PROC
EXTRN	_remove:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strerror:PROC
EXTRN	_strlen:PROC
EXTRN	_stricmp:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_strlcpy:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_W_VerifyNMUSlumps:PROC
EXTRN	_I_GetDiskFreeSpace:PROC
EXTRN	_I_mkdir:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_Net_GetNetStat:PROC
EXTRN	_HSendPacket:PROC
EXTRN	_Net_AbortPacketType:PROC
EXTRN	_Net_SendAcks:PROC
EXTRN	_Z_Free:PROC
EXTRN	_P_AddWadFile:PROC
EXTRN	_strcatbf:PROC
EXTRN	_M_DrawTextBox:PROC
EXTRN	_md5_stream:PROC
EXTRN	_filesearch:PROC
EXTRN	_V_DrawCenteredString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__allshr:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_devparm:DWORD
EXTRN	_modifiedgame:DWORD
EXTRN	_debugfile:DWORD
EXTRN	_text:BYTE
EXTRN	_netbuffer:DWORD
EXTRN	_software_MAXPACKETLENGTH:WORD
EXTRN	_servernode:BYTE
EXTRN	_cv_maxsend:BYTE
EXTRN	_cv_downloading:BYTE
EXTRN	_numwadfiles:WORD
EXTRN	_wadfiles:BYTE
EXTRN	_srb2home:BYTE
EXTRN	_srb2path:BYTE
EXTRN	_net_bandwidth:DWORD
EXTRN	_getbps:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_transfer DB	0180H DUP (?)
_filetosend DD	01H DUP (?)
?currentnode@?1??FiletxTicker@@9@9 DD 01H DUP (?)	; `FiletxTicker'::`2'::currentnode
?filetime@?1??Got_Filetxpak@@9@9 DD 01H DUP (?)		; `Got_Filetxpak'::`2'::filetime
_BSS	ENDS
;	COMDAT __real@4090000000000000
CONST	SEGMENT
__real@4090000000000000 DQ 04090000000000000r	; 1024
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DHCAKMFN@Couldn?8t?5open?5?$CFs?5for?5md5?5check@
CONST	SEGMENT
??_C@_0BP@DHCAKMFN@Couldn?8t?5open?5?$CFs?5for?5md5?5check@ DB 'Couldn''t'
	DB	' open %s for md5 check', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FOOJHAOG@Received?5a?5file?5not?5requested?6@
CONST	SEGMENT
??_C@_0BP@FOOJHAOG@Received?5a?5file?5not?5requested?6@ DB 'Received a fi'
	DB	'le not requested', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFFELOBI@?$CFuK?1?$DP?$DPK?5?$CF?41fK?1s?6@
CONST	SEGMENT
??_C@_0BB@LFFELOBI@?$CFuK?1?$DP?$DPK?5?$CF?41fK?1s?6@ DB '%uK/??K %.1fK/s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOKKCPOJ@?$CFdK?1?$CFdK?5?$CF?41fK?1s?6@
CONST	SEGMENT
??_C@_0BB@DOKKCPOJ@?$CFdK?1?$CFdK?5?$CF?41fK?1s?6@ DB '%dK/%dK %.1fK/s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKPJKNNM@?$AN?$CFs?6@
CONST	SEGMENT
??_C@_04PKPJKNNM@?$AN?$CFs?6@ DB 0dH, '%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LFICHMKE@Downloading?5files?4?4?4@
CONST	SEGMENT
??_C@_0BF@LFICHMKE@Downloading?5files?4?4?4@ DB 'Downloading files...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HGMKIEKL@?$AN?$CFs?5?$CFuK?1?$CFuK?5?$CF?41fK?1s?6@
CONST	SEGMENT
??_C@_0BF@HGMKIEKL@?$AN?$CFs?5?$CFuK?1?$CFuK?5?$CF?41fK?1s?6@ DB 0dH, '%s'
	DB	' %uK/%uK %.1fK/s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NHMJMAME@Can?8t?5write?5?$CFs?3?5disk?5full?5?$DP?5or?5@
CONST	SEGMENT
??_C@_0CD@NHMJMAME@Can?8t?5write?5?$CFs?3?5disk?5full?5?$DP?5or?5@ DB 'Ca'
	DB	'n''t write %s: disk full ? or %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHMLJGBL@?$AN?$CFs?4?4?4?6@
CONST	SEGMENT
??_C@_07OHMLJGBL@?$AN?$CFs?4?4?4?6@ DB 0dH, '%s...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IJMDJKC@Can?8t?5create?5file?5?$CFs?3?5disk?5full@
CONST	SEGMENT
??_C@_0CC@IJMDJKC@Can?8t?5create?5file?5?$CFs?3?5disk?5full@ DB 'Can''t c'
	DB	'reate file %s: disk full ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HOEMBJME@Got_Filetxpak?3?5allready?5open?5fi@
CONST	SEGMENT
??_C@_0CD@HOEMBJME@Got_Filetxpak?3?5allready?5open?5fi@ DB 'Got_Filetxpak'
	DB	': allready open file', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@POFLMOLC@fileframent?5not?5needed?5?$CFd?$DO?$CFd?6@
CONST	SEGMENT
??_C@_0BO@POFLMOLC@fileframent?5not?5needed?5?$CFd?$DO?$CFd?6@ DB 'filefr'
	DB	'ament not needed %d>%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MJPBHDKL@FiletxTicker?3?5can?8t?5read?5?$CFIu?5by@
CONST	SEGMENT
??_C@_0DJ@MJPBHDKL@FiletxTicker?3?5can?8t?5read?5?$CFIu?5by@ DB 'FiletxTi'
	DB	'cker: can''t read %Iu byte on %s at %d because %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DENMFBMH@Error?5getting?5filesize?5of?5?$CFs@
CONST	SEGMENT
??_C@_0BN@DENMFBMH@Error?5getting?5filesize?5of?5?$CFs@ DB 'Error getting'
	DB	' filesize of %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OICNIHOA@filesize?5of?5?$CFs?5is?5too?5large@
CONST	SEGMENT
??_C@_0BM@OICNIHOA@filesize?5of?5?$CFs?5is?5too?5large@ DB 'filesize of %'
	DB	's is too large', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NDPNNCIO@File?5?$CFs?5does?5not?5exist@
CONST	SEGMENT
??_C@_0BH@NDPNNCIO@File?5?$CFs?5does?5not?5exist@ DB 'File %s does not ex'
	DB	'ist', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KMDIGICE@filetosend?$DN?$CFd?5but?5no?5filetosend@
CONST	SEGMENT
??_C@_0CH@KMDIGICE@filetosend?$DN?$CFd?5but?5no?5filetosend@ DB 'filetose'
	DB	'nd=%d but no filetosend found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ELOMIMPL@Sending?5ram?5?$CFp?$CIsize?3?$CFu?$CJ?5to?5?$CFd?5?$CI@
CONST	SEGMENT
??_C@_0CH@ELOMIMPL@Sending?5ram?5?$CFp?$CIsize?3?$CFu?$CJ?5to?5?$CFd?5?$CI@ DB 'S'
	DB	'ending ram %p(size:%u) to %d (id=%u)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NCLGLKKP@SendRam?3?5No?5more?5ram?6@
CONST	SEGMENT
??_C@_0BG@NCLGLKKP@SendRam?3?5No?5more?5ram?6@ DB 'SendRam: No more ram', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ICLCPLH@Sending?5file?5?$CFs?5?$CIid?$DN?$CFd?$CJ?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0BP@ICLCPLH@Sending?5file?5?$CFs?5?$CIid?$DN?$CFd?$CJ?5to?5?$CFd?6@ DB 'S'
	DB	'ending file %s (id=%d) to %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OKLPELFN@Client?5?$CFd?5request?5?$CFs?3?5file?5too?5@
CONST	SEGMENT
??_C@_0DB@OKLPELFN@Client?5?$CFd?5request?5?$CFs?3?5file?5too?5@ DB 'Clie'
	DB	'nt %d request %s: file too big, not sending', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EJGJFIOI@Client?5?$CFd?5request?5?$CFs?3?5not?5found@
CONST	SEGMENT
??_C@_0CB@EJGJFIOI@Client?5?$CFd?5request?5?$CFs?3?5not?5found@ DB 'Clien'
	DB	't %d request %s: not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELOOOFIN@?$CFs?5not?5found?5in?5wadfiles?6@
CONST	SEGMENT
??_C@_0BK@ELOOOFIN@?$CFs?5not?5found?5in?5wadfiles?6@ DB '%s not found in'
	DB	' wadfiles', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNKNPLBN@SendFile?3?5No?5more?5ram?6@
CONST	SEGMENT
??_C@_0BH@JNKNPLBN@SendFile?3?5No?5more?5ram?6@ DB 'SendFile: No more ram'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JMJHKCBO@Try?5to?5load?5file?5?$CFs?5with?5status@
CONST	SEGMENT
??_C@_0CH@JMJHKCBO@Try?5to?5load?5file?5?$CFs?5with?5status@ DB 'Try to l'
	DB	'oad file %s with status of %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KNJKMGLE@File?5?$CFs?5found?5but?5with?5differen@
CONST	SEGMENT
??_C@_0CJ@KNJKMGLE@File?5?$CFs?5found?5but?5with?5differen@ DB 'File %s f'
	DB	'ound but with different md5sum', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BNNELPEK@File?5?$CFs?5should?5only?5contain?5mus@
CONST	SEGMENT
??_C@_0DF@BNNELPEK@File?5?$CFs?5should?5only?5contain?5mus@ DB 'File %s s'
	DB	'hould only contain music and sound effects!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DEBLFHAF@Wrong?5version?5of?5important?5file@
CONST	SEGMENT
??_C@_0CD@DEBLFHAF@Wrong?5version?5of?5important?5file@ DB 'Wrong version'
	DB	' of important file %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBGLDLF@found?5?$CFd?6@
CONST	SEGMENT
??_C@_09MBGLDLF@found?5?$CFd?6@ DB 'found %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMEFLLPP@already?5loaded?6@
CONST	SEGMENT
??_C@_0BA@KMEFLLPP@already?5loaded?6@ DB 'already loaded', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FAMPCCLJ@searching?5for?5?8?$CFs?8?5@
CONST	SEGMENT
??_C@_0BE@FAMPCCLJ@searching?5for?5?8?$CFs?8?5@ DB 'searching for ''%s'' '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDKGJCBO@?9nofiles@
CONST	SEGMENT
??_C@_08KDKGJCBO@?9nofiles@ DB '-nofiles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@EFCCCBLE@To?5play?5on?5this?5server?5you?5must@
CONST	SEGMENT
??_C@_0GE@EFCCCBLE@To?5play?5on?5this?5server?5you?5must@ DB 'To play on '
	DB	'this server you must download %Iu KB,', 0aH, 'but you have on'
	DB	'ly %Iu KB free space on this drive', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@PJBPNCAO@To?5play?5on?5this?5server?5you?5need@
CONST	SEGMENT
??_C@_0HB@PJBPNCAO@To?5play?5on?5this?5server?5you?5need@ DB 'To play on '
	DB	'this server you need these files:', 0aH, '%s', 0aH, 'Make sur'
	DB	'e you get them somewhere, or you won''t be able to join!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@FEEPMNPI@To?5play?5on?5this?5server?5you?5shou@
CONST	SEGMENT
??_C@_0GO@FEEPMNPI@To?5play?5on?5this?5server?5you?5shou@ DB 'To play on '
	DB	'this server you should have these files:', 0aH, '%s', 0aH, 'R'
	DB	'emove -nodownload if you want to download the files!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MMPLPGPI@?5?$CItoo?5big?5to?5download?5from?5serv@
CONST	SEGMENT
??_C@_0CD@MMPLPGPI@?5?$CItoo?5big?5to?5download?5from?5serv@ DB ' (too bi'
	DB	'g to download from server)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DAIMMJBJ@?5?$CIserver?5has?5downloading?5disabl@
CONST	SEGMENT
??_C@_0CD@DAIMMJBJ@?5?$CIserver?5has?5downloading?5disabl@ DB ' (server h'
	DB	'as downloading disabled)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NOJCDH@?$CF02x@
CONST	SEGMENT
??_C@_04NOJCDH@?$CF02x@ DB '%02x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BPCPJEJG@?5has?5wrong?5md5sum?0?5needs?3?5@
CONST	SEGMENT
??_C@_0BL@BPCPJEJG@?5has?5wrong?5md5sum?0?5needs?3?5@ DB ' has wrong md5s'
	DB	'um, needs: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GDEBAJHI@?5not?5found@
CONST	SEGMENT
??_C@_0L@GDEBAJHI@?5not?5found@ DB ' not found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KHFMAOIF@?5?5?$CC?$CFs?$CC?5?$CI?$CFdKB?$CJ@
CONST	SEGMENT
??_C@_0O@KHFMAOIF@?5?5?$CC?$CFs?$CC?5?$CI?$CFdKB?$CJ@ DB '  "%s" (%dKB)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEIMJBNI@?9nodownload@
CONST	SEGMENT
??_C@_0M@EEIMJBNI@?9nodownload@ DB '-nodownload', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@GIFIEBLC@Too?5many?5wad?5files?5added?5to?5hos@
CONST	SEGMENT
??_C@_0DP@GIFIEBLC@Too?5many?5wad?5files?5added?5to?5hos@ DB 'Too many wa'
	DB	'd files added to host a game. (%Iu, stopped on %s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02e5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	093H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0125H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0596H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02abH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _EndSend
_TEXT	SEGMENT
tv68 = -72						; size = 4
_p$ = -4						; size = 4
_node$ = 8						; size = 4
_EndSend PROC						; COMDAT

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 478  : 	filetx_t *p = transfer[node].txlist;

  00009	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  0000d	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax]
  00013	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 479  : 	switch (p->ram)

  00016	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  0001e	83 7d b8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00022	74 0e		 je	 SHORT $LN4@EndSend
  00024	83 7d b8 01	 cmp	 DWORD PTR tv68[ebp], 1
  00028	74 39		 je	 SHORT $LN6@EndSend
  0002a	83 7d b8 02	 cmp	 DWORD PTR tv68[ebp], 2
  0002e	74 44		 je	 SHORT $LN7@EndSend
  00030	eb 51		 jmp	 SHORT $LN2@EndSend
$LN4@EndSend:

; 480  : 	{
; 481  : 		case SF_FILE:
; 482  : 			if (transfer[node].currentfile)

  00032	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  00036	83 b8 08 00 00
	00 00		 cmp	 DWORD PTR _transfer[eax+8], 0
  0003d	74 13		 je	 SHORT $LN5@EndSend

; 483  : 				fclose(transfer[node].currentfile);

  0003f	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  00043	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+8]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _fclose
  0004f	83 c4 04	 add	 esp, 4
$LN5@EndSend:

; 484  : 			free(p->filename);

  00052	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00055	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _free
  0005e	83 c4 04	 add	 esp, 4

; 485  : 			break;

  00061	eb 20		 jmp	 SHORT $LN2@EndSend
$LN6@EndSend:

; 486  : 		case SF_Z_RAM:
; 487  : 			Z_Free(p->filename);

  00063	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00066	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _Z_Free
  0006f	83 c4 04	 add	 esp, 4

; 488  : 			break;

  00072	eb 0f		 jmp	 SHORT $LN2@EndSend
$LN7@EndSend:

; 489  : 		case SF_RAM:
; 490  : 			free(p->filename);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00077	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN2@EndSend:

; 491  : 		case SF_NOFREERAM:
; 492  : 			break;
; 493  : 	}
; 494  : 	transfer[node].txlist = p->next;

  00083	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0008a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008d	89 90 00 00 00
	00		 mov	 DWORD PTR _transfer[eax], edx

; 495  : 	transfer[node].currentfile = NULL;

  00093	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  00097	c7 80 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _transfer[eax+8], 0

; 496  : 	free(p);

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _free
  000aa	83 c4 04	 add	 esp, 4

; 497  : 	filetosend--;

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _filetosend
  000b2	83 e8 01	 sub	 eax, 1
  000b5	a3 00 00 00 00	 mov	 DWORD PTR _filetosend, eax

; 498  : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_EndSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _SendFile
_TEXT	SEGMENT
_wadfilename$ = -144					; size = 128
_i$ = -16						; size = 4
_p$ = -12						; size = 4
_q$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileid$ = 16						; size = 1
_SendFile PROC						; COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 386  : 	filetx_t **q;
; 387  : 	filetx_t *p;
; 388  : 	INT32 i;
; 389  : 	char wadfilename[MAX_WADPATH];
; 390  : 
; 391  : 	q = &transfer[node].txlist;

  00016	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  0001a	05 00 00 00 00	 add	 eax, OFFSET _transfer
  0001f	89 45 f8	 mov	 DWORD PTR _q$[ebp], eax
$LN2@SendFile:

; 392  : 	while (*q)

  00022	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  00025	83 38 00	 cmp	 DWORD PTR [eax], 0
  00028	74 0d		 je	 SHORT $LN3@SendFile

; 393  : 		q = &((*q)->next);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	83 c1 14	 add	 ecx, 20			; 00000014H
  00032	89 4d f8	 mov	 DWORD PTR _q$[ebp], ecx
  00035	eb eb		 jmp	 SHORT $LN2@SendFile
$LN3@SendFile:

; 394  : 	p = *q = (filetx_t *)malloc(sizeof (filetx_t));

  00037	6a 18		 push	 24			; 00000018H
  00039	e8 00 00 00 00	 call	 _malloc
  0003e	83 c4 04	 add	 esp, 4
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _q$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax
  00046	8b 55 f8	 mov	 edx, DWORD PTR _q$[ebp]
  00049	8b 02		 mov	 eax, DWORD PTR [edx]
  0004b	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 395  : 	if (p)

  0004e	83 7d f4 00	 cmp	 DWORD PTR _p$[ebp], 0
  00052	74 12		 je	 SHORT $LN7@SendFile

; 396  : 		memset(p, 0, sizeof (filetx_t));

  00054	6a 18		 push	 24			; 00000018H
  00056	6a 00		 push	 0
  00058	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _memset
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	eb 0d		 jmp	 SHORT $LN8@SendFile
$LN7@SendFile:

; 397  : 	else
; 398  : 		I_Error("SendFile: No more ram\n");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JNKNPLBN@SendFile?3?5No?5more?5ram?6@
  0006b	e8 00 00 00 00	 call	 _I_Error
  00070	83 c4 04	 add	 esp, 4
$LN8@SendFile:

; 399  : 	p->filename = (char *)malloc(MAX_WADPATH);

  00073	68 80 00 00 00	 push	 128			; 00000080H
  00078	e8 00 00 00 00	 call	 _malloc
  0007d	83 c4 04	 add	 esp, 4
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  00083	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 400  : 	if (!p->filename)

  00086	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00089	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0008d	75 0d		 jne	 SHORT $LN9@SendFile

; 401  : 		I_Error("SendFile: No more ram\n");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JNKNPLBN@SendFile?3?5No?5more?5ram?6@
  00094	e8 00 00 00 00	 call	 _I_Error
  00099	83 c4 04	 add	 esp, 4
$LN9@SendFile:

; 402  : 
; 403  : 	// a minimum of security, can get only file in srb2 direcory
; 404  : 	strlcpy(p->filename, filename, MAX_WADPATH);

  0009c	68 80 00 00 00	 push	 128			; 00000080H
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  000a8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _strlcpy
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 405  : 	nameonly(p->filename);

  000b4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _nameonly
  000c0	83 c4 04	 add	 esp, 4

; 406  : 
; 407  : 	// check first in wads loaded the majority of case
; 408  : 	for (i = 0; wadfiles[i]; i++)

  000c3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN6@SendFile
$LN4@SendFile:
  000cc	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN6@SendFile:
  000d5	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000d8	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _wadfiles[eax*4], 0
  000e0	74 72		 je	 SHORT $LN5@SendFile

; 409  : 	{
; 410  : 		strlcpy(wadfilename, wadfiles[i]->filename, MAX_WADPATH);

  000e2	68 80 00 00 00	 push	 128			; 00000080H
  000e7	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000ea	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  000f1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f3	52		 push	 edx
  000f4	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _strlcpy
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 411  : 		nameonly(wadfilename);

  00103	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _nameonly
  0010f	83 c4 04	 add	 esp, 4

; 412  : 		if (!stricmp(wadfilename, p->filename))

  00112	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00115	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00118	51		 push	 ecx
  00119	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _wadfilename$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 _stricmp
  00125	83 c4 08	 add	 esp, 8
  00128	85 c0		 test	 eax, eax
  0012a	75 23		 jne	 SHORT $LN10@SendFile

; 413  : 		{
; 414  : 			// copy filename with full path
; 415  : 			strlcpy(p->filename, wadfiles[i]->filename, MAX_WADPATH);

  0012c	68 80 00 00 00	 push	 128			; 00000080H
  00131	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00134	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  0013b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013d	52		 push	 edx
  0013e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00141	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 _strlcpy
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 			break;

  0014d	eb 05		 jmp	 SHORT $LN5@SendFile
$LN10@SendFile:

; 417  : 		}
; 418  : 	}

  0014f	e9 78 ff ff ff	 jmp	 $LN4@SendFile
$LN5@SendFile:

; 419  : 
; 420  : 	if (!wadfiles[i])

  00154	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00157	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _wadfiles[eax*4], 0
  0015f	0f 85 9b 00 00
	00		 jne	 $LN11@SendFile

; 421  : 	{
; 422  : 		DEBFILE(va("%s not found in wadfiles\n", filename));

  00165	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0016c	74 2e		 je	 SHORT $LN12@SendFile
  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00173	50		 push	 eax
  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00177	51		 push	 ecx
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@ELOOOFIN@?$CFs?5not?5found?5in?5wadfiles?6@
  0017d	e8 00 00 00 00	 call	 _va
  00182	83 c4 08	 add	 esp, 8
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _fputs
  0018b	83 c4 08	 add	 esp, 8
  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _fflush
  00199	83 c4 04	 add	 esp, 4
$LN12@SendFile:

; 423  : 		// this formerly checked if (!findfile(p->filename, NULL, true))
; 424  : 
; 425  : 		// not found
; 426  : 		// don't inform client (probably hacker)
; 427  : 		DEBFILE(va("Client %d request %s: not found\n", node, filename));

  0019c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  001a3	74 32		 je	 SHORT $LN13@SendFile
  001a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001aa	50		 push	 eax
  001ab	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  001ae	51		 push	 ecx
  001af	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  001b2	52		 push	 edx
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EJGJFIOI@Client?5?$CFd?5request?5?$CFs?3?5not?5found@
  001b8	e8 00 00 00 00	 call	 _va
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 _fputs
  001c6	83 c4 08	 add	 esp, 8
  001c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _fflush
  001d4	83 c4 04	 add	 esp, 4
$LN13@SendFile:

; 428  : 		free(p->filename);

  001d7	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 _free
  001e3	83 c4 04	 add	 esp, 4

; 429  : 		free(p);

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _free
  001ef	83 c4 04	 add	 esp, 4

; 430  : 		*q = NULL;

  001f2	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  001f5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 431  : 		return;

  001fb	e9 e2 00 00 00	 jmp	 $LN1@SendFile
$LN11@SendFile:

; 432  : 	}
; 433  : 
; 434  : 	if (wadfiles[i]->filesize > (UINT32)cv_maxsend.value * 1024)

  00200	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00203	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  0020a	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _cv_maxsend+20
  00210	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00213	39 51 18	 cmp	 DWORD PTR [ecx+24], edx
  00216	76 61		 jbe	 SHORT $LN14@SendFile

; 435  : 	{
; 436  : 		// too big
; 437  : 		// don't inform client (client sucks, man)
; 438  : 		DEBFILE(va("Client %d request %s: file too big, not sending\n", node, filename));

  00218	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0021f	74 32		 je	 SHORT $LN15@SendFile
  00221	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00226	50		 push	 eax
  00227	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  0022a	51		 push	 ecx
  0022b	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  0022e	52		 push	 edx
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OKLPELFN@Client?5?$CFd?5request?5?$CFs?3?5file?5too?5@
  00234	e8 00 00 00 00	 call	 _va
  00239	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 _fputs
  00242	83 c4 08	 add	 esp, 8
  00245	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 _fflush
  00250	83 c4 04	 add	 esp, 4
$LN15@SendFile:

; 439  : 		free(p->filename);

  00253	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00256	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00259	51		 push	 ecx
  0025a	e8 00 00 00 00	 call	 _free
  0025f	83 c4 04	 add	 esp, 4

; 440  : 		free(p);

  00262	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _free
  0026b	83 c4 04	 add	 esp, 4

; 441  : 		*q = NULL;

  0026e	8b 45 f8	 mov	 eax, DWORD PTR _q$[ebp]
  00271	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 442  : 		return;

  00277	eb 69		 jmp	 SHORT $LN1@SendFile
$LN14@SendFile:

; 443  : 	}
; 444  : 
; 445  : 	DEBFILE(va("Sending file %s (id=%d) to %d\n", filename, fileid, node));

  00279	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00280	74 37		 je	 SHORT $LN16@SendFile
  00282	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00287	50		 push	 eax
  00288	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  0028b	51		 push	 ecx
  0028c	0f b6 55 10	 movzx	 edx, BYTE PTR _fileid$[ebp]
  00290	52		 push	 edx
  00291	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00294	50		 push	 eax
  00295	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@ICLCPLH@Sending?5file?5?$CFs?5?$CIid?$DN?$CFd?$CJ?5to?5?$CFd?6@
  0029a	e8 00 00 00 00	 call	 _va
  0029f	83 c4 10	 add	 esp, 16			; 00000010H
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 _fputs
  002a8	83 c4 08	 add	 esp, 8
  002ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _fflush
  002b6	83 c4 04	 add	 esp, 4
$LN16@SendFile:

; 446  : 	p->ram = SF_FILE;

  002b9	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002bc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 447  : 	p->fileid = fileid;

  002c2	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002c5	8a 4d 10	 mov	 cl, BYTE PTR _fileid$[ebp]
  002c8	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 448  : 	p->next = NULL; // end of list

  002cb	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002ce	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 449  : 	filetosend++;

  002d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _filetosend
  002da	83 c0 01	 add	 eax, 1
  002dd	a3 00 00 00 00	 mov	 DWORD PTR _filetosend, eax
$LN1@SendFile:

; 450  : }

  002e2	5f		 pop	 edi
  002e3	5e		 pop	 esi
  002e4	5b		 pop	 ebx
  002e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e8	33 cd		 xor	 ecx, ebp
  002ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	c3		 ret	 0
_SendFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _nameonlylength
_TEXT	SEGMENT
_len$ = -8						; size = 4
_j$ = -4						; size = 4
_s$ = 8							; size = 4
_nameonlylength PROC					; COMDAT

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 723  : 	size_t j, len = strlen(s);

  00009	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 724  : 
; 725  : 	for (j = len; j != (size_t)-1; j--)

  00018	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
  0001e	eb 09		 jmp	 SHORT $LN4@nameonlyle
$LN2@nameonlyle:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  00023	83 e8 01	 sub	 eax, 1
  00026	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN4@nameonlyle:
  00029	83 7d fc ff	 cmp	 DWORD PTR _j$[ebp], -1
  0002d	74 37		 je	 SHORT $LN3@nameonlyle

; 726  : 		if ((s[j] == '\\') || (s[j] == ':') || (s[j] == '/'))

  0002f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00032	03 45 fc	 add	 eax, DWORD PTR _j$[ebp]
  00035	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00038	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0003b	74 1c		 je	 SHORT $LN6@nameonlyle
  0003d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00040	03 45 fc	 add	 eax, DWORD PTR _j$[ebp]
  00043	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00046	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00049	74 0e		 je	 SHORT $LN6@nameonlyle
  0004b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004e	03 45 fc	 add	 eax, DWORD PTR _j$[ebp]
  00051	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00054	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00057	75 0b		 jne	 SHORT $LN5@nameonlyle
$LN6@nameonlyle:

; 727  : 			return len - j - 1;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0005c	2b 45 fc	 sub	 eax, DWORD PTR _j$[ebp]
  0005f	83 e8 01	 sub	 eax, 1
  00062	eb 05		 jmp	 SHORT $LN1@nameonlyle
$LN5@nameonlyle:
  00064	eb ba		 jmp	 SHORT $LN2@nameonlyle
$LN3@nameonlyle:

; 728  : 
; 729  : 	return len;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
$LN1@nameonlyle:

; 730  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_nameonlylength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _nameonly
_TEXT	SEGMENT
_ns$ = -12						; size = 4
_len$ = -8						; size = 4
_j$ = -4						; size = 4
_s$ = 8							; size = 4
_nameonly PROC						; COMDAT

; 703  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 704  : 	size_t j, len;
; 705  : 	void *ns;
; 706  : 
; 707  : 	for (j = strlen(s); j != (size_t)-1; j--)

  00009	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
  00018	eb 09		 jmp	 SHORT $LN4@nameonly
$LN2@nameonly:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  0001d	83 e8 01	 sub	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
$LN4@nameonly:
  00023	83 7d fc ff	 cmp	 DWORD PTR _j$[ebp], -1
  00027	0f 84 82 00 00
	00		 je	 $LN3@nameonly

; 708  : 		if ((s[j] == '\\') || (s[j] == ':') || (s[j] == '/'))

  0002d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00030	03 45 fc	 add	 eax, DWORD PTR _j$[ebp]
  00033	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00036	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00039	74 1c		 je	 SHORT $LN6@nameonly
  0003b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003e	03 45 fc	 add	 eax, DWORD PTR _j$[ebp]
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00047	74 0e		 je	 SHORT $LN6@nameonly
  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	03 45 fc	 add	 eax, DWORD PTR _j$[ebp]
  0004f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00052	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00055	75 53		 jne	 SHORT $LN5@nameonly
$LN6@nameonly:

; 709  : 		{
; 710  : 			ns = &(s[j+1]);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0005d	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00061	89 55 f4	 mov	 DWORD PTR _ns$[ebp], edx

; 711  : 			len = strlen(ns);

  00064	8b 45 f4	 mov	 eax, DWORD PTR _ns$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _strlen
  0006d	83 c4 04	 add	 esp, 4
  00070	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 712  : 			if (false)

  00073	33 c0		 xor	 eax, eax
  00075	74 1a		 je	 SHORT $LN7@nameonly

; 713  : 				M_Memcpy(s, ns, len+1);

  00077	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	50		 push	 eax
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR _ns$[ebp]
  00081	51		 push	 ecx
  00082	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00085	52		 push	 edx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	eb 17		 jmp	 SHORT $LN8@nameonly
$LN7@nameonly:

; 714  : 			else
; 715  : 				memmove(s, ns, len+1);

  00091	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00094	83 c0 01	 add	 eax, 1
  00097	50		 push	 eax
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _ns$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _memmove
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@nameonly:

; 716  : 			return;

  000a8	eb 05		 jmp	 SHORT $LN3@nameonly
$LN5@nameonly:

; 717  : 		}

  000aa	e9 6b ff ff ff	 jmp	 $LN2@nameonly
$LN3@nameonly:

; 718  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_nameonly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _checkfilemd5
_TEXT	SEGMENT
_md5sum$ = -24						; size = 16
_fhandle$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_wantedmd5sum$ = 12					; size = 4
_checkfilemd5 PROC					; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 738  : #if defined (NOMD5) || defined (_arch_dreamcast)
; 739  : 	(void)wantedmd5sum;
; 740  : 	(void)filename;
; 741  : #else
; 742  : 	FILE *fhandle;
; 743  : 	UINT8 md5sum[16];
; 744  : 
; 745  : 	if (!wantedmd5sum)

  00013	83 7d 0c 00	 cmp	 DWORD PTR _wantedmd5sum$[ebp], 0
  00017	75 07		 jne	 SHORT $LN2@checkfilem

; 746  : 		return FS_FOUND;

  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	eb 70		 jmp	 SHORT $LN1@checkfilem
$LN2@checkfilem:

; 747  : 
; 748  : 	fhandle = fopen(filename, "rb");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00025	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _fopen
  0002e	83 c4 08	 add	 esp, 8
  00031	89 45 f8	 mov	 DWORD PTR _fhandle$[ebp], eax

; 749  : 	if (fhandle)

  00034	83 7d f8 00	 cmp	 DWORD PTR _fhandle$[ebp], 0
  00038	74 40		 je	 SHORT $LN3@checkfilem

; 750  : 	{
; 751  : 		md5_stream(fhandle,md5sum);

  0003a	8d 45 e8	 lea	 eax, DWORD PTR _md5sum$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _fhandle$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _md5_stream
  00047	83 c4 08	 add	 esp, 8

; 752  : 		fclose(fhandle);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _fhandle$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _fclose
  00053	83 c4 04	 add	 esp, 4

; 753  : 		if (!memcmp(wantedmd5sum, md5sum, 16))

  00056	6a 10		 push	 16			; 00000010H
  00058	8d 45 e8	 lea	 eax, DWORD PTR _md5sum$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _wantedmd5sum$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 _memcmp
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	85 c0		 test	 eax, eax
  0006a	75 07		 jne	 SHORT $LN4@checkfilem

; 754  : 			return FS_FOUND;

  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	eb 1d		 jmp	 SHORT $LN1@checkfilem
$LN4@checkfilem:

; 755  : 		return FS_MD5SUMBAD;

  00073	b8 05 00 00 00	 mov	 eax, 5
  00078	eb 16		 jmp	 SHORT $LN1@checkfilem
$LN3@checkfilem:

; 756  : 	}
; 757  : 
; 758  : 	I_Error("Couldn't open %s for md5 check", filename);

  0007a	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DHCAKMFN@Couldn?8t?5open?5?$CFs?5for?5md5?5check@
  00083	e8 00 00 00 00	 call	 _I_Error
  00088	83 c4 08	 add	 esp, 8

; 759  : #endif
; 760  : 	return FS_FOUND; // will never happen, but makes the compiler shut up

  0008b	b8 01 00 00 00	 mov	 eax, 1
$LN1@checkfilem:

; 761  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_checkfilemd5 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _findfile
_TEXT	SEGMENT
_homecheck$ = -4					; size = 4
_filename$ = 8						; size = 4
_wantedmd5sum$ = 12					; size = 4
_completepath$ = 16					; size = 4
_findfile PROC						; COMDAT

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 765  : 	filestatus_t homecheck = filesearch(filename, srb2home, wantedmd5sum, false, 10);

  00009	6a 0a		 push	 10			; 0000000aH
  0000b	6a 00		 push	 0
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _wantedmd5sum$[ebp]
  00010	50		 push	 eax
  00011	68 00 00 00 00	 push	 OFFSET _srb2home
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _filesearch
  0001f	83 c4 14	 add	 esp, 20			; 00000014H
  00022	89 45 fc	 mov	 DWORD PTR _homecheck$[ebp], eax

; 766  : 	if (homecheck == FS_FOUND)

  00025	83 7d fc 01	 cmp	 DWORD PTR _homecheck$[ebp], 1
  00029	75 1d		 jne	 SHORT $LN2@findfile

; 767  : 		return filesearch(filename, srb2home, wantedmd5sum, completepath, 10);

  0002b	6a 0a		 push	 10			; 0000000aH
  0002d	8b 45 10	 mov	 eax, DWORD PTR _completepath$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _wantedmd5sum$[ebp]
  00034	51		 push	 ecx
  00035	68 00 00 00 00	 push	 OFFSET _srb2home
  0003a	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _filesearch
  00043	83 c4 14	 add	 esp, 20			; 00000014H
  00046	eb 5a		 jmp	 SHORT $LN1@findfile
$LN2@findfile:

; 768  : 
; 769  : 	homecheck = filesearch(filename, srb2path, wantedmd5sum, false, 10);

  00048	6a 0a		 push	 10			; 0000000aH
  0004a	6a 00		 push	 0
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _wantedmd5sum$[ebp]
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET _srb2path
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _filesearch
  0005e	83 c4 14	 add	 esp, 20			; 00000014H
  00061	89 45 fc	 mov	 DWORD PTR _homecheck$[ebp], eax

; 770  : 	if (homecheck == FS_FOUND)

  00064	83 7d fc 01	 cmp	 DWORD PTR _homecheck$[ebp], 1
  00068	75 1d		 jne	 SHORT $LN3@findfile

; 771  : 		return filesearch(filename, srb2path, wantedmd5sum, completepath, 10);

  0006a	6a 0a		 push	 10			; 0000000aH
  0006c	8b 45 10	 mov	 eax, DWORD PTR _completepath$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 0c	 mov	 ecx, DWORD PTR _wantedmd5sum$[ebp]
  00073	51		 push	 ecx
  00074	68 00 00 00 00	 push	 OFFSET _srb2path
  00079	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _filesearch
  00082	83 c4 14	 add	 esp, 20			; 00000014H
  00085	eb 1b		 jmp	 SHORT $LN1@findfile
$LN3@findfile:

; 772  : 
; 773  : #ifdef _arch_dreamcast
; 774  : 	return filesearch(filename, "/cd", wantedmd5sum, completepath, 10);
; 775  : #else
; 776  : 	return filesearch(filename, ".", wantedmd5sum, completepath, 10);

  00087	6a 0a		 push	 10			; 0000000aH
  00089	8b 45 10	 mov	 eax, DWORD PTR _completepath$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _wantedmd5sum$[ebp]
  00090	51		 push	 ecx
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4@
  00096	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 _filesearch
  0009f	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@findfile:

; 777  : #endif
; 778  : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_findfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _CloseNetFile
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CloseNetFile PROC					; COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 682  : 	INT32 i;
; 683  : 	// is sending?
; 684  : 	for (i = 0; i < MAXNETNODES; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@CloseNetFi
$LN2@CloseNetFi:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CloseNetFi:
  0001b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0001f	7d 0e		 jge	 SHORT $LN3@CloseNetFi

; 685  : 		AbortSendFiles(i);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _AbortSendFiles
  0002a	83 c4 04	 add	 esp, 4
  0002d	eb e3		 jmp	 SHORT $LN2@CloseNetFi
$LN3@CloseNetFi:

; 686  : 
; 687  : 	// receiving a file?
; 688  : 	for (i = 0; i < MAX_WADFILES; i++)

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00036	eb 09		 jmp	 SHORT $LN7@CloseNetFi
$LN5@CloseNetFi:
  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	83 c0 01	 add	 eax, 1
  0003e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@CloseNetFi:
  00041	83 7d fc 30	 cmp	 DWORD PTR _i$[ebp], 48	; 00000030H
  00045	7d 4d		 jge	 SHORT $LN6@CloseNetFi

; 689  : 		if (fileneeded[i].status == FS_DOWNLOADING && fileneeded[i].phandle)

  00047	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0004e	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR _fileneeded[eax+160], 3
  00055	75 3b		 jne	 SHORT $LN8@CloseNetFi
  00057	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0005e	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR _fileneeded[eax+148], 0
  00065	74 2b		 je	 SHORT $LN8@CloseNetFi

; 690  : 		{
; 691  : 			fclose(fileneeded[i].phandle);

  00067	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0006e	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+148]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _fclose
  0007a	83 c4 04	 add	 esp, 4

; 692  : 			// file is not complete delete it
; 693  : 			remove(fileneeded[i].filename);

  0007d	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00084	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _remove
  0008f	83 c4 04	 add	 esp, 4
$LN8@CloseNetFi:

; 694  : 		}

  00092	eb a4		 jmp	 SHORT $LN5@CloseNetFi
$LN6@CloseNetFi:

; 695  : 
; 696  : 	// remove FILEFRAGMENT from acknledge list
; 697  : 	Net_AbortPacketType(PT_FILEFRAGMENT);

  00094	6a 11		 push	 17			; 00000011H
  00096	e8 00 00 00 00	 call	 _Net_AbortPacketType
  0009b	83 c4 04	 add	 esp, 4

; 698  : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_CloseNetFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _AbortSendFiles
_TEXT	SEGMENT
_node$ = 8						; size = 4
_AbortSendFiles PROC					; COMDAT

; 675  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@AbortSendF:

; 676  : 	while (transfer[node].txlist)

  00009	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  0000d	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _transfer[eax], 0
  00014	74 0e		 je	 SHORT $LN3@AbortSendF

; 677  : 		EndSend(node);

  00016	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _EndSend
  0001f	83 c4 04	 add	 esp, 4
  00022	eb e5		 jmp	 SHORT $LN2@AbortSendF
$LN3@AbortSendF:

; 678  : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_AbortSendFiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _Got_RequestFilePak
_TEXT	SEGMENT
tv81 = -220						; size = 4
$T1 = -216						; size = 4
_tmp_i$2 = -148						; size = 4
_id$ = -141						; size = 1
_p$ = -140						; size = 4
_wad$ = -136						; size = 129
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_Got_RequestFilePak PROC				; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 280  : 	char wad[MAX_WADPATH+1];
; 281  : 	UINT8 *p = netbuffer->u.textcmd;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0001b	83 c0 08	 add	 eax, 8
  0001e	89 85 74 ff ff
	ff		 mov	 DWORD PTR _p$[ebp], eax
$LN2@Got_Reques:

; 282  : 	UINT8 id;
; 283  : 	while (p < netbuffer->u.textcmd + MAXTEXTCMD-1) // Don't allow hacked client to overflow

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00029	05 07 01 00 00	 add	 eax, 263		; 00000107H
  0002e	39 85 74 ff ff
	ff		 cmp	 DWORD PTR _p$[ebp], eax
  00034	0f 83 e8 00 00
	00		 jae	 $LN3@Got_Reques

; 284  : 	{
; 285  : 		id = READUINT8(p);

  0003a	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _p$[ebp]
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	88 8d 73 ff ff
	ff		 mov	 BYTE PTR _id$[ebp], cl
  00048	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _p$[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 95 74 ff ff
	ff		 mov	 DWORD PTR _p$[ebp], edx

; 286  : 		if (id == 0xFF)

  00057	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR _id$[ebp]
  0005e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00063	75 05		 jne	 SHORT $LN7@Got_Reques

; 287  : 			break;

  00065	e9 b8 00 00 00	 jmp	 $LN3@Got_Reques
$LN7@Got_Reques:

; 288  : 		READSTRINGN(p, wad, MAX_WADPATH);

  0006a	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmp_i$2[ebp], 0
  00074	eb 0f		 jmp	 SHORT $LN6@Got_Reques
$LN4@Got_Reques:
  00076	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$2[ebp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 85 6c ff ff
	ff		 mov	 DWORD PTR _tmp_i$2[ebp], eax
$LN6@Got_Reques:
  00085	81 bd 6c ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR _tmp_i$2[ebp], 128 ; 00000080H
  0008f	73 43		 jae	 SHORT $LN5@Got_Reques
  00091	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$2[ebp]
  00097	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _p$[ebp]
  0009d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0009f	88 94 05 78 ff
	ff ff		 mov	 BYTE PTR _wad$[ebp+eax], dl
  000a6	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$2[ebp]
  000ac	0f be 8c 05 78
	ff ff ff	 movsx	 ecx, BYTE PTR _wad$[ebp+eax]
  000b4	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000ba	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _p$[ebp]
  000c0	83 c2 01	 add	 edx, 1
  000c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR _p$[ebp], edx
  000c9	83 bd 24 ff ff
	ff 00		 cmp	 DWORD PTR tv81[ebp], 0
  000d0	74 02		 je	 SHORT $LN5@Got_Reques
  000d2	eb a2		 jmp	 SHORT $LN4@Got_Reques
$LN5@Got_Reques:
  000d4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$2[ebp]
  000da	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  000e0	81 bd 28 ff ff
	ff 81 00 00 00	 cmp	 DWORD PTR $T1[ebp], 129	; 00000081H
  000ea	73 02		 jae	 SHORT $LN9@Got_Reques
  000ec	eb 06		 jmp	 SHORT $LN10@Got_Reques
$LN9@Got_Reques:
  000ee	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  000f3	90		 npad	 1
$LN10@Got_Reques:
  000f4	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  000fa	c6 84 0d 78 ff
	ff ff 00	 mov	 BYTE PTR _wad$[ebp+ecx], 0

; 289  : 		SendFile(node, wad, id);

  00102	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR _id$[ebp]
  00109	50		 push	 eax
  0010a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _wad$[ebp]
  00110	51		 push	 ecx
  00111	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 _SendFile
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 290  : 	}

  0011d	e9 02 ff ff ff	 jmp	 $LN2@Got_Reques
$LN3@Got_Reques:

; 291  : }

  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	33 cd		 xor	 ecx, ebp
  0012a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
_Got_RequestFilePak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _SendRequestFile
_TEXT	SEGMENT
$T1 = -11524						; size = 4
_p_tmp$2 = -11008					; size = 4
_p_tmp$3 = -11004					; size = 4
_p_tmp$4 = -11000					; size = 4
_tmp_i$5 = -10996					; size = 4
_p_tmp$6 = -10992					; size = 4
_j$7 = -10988						; size = 4
_strl$8 = -10984					; size = 4
_s$9 = -10980						; size = 10944
_coulddownload$10 = -36					; size = 4
_availablefreespace$ = -32				; size = 8
_totalfreespaceneeded$ = -24				; size = 8
_i$ = -16						; size = 4
_p$ = -12						; size = 4
_candownloadfiles$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_SendRequestFile PROC					; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 2d 00 00	 mov	 eax, 11524		; 00002d04H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 188  : 	boolean candownloadfiles = true;

  0001a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _candownloadfiles$[ebp], 1

; 189  : 	char *p;
; 190  : 	INT32 i;
; 191  : 	INT64 totalfreespaceneeded = 0, availablefreespace;

  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	66 0f 13 45 e8	 movlpd	 QWORD PTR _totalfreespaceneeded$[ebp], xmm0

; 192  : 
; 193  : 	if (M_CheckParm("-nodownload"))

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EEIMJBNI@?9nodownload@
  0002e	e8 00 00 00 00	 call	 _M_CheckParm
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	74 09		 je	 SHORT $LN29@SendReques

; 194  : 		candownloadfiles = false;

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _candownloadfiles$[ebp], 0
  00041	eb 7d		 jmp	 SHORT $LN3@SendReques
$LN29@SendReques:

; 195  : 	else
; 196  : 		for (i = 0; i < fileneedednum; i++)

  00043	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004a	eb 09		 jmp	 SHORT $LN4@SendReques
$LN2@SendReques:
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@SendReques:
  00055	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00058	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  0005e	7d 60		 jge	 SHORT $LN3@SendReques

; 197  : 			if (fileneeded[i].status != FS_FOUND && fileneeded[i].status != FS_OPEN
; 198  : 				&& fileneeded[i].important && (fileneeded[i].willsend == 0 || fileneeded[i].willsend == 2))

  00060	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00067	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR _fileneeded[eax+160], 1
  0006e	74 4e		 je	 SHORT $LN31@SendReques
  00070	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00077	83 b8 a0 00 00
	00 04		 cmp	 DWORD PTR _fileneeded[eax+160], 4
  0007e	74 3e		 je	 SHORT $LN31@SendReques
  00080	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00087	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax]
  0008e	85 c9		 test	 ecx, ecx
  00090	74 2c		 je	 SHORT $LN31@SendReques
  00092	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00099	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax+1]
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 13		 je	 SHORT $LN32@SendReques
  000a4	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000ab	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax+1]
  000b2	83 f9 02	 cmp	 ecx, 2
  000b5	75 07		 jne	 SHORT $LN31@SendReques
$LN32@SendReques:

; 199  : 			{
; 200  : 				candownloadfiles = false;

  000b7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _candownloadfiles$[ebp], 0
$LN31@SendReques:

; 201  : 			}

  000be	eb 8c		 jmp	 SHORT $LN2@SendReques
$LN3@SendReques:

; 202  : 
; 203  : 	if (!candownloadfiles)

  000c0	83 7d f8 00	 cmp	 DWORD PTR _candownloadfiles$[ebp], 0
  000c4	0f 85 6b 02 00
	00		 jne	 $LN33@SendReques

; 204  : 	{
; 205  : 		boolean coulddownload = true;

  000ca	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _coulddownload$10[ebp], 1

; 206  : 		char s[(MAX_WADPATH+100)*MAX_WADFILES] = ""; // more space than needed but safe

  000d1	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  000d6	88 85 1c d5 ff
	ff		 mov	 BYTE PTR _s$9[ebp], al
  000dc	68 bf 2a 00 00	 push	 10943			; 00002abfH
  000e1	6a 00		 push	 0
  000e3	8d 85 1d d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp+1]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _memset
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  : 
; 208  : 		for (i = 0; i < fileneedednum; i++)

  000f2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f9	eb 09		 jmp	 SHORT $LN7@SendReques
$LN5@SendReques:
  000fb	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000fe	83 c0 01	 add	 eax, 1
  00101	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN7@SendReques:
  00104	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00107	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  0010d	0f 8d f4 01 00
	00		 jge	 $LN6@SendReques

; 209  : 			if (fileneeded[i].status != FS_FOUND && fileneeded[i].status != FS_OPEN
; 210  : 				&& fileneeded[i].important)

  00113	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0011a	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR _fileneeded[eax+160], 1
  00121	0f 84 db 01 00
	00		 je	 $LN34@SendReques
  00127	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0012e	83 b8 a0 00 00
	00 04		 cmp	 DWORD PTR _fileneeded[eax+160], 4
  00135	0f 84 c7 01 00
	00		 je	 $LN34@SendReques
  0013b	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00142	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax]
  00149	85 c9		 test	 ecx, ecx
  0014b	0f 84 b1 01 00
	00		 je	 $LN34@SendReques

; 211  : 			{
; 212  : 				size_t strl;
; 213  : 
; 214  : 				strl = strlen(s);

  00151	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _strlen
  0015d	83 c4 04	 add	 esp, 4
  00160	89 85 18 d5 ff
	ff		 mov	 DWORD PTR _strl$8[ebp], eax

; 215  : 				sprintf(&s[strl], "  \"%s\" (%dKB)", fileneeded[i].filename,

  00166	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0016d	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+156]
  00173	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00176	51		 push	 ecx
  00177	69 55 f0 a4 00
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 164
  0017e	81 c2 02 00 00
	00		 add	 edx, OFFSET _fileneeded+2
  00184	52		 push	 edx
  00185	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KHFMAOIF@?5?5?$CC?$CFs?$CC?5?$CI?$CFdKB?$CJ@
  0018a	8b 85 18 d5 ff
	ff		 mov	 eax, DWORD PTR _strl$8[ebp]
  00190	8d 8c 05 1c d5
	ff ff		 lea	 ecx, DWORD PTR _s$9[ebp+eax]
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 _sprintf
  0019d	83 c4 10	 add	 esp, 16			; 00000010H

; 216  : 					fileneeded[i].totalsize / 1024);
; 217  : 
; 218  : 				if (fileneeded[i].status == FS_NOTFOUND)

  001a0	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  001a7	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR _fileneeded[eax+160], 0
  001ae	75 19		 jne	 SHORT $LN35@SendReques

; 219  : 					strcat(s, " not found");

  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GDEBAJHI@?5not?5found@
  001b5	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _strcat
  001c1	83 c4 08	 add	 esp, 8
  001c4	e9 ce 00 00 00	 jmp	 $LN37@SendReques
$LN35@SendReques:

; 220  : 				else if (fileneeded[i].status == FS_MD5SUMBAD)

  001c9	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  001d0	83 b8 a0 00 00
	00 05		 cmp	 DWORD PTR _fileneeded[eax+160], 5
  001d7	0f 85 ba 00 00
	00		 jne	 $LN37@SendReques

; 221  : 				{
; 222  : 					INT32 j;
; 223  : 
; 224  : 					strcat(s, " has wrong md5sum, needs: ");

  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BPCPJEJG@?5has?5wrong?5md5sum?0?5needs?3?5@
  001e2	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 _strcat
  001ee	83 c4 08	 add	 esp, 8

; 225  : 					strl = strlen(s);

  001f1	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _strlen
  001fd	83 c4 04	 add	 esp, 4
  00200	89 85 18 d5 ff
	ff		 mov	 DWORD PTR _strl$8[ebp], eax

; 226  : 
; 227  : 					for (j = 0; j < 16; j++)

  00206	c7 85 14 d5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$7[ebp], 0
  00210	eb 0f		 jmp	 SHORT $LN10@SendReques
$LN8@SendReques:
  00212	8b 85 14 d5 ff
	ff		 mov	 eax, DWORD PTR _j$7[ebp]
  00218	83 c0 01	 add	 eax, 1
  0021b	89 85 14 d5 ff
	ff		 mov	 DWORD PTR _j$7[ebp], eax
$LN10@SendReques:
  00221	83 bd 14 d5 ff
	ff 10		 cmp	 DWORD PTR _j$7[ebp], 16	; 00000010H
  00228	7d 3c		 jge	 SHORT $LN9@SendReques

; 228  : 						sprintf(&s[strl+2*j], "%02x", fileneeded[i].md5sum[j]);

  0022a	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00231	8b 8d 14 d5 ff
	ff		 mov	 ecx, DWORD PTR _j$7[ebp]
  00237	0f b6 94 08 82
	00 00 00	 movzx	 edx, BYTE PTR _fileneeded[eax+ecx+130]
  0023f	52		 push	 edx
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_04NOJCDH@?$CF02x@
  00245	8b 85 14 d5 ff
	ff		 mov	 eax, DWORD PTR _j$7[ebp]
  0024b	8b 8d 18 d5 ff
	ff		 mov	 ecx, DWORD PTR _strl$8[ebp]
  00251	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00254	8d 84 15 1c d5
	ff ff		 lea	 eax, DWORD PTR _s$9[ebp+edx]
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 _sprintf
  00261	83 c4 0c	 add	 esp, 12			; 0000000cH
  00264	eb ac		 jmp	 SHORT $LN8@SendReques
$LN9@SendReques:

; 229  : 					s[strl+32]='\0';

  00266	8b 85 18 d5 ff
	ff		 mov	 eax, DWORD PTR _strl$8[ebp]
  0026c	83 c0 20	 add	 eax, 32			; 00000020H
  0026f	89 85 fc d2 ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00275	81 bd fc d2 ff
	ff c0 2a 00 00	 cmp	 DWORD PTR $T1[ebp], 10944 ; 00002ac0H
  0027f	73 02		 jae	 SHORT $LN46@SendReques
  00281	eb 06		 jmp	 SHORT $LN47@SendReques
$LN46@SendReques:
  00283	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00288	90		 npad	 1
$LN47@SendReques:
  00289	8b 8d fc d2 ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0028f	c6 84 0d 1c d5
	ff ff 00	 mov	 BYTE PTR _s$9[ebp+ecx], 0
$LN37@SendReques:

; 230  : 				}
; 231  : 				if (fileneeded[i].willsend != 1)

  00297	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0029e	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax+1]
  002a5	83 f9 01	 cmp	 ecx, 1
  002a8	74 44		 je	 SHORT $LN40@SendReques

; 232  : 				{
; 233  : 					coulddownload = false;

  002aa	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _coulddownload$10[ebp], 0

; 234  : 
; 235  : 					if (fileneeded[i].willsend == 2)

  002b1	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  002b8	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax+1]
  002bf	83 f9 02	 cmp	 ecx, 2
  002c2	75 16		 jne	 SHORT $LN39@SendReques

; 236  : 						strcat(s, " (server has downloading disabled)");

  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DAIMMJBJ@?5?$CIserver?5has?5downloading?5disabl@
  002c9	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 _strcat
  002d5	83 c4 08	 add	 esp, 8
  002d8	eb 14		 jmp	 SHORT $LN40@SendReques
$LN39@SendReques:

; 237  : 					else
; 238  : 						strcat(s, " (too big to download from server)");

  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@MMPLPGPI@?5?$CItoo?5big?5to?5download?5from?5serv@
  002df	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 _strcat
  002eb	83 c4 08	 add	 esp, 8
$LN40@SendReques:

; 239  : 				}
; 240  : 				strcat(s, "\n");

  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  002f3	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  002f9	50		 push	 eax
  002fa	e8 00 00 00 00	 call	 _strcat
  002ff	83 c4 08	 add	 esp, 8
$LN34@SendReques:

; 241  : 			}

  00302	e9 f4 fd ff ff	 jmp	 $LN5@SendReques
$LN6@SendReques:

; 242  : 
; 243  : 		if (coulddownload)

  00307	83 7d dc 00	 cmp	 DWORD PTR _coulddownload$10[ebp], 0
  0030b	74 14		 je	 SHORT $LN41@SendReques

; 244  : 			I_Error("To play on this server you should have these files:\n%s\n"

  0030d	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  00313	50		 push	 eax
  00314	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@FEEPMNPI@To?5play?5on?5this?5server?5you?5shou@
  00319	e8 00 00 00 00	 call	 _I_Error
  0031e	83 c4 08	 add	 esp, 8
$LN41@SendReques:

; 245  : 				"Remove -nodownload if you want to download the files!\n", s);
; 246  : 
; 247  : 		I_Error("To play on this server you need these files:\n%s\n"

  00321	8d 85 1c d5 ff
	ff		 lea	 eax, DWORD PTR _s$9[ebp]
  00327	50		 push	 eax
  00328	68 00 00 00 00	 push	 OFFSET ??_C@_0HB@PJBPNCAO@To?5play?5on?5this?5server?5you?5need@
  0032d	e8 00 00 00 00	 call	 _I_Error
  00332	83 c4 08	 add	 esp, 8
$LN33@SendReques:

; 248  : 			"Make sure you get them somewhere, or you won't be able to join!\n", s);
; 249  : 	}
; 250  : 
; 251  : 	netbuffer->packettype = PT_REQUESTFILE;

  00335	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0033a	c6 40 06 0f	 mov	 BYTE PTR [eax+6], 15	; 0000000fH

; 252  : 	p = (char *)netbuffer->u.textcmd;

  0033e	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00343	83 c0 08	 add	 eax, 8
  00346	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 253  : 	for (i = 0; i < fileneedednum; i++)

  00349	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00350	eb 09		 jmp	 SHORT $LN13@SendReques
$LN11@SendReques:
  00352	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00355	83 c0 01	 add	 eax, 1
  00358	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN13@SendReques:
  0035b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0035e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  00364	0f 8d 80 01 00
	00		 jge	 $LN12@SendReques

; 254  : 		if ((fileneeded[i].status == FS_NOTFOUND || fileneeded[i].status == FS_MD5SUMBAD)
; 255  : 			&& fileneeded[i].important)

  0036a	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00371	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR _fileneeded[eax+160], 0
  00378	74 14		 je	 SHORT $LN43@SendReques
  0037a	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00381	83 b8 a0 00 00
	00 05		 cmp	 DWORD PTR _fileneeded[eax+160], 5
  00388	0f 85 57 01 00
	00		 jne	 $LN42@SendReques
$LN43@SendReques:
  0038e	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00395	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax]
  0039c	85 c9		 test	 ecx, ecx
  0039e	0f 84 41 01 00
	00		 je	 $LN42@SendReques

; 256  : 		{
; 257  : 			totalfreespaceneeded += fileneeded[i].totalsize;

  003a4	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  003ab	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+156]
  003b1	33 d2		 xor	 edx, edx
  003b3	03 4d e8	 add	 ecx, DWORD PTR _totalfreespaceneeded$[ebp]
  003b6	13 55 ec	 adc	 edx, DWORD PTR _totalfreespaceneeded$[ebp+4]
  003b9	89 4d e8	 mov	 DWORD PTR _totalfreespaceneeded$[ebp], ecx
  003bc	89 55 ec	 mov	 DWORD PTR _totalfreespaceneeded$[ebp+4], edx

; 258  : 			nameonly(fileneeded[i].filename);

  003bf	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  003c6	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  003cb	50		 push	 eax
  003cc	e8 00 00 00 00	 call	 _nameonly
  003d1	83 c4 04	 add	 esp, 4
$LN16@SendReques:

; 259  : 			WRITEUINT8(p, i); // fileid

  003d4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  003d7	89 85 10 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$6[ebp], eax
  003dd	8b 85 10 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$6[ebp]
  003e3	8a 4d f0	 mov	 cl, BYTE PTR _i$[ebp]
  003e6	88 08		 mov	 BYTE PTR [eax], cl
  003e8	8b 85 10 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$6[ebp]
  003ee	83 c0 01	 add	 eax, 1
  003f1	89 85 10 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$6[ebp], eax
  003f7	8b 85 10 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$6[ebp]
  003fd	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  00400	33 c0		 xor	 eax, eax
  00402	75 d0		 jne	 SHORT $LN16@SendReques

; 260  : 			WRITESTRINGN(p, fileneeded[i].filename, MAX_WADPATH);

  00404	c7 85 0c d5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmp_i$5[ebp], 0
  0040e	eb 0f		 jmp	 SHORT $LN19@SendReques
$LN17@SendReques:
  00410	8b 85 0c d5 ff
	ff		 mov	 eax, DWORD PTR _tmp_i$5[ebp]
  00416	83 c0 01	 add	 eax, 1
  00419	89 85 0c d5 ff
	ff		 mov	 DWORD PTR _tmp_i$5[ebp], eax
$LN19@SendReques:
  0041f	81 bd 0c d5 ff
	ff 80 00 00 00	 cmp	 DWORD PTR _tmp_i$5[ebp], 128 ; 00000080H
  00429	73 5c		 jae	 SHORT $LN18@SendReques
  0042b	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00432	8b 8d 0c d5 ff
	ff		 mov	 ecx, DWORD PTR _tmp_i$5[ebp]
  00438	0f be 94 08 02
	00 00 00	 movsx	 edx, BYTE PTR _fileneeded[eax+ecx+2]
  00440	85 d2		 test	 edx, edx
  00442	74 43		 je	 SHORT $LN18@SendReques
$LN22@SendReques:
  00444	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00447	89 85 08 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$4[ebp], eax
  0044d	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00454	8b 8d 08 d5 ff
	ff		 mov	 ecx, DWORD PTR _p_tmp$4[ebp]
  0045a	8b 95 0c d5 ff
	ff		 mov	 edx, DWORD PTR _tmp_i$5[ebp]
  00460	8a 84 10 02 00
	00 00		 mov	 al, BYTE PTR _fileneeded[eax+edx+2]
  00467	88 01		 mov	 BYTE PTR [ecx], al
  00469	8b 85 08 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  0046f	83 c0 01	 add	 eax, 1
  00472	89 85 08 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$4[ebp], eax
  00478	8b 85 08 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  0047e	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  00481	33 c0		 xor	 eax, eax
  00483	75 bf		 jne	 SHORT $LN22@SendReques
  00485	eb 89		 jmp	 SHORT $LN17@SendReques
$LN18@SendReques:
  00487	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0048a	89 85 04 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$3[ebp], eax
  00490	8b 85 04 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  00496	c6 00 00	 mov	 BYTE PTR [eax], 0
  00499	8b 85 04 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  0049f	83 c0 01	 add	 eax, 1
  004a2	89 85 04 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$3[ebp], eax
  004a8	8b 85 04 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  004ae	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  004b1	33 c0		 xor	 eax, eax
  004b3	75 d2		 jne	 SHORT $LN18@SendReques

; 261  : 			// put it in download dir
; 262  : 			strcatbf(fileneeded[i].filename, downloaddir, "/");

  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1@
  004ba	68 00 00 00 00	 push	 OFFSET _downloaddir
  004bf	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  004c6	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  004cb	50		 push	 eax
  004cc	e8 00 00 00 00	 call	 _strcatbf
  004d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 			fileneeded[i].status = FS_REQUESTED;

  004d4	69 45 f0 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  004db	c7 80 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 2
$LN42@SendReques:

; 264  : 		}

  004e5	e9 68 fe ff ff	 jmp	 $LN11@SendReques
$LN12@SendReques:

; 265  : 	WRITEUINT8(p, 0xFF);

  004ea	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  004ed	89 85 00 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$2[ebp], eax
  004f3	8b 85 00 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  004f9	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  004fc	8b 85 00 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00502	83 c0 01	 add	 eax, 1
  00505	89 85 00 d5 ff
	ff		 mov	 DWORD PTR _p_tmp$2[ebp], eax
  0050b	8b 85 00 d5 ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00511	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  00514	33 c0		 xor	 eax, eax
  00516	75 d2		 jne	 SHORT $LN12@SendReques

; 266  : 	I_GetDiskFreeSpace(&availablefreespace);

  00518	8d 45 e0	 lea	 eax, DWORD PTR _availablefreespace$[ebp]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 _I_GetDiskFreeSpace
  00521	83 c4 04	 add	 esp, 4

; 267  : 	if (totalfreespaceneeded > availablefreespace)

  00524	8b 45 ec	 mov	 eax, DWORD PTR _totalfreespaceneeded$[ebp+4]
  00527	3b 45 e4	 cmp	 eax, DWORD PTR _availablefreespace$[ebp+4]
  0052a	7c 33		 jl	 SHORT $LN44@SendReques
  0052c	7f 08		 jg	 SHORT $LN48@SendReques
  0052e	8b 4d e8	 mov	 ecx, DWORD PTR _totalfreespaceneeded$[ebp]
  00531	3b 4d e0	 cmp	 ecx, DWORD PTR _availablefreespace$[ebp]
  00534	76 29		 jbe	 SHORT $LN44@SendReques
$LN48@SendReques:

; 268  : 		I_Error("To play on this server you must download %"PRIdS" KB,\n"

  00536	8b 45 e0	 mov	 eax, DWORD PTR _availablefreespace$[ebp]
  00539	8b 55 e4	 mov	 edx, DWORD PTR _availablefreespace$[ebp+4]
  0053c	b1 0a		 mov	 cl, 10			; 0000000aH
  0053e	e8 00 00 00 00	 call	 __allshr
  00543	50		 push	 eax
  00544	8b 45 e8	 mov	 eax, DWORD PTR _totalfreespaceneeded$[ebp]
  00547	8b 55 ec	 mov	 edx, DWORD PTR _totalfreespaceneeded$[ebp+4]
  0054a	b1 0a		 mov	 cl, 10			; 0000000aH
  0054c	e8 00 00 00 00	 call	 __allshr
  00551	50		 push	 eax
  00552	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@EFCCCBLE@To?5play?5on?5this?5server?5you?5must@
  00557	e8 00 00 00 00	 call	 _I_Error
  0055c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@SendReques:

; 269  : 			"but you have only %"PRIdS" KB free space on this drive\n",
; 270  : 			(size_t)(totalfreespaceneeded>>10), (size_t)(availablefreespace>>10));
; 271  : 
; 272  : 	// prepare to download
; 273  : 	I_mkdir(downloaddir, 0755);

  0055f	68 ed 01 00 00	 push	 493			; 000001edH
  00564	68 00 00 00 00	 push	 OFFSET _downloaddir
  00569	e8 00 00 00 00	 call	 _I_mkdir
  0056e	83 c4 08	 add	 esp, 8

; 274  : 	return HSendPacket(servernode, true, 0, p - (char *)netbuffer->u.textcmd);

  00571	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00576	83 c0 08	 add	 eax, 8
  00579	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  0057c	2b c8		 sub	 ecx, eax
  0057e	51		 push	 ecx
  0057f	6a 00		 push	 0
  00581	6a 01		 push	 1
  00583	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR _servernode
  0058a	52		 push	 edx
  0058b	e8 00 00 00 00	 call	 _HSendPacket
  00590	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@SendReques:

; 275  : }

  00593	5f		 pop	 edi
  00594	5e		 pop	 esi
  00595	5b		 pop	 ebx
  00596	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00599	33 cd		 xor	 ecx, ebp
  0059b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a0	8b e5		 mov	 esp, ebp
  005a2	5d		 pop	 ebp
  005a3	c3		 ret	 0
_SendRequestFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _Got_Filetxpak
_TEXT	SEGMENT
_size$1 = -12						; size = 2
_pos$2 = -8						; size = 4
_filenum$ = -4						; size = 4
_Got_Filetxpak PROC					; COMDAT

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 594  : 	INT32 filenum = netbuffer->u.filetxpak.fileid;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0000e	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00012	89 4d fc	 mov	 DWORD PTR _filenum$[ebp], ecx

; 595  : 	static INT32 filetime = 0;
; 596  : 
; 597  : 	if (filenum >= fileneedednum)

  00015	8b 45 fc	 mov	 eax, DWORD PTR _filenum$[ebp]
  00018	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  0001e	7c 43		 jl	 SHORT $LN2@Got_Filetx

; 598  : 	{
; 599  : 		DEBFILE(va("fileframent not needed %d>%d\n",filenum, fileneedednum));

  00020	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00027	74 35		 je	 SHORT $LN3@Got_Filetx
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0002e	50		 push	 eax
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fileneedednum
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _filenum$[ebp]
  00039	52		 push	 edx
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@POFLMOLC@fileframent?5not?5needed?5?$CFd?$DO?$CFd?6@
  0003f	e8 00 00 00 00	 call	 _va
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _fputs
  0004d	83 c4 08	 add	 esp, 8
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _fflush
  0005b	83 c4 04	 add	 esp, 4
$LN3@Got_Filetx:

; 600  : 		return;

  0005e	e9 da 03 00 00	 jmp	 $LN15@Got_Filetx
$LN2@Got_Filetx:

; 601  : 	}
; 602  : 
; 603  : 	if (fileneeded[filenum].status == FS_REQUESTED)

  00063	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  0006a	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR _fileneeded[eax+160], 2
  00071	0f 85 aa 00 00
	00		 jne	 $LN4@Got_Filetx

; 604  : 	{
; 605  : 		if (fileneeded[filenum].phandle) I_Error("Got_Filetxpak: allready open file\n");

  00077	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  0007e	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR _fileneeded[eax+148], 0
  00085	74 0d		 je	 SHORT $LN5@Got_Filetx
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HOEMBJME@Got_Filetxpak?3?5allready?5open?5fi@
  0008c	e8 00 00 00 00	 call	 _I_Error
  00091	83 c4 04	 add	 esp, 4
$LN5@Got_Filetx:

; 606  : 			fileneeded[filenum].phandle = fopen(fileneeded[filenum].filename, "wb");

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00099	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  000a0	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _fopen
  000ab	83 c4 08	 add	 esp, 8
  000ae	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _filenum$[ebp], 164
  000b5	89 81 94 00 00
	00		 mov	 DWORD PTR _fileneeded[ecx+148], eax

; 607  : 		if (!fileneeded[filenum].phandle) I_Error("Can't create file %s: disk full ?",fileneeded[filenum].filename);

  000bb	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  000c2	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR _fileneeded[eax+148], 0
  000c9	75 1a		 jne	 SHORT $LN6@Got_Filetx
  000cb	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  000d2	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  000d7	50		 push	 eax
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IJMDJKC@Can?8t?5create?5file?5?$CFs?3?5disk?5full@
  000dd	e8 00 00 00 00	 call	 _I_Error
  000e2	83 c4 08	 add	 esp, 8
$LN6@Got_Filetx:

; 608  : 			CONS_Printf("\r%s...\n",fileneeded[filenum].filename);

  000e5	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  000ec	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_07OHMLJGBL@?$AN?$CFs?4?4?4?6@
  000f7	e8 00 00 00 00	 call	 _CONS_Printf
  000fc	83 c4 08	 add	 esp, 8

; 609  : 		fileneeded[filenum].currentsize = 0;

  000ff	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  00106	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR _fileneeded[eax+152], 0

; 610  : 		fileneeded[filenum].status = FS_DOWNLOADING;

  00110	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  00117	c7 80 a0 00 00
	00 03 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 3
$LN4@Got_Filetx:

; 611  : 	}
; 612  : 
; 613  : 	if (fileneeded[filenum].status == FS_DOWNLOADING)

  00121	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  00128	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR _fileneeded[eax+160], 3
  0012f	0f 85 cb 02 00
	00		 jne	 $LN7@Got_Filetx

; 614  : 	{
; 615  : 		UINT32 pos = LONG(netbuffer->u.filetxpak.position);

  00135	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0013a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0013d	89 4d f8	 mov	 DWORD PTR _pos$2[ebp], ecx

; 616  : 		UINT16 size = SHORT(netbuffer->u.filetxpak.size);

  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00145	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00149	66 89 4d f4	 mov	 WORD PTR _size$1[ebp], cx

; 617  : 		// use a special tric to know when file is finished (not allways used)
; 618  : 		// WARNING: filepak can arrive out of order so don't stop now !
; 619  : 		if (pos & 0x80000000)

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _pos$2[ebp]
  00150	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00155	74 1f		 je	 SHORT $LN9@Got_Filetx

; 620  : 		{
; 621  : 			pos &= ~0x80000000;

  00157	8b 45 f8	 mov	 eax, DWORD PTR _pos$2[ebp]
  0015a	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0015f	89 45 f8	 mov	 DWORD PTR _pos$2[ebp], eax

; 622  : 			fileneeded[filenum].totalsize = pos + size;

  00162	0f b7 45 f4	 movzx	 eax, WORD PTR _size$1[ebp]
  00166	03 45 f8	 add	 eax, DWORD PTR _pos$2[ebp]
  00169	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _filenum$[ebp], 164
  00170	89 81 9c 00 00
	00		 mov	 DWORD PTR _fileneeded[ecx+156], eax
$LN9@Got_Filetx:

; 623  : 		}
; 624  : 		// we can receive packet in the wrong order, anyway all os support gaped file
; 625  : 		fseek(fileneeded[filenum].phandle,pos,SEEK_SET);

  00176	6a 00		 push	 0
  00178	8b 45 f8	 mov	 eax, DWORD PTR _pos$2[ebp]
  0017b	50		 push	 eax
  0017c	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _filenum$[ebp], 164
  00183	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR _fileneeded[ecx+148]
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 _fseek
  0018f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 626  : 		if (fwrite(netbuffer->u.filetxpak.data,size,1,fileneeded[filenum].phandle)!=1)

  00192	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  00199	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+148]
  0019f	51		 push	 ecx
  001a0	6a 01		 push	 1
  001a2	0f b7 55 f4	 movzx	 edx, WORD PTR _size$1[ebp]
  001a6	52		 push	 edx
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  001ac	83 c0 12	 add	 eax, 18			; 00000012H
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _fwrite
  001b5	83 c4 10	 add	 esp, 16			; 00000010H
  001b8	83 f8 01	 cmp	 eax, 1
  001bb	74 3b		 je	 SHORT $LN10@Got_Filetx

; 627  : 			I_Error("Can't write %s: disk full ? or %s\n",fileneeded[filenum].filename, strerror(ferror(fileneeded[filenum].phandle)));

  001bd	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  001c4	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+148]
  001ca	51		 push	 ecx
  001cb	e8 00 00 00 00	 call	 _ferror
  001d0	83 c4 04	 add	 esp, 4
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 _strerror
  001d9	83 c4 04	 add	 esp, 4
  001dc	50		 push	 eax
  001dd	69 55 fc a4 00
	00 00		 imul	 edx, DWORD PTR _filenum$[ebp], 164
  001e4	81 c2 02 00 00
	00		 add	 edx, OFFSET _fileneeded+2
  001ea	52		 push	 edx
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NHMJMAME@Can?8t?5write?5?$CFs?3?5disk?5full?5?$DP?5or?5@
  001f0	e8 00 00 00 00	 call	 _I_Error
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@Got_Filetx:

; 628  : 		fileneeded[filenum].currentsize += size;

  001f8	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  001ff	0f b7 4d f4	 movzx	 ecx, WORD PTR _size$1[ebp]
  00203	03 88 98 00 00
	00		 add	 ecx, DWORD PTR _fileneeded[eax+152]
  00209	69 55 fc a4 00
	00 00		 imul	 edx, DWORD PTR _filenum$[ebp], 164
  00210	89 8a 98 00 00
	00		 mov	 DWORD PTR _fileneeded[edx+152], ecx

; 629  : 		if (filetime == 0)

  00216	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?filetime@?1??Got_Filetxpak@@9@9, 0
  0021d	0f 85 60 01 00
	00		 jne	 $LN13@Got_Filetx

; 630  : 		{
; 631  : 			Net_GetNetStat();

  00223	e8 00 00 00 00	 call	 _Net_GetNetStat
  00228	90		 npad	 1

; 632  : 			CONS_Printf("\r%s %uK/%uK %.1fK/s\n",fileneeded[filenum].filename,

  00229	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _getbps
  00231	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4090000000000000
  00239	83 ec 08	 sub	 esp, 8
  0023c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00241	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  00248	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+156]
  0024e	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00251	51		 push	 ecx
  00252	69 55 fc a4 00
	00 00		 imul	 edx, DWORD PTR _filenum$[ebp], 164
  00259	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR _fileneeded[edx+152]
  0025f	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00262	50		 push	 eax
  00263	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _filenum$[ebp], 164
  0026a	81 c1 02 00 00
	00		 add	 ecx, OFFSET _fileneeded+2
  00270	51		 push	 ecx
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HGMKIEKL@?$AN?$CFs?5?$CFuK?1?$CFuK?5?$CF?41fK?1s?6@
  00276	e8 00 00 00 00	 call	 _CONS_Printf
  0027b	83 c4 18	 add	 esp, 24			; 00000018H

; 633  : 			                                       fileneeded[filenum].currentsize>>10,
; 634  : 			                                       fileneeded[filenum].totalsize>>10,
; 635  : 			                                       ((double)getbps)/1024);
; 636  : 
; 637  : 			// Draw a status box in the middle of the screen.
; 638  : 			M_DrawTextBox(24, (BASEVIDHEIGHT/2)-7, 32, 4);

  0027e	6a 04		 push	 4
  00280	6a 20		 push	 32			; 00000020H
  00282	6a 5d		 push	 93			; 0000005dH
  00284	6a 18		 push	 24			; 00000018H
  00286	e8 00 00 00 00	 call	 _M_DrawTextBox
  0028b	83 c4 10	 add	 esp, 16			; 00000010H

; 639  : 			V_DrawCenteredString(BASEVIDWIDTH/2, BASEVIDHEIGHT/2, 0, "Downloading files...");

  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@LFICHMKE@Downloading?5files?4?4?4@
  00293	6a 00		 push	 0
  00295	6a 64		 push	 100			; 00000064H
  00297	68 a0 00 00 00	 push	 160			; 000000a0H
  0029c	e8 00 00 00 00	 call	 _V_DrawCenteredString
  002a1	83 c4 10	 add	 esp, 16			; 00000010H

; 640  : 			V_DrawCenteredString(BASEVIDWIDTH/2, (BASEVIDHEIGHT/2)+12, 0, va("\r%s\n",fileneeded[filenum].filename));

  002a4	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  002ab	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  002b0	50		 push	 eax
  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_04PKPJKNNM@?$AN?$CFs?6@
  002b6	e8 00 00 00 00	 call	 _va
  002bb	83 c4 08	 add	 esp, 8
  002be	50		 push	 eax
  002bf	6a 00		 push	 0
  002c1	6a 70		 push	 112			; 00000070H
  002c3	68 a0 00 00 00	 push	 160			; 000000a0H
  002c8	e8 00 00 00 00	 call	 _V_DrawCenteredString
  002cd	83 c4 10	 add	 esp, 16			; 00000010H

; 641  : 			if (fileneeded[filenum].totalsize != UINT32_MAX)

  002d0	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  002d7	83 b8 9c 00 00
	00 ff		 cmp	 DWORD PTR _fileneeded[eax+156], -1
  002de	74 5b		 je	 SHORT $LN12@Got_Filetx

; 642  : 				V_DrawCenteredString(BASEVIDWIDTH/2, (BASEVIDHEIGHT/2)+24, 0,

  002e0	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _getbps
  002e8	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4090000000000000
  002f0	83 ec 08	 sub	 esp, 8
  002f3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002f8	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  002ff	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+156]
  00305	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00308	51		 push	 ecx
  00309	69 55 fc a4 00
	00 00		 imul	 edx, DWORD PTR _filenum$[ebp], 164
  00310	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR _fileneeded[edx+152]
  00316	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00319	50		 push	 eax
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DOKKCPOJ@?$CFdK?1?$CFdK?5?$CF?41fK?1s?6@
  0031f	e8 00 00 00 00	 call	 _va
  00324	83 c4 14	 add	 esp, 20			; 00000014H
  00327	50		 push	 eax
  00328	6a 00		 push	 0
  0032a	6a 7c		 push	 124			; 0000007cH
  0032c	68 a0 00 00 00	 push	 160			; 000000a0H
  00331	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00336	83 c4 10	 add	 esp, 16			; 00000010H
  00339	eb 48		 jmp	 SHORT $LN13@Got_Filetx
$LN12@Got_Filetx:

; 643  : 		         va("%dK/%dK %.1fK/s\n",fileneeded[filenum].currentsize>>10,
; 644  : 		                                  fileneeded[filenum].totalsize>>10,
; 645  : 		                                  ((double)getbps)/1024));
; 646  : 			else //don't show the total file size if we don't know what it IS!
; 647  : 				V_DrawCenteredString(BASEVIDWIDTH/2, (BASEVIDHEIGHT/2)+24, 0,

  0033b	f2 0f 2a 05 00
	00 00 00	 cvtsi2sd xmm0, DWORD PTR _getbps
  00343	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4090000000000000
  0034b	83 ec 08	 sub	 esp, 8
  0034e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00353	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  0035a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+152]
  00360	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00363	51		 push	 ecx
  00364	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFFELOBI@?$CFuK?1?$DP?$DPK?5?$CF?41fK?1s?6@
  00369	e8 00 00 00 00	 call	 _va
  0036e	83 c4 10	 add	 esp, 16			; 00000010H
  00371	50		 push	 eax
  00372	6a 00		 push	 0
  00374	6a 7c		 push	 124			; 0000007cH
  00376	68 a0 00 00 00	 push	 160			; 000000a0H
  0037b	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00380	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@Got_Filetx:

; 648  : 				 va("%uK/??K %.1fK/s\n",fileneeded[filenum].currentsize>>10,
; 649  : 		                                 ((double)getbps)/1024));
; 650  : 		}
; 651  : 
; 652  : 		// finished?
; 653  : 		if (fileneeded[filenum].currentsize == fileneeded[filenum].totalsize)

  00383	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  0038a	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _filenum$[ebp], 164
  00391	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR _fileneeded[eax+152]
  00397	3b 91 9c 00 00
	00		 cmp	 edx, DWORD PTR _fileneeded[ecx+156]
  0039d	75 5f		 jne	 SHORT $LN14@Got_Filetx

; 654  : 		{
; 655  : 			fclose(fileneeded[filenum].phandle);

  0039f	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  003a6	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+148]
  003ac	51		 push	 ecx
  003ad	e8 00 00 00 00	 call	 _fclose
  003b2	83 c4 04	 add	 esp, 4

; 656  : 			fileneeded[filenum].phandle = NULL;

  003b5	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  003bc	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR _fileneeded[eax+148], 0

; 657  : 			fileneeded[filenum].status = FS_FOUND;

  003c6	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  003cd	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 1

; 658  : 			CONS_Printf(text[DOWNLOADING_DONE],

  003d7	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _filenum$[ebp], 164
  003de	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  003e3	50		 push	 eax
  003e4	b9 04 00 00 00	 mov	 ecx, 4
  003e9	69 d1 cf 00 00
	00		 imul	 edx, ecx, 207
  003ef	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  003f5	50		 push	 eax
  003f6	e8 00 00 00 00	 call	 _CONS_Printf
  003fb	83 c4 08	 add	 esp, 8
$LN14@Got_Filetx:

; 659  : 				fileneeded[filenum].filename);
; 660  : 		}
; 661  : 	}

  003fe	eb 0d		 jmp	 SHORT $LN8@Got_Filetx
$LN7@Got_Filetx:

; 662  : 	else
; 663  : 		I_Error("Received a file not requested\n");

  00400	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FOOJHAOG@Received?5a?5file?5not?5requested?6@
  00405	e8 00 00 00 00	 call	 _I_Error
  0040a	83 c4 04	 add	 esp, 4
$LN8@Got_Filetx:

; 664  : 	// send ack back quickly
; 665  : 
; 666  : 	if (++filetime == 4)

  0040d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?filetime@?1??Got_Filetxpak@@9@9
  00412	83 c0 01	 add	 eax, 1
  00415	a3 00 00 00 00	 mov	 DWORD PTR ?filetime@?1??Got_Filetxpak@@9@9, eax
  0041a	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR ?filetime@?1??Got_Filetxpak@@9@9, 4
  00421	75 1a		 jne	 SHORT $LN15@Got_Filetx

; 667  : 	{
; 668  : 		Net_SendAcks(servernode);

  00423	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR _servernode
  0042a	50		 push	 eax
  0042b	e8 00 00 00 00	 call	 _Net_SendAcks
  00430	83 c4 04	 add	 esp, 4

; 669  : 		filetime = 0;

  00433	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?filetime@?1??Got_Filetxpak@@9@9, 0
$LN15@Got_Filetx:

; 670  : 	}
; 671  : 
; 672  : }

  0043d	5f		 pop	 edi
  0043e	5e		 pop	 esi
  0043f	5b		 pop	 ebx
  00440	8b e5		 mov	 esp, ebp
  00442	5d		 pop	 ebp
  00443	c3		 ret	 0
_Got_Filetxpak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _FiletxTicker
_TEXT	SEGMENT
tv72 = -96						; size = 4
_filesize$1 = -28					; size = 4
_i$ = -24						; size = 4
_ram$ = -20						; size = 4
_packetsent$ = -16					; size = 4
_f$ = -12						; size = 4
_size$ = -8						; size = 4
_p$ = -4						; size = 4
_FiletxTicker PROC					; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 504  : 	static INT32 currentnode = 0;
; 505  : 	filetx_pak *p;
; 506  : 	size_t size;
; 507  : 	filetx_t *f;
; 508  : 	INT32 packetsent = PACKETPERTIC, ram, i;

  00009	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _software_MAXPACKETLENGTH
  00010	6b c8 23	 imul	 ecx, eax, 35
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _net_bandwidth
  00018	99		 cdq
  00019	f7 f9		 idiv	 ecx
  0001b	89 45 f0	 mov	 DWORD PTR _packetsent$[ebp], eax

; 509  : 
; 510  : 	if (!filetosend)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _filetosend, 0
  00025	75 05		 jne	 SHORT $LN7@FiletxTick

; 511  : 		return;

  00027	e9 66 03 00 00	 jmp	 $LN3@FiletxTick
$LN7@FiletxTick:

; 512  : 	if (!packetsent)

  0002c	83 7d f0 00	 cmp	 DWORD PTR _packetsent$[ebp], 0
  00030	75 09		 jne	 SHORT $LN8@FiletxTick

; 513  : 		packetsent++;

  00032	8b 45 f0	 mov	 eax, DWORD PTR _packetsent$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 f0	 mov	 DWORD PTR _packetsent$[ebp], eax
$LN8@FiletxTick:

; 514  : 	// (((sendbytes-nowsentbyte)*TICRATE)/(I_GetTime()-starttime)<(UINT32)net_bandwidth)
; 515  : 	while (packetsent-- && filetosend != 0)

  0003b	8b 45 f0	 mov	 eax, DWORD PTR _packetsent$[ebp]
  0003e	89 45 a0	 mov	 DWORD PTR tv72[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _packetsent$[ebp]
  00044	83 e9 01	 sub	 ecx, 1
  00047	89 4d f0	 mov	 DWORD PTR _packetsent$[ebp], ecx
  0004a	83 7d a0 00	 cmp	 DWORD PTR tv72[ebp], 0
  0004e	0f 84 3e 03 00
	00		 je	 $LN3@FiletxTick
  00054	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _filetosend, 0
  0005b	0f 84 31 03 00
	00		 je	 $LN3@FiletxTick

; 516  : 	{
; 517  : 		for (i = currentnode, ram = 0; ram < MAXNETNODES;

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?currentnode@?1??FiletxTicker@@9@9
  00066	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  00069	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ram$[ebp], 0
  00070	eb 1e		 jmp	 SHORT $LN6@FiletxTick
$LN4@FiletxTick:

; 518  : 			i = (i+1) % MAXNETNODES, ram++)

  00072	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0007d	79 05		 jns	 SHORT $LN26@FiletxTick
  0007f	48		 dec	 eax
  00080	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00083	40		 inc	 eax
$LN26@FiletxTick:
  00084	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  00087	8b 4d ec	 mov	 ecx, DWORD PTR _ram$[ebp]
  0008a	83 c1 01	 add	 ecx, 1
  0008d	89 4d ec	 mov	 DWORD PTR _ram$[ebp], ecx
$LN6@FiletxTick:

; 516  : 	{
; 517  : 		for (i = currentnode, ram = 0; ram < MAXNETNODES;

  00090	83 7d ec 20	 cmp	 DWORD PTR _ram$[ebp], 32 ; 00000020H
  00094	7d 11		 jge	 SHORT $LN5@FiletxTick

; 519  : 		{
; 520  : 			if (transfer[i].txlist)

  00096	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0009a	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _transfer[eax], 0
  000a1	74 02		 je	 SHORT $LN9@FiletxTick

; 521  : 				goto found;

  000a3	eb 15		 jmp	 SHORT $found$28
$LN9@FiletxTick:

; 522  : 		}

  000a5	eb cb		 jmp	 SHORT $LN4@FiletxTick
$LN5@FiletxTick:

; 523  : 		// no transfer to do
; 524  : 		I_Error("filetosend=%d but no filetosend found\n", filetosend);

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _filetosend
  000ac	50		 push	 eax
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KMDIGICE@filetosend?$DN?$CFd?5but?5no?5filetosend@
  000b2	e8 00 00 00 00	 call	 _I_Error
  000b7	83 c4 08	 add	 esp, 8
$found$28:

; 525  : 	found:
; 526  : 		currentnode = (i+1) % MAXNETNODES;

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000bd	83 c0 01	 add	 eax, 1
  000c0	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  000c5	79 05		 jns	 SHORT $LN27@FiletxTick
  000c7	48		 dec	 eax
  000c8	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000cb	40		 inc	 eax
$LN27@FiletxTick:
  000cc	a3 00 00 00 00	 mov	 DWORD PTR ?currentnode@?1??FiletxTicker@@9@9, eax

; 527  : 		f = transfer[i].txlist;

  000d1	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000d5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax]
  000db	89 4d f4	 mov	 DWORD PTR _f$[ebp], ecx

; 528  : 		ram = f->ram;

  000de	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	89 4d ec	 mov	 DWORD PTR _ram$[ebp], ecx

; 529  : 
; 530  : 		if (!transfer[i].currentfile) // file not already open

  000e6	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000ea	83 b8 08 00 00
	00 00		 cmp	 DWORD PTR _transfer[eax+8], 0
  000f1	0f 85 eb 00 00
	00		 jne	 $LN10@FiletxTick

; 531  : 		{
; 532  : 			if (!ram)

  000f7	83 7d ec 00	 cmp	 DWORD PTR _ram$[ebp], 0
  000fb	0f 85 c5 00 00
	00		 jne	 $LN11@FiletxTick

; 533  : 			{
; 534  : 				long filesize;
; 535  : 
; 536  : 				transfer[i].currentfile =

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00106	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00109	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _fopen
  00112	83 c4 08	 add	 esp, 8
  00115	6b 55 e8 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00119	89 82 08 00 00
	00		 mov	 DWORD PTR _transfer[edx+8], eax

; 537  : 					fopen(f->filename, "rb");
; 538  : 
; 539  : 				if (!transfer[i].currentfile)

  0011f	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00123	83 b8 08 00 00
	00 00		 cmp	 DWORD PTR _transfer[eax+8], 0
  0012a	75 14		 jne	 SHORT $LN13@FiletxTick

; 540  : 					I_Error("File %s does not exist",

  0012c	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  0012f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00132	51		 push	 ecx
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NDPNNCIO@File?5?$CFs?5does?5not?5exist@
  00138	e8 00 00 00 00	 call	 _I_Error
  0013d	83 c4 08	 add	 esp, 8
$LN13@FiletxTick:

; 541  : 						f->filename);
; 542  : 
; 543  : 				fseek(transfer[i].currentfile, 0, SEEK_END);

  00140	6a 02		 push	 2
  00142	6a 00		 push	 0
  00144	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00148	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+8]
  0014e	51		 push	 ecx
  0014f	e8 00 00 00 00	 call	 _fseek
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH

; 544  : 				filesize = ftell(transfer[i].currentfile);

  00157	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0015b	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+8]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _ftell
  00167	83 c4 04	 add	 esp, 4
  0016a	89 45 e4	 mov	 DWORD PTR _filesize$1[ebp], eax

; 545  : 
; 546  : 				// Nobody wants to transfer a file bigger
; 547  : 				// than 4GB!
; 548  : 				if (filesize >= LONG_MAX)

  0016d	81 7d e4 ff ff
	ff 7f		 cmp	 DWORD PTR _filesize$1[ebp], 2147483647 ; 7fffffffH
  00174	7c 14		 jl	 SHORT $LN14@FiletxTick

; 549  : 					I_Error("filesize of %s is too large", f->filename);

  00176	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00179	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0017c	51		 push	 ecx
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OICNIHOA@filesize?5of?5?$CFs?5is?5too?5large@
  00182	e8 00 00 00 00	 call	 _I_Error
  00187	83 c4 08	 add	 esp, 8
$LN14@FiletxTick:

; 550  : 				if (-1 == filesize)

  0018a	83 7d e4 ff	 cmp	 DWORD PTR _filesize$1[ebp], -1
  0018e	75 14		 jne	 SHORT $LN15@FiletxTick

; 551  : 					I_Error("Error getting filesize of %s", f->filename);

  00190	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00193	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00196	51		 push	 ecx
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DENMFBMH@Error?5getting?5filesize?5of?5?$CFs@
  0019c	e8 00 00 00 00	 call	 _I_Error
  001a1	83 c4 08	 add	 esp, 8
$LN15@FiletxTick:

; 552  : 
; 553  : 				f->size = (UINT32)filesize;

  001a4	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  001a7	8b 4d e4	 mov	 ecx, DWORD PTR _filesize$1[ebp]
  001aa	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 554  : 				fseek(transfer[i].currentfile, 0, SEEK_SET);

  001ad	6a 00		 push	 0
  001af	6a 00		 push	 0
  001b1	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  001b5	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+8]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 _fseek
  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 			}

  001c4	eb 0e		 jmp	 SHORT $LN12@FiletxTick
$LN11@FiletxTick:

; 556  : 			else
; 557  : 				transfer[i].currentfile = (FILE *)1;

  001c6	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  001ca	c7 80 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR _transfer[eax+8], 1
$LN12@FiletxTick:

; 558  : 			transfer[i].position = 0;

  001d4	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  001d8	c7 80 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _transfer[eax+4], 0
$LN10@FiletxTick:

; 559  : 		}
; 560  : 
; 561  : 		p = &netbuffer->u.filetxpak;

  001e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  001e7	83 c0 08	 add	 eax, 8
  001ea	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 562  : 		size = software_MAXPACKETLENGTH - (FILETXHEADER + BASEPACKETSIZE);

  001ed	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _software_MAXPACKETLENGTH
  001f4	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  001f9	83 c1 08	 add	 ecx, 8
  001fc	2b c1		 sub	 eax, ecx
  001fe	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 563  : 		if (f->size-transfer[i].position < size)

  00201	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00205	8b 4d f4	 mov	 ecx, DWORD PTR _f$[ebp]
  00208	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0020b	2b 90 04 00 00
	00		 sub	 edx, DWORD PTR _transfer[eax+4]
  00211	3b 55 f8	 cmp	 edx, DWORD PTR _size$[ebp]
  00214	73 13		 jae	 SHORT $LN16@FiletxTick

; 564  : 			size = f->size-transfer[i].position;

  00216	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0021a	8b 4d f4	 mov	 ecx, DWORD PTR _f$[ebp]
  0021d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00220	2b 90 04 00 00
	00		 sub	 edx, DWORD PTR _transfer[eax+4]
  00226	89 55 f8	 mov	 DWORD PTR _size$[ebp], edx
$LN16@FiletxTick:

; 565  : 		if (ram)

  00229	83 7d ec 00	 cmp	 DWORD PTR _ram$[ebp], 0
  0022d	74 27		 je	 SHORT $LN17@FiletxTick

; 566  : 			M_Memcpy(p->data, &f->filename[transfer[i].position], size);

  0022f	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
  00232	50		 push	 eax
  00233	6b 4d e8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  00237	8b 55 f4	 mov	 edx, DWORD PTR _f$[ebp]
  0023a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0023d	03 81 04 00 00
	00		 add	 eax, DWORD PTR _transfer[ecx+4]
  00243	50		 push	 eax
  00244	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00247	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0024a	51		 push	 ecx
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH
  00254	eb 65		 jmp	 SHORT $LN19@FiletxTick
$LN17@FiletxTick:

; 567  : 		else if (fread(p->data, 1, size, transfer[i].currentfile) != size)

  00256	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0025a	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+8]
  00260	51		 push	 ecx
  00261	8b 55 f8	 mov	 edx, DWORD PTR _size$[ebp]
  00264	52		 push	 edx
  00265	6a 01		 push	 1
  00267	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0026a	83 c0 0a	 add	 eax, 10			; 0000000aH
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 _fread
  00273	83 c4 10	 add	 esp, 16			; 00000010H
  00276	3b 45 f8	 cmp	 eax, DWORD PTR _size$[ebp]
  00279	74 40		 je	 SHORT $LN19@FiletxTick

; 568  : 			I_Error("FiletxTicker: can't read %"PRIdS" byte on %s at %d because %s", size,f->filename,transfer[i].position, strerror(ferror(transfer[i].currentfile)));

  0027b	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0027f	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+8]
  00285	51		 push	 ecx
  00286	e8 00 00 00 00	 call	 _ferror
  0028b	83 c4 04	 add	 esp, 4
  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 _strerror
  00294	83 c4 04	 add	 esp, 4
  00297	50		 push	 eax
  00298	6b 55 e8 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  0029c	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _transfer[edx+4]
  002a2	50		 push	 eax
  002a3	8b 4d f4	 mov	 ecx, DWORD PTR _f$[ebp]
  002a6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002a9	52		 push	 edx
  002aa	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
  002ad	50		 push	 eax
  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@MJPBHDKL@FiletxTicker?3?5can?8t?5read?5?$CFIu?5by@
  002b3	e8 00 00 00 00	 call	 _I_Error
  002b8	83 c4 14	 add	 esp, 20			; 00000014H
$LN19@FiletxTick:

; 569  : 		p->position = LONG(transfer[i].position);

  002bb	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  002bf	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  002c2	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR _transfer[eax+4]
  002c8	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 570  : 		// put flag so receiver know the totalsize
; 571  : 		if (transfer[i].position + size == f->size)

  002cb	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  002cf	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+4]
  002d5	03 4d f8	 add	 ecx, DWORD PTR _size$[ebp]
  002d8	8b 55 f4	 mov	 edx, DWORD PTR _f$[ebp]
  002db	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  002de	75 12		 jne	 SHORT $LN20@FiletxTick

; 572  : 			p->position |= LONG(0x80000000);

  002e0	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  002e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002e6	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  002ec	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  002ef	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN20@FiletxTick:

; 573  : 		p->fileid = f->fileid;

  002f2	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  002f5	8b 4d f4	 mov	 ecx, DWORD PTR _f$[ebp]
  002f8	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  002fb	88 10		 mov	 BYTE PTR [eax], dl

; 574  : 		p->size = SHORT((UINT16)size);

  002fd	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00300	66 8b 4d f8	 mov	 cx, WORD PTR _size$[ebp]
  00304	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 575  : 		netbuffer->packettype = PT_FILEFRAGMENT;

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0030d	c6 40 06 11	 mov	 BYTE PTR [eax+6], 17	; 00000011H

; 576  : 		if (!HSendPacket(i, true, 0, FILETXHEADER + size)) // reliable SEND

  00311	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00316	03 45 f8	 add	 eax, DWORD PTR _size$[ebp]
  00319	50		 push	 eax
  0031a	6a 00		 push	 0
  0031c	6a 01		 push	 1
  0031e	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  00321	51		 push	 ecx
  00322	e8 00 00 00 00	 call	 _HSendPacket
  00327	83 c4 10	 add	 esp, 16			; 00000010H
  0032a	85 c0		 test	 eax, eax
  0032c	75 2a		 jne	 SHORT $LN21@FiletxTick

; 577  : 		{ // not sent for some odd reason, retry at next call
; 578  : 			if (!ram)

  0032e	83 7d ec 00	 cmp	 DWORD PTR _ram$[ebp], 0
  00332	75 20		 jne	 SHORT $LN23@FiletxTick

; 579  : 				fseek(transfer[i].currentfile,transfer[i].position,SEEK_SET);

  00334	6a 00		 push	 0
  00336	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0033a	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _transfer[eax+4]
  00340	51		 push	 ecx
  00341	6b 55 e8 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00345	8b 82 08 00 00
	00		 mov	 eax, DWORD PTR _transfer[edx+8]
  0034b	50		 push	 eax
  0034c	e8 00 00 00 00	 call	 _fseek
  00351	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@FiletxTick:

; 580  : 			// exit the while (can't send this one so why should i send the next?)
; 581  : 			break;

  00354	eb 3c		 jmp	 SHORT $LN3@FiletxTick

; 582  : 		}

  00356	eb 35		 jmp	 SHORT $LN24@FiletxTick
$LN21@FiletxTick:

; 583  : 		else // success
; 584  : 		{
; 585  : 			transfer[i].position = (UINT32)(size+transfer[i].position);

  00358	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0035c	8b 4d f8	 mov	 ecx, DWORD PTR _size$[ebp]
  0035f	03 88 04 00 00
	00		 add	 ecx, DWORD PTR _transfer[eax+4]
  00365	6b 55 e8 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00369	89 8a 04 00 00
	00		 mov	 DWORD PTR _transfer[edx+4], ecx

; 586  : 			if (transfer[i].position == f->size) //  finish ?

  0036f	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00373	8b 4d f4	 mov	 ecx, DWORD PTR _f$[ebp]
  00376	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR _transfer[eax+4]
  0037c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0037f	75 0c		 jne	 SHORT $LN24@FiletxTick

; 587  : 				EndSend(i);

  00381	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 _EndSend
  0038a	83 c4 04	 add	 esp, 4
$LN24@FiletxTick:

; 588  : 		}
; 589  : 	}

  0038d	e9 a9 fc ff ff	 jmp	 $LN8@FiletxTick
$LN3@FiletxTick:

; 590  : }

  00392	5f		 pop	 edi
  00393	5e		 pop	 esi
  00394	5b		 pop	 ebx
  00395	8b e5		 mov	 esp, ebp
  00397	5d		 pop	 ebp
  00398	c3		 ret	 0
_FiletxTicker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _SendRam
_TEXT	SEGMENT
_p$ = -8						; size = 4
_q$ = -4						; size = 4
_node$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
_freemethod$ = 20					; size = 4
_fileid$ = 24						; size = 1
_SendRam PROC						; COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 454  : 	filetx_t **q;
; 455  : 	filetx_t *p;
; 456  : 
; 457  : 	q = &transfer[node].txlist;

  00009	6b 45 08 0c	 imul	 eax, DWORD PTR _node$[ebp], 12
  0000d	05 00 00 00 00	 add	 eax, OFFSET _transfer
  00012	89 45 fc	 mov	 DWORD PTR _q$[ebp], eax
$LN2@SendRam:

; 458  : 	while (*q)

  00015	8b 45 fc	 mov	 eax, DWORD PTR _q$[ebp]
  00018	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001b	74 0d		 je	 SHORT $LN3@SendRam

; 459  : 		q = &((*q)->next);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _q$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	83 c1 14	 add	 ecx, 20			; 00000014H
  00025	89 4d fc	 mov	 DWORD PTR _q$[ebp], ecx
  00028	eb eb		 jmp	 SHORT $LN2@SendRam
$LN3@SendRam:

; 460  : 	p = *q = (filetx_t *)malloc(sizeof (filetx_t));

  0002a	6a 18		 push	 24			; 00000018H
  0002c	e8 00 00 00 00	 call	 _malloc
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  00037	89 01		 mov	 DWORD PTR [ecx], eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR _q$[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 461  : 	if (p)

  00041	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00045	74 12		 je	 SHORT $LN4@SendRam

; 462  : 		memset(p, 0, sizeof (filetx_t));

  00047	6a 18		 push	 24			; 00000018H
  00049	6a 00		 push	 0
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _memset
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	eb 0d		 jmp	 SHORT $LN5@SendRam
$LN4@SendRam:

; 463  : 	else
; 464  : 		I_Error("SendRam: No more ram\n");

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NCLGLKKP@SendRam?3?5No?5more?5ram?6@
  0005e	e8 00 00 00 00	 call	 _I_Error
  00063	83 c4 04	 add	 esp, 4
$LN5@SendRam:

; 465  : 	p->ram = freemethod;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00069	8b 4d 14	 mov	 ecx, DWORD PTR _freemethod$[ebp]
  0006c	89 08		 mov	 DWORD PTR [eax], ecx

; 466  : 	p->filename = data;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00074	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 	p->size = (UINT32)size;

  00077	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 468  : 	p->fileid = fileid;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00083	8a 4d 18	 mov	 cl, BYTE PTR _fileid$[ebp]
  00086	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 469  : 	p->next = NULL; // end of list

  00089	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0008c	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 470  : 
; 471  : 	DEBFILE(va("Sending ram %p(size:%u) to %d (id=%u)\n",p->filename,p->size,node,fileid));

  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0009a	74 41		 je	 SHORT $LN6@SendRam
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000a1	50		 push	 eax
  000a2	0f b6 4d 18	 movzx	 ecx, BYTE PTR _fileid$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  000aa	52		 push	 edx
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000ae	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b1	51		 push	 ecx
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000b5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b8	50		 push	 eax
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@ELOMIMPL@Sending?5ram?5?$CFp?$CIsize?3?$CFu?$CJ?5to?5?$CFd?5?$CI@
  000be	e8 00 00 00 00	 call	 _va
  000c3	83 c4 14	 add	 esp, 20			; 00000014H
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _fputs
  000cc	83 c4 08	 add	 esp, 8
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _fflush
  000da	83 c4 04	 add	 esp, 4
$LN6@SendRam:

; 472  : 
; 473  : 	filetosend++;

  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _filetosend
  000e2	83 c0 01	 add	 eax, 1
  000e5	a3 00 00 00 00	 mov	 DWORD PTR _filetosend, eax

; 474  : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_SendRam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _CL_LoadServerFiles
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_LoadServerFiles PROC				; COMDAT

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 340  : 	INT32 i;
; 341  : 
; 342  : 	if (M_CheckParm("-nofiles"))

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_08KDKGJCBO@?9nofiles@
  0000e	e8 00 00 00 00	 call	 _M_CheckParm
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	74 05		 je	 SHORT $LN5@CL_LoadSer

; 343  : 		return;

  0001a	e9 a7 01 00 00	 jmp	 $LN3@CL_LoadSer
$LN5@CL_LoadSer:

; 344  : 
; 345  : 	for (i = 1; i < fileneedednum; i++)

  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00026	eb 09		 jmp	 SHORT $LN4@CL_LoadSer
$LN2@CL_LoadSer:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CL_LoadSer:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00034	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  0003a	0f 8d 86 01 00
	00		 jge	 $LN3@CL_LoadSer

; 346  : 	{
; 347  : 		if (fileneeded[i].status == FS_OPEN)

  00040	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00047	83 b8 a0 00 00
	00 04		 cmp	 DWORD PTR _fileneeded[eax+160], 4
  0004e	75 07		 jne	 SHORT $LN6@CL_LoadSer

; 348  : 			continue; // already loaded

  00050	eb d6		 jmp	 SHORT $LN2@CL_LoadSer
  00052	e9 6a 01 00 00	 jmp	 $LN15@CL_LoadSer
$LN6@CL_LoadSer:

; 349  : 		else if (fileneeded[i].status == FS_FOUND)

  00057	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0005e	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR _fileneeded[eax+160], 1
  00065	75 37		 jne	 SHORT $LN8@CL_LoadSer

; 350  : 		{
; 351  : 			P_AddWadFile(fileneeded[i].filename, NULL);

  00067	6a 00		 push	 0
  00069	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00070	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _P_AddWadFile
  0007b	83 c4 08	 add	 esp, 8

; 352  : 			modifiedgame = true;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _modifiedgame, 1

; 353  : 			fileneeded[i].status = FS_OPEN;

  00088	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0008f	c7 80 a0 00 00
	00 04 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 4

; 354  : 		}

  00099	e9 23 01 00 00	 jmp	 $LN15@CL_LoadSer
$LN8@CL_LoadSer:

; 355  : 		else if (fileneeded[i].status == FS_MD5SUMBAD)

  0009e	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000a5	83 b8 a0 00 00
	00 05		 cmp	 DWORD PTR _fileneeded[eax+160], 5
  000ac	0f 85 d4 00 00
	00		 jne	 $LN10@CL_LoadSer

; 356  : 		{
; 357  : 			// If the file is marked important, don't even bother proceeding.
; 358  : 			if (fileneeded[i].important)

  000b2	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000b9	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax]
  000c0	85 c9		 test	 ecx, ecx
  000c2	74 1a		 je	 SHORT $LN12@CL_LoadSer

; 359  : 				I_Error("Wrong version of important file %s", fileneeded[i].filename);

  000c4	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000cb	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  000d0	50		 push	 eax
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DEBLFHAF@Wrong?5version?5of?5important?5file@
  000d6	e8 00 00 00 00	 call	 _I_Error
  000db	83 c4 08	 add	 esp, 8
$LN12@CL_LoadSer:

; 360  : 
; 361  : 			// If it isn't, no need to worry the user with a console message,
; 362  : 			// although it can't hurt to put something in the debug file.
; 363  : 
; 364  : 			// ...but wait a second. What if the local version is "important"?
; 365  : 			if (!W_VerifyNMUSlumps(fileneeded[i].filename))

  000de	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000e5	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 _W_VerifyNMUSlumps
  000f0	83 c4 04	 add	 esp, 4
  000f3	85 c0		 test	 eax, eax
  000f5	75 1a		 jne	 SHORT $LN13@CL_LoadSer

; 366  : 				I_Error("File %s should only contain music and sound effects!",

  000f7	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000fe	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  00103	50		 push	 eax
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BNNELPEK@File?5?$CFs?5should?5only?5contain?5mus@
  00109	e8 00 00 00 00	 call	 _I_Error
  0010e	83 c4 08	 add	 esp, 8
$LN13@CL_LoadSer:

; 367  : 					fileneeded[i].filename);
; 368  : 
; 369  : 			// Okay, NOW we know it's safe. Whew.
; 370  : 			P_AddWadFile(fileneeded[i].filename, NULL);

  00111	6a 00		 push	 0
  00113	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0011a	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _P_AddWadFile
  00125	83 c4 08	 add	 esp, 8

; 371  : 			modifiedgame = true;

  00128	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _modifiedgame, 1

; 372  : 			fileneeded[i].status = FS_OPEN;

  00132	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00139	c7 80 a0 00 00
	00 04 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 4

; 373  : 			DEBFILE(va("File %s found but with different md5sum\n", fileneeded[i].filename));

  00143	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0014a	74 38		 je	 SHORT $LN14@CL_LoadSer
  0014c	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00151	50		 push	 eax
  00152	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 164
  00159	81 c1 02 00 00
	00		 add	 ecx, OFFSET _fileneeded+2
  0015f	51		 push	 ecx
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KNJKMGLE@File?5?$CFs?5found?5but?5with?5differen@
  00165	e8 00 00 00 00	 call	 _va
  0016a	83 c4 08	 add	 esp, 8
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _fputs
  00173	83 c4 08	 add	 esp, 8
  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _fflush
  00181	83 c4 04	 add	 esp, 4
$LN14@CL_LoadSer:

; 374  : 		}

  00184	eb 3b		 jmp	 SHORT $LN15@CL_LoadSer
$LN10@CL_LoadSer:

; 375  : 		else if (fileneeded[i].important)

  00186	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0018d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax]
  00194	85 c9		 test	 ecx, ecx
  00196	74 29		 je	 SHORT $LN15@CL_LoadSer

; 376  : 			I_Error("Try to load file %s with status of %d\n", fileneeded[i].filename,

  00198	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0019f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+160]
  001a5	51		 push	 ecx
  001a6	69 55 fc a4 00
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 164
  001ad	81 c2 02 00 00
	00		 add	 edx, OFFSET _fileneeded+2
  001b3	52		 push	 edx
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JMJHKCBO@Try?5to?5load?5file?5?$CFs?5with?5status@
  001b9	e8 00 00 00 00	 call	 _I_Error
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@CL_LoadSer:

; 377  : 				fileneeded[i].status);
; 378  : 	}

  001c1	e9 62 fe ff ff	 jmp	 $LN2@CL_LoadSer
$LN3@CL_LoadSer:

; 379  : }

  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
_CL_LoadServerFiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _CL_CheckFiles
_TEXT	SEGMENT
_ret$ = -144						; size = 4
_wadfilename$ = -140					; size = 128
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_CheckFiles PROC					; COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 296  : 	INT32 i, j;
; 297  : 	char wadfilename[MAX_WADPATH];
; 298  : 	INT32 ret = 1;

  00016	c7 85 70 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _ret$[ebp], 1

; 299  : 
; 300  : 	if (M_CheckParm("-nofiles"))

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_08KDKGJCBO@?9nofiles@
  00025	e8 00 00 00 00	 call	 _M_CheckParm
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	74 0a		 je	 SHORT $LN8@CL_CheckFi

; 301  : 		return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	e9 b7 01 00 00	 jmp	 $LN1@CL_CheckFi
$LN8@CL_CheckFi:

; 302  : 
; 303  : 	// the first is the iwad (the main wad file)
; 304  : 	// we don't care if it's called srb2.srb or srb2.wad.
; 305  : 	fileneeded[0].status = FS_OPEN;

  0003b	b8 a4 00 00 00	 mov	 eax, 164		; 000000a4H
  00040	6b c8 00	 imul	 ecx, eax, 0
  00043	c7 81 a0 00 00
	00 04 00 00 00	 mov	 DWORD PTR _fileneeded[ecx+160], 4

; 306  : 
; 307  : 	for (i = 1; i < fileneedednum; i++)

  0004d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00054	eb 09		 jmp	 SHORT $LN4@CL_CheckFi
$LN2@CL_CheckFi:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CL_CheckFi:
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00062	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  00068	0f 8d 7e 01 00
	00		 jge	 $LN3@CL_CheckFi

; 308  : 	{
; 309  : 		if (devparm)

  0006e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00075	74 1a		 je	 SHORT $LN9@CL_CheckFi

; 310  : 			CONS_Printf("searching for '%s' ", fileneeded[i].filename);

  00077	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0007e	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FAMPCCLJ@searching?5for?5?8?$CFs?8?5@
  00089	e8 00 00 00 00	 call	 _CONS_Printf
  0008e	83 c4 08	 add	 esp, 8
$LN9@CL_CheckFi:

; 311  : 
; 312  : 		// check in allready loaded files
; 313  : 		for (j = 1; wadfiles[j]; j++)

  00091	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  00098	eb 09		 jmp	 SHORT $LN7@CL_CheckFi
$LN5@CL_CheckFi:
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0009d	83 c0 01	 add	 eax, 1
  000a0	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN7@CL_CheckFi:
  000a3	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000a6	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _wadfiles[eax*4], 0
  000ae	0f 84 9c 00 00
	00		 je	 $LN6@CL_CheckFi

; 314  : 		{
; 315  : 			nameonly(strcpy(wadfilename, wadfiles[j]->filename));

  000b4	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000b7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  000be	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c0	52		 push	 edx
  000c1	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _strcpy
  000cd	83 c4 08	 add	 esp, 8
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _nameonly
  000d6	83 c4 04	 add	 esp, 4

; 316  : 			if (!stricmp(wadfilename, fileneeded[i].filename) &&

  000d9	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000e0	05 02 00 00 00	 add	 eax, OFFSET _fileneeded+2
  000e5	50		 push	 eax
  000e6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _wadfilename$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 _stricmp
  000f2	83 c4 08	 add	 esp, 8
  000f5	85 c0		 test	 eax, eax
  000f7	75 52		 jne	 SHORT $LN10@CL_CheckFi
  000f9	6a 10		 push	 16			; 00000010H
  000fb	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00102	05 82 00 00 00	 add	 eax, OFFSET _fileneeded+130
  00107	50		 push	 eax
  00108	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0010b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _wadfiles[ecx*4]
  00112	83 c2 1c	 add	 edx, 28			; 0000001cH
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 _memcmp
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	85 c0		 test	 eax, eax
  00120	75 29		 jne	 SHORT $LN10@CL_CheckFi

; 317  : 				!memcmp(wadfiles[j]->md5sum, fileneeded[i].md5sum, 16))
; 318  : 			{
; 319  : 				if (devparm)

  00122	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00129	74 0d		 je	 SHORT $LN11@CL_CheckFi

; 320  : 					CONS_Printf("already loaded\n");

  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KMEFLLPP@already?5loaded?6@
  00130	e8 00 00 00 00	 call	 _CONS_Printf
  00135	83 c4 04	 add	 esp, 4
$LN11@CL_CheckFi:

; 321  : 				fileneeded[i].status = FS_OPEN;

  00138	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0013f	c7 80 a0 00 00
	00 04 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 4

; 322  : 				break;

  00149	eb 05		 jmp	 SHORT $LN6@CL_CheckFi
$LN10@CL_CheckFi:

; 323  : 			}
; 324  : 		}

  0014b	e9 4a ff ff ff	 jmp	 $LN5@CL_CheckFi
$LN6@CL_CheckFi:

; 325  : 		if (fileneeded[i].status != FS_NOTFOUND || !fileneeded[i].important)

  00150	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00157	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR _fileneeded[eax+160], 0
  0015e	75 12		 jne	 SHORT $LN13@CL_CheckFi
  00160	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00167	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _fileneeded[eax]
  0016e	85 c9		 test	 ecx, ecx
  00170	75 05		 jne	 SHORT $LN12@CL_CheckFi
$LN13@CL_CheckFi:

; 326  : 			continue;

  00172	e9 df fe ff ff	 jmp	 $LN2@CL_CheckFi
$LN12@CL_CheckFi:

; 327  : 
; 328  : 		fileneeded[i].status = findfile(fileneeded[i].filename, fileneeded[i].md5sum, true);

  00177	6a 01		 push	 1
  00179	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00180	05 82 00 00 00	 add	 eax, OFFSET _fileneeded+130
  00185	50		 push	 eax
  00186	69 4d f8 a4 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 164
  0018d	81 c1 02 00 00
	00		 add	 ecx, OFFSET _fileneeded+2
  00193	51		 push	 ecx
  00194	e8 00 00 00 00	 call	 _findfile
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019c	69 55 f8 a4 00
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 164
  001a3	89 82 a0 00 00
	00		 mov	 DWORD PTR _fileneeded[edx+160], eax

; 329  : 		if (devparm)

  001a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  001b0	74 1b		 je	 SHORT $LN14@CL_CheckFi

; 330  : 			CONS_Printf("found %d\n", fileneeded[i].status);

  001b2	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  001b9	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR _fileneeded[eax+160]
  001bf	51		 push	 ecx
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_09MBGLDLF@found?5?$CFd?6@
  001c5	e8 00 00 00 00	 call	 _CONS_Printf
  001ca	83 c4 08	 add	 esp, 8
$LN14@CL_CheckFi:

; 331  : 		if (fileneeded[i].status != FS_FOUND)

  001cd	69 45 f8 a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  001d4	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR _fileneeded[eax+160], 1
  001db	74 0a		 je	 SHORT $LN15@CL_CheckFi

; 332  : 			ret = 0;

  001dd	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ret$[ebp], 0
$LN15@CL_CheckFi:

; 333  : 	}

  001e7	e9 6a fe ff ff	 jmp	 $LN2@CL_CheckFi
$LN3@CL_CheckFi:

; 334  : 	return ret;

  001ec	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@CL_CheckFi:

; 335  : }

  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
  001f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f8	33 cd		 xor	 ecx, ebp
  001fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
_CL_CheckFiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _CL_PrepareDownloadSaveGame
_TEXT	SEGMENT
_tmpsave$ = 8						; size = 4
_CL_PrepareDownloadSaveGame PROC			; COMDAT

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 172  : 	fileneedednum = 1;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _fileneedednum, 1

; 173  : 	fileneeded[0].status = FS_REQUESTED;

  00013	b8 a4 00 00 00	 mov	 eax, 164		; 000000a4H
  00018	6b c8 00	 imul	 ecx, eax, 0
  0001b	c7 81 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR _fileneeded[ecx+160], 2

; 174  : 	fileneeded[0].totalsize = UINT32_MAX;

  00025	b8 a4 00 00 00	 mov	 eax, 164		; 000000a4H
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	c7 81 9c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _fileneeded[ecx+156], -1

; 175  : 	fileneeded[0].phandle = NULL;

  00037	b8 a4 00 00 00	 mov	 eax, 164		; 000000a4H
  0003c	6b c8 00	 imul	 ecx, eax, 0
  0003f	c7 81 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR _fileneeded[ecx+148], 0

; 176  : 	memset(fileneeded[0].md5sum, 0, 16);

  00049	6a 10		 push	 16			; 00000010H
  0004b	6a 00		 push	 0
  0004d	b8 a4 00 00 00	 mov	 eax, 164		; 000000a4H
  00052	6b c8 00	 imul	 ecx, eax, 0
  00055	81 c1 82 00 00
	00		 add	 ecx, OFFSET _fileneeded+130
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _memset
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 	strcpy(fileneeded[0].filename, tmpsave);

  00064	8b 45 08	 mov	 eax, DWORD PTR _tmpsave$[ebp]
  00067	50		 push	 eax
  00068	b9 a4 00 00 00	 mov	 ecx, 164		; 000000a4H
  0006d	6b d1 00	 imul	 edx, ecx, 0
  00070	81 c2 02 00 00
	00		 add	 edx, OFFSET _fileneeded+2
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _strcpy
  0007c	83 c4 08	 add	 esp, 8

; 178  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_CL_PrepareDownloadSaveGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _D_ParseFileneeded
_TEXT	SEGMENT
tv136 = -84						; size = 4
_tmp_i$1 = -16						; size = 4
_filestatus$ = -9					; size = 1
_p$ = -8						; size = 4
_i$ = -4						; size = 4
_fileneedednum_parm$ = 8				; size = 4
_fileneededstr$ = 12					; size = 4
_D_ParseFileneeded PROC					; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 151  : 	INT32 i;
; 152  : 	UINT8 *p;
; 153  : 	UINT8 filestatus;
; 154  : 
; 155  : 	fileneedednum = fileneedednum_parm;

  00009	8b 45 08	 mov	 eax, DWORD PTR _fileneedednum_parm$[ebp]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR _fileneedednum, eax

; 156  : 	p = (UINT8 *)fileneededstr;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _fileneededstr$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 157  : 	for (i = 0; i < fileneedednum; i++)

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@D_ParseFil
$LN2@D_ParseFil:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@D_ParseFil:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _fileneedednum
  00032	0f 8d 09 01 00
	00		 jge	 $LN3@D_ParseFil

; 158  : 	{
; 159  : 		fileneeded[i].status = FS_NOTFOUND;

  00038	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0003f	c7 80 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR _fileneeded[eax+160], 0

; 160  : 		filestatus = READUINT8(p);

  00049	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0004c	8a 08		 mov	 cl, BYTE PTR [eax]
  0004e	88 4d f7	 mov	 BYTE PTR _filestatus$[ebp], cl
  00051	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  00054	83 c2 01	 add	 edx, 1
  00057	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx

; 161  : 		fileneeded[i].important = (UINT8)(filestatus & 3);

  0005a	0f b6 45 f7	 movzx	 eax, BYTE PTR _filestatus$[ebp]
  0005e	83 e0 03	 and	 eax, 3
  00061	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 164
  00068	88 81 00 00 00
	00		 mov	 BYTE PTR _fileneeded[ecx], al

; 162  : 		fileneeded[i].willsend = (UINT8)(filestatus >> 4);

  0006e	0f b6 45 f7	 movzx	 eax, BYTE PTR _filestatus$[ebp]
  00072	c1 f8 04	 sar	 eax, 4
  00075	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 164
  0007c	88 81 01 00 00
	00		 mov	 BYTE PTR _fileneeded[ecx+1], al

; 163  : 		fileneeded[i].totalsize = READUINT32(p);

  00082	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  0008c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008e	89 90 9c 00 00
	00		 mov	 DWORD PTR _fileneeded[eax+156], edx
  00094	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00097	83 c0 04	 add	 eax, 4
  0009a	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 164  : 		fileneeded[i].phandle = NULL;

  0009d	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000a4	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR _fileneeded[eax+148], 0

; 165  : 		READSTRINGN(p, fileneeded[i].filename, MAX_WADPATH);

  000ae	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _tmp_i$1[ebp], 0
  000b5	eb 09		 jmp	 SHORT $LN7@D_ParseFil
$LN5@D_ParseFil:
  000b7	8b 45 f0	 mov	 eax, DWORD PTR _tmp_i$1[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 f0	 mov	 DWORD PTR _tmp_i$1[ebp], eax
$LN7@D_ParseFil:
  000c0	81 7d f0 80 00
	00 00		 cmp	 DWORD PTR _tmp_i$1[ebp], 128 ; 00000080H
  000c7	73 3c		 jae	 SHORT $LN6@D_ParseFil
  000c9	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000d0	8b 4d f0	 mov	 ecx, DWORD PTR _tmp_i$1[ebp]
  000d3	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000d6	8a 12		 mov	 dl, BYTE PTR [edx]
  000d8	88 94 08 02 00
	00 00		 mov	 BYTE PTR _fileneeded[eax+ecx+2], dl
  000df	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _tmp_i$1[ebp]
  000e9	0f be 94 08 02
	00 00 00	 movsx	 edx, BYTE PTR _fileneeded[eax+ecx+2]
  000f1	89 55 ac	 mov	 DWORD PTR tv136[ebp], edx
  000f4	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000f7	83 c0 01	 add	 eax, 1
  000fa	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
  000fd	83 7d ac 00	 cmp	 DWORD PTR tv136[ebp], 0
  00101	74 02		 je	 SHORT $LN6@D_ParseFil
  00103	eb b2		 jmp	 SHORT $LN5@D_ParseFil
$LN6@D_ParseFil:
  00105	69 45 fc a4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 164
  0010c	8b 4d f0	 mov	 ecx, DWORD PTR _tmp_i$1[ebp]
  0010f	c6 84 08 02 00
	00 00 00	 mov	 BYTE PTR _fileneeded[eax+ecx+2], 0

; 166  : 		READMEM(p, fileneeded[i].md5sum, 16);

  00117	6a 10		 push	 16			; 00000010H
  00119	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0011c	50		 push	 eax
  0011d	69 4d fc a4 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 164
  00124	81 c1 82 00 00
	00		 add	 ecx, OFFSET _fileneeded+130
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00136	83 c0 10	 add	 eax, 16			; 00000010H
  00139	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 167  : 	}

  0013c	e9 df fe ff ff	 jmp	 $LN2@D_ParseFil
$LN3@D_ParseFil:

; 168  : }

  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
_D_ParseFileneeded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_netfil.c
;	COMDAT _PutFileNeeded
_TEXT	SEGMENT
_p_tmp$1 = -172						; size = 4
_p_tmp$2 = -168						; size = 4
_tmp_i$3 = -164						; size = 4
_p_tmp$4 = -160						; size = 4
_p_tmp$5 = -156						; size = 4
_bytesused$ = -152					; size = 4
_filestatus$ = -145					; size = 1
_wadfilename$ = -144					; size = 128
_p$ = -16						; size = 4
_count$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_PutFileNeeded PROC					; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 107  : 	size_t i, count = 0;

  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 108  : 	UINT8 *p = netbuffer->u.serverinfo.fileneeded;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00022	83 c0 75	 add	 eax, 117		; 00000075H
  00025	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 109  : 	char wadfilename[MAX_WADPATH] = "";

  00028	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0002d	88 85 70 ff ff
	ff		 mov	 BYTE PTR _wadfilename$[ebp], al
  00033	6a 7f		 push	 127			; 0000007fH
  00035	6a 00		 push	 0
  00037	8d 85 71 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp+1]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _memset
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 	UINT8 filestatus;
; 111  : 	size_t bytesused = 0;

  00046	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bytesused$[ebp], 0

; 112  : 
; 113  : 	for (i = 0; i < numwadfiles; i++)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@PutFileNee
$LN2@PutFileNee:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@PutFileNee:
  00062	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  00069	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0006c	0f 83 28 02 00
	00		 jae	 $LN3@PutFileNee

; 114  : 	{
; 115  : 		// if it has only music/sound lumps, mark it as unimportant
; 116  : 		if (W_VerifyNMUSlumps(wadfiles[i]->filename))

  00072	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00075	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _W_VerifyNMUSlumps
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	74 09		 je	 SHORT $LN20@PutFileNee

; 117  : 			filestatus = 0;

  0008b	c6 85 6f ff ff
	ff 00		 mov	 BYTE PTR _filestatus$[ebp], 0
  00092	eb 07		 jmp	 SHORT $LN21@PutFileNee
$LN20@PutFileNee:

; 118  : 		else
; 119  : 			filestatus = 1; // important

  00094	c6 85 6f ff ff
	ff 01		 mov	 BYTE PTR _filestatus$[ebp], 1
$LN21@PutFileNee:

; 120  : 
; 121  : 		// Store in the upper four bits
; 122  : 		if (!cv_downloading.value)

  0009b	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_downloading+20, 0
  000a2	75 12		 jne	 SHORT $LN22@PutFileNee

; 123  : 			filestatus += (2 << 4); // won't send

  000a4	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _filestatus$[ebp]
  000ab	83 c0 20	 add	 eax, 32			; 00000020H
  000ae	88 85 6f ff ff
	ff		 mov	 BYTE PTR _filestatus$[ebp], al
  000b4	eb 36		 jmp	 SHORT $LN25@PutFileNee
$LN22@PutFileNee:

; 124  : 		else if ((wadfiles[i]->filesize > (UINT32)cv_maxsend.value * 1024))

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b9	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  000c0	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _cv_maxsend+20
  000c6	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  000c9	39 51 18	 cmp	 DWORD PTR [ecx+24], edx
  000cc	76 0e		 jbe	 SHORT $LN24@PutFileNee

; 125  : 			filestatus += (0 << 4); // won't send

  000ce	8a 85 6f ff ff
	ff		 mov	 al, BYTE PTR _filestatus$[ebp]
  000d4	88 85 6f ff ff
	ff		 mov	 BYTE PTR _filestatus$[ebp], al
  000da	eb 10		 jmp	 SHORT $LN25@PutFileNee
$LN24@PutFileNee:

; 126  : 		else
; 127  : 			filestatus += (1 << 4); // will send if requested

  000dc	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _filestatus$[ebp]
  000e3	83 c0 10	 add	 eax, 16			; 00000010H
  000e6	88 85 6f ff ff
	ff		 mov	 BYTE PTR _filestatus$[ebp], al
$LN25@PutFileNee:

; 128  : 
; 129  : 		bytesused += (nameonlylength(wadfilename) + 22);

  000ec	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _nameonlylength
  000f8	83 c4 04	 add	 esp, 4
  000fb	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _bytesused$[ebp]
  00101	8d 54 01 16	 lea	 edx, DWORD PTR [ecx+eax+22]
  00105	89 95 68 ff ff
	ff		 mov	 DWORD PTR _bytesused$[ebp], edx

; 130  : 
; 131  : 		// Don't write too far...
; 132  : 		if (bytesused > sizeof(netbuffer->u.serverinfo.fileneeded))

  0010b	81 bd 68 ff ff
	ff 93 03 00 00	 cmp	 DWORD PTR _bytesused$[ebp], 915 ; 00000393H
  00115	76 1b		 jbe	 SHORT $LN26@PutFileNee

; 133  : 			I_Error("Too many wad files added to host a game. (%"PRIdS", stopped on %s)\n", bytesused, wadfilename);

  00117	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp]
  0011d	50		 push	 eax
  0011e	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _bytesused$[ebp]
  00124	51		 push	 ecx
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@GIFIEBLC@Too?5many?5wad?5files?5added?5to?5hos@
  0012a	e8 00 00 00 00	 call	 _I_Error
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@PutFileNee:

; 134  : 
; 135  : 		WRITEUINT8(p, filestatus);

  00132	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00135	89 85 64 ff ff
	ff		 mov	 DWORD PTR _p_tmp$5[ebp], eax
  0013b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  00141	8a 8d 6f ff ff
	ff		 mov	 cl, BYTE PTR _filestatus$[ebp]
  00147	88 08		 mov	 BYTE PTR [eax], cl
  00149	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  0014f	83 c0 01	 add	 eax, 1
  00152	89 85 64 ff ff
	ff		 mov	 DWORD PTR _p_tmp$5[ebp], eax
  00158	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  0015e	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
  00161	33 c0		 xor	 eax, eax
  00163	75 cd		 jne	 SHORT $LN26@PutFileNee

; 136  : 
; 137  : 		count++;

  00165	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  00168	83 c0 01	 add	 eax, 1
  0016b	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax
$LN10@PutFileNee:

; 138  : 		WRITEUINT32(p, wadfiles[i]->filesize);

  0016e	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00171	89 85 60 ff ff
	ff		 mov	 DWORD PTR _p_tmp$4[ebp], eax
  00177	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0017a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00181	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _p_tmp$4[ebp]
  00187	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0018a	89 02		 mov	 DWORD PTR [edx], eax
  0018c	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  00192	83 c0 04	 add	 eax, 4
  00195	89 85 60 ff ff
	ff		 mov	 DWORD PTR _p_tmp$4[ebp], eax
  0019b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$4[ebp]
  001a1	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
  001a4	33 c0		 xor	 eax, eax
  001a6	75 c6		 jne	 SHORT $LN10@PutFileNee

; 139  : 		nameonly(strcpy(wadfilename, wadfiles[i]->filename));

  001a8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001ab	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  001b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b4	52		 push	 edx
  001b5	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _wadfilename$[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _strcpy
  001c1	83 c4 08	 add	 esp, 8
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _nameonly
  001ca	83 c4 04	 add	 esp, 4

; 140  : 		WRITESTRINGN(p, wadfilename, MAX_WADPATH);

  001cd	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmp_i$3[ebp], 0
  001d7	eb 0f		 jmp	 SHORT $LN13@PutFileNee
$LN11@PutFileNee:
  001d9	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$3[ebp]
  001df	83 c0 01	 add	 eax, 1
  001e2	89 85 5c ff ff
	ff		 mov	 DWORD PTR _tmp_i$3[ebp], eax
$LN13@PutFileNee:
  001e8	81 bd 5c ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR _tmp_i$3[ebp], 128 ; 00000080H
  001f2	73 4e		 jae	 SHORT $LN12@PutFileNee
  001f4	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$3[ebp]
  001fa	0f be 8c 05 70
	ff ff ff	 movsx	 ecx, BYTE PTR _wadfilename$[ebp+eax]
  00202	85 c9		 test	 ecx, ecx
  00204	74 3c		 je	 SHORT $LN12@PutFileNee
$LN16@PutFileNee:
  00206	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00209	89 85 58 ff ff
	ff		 mov	 DWORD PTR _p_tmp$2[ebp], eax
  0020f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00215	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _tmp_i$3[ebp]
  0021b	8a 94 0d 70 ff
	ff ff		 mov	 dl, BYTE PTR _wadfilename$[ebp+ecx]
  00222	88 10		 mov	 BYTE PTR [eax], dl
  00224	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  0022a	83 c0 01	 add	 eax, 1
  0022d	89 85 58 ff ff
	ff		 mov	 DWORD PTR _p_tmp$2[ebp], eax
  00233	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00239	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
  0023c	33 c0		 xor	 eax, eax
  0023e	75 c6		 jne	 SHORT $LN16@PutFileNee
  00240	eb 97		 jmp	 SHORT $LN11@PutFileNee
$LN12@PutFileNee:
  00242	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00245	89 85 54 ff ff
	ff		 mov	 DWORD PTR _p_tmp$1[ebp], eax
  0024b	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  00251	c6 00 00	 mov	 BYTE PTR [eax], 0
  00254	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  0025a	83 c0 01	 add	 eax, 1
  0025d	89 85 54 ff ff
	ff		 mov	 DWORD PTR _p_tmp$1[ebp], eax
  00263	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  00269	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
  0026c	33 c0		 xor	 eax, eax
  0026e	75 d2		 jne	 SHORT $LN12@PutFileNee

; 141  : 		WRITEMEM(p, wadfiles[i]->md5sum, 16);

  00270	6a 10		 push	 16			; 00000010H
  00272	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00275	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  0027c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0027f	51		 push	 ecx
  00280	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00283	52		 push	 edx
  00284	e8 00 00 00 00	 call	 _memcpy
  00289	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028c	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0028f	83 c0 10	 add	 eax, 16			; 00000010H
  00292	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 142  : 	}

  00295	e9 bf fd ff ff	 jmp	 $LN2@PutFileNee
$LN3@PutFileNee:

; 143  : 	netbuffer->u.serverinfo.fileneedednum = (UINT8)count;

  0029a	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0029f	8a 4d f4	 mov	 cl, BYTE PTR _count$[ebp]
  002a2	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 144  : 
; 145  : 	return p;

  002a5	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]

; 146  : }

  002a8	5f		 pop	 edi
  002a9	5e		 pop	 esi
  002aa	5b		 pop	 ebx
  002ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ae	33 cd		 xor	 ecx, ebp
  002b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
_PutFileNeeded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
