; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\hw_bsp.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_extrasubsectors
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_extrasubsectors DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_addsubsector:DWORD
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_HWR_CreatePlanePolygons
PUBLIC	_HWR_InitPolyPool
PUBLIC	_HWR_FreePolyPool
PUBLIC	_HWR_FreeExtraSubsectors
PUBLIC	??_C@_0CK@EHHKGIMC@SplitPoly?3?5invalid?5splitting?5li@ ; `string'
PUBLIC	??_C@_0BI@FILNJIGP@Adding?5a?5new?5subsector?6@	; `string'
PUBLIC	??_C@_0CH@FIKCMBHP@WalkBSPNode?3?5not?5enough?5addsubs@ ; `string'
PUBLIC	??_C@_0CE@IDGOAFGF@WalkBSPNode?3?5addsubsector?5?$DO?50x7@ ; `string'
PUBLIC	??_C@_04FCMNJMCO@?$CFd?$CF?$CF@			; `string'
PUBLIC	??_C@_08LPMGDBIJ@SRB2BACK@			; `string'
PUBLIC	??_C@_0L@JIENHOK@Loading?4?4?4@			; `string'
PUBLIC	??_C@_0BK@OJMJFMIN@OPENGL?5MODE?5IS?5INCOMPLETE@ ; `string'
PUBLIC	??_C@_0BD@NNGMDKFG@AND?5MAY?5CRASH?5YOUR@	; `string'
PUBLIC	??_C@_09KALLHCMF@COMPUTER?4@			; `string'
PUBLIC	??_C@_0BB@LECHLICB@USE?5AT?5OWN?5RISK?4@	; `string'
PUBLIC	??_C@_0BM@MKEKOOIO@WalkBSPNode?3?5no?5front?5poly?$DP@ ; `string'
PUBLIC	??_C@_0DI@CBOJMKBL@Solving?5T?9joins?4?5This?5may?5take?5@ ; `string'
PUBLIC	??_C@_0CD@CMLNCLEJ@Creating?5polygons?0?5please?5wait?4@ ; `string'
PUBLIC	??_C@_0DD@PCNOADGC@couldn?8t?5malloc?5extrasubsectors@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f100000
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40100000
PUBLIC	__real@47800000
PUBLIC	__real@551184e7
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_hypot:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_M_ClearBox:PROC
EXTRN	_M_AddToBox:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_CON_Drawer:PROC
EXTRN	_V_DrawString:PROC
EXTRN	_V_DrawCenteredString:PROC
EXTRN	_V_StringWidth:PROC
EXTRN	_V_DrawPatchFill:PROC
EXTRN	_M_DrawTextBox:PROC
EXTRN	_I_OsPolling:PROC
EXTRN	_I_FinishUpdate:PROC
EXTRN	_I_UpdateNoVsync:PROC
EXTRN	_W_CachePatchName:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_cv_debug:DWORD
EXTRN	_cv_grsolvetjoin:BYTE
EXTRN	_numvertexes:DWORD
EXTRN	_vertexes:DWORD
EXTRN	_segs:DWORD
EXTRN	_numsubsectors:DWORD
EXTRN	_subsectors:DWORD
EXTRN	_numnodes:DWORD
EXTRN	_nodes:DWORD
EXTRN	_sscount:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_totsubsectors DD 01H DUP (?)
_nobackpoly DD	01H DUP (?)
_skipcut DD	01H DUP (?)
_totalsubsecpolys DD 01H DUP (?)
_bspfrac DD	01H DUP (?)
?pt@?1??fracdivline@@9@9 DB 0cH DUP (?)			; `fracdivline'::`2'::pt
_ls_count DD	01H DUP (?)
_ls_percent DB	01H DUP (?)
	ALIGN	4

_numsplitpoly DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@551184e7
CONST	SEGMENT
__real@551184e7 DD 0551184e7r			; 1e+13
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@40100000
CONST	SEGMENT
__real@40100000 DD 040100000r			; 2.25
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f100000
CONST	SEGMENT
__real@3f100000 DD 03f100000r			; 0.5625
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0DD@PCNOADGC@couldn?8t?5malloc?5extrasubsectors@
CONST	SEGMENT
??_C@_0DD@PCNOADGC@couldn?8t?5malloc?5extrasubsectors@ DB 'couldn''t mall'
	DB	'oc extrasubsectors totsubsectors %Iu', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CMLNCLEJ@Creating?5polygons?0?5please?5wait?4@
CONST	SEGMENT
??_C@_0CD@CMLNCLEJ@Creating?5polygons?0?5please?5wait?4@ DB 'Creating pol'
	DB	'ygons, please wait...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CBOJMKBL@Solving?5T?9joins?4?5This?5may?5take?5@
CONST	SEGMENT
??_C@_0DI@CBOJMKBL@Solving?5T?9joins?4?5This?5may?5take?5@ DB 'Solving T-'
	DB	'joins. This may take a while. Please wait...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MKEKOOIO@WalkBSPNode?3?5no?5front?5poly?$DP@
CONST	SEGMENT
??_C@_0BM@MKEKOOIO@WalkBSPNode?3?5no?5front?5poly?$DP@ DB 'WalkBSPNode: n'
	DB	'o front poly?', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LECHLICB@USE?5AT?5OWN?5RISK?4@
CONST	SEGMENT
??_C@_0BB@LECHLICB@USE?5AT?5OWN?5RISK?4@ DB 'USE AT OWN RISK.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KALLHCMF@COMPUTER?4@
CONST	SEGMENT
??_C@_09KALLHCMF@COMPUTER?4@ DB 'COMPUTER.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNGMDKFG@AND?5MAY?5CRASH?5YOUR@
CONST	SEGMENT
??_C@_0BD@NNGMDKFG@AND?5MAY?5CRASH?5YOUR@ DB 'AND MAY CRASH YOUR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OJMJFMIN@OPENGL?5MODE?5IS?5INCOMPLETE@
CONST	SEGMENT
??_C@_0BK@OJMJFMIN@OPENGL?5MODE?5IS?5INCOMPLETE@ DB 'OPENGL MODE IS INCOM'
	DB	'PLETE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JIENHOK@Loading?4?4?4@
CONST	SEGMENT
??_C@_0L@JIENHOK@Loading?4?4?4@ DB 'Loading...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LPMGDBIJ@SRB2BACK@
CONST	SEGMENT
??_C@_08LPMGDBIJ@SRB2BACK@ DB 'SRB2BACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FCMNJMCO@?$CFd?$CF?$CF@
CONST	SEGMENT
??_C@_04FCMNJMCO@?$CFd?$CF?$CF@ DB '%d%%', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IDGOAFGF@WalkBSPNode?3?5addsubsector?5?$DO?50x7@
CONST	SEGMENT
??_C@_0CE@IDGOAFGF@WalkBSPNode?3?5addsubsector?5?$DO?50x7@ DB 'WalkBSPNod'
	DB	'e: addsubsector > 0x7fff', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FIKCMBHP@WalkBSPNode?3?5not?5enough?5addsubs@
CONST	SEGMENT
??_C@_0CH@FIKCMBHP@WalkBSPNode?3?5not?5enough?5addsubs@ DB 'WalkBSPNode: '
	DB	'not enough addsubsectors', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FILNJIGP@Adding?5a?5new?5subsector?6@
CONST	SEGMENT
??_C@_0BI@FILNJIGP@Adding?5a?5new?5subsector?6@ DB 'Adding a new subsecto'
	DB	'r', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EHHKGIMC@SplitPoly?3?5invalid?5splitting?5li@
CONST	SEGMENT
??_C@_0CK@EHHKGIMC@SplitPoly?3?5invalid?5splitting?5li@ DB 'SplitPoly: in'
	DB	'valid splitting line (%d %d)', 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0441H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03fbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0410H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	023bH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _AdjustSegs
_TEXT	SEGMENT
tv83 = -132						; size = 4
_y$1 = -64						; size = 4
_x$2 = -60						; size = 4
_pv$3 = -56						; size = 4
_pv$4 = -52						; size = 4
_tmp$5 = -48						; size = 4
_distv2$6 = -44						; size = 4
_distv1$7 = -40						; size = 4
_nearv2$ = -36						; size = 4
_nearv1$ = -32						; size = 4
_v2found$ = -28						; size = 4
_v1found$ = -24						; size = 4
_p$ = -20						; size = 4
_lseg$ = -16						; size = 4
_j$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_AdjustSegs PROC					; COMDAT

; 870  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 871  : 	size_t i, count;
; 872  : 	INT32 j;
; 873  : 	seg_t *lseg;
; 874  : 	poly_t *p;
; 875  : 	INT32 v1found = 0, v2found = 0;

  0000c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _v1found$[ebp], 0
  00013	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _v2found$[ebp], 0

; 876  : 	float nearv1, nearv2;
; 877  : 
; 878  : 	for (i = 0; i < numsubsectors; i++)

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@AdjustSegs
$LN2@AdjustSegs:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@AdjustSegs:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsubsectors
  00035	0f 83 01 03 00
	00		 jae	 $LN3@AdjustSegs

; 879  : 	{
; 880  : 		count = subsectors[i].numlines;

  0003b	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _subsectors
  00045	0f bf 54 01 04	 movsx	 edx, WORD PTR [ecx+eax+4]
  0004a	89 55 f8	 mov	 DWORD PTR _count$[ebp], edx

; 881  : 		lseg = &segs[subsectors[i].firstline];

  0004d	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _subsectors
  00057	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  0005c	6b c2 3c	 imul	 eax, edx, 60
  0005f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  00065	89 45 f0	 mov	 DWORD PTR _lseg$[ebp], eax

; 882  : 		p = extrasubsectors[i].planepoly;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  00071	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00074	89 55 ec	 mov	 DWORD PTR _p$[ebp], edx

; 883  : 		if (!p)

  00077	83 7d ec 00	 cmp	 DWORD PTR _p$[ebp], 0
  0007b	75 02		 jne	 SHORT $LN11@AdjustSegs

; 884  : 			continue;

  0007d	eb a4		 jmp	 SHORT $LN2@AdjustSegs
$LN11@AdjustSegs:

; 885  : 		for (; count--; lseg++)

  0007f	eb 09		 jmp	 SHORT $LN7@AdjustSegs
$LN5@AdjustSegs:
  00081	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  00084	83 c0 3c	 add	 eax, 60			; 0000003cH
  00087	89 45 f0	 mov	 DWORD PTR _lseg$[ebp], eax
$LN7@AdjustSegs:
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0008d	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00096	83 e9 01	 sub	 ecx, 1
  00099	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  0009c	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv83[ebp], 0
  000a3	0f 84 8e 02 00
	00		 je	 $LN6@AdjustSegs

; 886  : 		{
; 887  : 			float distv1,distv2,tmp;
; 888  : 			nearv1 = nearv2 = MYMAX;

  000a9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@551184e7
  000b1	f3 0f 11 45 dc	 movss	 DWORD PTR _nearv2$[ebp], xmm0
  000b6	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _nearv2$[ebp]
  000bb	f3 0f 11 45 e0	 movss	 DWORD PTR _nearv1$[ebp], xmm0

; 889  : 
; 890  : #ifdef POLYOBJECTS
; 891  : 			// Don't touch polyobject segs. We'll compensate
; 892  : 			// for this when we go about drawing them. -Jazz
; 893  : 			if (lseg->polyseg)

  000c0	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  000c3	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  000c7	74 02		 je	 SHORT $LN12@AdjustSegs

; 894  : 				continue;

  000c9	eb b6		 jmp	 SHORT $LN5@AdjustSegs
$LN12@AdjustSegs:

; 895  : #endif
; 896  : 
; 897  : 			for (j = 0; j < p->numpts; j++)

  000cb	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000d2	eb 09		 jmp	 SHORT $LN10@AdjustSegs
$LN8@AdjustSegs:
  000d4	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000d7	83 c0 01	 add	 eax, 1
  000da	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN10@AdjustSegs:
  000dd	8b 45 ec	 mov	 eax, DWORD PTR _p$[ebp]
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  000e3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000e5	0f 8d 15 01 00
	00		 jge	 $LN9@AdjustSegs

; 898  : 			{
; 899  : 				distv1 = p->pts[j].x - FIXED_TO_FLOAT(lseg->v1->x);

  000eb	6b 45 f4 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _lseg$[ebp]
  000f2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f4	f3 0f 2a 02	 cvtsi2ss xmm0, DWORD PTR [edx]
  000f8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  00103	f3 0f 10 4c 01
	04		 movss	 xmm1, DWORD PTR [ecx+eax+4]
  00109	f3 0f 5c c8	 subss	 xmm1, xmm0
  0010d	f3 0f 11 4d d8	 movss	 DWORD PTR _distv1$7[ebp], xmm1

; 900  : 				tmp    = p->pts[j].y - FIXED_TO_FLOAT(lseg->v1->y);

  00112	6b 45 f4 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  00116	8b 4d f0	 mov	 ecx, DWORD PTR _lseg$[ebp]
  00119	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011b	f3 0f 2a 42 04	 cvtsi2ss xmm0, DWORD PTR [edx+4]
  00120	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00128	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  0012b	f3 0f 10 4c 01
	08		 movss	 xmm1, DWORD PTR [ecx+eax+8]
  00131	f3 0f 5c c8	 subss	 xmm1, xmm0
  00135	f3 0f 11 4d d0	 movss	 DWORD PTR _tmp$5[ebp], xmm1

; 901  : 				distv1 = distv1*distv1+tmp*tmp;

  0013a	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _distv1$7[ebp]
  0013f	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _distv1$7[ebp]
  00144	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _tmp$5[ebp]
  00149	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _tmp$5[ebp]
  0014e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00152	f3 0f 11 45 d8	 movss	 DWORD PTR _distv1$7[ebp], xmm0

; 902  : 				if (distv1 <= nearv1)

  00157	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _nearv1$[ebp]
  0015c	0f 2f 45 d8	 comiss	 xmm0, DWORD PTR _distv1$7[ebp]
  00160	72 10		 jb	 SHORT $LN13@AdjustSegs

; 903  : 				{
; 904  : 					v1found = j;

  00162	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00165	89 45 e8	 mov	 DWORD PTR _v1found$[ebp], eax

; 905  : 					nearv1 = distv1;

  00168	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _distv1$7[ebp]
  0016d	f3 0f 11 45 e0	 movss	 DWORD PTR _nearv1$[ebp], xmm0
$LN13@AdjustSegs:

; 906  : 				}
; 907  : 				// the same with v2
; 908  : 				distv2 = p->pts[j].x - FIXED_TO_FLOAT(lseg->v2->x);

  00172	6b 45 f4 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  00176	8b 4d f0	 mov	 ecx, DWORD PTR _lseg$[ebp]
  00179	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0017c	f3 0f 2a 02	 cvtsi2ss xmm0, DWORD PTR [edx]
  00180	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00188	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  0018b	f3 0f 10 4c 01
	04		 movss	 xmm1, DWORD PTR [ecx+eax+4]
  00191	f3 0f 5c c8	 subss	 xmm1, xmm0
  00195	f3 0f 11 4d d4	 movss	 DWORD PTR _distv2$6[ebp], xmm1

; 909  : 				tmp    = p->pts[j].y - FIXED_TO_FLOAT(lseg->v2->y);

  0019a	6b 45 f4 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  0019e	8b 4d f0	 mov	 ecx, DWORD PTR _lseg$[ebp]
  001a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a4	f3 0f 2a 42 04	 cvtsi2ss xmm0, DWORD PTR [edx+4]
  001a9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001b1	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  001b4	f3 0f 10 4c 01
	08		 movss	 xmm1, DWORD PTR [ecx+eax+8]
  001ba	f3 0f 5c c8	 subss	 xmm1, xmm0
  001be	f3 0f 11 4d d0	 movss	 DWORD PTR _tmp$5[ebp], xmm1

; 910  : 				distv2 = distv2*distv2+tmp*tmp;

  001c3	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _distv2$6[ebp]
  001c8	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _distv2$6[ebp]
  001cd	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _tmp$5[ebp]
  001d2	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _tmp$5[ebp]
  001d7	f3 0f 58 c1	 addss	 xmm0, xmm1
  001db	f3 0f 11 45 d4	 movss	 DWORD PTR _distv2$6[ebp], xmm0

; 911  : 				if (distv2 <= nearv2)

  001e0	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _nearv2$[ebp]
  001e5	0f 2f 45 d4	 comiss	 xmm0, DWORD PTR _distv2$6[ebp]
  001e9	72 10		 jb	 SHORT $LN14@AdjustSegs

; 912  : 				{
; 913  : 					v2found = j;

  001eb	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  001ee	89 45 e4	 mov	 DWORD PTR _v2found$[ebp], eax

; 914  : 					nearv2 = distv2;

  001f1	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _distv2$6[ebp]
  001f6	f3 0f 11 45 dc	 movss	 DWORD PTR _nearv2$[ebp], xmm0
$LN14@AdjustSegs:

; 915  : 				}
; 916  : 			}

  001fb	e9 d4 fe ff ff	 jmp	 $LN8@AdjustSegs
$LN9@AdjustSegs:

; 917  : 			if (nearv1 <= NEARDIST*NEARDIST)

  00200	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f100000
  00208	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _nearv1$[ebp]
  0020c	72 12		 jb	 SHORT $LN15@AdjustSegs

; 918  : 				// share vertice with segs
; 919  : 				lseg->v1 = (vertex_t *)&(p->pts[v1found]);

  0020e	6b 45 e8 0c	 imul	 eax, DWORD PTR _v1found$[ebp], 12
  00212	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  00215	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00219	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  0021c	89 10		 mov	 DWORD PTR [eax], edx
  0021e	eb 42		 jmp	 SHORT $LN16@AdjustSegs
$LN15@AdjustSegs:

; 920  : 			else
; 921  : 			{
; 922  : 				// BP: here we can do better, using PointInSeg and compute
; 923  : 				// the right point position also split a polygone side to
; 924  : 				// solve a T-intersection, but too mush work
; 925  : 
; 926  : 				// convert fixed vertex to float vertex
; 927  : 				polyvertex_t *pv = HWR_AllocVertex();

  00220	e8 00 00 00 00	 call	 _HWR_AllocVertex
  00225	89 45 cc	 mov	 DWORD PTR _pv$4[ebp], eax

; 928  : 				pv->x = FIXED_TO_FLOAT(lseg->v1->x);

  00228	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  0022b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022d	f3 0f 2a 01	 cvtsi2ss xmm0, DWORD PTR [ecx]
  00231	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00239	8b 55 cc	 mov	 edx, DWORD PTR _pv$4[ebp]
  0023c	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 929  : 				pv->y = FIXED_TO_FLOAT(lseg->v1->y);

  00240	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  00243	8b 08		 mov	 ecx, DWORD PTR [eax]
  00245	f3 0f 2a 41 04	 cvtsi2ss xmm0, DWORD PTR [ecx+4]
  0024a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00252	8b 55 cc	 mov	 edx, DWORD PTR _pv$4[ebp]
  00255	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 930  : 				lseg->v1 = (vertex_t *)pv;

  0025a	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  0025d	8b 4d cc	 mov	 ecx, DWORD PTR _pv$4[ebp]
  00260	89 08		 mov	 DWORD PTR [eax], ecx
$LN16@AdjustSegs:

; 931  : 			}
; 932  : 			if (nearv2 <= NEARDIST*NEARDIST)

  00262	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f100000
  0026a	0f 2f 45 dc	 comiss	 xmm0, DWORD PTR _nearv2$[ebp]
  0026e	72 13		 jb	 SHORT $LN17@AdjustSegs

; 933  : 				lseg->v2 = (vertex_t *)&(p->pts[v2found]);

  00270	6b 45 e4 0c	 imul	 eax, DWORD PTR _v2found$[ebp], 12
  00274	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  00277	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0027b	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  0027e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00281	eb 45		 jmp	 SHORT $LN18@AdjustSegs
$LN17@AdjustSegs:

; 934  : 			else
; 935  : 			{
; 936  : 				polyvertex_t *pv = HWR_AllocVertex();

  00283	e8 00 00 00 00	 call	 _HWR_AllocVertex
  00288	89 45 c8	 mov	 DWORD PTR _pv$3[ebp], eax

; 937  : 				pv->x = FIXED_TO_FLOAT(lseg->v2->x);

  0028b	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  0028e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00291	f3 0f 2a 01	 cvtsi2ss xmm0, DWORD PTR [ecx]
  00295	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0029d	8b 55 c8	 mov	 edx, DWORD PTR _pv$3[ebp]
  002a0	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 938  : 				pv->y = FIXED_TO_FLOAT(lseg->v2->y);

  002a4	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  002a7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002aa	f3 0f 2a 41 04	 cvtsi2ss xmm0, DWORD PTR [ecx+4]
  002af	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  002b7	8b 55 c8	 mov	 edx, DWORD PTR _pv$3[ebp]
  002ba	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 939  : 				lseg->v2 = (vertex_t *)pv;

  002bf	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  002c2	8b 4d c8	 mov	 ecx, DWORD PTR _pv$3[ebp]
  002c5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN18@AdjustSegs:

; 940  : 			}
; 941  : 
; 942  : 			// recompute length
; 943  : 			{
; 944  : 				float x,y;
; 945  : 				x = ((polyvertex_t *)lseg->v2)->x - ((polyvertex_t *)lseg->v1)->x

  002c8	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  002cb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ce	8b 55 f0	 mov	 edx, DWORD PTR _lseg$[ebp]
  002d1	8b 02		 mov	 eax, DWORD PTR [edx]
  002d3	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  002d7	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  002db	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  002e3	f3 0f 11 45 c4	 movss	 DWORD PTR _x$2[ebp], xmm0

; 946  : 					+ FIXED_TO_FLOAT(FRACUNIT/2);
; 947  : 				y = ((polyvertex_t *)lseg->v2)->y - ((polyvertex_t *)lseg->v1)->y

  002e8	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  002eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ee	8b 55 f0	 mov	 edx, DWORD PTR _lseg$[ebp]
  002f1	8b 02		 mov	 eax, DWORD PTR [edx]
  002f3	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  002f8	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  002fd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00305	f3 0f 11 45 c0	 movss	 DWORD PTR _y$1[ebp], xmm0

; 948  : 					+ FIXED_TO_FLOAT(FRACUNIT/2);
; 949  : 				lseg->flength = (float)hypot(x, y);

  0030a	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR _y$1[ebp]
  0030f	83 ec 08	 sub	 esp, 8
  00312	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00317	f3 0f 5a 45 c4	 cvtss2sd xmm0, DWORD PTR _x$2[ebp]
  0031c	83 ec 08	 sub	 esp, 8
  0031f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00324	e8 00 00 00 00	 call	 _hypot
  00329	83 c4 10	 add	 esp, 16			; 00000010H
  0032c	8b 45 f0	 mov	 eax, DWORD PTR _lseg$[ebp]
  0032f	d9 58 24	 fstp	 DWORD PTR [eax+36]

; 950  : 				// BP: debug see this kind of segs
; 951  : 				//if (nearv2 > NEARDIST*NEARDIST || nearv1 > NEARDIST*NEARDIST)
; 952  : 				//    lseg->length = 1;
; 953  : 			}
; 954  : 		}

  00332	e9 4a fd ff ff	 jmp	 $LN5@AdjustSegs
$LN6@AdjustSegs:

; 955  : 	}

  00337	e9 e7 fc ff ff	 jmp	 $LN2@AdjustSegs
$LN3@AdjustSegs:

; 956  : }

  0033c	5f		 pop	 edi
  0033d	5e		 pop	 esi
  0033e	5b		 pop	 ebx
  0033f	8b e5		 mov	 esp, ebp
  00341	5d		 pop	 ebp
  00342	c3		 ret	 0
_AdjustSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _SolveTProblem
_TEXT	SEGMENT
_l$ = -12						; size = 4
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_SolveTProblem PROC					; COMDAT

; 835  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 836  : 	poly_t *p;
; 837  : 	INT32 i;
; 838  : 	size_t l;
; 839  : 
; 840  : 	if (cv_grsolvetjoin.value == 0)

  00009	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grsolvetjoin+20, 0
  00010	75 07		 jne	 SHORT $LN8@SolveTProb

; 841  : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 a5 00 00 00	 jmp	 $LN1@SolveTProb
$LN8@SolveTProb:

; 842  : 
; 843  : 	if (cv_debug)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  00020	74 0d		 je	 SHORT $LN9@SolveTProb

; 844  : 		CONS_Printf("Solving T-joins. This may take a while. Please wait...\n");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CBOJMKBL@Solving?5T?9joins?4?5This?5may?5take?5@
  00027	e8 00 00 00 00	 call	 _CONS_Printf
  0002c	83 c4 04	 add	 esp, 4
$LN9@SolveTProb:

; 845  : 	CON_Drawer(); //let the user know what we are doing

  0002f	e8 00 00 00 00	 call	 _CON_Drawer
  00034	90		 npad	 1

; 846  : 	I_FinishUpdate(); // page flip or blit buffer

  00035	e8 00 00 00 00	 call	 _I_FinishUpdate
  0003a	90		 npad	 1

; 847  : 
; 848  : 	numsplitpoly = 0;

  0003b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numsplitpoly, 0

; 849  : 
; 850  : 	for (l = 0; l < addsubsector; l++)

  00045	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _l$[ebp], 0
  0004c	eb 09		 jmp	 SHORT $LN4@SolveTProb
$LN2@SolveTProb:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR _l$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 f4	 mov	 DWORD PTR _l$[ebp], eax
$LN4@SolveTProb:
  00057	8b 45 f4	 mov	 eax, DWORD PTR _l$[ebp]
  0005a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _addsubsector
  00060	73 57		 jae	 SHORT $LN3@SolveTProb

; 851  : 	{
; 852  : 		p = extrasubsectors[l].planepoly;

  00062	8b 45 f4	 mov	 eax, DWORD PTR _l$[ebp]
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  0006b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0006e	89 55 fc	 mov	 DWORD PTR _p$[ebp], edx

; 853  : 		if (p)

  00071	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  00075	74 40		 je	 SHORT $LN6@SolveTProb

; 854  : 			for (i = 0; i < p->numpts; i++)

  00077	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007e	eb 09		 jmp	 SHORT $LN7@SolveTProb
$LN5@SolveTProb:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@SolveTProb:
  00089	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0008f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00091	7d 24		 jge	 SHORT $LN6@SolveTProb

; 855  : 				SearchSegInBSP((INT32)numnodes-1, &p->pts[i], p);

  00093	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00096	50		 push	 eax
  00097	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0009e	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000a2	50		 push	 eax
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numnodes
  000a9	83 e9 01	 sub	 ecx, 1
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _SearchSegInBSP
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	eb c9		 jmp	 SHORT $LN5@SolveTProb
$LN6@SolveTProb:

; 856  : 	}

  000b7	eb 95		 jmp	 SHORT $LN2@SolveTProb
$LN3@SolveTProb:

; 857  : 	//CONS_Printf("numsplitpoly %d\n", numsplitpoly);
; 858  : 	return numsplitpoly;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsplitpoly
$LN1@SolveTProb:

; 859  : }

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_SolveTProblem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _SearchSegInBSP
_TEXT	SEGMENT
_n$1 = -20						; size = 4
_newpoly$2 = -16					; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_q$ = -4						; size = 4
_bspnum$ = 8						; size = 4
_p$ = 12						; size = 4
_poly$ = 16						; size = 4
_SearchSegInBSP PROC					; COMDAT

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 777  : 	poly_t  *q;
; 778  : 	INT32     j,k;
; 779  : 
; 780  : 	if (bspnum & NF_SUBSECTOR)

  00009	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  0000c	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00011	0f 84 d3 01 00
	00		 je	 $LN11@SearchSegI

; 781  : 	{
; 782  : 		if (bspnum!=-1)

  00017	83 7d 08 ff	 cmp	 DWORD PTR _bspnum$[ebp], -1
  0001b	0f 84 c4 01 00
	00		 je	 $LN3@SearchSegI

; 783  : 		{
; 784  : 			bspnum&=~NF_SUBSECTOR;

  00021	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  00024	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  00029	89 45 08	 mov	 DWORD PTR _bspnum$[ebp], eax

; 785  : 			q = extrasubsectors[bspnum].planepoly;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  00035	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00038	89 55 fc	 mov	 DWORD PTR _q$[ebp], edx

; 786  : 			if (poly == q || !q)

  0003b	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  0003e	3b 45 fc	 cmp	 eax, DWORD PTR _q$[ebp]
  00041	74 06		 je	 SHORT $LN14@SearchSegI
  00043	83 7d fc 00	 cmp	 DWORD PTR _q$[ebp], 0
  00047	75 05		 jne	 SHORT $LN13@SearchSegI
$LN14@SearchSegI:

; 787  : 				return;

  00049	e9 e6 03 00 00	 jmp	 $LN18@SearchSegI
$LN13@SearchSegI:

; 788  : 			for (j = 0; j < q->numpts; j++)

  0004e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00055	eb 09		 jmp	 SHORT $LN4@SearchSegI
$LN2@SearchSegI:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@SearchSegI:
  00060	8b 45 fc	 mov	 eax, DWORD PTR _q$[ebp]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00066	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00068	0f 8d 77 01 00
	00		 jge	 $LN3@SearchSegI

; 789  : 			{
; 790  : 				k = j+1;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 f4	 mov	 DWORD PTR _k$[ebp], eax

; 791  : 				if (k == q->numpts) k = 0;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _q$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  0007d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0007f	75 07		 jne	 SHORT $LN15@SearchSegI
  00081	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
$LN15@SearchSegI:

; 792  : 				if (!SameVertice(p, &q->pts[j])
; 793  : 					&& !SameVertice(p, &q->pts[k])
; 794  : 					&& PointInSeg(p, &q->pts[j],

  00088	6b 45 f8 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  0008f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00093	52		 push	 edx
  00094	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _SameVertice
  0009d	83 c4 08	 add	 esp, 8
  000a0	85 c0		 test	 eax, eax
  000a2	0f 85 38 01 00
	00		 jne	 $LN16@SearchSegI
  000a8	6b 45 f4 0c	 imul	 eax, DWORD PTR _k$[ebp], 12
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  000af	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000b3	52		 push	 edx
  000b4	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _SameVertice
  000bd	83 c4 08	 add	 esp, 8
  000c0	85 c0		 test	 eax, eax
  000c2	0f 85 18 01 00
	00		 jne	 $LN16@SearchSegI
  000c8	6b 45 f4 0c	 imul	 eax, DWORD PTR _k$[ebp], 12
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  000cf	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000d3	52		 push	 edx
  000d4	6b 45 f8 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  000db	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000df	52		 push	 edx
  000e0	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _PointInSeg
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	85 c0		 test	 eax, eax
  000ee	0f 84 ec 00 00
	00		 je	 $LN16@SearchSegI

; 795  : 						&q->pts[k]))
; 796  : 				{
; 797  : 					poly_t *newpoly = HWR_AllocPoly(q->numpts+1);

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _q$[ebp]
  000f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f9	83 c1 01	 add	 ecx, 1
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 _HWR_AllocPoly
  00102	83 c4 04	 add	 esp, 4
  00105	89 45 f0	 mov	 DWORD PTR _newpoly$2[ebp], eax

; 798  : 					INT32 n;
; 799  : 
; 800  : 					for (n = 0; n <= j; n++)

  00108	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0010f	eb 09		 jmp	 SHORT $LN7@SearchSegI
$LN5@SearchSegI:
  00111	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00114	83 c0 01	 add	 eax, 1
  00117	89 45 ec	 mov	 DWORD PTR _n$1[ebp], eax
$LN7@SearchSegI:
  0011a	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  0011d	3b 45 f8	 cmp	 eax, DWORD PTR _j$[ebp]
  00120	7f 28		 jg	 SHORT $LN6@SearchSegI

; 801  : 						newpoly->pts[n] = q->pts[n];

  00122	6b 45 ec 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00126	8b 4d fc	 mov	 ecx, DWORD PTR _q$[ebp]
  00129	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0012d	6b 45 ec 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00131	8b 4d f0	 mov	 ecx, DWORD PTR _newpoly$2[ebp]
  00134	8d 44 01 04	 lea	 eax, DWORD PTR [ecx+eax+4]
  00138	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0013a	89 08		 mov	 DWORD PTR [eax], ecx
  0013c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0013f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00142	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00145	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00148	eb c7		 jmp	 SHORT $LN5@SearchSegI
$LN6@SearchSegI:

; 802  : 					newpoly->pts[k] = *p;

  0014a	6b 45 f4 0c	 imul	 eax, DWORD PTR _k$[ebp], 12
  0014e	8b 4d f0	 mov	 ecx, DWORD PTR _newpoly$2[ebp]
  00151	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00155	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00158	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015a	89 0a		 mov	 DWORD PTR [edx], ecx
  0015c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00162	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00165	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 803  : 					for (n = k+1; n < newpoly->numpts; n++)

  00168	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  0016b	83 c0 01	 add	 eax, 1
  0016e	89 45 ec	 mov	 DWORD PTR _n$1[ebp], eax
  00171	eb 09		 jmp	 SHORT $LN10@SearchSegI
$LN8@SearchSegI:
  00173	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00176	83 c0 01	 add	 eax, 1
  00179	89 45 ec	 mov	 DWORD PTR _n$1[ebp], eax
$LN10@SearchSegI:
  0017c	8b 45 f0	 mov	 eax, DWORD PTR _newpoly$2[ebp]
  0017f	8b 4d ec	 mov	 ecx, DWORD PTR _n$1[ebp]
  00182	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00184	7d 2d		 jge	 SHORT $LN9@SearchSegI

; 804  : 						newpoly->pts[n] = q->pts[n-1];

  00186	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00189	83 e8 01	 sub	 eax, 1
  0018c	6b c8 0c	 imul	 ecx, eax, 12
  0018f	8b 55 fc	 mov	 edx, DWORD PTR _q$[ebp]
  00192	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00196	6b 4d ec 0c	 imul	 ecx, DWORD PTR _n$1[ebp], 12
  0019a	8b 55 f0	 mov	 edx, DWORD PTR _newpoly$2[ebp]
  0019d	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  001a1	8b 10		 mov	 edx, DWORD PTR [eax]
  001a3	89 11		 mov	 DWORD PTR [ecx], edx
  001a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001a8	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001ab	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001ae	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  001b1	eb c0		 jmp	 SHORT $LN8@SearchSegI
$LN9@SearchSegI:

; 805  : 					numsplitpoly++;

  001b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsplitpoly
  001b8	83 c0 01	 add	 eax, 1
  001bb	a3 00 00 00 00	 mov	 DWORD PTR _numsplitpoly, eax

; 806  : 					extrasubsectors[bspnum].planepoly =

  001c0	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  001c9	8b 55 f0	 mov	 edx, DWORD PTR _newpoly$2[ebp]
  001cc	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 807  : 						newpoly;
; 808  : 					HWR_FreePoly(q);

  001cf	8b 45 fc	 mov	 eax, DWORD PTR _q$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _HWR_FreePoly
  001d8	83 c4 04	 add	 esp, 4

; 809  : 					return;

  001db	e9 54 02 00 00	 jmp	 $LN18@SearchSegI
$LN16@SearchSegI:

; 810  : 				}
; 811  : 			}

  001e0	e9 72 fe ff ff	 jmp	 $LN2@SearchSegI
$LN3@SearchSegI:

; 812  : 		}
; 813  : 		return;

  001e5	e9 4a 02 00 00	 jmp	 $LN18@SearchSegI
$LN11@SearchSegI:

; 814  : 	}
; 815  : 
; 816  : 	if ((FIXED_TO_FLOAT(nodes[bspnum].bbox[0][BOXBOTTOM])-MAXDIST <= p->y) &&
; 817  : 	    (FIXED_TO_FLOAT(nodes[bspnum].bbox[0][BOXTOP   ])+MAXDIST >= p->y) &&
; 818  : 	    (FIXED_TO_FLOAT(nodes[bspnum].bbox[0][BOXLEFT  ])-MAXDIST <= p->x) &&

  001ea	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  001ee	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  001f4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001f9	6b d1 00	 imul	 edx, ecx, 0
  001fc	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  00200	b9 04 00 00 00	 mov	 ecx, 4
  00205	c1 e1 00	 shl	 ecx, 0
  00208	f3 0f 2a 04 08	 cvtsi2ss xmm0, DWORD PTR [eax+ecx]
  0020d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00215	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  0021d	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00220	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00225	0f 2f c8	 comiss	 xmm1, xmm0
  00228	0f 82 e1 00 00
	00		 jb	 $LN17@SearchSegI
  0022e	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  00232	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  00238	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0023d	6b d1 00	 imul	 edx, ecx, 0
  00240	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  00244	b9 04 00 00 00	 mov	 ecx, 4
  00249	6b d1 00	 imul	 edx, ecx, 0
  0024c	f3 0f 2a 04 10	 cvtsi2ss xmm0, DWORD PTR [eax+edx]
  00251	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00259	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3fc00000
  00261	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00264	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00268	0f 82 a1 00 00
	00		 jb	 $LN17@SearchSegI
  0026e	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  00272	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  00278	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0027d	6b d1 00	 imul	 edx, ecx, 0
  00280	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  00284	b9 04 00 00 00	 mov	 ecx, 4
  00289	d1 e1		 shl	 ecx, 1
  0028b	f3 0f 2a 04 08	 cvtsi2ss xmm0, DWORD PTR [eax+ecx]
  00290	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00298	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  002a0	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  002a3	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  002a7	0f 2f c8	 comiss	 xmm1, xmm0
  002aa	72 63		 jb	 SHORT $LN17@SearchSegI
  002ac	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  002b0	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  002b6	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002bb	6b d1 00	 imul	 edx, ecx, 0
  002be	8d 44 10 10	 lea	 eax, DWORD PTR [eax+edx+16]
  002c2	b9 04 00 00 00	 mov	 ecx, 4
  002c7	6b d1 03	 imul	 edx, ecx, 3
  002ca	f3 0f 2a 04 10	 cvtsi2ss xmm0, DWORD PTR [eax+edx]
  002cf	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  002d7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3fc00000
  002df	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  002e2	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  002e5	72 28		 jb	 SHORT $LN17@SearchSegI

; 819  : 	    (FIXED_TO_FLOAT(nodes[bspnum].bbox[0][BOXRIGHT ])+MAXDIST >= p->x))
; 820  : 		SearchSegInBSP(nodes[bspnum].children[0],p,poly);

  002e7	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  002ee	51		 push	 ecx
  002ef	6b 55 08 34	 imul	 edx, DWORD PTR _bspnum$[ebp], 52
  002f3	03 15 00 00 00
	00		 add	 edx, DWORD PTR _nodes
  002f9	b8 02 00 00 00	 mov	 eax, 2
  002fe	6b c8 00	 imul	 ecx, eax, 0
  00301	0f b7 54 0a 30	 movzx	 edx, WORD PTR [edx+ecx+48]
  00306	52		 push	 edx
  00307	e8 00 00 00 00	 call	 _SearchSegInBSP
  0030c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@SearchSegI:

; 821  : 
; 822  : 	if ((FIXED_TO_FLOAT(nodes[bspnum].bbox[1][BOXBOTTOM])-MAXDIST <= p->y) &&
; 823  : 	    (FIXED_TO_FLOAT(nodes[bspnum].bbox[1][BOXTOP   ])+MAXDIST >= p->y) &&
; 824  : 	    (FIXED_TO_FLOAT(nodes[bspnum].bbox[1][BOXLEFT  ])-MAXDIST <= p->x) &&

  0030f	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  00313	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  00319	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0031e	c1 e1 00	 shl	 ecx, 0
  00321	8d 54 08 10	 lea	 edx, DWORD PTR [eax+ecx+16]
  00325	b8 04 00 00 00	 mov	 eax, 4
  0032a	c1 e0 00	 shl	 eax, 0
  0032d	f3 0f 2a 04 02	 cvtsi2ss xmm0, DWORD PTR [edx+eax]
  00332	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0033a	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  00342	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00345	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0034a	0f 2f c8	 comiss	 xmm1, xmm0
  0034d	0f 82 e1 00 00
	00		 jb	 $LN18@SearchSegI
  00353	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  00357	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  0035d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00362	c1 e1 00	 shl	 ecx, 0
  00365	8d 54 08 10	 lea	 edx, DWORD PTR [eax+ecx+16]
  00369	b8 04 00 00 00	 mov	 eax, 4
  0036e	6b c8 00	 imul	 ecx, eax, 0
  00371	f3 0f 2a 04 0a	 cvtsi2ss xmm0, DWORD PTR [edx+ecx]
  00376	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0037e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3fc00000
  00386	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00389	0f 2f 42 04	 comiss	 xmm0, DWORD PTR [edx+4]
  0038d	0f 82 a1 00 00
	00		 jb	 $LN18@SearchSegI
  00393	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  00397	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  0039d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003a2	c1 e1 00	 shl	 ecx, 0
  003a5	8d 54 08 10	 lea	 edx, DWORD PTR [eax+ecx+16]
  003a9	b8 04 00 00 00	 mov	 eax, 4
  003ae	d1 e0		 shl	 eax, 1
  003b0	f3 0f 2a 04 02	 cvtsi2ss xmm0, DWORD PTR [edx+eax]
  003b5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  003bd	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  003c5	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  003c8	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  003cc	0f 2f c8	 comiss	 xmm1, xmm0
  003cf	72 63		 jb	 SHORT $LN18@SearchSegI
  003d1	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  003d5	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  003db	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003e0	c1 e1 00	 shl	 ecx, 0
  003e3	8d 54 08 10	 lea	 edx, DWORD PTR [eax+ecx+16]
  003e7	b8 04 00 00 00	 mov	 eax, 4
  003ec	6b c8 03	 imul	 ecx, eax, 3
  003ef	f3 0f 2a 04 0a	 cvtsi2ss xmm0, DWORD PTR [edx+ecx]
  003f4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  003fc	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3fc00000
  00404	8b 55 0c	 mov	 edx, DWORD PTR _p$[ebp]
  00407	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  0040a	72 28		 jb	 SHORT $LN18@SearchSegI

; 825  : 	    (FIXED_TO_FLOAT(nodes[bspnum].bbox[1][BOXRIGHT ])+MAXDIST >= p->x))
; 826  : 		SearchSegInBSP(nodes[bspnum].children[1],p,poly);

  0040c	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  0040f	50		 push	 eax
  00410	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00413	51		 push	 ecx
  00414	6b 55 08 34	 imul	 edx, DWORD PTR _bspnum$[ebp], 52
  00418	03 15 00 00 00
	00		 add	 edx, DWORD PTR _nodes
  0041e	b8 02 00 00 00	 mov	 eax, 2
  00423	c1 e0 00	 shl	 eax, 0
  00426	0f b7 4c 02 30	 movzx	 ecx, WORD PTR [edx+eax+48]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 _SearchSegInBSP
  00431	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@SearchSegI:

; 827  : }

  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	5b		 pop	 ebx
  00437	8b e5		 mov	 esp, ebp
  00439	5d		 pop	 ebp
  0043a	c3		 ret	 0
_SearchSegInBSP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _PointInSeg
_TEXT	SEGMENT
tv151 = -104						; size = 4
_p$ = -36						; size = 4
_norm$ = -32						; size = 4
_d$ = -28						; size = 4
_cy$ = -24						; size = 4
_cx$ = -20						; size = 4
_by$ = -16						; size = 4
_bx$ = -12						; size = 4
_ay$ = -8						; size = 4
_ax$ = -4						; size = 4
_a$ = 8							; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_PointInSeg PROC					; COMDAT

; 718  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 719  : 	register float ax,ay,bx,by,cx,cy,d,norm;
; 720  : 	register polyvertex_t *p;
; 721  : 
; 722  : 	// check bbox of the seg first
; 723  : 	if (v1->x > v2->x)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _v2$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00016	76 12		 jbe	 SHORT $LN2@PointInSeg

; 724  : 	{
; 725  : 		p = v1;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0001b	89 45 dc	 mov	 DWORD PTR _p$[ebp], eax

; 726  : 		v1 = v2;

  0001e	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  00021	89 45 0c	 mov	 DWORD PTR _v1$[ebp], eax

; 727  : 		v2 = p;

  00024	8b 45 dc	 mov	 eax, DWORD PTR _p$[ebp]
  00027	89 45 10	 mov	 DWORD PTR _v2$[ebp], eax
$LN2@PointInSeg:

; 728  : 	}
; 729  : 
; 730  : 	if (a->x < v1->x-MAXDIST || a->x > v2->x+MAXDIST)

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0002d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00031	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0003c	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  0003f	77 1b		 ja	 SHORT $LN4@PointInSeg
  00041	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  00044	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00048	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3fc00000
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00053	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  00057	0f 2f c8	 comiss	 xmm1, xmm0
  0005a	76 07		 jbe	 SHORT $LN3@PointInSeg
$LN4@PointInSeg:

; 731  : 		return false;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 88 01 00 00	 jmp	 $LN1@PointInSeg
$LN3@PointInSeg:

; 732  : 
; 733  : 	if (v1->y > v2->y)

  00063	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  00066	8b 4d 10	 mov	 ecx, DWORD PTR _v2$[ebp]
  00069	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0006e	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  00072	76 12		 jbe	 SHORT $LN5@PointInSeg

; 734  : 	{
; 735  : 		p = v1;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  00077	89 45 dc	 mov	 DWORD PTR _p$[ebp], eax

; 736  : 		v1 = v2;

  0007a	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  0007d	89 45 0c	 mov	 DWORD PTR _v1$[ebp], eax

; 737  : 		v2 = p;

  00080	8b 45 dc	 mov	 eax, DWORD PTR _p$[ebp]
  00083	89 45 10	 mov	 DWORD PTR _v2$[ebp], eax
$LN5@PointInSeg:

; 738  : 	}
; 739  : 	if (a->y < v1->y-MAXDIST || a->y > v2->y+MAXDIST)

  00086	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  00089	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0008e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00099	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  0009d	77 1d		 ja	 SHORT $LN7@PointInSeg
  0009f	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  000a2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000a7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3fc00000
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000b2	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  000b7	0f 2f c8	 comiss	 xmm1, xmm0
  000ba	76 07		 jbe	 SHORT $LN6@PointInSeg
$LN7@PointInSeg:

; 740  : 		return false;

  000bc	33 c0		 xor	 eax, eax
  000be	e9 28 01 00 00	 jmp	 $LN1@PointInSeg
$LN6@PointInSeg:

; 741  : 
; 742  : 	// v1 = origine
; 743  : 	ax= v2->x-v1->x;

  000c3	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  000c9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000cd	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000d1	f3 0f 11 45 fc	 movss	 DWORD PTR _ax$[ebp], xmm0

; 744  : 	ay= v2->y-v1->y;

  000d6	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  000dc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000e1	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000e6	f3 0f 11 45 f8	 movss	 DWORD PTR _ay$[ebp], xmm0

; 745  : 	norm = (float)hypot(ax, ay);

  000eb	f3 0f 5a 45 f8	 cvtss2sd xmm0, DWORD PTR _ay$[ebp]
  000f0	83 ec 08	 sub	 esp, 8
  000f3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f8	f3 0f 5a 45 fc	 cvtss2sd xmm0, DWORD PTR _ax$[ebp]
  000fd	83 ec 08	 sub	 esp, 8
  00100	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00105	e8 00 00 00 00	 call	 _hypot
  0010a	83 c4 10	 add	 esp, 16			; 00000010H
  0010d	d9 5d e0	 fstp	 DWORD PTR _norm$[ebp]

; 746  : 	ax /= norm;

  00110	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _ax$[ebp]
  00115	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _norm$[ebp]
  0011a	f3 0f 11 45 fc	 movss	 DWORD PTR _ax$[ebp], xmm0

; 747  : 	ay /= norm;

  0011f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _ay$[ebp]
  00124	f3 0f 5e 45 e0	 divss	 xmm0, DWORD PTR _norm$[ebp]
  00129	f3 0f 11 45 f8	 movss	 DWORD PTR _ay$[ebp], xmm0

; 748  : 	bx = a->x-v1->x;

  0012e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00131	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  00134	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00138	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0013c	f3 0f 11 45 f4	 movss	 DWORD PTR _bx$[ebp], xmm0

; 749  : 	by = a->y-v1->y;

  00141	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00144	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  00147	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0014c	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00151	f3 0f 11 45 f0	 movss	 DWORD PTR _by$[ebp], xmm0

; 750  : 	//d = a.b
; 751  : 	d =ax*bx+ay*by;

  00156	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _ax$[ebp]
  0015b	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _bx$[ebp]
  00160	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _ay$[ebp]
  00165	f3 0f 59 4d f0	 mulss	 xmm1, DWORD PTR _by$[ebp]
  0016a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0016e	f3 0f 11 45 e4	 movss	 DWORD PTR _d$[ebp], xmm0

; 752  : 	// bound of the seg
; 753  : 	if (d < 0 || d > norm)

  00173	0f 57 c0	 xorps	 xmm0, xmm0
  00176	0f 2f 45 e4	 comiss	 xmm0, DWORD PTR _d$[ebp]
  0017a	77 0b		 ja	 SHORT $LN9@PointInSeg
  0017c	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _d$[ebp]
  00181	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _norm$[ebp]
  00185	76 04		 jbe	 SHORT $LN8@PointInSeg
$LN9@PointInSeg:

; 754  : 		return false;

  00187	33 c0		 xor	 eax, eax
  00189	eb 60		 jmp	 SHORT $LN1@PointInSeg
$LN8@PointInSeg:

; 755  : 	//c = d.1a-b
; 756  : 	cx = ax*d-bx;

  0018b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _ax$[ebp]
  00190	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _d$[ebp]
  00195	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _bx$[ebp]
  0019a	f3 0f 11 45 ec	 movss	 DWORD PTR _cx$[ebp], xmm0

; 757  : 	cy = ay*d-by;

  0019f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _ay$[ebp]
  001a4	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _d$[ebp]
  001a9	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _by$[ebp]
  001ae	f3 0f 11 45 e8	 movss	 DWORD PTR _cy$[ebp], xmm0

; 758  : #ifdef MOVEVERTEX
; 759  : 	if (cx*cx+cy*cy <= MAXDIST*MAXDIST)
; 760  : 	{
; 761  : 		// ajust a little the point position
; 762  : 		a->x = ax*d+v1->x;
; 763  : 		a->y = ay*d+v1->y;
; 764  : 		// anyway the correction is not enouth
; 765  : 		return true;
; 766  : 	}
; 767  : 	return false;
; 768  : #else
; 769  : 	return cx*cx+cy*cy <= MAXDIST*MAXDIST;

  001b3	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _cx$[ebp]
  001b8	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _cx$[ebp]
  001bd	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _cy$[ebp]
  001c2	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _cy$[ebp]
  001c7	f3 0f 58 c1	 addss	 xmm0, xmm1
  001cb	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40100000
  001d3	0f 2f c8	 comiss	 xmm1, xmm0
  001d6	72 09		 jb	 SHORT $LN11@PointInSeg
  001d8	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv151[ebp], 1
  001df	eb 07		 jmp	 SHORT $LN12@PointInSeg
$LN11@PointInSeg:
  001e1	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
$LN12@PointInSeg:
  001e8	8b 45 98	 mov	 eax, DWORD PTR tv151[ebp]
$LN1@PointInSeg:

; 770  : #endif
; 771  : }

  001eb	5f		 pop	 edi
  001ec	5e		 pop	 esi
  001ed	5b		 pop	 ebx
  001ee	8b e5		 mov	 esp, ebp
  001f0	5d		 pop	 ebp
  001f1	c3		 ret	 0
_PointInSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _WalkBSPNode
_TEXT	SEGMENT
tv88 = -132						; size = 4
_y$1 = -64						; size = 4
_x$2 = -60						; size = 4
_s$3 = -56						; size = 16
_i$ = -40						; size = 4
_pt$ = -36						; size = 4
_fdivline$ = -32					; size = 16
_frontpoly$ = -16					; size = 4
_backpoly$ = -12					; size = 4
_bsp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bspnum$ = 8						; size = 4
_poly$ = 12						; size = 4
_leafnode$ = 16						; size = 4
_bbox$ = 20						; size = 4
_WalkBSPNode PROC					; COMDAT

; 600  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 601  : 	node_t *bsp;
; 602  : 	poly_t *backpoly, *frontpoly;
; 603  : 	fdivline_t fdivline;
; 604  : 	polyvertex_t *pt;
; 605  : 	INT32 i;
; 606  : 
; 607  : 	// Found a subsector?
; 608  : 	if (bspnum & NF_SUBSECTOR)

  00016	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  00019	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0001e	0f 84 90 02 00
	00		 je	 $LN5@WalkBSPNod

; 609  : 	{
; 610  : 		if (bspnum == -1)

  00024	83 7d 08 ff	 cmp	 DWORD PTR _bspnum$[ebp], -1
  00028	0f 85 88 00 00
	00		 jne	 $LN6@WalkBSPNod

; 611  : 		{
; 612  : 			// BP: i think this code is useless and wrong because
; 613  : 			// - bspnum==-1 happens only when numsubsectors == 0
; 614  : 			// - it can't happens in bsp recursive call since bspnum is a INT32 and children is UINT16
; 615  : 			// - the BSP is complet !! (there just can have subsector without segs) (i am not sure of this point)
; 616  : 
; 617  : 			// do we have a valid polygon ?
; 618  : 			if (poly && poly->numpts > 2)

  0002e	83 7d 0c 00	 cmp	 DWORD PTR _poly$[ebp], 0
  00032	74 7d		 je	 SHORT $LN8@WalkBSPNod
  00034	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  00037	83 38 02	 cmp	 DWORD PTR [eax], 2
  0003a	7e 75		 jle	 SHORT $LN8@WalkBSPNod

; 619  : 			{
; 620  : 				CONS_Printf("Adding a new subsector\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FILNJIGP@Adding?5a?5new?5subsector?6@
  00041	e8 00 00 00 00	 call	 _CONS_Printf
  00046	83 c4 04	 add	 esp, 4

; 621  : 				if (addsubsector == numsubsectors + NEWSUBSECTORS)

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsubsectors
  0004e	83 c0 32	 add	 eax, 50			; 00000032H
  00051	39 05 00 00 00
	00		 cmp	 DWORD PTR _addsubsector, eax
  00057	75 0f		 jne	 SHORT $LN9@WalkBSPNod

; 622  : 					I_Error("WalkBSPNode: not enough addsubsectors\n");

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FIKCMBHP@WalkBSPNode?3?5not?5enough?5addsubs@
  0005e	e8 00 00 00 00	 call	 _I_Error
  00063	83 c4 04	 add	 esp, 4
  00066	eb 19		 jmp	 SHORT $LN11@WalkBSPNod
$LN9@WalkBSPNod:

; 623  : 				else if (addsubsector > 0x7fff)

  00068	81 3d 00 00 00
	00 ff 7f 00 00	 cmp	 DWORD PTR _addsubsector, 32767 ; 00007fffH
  00072	76 0d		 jbe	 SHORT $LN11@WalkBSPNod

; 624  : 					I_Error("WalkBSPNode: addsubsector > 0x7fff\n");

  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IDGOAFGF@WalkBSPNode?3?5addsubsector?5?$DO?50x7@
  00079	e8 00 00 00 00	 call	 _I_Error
  0007e	83 c4 04	 add	 esp, 4
$LN11@WalkBSPNod:

; 625  : 				*leafnode = (UINT16)((UINT16)addsubsector | NF_SUBSECTOR);

  00081	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _addsubsector
  00088	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  0008d	8b 4d 10	 mov	 ecx, DWORD PTR _leafnode$[ebp]
  00090	66 89 01	 mov	 WORD PTR [ecx], ax

; 626  : 				extrasubsectors[addsubsector].planepoly = poly;

  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _addsubsector
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  0009e	8b 55 0c	 mov	 edx, DWORD PTR _poly$[ebp]
  000a1	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 627  : 				addsubsector++;

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _addsubsector
  000a9	83 c0 01	 add	 eax, 1
  000ac	a3 00 00 00 00	 mov	 DWORD PTR _addsubsector, eax
$LN8@WalkBSPNod:

; 628  : 			}
; 629  : 
; 630  : 			//add subsectors without segs here?
; 631  : 			//HWR_SubsecPoly(0, NULL);
; 632  : 		}

  000b1	e9 74 01 00 00	 jmp	 $LN12@WalkBSPNod
$LN6@WalkBSPNod:

; 633  : 		else
; 634  : 		{
; 635  : 			HWR_SubsecPoly(bspnum&(~NF_SUBSECTOR), poly);

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _bspnum$[ebp]
  000bd	81 e1 ff 7f ff
	ff		 and	 ecx, -32769		; ffff7fffH
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _HWR_SubsecPoly
  000c9	83 c4 08	 add	 esp, 8

; 636  : 			//Hurdler: implement a loading status
; 637  : 
; 638  : 			if (ls_count-- <= 0)

  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _ls_count
  000d1	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ls_count
  000dd	83 e9 01	 sub	 ecx, 1
  000e0	89 0d 00 00 00
	00		 mov	 DWORD PTR _ls_count, ecx
  000e6	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv88[ebp], 0
  000ed	0f 87 37 01 00
	00		 ja	 $LN12@WalkBSPNod

; 639  : 			{
; 640  : 				char s[16];
; 641  : 				int x, y;
; 642  : 
; 643  : 				I_OsPolling();

  000f3	e8 00 00 00 00	 call	 _I_OsPolling
  000f8	90		 npad	 1

; 644  : 				ls_count = numsubsectors/50;

  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsubsectors
  000fe	33 d2		 xor	 edx, edx
  00100	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00105	f7 f1		 div	 ecx
  00107	a3 00 00 00 00	 mov	 DWORD PTR _ls_count, eax

; 645  : 				CON_Drawer();

  0010c	e8 00 00 00 00	 call	 _CON_Drawer
  00111	90		 npad	 1

; 646  : 				sprintf(s, "%d%%", (++ls_percent)<<1);

  00112	a0 00 00 00 00	 mov	 al, BYTE PTR _ls_percent
  00117	04 01		 add	 al, 1
  00119	a2 00 00 00 00	 mov	 BYTE PTR _ls_percent, al
  0011e	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _ls_percent
  00125	d1 e1		 shl	 ecx, 1
  00127	51		 push	 ecx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_04FCMNJMCO@?$CFd?$CF?$CF@
  0012d	8d 55 c8	 lea	 edx, DWORD PTR _s$3[ebp]
  00130	52		 push	 edx
  00131	e8 00 00 00 00	 call	 _sprintf
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 				x = BASEVIDWIDTH/2;

  00139	c7 45 c4 a0 00
	00 00		 mov	 DWORD PTR _x$2[ebp], 160 ; 000000a0H

; 648  : 				y = BASEVIDHEIGHT/2;

  00140	c7 45 c0 64 00
	00 00		 mov	 DWORD PTR _y$1[ebp], 100 ; 00000064H

; 649  : 				V_DrawPatchFill(W_CachePatchName("SRB2BACK",PU_CACHE));

  00147	6a 65		 push	 101			; 00000065H
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_08LPMGDBIJ@SRB2BACK@
  0014e	e8 00 00 00 00	 call	 _W_CachePatchName
  00153	83 c4 08	 add	 esp, 8
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _V_DrawPatchFill
  0015c	83 c4 04	 add	 esp, 4

; 650  : 				M_DrawTextBox(x-58, y-8, 13, 1);

  0015f	6a 01		 push	 1
  00161	6a 0d		 push	 13			; 0000000dH
  00163	8b 45 c0	 mov	 eax, DWORD PTR _y$1[ebp]
  00166	83 e8 08	 sub	 eax, 8
  00169	50		 push	 eax
  0016a	8b 4d c4	 mov	 ecx, DWORD PTR _x$2[ebp]
  0016d	83 e9 3a	 sub	 ecx, 58			; 0000003aH
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 _M_DrawTextBox
  00176	83 c4 10	 add	 esp, 16			; 00000010H

; 651  : 				V_DrawString(x-50, y, V_YELLOWMAP, "Loading...");

  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JIENHOK@Loading?4?4?4@
  0017e	68 00 00 10 00	 push	 1048576			; 00100000H
  00183	8b 45 c0	 mov	 eax, DWORD PTR _y$1[ebp]
  00186	50		 push	 eax
  00187	8b 4d c4	 mov	 ecx, DWORD PTR _x$2[ebp]
  0018a	83 e9 32	 sub	 ecx, 50			; 00000032H
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _V_DrawString
  00193	83 c4 10	 add	 esp, 16			; 00000010H

; 652  : 				V_DrawString(x+50-V_StringWidth(s), y, V_YELLOWMAP, s);

  00196	8d 45 c8	 lea	 eax, DWORD PTR _s$3[ebp]
  00199	50		 push	 eax
  0019a	68 00 00 10 00	 push	 1048576			; 00100000H
  0019f	8b 4d c0	 mov	 ecx, DWORD PTR _y$1[ebp]
  001a2	51		 push	 ecx
  001a3	8b 75 c4	 mov	 esi, DWORD PTR _x$2[ebp]
  001a6	83 c6 32	 add	 esi, 50			; 00000032H
  001a9	8d 55 c8	 lea	 edx, DWORD PTR _s$3[ebp]
  001ac	52		 push	 edx
  001ad	e8 00 00 00 00	 call	 _V_StringWidth
  001b2	83 c4 04	 add	 esp, 4
  001b5	2b f0		 sub	 esi, eax
  001b7	56		 push	 esi
  001b8	e8 00 00 00 00	 call	 _V_DrawString
  001bd	83 c4 10	 add	 esp, 16			; 00000010H

; 653  : 
; 654  : 				V_DrawCenteredString(BASEVIDWIDTH/2, 40, V_YELLOWMAP, "OPENGL MODE IS INCOMPLETE");

  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OJMJFMIN@OPENGL?5MODE?5IS?5INCOMPLETE@
  001c5	68 00 00 10 00	 push	 1048576			; 00100000H
  001ca	6a 28		 push	 40			; 00000028H
  001cc	68 a0 00 00 00	 push	 160			; 000000a0H
  001d1	e8 00 00 00 00	 call	 _V_DrawCenteredString
  001d6	83 c4 10	 add	 esp, 16			; 00000010H

; 655  : 				V_DrawCenteredString(BASEVIDWIDTH/2, 50, V_YELLOWMAP, "AND MAY CRASH YOUR");

  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NNGMDKFG@AND?5MAY?5CRASH?5YOUR@
  001de	68 00 00 10 00	 push	 1048576			; 00100000H
  001e3	6a 32		 push	 50			; 00000032H
  001e5	68 a0 00 00 00	 push	 160			; 000000a0H
  001ea	e8 00 00 00 00	 call	 _V_DrawCenteredString
  001ef	83 c4 10	 add	 esp, 16			; 00000010H

; 656  : 				V_DrawCenteredString(BASEVIDWIDTH/2, 60, V_YELLOWMAP, "COMPUTER.");

  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_09KALLHCMF@COMPUTER?4@
  001f7	68 00 00 10 00	 push	 1048576			; 00100000H
  001fc	6a 3c		 push	 60			; 0000003cH
  001fe	68 a0 00 00 00	 push	 160			; 000000a0H
  00203	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00208	83 c4 10	 add	 esp, 16			; 00000010H

; 657  : 				V_DrawCenteredString(BASEVIDWIDTH/2, 80, V_YELLOWMAP, "USE AT OWN RISK.");

  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LECHLICB@USE?5AT?5OWN?5RISK?4@
  00210	68 00 00 10 00	 push	 1048576			; 00100000H
  00215	6a 50		 push	 80			; 00000050H
  00217	68 a0 00 00 00	 push	 160			; 000000a0H
  0021c	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00221	83 c4 10	 add	 esp, 16			; 00000010H

; 658  : 
; 659  : 				I_UpdateNoVsync();

  00224	e8 00 00 00 00	 call	 _I_UpdateNoVsync
  00229	90		 npad	 1
$LN12@WalkBSPNod:

; 660  : 			}
; 661  : 		}
; 662  : 		M_ClearBox(bbox);

  0022a	8b 45 14	 mov	 eax, DWORD PTR _bbox$[ebp]
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 _M_ClearBox
  00233	83 c4 04	 add	 esp, 4

; 663  : 		poly = extrasubsectors[bspnum&~NF_SUBSECTOR].planepoly;

  00236	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  00239	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  00244	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00247	89 55 0c	 mov	 DWORD PTR _poly$[ebp], edx

; 664  : 
; 665  : 		for (i = 0, pt = poly->pts; i < poly->numpts; i++,pt++)

  0024a	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00251	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  00254	83 c0 04	 add	 eax, 4
  00257	89 45 dc	 mov	 DWORD PTR _pt$[ebp], eax
  0025a	eb 12		 jmp	 SHORT $LN4@WalkBSPNod
$LN2@WalkBSPNod:
  0025c	8b 45 d8	 mov	 eax, DWORD PTR _i$[ebp]
  0025f	83 c0 01	 add	 eax, 1
  00262	89 45 d8	 mov	 DWORD PTR _i$[ebp], eax
  00265	8b 4d dc	 mov	 ecx, DWORD PTR _pt$[ebp]
  00268	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0026b	89 4d dc	 mov	 DWORD PTR _pt$[ebp], ecx
$LN4@WalkBSPNod:
  0026e	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  00271	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  00274	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00276	7d 37		 jge	 SHORT $LN3@WalkBSPNod

; 666  : 			M_AddToBox(bbox, FLOAT_TO_FIXED(pt->x), FLOAT_TO_FIXED(pt->y));

  00278	8b 45 dc	 mov	 eax, DWORD PTR _pt$[ebp]
  0027b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00280	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  00288	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0028c	51		 push	 ecx
  0028d	8b 55 dc	 mov	 edx, DWORD PTR _pt$[ebp]
  00290	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00294	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@47800000
  0029c	f3 0f 2c c0	 cvttss2si eax, xmm0
  002a0	50		 push	 eax
  002a1	8b 4d 14	 mov	 ecx, DWORD PTR _bbox$[ebp]
  002a4	51		 push	 ecx
  002a5	e8 00 00 00 00	 call	 _M_AddToBox
  002aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ad	eb ad		 jmp	 SHORT $LN2@WalkBSPNod
$LN3@WalkBSPNod:

; 667  : 
; 668  : 		return;

  002af	e9 8a 01 00 00	 jmp	 $LN16@WalkBSPNod
$LN5@WalkBSPNod:

; 669  : 	}
; 670  : 
; 671  : 	bsp = &nodes[bspnum];

  002b4	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  002b8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  002be	89 45 f8	 mov	 DWORD PTR _bsp$[ebp], eax

; 672  : 	SearchDivline(bsp, &fdivline);

  002c1	8d 45 e0	 lea	 eax, DWORD PTR _fdivline$[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d f8	 mov	 ecx, DWORD PTR _bsp$[ebp]
  002c8	51		 push	 ecx
  002c9	e8 00 00 00 00	 call	 _SearchDivline
  002ce	83 c4 08	 add	 esp, 8

; 673  : 	SplitPoly(&fdivline, poly, &frontpoly, &backpoly);

  002d1	8d 45 f4	 lea	 eax, DWORD PTR _backpoly$[ebp]
  002d4	50		 push	 eax
  002d5	8d 4d f0	 lea	 ecx, DWORD PTR _frontpoly$[ebp]
  002d8	51		 push	 ecx
  002d9	8b 55 0c	 mov	 edx, DWORD PTR _poly$[ebp]
  002dc	52		 push	 edx
  002dd	8d 45 e0	 lea	 eax, DWORD PTR _fdivline$[ebp]
  002e0	50		 push	 eax
  002e1	e8 00 00 00 00	 call	 _SplitPoly
  002e6	83 c4 10	 add	 esp, 16			; 00000010H

; 674  : 	poly = NULL;

  002e9	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _poly$[ebp], 0

; 675  : 
; 676  : 	//debug
; 677  : 	if (!backpoly)

  002f0	83 7d f4 00	 cmp	 DWORD PTR _backpoly$[ebp], 0
  002f4	75 0d		 jne	 SHORT $LN13@WalkBSPNod

; 678  : 		nobackpoly++;

  002f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _nobackpoly
  002fb	83 c0 01	 add	 eax, 1
  002fe	a3 00 00 00 00	 mov	 DWORD PTR _nobackpoly, eax
$LN13@WalkBSPNod:

; 679  : 
; 680  : 	// Recursively divide front space.
; 681  : 	if (frontpoly)

  00303	83 7d f0 00	 cmp	 DWORD PTR _frontpoly$[ebp], 0
  00307	74 5e		 je	 SHORT $LN14@WalkBSPNod

; 682  : 	{
; 683  : 		WalkBSPNode(bsp->children[0], frontpoly, &bsp->children[0],bsp->bbox[0]);

  00309	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0030e	6b c8 00	 imul	 ecx, eax, 0
  00311	8b 55 f8	 mov	 edx, DWORD PTR _bsp$[ebp]
  00314	8d 44 0a 10	 lea	 eax, DWORD PTR [edx+ecx+16]
  00318	50		 push	 eax
  00319	b9 02 00 00 00	 mov	 ecx, 2
  0031e	6b d1 00	 imul	 edx, ecx, 0
  00321	8b 45 f8	 mov	 eax, DWORD PTR _bsp$[ebp]
  00324	8d 4c 10 30	 lea	 ecx, DWORD PTR [eax+edx+48]
  00328	51		 push	 ecx
  00329	8b 55 f0	 mov	 edx, DWORD PTR _frontpoly$[ebp]
  0032c	52		 push	 edx
  0032d	b8 02 00 00 00	 mov	 eax, 2
  00332	6b c8 00	 imul	 ecx, eax, 0
  00335	8b 55 f8	 mov	 edx, DWORD PTR _bsp$[ebp]
  00338	0f b7 44 0a 30	 movzx	 eax, WORD PTR [edx+ecx+48]
  0033d	50		 push	 eax
  0033e	e8 00 00 00 00	 call	 _WalkBSPNode
  00343	83 c4 10	 add	 esp, 16			; 00000010H

; 684  : 
; 685  : 		// copy child bbox
; 686  : 		M_Memcpy(bbox, bsp->bbox[0], 4*sizeof (fixed_t));

  00346	6a 10		 push	 16			; 00000010H
  00348	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0034d	6b c8 00	 imul	 ecx, eax, 0
  00350	8b 55 f8	 mov	 edx, DWORD PTR _bsp$[ebp]
  00353	8d 44 0a 10	 lea	 eax, DWORD PTR [edx+ecx+16]
  00357	50		 push	 eax
  00358	8b 4d 14	 mov	 ecx, DWORD PTR _bbox$[ebp]
  0035b	51		 push	 ecx
  0035c	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00362	83 c4 0c	 add	 esp, 12			; 0000000cH

; 687  : 	}

  00365	eb 0d		 jmp	 SHORT $LN15@WalkBSPNod
$LN14@WalkBSPNod:

; 688  : 	else
; 689  : 		I_Error("WalkBSPNode: no front poly?");

  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MKEKOOIO@WalkBSPNode?3?5no?5front?5poly?$DP@
  0036c	e8 00 00 00 00	 call	 _I_Error
  00371	83 c4 04	 add	 esp, 4
$LN15@WalkBSPNod:

; 690  : 
; 691  : 	// Recursively divide back space.
; 692  : 	if (backpoly)

  00374	83 7d f4 00	 cmp	 DWORD PTR _backpoly$[ebp], 0
  00378	0f 84 c0 00 00
	00		 je	 $LN16@WalkBSPNod

; 693  : 	{
; 694  : 		// Correct back bbox to include floor/ceiling convex polygon
; 695  : 		WalkBSPNode(bsp->children[1], backpoly, &bsp->children[1],

  0037e	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00383	c1 e0 00	 shl	 eax, 0
  00386	8b 4d f8	 mov	 ecx, DWORD PTR _bsp$[ebp]
  00389	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  0038d	52		 push	 edx
  0038e	b8 02 00 00 00	 mov	 eax, 2
  00393	c1 e0 00	 shl	 eax, 0
  00396	8b 4d f8	 mov	 ecx, DWORD PTR _bsp$[ebp]
  00399	8d 54 01 30	 lea	 edx, DWORD PTR [ecx+eax+48]
  0039d	52		 push	 edx
  0039e	8b 45 f4	 mov	 eax, DWORD PTR _backpoly$[ebp]
  003a1	50		 push	 eax
  003a2	b9 02 00 00 00	 mov	 ecx, 2
  003a7	c1 e1 00	 shl	 ecx, 0
  003aa	8b 55 f8	 mov	 edx, DWORD PTR _bsp$[ebp]
  003ad	0f b7 44 0a 30	 movzx	 eax, WORD PTR [edx+ecx+48]
  003b2	50		 push	 eax
  003b3	e8 00 00 00 00	 call	 _WalkBSPNode
  003b8	83 c4 10	 add	 esp, 16			; 00000010H

; 696  : 			bsp->bbox[1]);
; 697  : 
; 698  : 		// enlarge bbox with seconde child
; 699  : 		M_AddToBox(bbox, bsp->bbox[1][BOXLEFT  ],

  003bb	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  003c0	c1 e0 00	 shl	 eax, 0
  003c3	8b 4d f8	 mov	 ecx, DWORD PTR _bsp$[ebp]
  003c6	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  003ca	b8 04 00 00 00	 mov	 eax, 4
  003cf	6b c8 00	 imul	 ecx, eax, 0
  003d2	8b 14 0a	 mov	 edx, DWORD PTR [edx+ecx]
  003d5	52		 push	 edx
  003d6	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  003db	c1 e0 00	 shl	 eax, 0
  003de	8b 4d f8	 mov	 ecx, DWORD PTR _bsp$[ebp]
  003e1	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  003e5	b8 04 00 00 00	 mov	 eax, 4
  003ea	d1 e0		 shl	 eax, 1
  003ec	8b 0c 02	 mov	 ecx, DWORD PTR [edx+eax]
  003ef	51		 push	 ecx
  003f0	8b 55 14	 mov	 edx, DWORD PTR _bbox$[ebp]
  003f3	52		 push	 edx
  003f4	e8 00 00 00 00	 call	 _M_AddToBox
  003f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 700  : 			bsp->bbox[1][BOXTOP   ]);
; 701  : 		M_AddToBox(bbox, bsp->bbox[1][BOXRIGHT ],

  003fc	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00401	c1 e0 00	 shl	 eax, 0
  00404	8b 4d f8	 mov	 ecx, DWORD PTR _bsp$[ebp]
  00407	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  0040b	b8 04 00 00 00	 mov	 eax, 4
  00410	c1 e0 00	 shl	 eax, 0
  00413	8b 0c 02	 mov	 ecx, DWORD PTR [edx+eax]
  00416	51		 push	 ecx
  00417	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0041c	c1 e2 00	 shl	 edx, 0
  0041f	8b 45 f8	 mov	 eax, DWORD PTR _bsp$[ebp]
  00422	8d 4c 10 10	 lea	 ecx, DWORD PTR [eax+edx+16]
  00426	ba 04 00 00 00	 mov	 edx, 4
  0042b	6b c2 03	 imul	 eax, edx, 3
  0042e	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  00431	51		 push	 ecx
  00432	8b 55 14	 mov	 edx, DWORD PTR _bbox$[ebp]
  00435	52		 push	 edx
  00436	e8 00 00 00 00	 call	 _M_AddToBox
  0043b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@WalkBSPNod:

; 702  : 			bsp->bbox[1][BOXBOTTOM]);
; 703  : 	}
; 704  : }

  0043e	5f		 pop	 edi
  0043f	5e		 pop	 esi
  00440	5b		 pop	 ebx
  00441	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00444	33 cd		 xor	 ecx, ebp
  00446	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0044b	8b e5		 mov	 esp, ebp
  0044d	5d		 pop	 ebp
  0044e	c3		 ret	 0
_WalkBSPNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _SearchDivline
_TEXT	SEGMENT
_bsp$ = 8						; size = 4
_divline$ = 12						; size = 4
_SearchDivline PROC					; COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 586  : #if 0 // MAR - If you don't use the same partition line that the BSP uses, the front/back polys won't match the subsectors in the BSP!
; 587  : #endif
; 588  : 	divline->x = FIXED_TO_FLOAT(bsp->x);

  00009	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  0000c	f3 0f 2a 00	 cvtsi2ss xmm0, DWORD PTR [eax]
  00010	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _divline$[ebp]
  0001b	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 589  : 	divline->y = FIXED_TO_FLOAT(bsp->y);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  00022	f3 0f 2a 40 04	 cvtsi2ss xmm0, DWORD PTR [eax+4]
  00027	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _divline$[ebp]
  00032	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 590  : 	divline->dx = FIXED_TO_FLOAT(bsp->dx);

  00037	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  0003a	f3 0f 2a 40 08	 cvtsi2ss xmm0, DWORD PTR [eax+8]
  0003f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _divline$[ebp]
  0004a	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 591  : 	divline->dy = FIXED_TO_FLOAT(bsp->dy);

  0004f	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  00052	f3 0f 2a 40 0c	 cvtsi2ss xmm0, DWORD PTR [eax+12]
  00057	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _divline$[ebp]
  00062	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0

; 592  : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_SearchDivline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_SubsecPoly
_TEXT	SEGMENT
_lseg$ = -12						; size = 4
_sub$ = -8						; size = 4
_count$ = -4						; size = 2
_num$ = 8						; size = 4
_poly$ = 12						; size = 4
_HWR_SubsecPoly PROC					; COMDAT

; 562  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 563  : 	INT16 count;
; 564  : 	subsector_t *sub;
; 565  : 	seg_t *lseg;
; 566  : 
; 567  : 	sscount++;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _sscount
  0000e	83 c0 01	 add	 eax, 1
  00011	a3 00 00 00 00	 mov	 DWORD PTR _sscount, eax

; 568  : 
; 569  : 	sub = &subsectors[num];

  00016	6b 45 08 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  0001a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _subsectors
  00020	89 45 f8	 mov	 DWORD PTR _sub$[ebp], eax

; 570  : 	count = sub->numlines;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _sub$[ebp]
  00026	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  0002a	66 89 4d fc	 mov	 WORD PTR _count$[ebp], cx

; 571  : 	lseg = &segs[sub->firstline];

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _sub$[ebp]
  00031	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00035	6b d1 3c	 imul	 edx, ecx, 60
  00038	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  0003e	89 55 f4	 mov	 DWORD PTR _lseg$[ebp], edx

; 572  : 
; 573  : 	if (poly)

  00041	83 7d 0c 00	 cmp	 DWORD PTR _poly$[ebp], 0
  00045	74 34		 je	 SHORT $LN2@HWR_Subsec

; 574  : 	{
; 575  : 		poly = CutOutSubsecPoly (lseg,count,poly);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  0004a	50		 push	 eax
  0004b	0f bf 4d fc	 movsx	 ecx, WORD PTR _count$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 f4	 mov	 edx, DWORD PTR _lseg$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _CutOutSubsecPoly
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	89 45 0c	 mov	 DWORD PTR _poly$[ebp], eax

; 576  : 		totalsubsecpolys++;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _totalsubsecpolys
  00064	83 c0 01	 add	 eax, 1
  00067	a3 00 00 00 00	 mov	 DWORD PTR _totalsubsecpolys, eax

; 577  : 		//extra data for this subsector
; 578  : 		extrasubsectors[num].planepoly = poly;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _extrasubsectors
  00075	8b 55 0c	 mov	 edx, DWORD PTR _poly$[ebp]
  00078	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$LN2@HWR_Subsec:

; 579  : 	}
; 580  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_HWR_SubsecPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _CutOutSubsecPoly
_TEXT	SEGMENT
tv67 = -172						; size = 4
tv75 = -172						; size = 4
tv86 = -172						; size = 4
tv129 = -172						; size = 4
tv140 = -172						; size = 4
_line$1 = -104						; size = 4
_temppoly$ = -100					; size = 4
_cutseg$ = -96						; size = 16
_fracs$ = -80						; size = 4
_p2$ = -76						; size = 12
_p1$ = -64						; size = 12
_ve$ = -52						; size = 12
_vs$ = -40						; size = 12
_pe$ = -28						; size = 4
_ps$ = -24						; size = 4
_nump$ = -20						; size = 4
_pv$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lseg$ = 8						; size = 4
_count$ = 12						; size = 4
_poly$ = 16						; size = 4
_CutOutSubsecPoly PROC					; COMDAT

; 445  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 446  : 	INT32 i, j;
; 447  : 
; 448  : 	polyvertex_t *pv;
; 449  : 
; 450  : 	INT32 nump = 0, ps, pe;

  00016	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nump$[ebp], 0

; 451  : 	polyvertex_t vs = {0, 0, 0}, ve = {0, 0, 0},

  0001d	0f 57 c0	 xorps	 xmm0, xmm0
  00020	f3 0f 11 45 d8	 movss	 DWORD PTR _vs$[ebp], xmm0
  00025	0f 57 c0	 xorps	 xmm0, xmm0
  00028	f3 0f 11 45 dc	 movss	 DWORD PTR _vs$[ebp+4], xmm0
  0002d	0f 57 c0	 xorps	 xmm0, xmm0
  00030	f3 0f 11 45 e0	 movss	 DWORD PTR _vs$[ebp+8], xmm0
  00035	0f 57 c0	 xorps	 xmm0, xmm0
  00038	f3 0f 11 45 cc	 movss	 DWORD PTR _ve$[ebp], xmm0
  0003d	0f 57 c0	 xorps	 xmm0, xmm0
  00040	f3 0f 11 45 d0	 movss	 DWORD PTR _ve$[ebp+4], xmm0
  00045	0f 57 c0	 xorps	 xmm0, xmm0
  00048	f3 0f 11 45 d4	 movss	 DWORD PTR _ve$[ebp+8], xmm0

; 452  : 		p1 = {0, 0, 0}, p2 = {0, 0, 0};

  0004d	0f 57 c0	 xorps	 xmm0, xmm0
  00050	f3 0f 11 45 c0	 movss	 DWORD PTR _p1$[ebp], xmm0
  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	f3 0f 11 45 c4	 movss	 DWORD PTR _p1$[ebp+4], xmm0
  0005d	0f 57 c0	 xorps	 xmm0, xmm0
  00060	f3 0f 11 45 c8	 movss	 DWORD PTR _p1$[ebp+8], xmm0
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 45 b4	 movss	 DWORD PTR _p2$[ebp], xmm0
  0006d	0f 57 c0	 xorps	 xmm0, xmm0
  00070	f3 0f 11 45 b8	 movss	 DWORD PTR _p2$[ebp+4], xmm0
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 45 bc	 movss	 DWORD PTR _p2$[ebp+8], xmm0

; 453  : 	float fracs = 0.0f;

  0007d	0f 57 c0	 xorps	 xmm0, xmm0
  00080	f3 0f 11 45 b0	 movss	 DWORD PTR _fracs$[ebp], xmm0

; 454  : 
; 455  : 	fdivline_t cutseg; // x, y, dx, dy as start of node_t struct
; 456  : 
; 457  : 	poly_t *temppoly;
; 458  : 
; 459  : 	// for each seg of the subsector
; 460  : 	for (; count--; lseg++)

  00085	eb 09		 jmp	 SHORT $LN4@CutOutSubs
$LN2@CutOutSubs:
  00087	8b 45 08	 mov	 eax, DWORD PTR _lseg$[ebp]
  0008a	83 c0 3c	 add	 eax, 60			; 0000003cH
  0008d	89 45 08	 mov	 DWORD PTR _lseg$[ebp], eax
$LN4@CutOutSubs:
  00090	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  00093	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  00099	8b 4d 0c	 mov	 ecx, DWORD PTR _count$[ebp]
  0009c	83 e9 01	 sub	 ecx, 1
  0009f	89 4d 0c	 mov	 DWORD PTR _count$[ebp], ecx
  000a2	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  000a9	0f 84 46 03 00
	00		 je	 $LN3@CutOutSubs

; 461  : 	{
; 462  : 		//x,y,dx,dy (like a divline)
; 463  : 		line_t *line = lseg->linedef;

  000af	8b 45 08	 mov	 eax, DWORD PTR _lseg$[ebp]
  000b2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b5	89 4d 98	 mov	 DWORD PTR _line$1[ebp], ecx

; 464  : 		p1.x = FIXED_TO_FLOAT(lseg->side ? line->v2->x : line->v1->x);

  000b8	8b 45 08	 mov	 eax, DWORD PTR _lseg$[ebp]
  000bb	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000bf	74 10		 je	 SHORT $LN23@CutOutSubs
  000c1	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  000c4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c7	8b 02		 mov	 eax, DWORD PTR [edx]
  000c9	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  000cf	eb 0d		 jmp	 SHORT $LN24@CutOutSubs
$LN23@CutOutSubs:
  000d1	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  000d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d6	8b 02		 mov	 eax, DWORD PTR [edx]
  000d8	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
$LN24@CutOutSubs:
  000de	f3 0f 2a 85 54
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR tv75[ebp]
  000e6	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  000ee	f3 0f 11 45 c0	 movss	 DWORD PTR _p1$[ebp], xmm0

; 465  : 		p1.y = FIXED_TO_FLOAT(lseg->side ? line->v2->y : line->v1->y);

  000f3	8b 45 08	 mov	 eax, DWORD PTR _lseg$[ebp]
  000f6	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000fa	74 11		 je	 SHORT $LN25@CutOutSubs
  000fc	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  000ff	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00102	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00105	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
  0010b	eb 0e		 jmp	 SHORT $LN26@CutOutSubs
$LN25@CutOutSubs:
  0010d	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  00110	8b 11		 mov	 edx, DWORD PTR [ecx]
  00112	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00115	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
$LN26@CutOutSubs:
  0011b	f3 0f 2a 85 54
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR tv86[ebp]
  00123	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0012b	f3 0f 11 45 c4	 movss	 DWORD PTR _p1$[ebp+4], xmm0

; 466  : 		p2.x = FIXED_TO_FLOAT(lseg->side ? line->v1->x : line->v2->x);

  00130	8b 45 08	 mov	 eax, DWORD PTR _lseg$[ebp]
  00133	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00137	74 0f		 je	 SHORT $LN27@CutOutSubs
  00139	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  0013c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013e	8b 02		 mov	 eax, DWORD PTR [edx]
  00140	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  00146	eb 0e		 jmp	 SHORT $LN28@CutOutSubs
$LN27@CutOutSubs:
  00148	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  0014b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0014e	8b 02		 mov	 eax, DWORD PTR [edx]
  00150	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
$LN28@CutOutSubs:
  00156	f3 0f 2a 85 54
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR tv129[ebp]
  0015e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00166	f3 0f 11 45 b4	 movss	 DWORD PTR _p2$[ebp], xmm0

; 467  : 		p2.y = FIXED_TO_FLOAT(lseg->side ? line->v1->y : line->v2->y);

  0016b	8b 45 08	 mov	 eax, DWORD PTR _lseg$[ebp]
  0016e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00172	74 10		 je	 SHORT $LN29@CutOutSubs
  00174	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  00177	8b 11		 mov	 edx, DWORD PTR [ecx]
  00179	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0017c	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv140[ebp], eax
  00182	eb 0f		 jmp	 SHORT $LN30@CutOutSubs
$LN29@CutOutSubs:
  00184	8b 4d 98	 mov	 ecx, DWORD PTR _line$1[ebp]
  00187	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0018a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018d	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv140[ebp], eax
$LN30@CutOutSubs:
  00193	f3 0f 2a 85 54
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR tv140[ebp]
  0019b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001a3	f3 0f 11 45 b8	 movss	 DWORD PTR _p2$[ebp+4], xmm0

; 468  : 
; 469  : 		cutseg.x = p1.x;

  001a8	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _p1$[ebp]
  001ad	f3 0f 11 45 a0	 movss	 DWORD PTR _cutseg$[ebp], xmm0

; 470  : 		cutseg.y = p1.y;

  001b2	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  001b7	f3 0f 11 45 a4	 movss	 DWORD PTR _cutseg$[ebp+4], xmm0

; 471  : 		cutseg.dx = p2.x - p1.x;

  001bc	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _p2$[ebp]
  001c1	f3 0f 5c 45 c0	 subss	 xmm0, DWORD PTR _p1$[ebp]
  001c6	f3 0f 11 45 a8	 movss	 DWORD PTR _cutseg$[ebp+8], xmm0

; 472  : 		cutseg.dy = p2.y - p1.y;

  001cb	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _p2$[ebp+4]
  001d0	f3 0f 5c 45 c4	 subss	 xmm0, DWORD PTR _p1$[ebp+4]
  001d5	f3 0f 11 45 ac	 movss	 DWORD PTR _cutseg$[ebp+12], xmm0

; 473  : 
; 474  : 		// see if it cuts the convex poly
; 475  : 		ps = -1;

  001da	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _ps$[ebp], -1

; 476  : 		pe = -1;

  001e1	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _pe$[ebp], -1

; 477  : 		for (i = 0; i < poly->numpts; i++)

  001e8	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001ef	eb 09		 jmp	 SHORT $LN7@CutOutSubs
$LN5@CutOutSubs:
  001f1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001f4	83 c0 01	 add	 eax, 1
  001f7	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@CutOutSubs:
  001fa	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  001fd	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00200	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00202	0f 8d 18 01 00
	00		 jge	 $LN6@CutOutSubs

; 478  : 		{
; 479  : 			j = i + 1;

  00208	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0020b	83 c0 01	 add	 eax, 1
  0020e	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax

; 480  : 			if (j == poly->numpts)

  00211	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  00214	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00217	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00219	75 07		 jne	 SHORT $LN11@CutOutSubs

; 481  : 				j = 0;

  0021b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN11@CutOutSubs:

; 482  : 
; 483  : 			pv = fracdivline(&cutseg, &poly->pts[i], &poly->pts[j]);

  00222	6b 45 f4 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  00226	8b 4d 10	 mov	 ecx, DWORD PTR _poly$[ebp]
  00229	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0022d	52		 push	 edx
  0022e	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00232	8b 4d 10	 mov	 ecx, DWORD PTR _poly$[ebp]
  00235	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00239	52		 push	 edx
  0023a	8d 45 a0	 lea	 eax, DWORD PTR _cutseg$[ebp]
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 _fracdivline
  00243	83 c4 0c	 add	 esp, 12			; 0000000cH
  00246	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 484  : 
; 485  : 			if (pv)

  00249	83 7d f0 00	 cmp	 DWORD PTR _pv$[ebp], 0
  0024d	0f 84 c8 00 00
	00		 je	 $LN14@CutOutSubs

; 486  : 			{
; 487  : 				if (ps < 0)

  00253	83 7d e8 00	 cmp	 DWORD PTR _ps$[ebp], 0
  00257	7d 2c		 jge	 SHORT $LN13@CutOutSubs

; 488  : 				{
; 489  : 					ps = i;

  00259	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0025c	89 45 e8	 mov	 DWORD PTR _ps$[ebp], eax

; 490  : 					vs = *pv;

  0025f	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  00262	8b 08		 mov	 ecx, DWORD PTR [eax]
  00264	89 4d d8	 mov	 DWORD PTR _vs$[ebp], ecx
  00267	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0026a	89 55 dc	 mov	 DWORD PTR _vs$[ebp+4], edx
  0026d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00270	89 45 e0	 mov	 DWORD PTR _vs$[ebp+8], eax

; 491  : 					fracs = bspfrac;

  00273	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _bspfrac
  0027b	f3 0f 11 45 b0	 movss	 DWORD PTR _fracs$[ebp], xmm0

; 492  : 				}

  00280	e9 96 00 00 00	 jmp	 $LN14@CutOutSubs
$LN13@CutOutSubs:

; 493  : 				else
; 494  : 				{
; 495  : 					//frac 1 on previous segment,
; 496  : 					//     0 on the next,
; 497  : 					//the split line goes through one of the convex poly
; 498  : 					// vertices, happens quite often since the convex
; 499  : 					// poly is already adjacent to the subsector segs
; 500  : 					// on most borders
; 501  : 					if (SameVertice(pv, &vs))

  00285	8d 45 d8	 lea	 eax, DWORD PTR _vs$[ebp]
  00288	50		 push	 eax
  00289	8b 4d f0	 mov	 ecx, DWORD PTR _pv$[ebp]
  0028c	51		 push	 ecx
  0028d	e8 00 00 00 00	 call	 _SameVertice
  00292	83 c4 08	 add	 esp, 8
  00295	85 c0		 test	 eax, eax
  00297	74 05		 je	 SHORT $LN15@CutOutSubs

; 502  : 						continue;

  00299	e9 53 ff ff ff	 jmp	 $LN5@CutOutSubs
$LN15@CutOutSubs:

; 503  : 
; 504  : 					if (fracs <= bspfrac)

  0029e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _bspfrac
  002a6	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _fracs$[ebp]
  002aa	72 35		 jb	 SHORT $LN16@CutOutSubs

; 505  : 					{
; 506  : 						nump = 2 + poly->numpts - (i-ps);

  002ac	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  002af	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b1	83 c1 02	 add	 ecx, 2
  002b4	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002b7	2b 55 e8	 sub	 edx, DWORD PTR _ps$[ebp]
  002ba	2b ca		 sub	 ecx, edx
  002bc	89 4d ec	 mov	 DWORD PTR _nump$[ebp], ecx

; 507  : 						pe = ps;

  002bf	8b 45 e8	 mov	 eax, DWORD PTR _ps$[ebp]
  002c2	89 45 e4	 mov	 DWORD PTR _pe$[ebp], eax

; 508  : 						ps = i;

  002c5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002c8	89 45 e8	 mov	 DWORD PTR _ps$[ebp], eax

; 509  : 						ve = *pv;

  002cb	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  002ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d0	89 4d cc	 mov	 DWORD PTR _ve$[ebp], ecx
  002d3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002d6	89 55 d0	 mov	 DWORD PTR _ve$[ebp+4], edx
  002d9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002dc	89 45 d4	 mov	 DWORD PTR _ve$[ebp+8], eax

; 510  : 					}

  002df	eb 38		 jmp	 SHORT $LN17@CutOutSubs
$LN16@CutOutSubs:

; 511  : 					else
; 512  : 					{
; 513  : 						nump = 2 + (i-ps);

  002e1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002e4	2b 45 e8	 sub	 eax, DWORD PTR _ps$[ebp]
  002e7	83 c0 02	 add	 eax, 2
  002ea	89 45 ec	 mov	 DWORD PTR _nump$[ebp], eax

; 514  : 						pe = i;

  002ed	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002f0	89 45 e4	 mov	 DWORD PTR _pe$[ebp], eax

; 515  : 						ve = vs;

  002f3	8b 45 d8	 mov	 eax, DWORD PTR _vs$[ebp]
  002f6	89 45 cc	 mov	 DWORD PTR _ve$[ebp], eax
  002f9	8b 4d dc	 mov	 ecx, DWORD PTR _vs$[ebp+4]
  002fc	89 4d d0	 mov	 DWORD PTR _ve$[ebp+4], ecx
  002ff	8b 55 e0	 mov	 edx, DWORD PTR _vs$[ebp+8]
  00302	89 55 d4	 mov	 DWORD PTR _ve$[ebp+8], edx

; 516  : 						vs = *pv;

  00305	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  00308	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030a	89 4d d8	 mov	 DWORD PTR _vs$[ebp], ecx
  0030d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00310	89 55 dc	 mov	 DWORD PTR _vs$[ebp+4], edx
  00313	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00316	89 45 e0	 mov	 DWORD PTR _vs$[ebp+8], eax
$LN17@CutOutSubs:

; 517  : 					}
; 518  : 					//found 2nd point
; 519  : 					break;

  00319	eb 05		 jmp	 SHORT $LN6@CutOutSubs
$LN14@CutOutSubs:

; 520  : 				}
; 521  : 			}
; 522  : 		}

  0031b	e9 d1 fe ff ff	 jmp	 $LN5@CutOutSubs
$LN6@CutOutSubs:

; 523  : 
; 524  : 		// there was a split
; 525  : 		if (ps >= 0)

  00320	83 7d e8 00	 cmp	 DWORD PTR _ps$[ebp], 0
  00324	0f 8c c6 00 00
	00		 jl	 $LN20@CutOutSubs

; 526  : 		{
; 527  : 			//need 2 points
; 528  : 			if (pe >= 0)

  0032a	83 7d e4 00	 cmp	 DWORD PTR _pe$[ebp], 0
  0032e	0f 8c af 00 00
	00		 jl	 $LN19@CutOutSubs

; 529  : 			{
; 530  : 				// generate FRONT poly
; 531  : 				temppoly = HWR_AllocPoly(nump);

  00334	8b 45 ec	 mov	 eax, DWORD PTR _nump$[ebp]
  00337	50		 push	 eax
  00338	e8 00 00 00 00	 call	 _HWR_AllocPoly
  0033d	83 c4 04	 add	 esp, 4
  00340	89 45 9c	 mov	 DWORD PTR _temppoly$[ebp], eax

; 532  : 				pv = temppoly->pts;

  00343	8b 45 9c	 mov	 eax, DWORD PTR _temppoly$[ebp]
  00346	83 c0 04	 add	 eax, 4
  00349	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 533  : 				*pv++ = vs;

  0034c	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  0034f	8b 4d d8	 mov	 ecx, DWORD PTR _vs$[ebp]
  00352	89 08		 mov	 DWORD PTR [eax], ecx
  00354	8b 55 dc	 mov	 edx, DWORD PTR _vs$[ebp+4]
  00357	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0035a	8b 4d e0	 mov	 ecx, DWORD PTR _vs$[ebp+8]
  0035d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00360	8b 55 f0	 mov	 edx, DWORD PTR _pv$[ebp]
  00363	83 c2 0c	 add	 edx, 12			; 0000000cH
  00366	89 55 f0	 mov	 DWORD PTR _pv$[ebp], edx

; 534  : 				*pv++ = ve;

  00369	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  0036c	8b 4d cc	 mov	 ecx, DWORD PTR _ve$[ebp]
  0036f	89 08		 mov	 DWORD PTR [eax], ecx
  00371	8b 55 d0	 mov	 edx, DWORD PTR _ve$[ebp+4]
  00374	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00377	8b 4d d4	 mov	 ecx, DWORD PTR _ve$[ebp+8]
  0037a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0037d	8b 55 f0	 mov	 edx, DWORD PTR _pv$[ebp]
  00380	83 c2 0c	 add	 edx, 12			; 0000000cH
  00383	89 55 f0	 mov	 DWORD PTR _pv$[ebp], edx
$LN10@CutOutSubs:

; 535  : 				do
; 536  : 				{
; 537  : 					if (++ps == poly->numpts)

  00386	8b 45 e8	 mov	 eax, DWORD PTR _ps$[ebp]
  00389	83 c0 01	 add	 eax, 1
  0038c	89 45 e8	 mov	 DWORD PTR _ps$[ebp], eax
  0038f	8b 4d 10	 mov	 ecx, DWORD PTR _poly$[ebp]
  00392	8b 55 e8	 mov	 edx, DWORD PTR _ps$[ebp]
  00395	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00397	75 07		 jne	 SHORT $LN21@CutOutSubs

; 538  : 						ps = 0;

  00399	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ps$[ebp], 0
$LN21@CutOutSubs:

; 539  : 					*pv++ = poly->pts[ps];

  003a0	6b 45 e8 0c	 imul	 eax, DWORD PTR _ps$[ebp], 12
  003a4	8b 4d 10	 mov	 ecx, DWORD PTR _poly$[ebp]
  003a7	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003ab	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  003ae	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003b0	89 08		 mov	 DWORD PTR [eax], ecx
  003b2	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  003b5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  003b8	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  003bb	89 50 08	 mov	 DWORD PTR [eax+8], edx
  003be	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  003c1	83 c0 0c	 add	 eax, 12			; 0000000cH
  003c4	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 540  : 				} while (ps != pe);

  003c7	8b 45 e8	 mov	 eax, DWORD PTR _ps$[ebp]
  003ca	3b 45 e4	 cmp	 eax, DWORD PTR _pe$[ebp]
  003cd	75 b7		 jne	 SHORT $LN10@CutOutSubs

; 541  : 				HWR_FreePoly(poly);

  003cf	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]
  003d2	50		 push	 eax
  003d3	e8 00 00 00 00	 call	 _HWR_FreePoly
  003d8	83 c4 04	 add	 esp, 4

; 542  : 				poly = temppoly;

  003db	8b 45 9c	 mov	 eax, DWORD PTR _temppoly$[ebp]
  003de	89 45 10	 mov	 DWORD PTR _poly$[ebp], eax

; 543  : 			}

  003e1	eb 0d		 jmp	 SHORT $LN20@CutOutSubs
$LN19@CutOutSubs:

; 544  : 			//hmmm... maybe we should NOT accept this, but this happens
; 545  : 			// only when the cut is not needed it seems (when the cut
; 546  : 			// line is aligned to one of the borders of the poly, and
; 547  : 			// only some times..)
; 548  : 			else
; 549  : 				skipcut++;

  003e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _skipcut
  003e8	83 c0 01	 add	 eax, 1
  003eb	a3 00 00 00 00	 mov	 DWORD PTR _skipcut, eax
$LN20@CutOutSubs:

; 550  : 			//    I_Error("CutOutPoly: only one point for split line (%d %d) %d", ps, pe, debugpos);
; 551  : 		}
; 552  : 	}

  003f0	e9 92 fc ff ff	 jmp	 $LN2@CutOutSubs
$LN3@CutOutSubs:

; 553  : 	return poly;

  003f5	8b 45 10	 mov	 eax, DWORD PTR _poly$[ebp]

; 554  : }

  003f8	5f		 pop	 edi
  003f9	5e		 pop	 esi
  003fa	5b		 pop	 ebx
  003fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fe	33 cd		 xor	 ecx, ebp
  00400	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00405	8b e5		 mov	 esp, ebp
  00407	5d		 pop	 ebp
  00408	c3		 ret	 0
_CutOutSubsecPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _SplitPoly
_TEXT	SEGMENT
_swappoly$1 = -88					; size = 4
_peonline$ = -84					; size = 4
_psonline$ = -80					; size = 4
_frace$ = -76						; size = 4
_fracs$ = -72						; size = 4
_lastpv$ = -68						; size = 12
_ve$ = -56						; size = 12
_vs$ = -44						; size = 12
_nptback$ = -32						; size = 4
_nptfront$ = -28					; size = 4
_pe$ = -24						; size = 4
_ps$ = -20						; size = 4
_pv$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bsp$ = 8						; size = 4
_poly$ = 12						; size = 4
_frontpoly$ = 16					; size = 4
_backpoly$ = 20						; size = 4
_SplitPoly PROC						; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 277  : 	INT32      i,j;
; 278  : 	polyvertex_t *pv;
; 279  : 
; 280  : 	INT32          ps = -1,pe = -1;

  00016	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _ps$[ebp], -1
  0001d	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _pe$[ebp], -1

; 281  : 	INT32          nptfront,nptback;
; 282  : 	polyvertex_t vs = {0,0,0};

  00024	0f 57 c0	 xorps	 xmm0, xmm0
  00027	f3 0f 11 45 d4	 movss	 DWORD PTR _vs$[ebp], xmm0
  0002c	0f 57 c0	 xorps	 xmm0, xmm0
  0002f	f3 0f 11 45 d8	 movss	 DWORD PTR _vs$[ebp+4], xmm0
  00034	0f 57 c0	 xorps	 xmm0, xmm0
  00037	f3 0f 11 45 dc	 movss	 DWORD PTR _vs$[ebp+8], xmm0

; 283  : 	polyvertex_t ve = {0,0,0};

  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	f3 0f 11 45 c8	 movss	 DWORD PTR _ve$[ebp], xmm0
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 45 cc	 movss	 DWORD PTR _ve$[ebp+4], xmm0
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 45 d0	 movss	 DWORD PTR _ve$[ebp+8], xmm0

; 284  : 	polyvertex_t lastpv = {0,0,0};

  00054	0f 57 c0	 xorps	 xmm0, xmm0
  00057	f3 0f 11 45 bc	 movss	 DWORD PTR _lastpv$[ebp], xmm0
  0005c	0f 57 c0	 xorps	 xmm0, xmm0
  0005f	f3 0f 11 45 c0	 movss	 DWORD PTR _lastpv$[ebp+4], xmm0
  00064	0f 57 c0	 xorps	 xmm0, xmm0
  00067	f3 0f 11 45 c4	 movss	 DWORD PTR _lastpv$[ebp+8], xmm0

; 285  : 	float        fracs = 0.0f,frace = 0.0f; //used to tell which poly is on

  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f3 0f 11 45 b8	 movss	 DWORD PTR _fracs$[ebp], xmm0
  00074	0f 57 c0	 xorps	 xmm0, xmm0
  00077	f3 0f 11 45 b4	 movss	 DWORD PTR _frace$[ebp], xmm0

; 286  : 	                                        // the front side of the bsp partition line
; 287  : 	INT32         psonline = 0, peonline = 0;

  0007c	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _psonline$[ebp], 0
  00083	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _peonline$[ebp], 0

; 288  : 
; 289  : 	for (i = 0; i < poly->numpts; i++)

  0008a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00091	eb 09		 jmp	 SHORT $LN4@SplitPoly
$LN2@SplitPoly:
  00093	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@SplitPoly:
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a4	0f 8d 1a 01 00
	00		 jge	 $LN3@SplitPoly

; 290  : 	{
; 291  : 		j = i + 1;

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	83 c0 01	 add	 eax, 1
  000b0	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax

; 292  : 		if (j == poly->numpts) j = 0;

  000b3	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  000b6	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  000b9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000bb	75 07		 jne	 SHORT $LN11@SplitPoly
  000bd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN11@SplitPoly:

; 293  : 
; 294  : 		// start & end points
; 295  : 		pv = fracdivline(bsp, &poly->pts[i], &poly->pts[j]);

  000c4	6b 45 f4 0c	 imul	 eax, DWORD PTR _j$[ebp], 12
  000c8	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  000cb	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000cf	52		 push	 edx
  000d0	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000d4	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  000d7	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000db	52		 push	 edx
  000dc	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _fracdivline
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e8	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 296  : 
; 297  : 		if (pv)

  000eb	83 7d f0 00	 cmp	 DWORD PTR _pv$[ebp], 0
  000ef	0f 84 ca 00 00
	00		 je	 $LN12@SplitPoly

; 298  : 		{
; 299  : 			if (ps < 0)

  000f5	83 7d ec 00	 cmp	 DWORD PTR _ps$[ebp], 0
  000f9	7d 2c		 jge	 SHORT $LN13@SplitPoly

; 300  : 			{
; 301  : 				// first point
; 302  : 				ps = i;

  000fb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000fe	89 45 ec	 mov	 DWORD PTR _ps$[ebp], eax

; 303  : 				vs = *pv;

  00101	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	89 4d d4	 mov	 DWORD PTR _vs$[ebp], ecx
  00109	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010c	89 55 d8	 mov	 DWORD PTR _vs$[ebp+4], edx
  0010f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00112	89 45 dc	 mov	 DWORD PTR _vs$[ebp+8], eax

; 304  : 				fracs = bspfrac;

  00115	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _bspfrac
  0011d	f3 0f 11 45 b8	 movss	 DWORD PTR _fracs$[ebp], xmm0

; 305  : 			}

  00122	e9 84 00 00 00	 jmp	 $LN20@SplitPoly
$LN13@SplitPoly:

; 306  : 			else
; 307  : 			{
; 308  : 				//the partition line traverse a junction between two segments
; 309  : 				// or the two points are so close, they can be considered as one
; 310  : 				// thus, don't accept, since split 2 must be another vertex
; 311  : 				if (SameVertice(pv, &lastpv))

  00127	8d 45 bc	 lea	 eax, DWORD PTR _lastpv$[ebp]
  0012a	50		 push	 eax
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _pv$[ebp]
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 _SameVertice
  00134	83 c4 08	 add	 esp, 8
  00137	85 c0		 test	 eax, eax
  00139	74 24		 je	 SHORT $LN15@SplitPoly

; 312  : 				{
; 313  : 					if (pe < 0)

  0013b	83 7d e8 00	 cmp	 DWORD PTR _pe$[ebp], 0
  0013f	7d 0f		 jge	 SHORT $LN17@SplitPoly

; 314  : 					{
; 315  : 						ps = i;

  00141	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00144	89 45 ec	 mov	 DWORD PTR _ps$[ebp], eax

; 316  : 						psonline = 1;

  00147	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _psonline$[ebp], 1

; 317  : 					}

  0014e	eb 0d		 jmp	 SHORT $LN18@SplitPoly
$LN17@SplitPoly:

; 318  : 					else
; 319  : 					{
; 320  : 						pe = i;

  00150	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00153	89 45 e8	 mov	 DWORD PTR _pe$[ebp], eax

; 321  : 						peonline = 1;

  00156	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _peonline$[ebp], 1
$LN18@SplitPoly:

; 322  : 					}
; 323  : 				}

  0015d	eb 4c		 jmp	 SHORT $LN20@SplitPoly
$LN15@SplitPoly:

; 324  : 				else
; 325  : 				{
; 326  : 					if (pe < 0)

  0015f	83 7d e8 00	 cmp	 DWORD PTR _pe$[ebp], 0
  00163	7d 29		 jge	 SHORT $LN19@SplitPoly

; 327  : 					{
; 328  : 						pe = i;

  00165	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00168	89 45 e8	 mov	 DWORD PTR _pe$[ebp], eax

; 329  : 						ve = *pv;

  0016b	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  0016e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00170	89 4d c8	 mov	 DWORD PTR _ve$[ebp], ecx
  00173	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00176	89 55 cc	 mov	 DWORD PTR _ve$[ebp+4], edx
  00179	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0017c	89 45 d0	 mov	 DWORD PTR _ve$[ebp+8], eax

; 330  : 						frace = bspfrac;

  0017f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR _bspfrac
  00187	f3 0f 11 45 b4	 movss	 DWORD PTR _frace$[ebp], xmm0

; 331  : 					}

  0018c	eb 1d		 jmp	 SHORT $LN20@SplitPoly
$LN19@SplitPoly:

; 332  : 					else
; 333  : 					{
; 334  : 					// a frac, not same vertice as last one
; 335  : 					// we already got pt2 so pt 2 is not on the line,
; 336  : 					// so we probably got back to the start point
; 337  : 					// which is on the line
; 338  : 						if (SameVertice(pv, &vs))

  0018e	8d 45 d4	 lea	 eax, DWORD PTR _vs$[ebp]
  00191	50		 push	 eax
  00192	8b 4d f0	 mov	 ecx, DWORD PTR _pv$[ebp]
  00195	51		 push	 ecx
  00196	e8 00 00 00 00	 call	 _SameVertice
  0019b	83 c4 08	 add	 esp, 8
  0019e	85 c0		 test	 eax, eax
  001a0	74 07		 je	 SHORT $LN21@SplitPoly

; 339  : 							psonline = 1;

  001a2	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _psonline$[ebp], 1
$LN21@SplitPoly:

; 340  : 						break;

  001a9	eb 19		 jmp	 SHORT $LN3@SplitPoly
$LN20@SplitPoly:

; 341  : 					}
; 342  : 				}
; 343  : 			}
; 344  : 
; 345  : 			// remember last point intercept to detect identical points
; 346  : 			lastpv = *pv;

  001ab	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  001ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b0	89 4d bc	 mov	 DWORD PTR _lastpv$[ebp], ecx
  001b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b6	89 55 c0	 mov	 DWORD PTR _lastpv$[ebp+4], edx
  001b9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001bc	89 45 c4	 mov	 DWORD PTR _lastpv$[ebp+8], eax
$LN12@SplitPoly:

; 347  : 		}
; 348  : 	}

  001bf	e9 cf fe ff ff	 jmp	 $LN2@SplitPoly
$LN3@SplitPoly:

; 349  : 
; 350  : 	// no split: the partition line is either parallel and
; 351  : 	// aligned with one of the poly segments, or the line is totally
; 352  : 	// out of the polygon and doesn't traverse it (happens if the bsp
; 353  : 	// is fooled by some trick where the sidedefs don't point to
; 354  : 	// the right sectors)
; 355  : 	if (ps < 0)

  001c4	83 7d ec 00	 cmp	 DWORD PTR _ps$[ebp], 0
  001c8	7d 16		 jge	 SHORT $LN22@SplitPoly

; 356  : 	{
; 357  : 		//I_Error("SplitPoly: did not split polygon (%d %d)\n"
; 358  : 		//        "debugpos %d",ps,pe,debugpos);
; 359  : 
; 360  : 		// this eventually happens with 'broken' BSP's that accept
; 361  : 		// linedefs where each side point the same sector, that is:
; 362  : 		// the deep water effect with the original Doom
; 363  : 
; 364  : 		/// \todo make sure front poly is to front of partition line?
; 365  : 
; 366  : 		*frontpoly = poly;

  001ca	8b 45 10	 mov	 eax, DWORD PTR _frontpoly$[ebp]
  001cd	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  001d0	89 08		 mov	 DWORD PTR [eax], ecx

; 367  : 		*backpoly = NULL;

  001d2	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  001d5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 368  : 		return;

  001db	e9 2d 02 00 00	 jmp	 $LN1@SplitPoly
$LN22@SplitPoly:

; 369  : 	}
; 370  : 
; 371  : 	if (ps >= 0 && pe < 0)

  001e0	83 7d ec 00	 cmp	 DWORD PTR _ps$[ebp], 0
  001e4	7c 1c		 jl	 SHORT $LN23@SplitPoly
  001e6	83 7d e8 00	 cmp	 DWORD PTR _pe$[ebp], 0
  001ea	7d 16		 jge	 SHORT $LN23@SplitPoly

; 372  : 	{
; 373  : 		//I_Error("SplitPoly: only one point for split line (%d %d)", ps, pe);
; 374  : 		*frontpoly = poly;

  001ec	8b 45 10	 mov	 eax, DWORD PTR _frontpoly$[ebp]
  001ef	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  001f2	89 08		 mov	 DWORD PTR [eax], ecx

; 375  : 		*backpoly = NULL;

  001f4	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  001f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 376  : 		return;

  001fd	e9 0b 02 00 00	 jmp	 $LN1@SplitPoly
$LN23@SplitPoly:

; 377  : 	}
; 378  : 	if (pe <= ps)

  00202	8b 45 e8	 mov	 eax, DWORD PTR _pe$[ebp]
  00205	3b 45 ec	 cmp	 eax, DWORD PTR _ps$[ebp]
  00208	7f 15		 jg	 SHORT $LN24@SplitPoly

; 379  : 		I_Error("SplitPoly: invalid splitting line (%d %d)", ps, pe);

  0020a	8b 45 e8	 mov	 eax, DWORD PTR _pe$[ebp]
  0020d	50		 push	 eax
  0020e	8b 4d ec	 mov	 ecx, DWORD PTR _ps$[ebp]
  00211	51		 push	 ecx
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@EHHKGIMC@SplitPoly?3?5invalid?5splitting?5li@
  00217	e8 00 00 00 00	 call	 _I_Error
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@SplitPoly:

; 380  : 
; 381  : 	// number of points on each side, _not_ counting those
; 382  : 	// that may lie just one the line
; 383  : 	nptback  = pe - ps - peonline;

  0021f	8b 45 e8	 mov	 eax, DWORD PTR _pe$[ebp]
  00222	2b 45 ec	 sub	 eax, DWORD PTR _ps$[ebp]
  00225	2b 45 ac	 sub	 eax, DWORD PTR _peonline$[ebp]
  00228	89 45 e0	 mov	 DWORD PTR _nptback$[ebp], eax

; 384  : 	nptfront = poly->numpts - peonline - psonline - nptback;

  0022b	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  0022e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00230	2b 4d ac	 sub	 ecx, DWORD PTR _peonline$[ebp]
  00233	2b 4d b0	 sub	 ecx, DWORD PTR _psonline$[ebp]
  00236	2b 4d e0	 sub	 ecx, DWORD PTR _nptback$[ebp]
  00239	89 4d e4	 mov	 DWORD PTR _nptfront$[ebp], ecx

; 385  : 
; 386  : 	if (nptback > 0)

  0023c	83 7d e0 00	 cmp	 DWORD PTR _nptback$[ebp], 0
  00240	7e 16		 jle	 SHORT $LN25@SplitPoly

; 387  : 		*backpoly = HWR_AllocPoly(2 + nptback);

  00242	8b 45 e0	 mov	 eax, DWORD PTR _nptback$[ebp]
  00245	83 c0 02	 add	 eax, 2
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 _HWR_AllocPoly
  0024e	83 c4 04	 add	 esp, 4
  00251	8b 4d 14	 mov	 ecx, DWORD PTR _backpoly$[ebp]
  00254	89 01		 mov	 DWORD PTR [ecx], eax
  00256	eb 09		 jmp	 SHORT $LN26@SplitPoly
$LN25@SplitPoly:

; 388  : 	else
; 389  : 		*backpoly = NULL;

  00258	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  0025b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN26@SplitPoly:

; 390  : 	if (nptfront)

  00261	83 7d e4 00	 cmp	 DWORD PTR _nptfront$[ebp], 0
  00265	74 16		 je	 SHORT $LN27@SplitPoly

; 391  : 		*frontpoly = HWR_AllocPoly(2 + nptfront);

  00267	8b 45 e4	 mov	 eax, DWORD PTR _nptfront$[ebp]
  0026a	83 c0 02	 add	 eax, 2
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 _HWR_AllocPoly
  00273	83 c4 04	 add	 esp, 4
  00276	8b 4d 10	 mov	 ecx, DWORD PTR _frontpoly$[ebp]
  00279	89 01		 mov	 DWORD PTR [ecx], eax
  0027b	eb 09		 jmp	 SHORT $LN28@SplitPoly
$LN27@SplitPoly:

; 392  : 	else
; 393  : 		*frontpoly = NULL;

  0027d	8b 45 10	 mov	 eax, DWORD PTR _frontpoly$[ebp]
  00280	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN28@SplitPoly:

; 394  : 
; 395  : 	// generate FRONT poly
; 396  : 	if (*frontpoly)

  00286	8b 45 10	 mov	 eax, DWORD PTR _frontpoly$[ebp]
  00289	83 38 00	 cmp	 DWORD PTR [eax], 0
  0028c	0f 84 9f 00 00
	00		 je	 $LN31@SplitPoly

; 397  : 	{
; 398  : 		pv = (*frontpoly)->pts;

  00292	8b 45 10	 mov	 eax, DWORD PTR _frontpoly$[ebp]
  00295	8b 08		 mov	 ecx, DWORD PTR [eax]
  00297	83 c1 04	 add	 ecx, 4
  0029a	89 4d f0	 mov	 DWORD PTR _pv$[ebp], ecx

; 399  : 		*pv++ = vs;

  0029d	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  002a0	8b 4d d4	 mov	 ecx, DWORD PTR _vs$[ebp]
  002a3	89 08		 mov	 DWORD PTR [eax], ecx
  002a5	8b 55 d8	 mov	 edx, DWORD PTR _vs$[ebp+4]
  002a8	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002ab	8b 4d dc	 mov	 ecx, DWORD PTR _vs$[ebp+8]
  002ae	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002b1	8b 55 f0	 mov	 edx, DWORD PTR _pv$[ebp]
  002b4	83 c2 0c	 add	 edx, 12			; 0000000cH
  002b7	89 55 f0	 mov	 DWORD PTR _pv$[ebp], edx

; 400  : 		*pv++ = ve;

  002ba	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  002bd	8b 4d c8	 mov	 ecx, DWORD PTR _ve$[ebp]
  002c0	89 08		 mov	 DWORD PTR [eax], ecx
  002c2	8b 55 cc	 mov	 edx, DWORD PTR _ve$[ebp+4]
  002c5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002c8	8b 4d d0	 mov	 ecx, DWORD PTR _ve$[ebp+8]
  002cb	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002ce	8b 55 f0	 mov	 edx, DWORD PTR _pv$[ebp]
  002d1	83 c2 0c	 add	 edx, 12			; 0000000cH
  002d4	89 55 f0	 mov	 DWORD PTR _pv$[ebp], edx

; 401  : 		i = pe;

  002d7	8b 45 e8	 mov	 eax, DWORD PTR _pe$[ebp]
  002da	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@SplitPoly:

; 402  : 		do
; 403  : 		{
; 404  : 			if (++i == poly->numpts)

  002dd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002e0	83 c0 01	 add	 eax, 1
  002e3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  002e6	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  002e9	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002ec	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002ee	75 07		 jne	 SHORT $LN30@SplitPoly

; 405  : 				i = 0;

  002f0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN30@SplitPoly:

; 406  : 			*pv++ = poly->pts[i];

  002f7	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  002fb	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  002fe	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00302	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  00305	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00307	89 08		 mov	 DWORD PTR [eax], ecx
  00309	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0030c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0030f	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00312	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00315	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  00318	83 c0 0c	 add	 eax, 12			; 0000000cH
  0031b	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 407  : 		} while (i != ps && --nptfront);

  0031e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00321	3b 45 ec	 cmp	 eax, DWORD PTR _ps$[ebp]
  00324	74 0b		 je	 SHORT $LN31@SplitPoly
  00326	8b 45 e4	 mov	 eax, DWORD PTR _nptfront$[ebp]
  00329	83 e8 01	 sub	 eax, 1
  0032c	89 45 e4	 mov	 DWORD PTR _nptfront$[ebp], eax
  0032f	75 ac		 jne	 SHORT $LN7@SplitPoly
$LN31@SplitPoly:

; 408  : 	}
; 409  : 
; 410  : 	// generate BACK poly
; 411  : 	if (*backpoly)

  00331	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  00334	83 38 00	 cmp	 DWORD PTR [eax], 0
  00337	0f 84 9f 00 00
	00		 je	 $LN34@SplitPoly

; 412  : 	{
; 413  : 		pv = (*backpoly)->pts;

  0033d	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  00340	8b 08		 mov	 ecx, DWORD PTR [eax]
  00342	83 c1 04	 add	 ecx, 4
  00345	89 4d f0	 mov	 DWORD PTR _pv$[ebp], ecx

; 414  : 		*pv++ = ve;

  00348	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  0034b	8b 4d c8	 mov	 ecx, DWORD PTR _ve$[ebp]
  0034e	89 08		 mov	 DWORD PTR [eax], ecx
  00350	8b 55 cc	 mov	 edx, DWORD PTR _ve$[ebp+4]
  00353	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00356	8b 4d d0	 mov	 ecx, DWORD PTR _ve$[ebp+8]
  00359	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0035c	8b 55 f0	 mov	 edx, DWORD PTR _pv$[ebp]
  0035f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00362	89 55 f0	 mov	 DWORD PTR _pv$[ebp], edx

; 415  : 		*pv++ = vs;

  00365	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  00368	8b 4d d4	 mov	 ecx, DWORD PTR _vs$[ebp]
  0036b	89 08		 mov	 DWORD PTR [eax], ecx
  0036d	8b 55 d8	 mov	 edx, DWORD PTR _vs$[ebp+4]
  00370	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00373	8b 4d dc	 mov	 ecx, DWORD PTR _vs$[ebp+8]
  00376	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00379	8b 55 f0	 mov	 edx, DWORD PTR _pv$[ebp]
  0037c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0037f	89 55 f0	 mov	 DWORD PTR _pv$[ebp], edx

; 416  : 		i = ps;

  00382	8b 45 ec	 mov	 eax, DWORD PTR _ps$[ebp]
  00385	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@SplitPoly:

; 417  : 		do
; 418  : 		{
; 419  : 			if (++i == poly->numpts)

  00388	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0038b	83 c0 01	 add	 eax, 1
  0038e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00391	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  00394	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00397	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00399	75 07		 jne	 SHORT $LN33@SplitPoly

; 420  : 				i = 0;

  0039b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN33@SplitPoly:

; 421  : 			*pv++ = poly->pts[i];

  003a2	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  003a6	8b 4d 0c	 mov	 ecx, DWORD PTR _poly$[ebp]
  003a9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003ad	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  003b0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003b2	89 08		 mov	 DWORD PTR [eax], ecx
  003b4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  003b7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  003ba	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  003bd	89 50 08	 mov	 DWORD PTR [eax+8], edx
  003c0	8b 45 f0	 mov	 eax, DWORD PTR _pv$[ebp]
  003c3	83 c0 0c	 add	 eax, 12			; 0000000cH
  003c6	89 45 f0	 mov	 DWORD PTR _pv$[ebp], eax

; 422  : 		} while (i != pe && --nptback);

  003c9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  003cc	3b 45 e8	 cmp	 eax, DWORD PTR _pe$[ebp]
  003cf	74 0b		 je	 SHORT $LN34@SplitPoly
  003d1	8b 45 e0	 mov	 eax, DWORD PTR _nptback$[ebp]
  003d4	83 e8 01	 sub	 eax, 1
  003d7	89 45 e0	 mov	 DWORD PTR _nptback$[ebp], eax
  003da	75 ac		 jne	 SHORT $LN10@SplitPoly
$LN34@SplitPoly:

; 423  : 	}
; 424  : 
; 425  : 	// make sure frontpoly is the one on the 'right' side
; 426  : 	// of the partition line
; 427  : 	if (fracs > frace)

  003dc	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fracs$[ebp]
  003e1	0f 2f 45 b4	 comiss	 xmm0, DWORD PTR _frace$[ebp]
  003e5	76 1a		 jbe	 SHORT $LN35@SplitPoly

; 428  : 	{
; 429  : 		poly_t *swappoly;
; 430  : 		swappoly = *backpoly;

  003e7	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  003ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ec	89 4d a8	 mov	 DWORD PTR _swappoly$1[ebp], ecx

; 431  : 		*backpoly = *frontpoly;

  003ef	8b 45 14	 mov	 eax, DWORD PTR _backpoly$[ebp]
  003f2	8b 4d 10	 mov	 ecx, DWORD PTR _frontpoly$[ebp]
  003f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  003f7	89 10		 mov	 DWORD PTR [eax], edx

; 432  : 		*frontpoly = swappoly;

  003f9	8b 45 10	 mov	 eax, DWORD PTR _frontpoly$[ebp]
  003fc	8b 4d a8	 mov	 ecx, DWORD PTR _swappoly$1[ebp]
  003ff	89 08		 mov	 DWORD PTR [eax], ecx
$LN35@SplitPoly:

; 433  : 	}
; 434  : 
; 435  : 	HWR_FreePoly (poly);

  00401	8b 45 0c	 mov	 eax, DWORD PTR _poly$[ebp]
  00404	50		 push	 eax
  00405	e8 00 00 00 00	 call	 _HWR_FreePoly
  0040a	83 c4 04	 add	 esp, 4
$LN1@SplitPoly:

; 436  : }

  0040d	5f		 pop	 edi
  0040e	5e		 pop	 esi
  0040f	5b		 pop	 ebx
  00410	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00413	33 cd		 xor	 ecx, ebp
  00415	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041a	8b e5		 mov	 esp, ebp
  0041c	5d		 pop	 ebp
  0041d	c3		 ret	 0
_SplitPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _SameVertice
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_SameVertice PROC					; COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 248  : #if 0
; 249  : 	float diff;
; 250  : 	diff = p2->x - p1->x;
; 251  : 	if (diff < -1.5f || diff > 1.5f)
; 252  : 		return false;
; 253  : 	diff = p2->y - p1->y;
; 254  : 	if (diff < -1.5f || diff > 1.5f)
; 255  : 		return false;
; 256  : #else
; 257  : 	if (p1->x != p2->x)

  00009	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	0f 2e 01	 ucomiss xmm0, DWORD PTR [ecx]
  00016	9f		 lahf
  00017	f6 c4 44	 test	 ah, 68			; 00000044H
  0001a	7b 04		 jnp	 SHORT $LN2@SameVertic

; 258  : 		return false;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 1e		 jmp	 SHORT $LN1@SameVertic
$LN2@SameVertic:

; 259  : 	if (p1->y != p2->y)

  00020	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  00026	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0002b	0f 2e 41 04	 ucomiss xmm0, DWORD PTR [ecx+4]
  0002f	9f		 lahf
  00030	f6 c4 44	 test	 ah, 68			; 00000044H
  00033	7b 04		 jnp	 SHORT $LN3@SameVertic

; 260  : 		return false;

  00035	33 c0		 xor	 eax, eax
  00037	eb 05		 jmp	 SHORT $LN1@SameVertic
$LN3@SameVertic:

; 261  : #endif
; 262  : 	// p1 and p2 are considered the same vertex
; 263  : 	return true;

  00039	b8 01 00 00 00	 mov	 eax, 1
$LN1@SameVertic:

; 264  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_SameVertice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _fracdivline
_TEXT	SEGMENT
_v2dy$ = -88						; size = 8
_v2dx$ = -80						; size = 8
_v2y$ = -72						; size = 8
_v2x$ = -64						; size = 8
_v1dy$ = -56						; size = 8
_v1dx$ = -48						; size = 8
_v1y$ = -40						; size = 8
_v1x$ = -32						; size = 8
_den$ = -24						; size = 8
_num$ = -16						; size = 8
_frac$ = -8						; size = 8
_bsp$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_fracdivline PROC					; COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 176  : 	static polyvertex_t pt;
; 177  : 	double frac;
; 178  : 	double num;
; 179  : 	double den;
; 180  : 	double v1x,v1y,v1dx,v1dy;
; 181  : 	double v2x,v2y,v2dx,v2dy;
; 182  : 
; 183  : 	// a segment of a polygon
; 184  : 	v1x  = v1->x;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0000f	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [eax]
  00013	f2 0f 11 45 e0	 movsd	 QWORD PTR _v1x$[ebp], xmm0

; 185  : 	v1y  = v1->y;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0001b	f3 0f 5a 40 04	 cvtss2sd xmm0, DWORD PTR [eax+4]
  00020	f2 0f 11 45 d8	 movsd	 QWORD PTR _v1y$[ebp], xmm0

; 186  : 	v1dx = v2->x - v1->x;

  00025	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00033	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00037	f2 0f 11 45 d0	 movsd	 QWORD PTR _v1dx$[ebp], xmm0

; 187  : 	v1dy = v2->y - v1->y;

  0003c	8b 45 10	 mov	 eax, DWORD PTR _v2$[ebp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _v1$[ebp]
  00042	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00047	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0004c	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00050	f2 0f 11 45 c8	 movsd	 QWORD PTR _v1dy$[ebp], xmm0

; 188  : 
; 189  : 	// the bsp partition line
; 190  : 	v2x  = bsp->x;

  00055	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  00058	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [eax]
  0005c	f2 0f 11 45 c0	 movsd	 QWORD PTR _v2x$[ebp], xmm0

; 191  : 	v2y  = bsp->y;

  00061	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  00064	f3 0f 5a 40 04	 cvtss2sd xmm0, DWORD PTR [eax+4]
  00069	f2 0f 11 45 b8	 movsd	 QWORD PTR _v2y$[ebp], xmm0

; 192  : 	v2dx = bsp->dx;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  00071	f3 0f 5a 40 08	 cvtss2sd xmm0, DWORD PTR [eax+8]
  00076	f2 0f 11 45 b0	 movsd	 QWORD PTR _v2dx$[ebp], xmm0

; 193  : 	v2dy = bsp->dy;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _bsp$[ebp]
  0007e	f3 0f 5a 40 0c	 cvtss2sd xmm0, DWORD PTR [eax+12]
  00083	f2 0f 11 45 a8	 movsd	 QWORD PTR _v2dy$[ebp], xmm0

; 194  : 
; 195  : 	den = v2dy*v1dx - v2dx*v1dy;

  00088	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR _v2dy$[ebp]
  0008d	f2 0f 59 45 d0	 mulsd	 xmm0, QWORD PTR _v1dx$[ebp]
  00092	f2 0f 10 4d b0	 movsd	 xmm1, QWORD PTR _v2dx$[ebp]
  00097	f2 0f 59 4d c8	 mulsd	 xmm1, QWORD PTR _v1dy$[ebp]
  0009c	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000a0	f2 0f 11 45 e8	 movsd	 QWORD PTR _den$[ebp], xmm0

; 196  : 	if (den == 0)

  000a5	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _den$[ebp]
  000aa	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000b2	9f		 lahf
  000b3	f6 c4 44	 test	 ah, 68			; 00000044H
  000b6	7a 07		 jp	 SHORT $LN2@fracdivlin

; 197  : 		return NULL;       // parallel

  000b8	33 c0		 xor	 eax, eax
  000ba	e9 d1 00 00 00	 jmp	 $LN1@fracdivlin
$LN2@fracdivlin:

; 198  : 
; 199  : 	// first check the frac along the polygon segment,
; 200  : 	// (do not accept hit with the extensions)
; 201  : 	num = (v2x - v1x)*v2dy + (v1y - v2y)*v2dx;

  000bf	f2 0f 10 45 c0	 movsd	 xmm0, QWORD PTR _v2x$[ebp]
  000c4	f2 0f 5c 45 e0	 subsd	 xmm0, QWORD PTR _v1x$[ebp]
  000c9	f2 0f 59 45 a8	 mulsd	 xmm0, QWORD PTR _v2dy$[ebp]
  000ce	f2 0f 10 4d d8	 movsd	 xmm1, QWORD PTR _v1y$[ebp]
  000d3	f2 0f 5c 4d b8	 subsd	 xmm1, QWORD PTR _v2y$[ebp]
  000d8	f2 0f 59 4d b0	 mulsd	 xmm1, QWORD PTR _v2dx$[ebp]
  000dd	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000e1	f2 0f 11 45 f0	 movsd	 QWORD PTR _num$[ebp], xmm0

; 202  : 	frac = num / den;

  000e6	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _num$[ebp]
  000eb	f2 0f 5e 45 e8	 divsd	 xmm0, QWORD PTR _den$[ebp]
  000f0	f2 0f 11 45 f8	 movsd	 QWORD PTR _frac$[ebp], xmm0

; 203  : 	if (frac < 0 || frac > 1)

  000f5	0f 57 c0	 xorps	 xmm0, xmm0
  000f8	66 0f 2f 45 f8	 comisd	 xmm0, QWORD PTR _frac$[ebp]
  000fd	77 0f		 ja	 SHORT $LN4@fracdivlin
  000ff	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _frac$[ebp]
  00104	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  0010c	76 04		 jbe	 SHORT $LN3@fracdivlin
$LN4@fracdivlin:

; 204  : 		return NULL;

  0010e	33 c0		 xor	 eax, eax
  00110	eb 7e		 jmp	 SHORT $LN1@fracdivlin
$LN3@fracdivlin:

; 205  : 
; 206  : 	// now get the frac along the BSP line
; 207  : 	// which is useful to determine what is left, what is right
; 208  : 	num = (v2x - v1x)*v1dy + (v1y - v2y)*v1dx;

  00112	f2 0f 10 45 c0	 movsd	 xmm0, QWORD PTR _v2x$[ebp]
  00117	f2 0f 5c 45 e0	 subsd	 xmm0, QWORD PTR _v1x$[ebp]
  0011c	f2 0f 59 45 c8	 mulsd	 xmm0, QWORD PTR _v1dy$[ebp]
  00121	f2 0f 10 4d d8	 movsd	 xmm1, QWORD PTR _v1y$[ebp]
  00126	f2 0f 5c 4d b8	 subsd	 xmm1, QWORD PTR _v2y$[ebp]
  0012b	f2 0f 59 4d d0	 mulsd	 xmm1, QWORD PTR _v1dx$[ebp]
  00130	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00134	f2 0f 11 45 f0	 movsd	 QWORD PTR _num$[ebp], xmm0

; 209  : 	frac = num / den;

  00139	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _num$[ebp]
  0013e	f2 0f 5e 45 e8	 divsd	 xmm0, QWORD PTR _den$[ebp]
  00143	f2 0f 11 45 f8	 movsd	 QWORD PTR _frac$[ebp], xmm0

; 210  : 	bspfrac = (float)frac;

  00148	f2 0f 5a 45 f8	 cvtsd2ss xmm0, QWORD PTR _frac$[ebp]
  0014d	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _bspfrac, xmm0

; 211  : 
; 212  : 
; 213  : 	// find the interception point along the partition line
; 214  : 	pt.x = (float)(v2x + v2dx*frac);

  00155	f2 0f 10 45 b0	 movsd	 xmm0, QWORD PTR _v2dx$[ebp]
  0015a	f2 0f 59 45 f8	 mulsd	 xmm0, QWORD PTR _frac$[ebp]
  0015f	f2 0f 58 45 c0	 addsd	 xmm0, QWORD PTR _v2x$[ebp]
  00164	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00168	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?pt@?1??fracdivline@@9@9, xmm0

; 215  : 	pt.y = (float)(v2y + v2dy*frac);

  00170	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR _v2dy$[ebp]
  00175	f2 0f 59 45 f8	 mulsd	 xmm0, QWORD PTR _frac$[ebp]
  0017a	f2 0f 58 45 b8	 addsd	 xmm0, QWORD PTR _v2y$[ebp]
  0017f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00183	f3 0f 11 05 04
	00 00 00	 movss	 DWORD PTR ?pt@?1??fracdivline@@9@9+4, xmm0

; 216  : 
; 217  : 	return &pt;

  0018b	b8 00 00 00 00	 mov	 eax, OFFSET ?pt@?1??fracdivline@@9@9
$LN1@fracdivlin:

; 218  : }

  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
_fracdivline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_FreePoly
_TEXT	SEGMENT
_poly$ = 8						; size = 4
_HWR_FreePoly PROC					; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 159  : #ifdef ZPLANALLOC
; 160  : 	Z_Free(poly);

  00009	8b 45 08	 mov	 eax, DWORD PTR _poly$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _Z_Free
  00012	83 c4 04	 add	 esp, 4

; 161  : #else
; 162  : 	const size_t size = sizeof (poly_t) + sizeof (polyvertex_t) * poly->numpts;
; 163  : 	memset(poly, 0x00, size);
; 164  : 	//mempoly -= polysize;
; 165  : #endif
; 166  : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_HWR_FreePoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_AllocVertex
_TEXT	SEGMENT
_size$ = -8						; size = 4
_p$ = -4						; size = 4
_HWR_AllocVertex PROC					; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 139  : 	polyvertex_t *p;
; 140  : 	size_t size = sizeof (polyvertex_t);

  00009	c7 45 f8 0c 00
	00 00		 mov	 DWORD PTR _size$[ebp], 12 ; 0000000cH

; 141  : #ifdef ZPLANALLOC
; 142  : 	p = Z_Malloc(size, PU_HWRPLANE, NULL);

  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 34		 push	 52			; 00000034H
  00016	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _Z_MallocAlign
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 143  : #else
; 144  : 	if (gr_ppfree < size)
; 145  : 		I_Error("HWR_AllocVertex(): no more memory %u bytes left, %u bytes needed\n\n%s\n",
; 146  : 		        gr_ppfree, size, "You can try the param -polypoolsize 2048 (or higher if needed)");
; 147  : 
; 148  : 	p = (polyvertex_t *)gr_ppcurrent;
; 149  : 	gr_ppcurrent += size;
; 150  : 	gr_ppfree -= size;
; 151  : #endif
; 152  : 	return p;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]

; 153  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_HWR_AllocVertex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_AllocPoly
_TEXT	SEGMENT
_size$ = -8						; size = 4
_p$ = -4						; size = 4
_numpts$ = 8						; size = 4
_HWR_AllocPoly PROC					; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 113  : 	poly_t *p;
; 114  : 	size_t size = sizeof (poly_t) + sizeof (polyvertex_t) * numpts;

  00009	6b 45 08 0c	 imul	 eax, DWORD PTR _numpts$[ebp], 12
  0000d	83 c0 04	 add	 eax, 4
  00010	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 115  : #ifdef ZPLANALLOC
; 116  : 	p = Z_Malloc(size, PU_HWRPLANE, NULL);

  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	6a 34		 push	 52			; 00000034H
  00019	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _Z_MallocAlign
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 117  : #else
; 118  : #ifdef PARANOIA
; 119  : 	if (!gr_polypool)
; 120  : 		I_Error("Used gr_polypool without init!\n");
; 121  : 	if (!gr_ppcurrent)
; 122  : 		I_Error("gr_ppcurrent == NULL!\n");
; 123  : #endif
; 124  : 
; 125  : 	if (gr_ppfree < size)
; 126  : 		I_Error("HWR_AllocPoly(): no more memory %u bytes left, %u bytes needed\n\n%s\n",
; 127  : 		        gr_ppfree, size, "You can try the param -polypoolsize 2048 (or higher if needed)");
; 128  : 
; 129  : 	p = (poly_t *)gr_ppcurrent;
; 130  : 	gr_ppcurrent += size;
; 131  : 	gr_ppfree -= size;
; 132  : #endif
; 133  : 	p->numpts = numpts;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _numpts$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx

; 134  : 	return p;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]

; 135  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_HWR_AllocPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_ClearPolys
_TEXT	SEGMENT
_HWR_ClearPolys PROC					; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 78   : #ifndef ZPLANALLOC
; 79   : 	gr_ppcurrent = gr_polypool;
; 80   : 	gr_ppfree = POLYPOOLSIZE;
; 81   : #endif
; 82   : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_HWR_ClearPolys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_FreeExtraSubsectors
_TEXT	SEGMENT
_HWR_FreeExtraSubsectors PROC				; COMDAT

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 709  : 	if (extrasubsectors)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _extrasubsectors, 0
  00010	74 0e		 je	 SHORT $LN2@HWR_FreeEx

; 710  : 		free(extrasubsectors);

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _extrasubsectors
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _free
  0001d	83 c4 04	 add	 esp, 4
$LN2@HWR_FreeEx:

; 711  : 	extrasubsectors = NULL;

  00020	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _extrasubsectors, 0

; 712  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_HWR_FreeExtraSubsectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_FreePolyPool
_TEXT	SEGMENT
_HWR_FreePolyPool PROC					; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 104  : #ifndef ZPLANALLOC
; 105  : 	if (gr_polypool)
; 106  : 		free(gr_polypool);
; 107  : 	gr_polypool = NULL;
; 108  : #endif
; 109  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_HWR_FreePolyPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_InitPolyPool
_TEXT	SEGMENT
_HWR_InitPolyPool PROC					; COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   : #ifndef ZPLANALLOC
; 88   : 	INT32 pnum;
; 89   : 
; 90   : 	//hurdler: quick fix for those who wants to play with larger wad
; 91   : 	if ((pnum = M_CheckParm("-polypoolsize")))
; 92   : 		POLYPOOLSIZE = atoi(myargv[pnum+1])*1024; // (in kb)
; 93   : 
; 94   : 	CONS_Printf("HWR_InitPolyPool(): allocating %d bytes\n", POLYPOOLSIZE);
; 95   : 	gr_polypool = malloc(POLYPOOLSIZE);
; 96   : 	if (!gr_polypool)
; 97   : 		I_Error("HWR_InitPolyPool(): couldn't malloc polypool\n");
; 98   : 	HWR_ClearPolys();
; 99   : #endif
; 100  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_HWR_InitPolyPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\hardware\hw_bsp.c
;	COMDAT _HWR_CreatePlanePolygons
_TEXT	SEGMENT
_rootbbox$ = -32					; size = 16
_i$ = -16						; size = 4
_rootpv$ = -12						; size = 4
_rootp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bspnum$ = 8						; size = 4
_HWR_CreatePlanePolygons PROC				; COMDAT

; 962  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 963  : 	poly_t *rootp;
; 964  : 	polyvertex_t *rootpv;
; 965  : 	size_t i;
; 966  : 	fixed_t rootbbox[4];
; 967  : 
; 968  : 	if (cv_debug)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  0001a	74 0d		 je	 SHORT $LN5@HWR_Create

; 969  : 		CONS_Printf("Creating polygons, please wait...\n");

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CMLNCLEJ@Creating?5polygons?0?5please?5wait?4@
  00021	e8 00 00 00 00	 call	 _CONS_Printf
  00026	83 c4 04	 add	 esp, 4
$LN5@HWR_Create:

; 970  : 	ls_count = ls_percent = 0; // reset the loading status

  00029	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _ls_percent, 0
  00030	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _ls_percent
  00037	a3 00 00 00 00	 mov	 DWORD PTR _ls_count, eax

; 971  : 	CON_Drawer(); //let the user know what we are doing

  0003c	e8 00 00 00 00	 call	 _CON_Drawer
  00041	90		 npad	 1

; 972  : 	I_FinishUpdate(); // page flip or blit buffer

  00042	e8 00 00 00 00	 call	 _I_FinishUpdate
  00047	90		 npad	 1

; 973  : 
; 974  : 	HWR_ClearPolys();

  00048	e8 00 00 00 00	 call	 _HWR_ClearPolys
  0004d	90		 npad	 1

; 975  : 
; 976  : 	// find min/max boundaries of map
; 977  : 	//CONS_Printf("Looking for boundaries of map...\n");
; 978  : 	M_ClearBox(rootbbox);

  0004e	8d 45 e0	 lea	 eax, DWORD PTR _rootbbox$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _M_ClearBox
  00057	83 c4 04	 add	 esp, 4

; 979  : 	for (i = 0;i < numvertexes; i++)

  0005a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN4@HWR_Create
$LN2@HWR_Create:
  00063	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HWR_Create:
  0006c	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numvertexes
  00075	73 2b		 jae	 SHORT $LN3@HWR_Create

; 980  : 		M_AddToBox(rootbbox, vertexes[i].x, vertexes[i].y);

  00077	6b 45 f0 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  00081	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00085	52		 push	 edx
  00086	6b 45 f0 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vertexes
  00090	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00093	52		 push	 edx
  00094	8d 45 e0	 lea	 eax, DWORD PTR _rootbbox$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _M_AddToBox
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	eb c1		 jmp	 SHORT $LN2@HWR_Create
$LN3@HWR_Create:

; 981  : 
; 982  : 	//CONS_Printf("Generating subsector polygons... %d subsectors\n", numsubsectors);
; 983  : 
; 984  : 	HWR_FreeExtraSubsectors();

  000a2	e8 00 00 00 00	 call	 _HWR_FreeExtraSubsectors
  000a7	90		 npad	 1

; 985  : 	// allocate extra data for each subsector present in map
; 986  : 	totsubsectors = numsubsectors + NEWSUBSECTORS;

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsubsectors
  000ad	83 c0 32	 add	 eax, 50			; 00000032H
  000b0	a3 00 00 00 00	 mov	 DWORD PTR _totsubsectors, eax

; 987  : 	extrasubsectors = calloc(totsubsectors, sizeof (*extrasubsectors));

  000b5	6a 04		 push	 4
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _totsubsectors
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _calloc
  000c2	83 c4 08	 add	 esp, 8
  000c5	a3 00 00 00 00	 mov	 DWORD PTR _extrasubsectors, eax

; 988  : 	if (extrasubsectors == NULL)

  000ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _extrasubsectors, 0
  000d1	75 13		 jne	 SHORT $LN6@HWR_Create

; 989  : 		I_Error("couldn't malloc extrasubsectors totsubsectors %"PRIdS"\n", totsubsectors);

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _totsubsectors
  000d8	50		 push	 eax
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PCNOADGC@couldn?8t?5malloc?5extrasubsectors@
  000de	e8 00 00 00 00	 call	 _I_Error
  000e3	83 c4 08	 add	 esp, 8
$LN6@HWR_Create:

; 990  : 
; 991  : 	// allocate table for back to front drawing of subsectors
; 992  : 	/*gr_drawsubsectors = (INT16 *)malloc(sizeof (*gr_drawsubsectors) * totsubsectors);
; 993  : 	if (!gr_drawsubsectors)
; 994  : 		I_Error("couldn't malloc gr_drawsubsectors\n");*/
; 995  : 
; 996  : 	// number of the first new subsector that might be added
; 997  : 	addsubsector = numsubsectors;

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsubsectors
  000eb	a3 00 00 00 00	 mov	 DWORD PTR _addsubsector, eax

; 998  : 
; 999  : 	// construct the initial convex poly that encloses the full map
; 1000 : 	rootp = HWR_AllocPoly(4);

  000f0	6a 04		 push	 4
  000f2	e8 00 00 00 00	 call	 _HWR_AllocPoly
  000f7	83 c4 04	 add	 esp, 4
  000fa	89 45 f8	 mov	 DWORD PTR _rootp$[ebp], eax

; 1001 : 	rootpv = rootp->pts;

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _rootp$[ebp]
  00100	83 c0 04	 add	 eax, 4
  00103	89 45 f4	 mov	 DWORD PTR _rootpv$[ebp], eax

; 1002 : 
; 1003 : 	rootpv->x = FIXED_TO_FLOAT(rootbbox[BOXLEFT  ]);

  00106	b8 04 00 00 00	 mov	 eax, 4
  0010b	d1 e0		 shl	 eax, 1
  0010d	f3 0f 2a 44 05
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+eax]
  00113	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR _rootpv$[ebp]
  0011e	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 1004 : 	rootpv->y = FIXED_TO_FLOAT(rootbbox[BOXBOTTOM]);  //lr

  00122	b8 04 00 00 00	 mov	 eax, 4
  00127	c1 e0 00	 shl	 eax, 0
  0012a	f3 0f 2a 44 05
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+eax]
  00130	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00138	8b 4d f4	 mov	 ecx, DWORD PTR _rootpv$[ebp]
  0013b	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 1005 : 	rootpv++;

  00140	8b 45 f4	 mov	 eax, DWORD PTR _rootpv$[ebp]
  00143	83 c0 0c	 add	 eax, 12			; 0000000cH
  00146	89 45 f4	 mov	 DWORD PTR _rootpv$[ebp], eax

; 1006 : 	rootpv->x = FIXED_TO_FLOAT(rootbbox[BOXLEFT  ]);

  00149	b8 04 00 00 00	 mov	 eax, 4
  0014e	d1 e0		 shl	 eax, 1
  00150	f3 0f 2a 44 05
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+eax]
  00156	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0015e	8b 4d f4	 mov	 ecx, DWORD PTR _rootpv$[ebp]
  00161	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 1007 : 	rootpv->y = FIXED_TO_FLOAT(rootbbox[BOXTOP   ]);  //ur

  00165	b8 04 00 00 00	 mov	 eax, 4
  0016a	6b c8 00	 imul	 ecx, eax, 0
  0016d	f3 0f 2a 44 0d
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+ecx]
  00173	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0017b	8b 55 f4	 mov	 edx, DWORD PTR _rootpv$[ebp]
  0017e	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 1008 : 	rootpv++;

  00183	8b 45 f4	 mov	 eax, DWORD PTR _rootpv$[ebp]
  00186	83 c0 0c	 add	 eax, 12			; 0000000cH
  00189	89 45 f4	 mov	 DWORD PTR _rootpv$[ebp], eax

; 1009 : 	rootpv->x = FIXED_TO_FLOAT(rootbbox[BOXRIGHT ]);

  0018c	b8 04 00 00 00	 mov	 eax, 4
  00191	6b c8 03	 imul	 ecx, eax, 3
  00194	f3 0f 2a 44 0d
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+ecx]
  0019a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001a2	8b 55 f4	 mov	 edx, DWORD PTR _rootpv$[ebp]
  001a5	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 1010 : 	rootpv->y = FIXED_TO_FLOAT(rootbbox[BOXTOP   ]);  //ul

  001a9	b8 04 00 00 00	 mov	 eax, 4
  001ae	6b c8 00	 imul	 ecx, eax, 0
  001b1	f3 0f 2a 44 0d
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+ecx]
  001b7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001bf	8b 55 f4	 mov	 edx, DWORD PTR _rootpv$[ebp]
  001c2	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 1011 : 	rootpv++;

  001c7	8b 45 f4	 mov	 eax, DWORD PTR _rootpv$[ebp]
  001ca	83 c0 0c	 add	 eax, 12			; 0000000cH
  001cd	89 45 f4	 mov	 DWORD PTR _rootpv$[ebp], eax

; 1012 : 	rootpv->x = FIXED_TO_FLOAT(rootbbox[BOXRIGHT ]);

  001d0	b8 04 00 00 00	 mov	 eax, 4
  001d5	6b c8 03	 imul	 ecx, eax, 3
  001d8	f3 0f 2a 44 0d
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+ecx]
  001de	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  001e6	8b 55 f4	 mov	 edx, DWORD PTR _rootpv$[ebp]
  001e9	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 1013 : 	rootpv->y = FIXED_TO_FLOAT(rootbbox[BOXBOTTOM]);  //ll

  001ed	b8 04 00 00 00	 mov	 eax, 4
  001f2	c1 e0 00	 shl	 eax, 0
  001f5	f3 0f 2a 44 05
	e0		 cvtsi2ss xmm0, DWORD PTR _rootbbox$[ebp+eax]
  001fb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00203	8b 4d f4	 mov	 ecx, DWORD PTR _rootpv$[ebp]
  00206	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 1014 : 	rootpv++;

  0020b	8b 45 f4	 mov	 eax, DWORD PTR _rootpv$[ebp]
  0020e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00211	89 45 f4	 mov	 DWORD PTR _rootpv$[ebp], eax

; 1015 : 
; 1016 : 	WalkBSPNode(bspnum, rootp, NULL,rootbbox);

  00214	8d 45 e0	 lea	 eax, DWORD PTR _rootbbox$[ebp]
  00217	50		 push	 eax
  00218	6a 00		 push	 0
  0021a	8b 4d f8	 mov	 ecx, DWORD PTR _rootp$[ebp]
  0021d	51		 push	 ecx
  0021e	8b 55 08	 mov	 edx, DWORD PTR _bspnum$[ebp]
  00221	52		 push	 edx
  00222	e8 00 00 00 00	 call	 _WalkBSPNode
  00227	83 c4 10	 add	 esp, 16			; 00000010H

; 1017 : 
; 1018 : 	i = SolveTProblem();

  0022a	e8 00 00 00 00	 call	 _SolveTProblem
  0022f	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 1019 : 	//CONS_Printf("%d point div a polygone line\n",i);
; 1020 : 	AdjustSegs();

  00232	e8 00 00 00 00	 call	 _AdjustSegs
  00237	90		 npad	 1

; 1021 : 
; 1022 : 	//debug debug..
; 1023 : 	//if (nobackpoly)
; 1024 : 	//    CONS_Printf("no back polygon %u times\n",nobackpoly);
; 1025 : 	//"(should happen only with the deep water trick)"
; 1026 : 	//if (skipcut)
; 1027 : 	//    CONS_Printf("%u cuts were skipped because of only one point\n",skipcut);
; 1028 : 
; 1029 : 	//CONS_Printf("done: %u total subsector convex polygons\n", totalsubsecpolys);
; 1030 : }

  00238	5f		 pop	 edi
  00239	5e		 pop	 esi
  0023a	5b		 pop	 ebx
  0023b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023e	33 cd		 xor	 ecx, ebp
  00240	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00245	8b e5		 mov	 esp, ebp
  00247	5d		 pop	 ebp
  00248	c3		 ret	 0
_HWR_CreatePlanePolygons ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
