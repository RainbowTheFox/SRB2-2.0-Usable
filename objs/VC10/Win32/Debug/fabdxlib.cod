; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\fabdxlib.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_DDr2
PUBLIC	_ScreenReal
PUBLIC	_ScreenVirtual
PUBLIC	_DDPalette
PUBLIC	_windowPosX
PUBLIC	_windowPosY
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_DDr2	DD	01H DUP (?)
_ScreenReal DD	01H DUP (?)
_ScreenVirtual DD 01H DUP (?)
_DDPalette DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_bAppFullScreen:DWORD
_DATA	ENDS
_BSS	SEGMENT
_windowPosX DD	01H DUP (?)
_windowPosY DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_ScreenWidth:DWORD
COMM	_ScreenHeight:DWORD
COMM	_ScreenLocked:DWORD
COMM	_ScreenPitch:DWORD
COMM	_ScreenPtr:DWORD
_DATA	ENDS
PUBLIC	_EnumDirectDrawDisplayModes
PUBLIC	_CreateDirectDrawInstance
PUBLIC	_InitDirectDrawe
PUBLIC	_CloseDirectDraw
PUBLIC	_ReleaseChtuff
PUBLIC	_ClearSurface
PUBLIC	_ScreenFlip
PUBLIC	_TextPrint
PUBLIC	_CreateDDPalette
PUBLIC	_DestroyDDPalette
PUBLIC	_SetDDPalette
PUBLIC	_RestoreDDPalette
PUBLIC	_WaitVbl
PUBLIC	_LockScreen
PUBLIC	_UnlockScreen
PUBLIC	??_C@_09KDGFPKMD@DDRAW?4DLL@			; `string'
PUBLIC	??_C@_0BB@BNCGIPPP@DirectDrawCreate@		; `string'
PUBLIC	??_C@_0BM@LDBKKLEC@DirectDrawCreate?5FAILED?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CK@PBMKIBDN@Failed?5to?5query?5DirectDraw2?5int@ ; `string'
PUBLIC	??_C@_0CA@HOJKEIJH@SetCooperativeLevel?5FAILED?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@ELFPCJGM@SetDisplayMode?5FAILED?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CE@PPFGDHGL@CreateSurface?5Primary?5Screen?5FA@ ; `string'
PUBLIC	??_C@_0BK@PBBHBLBF@GetAttachedSurface?5FAILED@	; `string'
PUBLIC	??_C@_0BL@JCLFBICE@SetCooperativeLevel?5FAILED@	; `string'
PUBLIC	??_C@_0CG@FBGGFFPI@CreateSurface?5Secondary?5Screen?5@ ; `string'
PUBLIC	??_C@_0BF@IGMEMDFF@CreateClipper?5FAILED@	; `string'
PUBLIC	??_C@_0BL@IBMDAENO@Clipper?5?9?$DO?5SetHWnd?5?5FAILED@ ; `string'
PUBLIC	??_C@_0CL@LEAPJBCA@PrimaryScreen?5?9?$DO?5SetClipperClip@ ; `string'
PUBLIC	??_C@_0DB@JIFGMALO@ScreenFlip?$CI?$CJ?5?3?5couldn?8t?5Flip?5su@ ; `string'
PUBLIC	??_C@_0BO@HJCEIMFC@Couldn?8t?5UnLock?5the?5renderer?$CB@ ; `string'
PUBLIC	??_C@_0BH@BMACOPOI@couldn?8t?5CreatePalette@	; `string'
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__SetBkMode@8:PROC
EXTRN	__imp__SetTextColor@8:PROC
EXTRN	__imp__TextOutA@20:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__GetMenu@4:PROC
EXTRN	__imp__AdjustWindowRectEx@16:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	_I_Error:PROC
EXTRN	_DXErrorToString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_IID_IDirectDraw2:BYTE
EXTRN	_bDX0300:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_windclip DD	01H DUP (?)
_DDrawDLL DD	01H DUP (?)
_pfnDirectDrawCreate DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BH@BMACOPOI@couldn?8t?5CreatePalette@
CONST	SEGMENT
??_C@_0BH@BMACOPOI@couldn?8t?5CreatePalette@ DB 'couldn''t CreatePalette', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HJCEIMFC@Couldn?8t?5UnLock?5the?5renderer?$CB@
CONST	SEGMENT
??_C@_0BO@HJCEIMFC@Couldn?8t?5UnLock?5the?5renderer?$CB@ DB 'Couldn''t Un'
	DB	'Lock the renderer!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JIFGMALO@ScreenFlip?$CI?$CJ?5?3?5couldn?8t?5Flip?5su@
CONST	SEGMENT
??_C@_0DB@JIFGMALO@ScreenFlip?$CI?$CJ?5?3?5couldn?8t?5Flip?5su@ DB 'Scree'
	DB	'nFlip() : couldn''t Flip surfaces because %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LEAPJBCA@PrimaryScreen?5?9?$DO?5SetClipperClip@
CONST	SEGMENT
??_C@_0CL@LEAPJBCA@PrimaryScreen?5?9?$DO?5SetClipperClip@ DB 'PrimaryScre'
	DB	'en -> SetClipperClipper  FAILED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IBMDAENO@Clipper?5?9?$DO?5SetHWnd?5?5FAILED@
CONST	SEGMENT
??_C@_0BL@IBMDAENO@Clipper?5?9?$DO?5SetHWnd?5?5FAILED@ DB 'Clipper -> Set'
	DB	'HWnd  FAILED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGMEMDFF@CreateClipper?5FAILED@
CONST	SEGMENT
??_C@_0BF@IGMEMDFF@CreateClipper?5FAILED@ DB 'CreateClipper FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FBGGFFPI@CreateSurface?5Secondary?5Screen?5@
CONST	SEGMENT
??_C@_0CG@FBGGFFPI@CreateSurface?5Secondary?5Screen?5@ DB 'CreateSurface '
	DB	'Secondary Screen FAILED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JCLFBICE@SetCooperativeLevel?5FAILED@
CONST	SEGMENT
??_C@_0BL@JCLFBICE@SetCooperativeLevel?5FAILED@ DB 'SetCooperativeLevel F'
	DB	'AILED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PBBHBLBF@GetAttachedSurface?5FAILED@
CONST	SEGMENT
??_C@_0BK@PBBHBLBF@GetAttachedSurface?5FAILED@ DB 'GetAttachedSurface FAI'
	DB	'LED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PPFGDHGL@CreateSurface?5Primary?5Screen?5FA@
CONST	SEGMENT
??_C@_0CE@PPFGDHGL@CreateSurface?5Primary?5Screen?5FA@ DB 'CreateSurface '
	DB	'Primary Screen FAILED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELFPCJGM@SetDisplayMode?5FAILED?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@ELFPCJGM@SetDisplayMode?5FAILED?3?5?$CFs?6@ DB 'SetDisplayMode '
	DB	'FAILED: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HOJKEIJH@SetCooperativeLevel?5FAILED?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@HOJKEIJH@SetCooperativeLevel?5FAILED?3?5?$CFs?6@ DB 'SetCoopera'
	DB	'tiveLevel FAILED: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PBMKIBDN@Failed?5to?5query?5DirectDraw2?5int@
CONST	SEGMENT
??_C@_0CK@PBMKIBDN@Failed?5to?5query?5DirectDraw2?5int@ DB 'Failed to que'
	DB	'ry DirectDraw2 interface: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LDBKKLEC@DirectDrawCreate?5FAILED?3?5?$CFs@
CONST	SEGMENT
??_C@_0BM@LDBKKLEC@DirectDrawCreate?5FAILED?3?5?$CFs@ DB 'DirectDrawCreat'
	DB	'e FAILED: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BNCGIPPP@DirectDrawCreate@
CONST	SEGMENT
??_C@_0BB@BNCGIPPP@DirectDrawCreate@ DB 'DirectDrawCreate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDGFPKMD@DDRAW?4DLL@
CONST	SEGMENT
??_C@_09KDGFPKMD@DDRAW?4DLL@ DB 'DDRAW.DLL', 00H	; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	08aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0daH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0183H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03f0H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _UnLoadDirectDraw
_TEXT	SEGMENT
_UnLoadDirectDraw PROC					; COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 158  : 	if (!DDrawDLL)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDrawDLL, 0
  00010	75 02		 jne	 SHORT $LN2@UnLoadDire

; 159  : 		return;

  00012	eb 21		 jmp	 SHORT $LN1@UnLoadDire
$LN2@UnLoadDire:

; 160  : 	FreeLibrary(DDrawDLL);

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDrawDLL
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00020	90		 npad	 1

; 161  : 	pfnDirectDrawCreate = NULL;

  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pfnDirectDrawCreate, 0

; 162  : 	DDrawDLL = NULL;

  0002b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DDrawDLL, 0
$LN1@UnLoadDire:

; 163  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_UnLoadDirectDraw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _LoadDirectDraw
_TEXT	SEGMENT
_LoadDirectDraw PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 146  : 	// load ddraw.dll
; 147  : 	DDrawDLL = LoadLibraryA("DDRAW.DLL");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_09KDGFPKMD@DDRAW?4DLL@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00014	a3 00 00 00 00	 mov	 DWORD PTR _DDrawDLL, eax

; 148  : 	if (DDrawDLL == NULL)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDrawDLL, 0
  00020	75 04		 jne	 SHORT $LN2@LoadDirect

; 149  : 		return false;

  00022	33 c0		 xor	 eax, eax
  00024	eb 28		 jmp	 SHORT $LN1@LoadDirect
$LN2@LoadDirect:

; 150  : 	pfnDirectDrawCreate = (DDCreate)GetProcAddress(DDrawDLL, "DirectDrawCreate");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BNCGIPPP@DirectDrawCreate@
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDrawDLL
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	a3 00 00 00 00	 mov	 DWORD PTR _pfnDirectDrawCreate, eax

; 151  : 	if (pfnDirectDrawCreate == NULL)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnDirectDrawCreate, 0
  00043	75 04		 jne	 SHORT $LN3@LoadDirect

; 152  : 		return false;

  00045	33 c0		 xor	 eax, eax
  00047	eb 05		 jmp	 SHORT $LN1@LoadDirect
$LN3@LoadDirect:

; 153  : 	return true;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN1@LoadDirect:

; 154  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_LoadDirectDraw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _myEnumModesCallback@8
_TEXT	SEGMENT
_pfnContext$ = -4					; size = 4
_surf$ = 8						; size = 4
_lpContext$ = 12					; size = 4
_myEnumModesCallback@8 PROC				; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 98   : 	APPENUMMODESCALLBACK pfnContext = lpContext;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpContext$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pfnContext$[ebp], eax

; 99   : 
; 100  : 	if (pfnContext) pfnContext(surf->dwWidth,

  0000f	83 7d fc 00	 cmp	 DWORD PTR _pfnContext$[ebp], 0
  00013	74 1b		 je	 SHORT $LN2@myEnumMode
  00015	8b 45 08	 mov	 eax, DWORD PTR _surf$[ebp]
  00018	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR _surf$[ebp]
  0001f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _surf$[ebp]
  00026	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00029	52		 push	 edx
  0002a	ff 55 fc	 call	 DWORD PTR _pfnContext$[ebp]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@myEnumMode:

; 101  : 		surf->dwHeight,surf->ddpfPixelFormat.
; 102  : #ifdef DUMMYUNIONNAMEN
; 103  : 		DUMMYUNIONNAMEN(1).
; 104  : #endif
; 105  : 		dwRGBBitCount
; 106  : 		);
; 107  : 
; 108  : 		/*CONS_Printf ("%dx%dx%d bpp %d refresh\n",
; 109  : 		surf->dwWidth,
; 110  : 		surf->dwHeight,
; 111  : 		surf->ddpfPixelFormat.dwRGBBitCount,
; 112  : 	surf->dwRefreshRate);*/
; 113  : 
; 114  : 	return  DDENUMRET_OK;

  00030	b8 01 00 00 00	 mov	 eax, 1

; 115  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_myEnumModesCallback@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _CreateNewSurface
_TEXT	SEGMENT
_psurf$ = -120						; size = 4
_hr$ = -116						; size = 4
_ddsd$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_dwWidth$ = 8						; size = 4
_dwHeight$ = 12						; size = 4
_dwSurfaceCaps$ = 16					; size = 4
_CreateNewSurface PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 64   : 	DDSURFACEDESC       ddsd;
; 65   : 	HRESULT             hr;
; 66   : 	LPDIRECTDRAWSURFACE psurf;
; 67   : 
; 68   : 	ZeroMemory(&ddsd, sizeof (ddsd));

  00016	6a 6c		 push	 108			; 0000006cH
  00018	6a 00		 push	 0
  0001a	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 69   : 	ddsd.dwSize = sizeof (ddsd);

  00026	c7 45 90 6c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp], 108 ; 0000006cH

; 70   : 	ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH;

  0002d	c7 45 94 07 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp+4], 7

; 71   : 
; 72   : 	ddsd.ddsCaps.dwCaps = dwSurfaceCaps;

  00034	8b 45 10	 mov	 eax, DWORD PTR _dwSurfaceCaps$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR _ddsd$[ebp+104], eax

; 73   : 
; 74   : 	ddsd.dwHeight = dwHeight;

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _dwHeight$[ebp]
  0003d	89 45 98	 mov	 DWORD PTR _ddsd$[ebp+8], eax

; 75   : 	ddsd.dwWidth = dwWidth;

  00040	8b 45 08	 mov	 eax, DWORD PTR _dwWidth$[ebp]
  00043	89 45 9c	 mov	 DWORD PTR _ddsd$[ebp+12], eax

; 76   : 
; 77   : 	hr = IDirectDraw2_CreateSurface (DDr2, &ddsd, &psurf, NULL);

  00046	6a 00		 push	 0
  00048	8d 45 88	 lea	 eax, DWORD PTR _psurf$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d 90	 lea	 ecx, DWORD PTR _ddsd$[ebp]
  0004f	51		 push	 ecx
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  00056	52		 push	 edx
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDr2
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00061	ff d2		 call	 edx
  00063	89 45 8c	 mov	 DWORD PTR _hr$[ebp], eax

; 78   : 
; 79   : 	if (hr == DD_OK)

  00066	83 7d 8c 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006a	75 11		 jne	 SHORT $LN2@CreateNewS

; 80   : 	{
; 81   : 		//DDCOLORKEY ddck;
; 82   : 		IDirectDrawSurface_Restore(psurf);

  0006c	8b 45 88	 mov	 eax, DWORD PTR _psurf$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 88	 mov	 ecx, DWORD PTR _psurf$[ebp]
  00073	8b 11		 mov	 edx, DWORD PTR [ecx]
  00075	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00078	ff d0		 call	 eax
  0007a	90		 npad	 1

; 83   : 
; 84   : 		//hr = IDirectDrawSurface_GetColorKey(DDCKEY_SRCBLT, &ddck);
; 85   : 		//psurf->SetColorKey(DDCKEY_SRCBLT, &ddck);
; 86   : 	}

  0007b	eb 07		 jmp	 SHORT $LN3@CreateNewS
$LN2@CreateNewS:

; 87   : 	else
; 88   : 		psurf = NULL;

  0007d	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _psurf$[ebp], 0
$LN3@CreateNewS:

; 89   : 
; 90   : 	return psurf;

  00084	8b 45 88	 mov	 eax, DWORD PTR _psurf$[ebp]

; 91   : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_CreateNewSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _UnlockScreen
_TEXT	SEGMENT
_UnlockScreen PROC					; COMDAT

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 558  : 	if (DD_OK != IDirectDrawSurface_Unlock(ScreenVirtual,NULL))

  00009	6a 00		 push	 0
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenVirtual
  00010	50		 push	 eax
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	8b 82 80 00 00
	00		 mov	 eax, DWORD PTR [edx+128]
  0001f	ff d0		 call	 eax
  00021	85 c0		 test	 eax, eax
  00023	74 0d		 je	 SHORT $LN2@UnlockScre

; 559  : 		I_Error("Couldn't UnLock the renderer!");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HJCEIMFC@Couldn?8t?5UnLock?5the?5renderer?$CB@
  0002a	e8 00 00 00 00	 call	 _I_Error
  0002f	83 c4 04	 add	 esp, 4
$LN2@UnlockScre:

; 560  : 
; 561  : 	ScreenLocked = FALSE;

  00032	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenLocked, 0

; 562  : 	ScreenPtr    = NULL;

  0003c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenPtr, 0

; 563  : 	ScreenPitch = 0;

  00046	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenPitch, 0

; 564  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_UnlockScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _LockScreen
_TEXT	SEGMENT
_ddrval$ = -116						; size = 4
_ddsd$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_LockScreen PROC					; COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 513  : 	DDSURFACEDESC ddsd;
; 514  : 	HRESULT ddrval;
; 515  : 
; 516  : 	ZeroMemory(&ddsd, sizeof (ddsd));

  00016	6a 6c		 push	 108			; 0000006cH
  00018	6a 00		 push	 0
  0001a	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 	ddsd.dwSize = sizeof (ddsd);

  00026	c7 45 90 6c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp], 108 ; 0000006cH

; 518  : 
; 519  : 	// attempt to Lock the surface
; 520  : 	ddrval = IDirectDrawSurface_Lock(ScreenVirtual, NULL, &ddsd, DDLOCK_WAIT, NULL);

  0002d	6a 00		 push	 0
  0002f	6a 01		 push	 1
  00031	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  00034	50		 push	 eax
  00035	6a 00		 push	 0
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  0003d	51		 push	 ecx
  0003e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenVirtual
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00049	ff d1		 call	 ecx
  0004b	89 45 8c	 mov	 DWORD PTR _ddrval$[ebp], eax

; 521  : 
; 522  : 	// Always, always check for errors with DirectX!
; 523  : 	// If the surface was lost, restore it.
; 524  : 	if (ddrval == DDERR_SURFACELOST)

  0004e	81 7d 8c c2 01
	76 88		 cmp	 DWORD PTR _ddrval$[ebp], -2005532222 ; 887601c2H
  00055	75 37		 jne	 SHORT $LN2@LockScreen

; 525  : 	{
; 526  : 		ddrval = IDirectDrawSurface_Restore(ScreenReal);

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  0005c	50		 push	 eax
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00068	ff d0		 call	 eax
  0006a	89 45 8c	 mov	 DWORD PTR _ddrval$[ebp], eax

; 527  : 
; 528  : 		// now retry to get the lock
; 529  : 		ddrval = IDirectDrawSurface_Lock(ScreenVirtual, NULL, &ddsd, DDLOCK_WAIT, NULL);

  0006d	6a 00		 push	 0
  0006f	6a 01		 push	 1
  00071	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  00074	50		 push	 eax
  00075	6a 00		 push	 0
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  0007d	51		 push	 ecx
  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenVirtual
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00089	ff d1		 call	 ecx
  0008b	89 45 8c	 mov	 DWORD PTR _ddrval$[ebp], eax
$LN2@LockScreen:

; 530  : 	}
; 531  : 
; 532  : 	if (ddrval == DD_OK)

  0008e	83 7d 8c 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  00092	75 1c		 jne	 SHORT $LN3@LockScreen

; 533  : 	{
; 534  : 		ScreenLocked = TRUE;

  00094	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ScreenLocked, 1

; 535  : 		ScreenPtr    = (LPBYTE)ddsd.lpSurface;

  0009e	8b 45 b4	 mov	 eax, DWORD PTR _ddsd$[ebp+36]
  000a1	a3 00 00 00 00	 mov	 DWORD PTR _ScreenPtr, eax

; 536  : 		ScreenPitch = ddsd.

  000a6	8b 45 a0	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  000a9	a3 00 00 00 00	 mov	 DWORD PTR _ScreenPitch, eax

; 537  : #ifdef DUMMYUNIONNAMEN
; 538  : 		 DUMMYUNIONNAMEN(1).
; 539  : #endif
; 540  : 		 lPitch;
; 541  : 	}

  000ae	eb 22		 jmp	 SHORT $LN4@LockScreen
$LN3@LockScreen:

; 542  : 	else
; 543  : 	{
; 544  : 		ScreenLocked = FALSE;

  000b0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenLocked, 0

; 545  : 		ScreenPtr = NULL;

  000ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenPtr, 0

; 546  : 		ScreenPitch = 0;

  000c4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenPitch, 0

; 547  : 		//I_Error("LockScreen() : couldn't restore the surface.");
; 548  : 		return false;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 05		 jmp	 SHORT $LN1@LockScreen
$LN4@LockScreen:

; 549  : 	}
; 550  : 	return true;

  000d2	b8 01 00 00 00	 mov	 eax, 1
$LN1@LockScreen:

; 551  : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 cd		 xor	 ecx, ebp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_LockScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _WaitVbl
_TEXT	SEGMENT
_WaitVbl PROC						; COMDAT

; 665  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 666  : 	IDirectDraw2_WaitForVerticalBlank(DDr2, DDWAITVB_BLOCKBEGIN, NULL);

  00009	6a 00		 push	 0
  0000b	6a 01		 push	 1
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDr2
  00012	50		 push	 eax
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0001e	ff d0		 call	 eax
  00020	90		 npad	 1

; 667  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_WaitVbl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _RestoreDDPalette
_TEXT	SEGMENT
_RestoreDDPalette PROC					; COMDAT

; 674  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 675  : 	if (DDPalette)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDPalette, 0
  00010	74 1b		 je	 SHORT $LN2@RestoreDDP

; 676  : 		IDirectDrawSurface_SetPalette(ScreenReal, DDPalette);

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDPalette
  00017	50		 push	 eax
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  0001e	51		 push	 ecx
  0001f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenReal
  00025	8b 02		 mov	 eax, DWORD PTR [edx]
  00027	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0002a	ff d1		 call	 ecx
  0002c	90		 npad	 1
$LN2@RestoreDDP:

; 677  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_RestoreDDPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _SetDDPalette
_TEXT	SEGMENT
_pal$ = 8						; size = 4
_SetDDPalette PROC					; COMDAT

; 650  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 651  : 	// create palette first time
; 652  : 	if (DDPalette == NULL)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDPalette, 0
  00010	75 0e		 jne	 SHORT $LN2@SetDDPalet

; 653  : 		CreateDDPalette(pal);

  00012	8b 45 08	 mov	 eax, DWORD PTR _pal$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _CreateDDPalette
  0001b	83 c4 04	 add	 esp, 4
  0001e	eb 22		 jmp	 SHORT $LN3@SetDDPalet
$LN2@SetDDPalet:

; 654  : 	else
; 655  : 		IDirectDrawPalette_SetEntries(DDPalette, 0, 0, 256, pal);

  00020	8b 45 08	 mov	 eax, DWORD PTR _pal$[ebp]
  00023	50		 push	 eax
  00024	68 00 01 00 00	 push	 256			; 00000100H
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDPalette
  00033	51		 push	 ecx
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDPalette
  0003a	8b 02		 mov	 eax, DWORD PTR [edx]
  0003c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003f	ff d1		 call	 ecx
  00041	90		 npad	 1
$LN3@SetDDPalet:

; 656  : 	// setting the same palette to the same surface again does not increase
; 657  : 	// the reference count
; 658  : 	IDirectDrawSurface_SetPalette(ScreenReal, DDPalette);

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDPalette
  00047	50		 push	 eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  0004e	51		 push	 ecx
  0004f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenReal
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0005a	ff d1		 call	 ecx
  0005c	90		 npad	 1

; 659  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_SetDDPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _DestroyDDPalette
_TEXT	SEGMENT
_DestroyDDPalette PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 639  : 	if (DDPalette)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDPalette, 0
  00010	74 1e		 je	 SHORT $LN2@DestroyDDP

; 640  : 	{
; 641  : 		IDirectDrawPalette_Release(DDPalette);

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDPalette
  00017	50		 push	 eax
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDPalette
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	ff d0		 call	 eax
  00025	90		 npad	 1

; 642  : 		DDPalette = NULL;

  00026	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DDPalette, 0
$LN2@DestroyDDP:

; 643  : 	}
; 644  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_DestroyDDPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _CreateDDPalette
_TEXT	SEGMENT
_ddrval$ = -4						; size = 4
_colorTable$ = 8					; size = 4
_CreateDDPalette PROC					; COMDAT

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  : 	HRESULT  ddrval;
; 628  : 	ddrval = IDirectDraw2_CreatePalette(DDr2,DDPCAPS_8BIT|DDPCAPS_ALLOW256, colorTable, &DDPalette, NULL);

  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET _DDPalette
  00010	8b 45 08	 mov	 eax, DWORD PTR _colorTable$[ebp]
  00013	50		 push	 eax
  00014	6a 44		 push	 68			; 00000044H
  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  0001c	51		 push	 ecx
  0001d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00028	ff d1		 call	 ecx
  0002a	89 45 fc	 mov	 DWORD PTR _ddrval$[ebp], eax

; 629  : 	if (ddrval != DD_OK)

  0002d	83 7d fc 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  00031	74 0d		 je	 SHORT $LN2@CreateDDPa

; 630  : 		I_Error("couldn't CreatePalette");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BMACOPOI@couldn?8t?5CreatePalette@
  00038	e8 00 00 00 00	 call	 _I_Error
  0003d	83 c4 04	 add	 esp, 4
$LN2@CreateDDPa:

; 631  : };

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_CreateDDPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _TextPrint
_TEXT	SEGMENT
_hdc$ = -8						; size = 4
_hr$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_message$ = 16						; size = 4
_TextPrint PROC						; COMDAT

; 490  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 491  : 	HRESULT hr;
; 492  : 	HDC hdc = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hdc$[ebp], 0

; 493  : 
; 494  : 	// Get the device context handle.
; 495  : 	hr = IDirectDrawSurface_GetDC(ScreenVirtual,&hdc);

  00010	8d 45 f8	 lea	 eax, DWORD PTR _hdc$[ebp]
  00013	50		 push	 eax
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  0001a	51		 push	 ecx
  0001b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenVirtual
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00026	ff d1		 call	 ecx
  00028	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 496  : 	if (hr != DD_OK)

  0002b	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002f	74 02		 je	 SHORT $LN2@TextPrint

; 497  : 		return;

  00031	eb 5c		 jmp	 SHORT $LN1@TextPrint
$LN2@TextPrint:

; 498  : 
; 499  : 	// Write the message.
; 500  : 	SetBkMode(hdc, TRANSPARENT);

  00033	6a 01		 push	 1
  00035	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkMode@8
  0003f	90		 npad	 1

; 501  : 	SetTextColor(hdc, RGB(255, 255, 255));

  00040	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  00045	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  0004f	90		 npad	 1

; 502  : 	TextOutA(hdc, x, y, message, (int)strlen(message));

  00050	8b 45 10	 mov	 eax, DWORD PTR _message$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _strlen
  00059	83 c4 04	 add	 esp, 4
  0005c	50		 push	 eax
  0005d	8b 4d 10	 mov	 ecx, DWORD PTR _message$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00064	52		 push	 edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00068	50		 push	 eax
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0006c	51		 push	 ecx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20
  00073	90		 npad	 1

; 503  : 
; 504  : 	// Release the device context.
; 505  : 	hr = IDirectDrawSurface_ReleaseDC(ScreenVirtual,hdc);

  00074	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00077	50		 push	 eax
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  0007e	51		 push	 ecx
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenVirtual
  00085	8b 02		 mov	 eax, DWORD PTR [edx]
  00087	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0008a	ff d1		 call	 ecx
  0008c	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
$LN1@TextPrint:

; 506  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_TextPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _ScreenFlip
_TEXT	SEGMENT
_rect$ = -24						; size = 16
_hr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_waitflip$ = 8						; size = 4
_ScreenFlip PROC					; COMDAT

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 436  : 	HRESULT hr;
; 437  : 	RECT rect;
; 438  : 
; 439  : 	UNREFERENCED_PARAMETER(waitflip);
; 440  : 	if (bAppFullScreen)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  0001a	74 56		 je	 SHORT $LN2@ScreenFlip

; 441  : 	{
; 442  : 		//hr = IDirectDrawSurface_GetFlipStatus (ScreenReal, DDGFS_);
; 443  : 
; 444  : 		// In full-screen exclusive mode, do a hardware flip.
; 445  : 		hr = IDirectDrawSurface_Flip(ScreenReal, NULL, DDFLIP_WAIT);   //return immediately

  0001c	6a 01		 push	 1
  0001e	6a 00		 push	 0
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  00025	50		 push	 eax
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00031	ff d0		 call	 eax
  00033	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 446  : 
; 447  : 		// If the surface was lost, restore it.
; 448  : 		if (hr == DDERR_SURFACELOST)

  00036	81 7d f8 c2 01
	76 88		 cmp	 DWORD PTR _hr$[ebp], -2005532222 ; 887601c2H
  0003d	75 2e		 jne	 SHORT $LN4@ScreenFlip

; 449  : 		{
; 450  : 			IDirectDrawSurface_Restore(ScreenReal);

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  00044	50		 push	 eax
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00050	ff d0		 call	 eax
  00052	90		 npad	 1

; 451  : 
; 452  : 			// The restore worked, so try the flip again.
; 453  : 			hr = IDirectDrawSurface_Flip(ScreenReal, 0, DDFLIP_WAIT);

  00053	6a 01		 push	 1
  00055	6a 00		 push	 0
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  0005c	50		 push	 eax
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00068	ff d0		 call	 eax
  0006a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$LN4@ScreenFlip:

; 454  : 		}
; 455  : 	}

  0006d	e9 ec 00 00 00	 jmp	 $LN5@ScreenFlip
$LN2@ScreenFlip:

; 456  : 	else
; 457  : 	{
; 458  : 		rect.left = windowPosX;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowPosX
  00077	89 45 e8	 mov	 DWORD PTR _rect$[ebp], eax

; 459  : 		rect.top = windowPosY;

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowPosY
  0007f	89 45 ec	 mov	 DWORD PTR _rect$[ebp+4], eax

; 460  : 		rect.right = windowPosX + ScreenWidth - 1;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenWidth
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _windowPosX
  0008d	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00091	89 55 f0	 mov	 DWORD PTR _rect$[ebp+8], edx

; 461  : 		rect.bottom = windowPosY + ScreenHeight - 1;

  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenHeight
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _windowPosY
  0009f	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  000a3	89 55 f4	 mov	 DWORD PTR _rect$[ebp+12], edx

; 462  : 
; 463  : 		// Copy the back buffer to front.
; 464  : 		hr = IDirectDrawSurface_Blt(ScreenReal, &rect, ScreenVirtual, 0, DDBLT_WAIT, 0);

  000a6	6a 00		 push	 0
  000a8	68 00 00 00 01	 push	 16777216		; 01000000H
  000ad	6a 00		 push	 0
  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenVirtual
  000b4	50		 push	 eax
  000b5	8d 4d e8	 lea	 ecx, DWORD PTR _rect$[ebp]
  000b8	51		 push	 ecx
  000b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenReal
  000bf	52		 push	 edx
  000c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  000c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c7	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000ca	ff d2		 call	 edx
  000cc	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 465  : 
; 466  : 		if (hr != DD_OK)

  000cf	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d3	0f 84 85 00 00
	00		 je	 $LN5@ScreenFlip

; 467  : 		{
; 468  : 			// If the surfaces were lost, restore them.
; 469  : 			if (IDirectDrawSurface_IsLost(ScreenReal) == DDERR_SURFACELOST)

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  000de	50		 push	 eax
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000ea	ff d0		 call	 eax
  000ec	3d c2 01 76 88	 cmp	 eax, -2005532222	; 887601c2H
  000f1	75 14		 jne	 SHORT $LN6@ScreenFlip

; 470  : 				IDirectDrawSurface_Restore(ScreenReal);

  000f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  000f8	50		 push	 eax
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  000ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00101	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00104	ff d0		 call	 eax
  00106	90		 npad	 1
$LN6@ScreenFlip:

; 471  : 
; 472  : 			if (IDirectDrawSurface_IsLost(ScreenVirtual) == DDERR_SURFACELOST)

  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenVirtual
  0010c	50		 push	 eax
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  00113	8b 11		 mov	 edx, DWORD PTR [ecx]
  00115	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00118	ff d0		 call	 eax
  0011a	3d c2 01 76 88	 cmp	 eax, -2005532222	; 887601c2H
  0011f	75 14		 jne	 SHORT $LN7@ScreenFlip

; 473  : 				IDirectDrawSurface_Restore(ScreenVirtual);

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenVirtual
  00126	50		 push	 eax
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  0012d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012f	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00132	ff d0		 call	 eax
  00134	90		 npad	 1
$LN7@ScreenFlip:

; 474  : 
; 475  : 			// Retry the copy.
; 476  : 			hr = IDirectDrawSurface_Blt(ScreenReal,&rect, ScreenVirtual, 0, DDBLT_WAIT, 0);

  00135	6a 00		 push	 0
  00137	68 00 00 00 01	 push	 16777216		; 01000000H
  0013c	6a 00		 push	 0
  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenVirtual
  00143	50		 push	 eax
  00144	8d 4d e8	 lea	 ecx, DWORD PTR _rect$[ebp]
  00147	51		 push	 ecx
  00148	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenReal
  0014e	52		 push	 edx
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  00154	8b 08		 mov	 ecx, DWORD PTR [eax]
  00156	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00159	ff d2		 call	 edx
  0015b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$LN5@ScreenFlip:

; 477  : 		}
; 478  : 	}
; 479  : 
; 480  : 	if (hr != DD_OK)

  0015e	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00162	74 1a		 je	 SHORT $LN8@ScreenFlip

; 481  : 		I_Error("ScreenFlip() : couldn't Flip surfaces because %s", DXErrorToString(hr));

  00164	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _DXErrorToString
  0016d	83 c4 04	 add	 esp, 4
  00170	50		 push	 eax
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JIFGMALO@ScreenFlip?$CI?$CJ?5?3?5couldn?8t?5Flip?5su@
  00176	e8 00 00 00 00	 call	 _I_Error
  0017b	83 c4 08	 add	 esp, 8
$LN8@ScreenFlip:

; 482  : 
; 483  : 	return FALSE;

  0017e	33 c0		 xor	 eax, eax

; 484  : }

  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	5b		 pop	 ebx
  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
_ScreenFlip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _ClearSurface
_TEXT	SEGMENT
_ddbltfx$ = -100					; size = 100
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_ClearSurface PROC					; COMDAT

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 415  : 	DDBLTFX ddbltfx;
; 416  : 
; 417  : 	// Use the blter to do a color fill to clear the back buffer
; 418  : 	ddbltfx.dwSize = sizeof (ddbltfx);

  0000c	c7 45 9c 64 00
	00 00		 mov	 DWORD PTR _ddbltfx$[ebp], 100 ; 00000064H

; 419  : 	ddbltfx.

  00013	8b 45 0c	 mov	 eax, DWORD PTR _color$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR _ddbltfx$[ebp+80], eax

; 420  : #ifdef DUMMYUNIONNAMEN
; 421  : 	 DUMMYUNIONNAMEN(5).
; 422  : #endif
; 423  : 	 dwFillColor = color;
; 424  : 	IDirectDrawSurface_Blt(surface,NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);

  00019	8d 45 9c	 lea	 eax, DWORD PTR _ddbltfx$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 04 00 01	 push	 16778240		; 01000400H
  00022	6a 00		 push	 0
  00024	6a 00		 push	 0
  00026	6a 00		 push	 0
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _surface$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _surface$[ebp]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00034	ff d1		 call	 ecx
  00036	90		 npad	 1

; 425  : 
; 426  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_ClearSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _ReleaseChtuff
_TEXT	SEGMENT
_ReleaseChtuff PROC					; COMDAT

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 380  : 	if (!DDr2)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDr2, 0
  00010	75 05		 jne	 SHORT $LN2@ReleaseCht

; 381  : 		return;

  00012	e9 a5 00 00 00	 jmp	 $LN6@ReleaseCht
$LN2@ReleaseCht:

; 382  : 	if (windclip)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _windclip, 0
  0001e	74 1e		 je	 SHORT $LN3@ReleaseCht

; 383  : 	{
; 384  : 		IDirectDrawClipper_Release(windclip);

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _windclip
  00025	50		 push	 eax
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _windclip
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00031	ff d0		 call	 eax
  00033	90		 npad	 1

; 385  : 		windclip = NULL;

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _windclip, 0
$LN3@ReleaseCht:

; 386  : 	}
; 387  : 	if (DDPalette)

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDPalette, 0
  00045	74 1e		 je	 SHORT $LN4@ReleaseCht

; 388  : 	{
; 389  : 		IDirectDrawPalette_Release(DDPalette);

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDPalette
  0004c	50		 push	 eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDPalette
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00058	ff d0		 call	 eax
  0005a	90		 npad	 1

; 390  : 		DDPalette = NULL;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DDPalette, 0
$LN4@ReleaseCht:

; 391  : 	}
; 392  : 	// If the app is fullscreen, the back buffer is attached to the
; 393  : 	// primary. Releasing the primary buffer will also release any
; 394  : 	// attached buffers, so explicitly releasing the back buffer is not
; 395  : 	// necessary.
; 396  : 
; 397  : 	if (!bAppFullScreen && ScreenVirtual)

  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  0006c	75 27		 jne	 SHORT $LN5@ReleaseCht
  0006e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ScreenVirtual, 0
  00075	74 1e		 je	 SHORT $LN5@ReleaseCht

; 398  : 	{
; 399  : 		IDirectDrawSurface_Release(ScreenVirtual);   // release hidden surface

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenVirtual
  0007c	50		 push	 eax
  0007d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenVirtual
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00088	ff d0		 call	 eax
  0008a	90		 npad	 1

; 400  : 		ScreenVirtual = NULL;

  0008b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenVirtual, 0
$LN5@ReleaseCht:

; 401  : 	}
; 402  : 	if (ScreenReal)

  00095	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ScreenReal, 0
  0009c	74 1e		 je	 SHORT $LN6@ReleaseCht

; 403  : 	{
; 404  : 		IDirectDrawSurface_Release(ScreenReal);                      // and attached backbuffers for bAppFullScreen mode

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _ScreenReal
  000a3	50		 push	 eax
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  000aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ac	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000af	ff d0		 call	 eax
  000b1	90		 npad	 1

; 405  : 		ScreenReal = NULL;

  000b2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ScreenReal, 0
$LN6@ReleaseCht:

; 406  : 	}
; 407  : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_ReleaseChtuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _CloseDirectDraw
_TEXT	SEGMENT
_CloseDirectDraw PROC					; COMDAT

; 364  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 365  : 	ReleaseChtuff();

  00009	e8 00 00 00 00	 call	 _ReleaseChtuff
  0000e	90		 npad	 1

; 366  : 	if (DDr2)

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDr2, 0
  00016	74 1e		 je	 SHORT $LN2@CloseDirec

; 367  : 	{
; 368  : 		IDirectDraw2_Release(DDr2);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDr2
  0001d	50		 push	 eax
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00029	ff d0		 call	 eax
  0002b	90		 npad	 1

; 369  : 		DDr2 = NULL;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DDr2, 0
$LN2@CloseDirec:

; 370  : 	}
; 371  : 	UnLoadDirectDraw();

  00036	e8 00 00 00 00	 call	 _UnLoadDirectDraw
  0003b	90		 npad	 1

; 372  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_CloseDirectDraw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _InitDirectDrawe
_TEXT	SEGMENT
tv173 = -208						; size = 4
_rect$ = -140						; size = 16
_dwStyle$ = -124					; size = 4
_ddrval$ = -120						; size = 4
_ddscaps$ = -116					; size = 4
_ddsd$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_appWin$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_bpp$ = 20						; size = 4
_fullScr$ = 24						; size = 4
_InitDirectDrawe PROC					; COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 199  : 	DDSURFACEDESC ddsd; // DirectDraw surface description for allocating
; 200  : 	DDSCAPS       ddscaps;
; 201  : 	HRESULT       ddrval;
; 202  : 
; 203  : 	DWORD         dwStyle;
; 204  : 	RECT          rect;
; 205  : 
; 206  : 	// enumerate directdraw devices
; 207  : 	//if (FAILED(DirectDrawEnumerate (myEnumDDDevicesCallback, NULL)))
; 208  : 	//      I_Error("Error with DirectDrawEnumerate");
; 209  : 
; 210  : 	if (!DDr2)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDr2, 0
  0001d	75 06		 jne	 SHORT $LN2@InitDirect

; 211  : 		CreateDirectDrawInstance();

  0001f	e8 00 00 00 00	 call	 _CreateDirectDrawInstance
  00024	90		 npad	 1
$LN2@InitDirect:

; 212  : 
; 213  : 	// remember what screen mode we are in
; 214  : 	bAppFullScreen = fullScr;

  00025	8b 45 18	 mov	 eax, DWORD PTR _fullScr$[ebp]
  00028	a3 00 00 00 00	 mov	 DWORD PTR _bAppFullScreen, eax

; 215  : 	ScreenHeight = height;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  00030	a3 00 00 00 00	 mov	 DWORD PTR _ScreenHeight, eax

; 216  : 	ScreenWidth = width;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  00038	a3 00 00 00 00	 mov	 DWORD PTR _ScreenWidth, eax

; 217  : 
; 218  : 	if (bAppFullScreen)

  0003d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  00044	0f 84 5f 01 00
	00		 je	 $LN3@InitDirect

; 219  : 	{
; 220  : 		// Change window attributes
; 221  : 		dwStyle = WS_POPUP | WS_VISIBLE;

  0004a	c7 45 84 00 00
	00 90		 mov	 DWORD PTR _dwStyle$[ebp], -1879048192 ; 90000000H

; 222  : 		SetWindowLong (appWin, GWL_STYLE, dwStyle);

  00051	8b 45 84	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  00054	50		 push	 eax
  00055	6a f0		 push	 -16			; fffffff0H
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _appWin$[ebp]
  0005a	51		 push	 ecx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  00061	90		 npad	 1

; 223  : 		SetWindowPos(appWin, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE |

  00062	6a 17		 push	 23			; 00000017H
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a ff		 push	 -1
  0006e	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  00078	90		 npad	 1

; 224  : 			SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
; 225  : 
; 226  : 		// Get exclusive mode
; 227  : 		ddrval = IDirectDraw2_SetCooperativeLevel(DDr2, appWin, DDSCL_EXCLUSIVE |

  00079	6a 13		 push	 19			; 00000013H
  0007b	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  0007e	50		 push	 eax
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  00085	51		 push	 ecx
  00086	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  0008c	8b 02		 mov	 eax, DWORD PTR [edx]
  0008e	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00091	ff d1		 call	 ecx
  00093	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 228  : 		                                          DDSCL_FULLSCREEN |
; 229  : 		                                          DDSCL_ALLOWREBOOT);
; 230  : 		if (ddrval != DD_OK)

  00096	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  0009a	74 1a		 je	 SHORT $LN5@InitDirect

; 231  : 			I_Error("SetCooperativeLevel FAILED: %s\n", DXErrorToString(ddrval));

  0009c	8b 45 88	 mov	 eax, DWORD PTR _ddrval$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _DXErrorToString
  000a5	83 c4 04	 add	 esp, 4
  000a8	50		 push	 eax
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HOJKEIJH@SetCooperativeLevel?5FAILED?3?5?$CFs?6@
  000ae	e8 00 00 00 00	 call	 _I_Error
  000b3	83 c4 08	 add	 esp, 8
$LN5@InitDirect:

; 232  : 
; 233  : 		// Switch from windows desktop to fullscreen
; 234  : 
; 235  : #ifdef NT4COMPAT
; 236  : 		ddrval = IDirectDraw2_SetDisplayMode(DDr2, width, height, bpp, 0, 0);

  000b6	6a 00		 push	 0
  000b8	6a 00		 push	 0
  000ba	8b 45 14	 mov	 eax, DWORD PTR _bpp$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _width$[ebp]
  000c5	52		 push	 edx
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDr2
  000cb	50		 push	 eax
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  000d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d4	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000d7	ff d0		 call	 eax
  000d9	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 237  : #else
; 238  : 		ddrval = IDirectDraw2_SetDisplayMode(DDr2, width, height, bpp, 0, DDSDM_STANDARDVGAMODE);
; 239  : #endif
; 240  : 		if (ddrval != DD_OK)

  000dc	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  000e0	74 1a		 je	 SHORT $LN6@InitDirect

; 241  : 			I_Error("SetDisplayMode FAILED: %s\n", DXErrorToString(ddrval));

  000e2	8b 45 88	 mov	 eax, DWORD PTR _ddrval$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _DXErrorToString
  000eb	83 c4 04	 add	 esp, 4
  000ee	50		 push	 eax
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@ELFPCJGM@SetDisplayMode?5FAILED?3?5?$CFs?6@
  000f4	e8 00 00 00 00	 call	 _I_Error
  000f9	83 c4 08	 add	 esp, 8
$LN6@InitDirect:

; 242  : 
; 243  : 		// This is not really needed, except in certain cases. One case
; 244  : 		// is while using MFC. When the desktop is initally at 16bpp, a mode
; 245  : 		// switch to 8bpp somehow causes the MFC window to not fully initialize
; 246  : 		// and a CreateSurface will fail with DDERR_NOEXCLUSIVEMODE. This will
; 247  : 		// ensure that the window is initialized properly after a mode switch.
; 248  : 
; 249  : 		ShowWindow(appWin, SW_SHOW);

  000fc	6a 05		 push	 5
  000fe	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  00101	50		 push	 eax
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
  00108	90		 npad	 1

; 250  : 
; 251  : 		// Create the primary surface with 1 back buffer. Always zero the
; 252  : 		// DDSURFACEDESC structure and set the dwSize member!
; 253  : 
; 254  : 		ZeroMemory(&ddsd, sizeof (ddsd));

  00109	6a 6c		 push	 108			; 0000006cH
  0010b	6a 00		 push	 0
  0010d	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _memset
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : 		ddsd.dwSize = sizeof (ddsd);

  00119	c7 45 90 6c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp], 108 ; 0000006cH

; 256  : 		ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;

  00120	c7 45 94 21 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp+4], 33 ; 00000021H

; 257  : 		ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX;

  00127	c7 45 f8 18 02
	00 00		 mov	 DWORD PTR _ddsd$[ebp+104], 536 ; 00000218H

; 258  : 
; 259  : 		// for fullscreen we use page flipping, for windowed mode, we blit the hidden surface to
; 260  : 		// the visible surface, in both cases we have a visible (or 'real') surface, and a hidden
; 261  : 		// (or 'virtual', or 'backbuffer') surface.
; 262  : 		ddsd.dwBackBufferCount = 1;

  0012e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp+20], 1

; 263  : 
; 264  : 		ddrval = IDirectDraw2_CreateSurface(DDr2,&ddsd, &ScreenReal, NULL);

  00135	6a 00		 push	 0
  00137	68 00 00 00 00	 push	 OFFSET _ScreenReal
  0013c	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  0013f	50		 push	 eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  00146	51		 push	 ecx
  00147	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  0014d	8b 02		 mov	 eax, DWORD PTR [edx]
  0014f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00152	ff d1		 call	 ecx
  00154	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 265  : 		if (ddrval != DD_OK)

  00157	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  0015b	74 0d		 je	 SHORT $LN7@InitDirect

; 266  : 			I_Error("CreateSurface Primary Screen FAILED");

  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PPFGDHGL@CreateSurface?5Primary?5Screen?5FA@
  00162	e8 00 00 00 00	 call	 _I_Error
  00167	83 c4 04	 add	 esp, 4
$LN7@InitDirect:

; 267  : 
; 268  : 		// Get a pointer to the back buffer
; 269  : 
; 270  : 		ddscaps.dwCaps = DDSCAPS_BACKBUFFER;

  0016a	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR _ddscaps$[ebp], 4

; 271  : 		ddrval = IDirectDrawSurface_GetAttachedSurface(ScreenReal,&ddscaps, &ScreenVirtual);

  00171	68 00 00 00 00	 push	 OFFSET _ScreenVirtual
  00176	8d 45 8c	 lea	 eax, DWORD PTR _ddscaps$[ebp]
  00179	50		 push	 eax
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  00180	51		 push	 ecx
  00181	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenReal
  00187	8b 02		 mov	 eax, DWORD PTR [edx]
  00189	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0018c	ff d1		 call	 ecx
  0018e	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 272  : 		if (ddrval != DD_OK)

  00191	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  00195	74 0d		 je	 SHORT $LN8@InitDirect

; 273  : 			I_Error("GetAttachedSurface FAILED");

  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PBBHBLBF@GetAttachedSurface?5FAILED@
  0019c	e8 00 00 00 00	 call	 _I_Error
  001a1	83 c4 04	 add	 esp, 4
$LN8@InitDirect:

; 274  : 	}

  001a4	e9 3f 02 00 00	 jmp	 $LN14@InitDirect
$LN3@InitDirect:

; 275  : 	else
; 276  : 	{
; 277  : 		rect.top = 0;

  001a9	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _rect$[ebp+4], 0

; 278  : 		rect.left = 0;

  001b3	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _rect$[ebp], 0

; 279  : 		rect.bottom = height-1;

  001bd	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  001c0	83 e8 01	 sub	 eax, 1
  001c3	89 45 80	 mov	 DWORD PTR _rect$[ebp+12], eax

; 280  : 		rect.right = width-1;

  001c6	8b 45 0c	 mov	 eax, DWORD PTR _width$[ebp]
  001c9	83 e8 01	 sub	 eax, 1
  001cc	89 85 7c ff ff
	ff		 mov	 DWORD PTR _rect$[ebp+8], eax

; 281  : 
; 282  : 		// Change window attributes
; 283  : 
; 284  : 		dwStyle = GetWindowStyle(appWin);

  001d2	6a f0		 push	 -16			; fffffff0H
  001d4	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  001d7	50		 push	 eax
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  001de	89 45 84	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 285  : 		dwStyle &= ~WS_POPUP;

  001e1	8b 45 84	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  001e4	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  001e9	89 45 84	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 286  : 		dwStyle |= WS_OVERLAPPED | WS_SYSMENU | WS_CAPTION;

  001ec	8b 45 84	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  001ef	0d 00 00 c8 00	 or	 eax, 13107200		; 00c80000H
  001f4	89 45 84	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 287  : 
; 288  : 		SetWindowLong(appWin, GWL_STYLE, dwStyle);

  001f7	8b 45 84	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  001fa	50		 push	 eax
  001fb	6a f0		 push	 -16			; fffffff0H
  001fd	8b 4d 08	 mov	 ecx, DWORD PTR _appWin$[ebp]
  00200	51		 push	 ecx
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  00207	90		 npad	 1

; 289  : 
; 290  : 		// Resize the window so that the client area is the requested width/height
; 291  : 
; 292  : 		AdjustWindowRectEx(&rect, GetWindowStyle(appWin), GetMenu(appWin) != NULL,

  00208	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  0020b	50		 push	 eax
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMenu@4
  00212	85 c0		 test	 eax, eax
  00214	74 0c		 je	 SHORT $LN16@InitDirect
  00216	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv173[ebp], 1
  00220	eb 0a		 jmp	 SHORT $LN17@InitDirect
$LN16@InitDirect:
  00222	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv173[ebp], 0
$LN17@InitDirect:
  0022c	6a ec		 push	 -20			; ffffffecH
  0022e	8b 4d 08	 mov	 ecx, DWORD PTR _appWin$[ebp]
  00231	51		 push	 ecx
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  00238	50		 push	 eax
  00239	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv173[ebp]
  0023f	52		 push	 edx
  00240	6a f0		 push	 -16			; fffffff0H
  00242	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  00245	50		 push	 eax
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  0024c	50		 push	 eax
  0024d	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _rect$[ebp]
  00253	51		 push	 ecx
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AdjustWindowRectEx@16
  0025a	90		 npad	 1

; 293  : 		                   GetWindowExStyle(appWin));
; 294  : 
; 295  : 		// Just in case the window was moved off the visible area of the
; 296  : 		// screen.
; 297  : 
; 298  : 		SetWindowPos(appWin, NULL, 0, 0, rect.right-rect.left,

  0025b	6a 16		 push	 22			; 00000016H
  0025d	8b 45 80	 mov	 eax, DWORD PTR _rect$[ebp+12]
  00260	2b 85 78 ff ff
	ff		 sub	 eax, DWORD PTR _rect$[ebp+4]
  00266	50		 push	 eax
  00267	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _rect$[ebp+8]
  0026d	2b 8d 74 ff ff
	ff		 sub	 ecx, DWORD PTR _rect$[ebp]
  00273	51		 push	 ecx
  00274	6a 00		 push	 0
  00276	6a 00		 push	 0
  00278	6a 00		 push	 0
  0027a	8b 55 08	 mov	 edx, DWORD PTR _appWin$[ebp]
  0027d	52		 push	 edx
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  00284	90		 npad	 1

; 299  : 		             rect.bottom-rect.top, SWP_NOMOVE | SWP_NOZORDER |
; 300  : 		             SWP_NOACTIVATE);
; 301  : 
; 302  : 		SetWindowPos(appWin, HWND_NOTOPMOST, 0, 0, 0, 0,

  00285	6a 13		 push	 19			; 00000013H
  00287	6a 00		 push	 0
  00289	6a 00		 push	 0
  0028b	6a 00		 push	 0
  0028d	6a 00		 push	 0
  0028f	6a fe		 push	 -2			; fffffffeH
  00291	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  00294	50		 push	 eax
  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  0029b	90		 npad	 1

; 303  : 		             SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
; 304  : 
; 305  : 		// Exclusive mode is normal since it's in windowed mode and needs
; 306  : 		// to cooperate with GDI
; 307  : 
; 308  : 		ddrval = IDirectDraw2_SetCooperativeLevel(DDr2,appWin, DDSCL_NORMAL);

  0029c	6a 08		 push	 8
  0029e	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  002a1	50		 push	 eax
  002a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  002a8	51		 push	 ecx
  002a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  002af	8b 02		 mov	 eax, DWORD PTR [edx]
  002b1	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  002b4	ff d1		 call	 ecx
  002b6	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 309  : 		if (ddrval != DD_OK)

  002b9	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  002bd	74 0d		 je	 SHORT $LN9@InitDirect

; 310  : 			I_Error("SetCooperativeLevel FAILED");

  002bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JCLFBICE@SetCooperativeLevel?5FAILED@
  002c4	e8 00 00 00 00	 call	 _I_Error
  002c9	83 c4 04	 add	 esp, 4
$LN9@InitDirect:

; 311  : 
; 312  : 		// Always zero the DDSURFACEDESC structure and set the dwSize member!
; 313  : 
; 314  : 		ZeroMemory(&ddsd, sizeof (ddsd));

  002cc	6a 6c		 push	 108			; 0000006cH
  002ce	6a 00		 push	 0
  002d0	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  002d3	50		 push	 eax
  002d4	e8 00 00 00 00	 call	 _memset
  002d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 		ddsd.dwSize = sizeof (ddsd);

  002dc	c7 45 90 6c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp], 108 ; 0000006cH

; 316  : 		ddsd.dwFlags = DDSD_CAPS;

  002e3	c7 45 94 01 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp+4], 1

; 317  : 		ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

  002ea	c7 45 f8 00 02
	00 00		 mov	 DWORD PTR _ddsd$[ebp+104], 512 ; 00000200H

; 318  : 
; 319  : 		// Create the primary surface
; 320  : 
; 321  : 		ddrval = IDirectDraw2_CreateSurface(DDr2,&ddsd, &ScreenReal, NULL);

  002f1	6a 00		 push	 0
  002f3	68 00 00 00 00	 push	 OFFSET _ScreenReal
  002f8	8d 45 90	 lea	 eax, DWORD PTR _ddsd$[ebp]
  002fb	50		 push	 eax
  002fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  00302	51		 push	 ecx
  00303	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  00309	8b 02		 mov	 eax, DWORD PTR [edx]
  0030b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0030e	ff d1		 call	 ecx
  00310	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 322  : 		if (ddrval != DD_OK)

  00313	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  00317	74 0d		 je	 SHORT $LN10@InitDirect

; 323  : 			I_Error("CreateSurface Primary Screen FAILED");

  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PPFGDHGL@CreateSurface?5Primary?5Screen?5FA@
  0031e	e8 00 00 00 00	 call	 _I_Error
  00323	83 c4 04	 add	 esp, 4
$LN10@InitDirect:

; 324  : 
; 325  : 		// Create a back buffer for offscreen rendering, this will be used to
; 326  : 		// blt to the primary
; 327  : 
; 328  : 		ScreenVirtual = CreateNewSurface(width, height, DDSCAPS_OFFSCREENPLAIN |

  00326	68 40 08 00 00	 push	 2112			; 00000840H
  0032b	8b 45 10	 mov	 eax, DWORD PTR _height$[ebp]
  0032e	50		 push	 eax
  0032f	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  00332	51		 push	 ecx
  00333	e8 00 00 00 00	 call	 _CreateNewSurface
  00338	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033b	a3 00 00 00 00	 mov	 DWORD PTR _ScreenVirtual, eax

; 329  : 		                                 DDSCAPS_SYSTEMMEMORY);
; 330  : 		if (ScreenVirtual == NULL)

  00340	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ScreenVirtual, 0
  00347	75 0d		 jne	 SHORT $LN11@InitDirect

; 331  : 			I_Error("CreateSurface Secondary Screen FAILED");

  00349	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FBGGFFPI@CreateSurface?5Secondary?5Screen?5@
  0034e	e8 00 00 00 00	 call	 _I_Error
  00353	83 c4 04	 add	 esp, 4
$LN11@InitDirect:

; 332  : 
; 333  : 		/// \todo get the desktop bit depth, and build a lookup table
; 334  : 		/// for quick conversions of 8bit color indexes 0-255 to desktop colors
; 335  : 		/// eg: 256 entries of equivalent of palette colors 0-255 in 15,16,24,32 bit format
; 336  : 		/// when blit virtual to real, convert pixels through lookup table..
; 337  : 
; 338  : 		// Use a clipper object for clipping when in windowed mode
; 339  : 		// (make sure our drawing doesn't affect other windows)
; 340  : 
; 341  : 		ddrval = IDirectDraw2_CreateClipper (DDr2, 0, &windclip, 0);

  00356	6a 00		 push	 0
  00358	68 00 00 00 00	 push	 OFFSET _windclip
  0035d	6a 00		 push	 0
  0035f	a1 00 00 00 00	 mov	 eax, DWORD PTR _DDr2
  00364	50		 push	 eax
  00365	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  0036b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0036d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00370	ff d0		 call	 eax
  00372	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 342  : 		if (ddrval != DD_OK)

  00375	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  00379	74 0d		 je	 SHORT $LN12@InitDirect

; 343  : 			I_Error("CreateClipper FAILED");

  0037b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IGMEMDFF@CreateClipper?5FAILED@
  00380	e8 00 00 00 00	 call	 _I_Error
  00385	83 c4 04	 add	 esp, 4
$LN12@InitDirect:

; 344  : 
; 345  : 		// Associate the clipper with the window.
; 346  : 		ddrval = IDirectDrawClipper_SetHWnd (windclip,0, appWin);

  00388	8b 45 08	 mov	 eax, DWORD PTR _appWin$[ebp]
  0038b	50		 push	 eax
  0038c	6a 00		 push	 0
  0038e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _windclip
  00394	51		 push	 ecx
  00395	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _windclip
  0039b	8b 02		 mov	 eax, DWORD PTR [edx]
  0039d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003a0	ff d1		 call	 ecx
  003a2	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 347  : 		if (ddrval != DD_OK)

  003a5	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  003a9	74 0d		 je	 SHORT $LN13@InitDirect

; 348  : 			I_Error("Clipper -> SetHWnd  FAILED");

  003ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IBMDAENO@Clipper?5?9?$DO?5SetHWnd?5?5FAILED@
  003b0	e8 00 00 00 00	 call	 _I_Error
  003b5	83 c4 04	 add	 esp, 4
$LN13@InitDirect:

; 349  : 
; 350  : 		// Attach the clipper to the surface.
; 351  : 		ddrval = IDirectDrawSurface_SetClipper (ScreenReal,windclip);

  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _windclip
  003bd	50		 push	 eax
  003be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ScreenReal
  003c4	51		 push	 ecx
  003c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ScreenReal
  003cb	8b 02		 mov	 eax, DWORD PTR [edx]
  003cd	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  003d0	ff d1		 call	 ecx
  003d2	89 45 88	 mov	 DWORD PTR _ddrval$[ebp], eax

; 352  : 		if (ddrval != DD_OK)

  003d5	83 7d 88 00	 cmp	 DWORD PTR _ddrval$[ebp], 0
  003d9	74 0d		 je	 SHORT $LN14@InitDirect

; 353  : 			I_Error("PrimaryScreen -> SetClipperClipper  FAILED");

  003db	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LEAPJBCA@PrimaryScreen?5?9?$DO?5SetClipperClip@
  003e0	e8 00 00 00 00	 call	 _I_Error
  003e5	83 c4 04	 add	 esp, 4
$LN14@InitDirect:

; 354  : 	}
; 355  : 
; 356  : 	return TRUE;

  003e8	b8 01 00 00 00	 mov	 eax, 1

; 357  : }

  003ed	5f		 pop	 edi
  003ee	5e		 pop	 esi
  003ef	5b		 pop	 ebx
  003f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f3	33 cd		 xor	 ecx, ebp
  003f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c3		 ret	 0
_InitDirectDrawe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _CreateDirectDrawInstance
_TEXT	SEGMENT
_tp$ = -20						; size = 4
_rp2$ = -16						; size = 4
_rp$ = -12						; size = 4
_DDr$ = -8						; size = 4
_hr$ = -4						; size = 4
_CreateDirectDrawInstance PROC				; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 170  : 	HRESULT hr;
; 171  : 	IDirectDraw* DDr;
; 172  : 	IDirectDraw** rp = &DDr;

  00009	8d 45 f8	 lea	 eax, DWORD PTR _DDr$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _rp$[ebp], eax

; 173  : 	IDirectDraw2** rp2 = &DDr2;

  0000f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rp2$[ebp], OFFSET _DDr2

; 174  : 	LPVOID *tp = (LPVOID *)rp2;

  00016	8b 45 f0	 mov	 eax, DWORD PTR _rp2$[ebp]
  00019	89 45 ec	 mov	 DWORD PTR _tp$[ebp], eax

; 175  : 
; 176  : 	if (!LoadDirectDraw())

  0001c	e8 00 00 00 00	 call	 _LoadDirectDraw
  00021	85 c0		 test	 eax, eax
  00023	75 04		 jne	 SHORT $LN2@CreateDire

; 177  : 		return FALSE;

  00025	33 c0		 xor	 eax, eax
  00027	eb 7e		 jmp	 SHORT $LN1@CreateDire
$LN2@CreateDire:

; 178  : 	//
; 179  : 	// create an instance of DirectDraw object
; 180  : 	//
; 181  : 	if (FAILED(hr = pfnDirectDrawCreate(NULL, rp, NULL)))

  00029	6a 00		 push	 0
  0002b	8b 45 f4	 mov	 eax, DWORD PTR _rp$[ebp]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnDirectDrawCreate
  00037	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  0003a	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0003e	7d 1a		 jge	 SHORT $LN3@CreateDire

; 182  : 		I_Error("DirectDrawCreate FAILED: %s", DXErrorToString(hr));

  00040	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _DXErrorToString
  00049	83 c4 04	 add	 esp, 4
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LDBKKLEC@DirectDrawCreate?5FAILED?3?5?$CFs@
  00052	e8 00 00 00 00	 call	 _I_Error
  00057	83 c4 08	 add	 esp, 8
$LN3@CreateDire:

; 183  : 
; 184  : 	// change interface to IDirectDraw2
; 185  : 	if (FAILED(hr = IDirectDraw_QueryInterface(DDr, &IID_IDirectDraw2, tp)))

  0005a	8b 45 ec	 mov	 eax, DWORD PTR _tp$[ebp]
  0005d	50		 push	 eax
  0005e	68 00 00 00 00	 push	 OFFSET _IID_IDirectDraw2
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _DDr$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 f8	 mov	 edx, DWORD PTR _DDr$[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	ff d1		 call	 ecx
  00070	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00073	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00077	7d 1a		 jge	 SHORT $LN4@CreateDire

; 186  : 		I_Error("Failed to query DirectDraw2 interface: %s", DXErrorToString(hr));

  00079	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _DXErrorToString
  00082	83 c4 04	 add	 esp, 4
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PBMKIBDN@Failed?5to?5query?5DirectDraw2?5int@
  0008b	e8 00 00 00 00	 call	 _I_Error
  00090	83 c4 08	 add	 esp, 8
$LN4@CreateDire:

; 187  : 
; 188  : 	// release the interface we don't need
; 189  : 	IDirectDraw_Release (DDr);

  00093	8b 45 f8	 mov	 eax, DWORD PTR _DDr$[ebp]
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _DDr$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0009f	ff d0		 call	 eax
  000a1	90		 npad	 1

; 190  : 	return TRUE;

  000a2	b8 01 00 00 00	 mov	 eax, 1
$LN1@CreateDire:

; 191  : }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_CreateDirectDrawInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\fabdxlib.c
;	COMDAT _EnumDirectDrawDisplayModes
_TEXT	SEGMENT
_lpappFunc$ = -4					; size = 4
_appFunc$ = 8						; size = 4
_EnumDirectDrawDisplayModes PROC			; COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 123  : 	LPVOID lpappFunc = appFunc;

  00009	8b 45 08	 mov	 eax, DWORD PTR _appFunc$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _lpappFunc$[ebp], eax

; 124  : 
; 125  : 	if (DDr2 == NULL)

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DDr2, 0
  00016	75 04		 jne	 SHORT $LN2@EnumDirect

; 126  : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 54		 jmp	 SHORT $LN1@EnumDirect
$LN2@EnumDirect:

; 127  : 
; 128  : 	// enumerate display modes
; 129  : 	// Carl: DirectX 3.x apparently does not support VGA modes. Who cares. :)
; 130  : 	// faB: removed DDEDM_REFRESHRATES, detects too many modes, plus we don't care of refresh rate.
; 131  : 	if (bDX0300)

  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bDX0300, 0
  00023	74 24		 je	 SHORT $LN3@EnumDirect

; 132  : 		IDirectDraw2_EnumDisplayModes (DDr2, 0 /*| DDEDM_REFRESHRATES*/,

  00025	68 00 00 00 00	 push	 OFFSET _myEnumModesCallback@8
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _lpappFunc$[ebp]
  0002d	50		 push	 eax
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  00038	51		 push	 ecx
  00039	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00044	ff d1		 call	 ecx
  00046	90		 npad	 1
  00047	eb 22		 jmp	 SHORT $LN4@EnumDirect
$LN3@EnumDirect:

; 133  : 		                               NULL, lpappFunc, myEnumModesCallback);
; 134  : 	else
; 135  : 		IDirectDraw2_EnumDisplayModes (DDr2, DDEDM_STANDARDVGAMODES /*| DDEDM_REFRESHRATES*/,

  00049	68 00 00 00 00	 push	 OFFSET _myEnumModesCallback@8
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _lpappFunc$[ebp]
  00051	50		 push	 eax
  00052	6a 00		 push	 0
  00054	6a 02		 push	 2
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DDr2
  0005c	51		 push	 ecx
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DDr2
  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00068	ff d1		 call	 ecx
  0006a	90		 npad	 1
$LN4@EnumDirect:

; 136  : 		                               NULL, lpappFunc, myEnumModesCallback);
; 137  : 	return TRUE;

  0006b	b8 01 00 00 00	 mov	 eax, 1
$LN1@EnumDirect:

; 138  : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_EnumDirectDrawDisplayModes ENDP
_TEXT	ENDS
END
