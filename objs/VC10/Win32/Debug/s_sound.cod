; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\s_sound.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_cv_samplerate
PUBLIC	_stereoreverse
PUBLIC	_cv_soundvolume
PUBLIC	_cv_digmusicvolume
PUBLIC	_cv_midimusicvolume
PUBLIC	_cv_numChannels
PUBLIC	_soundvolume_cons_t
PUBLIC	_mus_playing
PUBLIC	??_C@_03KGHEHEMH@MIN@				; `string'
PUBLIC	??_C@_03LEPPJAKI@MAX@				; `string'
PUBLIC	??_C@_0L@JDDECGBD@samplerate@			; `string'
PUBLIC	??_C@_05NBKDPKDF@22050@				; `string'
PUBLIC	??_C@_0O@FEPFLFGN@stereoreverse@		; `string'
PUBLIC	??_C@_03GCDBBDDL@Off@				; `string'
PUBLIC	??_C@_0O@GPOCJKCE@precachesound@		; `string'
PUBLIC	??_C@_0M@OKAOOHCM@soundvolume@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15@				; `string'
PUBLIC	??_C@_0P@BFILBIHB@digmusicvolume@		; `string'
PUBLIC	??_C@_02OAMOHKJG@31@				; `string'
PUBLIC	??_C@_0BA@KPPKJBPK@midimusicvolume@		; `string'
PUBLIC	??_C@_0N@IIDONHCG@snd_channels@			; `string'
PUBLIC	??_C@_02MLODCJFF@32@				; `string'
PUBLIC	??_C@_08NCOBOMG@surround@			; `string'
EXTRN	_CV_OnOff:BYTE
EXTRN	_CV_Unsigned:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_mus_playing DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08NCOBOMG@surround@
CONST	SEGMENT
??_C@_08NCOBOMG@surround@ DB 'surround', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32@
CONST	SEGMENT
??_C@_02MLODCJFF@32@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IIDONHCG@snd_channels@
CONST	SEGMENT
??_C@_0N@IIDONHCG@snd_channels@ DB 'snd_channels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPPKJBPK@midimusicvolume@
CONST	SEGMENT
??_C@_0BA@KPPKJBPK@midimusicvolume@ DB 'midimusicvolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31@
CONST	SEGMENT
??_C@_02OAMOHKJG@31@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFILBIHB@digmusicvolume@
CONST	SEGMENT
??_C@_0P@BFILBIHB@digmusicvolume@ DB 'digmusicvolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15@
CONST	SEGMENT
??_C@_02IHCGGLPM@15@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKAOOHCM@soundvolume@
CONST	SEGMENT
??_C@_0M@OKAOOHCM@soundvolume@ DB 'soundvolume', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GPOCJKCE@precachesound@
CONST	SEGMENT
??_C@_0O@GPOCJKCE@precachesound@ DB 'precachesound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FEPFLFGN@stereoreverse@
CONST	SEGMENT
??_C@_0O@FEPFLFGN@stereoreverse@ DB 'stereoreverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NBKDPKDF@22050@
CONST	SEGMENT
??_C@_05NBKDPKDF@22050@ DB '22050', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDDECGBD@samplerate@
CONST	SEGMENT
??_C@_0L@JDDECGBD@samplerate@ DB 'samplerate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEPPJAKI@MAX@
CONST	SEGMENT
??_C@_03LEPPJAKI@MAX@ DB 'MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGHEHEMH@MIN@
CONST	SEGMENT
??_C@_03KGHEHEMH@MIN@ DB 'MIN', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_cv_samplerate DD FLAT:??_C@_0L@JDDECGBD@samplerate@
	DD	FLAT:??_C@_05NBKDPKDF@22050@
	DD	00H
	DD	FLAT:_CV_Unsigned
	DD	00H
	DD	05622H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_stereoreverse DD FLAT:??_C@_0O@FEPFLFGN@stereoreverse@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_soundvolume DD FLAT:??_C@_0M@OKAOOHCM@soundvolume@
	DD	FLAT:??_C@_02IHCGGLPM@15@
	DD	01H
	DD	FLAT:_soundvolume_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_digmusicvolume DD FLAT:??_C@_0P@BFILBIHB@digmusicvolume@
	DD	FLAT:??_C@_02OAMOHKJG@31@
	DD	01H
	DD	FLAT:_soundvolume_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_midimusicvolume DD FLAT:??_C@_0BA@KPPKJBPK@midimusicvolume@
	DD	FLAT:??_C@_02OAMOHKJG@31@
	DD	01H
	DD	FLAT:_soundvolume_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_numChannels DD FLAT:??_C@_0N@IIDONHCG@snd_channels@
	DD	FLAT:??_C@_02MLODCJFF@32@
	DD	03H
	DD	FLAT:_CV_Unsigned
	DD	FLAT:_SetChannelsNum
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_soundvolume_cons_t DD 00H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	01fH
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_S_RegisterSoundStuff
PUBLIC	_S_Init
PUBLIC	_S_StopSounds
PUBLIC	_S_ClearSfx
PUBLIC	_S_Start
PUBLIC	_S_GetSfxLumpNum
PUBLIC	_S_StartSound
PUBLIC	_S_StartSoundAtVolume
PUBLIC	_S_StopSound
PUBLIC	_S_ChangeMusic
PUBLIC	_S_SpeedMusic
PUBLIC	_S_StopMusic
PUBLIC	_S_PauseSound
PUBLIC	_S_ResumeSound
PUBLIC	_S_UpdateSounds
PUBLIC	_S_CalculateSoundDistance
PUBLIC	_S_SetDigMusicVolume
PUBLIC	_S_SetMIDIMusicVolume
PUBLIC	_S_SetSfxVolume
PUBLIC	_S_SoundPlaying
PUBLIC	_S_StartSoundName
PUBLIC	_S_StopSoundByNum
PUBLIC	_S_AdjustSoundParams
PUBLIC	??_C@_0P@BNEBKMJG@?9precachesound@		; `string'
PUBLIC	??_C@_0BD@MLHHDKNE@Loading?5sounds?4?4?4?5@	; `string'
PUBLIC	??_C@_0BM@BPMIPJGB@?5pre?9cached?5all?5sound?5data?6@ ; `string'
PUBLIC	??_C@_04BGHBHICD@ds?$CFs@			; `string'
PUBLIC	??_C@_06KHJOJAIK@dsthok@			; `string'
PUBLIC	??_C@_0CE@IHIONKGF@musicvolume?5should?5be?5between?50@ ; `string'
PUBLIC	??_C@_0CC@PDCFMAGF@sfxvolume?5should?5be?5between?50?93@ ; `string'
PUBLIC	??_C@_04PMJFGIKF@d_?$CFs@			; `string'
PUBLIC	??_C@_0BF@DAIBKDKL@Bad?5music?5number?5?$CFd?6@	; `string'
PUBLIC	??_C@_0CD@KCDEBKHB@ERROR?3?5Music?5lump?5?$CF?46s?5not?5foun@ ; `string'
PUBLIC	??_C@_0CC@CDDDMENG@Cannot?5load?5another?5extra?5sound@ ; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@4046800000000000
PUBLIC	__real@41c0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memset:PROC
EXTRN	_stricmp:PROC
EXTRN	_abs:PROC
EXTRN	_strlcpy:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_S_AddSoundFx:PROC
EXTRN	_S_RemoveSoundFx:PROC
EXTRN	_CV_RegisterVar:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_CV_StealthSet:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_R_PointToAngle2:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_I_UpdateMumble:PROC
EXTRN	_I_GetSfx:PROC
EXTRN	_I_FreeSfx:PROC
EXTRN	_I_StartSound:PROC
EXTRN	_I_StopSound:PROC
EXTRN	_I_SoundIsPlaying:PROC
EXTRN	_I_UpdateSoundParams:PROC
EXTRN	_I_SetSfxVolume:PROC
EXTRN	_I_PauseSong:PROC
EXTRN	_I_ResumeSong:PROC
EXTRN	_I_SetMIDIMusicVolume:PROC
EXTRN	_I_RegisterSong:PROC
EXTRN	_I_PlaySong:PROC
EXTRN	_I_StopSong:PROC
EXTRN	_I_UnRegisterSong:PROC
EXTRN	_I_SetSongSpeed:PROC
EXTRN	_I_StartDigSong:PROC
EXTRN	_I_StopDigSong:PROC
EXTRN	_I_SetDigMusicVolume:PROC
EXTRN	_I_StopCD:PROC
EXTRN	_I_ResumeCD:PROC
EXTRN	_W_CheckNumForName:PROC
EXTRN	_W_GetNumForName:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_Z_ChangeTag2:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_P_AproxDistance:PROC
EXTRN	_HW3S_StartSound:PROC
EXTRN	_HW3S_StopSoundByNum:PROC
EXTRN	_HW3S_StopSound:PROC
EXTRN	_HW3S_StopSounds:PROC
EXTRN	_HW3S_UpdateSources:PROC
EXTRN	_HW3S_SetSfxVolume:PROC
EXTRN	_HW3S_SetSourcesNum:PROC
EXTRN	_HW3S_SoundPlaying:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_oncontinuescreen:DWORD
EXTRN	_finesine:BYTE
EXTRN	_S_sfx:BYTE
EXTRN	_S_music:BYTE
EXTRN	_gamemap:WORD
EXTRN	_mapmusic:DWORD
EXTRN	_maptol:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_nomidimusic:DWORD
EXTRN	_nosound:DWORD
EXTRN	_nodigimusic:DWORD
EXTRN	_music_disabled:DWORD
EXTRN	_sound_disabled:DWORD
EXTRN	_digital_disabled:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	_dedicated:DWORD
EXTRN	_players:BYTE
EXTRN	_cv_chasecam:BYTE
EXTRN	_cv_chasecam2:BYTE
EXTRN	_sound_started:BYTE
EXTRN	_skyflatnum:DWORD
EXTRN	_camera:BYTE
EXTRN	_camera2:BYTE
EXTRN	_hws_mode:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_channels DD	01H DUP (?)
_numofchannels DD 01H DUP (?)
_mus_paused DD	01H DUP (?)
_nextcleanup DD	01H DUP (?)
_actualsfxvolume DD 01H DUP (?)
_actualdigmusicvolume DD 01H DUP (?)
_actualmidimusicvolume DD 01H DUP (?)
_newsounds DD	0aH DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@41c0000000000000
CONST	SEGMENT
__real@41c0000000000000 DQ 041c0000000000000r	; 5.36871e+08
CONST	ENDS
;	COMDAT __real@4046800000000000
CONST	SEGMENT
__real@4046800000000000 DQ 04046800000000000r	; 45
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0CC@CDDDMENG@Cannot?5load?5another?5extra?5sound@
CONST	SEGMENT
??_C@_0CC@CDDDMENG@Cannot?5load?5another?5extra?5sound@ DB 'Cannot load a'
	DB	'nother extra sound!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KCDEBKHB@ERROR?3?5Music?5lump?5?$CF?46s?5not?5foun@
CONST	SEGMENT
??_C@_0CD@KCDEBKHB@ERROR?3?5Music?5lump?5?$CF?46s?5not?5foun@ DB 'ERROR: '
	DB	'Music lump %.6s not found!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DAIBKDKL@Bad?5music?5number?5?$CFd?6@
CONST	SEGMENT
??_C@_0BF@DAIBKDKL@Bad?5music?5number?5?$CFd?6@ DB 'Bad music number %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMJFGIKF@d_?$CFs@
CONST	SEGMENT
??_C@_04PMJFGIKF@d_?$CFs@ DB 'd_%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PDCFMAGF@sfxvolume?5should?5be?5between?50?93@
CONST	SEGMENT
??_C@_0CC@PDCFMAGF@sfxvolume?5should?5be?5between?50?93@ DB 'sfxvolume sh'
	DB	'ould be between 0-31', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IHIONKGF@musicvolume?5should?5be?5between?50@
CONST	SEGMENT
??_C@_0CE@IHIONKGF@musicvolume?5should?5be?5between?50@ DB 'musicvolume s'
	DB	'hould be between 0-31', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KHJOJAIK@dsthok@
CONST	SEGMENT
??_C@_06KHJOJAIK@dsthok@ DB 'dsthok', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGHBHICD@ds?$CFs@
CONST	SEGMENT
??_C@_04BGHBHICD@ds?$CFs@ DB 'ds%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BPMIPJGB@?5pre?9cached?5all?5sound?5data?6@
CONST	SEGMENT
??_C@_0BM@BPMIPJGB@?5pre?9cached?5all?5sound?5data?6@ DB ' pre-cached all'
	DB	' sound data', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MLHHDKNE@Loading?5sounds?4?4?4?5@
CONST	SEGMENT
??_C@_0BD@MLHHDKNE@Loading?5sounds?4?4?4?5@ DB 'Loading sounds... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BNEBKMJG@?9precachesound@
CONST	SEGMENT
??_C@_0P@BNEBKMJG@?9precachesound@ DB '-precachesound', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_precachesound DD FLAT:??_C@_0O@GPOCJKCE@precachesound@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_surround DD	FLAT:??_C@_08NCOBOMG@surround@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0376H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0453H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	046eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	082H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_DigMusic
_TEXT	SEGMENT
_music$ = 8						; size = 4
_looping$ = 12						; size = 4
_S_DigMusic PROC					; COMDAT

; 1029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1030 : 	if (nodigimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00010	74 04		 je	 SHORT $LN2@S_DigMusic

; 1031 : 		return false;

  00012	33 c0		 xor	 eax, eax
  00014	eb 34		 jmp	 SHORT $LN1@S_DigMusic
$LN2@S_DigMusic:

; 1032 : 
; 1033 : 	if (digital_disabled)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _digital_disabled, 0
  0001d	74 04		 je	 SHORT $LN3@S_DigMusic

; 1034 : 		return false;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 27		 jmp	 SHORT $LN1@S_DigMusic
$LN3@S_DigMusic:

; 1035 : 
; 1036 : 	if (!I_StartDigSong(music->name, looping))

  00023	8b 45 0c	 mov	 eax, DWORD PTR _looping$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _music$[ebp]
  0002a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _I_StartDigSong
  00032	83 c4 08	 add	 esp, 8
  00035	85 c0		 test	 eax, eax
  00037	75 04		 jne	 SHORT $LN4@S_DigMusic

; 1037 : 		return false;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 0d		 jmp	 SHORT $LN1@S_DigMusic
$LN4@S_DigMusic:

; 1038 : 
; 1039 : 	mus_playing = music;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  00040	a3 00 00 00 00	 mov	 DWORD PTR _mus_playing, eax

; 1040 : 	return true;

  00045	b8 01 00 00 00	 mov	 eax, 1
$LN1@S_DigMusic:

; 1041 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_S_DigMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_MIDIMusic
_TEXT	SEGMENT
_music$ = 8						; size = 4
_looping$ = 12						; size = 4
_S_MIDIMusic PROC					; COMDAT

; 985  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 986  : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 07		 je	 SHORT $LN2@S_MIDIMusi

; 987  : 		return false;

  00012	33 c0		 xor	 eax, eax
  00014	e9 c7 00 00 00	 jmp	 $LN1@S_MIDIMusi
$LN2@S_MIDIMusi:

; 988  : 
; 989  : 	if (music_disabled)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _music_disabled, 0
  00020	74 07		 je	 SHORT $LN3@S_MIDIMusi

; 990  : 		return false;

  00022	33 c0		 xor	 eax, eax
  00024	e9 b7 00 00 00	 jmp	 $LN1@S_MIDIMusi
$LN3@S_MIDIMusi:

; 991  : 
; 992  : 	// get lumpnum if neccessary
; 993  : 	if (!music->lumpnum)

  00029	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  0002c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00030	75 4a		 jne	 SHORT $LN4@S_MIDIMusi

; 994  : 	{
; 995  : 		if (W_CheckNumForName(va("d_%s", music->name)) == LUMPERROR)

  00032	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	51		 push	 ecx
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_04PMJFGIKF@d_?$CFs@
  0003d	e8 00 00 00 00	 call	 _va
  00042	83 c4 08	 add	 esp, 8
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _W_CheckNumForName
  0004b	83 c4 04	 add	 esp, 4
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	75 07		 jne	 SHORT $LN5@S_MIDIMusi

; 996  : 			return false;

  00053	33 c0		 xor	 eax, eax
  00055	e9 86 00 00 00	 jmp	 $LN1@S_MIDIMusi
$LN5@S_MIDIMusi:

; 997  : 		music->lumpnum = W_GetNumForName(va("d_%s", music->name));

  0005a	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	51		 push	 ecx
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_04PMJFGIKF@d_?$CFs@
  00065	e8 00 00 00 00	 call	 _va
  0006a	83 c4 08	 add	 esp, 8
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _W_GetNumForName
  00073	83 c4 04	 add	 esp, 4
  00076	8b 55 08	 mov	 edx, DWORD PTR _music$[ebp]
  00079	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN4@S_MIDIMusi:

; 998  : 	}
; 999  : 
; 1000 : 	// load & register it
; 1001 : 	music->data = W_CacheLumpNum(music->lumpnum, PU_MUSIC);

  0007c	6a 03		 push	 3
  0007e	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0008a	83 c4 08	 add	 esp, 8
  0008d	8b 55 08	 mov	 edx, DWORD PTR _music$[ebp]
  00090	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1002 : #if defined (macintosh) && !defined (SDL)
; 1003 : 	music->handle = I_RegisterSong(music_num);
; 1004 : #else
; 1005 : 	music->handle = I_RegisterSong(music->data, W_LumpLength(music->lumpnum));

  00093	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 _W_LumpLength
  0009f	83 c4 04	 add	 esp, 4
  000a2	50		 push	 eax
  000a3	8b 55 08	 mov	 edx, DWORD PTR _music$[ebp]
  000a6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _I_RegisterSong
  000af	83 c4 08	 add	 esp, 8
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _music$[ebp]
  000b5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1006 : #endif
; 1007 : 
; 1008 : #ifdef MUSSERV
; 1009 : 	if (msg_id != -1)
; 1010 : 	{
; 1011 : 		struct musmsg msg_buffer;
; 1012 : 
; 1013 : 		msg_buffer.msg_type = 6;
; 1014 : 		memset(msg_buffer.msg_text, 0, sizeof (msg_buffer.msg_text));
; 1015 : 		sprintf(msg_buffer.msg_text, "d_%s", music->name);
; 1016 : 		msgsnd(msg_id, (struct msgbuf*)&msg_buffer, sizeof (msg_buffer.msg_text), IPC_NOWAIT);
; 1017 : 	}
; 1018 : #endif
; 1019 : 
; 1020 : 	// play it
; 1021 : 	if (!I_PlaySong(music->handle, looping))

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _looping$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _music$[ebp]
  000bf	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _I_PlaySong
  000c8	83 c4 08	 add	 esp, 8
  000cb	85 c0		 test	 eax, eax
  000cd	75 04		 jne	 SHORT $LN6@S_MIDIMusi

; 1022 : 		return false;

  000cf	33 c0		 xor	 eax, eax
  000d1	eb 0d		 jmp	 SHORT $LN1@S_MIDIMusi
$LN6@S_MIDIMusi:

; 1023 : 
; 1024 : 	mus_playing = music;

  000d3	8b 45 08	 mov	 eax, DWORD PTR _music$[ebp]
  000d6	a3 00 00 00 00	 mov	 DWORD PTR _mus_playing, eax

; 1025 : 	return true;

  000db	b8 01 00 00 00	 mov	 eax, 1
$LN1@S_MIDIMusi:

; 1026 : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_S_MIDIMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_getChannel
_TEXT	SEGMENT
_c$ = -8						; size = 4
_cnum$ = -4						; size = 4
_origin$ = 8						; size = 4
_sfxinfo$ = 12						; size = 4
_S_getChannel PROC					; COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 168  : 	// channel number to use
; 169  : 	INT32 cnum;
; 170  : 
; 171  : 	channel_t *c;
; 172  : 
; 173  : 	// Find an open channel
; 174  : 	for (cnum = 0; cnum < numofchannels; cnum++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@S_getChann
$LN2@S_getChann:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _cnum$[ebp], eax
$LN4@S_getChann:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  00024	0f 8d 58 01 00
	00		 jge	 $LN3@S_getChann

; 175  : 	{
; 176  : 		if (!channels[cnum].sfxinfo)

  0002a	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00034	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00038	75 0a		 jne	 SHORT $LN8@S_getChann

; 177  : 			break;

  0003a	e9 43 01 00 00	 jmp	 $LN3@S_getChann
  0003f	e9 39 01 00 00	 jmp	 $LN18@S_getChann
$LN8@S_getChann:

; 178  : 
; 179  : 		// Now checks if same sound is being played, rather
; 180  : 		// than just one sound per mobj
; 181  : 		else if (sfxinfo == channels[cnum].sfxinfo && (sfxinfo->pitch & SF_NOMULTIPLESOUND))

  00044	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _sfxinfo$[ebp]
  00051	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  00054	75 1d		 jne	 SHORT $LN10@S_getChann
  00056	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  00059	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005c	83 e1 02	 and	 ecx, 2
  0005f	74 12		 je	 SHORT $LN10@S_getChann

; 182  : 		{
; 183  : 			return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	e9 9c 01 00 00	 jmp	 $LN1@S_getChann

; 184  : 			break;

  00069	e9 14 01 00 00	 jmp	 $LN3@S_getChann

; 185  : 		}

  0006e	e9 0a 01 00 00	 jmp	 $LN18@S_getChann
$LN10@S_getChann:

; 186  : 		else if (sfxinfo == channels[cnum].sfxinfo && sfxinfo->singularity == true)

  00073	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _sfxinfo$[ebp]
  00080	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  00083	75 1f		 jne	 SHORT $LN12@S_getChann
  00085	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  00088	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0008c	75 16		 jne	 SHORT $LN12@S_getChann

; 187  : 		{
; 188  : 			S_StopChannel(cnum);

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _S_StopChannel
  00097	83 c4 04	 add	 esp, 4

; 189  : 			break;

  0009a	e9 e3 00 00 00	 jmp	 $LN3@S_getChann

; 190  : 		}

  0009f	e9 d9 00 00 00	 jmp	 $LN18@S_getChann
$LN12@S_getChann:

; 191  : 		else if (origin && channels[cnum].origin == origin && channels[cnum].sfxinfo == sfxinfo)

  000a4	83 7d 08 00	 cmp	 DWORD PTR _origin$[ebp], 0
  000a8	74 50		 je	 SHORT $LN14@S_getChann
  000aa	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  000b4	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000b8	3b 55 08	 cmp	 edx, DWORD PTR _origin$[ebp]
  000bb	75 3d		 jne	 SHORT $LN14@S_getChann
  000bd	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  000c7	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000ca	3b 55 0c	 cmp	 edx, DWORD PTR _sfxinfo$[ebp]
  000cd	75 2b		 jne	 SHORT $LN14@S_getChann

; 192  : 		{
; 193  : 			if (sfxinfo->pitch & SF_NOINTERRUPT)

  000cf	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  000d2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d5	83 e1 20	 and	 ecx, 32			; 00000020H
  000d8	74 0a		 je	 SHORT $LN16@S_getChann

; 194  : 				return -1;

  000da	83 c8 ff	 or	 eax, -1
  000dd	e9 23 01 00 00	 jmp	 $LN1@S_getChann
  000e2	eb 0c		 jmp	 SHORT $LN17@S_getChann
$LN16@S_getChann:

; 195  : 			else
; 196  : 				S_StopChannel(cnum);

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _S_StopChannel
  000ed	83 c4 04	 add	 esp, 4
$LN17@S_getChann:

; 197  : 			break;

  000f0	e9 8d 00 00 00	 jmp	 $LN3@S_getChann

; 198  : 		}

  000f5	e9 83 00 00 00	 jmp	 $LN18@S_getChann
$LN14@S_getChann:

; 199  : 		else if (origin && channels[cnum].origin == origin && ((channels[cnum].sfxinfo == sfxinfo)

  000fa	83 7d 08 00	 cmp	 DWORD PTR _origin$[ebp], 0
  000fe	74 7d		 je	 SHORT $LN18@S_getChann
  00100	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0010a	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0010e	3b 55 08	 cmp	 edx, DWORD PTR _origin$[ebp]
  00111	75 6a		 jne	 SHORT $LN18@S_getChann
  00113	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0011d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00120	3b 55 0c	 cmp	 edx, DWORD PTR _sfxinfo$[ebp]
  00123	74 4a		 je	 SHORT $LN19@S_getChann
  00125	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00129	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0012f	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00132	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  00135	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00137	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00139	74 42		 je	 SHORT $LN18@S_getChann
  0013b	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0013f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00145	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00148	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  0014c	75 2f		 jne	 SHORT $LN18@S_getChann
  0014e	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  00151	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00155	75 26		 jne	 SHORT $LN18@S_getChann
  00157	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00161	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00164	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  00167	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0016a	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0016d	75 0e		 jne	 SHORT $LN18@S_getChann
$LN19@S_getChann:

; 200  : 			|| (channels[cnum].sfxinfo->name != sfxinfo->name
; 201  : 			&& channels[cnum].sfxinfo->pitch == 1 && sfxinfo->pitch == 1
; 202  : 			&& channels[cnum].sfxinfo->pitch == sfxinfo->pitch)))
; 203  : 		{
; 204  : 			S_StopChannel(cnum);

  0016f	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _S_StopChannel
  00178	83 c4 04	 add	 esp, 4

; 205  : 			break;

  0017b	eb 05		 jmp	 SHORT $LN3@S_getChann
$LN18@S_getChann:

; 206  : 		}
; 207  : 	}

  0017d	e9 90 fe ff ff	 jmp	 $LN2@S_getChann
$LN3@S_getChann:

; 208  : 
; 209  : 	// None available
; 210  : 	if (cnum == numofchannels)

  00182	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00185	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  0018b	75 57		 jne	 SHORT $LN23@S_getChann

; 211  : 	{
; 212  : 		// Look for lower priority
; 213  : 		for (cnum = 0; cnum < numofchannels; cnum++)

  0018d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  00194	eb 09		 jmp	 SHORT $LN7@S_getChann
$LN5@S_getChann:
  00196	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00199	83 c0 01	 add	 eax, 1
  0019c	89 45 fc	 mov	 DWORD PTR _cnum$[ebp], eax
$LN7@S_getChann:
  0019f	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  001a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  001a8	7d 1c		 jge	 SHORT $LN6@S_getChann

; 214  : 			if (channels[cnum].sfxinfo->priority >= sfxinfo->priority)

  001aa	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  001b4	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001b7	8b 45 0c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  001ba	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  001bd	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  001c0	7c 02		 jl	 SHORT $LN21@S_getChann

; 215  : 				break;

  001c2	eb 02		 jmp	 SHORT $LN6@S_getChann
$LN21@S_getChann:
  001c4	eb d0		 jmp	 SHORT $LN5@S_getChann
$LN6@S_getChann:

; 216  : 
; 217  : 		if (cnum == numofchannels)

  001c6	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  001c9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  001cf	75 07		 jne	 SHORT $LN22@S_getChann

; 218  : 		{
; 219  : 			// FUCK! No lower priority. Sorry, Charlie.
; 220  : 			return -1;

  001d1	83 c8 ff	 or	 eax, -1
  001d4	eb 2f		 jmp	 SHORT $LN1@S_getChann

; 221  : 		}

  001d6	eb 0c		 jmp	 SHORT $LN23@S_getChann
$LN22@S_getChann:

; 222  : 		else
; 223  : 		{
; 224  : 			// Otherwise, kick out lower priority.
; 225  : 			S_StopChannel(cnum);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 _S_StopChannel
  001e1	83 c4 04	 add	 esp, 4
$LN23@S_getChann:

; 226  : 		}
; 227  : 	}
; 228  : 
; 229  : 	c = &channels[cnum];

  001e4	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  001e8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _channels
  001ee	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 230  : 
; 231  : 	// channel is decided to be cnum.
; 232  : 	c->sfxinfo = sfxinfo;

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001f4	8b 4d 0c	 mov	 ecx, DWORD PTR _sfxinfo$[ebp]
  001f7	89 08		 mov	 DWORD PTR [eax], ecx

; 233  : 	c->origin = origin;

  001f9	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  001fc	8b 4d 08	 mov	 ecx, DWORD PTR _origin$[ebp]
  001ff	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 234  : 
; 235  : 	return cnum;

  00202	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
$LN1@S_getChann:

; 236  : }

  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	5b		 pop	 ebx
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c3		 ret	 0
_S_getChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StopChannel
_TEXT	SEGMENT
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_cnum$ = 8						; size = 4
_S_StopChannel PROC					; COMDAT

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1122 : 	INT32 i;
; 1123 : 	channel_t *c = &channels[cnum];

  00009	6b 45 08 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0000d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _channels
  00013	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 1124 : 
; 1125 : 	if (c->sfxinfo)

  00016	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00019	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001c	74 7b		 je	 SHORT $LN5@S_StopChan

; 1126 : 	{
; 1127 : 		// stop the sound playing
; 1128 : 		if (I_SoundIsPlaying(c->handle))

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00021	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 _I_SoundIsPlaying
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	74 0f		 je	 SHORT $LN6@S_StopChan

; 1129 : 			I_StopSound(c->handle);

  00031	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00034	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _I_StopSound
  0003d	83 c4 04	 add	 esp, 4
$LN6@S_StopChan:

; 1130 : 
; 1131 : 		// check to see
; 1132 : 		//  if other channels are playing the sound
; 1133 : 		for (i = 0; i < numofchannels; i++)

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN4@S_StopChan
$LN2@S_StopChan:
  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@S_StopChan:
  00052	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00055	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  0005b	7d 20		 jge	 SHORT $LN3@S_StopChan

; 1134 : 			if (cnum != i && c->sfxinfo == channels[i].sfxinfo)

  0005d	8b 45 08	 mov	 eax, DWORD PTR _cnum$[ebp]
  00060	3b 45 fc	 cmp	 eax, DWORD PTR _i$[ebp]
  00063	74 16		 je	 SHORT $LN7@S_StopChan
  00065	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  0006c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _channels
  00072	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00074	3b 0c 02	 cmp	 ecx, DWORD PTR [edx+eax]
  00077	75 02		 jne	 SHORT $LN7@S_StopChan

; 1135 : 				break;

  00079	eb 02		 jmp	 SHORT $LN3@S_StopChan
$LN7@S_StopChan:
  0007b	eb cc		 jmp	 SHORT $LN2@S_StopChan
$LN3@S_StopChan:

; 1136 : 
; 1137 : 		// degrade usefulness of sound data
; 1138 : 		c->sfxinfo->usefulness--;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00085	83 ea 01	 sub	 edx, 1
  00088	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 1139 : 
; 1140 : 		c->sfxinfo = 0;

  00090	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00093	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN5@S_StopChan:

; 1141 : 	}
; 1142 : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_S_StopChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _SetChannelsNum
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SetChannelsNum PROC					; COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 284  : 	INT32 i;
; 285  : 
; 286  : 	// Allocating the internal channels for mixing
; 287  : 	// (the maximum number of sounds rendered
; 288  : 	// simultaneously) within zone memory.
; 289  : 	if (channels)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _channels, 0
  00010	74 06		 je	 SHORT $LN5@SetChannel

; 290  : 		S_StopSounds();

  00012	e8 00 00 00 00	 call	 _S_StopSounds
  00017	90		 npad	 1
$LN5@SetChannel:

; 291  : 
; 292  : 	Z_Free(channels);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _channels
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _Z_Free
  00023	83 c4 04	 add	 esp, 4

; 293  : 	channels = NULL;

  00026	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _channels, 0

; 294  : 
; 295  : 
; 296  : 	if (cv_numChannels.value == 999999999) //Alam_GBC: OH MY ROD!(ROD rimmiced with GOD!)

  00030	81 3d 14 00 00
	00 ff c9 9a 3b	 cmp	 DWORD PTR _cv_numChannels+20, 999999999 ; 3b9ac9ffH
  0003a	75 13		 jne	 SHORT $LN6@SetChannel

; 297  : 		CV_StealthSet(&cv_numChannels,cv_numChannels.defaultvalue);

  0003c	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_numChannels+4
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET _cv_numChannels
  00047	e8 00 00 00 00	 call	 _CV_StealthSet
  0004c	83 c4 08	 add	 esp, 8
$LN6@SetChannel:

; 298  : 
; 299  : #ifdef HW3SOUND
; 300  : 	if (hws_mode != HWS_DEFAULT_MODE)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00056	74 08		 je	 SHORT $LN7@SetChannel

; 301  : 	{
; 302  : 		HW3S_SetSourcesNum();

  00058	e8 00 00 00 00	 call	 _HW3S_SetSourcesNum
  0005d	90		 npad	 1

; 303  : 		return;

  0005e	eb 5e		 jmp	 SHORT $LN3@SetChannel
$LN7@SetChannel:

; 304  : 	}
; 305  : #endif
; 306  : 	if (cv_numChannels.value)

  00060	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_numChannels+20, 0
  00067	74 1b		 je	 SHORT $LN8@SetChannel

; 307  : 		channels = (channel_t *)Z_Malloc(cv_numChannels.value * sizeof (channel_t), PU_STATIC, NULL);

  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	6a 01		 push	 1
  0006f	6b 05 14 00 00
	00 0c		 imul	 eax, DWORD PTR _cv_numChannels+20, 12
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _Z_MallocAlign
  0007c	83 c4 10	 add	 esp, 16			; 00000010H
  0007f	a3 00 00 00 00	 mov	 DWORD PTR _channels, eax
$LN8@SetChannel:

; 308  : 	numofchannels = cv_numChannels.value;

  00084	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_numChannels+20
  00089	a3 00 00 00 00	 mov	 DWORD PTR _numofchannels, eax

; 309  : 
; 310  : 	// Free all channels for use
; 311  : 	for (i = 0; i < numofchannels; i++)

  0008e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00095	eb 09		 jmp	 SHORT $LN4@SetChannel
$LN2@SetChannel:
  00097	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	83 c0 01	 add	 eax, 1
  0009d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@SetChannel:
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  000a9	7d 13		 jge	 SHORT $LN3@SetChannel

; 312  : 		channels[i].sfxinfo = 0;

  000ab	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  000b5	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0
  000bc	eb d9		 jmp	 SHORT $LN2@SetChannel
$LN3@SetChannel:

; 313  : }

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_SetChannelsNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_AdjustSoundParams
_TEXT	SEGMENT
tv235 = -132						; size = 4
_newdist$1 = -64					; size = 4
_closey$2 = -60						; size = 4
_closex$3 = -56						; size = 4
_xh$4 = -52						; size = 4
_xl$5 = -48						; size = 4
_yh$6 = -44						; size = 4
_yl$7 = -40						; size = 4
_y$8 = -36						; size = 4
_x$9 = -32						; size = 4
_listensource$ = -28					; size = 16
_angle$ = -12						; size = 4
_approx_dist$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_listener$ = 8						; size = 4
_source$ = 12						; size = 4
_vol$ = 16						; size = 4
_sep$ = 20						; size = 4
_pitch$ = 24						; size = 4
_sfxinfo$ = 28						; size = 4
_S_AdjustSoundParams PROC				; COMDAT

; 1180 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1181 : 	fixed_t approx_dist;
; 1182 : 	angle_t angle;
; 1183 : 
; 1184 : 	listener_t listensource;
; 1185 : 
; 1186 : 	pitch = NULL;

  00016	c7 45 18 00 00
	00 00		 mov	 DWORD PTR _pitch$[ebp], 0

; 1187 : 	if (!listener)

  0001d	83 7d 08 00	 cmp	 DWORD PTR _listener$[ebp], 0
  00021	75 07		 jne	 SHORT $LN8@S_AdjustSo

; 1188 : 		return false;

  00023	33 c0		 xor	 eax, eax
  00025	e9 49 03 00 00	 jmp	 $LN1@S_AdjustSo
$LN8@S_AdjustSo:

; 1189 : 
; 1190 : 	if (listener == players[displayplayer].mo && cv_chasecam.value)

  0002a	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _listener$[ebp]
  00037	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _players[eax]
  0003d	75 2b		 jne	 SHORT $LN9@S_AdjustSo
  0003f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam+20, 0
  00046	74 22		 je	 SHORT $LN9@S_AdjustSo

; 1191 : 	{
; 1192 : 		listensource.x = camera.x;

  00048	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera+16
  0004d	89 45 e4	 mov	 DWORD PTR _listensource$[ebp], eax

; 1193 : 		listensource.y = camera.y;

  00050	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera+20
  00055	89 45 e8	 mov	 DWORD PTR _listensource$[ebp+4], eax

; 1194 : 		listensource.z = camera.z;

  00058	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera+24
  0005d	89 45 ec	 mov	 DWORD PTR _listensource$[ebp+8], eax

; 1195 : 		listensource.angle = camera.angle;

  00060	a1 1c 00 00 00	 mov	 eax, DWORD PTR _camera+28
  00065	89 45 f0	 mov	 DWORD PTR _listensource$[ebp+12], eax

; 1196 : 	}

  00068	eb 6d		 jmp	 SHORT $LN12@S_AdjustSo
$LN9@S_AdjustSo:

; 1197 : 	else if (splitscreen && listener == players[secondarydisplayplayer].mo && cv_chasecam2.value)

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00071	74 40		 je	 SHORT $LN11@S_AdjustSo
  00073	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _listener$[ebp]
  00080	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _players[eax]
  00086	75 2b		 jne	 SHORT $LN11@S_AdjustSo
  00088	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam2+20, 0
  0008f	74 22		 je	 SHORT $LN11@S_AdjustSo

; 1198 : 	{
; 1199 : 		listensource.x = camera2.x;

  00091	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera2+16
  00096	89 45 e4	 mov	 DWORD PTR _listensource$[ebp], eax

; 1200 : 		listensource.y = camera2.y;

  00099	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera2+20
  0009e	89 45 e8	 mov	 DWORD PTR _listensource$[ebp+4], eax

; 1201 : 		listensource.z = camera2.z;

  000a1	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera2+24
  000a6	89 45 ec	 mov	 DWORD PTR _listensource$[ebp+8], eax

; 1202 : 		listensource.angle = camera2.angle;

  000a9	a1 1c 00 00 00	 mov	 eax, DWORD PTR _camera2+28
  000ae	89 45 f0	 mov	 DWORD PTR _listensource$[ebp+12], eax

; 1203 : 	}

  000b1	eb 24		 jmp	 SHORT $LN12@S_AdjustSo
$LN11@S_AdjustSo:

; 1204 : 	else
; 1205 : 	{
; 1206 : 		listensource.x = listener->x;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _listener$[ebp]
  000b6	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b9	89 4d e4	 mov	 DWORD PTR _listensource$[ebp], ecx

; 1207 : 		listensource.y = listener->y;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _listener$[ebp]
  000bf	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c2	89 4d e8	 mov	 DWORD PTR _listensource$[ebp+4], ecx

; 1208 : 		listensource.z = listener->z;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _listener$[ebp]
  000c8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000cb	89 4d ec	 mov	 DWORD PTR _listensource$[ebp+8], ecx

; 1209 : 		listensource.angle = listener->angle;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _listener$[ebp]
  000d1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000d4	89 4d f0	 mov	 DWORD PTR _listensource$[ebp+12], ecx
$LN12@S_AdjustSo:

; 1210 : 	}
; 1211 : 
; 1212 : 	if (sfxinfo->pitch & SF_OUTSIDESOUND) // Rain special case

  000d7	8b 45 1c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  000da	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000dd	83 e1 04	 and	 ecx, 4
  000e0	0f 84 07 01 00
	00		 je	 $LN13@S_AdjustSo

; 1213 : 	{
; 1214 : 		fixed_t x, y, yl, yh, xl, xh, closex, closey, newdist;
; 1215 : 
; 1216 : 		if (R_PointInSubsector(listensource.x, listensource.y)->sector->ceilingpic == skyflatnum)

  000e6	8b 45 e8	 mov	 eax, DWORD PTR _listensource$[ebp+4]
  000e9	50		 push	 eax
  000ea	8b 4d e4	 mov	 ecx, DWORD PTR _listensource$[ebp]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 _R_PointInSubsector
  000f3	83 c4 08	 add	 esp, 8
  000f6	8b 10		 mov	 edx, DWORD PTR [eax]
  000f8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000fb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _skyflatnum
  00101	75 0c		 jne	 SHORT $LN15@S_AdjustSo

; 1217 : 			approx_dist = 0;

  00103	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _approx_dist$[ebp], 0
  0010a	e9 dc 00 00 00	 jmp	 $LN3@S_AdjustSo
$LN15@S_AdjustSo:

; 1218 : 		else
; 1219 : 		{
; 1220 : 			// Essentially check in a 1024 unit radius of the player for an outdoor area.
; 1221 : 			yl = listensource.y - 1024*FRACUNIT;

  0010f	8b 45 e8	 mov	 eax, DWORD PTR _listensource$[ebp+4]
  00112	2d 00 00 00 04	 sub	 eax, 67108864		; 04000000H
  00117	89 45 d8	 mov	 DWORD PTR _yl$7[ebp], eax

; 1222 : 			yh = listensource.y + 1024*FRACUNIT;

  0011a	8b 45 e8	 mov	 eax, DWORD PTR _listensource$[ebp+4]
  0011d	05 00 00 00 04	 add	 eax, 67108864		; 04000000H
  00122	89 45 d4	 mov	 DWORD PTR _yh$6[ebp], eax

; 1223 : 			xl = listensource.x - 1024*FRACUNIT;

  00125	8b 45 e4	 mov	 eax, DWORD PTR _listensource$[ebp]
  00128	2d 00 00 00 04	 sub	 eax, 67108864		; 04000000H
  0012d	89 45 d0	 mov	 DWORD PTR _xl$5[ebp], eax

; 1224 : 			xh = listensource.x + 1024*FRACUNIT;

  00130	8b 45 e4	 mov	 eax, DWORD PTR _listensource$[ebp]
  00133	05 00 00 00 04	 add	 eax, 67108864		; 04000000H
  00138	89 45 cc	 mov	 DWORD PTR _xh$4[ebp], eax

; 1225 : 			closex = listensource.x + 2048*FRACUNIT;

  0013b	8b 45 e4	 mov	 eax, DWORD PTR _listensource$[ebp]
  0013e	05 00 00 00 08	 add	 eax, 134217728		; 08000000H
  00143	89 45 c8	 mov	 DWORD PTR _closex$3[ebp], eax

; 1226 : 			closey = listensource.y + 2048*FRACUNIT;

  00146	8b 45 e8	 mov	 eax, DWORD PTR _listensource$[ebp+4]
  00149	05 00 00 00 08	 add	 eax, 134217728		; 08000000H
  0014e	89 45 c4	 mov	 DWORD PTR _closey$2[ebp], eax

; 1227 : 			approx_dist = 1024*FRACUNIT;

  00151	c7 45 f8 00 00
	00 04		 mov	 DWORD PTR _approx_dist$[ebp], 67108864 ; 04000000H

; 1228 : 			for (y = yl; y <= yh; y += FRACUNIT*64)

  00158	8b 45 d8	 mov	 eax, DWORD PTR _yl$7[ebp]
  0015b	89 45 dc	 mov	 DWORD PTR _y$8[ebp], eax
  0015e	eb 0b		 jmp	 SHORT $LN4@S_AdjustSo
$LN2@S_AdjustSo:
  00160	8b 45 dc	 mov	 eax, DWORD PTR _y$8[ebp]
  00163	05 00 00 40 00	 add	 eax, 4194304		; 00400000H
  00168	89 45 dc	 mov	 DWORD PTR _y$8[ebp], eax
$LN4@S_AdjustSo:
  0016b	8b 45 dc	 mov	 eax, DWORD PTR _y$8[ebp]
  0016e	3b 45 d4	 cmp	 eax, DWORD PTR _yh$6[ebp]
  00171	7f 78		 jg	 SHORT $LN3@S_AdjustSo

; 1229 : 				for (x = xl; x <= xh; x += FRACUNIT*64)

  00173	8b 45 d0	 mov	 eax, DWORD PTR _xl$5[ebp]
  00176	89 45 e0	 mov	 DWORD PTR _x$9[ebp], eax
  00179	eb 0b		 jmp	 SHORT $LN7@S_AdjustSo
$LN5@S_AdjustSo:
  0017b	8b 45 e0	 mov	 eax, DWORD PTR _x$9[ebp]
  0017e	05 00 00 40 00	 add	 eax, 4194304		; 00400000H
  00183	89 45 e0	 mov	 DWORD PTR _x$9[ebp], eax
$LN7@S_AdjustSo:
  00186	8b 45 e0	 mov	 eax, DWORD PTR _x$9[ebp]
  00189	3b 45 cc	 cmp	 eax, DWORD PTR _xh$4[ebp]
  0018c	7f 58		 jg	 SHORT $LN6@S_AdjustSo

; 1230 : 				{
; 1231 : 					if (R_PointInSubsector(x, y)->sector->ceilingpic == skyflatnum)

  0018e	8b 45 dc	 mov	 eax, DWORD PTR _y$8[ebp]
  00191	50		 push	 eax
  00192	8b 4d e0	 mov	 ecx, DWORD PTR _x$9[ebp]
  00195	51		 push	 ecx
  00196	e8 00 00 00 00	 call	 _R_PointInSubsector
  0019b	83 c4 08	 add	 esp, 8
  0019e	8b 10		 mov	 edx, DWORD PTR [eax]
  001a0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001a3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _skyflatnum
  001a9	75 39		 jne	 SHORT $LN18@S_AdjustSo

; 1232 : 					{
; 1233 : 						// Found the outdoors!
; 1234 : 						newdist = S_CalculateSoundDistance(listensource.x, listensource.y, 0, x, y, 0);

  001ab	6a 00		 push	 0
  001ad	8b 45 dc	 mov	 eax, DWORD PTR _y$8[ebp]
  001b0	50		 push	 eax
  001b1	8b 4d e0	 mov	 ecx, DWORD PTR _x$9[ebp]
  001b4	51		 push	 ecx
  001b5	6a 00		 push	 0
  001b7	8b 55 e8	 mov	 edx, DWORD PTR _listensource$[ebp+4]
  001ba	52		 push	 edx
  001bb	8b 45 e4	 mov	 eax, DWORD PTR _listensource$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _S_CalculateSoundDistance
  001c4	83 c4 18	 add	 esp, 24			; 00000018H
  001c7	89 45 c0	 mov	 DWORD PTR _newdist$1[ebp], eax

; 1235 : 						if (newdist < approx_dist)

  001ca	8b 45 c0	 mov	 eax, DWORD PTR _newdist$1[ebp]
  001cd	3b 45 f8	 cmp	 eax, DWORD PTR _approx_dist$[ebp]
  001d0	7d 12		 jge	 SHORT $LN18@S_AdjustSo

; 1236 : 						{
; 1237 : 							closex = x;

  001d2	8b 45 e0	 mov	 eax, DWORD PTR _x$9[ebp]
  001d5	89 45 c8	 mov	 DWORD PTR _closex$3[ebp], eax

; 1238 : 							closey = y;

  001d8	8b 45 dc	 mov	 eax, DWORD PTR _y$8[ebp]
  001db	89 45 c4	 mov	 DWORD PTR _closey$2[ebp], eax

; 1239 : 							approx_dist = newdist;

  001de	8b 45 c0	 mov	 eax, DWORD PTR _newdist$1[ebp]
  001e1	89 45 f8	 mov	 DWORD PTR _approx_dist$[ebp], eax
$LN18@S_AdjustSo:

; 1240 : 						}
; 1241 : 					}
; 1242 : 				}

  001e4	eb 95		 jmp	 SHORT $LN5@S_AdjustSo
$LN6@S_AdjustSo:
  001e6	e9 75 ff ff ff	 jmp	 $LN2@S_AdjustSo
$LN3@S_AdjustSo:

; 1243 : 		}
; 1244 : 	}

  001eb	eb 2c		 jmp	 SHORT $LN14@S_AdjustSo
$LN13@S_AdjustSo:

; 1245 : 	else
; 1246 : 	{
; 1247 : 		approx_dist = S_CalculateSoundDistance(listensource.x, listensource.y, listensource.z,

  001ed	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  001f0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001f3	51		 push	 ecx
  001f4	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  001f7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001fa	50		 push	 eax
  001fb	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  001fe	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00201	52		 push	 edx
  00202	8b 45 ec	 mov	 eax, DWORD PTR _listensource$[ebp+8]
  00205	50		 push	 eax
  00206	8b 4d e8	 mov	 ecx, DWORD PTR _listensource$[ebp+4]
  00209	51		 push	 ecx
  0020a	8b 55 e4	 mov	 edx, DWORD PTR _listensource$[ebp]
  0020d	52		 push	 edx
  0020e	e8 00 00 00 00	 call	 _S_CalculateSoundDistance
  00213	83 c4 18	 add	 esp, 24			; 00000018H
  00216	89 45 f8	 mov	 DWORD PTR _approx_dist$[ebp], eax
$LN14@S_AdjustSo:

; 1248 : 												source->x, source->y, source->z);
; 1249 : 	}
; 1250 : 
; 1251 : 	// Taunts, deaths, etc, should all be heard louder.
; 1252 : 	if (sfxinfo->pitch & SF_X8AWAYSOUND)

  00219	8b 45 1c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  0021c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0021f	83 e1 10	 and	 ecx, 16			; 00000010H
  00222	74 14		 je	 SHORT $LN19@S_AdjustSo

; 1253 : 		approx_dist = FixedDiv(approx_dist,8*FRACUNIT);

  00224	68 00 00 08 00	 push	 524288			; 00080000H
  00229	8b 45 f8	 mov	 eax, DWORD PTR _approx_dist$[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _FixedDiv
  00232	83 c4 08	 add	 esp, 8
  00235	89 45 f8	 mov	 DWORD PTR _approx_dist$[ebp], eax
$LN19@S_AdjustSo:

; 1254 : 
; 1255 : 	// Combine 8XAWAYSOUND with 4XAWAYSOUND and get.... 32XAWAYSOUND?
; 1256 : 	if (sfxinfo->pitch & SF_X4AWAYSOUND)

  00238	8b 45 1c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  0023b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0023e	83 e1 08	 and	 ecx, 8
  00241	74 14		 je	 SHORT $LN20@S_AdjustSo

; 1257 : 		approx_dist = FixedDiv(approx_dist,4*FRACUNIT);

  00243	68 00 00 04 00	 push	 262144			; 00040000H
  00248	8b 45 f8	 mov	 eax, DWORD PTR _approx_dist$[ebp]
  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _FixedDiv
  00251	83 c4 08	 add	 esp, 8
  00254	89 45 f8	 mov	 DWORD PTR _approx_dist$[ebp], eax
$LN20@S_AdjustSo:

; 1258 : 
; 1259 : 	if (sfxinfo->pitch & SF_X2AWAYSOUND)

  00257	8b 45 1c	 mov	 eax, DWORD PTR _sfxinfo$[ebp]
  0025a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0025d	83 e1 40	 and	 ecx, 64			; 00000040H
  00260	74 14		 je	 SHORT $LN21@S_AdjustSo

; 1260 : 		approx_dist = FixedDiv(approx_dist,2*FRACUNIT);

  00262	68 00 00 02 00	 push	 131072			; 00020000H
  00267	8b 45 f8	 mov	 eax, DWORD PTR _approx_dist$[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _FixedDiv
  00270	83 c4 08	 add	 esp, 8
  00273	89 45 f8	 mov	 DWORD PTR _approx_dist$[ebp], eax
$LN21@S_AdjustSo:

; 1261 : 
; 1262 : 	if (approx_dist > S_CLIPPING_DIST)

  00276	81 7d f8 00 00
	00 06		 cmp	 DWORD PTR _approx_dist$[ebp], 100663296 ; 06000000H
  0027d	7e 07		 jle	 SHORT $LN22@S_AdjustSo

; 1263 : 		return 0;

  0027f	33 c0		 xor	 eax, eax
  00281	e9 ed 00 00 00	 jmp	 $LN1@S_AdjustSo
$LN22@S_AdjustSo:

; 1264 : 
; 1265 : 	// angle of source to listener
; 1266 : 	angle = R_PointToAngle2(listensource.x, listensource.y, source->x, source->y);

  00286	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00289	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0028c	51		 push	 ecx
  0028d	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00290	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00293	50		 push	 eax
  00294	8b 4d e8	 mov	 ecx, DWORD PTR _listensource$[ebp+4]
  00297	51		 push	 ecx
  00298	8b 55 e4	 mov	 edx, DWORD PTR _listensource$[ebp]
  0029b	52		 push	 edx
  0029c	e8 00 00 00 00	 call	 _R_PointToAngle2
  002a1	83 c4 10	 add	 esp, 16			; 00000010H
  002a4	89 45 f4	 mov	 DWORD PTR _angle$[ebp], eax

; 1267 : 
; 1268 : 	if (angle > listensource.angle)

  002a7	8b 45 f4	 mov	 eax, DWORD PTR _angle$[ebp]
  002aa	3b 45 f0	 cmp	 eax, DWORD PTR _listensource$[ebp+12]
  002ad	76 0b		 jbe	 SHORT $LN23@S_AdjustSo

; 1269 : 		angle = angle - listensource.angle;

  002af	8b 45 f4	 mov	 eax, DWORD PTR _angle$[ebp]
  002b2	2b 45 f0	 sub	 eax, DWORD PTR _listensource$[ebp+12]
  002b5	89 45 f4	 mov	 DWORD PTR _angle$[ebp], eax
  002b8	eb 10		 jmp	 SHORT $LN24@S_AdjustSo
$LN23@S_AdjustSo:

; 1270 : 	else
; 1271 : 		angle = angle + (ANGLE_MAX - listensource.angle + 1);

  002ba	83 c8 ff	 or	 eax, -1
  002bd	2b 45 f0	 sub	 eax, DWORD PTR _listensource$[ebp+12]
  002c0	8b 4d f4	 mov	 ecx, DWORD PTR _angle$[ebp]
  002c3	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  002c7	89 55 f4	 mov	 DWORD PTR _angle$[ebp], edx
$LN24@S_AdjustSo:

; 1272 : 
; 1273 : #ifdef SURROUND
; 1274 : 	// Produce a surround sound for angle from 105 till 255
; 1275 : 	if (surround.value == 1 && (angle > ANG105 && angle < ANG255 ))

  002ca	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _surround+20, 1
  002d1	75 1d		 jne	 SHORT $LN25@S_AdjustSo
  002d3	81 7d f4 ab aa
	aa 4a		 cmp	 DWORD PTR _angle$[ebp], 1252698795 ; 4aaaaaabH
  002da	76 14		 jbe	 SHORT $LN25@S_AdjustSo
  002dc	81 7d f4 55 55
	55 b5		 cmp	 DWORD PTR _angle$[ebp], -1252698795 ; b5555555H
  002e3	73 0b		 jae	 SHORT $LN25@S_AdjustSo

; 1276 : 		*sep = SURROUND_SEP;

  002e5	8b 45 14	 mov	 eax, DWORD PTR _sep$[ebp]
  002e8	c7 00 80 ff ff
	ff		 mov	 DWORD PTR [eax], -128	; ffffff80H
  002ee	eb 30		 jmp	 SHORT $LN26@S_AdjustSo
$LN25@S_AdjustSo:

; 1277 : 	else
; 1278 : #endif
; 1279 : 	{
; 1280 : 		angle >>= ANGLETOFINESHIFT;

  002f0	8b 45 f4	 mov	 eax, DWORD PTR _angle$[ebp]
  002f3	c1 e8 13	 shr	 eax, 19			; 00000013H
  002f6	89 45 f4	 mov	 DWORD PTR _angle$[ebp], eax

; 1281 : 
; 1282 : 		// stereo separation
; 1283 : 		*sep = 128 - (FixedMul(S_STEREO_SWING, FINESINE(angle))>>FRACBITS);

  002f9	8b 45 f4	 mov	 eax, DWORD PTR _angle$[ebp]
  002fc	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  00303	51		 push	 ecx
  00304	68 00 00 60 00	 push	 6291456			; 00600000H
  00309	e8 00 00 00 00	 call	 _FixedMul
  0030e	83 c4 08	 add	 esp, 8
  00311	c1 f8 10	 sar	 eax, 16			; 00000010H
  00314	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00319	2b d0		 sub	 edx, eax
  0031b	8b 45 14	 mov	 eax, DWORD PTR _sep$[ebp]
  0031e	89 10		 mov	 DWORD PTR [eax], edx
$LN26@S_AdjustSo:

; 1284 : 	}
; 1285 : 
; 1286 : 	// volume calculation
; 1287 : 	if (approx_dist < S_CLOSE_DIST)

  00320	81 7d f8 00 00
	a0 00		 cmp	 DWORD PTR _approx_dist$[ebp], 10485760 ; 00a00000H
  00327	7d 0b		 jge	 SHORT $LN27@S_AdjustSo

; 1288 : 	{
; 1289 : 		// SfxVolume is now hardware volume
; 1290 : 		*vol = 255; // not snd_SfxVolume

  00329	8b 45 10	 mov	 eax, DWORD PTR _vol$[ebp]
  0032c	c7 00 ff 00 00
	00		 mov	 DWORD PTR [eax], 255	; 000000ffH

; 1291 : 	}

  00332	eb 1b		 jmp	 SHORT $LN28@S_AdjustSo
$LN27@S_AdjustSo:

; 1292 : 	else
; 1293 : 	{
; 1294 : 		// distance effect
; 1295 : 		*vol = (15 * ((S_CLIPPING_DIST - approx_dist)>>FRACBITS)) / S_ATTENUATOR;

  00334	b8 00 00 00 06	 mov	 eax, 100663296		; 06000000H
  00339	2b 45 f8	 sub	 eax, DWORD PTR _approx_dist$[ebp]
  0033c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0033f	6b c0 0f	 imul	 eax, eax, 15
  00342	99		 cdq
  00343	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00348	f7 f9		 idiv	 ecx
  0034a	8b 55 10	 mov	 edx, DWORD PTR _vol$[ebp]
  0034d	89 02		 mov	 DWORD PTR [edx], eax
$LN28@S_AdjustSo:

; 1296 : 	}
; 1297 : 
; 1298 : 	return (*vol > 0);

  0034f	8b 45 10	 mov	 eax, DWORD PTR _vol$[ebp]
  00352	83 38 00	 cmp	 DWORD PTR [eax], 0
  00355	7e 0c		 jle	 SHORT $LN30@S_AdjustSo
  00357	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
  00361	eb 0a		 jmp	 SHORT $LN31@S_AdjustSo
$LN30@S_AdjustSo:
  00363	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN31@S_AdjustSo:
  0036d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv235[ebp]
$LN1@S_AdjustSo:

; 1299 : }

  00373	5f		 pop	 edi
  00374	5e		 pop	 esi
  00375	5b		 pop	 ebx
  00376	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00379	33 cd		 xor	 ecx, ebp
  0037b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00380	8b e5		 mov	 esp, ebp
  00382	5d		 pop	 ebp
  00383	c3		 ret	 0
_S_AdjustSoundParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StopSoundByNum
_TEXT	SEGMENT
_cnum$ = -4						; size = 4
_sfxnum$ = 8						; size = 4
_S_StopSoundByNum PROC					; COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 406  : 	INT32 cnum;
; 407  : 
; 408  : #ifdef HW3SOUND
; 409  : 	if (hws_mode != HWS_DEFAULT_MODE)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00010	74 0e		 je	 SHORT $LN5@S_StopSoun

; 410  : 	{
; 411  : 		HW3S_StopSoundByNum(sfxnum);

  00012	8b 45 08	 mov	 eax, DWORD PTR _sfxnum$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _HW3S_StopSoundByNum
  0001b	83 c4 04	 add	 esp, 4

; 412  : 		return;

  0001e	eb 46		 jmp	 SHORT $LN3@S_StopSoun
$LN5@S_StopSoun:

; 413  : 	}
; 414  : #endif
; 415  : 	for (cnum = 0; cnum < numofchannels; cnum++)

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@S_StopSoun
$LN2@S_StopSoun:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR _cnum$[ebp], eax
$LN4@S_StopSoun:
  00032	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00035	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  0003b	7d 29		 jge	 SHORT $LN3@S_StopSoun

; 416  : 	{
; 417  : 		if (channels[cnum].sfxinfo == &S_sfx[sfxnum])

  0003d	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00041	6b 4d 08 2c	 imul	 ecx, DWORD PTR _sfxnum$[ebp], 44
  00045	81 c1 00 00 00
	00		 add	 ecx, OFFSET _S_sfx
  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _channels
  00051	39 0c 02	 cmp	 DWORD PTR [edx+eax], ecx
  00054	75 0e		 jne	 SHORT $LN6@S_StopSoun

; 418  : 		{
; 419  : 			S_StopChannel(cnum);

  00056	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _S_StopChannel
  0005f	83 c4 04	 add	 esp, 4

; 420  : 			break;

  00062	eb 02		 jmp	 SHORT $LN3@S_StopSoun
$LN6@S_StopSoun:

; 421  : 		}
; 422  : 	}

  00064	eb c3		 jmp	 SHORT $LN2@S_StopSoun
$LN3@S_StopSoun:

; 423  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_S_StopSoundByNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StartSoundName
_TEXT	SEGMENT
_soundnum$ = -8						; size = 4
_i$ = -4						; size = 4
_mo$ = 8						; size = 4
_soundname$ = 12					; size = 4
_S_StartSoundName PROC					; COMDAT

; 1330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1331 : 	INT32 i, soundnum = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _soundnum$[ebp], 0

; 1332 : 	// Search existing sounds...
; 1333 : 	for (i = sfx_None + 1; i < NUMSFX; i++)

  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00017	eb 09		 jmp	 SHORT $LN4@S_StartSou
$LN2@S_StartSou:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@S_StartSou:
  00022	81 7d fc 63 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  00029	7d 34		 jge	 SHORT $LN3@S_StartSou

; 1334 : 	{
; 1335 : 		if (!S_sfx[i].name)

  0002b	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  0002f	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _S_sfx[eax], 0
  00036	75 02		 jne	 SHORT $LN8@S_StartSou

; 1336 : 			continue;

  00038	eb df		 jmp	 SHORT $LN2@S_StartSou
$LN8@S_StartSou:

; 1337 : 		if (!stricmp(S_sfx[i].name, soundname))

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _soundname$[ebp]
  0003d	50		 push	 eax
  0003e	6b 4d fc 2c	 imul	 ecx, DWORD PTR _i$[ebp], 44
  00042	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _S_sfx[ecx]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _stricmp
  0004e	83 c4 08	 add	 esp, 8
  00051	85 c0		 test	 eax, eax
  00053	75 08		 jne	 SHORT $LN9@S_StartSou

; 1338 : 		{
; 1339 : 			soundnum = i;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00058	89 45 f8	 mov	 DWORD PTR _soundnum$[ebp], eax

; 1340 : 			break;

  0005b	eb 02		 jmp	 SHORT $LN3@S_StartSou
$LN9@S_StartSou:

; 1341 : 		}
; 1342 : 	}

  0005d	eb ba		 jmp	 SHORT $LN2@S_StartSou
$LN3@S_StartSou:

; 1343 : 
; 1344 : 	if (!soundnum)

  0005f	83 7d f8 00	 cmp	 DWORD PTR _soundnum$[ebp], 0
  00063	0f 85 8e 00 00
	00		 jne	 $LN10@S_StartSou

; 1345 : 	{
; 1346 : 		for (i = 0; i < MAXNEWSOUNDS; i++)

  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00070	eb 09		 jmp	 SHORT $LN7@S_StartSou
$LN5@S_StartSou:
  00072	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00075	83 c0 01	 add	 eax, 1
  00078	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@S_StartSou:
  0007b	83 7d fc 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  0007f	7d 3f		 jge	 SHORT $LN6@S_StartSou

; 1347 : 		{
; 1348 : 			if (newsounds[i] == 0)

  00081	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00084	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _newsounds[eax*4], 0
  0008c	75 02		 jne	 SHORT $LN11@S_StartSou

; 1349 : 				break;

  0008e	eb 30		 jmp	 SHORT $LN6@S_StartSou
$LN11@S_StartSou:

; 1350 : 			if (!S_SoundPlaying(NULL, newsounds[i]))

  00090	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00093	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _newsounds[eax*4]
  0009a	51		 push	 ecx
  0009b	6a 00		 push	 0
  0009d	e8 00 00 00 00	 call	 _S_SoundPlaying
  000a2	83 c4 08	 add	 esp, 8
  000a5	85 c0		 test	 eax, eax
  000a7	75 15		 jne	 SHORT $LN12@S_StartSou

; 1351 : 			{
; 1352 : 				S_RemoveSoundFx(newsounds[i]);

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ac	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _newsounds[eax*4]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _S_RemoveSoundFx
  000b9	83 c4 04	 add	 esp, 4

; 1353 : 				break;

  000bc	eb 02		 jmp	 SHORT $LN6@S_StartSou
$LN12@S_StartSou:

; 1354 : 			}
; 1355 : 		}

  000be	eb b2		 jmp	 SHORT $LN5@S_StartSou
$LN6@S_StartSou:

; 1356 : 
; 1357 : 		if (i == MAXNEWSOUNDS)

  000c0	83 7d fc 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  000c4	75 0f		 jne	 SHORT $LN13@S_StartSou

; 1358 : 		{
; 1359 : 			CONS_Printf("Cannot load another extra sound!\n");

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@CDDDMENG@Cannot?5load?5another?5extra?5sound@
  000cb	e8 00 00 00 00	 call	 _CONS_Printf
  000d0	83 c4 04	 add	 esp, 4

; 1360 : 			return;

  000d3	eb 32		 jmp	 SHORT $LN1@S_StartSou
$LN13@S_StartSou:

; 1361 : 		}
; 1362 : 
; 1363 : 		soundnum = S_AddSoundFx(soundname, false, -1, false);

  000d5	6a 00		 push	 0
  000d7	6a ff		 push	 -1
  000d9	6a 00		 push	 0
  000db	8b 45 0c	 mov	 eax, DWORD PTR _soundname$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _S_AddSoundFx
  000e4	83 c4 10	 add	 esp, 16			; 00000010H
  000e7	89 45 f8	 mov	 DWORD PTR _soundnum$[ebp], eax

; 1364 : 		newsounds[i] = soundnum;

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _soundnum$[ebp]
  000f0	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _newsounds[eax*4], ecx
$LN10@S_StartSou:

; 1365 : 	}
; 1366 : 
; 1367 : 	S_StartSound(mo, soundnum);

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _soundnum$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _S_StartSound
  00104	83 c4 08	 add	 esp, 8
$LN1@S_StartSou:

; 1368 : }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_S_StartSoundName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_SoundPlaying
_TEXT	SEGMENT
_cnum$ = -4						; size = 4
_origin$ = 8						; size = 4
_id$ = 12						; size = 4
_S_SoundPlaying PROC					; COMDAT

; 1305 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1306 : 	INT32 cnum;
; 1307 : 
; 1308 : #ifdef HW3SOUND
; 1309 : 	if (hws_mode != HWS_DEFAULT_MODE)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00010	74 12		 je	 SHORT $LN5@S_SoundPla

; 1310 : 		return HW3S_SoundPlaying(origin, id);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _origin$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _HW3S_SoundPlaying
  0001f	83 c4 08	 add	 esp, 8
  00022	eb 70		 jmp	 SHORT $LN1@S_SoundPla
$LN5@S_SoundPla:

; 1311 : #endif
; 1312 : 
; 1313 : 	for (cnum = 0; cnum < numofchannels; cnum++)

  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@S_SoundPla
$LN2@S_SoundPla:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 fc	 mov	 DWORD PTR _cnum$[ebp], eax
$LN4@S_SoundPla:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00039	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  0003f	7d 51		 jge	 SHORT $LN3@S_SoundPla

; 1314 : 	{
; 1315 : 		if (origin && channels[cnum].origin == origin)

  00041	83 7d 08 00	 cmp	 DWORD PTR _origin$[ebp], 0
  00045	74 1a		 je	 SHORT $LN6@S_SoundPla
  00047	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00051	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00055	3b 55 08	 cmp	 edx, DWORD PTR _origin$[ebp]
  00058	75 07		 jne	 SHORT $LN6@S_SoundPla

; 1316 : 			return 1;

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	eb 33		 jmp	 SHORT $LN1@S_SoundPla
$LN6@S_SoundPla:

; 1317 : 		if (id != NUMSFX && (size_t)(channels[cnum].sfxinfo - S_sfx) == (size_t)id)

  00061	81 7d 0c 63 07
	00 00		 cmp	 DWORD PTR _id$[ebp], 1891 ; 00000763H
  00068	74 26		 je	 SHORT $LN7@S_SoundPla
  0006a	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00074	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00077	2d 00 00 00 00	 sub	 eax, OFFSET _S_sfx
  0007c	99		 cdq
  0007d	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00082	f7 f9		 idiv	 ecx
  00084	3b 45 0c	 cmp	 eax, DWORD PTR _id$[ebp]
  00087	75 07		 jne	 SHORT $LN7@S_SoundPla

; 1318 : 			return 1;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	eb 04		 jmp	 SHORT $LN1@S_SoundPla
$LN7@S_SoundPla:

; 1319 : 	}

  00090	eb 9b		 jmp	 SHORT $LN2@S_SoundPla
$LN3@S_SoundPla:

; 1320 : 	return 0;

  00092	33 c0		 xor	 eax, eax
$LN1@S_SoundPla:

; 1321 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_S_SoundPlaying ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_SetSfxVolume
_TEXT	SEGMENT
tv75 = -68						; size = 4
_volume$ = 8						; size = 4
_S_SetSfxVolume PROC					; COMDAT

; 969  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 970  : 	if (volume < 0 || volume > 31)

  00009	83 7d 08 00	 cmp	 DWORD PTR _volume$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@S_SetSfxVo
  0000f	83 7d 08 1f	 cmp	 DWORD PTR _volume$[ebp], 31 ; 0000001fH
  00013	7e 0d		 jle	 SHORT $LN2@S_SetSfxVo
$LN3@S_SetSfxVo:

; 971  : 		CONS_Printf("sfxvolume should be between 0-31\n");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PDCFMAGF@sfxvolume?5should?5be?5between?50?93@
  0001a	e8 00 00 00 00	 call	 _CONS_Printf
  0001f	83 c4 04	 add	 esp, 4
$LN2@S_SetSfxVo:

; 972  : 
; 973  : 	CV_SetValue(&cv_soundvolume, volume&31);

  00022	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  00025	83 e0 1f	 and	 eax, 31			; 0000001fH
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET _cv_soundvolume
  0002e	e8 00 00 00 00	 call	 _CV_SetValue
  00033	83 c4 08	 add	 esp, 8

; 974  : 	actualsfxvolume = cv_soundvolume.value; // check for change of var

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_soundvolume+20
  0003b	a3 00 00 00 00	 mov	 DWORD PTR _actualsfxvolume, eax

; 975  : 
; 976  : #ifdef HW3SOUND
; 977  : 	hws_mode == HWS_DEFAULT_MODE ? I_SetSfxVolume(volume&31) : HW3S_SetSfxVolume(volume&31);

  00040	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00047	75 18		 jne	 SHORT $LN5@S_SetSfxVo
  00049	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  0004c	83 e0 1f	 and	 eax, 31			; 0000001fH
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _I_SetSfxVolume
  00055	83 c4 04	 add	 esp, 4
  00058	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  0005f	eb 16		 jmp	 SHORT $LN6@S_SetSfxVo
$LN5@S_SetSfxVo:
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _volume$[ebp]
  00064	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _HW3S_SetSfxVolume
  0006d	83 c4 04	 add	 esp, 4
  00070	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN6@S_SetSfxVo:

; 978  : #else
; 979  : 	// now hardware volume
; 980  : 	I_SetSfxVolume(volume&31);
; 981  : #endif
; 982  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_S_SetSfxVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_SetMIDIMusicVolume
_TEXT	SEGMENT
_volume$ = 8						; size = 4
_S_SetMIDIMusicVolume PROC				; COMDAT

; 954  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 955  : 	if (volume < 0 || volume > 31)

  00009	83 7d 08 00	 cmp	 DWORD PTR _volume$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@S_SetMIDIM
  0000f	83 7d 08 1f	 cmp	 DWORD PTR _volume$[ebp], 31 ; 0000001fH
  00013	7e 0d		 jle	 SHORT $LN2@S_SetMIDIM
$LN3@S_SetMIDIM:

; 956  : 		CONS_Printf("musicvolume should be between 0-31\n");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IHIONKGF@musicvolume?5should?5be?5between?50@
  0001a	e8 00 00 00 00	 call	 _CONS_Printf
  0001f	83 c4 04	 add	 esp, 4
$LN2@S_SetMIDIM:

; 957  : 
; 958  : 	CV_SetValue(&cv_midimusicvolume, volume&31);

  00022	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  00025	83 e0 1f	 and	 eax, 31			; 0000001fH
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET _cv_midimusicvolume
  0002e	e8 00 00 00 00	 call	 _CV_SetValue
  00033	83 c4 08	 add	 esp, 8

; 959  : 	actualmidimusicvolume = cv_midimusicvolume.value;   //check for change of var

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_midimusicvolume+20
  0003b	a3 00 00 00 00	 mov	 DWORD PTR _actualmidimusicvolume, eax

; 960  : 
; 961  : #ifdef DJGPPDOS
; 962  : 	I_SetMIDIMusicVolume(31); // Trick for buggy dos drivers. Win32 doesn't need this.
; 963  : #endif
; 964  : 
; 965  : 	I_SetMIDIMusicVolume(volume&31);

  00040	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  00043	83 e0 1f	 and	 eax, 31			; 0000001fH
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _I_SetMIDIMusicVolume
  0004c	83 c4 04	 add	 esp, 4

; 966  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_S_SetMIDIMusicVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_SetDigMusicVolume
_TEXT	SEGMENT
_volume$ = 8						; size = 4
_S_SetDigMusicVolume PROC				; COMDAT

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 939  : 	if (volume < 0 || volume > 31)

  00009	83 7d 08 00	 cmp	 DWORD PTR _volume$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@S_SetDigMu
  0000f	83 7d 08 1f	 cmp	 DWORD PTR _volume$[ebp], 31 ; 0000001fH
  00013	7e 0d		 jle	 SHORT $LN2@S_SetDigMu
$LN3@S_SetDigMu:

; 940  : 		CONS_Printf("musicvolume should be between 0-31\n");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IHIONKGF@musicvolume?5should?5be?5between?50@
  0001a	e8 00 00 00 00	 call	 _CONS_Printf
  0001f	83 c4 04	 add	 esp, 4
$LN2@S_SetDigMu:

; 941  : 
; 942  : 	CV_SetValue(&cv_digmusicvolume, volume&31);

  00022	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  00025	83 e0 1f	 and	 eax, 31			; 0000001fH
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET _cv_digmusicvolume
  0002e	e8 00 00 00 00	 call	 _CV_SetValue
  00033	83 c4 08	 add	 esp, 8

; 943  : 	actualdigmusicvolume = cv_digmusicvolume.value;   //check for change of var

  00036	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_digmusicvolume+20
  0003b	a3 00 00 00 00	 mov	 DWORD PTR _actualdigmusicvolume, eax

; 944  : 
; 945  : #ifdef DJGPPDOS
; 946  : 	I_SetDigMusicVolume(31); // Trick for buggy dos drivers. Win32 doesn't need this.
; 947  : #endif
; 948  : 
; 949  : 	if (!nodigimusic)

  00040	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00047	75 0f		 jne	 SHORT $LN4@S_SetDigMu

; 950  : 		I_SetDigMusicVolume(volume&31);

  00049	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  0004c	83 e0 1f	 and	 eax, 31			; 0000001fH
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _I_SetDigMusicVolume
  00055	83 c4 04	 add	 esp, 4
$LN4@S_SetDigMu:

; 951  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_S_SetDigMusicVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_CalculateSoundDistance
_TEXT	SEGMENT
tv76 = -80						; size = 4
tv86 = -80						; size = 4
_ady$ = -12						; size = 4
_adx$ = -8						; size = 4
_approx_dist$ = -4					; size = 4
_sx1$ = 8						; size = 4
_sy1$ = 12						; size = 4
_sz1$ = 16						; size = 4
_sx2$ = 20						; size = 4
_sy2$ = 24						; size = 4
_sz2$ = 28						; size = 4
_S_CalculateSoundDistance PROC				; COMDAT

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1152 : 	fixed_t approx_dist, adx, ady;
; 1153 : 
; 1154 : 	// calculate the distance to sound origin and clip it if necessary
; 1155 : 	adx = abs((sx1>>FRACBITS) - (sx2>>FRACBITS));

  00009	8b 45 08	 mov	 eax, DWORD PTR _sx1$[ebp]
  0000c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0000f	8b 4d 14	 mov	 ecx, DWORD PTR _sx2$[ebp]
  00012	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00015	2b c1		 sub	 eax, ecx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _abs
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f8	 mov	 DWORD PTR _adx$[ebp], eax

; 1156 : 	ady = abs((sy1>>FRACBITS) - (sy2>>FRACBITS));

  00023	8b 45 0c	 mov	 eax, DWORD PTR _sy1$[ebp]
  00026	c1 f8 10	 sar	 eax, 16			; 00000010H
  00029	8b 4d 18	 mov	 ecx, DWORD PTR _sy2$[ebp]
  0002c	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0002f	2b c1		 sub	 eax, ecx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _abs
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 f4	 mov	 DWORD PTR _ady$[ebp], eax

; 1157 : 
; 1158 : 	// From _GG1_ p.428. Approx. euclidian distance fast.
; 1159 : 	// Take Z into account
; 1160 : 	adx = adx + ady - ((adx < ady ? adx : ady)>>1);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  00040	3b 45 f4	 cmp	 eax, DWORD PTR _ady$[ebp]
  00043	7d 08		 jge	 SHORT $LN4@S_Calculat
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _adx$[ebp]
  00048	89 4d b0	 mov	 DWORD PTR tv76[ebp], ecx
  0004b	eb 06		 jmp	 SHORT $LN5@S_Calculat
$LN4@S_Calculat:
  0004d	8b 55 f4	 mov	 edx, DWORD PTR _ady$[ebp]
  00050	89 55 b0	 mov	 DWORD PTR tv76[ebp], edx
$LN5@S_Calculat:
  00053	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  00056	03 45 f4	 add	 eax, DWORD PTR _ady$[ebp]
  00059	8b 4d b0	 mov	 ecx, DWORD PTR tv76[ebp]
  0005c	d1 f9		 sar	 ecx, 1
  0005e	2b c1		 sub	 eax, ecx
  00060	89 45 f8	 mov	 DWORD PTR _adx$[ebp], eax

; 1161 : 	ady = abs((sz1>>FRACBITS) - (sz2>>FRACBITS));

  00063	8b 45 10	 mov	 eax, DWORD PTR _sz1$[ebp]
  00066	c1 f8 10	 sar	 eax, 16			; 00000010H
  00069	8b 4d 1c	 mov	 ecx, DWORD PTR _sz2$[ebp]
  0006c	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0006f	2b c1		 sub	 eax, ecx
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _abs
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 f4	 mov	 DWORD PTR _ady$[ebp], eax

; 1162 : 	approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  00080	3b 45 f4	 cmp	 eax, DWORD PTR _ady$[ebp]
  00083	7d 08		 jge	 SHORT $LN6@S_Calculat
  00085	8b 4d f8	 mov	 ecx, DWORD PTR _adx$[ebp]
  00088	89 4d b0	 mov	 DWORD PTR tv86[ebp], ecx
  0008b	eb 06		 jmp	 SHORT $LN7@S_Calculat
$LN6@S_Calculat:
  0008d	8b 55 f4	 mov	 edx, DWORD PTR _ady$[ebp]
  00090	89 55 b0	 mov	 DWORD PTR tv86[ebp], edx
$LN7@S_Calculat:
  00093	8b 45 f8	 mov	 eax, DWORD PTR _adx$[ebp]
  00096	03 45 f4	 add	 eax, DWORD PTR _ady$[ebp]
  00099	8b 4d b0	 mov	 ecx, DWORD PTR tv86[ebp]
  0009c	d1 f9		 sar	 ecx, 1
  0009e	2b c1		 sub	 eax, ecx
  000a0	89 45 fc	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 1163 : 
; 1164 : 	if (approx_dist >= FRACUNIT/2)

  000a3	81 7d fc 00 80
	00 00		 cmp	 DWORD PTR _approx_dist$[ebp], 32768 ; 00008000H
  000aa	7c 07		 jl	 SHORT $LN2@S_Calculat

; 1165 : 		approx_dist = FRACUNIT/2-1;

  000ac	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR _approx_dist$[ebp], 32767 ; 00007fffH
$LN2@S_Calculat:

; 1166 : 
; 1167 : 	approx_dist <<= FRACBITS;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _approx_dist$[ebp]
  000b6	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b9	89 45 fc	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 1168 : 
; 1169 : 	return approx_dist;

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _approx_dist$[ebp]

; 1170 : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
_S_CalculateSoundDistance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_UpdateSounds
_TEXT	SEGMENT
tv323 = -184						; size = 4
_dist2$1 = -116						; size = 4
_dist1$2 = -112						; size = 4
_soundmobj$3 = -108					; size = 4
_listenmobj2$ = -104					; size = 4
_listenmobj$ = -100					; size = 4
_listener2$ = -96					; size = 16
_listener$ = -80					; size = 16
_MPos$ = -64						; size = 32
_c$ = -32						; size = 4
_sfx$ = -28						; size = 4
_pitch$ = -24						; size = 4
_sep$ = -20						; size = 4
_volume$ = -16						; size = 4
_cnum$ = -12						; size = 4
_audible$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_S_UpdateSounds PROC					; COMDAT

; 759  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 760  : 	INT32 audible, cnum, volume, sep, pitch;
; 761  : 	sfxinfo_t *sfx;
; 762  : 	channel_t *c;
; 763  : 	MumblePos_t MPos;
; 764  : 
; 765  : 	listener_t listener;
; 766  : 	listener_t listener2;
; 767  : 
; 768  : 	mobj_t *listenmobj = players[displayplayer].mo;

  00016	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00020	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00026	89 4d 9c	 mov	 DWORD PTR _listenmobj$[ebp], ecx

; 769  : 	mobj_t *listenmobj2 = NULL;

  00029	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _listenmobj2$[ebp], 0

; 770  : 	if (splitscreen) listenmobj2 = players[secondarydisplayplayer].mo;

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00037	74 13		 je	 SHORT $LN5@S_UpdateSo
  00039	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00043	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00049	89 4d 98	 mov	 DWORD PTR _listenmobj2$[ebp], ecx
$LN5@S_UpdateSo:

; 771  : 
; 772  : 	memset(&listener, 0, sizeof(listener_t));

  0004c	6a 10		 push	 16			; 00000010H
  0004e	6a 00		 push	 0
  00050	8d 45 b0	 lea	 eax, DWORD PTR _listener$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _memset
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 773  : 	memset(&listener2, 0, sizeof(listener_t));

  0005c	6a 10		 push	 16			; 00000010H
  0005e	6a 00		 push	 0
  00060	8d 45 a0	 lea	 eax, DWORD PTR _listener2$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 774  : 
; 775  : 	// Update sound/music volumes, if changed manually at console
; 776  : 	if (actualsfxvolume != cv_soundvolume.value)

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR _actualsfxvolume
  00071	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _cv_soundvolume+20
  00077	74 0e		 je	 SHORT $LN6@S_UpdateSo

; 777  : 		S_SetSfxVolume (cv_soundvolume.value);

  00079	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_soundvolume+20
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _S_SetSfxVolume
  00084	83 c4 04	 add	 esp, 4
$LN6@S_UpdateSo:

; 778  : 	if (actualdigmusicvolume != cv_digmusicvolume.value)

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _actualdigmusicvolume
  0008c	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _cv_digmusicvolume+20
  00092	74 0e		 je	 SHORT $LN7@S_UpdateSo

; 779  : 		S_SetDigMusicVolume (cv_digmusicvolume.value);

  00094	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_digmusicvolume+20
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _S_SetDigMusicVolume
  0009f	83 c4 04	 add	 esp, 4
$LN7@S_UpdateSo:

; 780  : 	if (actualmidimusicvolume != cv_midimusicvolume.value)

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _actualmidimusicvolume
  000a7	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _cv_midimusicvolume+20
  000ad	74 0e		 je	 SHORT $LN8@S_UpdateSo

; 781  : 		S_SetMIDIMusicVolume (cv_midimusicvolume.value);

  000af	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_midimusicvolume+20
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _S_SetMIDIMusicVolume
  000ba	83 c4 04	 add	 esp, 4
$LN8@S_UpdateSo:

; 782  : 
; 783  : 	if (gamestate != GS_LEVEL) return;		// We're done now, if we're not in a level.

  000bd	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  000c4	74 05		 je	 SHORT $LN9@S_UpdateSo
  000c6	e9 85 03 00 00	 jmp	 $LN3@S_UpdateSo
$LN9@S_UpdateSo:

; 784  : 
; 785  : 	if (dedicated || nosound)

  000cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  000d2	75 09		 jne	 SHORT $LN11@S_UpdateSo
  000d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  000db	74 05		 je	 SHORT $LN10@S_UpdateSo
$LN11@S_UpdateSo:

; 786  : 		return;

  000dd	e9 6e 03 00 00	 jmp	 $LN3@S_UpdateSo
$LN10@S_UpdateSo:

; 787  : 
; 788  : 	if (cv_chasecam.value)

  000e2	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam+20, 0
  000e9	74 22		 je	 SHORT $LN12@S_UpdateSo

; 789  : 	{
; 790  : 		listener.x = camera.x;

  000eb	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera+16
  000f0	89 45 b0	 mov	 DWORD PTR _listener$[ebp], eax

; 791  : 		listener.y = camera.y;

  000f3	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera+20
  000f8	89 45 b4	 mov	 DWORD PTR _listener$[ebp+4], eax

; 792  : 		listener.z = camera.z;

  000fb	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera+24
  00100	89 45 b8	 mov	 DWORD PTR _listener$[ebp+8], eax

; 793  : 		listener.angle = camera.angle;

  00103	a1 1c 00 00 00	 mov	 eax, DWORD PTR _camera+28
  00108	89 45 bc	 mov	 DWORD PTR _listener$[ebp+12], eax

; 794  : 	}

  0010b	eb 2a		 jmp	 SHORT $LN14@S_UpdateSo
$LN12@S_UpdateSo:

; 795  : 	else if (listenmobj)

  0010d	83 7d 9c 00	 cmp	 DWORD PTR _listenmobj$[ebp], 0
  00111	74 24		 je	 SHORT $LN14@S_UpdateSo

; 796  : 	{
; 797  : 		listener.x = listenmobj->x;

  00113	8b 45 9c	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  00116	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00119	89 4d b0	 mov	 DWORD PTR _listener$[ebp], ecx

; 798  : 		listener.y = listenmobj->y;

  0011c	8b 45 9c	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  0011f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00122	89 4d b4	 mov	 DWORD PTR _listener$[ebp+4], ecx

; 799  : 		listener.z = listenmobj->z;

  00125	8b 45 9c	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  00128	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0012b	89 4d b8	 mov	 DWORD PTR _listener$[ebp+8], ecx

; 800  : 		listener.angle = listenmobj->angle;

  0012e	8b 45 9c	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  00131	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00134	89 4d bc	 mov	 DWORD PTR _listener$[ebp+12], ecx
$LN14@S_UpdateSo:

; 801  : 	}
; 802  : 
; 803  : 	MPos.fPosition[0] = listener.x;

  00137	b8 04 00 00 00	 mov	 eax, 4
  0013c	6b c8 00	 imul	 ecx, eax, 0
  0013f	8b 55 b0	 mov	 edx, DWORD PTR _listener$[ebp]
  00142	89 54 0d c0	 mov	 DWORD PTR _MPos$[ebp+ecx], edx

; 804  : 	MPos.fPosition[1] = listener.y;

  00146	b8 04 00 00 00	 mov	 eax, 4
  0014b	c1 e0 00	 shl	 eax, 0
  0014e	8b 4d b4	 mov	 ecx, DWORD PTR _listener$[ebp+4]
  00151	89 4c 05 c0	 mov	 DWORD PTR _MPos$[ebp+eax], ecx

; 805  : 	MPos.fPosition[2] = listener.z;

  00155	b8 04 00 00 00	 mov	 eax, 4
  0015a	d1 e0		 shl	 eax, 1
  0015c	8b 4d b8	 mov	 ecx, DWORD PTR _listener$[ebp+8]
  0015f	89 4c 05 c0	 mov	 DWORD PTR _MPos$[ebp+eax], ecx

; 806  : 	if (listener.angle == 0)

  00163	83 7d bc 00	 cmp	 DWORD PTR _listener$[ebp+12], 0
  00167	75 3a		 jne	 SHORT $LN15@S_UpdateSo

; 807  : 		MPos.fFront = (double)((listener.angle*45.0l)/(double)ANGLE_45);

  00169	8b 45 bc	 mov	 eax, DWORD PTR _listener$[ebp+12]
  0016c	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  00172	f2 0f 2a 85 48
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv323[ebp]
  0017a	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv323[ebp]
  00180	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00183	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  0018c	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4046800000000000
  00194	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41c0000000000000
  0019c	f2 0f 11 45 d0	 movsd	 QWORD PTR _MPos$[ebp+16], xmm0
  001a1	eb 08		 jmp	 SHORT $LN16@S_UpdateSo
$LN15@S_UpdateSo:

; 808  : 	else
; 809  : 		MPos.fFront = 0.0l;

  001a3	0f 57 c0	 xorps	 xmm0, xmm0
  001a6	f2 0f 11 45 d0	 movsd	 QWORD PTR _MPos$[ebp+16], xmm0
$LN16@S_UpdateSo:

; 810  : 	MPos.fTop = 0.0l;

  001ab	0f 57 c0	 xorps	 xmm0, xmm0
  001ae	f2 0f 11 45 d8	 movsd	 QWORD PTR _MPos$[ebp+24], xmm0

; 811  : 	I_UpdateMumble(&MPos);

  001b3	8d 45 c0	 lea	 eax, DWORD PTR _MPos$[ebp]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _I_UpdateMumble
  001bc	83 c4 04	 add	 esp, 4

; 812  : 
; 813  : #ifdef HW3SOUND
; 814  : 	if (hws_mode != HWS_DEFAULT_MODE)

  001bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  001c6	74 0b		 je	 SHORT $LN17@S_UpdateSo

; 815  : 	{
; 816  : 		HW3S_UpdateSources();

  001c8	e8 00 00 00 00	 call	 _HW3S_UpdateSources
  001cd	90		 npad	 1

; 817  : 		return;

  001ce	e9 7d 02 00 00	 jmp	 $LN3@S_UpdateSo
$LN17@S_UpdateSo:

; 818  : 	}
; 819  : #endif
; 820  : 
; 821  : 	if (listenmobj2)

  001d3	83 7d 98 00	 cmp	 DWORD PTR _listenmobj2$[ebp], 0
  001d7	74 4f		 je	 SHORT $LN20@S_UpdateSo

; 822  : 	{
; 823  : 		if (cv_chasecam2.value)

  001d9	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam2+20, 0
  001e0	74 22		 je	 SHORT $LN19@S_UpdateSo

; 824  : 		{
; 825  : 			listener2.x = camera2.x;

  001e2	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera2+16
  001e7	89 45 a0	 mov	 DWORD PTR _listener2$[ebp], eax

; 826  : 			listener2.y = camera2.y;

  001ea	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera2+20
  001ef	89 45 a4	 mov	 DWORD PTR _listener2$[ebp+4], eax

; 827  : 			listener2.z = camera2.z;

  001f2	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera2+24
  001f7	89 45 a8	 mov	 DWORD PTR _listener2$[ebp+8], eax

; 828  : 			listener2.angle = camera2.angle;

  001fa	a1 1c 00 00 00	 mov	 eax, DWORD PTR _camera2+28
  001ff	89 45 ac	 mov	 DWORD PTR _listener2$[ebp+12], eax

; 829  : 		}

  00202	eb 24		 jmp	 SHORT $LN20@S_UpdateSo
$LN19@S_UpdateSo:

; 830  : 		else
; 831  : 		{
; 832  : 			listener2.x = listenmobj2->x;

  00204	8b 45 98	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  00207	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0020a	89 4d a0	 mov	 DWORD PTR _listener2$[ebp], ecx

; 833  : 			listener2.y = listenmobj2->y;

  0020d	8b 45 98	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  00210	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00213	89 4d a4	 mov	 DWORD PTR _listener2$[ebp+4], ecx

; 834  : 			listener2.z = listenmobj2->z;

  00216	8b 45 98	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  00219	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0021c	89 4d a8	 mov	 DWORD PTR _listener2$[ebp+8], ecx

; 835  : 			listener2.angle = listenmobj2->angle;

  0021f	8b 45 98	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  00222	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00225	89 4d ac	 mov	 DWORD PTR _listener2$[ebp+12], ecx
$LN20@S_UpdateSo:

; 836  : 		}
; 837  : 	}
; 838  : 
; 839  : 	// Clean up unused data.
; 840  : #if 0
; 841  : 	{
; 842  : 		static tic_t nextcleanup = 0;
; 843  : 		size_t i;
; 844  : 		if (!gametic) nextcleanup = 0;
; 845  : 		if (gametic > nextcleanup)
; 846  : 		{
; 847  : 			for (i = 1; i < NUMSFX; i++)
; 848  : 			{
; 849  : 				if (S_sfx[i].usefulness == 0)
; 850  : 				{
; 851  : 					S_sfx[i].usefulness--;
; 852  : 
; 853  : 					// don't forget to unlock it !!!
; 854  : 					// __dmpi_unlock_....
; 855  : 					//Z_ChangeTag(S_sfx[i].data, PU_CACHE);
; 856  : 					I_FreeSfx(S_sfx+i);
; 857  : 					//S_sfx[i].data = 0;
; 858  : 
; 859  : 					CONS_Printf("\2flushed sfx %.6s\n", S_sfx[i].name);
; 860  : 				}
; 861  : 			}
; 862  : 			nextcleanup = gametic + 15;
; 863  : 		}
; 864  : 	}
; 865  : #endif
; 866  : 
; 867  : 	// FIXTHIS: nextcleanup is probably unused
; 868  : 
; 869  : 	for (cnum = 0; cnum < numofchannels; cnum++)

  00228	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  0022f	eb 09		 jmp	 SHORT $LN4@S_UpdateSo
$LN2@S_UpdateSo:
  00231	8b 45 f4	 mov	 eax, DWORD PTR _cnum$[ebp]
  00234	83 c0 01	 add	 eax, 1
  00237	89 45 f4	 mov	 DWORD PTR _cnum$[ebp], eax
$LN4@S_UpdateSo:
  0023a	8b 45 f4	 mov	 eax, DWORD PTR _cnum$[ebp]
  0023d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  00243	0f 8d 07 02 00
	00		 jge	 $LN3@S_UpdateSo

; 870  : 	{
; 871  : 		c = &channels[cnum];

  00249	6b 45 f4 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0024d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _channels
  00253	89 45 e0	 mov	 DWORD PTR _c$[ebp], eax

; 872  : 		sfx = c->sfxinfo;

  00256	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00259	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025b	89 4d e4	 mov	 DWORD PTR _sfx$[ebp], ecx

; 873  : 
; 874  : 		if (c->sfxinfo)

  0025e	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00261	83 38 00	 cmp	 DWORD PTR [eax], 0
  00264	0f 84 e1 01 00
	00		 je	 $LN23@S_UpdateSo

; 875  : 		{
; 876  : 			if (I_SoundIsPlaying(c->handle))

  0026a	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  0026d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 _I_SoundIsPlaying
  00276	83 c4 04	 add	 esp, 4
  00279	85 c0		 test	 eax, eax
  0027b	0f 84 be 01 00
	00		 je	 $LN22@S_UpdateSo

; 877  : 			{
; 878  : 				// initialize parameters
; 879  : 				volume = 255; // 8 bits internal volume precision

  00281	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR _volume$[ebp], 255 ; 000000ffH

; 880  : 				pitch = NORM_PITCH;

  00288	c7 45 e8 80 00
	00 00		 mov	 DWORD PTR _pitch$[ebp], 128 ; 00000080H

; 881  : 				sep = NORM_SEP;

  0028f	c7 45 ec 80 00
	00 00		 mov	 DWORD PTR _sep$[ebp], 128 ; 00000080H

; 882  : 
; 883  : 				// check non-local sounds for distance clipping
; 884  : 				//  or modify their params
; 885  : 				if (c->origin && ((c->origin != players[consoleplayer].mo) ||

  00296	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00299	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0029d	0f 84 9a 01 00
	00		 je	 $LN34@S_UpdateSo
  002a3	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  002ad	8b 4d e0	 mov	 ecx, DWORD PTR _c$[ebp]
  002b0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002b3	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _players[eax]
  002b9	75 29		 jne	 SHORT $LN25@S_UpdateSo
  002bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  002c2	0f 84 75 01 00
	00		 je	 $LN34@S_UpdateSo
  002c8	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  002d2	8b 4d e0	 mov	 ecx, DWORD PTR _c$[ebp]
  002d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002d8	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR _players[eax]
  002de	0f 84 59 01 00
	00		 je	 $LN34@S_UpdateSo
$LN25@S_UpdateSo:

; 886  : 					(splitscreen && c->origin != players[secondarydisplayplayer].mo)))
; 887  : 				{
; 888  : 					// Whomever is closer gets the sound, but only in splitscreen.
; 889  : 					if (listenmobj && listenmobj2 && splitscreen)

  002e4	83 7d 9c 00	 cmp	 DWORD PTR _listenmobj$[ebp], 0
  002e8	0f 84 e9 00 00
	00		 je	 $LN26@S_UpdateSo
  002ee	83 7d 98 00	 cmp	 DWORD PTR _listenmobj2$[ebp], 0
  002f2	0f 84 df 00 00
	00		 je	 $LN26@S_UpdateSo
  002f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  002ff	0f 84 d2 00 00
	00		 je	 $LN26@S_UpdateSo

; 890  : 					{
; 891  : 						const mobj_t *soundmobj = c->origin;

  00305	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00308	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0030b	89 4d 94	 mov	 DWORD PTR _soundmobj$3[ebp], ecx

; 892  : 
; 893  : 						fixed_t dist1, dist2;
; 894  : 						dist1 = P_AproxDistance(listener.x-soundmobj->x, listener.y-soundmobj->y);

  0030e	8b 45 94	 mov	 eax, DWORD PTR _soundmobj$3[ebp]
  00311	8b 4d b4	 mov	 ecx, DWORD PTR _listener$[ebp+4]
  00314	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  00317	51		 push	 ecx
  00318	8b 55 94	 mov	 edx, DWORD PTR _soundmobj$3[ebp]
  0031b	8b 45 b0	 mov	 eax, DWORD PTR _listener$[ebp]
  0031e	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 _P_AproxDistance
  00327	83 c4 08	 add	 esp, 8
  0032a	89 45 90	 mov	 DWORD PTR _dist1$2[ebp], eax

; 895  : 						dist2 = P_AproxDistance(listener2.x-soundmobj->x, listener2.y-soundmobj->y);

  0032d	8b 45 94	 mov	 eax, DWORD PTR _soundmobj$3[ebp]
  00330	8b 4d a4	 mov	 ecx, DWORD PTR _listener2$[ebp+4]
  00333	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  00336	51		 push	 ecx
  00337	8b 55 94	 mov	 edx, DWORD PTR _soundmobj$3[ebp]
  0033a	8b 45 a0	 mov	 eax, DWORD PTR _listener2$[ebp]
  0033d	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00340	50		 push	 eax
  00341	e8 00 00 00 00	 call	 _P_AproxDistance
  00346	83 c4 08	 add	 esp, 8
  00349	89 45 8c	 mov	 DWORD PTR _dist2$1[ebp], eax

; 896  : 
; 897  : 						if (dist1 <= dist2)

  0034c	8b 45 90	 mov	 eax, DWORD PTR _dist1$2[ebp]
  0034f	3b 45 8c	 cmp	 eax, DWORD PTR _dist2$1[ebp]
  00352	7f 2a		 jg	 SHORT $LN28@S_UpdateSo

; 898  : 						{
; 899  : 							// Player 1 gets the sound
; 900  : 							audible = S_AdjustSoundParams(listenmobj, c->origin, &volume, &sep, &pitch,

  00354	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00357	8b 08		 mov	 ecx, DWORD PTR [eax]
  00359	51		 push	 ecx
  0035a	8d 55 e8	 lea	 edx, DWORD PTR _pitch$[ebp]
  0035d	52		 push	 edx
  0035e	8d 45 ec	 lea	 eax, DWORD PTR _sep$[ebp]
  00361	50		 push	 eax
  00362	8d 4d f0	 lea	 ecx, DWORD PTR _volume$[ebp]
  00365	51		 push	 ecx
  00366	8b 55 e0	 mov	 edx, DWORD PTR _c$[ebp]
  00369	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0036c	50		 push	 eax
  0036d	8b 4d 9c	 mov	 ecx, DWORD PTR _listenmobj$[ebp]
  00370	51		 push	 ecx
  00371	e8 00 00 00 00	 call	 _S_AdjustSoundParams
  00376	83 c4 18	 add	 esp, 24			; 00000018H
  00379	89 45 f8	 mov	 DWORD PTR _audible$[ebp], eax

; 901  : 								c->sfxinfo);
; 902  : 						}

  0037c	eb 28		 jmp	 SHORT $LN29@S_UpdateSo
$LN28@S_UpdateSo:

; 903  : 						else
; 904  : 						{
; 905  : 							// Player 2 gets the sound
; 906  : 							audible = S_AdjustSoundParams(listenmobj2, c->origin, &volume, &sep, &pitch,

  0037e	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00381	8b 08		 mov	 ecx, DWORD PTR [eax]
  00383	51		 push	 ecx
  00384	8d 55 e8	 lea	 edx, DWORD PTR _pitch$[ebp]
  00387	52		 push	 edx
  00388	8d 45 ec	 lea	 eax, DWORD PTR _sep$[ebp]
  0038b	50		 push	 eax
  0038c	8d 4d f0	 lea	 ecx, DWORD PTR _volume$[ebp]
  0038f	51		 push	 ecx
  00390	8b 55 e0	 mov	 edx, DWORD PTR _c$[ebp]
  00393	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00396	50		 push	 eax
  00397	8b 4d 98	 mov	 ecx, DWORD PTR _listenmobj2$[ebp]
  0039a	51		 push	 ecx
  0039b	e8 00 00 00 00	 call	 _S_AdjustSoundParams
  003a0	83 c4 18	 add	 esp, 24			; 00000018H
  003a3	89 45 f8	 mov	 DWORD PTR _audible$[ebp], eax
$LN29@S_UpdateSo:

; 907  : 								c->sfxinfo);
; 908  : 						}
; 909  : 
; 910  : 						if (audible)

  003a6	83 7d f8 00	 cmp	 DWORD PTR _audible$[ebp], 0
  003aa	74 1d		 je	 SHORT $LN30@S_UpdateSo

; 911  : 							I_UpdateSoundParams(c->handle, volume, sep, pitch);

  003ac	8b 45 e8	 mov	 eax, DWORD PTR _pitch$[ebp]
  003af	50		 push	 eax
  003b0	8b 4d ec	 mov	 ecx, DWORD PTR _sep$[ebp]
  003b3	51		 push	 ecx
  003b4	8b 55 f0	 mov	 edx, DWORD PTR _volume$[ebp]
  003b7	52		 push	 edx
  003b8	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  003bb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003be	51		 push	 ecx
  003bf	e8 00 00 00 00	 call	 _I_UpdateSoundParams
  003c4	83 c4 10	 add	 esp, 16			; 00000010H
  003c7	eb 0c		 jmp	 SHORT $LN31@S_UpdateSo
$LN30@S_UpdateSo:

; 912  : 						else
; 913  : 							S_StopChannel(cnum);

  003c9	8b 45 f4	 mov	 eax, DWORD PTR _cnum$[ebp]
  003cc	50		 push	 eax
  003cd	e8 00 00 00 00	 call	 _S_StopChannel
  003d2	83 c4 04	 add	 esp, 4
$LN31@S_UpdateSo:

; 914  : 					}

  003d5	eb 66		 jmp	 SHORT $LN34@S_UpdateSo
$LN26@S_UpdateSo:

; 915  : 					else if (listenmobj && !splitscreen)

  003d7	83 7d 9c 00	 cmp	 DWORD PTR _listenmobj$[ebp], 0
  003db	74 60		 je	 SHORT $LN34@S_UpdateSo
  003dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  003e4	75 57		 jne	 SHORT $LN34@S_UpdateSo

; 916  : 					{
; 917  : 						// In the case of a single player, he or she always should get updated sound.
; 918  : 						audible = S_AdjustSoundParams(listenmobj, c->origin, &volume, &sep, &pitch,

  003e6	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  003e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003eb	51		 push	 ecx
  003ec	8d 55 e8	 lea	 edx, DWORD PTR _pitch$[ebp]
  003ef	52		 push	 edx
  003f0	8d 45 ec	 lea	 eax, DWORD PTR _sep$[ebp]
  003f3	50		 push	 eax
  003f4	8d 4d f0	 lea	 ecx, DWORD PTR _volume$[ebp]
  003f7	51		 push	 ecx
  003f8	8b 55 e0	 mov	 edx, DWORD PTR _c$[ebp]
  003fb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003fe	50		 push	 eax
  003ff	8b 4d 9c	 mov	 ecx, DWORD PTR _listenmobj$[ebp]
  00402	51		 push	 ecx
  00403	e8 00 00 00 00	 call	 _S_AdjustSoundParams
  00408	83 c4 18	 add	 esp, 24			; 00000018H
  0040b	89 45 f8	 mov	 DWORD PTR _audible$[ebp], eax

; 919  : 							c->sfxinfo);
; 920  : 
; 921  : 						if (audible)

  0040e	83 7d f8 00	 cmp	 DWORD PTR _audible$[ebp], 0
  00412	74 1d		 je	 SHORT $LN33@S_UpdateSo

; 922  : 							I_UpdateSoundParams(c->handle, volume, sep, pitch);

  00414	8b 45 e8	 mov	 eax, DWORD PTR _pitch$[ebp]
  00417	50		 push	 eax
  00418	8b 4d ec	 mov	 ecx, DWORD PTR _sep$[ebp]
  0041b	51		 push	 ecx
  0041c	8b 55 f0	 mov	 edx, DWORD PTR _volume$[ebp]
  0041f	52		 push	 edx
  00420	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp]
  00423	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00426	51		 push	 ecx
  00427	e8 00 00 00 00	 call	 _I_UpdateSoundParams
  0042c	83 c4 10	 add	 esp, 16			; 00000010H
  0042f	eb 0c		 jmp	 SHORT $LN34@S_UpdateSo
$LN33@S_UpdateSo:

; 923  : 						else
; 924  : 							S_StopChannel(cnum);

  00431	8b 45 f4	 mov	 eax, DWORD PTR _cnum$[ebp]
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 _S_StopChannel
  0043a	83 c4 04	 add	 esp, 4
$LN34@S_UpdateSo:

; 925  : 					}
; 926  : 				}
; 927  : 			}

  0043d	eb 0c		 jmp	 SHORT $LN23@S_UpdateSo
$LN22@S_UpdateSo:

; 928  : 			else
; 929  : 			{
; 930  : 				// if channel is allocated but sound has stopped, free it
; 931  : 				S_StopChannel(cnum);

  0043f	8b 45 f4	 mov	 eax, DWORD PTR _cnum$[ebp]
  00442	50		 push	 eax
  00443	e8 00 00 00 00	 call	 _S_StopChannel
  00448	83 c4 04	 add	 esp, 4
$LN23@S_UpdateSo:

; 932  : 			}
; 933  : 		}
; 934  : 	}

  0044b	e9 e1 fd ff ff	 jmp	 $LN2@S_UpdateSo
$LN3@S_UpdateSo:

; 935  : }

  00450	5f		 pop	 edi
  00451	5e		 pop	 esi
  00452	5b		 pop	 ebx
  00453	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00456	33 cd		 xor	 ecx, ebp
  00458	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045d	8b e5		 mov	 esp, ebp
  0045f	5d		 pop	 ebp
  00460	c3		 ret	 0
_S_UpdateSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_ResumeSound
_TEXT	SEGMENT
_S_ResumeSound PROC					; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 738  : 	if (!nodigimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00010	75 0c		 jne	 SHORT $LN2@S_ResumeSo

; 739  : 		I_ResumeSong(0);

  00012	6a 00		 push	 0
  00014	e8 00 00 00 00	 call	 _I_ResumeSong
  00019	83 c4 04	 add	 esp, 4
  0001c	eb 2d		 jmp	 SHORT $LN4@S_ResumeSo
$LN2@S_ResumeSo:

; 740  : 	else
; 741  : 	if (mus_playing && mus_paused)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mus_playing, 0
  00025	74 24		 je	 SHORT $LN4@S_ResumeSo
  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mus_paused, 0
  0002e	74 1b		 je	 SHORT $LN4@S_ResumeSo

; 742  : 	{
; 743  : 		I_ResumeSong(mus_playing->handle);

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _I_ResumeSong
  0003e	83 c4 04	 add	 esp, 4

; 744  : 		mus_paused = false;

  00041	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mus_paused, 0
$LN4@S_ResumeSo:

; 745  : 	}
; 746  : 
; 747  : 	// resume cd music
; 748  : 	I_ResumeCD();

  0004b	e8 00 00 00 00	 call	 _I_ResumeCD
  00050	90		 npad	 1

; 749  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_S_ResumeSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_PauseSound
_TEXT	SEGMENT
_S_PauseSound PROC					; COMDAT

; 718  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 719  : 	if (!nodigimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00010	75 0a		 jne	 SHORT $LN2@S_PauseSou

; 720  : 		I_PauseSong(0);

  00012	6a 00		 push	 0
  00014	e8 00 00 00 00	 call	 _I_PauseSong
  00019	83 c4 04	 add	 esp, 4
$LN2@S_PauseSou:

; 721  : 
; 722  : 	if (mus_playing && !mus_paused)

  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mus_playing, 0
  00023	74 24		 je	 SHORT $LN3@S_PauseSou
  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mus_paused, 0
  0002c	75 1b		 jne	 SHORT $LN3@S_PauseSou

; 723  : 	{
; 724  : 		I_PauseSong(mus_playing->handle);

  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  00033	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _I_PauseSong
  0003c	83 c4 04	 add	 esp, 4

; 725  : 		mus_paused = true;

  0003f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _mus_paused, 1
$LN3@S_PauseSou:

; 726  : 	}
; 727  : 
; 728  : 	// pause cd music
; 729  : #if defined (__unix__) || defined (UNIXCOMMON) || defined (SDL)
; 730  : 	I_PauseCD();
; 731  : #else
; 732  : 	I_StopCD();

  00049	e8 00 00 00 00	 call	 _I_StopCD
  0004e	90		 npad	 1

; 733  : #endif
; 734  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_S_PauseSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StopMusic
_TEXT	SEGMENT
_S_StopMusic PROC					; COMDAT

; 1088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1089 : 	if (!mus_playing)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mus_playing, 0
  00010	75 05		 jne	 SHORT $LN2@S_StopMusi

; 1090 : 		return;

  00012	e9 8a 00 00 00	 jmp	 $LN1@S_StopMusi
$LN2@S_StopMusi:

; 1091 : 
; 1092 : 	if (mus_paused)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _mus_paused, 0
  0001e	74 11		 je	 SHORT $LN3@S_StopMusi

; 1093 : 		I_ResumeSong(mus_playing->handle);

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  00025	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _I_ResumeSong
  0002e	83 c4 04	 add	 esp, 4
$LN3@S_StopMusi:

; 1094 : 
; 1095 : 	if (!nodigimusic)

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00038	75 06		 jne	 SHORT $LN4@S_StopMusi

; 1096 : 		I_StopDigSong();

  0003a	e8 00 00 00 00	 call	 _I_StopDigSong
  0003f	90		 npad	 1
$LN4@S_StopMusi:

; 1097 : 
; 1098 : 	S_SpeedMusic(1.0f);

  00040	51		 push	 ecx
  00041	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	e8 00 00 00 00	 call	 _S_SpeedMusic
  00053	83 c4 04	 add	 esp, 4

; 1099 : 	I_StopSong(mus_playing->handle);

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  0005b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _I_StopSong
  00064	83 c4 04	 add	 esp, 4

; 1100 : 	I_UnRegisterSong(mus_playing->handle);

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  0006c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _I_UnRegisterSong
  00075	83 c4 04	 add	 esp, 4

; 1101 : 
; 1102 : #ifndef SDL //SDL uses RWOPS
; 1103 : 	Z_ChangeTag(mus_playing->data, PU_CACHE);

  00078	6a 65		 push	 101			; 00000065H
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  0007f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00088	83 c4 08	 add	 esp, 8

; 1104 : #endif
; 1105 : 
; 1106 : 	mus_playing->data = NULL;

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  00090	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1107 : 	mus_playing = NULL;

  00097	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mus_playing, 0
$LN1@S_StopMusi:

; 1108 : 
; 1109 : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_S_StopMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_SpeedMusic
_TEXT	SEGMENT
_speed$ = 8						; size = 4
_S_SpeedMusic PROC					; COMDAT

; 1083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1084 : 	return I_SetSongSpeed(speed);

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _speed$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _I_SetSongSpeed
  00019	83 c4 04	 add	 esp, 4

; 1085 : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_S_SpeedMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_ChangeMusic
_TEXT	SEGMENT
_music$ = -4						; size = 4
_music_num$ = 8						; size = 4
_looping$ = 12						; size = 4
_S_ChangeMusic PROC					; COMDAT

; 1044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1045 : 	musicinfo_t *music;
; 1046 : 
; 1047 : #if defined (DC) || defined (_WIN32_WCE) || defined (PSP) || defined(GP2X)
; 1048 : 	S_ClearSfx();
; 1049 : #endif
; 1050 : 
; 1051 : 	if (nomidimusic && nodigimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 0e		 je	 SHORT $LN2@S_ChangeMu
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00019	74 05		 je	 SHORT $LN2@S_ChangeMu

; 1052 : 		return;

  0001b	e9 d1 00 00 00	 jmp	 $LN9@S_ChangeMu
$LN2@S_ChangeMu:

; 1053 : 
; 1054 : 	if (music_disabled && digital_disabled)

  00020	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _music_disabled, 0
  00027	74 0e		 je	 SHORT $LN3@S_ChangeMu
  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _digital_disabled, 0
  00030	74 05		 je	 SHORT $LN3@S_ChangeMu

; 1055 : 		return;

  00032	e9 ba 00 00 00	 jmp	 $LN9@S_ChangeMu
$LN3@S_ChangeMu:

; 1056 : 
; 1057 : 	// No Music
; 1058 : 	if (music_num == mus_None)

  00037	83 7d 08 00	 cmp	 DWORD PTR _music_num$[ebp], 0
  0003b	75 0b		 jne	 SHORT $LN4@S_ChangeMu

; 1059 : 	{
; 1060 : 		S_StopMusic();

  0003d	e8 00 00 00 00	 call	 _S_StopMusic
  00042	90		 npad	 1

; 1061 : 		return;

  00043	e9 a9 00 00 00	 jmp	 $LN9@S_ChangeMu
$LN4@S_ChangeMu:

; 1062 : 	}
; 1063 : 
; 1064 : 	if (music_num >= NUMMUSIC)

  00048	81 7d 08 1a 04
	00 00		 cmp	 DWORD PTR _music_num$[ebp], 1050 ; 0000041aH
  0004f	7c 18		 jl	 SHORT $LN5@S_ChangeMu

; 1065 : 	{
; 1066 : 		I_Error("Bad music number %d\n", music_num);

  00051	8b 45 08	 mov	 eax, DWORD PTR _music_num$[ebp]
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DAIBKDKL@Bad?5music?5number?5?$CFd?6@
  0005a	e8 00 00 00 00	 call	 _I_Error
  0005f	83 c4 08	 add	 esp, 8

; 1067 : 		return;

  00062	e9 8a 00 00 00	 jmp	 $LN9@S_ChangeMu

; 1068 : 	}

  00067	eb 0e		 jmp	 SHORT $LN6@S_ChangeMu
$LN5@S_ChangeMu:

; 1069 : 	else
; 1070 : 		music = &S_music[music_num];

  00069	8b 45 08	 mov	 eax, DWORD PTR _music_num$[ebp]
  0006c	c1 e0 04	 shl	 eax, 4
  0006f	05 00 00 00 00	 add	 eax, OFFSET _S_music
  00074	89 45 fc	 mov	 DWORD PTR _music$[ebp], eax
$LN6@S_ChangeMu:

; 1071 : 
; 1072 : 	if (mus_playing == music)

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _mus_playing
  0007c	3b 45 fc	 cmp	 eax, DWORD PTR _music$[ebp]
  0007f	75 02		 jne	 SHORT $LN7@S_ChangeMu

; 1073 : 		return;

  00081	eb 6e		 jmp	 SHORT $LN9@S_ChangeMu
$LN7@S_ChangeMu:

; 1074 : 
; 1075 : 	if (!nomidimusic) // Make sure the MIDI is not playing

  00083	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  0008a	75 06		 jne	 SHORT $LN8@S_ChangeMu

; 1076 : 		S_StopMusic(); // shutdown old music

  0008c	e8 00 00 00 00	 call	 _S_StopMusic
  00091	90		 npad	 1
$LN8@S_ChangeMu:

; 1077 : 
; 1078 : 	if (!S_DigMusic(music, looping) && !S_MIDIMusic(music, looping) && (!nodigimusic || !nomidimusic || !digital_disabled || !music_disabled))

  00092	8b 45 0c	 mov	 eax, DWORD PTR _looping$[ebp]
  00095	50		 push	 eax
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _music$[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 _S_DigMusic
  0009f	83 c4 08	 add	 esp, 8
  000a2	85 c0		 test	 eax, eax
  000a4	75 4b		 jne	 SHORT $LN9@S_ChangeMu
  000a6	8b 45 0c	 mov	 eax, DWORD PTR _looping$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _music$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _S_MIDIMusic
  000b3	83 c4 08	 add	 esp, 8
  000b6	85 c0		 test	 eax, eax
  000b8	75 37		 jne	 SHORT $LN9@S_ChangeMu
  000ba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  000c1	74 1b		 je	 SHORT $LN10@S_ChangeMu
  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  000ca	74 12		 je	 SHORT $LN10@S_ChangeMu
  000cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _digital_disabled, 0
  000d3	74 09		 je	 SHORT $LN10@S_ChangeMu
  000d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _music_disabled, 0
  000dc	75 13		 jne	 SHORT $LN9@S_ChangeMu
$LN10@S_ChangeMu:

; 1079 : 		CONS_Printf("ERROR: Music lump %.6s not found!\n", music->name);

  000de	8b 45 fc	 mov	 eax, DWORD PTR _music$[ebp]
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	51		 push	 ecx
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KCDEBKHB@ERROR?3?5Music?5lump?5?$CF?46s?5not?5foun@
  000e9	e8 00 00 00 00	 call	 _CONS_Printf
  000ee	83 c4 08	 add	 esp, 8
$LN9@S_ChangeMu:

; 1080 : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_S_ChangeMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StopSound
_TEXT	SEGMENT
_cnum$ = -4						; size = 4
_origin$ = 8						; size = 4
_S_StopSound PROC					; COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 690  : 	INT32 cnum;
; 691  : 
; 692  : 	// Sounds without origin can have multiple sources, they shouldn't
; 693  : 	// be stopped by new sounds.
; 694  : 	if (!origin)

  00009	83 7d 08 00	 cmp	 DWORD PTR _origin$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN5@S_StopSoun

; 695  : 		return;

  0000f	eb 67		 jmp	 SHORT $LN3@S_StopSoun
$LN5@S_StopSoun:

; 696  : 
; 697  : #ifdef HW3SOUND
; 698  : 	if (hws_mode != HWS_DEFAULT_MODE)

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00018	74 0e		 je	 SHORT $LN6@S_StopSoun

; 699  : 	{
; 700  : 		HW3S_StopSound(origin);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _origin$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _HW3S_StopSound
  00023	83 c4 04	 add	 esp, 4

; 701  : 		return;

  00026	eb 50		 jmp	 SHORT $LN3@S_StopSoun
$LN6@S_StopSoun:

; 702  : 	}
; 703  : #endif
; 704  : 	for (cnum = 0; cnum < numofchannels; cnum++)

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@S_StopSoun
$LN2@S_StopSoun:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 fc	 mov	 DWORD PTR _cnum$[ebp], eax
$LN4@S_StopSoun:
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  0003d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  00043	7d 33		 jge	 SHORT $LN3@S_StopSoun

; 705  : 	{
; 706  : 		if (channels[cnum].sfxinfo && channels[cnum].origin == origin)

  00045	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0004f	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00053	74 21		 je	 SHORT $LN7@S_StopSoun
  00055	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  00059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  0005f	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00063	3b 55 08	 cmp	 edx, DWORD PTR _origin$[ebp]
  00066	75 0e		 jne	 SHORT $LN7@S_StopSoun

; 707  : 		{
; 708  : 			S_StopChannel(cnum);

  00068	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _S_StopChannel
  00071	83 c4 04	 add	 esp, 4

; 709  : 			break;

  00074	eb 02		 jmp	 SHORT $LN3@S_StopSoun
$LN7@S_StopSoun:

; 710  : 		}
; 711  : 	}

  00076	eb b9		 jmp	 SHORT $LN2@S_StopSoun
$LN3@S_StopSoun:

; 712  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_S_StopSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StartSoundAtVolume
_TEXT	SEGMENT
tv213 = -144						; size = 4
tv256 = -144						; size = 4
_rc$1 = -76						; size = 4
_rc$2 = -72						; size = 4
_listenmobj2$ = -68					; size = 4
_listenmobj$ = -64					; size = 4
_listener2$ = -60					; size = 16
_listener$ = -44					; size = 16
_origin$ = -28						; size = 4
_sfx$ = -24						; size = 4
_cnum$ = -20						; size = 4
_priority$ = -16					; size = 4
_pitch$ = -12						; size = 4
_sep$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_origin_p$ = 8						; size = 4
_sfx_id$ = 12						; size = 4
_volume$ = 16						; size = 4
_S_StartSoundAtVolume PROC				; COMDAT

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 444  : 	INT32 sep, pitch, priority, cnum;
; 445  : 	sfxinfo_t *sfx;
; 446  : 
; 447  : 	const mobj_t *origin = (const mobj_t *)origin_p;

  00016	8b 45 08	 mov	 eax, DWORD PTR _origin_p$[ebp]
  00019	89 45 e4	 mov	 DWORD PTR _origin$[ebp], eax

; 448  : 
; 449  : 	listener_t listener  = {0,0,0,0};

  0001c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _listener$[ebp], 0
  00023	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _listener$[ebp+4], 0
  0002a	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _listener$[ebp+8], 0
  00031	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _listener$[ebp+12], 0

; 450  : 	listener_t listener2 = {0,0,0,0};

  00038	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _listener2$[ebp], 0
  0003f	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _listener2$[ebp+4], 0
  00046	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _listener2$[ebp+8], 0
  0004d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _listener2$[ebp+12], 0

; 451  : 
; 452  : 	mobj_t *listenmobj = players[displayplayer].mo;

  00054	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  0005e	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00064	89 4d c0	 mov	 DWORD PTR _listenmobj$[ebp], ecx

; 453  : 	mobj_t *listenmobj2 = NULL;

  00067	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _listenmobj2$[ebp], 0

; 454  : 
; 455  : 	if (sound_disabled || !sound_started)

  0006e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sound_disabled, 0
  00075	75 0b		 jne	 SHORT $LN3@S_StartSou
  00077	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _sound_started
  0007e	85 c0		 test	 eax, eax
  00080	75 05		 jne	 SHORT $LN2@S_StartSou
$LN3@S_StartSou:

; 456  : 		return;

  00082	e9 e4 03 00 00	 jmp	 $LN1@S_StartSou
$LN2@S_StartSou:

; 457  : 
; 458  : 	// In space, no one can hear you spin, unless you die.
; 459  : 	if (!splitscreen && players[displayplayer].powers[pw_spacetime] &&

  00087	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0008e	75 42		 jne	 SHORT $LN5@S_StartSou
  00090	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  0009a	b9 04 00 00 00	 mov	 ecx, 4
  0009f	6b d1 07	 imul	 edx, ecx, 7
  000a2	83 bc 10 38 00
	00 00 00	 cmp	 DWORD PTR _players[eax+edx+56], 0
  000aa	74 26		 je	 SHORT $LN5@S_StartSou
  000ac	83 7d 0c 02	 cmp	 DWORD PTR _sfx_id$[ebp], 2
  000b0	74 20		 je	 SHORT $LN5@S_StartSou
  000b2	83 7d 0c 03	 cmp	 DWORD PTR _sfx_id$[ebp], 3
  000b6	74 1a		 je	 SHORT $LN5@S_StartSou
  000b8	83 7d 0c 04	 cmp	 DWORD PTR _sfx_id$[ebp], 4
  000bc	74 14		 je	 SHORT $LN5@S_StartSou
  000be	83 7d 0c 05	 cmp	 DWORD PTR _sfx_id$[ebp], 5
  000c2	74 0e		 je	 SHORT $LN5@S_StartSou

; 460  : 		!(sfx_id == sfx_altdi1 || sfx_id == sfx_altdi2 || sfx_id == sfx_altdi3 || sfx_id == sfx_altdi4))
; 461  : 
; 462  : 	if (oncontinuescreen)

  000c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _oncontinuescreen, 0
  000cb	74 05		 je	 SHORT $LN5@S_StartSou

; 463  : 		return;

  000cd	e9 99 03 00 00	 jmp	 $LN1@S_StartSou
$LN5@S_StartSou:

; 464  : 
; 465  : 	if (splitscreen) listenmobj2 = players[secondarydisplayplayer].mo;

  000d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  000d9	74 13		 je	 SHORT $LN6@S_StartSou
  000db	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  000e5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000eb	89 4d bc	 mov	 DWORD PTR _listenmobj2$[ebp], ecx
$LN6@S_StartSou:

; 466  : 
; 467  : 	if (nosound)

  000ee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  000f5	74 05		 je	 SHORT $LN7@S_StartSou

; 468  : 		return;

  000f7	e9 6f 03 00 00	 jmp	 $LN1@S_StartSou
$LN7@S_StartSou:

; 469  : 
; 470  : #ifdef HW3SOUND
; 471  : 	if (hws_mode != HWS_DEFAULT_MODE)

  000fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00103	74 15		 je	 SHORT $LN8@S_StartSou

; 472  : 	{
; 473  : 		HW3S_StartSound(origin, sfx_id);

  00105	8b 45 0c	 mov	 eax, DWORD PTR _sfx_id$[ebp]
  00108	50		 push	 eax
  00109	8b 4d e4	 mov	 ecx, DWORD PTR _origin$[ebp]
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _HW3S_StartSound
  00112	83 c4 08	 add	 esp, 8

; 474  : 		return;

  00115	e9 51 03 00 00	 jmp	 $LN1@S_StartSou
$LN8@S_StartSou:

; 475  : 	};
; 476  : #endif
; 477  : 
; 478  : 	if (cv_chasecam.value)

  0011a	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam+20, 0
  00121	74 22		 je	 SHORT $LN9@S_StartSou

; 479  : 	{
; 480  : 		listener.x = camera.x;

  00123	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera+16
  00128	89 45 d4	 mov	 DWORD PTR _listener$[ebp], eax

; 481  : 		listener.y = camera.y;

  0012b	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera+20
  00130	89 45 d8	 mov	 DWORD PTR _listener$[ebp+4], eax

; 482  : 		listener.z = camera.z;

  00133	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera+24
  00138	89 45 dc	 mov	 DWORD PTR _listener$[ebp+8], eax

; 483  : 		listener.angle = camera.angle;

  0013b	a1 1c 00 00 00	 mov	 eax, DWORD PTR _camera+28
  00140	89 45 e0	 mov	 DWORD PTR _listener$[ebp+12], eax

; 484  : 	}

  00143	eb 37		 jmp	 SHORT $LN13@S_StartSou
$LN9@S_StartSou:

; 485  : 	else if (listenmobj)

  00145	83 7d c0 00	 cmp	 DWORD PTR _listenmobj$[ebp], 0
  00149	74 26		 je	 SHORT $LN11@S_StartSou

; 486  : 	{
; 487  : 		listener.x = listenmobj->x;

  0014b	8b 45 c0	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  0014e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00151	89 4d d4	 mov	 DWORD PTR _listener$[ebp], ecx

; 488  : 		listener.y = listenmobj->y;

  00154	8b 45 c0	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  00157	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015a	89 4d d8	 mov	 DWORD PTR _listener$[ebp+4], ecx

; 489  : 		listener.z = listenmobj->z;

  0015d	8b 45 c0	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  00160	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00163	89 4d dc	 mov	 DWORD PTR _listener$[ebp+8], ecx

; 490  : 		listener.angle = listenmobj->angle;

  00166	8b 45 c0	 mov	 eax, DWORD PTR _listenmobj$[ebp]
  00169	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0016c	89 4d e0	 mov	 DWORD PTR _listener$[ebp+12], ecx

; 491  : 	}

  0016f	eb 0b		 jmp	 SHORT $LN13@S_StartSou
$LN11@S_StartSou:

; 492  : 	else if (origin)

  00171	83 7d e4 00	 cmp	 DWORD PTR _origin$[ebp], 0
  00175	74 05		 je	 SHORT $LN13@S_StartSou

; 493  : 		return;

  00177	e9 ef 02 00 00	 jmp	 $LN1@S_StartSou
$LN13@S_StartSou:

; 494  : 
; 495  : 	if (listenmobj2)

  0017c	83 7d bc 00	 cmp	 DWORD PTR _listenmobj2$[ebp], 0
  00180	74 4f		 je	 SHORT $LN16@S_StartSou

; 496  : 	{
; 497  : 		if (cv_chasecam2.value)

  00182	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam2+20, 0
  00189	74 22		 je	 SHORT $LN15@S_StartSou

; 498  : 		{
; 499  : 			listener2.x = camera2.x;

  0018b	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera2+16
  00190	89 45 c4	 mov	 DWORD PTR _listener2$[ebp], eax

; 500  : 			listener2.y = camera2.y;

  00193	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera2+20
  00198	89 45 c8	 mov	 DWORD PTR _listener2$[ebp+4], eax

; 501  : 			listener2.z = camera2.z;

  0019b	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera2+24
  001a0	89 45 cc	 mov	 DWORD PTR _listener2$[ebp+8], eax

; 502  : 			listener2.angle = camera2.angle;

  001a3	a1 1c 00 00 00	 mov	 eax, DWORD PTR _camera2+28
  001a8	89 45 d0	 mov	 DWORD PTR _listener2$[ebp+12], eax

; 503  : 		}

  001ab	eb 24		 jmp	 SHORT $LN16@S_StartSou
$LN15@S_StartSou:

; 504  : 		else
; 505  : 		{
; 506  : 			listener2.x = listenmobj2->x;

  001ad	8b 45 bc	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  001b0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001b3	89 4d c4	 mov	 DWORD PTR _listener2$[ebp], ecx

; 507  : 			listener2.y = listenmobj2->y;

  001b6	8b 45 bc	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  001b9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001bc	89 4d c8	 mov	 DWORD PTR _listener2$[ebp+4], ecx

; 508  : 			listener2.z = listenmobj2->z;

  001bf	8b 45 bc	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  001c2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001c5	89 4d cc	 mov	 DWORD PTR _listener2$[ebp+8], ecx

; 509  : 			listener2.angle = listenmobj2->angle;

  001c8	8b 45 bc	 mov	 eax, DWORD PTR _listenmobj2$[ebp]
  001cb	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001ce	89 4d d0	 mov	 DWORD PTR _listener2$[ebp+12], ecx
$LN16@S_StartSou:

; 510  : 		}
; 511  : 	}
; 512  : 
; 513  : 	// Don't want a sound? Okay then...
; 514  : 	if (sfx_id == 0 || sfx_id == sfx_None)

  001d1	83 7d 0c 00	 cmp	 DWORD PTR _sfx_id$[ebp], 0
  001d5	74 06		 je	 SHORT $LN18@S_StartSou
  001d7	83 7d 0c 00	 cmp	 DWORD PTR _sfx_id$[ebp], 0
  001db	75 05		 jne	 SHORT $LN17@S_StartSou
$LN18@S_StartSou:

; 515  : 		return;

  001dd	e9 89 02 00 00	 jmp	 $LN1@S_StartSou
$LN17@S_StartSou:

; 516  : 
; 517  : 	// check for bogus sound #
; 518  : 	I_Assert(sfx_id >= 1);
; 519  : 	I_Assert(sfx_id < NUMSFX);
; 520  : 
; 521  : 	sfx = &S_sfx[sfx_id];

  001e2	6b 45 0c 2c	 imul	 eax, DWORD PTR _sfx_id$[ebp], 44
  001e6	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  001eb	89 45 e8	 mov	 DWORD PTR _sfx$[ebp], eax

; 522  : 
; 523  : 	if (sfx->skinsound != -1 && origin && origin->skin)

  001ee	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  001f1	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  001f5	74 31		 je	 SHORT $LN19@S_StartSou
  001f7	83 7d e4 00	 cmp	 DWORD PTR _origin$[ebp], 0
  001fb	74 2b		 je	 SHORT $LN19@S_StartSou
  001fd	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  00200	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00204	74 22		 je	 SHORT $LN19@S_StartSou

; 524  : 	{
; 525  : 		// redirect player sound to the sound in the skin table
; 526  : 		sfx_id = ((skin_t *)origin->skin)->soundsid[sfx->skinsound];

  00206	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  00209	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0020c	8b 55 e8	 mov	 edx, DWORD PTR _sfx$[ebp]
  0020f	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00212	8b 8c 81 88 00
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+136]
  00219	89 4d 0c	 mov	 DWORD PTR _sfx_id$[ebp], ecx

; 527  : 		sfx = &S_sfx[sfx_id];

  0021c	6b 45 0c 2c	 imul	 eax, DWORD PTR _sfx_id$[ebp], 44
  00220	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  00225	89 45 e8	 mov	 DWORD PTR _sfx$[ebp], eax
$LN19@S_StartSou:

; 528  : 	}
; 529  : 
; 530  : 	// Initialize sound parameters
; 531  : 	pitch = NORM_PITCH;

  00228	c7 45 f4 80 00
	00 00		 mov	 DWORD PTR _pitch$[ebp], 128 ; 00000080H

; 532  : 	priority = NORM_PRIORITY;

  0022f	c7 45 f0 40 00
	00 00		 mov	 DWORD PTR _priority$[ebp], 64 ; 00000040H

; 533  : 
; 534  : 	if (splitscreen && listenmobj2) // Copy the sound for the split player

  00236	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0023d	0f 84 19 01 00
	00		 je	 $dontplay$38
  00243	83 7d bc 00	 cmp	 DWORD PTR _listenmobj2$[ebp], 0
  00247	0f 84 0f 01 00
	00		 je	 $dontplay$38

; 535  : 	{
; 536  : 		// Check to see if it is audible, and if not, modify the params
; 537  : 		if (origin && origin != listenmobj2)

  0024d	83 7d e4 00	 cmp	 DWORD PTR _origin$[ebp], 0
  00251	74 55		 je	 SHORT $LN21@S_StartSou
  00253	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  00256	3b 45 bc	 cmp	 eax, DWORD PTR _listenmobj2$[ebp]
  00259	74 4d		 je	 SHORT $LN21@S_StartSou

; 538  : 		{
; 539  : 			INT32 rc;
; 540  : 			rc = S_AdjustSoundParams(listenmobj2, origin, &volume, &sep, &pitch, sfx);

  0025b	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  0025e	50		 push	 eax
  0025f	8d 4d f4	 lea	 ecx, DWORD PTR _pitch$[ebp]
  00262	51		 push	 ecx
  00263	8d 55 f8	 lea	 edx, DWORD PTR _sep$[ebp]
  00266	52		 push	 edx
  00267	8d 45 10	 lea	 eax, DWORD PTR _volume$[ebp]
  0026a	50		 push	 eax
  0026b	8b 4d e4	 mov	 ecx, DWORD PTR _origin$[ebp]
  0026e	51		 push	 ecx
  0026f	8b 55 bc	 mov	 edx, DWORD PTR _listenmobj2$[ebp]
  00272	52		 push	 edx
  00273	e8 00 00 00 00	 call	 _S_AdjustSoundParams
  00278	83 c4 18	 add	 esp, 24			; 00000018H
  0027b	89 45 b8	 mov	 DWORD PTR _rc$2[ebp], eax

; 541  : 
; 542  : 			if (!rc)

  0027e	83 7d b8 00	 cmp	 DWORD PTR _rc$2[ebp], 0
  00282	75 05		 jne	 SHORT $LN23@S_StartSou

; 543  : 				goto dontplay; // Maybe the other player can hear it...

  00284	e9 d3 00 00 00	 jmp	 $dontplay$38
$LN23@S_StartSou:

; 544  : 
; 545  : 			if (origin->x == listener2.x && origin->y == listener2.y)

  00289	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  0028c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0028f	3b 4d c4	 cmp	 ecx, DWORD PTR _listener2$[ebp]
  00292	75 12		 jne	 SHORT $LN24@S_StartSou
  00294	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  00297	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0029a	3b 4d c8	 cmp	 ecx, DWORD PTR _listener2$[ebp+4]
  0029d	75 07		 jne	 SHORT $LN24@S_StartSou

; 546  : 				sep = NORM_SEP;

  0029f	c7 45 f8 80 00
	00 00		 mov	 DWORD PTR _sep$[ebp], 128 ; 00000080H
$LN24@S_StartSou:

; 547  : 		}

  002a6	eb 07		 jmp	 SHORT $LN22@S_StartSou
$LN21@S_StartSou:

; 548  : 		else
; 549  : 			sep = NORM_SEP;

  002a8	c7 45 f8 80 00
	00 00		 mov	 DWORD PTR _sep$[ebp], 128 ; 00000080H
$LN22@S_StartSou:

; 550  : 
; 551  : 		// try to find a channel
; 552  : 		cnum = S_getChannel(origin, sfx);

  002af	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  002b2	50		 push	 eax
  002b3	8b 4d e4	 mov	 ecx, DWORD PTR _origin$[ebp]
  002b6	51		 push	 ecx
  002b7	e8 00 00 00 00	 call	 _S_getChannel
  002bc	83 c4 08	 add	 esp, 8
  002bf	89 45 ec	 mov	 DWORD PTR _cnum$[ebp], eax

; 553  : 
; 554  : 		if (cnum < 0)

  002c2	83 7d ec 00	 cmp	 DWORD PTR _cnum$[ebp], 0
  002c6	7d 05		 jge	 SHORT $LN25@S_StartSou

; 555  : 			return; // If there's no free channels, it's not gonna be free for player 1, either.

  002c8	e9 9e 01 00 00	 jmp	 $LN1@S_StartSou
$LN25@S_StartSou:

; 556  : 
; 557  : 		// This is supposed to handle the loading/caching.
; 558  : 		// For some odd reason, the caching is done nearly
; 559  : 		// each time the sound is needed?
; 560  : 
; 561  : 		// cache data if necessary
; 562  : 		// NOTE: set sfx->data NULL sfx->lump -1 to force a reload
; 563  : 		if (!sfx->data)

  002cd	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  002d0	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  002d4	75 12		 jne	 SHORT $LN26@S_StartSou

; 564  : 			sfx->data = I_GetSfx(sfx);

  002d6	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  002d9	50		 push	 eax
  002da	e8 00 00 00 00	 call	 _I_GetSfx
  002df	83 c4 04	 add	 esp, 4
  002e2	8b 4d e8	 mov	 ecx, DWORD PTR _sfx$[ebp]
  002e5	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN26@S_StartSou:

; 565  : 
; 566  : 		// increase the usefulness
; 567  : 		if (sfx->usefulness++ < 0)

  002e8	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  002eb	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  002ee	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], ecx
  002f4	8b 55 e8	 mov	 edx, DWORD PTR _sfx$[ebp]
  002f7	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  002fa	83 c0 01	 add	 eax, 1
  002fd	8b 4d e8	 mov	 ecx, DWORD PTR _sfx$[ebp]
  00300	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00303	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv213[ebp], 0
  0030a	7d 0a		 jge	 SHORT $LN27@S_StartSou

; 568  : 			sfx->usefulness = -1;

  0030c	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  0030f	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [eax+32], -1
$LN27@S_StartSou:

; 569  : 
; 570  : #ifdef SURROUND
; 571  : 		// Avoid channel reverse if surround
; 572  : 		if (stereoreverse.value && sep != SURROUND_SEP)

  00316	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _stereoreverse+20, 0
  0031d	74 13		 je	 SHORT $LN28@S_StartSou
  0031f	83 7d f8 80	 cmp	 DWORD PTR _sep$[ebp], -128 ; ffffff80H
  00323	74 0d		 je	 SHORT $LN28@S_StartSou

; 573  : 			sep = (~sep) & 255;

  00325	8b 45 f8	 mov	 eax, DWORD PTR _sep$[ebp]
  00328	f7 d0		 not	 eax
  0032a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0032f	89 45 f8	 mov	 DWORD PTR _sep$[ebp], eax
$LN28@S_StartSou:

; 574  : #else
; 575  : 		if (stereoreverse.value)
; 576  : 			sep = (~sep) & 255;
; 577  : #endif
; 578  : 
; 579  : 		// Assigns the handle to one of the channels in the
; 580  : 		// mix/output buffer.
; 581  : 		channels[cnum].handle = I_StartSound(sfx_id, volume, sep, pitch, priority);

  00332	8b 45 f0	 mov	 eax, DWORD PTR _priority$[ebp]
  00335	50		 push	 eax
  00336	8b 4d f4	 mov	 ecx, DWORD PTR _pitch$[ebp]
  00339	51		 push	 ecx
  0033a	8b 55 f8	 mov	 edx, DWORD PTR _sep$[ebp]
  0033d	52		 push	 edx
  0033e	8b 45 10	 mov	 eax, DWORD PTR _volume$[ebp]
  00341	50		 push	 eax
  00342	8b 4d 0c	 mov	 ecx, DWORD PTR _sfx_id$[ebp]
  00345	51		 push	 ecx
  00346	e8 00 00 00 00	 call	 _I_StartSound
  0034b	83 c4 14	 add	 esp, 20			; 00000014H
  0034e	6b 55 ec 0c	 imul	 edx, DWORD PTR _cnum$[ebp], 12
  00352	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00358	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax
$dontplay$38:

; 582  : 	}
; 583  : 
; 584  : dontplay:
; 585  : 
; 586  : 	// Check to see if it is audible, and if not, modify the params
; 587  : 	if (origin && origin != listenmobj)

  0035c	83 7d e4 00	 cmp	 DWORD PTR _origin$[ebp], 0
  00360	74 55		 je	 SHORT $LN29@S_StartSou
  00362	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  00365	3b 45 c0	 cmp	 eax, DWORD PTR _listenmobj$[ebp]
  00368	74 4d		 je	 SHORT $LN29@S_StartSou

; 588  : 	{
; 589  : 		INT32 rc;
; 590  : 		rc = S_AdjustSoundParams(listenmobj, origin, &volume, &sep, &pitch, sfx);

  0036a	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  0036d	50		 push	 eax
  0036e	8d 4d f4	 lea	 ecx, DWORD PTR _pitch$[ebp]
  00371	51		 push	 ecx
  00372	8d 55 f8	 lea	 edx, DWORD PTR _sep$[ebp]
  00375	52		 push	 edx
  00376	8d 45 10	 lea	 eax, DWORD PTR _volume$[ebp]
  00379	50		 push	 eax
  0037a	8b 4d e4	 mov	 ecx, DWORD PTR _origin$[ebp]
  0037d	51		 push	 ecx
  0037e	8b 55 c0	 mov	 edx, DWORD PTR _listenmobj$[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 _S_AdjustSoundParams
  00387	83 c4 18	 add	 esp, 24			; 00000018H
  0038a	89 45 b4	 mov	 DWORD PTR _rc$1[ebp], eax

; 591  : 
; 592  : 		if (!rc)

  0038d	83 7d b4 00	 cmp	 DWORD PTR _rc$1[ebp], 0
  00391	75 05		 jne	 SHORT $LN31@S_StartSou

; 593  : 			return;

  00393	e9 d3 00 00 00	 jmp	 $LN1@S_StartSou
$LN31@S_StartSou:

; 594  : 
; 595  : 		if (origin->x == listener.x && origin->y == listener.y)

  00398	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  0039b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0039e	3b 4d d4	 cmp	 ecx, DWORD PTR _listener$[ebp]
  003a1	75 12		 jne	 SHORT $LN32@S_StartSou
  003a3	8b 45 e4	 mov	 eax, DWORD PTR _origin$[ebp]
  003a6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003a9	3b 4d d8	 cmp	 ecx, DWORD PTR _listener$[ebp+4]
  003ac	75 07		 jne	 SHORT $LN32@S_StartSou

; 596  : 			sep = NORM_SEP;

  003ae	c7 45 f8 80 00
	00 00		 mov	 DWORD PTR _sep$[ebp], 128 ; 00000080H
$LN32@S_StartSou:

; 597  : 	}

  003b5	eb 07		 jmp	 SHORT $LN30@S_StartSou
$LN29@S_StartSou:

; 598  : 	else
; 599  : 		sep = NORM_SEP;

  003b7	c7 45 f8 80 00
	00 00		 mov	 DWORD PTR _sep$[ebp], 128 ; 00000080H
$LN30@S_StartSou:

; 600  : 
; 601  : 	// try to find a channel
; 602  : 	cnum = S_getChannel(origin, sfx);

  003be	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  003c1	50		 push	 eax
  003c2	8b 4d e4	 mov	 ecx, DWORD PTR _origin$[ebp]
  003c5	51		 push	 ecx
  003c6	e8 00 00 00 00	 call	 _S_getChannel
  003cb	83 c4 08	 add	 esp, 8
  003ce	89 45 ec	 mov	 DWORD PTR _cnum$[ebp], eax

; 603  : 
; 604  : 	if (cnum < 0)

  003d1	83 7d ec 00	 cmp	 DWORD PTR _cnum$[ebp], 0
  003d5	7d 05		 jge	 SHORT $LN33@S_StartSou

; 605  : 		return;

  003d7	e9 8f 00 00 00	 jmp	 $LN1@S_StartSou
$LN33@S_StartSou:

; 606  : 
; 607  : 	// This is supposed to handle the loading/caching.
; 608  : 	// For some odd reason, the caching is done nearly
; 609  : 	// each time the sound is needed?
; 610  : 
; 611  : 	// cache data if necessary
; 612  : 	// NOTE: set sfx->data NULL sfx->lump -1 to force a reload
; 613  : 	if (!sfx->data)

  003dc	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  003df	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  003e3	75 12		 jne	 SHORT $LN34@S_StartSou

; 614  : 		sfx->data = I_GetSfx(sfx);

  003e5	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  003e8	50		 push	 eax
  003e9	e8 00 00 00 00	 call	 _I_GetSfx
  003ee	83 c4 04	 add	 esp, 4
  003f1	8b 4d e8	 mov	 ecx, DWORD PTR _sfx$[ebp]
  003f4	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN34@S_StartSou:

; 615  : 
; 616  : 	// increase the usefulness
; 617  : 	if (sfx->usefulness++ < 0)

  003f7	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  003fa	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003fd	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv256[ebp], ecx
  00403	8b 55 e8	 mov	 edx, DWORD PTR _sfx$[ebp]
  00406	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00409	83 c0 01	 add	 eax, 1
  0040c	8b 4d e8	 mov	 ecx, DWORD PTR _sfx$[ebp]
  0040f	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00412	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv256[ebp], 0
  00419	7d 0a		 jge	 SHORT $LN35@S_StartSou

; 618  : 		sfx->usefulness = -1;

  0041b	8b 45 e8	 mov	 eax, DWORD PTR _sfx$[ebp]
  0041e	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [eax+32], -1
$LN35@S_StartSou:

; 619  : 
; 620  : #ifdef SURROUND
; 621  : 	// Avoid channel reverse if surround
; 622  : 	if (stereoreverse.value && sep != SURROUND_SEP)

  00425	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _stereoreverse+20, 0
  0042c	74 13		 je	 SHORT $LN36@S_StartSou
  0042e	83 7d f8 80	 cmp	 DWORD PTR _sep$[ebp], -128 ; ffffff80H
  00432	74 0d		 je	 SHORT $LN36@S_StartSou

; 623  : 		sep = (~sep) & 255;

  00434	8b 45 f8	 mov	 eax, DWORD PTR _sep$[ebp]
  00437	f7 d0		 not	 eax
  00439	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0043e	89 45 f8	 mov	 DWORD PTR _sep$[ebp], eax
$LN36@S_StartSou:

; 624  : #else
; 625  : 	if (stereoreverse.value)
; 626  : 		sep = (~sep) & 255;
; 627  : #endif
; 628  : 
; 629  : 	// Assigns the handle to one of the channels in the
; 630  : 	// mix/output buffer.
; 631  : 	channels[cnum].handle = I_StartSound(sfx_id, volume, sep, pitch, priority);

  00441	8b 45 f0	 mov	 eax, DWORD PTR _priority$[ebp]
  00444	50		 push	 eax
  00445	8b 4d f4	 mov	 ecx, DWORD PTR _pitch$[ebp]
  00448	51		 push	 ecx
  00449	8b 55 f8	 mov	 edx, DWORD PTR _sep$[ebp]
  0044c	52		 push	 edx
  0044d	8b 45 10	 mov	 eax, DWORD PTR _volume$[ebp]
  00450	50		 push	 eax
  00451	8b 4d 0c	 mov	 ecx, DWORD PTR _sfx_id$[ebp]
  00454	51		 push	 ecx
  00455	e8 00 00 00 00	 call	 _I_StartSound
  0045a	83 c4 14	 add	 esp, 20			; 00000014H
  0045d	6b 55 ec 0c	 imul	 edx, DWORD PTR _cnum$[ebp], 12
  00461	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00467	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax
$LN1@S_StartSou:

; 632  : }

  0046b	5f		 pop	 edi
  0046c	5e		 pop	 esi
  0046d	5b		 pop	 ebx
  0046e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00471	33 cd		 xor	 ecx, ebp
  00473	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00478	8b e5		 mov	 esp, ebp
  0047a	5d		 pop	 ebp
  0047b	c3		 ret	 0
_S_StartSoundAtVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StartSound
_TEXT	SEGMENT
tv68 = -68						; size = 4
_origin$ = 8						; size = 4
_sfx_id$ = 12						; size = 4
_S_StartSound PROC					; COMDAT

; 635  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 636  : 	if (sound_disabled)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sound_disabled, 0
  00010	74 05		 je	 SHORT $LN4@S_StartSou

; 637  : 		return;

  00012	e9 b6 00 00 00	 jmp	 $LN20@S_StartSou
$LN4@S_StartSou:

; 638  : 
; 639  : 	if (mariomode) // Sounds change in Mario mode!

  00017	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  0001e	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00023	74 78		 je	 SHORT $LN2@S_StartSou

; 640  : 	{
; 641  : 		switch (sfx_id)

  00025	8b 45 0c	 mov	 eax, DWORD PTR _sfx_id$[ebp]
  00028	89 45 bc	 mov	 DWORD PTR tv68[ebp], eax
  0002b	8b 4d bc	 mov	 ecx, DWORD PTR tv68[ebp]
  0002e	83 e9 06	 sub	 ecx, 6
  00031	89 4d bc	 mov	 DWORD PTR tv68[ebp], ecx
  00034	81 7d bc e0 00
	00 00		 cmp	 DWORD PTR tv68[ebp], 224 ; 000000e0H
  0003b	77 60		 ja	 SHORT $LN18@S_StartSou
  0003d	8b 55 bc	 mov	 edx, DWORD PTR tv68[ebp]
  00040	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN22@S_StartSou[edx]
  00047	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@S_StartSou[eax*4]
$LN6@S_StartSou:

; 642  : 		{
; 643  : 			case sfx_altow1:
; 644  : 			case sfx_altow2:
; 645  : 			case sfx_altow3:
; 646  : 			case sfx_altow4:
; 647  : 				sfx_id = sfx_mario8;

  0004e	c7 45 0c 64 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 100 ; 00000064H

; 648  : 				break;

  00055	eb 46		 jmp	 SHORT $LN2@S_StartSou
$LN10@S_StartSou:

; 649  : 			case sfx_thok:
; 650  : 				sfx_id = sfx_mario7;

  00057	c7 45 0c 63 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 99 ; 00000063H

; 651  : 				break;

  0005e	eb 3d		 jmp	 SHORT $LN2@S_StartSou
$LN11@S_StartSou:

; 652  : 			case sfx_pop:
; 653  : 				sfx_id = sfx_mario5;

  00060	c7 45 0c 61 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 97 ; 00000061H

; 654  : 				break;

  00067	eb 34		 jmp	 SHORT $LN2@S_StartSou
$LN12@S_StartSou:

; 655  : 			case sfx_jump:
; 656  : 				sfx_id = sfx_mario6;

  00069	c7 45 0c 62 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 98 ; 00000062H

; 657  : 				break;

  00070	eb 2b		 jmp	 SHORT $LN2@S_StartSou
$LN13@S_StartSou:

; 658  : 			case sfx_shield:
; 659  : 				sfx_id = sfx_mario3;

  00072	c7 45 0c 5f 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 95 ; 0000005fH

; 660  : 				break;

  00079	eb 22		 jmp	 SHORT $LN2@S_StartSou
$LN14@S_StartSou:

; 661  : 			case sfx_itemup:
; 662  : 				sfx_id = sfx_mario4;

  0007b	c7 45 0c 60 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 96 ; 00000060H

; 663  : 				break;

  00082	eb 19		 jmp	 SHORT $LN2@S_StartSou
$LN15@S_StartSou:

; 664  : 			case sfx_tink:
; 665  : 				sfx_id = sfx_mario1;

  00084	c7 45 0c 5d 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 93 ; 0000005dH

; 666  : 				break;

  0008b	eb 10		 jmp	 SHORT $LN2@S_StartSou
$LN16@S_StartSou:

; 667  : 			case sfx_cgot:
; 668  : 				sfx_id = sfx_mario9;

  0008d	c7 45 0c 65 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 101 ; 00000065H

; 669  : 				break;

  00094	eb 07		 jmp	 SHORT $LN2@S_StartSou
$LN17@S_StartSou:

; 670  : 			case sfx_lose:
; 671  : 				sfx_id = sfx_mario2;

  00096	c7 45 0c 5e 00
	00 00		 mov	 DWORD PTR _sfx_id$[ebp], 94 ; 0000005eH
$LN18@S_StartSou:
$LN2@S_StartSou:

; 672  : 				break;
; 673  : 			default:
; 674  : 				break;
; 675  : 		}
; 676  : 
; 677  : 	}
; 678  : 
; 679  : 	// the volume is handled 8 bits
; 680  : #ifdef HW3SOUND
; 681  : 	if (hws_mode != HWS_DEFAULT_MODE)

  0009d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  000a4	74 12		 je	 SHORT $LN19@S_StartSou

; 682  : 		HW3S_StartSound(origin, sfx_id);

  000a6	8b 45 0c	 mov	 eax, DWORD PTR _sfx_id$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _origin$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _HW3S_StartSound
  000b3	83 c4 08	 add	 esp, 8
  000b6	eb 15		 jmp	 SHORT $LN20@S_StartSou
$LN19@S_StartSou:

; 683  : 	else
; 684  : #endif
; 685  : 		S_StartSoundAtVolume(origin, sfx_id, 255);

  000b8	68 ff 00 00 00	 push	 255			; 000000ffH
  000bd	8b 45 0c	 mov	 eax, DWORD PTR _sfx_id$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _origin$[ebp]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 _S_StartSoundAtVolume
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@S_StartSou:

; 686  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN23@S_StartSou:
  000d4	00 00 00 00	 DD	 $LN6@S_StartSou
  000d8	00 00 00 00	 DD	 $LN16@S_StartSou
  000dc	00 00 00 00	 DD	 $LN14@S_StartSou
  000e0	00 00 00 00	 DD	 $LN12@S_StartSou
  000e4	00 00 00 00	 DD	 $LN17@S_StartSou
  000e8	00 00 00 00	 DD	 $LN11@S_StartSou
  000ec	00 00 00 00	 DD	 $LN13@S_StartSou
  000f0	00 00 00 00	 DD	 $LN10@S_StartSou
  000f4	00 00 00 00	 DD	 $LN15@S_StartSou
  000f8	00 00 00 00	 DD	 $LN18@S_StartSou
$LN22@S_StartSou:
  000fc	00		 DB	 0
  000fd	00		 DB	 0
  000fe	00		 DB	 0
  000ff	00		 DB	 0
  00100	09		 DB	 9
  00101	09		 DB	 9
  00102	09		 DB	 9
  00103	09		 DB	 9
  00104	09		 DB	 9
  00105	09		 DB	 9
  00106	09		 DB	 9
  00107	09		 DB	 9
  00108	09		 DB	 9
  00109	09		 DB	 9
  0010a	09		 DB	 9
  0010b	09		 DB	 9
  0010c	09		 DB	 9
  0010d	09		 DB	 9
  0010e	09		 DB	 9
  0010f	09		 DB	 9
  00110	09		 DB	 9
  00111	09		 DB	 9
  00112	09		 DB	 9
  00113	09		 DB	 9
  00114	09		 DB	 9
  00115	09		 DB	 9
  00116	09		 DB	 9
  00117	09		 DB	 9
  00118	09		 DB	 9
  00119	09		 DB	 9
  0011a	09		 DB	 9
  0011b	09		 DB	 9
  0011c	09		 DB	 9
  0011d	09		 DB	 9
  0011e	09		 DB	 9
  0011f	01		 DB	 1
  00120	09		 DB	 9
  00121	09		 DB	 9
  00122	09		 DB	 9
  00123	09		 DB	 9
  00124	09		 DB	 9
  00125	09		 DB	 9
  00126	09		 DB	 9
  00127	09		 DB	 9
  00128	09		 DB	 9
  00129	09		 DB	 9
  0012a	09		 DB	 9
  0012b	09		 DB	 9
  0012c	09		 DB	 9
  0012d	09		 DB	 9
  0012e	09		 DB	 9
  0012f	09		 DB	 9
  00130	09		 DB	 9
  00131	09		 DB	 9
  00132	09		 DB	 9
  00133	09		 DB	 9
  00134	09		 DB	 9
  00135	09		 DB	 9
  00136	09		 DB	 9
  00137	09		 DB	 9
  00138	09		 DB	 9
  00139	09		 DB	 9
  0013a	09		 DB	 9
  0013b	09		 DB	 9
  0013c	09		 DB	 9
  0013d	09		 DB	 9
  0013e	09		 DB	 9
  0013f	09		 DB	 9
  00140	09		 DB	 9
  00141	09		 DB	 9
  00142	09		 DB	 9
  00143	09		 DB	 9
  00144	09		 DB	 9
  00145	09		 DB	 9
  00146	09		 DB	 9
  00147	09		 DB	 9
  00148	09		 DB	 9
  00149	02		 DB	 2
  0014a	03		 DB	 3
  0014b	09		 DB	 9
  0014c	09		 DB	 9
  0014d	09		 DB	 9
  0014e	09		 DB	 9
  0014f	09		 DB	 9
  00150	09		 DB	 9
  00151	04		 DB	 4
  00152	09		 DB	 9
  00153	09		 DB	 9
  00154	09		 DB	 9
  00155	09		 DB	 9
  00156	09		 DB	 9
  00157	09		 DB	 9
  00158	09		 DB	 9
  00159	09		 DB	 9
  0015a	09		 DB	 9
  0015b	09		 DB	 9
  0015c	09		 DB	 9
  0015d	09		 DB	 9
  0015e	09		 DB	 9
  0015f	09		 DB	 9
  00160	09		 DB	 9
  00161	09		 DB	 9
  00162	09		 DB	 9
  00163	09		 DB	 9
  00164	09		 DB	 9
  00165	09		 DB	 9
  00166	09		 DB	 9
  00167	09		 DB	 9
  00168	09		 DB	 9
  00169	09		 DB	 9
  0016a	09		 DB	 9
  0016b	09		 DB	 9
  0016c	09		 DB	 9
  0016d	05		 DB	 5
  0016e	09		 DB	 9
  0016f	09		 DB	 9
  00170	09		 DB	 9
  00171	09		 DB	 9
  00172	09		 DB	 9
  00173	09		 DB	 9
  00174	09		 DB	 9
  00175	09		 DB	 9
  00176	09		 DB	 9
  00177	09		 DB	 9
  00178	09		 DB	 9
  00179	09		 DB	 9
  0017a	09		 DB	 9
  0017b	09		 DB	 9
  0017c	09		 DB	 9
  0017d	09		 DB	 9
  0017e	09		 DB	 9
  0017f	09		 DB	 9
  00180	09		 DB	 9
  00181	09		 DB	 9
  00182	09		 DB	 9
  00183	09		 DB	 9
  00184	09		 DB	 9
  00185	09		 DB	 9
  00186	09		 DB	 9
  00187	09		 DB	 9
  00188	09		 DB	 9
  00189	09		 DB	 9
  0018a	09		 DB	 9
  0018b	09		 DB	 9
  0018c	09		 DB	 9
  0018d	09		 DB	 9
  0018e	09		 DB	 9
  0018f	09		 DB	 9
  00190	09		 DB	 9
  00191	09		 DB	 9
  00192	09		 DB	 9
  00193	09		 DB	 9
  00194	09		 DB	 9
  00195	09		 DB	 9
  00196	09		 DB	 9
  00197	09		 DB	 9
  00198	09		 DB	 9
  00199	09		 DB	 9
  0019a	09		 DB	 9
  0019b	09		 DB	 9
  0019c	09		 DB	 9
  0019d	09		 DB	 9
  0019e	09		 DB	 9
  0019f	09		 DB	 9
  001a0	09		 DB	 9
  001a1	09		 DB	 9
  001a2	09		 DB	 9
  001a3	09		 DB	 9
  001a4	09		 DB	 9
  001a5	09		 DB	 9
  001a6	09		 DB	 9
  001a7	09		 DB	 9
  001a8	09		 DB	 9
  001a9	09		 DB	 9
  001aa	09		 DB	 9
  001ab	09		 DB	 9
  001ac	09		 DB	 9
  001ad	09		 DB	 9
  001ae	09		 DB	 9
  001af	09		 DB	 9
  001b0	09		 DB	 9
  001b1	09		 DB	 9
  001b2	09		 DB	 9
  001b3	09		 DB	 9
  001b4	09		 DB	 9
  001b5	09		 DB	 9
  001b6	09		 DB	 9
  001b7	09		 DB	 9
  001b8	09		 DB	 9
  001b9	09		 DB	 9
  001ba	09		 DB	 9
  001bb	09		 DB	 9
  001bc	09		 DB	 9
  001bd	09		 DB	 9
  001be	09		 DB	 9
  001bf	09		 DB	 9
  001c0	09		 DB	 9
  001c1	09		 DB	 9
  001c2	09		 DB	 9
  001c3	09		 DB	 9
  001c4	09		 DB	 9
  001c5	09		 DB	 9
  001c6	06		 DB	 6
  001c7	09		 DB	 9
  001c8	09		 DB	 9
  001c9	09		 DB	 9
  001ca	09		 DB	 9
  001cb	09		 DB	 9
  001cc	09		 DB	 9
  001cd	09		 DB	 9
  001ce	09		 DB	 9
  001cf	09		 DB	 9
  001d0	09		 DB	 9
  001d1	09		 DB	 9
  001d2	09		 DB	 9
  001d3	09		 DB	 9
  001d4	09		 DB	 9
  001d5	09		 DB	 9
  001d6	09		 DB	 9
  001d7	09		 DB	 9
  001d8	09		 DB	 9
  001d9	09		 DB	 9
  001da	07		 DB	 7
  001db	09		 DB	 9
  001dc	08		 DB	 8
_S_StartSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_GetSfxLumpNum
_TEXT	SEGMENT
_sfxlump$ = -20						; size = 4
_namebuf$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_sfx$ = 8						; size = 4
_S_GetSfxLumpNum PROC					; COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 361  : 	char namebuf[9];
; 362  : 	lumpnum_t sfxlump;
; 363  : 
; 364  : 	sprintf(namebuf, "ds%s", sfx->name);

  00013	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	51		 push	 ecx
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_04BGHBHICD@ds?$CFs@
  0001e	8d 55 f0	 lea	 edx, DWORD PTR _namebuf$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _sprintf
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 365  : 
; 366  : 	sfxlump = W_CheckNumForName(namebuf);

  0002a	8d 45 f0	 lea	 eax, DWORD PTR _namebuf$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _W_CheckNumForName
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR _sfxlump$[ebp], eax

; 367  : 	if (sfxlump != LUMPERROR)

  00039	83 7d ec ff	 cmp	 DWORD PTR _sfxlump$[ebp], -1
  0003d	74 05		 je	 SHORT $LN2@S_GetSfxLu

; 368  : 		return sfxlump;

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _sfxlump$[ebp]
  00042	eb 3b		 jmp	 SHORT $LN1@S_GetSfxLu
$LN2@S_GetSfxLu:

; 369  : 
; 370  : 	strlcpy(namebuf, sfx->name, sizeof namebuf);

  00044	6a 09		 push	 9
  00046	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	8d 55 f0	 lea	 edx, DWORD PTR _namebuf$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _strlcpy
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 371  : 
; 372  : 	sfxlump = W_CheckNumForName(namebuf);

  00058	8d 45 f0	 lea	 eax, DWORD PTR _namebuf$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _W_CheckNumForName
  00061	83 c4 04	 add	 esp, 4
  00064	89 45 ec	 mov	 DWORD PTR _sfxlump$[ebp], eax

; 373  : 	if (sfxlump != LUMPERROR)

  00067	83 7d ec ff	 cmp	 DWORD PTR _sfxlump$[ebp], -1
  0006b	74 05		 je	 SHORT $LN3@S_GetSfxLu

; 374  : 		return sfxlump;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _sfxlump$[ebp]
  00070	eb 0d		 jmp	 SHORT $LN1@S_GetSfxLu
$LN3@S_GetSfxLu:

; 375  : 
; 376  : 	return W_GetNumForName("dsthok");

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_06KHJOJAIK@dsthok@
  00077	e8 00 00 00 00	 call	 _W_GetNumForName
  0007c	83 c4 04	 add	 esp, 4
$LN1@S_GetSfxLu:

; 377  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_S_GetSfxLumpNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_Start
_TEXT	SEGMENT
_S_Start PROC						; COMDAT

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 427  : 	if (!(mapmusic & 2048))

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapmusic
  0000e	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00013	75 1c		 jne	 SHORT $LN2@S_Start

; 428  : 		mapmusic = mapheaderinfo[gamemap-1].musicslot;

  00015	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0001c	83 e8 01	 sub	 eax, 1
  0001f	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00025	8b 91 48 00 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+72]
  0002b	89 15 00 00 00
	00		 mov	 DWORD PTR _mapmusic, edx
$LN2@S_Start:

; 429  : 
; 430  : 	mus_paused = 0;

  00031	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mus_paused, 0

; 431  : 
; 432  : 	S_ChangeMusic(mapmusic & 2047, true);

  0003b	6a 01		 push	 1
  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapmusic
  00042	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _S_ChangeMusic
  0004d	83 c4 08	 add	 esp, 8

; 433  : 	nextcleanup = 15;

  00050	c7 05 00 00 00
	00 0f 00 00 00	 mov	 DWORD PTR _nextcleanup, 15 ; 0000000fH

; 434  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_S_Start ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_ClearSfx
_TEXT	SEGMENT
_i$ = -4						; size = 4
_S_ClearSfx PROC					; COMDAT

; 1112 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1113 : #ifndef DJGPPDOS
; 1114 : 	size_t i;
; 1115 : 	for (i = 1; i < NUMSFX; i++)

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00010	eb 09		 jmp	 SHORT $LN4@S_ClearSfx
$LN2@S_ClearSfx:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@S_ClearSfx:
  0001b	81 7d fc 63 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  00022	73 14		 jae	 SHORT $LN3@S_ClearSfx

; 1116 : 		I_FreeSfx(S_sfx + i);

  00024	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00028	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _I_FreeSfx
  00033	83 c4 04	 add	 esp, 4
  00036	eb da		 jmp	 SHORT $LN2@S_ClearSfx
$LN3@S_ClearSfx:

; 1117 : #endif
; 1118 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_S_ClearSfx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_StopSounds
_TEXT	SEGMENT
_cnum$ = -4						; size = 4
_S_StopSounds PROC					; COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 388  : 	INT32 cnum;
; 389  : 
; 390  : #ifdef HW3SOUND
; 391  : 	if (hws_mode != HWS_DEFAULT_MODE)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00010	74 08		 je	 SHORT $LN5@S_StopSoun

; 392  : 	{
; 393  : 		HW3S_StopSounds();

  00012	e8 00 00 00 00	 call	 _HW3S_StopSounds
  00017	90		 npad	 1

; 394  : 		return;

  00018	eb 3b		 jmp	 SHORT $LN3@S_StopSoun
$LN5@S_StopSoun:

; 395  : 	}
; 396  : #endif
; 397  : 
; 398  : 	// kill all playing sounds at start of level
; 399  : 	for (cnum = 0; cnum < numofchannels; cnum++)

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnum$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@S_StopSoun
$LN2@S_StopSoun:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 fc	 mov	 DWORD PTR _cnum$[ebp], eax
$LN4@S_StopSoun:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numofchannels
  00035	7d 1e		 jge	 SHORT $LN3@S_StopSoun

; 400  : 		if (channels[cnum].sfxinfo)

  00037	6b 45 fc 0c	 imul	 eax, DWORD PTR _cnum$[ebp], 12
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _channels
  00041	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00045	74 0c		 je	 SHORT $LN6@S_StopSoun

; 401  : 			S_StopChannel(cnum);

  00047	8b 45 fc	 mov	 eax, DWORD PTR _cnum$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _S_StopChannel
  00050	83 c4 04	 add	 esp, 4
$LN6@S_StopSoun:
  00053	eb ce		 jmp	 SHORT $LN2@S_StopSoun
$LN3@S_StopSoun:

; 402  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_S_StopSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_Init
_TEXT	SEGMENT
_i$ = -4						; size = 4
_sfxVolume$ = 8						; size = 4
_digMusicVolume$ = 12					; size = 4
_midiMusicVolume$ = 16					; size = 4
_S_Init	PROC						; COMDAT

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 322  : 	INT32 i;
; 323  : 
; 324  : 	if (dedicated)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00010	74 05		 je	 SHORT $LN8@S_Init

; 325  : 		return;

  00012	e9 f0 00 00 00	 jmp	 $LN9@S_Init
$LN8@S_Init:

; 326  : 
; 327  : 	S_SetSfxVolume(sfxVolume);

  00017	8b 45 08	 mov	 eax, DWORD PTR _sfxVolume$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _S_SetSfxVolume
  00020	83 c4 04	 add	 esp, 4

; 328  : 	S_SetDigMusicVolume(digMusicVolume);

  00023	8b 45 0c	 mov	 eax, DWORD PTR _digMusicVolume$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _S_SetDigMusicVolume
  0002c	83 c4 04	 add	 esp, 4

; 329  : 	S_SetMIDIMusicVolume(midiMusicVolume);

  0002f	8b 45 10	 mov	 eax, DWORD PTR _midiMusicVolume$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _S_SetMIDIMusicVolume
  00038	83 c4 04	 add	 esp, 4

; 330  : 
; 331  : 	SetChannelsNum();

  0003b	e8 00 00 00 00	 call	 _SetChannelsNum
  00040	90		 npad	 1

; 332  : 
; 333  : 	// no sounds are playing, and they are not mus_paused
; 334  : 	mus_paused = 0;

  00041	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _mus_paused, 0

; 335  : 
; 336  : 	// Note that sounds have not been cached (yet).
; 337  : 	for (i = 1; i < NUMSFX; i++)

  0004b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00052	eb 09		 jmp	 SHORT $LN4@S_Init
$LN2@S_Init:
  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@S_Init:
  0005d	81 7d fc 63 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  00064	7d 1e		 jge	 SHORT $LN3@S_Init

; 338  : 	{
; 339  : 		S_sfx[i].usefulness = -1; // for I_GetSfx()

  00066	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  0006a	c7 80 20 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _S_sfx[eax+32], -1

; 340  : 		S_sfx[i].lumpnum = LUMPERROR;

  00074	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00078	c7 80 24 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _S_sfx[eax+36], -1

; 341  : 	}

  00082	eb d0		 jmp	 SHORT $LN2@S_Init
$LN3@S_Init:

; 342  : 
; 343  : 	// precache sounds if requested by cmdline, or precachesound var true
; 344  : 	if (!nosound && (M_CheckParm("-precachesound") || precachesound.value))

  00084	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  0008b	75 7a		 jne	 SHORT $LN9@S_Init
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BNEBKMJG@?9precachesound@
  00092	e8 00 00 00 00	 call	 _M_CheckParm
  00097	83 c4 04	 add	 esp, 4
  0009a	85 c0		 test	 eax, eax
  0009c	75 09		 jne	 SHORT $LN10@S_Init
  0009e	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _precachesound+20, 0
  000a5	74 60		 je	 SHORT $LN9@S_Init
$LN10@S_Init:

; 345  : 	{
; 346  : 		// Initialize external data (all sounds) at start, keep static.
; 347  : 		CONS_Printf("Loading sounds... ");

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MLHHDKNE@Loading?5sounds?4?4?4?5@
  000ac	e8 00 00 00 00	 call	 _CONS_Printf
  000b1	83 c4 04	 add	 esp, 4

; 348  : 
; 349  : 		for (i = 1; i < NUMSFX; i++)

  000b4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000bb	eb 09		 jmp	 SHORT $LN7@S_Init
$LN5@S_Init:
  000bd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@S_Init:
  000c6	81 7d fc 63 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  000cd	7d 2b		 jge	 SHORT $LN6@S_Init

; 350  : 			if (S_sfx[i].name)

  000cf	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  000d3	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _S_sfx[eax], 0
  000da	74 1c		 je	 SHORT $LN11@S_Init

; 351  : 				S_sfx[i].data = I_GetSfx(&S_sfx[i]);

  000dc	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  000e0	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _I_GetSfx
  000eb	83 c4 04	 add	 esp, 4
  000ee	6b 4d fc 2c	 imul	 ecx, DWORD PTR _i$[ebp], 44
  000f2	89 81 14 00 00
	00		 mov	 DWORD PTR _S_sfx[ecx+20], eax
$LN11@S_Init:
  000f8	eb c3		 jmp	 SHORT $LN5@S_Init
$LN6@S_Init:

; 352  : 
; 353  : 		CONS_Printf(" pre-cached all sound data\n");

  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BPMIPJGB@?5pre?9cached?5all?5sound?5data?6@
  000ff	e8 00 00 00 00	 call	 _CONS_Printf
  00104	83 c4 04	 add	 esp, 4
$LN9@S_Init:

; 354  : 	}
; 355  : }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_S_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\s_sound.c
;	COMDAT _S_RegisterSoundStuff
_TEXT	SEGMENT
_S_RegisterSoundStuff PROC				; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 240  : 	if (dedicated)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00010	74 0c		 je	 SHORT $LN2@S_Register

; 241  : 	{
; 242  : 		nosound = true;

  00012	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nosound, 1

; 243  : 		return;

  0001c	eb 34		 jmp	 SHORT $LN1@S_Register
$LN2@S_Register:

; 244  : 	}
; 245  : 
; 246  : 	CV_RegisterVar(&stereoreverse);

  0001e	68 00 00 00 00	 push	 OFFSET _stereoreverse
  00023	e8 00 00 00 00	 call	 _CV_RegisterVar
  00028	83 c4 04	 add	 esp, 4

; 247  : 	CV_RegisterVar(&precachesound);

  0002b	68 00 00 00 00	 push	 OFFSET _precachesound
  00030	e8 00 00 00 00	 call	 _CV_RegisterVar
  00035	83 c4 04	 add	 esp, 4

; 248  : 
; 249  : #ifdef SNDSERV
; 250  : 	CV_RegisterVar(&sndserver_cmd);
; 251  : 	CV_RegisterVar(&sndserver_arg);
; 252  : #endif
; 253  : #ifdef MUSSERV
; 254  : 	CV_RegisterVar(&musserver_cmd);
; 255  : 	CV_RegisterVar(&musserver_arg);
; 256  : #endif
; 257  : 	CV_RegisterVar(&surround);

  00038	68 00 00 00 00	 push	 OFFSET _surround
  0003d	e8 00 00 00 00	 call	 _CV_RegisterVar
  00042	83 c4 04	 add	 esp, 4

; 258  : 	CV_RegisterVar(&cv_samplerate);

  00045	68 00 00 00 00	 push	 OFFSET _cv_samplerate
  0004a	e8 00 00 00 00	 call	 _CV_RegisterVar
  0004f	83 c4 04	 add	 esp, 4
$LN1@S_Register:

; 259  : 
; 260  : #if defined (macintosh) && !defined (SDL) // mp3 playlist stuff
; 261  : 	{
; 262  : 		INT32 i;
; 263  : 		for (i = 0; i < PLAYLIST_LENGTH; i++)
; 264  : 		{
; 265  : 			user_songs[i].name = malloc(7);
; 266  : 			if (!user_songs[i].name)
; 267  : 				I_Error("No more free memory for mp3 playlist");
; 268  : 			sprintf(user_songs[i].name, "song%d%d",i/10,i%10);
; 269  : 			user_songs[i].defaultvalue = malloc(sizeof (char));
; 270  : 			if (user_songs[i].defaultvalue)
; 271  : 				I_Error("No more free memory for blank mp3 playerlist");
; 272  : 			*user_songs[i].defaultvalue = 0;
; 273  : 			user_songs[i].flags = CV_SAVE;
; 274  : 			user_songs[i].PossibleValue = NULL;
; 275  : 			CV_RegisterVar(&user_songs[i]);
; 276  : 		}
; 277  : 		CV_RegisterVar(&play_mode);
; 278  : 	}
; 279  : #endif
; 280  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_S_RegisterSoundStuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
