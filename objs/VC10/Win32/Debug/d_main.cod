; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\d_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_devparm
PUBLIC	_nomidimusic
PUBLIC	_nosound
PUBLIC	_nodigimusic
PUBLIC	_music_disabled
PUBLIC	_sound_disabled
PUBLIC	_digital_disabled
PUBLIC	_lastdraw
PUBLIC	_postimgtype
PUBLIC	_debugload
PUBLIC	_wipegamestate
PUBLIC	_singletics
PUBLIC	_dedicated
PUBLIC	_srb2home
PUBLIC	_usehome
PUBLIC	_pandf
PUBLIC	_srb2path
PUBLIC	??_C@_07DFOELFIN@MAP1PIC@			; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs@			; `string'
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_devparm DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_events:BYTE:0800H
COMM	_eventhead:DWORD
COMM	_eventtail:DWORD
_DATA	ENDS
_BSS	SEGMENT
_nomidimusic DD	01H DUP (?)
_nosound DD	01H DUP (?)
_nodigimusic DD	01H DUP (?)
_music_disabled DD 01H DUP (?)
_sound_disabled DD 01H DUP (?)
_digital_disabled DD 01H DUP (?)
_lastdraw DD	01H DUP (?)
_postimgtype DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_postimgparam:DWORD
_DATA	ENDS
_BSS	SEGMENT
_debugload DD	01H DUP (?)
_singletics DD	01H DUP (?)
_dedicated DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_supdate:DWORD
COMM	_advancedemo:DWORD
COMM	_rendergametic:DWORD
_DATA	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs@ DB '%s\%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFOELFIN@MAP1PIC@
CONST	SEGMENT
??_C@_07DFOELFIN@MAP1PIC@ DB 'MAP1PIC', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_wipegamestate DD 03H
_usehome DD	01H
_srb2home DB	'.', 00H
	ORG $+254
_pandf	DD	FLAT:??_C@_05BMGBEOOC@?$CFs?2?$CFs@
	ORG $+4
_srb2path DB	'.', 00H
	ORG $+254
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	___snprintf
PUBLIC	_D_SRB2Loop
PUBLIC	_D_SRB2Main
PUBLIC	_D_PostEvent
PUBLIC	_D_PostEvent_end
PUBLIC	_D_ProcessEvents
PUBLIC	_D_Home
PUBLIC	_D_PageTicker
PUBLIC	_D_PageDrawer
PUBLIC	_D_AdvanceDemo
PUBLIC	_D_StartTitle
PUBLIC	??_C@_07ILOCMDMD@M_PAUSE@			; `string'
PUBLIC	??_C@_0L@OHGNJCAA@get?5?$CFd?5b?1s@		; `string'
PUBLIC	??_C@_0M@KIKHLGMA@send?5?$CFd?5b?1s@		; `string'
PUBLIC	??_C@_0BA@IHEGKMH@GameMiss?5?$CF?42f?$CF?$CF@	; `string'
PUBLIC	??_C@_0P@OPEGPGMK@SysMiss?5?$CF?42f?$CF?$CF@	; `string'
PUBLIC	??_C@_0BI@KGOBCB@exec?5?$CC?$CFs?2adedserv?4cfg?$CC?6@ ; `string'
PUBLIC	??_C@_0CB@HJBEFKFL@exec?5?$CC?$CFs?2autoexec?4cfg?$CC?5?9noerror@ ; `string'
PUBLIC	??_C@_07IAHMHEDC@?9voodoo@			; `string'
PUBLIC	??_C@_0BL@IEEBAO@gr_voodoocompatibility?5on?6@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0L@CMHOPIGK@screenshot@			; `string'
PUBLIC	??_C@_07NKFJBOH@map?5?$CFs?6@			; `string'
PUBLIC	??_C@_07FLMOFAHC@PLAYPAL@			; `string'
PUBLIC	??_C@_0CC@DPFCLJJJ@No?5more?5free?5memory?5to?5AddFile?5@ ; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_0CC@JMBCPJOM@No?5more?5free?5memory?5to?5look?5in?5@ ; `string'
PUBLIC	??_C@_0O@IGIHOCK@?$CFs?2config?4cfg@		; `string'
PUBLIC	??_C@_0EC@DKCNNDKK@SRB2?4SRB?1SRB2?4WAD?5not?5found?$CB?5Ex@ ; `string'
PUBLIC	??_C@_09KDGAJFC@zones?4dta@			; `string'
PUBLIC	??_C@_09DPFJGNGH@rings?4wpn@			; `string'
PUBLIC	??_C@_09DADOBKL@drill?4dta@			; `string'
PUBLIC	??_C@_08FHJDCGJG@soar?4dta@			; `string'
PUBLIC	??_C@_0CP@FOCILDPI@File?5?$CFs?5has?5been?5modified?5with?5@ ; `string'
PUBLIC	??_C@_06OHOHKFPP@?9debug@			; `string'
PUBLIC	??_C@_0BD@HDCCHDPP@Sonic?5Robo?5Blast?52@	; `string'
PUBLIC	??_C@_0N@KGDKGFOH@SRB2?5v2?40?47?6@		; `string'
PUBLIC	??_C@_0M@PONKIHIH@dconfig?4cfg@			; `string'
PUBLIC	??_C@_0L@MFNMKHHD@config?4cfg@			; `string'
PUBLIC	??_C@_07FEOAPHKJ@?$CFs?2srb2@			; `string'
PUBLIC	??_C@_0M@NLIKGJPG@?$CFs?2DOWNLOAD@		; `string'
PUBLIC	??_C@_0P@OMKANKAO@?$CFs?2dconfig?4cfg@		; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_09GEFBAANH@?9password@			; `string'
PUBLIC	??_C@_08FABEHMEN@?9connect@			; `string'
PUBLIC	??_C@_05PMBENPHG@?9file@			; `string'
PUBLIC	??_C@_07ODEEFNBO@?9server@			; `string'
PUBLIC	??_C@_05EFCNCBMF@?9warp@			; `string'
PUBLIC	??_C@_0CH@DHJKLIKF@A?5WAD?5file?5was?5not?5found?5or?5not@ ; `string'
PUBLIC	??_C@_0CB@DKMKKGPC@1f698dd35bcedb04631568a84a97d72@ ; `string'
PUBLIC	??_C@_0CB@LMDFPOEK@86ae3f9179c64358d1c88060e41bd41@ ; `string'
PUBLIC	??_C@_0CB@FMLIHMDO@f699d4702b9b505db621e5ad5af4f35@ ; `string'
PUBLIC	??_C@_0CB@FBLENMKB@dfbbc38080485c70a84a57bb734ceee@ ; `string'
PUBLIC	??_C@_0CB@HIPAAGLD@1ea958e2aee87b6995226a120ba3eaa@ ; `string'
PUBLIC	??_C@_0CB@NMMBBOPJ@8f702416c15060cd3c53c71b9111691@ ; `string'
PUBLIC	??_C@_0CB@OKALEOH@6b1cf9b41e41a46ac58606dc6e7c9e0@ ; `string'
PUBLIC	??_C@_0CB@IBDPGNAC@8d080c050ecf03691562aa7b60156fe@ ; `string'
PUBLIC	??_C@_0L@JGOMHMOK@?9resetdata@			; `string'
PUBLIC	??_C@_06GOJMKCFL@?9usecd@			; `string'
PUBLIC	??_C@_0P@CBBFLDFP@?9nodownloading@		; `string'
PUBLIC	??_C@_0P@CACMCMEM@downloading?50?6@		; `string'
PUBLIC	??_C@_08FLDKIHPE@?9nosound@			; `string'
PUBLIC	??_C@_08CHNDLEKC@?9nomusic@			; `string'
PUBLIC	??_C@_0N@GNMEOENE@?9nomidimusic@		; `string'
PUBLIC	??_C@_0M@FFMEKMJE@?9nodigmusic@			; `string'
PUBLIC	??_C@_0BA@PIODIGNO@?9internetserver@		; `string'
PUBLIC	??_C@_07DAFDPAKP@?9record@			; `string'
PUBLIC	??_C@_08FEEPADEA@?9timetic@			; `string'
PUBLIC	??_C@_02IAAGKKDJ@On@				; `string'
PUBLIC	??_C@_09BCPNILDH@?9playdemo@			; `string'
PUBLIC	??_C@_09LEEFHMML@?9timedemo@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_04FJOMPALJ@?4lmp@				; `string'
PUBLIC	??_C@_0O@BJJAGKNO@?9ultimatemode@		; `string'
PUBLIC	??_C@_08CDAOAFMH@?$CLconnect@			; `string'
PUBLIC	??_C@_09GGNDLOMG@?9gametype@			; `string'
PUBLIC	??_C@_04CAKKOBMI@?$CLmap@			; `string'
PUBLIC	??_C@_08PBIHNGBH@TITLESKY@			; `string'
PUBLIC	??_C@_05GHINFEPM@?9home@			; `string'
PUBLIC	??_C@_04GHGFPGNC@HOME@				; `string'
PUBLIC	??_C@_07FMLNDKFM@APPDATA@			; `string'
PUBLIC	??_C@_04OALKLBNF@srb2@				; `string'
PUBLIC	??_C@_0BB@PHPDGCBL@?$CFs?2?$CFs?2config?4cfg@	; `string'
PUBLIC	??_C@_0M@DPNKMMOG@USERPROFILE@			; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_getcwd:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__time64:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_stricmp:PROC
EXTRN	_strlwr:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	_strlcpy:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_setbuf:PROC
EXTRN	_setvbuf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_AM_Drawer:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_COM_Init:PROC
EXTRN	_CV_ClearChangedFlags:PROC
EXTRN	_CV_Set:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_CON_Init:PROC
EXTRN	_CON_Responder:PROC
EXTRN	_CON_Drawer:PROC
EXTRN	_CONS_Error:PROC
EXTRN	_CON_ToggleOff:PROC
EXTRN	_Net_GetNetStat:PROC
EXTRN	_D_CheckNetGame:PROC
EXTRN	_F_GameEndDrawer:PROC
EXTRN	_F_IntroDrawer:PROC
EXTRN	_F_TitleScreenDrawer:PROC
EXTRN	_F_GameEvaluationDrawer:PROC
EXTRN	_F_CreditDrawer:PROC
EXTRN	_F_CutsceneDrawer:PROC
EXTRN	_F_StartIntro:PROC
EXTRN	_F_StartTitleScreen:PROC
EXTRN	_F_WipeStartScreen:PROC
EXTRN	_F_WipeEndScreen:PROC
EXTRN	_F_RunWipe:PROC
EXTRN	_P_PatchInfoTables:PROC
EXTRN	_P_BackupTables:PROC
EXTRN	_D_RegisterServerCommands:PROC
EXTRN	_D_RegisterClientCommands:PROC
EXTRN	_Command_ExitGame_f:PROC
EXTRN	_D_GameTypeChanged:PROC
EXTRN	_D_MapChange:PROC
EXTRN	_NetUpdate:PROC
EXTRN	_TryRunTics:PROC
EXTRN	_G_BuildMapName:PROC
EXTRN	_G_DeferedPlayDemo:PROC
EXTRN	_G_RecordDemo:PROC
EXTRN	_G_BeginRecording:PROC
EXTRN	_G_TimeDemo:PROC
EXTRN	_G_Responder:PROC
EXTRN	_G_ClearExitGameFlag:PROC
EXTRN	_G_GetExitGameFlag:PROC
EXTRN	_G_LoadGameData:PROC
EXTRN	_G_LoadGameSettings:PROC
EXTRN	_G_SetGamestate:PROC
EXTRN	_SCR_SetMode:PROC
EXTRN	_SCR_Recalc:PROC
EXTRN	_SCR_CheckDefaultMode:PROC
EXTRN	_SCR_Startup:PROC
EXTRN	_W_InitMultipleFiles:PROC
EXTRN	_W_CachePatchName:PROC
EXTRN	_W_VerifyFileMD5:PROC
EXTRN	_W_VerifyNMUSlumps:PROC
EXTRN	_HU_Init:PROC
EXTRN	_HU_Drawer:PROC
EXTRN	_HU_Erase:PROC
EXTRN	_I_StartupSound:PROC
EXTRN	_I_InitMusic:PROC
EXTRN	_I_InitCD:PROC
EXTRN	_I_UpdateCD:PROC
EXTRN	_I_GetTime:PROC
EXTRN	_I_Sleep:PROC
EXTRN	_I_Quit:PROC
EXTRN	_I_StartupKeyboard:PROC
EXTRN	_I_StartupTimer:PROC
EXTRN	_I_mkdir:PROC
EXTRN	_I_GetEnv:PROC
EXTRN	_I_RegisterSysCommands:PROC
EXTRN	_I_StartupGraphics:PROC
EXTRN	_I_UpdateNoBlit:PROC
EXTRN	_I_FinishUpdate:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_PushSpecialParameters:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_M_FindResponseFile:PROC
EXTRN	_M_Responder:PROC
EXTRN	_M_Drawer:PROC
EXTRN	_M_Init:PROC
EXTRN	_FIL_ReadFileOK:PROC
EXTRN	_FIL_FileOK:PROC
EXTRN	_FIL_DefaultExtension:PROC
EXTRN	_M_DoScreenShot:PROC
EXTRN	_M_FirstLoadConfig:PROC
EXTRN	_strcatbf:PROC
EXTRN	_P_SetupLevel:PROC
EXTRN	_P_InitMapHeaders:PROC
EXTRN	_P_ClearMapHeaderInfo:PROC
EXTRN	_R_Init:PROC
EXTRN	_R_ExecuteSetViewSize:PROC
EXTRN	_R_RenderPlayerView:PROC
EXTRN	_R_RegisterEngineStuff:PROC
EXTRN	_S_RegisterSoundStuff:PROC
EXTRN	_S_Init:PROC
EXTRN	_S_UpdateSounds:PROC
EXTRN	_ST_Drawer:PROC
EXTRN	_ST_Init:PROC
EXTRN	_V_SetPalette:PROC
EXTRN	_V_SetPaletteLump:PROC
EXTRN	_V_DrawScaledPatch:PROC
EXTRN	_V_DrawFill:PROC
EXTRN	_V_DrawString:PROC
EXTRN	_V_StringWidth:PROC
EXTRN	_V_DoPostProcessor:PROC
EXTRN	_VID_BlitLinearScreen:PROC
EXTRN	_Z_Init:PROC
EXTRN	_cht_Responder:PROC
EXTRN	_cht_Init:PROC
EXTRN	_Y_IntermissionDrawer:PROC
EXTRN	_P_MoveChaseCamera:PROC
EXTRN	_HWR_RenderPlayerView:PROC
EXTRN	_HWR_SetPaletteColor:PROC
EXTRN	_HWR_PrepFadeToBlack:PROC
EXTRN	_I_DoStartupMouse:PROC
EXTRN	_HW3S_BeginFrameUpdate:PROC
EXTRN	_HW3S_EndFrameUpdate:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_ultimatemode:BYTE
EXTRN	_gameaction:DWORD
EXTRN	_M_Memcpy:DWORD
EXTRN	_compdate:DWORD
EXTRN	_comptime:DWORD
EXTRN	_automapactive:DWORD
EXTRN	_savegamename:BYTE
EXTRN	_text:BYTE
EXTRN	_con_startup:DWORD
EXTRN	_getbps:DWORD
EXTRN	_sendbps:DWORD
EXTRN	_lostpercent:DWORD
EXTRN	_gamelostpercent:DWORD
EXTRN	_WipeInAction:DWORD
EXTRN	_gamemap:WORD
EXTRN	_modifiedgame:DWORD
EXTRN	_mainwads:WORD
EXTRN	_savemoddata:DWORD
EXTRN	_netgame:DWORD
EXTRN	_gametype:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_menuactive:DWORD
EXTRN	_paused:BYTE
EXTRN	_nodrawers:DWORD
EXTRN	_viewwindowx:DWORD
EXTRN	_viewwindowy:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_spstage_start:WORD
EXTRN	_cutscenes:BYTE
EXTRN	_mapheaderinfo:BYTE
EXTRN	_gametic:DWORD
EXTRN	_cv_tagtype:BYTE
EXTRN	_cv_matchtype:BYTE
EXTRN	_cv_netstat:BYTE
EXTRN	_cv_racetype:BYTE
EXTRN	_server:DWORD
EXTRN	_adminpassword:BYTE
EXTRN	_cv_timetic:BYTE
EXTRN	_players:BYTE
EXTRN	_demorecording:DWORD
EXTRN	_singledemo:DWORD
EXTRN	_levelstarttic:DWORD
EXTRN	_vid:BYTE
EXTRN	_setmodeneeded:DWORD
EXTRN	_scr_borderpatch:DWORD
EXTRN	_cv_renderview:BYTE
EXTRN	_playerdeadview:DWORD
EXTRN	_rendermode:DWORD
EXTRN	_gametype_cons_t:BYTE
EXTRN	_moviemode:DWORD
EXTRN	_takescreenshot:DWORD
EXTRN	_configfile:BYTE
EXTRN	_savedata:BYTE
EXTRN	_viewheight:DWORD
EXTRN	_setsizeneeded:DWORD
EXTRN	_ylookup:BYTE
EXTRN	_ylookup1:BYTE
EXTRN	_ylookup2:BYTE
EXTRN	_topleft:DWORD
EXTRN	_cv_soundvolume:BYTE
EXTRN	_cv_digmusicvolume:BYTE
EXTRN	_cv_midimusicvolume:BYTE
EXTRN	_screens:BYTE
EXTRN	_downloaddir:BYTE
EXTRN	_camera:BYTE
EXTRN	_camera2:BYTE
EXTRN	_cv_internetserver:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_pagetic DD	01H DUP (?)
_startupwadfiles DD 030H DUP (?)
?menuactivestate@?1??D_Display@@9@9 DD 01H DUP (?)	; `D_Display'::`2'::menuactivestate
?wipe@?1??D_Display@@9@9 DD 01H DUP (?)			; `D_Display'::`2'::wipe
_BSS	ENDS
;	COMDAT ??_C@_0M@DPNKMMOG@USERPROFILE@
CONST	SEGMENT
??_C@_0M@DPNKMMOG@USERPROFILE@ DB 'USERPROFILE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHPDGCBL@?$CFs?2?$CFs?2config?4cfg@
CONST	SEGMENT
??_C@_0BB@PHPDGCBL@?$CFs?2?$CFs?2config?4cfg@ DB '%s\%s\config.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OALKLBNF@srb2@
CONST	SEGMENT
??_C@_04OALKLBNF@srb2@ DB 'srb2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FMLNDKFM@APPDATA@
CONST	SEGMENT
??_C@_07FMLNDKFM@APPDATA@ DB 'APPDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHGFPGNC@HOME@
CONST	SEGMENT
??_C@_04GHGFPGNC@HOME@ DB 'HOME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GHINFEPM@?9home@
CONST	SEGMENT
??_C@_05GHINFEPM@?9home@ DB '-home', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PBIHNGBH@TITLESKY@
CONST	SEGMENT
??_C@_08PBIHNGBH@TITLESKY@ DB 'TITLESKY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAKKOBMI@?$CLmap@
CONST	SEGMENT
??_C@_04CAKKOBMI@?$CLmap@ DB '+map', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGNDLOMG@?9gametype@
CONST	SEGMENT
??_C@_09GGNDLOMG@?9gametype@ DB '-gametype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CDAOAFMH@?$CLconnect@
CONST	SEGMENT
??_C@_08CDAOAFMH@?$CLconnect@ DB '+connect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BJJAGKNO@?9ultimatemode@
CONST	SEGMENT
??_C@_0O@BJJAGKNO@?9ultimatemode@ DB '-ultimatemode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJOMPALJ@?4lmp@
CONST	SEGMENT
??_C@_04FJOMPALJ@?4lmp@ DB '.lmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09LEEFHMML@?9timedemo@
CONST	SEGMENT
??_C@_09LEEFHMML@?9timedemo@ DB '-timedemo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCPNILDH@?9playdemo@
CONST	SEGMENT
??_C@_09BCPNILDH@?9playdemo@ DB '-playdemo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FEEPADEA@?9timetic@
CONST	SEGMENT
??_C@_08FEEPADEA@?9timetic@ DB '-timetic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DAFDPAKP@?9record@
CONST	SEGMENT
??_C@_07DAFDPAKP@?9record@ DB '-record', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIODIGNO@?9internetserver@
CONST	SEGMENT
??_C@_0BA@PIODIGNO@?9internetserver@ DB '-internetserver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FFMEKMJE@?9nodigmusic@
CONST	SEGMENT
??_C@_0M@FFMEKMJE@?9nodigmusic@ DB '-nodigmusic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GNMEOENE@?9nomidimusic@
CONST	SEGMENT
??_C@_0N@GNMEOENE@?9nomidimusic@ DB '-nomidimusic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHNDLEKC@?9nomusic@
CONST	SEGMENT
??_C@_08CHNDLEKC@?9nomusic@ DB '-nomusic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLDKIHPE@?9nosound@
CONST	SEGMENT
??_C@_08FLDKIHPE@?9nosound@ DB '-nosound', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CACMCMEM@downloading?50?6@
CONST	SEGMENT
??_C@_0P@CACMCMEM@downloading?50?6@ DB 'downloading 0', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CBBFLDFP@?9nodownloading@
CONST	SEGMENT
??_C@_0P@CBBFLDFP@?9nodownloading@ DB '-nodownloading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GOJMKCFL@?9usecd@
CONST	SEGMENT
??_C@_06GOJMKCFL@?9usecd@ DB '-usecd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JGOMHMOK@?9resetdata@
CONST	SEGMENT
??_C@_0L@JGOMHMOK@?9resetdata@ DB '-resetdata', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IBDPGNAC@8d080c050ecf03691562aa7b60156fe@
CONST	SEGMENT
??_C@_0CB@IBDPGNAC@8d080c050ecf03691562aa7b60156fe@ DB '8d080c050ecf03691'
	DB	'562aa7b60156fec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OKALEOH@6b1cf9b41e41a46ac58606dc6e7c9e0@
CONST	SEGMENT
??_C@_0CB@OKALEOH@6b1cf9b41e41a46ac58606dc6e7c9e0@ DB '6b1cf9b41e41a46ac5'
	DB	'8606dc6e7c9e05', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NMMBBOPJ@8f702416c15060cd3c53c71b9111691@
CONST	SEGMENT
??_C@_0CB@NMMBBOPJ@8f702416c15060cd3c53c71b9111691@ DB '8f702416c15060cd3'
	DB	'c53c71b91116914', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIPAAGLD@1ea958e2aee87b6995226a120ba3eaa@
CONST	SEGMENT
??_C@_0CB@HIPAAGLD@1ea958e2aee87b6995226a120ba3eaa@ DB '1ea958e2aee87b699'
	DB	'5226a120ba3eaac', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FBLENMKB@dfbbc38080485c70a84a57bb734ceee@
CONST	SEGMENT
??_C@_0CB@FBLENMKB@dfbbc38080485c70a84a57bb734ceee@ DB 'dfbbc38080485c70a'
	DB	'84a57bb734ceee9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FMLIHMDO@f699d4702b9b505db621e5ad5af4f35@
CONST	SEGMENT
??_C@_0CB@FMLIHMDO@f699d4702b9b505db621e5ad5af4f35@ DB 'f699d4702b9b505db'
	DB	'621e5ad5af4f352', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LMDFPOEK@86ae3f9179c64358d1c88060e41bd41@
CONST	SEGMENT
??_C@_0CB@LMDFPOEK@86ae3f9179c64358d1c88060e41bd41@ DB '86ae3f9179c64358d'
	DB	'1c88060e41bd415', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DKMKKGPC@1f698dd35bcedb04631568a84a97d72@
CONST	SEGMENT
??_C@_0CB@DKMKKGPC@1f698dd35bcedb04631568a84a97d72@ DB '1f698dd35bcedb046'
	DB	'31568a84a97d72b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DHJKLIKF@A?5WAD?5file?5was?5not?5found?5or?5not@
CONST	SEGMENT
??_C@_0CH@DHJKLIKF@A?5WAD?5file?5was?5not?5found?5or?5not@ DB 'A WAD file'
	DB	' was not found or not valid', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFCNCBMF@?9warp@
CONST	SEGMENT
??_C@_05EFCNCBMF@?9warp@ DB '-warp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODEEFNBO@?9server@
CONST	SEGMENT
??_C@_07ODEEFNBO@?9server@ DB '-server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMBENPHG@?9file@
CONST	SEGMENT
??_C@_05PMBENPHG@?9file@ DB '-file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FABEHMEN@?9connect@
CONST	SEGMENT
??_C@_08FABEHMEN@?9connect@ DB '-connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GEFBAANH@?9password@
CONST	SEGMENT
??_C@_09GEFBAANH@?9password@ DB '-password', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OMKANKAO@?$CFs?2dconfig?4cfg@
CONST	SEGMENT
??_C@_0P@OMKANKAO@?$CFs?2dconfig?4cfg@ DB '%s\dconfig.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLIKGJPG@?$CFs?2DOWNLOAD@
CONST	SEGMENT
??_C@_0M@NLIKGJPG@?$CFs?2DOWNLOAD@ DB '%s\DOWNLOAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FEOAPHKJ@?$CFs?2srb2@
CONST	SEGMENT
??_C@_07FEOAPHKJ@?$CFs?2srb2@ DB '%s\srb2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFNMKHHD@config?4cfg@
CONST	SEGMENT
??_C@_0L@MFNMKHHD@config?4cfg@ DB 'config.cfg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PONKIHIH@dconfig?4cfg@
CONST	SEGMENT
??_C@_0M@PONKIHIH@dconfig?4cfg@ DB 'dconfig.cfg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KGDKGFOH@SRB2?5v2?40?47?6@
CONST	SEGMENT
??_C@_0N@KGDKGFOH@SRB2?5v2?40?47?6@ DB 'SRB2 v2.0.7', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HDCCHDPP@Sonic?5Robo?5Blast?52@
CONST	SEGMENT
??_C@_0BD@HDCCHDPP@Sonic?5Robo?5Blast?52@ DB 'Sonic Robo Blast 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHOHKFPP@?9debug@
CONST	SEGMENT
??_C@_06OHOHKFPP@?9debug@ DB '-debug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FOCILDPI@File?5?$CFs?5has?5been?5modified?5with?5@
CONST	SEGMENT
??_C@_0CP@FOCILDPI@File?5?$CFs?5has?5been?5modified?5with?5@ DB 'File %s '
	DB	'has been modified with non-music lumps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHJDCGJG@soar?4dta@
CONST	SEGMENT
??_C@_08FHJDCGJG@soar?4dta@ DB 'soar.dta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DADOBKL@drill?4dta@
CONST	SEGMENT
??_C@_09DADOBKL@drill?4dta@ DB 'drill.dta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPFJGNGH@rings?4wpn@
CONST	SEGMENT
??_C@_09DPFJGNGH@rings?4wpn@ DB 'rings.wpn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDGAJFC@zones?4dta@
CONST	SEGMENT
??_C@_09KDGAJFC@zones?4dta@ DB 'zones.dta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DKCNNDKK@SRB2?4SRB?1SRB2?4WAD?5not?5found?$CB?5Ex@
CONST	SEGMENT
??_C@_0EC@DKCNNDKK@SRB2?4SRB?1SRB2?4WAD?5not?5found?$CB?5Ex@ DB 'SRB2.SRB'
	DB	'/SRB2.WAD not found! Expected in %s, ss files: %s and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGIHOCK@?$CFs?2config?4cfg@
CONST	SEGMENT
??_C@_0O@IGIHOCK@?$CFs?2config?4cfg@ DB '%s\config.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMBCPJOM@No?5more?5free?5memory?5to?5look?5in?5@
CONST	SEGMENT
??_C@_0CC@JMBCPJOM@No?5more?5free?5memory?5to?5look?5in?5@ DB 'No more fr'
	DB	'ee memory to look in %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DPFCLJJJ@No?5more?5free?5memory?5to?5AddFile?5@
CONST	SEGMENT
??_C@_0CC@DPFCLJJJ@No?5more?5free?5memory?5to?5AddFile?5@ DB 'No more fre'
	DB	'e memory to AddFile %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLMOFAHC@PLAYPAL@
CONST	SEGMENT
??_C@_07FLMOFAHC@PLAYPAL@ DB 'PLAYPAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NKFJBOH@map?5?$CFs?6@
CONST	SEGMENT
??_C@_07NKFJBOH@map?5?$CFs?6@ DB 'map %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMHOPIGK@screenshot@
CONST	SEGMENT
??_C@_0L@CMHOPIGK@screenshot@ DB 'screenshot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IEEBAO@gr_voodoocompatibility?5on?6@
CONST	SEGMENT
??_C@_0BL@IEEBAO@gr_voodoocompatibility?5on?6@ DB 'gr_voodoocompatibility'
	DB	' on', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07IAHMHEDC@?9voodoo@
CONST	SEGMENT
??_C@_07IAHMHEDC@?9voodoo@ DB '-voodoo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HJBEFKFL@exec?5?$CC?$CFs?2autoexec?4cfg?$CC?5?9noerror@
CONST	SEGMENT
??_C@_0CB@HJBEFKFL@exec?5?$CC?$CFs?2autoexec?4cfg?$CC?5?9noerror@ DB 'exe'
	DB	'c "%s\autoexec.cfg" -noerror', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KGOBCB@exec?5?$CC?$CFs?2adedserv?4cfg?$CC?6@
CONST	SEGMENT
??_C@_0BI@KGOBCB@exec?5?$CC?$CFs?2adedserv?4cfg?$CC?6@ DB 'exec "%s\adeds'
	DB	'erv.cfg"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OPEGPGMK@SysMiss?5?$CF?42f?$CF?$CF@
CONST	SEGMENT
??_C@_0P@OPEGPGMK@SysMiss?5?$CF?42f?$CF?$CF@ DB 'SysMiss %.2f%%', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IHEGKMH@GameMiss?5?$CF?42f?$CF?$CF@
CONST	SEGMENT
??_C@_0BA@IHEGKMH@GameMiss?5?$CF?42f?$CF?$CF@ DB 'GameMiss %.2f%%', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KIKHLGMA@send?5?$CFd?5b?1s@
CONST	SEGMENT
??_C@_0M@KIKHLGMA@send?5?$CFd?5b?1s@ DB 'send %d b/s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OHGNJCAA@get?5?$CFd?5b?1s@
CONST	SEGMENT
??_C@_0L@OHGNJCAA@get?5?$CFd?5b?1s@ DB 'get %d b/s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ILOCMDMD@M_PAUSE@
CONST	SEGMENT
??_C@_07ILOCMDMD@M_PAUSE@ DB 'M_PAUSE', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_pagename DD	FLAT:??_C@_07DFOELFIN@MAP1PIC@
?oldgamestate@?1??D_Display@@9@9 DD 0ffffffffH		; `D_Display'::`2'::oldgamestate
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0168H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	07cdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0121H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0c3dH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_InitCutsceneInfo
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_D_InitCutsceneInfo PROC				; COMDAT

; 924  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 925  : 	INT32 i,j;
; 926  : 
; 927  : 	for (i = 0; i < 128; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@D_InitCuts
$LN2@D_InitCuts:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@D_InitCuts:
  0001b	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 128	; 00000080H
  00022	7d 38		 jge	 SHORT $LN3@D_InitCuts

; 928  : 		for (j = 0; j < 128; j++)

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN7@D_InitCuts
$LN5@D_InitCuts:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@D_InitCuts:
  00036	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _j$[ebp], 128	; 00000080H
  0003d	7d 1b		 jge	 SHORT $LN6@D_InitCuts

; 929  : 			cutscenes[i].scene[j].text = NULL;

  0003f	69 45 fc 04 52
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 20996
  00046	69 4d f8 a4 00
	00 00		 imul	 ecx, DWORD PTR _j$[ebp], 164
  0004d	c7 84 08 64 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _cutscenes[eax+ecx+100], 0
  00058	eb d3		 jmp	 SHORT $LN5@D_InitCuts
$LN6@D_InitCuts:
  0005a	eb b6		 jmp	 SHORT $LN2@D_InitCuts
$LN3@D_InitCuts:

; 930  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_D_InitCutsceneInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_MakeTitleString
_TEXT	SEGMENT
tv79 = -172						; size = 4
tv85 = -172						; size = 4
$T1 = -168						; size = 4
_i$ = -100						; size = 4
_u$ = -96						; size = 4
_t$ = -92						; size = 4
_temp$ = -88						; size = 82
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_D_MakeTitleString PROC					; COMDAT

; 900  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 901  : 	char temp[82];
; 902  : 	char *t;
; 903  : 	const char *u;
; 904  : 	INT32 i;
; 905  : 
; 906  : 	for (i = 0, t = temp; i < 82; i++)

  00016	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001d	8d 45 a8	 lea	 eax, DWORD PTR _temp$[ebp]
  00020	89 45 a4	 mov	 DWORD PTR _t$[ebp], eax
  00023	eb 09		 jmp	 SHORT $LN4@D_MakeTitl
$LN2@D_MakeTitl:
  00025	8b 45 9c	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 9c	 mov	 DWORD PTR _i$[ebp], eax
$LN4@D_MakeTitl:
  0002e	83 7d 9c 52	 cmp	 DWORD PTR _i$[ebp], 82	; 00000052H
  00032	7d 11		 jge	 SHORT $LN3@D_MakeTitl

; 907  : 		*t++=' ';

  00034	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  00037	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  0003a	8b 4d a4	 mov	 ecx, DWORD PTR _t$[ebp]
  0003d	83 c1 01	 add	 ecx, 1
  00040	89 4d a4	 mov	 DWORD PTR _t$[ebp], ecx
  00043	eb e0		 jmp	 SHORT $LN2@D_MakeTitl
$LN3@D_MakeTitl:

; 908  : 
; 909  : 	for (t = temp + (80-strlen(s))/2, u = s; *u != '\0' ;)

  00045	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strlen
  0004e	83 c4 04	 add	 esp, 4
  00051	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00056	2b c8		 sub	 ecx, eax
  00058	d1 e9		 shr	 ecx, 1
  0005a	8d 54 0d a8	 lea	 edx, DWORD PTR _temp$[ebp+ecx]
  0005e	89 55 a4	 mov	 DWORD PTR _t$[ebp], edx
  00061	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00064	89 45 a0	 mov	 DWORD PTR _u$[ebp], eax
$LN5@D_MakeTitl:
  00067	8b 45 a0	 mov	 eax, DWORD PTR _u$[ebp]
  0006a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 1e		 je	 SHORT $LN6@D_MakeTitl

; 910  : 		*t++ = *u++;

  00071	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  00074	8b 4d a0	 mov	 ecx, DWORD PTR _u$[ebp]
  00077	8a 11		 mov	 dl, BYTE PTR [ecx]
  00079	88 10		 mov	 BYTE PTR [eax], dl
  0007b	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 a4	 mov	 DWORD PTR _t$[ebp], eax
  00084	8b 4d a0	 mov	 ecx, DWORD PTR _u$[ebp]
  00087	83 c1 01	 add	 ecx, 1
  0008a	89 4d a0	 mov	 DWORD PTR _u$[ebp], ecx
  0008d	eb d8		 jmp	 SHORT $LN5@D_MakeTitl
$LN6@D_MakeTitl:

; 911  : 
; 912  : 	u = compdate;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _compdate
  00094	89 45 a0	 mov	 DWORD PTR _u$[ebp], eax

; 913  : 	for (t = temp + 1, i = 11; i-- ;)

  00097	8d 45 a9	 lea	 eax, DWORD PTR _temp$[ebp+1]
  0009a	89 45 a4	 mov	 DWORD PTR _t$[ebp], eax
  0009d	c7 45 9c 0b 00
	00 00		 mov	 DWORD PTR _i$[ebp], 11	; 0000000bH
$LN8@D_MakeTitl:
  000a4	8b 45 9c	 mov	 eax, DWORD PTR _i$[ebp]
  000a7	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  000ad	8b 4d 9c	 mov	 ecx, DWORD PTR _i$[ebp]
  000b0	83 e9 01	 sub	 ecx, 1
  000b3	89 4d 9c	 mov	 DWORD PTR _i$[ebp], ecx
  000b6	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv79[ebp], 0
  000bd	74 1e		 je	 SHORT $LN9@D_MakeTitl

; 914  : 		*t++ = *u++;

  000bf	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  000c2	8b 4d a0	 mov	 ecx, DWORD PTR _u$[ebp]
  000c5	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c7	88 10		 mov	 BYTE PTR [eax], dl
  000c9	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	89 45 a4	 mov	 DWORD PTR _t$[ebp], eax
  000d2	8b 4d a0	 mov	 ecx, DWORD PTR _u$[ebp]
  000d5	83 c1 01	 add	 ecx, 1
  000d8	89 4d a0	 mov	 DWORD PTR _u$[ebp], ecx
  000db	eb c7		 jmp	 SHORT $LN8@D_MakeTitl
$LN9@D_MakeTitl:

; 915  : 	u = comptime;

  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _comptime
  000e2	89 45 a0	 mov	 DWORD PTR _u$[ebp], eax

; 916  : 	for (t = temp + 71, i = 8; i-- ;)

  000e5	8d 45 ef	 lea	 eax, DWORD PTR _temp$[ebp+71]
  000e8	89 45 a4	 mov	 DWORD PTR _t$[ebp], eax
  000eb	c7 45 9c 08 00
	00 00		 mov	 DWORD PTR _i$[ebp], 8
$LN11@D_MakeTitl:
  000f2	8b 45 9c	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  000fb	8b 4d 9c	 mov	 ecx, DWORD PTR _i$[ebp]
  000fe	83 e9 01	 sub	 ecx, 1
  00101	89 4d 9c	 mov	 DWORD PTR _i$[ebp], ecx
  00104	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv85[ebp], 0
  0010b	74 1e		 je	 SHORT $LN12@D_MakeTitl

; 917  : 		*t++ = *u++;

  0010d	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  00110	8b 4d a0	 mov	 ecx, DWORD PTR _u$[ebp]
  00113	8a 11		 mov	 dl, BYTE PTR [ecx]
  00115	88 10		 mov	 BYTE PTR [eax], dl
  00117	8b 45 a4	 mov	 eax, DWORD PTR _t$[ebp]
  0011a	83 c0 01	 add	 eax, 1
  0011d	89 45 a4	 mov	 DWORD PTR _t$[ebp], eax
  00120	8b 4d a0	 mov	 ecx, DWORD PTR _u$[ebp]
  00123	83 c1 01	 add	 ecx, 1
  00126	89 4d a0	 mov	 DWORD PTR _u$[ebp], ecx
  00129	eb c7		 jmp	 SHORT $LN11@D_MakeTitl
$LN12@D_MakeTitl:

; 918  : 
; 919  : 	temp[80] = '\0';

  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	6b c8 50	 imul	 ecx, eax, 80
  00133	89 8d 58 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00139	83 bd 58 ff ff
	ff 52		 cmp	 DWORD PTR $T1[ebp], 82	; 00000052H
  00140	73 02		 jae	 SHORT $LN15@D_MakeTitl
  00142	eb 06		 jmp	 SHORT $LN16@D_MakeTitl
$LN15@D_MakeTitl:
  00144	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00149	90		 npad	 1
$LN16@D_MakeTitl:
  0014a	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00150	c6 44 15 a8 00	 mov	 BYTE PTR _temp$[ebp+edx], 0

; 920  : 	strcpy(s, temp);

  00155	8d 45 a8	 lea	 eax, DWORD PTR _temp$[ebp]
  00158	50		 push	 eax
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _strcpy
  00162	83 c4 08	 add	 esp, 8
$LN1@D_MakeTitl:

; 921  : }

  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
_D_MakeTitleString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _IdentifyVersion
_TEXT	SEGMENT
$T1 = -92						; size = 4
_ms$2 = -24						; size = 4
_musicpath$3 = -20					; size = 4
_musicfile$4 = -16					; size = 4
_srb2waddir$ = -12					; size = 4
_srb2wad2$ = -8						; size = 4
_srb2wad1$ = -4						; size = 4
_IdentifyVersion PROC					; COMDAT

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 776  : 	char *srb2wad1, *srb2wad2;
; 777  : 	const char *srb2waddir = NULL;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _srb2waddir$[ebp], 0

; 778  : 
; 779  : #if defined (__unix__) || defined (UNIXCOMMON) || defined (SDL)
; 780  : 	// change to the directory where 'srb2.srb' is found
; 781  : 	srb2waddir = I_LocateWad();
; 782  : #endif
; 783  : 
; 784  : 	// get the current directory (possible problem on NT with "." as current dir)
; 785  : 	if (srb2waddir)

  00010	83 7d f4 00	 cmp	 DWORD PTR _srb2waddir$[ebp], 0
  00014	74 18		 je	 SHORT $LN2@IdentifyVe

; 786  : 	{
; 787  : 		strlcpy(srb2path,srb2waddir,sizeof (srb2path));

  00016	68 00 01 00 00	 push	 256			; 00000100H
  0001b	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET _srb2path
  00024	e8 00 00 00 00	 call	 _strlcpy
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 	}

  0002c	eb 26		 jmp	 SHORT $LN5@IdentifyVe
$LN2@IdentifyVe:

; 789  : 	else
; 790  : 	{
; 791  : #ifndef _WIN32_WCE
; 792  : 		if (getcwd(srb2path, 256) != NULL)

  0002e	68 00 01 00 00	 push	 256			; 00000100H
  00033	68 00 00 00 00	 push	 OFFSET _srb2path
  00038	e8 00 00 00 00	 call	 _getcwd
  0003d	83 c4 08	 add	 esp, 8
  00040	85 c0		 test	 eax, eax
  00042	74 09		 je	 SHORT $LN4@IdentifyVe

; 793  : 			srb2waddir = srb2path;

  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _srb2waddir$[ebp], OFFSET _srb2path
  0004b	eb 07		 jmp	 SHORT $LN5@IdentifyVe
$LN4@IdentifyVe:

; 794  : 		else
; 795  : #endif
; 796  : 		{
; 797  : #ifdef _arch_dreamcast
; 798  : 			srb2waddir = "/cd";
; 799  : #else
; 800  : 			srb2waddir = ".";

  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _srb2waddir$[ebp], OFFSET ??_C@_01LFCBOECM@?4@
$LN5@IdentifyVe:

; 801  : #endif
; 802  : 		}
; 803  : 	}
; 804  : 
; 805  : #if defined (macintosh) && !defined (SDL)
; 806  : 	// cwd is always "/" when app is dbl-clicked
; 807  : 	if (!stricmp(srb2waddir, "/"))
; 808  : 		srb2waddir = I_GetWadDir();
; 809  : #endif
; 810  : 	// Commercial.
; 811  : 	srb2wad1 = malloc(strlen(srb2waddir)+1+8+1);

  00054	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _strlen
  0005d	83 c4 04	 add	 esp, 4
  00060	83 c0 0a	 add	 eax, 10			; 0000000aH
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _malloc
  00069	83 c4 04	 add	 esp, 4
  0006c	89 45 fc	 mov	 DWORD PTR _srb2wad1$[ebp], eax

; 812  : 	srb2wad2 = malloc(strlen(srb2waddir)+1+8+1);

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _strlen
  00078	83 c4 04	 add	 esp, 4
  0007b	83 c0 0a	 add	 eax, 10			; 0000000aH
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _malloc
  00084	83 c4 04	 add	 esp, 4
  00087	89 45 f8	 mov	 DWORD PTR _srb2wad2$[ebp], eax

; 813  : 	if (srb2wad1 == NULL && srb2wad2 == NULL)

  0008a	83 7d fc 00	 cmp	 DWORD PTR _srb2wad1$[ebp], 0
  0008e	75 17		 jne	 SHORT $LN6@IdentifyVe
  00090	83 7d f8 00	 cmp	 DWORD PTR _srb2wad2$[ebp], 0
  00094	75 11		 jne	 SHORT $LN6@IdentifyVe

; 814  : 		I_Error("No more free memory to look in %s", srb2waddir);

  00096	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JMBCPJOM@No?5more?5free?5memory?5to?5look?5in?5@
  0009f	e8 00 00 00 00	 call	 _I_Error
  000a4	83 c4 08	 add	 esp, 8
$LN6@IdentifyVe:

; 815  : 	if (srb2wad1 != NULL)

  000a7	83 7d fc 00	 cmp	 DWORD PTR _srb2wad1$[ebp], 0
  000ab	74 29		 je	 SHORT $LN7@IdentifyVe

; 816  : 		sprintf(srb2wad1, pandf, srb2waddir, text[SRB2SRB]);

  000ad	b8 04 00 00 00	 mov	 eax, 4
  000b2	69 c8 69 01 00
	00		 imul	 ecx, eax, 361
  000b8	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  000be	52		 push	 edx
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  000c2	50		 push	 eax
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  000c9	51		 push	 ecx
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _srb2wad1$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 _sprintf
  000d3	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@IdentifyVe:

; 817  : 	if (srb2wad2 != NULL)

  000d6	83 7d f8 00	 cmp	 DWORD PTR _srb2wad2$[ebp], 0
  000da	74 29		 je	 SHORT $LN8@IdentifyVe

; 818  : 		sprintf(srb2wad2, pandf, srb2waddir, text[SRB2WAD]);

  000dc	b8 04 00 00 00	 mov	 eax, 4
  000e1	69 c8 6a 01 00
	00		 imul	 ecx, eax, 362
  000e7	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  000ed	52		 push	 edx
  000ee	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  000f1	50		 push	 eax
  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  000f8	51		 push	 ecx
  000f9	8b 55 f8	 mov	 edx, DWORD PTR _srb2wad2$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 _sprintf
  00102	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@IdentifyVe:

; 819  : 
; 820  : 	// will be overwritten in case of -cdrom or unix/win home
; 821  : 	_snprintf(configfile, sizeof configfile, "%s" PATHSEP CONFIGFILENAME, srb2waddir);

  00105	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  00108	50		 push	 eax
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IGIHOCK@?$CFs?2config?4cfg@
  0010e	68 80 00 00 00	 push	 128			; 00000080H
  00113	68 00 00 00 00	 push	 OFFSET _configfile
  00118	e8 00 00 00 00	 call	 ___snprintf
  0011d	83 c4 10	 add	 esp, 16			; 00000010H

; 822  : 	configfile[sizeof configfile - 1] = '\0';

  00120	b8 01 00 00 00	 mov	 eax, 1
  00125	6b c8 7f	 imul	 ecx, eax, 127
  00128	89 4d a4	 mov	 DWORD PTR $T1[ebp], ecx
  0012b	81 7d a4 80 00
	00 00		 cmp	 DWORD PTR $T1[ebp], 128	; 00000080H
  00132	73 02		 jae	 SHORT $LN19@IdentifyVe
  00134	eb 06		 jmp	 SHORT $LN20@IdentifyVe
$LN19@IdentifyVe:
  00136	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0013b	90		 npad	 1
$LN20@IdentifyVe:
  0013c	8b 55 a4	 mov	 edx, DWORD PTR $T1[ebp]
  0013f	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _configfile[edx], 0

; 823  : 
; 824  : 	// Load the IWAD
; 825  : 	if (srb2wad2 != NULL && FIL_ReadFileOK(srb2wad2))

  00146	83 7d f8 00	 cmp	 DWORD PTR _srb2wad2$[ebp], 0
  0014a	74 1e		 je	 SHORT $LN9@IdentifyVe
  0014c	8b 45 f8	 mov	 eax, DWORD PTR _srb2wad2$[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _FIL_ReadFileOK
  00155	83 c4 04	 add	 esp, 4
  00158	85 c0		 test	 eax, eax
  0015a	74 0e		 je	 SHORT $LN9@IdentifyVe

; 826  : 		D_AddFile(srb2wad2);

  0015c	8b 45 f8	 mov	 eax, DWORD PTR _srb2wad2$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _D_AddFile
  00165	83 c4 04	 add	 esp, 4
  00168	eb 3d		 jmp	 SHORT $LN12@IdentifyVe
$LN9@IdentifyVe:

; 827  : 	else if (srb2wad1 != NULL && FIL_ReadFileOK(srb2wad1))

  0016a	83 7d fc 00	 cmp	 DWORD PTR _srb2wad1$[ebp], 0
  0016e	74 1e		 je	 SHORT $LN11@IdentifyVe
  00170	8b 45 fc	 mov	 eax, DWORD PTR _srb2wad1$[ebp]
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _FIL_ReadFileOK
  00179	83 c4 04	 add	 esp, 4
  0017c	85 c0		 test	 eax, eax
  0017e	74 0e		 je	 SHORT $LN11@IdentifyVe

; 828  : 		D_AddFile(srb2wad1);

  00180	8b 45 fc	 mov	 eax, DWORD PTR _srb2wad1$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _D_AddFile
  00189	83 c4 04	 add	 esp, 4
  0018c	eb 19		 jmp	 SHORT $LN12@IdentifyVe
$LN11@IdentifyVe:

; 829  : 	else
; 830  : 		I_Error("SRB2.SRB/SRB2.WAD not found! Expected in %s, ss files: %s and %s\n", srb2waddir, srb2wad1, srb2wad2);

  0018e	8b 45 f8	 mov	 eax, DWORD PTR _srb2wad2$[ebp]
  00191	50		 push	 eax
  00192	8b 4d fc	 mov	 ecx, DWORD PTR _srb2wad1$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 f4	 mov	 edx, DWORD PTR _srb2waddir$[ebp]
  00199	52		 push	 edx
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@DKCNNDKK@SRB2?4SRB?1SRB2?4WAD?5not?5found?$CB?5Ex@
  0019f	e8 00 00 00 00	 call	 _I_Error
  001a4	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@IdentifyVe:

; 831  : 
; 832  : 	if (srb2wad1)

  001a7	83 7d fc 00	 cmp	 DWORD PTR _srb2wad1$[ebp], 0
  001ab	74 0c		 je	 SHORT $LN13@IdentifyVe

; 833  : 		free(srb2wad1);

  001ad	8b 45 fc	 mov	 eax, DWORD PTR _srb2wad1$[ebp]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 _free
  001b6	83 c4 04	 add	 esp, 4
$LN13@IdentifyVe:

; 834  : 	if (srb2wad2)

  001b9	83 7d f8 00	 cmp	 DWORD PTR _srb2wad2$[ebp], 0
  001bd	74 0c		 je	 SHORT $LN14@IdentifyVe

; 835  : 		free(srb2wad2);

  001bf	8b 45 f8	 mov	 eax, DWORD PTR _srb2wad2$[ebp]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 _free
  001c8	83 c4 04	 add	 esp, 4
$LN14@IdentifyVe:

; 836  : 
; 837  : 	// if you change the ordering of this or add/remove a file, be sure to update the md5
; 838  : 	// checking in D_SRB2Main
; 839  : 
; 840  : 	// Add the maps
; 841  : 	D_AddFile(va(pandf,srb2waddir,"zones.dta")); //zones.dta

  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_09KDGAJFC@zones?4dta@
  001d0	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  001d3	50		 push	 eax
  001d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  001da	51		 push	 ecx
  001db	e8 00 00 00 00	 call	 _va
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 _D_AddFile
  001e9	83 c4 04	 add	 esp, 4

; 842  : 
; 843  : 	// Add the players
; 844  : 	D_AddFile(va(pandf,srb2waddir,text[SONICPLR])); //sonic.plr

  001ec	b8 04 00 00 00	 mov	 eax, 4
  001f1	69 c8 6b 01 00
	00		 imul	 ecx, eax, 363
  001f7	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  001fd	52		 push	 edx
  001fe	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  00201	50		 push	 eax
  00202	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  00208	51		 push	 ecx
  00209	e8 00 00 00 00	 call	 _va
  0020e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _D_AddFile
  00217	83 c4 04	 add	 esp, 4

; 845  : 	D_AddFile(va(pandf,srb2waddir,text[TAILSPLR])); //tails.plr

  0021a	b8 04 00 00 00	 mov	 eax, 4
  0021f	69 c8 6c 01 00
	00		 imul	 ecx, eax, 364
  00225	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0022b	52		 push	 edx
  0022c	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  0022f	50		 push	 eax
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  00236	51		 push	 ecx
  00237	e8 00 00 00 00	 call	 _va
  0023c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _D_AddFile
  00245	83 c4 04	 add	 esp, 4

; 846  : 	D_AddFile(va(pandf,srb2waddir,text[KNUXPLR])); //knux.plr

  00248	b8 04 00 00 00	 mov	 eax, 4
  0024d	69 c8 6d 01 00
	00		 imul	 ecx, eax, 365
  00253	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00259	52		 push	 edx
  0025a	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  0025d	50		 push	 eax
  0025e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  00264	51		 push	 ecx
  00265	e8 00 00 00 00	 call	 _va
  0026a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 _D_AddFile
  00273	83 c4 04	 add	 esp, 4

; 847  : 
; 848  : #ifndef _PSP // PSPDEV's CRT haves a limit of 16 files opened at a time
; 849  : 	// Add the weapons
; 850  : 	D_AddFile(va(pandf,srb2waddir,"rings.wpn")); //rings.wpn

  00276	68 00 00 00 00	 push	 OFFSET ??_C@_09DPFJGNGH@rings?4wpn@
  0027b	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  0027e	50		 push	 eax
  0027f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  00285	51		 push	 ecx
  00286	e8 00 00 00 00	 call	 _va
  0028b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 _D_AddFile
  00294	83 c4 04	 add	 esp, 4

; 851  : #endif
; 852  : 
; 853  : 	// Add... nights?
; 854  : 	D_AddFile(va(pandf,srb2waddir,"drill.dta")); //drill.dta

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_09DADOBKL@drill?4dta@
  0029c	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  0029f	50		 push	 eax
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  002a6	51		 push	 ecx
  002a7	e8 00 00 00 00	 call	 _va
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 _D_AddFile
  002b5	83 c4 04	 add	 esp, 4

; 855  : 	D_AddFile(va(pandf,srb2waddir,"soar.dta")); //soar.dta

  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_08FHJDCGJG@soar?4dta@
  002bd	8b 45 f4	 mov	 eax, DWORD PTR _srb2waddir$[ebp]
  002c0	50		 push	 eax
  002c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  002c7	51		 push	 ecx
  002c8	e8 00 00 00 00	 call	 _va
  002cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 _D_AddFile
  002d6	83 c4 04	 add	 esp, 4

; 856  : 
; 857  : #if !defined (SDL) || defined (HAVE_MIXER)
; 858  : 	{
; 859  : #if defined (DC) && 0
; 860  : 		const char *musicfile = "music_dc.dta";
; 861  : #else
; 862  : 		const char *musicfile = text[MUSICWAD];

  002d9	b8 04 00 00 00	 mov	 eax, 4
  002de	69 c8 6e 01 00
	00		 imul	 ecx, eax, 366
  002e4	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  002ea	89 55 f0	 mov	 DWORD PTR _musicfile$4[ebp], edx

; 863  : #endif
; 864  : 		const char *musicpath = va(pandf,srb2waddir,musicfile);

  002ed	8b 45 f0	 mov	 eax, DWORD PTR _musicfile$4[ebp]
  002f0	50		 push	 eax
  002f1	8b 4d f4	 mov	 ecx, DWORD PTR _srb2waddir$[ebp]
  002f4	51		 push	 ecx
  002f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pandf
  002fb	52		 push	 edx
  002fc	e8 00 00 00 00	 call	 _va
  00301	83 c4 0c	 add	 esp, 12			; 0000000cH
  00304	89 45 ec	 mov	 DWORD PTR _musicpath$3[ebp], eax

; 865  : 		int ms = W_VerifyNMUSlumps(musicpath); // Don't forget the music!

  00307	8b 45 ec	 mov	 eax, DWORD PTR _musicpath$3[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 _W_VerifyNMUSlumps
  00310	83 c4 04	 add	 esp, 4
  00313	89 45 e8	 mov	 DWORD PTR _ms$2[ebp], eax

; 866  : 		if (ms == 1)

  00316	83 7d e8 01	 cmp	 DWORD PTR _ms$2[ebp], 1
  0031a	75 0e		 jne	 SHORT $LN15@IdentifyVe

; 867  : 			D_AddFile(musicpath);

  0031c	8b 45 ec	 mov	 eax, DWORD PTR _musicpath$3[ebp]
  0031f	50		 push	 eax
  00320	e8 00 00 00 00	 call	 _D_AddFile
  00325	83 c4 04	 add	 esp, 4
  00328	eb 17		 jmp	 SHORT $LN17@IdentifyVe
$LN15@IdentifyVe:

; 868  : 		else if (ms == 0)

  0032a	83 7d e8 00	 cmp	 DWORD PTR _ms$2[ebp], 0
  0032e	75 11		 jne	 SHORT $LN17@IdentifyVe

; 869  : 			I_Error("File %s has been modified with non-music lumps",musicfile);

  00330	8b 45 f0	 mov	 eax, DWORD PTR _musicfile$4[ebp]
  00333	50		 push	 eax
  00334	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FOCILDPI@File?5?$CFs?5has?5been?5modified?5with?5@
  00339	e8 00 00 00 00	 call	 _I_Error
  0033e	83 c4 08	 add	 esp, 8
$LN17@IdentifyVe:

; 870  : 	}
; 871  : #endif
; 872  : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b e5		 mov	 esp, ebp
  00346	5d		 pop	 ebp
  00347	c3		 ret	 0
_IdentifyVersion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_CleanFile
_TEXT	SEGMENT
_pnumwadfiles$ = -4					; size = 4
_D_CleanFile PROC					; COMDAT

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 758  : 	size_t pnumwadfiles;
; 759  : 	for (pnumwadfiles = 0; startupwadfiles[pnumwadfiles]; pnumwadfiles++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pnumwadfiles$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@D_CleanFil
$LN2@D_CleanFil:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _pnumwadfiles$[ebp], eax
$LN4@D_CleanFil:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  0001e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _startupwadfiles[eax*4], 0
  00026	74 23		 je	 SHORT $LN3@D_CleanFil

; 760  : 	{
; 761  : 		free(startupwadfiles[pnumwadfiles]);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  0002b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _startupwadfiles[eax*4]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _free
  00038	83 c4 04	 add	 esp, 4

; 762  : 		startupwadfiles[pnumwadfiles] = NULL;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  0003e	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _startupwadfiles[eax*4], 0

; 763  : 	}

  00049	eb c7		 jmp	 SHORT $LN2@D_CleanFil
$LN3@D_CleanFil:

; 764  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_D_CleanFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_AddFile
_TEXT	SEGMENT
_newfile$ = -8						; size = 4
_pnumwadfiles$ = -4					; size = 4
_file$ = 8						; size = 4
_D_AddFile PROC						; COMDAT

; 739  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 740  : 	size_t pnumwadfiles;
; 741  : 	char *newfile;
; 742  : 
; 743  : 	for (pnumwadfiles = 0; startupwadfiles[pnumwadfiles]; pnumwadfiles++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pnumwadfiles$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@D_AddFile
$LN2@D_AddFile:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _pnumwadfiles$[ebp], eax
$LN4@D_AddFile:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  0001e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _startupwadfiles[eax*4], 0
  00026	74 02		 je	 SHORT $LN3@D_AddFile

; 744  : 		;

  00028	eb e8		 jmp	 SHORT $LN2@D_AddFile
$LN3@D_AddFile:

; 745  : 
; 746  : 	newfile = malloc(strlen(file) + 1);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _strlen
  00033	83 c4 04	 add	 esp, 4
  00036	83 c0 01	 add	 eax, 1
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _malloc
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f8	 mov	 DWORD PTR _newfile$[ebp], eax

; 747  : 	if (!newfile)

  00045	83 7d f8 00	 cmp	 DWORD PTR _newfile$[ebp], 0
  00049	75 11		 jne	 SHORT $LN5@D_AddFile

; 748  : 	{
; 749  : 		I_Error("No more free memory to AddFile %s",file);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DPFCLJJJ@No?5more?5free?5memory?5to?5AddFile?5@
  00054	e8 00 00 00 00	 call	 _I_Error
  00059	83 c4 08	 add	 esp, 8
$LN5@D_AddFile:

; 750  : 	}
; 751  : 	strcpy(newfile, file);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _newfile$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _strcpy
  00069	83 c4 08	 add	 esp, 8

; 752  : 
; 753  : 	startupwadfiles[pnumwadfiles] = newfile;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _pnumwadfiles$[ebp]
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _newfile$[ebp]
  00072	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _startupwadfiles[eax*4], ecx

; 754  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_D_AddFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_Display
_TEXT	SEGMENT
tv94 = -144						; size = 4
tv129 = -144						; size = 4
tv326 = -144						; size = 4
$T1 = -140						; size = 4
_s$2 = -72						; size = 50
_patch$3 = -20						; size = 4
_py$4 = -16						; size = 4
_viewactivestate$ = -12					; size = 4
_redrawsbar$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_D_Display PROC						; COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 217  : 	static boolean menuactivestate = false;
; 218  : 	static gamestate_t oldgamestate = -1;
; 219  : 	boolean redrawsbar = false, viewactivestate = false;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _redrawsbar$[ebp], 0
  0001d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _viewactivestate$[ebp], 0

; 220  : 	static boolean wipe = false;
; 221  : 
; 222  : 	if (dedicated)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0002b	74 05		 je	 SHORT $LN4@D_Display

; 223  : 		return;

  0002d	e9 98 07 00 00	 jmp	 $LN62@D_Display
$LN4@D_Display:

; 224  : 
; 225  : 	if (nodrawers)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodrawers, 0
  00039	74 05		 je	 SHORT $LN5@D_Display

; 226  : 		return; // for comparative timing/profiling

  0003b	e9 8a 07 00 00	 jmp	 $LN62@D_Display
$LN5@D_Display:

; 227  : 
; 228  : 	// check for change of screen size (video mode)
; 229  : 	if (setmodeneeded && !wipe)

  00040	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _setmodeneeded, 0
  00047	74 0f		 je	 SHORT $LN6@D_Display
  00049	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?wipe@?1??D_Display@@9@9, 0
  00050	75 06		 jne	 SHORT $LN6@D_Display

; 230  : 		SCR_SetMode(); // change video mode

  00052	e8 00 00 00 00	 call	 _SCR_SetMode
  00057	90		 npad	 1
$LN6@D_Display:

; 231  : 
; 232  : 	if (vid.recalc)

  00058	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _vid+24, 0
  0005f	74 06		 je	 SHORT $LN7@D_Display

; 233  : 		SCR_Recalc(); // NOTE! setsizeneeded is set by SCR_Recalc()

  00061	e8 00 00 00 00	 call	 _SCR_Recalc
  00066	90		 npad	 1
$LN7@D_Display:

; 234  : 
; 235  : 	// change the view size if needed
; 236  : 	if (setsizeneeded)

  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _setsizeneeded, 0
  0006e	74 17		 je	 SHORT $LN8@D_Display

; 237  : 	{
; 238  : 		R_ExecuteSetViewSize();

  00070	e8 00 00 00 00	 call	 _R_ExecuteSetViewSize
  00075	90		 npad	 1

; 239  : 		oldgamestate = -1; // force background redraw

  00076	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?oldgamestate@?1??D_Display@@9@9, -1

; 240  : 		redrawsbar = true;

  00080	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _redrawsbar$[ebp], 1
$LN8@D_Display:

; 241  : 	}
; 242  : 
; 243  : 	// save the current screen if about to wipe
; 244  : 	if (gamestate != wipegamestate)

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _gamestate
  0008c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wipegamestate
  00092	74 12		 je	 SHORT $LN9@D_Display

; 245  : 	{
; 246  : 		wipe = true;

  00094	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?wipe@?1??D_Display@@9@9, 1

; 247  : 
; 248  : #ifndef SHUFFLE
; 249  : 		if (rendermode == render_soft)
; 250  : #endif
; 251  : 			F_WipeStartScreen();

  0009e	e8 00 00 00 00	 call	 _F_WipeStartScreen
  000a3	90		 npad	 1

; 252  : 	}

  000a4	eb 0a		 jmp	 SHORT $LN10@D_Display
$LN9@D_Display:

; 253  : 	else
; 254  : 		wipe = false;

  000a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wipe@?1??D_Display@@9@9, 0
$LN10@D_Display:

; 255  : 
; 256  : 	// Hardware mode does not fade wipe.
; 257  : 	// Thus, don't delay it unless needed for synchronisity.
; 258  : #ifndef SHUFFLE
; 259  : 	if (rendermode != render_soft /*&& !netgame*/)
; 260  : 	{
; 261  : 		if (gamestate != GS_INTRO
; 262  : 		&& gamestate != GS_INTRO2
; 263  : 		&& gamestate != GS_CUTSCENE)
; 264  : 			wipe = false;
; 265  : 	}
; 266  : #endif
; 267  : 	// draw buffered stuff to screen
; 268  : 	// Used only by linux GGI version
; 269  : 	I_UpdateNoBlit();

  000b0	e8 00 00 00 00	 call	 _I_UpdateNoBlit
  000b5	90		 npad	 1

; 270  : 
; 271  : 	// Fade to black first
; 272  : 	if (rendermode != render_none)

  000b6	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  000bd	0f 84 be 00 00
	00		 je	 $LN11@D_Display

; 273  : 	{
; 274  : 		if (wipe)

  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?wipe@?1??D_Display@@9@9, 0
  000ca	0f 84 ab 00 00
	00		 je	 $LN12@D_Display

; 275  : 		{
; 276  : 			if (!(mapheaderinfo[gamemap-1].interscreen[0] == '#'

  000d0	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000d7	83 e8 01	 sub	 eax, 1
  000da	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  000e0	ba 01 00 00 00	 mov	 edx, 1
  000e5	6b c2 00	 imul	 eax, edx, 0
  000e8	0f be 8c 01 50
	00 00 00	 movsx	 ecx, BYTE PTR _mapheaderinfo[ecx+eax+80]
  000f0	83 f9 23	 cmp	 ecx, 35			; 00000023H
  000f3	75 09		 jne	 SHORT $LN14@D_Display
  000f5	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _gamestate, 2
  000fc	74 2a		 je	 SHORT $LN15@D_Display
$LN14@D_Display:

; 277  : 				&& gamestate == GS_INTERMISSION))
; 278  : 			{
; 279  : 				V_DrawFill(0, 0, vid.width, vid.height, 31);

  000fe	6a 1f		 push	 31			; 0000001fH
  00100	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00105	50		 push	 eax
  00106	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0010c	51		 push	 ecx
  0010d	6a 00		 push	 0
  0010f	6a 00		 push	 0
  00111	e8 00 00 00 00	 call	 _V_DrawFill
  00116	83 c4 14	 add	 esp, 20			; 00000014H

; 280  : #if defined (SHUFFLE) && defined (HWRENDER)
; 281  : 				if(rendermode != render_soft)

  00119	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00120	74 06		 je	 SHORT $LN15@D_Display

; 282  : 				{
; 283  : 					HWR_PrepFadeToBlack();

  00122	e8 00 00 00 00	 call	 _HWR_PrepFadeToBlack
  00127	90		 npad	 1
$LN15@D_Display:

; 284  : 				}
; 285  : #endif
; 286  : 			}
; 287  : 			F_WipeEndScreen(0, 0, vid.width, vid.height);

  00128	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0012d	50		 push	 eax
  0012e	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00134	51		 push	 ecx
  00135	6a 00		 push	 0
  00137	6a 00		 push	 0
  00139	e8 00 00 00 00	 call	 _F_WipeEndScreen
  0013e	83 c4 10	 add	 esp, 16			; 00000010H

; 288  : 
; 289  : 			F_RunWipe(2*TICRATE, gamestate != GS_TIMEATTACK);

  00141	83 3d 00 00 00
	00 0b		 cmp	 DWORD PTR _gamestate, 11 ; 0000000bH
  00148	74 0c		 je	 SHORT $LN64@D_Display
  0014a	c7 85 70 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv94[ebp], 1
  00154	eb 0a		 jmp	 SHORT $LN65@D_Display
$LN64@D_Display:
  00156	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv94[ebp], 0
$LN65@D_Display:
  00160	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv94[ebp]
  00166	50		 push	 eax
  00167	6a 46		 push	 70			; 00000046H
  00169	e8 00 00 00 00	 call	 _F_RunWipe
  0016e	83 c4 08	 add	 esp, 8

; 290  : 
; 291  : 			WipeInAction = false;

  00171	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WipeInAction, 0
$LN12@D_Display:

; 292  : 		}
; 293  : 		F_WipeStartScreen();

  0017b	e8 00 00 00 00	 call	 _F_WipeStartScreen
  00180	90		 npad	 1
$LN11@D_Display:

; 294  : 	}
; 295  : 
; 296  : 	// do buffered drawing
; 297  : 	switch (gamestate)

  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR _gamestate
  00186	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  0018c	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  00192	83 e9 01	 sub	 ecx, 1
  00195	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
  0019b	83 bd 70 ff ff
	ff 09		 cmp	 DWORD PTR tv129[ebp], 9
  001a2	0f 87 d2 00 00
	00		 ja	 $LN2@D_Display
  001a8	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv129[ebp]
  001ae	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN70@D_Display[edx*4]
$LN16@D_Display:

; 298  : 	{
; 299  : 		case GS_LEVEL:
; 300  : 			if (!gametic)

  001b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gametic, 0
  001bc	75 05		 jne	 SHORT $LN17@D_Display

; 301  : 				break;

  001be	e9 b7 00 00 00	 jmp	 $LN2@D_Display
$LN17@D_Display:

; 302  : 			HU_Erase();

  001c3	e8 00 00 00 00	 call	 _HU_Erase
  001c8	90		 npad	 1

; 303  : 			if (automapactive)

  001c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _automapactive, 0
  001d0	74 06		 je	 SHORT $LN18@D_Display

; 304  : 				AM_Drawer();

  001d2	e8 00 00 00 00	 call	 _AM_Drawer
  001d7	90		 npad	 1
$LN18@D_Display:

; 305  : 			if (wipe || menuactivestate || (rendermode != render_soft && rendermode != render_none) || vid.recalc)

  001d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?wipe@?1??D_Display@@9@9, 0
  001df	75 24		 jne	 SHORT $LN20@D_Display
  001e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?menuactivestate@?1??D_Display@@9@9, 0
  001e8	75 1b		 jne	 SHORT $LN20@D_Display
  001ea	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  001f1	74 09		 je	 SHORT $LN21@D_Display
  001f3	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  001fa	75 09		 jne	 SHORT $LN20@D_Display
$LN21@D_Display:
  001fc	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR _vid+24, 0
  00203	74 07		 je	 SHORT $LN19@D_Display
$LN20@D_Display:

; 306  : 				redrawsbar = true;

  00205	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _redrawsbar$[ebp], 1
$LN19@D_Display:

; 307  : 			break;

  0020c	eb 6c		 jmp	 SHORT $LN2@D_Display
$LN22@D_Display:

; 308  : 
; 309  : 		case GS_INTERMISSION:
; 310  : 			Y_IntermissionDrawer();

  0020e	e8 00 00 00 00	 call	 _Y_IntermissionDrawer
  00213	90		 npad	 1

; 311  : 			HU_Erase();

  00214	e8 00 00 00 00	 call	 _HU_Erase
  00219	90		 npad	 1

; 312  : 			HU_Drawer();

  0021a	e8 00 00 00 00	 call	 _HU_Drawer
  0021f	90		 npad	 1

; 313  : 			break;

  00220	eb 58		 jmp	 SHORT $LN2@D_Display

; 314  : 
; 315  : 		case GS_TIMEATTACK:
; 316  : 			break;

  00222	eb 56		 jmp	 SHORT $LN2@D_Display
$LN24@D_Display:

; 317  : 
; 318  : 		case GS_INTRO:
; 319  : 		case GS_INTRO2:
; 320  : 			F_IntroDrawer();

  00224	e8 00 00 00 00	 call	 _F_IntroDrawer
  00229	90		 npad	 1

; 321  : 			break;

  0022a	eb 4e		 jmp	 SHORT $LN2@D_Display
$LN26@D_Display:

; 322  : 
; 323  : 		case GS_CUTSCENE:
; 324  : 			F_CutsceneDrawer();

  0022c	e8 00 00 00 00	 call	 _F_CutsceneDrawer
  00231	90		 npad	 1

; 325  : 			HU_Erase();

  00232	e8 00 00 00 00	 call	 _HU_Erase
  00237	90		 npad	 1

; 326  : 			HU_Drawer();

  00238	e8 00 00 00 00	 call	 _HU_Drawer
  0023d	90		 npad	 1

; 327  : 			break;

  0023e	eb 3a		 jmp	 SHORT $LN2@D_Display
$LN27@D_Display:

; 328  : 
; 329  : 		case GS_GAMEEND:
; 330  : 			F_GameEndDrawer();

  00240	e8 00 00 00 00	 call	 _F_GameEndDrawer
  00245	90		 npad	 1

; 331  : 			break;

  00246	eb 32		 jmp	 SHORT $LN2@D_Display
$LN28@D_Display:

; 332  : 
; 333  : 		case GS_EVALUATION:
; 334  : 			F_GameEvaluationDrawer();

  00248	e8 00 00 00 00	 call	 _F_GameEvaluationDrawer
  0024d	90		 npad	 1

; 335  : 			break;

  0024e	eb 2a		 jmp	 SHORT $LN2@D_Display
$LN29@D_Display:

; 336  : 
; 337  : 		case GS_CREDITS:
; 338  : 			F_CreditDrawer();

  00250	e8 00 00 00 00	 call	 _F_CreditDrawer
  00255	90		 npad	 1

; 339  : 			HU_Erase();

  00256	e8 00 00 00 00	 call	 _HU_Erase
  0025b	90		 npad	 1

; 340  : 			HU_Drawer();

  0025c	e8 00 00 00 00	 call	 _HU_Drawer
  00261	90		 npad	 1

; 341  : 			break;

  00262	eb 16		 jmp	 SHORT $LN2@D_Display
$LN30@D_Display:

; 342  : 
; 343  : 		case GS_TITLESCREEN:
; 344  : 			F_TitleScreenDrawer();

  00264	e8 00 00 00 00	 call	 _F_TitleScreenDrawer
  00269	90		 npad	 1

; 345  : 			break;

  0026a	eb 0e		 jmp	 SHORT $LN2@D_Display
$LN31@D_Display:

; 346  : 
; 347  : 		case GS_DEMOSCREEN:
; 348  : 			D_PageDrawer(pagename);

  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pagename
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 _D_PageDrawer
  00277	83 c4 04	 add	 esp, 4
$LN2@D_Display:

; 349  : 		case GS_DEDICATEDSERVER:
; 350  : 		case GS_WAITINGPLAYERS:
; 351  : 		case GS_NULL:
; 352  : 			break;
; 353  : 	}
; 354  : 
; 355  : 	// Transitions for Introduction
; 356  : 	if (gamestate == GS_INTRO && oldgamestate == GS_INTRO2)

  0027a	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _gamestate, 5
  00281	75 15		 jne	 SHORT $LN35@D_Display
  00283	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?oldgamestate@?1??D_Display@@9@9, 6
  0028a	75 0c		 jne	 SHORT $LN35@D_Display

; 357  : 		wipe = true;

  0028c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?wipe@?1??D_Display@@9@9, 1
  00296	eb 1c		 jmp	 SHORT $LN37@D_Display
$LN35@D_Display:

; 358  : 	else if (gamestate == GS_INTRO2 && oldgamestate == GS_INTRO)

  00298	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _gamestate, 6
  0029f	75 13		 jne	 SHORT $LN37@D_Display
  002a1	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR ?oldgamestate@?1??D_Display@@9@9, 5
  002a8	75 0a		 jne	 SHORT $LN37@D_Display

; 359  : 		wipe = true;

  002aa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?wipe@?1??D_Display@@9@9, 1
$LN37@D_Display:

; 360  : 
; 361  : 	// clean up border stuff
; 362  : 	// see if the border needs to be initially drawn
; 363  : 	if (gamestate == GS_LEVEL)

  002b4	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  002bb	0f 85 39 02 00
	00		 jne	 $LN38@D_Display

; 364  : 	{
; 365  : 		if (oldgamestate != GS_LEVEL)

  002c1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?oldgamestate@?1??D_Display@@9@9, 1
  002c8	74 07		 je	 SHORT $LN39@D_Display

; 366  : 		{
; 367  : 			viewactivestate = false; // view was not active

  002ca	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _viewactivestate$[ebp], 0
$LN39@D_Display:

; 368  : #if 0
; 369  : 			R_FillBackScreen(); // draw the pattern into the back screen
; 370  : #endif
; 371  : 		}
; 372  : 
; 373  : 		// draw the view directly
; 374  : 		if (!automapactive && !dedicated && cv_renderview.value)

  002d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _automapactive, 0
  002d8	0f 85 a0 01 00
	00		 jne	 $LN49@D_Display
  002de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  002e5	0f 85 93 01 00
	00		 jne	 $LN49@D_Display
  002eb	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_renderview+20, 0
  002f2	0f 84 86 01 00
	00		 je	 $LN49@D_Display

; 375  : 		{
; 376  : 			if (players[displayplayer].mo)

  002f8	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00302	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00309	74 6e		 je	 SHORT $LN44@D_Display

; 377  : 			{
; 378  : 				topleft = screens[0] + viewwindowy*vid.width + viewwindowx;

  0030b	b8 04 00 00 00	 mov	 eax, 4
  00310	6b c8 00	 imul	 ecx, eax, 0
  00313	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewwindowy
  00319	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  00320	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  00326	03 c2		 add	 eax, edx
  00328	03 05 00 00 00
	00		 add	 eax, DWORD PTR _viewwindowx
  0032e	a3 00 00 00 00	 mov	 DWORD PTR _topleft, eax

; 379  : #ifdef HWRENDER
; 380  : 				if (rendermode != render_soft)

  00333	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0033a	74 1c		 je	 SHORT $LN42@D_Display

; 381  : 					HWR_RenderPlayerView(0, &players[displayplayer]);

  0033c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00346	05 00 00 00 00	 add	 eax, OFFSET _players
  0034b	50		 push	 eax
  0034c	6a 00		 push	 0
  0034e	e8 00 00 00 00	 call	 _HWR_RenderPlayerView
  00353	83 c4 08	 add	 esp, 8
  00356	eb 21		 jmp	 SHORT $LN44@D_Display
$LN42@D_Display:

; 382  : 				else
; 383  : #endif
; 384  : 				if (rendermode != render_none)

  00358	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0035f	74 18		 je	 SHORT $LN44@D_Display

; 385  : 					R_RenderPlayerView(&players[displayplayer]);

  00361	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  0036b	05 00 00 00 00	 add	 eax, OFFSET _players
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _R_RenderPlayerView
  00376	83 c4 04	 add	 esp, 4
$LN44@D_Display:

; 386  : 			}
; 387  : 
; 388  : 			// render the second screen
; 389  : 			if (secondarydisplayplayer != consoleplayer && players[secondarydisplayplayer].mo)

  00379	a1 00 00 00 00	 mov	 eax, DWORD PTR _secondarydisplayplayer
  0037e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  00384	0f 84 dd 00 00
	00		 je	 $LN48@D_Display
  0038a	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00394	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  0039b	0f 84 c6 00 00
	00		 je	 $LN48@D_Display

; 390  : 			{
; 391  : #ifdef HWRENDER
; 392  : 				if (rendermode != render_soft)

  003a1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  003a8	74 1f		 je	 SHORT $LN46@D_Display

; 393  : 					HWR_RenderPlayerView(1, &players[secondarydisplayplayer]);

  003aa	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003b4	05 00 00 00 00	 add	 eax, OFFSET _players
  003b9	50		 push	 eax
  003ba	6a 01		 push	 1
  003bc	e8 00 00 00 00	 call	 _HWR_RenderPlayerView
  003c1	83 c4 08	 add	 esp, 8
  003c4	e9 9e 00 00 00	 jmp	 $LN48@D_Display
$LN46@D_Display:

; 394  : 				else
; 395  : #endif
; 396  : 				if (rendermode != render_none)

  003c9	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  003d0	0f 84 91 00 00
	00		 je	 $LN48@D_Display

; 397  : 				{
; 398  : 					viewwindowy = vid.height / 2;

  003d6	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  003db	99		 cdq
  003dc	2b c2		 sub	 eax, edx
  003de	d1 f8		 sar	 eax, 1
  003e0	a3 00 00 00 00	 mov	 DWORD PTR _viewwindowy, eax

; 399  : 					M_Memcpy(ylookup, ylookup2, viewheight*sizeof (ylookup[0]));

  003e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewheight
  003ea	c1 e0 02	 shl	 eax, 2
  003ed	50		 push	 eax
  003ee	68 00 00 00 00	 push	 OFFSET _ylookup2
  003f3	68 00 00 00 00	 push	 OFFSET _ylookup
  003f8	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  003fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 400  : 
; 401  : 					topleft = screens[0] + viewwindowy*vid.width + viewwindowx;

  00401	b8 04 00 00 00	 mov	 eax, 4
  00406	6b c8 00	 imul	 ecx, eax, 0
  00409	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewwindowy
  0040f	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  00416	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  0041c	03 c2		 add	 eax, edx
  0041e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _viewwindowx
  00424	a3 00 00 00 00	 mov	 DWORD PTR _topleft, eax

; 402  : 
; 403  : 					R_RenderPlayerView(&players[secondarydisplayplayer]);

  00429	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00433	05 00 00 00 00	 add	 eax, OFFSET _players
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 _R_RenderPlayerView
  0043e	83 c4 04	 add	 esp, 4

; 404  : 
; 405  : 					viewwindowy = 0;

  00441	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _viewwindowy, 0

; 406  : 					M_Memcpy(ylookup, ylookup1, viewheight*sizeof (ylookup[0]));

  0044b	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewheight
  00450	c1 e0 02	 shl	 eax, 2
  00453	50		 push	 eax
  00454	68 00 00 00 00	 push	 OFFSET _ylookup1
  00459	68 00 00 00 00	 push	 OFFSET _ylookup
  0045e	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00464	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN48@D_Display:

; 407  : 				}
; 408  : 			}
; 409  : 
; 410  : 			// Image postprocessing effect
; 411  : 			if (postimgtype)

  00467	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _postimgtype, 0
  0046e	74 0e		 je	 SHORT $LN49@D_Display

; 412  : 				V_DoPostProcessor(postimgtype);

  00470	a1 00 00 00 00	 mov	 eax, DWORD PTR _postimgtype
  00475	50		 push	 eax
  00476	e8 00 00 00 00	 call	 _V_DoPostProcessor
  0047b	83 c4 04	 add	 esp, 4
$LN49@D_Display:

; 413  : 		}
; 414  : 
; 415  : 		if (lastdraw)

  0047e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lastdraw, 0
  00485	74 61		 je	 SHORT $LN50@D_Display

; 416  : 		{
; 417  : 			if (rendermode == render_soft)

  00487	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0048e	75 4e		 jne	 SHORT $LN51@D_Display

; 418  : 				VID_BlitLinearScreen(screens[0], screens[1], vid.width*vid.bpp, vid.height, vid.width*vid.bpp, vid.rowbytes);

  00490	a1 08 00 00 00	 mov	 eax, DWORD PTR _vid+8
  00495	50		 push	 eax
  00496	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0049c	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  004a3	51		 push	 ecx
  004a4	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  004aa	52		 push	 edx
  004ab	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  004b0	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  004b7	50		 push	 eax
  004b8	b9 04 00 00 00	 mov	 ecx, 4
  004bd	c1 e1 00	 shl	 ecx, 0
  004c0	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  004c6	52		 push	 edx
  004c7	b8 04 00 00 00	 mov	 eax, 4
  004cc	6b c8 00	 imul	 ecx, eax, 0
  004cf	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  004d5	52		 push	 edx
  004d6	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  004db	83 c4 18	 add	 esp, 24			; 00000018H
$LN51@D_Display:

; 419  : 			lastdraw = false;

  004de	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _lastdraw, 0
$LN50@D_Display:

; 420  : 		}
; 421  : 
; 422  : 		ST_Drawer(redrawsbar);

  004e8	8b 45 f8	 mov	 eax, DWORD PTR _redrawsbar$[ebp]
  004eb	50		 push	 eax
  004ec	e8 00 00 00 00	 call	 _ST_Drawer
  004f1	83 c4 04	 add	 esp, 4

; 423  : 
; 424  : 		HU_Drawer();

  004f4	e8 00 00 00 00	 call	 _HU_Drawer
  004f9	90		 npad	 1
$LN38@D_Display:

; 425  : 	}
; 426  : 
; 427  : 	// change gamma if needed
; 428  : 	if (gamestate != oldgamestate && gamestate != GS_LEVEL)

  004fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _gamestate
  004ff	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?oldgamestate@?1??D_Display@@9@9
  00505	74 13		 je	 SHORT $LN52@D_Display
  00507	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  0050e	74 0a		 je	 SHORT $LN52@D_Display

; 429  : 		V_SetPalette(0);

  00510	6a 00		 push	 0
  00512	e8 00 00 00 00	 call	 _V_SetPalette
  00517	83 c4 04	 add	 esp, 4
$LN52@D_Display:

; 430  : 
; 431  : 	menuactivestate = menuactive;

  0051a	a1 00 00 00 00	 mov	 eax, DWORD PTR _menuactive
  0051f	a3 00 00 00 00	 mov	 DWORD PTR ?menuactivestate@?1??D_Display@@9@9, eax

; 432  : 	oldgamestate = wipegamestate = gamestate;

  00524	a1 00 00 00 00	 mov	 eax, DWORD PTR _gamestate
  00529	a3 00 00 00 00	 mov	 DWORD PTR _wipegamestate, eax
  0052e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wipegamestate
  00534	89 0d 00 00 00
	00		 mov	 DWORD PTR ?oldgamestate@?1??D_Display@@9@9, ecx

; 433  : 
; 434  : 	// draw pause pic
; 435  : 	if (paused && (!menuactive || netgame))

  0053a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  00541	85 c0		 test	 eax, eax
  00543	74 6e		 je	 SHORT $LN53@D_Display
  00545	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _menuactive, 0
  0054c	74 09		 je	 SHORT $LN54@D_Display
  0054e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00555	74 5c		 je	 SHORT $LN53@D_Display
$LN54@D_Display:

; 436  : 	{
; 437  : 		INT32 py;
; 438  : 		patch_t *patch;
; 439  : 		if (automapactive)

  00557	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _automapactive, 0
  0055e	74 09		 je	 SHORT $LN55@D_Display

; 440  : 			py = 4;

  00560	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _py$4[ebp], 4
  00567	eb 0b		 jmp	 SHORT $LN56@D_Display
$LN55@D_Display:

; 441  : 		else
; 442  : 			py = viewwindowy + 4;

  00569	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewwindowy
  0056e	83 c0 04	 add	 eax, 4
  00571	89 45 f0	 mov	 DWORD PTR _py$4[ebp], eax
$LN56@D_Display:

; 443  : 		patch = W_CachePatchName("M_PAUSE", PU_CACHE);

  00574	6a 65		 push	 101			; 00000065H
  00576	68 00 00 00 00	 push	 OFFSET ??_C@_07ILOCMDMD@M_PAUSE@
  0057b	e8 00 00 00 00	 call	 _W_CachePatchName
  00580	83 c4 08	 add	 esp, 8
  00583	89 45 ec	 mov	 DWORD PTR _patch$3[ebp], eax

; 444  : 		V_DrawScaledPatch(viewwindowx + (BASEVIDWIDTH - SHORT(patch->width))/2, py, 0, patch);

  00586	8b 45 ec	 mov	 eax, DWORD PTR _patch$3[ebp]
  00589	50		 push	 eax
  0058a	6a 00		 push	 0
  0058c	8b 4d f0	 mov	 ecx, DWORD PTR _py$4[ebp]
  0058f	51		 push	 ecx
  00590	8b 55 ec	 mov	 edx, DWORD PTR _patch$3[ebp]
  00593	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00596	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  0059b	2b c8		 sub	 ecx, eax
  0059d	8b c1		 mov	 eax, ecx
  0059f	99		 cdq
  005a0	2b c2		 sub	 eax, edx
  005a2	d1 f8		 sar	 eax, 1
  005a4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _viewwindowx
  005aa	50		 push	 eax
  005ab	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  005b0	83 c4 10	 add	 esp, 16			; 00000010H
$LN53@D_Display:

; 445  : 	}
; 446  : 
; 447  : 	// vid size change is now finished if it was on...
; 448  : 	vid.recalc = 0;

  005b3	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _vid+24, 0

; 449  : 
; 450  : 	// FIXME: draw either console or menu, not the two
; 451  : 	if (gamestate != GS_TIMEATTACK)

  005bd	83 3d 00 00 00
	00 0b		 cmp	 DWORD PTR _gamestate, 11 ; 0000000bH
  005c4	74 06		 je	 SHORT $LN57@D_Display

; 452  : 		CON_Drawer();

  005c6	e8 00 00 00 00	 call	 _CON_Drawer
  005cb	90		 npad	 1
$LN57@D_Display:

; 453  : 
; 454  : 	M_Drawer(); // menu is drawn even on top of everything

  005cc	e8 00 00 00 00	 call	 _M_Drawer
  005d1	90		 npad	 1

; 455  : 	NetUpdate(); // send out any new accumulation

  005d2	e8 00 00 00 00	 call	 _NetUpdate
  005d7	90		 npad	 1

; 456  : 
; 457  : 	// It's safe to end the game now.
; 458  : 	if (G_GetExitGameFlag())

  005d8	e8 00 00 00 00	 call	 _G_GetExitGameFlag
  005dd	85 c0		 test	 eax, eax
  005df	74 0c		 je	 SHORT $LN58@D_Display

; 459  : 	{
; 460  : 		Command_ExitGame_f();

  005e1	e8 00 00 00 00	 call	 _Command_ExitGame_f
  005e6	90		 npad	 1

; 461  : 		G_ClearExitGameFlag();

  005e7	e8 00 00 00 00	 call	 _G_ClearExitGameFlag
  005ec	90		 npad	 1
$LN58@D_Display:

; 462  : 	}
; 463  : 
; 464  : 	//
; 465  : 	// normal update
; 466  : 	//
; 467  : 	if (!wipe)

  005ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?wipe@?1??D_Display@@9@9, 0
  005f4	0f 85 74 01 00
	00		 jne	 $LN59@D_Display

; 468  : 	{
; 469  : 		if (cv_netstat.value)

  005fa	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_netstat+20, 0
  00601	0f 84 50 01 00
	00		 je	 $LN60@D_Display

; 470  : 		{
; 471  : 			char s[50];
; 472  : 			Net_GetNetStat();

  00607	e8 00 00 00 00	 call	 _Net_GetNetStat
  0060c	90		 npad	 1

; 473  : 
; 474  : 			s[sizeof s - 1] = '\0';

  0060d	b8 01 00 00 00	 mov	 eax, 1
  00612	6b c8 31	 imul	 ecx, eax, 49
  00615	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0061b	83 bd 74 ff ff
	ff 32		 cmp	 DWORD PTR $T1[ebp], 50	; 00000032H
  00622	73 02		 jae	 SHORT $LN66@D_Display
  00624	eb 06		 jmp	 SHORT $LN67@D_Display
$LN66@D_Display:
  00626	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0062b	90		 npad	 1
$LN67@D_Display:
  0062c	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00632	c6 44 15 b8 00	 mov	 BYTE PTR _s$2[ebp+edx], 0

; 475  : 
; 476  : 			_snprintf(s, sizeof s - 1, "get %d b/s", getbps);

  00637	a1 00 00 00 00	 mov	 eax, DWORD PTR _getbps
  0063c	50		 push	 eax
  0063d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OHGNJCAA@get?5?$CFd?5b?1s@
  00642	6a 31		 push	 49			; 00000031H
  00644	8d 4d b8	 lea	 ecx, DWORD PTR _s$2[ebp]
  00647	51		 push	 ecx
  00648	e8 00 00 00 00	 call	 ___snprintf
  0064d	83 c4 10	 add	 esp, 16			; 00000010H

; 477  : 			V_DrawString(BASEVIDWIDTH - V_StringWidth(s), BASEVIDHEIGHT-ST_HEIGHT-40, V_YELLOWMAP, s);

  00650	8d 45 b8	 lea	 eax, DWORD PTR _s$2[ebp]
  00653	50		 push	 eax
  00654	68 00 00 10 00	 push	 1048576			; 00100000H
  00659	68 80 00 00 00	 push	 128			; 00000080H
  0065e	8d 4d b8	 lea	 ecx, DWORD PTR _s$2[ebp]
  00661	51		 push	 ecx
  00662	e8 00 00 00 00	 call	 _V_StringWidth
  00667	83 c4 04	 add	 esp, 4
  0066a	ba 40 01 00 00	 mov	 edx, 320		; 00000140H
  0066f	2b d0		 sub	 edx, eax
  00671	52		 push	 edx
  00672	e8 00 00 00 00	 call	 _V_DrawString
  00677	83 c4 10	 add	 esp, 16			; 00000010H

; 478  : 			_snprintf(s, sizeof s - 1, "send %d b/s", sendbps);

  0067a	a1 00 00 00 00	 mov	 eax, DWORD PTR _sendbps
  0067f	50		 push	 eax
  00680	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KIKHLGMA@send?5?$CFd?5b?1s@
  00685	6a 31		 push	 49			; 00000031H
  00687	8d 4d b8	 lea	 ecx, DWORD PTR _s$2[ebp]
  0068a	51		 push	 ecx
  0068b	e8 00 00 00 00	 call	 ___snprintf
  00690	83 c4 10	 add	 esp, 16			; 00000010H

; 479  : 			V_DrawString(BASEVIDWIDTH - V_StringWidth(s), BASEVIDHEIGHT-ST_HEIGHT-30, V_YELLOWMAP, s);

  00693	8d 45 b8	 lea	 eax, DWORD PTR _s$2[ebp]
  00696	50		 push	 eax
  00697	68 00 00 10 00	 push	 1048576			; 00100000H
  0069c	68 8a 00 00 00	 push	 138			; 0000008aH
  006a1	8d 4d b8	 lea	 ecx, DWORD PTR _s$2[ebp]
  006a4	51		 push	 ecx
  006a5	e8 00 00 00 00	 call	 _V_StringWidth
  006aa	83 c4 04	 add	 esp, 4
  006ad	ba 40 01 00 00	 mov	 edx, 320		; 00000140H
  006b2	2b d0		 sub	 edx, eax
  006b4	52		 push	 edx
  006b5	e8 00 00 00 00	 call	 _V_DrawString
  006ba	83 c4 10	 add	 esp, 16			; 00000010H

; 480  : 			_snprintf(s, sizeof s - 1, "GameMiss %.2f%%", gamelostpercent);

  006bd	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR _gamelostpercent
  006c5	83 ec 08	 sub	 esp, 8
  006c8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IHEGKMH@GameMiss?5?$CF?42f?$CF?$CF@
  006d2	6a 31		 push	 49			; 00000031H
  006d4	8d 45 b8	 lea	 eax, DWORD PTR _s$2[ebp]
  006d7	50		 push	 eax
  006d8	e8 00 00 00 00	 call	 ___snprintf
  006dd	83 c4 14	 add	 esp, 20			; 00000014H

; 481  : 			V_DrawString(BASEVIDWIDTH - V_StringWidth(s), BASEVIDHEIGHT-ST_HEIGHT-20, V_YELLOWMAP, s);

  006e0	8d 45 b8	 lea	 eax, DWORD PTR _s$2[ebp]
  006e3	50		 push	 eax
  006e4	68 00 00 10 00	 push	 1048576			; 00100000H
  006e9	68 94 00 00 00	 push	 148			; 00000094H
  006ee	8d 4d b8	 lea	 ecx, DWORD PTR _s$2[ebp]
  006f1	51		 push	 ecx
  006f2	e8 00 00 00 00	 call	 _V_StringWidth
  006f7	83 c4 04	 add	 esp, 4
  006fa	ba 40 01 00 00	 mov	 edx, 320		; 00000140H
  006ff	2b d0		 sub	 edx, eax
  00701	52		 push	 edx
  00702	e8 00 00 00 00	 call	 _V_DrawString
  00707	83 c4 10	 add	 esp, 16			; 00000010H

; 482  : 			_snprintf(s, sizeof s - 1, "SysMiss %.2f%%", lostpercent);

  0070a	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR _lostpercent
  00712	83 ec 08	 sub	 esp, 8
  00715	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0071a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OPEGPGMK@SysMiss?5?$CF?42f?$CF?$CF@
  0071f	6a 31		 push	 49			; 00000031H
  00721	8d 45 b8	 lea	 eax, DWORD PTR _s$2[ebp]
  00724	50		 push	 eax
  00725	e8 00 00 00 00	 call	 ___snprintf
  0072a	83 c4 14	 add	 esp, 20			; 00000014H

; 483  : 			V_DrawString(BASEVIDWIDTH - V_StringWidth(s), BASEVIDHEIGHT-ST_HEIGHT-10, V_YELLOWMAP, s);

  0072d	8d 45 b8	 lea	 eax, DWORD PTR _s$2[ebp]
  00730	50		 push	 eax
  00731	68 00 00 10 00	 push	 1048576			; 00100000H
  00736	68 9e 00 00 00	 push	 158			; 0000009eH
  0073b	8d 4d b8	 lea	 ecx, DWORD PTR _s$2[ebp]
  0073e	51		 push	 ecx
  0073f	e8 00 00 00 00	 call	 _V_StringWidth
  00744	83 c4 04	 add	 esp, 4
  00747	ba 40 01 00 00	 mov	 edx, 320		; 00000140H
  0074c	2b d0		 sub	 edx, eax
  0074e	52		 push	 edx
  0074f	e8 00 00 00 00	 call	 _V_DrawString
  00754	83 c4 10	 add	 esp, 16			; 00000010H
$LN60@D_Display:

; 484  : 		}
; 485  : 
; 486  : 		I_FinishUpdate(); // page flip or blit buffer

  00757	e8 00 00 00 00	 call	 _I_FinishUpdate
  0075c	90		 npad	 1

; 487  : 
; 488  : 		if (takescreenshot) // Only take screenshots after drawing.

  0075d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _takescreenshot, 0
  00764	74 06		 je	 SHORT $LN61@D_Display

; 489  : 			M_DoScreenShot();

  00766	e8 00 00 00 00	 call	 _M_DoScreenShot
  0076b	90		 npad	 1
$LN61@D_Display:

; 490  : 
; 491  : 		return;

  0076c	eb 5c		 jmp	 SHORT $LN62@D_Display
$LN59@D_Display:

; 492  : 	}
; 493  : 
; 494  : 	//
; 495  : 	// wipe update
; 496  : 	//
; 497  : 
; 498  : 	if (rendermode != render_none)

  0076e	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00775	74 53		 je	 SHORT $LN62@D_Display

; 499  : 	{
; 500  : 		F_WipeEndScreen(0, 0, vid.width, vid.height);

  00777	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0077c	50		 push	 eax
  0077d	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00783	51		 push	 ecx
  00784	6a 00		 push	 0
  00786	6a 00		 push	 0
  00788	e8 00 00 00 00	 call	 _F_WipeEndScreen
  0078d	83 c4 10	 add	 esp, 16			; 00000010H

; 501  : 
; 502  : 		F_RunWipe(2*TICRATE, gamestate != GS_TIMEATTACK);

  00790	83 3d 00 00 00
	00 0b		 cmp	 DWORD PTR _gamestate, 11 ; 0000000bH
  00797	74 0c		 je	 SHORT $LN68@D_Display
  00799	c7 85 70 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv326[ebp], 1
  007a3	eb 0a		 jmp	 SHORT $LN69@D_Display
$LN68@D_Display:
  007a5	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv326[ebp], 0
$LN69@D_Display:
  007af	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv326[ebp]
  007b5	50		 push	 eax
  007b6	6a 46		 push	 70			; 00000046H
  007b8	e8 00 00 00 00	 call	 _F_RunWipe
  007bd	83 c4 08	 add	 esp, 8

; 503  : 
; 504  : 		WipeInAction = false;

  007c0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WipeInAction, 0
$LN62@D_Display:

; 505  : 	}
; 506  : }

  007ca	5f		 pop	 edi
  007cb	5e		 pop	 esi
  007cc	5b		 pop	 ebx
  007cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007d0	33 cd		 xor	 ecx, ebp
  007d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007d7	8b e5		 mov	 esp, ebp
  007d9	5d		 pop	 ebp
  007da	c3		 ret	 0
  007db	90		 npad	 1
$LN70@D_Display:
  007dc	00 00 00 00	 DD	 $LN16@D_Display
  007e0	00 00 00 00	 DD	 $LN22@D_Display
  007e4	00 00 00 00	 DD	 $LN31@D_Display
  007e8	00 00 00 00	 DD	 $LN28@D_Display
  007ec	00 00 00 00	 DD	 $LN24@D_Display
  007f0	00 00 00 00	 DD	 $LN24@D_Display
  007f4	00 00 00 00	 DD	 $LN26@D_Display
  007f8	00 00 00 00	 DD	 $LN27@D_Display
  007fc	00 00 00 00	 DD	 $LN30@D_Display
  00800	00 00 00 00	 DD	 $LN29@D_Display
_D_Display ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_StartTitle
_TEXT	SEGMENT
$T1 = -80						; size = 4
_mapname$2 = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_D_StartTitle PROC					; COMDAT

; 693  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 694  : 	if (netgame)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0001a	0f 84 86 00 00
	00		 je	 $LN2@D_StartTit

; 695  : 	{
; 696  : 		if (gametype == GT_COOP)

  00020	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00027	85 c0		 test	 eax, eax
  00029	75 79		 jne	 SHORT $LN4@D_StartTit

; 697  : 		{
; 698  : 			G_SetGamestate(GS_WAITINGPLAYERS); // hack to prevent a command repeat

  0002b	6a 0d		 push	 13			; 0000000dH
  0002d	e8 00 00 00 00	 call	 _G_SetGamestate
  00032	83 c4 04	 add	 esp, 4

; 699  : 
; 700  : 			if (server)

  00035	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  0003c	74 66		 je	 SHORT $LN4@D_StartTit

; 701  : 			{
; 702  : 				char mapname[6];
; 703  : 
; 704  : 				strlcpy(mapname, G_BuildMapName(spstage_start), sizeof (mapname));

  0003e	6a 06		 push	 6
  00040	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _spstage_start
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _G_BuildMapName
  0004d	83 c4 04	 add	 esp, 4
  00050	50		 push	 eax
  00051	8d 4d f4	 lea	 ecx, DWORD PTR _mapname$2[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _strlcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 705  : 				strlwr(mapname);

  0005d	8d 45 f4	 lea	 eax, DWORD PTR _mapname$2[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _strlwr
  00066	83 c4 04	 add	 esp, 4

; 706  : 				mapname[5] = '\0';

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	6b c8 05	 imul	 ecx, eax, 5
  00071	89 4d b0	 mov	 DWORD PTR $T1[ebp], ecx
  00074	83 7d b0 06	 cmp	 DWORD PTR $T1[ebp], 6
  00078	73 02		 jae	 SHORT $LN9@D_StartTit
  0007a	eb 06		 jmp	 SHORT $LN10@D_StartTit
$LN9@D_StartTit:
  0007c	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00081	90		 npad	 1
$LN10@D_StartTit:
  00082	8b 55 b0	 mov	 edx, DWORD PTR $T1[ebp]
  00085	c6 44 15 f4 00	 mov	 BYTE PTR _mapname$2[ebp+edx], 0

; 707  : 
; 708  : 				COM_BufAddText(va("map %s\n", mapname));

  0008a	8d 45 f4	 lea	 eax, DWORD PTR _mapname$2[ebp]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_07NKFJBOH@map?5?$CFs?6@
  00093	e8 00 00 00 00	 call	 _va
  00098	83 c4 08	 add	 esp, 8
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _COM_BufAddText
  000a1	83 c4 04	 add	 esp, 4
$LN4@D_StartTit:

; 709  : 			}
; 710  : 		}
; 711  : 
; 712  : 		return;

  000a4	eb 78		 jmp	 SHORT $LN7@D_StartTit
$LN2@D_StartTit:

; 713  : 	}
; 714  : 
; 715  : 	gameaction = ga_nothing;

  000a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gameaction, 0

; 716  : 	playerdeadview = false;

  000b0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _playerdeadview, 0

; 717  : 	displayplayer = consoleplayer = 0;

  000ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _consoleplayer, 0
  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _consoleplayer
  000c9	a3 00 00 00 00	 mov	 DWORD PTR _displayplayer, eax

; 718  : 	//demosequence = -1;
; 719  : 	gametype = GT_COOP;

  000ce	33 c0		 xor	 eax, eax
  000d0	66 a3 00 00 00
	00		 mov	 WORD PTR _gametype, ax

; 720  : 	paused = false;

  000d6	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _paused, 0

; 721  : 	advancedemo = false;

  000dd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _advancedemo, 0

; 722  : 	F_StartTitleScreen();

  000e7	e8 00 00 00 00	 call	 _F_StartTitleScreen
  000ec	90		 npad	 1

; 723  : 	CON_ToggleOff();

  000ed	e8 00 00 00 00	 call	 _CON_ToggleOff
  000f2	90		 npad	 1

; 724  : 
; 725  : 	// Reset the palette
; 726  : #ifdef HWRENDER
; 727  : 	if (rendermode == render_opengl)

  000f3	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _rendermode, 2
  000fa	75 0c		 jne	 SHORT $LN5@D_StartTit

; 728  : 		HWR_SetPaletteColor(0);

  000fc	6a 00		 push	 0
  000fe	e8 00 00 00 00	 call	 _HWR_SetPaletteColor
  00103	83 c4 04	 add	 esp, 4
  00106	eb 16		 jmp	 SHORT $LN7@D_StartTit
$LN5@D_StartTit:

; 729  : 	else
; 730  : #endif
; 731  : 	if (rendermode != render_none)

  00108	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0010f	74 0d		 je	 SHORT $LN7@D_StartTit

; 732  : 		V_SetPaletteLump("PLAYPAL");

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_07FLMOFAHC@PLAYPAL@
  00116	e8 00 00 00 00	 call	 _V_SetPaletteLump
  0011b	83 c4 04	 add	 esp, 4
$LN7@D_StartTit:

; 733  : }

  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
_D_StartTitle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_AdvanceDemo
_TEXT	SEGMENT
_D_AdvanceDemo PROC					; COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 682  : 	advancedemo = true;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _advancedemo, 1

; 683  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_D_AdvanceDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_PageDrawer
_TEXT	SEGMENT
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_dest$ = -8						; size = 4
_src$ = -4						; size = 4
_lumpname$ = 8						; size = 4
_D_PageDrawer PROC					; COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 639  : 	UINT8 *src;
; 640  : 	UINT8 *dest;
; 641  : 	INT32 x, y;
; 642  : 
; 643  : 	// software mode which uses generally lower resolutions doesn't look
; 644  : 	// good when the pic is scaled, so it fills space aorund with a pattern,
; 645  : 	// and the pic is only scaled to integer multiples (x2, x3...)
; 646  : 	(void)lumpname;
; 647  : 	if (rendermode == render_soft)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	0f 85 e2 00 00
	00		 jne	 $LN3@D_PageDraw

; 648  : 	{
; 649  : 		if ((vid.width > BASEVIDWIDTH) || (vid.height > BASEVIDHEIGHT))

  00016	81 3d 0c 00 00
	00 40 01 00 00	 cmp	 DWORD PTR _vid+12, 320	; 00000140H
  00020	7f 10		 jg	 SHORT $LN10@D_PageDraw
  00022	81 3d 10 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _vid+16, 200	; 000000c8H
  0002c	0f 8e c6 00 00
	00		 jle	 $LN3@D_PageDraw
$LN10@D_PageDraw:

; 650  : 		{
; 651  : 			src = scr_borderpatch;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _scr_borderpatch
  00037	89 45 fc	 mov	 DWORD PTR _src$[ebp], eax

; 652  : 			dest = screens[0];

  0003a	b8 04 00 00 00	 mov	 eax, 4
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  00048	89 55 f8	 mov	 DWORD PTR _dest$[ebp], edx

; 653  : 
; 654  : 			for (y = 0; y < vid.height; y++)

  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@D_PageDraw
$LN2@D_PageDraw:
  00054	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@D_PageDraw:
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00060	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00066	0f 8d 8c 00 00
	00		 jge	 $LN3@D_PageDraw

; 655  : 			{
; 656  : 				for (x = 0; x < vid.width/64; x++)

  0006c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@D_PageDraw
$LN5@D_PageDraw:
  00075	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@D_PageDraw:
  0007e	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00083	99		 cdq
  00084	83 e2 3f	 and	 edx, 63			; 0000003fH
  00087	03 c2		 add	 eax, edx
  00089	c1 f8 06	 sar	 eax, 6
  0008c	39 45 f4	 cmp	 DWORD PTR _x$[ebp], eax
  0008f	7d 27		 jge	 SHORT $LN6@D_PageDraw

; 657  : 				{
; 658  : 					M_Memcpy(dest, src+((y&63)<<6), 64);

  00091	6a 40		 push	 64			; 00000040H
  00093	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00096	83 e0 3f	 and	 eax, 63			; 0000003fH
  00099	c1 e0 06	 shl	 eax, 6
  0009c	03 45 fc	 add	 eax, DWORD PTR _src$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  000a3	51		 push	 ecx
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 659  : 					dest += 64;

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  000b0	83 c0 40	 add	 eax, 64			; 00000040H
  000b3	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 660  : 				}

  000b6	eb bd		 jmp	 SHORT $LN5@D_PageDraw
$LN6@D_PageDraw:

; 661  : 				if (vid.width & 63)

  000b8	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000bd	83 e0 3f	 and	 eax, 63			; 0000003fH
  000c0	74 31		 je	 SHORT $LN11@D_PageDraw

; 662  : 				{
; 663  : 					M_Memcpy(dest, src + ((y&63)<<6), vid.width&63);

  000c2	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000c7	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ca	50		 push	 eax
  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  000ce	83 e1 3f	 and	 ecx, 63			; 0000003fH
  000d1	c1 e1 06	 shl	 ecx, 6
  000d4	03 4d fc	 add	 ecx, DWORD PTR _src$[ebp]
  000d7	51		 push	 ecx
  000d8	8b 55 f8	 mov	 edx, DWORD PTR _dest$[ebp]
  000db	52		 push	 edx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 664  : 					dest += (vid.width&63);

  000e5	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000ea	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ed	03 45 f8	 add	 eax, DWORD PTR _dest$[ebp]
  000f0	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax
$LN11@D_PageDraw:

; 665  : 				}
; 666  : 			}

  000f3	e9 5c ff ff ff	 jmp	 $LN2@D_PageDraw
$LN3@D_PageDraw:

; 667  : 		}
; 668  : 	}
; 669  : 
; 670  : 	// if you wanna centre the pages it's here.
; 671  : 	// I think it's not so beautiful to have the pic centered,
; 672  : 	// so I leave it in the upper-left corner for now...
; 673  : 	//V_DrawPatch (0,0, 0, W_CachePatchName(pagename, PU_CACHE));
; 674  : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_D_PageDrawer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_PageTicker
_TEXT	SEGMENT
_D_PageTicker PROC					; COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 628  : 	if (--pagetic < 0)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _pagetic
  0000e	83 e8 01	 sub	 eax, 1
  00011	a3 00 00 00 00	 mov	 DWORD PTR _pagetic, eax
  00016	79 06		 jns	 SHORT $LN2@D_PageTick

; 629  : 		D_AdvanceDemo();

  00018	e8 00 00 00 00	 call	 _D_AdvanceDemo
  0001d	90		 npad	 1
$LN2@D_PageTick:

; 630  : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_D_PageTicker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_Home
_TEXT	SEGMENT
_testhome$1 = -12					; size = 4
_testhome$2 = -8					; size = 4
_userhome$ = -4						; size = 4
_D_Home	PROC						; COMDAT

; 1373 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1374 : 	const char *userhome = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _userhome$[ebp], 0

; 1375 : 
; 1376 : #ifdef ANDROID
; 1377 : 	return "/data/data/org.srb2/";
; 1378 : #endif
; 1379 : #ifdef _arch_dreamcast
; 1380 : 	char VMUHOME[] = "HOME=/vmu/a1";
; 1381 : 	putenv(VMUHOME); //don't use I_PutEnv
; 1382 : #endif
; 1383 : 
; 1384 : 	if (M_CheckParm("-home") && M_IsNextParm())

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_05GHINFEPM@?9home@
  00015	e8 00 00 00 00	 call	 _M_CheckParm
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 13		 je	 SHORT $LN2@D_Home
  00021	e8 00 00 00 00	 call	 _M_IsNextParm
  00026	85 c0		 test	 eax, eax
  00028	74 0a		 je	 SHORT $LN2@D_Home

; 1385 : 		userhome = M_GetNextParm();

  0002a	e8 00 00 00 00	 call	 _M_GetNextParm
  0002f	89 45 fc	 mov	 DWORD PTR _userhome$[ebp], eax
  00032	eb 2d		 jmp	 SHORT $LN5@D_Home
$LN2@D_Home:

; 1386 : 	else
; 1387 : 	{
; 1388 : #ifdef GP2X
; 1389 : 		usehome = false; //let use the CWD
; 1390 : 		return NULL;
; 1391 : #elif !(defined (__unix__) || defined(__APPLE__) || defined (UNIXCOMMON)) && !defined (__APPLE__) && !defined(_WIN32_WCE)
; 1392 : 		if (FIL_FileOK(CONFIGFILENAME))

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MFNMKHHD@config?4cfg@
  00039	e8 00 00 00 00	 call	 _FIL_FileOK
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	74 0c		 je	 SHORT $LN4@D_Home

; 1393 : 			usehome = false; // Let's NOT use home

  00045	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _usehome, 0
  0004f	eb 10		 jmp	 SHORT $LN5@D_Home
$LN4@D_Home:

; 1394 : 		else
; 1395 : #endif
; 1396 : 			userhome = I_GetEnv("HOME"); //Alam: my new HOME for srb2

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_04GHGFPGNC@HOME@
  00056	e8 00 00 00 00	 call	 _I_GetEnv
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 fc	 mov	 DWORD PTR _userhome$[ebp], eax
$LN5@D_Home:

; 1397 : 	}
; 1398 : #if defined (_WIN32) && !defined(_WIN32_WCE) //Alam: only Win32 have APPDATA and USERPROFILE
; 1399 : 	if (!userhome && usehome) //Alam: Still not?

  00061	83 7d fc 00	 cmp	 DWORD PTR _userhome$[ebp], 0
  00065	75 4f		 jne	 SHORT $LN7@D_Home
  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usehome, 0
  0006e	74 46		 je	 SHORT $LN7@D_Home

; 1400 : 	{
; 1401 : 		char *testhome = NULL;

  00070	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _testhome$2[ebp], 0

; 1402 : 		testhome = I_GetEnv("APPDATA");

  00077	68 00 00 00 00	 push	 OFFSET ??_C@_07FMLNDKFM@APPDATA@
  0007c	e8 00 00 00 00	 call	 _I_GetEnv
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f8	 mov	 DWORD PTR _testhome$2[ebp], eax

; 1403 : 		if (testhome != NULL
; 1404 : 			&& (FIL_FileOK(va("%s" PATHSEP "%s" PATHSEP CONFIGFILENAME, testhome, DEFAULTDIR))))

  00087	83 7d f8 00	 cmp	 DWORD PTR _testhome$2[ebp], 0
  0008b	74 29		 je	 SHORT $LN7@D_Home
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_04OALKLBNF@srb2@
  00092	8b 45 f8	 mov	 eax, DWORD PTR _testhome$2[ebp]
  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PHPDGCBL@?$CFs?2?$CFs?2config?4cfg@
  0009b	e8 00 00 00 00	 call	 _va
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _FIL_FileOK
  000a9	83 c4 04	 add	 esp, 4
  000ac	85 c0		 test	 eax, eax
  000ae	74 06		 je	 SHORT $LN7@D_Home

; 1405 : 		{
; 1406 : 			userhome = testhome;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _testhome$2[ebp]
  000b3	89 45 fc	 mov	 DWORD PTR _userhome$[ebp], eax
$LN7@D_Home:

; 1407 : 		}
; 1408 : 	}
; 1409 : #ifndef __CYGWIN__
; 1410 : 	if (!userhome && usehome) //Alam: All else fails?

  000b6	83 7d fc 00	 cmp	 DWORD PTR _userhome$[ebp], 0
  000ba	75 4f		 jne	 SHORT $LN9@D_Home
  000bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usehome, 0
  000c3	74 46		 je	 SHORT $LN9@D_Home

; 1411 : 	{
; 1412 : 		char *testhome = NULL;

  000c5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _testhome$1[ebp], 0

; 1413 : 		testhome = I_GetEnv("USERPROFILE");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DPNKMMOG@USERPROFILE@
  000d1	e8 00 00 00 00	 call	 _I_GetEnv
  000d6	83 c4 04	 add	 esp, 4
  000d9	89 45 f4	 mov	 DWORD PTR _testhome$1[ebp], eax

; 1414 : 		if (testhome != NULL
; 1415 : 			&& (FIL_FileOK(va("%s" PATHSEP "%s" PATHSEP CONFIGFILENAME, testhome, DEFAULTDIR))))

  000dc	83 7d f4 00	 cmp	 DWORD PTR _testhome$1[ebp], 0
  000e0	74 29		 je	 SHORT $LN9@D_Home
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_04OALKLBNF@srb2@
  000e7	8b 45 f4	 mov	 eax, DWORD PTR _testhome$1[ebp]
  000ea	50		 push	 eax
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PHPDGCBL@?$CFs?2?$CFs?2config?4cfg@
  000f0	e8 00 00 00 00	 call	 _va
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 _FIL_FileOK
  000fe	83 c4 04	 add	 esp, 4
  00101	85 c0		 test	 eax, eax
  00103	74 06		 je	 SHORT $LN9@D_Home

; 1416 : 		{
; 1417 : 			userhome = testhome;

  00105	8b 45 f4	 mov	 eax, DWORD PTR _testhome$1[ebp]
  00108	89 45 fc	 mov	 DWORD PTR _userhome$[ebp], eax
$LN9@D_Home:

; 1418 : 		}
; 1419 : 	}
; 1420 : #endif// !__CYGWIN__
; 1421 : #endif// _WIN32
; 1422 : 	if (usehome) return userhome;

  0010b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usehome, 0
  00112	74 07		 je	 SHORT $LN10@D_Home
  00114	8b 45 fc	 mov	 eax, DWORD PTR _userhome$[ebp]
  00117	eb 04		 jmp	 SHORT $LN11@D_Home
  00119	eb 02		 jmp	 SHORT $LN11@D_Home
$LN10@D_Home:

; 1423 : 	else return NULL;

  0011b	33 c0		 xor	 eax, eax
$LN11@D_Home:

; 1424 : }

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
_D_Home	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_ProcessEvents
_TEXT	SEGMENT
_ev$ = -4						; size = 4
_D_ProcessEvents PROC					; COMDAT

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 181  : 	event_t *ev;
; 182  : 
; 183  : 	for (; eventtail != eventhead; eventtail = (eventtail+1) & (MAXEVENTS-1))

  00009	eb 10		 jmp	 SHORT $LN4@D_ProcessE
$LN2@D_ProcessE:
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventtail
  00010	83 c0 01	 add	 eax, 1
  00013	83 e0 7f	 and	 eax, 127		; 0000007fH
  00016	a3 00 00 00 00	 mov	 DWORD PTR _eventtail, eax
$LN4@D_ProcessE:
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventtail
  00020	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _eventhead
  00026	74 69		 je	 SHORT $LN3@D_ProcessE

; 184  : 	{
; 185  : 		ev = &events[eventtail];

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventtail
  0002d	c1 e0 04	 shl	 eax, 4
  00030	05 00 00 00 00	 add	 eax, OFFSET _events
  00035	89 45 fc	 mov	 DWORD PTR _ev$[ebp], eax

; 186  : 
; 187  : 		if (gameaction == ga_nothing
; 188  : 			&& gamestate == GS_TITLESCREEN)

  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gameaction, 0
  0003f	75 1b		 jne	 SHORT $LN6@D_ProcessE
  00041	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR _gamestate, 9
  00048	75 12		 jne	 SHORT $LN6@D_ProcessE

; 189  : 		{
; 190  : 			if (cht_Responder(ev))

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _cht_Responder
  00053	83 c4 04	 add	 esp, 4
  00056	85 c0		 test	 eax, eax
  00058	74 02		 je	 SHORT $LN6@D_ProcessE

; 191  : 				continue;

  0005a	eb af		 jmp	 SHORT $LN2@D_ProcessE
$LN6@D_ProcessE:

; 192  : 		}
; 193  : 
; 194  : 		// Menu input
; 195  : 		if (M_Responder(ev))

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _M_Responder
  00065	83 c4 04	 add	 esp, 4
  00068	85 c0		 test	 eax, eax
  0006a	74 02		 je	 SHORT $LN7@D_ProcessE

; 196  : 			continue; // menu ate the event

  0006c	eb 9d		 jmp	 SHORT $LN2@D_ProcessE
$LN7@D_ProcessE:

; 197  : 
; 198  : 		// console input
; 199  : 		if (CON_Responder(ev))

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _CON_Responder
  00077	83 c4 04	 add	 esp, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 02		 je	 SHORT $LN8@D_ProcessE

; 200  : 			continue; // ate the event

  0007e	eb 8b		 jmp	 SHORT $LN2@D_ProcessE
$LN8@D_ProcessE:

; 201  : 
; 202  : 		G_Responder(ev);

  00080	8b 45 fc	 mov	 eax, DWORD PTR _ev$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _G_Responder
  00089	83 c4 04	 add	 esp, 4

; 203  : 	}

  0008c	e9 7a ff ff ff	 jmp	 $LN2@D_ProcessE
$LN3@D_ProcessE:

; 204  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_D_ProcessEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_PostEvent_end
_TEXT	SEGMENT
_D_PostEvent_end PROC					; COMDAT

; 172  : void D_PostEvent_end(void) {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_D_PostEvent_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_PostEvent
_TEXT	SEGMENT
_ev$ = 8						; size = 4
_D_PostEvent PROC					; COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 167  : 	events[eventhead] = *ev;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventhead
  0000e	c1 e0 04	 shl	 eax, 4
  00011	05 00 00 00 00	 add	 eax, OFFSET _events
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _ev$[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	89 10		 mov	 DWORD PTR [eax], edx
  0001d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00020	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00029	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0002c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 168  : 	eventhead = (eventhead+1) & (MAXEVENTS-1);

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _eventhead
  00034	83 c0 01	 add	 eax, 1
  00037	83 e0 7f	 and	 eax, 127		; 0000007fH
  0003a	a3 00 00 00 00	 mov	 DWORD PTR _eventhead, eax

; 169  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_D_PostEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_SRB2Main
_TEXT	SEGMENT
$T1 = -416						; size = 4
$T2 = -412						; size = 4
_sgametype$3 = -344					; size = 4
_newgametype$4 = -340					; size = 2
_j$5 = -336						; size = 4
_tmp$6 = -332						; size = 128
_s$7 = -204						; size = 4
_z$8 = -200						; size = 4
_z$9 = -196						; size = 4
_pw$10 = -192						; size = 4
_userhome$11 = -188					; size = 4
_autostart$ = -184					; size = 4
_pstartmap$ = -180					; size = 4
_title$ = -176						; size = 82
_srb2$ = -92						; size = 82
_p$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_D_SRB2Main PROC					; COMDAT

; 936  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 937  : 	INT32 p;
; 938  : 	char srb2[82]; // srb2 title banner
; 939  : 	char title[82];
; 940  : 
; 941  : 	INT32 pstartmap = 1;

  00016	c7 85 4c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _pstartmap$[ebp], 1

; 942  : 	boolean autostart = false;

  00020	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _autostart$[ebp], 0

; 943  : 
; 944  : 	// keep error messages until the final flush(stderr)
; 945  : #if !defined (PC_DOS) && !defined (_WIN32_WCE) && !defined(NOTERMIOS)
; 946  : 	if (setvbuf(stderr, NULL, _IOFBF, 1000))

  0002a	68 e8 03 00 00	 push	 1000			; 000003e8H
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 02		 push	 2
  00035	e8 00 00 00 00	 call	 ___acrt_iob_func
  0003a	83 c4 04	 add	 esp, 4
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _setvbuf
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	85 c0		 test	 eax, eax
  00048	74 1c		 je	 SHORT $LN15@D_SRB2Main

; 947  : 		CONS_Printf("%s", text[SETVBUF_FAIL]);

  0004a	b8 04 00 00 00	 mov	 eax, 4
  0004f	6b c8 52	 imul	 ecx, eax, 82
  00052	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00058	52		 push	 edx
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0005e	e8 00 00 00 00	 call	 _CONS_Printf
  00063	83 c4 08	 add	 esp, 8
$LN15@D_SRB2Main:

; 948  : #endif
; 949  : 
; 950  : 	// get parameters from a response file (eg: srb2 @parms.txt)
; 951  : 	M_FindResponseFile();

  00066	e8 00 00 00 00	 call	 _M_FindResponseFile
  0006b	90		 npad	 1

; 952  : 
; 953  : 	// MAINCFG is now taken care of where "OBJCTCFG" is handled
; 954  : 	G_LoadGameSettings();

  0006c	e8 00 00 00 00	 call	 _G_LoadGameSettings
  00071	90		 npad	 1

; 955  : 
; 956  : 	// identify the main IWAD file to use
; 957  : 	IdentifyVersion();

  00072	e8 00 00 00 00	 call	 _IdentifyVersion
  00077	90		 npad	 1

; 958  : 
; 959  : #if !defined (_WIN32_WCE) && !defined(NOTERMIOS)
; 960  : 	setbuf(stdout, NULL); // non-buffered output

  00078	6a 00		 push	 0
  0007a	6a 01		 push	 1
  0007c	e8 00 00 00 00	 call	 ___acrt_iob_func
  00081	83 c4 04	 add	 esp, 4
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _setbuf
  0008a	83 c4 08	 add	 esp, 8

; 961  : #endif
; 962  : 
; 963  : #if defined (_WIN32_WCE) //|| defined (_DEBUG) || defined (GP2X)
; 964  : 	devparm = !M_CheckParm("-nodebug");
; 965  : #else
; 966  : 	devparm = M_CheckParm("-debug");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_06OHOHKFPP@?9debug@
  00092	e8 00 00 00 00	 call	 _M_CheckParm
  00097	83 c4 04	 add	 esp, 4
  0009a	a3 00 00 00 00	 mov	 DWORD PTR _devparm, eax

; 967  : #endif
; 968  : 
; 969  : 	// for dedicated server
; 970  : #if !defined (_WINDOWS) //already check in win_main.c
; 971  : 	dedicated = M_CheckParm("-dedicated") != 0;
; 972  : #endif
; 973  : 
; 974  : 	strcpy(title, "Sonic Robo Blast 2");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HDCCHDPP@Sonic?5Robo?5Blast?52@
  000a4	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _title$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _strcpy
  000b0	83 c4 08	 add	 esp, 8

; 975  : 	strcpy(srb2, "Sonic Robo Blast 2");

  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HDCCHDPP@Sonic?5Robo?5Blast?52@
  000b8	8d 45 a4	 lea	 eax, DWORD PTR _srb2$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _strcpy
  000c1	83 c4 08	 add	 esp, 8

; 976  : 	D_MakeTitleString(srb2);

  000c4	8d 45 a4	 lea	 eax, DWORD PTR _srb2$[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _D_MakeTitleString
  000cd	83 c4 04	 add	 esp, 4

; 977  : 
; 978  : #ifdef PC_DOS
; 979  : 	D_Titlebar(srb2, title);
; 980  : #else
; 981  : 	CONS_Printf("SRB2"VERSIONSTRING"\n");

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KGDKGFOH@SRB2?5v2?40?47?6@
  000d5	e8 00 00 00 00	 call	 _CONS_Printf
  000da	83 c4 04	 add	 esp, 4

; 982  : #endif
; 983  : 
; 984  : #if defined (__OS2__) && !defined (SDL)
; 985  : 	// set PM window title
; 986  : 	_snprintf(pmData->title, sizeof (pmData->title),
; 987  : 		"Sonic Robo Blast 2" VERSIONSTRING ": %s",
; 988  : 		title);
; 989  : 	pmData->title[sizeof (pmData->title) - 1] = '\0';
; 990  : #endif
; 991  : 
; 992  : 	if (devparm)

  000dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  000e4	74 1c		 je	 SHORT $LN16@D_SRB2Main

; 993  : 		CONS_Printf("%s",text[D_DEVSTR]);

  000e6	b8 04 00 00 00	 mov	 eax, 4
  000eb	6b c8 00	 imul	 ecx, eax, 0
  000ee	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  000f4	52		 push	 edx
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000fa	e8 00 00 00 00	 call	 _CONS_Printf
  000ff	83 c4 08	 add	 esp, 8
$LN16@D_SRB2Main:

; 994  : 
; 995  : 	P_ClearMapHeaderInfo();

  00102	e8 00 00 00 00	 call	 _P_ClearMapHeaderInfo
  00107	90		 npad	 1

; 996  : 	D_InitCutsceneInfo();

  00108	e8 00 00 00 00	 call	 _D_InitCutsceneInfo
  0010d	90		 npad	 1

; 997  : 
; 998  : 	// default savegame
; 999  : 	strcpy(savegamename,text[NORM_SAVEI]);

  0010e	b8 04 00 00 00	 mov	 eax, 4
  00113	69 c8 70 01 00
	00		 imul	 ecx, eax, 368
  00119	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0011f	52		 push	 edx
  00120	68 00 00 00 00	 push	 OFFSET _savegamename
  00125	e8 00 00 00 00	 call	 _strcpy
  0012a	83 c4 08	 add	 esp, 8

; 1000 : 
; 1001 : 	{
; 1002 : 		const char *userhome = D_Home(); //Alam: path to home

  0012d	e8 00 00 00 00	 call	 _D_Home
  00132	89 85 44 ff ff
	ff		 mov	 DWORD PTR _userhome$11[ebp], eax

; 1003 : 
; 1004 : 		if (!userhome)

  00138	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _userhome$11[ebp], 0
  0013f	75 3e		 jne	 SHORT $LN17@D_SRB2Main

; 1005 : 		{
; 1006 : #if (defined (__unix__) || defined(__APPLE__) || defined (UNIXCOMMON)) && !defined (__CYGWIN__) && !defined (DC) && !defined (PSP) && !defined(GP2X)
; 1007 : 			I_Error("Please set $HOME to your home directory\n");
; 1008 : #elif defined (_WIN32_WCE) && 0
; 1009 : 			if (dedicated)
; 1010 : 				_snprintf(configfile, sizeof configfile, "/Storage Card/SRB2DEMO/d"CONFIGFILENAME);
; 1011 : 			else
; 1012 : 				_snprintf(configfile, sizeof configfile, "/Storage Card/SRB2DEMO/"CONFIGFILENAME);
; 1013 : #else
; 1014 : 			if (dedicated)

  00141	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00148	74 19		 je	 SHORT $LN19@D_SRB2Main

; 1015 : 				_snprintf(configfile, sizeof configfile, "d"CONFIGFILENAME);

  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PONKIHIH@dconfig?4cfg@
  0014f	68 80 00 00 00	 push	 128			; 00000080H
  00154	68 00 00 00 00	 push	 OFFSET _configfile
  00159	e8 00 00 00 00	 call	 ___snprintf
  0015e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00161	eb 17		 jmp	 SHORT $LN20@D_SRB2Main
$LN19@D_SRB2Main:

; 1016 : 			else
; 1017 : 				_snprintf(configfile, sizeof configfile, CONFIGFILENAME);

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MFNMKHHD@config?4cfg@
  00168	68 80 00 00 00	 push	 128			; 00000080H
  0016d	68 00 00 00 00	 push	 OFFSET _configfile
  00172	e8 00 00 00 00	 call	 ___snprintf
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@D_SRB2Main:

; 1018 : #endif
; 1019 : 		}

  0017a	e9 a6 00 00 00	 jmp	 $LN18@D_SRB2Main
$LN17@D_SRB2Main:

; 1020 : 		else
; 1021 : 		{
; 1022 : 			// use user specific config file
; 1023 : #ifdef DEFAULTDIR
; 1024 : 			_snprintf(srb2home, sizeof srb2home, "%s" PATHSEP DEFAULTDIR, userhome);

  0017f	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _userhome$11[ebp]
  00185	50		 push	 eax
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_07FEOAPHKJ@?$CFs?2srb2@
  0018b	68 00 01 00 00	 push	 256			; 00000100H
  00190	68 00 00 00 00	 push	 OFFSET _srb2home
  00195	e8 00 00 00 00	 call	 ___snprintf
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 1025 : 			_snprintf(downloaddir, sizeof downloaddir, "%s" PATHSEP "DOWNLOAD", srb2home);

  0019d	68 00 00 00 00	 push	 OFFSET _srb2home
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NLIKGJPG@?$CFs?2DOWNLOAD@
  001a7	68 00 01 00 00	 push	 256			; 00000100H
  001ac	68 00 00 00 00	 push	 OFFSET _downloaddir
  001b1	e8 00 00 00 00	 call	 ___snprintf
  001b6	83 c4 10	 add	 esp, 16			; 00000010H

; 1026 : 			if (dedicated)

  001b9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  001c0	74 1e		 je	 SHORT $LN21@D_SRB2Main

; 1027 : 				_snprintf(configfile, sizeof configfile, "%s" PATHSEP "d"CONFIGFILENAME, srb2home);

  001c2	68 00 00 00 00	 push	 OFFSET _srb2home
  001c7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OMKANKAO@?$CFs?2dconfig?4cfg@
  001cc	68 80 00 00 00	 push	 128			; 00000080H
  001d1	68 00 00 00 00	 push	 OFFSET _configfile
  001d6	e8 00 00 00 00	 call	 ___snprintf
  001db	83 c4 10	 add	 esp, 16			; 00000010H
  001de	eb 1c		 jmp	 SHORT $LN22@D_SRB2Main
$LN21@D_SRB2Main:

; 1028 : 			else
; 1029 : 				_snprintf(configfile, sizeof configfile, "%s" PATHSEP CONFIGFILENAME, srb2home);

  001e0	68 00 00 00 00	 push	 OFFSET _srb2home
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IGIHOCK@?$CFs?2config?4cfg@
  001ea	68 80 00 00 00	 push	 128			; 00000080H
  001ef	68 00 00 00 00	 push	 OFFSET _configfile
  001f4	e8 00 00 00 00	 call	 ___snprintf
  001f9	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@D_SRB2Main:

; 1030 : 
; 1031 : 			// can't use sprintf since there is %u in savegamename
; 1032 : 			strcatbf(savegamename, srb2home, PATHSEP);

  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  00201	68 00 00 00 00	 push	 OFFSET _srb2home
  00206	68 00 00 00 00	 push	 OFFSET _savegamename
  0020b	e8 00 00 00 00	 call	 _strcatbf
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1033 : 
; 1034 : 			I_mkdir(srb2home, 0700);

  00213	68 c0 01 00 00	 push	 448			; 000001c0H
  00218	68 00 00 00 00	 push	 OFFSET _srb2home
  0021d	e8 00 00 00 00	 call	 _I_mkdir
  00222	83 c4 08	 add	 esp, 8
$LN18@D_SRB2Main:

; 1035 : #else
; 1036 : 			_snprintf(srb2home, sizeof srb2home, "%s", userhome);
; 1037 : 			_snprintf(downloaddir, sizeof downloaddir, "%s", userhome);
; 1038 : 			if (dedicated)
; 1039 : 				_snprintf(configfile, sizeof configfile, "%s" PATHSEP "d"CONFIGFILENAME, userhome);
; 1040 : 			else
; 1041 : 				_snprintf(configfile, sizeof configfile, "%s" PATHSEP CONFIGFILENAME, userhome);
; 1042 : 
; 1043 : 			// can't use sprintf since there is %u in savegamename
; 1044 : 			strcatbf(savegamename, userhome, PATHSEP);
; 1045 : #endif
; 1046 : 		}
; 1047 : 
; 1048 : 		configfile[sizeof configfile - 1] = '\0';

  00225	b8 01 00 00 00	 mov	 eax, 1
  0022a	6b c8 7f	 imul	 ecx, eax, 127
  0022d	89 8d 64 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00233	81 bd 64 fe ff
	ff 80 00 00 00	 cmp	 DWORD PTR $T2[ebp], 128	; 00000080H
  0023d	73 02		 jae	 SHORT $LN70@D_SRB2Main
  0023f	eb 06		 jmp	 SHORT $LN71@D_SRB2Main
$LN70@D_SRB2Main:
  00241	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00246	90		 npad	 1
$LN71@D_SRB2Main:
  00247	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0024d	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _configfile[edx], 0

; 1049 : 
; 1050 : #ifdef _arch_dreamcast
; 1051 : 	strcpy(downloaddir, "/ram"); // the dreamcast's TMP
; 1052 : #endif
; 1053 : 	}
; 1054 : 
; 1055 : 	if (M_CheckParm("-password") && M_IsNextParm())

  00254	68 00 00 00 00	 push	 OFFSET ??_C@_09GEFBAANH@?9password@
  00259	e8 00 00 00 00	 call	 _M_CheckParm
  0025e	83 c4 04	 add	 esp, 4
  00261	85 c0		 test	 eax, eax
  00263	74 7e		 je	 SHORT $LN23@D_SRB2Main
  00265	e8 00 00 00 00	 call	 _M_IsNextParm
  0026a	85 c0		 test	 eax, eax
  0026c	74 75		 je	 SHORT $LN23@D_SRB2Main

; 1056 : 	{
; 1057 : 		const char *pw = M_GetNextParm();

  0026e	e8 00 00 00 00	 call	 _M_GetNextParm
  00273	89 85 40 ff ff
	ff		 mov	 DWORD PTR _pw$10[ebp], eax

; 1058 : 		strncpy(adminpassword, pw, 8);

  00279	6a 08		 push	 8
  0027b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _pw$10[ebp]
  00281	50		 push	 eax
  00282	68 00 00 00 00	 push	 OFFSET _adminpassword
  00287	e8 00 00 00 00	 call	 _strncpy
  0028c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1059 : 		if (strlen(pw) < 8)

  0028f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _pw$10[ebp]
  00295	50		 push	 eax
  00296	e8 00 00 00 00	 call	 _strlen
  0029b	83 c4 04	 add	 esp, 4
  0029e	83 f8 08	 cmp	 eax, 8
  002a1	73 3e		 jae	 SHORT $LN3@D_SRB2Main

; 1060 : 		{
; 1061 : 			size_t z;
; 1062 : 			for (z = strlen(pw); z < 8; z++)

  002a3	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _pw$10[ebp]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 _strlen
  002af	83 c4 04	 add	 esp, 4
  002b2	89 85 3c ff ff
	ff		 mov	 DWORD PTR _z$9[ebp], eax
  002b8	eb 0f		 jmp	 SHORT $LN4@D_SRB2Main
$LN2@D_SRB2Main:
  002ba	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _z$9[ebp]
  002c0	83 c0 01	 add	 eax, 1
  002c3	89 85 3c ff ff
	ff		 mov	 DWORD PTR _z$9[ebp], eax
$LN4@D_SRB2Main:
  002c9	83 bd 3c ff ff
	ff 08		 cmp	 DWORD PTR _z$9[ebp], 8
  002d0	73 0f		 jae	 SHORT $LN3@D_SRB2Main

; 1063 : 				adminpassword[z] = 'a';

  002d2	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _z$9[ebp]
  002d8	c6 80 00 00 00
	00 61		 mov	 BYTE PTR _adminpassword[eax], 97 ; 00000061H
  002df	eb d9		 jmp	 SHORT $LN2@D_SRB2Main
$LN3@D_SRB2Main:

; 1064 : 		}
; 1065 : 	}

  002e1	eb 4d		 jmp	 SHORT $LN6@D_SRB2Main
$LN23@D_SRB2Main:

; 1066 : 	else
; 1067 : 	{
; 1068 : 		size_t z;
; 1069 : 		srand((unsigned int)time(NULL));

  002e3	6a 00		 push	 0
  002e5	e8 00 00 00 00	 call	 _time
  002ea	83 c4 04	 add	 esp, 4
  002ed	50		 push	 eax
  002ee	e8 00 00 00 00	 call	 _srand
  002f3	83 c4 04	 add	 esp, 4

; 1070 : 		for (z = 0; z < 8; z++)

  002f6	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$8[ebp], 0
  00300	eb 0f		 jmp	 SHORT $LN7@D_SRB2Main
$LN5@D_SRB2Main:
  00302	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _z$8[ebp]
  00308	83 c0 01	 add	 eax, 1
  0030b	89 85 38 ff ff
	ff		 mov	 DWORD PTR _z$8[ebp], eax
$LN7@D_SRB2Main:
  00311	83 bd 38 ff ff
	ff 08		 cmp	 DWORD PTR _z$8[ebp], 8
  00318	73 16		 jae	 SHORT $LN6@D_SRB2Main

; 1071 : 			adminpassword[z] = (char)(rand() & 127);

  0031a	e8 00 00 00 00	 call	 _rand
  0031f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00322	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _z$8[ebp]
  00328	88 81 00 00 00
	00		 mov	 BYTE PTR _adminpassword[ecx], al
  0032e	eb d2		 jmp	 SHORT $LN5@D_SRB2Main
$LN6@D_SRB2Main:

; 1072 : 	}
; 1073 : 	adminpassword[8] = '\0';

  00330	b8 01 00 00 00	 mov	 eax, 1
  00335	c1 e0 03	 shl	 eax, 3
  00338	89 85 60 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0033e	83 bd 60 fe ff
	ff 09		 cmp	 DWORD PTR $T1[ebp], 9
  00345	73 02		 jae	 SHORT $LN72@D_SRB2Main
  00347	eb 06		 jmp	 SHORT $LN73@D_SRB2Main
$LN72@D_SRB2Main:
  00349	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0034e	90		 npad	 1
$LN73@D_SRB2Main:
  0034f	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00355	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _adminpassword[ecx], 0

; 1074 : 
; 1075 : 	// add any files specified on the command line with -file wadfile
; 1076 : 	// to the wad list
; 1077 : 	if (!(M_CheckParm("-connect")))

  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_08FABEHMEN@?9connect@
  00361	e8 00 00 00 00	 call	 _M_CheckParm
  00366	83 c4 04	 add	 esp, 4
  00369	85 c0		 test	 eax, eax
  0036b	75 5c		 jne	 SHORT $LN9@D_SRB2Main

; 1078 : 	{
; 1079 : 		if (M_CheckParm("-file"))

  0036d	68 00 00 00 00	 push	 OFFSET ??_C@_05PMBENPHG@?9file@
  00372	e8 00 00 00 00	 call	 _M_CheckParm
  00377	83 c4 04	 add	 esp, 4
  0037a	85 c0		 test	 eax, eax
  0037c	74 4b		 je	 SHORT $LN9@D_SRB2Main
$LN8@D_SRB2Main:

; 1080 : 		{
; 1081 : 			// the parms after p are wadfile/lump names,
; 1082 : 			// until end of parms or another - preceded parm
; 1083 : 			while (M_IsNextParm())

  0037e	e8 00 00 00 00	 call	 _M_IsNextParm
  00383	85 c0		 test	 eax, eax
  00385	74 42		 je	 SHORT $LN9@D_SRB2Main

; 1084 : 			{
; 1085 : 				const char *s = M_GetNextParm();

  00387	e8 00 00 00 00	 call	 _M_GetNextParm
  0038c	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$7[ebp], eax

; 1086 : 
; 1087 : 				if (s) // Check for NULL?

  00392	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _s$7[ebp], 0
  00399	74 2c		 je	 SHORT $LN28@D_SRB2Main

; 1088 : 				{
; 1089 : 					if (!W_VerifyNMUSlumps(s))

  0039b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _s$7[ebp]
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 _W_VerifyNMUSlumps
  003a7	83 c4 04	 add	 esp, 4
  003aa	85 c0		 test	 eax, eax
  003ac	75 0a		 jne	 SHORT $LN29@D_SRB2Main

; 1090 : 						modifiedgame = true;

  003ae	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _modifiedgame, 1
$LN29@D_SRB2Main:

; 1091 : 					D_AddFile(s);

  003b8	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _s$7[ebp]
  003be	50		 push	 eax
  003bf	e8 00 00 00 00	 call	 _D_AddFile
  003c4	83 c4 04	 add	 esp, 4
$LN28@D_SRB2Main:

; 1092 : 				}
; 1093 : 			}

  003c7	eb b5		 jmp	 SHORT $LN8@D_SRB2Main
$LN9@D_SRB2Main:

; 1094 : 		}
; 1095 : 	}
; 1096 : 
; 1097 : 	// get map from parms
; 1098 : 
; 1099 : 	if (M_CheckParm("-server") || dedicated)

  003c9	68 00 00 00 00	 push	 OFFSET ??_C@_07ODEEFNBO@?9server@
  003ce	e8 00 00 00 00	 call	 _M_CheckParm
  003d3	83 c4 04	 add	 esp, 4
  003d6	85 c0		 test	 eax, eax
  003d8	75 09		 jne	 SHORT $LN31@D_SRB2Main
  003da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  003e1	74 14		 je	 SHORT $LN30@D_SRB2Main
$LN31@D_SRB2Main:

; 1100 : 		netgame = server = true;

  003e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _server, 1
  003ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _server
  003f2	a3 00 00 00 00	 mov	 DWORD PTR _netgame, eax
$LN30@D_SRB2Main:

; 1101 : 
; 1102 : 	if (M_CheckParm("-warp") && M_IsNextParm())

  003f7	68 00 00 00 00	 push	 OFFSET ??_C@_05EFCNCBMF@?9warp@
  003fc	e8 00 00 00 00	 call	 _M_CheckParm
  00401	83 c4 04	 add	 esp, 4
  00404	85 c0		 test	 eax, eax
  00406	74 3b		 je	 SHORT $LN32@D_SRB2Main
  00408	e8 00 00 00 00	 call	 _M_IsNextParm
  0040d	85 c0		 test	 eax, eax
  0040f	74 32		 je	 SHORT $LN32@D_SRB2Main

; 1103 : 	{
; 1104 : 		pstartmap = atoi(M_GetNextParm());

  00411	e8 00 00 00 00	 call	 _M_GetNextParm
  00416	50		 push	 eax
  00417	e8 00 00 00 00	 call	 _atoi
  0041c	83 c4 04	 add	 esp, 4
  0041f	89 85 4c ff ff
	ff		 mov	 DWORD PTR _pstartmap$[ebp], eax

; 1105 : 		modifiedgame = true;

  00425	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _modifiedgame, 1

; 1106 : 		autostart = true;

  0042f	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _autostart$[ebp], 1

; 1107 : 		savemoddata = false;

  00439	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _savemoddata, 0
$LN32@D_SRB2Main:

; 1108 : 	}
; 1109 : 
; 1110 : 	CONS_Printf("%s",text[Z_INIT]);

  00443	b8 04 00 00 00	 mov	 eax, 4
  00448	69 c8 5f 01 00
	00		 imul	 ecx, eax, 351
  0044e	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00454	52		 push	 edx
  00455	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0045a	e8 00 00 00 00	 call	 _CONS_Printf
  0045f	83 c4 08	 add	 esp, 8

; 1111 : 	Z_Init();

  00462	e8 00 00 00 00	 call	 _Z_Init
  00467	90		 npad	 1

; 1112 : 
; 1113 : 	// adapt tables to SRB2's needs, including extra slots for dehacked file support
; 1114 : 	P_PatchInfoTables();

  00468	e8 00 00 00 00	 call	 _P_PatchInfoTables
  0046d	90		 npad	 1

; 1115 : 
; 1116 : 	CONS_Printf("%s",text[W_INIT]);

  0046e	b8 04 00 00 00	 mov	 eax, 4
  00473	69 c8 60 01 00
	00		 imul	 ecx, eax, 352
  00479	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0047f	52		 push	 edx
  00480	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00485	e8 00 00 00 00	 call	 _CONS_Printf
  0048a	83 c4 08	 add	 esp, 8

; 1117 : 
; 1118 : 	//---------------------------------------------------- READY TIME
; 1119 : 	// we need to check for dedicated before initialization of some subsystems
; 1120 : 
; 1121 : 	CONS_Printf("%s", text[I_STARTUPTIMER]);

  0048d	b8 04 00 00 00	 mov	 eax, 4
  00492	6b c8 50	 imul	 ecx, eax, 80
  00495	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0049b	52		 push	 edx
  0049c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  004a1	e8 00 00 00 00	 call	 _CONS_Printf
  004a6	83 c4 08	 add	 esp, 8

; 1122 : 	I_StartupTimer();

  004a9	e8 00 00 00 00	 call	 _I_StartupTimer
  004ae	90		 npad	 1

; 1123 : 
; 1124 : 	// Make backups of some SOCcable tables.
; 1125 : 	P_BackupTables();

  004af	e8 00 00 00 00	 call	 _P_BackupTables
  004b4	90		 npad	 1

; 1126 : 
; 1127 : 	// load wad, including the main wad file
; 1128 : 	if (!W_InitMultipleFiles(startupwadfiles))

  004b5	68 00 00 00 00	 push	 OFFSET _startupwadfiles
  004ba	e8 00 00 00 00	 call	 _W_InitMultipleFiles
  004bf	83 c4 04	 add	 esp, 4
  004c2	85 c0		 test	 eax, eax
  004c4	75 0d		 jne	 SHORT $LN33@D_SRB2Main

; 1129 : #ifdef _DEBUG
; 1130 : 		CONS_Error("A WAD file was not found or not valid\n");

  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DHJKLIKF@A?5WAD?5file?5was?5not?5found?5or?5not@
  004cb	e8 00 00 00 00	 call	 _CONS_Error
  004d0	83 c4 04	 add	 esp, 4
$LN33@D_SRB2Main:

; 1131 : #else
; 1132 : 		I_Error("A WAD file was not found or not valid\n");
; 1133 : #endif
; 1134 : 	D_CleanFile();

  004d3	e8 00 00 00 00	 call	 _D_CleanFile
  004d8	90		 npad	 1

; 1135 : 
; 1136 : 	// Check MD5s of autoloaded files
; 1137 : 	W_VerifyFileMD5(0, "1f698dd35bcedb04631568a84a97d72b"); // srb2.srb

  004d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DKMKKGPC@1f698dd35bcedb04631568a84a97d72@
  004de	6a 00		 push	 0
  004e0	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  004e5	83 c4 08	 add	 esp, 8

; 1138 : 	W_VerifyFileMD5(1, "86ae3f9179c64358d1c88060e41bd415"); // zones.dta

  004e8	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LMDFPOEK@86ae3f9179c64358d1c88060e41bd41@
  004ed	6a 01		 push	 1
  004ef	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  004f4	83 c4 08	 add	 esp, 8

; 1139 : 	W_VerifyFileMD5(2, "f699d4702b9b505db621e5ad5af4f352"); // sonic.plr

  004f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FMLIHMDO@f699d4702b9b505db621e5ad5af4f35@
  004fc	6a 02		 push	 2
  004fe	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  00503	83 c4 08	 add	 esp, 8

; 1140 : 	W_VerifyFileMD5(3, "dfbbc38080485c70a84a57bb734ceee9"); // tails.plr

  00506	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FBLENMKB@dfbbc38080485c70a84a57bb734ceee@
  0050b	6a 03		 push	 3
  0050d	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  00512	83 c4 08	 add	 esp, 8

; 1141 : 	W_VerifyFileMD5(4, "1ea958e2aee87b6995226a120ba3eaac"); // knux.plr

  00515	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HIPAAGLD@1ea958e2aee87b6995226a120ba3eaa@
  0051a	6a 04		 push	 4
  0051c	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  00521	83 c4 08	 add	 esp, 8

; 1142 : 	W_VerifyFileMD5(5, "8f702416c15060cd3c53c71b91116914"); // rings.wpn

  00524	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NMMBBOPJ@8f702416c15060cd3c53c71b9111691@
  00529	6a 05		 push	 5
  0052b	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  00530	83 c4 08	 add	 esp, 8

; 1143 : 	W_VerifyFileMD5(6, "6b1cf9b41e41a46ac58606dc6e7c9e05"); // drill.dta

  00533	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OKALEOH@6b1cf9b41e41a46ac58606dc6e7c9e0@
  00538	6a 06		 push	 6
  0053a	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  0053f	83 c4 08	 add	 esp, 8

; 1144 : 	W_VerifyFileMD5(7, "8d080c050ecf03691562aa7b60156fec"); // soar.dta

  00542	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IBDPGNAC@8d080c050ecf03691562aa7b60156fe@
  00547	6a 07		 push	 7
  00549	e8 00 00 00 00	 call	 _W_VerifyFileMD5
  0054e	83 c4 08	 add	 esp, 8

; 1145 : 
; 1146 : 	// don't check music.dta because people like to modify it, and it doesn't matter if they do
; 1147 : 	// ...except it does if they slip maps in there, and that's what W_VerifyNMUSlumps is for.
; 1148 : 
; 1149 : 
; 1150 : 	mainwads = 7; // there 7 wads not to unload

  00551	b8 07 00 00 00	 mov	 eax, 7
  00556	66 a3 00 00 00
	00		 mov	 WORD PTR _mainwads, ax

; 1151 : 
; 1152 : 	// Check and print which version is executed.
; 1153 : 	CONS_Printf("%s",text[COMERCIAL]);

  0055c	b8 04 00 00 00	 mov	 eax, 4
  00561	69 c8 5d 01 00
	00		 imul	 ecx, eax, 349
  00567	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0056d	52		 push	 edx
  0056e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00573	e8 00 00 00 00	 call	 _CONS_Printf
  00578	83 c4 08	 add	 esp, 8

; 1154 : 
; 1155 : 	cht_Init();

  0057b	e8 00 00 00 00	 call	 _cht_Init
  00580	90		 npad	 1

; 1156 : 
; 1157 : 	//---------------------------------------------------- READY SCREEN
; 1158 : 	// we need to check for dedicated before initialization of some subsystems
; 1159 : 
; 1160 : 	CONS_Printf("%s", text[I_STARTUPGRAPHICS]);

  00581	b8 04 00 00 00	 mov	 eax, 4
  00586	6b c8 51	 imul	 ecx, eax, 81
  00589	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0058f	52		 push	 edx
  00590	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00595	e8 00 00 00 00	 call	 _CONS_Printf
  0059a	83 c4 08	 add	 esp, 8

; 1161 : 	I_StartupGraphics();

  0059d	e8 00 00 00 00	 call	 _I_StartupGraphics
  005a2	90		 npad	 1

; 1162 : 
; 1163 : 	//--------------------------------------------------------- CONSOLE
; 1164 : 	// setup loading screen
; 1165 : 	SCR_Startup();

  005a3	e8 00 00 00 00	 call	 _SCR_Startup
  005a8	90		 npad	 1

; 1166 : 
; 1167 : 	// we need the font of the console
; 1168 : 	CONS_Printf("%s",text[HU_INIT]);

  005a9	b8 04 00 00 00	 mov	 eax, 4
  005ae	69 c8 67 01 00
	00		 imul	 ecx, eax, 359
  005b4	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  005ba	52		 push	 edx
  005bb	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  005c0	e8 00 00 00 00	 call	 _CONS_Printf
  005c5	83 c4 08	 add	 esp, 8

; 1169 : 	HU_Init();

  005c8	e8 00 00 00 00	 call	 _HU_Init
  005cd	90		 npad	 1

; 1170 : 
; 1171 : 	COM_Init();

  005ce	e8 00 00 00 00	 call	 _COM_Init
  005d3	90		 npad	 1

; 1172 : 	CON_Init();

  005d4	e8 00 00 00 00	 call	 _CON_Init
  005d9	90		 npad	 1

; 1173 : 
; 1174 : 	D_RegisterServerCommands();

  005da	e8 00 00 00 00	 call	 _D_RegisterServerCommands
  005df	90		 npad	 1

; 1175 : 	D_RegisterClientCommands(); // be sure that this is called before D_CheckNetGame

  005e0	e8 00 00 00 00	 call	 _D_RegisterClientCommands
  005e5	90		 npad	 1

; 1176 : 	R_RegisterEngineStuff();

  005e6	e8 00 00 00 00	 call	 _R_RegisterEngineStuff
  005eb	90		 npad	 1

; 1177 : 	S_RegisterSoundStuff();

  005ec	e8 00 00 00 00	 call	 _S_RegisterSoundStuff
  005f1	90		 npad	 1

; 1178 : 
; 1179 : 	I_RegisterSysCommands();

  005f2	e8 00 00 00 00	 call	 _I_RegisterSysCommands
  005f7	90		 npad	 1

; 1180 : 
; 1181 : 	//--------------------------------------------------------- CONFIG.CFG
; 1182 : 	M_FirstLoadConfig(); // WARNING : this do a "COM_BufExecute()"

  005f8	e8 00 00 00 00	 call	 _M_FirstLoadConfig
  005fd	90		 npad	 1

; 1183 : 
; 1184 : 	if (!M_CheckParm("-resetdata"))

  005fe	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JGOMHMOK@?9resetdata@
  00603	e8 00 00 00 00	 call	 _M_CheckParm
  00608	83 c4 04	 add	 esp, 4
  0060b	85 c0		 test	 eax, eax
  0060d	75 06		 jne	 SHORT $LN34@D_SRB2Main

; 1185 : 		G_LoadGameData();

  0060f	e8 00 00 00 00	 call	 _G_LoadGameData
  00614	90		 npad	 1
$LN34@D_SRB2Main:

; 1186 : 
; 1187 : #if defined (__unix__) || defined (UNIXCOMMON) || defined (SDL)
; 1188 : 	VID_PrepareModeList(); // Regenerate Modelist according to cv_fullscreen
; 1189 : #endif
; 1190 : 
; 1191 : 	// set user default mode or mode set at cmdline
; 1192 : 	SCR_CheckDefaultMode();

  00615	e8 00 00 00 00	 call	 _SCR_CheckDefaultMode
  0061a	90		 npad	 1

; 1193 : 
; 1194 : 	wipegamestate = gamestate;

  0061b	a1 00 00 00 00	 mov	 eax, DWORD PTR _gamestate
  00620	a3 00 00 00 00	 mov	 DWORD PTR _wipegamestate, eax

; 1195 : 
; 1196 : 	P_InitMapHeaders();

  00625	e8 00 00 00 00	 call	 _P_InitMapHeaders
  0062a	90		 npad	 1

; 1197 : 	savedata.lives = 0; // flag this as not-used

  0062b	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _savedata+8, 0

; 1198 : 
; 1199 : 	//------------------------------------------------ COMMAND LINE PARAMS
; 1200 : 
; 1201 : 	// Initialize CD-Audio
; 1202 : 	if (M_CheckParm("-usecd") && !dedicated)

  00635	68 00 00 00 00	 push	 OFFSET ??_C@_06GOJMKCFL@?9usecd@
  0063a	e8 00 00 00 00	 call	 _M_CheckParm
  0063f	83 c4 04	 add	 esp, 4
  00642	85 c0		 test	 eax, eax
  00644	74 0f		 je	 SHORT $LN35@D_SRB2Main
  00646	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0064d	75 06		 jne	 SHORT $LN35@D_SRB2Main

; 1203 : 		I_InitCD();

  0064f	e8 00 00 00 00	 call	 _I_InitCD
  00654	90		 npad	 1
$LN35@D_SRB2Main:

; 1204 : 
; 1205 : 	if (M_CheckParm("-nodownloading"))

  00655	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CBBFLDFP@?9nodownloading@
  0065a	e8 00 00 00 00	 call	 _M_CheckParm
  0065f	83 c4 04	 add	 esp, 4
  00662	85 c0		 test	 eax, eax
  00664	74 0d		 je	 SHORT $LN36@D_SRB2Main

; 1206 : 		COM_BufAddText("downloading 0\n");

  00666	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CACMCMEM@downloading?50?6@
  0066b	e8 00 00 00 00	 call	 _COM_BufAddText
  00670	83 c4 04	 add	 esp, 4
$LN36@D_SRB2Main:

; 1207 : 
; 1208 : 	CONS_Printf("%s",text[M_INIT]);

  00673	b8 04 00 00 00	 mov	 eax, 4
  00678	69 c8 61 01 00
	00		 imul	 ecx, eax, 353
  0067e	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00684	52		 push	 edx
  00685	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0068a	e8 00 00 00 00	 call	 _CONS_Printf
  0068f	83 c4 08	 add	 esp, 8

; 1209 : 	M_Init();

  00692	e8 00 00 00 00	 call	 _M_Init
  00697	90		 npad	 1

; 1210 : 
; 1211 : 	CONS_Printf("%s",text[R_INIT]);

  00698	b8 04 00 00 00	 mov	 eax, 4
  0069d	69 c8 62 01 00
	00		 imul	 ecx, eax, 354
  006a3	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  006a9	52		 push	 edx
  006aa	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  006af	e8 00 00 00 00	 call	 _CONS_Printf
  006b4	83 c4 08	 add	 esp, 8

; 1212 : 	R_Init();

  006b7	e8 00 00 00 00	 call	 _R_Init
  006bc	90		 npad	 1

; 1213 : 
; 1214 : 	// setting up sound
; 1215 : 	CONS_Printf("%s",text[S_SETSOUND]);

  006bd	b8 04 00 00 00	 mov	 eax, 4
  006c2	69 c8 66 01 00
	00		 imul	 ecx, eax, 358
  006c8	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  006ce	52		 push	 edx
  006cf	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  006d4	e8 00 00 00 00	 call	 _CONS_Printf
  006d9	83 c4 08	 add	 esp, 8

; 1216 : 	if (M_CheckParm("-nosound"))

  006dc	68 00 00 00 00	 push	 OFFSET ??_C@_08FLDKIHPE@?9nosound@
  006e1	e8 00 00 00 00	 call	 _M_CheckParm
  006e6	83 c4 04	 add	 esp, 4
  006e9	85 c0		 test	 eax, eax
  006eb	74 0a		 je	 SHORT $LN37@D_SRB2Main

; 1217 : 		nosound = true;

  006ed	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nosound, 1
$LN37@D_SRB2Main:

; 1218 : 	if (M_CheckParm("-nomusic")) // combines -nomidimusic and -nodigmusic

  006f7	68 00 00 00 00	 push	 OFFSET ??_C@_08CHNDLEKC@?9nomusic@
  006fc	e8 00 00 00 00	 call	 _M_CheckParm
  00701	83 c4 04	 add	 esp, 4
  00704	85 c0		 test	 eax, eax
  00706	74 16		 je	 SHORT $LN38@D_SRB2Main

; 1219 : 		nomidimusic = nodigimusic = true;

  00708	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nodigimusic, 1
  00712	a1 00 00 00 00	 mov	 eax, DWORD PTR _nodigimusic
  00717	a3 00 00 00 00	 mov	 DWORD PTR _nomidimusic, eax
  0071c	eb 36		 jmp	 SHORT $LN41@D_SRB2Main
$LN38@D_SRB2Main:

; 1220 : 	else
; 1221 : 	{
; 1222 : 		if (M_CheckParm("-nomidimusic"))

  0071e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GNMEOENE@?9nomidimusic@
  00723	e8 00 00 00 00	 call	 _M_CheckParm
  00728	83 c4 04	 add	 esp, 4
  0072b	85 c0		 test	 eax, eax
  0072d	74 0a		 je	 SHORT $LN40@D_SRB2Main

; 1223 : 			nomidimusic = true; ; // WARNING: DOS version initmusic in I_StartupSound

  0072f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nomidimusic, 1
$LN40@D_SRB2Main:

; 1224 : 		if (M_CheckParm("-nodigmusic"))

  00739	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FFMEKMJE@?9nodigmusic@
  0073e	e8 00 00 00 00	 call	 _M_CheckParm
  00743	83 c4 04	 add	 esp, 4
  00746	85 c0		 test	 eax, eax
  00748	74 0a		 je	 SHORT $LN41@D_SRB2Main

; 1225 : 			nodigimusic = true; // WARNING: DOS version initmusic in I_StartupSound

  0074a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nodigimusic, 1
$LN41@D_SRB2Main:

; 1226 : 	}
; 1227 : 	I_StartupSound();

  00754	e8 00 00 00 00	 call	 _I_StartupSound
  00759	90		 npad	 1

; 1228 : 	I_InitMusic();

  0075a	e8 00 00 00 00	 call	 _I_InitMusic
  0075f	90		 npad	 1

; 1229 : 	S_Init(cv_soundvolume.value, cv_digmusicvolume.value, cv_midimusicvolume.value);

  00760	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_midimusicvolume+20
  00765	50		 push	 eax
  00766	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _cv_digmusicvolume+20
  0076c	51		 push	 ecx
  0076d	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _cv_soundvolume+20
  00773	52		 push	 edx
  00774	e8 00 00 00 00	 call	 _S_Init
  00779	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1230 : 
; 1231 : 	CONS_Printf("%s",text[ST_INIT]);

  0077c	b8 04 00 00 00	 mov	 eax, 4
  00781	69 c8 68 01 00
	00		 imul	 ecx, eax, 360
  00787	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0078d	52		 push	 edx
  0078e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00793	e8 00 00 00 00	 call	 _CONS_Printf
  00798	83 c4 08	 add	 esp, 8

; 1232 : 	ST_Init();

  0079b	e8 00 00 00 00	 call	 _ST_Init
  007a0	90		 npad	 1

; 1233 : 
; 1234 : 	if (M_CheckParm("-internetserver"))

  007a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIODIGNO@?9internetserver@
  007a6	e8 00 00 00 00	 call	 _M_CheckParm
  007ab	83 c4 04	 add	 esp, 4
  007ae	85 c0		 test	 eax, eax
  007b0	74 0f		 je	 SHORT $LN42@D_SRB2Main

; 1235 : 		CV_SetValue(&cv_internetserver, 1);

  007b2	6a 01		 push	 1
  007b4	68 00 00 00 00	 push	 OFFSET _cv_internetserver
  007b9	e8 00 00 00 00	 call	 _CV_SetValue
  007be	83 c4 08	 add	 esp, 8
$LN42@D_SRB2Main:

; 1236 : 
; 1237 : 	// init all NETWORK
; 1238 : 	CONS_Printf("%s",text[D_CHECKNET]);

  007c1	b8 04 00 00 00	 mov	 eax, 4
  007c6	69 c8 65 01 00
	00		 imul	 ecx, eax, 357
  007cc	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  007d2	52		 push	 edx
  007d3	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  007d8	e8 00 00 00 00	 call	 _CONS_Printf
  007dd	83 c4 08	 add	 esp, 8

; 1239 : 	if (D_CheckNetGame())

  007e0	e8 00 00 00 00	 call	 _D_CheckNetGame
  007e5	85 c0		 test	 eax, eax
  007e7	74 0a		 je	 SHORT $LN43@D_SRB2Main

; 1240 : 		autostart = true;

  007e9	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _autostart$[ebp], 1
$LN43@D_SRB2Main:

; 1241 : 
; 1242 : 	// check for a driver that wants intermission stats
; 1243 : 	// start the apropriate game based on parms
; 1244 : 	if (M_CheckParm("-record") && M_IsNextParm())

  007f3	68 00 00 00 00	 push	 OFFSET ??_C@_07DAFDPAKP@?9record@
  007f8	e8 00 00 00 00	 call	 _M_CheckParm
  007fd	83 c4 04	 add	 esp, 4
  00800	85 c0		 test	 eax, eax
  00802	74 21		 je	 SHORT $LN44@D_SRB2Main
  00804	e8 00 00 00 00	 call	 _M_IsNextParm
  00809	85 c0		 test	 eax, eax
  0080b	74 18		 je	 SHORT $LN44@D_SRB2Main

; 1245 : 	{
; 1246 : 		G_RecordDemo(M_GetNextParm());

  0080d	e8 00 00 00 00	 call	 _M_GetNextParm
  00812	50		 push	 eax
  00813	e8 00 00 00 00	 call	 _G_RecordDemo
  00818	83 c4 04	 add	 esp, 4

; 1247 : 		autostart = true;

  0081b	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _autostart$[ebp], 1
$LN44@D_SRB2Main:

; 1248 : 	}
; 1249 : 
; 1250 : 	p = M_CheckParm("-timetic");

  00825	68 00 00 00 00	 push	 OFFSET ??_C@_08FEEPADEA@?9timetic@
  0082a	e8 00 00 00 00	 call	 _M_CheckParm
  0082f	83 c4 04	 add	 esp, 4
  00832	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 1251 : 	if (p)

  00835	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00839	74 12		 je	 SHORT $LN45@D_SRB2Main

; 1252 : 		CV_Set(&cv_timetic, "On");

  0083b	68 00 00 00 00	 push	 OFFSET ??_C@_02IAAGKKDJ@On@
  00840	68 00 00 00 00	 push	 OFFSET _cv_timetic
  00845	e8 00 00 00 00	 call	 _CV_Set
  0084a	83 c4 08	 add	 esp, 8
$LN45@D_SRB2Main:

; 1253 : 
; 1254 : 	if (!autostart)

  0084d	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _autostart$[ebp], 0
  00854	75 06		 jne	 SHORT $LN46@D_SRB2Main

; 1255 : 		M_PushSpecialParameters(); // push all "+" parameters at the command buffer

  00856	e8 00 00 00 00	 call	 _M_PushSpecialParameters
  0085b	90		 npad	 1
$LN46@D_SRB2Main:

; 1256 : 
; 1257 : 	// demo doesn't need anymore to be added with D_AddFile()
; 1258 : 	p = M_CheckParm("-playdemo");

  0085c	68 00 00 00 00	 push	 OFFSET ??_C@_09BCPNILDH@?9playdemo@
  00861	e8 00 00 00 00	 call	 _M_CheckParm
  00866	83 c4 04	 add	 esp, 4
  00869	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 1259 : 	if (!p)

  0086c	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00870	75 10		 jne	 SHORT $LN47@D_SRB2Main

; 1260 : 		p = M_CheckParm("-timedemo");

  00872	68 00 00 00 00	 push	 OFFSET ??_C@_09LEEFHMML@?9timedemo@
  00877	e8 00 00 00 00	 call	 _M_CheckParm
  0087c	83 c4 04	 add	 esp, 4
  0087f	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
$LN47@D_SRB2Main:

; 1261 : 	if (p && M_IsNextParm())

  00882	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00886	0f 84 dc 00 00
	00		 je	 $LN48@D_SRB2Main
  0088c	e8 00 00 00 00	 call	 _M_IsNextParm
  00891	85 c0		 test	 eax, eax
  00893	0f 84 cf 00 00
	00		 je	 $LN48@D_SRB2Main

; 1262 : 	{
; 1263 : 		char tmp[MAX_WADPATH];
; 1264 : 		// add .lmp to identify the EXTERNAL demo file
; 1265 : 		// it is NOT possible to play an internal demo using -playdemo,
; 1266 : 		// rather push a playdemo command.. to do.
; 1267 : 
; 1268 : 		strcpy(tmp, M_GetNextParm());

  00899	e8 00 00 00 00	 call	 _M_GetNextParm
  0089e	50		 push	 eax
  0089f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  008a5	50		 push	 eax
  008a6	e8 00 00 00 00	 call	 _strcpy
  008ab	83 c4 08	 add	 esp, 8
$LN10@D_SRB2Main:

; 1269 : 		// get spaced filename or directory
; 1270 : 		while (M_IsNextParm())

  008ae	e8 00 00 00 00	 call	 _M_IsNextParm
  008b3	85 c0		 test	 eax, eax
  008b5	74 2b		 je	 SHORT $LN11@D_SRB2Main

; 1271 : 		{
; 1272 : 			strcat(tmp, " ");

  008b7	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  008bc	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  008c2	50		 push	 eax
  008c3	e8 00 00 00 00	 call	 _strcat
  008c8	83 c4 08	 add	 esp, 8

; 1273 : 			strcat(tmp, M_GetNextParm());

  008cb	e8 00 00 00 00	 call	 _M_GetNextParm
  008d0	50		 push	 eax
  008d1	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  008d7	50		 push	 eax
  008d8	e8 00 00 00 00	 call	 _strcat
  008dd	83 c4 08	 add	 esp, 8

; 1274 : 		}

  008e0	eb cc		 jmp	 SHORT $LN10@D_SRB2Main
$LN11@D_SRB2Main:

; 1275 : 
; 1276 : 		FIL_DefaultExtension(tmp, ".lmp");

  008e2	68 00 00 00 00	 push	 OFFSET ??_C@_04FJOMPALJ@?4lmp@
  008e7	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  008ed	50		 push	 eax
  008ee	e8 00 00 00 00	 call	 _FIL_DefaultExtension
  008f3	83 c4 08	 add	 esp, 8

; 1277 : 
; 1278 : 		CONS_Printf(text[PLAYINGDEMO], tmp);

  008f6	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  008fc	50		 push	 eax
  008fd	b9 04 00 00 00	 mov	 ecx, 4
  00902	6b d1 53	 imul	 edx, ecx, 83
  00905	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0090b	50		 push	 eax
  0090c	e8 00 00 00 00	 call	 _CONS_Printf
  00911	83 c4 08	 add	 esp, 8

; 1279 : 
; 1280 : 		if (M_CheckParm("-playdemo"))

  00914	68 00 00 00 00	 push	 OFFSET ??_C@_09BCPNILDH@?9playdemo@
  00919	e8 00 00 00 00	 call	 _M_CheckParm
  0091e	83 c4 04	 add	 esp, 4
  00921	85 c0		 test	 eax, eax
  00923	74 1b		 je	 SHORT $LN49@D_SRB2Main

; 1281 : 		{
; 1282 : 			singledemo = true; // quit after one demo

  00925	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _singledemo, 1

; 1283 : 			G_DeferedPlayDemo(tmp);

  0092f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  00935	50		 push	 eax
  00936	e8 00 00 00 00	 call	 _G_DeferedPlayDemo
  0093b	83 c4 04	 add	 esp, 4

; 1284 : 		}

  0093e	eb 0f		 jmp	 SHORT $LN50@D_SRB2Main
$LN49@D_SRB2Main:

; 1285 : 		else
; 1286 : 			G_TimeDemo(tmp);

  00940	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _tmp$6[ebp]
  00946	50		 push	 eax
  00947	e8 00 00 00 00	 call	 _G_TimeDemo
  0094c	83 c4 04	 add	 esp, 4
$LN50@D_SRB2Main:

; 1287 : 
; 1288 : 		G_SetGamestate(GS_NULL);

  0094f	6a 00		 push	 0
  00951	e8 00 00 00 00	 call	 _G_SetGamestate
  00956	83 c4 04	 add	 esp, 4

; 1289 : 		wipegamestate = GS_NULL;

  00959	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wipegamestate, 0

; 1290 : 		return;

  00963	e9 d2 02 00 00	 jmp	 $LN68@D_SRB2Main
$LN48@D_SRB2Main:

; 1291 : 	}
; 1292 : 
; 1293 : 	if (M_CheckParm("-ultimatemode"))

  00968	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BJJAGKNO@?9ultimatemode@
  0096d	e8 00 00 00 00	 call	 _M_CheckParm
  00972	83 c4 04	 add	 esp, 4
  00975	85 c0		 test	 eax, eax
  00977	74 14		 je	 SHORT $LN51@D_SRB2Main

; 1294 : 	{
; 1295 : 		autostart = ultimatemode = true;

  00979	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _ultimatemode, 1
  00980	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _ultimatemode
  00987	89 85 48 ff ff
	ff		 mov	 DWORD PTR _autostart$[ebp], eax
$LN51@D_SRB2Main:

; 1296 : 	}
; 1297 : 
; 1298 : 	if (autostart || netgame || M_CheckParm("+connect") || M_CheckParm("-connect"))

  0098d	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _autostart$[ebp], 0
  00994	75 2f		 jne	 SHORT $LN54@D_SRB2Main
  00996	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0099d	75 26		 jne	 SHORT $LN54@D_SRB2Main
  0099f	68 00 00 00 00	 push	 OFFSET ??_C@_08CDAOAFMH@?$CLconnect@
  009a4	e8 00 00 00 00	 call	 _M_CheckParm
  009a9	83 c4 04	 add	 esp, 4
  009ac	85 c0		 test	 eax, eax
  009ae	75 15		 jne	 SHORT $LN54@D_SRB2Main
  009b0	68 00 00 00 00	 push	 OFFSET ??_C@_08FABEHMEN@?9connect@
  009b5	e8 00 00 00 00	 call	 _M_CheckParm
  009ba	83 c4 04	 add	 esp, 4
  009bd	85 c0		 test	 eax, eax
  009bf	0f 84 23 02 00
	00		 je	 $LN52@D_SRB2Main
$LN54@D_SRB2Main:

; 1299 : 	{
; 1300 : 		gameaction = ga_nothing;

  009c5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gameaction, 0

; 1301 : 
; 1302 : 		CV_ClearChangedFlags();

  009cf	e8 00 00 00 00	 call	 _CV_ClearChangedFlags
  009d4	90		 npad	 1

; 1303 : 
; 1304 : 		// Do this here so if you run SRB2 with eg +timelimit 5, the time limit counts
; 1305 : 		// as having been modified for the first game.
; 1306 : 		M_PushSpecialParameters(); // push all "+" parameter at the command buffer

  009d5	e8 00 00 00 00	 call	 _M_PushSpecialParameters
  009da	90		 npad	 1

; 1307 : 
; 1308 : 		if (M_CheckParm("-gametype") && M_IsNextParm())

  009db	68 00 00 00 00	 push	 OFFSET ??_C@_09GGNDLOMG@?9gametype@
  009e0	e8 00 00 00 00	 call	 _M_CheckParm
  009e5	83 c4 04	 add	 esp, 4
  009e8	85 c0		 test	 eax, eax
  009ea	0f 84 93 01 00
	00		 je	 $LN65@D_SRB2Main
  009f0	e8 00 00 00 00	 call	 _M_IsNextParm
  009f5	85 c0		 test	 eax, eax
  009f7	0f 84 86 01 00
	00		 je	 $LN65@D_SRB2Main

; 1309 : 		{
; 1310 : 			// from Command_Map_f
; 1311 : 			INT32 j;
; 1312 : 			INT16 newgametype = -1;

  009fd	83 c8 ff	 or	 eax, -1
  00a00	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _newgametype$4[ebp], ax

; 1313 : 			const char *sgametype = M_GetNextParm();

  00a07	e8 00 00 00 00	 call	 _M_GetNextParm
  00a0c	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _sgametype$3[ebp], eax

; 1314 : 
; 1315 : 			for (j = 0; gametype_cons_t[j].strvalue; j++)

  00a12	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$5[ebp], 0
  00a1c	eb 0f		 jmp	 SHORT $LN14@D_SRB2Main
$LN12@D_SRB2Main:
  00a1e	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00a24	83 c0 01	 add	 eax, 1
  00a27	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _j$5[ebp], eax
$LN14@D_SRB2Main:
  00a2d	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00a33	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR _gametype_cons_t[eax*8+4], 0
  00a3b	0f 84 c8 00 00
	00		 je	 $LN13@D_SRB2Main

; 1316 : 				if (!strcasecmp(gametype_cons_t[j].strvalue, sgametype))

  00a41	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _sgametype$3[ebp]
  00a47	50		 push	 eax
  00a48	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _j$5[ebp]
  00a4e	8b 14 cd 04 00
	00 00		 mov	 edx, DWORD PTR _gametype_cons_t[ecx*8+4]
  00a55	52		 push	 edx
  00a56	e8 00 00 00 00	 call	 _stricmp
  00a5b	83 c4 08	 add	 esp, 8
  00a5e	85 c0		 test	 eax, eax
  00a60	0f 85 9e 00 00
	00		 jne	 $LN56@D_SRB2Main

; 1317 : 				{
; 1318 : 					if (gametype_cons_t[j].value == GTF_TEAMMATCH)

  00a66	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00a6c	83 3c c5 00 00
	00 00 2a	 cmp	 DWORD PTR _gametype_cons_t[eax*8], 42 ; 0000002aH
  00a74	75 1d		 jne	 SHORT $LN57@D_SRB2Main

; 1319 : 					{
; 1320 : 						newgametype = GT_MATCH;

  00a76	b8 01 00 00 00	 mov	 eax, 1
  00a7b	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _newgametype$4[ebp], ax

; 1321 : 						CV_SetValue(&cv_matchtype, 1);

  00a82	6a 01		 push	 1
  00a84	68 00 00 00 00	 push	 OFFSET _cv_matchtype
  00a89	e8 00 00 00 00	 call	 _CV_SetValue
  00a8e	83 c4 08	 add	 esp, 8

; 1322 : 					}

  00a91	eb 6f		 jmp	 SHORT $LN62@D_SRB2Main
$LN57@D_SRB2Main:

; 1323 : 					else if (gametype_cons_t[j].value == GTF_CLASSICRACE)

  00a93	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00a99	83 3c c5 00 00
	00 00 2b	 cmp	 DWORD PTR _gametype_cons_t[eax*8], 43 ; 0000002bH
  00aa1	75 1d		 jne	 SHORT $LN59@D_SRB2Main

; 1324 : 					{
; 1325 : 						newgametype = GT_RACE;

  00aa3	b8 02 00 00 00	 mov	 eax, 2
  00aa8	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _newgametype$4[ebp], ax

; 1326 : 						CV_SetValue(&cv_racetype, 1);

  00aaf	6a 01		 push	 1
  00ab1	68 00 00 00 00	 push	 OFFSET _cv_racetype
  00ab6	e8 00 00 00 00	 call	 _CV_SetValue
  00abb	83 c4 08	 add	 esp, 8

; 1327 : 					}

  00abe	eb 42		 jmp	 SHORT $LN62@D_SRB2Main
$LN59@D_SRB2Main:

; 1328 : 					else if (gametype_cons_t[j].value == GTF_HIDEANDSEEK)

  00ac0	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00ac6	83 3c c5 00 00
	00 00 2c	 cmp	 DWORD PTR _gametype_cons_t[eax*8], 44 ; 0000002cH
  00ace	75 1d		 jne	 SHORT $LN61@D_SRB2Main

; 1329 : 					{
; 1330 : 						newgametype = GT_TAG;

  00ad0	b8 03 00 00 00	 mov	 eax, 3
  00ad5	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _newgametype$4[ebp], ax

; 1331 : 						CV_SetValue(&cv_tagtype, 1);

  00adc	6a 01		 push	 1
  00ade	68 00 00 00 00	 push	 OFFSET _cv_tagtype
  00ae3	e8 00 00 00 00	 call	 _CV_SetValue
  00ae8	83 c4 08	 add	 esp, 8

; 1332 : 					}

  00aeb	eb 15		 jmp	 SHORT $LN62@D_SRB2Main
$LN61@D_SRB2Main:

; 1333 : 					else
; 1334 : 						newgametype = (INT16)gametype_cons_t[j].value;

  00aed	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00af3	66 8b 0c c5 00
	00 00 00	 mov	 cx, WORD PTR _gametype_cons_t[eax*8]
  00afb	66 89 8d ac fe
	ff ff		 mov	 WORD PTR _newgametype$4[ebp], cx
$LN62@D_SRB2Main:

; 1335 : 
; 1336 : 					break;

  00b02	eb 05		 jmp	 SHORT $LN13@D_SRB2Main
$LN56@D_SRB2Main:

; 1337 : 				}

  00b04	e9 15 ff ff ff	 jmp	 $LN12@D_SRB2Main
$LN13@D_SRB2Main:

; 1338 : 			if (!gametype_cons_t[j].strvalue) // reached end of the list with no match

  00b09	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00b0f	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR _gametype_cons_t[eax*8+4], 0
  00b17	75 35		 jne	 SHORT $LN64@D_SRB2Main

; 1339 : 			{
; 1340 : 				j = atoi(sgametype); // assume they gave us a gametype number, which is okay too

  00b19	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _sgametype$3[ebp]
  00b1f	50		 push	 eax
  00b20	e8 00 00 00 00	 call	 _atoi
  00b25	83 c4 04	 add	 esp, 4
  00b28	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _j$5[ebp], eax

; 1341 : 				if (j >= 0 && j < NUMGAMETYPES)

  00b2e	83 bd b0 fe ff
	ff 00		 cmp	 DWORD PTR _j$5[ebp], 0
  00b35	7c 17		 jl	 SHORT $LN64@D_SRB2Main
  00b37	83 bd b0 fe ff
	ff 05		 cmp	 DWORD PTR _j$5[ebp], 5
  00b3e	7d 0e		 jge	 SHORT $LN64@D_SRB2Main

; 1342 : 					newgametype = (INT16)j;

  00b40	66 8b 85 b0 fe
	ff ff		 mov	 ax, WORD PTR _j$5[ebp]
  00b47	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _newgametype$4[ebp], ax
$LN64@D_SRB2Main:

; 1343 : 			}
; 1344 : 
; 1345 : 			if (newgametype != -1)

  00b4e	0f bf 85 ac fe
	ff ff		 movsx	 eax, WORD PTR _newgametype$4[ebp]
  00b55	83 f8 ff	 cmp	 eax, -1
  00b58	74 29		 je	 SHORT $LN65@D_SRB2Main

; 1346 : 			{
; 1347 : 				j = gametype;

  00b5a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00b61	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _j$5[ebp], eax

; 1348 : 				gametype = newgametype;

  00b67	66 8b 85 ac fe
	ff ff		 mov	 ax, WORD PTR _newgametype$4[ebp]
  00b6e	66 a3 00 00 00
	00		 mov	 WORD PTR _gametype, ax

; 1349 : 				D_GameTypeChanged(j);

  00b74	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _j$5[ebp]
  00b7a	50		 push	 eax
  00b7b	e8 00 00 00 00	 call	 _D_GameTypeChanged
  00b80	83 c4 04	 add	 esp, 4
$LN65@D_SRB2Main:

; 1350 : 			}
; 1351 : 		}
; 1352 : 
; 1353 : 		if (server && !M_CheckParm("+map") && !M_CheckParm("+connect")
; 1354 : 			&& !M_CheckParm("-connect"))

  00b83	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  00b8a	74 5a		 je	 SHORT $LN66@D_SRB2Main
  00b8c	68 00 00 00 00	 push	 OFFSET ??_C@_04CAKKOBMI@?$CLmap@
  00b91	e8 00 00 00 00	 call	 _M_CheckParm
  00b96	83 c4 04	 add	 esp, 4
  00b99	85 c0		 test	 eax, eax
  00b9b	75 49		 jne	 SHORT $LN66@D_SRB2Main
  00b9d	68 00 00 00 00	 push	 OFFSET ??_C@_08CDAOAFMH@?$CLconnect@
  00ba2	e8 00 00 00 00	 call	 _M_CheckParm
  00ba7	83 c4 04	 add	 esp, 4
  00baa	85 c0		 test	 eax, eax
  00bac	75 38		 jne	 SHORT $LN66@D_SRB2Main
  00bae	68 00 00 00 00	 push	 OFFSET ??_C@_08FABEHMEN@?9connect@
  00bb3	e8 00 00 00 00	 call	 _M_CheckParm
  00bb8	83 c4 04	 add	 esp, 4
  00bbb	85 c0		 test	 eax, eax
  00bbd	75 27		 jne	 SHORT $LN66@D_SRB2Main

; 1355 : 		{
; 1356 : 			D_MapChange(pstartmap, gametype, ultimatemode, 1, 0, false, false);

  00bbf	6a 00		 push	 0
  00bc1	6a 00		 push	 0
  00bc3	6a 00		 push	 0
  00bc5	6a 01		 push	 1
  00bc7	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _ultimatemode
  00bce	50		 push	 eax
  00bcf	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _gametype
  00bd6	51		 push	 ecx
  00bd7	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _pstartmap$[ebp]
  00bdd	52		 push	 edx
  00bde	e8 00 00 00 00	 call	 _D_MapChange
  00be3	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN66@D_SRB2Main:

; 1357 : 		}
; 1358 : 	}

  00be6	eb 06		 jmp	 SHORT $LN53@D_SRB2Main
$LN52@D_SRB2Main:

; 1359 : 	else
; 1360 : 		F_StartIntro(); // Tails 03-03-2002

  00be8	e8 00 00 00 00	 call	 _F_StartIntro
  00bed	90		 npad	 1
$LN53@D_SRB2Main:

; 1361 : 
; 1362 : 	if (dedicated && server)

  00bee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00bf5	74 43		 je	 SHORT $LN68@D_SRB2Main
  00bf7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  00bfe	74 3a		 je	 SHORT $LN68@D_SRB2Main

; 1363 : 	{
; 1364 : 		pagename = "TITLESKY";

  00c00	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pagename, OFFSET ??_C@_08PBIHNGBH@TITLESKY@

; 1365 : 		levelstarttic = gametic;

  00c0a	a1 00 00 00 00	 mov	 eax, DWORD PTR _gametic
  00c0f	a3 00 00 00 00	 mov	 DWORD PTR _levelstarttic, eax

; 1366 : 		G_SetGamestate(GS_LEVEL);

  00c14	6a 01		 push	 1
  00c16	e8 00 00 00 00	 call	 _G_SetGamestate
  00c1b	83 c4 04	 add	 esp, 4

; 1367 : 		if (!P_SetupLevel(gamemap, false))

  00c1e	6a 00		 push	 0
  00c20	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00c27	50		 push	 eax
  00c28	e8 00 00 00 00	 call	 _P_SetupLevel
  00c2d	83 c4 08	 add	 esp, 8
  00c30	85 c0		 test	 eax, eax
  00c32	75 06		 jne	 SHORT $LN68@D_SRB2Main

; 1368 : 			I_Quit(); // fail so reset game stuff

  00c34	e8 00 00 00 00	 call	 _I_Quit
  00c39	90		 npad	 1
$LN68@D_SRB2Main:

; 1369 : 	}
; 1370 : }

  00c3a	5f		 pop	 edi
  00c3b	5e		 pop	 esi
  00c3c	5b		 pop	 ebx
  00c3d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c40	33 cd		 xor	 ecx, ebp
  00c42	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c47	8b e5		 mov	 esp, ebp
  00c49	5d		 pop	 ebp
  00c4a	c3		 ret	 0
_D_SRB2Main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\d_main.c
;	COMDAT _D_SRB2Loop
_TEXT	SEGMENT
_rendertimeout$ = -16					; size = 4
_realtics$ = -12					; size = 4
_entertic$ = -8						; size = 4
_oldentertics$ = -4					; size = 4
_D_SRB2Loop PROC					; COMDAT

; 516  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 517  : 	tic_t oldentertics = 0, entertic = 0, realtics = 0, rendertimeout = INFTICS;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _oldentertics$[ebp], 0
  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _entertic$[ebp], 0
  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _realtics$[ebp], 0
  0001e	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _rendertimeout$[ebp], -1

; 518  : 
; 519  : 	if (demorecording)

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demorecording, 0
  0002c	74 06		 je	 SHORT $LN5@D_SRB2Loop

; 520  : 		G_BeginRecording();

  0002e	e8 00 00 00 00	 call	 _G_BeginRecording
  00033	90		 npad	 1
$LN5@D_SRB2Loop:

; 521  : 
; 522  : 	// user settings
; 523  : 	if (dedicated)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0003b	74 1d		 je	 SHORT $LN6@D_SRB2Loop

; 524  : 		COM_BufAddText(va("exec \"%s"PATHSEP"adedserv.cfg\"\n", srb2home));

  0003d	68 00 00 00 00	 push	 OFFSET _srb2home
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KGOBCB@exec?5?$CC?$CFs?2adedserv?4cfg?$CC?6@
  00047	e8 00 00 00 00	 call	 _va
  0004c	83 c4 08	 add	 esp, 8
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _COM_BufAddText
  00055	83 c4 04	 add	 esp, 4
  00058	eb 1b		 jmp	 SHORT $LN7@D_SRB2Loop
$LN6@D_SRB2Loop:

; 525  : 	else
; 526  : 		COM_BufAddText(va("exec \"%s"PATHSEP"autoexec.cfg\" -noerror\n", srb2home));

  0005a	68 00 00 00 00	 push	 OFFSET _srb2home
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HJBEFKFL@exec?5?$CC?$CFs?2autoexec?4cfg?$CC?5?9noerror@
  00064	e8 00 00 00 00	 call	 _va
  00069	83 c4 08	 add	 esp, 8
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _COM_BufAddText
  00072	83 c4 04	 add	 esp, 4
$LN7@D_SRB2Loop:

; 527  : 
; 528  : 	if (dedicated)

  00075	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0007c	74 0a		 je	 SHORT $LN8@D_SRB2Loop

; 529  : 		server = true;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _server, 1
$LN8@D_SRB2Loop:

; 530  : 
; 531  : 	if (M_CheckParm("-voodoo")) // 256x256 Texture Limiter

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_07IAHMHEDC@?9voodoo@
  0008d	e8 00 00 00 00	 call	 _M_CheckParm
  00092	83 c4 04	 add	 esp, 4
  00095	85 c0		 test	 eax, eax
  00097	74 0d		 je	 SHORT $LN9@D_SRB2Loop

; 532  : 		COM_BufAddText("gr_voodoocompatibility on\n");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IEEBAO@gr_voodoocompatibility?5on?6@
  0009e	e8 00 00 00 00	 call	 _COM_BufAddText
  000a3	83 c4 04	 add	 esp, 4
$LN9@D_SRB2Loop:

; 533  : 
; 534  : 	// Pushing of + parameters is now done back in D_SRB2Main, not here.
; 535  : 
; 536  : 	// end of loading screen: CONS_Printf() will no more call FinishUpdate()
; 537  : 	con_startup = false;

  000a6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_startup, 0

; 538  : 
; 539  : 	CONS_Printf("%s", text[I_STARTUPKEYBOARD]);

  000b0	b8 04 00 00 00	 mov	 eax, 4
  000b5	6b c8 4e	 imul	 ecx, eax, 78
  000b8	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  000be	52		 push	 edx
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000c4	e8 00 00 00 00	 call	 _CONS_Printf
  000c9	83 c4 08	 add	 esp, 8

; 540  : 	I_StartupKeyboard();

  000cc	e8 00 00 00 00	 call	 _I_StartupKeyboard
  000d1	90		 npad	 1

; 541  : 
; 542  : #ifdef _WINDOWS
; 543  : 	CONS_Printf("%s", text[I_STARTUPMOUSE]);

  000d2	b8 04 00 00 00	 mov	 eax, 4
  000d7	6b c8 4f	 imul	 ecx, eax, 79
  000da	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  000e0	52		 push	 edx
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000e6	e8 00 00 00 00	 call	 _CONS_Printf
  000eb	83 c4 08	 add	 esp, 8

; 544  : 	I_DoStartupMouse();

  000ee	e8 00 00 00 00	 call	 _I_DoStartupMouse
  000f3	90		 npad	 1

; 545  : #endif
; 546  : 
; 547  : 	oldentertics = I_GetTime();

  000f4	e8 00 00 00 00	 call	 _I_GetTime
  000f9	89 45 fc	 mov	 DWORD PTR _oldentertics$[ebp], eax

; 548  : 
; 549  : 	// make sure to do a d_display to init mode _before_ load a level
; 550  : 	SCR_SetMode(); // change video mode

  000fc	e8 00 00 00 00	 call	 _SCR_SetMode
  00101	90		 npad	 1

; 551  : 	SCR_Recalc();

  00102	e8 00 00 00 00	 call	 _SCR_Recalc
  00107	90		 npad	 1
$LN2@D_SRB2Loop:

; 552  : 
; 553  : 	for (;;)
; 554  : 	{
; 555  : 		// get real tics
; 556  : 		entertic = I_GetTime();

  00108	e8 00 00 00 00	 call	 _I_GetTime
  0010d	89 45 f8	 mov	 DWORD PTR _entertic$[ebp], eax

; 557  : 		realtics = entertic - oldentertics;

  00110	8b 45 f8	 mov	 eax, DWORD PTR _entertic$[ebp]
  00113	2b 45 fc	 sub	 eax, DWORD PTR _oldentertics$[ebp]
  00116	89 45 f4	 mov	 DWORD PTR _realtics$[ebp], eax

; 558  : 		oldentertics = entertic;

  00119	8b 45 f8	 mov	 eax, DWORD PTR _entertic$[ebp]
  0011c	89 45 fc	 mov	 DWORD PTR _oldentertics$[ebp], eax

; 559  : 
; 560  : #ifdef DEBUGFILE
; 561  : 		if (!realtics)

  0011f	83 7d f4 00	 cmp	 DWORD PTR _realtics$[ebp], 0
  00123	75 16		 jne	 SHORT $LN11@D_SRB2Loop

; 562  : 			if (debugload)

  00125	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugload, 0
  0012c	74 0d		 je	 SHORT $LN11@D_SRB2Loop

; 563  : 				debugload--;

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugload
  00133	83 e8 01	 sub	 eax, 1
  00136	a3 00 00 00 00	 mov	 DWORD PTR _debugload, eax
$LN11@D_SRB2Loop:

; 564  : #endif
; 565  : 
; 566  : 		if (!realtics && !singletics)

  0013b	83 7d f4 00	 cmp	 DWORD PTR _realtics$[ebp], 0
  0013f	75 11		 jne	 SHORT $LN12@D_SRB2Loop
  00141	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _singletics, 0
  00148	75 08		 jne	 SHORT $LN12@D_SRB2Loop

; 567  : 		{
; 568  : 			I_Sleep();

  0014a	e8 00 00 00 00	 call	 _I_Sleep
  0014f	90		 npad	 1

; 569  : 			continue;

  00150	eb b6		 jmp	 SHORT $LN2@D_SRB2Loop
$LN12@D_SRB2Loop:

; 570  : 		}
; 571  : 
; 572  : #ifdef HW3SOUND
; 573  : 		HW3S_BeginFrameUpdate();

  00152	e8 00 00 00 00	 call	 _HW3S_BeginFrameUpdate
  00157	90		 npad	 1

; 574  : #endif
; 575  : 
; 576  : 		// process tics (but maybe not if realtic == 0)
; 577  : 		TryRunTics(realtics);

  00158	8b 45 f4	 mov	 eax, DWORD PTR _realtics$[ebp]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _TryRunTics
  00161	83 c4 04	 add	 esp, 4

; 578  : 
; 579  : 		if (lastdraw || singletics || gametic > rendergametic)

  00164	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _lastdraw, 0
  0016b	75 16		 jne	 SHORT $LN15@D_SRB2Loop
  0016d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _singletics, 0
  00174	75 0d		 jne	 SHORT $LN15@D_SRB2Loop
  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR _gametic
  0017b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rendergametic
  00181	76 3b		 jbe	 SHORT $LN13@D_SRB2Loop
$LN15@D_SRB2Loop:

; 580  : 		{
; 581  : 			rendergametic = gametic;

  00183	a1 00 00 00 00	 mov	 eax, DWORD PTR _gametic
  00188	a3 00 00 00 00	 mov	 DWORD PTR _rendergametic, eax

; 582  : 			rendertimeout = entertic+TICRATE/17;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _entertic$[ebp]
  00190	83 c0 02	 add	 eax, 2
  00193	89 45 f0	 mov	 DWORD PTR _rendertimeout$[ebp], eax

; 583  : 
; 584  : 			// Update display, next frame, with current state.
; 585  : 			D_Display();

  00196	e8 00 00 00 00	 call	 _D_Display
  0019b	90		 npad	 1

; 586  : 			supdate = false;

  0019c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _supdate, 0

; 587  : 
; 588  : 			if (moviemode)

  001a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _moviemode, 0
  001ad	74 0d		 je	 SHORT $LN16@D_SRB2Loop

; 589  : 			{
; 590  : #ifdef HAVE_PNG
; 591  : 				M_SaveFrame();
; 592  : #else
; 593  : 				COM_BufAddText("screenshot");

  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CMHOPIGK@screenshot@
  001b4	e8 00 00 00 00	 call	 _COM_BufAddText
  001b9	83 c4 04	 add	 esp, 4
$LN16@D_SRB2Loop:

; 594  : #endif
; 595  : 			}
; 596  : 		}

  001bc	eb 79		 jmp	 SHORT $LN17@D_SRB2Loop
$LN13@D_SRB2Loop:

; 597  : 		else if (rendertimeout < entertic) // in case the server hang or netsplit

  001be	8b 45 f0	 mov	 eax, DWORD PTR _rendertimeout$[ebp]
  001c1	3b 45 f8	 cmp	 eax, DWORD PTR _entertic$[ebp]
  001c4	73 71		 jae	 SHORT $LN17@D_SRB2Loop

; 598  : 		{
; 599  : 			// Lagless camera! Yay!
; 600  : 			if (gamestate == GS_LEVEL && netgame)

  001c6	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  001cd	75 62		 jne	 SHORT $LN20@D_SRB2Loop
  001cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  001d6	74 59		 je	 SHORT $LN20@D_SRB2Loop

; 601  : 			{
; 602  : 				if (splitscreen && camera2.chase)

  001d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  001df	74 28		 je	 SHORT $LN19@D_SRB2Loop
  001e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _camera2, 0
  001e8	74 1f		 je	 SHORT $LN19@D_SRB2Loop

; 603  : 					P_MoveChaseCamera(&players[secondarydisplayplayer], &camera2, true);

  001ea	6a 01		 push	 1
  001ec	68 00 00 00 00	 push	 OFFSET _camera2
  001f1	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  001fb	05 00 00 00 00	 add	 eax, OFFSET _players
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 _P_MoveChaseCamera
  00206	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@D_SRB2Loop:

; 604  : 				if (camera.chase)

  00209	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _camera, 0
  00210	74 1f		 je	 SHORT $LN20@D_SRB2Loop

; 605  : 					P_MoveChaseCamera(&players[displayplayer], &camera, true);

  00212	6a 01		 push	 1
  00214	68 00 00 00 00	 push	 OFFSET _camera
  00219	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00223	05 00 00 00 00	 add	 eax, OFFSET _players
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _P_MoveChaseCamera
  0022e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@D_SRB2Loop:

; 606  : 			}
; 607  : 			D_Display();

  00231	e8 00 00 00 00	 call	 _D_Display
  00236	90		 npad	 1
$LN17@D_SRB2Loop:

; 608  : 		}
; 609  : 
; 610  : 		// consoleplayer -> displayplayer (hear sounds from viewpoint)
; 611  : 		S_UpdateSounds(); // move positional sounds

  00237	e8 00 00 00 00	 call	 _S_UpdateSounds
  0023c	90		 npad	 1

; 612  : 
; 613  : 		// check for media change, loop music..
; 614  : 		I_UpdateCD();

  0023d	e8 00 00 00 00	 call	 _I_UpdateCD
  00242	90		 npad	 1

; 615  : 
; 616  : #ifdef HW3SOUND
; 617  : 		HW3S_EndFrameUpdate();

  00243	e8 00 00 00 00	 call	 _HW3S_EndFrameUpdate
  00248	90		 npad	 1

; 618  : #endif
; 619  : 	}

  00249	e9 ba fe ff ff	 jmp	 $LN2@D_SRB2Loop

; 620  : }

  0024e	5f		 pop	 edi
  0024f	5e		 pop	 esi
  00250	5b		 pop	 ebx
  00251	8b e5		 mov	 esp, ebp
  00253	5d		 pop	 ebp
  00254	c3		 ret	 0
_D_SRB2Loop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT ___snprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
___snprintf PROC					; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 __vsnprintf
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1952 :         __crt_va_end(_ArgList);

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1953 :         return _Result;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1954 :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
___snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1411 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1413 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 551  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 552  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 553  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
END
