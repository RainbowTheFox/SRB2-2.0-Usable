; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\command.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_CV_OnOff
PUBLIC	_CV_YesNo
PUBLIC	_CV_Unsigned
PUBLIC	_CV_Natural
PUBLIC	??_C@_03GCDBBDDL@Off@				; `string'
PUBLIC	??_C@_02IAAGKKDJ@On@				; `string'
PUBLIC	??_C@_02JINPPBEP@No@				; `string'
PUBLIC	??_C@_03CCLAEDDF@Yes@				; `string'
PUBLIC	??_C@_03KGHEHEMH@MIN@				; `string'
PUBLIC	??_C@_03LEPPJAKI@MAX@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEPPJAKI@MAX@
CONST	SEGMENT
??_C@_03LEPPJAKI@MAX@ DB 'MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGHEHEMH@MIN@
CONST	SEGMENT
??_C@_03KGHEHEMH@MIN@ DB 'MIN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No@
CONST	SEGMENT
??_C@_02JINPPBEP@No@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off@ DB 'Off', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_CV_OnOff DD	00H
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	00H
	DD	00H
_CV_YesNo DD	00H
	DD	FLAT:??_C@_02JINPPBEP@No@
	DD	01H
	DD	FLAT:??_C@_03CCLAEDDF@Yes@
	DD	00H
	DD	00H
_CV_Unsigned DD	00H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	03b9ac9ffH
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_CV_Natural DD	01H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	03b9ac9ffH
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_COM_AddCommand
PUBLIC	_COM_Argc
PUBLIC	_COM_Argv
PUBLIC	_COM_Args
PUBLIC	_COM_CheckParm
PUBLIC	_COM_CompleteCommand
PUBLIC	_COM_BufAddText
PUBLIC	_COM_BufInsertText
PUBLIC	_COM_ImmedExecute
PUBLIC	_COM_BufExecute
PUBLIC	_COM_Init
PUBLIC	_VS_Alloc
PUBLIC	_VS_Free
PUBLIC	_VS_Clear
PUBLIC	_VS_GetSpace
PUBLIC	_VS_Write
PUBLIC	_VS_Print
PUBLIC	_CV_RegisterVar
PUBLIC	_CV_ClearChangedFlags
PUBLIC	_CV_CompleteVar
PUBLIC	_CV_Set
PUBLIC	_CV_SetValue
PUBLIC	_CV_StealthSetValue
PUBLIC	_CV_StealthSet
PUBLIC	_CV_AddValue
PUBLIC	_CV_SaveVariables
PUBLIC	_CV_SaveNetVars
PUBLIC	_CV_LoadNetVars
PUBLIC	_CV_ResetCheatNetVars
PUBLIC	??_C@_0BG@OJJDFBCN@Command?5buffer?5full?$CB?6@	; `string'
PUBLIC	??_C@_05NKHOCLEE@alias@				; `string'
PUBLIC	??_C@_04OFDNEFMC@echo@				; `string'
PUBLIC	??_C@_05BMLNGOII@cecho@				; `string'
PUBLIC	??_C@_0L@DJOBFKIA@cechoflags@			; `string'
PUBLIC	??_C@_0O@PHPKLFOM@cechoduration@		; `string'
PUBLIC	??_C@_04MGEIEJAD@exec@				; `string'
PUBLIC	??_C@_04PNOAOIAG@wait@				; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_06FHLCKAHH@toggle@			; `string'
PUBLIC	??_C@_0BH@PLIEPDJG@?$CFs?5is?5a?5variable?5name?6@ ; `string'
PUBLIC	??_C@_0BL@PHFIBCN@Command?5?$CFs?5already?5exists?6@ ; `string'
PUBLIC	??_C@_0BG@IBOGFLDP@Unknown?5command?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BI@HCGIPMNK@alias?5?$DMname?$DO?5?$DMcommand?$DO?6@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5@			; `string'
PUBLIC	??_C@_0CF@DLKCJBF@exec?5?$DMfilename?$DO?5?3?5run?5a?5script?5@ ; `string'
PUBLIC	??_C@_08JGEINCBI@?9noerror@			; `string'
PUBLIC	??_C@_0BK@JLKACNFO@couldn?8t?5execute?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_07FDPFAEJA@?9silent@			; `string'
PUBLIC	??_C@_0O@PJIMACPA@executing?5?$CFs?6@		; `string'
PUBLIC	??_C@_0O@HHGOIADI@Variable?5?$CFs?3?6@		; `string'
PUBLIC	??_C@_09HJPHJBO@?5?5flags?5?3@			; `string'
PUBLIC	??_C@_09NENNDHNF@AUTOSAVE?5@			; `string'
PUBLIC	??_C@_06DKOIPINL@FLOAT?5@			; `string'
PUBLIC	??_C@_07EJKBDLDJ@NETVAR?5@			; `string'
PUBLIC	??_C@_07OEACDBNL@ACTION?5@			; `string'
PUBLIC	??_C@_06LJPBINML@CHEAT?5@			; `string'
PUBLIC	??_C@_0BH@MJBMLIGC@?5?5range?5from?5?$CFd?5to?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BE@HMPBCJPP@?5Current?5value?3?5?$CFd?6@	; `string'
PUBLIC	??_C@_0BH@LHJMBOKG@?5?5possible?5value?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0P@EPOFJEGP@?5?5?5?5?$CF?92d?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BE@GFJIJMAK@?5Current?5value?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CD@FJGBGHFA@No?5Help?5for?5this?5command?1variab@ ; `string'
PUBLIC	??_C@_0L@GGHKNGEP@?$ACCommands?6@		; `string'
PUBLIC	??_C@_0P@MPBDJGBK@emilydampstone@		; `string'
PUBLIC	??_C@_09NOKCFBCP@iamaghost@			; `string'
PUBLIC	??_C@_0N@FBKAIGED@?$AC?6Variables?6@		; `string'
PUBLIC	??_C@_0DO@PJDDLJGC@?$AC?6read?5help?5file?5for?5more?5or?5ty@ ; `string'
PUBLIC	??_C@_0N@NGDIOMGD@?$ACTotal?5?3?5?$CFd?6@	; `string'
PUBLIC	??_C@_0CP@MABMEIEJ@Toggle?5?$DMcvar_name?$DO?6Toggle?5the?5v@ ; `string'
PUBLIC	??_C@_0BC@GKGHMHFB@?$CFs?5is?5not?5a?5cvar?6@	; `string'
PUBLIC	??_C@_0BL@PEPKEIEH@?$CFs?5is?5not?5a?5boolean?5value?6@ ; `string'
PUBLIC	??_C@_0N@GIAGIJKH@overflow?5111@		; `string'
PUBLIC	??_C@_0BC@EFPENHPC@overflow?5l?$CFIu?5112@	; `string'
PUBLIC	??_C@_0BD@IMENGHPE@VS?5buffer?5overflow@	; `string'
PUBLIC	??_C@_0CA@OJFCHIOJ@Variable?5?$CFs?5is?5already?5defined?6@ ; `string'
PUBLIC	??_C@_0BG@FEIIJCCF@?$CFs?5is?5a?5command?5name?6@ ; `string'
PUBLIC	??_C@_0BN@MCACDFKG@Variable?5?$CFs?5have?5same?5netid?6@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_02LIELOMNJ@on@				; `string'
PUBLIC	??_C@_03MCADLMAF@off@				; `string'
PUBLIC	??_C@_03ICICOMAL@yes@				; `string'
PUBLIC	??_C@_02KAJCLHKP@no@				; `string'
PUBLIC	??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@ ; `string'
PUBLIC	??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@ ; `string'
PUBLIC	??_C@_0O@GHELFHEK@?$CFs?5set?5to?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CJ@MFLEKFEE@Illegal?5netvar?5command?5received@ ; `string'
PUBLIC	??_C@_0CC@MJKCJHAL@?$ACNetvar?5not?5found?5with?5netid?5?$CFh@ ; `string'
PUBLIC	??_C@_0CJ@NOOEBCIN@Netvar?5received?3?5?$CFs?5?$FLnetid?$DN?$CFd?$FN?5@ ; `string'
PUBLIC	??_C@_0DB@MDCKKJAK@Only?5the?5server?5can?5change?5this@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0DI@CLBKNOAP@This?5variable?5can?8t?5be?5changed?5@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0BO@NLKDOPKH@?$CC?$CFs?$CC?5is?5?$CC?$CFs?$CC?5default?5is?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	__real@40f0000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncat:PROC
EXTRN	_strncmp:PROC
EXTRN	_stricmp:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	_fflush:PROC
EXTRN	_fputs:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_RegisterNetXCmd:PROC
EXTRN	_SendNetXCmd:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_StrDup:PROC
EXTRN	_M_StartMessage:PROC
EXTRN	_M_CheatActivationResponder:PROC
EXTRN	_FIL_ReadFile:PROC
EXTRN	_HU_SetCEchoDuration:PROC
EXTRN	_HU_SetCEchoFlags:PROC
EXTRN	_HU_DoCEcho:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	_gamestate:DWORD
EXTRN	_M_Memcpy:DWORD
EXTRN	_devparm:DWORD
EXTRN	_netgame:DWORD
EXTRN	_multiplayer:DWORD
EXTRN	_gametype:WORD
EXTRN	_cv_debug:DWORD
EXTRN	_menuactive:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	_mapvisited:BYTE
EXTRN	_debugfile:DWORD
EXTRN	_text:BYTE
EXTRN	_cv_playercolor:BYTE
EXTRN	_cv_skin:BYTE
EXTRN	_cv_pointlimit:BYTE
EXTRN	_cv_cheats:BYTE
EXTRN	_server:DWORD
EXTRN	_adminplayer:DWORD
EXTRN	_serverplayer:DWORD
EXTRN	_con_destlines:DWORD
EXTRN	_inlevelselect:DWORD
EXTRN	_cv_newgametype:BYTE
EXTRN	_cv_nextmap:BYTE
EXTRN	_cv_chooseskin:BYTE
EXTRN	_player_names:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_consvar_vars DD 01H DUP (?)
_com_token DB	0400H DUP (?)
_com_wait DD	01H DUP (?)
_com_alias DD	01H DUP (?)
_com_text DB	014H DUP (?)
_com_commands DD 01H DUP (?)
_com_argc DD	01H DUP (?)
_com_argv DD	050H DUP (?)
_com_args DD	01H DUP (?)
_serverloading DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@40f0000000000000
CONST	SEGMENT
__real@40f0000000000000 DQ 040f0000000000000r	; 65536
CONST	ENDS
;	COMDAT ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@ DB '%s "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NLKDOPKH@?$CC?$CFs?$CC?5is?5?$CC?$CFs?$CC?5default?5is?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BO@NLKDOPKH@?$CC?$CFs?$CC?5is?5?$CC?$CFs?$CC?5default?5is?5?$CC?$CFs?$CC?6@ DB '"'
	DB	'%s" is "%s" default is "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CLBKNOAP@This?5variable?5can?8t?5be?5changed?5@
CONST	SEGMENT
??_C@_0DI@CLBKNOAP@This?5variable?5can?8t?5be?5changed?5@ DB 'This variab'
	DB	'le can''t be changed while in netgame: %s %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MDCKKJAK@Only?5the?5server?5can?5change?5this@
CONST	SEGMENT
??_C@_0DB@MDCKKJAK@Only?5the?5server?5can?5change?5this@ DB 'Only the ser'
	DB	'ver can change this variable: %s %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NOOEBCIN@Netvar?5received?3?5?$CFs?5?$FLnetid?$DN?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0CJ@NOOEBCIN@Netvar?5received?3?5?$CFs?5?$FLnetid?$DN?$CFd?$FN?5@ DB 'N'
	DB	'etvar received: %s [netid=%d] value %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MJKCJHAL@?$ACNetvar?5not?5found?5with?5netid?5?$CFh@
CONST	SEGMENT
??_C@_0CC@MJKCJHAL@?$ACNetvar?5not?5found?5with?5netid?5?$CFh@ DB 02H, 'N'
	DB	'etvar not found with netid %hu', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MFLEKFEE@Illegal?5netvar?5command?5received@
CONST	SEGMENT
??_C@_0CJ@MFLEKFEE@Illegal?5netvar?5command?5received@ DB 'Illegal netvar'
	DB	' command received from %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GHELFHEK@?$CFs?5set?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0O@GHELFHEK@?$CFs?5set?5to?5?$CFs?6@ DB '%s set to %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@
CONST	SEGMENT
??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@ DB 'V'
	DB	'ariable %s default value "%s" is not a possible value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@
CONST	SEGMENT
??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@ DB '"%'
	DB	's" is not a possible value for "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no@
CONST	SEGMENT
??_C@_02KAJCLHKP@no@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes@
CONST	SEGMENT
??_C@_03ICICOMAL@yes@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off@
CONST	SEGMENT
??_C@_03MCADLMAF@off@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on@
CONST	SEGMENT
??_C@_02LIELOMNJ@on@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MCACDFKG@Variable?5?$CFs?5have?5same?5netid?6@
CONST	SEGMENT
??_C@_0BN@MCACDFKG@Variable?5?$CFs?5have?5same?5netid?6@ DB 'Variable %s '
	DB	'have same netid', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FEIIJCCF@?$CFs?5is?5a?5command?5name?6@
CONST	SEGMENT
??_C@_0BG@FEIIJCCF@?$CFs?5is?5a?5command?5name?6@ DB '%s is a command nam'
	DB	'e', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OJFCHIOJ@Variable?5?$CFs?5is?5already?5defined?6@
CONST	SEGMENT
??_C@_0CA@OJFCHIOJ@Variable?5?$CFs?5is?5already?5defined?6@ DB 'Variable '
	DB	'%s is already defined', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IMENGHPE@VS?5buffer?5overflow@
CONST	SEGMENT
??_C@_0BD@IMENGHPE@VS?5buffer?5overflow@ DB 'VS buffer overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EFPENHPC@overflow?5l?$CFIu?5112@
CONST	SEGMENT
??_C@_0BC@EFPENHPC@overflow?5l?$CFIu?5112@ DB 'overflow l%Iu 112', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GIAGIJKH@overflow?5111@
CONST	SEGMENT
??_C@_0N@GIAGIJKH@overflow?5111@ DB 'overflow 111', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PEPKEIEH@?$CFs?5is?5not?5a?5boolean?5value?6@
CONST	SEGMENT
??_C@_0BL@PEPKEIEH@?$CFs?5is?5not?5a?5boolean?5value?6@ DB '%s is not a b'
	DB	'oolean value', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GKGHMHFB@?$CFs?5is?5not?5a?5cvar?6@
CONST	SEGMENT
??_C@_0BC@GKGHMHFB@?$CFs?5is?5not?5a?5cvar?6@ DB '%s is not a cvar', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MABMEIEJ@Toggle?5?$DMcvar_name?$DO?6Toggle?5the?5v@
CONST	SEGMENT
??_C@_0CP@MABMEIEJ@Toggle?5?$DMcvar_name?$DO?6Toggle?5the?5v@ DB 'Toggle '
	DB	'<cvar_name>', 0aH, 'Toggle the value of a cvar', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NGDIOMGD@?$ACTotal?5?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0N@NGDIOMGD@?$ACTotal?5?3?5?$CFd?6@ DB 02H, 'Total : %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PJDDLJGC@?$AC?6read?5help?5file?5for?5more?5or?5ty@
CONST	SEGMENT
??_C@_0DO@PJDDLJGC@?$AC?6read?5help?5file?5for?5more?5or?5ty@ DB 02H, 0aH
	DB	'read help file for more or type help <command or variable>', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBKAIGED@?$AC?6Variables?6@
CONST	SEGMENT
??_C@_0N@FBKAIGED@?$AC?6Variables?6@ DB 02H, 0aH, 'Variables', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NOKCFBCP@iamaghost@
CONST	SEGMENT
??_C@_09NOKCFBCP@iamaghost@ DB 'iamaghost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MPBDJGBK@emilydampstone@
CONST	SEGMENT
??_C@_0P@MPBDJGBK@emilydampstone@ DB 'emilydampstone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GGHKNGEP@?$ACCommands?6@
CONST	SEGMENT
??_C@_0L@GGHKNGEP@?$ACCommands?6@ DB 02H, 'Commands', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FJGBGHFA@No?5Help?5for?5this?5command?1variab@
CONST	SEGMENT
??_C@_0CD@FJGBGHFA@No?5Help?5for?5this?5command?1variab@ DB 'No Help for '
	DB	'this command/variable', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GFJIJMAK@?5Current?5value?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@GFJIJMAK@?5Current?5value?3?5?$CFs?6@ DB ' Current value: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EPOFJEGP@?5?5?5?5?$CF?92d?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@EPOFJEGP@?5?5?5?5?$CF?92d?5?3?5?$CFs?6@ DB '    %-2d : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LHJMBOKG@?5?5possible?5value?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@LHJMBOKG@?5?5possible?5value?5?3?5?$CFs?6@ DB '  possible value'
	DB	' : %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HMPBCJPP@?5Current?5value?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BE@HMPBCJPP@?5Current?5value?3?5?$CFd?6@ DB ' Current value: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJBMLIGC@?5?5range?5from?5?$CFd?5to?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@MJBMLIGC@?5?5range?5from?5?$CFd?5to?5?$CFd?6@ DB '  range from '
	DB	'%d to %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJPBINML@CHEAT?5@
CONST	SEGMENT
??_C@_06LJPBINML@CHEAT?5@ DB 'CHEAT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEACDBNL@ACTION?5@
CONST	SEGMENT
??_C@_07OEACDBNL@ACTION?5@ DB 'ACTION ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJKBDLDJ@NETVAR?5@
CONST	SEGMENT
??_C@_07EJKBDLDJ@NETVAR?5@ DB 'NETVAR ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKOIPINL@FLOAT?5@
CONST	SEGMENT
??_C@_06DKOIPINL@FLOAT?5@ DB 'FLOAT ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NENNDHNF@AUTOSAVE?5@
CONST	SEGMENT
??_C@_09NENNDHNF@AUTOSAVE?5@ DB 'AUTOSAVE ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJPHJBO@?5?5flags?5?3@
CONST	SEGMENT
??_C@_09HJPHJBO@?5?5flags?5?3@ DB '  flags :', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHGOIADI@Variable?5?$CFs?3?6@
CONST	SEGMENT
??_C@_0O@HHGOIADI@Variable?5?$CFs?3?6@ DB 'Variable %s:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJIMACPA@executing?5?$CFs?6@
CONST	SEGMENT
??_C@_0O@PJIMACPA@executing?5?$CFs?6@ DB 'executing %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDPFAEJA@?9silent@
CONST	SEGMENT
??_C@_07FDPFAEJA@?9silent@ DB '-silent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JLKACNFO@couldn?8t?5execute?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@JLKACNFO@couldn?8t?5execute?5file?5?$CFs?6@ DB 'couldn''t execu'
	DB	'te file %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGEINCBI@?9noerror@
CONST	SEGMENT
??_C@_08JGEINCBI@?9noerror@ DB '-noerror', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DLKCJBF@exec?5?$DMfilename?$DO?5?3?5run?5a?5script?5@
CONST	SEGMENT
??_C@_0CF@DLKCJBF@exec?5?$DMfilename?$DO?5?3?5run?5a?5script?5@ DB 'exec '
	DB	'<filename> : run a script file', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5@ DB '%s ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HCGIPMNK@alias?5?$DMname?$DO?5?$DMcommand?$DO?6@
CONST	SEGMENT
??_C@_0BI@HCGIPMNK@alias?5?$DMname?$DO?5?$DMcommand?$DO?6@ DB 'alias <nam'
	DB	'e> <command>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IBOGFLDP@Unknown?5command?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BG@IBOGFLDP@Unknown?5command?5?8?$CFs?8?6@ DB 'Unknown command ''%'
	DB	's''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PHFIBCN@Command?5?$CFs?5already?5exists?6@
CONST	SEGMENT
??_C@_0BL@PHFIBCN@Command?5?$CFs?5already?5exists?6@ DB 'Command %s alrea'
	DB	'dy exists', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PLIEPDJG@?$CFs?5is?5a?5variable?5name?6@
CONST	SEGMENT
??_C@_0BH@PLIEPDJG@?$CFs?5is?5a?5variable?5name?6@ DB '%s is a variable n'
	DB	'ame', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHLCKAHH@toggle@
CONST	SEGMENT
??_C@_06FHLCKAHH@toggle@ DB 'toggle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNOAOIAG@wait@
CONST	SEGMENT
??_C@_04PNOAOIAG@wait@ DB 'wait', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGEIEJAD@exec@
CONST	SEGMENT
??_C@_04MGEIEJAD@exec@ DB 'exec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PHPKLFOM@cechoduration@
CONST	SEGMENT
??_C@_0O@PHPKLFOM@cechoduration@ DB 'cechoduration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJOBFKIA@cechoflags@
CONST	SEGMENT
??_C@_0L@DJOBFKIA@cechoflags@ DB 'cechoflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMLNGOII@cecho@
CONST	SEGMENT
??_C@_05BMLNGOII@cecho@ DB 'cecho', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFDNEFMC@echo@
CONST	SEGMENT
??_C@_04OFDNEFMC@echo@ DB 'echo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKHOCLEE@alias@
CONST	SEGMENT
??_C@_05NKHOCLEE@alias@ DB 'alias', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_com_null_string DD FLAT:??_C@_00CNPNBAHC@@
_cv_null_string DD FLAT:??_C@_00CNPNBAHC@@
?premiers@?1??CV_ComputeNetid@@9@9 DW 02H		; `CV_ComputeNetid'::`2'::premiers
	DW	03H
	DW	05H
	DW	07H
	DW	0bH
	DW	0dH
	DW	011H
	DW	013H
	DW	017H
	DW	01dH
	DW	01fH
	DW	025H
	DW	029H
	DW	02bH
	DW	02fH
	DW	035H
_DATA	ENDS
;	COMDAT ??_C@_0BG@OJJDFBCN@Command?5buffer?5full?$CB?6@
CONST	SEGMENT
??_C@_0BG@OJJDFBCN@Command?5buffer?5full?$CB?6@ DB 'Command buffer full!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0323H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0d4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0144H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0cbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	03dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	03dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01d3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0186H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_SetCVar
_TEXT	SEGMENT
_p_tmp$1 = -156						; size = 4
_p_tmp$2 = -152						; size = 4
_p_tmp$3 = -148						; size = 4
_tmp_i$4 = -144						; size = 4
_p_tmp$5 = -140						; size = 4
_p$6 = -136						; size = 4
_buf$7 = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_var$ = 8						; size = 4
_value$ = 12						; size = 4
_stealth$ = 16						; size = 4
_CV_SetCVar PROC					; COMDAT

; 1227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1228 : #ifdef PARANOIA
; 1229 : 	if (!var)
; 1230 : 		I_Error("CV_Set: no variable\n");
; 1231 : 	if (!var->string)
; 1232 : 		I_Error("CV_Set: %s no string set!\n", var->name);
; 1233 : #endif
; 1234 : 	if (!stricmp(var->string, value))

  00016	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0001d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 _stricmp
  00026	83 c4 08	 add	 esp, 8
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN17@CV_SetCVar

; 1235 : 		return; // no changes

  0002d	e9 ee 02 00 00	 jmp	 $LN35@CV_SetCVar
$LN17@CV_SetCVar:

; 1236 : 
; 1237 : 	// Don't allow skin/color changes in single player
; 1238 : 	if ((var == &cv_skin || var == &cv_playercolor) &&
; 1239 : 		!(cv_debug || devparm) && !(multiplayer || netgame)
; 1240 : 		&& (gamestate == GS_LEVEL || gamestate == GS_INTERMISSION))

  00032	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _var$[ebp], OFFSET _cv_skin
  00039	74 09		 je	 SHORT $LN19@CV_SetCVar
  0003b	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _var$[ebp], OFFSET _cv_playercolor
  00042	75 3b		 jne	 SHORT $LN18@CV_SetCVar
$LN19@CV_SetCVar:
  00044	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  0004b	75 32		 jne	 SHORT $LN18@CV_SetCVar
  0004d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00054	75 29		 jne	 SHORT $LN18@CV_SetCVar
  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  0005d	75 20		 jne	 SHORT $LN18@CV_SetCVar
  0005f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00066	75 17		 jne	 SHORT $LN18@CV_SetCVar
  00068	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  0006f	74 09		 je	 SHORT $LN20@CV_SetCVar
  00071	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _gamestate, 2
  00078	75 05		 jne	 SHORT $LN18@CV_SetCVar
$LN20@CV_SetCVar:

; 1241 : 	{
; 1242 : 		return;

  0007a	e9 a1 02 00 00	 jmp	 $LN35@CV_SetCVar
$LN18@CV_SetCVar:

; 1243 : 	}
; 1244 : 
; 1245 : 	if (var->flags & CV_NETVAR)

  0007f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00082	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00085	83 e1 04	 and	 ecx, 4
  00088	0f 84 4c 02 00
	00		 je	 $LN21@CV_SetCVar

; 1246 : 	{
; 1247 : 		// send the value of the variable
; 1248 : 		XBOXSTATIC UINT8 buf[128];
; 1249 : 		UINT8 *p = buf;

  0008e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _buf$7[ebp]
  00094	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p$6[ebp], eax

; 1250 : 		if (!(server || (adminplayer == consoleplayer)))

  0009a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  000a1	75 2c		 jne	 SHORT $LN23@CV_SetCVar
  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _adminplayer
  000a8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  000ae	74 1f		 je	 SHORT $LN23@CV_SetCVar

; 1251 : 		{
; 1252 : 			CONS_Printf("Only the server can change this variable: %s %s\n",

  000b0	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  000b3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b6	51		 push	 ecx
  000b7	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000ba	8b 02		 mov	 eax, DWORD PTR [edx]
  000bc	50		 push	 eax
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MDCKKJAK@Only?5the?5server?5can?5change?5this@
  000c2	e8 00 00 00 00	 call	 _CONS_Printf
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1253 : 				var->name, var->string);
; 1254 : 			return;

  000ca	e9 51 02 00 00	 jmp	 $LN35@CV_SetCVar
$LN23@CV_SetCVar:

; 1255 : 		}
; 1256 : 		// Restrict multiplayer cheat variables from being changed unless cheats are enabled.
; 1257 : 		if (var->flags & CV_CHEAT)

  000cf	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  000d2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d5	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  000db	0f 84 9b 00 00
	00		 je	 $LN30@CV_SetCVar

; 1258 : 		{
; 1259 : 			if (!cv_cheats.value && (netgame || multiplayer))

  000e1	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_cheats+20, 0
  000e8	75 72		 jne	 SHORT $LN25@CV_SetCVar
  000ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000f1	75 09		 jne	 SHORT $LN27@CV_SetCVar
  000f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  000fa	74 60		 je	 SHORT $LN25@CV_SetCVar
$LN27@CV_SetCVar:

; 1260 : 			{
; 1261 : 				if (menuactive)

  000fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _menuactive, 0
  00103	74 31		 je	 SHORT $LN28@CV_SetCVar

; 1262 : 					M_StartMessage(va("%s", text[CHEATS_ACTIVATE]), M_CheatActivationResponder, MM_YESNO);

  00105	6a 01		 push	 1
  00107	68 00 00 00 00	 push	 OFFSET _M_CheatActivationResponder
  0010c	b8 04 00 00 00	 mov	 eax, 4
  00111	69 c8 cd 00 00
	00		 imul	 ecx, eax, 205
  00117	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0011d	52		 push	 edx
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00123	e8 00 00 00 00	 call	 _va
  00128	83 c4 08	 add	 esp, 8
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 _M_StartMessage
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
  00134	eb 1f		 jmp	 SHORT $LN29@CV_SetCVar
$LN28@CV_SetCVar:

; 1263 : 				else
; 1264 : 					CONS_Printf("%s", text[CHEATS_REQUIRED]);

  00136	b8 04 00 00 00	 mov	 eax, 4
  0013b	69 c8 cc 00 00
	00		 imul	 ecx, eax, 204
  00141	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00147	52		 push	 edx
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0014d	e8 00 00 00 00	 call	 _CONS_Printf
  00152	83 c4 08	 add	 esp, 8
$LN29@CV_SetCVar:

; 1265 : 				return;

  00155	e9 c6 01 00 00	 jmp	 $LN35@CV_SetCVar

; 1266 : 			}

  0015a	eb 20		 jmp	 SHORT $LN30@CV_SetCVar
$LN25@CV_SetCVar:

; 1267 : 			else if (!cv_debug && !(netgame || multiplayer)) // Still restrict if you're in single player and not in devmode.

  0015c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  00163	75 17		 jne	 SHORT $LN30@CV_SetCVar
  00165	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0016c	75 0e		 jne	 SHORT $LN30@CV_SetCVar
  0016e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00175	75 05		 jne	 SHORT $LN30@CV_SetCVar

; 1268 : 				return;

  00177	e9 a4 01 00 00	 jmp	 $LN35@CV_SetCVar
$LN30@CV_SetCVar:

; 1269 : 		}
; 1270 : 
; 1271 : 		// Only add to netcmd buffer if in a netgame, otherwise, just change it.
; 1272 : 		if (netgame || multiplayer)

  0017c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00183	75 0d		 jne	 SHORT $LN33@CV_SetCVar
  00185	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  0018c	0f 84 32 01 00
	00		 je	 $LN31@CV_SetCVar
$LN33@CV_SetCVar:

; 1273 : 		{
; 1274 : 			WRITEUINT16(p, var->netid);

  00192	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$6[ebp]
  00198	89 85 74 ff ff
	ff		 mov	 DWORD PTR _p_tmp$5[ebp], eax
  0019e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  001a7	66 8b 51 20	 mov	 dx, WORD PTR [ecx+32]
  001ab	66 89 10	 mov	 WORD PTR [eax], dx
  001ae	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  001b4	83 c0 02	 add	 eax, 2
  001b7	89 85 74 ff ff
	ff		 mov	 DWORD PTR _p_tmp$5[ebp], eax
  001bd	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  001c3	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p$6[ebp], eax
  001c9	33 c0		 xor	 eax, eax
  001cb	75 c5		 jne	 SHORT $LN33@CV_SetCVar

; 1275 : 			WRITESTRING(p, value);

  001cd	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmp_i$4[ebp], 0
  001d7	eb 0f		 jmp	 SHORT $LN7@CV_SetCVar
$LN5@CV_SetCVar:
  001d9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _tmp_i$4[ebp]
  001df	83 c0 01	 add	 eax, 1
  001e2	89 85 70 ff ff
	ff		 mov	 DWORD PTR _tmp_i$4[ebp], eax
$LN7@CV_SetCVar:
  001e8	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  001eb	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _tmp_i$4[ebp]
  001f1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001f4	85 c9		 test	 ecx, ecx
  001f6	74 40		 je	 SHORT $LN6@CV_SetCVar
$LN10@CV_SetCVar:
  001f8	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$6[ebp]
  001fe	89 85 6c ff ff
	ff		 mov	 DWORD PTR _p_tmp$3[ebp], eax
  00204	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00207	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _tmp_i$4[ebp]
  0020d	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _p_tmp$3[ebp]
  00213	8a 10		 mov	 dl, BYTE PTR [eax]
  00215	88 11		 mov	 BYTE PTR [ecx], dl
  00217	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  0021d	83 c0 01	 add	 eax, 1
  00220	89 85 6c ff ff
	ff		 mov	 DWORD PTR _p_tmp$3[ebp], eax
  00226	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  0022c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p$6[ebp], eax
  00232	33 c0		 xor	 eax, eax
  00234	75 c2		 jne	 SHORT $LN10@CV_SetCVar
  00236	eb a1		 jmp	 SHORT $LN5@CV_SetCVar
$LN6@CV_SetCVar:
  00238	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$6[ebp]
  0023e	89 85 68 ff ff
	ff		 mov	 DWORD PTR _p_tmp$2[ebp], eax
  00244	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  0024a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0024d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00253	83 c0 01	 add	 eax, 1
  00256	89 85 68 ff ff
	ff		 mov	 DWORD PTR _p_tmp$2[ebp], eax
  0025c	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  00262	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p$6[ebp], eax
  00268	33 c0		 xor	 eax, eax
  0026a	75 cc		 jne	 SHORT $LN6@CV_SetCVar
$LN12@CV_SetCVar:

; 1276 : 			WRITEUINT8(p, stealth);

  0026c	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$6[ebp]
  00272	89 85 64 ff ff
	ff		 mov	 DWORD PTR _p_tmp$1[ebp], eax
  00278	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  0027e	8a 4d 10	 mov	 cl, BYTE PTR _stealth$[ebp]
  00281	88 08		 mov	 BYTE PTR [eax], cl
  00283	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  00289	83 c0 01	 add	 eax, 1
  0028c	89 85 64 ff ff
	ff		 mov	 DWORD PTR _p_tmp$1[ebp], eax
  00292	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  00298	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p$6[ebp], eax
  0029e	33 c0		 xor	 eax, eax
  002a0	75 ca		 jne	 SHORT $LN12@CV_SetCVar

; 1277 : 
; 1278 : 			SendNetXCmd(XD_NETVAR, buf, p-buf);

  002a2	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p$6[ebp]
  002a8	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _buf$7[ebp]
  002ae	2b c1		 sub	 eax, ecx
  002b0	50		 push	 eax
  002b1	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _buf$7[ebp]
  002b7	52		 push	 edx
  002b8	6a 04		 push	 4
  002ba	e8 00 00 00 00	 call	 _SendNetXCmd
  002bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1279 : 		}

  002c2	eb 14		 jmp	 SHORT $LN32@CV_SetCVar
$LN31@CV_SetCVar:

; 1280 : 		else
; 1281 : 			Setvalue(var, value, stealth);

  002c4	8b 45 10	 mov	 eax, DWORD PTR _stealth$[ebp]
  002c7	50		 push	 eax
  002c8	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  002cb	51		 push	 ecx
  002cc	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  002cf	52		 push	 edx
  002d0	e8 00 00 00 00	 call	 _Setvalue
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@CV_SetCVar:

; 1282 : 	}

  002d8	eb 46		 jmp	 SHORT $LN35@CV_SetCVar
$LN21@CV_SetCVar:

; 1283 : 	else
; 1284 : 		if ((var->flags & CV_NOTINNET) && netgame)

  002da	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  002dd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e0	83 e1 20	 and	 ecx, 32			; 00000020H
  002e3	74 27		 je	 SHORT $LN34@CV_SetCVar
  002e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  002ec	74 1e		 je	 SHORT $LN34@CV_SetCVar

; 1285 : 		{
; 1286 : 			CONS_Printf("This variable can't be changed while in netgame: %s %s\n",

  002ee	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  002f1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002f4	51		 push	 ecx
  002f5	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  002f8	8b 02		 mov	 eax, DWORD PTR [edx]
  002fa	50		 push	 eax
  002fb	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CLBKNOAP@This?5variable?5can?8t?5be?5changed?5@
  00300	e8 00 00 00 00	 call	 _CONS_Printf
  00305	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1287 : 				var->name, var->string);
; 1288 : 			return;

  00308	eb 16		 jmp	 SHORT $LN35@CV_SetCVar

; 1289 : 		}

  0030a	eb 14		 jmp	 SHORT $LN35@CV_SetCVar
$LN34@CV_SetCVar:

; 1290 : 		else
; 1291 : 			Setvalue(var, value, stealth);

  0030c	8b 45 10	 mov	 eax, DWORD PTR _stealth$[ebp]
  0030f	50		 push	 eax
  00310	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00313	51		 push	 ecx
  00314	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00317	52		 push	 edx
  00318	e8 00 00 00 00	 call	 _Setvalue
  0031d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@CV_SetCVar:

; 1292 : }

  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
  00322	5b		 pop	 ebx
  00323	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00326	33 cd		 xor	 ecx, ebp
  00328	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032d	8b e5		 mov	 esp, ebp
  0032f	5d		 pop	 ebp
  00330	c3		 ret	 0
_CV_SetCVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _Setvalue
_TEXT	SEGMENT
tv249 = -100						; size = 4
_d$1 = -32						; size = 8
_hopevalue$2 = -24					; size = 4
_i$3 = -20						; size = 4
_i$4 = -16						; size = 4
_v$5 = -12						; size = 4
_overrideval$ = -8					; size = 4
_override$ = -4						; size = 4
_var$ = 8						; size = 4
_valstr$ = 12						; size = 4
_stealth$ = 16						; size = 4
_Setvalue PROC						; COMDAT

; 1011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1012 : 	boolean override = false;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _override$[ebp], 0

; 1013 : 	INT32 overrideval = 0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _overrideval$[ebp], 0

; 1014 : 
; 1015 : 	if (var->PossibleValue)

  00017	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0001a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0001e	0f 84 35 03 00
	00		 je	 $LN16@Setvalue

; 1016 : 	{
; 1017 : 		INT32 v = atoi(valstr);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _atoi
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f4	 mov	 DWORD PTR _v$5[ebp], eax

; 1018 : 
; 1019 : 		if (var->PossibleValue[0].strvalue && !stricmp(var->PossibleValue[0].strvalue, "MIN")) // bounded cvar

  00033	b8 08 00 00 00	 mov	 eax, 8
  00038	6b c8 00	 imul	 ecx, eax, 0
  0003b	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0003e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00041	83 7c 08 04 00	 cmp	 DWORD PTR [eax+ecx+4], 0
  00046	0f 84 25 01 00
	00		 je	 $LN15@Setvalue
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_03KGHEHEMH@MIN@
  00051	b8 08 00 00 00	 mov	 eax, 8
  00056	6b c8 00	 imul	 ecx, eax, 0
  00059	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0005c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005f	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _stricmp
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 fd 00 00
	00		 jne	 $LN15@Setvalue

; 1020 : 		{
; 1021 : 			INT32 i;
; 1022 : 			// search for maximum
; 1023 : 			for (i = 1; var->PossibleValue[i].strvalue; i++)

  00074	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 1
  0007b	eb 09		 jmp	 SHORT $LN4@Setvalue
$LN2@Setvalue:
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _i$4[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 f0	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@Setvalue:
  00086	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00089	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0008c	8b 55 f0	 mov	 edx, DWORD PTR _i$4[ebp]
  0008f	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  00094	74 23		 je	 SHORT $LN3@Setvalue

; 1024 : 				if (!stricmp(var->PossibleValue[i].strvalue, "MAX"))

  00096	68 00 00 00 00	 push	 OFFSET ??_C@_03LEPPJAKI@MAX@
  0009b	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0009e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a1	8b 55 f0	 mov	 edx, DWORD PTR _i$4[ebp]
  000a4	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _stricmp
  000ae	83 c4 08	 add	 esp, 8
  000b1	85 c0		 test	 eax, eax
  000b3	75 02		 jne	 SHORT $LN17@Setvalue

; 1025 : 					break;

  000b5	eb 02		 jmp	 SHORT $LN3@Setvalue
$LN17@Setvalue:
  000b7	eb c4		 jmp	 SHORT $LN2@Setvalue
$LN3@Setvalue:

; 1026 : #ifdef PARANOIA
; 1027 : 			if (!var->PossibleValue[i].strvalue)
; 1028 : 				I_Error("Bounded cvar \"%s\" without maximum!", var->name);
; 1029 : #endif
; 1030 : 			if (v < var->PossibleValue[0].value || !stricmp(valstr, "MIN"))

  000b9	b8 08 00 00 00	 mov	 eax, 8
  000be	6b c8 00	 imul	 ecx, eax, 0
  000c1	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000c4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000c7	8b 55 f4	 mov	 edx, DWORD PTR _v$5[ebp]
  000ca	3b 14 08	 cmp	 edx, DWORD PTR [eax+ecx]
  000cd	7c 15		 jl	 SHORT $LN19@Setvalue
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_03KGHEHEMH@MIN@
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _stricmp
  000dd	83 c4 08	 add	 esp, 8
  000e0	85 c0		 test	 eax, eax
  000e2	75 36		 jne	 SHORT $LN18@Setvalue
$LN19@Setvalue:

; 1031 : 			{
; 1032 : 				v = var->PossibleValue[0].value;

  000e4	b8 08 00 00 00	 mov	 eax, 8
  000e9	6b c8 00	 imul	 ecx, eax, 0
  000ec	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000ef	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000f2	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000f5	89 4d f4	 mov	 DWORD PTR _v$5[ebp], ecx

; 1033 : 				valstr = var->PossibleValue[0].strvalue;

  000f8	b8 08 00 00 00	 mov	 eax, 8
  000fd	6b c8 00	 imul	 ecx, eax, 0
  00100	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00103	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00106	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  0010a	89 4d 0c	 mov	 DWORD PTR _valstr$[ebp], ecx

; 1034 : 				override = true;

  0010d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _override$[ebp], 1

; 1035 : 				overrideval = v;

  00114	8b 45 f4	 mov	 eax, DWORD PTR _v$5[ebp]
  00117	89 45 f8	 mov	 DWORD PTR _overrideval$[ebp], eax
$LN18@Setvalue:

; 1036 : 			}
; 1037 : 			if (v > var->PossibleValue[i].value || !stricmp(valstr, "MAX"))

  0011a	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0011d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00120	8b 55 f0	 mov	 edx, DWORD PTR _i$4[ebp]
  00123	8b 45 f4	 mov	 eax, DWORD PTR _v$5[ebp]
  00126	3b 04 d1	 cmp	 eax, DWORD PTR [ecx+edx*8]
  00129	7f 15		 jg	 SHORT $LN21@Setvalue
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_03LEPPJAKI@MAX@
  00130	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _stricmp
  00139	83 c4 08	 add	 esp, 8
  0013c	85 c0		 test	 eax, eax
  0013e	75 2c		 jne	 SHORT $LN20@Setvalue
$LN21@Setvalue:

; 1038 : 			{
; 1039 : 				v = var->PossibleValue[i].value;

  00140	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00143	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00146	8b 55 f0	 mov	 edx, DWORD PTR _i$4[ebp]
  00149	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  0014c	89 45 f4	 mov	 DWORD PTR _v$5[ebp], eax

; 1040 : 				valstr = var->PossibleValue[i].strvalue;

  0014f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00152	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00155	8b 55 f0	 mov	 edx, DWORD PTR _i$4[ebp]
  00158	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  0015c	89 45 0c	 mov	 DWORD PTR _valstr$[ebp], eax

; 1041 : 				override = true;

  0015f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _override$[ebp], 1

; 1042 : 				overrideval = v;

  00166	8b 45 f4	 mov	 eax, DWORD PTR _v$5[ebp]
  00169	89 45 f8	 mov	 DWORD PTR _overrideval$[ebp], eax
$LN20@Setvalue:

; 1043 : 			}
; 1044 : 		}

  0016c	e9 e8 01 00 00	 jmp	 $LN16@Setvalue
$LN15@Setvalue:

; 1045 : 		else
; 1046 : 		{
; 1047 : 			INT32 i;
; 1048 : 
; 1049 : 			// check first strings
; 1050 : 			for (i = 0; var->PossibleValue[i].strvalue; i++)

  00171	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00178	eb 09		 jmp	 SHORT $LN7@Setvalue
$LN5@Setvalue:
  0017a	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  0017d	83 c0 01	 add	 eax, 1
  00180	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN7@Setvalue:
  00183	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00186	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00189	8b 55 ec	 mov	 edx, DWORD PTR _i$3[ebp]
  0018c	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  00191	74 25		 je	 SHORT $LN6@Setvalue

; 1051 : 				if (!stricmp(var->PossibleValue[i].strvalue, valstr))

  00193	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00196	50		 push	 eax
  00197	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0019a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0019d	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  001a0	8b 4c c2 04	 mov	 ecx, DWORD PTR [edx+eax*8+4]
  001a4	51		 push	 ecx
  001a5	e8 00 00 00 00	 call	 _stricmp
  001aa	83 c4 08	 add	 esp, 8
  001ad	85 c0		 test	 eax, eax
  001af	75 05		 jne	 SHORT $LN22@Setvalue

; 1052 : 					goto found;

  001b1	e9 79 01 00 00	 jmp	 $found$48
$LN22@Setvalue:
  001b6	eb c2		 jmp	 SHORT $LN5@Setvalue
$LN6@Setvalue:

; 1053 : 			if (!v)

  001b8	83 7d f4 00	 cmp	 DWORD PTR _v$5[ebp], 0
  001bc	75 17		 jne	 SHORT $LN24@Setvalue

; 1054 : 				if (strcmp(valstr, "0"))

  001be	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  001c3	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _strcmp
  001cc	83 c4 08	 add	 esp, 8
  001cf	85 c0		 test	 eax, eax
  001d1	74 02		 je	 SHORT $LN24@Setvalue

; 1055 : 					goto error;

  001d3	eb 3a		 jmp	 SHORT $error$49
$LN24@Setvalue:

; 1056 : 			// check INT32 now
; 1057 : 			for (i = 0; var->PossibleValue[i].strvalue; i++)

  001d5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  001dc	eb 09		 jmp	 SHORT $LN10@Setvalue
$LN8@Setvalue:
  001de	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  001e1	83 c0 01	 add	 eax, 1
  001e4	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN10@Setvalue:
  001e7	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001ea	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001ed	8b 55 ec	 mov	 edx, DWORD PTR _i$3[ebp]
  001f0	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  001f5	74 18		 je	 SHORT $error$49

; 1058 : 				if (v == var->PossibleValue[i].value)

  001f7	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001fa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001fd	8b 55 ec	 mov	 edx, DWORD PTR _i$3[ebp]
  00200	8b 45 f4	 mov	 eax, DWORD PTR _v$5[ebp]
  00203	3b 04 d1	 cmp	 eax, DWORD PTR [ecx+edx*8]
  00206	75 05		 jne	 SHORT $LN25@Setvalue

; 1059 : 					goto found;

  00208	e9 22 01 00 00	 jmp	 $found$48
$LN25@Setvalue:
  0020d	eb cf		 jmp	 SHORT $LN8@Setvalue
$error$49:

; 1060 : 
; 1061 : error:
; 1062 : 			// not found
; 1063 : 
; 1064 : 			// But wait, there's hope!
; 1065 : 			if (var->PossibleValue == CV_OnOff
; 1066 : 				|| var->PossibleValue == CV_YesNo)

  0020f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00212	81 78 0c 00 00
	00 00		 cmp	 DWORD PTR [eax+12], OFFSET _CV_OnOff
  00219	74 10		 je	 SHORT $LN27@Setvalue
  0021b	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0021e	81 78 0c 00 00
	00 00		 cmp	 DWORD PTR [eax+12], OFFSET _CV_YesNo
  00225	0f 85 ba 00 00
	00		 jne	 $LN12@Setvalue
$LN27@Setvalue:

; 1067 : 			{
; 1068 : 				INT32 hopevalue = -1;

  0022b	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _hopevalue$2[ebp], -1

; 1069 : 
; 1070 : 				if (!stricmp(valstr, "on"))

  00232	68 00 00 00 00	 push	 OFFSET ??_C@_02LIELOMNJ@on@
  00237	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _stricmp
  00240	83 c4 08	 add	 esp, 8
  00243	85 c0		 test	 eax, eax
  00245	75 09		 jne	 SHORT $LN28@Setvalue

; 1071 : 					hopevalue = 1;

  00247	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _hopevalue$2[ebp], 1
  0024e	eb 58		 jmp	 SHORT $LN34@Setvalue
$LN28@Setvalue:

; 1072 : 				else if (!stricmp(valstr, "off"))

  00250	68 00 00 00 00	 push	 OFFSET ??_C@_03MCADLMAF@off@
  00255	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 _stricmp
  0025e	83 c4 08	 add	 esp, 8
  00261	85 c0		 test	 eax, eax
  00263	75 09		 jne	 SHORT $LN30@Setvalue

; 1073 : 					hopevalue = 0;

  00265	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hopevalue$2[ebp], 0
  0026c	eb 3a		 jmp	 SHORT $LN34@Setvalue
$LN30@Setvalue:

; 1074 : 				else if (!stricmp(valstr, "yes"))

  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_03ICICOMAL@yes@
  00273	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 _stricmp
  0027c	83 c4 08	 add	 esp, 8
  0027f	85 c0		 test	 eax, eax
  00281	75 09		 jne	 SHORT $LN32@Setvalue

; 1075 : 					hopevalue = 1;

  00283	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _hopevalue$2[ebp], 1
  0028a	eb 1c		 jmp	 SHORT $LN34@Setvalue
$LN32@Setvalue:

; 1076 : 				else if (!stricmp(valstr, "no"))

  0028c	68 00 00 00 00	 push	 OFFSET ??_C@_02KAJCLHKP@no@
  00291	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _stricmp
  0029a	83 c4 08	 add	 esp, 8
  0029d	85 c0		 test	 eax, eax
  0029f	75 07		 jne	 SHORT $LN34@Setvalue

; 1077 : 					hopevalue = 0;

  002a1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hopevalue$2[ebp], 0
$LN34@Setvalue:

; 1078 : 
; 1079 : 				if (hopevalue != -1)

  002a8	83 7d e8 ff	 cmp	 DWORD PTR _hopevalue$2[ebp], -1
  002ac	74 37		 je	 SHORT $LN12@Setvalue

; 1080 : 				{
; 1081 : 					for (i = 0; var->PossibleValue[i].strvalue; i++)

  002ae	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  002b5	eb 09		 jmp	 SHORT $LN13@Setvalue
$LN11@Setvalue:
  002b7	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  002ba	83 c0 01	 add	 eax, 1
  002bd	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN13@Setvalue:
  002c0	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  002c3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002c6	8b 55 ec	 mov	 edx, DWORD PTR _i$3[ebp]
  002c9	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  002ce	74 15		 je	 SHORT $LN12@Setvalue

; 1082 : 						if (hopevalue == var->PossibleValue[i].value)

  002d0	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  002d3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002d6	8b 55 ec	 mov	 edx, DWORD PTR _i$3[ebp]
  002d9	8b 45 e8	 mov	 eax, DWORD PTR _hopevalue$2[ebp]
  002dc	3b 04 d1	 cmp	 eax, DWORD PTR [ecx+edx*8]
  002df	75 02		 jne	 SHORT $LN36@Setvalue

; 1083 : 							goto found;

  002e1	eb 4c		 jmp	 SHORT $found$48
$LN36@Setvalue:
  002e3	eb d2		 jmp	 SHORT $LN11@Setvalue
$LN12@Setvalue:

; 1084 : 				}
; 1085 : 			}
; 1086 : 
; 1087 : 			// ...or not.
; 1088 : 			if (var != &cv_nextmap) // Suppress errors for cv_nextmap

  002e5	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _var$[ebp], OFFSET _cv_nextmap
  002ec	74 17		 je	 SHORT $LN37@Setvalue

; 1089 : 				CONS_Printf("\"%s\" is not a possible value for \"%s\"\n", valstr, var->name);

  002ee	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  002f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f3	51		 push	 ecx
  002f4	8b 55 0c	 mov	 edx, DWORD PTR _valstr$[ebp]
  002f7	52		 push	 edx
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@
  002fd	e8 00 00 00 00	 call	 _CONS_Printf
  00302	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@Setvalue:

; 1090 : 
; 1091 : 			if (var->defaultvalue == valstr)

  00305	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00308	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0030b	3b 4d 0c	 cmp	 ecx, DWORD PTR _valstr$[ebp]
  0030e	75 1a		 jne	 SHORT $LN38@Setvalue

; 1092 : 				I_Error("Variable %s default value \"%s\" is not a possible value\n",

  00310	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00313	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00316	51		 push	 ecx
  00317	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0031a	8b 02		 mov	 eax, DWORD PTR [edx]
  0031c	50		 push	 eax
  0031d	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@
  00322	e8 00 00 00 00	 call	 _I_Error
  00327	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@Setvalue:

; 1093 : 					var->name, var->defaultvalue);
; 1094 : 			return;

  0032a	e9 67 01 00 00	 jmp	 $LN46@Setvalue
$found$48:

; 1095 : found:
; 1096 : 			var->value = var->PossibleValue[i].value;

  0032f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00332	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00335	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00338	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  0033b	8b 0c c1	 mov	 ecx, DWORD PTR [ecx+eax*8]
  0033e	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1097 : 			var->string = var->PossibleValue[i].strvalue;

  00341	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00344	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00347	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0034a	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  0034d	8b 4c c1 04	 mov	 ecx, DWORD PTR [ecx+eax*8+4]
  00351	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1098 : 			goto finish;

  00354	e9 8c 00 00 00	 jmp	 $finish$50
$LN16@Setvalue:

; 1099 : 		}
; 1100 : 	}
; 1101 : 
; 1102 : 	// free the old value string
; 1103 : 	Z_Free(var->zstring);

  00359	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0035c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0035f	51		 push	 ecx
  00360	e8 00 00 00 00	 call	 _Z_Free
  00365	83 c4 04	 add	 esp, 4

; 1104 : 
; 1105 : 	var->string = var->zstring = Z_StrDup(valstr);

  00368	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 _Z_StrDup
  00371	83 c4 04	 add	 esp, 4
  00374	89 45 9c	 mov	 DWORD PTR tv249[ebp], eax
  00377	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0037a	8b 55 9c	 mov	 edx, DWORD PTR tv249[ebp]
  0037d	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  00380	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00383	8b 4d 9c	 mov	 ecx, DWORD PTR tv249[ebp]
  00386	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1106 : 
; 1107 : 	if (var->flags & CV_FLOAT)

  00389	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0038c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0038f	83 e1 10	 and	 ecx, 16			; 00000010H
  00392	74 2b		 je	 SHORT $LN39@Setvalue

; 1108 : 	{
; 1109 : 		double d = atof(var->string);

  00394	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00397	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0039a	51		 push	 ecx
  0039b	e8 00 00 00 00	 call	 _atof
  003a0	83 c4 04	 add	 esp, 4
  003a3	dd 5d e0	 fstp	 QWORD PTR _d$1[ebp]

; 1110 : 		var->value = (INT32)(d * FRACUNIT);

  003a6	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _d$1[ebp]
  003ab	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@40f0000000000000
  003b3	f2 0f 2c c0	 cvttsd2si eax, xmm0
  003b7	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  003ba	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1111 : 	}

  003bd	eb 26		 jmp	 SHORT $finish$50
$LN39@Setvalue:

; 1112 : 	else if (override)

  003bf	83 7d fc 00	 cmp	 DWORD PTR _override$[ebp], 0
  003c3	74 0b		 je	 SHORT $LN41@Setvalue

; 1113 : 		var->value = overrideval;

  003c5	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  003c8	8b 4d f8	 mov	 ecx, DWORD PTR _overrideval$[ebp]
  003cb	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  003ce	eb 15		 jmp	 SHORT $finish$50
$LN41@Setvalue:

; 1114 : 	else
; 1115 : 		var->value = atoi(var->string);

  003d0	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  003d3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003d6	51		 push	 ecx
  003d7	e8 00 00 00 00	 call	 _atoi
  003dc	83 c4 04	 add	 esp, 4
  003df	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  003e2	89 42 14	 mov	 DWORD PTR [edx+20], eax
$finish$50:

; 1116 : 
; 1117 : finish:
; 1118 : 	if (var->flags & CV_SHOWMODIFONETIME || var->flags & CV_SHOWMODIF)

  003e5	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  003e8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003eb	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  003f1	75 0e		 jne	 SHORT $LN44@Setvalue
  003f3	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  003f6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003f9	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  003ff	74 2c		 je	 SHORT $LN43@Setvalue
$LN44@Setvalue:

; 1119 : 	{
; 1120 : 		CONS_Printf("%s set to %s\n", var->name, var->string);

  00401	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00404	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00407	51		 push	 ecx
  00408	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0040b	8b 02		 mov	 eax, DWORD PTR [edx]
  0040d	50		 push	 eax
  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GHELFHEK@?$CFs?5set?5to?5?$CFs?6@
  00413	e8 00 00 00 00	 call	 _CONS_Printf
  00418	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1121 : 		var->flags &= ~CV_SHOWMODIFONETIME;

  0041b	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0041e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00421	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  00427	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0042a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN43@Setvalue:

; 1122 : 	}
; 1123 : 	DEBFILE(va("%s set to %s\n", var->name, var->string));

  0042d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00434	74 37		 je	 SHORT $LN45@Setvalue
  00436	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0043b	50		 push	 eax
  0043c	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0043f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00442	52		 push	 edx
  00443	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00446	8b 08		 mov	 ecx, DWORD PTR [eax]
  00448	51		 push	 ecx
  00449	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GHELFHEK@?$CFs?5set?5to?5?$CFs?6@
  0044e	e8 00 00 00 00	 call	 _va
  00453	83 c4 0c	 add	 esp, 12			; 0000000cH
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 _fputs
  0045c	83 c4 08	 add	 esp, 8
  0045f	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00464	50		 push	 eax
  00465	e8 00 00 00 00	 call	 _fflush
  0046a	83 c4 04	 add	 esp, 4
$LN45@Setvalue:

; 1124 : 	var->flags |= CV_MODIFIED;

  0046d	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00470	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00473	83 c9 40	 or	 ecx, 64			; 00000040H
  00476	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00479	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1125 : 	// raise 'on change' code
; 1126 : 	if (var->flags & CV_CALL && !stealth)

  0047c	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0047f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00482	83 e1 02	 and	 ecx, 2
  00485	74 0f		 je	 SHORT $LN46@Setvalue
  00487	83 7d 10 00	 cmp	 DWORD PTR _stealth$[ebp], 0
  0048b	75 09		 jne	 SHORT $LN46@Setvalue

; 1127 : 		var->func();

  0048d	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00490	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00493	ff d1		 call	 ecx
  00495	90		 npad	 1
$LN46@Setvalue:

; 1128 : }

  00496	5f		 pop	 edi
  00497	5e		 pop	 esi
  00498	5b		 pop	 ebx
  00499	8b e5		 mov	 esp, ebp
  0049b	5d		 pop	 ebp
  0049c	c3		 ret	 0
_Setvalue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_FindNetVar
_TEXT	SEGMENT
_cvar$ = -4						; size = 4
_netid$ = 8						; size = 2
_CV_FindNetVar PROC					; COMDAT

; 894  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 895  : 	consvar_t *cvar;
; 896  : 
; 897  : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  0000e	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@CV_FindNet
$LN2@CV_FindNet:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00016	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00019	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_FindNet:
  0001c	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00020	74 16		 je	 SHORT $LN3@CV_FindNet

; 898  : 		if (cvar->netid == netid)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00025	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00029	0f b7 55 08	 movzx	 edx, WORD PTR _netid$[ebp]
  0002d	3b ca		 cmp	 ecx, edx
  0002f	75 05		 jne	 SHORT $LN5@CV_FindNet

; 899  : 			return cvar;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00034	eb 04		 jmp	 SHORT $LN1@CV_FindNet
$LN5@CV_FindNet:
  00036	eb db		 jmp	 SHORT $LN2@CV_FindNet
$LN3@CV_FindNet:

; 900  : 
; 901  : 	return NULL;

  00038	33 c0		 xor	 eax, eax
$LN1@CV_FindNet:

; 902  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_CV_FindNetVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_ComputeNetid
_TEXT	SEGMENT
_i$ = -8						; size = 2
_ret$ = -4						; size = 2
_s$ = 8							; size = 4
_CV_ComputeNetid PROC					; COMDAT

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 875  : 	UINT16 ret = 0, i = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 45 fc	 mov	 WORD PTR _ret$[ebp], ax
  0000f	33 c0		 xor	 eax, eax
  00011	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN2@CV_Compute:

; 876  : 	static UINT16 premiers[16] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};
; 877  : 
; 878  : 	while (*s)

  00015	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00018	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 41		 je	 SHORT $LN3@CV_Compute

; 879  : 	{
; 880  : 		ret = (UINT16)(ret + (*s)*premiers[i]);

  0001f	0f b7 45 fc	 movzx	 eax, WORD PTR _ret$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00026	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00029	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  0002d	0f b7 0c 4d 00
	00 00 00	 movzx	 ecx, WORD PTR ?premiers@?1??CV_ComputeNetid@@9@9[ecx*2]
  00035	0f af d1	 imul	 edx, ecx
  00038	03 c2		 add	 eax, edx
  0003a	66 89 45 fc	 mov	 WORD PTR _ret$[ebp], ax

; 881  : 		s++;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00041	83 c0 01	 add	 eax, 1
  00044	89 45 08	 mov	 DWORD PTR _s$[ebp], eax

; 882  : 		i = (UINT16)((i+1) % 16);

  00047	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  0004b	83 c0 01	 add	 eax, 1
  0004e	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00053	79 05		 jns	 SHORT $LN5@CV_Compute
  00055	48		 dec	 eax
  00056	83 c8 f0	 or	 eax, -16		; fffffff0H
  00059	40		 inc	 eax
$LN5@CV_Compute:
  0005a	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 883  : 	}

  0005e	eb b5		 jmp	 SHORT $LN2@CV_Compute
$LN3@CV_Compute:

; 884  : 	return ret;

  00060	0f b7 45 fc	 movzx	 eax, WORD PTR _ret$[ebp]

; 885  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_CV_ComputeNetid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_TokenizeString
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ptext$ = 8						; size = 4
_COM_TokenizeString PROC				; COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 333  : 	size_t i;
; 334  : 
; 335  : 	// Clear the args from the last string.
; 336  : 	for (i = 0; i < com_argc; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@COM_Tokeni
$LN2@COM_Tokeni:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@COM_Tokeni:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _com_argc
  00024	73 15		 jae	 SHORT $LN3@COM_Tokeni

; 337  : 		Z_Free(com_argv[i]);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _com_argv[eax*4]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _Z_Free
  00036	83 c4 04	 add	 esp, 4
  00039	eb d7		 jmp	 SHORT $LN2@COM_Tokeni
$LN3@COM_Tokeni:

; 338  : 
; 339  : 	com_argc = 0;

  0003b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _com_argc, 0

; 340  : 	com_args = NULL;

  00045	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _com_args, 0
$LN5@COM_Tokeni:

; 341  : 
; 342  : 	while (com_argc < MAX_ARGS)

  0004f	83 3d 00 00 00
	00 50		 cmp	 DWORD PTR _com_argc, 80	; 00000050H
  00056	0f 83 96 00 00
	00		 jae	 $LN6@COM_Tokeni
$LN7@COM_Tokeni:

; 343  : 	{
; 344  : 		// Skip whitespace up to a newline.
; 345  : 		while (*ptext != '\0' && *ptext <= ' ' && *ptext != '\n')

  0005c	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  0005f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00062	85 c9		 test	 ecx, ecx
  00064	74 21		 je	 SHORT $LN8@COM_Tokeni
  00066	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00069	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006c	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0006f	7f 16		 jg	 SHORT $LN8@COM_Tokeni
  00071	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00074	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00077	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0007a	74 0b		 je	 SHORT $LN8@COM_Tokeni

; 346  : 			ptext++;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 08	 mov	 DWORD PTR _ptext$[ebp], eax
  00085	eb d5		 jmp	 SHORT $LN7@COM_Tokeni
$LN8@COM_Tokeni:

; 347  : 
; 348  : 		// A newline means end of command in buffer,
; 349  : 		// thus end of this command's args too.
; 350  : 		if (*ptext == '\n' || *ptext == '\0')

  00087	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  0008a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008d	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00090	74 0a		 je	 SHORT $LN10@COM_Tokeni
  00092	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00095	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00098	85 c9		 test	 ecx, ecx
  0009a	75 02		 jne	 SHORT $LN9@COM_Tokeni
$LN10@COM_Tokeni:

; 351  : 			break;

  0009c	eb 54		 jmp	 SHORT $LN6@COM_Tokeni
$LN9@COM_Tokeni:

; 352  : 
; 353  : 		if (com_argc == 1)

  0009e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _com_argc, 1
  000a5	75 08		 jne	 SHORT $LN11@COM_Tokeni

; 354  : 			com_args = ptext;

  000a7	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _com_args, eax
$LN11@COM_Tokeni:

; 355  : 
; 356  : 		ptext = COM_Parse(ptext);

  000af	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _COM_Parse
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 45 08	 mov	 DWORD PTR _ptext$[ebp], eax

; 357  : 		if (ptext == NULL)

  000be	83 7d 08 00	 cmp	 DWORD PTR _ptext$[ebp], 0
  000c2	75 02		 jne	 SHORT $LN12@COM_Tokeni

; 358  : 			break;

  000c4	eb 2c		 jmp	 SHORT $LN6@COM_Tokeni
$LN12@COM_Tokeni:

; 359  : 
; 360  : 		com_argv[com_argc] = Z_StrDup(com_token);

  000c6	68 00 00 00 00	 push	 OFFSET _com_token
  000cb	e8 00 00 00 00	 call	 _Z_StrDup
  000d0	83 c4 04	 add	 esp, 4
  000d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _com_argc
  000d9	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _com_argv[ecx*4], eax

; 361  : 		com_argc++;

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_argc
  000e5	83 c0 01	 add	 eax, 1
  000e8	a3 00 00 00 00	 mov	 DWORD PTR _com_argc, eax

; 362  : 	}

  000ed	e9 5d ff ff ff	 jmp	 $LN5@COM_Tokeni
$LN6@COM_Tokeni:

; 363  : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
_COM_TokenizeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _Got_NetVar
_TEXT	SEGMENT
tv87 = -88						; size = 4
_buf$1 = -20						; size = 2
_stealth$ = -13						; size = 1
_svalue$ = -12						; size = 4
_netid$ = -8						; size = 2
_cvar$ = -4						; size = 4
_p$ = 8							; size = 4
_playernum$ = 12					; size = 4
_Got_NetVar PROC					; COMDAT

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1140 : 	consvar_t *cvar;
; 1141 : 	UINT16 netid;
; 1142 : 	char *svalue;
; 1143 : 	UINT8 stealth = false;

  00009	c6 45 f3 00	 mov	 BYTE PTR _stealth$[ebp], 0

; 1144 : 
; 1145 : 	if (playernum != serverplayer && playernum != adminplayer && !serverloading)

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _playernum$[ebp]
  00010	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _serverplayer
  00016	74 65		 je	 SHORT $LN4@Got_NetVar
  00018	8b 45 0c	 mov	 eax, DWORD PTR _playernum$[ebp]
  0001b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _adminplayer
  00021	74 5a		 je	 SHORT $LN4@Got_NetVar
  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _serverloading, 0
  0002a	75 51		 jne	 SHORT $LN4@Got_NetVar

; 1146 : 	{
; 1147 : 		// not from server or remote admin, must be hacked/buggy client
; 1148 : 		CONS_Printf("Illegal netvar command received from %s\n", player_names[playernum]);

  0002c	6b 45 0c 16	 imul	 eax, DWORD PTR _playernum$[ebp], 22
  00030	05 00 00 00 00	 add	 eax, OFFSET _player_names
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MFLEKFEE@Illegal?5netvar?5command?5received@
  0003b	e8 00 00 00 00	 call	 _CONS_Printf
  00040	83 c4 08	 add	 esp, 8

; 1149 : 
; 1150 : 		if (server)

  00043	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  0004a	74 2c		 je	 SHORT $LN5@Got_NetVar

; 1151 : 		{
; 1152 : 			XBOXSTATIC UINT8 buf[2];
; 1153 : 
; 1154 : 			buf[0] = (UINT8)playernum;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	6b c8 00	 imul	 ecx, eax, 0
  00054	8a 55 0c	 mov	 dl, BYTE PTR _playernum$[ebp]
  00057	88 54 0d ec	 mov	 BYTE PTR _buf$1[ebp+ecx], dl

; 1155 : 			buf[1] = KICK_MSG_CON_FAIL;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	c1 e0 00	 shl	 eax, 0
  00063	c6 44 05 ec 02	 mov	 BYTE PTR _buf$1[ebp+eax], 2

; 1156 : 			SendNetXCmd(XD_KICK, &buf, 2);

  00068	6a 02		 push	 2
  0006a	8d 45 ec	 lea	 eax, DWORD PTR _buf$1[ebp]
  0006d	50		 push	 eax
  0006e	6a 03		 push	 3
  00070	e8 00 00 00 00	 call	 _SendNetXCmd
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@Got_NetVar:

; 1157 : 		}
; 1158 : 		return;

  00078	e9 d9 00 00 00	 jmp	 $LN1@Got_NetVar
$LN4@Got_NetVar:

; 1159 : 	}
; 1160 : 	netid = READUINT16(*p);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00080	8b 08		 mov	 ecx, DWORD PTR [eax]
  00082	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00085	66 89 55 f8	 mov	 WORD PTR _netid$[ebp], dx
  00089	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	83 c1 02	 add	 ecx, 2
  00091	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00094	89 0a		 mov	 DWORD PTR [edx], ecx

; 1161 : 	cvar = CV_FindNetVar(netid);

  00096	0f b7 45 f8	 movzx	 eax, WORD PTR _netid$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _CV_FindNetVar
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax

; 1162 : 	svalue = (char *)*p;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ab	89 4d f4	 mov	 DWORD PTR _svalue$[ebp], ecx
$LN2@Got_NetVar:

; 1163 : 	SKIPSTRING(*p);

  000ae	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000b6	89 55 a8	 mov	 DWORD PTR tv87[ebp], edx
  000b9	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	83 c1 01	 add	 ecx, 1
  000c1	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000c4	89 0a		 mov	 DWORD PTR [edx], ecx
  000c6	83 7d a8 00	 cmp	 DWORD PTR tv87[ebp], 0
  000ca	74 02		 je	 SHORT $LN3@Got_NetVar
  000cc	eb e0		 jmp	 SHORT $LN2@Got_NetVar
$LN3@Got_NetVar:

; 1164 : 	stealth = READUINT8(*p);

  000ce	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d3	8a 11		 mov	 dl, BYTE PTR [ecx]
  000d5	88 55 f3	 mov	 BYTE PTR _stealth$[ebp], dl
  000d8	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000e3	89 0a		 mov	 DWORD PTR [edx], ecx

; 1165 : 
; 1166 : 	if (!cvar)

  000e5	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  000e9	75 14		 jne	 SHORT $LN6@Got_NetVar

; 1167 : 	{
; 1168 : 		CONS_Printf("\2Netvar not found with netid %hu\n", netid);

  000eb	0f b7 45 f8	 movzx	 eax, WORD PTR _netid$[ebp]
  000ef	50		 push	 eax
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MJKCJHAL@?$ACNetvar?5not?5found?5with?5netid?5?$CFh@
  000f5	e8 00 00 00 00	 call	 _CONS_Printf
  000fa	83 c4 08	 add	 esp, 8

; 1169 : 		return;

  000fd	eb 57		 jmp	 SHORT $LN1@Got_NetVar
$LN6@Got_NetVar:

; 1170 : 	}
; 1171 : #if 0 //defined (GP2X) || defined (PSP)
; 1172 : 	CONS_Printf("Netvar received: %s [netid=%d] value %s\n", cvar->name, netid, svalue);
; 1173 : #endif
; 1174 : 	DEBFILE(va("Netvar received: %s [netid=%d] value %s\n", cvar->name, netid, svalue));

  000ff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00106	74 39		 je	 SHORT $LN7@Got_NetVar
  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0010d	50		 push	 eax
  0010e	8b 4d f4	 mov	 ecx, DWORD PTR _svalue$[ebp]
  00111	51		 push	 ecx
  00112	0f b7 55 f8	 movzx	 edx, WORD PTR _netid$[ebp]
  00116	52		 push	 edx
  00117	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0011a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011c	51		 push	 ecx
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NOOEBCIN@Netvar?5received?3?5?$CFs?5?$FLnetid?$DN?$CFd?$FN?5@
  00122	e8 00 00 00 00	 call	 _va
  00127	83 c4 10	 add	 esp, 16			; 00000010H
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _fputs
  00130	83 c4 08	 add	 esp, 8
  00133	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _fflush
  0013e	83 c4 04	 add	 esp, 4
$LN7@Got_NetVar:

; 1175 : 
; 1176 : 	Setvalue(cvar, svalue, stealth);

  00141	0f b6 45 f3	 movzx	 eax, BYTE PTR _stealth$[ebp]
  00145	50		 push	 eax
  00146	8b 4d f4	 mov	 ecx, DWORD PTR _svalue$[ebp]
  00149	51		 push	 ecx
  0014a	8b 55 fc	 mov	 edx, DWORD PTR _cvar$[ebp]
  0014d	52		 push	 edx
  0014e	e8 00 00 00 00	 call	 _Setvalue
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Got_NetVar:

; 1177 : }

  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
_Got_NetVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Parse
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
_len$ = -8						; size = 4
_c$ = -1						; size = 1
_data$ = 8						; size = 4
_COM_Parse PROC						; COMDAT

; 1578 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1579 : 	char c;
; 1580 : 	size_t len = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 1581 : 
; 1582 : 	com_token[0] = 0;

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	6b c8 00	 imul	 ecx, eax, 0
  00018	89 4d b4	 mov	 DWORD PTR $T4[ebp], ecx
  0001b	81 7d b4 00 04
	00 00		 cmp	 DWORD PTR $T4[ebp], 1024 ; 00000400H
  00022	73 02		 jae	 SHORT $LN23@COM_Parse
  00024	eb 06		 jmp	 SHORT $LN24@COM_Parse
$LN23@COM_Parse:
  00026	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0002b	90		 npad	 1
$LN24@COM_Parse:
  0002c	8b 55 b4	 mov	 edx, DWORD PTR $T4[ebp]
  0002f	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _com_token[edx], 0

; 1583 : 
; 1584 : 	if (data == NULL)

  00036	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  0003a	75 07		 jne	 SHORT $skipwhite$31

; 1585 : 		return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 e0 01 00 00	 jmp	 $LN1@COM_Parse
$skipwhite$31:

; 1586 : 
; 1587 : 	// skip whitespace
; 1588 : skipwhite:
; 1589 : 	while ((c = *data) <= ' ')

  00043	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00046	8a 08		 mov	 cl, BYTE PTR [eax]
  00048	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl
  0004b	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  0004f	83 fa 20	 cmp	 edx, 32			; 00000020H
  00052	7f 1a		 jg	 SHORT $LN3@COM_Parse

; 1590 : 	{
; 1591 : 		if (c == '\0')

  00054	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN13@COM_Parse

; 1592 : 			return NULL; // end of file;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 c0 01 00 00	 jmp	 $LN1@COM_Parse
$LN13@COM_Parse:

; 1593 : 		data++;

  00063	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 08	 mov	 DWORD PTR _data$[ebp], eax

; 1594 : 	}

  0006c	eb d5		 jmp	 SHORT $skipwhite$31
$LN3@COM_Parse:

; 1595 : 
; 1596 : 	// skip // comments
; 1597 : 	if (c == '/' && data[1] == '/')

  0006e	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00072	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00075	75 36		 jne	 SHORT $LN14@COM_Parse
  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	c1 e0 00	 shl	 eax, 0
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00082	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00086	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00089	75 22		 jne	 SHORT $LN14@COM_Parse
$LN4@COM_Parse:

; 1598 : 	{
; 1599 : 		while (*data && *data != '\n')

  0008b	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0008e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00091	85 c9		 test	 ecx, ecx
  00093	74 16		 je	 SHORT $LN5@COM_Parse
  00095	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00098	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009b	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0009e	74 0b		 je	 SHORT $LN5@COM_Parse

; 1600 : 			data++;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	89 45 08	 mov	 DWORD PTR _data$[ebp], eax
  000a9	eb e0		 jmp	 SHORT $LN4@COM_Parse
$LN5@COM_Parse:

; 1601 : 		goto skipwhite;

  000ab	eb 96		 jmp	 SHORT $skipwhite$31
$LN14@COM_Parse:

; 1602 : 	}
; 1603 : 
; 1604 : 	// handle quoted strings specially
; 1605 : 	if (c == '\"')

  000ad	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  000b1	83 f8 22	 cmp	 eax, 34			; 00000022H
  000b4	75 6b		 jne	 SHORT $LN7@COM_Parse

; 1606 : 	{
; 1607 : 		data++;

  000b6	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 08	 mov	 DWORD PTR _data$[ebp], eax
$LN6@COM_Parse:

; 1608 : 		for (;;)
; 1609 : 		{
; 1610 : 			c = *data++;

  000bf	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000c2	8a 08		 mov	 cl, BYTE PTR [eax]
  000c4	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl
  000c7	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  000ca	83 c2 01	 add	 edx, 1
  000cd	89 55 08	 mov	 DWORD PTR _data$[ebp], edx

; 1611 : 			if (c == '\"' || c == '\0')

  000d0	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  000d4	83 f8 22	 cmp	 eax, 34			; 00000022H
  000d7	74 08		 je	 SHORT $LN17@COM_Parse
  000d9	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  000dd	85 c0		 test	 eax, eax
  000df	75 29		 jne	 SHORT $LN16@COM_Parse
$LN17@COM_Parse:

; 1612 : 			{
; 1613 : 				com_token[len] = 0;

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000e4	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
  000e7	81 7d b0 00 04
	00 00		 cmp	 DWORD PTR $T3[ebp], 1024 ; 00000400H
  000ee	73 02		 jae	 SHORT $LN25@COM_Parse
  000f0	eb 06		 jmp	 SHORT $LN26@COM_Parse
$LN25@COM_Parse:
  000f2	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  000f7	90		 npad	 1
$LN26@COM_Parse:
  000f8	8b 4d b0	 mov	 ecx, DWORD PTR $T3[ebp]
  000fb	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _com_token[ecx], 0

; 1614 : 				return data;

  00102	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00105	e9 19 01 00 00	 jmp	 $LN1@COM_Parse
$LN16@COM_Parse:

; 1615 : 			}
; 1616 : 			com_token[len] = c;

  0010a	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0010d	8a 4d ff	 mov	 cl, BYTE PTR _c$[ebp]
  00110	88 88 00 00 00
	00		 mov	 BYTE PTR _com_token[eax], cl

; 1617 : 			len++;

  00116	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00119	83 c0 01	 add	 eax, 1
  0011c	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1618 : 		}

  0011f	eb 9e		 jmp	 SHORT $LN6@COM_Parse
$LN7@COM_Parse:

; 1619 : 	}
; 1620 : 
; 1621 : 	// parse single characters
; 1622 : 	if (c == '{' || c == '}' || c == ')' || c == '(' || c == '\'' || c == ':')

  00121	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00125	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  00128	74 2d		 je	 SHORT $LN19@COM_Parse
  0012a	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  0012e	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00131	74 24		 je	 SHORT $LN19@COM_Parse
  00133	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00137	83 f8 29	 cmp	 eax, 41			; 00000029H
  0013a	74 1b		 je	 SHORT $LN19@COM_Parse
  0013c	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00140	83 f8 28	 cmp	 eax, 40			; 00000028H
  00143	74 12		 je	 SHORT $LN19@COM_Parse
  00145	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00149	83 f8 27	 cmp	 eax, 39			; 00000027H
  0014c	74 09		 je	 SHORT $LN19@COM_Parse
  0014e	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00152	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00155	75 41		 jne	 SHORT $LN18@COM_Parse
$LN19@COM_Parse:

; 1623 : 	{
; 1624 : 		com_token[len] = c;

  00157	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0015a	8a 4d ff	 mov	 cl, BYTE PTR _c$[ebp]
  0015d	88 88 00 00 00
	00		 mov	 BYTE PTR _com_token[eax], cl

; 1625 : 		len++;

  00163	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00166	83 c0 01	 add	 eax, 1
  00169	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1626 : 		com_token[len] = 0;

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0016f	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
  00172	81 7d ac 00 04
	00 00		 cmp	 DWORD PTR $T2[ebp], 1024 ; 00000400H
  00179	73 02		 jae	 SHORT $LN27@COM_Parse
  0017b	eb 06		 jmp	 SHORT $LN28@COM_Parse
$LN27@COM_Parse:
  0017d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00182	90		 npad	 1
$LN28@COM_Parse:
  00183	8b 4d ac	 mov	 ecx, DWORD PTR $T2[ebp]
  00186	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _com_token[ecx], 0

; 1627 : 		return data + 1;

  0018d	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	e9 8b 00 00 00	 jmp	 $LN1@COM_Parse
$LN18@COM_Parse:

; 1628 : 	}
; 1629 : 
; 1630 : 	// parse a regular word
; 1631 : 	do
; 1632 : 	{
; 1633 : 		com_token[len] = c;

  00198	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0019b	8a 4d ff	 mov	 cl, BYTE PTR _c$[ebp]
  0019e	88 88 00 00 00
	00		 mov	 BYTE PTR _com_token[eax], cl

; 1634 : 		data++;

  001a4	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001a7	83 c0 01	 add	 eax, 1
  001aa	89 45 08	 mov	 DWORD PTR _data$[ebp], eax

; 1635 : 		len++;

  001ad	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  001b0	83 c0 01	 add	 eax, 1
  001b3	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1636 : 		c = *data;

  001b6	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001b9	8a 08		 mov	 cl, BYTE PTR [eax]
  001bb	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl

; 1637 : 		if (c == '{' || c == '}' || c == ')'|| c == '(' || c == '\'' || c == ':')

  001be	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001c2	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  001c5	74 2d		 je	 SHORT $LN21@COM_Parse
  001c7	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001cb	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  001ce	74 24		 je	 SHORT $LN21@COM_Parse
  001d0	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001d4	83 f8 29	 cmp	 eax, 41			; 00000029H
  001d7	74 1b		 je	 SHORT $LN21@COM_Parse
  001d9	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001dd	83 f8 28	 cmp	 eax, 40			; 00000028H
  001e0	74 12		 je	 SHORT $LN21@COM_Parse
  001e2	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001e6	83 f8 27	 cmp	 eax, 39			; 00000027H
  001e9	74 09		 je	 SHORT $LN21@COM_Parse
  001eb	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001ef	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  001f2	75 02		 jne	 SHORT $LN20@COM_Parse
$LN21@COM_Parse:

; 1638 : 			break;

  001f4	eb 09		 jmp	 SHORT $LN10@COM_Parse
$LN20@COM_Parse:

; 1639 : 	} while (c > 32);

  001f6	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001fa	83 f8 20	 cmp	 eax, 32			; 00000020H
  001fd	7f 99		 jg	 SHORT $LN18@COM_Parse
$LN10@COM_Parse:

; 1640 : 
; 1641 : 	com_token[len] = 0;

  001ff	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00202	89 45 a8	 mov	 DWORD PTR $T1[ebp], eax
  00205	81 7d a8 00 04
	00 00		 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  0020c	73 02		 jae	 SHORT $LN29@COM_Parse
  0020e	eb 06		 jmp	 SHORT $LN30@COM_Parse
$LN29@COM_Parse:
  00210	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00215	90		 npad	 1
$LN30@COM_Parse:
  00216	8b 4d a8	 mov	 ecx, DWORD PTR $T1[ebp]
  00219	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _com_token[ecx], 0

; 1642 : 	return data;

  00220	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
$LN1@COM_Parse:

; 1643 : }

  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx
  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
_COM_Parse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_StringValue
_TEXT	SEGMENT
_var$ = -4						; size = 4
_var_name$ = 8						; size = 4
_CV_StringValue PROC					; COMDAT

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 971  : 	consvar_t *var;
; 972  : 
; 973  : 	var = CV_FindVar(var_name);

  00009	8b 45 08	 mov	 eax, DWORD PTR _var_name$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _CV_FindVar
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _var$[ebp], eax

; 974  : 	if (!var)

  00018	83 7d fc 00	 cmp	 DWORD PTR _var$[ebp], 0
  0001c	75 07		 jne	 SHORT $LN2@CV_StringV

; 975  : 		return cv_null_string;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _cv_null_string
  00023	eb 06		 jmp	 SHORT $LN1@CV_StringV
$LN2@CV_StringV:

; 976  : 	return var->string;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _var$[ebp]
  00028	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
$LN1@CV_StringV:

; 977  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_CV_StringValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_FindVar
_TEXT	SEGMENT
_cvar$ = -4						; size = 4
_name$ = 8						; size = 4
_CV_FindVar PROC					; COMDAT

; 856  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 857  : 	consvar_t *cvar;
; 858  : 
; 859  : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  0000e	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@CV_FindVar
$LN2@CV_FindVar:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00016	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00019	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_FindVar:
  0001c	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00020	74 1d		 je	 SHORT $LN3@CV_FindVar

; 860  : 		if (!stricmp(name,cvar->name))

  00022	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _stricmp
  00031	83 c4 08	 add	 esp, 8
  00034	85 c0		 test	 eax, eax
  00036	75 05		 jne	 SHORT $LN5@CV_FindVar

; 861  : 			return cvar;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0003b	eb 04		 jmp	 SHORT $LN1@CV_FindVar
$LN5@CV_FindVar:
  0003d	eb d4		 jmp	 SHORT $LN2@CV_FindVar
$LN3@CV_FindVar:

; 862  : 
; 863  : 	return NULL;

  0003f	33 c0		 xor	 eax, eax
$LN1@CV_FindVar:

; 864  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_CV_FindVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_Command
_TEXT	SEGMENT
_v$ = -4						; size = 4
_CV_Command PROC					; COMDAT

; 1510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1511 : 	consvar_t *v;
; 1512 : 
; 1513 : 	// check variables
; 1514 : 	v = CV_FindVar(COM_Argv(0));

  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _COM_Argv
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _CV_FindVar
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax

; 1515 : 	if (!v)

  0001f	83 7d fc 00	 cmp	 DWORD PTR _v$[ebp], 0
  00023	75 04		 jne	 SHORT $LN2@CV_Command

; 1516 : 		return false;

  00025	33 c0		 xor	 eax, eax
  00027	eb 55		 jmp	 SHORT $LN1@CV_Command
$LN2@CV_Command:

; 1517 : 
; 1518 : 	// perform a variable print or set
; 1519 : 	if (COM_Argc() == 1)

  00029	e8 00 00 00 00	 call	 _COM_Argc
  0002e	83 f8 01	 cmp	 eax, 1
  00031	75 28		 jne	 SHORT $LN3@CV_Command

; 1520 : 	{
; 1521 : 		CONS_Printf("\"%s\" is \"%s\" default is \"%s\"\n", v->name, v->string, v->defaultvalue);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	51		 push	 ecx
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _v$[ebp]
  0003d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _v$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	52		 push	 edx
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NLKDOPKH@?$CC?$CFs?$CC?5is?5?$CC?$CFs?$CC?5default?5is?5?$CC?$CFs?$CC?6@
  0004c	e8 00 00 00 00	 call	 _CONS_Printf
  00051	83 c4 10	 add	 esp, 16			; 00000010H

; 1522 : 		return true;

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	eb 23		 jmp	 SHORT $LN1@CV_Command
$LN3@CV_Command:

; 1523 : 	}
; 1524 : 
; 1525 : 	CV_Set(v, COM_Argv(1));

  0005b	6a 01		 push	 1
  0005d	e8 00 00 00 00	 call	 _COM_Argv
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _CV_Set
  0006f	83 c4 08	 add	 esp, 8

; 1526 : 	v->changed = 1; // now it's been changed by (presumably) the user

  00072	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00075	c6 40 22 01	 mov	 BYTE PTR [eax+34], 1

; 1527 : 	return true;

  00079	b8 01 00 00 00	 mov	 eax, 1
$LN1@CV_Command:

; 1528 : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_CV_Command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Toggle_f
_TEXT	SEGMENT
_cvar$ = -4						; size = 4
_COM_Toggle_f PROC					; COMDAT

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 710  : 	consvar_t *cvar;
; 711  : 
; 712  : 	if (COM_Argc() != 2)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 02	 cmp	 eax, 2
  00011	74 12		 je	 SHORT $LN2@COM_Toggle

; 713  : 	{
; 714  : 		CONS_Printf("Toggle <cvar_name>\n"

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MABMEIEJ@Toggle?5?$DMcvar_name?$DO?6Toggle?5the?5v@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 715  : 			"Toggle the value of a cvar\n");
; 716  : 		return;

  00020	e9 88 00 00 00	 jmp	 $LN1@COM_Toggle
$LN2@COM_Toggle:

; 717  : 	}
; 718  : 	cvar = CV_FindVar(COM_Argv(1));

  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 _COM_Argv
  0002c	83 c4 04	 add	 esp, 4
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _CV_FindVar
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax

; 719  : 	if (!cvar)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  0003f	75 1a		 jne	 SHORT $LN3@COM_Toggle

; 720  : 	{
; 721  : 		CONS_Printf("%s is not a cvar\n",COM_Argv(1));

  00041	6a 01		 push	 1
  00043	e8 00 00 00 00	 call	 _COM_Argv
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GKGHMHFB@?$CFs?5is?5not?5a?5cvar?6@
  00051	e8 00 00 00 00	 call	 _CONS_Printf
  00056	83 c4 08	 add	 esp, 8

; 722  : 		return;

  00059	eb 52		 jmp	 SHORT $LN1@COM_Toggle
$LN3@COM_Toggle:

; 723  : 	}
; 724  : 
; 725  : 	if (!(cvar->PossibleValue == CV_YesNo || cvar->PossibleValue == CV_OnOff))

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0005e	81 78 0c 00 00
	00 00		 cmp	 DWORD PTR [eax+12], OFFSET _CV_YesNo
  00065	74 26		 je	 SHORT $LN4@COM_Toggle
  00067	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0006a	81 78 0c 00 00
	00 00		 cmp	 DWORD PTR [eax+12], OFFSET _CV_OnOff
  00071	74 1a		 je	 SHORT $LN4@COM_Toggle

; 726  : 	{
; 727  : 		CONS_Printf("%s is not a boolean value\n",COM_Argv(1));

  00073	6a 01		 push	 1
  00075	e8 00 00 00 00	 call	 _COM_Argv
  0007a	83 c4 04	 add	 esp, 4
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PEPKEIEH@?$CFs?5is?5not?5a?5boolean?5value?6@
  00083	e8 00 00 00 00	 call	 _CONS_Printf
  00088	83 c4 08	 add	 esp, 8

; 728  : 		return;

  0008b	eb 20		 jmp	 SHORT $LN1@COM_Toggle
$LN4@COM_Toggle:

; 729  : 	}
; 730  : 
; 731  : 	// netcvar don't change imediately
; 732  : 	cvar->flags |= CV_SHOWMODIFONETIME;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00090	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00093	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  00099	8b 55 fc	 mov	 edx, DWORD PTR _cvar$[ebp]
  0009c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 733  : 	CV_AddValue(cvar, +1);

  0009f	6a 01		 push	 1
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _CV_AddValue
  000aa	83 c4 08	 add	 esp, 8
$LN1@COM_Toggle:

; 734  : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
_COM_Toggle_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Help_f
_TEXT	SEGMENT
_cvalue$1 = -16						; size = 4
_i$ = -12						; size = 4
_cvar$ = -8						; size = 4
_cmd$ = -4						; size = 4
_COM_Help_f PROC					; COMDAT

; 614  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 615  : 	xcommand_t *cmd;
; 616  : 	consvar_t *cvar;
; 617  : 	INT32 i = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 618  : 
; 619  : 	if (COM_Argc() > 1)

  00010	e8 00 00 00 00	 call	 _COM_Argc
  00015	83 f8 01	 cmp	 eax, 1
  00018	0f 86 5f 02 00
	00		 jbe	 $LN13@COM_Help_f

; 620  : 	{
; 621  : 		cvar = CV_FindVar(COM_Argv(1));

  0001e	6a 01		 push	 1
  00020	e8 00 00 00 00	 call	 _COM_Argv
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _CV_FindVar
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR _cvar$[ebp], eax

; 622  : 		if (cvar)

  00034	83 7d f8 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00038	0f 84 2d 02 00
	00		 je	 $LN15@COM_Help_f

; 623  : 		{
; 624  : 			CONS_Printf("Variable %s:\n",cvar->name);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	51		 push	 ecx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HHGOIADI@Variable?5?$CFs?3?6@
  00049	e8 00 00 00 00	 call	 _CONS_Printf
  0004e	83 c4 08	 add	 esp, 8

; 625  : 			CONS_Printf("  flags :");

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_09HJPHJBO@?5?5flags?5?3@
  00056	e8 00 00 00 00	 call	 _CONS_Printf
  0005b	83 c4 04	 add	 esp, 4

; 626  : 			if (cvar->flags & CV_SAVE)

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	83 e1 01	 and	 ecx, 1
  00067	74 0d		 je	 SHORT $LN17@COM_Help_f

; 627  : 				CONS_Printf("AUTOSAVE ");

  00069	68 00 00 00 00	 push	 OFFSET ??_C@_09NENNDHNF@AUTOSAVE?5@
  0006e	e8 00 00 00 00	 call	 _CONS_Printf
  00073	83 c4 04	 add	 esp, 4
$LN17@COM_Help_f:

; 628  : 			if (cvar->flags & CV_FLOAT)

  00076	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00079	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007c	83 e1 10	 and	 ecx, 16			; 00000010H
  0007f	74 0d		 je	 SHORT $LN18@COM_Help_f

; 629  : 				CONS_Printf("FLOAT ");

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_06DKOIPINL@FLOAT?5@
  00086	e8 00 00 00 00	 call	 _CONS_Printf
  0008b	83 c4 04	 add	 esp, 4
$LN18@COM_Help_f:

; 630  : 			if (cvar->flags & CV_NETVAR)

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00091	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00094	83 e1 04	 and	 ecx, 4
  00097	74 0d		 je	 SHORT $LN19@COM_Help_f

; 631  : 				CONS_Printf("NETVAR ");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_07EJKBDLDJ@NETVAR?5@
  0009e	e8 00 00 00 00	 call	 _CONS_Printf
  000a3	83 c4 04	 add	 esp, 4
$LN19@COM_Help_f:

; 632  : 			if (cvar->flags & CV_CALL)

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  000a9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ac	83 e1 02	 and	 ecx, 2
  000af	74 0d		 je	 SHORT $LN20@COM_Help_f

; 633  : 				CONS_Printf("ACTION ");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_07OEACDBNL@ACTION?5@
  000b6	e8 00 00 00 00	 call	 _CONS_Printf
  000bb	83 c4 04	 add	 esp, 4
$LN20@COM_Help_f:

; 634  : 			if (cvar->flags & CV_CHEAT)

  000be	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  000c1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c4	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  000ca	74 0d		 je	 SHORT $LN21@COM_Help_f

; 635  : 				CONS_Printf("CHEAT ");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_06LJPBINML@CHEAT?5@
  000d1	e8 00 00 00 00	 call	 _CONS_Printf
  000d6	83 c4 04	 add	 esp, 4
$LN21@COM_Help_f:

; 636  : 			CONS_Printf("\n");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000de	e8 00 00 00 00	 call	 _CONS_Printf
  000e3	83 c4 04	 add	 esp, 4

; 637  : 			if (cvar->PossibleValue)

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  000e9	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000ed	0f 84 62 01 00
	00		 je	 $LN22@COM_Help_f

; 638  : 			{
; 639  : 				if (stricmp(cvar->PossibleValue[0].strvalue, "MIN") == 0)

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_03KGHEHEMH@MIN@
  000f8	b8 08 00 00 00	 mov	 eax, 8
  000fd	6b c8 00	 imul	 ecx, eax, 0
  00100	8b 55 f8	 mov	 edx, DWORD PTR _cvar$[ebp]
  00103	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00106	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 _stricmp
  00110	83 c4 08	 add	 esp, 8
  00113	85 c0		 test	 eax, eax
  00115	0f 85 8a 00 00
	00		 jne	 $LN24@COM_Help_f

; 640  : 				{
; 641  : 					for (i = 1; cvar->PossibleValue[i].strvalue != NULL; i++)

  0011b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00122	eb 09		 jmp	 SHORT $LN4@COM_Help_f
$LN2@COM_Help_f:
  00124	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00127	83 c0 01	 add	 eax, 1
  0012a	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@COM_Help_f:
  0012d	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00130	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00133	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00136	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  0013b	74 23		 je	 SHORT $LN3@COM_Help_f

; 642  : 						if (!stricmp(cvar->PossibleValue[i].strvalue, "MAX"))

  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_03LEPPJAKI@MAX@
  00142	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00145	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00148	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0014b	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _stricmp
  00155	83 c4 08	 add	 esp, 8
  00158	85 c0		 test	 eax, eax
  0015a	75 02		 jne	 SHORT $LN26@COM_Help_f

; 643  : 							break;

  0015c	eb 02		 jmp	 SHORT $LN3@COM_Help_f
$LN26@COM_Help_f:
  0015e	eb c4		 jmp	 SHORT $LN2@COM_Help_f
$LN3@COM_Help_f:

; 644  : 					CONS_Printf("  range from %d to %d\n", cvar->PossibleValue[0].value,

  00160	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00163	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00166	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00169	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  0016c	50		 push	 eax
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	6b d1 00	 imul	 edx, ecx, 0
  00175	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00178	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0017b	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  0017e	52		 push	 edx
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MJBMLIGC@?5?5range?5from?5?$CFd?5to?5?$CFd?6@
  00184	e8 00 00 00 00	 call	 _CONS_Printf
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH

; 645  : 						cvar->PossibleValue[i].value);
; 646  : 					CONS_Printf(" Current value: %d\n", cvar->value);

  0018c	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  0018f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00192	51		 push	 ecx
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HMPBCJPP@?5Current?5value?3?5?$CFd?6@
  00198	e8 00 00 00 00	 call	 _CONS_Printf
  0019d	83 c4 08	 add	 esp, 8

; 647  : 				}

  001a0	e9 ae 00 00 00	 jmp	 $LN29@COM_Help_f
$LN24@COM_Help_f:

; 648  : 				else
; 649  : 				{
; 650  : 					const char *cvalue = NULL;

  001a5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cvalue$1[ebp], 0

; 651  : 					CONS_Printf("  possible value : %s\n", cvar->name);

  001ac	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  001af	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b1	51		 push	 ecx
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LHJMBOKG@?5?5possible?5value?5?3?5?$CFs?6@
  001b7	e8 00 00 00 00	 call	 _CONS_Printf
  001bc	83 c4 08	 add	 esp, 8
$LN5@COM_Help_f:

; 652  : 					while (cvar->PossibleValue[i].strvalue)

  001bf	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  001c2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001c5	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  001c8	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  001cd	74 57		 je	 SHORT $LN6@COM_Help_f

; 653  : 					{
; 654  : 						CONS_Printf("    %-2d : %s\n", cvar->PossibleValue[i].value,

  001cf	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  001d2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001d5	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  001d8	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  001dc	50		 push	 eax
  001dd	8b 4d f8	 mov	 ecx, DWORD PTR _cvar$[ebp]
  001e0	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001e3	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001e6	8b 0c c2	 mov	 ecx, DWORD PTR [edx+eax*8]
  001e9	51		 push	 ecx
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EPOFJEGP@?5?5?5?5?$CF?92d?5?3?5?$CFs?6@
  001ef	e8 00 00 00 00	 call	 _CONS_Printf
  001f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 655  : 							cvar->PossibleValue[i].strvalue);
; 656  : 						if (cvar->PossibleValue[i].value == cvar->value)

  001f7	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  001fa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001fd	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00200	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00203	8b 0c d1	 mov	 ecx, DWORD PTR [ecx+edx*8]
  00206	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00209	75 10		 jne	 SHORT $LN27@COM_Help_f

; 657  : 							cvalue = cvar->PossibleValue[i].strvalue;

  0020b	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  0020e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00211	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00214	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  00218	89 45 f0	 mov	 DWORD PTR _cvalue$1[ebp], eax
$LN27@COM_Help_f:

; 658  : 						i++;

  0021b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0021e	83 c0 01	 add	 eax, 1
  00221	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 659  : 					}

  00224	eb 99		 jmp	 SHORT $LN5@COM_Help_f
$LN6@COM_Help_f:

; 660  : 					if (cvalue)

  00226	83 7d f0 00	 cmp	 DWORD PTR _cvalue$1[ebp], 0
  0022a	74 13		 je	 SHORT $LN28@COM_Help_f

; 661  : 						CONS_Printf(" Current value: %s\n", cvalue);

  0022c	8b 45 f0	 mov	 eax, DWORD PTR _cvalue$1[ebp]
  0022f	50		 push	 eax
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GFJIJMAK@?5Current?5value?3?5?$CFs?6@
  00235	e8 00 00 00 00	 call	 _CONS_Printf
  0023a	83 c4 08	 add	 esp, 8
  0023d	eb 14		 jmp	 SHORT $LN29@COM_Help_f
$LN28@COM_Help_f:

; 662  : 					else
; 663  : 						CONS_Printf(" Current value: %d\n", cvar->value);

  0023f	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00242	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00245	51		 push	 ecx
  00246	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HMPBCJPP@?5Current?5value?3?5?$CFd?6@
  0024b	e8 00 00 00 00	 call	 _CONS_Printf
  00250	83 c4 08	 add	 esp, 8
$LN29@COM_Help_f:

; 664  : 				}
; 665  : 			}

  00253	eb 14		 jmp	 SHORT $LN23@COM_Help_f
$LN22@COM_Help_f:

; 666  : 			else
; 667  : 				CONS_Printf(" Current value: %d\n", cvar->value);

  00255	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00258	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0025b	51		 push	 ecx
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HMPBCJPP@?5Current?5value?3?5?$CFd?6@
  00261	e8 00 00 00 00	 call	 _CONS_Printf
  00266	83 c4 08	 add	 esp, 8
$LN23@COM_Help_f:

; 668  : 		}

  00269	eb 0d		 jmp	 SHORT $LN16@COM_Help_f
$LN15@COM_Help_f:

; 669  : 		else
; 670  : 			CONS_Printf("No Help for this command/variable\n");

  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FJGBGHFA@No?5Help?5for?5this?5command?1variab@
  00270	e8 00 00 00 00	 call	 _CONS_Printf
  00275	83 c4 04	 add	 esp, 4
$LN16@COM_Help_f:

; 671  : 	}

  00278	e9 ef 00 00 00	 jmp	 $LN33@COM_Help_f
$LN13@COM_Help_f:

; 672  : 	else
; 673  : 	{
; 674  : 		// commands
; 675  : 		CONS_Printf("\2Commands\n");

  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GGHKNGEP@?$ACCommands?6@
  00282	e8 00 00 00 00	 call	 _CONS_Printf
  00287	83 c4 04	 add	 esp, 4

; 676  : 		for (cmd = com_commands; cmd; cmd = cmd->next)

  0028a	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_commands
  0028f	89 45 fc	 mov	 DWORD PTR _cmd$[ebp], eax
  00292	eb 09		 jmp	 SHORT $LN9@COM_Help_f
$LN7@COM_Help_f:
  00294	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00297	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0029a	89 4d fc	 mov	 DWORD PTR _cmd$[ebp], ecx
$LN9@COM_Help_f:
  0029d	83 7d fc 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  002a1	74 50		 je	 SHORT $LN8@COM_Help_f

; 677  : 		{
; 678  : 			if (!(strcmp(cmd->name, "emilydampstone")))

  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MPBDJGBK@emilydampstone@
  002a8	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  002ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ad	51		 push	 ecx
  002ae	e8 00 00 00 00	 call	 _strcmp
  002b3	83 c4 08	 add	 esp, 8
  002b6	85 c0		 test	 eax, eax
  002b8	75 02		 jne	 SHORT $LN30@COM_Help_f

; 679  : 				continue;

  002ba	eb d8		 jmp	 SHORT $LN7@COM_Help_f
$LN30@COM_Help_f:

; 680  : 
; 681  : 			if (!(strcmp(cmd->name, "iamaghost")))

  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_09NOKCFBCP@iamaghost@
  002c1	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  002c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 _strcmp
  002cc	83 c4 08	 add	 esp, 8
  002cf	85 c0		 test	 eax, eax
  002d1	75 02		 jne	 SHORT $LN31@COM_Help_f

; 682  : 				continue;

  002d3	eb bf		 jmp	 SHORT $LN7@COM_Help_f
$LN31@COM_Help_f:

; 683  : 
; 684  : 			CONS_Printf("%s ",cmd->name);

  002d5	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  002d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002da	51		 push	 ecx
  002db	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5@
  002e0	e8 00 00 00 00	 call	 _CONS_Printf
  002e5	83 c4 08	 add	 esp, 8

; 685  : 			i++;

  002e8	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002eb	83 c0 01	 add	 eax, 1
  002ee	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 686  : 		}

  002f1	eb a1		 jmp	 SHORT $LN7@COM_Help_f
$LN8@COM_Help_f:

; 687  : 
; 688  : 		// variables
; 689  : 		CONS_Printf("\2\nVariables\n");

  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FBKAIGED@?$AC?6Variables?6@
  002f8	e8 00 00 00 00	 call	 _CONS_Printf
  002fd	83 c4 04	 add	 esp, 4

; 690  : 		for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00300	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  00305	89 45 f8	 mov	 DWORD PTR _cvar$[ebp], eax
  00308	eb 09		 jmp	 SHORT $LN12@COM_Help_f
$LN10@COM_Help_f:
  0030a	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  0030d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00310	89 4d f8	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN12@COM_Help_f:
  00313	83 7d f8 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00317	74 2c		 je	 SHORT $LN11@COM_Help_f

; 691  : 		{
; 692  : 			if (!(cvar->flags & CV_NOSHOWHELP))

  00319	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  0031c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0031f	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00325	75 13		 jne	 SHORT $LN32@COM_Help_f

; 693  : 				CONS_Printf("%s ", cvar->name);

  00327	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	51		 push	 ecx
  0032d	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5@
  00332	e8 00 00 00 00	 call	 _CONS_Printf
  00337	83 c4 08	 add	 esp, 8
$LN32@COM_Help_f:

; 694  : 			i++;

  0033a	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0033d	83 c0 01	 add	 eax, 1
  00340	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax

; 695  : 		}

  00343	eb c5		 jmp	 SHORT $LN10@COM_Help_f
$LN11@COM_Help_f:

; 696  : 
; 697  : 		CONS_Printf("\2\nread help file for more or type help <command or variable>\n");

  00345	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@PJDDLJGC@?$AC?6read?5help?5file?5for?5more?5or?5ty@
  0034a	e8 00 00 00 00	 call	 _CONS_Printf
  0034f	83 c4 04	 add	 esp, 4

; 698  : 
; 699  : 		if (devparm)

  00352	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00359	74 11		 je	 SHORT $LN33@COM_Help_f

; 700  : 			CONS_Printf("\2Total : %d\n", i);

  0035b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0035e	50		 push	 eax
  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NGDIOMGD@?$ACTotal?5?3?5?$CFd?6@
  00364	e8 00 00 00 00	 call	 _CONS_Printf
  00369	83 c4 08	 add	 esp, 8
$LN33@COM_Help_f:

; 701  : 	}
; 702  : }

  0036c	5f		 pop	 edi
  0036d	5e		 pop	 esi
  0036e	5b		 pop	 ebx
  0036f	8b e5		 mov	 esp, ebp
  00371	5d		 pop	 ebp
  00372	c3		 ret	 0
_COM_Help_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Wait_f
_TEXT	SEGMENT
_COM_Wait_f PROC					; COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 605  : 	if (COM_Argc() > 1)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 01	 cmp	 eax, 1
  00011	76 1a		 jbe	 SHORT $LN2@COM_Wait_f

; 606  : 		com_wait = atoi(COM_Argv(1));

  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 _COM_Argv
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _atoi
  00023	83 c4 04	 add	 esp, 4
  00026	a3 00 00 00 00	 mov	 DWORD PTR _com_wait, eax
  0002b	eb 0a		 jmp	 SHORT $LN3@COM_Wait_f
$LN2@COM_Wait_f:

; 607  : 	else
; 608  : 		com_wait = 1; // 1 frame

  0002d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _com_wait, 1
$LN3@COM_Wait_f:

; 609  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_COM_Wait_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Exec_f
_TEXT	SEGMENT
_buf$ = -8						; size = 4
_length$ = -4						; size = 4
_COM_Exec_f PROC					; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 570  : 	size_t length;
; 571  : 	UINT8 *buf = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _buf$[ebp], 0

; 572  : 
; 573  : 	if (COM_Argc() < 2 || COM_Argc() > 3)

  00010	e8 00 00 00 00	 call	 _COM_Argc
  00015	83 f8 02	 cmp	 eax, 2
  00018	72 0a		 jb	 SHORT $LN3@COM_Exec_f
  0001a	e8 00 00 00 00	 call	 _COM_Argc
  0001f	83 f8 03	 cmp	 eax, 3
  00022	76 12		 jbe	 SHORT $LN2@COM_Exec_f
$LN3@COM_Exec_f:

; 574  : 	{
; 575  : 		CONS_Printf("exec <filename> : run a script file\n");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DLKCJBF@exec?5?$DMfilename?$DO?5?3?5run?5a?5script?5@
  00029	e8 00 00 00 00	 call	 _CONS_Printf
  0002e	83 c4 04	 add	 esp, 4

; 576  : 		return;

  00031	e9 99 00 00 00	 jmp	 $LN1@COM_Exec_f
$LN2@COM_Exec_f:

; 577  : 	}
; 578  : 
; 579  : 	// load file
; 580  : 	length = FIL_ReadFile(COM_Argv(1), &buf);

  00036	8d 45 f8	 lea	 eax, DWORD PTR _buf$[ebp]
  00039	50		 push	 eax
  0003a	6a 01		 push	 1
  0003c	e8 00 00 00 00	 call	 _COM_Argv
  00041	83 c4 04	 add	 esp, 4
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _FIL_ReadFile
  0004a	83 c4 08	 add	 esp, 8
  0004d	89 45 fc	 mov	 DWORD PTR _length$[ebp], eax

; 581  : 
; 582  : 	if (!buf)

  00050	83 7d f8 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00054	75 2b		 jne	 SHORT $LN4@COM_Exec_f

; 583  : 	{
; 584  : 		if (!COM_CheckParm("-noerror"))

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_08JGEINCBI@?9noerror@
  0005b	e8 00 00 00 00	 call	 _COM_CheckParm
  00060	83 c4 04	 add	 esp, 4
  00063	85 c0		 test	 eax, eax
  00065	75 18		 jne	 SHORT $LN5@COM_Exec_f

; 585  : 			CONS_Printf("couldn't execute file %s\n", COM_Argv(1));

  00067	6a 01		 push	 1
  00069	e8 00 00 00 00	 call	 _COM_Argv
  0006e	83 c4 04	 add	 esp, 4
  00071	50		 push	 eax
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JLKACNFO@couldn?8t?5execute?5file?5?$CFs?6@
  00077	e8 00 00 00 00	 call	 _CONS_Printf
  0007c	83 c4 08	 add	 esp, 8
$LN5@COM_Exec_f:

; 586  : 		return;

  0007f	eb 4e		 jmp	 SHORT $LN1@COM_Exec_f
$LN4@COM_Exec_f:

; 587  : 	}
; 588  : 
; 589  : 	if (!COM_CheckParm("-silent"))

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_07FDPFAEJA@?9silent@
  00086	e8 00 00 00 00	 call	 _COM_CheckParm
  0008b	83 c4 04	 add	 esp, 4
  0008e	85 c0		 test	 eax, eax
  00090	75 18		 jne	 SHORT $LN6@COM_Exec_f

; 590  : 		CONS_Printf("executing %s\n", COM_Argv(1));

  00092	6a 01		 push	 1
  00094	e8 00 00 00 00	 call	 _COM_Argv
  00099	83 c4 04	 add	 esp, 4
  0009c	50		 push	 eax
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PJIMACPA@executing?5?$CFs?6@
  000a2	e8 00 00 00 00	 call	 _CONS_Printf
  000a7	83 c4 08	 add	 esp, 8
$LN6@COM_Exec_f:

; 591  : 
; 592  : 	// insert text file into the command buffer
; 593  : 	COM_BufAddText((char *)buf);

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _buf$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _COM_BufAddText
  000b3	83 c4 04	 add	 esp, 4

; 594  : 	COM_BufAddText("\n");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000bb	e8 00 00 00 00	 call	 _COM_BufAddText
  000c0	83 c4 04	 add	 esp, 4

; 595  : 
; 596  : 	// free buffer
; 597  : 	Z_Free(buf);

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _buf$[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _Z_Free
  000cc	83 c4 04	 add	 esp, 4
$LN1@COM_Exec_f:

; 598  : }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_COM_Exec_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_CEchoDuration_f
_TEXT	SEGMENT
_COM_CEchoDuration_f PROC				; COMDAT

; 561  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 562  : 	if (COM_Argc() > 1)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 01	 cmp	 eax, 1
  00011	76 1c		 jbe	 SHORT $LN2@COM_CEchoD

; 563  : 		HU_SetCEchoDuration(atoi(COM_Argv(1)));

  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 _COM_Argv
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _atoi
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _HU_SetCEchoDuration
  0002c	83 c4 04	 add	 esp, 4
$LN2@COM_CEchoD:

; 564  : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_COM_CEchoDuration_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_CEchoFlags_f
_TEXT	SEGMENT
_COM_CEchoFlags_f PROC					; COMDAT

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 554  : 	if (COM_Argc() > 1)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 01	 cmp	 eax, 1
  00011	76 1c		 jbe	 SHORT $LN2@COM_CEchoF

; 555  : 		HU_SetCEchoFlags(atoi(COM_Argv(1)));

  00013	6a 01		 push	 1
  00015	e8 00 00 00 00	 call	 _COM_Argv
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _atoi
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _HU_SetCEchoFlags
  0002c	83 c4 04	 add	 esp, 4
$LN2@COM_CEchoF:

; 556  : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_COM_CEchoFlags_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_CEcho_f
_TEXT	SEGMENT
$T1 = -1228						; size = 4
_cechotext$ = -1032					; size = 1024
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_COM_CEcho_f PROC					; COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 04 00
	00		 sub	 esp, 1228		; 000004ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 536  : 	size_t i;
; 537  : 	char cechotext[1024] = "";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 f8 fb ff
	ff		 mov	 BYTE PTR _cechotext$[ebp], al
  00021	68 ff 03 00 00	 push	 1023			; 000003ffH
  00026	6a 00		 push	 0
  00028	8d 85 f9 fb ff
	ff		 lea	 eax, DWORD PTR _cechotext$[ebp+1]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 538  : 
; 539  : 	for (i = 1; i < COM_Argc(); i++)

  00037	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0003e	eb 09		 jmp	 SHORT $LN4@COM_CEcho_
$LN2@COM_CEcho_:
  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@COM_CEcho_:
  00049	e8 00 00 00 00	 call	 _COM_Argc
  0004e	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00051	73 3c		 jae	 SHORT $LN3@COM_CEcho_

; 540  : 	{
; 541  : 		strncat(cechotext, COM_Argv(i), sizeof(cechotext)-1);

  00053	68 ff 03 00 00	 push	 1023			; 000003ffH
  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _COM_Argv
  00061	83 c4 04	 add	 esp, 4
  00064	50		 push	 eax
  00065	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _cechotext$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 _strncat
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 		strncat(cechotext, " ", sizeof(cechotext)-1);

  00074	68 ff 03 00 00	 push	 1023			; 000003ffH
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0007e	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _cechotext$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _strncat
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 543  : 	}

  0008d	eb b1		 jmp	 SHORT $LN2@COM_CEcho_
$LN3@COM_CEcho_:

; 544  : 
; 545  : 	cechotext[sizeof(cechotext) - 1] = '\0';

  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	69 c8 ff 03 00
	00		 imul	 ecx, eax, 1023
  0009a	89 8d 34 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000a0	81 bd 34 fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  000aa	73 02		 jae	 SHORT $LN6@COM_CEcho_
  000ac	eb 06		 jmp	 SHORT $LN7@COM_CEcho_
$LN6@COM_CEcho_:
  000ae	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  000b3	90		 npad	 1
$LN7@COM_CEcho_:
  000b4	8b 95 34 fb ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  000ba	c6 84 15 f8 fb
	ff ff 00	 mov	 BYTE PTR _cechotext$[ebp+edx], 0

; 546  : 
; 547  : 	HU_DoCEcho(cechotext);

  000c2	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _cechotext$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _HU_DoCEcho
  000ce	83 c4 04	 add	 esp, 4
$LN1@COM_CEcho_:

; 548  : }

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d7	33 cd		 xor	 ecx, ebp
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_COM_CEcho_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Echo_f
_TEXT	SEGMENT
_i$ = -4						; size = 4
_COM_Echo_f PROC					; COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 525  : 	size_t i;
; 526  : 
; 527  : 	for (i = 1; i < COM_Argc(); i++)

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00010	eb 09		 jmp	 SHORT $LN4@COM_Echo_f
$LN2@COM_Echo_f:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@COM_Echo_f:
  0001b	e8 00 00 00 00	 call	 _COM_Argc
  00020	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00023	73 1c		 jae	 SHORT $LN3@COM_Echo_f

; 528  : 		CONS_Printf("%s ", COM_Argv(i));

  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _COM_Argv
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5@
  00037	e8 00 00 00 00	 call	 _CONS_Printf
  0003c	83 c4 08	 add	 esp, 8
  0003f	eb d1		 jmp	 SHORT $LN2@COM_Echo_f
$LN3@COM_Echo_f:

; 529  : 	CONS_Printf("\n");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00046	e8 00 00 00 00	 call	 _CONS_Printf
  0004b	83 c4 04	 add	 esp, 4

; 530  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_COM_Echo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Alias_f
_TEXT	SEGMENT
$T1 = -1236						; size = 4
_c$ = -1040						; size = 4
_i$ = -1036						; size = 4
_cmd$ = -1032						; size = 1024
_a$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_COM_Alias_f PROC					; COMDAT

; 490  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 491  : 	cmdalias_t *a;
; 492  : 	char cmd[1024];
; 493  : 	size_t i, c;
; 494  : 
; 495  : 	if (COM_Argc() < 3)

  00016	e8 00 00 00 00	 call	 _COM_Argc
  0001b	83 f8 03	 cmp	 eax, 3
  0001e	73 12		 jae	 SHORT $LN5@COM_Alias_

; 496  : 	{
; 497  : 		CONS_Printf("alias <name> <command>\n");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HCGIPMNK@alias?5?$DMname?$DO?5?$DMcommand?$DO?6@
  00025	e8 00 00 00 00	 call	 _CONS_Printf
  0002a	83 c4 04	 add	 esp, 4

; 498  : 		return;

  0002d	e9 0f 01 00 00	 jmp	 $LN1@COM_Alias_
$LN5@COM_Alias_:

; 499  : 	}
; 500  : 
; 501  : 	a = ZZ_Alloc(sizeof *a);

  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 01		 push	 1
  00038	6a 0c		 push	 12			; 0000000cH
  0003a	e8 00 00 00 00	 call	 _Z_MallocAlign
  0003f	83 c4 10	 add	 esp, 16			; 00000010H
  00042	89 45 f8	 mov	 DWORD PTR _a$[ebp], eax

; 502  : 	a->next = com_alias;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _com_alias
  0004e	89 08		 mov	 DWORD PTR [eax], ecx

; 503  : 	com_alias = a;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  00053	a3 00 00 00 00	 mov	 DWORD PTR _com_alias, eax

; 504  : 
; 505  : 	a->name = Z_StrDup(COM_Argv(1));

  00058	6a 01		 push	 1
  0005a	e8 00 00 00 00	 call	 _COM_Argv
  0005f	83 c4 04	 add	 esp, 4
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _Z_StrDup
  00068	83 c4 04	 add	 esp, 4
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 506  : 
; 507  : 	// copy the rest of the command line
; 508  : 	cmd[0] = 0; // start out with a null string

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	6b c8 00	 imul	 ecx, eax, 0
  00079	89 8d 2c fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0007f	81 bd 2c fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  00089	73 02		 jae	 SHORT $LN8@COM_Alias_
  0008b	eb 06		 jmp	 SHORT $LN9@COM_Alias_
$LN8@COM_Alias_:
  0008d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00092	90		 npad	 1
$LN9@COM_Alias_:
  00093	8b 95 2c fb ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00099	c6 84 15 f8 fb
	ff ff 00	 mov	 BYTE PTR _cmd$[ebp+edx], 0

; 509  : 	c = COM_Argc();

  000a1	e8 00 00 00 00	 call	 _COM_Argc
  000a6	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _c$[ebp], eax

; 510  : 	for (i = 2; i < c; i++)

  000ac	c7 85 f4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR _i$[ebp], 2
  000b6	eb 0f		 jmp	 SHORT $LN4@COM_Alias_
$LN2@COM_Alias_:
  000b8	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000be	83 c0 01	 add	 eax, 1
  000c1	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@COM_Alias_:
  000c7	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000cd	3b 85 f0 fb ff
	ff		 cmp	 eax, DWORD PTR _c$[ebp]
  000d3	73 43		 jae	 SHORT $LN3@COM_Alias_

; 511  : 	{
; 512  : 		strcat(cmd, COM_Argv(i));

  000d5	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _COM_Argv
  000e1	83 c4 04	 add	 esp, 4
  000e4	50		 push	 eax
  000e5	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _cmd$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _strcat
  000f1	83 c4 08	 add	 esp, 8

; 513  : 		if (i != c)

  000f4	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000fa	3b 85 f0 fb ff
	ff		 cmp	 eax, DWORD PTR _c$[ebp]
  00100	74 14		 je	 SHORT $LN6@COM_Alias_

; 514  : 			strcat(cmd, " ");

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00107	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _cmd$[ebp]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _strcat
  00113	83 c4 08	 add	 esp, 8
$LN6@COM_Alias_:

; 515  : 	}

  00116	eb a0		 jmp	 SHORT $LN2@COM_Alias_
$LN3@COM_Alias_:

; 516  : 	strcat(cmd, "\n");

  00118	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0011d	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _cmd$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _strcat
  00129	83 c4 08	 add	 esp, 8

; 517  : 
; 518  : 	a->value = Z_StrDup(cmd);

  0012c	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _cmd$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _Z_StrDup
  00138	83 c4 04	 add	 esp, 4
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  0013e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@COM_Alias_:

; 519  : }

  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx
  00144	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_COM_Alias_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_ExecuteString
_TEXT	SEGMENT
_a$ = -8						; size = 4
_cmd$ = -4						; size = 4
_ptext$ = 8						; size = 4
_COM_ExecuteString PROC					; COMDAT

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 447  : 	xcommand_t *cmd;
; 448  : 	cmdalias_t *a;
; 449  : 
; 450  : 	COM_TokenizeString(ptext);

  00009	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _COM_TokenizeString
  00012	83 c4 04	 add	 esp, 4

; 451  : 
; 452  : 	// execute the command line
; 453  : 	if (COM_Argc() == 0)

  00015	e8 00 00 00 00	 call	 _COM_Argc
  0001a	85 c0		 test	 eax, eax
  0001c	75 05		 jne	 SHORT $LN8@COM_Execut

; 454  : 		return; // no tokens

  0001e	e9 be 00 00 00	 jmp	 $LN11@COM_Execut
$LN8@COM_Execut:

; 455  : 
; 456  : 	// check functions
; 457  : 	for (cmd = com_commands; cmd; cmd = cmd->next)

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_commands
  00028	89 45 fc	 mov	 DWORD PTR _cmd$[ebp], eax
  0002b	eb 09		 jmp	 SHORT $LN4@COM_Execut
$LN2@COM_Execut:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00033	89 4d fc	 mov	 DWORD PTR _cmd$[ebp], ecx
$LN4@COM_Execut:
  00036	83 7d fc 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  0003a	74 2e		 je	 SHORT $LN3@COM_Execut

; 458  : 	{
; 459  : 		if (!stricmp(com_argv[0], cmd->name)) //case insensitive now that we have lower and uppercase!

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	51		 push	 ecx
  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	6b c2 00	 imul	 eax, edx, 0
  0004a	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _com_argv[eax]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _stricmp
  00056	83 c4 08	 add	 esp, 8
  00059	85 c0		 test	 eax, eax
  0005b	75 0b		 jne	 SHORT $LN9@COM_Execut

; 460  : 		{
; 461  : 			cmd->function();

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00060	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00063	ff d1		 call	 ecx
  00065	90		 npad	 1

; 462  : 			return;

  00066	eb 79		 jmp	 SHORT $LN11@COM_Execut
$LN9@COM_Execut:

; 463  : 		}
; 464  : 	}

  00068	eb c3		 jmp	 SHORT $LN2@COM_Execut
$LN3@COM_Execut:

; 465  : 
; 466  : 	// check aliases
; 467  : 	for (a = com_alias; a; a = a->next)

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_alias
  0006f	89 45 f8	 mov	 DWORD PTR _a$[ebp], eax
  00072	eb 08		 jmp	 SHORT $LN7@COM_Execut
$LN5@COM_Execut:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	89 4d f8	 mov	 DWORD PTR _a$[ebp], ecx
$LN7@COM_Execut:
  0007c	83 7d f8 00	 cmp	 DWORD PTR _a$[ebp], 0
  00080	74 35		 je	 SHORT $LN6@COM_Execut

; 468  : 	{
; 469  : 		if (!stricmp(com_argv[0], a->name))

  00082	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  00085	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00088	51		 push	 ecx
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	6b c2 00	 imul	 eax, edx, 0
  00091	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _com_argv[eax]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 _stricmp
  0009d	83 c4 08	 add	 esp, 8
  000a0	85 c0		 test	 eax, eax
  000a2	75 11		 jne	 SHORT $LN10@COM_Execut

; 470  : 		{
; 471  : 			COM_BufInsertText(a->value);

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  000a7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 _COM_BufInsertText
  000b0	83 c4 04	 add	 esp, 4

; 472  : 			return;

  000b3	eb 2c		 jmp	 SHORT $LN11@COM_Execut
$LN10@COM_Execut:

; 473  : 		}
; 474  : 	}

  000b5	eb bd		 jmp	 SHORT $LN5@COM_Execut
$LN6@COM_Execut:

; 475  : 
; 476  : 	// check cvars
; 477  : 	// Hurdler: added at Ebola's request ;)
; 478  : 	// (don't flood the console in software mode with bad gr_xxx command)
; 479  : 	if (!CV_Command() && con_destlines)

  000b7	e8 00 00 00 00	 call	 _CV_Command
  000bc	85 c0		 test	 eax, eax
  000be	75 21		 jne	 SHORT $LN11@COM_Execut
  000c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_destlines, 0
  000c7	74 18		 je	 SHORT $LN11@COM_Execut

; 480  : 		CONS_Printf("Unknown command '%s'\n", COM_Argv(0));

  000c9	6a 00		 push	 0
  000cb	e8 00 00 00 00	 call	 _COM_Argv
  000d0	83 c4 04	 add	 esp, 4
  000d3	50		 push	 eax
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IBOGFLDP@Unknown?5command?5?8?$CFs?8?6@
  000d9	e8 00 00 00 00	 call	 _CONS_Printf
  000de	83 c4 08	 add	 esp, 8
$LN11@COM_Execut:

; 481  : }

  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_COM_ExecuteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Exists
_TEXT	SEGMENT
_cmd$ = -4						; size = 4
_com_name$ = 8						; size = 4
_COM_Exists PROC					; COMDAT

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 405  : 	xcommand_t *cmd;
; 406  : 
; 407  : 	for (cmd = com_commands; cmd; cmd = cmd->next)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_commands
  0000e	89 45 fc	 mov	 DWORD PTR _cmd$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@COM_Exists
$LN2@COM_Exists:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	89 4d fc	 mov	 DWORD PTR _cmd$[ebp], ecx
$LN4@COM_Exists:
  0001c	83 7d fc 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  00020	74 1f		 je	 SHORT $LN3@COM_Exists

; 408  : 		if (!stricmp(com_name, cmd->name))

  00022	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _com_name$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _stricmp
  00031	83 c4 08	 add	 esp, 8
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN5@COM_Exists

; 409  : 			return true;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	eb 04		 jmp	 SHORT $LN1@COM_Exists
$LN5@COM_Exists:
  0003f	eb d2		 jmp	 SHORT $LN2@COM_Exists
$LN3@COM_Exists:

; 410  : 
; 411  : 	return false;

  00041	33 c0		 xor	 eax, eax
$LN1@COM_Exists:

; 412  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_COM_Exists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_ResetCheatNetVars
_TEXT	SEGMENT
_cvar$ = -4						; size = 4
_CV_ResetCheatNetVars PROC				; COMDAT

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1210 : 	consvar_t *cvar;
; 1211 : 
; 1212 : 	// Stealthset everything back to default.
; 1213 : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  0000e	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@CV_ResetCh
$LN2@CV_ResetCh:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00016	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00019	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_ResetCh:
  0001c	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00020	74 25		 je	 SHORT $LN3@CV_ResetCh

; 1214 : 		if (cvar->flags & CV_CHEAT)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00025	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00028	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  0002e	74 15		 je	 SHORT $LN5@CV_ResetCh

; 1215 : 			Setvalue(cvar, cvar->defaultvalue, true);

  00030	6a 01		 push	 1
  00032	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	8b 55 fc	 mov	 edx, DWORD PTR _cvar$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _Setvalue
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CV_ResetCh:
  00045	eb cc		 jmp	 SHORT $LN2@CV_ResetCh
$LN3@CV_ResetCh:

; 1216 : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_CV_ResetCheatNetVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_LoadNetVars
_TEXT	SEGMENT
_cvar$ = -4						; size = 4
_p$ = 8							; size = 4
_CV_LoadNetVars PROC					; COMDAT

; 1197 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1198 : 	consvar_t *cvar;
; 1199 : 
; 1200 : 	serverloading = true;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _serverloading, 1

; 1201 : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  00018	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  0001b	eb 09		 jmp	 SHORT $LN4@CV_LoadNet
$LN2@CV_LoadNet:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00020	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00023	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_LoadNet:
  00026	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  0002a	74 1b		 je	 SHORT $LN3@CV_LoadNet

; 1202 : 		if (cvar->flags & CV_NETVAR)

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0002f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00032	83 e1 04	 and	 ecx, 4
  00035	74 0e		 je	 SHORT $LN5@CV_LoadNet

; 1203 : 			Got_NetVar(p, 0);

  00037	6a 00		 push	 0
  00039	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _Got_NetVar
  00042	83 c4 08	 add	 esp, 8
$LN5@CV_LoadNet:
  00045	eb d6		 jmp	 SHORT $LN2@CV_LoadNet
$LN3@CV_LoadNet:

; 1204 : 
; 1205 : 	serverloading = false;

  00047	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _serverloading, 0

; 1206 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_CV_LoadNetVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_SaveNetVars
_TEXT	SEGMENT
_p_tmp$1 = -24						; size = 4
_p_tmp$2 = -20						; size = 4
_p_tmp$3 = -16						; size = 4
_tmp_i$4 = -12						; size = 4
_p_tmp$5 = -8						; size = 4
_cvar$ = -4						; size = 4
_p$ = 8							; size = 4
_CV_SaveNetVars PROC					; COMDAT

; 1181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1182 : 	consvar_t *cvar;
; 1183 : 
; 1184 : 	// we must send all cvars because on the other side maybe
; 1185 : 	// it has a cvar modified and here not (same for true savegame)
; 1186 : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  0000e	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@CV_SaveNet
$LN2@CV_SaveNet:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00016	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00019	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_SaveNet:
  0001c	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00020	0f 84 d7 00 00
	00		 je	 $LN3@CV_SaveNet

; 1187 : 		if (cvar->flags & CV_NETVAR)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00029	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002c	83 e1 04	 and	 ecx, 4
  0002f	0f 84 c3 00 00
	00		 je	 $LN18@CV_SaveNet
$LN7@CV_SaveNet:

; 1188 : 		{
; 1189 : 			WRITEUINT16(*p, cvar->netid);

  00035	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	89 4d f8	 mov	 DWORD PTR _p_tmp$5[ebp], ecx
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _cvar$[ebp]
  00043	66 8b 51 20	 mov	 dx, WORD PTR [ecx+32]
  00047	66 89 10	 mov	 WORD PTR [eax], dx
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _p_tmp$5[ebp]
  0004d	83 c0 02	 add	 eax, 2
  00050	89 45 f8	 mov	 DWORD PTR _p_tmp$5[ebp], eax
  00053	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _p_tmp$5[ebp]
  00059	89 08		 mov	 DWORD PTR [eax], ecx
  0005b	33 c0		 xor	 eax, eax
  0005d	75 d6		 jne	 SHORT $LN7@CV_SaveNet

; 1190 : 			WRITESTRING(*p, cvar->string);

  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tmp_i$4[ebp], 0
  00066	eb 09		 jmp	 SHORT $LN10@CV_SaveNet
$LN8@CV_SaveNet:
  00068	8b 45 f4	 mov	 eax, DWORD PTR _tmp_i$4[ebp]
  0006b	83 c0 01	 add	 eax, 1
  0006e	89 45 f4	 mov	 DWORD PTR _tmp_i$4[ebp], eax
$LN10@CV_SaveNet:
  00071	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00074	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00077	8b 55 f4	 mov	 edx, DWORD PTR _tmp_i$4[ebp]
  0007a	0f be 04 11	 movsx	 eax, BYTE PTR [ecx+edx]
  0007e	85 c0		 test	 eax, eax
  00080	74 30		 je	 SHORT $LN9@CV_SaveNet
$LN13@CV_SaveNet:
  00082	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 4d f0	 mov	 DWORD PTR _p_tmp$3[ebp], ecx
  0008a	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0008d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00090	8b 55 f0	 mov	 edx, DWORD PTR _p_tmp$3[ebp]
  00093	8b 45 f4	 mov	 eax, DWORD PTR _tmp_i$4[ebp]
  00096	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  00099	88 0a		 mov	 BYTE PTR [edx], cl
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _p_tmp$3[ebp]
  0009e	83 c0 01	 add	 eax, 1
  000a1	89 45 f0	 mov	 DWORD PTR _p_tmp$3[ebp], eax
  000a4	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _p_tmp$3[ebp]
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	33 c0		 xor	 eax, eax
  000ae	75 d2		 jne	 SHORT $LN13@CV_SaveNet
  000b0	eb b6		 jmp	 SHORT $LN8@CV_SaveNet
$LN9@CV_SaveNet:
  000b2	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	89 4d ec	 mov	 DWORD PTR _p_tmp$2[ebp], ecx
  000ba	8b 45 ec	 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  000bd	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c0	8b 45 ec	 mov	 eax, DWORD PTR _p_tmp$2[ebp]
  000c3	83 c0 01	 add	 eax, 1
  000c6	89 45 ec	 mov	 DWORD PTR _p_tmp$2[ebp], eax
  000c9	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000cc	8b 4d ec	 mov	 ecx, DWORD PTR _p_tmp$2[ebp]
  000cf	89 08		 mov	 DWORD PTR [eax], ecx
  000d1	33 c0		 xor	 eax, eax
  000d3	75 dd		 jne	 SHORT $LN9@CV_SaveNet
$LN15@CV_SaveNet:

; 1191 : 			WRITEUINT8(*p, false);

  000d5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	89 4d e8	 mov	 DWORD PTR _p_tmp$1[ebp], ecx
  000dd	8b 45 e8	 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  000e0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e3	8b 45 e8	 mov	 eax, DWORD PTR _p_tmp$1[ebp]
  000e6	83 c0 01	 add	 eax, 1
  000e9	89 45 e8	 mov	 DWORD PTR _p_tmp$1[ebp], eax
  000ec	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ef	8b 4d e8	 mov	 ecx, DWORD PTR _p_tmp$1[ebp]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx
  000f4	33 c0		 xor	 eax, eax
  000f6	75 dd		 jne	 SHORT $LN15@CV_SaveNet
$LN18@CV_SaveNet:

; 1192 : 		}

  000f8	e9 16 ff ff ff	 jmp	 $LN2@CV_SaveNet
$LN3@CV_SaveNet:

; 1193 : }

  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_CV_SaveNetVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_SaveVariables
_TEXT	SEGMENT
_stringtowrite$1 = -268					; size = 257
_cvar$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_CV_SaveVariables PROC					; COMDAT

; 1550 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1551 : 	consvar_t *cvar;
; 1552 : 
; 1553 : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  0001b	89 45 f8	 mov	 DWORD PTR _cvar$[ebp], eax
  0001e	eb 09		 jmp	 SHORT $LN4@CV_SaveVar
$LN2@CV_SaveVar:
  00020	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00023	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00026	89 4d f8	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_SaveVar:
  00029	83 7d f8 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  0002d	0f 84 95 00 00
	00		 je	 $LN3@CV_SaveVar

; 1554 : 		if (cvar->flags & CV_SAVE)

  00033	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00036	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00039	83 e1 01	 and	 ecx, 1
  0003c	0f 84 81 00 00
	00		 je	 $LN5@CV_SaveVar

; 1555 : 		{
; 1556 : 			char stringtowrite[MAXTEXTCMD+1];
; 1557 : 
; 1558 : 			// Silly hack for Min/Max vars
; 1559 : 			if (!strcmp(cvar->string, "MAX") || !strcmp(cvar->string, "MIN"))

  00042	68 00 00 00 00	 push	 OFFSET ??_C@_03LEPPJAKI@MAX@
  00047	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  0004a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _strcmp
  00053	83 c4 08	 add	 esp, 8
  00056	85 c0		 test	 eax, eax
  00058	74 18		 je	 SHORT $LN8@CV_SaveVar
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_03KGHEHEMH@MIN@
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00062	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _strcmp
  0006b	83 c4 08	 add	 esp, 8
  0006e	85 c0		 test	 eax, eax
  00070	75 1d		 jne	 SHORT $LN6@CV_SaveVar
$LN8@CV_SaveVar:

; 1560 : 				sprintf(stringtowrite, "%d", cvar->value);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00075	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00078	51		 push	 ecx
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0007e	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _stringtowrite$1[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _sprintf
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	eb 16		 jmp	 SHORT $LN7@CV_SaveVar
$LN6@CV_SaveVar:

; 1561 : 			else
; 1562 : 				strcpy(stringtowrite, cvar->string);

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _cvar$[ebp]
  00092	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00095	51		 push	 ecx
  00096	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _stringtowrite$1[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _strcpy
  000a2	83 c4 08	 add	 esp, 8
$LN7@CV_SaveVar:

; 1563 : 
; 1564 : 			fprintf(f, "%s \"%s\"\n", cvar->name, stringtowrite);

  000a5	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _stringtowrite$1[ebp]
  000ab	50		 push	 eax
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _cvar$[ebp]
  000af	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b1	52		 push	 edx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
  000b7	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _fprintf
  000c0	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@CV_SaveVar:

; 1565 : 		}

  000c3	e9 58 ff ff ff	 jmp	 $LN2@CV_SaveVar
$LN3@CV_SaveVar:

; 1566 : }

  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
_CV_SaveVariables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_AddValue
_TEXT	SEGMENT
tv515 = -92						; size = 4
_gt$1 = -24						; size = 4
_oldvalue$2 = -20					; size = 4
_newindice$3 = -16					; size = 4
_currentindice$4 = -12					; size = 4
_max$ = -8						; size = 4
_newvalue$ = -4						; size = 4
_var$ = 8						; size = 4
_increment$ = 12					; size = 4
_CV_AddValue PROC					; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1353 : 	INT32 newvalue, max;
; 1354 : 
; 1355 : 	// count pointlimit better
; 1356 : 	if (var == &cv_pointlimit && (gametype == GT_MATCH

  00009	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _var$[ebp], OFFSET _cv_pointlimit
  00010	75 13		 jne	 SHORT $LN20@CV_AddValu
  00012	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 07		 jne	 SHORT $LN20@CV_AddValu

; 1357 : #ifdef CHAOSISNOTDEADYET
; 1358 : 		|| gametype == GT_CHAOS
; 1359 : #endif
; 1360 : 		))
; 1361 : 		increment *= 50;

  0001e	6b 45 0c 32	 imul	 eax, DWORD PTR _increment$[ebp], 50
  00022	89 45 0c	 mov	 DWORD PTR _increment$[ebp], eax
$LN20@CV_AddValu:

; 1362 : 	newvalue = var->value + increment;

  00025	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00028	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002b	03 4d 0c	 add	 ecx, DWORD PTR _increment$[ebp]
  0002e	89 4d fc	 mov	 DWORD PTR _newvalue$[ebp], ecx

; 1363 : 
; 1364 : 	if (var->PossibleValue)

  00031	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00034	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00038	0f 84 51 05 00
	00		 je	 $LN21@CV_AddValu

; 1365 : 	{
; 1366 : #define MINVAL 0
; 1367 : 		if (var->PossibleValue[MINVAL].strvalue && !strcmp(var->PossibleValue[MINVAL].strvalue, "MIN"))

  0003e	b8 08 00 00 00	 mov	 eax, 8
  00043	6b c8 00	 imul	 ecx, eax, 0
  00046	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00049	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004c	83 7c 08 04 00	 cmp	 DWORD PTR [eax+ecx+4], 0
  00051	0f 84 f1 00 00
	00		 je	 $LN23@CV_AddValu
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_03KGHEHEMH@MIN@
  0005c	b8 08 00 00 00	 mov	 eax, 8
  00061	6b c8 00	 imul	 ecx, eax, 0
  00064	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00067	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0006a	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _strcmp
  00074	83 c4 08	 add	 esp, 8
  00077	85 c0		 test	 eax, eax
  00079	0f 85 c9 00 00
	00		 jne	 $LN23@CV_AddValu

; 1368 : 		{
; 1369 : 			// search the next to last
; 1370 : 			for (max = 0; var->PossibleValue[max+1].strvalue; max++)

  0007f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _max$[ebp], 0
  00086	eb 09		 jmp	 SHORT $LN4@CV_AddValu
$LN2@CV_AddValu:
  00088	8b 45 f8	 mov	 eax, DWORD PTR _max$[ebp]
  0008b	83 c0 01	 add	 eax, 1
  0008e	89 45 f8	 mov	 DWORD PTR _max$[ebp], eax
$LN4@CV_AddValu:
  00091	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00094	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00097	8b 55 f8	 mov	 edx, DWORD PTR _max$[ebp]
  0009a	83 7c d1 0c 00	 cmp	 DWORD PTR [ecx+edx*8+12], 0
  0009f	74 02		 je	 SHORT $LN3@CV_AddValu

; 1371 : 				;

  000a1	eb e5		 jmp	 SHORT $LN2@CV_AddValu
$LN3@CV_AddValu:

; 1372 : 
; 1373 : 			if (newvalue < var->PossibleValue[MINVAL].value) // add the max+1

  000a3	b8 08 00 00 00	 mov	 eax, 8
  000a8	6b c8 00	 imul	 ecx, eax, 0
  000ab	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000ae	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _newvalue$[ebp]
  000b4	3b 14 08	 cmp	 edx, DWORD PTR [eax+ecx]
  000b7	7d 27		 jge	 SHORT $LN25@CV_AddValu

; 1374 : 				newvalue += var->PossibleValue[max].value - var->PossibleValue[MINVAL].value + 1;

  000b9	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  000bc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bf	ba 08 00 00 00	 mov	 edx, 8
  000c4	6b c2 00	 imul	 eax, edx, 0
  000c7	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000ca	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000cd	8b 75 f8	 mov	 esi, DWORD PTR _max$[ebp]
  000d0	8b 0c f1	 mov	 ecx, DWORD PTR [ecx+esi*8]
  000d3	2b 0c 02	 sub	 ecx, DWORD PTR [edx+eax]
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _newvalue$[ebp]
  000d9	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  000dd	89 45 fc	 mov	 DWORD PTR _newvalue$[ebp], eax
$LN25@CV_AddValu:

; 1375 : 
; 1376 : 			newvalue = var->PossibleValue[MINVAL].value + (newvalue - var->PossibleValue[MINVAL].value)

  000e0	b8 08 00 00 00	 mov	 eax, 8
  000e5	6b c8 00	 imul	 ecx, eax, 0
  000e8	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000eb	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  000ee	b8 08 00 00 00	 mov	 eax, 8
  000f3	6b d0 00	 imul	 edx, eax, 0
  000f6	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  000f9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000fc	8b 7d fc	 mov	 edi, DWORD PTR _newvalue$[ebp]
  000ff	2b 3c 10	 sub	 edi, DWORD PTR [eax+edx]
  00102	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00105	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00108	ba 08 00 00 00	 mov	 edx, 8
  0010d	6b d2 00	 imul	 edx, edx, 0
  00110	8b 5d 08	 mov	 ebx, DWORD PTR _var$[ebp]
  00113	8b 5b 0c	 mov	 ebx, DWORD PTR [ebx+12]
  00116	89 4d a4	 mov	 DWORD PTR tv515[ebp], ecx
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _max$[ebp]
  0011c	8b 0c c8	 mov	 ecx, DWORD PTR [eax+ecx*8]
  0011f	2b 0c 13	 sub	 ecx, DWORD PTR [ebx+edx]
  00122	83 c1 01	 add	 ecx, 1
  00125	8b c7		 mov	 eax, edi
  00127	99		 cdq
  00128	f7 f9		 idiv	 ecx
  0012a	8b 4d a4	 mov	 ecx, DWORD PTR tv515[ebp]
  0012d	03 14 0e	 add	 edx, DWORD PTR [esi+ecx]
  00130	89 55 fc	 mov	 DWORD PTR _newvalue$[ebp], edx

; 1377 : 				% (var->PossibleValue[max].value - var->PossibleValue[MINVAL].value + 1);
; 1378 : 
; 1379 : 			CV_SetValue(var, newvalue);

  00133	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00136	50		 push	 eax
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _CV_SetValue
  00140	83 c4 08	 add	 esp, 8

; 1380 : #undef MINVAL
; 1381 : 		}

  00143	e9 45 04 00 00	 jmp	 $LN24@CV_AddValu
$LN23@CV_AddValu:

; 1382 : 		else
; 1383 : 		{
; 1384 : 			INT32 currentindice = -1, newindice;

  00148	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _currentindice$4[ebp], -1

; 1385 : 
; 1386 : 			// this code do not support more than same value for differant PossibleValue
; 1387 : 			for (max = 0; var->PossibleValue[max].strvalue; max++)

  0014f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _max$[ebp], 0
  00156	eb 09		 jmp	 SHORT $LN7@CV_AddValu
$LN5@CV_AddValu:
  00158	8b 45 f8	 mov	 eax, DWORD PTR _max$[ebp]
  0015b	83 c0 01	 add	 eax, 1
  0015e	89 45 f8	 mov	 DWORD PTR _max$[ebp], eax
$LN7@CV_AddValu:
  00161	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00164	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00167	8b 55 f8	 mov	 edx, DWORD PTR _max$[ebp]
  0016a	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  0016f	74 1c		 je	 SHORT $LN6@CV_AddValu

; 1388 : 				if (var->PossibleValue[max].value == var->value)

  00171	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00174	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00177	8b 55 f8	 mov	 edx, DWORD PTR _max$[ebp]
  0017a	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0017d	8b 0c d1	 mov	 ecx, DWORD PTR [ecx+edx*8]
  00180	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00183	75 06		 jne	 SHORT $LN26@CV_AddValu

; 1389 : 					currentindice = max;

  00185	8b 45 f8	 mov	 eax, DWORD PTR _max$[ebp]
  00188	89 45 f4	 mov	 DWORD PTR _currentindice$4[ebp], eax
$LN26@CV_AddValu:
  0018b	eb cb		 jmp	 SHORT $LN5@CV_AddValu
$LN6@CV_AddValu:

; 1390 : 
; 1391 : 			max--;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _max$[ebp]
  00190	83 e8 01	 sub	 eax, 1
  00193	89 45 f8	 mov	 DWORD PTR _max$[ebp], eax

; 1392 : 
; 1393 : 			if (var == &cv_nextmap)

  00196	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _var$[ebp], OFFSET _cv_nextmap
  0019d	0f 85 e1 02 00
	00		 jne	 $LN27@CV_AddValu

; 1394 : 			{
; 1395 : 				// Special case for the nextmap variable, used only directly from the menu
; 1396 : 				INT32 oldvalue = var->value - 1, gt;

  001a3	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001a6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a9	83 e9 01	 sub	 ecx, 1
  001ac	89 4d ec	 mov	 DWORD PTR _oldvalue$2[ebp], ecx

; 1397 : 				gt = cv_newgametype.value;

  001af	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_newgametype+20
  001b4	89 45 e8	 mov	 DWORD PTR _gt$1[ebp], eax

; 1398 : 				if (increment > 0) // Going up!

  001b7	83 7d 0c 00	 cmp	 DWORD PTR _increment$[ebp], 0
  001bb	0f 8e 5e 01 00
	00		 jle	 $LN29@CV_AddValu

; 1399 : 				{
; 1400 : 					newvalue = var->value - 1;

  001c1	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001c4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001c7	83 e9 01	 sub	 ecx, 1
  001ca	89 4d fc	 mov	 DWORD PTR _newvalue$[ebp], ecx
$LN68@CV_AddValu:

; 1401 : 					do
; 1402 : 					{
; 1403 : 						newvalue++;

  001cd	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  001d0	83 c0 01	 add	 eax, 1
  001d3	89 45 fc	 mov	 DWORD PTR _newvalue$[ebp], eax

; 1404 : 						if (newvalue == NUMMAPS)

  001d6	81 7d fc 0b 04
	00 00		 cmp	 DWORD PTR _newvalue$[ebp], 1035 ; 0000040bH
  001dd	75 07		 jne	 SHORT $LN31@CV_AddValu

; 1405 : 							newvalue = 0;

  001df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _newvalue$[ebp], 0
$LN31@CV_AddValu:

; 1406 : 						if (newvalue == oldvalue)

  001e6	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  001e9	3b 45 ec	 cmp	 eax, DWORD PTR _oldvalue$2[ebp]
  001ec	75 07		 jne	 SHORT $LN32@CV_AddValu

; 1407 : 							gt = -1; // don't loop forever if there's none of a certain gametype

  001ee	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _gt$1[ebp], -1
$LN32@CV_AddValu:

; 1408 : 					} while (var->PossibleValue[newvalue].strvalue == NULL
; 1409 : 						|| (((gt == GT_COOP && !(mapheaderinfo[newvalue].typeoflevel & TOL_COOP))
; 1410 : 							|| ((gt == GT_MATCH || gt == GTF_TEAMMATCH) && !(mapheaderinfo[newvalue].typeoflevel & TOL_MATCH))
; 1411 : 							|| ((gt == GT_RACE || gt == GTF_CLASSICRACE) && !(mapheaderinfo[newvalue].typeoflevel & TOL_RACE))
; 1412 : 							|| ((gt == GT_TAG || gt == GTF_HIDEANDSEEK) && !(mapheaderinfo[newvalue].typeoflevel & TOL_TAG))
; 1413 : #ifdef CHAOSISNOTDEADYET
; 1414 : 							|| (gt == GT_CHAOS && !(mapheaderinfo[newvalue].typeoflevel & TOL_CHAOS))
; 1415 : #endif
; 1416 : 							|| (gt == GT_CTF && !(mapheaderinfo[newvalue].typeoflevel & TOL_CTF))) && inlevelselect == 0)
; 1417 : 						|| (inlevelselect == 1 && !(mapheaderinfo[newvalue].levelselect))
; 1418 : 						|| (inlevelselect == 2 && !(mapheaderinfo[newvalue].timeattack && mapvisited[newvalue]))

  001f5	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001f8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001fb	8b 55 fc	 mov	 edx, DWORD PTR _newvalue$[ebp]
  001fe	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  00203	74 c8		 je	 SHORT $LN68@CV_AddValu
  00205	83 7d e8 00	 cmp	 DWORD PTR _gt$1[ebp], 0
  00209	75 13		 jne	 SHORT $LN35@CV_AddValu
  0020b	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00212	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  00219	83 e1 01	 and	 ecx, 1
  0021c	74 76		 je	 SHORT $LN34@CV_AddValu
$LN35@CV_AddValu:
  0021e	83 7d e8 01	 cmp	 DWORD PTR _gt$1[ebp], 1
  00222	74 06		 je	 SHORT $LN37@CV_AddValu
  00224	83 7d e8 2a	 cmp	 DWORD PTR _gt$1[ebp], 42 ; 0000002aH
  00228	75 13		 jne	 SHORT $LN36@CV_AddValu
$LN37@CV_AddValu:
  0022a	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00231	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  00238	83 e1 04	 and	 ecx, 4
  0023b	74 57		 je	 SHORT $LN34@CV_AddValu
$LN36@CV_AddValu:
  0023d	83 7d e8 02	 cmp	 DWORD PTR _gt$1[ebp], 2
  00241	74 06		 je	 SHORT $LN39@CV_AddValu
  00243	83 7d e8 2b	 cmp	 DWORD PTR _gt$1[ebp], 43 ; 0000002bH
  00247	75 13		 jne	 SHORT $LN38@CV_AddValu
$LN39@CV_AddValu:
  00249	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00250	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  00257	83 e1 02	 and	 ecx, 2
  0025a	74 38		 je	 SHORT $LN34@CV_AddValu
$LN38@CV_AddValu:
  0025c	83 7d e8 03	 cmp	 DWORD PTR _gt$1[ebp], 3
  00260	74 06		 je	 SHORT $LN41@CV_AddValu
  00262	83 7d e8 2c	 cmp	 DWORD PTR _gt$1[ebp], 44 ; 0000002cH
  00266	75 13		 jne	 SHORT $LN40@CV_AddValu
$LN41@CV_AddValu:
  00268	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  0026f	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  00276	83 e1 08	 and	 ecx, 8
  00279	74 19		 je	 SHORT $LN34@CV_AddValu
$LN40@CV_AddValu:
  0027b	83 7d e8 04	 cmp	 DWORD PTR _gt$1[ebp], 4
  0027f	75 20		 jne	 SHORT $LN33@CV_AddValu
  00281	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00288	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  0028f	83 e1 10	 and	 ecx, 16			; 00000010H
  00292	75 0d		 jne	 SHORT $LN33@CV_AddValu
$LN34@CV_AddValu:
  00294	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _inlevelselect, 0
  0029b	0f 84 2c ff ff
	ff		 je	 $LN68@CV_AddValu
$LN33@CV_AddValu:
  002a1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _inlevelselect, 1
  002a8	75 14		 jne	 SHORT $LN42@CV_AddValu
  002aa	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  002b1	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[eax+312], 0
  002b8	0f 84 0f ff ff
	ff		 je	 $LN68@CV_AddValu
$LN42@CV_AddValu:
  002be	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _inlevelselect, 2
  002c5	75 26		 jne	 SHORT $LN43@CV_AddValu
  002c7	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  002ce	83 b8 34 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[eax+308], 0
  002d5	0f 84 f2 fe ff
	ff		 je	 $LN68@CV_AddValu
  002db	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  002de	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _mapvisited[eax]
  002e5	85 c9		 test	 ecx, ecx
  002e7	0f 84 e0 fe ff
	ff		 je	 $LN68@CV_AddValu
$LN43@CV_AddValu:

; 1419 : 						);
; 1420 : 					var->value = newvalue + 1;

  002ed	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  002f0	83 c0 01	 add	 eax, 1
  002f3	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  002f6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1421 : 					var->string = var->PossibleValue[newvalue].strvalue;

  002f9	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  002fc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002ff	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00302	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00305	8b 4c c1 04	 mov	 ecx, DWORD PTR [ecx+eax*8+4]
  00309	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1422 : 					var->func();

  0030c	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0030f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00312	ff d1		 call	 ecx
  00314	90		 npad	 1

; 1423 : 					return;

  00315	e9 8c 02 00 00	 jmp	 $LN1@CV_AddValu

; 1424 : 				}

  0031a	e9 60 01 00 00	 jmp	 $LN44@CV_AddValu
$LN29@CV_AddValu:

; 1425 : 				else if (increment < 0) // Going down!

  0031f	83 7d 0c 00	 cmp	 DWORD PTR _increment$[ebp], 0
  00323	0f 8d 56 01 00
	00		 jge	 $LN44@CV_AddValu

; 1426 : 				{
; 1427 : 					newvalue = var->value - 1;

  00329	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0032c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0032f	83 e9 01	 sub	 ecx, 1
  00332	89 4d fc	 mov	 DWORD PTR _newvalue$[ebp], ecx
$LN72@CV_AddValu:

; 1428 : 					do
; 1429 : 					{
; 1430 : 						newvalue--;

  00335	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00338	83 e8 01	 sub	 eax, 1
  0033b	89 45 fc	 mov	 DWORD PTR _newvalue$[ebp], eax

; 1431 : 						if (newvalue == -1)

  0033e	83 7d fc ff	 cmp	 DWORD PTR _newvalue$[ebp], -1
  00342	75 07		 jne	 SHORT $LN45@CV_AddValu

; 1432 : 							newvalue = NUMMAPS-1;

  00344	c7 45 fc 0a 04
	00 00		 mov	 DWORD PTR _newvalue$[ebp], 1034 ; 0000040aH
$LN45@CV_AddValu:

; 1433 : 						if (newvalue == oldvalue)

  0034b	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  0034e	3b 45 ec	 cmp	 eax, DWORD PTR _oldvalue$2[ebp]
  00351	75 07		 jne	 SHORT $LN46@CV_AddValu

; 1434 : 							gt = -1; // don't loop forever if there's none of a certain gametype

  00353	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _gt$1[ebp], -1
$LN46@CV_AddValu:

; 1435 : 					} while (var->PossibleValue[newvalue].strvalue == NULL
; 1436 : 						|| (((gt == GT_COOP && !(mapheaderinfo[newvalue].typeoflevel & TOL_COOP))
; 1437 : 						|| ((gt == GT_MATCH || gt == GTF_TEAMMATCH) && !(mapheaderinfo[newvalue].typeoflevel & TOL_MATCH))
; 1438 : 						|| ((gt == GT_RACE || gt == GTF_CLASSICRACE) && !(mapheaderinfo[newvalue].typeoflevel & TOL_RACE))
; 1439 : 						|| ((gt == GT_TAG || gt == GTF_HIDEANDSEEK) && !(mapheaderinfo[newvalue].typeoflevel & TOL_TAG))
; 1440 : #ifdef CHAOSISNOTDEADYET
; 1441 : 						|| (gt == GT_CHAOS && !(mapheaderinfo[newvalue].typeoflevel & TOL_CHAOS))
; 1442 : #endif
; 1443 : 						|| (gt == GT_CTF && !(mapheaderinfo[newvalue].typeoflevel & TOL_CTF))) && inlevelselect == 0)
; 1444 : 						|| (inlevelselect == 1 && !(mapheaderinfo[newvalue].levelselect))
; 1445 : 						|| (inlevelselect == 2 && !(mapheaderinfo[newvalue].timeattack && mapvisited[newvalue]))

  0035a	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0035d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00360	8b 55 fc	 mov	 edx, DWORD PTR _newvalue$[ebp]
  00363	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  00368	74 cb		 je	 SHORT $LN72@CV_AddValu
  0036a	83 7d e8 00	 cmp	 DWORD PTR _gt$1[ebp], 0
  0036e	75 13		 jne	 SHORT $LN49@CV_AddValu
  00370	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00377	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  0037e	83 e1 01	 and	 ecx, 1
  00381	74 76		 je	 SHORT $LN48@CV_AddValu
$LN49@CV_AddValu:
  00383	83 7d e8 01	 cmp	 DWORD PTR _gt$1[ebp], 1
  00387	74 06		 je	 SHORT $LN51@CV_AddValu
  00389	83 7d e8 2a	 cmp	 DWORD PTR _gt$1[ebp], 42 ; 0000002aH
  0038d	75 13		 jne	 SHORT $LN50@CV_AddValu
$LN51@CV_AddValu:
  0038f	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00396	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  0039d	83 e1 04	 and	 ecx, 4
  003a0	74 57		 je	 SHORT $LN48@CV_AddValu
$LN50@CV_AddValu:
  003a2	83 7d e8 02	 cmp	 DWORD PTR _gt$1[ebp], 2
  003a6	74 06		 je	 SHORT $LN53@CV_AddValu
  003a8	83 7d e8 2b	 cmp	 DWORD PTR _gt$1[ebp], 43 ; 0000002bH
  003ac	75 13		 jne	 SHORT $LN52@CV_AddValu
$LN53@CV_AddValu:
  003ae	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  003b5	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  003bc	83 e1 02	 and	 ecx, 2
  003bf	74 38		 je	 SHORT $LN48@CV_AddValu
$LN52@CV_AddValu:
  003c1	83 7d e8 03	 cmp	 DWORD PTR _gt$1[ebp], 3
  003c5	74 06		 je	 SHORT $LN55@CV_AddValu
  003c7	83 7d e8 2c	 cmp	 DWORD PTR _gt$1[ebp], 44 ; 0000002cH
  003cb	75 13		 jne	 SHORT $LN54@CV_AddValu
$LN55@CV_AddValu:
  003cd	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  003d4	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  003db	83 e1 08	 and	 ecx, 8
  003de	74 19		 je	 SHORT $LN48@CV_AddValu
$LN54@CV_AddValu:
  003e0	83 7d e8 04	 cmp	 DWORD PTR _gt$1[ebp], 4
  003e4	75 20		 jne	 SHORT $LN47@CV_AddValu
  003e6	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  003ed	0f bf 88 44 00
	00 00		 movsx	 ecx, WORD PTR _mapheaderinfo[eax+68]
  003f4	83 e1 10	 and	 ecx, 16			; 00000010H
  003f7	75 0d		 jne	 SHORT $LN47@CV_AddValu
$LN48@CV_AddValu:
  003f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _inlevelselect, 0
  00400	0f 84 2f ff ff
	ff		 je	 $LN72@CV_AddValu
$LN47@CV_AddValu:
  00406	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _inlevelselect, 1
  0040d	75 14		 jne	 SHORT $LN56@CV_AddValu
  0040f	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00416	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[eax+312], 0
  0041d	0f 84 12 ff ff
	ff		 je	 $LN72@CV_AddValu
$LN56@CV_AddValu:
  00423	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _inlevelselect, 2
  0042a	75 26		 jne	 SHORT $LN57@CV_AddValu
  0042c	69 45 fc 84 01
	00 00		 imul	 eax, DWORD PTR _newvalue$[ebp], 388
  00433	83 b8 34 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[eax+308], 0
  0043a	0f 84 f5 fe ff
	ff		 je	 $LN72@CV_AddValu
  00440	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00443	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _mapvisited[eax]
  0044a	85 c9		 test	 ecx, ecx
  0044c	0f 84 e3 fe ff
	ff		 je	 $LN72@CV_AddValu
$LN57@CV_AddValu:

; 1446 : 						);
; 1447 : 					var->value = newvalue + 1;

  00452	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00455	83 c0 01	 add	 eax, 1
  00458	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0045b	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1448 : 					var->string = var->PossibleValue[newvalue].strvalue;

  0045e	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00461	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00464	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00467	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  0046a	8b 4c c1 04	 mov	 ecx, DWORD PTR [ecx+eax*8+4]
  0046e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1449 : 					var->func();

  00471	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00474	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00477	ff d1		 call	 ecx
  00479	90		 npad	 1

; 1450 : 					return;

  0047a	e9 27 01 00 00	 jmp	 $LN1@CV_AddValu
$LN44@CV_AddValu:

; 1451 : 				}
; 1452 : 			}

  0047f	e9 d6 00 00 00	 jmp	 $LN62@CV_AddValu
$LN27@CV_AddValu:

; 1453 : 			else if (var == &cv_chooseskin)

  00484	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _var$[ebp], OFFSET _cv_chooseskin
  0048b	0f 85 c9 00 00
	00		 jne	 $LN62@CV_AddValu

; 1454 : 			{
; 1455 : 				// Special case for the chooseskin variable, used only directly from the menu
; 1456 : 				if (increment > 0) // Going up!

  00491	83 7d 0c 00	 cmp	 DWORD PTR _increment$[ebp], 0
  00495	7e 61		 jle	 SHORT $LN59@CV_AddValu

; 1457 : 				{
; 1458 : 					newvalue = var->value - 1;

  00497	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0049a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0049d	83 e9 01	 sub	 ecx, 1
  004a0	89 4d fc	 mov	 DWORD PTR _newvalue$[ebp], ecx
$LN16@CV_AddValu:

; 1459 : 					do
; 1460 : 					{
; 1461 : 						newvalue++;

  004a3	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  004a6	83 c0 01	 add	 eax, 1
  004a9	89 45 fc	 mov	 DWORD PTR _newvalue$[ebp], eax

; 1462 : 						if (newvalue == MAXSKINS)

  004ac	83 7d fc 20	 cmp	 DWORD PTR _newvalue$[ebp], 32 ; 00000020H
  004b0	75 07		 jne	 SHORT $LN61@CV_AddValu

; 1463 : 							newvalue = 0;

  004b2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _newvalue$[ebp], 0
$LN61@CV_AddValu:

; 1464 : 					} while (var->PossibleValue[newvalue].strvalue == NULL);

  004b9	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  004bc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  004bf	8b 55 fc	 mov	 edx, DWORD PTR _newvalue$[ebp]
  004c2	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  004c7	74 da		 je	 SHORT $LN16@CV_AddValu

; 1465 : 					var->value = newvalue + 1;

  004c9	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  004cc	83 c0 01	 add	 eax, 1
  004cf	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  004d2	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1466 : 					var->string = var->PossibleValue[newvalue].strvalue;

  004d5	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  004d8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  004db	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  004de	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  004e1	8b 4c c1 04	 mov	 ecx, DWORD PTR [ecx+eax*8+4]
  004e5	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1467 : 					var->func();

  004e8	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  004eb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  004ee	ff d1		 call	 ecx
  004f0	90		 npad	 1

; 1468 : 					return;

  004f1	e9 b0 00 00 00	 jmp	 $LN1@CV_AddValu

; 1469 : 				}

  004f6	eb 62		 jmp	 SHORT $LN62@CV_AddValu
$LN59@CV_AddValu:

; 1470 : 				else if (increment < 0) // Going down!

  004f8	83 7d 0c 00	 cmp	 DWORD PTR _increment$[ebp], 0
  004fc	7d 5c		 jge	 SHORT $LN62@CV_AddValu

; 1471 : 				{
; 1472 : 					newvalue = var->value - 1;

  004fe	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00501	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00504	83 e9 01	 sub	 ecx, 1
  00507	89 4d fc	 mov	 DWORD PTR _newvalue$[ebp], ecx
$LN19@CV_AddValu:

; 1473 : 					do
; 1474 : 					{
; 1475 : 						newvalue--;

  0050a	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  0050d	83 e8 01	 sub	 eax, 1
  00510	89 45 fc	 mov	 DWORD PTR _newvalue$[ebp], eax

; 1476 : 						if (newvalue == -1)

  00513	83 7d fc ff	 cmp	 DWORD PTR _newvalue$[ebp], -1
  00517	75 07		 jne	 SHORT $LN63@CV_AddValu

; 1477 : 							newvalue = MAXSKINS-1;

  00519	c7 45 fc 1f 00
	00 00		 mov	 DWORD PTR _newvalue$[ebp], 31 ; 0000001fH
$LN63@CV_AddValu:

; 1478 : 					} while (var->PossibleValue[newvalue].strvalue == NULL);

  00520	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00523	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00526	8b 55 fc	 mov	 edx, DWORD PTR _newvalue$[ebp]
  00529	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  0052e	74 da		 je	 SHORT $LN19@CV_AddValu

; 1479 : 					var->value = newvalue + 1;

  00530	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00533	83 c0 01	 add	 eax, 1
  00536	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00539	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1480 : 					var->string = var->PossibleValue[newvalue].strvalue;

  0053c	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0053f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00542	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00545	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00548	8b 4c c1 04	 mov	 ecx, DWORD PTR [ecx+eax*8+4]
  0054c	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1481 : 					var->func();

  0054f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00552	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00555	ff d1		 call	 ecx
  00557	90		 npad	 1

; 1482 : 					return;

  00558	eb 4c		 jmp	 SHORT $LN1@CV_AddValu
$LN62@CV_AddValu:

; 1483 : 				}
; 1484 : 			}
; 1485 : #ifdef PARANOIA
; 1486 : 			if (currentindice == -1)
; 1487 : 				I_Error("CV_AddValue: current value %d not found in possible value\n",
; 1488 : 					var->value);
; 1489 : #endif
; 1490 : 
; 1491 : 			newindice = (currentindice + increment + max + 1) % (max+1);

  0055a	8b 45 f4	 mov	 eax, DWORD PTR _currentindice$4[ebp]
  0055d	03 45 0c	 add	 eax, DWORD PTR _increment$[ebp]
  00560	8b 4d f8	 mov	 ecx, DWORD PTR _max$[ebp]
  00563	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]
  00567	8b 4d f8	 mov	 ecx, DWORD PTR _max$[ebp]
  0056a	83 c1 01	 add	 ecx, 1
  0056d	99		 cdq
  0056e	f7 f9		 idiv	 ecx
  00570	89 55 f0	 mov	 DWORD PTR _newindice$3[ebp], edx

; 1492 : 			CV_Set(var, var->PossibleValue[newindice].strvalue);

  00573	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00576	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00579	8b 55 f0	 mov	 edx, DWORD PTR _newindice$3[ebp]
  0057c	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  00580	50		 push	 eax
  00581	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00584	51		 push	 ecx
  00585	e8 00 00 00 00	 call	 _CV_Set
  0058a	83 c4 08	 add	 esp, 8
$LN24@CV_AddValu:

; 1493 : 		}
; 1494 : 	}

  0058d	eb 10		 jmp	 SHORT $LN22@CV_AddValu
$LN21@CV_AddValu:

; 1495 : 	else
; 1496 : 		CV_SetValue(var, newvalue);

  0058f	8b 45 fc	 mov	 eax, DWORD PTR _newvalue$[ebp]
  00592	50		 push	 eax
  00593	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00596	51		 push	 ecx
  00597	e8 00 00 00 00	 call	 _CV_SetValue
  0059c	83 c4 08	 add	 esp, 8
$LN22@CV_AddValu:

; 1497 : 
; 1498 : 	var->changed = 1; // user has changed it now

  0059f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  005a2	c6 40 22 01	 mov	 BYTE PTR [eax+34], 1
$LN1@CV_AddValu:

; 1499 : }

  005a6	5f		 pop	 edi
  005a7	5e		 pop	 esi
  005a8	5b		 pop	 ebx
  005a9	8b e5		 mov	 esp, ebp
  005ab	5d		 pop	 ebp
  005ac	c3		 ret	 0
_CV_AddValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_StealthSet
_TEXT	SEGMENT
_var$ = 8						; size = 4
_value$ = 12						; size = 4
_CV_StealthSet PROC					; COMDAT

; 1301 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1302 : 	CV_SetCVar(var, value, true);

  00009	6a 01		 push	 1
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _CV_SetCVar
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1303 : }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_CV_StealthSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_StealthSetValue
_TEXT	SEGMENT
_val$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_var$ = 8						; size = 4
_value$ = 12						; size = 4
_CV_StealthSetValue PROC				; COMDAT

; 1313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1314 : 	char val[32];
; 1315 : 
; 1316 : 	sprintf(val, "%d", value);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0001c	8d 4d dc	 lea	 ecx, DWORD PTR _val$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _sprintf
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1317 : 	CV_SetCVar(var, val, true);

  00028	6a 01		 push	 1
  0002a	8d 45 dc	 lea	 eax, DWORD PTR _val$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _CV_SetCVar
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1318 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_CV_StealthSetValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_SetValue
_TEXT	SEGMENT
_val$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_var$ = 8						; size = 4
_value$ = 12						; size = 4
_CV_SetValue PROC					; COMDAT

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1335 : 	char val[32];
; 1336 : 
; 1337 : 	sprintf(val, "%d", value);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0001c	8d 4d dc	 lea	 ecx, DWORD PTR _val$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _sprintf
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1338 : 	CV_SetCVar(var, val, false);

  00028	6a 00		 push	 0
  0002a	8d 45 dc	 lea	 eax, DWORD PTR _val$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _CV_SetCVar
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1339 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_CV_SetValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_Set
_TEXT	SEGMENT
_var$ = 8						; size = 4
_value$ = 12						; size = 4
_CV_Set	PROC						; COMDAT

; 1322 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1323 : 	CV_SetCVar(var, value, false);

  00009	6a 00		 push	 0
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _CV_SetCVar
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1324 : }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_CV_Set	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_CompleteVar
_TEXT	SEGMENT
tv77 = -76						; size = 4
_len$ = -8						; size = 4
_cvar$ = -4						; size = 4
_partial$ = 8						; size = 4
_skips$ = 12						; size = 4
_CV_CompleteVar PROC					; COMDAT

; 987  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 988  : 	consvar_t *cvar;
; 989  : 	size_t len;
; 990  : 
; 991  : 	len = strlen(partial);

  00009	8b 45 08	 mov	 eax, DWORD PTR _partial$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 992  : 
; 993  : 	if (!len)

  00018	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0001c	75 04		 jne	 SHORT $LN5@CV_Complet

; 994  : 		return NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 53		 jmp	 SHORT $LN1@CV_Complet
$LN5@CV_Complet:

; 995  : 
; 996  : 	// check variables
; 997  : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  00027	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  0002a	eb 09		 jmp	 SHORT $LN4@CV_Complet
$LN2@CV_Complet:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0002f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00032	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_Complet:
  00035	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00039	74 38		 je	 SHORT $LN3@CV_Complet

; 998  : 		if (!strncmp(partial, cvar->name, len))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _cvar$[ebp]
  00042	8b 11		 mov	 edx, DWORD PTR [ecx]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _partial$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strncmp
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN7@CV_Complet

; 999  : 			if (!skips--)

  00055	8b 45 0c	 mov	 eax, DWORD PTR _skips$[ebp]
  00058	89 45 b4	 mov	 DWORD PTR tv77[ebp], eax
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _skips$[ebp]
  0005e	83 e9 01	 sub	 ecx, 1
  00061	89 4d 0c	 mov	 DWORD PTR _skips$[ebp], ecx
  00064	83 7d b4 00	 cmp	 DWORD PTR tv77[ebp], 0
  00068	75 07		 jne	 SHORT $LN7@CV_Complet

; 1000 : 				return cvar->name;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	eb 04		 jmp	 SHORT $LN1@CV_Complet
$LN7@CV_Complet:
  00071	eb b9		 jmp	 SHORT $LN2@CV_Complet
$LN3@CV_Complet:

; 1001 : 
; 1002 : 	return NULL;

  00073	33 c0		 xor	 eax, eax
$LN1@CV_Complet:

; 1003 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_CV_CompleteVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_ClearChangedFlags
_TEXT	SEGMENT
_cvar$ = -4						; size = 4
_CV_ClearChangedFlags PROC				; COMDAT

; 1537 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1538 : 	consvar_t *cvar;
; 1539 : 
; 1540 : 	for (cvar = consvar_vars; cvar; cvar = cvar->next)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _consvar_vars
  0000e	89 45 fc	 mov	 DWORD PTR _cvar$[ebp], eax
  00011	eb 09		 jmp	 SHORT $LN4@CV_ClearCh
$LN2@CV_ClearCh:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00016	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00019	89 4d fc	 mov	 DWORD PTR _cvar$[ebp], ecx
$LN4@CV_ClearCh:
  0001c	83 7d fc 00	 cmp	 DWORD PTR _cvar$[ebp], 0
  00020	74 09		 je	 SHORT $LN3@CV_ClearCh

; 1541 : 		cvar->changed = 0;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _cvar$[ebp]
  00025	c6 40 22 00	 mov	 BYTE PTR [eax+34], 0
  00029	eb e8		 jmp	 SHORT $LN2@CV_ClearCh
$LN3@CV_ClearCh:

; 1542 : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_CV_ClearChangedFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _CV_RegisterVar
_TEXT	SEGMENT
_variable$ = 8						; size = 4
_CV_RegisterVar PROC					; COMDAT

; 911  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 912  : 	// first check to see if it has already been defined
; 913  : 	if (CV_FindVar(variable->name))

  00009	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _CV_FindVar
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 18		 je	 SHORT $LN2@CV_Registe

; 914  : 	{
; 915  : 		CONS_Printf("Variable %s is already defined\n", variable->name);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	51		 push	 ecx
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OJFCHIOJ@Variable?5?$CFs?5is?5already?5defined?6@
  00026	e8 00 00 00 00	 call	 _CONS_Printf
  0002b	83 c4 08	 add	 esp, 8

; 916  : 		return;

  0002e	e9 06 01 00 00	 jmp	 $LN1@CV_Registe
$LN2@CV_Registe:

; 917  : 	}
; 918  : 
; 919  : 	// check for overlap with a command
; 920  : 	if (COM_Exists(variable->name))

  00033	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _COM_Exists
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	74 18		 je	 SHORT $LN3@CV_Registe

; 921  : 	{
; 922  : 		CONS_Printf("%s is a command name\n", variable->name);

  00045	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	51		 push	 ecx
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FEIIJCCF@?$CFs?5is?5a?5command?5name?6@
  00050	e8 00 00 00 00	 call	 _CONS_Printf
  00055	83 c4 08	 add	 esp, 8

; 923  : 		return;

  00058	e9 dc 00 00 00	 jmp	 $LN1@CV_Registe
$LN3@CV_Registe:

; 924  : 	}
; 925  : 
; 926  : 	// check net variables
; 927  : 	if (variable->flags & CV_NETVAR)

  0005d	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00060	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00063	83 e1 04	 and	 ecx, 4
  00066	74 3c		 je	 SHORT $LN5@CV_Registe

; 928  : 	{
; 929  : 		variable->netid = CV_ComputeNetid(variable->name);

  00068	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _CV_ComputeNetid
  00073	83 c4 04	 add	 esp, 4
  00076	8b 55 08	 mov	 edx, DWORD PTR _variable$[ebp]
  00079	66 89 42 20	 mov	 WORD PTR [edx+32], ax

; 930  : 		if (CV_FindNetVar(variable->netid))

  0007d	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00080	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _CV_FindNetVar
  0008a	83 c4 04	 add	 esp, 4
  0008d	85 c0		 test	 eax, eax
  0008f	74 13		 je	 SHORT $LN5@CV_Registe

; 931  : 			I_Error("Variable %s have same netid\n", variable->name);

  00091	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	51		 push	 ecx
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MCACDFKG@Variable?5?$CFs?5have?5same?5netid?6@
  0009c	e8 00 00 00 00	 call	 _I_Error
  000a1	83 c4 08	 add	 esp, 8
$LN5@CV_Registe:

; 932  : 	}
; 933  : 
; 934  : 	// link the variable in
; 935  : 	if (!(variable->flags & CV_HIDEN))

  000a4	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000a7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000aa	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  000b0	75 14		 jne	 SHORT $LN6@CV_Registe

; 936  : 	{
; 937  : 		variable->next = consvar_vars;

  000b2	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _consvar_vars
  000bb	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 938  : 		consvar_vars = variable;

  000be	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000c1	a3 00 00 00 00	 mov	 DWORD PTR _consvar_vars, eax
$LN6@CV_Registe:

; 939  : 	}
; 940  : 	variable->string = variable->zstring = NULL;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000c9	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _variable$[ebp]
  000d3	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 941  : 	variable->changed = 0; // new variable has not been modified by the user

  000da	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000dd	c6 40 22 00	 mov	 BYTE PTR [eax+34], 0

; 942  : 
; 943  : #ifdef PARANOIA
; 944  : 	if ((variable->flags & CV_NOINIT) && !(variable->flags & CV_CALL))
; 945  : 		I_Error("variable %s has CV_NOINIT without CV_CALL",
; 946  : 			variable->name);
; 947  : 	if ((variable->flags & CV_CALL) && !variable->func)
; 948  : 		I_Error("variable %s has CV_CALL without a function",
; 949  : 			variable->name);
; 950  : #endif
; 951  : 
; 952  : 	if (variable->flags & CV_NOINIT)

  000e1	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000e4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e7	83 e1 08	 and	 ecx, 8
  000ea	74 0f		 je	 SHORT $LN7@CV_Registe

; 953  : 		variable->flags &= ~CV_CALL;

  000ec	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  000ef	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f2	83 e1 fd	 and	 ecx, -3			; fffffffdH
  000f5	8b 55 08	 mov	 edx, DWORD PTR _variable$[ebp]
  000f8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN7@CV_Registe:

; 954  : 
; 955  : 	Setvalue(variable, variable->defaultvalue, false);

  000fb	6a 00		 push	 0
  000fd	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00100	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00103	51		 push	 ecx
  00104	8b 55 08	 mov	 edx, DWORD PTR _variable$[ebp]
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _Setvalue
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 956  : 
; 957  : 	if (variable->flags & CV_NOINIT)

  00110	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  00113	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00116	83 e1 08	 and	 ecx, 8
  00119	74 0f		 je	 SHORT $LN8@CV_Registe

; 958  : 		variable->flags |= CV_CALL;

  0011b	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  0011e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00121	83 c9 02	 or	 ecx, 2
  00124	8b 55 08	 mov	 edx, DWORD PTR _variable$[ebp]
  00127	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN8@CV_Registe:

; 959  : 
; 960  : 	// the SetValue will set this bit
; 961  : 	variable->flags &= ~CV_MODIFIED;

  0012a	8b 45 08	 mov	 eax, DWORD PTR _variable$[ebp]
  0012d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00130	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  00133	8b 55 08	 mov	 edx, DWORD PTR _variable$[ebp]
  00136	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@CV_Registe:

; 962  : }

  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
_CV_RegisterVar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _VS_Print
_TEXT	SEGMENT
_len$ = -4						; size = 4
_buf$ = 8						; size = 4
_data$ = 12						; size = 4
_VS_Print PROC						; COMDAT

; 824  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 825  : 	size_t len;
; 826  : 
; 827  : 	len = strlen(data) + 1;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 828  : 
; 829  : 	if (buf->data[buf->cursize-1])

  0001b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0001e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00021	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	0f b6 4c 08 ff	 movzx	 ecx, BYTE PTR [eax+ecx-1]
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 24		 je	 SHORT $LN2@VS_Print

; 830  : 		M_Memcpy((UINT8 *)VS_GetSpace(buf, len), data, len); // no trailing 0

  00030	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _VS_GetSpace
  00045	83 c4 08	 add	 esp, 8
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	eb 28		 jmp	 SHORT $LN3@VS_Print
$LN2@VS_Print:

; 831  : 	else
; 832  : 		M_Memcpy((UINT8 *)VS_GetSpace(buf, len-1) - 1, data, len); // write over trailing 0

  00054	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  0005f	83 ea 01	 sub	 edx, 1
  00062	52		 push	 edx
  00063	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _VS_GetSpace
  0006c	83 c4 08	 add	 esp, 8
  0006f	83 e8 01	 sub	 eax, 1
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@VS_Print:

; 833  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_VS_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _VS_Write
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_data$ = 12						; size = 4
_length$ = 16						; size = 4
_VS_Write PROC						; COMDAT

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 813  : 	M_Memcpy(VS_GetSpace(buf, length), data, length);

  00009	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _VS_GetSpace
  0001e	83 c4 08	 add	 esp, 8
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 814  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_VS_Write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _VS_GetSpace
_TEXT	SEGMENT
_data$ = -4						; size = 4
_buf$ = 8						; size = 4
_length$ = 12						; size = 4
_VS_GetSpace PROC					; COMDAT

; 782  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 783  : 	void *data;
; 784  : 
; 785  : 	if (buf->cursize + length > buf->maxsize)

  00009	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	03 4d 0c	 add	 ecx, DWORD PTR _length$[ebp]
  00012	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00015	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00018	76 54		 jbe	 SHORT $LN2@VS_GetSpac

; 786  : 	{
; 787  : 		if (!buf->allowoverflow)

  0001a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	75 0d		 jne	 SHORT $LN3@VS_GetSpac

; 788  : 			I_Error("overflow 111");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GIAGIJKH@overflow?5111@
  00027	e8 00 00 00 00	 call	 _I_Error
  0002c	83 c4 04	 add	 esp, 4
$LN3@VS_GetSpac:

; 789  : 
; 790  : 		if (length > buf->maxsize)

  0002f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  00035	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00038	76 11		 jbe	 SHORT $LN4@VS_GetSpac

; 791  : 			I_Error("overflow l%"PRIdS" 112", length);

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EFPENHPC@overflow?5l?$CFIu?5112@
  00043	e8 00 00 00 00	 call	 _I_Error
  00048	83 c4 08	 add	 esp, 8
$LN4@VS_GetSpac:

; 792  : 
; 793  : 		buf->overflowed = true;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0004e	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 794  : 		CONS_Printf("VS buffer overflow");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IMENGHPE@VS?5buffer?5overflow@
  0005a	e8 00 00 00 00	 call	 _CONS_Printf
  0005f	83 c4 04	 add	 esp, 4

; 795  : 		VS_Clear(buf);

  00062	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _VS_Clear
  0006b	83 c4 04	 add	 esp, 4
$LN2@VS_GetSpac:

; 796  : 	}
; 797  : 
; 798  : 	data = buf->data + buf->cursize;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00071	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00074	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00077	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  0007a	89 4d fc	 mov	 DWORD PTR _data$[ebp], ecx

; 799  : 	buf->cursize += length;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00080	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00083	03 4d 0c	 add	 ecx, DWORD PTR _length$[ebp]
  00086	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00089	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 800  : 
; 801  : 	return data;

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]

; 802  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_VS_GetSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _VS_Clear
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_VS_Clear PROC						; COMDAT

; 770  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 771  : 	buf->cursize = 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 772  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_VS_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _VS_Free
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_VS_Free PROC						; COMDAT

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 762  : 	buf->cursize = 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 763  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_VS_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _VS_Alloc
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_initsize$ = 12						; size = 4
_VS_Alloc PROC						; COMDAT

; 746  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 747  : #define VSBUFMINSIZE 256
; 748  : 	if (initsize < VSBUFMINSIZE)

  00009	81 7d 0c 00 01
	00 00		 cmp	 DWORD PTR _initsize$[ebp], 256 ; 00000100H
  00010	73 07		 jae	 SHORT $LN2@VS_Alloc

; 749  : 		initsize = VSBUFMINSIZE;

  00012	c7 45 0c 00 01
	00 00		 mov	 DWORD PTR _initsize$[ebp], 256 ; 00000100H
$LN2@VS_Alloc:

; 750  : 	buf->data = Z_Malloc(initsize, PU_STATIC, NULL);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 01		 push	 1
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _initsize$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _Z_MallocAlign
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0002e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 751  : 	buf->maxsize = initsize;

  00031	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _initsize$[ebp]
  00037	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 752  : 	buf->cursize = 0;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0003d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 753  : #undef VSBUFMINSIZE
; 754  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_VS_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Init
_TEXT	SEGMENT
_COM_Init PROC						; COMDAT

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 261  : 	// allocate command buffer
; 262  : 	VS_Alloc(&com_text, COM_BUF_SIZE);

  00009	68 00 20 00 00	 push	 8192			; 00002000H
  0000e	68 00 00 00 00	 push	 OFFSET _com_text
  00013	e8 00 00 00 00	 call	 _VS_Alloc
  00018	83 c4 08	 add	 esp, 8

; 263  : 
; 264  : 	// add standard commands
; 265  : 	COM_AddCommand("alias", COM_Alias_f);

  0001b	68 00 00 00 00	 push	 OFFSET _COM_Alias_f
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_05NKHOCLEE@alias@
  00025	e8 00 00 00 00	 call	 _COM_AddCommand
  0002a	83 c4 08	 add	 esp, 8

; 266  : 	COM_AddCommand("echo", COM_Echo_f);

  0002d	68 00 00 00 00	 push	 OFFSET _COM_Echo_f
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_04OFDNEFMC@echo@
  00037	e8 00 00 00 00	 call	 _COM_AddCommand
  0003c	83 c4 08	 add	 esp, 8

; 267  : 	COM_AddCommand("cecho", COM_CEcho_f);

  0003f	68 00 00 00 00	 push	 OFFSET _COM_CEcho_f
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_05BMLNGOII@cecho@
  00049	e8 00 00 00 00	 call	 _COM_AddCommand
  0004e	83 c4 08	 add	 esp, 8

; 268  : 	COM_AddCommand("cechoflags", COM_CEchoFlags_f);

  00051	68 00 00 00 00	 push	 OFFSET _COM_CEchoFlags_f
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DJOBFKIA@cechoflags@
  0005b	e8 00 00 00 00	 call	 _COM_AddCommand
  00060	83 c4 08	 add	 esp, 8

; 269  : 	COM_AddCommand("cechoduration", COM_CEchoDuration_f);

  00063	68 00 00 00 00	 push	 OFFSET _COM_CEchoDuration_f
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PHPKLFOM@cechoduration@
  0006d	e8 00 00 00 00	 call	 _COM_AddCommand
  00072	83 c4 08	 add	 esp, 8

; 270  : 	COM_AddCommand("exec", COM_Exec_f);

  00075	68 00 00 00 00	 push	 OFFSET _COM_Exec_f
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_04MGEIEJAD@exec@
  0007f	e8 00 00 00 00	 call	 _COM_AddCommand
  00084	83 c4 08	 add	 esp, 8

; 271  : 	COM_AddCommand("wait", COM_Wait_f);

  00087	68 00 00 00 00	 push	 OFFSET _COM_Wait_f
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_04PNOAOIAG@wait@
  00091	e8 00 00 00 00	 call	 _COM_AddCommand
  00096	83 c4 08	 add	 esp, 8

; 272  : 	COM_AddCommand("help", COM_Help_f);

  00099	68 00 00 00 00	 push	 OFFSET _COM_Help_f
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_04PCJFHION@help@
  000a3	e8 00 00 00 00	 call	 _COM_AddCommand
  000a8	83 c4 08	 add	 esp, 8

; 273  : 	COM_AddCommand("toggle", COM_Toggle_f);

  000ab	68 00 00 00 00	 push	 OFFSET _COM_Toggle_f
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_06FHLCKAHH@toggle@
  000b5	e8 00 00 00 00	 call	 _COM_AddCommand
  000ba	83 c4 08	 add	 esp, 8

; 274  : 	RegisterNetXCmd(XD_NETVAR, Got_NetVar);

  000bd	68 00 00 00 00	 push	 OFFSET _Got_NetVar
  000c2	6a 04		 push	 4
  000c4	e8 00 00 00 00	 call	 _RegisterNetXCmd
  000c9	83 c4 08	 add	 esp, 8

; 275  : }

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
_COM_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_BufExecute
_TEXT	SEGMENT
$T1 = -1236						; size = 4
_quotes$ = -1040					; size = 4
_line$ = -1036						; size = 1024
_ptext$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_COM_BufExecute PROC					; COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 143  : 	size_t i;
; 144  : 	char *ptext;
; 145  : 	char line[1024] = "";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 f4 fb ff
	ff		 mov	 BYTE PTR _line$[ebp], al
  00021	68 ff 03 00 00	 push	 1023			; 000003ffH
  00026	6a 00		 push	 0
  00028	8d 85 f5 fb ff
	ff		 lea	 eax, DWORD PTR _line$[ebp+1]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 146  : 	INT32 quotes;
; 147  : 
; 148  : 	if (com_wait)

  00037	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _com_wait, 0
  0003e	74 12		 je	 SHORT $LN7@COM_BufExe

; 149  : 	{
; 150  : 		com_wait--;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_wait
  00045	83 e8 01	 sub	 eax, 1
  00048	a3 00 00 00 00	 mov	 DWORD PTR _com_wait, eax

; 151  : 		return;

  0004d	e9 7e 01 00 00	 jmp	 $LN3@COM_BufExe
$LN7@COM_BufExe:

; 152  : 	}
; 153  : 
; 154  : 	while (com_text.cursize)

  00052	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _com_text+16, 0
  00059	0f 84 71 01 00
	00		 je	 $LN3@COM_BufExe

; 155  : 	{
; 156  : 		// find a '\n' or; line break
; 157  : 		ptext = (char *)com_text.data;

  0005f	a1 08 00 00 00	 mov	 eax, DWORD PTR _com_text+8
  00064	89 45 f4	 mov	 DWORD PTR _ptext$[ebp], eax

; 158  : 
; 159  : 		quotes = 0;

  00067	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _quotes$[ebp], 0

; 160  : 		for (i = 0; i < com_text.cursize; i++)

  00071	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 09		 jmp	 SHORT $LN6@COM_BufExe
$LN4@COM_BufExe:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@COM_BufExe:
  00083	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00086	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _com_text+16
  0008c	0f 83 89 00 00
	00		 jae	 $LN5@COM_BufExe

; 161  : 		{
; 162  : 			if (ptext[i] == '\"' && !quotes && i > 0 && ptext[i-1] != ' ') // Malformed command

  00092	8b 45 f4	 mov	 eax, DWORD PTR _ptext$[ebp]
  00095	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00098	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009b	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0009e	75 20		 jne	 SHORT $LN8@COM_BufExe
  000a0	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _quotes$[ebp], 0
  000a7	75 17		 jne	 SHORT $LN8@COM_BufExe
  000a9	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000ad	76 11		 jbe	 SHORT $LN8@COM_BufExe
  000af	8b 45 f4	 mov	 eax, DWORD PTR _ptext$[ebp]
  000b2	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000b5	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  000b9	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000bc	74 02		 je	 SHORT $LN8@COM_BufExe

; 163  : 				break;

  000be	eb 5b		 jmp	 SHORT $LN5@COM_BufExe
$LN8@COM_BufExe:

; 164  : 			if (ptext[i] == '\"')

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _ptext$[ebp]
  000c3	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000c6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c9	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000cc	75 0f		 jne	 SHORT $LN9@COM_BufExe

; 165  : 				quotes++;

  000ce	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _quotes$[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _quotes$[ebp], eax
$LN9@COM_BufExe:

; 166  : 			if (!(quotes & 1) && ptext[i] == ';')

  000dd	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _quotes$[ebp]
  000e3	83 e0 01	 and	 eax, 1
  000e6	75 10		 jne	 SHORT $LN10@COM_BufExe
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _ptext$[ebp]
  000eb	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000ee	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f1	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  000f4	75 02		 jne	 SHORT $LN10@COM_BufExe

; 167  : 				break; // don't break if inside a quoted string

  000f6	eb 23		 jmp	 SHORT $LN5@COM_BufExe
$LN10@COM_BufExe:

; 168  : 			if (ptext[i] == '\n' || ptext[i] == '\r')

  000f8	8b 45 f4	 mov	 eax, DWORD PTR _ptext$[ebp]
  000fb	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000fe	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00101	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00104	74 0e		 je	 SHORT $LN12@COM_BufExe
  00106	8b 45 f4	 mov	 eax, DWORD PTR _ptext$[ebp]
  00109	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0010c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0010f	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00112	75 02		 jne	 SHORT $LN11@COM_BufExe
$LN12@COM_BufExe:

; 169  : 				break;

  00114	eb 05		 jmp	 SHORT $LN5@COM_BufExe
$LN11@COM_BufExe:

; 170  : 		}

  00116	e9 5f ff ff ff	 jmp	 $LN4@COM_BufExe
$LN5@COM_BufExe:

; 171  : 
; 172  : 		M_Memcpy(line, ptext, i);

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011e	50		 push	 eax
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _ptext$[ebp]
  00122	51		 push	 ecx
  00123	8d 95 f4 fb ff
	ff		 lea	 edx, DWORD PTR _line$[ebp]
  00129	52		 push	 edx
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 173  : 		line[i] = 0;

  00133	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00136	89 85 2c fb ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0013c	81 bd 2c fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  00146	73 02		 jae	 SHORT $LN17@COM_BufExe
  00148	eb 06		 jmp	 SHORT $LN18@COM_BufExe
$LN17@COM_BufExe:
  0014a	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0014f	90		 npad	 1
$LN18@COM_BufExe:
  00150	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00156	c6 84 0d f4 fb
	ff ff 00	 mov	 BYTE PTR _line$[ebp+ecx], 0

; 174  : 
; 175  : 		// flush the command text from the command buffer, _BEFORE_
; 176  : 		// executing, to avoid that 'recursive' aliases overflow the
; 177  : 		// command text buffer, in that case, new commands are inserted
; 178  : 		// at the beginning, in place of the actual, so it doesn't
; 179  : 		// overflow
; 180  : 		if (i == com_text.cursize)

  0015e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00161	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _com_text+16
  00167	75 0c		 jne	 SHORT $LN13@COM_BufExe

; 181  : 			// the last command was just flushed
; 182  : 			com_text.cursize = 0;

  00169	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _com_text+16, 0
  00173	eb 2f		 jmp	 SHORT $LN14@COM_BufExe
$LN13@COM_BufExe:

; 183  : 		else
; 184  : 		{
; 185  : 			i++;

  00175	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00178	83 c0 01	 add	 eax, 1
  0017b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 186  : 			com_text.cursize -= i;

  0017e	a1 10 00 00 00	 mov	 eax, DWORD PTR _com_text+16
  00183	2b 45 f8	 sub	 eax, DWORD PTR _i$[ebp]
  00186	a3 10 00 00 00	 mov	 DWORD PTR _com_text+16, eax

; 187  : 			//memcpy(ptext, ptext+i, com_text.cursize); // Use memmove if the memory areas do overlap.
; 188  : 			memmove(ptext, ptext+i, com_text.cursize);

  0018b	a1 10 00 00 00	 mov	 eax, DWORD PTR _com_text+16
  00190	50		 push	 eax
  00191	8b 4d f4	 mov	 ecx, DWORD PTR _ptext$[ebp]
  00194	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 f4	 mov	 edx, DWORD PTR _ptext$[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 _memmove
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@COM_BufExe:

; 189  : 		}
; 190  : 
; 191  : 		// execute the command line
; 192  : 		COM_ExecuteString(line);

  001a4	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _line$[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 _COM_ExecuteString
  001b0	83 c4 04	 add	 esp, 4

; 193  : 
; 194  : 		// delay following commands if a wait was encountered
; 195  : 		if (com_wait)

  001b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _com_wait, 0
  001ba	74 0f		 je	 SHORT $LN15@COM_BufExe

; 196  : 		{
; 197  : 			com_wait--;

  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_wait
  001c1	83 e8 01	 sub	 eax, 1
  001c4	a3 00 00 00 00	 mov	 DWORD PTR _com_wait, eax

; 198  : 			break;

  001c9	eb 05		 jmp	 SHORT $LN3@COM_BufExe
$LN15@COM_BufExe:

; 199  : 		}
; 200  : 	}

  001cb	e9 82 fe ff ff	 jmp	 $LN7@COM_BufExe
$LN3@COM_BufExe:

; 201  : }

  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d6	33 cd		 xor	 ecx, ebp
  001d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
_COM_BufExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_ImmedExecute
_TEXT	SEGMENT
$T1 = -1236						; size = 4
_quotes$ = -1040					; size = 4
_line$ = -1036						; size = 1024
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ptext$ = 8						; size = 4
_COM_ImmedExecute PROC					; COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 207  : 	size_t i = 0, j = 0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 208  : 	char line[1024] = "";

  00024	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  00029	88 85 f4 fb ff
	ff		 mov	 BYTE PTR _line$[ebp], al
  0002f	68 ff 03 00 00	 push	 1023			; 000003ffH
  00034	6a 00		 push	 0
  00036	8d 85 f5 fb ff
	ff		 lea	 eax, DWORD PTR _line$[ebp+1]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@COM_ImmedE:

; 209  : 	INT32 quotes;
; 210  : 
; 211  : 	while (i < strlen(ptext))

  00045	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strlen
  0004e	83 c4 04	 add	 esp, 4
  00051	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00054	0f 83 29 01 00
	00		 jae	 $LN3@COM_ImmedE

; 212  : 	{
; 213  : 
; 214  : 		quotes = 0;

  0005a	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _quotes$[ebp], 0

; 215  : 		for (j = 0; i < strlen(ptext); i++,j++)

  00064	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0006b	eb 12		 jmp	 SHORT $LN6@COM_ImmedE
$LN4@COM_ImmedE:
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00076	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00079	83 c1 01	 add	 ecx, 1
  0007c	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN6@COM_ImmedE:
  0007f	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _strlen
  00088	83 c4 04	 add	 esp, 4
  0008b	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0008e	0f 83 8a 00 00
	00		 jae	 $LN5@COM_ImmedE

; 216  : 		{
; 217  : 			if (ptext[i] == '\"' && !quotes && i > 0 && ptext[i-1] != ' ') // Malformed command

  00094	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00097	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000a0	75 23		 jne	 SHORT $LN7@COM_ImmedE
  000a2	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _quotes$[ebp], 0
  000a9	75 1a		 jne	 SHORT $LN7@COM_ImmedE
  000ab	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000af	76 14		 jbe	 SHORT $LN7@COM_ImmedE
  000b1	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  000b4	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000b7	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  000bb	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000be	74 05		 je	 SHORT $LN7@COM_ImmedE

; 218  : 				return;

  000c0	e9 be 00 00 00	 jmp	 $LN3@COM_ImmedE
$LN7@COM_ImmedE:

; 219  : 			if (ptext[i] == '\"')

  000c5	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  000c8	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000cb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ce	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000d1	75 0f		 jne	 SHORT $LN8@COM_ImmedE

; 220  : 				quotes++;

  000d3	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _quotes$[ebp]
  000d9	83 c0 01	 add	 eax, 1
  000dc	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _quotes$[ebp], eax
$LN8@COM_ImmedE:

; 221  : 			// don't break if inside a quoted string
; 222  : 			if ((!(quotes & 1) && ptext[i] == ';') || ptext[i] == '\n' || ptext[i] == '\r')

  000e2	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _quotes$[ebp]
  000e8	83 e0 01	 and	 eax, 1
  000eb	75 0e		 jne	 SHORT $LN11@COM_ImmedE
  000ed	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  000f0	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000f3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f6	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  000f9	74 1c		 je	 SHORT $LN10@COM_ImmedE
$LN11@COM_ImmedE:
  000fb	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  000fe	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00101	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00104	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00107	74 0e		 je	 SHORT $LN10@COM_ImmedE
  00109	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  0010c	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0010f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00112	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00115	75 02		 jne	 SHORT $LN9@COM_ImmedE
$LN10@COM_ImmedE:

; 223  : 				break;

  00117	eb 05		 jmp	 SHORT $LN5@COM_ImmedE
$LN9@COM_ImmedE:

; 224  : 		}

  00119	e9 4f ff ff ff	 jmp	 $LN4@COM_ImmedE
$LN5@COM_ImmedE:

; 225  : 
; 226  : 		memcpy(line, ptext+(i-j), j);

  0011e	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00121	50		 push	 eax
  00122	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00125	2b 4d f4	 sub	 ecx, DWORD PTR _j$[ebp]
  00128	03 4d 08	 add	 ecx, DWORD PTR _ptext$[ebp]
  0012b	51		 push	 ecx
  0012c	8d 95 f4 fb ff
	ff		 lea	 edx, DWORD PTR _line$[ebp]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 _memcpy
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 		line[j] = 0;

  0013b	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0013e	89 85 2c fb ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00144	81 bd 2c fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  0014e	73 02		 jae	 SHORT $LN13@COM_ImmedE
  00150	eb 06		 jmp	 SHORT $LN14@COM_ImmedE
$LN13@COM_ImmedE:
  00152	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00157	90		 npad	 1
$LN14@COM_ImmedE:
  00158	8b 8d 2c fb ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0015e	c6 84 0d f4 fb
	ff ff 00	 mov	 BYTE PTR _line$[ebp+ecx], 0

; 228  : 
; 229  : 		// execute the command line
; 230  : 		COM_ExecuteString(line);

  00166	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _line$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _COM_ExecuteString
  00172	83 c4 04	 add	 esp, 4

; 231  : 
; 232  : 		i++; // move to next character

  00175	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00178	83 c0 01	 add	 eax, 1
  0017b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 233  : 	}

  0017e	e9 c2 fe ff ff	 jmp	 $LN2@COM_ImmedE
$LN3@COM_ImmedE:

; 234  : }

  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00189	33 cd		 xor	 ecx, ebp
  0018b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c3		 ret	 0
_COM_ImmedExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_BufInsertText
_TEXT	SEGMENT
_templen$ = -8						; size = 4
_temp$ = -4						; size = 4
_ptext$ = 8						; size = 4
_COM_BufInsertText PROC					; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 116  : 	char *temp = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _temp$[ebp], 0

; 117  : 	size_t templen;
; 118  : 
; 119  : 	// copy off any commands still remaining in the exec buffer
; 120  : 	templen = com_text.cursize;

  00010	a1 10 00 00 00	 mov	 eax, DWORD PTR _com_text+16
  00015	89 45 f8	 mov	 DWORD PTR _templen$[ebp], eax

; 121  : 	if (templen)

  00018	83 7d f8 00	 cmp	 DWORD PTR _templen$[ebp], 0
  0001c	74 37		 je	 SHORT $LN2@COM_BufIns

; 122  : 	{
; 123  : 		temp = M_Memcpy(ZZ_Alloc(templen), com_text.data, templen);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _templen$[ebp]
  00021	50		 push	 eax
  00022	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _com_text+8
  00028	51		 push	 ecx
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	6a 01		 push	 1
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _templen$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 _Z_MallocAlign
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	89 45 fc	 mov	 DWORD PTR _temp$[ebp], eax

; 124  : 		VS_Clear(&com_text);

  00048	68 00 00 00 00	 push	 OFFSET _com_text
  0004d	e8 00 00 00 00	 call	 _VS_Clear
  00052	83 c4 04	 add	 esp, 4
$LN2@COM_BufIns:

; 125  : 	}
; 126  : 
; 127  : 	// add the entire text of the file (or alias)
; 128  : 	COM_BufAddText(ptext);

  00055	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _COM_BufAddText
  0005e	83 c4 04	 add	 esp, 4

; 129  : 	COM_BufExecute(); // do it right away

  00061	e8 00 00 00 00	 call	 _COM_BufExecute
  00066	90		 npad	 1

; 130  : 
; 131  : 	// add the copied off data
; 132  : 	if (templen)

  00067	83 7d f8 00	 cmp	 DWORD PTR _templen$[ebp], 0
  0006b	74 21		 je	 SHORT $LN3@COM_BufIns

; 133  : 	{
; 134  : 		VS_Write(&com_text, temp, templen);

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _templen$[ebp]
  00070	50		 push	 eax
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _temp$[ebp]
  00074	51		 push	 ecx
  00075	68 00 00 00 00	 push	 OFFSET _com_text
  0007a	e8 00 00 00 00	 call	 _VS_Write
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  : 		Z_Free(temp);

  00082	8b 45 fc	 mov	 eax, DWORD PTR _temp$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _Z_Free
  0008b	83 c4 04	 add	 esp, 4
$LN3@COM_BufIns:

; 136  : 	}
; 137  : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_COM_BufInsertText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_BufAddText
_TEXT	SEGMENT
_l$ = -4						; size = 4
_ptext$ = 8						; size = 4
_COM_BufAddText PROC					; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 97   : 	size_t l;
; 98   : 
; 99   : 	l = strlen(ptext);

  00009	8b 45 08	 mov	 eax, DWORD PTR _ptext$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax

; 100  : 
; 101  : 	if (com_text.cursize + l >= com_text.maxsize)

  00018	a1 10 00 00 00	 mov	 eax, DWORD PTR _com_text+16
  0001d	03 45 fc	 add	 eax, DWORD PTR _l$[ebp]
  00020	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _com_text+12
  00026	72 0f		 jb	 SHORT $LN2@COM_BufAdd

; 102  : 	{
; 103  : 		CONS_Printf("Command buffer full!\n");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OJJDFBCN@Command?5buffer?5full?$CB?6@
  0002d	e8 00 00 00 00	 call	 _CONS_Printf
  00032	83 c4 04	 add	 esp, 4

; 104  : 		return;

  00035	eb 15		 jmp	 SHORT $LN1@COM_BufAdd
$LN2@COM_BufAdd:

; 105  : 	}
; 106  : 	VS_Write(&com_text, ptext, l);

  00037	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _ptext$[ebp]
  0003e	51		 push	 ecx
  0003f	68 00 00 00 00	 push	 OFFSET _com_text
  00044	e8 00 00 00 00	 call	 _VS_Write
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@COM_BufAdd:

; 107  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_COM_BufAddText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_CompleteCommand
_TEXT	SEGMENT
tv77 = -76						; size = 4
_len$ = -8						; size = 4
_cmd$ = -4						; size = 4
_partial$ = 8						; size = 4
_skips$ = 12						; size = 4
_COM_CompleteCommand PROC				; COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 423  : 	xcommand_t *cmd;
; 424  : 	size_t len;
; 425  : 
; 426  : 	len = strlen(partial);

  00009	8b 45 08	 mov	 eax, DWORD PTR _partial$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 427  : 
; 428  : 	if (!len)

  00018	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0001c	75 04		 jne	 SHORT $LN5@COM_Comple

; 429  : 		return NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 53		 jmp	 SHORT $LN1@COM_Comple
$LN5@COM_Comple:

; 430  : 
; 431  : 	// check functions
; 432  : 	for (cmd = com_commands; cmd; cmd = cmd->next)

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_commands
  00027	89 45 fc	 mov	 DWORD PTR _cmd$[ebp], eax
  0002a	eb 09		 jmp	 SHORT $LN4@COM_Comple
$LN2@COM_Comple:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	89 4d fc	 mov	 DWORD PTR _cmd$[ebp], ecx
$LN4@COM_Comple:
  00035	83 7d fc 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  00039	74 38		 je	 SHORT $LN3@COM_Comple

; 433  : 		if (!strncmp(partial, cmd->name, len))

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _cmd$[ebp]
  00042	8b 11		 mov	 edx, DWORD PTR [ecx]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _partial$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strncmp
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	85 c0		 test	 eax, eax
  00053	75 1c		 jne	 SHORT $LN7@COM_Comple

; 434  : 			if (!skips--)

  00055	8b 45 0c	 mov	 eax, DWORD PTR _skips$[ebp]
  00058	89 45 b4	 mov	 DWORD PTR tv77[ebp], eax
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _skips$[ebp]
  0005e	83 e9 01	 sub	 ecx, 1
  00061	89 4d 0c	 mov	 DWORD PTR _skips$[ebp], ecx
  00064	83 7d b4 00	 cmp	 DWORD PTR tv77[ebp], 0
  00068	75 07		 jne	 SHORT $LN7@COM_Comple

; 435  : 				return cmd->name;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	eb 04		 jmp	 SHORT $LN1@COM_Comple
$LN7@COM_Comple:
  00071	eb b9		 jmp	 SHORT $LN2@COM_Comple
$LN3@COM_Comple:

; 436  : 
; 437  : 	return NULL;

  00073	33 c0		 xor	 eax, eax
$LN1@COM_Comple:

; 438  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_COM_CompleteCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_CheckParm
_TEXT	SEGMENT
_i$ = -4						; size = 4
_check$ = 8						; size = 4
_COM_CheckParm PROC					; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 318  : 	size_t i;
; 319  : 
; 320  : 	for (i = 1; i < com_argc; i++)

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00010	eb 09		 jmp	 SHORT $LN4@COM_CheckP
$LN2@COM_CheckP:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@COM_CheckP:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _com_argc
  00024	73 22		 jae	 SHORT $LN3@COM_CheckP

; 321  : 		if (!strcasecmp(check, com_argv[i]))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _com_argv[eax*4]
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _check$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _stricmp
  0003a	83 c4 08	 add	 esp, 8
  0003d	85 c0		 test	 eax, eax
  0003f	75 05		 jne	 SHORT $LN5@COM_CheckP

; 322  : 			return i;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00044	eb 04		 jmp	 SHORT $LN1@COM_CheckP
$LN5@COM_CheckP:
  00046	eb ca		 jmp	 SHORT $LN2@COM_CheckP
$LN3@COM_CheckP:

; 323  : 	return 0;

  00048	33 c0		 xor	 eax, eax
$LN1@COM_CheckP:

; 324  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_COM_CheckParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Args
_TEXT	SEGMENT
_COM_Args PROC						; COMDAT

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 307  : 	return com_args;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_args

; 308  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_COM_Args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Argv
_TEXT	SEGMENT
_arg$ = 8						; size = 4
_COM_Argv PROC						; COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 295  : 	if (arg >= com_argc || (signed)arg < 0)

  00009	8b 45 08	 mov	 eax, DWORD PTR _arg$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _com_argc
  00012	73 06		 jae	 SHORT $LN3@COM_Argv
  00014	83 7d 08 00	 cmp	 DWORD PTR _arg$[ebp], 0
  00018	7d 07		 jge	 SHORT $LN2@COM_Argv
$LN3@COM_Argv:

; 296  : 		return com_null_string;

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_null_string
  0001f	eb 0a		 jmp	 SHORT $LN1@COM_Argv
$LN2@COM_Argv:

; 297  : 	return com_argv[arg];

  00021	8b 45 08	 mov	 eax, DWORD PTR _arg$[ebp]
  00024	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _com_argv[eax*4]
$LN1@COM_Argv:

; 298  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_COM_Argv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_Argc
_TEXT	SEGMENT
_COM_Argc PROC						; COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 284  : 	return com_argc;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_argc

; 285  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_COM_Argc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\command.c
;	COMDAT _COM_AddCommand
_TEXT	SEGMENT
_cmd$ = -4						; size = 4
_name$ = 8						; size = 4
_func$ = 12						; size = 4
_COM_AddCommand PROC					; COMDAT

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 372  : 	xcommand_t *cmd;
; 373  : 
; 374  : 	// fail if the command is a variable name
; 375  : 	if (CV_StringValue(name)[0] != '\0')

  00009	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _CV_StringValue
  00012	83 c4 04	 add	 esp, 4
  00015	b9 01 00 00 00	 mov	 ecx, 1
  0001a	6b d1 00	 imul	 edx, ecx, 0
  0001d	0f be 04 10	 movsx	 eax, BYTE PTR [eax+edx]
  00021	85 c0		 test	 eax, eax
  00023	74 13		 je	 SHORT $LN5@COM_AddCom

; 376  : 	{
; 377  : 		I_Error("%s is a variable name\n", name);

  00025	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PLIEPDJG@?$CFs?5is?5a?5variable?5name?6@
  0002e	e8 00 00 00 00	 call	 _I_Error
  00033	83 c4 08	 add	 esp, 8

; 378  : 		return;

  00036	eb 7c		 jmp	 SHORT $LN1@COM_AddCom
$LN5@COM_AddCom:

; 379  : 	}
; 380  : 
; 381  : 	// fail if the command already exists
; 382  : 	for (cmd = com_commands; cmd; cmd = cmd->next)

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _com_commands
  0003d	89 45 fc	 mov	 DWORD PTR _cmd$[ebp], eax
  00040	eb 09		 jmp	 SHORT $LN4@COM_AddCom
$LN2@COM_AddCom:
  00042	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	89 4d fc	 mov	 DWORD PTR _cmd$[ebp], ecx
$LN4@COM_AddCom:
  0004b	83 7d fc 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  0004f	74 2b		 je	 SHORT $LN3@COM_AddCom

; 383  : 	{
; 384  : 		if (!stricmp(name, cmd->name)) //case insensitive now that we have lower and uppercase!

  00051	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 08	 mov	 edx, DWORD PTR _name$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _stricmp
  00060	83 c4 08	 add	 esp, 8
  00063	85 c0		 test	 eax, eax
  00065	75 13		 jne	 SHORT $LN6@COM_AddCom

; 385  : 		{
; 386  : 			I_Error("Command %s already exists\n", name);

  00067	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PHFIBCN@Command?5?$CFs?5already?5exists?6@
  00070	e8 00 00 00 00	 call	 _I_Error
  00075	83 c4 08	 add	 esp, 8

; 387  : 			return;

  00078	eb 3a		 jmp	 SHORT $LN1@COM_AddCom
$LN6@COM_AddCom:

; 388  : 		}
; 389  : 	}

  0007a	eb c6		 jmp	 SHORT $LN2@COM_AddCom
$LN3@COM_AddCom:

; 390  : 
; 391  : 	cmd = ZZ_Alloc(sizeof *cmd);

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 01		 push	 1
  00082	6a 0c		 push	 12			; 0000000cH
  00084	e8 00 00 00 00	 call	 _Z_MallocAlign
  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	89 45 fc	 mov	 DWORD PTR _cmd$[ebp], eax

; 392  : 	cmd->name = name;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx

; 393  : 	cmd->function = func;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _func$[ebp]
  0009d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 394  : 	cmd->next = com_commands;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _com_commands
  000a9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 395  : 	com_commands = cmd;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _cmd$[ebp]
  000af	a3 00 00 00 00	 mov	 DWORD PTR _com_commands, eax
$LN1@COM_AddCom:

; 396  : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_COM_AddCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
