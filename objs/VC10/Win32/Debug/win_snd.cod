; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\win_snd.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_bMidiLooped
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_dwVolumePercent:DWORD
_DATA	ENDS
_BSS	SEGMENT
_bMidiLooped DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_I_SetMidiChannelVolume
PUBLIC	_I_GetSfx
PUBLIC	_I_FreeSfx
PUBLIC	_I_StartupSound
PUBLIC	_I_ShutdownSound
PUBLIC	_I_StartSound
PUBLIC	_I_StopSound
PUBLIC	_I_SoundIsPlaying
PUBLIC	_I_UpdateSoundParams
PUBLIC	_I_SetSfxVolume
PUBLIC	_I_InitMusic
PUBLIC	_I_ShutdownMusic
PUBLIC	_I_PauseSong
PUBLIC	_I_ResumeSong
PUBLIC	_I_InitMIDIMusic
PUBLIC	_I_ShutdownMIDIMusic
PUBLIC	_I_SetMIDIMusicVolume
PUBLIC	_I_RegisterSong
PUBLIC	_I_PlaySong
PUBLIC	_I_StopSong
PUBLIC	_I_UnRegisterSong
PUBLIC	_I_InitDigMusic
PUBLIC	_I_ShutdownDigMusic
PUBLIC	_I_SetSongSpeed
PUBLIC	_I_StartDigSong
PUBLIC	_I_StopDigSong
PUBLIC	_I_SetDigMusicVolume
PUBLIC	??_C@_0BI@LMFLOHGH@Restore?5fail?5on?5?$CFp?0?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@OGJHGFPO@Lock?5fail?$CI2?$CJ?5on?5?$CFp?0?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@JKPGEACF@Lock?5fail?$CI1?$CJ?5on?5?$CFp?0?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BH@GIHODJA@Unlock?5fail?5on?5?$CFp?0?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CH@FOLMDOGH@CopyAndInvert?3?5Restore?5fail?5on?5@ ; `string'
PUBLIC	??_C@_0CH@EHALMPO@CopyAndInvert?3?5Lock?5fail?$CI2?$CJ?5on?5@ ; `string'
PUBLIC	??_C@_0CI@MCKAOOKL@CopyAndInvetrt?3?5Lock?5fail?$CI1?$CJ?5on@ ; `string'
PUBLIC	??_C@_0CG@FJCEPHFJ@CopyAndInvert?3?5Unlock?5fail?5on?5?$CF@ ; `string'
PUBLIC	??_C@_0GF@IHPLDPHJ@?7SoundBufferCreate?5error?5?9?5a?5bu@ ; `string'
PUBLIC	??_C@_0CA@HABLBEKB@CreateSoundBuffer?$CI?$CJ?5FAILED?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CE@PIABFBFE@I_StartSound?5?3?5?9?$DORestore?5FAILED@ ; `string'
PUBLIC	??_C@_0L@HDBBEELN@DSOUND?4DLL@			; `string'
PUBLIC	??_C@_0BC@GKIGDBEH@DirectSoundCreate@		; `string'
PUBLIC	??_C@_0BD@MHGMIPHA@I_ShutdownSound?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0BB@EGNOPLCP@I_StartupSound?3?5@		; `string'
PUBLIC	??_C@_05FKHDODDC@?9freq@			; `string'
PUBLIC	??_C@_0BP@PNCOJDPE@?5requested?5frequency?5of?5?$CFd?5hz?6@ ; `string'
PUBLIC	??_C@_0L@MDEJICN@?9coopsound@			; `string'
PUBLIC	??_C@_05MHILGDCB@?9ds3d@			; `string'
PUBLIC	??_C@_0L@NACJPEKC@s_ds3d?4dll@			; `string'
PUBLIC	??_C@_07CMDIEHOI@?9fmod3d@			; `string'
PUBLIC	??_C@_0L@HDJLHMPO@s_fmod?4dll@			; `string'
PUBLIC	??_C@_07IEAEJLGN@?9openal@			; `string'
PUBLIC	??_C@_0N@EPGNJCOA@s_openal?4dll@		; `string'
PUBLIC	??_C@_0N@PEDBCFFI@?9sounddriver@		; `string'
PUBLIC	??_C@_0CA@PBKKFDKM@Using?5external?5sound?5driver?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CE@ICKPPAPH@Not?5using?5external?5sound?5driver@ ; `string'
PUBLIC	??_C@_0BN@EOBCMMFO@?5DirectSound?5DLL?5not?5loaded?6@ ; `string'
PUBLIC	??_C@_0HG@ENBAALLE@?5DirectSoundCreate?5FAILED?6?5ther@ ; `string'
PUBLIC	??_C@_0BN@JLLKBHMH@?5SetCooperativeLevel?5FAILED?6@ ; `string'
PUBLIC	??_C@_0CK@EJBPBFLF@CreateSoundBuffer?5FAILED?3?5?$CFs?5?$CIE@ ; `string'
PUBLIC	??_C@_0DH@DMGMEEND@I_StartupSound?5?3?5?5couldn?8t?5set?5@ ; `string'
PUBLIC	??_C@_0CE@EPBAOBKP@?5Compacting?5onboard?5sound?9memor@ ; `string'
PUBLIC	??_C@_04GMOJEHPC@done@				; `string'
PUBLIC	??_C@_06OHCJKBJM@FAILED@			; `string'
PUBLIC	??_C@_04MDKIEGGJ@?5?$CFs?6@			; `string'
PUBLIC	??_C@_0CI@GPPFBKNC@?5Primary?5buffer?5continuous?5play@ ; `string'
PUBLIC	??_C@_0BE@LALGGIEN@sound?5initialised?4?6@	; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BC@DGMHJPLI@I_InitDigMusic?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0BD@CKHFPBDI@I_InitMIDIMusic?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0CO@KMPDLJMG@No?5MIDI?5devices?5available?0?5musi@ ; `string'
PUBLIC	??_C@_08DMGAMJFH@?9winmidi@			; `string'
PUBLIC	??_C@_0BK@FJOCNIKF@midiOutGetCaps?5FAILED?5?3?5?6@ ; `string'
PUBLIC	??_C@_0BH@EJBAJKDI@MIDI?5product?5name?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_08JCKGCGII@FM?5Synth@			; `string'
PUBLIC	??_C@_0BG@LDJPMKAP@Microsoft?5MIDI?5Mapper@	; `string'
PUBLIC	??_C@_0BD@OFCCDCFH@MIDI?5hardware?5port@	; `string'
PUBLIC	??_C@_0BI@PNFJHGIO@Square?5wave?5synthesizer@	; `string'
PUBLIC	??_C@_0M@LMECJLFI@Synthesizer@			; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown@			; `string'
PUBLIC	??_C@_0BF@IPGEIJMH@MIDI?5technology?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0M@LBEIDFMC@MIDI?5caps?3?6@		; `string'
PUBLIC	??_C@_0BA@MNELLNIM@?9Patch?5caching?6@		; `string'
PUBLIC	??_C@_0CJ@OCJBONLJ@?9Separate?5left?5and?5right?5volume@ ; `string'
PUBLIC	??_C@_0CF@MMNIHBDC@?9Direct?5support?5for?5midiStreamO@ ; `string'
PUBLIC	??_C@_0BB@CCMJMEKG@?9Volume?5control?6@		; `string'
PUBLIC	??_C@_0CL@LHGPBBJI@SRB2?5Midi?5Playback?3?5Wait?5For?5Bu@ ; `string'
PUBLIC	??_C@_0P@IAOAAAKM@No?5MIDI?5music?6@		; `string'
PUBLIC	??_C@_0CH@EAJMJIOO@I_RegisterSong?3?5midiStreamOpen?5@ ; `string'
PUBLIC	??_C@_0BF@EHAKIJCE@I_ShutdownDigMusic?3?6@	; `string'
PUBLIC	??_C@_06ENIPNAIK@?5Done?6@			; `string'
PUBLIC	??_C@_0BH@NKIEHFEO@I_ShutdownMIDIMusic?3?5?6@	; `string'
PUBLIC	??_C@_0CH@GNMLHIE@I_SetMusicVolume?3?5couldn?8t?5set?5@ ; `string'
PUBLIC	??_C@_0CF@KOIMFAFM@Timed?5out?5waiting?5for?5MIDI?5call@ ; `string'
PUBLIC	??_C@_04JKIEDINE@MThd@				; `string'
PUBLIC	??_C@_0CE@CGKEEJ@Music?5lump?5is?5not?5MID?5music?5for@ ; `string'
PUBLIC	??_C@_0CJ@GCMMCOOJ@I_RegisterSong?3?5StreamBufferSet@ ; `string'
PUBLIC	??_C@_0DD@NICHODNP@StreamBufferSetup?3?5initial?5conv@ ; `string'
PUBLIC	??_C@_0CP@PNIELMGN@MidiStreamCallback?$CI?$CJ?3?5conversio@ ; `string'
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__GlobalHandle@4:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__midiOutGetNumDevs@0:PROC
EXTRN	__imp__midiStreamOpen@24:PROC
EXTRN	__imp__midiStreamClose@4:PROC
EXTRN	__imp__midiStreamProperty@12:PROC
EXTRN	__imp__midiStreamOut@12:PROC
EXTRN	__imp__midiStreamPause@4:PROC
EXTRN	__imp__midiStreamRestart@4:PROC
EXTRN	__imp__midiStreamStop@4:PROC
EXTRN	__imp__midiOutGetDevCapsA@12:PROC
EXTRN	__imp__midiOutSetVolume@8:PROC
EXTRN	__imp__midiOutGetErrorTextA@12:PROC
EXTRN	__imp__midiOutPrepareHeader@12:PROC
EXTRN	__imp__midiOutUnprepareHeader@12:PROC
EXTRN	__imp__midiOutShortMsg@8:PROC
EXTRN	__imp__midiOutReset@4:PROC
EXTRN	_atoi:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_I_ShowLastError:PROC
EXTRN	_CV_SetValue:PROC
EXTRN	_S_GetSfxLumpNum:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_I_AddExitFunc:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_DXErrorToString:PROC
EXTRN	_Mid2StreamConverterCleanup:PROC
EXTRN	_Mid2StreamConverterInit:PROC
EXTRN	_Mid2StreamConvertToBuffer:PROC
EXTRN	_HW3S_Init:PROC
EXTRN	_HW3S_Shutdown:PROC
EXTRN	_HW3S_GetSfx:PROC
EXTRN	_HW3S_FreeSfx:PROC
EXTRN	_Init3DSDriver:PROC
EXTRN	_Shutdown3DSDriver:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	_devparm:DWORD
EXTRN	_hWndMain:DWORD
EXTRN	_S_sfx:BYTE
EXTRN	_sound_started:BYTE
EXTRN	_cv_samplerate:BYTE
EXTRN	_cv_midimusicvolume:BYTE
EXTRN	_nomidimusic:DWORD
EXTRN	_nosound:DWORD
EXTRN	_nodigimusic:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_ifs:BYTE
EXTRN	_dwProgressBytes:DWORD
EXTRN	_hws_mode:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_DSnd	DD	01H DUP (?)
_DSndPrimary DD	01H DUP (?)
_StackSounds DB	0200H DUP (?)
_DSoundDLL DD	01H DUP (?)
_pfnDirectSoundCreate DD 01H DUP (?)
_bMusicStarted DD 01H DUP (?)
_uMIDIDeviceID DD 01H DUP (?)
_uCallbackStatus DD 01H DUP (?)
_hStream DD	01H DUP (?)
_hBufferReturnEvent DD 01H DUP (?)
_nCurrentBuffer DD 01H DUP (?)
_nEmptyBuffers DD 01H DUP (?)
_bBuffersPrepared DD 01H DUP (?)
_dwVolCache DD	010H DUP (?)
_bMidiPlaying DD 01H DUP (?)
_bMidiPaused DD	01H DUP (?)
_ciStreamBuffers DB 0a8H DUP (?)
_bMidiCanSetVolume DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CP@PNIELMGN@MidiStreamCallback?$CI?$CJ?3?5conversio@
CONST	SEGMENT
??_C@_0CP@PNIELMGN@MidiStreamCallback?$CI?$CJ?3?5conversio@ DB 'MidiStrea'
	DB	'mCallback(): conversion pass failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NICHODNP@StreamBufferSetup?3?5initial?5conv@
CONST	SEGMENT
??_C@_0DD@NICHODNP@StreamBufferSetup?3?5initial?5conv@ DB 'StreamBufferSe'
	DB	'tup: initial conversion pass failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GCMMCOOJ@I_RegisterSong?3?5StreamBufferSet@
CONST	SEGMENT
??_C@_0CJ@GCMMCOOJ@I_RegisterSong?3?5StreamBufferSet@ DB 'I_RegisterSong:'
	DB	' StreamBufferSetup FAILED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CGKEEJ@Music?5lump?5is?5not?5MID?5music?5for@
CONST	SEGMENT
??_C@_0CE@CGKEEJ@Music?5lump?5is?5not?5MID?5music?5for@ DB 'Music lump is'
	DB	' not MID music format', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKIEDINE@MThd@
CONST	SEGMENT
??_C@_04JKIEDINE@MThd@ DB 'MThd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KOIMFAFM@Timed?5out?5waiting?5for?5MIDI?5call@
CONST	SEGMENT
??_C@_0CF@KOIMFAFM@Timed?5out?5waiting?5for?5MIDI?5call@ DB 'Timed out wa'
	DB	'iting for MIDI callback', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GNMLHIE@I_SetMusicVolume?3?5couldn?8t?5set?5@
CONST	SEGMENT
??_C@_0CH@GNMLHIE@I_SetMusicVolume?3?5couldn?8t?5set?5@ DB 'I_SetMusicVol'
	DB	'ume: couldn''t set volume', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NKIEHFEO@I_ShutdownMIDIMusic?3?5?6@
CONST	SEGMENT
??_C@_0BH@NKIEHFEO@I_ShutdownMIDIMusic?3?5?6@ DB 'I_ShutdownMIDIMusic: ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENIPNAIK@?5Done?6@
CONST	SEGMENT
??_C@_06ENIPNAIK@?5Done?6@ DB ' Done', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EHAKIJCE@I_ShutdownDigMusic?3?6@
CONST	SEGMENT
??_C@_0BF@EHAKIJCE@I_ShutdownDigMusic?3?6@ DB 'I_ShutdownDigMusic:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EAJMJIOO@I_RegisterSong?3?5midiStreamOpen?5@
CONST	SEGMENT
??_C@_0CH@EAJMJIOO@I_RegisterSong?3?5midiStreamOpen?5@ DB 'I_RegisterSong'
	DB	': midiStreamOpen FAILED', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IAOAAAKM@No?5MIDI?5music?6@
CONST	SEGMENT
??_C@_0P@IAOAAAKM@No?5MIDI?5music?6@ DB 'No MIDI music', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LHGPBBJI@SRB2?5Midi?5Playback?3?5Wait?5For?5Bu@
CONST	SEGMENT
??_C@_0CL@LHGPBBJI@SRB2?5Midi?5Playback?3?5Wait?5For?5Bu@ DB 'SRB2 Midi P'
	DB	'layback: Wait For Buffer Return', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CCMJMEKG@?9Volume?5control?6@
CONST	SEGMENT
??_C@_0BB@CCMJMEKG@?9Volume?5control?6@ DB '-Volume control', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MMNIHBDC@?9Direct?5support?5for?5midiStreamO@
CONST	SEGMENT
??_C@_0CF@MMNIHBDC@?9Direct?5support?5for?5midiStreamO@ DB '-Direct suppo'
	DB	'rt for midiStreamOut()', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OCJBONLJ@?9Separate?5left?5and?5right?5volume@
CONST	SEGMENT
??_C@_0CJ@OCJBONLJ@?9Separate?5left?5and?5right?5volume@ DB '-Separate le'
	DB	'ft and right volume control', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MNELLNIM@?9Patch?5caching?6@
CONST	SEGMENT
??_C@_0BA@MNELLNIM@?9Patch?5caching?6@ DB '-Patch caching', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LBEIDFMC@MIDI?5caps?3?6@
CONST	SEGMENT
??_C@_0M@LBEIDFMC@MIDI?5caps?3?6@ DB 'MIDI caps:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPGEIJMH@MIDI?5technology?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@IPGEIJMH@MIDI?5technology?3?5?$CFs?6@ DB 'MIDI technology: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMECJLFI@Synthesizer@
CONST	SEGMENT
??_C@_0M@LMECJLFI@Synthesizer@ DB 'Synthesizer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PNFJHGIO@Square?5wave?5synthesizer@
CONST	SEGMENT
??_C@_0BI@PNFJHGIO@Square?5wave?5synthesizer@ DB 'Square wave synthesizer'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OFCCDCFH@MIDI?5hardware?5port@
CONST	SEGMENT
??_C@_0BD@OFCCDCFH@MIDI?5hardware?5port@ DB 'MIDI hardware port', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LDJPMKAP@Microsoft?5MIDI?5Mapper@
CONST	SEGMENT
??_C@_0BG@LDJPMKAP@Microsoft?5MIDI?5Mapper@ DB 'Microsoft MIDI Mapper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JCKGCGII@FM?5Synth@
CONST	SEGMENT
??_C@_08JCKGCGII@FM?5Synth@ DB 'FM Synth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EJBAJKDI@MIDI?5product?5name?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@EJBAJKDI@MIDI?5product?5name?3?5?$CFs?6@ DB 'MIDI product name:'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FJOCNIKF@midiOutGetCaps?5FAILED?5?3?5?6@
CONST	SEGMENT
??_C@_0BK@FJOCNIKF@midiOutGetCaps?5FAILED?5?3?5?6@ DB 'midiOutGetCaps FAI'
	DB	'LED : ', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMGAMJFH@?9winmidi@
CONST	SEGMENT
??_C@_08DMGAMJFH@?9winmidi@ DB '-winmidi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KMPDLJMG@No?5MIDI?5devices?5available?0?5musi@
CONST	SEGMENT
??_C@_0CO@KMPDLJMG@No?5MIDI?5devices?5available?0?5musi@ DB 'No MIDI devi'
	DB	'ces available, music is disabled', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKHFPBDI@I_InitMIDIMusic?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BD@CKHFPBDI@I_InitMIDIMusic?$CI?$CJ?6@ DB 'I_InitMIDIMusic()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DGMHJPLI@I_InitDigMusic?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BC@DGMHJPLI@I_InitDigMusic?$CI?$CJ?6@ DB 'I_InitDigMusic()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LALGGIEN@sound?5initialised?4?6@
CONST	SEGMENT
??_C@_0BE@LALGGIEN@sound?5initialised?4?6@ DB 'sound initialised.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GPPFBKNC@?5Primary?5buffer?5continuous?5play@
CONST	SEGMENT
??_C@_0CI@GPPFBKNC@?5Primary?5buffer?5continuous?5play@ DB ' Primary buff'
	DB	'er continuous play FAILED', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDKIEGGJ@?5?$CFs?6@
CONST	SEGMENT
??_C@_04MDKIEGGJ@?5?$CFs?6@ DB ' %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHCJKBJM@FAILED@
CONST	SEGMENT
??_C@_06OHCJKBJM@FAILED@ DB 'FAILED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMOJEHPC@done@
CONST	SEGMENT
??_C@_04GMOJEHPC@done@ DB 'done', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EPBAOBKP@?5Compacting?5onboard?5sound?9memor@
CONST	SEGMENT
??_C@_0CE@EPBAOBKP@?5Compacting?5onboard?5sound?9memor@ DB ' Compacting o'
	DB	'nboard sound-memory...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DMGMEEND@I_StartupSound?5?3?5?5couldn?8t?5set?5@
CONST	SEGMENT
??_C@_0DH@DMGMEEND@I_StartupSound?5?3?5?5couldn?8t?5set?5@ DB 'I_StartupS'
	DB	'ound :  couldn''t set primary buffer format.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EJBPBFLF@CreateSoundBuffer?5FAILED?3?5?$CFs?5?$CIE@
CONST	SEGMENT
??_C@_0CK@EJBPBFLF@CreateSoundBuffer?5FAILED?3?5?$CFs?5?$CIE@ DB 'CreateS'
	DB	'oundBuffer FAILED: %s (ErrNo %ld)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JLLKBHMH@?5SetCooperativeLevel?5FAILED?6@
CONST	SEGMENT
??_C@_0BN@JLLKBHMH@?5SetCooperativeLevel?5FAILED?6@ DB ' SetCooperativeLe'
	DB	'vel FAILED', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@ENBAALLE@?5DirectSoundCreate?5FAILED?6?5ther@
CONST	SEGMENT
??_C@_0HG@ENBAALLE@?5DirectSoundCreate?5FAILED?6?5ther@ DB ' DirectSoundC'
	DB	'reate FAILED', 0aH, ' there is no sound device or the sound d'
	DB	'evice is under', 0aH, ' the control of another application', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EOBCMMFO@?5DirectSound?5DLL?5not?5loaded?6@
CONST	SEGMENT
??_C@_0BN@EOBCMMFO@?5DirectSound?5DLL?5not?5loaded?6@ DB ' DirectSound DL'
	DB	'L not loaded', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ICKPPAPH@Not?5using?5external?5sound?5driver@
CONST	SEGMENT
??_C@_0CE@ICKPPAPH@Not?5using?5external?5sound?5driver@ DB 'Not using ext'
	DB	'ernal sound driver %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PBKKFDKM@Using?5external?5sound?5driver?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@PBKKFDKM@Using?5external?5sound?5driver?5?$CFs?6@ DB 'Using ext'
	DB	'ernal sound driver %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEDBCFFI@?9sounddriver@
CONST	SEGMENT
??_C@_0N@PEDBCFFI@?9sounddriver@ DB '-sounddriver', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPGNJCOA@s_openal?4dll@
CONST	SEGMENT
??_C@_0N@EPGNJCOA@s_openal?4dll@ DB 's_openal.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEAEJLGN@?9openal@
CONST	SEGMENT
??_C@_07IEAEJLGN@?9openal@ DB '-openal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDJLHMPO@s_fmod?4dll@
CONST	SEGMENT
??_C@_0L@HDJLHMPO@s_fmod?4dll@ DB 's_fmod.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMDIEHOI@?9fmod3d@
CONST	SEGMENT
??_C@_07CMDIEHOI@?9fmod3d@ DB '-fmod3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NACJPEKC@s_ds3d?4dll@
CONST	SEGMENT
??_C@_0L@NACJPEKC@s_ds3d?4dll@ DB 's_ds3d.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MHILGDCB@?9ds3d@
CONST	SEGMENT
??_C@_05MHILGDCB@?9ds3d@ DB '-ds3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDEJICN@?9coopsound@
CONST	SEGMENT
??_C@_0L@MDEJICN@?9coopsound@ DB '-coopsound', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNCOJDPE@?5requested?5frequency?5of?5?$CFd?5hz?6@
CONST	SEGMENT
??_C@_0BP@PNCOJDPE@?5requested?5frequency?5of?5?$CFd?5hz?6@ DB ' requeste'
	DB	'd frequency of %d hz', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHDODDC@?9freq@
CONST	SEGMENT
??_C@_05FKHDODDC@?9freq@ DB '-freq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EGNOPLCP@I_StartupSound?3?5@
CONST	SEGMENT
??_C@_0BB@EGNOPLCP@I_StartupSound?3?5@ DB 'I_StartupSound: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MHGMIPHA@I_ShutdownSound?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BD@MHGMIPHA@I_ShutdownSound?$CI?$CJ?6@ DB 'I_ShutdownSound()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GKIGDBEH@DirectSoundCreate@
CONST	SEGMENT
??_C@_0BC@GKIGDBEH@DirectSoundCreate@ DB 'DirectSoundCreate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDBBEELN@DSOUND?4DLL@
CONST	SEGMENT
??_C@_0L@HDBBEELN@DSOUND?4DLL@ DB 'DSOUND.DLL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PIABFBFE@I_StartSound?5?3?5?9?$DORestore?5FAILED@
CONST	SEGMENT
??_C@_0CE@PIABFBFE@I_StartSound?5?3?5?9?$DORestore?5FAILED@ DB 'I_StartSo'
	DB	'und : ->Restore FAILED, %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HABLBEKB@CreateSoundBuffer?$CI?$CJ?5FAILED?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@HABLBEKB@CreateSoundBuffer?$CI?$CJ?5FAILED?3?5?$CFs?6@ DB 'Crea'
	DB	'teSoundBuffer() FAILED: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@IHPLDPHJ@?7SoundBufferCreate?5error?5?9?5a?5bu@
CONST	SEGMENT
??_C@_0GF@IHPLDPHJ@?7SoundBufferCreate?5error?5?9?5a?5bu@ DB 09H, 'SoundB'
	DB	'ufferCreate error - a buffer control is not available.', 0aH, 09H
	DB	'Trying to disable frequency control.', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_sound_buffer_flags DD 040c2H
_DATA	ENDS
;	COMDAT ??_C@_0CG@FJCEPHFJ@CopyAndInvert?3?5Unlock?5fail?5on?5?$CF@
CONST	SEGMENT
??_C@_0CG@FJCEPHFJ@CopyAndInvert?3?5Unlock?5fail?5on?5?$CF@ DB 'CopyAndIn'
	DB	'vert: Unlock fail on %p, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MCKAOOKL@CopyAndInvetrt?3?5Lock?5fail?$CI1?$CJ?5on@
CONST	SEGMENT
??_C@_0CI@MCKAOOKL@CopyAndInvetrt?3?5Lock?5fail?$CI1?$CJ?5on@ DB 'CopyAnd'
	DB	'Invetrt: Lock fail(1) on %p, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EHALMPO@CopyAndInvert?3?5Lock?5fail?$CI2?$CJ?5on?5@
CONST	SEGMENT
??_C@_0CH@EHALMPO@CopyAndInvert?3?5Lock?5fail?$CI2?$CJ?5on?5@ DB 'CopyAnd'
	DB	'Invert: Lock fail(2) on %p, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FOLMDOGH@CopyAndInvert?3?5Restore?5fail?5on?5@
CONST	SEGMENT
??_C@_0CH@FOLMDOGH@CopyAndInvert?3?5Restore?5fail?5on?5@ DB 'CopyAndInver'
	DB	't: Restore fail on %p, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GIHODJA@Unlock?5fail?5on?5?$CFp?0?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@GIHODJA@Unlock?5fail?5on?5?$CFp?0?5?$CFs?6@ DB 'Unlock fail on '
	DB	'%p, %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JKPGEACF@Lock?5fail?$CI1?$CJ?5on?5?$CFp?0?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@JKPGEACF@Lock?5fail?$CI1?$CJ?5on?5?$CFp?0?5?$CFs?6@ DB 'Lock fa'
	DB	'il(1) on %p, %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OGJHGFPO@Lock?5fail?$CI2?$CJ?5on?5?$CFp?0?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@OGJHGFPO@Lock?5fail?$CI2?$CJ?5on?5?$CFp?0?5?$CFs?6@ DB 'Lock fa'
	DB	'il(2) on %p, %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LMFLOHGH@Restore?5fail?5on?5?$CFp?0?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@LMFLOHGH@Restore?5fail?5on?5?$CFp?0?5?$CFs?6@ DB 'Restore fail '
	DB	'on %p, %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	07cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	017bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02d9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	047cH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _SetAllChannelVolumes
_TEXT	SEGMENT
_mmrRetVal$ = -20					; size = 4
_idx$ = -16						; size = 4
_dwVol$ = -12						; size = 4
_dwStatus$ = -8						; size = 4
_dwEvent$ = -4						; size = 4
_pdwVolumePercent$ = 8					; size = 4
_SetAllChannelVolumes PROC				; COMDAT

; 1500 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1501 : 	DWORD       dwEvent, dwStatus, dwVol, idx;
; 1502 : 	MMRESULT    mmrRetVal;
; 1503 : 
; 1504 : 	if (!bMidiPlaying)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPlaying, 0
  00010	75 02		 jne	 SHORT $LN5@SetAllChan

; 1505 : 		return;

  00012	eb 7f		 jmp	 SHORT $LN3@SetAllChan
$LN5@SetAllChan:

; 1506 : 
; 1507 : 	for (idx = 0, dwStatus = MIDI_CTRLCHANGE; idx < MAX_MIDI_IN_TRACKS; idx++, dwStatus++)

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  0001b	c7 45 f8 b0 00
	00 00		 mov	 DWORD PTR _dwStatus$[ebp], 176 ; 000000b0H
  00022	eb 12		 jmp	 SHORT $LN4@SetAllChan
$LN2@SetAllChan:
  00024	8b 45 f0	 mov	 eax, DWORD PTR _idx$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 f0	 mov	 DWORD PTR _idx$[ebp], eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _dwStatus$[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d f8	 mov	 DWORD PTR _dwStatus$[ebp], ecx
$LN4@SetAllChan:
  00036	83 7d f0 10	 cmp	 DWORD PTR _idx$[ebp], 16 ; 00000010H
  0003a	73 57		 jae	 SHORT $LN3@SetAllChan

; 1508 : 	{
; 1509 : 		dwVol = (dwVolCache[idx] * pdwVolumePercent) / 1000;

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _idx$[ebp]
  0003f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _dwVolCache[eax*4]
  00046	0f af 45 08	 imul	 eax, DWORD PTR _pdwVolumePercent$[ebp]
  0004a	33 d2		 xor	 edx, edx
  0004c	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00051	f7 f1		 div	 ecx
  00053	89 45 f4	 mov	 DWORD PTR _dwVol$[ebp], eax

; 1510 : 		//CONS_Printf("channel %d vol %d\n", idx, dwVol);
; 1511 : 		dwEvent = dwStatus | ((DWORD)MIDICTRL_VOLUME << 8)

  00056	8b 45 f8	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  00059	0d 00 07 00 00	 or	 eax, 1792		; 00000700H
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _dwVol$[ebp]
  00061	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00064	0b c1		 or	 eax, ecx
  00066	89 45 fc	 mov	 DWORD PTR _dwEvent$[ebp], eax

; 1512 : 			| ((DWORD)dwVol << 16);
; 1513 : 		if ((mmrRetVal = midiOutShortMsg((HMIDIOUT)hStream, dwEvent))
; 1514 : 			!= MMSYSERR_NOERROR)

  00069	8b 45 fc	 mov	 eax, DWORD PTR _dwEvent$[ebp]
  0006c	50		 push	 eax
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  00073	51		 push	 ecx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutShortMsg@8
  0007a	89 45 ec	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  0007d	83 7d ec 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00081	74 0e		 je	 SHORT $LN6@SetAllChan

; 1515 : 		{
; 1516 : 			MidiErrorMessageBox(mmrRetVal);

  00083	8b 45 ec	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  0008c	83 c4 04	 add	 esp, 4

; 1517 : 			return;

  0008f	eb 02		 jmp	 SHORT $LN3@SetAllChan
$LN6@SetAllChan:

; 1518 : 		}
; 1519 : 	}

  00091	eb 91		 jmp	 SHORT $LN2@SetAllChan
$LN3@SetAllChan:

; 1520 : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_SetAllChannelVolumes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _MidiErrorMessageBox
_TEXT	SEGMENT
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_mmr$ = 8						; size = 4
_MidiErrorMessageBox PROC				; COMDAT

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1172 : 	CHAR szTemp[256] = "";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 fc fe ff
	ff		 mov	 BYTE PTR _szTemp$[ebp], al
  00021	68 ff 00 00 00	 push	 255			; 000000ffH
  00026	6a 00		 push	 0
  00028	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp+1]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1173 : 
; 1174 : 	/*szTemp[0] = '\2';   //white text to stand out*/
; 1175 : 	if ((MMSYSERR_NOERROR == midiOutGetErrorTextA(mmr, szTemp/*+1*/, sizeof (szTemp))) && *szTemp)

  00037	68 00 01 00 00	 push	 256			; 00000100H
  0003c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _mmr$[ebp]
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutGetErrorTextA@12
  0004d	85 c0		 test	 eax, eax
  0004f	75 28		 jne	 SHORT $LN2@MidiErrorM
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	6b c8 00	 imul	 ecx, eax, 0
  00059	0f be 94 0d fc
	fe ff ff	 movsx	 edx, BYTE PTR _szTemp$[ebp+ecx]
  00061	85 d2		 test	 edx, edx
  00063	74 14		 je	 SHORT $LN2@MidiErrorM

; 1176 : 		I_OutputMsg("%s\n",szTemp);

  00065	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0006b	50		 push	 eax
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  00071	e8 00 00 00 00	 call	 _I_OutputMsg
  00076	83 c4 08	 add	 esp, 8
$LN2@MidiErrorM:

; 1177 : 	/*MessageBox(GetActiveWindow(), szTemp+1, "LEGACY",
; 1178 : 				MB_OK | MB_ICONSTOP);*/
; 1179 : 	//wsprintf(szDebug, "Midi subsystem error: %s", szTemp);
; 1180 : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_MidiErrorMessageBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _StreamBufferSetup
_TEXT	SEGMENT
_idx$ = -28						; size = 4
_nChkErr$ = -24						; size = 4
_dwConvertFlag$ = -20					; size = 4
_bFoundEnd$ = -16					; size = 4
_mptd$ = -12						; size = 8
_mmrRetVal$ = -4					; size = 4
_pMidiData$ = 8						; size = 4
_iMidiSize$ = 12					; size = 4
_StreamBufferSetup PROC					; COMDAT

; 2198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2199 : 	MMRESULT mmrRetVal;
; 2200 : 	MIDIPROPTIMEDIV mptd;
; 2201 : 	BOOL bFoundEnd = FALSE;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bFoundEnd$[ebp], 0

; 2202 : 	int dwConvertFlag, nChkErr, idx;
; 2203 : 
; 2204 : #ifdef DEBUGMIDISTREAM
; 2205 : 	if (hStream == NULL)
; 2206 : 		I_Error("StreamBufferSetup: hStream is NULL!");
; 2207 : #endif
; 2208 : 
; 2209 : 	// pause midi stream before manipulating the buffers
; 2210 : 	midiStreamPause(hStream);

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamPause@4
  0001c	90		 npad	 1

; 2211 : 
; 2212 : 	// allocate the stream buffers (only once)
; 2213 : 	for (idx = 0; idx < NUM_STREAM_BUFFERS; idx++)

  0001d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@StreamBuff
$LN2@StreamBuff:
  00026	8b 45 e4	 mov	 eax, DWORD PTR _idx$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 e4	 mov	 DWORD PTR _idx$[ebp], eax
$LN4@StreamBuff:
  0002f	83 7d e4 02	 cmp	 DWORD PTR _idx$[ebp], 2
  00033	7d 4f		 jge	 SHORT $LN3@StreamBuff

; 2214 : 	{
; 2215 : 		ciStreamBuffers[idx].mhBuffer.dwBufferLength = OUT_BUFFER_SIZE;

  00035	6b 45 e4 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  00039	c7 80 04 00 00
	00 00 04 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+4], 1024 ; 00000400H

; 2216 : 		if (!ciStreamBuffers[idx].mhBuffer.lpData)

  00043	6b 45 e4 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  00047	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _ciStreamBuffers[eax], 0
  0004e	75 32		 jne	 SHORT $LN12@StreamBuff

; 2217 : 		{
; 2218 : 			ciStreamBuffers[idx].mhBuffer.lpData = GlobalAllocPtr(GHND, OUT_BUFFER_SIZE);

  00050	68 00 04 00 00	 push	 1024			; 00000400H
  00055	6a 42		 push	 66			; 00000042H
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00064	6b 4d e4 54	 imul	 ecx, DWORD PTR _idx$[ebp], 84
  00068	89 81 00 00 00
	00		 mov	 DWORD PTR _ciStreamBuffers[ecx], eax

; 2219 : 			if (!ciStreamBuffers[idx].mhBuffer.lpData)

  0006e	6b 45 e4 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  00072	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _ciStreamBuffers[eax], 0
  00079	75 07		 jne	 SHORT $LN12@StreamBuff

; 2220 : 				return FALSE;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 39 02 00 00	 jmp	 $LN1@StreamBuff
$LN12@StreamBuff:

; 2221 : 		}
; 2222 : 	}

  00082	eb a2		 jmp	 SHORT $LN2@StreamBuff
$LN3@StreamBuff:

; 2223 : 
; 2224 : 	// returns TRUE in case of conversion error
; 2225 : 	if (Mid2StreamConverterInit(pMidiData, iMidiSize))

  00084	8b 45 0c	 mov	 eax, DWORD PTR _iMidiSize$[ebp]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _pMidiData$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _Mid2StreamConverterInit
  00091	83 c4 08	 add	 esp, 8
  00094	85 c0		 test	 eax, eax
  00096	74 0a		 je	 SHORT $LN13@StreamBuff

; 2226 : 		return TRUE;

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	e9 19 02 00 00	 jmp	 $LN1@StreamBuff
$LN13@StreamBuff:

; 2227 : 
; 2228 : 	// Initialize the volume cache array to some pre-defined value
; 2229 : 	for (idx = 0; idx < MAX_MIDI_IN_TRACKS; idx++)

  000a2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  000a9	eb 09		 jmp	 SHORT $LN7@StreamBuff
$LN5@StreamBuff:
  000ab	8b 45 e4	 mov	 eax, DWORD PTR _idx$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 e4	 mov	 DWORD PTR _idx$[ebp], eax
$LN7@StreamBuff:
  000b4	83 7d e4 10	 cmp	 DWORD PTR _idx$[ebp], 16 ; 00000010H
  000b8	7d 10		 jge	 SHORT $LN6@StreamBuff

; 2230 : 		dwVolCache[idx] = VOL_CACHE_INIT;

  000ba	8b 45 e4	 mov	 eax, DWORD PTR _idx$[ebp]
  000bd	c7 04 85 00 00
	00 00 7f 00 00
	00		 mov	 DWORD PTR _dwVolCache[eax*4], 127 ; 0000007fH
  000c8	eb e1		 jmp	 SHORT $LN5@StreamBuff
$LN6@StreamBuff:

; 2231 : 
; 2232 : 	mptd.cbStruct = sizeof (mptd);

  000ca	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _mptd$[ebp], 8

; 2233 : 	mptd.dwTimeDiv = ifs.dwTimeDivision;

  000d1	a1 10 00 00 00	 mov	 eax, DWORD PTR _ifs+16
  000d6	89 45 f8	 mov	 DWORD PTR _mptd$[ebp+4], eax

; 2234 : 	if ((mmrRetVal = midiStreamProperty(hStream, (LPBYTE)&mptd, MIDIPROP_SET|MIDIPROP_TIMEDIV))
; 2235 : 	    != MMSYSERR_NOERROR)

  000d9	68 01 00 00 80	 push	 -2147483647		; 80000001H
  000de	8d 45 f4	 lea	 eax, DWORD PTR _mptd$[ebp]
  000e1	50		 push	 eax
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  000e8	51		 push	 ecx
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamProperty@12
  000ef	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  000f2	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  000f6	74 16		 je	 SHORT $LN14@StreamBuff

; 2236 : 	{
; 2237 : 		MidiErrorMessageBox(mmrRetVal);

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  00101	83 c4 04	 add	 esp, 4

; 2238 : 		return TRUE;

  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	e9 ad 01 00 00	 jmp	 $LN1@StreamBuff
$LN14@StreamBuff:

; 2239 : 	}
; 2240 : 
; 2241 : 	nEmptyBuffers = 0;

  0010e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nEmptyBuffers, 0

; 2242 : 	dwConvertFlag = CONVERTF_RESET;

  00118	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dwConvertFlag$[ebp], 1

; 2243 : 
; 2244 : 	for (nCurrentBuffer = 0; nCurrentBuffer < NUM_STREAM_BUFFERS; nCurrentBuffer++)

  0011f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nCurrentBuffer, 0
  00129	eb 0d		 jmp	 SHORT $LN10@StreamBuff
$LN8@StreamBuff:
  0012b	a1 00 00 00 00	 mov	 eax, DWORD PTR _nCurrentBuffer
  00130	83 c0 01	 add	 eax, 1
  00133	a3 00 00 00 00	 mov	 DWORD PTR _nCurrentBuffer, eax
$LN10@StreamBuff:
  00138	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _nCurrentBuffer, 2
  0013f	0f 8d 31 01 00
	00		 jge	 $LN9@StreamBuff

; 2245 : 	{
; 2246 : 		// Tell the converter to convert up to one entire buffer's length of output
; 2247 : 		// data. Also, set a flag so it knows to reset any saved state variables it
; 2248 : 		// may keep from call to call.
; 2249 : 		ciStreamBuffers[nCurrentBuffer].dwStartOffset = 0;

  00145	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0014c	c7 80 40 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+64], 0

; 2250 : 		ciStreamBuffers[nCurrentBuffer].dwMaxLength = OUT_BUFFER_SIZE;

  00156	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0015d	c7 80 44 00 00
	00 00 04 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+68], 1024 ; 00000400H

; 2251 : 		ciStreamBuffers[nCurrentBuffer].tkStart = 0;

  00167	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0016e	c7 80 4c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+76], 0

; 2252 : 		ciStreamBuffers[nCurrentBuffer].bTimesUp = FALSE;

  00178	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0017f	c7 80 50 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+80], 0

; 2253 : 
; 2254 : 		if ((nChkErr = Mid2StreamConvertToBuffer(dwConvertFlag, &ciStreamBuffers[nCurrentBuffer]))
; 2255 : 		    != CONVERTERR_NOERROR)

  00189	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  00190	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  00195	50		 push	 eax
  00196	8b 4d ec	 mov	 ecx, DWORD PTR _dwConvertFlag$[ebp]
  00199	51		 push	 ecx
  0019a	e8 00 00 00 00	 call	 _Mid2StreamConvertToBuffer
  0019f	83 c4 08	 add	 esp, 8
  001a2	89 45 e8	 mov	 DWORD PTR _nChkErr$[ebp], eax
  001a5	83 7d e8 00	 cmp	 DWORD PTR _nChkErr$[ebp], 0
  001a9	74 26		 je	 SHORT $LN17@StreamBuff

; 2256 : 		{
; 2257 : 			if (nChkErr == CONVERTERR_DONE)

  001ab	83 7d e8 99	 cmp	 DWORD PTR _nChkErr$[ebp], -103 ; ffffff99H
  001af	75 09		 jne	 SHORT $LN16@StreamBuff

; 2258 : 				bFoundEnd = TRUE;

  001b1	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bFoundEnd$[ebp], 1
  001b8	eb 17		 jmp	 SHORT $LN17@StreamBuff
$LN16@StreamBuff:

; 2259 : 			else
; 2260 : 			{
; 2261 : 				CONS_Printf("StreamBufferSetup: initial conversion pass failed\n");

  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NICHODNP@StreamBufferSetup?3?5initial?5conv@
  001bf	e8 00 00 00 00	 call	 _CONS_Printf
  001c4	83 c4 04	 add	 esp, 4

; 2262 : 				return TRUE;

  001c7	b8 01 00 00 00	 mov	 eax, 1
  001cc	e9 ea 00 00 00	 jmp	 $LN1@StreamBuff
$LN17@StreamBuff:

; 2263 : 			}
; 2264 : 		}
; 2265 : 		ciStreamBuffers[nCurrentBuffer].mhBuffer.dwBytesRecorded

  001d1	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  001d8	6b 0d 00 00 00
	00 54		 imul	 ecx, DWORD PTR _nCurrentBuffer, 84
  001df	8b 90 48 00 00
	00		 mov	 edx, DWORD PTR _ciStreamBuffers[eax+72]
  001e5	89 91 08 00 00
	00		 mov	 DWORD PTR _ciStreamBuffers[ecx+8], edx

; 2266 : 			= ciStreamBuffers[nCurrentBuffer].dwBytesRecorded;
; 2267 : 
; 2268 : 		if (!bBuffersPrepared)

  001eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bBuffersPrepared, 0
  001f2	75 3b		 jne	 SHORT $LN19@StreamBuff

; 2269 : 		{
; 2270 : 			if ((mmrRetVal = midiOutPrepareHeader((HMIDIOUT)hStream,
; 2271 : 				&ciStreamBuffers[nCurrentBuffer].mhBuffer, sizeof (MIDIHDR))) != MMSYSERR_NOERROR)

  001f4	6a 40		 push	 64			; 00000040H
  001f6	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  001fd	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  00202	50		 push	 eax
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  00209	51		 push	 ecx
  0020a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutPrepareHeader@12
  00210	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  00213	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00217	74 16		 je	 SHORT $LN19@StreamBuff

; 2272 : 			{
; 2273 : 				MidiErrorMessageBox(mmrRetVal);

  00219	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  00222	83 c4 04	 add	 esp, 4

; 2274 : 				return TRUE;

  00225	b8 01 00 00 00	 mov	 eax, 1
  0022a	e9 8c 00 00 00	 jmp	 $LN1@StreamBuff
$LN19@StreamBuff:

; 2275 : 			}
; 2276 : 		}
; 2277 : 		if ((mmrRetVal = midiStreamOut(hStream, &ciStreamBuffers[nCurrentBuffer].mhBuffer,
; 2278 : 			sizeof (MIDIHDR))) != MMSYSERR_NOERROR)

  0022f	6a 40		 push	 64			; 00000040H
  00231	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  00238	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  0023d	50		 push	 eax
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  00244	51		 push	 ecx
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamOut@12
  0024b	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  0024e	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00252	74 0e		 je	 SHORT $LN20@StreamBuff

; 2279 : 		{
; 2280 : 			MidiErrorMessageBox(mmrRetVal);

  00254	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  0025d	83 c4 04	 add	 esp, 4

; 2281 : 			break;

  00260	eb 14		 jmp	 SHORT $LN9@StreamBuff
$LN20@StreamBuff:

; 2282 : 		}
; 2283 : 		dwConvertFlag = 0;

  00262	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwConvertFlag$[ebp], 0

; 2284 : 
; 2285 : 		if (bFoundEnd)

  00269	83 7d f0 00	 cmp	 DWORD PTR _bFoundEnd$[ebp], 0
  0026d	74 02		 je	 SHORT $LN21@StreamBuff

; 2286 : 			break;

  0026f	eb 05		 jmp	 SHORT $LN9@StreamBuff
$LN21@StreamBuff:

; 2287 : 	}

  00271	e9 b5 fe ff ff	 jmp	 $LN8@StreamBuff
$LN9@StreamBuff:

; 2288 : 
; 2289 : 	bBuffersPrepared = TRUE;

  00276	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bBuffersPrepared, 1

; 2290 : 	nCurrentBuffer = 0;

  00280	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nCurrentBuffer, 0

; 2291 : 
; 2292 : 	// MIDI volume
; 2293 : 	dwVolumePercent = (cv_midimusicvolume.value * 1000) / 32;

  0028a	69 05 14 00 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR _cv_midimusicvolume+20, 1000
  00294	99		 cdq
  00295	83 e2 1f	 and	 edx, 31			; 0000001fH
  00298	03 c2		 add	 eax, edx
  0029a	c1 f8 05	 sar	 eax, 5
  0029d	a3 00 00 00 00	 mov	 DWORD PTR _dwVolumePercent, eax

; 2294 : 	if (hStream)

  002a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hStream, 0
  002a9	74 0e		 je	 SHORT $LN22@StreamBuff

; 2295 : 		SetAllChannelVolumes(dwVolumePercent);

  002ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _dwVolumePercent
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _SetAllChannelVolumes
  002b6	83 c4 04	 add	 esp, 4
$LN22@StreamBuff:

; 2296 : 
; 2297 : 	return FALSE;

  002b9	33 c0		 xor	 eax, eax
$LN1@StreamBuff:

; 2298 : }

  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5b		 pop	 ebx
  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
_StreamBufferSetup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _MidiStreamCallback@20
_TEXT	SEGMENT
tv64 = -84						; size = 4
_pmh$ = -16						; size = 4
_pme$ = -12						; size = 4
_nChkErr$ = -8						; size = 4
_mmrRetVal$ = -4					; size = 4
_hMidi$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_dwInstance$ = 16					; size = 4
_dwParam1$ = 20						; size = 4
_dwParam2$ = 24						; size = 4
_MidiStreamCallback@20 PROC				; COMDAT

; 2331 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2332 : 	MMRESULT mmrRetVal;
; 2333 : 	int nChkErr;
; 2334 : 	MIDIEVENT* pme;
; 2335 : 	MIDIHDR* pmh;
; 2336 : 
; 2337 : 	UNREFERENCED_PARAMETER(hMidi);
; 2338 : 	UNREFERENCED_PARAMETER(dwParam1);
; 2339 : 	UNREFERENCED_PARAMETER(dwParam2);
; 2340 : 	UNREFERENCED_PARAMETER(dwInstance);
; 2341 : 	switch (uMsg)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  0000c	89 45 ac	 mov	 DWORD PTR tv64[ebp], eax
  0000f	81 7d ac c9 03
	00 00		 cmp	 DWORD PTR tv64[ebp], 969 ; 000003c9H
  00016	74 12		 je	 SHORT $LN4@MidiStream
  00018	81 7d ac ca 03
	00 00		 cmp	 DWORD PTR tv64[ebp], 970 ; 000003caH
  0001f	0f 84 fc 01 00
	00		 je	 $LN17@MidiStream
  00025	e9 73 02 00 00	 jmp	 $LN20@MidiStream
$LN4@MidiStream:

; 2342 : 	{
; 2343 : 		case MOM_DONE:
; 2344 : 			// dwParam1 is LPMIDIHDR
; 2345 : 			if (uCallbackStatus == STATUS_CALLBACKDEAD)

  0002a	81 3d 00 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H
  00034	75 05		 jne	 SHORT $LN5@MidiStream

; 2346 : 				return;

  00036	e9 62 02 00 00	 jmp	 $LN1@MidiStream
$LN5@MidiStream:

; 2347 : 
; 2348 : 			nEmptyBuffers++;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _nEmptyBuffers
  00040	83 c0 01	 add	 eax, 1
  00043	a3 00 00 00 00	 mov	 DWORD PTR _nEmptyBuffers, eax

; 2349 : 
; 2350 : 			// we reached end of song, but we wait until all the buffers are returned
; 2351 : 			if (uCallbackStatus == STATUS_WAITINGFOREND)

  00048	81 3d 00 00 00
	00 2c 01 00 00	 cmp	 DWORD PTR _uCallbackStatus, 300 ; 0000012cH
  00052	75 36		 jne	 SHORT $LN8@MidiStream

; 2352 : 			{
; 2353 : 				if (nEmptyBuffers < NUM_STREAM_BUFFERS)

  00054	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _nEmptyBuffers, 2
  0005b	7d 07		 jge	 SHORT $LN7@MidiStream

; 2354 : 					return;

  0005d	e9 3b 02 00 00	 jmp	 $LN1@MidiStream
  00062	eb 26		 jmp	 SHORT $LN8@MidiStream
$LN7@MidiStream:

; 2355 : 				else
; 2356 : 				{
; 2357 : 					// stop the song when end reached (was not looping)
; 2358 : 					uCallbackStatus = STATUS_CALLBACKDEAD;

  00064	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H

; 2359 : 					SetEvent(hBufferReturnEvent);

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hBufferReturnEvent
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  0007a	90		 npad	 1

; 2360 : 					I_StopSong(0);

  0007b	6a 00		 push	 0
  0007d	e8 00 00 00 00	 call	 _I_StopSong
  00082	83 c4 04	 add	 esp, 4

; 2361 : 					return;

  00085	e9 13 02 00 00	 jmp	 $LN1@MidiStream
$LN8@MidiStream:

; 2362 : 				}
; 2363 : 			}
; 2364 : 
; 2365 : 			// This flag is set whenever the callback is waiting for all buffers to come back.
; 2366 : 			if (uCallbackStatus == STATUS_KILLCALLBACK)

  0008a	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _uCallbackStatus, 100 ; 00000064H
  00091	75 2c		 jne	 SHORT $LN11@MidiStream

; 2367 : 			{
; 2368 : 				// Count NUM_STREAM_BUFFERS-1 being returned for the last time
; 2369 : 				if (nEmptyBuffers < NUM_STREAM_BUFFERS)

  00093	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _nEmptyBuffers, 2
  0009a	7d 07		 jge	 SHORT $LN10@MidiStream

; 2370 : 					return;

  0009c	e9 fc 01 00 00	 jmp	 $LN1@MidiStream
  000a1	eb 1c		 jmp	 SHORT $LN11@MidiStream
$LN10@MidiStream:

; 2371 : 				// Then send a stop message when we get the last buffer back...
; 2372 : 				else
; 2373 : 				{
; 2374 : 					// Change the status to callback dead
; 2375 : 					uCallbackStatus = STATUS_CALLBACKDEAD;

  000a3	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H

; 2376 : 					SetEvent(hBufferReturnEvent);

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _hBufferReturnEvent
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  000b9	90		 npad	 1

; 2377 : 					return;

  000ba	e9 de 01 00 00	 jmp	 $LN1@MidiStream
$LN11@MidiStream:

; 2378 : 				}
; 2379 : 			}
; 2380 : 
; 2381 : 			dwProgressBytes += ciStreamBuffers[nCurrentBuffer].mhBuffer.dwBytesRecorded;

  000bf	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dwProgressBytes
  000cc	03 88 08 00 00
	00		 add	 ecx, DWORD PTR _ciStreamBuffers[eax+8]
  000d2	89 0d 00 00 00
	00		 mov	 DWORD PTR _dwProgressBytes, ecx

; 2382 : 
; 2383 : 			// -------------------------------------------------
; 2384 : 			// Fill an available buffer with audio data again...
; 2385 : 			// -------------------------------------------------
; 2386 : 
; 2387 : 			if (bMidiPlaying && nEmptyBuffers)

  000d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPlaying, 0
  000df	0f 84 3a 01 00
	00		 je	 $LN12@MidiStream
  000e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nEmptyBuffers, 0
  000ec	0f 84 2d 01 00
	00		 je	 $LN12@MidiStream

; 2388 : 			{
; 2389 : 				ciStreamBuffers[nCurrentBuffer].dwStartOffset = 0;

  000f2	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  000f9	c7 80 40 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+64], 0

; 2390 : 				ciStreamBuffers[nCurrentBuffer].dwMaxLength = OUT_BUFFER_SIZE;

  00103	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0010a	c7 80 44 00 00
	00 00 04 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+68], 1024 ; 00000400H

; 2391 : 				ciStreamBuffers[nCurrentBuffer].tkStart = 0;

  00114	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0011b	c7 80 4c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+76], 0

; 2392 : 				ciStreamBuffers[nCurrentBuffer].dwBytesRecorded = 0;

  00125	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0012c	c7 80 48 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+72], 0

; 2393 : 				ciStreamBuffers[nCurrentBuffer].bTimesUp = FALSE;

  00136	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0013d	c7 80 50 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax+80], 0

; 2394 : 
; 2395 : 				if ((nChkErr = Mid2StreamConvertToBuffer(0, &ciStreamBuffers[nCurrentBuffer]))
; 2396 : 				   != CONVERTERR_NOERROR)

  00147	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  0014e	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  00153	50		 push	 eax
  00154	6a 00		 push	 0
  00156	e8 00 00 00 00	 call	 _Mid2StreamConvertToBuffer
  0015b	83 c4 08	 add	 esp, 8
  0015e	89 45 f8	 mov	 DWORD PTR _nChkErr$[ebp], eax
  00161	83 7d f8 00	 cmp	 DWORD PTR _nChkErr$[ebp], 0
  00165	74 3c		 je	 SHORT $LN15@MidiStream

; 2397 : 				{
; 2398 : 					if (nChkErr == CONVERTERR_DONE)

  00167	83 7d f8 99	 cmp	 DWORD PTR _nChkErr$[ebp], -103 ; ffffff99H
  0016b	75 11		 jne	 SHORT $LN14@MidiStream

; 2399 : 					{
; 2400 : 						// Don't include this one in the count
; 2401 : 						uCallbackStatus = STATUS_WAITINGFOREND;

  0016d	c7 05 00 00 00
	00 2c 01 00 00	 mov	 DWORD PTR _uCallbackStatus, 300 ; 0000012cH

; 2402 : 						return;

  00177	e9 21 01 00 00	 jmp	 $LN1@MidiStream

; 2403 : 					}

  0017c	eb 25		 jmp	 SHORT $LN15@MidiStream
$LN14@MidiStream:

; 2404 : 					else
; 2405 : 					{
; 2406 : 						// We're not in the main thread, so we can't call I_Error() now.
; 2407 : 						// Log the error message out, and post exit message.
; 2408 : 						CONS_Printf("MidiStreamCallback(): conversion pass failed!\n");

  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@PNIELMGN@MidiStreamCallback?$CI?$CJ?3?5conversio@
  00183	e8 00 00 00 00	 call	 _CONS_Printf
  00188	83 c4 04	 add	 esp, 4

; 2409 : 						PostMessage(hWndMain, WM_CLOSE, 0, 0);

  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	6a 10		 push	 16			; 00000010H
  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  00196	50		 push	 eax
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
  0019d	90		 npad	 1

; 2410 : 						return;

  0019e	e9 fa 00 00 00	 jmp	 $LN1@MidiStream
$LN15@MidiStream:

; 2411 : 					}
; 2412 : 				}
; 2413 : 
; 2414 : 				ciStreamBuffers[nCurrentBuffer].mhBuffer.dwBytesRecorded

  001a3	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  001aa	6b 0d 00 00 00
	00 54		 imul	 ecx, DWORD PTR _nCurrentBuffer, 84
  001b1	8b 90 48 00 00
	00		 mov	 edx, DWORD PTR _ciStreamBuffers[eax+72]
  001b7	89 91 08 00 00
	00		 mov	 DWORD PTR _ciStreamBuffers[ecx+8], edx

; 2415 : 					= ciStreamBuffers[nCurrentBuffer].dwBytesRecorded;
; 2416 : 
; 2417 : 				if ((mmrRetVal = midiStreamOut(hStream, &ciStreamBuffers[nCurrentBuffer].mhBuffer,
; 2418 : 					sizeof (MIDIHDR))) != MMSYSERR_NOERROR)

  001bd	6a 40		 push	 64			; 00000040H
  001bf	6b 05 00 00 00
	00 54		 imul	 eax, DWORD PTR _nCurrentBuffer, 84
  001c6	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  001cb	50		 push	 eax
  001cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  001d2	51		 push	 ecx
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamOut@12
  001d9	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  001dc	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  001e0	74 17		 je	 SHORT $LN16@MidiStream

; 2419 : 				{
; 2420 : 					MidiErrorMessageBox(mmrRetVal);

  001e2	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  001eb	83 c4 04	 add	 esp, 4

; 2421 : 					Mid2StreamConverterCleanup();

  001ee	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  001f3	90		 npad	 1

; 2422 : 					return;

  001f4	e9 a4 00 00 00	 jmp	 $LN1@MidiStream
$LN16@MidiStream:

; 2423 : 				}
; 2424 : 
; 2425 : 				nCurrentBuffer = (nCurrentBuffer + 1) % NUM_STREAM_BUFFERS;

  001f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _nCurrentBuffer
  001fe	83 c0 01	 add	 eax, 1
  00201	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00206	79 05		 jns	 SHORT $LN22@MidiStream
  00208	48		 dec	 eax
  00209	83 c8 fe	 or	 eax, -2			; fffffffeH
  0020c	40		 inc	 eax
$LN22@MidiStream:
  0020d	a3 00 00 00 00	 mov	 DWORD PTR _nCurrentBuffer, eax

; 2426 : 				nEmptyBuffers--;

  00212	a1 00 00 00 00	 mov	 eax, DWORD PTR _nEmptyBuffers
  00217	83 e8 01	 sub	 eax, 1
  0021a	a3 00 00 00 00	 mov	 DWORD PTR _nEmptyBuffers, eax
$LN12@MidiStream:

; 2427 : 			}
; 2428 : 
; 2429 : 			break;

  0021f	eb 7c		 jmp	 SHORT $LN2@MidiStream
$LN17@MidiStream:

; 2430 : 		case MOM_POSITIONCB:
; 2431 : 			pmh = (LPMIDIHDR)(size_t)dwParam1;

  00221	8b 45 14	 mov	 eax, DWORD PTR _dwParam1$[ebp]
  00224	89 45 f0	 mov	 DWORD PTR _pmh$[ebp], eax

; 2432 : 			pme = (MIDIEVENT *)(pmh->lpData + pmh->dwOffset);

  00227	8b 45 f0	 mov	 eax, DWORD PTR _pmh$[ebp]
  0022a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022c	8b 55 f0	 mov	 edx, DWORD PTR _pmh$[ebp]
  0022f	03 4a 1c	 add	 ecx, DWORD PTR [edx+28]
  00232	89 4d f4	 mov	 DWORD PTR _pme$[ebp], ecx

; 2433 : 			if (MIDIEVENT_TYPE(pme->dwEvent) == MIDI_CTRLCHANGE)

  00235	8b 45 f4	 mov	 eax, DWORD PTR _pme$[ebp]
  00238	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0023b	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00241	81 f9 b0 00 00
	00		 cmp	 ecx, 176		; 000000b0H
  00247	75 54		 jne	 SHORT $LN18@MidiStream

; 2434 : 			{
; 2435 : #ifdef DEBUGMIDISTREAM
; 2436 : 				if (MIDIEVENT_DATA1(pme->dwEvent) == MIDICTRL_VOLUME_LSB)
; 2437 : 				{
; 2438 : 					CONS_Printf("Got an LSB volume event\n");
; 2439 : 					PostMessage(hWndMain, WM_CLOSE, 0, 0); // can't I_Error() here
; 2440 : 					break;
; 2441 : 				}
; 2442 : #endif
; 2443 : 				// this is meant to respond to our own intention, from mid2strm.c
; 2444 : 				if (MIDIEVENT_DATA1(pme->dwEvent) != MIDICTRL_VOLUME)

  00249	8b 45 f4	 mov	 eax, DWORD PTR _pme$[ebp]
  0024c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024f	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00255	c1 e9 08	 shr	 ecx, 8
  00258	83 f9 07	 cmp	 ecx, 7
  0025b	74 02		 je	 SHORT $LN19@MidiStream

; 2445 : 					break;

  0025d	eb 3e		 jmp	 SHORT $LN2@MidiStream
$LN19@MidiStream:

; 2446 : 
; 2447 : 				// Mask off the channel number and cache the volume data byte
; 2448 : 				dwVolCache[MIDIEVENT_CHANNEL(pme->dwEvent)] = MIDIEVENT_VOLUME(pme->dwEvent);

  0025f	8b 45 f4	 mov	 eax, DWORD PTR _pme$[ebp]
  00262	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00265	81 e1 00 00 7f
	00		 and	 ecx, 8323072		; 007f0000H
  0026b	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0026e	8b 55 f4	 mov	 edx, DWORD PTR _pme$[ebp]
  00271	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00274	83 e0 0f	 and	 eax, 15			; 0000000fH
  00277	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _dwVolCache[eax*4], ecx

; 2449 : 				// call SetChannelVolume() later to adjust MIDI volume control message to our
; 2450 : 				// own current volume level.
; 2451 : 				PostMessage(hWndMain, WM_MSTREAM_UPDATEVOLUME,

  0027e	6a 00		 push	 0
  00280	8b 45 f4	 mov	 eax, DWORD PTR _pme$[ebp]
  00283	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00286	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00289	51		 push	 ecx
  0028a	68 65 04 00 00	 push	 1125			; 00000465H
  0028f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hWndMain
  00295	52		 push	 edx
  00296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16
  0029c	90		 npad	 1
$LN18@MidiStream:
$LN20@MidiStream:
$LN2@MidiStream:
$LN1@MidiStream:

; 2452 : 					MIDIEVENT_CHANNEL(pme->dwEvent), 0L);
; 2453 : 			}
; 2454 : 			break;
; 2455 : 		default:
; 2456 : 			break;
; 2457 : 	}
; 2458 : 
; 2459 : 	return;
; 2460 : }

  0029d	5f		 pop	 edi
  0029e	5e		 pop	 esi
  0029f	5b		 pop	 ebx
  002a0	8b e5		 mov	 esp, ebp
  002a2	5d		 pop	 ebp
  002a3	c2 14 00	 ret	 20			; 00000014H
_MidiStreamCallback@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _Mid2StreamFreeBuffers
_TEXT	SEGMENT
_mmrRetVal$ = -8					; size = 4
_idx$ = -4						; size = 4
_Mid2StreamFreeBuffers PROC				; COMDAT

; 2469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2470 : 	DWORD idx;
; 2471 : 	MMRESULT mmrRetVal;
; 2472 : 
; 2473 : 	if (bBuffersPrepared)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bBuffersPrepared, 0
  00010	74 52		 je	 SHORT $LN5@Mid2Stream

; 2474 : 	{
; 2475 : 		for (idx = 0; idx < NUM_STREAM_BUFFERS; idx++)

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@Mid2Stream
$LN2@Mid2Stream:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _idx$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 45 fc	 mov	 DWORD PTR _idx$[ebp], eax
$LN4@Mid2Stream:
  00024	83 7d fc 02	 cmp	 DWORD PTR _idx$[ebp], 2
  00028	73 30		 jae	 SHORT $LN3@Mid2Stream

; 2476 : 		{
; 2477 : 			if ((mmrRetVal = midiOutUnprepareHeader((HMIDIOUT)hStream,
; 2478 : 			 &ciStreamBuffers[idx].mhBuffer, sizeof (MIDIHDR))) != MMSYSERR_NOERROR)

  0002a	6a 40		 push	 64			; 00000040H
  0002c	6b 45 fc 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  00030	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  00035	50		 push	 eax
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  0003c	51		 push	 ecx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutUnprepareHeader@12
  00043	89 45 f8	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  00046	83 7d f8 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  0004a	74 0c		 je	 SHORT $LN6@Mid2Stream

; 2479 : 			{
; 2480 : 				MidiErrorMessageBox(mmrRetVal);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  00055	83 c4 04	 add	 esp, 4
$LN6@Mid2Stream:

; 2481 : 			}
; 2482 : 		}

  00058	eb c1		 jmp	 SHORT $LN2@Mid2Stream
$LN3@Mid2Stream:

; 2483 : 		bBuffersPrepared = FALSE;

  0005a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bBuffersPrepared, 0
$LN5@Mid2Stream:

; 2484 : 	}
; 2485 : 
; 2486 : 	// Don't free the stream buffers here, but rather allocate them once at startup,
; 2487 : 	// and free them at shutdown.
; 2488 : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_Mid2StreamFreeBuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _UnLoadDirectSound
_TEXT	SEGMENT
_UnLoadDirectSound PROC					; COMDAT

; 850  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 851  : 	if (!DSoundDLL)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DSoundDLL, 0
  00010	75 02		 jne	 SHORT $LN2@UnLoadDire

; 852  : 		return;

  00012	eb 21		 jmp	 SHORT $LN1@UnLoadDire
$LN2@UnLoadDire:

; 853  : 	FreeLibrary(DSoundDLL);

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSoundDLL
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00020	90		 npad	 1

; 854  : 	pfnDirectSoundCreate = NULL;

  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pfnDirectSoundCreate, 0

; 855  : 	DSoundDLL = NULL;

  0002b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DSoundDLL, 0
$LN1@UnLoadDire:

; 856  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_UnLoadDirectSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _LoadDirectSound
_TEXT	SEGMENT
_LoadDirectSound PROC					; COMDAT

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 839  : 	// load dsound.dll
; 840  : 	DSoundDLL = LoadLibraryA("DSOUND.DLL");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HDBBEELN@DSOUND?4DLL@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00014	a3 00 00 00 00	 mov	 DWORD PTR _DSoundDLL, eax

; 841  : 	if (DSoundDLL == NULL)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DSoundDLL, 0
  00020	75 04		 jne	 SHORT $LN2@LoadDirect

; 842  : 		return false;

  00022	33 c0		 xor	 eax, eax
  00024	eb 28		 jmp	 SHORT $LN1@LoadDirect
$LN2@LoadDirect:

; 843  : 	pfnDirectSoundCreate = (DSCreate)GetProcAddress(DSoundDLL, "DirectSoundCreate");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GKIGDBEH@DirectSoundCreate@
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSoundDLL
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00037	a3 00 00 00 00	 mov	 DWORD PTR _pfnDirectSoundCreate, eax

; 844  : 	if (pfnDirectSoundCreate == NULL)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pfnDirectSoundCreate, 0
  00043	75 04		 jne	 SHORT $LN3@LoadDirect

; 845  : 		return false;

  00045	33 c0		 xor	 eax, eax
  00047	eb 05		 jmp	 SHORT $LN1@LoadDirect
$LN3@LoadDirect:

; 846  : 	return true;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN1@LoadDirect:

; 847  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_LoadDirectSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _CreateInvertedSound
_TEXT	SEGMENT
_dsdata$ = -8						; size = 4
_lumpnum$ = -4						; size = 4
_id$ = 8						; size = 4
_CreateInvertedSound PROC				; COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 519  : 	lumpnum_t lumpnum;
; 520  : 	LPBYTE dsdata;
; 521  : 
; 522  : 	lumpnum = S_sfx[id].lumpnum;

  00009	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  0000d	8b 88 24 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+36]
  00013	89 4d fc	 mov	 DWORD PTR _lumpnum$[ebp], ecx

; 523  : 	if (lumpnum == LUMPERROR)

  00016	83 7d fc ff	 cmp	 DWORD PTR _lumpnum$[ebp], -1
  0001a	75 15		 jne	 SHORT $LN2@CreateInve

; 524  : 		lumpnum = S_GetSfxLumpNum(&S_sfx[id]);

  0001c	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  00020	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _S_GetSfxLumpNum
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 fc	 mov	 DWORD PTR _lumpnum$[ebp], eax
$LN2@CreateInve:

; 525  : 	dsdata = W_CacheLumpNum(lumpnum, PU_CACHE);

  00031	6a 65		 push	 101			; 00000065H
  00033	8b 45 fc	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0003c	83 c4 08	 add	 esp, 8
  0003f	89 45 f8	 mov	 DWORD PTR _dsdata$[ebp], eax

; 526  : 	return raw2DS(dsdata, S_sfx[id].length, TRUE);

  00042	6a 01		 push	 1
  00044	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  00048	8b 88 18 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+24]
  0004e	51		 push	 ecx
  0004f	8b 55 f8	 mov	 edx, DWORD PTR _dsdata$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _raw2DS
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 527  : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_CreateInvertedSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _GetFreeStackNum
_TEXT	SEGMENT
_i$ = -12						; size = 4
_lowestprihandle$ = -8					; size = 4
_lowestpri$ = -4					; size = 4
_newpriority$ = 8					; size = 4
_GetFreeStackNum PROC					; COMDAT

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 474  : 	int  lowestpri = 256,lowestprihandle = 0;

  00009	c7 45 fc 00 01
	00 00		 mov	 DWORD PTR _lowestpri$[ebp], 256 ; 00000100H
  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lowestprihandle$[ebp], 0

; 475  : 	int  i;
; 476  : 	// DirectSound can't play multiple instances of the same sound buffer
; 477  : 	// unless they are duplicated, so if the sound buffer is in use, make a duplicate
; 478  : 	for (i = 0; i < MAXSTACKSOUNDS; i++)

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@GetFreeSta
$LN2@GetFreeSta:
  00020	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetFreeSta:
  00029	83 7d f4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0002d	7d 61		 jge	 SHORT $LN3@GetFreeSta

; 479  : 	{
; 480  : 		// find a free 'playing sound slot' to use
; 481  : 		if (StackSounds[i].lpSndBuf == NULL)

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00032	c1 e0 04	 shl	 eax, 4
  00035	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _StackSounds[eax], 0
  0003c	75 07		 jne	 SHORT $LN5@GetFreeSta

; 482  : 		{
; 483  : 			//CONS_Printf("\t\tfound free slot %d\n", i);
; 484  : 			return i;

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00041	eb 69		 jmp	 SHORT $LN1@GetFreeSta

; 485  : 		}

  00043	eb 49		 jmp	 SHORT $LN9@GetFreeSta
$LN5@GetFreeSta:

; 486  : 		else if (!I_SoundIsPlaying(i)) // check for sounds that finished playing, and can be freed

  00045	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _I_SoundIsPlaying
  0004e	83 c4 04	 add	 esp, 4
  00051	85 c0		 test	 eax, eax
  00053	75 13		 jne	 SHORT $LN7@GetFreeSta

; 487  : 		{
; 488  : 			//CONS_Printf("\t\tfinished sound in slot %d\n", i);
; 489  : 			//stop sound and free the 'slot'
; 490  : 			I_StopSound(i);

  00055	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _I_StopSound
  0005e	83 c4 04	 add	 esp, 4

; 491  : 			// we can use this one since it's now freed
; 492  : 			return i;

  00061	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00064	eb 46		 jmp	 SHORT $LN1@GetFreeSta

; 493  : 		}

  00066	eb 26		 jmp	 SHORT $LN9@GetFreeSta
$LN7@GetFreeSta:

; 494  : 		else if (StackSounds[i].priority < lowestpri) //remember lowest priority sound

  00068	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	c1 e0 04	 shl	 eax, 4
  0006e	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax+8]
  00074	3b 4d fc	 cmp	 ecx, DWORD PTR _lowestpri$[ebp]
  00077	7d 15		 jge	 SHORT $LN9@GetFreeSta

; 495  : 		{
; 496  : 			lowestpri = StackSounds[i].priority;

  00079	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	c1 e0 04	 shl	 eax, 4
  0007f	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax+8]
  00085	89 4d fc	 mov	 DWORD PTR _lowestpri$[ebp], ecx

; 497  : 			lowestprihandle = i;

  00088	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0008b	89 45 f8	 mov	 DWORD PTR _lowestprihandle$[ebp], eax
$LN9@GetFreeSta:

; 498  : 		}
; 499  : 	}

  0008e	eb 90		 jmp	 SHORT $LN2@GetFreeSta
$LN3@GetFreeSta:

; 500  : 
; 501  : 	// the maximum of sounds playing at the same time is reached, if we have at least
; 502  : 	// one sound playing with a lower priority, stop it and replace it with the new one
; 503  : 
; 504  : 	//CONS_Printf("\t\tall slots occupied..\n");
; 505  : 	if (newpriority >= lowestpri)

  00090	8b 45 08	 mov	 eax, DWORD PTR _newpriority$[ebp]
  00093	3b 45 fc	 cmp	 eax, DWORD PTR _lowestpri$[ebp]
  00096	7c 11		 jl	 SHORT $LN10@GetFreeSta

; 506  : 	{
; 507  : 		I_StopSound(lowestprihandle);

  00098	8b 45 f8	 mov	 eax, DWORD PTR _lowestprihandle$[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _I_StopSound
  000a1	83 c4 04	 add	 esp, 4

; 508  : 		return lowestprihandle;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _lowestprihandle$[ebp]
  000a7	eb 03		 jmp	 SHORT $LN1@GetFreeSta
$LN10@GetFreeSta:

; 509  : 		//CONS_Printf(" kicking out lowest priority slot: %d pri: %d, my priority: %d\n",
; 510  : 		//             handle, lowestpri, priority);
; 511  : 	}
; 512  : 
; 513  : 	return -1;

  000a9	83 c8 ff	 or	 eax, -1
$LN1@GetFreeSta:

; 514  : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_GetFreeStackNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_UpdateSoundPanning
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_lpSnd$ = 8						; size = 4
_sep$ = 12						; size = 4
_I_UpdateSoundPanning PROC				; COMDAT

; 464  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 465  : 	HRESULT hr;
; 466  : 	hr = IDirectSoundBuffer_SetPan(lpSnd, (sep * DSBPAN_RANGE)/SEP_RANGE - DSBPAN_RIGHT);

  00009	69 45 0c 20 4e
	00 00		 imul	 eax, DWORD PTR _sep$[ebp], 20000
  00010	99		 cdq
  00011	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00017	03 c2		 add	 eax, edx
  00019	c1 f8 08	 sar	 eax, 8
  0001c	2d 10 27 00 00	 sub	 eax, 10000		; 00002710H
  00021	50		 push	 eax
  00022	8b 45 08	 mov	 eax, DWORD PTR _lpSnd$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpSnd$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0002e	ff d0		 call	 eax
  00030	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 467  : 	//if (FAILED(hr))
; 468  : 	//    CONS_Printf("SetPan FAILED for sep %d pan %d\n", sep, (sep * DSBPAN_RANGE)/SEP_RANGE - DSBPAN_RIGHT);
; 469  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_I_UpdateSoundPanning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_UpdateSoundVolume
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_lpSnd$ = 8						; size = 4
_volume$ = 12						; size = 4
_I_UpdateSoundVolume PROC				; COMDAT

; 447  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 448  : 	HRESULT hr;
; 449  : 	volume = (volume * ((DSBVOLUME_MAX-DSBVOLUME_MIN)/4)) / 256 +

  00009	69 45 0c c4 09
	00 00		 imul	 eax, DWORD PTR _volume$[ebp], 2500
  00010	99		 cdq
  00011	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00017	03 c2		 add	 eax, edx
  00019	c1 f8 08	 sar	 eax, 8
  0001c	2d c4 09 00 00	 sub	 eax, 2500		; 000009c4H
  00021	89 45 0c	 mov	 DWORD PTR _volume$[ebp], eax

; 450  : 	         (DSBVOLUME_MAX - ((DSBVOLUME_MAX-DSBVOLUME_MIN)/4));
; 451  : 	hr = IDirectSoundBuffer_SetVolume(lpSnd, volume);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _volume$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _lpSnd$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _lpSnd$[ebp]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00034	ff d1		 call	 ecx
  00036	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 452  : 	//if (FAILED(hr))
; 453  : 	//    CONS_Printf("\2SetVolume FAILED\n");
; 454  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_I_UpdateSoundVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _raw2DS
_TEXT	SEGMENT
_dsbuffer$ = -52					; size = 4
_dsbdesc$ = -48						; size = 20
_wfm$ = -28						; size = 18
_hr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dsdata$ = 8						; size = 4
_len$ = 12						; size = 4
_invert$ = 16						; size = 4
_raw2DS	PROC						; COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 281  : 	HRESULT             hr;
; 282  : 	WAVEFORMATEX        wfm;
; 283  : 	DSBUFFERDESC        dsbdesc;
; 284  : 	LPDIRECTSOUNDBUFFER dsbuffer;
; 285  : 
; 286  : 	// initialise WAVEFORMATEX structure describing the wave format
; 287  : 	ZeroMemory(&wfm, sizeof (WAVEFORMATEX));

  00013	6a 12		 push	 18			; 00000012H
  00015	6a 00		 push	 0
  00017	8d 45 e4	 lea	 eax, DWORD PTR _wfm$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  : 	wfm.wFormatTag = WAVE_FORMAT_PCM;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	66 89 45 e4	 mov	 WORD PTR _wfm$[ebp], ax

; 289  : 	wfm.nChannels = 1;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	66 89 45 e6	 mov	 WORD PTR _wfm$[ebp+2], ax

; 290  : 	wfm.nSamplesPerSec = (dsdata[3]<<8)+dsdata[2];      //mostly 11025, but some at 22050.

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	6b c8 03	 imul	 ecx, eax, 3
  0003d	8b 55 08	 mov	 edx, DWORD PTR _dsdata$[ebp]
  00040	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00044	c1 e0 08	 shl	 eax, 8
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	d1 e1		 shl	 ecx, 1
  0004e	8b 55 08	 mov	 edx, DWORD PTR _dsdata$[ebp]
  00051	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00055	03 c1		 add	 eax, ecx
  00057	89 45 e8	 mov	 DWORD PTR _wfm$[ebp+4], eax

; 291  : 	wfm.wBitsPerSample = 8;

  0005a	b8 08 00 00 00	 mov	 eax, 8
  0005f	66 89 45 f2	 mov	 WORD PTR _wfm$[ebp+14], ax

; 292  : 	wfm.nBlockAlign = (WORD)(wfm.wBitsPerSample / 8 * wfm.nChannels);

  00063	0f b7 45 f2	 movzx	 eax, WORD PTR _wfm$[ebp+14]
  00067	99		 cdq
  00068	83 e2 07	 and	 edx, 7
  0006b	03 c2		 add	 eax, edx
  0006d	c1 f8 03	 sar	 eax, 3
  00070	0f b7 4d e6	 movzx	 ecx, WORD PTR _wfm$[ebp+2]
  00074	0f af c1	 imul	 eax, ecx
  00077	66 89 45 f0	 mov	 WORD PTR _wfm$[ebp+12], ax

; 293  : 	wfm.nAvgBytesPerSec = wfm.nSamplesPerSec * wfm.nBlockAlign;

  0007b	0f b7 45 f0	 movzx	 eax, WORD PTR _wfm$[ebp+12]
  0007f	0f af 45 e8	 imul	 eax, DWORD PTR _wfm$[ebp+4]
  00083	89 45 ec	 mov	 DWORD PTR _wfm$[ebp+8], eax

; 294  : 
; 295  : 	// Set up DSBUFFERDESC structure.
; 296  : 	ZeroMemory(&dsbdesc, sizeof (DSBUFFERDESC));

  00086	6a 14		 push	 20			; 00000014H
  00088	6a 00		 push	 0
  0008a	8d 45 d0	 lea	 eax, DWORD PTR _dsbdesc$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _memset
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 	dsbdesc.dwSize = sizeof (DSBUFFERDESC);

  00096	c7 45 d0 14 00
	00 00		 mov	 DWORD PTR _dsbdesc$[ebp], 20 ; 00000014H

; 298  : /*	dsbdesc.dwFlags = DSBCAPS_CTRLPAN |
; 299  : 	                  DSBCAPS_CTRLVOLUME |
; 300  : 	                  DSBCAPS_STICKYFOCUS |
; 301  : 	                  //DSBCAPS_LOCSOFTWARE |
; 302  : 	                  DSBCAPS_STATIC
; 303  : 	                  | DSBCAPS_CTRLFREQUENCY;    // This one for pitching
; 304  : */
; 305  : 	dsbdesc.dwFlags = sound_buffer_flags;

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _sound_buffer_flags
  000a2	89 45 d4	 mov	 DWORD PTR _dsbdesc$[ebp+4], eax

; 306  : 	dsbdesc.dwBufferBytes = (DWORD)(len-8);

  000a5	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  000a8	83 e8 08	 sub	 eax, 8
  000ab	89 45 d8	 mov	 DWORD PTR _dsbdesc$[ebp+8], eax

; 307  : 	dsbdesc.lpwfxFormat = &wfm; // pointer to WAVEFORMATEX structure

  000ae	8d 45 e4	 lea	 eax, DWORD PTR _wfm$[ebp]
  000b1	89 45 e0	 mov	 DWORD PTR _dsbdesc$[ebp+16], eax

; 308  : 
; 309  : 	// Create the sound buffer
; 310  : 	hr = IDirectSound_CreateSoundBuffer(DSnd, &dsbdesc, &dsbuffer, NULL);

  000b4	6a 00		 push	 0
  000b6	8d 45 cc	 lea	 eax, DWORD PTR _dsbuffer$[ebp]
  000b9	50		 push	 eax
  000ba	8d 4d d0	 lea	 ecx, DWORD PTR _dsbdesc$[ebp]
  000bd	51		 push	 ecx
  000be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DSnd
  000c4	52		 push	 edx
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000cf	ff d2		 call	 edx
  000d1	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 311  : 
; 312  : 	if (hr == DSERR_CONTROLUNAVAIL)

  000d4	81 7d f8 1e 00
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005401570 ; 8878001eH
  000db	75 42		 jne	 SHORT $LN2@raw2DS

; 313  : 	{
; 314  : 		CONS_Printf("\tSoundBufferCreate error - a buffer control is not available.\n\tTrying to disable frequency control.\n");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@IHPLDPHJ@?7SoundBufferCreate?5error?5?9?5a?5bu@
  000e2	e8 00 00 00 00	 call	 _CONS_Printf
  000e7	83 c4 04	 add	 esp, 4

; 315  : 
; 316  : 		sound_buffer_flags &= ~DSBCAPS_CTRLFREQUENCY;

  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _sound_buffer_flags
  000ef	83 e0 df	 and	 eax, -33		; ffffffdfH
  000f2	a3 00 00 00 00	 mov	 DWORD PTR _sound_buffer_flags, eax

; 317  : 		dsbdesc.dwFlags = sound_buffer_flags;

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _sound_buffer_flags
  000fc	89 45 d4	 mov	 DWORD PTR _dsbdesc$[ebp+4], eax

; 318  : 
; 319  : 		hr = IDirectSound_CreateSoundBuffer(DSnd, &dsbdesc, &dsbuffer, NULL);

  000ff	6a 00		 push	 0
  00101	8d 45 cc	 lea	 eax, DWORD PTR _dsbuffer$[ebp]
  00104	50		 push	 eax
  00105	8d 4d d0	 lea	 ecx, DWORD PTR _dsbdesc$[ebp]
  00108	51		 push	 ecx
  00109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DSnd
  0010f	52		 push	 edx
  00110	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  00115	8b 08		 mov	 ecx, DWORD PTR [eax]
  00117	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0011a	ff d2		 call	 edx
  0011c	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$LN2@raw2DS:

; 320  : 	}
; 321  : 
; 322  : 	if (FAILED(hr))

  0011f	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00123	7d 1a		 jge	 SHORT $LN3@raw2DS

; 323  : 		I_Error("CreateSoundBuffer() FAILED: %s\n", DXErrorToString(hr));

  00125	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _DXErrorToString
  0012e	83 c4 04	 add	 esp, 4
  00131	50		 push	 eax
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HABLBEKB@CreateSoundBuffer?$CI?$CJ?5FAILED?3?5?$CFs?6@
  00137	e8 00 00 00 00	 call	 _I_Error
  0013c	83 c4 08	 add	 esp, 8
$LN3@raw2DS:

; 324  : 
; 325  : #ifdef SURROUND
; 326  : 	if (invert)

  0013f	83 7d 10 00	 cmp	 DWORD PTR _invert$[ebp], 0
  00143	74 19		 je	 SHORT $LN4@raw2DS

; 327  : 		// just invert a sound data for producing the surround sound
; 328  : 		CopyAndInvertSoundData(dsbuffer, (LPBYTE)dsdata + 8, dsbdesc.dwBufferBytes);

  00145	8b 45 d8	 mov	 eax, DWORD PTR _dsbdesc$[ebp+8]
  00148	50		 push	 eax
  00149	8b 4d 08	 mov	 ecx, DWORD PTR _dsdata$[ebp]
  0014c	83 c1 08	 add	 ecx, 8
  0014f	51		 push	 ecx
  00150	8b 55 cc	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 _CopyAndInvertSoundData
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015c	eb 17		 jmp	 SHORT $LN5@raw2DS
$LN4@raw2DS:

; 329  : 	else
; 330  : 		// Do a normal operation
; 331  : #endif
; 332  : 	// fill the DirectSoundBuffer waveform data
; 333  : 	CopySoundData(dsbuffer, (LPBYTE)dsdata + 8, dsbdesc.dwBufferBytes);

  0015e	8b 45 d8	 mov	 eax, DWORD PTR _dsbdesc$[ebp+8]
  00161	50		 push	 eax
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _dsdata$[ebp]
  00165	83 c1 08	 add	 ecx, 8
  00168	51		 push	 ecx
  00169	8b 55 cc	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  0016c	52		 push	 edx
  0016d	e8 00 00 00 00	 call	 _CopySoundData
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@raw2DS:

; 334  : 
; 335  : 	return dsbuffer;

  00175	8b 45 cc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]

; 336  : }

  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017e	33 cd		 xor	 ecx, ebp
  00180	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_raw2DS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _CopyAndInvertSoundData
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_dwBytes2$ = -16					; size = 4
_lpvAudio2$ = -12					; size = 4
_dwBytes1$ = -8						; size = 4
_lpvAudio1$ = -4					; size = 4
_dsbuffer$ = 8						; size = 4
_data$ = 12						; size = 4
_length$ = 16						; size = 4
_CopyAndInvertSoundData PROC				; COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 222  : 	LPVOID  lpvAudio1 = NULL; // receives address of lock start

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpvAudio1$[ebp], 0

; 223  : 	DWORD   dwBytes1 = 0;     // receives number of bytes locked

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwBytes1$[ebp], 0

; 224  : 	LPVOID  lpvAudio2 = NULL;

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lpvAudio2$[ebp], 0

; 225  : 	DWORD   dwBytes2 = 0;

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwBytes2$[ebp], 0

; 226  : 	HRESULT hr;
; 227  : 
; 228  : 	// Obtain memory address of write block.
; 229  : 	hr = IDirectSoundBuffer_Lock(dsbuffer, 0, length, &lpvAudio1, &dwBytes1, &lpvAudio2, &dwBytes2, 0);

  00025	6a 00		 push	 0
  00027	8d 45 f0	 lea	 eax, DWORD PTR _dwBytes2$[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR _lpvAudio2$[ebp]
  0002e	51		 push	 ecx
  0002f	8d 55 f8	 lea	 edx, DWORD PTR _dwBytes1$[ebp]
  00032	52		 push	 edx
  00033	8d 45 fc	 lea	 eax, DWORD PTR _lpvAudio1$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  0003a	51		 push	 ecx
  0003b	6a 00		 push	 0
  0003d	8b 55 08	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  00040	52		 push	 edx
  00041	8b 45 08	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00049	ff d2		 call	 edx
  0004b	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 230  : 
; 231  : 	// If DSERR_BUFFERLOST is returned, restore and retry lock.
; 232  : 	if (hr == DSERR_BUFFERLOST)

  0004e	81 7d ec 96 00
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005401450 ; 88780096H
  00055	0f 85 84 00 00
	00		 jne	 $LN2@CopyAndInv

; 233  : 	{
; 234  : 		hr = IDirectSoundBuffer_Restore(dsbuffer);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00067	ff d0		 call	 eax
  00069	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 235  : 		if (FAILED(hr))

  0006c	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00070	7d 1e		 jge	 SHORT $LN4@CopyAndInv

; 236  : 			I_Error("CopyAndInvert: Restore fail on %p, %s\n",dsbuffer,DXErrorToString(hr));

  00072	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _DXErrorToString
  0007b	83 c4 04	 add	 esp, 4
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00082	51		 push	 ecx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FOLMDOGH@CopyAndInvert?3?5Restore?5fail?5on?5@
  00088	e8 00 00 00 00	 call	 _I_Error
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CopyAndInv:

; 237  : 		hr = IDirectSoundBuffer_Lock(dsbuffer, 0, length, &lpvAudio1, &dwBytes1, &lpvAudio2, &dwBytes2, 0);

  00090	6a 00		 push	 0
  00092	8d 45 f0	 lea	 eax, DWORD PTR _dwBytes2$[ebp]
  00095	50		 push	 eax
  00096	8d 4d f4	 lea	 ecx, DWORD PTR _lpvAudio2$[ebp]
  00099	51		 push	 ecx
  0009a	8d 55 f8	 lea	 edx, DWORD PTR _dwBytes1$[ebp]
  0009d	52		 push	 edx
  0009e	8d 45 fc	 lea	 eax, DWORD PTR _lpvAudio1$[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  000a5	51		 push	 ecx
  000a6	6a 00		 push	 0
  000a8	8b 55 08	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 08	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000b4	ff d2		 call	 edx
  000b6	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 238  : 		if (FAILED(hr))

  000b9	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000bd	7d 1e		 jge	 SHORT $LN5@CopyAndInv

; 239  : 			I_Error("CopyAndInvert: Lock fail(2) on %p, %s\n",dsbuffer,DXErrorToString(hr));

  000bf	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _DXErrorToString
  000c8	83 c4 04	 add	 esp, 4
  000cb	50		 push	 eax
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000cf	51		 push	 ecx
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@EHALMPO@CopyAndInvert?3?5Lock?5fail?$CI2?$CJ?5on?5@
  000d5	e8 00 00 00 00	 call	 _I_Error
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CopyAndInv:

; 240  : 	} else if (FAILED(hr))

  000dd	eb 24		 jmp	 SHORT $LN6@CopyAndInv
$LN2@CopyAndInv:
  000df	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e3	7d 1e		 jge	 SHORT $LN6@CopyAndInv

; 241  : 			I_Error("CopyAndInvetrt: Lock fail(1) on %p, %s\n",dsbuffer,DXErrorToString(hr));

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _DXErrorToString
  000ee	83 c4 04	 add	 esp, 4
  000f1	50		 push	 eax
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000f5	51		 push	 ecx
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MCKAOOKL@CopyAndInvetrt?3?5Lock?5fail?$CI1?$CJ?5on@
  000fb	e8 00 00 00 00	 call	 _I_Error
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CopyAndInv:

; 242  : 
; 243  : 	// copy wave data into the buffer (note: dwBytes1 should equal to dsbdesc->dwBufferBytes ...)
; 244  : 	CopyAndInvertMemory(lpvAudio1, data, dwBytes1);

  00103	8b 45 f8	 mov	 eax, DWORD PTR _dwBytes1$[ebp]
  00106	50		 push	 eax
  00107	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0010a	51		 push	 ecx
  0010b	8b 55 fc	 mov	 edx, DWORD PTR _lpvAudio1$[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 _CopyAndInvertMemory
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 245  : 
; 246  : 	if (dwBytes2 && lpvAudio2)

  00117	83 7d f0 00	 cmp	 DWORD PTR _dwBytes2$[ebp], 0
  0011b	74 1d		 je	 SHORT $LN7@CopyAndInv
  0011d	83 7d f4 00	 cmp	 DWORD PTR _lpvAudio2$[ebp], 0
  00121	74 17		 je	 SHORT $LN7@CopyAndInv

; 247  : 		CopyAndInvertMemory(lpvAudio2, data+dwBytes1, dwBytes2);

  00123	8b 45 f0	 mov	 eax, DWORD PTR _dwBytes2$[ebp]
  00126	50		 push	 eax
  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0012a	03 4d f8	 add	 ecx, DWORD PTR _dwBytes1$[ebp]
  0012d	51		 push	 ecx
  0012e	8b 55 f4	 mov	 edx, DWORD PTR _lpvAudio2$[ebp]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _CopyAndInvertMemory
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CopyAndInv:

; 248  : 
; 249  : 	hr = IDirectSoundBuffer_Unlock(dsbuffer, lpvAudio1, dwBytes1, lpvAudio2, dwBytes2);

  0013a	8b 45 f0	 mov	 eax, DWORD PTR _dwBytes2$[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d f4	 mov	 ecx, DWORD PTR _lpvAudio2$[ebp]
  00141	51		 push	 ecx
  00142	8b 55 f8	 mov	 edx, DWORD PTR _dwBytes1$[ebp]
  00145	52		 push	 edx
  00146	8b 45 fc	 mov	 eax, DWORD PTR _lpvAudio1$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  0014d	51		 push	 ecx
  0014e	8b 55 08	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  00151	8b 02		 mov	 eax, DWORD PTR [edx]
  00153	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00156	ff d1		 call	 ecx
  00158	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 250  : 	if (FAILED (hr))

  0015b	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015f	7d 1e		 jge	 SHORT $LN8@CopyAndInv

; 251  : 		I_Error("CopyAndInvert: Unlock fail on %p, %s\n",dsbuffer,DXErrorToString(hr));

  00161	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _DXErrorToString
  0016a	83 c4 04	 add	 esp, 4
  0016d	50		 push	 eax
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00171	51		 push	 ecx
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FJCEPHFJ@CopyAndInvert?3?5Unlock?5fail?5on?5?$CF@
  00177	e8 00 00 00 00	 call	 _I_Error
  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CopyAndInv:

; 252  : 
; 253  : 	return false;

  0017f	33 c0		 xor	 eax, eax

; 254  : }

  00181	5f		 pop	 edi
  00182	5e		 pop	 esi
  00183	5b		 pop	 ebx
  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
_CopyAndInvertSoundData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _CopyAndInvertMemory
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_bytes$ = 16						; size = 4
_CopyAndInvertMemory PROC				; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 187  : #ifdef _X86_
; 188  : #ifdef __GNUC__
; 189  : 	__asm__("1:;lodsb;neg %%al;stosb;loop 1b;"::"c"(bytes),"D"(dest),"S"(src): "memory","cc");
; 190  : #elif defined (_MSC_VER)
; 191  : 	_asm
; 192  : 	{
; 193  : 		push esi

  00009	56		 push	 esi

; 194  : 		push edi

  0000a	57		 push	 edi

; 195  : 		push ecx

  0000b	51		 push	 ecx

; 196  : 		mov ecx,bytes

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _bytes$[ebp]

; 197  : 		mov esi,src

  0000f	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]

; 198  : 		mov edi,dest

  00012	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]
$a$3:

; 199  : a:
; 200  : 		lodsb

  00015	ac		 lodsb

; 201  : 		neg  al

  00016	f6 d8		 neg	 al

; 202  : 		stosb

  00018	aa		 stosb

; 203  : 		loop a

  00019	e2 fa		 loop	 $a$3

; 204  : 		pop ecx

  0001b	59		 pop	 ecx

; 205  : 		pop edi

  0001c	5f		 pop	 edi

; 206  : 		pop esi

  0001d	5e		 pop	 esi

; 207  : 	}
; 208  : #endif
; 209  : #else
; 210  : 	while (bytes)
; 211  : 	{
; 212  : 		*dest = 0xFF - *src;
; 213  : 		bytes--;
; 214  : 	}
; 215  : #endif
; 216  : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_CopyAndInvertMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _CopySoundData
_TEXT	SEGMENT
_hr$ = -20						; size = 4
_dwBytes2$ = -16					; size = 4
_lpvAudio2$ = -12					; size = 4
_dwBytes1$ = -8						; size = 4
_lpvAudio1$ = -4					; size = 4
_dsbuffer$ = 8						; size = 4
_data$ = 12						; size = 4
_length$ = 16						; size = 4
_CopySoundData PROC					; COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 144  : 	LPVOID  lpvAudio1;              // receives address of lock start
; 145  : 	DWORD   dwBytes1;               // receives number of bytes locked
; 146  : 	LPVOID  lpvAudio2;              // receives address of lock start
; 147  : 	DWORD   dwBytes2;               // receives number of bytes locked
; 148  : 	HRESULT hr;
; 149  : 
; 150  : 	// Obtain memory address of write block.
; 151  : 	hr = IDirectSoundBuffer_Lock(dsbuffer, 0, length, &lpvAudio1, &dwBytes1, &lpvAudio2, &dwBytes2, 0);

  00009	6a 00		 push	 0
  0000b	8d 45 f0	 lea	 eax, DWORD PTR _dwBytes2$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d f4	 lea	 ecx, DWORD PTR _lpvAudio2$[ebp]
  00012	51		 push	 ecx
  00013	8d 55 f8	 lea	 edx, DWORD PTR _dwBytes1$[ebp]
  00016	52		 push	 edx
  00017	8d 45 fc	 lea	 eax, DWORD PTR _lpvAudio1$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	8b 55 08	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  00024	52		 push	 edx
  00025	8b 45 08	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0002d	ff d2		 call	 edx
  0002f	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 152  : 
; 153  : 	// If DSERR_BUFFERLOST is returned, restore and retry lock.
; 154  : 	if (hr == DSERR_BUFFERLOST)

  00032	81 7d ec 96 00
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005401450 ; 88780096H
  00039	0f 85 84 00 00
	00		 jne	 $LN2@CopySoundD

; 155  : 	{
; 156  : 		hr = IDirectSoundBuffer_Restore(dsbuffer);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0004b	ff d0		 call	 eax
  0004d	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 157  : 		if (FAILED(hr))

  00050	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00054	7d 1e		 jge	 SHORT $LN4@CopySoundD

; 158  : 			I_Error("Restore fail on %p, %s\n",dsbuffer,DXErrorToString(hr));

  00056	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _DXErrorToString
  0005f	83 c4 04	 add	 esp, 4
  00062	50		 push	 eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00066	51		 push	 ecx
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LMFLOHGH@Restore?5fail?5on?5?$CFp?0?5?$CFs?6@
  0006c	e8 00 00 00 00	 call	 _I_Error
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CopySoundD:

; 159  : 		hr = IDirectSoundBuffer_Lock(dsbuffer, 0, length, &lpvAudio1, &dwBytes1, &lpvAudio2, &dwBytes2, 0);

  00074	6a 00		 push	 0
  00076	8d 45 f0	 lea	 eax, DWORD PTR _dwBytes2$[ebp]
  00079	50		 push	 eax
  0007a	8d 4d f4	 lea	 ecx, DWORD PTR _lpvAudio2$[ebp]
  0007d	51		 push	 ecx
  0007e	8d 55 f8	 lea	 edx, DWORD PTR _dwBytes1$[ebp]
  00081	52		 push	 edx
  00082	8d 45 fc	 lea	 eax, DWORD PTR _lpvAudio1$[ebp]
  00085	50		 push	 eax
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  00089	51		 push	 ecx
  0008a	6a 00		 push	 0
  0008c	8b 55 08	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  0008f	52		 push	 edx
  00090	8b 45 08	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00098	ff d2		 call	 edx
  0009a	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 160  : 		if (FAILED(hr))

  0009d	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a1	7d 1e		 jge	 SHORT $LN5@CopySoundD

; 161  : 			I_Error("Lock fail(2) on %p, %s\n",dsbuffer,DXErrorToString(hr));

  000a3	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _DXErrorToString
  000ac	83 c4 04	 add	 esp, 4
  000af	50		 push	 eax
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000b3	51		 push	 ecx
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@OGJHGFPO@Lock?5fail?$CI2?$CJ?5on?5?$CFp?0?5?$CFs?6@
  000b9	e8 00 00 00 00	 call	 _I_Error
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CopySoundD:

; 162  : 	}

  000c1	eb 24		 jmp	 SHORT $LN6@CopySoundD
$LN2@CopySoundD:

; 163  : 	else
; 164  : 		if (FAILED(hr))

  000c3	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000c7	7d 1e		 jge	 SHORT $LN6@CopySoundD

; 165  : 			I_Error("Lock fail(1) on %p, %s\n",dsbuffer,DXErrorToString(hr));

  000c9	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _DXErrorToString
  000d2	83 c4 04	 add	 esp, 4
  000d5	50		 push	 eax
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000d9	51		 push	 ecx
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JKPGEACF@Lock?5fail?$CI1?$CJ?5on?5?$CFp?0?5?$CFs?6@
  000df	e8 00 00 00 00	 call	 _I_Error
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CopySoundD:

; 166  : 
; 167  : 	// copy wave data into the buffer (note: dwBytes1 should equal to dsbdesc->dwBufferBytes ...)
; 168  : 	CopyMemory(lpvAudio1, data, dwBytes1);

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _dwBytes1$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 55 fc	 mov	 edx, DWORD PTR _lpvAudio1$[ebp]
  000f2	52		 push	 edx
  000f3	e8 00 00 00 00	 call	 _memcpy
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 169  : 
; 170  : 	if (dwBytes2 && lpvAudio2)

  000fb	83 7d f0 00	 cmp	 DWORD PTR _dwBytes2$[ebp], 0
  000ff	74 1d		 je	 SHORT $LN7@CopySoundD
  00101	83 7d f4 00	 cmp	 DWORD PTR _lpvAudio2$[ebp], 0
  00105	74 17		 je	 SHORT $LN7@CopySoundD

; 171  : 		CopyMemory(lpvAudio2, data+dwBytes1, dwBytes2);

  00107	8b 45 f0	 mov	 eax, DWORD PTR _dwBytes2$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0010e	03 4d f8	 add	 ecx, DWORD PTR _dwBytes1$[ebp]
  00111	51		 push	 ecx
  00112	8b 55 f4	 mov	 edx, DWORD PTR _lpvAudio2$[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 _memcpy
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CopySoundD:

; 172  : 
; 173  : 	// finally, unlock the buffer
; 174  : 	hr = IDirectSoundBuffer_Unlock(dsbuffer, lpvAudio1, dwBytes1, lpvAudio2, dwBytes2);

  0011e	8b 45 f0	 mov	 eax, DWORD PTR _dwBytes2$[ebp]
  00121	50		 push	 eax
  00122	8b 4d f4	 mov	 ecx, DWORD PTR _lpvAudio2$[ebp]
  00125	51		 push	 ecx
  00126	8b 55 f8	 mov	 edx, DWORD PTR _dwBytes1$[ebp]
  00129	52		 push	 edx
  0012a	8b 45 fc	 mov	 eax, DWORD PTR _lpvAudio1$[ebp]
  0012d	50		 push	 eax
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00131	51		 push	 ecx
  00132	8b 55 08	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  00135	8b 02		 mov	 eax, DWORD PTR [edx]
  00137	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0013a	ff d1		 call	 ecx
  0013c	89 45 ec	 mov	 DWORD PTR _hr$[ebp], eax

; 175  : 
; 176  : 	if (FAILED(hr))

  0013f	83 7d ec 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00143	7d 1e		 jge	 SHORT $LN8@CopySoundD

; 177  : 		I_Error("Unlock fail on %p, %s\n",dsbuffer,DXErrorToString(hr));

  00145	8b 45 ec	 mov	 eax, DWORD PTR _hr$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _DXErrorToString
  0014e	83 c4 04	 add	 esp, 4
  00151	50		 push	 eax
  00152	8b 4d 08	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00155	51		 push	 ecx
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GIHODJA@Unlock?5fail?5on?5?$CFp?0?5?$CFs?6@
  0015b	e8 00 00 00 00	 call	 _I_Error
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CopySoundD:

; 178  : 
; 179  : 	return true;

  00163	b8 01 00 00 00	 mov	 eax, 1

; 180  : }

  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
_CopySoundData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_SetDigMusicVolume
_TEXT	SEGMENT
_volume$ = 8						; size = 4
_I_SetDigMusicVolume PROC				; COMDAT

; 1555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1556 : #ifdef FMODSOUND
; 1557 : 	if (volume != -1)
; 1558 : 		fmodvol = (volume<<3)+(volume>>2);
; 1559 : 	if (!nodigimusic)
; 1560 : 	{
; 1561 : 		if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_CHANNEL_ALLOC && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER)
; 1562 : 			if (devparm) I_OutputMsg("FMOD(Volume,Unknown): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1563 : 		if (mod)
; 1564 : 		{
; 1565 : 			if (fmod375->FMUSIC_GetType(mod) != FMUSIC_TYPE_NONE)
; 1566 : 			{
; 1567 : 				if (!fmod375->FMUSIC_SetMasterVolume(mod, fmodvol) && devparm)
; 1568 : 					I_OutputMsg("FMOD(Volume,FMUSIC_SetMasterVolume): %s\n",
; 1569 : 						FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1570 : 			}
; 1571 : 			else if (devparm)
; 1572 : 				I_OutputMsg("FMOD(Volume,FMUSIC_GetType): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1573 : 		}
; 1574 : 		if (fmus)
; 1575 : 		{
; 1576 : 			if (!fmod375->FSOUND_SetVolume(fsoundchannel, fmodvol))
; 1577 : 				if (devparm) I_OutputMsg("FMOD(Volume,FSOUND_SetVolume): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1578 : 		}
; 1579 : 	}
; 1580 : #else
; 1581 : 	UNREFERENCED_PARAMETER(volume);
; 1582 : #endif
; 1583 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_I_SetDigMusicVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_StopDigSong
_TEXT	SEGMENT
_I_StopDigSong PROC					; COMDAT

; 1791 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1792 : #ifdef FMODSOUND
; 1793 : 	if (!nodigimusic)
; 1794 : 	{
; 1795 : 		if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_INVALID_PARAM && fmod375->FSOUND_GetError() != FMOD_ERR_CHANNEL_ALLOC && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER)
; 1796 : 			if (devparm) I_OutputMsg("FMOD(Stop,Unknown): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1797 : 		if (mod)
; 1798 : 		{
; 1799 : 			if (fmod375->FMUSIC_IsPlaying(mod))
; 1800 : 			{
; 1801 : 				if (!fmod375->FMUSIC_StopSong(mod))
; 1802 : 					if (devparm) I_OutputMsg("FMOD(Stop,FMUSIC_StopSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1803 : 			}
; 1804 : 		}
; 1805 : 		if (fmus)
; 1806 : 		{
; 1807 : 			if (fmod375->FSOUND_IsPlaying(fsoundchannel))
; 1808 : 			{
; 1809 : 				if (!fmod375->FSOUND_Stream_Stop(fmus))
; 1810 : 					if (devparm) I_OutputMsg("FMOD(Stop,FSOUND_Stream_Stop): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1811 : 			}
; 1812 : 		}
; 1813 : 		//if (!fmod375->FSOUND_StopSound(FSOUND_ALL))
; 1814 : 			//if (fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER) CONS_Printf("FMOD(Stop,FSOUND_StopSound): %s\n", fmod375->FMOD_ErrorString(FSOUND_GetError()));
; 1815 : 		//fmod375->FMUSIC_StopAllSongs();
; 1816 : 			//if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER) CONS_Printf("FMOD(Stop,FMUSIC_StopAllSongs): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1817 : 	}
; 1818 : #endif
; 1819 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_I_StopDigSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_StartDigSong
_TEXT	SEGMENT
_musicname$ = 8						; size = 4
_looping$ = 12						; size = 4
_I_StartDigSong PROC					; COMDAT

; 1902 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1903 : #ifdef FMODSOUND
; 1904 : 	char lumpname[9];
; 1905 : 	static void *data = NULL;
; 1906 : 	size_t len;
; 1907 : 	lumpnum_t lumpnum = LUMPERROR;
; 1908 : 
; 1909 : 	if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_CHANNEL_ALLOC &&
; 1910 : 	    fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER && fmod375->FSOUND_GetError() != FMOD_ERR_INVALID_PARAM)
; 1911 : 		if (devparm) I_OutputMsg("FMOD(Start,Unknown): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1912 : 
; 1913 : 	if (fmus)
; 1914 : 	{
; 1915 : 		if (fmod375->FSOUND_IsPlaying(fsoundchannel))
; 1916 : 			if (!fmod375->FSOUND_Stream_Stop(fmus))
; 1917 : 				if (devparm) I_OutputMsg("FMOD(Start,FSOUND_Stream_Stop): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1918 : 		if (!fmod375->FSOUND_Stream_Close(fmus))
; 1919 : 			if (devparm) I_OutputMsg("FMOD(Start,FSOUND_Stream_Close): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1920 : 		fsoundchannel = -1;
; 1921 : 		fmus = NULL;
; 1922 : 	}
; 1923 : 	if (mod)
; 1924 : 	{
; 1925 : 		if (fmod375->FMUSIC_IsPlaying(mod))
; 1926 : 			if (!fmod375->FMUSIC_StopSong(mod))
; 1927 : 				if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_StopSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1928 : 		if (!fmod375->FMUSIC_FreeSong(mod))
; 1929 : 			if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_FreeSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1930 : 		mod = NULL;
; 1931 : 	}
; 1932 : 	//if (!fmod375->FSOUND_StopSound(FSOUND_ALL))
; 1933 : 		//if (fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER) CONS_Printf("FMOD(Start,FSOUND_StopSound): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1934 : 	//fmod375->FMUSIC_StopAllSongs();
; 1935 : 	//if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER) CONS_Printf("FMOD(Start,FMUSIC_StopAllSongs): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1936 : 
; 1937 : 	// Create the lumpname we need
; 1938 : 	sprintf(lumpname, "o_%s", musicname);
; 1939 : 
; 1940 : 	lumpnum = W_CheckNumForName(lumpname);
; 1941 : 
; 1942 : 	if (lumpnum == LUMPERROR)
; 1943 : 	{
; 1944 : 		sprintf(lumpname, "d_%s", musicname);
; 1945 : 
; 1946 : 		lumpnum = W_CheckNumForName(lumpname);
; 1947 : 
; 1948 : 		if (lumpnum == LUMPERROR) // Graue 02-29-2004: don't worry about missing music, there might still be a MIDI
; 1949 : 			return false; // No music found. Oh well!
; 1950 : 	}
; 1951 : 
; 1952 : #ifndef FMODMEMORY
; 1953 : 	Z_Free(data);
; 1954 : #endif
; 1955 : 	len = W_LumpLength(lumpnum);
; 1956 : 	data = W_CacheLumpNum(lumpnum, PU_MUSIC);
; 1957 : 
; 1958 : #ifdef FMODMEMORY
; 1959 : 	mod = fmod375->FMUSIC_LoadSongEx(data, 0, (int)len, ((looping) ? (FSOUND_LOOP_NORMAL) : (0))|FSOUND_LOADMEMORY, NULL, 0);
; 1960 : #else
; 1961 : 	I_SaveMemToFile(data, len, "fmod.tmp");
; 1962 : 
; 1963 : 	mod = fmod375->FMUSIC_LoadSong("fmod.tmp");
; 1964 : #endif
; 1965 : 
; 1966 : 	if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE)
; 1967 : 	{
; 1968 : 		if (fmod375->FSOUND_GetError() != FMOD_ERR_FILE_FORMAT)
; 1969 : 			if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_LoadSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1970 : 
; 1971 : 		if (mod)
; 1972 : 		{
; 1973 : 			if (fmod375->FMUSIC_IsPlaying(mod))
; 1974 : 				if (!fmod375->FMUSIC_StopSong(mod))
; 1975 : 					if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_StopSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1976 : 			if (!fmod375->FMUSIC_FreeSong(mod))
; 1977 : 				if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_FreeSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1978 : 			mod = NULL;
; 1979 : 		}
; 1980 : 	}
; 1981 : 
; 1982 : 	if (mod)
; 1983 : 	{
; 1984 : 		if (!fmod375->FMUSIC_SetLooping(mod, (signed char)looping))
; 1985 : 		{
; 1986 : 			if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_SetLooping): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1987 : 		}
; 1988 : //		else if (fmod375->FMUSIC_GetType(mod) == FMUSIC_TYPE_MOD || fmod375->FMUSIC_GetType(mod) == FMUSIC_TYPE_S3M)
; 1989 : //		{
; 1990 : //			if (!fmod375->FMUSIC_SetPanSeperation(mod, 0.85f))		/* 15% crossover */
; 1991 : //				CONS_Printf("FMOD(Start,FMUSIC_SetPanSeperation): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1992 : //		}
; 1993 : 		else if (!fmod375->FMUSIC_SetPanSeperation(mod, 0.0f))
; 1994 : 		{
; 1995 : 			if (devparm) I_OutputMsg("FMOD(Start,FMUSIC_SetPanSeperation): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1996 : 		}
; 1997 : 	}
; 1998 : 	else
; 1999 : 	{
; 2000 : #ifdef FMODMEMORY
; 2001 : 		fmus = fmod375->FSOUND_Stream_Open(data, ((looping) ? (FSOUND_LOOP_NORMAL) : (0))|FSOUND_LOADMEMORY, 0, (int)len);
; 2002 : #else
; 2003 : 		fmus = fmod375->FSOUND_Stream_Open("fmod.tmp", ((looping) ? (FSOUND_LOOP_NORMAL) : (0)), 0, len);
; 2004 : #endif
; 2005 : 		if (fmus == NULL)
; 2006 : 		{
; 2007 : 			if (devparm) I_OutputMsg("FMOD(Start,FSOUND_Stream_Open): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 2008 : 			return false;
; 2009 : 		}
; 2010 : 	}
; 2011 : 
; 2012 : 	// Scan the Ogg Vorbis file for the COMMENT= field for a custom loop point
; 2013 : 	if (fmus && looping)
; 2014 : 	{
; 2015 : 		const char *dataum = data;
; 2016 : 		size_t scan;
; 2017 : 		unsigned int loopstart = 0;
; 2018 : 		UINT8 newcount = 0;
; 2019 : 		char looplength[64];
; 2020 : 
; 2021 : 		for (scan = 0;scan < len; scan++)
; 2022 : 		{
; 2023 : 			if (*dataum++ == 'C'){
; 2024 : 			if (*dataum++ == 'O'){
; 2025 : 			if (*dataum++ == 'M'){
; 2026 : 			if (*dataum++ == 'M'){
; 2027 : 			if (*dataum++ == 'E'){
; 2028 : 			if (*dataum++ == 'N'){
; 2029 : 			if (*dataum++ == 'T'){
; 2030 : 			if (*dataum++ == '='){
; 2031 : 			if (*dataum++ == 'L'){
; 2032 : 			if (*dataum++ == 'O'){
; 2033 : 			if (*dataum++ == 'O'){
; 2034 : 			if (*dataum++ == 'P'){
; 2035 : 			if (*dataum++ == 'P'){
; 2036 : 			if (*dataum++ == 'O'){
; 2037 : 			if (*dataum++ == 'I'){
; 2038 : 			if (*dataum++ == 'N'){
; 2039 : 			if (*dataum++ == 'T'){
; 2040 : 			if (*dataum++ == '=')
; 2041 : 			{
; 2042 : 				while (*dataum != 1 && newcount != 63)
; 2043 : 					looplength[newcount++] = *dataum++;
; 2044 : 
; 2045 : 				looplength[newcount] = '\0';
; 2046 : 
; 2047 : 				loopstart = atoi(looplength);
; 2048 : 			}
; 2049 : 			else
; 2050 : 				dataum--;}
; 2051 : 			else
; 2052 : 				dataum--;}
; 2053 : 			else
; 2054 : 				dataum--;}
; 2055 : 			else
; 2056 : 				dataum--;}
; 2057 : 			else
; 2058 : 				dataum--;}
; 2059 : 			else
; 2060 : 				dataum--;}
; 2061 : 			else
; 2062 : 				dataum--;}
; 2063 : 			else
; 2064 : 				dataum--;}
; 2065 : 			else
; 2066 : 				dataum--;}
; 2067 : 			else
; 2068 : 				dataum--;}
; 2069 : 			else
; 2070 : 				dataum--;}
; 2071 : 			else
; 2072 : 				dataum--;}
; 2073 : 			else
; 2074 : 				dataum--;}
; 2075 : 			else
; 2076 : 				dataum--;}
; 2077 : 			else
; 2078 : 				dataum--;}
; 2079 : 			else
; 2080 : 				dataum--;}
; 2081 : 			else
; 2082 : 				dataum--;}
; 2083 : 		}
; 2084 : 
; 2085 : 		if (loopstart > 0)
; 2086 : 		{
; 2087 : 			const int length = fmod375->FSOUND_Stream_GetLengthMs(fmus);
; 2088 : 			const int freq = 44100; //= FSOUND_GetFrequency(fsoundchannel);
; 2089 : 			const unsigned int loopend = (unsigned int)((freq/1000.0f)*length-(freq/1000.0f));
; 2090 : 			//const unsigned int loopend = (((freq/2)*length)/500)-8;
; 2091 : 			if (!fmod375->FSOUND_Stream_SetLoopPoints(fmus, loopstart, loopend) && devparm)
; 2092 : 				I_OutputMsg("FMOD(Start,FSOUND_Stream_SetLoopPoints): %s\n",
; 2093 : 					FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 2094 : 		}
; 2095 : 	}
; 2096 : 
; 2097 : 	/*
; 2098 : 		PLAY SONG
; 2099 : 	*/
; 2100 : 	if (mod)
; 2101 : 	{
; 2102 : 		if (fmod375->FMUSIC_PlaySong(mod))
; 2103 : 		{
; 2104 : 			fsoundchannel = -1;
; 2105 : 			I_SetDigMusicVolume(-1);
; 2106 : 			return true;
; 2107 : 		}
; 2108 : 		else
; 2109 : 		{
; 2110 : 			if (devparm)
; 2111 : 				I_OutputMsg("FMOD(Start,FMUSIC_PlaySong): %s\n",
; 2112 : 				            FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 2113 : 			return false;
; 2114 : 		}
; 2115 : 	}
; 2116 : 	if (fmus)
; 2117 : 	{
; 2118 : 		fsoundchannel = fmod375->FSOUND_Stream_PlayEx(FSOUND_FREE, fmus, NULL, TRUE);
; 2119 : 
; 2120 : 		if (fsoundchannel == -1)
; 2121 : 		{
; 2122 : 			if (devparm)
; 2123 : 				I_OutputMsg("FMOD(Start,FSOUND_Stream_PlayEx): %s\n",
; 2124 : 				            FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 2125 : 			return false;
; 2126 : 		}
; 2127 : 		else if (!fmod375->FSOUND_SetPaused(fsoundchannel, FALSE))
; 2128 : 		{
; 2129 : 			if (devparm)
; 2130 : 				I_OutputMsg("FMOD(Start,FSOUND_SetPaused): %s\n",
; 2131 : 					FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 2132 : 			return false;
; 2133 : 		}
; 2134 : 
; 2135 : 		I_SetDigMusicVolume(-1);
; 2136 : 		fsoundfreq = fmod375->FSOUND_GetFrequency(fsoundchannel);
; 2137 : 		return true;
; 2138 : 	}
; 2139 : #else
; 2140 : 	UNREFERENCED_PARAMETER(musicname);
; 2141 : 	UNREFERENCED_PARAMETER(looping);
; 2142 : #endif
; 2143 : 	return false;

  00009	33 c0		 xor	 eax, eax

; 2144 : 
; 2145 : /////////////////////////////////////////////////////////////////////////////////
; 2146 : }

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_I_StartDigSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_SetSongSpeed
_TEXT	SEGMENT
_speed$ = 8						; size = 4
_I_SetSongSpeed PROC					; COMDAT

; 1837 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1838 : #ifdef FMODSOUND
; 1839 : 	if (music_disabled || nodigimusic)
; 1840 : 		return false; //there no music or FMOD is not loaded
; 1841 : 
; 1842 : 	if ((!fmus || !fmod375->FSOUND_IsPlaying(fsoundchannel)) && (!mod || !fmod375->FMUSIC_IsPlaying(mod)))
; 1843 : 		return false; //there no FMOD music playing
; 1844 : 
; 1845 : 	if (speed == 0.0f)
; 1846 : 		return true; //yes, we can set the speed
; 1847 : 	if (speed > 250.0f)
; 1848 : 		speed = 250.0f; //limit speed up to 250x
; 1849 : 
; 1850 : 	if (fmus && fmod375->FSOUND_IsPlaying(fsoundchannel))
; 1851 : 	{
; 1852 : 		if (!fmod375->FSOUND_SetFrequency(fsoundchannel,(int)(speed*fsoundfreq)))
; 1853 : 		{
; 1854 : 			if (devparm)
; 1855 : 				I_OutputMsg("FMOD(ChangeSpeed,FSOUND_SetFrequency): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1856 : 		}
; 1857 : 		else
; 1858 : 			return true;
; 1859 : 	}
; 1860 : 	else if (mod && fmod375->FMUSIC_IsPlaying(mod))
; 1861 : 	{
; 1862 : 		if (fmod375->FMUSIC_SetMasterSpeed(mod, speed))
; 1863 : 		{
; 1864 : 			if (devparm)
; 1865 : 				I_OutputMsg("FMOD(ChangeSpeed,FMUSIC_SetMasterSpeed): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1866 : 		}
; 1867 : 		else
; 1868 : 			return true;
; 1869 : 	}
; 1870 : #else
; 1871 : 	UNREFERENCED_PARAMETER(speed);
; 1872 : #endif
; 1873 : 	return false;

  00009	33 c0		 xor	 eax, eax

; 1874 : }

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_I_SetSongSpeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_ShutdownDigMusic
_TEXT	SEGMENT
_I_ShutdownDigMusic PROC				; COMDAT

; 1393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1394 : 	CONS_Printf("I_ShutdownDigMusic:\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EHAKIJCE@I_ShutdownDigMusic?3?6@
  0000e	e8 00 00 00 00	 call	 _CONS_Printf
  00013	83 c4 04	 add	 esp, 4

; 1395 : 
; 1396 : #ifdef FMODSOUND
; 1397 : 	if (fmod375 && fmod375->FSOUND_GetError() != FMOD_ERR_UNINITIALIZED)
; 1398 : 	{
; 1399 : 		if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_CHANNEL_ALLOC && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER)
; 1400 : 			if (devparm) I_OutputMsg("FMOD(Shutdown,Unknown): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1401 : 		if (mod)
; 1402 : 		{
; 1403 : 			if (fmod375->FMUSIC_IsPlaying(mod))
; 1404 : 				if (!fmod375->FMUSIC_StopSong(mod))
; 1405 : 					if (devparm) I_OutputMsg("FMOD(Shutdown,FMUSIC_StopSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1406 : 			if (!fmod375->FMUSIC_FreeSong(mod))
; 1407 : 				if (devparm) I_OutputMsg("FMOD(Shutdown,FMUSIC_FreeSong): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1408 : 		}
; 1409 : 		if (fmus)
; 1410 : 		{
; 1411 : 			if (fmod375->FSOUND_IsPlaying(fsoundchannel))
; 1412 : 				if (!fmod375->FSOUND_Stream_Stop(fmus))
; 1413 : 					if (devparm) I_OutputMsg("FMOD(Shutdown,FSOUND_Stream_Stop): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1414 : 			if (!fmod375->FSOUND_Stream_Close(fmus))
; 1415 : 				if (devparm) I_OutputMsg("FMOD(Shutdown,FSOUND_Stream_Close): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1416 : 		}
; 1417 : 		fmod375->FSOUND_Close();
; 1418 : #ifndef FMODMEMORY
; 1419 : 		remove("fmod.tmp"); // Delete the temp file
; 1420 : #endif
; 1421 : 		//if (!fmod375->FSOUND_StopSound(FSOUND_ALL))
; 1422 : 			//if (fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER) CONS_Printf("FMOD(Shutdown,FSOUND_StopSound): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1423 : 		//fmod375->FMUSIC_StopAllSongs();
; 1424 : 			//if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER) CONS_Printf("FMOD(Shutdown,FMUSIC_StopAllSongs): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1425 : 	}
; 1426 : 	FMOD_FreeInstance(fmod375);
; 1427 : 	fmod375 = NULL;
; 1428 : #endif
; 1429 : 	CONS_Printf(" Done\n");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_06ENIPNAIK@?5Done?6@
  0001b	e8 00 00 00 00	 call	 _CONS_Printf
  00020	83 c4 04	 add	 esp, 4

; 1430 : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_I_ShutdownDigMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_InitDigMusic
_TEXT	SEGMENT
_I_InitDigMusic PROC					; COMDAT

; 1199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1200 : 	if (dedicated)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00010	74 0c		 je	 SHORT $LN2@I_InitDigM

; 1201 : 		nodigimusic = true;

  00012	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nodigimusic, 1
  0001c	eb 0d		 jmp	 SHORT $LN3@I_InitDigM
$LN2@I_InitDigM:

; 1202 : 	else
; 1203 : 		CONS_Printf("I_InitDigMusic()\n");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DGMHJPLI@I_InitDigMusic?$CI?$CJ?6@
  00023	e8 00 00 00 00	 call	 _CONS_Printf
  00028	83 c4 04	 add	 esp, 4
$LN3@I_InitDigM:

; 1204 : 
; 1205 : #ifdef FMODSOUND
; 1206 : 	if (!nodigimusic)
; 1207 : 	{
; 1208 : #ifdef _X86_
; 1209 : 		char fmod375dll[] = "fmod375.dll";
; 1210 : 		char fmod000dll[] = "fmod.dll";
; 1211 : #else
; 1212 : 		char fmod375dll[] = "fmod64375.dll";
; 1213 : 		char fmod000dll[] = "fmod64.dll";
; 1214 : #endif
; 1215 : 		fmod375 = FMOD_CreateInstance(fmod375dll);
; 1216 : 
; 1217 : 		if(!fmod375)
; 1218 : 			fmod375 = FMOD_CreateInstance(fmod000dll);
; 1219 : 
; 1220 : 		if (fmod375)
; 1221 : 			I_AddExitFunc(I_ShutdownDigMusic);
; 1222 : 		else
; 1223 : 		{
; 1224 : 			CONS_Printf(" failling loading FMOD\n no DigiMusic support\n");
; 1225 : 			nodigimusic = true;
; 1226 : 		}
; 1227 : 	}
; 1228 : 
; 1229 : 	if (fmod375)
; 1230 : 	{
; 1231 : 		// Tails 11-21-2002
; 1232 : 		if (fmod375->FSOUND_GetVersion() < FMOD_VERSION)
; 1233 : 		{
; 1234 : 			//I_Error("FMOD Error : You are using the wrong DLL version!\nYou should be using FMOD %s\n", "FMOD_VERSION");
; 1235 : 			CONS_Printf("FMOD Error : You are using the wrong DLL version!\nYou should be using FMOD %s\n", "FMOD_VERSION");
; 1236 : 			nodigimusic = true;
; 1237 : 		}
; 1238 : 
; 1239 : 		/*
; 1240 : 			INITIALIZE
; 1241 : 		*/
; 1242 : #if 1
; 1243 : 		if (!fmod375->FSOUND_SetHWND(hWndMain))
; 1244 : 		{
; 1245 : //			I_Error("FMOD(Init,FSOUND_SetHWND): %s\n", fmod375->FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1246 : 			//fmod375->FSOUND_SetOutput(FSOUND_OUTPUT_DSOUND);
; 1247 : 		}
; 1248 : 		//else
; 1249 : #endif
; 1250 : 
; 1251 : 		if (!fmod375->FSOUND_Init(44100, 32, FSOUND_INIT_DONTLATENCYADJUST))
; 1252 : 		{
; 1253 : 			CONS_Printf("FMOD(Init,FSOUND_Init): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1254 : 			nodigimusic = true;
; 1255 : 		}
; 1256 : 	}
; 1257 : #endif
; 1258 : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_I_InitDigMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_UnRegisterSong
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_I_UnRegisterSong PROC					; COMDAT

; 1822 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1823 : 	UNREFERENCED_PARAMETER(handle);
; 1824 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 02		 je	 SHORT $LN2@I_UnRegist

; 1825 : 		return;

  00012	eb 06		 jmp	 SHORT $LN1@I_UnRegist
$LN2@I_UnRegist:

; 1826 : 
; 1827 : 	//faB: we might free here whatever is allocated per-music
; 1828 : 	//     (but we don't cause I hate malloc's)
; 1829 : 	Mid2StreamConverterCleanup();

  00014	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  00019	90		 npad	 1
$LN1@I_UnRegist:

; 1830 : 
; 1831 : #ifdef DEBUGMIDISTREAM
; 1832 : 	CONS_Printf("I_UnregisterSong: \n");
; 1833 : #endif
; 1834 : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_I_UnRegisterSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_StopSong
_TEXT	SEGMENT
_mmrRetVal$ = -4					; size = 4
_handle$ = 8						; size = 4
_I_StopSong PROC					; COMDAT

; 1717 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1718 : 	MMRESULT        mmrRetVal;
; 1719 : 
; 1720 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 05		 je	 SHORT $LN2@I_StopSong

; 1721 : 		return;

  00012	e9 4b 01 00 00	 jmp	 $LN12@I_StopSong
$LN2@I_StopSong:

; 1722 : 
; 1723 : #ifdef DEBUGMIDISTREAM
; 1724 : 	CONS_Printf("I_StopSong: \n");
; 1725 : #endif
; 1726 : 
; 1727 : 	if (bMidiPlaying || (uCallbackStatus != STATUS_CALLBACKDEAD))

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPlaying, 0
  0001e	75 10		 jne	 SHORT $LN4@I_StopSong
  00020	81 3d 00 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H
  0002a	0f 84 e4 00 00
	00		 je	 $LN11@I_StopSong
$LN4@I_StopSong:

; 1728 : 	{
; 1729 : 		bMidiPlaying = bMidiPaused = FALSE;

  00030	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bMidiPaused, 0
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _bMidiPaused
  0003f	a3 00 00 00 00	 mov	 DWORD PTR _bMidiPlaying, eax

; 1730 : 		if (uCallbackStatus != STATUS_CALLBACKDEAD &&

  00044	81 3d 00 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H
  0004e	74 16		 je	 SHORT $LN5@I_StopSong
  00050	81 3d 00 00 00
	00 2c 01 00 00	 cmp	 DWORD PTR _uCallbackStatus, 300 ; 0000012cH
  0005a	74 0a		 je	 SHORT $LN5@I_StopSong

; 1731 : 		    uCallbackStatus != STATUS_WAITINGFOREND)
; 1732 : 			uCallbackStatus = STATUS_KILLCALLBACK;

  0005c	c7 05 00 00 00
	00 64 00 00 00	 mov	 DWORD PTR _uCallbackStatus, 100 ; 00000064H
$LN5@I_StopSong:

; 1733 : 
; 1734 : 		//CONS_Printf("a: %d\n",I_GetTime());
; 1735 : 		if ((mmrRetVal = midiStreamStop(hStream)) != MMSYSERR_NOERROR)

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamStop@4
  00072	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  00075	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00079	74 11		 je	 SHORT $LN6@I_StopSong

; 1736 : 		{
; 1737 : 			MidiErrorMessageBox(mmrRetVal);

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  00084	83 c4 04	 add	 esp, 4

; 1738 : 			return;

  00087	e9 d6 00 00 00	 jmp	 $LN12@I_StopSong
$LN6@I_StopSong:

; 1739 : 		}
; 1740 : 
; 1741 : 		//faB: if we don't call midiOutReset() seems we have to stop the buffers
; 1742 : 		//     ourselves (or it doesn't play anymore)
; 1743 : 		if (!bMidiPaused && (handle != SPECIAL_HANDLE_CLEANMIDI))

  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPaused, 0
  00093	75 18		 jne	 SHORT $LN7@I_StopSong
  00095	81 7d 08 31 f8
	ff ff		 cmp	 DWORD PTR _handle$[ebp], -1999 ; fffff831H
  0009c	74 0f		 je	 SHORT $LN7@I_StopSong

; 1744 : 		{
; 1745 : 			midiStreamPause(hStream);

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  000a3	50		 push	 eax
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamPause@4
  000aa	90		 npad	 1

; 1746 : 		}

  000ab	eb 2f		 jmp	 SHORT $LN10@I_StopSong
$LN7@I_StopSong:

; 1747 : 		//CONS_Printf("b: %d\n",I_GetTime());
; 1748 : 		else
; 1749 : 		//faB: this damn call takes 1 second and a half !!! still do it on exit
; 1750 : 		//     to be sure everything midi is cleaned as much as possible
; 1751 : 		if (handle == SPECIAL_HANDLE_CLEANMIDI)

  000ad	81 7d 08 31 f8
	ff ff		 cmp	 DWORD PTR _handle$[ebp], -1999 ; fffff831H
  000b4	75 26		 jne	 SHORT $LN10@I_StopSong

; 1752 : 		{
; 1753 : 			if ((mmrRetVal = midiOutReset((HMIDIOUT)hStream)) != MMSYSERR_NOERROR)

  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  000bb	50		 push	 eax
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutReset@4
  000c2	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  000c5	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  000c9	74 11		 je	 SHORT $LN10@I_StopSong

; 1754 : 			{
; 1755 : 				MidiErrorMessageBox(mmrRetVal);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  000d4	83 c4 04	 add	 esp, 4

; 1756 : 				return;

  000d7	e9 86 00 00 00	 jmp	 $LN12@I_StopSong
$LN10@I_StopSong:

; 1757 : 			}
; 1758 : 		}
; 1759 : 		//CONS_Printf("c: %d\n",I_GetTime());
; 1760 : 
; 1761 : 		// Wait for the callback thread to release this thread, which it will do by
; 1762 : 		// calling SetEvent() once all buffers are returned to it
; 1763 : 		if ((devparm)
; 1764 : 			&& (WaitForSingleObject(hBufferReturnEvent, DEBUG_CALLBACK_TIMEOUT)

  000dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  000e3	74 2f		 je	 SHORT $LN11@I_StopSong
  000e5	68 d0 07 00 00	 push	 2000			; 000007d0H
  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _hBufferReturnEvent
  000ef	50		 push	 eax
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  000f6	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  000fb	75 17		 jne	 SHORT $LN11@I_StopSong

; 1765 : 			   == WAIT_TIMEOUT))
; 1766 : 		{
; 1767 : 			// Note, this is a risky move because the callback may be genuinely busy, but
; 1768 : 			// when we're debugging, it's safer and faster than freezing the application,
; 1769 : 			// which leaves the MIDI device locked up and forces a system reset...
; 1770 : 			I_OutputMsg("Timed out waiting for MIDI callback\n");

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KOIMFAFM@Timed?5out?5waiting?5for?5MIDI?5call@
  00102	e8 00 00 00 00	 call	 _I_OutputMsg
  00107	83 c4 04	 add	 esp, 4

; 1771 : 			uCallbackStatus = STATUS_CALLBACKDEAD;

  0010a	c7 05 00 00 00
	00 c8 00 00 00	 mov	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H
$LN11@I_StopSong:

; 1772 : 		}
; 1773 : 		//CONS_Printf("d: %d\n",I_GetTime());
; 1774 : 	}
; 1775 : 
; 1776 : 	if (uCallbackStatus == STATUS_CALLBACKDEAD)

  00114	81 3d 00 00 00
	00 c8 00 00 00	 cmp	 DWORD PTR _uCallbackStatus, 200 ; 000000c8H
  0011e	75 42		 jne	 SHORT $LN12@I_StopSong

; 1777 : 	{
; 1778 : 		uCallbackStatus = 0;

  00120	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uCallbackStatus, 0

; 1779 : 		Mid2StreamConverterCleanup();

  0012a	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  0012f	90		 npad	 1

; 1780 : 		Mid2StreamFreeBuffers();

  00130	e8 00 00 00 00	 call	 _Mid2StreamFreeBuffers
  00135	90		 npad	 1

; 1781 : 		//faB: we could close the stream here and re-open later to avoid
; 1782 : 		//     a little quirk in mmsystem (see DirectX6 mstream note)
; 1783 : 		midiStreamClose(hStream);

  00136	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  0013b	50		 push	 eax
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamClose@4
  00142	90		 npad	 1

; 1784 : 		midiStreamOpen(&hStream, &uMIDIDeviceID, (DWORD)1,

  00143	68 00 00 03 00	 push	 196608			; 00030000H
  00148	6a 00		 push	 0
  0014a	68 00 00 00 00	 push	 OFFSET _MidiStreamCallback@20
  0014f	6a 01		 push	 1
  00151	68 00 00 00 00	 push	 OFFSET _uMIDIDeviceID
  00156	68 00 00 00 00	 push	 OFFSET _hStream
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamOpen@24
  00161	90		 npad	 1
$LN12@I_StopSong:

; 1785 : 		               (DWORD_PTR)MidiStreamCallback/*NULL*/,
; 1786 : 		               (DWORD)0, CALLBACK_FUNCTION /*CALLBACK_NULL*/);
; 1787 : 	}
; 1788 : }

  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
_I_StopSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_PlaySong
_TEXT	SEGMENT
_mmrRetVal$ = -4					; size = 4
_handle$ = 8						; size = 4
_bLooping$ = 12						; size = 4
_I_PlaySong PROC					; COMDAT

; 1592 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1593 : 	MMRESULT        mmrRetVal;
; 1594 : 
; 1595 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 07		 je	 SHORT $LN2@I_PlaySong

; 1596 : 		return false;

  00012	33 c0		 xor	 eax, eax
  00014	e9 9b 00 00 00	 jmp	 $LN1@I_PlaySong
$LN2@I_PlaySong:

; 1597 : 
; 1598 : #ifdef DEBUGMIDISTREAM
; 1599 : 	CONS_Printf("I_PlaySong: looping %d\n", bLooping);
; 1600 : #endif
; 1601 : 
; 1602 : 	// unpause the song first if it was paused
; 1603 : 	if (bMidiPaused)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPaused, 0
  00020	74 0c		 je	 SHORT $LN3@I_PlaySong

; 1604 : 		I_PauseSong(handle);

  00022	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _I_PauseSong
  0002b	83 c4 04	 add	 esp, 4
$LN3@I_PlaySong:

; 1605 : 
; 1606 : 	// Clear the status of our callback so it will handle
; 1607 : 	// MOM_DONE callbacks once more
; 1608 : 	uCallbackStatus = 0;

  0002e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uCallbackStatus, 0

; 1609 : 	bMidiPlaying = FALSE;

  00038	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bMidiPlaying, 0

; 1610 : 	if ((mmrRetVal = midiStreamRestart(hStream)) != MMSYSERR_NOERROR)

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamRestart@4
  0004e	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  00051	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00055	74 46		 je	 SHORT $LN4@I_PlaySong

; 1611 : 	{
; 1612 : 		MidiErrorMessageBox(mmrRetVal);

  00057	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  00060	83 c4 04	 add	 esp, 4

; 1613 : 		Mid2StreamConverterCleanup();

  00063	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  00068	90		 npad	 1

; 1614 : 		Mid2StreamFreeBuffers();

  00069	e8 00 00 00 00	 call	 _Mid2StreamFreeBuffers
  0006e	90		 npad	 1

; 1615 : 		midiStreamClose(hStream);

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamClose@4
  0007b	90		 npad	 1

; 1616 : 		//I_Error("I_PlaySong: midiStreamRestart error");
; 1617 : 		midiStreamOpen(&hStream, &uMIDIDeviceID, (DWORD)1,

  0007c	68 00 00 03 00	 push	 196608			; 00030000H
  00081	6a 00		 push	 0
  00083	68 00 00 00 00	 push	 OFFSET _MidiStreamCallback@20
  00088	6a 01		 push	 1
  0008a	68 00 00 00 00	 push	 OFFSET _uMIDIDeviceID
  0008f	68 00 00 00 00	 push	 OFFSET _hStream
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamOpen@24
  0009a	90		 npad	 1

; 1618 : 		               (DWORD_PTR)MidiStreamCallback/*NULL*/,
; 1619 : 		               (DWORD)0, CALLBACK_FUNCTION /*CALLBACK_NULL*/);
; 1620 : 	}

  0009b	eb 0a		 jmp	 SHORT $LN5@I_PlaySong
$LN4@I_PlaySong:

; 1621 : 	else bMidiPlaying = TRUE;

  0009d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bMidiPlaying, 1
$LN5@I_PlaySong:

; 1622 : 	bMidiLooped = bLooping;

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _bLooping$[ebp]
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _bMidiLooped, eax

; 1623 : 	return bMidiPlaying;

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _bMidiPlaying
$LN1@I_PlaySong:

; 1624 : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_I_PlaySong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_RegisterSong
_TEXT	SEGMENT
_data$ = 8						; size = 4
_len$ = 12						; size = 4
_I_RegisterSong PROC					; COMDAT

; 2156 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2157 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 07		 je	 SHORT $LN2@I_Register

; 2158 : 		return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	eb 64		 jmp	 SHORT $LN1@I_Register
$LN2@I_Register:

; 2159 : 	if (!data || !len)

  00019	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  0001d	74 06		 je	 SHORT $LN4@I_Register
  0001f	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  00023	75 04		 jne	 SHORT $LN3@I_Register
$LN4@I_Register:

; 2160 : 		return 0;

  00025	33 c0		 xor	 eax, eax
  00027	eb 54		 jmp	 SHORT $LN1@I_Register
$LN3@I_Register:

; 2161 : 
; 2162 : #ifdef DEBUGMIDISTREAM
; 2163 : 	CONS_Printf("I_RegisterSong: \n");
; 2164 : #endif
; 2165 : 	// check for MID format file
; 2166 : 	if (memcmp(data, "MThd", 4))

  00029	6a 04		 push	 4
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_04JKIEDINE@MThd@
  00030	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _memcmp
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	85 c0		 test	 eax, eax
  0003e	74 11		 je	 SHORT $LN5@I_Register

; 2167 : 	{
; 2168 : 		CONS_Printf("Music lump is not MID music format\n");

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CGKEEJ@Music?5lump?5is?5not?5MID?5music?5for@
  00045	e8 00 00 00 00	 call	 _CONS_Printf
  0004a	83 c4 04	 add	 esp, 4

; 2169 : 		return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 2c		 jmp	 SHORT $LN1@I_Register
$LN5@I_Register:

; 2170 : 	}
; 2171 : 
; 2172 : #ifdef DEBUGMIDISTREAM
; 2173 : 	I_SaveMemToFile(data, len, "debug.mid");
; 2174 : #endif
; 2175 : 
; 2176 : 	// setup midi stream buffer
; 2177 : 	if (StreamBufferSetup(data, len))

  00051	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _StreamBufferSetup
  0005e	83 c4 08	 add	 esp, 8
  00061	85 c0		 test	 eax, eax
  00063	74 13		 je	 SHORT $LN6@I_Register

; 2178 : 	{
; 2179 : 		Mid2StreamConverterCleanup();

  00065	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  0006a	90		 npad	 1

; 2180 : 		I_Error("I_RegisterSong: StreamBufferSetup FAILED");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GCMMCOOJ@I_RegisterSong?3?5StreamBufferSet@
  00070	e8 00 00 00 00	 call	 _I_Error
  00075	83 c4 04	 add	 esp, 4
$LN6@I_Register:

; 2181 : 	}
; 2182 : 
; 2183 : 	return 1;

  00078	b8 01 00 00 00	 mov	 eax, 1
$LN1@I_Register:

; 2184 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_I_RegisterSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_SetMIDIMusicVolume
_TEXT	SEGMENT
_iVolume$ = -8						; size = 4
_mmrRetVal$ = -4					; size = 4
_volume$ = 8						; size = 4
_I_SetMIDIMusicVolume PROC				; COMDAT

; 1528 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1529 : 	MMRESULT    mmrRetVal;
; 1530 : 	int         iVolume;
; 1531 : 
; 1532 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 02		 je	 SHORT $LN2@I_SetMIDIM

; 1533 : 		return;

  00012	eb 72		 jmp	 SHORT $LN4@I_SetMIDIM
$LN2@I_SetMIDIM:

; 1534 : 
; 1535 : 	if (bMidiCanSetVolume)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiCanSetVolume, 0
  0001b	74 46		 je	 SHORT $LN3@I_SetMIDIM

; 1536 : 	{
; 1537 : 		// method A
; 1538 : 		// current volume is 0-31, we need 0-0xFFFF in each word (left/right channel)
; 1539 : 		iVolume = (volume << 11) | (volume << 27);

  0001d	8b 45 08	 mov	 eax, DWORD PTR _volume$[ebp]
  00020	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _volume$[ebp]
  00026	c1 e1 1b	 shl	 ecx, 27			; 0000001bH
  00029	0b c1		 or	 eax, ecx
  0002b	89 45 f8	 mov	 DWORD PTR _iVolume$[ebp], eax

; 1540 : 		if ((mmrRetVal = midiOutSetVolume((HMIDIOUT)(size_t)uMIDIDeviceID, iVolume)) != MMSYSERR_NOERROR)

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _iVolume$[ebp]
  00031	50		 push	 eax
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uMIDIDeviceID
  00038	51		 push	 ecx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutSetVolume@8
  0003f	89 45 fc	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  00042	83 7d fc 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00046	74 19		 je	 SHORT $LN5@I_SetMIDIM

; 1541 : 		{
; 1542 : 			CONS_Printf("I_SetMusicVolume: couldn't set volume\n");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GNMLHIE@I_SetMusicVolume?3?5couldn?8t?5set?5@
  0004d	e8 00 00 00 00	 call	 _CONS_Printf
  00052	83 c4 04	 add	 esp, 4

; 1543 : 			MidiErrorMessageBox(mmrRetVal);

  00055	8b 45 fc	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  0005e	83 c4 04	 add	 esp, 4
$LN5@I_SetMIDIM:

; 1544 : 		}
; 1545 : 	}

  00061	eb 23		 jmp	 SHORT $LN4@I_SetMIDIM
$LN3@I_SetMIDIM:

; 1546 : 	else
; 1547 : 	{
; 1548 : 		// method B
; 1549 : 		dwVolumePercent = (volume * 1000) / 32;

  00063	69 45 08 e8 03
	00 00		 imul	 eax, DWORD PTR _volume$[ebp], 1000
  0006a	99		 cdq
  0006b	83 e2 1f	 and	 edx, 31			; 0000001fH
  0006e	03 c2		 add	 eax, edx
  00070	c1 f8 05	 sar	 eax, 5
  00073	a3 00 00 00 00	 mov	 DWORD PTR _dwVolumePercent, eax

; 1550 : 		SetAllChannelVolumes(dwVolumePercent);

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _dwVolumePercent
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _SetAllChannelVolumes
  00083	83 c4 04	 add	 esp, 4
$LN4@I_SetMIDIM:

; 1551 : 	}
; 1552 : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_I_SetMIDIMusicVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_ShutdownMIDIMusic
_TEXT	SEGMENT
_lp$ = -12						; size = 4
_mmrRetVal$ = -8					; size = 4
_idx$ = -4						; size = 4
_I_ShutdownMIDIMusic PROC				; COMDAT

; 1436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1437 : 	DWORD       idx;
; 1438 : 	MMRESULT    mmrRetVal;
; 1439 : 	HGLOBAL     lp;
; 1440 : 
; 1441 : 	CONS_Printf("I_ShutdownMIDIMusic: \n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NKIEHFEO@I_ShutdownMIDIMusic?3?5?6@
  0000e	e8 00 00 00 00	 call	 _CONS_Printf
  00013	83 c4 04	 add	 esp, 4

; 1442 : 
; 1443 : 	if (nomidimusic)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  0001d	74 05		 je	 SHORT $LN5@I_Shutdown

; 1444 : 		return;

  0001f	e9 da 00 00 00	 jmp	 $LN1@I_Shutdown
$LN5@I_Shutdown:

; 1445 : 
; 1446 : 	if (!bMusicStarted)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMusicStarted, 0
  0002b	75 05		 jne	 SHORT $LN6@I_Shutdown

; 1447 : 		return;

  0002d	e9 cc 00 00 00	 jmp	 $LN1@I_Shutdown
$LN6@I_Shutdown:

; 1448 : 
; 1449 : 	if (hStream)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hStream, 0
  00039	74 0d		 je	 SHORT $LN7@I_Shutdown

; 1450 : 	{
; 1451 : 		I_StopSong (SPECIAL_HANDLE_CLEANMIDI);

  0003b	68 31 f8 ff ff	 push	 -1999			; fffff831H
  00040	e8 00 00 00 00	 call	 _I_StopSong
  00045	83 c4 04	 add	 esp, 4
$LN7@I_Shutdown:

; 1452 : 	}
; 1453 : 
; 1454 : 	Mid2StreamConverterCleanup();

  00048	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  0004d	90		 npad	 1

; 1455 : 	Mid2StreamFreeBuffers();

  0004e	e8 00 00 00 00	 call	 _Mid2StreamFreeBuffers
  00053	90		 npad	 1

; 1456 : 
; 1457 : 	// Free our stream buffers
; 1458 : 	for (idx = 0; idx < NUM_STREAM_BUFFERS; idx++)

  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  0005b	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _idx$[ebp]
  00060	83 c0 01	 add	 eax, 1
  00063	89 45 fc	 mov	 DWORD PTR _idx$[ebp], eax
$LN4@I_Shutdown:
  00066	83 7d fc 02	 cmp	 DWORD PTR _idx$[ebp], 2
  0006a	73 47		 jae	 SHORT $LN3@I_Shutdown

; 1459 : 	{
; 1460 : 		if (ciStreamBuffers[idx].mhBuffer.lpData)

  0006c	6b 45 fc 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  00070	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _ciStreamBuffers[eax], 0
  00077	74 38		 je	 SHORT $LN8@I_Shutdown

; 1461 : 		{
; 1462 : 			//GlobalFreePtr(ciStreamBuffers[idx].mhBuffer.lpData);
; 1463 : 			lp = GlobalPtrHandle(ciStreamBuffers[idx].mhBuffer.lpData);

  00079	6b 45 fc 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  0007d	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _ciStreamBuffers[eax]
  00083	51		 push	 ecx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalHandle@4
  0008a	89 45 f4	 mov	 DWORD PTR _lp$[ebp], eax

; 1464 : 			GlobalUnlock(lp);

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _lp$[ebp]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  00097	90		 npad	 1

; 1465 : 			GlobalFree(lp);

  00098	8b 45 f4	 mov	 eax, DWORD PTR _lp$[ebp]
  0009b	50		 push	 eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  000a2	90		 npad	 1

; 1466 : 			ciStreamBuffers[idx].mhBuffer.lpData = NULL;

  000a3	6b 45 fc 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  000a7	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ciStreamBuffers[eax], 0
$LN8@I_Shutdown:

; 1467 : 		}
; 1468 : 	}

  000b1	eb aa		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 1469 : 
; 1470 : 	if (hStream)

  000b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hStream, 0
  000ba	74 2b		 je	 SHORT $LN9@I_Shutdown

; 1471 : 	{
; 1472 : 		if ((mmrRetVal = midiStreamClose(hStream)) != MMSYSERR_NOERROR)

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  000c1	50		 push	 eax
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamClose@4
  000c8	89 45 f8	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  000cb	83 7d f8 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  000cf	74 0c		 je	 SHORT $LN10@I_Shutdown

; 1473 : 			MidiErrorMessageBox(mmrRetVal);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  000da	83 c4 04	 add	 esp, 4
$LN10@I_Shutdown:

; 1474 : 		hStream = NULL;

  000dd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hStream, 0
$LN9@I_Shutdown:

; 1475 : 	}
; 1476 : 
; 1477 : 	CloseHandle(hBufferReturnEvent);

  000e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hBufferReturnEvent
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000f3	90		 npad	 1

; 1478 : 
; 1479 : 	bMusicStarted = false;

  000f4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bMusicStarted, 0
$LN1@I_Shutdown:

; 1480 : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_I_ShutdownMIDIMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_InitMIDIMusic
_TEXT	SEGMENT
tv88 = -140						; size = 4
tv140 = -140						; size = 4
_szTechnology$ = -72					; size = 4
_MidiOutCaps$ = -68					; size = 52
_cMidiDevs$ = -16					; size = 4
_mmrRetVal$ = -12					; size = 4
_idx$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_InitMIDIMusic PROC					; COMDAT

; 1265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1266 : 	DWORD       idx;
; 1267 : 	MMRESULT    mmrRetVal;
; 1268 : 	UINT        cMidiDevs;
; 1269 : 	MIDIOUTCAPS MidiOutCaps;
; 1270 : 	LPCSTR      szTechnology;
; 1271 : 
; 1272 : 	bMusicStarted = false;

  00016	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bMusicStarted, 0

; 1273 : 
; 1274 : 	if (dedicated)

  00020	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00027	74 0c		 je	 SHORT $LN7@I_InitMIDI

; 1275 : 		nomidimusic = true;

  00029	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nomidimusic, 1
  00033	eb 0d		 jmp	 SHORT $LN8@I_InitMIDI
$LN7@I_InitMIDI:

; 1276 : 	else
; 1277 : 		CONS_Printf("I_InitMIDIMusic()\n");

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CKHFPBDI@I_InitMIDIMusic?$CI?$CJ?6@
  0003a	e8 00 00 00 00	 call	 _CONS_Printf
  0003f	83 c4 04	 add	 esp, 4
$LN8@I_InitMIDI:

; 1278 : 
; 1279 : 	if (nomidimusic)

  00042	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00049	74 05		 je	 SHORT $LN9@I_InitMIDI

; 1280 : 		return;

  0004b	e9 86 02 00 00	 jmp	 $LN1@I_InitMIDI
$LN9@I_InitMIDI:

; 1281 : 
; 1282 : 	// check out number of MIDI devices available
; 1283 : 	//
; 1284 : 	cMidiDevs = midiOutGetNumDevs();

  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutGetNumDevs@0
  00056	89 45 f0	 mov	 DWORD PTR _cMidiDevs$[ebp], eax

; 1285 : 	if (!cMidiDevs)

  00059	83 7d f0 00	 cmp	 DWORD PTR _cMidiDevs$[ebp], 0
  0005d	75 1c		 jne	 SHORT $LN10@I_InitMIDI

; 1286 : 	{
; 1287 : 		CONS_Printf("No MIDI devices available, music is disabled\n");

  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KMPDLJMG@No?5MIDI?5devices?5available?0?5musi@
  00064	e8 00 00 00 00	 call	 _CONS_Printf
  00069	83 c4 04	 add	 esp, 4

; 1288 : 		nomidimusic = true;

  0006c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nomidimusic, 1

; 1289 : 		return;

  00076	e9 5b 02 00 00	 jmp	 $LN1@I_InitMIDI
$LN10@I_InitMIDI:

; 1290 : 	}
; 1291 : #ifdef DEBUGMIDISTREAM
; 1292 : 	else
; 1293 : 	{
; 1294 : 		CONS_Printf("%d MIDI devices available\n", cMidiDevs);
; 1295 : 	}
; 1296 : #endif
; 1297 : 
; 1298 : 	if (M_CheckParm("-winmidi") && M_IsNextParm())

  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_08DMGAMJFH@?9winmidi@
  00080	e8 00 00 00 00	 call	 _M_CheckParm
  00085	83 c4 04	 add	 esp, 4
  00088	85 c0		 test	 eax, eax
  0008a	74 1e		 je	 SHORT $LN11@I_InitMIDI
  0008c	e8 00 00 00 00	 call	 _M_IsNextParm
  00091	85 c0		 test	 eax, eax
  00093	74 15		 je	 SHORT $LN11@I_InitMIDI

; 1299 : 		uMIDIDeviceID = atoi(M_GetNextParm());

  00095	e8 00 00 00 00	 call	 _M_GetNextParm
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _atoi
  000a0	83 c4 04	 add	 esp, 4
  000a3	a3 00 00 00 00	 mov	 DWORD PTR _uMIDIDeviceID, eax
  000a8	eb 0a		 jmp	 SHORT $LN12@I_InitMIDI
$LN11@I_InitMIDI:

; 1300 : 	else
; 1301 : 		uMIDIDeviceID = MIDI_MAPPER;

  000aa	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uMIDIDeviceID, -1
$LN12@I_InitMIDI:

; 1302 : 
; 1303 : 	// get MIDI device caps
; 1304 : 	//
; 1305 : 	if ((mmrRetVal = midiOutGetDevCaps(uMIDIDeviceID, &MidiOutCaps, sizeof (MIDIOUTCAPS))) !=

  000b4	6a 34		 push	 52			; 00000034H
  000b6	8d 45 bc	 lea	 eax, DWORD PTR _MidiOutCaps$[ebp]
  000b9	50		 push	 eax
  000ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uMIDIDeviceID
  000c0	51		 push	 ecx
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutGetDevCapsA@12
  000c7	89 45 f4	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  000ca	83 7d f4 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  000ce	74 1e		 je	 SHORT $LN13@I_InitMIDI

; 1306 : 	     MMSYSERR_NOERROR)
; 1307 : 	{
; 1308 : 		CONS_Printf("midiOutGetCaps FAILED : \n");

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FJOCNIKF@midiOutGetCaps?5FAILED?5?3?5?6@
  000d5	e8 00 00 00 00	 call	 _CONS_Printf
  000da	83 c4 04	 add	 esp, 4

; 1309 : 		MidiErrorMessageBox(mmrRetVal);

  000dd	8b 45 f4	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  000e6	83 c4 04	 add	 esp, 4

; 1310 : 	}

  000e9	e9 10 01 00 00	 jmp	 $LN14@I_InitMIDI
$LN13@I_InitMIDI:

; 1311 : 	else
; 1312 : 	{
; 1313 : 		CONS_Printf("MIDI product name: %s\n", MidiOutCaps.szPname);

  000ee	8d 45 c4	 lea	 eax, DWORD PTR _MidiOutCaps$[ebp+8]
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EJBAJKDI@MIDI?5product?5name?3?5?$CFs?6@
  000f7	e8 00 00 00 00	 call	 _CONS_Printf
  000fc	83 c4 08	 add	 esp, 8

; 1314 : 		switch (MidiOutCaps.wTechnology)

  000ff	0f b7 45 e4	 movzx	 eax, WORD PTR _MidiOutCaps$[ebp+40]
  00103	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  00109	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv88[ebp]
  0010f	83 e9 01	 sub	 ecx, 1
  00112	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv88[ebp], ecx
  00118	83 bd 74 ff ff
	ff 04		 cmp	 DWORD PTR tv88[ebp], 4
  0011f	77 3a		 ja	 SHORT $LN20@I_InitMIDI
  00121	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv88[ebp]
  00127	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN30@I_InitMIDI[edx*4]
$LN15@I_InitMIDI:

; 1315 : 		{
; 1316 : 			case MOD_FMSYNTH:   szTechnology = "FM Synth"; break;

  0012e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _szTechnology$[ebp], OFFSET ??_C@_08JCKGCGII@FM?5Synth@
  00135	eb 2b		 jmp	 SHORT $LN2@I_InitMIDI
$LN16@I_InitMIDI:

; 1317 : 			case MOD_MAPPER:    szTechnology = "Microsoft MIDI Mapper"; break;

  00137	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _szTechnology$[ebp], OFFSET ??_C@_0BG@LDJPMKAP@Microsoft?5MIDI?5Mapper@
  0013e	eb 22		 jmp	 SHORT $LN2@I_InitMIDI
$LN17@I_InitMIDI:

; 1318 : 			case MOD_MIDIPORT:  szTechnology = "MIDI hardware port"; break;

  00140	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _szTechnology$[ebp], OFFSET ??_C@_0BD@OFCCDCFH@MIDI?5hardware?5port@
  00147	eb 19		 jmp	 SHORT $LN2@I_InitMIDI
$LN18@I_InitMIDI:

; 1319 : 			case MOD_SQSYNTH:   szTechnology = "Square wave synthesizer"; break;

  00149	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _szTechnology$[ebp], OFFSET ??_C@_0BI@PNFJHGIO@Square?5wave?5synthesizer@
  00150	eb 10		 jmp	 SHORT $LN2@I_InitMIDI
$LN19@I_InitMIDI:

; 1320 : 			case MOD_SYNTH:     szTechnology = "Synthesizer"; break;

  00152	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _szTechnology$[ebp], OFFSET ??_C@_0M@LMECJLFI@Synthesizer@
  00159	eb 07		 jmp	 SHORT $LN2@I_InitMIDI
$LN20@I_InitMIDI:

; 1321 : 			default:            szTechnology = "unknown"; break;

  0015b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _szTechnology$[ebp], OFFSET ??_C@_07CIFAGBMG@unknown@
$LN2@I_InitMIDI:

; 1322 : 		}
; 1323 : 		CONS_Printf("MIDI technology: %s\n", szTechnology);

  00162	8b 45 b8	 mov	 eax, DWORD PTR _szTechnology$[ebp]
  00165	50		 push	 eax
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IPGEIJMH@MIDI?5technology?3?5?$CFs?6@
  0016b	e8 00 00 00 00	 call	 _CONS_Printf
  00170	83 c4 08	 add	 esp, 8

; 1324 : 		CONS_Printf("MIDI caps:\n");

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LBEIDFMC@MIDI?5caps?3?6@
  00178	e8 00 00 00 00	 call	 _CONS_Printf
  0017d	83 c4 04	 add	 esp, 4

; 1325 : 		if (MidiOutCaps.dwSupport & MIDICAPS_CACHE)

  00180	8b 45 ec	 mov	 eax, DWORD PTR _MidiOutCaps$[ebp+48]
  00183	83 e0 04	 and	 eax, 4
  00186	74 0d		 je	 SHORT $LN21@I_InitMIDI

; 1326 : 			CONS_Printf("-Patch caching\n");

  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MNELLNIM@?9Patch?5caching?6@
  0018d	e8 00 00 00 00	 call	 _CONS_Printf
  00192	83 c4 04	 add	 esp, 4
$LN21@I_InitMIDI:

; 1327 : 		if (MidiOutCaps.dwSupport & MIDICAPS_LRVOLUME)

  00195	8b 45 ec	 mov	 eax, DWORD PTR _MidiOutCaps$[ebp+48]
  00198	83 e0 02	 and	 eax, 2
  0019b	74 0d		 je	 SHORT $LN22@I_InitMIDI

; 1328 : 			CONS_Printf("-Separate left and right volume control\n");

  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OCJBONLJ@?9Separate?5left?5and?5right?5volume@
  001a2	e8 00 00 00 00	 call	 _CONS_Printf
  001a7	83 c4 04	 add	 esp, 4
$LN22@I_InitMIDI:

; 1329 : 		if (MidiOutCaps.dwSupport & MIDICAPS_STREAM)

  001aa	8b 45 ec	 mov	 eax, DWORD PTR _MidiOutCaps$[ebp+48]
  001ad	83 e0 08	 and	 eax, 8
  001b0	74 0d		 je	 SHORT $LN23@I_InitMIDI

; 1330 : 			CONS_Printf("-Direct support for midiStreamOut()\n");

  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MMNIHBDC@?9Direct?5support?5for?5midiStreamO@
  001b7	e8 00 00 00 00	 call	 _CONS_Printf
  001bc	83 c4 04	 add	 esp, 4
$LN23@I_InitMIDI:

; 1331 : 		if (MidiOutCaps.dwSupport & MIDICAPS_VOLUME)

  001bf	8b 45 ec	 mov	 eax, DWORD PTR _MidiOutCaps$[ebp+48]
  001c2	83 e0 01	 and	 eax, 1
  001c5	74 0d		 je	 SHORT $LN24@I_InitMIDI

; 1332 : 			CONS_Printf("-Volume control\n");

  001c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CCMJMEKG@?9Volume?5control?6@
  001cc	e8 00 00 00 00	 call	 _CONS_Printf
  001d1	83 c4 04	 add	 esp, 4
$LN24@I_InitMIDI:

; 1333 : 		bMidiCanSetVolume = ((MidiOutCaps.dwSupport & MIDICAPS_VOLUME)!=0);

  001d4	8b 45 ec	 mov	 eax, DWORD PTR _MidiOutCaps$[ebp+48]
  001d7	83 e0 01	 and	 eax, 1
  001da	74 0c		 je	 SHORT $LN28@I_InitMIDI
  001dc	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv140[ebp], 1
  001e6	eb 0a		 jmp	 SHORT $LN29@I_InitMIDI
$LN28@I_InitMIDI:
  001e8	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$LN29@I_InitMIDI:
  001f2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv140[ebp]
  001f8	89 0d 00 00 00
	00		 mov	 DWORD PTR _bMidiCanSetVolume, ecx
$LN14@I_InitMIDI:

; 1334 : 	}
; 1335 : 
; 1336 : #ifdef TESTCODE
; 1337 : 	I_InitAudioMixer ();
; 1338 : #endif
; 1339 : 
; 1340 : 	// ----------------------------------------------------------------------
; 1341 : 	// Midi2Stream initialization
; 1342 : 	// ----------------------------------------------------------------------
; 1343 : 
; 1344 : 	// create event for synch'ing the callback thread to main program thread
; 1345 : 	// when we will need it
; 1346 : 	hBufferReturnEvent = CreateEvent(NULL, FALSE, FALSE,

  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LHGPBBJI@SRB2?5Midi?5Playback?3?5Wait?5For?5Bu@
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	6a 00		 push	 0
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  0020f	a3 00 00 00 00	 mov	 DWORD PTR _hBufferReturnEvent, eax

; 1347 : 	                                 TEXT("SRB2 Midi Playback: Wait For Buffer Return"));
; 1348 : 
; 1349 : 	if (!hBufferReturnEvent)

  00214	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hBufferReturnEvent, 0
  0021b	75 26		 jne	 SHORT $LN25@I_InitMIDI

; 1350 : 	{
; 1351 : 		CONS_Printf("No MIDI music\n");

  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IAOAAAKM@No?5MIDI?5music?6@
  00222	e8 00 00 00 00	 call	 _CONS_Printf
  00227	83 c4 04	 add	 esp, 4

; 1352 : 		I_ShowLastError(TRUE);

  0022a	6a 01		 push	 1
  0022c	e8 00 00 00 00	 call	 _I_ShowLastError
  00231	83 c4 04	 add	 esp, 4

; 1353 : 		nomidimusic = true;

  00234	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nomidimusic, 1

; 1354 : 		return;

  0023e	e9 93 00 00 00	 jmp	 $LN1@I_InitMIDI
$LN25@I_InitMIDI:

; 1355 : 	}
; 1356 : 
; 1357 : 	if ((mmrRetVal = midiStreamOpen(&hStream,
; 1358 : 	                                &uMIDIDeviceID,
; 1359 : 	                                (DWORD)1, (DWORD_PTR)MidiStreamCallback/*NULL*/,
; 1360 : 	                                (DWORD)0,
; 1361 : 	                                CALLBACK_FUNCTION /*CALLBACK_NULL*/)) != MMSYSERR_NOERROR)

  00243	68 00 00 03 00	 push	 196608			; 00030000H
  00248	6a 00		 push	 0
  0024a	68 00 00 00 00	 push	 OFFSET _MidiStreamCallback@20
  0024f	6a 01		 push	 1
  00251	68 00 00 00 00	 push	 OFFSET _uMIDIDeviceID
  00256	68 00 00 00 00	 push	 OFFSET _hStream
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamOpen@24
  00261	89 45 f4	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
  00264	83 7d f4 00	 cmp	 DWORD PTR _mmrRetVal$[ebp], 0
  00268	74 25		 je	 SHORT $LN26@I_InitMIDI

; 1362 : 	{
; 1363 : 		CONS_Printf("I_RegisterSong: midiStreamOpen FAILED\n");

  0026a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@EAJMJIOO@I_RegisterSong?3?5midiStreamOpen?5@
  0026f	e8 00 00 00 00	 call	 _CONS_Printf
  00274	83 c4 04	 add	 esp, 4

; 1364 : 		MidiErrorMessageBox(mmrRetVal);

  00277	8b 45 f4	 mov	 eax, DWORD PTR _mmrRetVal$[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 _MidiErrorMessageBox
  00280	83 c4 04	 add	 esp, 4

; 1365 : 		nomidimusic = true;

  00283	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nomidimusic, 1

; 1366 : 		return;

  0028d	eb 47		 jmp	 SHORT $LN1@I_InitMIDI
$LN26@I_InitMIDI:

; 1367 : 	}
; 1368 : 
; 1369 : 	// stream buffers are initially unallocated (set em NULL)
; 1370 : 	for (idx = 0; idx < NUM_STREAM_BUFFERS; idx++)

  0028f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  00296	eb 09		 jmp	 SHORT $LN6@I_InitMIDI
$LN4@I_InitMIDI:
  00298	8b 45 f8	 mov	 eax, DWORD PTR _idx$[ebp]
  0029b	83 c0 01	 add	 eax, 1
  0029e	89 45 f8	 mov	 DWORD PTR _idx$[ebp], eax
$LN6@I_InitMIDI:
  002a1	83 7d f8 02	 cmp	 DWORD PTR _idx$[ebp], 2
  002a5	73 18		 jae	 SHORT $LN5@I_InitMIDI

; 1371 : 		ZeroMemory(&ciStreamBuffers[idx].mhBuffer, sizeof (MIDIHDR));

  002a7	6a 40		 push	 64			; 00000040H
  002a9	6a 00		 push	 0
  002ab	6b 45 f8 54	 imul	 eax, DWORD PTR _idx$[ebp], 84
  002af	05 00 00 00 00	 add	 eax, OFFSET _ciStreamBuffers
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 _memset
  002ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bd	eb d9		 jmp	 SHORT $LN4@I_InitMIDI
$LN5@I_InitMIDI:

; 1372 : 	// ----------------------------------------------------------------------
; 1373 : 
; 1374 : 	// register exit code
; 1375 : 	I_AddExitFunc(I_ShutdownMIDIMusic);

  002bf	68 00 00 00 00	 push	 OFFSET _I_ShutdownMIDIMusic
  002c4	e8 00 00 00 00	 call	 _I_AddExitFunc
  002c9	83 c4 04	 add	 esp, 4

; 1376 : 
; 1377 : 	bMusicStarted = true;

  002cc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bMusicStarted, 1
$LN1@I_InitMIDI:

; 1378 : }

  002d6	5f		 pop	 edi
  002d7	5e		 pop	 esi
  002d8	5b		 pop	 ebx
  002d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002dc	33 cd		 xor	 ecx, ebp
  002de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
  002e7	90		 npad	 1
$LN30@I_InitMIDI:
  002e8	00 00 00 00	 DD	 $LN17@I_InitMIDI
  002ec	00 00 00 00	 DD	 $LN19@I_InitMIDI
  002f0	00 00 00 00	 DD	 $LN18@I_InitMIDI
  002f4	00 00 00 00	 DD	 $LN15@I_InitMIDI
  002f8	00 00 00 00	 DD	 $LN16@I_InitMIDI
_I_InitMIDIMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_ResumeSong
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_I_ResumeSong PROC					; COMDAT

; 1674 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1675 : 	UNREFERENCED_PARAMETER(handle);
; 1676 : #ifdef FMODSOUND
; 1677 : 	if (!nodigimusic && fmod375)
; 1678 : 	{
; 1679 : 		if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_CHANNEL_ALLOC && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER)
; 1680 : 			if (devparm) I_OutputMsg("FMOD(Resume,Unknown): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1681 : 		if (mod != NULL)
; 1682 : 		{
; 1683 : 			if (fmod375->FMUSIC_GetPaused(mod))
; 1684 : 				if (!fmod375->FMUSIC_SetPaused(mod, false))
; 1685 : 					if (devparm) I_OutputMsg("FMOD(Resume,FMUSIC_SetPaused): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1686 : 		}
; 1687 : 		if (fmus != NULL)
; 1688 : 		{
; 1689 : 			if (fmod375->FSOUND_GetPaused(fsoundchannel))
; 1690 : 				if (!fmod375->FSOUND_SetPaused(fsoundchannel, false))
; 1691 : 					if (devparm) I_OutputMsg("FMOD(Resume,FSOUND_SetPaused): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1692 : 		}
; 1693 : 	}
; 1694 : #endif
; 1695 : 
; 1696 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 02		 je	 SHORT $LN2@I_ResumeSo

; 1697 : 		return;

  00012	eb 20		 jmp	 SHORT $LN3@I_ResumeSo
$LN2@I_ResumeSo:

; 1698 : 
; 1699 : #ifdef DEBUGMIDISTREAM
; 1700 : 	CONS_Printf("I_ResumeSong: \n");
; 1701 : #endif
; 1702 : 
; 1703 : 	if (bMidiPaused)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPaused, 0
  0001b	74 17		 je	 SHORT $LN3@I_ResumeSo

; 1704 : 	{
; 1705 : 		midiStreamRestart(hStream);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamRestart@4
  00029	90		 npad	 1

; 1706 : 		bMidiPaused = false;

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bMidiPaused, 0
$LN3@I_ResumeSo:

; 1707 : 	}
; 1708 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_I_ResumeSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_PauseSong
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_I_PauseSong PROC					; COMDAT

; 1632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1633 : 	UNREFERENCED_PARAMETER(handle);
; 1634 : #ifdef FMODSOUND
; 1635 : 	if (!nodigimusic && fmod375)
; 1636 : 	{
; 1637 : 		if (fmod375->FSOUND_GetError() != FMOD_ERR_NONE && fmod375->FSOUND_GetError() != FMOD_ERR_CHANNEL_ALLOC && fmod375->FSOUND_GetError() != FMOD_ERR_MEDIAPLAYER)
; 1638 : 			if (devparm) I_OutputMsg("FMOD(Pause,Unknown): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1639 : 		if (mod)
; 1640 : 		{
; 1641 : 			if (!fmod375->FMUSIC_GetPaused(mod))
; 1642 : 				if (!fmod375->FMUSIC_SetPaused(mod, true))
; 1643 : 					if (devparm) I_OutputMsg("FMOD(Pause,FMUSIC_SetPaused): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1644 : 		}
; 1645 : 		if (fmus)
; 1646 : 		{
; 1647 : 			if (!fmod375->FSOUND_GetPaused(fsoundchannel))
; 1648 : 				if (!fmod375->FSOUND_SetPaused(fsoundchannel, true))
; 1649 : 					if (devparm) I_OutputMsg("FMOD(Pause,FSOUND_SetPaused): %s\n", FMOD_ErrorString(fmod375->FSOUND_GetError()));
; 1650 : 		}
; 1651 : 	}
; 1652 : #endif
; 1653 : 
; 1654 : 	if (nomidimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  00010	74 02		 je	 SHORT $LN2@I_PauseSon

; 1655 : 		return;

  00012	eb 20		 jmp	 SHORT $LN3@I_PauseSon
$LN2@I_PauseSon:

; 1656 : 
; 1657 : #ifdef DEBUGMIDISTREAM
; 1658 : 	CONS_Printf("I_PauseSong: \n");
; 1659 : #endif
; 1660 : 
; 1661 : 	if (!bMidiPaused)

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPaused, 0
  0001b	75 17		 jne	 SHORT $LN3@I_PauseSon

; 1662 : 	{
; 1663 : 		midiStreamPause(hStream);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _hStream
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiStreamPause@4
  00029	90		 npad	 1

; 1664 : 		bMidiPaused = true;

  0002a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bMidiPaused, 1
$LN3@I_PauseSon:

; 1665 : 	}
; 1666 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_I_PauseSong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_ShutdownMusic
_TEXT	SEGMENT
_I_ShutdownMusic PROC					; COMDAT

; 1486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1487 : 	if (!nodigimusic)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodigimusic, 0
  00010	75 06		 jne	 SHORT $LN2@I_Shutdown

; 1488 : 		I_ShutdownDigMusic();

  00012	e8 00 00 00 00	 call	 _I_ShutdownDigMusic
  00017	90		 npad	 1
$LN2@I_Shutdown:

; 1489 : 
; 1490 : 	if (!nomidimusic)

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nomidimusic, 0
  0001f	75 06		 jne	 SHORT $LN3@I_Shutdown

; 1491 : 		I_ShutdownMIDIMusic();

  00021	e8 00 00 00 00	 call	 _I_ShutdownMIDIMusic
  00026	90		 npad	 1
$LN3@I_Shutdown:

; 1492 : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_I_ShutdownMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_InitMusic
_TEXT	SEGMENT
_I_InitMusic PROC					; COMDAT

; 1384 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1385 : 	I_InitDigMusic();

  00009	e8 00 00 00 00	 call	 _I_InitDigMusic
  0000e	90		 npad	 1

; 1386 : 	I_InitMIDIMusic();

  0000f	e8 00 00 00 00	 call	 _I_InitMIDIMusic
  00014	90		 npad	 1

; 1387 : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_I_InitMusic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_SetSfxVolume
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_vol$ = -4						; size = 4
_volume$ = 8						; size = 4
_I_SetSfxVolume PROC					; COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 423  : 	LONG    vol;
; 424  : 	HRESULT hr;
; 425  : 
; 426  : 	if (nosound || !sound_started)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  00010	75 0b		 jne	 SHORT $LN3@I_SetSfxVo
  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _sound_started
  00019	85 c0		 test	 eax, eax
  0001b	75 02		 jne	 SHORT $LN2@I_SetSfxVo
$LN3@I_SetSfxVo:

; 427  : 		return;

  0001d	eb 41		 jmp	 SHORT $LN1@I_SetSfxVo
$LN2@I_SetSfxVo:

; 428  : 
; 429  : 	// use the last quarter of volume range
; 430  : 	if (volume)

  0001f	83 7d 08 00	 cmp	 DWORD PTR _volume$[ebp], 0
  00023	74 19		 je	 SHORT $LN4@I_SetSfxVo

; 431  : 		vol = (volume * ((DSBVOLUME_MAX-DSBVOLUME_MIN)/4)) / 31 +

  00025	69 45 08 c4 09
	00 00		 imul	 eax, DWORD PTR _volume$[ebp], 2500
  0002c	99		 cdq
  0002d	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00032	f7 f9		 idiv	 ecx
  00034	2d c4 09 00 00	 sub	 eax, 2500		; 000009c4H
  00039	89 45 fc	 mov	 DWORD PTR _vol$[ebp], eax
  0003c	eb 07		 jmp	 SHORT $LN5@I_SetSfxVo
$LN4@I_SetSfxVo:

; 432  : 		      (DSBVOLUME_MAX - ((DSBVOLUME_MAX-DSBVOLUME_MIN)/4));
; 433  : 	else
; 434  : 		vol = DSBVOLUME_MIN;    // make sure 0 is silence

  0003e	c7 45 fc f0 d8
	ff ff		 mov	 DWORD PTR _vol$[ebp], -10000 ; ffffd8f0H
$LN5@I_SetSfxVo:

; 435  : 	//CONS_Printf("setvolume to %d\n", vol);
; 436  : 	hr = IDirectSoundBuffer_SetVolume(DSndPrimary, vol);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _vol$[ebp]
  00048	50		 push	 eax
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DSndPrimary
  0004f	51		 push	 ecx
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DSndPrimary
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0005b	ff d1		 call	 ecx
  0005d	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$LN1@I_SetSfxVo:

; 437  : 	//if (FAILED(hr))
; 438  : 	//    CONS_Printf("setvolumne failed\n");
; 439  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_I_SetSfxVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_UpdateSoundParams
_TEXT	SEGMENT
_surround_inuse$ = -20					; size = 4
_pos$ = -16						; size = 4
_dwStatus$ = -12					; size = 4
_dssurround$ = -8					; size = 4
_dsbuffer$ = -4						; size = 4
_handle$ = 8						; size = 4
_vol$ = 12						; size = 4
_sep$ = 16						; size = 4
_pitch$ = 20						; size = 4
_I_UpdateSoundParams PROC				; COMDAT

; 777  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 778  : 	LPDIRECTSOUNDBUFFER dsbuffer;
; 779  : #ifdef SURROUND
; 780  : 	LPDIRECTSOUNDBUFFER dssurround;
; 781  : 	DWORD               dwStatus;
; 782  : 	DWORD               pos;
; 783  : 	boolean             surround_inuse = FALSE;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _surround_inuse$[ebp], 0

; 784  : #endif
; 785  : 
; 786  : 	if (nosound)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  00017	74 05		 je	 SHORT $LN2@I_UpdateSo

; 787  : 		return;

  00019	e9 0f 01 00 00	 jmp	 $LN10@I_UpdateSo
$LN2@I_UpdateSo:

; 788  : 
; 789  : 	UNREFERENCED_PARAMETER(pitch);
; 790  : 	dsbuffer = StackSounds[handle].lpSndBuf;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00021	c1 e0 04	 shl	 eax, 4
  00024	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax]
  0002a	89 4d fc	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 791  : 
; 792  : 	if (dsbuffer == NULL)

  0002d	83 7d fc 00	 cmp	 DWORD PTR _dsbuffer$[ebp], 0
  00031	75 05		 jne	 SHORT $LN3@I_UpdateSo

; 793  : 		return;

  00033	e9 f5 00 00 00	 jmp	 $LN10@I_UpdateSo
$LN3@I_UpdateSo:

; 794  : 
; 795  : #ifdef SURROUND
; 796  : 	dssurround = StackSounds[handle].lpSurround;

  00038	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  0003b	c1 e0 04	 shl	 eax, 4
  0003e	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax+4]
  00044	89 4d f8	 mov	 DWORD PTR _dssurround$[ebp], ecx

; 797  : 	if (dssurround)

  00047	83 7d f8 00	 cmp	 DWORD PTR _dssurround$[ebp], 0
  0004b	74 1c		 je	 SHORT $LN4@I_UpdateSo

; 798  : 	{
; 799  : 		IDirectSoundBuffer_GetStatus(dssurround, &dwStatus);

  0004d	8d 45 f4	 lea	 eax, DWORD PTR _dwStatus$[ebp]
  00050	50		 push	 eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 f8	 mov	 edx, DWORD PTR _dssurround$[ebp]
  00058	8b 02		 mov	 eax, DWORD PTR [edx]
  0005a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0005d	ff d1		 call	 ecx
  0005f	90		 npad	 1

; 800  : 		surround_inuse = (dwStatus & (DSBSTATUS_PLAYING | DSBSTATUS_LOOPING));

  00060	8b 45 f4	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  00063	83 e0 05	 and	 eax, 5
  00066	89 45 ec	 mov	 DWORD PTR _surround_inuse$[ebp], eax
$LN4@I_UpdateSo:

; 801  : 	}
; 802  : 		// If pan changed to stereo...
; 803  : 	if (sep != -128)

  00069	83 7d 10 80	 cmp	 DWORD PTR _sep$[ebp], -128 ; ffffff80H
  0006d	74 1e		 je	 SHORT $LN5@I_UpdateSo

; 804  : 	{
; 805  : 		if (surround_inuse)

  0006f	83 7d ec 00	 cmp	 DWORD PTR _surround_inuse$[ebp], 0
  00073	74 16		 je	 SHORT $LN7@I_UpdateSo

; 806  : 		{
; 807  : 			IDirectSoundBuffer_Stop(dssurround);

  00075	8b 45 f8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00081	ff d0		 call	 eax
  00083	90		 npad	 1

; 808  : 			surround_inuse = FALSE;

  00084	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _surround_inuse$[ebp], 0
$LN7@I_UpdateSo:

; 809  : 		}
; 810  : 	}

  0008b	eb 7a		 jmp	 SHORT $LN9@I_UpdateSo
$LN5@I_UpdateSo:

; 811  : 	else  if (!surround_inuse) // Just update volumes and start the surround if need

  0008d	83 7d ec 00	 cmp	 DWORD PTR _surround_inuse$[ebp], 0
  00091	75 64		 jne	 SHORT $LN8@I_UpdateSo

; 812  : 	{
; 813  : 		I_UpdateSoundVolume(dssurround, vol);

  00093	8b 45 0c	 mov	 eax, DWORD PTR _vol$[ebp]
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _I_UpdateSoundVolume
  000a0	83 c4 08	 add	 esp, 8

; 814  : 		I_UpdateSoundPanning(dsbuffer, 0);

  000a3	6a 00		 push	 0
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _I_UpdateSoundPanning
  000ae	83 c4 08	 add	 esp, 8

; 815  : 		IDirectSoundBuffer_GetCurrentPosition(dsbuffer, &pos, NULL);

  000b1	6a 00		 push	 0
  000b3	8d 45 f0	 lea	 eax, DWORD PTR _pos$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  000be	8b 02		 mov	 eax, DWORD PTR [edx]
  000c0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c3	ff d1		 call	 ecx
  000c5	90		 npad	 1

; 816  : 		IDirectSoundBuffer_SetCurrentPosition(dssurround, pos);

  000c6	8b 45 f0	 mov	 eax, DWORD PTR _pos$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 f8	 mov	 edx, DWORD PTR _dssurround$[ebp]
  000d1	8b 02		 mov	 eax, DWORD PTR [edx]
  000d3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d6	ff d1		 call	 ecx
  000d8	90		 npad	 1

; 817  : 		IDirectSoundBuffer_Play(dssurround, 0, 0, 0);

  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	6a 00		 push	 0
  000df	8b 45 f8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d f8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  000e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e8	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000eb	ff d0		 call	 eax
  000ed	90		 npad	 1

; 818  : 		surround_inuse = TRUE;

  000ee	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _surround_inuse$[ebp], 1

; 819  : 	}

  000f5	eb 10		 jmp	 SHORT $LN9@I_UpdateSo
$LN8@I_UpdateSo:

; 820  : 	else
; 821  : 		I_UpdateSoundVolume(dssurround, vol);

  000f7	8b 45 0c	 mov	 eax, DWORD PTR _vol$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d f8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _I_UpdateSoundVolume
  00104	83 c4 08	 add	 esp, 8
$LN9@I_UpdateSo:

; 822  : 	I_UpdateSoundVolume(dsbuffer, vol);

  00107	8b 45 0c	 mov	 eax, DWORD PTR _vol$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 _I_UpdateSoundVolume
  00114	83 c4 08	 add	 esp, 8

; 823  : 
; 824  : 	if (!surround_inuse)

  00117	83 7d ec 00	 cmp	 DWORD PTR _surround_inuse$[ebp], 0
  0011b	75 10		 jne	 SHORT $LN10@I_UpdateSo

; 825  : 		I_UpdateSoundPanning(dsbuffer, sep);

  0011d	8b 45 10	 mov	 eax, DWORD PTR _sep$[ebp]
  00120	50		 push	 eax
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 _I_UpdateSoundPanning
  0012a	83 c4 08	 add	 esp, 8
$LN10@I_UpdateSo:

; 826  : #else
; 827  : 	I_UpdateSoundVolume(dsbuffer, vol);
; 828  : 	I_UpdateSoundPanning(dsbuffer, sep);
; 829  : #endif
; 830  : }

  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
_I_UpdateSoundParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_SoundIsPlaying
_TEXT	SEGMENT
_dwStatus$ = -8						; size = 4
_dsbuffer$ = -4						; size = 4
_handle$ = 8						; size = 4
_I_SoundIsPlaying PROC					; COMDAT

; 751  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 752  : 	LPDIRECTSOUNDBUFFER dsbuffer;
; 753  : 	DWORD   dwStatus;
; 754  : 
; 755  : 	if (nosound || handle == -1)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  00010	75 06		 jne	 SHORT $LN3@I_SoundIsP
  00012	83 7d 08 ff	 cmp	 DWORD PTR _handle$[ebp], -1
  00016	75 04		 jne	 SHORT $LN2@I_SoundIsP
$LN3@I_SoundIsP:

; 756  : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 39		 jmp	 SHORT $LN1@I_SoundIsP
$LN2@I_SoundIsP:

; 757  : 
; 758  : 	dsbuffer = StackSounds[handle].lpSndBuf;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  0001f	c1 e0 04	 shl	 eax, 4
  00022	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax]
  00028	89 4d fc	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 759  : 	if (dsbuffer)

  0002b	83 7d fc 00	 cmp	 DWORD PTR _dsbuffer$[ebp], 0
  0002f	74 22		 je	 SHORT $LN5@I_SoundIsP

; 760  : 	{
; 761  : 		IDirectSoundBuffer_GetStatus(dsbuffer, &dwStatus);

  00031	8d 45 f8	 lea	 eax, DWORD PTR _dwStatus$[ebp]
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 fc	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00041	ff d1		 call	 ecx
  00043	90		 npad	 1

; 762  : 		if (dwStatus & (DSBSTATUS_PLAYING | DSBSTATUS_LOOPING))

  00044	8b 45 f8	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  00047	83 e0 05	 and	 eax, 5
  0004a	74 07		 je	 SHORT $LN5@I_SoundIsP

; 763  : 			return TRUE;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	eb 02		 jmp	 SHORT $LN1@I_SoundIsP
$LN5@I_SoundIsP:

; 764  : 	}
; 765  : 
; 766  : 	return FALSE;

  00053	33 c0		 xor	 eax, eax
$LN1@I_SoundIsP:

; 767  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_I_SoundIsPlaying ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_StopSound
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_dsbuffer$ = -4						; size = 4
_handle$ = 8						; size = 4
_I_StopSound PROC					; COMDAT

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 716  : 	LPDIRECTSOUNDBUFFER dsbuffer;
; 717  : 	HRESULT hr;
; 718  : 
; 719  : 	if (nosound || handle < 0)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  00010	75 06		 jne	 SHORT $LN3@I_StopSoun
  00012	83 7d 08 00	 cmp	 DWORD PTR _handle$[ebp], 0
  00016	7d 05		 jge	 SHORT $LN2@I_StopSoun
$LN3@I_StopSoun:

; 720  : 		return;

  00018	e9 91 00 00 00	 jmp	 $LN1@I_StopSoun
$LN2@I_StopSoun:

; 721  : 
; 722  : 	dsbuffer = StackSounds[handle].lpSndBuf;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00020	c1 e0 04	 shl	 eax, 4
  00023	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax]
  00029	89 4d fc	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 723  : 	hr = IDirectSoundBuffer_Stop(dsbuffer);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00038	ff d0		 call	 eax
  0003a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  : 	// free duplicates of original sound buffer (DirectSound hassles)
; 726  : 	if (StackSounds[handle].duplicate)

  0003d	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00040	c1 e0 04	 shl	 eax, 4
  00043	83 b8 0c 00 00
	00 00		 cmp	 DWORD PTR _StackSounds[eax+12], 0
  0004a	74 0f		 je	 SHORT $LN4@I_StopSoun

; 727  : 	{
; 728  : 		//CONS_Printf("\t\trelease a duplicate..\n");
; 729  : 		IDirectSoundBuffer_Release(dsbuffer);

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00058	ff d0		 call	 eax
  0005a	90		 npad	 1
$LN4@I_StopSoun:

; 730  : 	}
; 731  : 
; 732  : #ifdef SURROUND
; 733  : 	// Stop and release the surround sound buffer
; 734  : 	dsbuffer = StackSounds[handle].lpSurround;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  0005e	c1 e0 04	 shl	 eax, 4
  00061	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax+4]
  00067	89 4d fc	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 735  : 	if (dsbuffer != NULL)

  0006a	83 7d fc 00	 cmp	 DWORD PTR _dsbuffer$[ebp], 0
  0006e	74 1e		 je	 SHORT $LN5@I_StopSoun

; 736  : 	{
; 737  : 		IDirectSoundBuffer_Stop(dsbuffer);

  00070	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00077	8b 11		 mov	 edx, DWORD PTR [ecx]
  00079	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0007c	ff d0		 call	 eax
  0007e	90		 npad	 1

; 738  : 		IDirectSoundBuffer_Release(dsbuffer);

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00082	50		 push	 eax
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00086	8b 11		 mov	 edx, DWORD PTR [ecx]
  00088	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008b	ff d0		 call	 eax
  0008d	90		 npad	 1
$LN5@I_StopSoun:

; 739  : 	}
; 740  : 	StackSounds[handle].lpSurround = NULL;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00091	c1 e0 04	 shl	 eax, 4
  00094	c7 80 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StackSounds[eax+4], 0

; 741  : #endif
; 742  : 
; 743  : 	StackSounds[handle].lpSndBuf = NULL;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  000a1	c1 e0 04	 shl	 eax, 4
  000a4	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StackSounds[eax], 0
$LN1@I_StopSoun:

; 744  : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
_I_StopSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_StartSound
_TEXT	SEGMENT
tv148 = -108						; size = 4
_lumpnum$1 = -40					; size = 4
_dsdata$2 = -36						; size = 4
_lumpnum$3 = -32					; size = 4
_dsdata$4 = -28						; size = 4
_dssurround$ = -24					; size = 4
_i$ = -20						; size = 4
_handle$ = -16						; size = 4
_dwStatus$ = -12					; size = 4
_dsbuffer$ = -8						; size = 4
_hr$ = -4						; size = 4
_id$ = 8						; size = 4
_vol$ = 12						; size = 4
_sep$ = 16						; size = 4
_pitch$ = 20						; size = 4
_priority$ = 24						; size = 4
_I_StartSound PROC					; COMDAT

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 549  : 	HRESULT     hr;
; 550  : 	LPDIRECTSOUNDBUFFER     dsbuffer;
; 551  : 	DWORD       dwStatus;
; 552  : 	int         handle;
; 553  : 	int         i;
; 554  : #ifdef SURROUND
; 555  : 	LPDIRECTSOUNDBUFFER     dssurround;
; 556  : #endif
; 557  : 
; 558  : 	if (nosound)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  00010	74 08		 je	 SHORT $LN5@I_StartSou

; 559  : 		return -1;

  00012	83 c8 ff	 or	 eax, -1
  00015	e9 53 03 00 00	 jmp	 $LN1@I_StartSou
$LN5@I_StartSou:

; 560  : 
; 561  : 	//CONS_Printf("I_StartSound:\n\t\tS_sfx[%d]\n", id);
; 562  : 	handle = GetFreeStackNum(priority);

  0001a	8b 45 18	 mov	 eax, DWORD PTR _priority$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _GetFreeStackNum
  00023	83 c4 04	 add	 esp, 4
  00026	89 45 f0	 mov	 DWORD PTR _handle$[ebp], eax

; 563  : 	if (handle < 0)

  00029	83 7d f0 00	 cmp	 DWORD PTR _handle$[ebp], 0
  0002d	7d 08		 jge	 SHORT $LN6@I_StartSou

; 564  : 		return -1;

  0002f	83 c8 ff	 or	 eax, -1
  00032	e9 36 03 00 00	 jmp	 $LN1@I_StartSou
$LN6@I_StartSou:

; 565  : 
; 566  : 	//CONS_Printf("\t\tusing handle %d\n", handle);
; 567  : 
; 568  : 	// if the original buffer is playing, duplicate it (DirectSound specific)
; 569  : 	// else, use the original buffer
; 570  : 	dsbuffer = (LPDIRECTSOUNDBUFFER)S_sfx[id].data;

  00037	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  0003b	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+20]
  00041	89 4d f8	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 571  : 	IDirectSoundBuffer_GetStatus(dsbuffer, &dwStatus);

  00044	8d 45 f4	 lea	 eax, DWORD PTR _dwStatus$[ebp]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 f8	 mov	 edx, DWORD PTR _dsbuffer$[ebp]
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00054	ff d1		 call	 ecx
  00056	90		 npad	 1

; 572  : 	if (dwStatus & (DSBSTATUS_PLAYING | DSBSTATUS_LOOPING))

  00057	8b 45 f4	 mov	 eax, DWORD PTR _dwStatus$[ebp]
  0005a	83 e0 05	 and	 eax, 5
  0005d	0f 84 8a 00 00
	00		 je	 $LN7@I_StartSou

; 573  : 	{
; 574  : 		//CONS_Printf("\t\toriginal sound S_sfx[%d] is playing, duplicating.. ", id);
; 575  : 		hr = IDirectSound_DuplicateSoundBuffer(DSnd,  (LPDIRECTSOUNDBUFFER)S_sfx[id].data, &dsbuffer);

  00063	8d 45 f8	 lea	 eax, DWORD PTR _dsbuffer$[ebp]
  00066	50		 push	 eax
  00067	6b 4d 08 2c	 imul	 ecx, DWORD PTR _id$[ebp], 44
  0006b	8b 91 14 00 00
	00		 mov	 edx, DWORD PTR _S_sfx[ecx+20]
  00071	52		 push	 edx
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  00077	50		 push	 eax
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DSnd
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00083	ff d0		 call	 eax
  00085	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 576  : 		if (FAILED(hr))

  00088	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0008c	7d 50		 jge	 SHORT $LN3@I_StartSou

; 577  : 		{
; 578  : 			//CONS_Printf("Cound't duplicate sound buffer\n");
; 579  : 			// re-use the original then..
; 580  : 			dsbuffer = (LPDIRECTSOUNDBUFFER)S_sfx[id].data;

  0008e	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  00092	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+20]
  00098	89 4d f8	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 581  : 			// clean up stacksounds info
; 582  : 			for (i = 0; i < MAXSTACKSOUNDS; i++)

  0009b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a2	eb 09		 jmp	 SHORT $LN4@I_StartSou
$LN2@I_StartSou:
  000a4	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_StartSou:
  000ad	83 7d ec 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000b1	7d 2b		 jge	 SHORT $LN3@I_StartSou

; 583  : 				if (handle != i &&

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _handle$[ebp]
  000b6	3b 45 ec	 cmp	 eax, DWORD PTR _i$[ebp]
  000b9	74 21		 je	 SHORT $LN9@I_StartSou
  000bb	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000be	c1 e0 04	 shl	 eax, 4
  000c1	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax]
  000c7	3b 4d f8	 cmp	 ecx, DWORD PTR _dsbuffer$[ebp]
  000ca	75 10		 jne	 SHORT $LN9@I_StartSou

; 584  : 					StackSounds[i].lpSndBuf == dsbuffer)
; 585  : 				{
; 586  : 					StackSounds[i].lpSndBuf = NULL;

  000cc	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	c1 e0 04	 shl	 eax, 4
  000d2	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StackSounds[eax], 0
$LN9@I_StartSou:

; 587  : 				}

  000dc	eb c6		 jmp	 SHORT $LN2@I_StartSou
$LN3@I_StartSou:

; 588  : 		}
; 589  : 		// stop the duplicate or the re-used original
; 590  : 		IDirectSoundBuffer_Stop(dsbuffer);

  000de	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000ea	ff d0		 call	 eax
  000ec	90		 npad	 1
$LN7@I_StartSou:

; 591  : 	}
; 592  : 
; 593  : 	//judgecutor: Sound pitching
; 594  : #if 0
; 595  : 	if (cv_rndsoundpitch.value)
; 596  : 	{
; 597  : 		// At first reset the buffer back to original frequency
; 598  : 		hr = IDirectSoundBuffer_SetFrequency(dsbuffer, DSBFREQUENCY_ORIGINAL);
; 599  : 		if (SUCCEEDED(hr))
; 600  : 		{
; 601  : 			DWORD freq;
; 602  : 			IDirectSoundBuffer_GetFrequency(dsbuffer, &freq);
; 603  : 
; 604  : 			// Now pitch it
; 605  : 			freq *= recalc_pitch(pitch);
; 606  : 			IDirectSoundBuffer_SetFrequency(dsbuffer, freq);
; 607  : 		}
; 608  : 		else
; 609  : 			cv_rndsoundpitch = 0;
; 610  : 	}
; 611  : #else
; 612  : 	UNREFERENCED_PARAMETER(pitch);
; 613  : #endif
; 614  : 	// store information on the playing sound
; 615  : 	StackSounds[handle].lpSndBuf = dsbuffer;

  000ed	8b 45 f0	 mov	 eax, DWORD PTR _handle$[ebp]
  000f0	c1 e0 04	 shl	 eax, 4
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000f6	89 88 00 00 00
	00		 mov	 DWORD PTR _StackSounds[eax], ecx

; 616  : 	StackSounds[handle].priority = priority;

  000fc	8b 45 f0	 mov	 eax, DWORD PTR _handle$[ebp]
  000ff	c1 e0 04	 shl	 eax, 4
  00102	8b 4d 18	 mov	 ecx, DWORD PTR _priority$[ebp]
  00105	89 88 08 00 00
	00		 mov	 DWORD PTR _StackSounds[eax+8], ecx

; 617  : 	StackSounds[handle].duplicate = (dsbuffer != (LPDIRECTSOUNDBUFFER)S_sfx[id].data);

  0010b	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00112	3b 88 14 00 00
	00		 cmp	 ecx, DWORD PTR _S_sfx[eax+20]
  00118	74 09		 je	 SHORT $LN22@I_StartSou
  0011a	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv148[ebp], 1
  00121	eb 07		 jmp	 SHORT $LN23@I_StartSou
$LN22@I_StartSou:
  00123	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv148[ebp], 0
$LN23@I_StartSou:
  0012a	8b 55 f0	 mov	 edx, DWORD PTR _handle$[ebp]
  0012d	c1 e2 04	 shl	 edx, 4
  00130	8b 45 94	 mov	 eax, DWORD PTR tv148[ebp]
  00133	89 82 0c 00 00
	00		 mov	 DWORD PTR _StackSounds[edx+12], eax

; 618  : 
; 619  : 	//CONS_Printf("StackSounds[%d].lpSndBuf is %s\n", handle, StackSounds[handle].lpSndBuf == NULL ? "Null":"valid");
; 620  : 	//CONS_Printf("StackSounds[%d].priority is %d\n", handle, StackSounds[handle].priority);
; 621  : 	//CONS_Printf("StackSounds[%d].duplicate is %s\n", handle, StackSounds[handle].duplicate ? "TRUE":"FALSE");
; 622  : 
; 623  : 	I_UpdateSoundVolume(dsbuffer, vol);

  00139	8b 45 0c	 mov	 eax, DWORD PTR _vol$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _I_UpdateSoundVolume
  00146	83 c4 08	 add	 esp, 8

; 624  : 
; 625  : #ifdef SURROUND
; 626  : 		// Prepare the surround sound buffer
; 627  : 	// Use a normal sound data for the left channel (with pan == 0)
; 628  : 	// and an inverted sound data for the right channel (with pan == 255)
; 629  : 
; 630  : 	dssurround = CreateInvertedSound(id);

  00149	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _CreateInvertedSound
  00152	83 c4 04	 add	 esp, 4
  00155	89 45 e8	 mov	 DWORD PTR _dssurround$[ebp], eax

; 631  : 
; 632  : 	// Surround must be pitched too
; 633  : #if 0
; 634  : 	if (cv_rndsoundpitch.value)
; 635  : 		IDirectSoundBuffer_SetFrequency(dssurround, freq);
; 636  : #endif
; 637  : 	if (sep == -128)

  00158	83 7d 10 80	 cmp	 DWORD PTR _sep$[ebp], -128 ; ffffff80H
  0015c	75 42		 jne	 SHORT $LN10@I_StartSou

; 638  : 	{
; 639  : 		I_UpdateSoundPanning(dssurround, 255);

  0015e	68 ff 00 00 00	 push	 255			; 000000ffH
  00163	8b 45 e8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _I_UpdateSoundPanning
  0016c	83 c4 08	 add	 esp, 8

; 640  : 		I_UpdateSoundVolume(dssurround, vol);

  0016f	8b 45 0c	 mov	 eax, DWORD PTR _vol$[ebp]
  00172	50		 push	 eax
  00173	8b 4d e8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _I_UpdateSoundVolume
  0017c	83 c4 08	 add	 esp, 8

; 641  : 		I_UpdateSoundPanning(dsbuffer, 0);

  0017f	6a 00		 push	 0
  00181	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _I_UpdateSoundPanning
  0018a	83 c4 08	 add	 esp, 8

; 642  : 		IDirectSoundBuffer_SetCurrentPosition(dssurround, 0);

  0018d	6a 00		 push	 0
  0018f	8b 45 e8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  00192	50		 push	 eax
  00193	8b 4d e8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  00196	8b 11		 mov	 edx, DWORD PTR [ecx]
  00198	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0019b	ff d0		 call	 eax
  0019d	90		 npad	 1

; 643  : 	}

  0019e	eb 10		 jmp	 SHORT $LN11@I_StartSou
$LN10@I_StartSou:

; 644  : 		else
; 645  : 	// Perform normal operation
; 646  : #endif
; 647  : 
; 648  : 	I_UpdateSoundPanning(dsbuffer, sep);

  001a0	8b 45 10	 mov	 eax, DWORD PTR _sep$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 _I_UpdateSoundPanning
  001ad	83 c4 08	 add	 esp, 8
$LN11@I_StartSou:

; 649  : 
; 650  : 	IDirectSoundBuffer_SetCurrentPosition(dsbuffer, 0);

  001b0	6a 00		 push	 0
  001b2	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  001b5	50		 push	 eax
  001b6	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  001b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bb	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  001be	ff d0		 call	 eax
  001c0	90		 npad	 1

; 651  : 
; 652  : 	hr = IDirectSoundBuffer_Play(dsbuffer, 0, 0, 0);

  001c1	6a 00		 push	 0
  001c3	6a 00		 push	 0
  001c5	6a 00		 push	 0
  001c7	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  001ca	50		 push	 eax
  001cb	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  001ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d0	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  001d3	ff d0		 call	 eax
  001d5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 653  : 	if (hr == DSERR_BUFFERLOST)

  001d8	81 7d fc 96 00
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005401450 ; 88780096H
  001df	0f 85 a4 00 00
	00		 jne	 $LN14@I_StartSou

; 654  : 	{
; 655  : 		//CONS_Printf("buffer lost\n");
; 656  : 		// restores the buffer memory and all other settings for the buffer
; 657  : 		hr = IDirectSoundBuffer_Restore(dsbuffer);

  001e5	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  001ec	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ee	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  001f1	ff d0		 call	 eax
  001f3	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 658  : 		if (SUCCEEDED (hr))

  001f6	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001fa	7c 73		 jl	 SHORT $LN13@I_StartSou

; 659  : 		{
; 660  : 			LPBYTE dsdata;
; 661  : 			// reload sample data here
; 662  : 			lumpnum_t lumpnum = S_sfx[id].lumpnum;

  001fc	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  00200	8b 88 24 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+36]
  00206	89 4d e0	 mov	 DWORD PTR _lumpnum$3[ebp], ecx

; 663  : 			if (lumpnum == LUMPERROR)

  00209	83 7d e0 ff	 cmp	 DWORD PTR _lumpnum$3[ebp], -1
  0020d	75 15		 jne	 SHORT $LN15@I_StartSou

; 664  : 				lumpnum = S_GetSfxLumpNum(&S_sfx[id]);

  0020f	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  00213	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _S_GetSfxLumpNum
  0021e	83 c4 04	 add	 esp, 4
  00221	89 45 e0	 mov	 DWORD PTR _lumpnum$3[ebp], eax
$LN15@I_StartSou:

; 665  : 			dsdata = W_CacheLumpNum(lumpnum, PU_CACHE);

  00224	6a 65		 push	 101			; 00000065H
  00226	8b 45 e0	 mov	 eax, DWORD PTR _lumpnum$3[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0022f	83 c4 08	 add	 esp, 8
  00232	89 45 e4	 mov	 DWORD PTR _dsdata$4[ebp], eax

; 666  : 
; 667  : 			// Well... Data lenght must be -8!!!
; 668  : 			CopySoundData(dsbuffer, dsdata + 8, (DWORD)(S_sfx[id].length - 8));

  00235	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  00239	8b 88 18 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+24]
  0023f	83 e9 08	 sub	 ecx, 8
  00242	51		 push	 ecx
  00243	8b 55 e4	 mov	 edx, DWORD PTR _dsdata$4[ebp]
  00246	83 c2 08	 add	 edx, 8
  00249	52		 push	 edx
  0024a	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 _CopySoundData
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH

; 669  : 
; 670  : 			// play
; 671  : 			hr = IDirectSoundBuffer_Play(dsbuffer, 0, 0, 0);

  00256	6a 00		 push	 0
  00258	6a 00		 push	 0
  0025a	6a 00		 push	 0
  0025c	8b 45 f8	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  0025f	50		 push	 eax
  00260	8b 4d f8	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  00263	8b 11		 mov	 edx, DWORD PTR [ecx]
  00265	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00268	ff d0		 call	 eax
  0026a	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 672  : 		}

  0026d	eb 1a		 jmp	 SHORT $LN14@I_StartSou
$LN13@I_StartSou:

; 673  : 		else
; 674  : 			I_Error("I_StartSound : ->Restore FAILED, %s",DXErrorToString(hr));

  0026f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _DXErrorToString
  00278	83 c4 04	 add	 esp, 4
  0027b	50		 push	 eax
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PIABFBFE@I_StartSound?5?3?5?9?$DORestore?5FAILED@
  00281	e8 00 00 00 00	 call	 _I_Error
  00286	83 c4 08	 add	 esp, 8
$LN14@I_StartSou:

; 675  : 	}
; 676  : 
; 677  : #ifdef SURROUND
; 678  : 	if (sep == -128)

  00289	83 7d 10 80	 cmp	 DWORD PTR _sep$[ebp], -128 ; ffffff80H
  0028d	0f 85 c8 00 00
	00		 jne	 $LN19@I_StartSou

; 679  : 	{
; 680  : 		hr = IDirectSoundBuffer_Play(dssurround, 0, 0, 0);

  00293	6a 00		 push	 0
  00295	6a 00		 push	 0
  00297	6a 00		 push	 0
  00299	8b 45 e8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  0029c	50		 push	 eax
  0029d	8b 4d e8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  002a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  002a2	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  002a5	ff d0		 call	 eax
  002a7	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 681  : 		//CONS_Printf("Surround playback\n");
; 682  : 		if (hr == DSERR_BUFFERLOST)

  002aa	81 7d fc 96 00
	78 88		 cmp	 DWORD PTR _hr$[ebp], -2005401450 ; 88780096H
  002b1	0f 85 a4 00 00
	00		 jne	 $LN19@I_StartSou

; 683  : 		{
; 684  : 			// restores the buffer memory and all other settings for the surround buffer
; 685  : 			hr = IDirectSoundBuffer_Restore(dssurround);

  002b7	8b 45 e8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  002ba	50		 push	 eax
  002bb	8b 4d e8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  002be	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c0	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  002c3	ff d0		 call	 eax
  002c5	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 686  : 			if (SUCCEEDED (hr))

  002c8	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002cc	7c 73		 jl	 SHORT $LN18@I_StartSou

; 687  : 			{
; 688  : 				LPBYTE *dsdata;
; 689  : 				lumpnum_t lumpnum = S_sfx[id].lumpnum;

  002ce	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  002d2	8b 88 24 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+36]
  002d8	89 4d d8	 mov	 DWORD PTR _lumpnum$1[ebp], ecx

; 690  : 
; 691  : 				if (lumpnum == LUMPERROR)

  002db	83 7d d8 ff	 cmp	 DWORD PTR _lumpnum$1[ebp], -1
  002df	75 15		 jne	 SHORT $LN20@I_StartSou

; 692  : 					lumpnum = S_GetSfxLumpNum(&S_sfx[id]);

  002e1	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  002e5	05 00 00 00 00	 add	 eax, OFFSET _S_sfx
  002ea	50		 push	 eax
  002eb	e8 00 00 00 00	 call	 _S_GetSfxLumpNum
  002f0	83 c4 04	 add	 esp, 4
  002f3	89 45 d8	 mov	 DWORD PTR _lumpnum$1[ebp], eax
$LN20@I_StartSou:

; 693  : 				dsdata = W_CacheLumpNum(lumpnum, PU_CACHE);

  002f6	6a 65		 push	 101			; 00000065H
  002f8	8b 45 d8	 mov	 eax, DWORD PTR _lumpnum$1[ebp]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00301	83 c4 08	 add	 esp, 8
  00304	89 45 dc	 mov	 DWORD PTR _dsdata$2[ebp], eax

; 694  : 				CopyAndInvertSoundData(dssurround, (LPBYTE)dsdata + 8, (DWORD)(S_sfx[id].length - 8));

  00307	6b 45 08 2c	 imul	 eax, DWORD PTR _id$[ebp], 44
  0030b	8b 88 18 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+24]
  00311	83 e9 08	 sub	 ecx, 8
  00314	51		 push	 ecx
  00315	8b 55 dc	 mov	 edx, DWORD PTR _dsdata$2[ebp]
  00318	83 c2 08	 add	 edx, 8
  0031b	52		 push	 edx
  0031c	8b 45 e8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  0031f	50		 push	 eax
  00320	e8 00 00 00 00	 call	 _CopyAndInvertSoundData
  00325	83 c4 0c	 add	 esp, 12			; 0000000cH

; 695  : 
; 696  : 				hr = IDirectSoundBuffer_Play(dssurround, 0, 0, 0);

  00328	6a 00		 push	 0
  0032a	6a 00		 push	 0
  0032c	6a 00		 push	 0
  0032e	8b 45 e8	 mov	 eax, DWORD PTR _dssurround$[ebp]
  00331	50		 push	 eax
  00332	8b 4d e8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  00335	8b 11		 mov	 edx, DWORD PTR [ecx]
  00337	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0033a	ff d0		 call	 eax
  0033c	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 697  : 			}

  0033f	eb 1a		 jmp	 SHORT $LN19@I_StartSou
$LN18@I_StartSou:

; 698  : 			else
; 699  : 				I_Error("I_StartSound : ->Restore FAILED, %s",DXErrorToString(hr));

  00341	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00344	50		 push	 eax
  00345	e8 00 00 00 00	 call	 _DXErrorToString
  0034a	83 c4 04	 add	 esp, 4
  0034d	50		 push	 eax
  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PIABFBFE@I_StartSound?5?3?5?9?$DORestore?5FAILED@
  00353	e8 00 00 00 00	 call	 _I_Error
  00358	83 c4 08	 add	 esp, 8
$LN19@I_StartSou:

; 700  : 		}
; 701  : 	}
; 702  : 	StackSounds[handle].lpSurround = dssurround;

  0035b	8b 45 f0	 mov	 eax, DWORD PTR _handle$[ebp]
  0035e	c1 e0 04	 shl	 eax, 4
  00361	8b 4d e8	 mov	 ecx, DWORD PTR _dssurround$[ebp]
  00364	89 88 04 00 00
	00		 mov	 DWORD PTR _StackSounds[eax+4], ecx

; 703  : #endif
; 704  : 
; 705  : 	// Returns a handle
; 706  : 	return handle;

  0036a	8b 45 f0	 mov	 eax, DWORD PTR _handle$[ebp]
$LN1@I_StartSou:

; 707  : }

  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi
  0036f	5b		 pop	 ebx
  00370	8b e5		 mov	 esp, ebp
  00372	5d		 pop	 ebp
  00373	c3		 ret	 0
_I_StartSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_ShutdownSound
_TEXT	SEGMENT
_i$ = -4						; size = 4
_I_ShutdownSound PROC					; COMDAT

; 862  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 863  : 	int i;
; 864  : 
; 865  : 	CONS_Printf("I_ShutdownSound()\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MHGMIPHA@I_ShutdownSound?$CI?$CJ?6@
  0000e	e8 00 00 00 00	 call	 _CONS_Printf
  00013	83 c4 04	 add	 esp, 4

; 866  : 
; 867  : #ifdef HW3SOUND
; 868  : 	if (hws_mode != HWS_DEFAULT_MODE)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  0001d	74 0e		 je	 SHORT $LN5@I_Shutdown

; 869  : 	{
; 870  : 		HW3S_Shutdown();

  0001f	e8 00 00 00 00	 call	 _HW3S_Shutdown
  00024	90		 npad	 1

; 871  : 		Shutdown3DSDriver();

  00025	e8 00 00 00 00	 call	 _Shutdown3DSDriver
  0002a	90		 npad	 1

; 872  : 		return;

  0002b	eb 62		 jmp	 SHORT $LN1@I_Shutdown
$LN5@I_Shutdown:

; 873  : 	}
; 874  : #endif
; 875  : 	// release any temporary 'duplicated' secondary buffers
; 876  : 	for (i = 0; i < MAXSTACKSOUNDS; i++)

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@I_Shutdown
$LN2@I_Shutdown:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_Shutdown:
  0003f	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00043	7d 1d		 jge	 SHORT $LN3@I_Shutdown

; 877  : 		if (StackSounds[i].lpSndBuf)

  00045	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00048	c1 e0 04	 shl	 eax, 4
  0004b	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _StackSounds[eax], 0
  00052	74 0c		 je	 SHORT $LN6@I_Shutdown

; 878  : 			// stops the sound and release it if it is a duplicate
; 879  : 			I_StopSound (i);

  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _I_StopSound
  0005d	83 c4 04	 add	 esp, 4
$LN6@I_Shutdown:
  00060	eb d4		 jmp	 SHORT $LN2@I_Shutdown
$LN3@I_Shutdown:

; 880  : 
; 881  : 	if (DSnd)

  00062	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _DSnd, 0
  00069	74 1e		 je	 SHORT $LN7@I_Shutdown

; 882  : 	{
; 883  : 		IDirectSound_Release(DSnd);

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  00070	50		 push	 eax
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DSnd
  00077	8b 11		 mov	 edx, DWORD PTR [ecx]
  00079	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007c	ff d0		 call	 eax
  0007e	90		 npad	 1

; 884  : 		DSnd = NULL;

  0007f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DSnd, 0
$LN7@I_Shutdown:

; 885  : 	}
; 886  : 	UnLoadDirectSound();

  00089	e8 00 00 00 00	 call	 _UnLoadDirectSound
  0008e	90		 npad	 1
$LN1@I_Shutdown:

; 887  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_I_ShutdownSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_StartupSound
_TEXT	SEGMENT
tv236 = -152						; size = 4
_snddev$ = -84						; size = 20
_sdrv_name$ = -64					; size = 4
_frequency$ = -60					; size = 4
_cooplevel$ = -56					; size = 4
_wfm$ = -52						; size = 18
_dsbdesc$ = -32						; size = 20
_lpDsb$ = -12						; size = 4
_hr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_I_StartupSound PROC					; COMDAT

; 894  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 895  : 	HRESULT             hr;
; 896  : 	LPDIRECTSOUNDBUFFER lpDsb;
; 897  : 	DSBUFFERDESC        dsbdesc;
; 898  : 	WAVEFORMATEX        wfm;
; 899  : 	int                 cooplevel;
; 900  : 	int                 frequency;
; 901  : 
; 902  : #ifdef HW3SOUND
; 903  : 	LPCSTR              sdrv_name = NULL;

  00016	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _sdrv_name$[ebp], 0

; 904  : 	snddev_t            snddev;
; 905  : #endif
; 906  : 
; 907  : 	sound_started = false;

  0001d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _sound_started, 0

; 908  : 
; 909  : 	if (dedicated)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0002b	74 05		 je	 SHORT $LN2@I_StartupS

; 910  : 		return;

  0002d	e9 47 04 00 00	 jmp	 $LN1@I_StartupS
$LN2@I_StartupS:

; 911  : 
; 912  : 	if (nosound)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nosound, 0
  00039	74 05		 je	 SHORT $LN3@I_StartupS

; 913  : 		return;

  0003b	e9 39 04 00 00	 jmp	 $LN1@I_StartupS
$LN3@I_StartupS:

; 914  : 
; 915  : 	// Secure and configure sound device first.
; 916  : 	CONS_Printf("I_StartupSound: ");

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EGNOPLCP@I_StartupSound?3?5@
  00045	e8 00 00 00 00	 call	 _CONS_Printf
  0004a	83 c4 04	 add	 esp, 4

; 917  : 
; 918  : 	// frequency of primary buffer may be set at cmd-line
; 919  : 	if (M_CheckParm("-freq") && M_IsNextParm())

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_05FKHDODDC@?9freq@
  00052	e8 00 00 00 00	 call	 _M_CheckParm
  00057	83 c4 04	 add	 esp, 4
  0005a	85 c0		 test	 eax, eax
  0005c	74 3e		 je	 SHORT $LN4@I_StartupS
  0005e	e8 00 00 00 00	 call	 _M_IsNextParm
  00063	85 c0		 test	 eax, eax
  00065	74 35		 je	 SHORT $LN4@I_StartupS

; 920  : 	{
; 921  : 		frequency = atoi(M_GetNextParm());

  00067	e8 00 00 00 00	 call	 _M_GetNextParm
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _atoi
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 c4	 mov	 DWORD PTR _frequency$[ebp], eax

; 922  : 		CONS_Printf(" requested frequency of %d hz\n", frequency);

  00078	8b 45 c4	 mov	 eax, DWORD PTR _frequency$[ebp]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PNCOJDPE@?5requested?5frequency?5of?5?$CFd?5hz?6@
  00081	e8 00 00 00 00	 call	 _CONS_Printf
  00086	83 c4 08	 add	 esp, 8

; 923  : 		CV_SetValue(&cv_samplerate,frequency);

  00089	8b 45 c4	 mov	 eax, DWORD PTR _frequency$[ebp]
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET _cv_samplerate
  00092	e8 00 00 00 00	 call	 _CV_SetValue
  00097	83 c4 08	 add	 esp, 8

; 924  : 	}

  0009a	eb 08		 jmp	 SHORT $LN5@I_StartupS
$LN4@I_StartupS:

; 925  : 	else
; 926  : 		frequency = cv_samplerate.value;

  0009c	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_samplerate+20
  000a1	89 45 c4	 mov	 DWORD PTR _frequency$[ebp], eax
$LN5@I_StartupS:

; 927  : 
; 928  : 	// Set cooperative level
; 929  : 	// Cooperative sound with other applications can be requested at cmd-line
; 930  : 	if (M_CheckParm("-coopsound"))

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MDEJICN@?9coopsound@
  000a9	e8 00 00 00 00	 call	 _M_CheckParm
  000ae	83 c4 04	 add	 esp, 4
  000b1	85 c0		 test	 eax, eax
  000b3	74 09		 je	 SHORT $LN6@I_StartupS

; 931  : 		cooplevel = DSSCL_PRIORITY;

  000b5	c7 45 c8 02 00
	00 00		 mov	 DWORD PTR _cooplevel$[ebp], 2
  000bc	eb 07		 jmp	 SHORT $LN7@I_StartupS
$LN6@I_StartupS:

; 932  : 	else
; 933  : 		cooplevel = DSSCL_EXCLUSIVE;

  000be	c7 45 c8 03 00
	00 00		 mov	 DWORD PTR _cooplevel$[ebp], 3
$LN7@I_StartupS:

; 934  : 
; 935  : #ifdef HW3SOUND
; 936  : 	if (M_CheckParm("-ds3d"))

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_05MHILGDCB@?9ds3d@
  000ca	e8 00 00 00 00	 call	 _M_CheckParm
  000cf	83 c4 04	 add	 esp, 4
  000d2	85 c0		 test	 eax, eax
  000d4	74 13		 je	 SHORT $LN8@I_StartupS

; 937  : 	{
; 938  : 		hws_mode = HWS_DS3D;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _hws_mode, 1

; 939  : 		sdrv_name = "s_ds3d.dll";

  000e0	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _sdrv_name$[ebp], OFFSET ??_C@_0L@NACJPEKC@s_ds3d?4dll@

; 940  : 	}

  000e7	eb 74		 jmp	 SHORT $LN14@I_StartupS
$LN8@I_StartupS:

; 941  : #if 1
; 942  : 	else if (M_CheckParm("-fmod3d"))

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_07CMDIEHOI@?9fmod3d@
  000ee	e8 00 00 00 00	 call	 _M_CheckParm
  000f3	83 c4 04	 add	 esp, 4
  000f6	85 c0		 test	 eax, eax
  000f8	74 13		 je	 SHORT $LN10@I_StartupS

; 943  : 	{
; 944  : 		hws_mode = HWS_FMOD3D;

  000fa	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _hws_mode, 3

; 945  : 		sdrv_name = "s_fmod.dll";

  00104	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _sdrv_name$[ebp], OFFSET ??_C@_0L@HDJLHMPO@s_fmod?4dll@

; 946  : 	}

  0010b	eb 50		 jmp	 SHORT $LN14@I_StartupS
$LN10@I_StartupS:

; 947  : 	else if (M_CheckParm("-openal"))

  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_07IEAEJLGN@?9openal@
  00112	e8 00 00 00 00	 call	 _M_CheckParm
  00117	83 c4 04	 add	 esp, 4
  0011a	85 c0		 test	 eax, eax
  0011c	74 13		 je	 SHORT $LN12@I_StartupS

; 948  : 	{
; 949  : 		hws_mode = HWS_FMOD3D;

  0011e	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _hws_mode, 3

; 950  : 		sdrv_name = "s_openal.dll";

  00128	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _sdrv_name$[ebp], OFFSET ??_C@_0N@EPGNJCOA@s_openal?4dll@

; 951  : 	}

  0012f	eb 2c		 jmp	 SHORT $LN14@I_StartupS
$LN12@I_StartupS:

; 952  : 	else if (M_CheckParm("-sounddriver") &&  M_IsNextParm())

  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PEDBCFFI@?9sounddriver@
  00136	e8 00 00 00 00	 call	 _M_CheckParm
  0013b	83 c4 04	 add	 esp, 4
  0013e	85 c0		 test	 eax, eax
  00140	74 1b		 je	 SHORT $LN14@I_StartupS
  00142	e8 00 00 00 00	 call	 _M_IsNextParm
  00147	85 c0		 test	 eax, eax
  00149	74 12		 je	 SHORT $LN14@I_StartupS

; 953  : 	{
; 954  : 		hws_mode = HWS_OTHER;

  0014b	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _hws_mode, 2

; 955  : 		sdrv_name = M_GetNextParm();

  00155	e8 00 00 00 00	 call	 _M_GetNextParm
  0015a	89 45 c0	 mov	 DWORD PTR _sdrv_name$[ebp], eax
$LN14@I_StartupS:

; 956  : 	}
; 957  : #else
; 958  : 	else if (M_CheckParm("-sounddriver") &&  M_IsNextParm())
; 959  : 	{
; 960  : 		hws_mode = HWS_OTHER;
; 961  : 		sdrv_name = M_GetNextParm();
; 962  : 	}
; 963  : 	else if (!M_CheckParm("-nosd"))
; 964  : 	{
; 965  : 		hws_mode = HWS_FMOD3D;
; 966  : 		sdrv_name = "s_fmod.dll";
; 967  : 	}
; 968  : #endif
; 969  : 
; 970  : 	// There must be further sound drivers (such as A3D and EAX)!!!
; 971  : 
; 972  : 	if (hws_mode != HWS_DEFAULT_MODE && sdrv_name != NULL)

  0015d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  00164	0f 84 9b 00 00
	00		 je	 $LN15@I_StartupS
  0016a	83 7d c0 00	 cmp	 DWORD PTR _sdrv_name$[ebp], 0
  0016e	0f 84 91 00 00
	00		 je	 $LN15@I_StartupS

; 973  : 	{
; 974  : 		if (Init3DSDriver(sdrv_name))

  00174	8b 45 c0	 mov	 eax, DWORD PTR _sdrv_name$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _Init3DSDriver
  0017d	83 c4 04	 add	 esp, 4
  00180	85 c0		 test	 eax, eax
  00182	74 77		 je	 SHORT $LN16@I_StartupS

; 975  : 		{
; 976  : 			//nosound = true;
; 977  : 			snddev.sample_rate = frequency;

  00184	8b 45 c4	 mov	 eax, DWORD PTR _frequency$[ebp]
  00187	89 45 ac	 mov	 DWORD PTR _snddev$[ebp], eax

; 978  : 			snddev.bps = 16;

  0018a	c7 45 b0 10 00
	00 00		 mov	 DWORD PTR _snddev$[ebp+4], 16 ; 00000010H

; 979  : 			snddev.numsfxs = NUMSFX;

  00191	c7 45 b4 63 07
	00 00		 mov	 DWORD PTR _snddev$[ebp+8], 1891 ; 00000763H

; 980  : 			snddev.cooplevel = cooplevel;

  00198	8b 45 c8	 mov	 eax, DWORD PTR _cooplevel$[ebp]
  0019b	89 45 b8	 mov	 DWORD PTR _snddev$[ebp+12], eax

; 981  : 			snddev.hWnd = hWndMain;

  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  001a3	89 45 bc	 mov	 DWORD PTR _snddev$[ebp+16], eax

; 982  : 			if (HW3S_Init(I_Error, &snddev))

  001a6	8d 45 ac	 lea	 eax, DWORD PTR _snddev$[ebp]
  001a9	50		 push	 eax
  001aa	68 00 00 00 00	 push	 OFFSET _I_Error
  001af	e8 00 00 00 00	 call	 _HW3S_Init
  001b4	83 c4 08	 add	 esp, 8
  001b7	85 c0		 test	 eax, eax
  001b9	74 23		 je	 SHORT $LN17@I_StartupS

; 983  : 			{
; 984  : 				CONS_Printf("Using external sound driver %s\n", sdrv_name);

  001bb	8b 45 c0	 mov	 eax, DWORD PTR _sdrv_name$[ebp]
  001be	50		 push	 eax
  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PBKKFDKM@Using?5external?5sound?5driver?5?$CFs?6@
  001c4	e8 00 00 00 00	 call	 _CONS_Printf
  001c9	83 c4 08	 add	 esp, 8

; 985  : 				I_AddExitFunc(I_ShutdownSound);

  001cc	68 00 00 00 00	 push	 OFFSET _I_ShutdownSound
  001d1	e8 00 00 00 00	 call	 _I_AddExitFunc
  001d6	83 c4 04	 add	 esp, 4

; 986  : 				return;

  001d9	e9 9b 02 00 00	 jmp	 $LN1@I_StartupS
$LN17@I_StartupS:

; 987  : 			}
; 988  : 			// Falls back to default sound system
; 989  : 			CONS_Printf("Not using external sound driver %s\n", sdrv_name);

  001de	8b 45 c0	 mov	 eax, DWORD PTR _sdrv_name$[ebp]
  001e1	50		 push	 eax
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@ICKPPAPH@Not?5using?5external?5sound?5driver@
  001e7	e8 00 00 00 00	 call	 _CONS_Printf
  001ec	83 c4 08	 add	 esp, 8

; 990  : 			HW3S_Shutdown();

  001ef	e8 00 00 00 00	 call	 _HW3S_Shutdown
  001f4	90		 npad	 1

; 991  : 			Shutdown3DSDriver();

  001f5	e8 00 00 00 00	 call	 _Shutdown3DSDriver
  001fa	90		 npad	 1
$LN16@I_StartupS:

; 992  : 		}
; 993  : 		hws_mode = HWS_DEFAULT_MODE;

  001fb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _hws_mode, 0
$LN15@I_StartupS:

; 994  : 	}
; 995  : #endif
; 996  : 
; 997  : 	// Load DirectSound DLL
; 998  : 	if (!LoadDirectSound())

  00205	e8 00 00 00 00	 call	 _LoadDirectSound
  0020a	85 c0		 test	 eax, eax
  0020c	75 1c		 jne	 SHORT $LN18@I_StartupS

; 999  : 	{
; 1000 : 		CONS_Printf(" DirectSound DLL not loaded\n");

  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EOBCMMFO@?5DirectSound?5DLL?5not?5loaded?6@
  00213	e8 00 00 00 00	 call	 _CONS_Printf
  00218	83 c4 04	 add	 esp, 4

; 1001 : 		nosound = true;

  0021b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nosound, 1

; 1002 : 		return;

  00225	e9 4f 02 00 00	 jmp	 $LN1@I_StartupS
$LN18@I_StartupS:

; 1003 : 	}
; 1004 : 	// Create DirectSound, use the default sound device
; 1005 : 	hr = pfnDirectSoundCreate(NULL, &DSnd, NULL);

  0022a	6a 00		 push	 0
  0022c	68 00 00 00 00	 push	 OFFSET _DSnd
  00231	6a 00		 push	 0
  00233	ff 15 00 00 00
	00		 call	 DWORD PTR _pfnDirectSoundCreate
  00239	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1006 : 	if (FAILED(hr))

  0023c	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00240	7d 1c		 jge	 SHORT $LN19@I_StartupS

; 1007 : 	{
; 1008 : 		CONS_Printf(" DirectSoundCreate FAILED\n"

  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@ENBAALLE@?5DirectSoundCreate?5FAILED?6?5ther@
  00247	e8 00 00 00 00	 call	 _CONS_Printf
  0024c	83 c4 04	 add	 esp, 4

; 1009 : 		            " there is no sound device or the sound device is under\n"
; 1010 : 		            " the control of another application\n");
; 1011 : 		nosound = true;

  0024f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nosound, 1

; 1012 : 		return;

  00259	e9 1b 02 00 00	 jmp	 $LN1@I_StartupS
$LN19@I_StartupS:

; 1013 : 	}
; 1014 : 
; 1015 : 	// register exit code, now that we have at least DirectSound to close
; 1016 : 	I_AddExitFunc(I_ShutdownSound);

  0025e	68 00 00 00 00	 push	 OFFSET _I_ShutdownSound
  00263	e8 00 00 00 00	 call	 _I_AddExitFunc
  00268	83 c4 04	 add	 esp, 4

; 1017 : 	hr = IDirectSound_SetCooperativeLevel(DSnd, hWndMain, cooplevel);

  0026b	8b 45 c8	 mov	 eax, DWORD PTR _cooplevel$[ebp]
  0026e	50		 push	 eax
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  00275	51		 push	 ecx
  00276	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DSnd
  0027c	52		 push	 edx
  0027d	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  00282	8b 08		 mov	 ecx, DWORD PTR [eax]
  00284	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00287	ff d2		 call	 edx
  00289	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1018 : 	if (FAILED(hr))

  0028c	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00290	7d 1c		 jge	 SHORT $LN20@I_StartupS

; 1019 : 	{
; 1020 : 		CONS_Printf(" SetCooperativeLevel FAILED\n");

  00292	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JLLKBHMH@?5SetCooperativeLevel?5FAILED?6@
  00297	e8 00 00 00 00	 call	 _CONS_Printf
  0029c	83 c4 04	 add	 esp, 4

; 1021 : 		nosound = true;

  0029f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nosound, 1

; 1022 : 		return;

  002a9	e9 cb 01 00 00	 jmp	 $LN1@I_StartupS
$LN20@I_StartupS:

; 1023 : 	}
; 1024 : 
; 1025 : 	// Set up DSBUFFERDESC structure.
; 1026 : 	ZeroMemory(&dsbdesc, sizeof (DSBUFFERDESC));

  002ae	6a 14		 push	 20			; 00000014H
  002b0	6a 00		 push	 0
  002b2	8d 45 e0	 lea	 eax, DWORD PTR _dsbdesc$[ebp]
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 _memset
  002bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1027 : 	dsbdesc.dwSize        = sizeof (DSBUFFERDESC);

  002be	c7 45 e0 14 00
	00 00		 mov	 DWORD PTR _dsbdesc$[ebp], 20 ; 00000014H

; 1028 : 	dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER |

  002c5	c7 45 e4 81 00
	00 00		 mov	 DWORD PTR _dsbdesc$[ebp+4], 129 ; 00000081H

; 1029 : 	                  DSBCAPS_CTRLVOLUME;
; 1030 : 	dsbdesc.dwBufferBytes = 0;      // Must be 0 for primary buffer

  002cc	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dsbdesc$[ebp+8], 0

; 1031 : 	dsbdesc.lpwfxFormat = NULL;     // Must be NULL for primary buffer

  002d3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dsbdesc$[ebp+16], 0

; 1032 : 
; 1033 : 	// Set up structure for the desired format
; 1034 : 	ZeroMemory(&wfm, sizeof (WAVEFORMATEX));

  002da	6a 12		 push	 18			; 00000012H
  002dc	6a 00		 push	 0
  002de	8d 45 cc	 lea	 eax, DWORD PTR _wfm$[ebp]
  002e1	50		 push	 eax
  002e2	e8 00 00 00 00	 call	 _memset
  002e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1035 : 	wfm.wFormatTag = WAVE_FORMAT_PCM;

  002ea	b8 01 00 00 00	 mov	 eax, 1
  002ef	66 89 45 cc	 mov	 WORD PTR _wfm$[ebp], ax

; 1036 : 	wfm.nChannels = 2;                              //STEREO SOUND!

  002f3	b8 02 00 00 00	 mov	 eax, 2
  002f8	66 89 45 ce	 mov	 WORD PTR _wfm$[ebp+2], ax

; 1037 : 	wfm.nSamplesPerSec = frequency;

  002fc	8b 45 c4	 mov	 eax, DWORD PTR _frequency$[ebp]
  002ff	89 45 d0	 mov	 DWORD PTR _wfm$[ebp+4], eax

; 1038 : 	wfm.wBitsPerSample = 16;

  00302	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00307	66 89 45 da	 mov	 WORD PTR _wfm$[ebp+14], ax

; 1039 : 	wfm.nBlockAlign = (WORD)(wfm.wBitsPerSample / 8 * wfm.nChannels);

  0030b	0f b7 45 da	 movzx	 eax, WORD PTR _wfm$[ebp+14]
  0030f	99		 cdq
  00310	83 e2 07	 and	 edx, 7
  00313	03 c2		 add	 eax, edx
  00315	c1 f8 03	 sar	 eax, 3
  00318	0f b7 4d ce	 movzx	 ecx, WORD PTR _wfm$[ebp+2]
  0031c	0f af c1	 imul	 eax, ecx
  0031f	66 89 45 d8	 mov	 WORD PTR _wfm$[ebp+12], ax

; 1040 : 	wfm.nAvgBytesPerSec = wfm.nSamplesPerSec * wfm.nBlockAlign;

  00323	0f b7 45 d8	 movzx	 eax, WORD PTR _wfm$[ebp+12]
  00327	0f af 45 d0	 imul	 eax, DWORD PTR _wfm$[ebp+4]
  0032b	89 45 d4	 mov	 DWORD PTR _wfm$[ebp+8], eax

; 1041 : 
; 1042 : 	// Gain access to the primary buffer
; 1043 : 	hr = IDirectSound_CreateSoundBuffer(DSnd, &dsbdesc, &lpDsb, NULL);

  0032e	6a 00		 push	 0
  00330	8d 45 f4	 lea	 eax, DWORD PTR _lpDsb$[ebp]
  00333	50		 push	 eax
  00334	8d 4d e0	 lea	 ecx, DWORD PTR _dsbdesc$[ebp]
  00337	51		 push	 ecx
  00338	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _DSnd
  0033e	52		 push	 edx
  0033f	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  00344	8b 08		 mov	 ecx, DWORD PTR [eax]
  00346	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00349	ff d2		 call	 edx
  0034b	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1044 : 	if (FAILED(hr))

  0034e	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00352	7d 2d		 jge	 SHORT $LN21@I_StartupS

; 1045 : 	{
; 1046 : 		CONS_Printf("CreateSoundBuffer FAILED: %s (ErrNo %ld)\n", DXErrorToString(hr), hr);

  00354	8b 45 f8	 mov	 eax, DWORD PTR _hr$[ebp]
  00357	50		 push	 eax
  00358	8b 4d f8	 mov	 ecx, DWORD PTR _hr$[ebp]
  0035b	51		 push	 ecx
  0035c	e8 00 00 00 00	 call	 _DXErrorToString
  00361	83 c4 04	 add	 esp, 4
  00364	50		 push	 eax
  00365	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@EJBPBFLF@CreateSoundBuffer?5FAILED?3?5?$CFs?5?$CIE@
  0036a	e8 00 00 00 00	 call	 _CONS_Printf
  0036f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1047 : 		nosound = true;

  00372	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nosound, 1

; 1048 : 		return;

  0037c	e9 f8 00 00 00	 jmp	 $LN1@I_StartupS
$LN21@I_StartupS:

; 1049 : 	}
; 1050 : 
; 1051 : 	// Set the primary buffer to the desired format,
; 1052 : 	// but only if we are allowed to do it
; 1053 : 	if (cooplevel >= DSSCL_PRIORITY)

  00381	83 7d c8 02	 cmp	 DWORD PTR _cooplevel$[ebp], 2
  00385	0f 8c 94 00 00
	00		 jl	 $LN22@I_StartupS

; 1054 : 	{
; 1055 : 		if (SUCCEEDED(hr))

  0038b	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0038f	7c 3b		 jl	 SHORT $LN25@I_StartupS

; 1056 : 		{
; 1057 : 			// Set primary buffer to the desired format. If this fails,
; 1058 : 			// we'll just ignore and go with the default.
; 1059 : 			hr = IDirectSoundBuffer_SetFormat(lpDsb, &wfm);

  00391	8d 45 cc	 lea	 eax, DWORD PTR _wfm$[ebp]
  00394	50		 push	 eax
  00395	8b 4d f4	 mov	 ecx, DWORD PTR _lpDsb$[ebp]
  00398	51		 push	 ecx
  00399	8b 55 f4	 mov	 edx, DWORD PTR _lpDsb$[ebp]
  0039c	8b 02		 mov	 eax, DWORD PTR [edx]
  0039e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  003a1	ff d1		 call	 ecx
  003a3	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1060 : 			if (FAILED(hr))

  003a6	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003aa	7d 0f		 jge	 SHORT $LN24@I_StartupS

; 1061 : 				CONS_Printf("I_StartupSound :  couldn't set primary buffer format.\n");

  003ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DMGMEEND@I_StartupSound?5?3?5?5couldn?8t?5set?5@
  003b1	e8 00 00 00 00	 call	 _CONS_Printf
  003b6	83 c4 04	 add	 esp, 4
  003b9	eb 11		 jmp	 SHORT $LN25@I_StartupS
$LN24@I_StartupS:

; 1062 : 			else
; 1063 : 				CV_SetValue(&cv_samplerate,wfm.nSamplesPerSec);

  003bb	8b 45 d0	 mov	 eax, DWORD PTR _wfm$[ebp+4]
  003be	50		 push	 eax
  003bf	68 00 00 00 00	 push	 OFFSET _cv_samplerate
  003c4	e8 00 00 00 00	 call	 _CV_SetValue
  003c9	83 c4 08	 add	 esp, 8
$LN25@I_StartupS:

; 1064 : 		}
; 1065 : 		// move any on-board sound memory into a contiguous block
; 1066 : 		// to make the largest portion of free memory available.
; 1067 : 
; 1068 : 		CONS_Printf(" Compacting onboard sound-memory...");

  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EPBAOBKP@?5Compacting?5onboard?5sound?9memor@
  003d1	e8 00 00 00 00	 call	 _CONS_Printf
  003d6	83 c4 04	 add	 esp, 4

; 1069 : 		hr = IDirectSound_Compact(DSnd);

  003d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _DSnd
  003de	50		 push	 eax
  003df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _DSnd
  003e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  003e7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  003ea	ff d0		 call	 eax
  003ec	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1070 : 		CONS_Printf(" %s\n", SUCCEEDED(hr) ? "done" : "FAILED");

  003ef	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  003f3	7c 0c		 jl	 SHORT $LN28@I_StartupS
  003f5	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv236[ebp], OFFSET ??_C@_04GMOJEHPC@done@
  003ff	eb 0a		 jmp	 SHORT $LN29@I_StartupS
$LN28@I_StartupS:
  00401	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv236[ebp], OFFSET ??_C@_06OHCJKBJM@FAILED@
$LN29@I_StartupS:
  0040b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv236[ebp]
  00411	50		 push	 eax
  00412	68 00 00 00 00	 push	 OFFSET ??_C@_04MDKIEGGJ@?5?$CFs?6@
  00417	e8 00 00 00 00	 call	 _CONS_Printf
  0041c	83 c4 08	 add	 esp, 8
$LN22@I_StartupS:

; 1071 : 	}
; 1072 : 
; 1073 : 	// set the primary buffer to play continuously, for performance
; 1074 : 	// "... this method will ensure that the primary buffer is playing even when no secondary
; 1075 : 	// buffers are playing; in that case, silence will be played. This can reduce processing
; 1076 : 	// overhead when sounds are started and stopped in sequence, because the primary buffer
; 1077 : 	// will be playing continuously rather than stopping and starting between secondary buffers."
; 1078 : 	hr = IDirectSoundBuffer_Play(lpDsb, 0, 0, DSBPLAY_LOOPING);

  0041f	6a 01		 push	 1
  00421	6a 00		 push	 0
  00423	6a 00		 push	 0
  00425	8b 45 f4	 mov	 eax, DWORD PTR _lpDsb$[ebp]
  00428	50		 push	 eax
  00429	8b 4d f4	 mov	 ecx, DWORD PTR _lpDsb$[ebp]
  0042c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042e	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00431	ff d0		 call	 eax
  00433	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1079 : 	if (FAILED (hr))

  00436	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0043a	7d 0d		 jge	 SHORT $LN26@I_StartupS

; 1080 : 		CONS_Printf(" Primary buffer continuous play FAILED\n");

  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GPPFBKNC@?5Primary?5buffer?5continuous?5play@
  00441	e8 00 00 00 00	 call	 _CONS_Printf
  00446	83 c4 04	 add	 esp, 4
$LN26@I_StartupS:

; 1081 : 
; 1082 : #ifdef DEBUGSOUND
; 1083 : 	{
; 1084 : 		DSCAPS DSCaps;
; 1085 : 		DSCaps.dwSize = sizeof (DSCAPS);
; 1086 : 		hr = IDirectSound_GetCaps(DSnd, &DSCaps);
; 1087 : 		if (SUCCEEDED(hr))
; 1088 : 		{
; 1089 : 			if (DSCaps.dwFlags & DSCAPS_CERTIFIED)
; 1090 : 				CONS_Printf("This driver has been certified by Microsoft\n");
; 1091 : 			if (DSCaps.dwFlags & DSCAPS_EMULDRIVER)
; 1092 : 				CONS_Printf("No driver with DirectSound support installed (no hardware mixing)\n");
; 1093 : 			if (DSCaps.dwFlags & DSCAPS_PRIMARY16BIT)
; 1094 : 				CONS_Printf("Supports 16-bit primary buffer\n");
; 1095 : 			if (DSCaps.dwFlags & DSCAPS_PRIMARY8BIT)
; 1096 : 				CONS_Printf("Supports 8-bit primary buffer\n");
; 1097 : 			if (DSCaps.dwFlags & DSCAPS_SECONDARY16BIT)
; 1098 : 				CONS_Printf("Supports 16-bit, hardware-mixed secondary buffers\n");
; 1099 : 			if (DSCaps.dwFlags & DSCAPS_SECONDARY8BIT)
; 1100 : 				CONS_Printf("Supports 8-bit, hardware-mixed secondary buffers\n");
; 1101 : 
; 1102 : 			CONS_Printf("Maximum number of hardware buffers: %d\n", DSCaps.dwMaxHwMixingStaticBuffers);
; 1103 : 			CONS_Printf("Size of total hardware memory: %d\n", DSCaps.dwTotalHwMemBytes);
; 1104 : 			CONS_Printf("Size of free hardware memory= %d\n", DSCaps.dwFreeHwMemBytes);
; 1105 : 			CONS_Printf("Play Cpu Overhead (%% cpu cycles): %d\n", DSCaps.dwPlayCpuOverheadSwBuffers);
; 1106 : 		}
; 1107 : 		else
; 1108 : 			CONS_Printf(" couldn't get sound device caps.\n");
; 1109 : 	}
; 1110 : #endif
; 1111 : 
; 1112 : 	// save pointer to the primary DirectSound buffer for volume changes
; 1113 : 	DSndPrimary = lpDsb;

  00449	8b 45 f4	 mov	 eax, DWORD PTR _lpDsb$[ebp]
  0044c	a3 00 00 00 00	 mov	 DWORD PTR _DSndPrimary, eax

; 1114 : 
; 1115 : 	ZeroMemory(StackSounds, sizeof (StackSounds));

  00451	68 00 02 00 00	 push	 512			; 00000200H
  00456	6a 00		 push	 0
  00458	68 00 00 00 00	 push	 OFFSET _StackSounds
  0045d	e8 00 00 00 00	 call	 _memset
  00462	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1116 : 
; 1117 : 	CONS_Printf("sound initialised.\n");

  00465	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LALGGIEN@sound?5initialised?4?6@
  0046a	e8 00 00 00 00	 call	 _CONS_Printf
  0046f	83 c4 04	 add	 esp, 4

; 1118 : 	sound_started = true;

  00472	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _sound_started, 1
$LN1@I_StartupS:

; 1119 : }

  00479	5f		 pop	 edi
  0047a	5e		 pop	 esi
  0047b	5b		 pop	 ebx
  0047c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047f	33 cd		 xor	 ecx, ebp
  00481	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00486	8b e5		 mov	 esp, ebp
  00488	5d		 pop	 ebp
  00489	c3		 ret	 0
_I_StartupSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_FreeSfx
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_dsbuffer$ = -4						; size = 4
_sfx$ = 8						; size = 4
_I_FreeSfx PROC						; COMDAT

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 374  : 	LPDIRECTSOUNDBUFFER dsbuffer;
; 375  : 
; 376  : 	if (sfx->lumpnum == LUMPERROR)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  0000c	83 78 24 ff	 cmp	 DWORD PTR [eax+36], -1
  00010	75 05		 jne	 SHORT $LN5@I_FreeSfx

; 377  : 		return;

  00012	e9 02 01 00 00	 jmp	 $LN1@I_FreeSfx
$LN5@I_FreeSfx:

; 378  : 
; 379  : #ifdef HW3SOUND
; 380  : 	if (hws_mode != HWS_DEFAULT_MODE)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  0001e	74 11		 je	 SHORT $LN6@I_FreeSfx

; 381  : 	{
; 382  : 		HW3S_FreeSfx(sfx);

  00020	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _HW3S_FreeSfx
  00029	83 c4 04	 add	 esp, 4

; 383  : 	}

  0002c	e9 d4 00 00 00	 jmp	 $LN8@I_FreeSfx
$LN6@I_FreeSfx:

; 384  : 	else
; 385  : #endif
; 386  : 	{
; 387  : 		//CONS_Printf("I_FreeSfx(%d)\n", sfx->lumpnum);
; 388  : 
; 389  : 		// free DIRECTSOUNDBUFFER
; 390  : 		dsbuffer = (LPDIRECTSOUNDBUFFER)sfx->data;

  00031	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00034	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00037	89 4d fc	 mov	 DWORD PTR _dsbuffer$[ebp], ecx

; 391  : 		if (dsbuffer)

  0003a	83 7d fc 00	 cmp	 DWORD PTR _dsbuffer$[ebp], 0
  0003e	0f 84 c1 00 00
	00		 je	 $LN8@I_FreeSfx

; 392  : 		{
; 393  : 			size_t i;
; 394  : 			for (i = 0; i < MAXSTACKSOUNDS; i++)

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@I_FreeSfx
$LN2@I_FreeSfx:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@I_FreeSfx:
  00056	83 7d f8 20	 cmp	 DWORD PTR _i$1[ebp], 32	; 00000020H
  0005a	0f 83 87 00 00
	00		 jae	 $LN3@I_FreeSfx

; 395  : 			{
; 396  : 				if (StackSounds[i].lpSndBuf == dsbuffer)

  00060	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00063	c1 e0 04	 shl	 eax, 4
  00066	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax]
  0006c	3b 4d fc	 cmp	 ecx, DWORD PTR _dsbuffer$[ebp]
  0006f	75 71		 jne	 SHORT $LN9@I_FreeSfx

; 397  : 				{
; 398  : 					StackSounds[i].lpSndBuf = NULL;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00074	c1 e0 04	 shl	 eax, 4
  00077	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StackSounds[eax], 0

; 399  : #ifdef SURROUND
; 400  : 					if (StackSounds[i].lpSurround)

  00081	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00084	c1 e0 04	 shl	 eax, 4
  00087	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _StackSounds[eax+4], 0
  0008e	74 42		 je	 SHORT $LN10@I_FreeSfx

; 401  : 					{
; 402  : 						IDirectSoundBuffer_Stop(StackSounds[i].lpSurround);

  00090	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00093	c1 e0 04	 shl	 eax, 4
  00096	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax+4]
  0009c	51		 push	 ecx
  0009d	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  000a0	c1 e2 04	 shl	 edx, 4
  000a3	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _StackSounds[edx+4]
  000a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ab	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  000ae	ff d2		 call	 edx
  000b0	90		 npad	 1

; 403  : 						IDirectSoundBuffer_Release(StackSounds[i].lpSurround);

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  000b4	c1 e0 04	 shl	 eax, 4
  000b7	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _StackSounds[eax+4]
  000bd	51		 push	 ecx
  000be	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  000c1	c1 e2 04	 shl	 edx, 4
  000c4	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _StackSounds[edx+4]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000cf	ff d2		 call	 edx
  000d1	90		 npad	 1
$LN10@I_FreeSfx:

; 404  : 					}
; 405  : 					StackSounds[i].lpSurround = NULL;

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  000d5	c1 e0 04	 shl	 eax, 4
  000d8	c7 80 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StackSounds[eax+4], 0
$LN9@I_FreeSfx:

; 406  : #endif
; 407  : 				}
; 408  : 			}

  000e2	e9 66 ff ff ff	 jmp	 $LN2@I_FreeSfx
$LN3@I_FreeSfx:

; 409  : 			IDirectSoundBuffer_Stop(dsbuffer);

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f0	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000f3	ff d0		 call	 eax
  000f5	90		 npad	 1

; 410  : 			IDirectSoundBuffer_Release(dsbuffer);

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _dsbuffer$[ebp]
  000f9	50		 push	 eax
  000fa	8b 4d fc	 mov	 ecx, DWORD PTR _dsbuffer$[ebp]
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ff	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00102	ff d0		 call	 eax
  00104	90		 npad	 1
$LN8@I_FreeSfx:

; 411  : 		}
; 412  : 	}
; 413  : 	sfx->data = NULL;

  00105	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00108	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 414  : 	sfx->lumpnum = LUMPERROR;

  0010f	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00112	c7 40 24 ff ff
	ff ff		 mov	 DWORD PTR [eax+36], -1
$LN1@I_FreeSfx:

; 415  : }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
_I_FreeSfx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_GetSfx
_TEXT	SEGMENT
_dssfx$ = -4						; size = 4
_sfx$ = 8						; size = 4
_I_GetSfx PROC						; COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 344  : 	LPBYTE dssfx;
; 345  : 
; 346  : 	if (sfx->lumpnum == LUMPERROR)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  0000c	83 78 24 ff	 cmp	 DWORD PTR [eax+36], -1
  00010	75 12		 jne	 SHORT $LN2@I_GetSfx

; 347  : 		sfx->lumpnum = S_GetSfxLumpNum(sfx);

  00012	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _S_GetSfxLumpNum
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _sfx$[ebp]
  00021	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN2@I_GetSfx:

; 348  : 
; 349  : #ifdef HW3SOUND
; 350  : 	if (hws_mode != HWS_DEFAULT_MODE)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hws_mode, 0
  0002b	74 0e		 je	 SHORT $LN3@I_GetSfx

; 351  : 		return HW3S_GetSfx(sfx);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _HW3S_GetSfx
  00036	83 c4 04	 add	 esp, 4
  00039	eb 3e		 jmp	 SHORT $LN1@I_GetSfx
$LN3@I_GetSfx:

; 352  : #endif
; 353  : 
; 354  : 	sfx->length = W_LumpLength(sfx->lumpnum);

  0003b	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  0003e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _W_LumpLength
  00047	83 c4 04	 add	 esp, 4
  0004a	8b 55 08	 mov	 edx, DWORD PTR _sfx$[ebp]
  0004d	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 355  : 
; 356  : 	// PU_CACHE because the data is copied to the DIRECTSOUNDBUFFER, the one here will not be used
; 357  : 	dssfx = W_CacheLumpNum(sfx->lumpnum, PU_CACHE);

  00050	6a 65		 push	 101			; 00000065H
  00052	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00055	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0005e	83 c4 08	 add	 esp, 8
  00061	89 45 fc	 mov	 DWORD PTR _dssfx$[ebp], eax

; 358  : 
; 359  : #ifdef SURROUND
; 360  : 	// Make a normal (not inverted) sound buffer
; 361  : 	return raw2DS(dssfx, sfx->length, FALSE);

  00064	6a 00		 push	 0
  00066	8b 45 08	 mov	 eax, DWORD PTR _sfx$[ebp]
  00069	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0006c	51		 push	 ecx
  0006d	8b 55 fc	 mov	 edx, DWORD PTR _dssfx$[ebp]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _raw2DS
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@I_GetSfx:

; 362  : #else
; 363  : 	// return the LPDIRECTSOUNDBUFFER, which will be stored in S_sfx[].data
; 364  : 	return raw2DS(dssfx, sfx->length);
; 365  : #endif
; 366  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_I_GetSfx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_snd.c
;	COMDAT _I_SetMidiChannelVolume
_TEXT	SEGMENT
_mmrRetVal$ = -12					; size = 4
_dwVol$ = -8						; size = 4
_dwEvent$ = -4						; size = 4
_dwChannel$ = 8						; size = 4
_pdwVolumePercent$ = 12					; size = 4
_I_SetMidiChannelVolume PROC				; COMDAT

; 2306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2307 : 	DWORD dwEvent, dwVol;
; 2308 : 	MMRESULT mmrRetVal;
; 2309 : 
; 2310 : 	if (!bMidiPlaying)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiPlaying, 0
  00010	75 02		 jne	 SHORT $LN2@I_SetMidiC

; 2311 : 		return;

  00012	eb 46		 jmp	 SHORT $LN3@I_SetMidiC
$LN2@I_SetMidiC:

; 2312 : 
; 2313 : 	dwVol = (dwVolCache[dwChannel] * pdwVolumePercent) / 1000;

  00014	8b 45 08	 mov	 eax, DWORD PTR _dwChannel$[ebp]
  00017	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _dwVolCache[eax*4]
  0001e	0f af 45 0c	 imul	 eax, DWORD PTR _pdwVolumePercent$[ebp]
  00022	33 d2		 xor	 edx, edx
  00024	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00029	f7 f1		 div	 ecx
  0002b	89 45 f8	 mov	 DWORD PTR _dwVol$[ebp], eax

; 2314 : 	dwEvent = MIDI_CTRLCHANGE|dwChannel|((DWORD)MIDICTRL_VOLUME << 8)|((DWORD)dwVol << 16);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _dwChannel$[ebp]
  00031	0d b0 00 00 00	 or	 eax, 176		; 000000b0H
  00036	0d 00 07 00 00	 or	 eax, 1792		; 00000700H
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _dwVol$[ebp]
  0003e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00041	0b c1		 or	 eax, ecx
  00043	89 45 fc	 mov	 DWORD PTR _dwEvent$[ebp], eax

; 2315 : 	if ((mmrRetVal = midiOutShortMsg((HMIDIOUT)hStream, dwEvent)) != MMSYSERR_NOERROR)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _dwEvent$[ebp]
  00049	50		 push	 eax
  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hStream
  00050	51		 push	 ecx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__midiOutShortMsg@8
  00057	89 45 f4	 mov	 DWORD PTR _mmrRetVal$[ebp], eax
$LN3@I_SetMidiC:

; 2316 : 	{
; 2317 : #ifdef DEBUGMIDISTREAM
; 2318 : 		MidiErrorMessageBox(mmrRetVal);
; 2319 : #endif
; 2320 : 		return;
; 2321 : 	}
; 2322 : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_I_SetMidiChannelVolume ENDP
_TEXT	ENDS
END
