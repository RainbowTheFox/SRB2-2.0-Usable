; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\mserv.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_cv_masterserver
PUBLIC	_cv_servername
PUBLIC	_cv_internetserver
PUBLIC	_oldroomnum
PUBLIC	??_C@_0P@NNPOPHEI@internetserver@		; `string'
PUBLIC	??_C@_02JINPPBEP@No@				; `string'
PUBLIC	??_C@_0N@HBKKGKCD@masterserver@			; `string'
PUBLIC	??_C@_0BC@FEAJFNPD@ms?4srb2?4org?328900@	; `string'
PUBLIC	??_C@_0L@BCGFJHMC@servername@			; `string'
PUBLIC	??_C@_0M@JHAJICBJ@SRB2?5server@			; `string'
EXTRN	_CV_YesNo:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_oldroomnum DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_room_list:BYTE:02793H
_DATA	ENDS
;	COMDAT ??_C@_0M@JHAJICBJ@SRB2?5server@
CONST	SEGMENT
??_C@_0M@JHAJICBJ@SRB2?5server@ DB 'SRB2 server', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCGFJHMC@servername@
CONST	SEGMENT
??_C@_0L@BCGFJHMC@servername@ DB 'servername', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FEAJFNPD@ms?4srb2?4org?328900@
CONST	SEGMENT
??_C@_0BC@FEAJFNPD@ms?4srb2?4org?328900@ DB 'ms.srb2.org:28900', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HBKKGKCD@masterserver@
CONST	SEGMENT
??_C@_0N@HBKKGKCD@masterserver@ DB 'masterserver', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No@
CONST	SEGMENT
??_C@_02JINPPBEP@No@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNPOPHEI@internetserver@
CONST	SEGMENT
??_C@_0P@NNPOPHEI@internetserver@ DB 'internetserver', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_cv_masterserver DD FLAT:??_C@_0N@HBKKGKCD@masterserver@
	DD	FLAT:??_C@_0BC@FEAJFNPD@ms?4srb2?4org?328900@
	DD	01H
	DD	00H
	DD	FLAT:_MasterServer_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_servername DD FLAT:??_C@_0L@BCGFJHMC@servername@
	DD	FLAT:??_C@_0M@JHAJICBJ@SRB2?5server@
	DD	01H
	DD	00H
	DD	FLAT:_ServerName_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_internetserver DD FLAT:??_C@_0P@NNPOPHEI@internetserver@
	DD	FLAT:??_C@_02JINPPBEP@No@
	DD	02H
	DD	FLAT:_CV_YesNo
	DD	FLAT:_InternetServer_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_GetMasterServerPort
PUBLIC	_GetMasterServerIP
PUBLIC	_MSOpenUDPSocket
PUBLIC	_MSCloseUDPSocket
PUBLIC	_SendAskInfoViaMS
PUBLIC	_RegisterServer
PUBLIC	_UnregisterServer
PUBLIC	_MasterClient_Ticker
PUBLIC	_GetShortServersList
PUBLIC	_GetRoomsList
PUBLIC	_GetMODVersion
PUBLIC	_AddMServCommands
PUBLIC	??_C@_08LNKMFIHA@listserv@			; `string'
PUBLIC	??_C@_0BP@FEGPILHP@No?5servers?5currently?5running?4?6@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@ ; `string'
PUBLIC	??_C@_0DE@PILCGDBG@There?5was?5a?5problem?5connecting?5@ ; `string'
PUBLIC	??_C@_0BH@HBPKGLJE@Master?5Server?5Offline?4@	; `string'
PUBLIC	??_C@_07BMIEDOEC@Offline@			; `string'
PUBLIC	??_C@_0IO@HKEKLKBF@You?5have?5been?5banned?5from?6hosti@ ; `string'
PUBLIC	??_C@_0IO@PFIMLPLI@You?5have?5been?5banned?5from?6joini@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_04HIBGFPH@NULL@				; `string'
PUBLIC	??_C@_0CK@PANENJBJ@Not?5yet?5registered?5to?5the?5maste@ ; `string'
PUBLIC	??_C@_0BL@NOHIMKIJ@Retrieving?5server?5list?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BI@FBMAGFAO@cannot?5get?5server?5list?6@	; `string'
PUBLIC	??_C@_0CE@LAPJJAPM@Connection?5to?5master?5server?5fai@ ; `string'
PUBLIC	??_C@_0BJ@EFDMONEA@Timeout?5on?5masterserver?6@	; `string'
PUBLIC	??_C@_0CE@LIHLBGPB@Mastserver?5error?5on?5select?5?$CD?$CFu?3@ ; `string'
PUBLIC	??_C@_0CH@MOCAGAFN@Masterserver?5getsockopt?5error?5?$CD@ ; `string'
PUBLIC	??_C@_05IGIAIFLJ@?9room@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd@		; `string'
PUBLIC	??_C@_0CF@CJGMNOGD@Master?5Server?5Updated?5Successfu@ ; `string'
PUBLIC	??_C@_05OANAGPPF@28900@				; `string'
PUBLIC	??_C@_0BI@JDJFAKIG@srb2?4ssntails?4org?328910@	; `string'
PUBLIC	??_C@_0BJ@LENOLGCK@srb2?4servegame?4org?328910@	; `string'
PUBLIC	??_C@_0BJ@LFBMNMBN@srb2?4servegame?4org?328900@	; `string'
PUBLIC	??_C@_05HKPGCKL@?$CFs?3?$CFd@			; `string'
PUBLIC	??_C@_0DB@JGONOAKO@Registering?5this?5server?5to?5the?5@ ; `string'
PUBLIC	??_C@_0DD@KAGGBDFM@Unregistering?5this?5server?5to?5th@ ; `string'
PUBLIC	??_C@_0DC@NLJKCLLO@cannot?5remove?5this?5server?5from?5@ ; `string'
PUBLIC	??_C@_0JL@GMPDIPOO@You?5cannot?5register?5on?5the?5Mast@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__time64:PROC
EXTRN	_memset:PROC
EXTRN	_strstr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strerror:PROC
EXTRN	_strlen:PROC
EXTRN	_atoi:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_connect@12:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_getsockopt@20:PROC
EXTRN	_htonl@4:PROC
EXTRN	_htons@4:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_inet_ntoa@4:PROC
EXTRN	_ntohl@4:PROC
EXTRN	_recv@16:PROC
EXTRN	_select@20:PROC
EXTRN	_send@16:PROC
EXTRN	_socket@12:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_COM_AddCommand:PROC
EXTRN	_CV_RegisterVar:PROC
EXTRN	_CV_Set:PROC
EXTRN	_CV_StealthSetValue:PROC
EXTRN	_Playing:PROC
EXTRN	_I_InitTcpDriver:PROC
EXTRN	_M_StartMessage:PROC
EXTRN	_M_AlterRoomOptions:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_netbuffer:DWORD
EXTRN	_server:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_doomcom:DWORD
EXTRN	_I_NetSend:DWORD
EXTRN	_I_NetFreeNodenum:DWORD
EXTRN	_I_NetMakeNode:DWORD
EXTRN	_I_GetNodeAddress:DWORD
EXTRN	_sock_port:WORD
EXTRN	_cv_chooseroom:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_registered_server DB 088H DUP (?)
	ALIGN	8

_MSLastPing DQ	01H DUP (?)
_con_state DD	01H DUP (?)
_addr	DB	010H DUP (?)
	ALIGN	8

_select_timeout DQ 01H DUP (?)
_wset	DB	0104H DUP (?)
?server_list@?1??GetShortServersList@@9@9 DB 01554H DUP (?) ; `GetShortServersList'::`2'::server_list
?banned_info@?1??GetRoomsList@@9@9 DB 0153H DUP (?)	; `GetRoomsList'::`2'::banned_info
	ALIGN	4

?msg@?1??GetMODVersion@@9@9 DB 0410H DUP (?)		; `GetMODVersion'::`2'::msg
?res@?1??int2str@@9@9 DB 010H DUP (?)			; `int2str'::`2'::res
?retry@?1??AddToMasterServer@@9@9 DD 01H DUP (?)	; `AddToMasterServer'::`2'::retry
?str_ip@?1??GetMasterServerIP@@9@9 DB 040H DUP (?)	; `GetMasterServerIP'::`2'::str_ip
_BSS	ENDS
;	COMDAT ??_C@_0JL@GMPDIPOO@You?5cannot?5register?5on?5the?5Mast@
CONST	SEGMENT
??_C@_0JL@GMPDIPOO@You?5cannot?5register?5on?5the?5Mast@ DB 'You cannot r'
	DB	'egister on the Master Server mid-game, please end your curren'
	DB	't session and re-host if you wish to advertise your server on'
	DB	' the Master Server.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NLJKCLLO@cannot?5remove?5this?5server?5from?5@
CONST	SEGMENT
??_C@_0DC@NLJKCLLO@cannot?5remove?5this?5server?5from?5@ DB 'cannot remov'
	DB	'e this server from the master server', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KAGGBDFM@Unregistering?5this?5server?5to?5th@
CONST	SEGMENT
??_C@_0DD@KAGGBDFM@Unregistering?5this?5server?5to?5th@ DB 'Unregistering'
	DB	' this server to the master server...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JGONOAKO@Registering?5this?5server?5to?5the?5@
CONST	SEGMENT
??_C@_0DB@JGONOAKO@Registering?5this?5server?5to?5the?5@ DB 'Registering '
	DB	'this server to the master server...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKPGCKL@?$CFs?3?$CFd@
CONST	SEGMENT
??_C@_05HKPGCKL@?$CFs?3?$CFd@ DB '%s:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFBMNMBN@srb2?4servegame?4org?328900@
CONST	SEGMENT
??_C@_0BJ@LFBMNMBN@srb2?4servegame?4org?328900@ DB 'srb2.servegame.org:28'
	DB	'900', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LENOLGCK@srb2?4servegame?4org?328910@
CONST	SEGMENT
??_C@_0BJ@LENOLGCK@srb2?4servegame?4org?328910@ DB 'srb2.servegame.org:28'
	DB	'910', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JDJFAKIG@srb2?4ssntails?4org?328910@
CONST	SEGMENT
??_C@_0BI@JDJFAKIG@srb2?4ssntails?4org?328910@ DB 'srb2.ssntails.org:2891'
	DB	'0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05OANAGPPF@28900@
CONST	SEGMENT
??_C@_05OANAGPPF@28900@ DB '28900', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CJGMNOGD@Master?5Server?5Updated?5Successfu@
CONST	SEGMENT
??_C@_0CF@CJGMNOGD@Master?5Server?5Updated?5Successfu@ DB 'Master Server '
	DB	'Updated Successfully!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd@
CONST	SEGMENT
??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd@ DB '%d.%d.%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGIAIFLJ@?9room@
CONST	SEGMENT
??_C@_05IGIAIFLJ@?9room@ DB '-room', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MOCAGAFN@Masterserver?5getsockopt?5error?5?$CD@
CONST	SEGMENT
??_C@_0CH@MOCAGAFN@Masterserver?5getsockopt?5error?5?$CD@ DB 'Masterserve'
	DB	'r getsockopt error #%u: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LIHLBGPB@Mastserver?5error?5on?5select?5?$CD?$CFu?3@
CONST	SEGMENT
??_C@_0CE@LIHLBGPB@Mastserver?5error?5on?5select?5?$CD?$CFu?3@ DB 'Mastse'
	DB	'rver error on select #%u: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EFDMONEA@Timeout?5on?5masterserver?6@
CONST	SEGMENT
??_C@_0BJ@EFDMONEA@Timeout?5on?5masterserver?6@ DB 'Timeout on masterserv'
	DB	'er', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LAPJJAPM@Connection?5to?5master?5server?5fai@
CONST	SEGMENT
??_C@_0CE@LAPJJAPM@Connection?5to?5master?5server?5fai@ DB 'Connection to'
	DB	' master server failed', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FBMAGFAO@cannot?5get?5server?5list?6@
CONST	SEGMENT
??_C@_0BI@FBMAGFAO@cannot?5get?5server?5list?6@ DB 'cannot get server lis'
	DB	't', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NOHIMKIJ@Retrieving?5server?5list?4?4?4?6@
CONST	SEGMENT
??_C@_0BL@NOHIMKIJ@Retrieving?5server?5list?4?4?4?6@ DB 'Retrieving serve'
	DB	'r list...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PANENJBJ@Not?5yet?5registered?5to?5the?5maste@
CONST	SEGMENT
??_C@_0CK@PANENJBJ@Not?5yet?5registered?5to?5the?5maste@ DB 'Not yet regi'
	DB	'stered to the master server.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IO@PFIMLPLI@You?5have?5been?5banned?5from?6joini@
CONST	SEGMENT
??_C@_0IO@PFIMLPLI@You?5have?5been?5banned?5from?6joini@ DB 'You have bee'
	DB	'n banned from', 0aH, 'joining netgames.', 0aH, 0aH, 'Under th'
	DB	'e following IP Range:', 0aH, '%s - %s', 0aH, 0aH, 'For the fo'
	DB	'llowing reason:', 0aH, '%s', 0aH, 0aH, 'Your ban will expire '
	DB	'on:', 0aH, '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IO@HKEKLKBF@You?5have?5been?5banned?5from?6hosti@
CONST	SEGMENT
??_C@_0IO@HKEKLKBF@You?5have?5been?5banned?5from?6hosti@ DB 'You have bee'
	DB	'n banned from', 0aH, 'hosting netgames.', 0aH, 0aH, 'Under th'
	DB	'e following IP Range:', 0aH, '%s - %s', 0aH, 0aH, 'For the fo'
	DB	'llowing reason:', 0aH, '%s', 0aH, 0aH, 'Your ban will expire '
	DB	'on:', 0aH, '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BMIEDOEC@Offline@
CONST	SEGMENT
??_C@_07BMIEDOEC@Offline@ DB 'Offline', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HBPKGLJE@Master?5Server?5Offline?4@
CONST	SEGMENT
??_C@_0BH@HBPKGLJE@Master?5Server?5Offline?4@ DB 'Master Server Offline.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PILCGDBG@There?5was?5a?5problem?5connecting?5@
CONST	SEGMENT
??_C@_0DE@PILCGDBG@There?5was?5a?5problem?5connecting?5@ DB 'There was a '
	DB	'problem connecting to', 0aH, 'the Master Server', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
CONST	SEGMENT
??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@ DB 'cannot conne'
	DB	'ct to the master server', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FEGPILHP@No?5servers?5currently?5running?4?6@
CONST	SEGMENT
??_C@_0BP@FEGPILHP@No?5servers?5currently?5running?4?6@ DB 'No servers cu'
	DB	'rrently running.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08LNKMFIHA@listserv@
CONST	SEGMENT
??_C@_08LNKMFIHA@listserv@ DB 'listserv', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_msnode	DD	0ffffffffH
_socket_fd DD	0ffffffffH
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	040cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0bbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0325H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0168H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0edH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	087H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _SendPingToMasterServer
_TEXT	SEGMENT
tv85 = -80						; size = 8
tv82 = -72						; size = 8
_SendPingToMasterServer PROC				; COMDAT

; 861  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 862  : /*	static tic_t next_time = 0;
; 863  : 	tic_t cur_time;
; 864  : 	char *inbuffer = (char*)netbuffer;
; 865  : 
; 866  : 	cur_time = I_GetTime();
; 867  : 	if (!netgame)
; 868  : 		UnregisterServer();
; 869  : 	else if (cur_time > next_time) // ping every 2 second if possible
; 870  : 	{
; 871  : 		next_time = cur_time+2*TICRATE;
; 872  : 
; 873  : 		if (con_state == MSCS_WAITING)
; 874  : 			AddToMasterServer();
; 875  : 
; 876  : 		if (con_state != MSCS_REGISTERED)
; 877  : 			return;
; 878  : 
; 879  : 		// cur_time is just a dummy data to send
; 880  : 		WRITEUINT32(inbuffer, cur_time);
; 881  : 		doomcom->datalength = sizeof (cur_time);
; 882  : 		doomcom->remotenode = (INT16)msnode;
; 883  : 		I_NetSend();
; 884  : 	}
; 885  : */
; 886  : 
; 887  : // Here, have a simpler MS Ping... - Cue
; 888  : 	if(time(NULL) > (MSLastPing+(60*2)) && con_state != MSCS_NONE)

  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _time
  00010	83 c4 04	 add	 esp, 4
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MSLastPing
  00019	83 c1 78	 add	 ecx, 120		; 00000078H
  0001c	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _MSLastPing+4
  00022	83 d6 00	 adc	 esi, 0
  00025	89 45 b8	 mov	 DWORD PTR tv82[ebp], eax
  00028	89 55 bc	 mov	 DWORD PTR tv82[ebp+4], edx
  0002b	89 4d b0	 mov	 DWORD PTR tv85[ebp], ecx
  0002e	89 75 b4	 mov	 DWORD PTR tv85[ebp+4], esi
  00031	8b 55 bc	 mov	 edx, DWORD PTR tv82[ebp+4]
  00034	3b 55 b4	 cmp	 edx, DWORD PTR tv85[ebp+4]
  00037	7c 3d		 jl	 SHORT $LN4@SendPingTo
  00039	7f 08		 jg	 SHORT $LN6@SendPingTo
  0003b	8b 45 b8	 mov	 eax, DWORD PTR tv82[ebp]
  0003e	3b 45 b0	 cmp	 eax, DWORD PTR tv85[ebp]
  00041	76 33		 jbe	 SHORT $LN4@SendPingTo
$LN6@SendPingTo:
  00043	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _con_state, 0
  0004a	74 2a		 je	 SHORT $LN4@SendPingTo

; 889  : 	{
; 890  : 		//CONS_Printf("%ld (current time) is greater than %d (Last Ping Time)\n", time(NULL), MSLastPing);
; 891  : 		if(MSLastPing < 1)

  0004c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _MSLastPing+4, 0
  00053	7f 17		 jg	 SHORT $LN3@SendPingTo
  00055	7c 09		 jl	 SHORT $LN7@SendPingTo
  00057	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _MSLastPing, 1
  0005e	73 0c		 jae	 SHORT $LN3@SendPingTo
$LN7@SendPingTo:

; 892  : 			AddToMasterServer(true);

  00060	6a 01		 push	 1
  00062	e8 00 00 00 00	 call	 _AddToMasterServer
  00067	83 c4 04	 add	 esp, 4
  0006a	eb 0a		 jmp	 SHORT $LN4@SendPingTo
$LN3@SendPingTo:

; 893  : 		else
; 894  : 			AddToMasterServer(false);

  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 _AddToMasterServer
  00073	83 c4 04	 add	 esp, 4
$LN4@SendPingTo:

; 895  : 	}
; 896  : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_SendPingToMasterServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _RemoveFromMasterSever
_TEXT	SEGMENT
_info$ = -1048						; size = 4
_msg$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_RemoveFromMasterSever PROC				; COMDAT

; 746  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 04 00
	00		 sub	 esp, 1240		; 000004d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 747  : 	msg_t msg;
; 748  : 	msg_server_t *info = (msg_server_t *)msg.buffer;

  00016	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp+16]
  0001c	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _info$[ebp], eax

; 749  : 
; 750  : 	strcpy(info->header.buffer, "");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00027	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _info$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _strcpy
  00033	83 c4 08	 add	 esp, 8

; 751  : 	strcpy(info->ip, "");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0003b	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _info$[ebp]
  00041	83 c0 10	 add	 eax, 16			; 00000010H
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _strcpy
  0004a	83 c4 08	 add	 esp, 8

; 752  : 	strcpy(info->port, int2str(current_port));

  0004d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _sock_port
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _int2str
  0005a	83 c4 04	 add	 esp, 4
  0005d	50		 push	 eax
  0005e	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _info$[ebp]
  00064	83 c1 20	 add	 ecx, 32			; 00000020H
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _strcpy
  0006d	83 c4 08	 add	 esp, 8

; 753  : 	strcpy(info->name, registered_server.name);

  00070	68 48 00 00 00	 push	 OFFSET _registered_server+72
  00075	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _info$[ebp]
  0007b	83 c0 28	 add	 eax, 40			; 00000028H
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _strcpy
  00084	83 c4 08	 add	 esp, 8

; 754  : 	sprintf(info->version, "%d.%d.%d", VERSION/100, VERSION%100, SUBVERSION);

  00087	6a 07		 push	 7
  00089	6a 00		 push	 0
  0008b	6a 02		 push	 2
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd@
  00092	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _info$[ebp]
  00098	83 c0 4c	 add	 eax, 76			; 0000004cH
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _sprintf
  000a1	83 c4 14	 add	 esp, 20			; 00000014H

; 755  : 
; 756  : 	msg.type = REMOVE_SERVER_MSG;

  000a4	c7 85 f0 fb ff
	ff 67 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 103 ; 00000067H

; 757  : 	msg.length = (UINT32)sizeof (msg_server_t);

  000ae	c7 85 f8 fb ff
	ff 54 00 00 00	 mov	 DWORD PTR _msg$[ebp+12], 84 ; 00000054H

; 758  : 	msg.room = 0;

  000b8	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+8], 0

; 759  : 	if (MS_Write(&msg) < 0)

  000c2	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _MS_Write
  000ce	83 c4 04	 add	 esp, 4
  000d1	85 c0		 test	 eax, eax
  000d3	7d 07		 jge	 SHORT $LN2@RemoveFrom

; 760  : 		return MS_WRITE_ERROR;

  000d5	b8 2e ff ff ff	 mov	 eax, -210		; ffffff2eH
  000da	eb 02		 jmp	 SHORT $LN1@RemoveFrom
$LN2@RemoveFrom:

; 761  : 
; 762  : 	return MS_NO_ERROR;

  000dc	33 c0		 xor	 eax, eax
$LN1@RemoveFrom:

; 763  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	33 cd		 xor	 ecx, ebp
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_RemoveFromMasterSever ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _AddToMasterServer
_TEXT	SEGMENT
tv79 = -1540						; size = 4
_insname$ = -1344					; size = 4
_tmp$ = -1340						; size = 4
_signature$ = -1336					; size = 4
_timestamp$ = -1332					; size = 8
_tset$ = -1324						; size = 260
_room$ = -1064						; size = 4
_info$ = -1060						; size = 4
_msg$ = -1056						; size = 1040
_j$ = -16						; size = 4
_res$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_firstadd$ = 8						; size = 4
_AddToMasterServer PROC					; COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 06 00
	00		 sub	 esp, 1540		; 00000604H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 649  : #ifdef NONET
; 650  : 	(void)firstadd;
; 651  : #else
; 652  : 	static INT32 retry = 0;
; 653  : 	int i, res;
; 654  : 	socklen_t j;
; 655  : 	msg_t msg;
; 656  : 	msg_server_t *info = (msg_server_t *)msg.buffer;

  00016	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp+16]
  0001c	89 85 dc fb ff
	ff		 mov	 DWORD PTR _info$[ebp], eax

; 657  : 	INT32 room = -1;

  00022	c7 85 d8 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _room$[ebp], -1

; 658  : 	fd_set tset;
; 659  : 	time_t timestamp = time(NULL);

  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 _time
  00033	83 c4 04	 add	 esp, 4
  00036	89 85 cc fa ff
	ff		 mov	 DWORD PTR _timestamp$[ebp], eax
  0003c	89 95 d0 fa ff
	ff		 mov	 DWORD PTR _timestamp$[ebp+4], edx

; 660  : 	UINT32 signature, tmp;
; 661  : 	const char *insname;
; 662  : 
; 663  : 	M_Memcpy(&tset, &wset, sizeof (tset));

  00042	68 04 01 00 00	 push	 260			; 00000104H
  00047	68 00 00 00 00	 push	 OFFSET _wset
  0004c	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _tset$[ebp]
  00052	50		 push	 eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 664  : 	res = select(255, NULL, &tset, NULL, &select_timeout);

  0005c	68 00 00 00 00	 push	 OFFSET _select_timeout
  00061	6a 00		 push	 0
  00063	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _tset$[ebp]
  00069	50		 push	 eax
  0006a	6a 00		 push	 0
  0006c	68 ff 00 00 00	 push	 255			; 000000ffH
  00071	e8 00 00 00 00	 call	 _select@20
  00076	89 45 f4	 mov	 DWORD PTR _res$[ebp], eax

; 665  : 	if (res != ERRSOCKET && !res)

  00079	83 7d f4 ff	 cmp	 DWORD PTR _res$[ebp], -1
  0007d	74 6b		 je	 SHORT $LN5@AddToMaste
  0007f	83 7d f4 00	 cmp	 DWORD PTR _res$[ebp], 0
  00083	75 65		 jne	 SHORT $LN5@AddToMaste

; 666  : 	{
; 667  : 		if (retry++ > 30) // an about 30 second timeout

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?retry@?1??AddToMasterServer@@9@9
  0008a	89 85 fc f9 ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?retry@?1??AddToMasterServer@@9@9
  00096	83 c1 01	 add	 ecx, 1
  00099	89 0d 00 00 00
	00		 mov	 DWORD PTR ?retry@?1??AddToMasterServer@@9@9, ecx
  0009f	83 bd fc f9 ff
	ff 1e		 cmp	 DWORD PTR tv79[ebp], 30	; 0000001eH
  000a6	7e 38		 jle	 SHORT $LN6@AddToMaste

; 668  : 		{
; 669  : 			retry = 0;

  000a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?retry@?1??AddToMasterServer@@9@9, 0

; 670  : 			CONS_Printf("Timeout on masterserver\n");

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EFDMONEA@Timeout?5on?5masterserver?6@
  000b7	e8 00 00 00 00	 call	 _CONS_Printf
  000bc	83 c4 04	 add	 esp, 4

; 671  : 			MSLastPing = timestamp;

  000bf	8b 85 cc fa ff
	ff		 mov	 eax, DWORD PTR _timestamp$[ebp]
  000c5	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _timestamp$[ebp+4]
  000cb	a3 00 00 00 00	 mov	 DWORD PTR _MSLastPing, eax
  000d0	89 0d 04 00 00
	00		 mov	 DWORD PTR _MSLastPing+4, ecx

; 672  : 			return ConnectionFailed();

  000d6	e8 00 00 00 00	 call	 _ConnectionFailed
  000db	e9 29 03 00 00	 jmp	 $LN1@AddToMaste
$LN6@AddToMaste:

; 673  : 		}
; 674  : 		return MS_CONNECT_ERROR;

  000e0	b8 35 ff ff ff	 mov	 eax, -203		; ffffff35H
  000e5	e9 1f 03 00 00	 jmp	 $LN1@AddToMaste
$LN5@AddToMaste:

; 675  : 	}
; 676  : 	retry = 0;

  000ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?retry@?1??AddToMasterServer@@9@9, 0

; 677  : 	if (res == ERRSOCKET)

  000f4	83 7d f4 ff	 cmp	 DWORD PTR _res$[ebp], -1
  000f8	75 5d		 jne	 SHORT $LN8@AddToMaste

; 678  : 	{
; 679  : 		if (MS_Connect(GetMasterServerIP(), GetMasterServerPort(), 0))

  000fa	6a 00		 push	 0
  000fc	e8 00 00 00 00	 call	 _GetMasterServerPort
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _GetMasterServerIP
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _MS_Connect
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00110	85 c0		 test	 eax, eax
  00112	74 43		 je	 SHORT $LN8@AddToMaste

; 680  : 		{
; 681  : 			CONS_Printf("Mastserver error on select #%u: %s\n", errno, strerror(errno));

  00114	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _strerror
  0011f	83 c4 04	 add	 esp, 4
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00128	50		 push	 eax
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LIHLBGPB@Mastserver?5error?5on?5select?5?$CD?$CFu?3@
  0012e	e8 00 00 00 00	 call	 _CONS_Printf
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 682  : 			MSLastPing = timestamp;

  00136	8b 85 cc fa ff
	ff		 mov	 eax, DWORD PTR _timestamp$[ebp]
  0013c	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _timestamp$[ebp+4]
  00142	a3 00 00 00 00	 mov	 DWORD PTR _MSLastPing, eax
  00147	89 0d 04 00 00
	00		 mov	 DWORD PTR _MSLastPing+4, ecx

; 683  : 			return ConnectionFailed();

  0014d	e8 00 00 00 00	 call	 _ConnectionFailed
  00152	e9 b2 02 00 00	 jmp	 $LN1@AddToMaste
$LN8@AddToMaste:

; 684  : 		}
; 685  : 	}
; 686  : 
; 687  : 	// so, the socket is writable, but what does that mean, that the connection is
; 688  : 	// ok, or bad... let see that!
; 689  : 	j = (socklen_t)sizeof (i);

  00157	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4

; 690  : 	getsockopt(socket_fd, SOL_SOCKET, SO_ERROR, (char *)&i, &j);

  0015e	8d 45 f0	 lea	 eax, DWORD PTR _j$[ebp]
  00161	50		 push	 eax
  00162	8d 4d f8	 lea	 ecx, DWORD PTR _i$[ebp]
  00165	51		 push	 ecx
  00166	68 07 10 00 00	 push	 4103			; 00001007H
  0016b	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00170	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _socket_fd
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 _getsockopt@20
  0017c	90		 npad	 1

; 691  : 	if (i) // it was bad

  0017d	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  00181	74 43		 je	 SHORT $LN9@AddToMaste

; 692  : 	{
; 693  : 		CONS_Printf("Masterserver getsockopt error #%u: %s\n", errno, strerror(errno));

  00183	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 _strerror
  0018e	83 c4 04	 add	 esp, 4
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00197	50		 push	 eax
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MOCAGAFN@Masterserver?5getsockopt?5error?5?$CD@
  0019d	e8 00 00 00 00	 call	 _CONS_Printf
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 694  : 		MSLastPing = timestamp;

  001a5	8b 85 cc fa ff
	ff		 mov	 eax, DWORD PTR _timestamp$[ebp]
  001ab	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _timestamp$[ebp+4]
  001b1	a3 00 00 00 00	 mov	 DWORD PTR _MSLastPing, eax
  001b6	89 0d 04 00 00
	00		 mov	 DWORD PTR _MSLastPing+4, ecx

; 695  : 		return ConnectionFailed();

  001bc	e8 00 00 00 00	 call	 _ConnectionFailed
  001c1	e9 43 02 00 00	 jmp	 $LN1@AddToMaste
$LN9@AddToMaste:

; 696  : 	}
; 697  : 
; 698  : 	if (dedicated && (M_CheckParm("-room") && M_IsNextParm()))

  001c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  001cd	74 43		 je	 SHORT $LN10@AddToMaste
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_05IGIAIFLJ@?9room@
  001d4	e8 00 00 00 00	 call	 _M_CheckParm
  001d9	83 c4 04	 add	 esp, 4
  001dc	85 c0		 test	 eax, eax
  001de	74 32		 je	 SHORT $LN10@AddToMaste
  001e0	e8 00 00 00 00	 call	 _M_IsNextParm
  001e5	85 c0		 test	 eax, eax
  001e7	74 29		 je	 SHORT $LN10@AddToMaste

; 699  : 	{
; 700  : 		room = atoi(M_GetNextParm());

  001e9	e8 00 00 00 00	 call	 _M_GetNextParm
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _atoi
  001f4	83 c4 04	 add	 esp, 4
  001f7	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _room$[ebp], eax

; 701  : 		if(room == 0)

  001fd	83 bd d8 fb ff
	ff 00		 cmp	 DWORD PTR _room$[ebp], 0
  00204	75 0a		 jne	 SHORT $LN12@AddToMaste

; 702  : 			room = -1;

  00206	c7 85 d8 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _room$[ebp], -1
$LN12@AddToMaste:

; 703  : 	}

  00210	eb 20		 jmp	 SHORT $LN14@AddToMaste
$LN10@AddToMaste:

; 704  : 	else if(dedicated)

  00212	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00219	74 0c		 je	 SHORT $LN13@AddToMaste

; 705  : 		room = -1;

  0021b	c7 85 d8 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _room$[ebp], -1
  00225	eb 0b		 jmp	 SHORT $LN14@AddToMaste
$LN13@AddToMaste:

; 706  : 	else
; 707  : 		room = cv_chooseroom.value;

  00227	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_chooseroom+20
  0022c	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _room$[ebp], eax
$LN14@AddToMaste:

; 708  : 
; 709  : 	for(signature = 0, insname = cv_servername.string; *insname; signature += *insname++);

  00232	c7 85 c8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _signature$[ebp], 0
  0023c	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_servername+24
  00241	89 85 c0 fa ff
	ff		 mov	 DWORD PTR _insname$[ebp], eax
  00247	eb 24		 jmp	 SHORT $LN4@AddToMaste
$LN2@AddToMaste:
  00249	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _insname$[ebp]
  0024f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00252	03 8d c8 fa ff
	ff		 add	 ecx, DWORD PTR _signature$[ebp]
  00258	89 8d c8 fa ff
	ff		 mov	 DWORD PTR _signature$[ebp], ecx
  0025e	8b 95 c0 fa ff
	ff		 mov	 edx, DWORD PTR _insname$[ebp]
  00264	83 c2 01	 add	 edx, 1
  00267	89 95 c0 fa ff
	ff		 mov	 DWORD PTR _insname$[ebp], edx
$LN4@AddToMaste:
  0026d	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _insname$[ebp]
  00273	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00276	85 c9		 test	 ecx, ecx
  00278	74 02		 je	 SHORT $LN3@AddToMaste
  0027a	eb cd		 jmp	 SHORT $LN2@AddToMaste
$LN3@AddToMaste:

; 710  : 	tmp = (UINT32)(signature * (size_t)&MSLastPing);

  0027c	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _signature$[ebp]
  00282	69 c0 00 00 00
	00		 imul	 eax, OFFSET _MSLastPing
  00288	89 85 c4 fa ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 711  : 	signature *= tmp;

  0028e	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _signature$[ebp]
  00294	0f af 85 c4 fa
	ff ff		 imul	 eax, DWORD PTR _tmp$[ebp]
  0029b	89 85 c8 fa ff
	ff		 mov	 DWORD PTR _signature$[ebp], eax

; 712  : 	signature &= 0xAAAAAAAA;

  002a1	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _signature$[ebp]
  002a7	25 aa aa aa aa	 and	 eax, -1431655766	; aaaaaaaaH
  002ac	89 85 c8 fa ff
	ff		 mov	 DWORD PTR _signature$[ebp], eax

; 713  : 	M_Memcpy(&info->header.signature, &signature, sizeof (UINT32));

  002b2	6a 04		 push	 4
  002b4	8d 85 c8 fa ff
	ff		 lea	 eax, DWORD PTR _signature$[ebp]
  002ba	50		 push	 eax
  002bb	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _info$[ebp]
  002c1	51		 push	 ecx
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 714  : 
; 715  : 	strcpy(info->ip, "");

  002cb	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  002d0	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _info$[ebp]
  002d6	83 c0 10	 add	 eax, 16			; 00000010H
  002d9	50		 push	 eax
  002da	e8 00 00 00 00	 call	 _strcpy
  002df	83 c4 08	 add	 esp, 8

; 716  : 	strcpy(info->port, int2str(current_port));

  002e2	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _sock_port
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 _int2str
  002ef	83 c4 04	 add	 esp, 4
  002f2	50		 push	 eax
  002f3	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _info$[ebp]
  002f9	83 c1 20	 add	 ecx, 32			; 00000020H
  002fc	51		 push	 ecx
  002fd	e8 00 00 00 00	 call	 _strcpy
  00302	83 c4 08	 add	 esp, 8

; 717  : 	strcpy(info->name, cv_servername.string);

  00305	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_servername+24
  0030a	50		 push	 eax
  0030b	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _info$[ebp]
  00311	83 c1 28	 add	 ecx, 40			; 00000028H
  00314	51		 push	 ecx
  00315	e8 00 00 00 00	 call	 _strcpy
  0031a	83 c4 08	 add	 esp, 8

; 718  : 	M_Memcpy(&info->room, & room, sizeof (INT32));

  0031d	6a 04		 push	 4
  0031f	8d 85 d8 fb ff
	ff		 lea	 eax, DWORD PTR _room$[ebp]
  00325	50		 push	 eax
  00326	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _info$[ebp]
  0032c	83 c1 48	 add	 ecx, 72			; 00000048H
  0032f	51		 push	 ecx
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00336	83 c4 0c	 add	 esp, 12			; 0000000cH

; 719  : 	sprintf(info->version, "%d.%d.%d", VERSION/100, VERSION%100, SUBVERSION);

  00339	6a 07		 push	 7
  0033b	6a 00		 push	 0
  0033d	6a 02		 push	 2
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd@
  00344	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _info$[ebp]
  0034a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0034d	50		 push	 eax
  0034e	e8 00 00 00 00	 call	 _sprintf
  00353	83 c4 14	 add	 esp, 20			; 00000014H

; 720  : 	strcpy(registered_server.name, cv_servername.string);

  00356	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_servername+24
  0035b	50		 push	 eax
  0035c	68 48 00 00 00	 push	 OFFSET _registered_server+72
  00361	e8 00 00 00 00	 call	 _strcpy
  00366	83 c4 08	 add	 esp, 8

; 721  : 
; 722  : 	if(firstadd)

  00369	83 7d 08 00	 cmp	 DWORD PTR _firstadd$[ebp], 0
  0036d	74 0c		 je	 SHORT $LN15@AddToMaste

; 723  : 		msg.type = ADD_SERVER_MSG;

  0036f	c7 85 e4 fb ff
	ff 65 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 101 ; 00000065H
  00379	eb 0a		 jmp	 SHORT $LN16@AddToMaste
$LN15@AddToMaste:

; 724  : 	else
; 725  : 		msg.type = PING_SERVER_MSG;

  0037b	c7 85 e4 fb ff
	ff d8 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 216 ; 000000d8H
$LN16@AddToMaste:

; 726  : 
; 727  : 	msg.length = (UINT32)sizeof (msg_server_t);

  00385	c7 85 ec fb ff
	ff 54 00 00 00	 mov	 DWORD PTR _msg$[ebp+12], 84 ; 00000054H

; 728  : 	msg.room = 0;

  0038f	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+8], 0

; 729  : 	if (MS_Write(&msg) < 0)

  00399	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 _MS_Write
  003a5	83 c4 04	 add	 esp, 4
  003a8	85 c0		 test	 eax, eax
  003aa	7d 1e		 jge	 SHORT $LN17@AddToMaste

; 730  : 	{
; 731  : 		MSLastPing = timestamp;

  003ac	8b 85 cc fa ff
	ff		 mov	 eax, DWORD PTR _timestamp$[ebp]
  003b2	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _timestamp$[ebp+4]
  003b8	a3 00 00 00 00	 mov	 DWORD PTR _MSLastPing, eax
  003bd	89 0d 04 00 00
	00		 mov	 DWORD PTR _MSLastPing+4, ecx

; 732  : 		return ConnectionFailed();

  003c3	e8 00 00 00 00	 call	 _ConnectionFailed
  003c8	eb 3f		 jmp	 SHORT $LN1@AddToMaste
$LN17@AddToMaste:

; 733  : 	}
; 734  : 
; 735  : 	if(con_state != MSCS_REGISTERED)

  003ca	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _con_state, 2
  003d1	74 0d		 je	 SHORT $LN18@AddToMaste

; 736  : 		CONS_Printf("Master Server Updated Successfully!\n");

  003d3	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CJGMNOGD@Master?5Server?5Updated?5Successfu@
  003d8	e8 00 00 00 00	 call	 _CONS_Printf
  003dd	83 c4 04	 add	 esp, 4
$LN18@AddToMaste:

; 737  : 
; 738  : 	MSLastPing = timestamp;

  003e0	8b 85 cc fa ff
	ff		 mov	 eax, DWORD PTR _timestamp$[ebp]
  003e6	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _timestamp$[ebp+4]
  003ec	a3 00 00 00 00	 mov	 DWORD PTR _MSLastPing, eax
  003f1	89 0d 04 00 00
	00		 mov	 DWORD PTR _MSLastPing+4, ecx

; 739  : 	con_state = MSCS_REGISTERED;

  003f7	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _con_state, 2

; 740  : 	CloseConnection();

  00401	e8 00 00 00 00	 call	 _CloseConnection
  00406	90		 npad	 1

; 741  : #endif
; 742  : 	return MS_NO_ERROR;

  00407	33 c0		 xor	 eax, eax
$LN1@AddToMaste:

; 743  : }

  00409	5f		 pop	 edi
  0040a	5e		 pop	 esi
  0040b	5b		 pop	 ebx
  0040c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040f	33 cd		 xor	 ecx, ebp
  00411	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00416	8b e5		 mov	 esp, ebp
  00418	5d		 pop	 ebp
  00419	c3		 ret	 0
_AddToMasterServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _ConnectionFailed
_TEXT	SEGMENT
_ConnectionFailed PROC					; COMDAT

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 638  : 	con_state = MSCS_FAILED;

  00009	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _con_state, 3

; 639  : 	CONS_Printf("Connection to master server failed\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LAPJJAPM@Connection?5to?5master?5server?5fai@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 640  : 	CloseConnection();

  00020	e8 00 00 00 00	 call	 _CloseConnection
  00025	90		 npad	 1

; 641  : 	return MS_CONNECT_ERROR;

  00026	b8 35 ff ff ff	 mov	 eax, -203		; ffffff35H

; 642  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_ConnectionFailed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _int2str
_TEXT	SEGMENT
$T1 = -72						; size = 4
_i$ = -4						; size = 4
_n$ = 8							; size = 4
_int2str PROC						; COMDAT

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 624  : 	INT32 i;
; 625  : 	static char res[16];
; 626  : 
; 627  : 	res[15] = '\0';

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	6b c8 0f	 imul	 ecx, eax, 15
  00011	89 4d b8	 mov	 DWORD PTR $T1[ebp], ecx
  00014	83 7d b8 10	 cmp	 DWORD PTR $T1[ebp], 16	; 00000010H
  00018	73 02		 jae	 SHORT $LN6@int2str
  0001a	eb 06		 jmp	 SHORT $LN7@int2str
$LN6@int2str:
  0001c	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00021	90		 npad	 1
$LN7@int2str:
  00022	8b 55 b8	 mov	 edx, DWORD PTR $T1[ebp]
  00025	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?res@?1??int2str@@9@9[edx], 0

; 628  : 	res[14] = (char)((char)(n%10)+'0');

  0002c	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  0002f	99		 cdq
  00030	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00035	f7 f9		 idiv	 ecx
  00037	0f be d2	 movsx	 edx, dl
  0003a	83 c2 30	 add	 edx, 48			; 00000030H
  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	6b c8 0e	 imul	 ecx, eax, 14
  00045	88 91 00 00 00
	00		 mov	 BYTE PTR ?res@?1??int2str@@9@9[ecx], dl

; 629  : 	for (i = 13; (n /= 10); i--)

  0004b	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR _i$[ebp], 13	; 0000000dH
  00052	eb 09		 jmp	 SHORT $LN4@int2str
$LN2@int2str:
  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	83 e8 01	 sub	 eax, 1
  0005a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@int2str:
  0005d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00060	99		 cdq
  00061	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00066	f7 f9		 idiv	 ecx
  00068	89 45 08	 mov	 DWORD PTR _n$[ebp], eax
  0006b	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  0006f	74 1c		 je	 SHORT $LN3@int2str

; 630  : 		res[i] = (char)((char)(n%10)+'0');

  00071	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00074	99		 cdq
  00075	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0007a	f7 f9		 idiv	 ecx
  0007c	0f be d2	 movsx	 edx, dl
  0007f	83 c2 30	 add	 edx, 48			; 00000030H
  00082	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00085	88 90 00 00 00
	00		 mov	 BYTE PTR ?res@?1??int2str@@9@9[eax], dl
  0008b	eb c7		 jmp	 SHORT $LN2@int2str
$LN3@int2str:

; 631  : 
; 632  : 	return &res[i+1];

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00090	05 01 00 00 00	 add	 eax, OFFSET ?res@?1??int2str@@9@9+1
$LN1@int2str:

; 633  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_int2str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MS_Connect
_TEXT	SEGMENT
_res$1 = -8						; size = 4
_j$ = -4						; size = 4
_ip_addr$ = 8						; size = 4
_str_port$ = 12						; size = 4
_async$ = 16						; size = 4
_MS_Connect PROC					; COMDAT

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 400  : #ifdef NONET
; 401  : 	str_port = ip_addr = NULL;
; 402  : 	async = MS_CONNECT_ERROR;
; 403  : 	return async;
; 404  : #else
; 405  : 	socklen_t j = (socklen_t)sizeof(addr);

  00009	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _j$[ebp], 16	; 00000010H

; 406  : //	I_InitTcpNetwork(); this is already done on startup in D_SRB2Main()
; 407  : 	if (!I_InitTcpDriver()) // this is done only if not already done

  00010	e8 00 00 00 00	 call	 _I_InitTcpDriver
  00015	85 c0		 test	 eax, eax
  00017	75 0a		 jne	 SHORT $LN5@MS_Connect

; 408  : 		return MS_SOCKET_ERROR;

  00019	b8 37 ff ff ff	 mov	 eax, -201		; ffffff37H
  0001e	e9 5c 01 00 00	 jmp	 $LN1@MS_Connect
$LN5@MS_Connect:

; 409  : 	memset(&addr, 0, sizeof (addr));

  00023	6a 10		 push	 16			; 00000010H
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET _addr
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  : 	addr.sin_family = AF_INET;

  00034	b8 02 00 00 00	 mov	 eax, 2
  00039	66 a3 00 00 00
	00		 mov	 WORD PTR _addr, ax

; 411  : 
; 412  : 	socket_fd = socket(AF_INET, SOCK_STREAM, 0);

  0003f	6a 00		 push	 0
  00041	6a 01		 push	 1
  00043	6a 02		 push	 2
  00045	e8 00 00 00 00	 call	 _socket@12
  0004a	a3 00 00 00 00	 mov	 DWORD PTR _socket_fd, eax

; 413  : 	if (socket_fd == BADSOCKET || socket_fd == (SOCKET_TYPE)ERRSOCKET)

  0004f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _socket_fd, -1
  00056	74 09		 je	 SHORT $LN7@MS_Connect
  00058	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _socket_fd, -1
  0005f	75 0a		 jne	 SHORT $LN6@MS_Connect
$LN7@MS_Connect:

; 414  : 		return MS_SOCKET_ERROR;

  00061	b8 37 ff ff ff	 mov	 eax, -201		; ffffff37H
  00066	e9 14 01 00 00	 jmp	 $LN1@MS_Connect
$LN6@MS_Connect:

; 415  : 
; 416  : 	if (MS_GetIP(ip_addr) == MS_GETHOSTBYNAME_ERROR)

  0006b	8b 45 08	 mov	 eax, DWORD PTR _ip_addr$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _MS_GetIP
  00074	83 c4 04	 add	 esp, 4
  00077	3d 24 ff ff ff	 cmp	 eax, -220		; ffffff24H
  0007c	75 0a		 jne	 SHORT $LN8@MS_Connect

; 417  : 		return MS_GETHOSTBYNAME_ERROR;

  0007e	b8 24 ff ff ff	 mov	 eax, -220		; ffffff24H
  00083	e9 f7 00 00 00	 jmp	 $LN1@MS_Connect
$LN8@MS_Connect:

; 418  : 	addr.sin_port = htons((UINT16)atoi(str_port));

  00088	8b 45 0c	 mov	 eax, DWORD PTR _str_port$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _atoi
  00091	83 c4 04	 add	 esp, 4
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _htons@4
  0009a	66 a3 02 00 00
	00		 mov	 WORD PTR _addr+2, ax

; 419  : 
; 420  : 	if (async) // do asynchronous connection

  000a0	83 7d 10 00	 cmp	 DWORD PTR _async$[ebp], 0
  000a4	0f 84 b2 00 00
	00		 je	 $LN9@MS_Connect

; 421  : 	{
; 422  : #ifdef WATTCP
; 423  : 		char res = 1;
; 424  : #else
; 425  : 		unsigned long res = 1;

  000aa	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _res$1[ebp], 1

; 426  : #endif
; 427  : 
; 428  : 		ioctl(socket_fd, FIONBIO, &res);

  000b1	8d 45 f8	 lea	 eax, DWORD PTR _res$1[ebp]
  000b4	50		 push	 eax
  000b5	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  000ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _socket_fd
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _ioctlsocket@12
  000c6	90		 npad	 1

; 429  : 
; 430  : 		if (connect(socket_fd, (void *)&addr, j) == ERRSOCKET)

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  000ca	50		 push	 eax
  000cb	68 00 00 00 00	 push	 OFFSET _addr
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _socket_fd
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 _connect@12
  000dc	83 f8 ff	 cmp	 eax, -1
  000df	75 23		 jne	 SHORT $LN12@MS_Connect

; 431  : 		{
; 432  : #ifdef _WIN32 // humm, on win32/win64 it doesn't work with EINPROGRESS (stupid windows)
; 433  : 			if (WSAGetLastError() != WSAEWOULDBLOCK)

  000e1	e8 00 00 00 00	 call	 _WSAGetLastError@0
  000e6	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  000eb	74 17		 je	 SHORT $LN12@MS_Connect

; 434  : #else
; 435  : 			if (errno != EINPROGRESS)
; 436  : #endif
; 437  : 			{
; 438  : 				con_state = MSCS_FAILED;

  000ed	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _con_state, 3

; 439  : 				CloseConnection();

  000f7	e8 00 00 00 00	 call	 _CloseConnection
  000fc	90		 npad	 1

; 440  : 				return MS_CONNECT_ERROR;

  000fd	b8 35 ff ff ff	 mov	 eax, -203		; ffffff35H
  00102	eb 7b		 jmp	 SHORT $LN1@MS_Connect
$LN12@MS_Connect:

; 441  : 			}
; 442  : 		}
; 443  : 		con_state = MSCS_WAITING;

  00104	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _con_state, 1

; 444  : 		FD_ZERO(&wset);

  0010e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _wset, 0
$LN4@MS_Connect:

; 445  : 		FD_SET(socket_fd, &wset);

  00118	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR _wset, 64	; 00000040H
  0011f	73 21		 jae	 SHORT $LN13@MS_Connect
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _wset
  00126	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _socket_fd
  0012c	89 0c 85 04 00
	00 00		 mov	 DWORD PTR _wset[eax*4+4], ecx
  00133	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wset
  00139	83 c2 01	 add	 edx, 1
  0013c	89 15 00 00 00
	00		 mov	 DWORD PTR _wset, edx
$LN13@MS_Connect:
  00142	33 c0		 xor	 eax, eax
  00144	75 d2		 jne	 SHORT $LN4@MS_Connect

; 446  : 		select_timeout.tv_sec = 0, select_timeout.tv_usec = 0;

  00146	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _select_timeout, 0
  00150	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _select_timeout+4, 0

; 447  : 	}

  0015a	eb 21		 jmp	 SHORT $LN14@MS_Connect
$LN9@MS_Connect:

; 448  : 	else if (connect(socket_fd, (void *)&addr, j) == ERRSOCKET)

  0015c	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  0015f	50		 push	 eax
  00160	68 00 00 00 00	 push	 OFFSET _addr
  00165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _socket_fd
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 _connect@12
  00171	83 f8 ff	 cmp	 eax, -1
  00174	75 07		 jne	 SHORT $LN14@MS_Connect

; 449  : 		return MS_CONNECT_ERROR;

  00176	b8 35 ff ff ff	 mov	 eax, -203		; ffffff35H
  0017b	eb 02		 jmp	 SHORT $LN1@MS_Connect
$LN14@MS_Connect:

; 450  : 	return 0;

  0017d	33 c0		 xor	 eax, eax
$LN1@MS_Connect:

; 451  : #endif
; 452  : }

  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
_MS_Connect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MS_GetIP
_TEXT	SEGMENT
_host_ent$ = -4						; size = 4
_hostname$ = 8						; size = 4
_MS_GetIP PROC						; COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 382  : 	struct hostent *host_ent;
; 383  : 	if (!inet_aton(hostname, (void *)&addr.sin_addr))

  00009	68 04 00 00 00	 push	 OFFSET _addr+4
  0000e	8b 45 08	 mov	 eax, DWORD PTR _hostname$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _inet_aton
  00017	83 c4 08	 add	 esp, 8
  0001a	85 c0		 test	 eax, eax
  0001c	75 3b		 jne	 SHORT $LN2@MS_GetIP

; 384  : 	{
; 385  : 		/// \todo only when we are connected to the Internet, or use a non blocking call
; 386  : 		host_ent = gethostbyname(hostname);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _hostname$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _gethostbyname@4
  00027	89 45 fc	 mov	 DWORD PTR _host_ent$[ebp], eax

; 387  : 		if (!host_ent)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _host_ent$[ebp], 0
  0002e	75 07		 jne	 SHORT $LN3@MS_GetIP

; 388  : 			return MS_GETHOSTBYNAME_ERROR;

  00030	b8 24 ff ff ff	 mov	 eax, -220		; ffffff24H
  00035	eb 24		 jmp	 SHORT $LN1@MS_GetIP
$LN3@MS_GetIP:

; 389  : 		M_Memcpy(&addr.sin_addr, host_ent->h_addr_list[0], sizeof (struct in_addr));

  00037	6a 04		 push	 4
  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 55 fc	 mov	 edx, DWORD PTR _host_ent$[ebp]
  00044	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00047	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0004a	51		 push	 ecx
  0004b	68 04 00 00 00	 push	 OFFSET _addr+4
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@MS_GetIP:

; 390  : 	}
; 391  : 	return 0;

  00059	33 c0		 xor	 eax, eax
$LN1@MS_GetIP:

; 392  : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_MS_GetIP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _GetServersList
_TEXT	SEGMENT
_count$ = -1048						; size = 4
_msg$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_GetServersList PROC					; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 04 00
	00		 sub	 esp, 1240		; 000004d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 325  : 	msg_t msg;
; 326  : 	INT32 count = 0;

  00016	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0

; 327  : 
; 328  : 	msg.type = GET_SERVER_MSG;

  00020	c7 85 f0 fb ff
	ff c8 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 200 ; 000000c8H

; 329  : 	msg.length = 0;

  0002a	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+12], 0

; 330  : 	msg.room = 0;

  00034	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+8], 0

; 331  : 	if (MS_Write(&msg) < 0)

  0003e	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _MS_Write
  0004a	83 c4 04	 add	 esp, 4
  0004d	85 c0		 test	 eax, eax
  0004f	7d 07		 jge	 SHORT $LN4@GetServers

; 332  : 		return MS_WRITE_ERROR;

  00051	b8 2e ff ff ff	 mov	 eax, -210		; ffffff2eH
  00056	eb 60		 jmp	 SHORT $LN1@GetServers
$LN4@GetServers:

; 333  : 
; 334  : 	while (MS_Read(&msg) >= 0)

  00058	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _MS_Read
  00064	83 c4 04	 add	 esp, 4
  00067	85 c0		 test	 eax, eax
  00069	7c 48		 jl	 SHORT $LN3@GetServers

; 335  : 	{
; 336  : 		if (!msg.length)

  0006b	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _msg$[ebp+12], 0
  00072	75 1a		 jne	 SHORT $LN5@GetServers

; 337  : 		{
; 338  : 			if (!count)

  00074	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  0007b	75 0d		 jne	 SHORT $LN6@GetServers

; 339  : 				CONS_Printf("No servers currently running.\n");

  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FEGPILHP@No?5servers?5currently?5running?4?6@
  00082	e8 00 00 00 00	 call	 _CONS_Printf
  00087	83 c4 04	 add	 esp, 4
$LN6@GetServers:

; 340  : 			return MS_NO_ERROR;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 2a		 jmp	 SHORT $LN1@GetServers
$LN5@GetServers:

; 341  : 		}
; 342  : 		count++;

  0008e	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00094	83 c0 01	 add	 eax, 1
  00097	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 343  : 		CONS_Printf("%s",msg.buffer);

  0009d	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp+16]
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000a9	e8 00 00 00 00	 call	 _CONS_Printf
  000ae	83 c4 08	 add	 esp, 8

; 344  : 	}

  000b1	eb a5		 jmp	 SHORT $LN4@GetServers
$LN3@GetServers:

; 345  : 
; 346  : 	return MS_READ_ERROR;

  000b3	b8 2d ff ff ff	 mov	 eax, -211		; ffffff2dH
$LN1@GetServers:

; 347  : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_GetServersList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MS_Read
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_MS_Read PROC						; COMDAT

; 300  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 301  : #ifdef NONET
; 302  : 	msg = NULL;
; 303  : 	return MS_READ_ERROR;
; 304  : #else
; 305  : 	if (recvfull(socket_fd, (char *)msg, HEADER_SIZE, 0) != HEADER_SIZE)

  00009	6a 00		 push	 0
  0000b	6a 10		 push	 16			; 00000010H
  0000d	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00010	50		 push	 eax
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _socket_fd
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _recvfull
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
  00020	83 f8 10	 cmp	 eax, 16			; 00000010H
  00023	74 07		 je	 SHORT $LN2@MS_Read

; 306  : 		return MS_READ_ERROR;

  00025	b8 2d ff ff ff	 mov	 eax, -211		; ffffff2dH
  0002a	eb 72		 jmp	 SHORT $LN1@MS_Read
$LN2@MS_Read:

; 307  : 
; 308  : 	msg->type = ntohl(msg->type);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _ntohl@4
  00038	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  0003b	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 309  : 	msg->length = ntohl(msg->length);

  0003e	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00041	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _ntohl@4
  0004a	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  0004d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 310  : 	msg->room = ntohl(msg->room);

  00050	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00053	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _ntohl@4
  0005c	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  0005f	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 311  : 
; 312  : 	if (!msg->length) // fix a bug in Windows 2000

  00062	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00065	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00069	75 04		 jne	 SHORT $LN3@MS_Read

; 313  : 		return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	eb 2f		 jmp	 SHORT $LN1@MS_Read
$LN3@MS_Read:

; 314  : 
; 315  : 	if (recvfull(socket_fd, (char *)msg->buffer, msg->length, 0) != msg->length)

  0006f	6a 00		 push	 0
  00071	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00074	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00077	51		 push	 ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  0007b	83 c2 10	 add	 edx, 16			; 00000010H
  0007e	52		 push	 edx
  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _socket_fd
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _recvfull
  0008a	83 c4 10	 add	 esp, 16			; 00000010H
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  00090	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00093	74 07		 je	 SHORT $LN4@MS_Read

; 316  : 		return MS_READ_ERROR;

  00095	b8 2d ff ff ff	 mov	 eax, -211		; ffffff2dH
  0009a	eb 02		 jmp	 SHORT $LN1@MS_Read
$LN4@MS_Read:

; 317  : 	return 0;

  0009c	33 c0		 xor	 eax, eax
$LN1@MS_Read:

; 318  : #endif
; 319  : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_MS_Read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MS_Write
_TEXT	SEGMENT
_len$ = -4						; size = 4
_msg$ = 8						; size = 4
_MS_Write PROC						; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 276  : #ifdef NONET
; 277  : 	msg = NULL;
; 278  : 	return MS_WRITE_ERROR;
; 279  : #else
; 280  : 	size_t len;
; 281  : 
; 282  : 	if (msg->length == 0)

  00009	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	75 15		 jne	 SHORT $LN2@MS_Write

; 283  : 		msg->length = (INT32)strlen(msg->buffer);

  00012	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _strlen
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  00024	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN2@MS_Write:

; 284  : 	len = msg->length + HEADER_SIZE;

  00027	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	83 c1 10	 add	 ecx, 16			; 00000010H
  00030	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 285  : 
; 286  : 	msg->type = htonl(msg->type);

  00033	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _htonl@4
  0003f	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  00042	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 287  : 	msg->length = htonl(msg->length);

  00045	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00048	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _htonl@4
  00051	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  00054	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 288  : 	msg->room = htonl(msg->room);

  00057	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  0005a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _htonl@4
  00063	8b 55 08	 mov	 edx, DWORD PTR _msg$[ebp]
  00066	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 289  : 
; 290  : 	if ((size_t)send(socket_fd, (char *)msg, (int)len, 0) != len)

  00069	6a 00		 push	 0
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _msg$[ebp]
  00072	51		 push	 ecx
  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _socket_fd
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _send@16
  0007f	3b 45 fc	 cmp	 eax, DWORD PTR _len$[ebp]
  00082	74 07		 je	 SHORT $LN3@MS_Write

; 291  : 		return MS_WRITE_ERROR;

  00084	b8 2e ff ff ff	 mov	 eax, -210		; ffffff2eH
  00089	eb 02		 jmp	 SHORT $LN1@MS_Write
$LN3@MS_Write:

; 292  : 	return 0;

  0008b	33 c0		 xor	 eax, eax
$LN1@MS_Write:

; 293  : #endif
; 294  : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_MS_Write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _CloseConnection
_TEXT	SEGMENT
_CloseConnection PROC					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 264  : #ifndef NONET
; 265  : 	if (socket_fd != (SOCKET_TYPE)ERRSOCKET && socket_fd != BADSOCKET)

  00009	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _socket_fd, -1
  00010	74 15		 je	 SHORT $LN2@CloseConne
  00012	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _socket_fd, -1
  00019	74 0c		 je	 SHORT $LN2@CloseConne

; 266  : 		close(socket_fd);

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _socket_fd
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _closesocket@4
  00026	90		 npad	 1
$LN2@CloseConne:

; 267  : 	socket_fd = BADSOCKET;

  00027	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _socket_fd, -1

; 268  : #endif
; 269  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_CloseConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _recvfull
_TEXT	SEGMENT
_ret$1 = -8						; size = 4
_totallen$ = -4						; size = 4
_s$ = 8							; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_flags$ = 20						; size = 4
_recvfull PROC						; COMDAT

; 996  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 997  : 	/* Total received. */
; 998  : 	size_t totallen = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _totallen$[ebp], 0
$LN2@recvfull:

; 999  : 
; 1000 : 	while(totallen < len)

  00010	8b 45 fc	 mov	 eax, DWORD PTR _totallen$[ebp]
  00013	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00016	73 34		 jae	 SHORT $LN3@recvfull

; 1001 : 	{
; 1002 : 		ssize_t ret = (ssize_t)recv(s, buf + totallen, (int)(len - totallen), flags);

  00018	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0001f	2b 4d fc	 sub	 ecx, DWORD PTR _totallen$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00026	03 55 fc	 add	 edx, DWORD PTR _totallen$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _recv@16
  00033	89 45 f8	 mov	 DWORD PTR _ret$1[ebp], eax

; 1003 : 
; 1004 : 		/* Error. */
; 1005 : 		if(ret == -1)

  00036	83 7d f8 ff	 cmp	 DWORD PTR _ret$1[ebp], -1
  0003a	75 05		 jne	 SHORT $LN4@recvfull

; 1006 : 			return (size_t)-1;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	eb 0e		 jmp	 SHORT $LN1@recvfull
$LN4@recvfull:

; 1007 : 
; 1008 : 		totallen += ret;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _totallen$[ebp]
  00044	03 45 f8	 add	 eax, DWORD PTR _ret$1[ebp]
  00047	89 45 fc	 mov	 DWORD PTR _totallen$[ebp], eax

; 1009 : 	}

  0004a	eb c4		 jmp	 SHORT $LN2@recvfull
$LN3@recvfull:

; 1010 : 
; 1011 : 	return totallen;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _totallen$[ebp]
$LN1@recvfull:

; 1012 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_recvfull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _ServerName_OnChange
_TEXT	SEGMENT
_ServerName_OnChange PROC				; COMDAT

; 964  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 965  : 	UnregisterServer();

  00009	e8 00 00 00 00	 call	 _UnregisterServer
  0000e	90		 npad	 1

; 966  : 	RegisterServer();

  0000f	e8 00 00 00 00	 call	 _RegisterServer
  00014	90		 npad	 1

; 967  : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_ServerName_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MasterServer_OnChange
_TEXT	SEGMENT
_MasterServer_OnChange PROC				; COMDAT

; 988  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 989  : 	UnregisterServer();

  00009	e8 00 00 00 00	 call	 _UnregisterServer
  0000e	90		 npad	 1

; 990  : 	RegisterServer();

  0000f	e8 00 00 00 00	 call	 _RegisterServer
  00014	90		 npad	 1

; 991  : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_MasterServer_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _InternetServer_OnChange
_TEXT	SEGMENT
_InternetServer_OnChange PROC				; COMDAT

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 971  : /*	if (cv_internetserver.value)
; 972  : 		RegisterServer();
; 973  : 	else
; 974  : 		UnregisterServer(); */
; 975  : 	if(cv_internetserver.value && Playing())

  00009	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_internetserver+20, 0
  00010	74 27		 je	 SHORT $LN2@InternetSe
  00012	e8 00 00 00 00	 call	 _Playing
  00017	85 c0		 test	 eax, eax
  00019	74 1e		 je	 SHORT $LN2@InternetSe

; 976  : 	{
; 977  : 		CV_StealthSetValue(&cv_internetserver, 0);

  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET _cv_internetserver
  00022	e8 00 00 00 00	 call	 _CV_StealthSetValue
  00027	83 c4 08	 add	 esp, 8

; 978  : 		CONS_Printf("You cannot register on the Master Server mid-game, please end your current session and re-host if you wish to advertise your server on the Master Server.\n");

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0JL@GMPDIPOO@You?5cannot?5register?5on?5the?5Mast@
  0002f	e8 00 00 00 00	 call	 _CONS_Printf
  00034	83 c4 04	 add	 esp, 4

; 979  : 		return;

  00037	eb 18		 jmp	 SHORT $LN3@InternetSe
$LN2@InternetSe:

; 980  : 	}
; 981  : #ifndef NONET
; 982  : 	if (!Playing() && !dedicated)

  00039	e8 00 00 00 00	 call	 _Playing
  0003e	85 c0		 test	 eax, eax
  00040	75 0f		 jne	 SHORT $LN3@InternetSe
  00042	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00049	75 06		 jne	 SHORT $LN3@InternetSe

; 983  : 		M_AlterRoomOptions();

  0004b	e8 00 00 00 00	 call	 _M_AlterRoomOptions
  00050	90		 npad	 1
$LN3@InternetSe:

; 984  : #endif
; 985  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_InternetServer_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _Command_Listserv_f
_TEXT	SEGMENT
_Command_Listserv_f PROC				; COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 602  : 	if (con_state == MSCS_WAITING)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _con_state, 1
  00010	75 0f		 jne	 SHORT $LN2@Command_Li

; 603  : 	{
; 604  : 		CONS_Printf("Not yet registered to the master server.\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PANENJBJ@Not?5yet?5registered?5to?5the?5maste@
  00017	e8 00 00 00 00	 call	 _CONS_Printf
  0001c	83 c4 04	 add	 esp, 4

; 605  : 		return;

  0001f	eb 52		 jmp	 SHORT $LN1@Command_Li
$LN2@Command_Li:

; 606  : 	}
; 607  : 
; 608  : 	CONS_Printf("Retrieving server list...\n");

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NOHIMKIJ@Retrieving?5server?5list?4?4?4?6@
  00026	e8 00 00 00 00	 call	 _CONS_Printf
  0002b	83 c4 04	 add	 esp, 4

; 609  : 
; 610  : 	if (MS_Connect(GetMasterServerIP(), GetMasterServerPort(), 0))

  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 _GetMasterServerPort
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _GetMasterServerIP
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _MS_Connect
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	85 c0		 test	 eax, eax
  00046	74 0f		 je	 SHORT $LN3@Command_Li

; 611  : 	{
; 612  : 		CONS_Printf("cannot connect to the master server\n");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
  0004d	e8 00 00 00 00	 call	 _CONS_Printf
  00052	83 c4 04	 add	 esp, 4

; 613  : 		return;

  00055	eb 1c		 jmp	 SHORT $LN1@Command_Li
$LN3@Command_Li:

; 614  : 	}
; 615  : 
; 616  : 	if (GetServersList())

  00057	e8 00 00 00 00	 call	 _GetServersList
  0005c	85 c0		 test	 eax, eax
  0005e	74 0d		 je	 SHORT $LN4@Command_Li

; 617  : 		CONS_Printf("cannot get server list\n");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FBMAGFAO@cannot?5get?5server?5list?6@
  00065	e8 00 00 00 00	 call	 _CONS_Printf
  0006a	83 c4 04	 add	 esp, 4
$LN4@Command_Li:

; 618  : 
; 619  : 	CloseConnection();

  0006d	e8 00 00 00 00	 call	 _CloseConnection
  00072	90		 npad	 1
$LN1@Command_Li:

; 620  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_Command_Listserv_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _inet_aton
_TEXT	SEGMENT
tv70 = -72						; size = 4
tv65 = -68						; size = 4
_hostname$ = 8						; size = 4
_addr$ = 12						; size = 4
_inet_aton PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 194  : 	return (addr->s_addr = inet_addr(hostname)) != htonl(INADDR_NONE);

  00009	8b 45 08	 mov	 eax, DWORD PTR _hostname$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _inet_addr@4
  00012	89 45 bc	 mov	 DWORD PTR tv65[ebp], eax
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _addr$[ebp]
  00018	8b 55 bc	 mov	 edx, DWORD PTR tv65[ebp]
  0001b	89 11		 mov	 DWORD PTR [ecx], edx
  0001d	6a ff		 push	 -1
  0001f	e8 00 00 00 00	 call	 _htonl@4
  00024	39 45 bc	 cmp	 DWORD PTR tv65[ebp], eax
  00027	74 09		 je	 SHORT $LN3@inet_aton
  00029	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00030	eb 07		 jmp	 SHORT $LN4@inet_aton
$LN3@inet_aton:
  00032	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@inet_aton:
  00039	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 195  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_inet_aton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _AddMServCommands
_TEXT	SEGMENT
_AddMServCommands PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 252  : 	CV_RegisterVar(&cv_internetserver);

  00009	68 00 00 00 00	 push	 OFFSET _cv_internetserver
  0000e	e8 00 00 00 00	 call	 _CV_RegisterVar
  00013	83 c4 04	 add	 esp, 4

; 253  : 	CV_RegisterVar(&cv_masterserver);

  00016	68 00 00 00 00	 push	 OFFSET _cv_masterserver
  0001b	e8 00 00 00 00	 call	 _CV_RegisterVar
  00020	83 c4 04	 add	 esp, 4

; 254  : 	CV_RegisterVar(&cv_servername);

  00023	68 00 00 00 00	 push	 OFFSET _cv_servername
  00028	e8 00 00 00 00	 call	 _CV_RegisterVar
  0002d	83 c4 04	 add	 esp, 4

; 255  : 	COM_AddCommand("listserv", Command_Listserv_f);

  00030	68 00 00 00 00	 push	 OFFSET _Command_Listserv_f
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_08LNKMFIHA@listserv@
  0003a	e8 00 00 00 00	 call	 _COM_AddCommand
  0003f	83 c4 08	 add	 esp, 8

; 256  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_AddMServCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _GetMODVersion
_TEXT	SEGMENT
_GetMODVersion PROC					; COMDAT

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 568  : 	static msg_t msg;
; 569  : 
; 570  : 
; 571  : 	// we must be connected to the master server before writing to it
; 572  : 	if (MS_Connect(GetMasterServerIP(), GetMasterServerPort(), 0))

  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _GetMasterServerPort
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _GetMasterServerIP
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _MS_Connect
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	85 c0		 test	 eax, eax
  00021	74 22		 je	 SHORT $LN2@GetMODVers

; 573  : 	{
; 574  : 		CONS_Printf("cannot connect to the master server\n");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
  00028	e8 00 00 00 00	 call	 _CONS_Printf
  0002d	83 c4 04	 add	 esp, 4

; 575  : 		M_StartMessage("There was a problem connecting to\nthe Master Server", NULL, MM_NOTHING);

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PILCGDBG@There?5was?5a?5problem?5connecting?5@
  00039	e8 00 00 00 00	 call	 _M_StartMessage
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 576  : 		return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 7e		 jmp	 SHORT $LN5@GetMODVers
$LN2@GetMODVers:

; 577  : 	}
; 578  : 
; 579  : 	msg.type = GET_VERSION_MSG;

  00045	c7 05 04 00 00
	00 d5 00 00 00	 mov	 DWORD PTR ?msg@?1??GetMODVersion@@9@9+4, 213 ; 000000d5H

; 580  : 	msg.length = sizeof MODVERSION;

  0004f	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?msg@?1??GetMODVersion@@9@9+12, 4

; 581  : 	msg.room = MODID; // Might as well use it for something.

  00059	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?msg@?1??GetMODVersion@@9@9+8, 1

; 582  : 	sprintf(msg.buffer,"%d",MODVERSION);

  00063	68 cf 00 00 00	 push	 207			; 000000cfH
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0006d	68 10 00 00 00	 push	 OFFSET ?msg@?1??GetMODVersion@@9@9+16
  00072	e8 00 00 00 00	 call	 _sprintf
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 583  : 	if (MS_Write(&msg) < 0)

  0007a	68 00 00 00 00	 push	 OFFSET ?msg@?1??GetMODVersion@@9@9
  0007f	e8 00 00 00 00	 call	 _MS_Write
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	7d 04		 jge	 SHORT $LN3@GetMODVers

; 584  : 		return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 34		 jmp	 SHORT $LN5@GetMODVers
$LN3@GetMODVers:

; 585  : 
; 586  : 	MS_Read(&msg);

  0008f	68 00 00 00 00	 push	 OFFSET ?msg@?1??GetMODVersion@@9@9
  00094	e8 00 00 00 00	 call	 _MS_Read
  00099	83 c4 04	 add	 esp, 4

; 587  : 	CloseConnection();

  0009c	e8 00 00 00 00	 call	 _CloseConnection
  000a1	90		 npad	 1

; 588  : 
; 589  : 	if(strcmp(msg.buffer,"NULL") != 0)

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL@
  000a7	68 10 00 00 00	 push	 OFFSET ?msg@?1??GetMODVersion@@9@9+16
  000ac	e8 00 00 00 00	 call	 _strcmp
  000b1	83 c4 08	 add	 esp, 8
  000b4	85 c0		 test	 eax, eax
  000b6	74 09		 je	 SHORT $LN4@GetMODVers

; 590  : 	{
; 591  : 		return msg.buffer;

  000b8	b8 10 00 00 00	 mov	 eax, OFFSET ?msg@?1??GetMODVersion@@9@9+16
  000bd	eb 04		 jmp	 SHORT $LN5@GetMODVers

; 592  : 	}

  000bf	eb 02		 jmp	 SHORT $LN5@GetMODVers
$LN4@GetMODVers:

; 593  : 	else
; 594  : 		return NULL;

  000c1	33 c0		 xor	 eax, eax
$LN5@GetMODVers:

; 595  : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
_GetMODVersion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _GetRoomsList
_TEXT	SEGMENT
_banmsg$1 = -2048					; size = 1000
_i$ = -1048						; size = 4
_msg$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_hosting$ = 8						; size = 4
_GetRoomsList PROC					; COMDAT

; 500  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 09 00
	00		 sub	 esp, 2368		; 00000940H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 501  : 	static msg_ban_t banned_info[1];
; 502  : 	msg_t msg;
; 503  : 	INT32 i;
; 504  : 
; 505  : 	// we must be connected to the master server before writing to it
; 506  : 	if (MS_Connect(GetMasterServerIP(), GetMasterServerPort(), 0))

  00016	6a 00		 push	 0
  00018	e8 00 00 00 00	 call	 _GetMasterServerPort
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _GetMasterServerIP
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _MS_Connect
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	85 c0		 test	 eax, eax
  0002e	74 26		 je	 SHORT $LN5@GetRoomsLi

; 507  : 	{
; 508  : 		CONS_Printf("cannot connect to the master server\n");

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
  00035	e8 00 00 00 00	 call	 _CONS_Printf
  0003a	83 c4 04	 add	 esp, 4

; 509  : 		M_StartMessage("There was a problem connecting to\nthe Master Server", NULL, MM_NOTHING);

  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PILCGDBG@There?5was?5a?5problem?5connecting?5@
  00046	e8 00 00 00 00	 call	 _M_StartMessage
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 510  : 		return -1;

  0004e	83 c8 ff	 or	 eax, -1
  00051	e9 cc 02 00 00	 jmp	 $LN14@GetRoomsLi
$LN5@GetRoomsLi:

; 511  : 	}
; 512  : 
; 513  : 	if (hosting)

  00056	83 7d 08 00	 cmp	 DWORD PTR _hosting$[ebp], 0
  0005a	74 0c		 je	 SHORT $LN6@GetRoomsLi

; 514  : 		msg.type = GET_ROOMS_HOST_MSG;

  0005c	c7 85 f0 fb ff
	ff d4 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 212 ; 000000d4H
  00066	eb 0a		 jmp	 SHORT $LN7@GetRoomsLi
$LN6@GetRoomsLi:

; 515  : 	else
; 516  : 		msg.type = GET_ROOMS_MSG;

  00068	c7 85 f0 fb ff
	ff d2 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 210 ; 000000d2H
$LN7@GetRoomsLi:

; 517  : 	msg.length = 0;

  00072	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+12], 0

; 518  : 	msg.room = 0;

  0007c	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+8], 0

; 519  : 	if (MS_Write(&msg) < 0)

  00086	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _MS_Write
  00092	83 c4 04	 add	 esp, 4
  00095	85 c0		 test	 eax, eax
  00097	7d 52		 jge	 SHORT $LN8@GetRoomsLi

; 520  : 	{
; 521  : 		room_list[0].id = 1;

  00099	b8 33 01 00 00	 mov	 eax, 307		; 00000133H
  0009e	6b c8 00	 imul	 ecx, eax, 0
  000a1	c7 81 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _room_list[ecx+16], 1

; 522  : 		strcpy(room_list[0].motd,"Master Server Offline.");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HBPKGLJE@Master?5Server?5Offline?4@
  000b0	b8 33 01 00 00	 mov	 eax, 307		; 00000133H
  000b5	6b c8 00	 imul	 ecx, eax, 0
  000b8	81 c1 34 00 00
	00		 add	 ecx, OFFSET _room_list+52
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 _strcpy
  000c4	83 c4 08	 add	 esp, 8

; 523  : 		strcpy(room_list[0].name,"Offline");

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_07BMIEDOEC@Offline@
  000cc	b8 33 01 00 00	 mov	 eax, 307		; 00000133H
  000d1	6b c8 00	 imul	 ecx, eax, 0
  000d4	81 c1 14 00 00
	00		 add	 ecx, OFFSET _room_list+20
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _strcpy
  000e0	83 c4 08	 add	 esp, 8

; 524  : 		return -1;

  000e3	83 c8 ff	 or	 eax, -1
  000e6	e9 37 02 00 00	 jmp	 $LN14@GetRoomsLi
$LN8@GetRoomsLi:

; 525  : 	}
; 526  : 
; 527  : 	for (i = 0; i < NUM_LIST_ROOMS && MS_Read(&msg) >= 0; i++)

  000eb	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000f5	eb 0f		 jmp	 SHORT $LN4@GetRoomsLi
$LN2@GetRoomsLi:
  000f7	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000fd	83 c0 01	 add	 eax, 1
  00100	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetRoomsLi:
  00106	83 bd e8 fb ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0010d	0f 8d 90 01 00
	00		 jge	 $LN3@GetRoomsLi
  00113	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _MS_Read
  0011f	83 c4 04	 add	 esp, 4
  00122	85 c0		 test	 eax, eax
  00124	0f 8c 79 01 00
	00		 jl	 $LN3@GetRoomsLi

; 528  : 	{
; 529  : 		if(msg.type == GET_BANNED_MSG)

  0012a	81 bd f0 fb ff
	ff d7 00 00 00	 cmp	 DWORD PTR _msg$[ebp+4], 215 ; 000000d7H
  00134	0f 85 f1 00 00
	00		 jne	 $LN9@GetRoomsLi

; 530  : 		{
; 531  : 			char banmsg[1000];
; 532  : 			M_Memcpy(&banned_info[0], msg.buffer, sizeof (msg_ban_t));

  0013a	68 53 01 00 00	 push	 339			; 00000153H
  0013f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp+16]
  00145	50		 push	 eax
  00146	b9 53 01 00 00	 mov	 ecx, 339		; 00000153H
  0014b	6b d1 00	 imul	 edx, ecx, 0
  0014e	81 c2 00 00 00
	00		 add	 edx, OFFSET ?banned_info@?1??GetRoomsList@@9@9
  00154	52		 push	 edx
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 533  : 			if (hosting)

  0015e	83 7d 08 00	 cmp	 DWORD PTR _hosting$[ebp], 0
  00162	74 51		 je	 SHORT $LN10@GetRoomsLi

; 534  : 				sprintf(banmsg, "You have been banned from\nhosting netgames.\n\nUnder the following IP Range:\n%s - %s\n\nFor the following reason:\n%s\n\nYour ban will expire on:\n%s",banned_info[0].ipstart,banned_info[0].ipend,banned_info[0].reason,banned_info[0].endstamp);

  00164	b8 53 01 00 00	 mov	 eax, 339		; 00000153H
  00169	6b c8 00	 imul	 ecx, eax, 0
  0016c	81 c1 30 00 00
	00		 add	 ecx, OFFSET ?banned_info@?1??GetRoomsList@@9@9+48
  00172	51		 push	 ecx
  00173	ba 53 01 00 00	 mov	 edx, 339		; 00000153H
  00178	6b c2 00	 imul	 eax, edx, 0
  0017b	05 50 00 00 00	 add	 eax, OFFSET ?banned_info@?1??GetRoomsList@@9@9+80
  00180	50		 push	 eax
  00181	b9 53 01 00 00	 mov	 ecx, 339		; 00000153H
  00186	6b d1 00	 imul	 edx, ecx, 0
  00189	81 c2 20 00 00
	00		 add	 edx, OFFSET ?banned_info@?1??GetRoomsList@@9@9+32
  0018f	52		 push	 edx
  00190	b8 53 01 00 00	 mov	 eax, 339		; 00000153H
  00195	6b c8 00	 imul	 ecx, eax, 0
  00198	81 c1 10 00 00
	00		 add	 ecx, OFFSET ?banned_info@?1??GetRoomsList@@9@9+16
  0019e	51		 push	 ecx
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0IO@HKEKLKBF@You?5have?5been?5banned?5from?6hosti@
  001a4	8d 95 00 f8 ff
	ff		 lea	 edx, DWORD PTR _banmsg$1[ebp]
  001aa	52		 push	 edx
  001ab	e8 00 00 00 00	 call	 _sprintf
  001b0	83 c4 18	 add	 esp, 24			; 00000018H
  001b3	eb 4f		 jmp	 SHORT $LN11@GetRoomsLi
$LN10@GetRoomsLi:

; 535  : 			else
; 536  : 				sprintf(banmsg, "You have been banned from\njoining netgames.\n\nUnder the following IP Range:\n%s - %s\n\nFor the following reason:\n%s\n\nYour ban will expire on:\n%s",banned_info[0].ipstart,banned_info[0].ipend,banned_info[0].reason,banned_info[0].endstamp);

  001b5	b8 53 01 00 00	 mov	 eax, 339		; 00000153H
  001ba	6b c8 00	 imul	 ecx, eax, 0
  001bd	81 c1 30 00 00
	00		 add	 ecx, OFFSET ?banned_info@?1??GetRoomsList@@9@9+48
  001c3	51		 push	 ecx
  001c4	ba 53 01 00 00	 mov	 edx, 339		; 00000153H
  001c9	6b c2 00	 imul	 eax, edx, 0
  001cc	05 50 00 00 00	 add	 eax, OFFSET ?banned_info@?1??GetRoomsList@@9@9+80
  001d1	50		 push	 eax
  001d2	b9 53 01 00 00	 mov	 ecx, 339		; 00000153H
  001d7	6b d1 00	 imul	 edx, ecx, 0
  001da	81 c2 20 00 00
	00		 add	 edx, OFFSET ?banned_info@?1??GetRoomsList@@9@9+32
  001e0	52		 push	 edx
  001e1	b8 53 01 00 00	 mov	 eax, 339		; 00000153H
  001e6	6b c8 00	 imul	 ecx, eax, 0
  001e9	81 c1 10 00 00
	00		 add	 ecx, OFFSET ?banned_info@?1??GetRoomsList@@9@9+16
  001ef	51		 push	 ecx
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0IO@PFIMLPLI@You?5have?5been?5banned?5from?6joini@
  001f5	8d 95 00 f8 ff
	ff		 lea	 edx, DWORD PTR _banmsg$1[ebp]
  001fb	52		 push	 edx
  001fc	e8 00 00 00 00	 call	 _sprintf
  00201	83 c4 18	 add	 esp, 24			; 00000018H
$LN11@GetRoomsLi:

; 537  : 			M_StartMessage(banmsg, NULL, MM_NOTHING);

  00204	6a 00		 push	 0
  00206	6a 00		 push	 0
  00208	8d 85 00 f8 ff
	ff		 lea	 eax, DWORD PTR _banmsg$1[ebp]
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 _M_StartMessage
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH

; 538  : 			cv_internetserver.value = false;

  00217	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_internetserver+20, 0

; 539  : 			return -2;

  00221	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00226	e9 f7 00 00 00	 jmp	 $LN14@GetRoomsLi
$LN9@GetRoomsLi:

; 540  : 		}
; 541  : 		if (!msg.length)

  0022b	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _msg$[ebp+12], 0
  00232	75 2a		 jne	 SHORT $LN12@GetRoomsLi

; 542  : 		{
; 543  : 			room_list[i].header.buffer[0] = 0;

  00234	69 85 e8 fb ff
	ff 33 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 307
  0023e	b9 01 00 00 00	 mov	 ecx, 1
  00243	6b d1 00	 imul	 edx, ecx, 0
  00246	c6 84 10 00 00
	00 00 00	 mov	 BYTE PTR _room_list[eax+edx], 0

; 544  : 			CloseConnection();

  0024e	e8 00 00 00 00	 call	 _CloseConnection
  00253	90		 npad	 1

; 545  : 			return 1;

  00254	b8 01 00 00 00	 mov	 eax, 1
  00259	e9 c4 00 00 00	 jmp	 $LN14@GetRoomsLi
$LN12@GetRoomsLi:

; 546  : 		}
; 547  : 		M_Memcpy(&room_list[i], msg.buffer, sizeof (msg_rooms_t));

  0025e	68 33 01 00 00	 push	 307			; 00000133H
  00263	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp+16]
  00269	50		 push	 eax
  0026a	69 8d e8 fb ff
	ff 33 01 00 00	 imul	 ecx, DWORD PTR _i$[ebp], 307
  00274	81 c1 00 00 00
	00		 add	 ecx, OFFSET _room_list
  0027a	51		 push	 ecx
  0027b	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00281	83 c4 0c	 add	 esp, 12			; 0000000cH

; 548  : 		room_list[i].header.buffer[0] = 1;

  00284	69 85 e8 fb ff
	ff 33 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 307
  0028e	b9 01 00 00 00	 mov	 ecx, 1
  00293	6b d1 00	 imul	 edx, ecx, 0
  00296	c6 84 10 00 00
	00 00 01	 mov	 BYTE PTR _room_list[eax+edx], 1

; 549  : 	}

  0029e	e9 54 fe ff ff	 jmp	 $LN2@GetRoomsLi
$LN3@GetRoomsLi:

; 550  : 	CloseConnection();

  002a3	e8 00 00 00 00	 call	 _CloseConnection
  002a8	90		 npad	 1

; 551  : 	if (i == NUM_LIST_ROOMS)

  002a9	83 bd e8 fb ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  002b0	75 23		 jne	 SHORT $LN13@GetRoomsLi

; 552  : 	{
; 553  : 		room_list[i].header.buffer[0] = 0;

  002b2	69 85 e8 fb ff
	ff 33 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 307
  002bc	b9 01 00 00 00	 mov	 ecx, 1
  002c1	6b d1 00	 imul	 edx, ecx, 0
  002c4	c6 84 10 00 00
	00 00 00	 mov	 BYTE PTR _room_list[eax+edx], 0

; 554  : 		return 1;

  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	eb 4f		 jmp	 SHORT $LN14@GetRoomsLi

; 555  : 	}

  002d3	eb 4d		 jmp	 SHORT $LN14@GetRoomsLi
$LN13@GetRoomsLi:

; 556  : 	else
; 557  : 	{
; 558  : 		room_list[0].id = 1;

  002d5	b8 33 01 00 00	 mov	 eax, 307		; 00000133H
  002da	6b c8 00	 imul	 ecx, eax, 0
  002dd	c7 81 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR _room_list[ecx+16], 1

; 559  : 		strcpy(room_list[0].motd,"Master Server Offline.");

  002e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HBPKGLJE@Master?5Server?5Offline?4@
  002ec	b8 33 01 00 00	 mov	 eax, 307		; 00000133H
  002f1	6b c8 00	 imul	 ecx, eax, 0
  002f4	81 c1 34 00 00
	00		 add	 ecx, OFFSET _room_list+52
  002fa	51		 push	 ecx
  002fb	e8 00 00 00 00	 call	 _strcpy
  00300	83 c4 08	 add	 esp, 8

; 560  : 		strcpy(room_list[0].name,"Offline");

  00303	68 00 00 00 00	 push	 OFFSET ??_C@_07BMIEDOEC@Offline@
  00308	b8 33 01 00 00	 mov	 eax, 307		; 00000133H
  0030d	6b c8 00	 imul	 ecx, eax, 0
  00310	81 c1 14 00 00
	00		 add	 ecx, OFFSET _room_list+20
  00316	51		 push	 ecx
  00317	e8 00 00 00 00	 call	 _strcpy
  0031c	83 c4 08	 add	 esp, 8

; 561  : 		return -1;

  0031f	83 c8 ff	 or	 eax, -1
$LN14@GetRoomsLi:

; 562  : 	}
; 563  : }

  00322	5f		 pop	 edi
  00323	5e		 pop	 esi
  00324	5b		 pop	 ebx
  00325	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00328	33 cd		 xor	 ecx, ebp
  0032a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c3		 ret	 0
_GetRoomsList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _GetShortServersList
_TEXT	SEGMENT
_i$ = -1048						; size = 4
_msg$ = -1044						; size = 1040
__$ArrayPad$ = -4					; size = 4
_room$ = 8						; size = 4
_GetShortServersList PROC				; COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 04 00
	00		 sub	 esp, 1240		; 000004d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 457  : 	static msg_server_t server_list[NUM_LIST_SERVER+1]; // +1 for easy test
; 458  : 	msg_t msg;
; 459  : 	INT32 i;
; 460  : 
; 461  : 	// updated now
; 462  : 	oldroomnum = room;

  00016	8b 45 08	 mov	 eax, DWORD PTR _room$[ebp]
  00019	a3 00 00 00 00	 mov	 DWORD PTR _oldroomnum, eax

; 463  : 
; 464  : 	// we must be connected to the master server before writing to it
; 465  : 	if (MS_Connect(GetMasterServerIP(), GetMasterServerPort(), 0))

  0001e	6a 00		 push	 0
  00020	e8 00 00 00 00	 call	 _GetMasterServerPort
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _GetMasterServerIP
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _MS_Connect
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	85 c0		 test	 eax, eax
  00036	74 25		 je	 SHORT $LN5@GetShortSe

; 466  : 	{
; 467  : 		CONS_Printf("cannot connect to the master server\n");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
  0003d	e8 00 00 00 00	 call	 _CONS_Printf
  00042	83 c4 04	 add	 esp, 4

; 468  : 		M_StartMessage("There was a problem connecting to\nthe Master Server", NULL, MM_NOTHING);

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PILCGDBG@There?5was?5a?5problem?5connecting?5@
  0004e	e8 00 00 00 00	 call	 _M_StartMessage
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 469  : 		return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 08 01 00 00	 jmp	 $LN9@GetShortSe
$LN5@GetShortSe:

; 470  : 	}
; 471  : 
; 472  : 	msg.type = GET_SHORT_SERVER_MSG;

  0005d	c7 85 f0 fb ff
	ff cd 00 00 00	 mov	 DWORD PTR _msg$[ebp+4], 205 ; 000000cdH

; 473  : 	msg.length = 0;

  00067	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _msg$[ebp+12], 0

; 474  : 	msg.room = room;

  00071	8b 45 08	 mov	 eax, DWORD PTR _room$[ebp]
  00074	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _msg$[ebp+8], eax

; 475  : 	if (MS_Write(&msg) < 0)

  0007a	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _MS_Write
  00086	83 c4 04	 add	 esp, 4
  00089	85 c0		 test	 eax, eax
  0008b	7d 07		 jge	 SHORT $LN6@GetShortSe

; 476  : 		return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 d1 00 00 00	 jmp	 $LN9@GetShortSe
$LN6@GetShortSe:

; 477  : 
; 478  : 	for (i = 0; i < NUM_LIST_SERVER && MS_Read(&msg) >= 0; i++)

  00094	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0009e	eb 0f		 jmp	 SHORT $LN4@GetShortSe
$LN2@GetShortSe:
  000a0	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000a6	83 c0 01	 add	 eax, 1
  000a9	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetShortSe:
  000af	83 bd e8 fb ff
	ff 40		 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  000b6	7d 7c		 jge	 SHORT $LN3@GetShortSe
  000b8	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _MS_Read
  000c4	83 c4 04	 add	 esp, 4
  000c7	85 c0		 test	 eax, eax
  000c9	7c 69		 jl	 SHORT $LN3@GetShortSe

; 479  : 	{
; 480  : 		if (!msg.length)

  000cb	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _msg$[ebp+12], 0
  000d2	75 24		 jne	 SHORT $LN7@GetShortSe

; 481  : 		{
; 482  : 			server_list[i].header.buffer[0] = 0;

  000d4	6b 85 e8 fb ff
	ff 54		 imul	 eax, DWORD PTR _i$[ebp], 84
  000db	b9 01 00 00 00	 mov	 ecx, 1
  000e0	6b d1 00	 imul	 edx, ecx, 0
  000e3	c6 84 10 00 00
	00 00 00	 mov	 BYTE PTR ?server_list@?1??GetShortServersList@@9@9[eax+edx], 0

; 483  : 			CloseConnection();

  000eb	e8 00 00 00 00	 call	 _CloseConnection
  000f0	90		 npad	 1

; 484  : 			return server_list;

  000f1	b8 00 00 00 00	 mov	 eax, OFFSET ?server_list@?1??GetShortServersList@@9@9
  000f6	eb 6d		 jmp	 SHORT $LN9@GetShortSe
$LN7@GetShortSe:

; 485  : 		}
; 486  : 		M_Memcpy(&server_list[i], msg.buffer, sizeof (msg_server_t));

  000f8	6a 54		 push	 84			; 00000054H
  000fa	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp+16]
  00100	50		 push	 eax
  00101	6b 8d e8 fb ff
	ff 54		 imul	 ecx, DWORD PTR _i$[ebp], 84
  00108	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?server_list@?1??GetShortServersList@@9@9
  0010e	51		 push	 ecx
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 487  : 		server_list[i].header.buffer[0] = 1;

  00118	6b 85 e8 fb ff
	ff 54		 imul	 eax, DWORD PTR _i$[ebp], 84
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	6b d1 00	 imul	 edx, ecx, 0
  00127	c6 84 10 00 00
	00 00 01	 mov	 BYTE PTR ?server_list@?1??GetShortServersList@@9@9[eax+edx], 1

; 488  : 	}

  0012f	e9 6c ff ff ff	 jmp	 $LN2@GetShortSe
$LN3@GetShortSe:

; 489  : 	CloseConnection();

  00134	e8 00 00 00 00	 call	 _CloseConnection
  00139	90		 npad	 1

; 490  : 	if (i == NUM_LIST_SERVER)

  0013a	83 bd e8 fb ff
	ff 40		 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00141	75 20		 jne	 SHORT $LN8@GetShortSe

; 491  : 	{
; 492  : 		server_list[i].header.buffer[0] = 0;

  00143	6b 85 e8 fb ff
	ff 54		 imul	 eax, DWORD PTR _i$[ebp], 84
  0014a	b9 01 00 00 00	 mov	 ecx, 1
  0014f	6b d1 00	 imul	 edx, ecx, 0
  00152	c6 84 10 00 00
	00 00 00	 mov	 BYTE PTR ?server_list@?1??GetShortServersList@@9@9[eax+edx], 0

; 493  : 		return server_list;

  0015a	b8 00 00 00 00	 mov	 eax, OFFSET ?server_list@?1??GetShortServersList@@9@9
  0015f	eb 04		 jmp	 SHORT $LN9@GetShortSe

; 494  : 	}

  00161	eb 02		 jmp	 SHORT $LN9@GetShortSe
$LN8@GetShortSe:

; 495  : 	else
; 496  : 		return NULL;

  00163	33 c0		 xor	 eax, eax
$LN9@GetShortSe:

; 497  : }

  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
_GetShortServersList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MasterClient_Ticker
_TEXT	SEGMENT
_MasterClient_Ticker PROC				; COMDAT

; 958  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 959  : 	if (server && cv_internetserver.value)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  00010	74 0f		 je	 SHORT $LN2@MasterClie
  00012	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_internetserver+20, 0
  00019	74 06		 je	 SHORT $LN2@MasterClie

; 960  : 		SendPingToMasterServer();

  0001b	e8 00 00 00 00	 call	 _SendPingToMasterServer
  00020	90		 npad	 1
$LN2@MasterClie:

; 961  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_MasterClient_Ticker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _UnregisterServer
_TEXT	SEGMENT
_UnregisterServer PROC					; COMDAT

; 931  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 932  : 	if (con_state != MSCS_REGISTERED)

  00009	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _con_state, 2
  00010	74 12		 je	 SHORT $LN2@Unregister

; 933  : 	{
; 934  : 		con_state = MSCS_NONE;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_state, 0

; 935  : 		CloseConnection();

  0001c	e8 00 00 00 00	 call	 _CloseConnection
  00021	90		 npad	 1

; 936  : 		return;

  00022	eb 6b		 jmp	 SHORT $LN1@Unregister
$LN2@Unregister:

; 937  : 	}
; 938  : 
; 939  : 	con_state = MSCS_NONE;

  00024	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_state, 0

; 940  : 
; 941  : 	CONS_Printf("Unregistering this server to the master server...\n");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KAGGBDFM@Unregistering?5this?5server?5to?5th@
  00033	e8 00 00 00 00	 call	 _CONS_Printf
  00038	83 c4 04	 add	 esp, 4

; 942  : 
; 943  : 	if (MS_Connect(registered_server.ip, registered_server.port, 0))

  0003b	6a 00		 push	 0
  0003d	68 40 00 00 00	 push	 OFFSET _registered_server+64
  00042	68 00 00 00 00	 push	 OFFSET _registered_server
  00047	e8 00 00 00 00	 call	 _MS_Connect
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	85 c0		 test	 eax, eax
  00051	74 0f		 je	 SHORT $LN3@Unregister

; 944  : 	{
; 945  : 		CONS_Printf("cannot connect to the master server\n");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
  00058	e8 00 00 00 00	 call	 _CONS_Printf
  0005d	83 c4 04	 add	 esp, 4

; 946  : 		return;

  00060	eb 2d		 jmp	 SHORT $LN1@Unregister
$LN3@Unregister:

; 947  : 	}
; 948  : 
; 949  : 	if (RemoveFromMasterSever() < 0)

  00062	e8 00 00 00 00	 call	 _RemoveFromMasterSever
  00067	85 c0		 test	 eax, eax
  00069	7d 0d		 jge	 SHORT $LN4@Unregister

; 950  : 		CONS_Printf("cannot remove this server from the master server\n");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@NLJKCLLO@cannot?5remove?5this?5server?5from?5@
  00070	e8 00 00 00 00	 call	 _CONS_Printf
  00075	83 c4 04	 add	 esp, 4
$LN4@Unregister:

; 951  : 
; 952  : 	CloseConnection();

  00078	e8 00 00 00 00	 call	 _CloseConnection
  0007d	90		 npad	 1

; 953  : 	MSCloseUDPSocket();

  0007e	e8 00 00 00 00	 call	 _MSCloseUDPSocket
  00083	90		 npad	 1

; 954  : 	MSLastPing = 0;

  00084	0f 57 c0	 xorps	 xmm0, xmm0
  00087	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _MSLastPing, xmm0
$LN1@Unregister:

; 955  : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_UnregisterServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _RegisterServer
_TEXT	SEGMENT
_RegisterServer PROC					; COMDAT

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 842  : 	if (con_state == MSCS_REGISTERED || con_state == MSCS_WAITING)

  00009	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _con_state, 2
  00010	74 09		 je	 SHORT $LN3@RegisterSe
  00012	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _con_state, 1
  00019	75 02		 jne	 SHORT $LN2@RegisterSe
$LN3@RegisterSe:

; 843  : 			return;

  0001b	eb 60		 jmp	 SHORT $LN1@RegisterSe
$LN2@RegisterSe:

; 844  : 
; 845  : 	CONS_Printf("Registering this server to the master server...\n");

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JGONOAKO@Registering?5this?5server?5to?5the?5@
  00022	e8 00 00 00 00	 call	 _CONS_Printf
  00027	83 c4 04	 add	 esp, 4

; 846  : 
; 847  : 	strcpy(registered_server.ip, GetMasterServerIP());

  0002a	e8 00 00 00 00	 call	 _GetMasterServerIP
  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET _registered_server
  00035	e8 00 00 00 00	 call	 _strcpy
  0003a	83 c4 08	 add	 esp, 8

; 848  : 	strcpy(registered_server.port, GetMasterServerPort());

  0003d	e8 00 00 00 00	 call	 _GetMasterServerPort
  00042	50		 push	 eax
  00043	68 40 00 00 00	 push	 OFFSET _registered_server+64
  00048	e8 00 00 00 00	 call	 _strcpy
  0004d	83 c4 08	 add	 esp, 8

; 849  : 
; 850  : 	if (MS_Connect(registered_server.ip, registered_server.port, 1))

  00050	6a 01		 push	 1
  00052	68 40 00 00 00	 push	 OFFSET _registered_server+64
  00057	68 00 00 00 00	 push	 OFFSET _registered_server
  0005c	e8 00 00 00 00	 call	 _MS_Connect
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	85 c0		 test	 eax, eax
  00066	74 0f		 je	 SHORT $LN4@RegisterSe

; 851  : 	{
; 852  : 		CONS_Printf("cannot connect to the master server\n");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JNIPGPML@cannot?5connect?5to?5the?5master?5se@
  0006d	e8 00 00 00 00	 call	 _CONS_Printf
  00072	83 c4 04	 add	 esp, 4

; 853  : 		return;

  00075	eb 06		 jmp	 SHORT $LN1@RegisterSe
$LN4@RegisterSe:

; 854  : 	}
; 855  : 	MSOpenUDPSocket();

  00077	e8 00 00 00 00	 call	 _MSOpenUDPSocket
  0007c	90		 npad	 1
$LN1@RegisterSe:

; 856  : 
; 857  : 	// keep the TCP connection open until AddToMasterServer() is completed;
; 858  : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_RegisterServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _SendAskInfoViaMS
_TEXT	SEGMENT
tv78 = -112						; size = 4
tv77 = -108						; size = 4
_mshpp$ = -40						; size = 24
_inip$ = -16						; size = 4
_port$ = -12						; size = 2
_address$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_asktime$ = 12						; size = 4
_SendAskInfoViaMS PROC					; COMDAT

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 900  : 	const char *address;
; 901  : 	UINT16 port;
; 902  : 	char *inip;
; 903  : 	ms_holepunch_packet_t mshpp;
; 904  : 
; 905  : 	MSOpenUDPSocket();

  00013	e8 00 00 00 00	 call	 _MSOpenUDPSocket
  00018	90		 npad	 1

; 906  : 
; 907  : 	// This must be called after calling MSOpenUDPSocket, due to the
; 908  : 	// static buffer.
; 909  : 	address = I_GetNodeAddress(node);

  00019	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR _I_GetNodeAddress
  00023	83 c4 04	 add	 esp, 4
  00026	89 45 f8	 mov	 DWORD PTR _address$[ebp], eax

; 910  : 
; 911  : 	// Copy the IP address into the buffer.
; 912  : 	inip = mshpp.ip;

  00029	8d 45 d8	 lea	 eax, DWORD PTR _mshpp$[ebp]
  0002c	89 45 f0	 mov	 DWORD PTR _inip$[ebp], eax
$LN2@SendAskInf:

; 913  : 	while(*address && *address != ':') *inip++ = *address++;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _address$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	85 c9		 test	 ecx, ecx
  00037	74 29		 je	 SHORT $LN3@SendAskInf
  00039	8b 45 f8	 mov	 eax, DWORD PTR _address$[ebp]
  0003c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003f	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00042	74 1e		 je	 SHORT $LN3@SendAskInf
  00044	8b 45 f0	 mov	 eax, DWORD PTR _inip$[ebp]
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _address$[ebp]
  0004a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0004c	88 10		 mov	 BYTE PTR [eax], dl
  0004e	8b 45 f0	 mov	 eax, DWORD PTR _inip$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 f0	 mov	 DWORD PTR _inip$[ebp], eax
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _address$[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	89 4d f8	 mov	 DWORD PTR _address$[ebp], ecx
  00060	eb cd		 jmp	 SHORT $LN2@SendAskInf
$LN3@SendAskInf:

; 914  : 	*inip = '\0';

  00062	8b 45 f0	 mov	 eax, DWORD PTR _inip$[ebp]
  00065	c6 00 00	 mov	 BYTE PTR [eax], 0

; 915  : 
; 916  : 	// Get the port.
; 917  : 	port = (UINT16)(*address++ ? atoi(address) : 0);

  00068	8b 45 f8	 mov	 eax, DWORD PTR _address$[ebp]
  0006b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006e	89 4d 94	 mov	 DWORD PTR tv77[ebp], ecx
  00071	8b 55 f8	 mov	 edx, DWORD PTR _address$[ebp]
  00074	83 c2 01	 add	 edx, 1
  00077	89 55 f8	 mov	 DWORD PTR _address$[ebp], edx
  0007a	83 7d 94 00	 cmp	 DWORD PTR tv77[ebp], 0
  0007e	74 11		 je	 SHORT $LN5@SendAskInf
  00080	8b 45 f8	 mov	 eax, DWORD PTR _address$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _atoi
  00089	83 c4 04	 add	 esp, 4
  0008c	89 45 90	 mov	 DWORD PTR tv78[ebp], eax
  0008f	eb 07		 jmp	 SHORT $LN6@SendAskInf
$LN5@SendAskInf:
  00091	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN6@SendAskInf:
  00098	66 8b 4d 90	 mov	 cx, WORD PTR tv78[ebp]
  0009c	66 89 4d f4	 mov	 WORD PTR _port$[ebp], cx

; 918  : 	mshpp.port = SHORT(port);

  000a0	66 8b 45 f4	 mov	 ax, WORD PTR _port$[ebp]
  000a4	66 89 45 e8	 mov	 WORD PTR _mshpp$[ebp+16], ax

; 919  : 
; 920  : 	// Set the time for ping calculation.
; 921  : 	mshpp.time = LONG(asktime);

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _asktime$[ebp]
  000ab	89 45 ec	 mov	 DWORD PTR _mshpp$[ebp+20], eax

; 922  : 
; 923  : 	// Send to the MS.
; 924  : 	M_Memcpy(netbuffer, &mshpp, sizeof(mshpp));

  000ae	6a 18		 push	 24			; 00000018H
  000b0	8d 45 d8	 lea	 eax, DWORD PTR _mshpp$[ebp]
  000b3	50		 push	 eax
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  000ba	51		 push	 ecx
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 925  : 	doomcom->datalength = sizeof(ms_holepunch_packet_t);

  000c4	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  000cf	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 926  : 	doomcom->remotenode = (INT16)msnode;

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000d8	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _msnode
  000df	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 927  : 	I_NetSend();

  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetSend
  000e9	90		 npad	 1

; 928  : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_SendAskInfoViaMS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MSCloseUDPSocket
_TEXT	SEGMENT
_MSCloseUDPSocket PROC					; COMDAT

; 835  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 836  : 	if (msnode != INT16_MAX) I_NetFreeNodenum(msnode);

  00009	81 3d 00 00 00
	00 ff 7f 00 00	 cmp	 DWORD PTR _msnode, 32767 ; 00007fffH
  00013	74 0f		 je	 SHORT $LN2@MSCloseUDP
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR _msnode
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetFreeNodenum
  00021	83 c4 04	 add	 esp, 4
$LN2@MSCloseUDP:

; 837  : 	msnode = -1;

  00024	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _msnode, -1

; 838  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_MSCloseUDPSocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _MSOpenUDPSocket
_TEXT	SEGMENT
_hostname$1 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_MSOpenUDPSocket PROC					; COMDAT

; 808  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 809  : #ifndef NONET
; 810  : 	if (I_NetMakeNode)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _I_NetMakeNode, 0
  0001a	74 5e		 je	 SHORT $LN2@MSOpenUDPS

; 811  : 	{
; 812  : 		// If it's already open, there's nothing to do.
; 813  : 		if (msnode < 0)

  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _msnode, 0
  00023	7d 53		 jge	 SHORT $LN4@MSOpenUDPS

; 814  : 		{
; 815  : 			char hostname[24];
; 816  : 
; 817  : 			MS_GetIP(GetMasterServerIP());

  00025	e8 00 00 00 00	 call	 _GetMasterServerIP
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _MS_GetIP
  00030	83 c4 04	 add	 esp, 4

; 818  : 
; 819  : 			sprintf(hostname, "%s:%d",

  00033	e8 00 00 00 00	 call	 _GetMasterServerPort
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _atoi
  0003e	83 c4 04	 add	 esp, 4
  00041	83 c0 01	 add	 eax, 1
  00044	50		 push	 eax
  00045	a1 04 00 00 00	 mov	 eax, DWORD PTR _addr+4
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _inet_ntoa@4
  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_05HKPGCKL@?$CFs?3?$CFd@
  00056	8d 4d e4	 lea	 ecx, DWORD PTR _hostname$1[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _sprintf
  0005f	83 c4 10	 add	 esp, 16			; 00000010H

; 820  : #ifdef _arch_dreamcast
; 821  : 				inet_ntoa(*(UINT32 *)&addr.sin_addr),
; 822  : #else
; 823  : 				inet_ntoa(addr.sin_addr),
; 824  : #endif
; 825  : 				atoi(GetMasterServerPort())+1);
; 826  : 			msnode = I_NetMakeNode(hostname);

  00062	8d 45 e4	 lea	 eax, DWORD PTR _hostname$1[ebp]
  00065	50		 push	 eax
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetMakeNode
  0006c	83 c4 04	 add	 esp, 4
  0006f	0f be c8	 movsx	 ecx, al
  00072	89 0d 00 00 00
	00		 mov	 DWORD PTR _msnode, ecx
$LN4@MSOpenUDPS:

; 827  : 		}
; 828  : 	}

  00078	eb 0a		 jmp	 SHORT $LN3@MSOpenUDPS
$LN2@MSOpenUDPS:

; 829  : 	else
; 830  : #endif
; 831  : 		msnode = -1;

  0007a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _msnode, -1
$LN3@MSOpenUDPS:

; 832  : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_MSOpenUDPSocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _GetMasterServerIP
_TEXT	SEGMENT
_t$ = -4						; size = 4
_GetMasterServerIP PROC					; COMDAT

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 786  : 	static char str_ip[64];
; 787  : 	char *t = str_ip;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _t$[ebp], OFFSET ?str_ip@?1??GetMasterServerIP@@9@9

; 788  : 
; 789  : 	if (strstr(cv_masterserver.string, "srb2.ssntails.org:28910")
; 790  : 	 || strstr(cv_masterserver.string, "srb2.servegame.org:28910")
; 791  : 	 || strstr(cv_masterserver.string, "srb2.servegame.org:28900")

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JDJFAKIG@srb2?4ssntails?4org?328910@
  00015	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_masterserver+24
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _strstr
  00020	83 c4 08	 add	 esp, 8
  00023	85 c0		 test	 eax, eax
  00025	75 2e		 jne	 SHORT $LN5@GetMasterS
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LENOLGCK@srb2?4servegame?4org?328910@
  0002c	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_masterserver+24
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _strstr
  00037	83 c4 08	 add	 esp, 8
  0003a	85 c0		 test	 eax, eax
  0003c	75 17		 jne	 SHORT $LN5@GetMasterS
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LFBMNMBN@srb2?4servegame?4org?328900@
  00043	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_masterserver+24
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _strstr
  0004e	83 c4 08	 add	 esp, 8
  00051	85 c0		 test	 eax, eax
  00053	74 13		 je	 SHORT $LN4@GetMasterS
$LN5@GetMasterS:

; 792  : 	   )
; 793  : 	{
; 794  : 		// replace it with the current default one
; 795  : 		CV_Set(&cv_masterserver, cv_masterserver.defaultvalue);

  00055	a1 04 00 00 00	 mov	 eax, DWORD PTR _cv_masterserver+4
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET _cv_masterserver
  00060	e8 00 00 00 00	 call	 _CV_Set
  00065	83 c4 08	 add	 esp, 8
$LN4@GetMasterS:

; 796  : 	}
; 797  : 
; 798  : 	strcpy(t, cv_masterserver.string);

  00068	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_masterserver+24
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _strcpy
  00077	83 c4 08	 add	 esp, 8
$LN2@GetMasterS:

; 799  : 
; 800  : 	while ((*t != ':') && (*t != '\0'))

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  0007d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00080	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00083	74 15		 je	 SHORT $LN3@GetMasterS
  00085	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00088	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 0b		 je	 SHORT $LN3@GetMasterS

; 801  : 		t++;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00092	83 c0 01	 add	 eax, 1
  00095	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax
  00098	eb e0		 jmp	 SHORT $LN2@GetMasterS
$LN3@GetMasterS:

; 802  : 	*t = '\0';

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  0009d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 803  : 
; 804  : 	return str_ip;

  000a0	b8 00 00 00 00	 mov	 eax, OFFSET ?str_ip@?1??GetMasterServerIP@@9@9

; 805  : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_GetMasterServerIP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\mserv.c
;	COMDAT _GetMasterServerPort
_TEXT	SEGMENT
_t$ = -4						; size = 4
_GetMasterServerPort PROC				; COMDAT

; 766  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 767  : 	const char *t = cv_masterserver.string;

  00009	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_masterserver+24
  0000e	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax
$LN2@GetMasterS:

; 768  : 
; 769  : 	while ((*t != ':') && (*t != '\0'))

  00011	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00014	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00017	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0001a	74 15		 je	 SHORT $LN3@GetMasterS
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  0001f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00022	85 c9		 test	 ecx, ecx
  00024	74 0b		 je	 SHORT $LN3@GetMasterS

; 770  : 		t++;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax
  0002f	eb e0		 jmp	 SHORT $LN2@GetMasterS
$LN3@GetMasterS:

; 771  : 
; 772  : 	if (*t)

  00031	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00037	85 c9		 test	 ecx, ecx
  00039	74 10		 je	 SHORT $LN4@GetMasterS

; 773  : 		return ++t;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax
  00044	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00047	eb 07		 jmp	 SHORT $LN5@GetMasterS
  00049	eb 05		 jmp	 SHORT $LN5@GetMasterS
$LN4@GetMasterS:

; 774  : 	else
; 775  : 		return DEF_PORT;

  0004b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05OANAGPPF@28900@
$LN5@GetMasterS:

; 776  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_GetMasterServerPort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 551  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 552  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 553  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
END
