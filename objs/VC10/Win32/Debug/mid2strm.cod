; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\mid2strm.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_ifs:BYTE:01dcH
COMM	_dwProgressBytes:DWORD
_DATA	ENDS
PUBLIC	_Mid2StreamConverterCleanup
PUBLIC	_Mid2StreamConverterInit
PUBLIC	_Mid2StreamConvertToBuffer
PUBLIC	??_C@_0BM@IOCKPAHO@Read?5error?5on?5MIDI?5header?4?6@ ; `string'
PUBLIC	??_C@_0BN@LHIKEFDN@Read?5error?5on?5track?5header?4?6@ ; `string'
PUBLIC	??_C@_0CG@ILPAJGKE@Read?5error?5while?5reading?5track?5@ ; `string'
PUBLIC	??_C@_0DF@BLKEMBAP@Read?5error?5while?5reading?5first?5@ ; `string'
PUBLIC	??_C@_0BP@OLAIGNOM@NOTE?3?5Ignoring?5SysEx?5for?5now?4?6@ ; `string'
PUBLIC	??_C@_0CK@EANDOAKM@AddEventToStreamBuffer?3?5not?5a?5M@ ; `string'
PUBLIC	??_C@_0CM@INAJHHHP@AddEventToStreamBuffer?3?5dwEvent@ ; `string'
PUBLIC	??_C@_0CG@DNJCGPOJ@Unable?5to?5add?5event?5to?5stream?5b@ ; `string'
EXTRN	_memset:PROC
EXTRN	_I_Error:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_devparm:DWORD
EXTRN	_bMidiLooped:DWORD
_BSS	SEGMENT
_tkCurrentTime DD 01H DUP (?)
_dwBufferTickLength DD 01H DUP (?)
?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9 DD 01H DUP (?) ; `Mid2StreamConvertToBuffer'::`2'::pInTrack
?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9 DD 01H DUP (?) ; `Mid2StreamConvertToBuffer'::`2'::pInTrackFound
?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9 DD 01H DUP (?) ; `Mid2StreamConvertToBuffer'::`2'::dwStatus
?tkNext@?1??Mid2StreamConvertToBuffer@@9@9 DD 01H DUP (?) ; `Mid2StreamConvertToBuffer'::`2'::tkNext
?teTemp@?1??Mid2StreamConvertToBuffer@@9@9 DB 010H DUP (?) ; `Mid2StreamConvertToBuffer'::`2'::teTemp
_BSS	ENDS
;	COMDAT ??_C@_0CG@DNJCGPOJ@Unable?5to?5add?5event?5to?5stream?5b@
CONST	SEGMENT
??_C@_0CG@DNJCGPOJ@Unable?5to?5add?5event?5to?5stream?5b@ DB 'Unable to a'
	DB	'dd event to stream buffer.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@INAJHHHP@AddEventToStreamBuffer?3?5dwEvent@
CONST	SEGMENT
??_C@_0CM@INAJHHHP@AddEventToStreamBuffer?3?5dwEvent@ DB 'AddEventToStrea'
	DB	'mBuffer: dwEventLength <> 3', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EANDOAKM@AddEventToStreamBuffer?3?5not?5a?5M@
CONST	SEGMENT
??_C@_0CK@EANDOAKM@AddEventToStreamBuffer?3?5not?5a?5M@ DB 'AddEventToStr'
	DB	'eamBuffer: not a META event', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLAIGNOM@NOTE?3?5Ignoring?5SysEx?5for?5now?4?6@
CONST	SEGMENT
??_C@_0BP@OLAIGNOM@NOTE?3?5Ignoring?5SysEx?5for?5now?4?6@ DB 'NOTE: Ignor'
	DB	'ing SysEx for now.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BLKEMBAP@Read?5error?5while?5reading?5first?5@
CONST	SEGMENT
??_C@_0DF@BLKEMBAP@Read?5error?5while?5reading?5first?5@ DB 'Read error w'
	DB	'hile reading first delta time of track.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ILPAJGKE@Read?5error?5while?5reading?5track?5@
CONST	SEGMENT
??_C@_0CG@ILPAJGKE@Read?5error?5while?5reading?5track?5@ DB 'Read error w'
	DB	'hile reading track data.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHIKEFDN@Read?5error?5on?5track?5header?4?6@
CONST	SEGMENT
??_C@_0BN@LHIKEFDN@Read?5error?5on?5track?5header?4?6@ DB 'Read error on '
	DB	'track header.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IOCKPAHO@Read?5error?5on?5MIDI?5header?4?6@
CONST	SEGMENT
??_C@_0BM@IOCKPAHO@Read?5error?5on?5MIDI?5header?4?6@ DB 'Read error on M'
	DB	'IDI header.', 0aH, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _Mid2StreamRewindConverter
_TEXT	SEGMENT
_pInTrack$ = -8						; size = 4
_iTrack$ = -4						; size = 4
_Mid2StreamRewindConverter PROC				; COMDAT

; 1394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1395 : 	DWORD          iTrack;
; 1396 : 	LPINTRACKSTATE pInTrack;
; 1397 : 
; 1398 : 	tkCurrentTime = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tkCurrentTime, 0

; 1399 : 
; 1400 : 	// reset to start of midi file
; 1401 : 	ifs.iBytesLeft = ifs.FileSize;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _ifs
  00018	a3 08 00 00 00	 mov	 DWORD PTR _ifs+8, eax

; 1402 : 	ifs.pFilePointer = ifs.pFile;

  0001d	a1 04 00 00 00	 mov	 eax, DWORD PTR _ifs+4
  00022	a3 0c 00 00 00	 mov	 DWORD PTR _ifs+12, eax

; 1403 : 
; 1404 : 	for (iTrack = 0, pInTrack = ifs.pTracks; iTrack < ifs.nTracks; ++iTrack, ++pInTrack)

  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iTrack$[ebp], 0
  0002e	c7 45 f8 1c 00
	00 00		 mov	 DWORD PTR _pInTrack$[ebp], OFFSET _ifs+28
  00035	eb 12		 jmp	 SHORT $LN4@Mid2Stream
$LN2@Mid2Stream:
  00037	8b 45 fc	 mov	 eax, DWORD PTR _iTrack$[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 45 fc	 mov	 DWORD PTR _iTrack$[ebp], eax
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  00043	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00046	89 4d f8	 mov	 DWORD PTR _pInTrack$[ebp], ecx
$LN4@Mid2Stream:
  00049	8b 45 fc	 mov	 eax, DWORD PTR _iTrack$[ebp]
  0004c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _ifs+24
  00052	73 7a		 jae	 SHORT $LN3@Mid2Stream

; 1405 : 	{
; 1406 : 		pInTrack->iBytesLeft = pInTrack->iTrackLen;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0005a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1407 : 
; 1408 : 		// Setup pointer to the current position in the track
; 1409 : 		pInTrack->pTrackPointer = pInTrack->pTrackData;

  00060	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  00066	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00069	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1410 : 
; 1411 : 		pInTrack->fdwTrack = 0;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0006f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1412 : 		pInTrack->bRunningStatus = BAD_MIDI_FIX;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00078	c6 40 18 80	 mov	 BYTE PTR [eax+24], 128	; 00000080H

; 1413 : 		pInTrack->tkNextEventDue = 0;

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0007f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1414 : 
; 1415 : 		// Handle bozo MIDI files which contain empty track chunks
; 1416 : 		if (!pInTrack->iBytesLeft)

  00086	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00089	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0008d	75 0f		 jne	 SHORT $LN5@Mid2Stream

; 1417 : 		{
; 1418 : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	83 c9 01	 or	 ecx, 1
  00097	8b 55 f8	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0009a	89 0a		 mov	 DWORD PTR [edx], ecx

; 1419 : 			continue;

  0009c	eb 99		 jmp	 SHORT $LN2@Mid2Stream
$LN5@Mid2Stream:

; 1420 : 		}
; 1421 : 
; 1422 : 		// We always preread the time from each track so the mixer code can
; 1423 : 		// determine which track has the next event with a minimum of work
; 1424 : 		if (!GetTrackVDWord(pInTrack, &pInTrack->tkNextEventDue))

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  000a1	83 c0 14	 add	 eax, 20			; 00000014H
  000a4	50		 push	 eax
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _GetTrackVDWord
  000ae	83 c4 08	 add	 esp, 8
  000b1	85 c0		 test	 eax, eax
  000b3	75 14		 jne	 SHORT $LN6@Mid2Stream

; 1425 : 		{
; 1426 : 			I_OutputMsg("Read error while reading first delta time of track.\n");

  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BLKEMBAP@Read?5error?5while?5reading?5first?5@
  000ba	e8 00 00 00 00	 call	 _I_OutputMsg
  000bf	83 c4 04	 add	 esp, 4

; 1427 : 			return TRUE;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	eb 07		 jmp	 SHORT $LN1@Mid2Stream
$LN6@Mid2Stream:

; 1428 : 		}
; 1429 : 	}

  000c9	e9 69 ff ff ff	 jmp	 $LN2@Mid2Stream
$LN3@Mid2Stream:

; 1430 : 	// End of track initialization code
; 1431 : 
; 1432 : 	return FALSE;

  000ce	33 c0		 xor	 eax, eax
$LN1@Mid2Stream:

; 1433 : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_Mid2StreamRewindConverter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _AddEventToStreamBuffer
_TEXT	SEGMENT
_dwCurrentTempo$1 = -16					; size = 4
_pmeEvent$ = -12					; size = 4
_tkDelta$ = -8						; size = 4
_tkNow$ = -4						; size = 4
_pMe$ = 8						; size = 4
_lpciInfo$ = 12						; size = 4
_AddEventToStreamBuffer PROC				; COMDAT

; 1265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1266 : 	DWORD      tkNow, tkDelta;
; 1267 : 	MIDIEVENT *pmeEvent;
; 1268 : 
; 1269 : 	pmeEvent = (MIDIEVENT *)(lpciInfo->mhBuffer.lpData

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _lpciInfo$[ebp]
  00011	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00014	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00017	03 48 48	 add	 ecx, DWORD PTR [eax+72]
  0001a	89 4d f4	 mov	 DWORD PTR _pmeEvent$[ebp], ecx

; 1270 : 	                        + lpciInfo->dwStartOffset
; 1271 : 	                        + lpciInfo->dwBytesRecorded);
; 1272 : 
; 1273 : 	// When we see a new, empty buffer, set the start time on it...
; 1274 : 	if (!lpciInfo->dwBytesRecorded)

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00020	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00024	75 0c		 jne	 SHORT $LN2@AddEventTo

; 1275 : 		lpciInfo->tkStart = tkCurrentTime;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tkCurrentTime
  0002f	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
$LN2@AddEventTo:

; 1276 : 
; 1277 : 	// Use the above set start time to figure out how much longer we should fill
; 1278 : 	// this buffer before officially declaring it as "full"
; 1279 : 	if (tkCurrentTime - lpciInfo->tkStart > dwBufferTickLength)

  00032	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tkCurrentTime
  0003b	2b 48 4c	 sub	 ecx, DWORD PTR [eax+76]
  0003e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _dwBufferTickLength
  00044	76 29		 jbe	 SHORT $LN5@AddEventTo

; 1280 : 	{
; 1281 : 		if (lpciInfo->bTimesUp)

  00046	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00049	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  0004d	74 16		 je	 SHORT $LN4@AddEventTo

; 1282 : 		{
; 1283 : 			lpciInfo->bTimesUp = FALSE;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00052	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 1284 : 			return CONVERTERR_BUFFERFULL;

  00059	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  0005e	e9 1f 02 00 00	 jmp	 $LN1@AddEventTo

; 1285 : 		}

  00063	eb 0a		 jmp	 SHORT $LN5@AddEventTo
$LN4@AddEventTo:

; 1286 : 		else
; 1287 : 			lpciInfo->bTimesUp = TRUE;

  00065	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00068	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [eax+80], 1
$LN5@AddEventTo:

; 1288 : 	}
; 1289 : 
; 1290 : 	tkNow = tkCurrentTime;

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tkCurrentTime
  00074	89 45 fc	 mov	 DWORD PTR _tkNow$[ebp], eax

; 1291 : 
; 1292 : 	// Delta time is absolute event time minus absolute time
; 1293 : 	// already gone by on this track
; 1294 : 	tkDelta = pMe->tkEvent - tkCurrentTime;

  00077	8b 45 08	 mov	 eax, DWORD PTR _pMe$[ebp]
  0007a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007c	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _tkCurrentTime
  00082	89 4d f8	 mov	 DWORD PTR _tkDelta$[ebp], ecx

; 1295 : 
; 1296 : 	// Event time is now current time on this track
; 1297 : 	tkCurrentTime = pMe->tkEvent;

  00085	8b 45 08	 mov	 eax, DWORD PTR _pMe$[ebp]
  00088	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008a	89 0d 00 00 00
	00		 mov	 DWORD PTR _tkCurrentTime, ecx

; 1298 : 
; 1299 : 	if (pMe->abEvent[0] < MIDI_SYSEX)

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	6b c8 00	 imul	 ecx, eax, 0
  00098	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  0009b	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  000a0	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  000a5	0f 8d 80 00 00
	00		 jge	 $LN6@AddEventTo

; 1300 : 	{
; 1301 : 		// Channel message. We know how long it is, just copy it.
; 1302 : 		// Need 3 DWORD's: delta-t, stream-ID, event
; 1303 : 		if (lpciInfo->dwMaxLength-lpciInfo->dwBytesRecorded < 3*sizeof (DWORD))

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _lpciInfo$[ebp]
  000b1	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  000b4	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  000b7	83 fa 0c	 cmp	 edx, 12			; 0000000cH
  000ba	73 0a		 jae	 SHORT $LN8@AddEventTo

; 1304 : 		{
; 1305 : 			// Cleanup from our write operation
; 1306 : 			return CONVERTERR_BUFFERFULL;

  000bc	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  000c1	e9 bc 01 00 00	 jmp	 $LN1@AddEventTo
$LN8@AddEventTo:

; 1307 : 		}
; 1308 : 
; 1309 : 		pmeEvent->dwDeltaTime = tkDelta;

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _pmeEvent$[ebp]
  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _tkDelta$[ebp]
  000cc	89 08		 mov	 DWORD PTR [eax], ecx

; 1310 : 		pmeEvent->dwStreamID = 0;

  000ce	8b 45 f4	 mov	 eax, DWORD PTR _pmeEvent$[ebp]
  000d1	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1311 : 		pmeEvent->dwEvent = (pMe->abEvent[0])

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	6b c8 00	 imul	 ecx, eax, 0
  000e0	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  000e3	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  000e8	b9 01 00 00 00	 mov	 ecx, 1
  000ed	c1 e1 00	 shl	 ecx, 0
  000f0	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  000f3	0f b6 4c 0a 04	 movzx	 ecx, BYTE PTR [edx+ecx+4]
  000f8	c1 e1 08	 shl	 ecx, 8
  000fb	0b c1		 or	 eax, ecx
  000fd	ba 01 00 00 00	 mov	 edx, 1
  00102	d1 e2		 shl	 edx, 1
  00104	8b 4d 08	 mov	 ecx, DWORD PTR _pMe$[ebp]
  00107	0f b6 54 11 04	 movzx	 edx, BYTE PTR [ecx+edx+4]
  0010c	c1 e2 10	 shl	 edx, 16			; 00000010H
  0010f	0b c2		 or	 eax, edx
  00111	8b 4d f4	 mov	 ecx, DWORD PTR _pmeEvent$[ebp]
  00114	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1312 : 		                    | (((DWORD)pMe->abEvent[1]) << 8)
; 1313 : 		                    | (((DWORD)pMe->abEvent[2]) << 16)
; 1314 : 		                    | MEVT_F_SHORT;
; 1315 : 
; 1316 : 		//faB: control the volume with our own volume percentage
; 1317 : 		if (((pMe->abEvent[0] & 0xF0) == MIDI_CTRLCHANGE) &&
; 1318 : 			(pMe->abEvent[1] == MIDICTRL_VOLUME))
; 1319 : 		{
; 1320 : 			// If this is a volume change, generate a callback so we can grab
; 1321 : 			// the new volume for our cache
; 1322 : 			// BP: this seems like this is useless and cause many many many bugs !
; 1323 : 			//pmeEvent->dwEvent |= MEVT_F_CALLBACK;
; 1324 : 		}
; 1325 : 		lpciInfo->dwBytesRecorded += 3 *sizeof (DWORD);

  00117	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  0011a	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0011d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00120	8b 55 0c	 mov	 edx, DWORD PTR _lpciInfo$[ebp]
  00123	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 1326 : 	}

  00126	e9 55 01 00 00	 jmp	 $LN11@AddEventTo
$LN6@AddEventTo:

; 1327 : 	else if ((pMe->abEvent[0] == MIDI_SYSEX) ||

  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	6b c8 00	 imul	 ecx, eax, 0
  00133	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  00136	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  0013b	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00140	74 17		 je	 SHORT $LN12@AddEventTo
  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	6b c8 00	 imul	 ecx, eax, 0
  0014a	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  0014d	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  00152	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00157	75 1b		 jne	 SHORT $LN10@AddEventTo
$LN12@AddEventTo:

; 1328 : 			(pMe->abEvent[0] == MIDI_SYSEXEND))
; 1329 : 	{
; 1330 : 		if (devparm) // Tails

  00159	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00160	74 0d		 je	 SHORT $LN13@AddEventTo

; 1331 : 			I_OutputMsg("NOTE: Ignoring SysEx for now.\n");

  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLAIGNOM@NOTE?3?5Ignoring?5SysEx?5for?5now?4?6@
  00167	e8 00 00 00 00	 call	 _I_OutputMsg
  0016c	83 c4 04	 add	 esp, 4
$LN13@AddEventTo:

; 1332 : 	}

  0016f	e9 0c 01 00 00	 jmp	 $LN11@AddEventTo
$LN10@AddEventTo:

; 1333 : 	else
; 1334 : 	{
; 1335 : 		DWORD   dwCurrentTempo;
; 1336 : 
; 1337 : 		// Better be a meta event.
; 1338 : 		//  BYTE        byEvent
; 1339 : 		//  BYTE        byEventType
; 1340 : 		//  VDWORD      dwEventLength
; 1341 : 		//  BYTE        pLongEventData[dwEventLength]
; 1342 : 		//
; 1343 : 		if (!(pMe->abEvent[0] == MIDI_META))

  00174	b8 01 00 00 00	 mov	 eax, 1
  00179	6b c8 00	 imul	 ecx, eax, 0
  0017c	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  0017f	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  00184	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00189	74 0d		 je	 SHORT $LN14@AddEventTo

; 1344 : 		{
; 1345 : 			I_Error("AddEventToStreamBuffer: not a META event\n");

  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@EANDOAKM@AddEventToStreamBuffer?3?5not?5a?5M@
  00190	e8 00 00 00 00	 call	 _I_Error
  00195	83 c4 04	 add	 esp, 4
$LN14@AddEventTo:

; 1346 : 		}
; 1347 : 
; 1348 : 		// The only meta-event we care about is change tempo
; 1349 : 		//
; 1350 : 		if (pMe->abEvent[1] != MIDI_META_TEMPO)

  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	c1 e0 00	 shl	 eax, 0
  001a0	8b 4d 08	 mov	 ecx, DWORD PTR _pMe$[ebp]
  001a3	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  001a8	83 fa 51	 cmp	 edx, 81			; 00000051H
  001ab	74 0a		 je	 SHORT $LN15@AddEventTo

; 1351 : 			return CONVERTERR_METASKIP;

  001ad	b8 97 ff ff ff	 mov	 eax, -105		; ffffff97H
  001b2	e9 cb 00 00 00	 jmp	 $LN1@AddEventTo
$LN15@AddEventTo:

; 1352 : 
; 1353 : 		// We should have three bytes of parameter data...
; 1354 : 		if (!(pMe->dwEventLength == 3))

  001b7	8b 45 08	 mov	 eax, DWORD PTR _pMe$[ebp]
  001ba	83 78 08 03	 cmp	 DWORD PTR [eax+8], 3
  001be	74 0d		 je	 SHORT $LN16@AddEventTo

; 1355 : 		{
; 1356 : 			I_Error("AddEventToStreamBuffer: dwEventLength <> 3\n");

  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@INAJHHHP@AddEventToStreamBuffer?3?5dwEvent@
  001c5	e8 00 00 00 00	 call	 _I_Error
  001ca	83 c4 04	 add	 esp, 4
$LN16@AddEventTo:

; 1357 : 		}
; 1358 : 
; 1359 : 		// Need 3 DWORD's: delta-t, stream-ID, event data
; 1360 : 		if (lpciInfo->dwMaxLength - lpciInfo->dwBytesRecorded < 3 *sizeof (DWORD))

  001cd	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  001d0	8b 4d 0c	 mov	 ecx, DWORD PTR _lpciInfo$[ebp]
  001d3	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  001d6	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  001d9	83 fa 0c	 cmp	 edx, 12			; 0000000cH
  001dc	73 0a		 jae	 SHORT $LN17@AddEventTo

; 1361 : 		{
; 1362 : 			return CONVERTERR_BUFFERFULL;

  001de	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  001e3	e9 9a 00 00 00	 jmp	 $LN1@AddEventTo
$LN17@AddEventTo:

; 1363 : 		}
; 1364 : 
; 1365 : 		pmeEvent->dwDeltaTime = tkDelta;

  001e8	8b 45 f4	 mov	 eax, DWORD PTR _pmeEvent$[ebp]
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _tkDelta$[ebp]
  001ee	89 08		 mov	 DWORD PTR [eax], ecx

; 1366 : 		pmeEvent->dwStreamID = 0;

  001f0	8b 45 f4	 mov	 eax, DWORD PTR _pmeEvent$[ebp]
  001f3	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1367 : 		// Note: this is backwards from above because we're converting a single
; 1368 : 		//       data value from hi-lo to lo-hi format...
; 1369 : 		pmeEvent->dwEvent = (pMe->pEvent[2])

  001fa	b8 01 00 00 00	 mov	 eax, 1
  001ff	d1 e0		 shl	 eax, 1
  00201	8b 4d 08	 mov	 ecx, DWORD PTR _pMe$[ebp]
  00204	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00207	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  0020b	b9 01 00 00 00	 mov	 ecx, 1
  00210	c1 e1 00	 shl	 ecx, 0
  00213	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  00216	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00219	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0021d	c1 e1 08	 shl	 ecx, 8
  00220	0b c1		 or	 eax, ecx
  00222	ba 01 00 00 00	 mov	 edx, 1
  00227	6b ca 00	 imul	 ecx, edx, 0
  0022a	8b 55 08	 mov	 edx, DWORD PTR _pMe$[ebp]
  0022d	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00230	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00234	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00237	0b c1		 or	 eax, ecx
  00239	8b 55 f4	 mov	 edx, DWORD PTR _pmeEvent$[ebp]
  0023c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1370 : 			| (((DWORD)pMe->pEvent[1]) << 8)
; 1371 : 			| (((DWORD)pMe->pEvent[0]) << 16);
; 1372 : 
; 1373 : 		dwCurrentTempo = pmeEvent->dwEvent;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _pmeEvent$[ebp]
  00242	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00245	89 4d f0	 mov	 DWORD PTR _dwCurrentTempo$1[ebp], ecx

; 1374 : 		pmeEvent->dwEvent |= (((DWORD)MEVT_TEMPO) << 24) | MEVT_F_SHORT;

  00248	8b 45 f4	 mov	 eax, DWORD PTR _pmeEvent$[ebp]
  0024b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024e	81 c9 00 00 00
	01		 or	 ecx, 16777216		; 01000000H
  00254	8b 55 f4	 mov	 edx, DWORD PTR _pmeEvent$[ebp]
  00257	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1375 : 
; 1376 : 		dwBufferTickLength = (ifs.dwTimeDivision * 1000 * BUFFER_TIME_LENGTH) / dwCurrentTempo;

  0025a	69 05 10 00 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR _ifs+16, 1000
  00264	6b c0 3c	 imul	 eax, eax, 60
  00267	33 d2		 xor	 edx, edx
  00269	f7 75 f0	 div	 DWORD PTR _dwCurrentTempo$1[ebp]
  0026c	a3 00 00 00 00	 mov	 DWORD PTR _dwBufferTickLength, eax

; 1377 : #ifdef DEBUGMIDISTREAM
; 1378 : 		I_OutputMsg("dwBufferTickLength = %lu", dwBufferTickLength);
; 1379 : #endif
; 1380 : 		lpciInfo->dwBytesRecorded += 3 *sizeof (DWORD);

  00271	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00274	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00277	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0027a	8b 55 0c	 mov	 edx, DWORD PTR _lpciInfo$[ebp]
  0027d	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
$LN11@AddEventTo:

; 1381 : 	}
; 1382 : 
; 1383 : 	return FALSE;

  00280	33 c0		 xor	 eax, eax
$LN1@AddEventTo:

; 1384 : }

  00282	5f		 pop	 edi
  00283	5e		 pop	 esi
  00284	5b		 pop	 ebx
  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c3		 ret	 0
_AddEventToStreamBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _GetInFileData
_TEXT	SEGMENT
_pRet$ = -4						; size = 4
_iBytesToGet$ = 8					; size = 4
_GetInFileData PROC					; COMDAT

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 427  : 	LPBYTE pRet;
; 428  : 	if (ifs.iBytesLeft < iBytesToGet)       // requested more BYTEs than there are left

  00009	a1 08 00 00 00	 mov	 eax, DWORD PTR _ifs+8
  0000e	3b 45 08	 cmp	 eax, DWORD PTR _iBytesToGet$[ebp]
  00011	73 04		 jae	 SHORT $LN2@GetInFileD

; 429  : 		return NULL;

  00013	33 c0		 xor	 eax, eax
  00015	eb 25		 jmp	 SHORT $LN1@GetInFileD
$LN2@GetInFileD:

; 430  : 	pRet = ifs.pFilePointer;                // pointer to requested data

  00017	a1 0c 00 00 00	 mov	 eax, DWORD PTR _ifs+12
  0001c	89 45 fc	 mov	 DWORD PTR _pRet$[ebp], eax

; 431  : 	ifs.iBytesLeft -= iBytesToGet;

  0001f	a1 08 00 00 00	 mov	 eax, DWORD PTR _ifs+8
  00024	2b 45 08	 sub	 eax, DWORD PTR _iBytesToGet$[ebp]
  00027	a3 08 00 00 00	 mov	 DWORD PTR _ifs+8, eax

; 432  : 	ifs.pFilePointer += iBytesToGet;

  0002c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _ifs+12
  00031	03 45 08	 add	 eax, DWORD PTR _iBytesToGet$[ebp]
  00034	a3 0c 00 00 00	 mov	 DWORD PTR _ifs+12, eax

; 433  : 	return pRet;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pRet$[ebp]
$LN1@GetInFileD:

; 434  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_GetInFileData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _GetTrackEvent
_TEXT	SEGMENT
tv169 = -80						; size = 4
_tkDelta$1 = -12					; size = 4
_dwEventLength$ = -8					; size = 4
_b$ = -1						; size = 1
_pInTrack$ = 8						; size = 4
_pMe$ = 12						; size = 4
_GetTrackEvent PROC					; COMDAT

; 687  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 688  : 	BYTE b;
; 689  : 	UINT32 dwEventLength;
; 690  : 
; 691  : 	// Clear out the temporary event structure to get rid of old data...
; 692  : 	ZeroMemory(pMe, sizeof (TEMPEVENT));

  00009	6a 10		 push	 16			; 00000010H
  0000b	6a 00		 push	 0
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 693  : 
; 694  : 	// Already at end of track? There's nothing to read.
; 695  : 	//
; 696  : 	if ((pInTrack->fdwTrack & ITS_F_ENDOFTRK) || !pInTrack->iBytesLeft)

  00019	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	83 e1 01	 and	 ecx, 1
  00021	75 09		 jne	 SHORT $LN3@GetTrackEv
  00023	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00026	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002a	75 07		 jne	 SHORT $LN2@GetTrackEv
$LN3@GetTrackEv:

; 697  : 		return FALSE;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 fc 03 00 00	 jmp	 $LN1@GetTrackEv
$LN2@GetTrackEv:

; 698  : 
; 699  : 	// Get the first BYTE, which determines the type of event.
; 700  : 	//
; 701  : 	b = *pInTrack->pTrackPointer++;

  00033	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00036	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00039	8a 11		 mov	 dl, BYTE PTR [ecx]
  0003b	88 55 ff	 mov	 BYTE PTR _b$[ebp], dl
  0003e	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00041	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00044	83 c1 01	 add	 ecx, 1
  00047	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0004a	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 702  : 	--pInTrack->iBytesLeft;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00050	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00053	83 e9 01	 sub	 ecx, 1
  00056	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00059	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 703  : 
; 704  : 	// If the high bit is not set, then this is a channel message
; 705  : 	// which uses the status BYTE from the last channel message
; 706  : 	// we saw. NOTE: We do not clear running status across SysEx or
; 707  : 	// meta events even though the spec says to because there are
; 708  : 	// actually files out there which contain that sequence of data.
; 709  : 	//
; 710  : 	if (!(b & 0x80))

  0005c	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  00060	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00065	0f 85 d6 00 00
	00		 jne	 $LN4@GetTrackEv

; 711  : 	{
; 712  : 		// No previous status BYTE? We're hosed.
; 713  : 		//
; 714  : 		if (!pInTrack->bRunningStatus)

  0006b	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0006e	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00072	85 c9		 test	 ecx, ecx
  00074	75 07		 jne	 SHORT $LN6@GetTrackEv

; 715  : 		{
; 716  : 			TRACKERR(pInTrack, gteBadRunStat);
; 717  : 			return FALSE;

  00076	33 c0		 xor	 eax, eax
  00078	e9 b2 03 00 00	 jmp	 $LN1@GetTrackEv
$LN6@GetTrackEv:

; 718  : 		}
; 719  : 
; 720  : 		//faB: the last midi command issued on that track
; 721  : 		pMe->abEvent[0] = pInTrack->bRunningStatus;

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	6b c8 00	 imul	 ecx, eax, 0
  00085	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  00088	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0008b	8a 40 18	 mov	 al, BYTE PTR [eax+24]
  0008e	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 722  : 		pMe->abEvent[1] = b;        // the data !

  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	c1 e0 00	 shl	 eax, 0
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  0009d	8a 55 ff	 mov	 dl, BYTE PTR _b$[ebp]
  000a0	88 54 01 04	 mov	 BYTE PTR [ecx+eax+4], dl

; 723  : 
; 724  : 		b = (BYTE)(pMe->abEvent[0] & 0xF0);

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	6b c8 00	 imul	 ecx, eax, 0
  000ac	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  000af	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  000b4	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000b9	88 45 ff	 mov	 BYTE PTR _b$[ebp], al

; 725  : 		pMe->dwEventLength = 2;       //2 data bytes

  000bc	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  000bf	c7 40 08 02 00
	00 00		 mov	 DWORD PTR [eax+8], 2

; 726  : 
; 727  : 		// Only program change and channel pressure events are 2 BYTEs long;
; 728  : 		// the rest are 3 and need another BYTE
; 729  : 		//
; 730  : 		if ((b != MIDI_PRGMCHANGE) && (b != MIDI_CHANPRESS))

  000c6	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  000ca	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000cf	74 6b		 je	 SHORT $LN7@GetTrackEv
  000d1	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  000d5	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  000da	74 60		 je	 SHORT $LN7@GetTrackEv

; 731  : 		{
; 732  : 			if (!pInTrack->iBytesLeft)

  000dc	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  000df	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000e3	75 14		 jne	 SHORT $LN8@GetTrackEv

; 733  : 			{
; 734  : 				TRACKERR(pInTrack, gteRunStatMsgTrunc);
; 735  : 				pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  000e5	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	83 c9 01	 or	 ecx, 1
  000ed	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  000f0	89 0a		 mov	 DWORD PTR [edx], ecx

; 736  : 				return FALSE;

  000f2	33 c0		 xor	 eax, eax
  000f4	e9 36 03 00 00	 jmp	 $LN1@GetTrackEv
$LN8@GetTrackEv:

; 737  : 			}
; 738  : 
; 739  : 			pMe->abEvent[2] = *pInTrack->pTrackPointer++;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  000fc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ff	ba 01 00 00 00	 mov	 edx, 1
  00104	d1 e2		 shl	 edx, 1
  00106	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00109	8a 09		 mov	 cl, BYTE PTR [ecx]
  0010b	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
  0010f	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00112	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00115	83 c0 01	 add	 eax, 1
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0011b	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 740  : 			--pInTrack->iBytesLeft;

  0011e	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00121	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00124	83 e9 01	 sub	 ecx, 1
  00127	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0012a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 741  : 			++pMe->dwEventLength;

  0012d	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00130	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00133	83 c1 01	 add	 ecx, 1
  00136	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  00139	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN7@GetTrackEv:

; 742  : 		}
; 743  : 	}

  0013c	e9 ad 02 00 00	 jmp	 $LN19@GetTrackEv
$LN4@GetTrackEv:

; 744  : 	else if ((b & 0xF0) != MIDI_SYSEX)

  00141	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  00145	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0014a	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  0014f	0f 84 e4 00 00
	00		 je	 $LN9@GetTrackEv

; 745  : 	{
; 746  : 		// Not running status, not in SysEx range - must be
; 747  : 		// normal channel message (0x80-0xEF)
; 748  : 
; 749  : 		pMe->abEvent[0] = b;

  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	6b c8 00	 imul	 ecx, eax, 0
  0015d	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  00160	8a 45 ff	 mov	 al, BYTE PTR _b$[ebp]
  00163	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 750  : 		pInTrack->bRunningStatus = b;

  00167	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0016a	8a 4d ff	 mov	 cl, BYTE PTR _b$[ebp]
  0016d	88 48 18	 mov	 BYTE PTR [eax+24], cl

; 751  : 
; 752  : 		// Strip off channel and just keep message type
; 753  : 		//
; 754  : 		b &= 0xF0;

  00170	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  00174	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00179	88 45 ff	 mov	 BYTE PTR _b$[ebp], al

; 755  : 
; 756  : 		dwEventLength = (b == MIDI_PRGMCHANGE || b == MIDI_CHANPRESS) ? 1 : 2;

  0017c	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  00180	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00185	74 15		 je	 SHORT $LN28@GetTrackEv
  00187	0f b6 4d ff	 movzx	 ecx, BYTE PTR _b$[ebp]
  0018b	81 f9 d0 00 00
	00		 cmp	 ecx, 208		; 000000d0H
  00191	74 09		 je	 SHORT $LN28@GetTrackEv
  00193	c7 45 b0 02 00
	00 00		 mov	 DWORD PTR tv169[ebp], 2
  0019a	eb 07		 jmp	 SHORT $LN29@GetTrackEv
$LN28@GetTrackEv:
  0019c	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv169[ebp], 1
$LN29@GetTrackEv:
  001a3	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  001a6	89 55 f8	 mov	 DWORD PTR _dwEventLength$[ebp], edx

; 757  : 		pMe->dwEventLength = dwEventLength + 1;

  001a9	8b 45 f8	 mov	 eax, DWORD PTR _dwEventLength$[ebp]
  001ac	83 c0 01	 add	 eax, 1
  001af	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  001b2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 758  : 
; 759  : 		if (pInTrack->iBytesLeft < dwEventLength)

  001b5	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  001b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bb	3b 4d f8	 cmp	 ecx, DWORD PTR _dwEventLength$[ebp]
  001be	73 14		 jae	 SHORT $LN11@GetTrackEv

; 760  : 		{
; 761  : 			TRACKERR(pInTrack, gteChanMsgTrunc);
; 762  : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  001c0	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  001c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c5	83 c9 01	 or	 ecx, 1
  001c8	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  001cb	89 0a		 mov	 DWORD PTR [edx], ecx

; 763  : 			return FALSE;

  001cd	33 c0		 xor	 eax, eax
  001cf	e9 5b 02 00 00	 jmp	 $LN1@GetTrackEv
$LN11@GetTrackEv:

; 764  : 		}
; 765  : 
; 766  : 		pMe->abEvent[1] = *pInTrack->pTrackPointer++;

  001d4	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  001d7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001da	ba 01 00 00 00	 mov	 edx, 1
  001df	c1 e2 00	 shl	 edx, 0
  001e2	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  001e5	8a 09		 mov	 cl, BYTE PTR [ecx]
  001e7	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
  001eb	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  001ee	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001f1	83 c0 01	 add	 eax, 1
  001f4	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  001f7	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 767  : 		if (dwEventLength == 2)

  001fa	83 7d f8 02	 cmp	 DWORD PTR _dwEventLength$[ebp], 2
  001fe	75 25		 jne	 SHORT $LN12@GetTrackEv

; 768  : 			pMe->abEvent[2] = *pInTrack->pTrackPointer++;

  00200	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00203	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00206	ba 01 00 00 00	 mov	 edx, 1
  0020b	d1 e2		 shl	 edx, 1
  0020d	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00210	8a 09		 mov	 cl, BYTE PTR [ecx]
  00212	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
  00216	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00219	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0021c	83 c0 01	 add	 eax, 1
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  00222	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN12@GetTrackEv:

; 769  : 
; 770  : 		pInTrack->iBytesLeft -= dwEventLength;

  00225	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00228	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0022b	2b 4d f8	 sub	 ecx, DWORD PTR _dwEventLength$[ebp]
  0022e	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00231	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 771  : 	}

  00234	e9 b5 01 00 00	 jmp	 $LN19@GetTrackEv
$LN9@GetTrackEv:

; 772  : 	else if (b == MIDI_SYSEX || b == MIDI_SYSEXEND)

  00239	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  0023d	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00242	74 0f		 je	 SHORT $LN15@GetTrackEv
  00244	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  00248	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  0024d	0f 85 87 00 00
	00		 jne	 $LN13@GetTrackEv
$LN15@GetTrackEv:

; 773  : 	{
; 774  : 		// One of the SysEx types. (They are the same as far as we're concerned;
; 775  : 		// there is only a semantic difference in how the data would actually
; 776  : 		// get sent when the file is played. We must take care to put the correct
; 777  : 		// event type back on the output track, however.)
; 778  : 		//
; 779  : 		// Parse the general format of:
; 780  : 		//  BYTE        bEvent (MIDI_SYSEX or MIDI_SYSEXEND)
; 781  : 		//  VLONG      cbParms
; 782  : 		//  BYTE        abParms[cbParms]
; 783  : 		//
; 784  : 		pMe->abEvent[0] = b;

  00253	b8 01 00 00 00	 mov	 eax, 1
  00258	6b c8 00	 imul	 ecx, eax, 0
  0025b	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  0025e	8a 45 ff	 mov	 al, BYTE PTR _b$[ebp]
  00261	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 785  : 		if (!GetTrackVDWord(pInTrack, &pMe->dwEventLength))

  00265	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00268	83 c0 08	 add	 eax, 8
  0026b	50		 push	 eax
  0026c	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 _GetTrackVDWord
  00275	83 c4 08	 add	 esp, 8
  00278	85 c0		 test	 eax, eax
  0027a	75 07		 jne	 SHORT $LN16@GetTrackEv

; 786  : 		{
; 787  : 			TRACKERR(pInTrack, gteSysExLenTrunc);
; 788  : 			return FALSE;

  0027c	33 c0		 xor	 eax, eax
  0027e	e9 ac 01 00 00	 jmp	 $LN1@GetTrackEv
$LN16@GetTrackEv:

; 789  : 		}
; 790  : 
; 791  : 		if (pInTrack->iBytesLeft < pMe->dwEventLength)

  00283	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00286	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  00289	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0028c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0028f	73 14		 jae	 SHORT $LN17@GetTrackEv

; 792  : 		{
; 793  : 			TRACKERR(pInTrack, gteSysExTrunc);
; 794  : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  00291	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00294	8b 08		 mov	 ecx, DWORD PTR [eax]
  00296	83 c9 01	 or	 ecx, 1
  00299	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0029c	89 0a		 mov	 DWORD PTR [edx], ecx

; 795  : 			return FALSE;

  0029e	33 c0		 xor	 eax, eax
  002a0	e9 8a 01 00 00	 jmp	 $LN1@GetTrackEv
$LN17@GetTrackEv:

; 796  : 		}
; 797  : 
; 798  : 		pMe->pEvent = pInTrack->pTrackPointer;

  002a5	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  002ab	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002ae	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 799  : 		pInTrack->pTrackPointer += pMe->dwEventLength;

  002b1	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  002b4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002b7	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  002ba	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  002bd	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  002c0	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 800  : 		pInTrack->iBytesLeft -= pMe->dwEventLength;

  002c3	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  002c6	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  002c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002cc	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  002cf	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  002d2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 801  : 	}

  002d5	e9 14 01 00 00	 jmp	 $LN19@GetTrackEv
$LN13@GetTrackEv:

; 802  : 	else if (b == MIDI_META)

  002da	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  002de	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  002e3	0f 85 01 01 00
	00		 jne	 $LN18@GetTrackEv

; 803  : 	{
; 804  : 		// It's a meta event. Parse the general form:
; 805  : 		//  BYTE        bEvent  (MIDI_META)
; 806  : 		//      BYTE    bClass
; 807  : 		//  VLONG      cbParms
; 808  : 		//      BYTE    abParms[cbParms]
; 809  : 		//
; 810  : 		pMe->abEvent[0] = b;

  002e9	b8 01 00 00 00	 mov	 eax, 1
  002ee	6b c8 00	 imul	 ecx, eax, 0
  002f1	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  002f4	8a 45 ff	 mov	 al, BYTE PTR _b$[ebp]
  002f7	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 811  : 
; 812  : 		if (!pInTrack->iBytesLeft)

  002fb	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  002fe	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00302	75 14		 jne	 SHORT $LN20@GetTrackEv

; 813  : 		{
; 814  : 			TRACKERR(pInTrack, gteMetaNoClass);
; 815  : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  00304	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00307	8b 08		 mov	 ecx, DWORD PTR [eax]
  00309	83 c9 01	 or	 ecx, 1
  0030c	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0030f	89 0a		 mov	 DWORD PTR [edx], ecx

; 816  : 			return FALSE;

  00311	33 c0		 xor	 eax, eax
  00313	e9 17 01 00 00	 jmp	 $LN1@GetTrackEv
$LN20@GetTrackEv:

; 817  : 		}
; 818  : 
; 819  : 		pMe->abEvent[1] = *pInTrack->pTrackPointer++;

  00318	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0031b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0031e	ba 01 00 00 00	 mov	 edx, 1
  00323	c1 e2 00	 shl	 edx, 0
  00326	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00329	8a 09		 mov	 cl, BYTE PTR [ecx]
  0032b	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
  0032f	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00332	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00335	83 c0 01	 add	 eax, 1
  00338	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0033b	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 820  : 		--pInTrack->iBytesLeft;

  0033e	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00341	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00344	83 e9 01	 sub	 ecx, 1
  00347	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0034a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 821  : 
; 822  : 		if (!GetTrackVDWord(pInTrack, &pMe->dwEventLength))

  0034d	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00350	83 c0 08	 add	 eax, 8
  00353	50		 push	 eax
  00354	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  00357	51		 push	 ecx
  00358	e8 00 00 00 00	 call	 _GetTrackVDWord
  0035d	83 c4 08	 add	 esp, 8
  00360	85 c0		 test	 eax, eax
  00362	75 07		 jne	 SHORT $LN21@GetTrackEv

; 823  : 		{
; 824  : 			TRACKERR(pInTrack, gteMetaLenTrunc);
; 825  : 			return FALSE;

  00364	33 c0		 xor	 eax, eax
  00366	e9 c4 00 00 00	 jmp	 $LN1@GetTrackEv
$LN21@GetTrackEv:

; 826  : 		}
; 827  : 
; 828  : 		// NOTE: Perfectly valid to have a meta with no data
; 829  : 		// In this case, dwEventLength == 0 and pEvent == NULL
; 830  : 		//
; 831  : 		if (pMe->dwEventLength)

  0036b	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  0036e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00372	74 52		 je	 SHORT $LN22@GetTrackEv

; 832  : 		{
; 833  : 			if (pInTrack->iBytesLeft < pMe->dwEventLength)

  00374	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00377	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  0037a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0037d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00380	73 14		 jae	 SHORT $LN23@GetTrackEv

; 834  : 			{
; 835  : 				TRACKERR(pInTrack, gteMetaTrunc);
; 836  : 				pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  00382	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00385	8b 08		 mov	 ecx, DWORD PTR [eax]
  00387	83 c9 01	 or	 ecx, 1
  0038a	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0038d	89 0a		 mov	 DWORD PTR [edx], ecx

; 837  : 				return FALSE;

  0038f	33 c0		 xor	 eax, eax
  00391	e9 99 00 00 00	 jmp	 $LN1@GetTrackEv
$LN23@GetTrackEv:

; 838  : 			}
; 839  : 
; 840  : 			pMe->pEvent = pInTrack->pTrackPointer;

  00396	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  00399	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0039c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0039f	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 841  : 			pInTrack->pTrackPointer += pMe->dwEventLength;

  003a2	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  003a5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003a8	8b 55 0c	 mov	 edx, DWORD PTR _pMe$[ebp]
  003ab	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  003ae	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  003b1	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 842  : 			pInTrack->iBytesLeft -= pMe->dwEventLength;

  003b4	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  003b7	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  003ba	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  003bd	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  003c0	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  003c3	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN22@GetTrackEv:

; 843  : 		}
; 844  : 
; 845  : 		if (pMe->abEvent[1] == MIDI_META_EOT)

  003c6	b8 01 00 00 00	 mov	 eax, 1
  003cb	c1 e0 00	 shl	 eax, 0
  003ce	8b 4d 0c	 mov	 ecx, DWORD PTR _pMe$[ebp]
  003d1	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  003d6	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  003d9	75 0d		 jne	 SHORT $LN24@GetTrackEv

; 846  : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  003db	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  003de	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e0	83 c9 01	 or	 ecx, 1
  003e3	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  003e6	89 0a		 mov	 DWORD PTR [edx], ecx
$LN24@GetTrackEv:

; 847  : 	}

  003e8	eb 04		 jmp	 SHORT $LN19@GetTrackEv
$LN18@GetTrackEv:

; 848  : 	else
; 849  : 	{
; 850  : 		// Messages in this range are system messages and aren't supposed to
; 851  : 		// be in a normal MIDI file. If they are, we've misparsed or the
; 852  : 		// authoring software is stpuid.
; 853  : #ifdef DEBUGMIDISTREAM
; 854  : 		I_OutputMsg("System message not supposed to be in MIDI file..\n");
; 855  : #endif
; 856  : 		return FALSE;

  003ea	33 c0		 xor	 eax, eax
  003ec	eb 41		 jmp	 SHORT $LN1@GetTrackEv
$LN19@GetTrackEv:

; 857  : 	}
; 858  : 
; 859  : 	// Event time was already stored as the current track time
; 860  : 	//
; 861  : 	pMe->tkEvent = pInTrack->tkNextEventDue;

  003ee	8b 45 0c	 mov	 eax, DWORD PTR _pMe$[ebp]
  003f1	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  003f4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  003f7	89 10		 mov	 DWORD PTR [eax], edx

; 862  : 
; 863  : 	// Now update to the next event time. The code above MUST properly
; 864  : 	// maintain the end of track flag in case the end of track meta is
; 865  : 	// missing.
; 866  : 
; 867  : 	if (!(pInTrack->fdwTrack & ITS_F_ENDOFTRK))

  003f9	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  003fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fe	83 e1 01	 and	 ecx, 1
  00401	75 27		 jne	 SHORT $LN25@GetTrackEv

; 868  : 	{
; 869  : 		DWORD tkDelta;
; 870  : 
; 871  : 		if (!GetTrackVDWord(pInTrack, &tkDelta))

  00403	8d 45 f4	 lea	 eax, DWORD PTR _tkDelta$1[ebp]
  00406	50		 push	 eax
  00407	8b 4d 08	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0040a	51		 push	 ecx
  0040b	e8 00 00 00 00	 call	 _GetTrackVDWord
  00410	83 c4 08	 add	 esp, 8
  00413	85 c0		 test	 eax, eax
  00415	75 04		 jne	 SHORT $LN26@GetTrackEv

; 872  : 			return FALSE;

  00417	33 c0		 xor	 eax, eax
  00419	eb 14		 jmp	 SHORT $LN1@GetTrackEv
$LN26@GetTrackEv:

; 873  : 
; 874  : 		pInTrack->tkNextEventDue += tkDelta;

  0041b	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0041e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00421	03 4d f4	 add	 ecx, DWORD PTR _tkDelta$1[ebp]
  00424	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00427	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$LN25@GetTrackEv:

; 875  : 	}
; 876  : 
; 877  : 	return TRUE;

  0042a	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetTrackEv:

; 878  : }

  0042f	5f		 pop	 edi
  00430	5e		 pop	 esi
  00431	5b		 pop	 ebx
  00432	8b e5		 mov	 esp, ebp
  00434	5d		 pop	 ebp
  00435	c3		 ret	 0
_GetTrackEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _GetTrackVDWord
_TEXT	SEGMENT
_dw$ = -8						; size = 4
_b$ = -1						; size = 1
_pInTrack$ = 8						; size = 4
_lpdw$ = 12						; size = 4
_GetTrackVDWord PROC					; COMDAT

; 630  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 631  : 	BYTE b;
; 632  : 	DWORD dw = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 633  : 
; 634  : 	if (pInTrack->fdwTrack & ITS_F_ENDOFTRK)

  00010	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	83 e1 01	 and	 ecx, 1
  00018	74 04		 je	 SHORT $LN5@GetTrackVD

; 635  : 		return FALSE;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 6d		 jmp	 SHORT $LN1@GetTrackVD
$LN5@GetTrackVD:

; 636  : 
; 637  : 	do
; 638  : 	{
; 639  : 		if (!pInTrack->iBytesLeft)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00021	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00025	75 11		 jne	 SHORT $LN6@GetTrackVD

; 640  : 		{
; 641  : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  00027	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	83 c9 01	 or	 ecx, 1
  0002f	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 642  : 			return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	eb 53		 jmp	 SHORT $LN1@GetTrackVD
$LN6@GetTrackVD:

; 643  : 		}
; 644  : 
; 645  : 		b = *pInTrack->pTrackPointer++;

  00038	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0003b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00040	88 55 ff	 mov	 BYTE PTR _b$[ebp], dl
  00043	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00046	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00049	83 c1 01	 add	 ecx, 1
  0004c	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0004f	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 646  : 		--pInTrack->iBytesLeft;

  00052	8b 45 08	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00055	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00058	83 e9 01	 sub	 ecx, 1
  0005b	8b 55 08	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0005e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 647  : 
; 648  : 		dw = (dw << 7) | (b & 0x7F);

  00061	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  00064	c1 e0 07	 shl	 eax, 7
  00067	0f b6 4d ff	 movzx	 ecx, BYTE PTR _b$[ebp]
  0006b	83 e1 7f	 and	 ecx, 127		; 0000007fH
  0006e	0b c1		 or	 eax, ecx
  00070	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax

; 649  : 	} while (b & 0x80);

  00073	0f b6 45 ff	 movzx	 eax, BYTE PTR _b$[ebp]
  00077	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0007c	75 a0		 jne	 SHORT $LN5@GetTrackVD

; 650  : 
; 651  : 	*lpdw = dw;

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _lpdw$[ebp]
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _dw$[ebp]
  00084	89 08		 mov	 DWORD PTR [eax], ecx

; 652  : 
; 653  : 	return TRUE;

  00086	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetTrackVD:

; 654  : }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_GetTrackVDWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _Mid2StreamConvertToBuffer
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_nChkErr$ = -4						; size = 4
_dwFlags$ = 8						; size = 4
_lpciInfo$ = 12						; size = 4
_Mid2StreamConvertToBuffer PROC				; COMDAT

; 1448 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1449 : 	static LPINTRACKSTATE pInTrack, pInTrackFound;
; 1450 : 	static DWORD          dwStatus;
; 1451 : 	static DWORD          tkNext;
; 1452 : 	static TEMPEVENT      teTemp;
; 1453 : 
; 1454 : 	int     nChkErr;
; 1455 : 	DWORD   idx;
; 1456 : 
; 1457 : 	lpciInfo->dwBytesRecorded = 0;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  0000c	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 1458 : 
; 1459 : 	if (dwFlags & CONVERTF_RESET)

  00013	8b 45 08	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00016	83 e0 01	 and	 eax, 1
  00019	74 39		 je	 SHORT $LN8@Mid2Stream

; 1460 : 	{
; 1461 : 		dwProgressBytes = 0;

  0001b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dwProgressBytes, 0

; 1462 : 		dwStatus = 0;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, 0

; 1463 : 		ZeroMemory(&teTemp, sizeof (TEMPEVENT));

  0002f	6a 10		 push	 16			; 00000010H
  00031	6a 00		 push	 0
  00033	68 00 00 00 00	 push	 OFFSET ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1464 : 		pInTrack = pInTrackFound = NULL;

  00040	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9, 0
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9
  0004f	a3 00 00 00 00	 mov	 DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9, eax
$LN8@Mid2Stream:

; 1465 : 	}
; 1466 : 
; 1467 : 	// If we were already done, then return with a warning...
; 1468 : 	if (dwStatus & CONVERTF_STATUS_DONE)

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  00059	83 e0 01	 and	 eax, 1
  0005c	74 34		 je	 SHORT $LN9@Mid2Stream

; 1469 : 	{
; 1470 : 		if (bMidiLooped)

  0005e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bMidiLooped, 0
  00065	74 1c		 je	 SHORT $LN11@Mid2Stream

; 1471 : 		{
; 1472 : 			Mid2StreamRewindConverter();

  00067	e8 00 00 00 00	 call	 _Mid2StreamRewindConverter
  0006c	90		 npad	 1

; 1473 : 			dwProgressBytes = 0;

  0006d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dwProgressBytes, 0

; 1474 : 			dwStatus = 0;

  00077	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, 0

; 1475 : 		}

  00081	eb 0a		 jmp	 SHORT $LN12@Mid2Stream
$LN11@Mid2Stream:

; 1476 : 		else
; 1477 : 			return CONVERTERR_DONE;

  00083	b8 99 ff ff ff	 mov	 eax, -103		; ffffff99H
  00088	e9 f6 01 00 00	 jmp	 $LN3@Mid2Stream
$LN12@Mid2Stream:

; 1478 : 	}

  0008d	e9 ac 00 00 00	 jmp	 $LN22@Mid2Stream
$LN9@Mid2Stream:

; 1479 : 	// The caller is asking us to continue, but we're already hosed because we
; 1480 : 	// previously identified something as corrupt, so complain louder this time.
; 1481 : 	else if (dwStatus & CONVERTF_STATUS_STUCK)

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  00097	83 e0 02	 and	 eax, 2
  0009a	74 0f		 je	 SHORT $LN13@Mid2Stream

; 1482 : 		return CONVERTERR_STUCK;

  0009c	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  000a1	e9 dd 01 00 00	 jmp	 $LN3@Mid2Stream
  000a6	e9 93 00 00 00	 jmp	 $LN22@Mid2Stream
$LN13@Mid2Stream:

; 1483 : 	else if (dwStatus & CONVERTF_STATUS_GOTEVENT)

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  000b0	83 e0 04	 and	 eax, 4
  000b3	0f 84 85 00 00
	00		 je	 $LN22@Mid2Stream

; 1484 : 	{
; 1485 : 		// Turn off this bit flag
; 1486 : 		dwStatus ^= CONVERTF_STATUS_GOTEVENT;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  000be	83 f0 04	 xor	 eax, 4
  000c1	a3 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, eax

; 1487 : 
; 1488 : 		// Don't add end of track event 'til we're done
; 1489 : 		//
; 1490 : 		if (teTemp.abEvent[0] == MIDI_META &&

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	6b c8 00	 imul	 ecx, eax, 0
  000ce	0f b6 91 04 00
	00 00		 movzx	 edx, BYTE PTR ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9[ecx+4]
  000d5	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  000db	75 16		 jne	 SHORT $LN16@Mid2Stream
  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	c1 e0 00	 shl	 eax, 0
  000e5	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9[eax+4]
  000ec	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  000ef	75 02		 jne	 SHORT $LN16@Mid2Stream

; 1491 : 			teTemp.abEvent[1] == MIDI_META_EOT)
; 1492 : 		{
; 1493 : 		}

  000f1	eb 4b		 jmp	 SHORT $LN22@Mid2Stream
$LN16@Mid2Stream:

; 1494 : 		else if ((nChkErr = AddEventToStreamBuffer(&teTemp, lpciInfo))
; 1495 : 		         != CONVERTERR_NOERROR)

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  000f6	50		 push	 eax
  000f7	68 00 00 00 00	 push	 OFFSET ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9
  000fc	e8 00 00 00 00	 call	 _AddEventToStreamBuffer
  00101	83 c4 08	 add	 esp, 8
  00104	89 45 fc	 mov	 DWORD PTR _nChkErr$[ebp], eax
  00107	83 7d fc 00	 cmp	 DWORD PTR _nChkErr$[ebp], 0
  0010b	74 31		 je	 SHORT $LN22@Mid2Stream

; 1496 : 		{
; 1497 : 			if (nChkErr == CONVERTERR_BUFFERFULL)

  0010d	83 7d fc 98	 cmp	 DWORD PTR _nChkErr$[ebp], -104 ; ffffff98H
  00111	75 16		 jne	 SHORT $LN19@Mid2Stream

; 1498 : 			{
; 1499 : 				// Do some processing and tell caller that this buffer's full
; 1500 : 				dwStatus |= CONVERTF_STATUS_GOTEVENT;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  00118	83 c8 04	 or	 eax, 4
  0011b	a3 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, eax

; 1501 : 				return CONVERTERR_NOERROR;

  00120	33 c0		 xor	 eax, eax
  00122	e9 5c 01 00 00	 jmp	 $LN3@Mid2Stream

; 1502 : 			}

  00127	eb 15		 jmp	 SHORT $LN22@Mid2Stream
$LN19@Mid2Stream:

; 1503 : 			else if (nChkErr == CONVERTERR_METASKIP)

  00129	83 7d fc 97	 cmp	 DWORD PTR _nChkErr$[ebp], -105 ; ffffff97H
  0012d	75 02		 jne	 SHORT $LN21@Mid2Stream

; 1504 : 			{
; 1505 : 				// We skip by all meta events that aren't tempo changes...
; 1506 : 			}

  0012f	eb 0d		 jmp	 SHORT $LN22@Mid2Stream
$LN21@Mid2Stream:

; 1507 : 			else
; 1508 : 			{
; 1509 : 				I_Error("Unable to add event to stream buffer.");

  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DNJCGPOJ@Unable?5to?5add?5event?5to?5stream?5b@
  00136	e8 00 00 00 00	 call	 _I_Error
  0013b	83 c4 04	 add	 esp, 4
$LN22@Mid2Stream:
$LN2@Mid2Stream:

; 1510 : 			}
; 1511 : 		}
; 1512 : 	}
; 1513 : 
; 1514 : 	for (; ;)
; 1515 : 	{
; 1516 : 		pInTrackFound = NULL;

  0013e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9, 0

; 1517 : 		tkNext = 0xFFFFFFFFL;

  00148	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?tkNext@?1??Mid2StreamConvertToBuffer@@9@9, -1

; 1518 : 
; 1519 : 		// Find nearest event due
; 1520 : 		//
; 1521 : 		for (idx = 0, pInTrack = ifs.pTracks; idx < ifs.nTracks; ++idx, ++pInTrack)

  00152	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _idx$[ebp], 0
  00159	c7 05 00 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9, OFFSET _ifs+28
  00163	eb 18		 jmp	 SHORT $LN7@Mid2Stream
$LN5@Mid2Stream:
  00165	8b 45 f8	 mov	 eax, DWORD PTR _idx$[ebp]
  00168	83 c0 01	 add	 eax, 1
  0016b	89 45 f8	 mov	 DWORD PTR _idx$[ebp], eax
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9
  00174	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00177	89 0d 00 00 00
	00		 mov	 DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9, ecx
$LN7@Mid2Stream:
  0017d	8b 45 f8	 mov	 eax, DWORD PTR _idx$[ebp]
  00180	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _ifs+24
  00186	73 36		 jae	 SHORT $LN6@Mid2Stream

; 1522 : 		{
; 1523 : 			if ((!(pInTrack->fdwTrack & ITS_F_ENDOFTRK)) && (pInTrack->tkNextEventDue < tkNext))

  00188	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9
  0018d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018f	83 e1 01	 and	 ecx, 1
  00192	75 28		 jne	 SHORT $LN23@Mid2Stream
  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9
  00199	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0019c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?tkNext@?1??Mid2StreamConvertToBuffer@@9@9
  001a2	73 18		 jae	 SHORT $LN23@Mid2Stream

; 1524 : 			{
; 1525 : 				tkNext = pInTrack->tkNextEventDue;

  001a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9
  001a9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001ac	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tkNext@?1??Mid2StreamConvertToBuffer@@9@9, ecx

; 1526 : 				pInTrackFound = pInTrack;

  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pInTrack@?1??Mid2StreamConvertToBuffer@@9@9
  001b7	a3 00 00 00 00	 mov	 DWORD PTR ?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9, eax
$LN23@Mid2Stream:

; 1527 : 			}
; 1528 : 		}

  001bc	eb a7		 jmp	 SHORT $LN5@Mid2Stream
$LN6@Mid2Stream:

; 1529 : 
; 1530 : 		// None found?  We must be done, so return to the caller with a smile.
; 1531 : 		//
; 1532 : 		if (!pInTrackFound)

  001be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9, 0
  001c5	75 14		 jne	 SHORT $LN24@Mid2Stream

; 1533 : 		{
; 1534 : 			dwStatus |= CONVERTF_STATUS_DONE;

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  001cc	83 c8 01	 or	 eax, 1
  001cf	a3 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, eax

; 1535 : 			// Need to set return buffer members properly
; 1536 : 			return CONVERTERR_NOERROR;

  001d4	33 c0		 xor	 eax, eax
  001d6	e9 a8 00 00 00	 jmp	 $LN3@Mid2Stream
$LN24@Mid2Stream:

; 1537 : 		}
; 1538 : 
; 1539 : 		// Ok, get the event header from that track
; 1540 : 		//
; 1541 : 		if (!GetTrackEvent(pInTrackFound, &teTemp))

  001db	68 00 00 00 00	 push	 OFFSET ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9
  001e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pInTrackFound@?1??Mid2StreamConvertToBuffer@@9@9
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 _GetTrackEvent
  001eb	83 c4 08	 add	 esp, 8
  001ee	85 c0		 test	 eax, eax
  001f0	75 14		 jne	 SHORT $LN25@Mid2Stream

; 1542 : 		{
; 1543 : 			// Warn future calls that this converter is stuck at a corrupt spot
; 1544 : 			// and can't continue
; 1545 : 			dwStatus |= CONVERTF_STATUS_STUCK;

  001f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  001f7	83 c8 02	 or	 eax, 2
  001fa	a3 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, eax

; 1546 : 			return CONVERTERR_CORRUPT;

  001ff	b8 9b ff ff ff	 mov	 eax, -101		; ffffff9bH
  00204	eb 7d		 jmp	 SHORT $LN3@Mid2Stream
$LN25@Mid2Stream:

; 1547 : 		}
; 1548 : 
; 1549 : 		// Don't add end of track event 'til we're done
; 1550 : 		//
; 1551 : 		if (teTemp.abEvent[0] == MIDI_META &&

  00206	b8 01 00 00 00	 mov	 eax, 1
  0020b	6b c8 00	 imul	 ecx, eax, 0
  0020e	0f b6 91 04 00
	00 00		 movzx	 edx, BYTE PTR ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9[ecx+4]
  00215	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0021b	75 19		 jne	 SHORT $LN26@Mid2Stream
  0021d	b8 01 00 00 00	 mov	 eax, 1
  00222	c1 e0 00	 shl	 eax, 0
  00225	0f b6 88 04 00
	00 00		 movzx	 ecx, BYTE PTR ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9[eax+4]
  0022c	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  0022f	75 05		 jne	 SHORT $LN26@Mid2Stream

; 1552 : 		    teTemp.abEvent[1] == MIDI_META_EOT)
; 1553 : 			continue;

  00231	e9 08 ff ff ff	 jmp	 $LN2@Mid2Stream
$LN26@Mid2Stream:

; 1554 : 
; 1555 : 		if ((nChkErr = AddEventToStreamBuffer(&teTemp, lpciInfo))
; 1556 : 			!= CONVERTERR_NOERROR)

  00236	8b 45 0c	 mov	 eax, DWORD PTR _lpciInfo$[ebp]
  00239	50		 push	 eax
  0023a	68 00 00 00 00	 push	 OFFSET ?teTemp@?1??Mid2StreamConvertToBuffer@@9@9
  0023f	e8 00 00 00 00	 call	 _AddEventToStreamBuffer
  00244	83 c4 08	 add	 esp, 8
  00247	89 45 fc	 mov	 DWORD PTR _nChkErr$[ebp], eax
  0024a	83 7d fc 00	 cmp	 DWORD PTR _nChkErr$[ebp], 0
  0024e	74 2e		 je	 SHORT $LN31@Mid2Stream

; 1557 : 		{
; 1558 : 			if (nChkErr == CONVERTERR_BUFFERFULL)

  00250	83 7d fc 98	 cmp	 DWORD PTR _nChkErr$[ebp], -104 ; ffffff98H
  00254	75 13		 jne	 SHORT $LN28@Mid2Stream

; 1559 : 			{
; 1560 : 				// Do some processing and tell somebody this buffer is full...
; 1561 : 				dwStatus |= CONVERTF_STATUS_GOTEVENT;

  00256	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9
  0025b	83 c8 04	 or	 eax, 4
  0025e	a3 00 00 00 00	 mov	 DWORD PTR ?dwStatus@?1??Mid2StreamConvertToBuffer@@9@9, eax

; 1562 : 				return CONVERTERR_NOERROR;

  00263	33 c0		 xor	 eax, eax
  00265	eb 1c		 jmp	 SHORT $LN3@Mid2Stream

; 1563 : 			}

  00267	eb 15		 jmp	 SHORT $LN31@Mid2Stream
$LN28@Mid2Stream:

; 1564 : 			else if (nChkErr == CONVERTERR_METASKIP)

  00269	83 7d fc 97	 cmp	 DWORD PTR _nChkErr$[ebp], -105 ; ffffff97H
  0026d	75 02		 jne	 SHORT $LN30@Mid2Stream

; 1565 : 			{
; 1566 : 				// We skip by all meta events that aren't tempo changes...
; 1567 : 			}

  0026f	eb 0d		 jmp	 SHORT $LN31@Mid2Stream
$LN30@Mid2Stream:

; 1568 : 			else
; 1569 : 			{
; 1570 : 				I_Error("Unable to add event to stream buffer.");

  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DNJCGPOJ@Unable?5to?5add?5event?5to?5stream?5b@
  00276	e8 00 00 00 00	 call	 _I_Error
  0027b	83 c4 04	 add	 esp, 4
$LN31@Mid2Stream:

; 1571 : 			}
; 1572 : 		}
; 1573 : 	}

  0027e	e9 bb fe ff ff	 jmp	 $LN2@Mid2Stream
$LN3@Mid2Stream:

; 1574 : 
; 1575 : 	//return CONVERTERR_NOERROR;
; 1576 : }

  00283	5f		 pop	 edi
  00284	5e		 pop	 esi
  00285	5b		 pop	 ebx
  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c3		 ret	 0
_Mid2StreamConvertToBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _Mid2StreamConverterInit
_TEXT	SEGMENT
_iTrack$ = -28						; size = 4
_pInTrack$ = -24					; size = 4
_pHeader$ = -20						; size = 4
_iChunkSize$ = -16					; size = 4
_pChunkSize$ = -12					; size = 4
_pChunkID$ = -8						; size = 4
_fRet$ = -4						; size = 4
_pMidiData$ = 8						; size = 4
_iMidiSize$ = 12					; size = 4
_Mid2StreamConverterInit PROC				; COMDAT

; 1130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1131 : 	BOOL           fRet = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _fRet$[ebp], 1

; 1132 : 	UINT32         *pChunkID;
; 1133 : 	UINT32         *pChunkSize;
; 1134 : 	UINT32          iChunkSize;
; 1135 : 	LPMIDIFILEHDR  pHeader;
; 1136 : 	LPINTRACKSTATE pInTrack;
; 1137 : 	UINT           iTrack;
; 1138 : 
; 1139 : 	tkCurrentTime = 0;

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tkCurrentTime, 0

; 1140 : 
; 1141 : 	// Initialize things we'll try to free later if we fail
; 1142 : 	ZeroMemory(&ifs, sizeof (INFILESTATE));

  0001a	68 dc 01 00 00	 push	 476			; 000001dcH
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET _ifs
  00026	e8 00 00 00 00	 call	 _memset
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1143 : 	//ifs.pTracks = NULL;   //faB: now static
; 1144 : 
; 1145 : 	// Set up to read from the memory buffer. Read and validate
; 1146 : 	// - MThd header
; 1147 : 	// - size of file header chunk
; 1148 : 	// - file header itself
; 1149 : 	//
; 1150 : 	ifs.FileSize = iMidiSize;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _iMidiSize$[ebp]
  00031	a3 00 00 00 00	 mov	 DWORD PTR _ifs, eax

; 1151 : 	ifs.pFile = pMidiData;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pMidiData$[ebp]
  00039	a3 04 00 00 00	 mov	 DWORD PTR _ifs+4, eax

; 1152 : 	ifs.iBytesLeft = ifs.FileSize;

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR _ifs
  00043	a3 08 00 00 00	 mov	 DWORD PTR _ifs+8, eax

; 1153 : 	ifs.pFilePointer = ifs.pFile;

  00048	a1 04 00 00 00	 mov	 eax, DWORD PTR _ifs+4
  0004d	a3 0c 00 00 00	 mov	 DWORD PTR _ifs+12, eax

; 1154 : 
; 1155 : #ifdef DEBUGMIDISTREAM
; 1156 : 	I_OutputMsg("Midi file size: %d\n", iMidiSize);
; 1157 : #endif
; 1158 : 
; 1159 : 	// note: midi header size should always be 6
; 1160 : 	if ((pChunkID = (UINT32*)GetInFileData(sizeof (*pChunkID))) == NULL ||
; 1161 : 		*pChunkID != MThd ||
; 1162 : 		(pChunkSize = (UINT32*)GetInFileData(sizeof (*pChunkSize))) == NULL ||
; 1163 : 		(iChunkSize = LONGSWAP(*pChunkSize)) < sizeof (MIDIFILEHDR) ||

  00052	6a 04		 push	 4
  00054	e8 00 00 00 00	 call	 _GetInFileData
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 f8	 mov	 DWORD PTR _pChunkID$[ebp], eax
  0005f	83 7d f8 00	 cmp	 DWORD PTR _pChunkID$[ebp], 0
  00063	74 71		 je	 SHORT $LN6@Mid2Stream
  00065	8b 45 f8	 mov	 eax, DWORD PTR _pChunkID$[ebp]
  00068	81 38 4d 54 68
	64		 cmp	 DWORD PTR [eax], 1684558925 ; 6468544dH
  0006e	75 66		 jne	 SHORT $LN6@Mid2Stream
  00070	6a 04		 push	 4
  00072	e8 00 00 00 00	 call	 _GetInFileData
  00077	83 c4 04	 add	 esp, 4
  0007a	89 45 f4	 mov	 DWORD PTR _pChunkSize$[ebp], eax
  0007d	83 7d f4 00	 cmp	 DWORD PTR _pChunkSize$[ebp], 0
  00081	74 53		 je	 SHORT $LN6@Mid2Stream
  00083	8b 45 f4	 mov	 eax, DWORD PTR _pChunkSize$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0008b	8b 55 f4	 mov	 edx, DWORD PTR _pChunkSize$[ebp]
  0008e	8b 02		 mov	 eax, DWORD PTR [edx]
  00090	c1 e8 08	 shr	 eax, 8
  00093	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00098	0b c8		 or	 ecx, eax
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _pChunkSize$[ebp]
  0009d	8b 02		 mov	 eax, DWORD PTR [edx]
  0009f	c1 e0 08	 shl	 eax, 8
  000a2	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  000a7	0b c8		 or	 ecx, eax
  000a9	8b 55 f4	 mov	 edx, DWORD PTR _pChunkSize$[ebp]
  000ac	8b 02		 mov	 eax, DWORD PTR [edx]
  000ae	c1 e0 18	 shl	 eax, 24			; 00000018H
  000b1	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  000b6	0b c8		 or	 ecx, eax
  000b8	89 4d f0	 mov	 DWORD PTR _iChunkSize$[ebp], ecx
  000bb	83 7d f0 06	 cmp	 DWORD PTR _iChunkSize$[ebp], 6
  000bf	72 15		 jb	 SHORT $LN6@Mid2Stream
  000c1	8b 45 f0	 mov	 eax, DWORD PTR _iChunkSize$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _GetInFileData
  000ca	83 c4 04	 add	 esp, 4
  000cd	89 45 ec	 mov	 DWORD PTR _pHeader$[ebp], eax
  000d0	83 7d ec 00	 cmp	 DWORD PTR _pHeader$[ebp], 0
  000d4	75 12		 jne	 SHORT $LN5@Mid2Stream
$LN6@Mid2Stream:

; 1164 : 		(pHeader = (LPMIDIFILEHDR)GetInFileData(iChunkSize)) == NULL)
; 1165 : 	{
; 1166 : 		I_OutputMsg("Read error on MIDI header.\n");

  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IOCKPAHO@Read?5error?5on?5MIDI?5header?4?6@
  000db	e8 00 00 00 00	 call	 _I_OutputMsg
  000e0	83 c4 04	 add	 esp, 4

; 1167 : 		goto Init_Cleanup;

  000e3	e9 cf 01 00 00	 jmp	 $Init_Cleanup$15
$LN5@Mid2Stream:

; 1168 : 	}
; 1169 : 
; 1170 : 	ifs.dwFormat = (LONG)WORDSWAP(pHeader->wFormat);

  000e8	8b 45 ec	 mov	 eax, DWORD PTR _pHeader$[ebp]
  000eb	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000ee	c1 f9 08	 sar	 ecx, 8
  000f1	8b 55 ec	 mov	 edx, DWORD PTR _pHeader$[ebp]
  000f4	0f b7 02	 movzx	 eax, WORD PTR [edx]
  000f7	c1 e0 08	 shl	 eax, 8
  000fa	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  000ff	0b c8		 or	 ecx, eax
  00101	89 0d 14 00 00
	00		 mov	 DWORD PTR _ifs+20, ecx

; 1171 : 	ifs.nTracks   = (LONG)WORDSWAP(pHeader->nTracks);

  00107	8b 45 ec	 mov	 eax, DWORD PTR _pHeader$[ebp]
  0010a	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0010e	c1 f9 08	 sar	 ecx, 8
  00111	8b 55 ec	 mov	 edx, DWORD PTR _pHeader$[ebp]
  00114	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00118	c1 e0 08	 shl	 eax, 8
  0011b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00120	0b c8		 or	 ecx, eax
  00122	89 0d 18 00 00
	00		 mov	 DWORD PTR _ifs+24, ecx

; 1172 : 	ifs.dwTimeDivision = (LONG)WORDSWAP(pHeader->wTimeDivision);

  00128	8b 45 ec	 mov	 eax, DWORD PTR _pHeader$[ebp]
  0012b	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0012f	c1 f9 08	 sar	 ecx, 8
  00132	8b 55 ec	 mov	 edx, DWORD PTR _pHeader$[ebp]
  00135	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00139	c1 e0 08	 shl	 eax, 8
  0013c	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00141	0b c8		 or	 ecx, eax
  00143	89 0d 10 00 00
	00		 mov	 DWORD PTR _ifs+16, ecx

; 1173 : 
; 1174 : #ifdef DEBUGMIDISTREAM
; 1175 : 	I_OutputMsg("MIDI Header:\n"
; 1176 : 				"------------\n"
; 1177 : 				"format: %d\n"
; 1178 : 				"number of tracks: %d\n"
; 1179 : 				"time division: %d\n", ifs.dwFormat, ifs.nTracks, ifs.dwTimeDivision);
; 1180 : #endif
; 1181 : 
; 1182 : 	/* faB: made static
; 1183 : 	ifs.pTracks = (INTRACKSTATE *)GlobalAllocPtr(GPTR, ifs.nTracks*sizeof (INTRACKSTATE));
; 1184 : 	if (ifs.pTracks == NULL)
; 1185 : 	{
; 1186 : 		I_OutputMsg("Out of memory.\n");
; 1187 : 		goto Init_Cleanup;
; 1188 : 	}
; 1189 : 	*/
; 1190 : 
; 1191 : 	// faB: made it static, but don't quit if there are more tracks, just skip'em
; 1192 : 	if (ifs.nTracks > MAX_MIDI_IN_TRACKS)

  00149	83 3d 18 00 00
	00 10		 cmp	 DWORD PTR _ifs+24, 16	; 00000010H
  00150	76 0a		 jbe	 SHORT $LN7@Mid2Stream

; 1193 : 		ifs.nTracks = MAX_MIDI_IN_TRACKS;

  00152	c7 05 18 00 00
	00 10 00 00 00	 mov	 DWORD PTR _ifs+24, 16	; 00000010H
$LN7@Mid2Stream:

; 1194 : 
; 1195 : 	for (iTrack = 0, pInTrack = ifs.pTracks; iTrack < ifs.nTracks; ++iTrack, ++pInTrack)

  0015c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iTrack$[ebp], 0
  00163	c7 45 e8 1c 00
	00 00		 mov	 DWORD PTR _pInTrack$[ebp], OFFSET _ifs+28
  0016a	eb 12		 jmp	 SHORT $LN4@Mid2Stream
$LN2@Mid2Stream:
  0016c	8b 45 e4	 mov	 eax, DWORD PTR _iTrack$[ebp]
  0016f	83 c0 01	 add	 eax, 1
  00172	89 45 e4	 mov	 DWORD PTR _iTrack$[ebp], eax
  00175	8b 4d e8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  00178	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0017b	89 4d e8	 mov	 DWORD PTR _pInTrack$[ebp], ecx
$LN4@Mid2Stream:
  0017e	8b 45 e4	 mov	 eax, DWORD PTR _iTrack$[ebp]
  00181	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _ifs+24
  00187	0f 83 23 01 00
	00		 jae	 $LN3@Mid2Stream

; 1196 : 	{
; 1197 : 		if ((pChunkID = (UINT32*)GetInFileData(sizeof (*pChunkID))) == NULL ||
; 1198 : 			*pChunkID!= MTrk ||

  0018d	6a 04		 push	 4
  0018f	e8 00 00 00 00	 call	 _GetInFileData
  00194	83 c4 04	 add	 esp, 4
  00197	89 45 f8	 mov	 DWORD PTR _pChunkID$[ebp], eax
  0019a	83 7d f8 00	 cmp	 DWORD PTR _pChunkID$[ebp], 0
  0019e	74 1e		 je	 SHORT $LN9@Mid2Stream
  001a0	8b 45 f8	 mov	 eax, DWORD PTR _pChunkID$[ebp]
  001a3	81 38 4d 54 72
	6b		 cmp	 DWORD PTR [eax], 1802654797 ; 6b72544dH
  001a9	75 13		 jne	 SHORT $LN9@Mid2Stream
  001ab	6a 04		 push	 4
  001ad	e8 00 00 00 00	 call	 _GetInFileData
  001b2	83 c4 04	 add	 esp, 4
  001b5	89 45 f4	 mov	 DWORD PTR _pChunkSize$[ebp], eax
  001b8	83 7d f4 00	 cmp	 DWORD PTR _pChunkSize$[ebp], 0
  001bc	75 12		 jne	 SHORT $LN8@Mid2Stream
$LN9@Mid2Stream:

; 1199 : 			(pChunkSize = (UINT32*)GetInFileData(sizeof (*pChunkSize))) == NULL)
; 1200 : 		{
; 1201 : 			I_OutputMsg("Read error on track header.\n");

  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LHIKEFDN@Read?5error?5on?5track?5header?4?6@
  001c3	e8 00 00 00 00	 call	 _I_OutputMsg
  001c8	83 c4 04	 add	 esp, 4

; 1202 : 			goto Init_Cleanup;

  001cb	e9 e7 00 00 00	 jmp	 $Init_Cleanup$15
$LN8@Mid2Stream:

; 1203 : 		}
; 1204 : 
; 1205 : 		iChunkSize = LONGSWAP(*pChunkSize);

  001d0	8b 45 f4	 mov	 eax, DWORD PTR _pChunkSize$[ebp]
  001d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d5	c1 e9 18	 shr	 ecx, 24			; 00000018H
  001d8	8b 55 f4	 mov	 edx, DWORD PTR _pChunkSize$[ebp]
  001db	8b 02		 mov	 eax, DWORD PTR [edx]
  001dd	c1 e8 08	 shr	 eax, 8
  001e0	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  001e5	0b c8		 or	 ecx, eax
  001e7	8b 55 f4	 mov	 edx, DWORD PTR _pChunkSize$[ebp]
  001ea	8b 02		 mov	 eax, DWORD PTR [edx]
  001ec	c1 e0 08	 shl	 eax, 8
  001ef	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  001f4	0b c8		 or	 ecx, eax
  001f6	8b 55 f4	 mov	 edx, DWORD PTR _pChunkSize$[ebp]
  001f9	8b 02		 mov	 eax, DWORD PTR [edx]
  001fb	c1 e0 18	 shl	 eax, 24			; 00000018H
  001fe	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00203	0b c8		 or	 ecx, eax
  00205	89 4d f0	 mov	 DWORD PTR _iChunkSize$[ebp], ecx

; 1206 : 		pInTrack->iTrackLen = iChunkSize;       // Total track length

  00208	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0020b	8b 4d f0	 mov	 ecx, DWORD PTR _iChunkSize$[ebp]
  0020e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1207 : 		pInTrack->iBytesLeft = iChunkSize;

  00211	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00214	8b 4d f0	 mov	 ecx, DWORD PTR _iChunkSize$[ebp]
  00217	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1208 : 		pInTrack->pTrackData = GetInFileData(iChunkSize);

  0021a	8b 45 f0	 mov	 eax, DWORD PTR _iChunkSize$[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _GetInFileData
  00223	83 c4 04	 add	 esp, 4
  00226	8b 4d e8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  00229	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1209 : 		if (pInTrack->pTrackData == NULL)

  0022c	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0022f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00233	75 0f		 jne	 SHORT $LN10@Mid2Stream

; 1210 : 		{
; 1211 : 			I_OutputMsg("Read error while reading track data.\n");

  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@ILPAJGKE@Read?5error?5while?5reading?5track?5@
  0023a	e8 00 00 00 00	 call	 _I_OutputMsg
  0023f	83 c4 04	 add	 esp, 4

; 1212 : 			goto Init_Cleanup;

  00242	eb 73		 jmp	 SHORT $Init_Cleanup$15
$LN10@Mid2Stream:

; 1213 : 		}
; 1214 : 
; 1215 : #ifdef DEBUGMIDISTREAM
; 1216 : 		I_OutputMsg("Track %d : length %d bytes\n", iTrack, iChunkSize);
; 1217 : 		pInTrack->nTrack = iTrack;
; 1218 : #endif
; 1219 : 		// Setup pointer to the current position in the track
; 1220 : 		pInTrack->pTrackPointer = pInTrack->pTrackData;

  00244	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00247	8b 4d e8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0024a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0024d	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1221 : 
; 1222 : 		pInTrack->fdwTrack = 0;

  00250	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00253	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1223 : 		pInTrack->bRunningStatus = BAD_MIDI_FIX;

  00259	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0025c	c6 40 18 80	 mov	 BYTE PTR [eax+24], 128	; 00000080H

; 1224 : 		pInTrack->tkNextEventDue = 0;

  00260	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00263	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1225 : 
; 1226 : 		// Handle bozo MIDI files which contain empty track chunks
; 1227 : 		if (!pInTrack->iBytesLeft)

  0026a	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  0026d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00271	75 12		 jne	 SHORT $LN11@Mid2Stream

; 1228 : 		{
; 1229 : 			pInTrack->fdwTrack |= ITS_F_ENDOFTRK;

  00273	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00276	8b 08		 mov	 ecx, DWORD PTR [eax]
  00278	83 c9 01	 or	 ecx, 1
  0027b	8b 55 e8	 mov	 edx, DWORD PTR _pInTrack$[ebp]
  0027e	89 0a		 mov	 DWORD PTR [edx], ecx

; 1230 : 			continue;

  00280	e9 e7 fe ff ff	 jmp	 $LN2@Mid2Stream
$LN11@Mid2Stream:

; 1231 : 		}
; 1232 : 
; 1233 : 		// We always preread the time from each track so the mixer code can
; 1234 : 		// determine which track has the next event with a minimum of work
; 1235 : 		if (!GetTrackVDWord(pInTrack, &pInTrack->tkNextEventDue))

  00285	8b 45 e8	 mov	 eax, DWORD PTR _pInTrack$[ebp]
  00288	83 c0 14	 add	 eax, 20			; 00000014H
  0028b	50		 push	 eax
  0028c	8b 4d e8	 mov	 ecx, DWORD PTR _pInTrack$[ebp]
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 _GetTrackVDWord
  00295	83 c4 08	 add	 esp, 8
  00298	85 c0		 test	 eax, eax
  0029a	75 0f		 jne	 SHORT $LN12@Mid2Stream

; 1236 : 		{
; 1237 : 			I_OutputMsg("Read error while reading first delta time of track.\n");

  0029c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BLKEMBAP@Read?5error?5while?5reading?5first?5@
  002a1	e8 00 00 00 00	 call	 _I_OutputMsg
  002a6	83 c4 04	 add	 esp, 4

; 1238 : 			goto Init_Cleanup;

  002a9	eb 0c		 jmp	 SHORT $Init_Cleanup$15
$LN12@Mid2Stream:

; 1239 : 		}
; 1240 : 	}

  002ab	e9 bc fe ff ff	 jmp	 $LN2@Mid2Stream
$LN3@Mid2Stream:

; 1241 : 	// End of track initialization code
; 1242 : 
; 1243 : 	fRet = FALSE;

  002b0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fRet$[ebp], 0
$Init_Cleanup$15:

; 1244 : 
; 1245 : Init_Cleanup:
; 1246 : 	if (fRet)

  002b7	83 7d fc 00	 cmp	 DWORD PTR _fRet$[ebp], 0
  002bb	74 06		 je	 SHORT $LN13@Mid2Stream

; 1247 : 		Mid2StreamConverterCleanup();

  002bd	e8 00 00 00 00	 call	 _Mid2StreamConverterCleanup
  002c2	90		 npad	 1
$LN13@Mid2Stream:

; 1248 : 
; 1249 : 	return fRet;

  002c3	8b 45 fc	 mov	 eax, DWORD PTR _fRet$[ebp]

; 1250 : }

  002c6	5f		 pop	 edi
  002c7	5e		 pop	 esi
  002c8	5b		 pop	 ebx
  002c9	8b e5		 mov	 esp, ebp
  002cb	5d		 pop	 ebp
  002cc	c3		 ret	 0
_Mid2StreamConverterInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\mid2strm.c
;	COMDAT _Mid2StreamConverterCleanup
_TEXT	SEGMENT
_Mid2StreamConverterCleanup PROC			; COMDAT

; 1110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1111 : 	// hmm.. nothing to clean up.. since I made the INTRACKSTATE's static
; 1112 : 
; 1113 : 	/* faB: made pTracks static
; 1114 : 	if (ifs.pTracks)
; 1115 : 		GlobalFreePtr(ifs.pTracks);
; 1116 : 	*/
; 1117 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_Mid2StreamConverterCleanup ENDP
_TEXT	ENDS
END
