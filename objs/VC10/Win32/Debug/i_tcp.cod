; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\i_tcp.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_sock_port
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_DATA	SEGMENT
_sock_port DW	013a5H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_I_InitTcpNetwork
PUBLIC	_I_InitTcpDriver
PUBLIC	_I_ShutdownTcpDriver
PUBLIC	??_C@_03HODKBCIO@?3?$CFd@			; `string'
PUBLIC	??_C@_0CN@JPPIFNFE@?$CF02x?$CF02x?$CF02x?$CF02x?4?$CF02x?$CF02x?$CF02x?$CF0@ ; `string'
PUBLIC	??_C@_0N@DGOCBNGP@Unknown?5type@		; `string'
PUBLIC	??_C@_04PJDNGLKJ@self@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0DJ@KDNCGLM@Connection?5reset?5?$CIlikely?5that?5t@ ; `string'
PUBLIC	??_C@_0GG@JLFOCFNG@SOCK_Get?5error?5?$CD?$CFu?3?5?$CFs?6?6?$CIDisabl@ ; `string'
PUBLIC	??_C@_0CH@LHJLLFLG@New?5node?5detected?3?5node?3?$CFd?5addr@ ; `string'
PUBLIC	??_C@_0BL@LDLKKAOF@This?5dude?5has?5been?5banned?6@ ; `string'
PUBLIC	??_C@_0CH@MFMCOFFD@New?5node?5detected?3?5No?5more?5free@ ; `string'
PUBLIC	??_C@_0DB@BHJCIMJC@SOCK_Send?0?5error?5sending?5to?5nod@ ; `string'
PUBLIC	??_C@_0BD@FLBLKNHL@Free?5node?5?$CFd?5?$CI?$CFs?$CJ?6@ ; `string'
PUBLIC	??_C@_0CO@JOFKFBKG@UDP_Socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@ ; `string'
PUBLIC	??_C@_09BBMKDBIO@?9bindaddr@			; `string'
PUBLIC	??_C@_0BP@DCCLGMFC@syntax?3?5?9bindaddr?5?$DMip?9address?$DO@ ; `string'
PUBLIC	??_C@_0M@KFBJBBFI@?9clientport@			; `string'
PUBLIC	??_C@_0BO@FNLNHHNO@syntax?3?5?9clientport?5?$DMportnum?$DO@ ; `string'
PUBLIC	??_C@_0NF@JBPHABIG@UDP_Socket?5error?3?5The?5address?5a@ ; `string'
PUBLIC	??_C@_0BJ@HHIAFBGK@UDP_Socket?5error?5?$CD?$CFu?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0DM@CKLNDCNP@UDP_Socket?5error?4?5Could?5not?5set@ ; `string'
PUBLIC	??_C@_0DK@MDCBFNLH@UDP_Socket?5error?4?5Could?5not?5set@ ; `string'
PUBLIC	??_C@_0BN@JEENIIKP@Network?5system?5buffer?3?5?$CFdKb?6@ ; `string'
PUBLIC	??_C@_0DL@CCHJDBAG@Can?8t?5set?5buffer?5length?5to?564k?0@ ; `string'
PUBLIC	??_C@_0CE@EKKIJAJA@Network?5system?5buffer?5set?5to?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CO@BFKFFGLF@IPX_socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@ ; `string'
PUBLIC	??_C@_0BH@FLNCIJCH@IPX_Bind?5error?5?$CD?$CFu?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CF@IEIIBCNK@Network?5system?5receive?5buffer?3?5@ ; `string'
PUBLIC	??_C@_0CM@DJOJGKAN@Network?5system?5receive?5buffer?5s@ ; `string'
PUBLIC	??_C@_0ED@JDIAMALP@Can?8t?5set?5receive?5buffer?5length@ ; `string'
PUBLIC	??_C@_0EI@JLCNGLKD@The?5underlying?5network?5subsyste@ ; `string'
PUBLIC	??_C@_0DI@LGHIKHKH@A?5blocking?5Windows?5Sockets?51?41?5@ ; `string'
PUBLIC	??_C@_0FO@MOJFEIAD@Limit?5on?5the?5number?5of?5tasks?5su@ ; `string'
PUBLIC	??_C@_0EJ@BFHCDGFI@WTF?$DP?5The?5WSAData?5is?5not?5a?5valid@ ; `string'
PUBLIC	??_C@_0O@GHDHPEFL@Error?5code?5?$CFu@		; `string'
PUBLIC	??_C@_0BL@GMNDDBHJ@WinSock?$CITCP?1IP?$CJ?5error?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CH@JOMAOFEJ@No?5WinSock?$CITCP?1IP?$CJ?51?41?5driver?5d@ ; `string'
PUBLIC	??_C@_0BJ@IEOEOFPL@WinSock?5description?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@KLEHEDME@WinSock?5System?5Status?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BG@OAMGEJHN@I_ShutdownTcpDriver?3?5@	; `string'
PUBLIC	??_C@_0L@KKFCCFFM@shut?5down?6@			; `string'
PUBLIC	??_C@_0BH@HDCGPMAE@Creating?5new?5node?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_0O@NIMOHCFP@Resolving?5?$CFs?6@		; `string'
PUBLIC	??_C@_0M@LNBDJGGF@?$CFs?5unknown?6@		; `string'
PUBLIC	??_C@_0N@OHGMBHC@Resolved?5?$CFs?6@		; `string'
PUBLIC	??_C@_04PFLFMAHA@?9ipx@				; `string'
PUBLIC	??_C@_08HMJCHDDA@?9udpport@			; `string'
PUBLIC	??_C@_07ODEEFNBO@?9server@			; `string'
PUBLIC	??_C@_08FABEHMEN@?9connect@			; `string'
PUBLIC	??_C@_09EGJOEHMB@connect?5?$CC@			; `string'
PUBLIC	??_C@_02MBJIFMOJ@?$CC?6@			; `string'
PUBLIC	??_C@_0N@FNIHICEM@connect?5any?6@		; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_free:PROC
EXTRN	_atoi:PROC
EXTRN	_memcmp:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strerror:PROC
EXTRN	_strtok:PROC
EXTRN	_strdup:PROC
EXTRN	_fflush:PROC
EXTRN	_fputs:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___WSAFDIsSet@8:PROC
EXTRN	_bind@12:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_getsockopt@20:PROC
EXTRN	_htonl@4:PROC
EXTRN	_htons@4:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_inet_ntoa@4:PROC
EXTRN	_ntohs@4:PROC
EXTRN	_recvfrom@24:PROC
EXTRN	_select@20:PROC
EXTRN	_sendto@24:PROC
EXTRN	_setsockopt@20:PROC
EXTRN	_socket@12:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_WSAStartup@8:PROC
EXTRN	_WSACleanup@0:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_I_AddExitFunc:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_Playing:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_hardware_MAXPACKETLENGTH:WORD
EXTRN	_net_bandwidth:DWORD
EXTRN	_doomcom:DWORD
EXTRN	_I_NetGet:DWORD
EXTRN	_I_NetCanGet:DWORD
EXTRN	_I_NetSend:DWORD
EXTRN	_I_NetCanSend:DWORD
EXTRN	_I_NetFreeNodenum:DWORD
EXTRN	_I_NetMakeNode:DWORD
EXTRN	_I_NetOpenSocket:DWORD
EXTRN	_I_NetCloseSocket:DWORD
EXTRN	_I_Ban:DWORD
EXTRN	_I_Shun:DWORD
EXTRN	_I_ClearBans:DWORD
EXTRN	_I_GetNodeAddress:DWORD
EXTRN	_I_GetBanAddress:DWORD
EXTRN	_I_GetBanMask:DWORD
EXTRN	_I_SetBanAddress:DWORD
EXTRN	_bannednode:DWORD
EXTRN	_packetheaderlength:DWORD
EXTRN	_nodeingame:BYTE
EXTRN	_debugfile:DWORD
EXTRN	_server:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_servernode:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_ipx	DD	01H DUP (?)
_clientaddress DB 0210H DUP (?)
_nodeconnected DD 021H DUP (?)
_banned	DB	0640H DUP (?)
_bannedmask DB	064H DUP (?)
_shunned DB	0640H DUP (?)
_shunnedmask DB	064H DUP (?)
_numshun DD	01H DUP (?)
_numbans DD	01H DUP (?)
_SOCK_bannednode DD 021H DUP (?)
_init_tcp_driver DD 01H DUP (?)
?s@?1??SOCK_AddrToStr@@9@9 DB 040H DUP (?)		; `SOCK_AddrToStr'::`2'::s
?s@?1??SOCK_GetBanMask@@9@9 DB 010H DUP (?)		; `SOCK_GetBanMask'::`2'::s
_SOCK_cmpaddr DD 01H DUP (?)
_set	DB	0104H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@FNIHICEM@connect?5any?6@
CONST	SEGMENT
??_C@_0N@FNIHICEM@connect?5any?6@ DB 'connect any', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBJIFMOJ@?$CC?6@
CONST	SEGMENT
??_C@_02MBJIFMOJ@?$CC?6@ DB '"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EGJOEHMB@connect?5?$CC@
CONST	SEGMENT
??_C@_09EGJOEHMB@connect?5?$CC@ DB 'connect "', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FABEHMEN@?9connect@
CONST	SEGMENT
??_C@_08FABEHMEN@?9connect@ DB '-connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODEEFNBO@?9server@
CONST	SEGMENT
??_C@_07ODEEFNBO@?9server@ DB '-server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMJCHDDA@?9udpport@
CONST	SEGMENT
??_C@_08HMJCHDDA@?9udpport@ DB '-udpport', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFLFMAHA@?9ipx@
CONST	SEGMENT
??_C@_04PFLFMAHA@?9ipx@ DB '-ipx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OHGMBHC@Resolved?5?$CFs?6@
CONST	SEGMENT
??_C@_0N@OHGMBHC@Resolved?5?$CFs?6@ DB 'Resolved %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNBDJGGF@?$CFs?5unknown?6@
CONST	SEGMENT
??_C@_0M@LNBDJGGF@?$CFs?5unknown?6@ DB '%s unknown', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NIMOHCFP@Resolving?5?$CFs?6@
CONST	SEGMENT
??_C@_0O@NIMOHCFP@Resolving?5?$CFs?6@ DB 'Resolving %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HDCGPMAE@Creating?5new?5node?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@HDCGPMAE@Creating?5new?5node?3?5?$CFs?6@ DB 'Creating new node:'
	DB	' %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKFCCFFM@shut?5down?6@
CONST	SEGMENT
??_C@_0L@KKFCCFFM@shut?5down?6@ DB 'shut down', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OAMGEJHN@I_ShutdownTcpDriver?3?5@
CONST	SEGMENT
??_C@_0BG@OAMGEJHN@I_ShutdownTcpDriver?3?5@ DB 'I_ShutdownTcpDriver: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLEHEDME@WinSock?5System?5Status?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@KLEHEDME@WinSock?5System?5Status?3?5?$CFs?6@ DB 'WinSock System'
	DB	' Status: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IEOEOFPL@WinSock?5description?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BJ@IEOEOFPL@WinSock?5description?3?5?$CFs?6@ DB 'WinSock descripti'
	DB	'on: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JOMAOFEJ@No?5WinSock?$CITCP?1IP?$CJ?51?41?5driver?5d@
CONST	SEGMENT
??_C@_0CH@JOMAOFEJ@No?5WinSock?$CITCP?1IP?$CJ?51?41?5driver?5d@ DB 'No Wi'
	DB	'nSock(TCP/IP) 1.1 driver detected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GMNDDBHJ@WinSock?$CITCP?1IP?$CJ?5error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@GMNDDBHJ@WinSock?$CITCP?1IP?$CJ?5error?3?5?$CFs?6@ DB 'WinSock('
	DB	'TCP/IP) error: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GHDHPEFL@Error?5code?5?$CFu@
CONST	SEGMENT
??_C@_0O@GHDHPEFL@Error?5code?5?$CFu@ DB 'Error code %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@BFHCDGFI@WTF?$DP?5The?5WSAData?5is?5not?5a?5valid@
CONST	SEGMENT
??_C@_0EJ@BFHCDGFI@WTF?$DP?5The?5WSAData?5is?5not?5a?5valid@ DB 'WTF? The'
	DB	' WSAData is not a valid pointer? What kind of setup do you ha'
	DB	've?', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@MOJFEIAD@Limit?5on?5the?5number?5of?5tasks?5su@
CONST	SEGMENT
??_C@_0FO@MOJFEIAD@Limit?5on?5the?5number?5of?5tasks?5su@ DB 'Limit on th'
	DB	'e number of tasks supported by the Windows Sockets implementa'
	DB	'tion has been reached', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LGHIKHKH@A?5blocking?5Windows?5Sockets?51?41?5@
CONST	SEGMENT
??_C@_0DI@LGHIKHKH@A?5blocking?5Windows?5Sockets?51?41?5@ DB 'A blocking '
	DB	'Windows Sockets 1.1 operation is in progress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@JLCNGLKD@The?5underlying?5network?5subsyste@
CONST	SEGMENT
??_C@_0EI@JLCNGLKD@The?5underlying?5network?5subsyste@ DB 'The underlying'
	DB	' network subsystem is not ready for network communication', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@JDIAMALP@Can?8t?5set?5receive?5buffer?5length@
CONST	SEGMENT
??_C@_0ED@JDIAMALP@Can?8t?5set?5receive?5buffer?5length@ DB 'Can''t set r'
	DB	'eceive buffer length to 64k, file transfer will be bad', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DJOJGKAN@Network?5system?5receive?5buffer?5s@
CONST	SEGMENT
??_C@_0CM@DJOJGKAN@Network?5system?5receive?5buffer?5s@ DB 'Network syste'
	DB	'm receive buffer set to: %dKb', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IEIIBCNK@Network?5system?5receive?5buffer?3?5@
CONST	SEGMENT
??_C@_0CF@IEIIBCNK@Network?5system?5receive?5buffer?3?5@ DB 'Network syst'
	DB	'em receive buffer: %dKb', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLNCIJCH@IPX_Bind?5error?5?$CD?$CFu?3?5?$CFs@
CONST	SEGMENT
??_C@_0BH@FLNCIJCH@IPX_Bind?5error?5?$CD?$CFu?3?5?$CFs@ DB 'IPX_Bind erro'
	DB	'r #%u: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BFKFFGLF@IPX_socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@
CONST	SEGMENT
??_C@_0CO@BFKFFGLF@IPX_socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@ DB 'IPX_s'
	DB	'ocket error #%u: Can''t create socket: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EKKIJAJA@Network?5system?5buffer?5set?5to?3?5?$CF@
CONST	SEGMENT
??_C@_0CE@EKKIJAJA@Network?5system?5buffer?5set?5to?3?5?$CF@ DB 'Network '
	DB	'system buffer set to: %dKb', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CCHJDBAG@Can?8t?5set?5buffer?5length?5to?564k?0@
CONST	SEGMENT
??_C@_0DL@CCHJDBAG@Can?8t?5set?5buffer?5length?5to?564k?0@ DB 'Can''t set'
	DB	' buffer length to 64k, file transfer will be bad', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JEENIIKP@Network?5system?5buffer?3?5?$CFdKb?6@
CONST	SEGMENT
??_C@_0BN@JEENIIKP@Network?5system?5buffer?3?5?$CFdKb?6@ DB 'Network syst'
	DB	'em buffer: %dKb', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@MDCBFNLH@UDP_Socket?5error?4?5Could?5not?5set@
CONST	SEGMENT
??_C@_0DK@MDCBFNLH@UDP_Socket?5error?4?5Could?5not?5set@ DB 'UDP_Socket e'
	DB	'rror. Could not set socket to allow broadcast', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CKLNDCNP@UDP_Socket?5error?4?5Could?5not?5set@
CONST	SEGMENT
??_C@_0DM@CKLNDCNP@UDP_Socket?5error?4?5Could?5not?5set@ DB 'UDP_Socket e'
	DB	'rror. Could not set socket to non blocking mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HHIAFBGK@UDP_Socket?5error?5?$CD?$CFu?3?5?$CFs@
CONST	SEGMENT
??_C@_0BJ@HHIAFBGK@UDP_Socket?5error?5?$CD?$CFu?3?5?$CFs@ DB 'UDP_Socket '
	DB	'error #%u: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0NF@JBPHABIG@UDP_Socket?5error?3?5The?5address?5a@
CONST	SEGMENT
??_C@_0NF@JBPHABIG@UDP_Socket?5error?3?5The?5address?5a@ DB 'UDP_Socket e'
	DB	'rror: The address and port SRB2 had attempted to bind to is a'
	DB	'lready in use.', 0aH, 0aH, 'This isn''t a normal error, and p'
	DB	'robably indicates that something network-related', 0aH, 'on y'
	DB	'our computer is configured improperly.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FNLNHHNO@syntax?3?5?9clientport?5?$DMportnum?$DO@
CONST	SEGMENT
??_C@_0BO@FNLNHHNO@syntax?3?5?9clientport?5?$DMportnum?$DO@ DB 'syntax: -'
	DB	'clientport <portnum>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFBJBBFI@?9clientport@
CONST	SEGMENT
??_C@_0M@KFBJBBFI@?9clientport@ DB '-clientport', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DCCLGMFC@syntax?3?5?9bindaddr?5?$DMip?9address?$DO@
CONST	SEGMENT
??_C@_0BP@DCCLGMFC@syntax?3?5?9bindaddr?5?$DMip?9address?$DO@ DB 'syntax:'
	DB	' -bindaddr <ip-address>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBMKDBIO@?9bindaddr@
CONST	SEGMENT
??_C@_09BBMKDBIO@?9bindaddr@ DB '-bindaddr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JOFKFBKG@UDP_Socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@
CONST	SEGMENT
??_C@_0CO@JOFKFBKG@UDP_Socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@ DB 'UDP_S'
	DB	'ocket error #%u: Can''t create socket: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FLBLKNHL@Free?5node?5?$CFd?5?$CI?$CFs?$CJ?6@
CONST	SEGMENT
??_C@_0BD@FLBLKNHL@Free?5node?5?$CFd?5?$CI?$CFs?$CJ?6@ DB 'Free node %d ('
	DB	'%s)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BHJCIMJC@SOCK_Send?0?5error?5sending?5to?5nod@
CONST	SEGMENT
??_C@_0DB@BHJCIMJC@SOCK_Send?0?5error?5sending?5to?5nod@ DB 'SOCK_Send, e'
	DB	'rror sending to node %d (%s) #%u: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MFMCOFFD@New?5node?5detected?3?5No?5more?5free@
CONST	SEGMENT
??_C@_0CH@MFMCOFFD@New?5node?5detected?3?5No?5more?5free@ DB 'New node de'
	DB	'tected: No more free slots', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LDLKKAOF@This?5dude?5has?5been?5banned?6@
CONST	SEGMENT
??_C@_0BL@LDLKKAOF@This?5dude?5has?5been?5banned?6@ DB 'This dude has bee'
	DB	'n banned', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LHJLLFLG@New?5node?5detected?3?5node?3?$CFd?5addr@
CONST	SEGMENT
??_C@_0CH@LHJLLFLG@New?5node?5detected?3?5node?3?$CFd?5addr@ DB 'New node'
	DB	' detected: node:%d address:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@JLFOCFNG@SOCK_Get?5error?5?$CD?$CFu?3?5?$CFs?6?6?$CIDisabl@
CONST	SEGMENT
??_C@_0GG@JLFOCFNG@SOCK_Get?5error?5?$CD?$CFu?3?5?$CFs?6?6?$CIDisabl@ DB 'S'
	DB	'OCK_Get error #%u: %s', 0aH, 0aH, '(Disabling any firewalls a'
	DB	'nd/or rebooting your computer may fix this problem)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KDNCGLM@Connection?5reset?5?$CIlikely?5that?5t@
CONST	SEGMENT
??_C@_0DJ@KDNCGLM@Connection?5reset?5?$CIlikely?5that?5t@ DB 'Connection '
	DB	'reset (likely that the server isn''t running)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJDNGLKJ@self@
CONST	SEGMENT
??_C@_04PJDNGLKJ@self@ DB 'self', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGOCBNGP@Unknown?5type@
CONST	SEGMENT
??_C@_0N@DGOCBNGP@Unknown?5type@ DB 'Unknown type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JPPIFNFE@?$CF02x?$CF02x?$CF02x?$CF02x?4?$CF02x?$CF02x?$CF02x?$CF0@
CONST	SEGMENT
??_C@_0CN@JPPIFNFE@?$CF02x?$CF02x?$CF02x?$CF02x?4?$CF02x?$CF02x?$CF02x?$CF0@ DB '%'
	DB	'02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HODKBCIO@?3?$CFd@
CONST	SEGMENT
??_C@_03HODKBCIO@?3?$CFd@ DB ':%d', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
	ORG $+2
_mysocket DD	0ffffffffH
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0229H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0370H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0318H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0192H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0266H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_ClearBans
_TEXT	SEGMENT
_SOCK_ClearBans PROC					; COMDAT

; 1190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1191 : 	numbans = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numbans, 0

; 1192 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_SOCK_ClearBans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_SetBanAddress
_TEXT	SEGMENT
_address$ = 8						; size = 4
_mask$ = 12						; size = 4
_SOCK_SetBanAddress PROC				; COMDAT

; 1157 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1158 : #ifdef NONET
; 1159 : 	(void)address;
; 1160 : 	(void)mask;
; 1161 : 	return false;
; 1162 : #else
; 1163 : 	if (numbans == MAXBANS || !address)

  00009	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _numbans, 100	; 00000064H
  00010	74 06		 je	 SHORT $LN3@SOCK_SetBa
  00012	83 7d 08 00	 cmp	 DWORD PTR _address$[ebp], 0
  00016	75 07		 jne	 SHORT $LN2@SOCK_SetBa
$LN3@SOCK_SetBa:

; 1164 : 		return false;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 b9 00 00 00	 jmp	 $LN1@SOCK_SetBa
$LN2@SOCK_SetBa:

; 1165 : 
; 1166 : 	banned[numbans].ip.sin_addr.s_addr = inet_addr(address);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _address$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _inet_addr@4
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numbans
  0002e	c1 e1 04	 shl	 ecx, 4
  00031	89 81 04 00 00
	00		 mov	 DWORD PTR _banned[ecx+4], eax

; 1167 : 
; 1168 : 	if (banned[numbans].ip.sin_addr.s_addr == htonl(INADDR_NONE))

  00037	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _numbans
  0003d	c1 e6 04	 shl	 esi, 4
  00040	6a ff		 push	 -1
  00042	e8 00 00 00 00	 call	 _htonl@4
  00047	39 86 04 00 00
	00		 cmp	 DWORD PTR _banned[esi+4], eax
  0004d	75 09		 jne	 SHORT $LN4@SOCK_SetBa

; 1169 : 		return false;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 82 00 00 00	 jmp	 $LN1@SOCK_SetBa
  00056	eb 11		 jmp	 SHORT $LN5@SOCK_SetBa
$LN4@SOCK_SetBa:

; 1170 : 	else
; 1171 : 		banned[numbans].ip.sin_port = 0;

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  0005d	c1 e0 04	 shl	 eax, 4
  00060	33 c9		 xor	 ecx, ecx
  00062	66 89 88 02 00
	00 00		 mov	 WORD PTR _banned[eax+2], cx
$LN5@SOCK_SetBa:

; 1172 : 
; 1173 : 	banned[numbans].sa_family = AF_INET;

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  0006e	c1 e0 04	 shl	 eax, 4
  00071	b9 02 00 00 00	 mov	 ecx, 2
  00076	66 89 88 00 00
	00 00		 mov	 WORD PTR _banned[eax], cx

; 1174 : 
; 1175 : 	if (mask)

  0007d	83 7d 0c 00	 cmp	 DWORD PTR _mask$[ebp], 0
  00081	74 1a		 je	 SHORT $LN6@SOCK_SetBa

; 1176 : 		bannedmask[numbans] = (UINT8)atoi(mask);

  00083	8b 45 0c	 mov	 eax, DWORD PTR _mask$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _atoi
  0008c	83 c4 04	 add	 esp, 4
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numbans
  00095	88 81 00 00 00
	00		 mov	 BYTE PTR _bannedmask[ecx], al
  0009b	eb 0c		 jmp	 SHORT $LN7@SOCK_SetBa
$LN6@SOCK_SetBa:

; 1177 : 	else
; 1178 : 		bannedmask[numbans] = 32;

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  000a2	c6 80 00 00 00
	00 20		 mov	 BYTE PTR _bannedmask[eax], 32 ; 00000020H
$LN7@SOCK_SetBa:

; 1179 : 
; 1180 : 	if (bannedmask[numbans] > 32)

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  000ae	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _bannedmask[eax]
  000b5	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000b8	7e 0c		 jle	 SHORT $LN8@SOCK_SetBa

; 1181 : 		bannedmask[numbans] = 32;

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  000bf	c6 80 00 00 00
	00 20		 mov	 BYTE PTR _bannedmask[eax], 32 ; 00000020H
$LN8@SOCK_SetBa:

; 1182 : 
; 1183 : 	numbans++;

  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  000cb	83 c0 01	 add	 eax, 1
  000ce	a3 00 00 00 00	 mov	 DWORD PTR _numbans, eax

; 1184 : 
; 1185 : 	return true;

  000d3	b8 01 00 00 00	 mov	 eax, 1
$LN1@SOCK_SetBa:

; 1186 : #endif
; 1187 : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_SOCK_SetBanAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_Shun
_TEXT	SEGMENT
_node$ = 8						; size = 4
_SOCK_Shun PROC						; COMDAT

; 1138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1139 : 	if (node > MAXNETNODES)

  00009	83 7d 08 20	 cmp	 DWORD PTR _node$[ebp], 32 ; 00000020H
  0000d	7e 04		 jle	 SHORT $LN2@SOCK_Shun

; 1140 : 		return false;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 77		 jmp	 SHORT $LN1@SOCK_Shun
$LN2@SOCK_Shun:

; 1141 : #ifdef NONET
; 1142 : 	return false;
; 1143 : #else
; 1144 : 	if (numshun == MAXBANS)

  00013	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _numshun, 100	; 00000064H
  0001a	75 04		 jne	 SHORT $LN3@SOCK_Shun

; 1145 : 		return false;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 6a		 jmp	 SHORT $LN1@SOCK_Shun
$LN3@SOCK_Shun:

; 1146 : 
; 1147 : 	shunnedmask[numshun] = 32;

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _numshun
  00025	c6 80 00 00 00
	00 20		 mov	 BYTE PTR _shunnedmask[eax], 32 ; 00000020H

; 1148 : 	M_Memcpy(&shunned[numshun], &clientaddress[node], sizeof (mysockaddr_t));

  0002c	6a 10		 push	 16			; 00000010H
  0002e	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00031	c1 e0 04	 shl	 eax, 4
  00034	05 00 00 00 00	 add	 eax, OFFSET _clientaddress
  00039	50		 push	 eax
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numshun
  00040	c1 e1 04	 shl	 ecx, 4
  00043	81 c1 00 00 00
	00		 add	 ecx, OFFSET _shunned
  00049	51		 push	 ecx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1149 : 	if (shunned[numshun].sa_family == AF_INET)

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _numshun
  00058	c1 e0 04	 shl	 eax, 4
  0005b	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _shunned[eax]
  00062	83 f9 02	 cmp	 ecx, 2
  00065	75 11		 jne	 SHORT $LN4@SOCK_Shun

; 1150 : 		shunned[numshun].ip.sin_port = 0;

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _numshun
  0006c	c1 e0 04	 shl	 eax, 4
  0006f	33 c9		 xor	 ecx, ecx
  00071	66 89 88 02 00
	00 00		 mov	 WORD PTR _shunned[eax+2], cx
$LN4@SOCK_Shun:

; 1151 : 	numshun++;

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _numshun
  0007d	83 c0 01	 add	 eax, 1
  00080	a3 00 00 00 00	 mov	 DWORD PTR _numshun, eax

; 1152 : 	return true;

  00085	b8 01 00 00 00	 mov	 eax, 1
$LN1@SOCK_Shun:

; 1153 : #endif
; 1154 : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_SOCK_Shun ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_Ban
_TEXT	SEGMENT
_node$ = 8						; size = 4
_SOCK_Ban PROC						; COMDAT

; 1120 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1121 : #ifdef NONET
; 1122 : 	(void)node;
; 1123 : 	return false;
; 1124 : #else
; 1125 : 	if (numbans == MAXBANS)

  00009	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _numbans, 100	; 00000064H
  00010	75 04		 jne	 SHORT $LN2@SOCK_Ban

; 1126 : 		return false;

  00012	33 c0		 xor	 eax, eax
  00014	eb 6a		 jmp	 SHORT $LN1@SOCK_Ban
$LN2@SOCK_Ban:

; 1127 : 
; 1128 : 	bannedmask[numbans] = 32;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  0001b	c6 80 00 00 00
	00 20		 mov	 BYTE PTR _bannedmask[eax], 32 ; 00000020H

; 1129 : 	M_Memcpy(&banned[numbans], &clientaddress[node], sizeof (mysockaddr_t));

  00022	6a 10		 push	 16			; 00000010H
  00024	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00027	c1 e0 04	 shl	 eax, 4
  0002a	05 00 00 00 00	 add	 eax, OFFSET _clientaddress
  0002f	50		 push	 eax
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numbans
  00036	c1 e1 04	 shl	 ecx, 4
  00039	81 c1 00 00 00
	00		 add	 ecx, OFFSET _banned
  0003f	51		 push	 ecx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1130 : 	if (banned[numbans].sa_family == AF_INET)

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  0004e	c1 e0 04	 shl	 eax, 4
  00051	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _banned[eax]
  00058	83 f9 02	 cmp	 ecx, 2
  0005b	75 11		 jne	 SHORT $LN3@SOCK_Ban

; 1131 : 		banned[numbans].ip.sin_port = 0;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  00062	c1 e0 04	 shl	 eax, 4
  00065	33 c9		 xor	 ecx, ecx
  00067	66 89 88 02 00
	00 00		 mov	 WORD PTR _banned[eax+2], cx
$LN3@SOCK_Ban:

; 1132 : 	numbans++;

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _numbans
  00073	83 c0 01	 add	 eax, 1
  00076	a3 00 00 00 00	 mov	 DWORD PTR _numbans, eax

; 1133 : 	return true;

  0007b	b8 01 00 00 00	 mov	 eax, 1
$LN1@SOCK_Ban:

; 1134 : #endif
; 1135 : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_SOCK_Ban ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_OpenSocket
_TEXT	SEGMENT
tv85 = -72						; size = 4
_i$ = -4						; size = 4
_SOCK_OpenSocket PROC					; COMDAT

; 1077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1078 : #ifndef NONET
; 1079 : 	size_t i;
; 1080 : 
; 1081 : 	memset(clientaddress, 0, sizeof (clientaddress));

  00009	68 10 02 00 00	 push	 528			; 00000210H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _clientaddress
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1082 : 
; 1083 : 	for (i = 0; i < MAXNETNODES; i++)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@SOCK_OpenS
$LN2@SOCK_OpenS:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@SOCK_OpenS:
  0002f	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00033	73 10		 jae	 SHORT $LN3@SOCK_OpenS

; 1084 : 		nodeconnected[i] = false;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00038	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _nodeconnected[eax*4], 0
  00043	eb e1		 jmp	 SHORT $LN2@SOCK_OpenS
$LN3@SOCK_OpenS:

; 1085 : 
; 1086 : 	nodeconnected[0] = true; // always connected to self

  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	6b c8 00	 imul	 ecx, eax, 0
  0004d	c7 81 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nodeconnected[ecx], 1

; 1087 : 	nodeconnected[BROADCASTADDR] = true;

  00057	b8 04 00 00 00	 mov	 eax, 4
  0005c	c1 e0 05	 shl	 eax, 5
  0005f	c7 80 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nodeconnected[eax], 1

; 1088 : 	I_NetSend = SOCK_Send;

  00069	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetSend, OFFSET _SOCK_Send

; 1089 : 	I_NetGet = SOCK_Get;

  00073	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetGet, OFFSET _SOCK_Get

; 1090 : 	I_NetCloseSocket = SOCK_CloseSocket;

  0007d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCloseSocket, OFFSET _SOCK_CloseSocket

; 1091 : 	I_NetFreeNodenum = SOCK_FreeNodenum;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetFreeNodenum, OFFSET _SOCK_FreeNodenum

; 1092 : 	I_NetMakeNode = SOCK_NetMakeNode;

  00091	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetMakeNode, OFFSET _SOCK_NetMakeNode

; 1093 : 
; 1094 : #ifdef SELECTTEST
; 1095 : 	// seem like not work with libsocket : (
; 1096 : 	I_NetCanSend = SOCK_CanSend;

  0009b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCanSend, OFFSET _SOCK_CanSend

; 1097 : 	I_NetCanGet = SOCK_CanGet;

  000a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCanGet, OFFSET _SOCK_CanGet

; 1098 : #endif
; 1099 : 
; 1100 : 	// build the socket but close it first
; 1101 : 	SOCK_CloseSocket();

  000af	e8 00 00 00 00	 call	 _SOCK_CloseSocket
  000b4	90		 npad	 1

; 1102 : #ifdef USEIPX
; 1103 : 	if (ipx)

  000b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ipx, 0
  000bc	74 21		 je	 SHORT $LN8@SOCK_OpenS

; 1104 : 	{
; 1105 : 		mysocket = IPX_Socket();

  000be	e8 00 00 00 00	 call	 _IPX_Socket
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _mysocket, eax

; 1106 : 		net_bandwidth = 800000;

  000c8	c7 05 00 00 00
	00 00 35 0c 00	 mov	 DWORD PTR _net_bandwidth, 800000 ; 000c3500H

; 1107 : 		hardware_MAXPACKETLENGTH = MAXPACKETLENGTH;

  000d2	b8 aa 05 00 00	 mov	 eax, 1450		; 000005aaH
  000d7	66 a3 00 00 00
	00		 mov	 WORD PTR _hardware_MAXPACKETLENGTH, ax

; 1108 : 	}

  000dd	eb 0a		 jmp	 SHORT $LN9@SOCK_OpenS
$LN8@SOCK_OpenS:

; 1109 : 	else
; 1110 : #endif // USEIPX
; 1111 : 		mysocket = UDP_Socket();

  000df	e8 00 00 00 00	 call	 _UDP_Socket
  000e4	a3 00 00 00 00	 mov	 DWORD PTR _mysocket, eax
$LN9@SOCK_OpenS:

; 1112 : 	// for select
; 1113 : 	FD_ZERO(&set);

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _set, 0
$LN7@SOCK_OpenS:

; 1114 : 	FD_SET(mysocket,&set);

  000f3	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR _set, 64	; 00000040H
  000fa	73 21		 jae	 SHORT $LN10@SOCK_OpenS
  000fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _set
  00101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mysocket
  00107	89 0c 85 04 00
	00 00		 mov	 DWORD PTR _set[eax*4+4], ecx
  0010e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _set
  00114	83 c2 01	 add	 edx, 1
  00117	89 15 00 00 00
	00		 mov	 DWORD PTR _set, edx
$LN10@SOCK_OpenS:
  0011d	33 c0		 xor	 eax, eax
  0011f	75 d2		 jne	 SHORT $LN7@SOCK_OpenS

; 1115 : #endif
; 1116 : 	return (boolean)(mysocket != (SOCKET_TYPE)ERRSOCKET && mysocket != BADSOCKET);

  00121	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mysocket, -1
  00128	74 12		 je	 SHORT $LN12@SOCK_OpenS
  0012a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mysocket, -1
  00131	74 09		 je	 SHORT $LN12@SOCK_OpenS
  00133	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
  0013a	eb 07		 jmp	 SHORT $LN13@SOCK_OpenS
$LN12@SOCK_OpenS:
  0013c	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
$LN13@SOCK_OpenS:
  00143	8b 45 b8	 mov	 eax, DWORD PTR tv85[ebp]

; 1117 : }

  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
_SOCK_OpenSocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_NetMakeNode
_TEXT	SEGMENT
_t$1 = -24						; size = 4
_hostentry$2 = -20					; size = 4
_portnum$ = -16						; size = 2
_portchar$ = -12					; size = 4
_localhostname$ = -8					; size = 4
_newnode$ = -1						; size = 1
_hostname$ = 8						; size = 4
_SOCK_NetMakeNode PROC					; COMDAT

; 1010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1011 : 	SINT8 newnode;
; 1012 : 	char *localhostname = strdup(hostname);

  00009	8b 45 08	 mov	 eax, DWORD PTR _hostname$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strdup
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 f8	 mov	 DWORD PTR _localhostname$[ebp], eax

; 1013 : 	char *portchar;
; 1014 : 	UINT16 portnum = htons(sock_port);

  00018	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _sock_port
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _htons@4
  00025	66 89 45 f0	 mov	 WORD PTR _portnum$[ebp], ax

; 1015 : 
; 1016 : 	DEBFILE(va("Creating new node: %s\n", hostname));

  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00030	74 2e		 je	 SHORT $LN4@SOCK_NetMa
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _hostname$[ebp]
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HDCGPMAE@Creating?5new?5node?3?5?$CFs?6@
  00041	e8 00 00 00 00	 call	 _va
  00046	83 c4 08	 add	 esp, 8
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _fputs
  0004f	83 c4 08	 add	 esp, 8
  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _fflush
  0005d	83 c4 04	 add	 esp, 4
$LN4@SOCK_NetMa:

; 1017 : 
; 1018 : 	// retrieve portnum from address!
; 1019 : 	strtok(localhostname, ":");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3@
  00065	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _strtok
  0006e	83 c4 08	 add	 esp, 8

; 1020 : 	portchar = strtok(NULL, ":");

  00071	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3@
  00076	6a 00		 push	 0
  00078	e8 00 00 00 00	 call	 _strtok
  0007d	83 c4 08	 add	 esp, 8
  00080	89 45 f4	 mov	 DWORD PTR _portchar$[ebp], eax

; 1021 : 	if (portchar)

  00083	83 7d f4 00	 cmp	 DWORD PTR _portchar$[ebp], 0
  00087	74 16		 je	 SHORT $LN5@SOCK_NetMa

; 1022 : 		portnum = htons((UINT16)atoi(portchar));

  00089	8b 45 f4	 mov	 eax, DWORD PTR _portchar$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _atoi
  00092	83 c4 04	 add	 esp, 4
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _htons@4
  0009b	66 89 45 f0	 mov	 WORD PTR _portnum$[ebp], ax
$LN5@SOCK_NetMa:

; 1023 : 	free(localhostname);

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _free
  000a8	83 c4 04	 add	 esp, 4

; 1024 : 
; 1025 : 	// server address only in ip
; 1026 : #ifdef USEIPX
; 1027 : 	if (ipx) // ipx only

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ipx, 0
  000b2	74 0c		 je	 SHORT $LN6@SOCK_NetMa

; 1028 : 		return BROADCASTADDR;

  000b4	b0 20		 mov	 al, 32			; 00000020H
  000b6	e9 5b 01 00 00	 jmp	 $LN7@SOCK_NetMa
  000bb	e9 56 01 00 00	 jmp	 $LN7@SOCK_NetMa
$LN6@SOCK_NetMa:

; 1029 : 	else // tcp/ip
; 1030 : #endif
; 1031 : 	{
; 1032 : 		struct hostent *hostentry; // host information entry
; 1033 : 		char *t;
; 1034 : 
; 1035 : 		// remove the port in the hostname as we've it already
; 1036 : 		t = localhostname = strdup(hostname);

  000c0	8b 45 08	 mov	 eax, DWORD PTR _hostname$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _strdup
  000c9	83 c4 04	 add	 esp, 4
  000cc	89 45 f8	 mov	 DWORD PTR _localhostname$[ebp], eax
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _localhostname$[ebp]
  000d2	89 4d e8	 mov	 DWORD PTR _t$1[ebp], ecx
$LN2@SOCK_NetMa:

; 1037 : 		while ((*t != ':') && (*t != '\0'))

  000d5	8b 45 e8	 mov	 eax, DWORD PTR _t$1[ebp]
  000d8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000db	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  000de	74 15		 je	 SHORT $LN3@SOCK_NetMa
  000e0	8b 45 e8	 mov	 eax, DWORD PTR _t$1[ebp]
  000e3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000e6	85 c9		 test	 ecx, ecx
  000e8	74 0b		 je	 SHORT $LN3@SOCK_NetMa

; 1038 : 			t++;

  000ea	8b 45 e8	 mov	 eax, DWORD PTR _t$1[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 45 e8	 mov	 DWORD PTR _t$1[ebp], eax
  000f3	eb e0		 jmp	 SHORT $LN2@SOCK_NetMa
$LN3@SOCK_NetMa:

; 1039 : 		*t = '\0';

  000f5	8b 45 e8	 mov	 eax, DWORD PTR _t$1[ebp]
  000f8	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1040 : 
; 1041 : 		cleanupnodes();

  000fb	e8 00 00 00 00	 call	 _cleanupnodes
  00100	90		 npad	 1

; 1042 : 		newnode = getfreenode();

  00101	e8 00 00 00 00	 call	 _getfreenode
  00106	88 45 ff	 mov	 BYTE PTR _newnode$[ebp], al

; 1043 : 		if (newnode == -1)

  00109	0f be 45 ff	 movsx	 eax, BYTE PTR _newnode$[ebp]
  0010d	83 f8 ff	 cmp	 eax, -1
  00110	75 13		 jne	 SHORT $LN8@SOCK_NetMa

; 1044 : 		{
; 1045 : 			free(localhostname);

  00112	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _free
  0011b	83 c4 04	 add	 esp, 4

; 1046 : 			return -1;

  0011e	0c ff		 or	 al, -1
  00120	e9 f1 00 00 00	 jmp	 $LN7@SOCK_NetMa
$LN8@SOCK_NetMa:

; 1047 : 		}
; 1048 : 		// find ip of the server
; 1049 : 		clientaddress[newnode].sa_family = AF_INET;

  00125	0f be 45 ff	 movsx	 eax, BYTE PTR _newnode$[ebp]
  00129	c1 e0 04	 shl	 eax, 4
  0012c	b9 02 00 00 00	 mov	 ecx, 2
  00131	66 89 88 00 00
	00 00		 mov	 WORD PTR _clientaddress[eax], cx

; 1050 : 		clientaddress[newnode].ip.sin_port = portnum;

  00138	0f be 45 ff	 movsx	 eax, BYTE PTR _newnode$[ebp]
  0013c	c1 e0 04	 shl	 eax, 4
  0013f	66 8b 4d f0	 mov	 cx, WORD PTR _portnum$[ebp]
  00143	66 89 88 02 00
	00 00		 mov	 WORD PTR _clientaddress[eax+2], cx

; 1051 : 		clientaddress[newnode].ip.sin_addr.s_addr = inet_addr(localhostname);

  0014a	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _inet_addr@4
  00153	0f be 4d ff	 movsx	 ecx, BYTE PTR _newnode$[ebp]
  00157	c1 e1 04	 shl	 ecx, 4
  0015a	89 81 04 00 00
	00		 mov	 DWORD PTR _clientaddress[ecx+4], eax

; 1052 : 
; 1053 : 		if (clientaddress[newnode].ip.sin_addr.s_addr == htonl(INADDR_NONE)) // not a ip ask to the dns

  00160	0f be 75 ff	 movsx	 esi, BYTE PTR _newnode$[ebp]
  00164	c1 e6 04	 shl	 esi, 4
  00167	6a ff		 push	 -1
  00169	e8 00 00 00 00	 call	 _htonl@4
  0016e	39 86 04 00 00
	00		 cmp	 DWORD PTR _clientaddress[esi+4], eax
  00174	0f 85 8d 00 00
	00		 jne	 $LN9@SOCK_NetMa

; 1054 : 		{
; 1055 : 			CONS_Printf("Resolving %s\n",localhostname);

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  0017d	50		 push	 eax
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NIMOHCFP@Resolving?5?$CFs?6@
  00183	e8 00 00 00 00	 call	 _CONS_Printf
  00188	83 c4 08	 add	 esp, 8

; 1056 : 			hostentry = gethostbyname(localhostname);

  0018b	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _gethostbyname@4
  00194	89 45 ec	 mov	 DWORD PTR _hostentry$2[ebp], eax

; 1057 : 			if (!hostentry)

  00197	83 7d ec 00	 cmp	 DWORD PTR _hostentry$2[ebp], 0
  0019b	75 2f		 jne	 SHORT $LN10@SOCK_NetMa

; 1058 : 			{
; 1059 : 				CONS_Printf("%s unknown\n", localhostname);

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  001a0	50		 push	 eax
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LNBDJGGF@?$CFs?5unknown?6@
  001a6	e8 00 00 00 00	 call	 _CONS_Printf
  001ab	83 c4 08	 add	 esp, 8

; 1060 : 				I_NetFreeNodenum(newnode);

  001ae	0f be 45 ff	 movsx	 eax, BYTE PTR _newnode$[ebp]
  001b2	50		 push	 eax
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetFreeNodenum
  001b9	83 c4 04	 add	 esp, 4

; 1061 : 				free(localhostname);

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _free
  001c5	83 c4 04	 add	 esp, 4

; 1062 : 				return -1;

  001c8	0c ff		 or	 al, -1
  001ca	eb 4a		 jmp	 SHORT $LN7@SOCK_NetMa
$LN10@SOCK_NetMa:

; 1063 : 			}
; 1064 : 			clientaddress[newnode].ip.sin_addr.s_addr = *((UINT32 *)hostentry->h_addr_list[0]);

  001cc	b8 04 00 00 00	 mov	 eax, 4
  001d1	6b c8 00	 imul	 ecx, eax, 0
  001d4	8b 55 ec	 mov	 edx, DWORD PTR _hostentry$2[ebp]
  001d7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001da	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  001dd	0f be 55 ff	 movsx	 edx, BYTE PTR _newnode$[ebp]
  001e1	c1 e2 04	 shl	 edx, 4
  001e4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e6	89 82 04 00 00
	00		 mov	 DWORD PTR _clientaddress[edx+4], eax

; 1065 : 
; 1066 : 			CONS_Printf("Resolved %s\n", SOCK_GetNodeAddress(newnode));

  001ec	0f be 45 ff	 movsx	 eax, BYTE PTR _newnode$[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 _SOCK_GetNodeAddress
  001f6	83 c4 04	 add	 esp, 4
  001f9	50		 push	 eax
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OHGMBHC@Resolved?5?$CFs?6@
  001ff	e8 00 00 00 00	 call	 _CONS_Printf
  00204	83 c4 08	 add	 esp, 8
$LN9@SOCK_NetMa:

; 1067 : 		}
; 1068 : 
; 1069 : 		free(localhostname);

  00207	8b 45 f8	 mov	 eax, DWORD PTR _localhostname$[ebp]
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 _free
  00210	83 c4 04	 add	 esp, 4

; 1070 : 
; 1071 : 		return newnode;

  00213	8a 45 ff	 mov	 al, BYTE PTR _newnode$[ebp]
$LN7@SOCK_NetMa:

; 1072 : 	}
; 1073 : }

  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
  00218	5b		 pop	 ebx
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
_SOCK_NetMakeNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_CloseSocket
_TEXT	SEGMENT
___i$1 = -4						; size = 4
_SOCK_CloseSocket PROC					; COMDAT

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 969  : 	if (mysocket != (SOCKET_TYPE)ERRSOCKET && mysocket != BADSOCKET)

  00009	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mysocket, -1
  00010	0f 84 85 00 00
	00		 je	 $LN10@SOCK_Close
  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _mysocket, -1
  0001d	74 7c		 je	 SHORT $LN10@SOCK_Close
$LN4@SOCK_Close:

; 970  : 	{
; 971  : // quick fix bug in libsocket 0.7.4 beta 4 under winsock 1.1 (win95)
; 972  : #if !defined (__DJGPP__) || defined (WATTCP)
; 973  : 		FD_CLR(mysocket, &set);

  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR ___i$1[ebp], 0
  00026	eb 09		 jmp	 SHORT $LN7@SOCK_Close
$LN5@SOCK_Close:
  00028	8b 45 fc	 mov	 eax, DWORD PTR ___i$1[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 fc	 mov	 DWORD PTR ___i$1[ebp], eax
$LN7@SOCK_Close:
  00031	8b 45 fc	 mov	 eax, DWORD PTR ___i$1[ebp]
  00034	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _set
  0003a	73 4f		 jae	 SHORT $LN6@SOCK_Close
  0003c	8b 45 fc	 mov	 eax, DWORD PTR ___i$1[ebp]
  0003f	8b 0c 85 04 00
	00 00		 mov	 ecx, DWORD PTR _set[eax*4+4]
  00046	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _mysocket
  0004c	75 3b		 jne	 SHORT $LN11@SOCK_Close
$LN8@SOCK_Close:
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR _set
  00053	83 e8 01	 sub	 eax, 1
  00056	39 45 fc	 cmp	 DWORD PTR ___i$1[ebp], eax
  00059	73 1f		 jae	 SHORT $LN9@SOCK_Close
  0005b	8b 45 fc	 mov	 eax, DWORD PTR ___i$1[ebp]
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR ___i$1[ebp]
  00061	8b 14 8d 08 00
	00 00		 mov	 edx, DWORD PTR _set[ecx*4+8]
  00068	89 14 85 04 00
	00 00		 mov	 DWORD PTR _set[eax*4+4], edx
  0006f	8b 45 fc	 mov	 eax, DWORD PTR ___i$1[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 fc	 mov	 DWORD PTR ___i$1[ebp], eax
  00078	eb d4		 jmp	 SHORT $LN8@SOCK_Close
$LN9@SOCK_Close:
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _set
  0007f	83 e8 01	 sub	 eax, 1
  00082	a3 00 00 00 00	 mov	 DWORD PTR _set, eax
  00087	eb 02		 jmp	 SHORT $LN6@SOCK_Close
$LN11@SOCK_Close:
  00089	eb 9d		 jmp	 SHORT $LN5@SOCK_Close
$LN6@SOCK_Close:
  0008b	33 c0		 xor	 eax, eax
  0008d	75 90		 jne	 SHORT $LN4@SOCK_Close

; 974  : 		close(mysocket);

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _mysocket
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _closesocket@4
  0009a	90		 npad	 1
$LN10@SOCK_Close:

; 975  : #endif
; 976  : 	}
; 977  : 	mysocket = BADSOCKET;

  0009b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _mysocket, -1

; 978  : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_SOCK_CloseSocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _IPX_Socket
_TEXT	SEGMENT
_j$ = -36						; size = 4
_i$ = -32						; size = 4
_trueval$ = -28						; size = 4
_address$ = -24						; size = 14
_s$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_IPX_Socket PROC					; COMDAT

; 776  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 777  : 	SOCKET_TYPE s = BADSOCKET;

  00013	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1

; 778  : 	SOCKADDR_IPX address;
; 779  : #ifdef WATTCP
; 780  : 	char trueval = true;
; 781  : #else
; 782  : 	unsigned long trueval = true;

  0001a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _trueval$[ebp], 1

; 783  : #endif
; 784  : 	int i;
; 785  : 	socklen_t j;
; 786  : 
; 787  : 	// allocate a socket
; 788  : 	s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);

  00021	68 e8 03 00 00	 push	 1000			; 000003e8H
  00026	6a 02		 push	 2
  00028	6a 06		 push	 6
  0002a	e8 00 00 00 00	 call	 _socket@12
  0002f	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 789  : 	if (s == (SOCKET_TYPE)ERRSOCKET || s == BADSOCKET)

  00032	83 7d f8 ff	 cmp	 DWORD PTR _s$[ebp], -1
  00036	74 06		 je	 SHORT $LN9@IPX_Socket
  00038	83 7d f8 ff	 cmp	 DWORD PTR _s$[ebp], -1
  0003c	75 22		 jne	 SHORT $LN8@IPX_Socket
$LN9@IPX_Socket:

; 790  : 		I_Error("IPX_socket error #%u: Can't create socket: %s", errno, strerror(errno));

  0003e	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _strerror
  00049	83 c4 04	 add	 esp, 4
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00052	50		 push	 eax
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BFKFFGLF@IPX_socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@
  00058	e8 00 00 00 00	 call	 _I_Error
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@IPX_Socket:

; 791  : 
; 792  : 	memset(&address, 0, sizeof (address));

  00060	6a 0e		 push	 14			; 0000000eH
  00062	6a 00		 push	 0
  00064	8d 45 e8	 lea	 eax, DWORD PTR _address$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _memset
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 793  : #if defined (__unix__) || defined(__APPLE__) || defined (UNIXCOMMON) && !defined (__CYGWIN__)
; 794  : 	address.sipx_family = AF_IPX;
; 795  : 	address.sipx_port = htons(sock_port);
; 796  : #else
; 797  : 	address.sa_family = AF_IPX;

  00070	b8 06 00 00 00	 mov	 eax, 6
  00075	66 89 45 e8	 mov	 WORD PTR _address$[ebp], ax

; 798  : 	address.sa_socket = htons(sock_port);

  00079	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _sock_port
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _htons@4
  00086	66 89 45 f4	 mov	 WORD PTR _address$[ebp+12], ax

; 799  : #endif // UNIXCOMMON
; 800  : 	if (bind(s, (void *)&address, sizeof (address)) == ERRSOCKET)

  0008a	6a 0e		 push	 14			; 0000000eH
  0008c	8d 45 e8	 lea	 eax, DWORD PTR _address$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _bind@12
  00099	83 f8 ff	 cmp	 eax, -1
  0009c	75 22		 jne	 SHORT $LN10@IPX_Socket

; 801  : 		I_Error("IPX_Bind error #%u: %s", errno, strerror(errno));

  0009e	e8 00 00 00 00	 call	 _WSAGetLastError@0
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _strerror
  000a9	83 c4 04	 add	 esp, 4
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _WSAGetLastError@0
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FLNCIJCH@IPX_Bind?5error?5?$CD?$CFu?3?5?$CFs@
  000b8	e8 00 00 00 00	 call	 _I_Error
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@IPX_Socket:

; 802  : 
; 803  : 	// make it non blocking
; 804  : 	ioctl(s, FIONBIO, &trueval);

  000c0	8d 45 e4	 lea	 eax, DWORD PTR _trueval$[ebp]
  000c3	50		 push	 eax
  000c4	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 _ioctlsocket@12
  000d2	90		 npad	 1

; 805  : 
; 806  : 	// make it broadcastable
; 807  : 	setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&trueval, sizeof (trueval));

  000d3	6a 04		 push	 4
  000d5	8d 45 e4	 lea	 eax, DWORD PTR _trueval$[ebp]
  000d8	50		 push	 eax
  000d9	6a 20		 push	 32			; 00000020H
  000db	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _setsockopt@20
  000e9	90		 npad	 1

; 808  : 
; 809  : 	// set receive buffer to 64Kb
; 810  : 	j = sizeof (i);

  000ea	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4

; 811  : 	getsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&i, &j);

  000f1	8d 45 dc	 lea	 eax, DWORD PTR _j$[ebp]
  000f4	50		 push	 eax
  000f5	8d 4d e0	 lea	 ecx, DWORD PTR _i$[ebp]
  000f8	51		 push	 ecx
  000f9	68 02 10 00 00	 push	 4098			; 00001002H
  000fe	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00103	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _getsockopt@20
  0010c	90		 npad	 1

; 812  : 	CONS_Printf("Network system receive buffer: %dKb\n",i>>10);

  0010d	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00110	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00113	50		 push	 eax
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IEIIBCNK@Network?5system?5receive?5buffer?3?5@
  00119	e8 00 00 00 00	 call	 _CONS_Printf
  0011e	83 c4 08	 add	 esp, 8

; 813  : 	if (i < 128<<10)

  00121	81 7d e0 00 00
	02 00		 cmp	 DWORD PTR _i$[ebp], 131072 ; 00020000H
  00128	7d 5b		 jge	 SHORT $LN13@IPX_Socket

; 814  : 	{
; 815  : 		i = 64<<10;

  0012a	c7 45 e0 00 00
	01 00		 mov	 DWORD PTR _i$[ebp], 65536 ; 00010000H

; 816  : 		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&i, sizeof (i)))

  00131	6a 04		 push	 4
  00133	8d 45 e0	 lea	 eax, DWORD PTR _i$[ebp]
  00136	50		 push	 eax
  00137	68 02 10 00 00	 push	 4098			; 00001002H
  0013c	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00141	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 _setsockopt@20
  0014a	85 c0		 test	 eax, eax
  0014c	74 23		 je	 SHORT $LN12@IPX_Socket

; 817  : 		{
; 818  : 			CONS_Printf("Network system receive buffer set to: %dKb\n",i>>10);

  0014e	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00151	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00154	50		 push	 eax
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DJOJGKAN@Network?5system?5receive?5buffer?5s@
  0015a	e8 00 00 00 00	 call	 _CONS_Printf
  0015f	83 c4 08	 add	 esp, 8

; 819  : 			CONS_Printf("Can't set receive buffer length to 64k, file transfer will be bad\n");

  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@JDIAMALP@Can?8t?5set?5receive?5buffer?5length@
  00167	e8 00 00 00 00	 call	 _CONS_Printf
  0016c	83 c4 04	 add	 esp, 4

; 820  : 		}

  0016f	eb 14		 jmp	 SHORT $LN13@IPX_Socket
$LN12@IPX_Socket:

; 821  : 		else
; 822  : 		{
; 823  : 			CONS_Printf("Network system receive buffer set to: %dKb\n",i>>10);

  00171	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00174	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00177	50		 push	 eax
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DJOJGKAN@Network?5system?5receive?5buffer?5s@
  0017d	e8 00 00 00 00	 call	 _CONS_Printf
  00182	83 c4 08	 add	 esp, 8
$LN13@IPX_Socket:

; 824  : 		}
; 825  : 	}
; 826  : 
; 827  : 	// ipx header
; 828  : 	packetheaderlength = 30; // for stats

  00185	c7 05 00 00 00
	00 1e 00 00 00	 mov	 DWORD PTR _packetheaderlength, 30 ; 0000001eH

; 829  : 
; 830  : 	// setup broadcast adress to BROADCASTADDR entry
; 831  : #if defined (__unix__) || defined(__APPLE__) || defined (UNIXCOMMON) && !defined (__CYGWIN__)
; 832  : 	clientaddress[BROADCASTADDR].sa_family = AF_IPX;
; 833  : 	clientaddress[BROADCASTADDR].ipx.sipx_port = htons(sock_port);
; 834  : #ifndef FREEBSD
; 835  : 	clientaddress[BROADCASTADDR].ipx.sipx_network = 0;
; 836  : 	for (i = 0; i < 6; i++)
; 837  : 		clientaddress[BROADCASTADDR].ipx.sipx_node[i] = (UINT8)0xFF;
; 838  : #else
; 839  : 	clientaddress[BROADCASTADDR].ipx.sipx_addr.x_net.s_net[0] = 0;
; 840  : 	clientaddress[BROADCASTADDR].ipx.sipx_addr.x_net.s_net[1] = 0;
; 841  : 	for (i = 0; i < 6; i++)
; 842  : 		clientaddress[BROADCASTADDR].ipx.sipx_addr.x_host.c_host[i] = (UINT8)0xFF;
; 843  : #endif
; 844  : #else
; 845  : 	clientaddress[BROADCASTADDR].sa_family = AF_IPX;

  0018f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00194	c1 e0 05	 shl	 eax, 5
  00197	b9 06 00 00 00	 mov	 ecx, 6
  0019c	66 89 88 00 00
	00 00		 mov	 WORD PTR _clientaddress[eax], cx

; 846  : 	clientaddress[BROADCASTADDR].ipx.sa_socket = htons(sock_port);

  001a3	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _sock_port
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 _htons@4
  001b0	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001b5	c1 e1 05	 shl	 ecx, 5
  001b8	66 89 81 0c 00
	00 00		 mov	 WORD PTR _clientaddress[ecx+12], ax

; 847  : 	for (i = 0; i < 4; i++)

  001bf	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001c6	eb 09		 jmp	 SHORT $LN4@IPX_Socket
$LN2@IPX_Socket:
  001c8	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  001cb	83 c0 01	 add	 eax, 1
  001ce	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@IPX_Socket:
  001d1	83 7d e0 04	 cmp	 DWORD PTR _i$[ebp], 4
  001d5	7d 15		 jge	 SHORT $LN3@IPX_Socket

; 848  : 		clientaddress[BROADCASTADDR].ipx.sa_netnum[i] = 0;

  001d7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001dc	c1 e0 05	 shl	 eax, 5
  001df	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  001e2	c6 84 08 02 00
	00 00 00	 mov	 BYTE PTR _clientaddress[eax+ecx+2], 0
  001ea	eb dc		 jmp	 SHORT $LN2@IPX_Socket
$LN3@IPX_Socket:

; 849  : 	for (i = 0; i < 6; i++)

  001ec	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001f3	eb 09		 jmp	 SHORT $LN7@IPX_Socket
$LN5@IPX_Socket:
  001f5	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  001f8	83 c0 01	 add	 eax, 1
  001fb	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN7@IPX_Socket:
  001fe	83 7d e0 06	 cmp	 DWORD PTR _i$[ebp], 6
  00202	7d 15		 jge	 SHORT $LN6@IPX_Socket

; 850  : 		clientaddress[BROADCASTADDR].ipx.sa_nodenum[i] = (UINT8)0xFF;

  00204	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00209	c1 e0 05	 shl	 eax, 5
  0020c	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0020f	c6 84 08 06 00
	00 00 ff	 mov	 BYTE PTR _clientaddress[eax+ecx+6], -1
  00217	eb dc		 jmp	 SHORT $LN5@IPX_Socket
$LN6@IPX_Socket:

; 851  : #endif // UNIXCOMMON
; 852  : 	SOCK_cmpaddr = IPX_cmpaddr;

  00219	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SOCK_cmpaddr, OFFSET _IPX_cmpaddr

; 853  : 	return s;

  00223	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]

; 854  : }

  00226	5f		 pop	 edi
  00227	5e		 pop	 esi
  00228	5b		 pop	 ebx
  00229	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022c	33 cd		 xor	 ecx, ebp
  0022e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c3		 ret	 0
_IPX_Socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _UDP_Socket
_TEXT	SEGMENT
_falseval$1 = -44					; size = 4
_j$ = -40						; size = 4
_i$ = -36						; size = 4
_trueval$ = -32						; size = 4
_sock_port_local$ = -28					; size = 2
_address$ = -24						; size = 16
_s$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_UDP_Socket PROC					; COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 628  : 	SOCKET_TYPE s = BADSOCKET;

  00013	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1

; 629  : 	struct sockaddr_in address;
; 630  : #ifdef HAVE_IP6
; 631  : 	struct sockaddr_in6 address6;
; 632  : #endif
; 633  : 	UINT16 sock_port_local;
; 634  : 
; 635  : #ifdef WATTCP
; 636  : 	char trueval = true;
; 637  : #else
; 638  : 	unsigned long trueval = true;

  0001a	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _trueval$[ebp], 1

; 639  : #endif
; 640  : 	int i;
; 641  : 	socklen_t j;
; 642  : 
; 643  : 	// allocate a socket
; 644  : #ifdef HAVE_IP6
; 645  : 	s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP);
; 646  : 	if (s == (SOCKET_TYPE)ERRSOCKET || s == BADSOCKET)
; 647  : #endif
; 648  : 	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);

  00021	6a 11		 push	 17			; 00000011H
  00023	6a 02		 push	 2
  00025	6a 02		 push	 2
  00027	e8 00 00 00 00	 call	 _socket@12
  0002c	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 649  : 	if (s == (SOCKET_TYPE)ERRSOCKET || s == BADSOCKET)

  0002f	83 7d f8 ff	 cmp	 DWORD PTR _s$[ebp], -1
  00033	74 06		 je	 SHORT $LN3@UDP_Socket
  00035	83 7d f8 ff	 cmp	 DWORD PTR _s$[ebp], -1
  00039	75 22		 jne	 SHORT $LN2@UDP_Socket
$LN3@UDP_Socket:

; 650  : 		I_Error("UDP_Socket error #%u: Can't create socket: %s", errno, strerror(errno));

  0003b	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strerror
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JOFKFBKG@UDP_Socket?5error?5?$CD?$CFu?3?5Can?8t?5cre@
  00055	e8 00 00 00 00	 call	 _I_Error
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@UDP_Socket:

; 651  : 
; 652  : #ifdef _WIN32
; 653  : 	{ // Alam_GBC: disable the new UDP connection reset behavior for Win2k and up
; 654  : #if 0
; 655  : 		DWORD dwBytesReturned = 0;
; 656  : 		BOOL bfalse = FALSE;
; 657  : 		WSAIoctl(s, SIO_UDP_CONNRESET, &bfalse, sizeof(bfalse),
; 658  : 		         NULL, 0, &dwBytesReturned, NULL, NULL);
; 659  : #else
; 660  : 		unsigned long falseval = false;

  0005d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _falseval$1[ebp], 0

; 661  : 		ioctl(s, SIO_UDP_CONNRESET, &falseval);

  00064	8d 45 d4	 lea	 eax, DWORD PTR _falseval$1[ebp]
  00067	50		 push	 eax
  00068	68 0c 00 00 98	 push	 -1744830452		; 9800000cH
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _ioctlsocket@12
  00076	90		 npad	 1

; 662  : #endif
; 663  : 	}
; 664  : #endif
; 665  : 
; 666  : 	memset(&address, 0, sizeof (address));

  00077	6a 10		 push	 16			; 00000010H
  00079	6a 00		 push	 0
  0007b	8d 45 e8	 lea	 eax, DWORD PTR _address$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _memset
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 667  : 	address.sin_family = AF_INET;

  00087	b8 02 00 00 00	 mov	 eax, 2
  0008c	66 89 45 e8	 mov	 WORD PTR _address$[ebp], ax

; 668  : 	address.sin_addr.s_addr = htonl(INADDR_NONE);

  00090	6a ff		 push	 -1
  00092	e8 00 00 00 00	 call	 _htonl@4
  00097	89 45 ec	 mov	 DWORD PTR _address$[ebp+4], eax

; 669  : 	if (M_CheckParm("-bindaddr"))

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_09BBMKDBIO@?9bindaddr@
  0009f	e8 00 00 00 00	 call	 _M_CheckParm
  000a4	83 c4 04	 add	 esp, 4
  000a7	85 c0		 test	 eax, eax
  000a9	74 24		 je	 SHORT $LN4@UDP_Socket

; 670  : 	{
; 671  : 		if (!M_IsNextParm())

  000ab	e8 00 00 00 00	 call	 _M_IsNextParm
  000b0	85 c0		 test	 eax, eax
  000b2	75 0d		 jne	 SHORT $LN5@UDP_Socket

; 672  : 			I_Error("syntax: -bindaddr <ip-address>");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DCCLGMFC@syntax?3?5?9bindaddr?5?$DMip?9address?$DO@
  000b9	e8 00 00 00 00	 call	 _I_Error
  000be	83 c4 04	 add	 esp, 4
$LN5@UDP_Socket:

; 673  : 		address.sin_addr.s_addr = inet_addr(M_GetNextParm());

  000c1	e8 00 00 00 00	 call	 _M_GetNextParm
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _inet_addr@4
  000cc	89 45 ec	 mov	 DWORD PTR _address$[ebp+4], eax
$LN4@UDP_Socket:

; 674  : 	}
; 675  : 	if (address.sin_addr.s_addr == htonl(INADDR_NONE))

  000cf	6a ff		 push	 -1
  000d1	e8 00 00 00 00	 call	 _htonl@4
  000d6	39 45 ec	 cmp	 DWORD PTR _address$[ebp+4], eax
  000d9	75 2a		 jne	 SHORT $LN6@UDP_Socket

; 676  : 	{
; 677  : 		address.sin_addr.s_addr = htonl(INADDR_ANY);

  000db	6a 00		 push	 0
  000dd	e8 00 00 00 00	 call	 _htonl@4
  000e2	89 45 ec	 mov	 DWORD PTR _address$[ebp+4], eax

; 678  : 		j = (socklen_t)sizeof(trueval);

  000e5	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4

; 679  : 		setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&trueval, j);

  000ec	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  000ef	50		 push	 eax
  000f0	8d 4d e0	 lea	 ecx, DWORD PTR _trueval$[ebp]
  000f3	51		 push	 ecx
  000f4	6a 04		 push	 4
  000f6	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000fb	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000fe	52		 push	 edx
  000ff	e8 00 00 00 00	 call	 _setsockopt@20
  00104	90		 npad	 1
$LN6@UDP_Socket:

; 680  : 	}
; 681  : 
; 682  : 	//Hurdler: I'd like to put a server and a client on the same computer
; 683  : 	//BP: in fact for client we can use any free port we want i have read
; 684  : 	//    in some doc that connect in udp can do it for us...
; 685  : 	address.sin_port = htons(0); //????

  00105	6a 00		 push	 0
  00107	e8 00 00 00 00	 call	 _htons@4
  0010c	66 89 45 ea	 mov	 WORD PTR _address$[ebp+2], ax

; 686  : 	if (M_CheckParm("-clientport"))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KFBJBBFI@?9clientport@
  00115	e8 00 00 00 00	 call	 _M_CheckParm
  0011a	83 c4 04	 add	 esp, 4
  0011d	85 c0		 test	 eax, eax
  0011f	74 2a		 je	 SHORT $LN7@UDP_Socket

; 687  : 	{
; 688  : 		if (!M_IsNextParm())

  00121	e8 00 00 00 00	 call	 _M_IsNextParm
  00126	85 c0		 test	 eax, eax
  00128	75 0d		 jne	 SHORT $LN9@UDP_Socket

; 689  : 			I_Error("syntax: -clientport <portnum>");

  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FNLNHHNO@syntax?3?5?9clientport?5?$DMportnum?$DO@
  0012f	e8 00 00 00 00	 call	 _I_Error
  00134	83 c4 04	 add	 esp, 4
$LN9@UDP_Socket:

; 690  : 		sock_port_local = (UINT16)atoi(M_GetNextParm());

  00137	e8 00 00 00 00	 call	 _M_GetNextParm
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _atoi
  00142	83 c4 04	 add	 esp, 4
  00145	66 89 45 e4	 mov	 WORD PTR _sock_port_local$[ebp], ax

; 691  : 	}

  00149	eb 0a		 jmp	 SHORT $LN8@UDP_Socket
$LN7@UDP_Socket:

; 692  : 	else
; 693  : 		sock_port_local = sock_port;

  0014b	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _sock_port
  00151	66 89 45 e4	 mov	 WORD PTR _sock_port_local$[ebp], ax
$LN8@UDP_Socket:

; 694  : 
; 695  : 	address.sin_port = htons(sock_port_local);

  00155	0f b7 45 e4	 movzx	 eax, WORD PTR _sock_port_local$[ebp]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _htons@4
  0015f	66 89 45 ea	 mov	 WORD PTR _address$[ebp+2], ax

; 696  : 
; 697  : 	//setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&trueval, sizeof (trueval));
; 698  : 
; 699  : 	j = (socklen_t)sizeof(address);

  00163	c7 45 d8 10 00
	00 00		 mov	 DWORD PTR _j$[ebp], 16	; 00000010H

; 700  : 	if (bind(s, (void *)&address, j) == ERRSOCKET)

  0016a	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  0016d	50		 push	 eax
  0016e	8d 4d e8	 lea	 ecx, DWORD PTR _address$[ebp]
  00171	51		 push	 ecx
  00172	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 _bind@12
  0017b	83 f8 ff	 cmp	 eax, -1
  0017e	75 3b		 jne	 SHORT $LN10@UDP_Socket

; 701  : 	{
; 702  : #ifdef _WIN32
; 703  : 		if (errno == WSAEADDRINUSE)

  00180	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00185	3d 40 27 00 00	 cmp	 eax, 10048		; 00002740H
  0018a	75 0d		 jne	 SHORT $LN11@UDP_Socket

; 704  : 			I_Error("UDP_Socket error: The address and port SRB2 had attempted to bind to is already in use.\n"

  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0NF@JBPHABIG@UDP_Socket?5error?3?5The?5address?5a@
  00191	e8 00 00 00 00	 call	 _I_Error
  00196	83 c4 04	 add	 esp, 4
$LN11@UDP_Socket:

; 705  : 				"\nThis isn't a normal error, and probably indicates that something network-related\n"
; 706  : 				"on your computer is configured improperly.");
; 707  : #endif
; 708  : 		I_Error("UDP_Socket error #%u: %s", errno, strerror(errno));

  00199	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _strerror
  001a4	83 c4 04	 add	 esp, 4
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _WSAGetLastError@0
  001ad	50		 push	 eax
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HHIAFBGK@UDP_Socket?5error?5?$CD?$CFu?3?5?$CFs@
  001b3	e8 00 00 00 00	 call	 _I_Error
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@UDP_Socket:

; 709  : 	}
; 710  : 
; 711  : #ifdef HAVE_IP6
; 712  : 	memset(&address6, 0, sizeof (address6));
; 713  : 	address6.sin6_family = AF_INET6;
; 714  : 	address6.sin6_addr = in6addr_any;
; 715  : 
; 716  : 	//Hurdler: I'd like to put a server and a client on the same computer
; 717  : 	//BP: in fact for client we can use any free port we want i have read
; 718  : 	//    in some doc that connect in udp can do it for us...
; 719  : 	address6.sin6_port = htons(sock_port_local);
; 720  : 
; 721  : 	if (bind(s, (void *)&address6, sizeof (address6)) == ERRSOCKET)
; 722  : 	{
; 723  : 		CONS_Printf("failed to bind with IPv6 stack");
; 724  : 	}
; 725  : #endif
; 726  : 
; 727  : 	// make it non blocking
; 728  : 	if (ioctl(s, FIONBIO, &trueval) != 0)

  001bb	8d 45 e0	 lea	 eax, DWORD PTR _trueval$[ebp]
  001be	50		 push	 eax
  001bf	68 7e 66 04 80	 push	 -2147195266		; 8004667eH
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  001c7	51		 push	 ecx
  001c8	e8 00 00 00 00	 call	 _ioctlsocket@12
  001cd	85 c0		 test	 eax, eax
  001cf	74 0d		 je	 SHORT $LN12@UDP_Socket

; 729  : 	{
; 730  : 		I_Error("UDP_Socket error. Could not set socket to non blocking mode");

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@CKLNDCNP@UDP_Socket?5error?4?5Could?5not?5set@
  001d6	e8 00 00 00 00	 call	 _I_Error
  001db	83 c4 04	 add	 esp, 4
$LN12@UDP_Socket:

; 731  : 	}
; 732  : 
; 733  : 	// make it broadcastable
; 734  : 	j = (socklen_t)sizeof(trueval);

  001de	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4

; 735  : 	if (setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&trueval, j))

  001e5	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  001e8	50		 push	 eax
  001e9	8d 4d e0	 lea	 ecx, DWORD PTR _trueval$[ebp]
  001ec	51		 push	 ecx
  001ed	6a 20		 push	 32			; 00000020H
  001ef	68 ff ff 00 00	 push	 65535			; 0000ffffH
  001f4	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001f7	52		 push	 edx
  001f8	e8 00 00 00 00	 call	 _setsockopt@20
  001fd	85 c0		 test	 eax, eax
  001ff	74 0d		 je	 SHORT $LN13@UDP_Socket

; 736  : 	{
; 737  : 		I_Error("UDP_Socket error. Could not set socket to allow broadcast");

  00201	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@MDCBFNLH@UDP_Socket?5error?4?5Could?5not?5set@
  00206	e8 00 00 00 00	 call	 _I_Error
  0020b	83 c4 04	 add	 esp, 4
$LN13@UDP_Socket:

; 738  : 	}
; 739  : 
; 740  : 	j = (socklen_t)sizeof(i);

  0020e	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4

; 741  : 	getsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&i, &j); // FIXME: so an INT32 value is written to a (char *); portability!!!!!!!

  00215	8d 45 d8	 lea	 eax, DWORD PTR _j$[ebp]
  00218	50		 push	 eax
  00219	8d 4d dc	 lea	 ecx, DWORD PTR _i$[ebp]
  0021c	51		 push	 ecx
  0021d	68 02 10 00 00	 push	 4098			; 00001002H
  00222	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00227	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0022a	52		 push	 edx
  0022b	e8 00 00 00 00	 call	 _getsockopt@20
  00230	90		 npad	 1

; 742  : 	CONS_Printf("Network system buffer: %dKb\n", i>>10);

  00231	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00234	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00237	50		 push	 eax
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JEENIIKP@Network?5system?5buffer?3?5?$CFdKb?6@
  0023d	e8 00 00 00 00	 call	 _CONS_Printf
  00242	83 c4 08	 add	 esp, 8

; 743  : 
; 744  : 	if (i < 64<<10) // 64k

  00245	81 7d dc 00 00
	01 00		 cmp	 DWORD PTR _i$[ebp], 65536 ; 00010000H
  0024c	7d 72		 jge	 SHORT $LN16@UDP_Socket

; 745  : 	{
; 746  : 		i = 64<<10;

  0024e	c7 45 dc 00 00
	01 00		 mov	 DWORD PTR _i$[ebp], 65536 ; 00010000H

; 747  : 		j = (socklen_t)sizeof(i);

  00255	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _j$[ebp], 4

; 748  : 		setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&i, j);

  0025c	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  0025f	50		 push	 eax
  00260	8d 4d dc	 lea	 ecx, DWORD PTR _i$[ebp]
  00263	51		 push	 ecx
  00264	68 02 10 00 00	 push	 4098			; 00001002H
  00269	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0026e	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 _setsockopt@20
  00277	90		 npad	 1

; 749  : 		getsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&i, &j); // FIXME: so an INT32 value is written to a (char *); portability!!!!!!!

  00278	8d 45 d8	 lea	 eax, DWORD PTR _j$[ebp]
  0027b	50		 push	 eax
  0027c	8d 4d dc	 lea	 ecx, DWORD PTR _i$[ebp]
  0027f	51		 push	 ecx
  00280	68 02 10 00 00	 push	 4098			; 00001002H
  00285	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0028a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0028d	52		 push	 edx
  0028e	e8 00 00 00 00	 call	 _getsockopt@20
  00293	90		 npad	 1

; 750  : 		if (i < 64<<10)

  00294	81 7d dc 00 00
	01 00		 cmp	 DWORD PTR _i$[ebp], 65536 ; 00010000H
  0029b	7d 0f		 jge	 SHORT $LN15@UDP_Socket

; 751  : 			CONS_Printf("Can't set buffer length to 64k, file transfer will be bad\n");

  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CCHJDBAG@Can?8t?5set?5buffer?5length?5to?564k?0@
  002a2	e8 00 00 00 00	 call	 _CONS_Printf
  002a7	83 c4 04	 add	 esp, 4
  002aa	eb 14		 jmp	 SHORT $LN16@UDP_Socket
$LN15@UDP_Socket:

; 752  : 		else
; 753  : 			CONS_Printf("Network system buffer set to: %dKb\n",i>>10);

  002ac	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  002af	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  002b2	50		 push	 eax
  002b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EKKIJAJA@Network?5system?5buffer?5set?5to?3?5?$CF@
  002b8	e8 00 00 00 00	 call	 _CONS_Printf
  002bd	83 c4 08	 add	 esp, 8
$LN16@UDP_Socket:

; 754  : 	}
; 755  : 
; 756  : 	// ip + udp
; 757  : 	packetheaderlength = 20 + 8; // for stats

  002c0	c7 05 00 00 00
	00 1c 00 00 00	 mov	 DWORD PTR _packetheaderlength, 28 ; 0000001cH

; 758  : 
; 759  : 	clientaddress[0].sa_family = AF_INET;

  002ca	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  002cf	6b c8 00	 imul	 ecx, eax, 0
  002d2	ba 02 00 00 00	 mov	 edx, 2
  002d7	66 89 91 00 00
	00 00		 mov	 WORD PTR _clientaddress[ecx], dx

; 760  : 	clientaddress[0].ip.sin_port = htons(sock_port_local);

  002de	0f b7 45 e4	 movzx	 eax, WORD PTR _sock_port_local$[ebp]
  002e2	50		 push	 eax
  002e3	e8 00 00 00 00	 call	 _htons@4
  002e8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002ed	6b d1 00	 imul	 edx, ecx, 0
  002f0	66 89 82 02 00
	00 00		 mov	 WORD PTR _clientaddress[edx+2], ax

; 761  : 	clientaddress[0].ip.sin_addr.s_addr = htonl(INADDR_LOOPBACK); //GetLocalAddress(); // my own ip

  002f7	68 01 00 00 7f	 push	 2130706433		; 7f000001H
  002fc	e8 00 00 00 00	 call	 _htonl@4
  00301	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00306	6b d1 00	 imul	 edx, ecx, 0
  00309	89 82 04 00 00
	00		 mov	 DWORD PTR _clientaddress[edx+4], eax

; 762  : 	// setup broadcast adress to BROADCASTADDR entry
; 763  : 	clientaddress[BROADCASTADDR].sa_family = AF_INET;

  0030f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00314	c1 e0 05	 shl	 eax, 5
  00317	b9 02 00 00 00	 mov	 ecx, 2
  0031c	66 89 88 00 00
	00 00		 mov	 WORD PTR _clientaddress[eax], cx

; 764  : 	clientaddress[BROADCASTADDR].ip.sin_port = htons(sock_port_local);

  00323	0f b7 45 e4	 movzx	 eax, WORD PTR _sock_port_local$[ebp]
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 _htons@4
  0032d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00332	c1 e1 05	 shl	 ecx, 5
  00335	66 89 81 02 00
	00 00		 mov	 WORD PTR _clientaddress[ecx+2], ax

; 765  : 	clientaddress[BROADCASTADDR].ip.sin_addr.s_addr = htonl(INADDR_BROADCAST);

  0033c	6a ff		 push	 -1
  0033e	e8 00 00 00 00	 call	 _htonl@4
  00343	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00348	c1 e1 05	 shl	 ecx, 5
  0034b	89 81 04 00 00
	00		 mov	 DWORD PTR _clientaddress[ecx+4], eax

; 766  : 
; 767  : 	doomcom->extratics = 1; // internet is very high ping

  00351	b8 01 00 00 00	 mov	 eax, 1
  00356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  0035c	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 768  : 
; 769  : 	SOCK_cmpaddr = UDP_cmpaddr;

  00360	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SOCK_cmpaddr, OFFSET _UDP_cmpaddr

; 770  : 	return s;

  0036a	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]

; 771  : }

  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi
  0036f	5b		 pop	 ebx
  00370	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00373	33 cd		 xor	 ecx, ebp
  00375	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037a	8b e5		 mov	 esp, ebp
  0037c	5d		 pop	 ebp
  0037d	c3		 ret	 0
_UDP_Socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_FreeNodenum
_TEXT	SEGMENT
_numnode$ = 8						; size = 4
_SOCK_FreeNodenum PROC					; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 609  : 	// can't disconnect from self :)
; 610  : 	if (!numnode)

  00009	83 7d 08 00	 cmp	 DWORD PTR _numnode$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN2@SOCK_FreeN

; 611  : 		return;

  0000f	eb 6a		 jmp	 SHORT $LN1@SOCK_FreeN
$LN2@SOCK_FreeN:

; 612  : 
; 613  : 	DEBFILE(va("Free node %d (%s)\n", numnode, SOCK_GetNodeAddress(numnode)));

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00018	74 3b		 je	 SHORT $LN3@SOCK_FreeN
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0001f	50		 push	 eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _numnode$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _SOCK_GetNodeAddress
  00029	83 c4 04	 add	 esp, 4
  0002c	50		 push	 eax
  0002d	8b 55 08	 mov	 edx, DWORD PTR _numnode$[ebp]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FLBLKNHL@Free?5node?5?$CFd?5?$CI?$CFs?$CJ?6@
  00036	e8 00 00 00 00	 call	 _va
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _fputs
  00044	83 c4 08	 add	 esp, 8
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _fflush
  00052	83 c4 04	 add	 esp, 4
$LN3@SOCK_FreeN:

; 614  : 
; 615  : 	nodeconnected[numnode] = false;

  00055	8b 45 08	 mov	 eax, DWORD PTR _numnode$[ebp]
  00058	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _nodeconnected[eax*4], 0

; 616  : 
; 617  : 	// put invalid address
; 618  : 	memset(&clientaddress[numnode], 0, sizeof (clientaddress[numnode]));

  00063	6a 10		 push	 16			; 00000010H
  00065	6a 00		 push	 0
  00067	8b 45 08	 mov	 eax, DWORD PTR _numnode$[ebp]
  0006a	c1 e0 04	 shl	 eax, 4
  0006d	05 00 00 00 00	 add	 eax, OFFSET _clientaddress
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _memset
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SOCK_FreeN:

; 619  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_SOCK_FreeNodenum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_Send
_TEXT	SEGMENT
_d$ = -8						; size = 4
_c$ = -4						; size = 4
_SOCK_Send PROC						; COMDAT

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 591  : 	ssize_t c;
; 592  : 	socklen_t d = (socklen_t)sizeof(struct sockaddr);

  00009	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _d$[ebp], 16	; 00000010H

; 593  : 
; 594  : 	if (!nodeconnected[doomcom->remotenode])

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00015	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00019	83 3c 8d 00 00
	00 00 00	 cmp	 DWORD PTR _nodeconnected[ecx*4], 0
  00021	75 05		 jne	 SHORT $LN2@SOCK_Send

; 595  : 		return;

  00023	e9 9a 00 00 00	 jmp	 $LN3@SOCK_Send
$LN2@SOCK_Send:

; 596  : 
; 597  : 	c = sendto(mysocket, (char *)&doomcom->data, doomcom->datalength, 0,

  00028	8b 45 f8	 mov	 eax, DWORD PTR _d$[ebp]
  0002b	50		 push	 eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00032	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00036	c1 e2 04	 shl	 edx, 4
  00039	81 c2 00 00 00
	00		 add	 edx, OFFSET _clientaddress
  0003f	52		 push	 edx
  00040	6a 00		 push	 0
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00047	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  0004b	51		 push	 ecx
  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _doomcom
  00052	83 c2 1c	 add	 edx, 28			; 0000001cH
  00055	52		 push	 edx
  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR _mysocket
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _sendto@24
  00061	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 598  : 		(struct sockaddr *)&clientaddress[doomcom->remotenode], d);
; 599  : 
; 600  : 	if (c == ERRSOCKET && errno != ECONNREFUSED && errno != EWOULDBLOCK)

  00064	83 7d fc ff	 cmp	 DWORD PTR _c$[ebp], -1
  00068	75 58		 jne	 SHORT $LN3@SOCK_Send
  0006a	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0006f	3d 4d 27 00 00	 cmp	 eax, 10061		; 0000274dH
  00074	74 4c		 je	 SHORT $LN3@SOCK_Send
  00076	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0007b	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00080	74 40		 je	 SHORT $LN3@SOCK_Send

; 601  : 		I_Error("SOCK_Send, error sending to node %d (%s) #%u: %s", doomcom->remotenode,

  00082	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _strerror
  0008d	83 c4 04	 add	 esp, 4
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00096	50		 push	 eax
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0009c	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _SOCK_GetNodeAddress
  000a6	83 c4 04	 add	 esp, 4
  000a9	50		 push	 eax
  000aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _doomcom
  000b0	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BHJCIMJC@SOCK_Send?0?5error?5sending?5to?5nod@
  000ba	e8 00 00 00 00	 call	 _I_Error
  000bf	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@SOCK_Send:

; 602  : 			SOCK_GetNodeAddress(doomcom->remotenode), errno, strerror(errno));
; 603  : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_SOCK_Send ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_CanGet
_TEXT	SEGMENT
_rselect$ = -276					; size = 4
_tset$ = -272						; size = 260
_timeval_for_select$ = -12				; size = 8
__$ArrayPad$ = -4					; size = 4
_SOCK_CanGet PROC					; COMDAT

; 561  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 562  : 	struct timeval timeval_for_select = {0, 0};

  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _timeval_for_select$[ebp], 0
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _timeval_for_select$[ebp+4], 0

; 563  : 	fd_set          tset;
; 564  : 	int rselect;
; 565  : 
; 566  : 	M_Memcpy(&tset, &set, sizeof (tset));

  00024	68 04 01 00 00	 push	 260			; 00000104H
  00029	68 00 00 00 00	 push	 OFFSET _set
  0002e	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _tset$[ebp]
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 	rselect = select(255, &tset, NULL, NULL, &timeval_for_select);

  0003e	8d 45 f4	 lea	 eax, DWORD PTR _timeval_for_select$[ebp]
  00041	50		 push	 eax
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _tset$[ebp]
  0004c	51		 push	 ecx
  0004d	68 ff 00 00 00	 push	 255			; 000000ffH
  00052	e8 00 00 00 00	 call	 _select@20
  00057	89 85 ec fe ff
	ff		 mov	 DWORD PTR _rselect$[ebp], eax

; 568  : 	if (rselect >= 1)

  0005d	83 bd ec fe ff
	ff 01		 cmp	 DWORD PTR _rselect$[ebp], 1
  00064	7c 26		 jl	 SHORT $LN2@SOCK_CanGe

; 569  : 	{
; 570  : 		if (FD_ISSET(mysocket, &tset))

  00066	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _tset$[ebp]
  0006c	50		 push	 eax
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mysocket
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00079	85 c0		 test	 eax, eax
  0007b	74 09		 je	 SHORT $LN4@SOCK_CanGe

; 571  : 			return true;

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	eb 26		 jmp	 SHORT $LN1@SOCK_CanGe
  00084	eb 04		 jmp	 SHORT $LN5@SOCK_CanGe
$LN4@SOCK_CanGe:

; 572  : 		else
; 573  : 			return false;

  00086	33 c0		 xor	 eax, eax
  00088	eb 20		 jmp	 SHORT $LN1@SOCK_CanGe
$LN5@SOCK_CanGe:

; 574  : 	}

  0008a	eb 1c		 jmp	 SHORT $LN8@SOCK_CanGe
$LN2@SOCK_CanGe:

; 575  : 	else if (rselect == 0)

  0008c	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _rselect$[ebp], 0
  00093	75 06		 jne	 SHORT $LN6@SOCK_CanGe

; 576  : 	{
; 577  : 		return false;

  00095	33 c0		 xor	 eax, eax
  00097	eb 11		 jmp	 SHORT $LN1@SOCK_CanGe

; 578  : 	}

  00099	eb 0d		 jmp	 SHORT $LN8@SOCK_CanGe
$LN6@SOCK_CanGe:

; 579  : 	else if (rselect == ERRSOCKET)

  0009b	83 bd ec fe ff
	ff ff		 cmp	 DWORD PTR _rselect$[ebp], -1
  000a2	75 04		 jne	 SHORT $LN8@SOCK_CanGe

; 580  : 	{
; 581  : 		return false;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 02		 jmp	 SHORT $LN1@SOCK_CanGe
$LN8@SOCK_CanGe:

; 582  : 	}
; 583  : 	return false;

  000a8	33 c0		 xor	 eax, eax
$LN1@SOCK_CanGe:

; 584  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_SOCK_CanGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_CanSend
_TEXT	SEGMENT
_wselect$ = -276					; size = 4
_tset$ = -272						; size = 260
_timeval_for_select$ = -12				; size = 8
__$ArrayPad$ = -4					; size = 4
_SOCK_CanSend PROC					; COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 536  : 	struct timeval timeval_for_select = {0, 0};

  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _timeval_for_select$[ebp], 0
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _timeval_for_select$[ebp+4], 0

; 537  : 	fd_set          tset;
; 538  : 	int wselect;
; 539  : 
; 540  : 	M_Memcpy(&tset, &set, sizeof (tset));

  00024	68 04 01 00 00	 push	 260			; 00000104H
  00029	68 00 00 00 00	 push	 OFFSET _set
  0002e	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _tset$[ebp]
  00034	50		 push	 eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 541  : 	wselect = select(255, NULL, &tset, NULL, &timeval_for_select);

  0003e	8d 45 f4	 lea	 eax, DWORD PTR _timeval_for_select$[ebp]
  00041	50		 push	 eax
  00042	6a 00		 push	 0
  00044	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _tset$[ebp]
  0004a	51		 push	 ecx
  0004b	6a 00		 push	 0
  0004d	68 ff 00 00 00	 push	 255			; 000000ffH
  00052	e8 00 00 00 00	 call	 _select@20
  00057	89 85 ec fe ff
	ff		 mov	 DWORD PTR _wselect$[ebp], eax

; 542  : 	if (wselect >= 1)

  0005d	83 bd ec fe ff
	ff 01		 cmp	 DWORD PTR _wselect$[ebp], 1
  00064	7c 26		 jl	 SHORT $LN2@SOCK_CanSe

; 543  : 	{
; 544  : 		if (FD_ISSET(mysocket, &tset))

  00066	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _tset$[ebp]
  0006c	50		 push	 eax
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mysocket
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ___WSAFDIsSet@8
  00079	85 c0		 test	 eax, eax
  0007b	74 09		 je	 SHORT $LN4@SOCK_CanSe

; 545  : 			return true;

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	eb 26		 jmp	 SHORT $LN1@SOCK_CanSe
  00084	eb 04		 jmp	 SHORT $LN5@SOCK_CanSe
$LN4@SOCK_CanSe:

; 546  : 		else
; 547  : 			return false;

  00086	33 c0		 xor	 eax, eax
  00088	eb 20		 jmp	 SHORT $LN1@SOCK_CanSe
$LN5@SOCK_CanSe:

; 548  : 	}

  0008a	eb 1c		 jmp	 SHORT $LN8@SOCK_CanSe
$LN2@SOCK_CanSe:

; 549  : 	else if (wselect == 0)

  0008c	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _wselect$[ebp], 0
  00093	75 06		 jne	 SHORT $LN6@SOCK_CanSe

; 550  : 	{
; 551  : 		return false;

  00095	33 c0		 xor	 eax, eax
  00097	eb 11		 jmp	 SHORT $LN1@SOCK_CanSe

; 552  : 	}

  00099	eb 0d		 jmp	 SHORT $LN8@SOCK_CanSe
$LN6@SOCK_CanSe:

; 553  : 	else if (wselect == ERRSOCKET)

  0009b	83 bd ec fe ff
	ff ff		 cmp	 DWORD PTR _wselect$[ebp], -1
  000a2	75 04		 jne	 SHORT $LN8@SOCK_CanSe

; 554  : 	{
; 555  : 		return false;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 02		 jmp	 SHORT $LN1@SOCK_CanSe
$LN8@SOCK_CanSe:

; 556  : 	}
; 557  : 	return false;

  000a8	33 c0		 xor	 eax, eax
$LN1@SOCK_CanSe:

; 558  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_SOCK_CanSend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_Get
_TEXT	SEGMENT
_i$1 = -36						; size = 4
_fromaddress$ = -32					; size = 16
_fromlen$ = -16						; size = 4
_c$ = -12						; size = 4
_j$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_SOCK_Get PROC						; COMDAT

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
$LN4@SOCK_Get:

; 445  : 	int j;
; 446  : 	ssize_t c;
; 447  : 	socklen_t fromlen;
; 448  : 	mysockaddr_t fromaddress;
; 449  : 
; 450  : 	do
; 451  : 	{
; 452  : 		fromlen = (socklen_t)sizeof(fromaddress);

  00013	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _fromlen$[ebp], 16 ; 00000010H

; 453  : 		c = recvfrom(mysocket, (char *)&doomcom->data, MAXPACKETLENGTH, 0,

  0001a	8d 45 f0	 lea	 eax, DWORD PTR _fromlen$[ebp]
  0001d	50		 push	 eax
  0001e	8d 4d e0	 lea	 ecx, DWORD PTR _fromaddress$[ebp]
  00021	51		 push	 ecx
  00022	6a 00		 push	 0
  00024	68 aa 05 00 00	 push	 1450			; 000005aaH
  00029	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _doomcom
  0002f	83 c2 1c	 add	 edx, 28			; 0000001cH
  00032	52		 push	 edx
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _mysocket
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _recvfrom@24
  0003e	89 45 f4	 mov	 DWORD PTR _c$[ebp], eax

; 454  : 			(void *)&fromaddress, &fromlen);
; 455  : 		if (c == ERRSOCKET)

  00041	83 7d f4 ff	 cmp	 DWORD PTR _c$[ebp], -1
  00045	0f 85 ae 00 00
	00		 jne	 $LN14@SOCK_Get

; 456  : 		{
; 457  : 			if ((errno == EWOULDBLOCK) || (errno == EMSGSIZE) || (errno == ECONNREFUSED) || (errno == ETIMEDOUT))

  0004b	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00050	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00055	74 24		 je	 SHORT $LN17@SOCK_Get
  00057	e8 00 00 00 00	 call	 _WSAGetLastError@0
  0005c	3d 38 27 00 00	 cmp	 eax, 10040		; 00002738H
  00061	74 18		 je	 SHORT $LN17@SOCK_Get
  00063	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00068	3d 4d 27 00 00	 cmp	 eax, 10061		; 0000274dH
  0006d	74 0c		 je	 SHORT $LN17@SOCK_Get
  0006f	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00074	3d 4c 27 00 00	 cmp	 eax, 10060		; 0000274cH
  00079	75 14		 jne	 SHORT $LN15@SOCK_Get
$LN17@SOCK_Get:

; 458  : 			{
; 459  : 				doomcom->remotenode = -1; // no packet

  0007b	83 c8 ff	 or	 eax, -1
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00084	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 460  : 				return;

  00088	e9 88 02 00 00	 jmp	 $LN1@SOCK_Get

; 461  : 			}

  0008d	eb 48		 jmp	 SHORT $LN18@SOCK_Get
$LN15@SOCK_Get:

; 462  : #if defined (_WIN32)
; 463  : 			else if (errno == WSAECONNRESET) // 2k has some extra errors

  0008f	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00094	3d 46 27 00 00	 cmp	 eax, 10054		; 00002746H
  00099	75 3c		 jne	 SHORT $LN18@SOCK_Get

; 464  : 			{
; 465  : 				DEBFILE("Connection reset (likely that the server isn't running)\n"); //Alam_GBC: how about DEBFILE instead of annoying the user?

  0009b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  000a2	74 21		 je	 SHORT $LN19@SOCK_Get
  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000a9	50		 push	 eax
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@KDNCGLM@Connection?5reset?5?$CIlikely?5that?5t@
  000af	e8 00 00 00 00	 call	 _fputs
  000b4	83 c4 08	 add	 esp, 8
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _fflush
  000c2	83 c4 04	 add	 esp, 4
$LN19@SOCK_Get:

; 466  : 				//D_QuitNetGame(); // Graue 07-04-2004: win32 only and quit
; 467  : 				doomcom->remotenode = -1;      // no packet too

  000c5	83 c8 ff	 or	 eax, -1
  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  000ce	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 468  : 				return;

  000d2	e9 3e 02 00 00	 jmp	 $LN1@SOCK_Get
$LN18@SOCK_Get:

; 469  : 				/// \todo see if the D_QuitNetGame actually fixes it, or whether it crashes or something
; 470  : 				/// Alam_GBC: this WSAECONNRESET happends alot when talking to a masterlist server, i am guess when talking too much at a time
; 471  : 				/// Later, hmmm, SIO_UDP_CONNRESET turned off should fix this
; 472  : 			}
; 473  : #endif
; 474  : 			I_Error("SOCK_Get error #%u: %s\n\n(Disabling any firewalls and/or rebooting your computer may fix this problem)", errno, strerror(errno));

  000d7	e8 00 00 00 00	 call	 _WSAGetLastError@0
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _strerror
  000e2	83 c4 04	 add	 esp, 4
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _WSAGetLastError@0
  000eb	50		 push	 eax
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@JLFOCFNG@SOCK_Get?5error?5?$CD?$CFu?3?5?$CFs?6?6?$CIDisabl@
  000f1	e8 00 00 00 00	 call	 _I_Error
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@SOCK_Get:

; 475  : 		}
; 476  : 
; 477  : 		// check if it's a DoS attacker and don't respond.
; 478  : 		for (j = 0; j < numshun; j++)

  000f9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00100	eb 09		 jmp	 SHORT $LN7@SOCK_Get
$LN5@SOCK_Get:
  00102	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00105	83 c0 01	 add	 eax, 1
  00108	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@SOCK_Get:
  0010b	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0010e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numshun
  00114	7d 2d		 jge	 SHORT $LN6@SOCK_Get

; 479  : 			if (SOCK_cmpaddr(&fromaddress, &shunned[j], shunnedmask[j]))

  00116	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00119	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _shunnedmask[eax]
  00120	51		 push	 ecx
  00121	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00124	c1 e2 04	 shl	 edx, 4
  00127	81 c2 00 00 00
	00		 add	 edx, OFFSET _shunned
  0012d	52		 push	 edx
  0012e	8d 45 e0	 lea	 eax, DWORD PTR _fromaddress$[ebp]
  00131	50		 push	 eax
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR _SOCK_cmpaddr
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	85 c0		 test	 eax, eax
  0013d	74 02		 je	 SHORT $LN20@SOCK_Get

; 480  : 				break;

  0013f	eb 02		 jmp	 SHORT $LN6@SOCK_Get
$LN20@SOCK_Get:
  00141	eb bf		 jmp	 SHORT $LN5@SOCK_Get
$LN6@SOCK_Get:

; 481  : 	} while (j < numshun);

  00143	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00146	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numshun
  0014c	0f 8c c1 fe ff
	ff		 jl	 $LN4@SOCK_Get

; 482  : 
; 483  : 	// find remote node number
; 484  : 	for (j = 0; j < MAXNETNODES; j++)

  00152	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00159	eb 09		 jmp	 SHORT $LN10@SOCK_Get
$LN8@SOCK_Get:
  0015b	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0015e	83 c0 01	 add	 eax, 1
  00161	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN10@SOCK_Get:
  00164	83 7d f8 20	 cmp	 DWORD PTR _j$[ebp], 32	; 00000020H
  00168	7d 40		 jge	 SHORT $LN9@SOCK_Get

; 485  : 	{
; 486  : 		if (SOCK_cmpaddr(&fromaddress, &clientaddress[j], 0))

  0016a	6a 00		 push	 0
  0016c	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0016f	c1 e0 04	 shl	 eax, 4
  00172	05 00 00 00 00	 add	 eax, OFFSET _clientaddress
  00177	50		 push	 eax
  00178	8d 4d e0	 lea	 ecx, DWORD PTR _fromaddress$[ebp]
  0017b	51		 push	 ecx
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR _SOCK_cmpaddr
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	85 c0		 test	 eax, eax
  00187	74 1f		 je	 SHORT $LN21@SOCK_Get

; 487  : 		{
; 488  : 			doomcom->remotenode = (INT16)j; // good packet from a game player

  00189	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0018e	66 8b 4d f8	 mov	 cx, WORD PTR _j$[ebp]
  00192	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 489  : 			doomcom->datalength = (INT16)c;

  00196	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0019b	66 8b 4d f4	 mov	 cx, WORD PTR _c$[ebp]
  0019f	66 89 48 0a	 mov	 WORD PTR [eax+10], cx

; 490  : 			return;

  001a3	e9 6d 01 00 00	 jmp	 $LN1@SOCK_Get
$LN21@SOCK_Get:

; 491  : 		}
; 492  : 	}

  001a8	eb b1		 jmp	 SHORT $LN8@SOCK_Get
$LN9@SOCK_Get:

; 493  : 
; 494  : 	// not found
; 495  : 
; 496  : 	// find a free slot
; 497  : 	cleanupnodes();

  001aa	e8 00 00 00 00	 call	 _cleanupnodes
  001af	90		 npad	 1

; 498  : 	j = getfreenode();

  001b0	e8 00 00 00 00	 call	 _getfreenode
  001b5	0f be c0	 movsx	 eax, al
  001b8	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax

; 499  : 	if (j > 0)

  001bb	83 7d f8 00	 cmp	 DWORD PTR _j$[ebp], 0
  001bf	0f 8e 19 01 00
	00		 jle	 $LN22@SOCK_Get

; 500  : 	{
; 501  : 		size_t i;
; 502  : 		M_Memcpy(&clientaddress[j], &fromaddress, fromlen);

  001c5	8b 45 f0	 mov	 eax, DWORD PTR _fromlen$[ebp]
  001c8	50		 push	 eax
  001c9	8d 4d e0	 lea	 ecx, DWORD PTR _fromaddress$[ebp]
  001cc	51		 push	 ecx
  001cd	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  001d0	c1 e2 04	 shl	 edx, 4
  001d3	81 c2 00 00 00
	00		 add	 edx, OFFSET _clientaddress
  001d9	52		 push	 edx
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 503  : 		DEBFILE(va("New node detected: node:%d address:%s\n", j,

  001e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  001ea	74 3b		 je	 SHORT $LN23@SOCK_Get
  001ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001f1	50		 push	 eax
  001f2	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  001f5	51		 push	 ecx
  001f6	e8 00 00 00 00	 call	 _SOCK_GetNodeAddress
  001fb	83 c4 04	 add	 esp, 4
  001fe	50		 push	 eax
  001ff	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00202	52		 push	 edx
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LHJLLFLG@New?5node?5detected?3?5node?3?$CFd?5addr@
  00208	e8 00 00 00 00	 call	 _va
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _fputs
  00216	83 c4 08	 add	 esp, 8
  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _fflush
  00224	83 c4 04	 add	 esp, 4
$LN23@SOCK_Get:

; 504  : 				SOCK_GetNodeAddress(j)));
; 505  : 		doomcom->remotenode = (INT16)j; // good packet from a game player

  00227	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0022c	66 8b 4d f8	 mov	 cx, WORD PTR _j$[ebp]
  00230	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 506  : 		doomcom->datalength = (INT16)c;

  00234	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00239	66 8b 4d f4	 mov	 cx, WORD PTR _c$[ebp]
  0023d	66 89 48 0a	 mov	 WORD PTR [eax+10], cx

; 507  : 
; 508  : 		// check if it's a banned dude so we can send a refusal later
; 509  : 		for (i = 0; i < numbans; i++)

  00241	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00248	eb 09		 jmp	 SHORT $LN13@SOCK_Get
$LN11@SOCK_Get:
  0024a	8b 45 dc	 mov	 eax, DWORD PTR _i$1[ebp]
  0024d	83 c0 01	 add	 eax, 1
  00250	89 45 dc	 mov	 DWORD PTR _i$1[ebp], eax
$LN13@SOCK_Get:
  00253	8b 45 dc	 mov	 eax, DWORD PTR _i$1[ebp]
  00256	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numbans
  0025c	73 65		 jae	 SHORT $LN12@SOCK_Get

; 510  : 		{
; 511  : 			if (SOCK_cmpaddr(&fromaddress, &banned[i], bannedmask[i]))

  0025e	8b 45 dc	 mov	 eax, DWORD PTR _i$1[ebp]
  00261	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _bannedmask[eax]
  00268	51		 push	 ecx
  00269	8b 55 dc	 mov	 edx, DWORD PTR _i$1[ebp]
  0026c	c1 e2 04	 shl	 edx, 4
  0026f	81 c2 00 00 00
	00		 add	 edx, OFFSET _banned
  00275	52		 push	 edx
  00276	8d 45 e0	 lea	 eax, DWORD PTR _fromaddress$[ebp]
  00279	50		 push	 eax
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR _SOCK_cmpaddr
  00280	83 c4 0c	 add	 esp, 12			; 0000000cH
  00283	85 c0		 test	 eax, eax
  00285	74 3a		 je	 SHORT $LN24@SOCK_Get

; 512  : 			{
; 513  : 				SOCK_bannednode[j] = true;

  00287	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0028a	c7 04 85 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _SOCK_bannednode[eax*4], 1

; 514  : 				DEBFILE("This dude has been banned\n");

  00295	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0029c	74 21		 je	 SHORT $LN25@SOCK_Get
  0029e	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  002a3	50		 push	 eax
  002a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LDLKKAOF@This?5dude?5has?5been?5banned?6@
  002a9	e8 00 00 00 00	 call	 _fputs
  002ae	83 c4 08	 add	 esp, 8
  002b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 _fflush
  002bc	83 c4 04	 add	 esp, 4
$LN25@SOCK_Get:

; 515  : 				break;

  002bf	eb 02		 jmp	 SHORT $LN12@SOCK_Get
$LN24@SOCK_Get:

; 516  : 			}
; 517  : 		}

  002c1	eb 87		 jmp	 SHORT $LN11@SOCK_Get
$LN12@SOCK_Get:

; 518  : 		if (i == numbans)

  002c3	8b 45 dc	 mov	 eax, DWORD PTR _i$1[ebp]
  002c6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numbans
  002cc	75 0e		 jne	 SHORT $LN26@SOCK_Get

; 519  : 			SOCK_bannednode[j] = false;

  002ce	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  002d1	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _SOCK_bannednode[eax*4], 0
$LN26@SOCK_Get:

; 520  : 		return;

  002dc	eb 37		 jmp	 SHORT $LN1@SOCK_Get
$LN22@SOCK_Get:

; 521  : 	}
; 522  : 
; 523  : 	DEBFILE("New node detected: No more free slots\n");

  002de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  002e5	74 21		 je	 SHORT $LN27@SOCK_Get
  002e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  002ec	50		 push	 eax
  002ed	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MFMCOFFD@New?5node?5detected?3?5No?5more?5free@
  002f2	e8 00 00 00 00	 call	 _fputs
  002f7	83 c4 08	 add	 esp, 8
  002fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 _fflush
  00305	83 c4 04	 add	 esp, 4
$LN27@SOCK_Get:

; 524  : 	doomcom->remotenode = -1; // no packet

  00308	83 c8 ff	 or	 eax, -1
  0030b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00311	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
$LN1@SOCK_Get:

; 525  : }

  00315	5f		 pop	 edi
  00316	5e		 pop	 esi
  00317	5b		 pop	 ebx
  00318	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031b	33 cd		 xor	 ecx, ebp
  0031d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00322	8b e5		 mov	 esp, ebp
  00324	5d		 pop	 ebp
  00325	c3		 ret	 0
_SOCK_Get ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _cleanupnodes
_TEXT	SEGMENT
_j$ = -1						; size = 1
_cleanupnodes PROC					; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 430  : 	SINT8 j;
; 431  : 
; 432  : 	if (!Playing())

  00009	e8 00 00 00 00	 call	 _Playing
  0000e	85 c0		 test	 eax, eax
  00010	75 02		 jne	 SHORT $LN5@cleanupnod

; 433  : 		return;

  00012	eb 36		 jmp	 SHORT $LN3@cleanupnod
$LN5@cleanupnod:

; 434  : 
; 435  : 	// Why can't I start at zero?
; 436  : 	for (j = 1; j < MAXNETNODES; j++)

  00014	c6 45 ff 01	 mov	 BYTE PTR _j$[ebp], 1
  00018	eb 08		 jmp	 SHORT $LN4@cleanupnod
$LN2@cleanupnod:
  0001a	8a 45 ff	 mov	 al, BYTE PTR _j$[ebp]
  0001d	04 01		 add	 al, 1
  0001f	88 45 ff	 mov	 BYTE PTR _j$[ebp], al
$LN4@cleanupnod:
  00022	0f be 45 ff	 movsx	 eax, BYTE PTR _j$[ebp]
  00026	83 f8 20	 cmp	 eax, 32			; 00000020H
  00029	7d 1f		 jge	 SHORT $LN3@cleanupnod

; 437  : 		if (!nodeingame[j])

  0002b	0f be 45 ff	 movsx	 eax, BYTE PTR _j$[ebp]
  0002f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _nodeingame[eax*4], 0
  00037	75 0f		 jne	 SHORT $LN6@cleanupnod

; 438  : 			nodeconnected[j] = false;

  00039	0f be 45 ff	 movsx	 eax, BYTE PTR _j$[ebp]
  0003d	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _nodeconnected[eax*4], 0
$LN6@cleanupnod:
  00048	eb d0		 jmp	 SHORT $LN2@cleanupnod
$LN3@cleanupnod:

; 439  : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_cleanupnodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _getfreenode
_TEXT	SEGMENT
_j$ = -1						; size = 1
_getfreenode PROC					; COMDAT

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 415  : 	SINT8 j;
; 416  : 
; 417  : 	for (j = 0; j < MAXNETNODES; j++)

  00009	c6 45 ff 00	 mov	 BYTE PTR _j$[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@getfreenod
$LN2@getfreenod:
  0000f	8a 45 ff	 mov	 al, BYTE PTR _j$[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 ff	 mov	 BYTE PTR _j$[ebp], al
$LN4@getfreenod:
  00017	0f be 45 ff	 movsx	 eax, BYTE PTR _j$[ebp]
  0001b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001e	7d 24		 jge	 SHORT $LN3@getfreenod

; 418  : 		if (!nodeconnected[j])

  00020	0f be 45 ff	 movsx	 eax, BYTE PTR _j$[ebp]
  00024	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _nodeconnected[eax*4], 0
  0002c	75 14		 jne	 SHORT $LN5@getfreenod

; 419  : 		{
; 420  : 			nodeconnected[j] = true;

  0002e	0f be 45 ff	 movsx	 eax, BYTE PTR _j$[ebp]
  00032	c7 04 85 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _nodeconnected[eax*4], 1

; 421  : 			return j;

  0003d	8a 45 ff	 mov	 al, BYTE PTR _j$[ebp]
  00040	eb 04		 jmp	 SHORT $LN1@getfreenod
$LN5@getfreenod:

; 422  : 		}

  00042	eb cb		 jmp	 SHORT $LN2@getfreenod
$LN3@getfreenod:

; 423  : 	return -1;

  00044	0c ff		 or	 al, -1
$LN1@getfreenod:

; 424  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_getfreenode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _UDP_cmpaddr
_TEXT	SEGMENT
tv89 = -72						; size = 4
_bitmask$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mask$ = 16						; size = 1
_UDP_cmpaddr PROC					; COMDAT

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 394  : 	UINT32 bitmask = INADDR_NONE;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _bitmask$[ebp], -1

; 395  : 
; 396  : 	if (mask && mask < 32)

  00010	0f b6 45 10	 movzx	 eax, BYTE PTR _mask$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	74 22		 je	 SHORT $LN2@UDP_cmpadd
  00018	0f b6 45 10	 movzx	 eax, BYTE PTR _mask$[ebp]
  0001c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001f	7d 19		 jge	 SHORT $LN2@UDP_cmpadd

; 397  : 		bitmask = htonl(-1 << (32 - mask));

  00021	0f b6 45 10	 movzx	 eax, BYTE PTR _mask$[ebp]
  00025	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0002a	2b c8		 sub	 ecx, eax
  0002c	83 ca ff	 or	 edx, -1
  0002f	d3 e2		 shl	 edx, cl
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _htonl@4
  00037	89 45 fc	 mov	 DWORD PTR _bitmask$[ebp], eax
$LN2@UDP_cmpadd:

; 398  : 
; 399  : 	if (b->sa_family == AF_INET)

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0003d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00040	83 f9 02	 cmp	 ecx, 2
  00043	75 4a		 jne	 SHORT $LN3@UDP_cmpadd

; 400  : 		return (a->ip.sin_addr.s_addr & bitmask) == (b->ip.sin_addr.s_addr & bitmask)

  00045	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	23 4d fc	 and	 ecx, DWORD PTR _bitmask$[ebp]
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00051	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00054	23 45 fc	 and	 eax, DWORD PTR _bitmask$[ebp]
  00057	3b c8		 cmp	 ecx, eax
  00059	75 26		 jne	 SHORT $LN7@UDP_cmpadd
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0005e	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00062	85 d2		 test	 edx, edx
  00064	74 12		 je	 SHORT $LN6@UDP_cmpadd
  00066	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00069	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0006d	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00070	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00074	3b c8		 cmp	 ecx, eax
  00076	75 09		 jne	 SHORT $LN7@UDP_cmpadd
$LN6@UDP_cmpadd:
  00078	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  0007f	eb 07		 jmp	 SHORT $LN8@UDP_cmpadd
$LN7@UDP_cmpadd:
  00081	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN8@UDP_cmpadd:
  00088	8b 45 b8	 mov	 eax, DWORD PTR tv89[ebp]
  0008b	eb 04		 jmp	 SHORT $LN4@UDP_cmpadd
  0008d	eb 02		 jmp	 SHORT $LN4@UDP_cmpadd
$LN3@UDP_cmpadd:

; 401  : 			&& (b->ip.sin_port == 0 || (a->ip.sin_port == b->ip.sin_port));
; 402  : #ifdef HAVE_IP6
; 403  : 	else if (b->sa_family == AF_INET6)
; 404  : 		return memcmp(&a->ip6.sin6_addr, &b->ip6.sin6_addr, sizeof(b->ip6.sin6_addr))
; 405  : 			&& (b->ip6.sin6_port == 0 || (a->ip6.sin6_port == b->ip6.sin6_port));
; 406  : #endif
; 407  : 	else
; 408  : 		return false;

  0008f	33 c0		 xor	 eax, eax
$LN4@UDP_cmpadd:

; 409  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_UDP_cmpaddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _IPX_cmpaddr
_TEXT	SEGMENT
tv78 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mask$ = 16						; size = 1
_IPX_cmpaddr PROC					; COMDAT

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 375  : 	(void)mask;
; 376  : #if (defined (__unix__) || defined (UNIXCOMMON)) && !defined (__CYGWIN__)
; 377  : #ifdef FREEBSD
; 378  : 	return ipx_neteq(a->ipx.sipx_addr, b->ipx.sipx_addr)
; 379  : 		&& ipx_hosteq(a->ipx.sipx_addr, b->ipx.sipx_addr);
; 380  : #else
; 381  : 	return ((!memcmp(&(a->ipx.sipx_network), &(b->ipx.sipx_network), 4))
; 382  : 		&& (!memcmp(&(a->ipx.sipx_node), &(b->ipx.sipx_node), 6)));
; 383  : #endif
; 384  : #else
; 385  : 	return ((!memcmp(&(a->ipx.sa_netnum), &(b->ipx.sa_netnum), 4))

  00009	6a 04		 push	 4
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0000e	83 c0 02	 add	 eax, 2
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00015	83 c1 02	 add	 ecx, 2
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _memcmp
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	85 c0		 test	 eax, eax
  00023	75 25		 jne	 SHORT $LN3@IPX_cmpadd
  00025	6a 06		 push	 6
  00027	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  0002a	83 c2 06	 add	 edx, 6
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00031	83 c0 06	 add	 eax, 6
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _memcmp
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	85 c0		 test	 eax, eax
  0003f	75 09		 jne	 SHORT $LN3@IPX_cmpadd
  00041	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00048	eb 07		 jmp	 SHORT $LN4@IPX_cmpadd
$LN3@IPX_cmpadd:
  0004a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@IPX_cmpadd:
  00051	8b 45 bc	 mov	 eax, DWORD PTR tv78[ebp]

; 386  : 		&& (!memcmp(&(a->ipx.sa_nodenum), &(b->ipx.sa_nodenum), 6)));
; 387  : #endif // UNIXCOMMON
; 388  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_IPX_cmpaddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_GetBanMask
_TEXT	SEGMENT
_ban$ = 8						; size = 4
_SOCK_GetBanMask PROC					; COMDAT

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 360  : #ifdef NONET
; 361  : 	(void)ban;
; 362  : #else
; 363  : 	static char s[16]; //255.255.255.255 netmask? no, just CDIR for only
; 364  : 	if (ban >= numbans)

  00009	8b 45 08	 mov	 eax, DWORD PTR _ban$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numbans
  00012	72 04		 jb	 SHORT $LN2@SOCK_GetBa

; 365  : 		return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	eb 2a		 jmp	 SHORT $LN1@SOCK_GetBa
$LN2@SOCK_GetBa:

; 366  : 	if (sprintf(s,"%d",bannedmask[ban]) > 0)

  00018	8b 45 08	 mov	 eax, DWORD PTR _ban$[ebp]
  0001b	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _bannedmask[eax]
  00022	51		 push	 ecx
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00028	68 00 00 00 00	 push	 OFFSET ?s@?1??SOCK_GetBanMask@@9@9
  0002d	e8 00 00 00 00	 call	 _sprintf
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	85 c0		 test	 eax, eax
  00037	7e 07		 jle	 SHORT $LN3@SOCK_GetBa

; 367  : 		return s;

  00039	b8 00 00 00 00	 mov	 eax, OFFSET ?s@?1??SOCK_GetBanMask@@9@9
  0003e	eb 02		 jmp	 SHORT $LN1@SOCK_GetBa
$LN3@SOCK_GetBa:

; 368  : #endif
; 369  : 	return NULL;

  00040	33 c0		 xor	 eax, eax
$LN1@SOCK_GetBa:

; 370  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_SOCK_GetBanMask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_GetBanAddress
_TEXT	SEGMENT
_ban$ = 8						; size = 4
_SOCK_GetBanAddress PROC				; COMDAT

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 349  : 	if (ban >= numbans)

  00009	8b 45 08	 mov	 eax, DWORD PTR _ban$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numbans
  00012	72 04		 jb	 SHORT $LN2@SOCK_GetBa

; 350  : 		return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	eb 14		 jmp	 SHORT $LN1@SOCK_GetBa
$LN2@SOCK_GetBa:

; 351  : #ifdef NONET
; 352  : 	return NULL;
; 353  : #else
; 354  : 	return SOCK_AddrToStr(&banned[ban]);

  00018	8b 45 08	 mov	 eax, DWORD PTR _ban$[ebp]
  0001b	c1 e0 04	 shl	 eax, 4
  0001e	05 00 00 00 00	 add	 eax, OFFSET _banned
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _SOCK_AddrToStr
  00029	83 c4 04	 add	 esp, 4
$LN1@SOCK_GetBa:

; 355  : #endif
; 356  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_SOCK_GetBanAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_GetNodeAddress
_TEXT	SEGMENT
_node$ = 8						; size = 4
_SOCK_GetNodeAddress PROC				; COMDAT

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 336  : 	if (node == 0)

  00009	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  0000d	75 07		 jne	 SHORT $LN2@SOCK_GetNo

; 337  : 		return "self";

  0000f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04PJDNGLKJ@self@
  00014	eb 25		 jmp	 SHORT $LN1@SOCK_GetNo
$LN2@SOCK_GetNo:

; 338  : #ifdef NONET
; 339  : 	return NULL;
; 340  : #else
; 341  : 	if (!nodeconnected[node])

  00016	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00019	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _nodeconnected[eax*4], 0
  00021	75 04		 jne	 SHORT $LN3@SOCK_GetNo

; 342  : 		return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 14		 jmp	 SHORT $LN1@SOCK_GetNo
$LN3@SOCK_GetNo:

; 343  : 	return SOCK_AddrToStr(&clientaddress[node]);

  00027	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0002a	c1 e0 04	 shl	 eax, 4
  0002d	05 00 00 00 00	 add	 eax, OFFSET _clientaddress
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _SOCK_AddrToStr
  00038	83 c4 04	 add	 esp, 4
$LN1@SOCK_GetNo:

; 344  : #endif
; 345  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_SOCK_GetNodeAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _SOCK_AddrToStr
_TEXT	SEGMENT
_sk$ = 8						; size = 4
_SOCK_AddrToStr PROC					; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 280  : 	static char s[64]; // 255.255.255.255:65535 or IPv6:65535
; 281  : 	if (sk->sa_family == AF_INET)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  0000c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0000f	83 f9 02	 cmp	 ecx, 2
  00012	75 56		 jne	 SHORT $LN2@SOCK_AddrT

; 282  : 	{
; 283  : 		strcpy(s, inet_ntoa(sk->ip.sin_addr));

  00014	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _inet_ntoa@4
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ?s@?1??SOCK_AddrToStr@@9@9
  00026	e8 00 00 00 00	 call	 _strcpy
  0002b	83 c4 08	 add	 esp, 8

; 284  : 		if (sk->ip.sin_port != 0) strcat(s, va(":%d", ntohs(sk->ip.sin_port)));

  0002e	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  00031	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00035	85 c9		 test	 ecx, ecx
  00037	74 2c		 je	 SHORT $LN4@SOCK_AddrT
  00039	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  0003c	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _ntohs@4
  00046	0f b7 d0	 movzx	 edx, ax
  00049	52		 push	 edx
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_03HODKBCIO@?3?$CFd@
  0004f	e8 00 00 00 00	 call	 _va
  00054	83 c4 08	 add	 esp, 8
  00057	50		 push	 eax
  00058	68 00 00 00 00	 push	 OFFSET ?s@?1??SOCK_AddrToStr@@9@9
  0005d	e8 00 00 00 00	 call	 _strcat
  00062	83 c4 08	 add	 esp, 8
$LN4@SOCK_AddrT:

; 285  : 	}

  00065	e9 e5 00 00 00	 jmp	 $LN6@SOCK_AddrT
$LN2@SOCK_AddrT:

; 286  : #ifdef USEIPX
; 287  : 	else
; 288  : #if (defined (__unix__) || defined(__APPLE__) || defined (UNIXCOMMON)) && !defined (__CYGWIN__)
; 289  : 	if (sk->sa_family == AF_IPX)
; 290  : 	{
; 291  : #ifdef FREEBSD
; 292  : 		sprintf(s, "%s", ipx_ntoa(sk->ipx.sipx_addr));
; 293  : #else
; 294  : 		sprintf(s,"%08x.%02x%02x%02x%02x%02x%02x:%d", sk->ipx.sipx_network,
; 295  : 			(UINT8)sk->ipx.sipx_node[0],
; 296  : 			(UINT8)sk->ipx.sipx_node[1],
; 297  : 			(UINT8)sk->ipx.sipx_node[2],
; 298  : 			(UINT8)sk->ipx.sipx_node[3],
; 299  : 			(UINT8)sk->ipx.sipx_node[4],
; 300  : 			(UINT8)sk->ipx.sipx_node[5],
; 301  : 			sk->ipx.sipx_port);
; 302  : #endif
; 303  : 	}
; 304  : #else
; 305  : 	if (sk->sa_family == AF_IPX)

  0006a	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  0006d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00070	83 f9 06	 cmp	 ecx, 6
  00073	0f 85 c4 00 00
	00		 jne	 $LN5@SOCK_AddrT

; 306  : 	{
; 307  : 		sprintf(s, "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x:%d",

  00079	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  0007c	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00080	51		 push	 ecx
  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	6b c2 05	 imul	 eax, edx, 5
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _sk$[ebp]
  0008c	0f b6 54 01 06	 movzx	 edx, BYTE PTR [ecx+eax+6]
  00091	52		 push	 edx
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	c1 e0 02	 shl	 eax, 2
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _sk$[ebp]
  0009d	0f b6 54 01 06	 movzx	 edx, BYTE PTR [ecx+eax+6]
  000a2	52		 push	 edx
  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	6b c8 03	 imul	 ecx, eax, 3
  000ab	8b 55 08	 mov	 edx, DWORD PTR _sk$[ebp]
  000ae	0f b6 44 0a 06	 movzx	 eax, BYTE PTR [edx+ecx+6]
  000b3	50		 push	 eax
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	d1 e1		 shl	 ecx, 1
  000bb	8b 55 08	 mov	 edx, DWORD PTR _sk$[ebp]
  000be	0f b6 44 0a 06	 movzx	 eax, BYTE PTR [edx+ecx+6]
  000c3	50		 push	 eax
  000c4	b9 01 00 00 00	 mov	 ecx, 1
  000c9	c1 e1 00	 shl	 ecx, 0
  000cc	8b 55 08	 mov	 edx, DWORD PTR _sk$[ebp]
  000cf	0f b6 44 0a 06	 movzx	 eax, BYTE PTR [edx+ecx+6]
  000d4	50		 push	 eax
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	6b d1 00	 imul	 edx, ecx, 0
  000dd	8b 45 08	 mov	 eax, DWORD PTR _sk$[ebp]
  000e0	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  000e5	51		 push	 ecx
  000e6	ba 01 00 00 00	 mov	 edx, 1
  000eb	6b c2 03	 imul	 eax, edx, 3
  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _sk$[ebp]
  000f1	0f b6 54 01 02	 movzx	 edx, BYTE PTR [ecx+eax+2]
  000f6	52		 push	 edx
  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	d1 e0		 shl	 eax, 1
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _sk$[ebp]
  00101	0f b6 54 01 02	 movzx	 edx, BYTE PTR [ecx+eax+2]
  00106	52		 push	 edx
  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	c1 e0 00	 shl	 eax, 0
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _sk$[ebp]
  00112	0f b6 54 01 02	 movzx	 edx, BYTE PTR [ecx+eax+2]
  00117	52		 push	 edx
  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	6b c8 00	 imul	 ecx, eax, 0
  00120	8b 55 08	 mov	 edx, DWORD PTR _sk$[ebp]
  00123	0f b6 44 0a 02	 movzx	 eax, BYTE PTR [edx+ecx+2]
  00128	50		 push	 eax
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@JPPIFNFE@?$CF02x?$CF02x?$CF02x?$CF02x?4?$CF02x?$CF02x?$CF02x?$CF0@
  0012e	68 00 00 00 00	 push	 OFFSET ?s@?1??SOCK_AddrToStr@@9@9
  00133	e8 00 00 00 00	 call	 _sprintf
  00138	83 c4 34	 add	 esp, 52			; 00000034H

; 308  : 			(UINT8)sk->ipx.sa_netnum[0],
; 309  : 			(UINT8)sk->ipx.sa_netnum[1],
; 310  : 			(UINT8)sk->ipx.sa_netnum[2],
; 311  : 			(UINT8)sk->ipx.sa_netnum[3],
; 312  : 			(UINT8)sk->ipx.sa_nodenum[0],
; 313  : 			(UINT8)sk->ipx.sa_nodenum[1],
; 314  : 			(UINT8)sk->ipx.sa_nodenum[2],
; 315  : 			(UINT8)sk->ipx.sa_nodenum[3],
; 316  : 			(UINT8)sk->ipx.sa_nodenum[4],
; 317  : 			(UINT8)sk->ipx.sa_nodenum[5],
; 318  : 			sk->ipx.sa_socket);
; 319  : 	}

  0013b	eb 12		 jmp	 SHORT $LN6@SOCK_AddrT
$LN5@SOCK_AddrT:

; 320  : #endif // UNIXCOMMON
; 321  : #endif // USEIPX
; 322  : #ifdef HAVE_IP6
; 323  : 	if (sk->sa_family == AF_INET6)
; 324  : 	{
; 325  : 		inet_ntop(AF_INET6, &sk->ip6.sin6_addr, s, sizeof (sk->ip6));
; 326  : 	}
; 327  : #endif
; 328  : 	else
; 329  : 		sprintf(s, "Unknown type");

  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGOCBNGP@Unknown?5type@
  00142	68 00 00 00 00	 push	 OFFSET ?s@?1??SOCK_AddrToStr@@9@9
  00147	e8 00 00 00 00	 call	 _sprintf
  0014c	83 c4 08	 add	 esp, 8
$LN6@SOCK_AddrT:

; 330  : 	return s;

  0014f	b8 00 00 00 00	 mov	 eax, OFFSET ?s@?1??SOCK_AddrToStr@@9@9

; 331  : }

  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	5b		 pop	 ebx
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
_SOCK_AddrToStr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _I_ShutdownTcpDriver
_TEXT	SEGMENT
_I_ShutdownTcpDriver PROC				; COMDAT

; 982  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 983  : #ifndef NONET
; 984  : 	SOCK_CloseSocket();

  00009	e8 00 00 00 00	 call	 _SOCK_CloseSocket
  0000e	90		 npad	 1

; 985  : 
; 986  : 	CONS_Printf("I_ShutdownTcpDriver: ");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OAMGEJHN@I_ShutdownTcpDriver?3?5@
  00014	e8 00 00 00 00	 call	 _CONS_Printf
  00019	83 c4 04	 add	 esp, 4

; 987  : #ifdef _WIN32
; 988  : 	WSACleanup();

  0001c	e8 00 00 00 00	 call	 _WSACleanup@0
  00021	90		 npad	 1

; 989  : #endif
; 990  : #ifdef HAVE_LWIP
; 991  : 	lwip_kos_shutdown();
; 992  : #elif defined(_arch_dreamcast)
; 993  : 	net_shutdown();
; 994  : #endif
; 995  : #ifdef __DJGPP__
; 996  : #ifdef WATTCP // wattcp
; 997  : 	//_outch = NULL;
; 998  : 	sock_exit();
; 999  : #else
; 1000 : 	__lsck_uninit();
; 1001 : #endif // libsocket
; 1002 : #endif // __DJGPP__
; 1003 : 	CONS_Printf("shut down\n");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KKFCCFFM@shut?5down?6@
  00027	e8 00 00 00 00	 call	 _CONS_Printf
  0002c	83 c4 04	 add	 esp, 4

; 1004 : 	init_tcp_driver = false;

  0002f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _init_tcp_driver, 0

; 1005 : #endif
; 1006 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_I_ShutdownTcpDriver ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _I_InitTcpDriver
_TEXT	SEGMENT
tv69 = -484						; size = 4
_WSError$1 = -416					; size = 4
_WSAresult$2 = -412					; size = 4
_WSAData$3 = -408					; size = 400
_tcp_was_up$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_I_InitTcpDriver PROC					; COMDAT

; 858  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 01 00
	00		 sub	 esp, 484		; 000001e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 859  : 	boolean tcp_was_up = init_tcp_driver;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _init_tcp_driver
  0001b	89 45 f8	 mov	 DWORD PTR _tcp_was_up$[ebp], eax

; 860  : #ifndef NONET
; 861  : 	if (!init_tcp_driver)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _init_tcp_driver, 0
  00025	0f 85 43 01 00
	00		 jne	 $LN4@I_InitTcpD

; 862  : 	{
; 863  : #ifdef _WIN32
; 864  : 		WSADATA WSAData;
; 865  : 		const int WSAresult = WSAStartup(MAKEWORD(1,1),&WSAData);

  0002b	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _WSAData$3[ebp]
  00031	50		 push	 eax
  00032	68 01 01 00 00	 push	 257			; 00000101H
  00037	e8 00 00 00 00	 call	 _WSAStartup@8
  0003c	89 85 64 fe ff
	ff		 mov	 DWORD PTR _WSAresult$2[ebp], eax

; 866  : 		if (WSAresult != 0)

  00042	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR _WSAresult$2[ebp], 0
  00049	0f 84 af 00 00
	00		 je	 $LN11@I_InitTcpD

; 867  : 		{
; 868  : 			LPCSTR WSError = NULL;

  0004f	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _WSError$1[ebp], 0

; 869  : 			switch (WSAresult)

  00059	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _WSAresult$2[ebp]
  0005f	89 85 1c fe ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00065	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  0006b	81 e9 1e 27 00
	00		 sub	 ecx, 10014		; 0000271eH
  00071	89 8d 1c fe ff
	ff		 mov	 DWORD PTR tv69[ebp], ecx
  00077	83 bd 1c fe ff
	ff 4d		 cmp	 DWORD PTR tv69[ebp], 77	; 0000004dH
  0007e	77 44		 ja	 SHORT $LN10@I_InitTcpD
  00080	8b 95 1c fe ff
	ff		 mov	 edx, DWORD PTR tv69[ebp]
  00086	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN16@I_InitTcpD[edx]
  0008d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN17@I_InitTcpD[eax*4]
$LN6@I_InitTcpD:

; 870  : 			{
; 871  : 				case WSASYSNOTREADY:
; 872  : 					WSError = "The underlying network subsystem is not ready for network communication";

  00094	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _WSError$1[ebp], OFFSET ??_C@_0EI@JLCNGLKD@The?5underlying?5network?5subsyste@

; 873  : 					break;

  0009e	eb 3e		 jmp	 SHORT $LN2@I_InitTcpD
$LN7@I_InitTcpD:

; 874  : 				case WSAEINPROGRESS:
; 875  : 					WSError = "A blocking Windows Sockets 1.1 operation is in progress";

  000a0	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _WSError$1[ebp], OFFSET ??_C@_0DI@LGHIKHKH@A?5blocking?5Windows?5Sockets?51?41?5@

; 876  : 					break;

  000aa	eb 32		 jmp	 SHORT $LN2@I_InitTcpD
$LN8@I_InitTcpD:

; 877  : 				case WSAEPROCLIM:
; 878  : 					WSError = "Limit on the number of tasks supported by the Windows Sockets implementation has been reached";

  000ac	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _WSError$1[ebp], OFFSET ??_C@_0FO@MOJFEIAD@Limit?5on?5the?5number?5of?5tasks?5su@

; 879  : 					break;

  000b6	eb 26		 jmp	 SHORT $LN2@I_InitTcpD
$LN9@I_InitTcpD:

; 880  : 				case WSAEFAULT:
; 881  : 					WSError = "WTF? The WSAData is not a valid pointer? What kind of setup do you have?";

  000b8	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _WSError$1[ebp], OFFSET ??_C@_0EJ@BFHCDGFI@WTF?$DP?5The?5WSAData?5is?5not?5a?5valid@

; 882  : 					break;

  000c2	eb 1a		 jmp	 SHORT $LN2@I_InitTcpD
$LN10@I_InitTcpD:

; 883  : 				default:
; 884  : 					WSError = va("Error code %u",WSAresult);

  000c4	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _WSAresult$2[ebp]
  000ca	50		 push	 eax
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GHDHPEFL@Error?5code?5?$CFu@
  000d0	e8 00 00 00 00	 call	 _va
  000d5	83 c4 08	 add	 esp, 8
  000d8	89 85 60 fe ff
	ff		 mov	 DWORD PTR _WSError$1[ebp], eax
$LN2@I_InitTcpD:

; 885  : 					break;
; 886  : 			}
; 887  : 			if (WSAresult != WSAVERNOTSUPPORTED) CONS_Printf("WinSock(TCP/IP) error: %s\n",WSError);

  000de	81 bd 64 fe ff
	ff 6c 27 00 00	 cmp	 DWORD PTR _WSAresult$2[ebp], 10092 ; 0000276cH
  000e8	74 14		 je	 SHORT $LN11@I_InitTcpD
  000ea	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _WSError$1[ebp]
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GMNDDBHJ@WinSock?$CITCP?1IP?$CJ?5error?3?5?$CFs?6@
  000f6	e8 00 00 00 00	 call	 _CONS_Printf
  000fb	83 c4 08	 add	 esp, 8
$LN11@I_InitTcpD:

; 888  : 		}
; 889  : 		if (LOBYTE(WSAData.wVersion) != 1 ||

  000fe	0f b7 85 68 fe
	ff ff		 movzx	 eax, WORD PTR _WSAData$3[ebp]
  00105	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010a	0f b6 c8	 movzx	 ecx, al
  0010d	83 f9 01	 cmp	 ecx, 1
  00110	75 17		 jne	 SHORT $LN13@I_InitTcpD
  00112	0f b7 85 68 fe
	ff ff		 movzx	 eax, WORD PTR _WSAData$3[ebp]
  00119	c1 e8 08	 shr	 eax, 8
  0011c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00121	0f b6 c8	 movzx	 ecx, al
  00124	83 f9 01	 cmp	 ecx, 1
  00127	74 13		 je	 SHORT $LN12@I_InitTcpD
$LN13@I_InitTcpD:

; 890  : 			HIBYTE(WSAData.wVersion) != 1)
; 891  : 		{
; 892  : 			WSACleanup();

  00129	e8 00 00 00 00	 call	 _WSACleanup@0
  0012e	90		 npad	 1

; 893  : 			CONS_Printf("No WinSock(TCP/IP) 1.1 driver detected");

  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JOMAOFEJ@No?5WinSock?$CITCP?1IP?$CJ?51?41?5driver?5d@
  00134	e8 00 00 00 00	 call	 _CONS_Printf
  00139	83 c4 04	 add	 esp, 4
$LN12@I_InitTcpD:

; 894  : 		}
; 895  : 		CONS_Printf("WinSock description: %s\n",WSAData.szDescription);

  0013c	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _WSAData$3[ebp+4]
  00142	50		 push	 eax
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IEOEOFPL@WinSock?5description?3?5?$CFs?6@
  00148	e8 00 00 00 00	 call	 _CONS_Printf
  0014d	83 c4 08	 add	 esp, 8

; 896  : 		CONS_Printf("WinSock System Status: %s\n",WSAData.szSystemStatus);

  00150	8d 85 6d ff ff
	ff		 lea	 eax, DWORD PTR _WSAData$3[ebp+261]
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KLEHEDME@WinSock?5System?5Status?3?5?$CFs?6@
  0015c	e8 00 00 00 00	 call	 _CONS_Printf
  00161	83 c4 08	 add	 esp, 8

; 897  : #endif
; 898  : #ifdef HAVE_LWIP
; 899  : 		lwip_kos_init();
; 900  : #elif defined(_arch_dreamcast)
; 901  : 		//return;
; 902  : 		net_init();
; 903  : #endif
; 904  : #ifdef __DJGPP__
; 905  : #ifdef WATTCP // Alam_GBC: survive bootp, dhcp, rarp and wattcp/pktdrv from failing to load
; 906  : 		survive_eth   = 1; // would be needed to not exit if pkt_eth_init() fails
; 907  : 		survive_bootp = 1; // ditto for BOOTP
; 908  : 		survive_dhcp  = 1; // ditto for DHCP/RARP
; 909  : 		survive_rarp  = 1;
; 910  : 		//_watt_do_exit = false;
; 911  : 		//_watt_handle_cbreak = false;
; 912  : 		//_watt_no_config = true;
; 913  : 		_outch = wattcp_outch;
; 914  : 		init_misc();
; 915  : //#ifdef DEBUGFILE
; 916  : 		dbug_init();
; 917  : //#endif
; 918  : 		switch (sock_init())
; 919  : 		{
; 920  : 			case 0:
; 921  : 				init_tcp_driver = true;
; 922  : 				break;
; 923  : 			case 3:
; 924  : 				CONS_Printf("No packet driver detected");
; 925  : 				break;
; 926  : 			case 4:
; 927  : 				CONS_Printf("Error while talking to packet driver");
; 928  : 				break;
; 929  : 			case 5:
; 930  : 				CONS_Printf("BOOTP failed");
; 931  : 				break;
; 932  : 			case 6:
; 933  : 				CONS_Printf("DHCP failed");
; 934  : 				break;
; 935  : 			case 7:
; 936  : 				CONS_Printf("RARP failed");
; 937  : 				break;
; 938  : 			case 8:
; 939  : 				CONS_Printf("TCP/IP failed");
; 940  : 				break;
; 941  : 			case 9:
; 942  : 				CONS_Printf("PPPoE login/discovery failed");
; 943  : 				break;
; 944  : 			default:
; 945  : 				CONS_Printf("Unknown error with TCP/IP stack");
; 946  : 				break;
; 947  : 		}
; 948  : 		hires_timer(0);
; 949  : #else // wattcp
; 950  : 		if (__lsck_init())
; 951  : 			init_tcp_driver = true;
; 952  : 		else
; 953  : 			CONS_Printf("No Tcp/Ip driver detected");
; 954  : #endif // libsocket
; 955  : #endif // __DJGPP__
; 956  : #ifndef __DJGPP__
; 957  : 		init_tcp_driver = true;

  00164	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _init_tcp_driver, 1
$LN4@I_InitTcpD:

; 958  : #endif
; 959  : 	}
; 960  : #endif
; 961  : 	if (!tcp_was_up && init_tcp_driver)

  0016e	83 7d f8 00	 cmp	 DWORD PTR _tcp_was_up$[ebp], 0
  00172	75 16		 jne	 SHORT $LN14@I_InitTcpD
  00174	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _init_tcp_driver, 0
  0017b	74 0d		 je	 SHORT $LN14@I_InitTcpD

; 962  : 		I_AddExitFunc(I_ShutdownTcpDriver);

  0017d	68 00 00 00 00	 push	 OFFSET _I_ShutdownTcpDriver
  00182	e8 00 00 00 00	 call	 _I_AddExitFunc
  00187	83 c4 04	 add	 esp, 4
$LN14@I_InitTcpD:

; 963  : 	return init_tcp_driver;

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR _init_tcp_driver

; 964  : }

  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00195	33 cd		 xor	 ecx, ebp
  00197	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c3		 ret	 0
$LN17@I_InitTcpD:
  001a0	00 00 00 00	 DD	 $LN9@I_InitTcpD
  001a4	00 00 00 00	 DD	 $LN7@I_InitTcpD
  001a8	00 00 00 00	 DD	 $LN8@I_InitTcpD
  001ac	00 00 00 00	 DD	 $LN6@I_InitTcpD
  001b0	00 00 00 00	 DD	 $LN10@I_InitTcpD
$LN16@I_InitTcpD:
  001b4	00		 DB	 0
  001b5	04		 DB	 4
  001b6	04		 DB	 4
  001b7	04		 DB	 4
  001b8	04		 DB	 4
  001b9	04		 DB	 4
  001ba	04		 DB	 4
  001bb	04		 DB	 4
  001bc	04		 DB	 4
  001bd	04		 DB	 4
  001be	04		 DB	 4
  001bf	04		 DB	 4
  001c0	04		 DB	 4
  001c1	04		 DB	 4
  001c2	04		 DB	 4
  001c3	04		 DB	 4
  001c4	04		 DB	 4
  001c5	04		 DB	 4
  001c6	04		 DB	 4
  001c7	04		 DB	 4
  001c8	04		 DB	 4
  001c9	04		 DB	 4
  001ca	01		 DB	 1
  001cb	04		 DB	 4
  001cc	04		 DB	 4
  001cd	04		 DB	 4
  001ce	04		 DB	 4
  001cf	04		 DB	 4
  001d0	04		 DB	 4
  001d1	04		 DB	 4
  001d2	04		 DB	 4
  001d3	04		 DB	 4
  001d4	04		 DB	 4
  001d5	04		 DB	 4
  001d6	04		 DB	 4
  001d7	04		 DB	 4
  001d8	04		 DB	 4
  001d9	04		 DB	 4
  001da	04		 DB	 4
  001db	04		 DB	 4
  001dc	04		 DB	 4
  001dd	04		 DB	 4
  001de	04		 DB	 4
  001df	04		 DB	 4
  001e0	04		 DB	 4
  001e1	04		 DB	 4
  001e2	04		 DB	 4
  001e3	04		 DB	 4
  001e4	04		 DB	 4
  001e5	04		 DB	 4
  001e6	04		 DB	 4
  001e7	04		 DB	 4
  001e8	04		 DB	 4
  001e9	02		 DB	 2
  001ea	04		 DB	 4
  001eb	04		 DB	 4
  001ec	04		 DB	 4
  001ed	04		 DB	 4
  001ee	04		 DB	 4
  001ef	04		 DB	 4
  001f0	04		 DB	 4
  001f1	04		 DB	 4
  001f2	04		 DB	 4
  001f3	04		 DB	 4
  001f4	04		 DB	 4
  001f5	04		 DB	 4
  001f6	04		 DB	 4
  001f7	04		 DB	 4
  001f8	04		 DB	 4
  001f9	04		 DB	 4
  001fa	04		 DB	 4
  001fb	04		 DB	 4
  001fc	04		 DB	 4
  001fd	04		 DB	 4
  001fe	04		 DB	 4
  001ff	04		 DB	 4
  00200	04		 DB	 4
  00201	03		 DB	 3
_I_InitTcpDriver ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\i_tcp.c
;	COMDAT _I_InitTcpNetwork
_TEXT	SEGMENT
$T1 = -332						; size = 4
_ret$ = -264						; size = 4
_serverhostname$ = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_I_InitTcpNetwork PROC					; COMDAT

; 1195 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1196 : 	char serverhostname[255];
; 1197 : 	boolean ret = false;

  00016	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ret$[ebp], 0

; 1198 : #ifdef USEIPX
; 1199 : 	ipx = M_CheckParm("-ipx");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_04PFLFMAHA@?9ipx@
  00025	e8 00 00 00 00	 call	 _M_CheckParm
  0002a	83 c4 04	 add	 esp, 4
  0002d	a3 00 00 00 00	 mov	 DWORD PTR _ipx, eax

; 1200 : #endif
; 1201 : 	// initilize the OS's TCP/IP stack
; 1202 : 	if (!I_InitTcpDriver())

  00032	e8 00 00 00 00	 call	 _I_InitTcpDriver
  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN2@I_InitTcpN

; 1203 : 		return false;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 21 02 00 00	 jmp	 $LN1@I_InitTcpN
$LN2@I_InitTcpN:

; 1204 : 
; 1205 : 	if (M_CheckParm("-udpport"))

  00042	68 00 00 00 00	 push	 OFFSET ??_C@_08HMJCHDDA@?9udpport@
  00047	e8 00 00 00 00	 call	 _M_CheckParm
  0004c	83 c4 04	 add	 esp, 4
  0004f	85 c0		 test	 eax, eax
  00051	74 27		 je	 SHORT $LN5@I_InitTcpN

; 1206 : 	{
; 1207 : 		if (M_IsNextParm())

  00053	e8 00 00 00 00	 call	 _M_IsNextParm
  00058	85 c0		 test	 eax, eax
  0005a	74 16		 je	 SHORT $LN4@I_InitTcpN

; 1208 : 			sock_port = (UINT16)atoi(M_GetNextParm());

  0005c	e8 00 00 00 00	 call	 _M_GetNextParm
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _atoi
  00067	83 c4 04	 add	 esp, 4
  0006a	66 a3 00 00 00
	00		 mov	 WORD PTR _sock_port, ax
  00070	eb 08		 jmp	 SHORT $LN5@I_InitTcpN
$LN4@I_InitTcpN:

; 1209 : 		else
; 1210 : 			sock_port = 0;

  00072	33 c0		 xor	 eax, eax
  00074	66 a3 00 00 00
	00		 mov	 WORD PTR _sock_port, ax
$LN5@I_InitTcpN:

; 1211 : 	}
; 1212 : 
; 1213 : 	// parse network game options,
; 1214 : 	if (M_CheckParm("-server") || dedicated)

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_07ODEEFNBO@?9server@
  0007f	e8 00 00 00 00	 call	 _M_CheckParm
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	75 0d		 jne	 SHORT $LN8@I_InitTcpN
  0008b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00092	0f 84 91 00 00
	00		 je	 $LN6@I_InitTcpN
$LN8@I_InitTcpN:

; 1215 : 	{
; 1216 : 		server = true;

  00098	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _server, 1

; 1217 : 
; 1218 : 		// If a number of clients (i.e. nodes) is specified, the server will wait for the clients
; 1219 : 		// to connect before starting.
; 1220 : 		// If no number is specified here, the server starts with 1 client, and others can join
; 1221 : 		// in-game.
; 1222 : 		// Since Boris has implemented join in-game, there is no actual need for specifying a
; 1223 : 		// particular number here.
; 1224 : 		// FIXME: for dedicated server, numnodes needs to be set to 0 upon start
; 1225 : 		if (dedicated)

  000a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  000a9	74 0e		 je	 SHORT $LN9@I_InitTcpN

; 1226 : 			doomcom->numnodes = 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  000b3	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
  000b7	eb 0f		 jmp	 SHORT $LN10@I_InitTcpN
$LN9@I_InitTcpN:

; 1227 : /*		else if (M_IsNextParm())
; 1228 : 			doomcom->numnodes = (INT16)atoi(M_GetNextParm());*/
; 1229 : 		else
; 1230 : 			doomcom->numnodes = 1;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  000c4	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
$LN10@I_InitTcpN:

; 1231 : 
; 1232 : 		if (doomcom->numnodes < 0)

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000cd	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  000d1	85 c9		 test	 ecx, ecx
  000d3	7d 0c		 jge	 SHORT $LN11@I_InitTcpN

; 1233 : 			doomcom->numnodes = 0;

  000d5	33 c0		 xor	 eax, eax
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  000dd	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
$LN11@I_InitTcpN:

; 1234 : 		if (doomcom->numnodes > MAXNETNODES)

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000e6	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  000ea	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000ed	7e 0f		 jle	 SHORT $LN12@I_InitTcpN

; 1235 : 			doomcom->numnodes = MAXNETNODES;

  000ef	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  000fa	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
$LN12@I_InitTcpN:

; 1236 : 
; 1237 : 		// server
; 1238 : 		servernode = 0;

  000fe	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _servernode, 0

; 1239 : 		// FIXME:
; 1240 : 		// ??? and now ?
; 1241 : 		// server on a big modem ??? 4*isdn
; 1242 : 		net_bandwidth = 16000;

  00105	c7 05 00 00 00
	00 80 3e 00 00	 mov	 DWORD PTR _net_bandwidth, 16000 ; 00003e80H

; 1243 : 		hardware_MAXPACKETLENGTH = INETPACKETLENGTH;

  0010f	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00114	66 a3 00 00 00
	00		 mov	 WORD PTR _hardware_MAXPACKETLENGTH, ax

; 1244 : 
; 1245 : 		ret = true;

  0011a	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _ret$[ebp], 1

; 1246 : 	}

  00124	e9 da 00 00 00	 jmp	 $LN17@I_InitTcpN
$LN6@I_InitTcpN:

; 1247 : 	else if (M_CheckParm("-connect"))

  00129	68 00 00 00 00	 push	 OFFSET ??_C@_08FABEHMEN@?9connect@
  0012e	e8 00 00 00 00	 call	 _M_CheckParm
  00133	83 c4 04	 add	 esp, 4
  00136	85 c0		 test	 eax, eax
  00138	0f 84 c5 00 00
	00		 je	 $LN17@I_InitTcpN

; 1248 : 	{
; 1249 : 		if (M_IsNextParm())

  0013e	e8 00 00 00 00	 call	 _M_IsNextParm
  00143	85 c0		 test	 eax, eax
  00145	74 17		 je	 SHORT $LN14@I_InitTcpN

; 1250 : 			strcpy(serverhostname, M_GetNextParm());

  00147	e8 00 00 00 00	 call	 _M_GetNextParm
  0014c	50		 push	 eax
  0014d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _serverhostname$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _strcpy
  00159	83 c4 08	 add	 esp, 8
  0015c	eb 30		 jmp	 SHORT $LN15@I_InitTcpN
$LN14@I_InitTcpN:

; 1251 : 		else
; 1252 : 			serverhostname[0] = 0; // assuming server in the LAN, use broadcast to detect it

  0015e	b8 01 00 00 00	 mov	 eax, 1
  00163	6b c8 00	 imul	 ecx, eax, 0
  00166	89 8d b4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0016c	81 bd b4 fe ff
	ff ff 00 00 00	 cmp	 DWORD PTR $T1[ebp], 255	; 000000ffH
  00176	73 02		 jae	 SHORT $LN19@I_InitTcpN
  00178	eb 06		 jmp	 SHORT $LN20@I_InitTcpN
$LN19@I_InitTcpN:
  0017a	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0017f	90		 npad	 1
$LN20@I_InitTcpN:
  00180	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00186	c6 84 15 fc fe
	ff ff 00	 mov	 BYTE PTR _serverhostname$[ebp+edx], 0
$LN15@I_InitTcpN:

; 1253 : 
; 1254 : 		// server address only in ip
; 1255 : 		if (serverhostname[0] && !ipx)

  0018e	b8 01 00 00 00	 mov	 eax, 1
  00193	6b c8 00	 imul	 ecx, eax, 0
  00196	0f be 94 0d fc
	fe ff ff	 movsx	 edx, BYTE PTR _serverhostname$[ebp+ecx]
  0019e	85 d2		 test	 edx, edx
  001a0	74 3f		 je	 SHORT $LN16@I_InitTcpN
  001a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ipx, 0
  001a9	75 36		 jne	 SHORT $LN16@I_InitTcpN

; 1256 : 		{
; 1257 : 			COM_BufAddText("connect \"");

  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_09EGJOEHMB@connect?5?$CC@
  001b0	e8 00 00 00 00	 call	 _COM_BufAddText
  001b5	83 c4 04	 add	 esp, 4

; 1258 : 			COM_BufAddText(serverhostname);

  001b8	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _serverhostname$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _COM_BufAddText
  001c4	83 c4 04	 add	 esp, 4

; 1259 : 			COM_BufAddText("\"\n");

  001c7	68 00 00 00 00	 push	 OFFSET ??_C@_02MBJIFMOJ@?$CC?6@
  001cc	e8 00 00 00 00	 call	 _COM_BufAddText
  001d1	83 c4 04	 add	 esp, 4

; 1260 : 
; 1261 : 			// probably modem
; 1262 : 			hardware_MAXPACKETLENGTH = INETPACKETLENGTH;

  001d4	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  001d9	66 a3 00 00 00
	00		 mov	 WORD PTR _hardware_MAXPACKETLENGTH, ax

; 1263 : 		}

  001df	eb 22		 jmp	 SHORT $LN17@I_InitTcpN
$LN16@I_InitTcpN:

; 1264 : 		else
; 1265 : 		{
; 1266 : 			// so we're on a LAN
; 1267 : 			COM_BufAddText("connect any\n");

  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FNIHICEM@connect?5any?6@
  001e6	e8 00 00 00 00	 call	 _COM_BufAddText
  001eb	83 c4 04	 add	 esp, 4

; 1268 : 
; 1269 : 			net_bandwidth = 800000;

  001ee	c7 05 00 00 00
	00 00 35 0c 00	 mov	 DWORD PTR _net_bandwidth, 800000 ; 000c3500H

; 1270 : 			hardware_MAXPACKETLENGTH = MAXPACKETLENGTH;

  001f8	b8 aa 05 00 00	 mov	 eax, 1450		; 000005aaH
  001fd	66 a3 00 00 00
	00		 mov	 WORD PTR _hardware_MAXPACKETLENGTH, ax
$LN17@I_InitTcpN:

; 1271 : 		}
; 1272 : 	}
; 1273 : 
; 1274 : 	I_NetOpenSocket = SOCK_OpenSocket;

  00203	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetOpenSocket, OFFSET _SOCK_OpenSocket

; 1275 : 	I_Ban = SOCK_Ban;

  0020d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_Ban, OFFSET _SOCK_Ban

; 1276 : 	I_Shun = SOCK_Shun;

  00217	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_Shun, OFFSET _SOCK_Shun

; 1277 : 	I_ClearBans = SOCK_ClearBans;

  00221	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_ClearBans, OFFSET _SOCK_ClearBans

; 1278 : 	I_GetNodeAddress = SOCK_GetNodeAddress;

  0022b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_GetNodeAddress, OFFSET _SOCK_GetNodeAddress

; 1279 : 	I_GetBanAddress = SOCK_GetBanAddress;

  00235	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_GetBanAddress, OFFSET _SOCK_GetBanAddress

; 1280 : 	I_GetBanMask = SOCK_GetBanMask;

  0023f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_GetBanMask, OFFSET _SOCK_GetBanMask

; 1281 : 	I_SetBanAddress = SOCK_SetBanAddress;

  00249	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_SetBanAddress, OFFSET _SOCK_SetBanAddress

; 1282 : 	bannednode = SOCK_bannednode;

  00253	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bannednode, OFFSET _SOCK_bannednode

; 1283 : 
; 1284 : 	return ret;

  0025d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@I_InitTcpN:

; 1285 : }

  00263	5f		 pop	 edi
  00264	5e		 pop	 esi
  00265	5b		 pop	 ebx
  00266	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00269	33 cd		 xor	 ecx, ebp
  0026b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00270	8b e5		 mov	 esp, ebp
  00272	5d		 pop	 ebp
  00273	c3		 ret	 0
_I_InitTcpNetwork ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
