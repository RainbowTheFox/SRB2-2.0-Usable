; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\m_misc.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_M_Memcpy
PUBLIC	_cv_screenshot_option
PUBLIC	_cv_screenshot_folder
PUBLIC	_cv_zlib_level
PUBLIC	_cv_zlib_memory
PUBLIC	_cv_zlib_strategy
PUBLIC	_cv_zlib_window_bits
PUBLIC	_cv_zlib_levela
PUBLIC	_cv_zlib_memorya
PUBLIC	_cv_zlib_strategya
PUBLIC	_cv_zlib_window_bitsa
PUBLIC	_cv_apng_disable
PUBLIC	_moviemode
PUBLIC	_takescreenshot
PUBLIC	??_C@_07MCAEODGB@Default@			; `string'
PUBLIC	??_C@_04GHGFPGNC@HOME@				; `string'
PUBLIC	??_C@_04LJAEHHAP@SRB2@				; `string'
PUBLIC	??_C@_06EOPOAAHK@CUSTOM@			; `string'
PUBLIC	??_C@_0BC@HCFCCCOC@screenshot_option@		; `string'
PUBLIC	??_C@_0BC@FMFAALGK@screenshot_folder@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_04OHJIHAFH@None@				; `string'
PUBLIC	??_C@_0L@DDKGECCA@Best?5Speed@			; `string'
PUBLIC	??_C@_07BFAFNILN@Level?52@			; `string'
PUBLIC	??_C@_07MBOOJPM@Level?53@			; `string'
PUBLIC	??_C@_07EDFPHPDL@Level?54@			; `string'
PUBLIC	??_C@_07FKEEEOHK@Level?55@			; `string'
PUBLIC	??_C@_06EFAGIKOH@Normal@			; `string'
PUBLIC	??_C@_07GIHCCMPI@Level?57@			; `string'
PUBLIC	??_C@_07OPOKDADH@Level?58@			; `string'
PUBLIC	??_C@_0BB@BGBEFBH@Best?5Compression@		; `string'
PUBLIC	??_C@_07CHDDLKDP@Level?50@			; `string'
PUBLIC	??_C@_07DOCIILHO@Level?51@			; `string'
PUBLIC	??_C@_07HBGJBNLJ@Level?56@			; `string'
PUBLIC	??_C@_07PGPBABHG@Level?59@			; `string'
PUBLIC	??_C@_08HIBGHEEI@Filtered@			; `string'
PUBLIC	??_C@_0N@BMFGGOBI@Huffman?5Only@		; `string'
PUBLIC	??_C@_03ELDBCICO@RLE@				; `string'
PUBLIC	??_C@_05OCBIINAK@Fixed@				; `string'
PUBLIC	??_C@_03NBJHPDKG@512@				; `string'
PUBLIC	??_C@_02KDBOBLCG@1k@				; `string'
PUBLIC	??_C@_02KBFIKFHP@2k@				; `string'
PUBLIC	??_C@_02KFNFNJMN@4k@				; `string'
PUBLIC	??_C@_02KMMPCAKJ@8k@				; `string'
PUBLIC	??_C@_03DAMDJEGJ@16k@				; `string'
PUBLIC	??_C@_03JNMDPEDO@32k@				; `string'
PUBLIC	??_C@_0BI@LLJNDNKI@png_z_compression_level@	; `string'
PUBLIC	??_C@_0BD@LLGGCJMF@png_z_memory_level@		; `string'
PUBLIC	??_C@_0P@OKGPBBHH@png_z_strategy@		; `string'
PUBLIC	??_C@_0BC@PBEGGGIF@png_z_window_bits@		; `string'
PUBLIC	??_C@_0BJ@FPBLLMCM@apng_z_compression_level@	; `string'
PUBLIC	??_C@_0BE@CENILAHM@apng_z_memory_level@		; `string'
PUBLIC	??_C@_0BA@EGCOEFND@apng_z_strategy@		; `string'
PUBLIC	??_C@_0BD@PADLHKMD@apng_z_window_bits@		; `string'
PUBLIC	??_C@_0N@DANFADAJ@apng_disable@			; `string'
PUBLIC	??_C@_03GCDBBDDL@Off@				; `string'
EXTRN	_CV_OnOff:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_moviemode DD	01H DUP (?)
_takescreenshot DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_configfile:BYTE:080H
_DATA	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DANFADAJ@apng_disable@
CONST	SEGMENT
??_C@_0N@DANFADAJ@apng_disable@ DB 'apng_disable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PADLHKMD@apng_z_window_bits@
CONST	SEGMENT
??_C@_0BD@PADLHKMD@apng_z_window_bits@ DB 'apng_z_window_bits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EGCOEFND@apng_z_strategy@
CONST	SEGMENT
??_C@_0BA@EGCOEFND@apng_z_strategy@ DB 'apng_z_strategy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CENILAHM@apng_z_memory_level@
CONST	SEGMENT
??_C@_0BE@CENILAHM@apng_z_memory_level@ DB 'apng_z_memory_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPBLLMCM@apng_z_compression_level@
CONST	SEGMENT
??_C@_0BJ@FPBLLMCM@apng_z_compression_level@ DB 'apng_z_compression_level'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PBEGGGIF@png_z_window_bits@
CONST	SEGMENT
??_C@_0BC@PBEGGGIF@png_z_window_bits@ DB 'png_z_window_bits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OKGPBBHH@png_z_strategy@
CONST	SEGMENT
??_C@_0P@OKGPBBHH@png_z_strategy@ DB 'png_z_strategy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LLGGCJMF@png_z_memory_level@
CONST	SEGMENT
??_C@_0BD@LLGGCJMF@png_z_memory_level@ DB 'png_z_memory_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LLJNDNKI@png_z_compression_level@
CONST	SEGMENT
??_C@_0BI@LLJNDNKI@png_z_compression_level@ DB 'png_z_compression_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JNMDPEDO@32k@
CONST	SEGMENT
??_C@_03JNMDPEDO@32k@ DB '32k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAMDJEGJ@16k@
CONST	SEGMENT
??_C@_03DAMDJEGJ@16k@ DB '16k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMMPCAKJ@8k@
CONST	SEGMENT
??_C@_02KMMPCAKJ@8k@ DB '8k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFNFNJMN@4k@
CONST	SEGMENT
??_C@_02KFNFNJMN@4k@ DB '4k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KBFIKFHP@2k@
CONST	SEGMENT
??_C@_02KBFIKFHP@2k@ DB '2k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KDBOBLCG@1k@
CONST	SEGMENT
??_C@_02KDBOBLCG@1k@ DB '1k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NBJHPDKG@512@
CONST	SEGMENT
??_C@_03NBJHPDKG@512@ DB '512', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCBIINAK@Fixed@
CONST	SEGMENT
??_C@_05OCBIINAK@Fixed@ DB 'Fixed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELDBCICO@RLE@
CONST	SEGMENT
??_C@_03ELDBCICO@RLE@ DB 'RLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BMFGGOBI@Huffman?5Only@
CONST	SEGMENT
??_C@_0N@BMFGGOBI@Huffman?5Only@ DB 'Huffman Only', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HIBGHEEI@Filtered@
CONST	SEGMENT
??_C@_08HIBGHEEI@Filtered@ DB 'Filtered', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGPBABHG@Level?59@
CONST	SEGMENT
??_C@_07PGPBABHG@Level?59@ DB 'Level 9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBGJBNLJ@Level?56@
CONST	SEGMENT
??_C@_07HBGJBNLJ@Level?56@ DB 'Level 6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOCIILHO@Level?51@
CONST	SEGMENT
??_C@_07DOCIILHO@Level?51@ DB 'Level 1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHDDLKDP@Level?50@
CONST	SEGMENT
??_C@_07CHDDLKDP@Level?50@ DB 'Level 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BGBEFBH@Best?5Compression@
CONST	SEGMENT
??_C@_0BB@BGBEFBH@Best?5Compression@ DB 'Best Compression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OPOKDADH@Level?58@
CONST	SEGMENT
??_C@_07OPOKDADH@Level?58@ DB 'Level 8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GIHCCMPI@Level?57@
CONST	SEGMENT
??_C@_07GIHCCMPI@Level?57@ DB 'Level 7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFAGIKOH@Normal@
CONST	SEGMENT
??_C@_06EFAGIKOH@Normal@ DB 'Normal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKEEEOHK@Level?55@
CONST	SEGMENT
??_C@_07FKEEEOHK@Level?55@ DB 'Level 5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EDFPHPDL@Level?54@
CONST	SEGMENT
??_C@_07EDFPHPDL@Level?54@ DB 'Level 4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBOOJPM@Level?53@
CONST	SEGMENT
??_C@_07MBOOJPM@Level?53@ DB 'Level 3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BFAFNILN@Level?52@
CONST	SEGMENT
??_C@_07BFAFNILN@Level?52@ DB 'Level 2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DDKGECCA@Best?5Speed@
CONST	SEGMENT
??_C@_0L@DDKGECCA@Best?5Speed@ DB 'Best Speed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None@
CONST	SEGMENT
??_C@_04OHJIHAFH@None@ DB 'None', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMFAALGK@screenshot_folder@
CONST	SEGMENT
??_C@_0BC@FMFAALGK@screenshot_folder@ DB 'screenshot_folder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HCFCCCOC@screenshot_option@
CONST	SEGMENT
??_C@_0BC@HCFCCCOC@screenshot_option@ DB 'screenshot_option', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOPOAAHK@CUSTOM@
CONST	SEGMENT
??_C@_06EOPOAAHK@CUSTOM@ DB 'CUSTOM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJAEHHAP@SRB2@
CONST	SEGMENT
??_C@_04LJAEHHAP@SRB2@ DB 'SRB2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHGFPGNC@HOME@
CONST	SEGMENT
??_C@_04GHGFPGNC@HOME@ DB 'HOME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MCAEODGB@Default@
CONST	SEGMENT
??_C@_07MCAEODGB@Default@ DB 'Default', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_M_Memcpy DD	FLAT:_cpu_cpy
_cv_screenshot_option DD FLAT:??_C@_0BC@HCFCCCOC@screenshot_option@
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:_screenshot_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_screenshot_folder DD FLAT:??_C@_0BC@FMFAALGK@screenshot_folder@
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_level DD FLAT:??_C@_0BI@LLJNDNKI@png_z_compression_level@
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:_zlib_level_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_memory DD FLAT:??_C@_0BD@LLGGCJMF@png_z_memory_level@
	DD	FLAT:??_C@_07GIHCCMPI@Level?57@
	DD	01H
	DD	FLAT:_zlib_mem_level_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_strategy DD FLAT:??_C@_0P@OKGPBBHH@png_z_strategy@
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:_zlib_strategy_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_window_bits DD FLAT:??_C@_0BC@PBEGGGIF@png_z_window_bits@
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:_zlib_window_bits_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_levela DD FLAT:??_C@_0BJ@FPBLLMCM@apng_z_compression_level@
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:_zlib_level_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_memorya DD FLAT:??_C@_0BE@CENILAHM@apng_z_memory_level@
	DD	FLAT:??_C@_07GIHCCMPI@Level?57@
	DD	01H
	DD	FLAT:_zlib_mem_level_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_strategya DD FLAT:??_C@_0BA@EGCOEFND@apng_z_strategy@
	DD	FLAT:??_C@_03ELDBCICO@RLE@
	DD	01H
	DD	FLAT:_zlib_strategy_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_zlib_window_bitsa DD FLAT:??_C@_0BD@PADLHKMD@apng_z_window_bits@
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:_zlib_window_bits_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_apng_disable DD FLAT:??_C@_0N@DANFADAJ@apng_disable@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_screenshot_cons_t DD 00H
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	01H
	DD	FLAT:??_C@_04GHGFPGNC@HOME@
	DD	02H
	DD	FLAT:??_C@_04LJAEHHAP@SRB2@
	DD	03H
	DD	FLAT:??_C@_06EOPOAAHK@CUSTOM@
	DD	00H
	DD	00H
	ORG $+4
_zlib_level_t DD 0ffffffffH
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	00H
	DD	FLAT:??_C@_04OHJIHAFH@None@
	DD	01H
	DD	FLAT:??_C@_0L@DDKGECCA@Best?5Speed@
	DD	02H
	DD	FLAT:??_C@_07BFAFNILN@Level?52@
	DD	03H
	DD	FLAT:??_C@_07MBOOJPM@Level?53@
	DD	04H
	DD	FLAT:??_C@_07EDFPHPDL@Level?54@
	DD	05H
	DD	FLAT:??_C@_07FKEEEOHK@Level?55@
	DD	06H
	DD	FLAT:??_C@_06EFAGIKOH@Normal@
	DD	07H
	DD	FLAT:??_C@_07GIHCCMPI@Level?57@
	DD	08H
	DD	FLAT:??_C@_07OPOKDADH@Level?58@
	DD	09H
	DD	FLAT:??_C@_0BB@BGBEFBH@Best?5Compression@
	DD	00H
	DD	00H
_zlib_mem_level_t DD 0ffffffffH
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	00H
	DD	FLAT:??_C@_07CHDDLKDP@Level?50@
	DD	01H
	DD	FLAT:??_C@_07DOCIILHO@Level?51@
	DD	02H
	DD	FLAT:??_C@_07BFAFNILN@Level?52@
	DD	03H
	DD	FLAT:??_C@_07MBOOJPM@Level?53@
	DD	04H
	DD	FLAT:??_C@_07EDFPHPDL@Level?54@
	DD	05H
	DD	FLAT:??_C@_07FKEEEOHK@Level?55@
	DD	06H
	DD	FLAT:??_C@_07HBGJBNLJ@Level?56@
	DD	07H
	DD	FLAT:??_C@_07GIHCCMPI@Level?57@
	DD	08H
	DD	FLAT:??_C@_06EFAGIKOH@Normal@
	DD	09H
	DD	FLAT:??_C@_07PGPBABHG@Level?59@
	DD	00H
	DD	00H
_zlib_strategy_t DD 0ffffffffH
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	00H
	DD	FLAT:??_C@_06EFAGIKOH@Normal@
	DD	01H
	DD	FLAT:??_C@_08HIBGHEEI@Filtered@
	DD	02H
	DD	FLAT:??_C@_0N@BMFGGOBI@Huffman?5Only@
	DD	03H
	DD	FLAT:??_C@_03ELDBCICO@RLE@
	DD	04H
	DD	FLAT:??_C@_05OCBIINAK@Fixed@
	DD	00H
	DD	00H
_zlib_window_bits_t DD 0ffffffffH
	DD	FLAT:??_C@_07MCAEODGB@Default@
	DD	09H
	DD	FLAT:??_C@_03NBJHPDKG@512@
	DD	0aH
	DD	FLAT:??_C@_02KDBOBLCG@1k@
	DD	0bH
	DD	FLAT:??_C@_02KBFIKFHP@2k@
	DD	0cH
	DD	FLAT:??_C@_02KFNFNJMN@4k@
	DD	0dH
	DD	FLAT:??_C@_02KMMPCAKJ@8k@
	DD	0eH
	DD	FLAT:??_C@_03DAMDJEGJ@16k@
	DD	0fH
	DD	FLAT:??_C@_03JNMDPEDO@32k@
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	_vsprintf
PUBLIC	_va
PUBLIC	_M_MapNumber
PUBLIC	_FIL_WriteFile
PUBLIC	_FIL_ReadFile
PUBLIC	_FIL_FileExists
PUBLIC	_FIL_WriteFileOK
PUBLIC	_FIL_ReadFileOK
PUBLIC	_FIL_FileOK
PUBLIC	_FIL_DefaultExtension
PUBLIC	_FIL_ForceExtension
PUBLIC	_FIL_CheckExtension
PUBLIC	_M_ScreenShot
PUBLIC	_M_DoScreenShot
PUBLIC	_Command_SaveConfig_f
PUBLIC	_Command_LoadConfig_f
PUBLIC	_Command_ChangeConfig_f
PUBLIC	_M_FirstLoadConfig
PUBLIC	_M_SaveConfig
PUBLIC	_strcatbf
PUBLIC	_M_SetupMemcpy
PUBLIC	??_C@_03ELIABIOC@w?$CLb@			; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0DP@OPJHDKAI@saveconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?$FL?9s@ ; `string'
PUBLIC	??_C@_04IFJILJI@?4cfg@				; `string'
PUBLIC	??_C@_07FDPFAEJA@?9silent@			; `string'
PUBLIC	??_C@_0BE@LFKJPNBC@config?5saved?5as?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DH@IKJCMNIF@loadconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3?5l@ ; `string'
PUBLIC	??_C@_0L@CMKBJKBF@exec?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0EG@JNENEDAE@changeconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3@ ; `string'
PUBLIC	??_C@_0BB@JDNBDCKH@saveconfig?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BB@CAOMBPIH@loadconfig?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_07OOKHNANK@?9config@			; `string'
PUBLIC	??_C@_0BB@EMBFEKE@config?5file?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0CG@IJCKCNG@M_SaveConfig?$CI?$CJ?3?5filename?5is?5not@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0CD@FMPONOCB@Couldn?8t?5save?5game?5config?5file?5@ ; `string'
PUBLIC	??_C@_0BN@PDDANKFG@?1?1?5SRB2?5configuration?5file?4?6@ ; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_03BIPDAGPI@pcx@				; `string'
PUBLIC	??_C@_03LJIJAGL@tga@				; `string'
PUBLIC	??_C@_0DA@JJFBJPLK@Can?8t?5take?5a?5screenshot?5without@ ; `string'
PUBLIC	??_C@_0BM@EKELNKMB@screen?5shot?5?$CFs?5saved?5in?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CG@JBEGIPMN@Couldn?8t?5create?5screen?5shot?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0DL@LODJHCDC@Couldn?8t?5create?5screen?5shot?5?$CIal@ ; `string'
PUBLIC	??_C@_0BO@HDOGFIMO@Memcpy?5from?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@ ; `string'
PUBLIC	??_C@_0BM@GKHKLCEK@Memcpy?5to?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@ ; `string'
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isalnum:PROC
EXTRN	_tolower:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_stricmp:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_access:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_COM_Argc:PROC
EXTRN	_COM_Argv:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_COM_BufInsertText:PROC
EXTRN	_CV_SaveVariables:PROC
EXTRN	_W_CacheLumpName:PROC
EXTRN	_GetPalette:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_G_Controldefault:PROC
EXTRN	_G_SaveKeySetting:PROC
EXTRN	_I_ReadScreen:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_HWR_Screenshot:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_dedicated:DWORD
EXTRN	_R_MMX:DWORD
EXTRN	_vid:BYTE
EXTRN	_screens:BYTE
EXTRN	_rendermode:DWORD
EXTRN	_srb2home:BYTE
EXTRN	_usehome:DWORD
EXTRN	_pandf:DWORD
EXTRN	_srb2path:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_gameconfig_loaded DD 01H DUP (?)
?string@?1??va@@9@9 DB 0400H DUP (?)			; `va'::`2'::string
_BSS	ENDS
;	COMDAT ??_C@_0BM@GKHKLCEK@Memcpy?5to?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@
CONST	SEGMENT
??_C@_0BM@GKHKLCEK@Memcpy?5to?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@ DB 'M'
	DB	'emcpy to 0x0?!: %p %p %Iu', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HDOGFIMO@Memcpy?5from?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@
CONST	SEGMENT
??_C@_0BO@HDOGFIMO@Memcpy?5from?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@ DB 'M'
	DB	'emcpy from 0x0?!: %p %p %Iu', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LODJHCDC@Couldn?8t?5create?5screen?5shot?5?$CIal@
CONST	SEGMENT
??_C@_0DL@LODJHCDC@Couldn?8t?5create?5screen?5shot?5?$CIal@ DB 'Couldn''t'
	DB	' create screen shot (all 10000 slots used!) in %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JBEGIPMN@Couldn?8t?5create?5screen?5shot?5?$CFs?5@
CONST	SEGMENT
??_C@_0CG@JBEGIPMN@Couldn?8t?5create?5screen?5shot?5?$CFs?5@ DB 'Couldn'''
	DB	't create screen shot %s in %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EKELNKMB@screen?5shot?5?$CFs?5saved?5in?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@EKELNKMB@screen?5shot?5?$CFs?5saved?5in?5?$CFs?6@ DB 'screen sh'
	DB	'ot %s saved in %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JJFBJPLK@Can?8t?5take?5a?5screenshot?5without@
CONST	SEGMENT
??_C@_0DA@JJFBJPLK@Can?8t?5take?5a?5screenshot?5without@ DB 'Can''t take '
	DB	'a screenshot without a render system', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJIJAGL@tga@
CONST	SEGMENT
??_C@_03LJIJAGL@tga@ DB 'tga', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BIPDAGPI@pcx@
CONST	SEGMENT
??_C@_03BIPDAGPI@pcx@ DB 'pcx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?freename@?1??Newsnapshotfile@@9@9 DB 'srb2XXXX.ext', 00H ; `Newsnapshotfile'::`2'::freename
_DATA	ENDS
;	COMDAT ??_C@_0BN@PDDANKFG@?1?1?5SRB2?5configuration?5file?4?6@
CONST	SEGMENT
??_C@_0BN@PDDANKFG@?1?1?5SRB2?5configuration?5file?4?6@ DB '// SRB2 confi'
	DB	'guration file.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FMPONOCB@Couldn?8t?5save?5game?5config?5file?5@
CONST	SEGMENT
??_C@_0CD@FMPONOCB@Couldn?8t?5save?5game?5config?5file?5@ DB 'Couldn''t s'
	DB	'ave game config file %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IJCKCNG@M_SaveConfig?$CI?$CJ?3?5filename?5is?5not@
CONST	SEGMENT
??_C@_0CG@IJCKCNG@M_SaveConfig?$CI?$CJ?3?5filename?5is?5not@ DB 'M_SaveCo'
	DB	'nfig(): filename is not .cfg', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EMBFEKE@config?5file?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@EMBFEKE@config?5file?3?5?$CFs?6@ DB 'config file: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOKHNANK@?9config@
CONST	SEGMENT
??_C@_07OOKHNANK@?9config@ DB '-config', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAOMBPIH@loadconfig?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BB@CAOMBPIH@loadconfig?5?$CC?$CFs?$CC?6@ DB 'loadconfig "%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JDNBDCKH@saveconfig?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BB@JDNBDCKH@saveconfig?5?$CC?$CFs?$CC?6@ DB 'saveconfig "%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JNENEDAE@changeconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3@
CONST	SEGMENT
??_C@_0EG@JNENEDAE@changeconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3@ DB 'c'
	DB	'hangeconfig <filename[.cfg]> : save current config and load a'
	DB	'nother', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMKBJKBF@exec?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0L@CMKBJKBF@exec?5?$CC?$CFs?$CC?6@ DB 'exec "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IKJCMNIF@loadconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3?5l@
CONST	SEGMENT
??_C@_0DH@IKJCMNIF@loadconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3?5l@ DB 'l'
	DB	'oadconfig <filename[.cfg]> : load config from a file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LFKJPNBC@config?5saved?5as?5?$CFs?6@
CONST	SEGMENT
??_C@_0BE@LFKJPNBC@config?5saved?5as?5?$CFs?6@ DB 'config saved as %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDPFAEJA@?9silent@
CONST	SEGMENT
??_C@_07FDPFAEJA@?9silent@ DB '-silent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFJILJI@?4cfg@
CONST	SEGMENT
??_C@_04IFJILJI@?4cfg@ DB '.cfg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@OPJHDKAI@saveconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?$FL?9s@
CONST	SEGMENT
??_C@_0DP@OPJHDKAI@saveconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?$FL?9s@ DB 's'
	DB	'aveconfig <filename[.cfg]> [-silent] : save config to a file', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELIABIOC@w?$CLb@
CONST	SEGMENT
??_C@_03ELIABIOC@w?$CLb@ DB 'w+b', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	05fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	09dH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _mmx_cpy
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_n$ = 16						; size = 4
_mmx_cpy PROC						; COMDAT

; 1659 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1660 : #if defined (_MSC_VER) && defined (_X86_)
; 1661 : 	_asm
; 1662 : 	{
; 1663 : 		mov ecx, [n]

  00009	8b 4d 10	 mov	 ecx, DWORD PTR _n$[ebp]

; 1664 : 		mov esi, [src]

  0000c	8b 75 0c	 mov	 esi, DWORD PTR _src$[ebp]

; 1665 : 		mov edi, [dest]

  0000f	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1666 : 		shr ecx, 6 // mit mmx: 64bytes per iteration

  00012	c1 e9 06	 shr	 ecx, 6

; 1667 : 		jz lower_64 // if lower than 64 bytes

  00015	74 49		 je	 SHORT $lower_64$3
$loop_64$4:

; 1668 : 		loop_64: // MMX transfers multiples of 64bytes
; 1669 : 		movq mm0,  0[ESI] // read sources

  00017	0f 6f 06	 movq	 mm0, MMWORD PTR [esi]

; 1670 : 		movq mm1,  8[ESI]

  0001a	0f 6f 4e 08	 movq	 mm1, MMWORD PTR [esi+8]

; 1671 : 		movq mm2, 16[ESI]

  0001e	0f 6f 56 10	 movq	 mm2, MMWORD PTR [esi+16]

; 1672 : 		movq mm3, 24[ESI]

  00022	0f 6f 5e 18	 movq	 mm3, MMWORD PTR [esi+24]

; 1673 : 		movq mm4, 32[ESI]

  00026	0f 6f 66 20	 movq	 mm4, MMWORD PTR [esi+32]

; 1674 : 		movq mm5, 40[ESI]

  0002a	0f 6f 6e 28	 movq	 mm5, MMWORD PTR [esi+40]

; 1675 : 		movq mm6, 48[ESI]

  0002e	0f 6f 76 30	 movq	 mm6, MMWORD PTR [esi+48]

; 1676 : 		movq mm7, 56[ESI]

  00032	0f 6f 7e 38	 movq	 mm7, MMWORD PTR [esi+56]

; 1677 : 
; 1678 : 		movq  0[EDI], mm0 // write destination

  00036	0f 7f 07	 movq	 MMWORD PTR [edi], mm0

; 1679 : 		movq  8[EDI], mm1

  00039	0f 7f 4f 08	 movq	 MMWORD PTR [edi+8], mm1

; 1680 : 		movq 16[EDI], mm2

  0003d	0f 7f 57 10	 movq	 MMWORD PTR [edi+16], mm2

; 1681 : 		movq 24[EDI], mm3

  00041	0f 7f 5f 18	 movq	 MMWORD PTR [edi+24], mm3

; 1682 : 		movq 32[EDI], mm4

  00045	0f 7f 67 20	 movq	 MMWORD PTR [edi+32], mm4

; 1683 : 		movq 40[EDI], mm5

  00049	0f 7f 6f 28	 movq	 MMWORD PTR [edi+40], mm5

; 1684 : 		movq 48[EDI], mm6

  0004d	0f 7f 77 30	 movq	 MMWORD PTR [edi+48], mm6

; 1685 : 		movq 56[EDI], mm7

  00051	0f 7f 7f 38	 movq	 MMWORD PTR [edi+56], mm7

; 1686 : 
; 1687 : 		add esi, 64

  00055	83 c6 40	 add	 esi, 64			; 00000040H

; 1688 : 		add edi, 64

  00058	83 c7 40	 add	 edi, 64			; 00000040H

; 1689 : 		dec ecx

  0005b	49		 dec	 ecx

; 1690 : 		jnz loop_64

  0005c	75 b9		 jne	 SHORT $loop_64$4

; 1691 : 		emms // close mmx operation

  0005e	0f 77		 emms
$lower_64$3:

; 1692 : 		lower_64:// transfer rest of buffer
; 1693 : 		mov ebx,esi

  00060	8b de		 mov	 ebx, esi

; 1694 : 		sub ebx,src

  00062	2b 5d 0c	 sub	 ebx, DWORD PTR _src$[ebp]

; 1695 : 		mov ecx,[n]

  00065	8b 4d 10	 mov	 ecx, DWORD PTR _n$[ebp]

; 1696 : 		sub ecx,ebx

  00068	2b cb		 sub	 ecx, ebx

; 1697 : 		shr ecx, 3 // multiples of 8 bytes

  0006a	c1 e9 03	 shr	 ecx, 3

; 1698 : 		jz lower_8

  0006d	74 11		 je	 SHORT $lower_8$5
$loop_8$6:

; 1699 : 		loop_8:
; 1700 : 		movq  mm0, [esi] // read source

  0006f	0f 6f 06	 movq	 mm0, MMWORD PTR [esi]

; 1701 : 		movq [edi], mm0 // write destination

  00072	0f 7f 07	 movq	 MMWORD PTR [edi], mm0

; 1702 : 		add esi, 8

  00075	83 c6 08	 add	 esi, 8

; 1703 : 		add edi, 8

  00078	83 c7 08	 add	 edi, 8

; 1704 : 		dec ecx

  0007b	49		 dec	 ecx

; 1705 : 		jnz loop_8

  0007c	75 f1		 jne	 SHORT $loop_8$6

; 1706 : 		emms // close mmx operation

  0007e	0f 77		 emms
$lower_8$5:

; 1707 : 		lower_8:
; 1708 : 		mov ebx,esi

  00080	8b de		 mov	 ebx, esi

; 1709 : 		sub ebx,src

  00082	2b 5d 0c	 sub	 ebx, DWORD PTR _src$[ebp]

; 1710 : 		mov ecx,[n]

  00085	8b 4d 10	 mov	 ecx, DWORD PTR _n$[ebp]

; 1711 : 		sub ecx,ebx

  00088	2b cb		 sub	 ecx, ebx

; 1712 : 		rep movsb

  0008a	f3 a4		 rep	  movsb

; 1713 : 		mov eax, [dest] // return dest

  0008c	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1714 : 	}
; 1715 : #elif defined (__GNUC__) && defined (__i386__)
; 1716 : 	void *retval = dest;
; 1717 : 	size_t i;
; 1718 : 
; 1719 : 	if (n >= MMX1_MIN_LEN)
; 1720 : 	{
; 1721 : 		register unsigned long int delta;
; 1722 : 		/* Align destinition to MMREG_SIZE -boundary */
; 1723 : 		delta = ((unsigned long int)dest)&(MMX_MMREG_SIZE-1);
; 1724 : 		if (delta)
; 1725 : 		{
; 1726 : 			delta=MMX_MMREG_SIZE-delta;
; 1727 : 			n -= delta;
; 1728 : 			small_memcpy(dest, src, delta);
; 1729 : 		}
; 1730 : 		i = n >> 6; /* n/64 */
; 1731 : 		n&=63;
; 1732 : 		for (; i>0; i--)
; 1733 : 		{
; 1734 : 			__asm__ __volatile__ (
; 1735 : 				"movq (%0), %%mm0;"
; 1736 : 				"movq 8(%0), %%mm1;"
; 1737 : 				"movq 16(%0), %%mm2;"
; 1738 : 				"movq 24(%0), %%mm3;"
; 1739 : 				"movq 32(%0), %%mm4;"
; 1740 : 				"movq 40(%0), %%mm5;"
; 1741 : 				"movq 48(%0), %%mm6;"
; 1742 : 				"movq 56(%0), %%mm7;"
; 1743 : 				"movq %%mm0, (%1);"
; 1744 : 				"movq %%mm1, 8(%1);"
; 1745 : 				"movq %%mm2, 16(%1);"
; 1746 : 				"movq %%mm3, 24(%1);"
; 1747 : 				"movq %%mm4, 32(%1);"
; 1748 : 				"movq %%mm5, 40(%1);"
; 1749 : 				"movq %%mm6, 48(%1);"
; 1750 : 				"movq %%mm7, 56(%1);"
; 1751 : 			:: "r" (src), "r" (dest) : "memory");
; 1752 : 			src = ((const unsigned char *)src) + 64;
; 1753 : 			dest = ((unsigned char *)dest) + 64;
; 1754 : 		}
; 1755 : 		__asm__ __volatile__ ("emms":::"memory");
; 1756 : 	}
; 1757 : 	/*
; 1758 : 	 *	Now do the tail of the block
; 1759 : 	 */
; 1760 : 	if (n) __memcpy(dest, src, n);
; 1761 : 	return retval;
; 1762 : #else
; 1763 : 	return cpu_cpy(dest, src, n);
; 1764 : #endif
; 1765 : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_mmx_cpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _cpu_cpy
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_n$ = 16						; size = 4
_cpu_cpy PROC						; COMDAT

; 1642 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1643 : 	if(src == NULL)

  00009	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  0000d	75 1e		 jne	 SHORT $LN2@cpu_cpy

; 1644 : 	{
; 1645 : 		I_OutputMsg("Memcpy from 0x0?!: %p %p %"PRIdS"\n", dest, src, n);

  0000f	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0001a	52		 push	 edx
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HDOGFIMO@Memcpy?5from?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@
  00020	e8 00 00 00 00	 call	 _I_OutputMsg
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 1646 : 		return dest;

  00028	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0002b	eb 38		 jmp	 SHORT $LN1@cpu_cpy
$LN2@cpu_cpy:

; 1647 : 	}
; 1648 : 
; 1649 : 	if(dest == NULL)

  0002d	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00031	75 1e		 jne	 SHORT $LN3@cpu_cpy

; 1650 : 	{
; 1651 : 		I_OutputMsg("Memcpy to 0x0?!: %p %p %"PRIdS"\n", dest, src, n);

  00033	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0003e	52		 push	 edx
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GKHKLCEK@Memcpy?5to?50x0?$DP?$CB?3?5?$CFp?5?$CFp?5?$CFIu?6@
  00044	e8 00 00 00 00	 call	 _I_OutputMsg
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 1652 : 		return dest;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0004f	eb 14		 jmp	 SHORT $LN1@cpu_cpy
$LN3@cpu_cpy:

; 1653 : 	}
; 1654 : 
; 1655 : 	return memcpy(dest, src, n);

  00051	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _memcpy
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@cpu_cpy:

; 1656 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_cpu_cpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _WritePCXfile
_TEXT	SEGMENT
_pack$ = -16						; size = 4
_pcx$ = -12						; size = 4
_length$ = -8						; size = 4
_i$ = -4						; size = 4
_filename$ = 8						; size = 4
_data$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_palette$ = 24						; size = 4
_WritePCXfile PROC					; COMDAT

; 1186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1187 : 	int i;
; 1188 : 	size_t length;
; 1189 : 	pcx_t *pcx;
; 1190 : 	UINT8 *pack;
; 1191 : 
; 1192 : 	pcx = Z_Malloc(width*height*2 + 1000, PU_STATIC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 01		 push	 1
  0000f	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00012	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00016	8d 8c 00 e8 03
	00 00		 lea	 ecx, DWORD PTR [eax+eax+1000]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _Z_MallocAlign
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	89 45 f4	 mov	 DWORD PTR _pcx$[ebp], eax

; 1193 : 
; 1194 : 	pcx->manufacturer = 0x0a; // PCX id

  00029	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  0002c	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH

; 1195 : 	pcx->version = 5; // 256 color

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  00032	c6 40 01 05	 mov	 BYTE PTR [eax+1], 5

; 1196 : 	pcx->encoding = 1; // uncompressed

  00036	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  00039	c6 40 02 01	 mov	 BYTE PTR [eax+2], 1

; 1197 : 	pcx->bits_per_pixel = 8; // 256 color

  0003d	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  00040	c6 40 03 08	 mov	 BYTE PTR [eax+3], 8

; 1198 : 	pcx->xmin = pcx->ymin = 0;

  00044	33 c0		 xor	 eax, eax
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _pcx$[ebp]
  00049	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0004d	33 d2		 xor	 edx, edx
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  00052	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 1199 : 	pcx->xmax = SHORT(width - 1);

  00056	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00059	83 e8 01	 sub	 eax, 1
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _pcx$[ebp]
  0005f	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 1200 : 	pcx->ymax = SHORT(height - 1);

  00063	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]
  00066	83 e8 01	 sub	 eax, 1
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _pcx$[ebp]
  0006c	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 1201 : 	pcx->hres = SHORT(width);

  00070	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  00073	66 8b 4d 10	 mov	 cx, WORD PTR _width$[ebp]
  00077	66 89 48 0c	 mov	 WORD PTR [eax+12], cx

; 1202 : 	pcx->vres = SHORT(height);

  0007b	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  0007e	66 8b 4d 14	 mov	 cx, WORD PTR _height$[ebp]
  00082	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 1203 : 	memset(pcx->palette, 0, sizeof (pcx->palette));

  00086	6a 30		 push	 48			; 00000030H
  00088	6a 00		 push	 0
  0008a	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  0008d	83 c0 10	 add	 eax, 16			; 00000010H
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _memset
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1204 : 	pcx->reserved = 0;

  00099	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  0009c	c6 40 40 00	 mov	 BYTE PTR [eax+64], 0

; 1205 : 	pcx->color_planes = 1; // chunky image

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  000a3	c6 40 41 01	 mov	 BYTE PTR [eax+65], 1

; 1206 : 	pcx->bytes_per_line = SHORT(width);

  000a7	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  000aa	66 8b 4d 10	 mov	 cx, WORD PTR _width$[ebp]
  000ae	66 89 48 42	 mov	 WORD PTR [eax+66], cx

; 1207 : 	pcx->palette_type = SHORT(1); // not a grey scale

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _pcx$[ebp]
  000ba	66 89 41 44	 mov	 WORD PTR [ecx+68], ax

; 1208 : 	memset(pcx->filler, 0, sizeof (pcx->filler));

  000be	6a 3a		 push	 58			; 0000003aH
  000c0	6a 00		 push	 0
  000c2	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  000c5	83 c0 46	 add	 eax, 70			; 00000046H
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _memset
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1209 : 
; 1210 : 	// pack the image
; 1211 : 	pack = &pcx->data;

  000d1	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  000d4	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000d9	89 45 f0	 mov	 DWORD PTR _pack$[ebp], eax

; 1212 : 
; 1213 : 	for (i = 0; i < width*height; i++)

  000dc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e3	eb 09		 jmp	 SHORT $LN4@WritePCXfi
$LN2@WritePCXfi:
  000e5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e8	83 c0 01	 add	 eax, 1
  000eb	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@WritePCXfi:
  000ee	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  000f1	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  000f5	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000f8	7d 5f		 jge	 SHORT $LN3@WritePCXfi

; 1214 : 	{
; 1215 : 		if ((*data & 0xc0) != 0xc0)

  000fa	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  000fd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00100	81 e1 c0 00 00
	00		 and	 ecx, 192		; 000000c0H
  00106	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  0010c	74 1e		 je	 SHORT $LN8@WritePCXfi

; 1216 : 			*pack++ = *data++;

  0010e	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  00111	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00114	8a 11		 mov	 dl, BYTE PTR [ecx]
  00116	88 10		 mov	 BYTE PTR [eax], dl
  00118	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  0011b	83 c0 01	 add	 eax, 1
  0011e	89 45 f0	 mov	 DWORD PTR _pack$[ebp], eax
  00121	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d 0c	 mov	 DWORD PTR _data$[ebp], ecx
  0012a	eb 2b		 jmp	 SHORT $LN9@WritePCXfi
$LN8@WritePCXfi:

; 1217 : 		else
; 1218 : 		{
; 1219 : 			*pack++ = 0xc1;

  0012c	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  0012f	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00132	8b 4d f0	 mov	 ecx, DWORD PTR _pack$[ebp]
  00135	83 c1 01	 add	 ecx, 1
  00138	89 4d f0	 mov	 DWORD PTR _pack$[ebp], ecx

; 1220 : 			*pack++ = *data++;

  0013b	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  0013e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00141	8a 11		 mov	 dl, BYTE PTR [ecx]
  00143	88 10		 mov	 BYTE PTR [eax], dl
  00145	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 45 f0	 mov	 DWORD PTR _pack$[ebp], eax
  0014e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00151	83 c1 01	 add	 ecx, 1
  00154	89 4d 0c	 mov	 DWORD PTR _data$[ebp], ecx
$LN9@WritePCXfi:

; 1221 : 		}
; 1222 : 	}

  00157	eb 8c		 jmp	 SHORT $LN2@WritePCXfi
$LN3@WritePCXfi:

; 1223 : 
; 1224 : 	// write the palette
; 1225 : 	*pack++ = 0x0c; // palette ID byte

  00159	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  0015c	c6 00 0c	 mov	 BYTE PTR [eax], 12	; 0000000cH
  0015f	8b 4d f0	 mov	 ecx, DWORD PTR _pack$[ebp]
  00162	83 c1 01	 add	 ecx, 1
  00165	89 4d f0	 mov	 DWORD PTR _pack$[ebp], ecx

; 1226 : 	for (i = 0; i < 768; i++)

  00168	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0016f	eb 09		 jmp	 SHORT $LN7@WritePCXfi
$LN5@WritePCXfi:
  00171	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00174	83 c0 01	 add	 eax, 1
  00177	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@WritePCXfi:
  0017a	81 7d fc 00 03
	00 00		 cmp	 DWORD PTR _i$[ebp], 768	; 00000300H
  00181	7d 1e		 jge	 SHORT $LN6@WritePCXfi

; 1227 : 		*pack++ = *palette++;

  00183	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  00186	8b 4d 18	 mov	 ecx, DWORD PTR _palette$[ebp]
  00189	8a 11		 mov	 dl, BYTE PTR [ecx]
  0018b	88 10		 mov	 BYTE PTR [eax], dl
  0018d	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	89 45 f0	 mov	 DWORD PTR _pack$[ebp], eax
  00196	8b 4d 18	 mov	 ecx, DWORD PTR _palette$[ebp]
  00199	83 c1 01	 add	 ecx, 1
  0019c	89 4d 18	 mov	 DWORD PTR _palette$[ebp], ecx
  0019f	eb d0		 jmp	 SHORT $LN5@WritePCXfi
$LN6@WritePCXfi:

; 1228 : 
; 1229 : 	// write output file
; 1230 : 	length = pack - (UINT8 *)pcx;

  001a1	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  001a4	2b 45 f4	 sub	 eax, DWORD PTR _pcx$[ebp]
  001a7	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 1231 : 	i = FIL_WriteFile(filename, pcx, length);

  001aa	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]
  001ad	50		 push	 eax
  001ae	8b 4d f4	 mov	 ecx, DWORD PTR _pcx$[ebp]
  001b1	51		 push	 ecx
  001b2	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 _FIL_WriteFile
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001be	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 1232 : 
; 1233 : 	Z_Free(pcx);

  001c1	8b 45 f4	 mov	 eax, DWORD PTR _pcx$[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _Z_Free
  001ca	83 c4 04	 add	 esp, 4

; 1234 : 	return i;

  001cd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 1235 : }

  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c3		 ret	 0
_WritePCXfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _Newsnapshotfile
_TEXT	SEGMENT
_result$ = -12						; size = 4
_add$ = -8						; size = 4
_i$ = -4						; size = 4
_pathname$ = 8						; size = 4
_ext$ = 12						; size = 4
_Newsnapshotfile PROC					; COMDAT

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 510  : 	static char freename[13] = "srb2XXXX.ext";
; 511  : 	int i = 5000; // start in the middle: num screenshots divided by 2

  00009	c7 45 fc 88 13
	00 00		 mov	 DWORD PTR _i$[ebp], 5000 ; 00001388H

; 512  : 	int add = i; // how much to add or subtract if wrong; gets divided by 2 each time

  00010	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR _add$[ebp], eax

; 513  : 	int result; // -1 = guess too high, 0 = correct, 1 = guess too low
; 514  : 
; 515  : 	// find a file name to save it to
; 516  : 	strcpy(freename+9,ext);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _ext$[ebp]
  00019	50		 push	 eax
  0001a	68 09 00 00 00	 push	 OFFSET ?freename@?1??Newsnapshotfile@@9@9+9
  0001f	e8 00 00 00 00	 call	 _strcpy
  00024	83 c4 08	 add	 esp, 8
$LN2@Newsnapsho:

; 517  : 
; 518  : 	for (;;)
; 519  : 	{
; 520  : 		freename[4] = (char)('0' + (char)(i/1000));

  00027	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	99		 cdq
  0002b	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00030	f7 f9		 idiv	 ecx
  00032	0f be d0	 movsx	 edx, al
  00035	83 c2 30	 add	 edx, 48			; 00000030H
  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	c1 e0 02	 shl	 eax, 2
  00040	88 90 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[eax], dl

; 521  : 		freename[5] = (char)('0' + (char)((i/100)%10));

  00046	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00049	99		 cdq
  0004a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0004f	f7 f9		 idiv	 ecx
  00051	99		 cdq
  00052	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00057	f7 f9		 idiv	 ecx
  00059	0f be d2	 movsx	 edx, dl
  0005c	83 c2 30	 add	 edx, 48			; 00000030H
  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	6b c8 05	 imul	 ecx, eax, 5
  00067	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 522  : 		freename[6] = (char)('0' + (char)((i/10)%10));

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00070	99		 cdq
  00071	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00076	f7 f9		 idiv	 ecx
  00078	99		 cdq
  00079	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0007e	f7 f9		 idiv	 ecx
  00080	0f be d2	 movsx	 edx, dl
  00083	83 c2 30	 add	 edx, 48			; 00000030H
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	6b c8 06	 imul	 ecx, eax, 6
  0008e	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 523  : 		freename[7] = (char)('0' + (char)(i%10));

  00094	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00097	99		 cdq
  00098	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0009d	f7 f9		 idiv	 ecx
  0009f	0f be d2	 movsx	 edx, dl
  000a2	83 c2 30	 add	 edx, 48			; 00000030H
  000a5	b8 01 00 00 00	 mov	 eax, 1
  000aa	6b c8 07	 imul	 ecx, eax, 7
  000ad	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 524  : 
; 525  : 		if (FIL_WriteFileOK(va(pandf,pathname,freename))) // access succeeds

  000b3	68 00 00 00 00	 push	 OFFSET ?freename@?1??Newsnapshotfile@@9@9
  000b8	8b 45 08	 mov	 eax, DWORD PTR _pathname$[ebp]
  000bb	50		 push	 eax
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 _va
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _FIL_WriteFileOK
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	74 0c		 je	 SHORT $LN5@Newsnapsho

; 526  : 			result = 1; // too low

  000d8	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1
  000df	e9 d3 00 00 00	 jmp	 $LN9@Newsnapsho
$LN5@Newsnapsho:

; 527  : 		else // access fails: equal or too high
; 528  : 		{
; 529  : 			if (!i)

  000e4	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  000e8	75 05		 jne	 SHORT $LN7@Newsnapsho

; 530  : 				break; // not too high, so it must be equal! YAY!

  000ea	e9 04 01 00 00	 jmp	 $LN3@Newsnapsho
$LN7@Newsnapsho:

; 531  : 
; 532  : 			freename[4] = (char)('0' + (char)((i-1)/1000));

  000ef	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000f2	83 e8 01	 sub	 eax, 1
  000f5	99		 cdq
  000f6	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000fb	f7 f9		 idiv	 ecx
  000fd	0f be d0	 movsx	 edx, al
  00100	83 c2 30	 add	 edx, 48			; 00000030H
  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	c1 e0 02	 shl	 eax, 2
  0010b	88 90 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[eax], dl

; 533  : 			freename[5] = (char)('0' + (char)(((i-1)/100)%10));

  00111	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00114	83 e8 01	 sub	 eax, 1
  00117	99		 cdq
  00118	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0011d	f7 f9		 idiv	 ecx
  0011f	99		 cdq
  00120	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00125	f7 f9		 idiv	 ecx
  00127	0f be d2	 movsx	 edx, dl
  0012a	83 c2 30	 add	 edx, 48			; 00000030H
  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	6b c8 05	 imul	 ecx, eax, 5
  00135	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 534  : 			freename[6] = (char)('0' + (char)(((i-1)/10)%10));

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013e	83 e8 01	 sub	 eax, 1
  00141	99		 cdq
  00142	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00147	f7 f9		 idiv	 ecx
  00149	99		 cdq
  0014a	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0014f	f7 f9		 idiv	 ecx
  00151	0f be d2	 movsx	 edx, dl
  00154	83 c2 30	 add	 edx, 48			; 00000030H
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	6b c8 06	 imul	 ecx, eax, 6
  0015f	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 535  : 			freename[7] = (char)('0' + (char)((i-1)%10));

  00165	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00168	83 e8 01	 sub	 eax, 1
  0016b	99		 cdq
  0016c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00171	f7 f9		 idiv	 ecx
  00173	0f be d2	 movsx	 edx, dl
  00176	83 c2 30	 add	 edx, 48			; 00000030H
  00179	b8 01 00 00 00	 mov	 eax, 1
  0017e	6b c8 07	 imul	 ecx, eax, 7
  00181	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 536  : 			if (!FIL_WriteFileOK(va(pandf,pathname,freename))) // access fails

  00187	68 00 00 00 00	 push	 OFFSET ?freename@?1??Newsnapshotfile@@9@9
  0018c	8b 45 08	 mov	 eax, DWORD PTR _pathname$[ebp]
  0018f	50		 push	 eax
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pandf
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 _va
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _FIL_WriteFileOK
  001a5	83 c4 04	 add	 esp, 4
  001a8	85 c0		 test	 eax, eax
  001aa	75 09		 jne	 SHORT $LN8@Newsnapsho

; 537  : 				result = -1; // too high

  001ac	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _result$[ebp], -1
  001b3	eb 02		 jmp	 SHORT $LN9@Newsnapsho
$LN8@Newsnapsho:

; 538  : 			else
; 539  : 				break; // not too high, so equal, YAY!

  001b5	eb 3c		 jmp	 SHORT $LN3@Newsnapsho
$LN9@Newsnapsho:

; 540  : 		}
; 541  : 
; 542  : 		add /= 2;

  001b7	8b 45 f8	 mov	 eax, DWORD PTR _add$[ebp]
  001ba	99		 cdq
  001bb	2b c2		 sub	 eax, edx
  001bd	d1 f8		 sar	 eax, 1
  001bf	89 45 f8	 mov	 DWORD PTR _add$[ebp], eax

; 543  : 
; 544  : 		if (!add) // don't get stuck at 5 due to truncation!

  001c2	75 07		 jne	 SHORT $LN10@Newsnapsho

; 545  : 			add = 1;

  001c4	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _add$[ebp], 1
$LN10@Newsnapsho:

; 546  : 
; 547  : 		i += add * result;

  001cb	8b 45 f8	 mov	 eax, DWORD PTR _add$[ebp]
  001ce	0f af 45 f4	 imul	 eax, DWORD PTR _result$[ebp]
  001d2	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  001d5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 548  : 
; 549  : 		if (add < 0 || add > 9999)

  001d8	83 7d f8 00	 cmp	 DWORD PTR _add$[ebp], 0
  001dc	7c 09		 jl	 SHORT $LN12@Newsnapsho
  001de	81 7d f8 0f 27
	00 00		 cmp	 DWORD PTR _add$[ebp], 9999 ; 0000270fH
  001e5	7e 07		 jle	 SHORT $LN11@Newsnapsho
$LN12@Newsnapsho:

; 550  : 			return NULL;

  001e7	33 c0		 xor	 eax, eax
  001e9	e9 96 00 00 00	 jmp	 $LN1@Newsnapsho
$LN11@Newsnapsho:

; 551  : 	}

  001ee	e9 34 fe ff ff	 jmp	 $LN2@Newsnapsho
$LN3@Newsnapsho:

; 552  : 
; 553  : 	freename[4] = (char)('0' + (char)(i/1000));

  001f3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001f6	99		 cdq
  001f7	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  001fc	f7 f9		 idiv	 ecx
  001fe	0f be d0	 movsx	 edx, al
  00201	83 c2 30	 add	 edx, 48			; 00000030H
  00204	b8 01 00 00 00	 mov	 eax, 1
  00209	c1 e0 02	 shl	 eax, 2
  0020c	88 90 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[eax], dl

; 554  : 	freename[5] = (char)('0' + (char)((i/100)%10));

  00212	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00215	99		 cdq
  00216	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021b	f7 f9		 idiv	 ecx
  0021d	99		 cdq
  0021e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00223	f7 f9		 idiv	 ecx
  00225	0f be d2	 movsx	 edx, dl
  00228	83 c2 30	 add	 edx, 48			; 00000030H
  0022b	b8 01 00 00 00	 mov	 eax, 1
  00230	6b c8 05	 imul	 ecx, eax, 5
  00233	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 555  : 	freename[6] = (char)('0' + (char)((i/10)%10));

  00239	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0023c	99		 cdq
  0023d	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00242	f7 f9		 idiv	 ecx
  00244	99		 cdq
  00245	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0024a	f7 f9		 idiv	 ecx
  0024c	0f be d2	 movsx	 edx, dl
  0024f	83 c2 30	 add	 edx, 48			; 00000030H
  00252	b8 01 00 00 00	 mov	 eax, 1
  00257	6b c8 06	 imul	 ecx, eax, 6
  0025a	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 556  : 	freename[7] = (char)('0' + (char)(i%10));

  00260	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00263	99		 cdq
  00264	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00269	f7 f9		 idiv	 ecx
  0026b	0f be d2	 movsx	 edx, dl
  0026e	83 c2 30	 add	 edx, 48			; 00000030H
  00271	b8 01 00 00 00	 mov	 eax, 1
  00276	6b c8 07	 imul	 ecx, eax, 7
  00279	88 91 00 00 00
	00		 mov	 BYTE PTR ?freename@?1??Newsnapshotfile@@9@9[ecx], dl

; 557  : 
; 558  : 	return freename;

  0027f	b8 00 00 00 00	 mov	 eax, OFFSET ?freename@?1??Newsnapshotfile@@9@9
$LN1@Newsnapsho:

; 559  : }

  00284	5f		 pop	 edi
  00285	5e		 pop	 esi
  00286	5b		 pop	 ebx
  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c3		 ret	 0
_Newsnapshotfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _M_SetupMemcpy
_TEXT	SEGMENT
_M_SetupMemcpy PROC					; COMDAT

; 1773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1774 : #if defined (__GNUC__) && defined (__i386__)
; 1775 : 	if (R_SSE2)
; 1776 : 		M_Memcpy = sse_cpy;
; 1777 : 	else if (R_MMXExt)
; 1778 : 		M_Memcpy = mmx2_cpy;
; 1779 : 	else if (R_3DNow)
; 1780 : 		M_Memcpy = mmx1_cpy;
; 1781 : 	else
; 1782 : #endif
; 1783 : 	if (R_MMX)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _R_MMX, 0
  00010	74 0a		 je	 SHORT $LN2@M_SetupMem

; 1784 : 		M_Memcpy = mmx_cpy;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _M_Memcpy, OFFSET _mmx_cpy
$LN2@M_SetupMem:

; 1785 : #if 0
; 1786 : 	M_Memcpy = cpu_cpy;
; 1787 : #endif
; 1788 : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_M_SetupMemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _strcatbf
_TEXT	SEGMENT
_tmp$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_s3$ = 16						; size = 4
_strcatbf PROC						; COMDAT

; 1357 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 04 00
	00		 sub	 esp, 1220		; 000004c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1358 : 	char tmp[1024];
; 1359 : 
; 1360 : 	strcpy(tmp, s1);

  00016	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00019	50		 push	 eax
  0001a	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _tmp$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _strcpy
  00026	83 c4 08	 add	 esp, 8

; 1361 : 	strcpy(s1, s2);

  00029	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _strcpy
  00036	83 c4 08	 add	 esp, 8

; 1362 : 	strcat(s1, s3);

  00039	8b 45 10	 mov	 eax, DWORD PTR _s3$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _strcat
  00046	83 c4 08	 add	 esp, 8

; 1363 : 	strcat(s1, tmp);

  00049	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _strcat
  00059	83 c4 08	 add	 esp, 8

; 1364 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_strcatbf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _M_SaveConfig
_TEXT	SEGMENT
_f$ = -4						; size = 4
_filename$ = 8						; size = 4
_M_SaveConfig PROC					; COMDAT

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 454  : 	FILE *f;
; 455  : 
; 456  : 	// make sure not to write back the config until it's been correctly loaded
; 457  : 	if (!gameconfig_loaded)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gameconfig_loaded, 0
  00010	75 05		 jne	 SHORT $LN2@M_SaveConf

; 458  : 		return;

  00012	e9 04 01 00 00	 jmp	 $LN1@M_SaveConf
$LN2@M_SaveConf:

; 459  : 
; 460  : 	// can change the file name
; 461  : 	if (filename)

  00017	83 7d 08 00	 cmp	 DWORD PTR _filename$[ebp], 0
  0001b	74 6c		 je	 SHORT $LN3@M_SaveConf

; 462  : 	{
; 463  : 		if (!strstr(filename, ".cfg"))

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_04IFJILJI@?4cfg@
  00022	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strstr
  0002b	83 c4 08	 add	 esp, 8
  0002e	85 c0		 test	 eax, eax
  00030	75 12		 jne	 SHORT $LN5@M_SaveConf

; 464  : 		{
; 465  : 			CONS_Printf("M_SaveConfig(): filename is not .cfg\n");

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IJCKCNG@M_SaveConfig?$CI?$CJ?3?5filename?5is?5not@
  00037	e8 00 00 00 00	 call	 _CONS_Printf
  0003c	83 c4 04	 add	 esp, 4

; 466  : 			return;

  0003f	e9 d7 00 00 00	 jmp	 $LN1@M_SaveConf
$LN5@M_SaveConf:

; 467  : 		}
; 468  : 
; 469  : 		f = fopen(filename, "w");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  00049	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _fopen
  00052	83 c4 08	 add	 esp, 8
  00055	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 470  : 		// change it only if valid
; 471  : 		if (f)

  00058	83 7d fc 00	 cmp	 DWORD PTR _f$[ebp], 0
  0005c	74 13		 je	 SHORT $LN6@M_SaveConf

; 472  : 			strcpy(configfile, filename);

  0005e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET _configfile
  00067	e8 00 00 00 00	 call	 _strcpy
  0006c	83 c4 08	 add	 esp, 8
  0006f	eb 16		 jmp	 SHORT $LN7@M_SaveConf
$LN6@M_SaveConf:

; 473  : 		else
; 474  : 		{
; 475  : 			CONS_Printf("Couldn't save game config file %s\n", filename);

  00071	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FMPONOCB@Couldn?8t?5save?5game?5config?5file?5@
  0007a	e8 00 00 00 00	 call	 _CONS_Printf
  0007f	83 c4 08	 add	 esp, 8

; 476  : 			return;

  00082	e9 94 00 00 00	 jmp	 $LN1@M_SaveConf
$LN7@M_SaveConf:

; 477  : 		}
; 478  : 	}

  00087	eb 54		 jmp	 SHORT $LN9@M_SaveConf
$LN3@M_SaveConf:

; 479  : 	else
; 480  : 	{
; 481  : 		if (!strstr(configfile, ".cfg"))

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_04IFJILJI@?4cfg@
  0008e	68 00 00 00 00	 push	 OFFSET _configfile
  00093	e8 00 00 00 00	 call	 _strstr
  00098	83 c4 08	 add	 esp, 8
  0009b	85 c0		 test	 eax, eax
  0009d	75 0f		 jne	 SHORT $LN8@M_SaveConf

; 482  : 		{
; 483  : 			CONS_Printf("M_SaveConfig(): filename is not .cfg\n");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IJCKCNG@M_SaveConfig?$CI?$CJ?3?5filename?5is?5not@
  000a4	e8 00 00 00 00	 call	 _CONS_Printf
  000a9	83 c4 04	 add	 esp, 4

; 484  : 			return;

  000ac	eb 6d		 jmp	 SHORT $LN1@M_SaveConf
$LN8@M_SaveConf:

; 485  : 		}
; 486  : 
; 487  : 		f = fopen(configfile, "w");

  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  000b3	68 00 00 00 00	 push	 OFFSET _configfile
  000b8	e8 00 00 00 00	 call	 _fopen
  000bd	83 c4 08	 add	 esp, 8
  000c0	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 488  : 		if (!f)

  000c3	83 7d fc 00	 cmp	 DWORD PTR _f$[ebp], 0
  000c7	75 14		 jne	 SHORT $LN9@M_SaveConf

; 489  : 		{
; 490  : 			CONS_Printf("Couldn't save game config file %s\n", configfile);

  000c9	68 00 00 00 00	 push	 OFFSET _configfile
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FMPONOCB@Couldn?8t?5save?5game?5config?5file?5@
  000d3	e8 00 00 00 00	 call	 _CONS_Printf
  000d8	83 c4 08	 add	 esp, 8

; 491  : 			return;

  000db	eb 3e		 jmp	 SHORT $LN1@M_SaveConf
$LN9@M_SaveConf:

; 492  : 		}
; 493  : 	}
; 494  : 
; 495  : 	// header message
; 496  : 	fprintf(f, "// SRB2 configuration file.\n");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PDDANKFG@?1?1?5SRB2?5configuration?5file?4?6@
  000e2	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _fprintf
  000eb	83 c4 08	 add	 esp, 8

; 497  : 
; 498  : 	// FIXME: save key aliases if ever implemented..
; 499  : 
; 500  : 	CV_SaveVariables(f);

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _CV_SaveVariables
  000f7	83 c4 04	 add	 esp, 4

; 501  : 	if (!dedicated) G_SaveKeySetting(f);

  000fa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00101	75 0c		 jne	 SHORT $LN10@M_SaveConf
  00103	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _G_SaveKeySetting
  0010c	83 c4 04	 add	 esp, 4
$LN10@M_SaveConf:

; 502  : 
; 503  : 	fclose(f);

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _fclose
  00118	83 c4 04	 add	 esp, 4
$LN1@M_SaveConf:

; 504  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
_M_SaveConfig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _M_FirstLoadConfig
_TEXT	SEGMENT
_M_FirstLoadConfig PROC					; COMDAT

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 426  : 	// configfile is initialised by d_main when searching for the wad?
; 427  : 
; 428  : 	// check for a custom config file
; 429  : 	if (M_CheckParm("-config") && M_IsNextParm())

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_07OOKHNANK@?9config@
  0000e	e8 00 00 00 00	 call	 _M_CheckParm
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	74 2e		 je	 SHORT $LN2@M_FirstLoa
  0001a	e8 00 00 00 00	 call	 _M_IsNextParm
  0001f	85 c0		 test	 eax, eax
  00021	74 25		 je	 SHORT $LN2@M_FirstLoa

; 430  : 	{
; 431  : 		strcpy(configfile, M_GetNextParm());

  00023	e8 00 00 00 00	 call	 _M_GetNextParm
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET _configfile
  0002e	e8 00 00 00 00	 call	 _strcpy
  00033	83 c4 08	 add	 esp, 8

; 432  : 		CONS_Printf("config file: %s\n",configfile);

  00036	68 00 00 00 00	 push	 OFFSET _configfile
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EMBFEKE@config?5file?3?5?$CFs?6@
  00040	e8 00 00 00 00	 call	 _CONS_Printf
  00045	83 c4 08	 add	 esp, 8
$LN2@M_FirstLoa:

; 433  : 	}
; 434  : 
; 435  : 	// load default control
; 436  : 	G_Controldefault();

  00048	e8 00 00 00 00	 call	 _G_Controldefault
  0004d	90		 npad	 1

; 437  : 
; 438  : 	// load config, make sure those commands doesnt require the screen..
; 439  : 	CONS_Printf("\n");

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00053	e8 00 00 00 00	 call	 _CONS_Printf
  00058	83 c4 04	 add	 esp, 4

; 440  : 	COM_BufInsertText(va("exec \"%s\"\n", configfile));

  0005b	68 00 00 00 00	 push	 OFFSET _configfile
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CMKBJKBF@exec?5?$CC?$CFs?$CC?6@
  00065	e8 00 00 00 00	 call	 _va
  0006a	83 c4 08	 add	 esp, 8
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _COM_BufInsertText
  00073	83 c4 04	 add	 esp, 4

; 441  : 	// no COM_BufExecute() needed; that does it right away
; 442  : 
; 443  : 	// make sure I_Quit() will write back the correct config
; 444  : 	// (do not write back the config if it crash before)
; 445  : 	gameconfig_loaded = true;

  00076	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _gameconfig_loaded, 1

; 446  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_M_FirstLoadConfig ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _Command_ChangeConfig_f
_TEXT	SEGMENT
_Command_ChangeConfig_f PROC				; COMDAT

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 410  : 	if (COM_Argc() != 2)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 02	 cmp	 eax, 2
  00011	74 0f		 je	 SHORT $LN2@Command_Ch

; 411  : 	{
; 412  : 		CONS_Printf("changeconfig <filename[.cfg]> : save current config and load another\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@JNENEDAE@changeconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 413  : 		return;

  00020	eb 3c		 jmp	 SHORT $LN1@Command_Ch
$LN2@Command_Ch:

; 414  : 	}
; 415  : 
; 416  : 	COM_BufAddText(va("saveconfig \"%s\"\n", configfile));

  00022	68 00 00 00 00	 push	 OFFSET _configfile
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JDNBDCKH@saveconfig?5?$CC?$CFs?$CC?6@
  0002c	e8 00 00 00 00	 call	 _va
  00031	83 c4 08	 add	 esp, 8
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _COM_BufAddText
  0003a	83 c4 04	 add	 esp, 4

; 417  : 	COM_BufAddText(va("loadconfig \"%s\"\n", COM_Argv(1)));

  0003d	6a 01		 push	 1
  0003f	e8 00 00 00 00	 call	 _COM_Argv
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CAOMBPIH@loadconfig?5?$CC?$CFs?$CC?6@
  0004d	e8 00 00 00 00	 call	 _va
  00052	83 c4 08	 add	 esp, 8
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _COM_BufAddText
  0005b	83 c4 04	 add	 esp, 4
$LN1@Command_Ch:

; 418  : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_Command_ChangeConfig_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _Command_LoadConfig_f
_TEXT	SEGMENT
_Command_LoadConfig_f PROC				; COMDAT

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 393  : 	if (COM_Argc() != 2)

  00009	e8 00 00 00 00	 call	 _COM_Argc
  0000e	83 f8 02	 cmp	 eax, 2
  00011	74 0f		 je	 SHORT $LN2@Command_Lo

; 394  : 	{
; 395  : 		CONS_Printf("loadconfig <filename[.cfg]> : load config from a file\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@IKJCMNIF@loadconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?3?5l@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 396  : 		return;

  00020	eb 45		 jmp	 SHORT $LN1@Command_Lo
$LN2@Command_Lo:

; 397  : 	}
; 398  : 
; 399  : 	strcpy(configfile, COM_Argv(1));

  00022	6a 01		 push	 1
  00024	e8 00 00 00 00	 call	 _COM_Argv
  00029	83 c4 04	 add	 esp, 4
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET _configfile
  00032	e8 00 00 00 00	 call	 _strcpy
  00037	83 c4 08	 add	 esp, 8

; 400  : 	FIL_ForceExtension(configfile, ".cfg");

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_04IFJILJI@?4cfg@
  0003f	68 00 00 00 00	 push	 OFFSET _configfile
  00044	e8 00 00 00 00	 call	 _FIL_ForceExtension
  00049	83 c4 08	 add	 esp, 8

; 401  : 	COM_BufInsertText(va("exec \"%s\"\n", configfile));

  0004c	68 00 00 00 00	 push	 OFFSET _configfile
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CMKBJKBF@exec?5?$CC?$CFs?$CC?6@
  00056	e8 00 00 00 00	 call	 _va
  0005b	83 c4 08	 add	 esp, 8
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _COM_BufInsertText
  00064	83 c4 04	 add	 esp, 4
$LN1@Command_Lo:

; 402  : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_Command_LoadConfig_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _Command_SaveConfig_f
_TEXT	SEGMENT
_tmpstr$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_Command_SaveConfig_f PROC				; COMDAT

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 372  : 	char tmpstr[MAX_WADPATH];
; 373  : 
; 374  : 	if (COM_Argc() < 2)

  00016	e8 00 00 00 00	 call	 _COM_Argc
  0001b	83 f8 02	 cmp	 eax, 2
  0001e	73 0f		 jae	 SHORT $LN2@Command_Sa

; 375  : 	{
; 376  : 		CONS_Printf("saveconfig <filename[.cfg]> [-silent] : save config to a file\n");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@OPJHDKAI@saveconfig?5?$DMfilename?$FL?4cfg?$FN?$DO?5?$FL?9s@
  00025	e8 00 00 00 00	 call	 _CONS_Printf
  0002a	83 c4 04	 add	 esp, 4

; 377  : 		return;

  0002d	eb 6b		 jmp	 SHORT $LN3@Command_Sa
$LN2@Command_Sa:

; 378  : 	}
; 379  : 	strcpy(tmpstr, COM_Argv(1));

  0002f	6a 01		 push	 1
  00031	e8 00 00 00 00	 call	 _COM_Argv
  00036	83 c4 04	 add	 esp, 4
  00039	50		 push	 eax
  0003a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _tmpstr$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strcpy
  00046	83 c4 08	 add	 esp, 8

; 380  : 	FIL_ForceExtension(tmpstr, ".cfg");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_04IFJILJI@?4cfg@
  0004e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _tmpstr$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _FIL_ForceExtension
  0005a	83 c4 08	 add	 esp, 8

; 381  : 
; 382  : 	M_SaveConfig(tmpstr);

  0005d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _tmpstr$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _M_SaveConfig
  00069	83 c4 04	 add	 esp, 4

; 383  : 	if (stricmp(COM_Argv(2), "-silent"))

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_07FDPFAEJA@?9silent@
  00071	6a 02		 push	 2
  00073	e8 00 00 00 00	 call	 _COM_Argv
  00078	83 c4 04	 add	 esp, 4
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _stricmp
  00081	83 c4 08	 add	 esp, 8
  00084	85 c0		 test	 eax, eax
  00086	74 12		 je	 SHORT $LN3@Command_Sa

; 384  : 		CONS_Printf("config saved as %s\n", configfile);

  00088	68 00 00 00 00	 push	 OFFSET _configfile
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LFKJPNBC@config?5saved?5as?5?$CFs?6@
  00092	e8 00 00 00 00	 call	 _CONS_Printf
  00097	83 c4 08	 add	 esp, 8
$LN3@Command_Sa:

; 385  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	33 cd		 xor	 ecx, ebp
  000a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_Command_SaveConfig_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _M_DoScreenShot
_TEXT	SEGMENT
tv66 = -84						; size = 4
_linear$ = -16						; size = 4
_ret$ = -12						; size = 4
_pathname$ = -8						; size = 4
_freename$ = -4						; size = 4
_M_DoScreenShot PROC					; COMDAT

; 1252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1253 : #if NUMSCREENS > 2
; 1254 : 	const char *freename = NULL, *pathname = ".";

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _freename$[ebp], 0
  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pathname$[ebp], OFFSET ??_C@_01LFCBOECM@?4@

; 1255 : 	boolean ret = false;

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 1256 : 	UINT8 *linear = NULL;

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _linear$[ebp], 0

; 1257 : 
; 1258 : 	// Don't take multiple screenshots, obviously
; 1259 : 	takescreenshot = false;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _takescreenshot, 0

; 1260 : 
; 1261 : 	if (cv_screenshot_option.value == 0)

  0002f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_screenshot_option+20, 0
  00036	75 21		 jne	 SHORT $LN2@M_DoScreen

; 1262 : 		pathname = usehome ? srb2home : srb2path;

  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usehome, 0
  0003f	74 09		 je	 SHORT $LN24@M_DoScreen
  00041	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], OFFSET _srb2home
  00048	eb 07		 jmp	 SHORT $LN25@M_DoScreen
$LN24@M_DoScreen:
  0004a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], OFFSET _srb2path
$LN25@M_DoScreen:
  00051	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00054	89 45 f8	 mov	 DWORD PTR _pathname$[ebp], eax
  00057	eb 41		 jmp	 SHORT $LN8@M_DoScreen
$LN2@M_DoScreen:

; 1263 : 	else if (cv_screenshot_option.value == 1)

  00059	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _cv_screenshot_option+20, 1
  00060	75 09		 jne	 SHORT $LN4@M_DoScreen

; 1264 : 		pathname = srb2home;

  00062	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pathname$[ebp], OFFSET _srb2home
  00069	eb 2f		 jmp	 SHORT $LN8@M_DoScreen
$LN4@M_DoScreen:

; 1265 : 	else if (cv_screenshot_option.value == 2)

  0006b	83 3d 14 00 00
	00 02		 cmp	 DWORD PTR _cv_screenshot_option+20, 2
  00072	75 09		 jne	 SHORT $LN6@M_DoScreen

; 1266 : 		pathname = srb2path;

  00074	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pathname$[ebp], OFFSET _srb2path
  0007b	eb 1d		 jmp	 SHORT $LN8@M_DoScreen
$LN6@M_DoScreen:

; 1267 : 	else if (cv_screenshot_option.value == 3 && *cv_screenshot_folder.string != '\0')

  0007d	83 3d 14 00 00
	00 03		 cmp	 DWORD PTR _cv_screenshot_option+20, 3
  00084	75 14		 jne	 SHORT $LN8@M_DoScreen
  00086	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_screenshot_folder+24
  0008b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008e	85 c9		 test	 ecx, ecx
  00090	74 08		 je	 SHORT $LN8@M_DoScreen

; 1268 : 		pathname = cv_screenshot_folder.string;

  00092	a1 18 00 00 00	 mov	 eax, DWORD PTR _cv_screenshot_folder+24
  00097	89 45 f8	 mov	 DWORD PTR _pathname$[ebp], eax
$LN8@M_DoScreen:

; 1269 : 
; 1270 : #ifdef USE_PNG
; 1271 : 	if (rendermode != render_none)
; 1272 : 		freename = Newsnapshotfile(pathname,"png");
; 1273 : #else
; 1274 : 	if (rendermode == render_soft)

  0009a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000a1	75 16		 jne	 SHORT $LN9@M_DoScreen

; 1275 : 		freename = Newsnapshotfile(pathname,"pcx");

  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_03BIPDAGPI@pcx@
  000a8	8b 45 f8	 mov	 eax, DWORD PTR _pathname$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _Newsnapshotfile
  000b1	83 c4 08	 add	 esp, 8
  000b4	89 45 fc	 mov	 DWORD PTR _freename$[ebp], eax
  000b7	eb 2c		 jmp	 SHORT $LN12@M_DoScreen
$LN9@M_DoScreen:

; 1276 : 	else if (rendermode != render_none)

  000b9	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  000c0	74 16		 je	 SHORT $LN11@M_DoScreen

; 1277 : 		freename = Newsnapshotfile(pathname,"tga");

  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_03LJIJAGL@tga@
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _pathname$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _Newsnapshotfile
  000d0	83 c4 08	 add	 esp, 8
  000d3	89 45 fc	 mov	 DWORD PTR _freename$[ebp], eax
  000d6	eb 0d		 jmp	 SHORT $LN12@M_DoScreen
$LN11@M_DoScreen:

; 1278 : #endif
; 1279 : 	else
; 1280 : 		I_Error("Can't take a screenshot without a render system");

  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JJFBJPLK@Can?8t?5take?5a?5screenshot?5without@
  000dd	e8 00 00 00 00	 call	 _I_Error
  000e2	83 c4 04	 add	 esp, 4
$LN12@M_DoScreen:

; 1281 : 
; 1282 : 	if (rendermode == render_soft)

  000e5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000ec	75 1c		 jne	 SHORT $LN13@M_DoScreen

; 1283 : 	{
; 1284 : 		// munge planar buffer to linear
; 1285 : 		linear = screens[2];

  000ee	b8 04 00 00 00	 mov	 eax, 4
  000f3	d1 e0		 shl	 eax, 1
  000f5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  000fb	89 4d f0	 mov	 DWORD PTR _linear$[ebp], ecx

; 1286 : 		I_ReadScreen(linear);

  000fe	8b 45 f0	 mov	 eax, DWORD PTR _linear$[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _I_ReadScreen
  00107	83 c4 04	 add	 esp, 4
$LN13@M_DoScreen:

; 1287 : 	}
; 1288 : 
; 1289 : 	if (!freename)

  0010a	83 7d fc 00	 cmp	 DWORD PTR _freename$[ebp], 0
  0010e	75 02		 jne	 SHORT $LN14@M_DoScreen

; 1290 : 		goto failure;

  00110	eb 7c		 jmp	 SHORT $failure$26
$LN14@M_DoScreen:

; 1291 : 
; 1292 : 	// save the pcx file
; 1293 : #ifdef HWRENDER
; 1294 : 	if (rendermode != render_soft)

  00112	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00119	74 25		 je	 SHORT $LN15@M_DoScreen

; 1295 : 		ret = HWR_Screenshot(va(pandf,pathname,freename));

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _freename$[ebp]
  0011e	50		 push	 eax
  0011f	8b 4d f8	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00122	51		 push	 ecx
  00123	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pandf
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 _va
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _HWR_Screenshot
  00138	83 c4 04	 add	 esp, 4
  0013b	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax
  0013e	eb 4e		 jmp	 SHORT $failure$26
$LN15@M_DoScreen:

; 1296 : 	else
; 1297 : #endif
; 1298 : 	if (rendermode != render_none)

  00140	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00147	74 45		 je	 SHORT $failure$26

; 1299 : 	{
; 1300 : #ifdef USE_PNG
; 1301 : 		ret = M_SavePNG(va(pandf,pathname,freename), linear, vid.width, vid.height,
; 1302 : 			W_CacheLumpName(GetPalette(), PU_CACHE));
; 1303 : #else
; 1304 : 		ret = WritePCXfile(va(pandf,pathname,freename), linear, vid.width, vid.height,

  00149	6a 65		 push	 101			; 00000065H
  0014b	e8 00 00 00 00	 call	 _GetPalette
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _W_CacheLumpName
  00156	83 c4 08	 add	 esp, 8
  00159	50		 push	 eax
  0015a	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0015f	50		 push	 eax
  00160	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00166	51		 push	 ecx
  00167	8b 55 f0	 mov	 edx, DWORD PTR _linear$[ebp]
  0016a	52		 push	 edx
  0016b	8b 45 fc	 mov	 eax, DWORD PTR _freename$[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d f8	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00172	51		 push	 ecx
  00173	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pandf
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 _va
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _WritePCXfile
  00188	83 c4 14	 add	 esp, 20			; 00000014H
  0018b	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax
$failure$26:

; 1305 : 			W_CacheLumpName(GetPalette(), PU_CACHE));
; 1306 : #endif
; 1307 : 	}
; 1308 : 
; 1309 : failure:
; 1310 : 	if (ret)

  0018e	83 7d f4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00192	74 20		 je	 SHORT $LN18@M_DoScreen

; 1311 : 	{
; 1312 : 		if (!moviemode)

  00194	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _moviemode, 0
  0019b	75 15		 jne	 SHORT $LN20@M_DoScreen

; 1313 : 			CONS_Printf("screen shot %s saved in %s\n", freename, pathname);

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _pathname$[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d fc	 mov	 ecx, DWORD PTR _freename$[ebp]
  001a4	51		 push	 ecx
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EKELNKMB@screen?5shot?5?$CFs?5saved?5in?5?$CFs?6@
  001aa	e8 00 00 00 00	 call	 _CONS_Printf
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@M_DoScreen:

; 1314 : 	}

  001b2	eb 2e		 jmp	 SHORT $LN22@M_DoScreen
$LN18@M_DoScreen:

; 1315 : 	else
; 1316 : 	{
; 1317 : 		if (freename)

  001b4	83 7d fc 00	 cmp	 DWORD PTR _freename$[ebp], 0
  001b8	74 17		 je	 SHORT $LN21@M_DoScreen

; 1318 : 			CONS_Printf("Couldn't create screen shot %s in %s\n", freename, pathname);

  001ba	8b 45 f8	 mov	 eax, DWORD PTR _pathname$[ebp]
  001bd	50		 push	 eax
  001be	8b 4d fc	 mov	 ecx, DWORD PTR _freename$[ebp]
  001c1	51		 push	 ecx
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JBEGIPMN@Couldn?8t?5create?5screen?5shot?5?$CFs?5@
  001c7	e8 00 00 00 00	 call	 _CONS_Printf
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cf	eb 11		 jmp	 SHORT $LN22@M_DoScreen
$LN21@M_DoScreen:

; 1319 : 		else
; 1320 : 			CONS_Printf("Couldn't create screen shot (all 10000 slots used!) in %s\n", pathname);

  001d1	8b 45 f8	 mov	 eax, DWORD PTR _pathname$[ebp]
  001d4	50		 push	 eax
  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@LODJHCDC@Couldn?8t?5create?5screen?5shot?5?$CIal@
  001da	e8 00 00 00 00	 call	 _CONS_Printf
  001df	83 c4 08	 add	 esp, 8
$LN22@M_DoScreen:

; 1321 : 	}
; 1322 : #endif
; 1323 : }

  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
_M_DoScreenShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _M_ScreenShot
_TEXT	SEGMENT
_M_ScreenShot PROC					; COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1241 : 	takescreenshot = true;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _takescreenshot, 1

; 1242 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_M_ScreenShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_CheckExtension
_TEXT	SEGMENT
tv67 = -68						; size = 4
_in$ = 8						; size = 4
_FIL_CheckExtension PROC				; COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@FIL_CheckE:

; 344  : 	while (*in++)

  00009	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0000f	89 4d bc	 mov	 DWORD PTR tv67[ebp], ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00015	83 c2 01	 add	 edx, 1
  00018	89 55 08	 mov	 DWORD PTR _in$[ebp], edx
  0001b	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  0001f	74 14		 je	 SHORT $LN3@FIL_CheckE

; 345  : 		if (*in == '.')

  00021	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00027	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  0002a	75 07		 jne	 SHORT $LN4@FIL_CheckE

; 346  : 			return true;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	eb 04		 jmp	 SHORT $LN1@FIL_CheckE
$LN4@FIL_CheckE:
  00033	eb d4		 jmp	 SHORT $LN2@FIL_CheckE
$LN3@FIL_CheckE:

; 347  : 
; 348  : 	return false;

  00035	33 c0		 xor	 eax, eax
$LN1@FIL_CheckE:

; 349  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_FIL_CheckExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_ForceExtension
_TEXT	SEGMENT
_src$ = -4						; size = 4
_path$ = 8						; size = 4
_extension$ = 12					; size = 4
_FIL_ForceExtension PROC				; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 318  : 	char *src;
; 319  : 
; 320  : 	// search for '.' from end to begin, add .EXT only when not found
; 321  : 	src = path + strlen(path) - 1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00018	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  0001c	89 55 fc	 mov	 DWORD PTR _src$[ebp], edx
$LN2@FIL_ForceE:

; 322  : 
; 323  : 	while (*src != '/' && src != path)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00022	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00025	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00028	74 26		 je	 SHORT $LN3@FIL_ForceE
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  0002d	3b 45 08	 cmp	 eax, DWORD PTR _path$[ebp]
  00030	74 1e		 je	 SHORT $LN3@FIL_ForceE

; 324  : 	{
; 325  : 		if (*src == '.')

  00032	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00035	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00038	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  0003b	75 08		 jne	 SHORT $LN4@FIL_ForceE

; 326  : 		{
; 327  : 			*src = '\0';

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00040	c6 00 00	 mov	 BYTE PTR [eax], 0

; 328  : 			break; // it has an extension

  00043	eb 0b		 jmp	 SHORT $LN3@FIL_ForceE
$LN4@FIL_ForceE:

; 329  : 		}
; 330  : 		src--;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00048	83 e8 01	 sub	 eax, 1
  0004b	89 45 fc	 mov	 DWORD PTR _src$[ebp], eax

; 331  : 	}

  0004e	eb cf		 jmp	 SHORT $LN2@FIL_ForceE
$LN3@FIL_ForceE:

; 332  : 
; 333  : 	strcat(path, extension);

  00050	8b 45 0c	 mov	 eax, DWORD PTR _extension$[ebp]
  00053	50		 push	 eax
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _strcat
  0005d	83 c4 08	 add	 esp, 8

; 334  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_FIL_ForceExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_DefaultExtension
_TEXT	SEGMENT
_src$ = -4						; size = 4
_path$ = 8						; size = 4
_extension$ = 12					; size = 4
_FIL_DefaultExtension PROC				; COMDAT

; 300  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 301  : 	char *src;
; 302  : 
; 303  : 	// search for '.' from end to begin, add .EXT only when not found
; 304  : 	src = path + strlen(path) - 1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00018	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  0001c	89 55 fc	 mov	 DWORD PTR _src$[ebp], edx
$LN2@FIL_Defaul:

; 305  : 
; 306  : 	while (*src != '/' && src != path)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00022	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00025	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00028	74 20		 je	 SHORT $LN3@FIL_Defaul
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  0002d	3b 45 08	 cmp	 eax, DWORD PTR _path$[ebp]
  00030	74 18		 je	 SHORT $LN3@FIL_Defaul

; 307  : 	{
; 308  : 		if (*src == '.')

  00032	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00035	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00038	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  0003b	75 02		 jne	 SHORT $LN4@FIL_Defaul

; 309  : 			return; // it has an extension

  0003d	eb 1b		 jmp	 SHORT $LN1@FIL_Defaul
$LN4@FIL_Defaul:

; 310  : 		src--;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _src$[ebp]
  00042	83 e8 01	 sub	 eax, 1
  00045	89 45 fc	 mov	 DWORD PTR _src$[ebp], eax

; 311  : 	}

  00048	eb d5		 jmp	 SHORT $LN2@FIL_Defaul
$LN3@FIL_Defaul:

; 312  : 
; 313  : 	strcat(path, extension);

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _extension$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _strcat
  00057	83 c4 08	 add	 esp, 8
$LN1@FIL_Defaul:

; 314  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_FIL_DefaultExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_FileOK
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FIL_FileOK PROC					; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  : 	return access(name,6)+1;

  00009	6a 06		 push	 6
  0000b	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _access
  00014	83 c4 08	 add	 esp, 8
  00017	83 c0 01	 add	 eax, 1

; 290  : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_FIL_FileOK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_ReadFileOK
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FIL_ReadFileOK PROC					; COMDAT

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 279  : 	return access(name,4)+1;

  00009	6a 04		 push	 4
  0000b	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _access
  00014	83 c4 08	 add	 esp, 8
  00017	83 c0 01	 add	 eax, 1

; 280  : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_FIL_ReadFileOK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_WriteFileOK
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FIL_WriteFileOK PROC					; COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  : 	return access(name,2)+1;

  00009	6a 02		 push	 2
  0000b	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _access
  00014	83 c4 08	 add	 esp, 8
  00017	83 c0 01	 add	 eax, 1

; 269  : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_FIL_WriteFileOK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_FileExists
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FIL_FileExists PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 257  : 	return access(name,0)+1;

  00009	6a 00		 push	 0
  0000b	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _access
  00014	83 c4 08	 add	 esp, 8
  00017	83 c0 01	 add	 eax, 1

; 258  : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_FIL_FileExists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_ReadFile
_TEXT	SEGMENT
_buf$ = -16						; size = 4
_length$ = -12						; size = 4
_count$ = -8						; size = 4
_handle$ = -4						; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_FIL_ReadFile PROC					; COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 219  : 	FILE *handle = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _handle$[ebp], 0

; 220  : 	size_t count, length;
; 221  : 	UINT8 *buf;
; 222  : 
; 223  : 	if (FIL_ReadFileOK(name))

  00010	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _FIL_ReadFileOK
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax
  0001e	74 14		 je	 SHORT $LN2@FIL_ReadFi

; 224  : 		handle = fopen(name, "rb");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00025	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _fopen
  0002e	83 c4 08	 add	 esp, 8
  00031	89 45 fc	 mov	 DWORD PTR _handle$[ebp], eax
$LN2@FIL_ReadFi:

; 225  : 
; 226  : 	if (!handle)

  00034	83 7d fc 00	 cmp	 DWORD PTR _handle$[ebp], 0
  00038	75 07		 jne	 SHORT $LN3@FIL_ReadFi

; 227  : 		return 0;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 98 00 00 00	 jmp	 $LN1@FIL_ReadFi
$LN3@FIL_ReadFi:

; 228  : 
; 229  : 	fseek(handle,0,SEEK_END);

  00041	6a 02		 push	 2
  00043	6a 00		 push	 0
  00045	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _fseek
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 230  : 	length = ftell(handle);

  00051	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _ftell
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax

; 231  : 	fseek(handle,0,SEEK_SET);

  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _fseek
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : 
; 233  : 	buf = Z_Malloc(length + 1, PU_STATIC, NULL);

  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	6a 01		 push	 1
  00076	8b 45 f4	 mov	 eax, DWORD PTR _length$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _Z_MallocAlign
  00082	83 c4 10	 add	 esp, 16			; 00000010H
  00085	89 45 f0	 mov	 DWORD PTR _buf$[ebp], eax

; 234  : 	count = fread(buf, 1, length, handle);

  00088	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _length$[ebp]
  0008f	51		 push	 ecx
  00090	6a 01		 push	 1
  00092	8b 55 f0	 mov	 edx, DWORD PTR _buf$[ebp]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 _fread
  0009b	83 c4 10	 add	 esp, 16			; 00000010H
  0009e	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 235  : 	fclose(handle);

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fclose
  000aa	83 c4 04	 add	 esp, 4

; 236  : 
; 237  : 	if (count < length)

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000b0	3b 45 f4	 cmp	 eax, DWORD PTR _length$[ebp]
  000b3	73 10		 jae	 SHORT $LN4@FIL_ReadFi

; 238  : 	{
; 239  : 		Z_Free(buf);

  000b5	8b 45 f0	 mov	 eax, DWORD PTR _buf$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _Z_Free
  000be	83 c4 04	 add	 esp, 4

; 240  : 		return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 14		 jmp	 SHORT $LN1@FIL_ReadFi
$LN4@FIL_ReadFi:

; 241  : 	}
; 242  : 
; 243  : 	// append 0 byte for script text files
; 244  : 	buf[length] = 0;

  000c5	8b 45 f0	 mov	 eax, DWORD PTR _buf$[ebp]
  000c8	03 45 f4	 add	 eax, DWORD PTR _length$[ebp]
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 245  : 
; 246  : 	*buffer = buf;

  000ce	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  000d1	8b 4d f0	 mov	 ecx, DWORD PTR _buf$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx

; 247  : 	return length;

  000d6	8b 45 f4	 mov	 eax, DWORD PTR _length$[ebp]
$LN1@FIL_ReadFi:

; 248  : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_FIL_ReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _FIL_WriteFile
_TEXT	SEGMENT
_count$ = -8						; size = 4
_handle$ = -4						; size = 4
_name$ = 8						; size = 4
_source$ = 12						; size = 4
_length$ = 16						; size = 4
_FIL_WriteFile PROC					; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 191  : 	FILE *handle = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _handle$[ebp], 0

; 192  : 	size_t count;
; 193  : 
; 194  : 	//if (FIL_WriteFileOK(name))
; 195  : 		handle = fopen(name, "w+b");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_03ELIABIOC@w?$CLb@
  00015	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _fopen
  0001e	83 c4 08	 add	 esp, 8
  00021	89 45 fc	 mov	 DWORD PTR _handle$[ebp], eax

; 196  : 
; 197  : 	if (!handle)

  00024	83 7d fc 00	 cmp	 DWORD PTR _handle$[ebp], 0
  00028	75 04		 jne	 SHORT $LN2@FIL_WriteF

; 198  : 		return false;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 36		 jmp	 SHORT $LN1@FIL_WriteF
$LN2@FIL_WriteF:

; 199  : 
; 200  : 	count = fwrite(source, 1, length, handle);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR _length$[ebp]
  00035	51		 push	 ecx
  00036	6a 01		 push	 1
  00038	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _fwrite
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 201  : 	fclose(handle);

  00047	8b 45 fc	 mov	 eax, DWORD PTR _handle$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _fclose
  00050	83 c4 04	 add	 esp, 4

; 202  : 
; 203  : 	if (count < length)

  00053	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00056	3b 45 10	 cmp	 eax, DWORD PTR _length$[ebp]
  00059	73 04		 jae	 SHORT $LN3@FIL_WriteF

; 204  : 		return false;

  0005b	33 c0		 xor	 eax, eax
  0005d	eb 05		 jmp	 SHORT $LN1@FIL_WriteF
$LN3@FIL_WriteF:

; 205  : 
; 206  : 	return true;

  0005f	b8 01 00 00 00	 mov	 eax, 1
$LN1@FIL_WriteF:

; 207  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_FIL_WriteFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _M_MapNumber
_TEXT	SEGMENT
tv135 = -68						; size = 4
_first$ = 8						; size = 1
_second$ = 12						; size = 1
_M_MapNumber PROC					; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 155  : 	if (isdigit(first))

  00009	0f be 45 08	 movsx	 eax, BYTE PTR _first$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _isdigit
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	74 29		 je	 SHORT $LN2@M_MapNumbe

; 156  : 	{
; 157  : 		if (isdigit(second))

  0001a	0f be 45 0c	 movsx	 eax, BYTE PTR _second$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _isdigit
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	74 14		 je	 SHORT $LN3@M_MapNumbe

; 158  : 			return ((INT32)first - '0') * 10 + ((INT32)second - '0');

  0002b	0f be 45 08	 movsx	 eax, BYTE PTR _first$[ebp]
  0002f	83 e8 30	 sub	 eax, 48			; 00000030H
  00032	6b c8 0a	 imul	 ecx, eax, 10
  00035	0f be 55 0c	 movsx	 edx, BYTE PTR _second$[ebp]
  00039	8d 44 11 d0	 lea	 eax, DWORD PTR [ecx+edx-48]
  0003d	eb 78		 jmp	 SHORT $LN1@M_MapNumbe
$LN3@M_MapNumbe:

; 159  : 		return 0;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 74		 jmp	 SHORT $LN1@M_MapNumbe
$LN2@M_MapNumbe:

; 160  : 	}
; 161  : 
; 162  : 	if (!isalpha(first))

  00043	0f be 45 08	 movsx	 eax, BYTE PTR _first$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _isalpha
  0004d	83 c4 04	 add	 esp, 4
  00050	85 c0		 test	 eax, eax
  00052	75 04		 jne	 SHORT $LN4@M_MapNumbe

; 163  : 		return 0;

  00054	33 c0		 xor	 eax, eax
  00056	eb 5f		 jmp	 SHORT $LN1@M_MapNumbe
$LN4@M_MapNumbe:

; 164  : 	if (!isalnum(second))

  00058	0f be 45 0c	 movsx	 eax, BYTE PTR _second$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _isalnum
  00062	83 c4 04	 add	 esp, 4
  00065	85 c0		 test	 eax, eax
  00067	75 04		 jne	 SHORT $LN5@M_MapNumbe

; 165  : 		return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	eb 4a		 jmp	 SHORT $LN1@M_MapNumbe
$LN5@M_MapNumbe:

; 166  : 
; 167  : 	return 100 + ((INT32)tolower(first) - 'a') * 36 + (isdigit(second) ? ((INT32)second - '0') :

  0006d	0f be 45 0c	 movsx	 eax, BYTE PTR _second$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _isdigit
  00077	83 c4 04	 add	 esp, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 0c		 je	 SHORT $LN7@M_MapNumbe
  0007e	0f be 4d 0c	 movsx	 ecx, BYTE PTR _second$[ebp]
  00082	83 e9 30	 sub	 ecx, 48			; 00000030H
  00085	89 4d bc	 mov	 DWORD PTR tv135[ebp], ecx
  00088	eb 13		 jmp	 SHORT $LN8@M_MapNumbe
$LN7@M_MapNumbe:
  0008a	0f be 55 0c	 movsx	 edx, BYTE PTR _second$[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _tolower
  00094	83 c4 04	 add	 esp, 4
  00097	83 e8 57	 sub	 eax, 87			; 00000057H
  0009a	89 45 bc	 mov	 DWORD PTR tv135[ebp], eax
$LN8@M_MapNumbe:
  0009d	0f be 45 08	 movsx	 eax, BYTE PTR _first$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _tolower
  000a7	83 c4 04	 add	 esp, 4
  000aa	83 e8 61	 sub	 eax, 97			; 00000061H
  000ad	6b c8 24	 imul	 ecx, eax, 36
  000b0	8b 55 bc	 mov	 edx, DWORD PTR tv135[ebp]
  000b3	8d 44 11 64	 lea	 eax, DWORD PTR [ecx+edx+100]
$LN1@M_MapNumbe:

; 168  : 		((INT32)tolower(second) - 'a') + 10);
; 169  : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_M_MapNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_misc.c
;	COMDAT _va
_TEXT	SEGMENT
_argptr$ = -4						; size = 4
_format$ = 8						; size = 4
_va	PROC						; COMDAT

; 1337 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1338 : 	va_list argptr;
; 1339 : 	static char string[1024];
; 1340 : 
; 1341 : 	va_start(argptr, format);

  00009	8d 45 0c	 lea	 eax, DWORD PTR _format$[ebp+4]
  0000c	89 45 fc	 mov	 DWORD PTR _argptr$[ebp], eax

; 1342 : 	vsprintf(string, format, argptr);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _argptr$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _format$[ebp]
  00016	51		 push	 ecx
  00017	68 00 00 00 00	 push	 OFFSET ?string@?1??va@@9@9
  0001c	e8 00 00 00 00	 call	 _vsprintf
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1343 : 	va_end(argptr);

  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _argptr$[ebp], 0

; 1344 : 
; 1345 : 	return string;

  0002b	b8 00 00 00 00	 mov	 eax, OFFSET ?string@?1??va@@9@9

; 1346 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_va	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1474 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1475 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
