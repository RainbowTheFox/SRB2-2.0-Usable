; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\p_sight.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
PUBLIC	_P_CheckSight
EXTRN	_abs:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_rejectmatrix:DWORD
EXTRN	_segs:DWORD
EXTRN	_numsectors:DWORD
EXTRN	_sectors:DWORD
EXTRN	_subsectors:DWORD
EXTRN	_numnodes:DWORD
EXTRN	_nodes:DWORD
EXTRN	_validcount:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_sightcounts DD	02H DUP (?)
_BSS	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	037aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01aeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03c8H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_sight.c
;	COMDAT _P_CrossBSPNode
_TEXT	SEGMENT
tv135 = -76						; size = 4
_side$1 = -8						; size = 4
_bsp$2 = -4						; size = 4
_bspnum$ = 8						; size = 4
_los$ = 12						; size = 4
_P_CrossBSPNode PROC					; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@P_CrossBSP:

; 289  : 	while (!(bspnum & NF_SUBSECTOR))

  00009	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  0000c	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00011	0f 85 94 00 00
	00		 jne	 $LN3@P_CrossBSP

; 290  : 	{
; 291  : 		register node_t *bsp = nodes + bspnum;

  00017	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  0001b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  00021	89 45 fc	 mov	 DWORD PTR _bsp$2[ebp], eax

; 292  : 		INT32 side = P_DivlineSide(los->strace.x,los->strace.y,(divline_t *)bsp)&1;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _bsp$2[ebp]
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  0002b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0002e	52		 push	 edx
  0002f	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00032	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _P_DivlineSide
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	83 e0 01	 and	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _side$1[ebp], eax

; 293  : 		if (side == P_DivlineSide(los->t2x, los->t2y, (divline_t *) bsp))

  00044	8b 45 fc	 mov	 eax, DWORD PTR _bsp$2[ebp]
  00047	50		 push	 eax
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  0004b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004e	52		 push	 edx
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _P_DivlineSide
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	39 45 f8	 cmp	 DWORD PTR _side$1[ebp], eax
  00061	75 10		 jne	 SHORT $LN4@P_CrossBSP

; 294  : 			bspnum = bsp->children[side]; // doesn't touch the other side

  00063	8b 45 f8	 mov	 eax, DWORD PTR _side$1[ebp]
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$2[ebp]
  00069	0f b7 54 41 30	 movzx	 edx, WORD PTR [ecx+eax*2+48]
  0006e	89 55 08	 mov	 DWORD PTR _bspnum$[ebp], edx
  00071	eb 33		 jmp	 SHORT $LN7@P_CrossBSP
$LN4@P_CrossBSP:

; 295  : 		else         // the partition plane is crossed here
; 296  : 		{
; 297  : 			if (!P_CrossBSPNode(bsp->children[side], los))

  00073	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00076	50		 push	 eax
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _side$1[ebp]
  0007a	8b 55 fc	 mov	 edx, DWORD PTR _bsp$2[ebp]
  0007d	0f b7 44 4a 30	 movzx	 eax, WORD PTR [edx+ecx*2+48]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _P_CrossBSPNode
  00088	83 c4 08	 add	 esp, 8
  0008b	85 c0		 test	 eax, eax
  0008d	75 06		 jne	 SHORT $LN6@P_CrossBSP

; 298  : 				return 0;  // cross the starting side

  0008f	33 c0		 xor	 eax, eax
  00091	eb 42		 jmp	 SHORT $LN1@P_CrossBSP
  00093	eb 11		 jmp	 SHORT $LN7@P_CrossBSP
$LN6@P_CrossBSP:

; 299  : 			else
; 300  : 				bspnum = bsp->children[side^1];  // cross the ending side

  00095	8b 45 f8	 mov	 eax, DWORD PTR _side$1[ebp]
  00098	83 f0 01	 xor	 eax, 1
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$2[ebp]
  0009e	0f b7 54 41 30	 movzx	 edx, WORD PTR [ecx+eax*2+48]
  000a3	89 55 08	 mov	 DWORD PTR _bspnum$[ebp], edx
$LN7@P_CrossBSP:

; 301  : 		}
; 302  : 	}

  000a6	e9 5e ff ff ff	 jmp	 $LN2@P_CrossBSP
$LN3@P_CrossBSP:

; 303  : 	return

  000ab	83 7d 08 ff	 cmp	 DWORD PTR _bspnum$[ebp], -1
  000af	75 09		 jne	 SHORT $LN9@P_CrossBSP
  000b1	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
  000b8	eb 0b		 jmp	 SHORT $LN10@P_CrossBSP
$LN9@P_CrossBSP:
  000ba	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  000bd	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  000c2	89 45 b4	 mov	 DWORD PTR tv135[ebp], eax
$LN10@P_CrossBSP:
  000c5	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 b4	 mov	 edx, DWORD PTR tv135[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _P_CrossSubsector
  000d2	83 c4 08	 add	 esp, 8
$LN1@P_CrossBSP:

; 304  : 		P_CrossSubsector((bspnum == -1 ? 0 : bspnum & ~NF_SUBSECTOR), los);
; 305  : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
_P_CrossBSPNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_sight.c
;	COMDAT _P_CrossSubsector
_TEXT	SEGMENT
tv207 = -140						; size = 4
tv213 = -140						; size = 4
_slope$1 = -72						; size = 4
_slope$2 = -68						; size = 4
_frac$3 = -64						; size = 4
_v2$4 = -60						; size = 4
_v1$5 = -56						; size = 4
_back$6 = -52						; size = 4
_front$7 = -48						; size = 4
_popenbottom$8 = -44					; size = 4
_popentop$9 = -40					; size = 4
_divl$10 = -36						; size = 16
_line$11 = -20						; size = 4
_po$ = -16						; size = 4
_count$ = -12						; size = 4
_seg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_num$ = 8						; size = 4
_los$ = 12						; size = 4
_P_CrossSubsector PROC					; COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 163  : 	seg_t *seg;
; 164  : 	INT32 count;
; 165  : #ifdef POLYOBJECTS
; 166  : 	polyobj_t *po; // haleyjd 02/23/06
; 167  : #endif
; 168  : 
; 169  : #ifdef RANGECHECK
; 170  : 	if (num >= numsubsectors)
; 171  : 		I_Error("P_CrossSubsector: ss %"PRIdS" with numss = %"PRIdS"\n", num, numsubsectors);
; 172  : #endif
; 173  : 
; 174  : 	// haleyjd 02/23/06: this assignment should be after the above check
; 175  : 	seg = segs + subsectors[num].firstline;

  00016	6b 45 08 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _subsectors
  00020	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  00025	6b c2 3c	 imul	 eax, edx, 60
  00028	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  0002e	89 45 f8	 mov	 DWORD PTR _seg$[ebp], eax

; 176  : 
; 177  : #ifdef POLYOBJECTS
; 178  : 	// haleyjd 02/23/06: check polyobject lines
; 179  : 	if ((po = subsectors[num].polyList))

  00031	6b 45 08 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _subsectors
  0003b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0003f	89 55 f0	 mov	 DWORD PTR _po$[ebp], edx
  00042	83 7d f0 00	 cmp	 DWORD PTR _po$[ebp], 0
  00046	74 4b		 je	 SHORT $LN3@P_CrossSub
$LN2@P_CrossSub:

; 180  : 	{
; 181  : 		while (po)

  00048	83 7d f0 00	 cmp	 DWORD PTR _po$[ebp], 0
  0004c	74 45		 je	 SHORT $LN3@P_CrossSub

; 182  : 		{
; 183  : 			if (po->validcount != validcount)

  0004e	8b 45 f0	 mov	 eax, DWORD PTR _po$[ebp]
  00051	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00057	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  0005d	74 2a		 je	 SHORT $LN9@P_CrossSub

; 184  : 			{
; 185  : 				po->validcount = validcount;

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _po$[ebp]
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00068	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx

; 186  : 				if (!P_CrossSubsecPolyObj(po, los))

  0006e	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _po$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _P_CrossSubsecPolyObj
  0007b	83 c4 08	 add	 esp, 8
  0007e	85 c0		 test	 eax, eax
  00080	75 07		 jne	 SHORT $LN9@P_CrossSub

; 187  : 					return false;

  00082	33 c0		 xor	 eax, eax
  00084	e9 ee 02 00 00	 jmp	 $LN1@P_CrossSub
$LN9@P_CrossSub:

; 188  : 			}
; 189  : 			po = (polyobj_t *)(po->link.next);

  00089	8b 45 f0	 mov	 eax, DWORD PTR _po$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	89 4d f0	 mov	 DWORD PTR _po$[ebp], ecx

; 190  : 		}

  00091	eb b5		 jmp	 SHORT $LN2@P_CrossSub
$LN3@P_CrossSub:

; 191  : 	}
; 192  : #endif
; 193  : 
; 194  : 	for (count = subsectors[num].numlines; --count >= 0; seg++)  // check lines

  00093	6b 45 08 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _subsectors
  0009d	0f bf 54 01 04	 movsx	 edx, WORD PTR [ecx+eax+4]
  000a2	89 55 f4	 mov	 DWORD PTR _count$[ebp], edx
  000a5	eb 09		 jmp	 SHORT $LN6@P_CrossSub
$LN4@P_CrossSub:
  000a7	8b 45 f8	 mov	 eax, DWORD PTR _seg$[ebp]
  000aa	83 c0 3c	 add	 eax, 60			; 0000003cH
  000ad	89 45 f8	 mov	 DWORD PTR _seg$[ebp], eax
$LN6@P_CrossSub:
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  000b3	83 e8 01	 sub	 eax, 1
  000b6	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax
  000b9	0f 88 b3 02 00
	00		 js	 $LN5@P_CrossSub

; 195  : 	{
; 196  : 		line_t *line = seg->linedef;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _seg$[ebp]
  000c2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c5	89 4d ec	 mov	 DWORD PTR _line$11[ebp], ecx

; 197  : 		divline_t divl;
; 198  : 		fixed_t popentop, popenbottom;
; 199  : 		const sector_t *front, *back;
; 200  : 		const vertex_t *v1,*v2;
; 201  : 		fixed_t frac;
; 202  : 
; 203  : 		// already checked other side?
; 204  : 		if (line->validcount == validcount)

  000c8	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  000cb	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000ce	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  000d4	75 02		 jne	 SHORT $LN10@P_CrossSub

; 205  : 			continue;

  000d6	eb cf		 jmp	 SHORT $LN4@P_CrossSub
$LN10@P_CrossSub:

; 206  : 
; 207  : 		line->validcount = validcount;

  000d8	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  000e1	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 208  : 
; 209  : 		// OPTIMIZE: killough 4/20/98: Added quick bounding-box rejection test
; 210  : 		if (line->bbox[BOXLEFT  ] > los->bbox[BOXRIGHT ] ||
; 211  : 			line->bbox[BOXRIGHT ] < los->bbox[BOXLEFT  ] ||
; 212  : 			line->bbox[BOXBOTTOM] > los->bbox[BOXTOP   ] ||

  000e4	b8 04 00 00 00	 mov	 eax, 4
  000e9	d1 e0		 shl	 eax, 1
  000eb	b9 04 00 00 00	 mov	 ecx, 4
  000f0	6b d1 03	 imul	 edx, ecx, 3
  000f3	8b 4d ec	 mov	 ecx, DWORD PTR _line$11[ebp]
  000f6	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  000f9	8b 44 01 1c	 mov	 eax, DWORD PTR [ecx+eax+28]
  000fd	3b 44 16 24	 cmp	 eax, DWORD PTR [esi+edx+36]
  00101	7f 5f		 jg	 SHORT $LN12@P_CrossSub
  00103	b8 04 00 00 00	 mov	 eax, 4
  00108	6b c8 03	 imul	 ecx, eax, 3
  0010b	ba 04 00 00 00	 mov	 edx, 4
  00110	d1 e2		 shl	 edx, 1
  00112	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  00115	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  00118	8b 4c 08 1c	 mov	 ecx, DWORD PTR [eax+ecx+28]
  0011c	3b 4c 16 24	 cmp	 ecx, DWORD PTR [esi+edx+36]
  00120	7c 40		 jl	 SHORT $LN12@P_CrossSub
  00122	b8 04 00 00 00	 mov	 eax, 4
  00127	c1 e0 00	 shl	 eax, 0
  0012a	b9 04 00 00 00	 mov	 ecx, 4
  0012f	6b d1 00	 imul	 edx, ecx, 0
  00132	8b 4d ec	 mov	 ecx, DWORD PTR _line$11[ebp]
  00135	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  00138	8b 44 01 1c	 mov	 eax, DWORD PTR [ecx+eax+28]
  0013c	3b 44 16 24	 cmp	 eax, DWORD PTR [esi+edx+36]
  00140	7f 20		 jg	 SHORT $LN12@P_CrossSub
  00142	b8 04 00 00 00	 mov	 eax, 4
  00147	6b c8 00	 imul	 ecx, eax, 0
  0014a	ba 04 00 00 00	 mov	 edx, 4
  0014f	c1 e2 00	 shl	 edx, 0
  00152	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  00155	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  00158	8b 4c 08 1c	 mov	 ecx, DWORD PTR [eax+ecx+28]
  0015c	3b 4c 16 24	 cmp	 ecx, DWORD PTR [esi+edx+36]
  00160	7d 05		 jge	 SHORT $LN11@P_CrossSub
$LN12@P_CrossSub:

; 213  : 			line->bbox[BOXTOP]    < los->bbox[BOXBOTTOM])
; 214  : 			continue;

  00162	e9 40 ff ff ff	 jmp	 $LN4@P_CrossSub
$LN11@P_CrossSub:

; 215  : 
; 216  : 		v1 = line->v1;

  00167	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	89 4d c8	 mov	 DWORD PTR _v1$5[ebp], ecx

; 217  : 		v2 = line->v2;

  0016f	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  00172	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00175	89 4d c4	 mov	 DWORD PTR _v2$4[ebp], ecx

; 218  : 
; 219  : 		// line isn't crossed?
; 220  : 		if (P_DivlineSide(v1->x, v1->y, &los->strace) ==

  00178	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  0017b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0017e	50		 push	 eax
  0017f	8b 4d c8	 mov	 ecx, DWORD PTR _v1$5[ebp]
  00182	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00185	52		 push	 edx
  00186	8b 45 c8	 mov	 eax, DWORD PTR _v1$5[ebp]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 _P_DivlineSide
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
  00194	8b f0		 mov	 esi, eax
  00196	8b 55 0c	 mov	 edx, DWORD PTR _los$[ebp]
  00199	83 c2 0c	 add	 edx, 12			; 0000000cH
  0019c	52		 push	 edx
  0019d	8b 45 c4	 mov	 eax, DWORD PTR _v2$4[ebp]
  001a0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a3	51		 push	 ecx
  001a4	8b 55 c4	 mov	 edx, DWORD PTR _v2$4[ebp]
  001a7	8b 02		 mov	 eax, DWORD PTR [edx]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _P_DivlineSide
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b2	3b f0		 cmp	 esi, eax
  001b4	75 05		 jne	 SHORT $LN13@P_CrossSub

; 221  : 			P_DivlineSide(v2->x, v2->y, &los->strace))
; 222  : 			continue;

  001b6	e9 ec fe ff ff	 jmp	 $LN4@P_CrossSub
$LN13@P_CrossSub:

; 223  : 
; 224  : 		divl.dx = v2->x - (divl.x = v1->x);

  001bb	8b 45 c8	 mov	 eax, DWORD PTR _v1$5[ebp]
  001be	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c0	89 4d dc	 mov	 DWORD PTR _divl$10[ebp], ecx
  001c3	8b 55 c4	 mov	 edx, DWORD PTR _v2$4[ebp]
  001c6	8b 02		 mov	 eax, DWORD PTR [edx]
  001c8	2b 45 dc	 sub	 eax, DWORD PTR _divl$10[ebp]
  001cb	89 45 e4	 mov	 DWORD PTR _divl$10[ebp+8], eax

; 225  : 		divl.dy = v2->y - (divl.y = v1->y);

  001ce	8b 45 c8	 mov	 eax, DWORD PTR _v1$5[ebp]
  001d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d4	89 4d e0	 mov	 DWORD PTR _divl$10[ebp+4], ecx
  001d7	8b 55 c4	 mov	 edx, DWORD PTR _v2$4[ebp]
  001da	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001dd	2b 45 e0	 sub	 eax, DWORD PTR _divl$10[ebp+4]
  001e0	89 45 e8	 mov	 DWORD PTR _divl$10[ebp+12], eax

; 226  : 
; 227  : 		// line isn't crossed?
; 228  : 		if (P_DivlineSide(los->strace.x, los->strace.y, &divl) ==

  001e3	8d 45 dc	 lea	 eax, DWORD PTR _divl$10[ebp]
  001e6	50		 push	 eax
  001e7	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  001ea	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001ed	52		 push	 edx
  001ee	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  001f1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _P_DivlineSide
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fd	8b f0		 mov	 esi, eax
  001ff	8d 55 dc	 lea	 edx, DWORD PTR _divl$10[ebp]
  00202	52		 push	 edx
  00203	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00206	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00209	51		 push	 ecx
  0020a	8b 55 0c	 mov	 edx, DWORD PTR _los$[ebp]
  0020d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _P_DivlineSide
  00216	83 c4 0c	 add	 esp, 12			; 0000000cH
  00219	3b f0		 cmp	 esi, eax
  0021b	75 05		 jne	 SHORT $LN14@P_CrossSub

; 229  : 			P_DivlineSide(los->t2x, los->t2y, &divl))
; 230  : 			continue;

  0021d	e9 85 fe ff ff	 jmp	 $LN4@P_CrossSub
$LN14@P_CrossSub:

; 231  : 
; 232  : 		// stop because it is not two sided anyway
; 233  : 		if (!(line->flags & ML_TWOSIDED))

  00222	8b 45 ec	 mov	 eax, DWORD PTR _line$11[ebp]
  00225	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00229	83 e1 04	 and	 ecx, 4
  0022c	75 07		 jne	 SHORT $LN15@P_CrossSub

; 234  : 			return false;

  0022e	33 c0		 xor	 eax, eax
  00230	e9 42 01 00 00	 jmp	 $LN1@P_CrossSub
$LN15@P_CrossSub:

; 235  : 
; 236  : 		// crosses a two sided line
; 237  : 		// no wall to block sight with?
; 238  : 		if ((front = seg->frontsector)->floorheight ==
; 239  : 			(back = seg->backsector)->floorheight   &&

  00235	8b 45 f8	 mov	 eax, DWORD PTR _seg$[ebp]
  00238	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0023b	89 4d d0	 mov	 DWORD PTR _front$7[ebp], ecx
  0023e	8b 55 f8	 mov	 edx, DWORD PTR _seg$[ebp]
  00241	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00244	89 45 cc	 mov	 DWORD PTR _back$6[ebp], eax
  00247	8b 4d d0	 mov	 ecx, DWORD PTR _front$7[ebp]
  0024a	8b 55 cc	 mov	 edx, DWORD PTR _back$6[ebp]
  0024d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0024f	3b 02		 cmp	 eax, DWORD PTR [edx]
  00251	75 13		 jne	 SHORT $LN16@P_CrossSub
  00253	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  00256	8b 4d cc	 mov	 ecx, DWORD PTR _back$6[ebp]
  00259	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0025c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0025f	75 05		 jne	 SHORT $LN16@P_CrossSub

; 240  : 			front->ceilingheight == back->ceilingheight)
; 241  : 			continue;

  00261	e9 41 fe ff ff	 jmp	 $LN4@P_CrossSub
$LN16@P_CrossSub:

; 242  : 
; 243  : 		// possible occluder
; 244  : 		// because of ceiling height differences
; 245  : 		popentop = front->ceilingheight < back->ceilingheight ?

  00266	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  00269	8b 4d cc	 mov	 ecx, DWORD PTR _back$6[ebp]
  0026c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0026f	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00272	7d 0e		 jge	 SHORT $LN24@P_CrossSub
  00274	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  00277	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0027a	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv207[ebp], ecx
  00280	eb 0c		 jmp	 SHORT $LN25@P_CrossSub
$LN24@P_CrossSub:
  00282	8b 55 cc	 mov	 edx, DWORD PTR _back$6[ebp]
  00285	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00288	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv207[ebp], eax
$LN25@P_CrossSub:
  0028e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv207[ebp]
  00294	89 4d d8	 mov	 DWORD PTR _popentop$9[ebp], ecx

; 246  : 			front->ceilingheight : back->ceilingheight ;
; 247  : 
; 248  : 		// because of floor height differences
; 249  : 		popenbottom = front->floorheight > back->floorheight ?

  00297	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  0029a	8b 4d cc	 mov	 ecx, DWORD PTR _back$6[ebp]
  0029d	8b 10		 mov	 edx, DWORD PTR [eax]
  0029f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002a1	7e 0d		 jle	 SHORT $LN26@P_CrossSub
  002a3	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  002a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a8	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], ecx
  002ae	eb 0b		 jmp	 SHORT $LN27@P_CrossSub
$LN26@P_CrossSub:
  002b0	8b 55 cc	 mov	 edx, DWORD PTR _back$6[ebp]
  002b3	8b 02		 mov	 eax, DWORD PTR [edx]
  002b5	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], eax
$LN27@P_CrossSub:
  002bb	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv213[ebp]
  002c1	89 4d d4	 mov	 DWORD PTR _popenbottom$8[ebp], ecx

; 250  : 			front->floorheight : back->floorheight ;
; 251  : 
; 252  : 		// quick test for totally closed doors
; 253  : 		if (popenbottom >= popentop)

  002c4	8b 45 d4	 mov	 eax, DWORD PTR _popenbottom$8[ebp]
  002c7	3b 45 d8	 cmp	 eax, DWORD PTR _popentop$9[ebp]
  002ca	7c 07		 jl	 SHORT $LN17@P_CrossSub

; 254  : 			return false;

  002cc	33 c0		 xor	 eax, eax
  002ce	e9 a4 00 00 00	 jmp	 $LN1@P_CrossSub
$LN17@P_CrossSub:

; 255  : 
; 256  : 		frac = P_InterceptVector2(&los->strace, &divl);

  002d3	8d 45 dc	 lea	 eax, DWORD PTR _divl$10[ebp]
  002d6	50		 push	 eax
  002d7	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  002da	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002dd	51		 push	 ecx
  002de	e8 00 00 00 00	 call	 _P_InterceptVector2
  002e3	83 c4 08	 add	 esp, 8
  002e6	89 45 c0	 mov	 DWORD PTR _frac$3[ebp], eax

; 257  : 
; 258  : 		if (front->floorheight != back->floorheight)

  002e9	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  002ec	8b 4d cc	 mov	 ecx, DWORD PTR _back$6[ebp]
  002ef	8b 10		 mov	 edx, DWORD PTR [eax]
  002f1	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002f3	74 2c		 je	 SHORT $LN19@P_CrossSub

; 259  : 		{
; 260  : 			fixed_t slope = FixedDiv(popenbottom - los->sightzstart , frac);

  002f5	8b 45 c0	 mov	 eax, DWORD PTR _frac$3[ebp]
  002f8	50		 push	 eax
  002f9	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  002fc	8b 55 d4	 mov	 edx, DWORD PTR _popenbottom$8[ebp]
  002ff	2b 11		 sub	 edx, DWORD PTR [ecx]
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 _FixedDiv
  00307	83 c4 08	 add	 esp, 8
  0030a	89 45 bc	 mov	 DWORD PTR _slope$2[ebp], eax

; 261  : 			if (slope > los->bottomslope)

  0030d	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00310	8b 4d bc	 mov	 ecx, DWORD PTR _slope$2[ebp]
  00313	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00316	7e 09		 jle	 SHORT $LN19@P_CrossSub

; 262  : 				los->bottomslope = slope;

  00318	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  0031b	8b 4d bc	 mov	 ecx, DWORD PTR _slope$2[ebp]
  0031e	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$LN19@P_CrossSub:

; 263  : 		}
; 264  : 
; 265  : 		if (front->ceilingheight != back->ceilingheight)

  00321	8b 45 d0	 mov	 eax, DWORD PTR _front$7[ebp]
  00324	8b 4d cc	 mov	 ecx, DWORD PTR _back$6[ebp]
  00327	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0032a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0032d	74 2c		 je	 SHORT $LN21@P_CrossSub

; 266  : 		{
; 267  : 			fixed_t slope = FixedDiv(popentop - los->sightzstart , frac);

  0032f	8b 45 c0	 mov	 eax, DWORD PTR _frac$3[ebp]
  00332	50		 push	 eax
  00333	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  00336	8b 55 d8	 mov	 edx, DWORD PTR _popentop$9[ebp]
  00339	2b 11		 sub	 edx, DWORD PTR [ecx]
  0033b	52		 push	 edx
  0033c	e8 00 00 00 00	 call	 _FixedDiv
  00341	83 c4 08	 add	 esp, 8
  00344	89 45 b8	 mov	 DWORD PTR _slope$1[ebp], eax

; 268  : 			if (slope < los->topslope)

  00347	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  0034a	8b 4d b8	 mov	 ecx, DWORD PTR _slope$1[ebp]
  0034d	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00350	7d 09		 jge	 SHORT $LN21@P_CrossSub

; 269  : 				los->topslope = slope;

  00352	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00355	8b 4d b8	 mov	 ecx, DWORD PTR _slope$1[ebp]
  00358	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$LN21@P_CrossSub:

; 270  : 		}
; 271  : 
; 272  : 		if (los->topslope <= los->bottomslope)

  0035b	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  0035e	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  00361	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00364	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  00367	7f 04		 jg	 SHORT $LN22@P_CrossSub

; 273  : 			return false;

  00369	33 c0		 xor	 eax, eax
  0036b	eb 0a		 jmp	 SHORT $LN1@P_CrossSub
$LN22@P_CrossSub:

; 274  : 	}

  0036d	e9 35 fd ff ff	 jmp	 $LN4@P_CrossSub
$LN5@P_CrossSub:

; 275  : 
; 276  : 	// passed the subsector ok
; 277  : 	return true;

  00372	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_CrossSub:

; 278  : }

  00377	5f		 pop	 edi
  00378	5e		 pop	 esi
  00379	5b		 pop	 ebx
  0037a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037d	33 cd		 xor	 ecx, ebp
  0037f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c3		 ret	 0
_P_CrossSubsector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_sight.c
;	COMDAT _P_CrossSubsecPolyObj
_TEXT	SEGMENT
_v2$1 = -36						; size = 4
_v1$2 = -32						; size = 4
_divl$3 = -28						; size = 16
_line$4 = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_los$ = 12						; size = 4
_P_CrossSubsecPolyObj PROC				; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 111  : 	size_t i;
; 112  : 
; 113  : 	for (i = 0; i < po->numLines; ++i)

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@P_CrossSub
$LN2@P_CrossSub:
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_CrossSub:
  00025	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0002b	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  0002e	0f 83 72 01 00
	00		 jae	 $LN3@P_CrossSub

; 114  : 	{
; 115  : 		line_t *line = po->lines[i];

  00034	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00037	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0003a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0003d	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00040	89 45 f4	 mov	 DWORD PTR _line$4[ebp], eax

; 116  : 		divline_t divl;
; 117  : 		const vertex_t *v1,*v2;
; 118  : 
; 119  : 		// already checked other side?
; 120  : 		if (line->validcount == validcount)

  00043	8b 45 f4	 mov	 eax, DWORD PTR _line$4[ebp]
  00046	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00049	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  0004f	75 02		 jne	 SHORT $LN5@P_CrossSub

; 121  : 			continue;

  00051	eb c9		 jmp	 SHORT $LN2@P_CrossSub
$LN5@P_CrossSub:

; 122  : 
; 123  : 		line->validcount = validcount;

  00053	8b 45 f4	 mov	 eax, DWORD PTR _line$4[ebp]
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  0005c	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 124  : 
; 125  : 		// OPTIMIZE: killough 4/20/98: Added quick bounding-box rejection test
; 126  : 		if (line->bbox[BOXLEFT  ] > los->bbox[BOXRIGHT ] ||
; 127  : 			line->bbox[BOXRIGHT ] < los->bbox[BOXLEFT  ] ||
; 128  : 			line->bbox[BOXBOTTOM] > los->bbox[BOXTOP   ] ||

  0005f	b8 04 00 00 00	 mov	 eax, 4
  00064	d1 e0		 shl	 eax, 1
  00066	b9 04 00 00 00	 mov	 ecx, 4
  0006b	6b d1 03	 imul	 edx, ecx, 3
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _line$4[ebp]
  00071	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  00074	8b 44 01 1c	 mov	 eax, DWORD PTR [ecx+eax+28]
  00078	3b 44 16 24	 cmp	 eax, DWORD PTR [esi+edx+36]
  0007c	7f 5f		 jg	 SHORT $LN7@P_CrossSub
  0007e	b8 04 00 00 00	 mov	 eax, 4
  00083	6b c8 03	 imul	 ecx, eax, 3
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	d1 e2		 shl	 edx, 1
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _line$4[ebp]
  00090	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  00093	8b 4c 08 1c	 mov	 ecx, DWORD PTR [eax+ecx+28]
  00097	3b 4c 16 24	 cmp	 ecx, DWORD PTR [esi+edx+36]
  0009b	7c 40		 jl	 SHORT $LN7@P_CrossSub
  0009d	b8 04 00 00 00	 mov	 eax, 4
  000a2	c1 e0 00	 shl	 eax, 0
  000a5	b9 04 00 00 00	 mov	 ecx, 4
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _line$4[ebp]
  000b0	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  000b3	8b 44 01 1c	 mov	 eax, DWORD PTR [ecx+eax+28]
  000b7	3b 44 16 24	 cmp	 eax, DWORD PTR [esi+edx+36]
  000bb	7f 20		 jg	 SHORT $LN7@P_CrossSub
  000bd	b8 04 00 00 00	 mov	 eax, 4
  000c2	6b c8 00	 imul	 ecx, eax, 0
  000c5	ba 04 00 00 00	 mov	 edx, 4
  000ca	c1 e2 00	 shl	 edx, 0
  000cd	8b 45 f4	 mov	 eax, DWORD PTR _line$4[ebp]
  000d0	8b 75 0c	 mov	 esi, DWORD PTR _los$[ebp]
  000d3	8b 4c 08 1c	 mov	 ecx, DWORD PTR [eax+ecx+28]
  000d7	3b 4c 16 24	 cmp	 ecx, DWORD PTR [esi+edx+36]
  000db	7d 05		 jge	 SHORT $LN6@P_CrossSub
$LN7@P_CrossSub:

; 129  : 			line->bbox[BOXTOP]    < los->bbox[BOXBOTTOM])
; 130  : 			continue;

  000dd	e9 3a ff ff ff	 jmp	 $LN2@P_CrossSub
$LN6@P_CrossSub:

; 131  : 
; 132  : 		v1 = line->v1;

  000e2	8b 45 f4	 mov	 eax, DWORD PTR _line$4[ebp]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	89 4d e0	 mov	 DWORD PTR _v1$2[ebp], ecx

; 133  : 		v2 = line->v2;

  000ea	8b 45 f4	 mov	 eax, DWORD PTR _line$4[ebp]
  000ed	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f0	89 4d dc	 mov	 DWORD PTR _v2$1[ebp], ecx

; 134  : 
; 135  : 		// line isn't crossed?
; 136  : 		if (P_DivlineSide(v1->x, v1->y, &los->strace) ==

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  000f6	83 c0 0c	 add	 eax, 12			; 0000000cH
  000f9	50		 push	 eax
  000fa	8b 4d e0	 mov	 ecx, DWORD PTR _v1$2[ebp]
  000fd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00100	52		 push	 edx
  00101	8b 45 e0	 mov	 eax, DWORD PTR _v1$2[ebp]
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 _P_DivlineSide
  0010c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010f	8b f0		 mov	 esi, eax
  00111	8b 55 0c	 mov	 edx, DWORD PTR _los$[ebp]
  00114	83 c2 0c	 add	 edx, 12			; 0000000cH
  00117	52		 push	 edx
  00118	8b 45 dc	 mov	 eax, DWORD PTR _v2$1[ebp]
  0011b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011e	51		 push	 ecx
  0011f	8b 55 dc	 mov	 edx, DWORD PTR _v2$1[ebp]
  00122	8b 02		 mov	 eax, DWORD PTR [edx]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _P_DivlineSide
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	3b f0		 cmp	 esi, eax
  0012f	75 05		 jne	 SHORT $LN8@P_CrossSub

; 137  : 			P_DivlineSide(v2->x, v2->y, &los->strace))
; 138  : 			continue;

  00131	e9 e6 fe ff ff	 jmp	 $LN2@P_CrossSub
$LN8@P_CrossSub:

; 139  : 
; 140  : 		divl.dx = v2->x - (divl.x = v1->x);

  00136	8b 45 e0	 mov	 eax, DWORD PTR _v1$2[ebp]
  00139	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013b	89 4d e4	 mov	 DWORD PTR _divl$3[ebp], ecx
  0013e	8b 55 dc	 mov	 edx, DWORD PTR _v2$1[ebp]
  00141	8b 02		 mov	 eax, DWORD PTR [edx]
  00143	2b 45 e4	 sub	 eax, DWORD PTR _divl$3[ebp]
  00146	89 45 ec	 mov	 DWORD PTR _divl$3[ebp+8], eax

; 141  : 		divl.dy = v2->y - (divl.y = v1->y);

  00149	8b 45 e0	 mov	 eax, DWORD PTR _v1$2[ebp]
  0014c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014f	89 4d e8	 mov	 DWORD PTR _divl$3[ebp+4], ecx
  00152	8b 55 dc	 mov	 edx, DWORD PTR _v2$1[ebp]
  00155	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00158	2b 45 e8	 sub	 eax, DWORD PTR _divl$3[ebp+4]
  0015b	89 45 f0	 mov	 DWORD PTR _divl$3[ebp+12], eax

; 142  : 
; 143  : 		// line isn't crossed?
; 144  : 		if (P_DivlineSide(los->strace.x, los->strace.y, &divl) ==

  0015e	8d 45 e4	 lea	 eax, DWORD PTR _divl$3[ebp]
  00161	50		 push	 eax
  00162	8b 4d 0c	 mov	 ecx, DWORD PTR _los$[ebp]
  00165	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00168	52		 push	 edx
  00169	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  0016c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 _P_DivlineSide
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
  00178	8b f0		 mov	 esi, eax
  0017a	8d 55 e4	 lea	 edx, DWORD PTR _divl$3[ebp]
  0017d	52		 push	 edx
  0017e	8b 45 0c	 mov	 eax, DWORD PTR _los$[ebp]
  00181	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00184	51		 push	 ecx
  00185	8b 55 0c	 mov	 edx, DWORD PTR _los$[ebp]
  00188	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _P_DivlineSide
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
  00194	3b f0		 cmp	 esi, eax
  00196	75 05		 jne	 SHORT $LN9@P_CrossSub

; 145  : 			P_DivlineSide(los->t2x, los->t2y, &divl))
; 146  : 			continue;

  00198	e9 7f fe ff ff	 jmp	 $LN2@P_CrossSub
$LN9@P_CrossSub:

; 147  : 
; 148  : 		// stop because it is not two sided
; 149  : 		return false;

  0019d	33 c0		 xor	 eax, eax
  0019f	eb 0a		 jmp	 SHORT $LN1@P_CrossSub

; 150  : 	}

  001a1	e9 76 fe ff ff	 jmp	 $LN2@P_CrossSub
$LN3@P_CrossSub:

; 151  : 
; 152  : 	return true;

  001a6	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_CrossSub:

; 153  : }

  001ab	5f		 pop	 edi
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx
  001ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b1	33 cd		 xor	 ecx, ebp
  001b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
_P_CrossSubsecPolyObj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_sight.c
;	COMDAT _P_InterceptVector2
_TEXT	SEGMENT
_den$ = -12						; size = 4
_num$ = -8						; size = 4
_frac$ = -4						; size = 4
_v2$ = 8						; size = 4
_v1$ = 12						; size = 4
_P_InterceptVector2 PROC				; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	fixed_t frac, num, den;
; 96   : 
; 97   : 	den = FixedMul(v1->dy>>8, v2->dx) - FixedMul(v1->dx>>8, v2->dy);

  00009	8b 45 08	 mov	 eax, DWORD PTR _v2$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00013	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00016	c1 f8 08	 sar	 eax, 8
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _FixedMul
  0001f	83 c4 08	 add	 esp, 8
  00022	8b f0		 mov	 esi, eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _v2$[ebp]
  00027	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002a	52		 push	 edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0002e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00031	c1 f9 08	 sar	 ecx, 8
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _FixedMul
  0003a	83 c4 08	 add	 esp, 8
  0003d	2b f0		 sub	 esi, eax
  0003f	89 75 f4	 mov	 DWORD PTR _den$[ebp], esi

; 98   : 
; 99   : 	if (!den)

  00042	75 04		 jne	 SHORT $LN2@P_Intercep

; 100  : 		return 0;

  00044	33 c0		 xor	 eax, eax
  00046	eb 59		 jmp	 SHORT $LN1@P_Intercep
$LN2@P_Intercep:

; 101  : 
; 102  : 	num = FixedMul((v1->x - v2->x)>>8, v1->dy) + FixedMul((v2->y - v1->y)>>8, v1->dx);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0004b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004e	51		 push	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00052	8b 45 08	 mov	 eax, DWORD PTR _v2$[ebp]
  00055	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00057	2b 08		 sub	 ecx, DWORD PTR [eax]
  00059	c1 f9 08	 sar	 ecx, 8
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _FixedMul
  00062	83 c4 08	 add	 esp, 8
  00065	8b f0		 mov	 esi, eax
  00067	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  0006a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _v2$[ebp]
  00071	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00074	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00077	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0007a	c1 f8 08	 sar	 eax, 8
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _FixedMul
  00083	83 c4 08	 add	 esp, 8
  00086	03 f0		 add	 esi, eax
  00088	89 75 f8	 mov	 DWORD PTR _num$[ebp], esi

; 103  : 	frac = FixedDiv(num, den);

  0008b	8b 45 f4	 mov	 eax, DWORD PTR _den$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _num$[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _FixedDiv
  00098	83 c4 08	 add	 esp, 8
  0009b	89 45 fc	 mov	 DWORD PTR _frac$[ebp], eax

; 104  : 
; 105  : 	return frac;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _frac$[ebp]
$LN1@P_Intercep:

; 106  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_P_InterceptVector2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_sight.c
;	COMDAT _P_DivlineSide
_TEXT	SEGMENT
tv72 = -84						; size = 4
tv75 = -84						; size = 4
tv84 = -84						; size = 4
tv87 = -84						; size = 4
_right$ = -16						; size = 4
_left$ = -12						; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_node$ = 16						; size = 4
_P_DivlineSide PROC					; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 48   : 	fixed_t dx, dy, left, right;
; 49   : 
; 50   : 	if (!node->dx)

  00009	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	75 60		 jne	 SHORT $LN2@P_DivlineS

; 51   : 	{
; 52   : 		if (x == node->x)

  00012	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00018	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0001a	75 0a		 jne	 SHORT $LN3@P_DivlineS

; 53   : 			return 2;

  0001c	b8 02 00 00 00	 mov	 eax, 2
  00021	e9 12 01 00 00	 jmp	 $LN1@P_DivlineS
$LN3@P_DivlineS:

; 54   : 
; 55   : 		if (x <= node->x)

  00026	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0002c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0002e	7f 21		 jg	 SHORT $LN4@P_DivlineS

; 56   : 			return (node->dy > 0);

  00030	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  00033	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00037	7e 09		 jle	 SHORT $LN11@P_DivlineS
  00039	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00040	eb 07		 jmp	 SHORT $LN12@P_DivlineS
$LN11@P_DivlineS:
  00042	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN12@P_DivlineS:
  00049	8b 45 ac	 mov	 eax, DWORD PTR tv72[ebp]
  0004c	e9 e7 00 00 00	 jmp	 $LN1@P_DivlineS
$LN4@P_DivlineS:

; 57   : 
; 58   : 		return (node->dy < 0);

  00051	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  00054	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00058	7d 09		 jge	 SHORT $LN13@P_DivlineS
  0005a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00061	eb 07		 jmp	 SHORT $LN14@P_DivlineS
$LN13@P_DivlineS:
  00063	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN14@P_DivlineS:
  0006a	8b 45 ac	 mov	 eax, DWORD PTR tv75[ebp]
  0006d	e9 c6 00 00 00	 jmp	 $LN1@P_DivlineS
$LN2@P_DivlineS:

; 59   : 	}
; 60   : 
; 61   : 	if (!node->dy)

  00072	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  00075	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00079	75 5c		 jne	 SHORT $LN5@P_DivlineS

; 62   : 	{
; 63   : 		if (x == node->y)

  0007b	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00081	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00084	75 0a		 jne	 SHORT $LN6@P_DivlineS

; 64   : 			return 2;

  00086	b8 02 00 00 00	 mov	 eax, 2
  0008b	e9 a8 00 00 00	 jmp	 $LN1@P_DivlineS
$LN6@P_DivlineS:

; 65   : 
; 66   : 		if (y <= node->y)

  00090	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00096	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00099	7f 1e		 jg	 SHORT $LN7@P_DivlineS

; 67   : 			return (node->dx < 0);

  0009b	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  0009e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000a2	7d 09		 jge	 SHORT $LN15@P_DivlineS
  000a4	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  000ab	eb 07		 jmp	 SHORT $LN16@P_DivlineS
$LN15@P_DivlineS:
  000ad	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN16@P_DivlineS:
  000b4	8b 45 ac	 mov	 eax, DWORD PTR tv84[ebp]
  000b7	eb 7f		 jmp	 SHORT $LN1@P_DivlineS
$LN7@P_DivlineS:

; 68   : 
; 69   : 		return (node->dx > 0);

  000b9	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  000bc	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000c0	7e 09		 jle	 SHORT $LN17@P_DivlineS
  000c2	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  000c9	eb 07		 jmp	 SHORT $LN18@P_DivlineS
$LN17@P_DivlineS:
  000cb	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN18@P_DivlineS:
  000d2	8b 45 ac	 mov	 eax, DWORD PTR tv87[ebp]
  000d5	eb 61		 jmp	 SHORT $LN1@P_DivlineS
$LN5@P_DivlineS:

; 70   : 	}
; 71   : 
; 72   : 	dx = x - node->x;

  000d7	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000dd	2b 08		 sub	 ecx, DWORD PTR [eax]
  000df	89 4d fc	 mov	 DWORD PTR _dx$[ebp], ecx

; 73   : 	dy = y - node->y;

  000e2	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  000e5	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000e8	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000eb	89 4d f8	 mov	 DWORD PTR _dy$[ebp], ecx

; 74   : 
; 75   : 	left = (node->dy>>FRACBITS) * (dx>>FRACBITS);

  000ee	8b 45 10	 mov	 eax, DWORD PTR _node$[ebp]
  000f1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000f4	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _dx$[ebp]
  000fa	c1 fa 10	 sar	 edx, 16			; 00000010H
  000fd	0f af ca	 imul	 ecx, edx
  00100	89 4d f4	 mov	 DWORD PTR _left$[ebp], ecx

; 76   : 	right = (dy>>FRACBITS) * (node->dx>>FRACBITS);

  00103	8b 45 f8	 mov	 eax, DWORD PTR _dy$[ebp]
  00106	c1 f8 10	 sar	 eax, 16			; 00000010H
  00109	8b 4d 10	 mov	 ecx, DWORD PTR _node$[ebp]
  0010c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0010f	c1 fa 10	 sar	 edx, 16			; 00000010H
  00112	0f af c2	 imul	 eax, edx
  00115	89 45 f0	 mov	 DWORD PTR _right$[ebp], eax

; 77   : 
; 78   : 	if (right < left)

  00118	8b 45 f0	 mov	 eax, DWORD PTR _right$[ebp]
  0011b	3b 45 f4	 cmp	 eax, DWORD PTR _left$[ebp]
  0011e	7d 04		 jge	 SHORT $LN8@P_DivlineS

; 79   : 		return 0; // front side

  00120	33 c0		 xor	 eax, eax
  00122	eb 14		 jmp	 SHORT $LN1@P_DivlineS
$LN8@P_DivlineS:

; 80   : 
; 81   : 	if (left == right)

  00124	8b 45 f4	 mov	 eax, DWORD PTR _left$[ebp]
  00127	3b 45 f0	 cmp	 eax, DWORD PTR _right$[ebp]
  0012a	75 07		 jne	 SHORT $LN9@P_DivlineS

; 82   : 		return 2;

  0012c	b8 02 00 00 00	 mov	 eax, 2
  00131	eb 05		 jmp	 SHORT $LN1@P_DivlineS
$LN9@P_DivlineS:

; 83   : 
; 84   : 	return 1; // back side

  00133	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_DivlineS:

; 85   : }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
_P_DivlineSide ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_sight.c
;	COMDAT _P_CheckSight
_TEXT	SEGMENT
_rover$1 = -80						; size = 4
_sight2$2 = -76						; size = 4
_sight1$3 = -72						; size = 4
_los$ = -68						; size = 52
_pnum$ = -16						; size = 4
_s2$ = -12						; size = 4
_s1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
_P_CheckSight PROC					; COMDAT

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 315  : 	const sector_t *s1 = t1->subsector->sector;

  00016	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00019	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	89 55 f8	 mov	 DWORD PTR _s1$[ebp], edx

; 316  : 	const sector_t *s2 = t2->subsector->sector;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  00024	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	89 55 f4	 mov	 DWORD PTR _s2$[ebp], edx

; 317  : 	size_t pnum = (s1-sectors)*numsectors + (s2-sectors);

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _s1$[ebp]
  0002f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00035	99		 cdq
  00036	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0003b	f7 f9		 idiv	 ecx
  0003d	8b c8		 mov	 ecx, eax
  0003f	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _numsectors
  00046	8b 45 f4	 mov	 eax, DWORD PTR _s2$[ebp]
  00049	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  0004f	99		 cdq
  00050	be f8 00 00 00	 mov	 esi, 248		; 000000f8H
  00055	f7 fe		 idiv	 esi
  00057	03 c8		 add	 ecx, eax
  00059	89 4d f0	 mov	 DWORD PTR _pnum$[ebp], ecx

; 318  : 	los_t los;
; 319  : 
; 320  : 	// First check for trivial rejection.
; 321  : 	if (!t1 || !t2 || !t1->subsector || !t2->subsector
; 322  : 		|| !t1->subsector->sector || !t2->subsector->sector)

  0005c	83 7d 08 00	 cmp	 DWORD PTR _t1$[ebp], 0
  00060	74 2e		 je	 SHORT $LN6@P_CheckSig
  00062	83 7d 0c 00	 cmp	 DWORD PTR _t2$[ebp], 0
  00066	74 28		 je	 SHORT $LN6@P_CheckSig
  00068	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  0006b	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0006f	74 1f		 je	 SHORT $LN6@P_CheckSig
  00071	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  00074	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00078	74 16		 je	 SHORT $LN6@P_CheckSig
  0007a	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  0007d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00080	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00083	74 0b		 je	 SHORT $LN6@P_CheckSig
  00085	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  00088	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0008b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0008e	75 07		 jne	 SHORT $LN5@P_CheckSig
$LN6@P_CheckSig:

; 323  : 	{
; 324  : 		return false;

  00090	33 c0		 xor	 eax, eax
  00092	e9 2e 03 00 00	 jmp	 $LN1@P_CheckSig
$LN5@P_CheckSig:

; 325  : 	}
; 326  : 
; 327  : 	// Check in REJECT table.
; 328  : 	if (rejectmatrix[pnum>>3] & (1 << (pnum&7))) // can't possibly be connected

  00097	8b 45 f0	 mov	 eax, DWORD PTR _pnum$[ebp]
  0009a	c1 e8 03	 shr	 eax, 3
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rejectmatrix
  000a3	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _pnum$[ebp]
  000aa	83 e1 07	 and	 ecx, 7
  000ad	b8 01 00 00 00	 mov	 eax, 1
  000b2	d3 e0		 shl	 eax, cl
  000b4	23 d0		 and	 edx, eax
  000b6	74 07		 je	 SHORT $LN7@P_CheckSig

; 329  : 		return false;

  000b8	33 c0		 xor	 eax, eax
  000ba	e9 06 03 00 00	 jmp	 $LN1@P_CheckSig
$LN7@P_CheckSig:

; 330  : 
; 331  : 	// killough 11/98: shortcut for melee situations
; 332  : 	// same subsector? obviously visible
; 333  : #ifndef POLYOBJECTS
; 334  : 	if (t1->subsector == t2->subsector)
; 335  : 		return true;
; 336  : #else
; 337  : 	// haleyjd 02/23/06: can't do this if there are polyobjects in the subsec
; 338  : 	if (!t1->subsector->polyList &&

  000bf	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  000c2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000c5	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000c9	75 18		 jne	 SHORT $LN8@P_CheckSig
  000cb	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR _t2$[ebp]
  000d1	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  000d4	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  000d7	75 0a		 jne	 SHORT $LN8@P_CheckSig

; 339  : 		t1->subsector == t2->subsector)
; 340  : 		return true;

  000d9	b8 01 00 00 00	 mov	 eax, 1
  000de	e9 e2 02 00 00	 jmp	 $LN1@P_CheckSig
$LN8@P_CheckSig:

; 341  : #endif
; 342  : 
; 343  : 	// An unobstructed LOS is possible.
; 344  : 	// Now look from eyes of t1 to any part of t2.
; 345  : 	sightcounts[1]++;

  000e3	b8 04 00 00 00	 mov	 eax, 4
  000e8	c1 e0 00	 shl	 eax, 0
  000eb	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _sightcounts[eax]
  000f1	83 c1 01	 add	 ecx, 1
  000f4	ba 04 00 00 00	 mov	 edx, 4
  000f9	c1 e2 00	 shl	 edx, 0
  000fc	89 8a 00 00 00
	00		 mov	 DWORD PTR _sightcounts[edx], ecx

; 346  : 
; 347  : 	validcount++;

  00102	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  00107	83 c0 01	 add	 eax, 1
  0010a	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 348  : 
; 349  : 	los.topslope =

  0010f	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00112	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00115	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  00118	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0011b	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  0011e	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  00121	c1 fa 02	 sar	 edx, 2
  00124	2b ca		 sub	 ecx, edx
  00126	89 4d bc	 mov	 DWORD PTR _los$[ebp], ecx
  00129	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  0012c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0012f	2b 4d bc	 sub	 ecx, DWORD PTR _los$[ebp]
  00132	89 4d dc	 mov	 DWORD PTR _los$[ebp+32], ecx
  00135	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  00138	8b 45 dc	 mov	 eax, DWORD PTR _los$[ebp+32]
  0013b	03 42 44	 add	 eax, DWORD PTR [edx+68]
  0013e	89 45 d8	 mov	 DWORD PTR _los$[ebp+28], eax

; 350  : 		(los.bottomslope = t2->z - (los.sightzstart =
; 351  : 			t1->z + t1->height -
; 352  : 			(t1->height>>2))) + t2->height;
; 353  : 	los.strace.dx = (los.t2x = t2->x) - (los.strace.x = t1->x);

  00141	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  00144	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00147	89 4d c0	 mov	 DWORD PTR _los$[ebp+4], ecx
  0014a	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  0014d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00150	89 45 c8	 mov	 DWORD PTR _los$[ebp+12], eax
  00153	8b 4d c0	 mov	 ecx, DWORD PTR _los$[ebp+4]
  00156	2b 4d c8	 sub	 ecx, DWORD PTR _los$[ebp+12]
  00159	89 4d d0	 mov	 DWORD PTR _los$[ebp+20], ecx

; 354  : 	los.strace.dy = (los.t2y = t2->y) - (los.strace.y = t1->y);

  0015c	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  0015f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00162	89 4d c4	 mov	 DWORD PTR _los$[ebp+8], ecx
  00165	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  00168	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0016b	89 45 cc	 mov	 DWORD PTR _los$[ebp+16], eax
  0016e	8b 4d c4	 mov	 ecx, DWORD PTR _los$[ebp+8]
  00171	2b 4d cc	 sub	 ecx, DWORD PTR _los$[ebp+16]
  00174	89 4d d4	 mov	 DWORD PTR _los$[ebp+24], ecx

; 355  : 
; 356  : 	if (t1->x > t2->x)

  00177	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  0017a	8b 4d 0c	 mov	 ecx, DWORD PTR _t2$[ebp]
  0017d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00180	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00183	7e 25		 jle	 SHORT $LN9@P_CheckSig

; 357  : 		los.bbox[BOXRIGHT] = t1->x, los.bbox[BOXLEFT] = t2->x;

  00185	b8 04 00 00 00	 mov	 eax, 4
  0018a	6b c8 03	 imul	 ecx, eax, 3
  0018d	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  00190	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00193	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
  00197	b9 04 00 00 00	 mov	 ecx, 4
  0019c	d1 e1		 shl	 ecx, 1
  0019e	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  001a1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001a4	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
  001a8	eb 23		 jmp	 SHORT $LN10@P_CheckSig
$LN9@P_CheckSig:

; 358  : 	else
; 359  : 		los.bbox[BOXRIGHT] = t2->x, los.bbox[BOXLEFT] = t1->x;

  001aa	b8 04 00 00 00	 mov	 eax, 4
  001af	6b c8 03	 imul	 ecx, eax, 3
  001b2	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  001b5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001b8	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
  001bc	b9 04 00 00 00	 mov	 ecx, 4
  001c1	d1 e1		 shl	 ecx, 1
  001c3	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  001c6	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001c9	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
$LN10@P_CheckSig:

; 360  : 
; 361  : 	if (t1->y > t2->y)

  001cd	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  001d0	8b 4d 0c	 mov	 ecx, DWORD PTR _t2$[ebp]
  001d3	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001d6	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  001d9	7e 26		 jle	 SHORT $LN11@P_CheckSig

; 362  : 		los.bbox[BOXTOP] = t1->y, los.bbox[BOXBOTTOM] = t2->y;

  001db	b8 04 00 00 00	 mov	 eax, 4
  001e0	6b c8 00	 imul	 ecx, eax, 0
  001e3	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  001e6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001e9	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
  001ed	b9 04 00 00 00	 mov	 ecx, 4
  001f2	c1 e1 00	 shl	 ecx, 0
  001f5	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  001f8	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001fb	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
  001ff	eb 24		 jmp	 SHORT $LN12@P_CheckSig
$LN11@P_CheckSig:

; 363  : 	else
; 364  : 		los.bbox[BOXTOP] = t2->y, los.bbox[BOXBOTTOM] = t1->y;

  00201	b8 04 00 00 00	 mov	 eax, 4
  00206	6b c8 00	 imul	 ecx, eax, 0
  00209	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  0020c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0020f	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
  00213	b9 04 00 00 00	 mov	 ecx, 4
  00218	c1 e1 00	 shl	 ecx, 0
  0021b	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  0021e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00221	89 44 0d e0	 mov	 DWORD PTR _los$[ebp+ecx+36], eax
$LN12@P_CheckSig:

; 365  : 
; 366  : 	// Prevent SOME cases of looking through 3dfloors
; 367  : 	//
; 368  : 	// This WILL NOT work for things like 3d stairs with monsters behind
; 369  : 	// them - they will still see you! TODO: Fix.
; 370  : 	//
; 371  : 	if (s1 == s2) // Both sectors are the same.

  00225	8b 45 f8	 mov	 eax, DWORD PTR _s1$[ebp]
  00228	3b 45 f4	 cmp	 eax, DWORD PTR _s2$[ebp]
  0022b	0f 85 7e 01 00
	00		 jne	 $LN3@P_CheckSig

; 372  : 	{
; 373  : 		fixed_t sight1, sight2;
; 374  : 		ffloor_t *rover;
; 375  : 
; 376  : 		sight1 = t1->z + (t1->height>>2);

  00231	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00234	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00237	c1 f9 02	 sar	 ecx, 2
  0023a	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  0023d	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00240	89 4d b8	 mov	 DWORD PTR _sight1$3[ebp], ecx

; 377  : 		sight2 = t2->z + (t2->height>>2);

  00243	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  00246	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00249	c1 f9 02	 sar	 ecx, 2
  0024c	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  0024f	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00252	89 4d b4	 mov	 DWORD PTR _sight2$2[ebp], ecx

; 378  : 
; 379  : 		for (rover = s1->ffloors; rover; rover = rover->next)

  00255	8b 45 f8	 mov	 eax, DWORD PTR _s1$[ebp]
  00258	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0025e	89 4d b0	 mov	 DWORD PTR _rover$1[ebp], ecx
  00261	eb 09		 jmp	 SHORT $LN4@P_CheckSig
$LN2@P_CheckSig:
  00263	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00266	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00269	89 4d b0	 mov	 DWORD PTR _rover$1[ebp], ecx
$LN4@P_CheckSig:
  0026c	83 7d b0 00	 cmp	 DWORD PTR _rover$1[ebp], 0
  00270	0f 84 39 01 00
	00		 je	 $LN3@P_CheckSig

; 380  : 		{
; 381  : 			// Allow sight through water, fog, etc.
; 382  : 			/// \todo Improve by checking fog density/translucency
; 383  : 			/// and setting a sight limit.
; 384  : 			if (!(rover->flags & FF_EXISTS)
; 385  : 				|| !(rover->flags & FF_RENDERPLANES) || rover->flags & FF_TRANSLUCENT)

  00276	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00279	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0027c	83 e1 01	 and	 ecx, 1
  0027f	74 19		 je	 SHORT $LN15@P_CheckSig
  00281	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00284	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00287	83 e1 10	 and	 ecx, 16			; 00000010H
  0028a	74 0e		 je	 SHORT $LN15@P_CheckSig
  0028c	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0028f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00292	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00298	74 02		 je	 SHORT $LN14@P_CheckSig
$LN15@P_CheckSig:

; 386  : 			{
; 387  : 				continue;

  0029a	eb c7		 jmp	 SHORT $LN2@P_CheckSig
$LN14@P_CheckSig:

; 388  : 			}
; 389  : 
; 390  : 			// Check for blocking floors here.
; 391  : 			if ((los.sightzstart < *rover->bottomheight && t2->z >= *rover->topheight)
; 392  : 				|| (los.sightzstart >= *rover->topheight && t2->z + t2->height < *rover->bottomheight))

  0029c	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0029f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002a2	8b 55 bc	 mov	 edx, DWORD PTR _los$[ebp]
  002a5	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002a7	7d 0f		 jge	 SHORT $LN18@P_CheckSig
  002a9	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  002ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ae	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  002b1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002b4	3b 01		 cmp	 eax, DWORD PTR [ecx]
  002b6	7d 22		 jge	 SHORT $LN17@P_CheckSig
$LN18@P_CheckSig:
  002b8	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  002bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002bd	8b 55 bc	 mov	 edx, DWORD PTR _los$[ebp]
  002c0	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002c2	7c 1d		 jl	 SHORT $LN16@P_CheckSig
  002c4	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  002c7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002ca	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  002cd	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  002d0	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  002d3	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  002d6	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  002d8	7d 07		 jge	 SHORT $LN16@P_CheckSig
$LN17@P_CheckSig:

; 393  : 			{
; 394  : 				// no way to see through that
; 395  : 				return false;

  002da	33 c0		 xor	 eax, eax
  002dc	e9 e4 00 00 00	 jmp	 $LN1@P_CheckSig
$LN16@P_CheckSig:

; 396  : 			}
; 397  : 
; 398  : 			if (rover->flags & FF_SOLID)

  002e1	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  002e4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002e7	83 e1 06	 and	 ecx, 6
  002ea	74 05		 je	 SHORT $LN19@P_CheckSig

; 399  : 				continue; // shortcut since neither mobj can be inside the 3dfloor

  002ec	e9 72 ff ff ff	 jmp	 $LN2@P_CheckSig
$LN19@P_CheckSig:

; 400  : 
; 401  : 			if (!(rover->flags & FF_INVERTPLANES))

  002f1	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  002f4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002f7	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  002fd	75 49		 jne	 SHORT $LN22@P_CheckSig

; 402  : 			{
; 403  : 				if (los.sightzstart >= *rover->topheight && t2->z + t2->height < *rover->topheight)

  002ff	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00302	8b 08		 mov	 ecx, DWORD PTR [eax]
  00304	8b 55 bc	 mov	 edx, DWORD PTR _los$[ebp]
  00307	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00309	7c 1c		 jl	 SHORT $LN21@P_CheckSig
  0030b	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  0030e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00311	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  00314	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00317	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0031a	8b 10		 mov	 edx, DWORD PTR [eax]
  0031c	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0031e	7d 07		 jge	 SHORT $LN21@P_CheckSig

; 404  : 					return false; // blocked by upper outside plane

  00320	33 c0		 xor	 eax, eax
  00322	e9 9e 00 00 00	 jmp	 $LN1@P_CheckSig
$LN21@P_CheckSig:

; 405  : 
; 406  : 				if (los.sightzstart < *rover->bottomheight && t2->z >= *rover->bottomheight)

  00327	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0032a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0032d	8b 55 bc	 mov	 edx, DWORD PTR _los$[ebp]
  00330	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00332	7d 14		 jge	 SHORT $LN22@P_CheckSig
  00334	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00337	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0033a	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  0033d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00340	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00342	7c 04		 jl	 SHORT $LN22@P_CheckSig

; 407  : 					return false; // blocked by lower outside plane

  00344	33 c0		 xor	 eax, eax
  00346	eb 7d		 jmp	 SHORT $LN1@P_CheckSig
$LN22@P_CheckSig:

; 408  : 			}
; 409  : 
; 410  : 			if (rover->flags & FF_INVERTPLANES || rover->flags & FF_BOTHPLANES)

  00348	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0034b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0034e	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00354	75 0e		 jne	 SHORT $LN24@P_CheckSig
  00356	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00359	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0035c	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00362	74 46		 je	 SHORT $LN26@P_CheckSig
$LN24@P_CheckSig:

; 411  : 			{
; 412  : 				if (los.sightzstart < *rover->topheight && t2->z >= *rover->topheight)

  00364	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00367	8b 08		 mov	 ecx, DWORD PTR [eax]
  00369	8b 55 bc	 mov	 edx, DWORD PTR _los$[ebp]
  0036c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0036e	7d 13		 jge	 SHORT $LN25@P_CheckSig
  00370	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00373	8b 08		 mov	 ecx, DWORD PTR [eax]
  00375	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  00378	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0037b	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0037d	7c 04		 jl	 SHORT $LN25@P_CheckSig

; 413  : 					return false; // blocked by upper inside plane

  0037f	33 c0		 xor	 eax, eax
  00381	eb 42		 jmp	 SHORT $LN1@P_CheckSig
$LN25@P_CheckSig:

; 414  : 
; 415  : 				if (los.sightzstart >= *rover->bottomheight && t2->z + t2->height < *rover->bottomheight)

  00383	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00386	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00389	8b 55 bc	 mov	 edx, DWORD PTR _los$[ebp]
  0038c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0038e	7c 1a		 jl	 SHORT $LN26@P_CheckSig
  00390	8b 45 0c	 mov	 eax, DWORD PTR _t2$[ebp]
  00393	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00396	8b 55 0c	 mov	 edx, DWORD PTR _t2$[ebp]
  00399	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0039c	8b 45 b0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0039f	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  003a2	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  003a4	7d 04		 jge	 SHORT $LN26@P_CheckSig

; 416  : 					return false; // blocked by lower inside plane

  003a6	33 c0		 xor	 eax, eax
  003a8	eb 1b		 jmp	 SHORT $LN1@P_CheckSig
$LN26@P_CheckSig:

; 417  : 			}
; 418  : 		}

  003aa	e9 b4 fe ff ff	 jmp	 $LN2@P_CheckSig
$LN3@P_CheckSig:

; 419  : 	}
; 420  : 
; 421  : 	// the head node is the last node output
; 422  : 	return P_CrossBSPNode((INT32)numnodes - 1, &los);

  003af	8d 45 bc	 lea	 eax, DWORD PTR _los$[ebp]
  003b2	50		 push	 eax
  003b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numnodes
  003b9	83 e9 01	 sub	 ecx, 1
  003bc	51		 push	 ecx
  003bd	e8 00 00 00 00	 call	 _P_CrossBSPNode
  003c2	83 c4 08	 add	 esp, 8
$LN1@P_CheckSig:

; 423  : }

  003c5	5f		 pop	 edi
  003c6	5e		 pop	 esi
  003c7	5b		 pop	 ebx
  003c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003cb	33 cd		 xor	 ecx, ebp
  003cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d2	8b e5		 mov	 esp, ebp
  003d4	5d		 pop	 ebp
  003d5	c3		 ret	 0
_P_CheckSight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
END
