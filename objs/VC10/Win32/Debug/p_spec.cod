; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\p_spec.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
CONST	SEGMENT
_laserflags DD	0959H
CONST	ENDS
PUBLIC	_P_InitPicAnims
PUBLIC	_P_SetupLevelFlatAnims
PUBLIC	_P_SpawnSpecials
PUBLIC	_P_UpdateSpecials
PUBLIC	_P_PlayerTouchingSectorSpecial
PUBLIC	_P_PlayerInSpecialSector
PUBLIC	_P_ProcessSpecialSector
PUBLIC	_P_FindLowestFloorSurrounding
PUBLIC	_P_FindHighestFloorSurrounding
PUBLIC	_P_FindNextHighestFloor
PUBLIC	_P_FindNextLowestFloor
PUBLIC	_P_FindLowestCeilingSurrounding
PUBLIC	_P_FindHighestCeilingSurrounding
PUBLIC	_P_FindSectorFromLineTag
PUBLIC	_P_FindSectorFromTag
PUBLIC	_P_FindSpecialLineFromTag
PUBLIC	_P_FindMinSurroundingLight
PUBLIC	_P_SetupSignExit
PUBLIC	_P_SwitchWeather
PUBLIC	_P_LinedefExecute
PUBLIC	_P_ChangeSectorTag
PUBLIC	_T_ExecutorDelay
PUBLIC	_T_Scroll
PUBLIC	_T_LaserFlash
PUBLIC	_T_Friction
PUBLIC	_T_Disappear
PUBLIC	_T_Pusher
PUBLIC	_P_GetPushThing
PUBLIC	_P_ThingOnSpecial3DFloor
PUBLIC	??_C@_08ENOFCJPE@ANIMATED@			; `string'
PUBLIC	??_C@_0CB@LGALMIEA@No?5free?5memory?5for?5ANIMATED?5dat@ ; `string'
PUBLIC	??_C@_0CI@NPDMFJCJ@P_InitPicAnims?3?5bad?5cycle?5from?5@ ; `string'
PUBLIC	??_C@_0DB@PPFFLENC@AnimatedFlat?5start?5?$CFs?5not?5in?5sa@ ; `string'
PUBLIC	??_C@_0DL@DNGGGIOB@animflat?3?5?$CD?$CF03Iu?5name?3?$CF?48s?5anim@ ; `string'
PUBLIC	??_C@_0BP@DLBMDGJG@PolyInvisible?3?5bad?5polyobj?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BN@KIIHCCJ@PolyVisible?3?5bad?5polyobj?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@ ; `string'
PUBLIC	??_C@_0CA@EIHMNEPK@Corrupt?5tag?5list?5for?5sector?5?$CFu?6@ ; `string'
PUBLIC	??_C@_0CN@JGFODBHM@P_AddExecutorDelay?3?5Line?5has?5no@ ; `string'
PUBLIC	??_C@_0DK@HMODDHIJ@Warning?3?5Sector?5?$CFIu?5is?5not?5clos@ ; `string'
PUBLIC	??_C@_0BK@DKKFEAKA@Unknown?5weather?5type?5?$CFd?4?6@ ; `string'
PUBLIC	??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@ ; `string'
PUBLIC	??_C@_0DI@HBJMHHLC@Line?5type?5436?5Executor?3?5Target?5@ ; `string'
PUBLIC	??_C@_0EF@ONKOONKC@Line?5type?5436?5Executor?3?5Can?8t?5f@ ; `string'
PUBLIC	??_C@_0P@HLFJDFHH@changeteam?5red@		; `string'
PUBLIC	??_C@_0BA@PEKCJCD@changeteam2?5red@		; `string'
PUBLIC	??_C@_0BP@OMOKFAHO@?$CFs?2captured?5the?5blue?5flag?4?2?2?2?2@ ; `string'
PUBLIC	??_C@_0BM@NCHIJMJN@?$CFs?5captured?5the?5blue?5flag?4?6@ ; `string'
PUBLIC	??_C@_0CH@LFDGLEBD@the?5enemy?5has?5returned?2their?5fl@ ; `string'
PUBLIC	??_C@_0CI@PCBKHFLB@the?5blue?5team?5has?5returned?5thei@ ; `string'
PUBLIC	??_C@_0CE@EBPGLBCL@your?5flag?5was?5returned?2to?5base?4@ ; `string'
PUBLIC	??_C@_0CF@IFDPBPCN@your?5red?5flag?5was?5returned?5to?5b@ ; `string'
PUBLIC	??_C@_0BA@NGJMDDAH@changeteam?5blue@		; `string'
PUBLIC	??_C@_0BB@LKOOLFPG@changeteam2?5blue@		; `string'
PUBLIC	??_C@_0BO@GPOAFCDN@?$CFs?2captured?5the?5red?5flag?4?2?2?2?2@ ; `string'
PUBLIC	??_C@_0BL@MIPBFDCD@?$CFs?5captured?5the?5red?5flag?4?6@ ; `string'
PUBLIC	??_C@_0CH@GHLKNNGA@the?5red?5team?5has?5returned?5their@ ; `string'
PUBLIC	??_C@_0CG@CLJLMGKF@your?5blue?5flag?5was?5returned?5to?5@ ; `string'
PUBLIC	??_C@_0DD@HOADDFGL@ERROR?3?5Sector?5special?5?$CFd?5missin@ ; `string'
PUBLIC	??_C@_0DB@IDAAEOCG@ERROR?3?5FIRST?5WAYPOINT?5IN?5SEQUEN@ ; `string'
PUBLIC	??_C@_0CP@BGLBOMJP@Waypoint?5?$CFd?5found?5in?5sequence?5?$CF@ ; `string'
PUBLIC	??_C@_0DA@MHOJGJAN@ERROR?3?5LAST?5WAYPOINT?5IN?5SEQUENC@ ; `string'
PUBLIC	??_C@_09KFDLEEGG@FINISHED?$CB@			; `string'
PUBLIC	??_C@_0DE@GNAPKJPK@ERROR?3?5Sector?5special?5?$CFd?5missin@ ; `string'
PUBLIC	??_C@_0CO@NDOBHENA@ERROR?3?5WAYPOINT?$CIS?$CJ?5IN?5SEQUENCE?5@ ; `string'
PUBLIC	??_C@_0DE@KBAFCDBG@WaypointMid?3?5?$CFd?$DL?5WaypointLow?3?5?$CF@ ; `string'
PUBLIC	??_C@_0DE@OPMPDJLP@?$CFs?5recieved?5double?5points?5for?5s@ ; `string'
PUBLIC	??_C@_0FC@DOPDFDHL@One?5of?5your?5FOFs?5with?5a?5tag?5of?5@ ; `string'
PUBLIC	??_C@_0FL@BIGCHJLL@Make?9Your?9Own?9FOF?5?$CItag?5?$CFd?$CJ?5need@ ; `string'
PUBLIC	??_C@_0DN@MNKJLNKI@Make?9Your?9Own?5FOF?5?$CItag?5?$CFd?$CJ?5foun@ ; `string'
PUBLIC	??_C@_0DA@IAIAPEMG@Line?5special?5506?5?$CIline?5?$CD?$CFIu?$CJ?5mi@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_abs:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_AngleFixed:PROC
EXTRN	_A_CustomPower:PROC
EXTRN	_P_SpawnPrecipitation:PROC
EXTRN	_P_SnowThinker:PROC
EXTRN	_P_RainThinker:PROC
EXTRN	_P_NullPrecipThinker:PROC
EXTRN	_P_RemovePrecipMobj:PROC
EXTRN	_COM_BufInsertText:PROC
EXTRN	_COM_ImmedExecute:PROC
EXTRN	_SendNetXCmd:PROC
EXTRN	_D_NumPlayers:PROC
EXTRN	_G_BuildMapName:PROC
EXTRN	_P_SetTarget:PROC
EXTRN	_Polyobj_GetForNum:PROC
EXTRN	_Polyobj_InitLevel:PROC
EXTRN	_P_MobjTouchingPolyobj:PROC
EXTRN	_P_MobjInsidePolyobj:PROC
EXTRN	_EV_DoPolyDoor:PROC
EXTRN	_EV_DoPolyObjMove:PROC
EXTRN	_EV_DoPolyObjWaypoint:PROC
EXTRN	_EV_DoPolyObjRotate:PROC
EXTRN	_EV_DoPolyObjFlag:PROC
EXTRN	_P_AproxDistance:PROC
EXTRN	_P_ClosestPointOnLine:PROC
EXTRN	_P_BlockThingsIterator:PROC
EXTRN	_P_AddThinker:PROC
EXTRN	_P_RemoveThinker:PROC
EXTRN	_P_GetPlayerHeight:PROC
EXTRN	_P_GetPlayerSpinHeight:PROC
EXTRN	_P_AddPlayerScore:PROC
EXTRN	_P_ResetPlayer:PROC
EXTRN	_P_IsLocalPlayer:PROC
EXTRN	_P_IsObjectOnGround:PROC
EXTRN	_P_ResetScore:PROC
EXTRN	_P_FreezeObjectplace:PROC
EXTRN	_P_DoPlayerExit:PROC
EXTRN	_P_InstaThrust:PROC
EXTRN	_P_FindLowestMare:PROC
EXTRN	_P_SpawnMobj:PROC
EXTRN	_P_SetPlayerMobjState:PROC
EXTRN	_P_SetMobjState:PROC
EXTRN	_P_MobjThinker:PROC
EXTRN	_P_UnsetThingPosition:PROC
EXTRN	_P_SetThingPosition:PROC
EXTRN	_P_CheckSight:PROC
EXTRN	_P_DamageMobj:PROC
EXTRN	_P_TouchSpecialThing:PROC
EXTRN	_P_PlayerFlagBurst:PROC
EXTRN	_P_CheckPointLimit:PROC
EXTRN	_P_PlayRinglossSound:PROC
EXTRN	_P_SpawnAdjustableFireFlicker:PROC
EXTRN	_P_SpawnAdjustableStrobeFlash:PROC
EXTRN	_P_SpawnAdjustableGlowingLight:PROC
EXTRN	_P_FadeLight:PROC
EXTRN	_EV_DoCeiling:PROC
EXTRN	_EV_DoCrush:PROC
EXTRN	_EV_DoFloor:PROC
EXTRN	_EV_DoElevator:PROC
EXTRN	_EV_CrumbleChain:PROC
EXTRN	_EV_DoContinuousFall:PROC
EXTRN	_T_SpikeSector:PROC
EXTRN	_T_FloatSector:PROC
EXTRN	_T_MarioBlockChecker:PROC
EXTRN	_T_ThwompSector:PROC
EXTRN	_T_NoEnemiesSector:PROC
EXTRN	_T_EachTimeThinker:PROC
EXTRN	_T_CameraScanner:PROC
EXTRN	_T_RaiseSector:PROC
EXTRN	_P_Teleport:PROC
EXTRN	_P_DoSuperTransformation:PROC
EXTRN	_P_SetupLevelSky:PROC
EXTRN	_R_GetFlatNumForName:PROC
EXTRN	_R_TextureNumForName:PROC
EXTRN	_R_CheckTextureNumForName:PROC
EXTRN	_M_Random:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_S_ChangeMusic:PROC
EXTRN	_S_StopMusic:PROC
EXTRN	_W_CheckNumForName:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_W_CacheLumpName:PROC
EXTRN	_Z_ChangeTag2:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_Z_ReallocAlign:PROC
EXTRN	_R_PointToAngle2:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_HU_SetCEchoDuration:PROC
EXTRN	_HU_SetCEchoFlags:PROC
EXTRN	_HU_DoCEcho:PROC
EXTRN	_S_StartAttackSound:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_gameaction:DWORD
EXTRN	_devparm:DWORD
EXTRN	_finesine:BYTE
EXTRN	_finecosine:DWORD
EXTRN	_tantoangle:BYTE
EXTRN	_states:BYTE
EXTRN	_mobjinfo:BYTE
EXTRN	_numstarposts:DWORD
EXTRN	_gamemap:WORD
EXTRN	_mapmusic:DWORD
EXTRN	_maptol:WORD
EXTRN	_globalweather:BYTE
EXTRN	_curWeather:DWORD
EXTRN	_netgame:DWORD
EXTRN	_multiplayer:DWORD
EXTRN	_gametype:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_circuitmap:DWORD
EXTRN	_cv_debug:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_sstage_start:WORD
EXTRN	_sstage_end:WORD
EXTRN	_useNightsSS:DWORD
EXTRN	_nextmapoverride:WORD
EXTRN	_nextmapgametype:DWORD
EXTRN	_skipstats:DWORD
EXTRN	_totalrings:DWORD
EXTRN	_rflagpoint:DWORD
EXTRN	_bflagpoint:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	_emeralds:WORD
EXTRN	_sstimer:DWORD
EXTRN	_bluescore:DWORD
EXTRN	_redscore:DWORD
EXTRN	_CheckForBustableBlocks:DWORD
EXTRN	_CheckForBouncySector:DWORD
EXTRN	_CheckForQuicksand:DWORD
EXTRN	_CheckForMarioBlocks:DWORD
EXTRN	_CheckForFloatBob:DWORD
EXTRN	_CheckForReverseGravity:DWORD
EXTRN	_flashingtics:DWORD
EXTRN	_spacetimetics:DWORD
EXTRN	_gravity:DWORD
EXTRN	_text:BYTE
EXTRN	_cv_matchtype:BYTE
EXTRN	_cv_timelimit:BYTE
EXTRN	_cv_numlaps:BYTE
EXTRN	_timelimitintics:DWORD
EXTRN	_cv_runscripts:BYTE
EXTRN	_cv_overtime:BYTE
EXTRN	_server:DWORD
EXTRN	_player_names:BYTE
EXTRN	_players:BYTE
EXTRN	_playeringame:BYTE
EXTRN	_localangle:DWORD
EXTRN	_localangle2:DWORD
EXTRN	_leveltime:DWORD
EXTRN	_tmbbox:BYTE
EXTRN	_thinkercap:BYTE
EXTRN	_camera:BYTE
EXTRN	_camera2:BYTE
EXTRN	_var1:DWORD
EXTRN	_var2:DWORD
EXTRN	_bmaporgx:DWORD
EXTRN	_bmaporgy:DWORD
EXTRN	_lastloadedmaplumpnum:DWORD
EXTRN	_numlevelflats:DWORD
EXTRN	_levelflats:DWORD
EXTRN	_texturetranslation:DWORD
EXTRN	_vertexes:DWORD
EXTRN	_numsectors:DWORD
EXTRN	_sectors:DWORD
EXTRN	_numlines:DWORD
EXTRN	_lines:DWORD
EXTRN	_numsides:DWORD
EXTRN	_sides:DWORD
EXTRN	_levelskynum:DWORD
EXTRN	_globallevelskynum:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_lastanim DD	01H DUP (?)
_anims	DD	01H DUP (?)
_maxanims DD	01H DUP (?)
_animdefs DD	01H DUP (?)
_triplinecaller DD 01H DUP (?)
_tmpusher DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DA@IAIAPEMG@Line?5special?5506?5?$CIline?5?$CD?$CFIu?$CJ?5mi@
CONST	SEGMENT
??_C@_0DA@IAIAPEMG@Line?5special?5506?5?$CIline?5?$CD?$CFIu?$CJ?5mi@ DB 'L'
	DB	'ine special 506 (line #%Iu) missing 2nd side!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MNKJLNKI@Make?9Your?9Own?5FOF?5?$CItag?5?$CFd?$CJ?5foun@
CONST	SEGMENT
??_C@_0DN@MNKJLNKI@Make?9Your?9Own?5FOF?5?$CItag?5?$CFd?$CJ?5foun@ DB 'Ma'
	DB	'ke-Your-Own FOF (tag %d) found without a 2nd linedef side!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@BIGCHJLL@Make?9Your?9Own?9FOF?5?$CItag?5?$CFd?$CJ?5need@
CONST	SEGMENT
??_C@_0FL@BIGCHJLL@Make?9Your?9Own?9FOF?5?$CItag?5?$CFd?$CJ?5need@ DB 'Ma'
	DB	'ke-Your-Own-FOF (tag %d) needs a value in the linedef''s seco'
	DB	'nd side upper texture field.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DOPDFDHL@One?5of?5your?5FOFs?5with?5a?5tag?5of?5@
CONST	SEGMENT
??_C@_0FC@DOPDFDHL@One?5of?5your?5FOFs?5with?5a?5tag?5of?5@ DB 'One of yo'
	DB	'ur FOFs with a tag of %d has a top height less than that of t'
	DB	'he bottom.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OPMPDJLP@?$CFs?5recieved?5double?5points?5for?5s@
CONST	SEGMENT
??_C@_0DE@OPMPDJLP@?$CFs?5recieved?5double?5points?5for?5s@ DB '%s reciev'
	DB	'ed double points for surviving the round.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KBAFCDBG@WaypointMid?3?5?$CFd?$DL?5WaypointLow?3?5?$CF@
CONST	SEGMENT
??_C@_0DE@KBAFCDBG@WaypointMid?3?5?$CFd?$DL?5WaypointLow?3?5?$CF@ DB 'Way'
	DB	'pointMid: %d; WaypointLow: %d; WaypointHigh: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NDOBHENA@ERROR?3?5WAYPOINT?$CIS?$CJ?5IN?5SEQUENCE?5@
CONST	SEGMENT
??_C@_0CO@NDOBHENA@ERROR?3?5WAYPOINT?$CIS?$CJ?5IN?5SEQUENCE?5@ DB 'ERROR:'
	DB	' WAYPOINT(S) IN SEQUENCE %d NOT FOUND.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GNAPKJPK@ERROR?3?5Sector?5special?5?$CFd?5missin@
CONST	SEGMENT
??_C@_0DE@GNAPKJPK@ERROR?3?5Sector?5special?5?$CFd?5missin@ DB 'ERROR: Se'
	DB	'ctor special %d missing line special #11.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KFDLEEGG@FINISHED?$CB@
CONST	SEGMENT
??_C@_09KFDLEEGG@FINISHED?$CB@ DB 'FINISHED!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MHOJGJAN@ERROR?3?5LAST?5WAYPOINT?5IN?5SEQUENC@
CONST	SEGMENT
??_C@_0DA@MHOJGJAN@ERROR?3?5LAST?5WAYPOINT?5IN?5SEQUENC@ DB 'ERROR: LAST '
	DB	'WAYPOINT IN SEQUENCE %d NOT FOUND.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BGLBOMJP@Waypoint?5?$CFd?5found?5in?5sequence?5?$CF@
CONST	SEGMENT
??_C@_0CP@BGLBOMJP@Waypoint?5?$CFd?5found?5in?5sequence?5?$CF@ DB 'Waypoi'
	DB	'nt %d found in sequence %d - speed = %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IDAAEOCG@ERROR?3?5FIRST?5WAYPOINT?5IN?5SEQUEN@
CONST	SEGMENT
??_C@_0DB@IDAAEOCG@ERROR?3?5FIRST?5WAYPOINT?5IN?5SEQUEN@ DB 'ERROR: FIRST'
	DB	' WAYPOINT IN SEQUENCE %d NOT FOUND.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HOADDFGL@ERROR?3?5Sector?5special?5?$CFd?5missin@
CONST	SEGMENT
??_C@_0DD@HOADDFGL@ERROR?3?5Sector?5special?5?$CFd?5missin@ DB 'ERROR: Se'
	DB	'ctor special %d missing line special #3.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CLJLMGKF@your?5blue?5flag?5was?5returned?5to?5@
CONST	SEGMENT
??_C@_0CG@CLJLMGKF@your?5blue?5flag?5was?5returned?5to?5@ DB 'your blue f'
	DB	'lag was returned to base.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GHLKNNGA@the?5red?5team?5has?5returned?5their@
CONST	SEGMENT
??_C@_0CH@GHLKNNGA@the?5red?5team?5has?5returned?5their@ DB 'the red team'
	DB	' has returned their flag.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MIPBFDCD@?$CFs?5captured?5the?5red?5flag?4?6@
CONST	SEGMENT
??_C@_0BL@MIPBFDCD@?$CFs?5captured?5the?5red?5flag?4?6@ DB '%s captured t'
	DB	'he red flag.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GPOAFCDN@?$CFs?2captured?5the?5red?5flag?4?2?2?2?2@
CONST	SEGMENT
??_C@_0BO@GPOAFCDN@?$CFs?2captured?5the?5red?5flag?4?2?2?2?2@ DB '%s\capt'
	DB	'ured the red flag.\\\\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LKOOLFPG@changeteam2?5blue@
CONST	SEGMENT
??_C@_0BB@LKOOLFPG@changeteam2?5blue@ DB 'changeteam2 blue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NGJMDDAH@changeteam?5blue@
CONST	SEGMENT
??_C@_0BA@NGJMDDAH@changeteam?5blue@ DB 'changeteam blue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IFDPBPCN@your?5red?5flag?5was?5returned?5to?5b@
CONST	SEGMENT
??_C@_0CF@IFDPBPCN@your?5red?5flag?5was?5returned?5to?5b@ DB 'your red fl'
	DB	'ag was returned to base.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EBPGLBCL@your?5flag?5was?5returned?2to?5base?4@
CONST	SEGMENT
??_C@_0CE@EBPGLBCL@your?5flag?5was?5returned?2to?5base?4@ DB 'your flag w'
	DB	'as returned\to base.\\\\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PCBKHFLB@the?5blue?5team?5has?5returned?5thei@
CONST	SEGMENT
??_C@_0CI@PCBKHFLB@the?5blue?5team?5has?5returned?5thei@ DB 'the blue tea'
	DB	'm has returned their flag.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LFDGLEBD@the?5enemy?5has?5returned?2their?5fl@
CONST	SEGMENT
??_C@_0CH@LFDGLEBD@the?5enemy?5has?5returned?2their?5fl@ DB 'the enemy ha'
	DB	's returned\their flag.\\\\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NCHIJMJN@?$CFs?5captured?5the?5blue?5flag?4?6@
CONST	SEGMENT
??_C@_0BM@NCHIJMJN@?$CFs?5captured?5the?5blue?5flag?4?6@ DB '%s captured '
	DB	'the blue flag.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OMOKFAHO@?$CFs?2captured?5the?5blue?5flag?4?2?2?2?2@
CONST	SEGMENT
??_C@_0BP@OMOKFAHO@?$CFs?2captured?5the?5blue?5flag?4?2?2?2?2@ DB '%s\cap'
	DB	'tured the blue flag.\\\\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PEKCJCD@changeteam2?5red@
CONST	SEGMENT
??_C@_0BA@PEKCJCD@changeteam2?5red@ DB 'changeteam2 red', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLFJDFHH@changeteam?5red@
CONST	SEGMENT
??_C@_0P@HLFJDFHH@changeteam?5red@ DB 'changeteam red', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ONKOONKC@Line?5type?5436?5Executor?3?5Can?8t?5f@
CONST	SEGMENT
??_C@_0EF@ONKOONKC@Line?5type?5436?5Executor?3?5Can?8t?5f@ DB 'Line type '
	DB	'436 Executor: Can''t find a FOF control sector with tag %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HBJMHHLC@Line?5type?5436?5Executor?3?5Target?5@
CONST	SEGMENT
??_C@_0DI@HBJMHHLC@Line?5type?5436?5Executor?3?5Target?5@ DB 'Line type 4'
	DB	'36 Executor: Target sector #%d has no FOFs.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@
CONST	SEGMENT
??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@ DB 'SOC Err'
	DB	'or: script lump %s not found/not valid.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DKKFEAKA@Unknown?5weather?5type?5?$CFd?4?6@
CONST	SEGMENT
??_C@_0BK@DKKFEAKA@Unknown?5weather?5type?5?$CFd?4?6@ DB 'Unknown weather'
	DB	' type %d.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HMODDHIJ@Warning?3?5Sector?5?$CFIu?5is?5not?5clos@
CONST	SEGMENT
??_C@_0DK@HMODDHIJ@Warning?3?5Sector?5?$CFIu?5is?5not?5clos@ DB 'Warning:'
	DB	' Sector %Iu is not closed at vertex %Iu (%d, %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JGFODBHM@P_AddExecutorDelay?3?5Line?5has?5no@
CONST	SEGMENT
??_C@_0CN@JGFODBHM@P_AddExecutorDelay?3?5Line?5has?5no@ DB 'P_AddExecutor'
	DB	'Delay: Line has no backsector!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EIHMNEPK@Corrupt?5tag?5list?5for?5sector?5?$CFu?6@
CONST	SEGMENT
??_C@_0CA@EIHMNEPK@Corrupt?5tag?5list?5for?5sector?5?$CFu?6@ DB 'Corrupt '
	DB	'tag list for sector %u', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@
CONST	SEGMENT
??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@ DB 'EV_DoPolyObjWa'
	DB	'ypoint: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KIIHCCJ@PolyVisible?3?5bad?5polyobj?5?$CFd?6@
CONST	SEGMENT
??_C@_0BN@KIIHCCJ@PolyVisible?3?5bad?5polyobj?5?$CFd?6@ DB 'PolyVisible: '
	DB	'bad polyobj %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DLBMDGJG@PolyInvisible?3?5bad?5polyobj?5?$CFd?6@
CONST	SEGMENT
??_C@_0BP@DLBMDGJG@PolyInvisible?3?5bad?5polyobj?5?$CFd?6@ DB 'PolyInvisi'
	DB	'ble: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DNGGGIOB@animflat?3?5?$CD?$CF03Iu?5name?3?$CF?48s?5anim@
CONST	SEGMENT
??_C@_0DL@DNGGGIOB@animflat?3?5?$CD?$CF03Iu?5name?3?$CF?48s?5anim@ DB 'an'
	DB	'imflat: #%03Iu name:%.8s animseq:%d numpics:%d speed:%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PPFFLENC@AnimatedFlat?5start?5?$CFs?5not?5in?5sa@
CONST	SEGMENT
??_C@_0DB@PPFFLENC@AnimatedFlat?5start?5?$CFs?5not?5in?5sa@ DB 'AnimatedF'
	DB	'lat start %s not in same wad as end %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NPDMFJCJ@P_InitPicAnims?3?5bad?5cycle?5from?5@
CONST	SEGMENT
??_C@_0CI@NPDMFJCJ@P_InitPicAnims?3?5bad?5cycle?5from?5@ DB 'P_InitPicAni'
	DB	'ms: bad cycle from %s to %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LGALMIEA@No?5free?5memory?5for?5ANIMATED?5dat@
CONST	SEGMENT
??_C@_0CB@LGALMIEA@No?5free?5memory?5for?5ANIMATED?5dat@ DB 'No free memo'
	DB	'ry for ANIMATED data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENOFCJPE@ANIMATED@
CONST	SEGMENT
??_C@_08ENOFCJPE@ANIMATED@ DB 'ANIMATED', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_harddefs DB	00H
	DB	'LITEY3', 00H
	ORG $+2
	DB	'LITEY1', 00H
	ORG $+2
	DD	04H
	DB	00H
	DB	'FWATER16', 00H
	DB	'FWATER1', 00H
	ORG $+1
	DD	04H
	DB	00H
	DB	'BWATER16', 00H
	DB	'BWATER01', 00H
	DD	04H
	DB	00H
	DB	'LWATER16', 00H
	DB	'LWATER1', 00H
	ORG $+1
	DD	04H
	DB	00H
	DB	'WATER7', 00H
	ORG $+2
	DB	'WATER0', 00H
	ORG $+2
	DD	04H
	DB	00H
	DB	'SWATER4', 00H
	ORG $+1
	DB	'SWATER1', 00H
	ORG $+1
	DD	08H
	DB	00H
	DB	'LAVA4', 00H
	ORG $+3
	DB	'LAVA1', 00H
	ORG $+3
	DD	08H
	DB	00H
	DB	'DLAVA4', 00H
	ORG $+2
	DB	'DLAVA1', 00H
	ORG $+2
	DD	08H
	DB	00H
	DB	'RLAVA8', 00H
	ORG $+2
	DB	'RLAVA1', 00H
	ORG $+2
	DD	08H
	DB	00H
	DB	'LITER3', 00H
	ORG $+2
	DB	'LITER1', 00H
	ORG $+2
	DD	08H
	DB	00H
	DB	'SURF08', 00H
	ORG $+2
	DB	'SURF01', 00H
	ORG $+2
	DD	04H
	DB	00H
	DB	'CHEMG16', 00H
	ORG $+1
	DB	'CHEMG01', 00H
	ORG $+1
	DD	04H
	DB	00H
	DB	'GOOP16', 00H
	ORG $+2
	DB	'GOOP01', 00H
	ORG $+2
	DD	04H
	DB	00H
	DB	'OIL16', 00H
	ORG $+3
	DB	'OIL01', 00H
	ORG $+3
	DD	04H
	DB	00H
	DB	'THZBOXF4', 00H
	DB	'THZBOXF1', 00H
	DD	02H
	DB	00H
	DB	'ALTBOXF4', 00H
	DB	'ALTBOXF1', 00H
	DD	02H
	DB	00H
	DB	'LITEB3', 00H
	ORG $+2
	DB	'LITEB1', 00H
	ORG $+2
	DD	04H
	DB	00H
	DB	'LITEN3', 00H
	ORG $+2
	DB	'LITEN1', 00H
	ORG $+2
	DD	04H
	DB	00H
	DB	'ACZRFL1H', 00H
	DB	'ACZRFL1A', 00H
	DD	04H
	DB	00H
	DB	'ACZRFL2H', 00H
	DB	'ACZRFL2A', 00H
	DD	04H
	DB	00H
	DB	'EGRIDF3', 00H
	ORG $+1
	DB	'EGRIDF1', 00H
	ORG $+1
	DD	04H
	DB	00H
	DB	'ERZFAN4', 00H
	ORG $+1
	DB	'ERZFAN1', 00H
	ORG $+1
	DD	01H
	DB	00H
	DB	'ERZFANR4', 00H
	DB	'ERZFANR1', 00H
	DD	01H
	DB	00H
	DB	'DISCO4', 00H
	ORG $+2
	DB	'DISCO1', 00H
	ORG $+2
	DD	0fH
	DB	01H
	DB	'GFALL4', 00H
	ORG $+2
	DB	'GFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'CFALL4', 00H
	ORG $+2
	DB	'CFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'TFALL4', 00H
	ORG $+2
	DB	'TFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'AFALL4', 00H
	ORG $+2
	DB	'AFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'QFALL4', 00H
	ORG $+2
	DB	'QFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'Q2FALL4', 00H
	ORG $+1
	DB	'Q2FALL1', 00H
	ORG $+1
	DD	02H
	DB	01H
	DB	'Q3FALL4', 00H
	ORG $+1
	DB	'Q3FALL1', 00H
	ORG $+1
	DD	02H
	DB	01H
	DB	'Q4FALL4', 00H
	ORG $+1
	DB	'Q4FALL1', 00H
	ORG $+1
	DD	02H
	DB	01H
	DB	'Q5FALL4', 00H
	ORG $+1
	DB	'Q5FALL1', 00H
	ORG $+1
	DD	02H
	DB	01H
	DB	'Q6FALL4', 00H
	ORG $+1
	DB	'Q6FALL1', 00H
	ORG $+1
	DD	02H
	DB	01H
	DB	'Q7FALL4', 00H
	ORG $+1
	DB	'Q7FALL1', 00H
	ORG $+1
	DD	02H
	DB	01H
	DB	'LFALL4', 00H
	ORG $+2
	DB	'LFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'MFALL4', 00H
	ORG $+2
	DB	'MFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'OFALL4', 00H
	ORG $+2
	DB	'OFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'DLAVA4', 00H
	ORG $+2
	DB	'DLAVA1', 00H
	ORG $+2
	DD	08H
	DB	01H
	DB	'ERZLASA2', 00H
	DB	'ERZLASA1', 00H
	DD	01H
	DB	01H
	DB	'ERZLASB4', 00H
	DB	'ERZLASB1', 00H
	DD	01H
	DB	01H
	DB	'ERZLASC4', 00H
	DB	'ERZLASC1', 00H
	DD	01H
	DB	01H
	DB	'THZBOX04', 00H
	DB	'THZBOX01', 00H
	DD	02H
	DB	01H
	DB	'ALTBOX04', 00H
	DB	'ALTBOX01', 00H
	DD	02H
	DB	01H
	DB	'SFALL4', 00H
	ORG $+2
	DB	'SFALL1', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'RVZFALL8', 00H
	DB	'RVZFALL1', 00H
	DD	04H
	DB	01H
	DB	'BFALL4', 00H
	ORG $+2
	DB	'BFALL1', 00H
	ORG $+2
	DD	02H
	DB	01H
	DB	'GREYW3', 00H
	ORG $+2
	DB	'GREYW1', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'BLUEW3', 00H
	ORG $+2
	DB	'BLUEW1', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'COMP6', 00H
	ORG $+3
	DB	'COMP4', 00H
	ORG $+3
	DD	04H
	DB	01H
	DB	'RED3', 00H
	ORG $+4
	DB	'RED1', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'YEL3', 00H
	ORG $+4
	DB	'YEL1', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'ACWRFL1D', 00H
	DB	'ACWRFL1A', 00H
	DD	01H
	DB	01H
	DB	'ACWRFL2D', 00H
	DB	'ACWRFL2A', 00H
	DD	01H
	DB	01H
	DB	'ACWRFL3D', 00H
	DB	'ACWRFL3A', 00H
	DD	01H
	DB	01H
	DB	'ACWRFL4D', 00H
	DB	'ACWRFL4A', 00H
	DD	01H
	DB	01H
	DB	'ACWRP1D', 00H
	ORG $+1
	DB	'ACWRP1A', 00H
	ORG $+1
	DD	01H
	DB	01H
	DB	'ACWRP2D', 00H
	ORG $+1
	DB	'ACWRP2A', 00H
	ORG $+1
	DD	01H
	DB	01H
	DB	'ACZRP1D', 00H
	ORG $+1
	DB	'ACZRP1A', 00H
	ORG $+1
	DD	01H
	DB	01H
	DB	'ACZRP2D', 00H
	ORG $+1
	DB	'ACZRP2A', 00H
	ORG $+1
	DD	01H
	DB	01H
	DB	'OILFALL4', 00H
	DB	'OILFALL1', 00H
	DD	02H
	DB	01H
	DB	'SOLFALL4', 00H
	DB	'SOLFALL1', 00H
	DD	02H
	DB	01H
	DB	'DOWN1C', 00H
	ORG $+2
	DB	'DOWN1A', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'DOWN2C', 00H
	ORG $+2
	DB	'DOWN2A', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'DOWN3D', 00H
	ORG $+2
	DB	'DOWN3A', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'DOWN4C', 00H
	ORG $+2
	DB	'DOWN4A', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'DOWN5C', 00H
	ORG $+2
	DB	'DOWN5A', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'UP1C', 00H
	ORG $+4
	DB	'UP1A', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'UP2C', 00H
	ORG $+4
	DB	'UP2A', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'UP3D', 00H
	ORG $+4
	DB	'UP3A', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'UP4C', 00H
	ORG $+4
	DB	'UP4A', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'UP5C', 00H
	ORG $+4
	DB	'UP5A', 00H
	ORG $+4
	DD	04H
	DB	01H
	DB	'EGRID3', 00H
	ORG $+2
	DB	'EGRID1', 00H
	ORG $+2
	DD	04H
	DB	01H
	DB	'ERFANW4', 00H
	ORG $+1
	DB	'ERFANW1', 00H
	ORG $+1
	DD	01H
	DB	01H
	DB	'ERFANX4', 00H
	ORG $+1
	DB	'ERFANX1', 00H
	ORG $+1
	DD	01H
	DB	01H
	DB	'DISCOD4', 00H
	ORG $+1
	DB	'DISCOD1', 00H
	ORG $+1
	DD	0fH
	DB	01H
	DB	'DANCE4', 00H
	ORG $+2
	DB	'DANCE1', 00H
	ORG $+2
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	00H
	DB	'DUMYSLOT', 00H
	DB	'DUMYSLOT', 00H
	DD	08H
	DB	0ffH
	DB	00H
	ORG $+8
	DB	00H
	ORG $+8
	DD	00H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	013aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0d7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0108H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01acH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0185bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02821H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	049bH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PIT_PushThing
_TEXT	SEGMENT
_tmpmomz$1 = -48					; size = 4
_tmpmomy$2 = -44					; size = 4
_tmpmomx$3 = -40					; size = 4
_pushangle$4 = -36					; size = 4
_tmpmomz$5 = -32					; size = 4
_tmpmomy$6 = -28					; size = 4
_tmpmomx$7 = -24					; size = 4
_sz$8 = -20						; size = 4
_sy$9 = -16						; size = 4
_sx$10 = -12						; size = 4
_speed$11 = -8						; size = 4
_dist$12 = -4						; size = 4
_thing$ = 8						; size = 4
_PIT_PushThing PROC					; COMDAT

; 6662 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6663 : 	if (thing->flags2 & MF2_PUSHED)

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00012	83 e1 01	 and	 ecx, 1
  00015	74 07		 je	 SHORT $LN2@PIT_PushTh

; 6664 : 		return false;

  00017	33 c0		 xor	 eax, eax
  00019	e9 47 06 00 00	 jmp	 $LN1@PIT_PushTh
$LN2@PIT_PushTh:

; 6665 : 
; 6666 : 	if (thing->player && (thing->player->pflags & PF_ROPEHANG || thing->player->pflags & PF_MINECART))

  0001e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00021	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00028	74 35		 je	 SHORT $LN3@PIT_PushTh
  0002a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0002d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00033	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00039	81 e2 00 00 00
	20		 and	 edx, 536870912		; 20000000H
  0003f	75 17		 jne	 SHORT $LN4@PIT_PushTh
  00041	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00044	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0004a	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00050	81 e2 00 00 00
	40		 and	 edx, 1073741824		; 40000000H
  00056	74 07		 je	 SHORT $LN3@PIT_PushTh
$LN4@PIT_PushTh:

; 6667 : 		return false;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 06 06 00 00	 jmp	 $LN1@PIT_PushTh
$LN3@PIT_PushTh:

; 6668 : 
; 6669 : 	// Allow this to affect pushable objects at some point?
; 6670 : 	if (thing->player && (!(thing->flags & (MF_NOGRAVITY | MF_NOCLIP)) || thing->player->pflags & PF_NIGHTSMODE))

  0005f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00062	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00069	0f 84 d1 05 00
	00		 je	 $LN25@PIT_PushTh
  0006f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00072	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00075	81 e1 00 12 00
	00		 and	 ecx, 4608		; 00001200H
  0007b	74 1b		 je	 SHORT $LN6@PIT_PushTh
  0007d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00080	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00086	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0008c	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  00092	0f 84 a8 05 00
	00		 je	 $LN25@PIT_PushTh
$LN6@PIT_PushTh:

; 6671 : 	{
; 6672 : 		INT32 dist;
; 6673 : 		INT32 speed;
; 6674 : 		INT32 sx, sy, sz;
; 6675 : 
; 6676 : 		sx = tmpusher->x;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  0009d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000a0	89 4d f4	 mov	 DWORD PTR _sx$10[ebp], ecx

; 6677 : 		sy = tmpusher->y;

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  000a8	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000ab	89 4d f0	 mov	 DWORD PTR _sy$9[ebp], ecx

; 6678 : 		sz = tmpusher->z;

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  000b3	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000b6	89 4d ec	 mov	 DWORD PTR _sz$8[ebp], ecx

; 6679 : 
; 6680 : 		// don't fade wrt Z if health & 2 (mapthing has multi flag)
; 6681 : 		if (tmpusher->source->health & 2)

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  000be	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c1	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  000c7	83 e2 02	 and	 edx, 2
  000ca	74 21		 je	 SHORT $LN7@PIT_PushTh

; 6682 : 			dist = P_AproxDistance(thing->x - sx,thing->y - sy);

  000cc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000cf	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d2	2b 4d f0	 sub	 ecx, DWORD PTR _sy$9[ebp]
  000d5	51		 push	 ecx
  000d6	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000d9	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000dc	2b 45 f4	 sub	 eax, DWORD PTR _sx$10[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _P_AproxDistance
  000e5	83 c4 08	 add	 esp, 8
  000e8	89 45 fc	 mov	 DWORD PTR _dist$12[ebp], eax
  000eb	eb 5f		 jmp	 SHORT $LN8@PIT_PushTh
$LN7@PIT_PushTh:

; 6683 : 		else
; 6684 : 		{
; 6685 : 			// Make sure the Z is in range
; 6686 : 			if (thing->z < sz - tmpusher->radius || thing->z > sz + tmpusher->radius)

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  000f2	8b 4d ec	 mov	 ecx, DWORD PTR _sz$8[ebp]
  000f5	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000f8	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000fb	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  000fe	7c 13		 jl	 SHORT $LN10@PIT_PushTh
  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  00105	8b 4d ec	 mov	 ecx, DWORD PTR _sz$8[ebp]
  00108	03 48 24	 add	 ecx, DWORD PTR [eax+36]
  0010b	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0010e	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  00111	7e 07		 jle	 SHORT $LN9@PIT_PushTh
$LN10@PIT_PushTh:

; 6687 : 				return false;

  00113	33 c0		 xor	 eax, eax
  00115	e9 4b 05 00 00	 jmp	 $LN1@PIT_PushTh
$LN9@PIT_PushTh:

; 6688 : 
; 6689 : 			dist = P_AproxDistance(P_AproxDistance(thing->x - sx, thing->y - sy),

  0011a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0011d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00120	2b 4d ec	 sub	 ecx, DWORD PTR _sz$8[ebp]
  00123	51		 push	 ecx
  00124	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00127	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0012a	2b 45 f0	 sub	 eax, DWORD PTR _sy$9[ebp]
  0012d	50		 push	 eax
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00131	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00134	2b 55 f4	 sub	 edx, DWORD PTR _sx$10[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _P_AproxDistance
  0013d	83 c4 08	 add	 esp, 8
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _P_AproxDistance
  00146	83 c4 08	 add	 esp, 8
  00149	89 45 fc	 mov	 DWORD PTR _dist$12[ebp], eax
$LN8@PIT_PushTh:

; 6690 : 				thing->z - sz);
; 6691 : 		}
; 6692 : 
; 6693 : 		speed = (tmpusher->magnitude - ((dist>>FRACBITS)>>1))<<(FRACBITS - PUSH_FACTOR - 1);

  0014c	8b 45 fc	 mov	 eax, DWORD PTR _dist$12[ebp]
  0014f	c1 f8 10	 sar	 eax, 16			; 00000010H
  00152	d1 f8		 sar	 eax, 1
  00154	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmpusher
  0015a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0015d	2b d0		 sub	 edx, eax
  0015f	c1 e2 08	 shl	 edx, 8
  00162	89 55 f8	 mov	 DWORD PTR _speed$11[ebp], edx

; 6694 : 
; 6695 : 		// If speed <= 0, you're outside the effective radius. You also have
; 6696 : 		// to be able to see the push/pull source point.
; 6697 : 
; 6698 : 		// Written with bits and pieces of P_HomingAttack
; 6699 : 		if ((speed > 0) && (P_CheckSight(thing, tmpusher->source)))

  00165	83 7d f8 00	 cmp	 DWORD PTR _speed$11[ebp], 0
  00169	0f 8e d1 04 00
	00		 jle	 $LN25@PIT_PushTh
  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  00174	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00177	51		 push	 ecx
  00178	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 _P_CheckSight
  00181	83 c4 08	 add	 esp, 8
  00184	85 c0		 test	 eax, eax
  00186	0f 84 b4 04 00
	00		 je	 $LN25@PIT_PushTh

; 6700 : 		{
; 6701 : 			if (!(thing->player->pflags & PF_NIGHTSMODE))

  0018c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0018f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00195	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0019b	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  001a1	0f 85 f2 02 00
	00		 jne	 $LN12@PIT_PushTh

; 6702 : 			{
; 6703 : 				// only push wrt Z if health & 1 (mapthing has ambush flag)
; 6704 : 				if (tmpusher->source->health & 1)

  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  001ac	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001af	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  001b5	83 e2 01	 and	 edx, 1
  001b8	0f 84 74 01 00
	00		 je	 $LN14@PIT_PushTh

; 6705 : 				{
; 6706 : 					fixed_t tmpmomx, tmpmomy, tmpmomz;
; 6707 : 
; 6708 : 					tmpmomx = FixedMul(FixedDiv(sx - thing->x, dist), speed);

  001be	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  001c1	50		 push	 eax
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _dist$12[ebp]
  001c5	51		 push	 ecx
  001c6	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  001c9	8b 45 f4	 mov	 eax, DWORD PTR _sx$10[ebp]
  001cc	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _FixedDiv
  001d5	83 c4 08	 add	 esp, 8
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 _FixedMul
  001de	83 c4 08	 add	 esp, 8
  001e1	89 45 e8	 mov	 DWORD PTR _tmpmomx$7[ebp], eax

; 6709 : 					tmpmomy = FixedMul(FixedDiv(sy - thing->y, dist), speed);

  001e4	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  001e7	50		 push	 eax
  001e8	8b 4d fc	 mov	 ecx, DWORD PTR _dist$12[ebp]
  001eb	51		 push	 ecx
  001ec	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  001ef	8b 45 f0	 mov	 eax, DWORD PTR _sy$9[ebp]
  001f2	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 _FixedDiv
  001fb	83 c4 08	 add	 esp, 8
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _FixedMul
  00204	83 c4 08	 add	 esp, 8
  00207	89 45 e4	 mov	 DWORD PTR _tmpmomy$6[ebp], eax

; 6710 : 					tmpmomz = FixedMul(FixedDiv(sz - thing->z, dist), speed);

  0020a	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  0020d	50		 push	 eax
  0020e	8b 4d fc	 mov	 ecx, DWORD PTR _dist$12[ebp]
  00211	51		 push	 ecx
  00212	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00215	8b 45 ec	 mov	 eax, DWORD PTR _sz$8[ebp]
  00218	2b 42 18	 sub	 eax, DWORD PTR [edx+24]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 _FixedDiv
  00221	83 c4 08	 add	 esp, 8
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _FixedMul
  0022a	83 c4 08	 add	 esp, 8
  0022d	89 45 e0	 mov	 DWORD PTR _tmpmomz$5[ebp], eax

; 6711 : 					if (tmpusher->source->type == MT_PUSH) // away!

  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  00235	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00238	81 79 7c 07 01
	00 00		 cmp	 DWORD PTR [ecx+124], 263 ; 00000107H
  0023f	75 15		 jne	 SHORT $LN16@PIT_PushTh

; 6712 : 					{
; 6713 : 						tmpmomx *= -1;

  00241	6b 45 e8 ff	 imul	 eax, DWORD PTR _tmpmomx$7[ebp], -1
  00245	89 45 e8	 mov	 DWORD PTR _tmpmomx$7[ebp], eax

; 6714 : 						tmpmomy *= -1;

  00248	6b 45 e4 ff	 imul	 eax, DWORD PTR _tmpmomy$6[ebp], -1
  0024c	89 45 e4	 mov	 DWORD PTR _tmpmomy$6[ebp], eax

; 6715 : 						tmpmomz *= -1;

  0024f	6b 45 e0 ff	 imul	 eax, DWORD PTR _tmpmomz$5[ebp], -1
  00253	89 45 e0	 mov	 DWORD PTR _tmpmomz$5[ebp], eax
$LN16@PIT_PushTh:

; 6716 : 					}
; 6717 : 
; 6718 : 					thing->momx += tmpmomx;

  00256	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00259	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0025c	03 4d e8	 add	 ecx, DWORD PTR _tmpmomx$7[ebp]
  0025f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00262	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 6719 : 					thing->momy += tmpmomy;

  00265	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00268	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0026b	03 4d e4	 add	 ecx, DWORD PTR _tmpmomy$6[ebp]
  0026e	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00271	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 6720 : 					thing->momz += tmpmomz;

  00274	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00277	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0027a	03 4d e0	 add	 ecx, DWORD PTR _tmpmomz$5[ebp]
  0027d	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00280	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 6721 : 
; 6722 : 					if (thing->player)

  00283	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00286	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0028d	0f 84 9a 00 00
	00		 je	 $LN17@PIT_PushTh

; 6723 : 					{
; 6724 : 						thing->player->cmomx += tmpmomx;

  00293	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00296	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0029c	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  002a2	03 55 e8	 add	 edx, DWORD PTR _tmpmomx$7[ebp]
  002a5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002a8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002ae	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 6725 : 						thing->player->cmomy += tmpmomy;

  002b4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002b7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002bd	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  002c3	03 55 e4	 add	 edx, DWORD PTR _tmpmomy$6[ebp]
  002c6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002c9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002cf	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 6726 : 						thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  002d5	68 00 e8 00 00	 push	 59392			; 0000e800H
  002da	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002dd	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002e3	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 _FixedMul
  002ef	83 c4 08	 add	 esp, 8
  002f2	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  002f5	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  002fb	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6727 : 						thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  00301	68 00 e8 00 00	 push	 59392			; 0000e800H
  00306	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00309	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0030f	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00315	52		 push	 edx
  00316	e8 00 00 00 00	 call	 _FixedMul
  0031b	83 c4 08	 add	 esp, 8
  0031e	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00321	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00327	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN17@PIT_PushTh:

; 6728 : 					}
; 6729 : 				}

  0032d	e9 62 01 00 00	 jmp	 $LN19@PIT_PushTh
$LN14@PIT_PushTh:

; 6730 : 				else
; 6731 : 				{
; 6732 : 					angle_t pushangle;
; 6733 : 
; 6734 : 					pushangle = R_PointToAngle2(thing->x, thing->y, sx, sy);

  00332	8b 45 f0	 mov	 eax, DWORD PTR _sy$9[ebp]
  00335	50		 push	 eax
  00336	8b 4d f4	 mov	 ecx, DWORD PTR _sx$10[ebp]
  00339	51		 push	 ecx
  0033a	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0033d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00340	50		 push	 eax
  00341	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00344	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00347	52		 push	 edx
  00348	e8 00 00 00 00	 call	 _R_PointToAngle2
  0034d	83 c4 10	 add	 esp, 16			; 00000010H
  00350	89 45 dc	 mov	 DWORD PTR _pushangle$4[ebp], eax

; 6735 : 					if (tmpusher->source->type == MT_PUSH)

  00353	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  00358	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0035b	81 79 7c 07 01
	00 00		 cmp	 DWORD PTR [ecx+124], 263 ; 00000107H
  00362	75 0b		 jne	 SHORT $LN18@PIT_PushTh

; 6736 : 						pushangle += ANGLE_180; // away

  00364	8b 45 dc	 mov	 eax, DWORD PTR _pushangle$4[ebp]
  00367	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  0036c	89 45 dc	 mov	 DWORD PTR _pushangle$4[ebp], eax
$LN18@PIT_PushTh:

; 6737 : 					pushangle >>= ANGLETOFINESHIFT;

  0036f	8b 45 dc	 mov	 eax, DWORD PTR _pushangle$4[ebp]
  00372	c1 e8 13	 shr	 eax, 19			; 00000013H
  00375	89 45 dc	 mov	 DWORD PTR _pushangle$4[ebp], eax

; 6738 : 					thing->momx += FixedMul(speed, FINECOSINE(pushangle));

  00378	8b 45 dc	 mov	 eax, DWORD PTR _pushangle$4[ebp]
  0037b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00381	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00384	52		 push	 edx
  00385	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 _FixedMul
  0038e	83 c4 08	 add	 esp, 8
  00391	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00394	03 41 48	 add	 eax, DWORD PTR [ecx+72]
  00397	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0039a	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 6739 : 					thing->momy += FixedMul(speed, FINESINE(pushangle));

  0039d	8b 45 dc	 mov	 eax, DWORD PTR _pushangle$4[ebp]
  003a0	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  003a7	51		 push	 ecx
  003a8	8b 55 f8	 mov	 edx, DWORD PTR _speed$11[ebp]
  003ab	52		 push	 edx
  003ac	e8 00 00 00 00	 call	 _FixedMul
  003b1	83 c4 08	 add	 esp, 8
  003b4	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  003b7	03 41 4c	 add	 eax, DWORD PTR [ecx+76]
  003ba	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  003bd	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 6740 : 
; 6741 : 					if (thing->player)

  003c0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003c3	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  003ca	0f 84 c4 00 00
	00		 je	 $LN19@PIT_PushTh

; 6742 : 					{
; 6743 : 						thing->player->cmomx += FixedMul(speed, FINECOSINE(pushangle));

  003d0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003d3	8b b0 a4 00 00
	00		 mov	 esi, DWORD PTR [eax+164]
  003d9	8b 4d dc	 mov	 ecx, DWORD PTR _pushangle$4[ebp]
  003dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _finecosine
  003e2	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  003e5	50		 push	 eax
  003e6	8b 4d f8	 mov	 ecx, DWORD PTR _speed$11[ebp]
  003e9	51		 push	 ecx
  003ea	e8 00 00 00 00	 call	 _FixedMul
  003ef	83 c4 08	 add	 esp, 8
  003f2	03 86 3c 01 00
	00		 add	 eax, DWORD PTR [esi+316]
  003f8	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  003fb	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  00401	89 81 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], eax

; 6744 : 						thing->player->cmomy += FixedMul(speed, FINESINE(pushangle));

  00407	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0040a	8b b0 a4 00 00
	00		 mov	 esi, DWORD PTR [eax+164]
  00410	8b 4d dc	 mov	 ecx, DWORD PTR _pushangle$4[ebp]
  00413	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finesine[ecx*4]
  0041a	52		 push	 edx
  0041b	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  0041e	50		 push	 eax
  0041f	e8 00 00 00 00	 call	 _FixedMul
  00424	83 c4 08	 add	 esp, 8
  00427	03 86 40 01 00
	00		 add	 eax, DWORD PTR [esi+320]
  0042d	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00430	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00436	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax

; 6745 : 						thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  0043c	68 00 e8 00 00	 push	 59392			; 0000e800H
  00441	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00444	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0044a	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  00450	52		 push	 edx
  00451	e8 00 00 00 00	 call	 _FixedMul
  00456	83 c4 08	 add	 esp, 8
  00459	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0045c	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00462	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6746 : 						thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  00468	68 00 e8 00 00	 push	 59392			; 0000e800H
  0046d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00470	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00476	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  0047c	52		 push	 edx
  0047d	e8 00 00 00 00	 call	 _FixedMul
  00482	83 c4 08	 add	 esp, 8
  00485	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00488	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0048e	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN19@PIT_PushTh:

; 6747 : 					}
; 6748 : 				}
; 6749 : 			}

  00494	e9 a7 01 00 00	 jmp	 $LN25@PIT_PushTh
$LN12@PIT_PushTh:

; 6750 : 			else
; 6751 : 			{
; 6752 : 				//NiGHTS-specific handling.
; 6753 : 				//By default, pushes and pulls only affect the Z-axis.
; 6754 : 				//By having the ambush flag, it affects the X-axis.
; 6755 : 				//By having the object special flag, it affects the Y-axis.
; 6756 : 				fixed_t tmpmomx, tmpmomy, tmpmomz;
; 6757 : 
; 6758 : 				if (tmpusher->source->health & 1)

  00499	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  0049e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004a1	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  004a7	83 e2 01	 and	 edx, 1
  004aa	74 28		 je	 SHORT $LN20@PIT_PushTh

; 6759 : 					tmpmomx = FixedMul(FixedDiv(sx - thing->x, dist), speed);

  004ac	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  004af	50		 push	 eax
  004b0	8b 4d fc	 mov	 ecx, DWORD PTR _dist$12[ebp]
  004b3	51		 push	 ecx
  004b4	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  004b7	8b 45 f4	 mov	 eax, DWORD PTR _sx$10[ebp]
  004ba	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  004bd	50		 push	 eax
  004be	e8 00 00 00 00	 call	 _FixedDiv
  004c3	83 c4 08	 add	 esp, 8
  004c6	50		 push	 eax
  004c7	e8 00 00 00 00	 call	 _FixedMul
  004cc	83 c4 08	 add	 esp, 8
  004cf	89 45 d8	 mov	 DWORD PTR _tmpmomx$3[ebp], eax
  004d2	eb 07		 jmp	 SHORT $LN21@PIT_PushTh
$LN20@PIT_PushTh:

; 6760 : 				else
; 6761 : 					tmpmomx = 0;

  004d4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _tmpmomx$3[ebp], 0
$LN21@PIT_PushTh:

; 6762 : 
; 6763 : 				if (tmpusher->source->health & 2)

  004db	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  004e0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004e3	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  004e9	83 e2 02	 and	 edx, 2
  004ec	74 28		 je	 SHORT $LN22@PIT_PushTh

; 6764 : 					tmpmomy = FixedMul(FixedDiv(sy - thing->y, dist), speed);

  004ee	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  004f1	50		 push	 eax
  004f2	8b 4d fc	 mov	 ecx, DWORD PTR _dist$12[ebp]
  004f5	51		 push	 ecx
  004f6	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  004f9	8b 45 f0	 mov	 eax, DWORD PTR _sy$9[ebp]
  004fc	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  004ff	50		 push	 eax
  00500	e8 00 00 00 00	 call	 _FixedDiv
  00505	83 c4 08	 add	 esp, 8
  00508	50		 push	 eax
  00509	e8 00 00 00 00	 call	 _FixedMul
  0050e	83 c4 08	 add	 esp, 8
  00511	89 45 d4	 mov	 DWORD PTR _tmpmomy$2[ebp], eax
  00514	eb 07		 jmp	 SHORT $LN23@PIT_PushTh
$LN22@PIT_PushTh:

; 6765 : 				else
; 6766 : 					tmpmomy = 0;

  00516	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _tmpmomy$2[ebp], 0
$LN23@PIT_PushTh:

; 6767 : 
; 6768 : 				tmpmomz = FixedMul(FixedDiv(sz - thing->z, dist), speed);

  0051d	8b 45 f8	 mov	 eax, DWORD PTR _speed$11[ebp]
  00520	50		 push	 eax
  00521	8b 4d fc	 mov	 ecx, DWORD PTR _dist$12[ebp]
  00524	51		 push	 ecx
  00525	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00528	8b 45 ec	 mov	 eax, DWORD PTR _sz$8[ebp]
  0052b	2b 42 18	 sub	 eax, DWORD PTR [edx+24]
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 _FixedDiv
  00534	83 c4 08	 add	 esp, 8
  00537	50		 push	 eax
  00538	e8 00 00 00 00	 call	 _FixedMul
  0053d	83 c4 08	 add	 esp, 8
  00540	89 45 d0	 mov	 DWORD PTR _tmpmomz$1[ebp], eax

; 6769 : 
; 6770 : 				if (tmpusher->source->type == MT_PUSH) // away!

  00543	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  00548	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0054b	81 79 7c 07 01
	00 00		 cmp	 DWORD PTR [ecx+124], 263 ; 00000107H
  00552	75 15		 jne	 SHORT $LN24@PIT_PushTh

; 6771 : 				{
; 6772 : 					tmpmomx *= -1;

  00554	6b 45 d8 ff	 imul	 eax, DWORD PTR _tmpmomx$3[ebp], -1
  00558	89 45 d8	 mov	 DWORD PTR _tmpmomx$3[ebp], eax

; 6773 : 					tmpmomy *= -1;

  0055b	6b 45 d4 ff	 imul	 eax, DWORD PTR _tmpmomy$2[ebp], -1
  0055f	89 45 d4	 mov	 DWORD PTR _tmpmomy$2[ebp], eax

; 6774 : 					tmpmomz *= -1;

  00562	6b 45 d0 ff	 imul	 eax, DWORD PTR _tmpmomz$1[ebp], -1
  00566	89 45 d0	 mov	 DWORD PTR _tmpmomz$1[ebp], eax
$LN24@PIT_PushTh:

; 6775 : 				}
; 6776 : 
; 6777 : 				thing->momx += tmpmomx;

  00569	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0056c	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0056f	03 4d d8	 add	 ecx, DWORD PTR _tmpmomx$3[ebp]
  00572	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00575	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 6778 : 				thing->momy += tmpmomy;

  00578	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0057b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0057e	03 4d d4	 add	 ecx, DWORD PTR _tmpmomy$2[ebp]
  00581	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00584	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 6779 : 				thing->momz += tmpmomz;

  00587	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0058a	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0058d	03 4d d0	 add	 ecx, DWORD PTR _tmpmomz$1[ebp]
  00590	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00593	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 6780 : 
; 6781 : 				if (thing->player)

  00596	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00599	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  005a0	0f 84 9a 00 00
	00		 je	 $LN25@PIT_PushTh

; 6782 : 				{
; 6783 : 					thing->player->cmomx += tmpmomx;

  005a6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005a9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005af	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  005b5	03 55 d8	 add	 edx, DWORD PTR _tmpmomx$3[ebp]
  005b8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005bb	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005c1	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 6784 : 					thing->player->cmomy += tmpmomy;

  005c7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005ca	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005d0	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  005d6	03 55 d4	 add	 edx, DWORD PTR _tmpmomy$2[ebp]
  005d9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005dc	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005e2	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 6785 : 					thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  005e8	68 00 e8 00 00	 push	 59392			; 0000e800H
  005ed	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005f0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005f6	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  005fc	52		 push	 edx
  005fd	e8 00 00 00 00	 call	 _FixedMul
  00602	83 c4 08	 add	 esp, 8
  00605	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00608	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0060e	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6786 : 					thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  00614	68 00 e8 00 00	 push	 59392			; 0000e800H
  00619	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0061c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00622	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00628	52		 push	 edx
  00629	e8 00 00 00 00	 call	 _FixedMul
  0062e	83 c4 08	 add	 esp, 8
  00631	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00634	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0063a	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN25@PIT_PushTh:

; 6787 : 				}
; 6788 : 			}
; 6789 : 		}
; 6790 : 	}
; 6791 : 
; 6792 : 	if (tmpusher->exclusive)

  00640	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmpusher
  00645	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00649	74 15		 je	 SHORT $LN26@PIT_PushTh

; 6793 : 		thing->flags2 |= MF2_PUSHED;

  0064b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0064e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00654	83 c9 01	 or	 ecx, 1
  00657	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0065a	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN26@PIT_PushTh:

; 6794 : 
; 6795 : 	return true;

  00660	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_PushTh:

; 6796 : }

  00665	5f		 pop	 edi
  00666	5e		 pop	 esi
  00667	5b		 pop	 ebx
  00668	8b e5		 mov	 esp, ebp
  0066a	5d		 pop	 ebp
  0066b	c3		 ret	 0
_PIT_PushThing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _Add_WallScroller
_TEXT	SEGMENT
_d$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_dx$ = 8						; size = 4
_dy$ = 12						; size = 4
_l$ = 16						; size = 4
_control$ = 20						; size = 4
_accel$ = 24						; size = 4
_Add_WallScroller PROC					; COMDAT

; 6238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6239 : 	fixed_t x = abs(l->dx), y = abs(l->dy), d;

  00009	8b 45 10	 mov	 eax, DWORD PTR _l$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _abs
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
  0001b	8b 45 10	 mov	 eax, DWORD PTR _l$[ebp]
  0001e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _abs
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax

; 6240 : 	if (y > x)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00030	3b 45 fc	 cmp	 eax, DWORD PTR _x$[ebp]
  00033	7e 12		 jle	 SHORT $LN2@Add_WallSc

; 6241 : 		d = x, x = y, y = d;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  0003e	89 4d fc	 mov	 DWORD PTR _x$[ebp], ecx
  00041	8b 55 f4	 mov	 edx, DWORD PTR _d$[ebp]
  00044	89 55 f8	 mov	 DWORD PTR _y$[ebp], edx
$LN2@Add_WallSc:

; 6242 : 	d = FixedDiv(x, FINESINE((tantoangle[FixedDiv(y, x) >> DBITS] + ANGLE_90) >> ANGLETOFINESHIFT));

  00047	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv
  00054	83 c4 08	 add	 esp, 8
  00057	c1 f8 05	 sar	 eax, 5
  0005a	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _tantoangle[eax*4]
  00061	81 c2 00 00 00
	40		 add	 edx, 1073741824		; 40000000H
  00067	c1 ea 13	 shr	 edx, 19			; 00000013H
  0006a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _finesine[edx*4]
  00071	50		 push	 eax
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _FixedDiv
  0007b	83 c4 08	 add	 esp, 8
  0007e	89 45 f4	 mov	 DWORD PTR _d$[ebp], eax

; 6243 : 	x = -FixedDiv(FixedMul(dy, l->dy) + FixedMul(dx, l->dx), d);

  00081	8b 45 f4	 mov	 eax, DWORD PTR _d$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 10	 mov	 ecx, DWORD PTR _l$[ebp]
  00088	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _dy$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _FixedMul
  00095	83 c4 08	 add	 esp, 8
  00098	8b f0		 mov	 esi, eax
  0009a	8b 4d 10	 mov	 ecx, DWORD PTR _l$[ebp]
  0009d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _dx$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _FixedMul
  000aa	83 c4 08	 add	 esp, 8
  000ad	03 f0		 add	 esi, eax
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 _FixedDiv
  000b5	83 c4 08	 add	 esp, 8
  000b8	f7 d8		 neg	 eax
  000ba	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 6244 : 	y = -FixedDiv(FixedMul(dx, l->dy) - FixedMul(dy, l->dx), d);

  000bd	8b 45 f4	 mov	 eax, DWORD PTR _d$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 10	 mov	 ecx, DWORD PTR _l$[ebp]
  000c4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000c7	52		 push	 edx
  000c8	8b 45 08	 mov	 eax, DWORD PTR _dx$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _FixedMul
  000d1	83 c4 08	 add	 esp, 8
  000d4	8b f0		 mov	 esi, eax
  000d6	8b 4d 10	 mov	 ecx, DWORD PTR _l$[ebp]
  000d9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000dc	52		 push	 edx
  000dd	8b 45 0c	 mov	 eax, DWORD PTR _dy$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _FixedMul
  000e6	83 c4 08	 add	 esp, 8
  000e9	2b f0		 sub	 esi, eax
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 _FixedDiv
  000f1	83 c4 08	 add	 esp, 8
  000f4	f7 d8		 neg	 eax
  000f6	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax

; 6245 : 	Add_Scroller(sc_side, x, y, control, *l->sidenum, accel, 0);

  000f9	6a 00		 push	 0
  000fb	8b 45 18	 mov	 eax, DWORD PTR _accel$[ebp]
  000fe	50		 push	 eax
  000ff	b9 02 00 00 00	 mov	 ecx, 2
  00104	6b d1 00	 imul	 edx, ecx, 0
  00107	8b 45 10	 mov	 eax, DWORD PTR _l$[ebp]
  0010a	0f b7 4c 10 16	 movzx	 ecx, WORD PTR [eax+edx+22]
  0010f	51		 push	 ecx
  00110	8b 55 14	 mov	 edx, DWORD PTR _control$[ebp]
  00113	52		 push	 edx
  00114	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00117	50		 push	 eax
  00118	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  0011b	51		 push	 ecx
  0011c	6a 00		 push	 0
  0011e	e8 00 00 00 00	 call	 _Add_Scroller
  00123	83 c4 1c	 add	 esp, 28			; 0000001cH

; 6246 : }

  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_Add_WallScroller ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _Add_Scroller
_TEXT	SEGMENT
_s$ = -4						; size = 4
_type$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
_control$ = 20						; size = 4
_affectee$ = 24						; size = 4
_accel$ = 28						; size = 4
_exclusive$ = 32					; size = 4
_Add_Scroller PROC					; COMDAT

; 6208 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6209 : 	scroll_t *s = Z_Calloc(sizeof *s, PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 38		 push	 56			; 00000038H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 6210 : 	s->thinker.function.acp1 = (actionf_p1)T_Scroll;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_Scroll

; 6211 : 	s->type = type;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0002c	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 6212 : 	s->dx = dx;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _dx$[ebp]
  00035	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 6213 : 	s->dy = dy;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _dy$[ebp]
  0003e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 6214 : 	s->accel = accel;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00044	8b 4d 1c	 mov	 ecx, DWORD PTR _accel$[ebp]
  00047	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 6215 : 	s->exclusive = exclusive;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0004d	8b 4d 20	 mov	 ecx, DWORD PTR _exclusive$[ebp]
  00050	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 6216 : 	s->vdx = s->vdy = 0;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00056	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00060	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 6217 : 	if ((s->control = control) != -1)

  00067	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0006a	8b 4d 14	 mov	 ecx, DWORD PTR _control$[ebp]
  0006d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00070	83 7d 14 ff	 cmp	 DWORD PTR _control$[ebp], -1
  00074	74 27		 je	 SHORT $LN2@Add_Scroll

; 6218 : 		s->last_height = sectors[control].floorheight + sectors[control].ceilingheight;

  00076	69 45 14 f8 00
	00 00		 imul	 eax, DWORD PTR _control$[ebp], 248
  0007d	69 4d 14 f8 00
	00 00		 imul	 ecx, DWORD PTR _control$[ebp], 248
  00084	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0008a	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0008d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00093	03 44 0a 04	 add	 eax, DWORD PTR [edx+ecx+4]
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0009a	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN2@Add_Scroll:

; 6219 : 	s->affectee = affectee;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000a0	8b 4d 18	 mov	 ecx, DWORD PTR _affectee$[ebp]
  000a3	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 6220 : 	P_AddThinker(&s->thinker);

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _P_AddThinker
  000af	83 c4 04	 add	 esp, 4

; 6221 : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_Add_Scroller ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_RunLevelLoadExecutors
_TEXT	SEGMENT
_i$ = -4						; size = 4
_P_RunLevelLoadExecutors PROC				; COMDAT

; 4916 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4917 : 	size_t i;
; 4918 : 
; 4919 : 	for (i = 0; i < numlines; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_RunLevel
$LN2@P_RunLevel:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_RunLevel:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00024	73 35		 jae	 SHORT $LN3@P_RunLevel

; 4920 : 	{
; 4921 : 		if (lines[i].special == 399)

  00026	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00030	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00035	81 fa 8f 01 00
	00		 cmp	 edx, 399		; 0000018fH
  0003b	75 1c		 jne	 SHORT $LN5@P_RunLevel

; 4922 : 			P_LinedefExecute(lines[i].tag, NULL, NULL);

  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0004b	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 _P_LinedefExecute
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@P_RunLevel:

; 4923 : 	}

  00059	eb b7		 jmp	 SHORT $LN2@P_RunLevel
$LN3@P_RunLevel:

; 4924 : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_P_RunLevelLoadExecutors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _axtoi
_TEXT	SEGMENT
_digit$ = -52						; size = 32
_intValue$ = -20					; size = 4
_count$ = -16						; size = 4
_m$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hexStg$ = 8						; size = 4
_axtoi	PROC						; COMDAT

; 4877 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4878 : 	INT32 n = 0;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 4879 : 	INT32 m = 0;

  0001a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], 0

; 4880 : 	INT32 count;
; 4881 : 	INT32 intValue = 0;

  00021	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _intValue$[ebp], 0
$LN2@axtoi:

; 4882 : 	INT32 digit[8];
; 4883 : 	while (n < 8)

  00028	83 7d f8 08	 cmp	 DWORD PTR _n$[ebp], 8
  0002c	0f 8d bb 00 00
	00		 jge	 $LN3@axtoi

; 4884 : 	{
; 4885 : 		if (hexStg[n] == '\0')

  00032	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00035	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00038	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003b	85 c9		 test	 ecx, ecx
  0003d	75 05		 jne	 SHORT $LN6@axtoi

; 4886 : 			break;

  0003f	e9 a9 00 00 00	 jmp	 $LN3@axtoi
$LN6@axtoi:

; 4887 : 		if (hexStg[n] > 0x29 && hexStg[n] < 0x40) // 0-9

  00044	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00047	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  0004a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004d	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00050	7e 23		 jle	 SHORT $LN7@axtoi
  00052	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00055	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00058	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005b	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0005e	7d 15		 jge	 SHORT $LN7@axtoi

; 4888 : 			digit[n] = (hexStg[n] & 0x0f);

  00060	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00063	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00066	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00069	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0006f	89 4c 95 cc	 mov	 DWORD PTR _digit$[ebp+edx*4], ecx
  00073	eb 6a		 jmp	 SHORT $LN12@axtoi
$LN7@axtoi:

; 4889 : 		else if (hexStg[n] >= 'a' && hexStg[n] <= 'f') // a-f

  00075	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00078	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  0007b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007e	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00081	7c 26		 jl	 SHORT $LN9@axtoi
  00083	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00086	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00089	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008c	83 f9 66	 cmp	 ecx, 102		; 00000066H
  0008f	7f 18		 jg	 SHORT $LN9@axtoi

; 4890 : 			digit[n] = (hexStg[n] & 0x0f) + 9;

  00091	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  00094	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  00097	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0009d	83 c1 09	 add	 ecx, 9
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  000a3	89 4c 95 cc	 mov	 DWORD PTR _digit$[ebp+edx*4], ecx
  000a7	eb 36		 jmp	 SHORT $LN12@axtoi
$LN9@axtoi:

; 4891 : 		else if (hexStg[n] >= 'A' && hexStg[n] <= 'F') // A-F

  000a9	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  000ac	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  000af	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b2	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000b5	7c 26		 jl	 SHORT $LN11@axtoi
  000b7	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  000ba	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  000bd	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c0	83 f9 46	 cmp	 ecx, 70			; 00000046H
  000c3	7f 18		 jg	 SHORT $LN11@axtoi

; 4892 : 			digit[n] = (hexStg[n] & 0x0f) + 9;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _hexStg$[ebp]
  000c8	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  000cb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ce	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000d1	83 c1 09	 add	 ecx, 9
  000d4	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  000d7	89 4c 95 cc	 mov	 DWORD PTR _digit$[ebp+edx*4], ecx
  000db	eb 02		 jmp	 SHORT $LN12@axtoi
$LN11@axtoi:

; 4893 : 		else
; 4894 : 			break;

  000dd	eb 0e		 jmp	 SHORT $LN3@axtoi
$LN12@axtoi:

; 4895 : 		n++;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 4896 : 	}

  000e8	e9 3b ff ff ff	 jmp	 $LN2@axtoi
$LN3@axtoi:

; 4897 : 	count = n;

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000f0	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax

; 4898 : 	m = n - 1;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000f6	83 e8 01	 sub	 eax, 1
  000f9	89 45 f4	 mov	 DWORD PTR _m$[ebp], eax

; 4899 : 	n = 0;

  000fc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$LN4@axtoi:

; 4900 : 	while (n < count)

  00103	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00106	3b 45 f0	 cmp	 eax, DWORD PTR _count$[ebp]
  00109	7d 29		 jge	 SHORT $LN5@axtoi

; 4901 : 	{
; 4902 : 		intValue = intValue | (digit[n] << (m << 2));

  0010b	8b 4d f4	 mov	 ecx, DWORD PTR _m$[ebp]
  0010e	c1 e1 02	 shl	 ecx, 2
  00111	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00114	8b 54 85 cc	 mov	 edx, DWORD PTR _digit$[ebp+eax*4]
  00118	d3 e2		 shl	 edx, cl
  0011a	0b 55 ec	 or	 edx, DWORD PTR _intValue$[ebp]
  0011d	89 55 ec	 mov	 DWORD PTR _intValue$[ebp], edx

; 4903 : 		m--;

  00120	8b 45 f4	 mov	 eax, DWORD PTR _m$[ebp]
  00123	83 e8 01	 sub	 eax, 1
  00126	89 45 f4	 mov	 DWORD PTR _m$[ebp], eax

; 4904 : 		n++;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0012c	83 c0 01	 add	 eax, 1
  0012f	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 4905 : 	}

  00132	eb cf		 jmp	 SHORT $LN4@axtoi
$LN5@axtoi:

; 4906 : 	return intValue;

  00134	8b 45 ec	 mov	 eax, DWORD PTR _intValue$[ebp]

; 4907 : }

  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013d	33 cd		 xor	 ecx, ebp
  0013f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
_axtoi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _EV_AddLaserThinker
_TEXT	SEGMENT
_ffloor$ = -8						; size = 4
_flash$ = -4						; size = 4
_sec$ = 8						; size = 4
_sec2$ = 12						; size = 4
_line$ = 16						; size = 4
_EV_AddLaserThinker PROC				; COMDAT

; 4851 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4852 : 	laserthink_t *flash;
; 4853 : 	ffloor_t *ffloor = P_AddFakeFloor(sec, sec2, line, laserflags);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _laserflags
  0000e	50		 push	 eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _line$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _P_AddFakeFloor
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	89 45 f8	 mov	 DWORD PTR _ffloor$[ebp], eax

; 4854 : 
; 4855 : 	if (!ffloor)

  00026	83 7d f8 00	 cmp	 DWORD PTR _ffloor$[ebp], 0
  0002a	75 02		 jne	 SHORT $LN2@EV_AddLase

; 4856 : 		return;

  0002c	eb 4d		 jmp	 SHORT $LN1@EV_AddLase
$LN2@EV_AddLase:

; 4857 : 
; 4858 : 	flash = Z_Calloc(sizeof (*flash), PU_LEVSPEC, NULL);

  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 33		 push	 51			; 00000033H
  00034	6a 20		 push	 32			; 00000020H
  00036	e8 00 00 00 00	 call	 _Z_CallocAlign
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
  0003e	89 45 fc	 mov	 DWORD PTR _flash$[ebp], eax

; 4859 : 
; 4860 : 	P_AddThinker(&flash->thinker);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _flash$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _P_AddThinker
  0004a	83 c4 04	 add	 esp, 4

; 4861 : 
; 4862 : 	flash->thinker.function.acp1 = (actionf_p1)T_LaserFlash;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _flash$[ebp]
  00050	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_LaserFlash

; 4863 : 	flash->ffloor = ffloor;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _flash$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  0005d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4864 : 	flash->sector = sec; // For finding mobjs

  00060	8b 45 fc	 mov	 eax, DWORD PTR _flash$[ebp]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00066	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4865 : 	flash->sec = sec2;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _flash$[ebp]
  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  0006f	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 4866 : 	flash->sourceline = line;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _flash$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR _line$[ebp]
  00078	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$LN1@EV_AddLase:

; 4867 : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_EV_AddLaserThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddCameraScanner
_TEXT	SEGMENT
_elevator$ = -4						; size = 4
_sourcesec$ = 8						; size = 4
_actionsector$ = 12					; size = 4
_angle$ = 16						; size = 4
_P_AddCameraScanner PROC				; COMDAT

; 4775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4776 : 	elevator_t *elevator; // Why not? LOL
; 4777 : 
; 4778 : 	// create and initialize new elevator thinker
; 4779 : 	elevator = Z_Calloc(sizeof (*elevator), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 54		 push	 84			; 00000054H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _elevator$[ebp], eax

; 4780 : 	P_AddThinker(&elevator->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _elevator$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4781 : 
; 4782 : 	elevator->thinker.function.acp1 = (actionf_p1)T_CameraScanner;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _elevator$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_CameraScanner

; 4783 : 	elevator->type = elevateBounce;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _elevator$[ebp]
  00035	c7 40 10 04 00
	00 00		 mov	 DWORD PTR [eax+16], 4

; 4784 : 
; 4785 : 	// set up the fields according to the type of elevator action
; 4786 : 	elevator->sector = sourcesec;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _elevator$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _sourcesec$[ebp]
  00042	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4787 : 	elevator->actionsector = actionsector;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _elevator$[ebp]
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _actionsector$[ebp]
  0004b	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 4788 : 	elevator->distance = FixedInt(AngleFixed(angle));

  0004e	8b 45 10	 mov	 eax, DWORD PTR _angle$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _AngleFixed
  00057	83 c4 04	 add	 esp, 4
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _FixedInt
  00060	83 c4 04	 add	 esp, 4
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _elevator$[ebp]
  00066	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 4789 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_P_AddCameraScanner ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddEachTimeThinker
_TEXT	SEGMENT
_eachtime$ = -4						; size = 4
_sec$ = 8						; size = 4
_sourceline$ = 12					; size = 4
_P_AddEachTimeThinker PROC				; COMDAT

; 4753 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4754 : 	levelspecthink_t *eachtime;
; 4755 : 
; 4756 : 	// create and initialize new thinker
; 4757 : 	eachtime = Z_Calloc(sizeof (*eachtime), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _eachtime$[ebp], eax

; 4758 : 	P_AddThinker(&eachtime->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _eachtime$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4759 : 
; 4760 : 	eachtime->thinker.function.acp1 = (actionf_p1)T_EachTimeThinker;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _eachtime$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_EachTimeThinker

; 4761 : 
; 4762 : 	eachtime->sector = sec;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _eachtime$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00038	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4763 : 	eachtime->sourceline = sourceline;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _eachtime$[ebp]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  00041	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4764 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_P_AddEachTimeThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddNoEnemiesThinker
_TEXT	SEGMENT
_nobaddies$ = -4					; size = 4
_sec$ = 8						; size = 4
_sourceline$ = 12					; size = 4
_P_AddNoEnemiesThinker PROC				; COMDAT

; 4731 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4732 : 	levelspecthink_t *nobaddies;
; 4733 : 
; 4734 : 	// create and initialize new thinker
; 4735 : 	nobaddies = Z_Calloc(sizeof (*nobaddies), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _nobaddies$[ebp], eax

; 4736 : 	P_AddThinker(&nobaddies->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _nobaddies$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4737 : 
; 4738 : 	nobaddies->thinker.function.acp1 = (actionf_p1)T_NoEnemiesSector;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _nobaddies$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_NoEnemiesSector

; 4739 : 
; 4740 : 	nobaddies->sector = sec;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _nobaddies$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00038	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4741 : 	nobaddies->sourceline = sourceline;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _nobaddies$[ebp]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  00041	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4742 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_P_AddNoEnemiesThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddThwompThinker
_TEXT	SEGMENT
_thwomp$ = -4						; size = 4
_sec$ = 8						; size = 4
_actionsector$ = 12					; size = 4
_sourceline$ = 16					; size = 4
_P_AddThwompThinker PROC				; COMDAT

; 4685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4686 : #define speed vars[1]
; 4687 : #define direction vars[2]
; 4688 : #define distance vars[3]
; 4689 : #define floorwasheight vars[4]
; 4690 : #define ceilingwasheight vars[5]
; 4691 : 	levelspecthink_t *thwomp;
; 4692 : 
; 4693 : 	// You *probably* already have a thwomp in this sector. If you've combined it with something
; 4694 : 	// else that uses the floordata/ceilingdata, you must be weird.
; 4695 : 	if (sec->floordata || sec->ceilingdata)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0000c	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  00010	75 09		 jne	 SHORT $LN3@P_AddThwom
  00012	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00015	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00019	74 05		 je	 SHORT $LN2@P_AddThwom
$LN3@P_AddThwom:

; 4696 : 		return;

  0001b	e9 bd 00 00 00	 jmp	 $LN1@P_AddThwom
$LN2@P_AddThwom:

; 4697 : 
; 4698 : 	// create and initialize new elevator thinker
; 4699 : 	thwomp = Z_Calloc(sizeof (*thwomp), PU_LEVSPEC, NULL);

  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	6a 33		 push	 51			; 00000033H
  00026	6a 58		 push	 88			; 00000058H
  00028	e8 00 00 00 00	 call	 _Z_CallocAlign
  0002d	83 c4 10	 add	 esp, 16			; 00000010H
  00030	89 45 fc	 mov	 DWORD PTR _thwomp$[ebp], eax

; 4700 : 	P_AddThinker(&thwomp->thinker);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _P_AddThinker
  0003c	83 c4 04	 add	 esp, 4

; 4701 : 
; 4702 : 	thwomp->thinker.function.acp1 = (actionf_p1)T_ThwompSector;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  00042	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_ThwompSector

; 4703 : 
; 4704 : 	// set up the fields according to the type of elevator action
; 4705 : 	thwomp->sector = sec;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  0004f	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4706 : 	thwomp->vars[0] = actionsector->tag;

  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	6b c8 00	 imul	 ecx, eax, 0
  0005a	8b 55 0c	 mov	 edx, DWORD PTR _actionsector$[ebp]
  0005d	0f bf 42 14	 movsx	 eax, WORD PTR [edx+20]
  00061	8b 55 fc	 mov	 edx, DWORD PTR _thwomp$[ebp]
  00064	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 4707 : 	thwomp->floorwasheight = thwomp->sector->floorheight;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  0006b	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0006e	ba 04 00 00 00	 mov	 edx, 4
  00073	c1 e2 02	 shl	 edx, 2
  00076	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 4c 10 10	 mov	 DWORD PTR [eax+edx+16], ecx

; 4708 : 	thwomp->ceilingwasheight = thwomp->sector->ceilingheight;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  00082	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00085	ba 04 00 00 00	 mov	 edx, 4
  0008a	6b c2 05	 imul	 eax, edx, 5
  0008d	8b 55 fc	 mov	 edx, DWORD PTR _thwomp$[ebp]
  00090	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00093	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 4709 : 	thwomp->direction = 0;

  00097	b8 04 00 00 00	 mov	 eax, 4
  0009c	d1 e0		 shl	 eax, 1
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _thwomp$[ebp]
  000a1	c7 44 01 10 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 0

; 4710 : 	thwomp->distance = 1;

  000a9	b8 04 00 00 00	 mov	 eax, 4
  000ae	6b c8 03	 imul	 ecx, eax, 3
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _thwomp$[ebp]
  000b4	c7 44 0a 10 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 1

; 4711 : 	thwomp->sourceline = sourceline;

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  000bf	8b 4d 10	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  000c2	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4712 : 	thwomp->sector->floordata = thwomp;

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  000c8	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000cb	8b 55 fc	 mov	 edx, DWORD PTR _thwomp$[ebp]
  000ce	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 4713 : 	thwomp->sector->ceilingdata = thwomp;

  000d1	8b 45 fc	 mov	 eax, DWORD PTR _thwomp$[ebp]
  000d4	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _thwomp$[ebp]
  000da	89 51 48	 mov	 DWORD PTR [ecx+72], edx
$LN1@P_AddThwom:

; 4714 : 	return;
; 4715 : #undef speed
; 4716 : #undef direction
; 4717 : #undef distance
; 4718 : #undef floorwasheight
; 4719 : #undef ceilingwasheight
; 4720 : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_P_AddThwompThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddOldAirbob
_TEXT	SEGMENT
_airbob$ = -4						; size = 4
_sec$ = 8						; size = 4
_sourceline$ = 12					; size = 4
_noadjust$ = 16						; size = 4
_P_AddOldAirbob PROC					; COMDAT

; 4633 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4634 : 	levelspecthink_t *airbob;
; 4635 : 
; 4636 : 	airbob = Z_Calloc(sizeof (*airbob), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _airbob$[ebp], eax

; 4637 : 	P_AddThinker(&airbob->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4638 : 
; 4639 : 	airbob->thinker.function.acp1 = (actionf_p1)T_RaiseSector;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_RaiseSector

; 4640 : 
; 4641 : 	// set up the fields
; 4642 : 	airbob->sector = sec;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00038	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4643 : 
; 4644 : 	// Require a spindash to activate
; 4645 : 	if (sourceline->flags & ML_NOCLIMB)

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _sourceline$[ebp]
  0003e	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00042	83 e1 40	 and	 ecx, 64			; 00000040H
  00045	74 15		 je	 SHORT $LN2@P_AddOldAi

; 4646 : 		airbob->vars[1] = 1;

  00047	b8 04 00 00 00	 mov	 eax, 4
  0004c	c1 e0 00	 shl	 eax, 0
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _airbob$[ebp]
  00052	c7 44 01 10 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 1
  0005a	eb 13		 jmp	 SHORT $LN3@P_AddOldAi
$LN2@P_AddOldAi:

; 4647 : 	else
; 4648 : 		airbob->vars[1] = 0;

  0005c	b8 04 00 00 00	 mov	 eax, 4
  00061	c1 e0 00	 shl	 eax, 0
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _airbob$[ebp]
  00067	c7 44 01 10 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 0
$LN3@P_AddOldAi:

; 4649 : 
; 4650 : 	airbob->vars[2] = FRACUNIT/NEWTICRATERATIO;

  0006f	b8 04 00 00 00	 mov	 eax, 4
  00074	d1 e0		 shl	 eax, 1
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _airbob$[ebp]
  00079	c7 44 01 10 00
	00 01 00	 mov	 DWORD PTR [ecx+eax+16], 65536 ; 00010000H

; 4651 : 
; 4652 : 	if (noadjust)

  00081	83 7d 10 00	 cmp	 DWORD PTR _noadjust$[ebp], 0
  00085	74 4b		 je	 SHORT $LN4@P_AddOldAi

; 4653 : 	{
; 4654 : 		airbob->vars[7] = airbob->sector->ceilingheight-16*FRACUNIT;

  00087	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  0008a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0008d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00090	81 ea 00 00 10
	00		 sub	 edx, 1048576		; 00100000H
  00096	b8 04 00 00 00	 mov	 eax, 4
  0009b	6b c8 07	 imul	 ecx, eax, 7
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  000a1	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 4655 : 		airbob->vars[6] = airbob->vars[7]

  000a5	b8 04 00 00 00	 mov	 eax, 4
  000aa	6b c8 07	 imul	 ecx, eax, 7
  000ad	8b 55 08	 mov	 edx, DWORD PTR _sec$[ebp]
  000b0	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  000b3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000b6	2b 10		 sub	 edx, DWORD PTR [eax]
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  000bb	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  000bf	2b ca		 sub	 ecx, edx
  000c1	ba 04 00 00 00	 mov	 edx, 4
  000c6	6b c2 06	 imul	 eax, edx, 6
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _airbob$[ebp]
  000cc	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 4656 : 			- (sec->ceilingheight - sec->floorheight);
; 4657 : 	}

  000d0	eb 30		 jmp	 SHORT $LN5@P_AddOldAi
$LN4@P_AddOldAi:

; 4658 : 	else
; 4659 : 		airbob->vars[7] = airbob->sector->ceilingheight - P_AproxDistance(sourceline->dx, sourceline->dy);

  000d2	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  000d5	8b 70 54	 mov	 esi, DWORD PTR [eax+84]
  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  000db	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000de	52		 push	 edx
  000df	8b 45 0c	 mov	 eax, DWORD PTR _sourceline$[ebp]
  000e2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _P_AproxDistance
  000eb	83 c4 08	 add	 esp, 8
  000ee	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000f1	2b d0		 sub	 edx, eax
  000f3	b8 04 00 00 00	 mov	 eax, 4
  000f8	6b c8 07	 imul	 ecx, eax, 7
  000fb	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  000fe	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx
$LN5@P_AddOldAi:

; 4660 : 
; 4661 : 	airbob->vars[3] = airbob->vars[2];

  00102	b8 04 00 00 00	 mov	 eax, 4
  00107	d1 e0		 shl	 eax, 1
  00109	b9 04 00 00 00	 mov	 ecx, 4
  0010e	6b d1 03	 imul	 edx, ecx, 3
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _airbob$[ebp]
  00114	8b 75 fc	 mov	 esi, DWORD PTR _airbob$[ebp]
  00117	8b 44 06 10	 mov	 eax, DWORD PTR [esi+eax+16]
  0011b	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 4662 : 
; 4663 : 	if (sourceline->flags & ML_BLOCKMONSTERS)

  0011f	8b 45 0c	 mov	 eax, DWORD PTR _sourceline$[ebp]
  00122	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00126	83 e1 02	 and	 ecx, 2
  00129	74 15		 je	 SHORT $LN6@P_AddOldAi

; 4664 : 		airbob->vars[0] = 1;

  0012b	b8 04 00 00 00	 mov	 eax, 4
  00130	6b c8 00	 imul	 ecx, eax, 0
  00133	8b 55 fc	 mov	 edx, DWORD PTR _airbob$[ebp]
  00136	c7 44 0a 10 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 1
  0013e	eb 13		 jmp	 SHORT $LN7@P_AddOldAi
$LN6@P_AddOldAi:

; 4665 : 	else
; 4666 : 		airbob->vars[0] = 0;

  00140	b8 04 00 00 00	 mov	 eax, 4
  00145	6b c8 00	 imul	 ecx, eax, 0
  00148	8b 55 fc	 mov	 edx, DWORD PTR _airbob$[ebp]
  0014b	c7 44 0a 10 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 0
$LN7@P_AddOldAi:

; 4667 : 
; 4668 : 	airbob->vars[5] = sec->ceilingheight;

  00153	b8 04 00 00 00	 mov	 eax, 4
  00158	6b c8 05	 imul	 ecx, eax, 5
  0015b	8b 55 fc	 mov	 edx, DWORD PTR _airbob$[ebp]
  0015e	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 4669 : 	airbob->vars[4] = airbob->vars[5]

  00168	b8 04 00 00 00	 mov	 eax, 4
  0016d	6b c8 05	 imul	 ecx, eax, 5
  00170	8b 55 08	 mov	 edx, DWORD PTR _sec$[ebp]
  00173	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00176	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00179	2b 10		 sub	 edx, DWORD PTR [eax]
  0017b	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  0017e	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  00182	2b ca		 sub	 ecx, edx
  00184	ba 04 00 00 00	 mov	 edx, 4
  00189	c1 e2 02	 shl	 edx, 2
  0018c	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  0018f	89 4c 10 10	 mov	 DWORD PTR [eax+edx+16], ecx

; 4670 : 			- (sec->ceilingheight - sec->floorheight);
; 4671 : 
; 4672 : 	airbob->sourceline = sourceline;

  00193	8b 45 fc	 mov	 eax, DWORD PTR _airbob$[ebp]
  00196	8b 4d 0c	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  00199	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4673 : }

  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
_P_AddOldAirbob ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddRaiseThinker
_TEXT	SEGMENT
_raise$ = -4						; size = 4
_sec$ = 8						; size = 4
_sourceline$ = 12					; size = 4
_P_AddRaiseThinker PROC					; COMDAT

; 4594 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4595 : 	levelspecthink_t *raise;
; 4596 : 
; 4597 : 	raise = Z_Calloc(sizeof (*raise), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _raise$[ebp], eax

; 4598 : 	P_AddThinker(&raise->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4599 : 
; 4600 : 	raise->thinker.function.acp1 = (actionf_p1)T_RaiseSector;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_RaiseSector

; 4601 : 
; 4602 : 	if (sourceline->flags & ML_BLOCKMONSTERS)

  00032	8b 45 0c	 mov	 eax, DWORD PTR _sourceline$[ebp]
  00035	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00039	83 e1 02	 and	 ecx, 2
  0003c	74 15		 je	 SHORT $LN2@P_AddRaise

; 4603 : 		raise->vars[0] = 1;

  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	6b c8 00	 imul	 ecx, eax, 0
  00046	8b 55 fc	 mov	 edx, DWORD PTR _raise$[ebp]
  00049	c7 44 0a 10 01
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 1
  00051	eb 13		 jmp	 SHORT $LN3@P_AddRaise
$LN2@P_AddRaise:

; 4604 : 	else
; 4605 : 		raise->vars[0] = 0;

  00053	b8 04 00 00 00	 mov	 eax, 4
  00058	6b c8 00	 imul	 ecx, eax, 0
  0005b	8b 55 fc	 mov	 edx, DWORD PTR _raise$[ebp]
  0005e	c7 44 0a 10 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+16], 0
$LN3@P_AddRaise:

; 4606 : 
; 4607 : 	// set up the fields
; 4608 : 	raise->sector = sec;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  0006c	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4609 : 
; 4610 : 	// Require a spindash to activate
; 4611 : 	if (sourceline->flags & ML_NOCLIMB)

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _sourceline$[ebp]
  00072	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00076	83 e1 40	 and	 ecx, 64			; 00000040H
  00079	74 15		 je	 SHORT $LN4@P_AddRaise

; 4612 : 		raise->vars[1] = 1;

  0007b	b8 04 00 00 00	 mov	 eax, 4
  00080	c1 e0 00	 shl	 eax, 0
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _raise$[ebp]
  00086	c7 44 01 10 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 1
  0008e	eb 13		 jmp	 SHORT $LN5@P_AddRaise
$LN4@P_AddRaise:

; 4613 : 	else
; 4614 : 		raise->vars[1] = 0;

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	c1 e0 00	 shl	 eax, 0
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _raise$[ebp]
  0009b	c7 44 01 10 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 0
$LN5@P_AddRaise:

; 4615 : 
; 4616 : 	raise->vars[2] = P_AproxDistance(sourceline->dx, sourceline->dy);

  000a3	8b 45 0c	 mov	 eax, DWORD PTR _sourceline$[ebp]
  000a6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a9	51		 push	 ecx
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _sourceline$[ebp]
  000ad	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _P_AproxDistance
  000b6	83 c4 08	 add	 esp, 8
  000b9	b9 04 00 00 00	 mov	 ecx, 4
  000be	d1 e1		 shl	 ecx, 1
  000c0	8b 55 fc	 mov	 edx, DWORD PTR _raise$[ebp]
  000c3	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 4617 : 	raise->vars[2] = FixedDiv(raise->vars[2], NEWTICRATERATIO*4*FRACUNIT);

  000c7	68 00 00 04 00	 push	 262144			; 00040000H
  000cc	b8 04 00 00 00	 mov	 eax, 4
  000d1	d1 e0		 shl	 eax, 1
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _raise$[ebp]
  000d6	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 _FixedDiv
  000e0	83 c4 08	 add	 esp, 8
  000e3	b9 04 00 00 00	 mov	 ecx, 4
  000e8	d1 e1		 shl	 ecx, 1
  000ea	8b 55 fc	 mov	 edx, DWORD PTR _raise$[ebp]
  000ed	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 4618 : 	raise->vars[3] = raise->vars[2];

  000f1	b8 04 00 00 00	 mov	 eax, 4
  000f6	d1 e0		 shl	 eax, 1
  000f8	b9 04 00 00 00	 mov	 ecx, 4
  000fd	6b d1 03	 imul	 edx, ecx, 3
  00100	8b 4d fc	 mov	 ecx, DWORD PTR _raise$[ebp]
  00103	8b 75 fc	 mov	 esi, DWORD PTR _raise$[ebp]
  00106	8b 44 06 10	 mov	 eax, DWORD PTR [esi+eax+16]
  0010a	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 4619 : 
; 4620 : 	raise->vars[5] = P_FindHighestCeilingSurrounding(sec);

  0010e	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _P_FindHighestCeilingSurrounding
  00117	83 c4 04	 add	 esp, 4
  0011a	b9 04 00 00 00	 mov	 ecx, 4
  0011f	6b d1 05	 imul	 edx, ecx, 5
  00122	8b 4d fc	 mov	 ecx, DWORD PTR _raise$[ebp]
  00125	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 4621 : 	raise->vars[4] = raise->vars[5]

  00129	b8 04 00 00 00	 mov	 eax, 4
  0012e	6b c8 05	 imul	 ecx, eax, 5
  00131	8b 55 08	 mov	 edx, DWORD PTR _sec$[ebp]
  00134	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00137	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0013a	2b 10		 sub	 edx, DWORD PTR [eax]
  0013c	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  0013f	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  00143	2b ca		 sub	 ecx, edx
  00145	ba 04 00 00 00	 mov	 edx, 4
  0014a	c1 e2 02	 shl	 edx, 2
  0014d	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  00150	89 4c 10 10	 mov	 DWORD PTR [eax+edx+16], ecx

; 4622 : 		- (sec->ceilingheight - sec->floorheight);
; 4623 : 
; 4624 : 	raise->vars[7] = P_FindLowestCeilingSurrounding(sec);

  00154	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _P_FindLowestCeilingSurrounding
  0015d	83 c4 04	 add	 esp, 4
  00160	b9 04 00 00 00	 mov	 ecx, 4
  00165	6b d1 07	 imul	 edx, ecx, 7
  00168	8b 4d fc	 mov	 ecx, DWORD PTR _raise$[ebp]
  0016b	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 4625 : 	raise->vars[6] = raise->vars[7]

  0016f	b8 04 00 00 00	 mov	 eax, 4
  00174	6b c8 07	 imul	 ecx, eax, 7
  00177	8b 55 08	 mov	 edx, DWORD PTR _sec$[ebp]
  0017a	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0017d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00180	2b 10		 sub	 edx, DWORD PTR [eax]
  00182	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  00185	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  00189	2b ca		 sub	 ecx, edx
  0018b	ba 04 00 00 00	 mov	 edx, 4
  00190	6b c2 06	 imul	 eax, edx, 6
  00193	8b 55 fc	 mov	 edx, DWORD PTR _raise$[ebp]
  00196	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 4626 : 		- (sec->ceilingheight - sec->floorheight);
; 4627 : 
; 4628 : 	raise->sourceline = sourceline;

  0019a	8b 45 fc	 mov	 eax, DWORD PTR _raise$[ebp]
  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  001a0	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4629 : }

  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	5b		 pop	 ebx
  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c3		 ret	 0
_P_AddRaiseThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddFakeFloor
_TEXT	SEGMENT
_i$1 = -24						; size = 4
_lst$ = -20						; size = 4
_p$ = -16						; size = 4
_f$ = -12						; size = 4
_th$ = -8						; size = 4
_ffloor$ = -4						; size = 4
_sec$ = 8						; size = 4
_sec2$ = 12						; size = 4
_master$ = 16						; size = 4
_flags$ = 20						; size = 4
_P_AddFakeFloor PROC					; COMDAT

; 4330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4331 : 	ffloor_t *ffloor;
; 4332 : 	thinker_t *th;
; 4333 : 	friction_t *f;
; 4334 : 	pusher_t *p;
; 4335 : 	levelspecthink_t *lst;
; 4336 : 
; 4337 : 	if (sec == sec2)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR _sec2$[ebp]
  0000f	75 07		 jne	 SHORT $LN14@P_AddFakeF

; 4338 : 		return false; //Don't need a fake floor on a control sector.

  00011	33 c0		 xor	 eax, eax
  00013	e9 7f 05 00 00	 jmp	 $LN1@P_AddFakeF
$LN14@P_AddFakeF:

; 4339 : 
; 4340 : 	if (sec2->ceilingheight < sec2->floorheight)

  00018	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  0001e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00021	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00023	7d 15		 jge	 SHORT $LN15@P_AddFakeF

; 4341 : 		I_Error("One of your FOFs with a tag of %d has a top height less than that of the bottom.\n", master->tag);

  00025	8b 45 10	 mov	 eax, DWORD PTR _master$[ebp]
  00028	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DOPDFDHL@One?5of?5your?5FOFs?5with?5a?5tag?5of?5@
  00032	e8 00 00 00 00	 call	 _I_Error
  00037	83 c4 08	 add	 esp, 8
$LN15@P_AddFakeF:

; 4342 : 
; 4343 : 	if (sec2->numattached == 0)

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0003d	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00044	0f 85 99 00 00
	00		 jne	 $LN16@P_AddFakeF

; 4344 : 	{
; 4345 : 		sec2->attached = Z_Malloc(sizeof (*sec2->attached) * sec2->maxattached, PU_STATIC, NULL);

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 01		 push	 1
  00050	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00053	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00059	c1 e1 02	 shl	 ecx, 2
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _Z_MallocAlign
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  00068	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 4346 : 		sec2->attachedsolid = Z_Malloc(sizeof (*sec2->attachedsolid) * sec2->maxattached, PU_STATIC, NULL);

  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	6a 01		 push	 1
  00074	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00077	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0007d	c1 e1 02	 shl	 ecx, 2
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _Z_MallocAlign
  00086	83 c4 10	 add	 esp, 16			; 00000010H
  00089	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  0008c	89 82 98 00 00
	00		 mov	 DWORD PTR [edx+152], eax

; 4347 : 		sec2->attached[0] = sec - sectors;

  00092	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00095	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  0009b	99		 cdq
  0009c	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  000a1	f7 f9		 idiv	 ecx
  000a3	ba 04 00 00 00	 mov	 edx, 4
  000a8	6b ca 00	 imul	 ecx, edx, 0
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  000ae	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [edx+148]
  000b4	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 4348 : 		sec2->numattached = 1;

  000b7	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  000ba	c7 80 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+156], 1

; 4349 : 		sec2->attachedsolid[0] = (flags & FF_SOLID);

  000c4	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  000c7	83 e0 06	 and	 eax, 6
  000ca	b9 04 00 00 00	 mov	 ecx, 4
  000cf	6b d1 00	 imul	 edx, ecx, 0
  000d2	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  000d5	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [ecx+152]
  000db	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 4350 : 	}

  000de	e9 25 01 00 00	 jmp	 $LN17@P_AddFakeF
$LN16@P_AddFakeF:

; 4351 : 	else
; 4352 : 	{
; 4353 : 		size_t i;
; 4354 : 
; 4355 : 		for (i = 0; i < sec2->numattached; i++)

  000e3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  000ea	eb 09		 jmp	 SHORT $LN4@P_AddFakeF
$LN2@P_AddFakeF:
  000ec	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  000ef	83 c0 01	 add	 eax, 1
  000f2	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@P_AddFakeF:
  000f5	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _i$1[ebp]
  000fb	3b 88 9c 00 00
	00		 cmp	 ecx, DWORD PTR [eax+156]
  00101	73 2b		 jae	 SHORT $LN3@P_AddFakeF

; 4356 : 			if (sec2->attached[i] == (size_t)(sec - sectors))

  00103	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00106	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0010c	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0010f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00115	99		 cdq
  00116	be f8 00 00 00	 mov	 esi, 248		; 000000f8H
  0011b	f7 fe		 idiv	 esi
  0011d	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  00120	39 04 91	 cmp	 DWORD PTR [ecx+edx*4], eax
  00123	75 07		 jne	 SHORT $LN18@P_AddFakeF

; 4357 : 				return NULL;

  00125	33 c0		 xor	 eax, eax
  00127	e9 6b 04 00 00	 jmp	 $LN1@P_AddFakeF
$LN18@P_AddFakeF:
  0012c	eb be		 jmp	 SHORT $LN2@P_AddFakeF
$LN3@P_AddFakeF:

; 4358 : 
; 4359 : 		if (sec2->numattached >= sec2->maxattached)

  0012e	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00131	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  00134	8b 90 9c 00 00
	00		 mov	 edx, DWORD PTR [eax+156]
  0013a	3b 91 a0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+160]
  00140	72 70		 jb	 SHORT $LN19@P_AddFakeF

; 4360 : 		{
; 4361 : 			sec2->maxattached *= 2;

  00142	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00145	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0014b	d1 e1		 shl	 ecx, 1
  0014d	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  00150	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 4362 : 			sec2->attached = Z_Realloc(sec2->attached, sizeof (*sec2->attached) * sec2->maxattached, PU_STATIC, NULL);

  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	6a 01		 push	 1
  0015c	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0015f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00165	c1 e1 02	 shl	 ecx, 2
  00168	51		 push	 ecx
  00169	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  0016c	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _Z_ReallocAlign
  00178	83 c4 14	 add	 esp, 20			; 00000014H
  0017b	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  0017e	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax

; 4363 : 			sec2->attachedsolid = Z_Realloc(sec2->attachedsolid, sizeof (*sec2->attachedsolid) * sec2->maxattached, PU_STATIC, NULL);

  00184	6a 00		 push	 0
  00186	6a 00		 push	 0
  00188	6a 01		 push	 1
  0018a	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0018d	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00193	c1 e1 02	 shl	 ecx, 2
  00196	51		 push	 ecx
  00197	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  0019a	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _Z_ReallocAlign
  001a6	83 c4 14	 add	 esp, 20			; 00000014H
  001a9	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  001ac	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax
$LN19@P_AddFakeF:

; 4364 : 		}
; 4365 : 		sec2->attached[sec2->numattached] = sec - sectors;

  001b2	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  001b5	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  001bb	99		 cdq
  001bc	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  001c1	f7 f9		 idiv	 ecx
  001c3	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  001c6	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  001cc	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  001cf	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [edx+148]
  001d5	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 4366 : 		sec2->attachedsolid[sec2->numattached] = (flags & FF_SOLID);

  001d8	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  001db	83 e0 06	 and	 eax, 6
  001de	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  001e1	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  001e7	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  001ea	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [ecx+152]
  001f0	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 4367 : 		sec2->numattached++;

  001f3	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  001f6	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  001fc	83 c1 01	 add	 ecx, 1
  001ff	8b 55 0c	 mov	 edx, DWORD PTR _sec2$[ebp]
  00202	89 8a 9c 00 00
	00		 mov	 DWORD PTR [edx+156], ecx
$LN17@P_AddFakeF:

; 4368 : 	}
; 4369 : 
; 4370 : 	// Add the floor
; 4371 : 	ffloor = Z_Calloc(sizeof (*ffloor), PU_LEVEL, NULL);

  00208	6a 00		 push	 0
  0020a	6a 00		 push	 0
  0020c	6a 32		 push	 50			; 00000032H
  0020e	6a 54		 push	 84			; 00000054H
  00210	e8 00 00 00 00	 call	 _Z_CallocAlign
  00215	83 c4 10	 add	 esp, 16			; 00000010H
  00218	89 45 fc	 mov	 DWORD PTR _ffloor$[ebp], eax

; 4372 : 	ffloor->secnum = sec2 - sectors;

  0021b	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0021e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00224	99		 cdq
  00225	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0022a	f7 f9		 idiv	 ecx
  0022c	8b 55 fc	 mov	 edx, DWORD PTR _ffloor$[ebp]
  0022f	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 4373 : 	ffloor->target = sec;

  00232	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00235	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00238	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 4374 : 	ffloor->bottomheight = &sec2->floorheight;

  0023b	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  00241	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 4375 : 	ffloor->bottompic = &sec2->floorpic;

  00244	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00247	83 c0 08	 add	 eax, 8
  0024a	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  0024d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 4376 : 	ffloor->bottomxoffs = &sec2->floor_xoffs;

  00250	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00253	83 c0 50	 add	 eax, 80			; 00000050H
  00256	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  00259	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 4377 : 	ffloor->bottomyoffs = &sec2->floor_yoffs;

  0025c	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0025f	83 c0 54	 add	 eax, 84			; 00000054H
  00262	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  00265	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 4378 : 	ffloor->bottomangle = &sec2->floorpic_angle;

  00268	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0026b	83 c0 60	 add	 eax, 96			; 00000060H
  0026e	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  00271	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 4379 : 
; 4380 : 	// Add the ceiling
; 4381 : 	ffloor->topheight = &sec2->ceilingheight;

  00274	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00277	83 c0 04	 add	 eax, 4
  0027a	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  0027d	89 01		 mov	 DWORD PTR [ecx], eax

; 4382 : 	ffloor->toppic = &sec2->ceilingpic;

  0027f	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00282	83 c0 0c	 add	 eax, 12			; 0000000cH
  00285	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  00288	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 4383 : 	ffloor->toplightlevel = &sec2->lightlevel;

  0028b	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0028e	83 c0 10	 add	 eax, 16			; 00000010H
  00291	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  00294	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4384 : 	ffloor->topxoffs = &sec2->ceiling_xoffs;

  00297	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  0029a	83 c0 58	 add	 eax, 88			; 00000058H
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  002a0	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 4385 : 	ffloor->topyoffs = &sec2->ceiling_yoffs;

  002a3	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  002a6	83 c0 5c	 add	 eax, 92			; 0000005cH
  002a9	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  002ac	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 4386 : 	ffloor->topangle = &sec2->ceilingpic_angle;

  002af	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  002b2	83 c0 64	 add	 eax, 100		; 00000064H
  002b5	8b 4d fc	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  002b8	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 4387 : 
; 4388 : 	if ((flags & FF_SOLID) && (master->flags & ML_EFFECT1)) // Block player only

  002bb	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  002be	83 e0 06	 and	 eax, 6
  002c1	74 15		 je	 SHORT $LN20@P_AddFakeF
  002c3	8b 45 10	 mov	 eax, DWORD PTR _master$[ebp]
  002c6	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  002ca	83 e1 20	 and	 ecx, 32			; 00000020H
  002cd	74 09		 je	 SHORT $LN20@P_AddFakeF

; 4389 : 		flags &= ~FF_BLOCKOTHERS;

  002cf	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  002d2	83 e0 fb	 and	 eax, -5			; fffffffbH
  002d5	89 45 14	 mov	 DWORD PTR _flags$[ebp], eax
$LN20@P_AddFakeF:

; 4390 : 
; 4391 : 	if ((flags & FF_SOLID) && (master->flags & ML_EFFECT2)) // Block all BUT player

  002d8	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  002db	83 e0 06	 and	 eax, 6
  002de	74 18		 je	 SHORT $LN21@P_AddFakeF
  002e0	8b 45 10	 mov	 eax, DWORD PTR _master$[ebp]
  002e3	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  002e7	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002ed	74 09		 je	 SHORT $LN21@P_AddFakeF

; 4392 : 		flags &= ~FF_BLOCKPLAYER;

  002ef	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  002f2	83 e0 fd	 and	 eax, -3			; fffffffdH
  002f5	89 45 14	 mov	 DWORD PTR _flags$[ebp], eax
$LN21@P_AddFakeF:

; 4393 : 
; 4394 : 	ffloor->flags = flags;

  002f8	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  002fb	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  002fe	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 4395 : 	ffloor->master = master;

  00301	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00304	8b 4d 10	 mov	 ecx, DWORD PTR _master$[ebp]
  00307	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 4396 : 	ffloor->norender = INFTICS;

  0030a	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  0030d	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [eax+80], -1

; 4397 : 
; 4398 : 	// scan the thinkers
; 4399 : 	// to see if this FOF should have spikeness
; 4400 : 	for (th = thinkercap.next; th != &thinkercap; th = th->next)

  00314	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00319	89 45 f8	 mov	 DWORD PTR _th$[ebp], eax
  0031c	eb 09		 jmp	 SHORT $LN7@P_AddFakeF
$LN5@P_AddFakeF:
  0031e	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00321	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00324	89 4d f8	 mov	 DWORD PTR _th$[ebp], ecx
$LN7@P_AddFakeF:
  00327	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _th$[ebp], OFFSET _thinkercap
  0032e	74 3f		 je	 SHORT $LN6@P_AddFakeF

; 4401 : 	{
; 4402 : 		if (th->function.acp1 != (actionf_p1)T_SpikeSector)

  00330	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00333	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _T_SpikeSector
  0033a	74 02		 je	 SHORT $LN22@P_AddFakeF

; 4403 : 			continue;

  0033c	eb e0		 jmp	 SHORT $LN5@P_AddFakeF
$LN22@P_AddFakeF:

; 4404 : 
; 4405 : 		lst = (levelspecthink_t *)th;

  0033e	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00341	89 45 ec	 mov	 DWORD PTR _lst$[ebp], eax

; 4406 : 
; 4407 : 		if (lst->sector == sec2)

  00344	8b 45 ec	 mov	 eax, DWORD PTR _lst$[ebp]
  00347	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0034a	3b 4d 0c	 cmp	 ecx, DWORD PTR _sec2$[ebp]
  0034d	75 1e		 jne	 SHORT $LN23@P_AddFakeF

; 4408 : 			P_AddSpikeThinker(sec, (INT32)(sec2-sectors));

  0034f	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00352	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00358	99		 cdq
  00359	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0035e	f7 f9		 idiv	 ecx
  00360	50		 push	 eax
  00361	8b 55 08	 mov	 edx, DWORD PTR _sec$[ebp]
  00364	52		 push	 edx
  00365	e8 00 00 00 00	 call	 _P_AddSpikeThinker
  0036a	83 c4 08	 add	 esp, 8
$LN23@P_AddFakeF:

; 4409 : 	}

  0036d	eb af		 jmp	 SHORT $LN5@P_AddFakeF
$LN6@P_AddFakeF:

; 4410 : 
; 4411 : 	// scan the thinkers
; 4412 : 	// to see if this FOF should have friction
; 4413 : 	for (th = thinkercap.next; th != &thinkercap; th = th->next)

  0036f	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00374	89 45 f8	 mov	 DWORD PTR _th$[ebp], eax
  00377	eb 09		 jmp	 SHORT $LN10@P_AddFakeF
$LN8@P_AddFakeF:
  00379	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0037c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0037f	89 4d f8	 mov	 DWORD PTR _th$[ebp], ecx
$LN10@P_AddFakeF:
  00382	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _th$[ebp], OFFSET _thinkercap
  00389	74 5a		 je	 SHORT $LN9@P_AddFakeF

; 4414 : 	{
; 4415 : 		if (th->function.acp1 != (actionf_p1)T_Friction)

  0038b	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0038e	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _T_Friction
  00395	74 02		 je	 SHORT $LN24@P_AddFakeF

; 4416 : 			continue;

  00397	eb e0		 jmp	 SHORT $LN8@P_AddFakeF
$LN24@P_AddFakeF:

; 4417 : 
; 4418 : 		f = (friction_t *)th;

  00399	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0039c	89 45 f4	 mov	 DWORD PTR _f$[ebp], eax

; 4419 : 
; 4420 : 		if (&sectors[f->affectee] == sec2)

  0039f	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  003a2	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  003a9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  003af	3b 4d 0c	 cmp	 ecx, DWORD PTR _sec2$[ebp]
  003b2	75 2f		 jne	 SHORT $LN25@P_AddFakeF

; 4421 : 			Add_Friction(f->friction, f->movefactor, (INT32)(sec-sectors), f->affectee);

  003b4	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  003b7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003ba	51		 push	 ecx
  003bb	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  003be	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  003c4	99		 cdq
  003c5	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  003ca	f7 f9		 idiv	 ecx
  003cc	50		 push	 eax
  003cd	8b 55 f4	 mov	 edx, DWORD PTR _f$[ebp]
  003d0	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  003d3	50		 push	 eax
  003d4	8b 4d f4	 mov	 ecx, DWORD PTR _f$[ebp]
  003d7	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  003da	52		 push	 edx
  003db	e8 00 00 00 00	 call	 _Add_Friction
  003e0	83 c4 10	 add	 esp, 16			; 00000010H
$LN25@P_AddFakeF:

; 4422 : 	}

  003e3	eb 94		 jmp	 SHORT $LN8@P_AddFakeF
$LN9@P_AddFakeF:

; 4423 : 
; 4424 : 	// scan the thinkers
; 4425 : 	// to see if this FOF should have wind/current/pusher
; 4426 : 	for (th = thinkercap.next; th != &thinkercap; th = th->next)

  003e5	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  003ea	89 45 f8	 mov	 DWORD PTR _th$[ebp], eax
  003ed	eb 09		 jmp	 SHORT $LN13@P_AddFakeF
$LN11@P_AddFakeF:
  003ef	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  003f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003f5	89 4d f8	 mov	 DWORD PTR _th$[ebp], ecx
$LN13@P_AddFakeF:
  003f8	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _th$[ebp], OFFSET _thinkercap
  003ff	74 7f		 je	 SHORT $LN12@P_AddFakeF

; 4427 : 	{
; 4428 : 		if (th->function.acp1 != (actionf_p1)T_Pusher)

  00401	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00404	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _T_Pusher
  0040b	74 02		 je	 SHORT $LN26@P_AddFakeF

; 4429 : 			continue;

  0040d	eb e0		 jmp	 SHORT $LN11@P_AddFakeF
$LN26@P_AddFakeF:

; 4430 : 
; 4431 : 		p = (pusher_t *)th;

  0040f	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00412	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 4432 : 
; 4433 : 		if (&sectors[p->affectee] == sec2)

  00415	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00418	69 48 34 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+52], 248
  0041f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00425	3b 4d 0c	 cmp	 ecx, DWORD PTR _sec2$[ebp]
  00428	75 51		 jne	 SHORT $LN27@P_AddFakeF

; 4434 : 			Add_Pusher(p->type, p->x_mag<<FRACBITS, p->y_mag<<FRACBITS, p->source, (INT32)(sec-sectors), p->affectee, p->exclusive, p->slider);

  0042a	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0042d	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00430	51		 push	 ecx
  00431	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00434	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00437	50		 push	 eax
  00438	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0043b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0043e	52		 push	 edx
  0043f	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00442	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00448	99		 cdq
  00449	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0044e	f7 f9		 idiv	 ecx
  00450	50		 push	 eax
  00451	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00454	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00457	50		 push	 eax
  00458	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0045b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0045e	c1 e2 10	 shl	 edx, 16			; 00000010H
  00461	52		 push	 edx
  00462	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00465	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00468	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0046b	51		 push	 ecx
  0046c	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  0046f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00472	50		 push	 eax
  00473	e8 00 00 00 00	 call	 _Add_Pusher
  00478	83 c4 20	 add	 esp, 32			; 00000020H
$LN27@P_AddFakeF:

; 4435 : 	}

  0047b	e9 6f ff ff ff	 jmp	 $LN11@P_AddFakeF
$LN12@P_AddFakeF:

; 4436 : 
; 4437 : 	if (flags & FF_TRANSLUCENT)

  00480	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00483	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00488	74 50		 je	 SHORT $LN28@P_AddFakeF

; 4438 : 	{
; 4439 : 		if (sides[master->sidenum[0]].toptexture > 0)

  0048a	b8 02 00 00 00	 mov	 eax, 2
  0048f	6b c8 00	 imul	 ecx, eax, 0
  00492	8b 55 10	 mov	 edx, DWORD PTR _master$[ebp]
  00495	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0049a	6b c8 1c	 imul	 ecx, eax, 28
  0049d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  004a3	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  004a8	7e 24		 jle	 SHORT $LN30@P_AddFakeF

; 4440 : 			ffloor->alpha = sides[master->sidenum[0]].toptexture;

  004aa	b8 02 00 00 00	 mov	 eax, 2
  004af	6b c8 00	 imul	 ecx, eax, 0
  004b2	8b 55 10	 mov	 edx, DWORD PTR _master$[ebp]
  004b5	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  004ba	6b c8 1c	 imul	 ecx, eax, 28
  004bd	8b 55 fc	 mov	 edx, DWORD PTR _ffloor$[ebp]
  004c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  004c5	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  004c9	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
  004cc	eb 0a		 jmp	 SHORT $LN31@P_AddFakeF
$LN30@P_AddFakeF:

; 4441 : 		else
; 4442 : 			ffloor->alpha = 0x80;

  004ce	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  004d1	c7 40 4c 80 00
	00 00		 mov	 DWORD PTR [eax+76], 128	; 00000080H
$LN31@P_AddFakeF:

; 4443 : 	}

  004d8	eb 0a		 jmp	 SHORT $LN29@P_AddFakeF
$LN28@P_AddFakeF:

; 4444 : 	else
; 4445 : 		ffloor->alpha = 0xff;

  004da	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  004dd	c7 40 4c ff 00
	00 00		 mov	 DWORD PTR [eax+76], 255	; 000000ffH
$LN29@P_AddFakeF:

; 4446 : 
; 4447 : 	if (flags & FF_QUICKSAND)

  004e4	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  004e7	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  004ec	74 0a		 je	 SHORT $LN32@P_AddFakeF

; 4448 : 		CheckForQuicksand = true;

  004ee	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CheckForQuicksand, 1
$LN32@P_AddFakeF:

; 4449 : 
; 4450 : 	if ((flags & FF_BUSTUP) || (flags & FF_SHATTER) || (flags & FF_SPINBUST))

  004f8	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  004fb	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00500	75 14		 jne	 SHORT $LN34@P_AddFakeF
  00502	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00505	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0050a	75 0a		 jne	 SHORT $LN34@P_AddFakeF
  0050c	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0050f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00514	74 0a		 je	 SHORT $LN33@P_AddFakeF
$LN34@P_AddFakeF:

; 4451 : 		CheckForBustableBlocks = true;

  00516	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CheckForBustableBlocks, 1
$LN33@P_AddFakeF:

; 4452 : 
; 4453 : 	if ((flags & FF_MARIO))

  00520	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00523	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00528	74 1a		 je	 SHORT $LN35@P_AddFakeF

; 4454 : 	{
; 4455 : 		P_AddBlockThinker(sec2, master);

  0052a	8b 45 10	 mov	 eax, DWORD PTR _master$[ebp]
  0052d	50		 push	 eax
  0052e	8b 4d 0c	 mov	 ecx, DWORD PTR _sec2$[ebp]
  00531	51		 push	 ecx
  00532	e8 00 00 00 00	 call	 _P_AddBlockThinker
  00537	83 c4 08	 add	 esp, 8

; 4456 : 		CheckForMarioBlocks = true;

  0053a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CheckForMarioBlocks, 1
$LN35@P_AddFakeF:

; 4457 : 	}
; 4458 : 
; 4459 : 	if ((flags & FF_CRUMBLE))

  00544	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00547	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0054c	74 0a		 je	 SHORT $LN36@P_AddFakeF

; 4460 : 		sec2->crumblestate = 1;

  0054e	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00551	c7 40 74 01 00
	00 00		 mov	 DWORD PTR [eax+116], 1
$LN36@P_AddFakeF:

; 4461 : 
; 4462 : 	if ((flags & FF_FLOATBOB))

  00558	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0055b	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00560	74 22		 je	 SHORT $LN37@P_AddFakeF

; 4463 : 	{
; 4464 : 		P_AddFloatThinker(sec2, sec->tag, master);

  00562	8b 45 10	 mov	 eax, DWORD PTR _master$[ebp]
  00565	50		 push	 eax
  00566	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00569	0f bf 51 14	 movsx	 edx, WORD PTR [ecx+20]
  0056d	52		 push	 edx
  0056e	8b 45 0c	 mov	 eax, DWORD PTR _sec2$[ebp]
  00571	50		 push	 eax
  00572	e8 00 00 00 00	 call	 _P_AddFloatThinker
  00577	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4465 : 		CheckForFloatBob = true;

  0057a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CheckForFloatBob, 1
$LN37@P_AddFakeF:

; 4466 : 	}
; 4467 : 
; 4468 : 	P_AddFFloor(sec, ffloor);

  00584	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00587	50		 push	 eax
  00588	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  0058b	51		 push	 ecx
  0058c	e8 00 00 00 00	 call	 _P_AddFFloor
  00591	83 c4 08	 add	 esp, 8

; 4469 : 
; 4470 : 	return ffloor;

  00594	8b 45 fc	 mov	 eax, DWORD PTR _ffloor$[ebp]
$LN1@P_AddFakeF:

; 4471 : }

  00597	5f		 pop	 edi
  00598	5e		 pop	 esi
  00599	5b		 pop	 ebx
  0059a	8b e5		 mov	 esp, ebp
  0059c	5d		 pop	 ebp
  0059d	c3		 ret	 0
_P_AddFakeFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddFFloor
_TEXT	SEGMENT
_rover$ = -4						; size = 4
_sec$ = 8						; size = 4
_ffloor$ = 12						; size = 4
_P_AddFFloor PROC					; COMDAT

; 4302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4303 : 	ffloor_t *rover;
; 4304 : 
; 4305 : 	if (!sec->ffloors)

  00009	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0000c	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00013	75 22		 jne	 SHORT $LN5@P_AddFFloo

; 4306 : 	{
; 4307 : 		sec->ffloors = ffloor;

  00015	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  0001b	89 88 90 00 00
	00		 mov	 DWORD PTR [eax+144], ecx

; 4308 : 		ffloor->next = 0;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00024	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 4309 : 		ffloor->prev = 0;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _ffloor$[ebp]
  0002e	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 4310 : 		return;

  00035	eb 3e		 jmp	 SHORT $LN1@P_AddFFloo
$LN5@P_AddFFloo:

; 4311 : 	}
; 4312 : 
; 4313 : 	for (rover = sec->ffloors; rover->next; rover = rover->next);

  00037	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0003a	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00040	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
  00043	eb 09		 jmp	 SHORT $LN4@P_AddFFloo
$LN2@P_AddFFloo:
  00045	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00048	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0004b	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
$LN4@P_AddFFloo:
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00051	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00055	74 02		 je	 SHORT $LN3@P_AddFFloo
  00057	eb ec		 jmp	 SHORT $LN2@P_AddFFloo
$LN3@P_AddFFloo:

; 4314 : 
; 4315 : 	rover->next = ffloor;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  0005f	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 4316 : 	ffloor->prev = rover;

  00062	8b 45 0c	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _rover$[ebp]
  00068	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 4317 : 	ffloor->next = 0;

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _ffloor$[ebp]
  0006e	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0
$LN1@P_AddFFloo:

; 4318 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_AddFFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_RunSpecialSectorCheck
_TEXT	SEGMENT
tv75 = -72						; size = 4
tv82 = -72						; size = 4
tv89 = -72						; size = 4
_nofloorneeded$ = -4					; size = 4
_player$ = 8						; size = 4
_sector$ = 12						; size = 4
_P_RunSpecialSectorCheck PROC				; COMDAT

; 4039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4040 : 	boolean nofloorneeded = false;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nofloorneeded$[ebp], 0

; 4041 : 
; 4042 : 	if (!sector->special) // nothing special, exit

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00013	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00017	85 c9		 test	 ecx, ecx
  00019	75 05		 jne	 SHORT $LN8@P_RunSpeci

; 4043 : 		return;

  0001b	e9 a3 01 00 00	 jmp	 $LN1@P_RunSpeci
$LN8@P_RunSpeci:

; 4044 : 
; 4045 : 	if (GETSECSPECIAL(sector->special, 2) == 9) // Egg trap capsule -- should only be for 3dFloors!

  00020	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00023	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00027	c1 f9 04	 sar	 ecx, 4
  0002a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0002d	83 f9 09	 cmp	 ecx, 9
  00030	75 05		 jne	 SHORT $LN9@P_RunSpeci

; 4046 : 		return;

  00032	e9 8c 01 00 00	 jmp	 $LN1@P_RunSpeci
$LN9@P_RunSpeci:

; 4047 : 
; 4048 : 	// The list of specials that activate without floor touch
; 4049 : 	// Check Section 1
; 4050 : 	switch(GETSECSPECIAL(sector->special, 1))

  00037	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0003a	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0003e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00041	89 4d b8	 mov	 DWORD PTR tv75[ebp], ecx
  00044	8b 55 b8	 mov	 edx, DWORD PTR tv75[ebp]
  00047	83 ea 02	 sub	 edx, 2
  0004a	89 55 b8	 mov	 DWORD PTR tv75[ebp], edx
  0004d	83 7d b8 0a	 cmp	 DWORD PTR tv75[ebp], 10	; 0000000aH
  00051	77 18		 ja	 SHORT $LN2@P_RunSpeci
  00053	8b 45 b8	 mov	 eax, DWORD PTR tv75[ebp]
  00056	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN31@P_RunSpeci[eax]
  0005d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN32@P_RunSpeci[ecx*4]
$LN10@P_RunSpeci:

; 4051 : 	{
; 4052 : 		case 2: // Damage (water)
; 4053 : 		case 8: // Instant kill
; 4054 : 		case 10: // Ring drainer that doesn't require floor touch
; 4055 : 		case 12: // Space countdown
; 4056 : 			nofloorneeded = true;

  00064	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _nofloorneeded$[ebp], 1
$LN2@P_RunSpeci:

; 4057 : 			break;
; 4058 : 	}
; 4059 : 
; 4060 : 	// Check Section 2
; 4061 : 	switch(GETSECSPECIAL(sector->special, 2))

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0006e	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00072	c1 f9 04	 sar	 ecx, 4
  00075	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00078	89 4d b8	 mov	 DWORD PTR tv82[ebp], ecx
  0007b	8b 55 b8	 mov	 edx, DWORD PTR tv82[ebp]
  0007e	83 ea 02	 sub	 edx, 2
  00081	89 55 b8	 mov	 DWORD PTR tv82[ebp], edx
  00084	83 7d b8 05	 cmp	 DWORD PTR tv82[ebp], 5
  00088	77 11		 ja	 SHORT $LN4@P_RunSpeci
  0008a	8b 45 b8	 mov	 eax, DWORD PTR tv82[ebp]
  0008d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN33@P_RunSpeci[eax*4]
$LN14@P_RunSpeci:

; 4062 : 	{
; 4063 : 		case 2: // Linedef executor (All players needed)
; 4064 : 		case 4: // Linedef executor
; 4065 : 		case 6: // Linedef executor (7 Emeralds)
; 4066 : 		case 7: // Linedef executor (NiGHTS Mare)
; 4067 : 			nofloorneeded = true;

  00094	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _nofloorneeded$[ebp], 1
$LN4@P_RunSpeci:

; 4068 : 			break;
; 4069 : 	}
; 4070 : 
; 4071 : 	// Check Section 3
; 4072 : /*	switch(GETSECSPECIAL(sector->special, 3))
; 4073 : 	{
; 4074 : 
; 4075 : 	}*/
; 4076 : 
; 4077 : 	// Check Section 4
; 4078 : 	switch(GETSECSPECIAL(sector->special, 4))

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0009e	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  000a2	c1 f9 0c	 sar	 ecx, 12			; 0000000cH
  000a5	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000a8	89 4d b8	 mov	 DWORD PTR tv89[ebp], ecx
  000ab	8b 55 b8	 mov	 edx, DWORD PTR tv89[ebp]
  000ae	83 ea 01	 sub	 edx, 1
  000b1	89 55 b8	 mov	 DWORD PTR tv89[ebp], edx
  000b4	83 7d b8 09	 cmp	 DWORD PTR tv89[ebp], 9
  000b8	77 40		 ja	 SHORT $LN6@P_RunSpeci
  000ba	8b 45 b8	 mov	 eax, DWORD PTR tv89[ebp]
  000bd	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@P_RunSpeci[eax*4]
$LN18@P_RunSpeci:

; 4079 : 	{
; 4080 : 		case 2: // Level Exit / GOAL Sector / Flag Return
; 4081 : 			if (!useNightsSS && gamemap >= sstage_start && gamemap <= sstage_end)

  000c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _useNightsSS, 0
  000cb	75 26		 jne	 SHORT $LN19@P_RunSpeci
  000cd	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000d4	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _sstage_start
  000db	3b c1		 cmp	 eax, ecx
  000dd	7c 14		 jl	 SHORT $LN19@P_RunSpeci
  000df	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000e6	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _sstage_end
  000ed	3b c1		 cmp	 eax, ecx
  000ef	7f 02		 jg	 SHORT $LN19@P_RunSpeci

; 4082 : 			{
; 4083 : 				// Special stage GOAL sector
; 4084 : 				// requires touching floor.
; 4085 : 				break;

  000f1	eb 07		 jmp	 SHORT $LN6@P_RunSpeci
$LN19@P_RunSpeci:

; 4086 : 			}
; 4087 : 		case 1: // Starpost activator
; 4088 : 		case 5: // Fan sector
; 4089 : 		case 6: // Super Sonic Transform
; 4090 : 		case 8: // Zoom Tube Start
; 4091 : 		case 9: // Zoom Tube End
; 4092 : 		case 10: // Finish line
; 4093 : 			nofloorneeded = true;

  000f3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _nofloorneeded$[ebp], 1
$LN6@P_RunSpeci:

; 4094 : 			break;
; 4095 : 	}
; 4096 : 
; 4097 : 	if (nofloorneeded)

  000fa	83 7d fc 00	 cmp	 DWORD PTR _nofloorneeded$[ebp], 0
  000fe	74 17		 je	 SHORT $LN26@P_RunSpeci

; 4098 : 	{
; 4099 : 		P_ProcessSpecialSector(player, sector, NULL);

  00100	6a 00		 push	 0
  00102	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00105	50		 push	 eax
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 _P_ProcessSpecialSector
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4100 : 		return;

  00112	e9 ac 00 00 00	 jmp	 $LN1@P_RunSpeci
$LN26@P_RunSpeci:

; 4101 : 	}
; 4102 : 
; 4103 : 	// Only go further if on the ground
; 4104 : 	if ((sector->flags & SF_FLIPSPECIAL_FLOOR) && !(sector->flags & SF_FLIPSPECIAL_CEILING) && player->mo->z != sector->floorheight)

  00117	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0011a	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00120	83 e1 01	 and	 ecx, 1
  00123	74 1f		 je	 SHORT $LN27@P_RunSpeci
  00125	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00128	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0012e	83 e1 02	 and	 ecx, 2
  00131	75 11		 jne	 SHORT $LN27@P_RunSpeci
  00133	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00136	8b 08		 mov	 ecx, DWORD PTR [eax]
  00138	8b 55 0c	 mov	 edx, DWORD PTR _sector$[ebp]
  0013b	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0013e	3b 02		 cmp	 eax, DWORD PTR [edx]
  00140	74 02		 je	 SHORT $LN27@P_RunSpeci

; 4105 : 		return;

  00142	eb 7f		 jmp	 SHORT $LN1@P_RunSpeci
$LN27@P_RunSpeci:

; 4106 : 
; 4107 : 	if ((sector->flags & SF_FLIPSPECIAL_CEILING) && !(sector->flags & SF_FLIPSPECIAL_FLOOR) && player->mo->z + player->mo->height != sector->ceilingheight)

  00144	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00147	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0014d	83 e1 02	 and	 ecx, 2
  00150	74 28		 je	 SHORT $LN28@P_RunSpeci
  00152	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00155	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0015b	83 e1 01	 and	 ecx, 1
  0015e	75 1a		 jne	 SHORT $LN28@P_RunSpeci
  00160	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00163	8b 08		 mov	 ecx, DWORD PTR [eax]
  00165	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00168	8b 02		 mov	 eax, DWORD PTR [edx]
  0016a	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0016d	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00170	8b 55 0c	 mov	 edx, DWORD PTR _sector$[ebp]
  00173	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00176	74 02		 je	 SHORT $LN28@P_RunSpeci

; 4108 : 		return;

  00178	eb 49		 jmp	 SHORT $LN1@P_RunSpeci
$LN28@P_RunSpeci:

; 4109 : 
; 4110 : 	if ((sector->flags & SF_FLIPSPECIAL_BOTH)
; 4111 : 		&& player->mo->z != sector->floorheight
; 4112 : 		&& player->mo->z + player->mo->height != sector->ceilingheight)

  0017a	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0017d	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00183	83 e1 03	 and	 ecx, 3
  00186	74 29		 je	 SHORT $LN29@P_RunSpeci
  00188	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0018b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018d	8b 55 0c	 mov	 edx, DWORD PTR _sector$[ebp]
  00190	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00193	3b 02		 cmp	 eax, DWORD PTR [edx]
  00195	74 1a		 je	 SHORT $LN29@P_RunSpeci
  00197	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0019a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0019f	8b 02		 mov	 eax, DWORD PTR [edx]
  001a1	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  001a4	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  001a7	8b 55 0c	 mov	 edx, DWORD PTR _sector$[ebp]
  001aa	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  001ad	74 02		 je	 SHORT $LN29@P_RunSpeci

; 4113 : 		return;

  001af	eb 12		 jmp	 SHORT $LN1@P_RunSpeci
$LN29@P_RunSpeci:

; 4114 : 
; 4115 : 	P_ProcessSpecialSector(player, sector, NULL);

  001b1	6a 00		 push	 0
  001b3	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  001b6	50		 push	 eax
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _P_ProcessSpecialSector
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@P_RunSpeci:

; 4116 : }

  001c3	5f		 pop	 edi
  001c4	5e		 pop	 esi
  001c5	5b		 pop	 ebx
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
  001ca	66 90		 npad	 2
$LN32@P_RunSpeci:
  001cc	00 00 00 00	 DD	 $LN10@P_RunSpeci
  001d0	00 00 00 00	 DD	 $LN2@P_RunSpeci
$LN31@P_RunSpeci:
  001d4	00		 DB	 0
  001d5	01		 DB	 1
  001d6	01		 DB	 1
  001d7	01		 DB	 1
  001d8	01		 DB	 1
  001d9	01		 DB	 1
  001da	00		 DB	 0
  001db	01		 DB	 1
  001dc	00		 DB	 0
  001dd	01		 DB	 1
  001de	00		 DB	 0
  001df	90		 npad	 1
$LN33@P_RunSpeci:
  001e0	00 00 00 00	 DD	 $LN14@P_RunSpeci
  001e4	00 00 00 00	 DD	 $LN4@P_RunSpeci
  001e8	00 00 00 00	 DD	 $LN14@P_RunSpeci
  001ec	00 00 00 00	 DD	 $LN4@P_RunSpeci
  001f0	00 00 00 00	 DD	 $LN14@P_RunSpeci
  001f4	00 00 00 00	 DD	 $LN14@P_RunSpeci
$LN34@P_RunSpeci:
  001f8	00 00 00 00	 DD	 $LN19@P_RunSpeci
  001fc	00 00 00 00	 DD	 $LN18@P_RunSpeci
  00200	00 00 00 00	 DD	 $LN6@P_RunSpeci
  00204	00 00 00 00	 DD	 $LN6@P_RunSpeci
  00208	00 00 00 00	 DD	 $LN19@P_RunSpeci
  0020c	00 00 00 00	 DD	 $LN19@P_RunSpeci
  00210	00 00 00 00	 DD	 $LN6@P_RunSpeci
  00214	00 00 00 00	 DD	 $LN19@P_RunSpeci
  00218	00 00 00 00	 DD	 $LN19@P_RunSpeci
  0021c	00 00 00 00	 DD	 $LN19@P_RunSpeci
_P_RunSpecialSectorCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_PlayerOnSpecial3DFloor
_TEXT	SEGMENT
_inside$1 = -20						; size = 4
_touching$2 = -16					; size = 4
_polysec$3 = -12					; size = 4
_po$4 = -8						; size = 4
_rover$ = -4						; size = 4
_player$ = 8						; size = 4
_sector$ = 12						; size = 4
_P_PlayerOnSpecial3DFloor PROC				; COMDAT

; 3893 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3894 : 	ffloor_t *rover;
; 3895 : 
; 3896 : 	for (rover = sector->ffloors; rover; rover = rover->next)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0000c	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00012	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
  00015	eb 09		 jmp	 SHORT $LN4@P_PlayerOn
$LN2@P_PlayerOn:
  00017	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0001a	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001d	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
$LN4@P_PlayerOn:
  00020	83 7d fc 00	 cmp	 DWORD PTR _rover$[ebp], 0
  00024	0f 84 b3 01 00
	00		 je	 $LN3@P_PlayerOn

; 3897 : 	{
; 3898 : 		if (!rover->master->frontsector->special)

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0002d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00030	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00033	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  00037	85 c0		 test	 eax, eax
  00039	75 02		 jne	 SHORT $LN7@P_PlayerOn

; 3899 : 			continue;

  0003b	eb da		 jmp	 SHORT $LN2@P_PlayerOn
$LN7@P_PlayerOn:

; 3900 : 
; 3901 : 		if (!(rover->flags & FF_EXISTS))

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00040	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00043	83 e1 01	 and	 ecx, 1
  00046	75 02		 jne	 SHORT $LN8@P_PlayerOn

; 3902 : 			continue;

  00048	eb cd		 jmp	 SHORT $LN2@P_PlayerOn
$LN8@P_PlayerOn:

; 3903 : 
; 3904 : 		// Check the 3D floor's type...
; 3905 : 		if (rover->flags & FF_BLOCKPLAYER)

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0004d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00050	83 e1 02	 and	 ecx, 2
  00053	0f 84 12 01 00
	00		 je	 $LN9@P_PlayerOn

; 3906 : 		{
; 3907 : 			// Thing must be on top of the floor to be affected...
; 3908 : 			if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR)
; 3909 : 				&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING))

  00059	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0005c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005f	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00062	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00068	83 e0 01	 and	 eax, 1
  0006b	74 3f		 je	 SHORT $LN11@P_PlayerOn
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00070	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00073	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00076	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  0007c	83 e0 02	 and	 eax, 2
  0007f	75 2b		 jne	 SHORT $LN11@P_PlayerOn

; 3910 : 			{
; 3911 : 				if ((player->mo->eflags & MFE_VERTICALFLIP) || player->mo->z != *rover->topheight)

  00081	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0008c	83 e2 20	 and	 edx, 32			; 00000020H
  0008f	75 11		 jne	 SHORT $LN14@P_PlayerOn
  00091	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	8b 55 fc	 mov	 edx, DWORD PTR _rover$[ebp]
  00099	8b 02		 mov	 eax, DWORD PTR [edx]
  0009b	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0009e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a0	74 05		 je	 SHORT $LN13@P_PlayerOn
$LN14@P_PlayerOn:

; 3912 : 					continue;

  000a2	e9 70 ff ff ff	 jmp	 $LN2@P_PlayerOn
$LN13@P_PlayerOn:

; 3913 : 			}

  000a7	e9 bd 00 00 00	 jmp	 $LN20@P_PlayerOn
$LN11@P_PlayerOn:

; 3914 : 			else if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING)
; 3915 : 				&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR))

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  000af	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b2	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000b5	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000bb	83 e0 02	 and	 eax, 2
  000be	74 45		 je	 SHORT $LN15@P_PlayerOn
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  000c3	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000c6	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000c9	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000cf	83 e0 01	 and	 eax, 1
  000d2	75 31		 jne	 SHORT $LN15@P_PlayerOn

; 3916 : 			{
; 3917 : 				if (!(player->mo->eflags & MFE_VERTICALFLIP)
; 3918 : 					|| player->mo->z + player->mo->height != *rover->bottomheight)

  000d4	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  000df	83 e2 20	 and	 edx, 32			; 00000020H
  000e2	74 1a		 je	 SHORT $LN18@P_PlayerOn
  000e4	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  000ec	8b 02		 mov	 eax, DWORD PTR [edx]
  000ee	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  000f1	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  000f4	8b 55 fc	 mov	 edx, DWORD PTR _rover$[ebp]
  000f7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000fa	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000fc	74 05		 je	 SHORT $LN17@P_PlayerOn
$LN18@P_PlayerOn:

; 3919 : 					continue;

  000fe	e9 14 ff ff ff	 jmp	 $LN2@P_PlayerOn
$LN17@P_PlayerOn:

; 3920 : 			}

  00103	eb 64		 jmp	 SHORT $LN20@P_PlayerOn
$LN15@P_PlayerOn:

; 3921 : 			else if (rover->master->frontsector->flags & SF_FLIPSPECIAL_BOTH)

  00105	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00108	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0010b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0010e	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00114	83 e0 03	 and	 eax, 3
  00117	74 50		 je	 SHORT $LN20@P_PlayerOn

; 3922 : 			{
; 3923 : 				if (!((player->mo->eflags & MFE_VERTICALFLIP && player->mo->z + player->mo->height == *rover->bottomheight)

  00119	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0011c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011e	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00124	83 e2 20	 and	 edx, 32			; 00000020H
  00127	74 1a		 je	 SHORT $LN21@P_PlayerOn
  00129	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0012c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012e	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00131	8b 02		 mov	 eax, DWORD PTR [edx]
  00133	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00136	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00139	8b 55 fc	 mov	 edx, DWORD PTR _rover$[ebp]
  0013c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0013f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00141	74 26		 je	 SHORT $LN20@P_PlayerOn
$LN21@P_PlayerOn:
  00143	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00146	8b 08		 mov	 ecx, DWORD PTR [eax]
  00148	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0014e	83 e2 20	 and	 edx, 32			; 00000020H
  00151	75 11		 jne	 SHORT $LN22@P_PlayerOn
  00153	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00156	8b 08		 mov	 ecx, DWORD PTR [eax]
  00158	8b 55 fc	 mov	 edx, DWORD PTR _rover$[ebp]
  0015b	8b 02		 mov	 eax, DWORD PTR [edx]
  0015d	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00160	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00162	74 05		 je	 SHORT $LN20@P_PlayerOn
$LN22@P_PlayerOn:

; 3924 : 					|| (!(player->mo->eflags & MFE_VERTICALFLIP) && player->mo->z == *rover->topheight)))
; 3925 : 					continue;

  00164	e9 ae fe ff ff	 jmp	 $LN2@P_PlayerOn
$LN20@P_PlayerOn:

; 3926 : 			}
; 3927 : 		}

  00169	eb 30		 jmp	 SHORT $LN23@P_PlayerOn
$LN9@P_PlayerOn:

; 3928 : 		else
; 3929 : 		{
; 3930 : 			// Water and DEATH FOG!!! heh
; 3931 : 			if (player->mo->z > *rover->topheight || (player->mo->z + player->mo->height) < *rover->bottomheight)

  0016b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0016e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00170	8b 55 fc	 mov	 edx, DWORD PTR _rover$[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00178	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0017a	7f 1a		 jg	 SHORT $LN24@P_PlayerOn
  0017c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00184	8b 02		 mov	 eax, DWORD PTR [edx]
  00186	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00189	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  0018c	8b 55 fc	 mov	 edx, DWORD PTR _rover$[ebp]
  0018f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00192	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00194	7d 05		 jge	 SHORT $LN23@P_PlayerOn
$LN24@P_PlayerOn:

; 3932 : 				continue;

  00196	e9 7c fe ff ff	 jmp	 $LN2@P_PlayerOn
$LN23@P_PlayerOn:

; 3933 : 		}
; 3934 : 
; 3935 : 		// This FOF has the special we're looking for, but are we allowed to touch it?
; 3936 : 		if (sector == player->mo->subsector->sector
; 3937 : 			|| (rover->master->frontsector->flags & SF_TRIGGERSPECIAL_TOUCH))

  0019b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0019e	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  001a6	3b 02		 cmp	 eax, DWORD PTR [edx]
  001a8	74 14		 je	 SHORT $LN26@P_PlayerOn
  001aa	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001ad	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001b0	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001b3	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  001b9	83 e0 04	 and	 eax, 4
  001bc	74 1a		 je	 SHORT $LN25@P_PlayerOn
$LN26@P_PlayerOn:

; 3938 : 			P_ProcessSpecialSector(player, rover->master->frontsector, sector);

  001be	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  001c1	50		 push	 eax
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _rover$[ebp]
  001c5	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001c8	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  001cb	50		 push	 eax
  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  001cf	51		 push	 ecx
  001d0	e8 00 00 00 00	 call	 _P_ProcessSpecialSector
  001d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@P_PlayerOn:

; 3939 : 	}

  001d8	e9 3a fe ff ff	 jmp	 $LN2@P_PlayerOn
$LN3@P_PlayerOn:

; 3940 : 
; 3941 : 	// Allow sector specials to be applied to polyobjects!
; 3942 : 	if (player->mo->subsector->polyList)

  001dd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  001e5	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  001e9	0f 84 48 02 00
	00		 je	 $LN6@P_PlayerOn

; 3943 : 	{
; 3944 : 		polyobj_t *po = player->mo->subsector->polyList;

  001ef	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f4	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  001f7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001fa	89 45 f8	 mov	 DWORD PTR _po$4[ebp], eax

; 3945 : 		sector_t *polysec;
; 3946 : 		boolean touching = false;

  001fd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _touching$2[ebp], 0

; 3947 : 		boolean inside = false;

  00204	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _inside$1[ebp], 0
$LN58@P_PlayerOn:

; 3948 : 
; 3949 : 		while(po)

  0020b	83 7d f8 00	 cmp	 DWORD PTR _po$4[ebp], 0
  0020f	0f 84 22 02 00
	00		 je	 $LN6@P_PlayerOn

; 3950 : 		{
; 3951 : 			if (po->flags & POF_NOSPECIALS)

  00215	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  00218	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0021e	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00224	74 0a		 je	 SHORT $LN28@P_PlayerOn

; 3952 : 			{
; 3953 : 				po = (polyobj_t *)(po->link.next);

  00226	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  00229	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022b	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 3954 : 				continue;

  0022e	eb db		 jmp	 SHORT $LN58@P_PlayerOn
$LN28@P_PlayerOn:

; 3955 : 			}
; 3956 : 
; 3957 : 			polysec = po->lines[0]->backsector;

  00230	b8 04 00 00 00	 mov	 eax, 4
  00235	6b c8 00	 imul	 ecx, eax, 0
  00238	8b 55 f8	 mov	 edx, DWORD PTR _po$4[ebp]
  0023b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0023e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00241	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00244	89 55 f4	 mov	 DWORD PTR _polysec$3[ebp], edx

; 3958 : 
; 3959 : 			if ((polysec->flags & SF_TRIGGERSPECIAL_TOUCH))

  00247	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  0024a	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00250	83 e1 04	 and	 ecx, 4
  00253	74 17		 je	 SHORT $LN29@P_PlayerOn

; 3960 : 				touching = P_MobjTouchingPolyobj(po, player->mo);

  00255	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00258	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025a	51		 push	 ecx
  0025b	8b 55 f8	 mov	 edx, DWORD PTR _po$4[ebp]
  0025e	52		 push	 edx
  0025f	e8 00 00 00 00	 call	 _P_MobjTouchingPolyobj
  00264	83 c4 08	 add	 esp, 8
  00267	89 45 f0	 mov	 DWORD PTR _touching$2[ebp], eax
  0026a	eb 07		 jmp	 SHORT $LN30@P_PlayerOn
$LN29@P_PlayerOn:

; 3961 : 			else
; 3962 : 				touching = false;

  0026c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _touching$2[ebp], 0
$LN30@P_PlayerOn:

; 3963 : 
; 3964 : 			inside = P_MobjInsidePolyobj(po, player->mo);

  00273	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00276	8b 08		 mov	 ecx, DWORD PTR [eax]
  00278	51		 push	 ecx
  00279	8b 55 f8	 mov	 edx, DWORD PTR _po$4[ebp]
  0027c	52		 push	 edx
  0027d	e8 00 00 00 00	 call	 _P_MobjInsidePolyobj
  00282	83 c4 08	 add	 esp, 8
  00285	89 45 ec	 mov	 DWORD PTR _inside$1[ebp], eax

; 3965 : 
; 3966 : 			if (!(inside || touching))

  00288	83 7d ec 00	 cmp	 DWORD PTR _inside$1[ebp], 0
  0028c	75 13		 jne	 SHORT $LN31@P_PlayerOn
  0028e	83 7d f0 00	 cmp	 DWORD PTR _touching$2[ebp], 0
  00292	75 0d		 jne	 SHORT $LN31@P_PlayerOn

; 3967 : 			{
; 3968 : 				po = (polyobj_t *)(po->link.next);

  00294	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  00297	8b 08		 mov	 ecx, DWORD PTR [eax]
  00299	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 3969 : 				continue;

  0029c	e9 6a ff ff ff	 jmp	 $LN58@P_PlayerOn
$LN31@P_PlayerOn:

; 3970 : 			}
; 3971 : 
; 3972 : 			// We're inside it! Yess...
; 3973 : 			if (!polysec->special)

  002a1	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  002a4	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  002a8	85 c9		 test	 ecx, ecx
  002aa	75 0d		 jne	 SHORT $LN32@P_PlayerOn

; 3974 : 			{
; 3975 : 				po = (polyobj_t *)(po->link.next);

  002ac	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  002af	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b1	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 3976 : 				continue;

  002b4	e9 52 ff ff ff	 jmp	 $LN58@P_PlayerOn
$LN32@P_PlayerOn:

; 3977 : 			}
; 3978 : 
; 3979 : 			if (!(po->flags & POF_TESTHEIGHT)) // Don't do height checking

  002b9	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  002bc	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  002c2	83 e1 04	 and	 ecx, 4
  002c5	75 05		 jne	 SHORT $LN33@P_PlayerOn

; 3980 : 			{
; 3981 : 			}

  002c7	e9 4a 01 00 00	 jmp	 $LN49@P_PlayerOn
$LN33@P_PlayerOn:

; 3982 : 			else if (po->flags & POF_SOLID)

  002cc	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  002cf	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  002d5	83 e1 03	 and	 ecx, 3
  002d8	0f 84 04 01 00
	00		 je	 $LN35@P_PlayerOn

; 3983 : 			{
; 3984 : 				// Thing must be on top of the floor to be affected...
; 3985 : 				if ((polysec->flags & SF_FLIPSPECIAL_FLOOR)
; 3986 : 					&& !(polysec->flags & SF_FLIPSPECIAL_CEILING))

  002de	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  002e1	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  002e7	83 e1 01	 and	 ecx, 1
  002ea	74 40		 je	 SHORT $LN37@P_PlayerOn
  002ec	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  002ef	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  002f5	83 e1 02	 and	 ecx, 2
  002f8	75 32		 jne	 SHORT $LN37@P_PlayerOn

; 3987 : 				{
; 3988 : 					if ((player->mo->eflags & MFE_VERTICALFLIP) || player->mo->z != polysec->ceilingheight)

  002fa	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  002fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ff	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00305	83 e2 20	 and	 edx, 32			; 00000020H
  00308	75 10		 jne	 SHORT $LN40@P_PlayerOn
  0030a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0030d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030f	8b 55 f4	 mov	 edx, DWORD PTR _polysec$3[ebp]
  00312	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00315	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00318	74 0d		 je	 SHORT $LN39@P_PlayerOn
$LN40@P_PlayerOn:

; 3989 : 					{
; 3990 : 						po = (polyobj_t *)(po->link.next);

  0031a	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  0031d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031f	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 3991 : 						continue;

  00322	e9 e4 fe ff ff	 jmp	 $LN58@P_PlayerOn
$LN39@P_PlayerOn:

; 3992 : 					}
; 3993 : 				}

  00327	e9 b4 00 00 00	 jmp	 $LN46@P_PlayerOn
$LN37@P_PlayerOn:

; 3994 : 				else if ((polysec->flags & SF_FLIPSPECIAL_CEILING)
; 3995 : 					&& !(polysec->flags & SF_FLIPSPECIAL_FLOOR))

  0032c	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  0032f	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00335	83 e1 02	 and	 ecx, 2
  00338	74 44		 je	 SHORT $LN41@P_PlayerOn
  0033a	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  0033d	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00343	83 e1 01	 and	 ecx, 1
  00346	75 36		 jne	 SHORT $LN41@P_PlayerOn

; 3996 : 				{
; 3997 : 					if (!(player->mo->eflags & MFE_VERTICALFLIP)
; 3998 : 						|| player->mo->z + player->mo->height != polysec->floorheight)

  00348	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0034b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034d	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00353	83 e2 20	 and	 edx, 32			; 00000020H
  00356	74 17		 je	 SHORT $LN44@P_PlayerOn
  00358	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0035b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035d	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00360	8b 02		 mov	 eax, DWORD PTR [edx]
  00362	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00365	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00368	8b 55 f4	 mov	 edx, DWORD PTR _polysec$3[ebp]
  0036b	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0036d	74 0d		 je	 SHORT $LN43@P_PlayerOn
$LN44@P_PlayerOn:

; 3999 : 					{
; 4000 : 						po = (polyobj_t *)(po->link.next);

  0036f	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  00372	8b 08		 mov	 ecx, DWORD PTR [eax]
  00374	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 4001 : 						continue;

  00377	e9 8f fe ff ff	 jmp	 $LN58@P_PlayerOn
$LN43@P_PlayerOn:

; 4002 : 					}
; 4003 : 				}

  0037c	eb 62		 jmp	 SHORT $LN46@P_PlayerOn
$LN41@P_PlayerOn:

; 4004 : 				else if (polysec->flags & SF_FLIPSPECIAL_BOTH)

  0037e	8b 45 f4	 mov	 eax, DWORD PTR _polysec$3[ebp]
  00381	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00387	83 e1 03	 and	 ecx, 3
  0038a	74 54		 je	 SHORT $LN46@P_PlayerOn

; 4005 : 				{
; 4006 : 					if (!((player->mo->eflags & MFE_VERTICALFLIP && player->mo->z + player->mo->height == polysec->floorheight)

  0038c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0038f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00391	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00397	83 e2 20	 and	 edx, 32			; 00000020H
  0039a	74 17		 je	 SHORT $LN47@P_PlayerOn
  0039c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0039f	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a1	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  003a4	8b 02		 mov	 eax, DWORD PTR [edx]
  003a6	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003a9	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  003ac	8b 55 f4	 mov	 edx, DWORD PTR _polysec$3[ebp]
  003af	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  003b1	74 2d		 je	 SHORT $LN46@P_PlayerOn
$LN47@P_PlayerOn:
  003b3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b8	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  003be	83 e2 20	 and	 edx, 32			; 00000020H
  003c1	75 10		 jne	 SHORT $LN48@P_PlayerOn
  003c3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c8	8b 55 f4	 mov	 edx, DWORD PTR _polysec$3[ebp]
  003cb	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  003ce	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  003d1	74 0d		 je	 SHORT $LN46@P_PlayerOn
$LN48@P_PlayerOn:

; 4007 : 						|| (!(player->mo->eflags & MFE_VERTICALFLIP) && player->mo->z == polysec->ceilingheight)))
; 4008 : 					{
; 4009 : 						po = (polyobj_t *)(po->link.next);

  003d3	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  003d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d8	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 4010 : 						continue;

  003db	e9 2b fe ff ff	 jmp	 $LN58@P_PlayerOn
$LN46@P_PlayerOn:

; 4011 : 					}
; 4012 : 				}
; 4013 : 			}

  003e0	eb 34		 jmp	 SHORT $LN49@P_PlayerOn
$LN35@P_PlayerOn:

; 4014 : 			else
; 4015 : 			{
; 4016 : 				// Water and DEATH FOG!!! heh
; 4017 : 				if (player->mo->z > polysec->ceilingheight || (player->mo->z + player->mo->height) < polysec->floorheight)

  003e2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e7	8b 55 f4	 mov	 edx, DWORD PTR _polysec$3[ebp]
  003ea	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  003ed	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  003f0	7f 17		 jg	 SHORT $LN50@P_PlayerOn
  003f2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f7	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  003fa	8b 02		 mov	 eax, DWORD PTR [edx]
  003fc	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003ff	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00402	8b 55 f4	 mov	 edx, DWORD PTR _polysec$3[ebp]
  00405	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00407	7d 0d		 jge	 SHORT $LN49@P_PlayerOn
$LN50@P_PlayerOn:

; 4018 : 				{
; 4019 : 					po = (polyobj_t *)(po->link.next);

  00409	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  0040c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0040e	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 4020 : 					continue;

  00411	e9 f5 fd ff ff	 jmp	 $LN58@P_PlayerOn
$LN49@P_PlayerOn:

; 4021 : 				}
; 4022 : 			}
; 4023 : 
; 4024 : 			P_ProcessSpecialSector(player, polysec, sector);

  00416	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00419	50		 push	 eax
  0041a	8b 4d f4	 mov	 ecx, DWORD PTR _polysec$3[ebp]
  0041d	51		 push	 ecx
  0041e	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00421	52		 push	 edx
  00422	e8 00 00 00 00	 call	 _P_ProcessSpecialSector
  00427	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4025 : 
; 4026 : 			po = (polyobj_t *)(po->link.next);

  0042a	8b 45 f8	 mov	 eax, DWORD PTR _po$4[ebp]
  0042d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0042f	89 4d f8	 mov	 DWORD PTR _po$4[ebp], ecx

; 4027 : 		}

  00432	e9 d4 fd ff ff	 jmp	 $LN58@P_PlayerOn
$LN6@P_PlayerOn:

; 4028 : 	}
; 4029 : }

  00437	5f		 pop	 edi
  00438	5e		 pop	 esi
  00439	5b		 pop	 ebx
  0043a	8b e5		 mov	 esp, ebp
  0043c	5d		 pop	 ebp
  0043d	c3		 ret	 0
_P_PlayerOnSpecial3DFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_IsFlagAtBase
_TEXT	SEGMENT
_rover$1 = -16						; size = 4
_specialnum$ = -12					; size = 4
_mo$ = -8						; size = 4
_think$ = -4						; size = 4
_flag$ = 8						; size = 4
_P_IsFlagAtBase PROC					; COMDAT

; 2603 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2604 : 	thinker_t *think;
; 2605 : 	mobj_t *mo;
; 2606 : 	INT32 specialnum = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _specialnum$[ebp], 0

; 2607 : 
; 2608 : 	for (think = thinkercap.next; think != &thinkercap; think = think->next)

  00010	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00015	89 45 fc	 mov	 DWORD PTR _think$[ebp], eax
  00018	eb 09		 jmp	 SHORT $LN4@P_IsFlagAt
$LN2@P_IsFlagAt:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _think$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	89 4d fc	 mov	 DWORD PTR _think$[ebp], ecx
$LN4@P_IsFlagAt:
  00023	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _think$[ebp], OFFSET _thinkercap
  0002a	0f 84 f0 00 00
	00		 je	 $LN3@P_IsFlagAt

; 2609 : 	{
; 2610 : 		if (think->function.acp1 != (actionf_p1)P_MobjThinker)

  00030	8b 45 fc	 mov	 eax, DWORD PTR _think$[ebp]
  00033	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  0003a	74 02		 je	 SHORT $LN8@P_IsFlagAt

; 2611 : 			continue; // not a mobj thinker

  0003c	eb dc		 jmp	 SHORT $LN2@P_IsFlagAt
$LN8@P_IsFlagAt:

; 2612 : 
; 2613 : 		mo = (mobj_t *)think;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _think$[ebp]
  00041	89 45 f8	 mov	 DWORD PTR _mo$[ebp], eax

; 2614 : 
; 2615 : 		if (mo->type != flag)

  00044	8b 45 f8	 mov	 eax, DWORD PTR _mo$[ebp]
  00047	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0004a	3b 4d 08	 cmp	 ecx, DWORD PTR _flag$[ebp]
  0004d	74 02		 je	 SHORT $LN9@P_IsFlagAt

; 2616 : 			continue;

  0004f	eb c9		 jmp	 SHORT $LN2@P_IsFlagAt
$LN9@P_IsFlagAt:

; 2617 : 
; 2618 : 		if (mo->type == MT_REDFLAG)

  00051	8b 45 f8	 mov	 eax, DWORD PTR _mo$[ebp]
  00054	83 78 7c 34	 cmp	 DWORD PTR [eax+124], 52	; 00000034H
  00058	75 09		 jne	 SHORT $LN10@P_IsFlagAt

; 2619 : 			specialnum = 3;

  0005a	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _specialnum$[ebp], 3
  00061	eb 10		 jmp	 SHORT $LN12@P_IsFlagAt
$LN10@P_IsFlagAt:

; 2620 : 		else if (mo->type == MT_BLUEFLAG)

  00063	8b 45 f8	 mov	 eax, DWORD PTR _mo$[ebp]
  00066	83 78 7c 35	 cmp	 DWORD PTR [eax+124], 53	; 00000035H
  0006a	75 07		 jne	 SHORT $LN12@P_IsFlagAt

; 2621 : 			specialnum = 4;

  0006c	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _specialnum$[ebp], 4
$LN12@P_IsFlagAt:

; 2622 : 
; 2623 : 		if (GETSECSPECIAL(mo->subsector->sector->special, 4) == specialnum)

  00073	8b 45 f8	 mov	 eax, DWORD PTR _mo$[ebp]
  00076	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  0007f	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  00082	83 e0 0f	 and	 eax, 15			; 0000000fH
  00085	3b 45 f4	 cmp	 eax, DWORD PTR _specialnum$[ebp]
  00088	75 0f		 jne	 SHORT $LN13@P_IsFlagAt

; 2624 : 			return true;

  0008a	b8 01 00 00 00	 mov	 eax, 1
  0008f	e9 8e 00 00 00	 jmp	 $LN1@P_IsFlagAt
  00094	e9 82 00 00 00	 jmp	 $LN6@P_IsFlagAt
$LN13@P_IsFlagAt:

; 2625 : 		else if (mo->subsector->sector->ffloors) // Check the 3D floors

  00099	8b 45 f8	 mov	 eax, DWORD PTR _mo$[ebp]
  0009c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0009f	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a1	83 ba 90 00 00
	00 00		 cmp	 DWORD PTR [edx+144], 0
  000a8	74 71		 je	 SHORT $LN6@P_IsFlagAt

; 2626 : 		{
; 2627 : 			ffloor_t *rover;
; 2628 : 
; 2629 : 			for (rover = mo->subsector->sector->ffloors; rover; rover = rover->next)

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _mo$[ebp]
  000ad	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b2	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  000b8	89 45 f0	 mov	 DWORD PTR _rover$1[ebp], eax
  000bb	eb 09		 jmp	 SHORT $LN7@P_IsFlagAt
$LN5@P_IsFlagAt:
  000bd	8b 45 f0	 mov	 eax, DWORD PTR _rover$1[ebp]
  000c0	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000c3	89 4d f0	 mov	 DWORD PTR _rover$1[ebp], ecx
$LN7@P_IsFlagAt:
  000c6	83 7d f0 00	 cmp	 DWORD PTR _rover$1[ebp], 0
  000ca	74 4f		 je	 SHORT $LN6@P_IsFlagAt

; 2630 : 			{
; 2631 : 				if (!(rover->flags & FF_EXISTS))

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _rover$1[ebp]
  000cf	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d2	83 e1 01	 and	 ecx, 1
  000d5	75 02		 jne	 SHORT $LN16@P_IsFlagAt

; 2632 : 					continue;

  000d7	eb e4		 jmp	 SHORT $LN5@P_IsFlagAt
$LN16@P_IsFlagAt:

; 2633 : 
; 2634 : 				if (GETSECSPECIAL(rover->master->frontsector->special, 4) != specialnum)

  000d9	8b 45 f0	 mov	 eax, DWORD PTR _rover$1[ebp]
  000dc	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000df	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000e2	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  000e6	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  000e9	83 e0 0f	 and	 eax, 15			; 0000000fH
  000ec	3b 45 f4	 cmp	 eax, DWORD PTR _specialnum$[ebp]
  000ef	74 02		 je	 SHORT $LN17@P_IsFlagAt

; 2635 : 					continue;

  000f1	eb ca		 jmp	 SHORT $LN5@P_IsFlagAt
$LN17@P_IsFlagAt:

; 2636 : 
; 2637 : 				if (mo->z <= *rover->topheight
; 2638 : 					&& mo->z >= *rover->bottomheight)

  000f3	8b 45 f0	 mov	 eax, DWORD PTR _rover$1[ebp]
  000f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f8	8b 55 f8	 mov	 edx, DWORD PTR _mo$[ebp]
  000fb	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000fe	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00100	7f 17		 jg	 SHORT $LN18@P_IsFlagAt
  00102	8b 45 f0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00105	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00108	8b 55 f8	 mov	 edx, DWORD PTR _mo$[ebp]
  0010b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0010e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00110	7c 07		 jl	 SHORT $LN18@P_IsFlagAt

; 2639 : 					return true;

  00112	b8 01 00 00 00	 mov	 eax, 1
  00117	eb 09		 jmp	 SHORT $LN1@P_IsFlagAt
$LN18@P_IsFlagAt:

; 2640 : 			}

  00119	eb a2		 jmp	 SHORT $LN5@P_IsFlagAt
$LN6@P_IsFlagAt:

; 2641 : 		}
; 2642 : 	}

  0011b	e9 fa fe ff ff	 jmp	 $LN2@P_IsFlagAt
$LN3@P_IsFlagAt:

; 2643 : 	return false;

  00120	33 c0		 xor	 eax, eax
$LN1@P_IsFlagAt:

; 2644 : }

  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_P_IsFlagAtBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_GetObjectTypeInSectorNum
_TEXT	SEGMENT
_thing$ = -8						; size = 4
_sec$ = -4						; size = 4
_type$ = 8						; size = 4
_s$ = 12						; size = 4
_P_GetObjectTypeInSectorNum PROC			; COMDAT

; 1826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1827 : 	sector_t *sec = sectors + s;

  00009	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _s$[ebp], 248
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00016	89 45 fc	 mov	 DWORD PTR _sec$[ebp], eax

; 1828 : 	mobj_t *thing = sec->thinglist;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  0001c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001f	89 4d f8	 mov	 DWORD PTR _thing$[ebp], ecx
$LN2@P_GetObjec:

; 1829 : 
; 1830 : 	while (thing)

  00022	83 7d f8 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00026	74 1b		 je	 SHORT $LN3@P_GetObjec

; 1831 : 	{
; 1832 : 		if (thing->type == type)

  00028	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0002b	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0002e	3b 4d 08	 cmp	 ecx, DWORD PTR _type$[ebp]
  00031	75 05		 jne	 SHORT $LN4@P_GetObjec

; 1833 : 			return thing;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00036	eb 0d		 jmp	 SHORT $LN1@P_GetObjec
$LN4@P_GetObjec:

; 1834 : 		thing = thing->snext;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0003b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003e	89 4d f8	 mov	 DWORD PTR _thing$[ebp], ecx

; 1835 : 	}

  00041	eb df		 jmp	 SHORT $LN2@P_GetObjec
$LN3@P_GetObjec:

; 1836 : 	return NULL;

  00043	33 c0		 xor	 eax, eax
$LN1@P_GetObjec:

; 1837 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_P_GetObjectTypeInSectorNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddExecutorDelay
_TEXT	SEGMENT
_e$ = -4						; size = 4
_line$ = 8						; size = 4
_mobj$ = 12						; size = 4
_P_AddExecutorDelay PROC				; COMDAT

; 1285 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1286 : 	executor_t *e;
; 1287 : 
; 1288 : 	if (!line->backsector)

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00010	75 0d		 jne	 SHORT $LN2@P_AddExecu

; 1289 : 		I_Error("P_AddExecutorDelay: Line has no backsector!\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@JGFODBHM@P_AddExecutorDelay?3?5Line?5has?5no@
  00017	e8 00 00 00 00	 call	 _I_Error
  0001c	83 c4 04	 add	 esp, 4
$LN2@P_AddExecu:

; 1290 : 
; 1291 : 	e = Z_Calloc(sizeof (*e), PU_LEVSPEC, NULL);

  0001f	6a 00		 push	 0
  00021	6a 00		 push	 0
  00023	6a 33		 push	 51			; 00000033H
  00025	6a 1c		 push	 28			; 0000001cH
  00027	e8 00 00 00 00	 call	 _Z_CallocAlign
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	89 45 fc	 mov	 DWORD PTR _e$[ebp], eax

; 1292 : 
; 1293 : 	e->thinker.function.acp1 = (actionf_p1)T_ExecutorDelay;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _e$[ebp]
  00035	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_ExecutorDelay

; 1294 : 	e->line = line;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _e$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00042	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1295 : 	e->timer = (line->backsector->ceilingheight>>FRACBITS)+(line->backsector->floorheight>>FRACBITS);

  00045	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00048	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0004b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004e	c1 fa 10	 sar	 edx, 16			; 00000010H
  00051	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00054	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00057	8b 01		 mov	 eax, DWORD PTR [ecx]
  00059	c1 f8 10	 sar	 eax, 16			; 00000010H
  0005c	03 d0		 add	 edx, eax
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _e$[ebp]
  00061	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1296 : 	e->caller = mobj;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _e$[ebp]
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR _mobj$[ebp]
  0006a	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1297 : 	P_AddThinker(&e->thinker);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _e$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _P_AddThinker
  00076	83 c4 04	 add	 esp, 4

; 1298 : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_P_AddExecutorDelay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_InitTagLists
_TEXT	SEGMENT
_j$1 = -12						; size = 4
_j$2 = -8						; size = 4
_i$ = -4						; size = 4
_P_InitTagLists PROC					; COMDAT

; 1229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 : 	register size_t i;
; 1231 : 
; 1232 : 	for (i = numsectors - 1; i != (size_t)-1; i--)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsectors
  0000e	83 e8 01	 sub	 eax, 1
  00011	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00014	eb 09		 jmp	 SHORT $LN4@P_InitTagL
$LN2@P_InitTagL:
  00016	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00019	83 e8 01	 sub	 eax, 1
  0001c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_InitTagL:
  0001f	83 7d fc ff	 cmp	 DWORD PTR _i$[ebp], -1
  00023	74 55		 je	 SHORT $LN3@P_InitTagL

; 1233 : 	{
; 1234 : 		size_t j = (unsigned)sectors[i].tag % numsectors;

  00025	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00032	0f bf 44 01 14	 movsx	 eax, WORD PTR [ecx+eax+20]
  00037	33 d2		 xor	 edx, edx
  00039	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  0003f	89 55 f8	 mov	 DWORD PTR _j$2[ebp], edx

; 1235 : 		sectors[i].nexttag = sectors[j].firsttag;

  00042	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _j$2[ebp], 248
  00049	69 4d fc f8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 248
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00056	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  0005c	8b 44 06 1c	 mov	 eax, DWORD PTR [esi+eax+28]
  00060	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax

; 1236 : 		sectors[j].firsttag = (INT32)i;

  00064	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _j$2[ebp], 248
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00071	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00074	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1237 : 	}

  00078	eb 9c		 jmp	 SHORT $LN2@P_InitTagL
$LN3@P_InitTagL:

; 1238 : 
; 1239 : 	for (i = numlines - 1; i != (size_t)-1; i--)

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _numlines
  0007f	83 e8 01	 sub	 eax, 1
  00082	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00085	eb 09		 jmp	 SHORT $LN7@P_InitTagL
$LN5@P_InitTagL:
  00087	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	83 e8 01	 sub	 eax, 1
  0008d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_InitTagL:
  00090	83 7d fc ff	 cmp	 DWORD PTR _i$[ebp], -1
  00094	74 49		 je	 SHORT $LN6@P_InitTagL

; 1240 : 	{
; 1241 : 		size_t j = (unsigned)lines[i].tag % numlines;

  00096	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000a0	0f bf 44 01 14	 movsx	 eax, WORD PTR [ecx+eax+20]
  000a5	33 d2		 xor	 edx, edx
  000a7	f7 35 00 00 00
	00		 div	 DWORD PTR _numlines
  000ad	89 55 f4	 mov	 DWORD PTR _j$1[ebp], edx

; 1242 : 		lines[i].nexttag = lines[j].firsttag;

  000b0	6b 45 f4 4c	 imul	 eax, DWORD PTR _j$1[ebp], 76
  000b4	6b 4d fc 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  000b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  000be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _lines
  000c4	8b 44 06 40	 mov	 eax, DWORD PTR [esi+eax+64]
  000c8	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 1243 : 		lines[j].firsttag = (INT32)i;

  000cc	6b 45 f4 4c	 imul	 eax, DWORD PTR _j$1[ebp], 76
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d9	89 54 01 40	 mov	 DWORD PTR [ecx+eax+64], edx

; 1244 : 	}

  000dd	eb a8		 jmp	 SHORT $LN5@P_InitTagL
$LN6@P_InitTagL:

; 1245 : }

  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
_P_InitTagLists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyRotate
_TEXT	SEGMENT
tv88 = -92						; size = 4
tv95 = -92						; size = 4
_prd$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyRotate PROC					; COMDAT

; 1144 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1145 : 	polyrotdata_t prd;
; 1146 : 
; 1147 : 	prd.polyObjNum = line->tag;

  00013	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00016	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0001a	89 4d e8	 mov	 DWORD PTR _prd$[ebp], ecx

; 1148 : 	prd.speed      = sides[line->sidenum[0]].textureoffset >> FRACBITS; // angular speed

  0001d	b8 02 00 00 00	 mov	 eax, 2
  00022	6b c8 00	 imul	 ecx, eax, 0
  00025	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00028	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0002d	6b c8 1c	 imul	 ecx, eax, 28
  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00036	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00039	c1 f8 10	 sar	 eax, 16			; 00000010H
  0003c	89 45 f0	 mov	 DWORD PTR _prd$[ebp+8], eax

; 1149 : 	prd.distance   = sides[line->sidenum[0]].rowoffset >> FRACBITS; // angular distance

  0003f	b8 02 00 00 00	 mov	 eax, 2
  00044	6b c8 00	 imul	 ecx, eax, 0
  00047	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0004a	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0004f	6b c8 1c	 imul	 ecx, eax, 28
  00052	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00058	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0005c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0005f	89 45 f4	 mov	 DWORD PTR _prd$[ebp+12], eax

; 1150 : 
; 1151 : 	// Polyobj_(OR_)RotateRight have dir == -1
; 1152 : 	prd.direction = (line->special == 484 || line->special == 485) ? -1 : 1;

  00062	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00065	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00069	81 f9 e4 01 00
	00		 cmp	 ecx, 484		; 000001e4H
  0006f	74 17		 je	 SHORT $LN3@PolyRotate
  00071	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00074	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  00078	3d e5 01 00 00	 cmp	 eax, 485		; 000001e5H
  0007d	74 09		 je	 SHORT $LN3@PolyRotate
  0007f	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00086	eb 07		 jmp	 SHORT $LN4@PolyRotate
$LN3@PolyRotate:
  00088	c7 45 a4 ff ff
	ff ff		 mov	 DWORD PTR tv88[ebp], -1
$LN4@PolyRotate:
  0008f	8b 4d a4	 mov	 ecx, DWORD PTR tv88[ebp]
  00092	89 4d ec	 mov	 DWORD PTR _prd$[ebp+4], ecx

; 1153 : 
; 1154 : 	// Polyobj_OR types have override set to true
; 1155 : 	prd.overRide  = (line->special == 485 || line->special == 487);

  00095	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00098	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0009c	81 f9 e5 01 00
	00		 cmp	 ecx, 485		; 000001e5H
  000a2	74 17		 je	 SHORT $LN5@PolyRotate
  000a4	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  000a7	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  000ab	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  000b0	74 09		 je	 SHORT $LN5@PolyRotate
  000b2	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  000b9	eb 07		 jmp	 SHORT $LN6@PolyRotate
$LN5@PolyRotate:
  000bb	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
$LN6@PolyRotate:
  000c2	8a 4d a4	 mov	 cl, BYTE PTR tv95[ebp]
  000c5	88 4d f8	 mov	 BYTE PTR _prd$[ebp+16], cl

; 1156 : 
; 1157 : 	return EV_DoPolyObjRotate(&prd);

  000c8	8d 45 e8	 lea	 eax, DWORD PTR _prd$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _EV_DoPolyObjRotate
  000d1	83 c4 04	 add	 esp, 4

; 1158 : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_PolyRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyWaypoint
_TEXT	SEGMENT
tv86 = -88						; size = 4
tv92 = -88						; size = 4
tv130 = -88						; size = 4
tv136 = -88						; size = 4
_pwd$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyWaypoint PROC					; COMDAT

; 1124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1125 : 	polywaypointdata_t pwd;
; 1126 : 
; 1127 : 	pwd.polyObjNum = line->tag;

  00013	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00016	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0001a	89 4d ec	 mov	 DWORD PTR _pwd$[ebp], ecx

; 1128 : 	pwd.speed      = sides[line->sidenum[0]].textureoffset / 8;

  0001d	b8 02 00 00 00	 mov	 eax, 2
  00022	6b c8 00	 imul	 ecx, eax, 0
  00025	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00028	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0002d	6b c8 1c	 imul	 ecx, eax, 28
  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00036	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00039	99		 cdq
  0003a	83 e2 07	 and	 edx, 7
  0003d	03 c2		 add	 eax, edx
  0003f	c1 f8 03	 sar	 eax, 3
  00042	89 45 f4	 mov	 DWORD PTR _pwd$[ebp+8], eax

; 1129 : 	pwd.sequence   = sides[line->sidenum[0]].rowoffset >> FRACBITS; // Sequence #

  00045	b8 02 00 00 00	 mov	 eax, 2
  0004a	6b c8 00	 imul	 ecx, eax, 0
  0004d	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00050	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00055	6b c8 1c	 imul	 ecx, eax, 28
  00058	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0005e	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00062	c1 f8 10	 sar	 eax, 16			; 00000010H
  00065	89 45 f0	 mov	 DWORD PTR _pwd$[ebp+4], eax

; 1130 : 	pwd.reverse    = (line->flags & ML_EFFECT1) == ML_EFFECT1; // Reverse?

  00068	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0006b	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0006f	83 e1 20	 and	 ecx, 32			; 00000020H
  00072	74 09		 je	 SHORT $LN3@PolyWaypoi
  00074	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  0007b	eb 07		 jmp	 SHORT $LN4@PolyWaypoi
$LN3@PolyWaypoi:
  0007d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN4@PolyWaypoi:
  00084	8a 55 a8	 mov	 dl, BYTE PTR tv86[ebp]
  00087	88 55 f8	 mov	 BYTE PTR _pwd$[ebp+12], dl

; 1131 : 	pwd.comeback   = (line->flags & ML_EFFECT2) == ML_EFFECT2; // Return when reaching end?

  0008a	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0008d	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00091	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00097	74 09		 je	 SHORT $LN5@PolyWaypoi
  00099	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  000a0	eb 07		 jmp	 SHORT $LN6@PolyWaypoi
$LN5@PolyWaypoi:
  000a2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN6@PolyWaypoi:
  000a9	8a 55 a8	 mov	 dl, BYTE PTR tv92[ebp]
  000ac	88 55 f9	 mov	 BYTE PTR _pwd$[ebp+13], dl

; 1132 : 	pwd.wrap       = (line->flags & ML_EFFECT3) == ML_EFFECT3; // Wrap around waypoints

  000af	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  000b2	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  000b6	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  000bc	74 09		 je	 SHORT $LN7@PolyWaypoi
  000be	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  000c5	eb 07		 jmp	 SHORT $LN8@PolyWaypoi
$LN7@PolyWaypoi:
  000c7	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$LN8@PolyWaypoi:
  000ce	8a 55 a8	 mov	 dl, BYTE PTR tv130[ebp]
  000d1	88 55 fa	 mov	 BYTE PTR _pwd$[ebp+14], dl

; 1133 : 	pwd.continuous = (line->flags & ML_EFFECT4) == ML_EFFECT4; // Continuously move - used with COMEBACK or WRAP

  000d4	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  000d7	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  000db	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  000e1	74 09		 je	 SHORT $LN9@PolyWaypoi
  000e3	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
  000ea	eb 07		 jmp	 SHORT $LN10@PolyWaypoi
$LN9@PolyWaypoi:
  000ec	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
$LN10@PolyWaypoi:
  000f3	8a 55 a8	 mov	 dl, BYTE PTR tv136[ebp]
  000f6	88 55 fb	 mov	 BYTE PTR _pwd$[ebp+15], dl

; 1134 : 
; 1135 : 	return EV_DoPolyObjWaypoint(&pwd);

  000f9	8d 45 ec	 lea	 eax, DWORD PTR _pwd$[ebp]
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _EV_DoPolyObjWaypoint
  00102	83 c4 04	 add	 esp, 4

; 1136 : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	33 cd		 xor	 ecx, ebp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_PolyWaypoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyTranslucency
_TEXT	SEGMENT
_po$ = -8						; size = 4
_polyObjNum$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyTranslucency PROC					; COMDAT

; 1100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1101 : 	INT32 polyObjNum = line->tag;

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00010	89 4d fc	 mov	 DWORD PTR _polyObjNum$[ebp], ecx

; 1102 : 	polyobj_t *po;
; 1103 : 
; 1104 : 	if (!(po = Polyobj_GetForNum(polyObjNum)))

  00013	8b 45 fc	 mov	 eax, DWORD PTR _polyObjNum$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f8	 mov	 DWORD PTR _po$[ebp], eax
  00022	83 7d f8 00	 cmp	 DWORD PTR _po$[ebp], 0
  00026	75 13		 jne	 SHORT $LN2@PolyTransl

; 1105 : 	{
; 1106 : 		CONS_Printf("EV_DoPolyObjWaypoint: bad polyobj %d\n",

  00028	8b 45 fc	 mov	 eax, DWORD PTR _polyObjNum$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@
  00031	e8 00 00 00 00	 call	 _CONS_Printf
  00036	83 c4 08	 add	 esp, 8

; 1107 : 			polyObjNum);
; 1108 : 		return;

  00039	eb 2c		 jmp	 SHORT $LN1@PolyTransl
$LN2@PolyTransl:

; 1109 : 	}
; 1110 : 
; 1111 : 	// don't allow line actions to affect bad polyobjects
; 1112 : 	if (po->isBad)

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0003e	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00045	85 c9		 test	 ecx, ecx
  00047	74 02		 je	 SHORT $LN3@PolyTransl

; 1113 : 		return;

  00049	eb 1c		 jmp	 SHORT $LN1@PolyTransl
$LN3@PolyTransl:

; 1114 : 
; 1115 : 	po->translucency = (line->frontsector->floorheight >> FRACBITS) / 100;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0004e	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00051	8b 01		 mov	 eax, DWORD PTR [ecx]
  00053	c1 f8 10	 sar	 eax, 16			; 00000010H
  00056	99		 cdq
  00057	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0005c	f7 f9		 idiv	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00061	89 82 a4 00 00
	00		 mov	 DWORD PTR [edx+164], eax
$LN1@PolyTransl:

; 1116 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_PolyTranslucency ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyVisible
_TEXT	SEGMENT
_po$ = -8						; size = 4
_polyObjNum$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyVisible PROC					; COMDAT

; 1071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1072 : 	INT32 polyObjNum = line->tag;

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00010	89 4d fc	 mov	 DWORD PTR _polyObjNum$[ebp], ecx

; 1073 : 	polyobj_t *po;
; 1074 : 
; 1075 : 	if (!(po = Polyobj_GetForNum(polyObjNum)))

  00013	8b 45 fc	 mov	 eax, DWORD PTR _polyObjNum$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f8	 mov	 DWORD PTR _po$[ebp], eax
  00022	83 7d f8 00	 cmp	 DWORD PTR _po$[ebp], 0
  00026	75 13		 jne	 SHORT $LN2@PolyVisibl

; 1076 : 	{
; 1077 : 		CONS_Printf("PolyVisible: bad polyobj %d\n",

  00028	8b 45 fc	 mov	 eax, DWORD PTR _polyObjNum$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KIIHCCJ@PolyVisible?3?5bad?5polyobj?5?$CFd?6@
  00031	e8 00 00 00 00	 call	 _CONS_Printf
  00036	83 c4 08	 add	 esp, 8

; 1078 : 			polyObjNum);
; 1079 : 		return;

  00039	eb 5e		 jmp	 SHORT $LN1@PolyVisibl
$LN2@PolyVisibl:

; 1080 : 	}
; 1081 : 
; 1082 : 	// don't allow line actions to affect bad polyobjects
; 1083 : 	if (po->isBad)

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0003e	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00045	85 c9		 test	 ecx, ecx
  00047	74 02		 je	 SHORT $LN3@PolyVisibl

; 1084 : 		return;

  00049	eb 4e		 jmp	 SHORT $LN1@PolyVisibl
$LN3@PolyVisibl:

; 1085 : 
; 1086 : 	if (!(line->flags & ML_NOCLIMB))

  0004b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0004e	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00052	83 e1 40	 and	 ecx, 64			; 00000040H
  00055	75 15		 jne	 SHORT $LN4@PolyVisibl

; 1087 : 		po->flags |= POF_SOLID;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0005a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00060	83 c9 03	 or	 ecx, 3
  00063	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00066	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN4@PolyVisibl:

; 1088 : 
; 1089 : 	po->flags &= ~POF_NOSPECIALS;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0006f	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00075	81 e1 ff ef ff
	ff		 and	 ecx, -4097		; ffffefffH
  0007b	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  0007e	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx

; 1090 : 	po->flags |= POF_RENDERALL;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00087	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0008d	83 c9 38	 or	 ecx, 56			; 00000038H
  00090	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00093	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN1@PolyVisibl:

; 1091 : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_PolyVisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyInvisible
_TEXT	SEGMENT
_po$ = -8						; size = 4
_polyObjNum$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyInvisible PROC					; COMDAT

; 1042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1043 : 	INT32 polyObjNum = line->tag;

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00010	89 4d fc	 mov	 DWORD PTR _polyObjNum$[ebp], ecx

; 1044 : 	polyobj_t *po;
; 1045 : 
; 1046 : 	if (!(po = Polyobj_GetForNum(polyObjNum)))

  00013	8b 45 fc	 mov	 eax, DWORD PTR _polyObjNum$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f8	 mov	 DWORD PTR _po$[ebp], eax
  00022	83 7d f8 00	 cmp	 DWORD PTR _po$[ebp], 0
  00026	75 13		 jne	 SHORT $LN2@PolyInvisi

; 1047 : 	{
; 1048 : 		CONS_Printf("PolyInvisible: bad polyobj %d\n",

  00028	8b 45 fc	 mov	 eax, DWORD PTR _polyObjNum$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DLBMDGJG@PolyInvisible?3?5bad?5polyobj?5?$CFd?6@
  00031	e8 00 00 00 00	 call	 _CONS_Printf
  00036	83 c4 08	 add	 esp, 8

; 1049 : 			polyObjNum);
; 1050 : 		return;

  00039	eb 5e		 jmp	 SHORT $LN1@PolyInvisi
$LN2@PolyInvisi:

; 1051 : 	}
; 1052 : 
; 1053 : 	// don't allow line actions to affect bad polyobjects
; 1054 : 	if (po->isBad)

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0003e	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00045	85 c9		 test	 ecx, ecx
  00047	74 02		 je	 SHORT $LN3@PolyInvisi

; 1055 : 		return;

  00049	eb 4e		 jmp	 SHORT $LN1@PolyInvisi
$LN3@PolyInvisi:

; 1056 : 
; 1057 : 	if (!(line->flags & ML_NOCLIMB))

  0004b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0004e	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00052	83 e1 40	 and	 ecx, 64			; 00000040H
  00055	75 15		 jne	 SHORT $LN4@PolyInvisi

; 1058 : 		po->flags &= ~POF_SOLID;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0005a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00060	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00063	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00066	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN4@PolyInvisi:

; 1059 : 
; 1060 : 	po->flags |= POF_NOSPECIALS;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0006f	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00075	81 c9 00 10 00
	00		 or	 ecx, 4096		; 00001000H
  0007b	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  0007e	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx

; 1061 : 	po->flags &= ~POF_RENDERALL;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00087	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0008d	83 e1 c7	 and	 ecx, -57		; ffffffc7H
  00090	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00093	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN1@PolyInvisi:

; 1062 : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_PolyInvisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyMove
_TEXT	SEGMENT
tv129 = -92						; size = 4
_pmd$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyMove PROC						; COMDAT

; 1022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1023 : 	polymovedata_t pmd;
; 1024 : 
; 1025 : 	pmd.polyObjNum = line->tag;

  00013	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00016	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0001a	89 4d e8	 mov	 DWORD PTR _pmd$[ebp], ecx

; 1026 : 	pmd.speed      = sides[line->sidenum[0]].textureoffset / 8;

  0001d	b8 02 00 00 00	 mov	 eax, 2
  00022	6b c8 00	 imul	 ecx, eax, 0
  00025	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00028	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0002d	6b c8 1c	 imul	 ecx, eax, 28
  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00036	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00039	99		 cdq
  0003a	83 e2 07	 and	 edx, 7
  0003d	03 c2		 add	 eax, edx
  0003f	c1 f8 03	 sar	 eax, 3
  00042	89 45 f0	 mov	 DWORD PTR _pmd$[ebp+8], eax

; 1027 : 	pmd.angle      = R_PointToAngle2(line->v1->x, line->v1->y, line->v2->x, line->v2->y);

  00045	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004e	52		 push	 edx
  0004f	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	52		 push	 edx
  00058	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00060	52		 push	 edx
  00061	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _R_PointToAngle2
  0006e	83 c4 10	 add	 esp, 16			; 00000010H
  00071	89 45 f4	 mov	 DWORD PTR _pmd$[ebp+12], eax

; 1028 : 	pmd.distance   = sides[line->sidenum[0]].rowoffset;

  00074	b8 02 00 00 00	 mov	 eax, 2
  00079	6b c8 00	 imul	 ecx, eax, 0
  0007c	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0007f	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00084	6b c8 1c	 imul	 ecx, eax, 28
  00087	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0008d	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00091	89 45 ec	 mov	 DWORD PTR _pmd$[ebp+4], eax

; 1029 : 
; 1030 : 	pmd.overRide = (line->special == 483); // Polyobj_OR_Move

  00094	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00097	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0009b	81 f9 e3 01 00
	00		 cmp	 ecx, 483		; 000001e3H
  000a1	75 09		 jne	 SHORT $LN3@PolyMove
  000a3	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  000aa	eb 07		 jmp	 SHORT $LN4@PolyMove
$LN3@PolyMove:
  000ac	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$LN4@PolyMove:
  000b3	8a 55 a4	 mov	 dl, BYTE PTR tv129[ebp]
  000b6	88 55 f8	 mov	 BYTE PTR _pmd$[ebp+16], dl

; 1031 : 
; 1032 : 	return EV_DoPolyObjMove(&pmd);

  000b9	8d 45 e8	 lea	 eax, DWORD PTR _pmd$[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _EV_DoPolyObjMove
  000c2	83 c4 04	 add	 esp, 4

; 1033 : }

  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	33 cd		 xor	 ecx, ebp
  000cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_PolyMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _PolyDoor
_TEXT	SEGMENT
tv68 = -96						; size = 4
_pdd$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_line$ = 8						; size = 4
_PolyDoor PROC						; COMDAT

; 981  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 982  : 	polydoordata_t pdd;
; 983  : 
; 984  : 	pdd.polyObjNum = line->tag; // polyobject id

  00013	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00016	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0001a	89 4d e4	 mov	 DWORD PTR _pdd$[ebp], ecx

; 985  : 
; 986  : 	switch(line->special)

  0001d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00020	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00024	89 4d a0	 mov	 DWORD PTR tv68[ebp], ecx
  00027	81 7d a0 e0 01
	00 00		 cmp	 DWORD PTR tv68[ebp], 480 ; 000001e0H
  0002e	74 12		 je	 SHORT $LN4@PolyDoor
  00030	81 7d a0 e1 01
	00 00		 cmp	 DWORD PTR tv68[ebp], 481 ; 000001e1H
  00037	0f 84 cb 00 00
	00		 je	 $LN7@PolyDoor
  0003d	e9 57 01 00 00	 jmp	 $LN10@PolyDoor
$LN4@PolyDoor:

; 987  : 	{
; 988  : 		case 480: // Polyobj_DoorSlide
; 989  : 			pdd.doorType = POLY_DOOR_SLIDE;

  00042	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pdd$[ebp+4], 0

; 990  : 			pdd.speed    = sides[line->sidenum[0]].textureoffset / 8;

  00049	b8 02 00 00 00	 mov	 eax, 2
  0004e	6b c8 00	 imul	 ecx, eax, 0
  00051	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00054	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00059	6b c8 1c	 imul	 ecx, eax, 28
  0005c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00062	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00065	99		 cdq
  00066	83 e2 07	 and	 edx, 7
  00069	03 c2		 add	 eax, edx
  0006b	c1 f8 03	 sar	 eax, 3
  0006e	89 45 ec	 mov	 DWORD PTR _pdd$[ebp+8], eax

; 991  : 			pdd.angle    = R_PointToAngle2(line->v1->x, line->v1->y, line->v2->x, line->v2->y); // angle of motion

  00071	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00074	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00077	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007a	52		 push	 edx
  0007b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	52		 push	 edx
  00084	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008c	52		 push	 edx
  0008d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 _R_PointToAngle2
  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	89 45 f0	 mov	 DWORD PTR _pdd$[ebp+12], eax

; 992  : 			pdd.distance = sides[line->sidenum[0]].rowoffset;

  000a0	b8 02 00 00 00	 mov	 eax, 2
  000a5	6b c8 00	 imul	 ecx, eax, 0
  000a8	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  000ab	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  000b0	6b c8 1c	 imul	 ecx, eax, 28
  000b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  000b9	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  000bd	89 45 f4	 mov	 DWORD PTR _pdd$[ebp+16], eax

; 993  : 
; 994  : 			if (line->sidenum[1] != 0xffff)

  000c0	b8 02 00 00 00	 mov	 eax, 2
  000c5	c1 e0 00	 shl	 eax, 0
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  000cb	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  000d0	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  000d6	74 24		 je	 SHORT $LN5@PolyDoor

; 995  : 				pdd.delay = sides[line->sidenum[1]].textureoffset >> FRACBITS; // delay in tics

  000d8	b8 02 00 00 00	 mov	 eax, 2
  000dd	c1 e0 00	 shl	 eax, 0
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  000e3	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  000e8	6b c2 1c	 imul	 eax, edx, 28
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  000f1	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000f4	c1 fa 10	 sar	 edx, 16			; 00000010H
  000f7	89 55 f8	 mov	 DWORD PTR _pdd$[ebp+20], edx
  000fa	eb 07		 jmp	 SHORT $LN6@PolyDoor
$LN5@PolyDoor:

; 996  : 			else
; 997  : 				pdd.delay = 0;

  000fc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pdd$[ebp+20], 0
$LN6@PolyDoor:

; 998  : 			break;

  00103	e9 95 00 00 00	 jmp	 $LN2@PolyDoor
$LN7@PolyDoor:

; 999  : 		case 481: // Polyobj_DoorSwing
; 1000 : 			pdd.doorType = POLY_DOOR_SWING;

  00108	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _pdd$[ebp+4], 1

; 1001 : 			pdd.speed    = sides[line->sidenum[0]].textureoffset >> FRACBITS; // angular speed

  0010f	b8 02 00 00 00	 mov	 eax, 2
  00114	6b c8 00	 imul	 ecx, eax, 0
  00117	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0011a	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0011f	6b c8 1c	 imul	 ecx, eax, 28
  00122	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00128	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0012b	c1 f8 10	 sar	 eax, 16			; 00000010H
  0012e	89 45 ec	 mov	 DWORD PTR _pdd$[ebp+8], eax

; 1002 : 			pdd.distance = sides[line->sidenum[0]].rowoffset >> FRACBITS; // angular distance

  00131	b8 02 00 00 00	 mov	 eax, 2
  00136	6b c8 00	 imul	 ecx, eax, 0
  00139	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0013c	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00141	6b c8 1c	 imul	 ecx, eax, 28
  00144	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0014a	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0014e	c1 f8 10	 sar	 eax, 16			; 00000010H
  00151	89 45 f4	 mov	 DWORD PTR _pdd$[ebp+16], eax

; 1003 : 
; 1004 : 			if (line->sidenum[1] != 0xffff)

  00154	b8 02 00 00 00	 mov	 eax, 2
  00159	c1 e0 00	 shl	 eax, 0
  0015c	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  0015f	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  00164	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0016a	74 24		 je	 SHORT $LN8@PolyDoor

; 1005 : 				pdd.delay = sides[line->sidenum[1]].textureoffset >> FRACBITS; // delay in tics

  0016c	b8 02 00 00 00	 mov	 eax, 2
  00171	c1 e0 00	 shl	 eax, 0
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00177	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  0017c	6b c2 1c	 imul	 eax, edx, 28
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  00185	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00188	c1 fa 10	 sar	 edx, 16			; 00000010H
  0018b	89 55 f8	 mov	 DWORD PTR _pdd$[ebp+20], edx
  0018e	eb 07		 jmp	 SHORT $LN9@PolyDoor
$LN8@PolyDoor:

; 1006 : 			else
; 1007 : 				pdd.delay = 0;

  00190	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pdd$[ebp+20], 0
$LN9@PolyDoor:

; 1008 : 			break;

  00197	eb 04		 jmp	 SHORT $LN2@PolyDoor
$LN10@PolyDoor:

; 1009 : 		default:
; 1010 : 			return 0; // ???

  00199	33 c0		 xor	 eax, eax
  0019b	eb 0c		 jmp	 SHORT $LN1@PolyDoor
$LN2@PolyDoor:

; 1011 : 	}
; 1012 : 
; 1013 : 	return EV_DoPolyDoor(&pdd);

  0019d	8d 45 e4	 lea	 eax, DWORD PTR _pdd$[ebp]
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _EV_DoPolyDoor
  001a6	83 c4 04	 add	 esp, 4
$LN1@PolyDoor:

; 1014 : }

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001af	33 cd		 xor	 ecx, ebp
  001b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
_PolyDoor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindLineFromLineTag
_TEXT	SEGMENT
tv79 = -68						; size = 4
_line$ = 8						; size = 4
_start$ = 12						; size = 4
_P_FindLineFromLineTag PROC				; COMDAT

; 895  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 896  : 	if (line->tag == -1)

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00010	83 f9 ff	 cmp	 ecx, -1
  00013	75 20		 jne	 SHORT $LN4@P_FindLine

; 897  : 	{
; 898  : 		start++;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 0c	 mov	 DWORD PTR _start$[ebp], eax

; 899  : 
; 900  : 		if (start >= (INT32)numlines)

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00021	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00027	7c 05		 jl	 SHORT $LN6@P_FindLine

; 901  : 			return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	eb 7b		 jmp	 SHORT $LN5@P_FindLine
$LN6@P_FindLine:

; 902  : 
; 903  : 		return start;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00031	eb 76		 jmp	 SHORT $LN5@P_FindLine

; 904  : 	}

  00033	eb 74		 jmp	 SHORT $LN5@P_FindLine
$LN4@P_FindLine:

; 905  : 	else
; 906  : 	{
; 907  : 		start = start >= 0 ? lines[start].nexttag :

  00035	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  00039	7c 13		 jl	 SHORT $LN8@P_FindLine
  0003b	6b 45 0c 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00045	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  00049	89 55 bc	 mov	 DWORD PTR tv79[ebp], edx
  0004c	eb 1f		 jmp	 SHORT $LN9@P_FindLine
$LN8@P_FindLine:
  0004e	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00051	0f bf 40 14	 movsx	 eax, WORD PTR [eax+20]
  00055	33 d2		 xor	 edx, edx
  00057	f7 35 00 00 00
	00		 div	 DWORD PTR _numlines
  0005d	6b ca 4c	 imul	 ecx, edx, 76
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00066	8b 44 0a 40	 mov	 eax, DWORD PTR [edx+ecx+64]
  0006a	89 45 bc	 mov	 DWORD PTR tv79[ebp], eax
$LN9@P_FindLine:
  0006d	8b 4d bc	 mov	 ecx, DWORD PTR tv79[ebp]
  00070	89 4d 0c	 mov	 DWORD PTR _start$[ebp], ecx
$LN2@P_FindLine:

; 908  : 			lines[(unsigned)line->tag % numlines].firsttag;
; 909  : 		while (start >= 0 && lines[start].tag != line->tag)

  00073	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  00077	7c 2d		 jl	 SHORT $LN3@P_FindLine
  00079	6b 45 0c 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  0007d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00083	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  00088	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0008b	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0008f	3b d1		 cmp	 edx, ecx
  00091	74 13		 je	 SHORT $LN3@P_FindLine

; 910  : 			start = lines[start].nexttag;

  00093	6b 45 0c 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0009d	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  000a1	89 55 0c	 mov	 DWORD PTR _start$[ebp], edx
  000a4	eb cd		 jmp	 SHORT $LN2@P_FindLine
$LN3@P_FindLine:

; 911  : 		return start;

  000a6	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
$LN5@P_FindLine:

; 912  : 	}
; 913  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_P_FindLineFromLineTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _getNextSector
_TEXT	SEGMENT
_line$ = 8						; size = 4
_sec$ = 12						; size = 4
_getNextSector PROC					; COMDAT

; 412  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 413  : 	if (line->frontsector == sec)

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000f	3b 4d 0c	 cmp	 ecx, DWORD PTR _sec$[ebp]
  00012	75 19		 jne	 SHORT $LN4@getNextSec

; 414  : 	{
; 415  : 		if (line->backsector != sec)

  00014	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00017	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0001a	3b 4d 0c	 cmp	 ecx, DWORD PTR _sec$[ebp]
  0001d	74 0a		 je	 SHORT $LN3@getNextSec

; 416  : 			return line->backsector;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00022	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00025	eb 0c		 jmp	 SHORT $LN1@getNextSec
  00027	eb 04		 jmp	 SHORT $LN4@getNextSec
$LN3@getNextSec:

; 417  : 		else
; 418  : 			return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 06		 jmp	 SHORT $LN1@getNextSec
$LN4@getNextSec:

; 419  : 	}
; 420  : 	return line->frontsector;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00030	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
$LN1@getNextSec:

; 421  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_getNextSector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindAnimatedFlat
_TEXT	SEGMENT
_foundflats$ = -16					; size = 4
_endflatnum$ = -12					; size = 4
_startflatnum$ = -8					; size = 4
_i$ = -4						; size = 4
_animnum$ = 8						; size = 4
_P_FindAnimatedFlat PROC				; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 308  : 	size_t i;
; 309  : 	lumpnum_t startflatnum, endflatnum;
; 310  : 	levelflat_t *foundflats;
; 311  : 
; 312  : 	foundflats = levelflats;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelflats
  0000e	89 45 f0	 mov	 DWORD PTR _foundflats$[ebp], eax

; 313  : 	startflatnum = anims[animnum].basepic;

  00011	6b 45 08 14	 imul	 eax, DWORD PTR _animnum$[ebp], 20
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _anims
  0001b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0001f	89 55 f8	 mov	 DWORD PTR _startflatnum$[ebp], edx

; 314  : 	endflatnum = anims[animnum].picnum;

  00022	6b 45 08 14	 imul	 eax, DWORD PTR _animnum$[ebp], 20
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _anims
  0002c	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00030	89 55 f4	 mov	 DWORD PTR _endflatnum$[ebp], edx

; 315  : 
; 316  : 	// note: high word of lumpnum is the wad number
; 317  : 	if ((startflatnum>>16) != (endflatnum>>16))

  00033	8b 45 f8	 mov	 eax, DWORD PTR _startflatnum$[ebp]
  00036	c1 e8 10	 shr	 eax, 16			; 00000010H
  00039	8b 4d f4	 mov	 ecx, DWORD PTR _endflatnum$[ebp]
  0003c	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0003f	3b c1		 cmp	 eax, ecx
  00041	74 2b		 je	 SHORT $LN5@P_FindAnim

; 318  : 		I_Error("AnimatedFlat start %s not in same wad as end %s\n",

  00043	6b 45 08 17	 imul	 eax, DWORD PTR _animnum$[ebp], 23
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  0004d	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00051	52		 push	 edx
  00052	6b 45 08 17	 imul	 eax, DWORD PTR _animnum$[ebp], 23
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  0005c	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00060	52		 push	 edx
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@PPFFLENC@AnimatedFlat?5start?5?$CFs?5not?5in?5sa@
  00066	e8 00 00 00 00	 call	 _I_Error
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@P_FindAnim:

; 319  : 			animdefs[animnum].startname, animdefs[animnum].endname);
; 320  : 
; 321  : 	//
; 322  : 	// now search through the levelflats if this anim flat sequence is used
; 323  : 	//
; 324  : 	for (i = 0; i < numlevelflats; i++, foundflats++)

  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00075	eb 12		 jmp	 SHORT $LN4@P_FindAnim
$LN2@P_FindAnim:
  00077	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00083	83 c1 20	 add	 ecx, 32			; 00000020H
  00086	89 4d f0	 mov	 DWORD PTR _foundflats$[ebp], ecx
$LN4@P_FindAnim:
  00089	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlevelflats
  00092	0f 83 89 00 00
	00		 jae	 $LN3@P_FindAnim

; 325  : 	{
; 326  : 		// is that levelflat from the flat anim sequence ?
; 327  : 		if (foundflats->lumpnum >= startflatnum && foundflats->lumpnum <= endflatnum)

  00098	8b 45 f0	 mov	 eax, DWORD PTR _foundflats$[ebp]
  0009b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0009e	3b 4d f8	 cmp	 ecx, DWORD PTR _startflatnum$[ebp]
  000a1	72 79		 jb	 SHORT $LN7@P_FindAnim
  000a3	8b 45 f0	 mov	 eax, DWORD PTR _foundflats$[ebp]
  000a6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000a9	3b 4d f4	 cmp	 ecx, DWORD PTR _endflatnum$[ebp]
  000ac	77 6e		 ja	 SHORT $LN7@P_FindAnim

; 328  : 		{
; 329  : 			foundflats->baselumpnum = startflatnum;

  000ae	8b 45 f0	 mov	 eax, DWORD PTR _foundflats$[ebp]
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _startflatnum$[ebp]
  000b4	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 330  : 			foundflats->animseq = foundflats->lumpnum - startflatnum;

  000b7	8b 45 f0	 mov	 eax, DWORD PTR _foundflats$[ebp]
  000ba	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bd	2b 4d f8	 sub	 ecx, DWORD PTR _startflatnum$[ebp]
  000c0	8b 55 f0	 mov	 edx, DWORD PTR _foundflats$[ebp]
  000c3	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 331  : 			foundflats->numpics = endflatnum - startflatnum + 1;

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _endflatnum$[ebp]
  000c9	2b 45 f8	 sub	 eax, DWORD PTR _startflatnum$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  000d2	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 332  : 			foundflats->speed = anims[animnum].speed;

  000d5	6b 45 08 14	 imul	 eax, DWORD PTR _animnum$[ebp], 20
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  000dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _anims
  000e2	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  000e6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 333  : 
; 334  : 			if (devparm)

  000e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  000f0	74 2a		 je	 SHORT $LN7@P_FindAnim

; 335  : 				I_OutputMsg("animflat: #%03"PRIdS" name:%.8s animseq:%d numpics:%d speed:%d\n",

  000f2	8b 45 f0	 mov	 eax, DWORD PTR _foundflats$[ebp]
  000f5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000f8	51		 push	 ecx
  000f9	8b 55 f0	 mov	 edx, DWORD PTR _foundflats$[ebp]
  000fc	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000ff	50		 push	 eax
  00100	8b 4d f0	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00103	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00106	52		 push	 edx
  00107	8b 45 f0	 mov	 eax, DWORD PTR _foundflats$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010e	51		 push	 ecx
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@DNGGGIOB@animflat?3?5?$CD?$CF03Iu?5name?3?$CF?48s?5anim@
  00114	e8 00 00 00 00	 call	 _I_OutputMsg
  00119	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@P_FindAnim:

; 336  : 					i, foundflats->name, foundflats->animseq,
; 337  : 					foundflats->numpics,foundflats->speed);
; 338  : 		}
; 339  : 	}

  0011c	e9 56 ff ff ff	 jmp	 $LN2@P_FindAnim
$LN3@P_FindAnim:

; 340  : }

  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
_P_FindAnimatedFlat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddSpikeThinker
_TEXT	SEGMENT
_spikes$ = -4						; size = 4
_sec$ = 8						; size = 4
_referrer$ = 12						; size = 4
_P_AddSpikeThinker PROC					; COMDAT

; 4486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4487 : 	levelspecthink_t *spikes;
; 4488 : 
; 4489 : 	// create and initialize new thinker
; 4490 : 	spikes = Z_Calloc(sizeof (*spikes), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _spikes$[ebp], eax

; 4491 : 	P_AddThinker(&spikes->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _spikes$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4492 : 
; 4493 : 	spikes->thinker.function.acp1 = (actionf_p1)T_SpikeSector;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _spikes$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_SpikeSector

; 4494 : 
; 4495 : 	spikes->sector = sec;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _spikes$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00038	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4496 : 	spikes->vars[0] = referrer;

  0003b	b8 04 00 00 00	 mov	 eax, 4
  00040	6b c8 00	 imul	 ecx, eax, 0
  00043	8b 55 fc	 mov	 edx, DWORD PTR _spikes$[ebp]
  00046	8b 45 0c	 mov	 eax, DWORD PTR _referrer$[ebp]
  00049	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 4497 : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_P_AddSpikeThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _Add_Friction
_TEXT	SEGMENT
_f$ = -4						; size = 4
_friction$ = 8						; size = 4
_movefactor$ = 12					; size = 4
_affectee$ = 16						; size = 4
_referrer$ = 20						; size = 4
_Add_Friction PROC					; COMDAT

; 6450 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6451 : 	friction_t *f = Z_Calloc(sizeof *f, PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 24		 push	 36			; 00000024H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _f$[ebp], eax

; 6452 : 
; 6453 : 	f->thinker.function.acp1 = (actionf_p1)T_Friction;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_Friction

; 6454 : 	f->friction = friction;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _friction$[ebp]
  0002c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 6455 : 	f->movefactor = movefactor;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _movefactor$[ebp]
  00035	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 6456 : 	f->affectee = affectee;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _affectee$[ebp]
  0003e	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 6457 : 
; 6458 : 	if (referrer != -1)

  00041	83 7d 14 ff	 cmp	 DWORD PTR _referrer$[ebp], -1
  00045	74 12		 je	 SHORT $LN2@Add_Fricti

; 6459 : 	{
; 6460 : 		f->roverfriction = true;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  0004a	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 6461 : 		f->referrer = referrer;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  00051	8b 4d 14	 mov	 ecx, DWORD PTR _referrer$[ebp]
  00054	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 6462 : 	}

  00057	eb 07		 jmp	 SHORT $LN3@Add_Fricti
$LN2@Add_Fricti:

; 6463 : 	else
; 6464 : 		f->roverfriction = false;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  0005c	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
$LN3@Add_Fricti:

; 6465 : 
; 6466 : 	P_AddThinker(&f->thinker);

  00060	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _P_AddThinker
  00069	83 c4 04	 add	 esp, 4

; 6467 : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_Add_Friction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_ProcessLineSpecial
_TEXT	SEGMENT
tv366 = -220						; size = 4
tv330 = -220						; size = 4
tv310 = -220						; size = 4
tv66 = -220						; size = 4
$T1 = -216						; size = 4
_fractime$2 = -148					; size = 4
_rover$3 = -144						; size = 4
_sec$4 = -140						; size = 4
_foftag$5 = -136					; size = 2
_sectag$6 = -132					; size = 2
_th$7 = -128						; size = 4
_scroller$8 = -124					; size = 4
_dummy$9 = -120						; size = 4
_aim$10 = -116						; size = 4
_altview$11 = -112					; size = 4
_reallightlevel$12 = -108				; size = 2
_flash$13 = -104					; size = 4
_reallightlevel$14 = -100				; size = 2
_flash$15 = -96						; size = 4
_reallightlevel$16 = -92				; size = 2
_glow$17 = -88						; size = 4
_reallightlevel$18 = -84				; size = 2
_flick$19 = -80						; size = 4
_newname$20 = -76					; size = 9
_lumpnum$21 = -64					; size = 4
_scrnum$22 = -60					; size = 4
_foundit$23 = -56					; size = 4
_rover$24 = -52						; size = 4
_sec$25 = -48						; size = 4
_sfxnum$26 = -44					; size = 4
_musicnum$27 = -40					; size = 4
_z$28 = -36						; size = 4
_y$29 = -32						; size = 4
_x$30 = -28						; size = 4
_dest$31 = -24						; size = 4
_newceilinglightsec$32 = -20				; size = 4
_newfloorlightsec$33 = -16				; size = 4
_newlightlevel$34 = -12					; size = 2
_secnum$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_line$ = 8						; size = 4
_mo$ = 12						; size = 4
_P_ProcessLineSpecial PROC				; COMDAT

; 1856 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1857 : 	INT32 secnum = -1;

  00016	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _secnum$[ebp], -1

; 1858 : 
; 1859 : 	// note: only commands with linedef types >= 400 && < 500 can be used
; 1860 : 	switch (line->special)

  0001d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00020	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00024	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], ecx
  0002a	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  00030	81 ea 90 01 00
	00		 sub	 edx, 400		; 00000190H
  00036	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], edx
  0003c	83 bd 24 ff ff
	ff 5b		 cmp	 DWORD PTR tv66[ebp], 91	; 0000005bH
  00043	0f 87 0f 18 00
	00		 ja	 $LN194@P_ProcessL
  00049	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004f	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN204@P_ProcessL[eax]
  00056	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN205@P_ProcessL[ecx*4]
$LN38@P_ProcessL:

; 1861 : 	{
; 1862 : 		case 400: // Set tagged sector's floor height/pic
; 1863 : 			EV_DoFloor(line, instantMoveFloorByFrontSector);

  0005d	6a 04		 push	 4
  0005f	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _EV_DoFloor
  00068	83 c4 08	 add	 esp, 8

; 1864 : 			break;

  0006b	e9 e8 17 00 00	 jmp	 $LN2@P_ProcessL
$LN39@P_ProcessL:

; 1865 : 
; 1866 : 		case 401: // Set tagged sector's ceiling height/pic
; 1867 : 			EV_DoCeiling(line, instantMoveCeilingByFrontSector);

  00070	6a 0b		 push	 11			; 0000000bH
  00072	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _EV_DoCeiling
  0007b	83 c4 08	 add	 esp, 8

; 1868 : 			break;

  0007e	e9 d5 17 00 00	 jmp	 $LN2@P_ProcessL
$LN40@P_ProcessL:

; 1869 : 
; 1870 : 		case 402: // Set tagged sector's light level
; 1871 : 			{
; 1872 : 				INT16 newlightlevel;
; 1873 : 				INT32 newfloorlightsec, newceilinglightsec;
; 1874 : 
; 1875 : 				newlightlevel = line->frontsector->lightlevel;

  00083	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00086	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00089	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  0008d	66 89 55 f4	 mov	 WORD PTR _newlightlevel$34[ebp], dx

; 1876 : 				newfloorlightsec = line->frontsector->floorlightsec;

  00091	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00094	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00097	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  0009a	89 55 f0	 mov	 DWORD PTR _newfloorlightsec$33[ebp], edx

; 1877 : 				newceilinglightsec = line->frontsector->ceilinglightsec;

  0009d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  000a0	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000a3	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  000a6	89 55 ec	 mov	 DWORD PTR _newceilinglightsec$32[ebp], edx
$LN4@P_ProcessL:

; 1878 : 
; 1879 : 				// act on all sectors with the same tag as the triggering linedef
; 1880 : 				while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  000b6	83 c4 08	 add	 esp, 8
  000b9	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  000bc	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  000c0	0f 8c 86 00 00
	00		 jl	 $LN5@P_ProcessL

; 1881 : 				{
; 1882 : 					if (sectors[secnum].lightingdata)

  000c6	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000d3	83 7c 01 4c 00	 cmp	 DWORD PTR [ecx+eax+76], 0
  000d8	74 2f		 je	 SHORT $LN41@P_ProcessL

; 1883 : 					{
; 1884 : 						// Stop the lighting madness going on in this sector!
; 1885 : 						P_RemoveThinker(&((elevator_t *)sectors[secnum].lightingdata)->thinker);

  000da	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000e7	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 _P_RemoveThinker
  000f1	83 c4 04	 add	 esp, 4

; 1886 : 						sectors[secnum].lightingdata = NULL;

  000f4	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00101	c7 44 01 4c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+76], 0
$LN41@P_ProcessL:

; 1887 : 
; 1888 : 						// No, it's not an elevator_t, but any struct with a thinker_t named
; 1889 : 						// 'thinker' at the beginning will do here. (We don't know what it
; 1890 : 						// actually is: could be lightlevel_t, fireflicker_t, glow_t, etc.)
; 1891 : 					}
; 1892 : 
; 1893 : 					sectors[secnum].lightlevel = newlightlevel;

  00109	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00116	66 8b 55 f4	 mov	 dx, WORD PTR _newlightlevel$34[ebp]
  0011a	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 1894 : 					sectors[secnum].floorlightsec = newfloorlightsec;

  0011f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00126	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0012c	8b 55 f0	 mov	 edx, DWORD PTR _newfloorlightsec$33[ebp]
  0012f	89 54 01 6c	 mov	 DWORD PTR [ecx+eax+108], edx

; 1895 : 					sectors[secnum].ceilinglightsec = newceilinglightsec;

  00133	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00140	8b 55 ec	 mov	 edx, DWORD PTR _newceilinglightsec$32[ebp]
  00143	89 54 01 70	 mov	 DWORD PTR [ecx+eax+112], edx

; 1896 : 				}

  00147	e9 5d ff ff ff	 jmp	 $LN4@P_ProcessL
$LN5@P_ProcessL:

; 1897 : 			}
; 1898 : 			break;

  0014c	e9 07 17 00 00	 jmp	 $LN2@P_ProcessL
$LN42@P_ProcessL:

; 1899 : 
; 1900 : 		case 403: // Move floor, linelen = speed, frontsector floor = dest height
; 1901 : 			EV_DoFloor(line, moveFloorByFrontSector);

  00151	6a 03		 push	 3
  00153	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _EV_DoFloor
  0015c	83 c4 08	 add	 esp, 8

; 1902 : 			break;

  0015f	e9 f4 16 00 00	 jmp	 $LN2@P_ProcessL
$LN43@P_ProcessL:

; 1903 : 
; 1904 : 		case 404: // Move ceiling, linelen = speed, frontsector ceiling = dest height
; 1905 : 			EV_DoCeiling(line, moveCeilingByFrontSector);

  00164	6a 0a		 push	 10			; 0000000aH
  00166	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _EV_DoCeiling
  0016f	83 c4 08	 add	 esp, 8

; 1906 : 			break;

  00172	e9 e1 16 00 00	 jmp	 $LN2@P_ProcessL
$LN44@P_ProcessL:

; 1907 : 
; 1908 : 		case 405: // Lower floor by line, dx = speed, dy = amount to lower
; 1909 : 			EV_DoFloor(line, lowerFloorByLine);

  00177	6a 05		 push	 5
  00179	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _EV_DoFloor
  00182	83 c4 08	 add	 esp, 8

; 1910 : 			break;

  00185	e9 ce 16 00 00	 jmp	 $LN2@P_ProcessL
$LN45@P_ProcessL:

; 1911 : 
; 1912 : 		case 406: // Raise floor by line, dx = speed, dy = amount to raise
; 1913 : 			EV_DoFloor(line, raiseFloorByLine);

  0018a	6a 06		 push	 6
  0018c	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 _EV_DoFloor
  00195	83 c4 08	 add	 esp, 8

; 1914 : 			break;

  00198	e9 bb 16 00 00	 jmp	 $LN2@P_ProcessL
$LN46@P_ProcessL:

; 1915 : 
; 1916 : 		case 407: // Lower ceiling by line, dx = speed, dy = amount to lower
; 1917 : 			EV_DoCeiling(line, lowerCeilingByLine);

  0019d	6a 0c		 push	 12			; 0000000cH
  0019f	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _EV_DoCeiling
  001a8	83 c4 08	 add	 esp, 8

; 1918 : 			break;

  001ab	e9 a8 16 00 00	 jmp	 $LN2@P_ProcessL
$LN47@P_ProcessL:

; 1919 : 
; 1920 : 		case 408: // Raise ceiling by line, dx = speed, dy = amount to raise
; 1921 : 			EV_DoCeiling(line, raiseCeilingByLine);

  001b0	6a 0d		 push	 13			; 0000000dH
  001b2	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _EV_DoCeiling
  001bb	83 c4 08	 add	 esp, 8

; 1922 : 			break;

  001be	e9 95 16 00 00	 jmp	 $LN2@P_ProcessL
$LN48@P_ProcessL:

; 1923 : 
; 1924 : 		case 409: // Change tagged sectors' tag
; 1925 : 		// (formerly "Change calling sectors' tag", but behavior
; 1926 : 		//  was changed)
; 1927 : 		{
; 1928 : 			while ((secnum = P_FindSectorFromLineTag(line,
; 1929 : 				secnum)) != -1)

  001c3	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  001ca	51		 push	 ecx
  001cb	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  001d0	83 c4 08	 add	 esp, 8
  001d3	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  001d6	83 7d f8 ff	 cmp	 DWORD PTR _secnum$[ebp], -1
  001da	74 28		 je	 SHORT $LN7@P_ProcessL

; 1930 : 			{
; 1931 : 				P_ChangeSectorTag(secnum,

  001dc	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  001df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001e2	51		 push	 ecx
  001e3	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  001e6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _P_AproxDistance
  001ef	83 c4 08	 add	 esp, 8
  001f2	c1 f8 10	 sar	 eax, 16			; 00000010H
  001f5	50		 push	 eax
  001f6	8b 4d f8	 mov	 ecx, DWORD PTR _secnum$[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _P_ChangeSectorTag
  001ff	83 c4 08	 add	 esp, 8

; 1932 : 					(INT16)(P_AproxDistance(line->dx, line->dy)
; 1933 : 					>>FRACBITS));
; 1934 : 			}

  00202	eb bf		 jmp	 SHORT $LN48@P_ProcessL
$LN7@P_ProcessL:

; 1935 : 			break;

  00204	e9 4f 16 00 00	 jmp	 $LN2@P_ProcessL
$LN49@P_ProcessL:

; 1936 : 		}
; 1937 : 
; 1938 : 		case 410: // Change front sector's tag
; 1939 : 			P_ChangeSectorTag((UINT32)(line->frontsector - sectors), (INT16)(P_AproxDistance(line->dx, line->dy)>>FRACBITS));

  00209	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0020c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0020f	51		 push	 ecx
  00210	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00213	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 _P_AproxDistance
  0021c	83 c4 08	 add	 esp, 8
  0021f	c1 f8 10	 sar	 eax, 16			; 00000010H
  00222	50		 push	 eax
  00223	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00226	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00229	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  0022f	99		 cdq
  00230	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00235	f7 f9		 idiv	 ecx
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _P_ChangeSectorTag
  0023d	83 c4 08	 add	 esp, 8

; 1940 : 			break;

  00240	e9 13 16 00 00	 jmp	 $LN2@P_ProcessL
$LN50@P_ProcessL:

; 1941 : 
; 1942 : 		case 411: // Stop floor/ceiling movement in tagged sector(s)
; 1943 : 			while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  00245	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00248	50		 push	 eax
  00249	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  0024c	51		 push	 ecx
  0024d	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00252	83 c4 08	 add	 esp, 8
  00255	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00258	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  0025c	0f 8c 57 01 00
	00		 jl	 $LN9@P_ProcessL

; 1944 : 			{
; 1945 : 				if (sectors[secnum].floordata)

  00262	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00269	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0026f	83 7c 01 44 00	 cmp	 DWORD PTR [ecx+eax+68], 0
  00274	0f 84 df 00 00
	00		 je	 $LN53@P_ProcessL

; 1946 : 				{
; 1947 : 					if (sectors[secnum].floordata == sectors[secnum].ceilingdata) // elevator

  0027a	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00281	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00288	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0028e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  00294	8b 44 02 44	 mov	 eax, DWORD PTR [edx+eax+68]
  00298	3b 44 0e 48	 cmp	 eax, DWORD PTR [esi+ecx+72]
  0029c	75 74		 jne	 SHORT $LN52@P_ProcessL

; 1948 : 					{
; 1949 : 						P_RemoveThinker(&((elevator_t *)sectors[secnum].floordata)->thinker);

  0029e	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  002ab	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  002af	52		 push	 edx
  002b0	e8 00 00 00 00	 call	 _P_RemoveThinker
  002b5	83 c4 04	 add	 esp, 4

; 1950 : 						sectors[secnum].floordata = sectors[secnum].ceilingdata = NULL;

  002b8	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  002bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  002c5	c7 44 01 48 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+72], 0
  002cd	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _secnum$[ebp], 248
  002d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  002d9	c7 44 10 44 00
	00 00 00	 mov	 DWORD PTR [eax+edx+68], 0

; 1951 : 						sectors[secnum].floorspeed = sectors[secnum].ceilspeed = 0;

  002e1	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  002ee	c7 84 01 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+236], 0
  002f9	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _secnum$[ebp], 248
  00300	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00305	c7 84 10 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+232], 0

; 1952 : 					}

  00310	eb 47		 jmp	 SHORT $LN53@P_ProcessL
$LN52@P_ProcessL:

; 1953 : 					else // floormove
; 1954 : 					{
; 1955 : 						P_RemoveThinker(&((floormove_t *)sectors[secnum].floordata)->thinker);

  00312	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00319	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0031f	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  00323	52		 push	 edx
  00324	e8 00 00 00 00	 call	 _P_RemoveThinker
  00329	83 c4 04	 add	 esp, 4

; 1956 : 						sectors[secnum].floordata = NULL;

  0032c	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00333	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00339	c7 44 01 44 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+68], 0

; 1957 : 						sectors[secnum].floorspeed = 0;

  00341	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00348	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0034e	c7 84 01 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+232], 0
$LN53@P_ProcessL:

; 1958 : 					}
; 1959 : 				}
; 1960 : 
; 1961 : 				if (sectors[secnum].ceilingdata) // ceiling

  00359	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00360	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00366	83 7c 01 48 00	 cmp	 DWORD PTR [ecx+eax+72], 0
  0036b	74 47		 je	 SHORT $LN54@P_ProcessL

; 1962 : 				{
; 1963 : 					P_RemoveThinker(&((ceiling_t *)sectors[secnum].ceilingdata)->thinker);

  0036d	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00374	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0037a	8b 54 01 48	 mov	 edx, DWORD PTR [ecx+eax+72]
  0037e	52		 push	 edx
  0037f	e8 00 00 00 00	 call	 _P_RemoveThinker
  00384	83 c4 04	 add	 esp, 4

; 1964 : 					sectors[secnum].ceilingdata = NULL;

  00387	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  0038e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00394	c7 44 01 48 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+72], 0

; 1965 : 					sectors[secnum].ceilspeed = 0;

  0039c	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  003a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  003a9	c7 84 01 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+236], 0
$LN54@P_ProcessL:

; 1966 : 				}
; 1967 : 			}

  003b4	e9 8c fe ff ff	 jmp	 $LN50@P_ProcessL
$LN9@P_ProcessL:

; 1968 : 			break;

  003b9	e9 9a 14 00 00	 jmp	 $LN2@P_ProcessL
$LN55@P_ProcessL:

; 1969 : 
; 1970 : 		case 412: // Teleport the player or thing
; 1971 : 			{
; 1972 : 				mobj_t *dest;
; 1973 : 
; 1974 : 				if (!mo) // nothing to teleport

  003be	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  003c2	75 05		 jne	 SHORT $LN56@P_ProcessL

; 1975 : 					return;

  003c4	e9 8f 14 00 00	 jmp	 $LN2@P_ProcessL
$LN56@P_ProcessL:

; 1976 : 
; 1977 : 				if (line->flags & ML_EFFECT3) // Relative silent teleport

  003c9	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  003cc	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  003d0	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  003d6	0f 84 78 01 00
	00		 je	 $LN57@P_ProcessL

; 1978 : 				{
; 1979 : 					fixed_t x,y,z;
; 1980 : 
; 1981 : 					x = sides[line->sidenum[0]].textureoffset;

  003dc	b8 02 00 00 00	 mov	 eax, 2
  003e1	6b c8 00	 imul	 ecx, eax, 0
  003e4	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  003e7	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  003ec	6b c8 1c	 imul	 ecx, eax, 28
  003ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  003f5	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  003f8	89 45 e4	 mov	 DWORD PTR _x$30[ebp], eax

; 1982 : 					y = sides[line->sidenum[0]].rowoffset;

  003fb	b8 02 00 00 00	 mov	 eax, 2
  00400	6b c8 00	 imul	 ecx, eax, 0
  00403	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00406	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0040b	6b c8 1c	 imul	 ecx, eax, 28
  0040e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00414	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00418	89 45 e0	 mov	 DWORD PTR _y$29[ebp], eax

; 1983 : 					z = line->frontsector->ceilingheight;

  0041b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0041e	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00421	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00424	89 55 dc	 mov	 DWORD PTR _z$28[ebp], edx

; 1984 : 
; 1985 : 					P_UnsetThingPosition(mo);

  00427	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0042a	50		 push	 eax
  0042b	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  00430	83 c4 04	 add	 esp, 4

; 1986 : 					mo->x += x;

  00433	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00436	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00439	03 4d e4	 add	 ecx, DWORD PTR _x$30[ebp]
  0043c	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0043f	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1987 : 					mo->y += y;

  00442	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00445	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00448	03 4d e0	 add	 ecx, DWORD PTR _y$29[ebp]
  0044b	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0044e	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1988 : 					mo->z += z;

  00451	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00454	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00457	03 4d dc	 add	 ecx, DWORD PTR _z$28[ebp]
  0045a	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0045d	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1989 : 					P_SetThingPosition(mo);

  00460	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00463	50		 push	 eax
  00464	e8 00 00 00 00	 call	 _P_SetThingPosition
  00469	83 c4 04	 add	 esp, 4

; 1990 : 
; 1991 : 					if (mo->player)

  0046c	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0046f	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00476	0f 84 d3 00 00
	00		 je	 $LN62@P_ProcessL

; 1992 : 					{
; 1993 : 						if (splitscreen && mo->player == &players[secondarydisplayplayer] && camera2.chase)

  0047c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00483	74 66		 je	 SHORT $LN60@P_ProcessL
  00485	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0048f	05 00 00 00 00	 add	 eax, OFFSET _players
  00494	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00497	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  0049d	75 4c		 jne	 SHORT $LN60@P_ProcessL
  0049f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _camera2, 0
  004a6	74 43		 je	 SHORT $LN60@P_ProcessL

; 1994 : 						{
; 1995 : 							camera2.x += x;

  004a8	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera2+16
  004ad	03 45 e4	 add	 eax, DWORD PTR _x$30[ebp]
  004b0	a3 10 00 00 00	 mov	 DWORD PTR _camera2+16, eax

; 1996 : 							camera2.y += y;

  004b5	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera2+20
  004ba	03 45 e0	 add	 eax, DWORD PTR _y$29[ebp]
  004bd	a3 14 00 00 00	 mov	 DWORD PTR _camera2+20, eax

; 1997 : 							camera2.z += z;

  004c2	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera2+24
  004c7	03 45 dc	 add	 eax, DWORD PTR _z$28[ebp]
  004ca	a3 18 00 00 00	 mov	 DWORD PTR _camera2+24, eax

; 1998 : 							camera2.subsector = R_PointInSubsector(camera2.x, camera2.y);

  004cf	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera2+20
  004d4	50		 push	 eax
  004d5	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _camera2+16
  004db	51		 push	 ecx
  004dc	e8 00 00 00 00	 call	 _R_PointInSubsector
  004e1	83 c4 08	 add	 esp, 8
  004e4	a3 20 00 00 00	 mov	 DWORD PTR _camera2+32, eax

; 1999 : 						}

  004e9	eb 64		 jmp	 SHORT $LN62@P_ProcessL
$LN60@P_ProcessL:

; 2000 : 						else if (camera.chase && mo->player == &players[displayplayer])

  004eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _camera, 0
  004f2	74 5b		 je	 SHORT $LN62@P_ProcessL
  004f4	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  004fe	05 00 00 00 00	 add	 eax, OFFSET _players
  00503	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00506	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  0050c	75 41		 jne	 SHORT $LN62@P_ProcessL

; 2001 : 						{
; 2002 : 							camera.x += x;

  0050e	a1 10 00 00 00	 mov	 eax, DWORD PTR _camera+16
  00513	03 45 e4	 add	 eax, DWORD PTR _x$30[ebp]
  00516	a3 10 00 00 00	 mov	 DWORD PTR _camera+16, eax

; 2003 : 							camera.y += y;

  0051b	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera+20
  00520	03 45 e0	 add	 eax, DWORD PTR _y$29[ebp]
  00523	a3 14 00 00 00	 mov	 DWORD PTR _camera+20, eax

; 2004 : 							camera.z += z;

  00528	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera+24
  0052d	03 45 dc	 add	 eax, DWORD PTR _z$28[ebp]
  00530	a3 18 00 00 00	 mov	 DWORD PTR _camera+24, eax

; 2005 : 							camera.subsector = R_PointInSubsector(camera.x, camera.y);

  00535	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera+20
  0053a	50		 push	 eax
  0053b	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _camera+16
  00541	51		 push	 ecx
  00542	e8 00 00 00 00	 call	 _R_PointInSubsector
  00547	83 c4 08	 add	 esp, 8
  0054a	a3 20 00 00 00	 mov	 DWORD PTR _camera+32, eax
$LN62@P_ProcessL:

; 2006 : 						}
; 2007 : 					}
; 2008 : 				}

  0054f	e9 13 01 00 00	 jmp	 $LN66@P_ProcessL
$LN57@P_ProcessL:

; 2009 : 				else
; 2010 : 				{
; 2011 : 					if ((secnum = P_FindSectorFromLineTag(line, -1)) < 0)

  00554	6a ff		 push	 -1
  00556	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00559	50		 push	 eax
  0055a	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  0055f	83 c4 08	 add	 esp, 8
  00562	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00565	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  00569	7d 05		 jge	 SHORT $LN63@P_ProcessL

; 2012 : 						return;

  0056b	e9 e8 12 00 00	 jmp	 $LN2@P_ProcessL
$LN63@P_ProcessL:

; 2013 : 
; 2014 : 					dest = P_GetObjectTypeInSectorNum(MT_TELEPORTMAN, secnum);

  00570	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00573	50		 push	 eax
  00574	68 02 01 00 00	 push	 258			; 00000102H
  00579	e8 00 00 00 00	 call	 _P_GetObjectTypeInSectorNum
  0057e	83 c4 08	 add	 esp, 8
  00581	89 45 e8	 mov	 DWORD PTR _dest$31[ebp], eax

; 2015 : 					if (!dest)

  00584	83 7d e8 00	 cmp	 DWORD PTR _dest$31[ebp], 0
  00588	75 05		 jne	 SHORT $LN64@P_ProcessL

; 2016 : 						return;

  0058a	e9 c9 12 00 00	 jmp	 $LN2@P_ProcessL
$LN64@P_ProcessL:

; 2017 : 
; 2018 : 					if (line->flags & ML_BLOCKMONSTERS)

  0058f	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00592	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00596	83 e1 02	 and	 ecx, 2
  00599	74 60		 je	 SHORT $LN65@P_ProcessL

; 2019 : 						P_Teleport(mo, dest->x, dest->y, dest->z, (line->flags & ML_NOCLIMB) ?  mo->angle : dest->angle, false, (line->flags & ML_EFFECT4));

  0059b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0059e	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  005a2	83 e1 40	 and	 ecx, 64			; 00000040H
  005a5	74 0e		 je	 SHORT $LN196@P_ProcessL
  005a7	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  005aa	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  005ad	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv310[ebp], eax
  005b3	eb 0c		 jmp	 SHORT $LN197@P_ProcessL
$LN196@P_ProcessL:
  005b5	8b 4d e8	 mov	 ecx, DWORD PTR _dest$31[ebp]
  005b8	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  005bb	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv310[ebp], edx
$LN197@P_ProcessL:
  005c1	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  005c4	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  005c8	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  005ce	51		 push	 ecx
  005cf	6a 00		 push	 0
  005d1	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv310[ebp]
  005d7	52		 push	 edx
  005d8	8b 45 e8	 mov	 eax, DWORD PTR _dest$31[ebp]
  005db	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005de	51		 push	 ecx
  005df	8b 55 e8	 mov	 edx, DWORD PTR _dest$31[ebp]
  005e2	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  005e5	50		 push	 eax
  005e6	8b 4d e8	 mov	 ecx, DWORD PTR _dest$31[ebp]
  005e9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  005ec	52		 push	 edx
  005ed	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  005f0	50		 push	 eax
  005f1	e8 00 00 00 00	 call	 _P_Teleport
  005f6	83 c4 1c	 add	 esp, 28			; 0000001cH
  005f9	eb 6c		 jmp	 SHORT $LN66@P_ProcessL
$LN65@P_ProcessL:

; 2020 : 					else
; 2021 : 					{
; 2022 : 						P_Teleport(mo, dest->x, dest->y, dest->z, (line->flags & ML_NOCLIMB) ?  mo->angle : dest->angle, true, (line->flags & ML_EFFECT4));

  005fb	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  005fe	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00602	83 e1 40	 and	 ecx, 64			; 00000040H
  00605	74 0e		 je	 SHORT $LN198@P_ProcessL
  00607	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0060a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0060d	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv330[ebp], eax
  00613	eb 0c		 jmp	 SHORT $LN199@P_ProcessL
$LN198@P_ProcessL:
  00615	8b 4d e8	 mov	 ecx, DWORD PTR _dest$31[ebp]
  00618	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0061b	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv330[ebp], edx
$LN199@P_ProcessL:
  00621	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00624	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00628	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0062e	51		 push	 ecx
  0062f	6a 01		 push	 1
  00631	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv330[ebp]
  00637	52		 push	 edx
  00638	8b 45 e8	 mov	 eax, DWORD PTR _dest$31[ebp]
  0063b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0063e	51		 push	 ecx
  0063f	8b 55 e8	 mov	 edx, DWORD PTR _dest$31[ebp]
  00642	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00645	50		 push	 eax
  00646	8b 4d e8	 mov	 ecx, DWORD PTR _dest$31[ebp]
  00649	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0064c	52		 push	 edx
  0064d	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00650	50		 push	 eax
  00651	e8 00 00 00 00	 call	 _P_Teleport
  00656	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2023 : 						// Play the 'bowrwoosh!' sound
; 2024 : 						S_StartSound(dest, sfx_mixup);

  00659	6a 68		 push	 104			; 00000068H
  0065b	8b 45 e8	 mov	 eax, DWORD PTR _dest$31[ebp]
  0065e	50		 push	 eax
  0065f	e8 00 00 00 00	 call	 _S_StartSound
  00664	83 c4 08	 add	 esp, 8
$LN66@P_ProcessL:

; 2025 : 					}
; 2026 : 				}
; 2027 : 			}
; 2028 : 			break;

  00667	e9 ec 11 00 00	 jmp	 $LN2@P_ProcessL
$LN67@P_ProcessL:

; 2029 : 
; 2030 : 		case 413: // Change music
; 2031 : 			if (mo && mo->player && P_IsLocalPlayer(mo->player)) // console player only

  0066c	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  00670	0f 84 c1 00 00
	00		 je	 $LN68@P_ProcessL
  00676	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00679	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00680	0f 84 b1 00 00
	00		 je	 $LN68@P_ProcessL
  00686	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00689	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0068f	51		 push	 ecx
  00690	e8 00 00 00 00	 call	 _P_IsLocalPlayer
  00695	83 c4 04	 add	 esp, 4
  00698	85 c0		 test	 eax, eax
  0069a	0f 84 97 00 00
	00		 je	 $LN68@P_ProcessL

; 2032 : 			{
; 2033 : 				fixed_t musicnum;
; 2034 : 
; 2035 : 				musicnum = P_AproxDistance(line->dx, line->dy)>>FRACBITS;

  006a0	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  006a3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  006a6	51		 push	 ecx
  006a7	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  006aa	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  006ad	50		 push	 eax
  006ae	e8 00 00 00 00	 call	 _P_AproxDistance
  006b3	83 c4 08	 add	 esp, 8
  006b6	c1 f8 10	 sar	 eax, 16			; 00000010H
  006b9	89 45 d8	 mov	 DWORD PTR _musicnum$27[ebp], eax

; 2036 : 
; 2037 : 				if (line->flags & ML_BLOCKMONSTERS)

  006bc	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  006bf	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  006c3	83 e1 02	 and	 ecx, 2
  006c6	74 0b		 je	 SHORT $LN69@P_ProcessL

; 2038 : 					musicnum += 2048;

  006c8	8b 45 d8	 mov	 eax, DWORD PTR _musicnum$27[ebp]
  006cb	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  006d0	89 45 d8	 mov	 DWORD PTR _musicnum$27[ebp], eax
$LN69@P_ProcessL:

; 2039 : 
; 2040 : 				if ((musicnum & ~2048) < NUMMUSIC && (musicnum & ~2048) > mus_None)

  006d3	8b 45 d8	 mov	 eax, DWORD PTR _musicnum$27[ebp]
  006d6	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  006db	3d 1a 04 00 00	 cmp	 eax, 1050		; 0000041aH
  006e0	7d 46		 jge	 SHORT $LN70@P_ProcessL
  006e2	8b 45 d8	 mov	 eax, DWORD PTR _musicnum$27[ebp]
  006e5	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  006ea	7e 3c		 jle	 SHORT $LN70@P_ProcessL

; 2041 : 					S_ChangeMusic(musicnum & 2047, !(line->flags & ML_NOCLIMB));

  006ec	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  006ef	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  006f3	83 e1 40	 and	 ecx, 64			; 00000040H
  006f6	75 0c		 jne	 SHORT $LN200@P_ProcessL
  006f8	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv366[ebp], 1
  00702	eb 0a		 jmp	 SHORT $LN201@P_ProcessL
$LN200@P_ProcessL:
  00704	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv366[ebp], 0
$LN201@P_ProcessL:
  0070e	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv366[ebp]
  00714	52		 push	 edx
  00715	8b 45 d8	 mov	 eax, DWORD PTR _musicnum$27[ebp]
  00718	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0071d	50		 push	 eax
  0071e	e8 00 00 00 00	 call	 _S_ChangeMusic
  00723	83 c4 08	 add	 esp, 8
  00726	eb 06		 jmp	 SHORT $LN71@P_ProcessL
$LN70@P_ProcessL:

; 2042 : 				else
; 2043 : 					S_StopMusic();

  00728	e8 00 00 00 00	 call	 _S_StopMusic
  0072d	90		 npad	 1
$LN71@P_ProcessL:

; 2044 : 
; 2045 : 				mapmusic = (INT16)musicnum; // but it gets reset if you die

  0072e	0f bf 45 d8	 movsx	 eax, WORD PTR _musicnum$27[ebp]
  00732	a3 00 00 00 00	 mov	 DWORD PTR _mapmusic, eax
$LN68@P_ProcessL:

; 2046 : 
; 2047 : 				// Except, you can use the ML_BLOCKMONSTERS flag to change this behavior.
; 2048 : 				// if (mapmusic & 2048) then it won't reset the music in G_PlayerReborn as usual.
; 2049 : 				// This is why I do the crazy anding with musicnum above.
; 2050 : 			}
; 2051 : 			break;

  00737	e9 1c 11 00 00	 jmp	 $LN2@P_ProcessL
$LN72@P_ProcessL:

; 2052 : 
; 2053 : 		case 414: // Play SFX
; 2054 : 			{
; 2055 : 				fixed_t sfxnum;
; 2056 : 
; 2057 : 				sfxnum = P_AproxDistance(line->dx, line->dy)>>FRACBITS;

  0073c	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0073f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00742	51		 push	 ecx
  00743	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00746	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00749	50		 push	 eax
  0074a	e8 00 00 00 00	 call	 _P_AproxDistance
  0074f	83 c4 08	 add	 esp, 8
  00752	c1 f8 10	 sar	 eax, 16			; 00000010H
  00755	89 45 d4	 mov	 DWORD PTR _sfxnum$26[ebp], eax

; 2058 : 
; 2059 : 				if (line->tag != 0 && line->flags & ML_EFFECT5)

  00758	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0075b	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0075f	85 c9		 test	 ecx, ecx
  00761	74 52		 je	 SHORT $LN73@P_ProcessL
  00763	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00766	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0076a	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00770	74 43		 je	 SHORT $LN73@P_ProcessL
$LN10@P_ProcessL:

; 2060 : 				{
; 2061 : 					sector_t *sec;
; 2062 : 
; 2063 : 					while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  00772	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00775	50		 push	 eax
  00776	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00779	51		 push	 ecx
  0077a	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  0077f	83 c4 08	 add	 esp, 8
  00782	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00785	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  00789	7c 25		 jl	 SHORT $LN11@P_ProcessL

; 2064 : 					{
; 2065 : 						sec = &sectors[secnum];

  0078b	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00792	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00798	89 45 d0	 mov	 DWORD PTR _sec$25[ebp], eax

; 2066 : 						S_StartSound(&sec->soundorg, sfxnum);

  0079b	8b 45 d4	 mov	 eax, DWORD PTR _sfxnum$26[ebp]
  0079e	50		 push	 eax
  0079f	8b 4d d0	 mov	 ecx, DWORD PTR _sec$25[ebp]
  007a2	83 c1 20	 add	 ecx, 32			; 00000020H
  007a5	51		 push	 ecx
  007a6	e8 00 00 00 00	 call	 _S_StartSound
  007ab	83 c4 08	 add	 esp, 8

; 2067 : 					}

  007ae	eb c2		 jmp	 SHORT $LN10@P_ProcessL
$LN11@P_ProcessL:

; 2068 : 				}

  007b0	e9 b7 00 00 00	 jmp	 $LN80@P_ProcessL
$LN73@P_ProcessL:

; 2069 : 				else if (line->tag != 0 && mo)

  007b5	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  007b8	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  007bc	85 c9		 test	 ecx, ecx
  007be	0f 84 a8 00 00
	00		 je	 $LN80@P_ProcessL
  007c4	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  007c8	0f 84 9e 00 00
	00		 je	 $LN80@P_ProcessL

; 2070 : 				{
; 2071 : 					// Only trigger if mobj is touching the tag
; 2072 : 					ffloor_t *rover;
; 2073 : 					boolean foundit = false;

  007ce	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _foundit$23[ebp], 0

; 2074 : 
; 2075 : 					for(rover = mo->subsector->sector->ffloors; rover; rover = rover->next)

  007d5	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  007d8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  007db	8b 11		 mov	 edx, DWORD PTR [ecx]
  007dd	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  007e3	89 45 cc	 mov	 DWORD PTR _rover$24[ebp], eax
  007e6	eb 09		 jmp	 SHORT $LN14@P_ProcessL
$LN12@P_ProcessL:
  007e8	8b 45 cc	 mov	 eax, DWORD PTR _rover$24[ebp]
  007eb	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  007ee	89 4d cc	 mov	 DWORD PTR _rover$24[ebp], ecx
$LN14@P_ProcessL:
  007f1	83 7d cc 00	 cmp	 DWORD PTR _rover$24[ebp], 0
  007f5	74 4c		 je	 SHORT $LN13@P_ProcessL

; 2076 : 					{
; 2077 : 						if (rover->master->frontsector->tag != line->tag)

  007f7	8b 45 cc	 mov	 eax, DWORD PTR _rover$24[ebp]
  007fa	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  007fd	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00800	0f bf 42 14	 movsx	 eax, WORD PTR [edx+20]
  00804	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00807	0f bf 51 14	 movsx	 edx, WORD PTR [ecx+20]
  0080b	3b c2		 cmp	 eax, edx
  0080d	74 02		 je	 SHORT $LN76@P_ProcessL

; 2078 : 							continue;

  0080f	eb d7		 jmp	 SHORT $LN12@P_ProcessL
$LN76@P_ProcessL:

; 2079 : 
; 2080 : 						if (mo->z > *rover->topheight)

  00811	8b 45 cc	 mov	 eax, DWORD PTR _rover$24[ebp]
  00814	8b 08		 mov	 ecx, DWORD PTR [eax]
  00816	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  00819	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0081c	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0081e	7e 02		 jle	 SHORT $LN77@P_ProcessL

; 2081 : 							continue;

  00820	eb c6		 jmp	 SHORT $LN12@P_ProcessL
$LN77@P_ProcessL:

; 2082 : 
; 2083 : 						if (mo->z + mo->height < *rover->bottomheight)

  00822	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00825	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00828	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0082b	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0082e	8b 45 cc	 mov	 eax, DWORD PTR _rover$24[ebp]
  00831	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00834	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00836	7d 02		 jge	 SHORT $LN78@P_ProcessL

; 2084 : 							continue;

  00838	eb ae		 jmp	 SHORT $LN12@P_ProcessL
$LN78@P_ProcessL:

; 2085 : 
; 2086 : 						foundit = true;

  0083a	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _foundit$23[ebp], 1

; 2087 : 					}

  00841	eb a5		 jmp	 SHORT $LN12@P_ProcessL
$LN13@P_ProcessL:

; 2088 : 
; 2089 : 					if (mo->subsector->sector->tag == line->tag)

  00843	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00846	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00849	8b 11		 mov	 edx, DWORD PTR [ecx]
  0084b	0f bf 42 14	 movsx	 eax, WORD PTR [edx+20]
  0084f	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00852	0f bf 51 14	 movsx	 edx, WORD PTR [ecx+20]
  00856	3b c2		 cmp	 eax, edx
  00858	75 07		 jne	 SHORT $LN79@P_ProcessL

; 2090 : 						foundit = true;

  0085a	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _foundit$23[ebp], 1
$LN79@P_ProcessL:

; 2091 : 
; 2092 : 					if (!foundit)

  00861	83 7d c8 00	 cmp	 DWORD PTR _foundit$23[ebp], 0
  00865	75 05		 jne	 SHORT $LN80@P_ProcessL

; 2093 : 						return;

  00867	e9 ec 0f 00 00	 jmp	 $LN2@P_ProcessL
$LN80@P_ProcessL:

; 2094 : 				}
; 2095 : 
; 2096 : 				if (sfxnum < NUMSFX && sfxnum > sfx_None)

  0086c	81 7d d4 63 07
	00 00		 cmp	 DWORD PTR _sfxnum$26[ebp], 1891 ; 00000763H
  00873	0f 8d f1 00 00
	00		 jge	 $LN93@P_ProcessL
  00879	83 7d d4 00	 cmp	 DWORD PTR _sfxnum$26[ebp], 0
  0087d	0f 8e e7 00 00
	00		 jle	 $LN93@P_ProcessL

; 2097 : 				{
; 2098 : 					if (line->flags & ML_NOCLIMB)

  00883	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00886	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0088a	83 e1 40	 and	 ecx, 64			; 00000040H
  0088d	74 59		 je	 SHORT $LN82@P_ProcessL

; 2099 : 					{
; 2100 : 						// play the sound from nowhere, but only if display player triggered it
; 2101 : 						if (mo && mo->player && (mo->player == &players[displayplayer] || mo->player == &players[secondarydisplayplayer]))

  0088f	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  00893	74 4e		 je	 SHORT $LN84@P_ProcessL
  00895	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00898	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0089f	74 42		 je	 SHORT $LN84@P_ProcessL
  008a1	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  008ab	05 00 00 00 00	 add	 eax, OFFSET _players
  008b0	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  008b3	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  008b9	74 1a		 je	 SHORT $LN85@P_ProcessL
  008bb	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  008c5	05 00 00 00 00	 add	 eax, OFFSET _players
  008ca	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  008cd	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  008d3	75 0e		 jne	 SHORT $LN84@P_ProcessL
$LN85@P_ProcessL:

; 2102 : 							S_StartSound(NULL, sfxnum);

  008d5	8b 45 d4	 mov	 eax, DWORD PTR _sfxnum$26[ebp]
  008d8	50		 push	 eax
  008d9	6a 00		 push	 0
  008db	e8 00 00 00 00	 call	 _S_StartSound
  008e0	83 c4 08	 add	 esp, 8
$LN84@P_ProcessL:

; 2103 : 					}

  008e3	e9 82 00 00 00	 jmp	 $LN93@P_ProcessL
$LN82@P_ProcessL:

; 2104 : 					else if (line->flags & ML_EFFECT4)

  008e8	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  008eb	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  008ef	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  008f5	74 10		 je	 SHORT $LN86@P_ProcessL

; 2105 : 					{
; 2106 : 						// play the sound from nowhere
; 2107 : 						S_StartSound(NULL, sfxnum);

  008f7	8b 45 d4	 mov	 eax, DWORD PTR _sfxnum$26[ebp]
  008fa	50		 push	 eax
  008fb	6a 00		 push	 0
  008fd	e8 00 00 00 00	 call	 _S_StartSound
  00902	83 c4 08	 add	 esp, 8

; 2108 : 					}

  00905	eb 63		 jmp	 SHORT $LN93@P_ProcessL
$LN86@P_ProcessL:

; 2109 : 					else if (line->flags & ML_BLOCKMONSTERS)

  00907	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0090a	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0090e	83 e1 02	 and	 ecx, 2
  00911	74 41		 je	 SHORT $LN88@P_ProcessL

; 2110 : 					{
; 2111 : 						// play the sound from calling sector's soundorg
; 2112 : 						if (triplinecaller)

  00913	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _triplinecaller, 0
  0091a	74 18		 je	 SHORT $LN90@P_ProcessL

; 2113 : 							S_StartSound(&triplinecaller->soundorg, sfxnum);

  0091c	8b 45 d4	 mov	 eax, DWORD PTR _sfxnum$26[ebp]
  0091f	50		 push	 eax
  00920	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _triplinecaller
  00926	83 c1 20	 add	 ecx, 32			; 00000020H
  00929	51		 push	 ecx
  0092a	e8 00 00 00 00	 call	 _S_StartSound
  0092f	83 c4 08	 add	 esp, 8
  00932	eb 1e		 jmp	 SHORT $LN92@P_ProcessL
$LN90@P_ProcessL:

; 2114 : 						else if (mo)

  00934	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  00938	74 18		 je	 SHORT $LN92@P_ProcessL

; 2115 : 							S_StartSound(&mo->subsector->sector->soundorg, sfxnum);

  0093a	8b 45 d4	 mov	 eax, DWORD PTR _sfxnum$26[ebp]
  0093d	50		 push	 eax
  0093e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00941	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00944	8b 02		 mov	 eax, DWORD PTR [edx]
  00946	83 c0 20	 add	 eax, 32			; 00000020H
  00949	50		 push	 eax
  0094a	e8 00 00 00 00	 call	 _S_StartSound
  0094f	83 c4 08	 add	 esp, 8
$LN92@P_ProcessL:

; 2116 : 					}

  00952	eb 16		 jmp	 SHORT $LN93@P_ProcessL
$LN88@P_ProcessL:

; 2117 : 					else if (mo)

  00954	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  00958	74 10		 je	 SHORT $LN93@P_ProcessL

; 2118 : 					{
; 2119 : 						// play the sound from mobj that triggered it
; 2120 : 						S_StartSound(mo, sfxnum);

  0095a	8b 45 d4	 mov	 eax, DWORD PTR _sfxnum$26[ebp]
  0095d	50		 push	 eax
  0095e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00961	51		 push	 ecx
  00962	e8 00 00 00 00	 call	 _S_StartSound
  00967	83 c4 08	 add	 esp, 8
$LN93@P_ProcessL:

; 2121 : 					}
; 2122 : 				}
; 2123 : 			}
; 2124 : 			break;

  0096a	e9 e9 0e 00 00	 jmp	 $LN2@P_ProcessL
$LN94@P_ProcessL:

; 2125 : 
; 2126 : 		case 415: // Run a script
; 2127 : 			if (cv_runscripts.value)

  0096f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_runscripts+20, 0
  00976	0f 84 64 01 00
	00		 je	 $LN99@P_ProcessL

; 2128 : 			{
; 2129 : 				INT32 scrnum;
; 2130 : 				lumpnum_t lumpnum;
; 2131 : 				char newname[9];
; 2132 : 
; 2133 : 				strcpy(newname, G_BuildMapName(gamemap));

  0097c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00983	50		 push	 eax
  00984	e8 00 00 00 00	 call	 _G_BuildMapName
  00989	83 c4 04	 add	 esp, 4
  0098c	50		 push	 eax
  0098d	8d 4d b4	 lea	 ecx, DWORD PTR _newname$20[ebp]
  00990	51		 push	 ecx
  00991	e8 00 00 00 00	 call	 _strcpy
  00996	83 c4 08	 add	 esp, 8

; 2134 : 				newname[0] = 'S';

  00999	b8 01 00 00 00	 mov	 eax, 1
  0099e	6b c8 00	 imul	 ecx, eax, 0
  009a1	c6 44 0d b4 53	 mov	 BYTE PTR _newname$20[ebp+ecx], 83 ; 00000053H

; 2135 : 				newname[1] = 'C';

  009a6	b8 01 00 00 00	 mov	 eax, 1
  009ab	c1 e0 00	 shl	 eax, 0
  009ae	c6 44 05 b4 43	 mov	 BYTE PTR _newname$20[ebp+eax], 67 ; 00000043H

; 2136 : 				newname[2] = 'R';

  009b3	b8 01 00 00 00	 mov	 eax, 1
  009b8	d1 e0		 shl	 eax, 1
  009ba	c6 44 05 b4 52	 mov	 BYTE PTR _newname$20[ebp+eax], 82 ; 00000052H

; 2137 : 
; 2138 : 				scrnum = line->frontsector->floorheight>>FRACBITS;

  009bf	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  009c2	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  009c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  009c7	c1 fa 10	 sar	 edx, 16			; 00000010H
  009ca	89 55 c4	 mov	 DWORD PTR _scrnum$22[ebp], edx

; 2139 : 				if (scrnum > 999)

  009cd	81 7d c4 e7 03
	00 00		 cmp	 DWORD PTR _scrnum$22[ebp], 999 ; 000003e7H
  009d4	7e 30		 jle	 SHORT $LN96@P_ProcessL

; 2140 : 				{
; 2141 : 					scrnum = 0;

  009d6	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _scrnum$22[ebp], 0

; 2142 : 					newname[5] = newname[6] = newname[7] = '0';

  009dd	b8 01 00 00 00	 mov	 eax, 1
  009e2	6b c8 07	 imul	 ecx, eax, 7
  009e5	c6 44 0d b4 30	 mov	 BYTE PTR _newname$20[ebp+ecx], 48 ; 00000030H
  009ea	ba 01 00 00 00	 mov	 edx, 1
  009ef	6b c2 06	 imul	 eax, edx, 6
  009f2	c6 44 05 b4 30	 mov	 BYTE PTR _newname$20[ebp+eax], 48 ; 00000030H
  009f7	b9 01 00 00 00	 mov	 ecx, 1
  009fc	6b d1 05	 imul	 edx, ecx, 5
  009ff	c6 44 15 b4 30	 mov	 BYTE PTR _newname$20[ebp+edx], 48 ; 00000030H

; 2143 : 				}

  00a04	eb 61		 jmp	 SHORT $LN97@P_ProcessL
$LN96@P_ProcessL:

; 2144 : 				else
; 2145 : 				{
; 2146 : 					newname[5] = (char)('0' + (char)((scrnum/100)));

  00a06	8b 45 c4	 mov	 eax, DWORD PTR _scrnum$22[ebp]
  00a09	99		 cdq
  00a0a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a0f	f7 f9		 idiv	 ecx
  00a11	0f be d0	 movsx	 edx, al
  00a14	83 c2 30	 add	 edx, 48			; 00000030H
  00a17	b8 01 00 00 00	 mov	 eax, 1
  00a1c	6b c8 05	 imul	 ecx, eax, 5
  00a1f	88 54 0d b4	 mov	 BYTE PTR _newname$20[ebp+ecx], dl

; 2147 : 					newname[6] = (char)('0' + (char)((scrnum%100)/10));

  00a23	8b 45 c4	 mov	 eax, DWORD PTR _scrnum$22[ebp]
  00a26	99		 cdq
  00a27	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a2c	f7 f9		 idiv	 ecx
  00a2e	8b c2		 mov	 eax, edx
  00a30	99		 cdq
  00a31	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00a36	f7 f9		 idiv	 ecx
  00a38	0f be d0	 movsx	 edx, al
  00a3b	83 c2 30	 add	 edx, 48			; 00000030H
  00a3e	b8 01 00 00 00	 mov	 eax, 1
  00a43	6b c8 06	 imul	 ecx, eax, 6
  00a46	88 54 0d b4	 mov	 BYTE PTR _newname$20[ebp+ecx], dl

; 2148 : 					newname[7] = (char)('0' + (char)(scrnum%10));

  00a4a	8b 45 c4	 mov	 eax, DWORD PTR _scrnum$22[ebp]
  00a4d	99		 cdq
  00a4e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00a53	f7 f9		 idiv	 ecx
  00a55	0f be d2	 movsx	 edx, dl
  00a58	83 c2 30	 add	 edx, 48			; 00000030H
  00a5b	b8 01 00 00 00	 mov	 eax, 1
  00a60	6b c8 07	 imul	 ecx, eax, 7
  00a63	88 54 0d b4	 mov	 BYTE PTR _newname$20[ebp+ecx], dl
$LN97@P_ProcessL:

; 2149 : 				}
; 2150 : 				newname[8] = '\0';

  00a67	b8 01 00 00 00	 mov	 eax, 1
  00a6c	c1 e0 03	 shl	 eax, 3
  00a6f	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00a75	83 bd 28 ff ff
	ff 09		 cmp	 DWORD PTR $T1[ebp], 9
  00a7c	73 02		 jae	 SHORT $LN202@P_ProcessL
  00a7e	eb 06		 jmp	 SHORT $LN203@P_ProcessL
$LN202@P_ProcessL:
  00a80	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00a85	90		 npad	 1
$LN203@P_ProcessL:
  00a86	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00a8c	c6 44 0d b4 00	 mov	 BYTE PTR _newname$20[ebp+ecx], 0

; 2151 : 
; 2152 : 				lumpnum = W_CheckNumForName(newname);

  00a91	8d 45 b4	 lea	 eax, DWORD PTR _newname$20[ebp]
  00a94	50		 push	 eax
  00a95	e8 00 00 00 00	 call	 _W_CheckNumForName
  00a9a	83 c4 04	 add	 esp, 4
  00a9d	89 45 c0	 mov	 DWORD PTR _lumpnum$21[ebp], eax

; 2153 : 
; 2154 : 				if (lumpnum == LUMPERROR || W_LumpLength(lumpnum) == 0)

  00aa0	83 7d c0 ff	 cmp	 DWORD PTR _lumpnum$21[ebp], -1
  00aa4	74 10		 je	 SHORT $LN100@P_ProcessL
  00aa6	8b 45 c0	 mov	 eax, DWORD PTR _lumpnum$21[ebp]
  00aa9	50		 push	 eax
  00aaa	e8 00 00 00 00	 call	 _W_LumpLength
  00aaf	83 c4 04	 add	 esp, 4
  00ab2	85 c0		 test	 eax, eax
  00ab4	75 13		 jne	 SHORT $LN98@P_ProcessL
$LN100@P_ProcessL:

; 2155 : 					CONS_Printf("SOC Error: script lump %s not found/not valid.\n", newname);

  00ab6	8d 45 b4	 lea	 eax, DWORD PTR _newname$20[ebp]
  00ab9	50		 push	 eax
  00aba	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@LFBFGGIP@SOC?5Error?3?5script?5lump?5?$CFs?5not?5f@
  00abf	e8 00 00 00 00	 call	 _CONS_Printf
  00ac4	83 c4 08	 add	 esp, 8
  00ac7	eb 17		 jmp	 SHORT $LN99@P_ProcessL
$LN98@P_ProcessL:

; 2156 : 				else
; 2157 : 					COM_BufInsertText(W_CacheLumpNum(lumpnum, PU_CACHE));

  00ac9	6a 65		 push	 101			; 00000065H
  00acb	8b 45 c0	 mov	 eax, DWORD PTR _lumpnum$21[ebp]
  00ace	50		 push	 eax
  00acf	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00ad4	83 c4 08	 add	 esp, 8
  00ad7	50		 push	 eax
  00ad8	e8 00 00 00 00	 call	 _COM_BufInsertText
  00add	83 c4 04	 add	 esp, 4
$LN99@P_ProcessL:

; 2158 : 			}
; 2159 : 			break;

  00ae0	e9 73 0d 00 00	 jmp	 $LN2@P_ProcessL
$LN101@P_ProcessL:

; 2160 : 
; 2161 : 		case 416: // Spawn adjustable fire flicker
; 2162 : 			while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  00ae5	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00ae8	50		 push	 eax
  00ae9	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00aec	51		 push	 ecx
  00aed	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00af2	83 c4 08	 add	 esp, 8
  00af5	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00af8	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  00afc	0f 8c 0c 01 00
	00		 jl	 $LN16@P_ProcessL

; 2163 : 			{
; 2164 : 				if (line->flags & ML_NOCLIMB && line->backsector)

  00b02	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00b05	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00b09	83 e1 40	 and	 ecx, 64			; 00000040H
  00b0c	0f 84 c0 00 00
	00		 je	 $LN102@P_ProcessL
  00b12	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00b15	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00b19	0f 84 b3 00 00
	00		 je	 $LN102@P_ProcessL

; 2165 : 				{
; 2166 : 					// Use front sector for min light level, back sector for max.
; 2167 : 					// This is tricky because P_SpawnAdjustableFireFlicker expects
; 2168 : 					// the maxsector (second argument) to also be the target
; 2169 : 					// sector, so we have to do some light level twiddling.
; 2170 : 					fireflicker_t *flick;
; 2171 : 					INT16 reallightlevel = sectors[secnum].lightlevel;

  00b1f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00b26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00b2c	66 8b 54 01 10	 mov	 dx, WORD PTR [ecx+eax+16]
  00b31	66 89 55 ac	 mov	 WORD PTR _reallightlevel$18[ebp], dx

; 2172 : 					sectors[secnum].lightlevel = line->backsector->lightlevel;

  00b35	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00b38	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00b3b	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _secnum$[ebp], 248
  00b42	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00b47	66 8b 49 10	 mov	 cx, WORD PTR [ecx+16]
  00b4b	66 89 4c 10 10	 mov	 WORD PTR [eax+edx+16], cx

; 2173 : 
; 2174 : 					flick = P_SpawnAdjustableFireFlicker(line->frontsector, &sectors[secnum],

  00b50	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00b53	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00b56	51		 push	 ecx
  00b57	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00b5a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00b5d	50		 push	 eax
  00b5e	e8 00 00 00 00	 call	 _P_AproxDistance
  00b63	83 c4 08	 add	 esp, 8
  00b66	c1 f8 10	 sar	 eax, 16			; 00000010H
  00b69	50		 push	 eax
  00b6a	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00b71	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00b77	51		 push	 ecx
  00b78	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00b7b	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00b7e	50		 push	 eax
  00b7f	e8 00 00 00 00	 call	 _P_SpawnAdjustableFireFlicker
  00b84	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b87	89 45 b0	 mov	 DWORD PTR _flick$19[ebp], eax

; 2175 : 						P_AproxDistance(line->dx, line->dy)>>FRACBITS);
; 2176 : 
; 2177 : 					// Make sure the starting light level is in range.
; 2178 : 					if (reallightlevel < flick->minlight)

  00b8a	0f bf 45 ac	 movsx	 eax, WORD PTR _reallightlevel$18[ebp]
  00b8e	8b 4d b0	 mov	 ecx, DWORD PTR _flick$19[ebp]
  00b91	3b 41 20	 cmp	 eax, DWORD PTR [ecx+32]
  00b94	7d 0d		 jge	 SHORT $LN104@P_ProcessL

; 2179 : 						reallightlevel = (INT16)flick->minlight;

  00b96	8b 45 b0	 mov	 eax, DWORD PTR _flick$19[ebp]
  00b99	66 8b 48 20	 mov	 cx, WORD PTR [eax+32]
  00b9d	66 89 4d ac	 mov	 WORD PTR _reallightlevel$18[ebp], cx
  00ba1	eb 17		 jmp	 SHORT $LN106@P_ProcessL
$LN104@P_ProcessL:

; 2180 : 					else if (reallightlevel > flick->maxlight)

  00ba3	0f bf 45 ac	 movsx	 eax, WORD PTR _reallightlevel$18[ebp]
  00ba7	8b 4d b0	 mov	 ecx, DWORD PTR _flick$19[ebp]
  00baa	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  00bad	7e 0b		 jle	 SHORT $LN106@P_ProcessL

; 2181 : 						reallightlevel = (INT16)flick->maxlight;

  00baf	8b 45 b0	 mov	 eax, DWORD PTR _flick$19[ebp]
  00bb2	66 8b 48 1c	 mov	 cx, WORD PTR [eax+28]
  00bb6	66 89 4d ac	 mov	 WORD PTR _reallightlevel$18[ebp], cx
$LN106@P_ProcessL:

; 2182 : 
; 2183 : 					sectors[secnum].lightlevel = reallightlevel;

  00bba	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00bc1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00bc7	66 8b 55 ac	 mov	 dx, WORD PTR _reallightlevel$18[ebp]
  00bcb	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 2184 : 				}

  00bd0	eb 37		 jmp	 SHORT $LN103@P_ProcessL
$LN102@P_ProcessL:

; 2185 : 				else
; 2186 : 				{
; 2187 : 					// Use front sector for min, target sector for max,
; 2188 : 					// the same way linetype 61 does it.
; 2189 : 					P_SpawnAdjustableFireFlicker(line->frontsector, &sectors[secnum],

  00bd2	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00bd5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00bd8	51		 push	 ecx
  00bd9	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00bdc	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00bdf	50		 push	 eax
  00be0	e8 00 00 00 00	 call	 _P_AproxDistance
  00be5	83 c4 08	 add	 esp, 8
  00be8	c1 f8 10	 sar	 eax, 16			; 00000010H
  00beb	50		 push	 eax
  00bec	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00bf3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00bf9	51		 push	 ecx
  00bfa	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00bfd	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00c00	50		 push	 eax
  00c01	e8 00 00 00 00	 call	 _P_SpawnAdjustableFireFlicker
  00c06	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN103@P_ProcessL:

; 2190 : 						P_AproxDistance(line->dx, line->dy)>>FRACBITS);
; 2191 : 				}
; 2192 : 			}

  00c09	e9 d7 fe ff ff	 jmp	 $LN101@P_ProcessL
$LN16@P_ProcessL:

; 2193 : 			break;

  00c0e	e9 45 0c 00 00	 jmp	 $LN2@P_ProcessL
$LN107@P_ProcessL:

; 2194 : 
; 2195 : 		case 417: // Spawn adjustable glowing light
; 2196 : 			while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  00c13	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00c16	50		 push	 eax
  00c17	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00c1a	51		 push	 ecx
  00c1b	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00c20	83 c4 08	 add	 esp, 8
  00c23	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00c26	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  00c2a	0f 8c 0c 01 00
	00		 jl	 $LN18@P_ProcessL

; 2197 : 			{
; 2198 : 				if (line->flags & ML_NOCLIMB && line->backsector)

  00c30	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00c33	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00c37	83 e1 40	 and	 ecx, 64			; 00000040H
  00c3a	0f 84 c0 00 00
	00		 je	 $LN108@P_ProcessL
  00c40	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00c43	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00c47	0f 84 b3 00 00
	00		 je	 $LN108@P_ProcessL

; 2199 : 				{
; 2200 : 					// Use front sector for min light level, back sector for max.
; 2201 : 					// This is tricky because P_SpawnAdjustableGlowingLight expects
; 2202 : 					// the maxsector (second argument) to also be the target
; 2203 : 					// sector, so we have to do some light level twiddling.
; 2204 : 					glow_t *glow;
; 2205 : 					INT16 reallightlevel = sectors[secnum].lightlevel;

  00c4d	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00c54	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00c5a	66 8b 54 01 10	 mov	 dx, WORD PTR [ecx+eax+16]
  00c5f	66 89 55 a4	 mov	 WORD PTR _reallightlevel$16[ebp], dx

; 2206 : 					sectors[secnum].lightlevel = line->backsector->lightlevel;

  00c63	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00c66	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00c69	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _secnum$[ebp], 248
  00c70	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00c75	66 8b 49 10	 mov	 cx, WORD PTR [ecx+16]
  00c79	66 89 4c 10 10	 mov	 WORD PTR [eax+edx+16], cx

; 2207 : 
; 2208 : 					glow = P_SpawnAdjustableGlowingLight(line->frontsector, &sectors[secnum],

  00c7e	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00c81	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00c84	51		 push	 ecx
  00c85	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00c88	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c8b	50		 push	 eax
  00c8c	e8 00 00 00 00	 call	 _P_AproxDistance
  00c91	83 c4 08	 add	 esp, 8
  00c94	c1 f8 10	 sar	 eax, 16			; 00000010H
  00c97	50		 push	 eax
  00c98	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00c9f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00ca5	51		 push	 ecx
  00ca6	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00ca9	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00cac	50		 push	 eax
  00cad	e8 00 00 00 00	 call	 _P_SpawnAdjustableGlowingLight
  00cb2	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cb5	89 45 a8	 mov	 DWORD PTR _glow$17[ebp], eax

; 2209 : 						P_AproxDistance(line->dx, line->dy)>>FRACBITS);
; 2210 : 
; 2211 : 					// Make sure the starting light level is in range.
; 2212 : 					if (reallightlevel < glow->minlight)

  00cb8	0f bf 45 a4	 movsx	 eax, WORD PTR _reallightlevel$16[ebp]
  00cbc	8b 4d a8	 mov	 ecx, DWORD PTR _glow$17[ebp]
  00cbf	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00cc2	7d 0d		 jge	 SHORT $LN110@P_ProcessL

; 2213 : 						reallightlevel = (INT16)glow->minlight;

  00cc4	8b 45 a8	 mov	 eax, DWORD PTR _glow$17[ebp]
  00cc7	66 8b 48 14	 mov	 cx, WORD PTR [eax+20]
  00ccb	66 89 4d a4	 mov	 WORD PTR _reallightlevel$16[ebp], cx
  00ccf	eb 17		 jmp	 SHORT $LN112@P_ProcessL
$LN110@P_ProcessL:

; 2214 : 					else if (reallightlevel > glow->maxlight)

  00cd1	0f bf 45 a4	 movsx	 eax, WORD PTR _reallightlevel$16[ebp]
  00cd5	8b 4d a8	 mov	 ecx, DWORD PTR _glow$17[ebp]
  00cd8	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00cdb	7e 0b		 jle	 SHORT $LN112@P_ProcessL

; 2215 : 						reallightlevel = (INT16)glow->maxlight;

  00cdd	8b 45 a8	 mov	 eax, DWORD PTR _glow$17[ebp]
  00ce0	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00ce4	66 89 4d a4	 mov	 WORD PTR _reallightlevel$16[ebp], cx
$LN112@P_ProcessL:

; 2216 : 
; 2217 : 					sectors[secnum].lightlevel = reallightlevel;

  00ce8	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00cef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00cf5	66 8b 55 a4	 mov	 dx, WORD PTR _reallightlevel$16[ebp]
  00cf9	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 2218 : 				}

  00cfe	eb 37		 jmp	 SHORT $LN109@P_ProcessL
$LN108@P_ProcessL:

; 2219 : 				else
; 2220 : 				{
; 2221 : 					// Use front sector for min, target sector for max,
; 2222 : 					// the same way linetype 602 does it.
; 2223 : 					P_SpawnAdjustableGlowingLight(line->frontsector, &sectors[secnum],

  00d00	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00d03	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00d06	51		 push	 ecx
  00d07	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00d0a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00d0d	50		 push	 eax
  00d0e	e8 00 00 00 00	 call	 _P_AproxDistance
  00d13	83 c4 08	 add	 esp, 8
  00d16	c1 f8 10	 sar	 eax, 16			; 00000010H
  00d19	50		 push	 eax
  00d1a	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00d21	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00d27	51		 push	 ecx
  00d28	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00d2b	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00d2e	50		 push	 eax
  00d2f	e8 00 00 00 00	 call	 _P_SpawnAdjustableGlowingLight
  00d34	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN109@P_ProcessL:

; 2224 : 						P_AproxDistance(line->dx, line->dy)>>FRACBITS);
; 2225 : 				}
; 2226 : 			}

  00d37	e9 d7 fe ff ff	 jmp	 $LN107@P_ProcessL
$LN18@P_ProcessL:

; 2227 : 			break;

  00d3c	e9 17 0b 00 00	 jmp	 $LN2@P_ProcessL
$LN113@P_ProcessL:

; 2228 : 
; 2229 : 		case 418: // Spawn adjustable strobe flash (unsynchronized)
; 2230 : 			while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  00d41	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00d44	50		 push	 eax
  00d45	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00d48	51		 push	 ecx
  00d49	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00d4e	83 c4 08	 add	 esp, 8
  00d51	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00d54	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  00d58	0f 8c 28 01 00
	00		 jl	 $LN20@P_ProcessL

; 2231 : 			{
; 2232 : 				if (line->flags & ML_NOCLIMB && line->backsector)

  00d5e	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00d61	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00d65	83 e1 40	 and	 ecx, 64			; 00000040H
  00d68	0f 84 ce 00 00
	00		 je	 $LN114@P_ProcessL
  00d6e	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00d71	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00d75	0f 84 c1 00 00
	00		 je	 $LN114@P_ProcessL

; 2233 : 				{
; 2234 : 					// Use front sector for min light level, back sector for max.
; 2235 : 					// This is tricky because P_SpawnAdjustableGlowingLight expects
; 2236 : 					// the maxsector (second argument) to also be the target
; 2237 : 					// sector, so we have to do some light level twiddling.
; 2238 : 					strobe_t *flash;
; 2239 : 					INT16 reallightlevel = sectors[secnum].lightlevel;

  00d7b	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00d82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00d88	66 8b 54 01 10	 mov	 dx, WORD PTR [ecx+eax+16]
  00d8d	66 89 55 9c	 mov	 WORD PTR _reallightlevel$14[ebp], dx

; 2240 : 					sectors[secnum].lightlevel = line->backsector->lightlevel;

  00d91	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00d94	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00d97	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _secnum$[ebp], 248
  00d9e	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00da3	66 8b 49 10	 mov	 cx, WORD PTR [ecx+16]
  00da7	66 89 4c 10 10	 mov	 WORD PTR [eax+edx+16], cx

; 2241 : 
; 2242 : 					flash = P_SpawnAdjustableStrobeFlash(line->frontsector, &sectors[secnum],

  00dac	6a 00		 push	 0
  00dae	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00db1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00db4	51		 push	 ecx
  00db5	e8 00 00 00 00	 call	 _abs
  00dba	83 c4 04	 add	 esp, 4
  00dbd	c1 f8 10	 sar	 eax, 16			; 00000010H
  00dc0	50		 push	 eax
  00dc1	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00dc4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00dc7	50		 push	 eax
  00dc8	e8 00 00 00 00	 call	 _abs
  00dcd	83 c4 04	 add	 esp, 4
  00dd0	c1 f8 10	 sar	 eax, 16			; 00000010H
  00dd3	50		 push	 eax
  00dd4	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00ddb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00de1	51		 push	 ecx
  00de2	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00de5	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00de8	50		 push	 eax
  00de9	e8 00 00 00 00	 call	 _P_SpawnAdjustableStrobeFlash
  00dee	83 c4 14	 add	 esp, 20			; 00000014H
  00df1	89 45 a0	 mov	 DWORD PTR _flash$15[ebp], eax

; 2243 : 						abs(line->dx)>>FRACBITS, abs(line->dy)>>FRACBITS, false);
; 2244 : 
; 2245 : 					// Make sure the starting light level is in range.
; 2246 : 					if (reallightlevel < flash->minlight)

  00df4	0f bf 45 9c	 movsx	 eax, WORD PTR _reallightlevel$14[ebp]
  00df8	8b 4d a0	 mov	 ecx, DWORD PTR _flash$15[ebp]
  00dfb	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00dfe	7d 0d		 jge	 SHORT $LN116@P_ProcessL

; 2247 : 						reallightlevel = (INT16)flash->minlight;

  00e00	8b 45 a0	 mov	 eax, DWORD PTR _flash$15[ebp]
  00e03	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00e07	66 89 4d 9c	 mov	 WORD PTR _reallightlevel$14[ebp], cx
  00e0b	eb 17		 jmp	 SHORT $LN118@P_ProcessL
$LN116@P_ProcessL:

; 2248 : 					else if (reallightlevel > flash->maxlight)

  00e0d	0f bf 45 9c	 movsx	 eax, WORD PTR _reallightlevel$14[ebp]
  00e11	8b 4d a0	 mov	 ecx, DWORD PTR _flash$15[ebp]
  00e14	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  00e17	7e 0b		 jle	 SHORT $LN118@P_ProcessL

; 2249 : 						reallightlevel = (INT16)flash->maxlight;

  00e19	8b 45 a0	 mov	 eax, DWORD PTR _flash$15[ebp]
  00e1c	66 8b 48 1c	 mov	 cx, WORD PTR [eax+28]
  00e20	66 89 4d 9c	 mov	 WORD PTR _reallightlevel$14[ebp], cx
$LN118@P_ProcessL:

; 2250 : 
; 2251 : 					sectors[secnum].lightlevel = reallightlevel;

  00e24	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00e2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00e31	66 8b 55 9c	 mov	 dx, WORD PTR _reallightlevel$14[ebp]
  00e35	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 2252 : 				}

  00e3a	eb 45		 jmp	 SHORT $LN115@P_ProcessL
$LN114@P_ProcessL:

; 2253 : 				else
; 2254 : 				{
; 2255 : 					// Use front sector for min, target sector for max,
; 2256 : 					// the same way linetype 602 does it.
; 2257 : 					P_SpawnAdjustableStrobeFlash(line->frontsector, &sectors[secnum],

  00e3c	6a 00		 push	 0
  00e3e	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00e41	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00e44	51		 push	 ecx
  00e45	e8 00 00 00 00	 call	 _abs
  00e4a	83 c4 04	 add	 esp, 4
  00e4d	c1 f8 10	 sar	 eax, 16			; 00000010H
  00e50	50		 push	 eax
  00e51	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00e54	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00e57	50		 push	 eax
  00e58	e8 00 00 00 00	 call	 _abs
  00e5d	83 c4 04	 add	 esp, 4
  00e60	c1 f8 10	 sar	 eax, 16			; 00000010H
  00e63	50		 push	 eax
  00e64	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00e6b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00e71	51		 push	 ecx
  00e72	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00e75	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00e78	50		 push	 eax
  00e79	e8 00 00 00 00	 call	 _P_SpawnAdjustableStrobeFlash
  00e7e	83 c4 14	 add	 esp, 20			; 00000014H
$LN115@P_ProcessL:

; 2258 : 						abs(line->dx)>>FRACBITS, abs(line->dy)>>FRACBITS, false);
; 2259 : 				}
; 2260 : 			}

  00e81	e9 bb fe ff ff	 jmp	 $LN113@P_ProcessL
$LN20@P_ProcessL:

; 2261 : 			break;

  00e86	e9 cd 09 00 00	 jmp	 $LN2@P_ProcessL
$LN119@P_ProcessL:

; 2262 : 
; 2263 : 		case 419: // Spawn adjustable strobe flash (synchronized)
; 2264 : 			while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  00e8b	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  00e8e	50		 push	 eax
  00e8f	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00e92	51		 push	 ecx
  00e93	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00e98	83 c4 08	 add	 esp, 8
  00e9b	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  00e9e	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  00ea2	0f 8c 28 01 00
	00		 jl	 $LN22@P_ProcessL

; 2265 : 			{
; 2266 : 				if (line->flags & ML_NOCLIMB && line->backsector)

  00ea8	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00eab	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00eaf	83 e1 40	 and	 ecx, 64			; 00000040H
  00eb2	0f 84 ce 00 00
	00		 je	 $LN120@P_ProcessL
  00eb8	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00ebb	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00ebf	0f 84 c1 00 00
	00		 je	 $LN120@P_ProcessL

; 2267 : 				{
; 2268 : 					// Use front sector for min light level, back sector for max.
; 2269 : 					// This is tricky because P_SpawnAdjustableGlowingLight expects
; 2270 : 					// the maxsector (second argument) to also be the target
; 2271 : 					// sector, so we have to do some light level twiddling.
; 2272 : 					strobe_t *flash;
; 2273 : 					INT16 reallightlevel = sectors[secnum].lightlevel;

  00ec5	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00ecc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00ed2	66 8b 54 01 10	 mov	 dx, WORD PTR [ecx+eax+16]
  00ed7	66 89 55 94	 mov	 WORD PTR _reallightlevel$12[ebp], dx

; 2274 : 					sectors[secnum].lightlevel = line->backsector->lightlevel;

  00edb	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00ede	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00ee1	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _secnum$[ebp], 248
  00ee8	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00eed	66 8b 49 10	 mov	 cx, WORD PTR [ecx+16]
  00ef1	66 89 4c 10 10	 mov	 WORD PTR [eax+edx+16], cx

; 2275 : 
; 2276 : 					flash = P_SpawnAdjustableStrobeFlash(line->frontsector, &sectors[secnum],

  00ef6	6a 01		 push	 1
  00ef8	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00efb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00efe	51		 push	 ecx
  00eff	e8 00 00 00 00	 call	 _abs
  00f04	83 c4 04	 add	 esp, 4
  00f07	c1 f8 10	 sar	 eax, 16			; 00000010H
  00f0a	50		 push	 eax
  00f0b	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00f0e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00f11	50		 push	 eax
  00f12	e8 00 00 00 00	 call	 _abs
  00f17	83 c4 04	 add	 esp, 4
  00f1a	c1 f8 10	 sar	 eax, 16			; 00000010H
  00f1d	50		 push	 eax
  00f1e	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00f25	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00f2b	51		 push	 ecx
  00f2c	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00f2f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00f32	50		 push	 eax
  00f33	e8 00 00 00 00	 call	 _P_SpawnAdjustableStrobeFlash
  00f38	83 c4 14	 add	 esp, 20			; 00000014H
  00f3b	89 45 98	 mov	 DWORD PTR _flash$13[ebp], eax

; 2277 : 						abs(line->dx)>>FRACBITS, abs(line->dy)>>FRACBITS, true);
; 2278 : 
; 2279 : 					// Make sure the starting light level is in range.
; 2280 : 					if (reallightlevel < flash->minlight)

  00f3e	0f bf 45 94	 movsx	 eax, WORD PTR _reallightlevel$12[ebp]
  00f42	8b 4d 98	 mov	 ecx, DWORD PTR _flash$13[ebp]
  00f45	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00f48	7d 0d		 jge	 SHORT $LN122@P_ProcessL

; 2281 : 						reallightlevel = (INT16)flash->minlight;

  00f4a	8b 45 98	 mov	 eax, DWORD PTR _flash$13[ebp]
  00f4d	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00f51	66 89 4d 94	 mov	 WORD PTR _reallightlevel$12[ebp], cx
  00f55	eb 17		 jmp	 SHORT $LN124@P_ProcessL
$LN122@P_ProcessL:

; 2282 : 					else if (reallightlevel > flash->maxlight)

  00f57	0f bf 45 94	 movsx	 eax, WORD PTR _reallightlevel$12[ebp]
  00f5b	8b 4d 98	 mov	 ecx, DWORD PTR _flash$13[ebp]
  00f5e	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  00f61	7e 0b		 jle	 SHORT $LN124@P_ProcessL

; 2283 : 						reallightlevel = (INT16)flash->maxlight;

  00f63	8b 45 98	 mov	 eax, DWORD PTR _flash$13[ebp]
  00f66	66 8b 48 1c	 mov	 cx, WORD PTR [eax+28]
  00f6a	66 89 4d 94	 mov	 WORD PTR _reallightlevel$12[ebp], cx
$LN124@P_ProcessL:

; 2284 : 
; 2285 : 					sectors[secnum].lightlevel = reallightlevel;

  00f6e	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  00f75	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00f7b	66 8b 55 94	 mov	 dx, WORD PTR _reallightlevel$12[ebp]
  00f7f	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 2286 : 				}

  00f84	eb 45		 jmp	 SHORT $LN121@P_ProcessL
$LN120@P_ProcessL:

; 2287 : 				else
; 2288 : 				{
; 2289 : 					// Use front sector for min, target sector for max,
; 2290 : 					// the same way linetype 602 does it.
; 2291 : 					P_SpawnAdjustableStrobeFlash(line->frontsector, &sectors[secnum],

  00f86	6a 01		 push	 1
  00f88	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00f8b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f8e	51		 push	 ecx
  00f8f	e8 00 00 00 00	 call	 _abs
  00f94	83 c4 04	 add	 esp, 4
  00f97	c1 f8 10	 sar	 eax, 16			; 00000010H
  00f9a	50		 push	 eax
  00f9b	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00f9e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00fa1	50		 push	 eax
  00fa2	e8 00 00 00 00	 call	 _abs
  00fa7	83 c4 04	 add	 esp, 4
  00faa	c1 f8 10	 sar	 eax, 16			; 00000010H
  00fad	50		 push	 eax
  00fae	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _secnum$[ebp], 248
  00fb5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00fbb	51		 push	 ecx
  00fbc	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00fbf	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00fc2	50		 push	 eax
  00fc3	e8 00 00 00 00	 call	 _P_SpawnAdjustableStrobeFlash
  00fc8	83 c4 14	 add	 esp, 20			; 00000014H
$LN121@P_ProcessL:

; 2292 : 						abs(line->dx)>>FRACBITS, abs(line->dy)>>FRACBITS, true);
; 2293 : 				}
; 2294 : 			}

  00fcb	e9 bb fe ff ff	 jmp	 $LN119@P_ProcessL
$LN22@P_ProcessL:

; 2295 : 			break;

  00fd0	e9 83 08 00 00	 jmp	 $LN2@P_ProcessL
$LN125@P_ProcessL:

; 2296 : 
; 2297 : 		case 420: // Fade light levels in tagged sectors to new value
; 2298 : 			P_FadeLight(line->tag, line->frontsector->lightlevel, P_AproxDistance(line->dx, line->dy)>>FRACBITS);

  00fd5	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00fd8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00fdb	51		 push	 ecx
  00fdc	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  00fdf	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00fe2	50		 push	 eax
  00fe3	e8 00 00 00 00	 call	 _P_AproxDistance
  00fe8	83 c4 08	 add	 esp, 8
  00feb	c1 f8 10	 sar	 eax, 16			; 00000010H
  00fee	50		 push	 eax
  00fef	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00ff2	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00ff5	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00ff9	50		 push	 eax
  00ffa	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  00ffd	0f b7 51 14	 movzx	 edx, WORD PTR [ecx+20]
  01001	52		 push	 edx
  01002	e8 00 00 00 00	 call	 _P_FadeLight
  01007	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2299 : 			break;

  0100a	e9 49 08 00 00	 jmp	 $LN2@P_ProcessL
$LN126@P_ProcessL:

; 2300 : 
; 2301 : 		case 421: // Stop lighting effect in tagged sectors
; 2302 : 			while ((secnum = P_FindSectorFromLineTag(line, secnum)) >= 0)

  0100f	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  01012	50		 push	 eax
  01013	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  01016	51		 push	 ecx
  01017	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  0101c	83 c4 08	 add	 esp, 8
  0101f	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  01022	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  01026	7c 45		 jl	 SHORT $LN24@P_ProcessL

; 2303 : 				if (sectors[secnum].lightingdata)

  01028	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  0102f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  01035	83 7c 01 4c 00	 cmp	 DWORD PTR [ecx+eax+76], 0
  0103a	74 2f		 je	 SHORT $LN127@P_ProcessL

; 2304 : 				{
; 2305 : 					P_RemoveThinker(&((elevator_t *)sectors[secnum].lightingdata)->thinker);

  0103c	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  01043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  01049	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  0104d	52		 push	 edx
  0104e	e8 00 00 00 00	 call	 _P_RemoveThinker
  01053	83 c4 04	 add	 esp, 4

; 2306 : 					sectors[secnum].lightingdata = NULL;

  01056	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  0105d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  01063	c7 44 01 4c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+76], 0
$LN127@P_ProcessL:

; 2307 : 				}

  0106b	eb a2		 jmp	 SHORT $LN126@P_ProcessL
$LN24@P_ProcessL:

; 2308 : 			break;

  0106d	e9 e6 07 00 00	 jmp	 $LN2@P_ProcessL
$LN128@P_ProcessL:

; 2309 : 
; 2310 : 		case 422: // Cut away to another view
; 2311 : 			{
; 2312 : 				mobj_t *altview;
; 2313 : 
; 2314 : 				if (!mo || !mo->player) // only players have views

  01072	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  01076	74 0c		 je	 SHORT $LN130@P_ProcessL
  01078	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0107b	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01082	75 05		 jne	 SHORT $LN129@P_ProcessL
$LN130@P_ProcessL:

; 2315 : 					return;

  01084	e9 cf 07 00 00	 jmp	 $LN2@P_ProcessL
$LN129@P_ProcessL:

; 2316 : 
; 2317 : 				if ((secnum = P_FindSectorFromLineTag(line, -1)) < 0)

  01089	6a ff		 push	 -1
  0108b	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0108e	50		 push	 eax
  0108f	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  01094	83 c4 08	 add	 esp, 8
  01097	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  0109a	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  0109e	7d 05		 jge	 SHORT $LN131@P_ProcessL

; 2318 : 					return;

  010a0	e9 b3 07 00 00	 jmp	 $LN2@P_ProcessL
$LN131@P_ProcessL:

; 2319 : 
; 2320 : 				altview = P_GetObjectTypeInSectorNum(MT_ALTVIEWMAN, secnum);

  010a5	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  010a8	50		 push	 eax
  010a9	68 03 01 00 00	 push	 259			; 00000103H
  010ae	e8 00 00 00 00	 call	 _P_GetObjectTypeInSectorNum
  010b3	83 c4 08	 add	 esp, 8
  010b6	89 45 90	 mov	 DWORD PTR _altview$11[ebp], eax

; 2321 : 				if (!altview)

  010b9	83 7d 90 00	 cmp	 DWORD PTR _altview$11[ebp], 0
  010bd	75 05		 jne	 SHORT $LN132@P_ProcessL

; 2322 : 					return;

  010bf	e9 94 07 00 00	 jmp	 $LN2@P_ProcessL
$LN132@P_ProcessL:

; 2323 : 
; 2324 : 				P_SetTarget(&mo->player->awayviewmobj, altview);

  010c4	8b 45 90	 mov	 eax, DWORD PTR _altview$11[ebp]
  010c7	50		 push	 eax
  010c8	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  010cb	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  010d1	81 c2 e8 01 00
	00		 add	 edx, 488		; 000001e8H
  010d7	52		 push	 edx
  010d8	e8 00 00 00 00	 call	 _P_SetTarget
  010dd	83 c4 08	 add	 esp, 8

; 2325 : 				mo->player->awayviewtics = P_AproxDistance(line->dx, line->dy)>>FRACBITS;

  010e0	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  010e3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  010e6	51		 push	 ecx
  010e7	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  010ea	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  010ed	50		 push	 eax
  010ee	e8 00 00 00 00	 call	 _P_AproxDistance
  010f3	83 c4 08	 add	 esp, 8
  010f6	c1 f8 10	 sar	 eax, 16			; 00000010H
  010f9	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  010fc	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01102	89 82 ec 01 00
	00		 mov	 DWORD PTR [edx+492], eax

; 2326 : 
; 2327 : 				if (line->flags & ML_NOCLIMB) // lets you specify a vertical angle

  01108	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0110b	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0110f	83 e1 40	 and	 ecx, 64			; 00000040H
  01112	74 7c		 je	 SHORT $LN133@P_ProcessL

; 2328 : 				{
; 2329 : 					INT32 aim;
; 2330 : 
; 2331 : 					aim = sides[line->sidenum[0]].textureoffset>>FRACBITS;

  01114	b8 02 00 00 00	 mov	 eax, 2
  01119	6b c8 00	 imul	 ecx, eax, 0
  0111c	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0111f	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  01124	6b c8 1c	 imul	 ecx, eax, 28
  01127	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0112d	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01130	c1 f8 10	 sar	 eax, 16			; 00000010H
  01133	89 45 8c	 mov	 DWORD PTR _aim$10[ebp], eax
$LN25@P_ProcessL:

; 2332 : 					while (aim < 0)

  01136	83 7d 8c 00	 cmp	 DWORD PTR _aim$10[ebp], 0
  0113a	7d 0d		 jge	 SHORT $LN26@P_ProcessL

; 2333 : 						aim += 360;

  0113c	8b 45 8c	 mov	 eax, DWORD PTR _aim$10[ebp]
  0113f	05 68 01 00 00	 add	 eax, 360		; 00000168H
  01144	89 45 8c	 mov	 DWORD PTR _aim$10[ebp], eax
  01147	eb ed		 jmp	 SHORT $LN25@P_ProcessL
$LN26@P_ProcessL:

; 2334 : 					while (aim >= 360)

  01149	81 7d 8c 68 01
	00 00		 cmp	 DWORD PTR _aim$10[ebp], 360 ; 00000168H
  01150	7c 0d		 jl	 SHORT $LN28@P_ProcessL

; 2335 : 						aim -= 360;

  01152	8b 45 8c	 mov	 eax, DWORD PTR _aim$10[ebp]
  01155	2d 68 01 00 00	 sub	 eax, 360		; 00000168H
  0115a	89 45 8c	 mov	 DWORD PTR _aim$10[ebp], eax
  0115d	eb ea		 jmp	 SHORT $LN26@P_ProcessL
$LN28@P_ProcessL:

; 2336 : 					aim *= (ANGLE_90>>8);

  0115f	8b 45 8c	 mov	 eax, DWORD PTR _aim$10[ebp]
  01162	c1 e0 16	 shl	 eax, 22			; 00000016H
  01165	89 45 8c	 mov	 DWORD PTR _aim$10[ebp], eax

; 2337 : 					aim /= 90;

  01168	8b 45 8c	 mov	 eax, DWORD PTR _aim$10[ebp]
  0116b	99		 cdq
  0116c	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  01171	f7 f9		 idiv	 ecx
  01173	89 45 8c	 mov	 DWORD PTR _aim$10[ebp], eax

; 2338 : 					aim <<= 8;

  01176	8b 45 8c	 mov	 eax, DWORD PTR _aim$10[ebp]
  01179	c1 e0 08	 shl	 eax, 8
  0117c	89 45 8c	 mov	 DWORD PTR _aim$10[ebp], eax

; 2339 : 					mo->player->awayviewaiming = (angle_t)aim;

  0117f	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01182	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01188	8b 55 8c	 mov	 edx, DWORD PTR _aim$10[ebp]
  0118b	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 2340 : 				}

  0118e	eb 10		 jmp	 SHORT $LN134@P_ProcessL
$LN133@P_ProcessL:

; 2341 : 				else
; 2342 : 					mo->player->awayviewaiming = 0; // straight ahead

  01190	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01193	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01199	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$LN134@P_ProcessL:

; 2343 : 			}
; 2344 : 			break;

  011a0	e9 b3 06 00 00	 jmp	 $LN2@P_ProcessL
$LN135@P_ProcessL:

; 2345 : 
; 2346 : 		case 423: // Change Sky
; 2347 : 			if ((mo && P_IsLocalPlayer(mo->player)) || (line->flags & ML_NOCLIMB))

  011a5	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  011a9	74 16		 je	 SHORT $LN138@P_ProcessL
  011ab	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  011ae	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  011b4	51		 push	 ecx
  011b5	e8 00 00 00 00	 call	 _P_IsLocalPlayer
  011ba	83 c4 04	 add	 esp, 4
  011bd	85 c0		 test	 eax, eax
  011bf	75 0c		 jne	 SHORT $LN137@P_ProcessL
$LN138@P_ProcessL:
  011c1	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  011c4	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  011c8	83 e1 40	 and	 ecx, 64			; 00000040H
  011cb	74 3c		 je	 SHORT $LN136@P_ProcessL
$LN137@P_ProcessL:

; 2348 : 			{
; 2349 : 				if (line->flags & ML_NOCLIMB)

  011cd	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  011d0	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  011d4	83 e1 40	 and	 ecx, 64			; 00000040H
  011d7	74 11		 je	 SHORT $LN139@P_ProcessL

; 2350 : 					globallevelskynum = line->frontsector->floorheight>>FRACBITS;

  011d9	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  011dc	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  011df	8b 11		 mov	 edx, DWORD PTR [ecx]
  011e1	c1 fa 10	 sar	 edx, 16			; 00000010H
  011e4	89 15 00 00 00
	00		 mov	 DWORD PTR _globallevelskynum, edx
$LN139@P_ProcessL:

; 2351 : 
; 2352 : 				levelskynum = line->frontsector->floorheight>>FRACBITS;

  011ea	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  011ed	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  011f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  011f2	c1 fa 10	 sar	 edx, 16			; 00000010H
  011f5	89 15 00 00 00
	00		 mov	 DWORD PTR _levelskynum, edx

; 2353 : 				P_SetupLevelSky(levelskynum);

  011fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelskynum
  01200	50		 push	 eax
  01201	e8 00 00 00 00	 call	 _P_SetupLevelSky
  01206	83 c4 04	 add	 esp, 4
$LN136@P_ProcessL:

; 2354 : 			}
; 2355 : 			break;

  01209	e9 4a 06 00 00	 jmp	 $LN2@P_ProcessL
$LN140@P_ProcessL:

; 2356 : 
; 2357 : 		case 424: // Change Weather - Extremely CPU-Intense.
; 2358 : 			if ((mo && P_IsLocalPlayer(mo->player)) || (line->flags & ML_NOCLIMB))

  0120e	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  01212	74 16		 je	 SHORT $LN143@P_ProcessL
  01214	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01217	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0121d	51		 push	 ecx
  0121e	e8 00 00 00 00	 call	 _P_IsLocalPlayer
  01223	83 c4 04	 add	 esp, 4
  01226	85 c0		 test	 eax, eax
  01228	75 0c		 jne	 SHORT $LN142@P_ProcessL
$LN143@P_ProcessL:
  0122a	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0122d	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  01231	83 e1 40	 and	 ecx, 64			; 00000040H
  01234	74 40		 je	 SHORT $LN141@P_ProcessL
$LN142@P_ProcessL:

; 2359 : 			{
; 2360 : 				if (line->flags & ML_NOCLIMB)

  01236	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01239	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0123d	83 e1 40	 and	 ecx, 64			; 00000040H
  01240	74 18		 je	 SHORT $LN144@P_ProcessL

; 2361 : 					globalweather = (UINT8)((line->frontsector->floorheight>>FRACBITS)/10);

  01242	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01245	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  01248	8b 01		 mov	 eax, DWORD PTR [ecx]
  0124a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0124d	99		 cdq
  0124e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  01253	f7 f9		 idiv	 ecx
  01255	a2 00 00 00 00	 mov	 BYTE PTR _globalweather, al
$LN144@P_ProcessL:

; 2362 : 
; 2363 : 				P_SwitchWeather((line->frontsector->floorheight>>FRACBITS)/10);

  0125a	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0125d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  01260	8b 01		 mov	 eax, DWORD PTR [ecx]
  01262	c1 f8 10	 sar	 eax, 16			; 00000010H
  01265	99		 cdq
  01266	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0126b	f7 f9		 idiv	 ecx
  0126d	50		 push	 eax
  0126e	e8 00 00 00 00	 call	 _P_SwitchWeather
  01273	83 c4 04	 add	 esp, 4
$LN141@P_ProcessL:

; 2364 : 			}
; 2365 : 			break;

  01276	e9 dd 05 00 00	 jmp	 $LN2@P_ProcessL
$LN145@P_ProcessL:

; 2366 : 
; 2367 : 		case 425: // Calls P_SetMobjState on calling mobj
; 2368 : 			if (mo)

  0127b	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  0127f	74 26		 je	 SHORT $LN146@P_ProcessL

; 2369 : 				P_SetMobjState(mo, P_AproxDistance(line->dx, line->dy)>>FRACBITS);

  01281	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01284	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01287	51		 push	 ecx
  01288	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0128b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0128e	50		 push	 eax
  0128f	e8 00 00 00 00	 call	 _P_AproxDistance
  01294	83 c4 08	 add	 esp, 8
  01297	c1 f8 10	 sar	 eax, 16			; 00000010H
  0129a	50		 push	 eax
  0129b	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  0129e	51		 push	 ecx
  0129f	e8 00 00 00 00	 call	 _P_SetMobjState
  012a4	83 c4 08	 add	 esp, 8
$LN146@P_ProcessL:

; 2370 : 			break;

  012a7	e9 ac 05 00 00	 jmp	 $LN2@P_ProcessL
$LN147@P_ProcessL:

; 2371 : 
; 2372 : 		case 426: // Moves the mobj to its sector's soundorg and on the floor, and stops it
; 2373 : 			if (!mo)

  012ac	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  012b0	75 05		 jne	 SHORT $LN148@P_ProcessL

; 2374 : 				return;

  012b2	e9 a1 05 00 00	 jmp	 $LN2@P_ProcessL
$LN148@P_ProcessL:

; 2375 : 
; 2376 : 			if (line->flags & ML_NOCLIMB)

  012b7	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  012ba	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  012be	83 e1 40	 and	 ecx, 64			; 00000040H
  012c1	74 46		 je	 SHORT $LN149@P_ProcessL

; 2377 : 			{
; 2378 : 				P_UnsetThingPosition(mo);

  012c3	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  012c6	50		 push	 eax
  012c7	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  012cc	83 c4 04	 add	 esp, 4

; 2379 : 				mo->x = mo->subsector->sector->soundorg.x;

  012cf	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  012d2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  012d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  012d7	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  012da	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  012dd	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2380 : 				mo->y = mo->subsector->sector->soundorg.y;

  012e0	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  012e3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  012e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  012e8	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  012eb	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  012ee	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2381 : 				mo->z = mo->floorz;

  012f1	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  012f4	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  012f7	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  012fa	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 2382 : 				P_SetThingPosition(mo);

  012fd	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01300	50		 push	 eax
  01301	e8 00 00 00 00	 call	 _P_SetThingPosition
  01306	83 c4 04	 add	 esp, 4
$LN149@P_ProcessL:

; 2383 : 			}
; 2384 : 
; 2385 : 			mo->momx = mo->momy = mo->momz = 1;

  01309	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0130c	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [eax+80], 1
  01313	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  01316	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [ecx+76], 1
  0131d	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  01320	c7 42 48 01 00
	00 00		 mov	 DWORD PTR [edx+72], 1

; 2386 : 			mo->pmomz = 0;

  01327	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0132a	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 2387 : 
; 2388 : 			if (mo->player)

  01331	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01334	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0133b	74 6c		 je	 SHORT $LN150@P_ProcessL

; 2389 : 			{
; 2390 : /*				if (splitscreen && cv_chasecam2.value && mo->player == &players[secondarydisplayplayer])
; 2391 : 					P_ResetCamera(mo->player, &camera2);
; 2392 : 				else if (cv_chasecam.value && mo->player == &players[displayplayer])
; 2393 : 					P_ResetCamera(mo->player, &camera);*/
; 2394 : 
; 2395 : 				mo->player->rmomx = mo->player->rmomy = 1;

  0133d	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01340	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01346	c7 81 48 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+328], 1
  01350	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  01353	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  01359	c7 80 44 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+324], 1

; 2396 : 				mo->player->cmomx = mo->player->cmomy = 0;

  01363	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01366	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0136c	c7 81 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+320], 0
  01376	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  01379	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0137f	c7 80 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+316], 0

; 2397 : 				P_ResetPlayer(mo->player);

  01389	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0138c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01392	51		 push	 ecx
  01393	e8 00 00 00 00	 call	 _P_ResetPlayer
  01398	83 c4 04	 add	 esp, 4

; 2398 : 				P_SetPlayerMobjState(mo, S_PLAY_STND);

  0139b	6a 01		 push	 1
  0139d	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  013a0	50		 push	 eax
  013a1	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  013a6	83 c4 08	 add	 esp, 8
$LN150@P_ProcessL:

; 2399 : 			}
; 2400 : 			break;

  013a9	e9 aa 04 00 00	 jmp	 $LN2@P_ProcessL
$LN151@P_ProcessL:

; 2401 : 
; 2402 : 		case 427: // Awards points if the mobj is a player
; 2403 : 			if (mo && mo->player)

  013ae	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  013b2	74 2a		 je	 SHORT $LN152@P_ProcessL
  013b4	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  013b7	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  013be	74 1e		 je	 SHORT $LN152@P_ProcessL

; 2404 : 				P_AddPlayerScore(mo->player, line->frontsector->floorheight>>FRACBITS);

  013c0	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  013c3	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  013c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  013c8	c1 fa 10	 sar	 edx, 16			; 00000010H
  013cb	52		 push	 edx
  013cc	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  013cf	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  013d5	51		 push	 ecx
  013d6	e8 00 00 00 00	 call	 _P_AddPlayerScore
  013db	83 c4 08	 add	 esp, 8
$LN152@P_ProcessL:

; 2405 : 			break;

  013de	e9 75 04 00 00	 jmp	 $LN2@P_ProcessL
$LN153@P_ProcessL:

; 2406 : 
; 2407 : 		case 428: // Start floating platform movement
; 2408 : 			EV_DoElevator(line, elevateContinuous, true);

  013e3	6a 01		 push	 1
  013e5	6a 03		 push	 3
  013e7	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  013ea	50		 push	 eax
  013eb	e8 00 00 00 00	 call	 _EV_DoElevator
  013f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2409 : 			break;

  013f3	e9 60 04 00 00	 jmp	 $LN2@P_ProcessL
$LN154@P_ProcessL:

; 2410 : 
; 2411 : 		case 429: // Crush Ceiling Down Once
; 2412 : 			EV_DoCrush(line, crushCeilOnce);

  013f8	6a 08		 push	 8
  013fa	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  013fd	50		 push	 eax
  013fe	e8 00 00 00 00	 call	 _EV_DoCrush
  01403	83 c4 08	 add	 esp, 8

; 2413 : 			break;

  01406	e9 4d 04 00 00	 jmp	 $LN2@P_ProcessL
$LN155@P_ProcessL:

; 2414 : 
; 2415 : 		case 430: // Crush Floor Up Once
; 2416 : 			EV_DoFloor(line, crushFloorOnce);

  0140b	6a 09		 push	 9
  0140d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01410	50		 push	 eax
  01411	e8 00 00 00 00	 call	 _EV_DoFloor
  01416	83 c4 08	 add	 esp, 8

; 2417 : 			break;

  01419	e9 3a 04 00 00	 jmp	 $LN2@P_ProcessL
$LN156@P_ProcessL:

; 2418 : 
; 2419 : 		case 431: // Crush Floor & Ceiling to middle Once
; 2420 : 			EV_DoCrush(line, crushBothOnce);

  0141e	6a 09		 push	 9
  01420	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01423	50		 push	 eax
  01424	e8 00 00 00 00	 call	 _EV_DoCrush
  01429	83 c4 08	 add	 esp, 8

; 2421 : 			break;

  0142c	e9 27 04 00 00	 jmp	 $LN2@P_ProcessL
$LN157@P_ProcessL:

; 2422 : 
; 2423 : 		case 432: // Enable 2D Mode
; 2424 : 			if (mo->player)

  01431	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01434	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0143b	74 18		 je	 SHORT $LN158@P_ProcessL

; 2425 : 				mo->flags2 |= MF2_TWOD;

  0143d	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01440	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  01446	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0144c	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0144f	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN158@P_ProcessL:

; 2426 : 			break;

  01455	e9 fe 03 00 00	 jmp	 $LN2@P_ProcessL
$LN159@P_ProcessL:

; 2427 : 
; 2428 : 		case 433: // Disable 2D Mode
; 2429 : 			if (mo->player)

  0145a	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0145d	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01464	74 18		 je	 SHORT $LN160@P_ProcessL

; 2430 : 				mo->flags2 &= ~MF2_TWOD;

  01466	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01469	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0146f	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  01475	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  01478	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN160@P_ProcessL:

; 2431 : 			break;

  0147e	e9 d5 03 00 00	 jmp	 $LN2@P_ProcessL
$LN161@P_ProcessL:

; 2432 : 
; 2433 : 		case 434: // Custom Power
; 2434 : 			if (mo->player)

  01483	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01486	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0148d	0f 84 80 00 00
	00		 je	 $LN162@P_ProcessL

; 2435 : 			{
; 2436 : 				mobj_t *dummy = P_SpawnMobj(mo->x, mo->y, mo->z, MT_DISS);

  01493	68 05 01 00 00	 push	 261			; 00000105H
  01498	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0149b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0149e	51		 push	 ecx
  0149f	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  014a2	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  014a5	50		 push	 eax
  014a6	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  014a9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  014ac	52		 push	 edx
  014ad	e8 00 00 00 00	 call	 _P_SpawnMobj
  014b2	83 c4 10	 add	 esp, 16			; 00000010H
  014b5	89 45 88	 mov	 DWORD PTR _dummy$9[ebp], eax

; 2437 : 
; 2438 : 				var1 = (line->dx>>FRACBITS)-1;

  014b8	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  014bb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  014be	c1 f9 10	 sar	 ecx, 16			; 00000010H
  014c1	83 e9 01	 sub	 ecx, 1
  014c4	89 0d 00 00 00
	00		 mov	 DWORD PTR _var1, ecx

; 2439 : 
; 2440 : 				if (line->flags & ML_NOCLIMB) // 'Infinite'

  014ca	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  014cd	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  014d1	83 e1 40	 and	 ecx, 64			; 00000040H
  014d4	74 0c		 je	 SHORT $LN163@P_ProcessL

; 2441 : 					var2 = 1 << 30;

  014d6	c7 05 00 00 00
	00 00 00 00 40	 mov	 DWORD PTR _var2, 1073741824 ; 40000000H
  014e0	eb 0f		 jmp	 SHORT $LN164@P_ProcessL
$LN163@P_ProcessL:

; 2442 : 				else
; 2443 : 					var2 = line->dy>>FRACBITS;

  014e2	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  014e5	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  014e8	c1 f9 10	 sar	 ecx, 16			; 00000010H
  014eb	89 0d 00 00 00
	00		 mov	 DWORD PTR _var2, ecx
$LN164@P_ProcessL:

; 2444 : 
; 2445 : 				P_SetTarget(&dummy->target, mo);

  014f1	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  014f4	50		 push	 eax
  014f5	8b 4d 88	 mov	 ecx, DWORD PTR _dummy$9[ebp]
  014f8	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  014fe	51		 push	 ecx
  014ff	e8 00 00 00 00	 call	 _P_SetTarget
  01504	83 c4 08	 add	 esp, 8

; 2446 : 				A_CustomPower(dummy);

  01507	8b 45 88	 mov	 eax, DWORD PTR _dummy$9[ebp]
  0150a	50		 push	 eax
  0150b	e8 00 00 00 00	 call	 _A_CustomPower
  01510	83 c4 04	 add	 esp, 4
$LN162@P_ProcessL:

; 2447 : 			}
; 2448 : 			break;

  01513	e9 40 03 00 00	 jmp	 $LN2@P_ProcessL
$LN165@P_ProcessL:

; 2449 : 
; 2450 : 		case 435: // Change scroller direction
; 2451 : 			{
; 2452 : 				scroll_t *scroller;
; 2453 : 				thinker_t *th;
; 2454 : 
; 2455 : 				for (th = thinkercap.next; th != &thinkercap; th = th->next)

  01518	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0151d	89 45 80	 mov	 DWORD PTR _th$7[ebp], eax
  01520	eb 09		 jmp	 SHORT $LN31@P_ProcessL
$LN29@P_ProcessL:
  01522	8b 45 80	 mov	 eax, DWORD PTR _th$7[ebp]
  01525	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01528	89 4d 80	 mov	 DWORD PTR _th$7[ebp], ecx
$LN31@P_ProcessL:
  0152b	81 7d 80 00 00
	00 00		 cmp	 DWORD PTR _th$7[ebp], OFFSET _thinkercap
  01532	74 75		 je	 SHORT $LN30@P_ProcessL

; 2456 : 				{
; 2457 : 					if (th->function.acp1 != (actionf_p1)T_Scroll)

  01534	8b 45 80	 mov	 eax, DWORD PTR _th$7[ebp]
  01537	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _T_Scroll
  0153e	74 02		 je	 SHORT $LN166@P_ProcessL

; 2458 : 						continue;

  01540	eb e0		 jmp	 SHORT $LN29@P_ProcessL
$LN166@P_ProcessL:

; 2459 : 
; 2460 : 					scroller = (scroll_t *)th;

  01542	8b 45 80	 mov	 eax, DWORD PTR _th$7[ebp]
  01545	89 45 84	 mov	 DWORD PTR _scroller$8[ebp], eax

; 2461 : 
; 2462 : 					if (sectors[scroller->affectee].tag != line->tag)

  01548	8b 45 84	 mov	 eax, DWORD PTR _scroller$8[ebp]
  0154b	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  01552	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  01558	0f bf 44 0a 14	 movsx	 eax, WORD PTR [edx+ecx+20]
  0155d	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  01560	0f bf 51 14	 movsx	 edx, WORD PTR [ecx+20]
  01564	3b c2		 cmp	 eax, edx
  01566	74 02		 je	 SHORT $LN167@P_ProcessL

; 2463 : 						continue;

  01568	eb b8		 jmp	 SHORT $LN29@P_ProcessL
$LN167@P_ProcessL:

; 2464 : 
; 2465 : 					scroller->dx = FixedMul(line->dx>>SCROLL_SHIFT, CARRYFACTOR);

  0156a	68 00 18 00 00	 push	 6144			; 00001800H
  0156f	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01572	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01575	c1 f9 05	 sar	 ecx, 5
  01578	51		 push	 ecx
  01579	e8 00 00 00 00	 call	 _FixedMul
  0157e	83 c4 08	 add	 esp, 8
  01581	8b 55 84	 mov	 edx, DWORD PTR _scroller$8[ebp]
  01584	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 2466 : 					scroller->dy = FixedMul(line->dy>>SCROLL_SHIFT, CARRYFACTOR);

  01587	68 00 18 00 00	 push	 6144			; 00001800H
  0158c	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0158f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01592	c1 f9 05	 sar	 ecx, 5
  01595	51		 push	 ecx
  01596	e8 00 00 00 00	 call	 _FixedMul
  0159b	83 c4 08	 add	 esp, 8
  0159e	8b 55 84	 mov	 edx, DWORD PTR _scroller$8[ebp]
  015a1	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 2467 : 				}

  015a4	e9 79 ff ff ff	 jmp	 $LN29@P_ProcessL
$LN30@P_ProcessL:

; 2468 : 			}
; 2469 : 			break;

  015a9	e9 aa 02 00 00	 jmp	 $LN2@P_ProcessL
$LN168@P_ProcessL:

; 2470 : 
; 2471 : 		case 436: // Shatter block remotely
; 2472 : 			{
; 2473 : 				INT16 sectag = (INT16)(sides[line->sidenum[0]].textureoffset>>FRACBITS);

  015ae	b8 02 00 00 00	 mov	 eax, 2
  015b3	6b c8 00	 imul	 ecx, eax, 0
  015b6	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  015b9	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  015be	6b c8 1c	 imul	 ecx, eax, 28
  015c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  015c7	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  015ca	c1 f8 10	 sar	 eax, 16			; 00000010H
  015cd	66 89 85 7c ff
	ff ff		 mov	 WORD PTR _sectag$6[ebp], ax

; 2474 : 				INT16 foftag = (INT16)(sides[line->sidenum[0]].rowoffset>>FRACBITS);

  015d4	b8 02 00 00 00	 mov	 eax, 2
  015d9	6b c8 00	 imul	 ecx, eax, 0
  015dc	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  015df	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  015e4	6b c8 1c	 imul	 ecx, eax, 28
  015e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  015ed	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  015f1	c1 f8 10	 sar	 eax, 16			; 00000010H
  015f4	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _foftag$5[ebp], ax

; 2475 : 				sector_t *sec; // Sector that the FOF is visible in
; 2476 : 				ffloor_t *rover; // FOF that we are going to crumble
; 2477 : 
; 2478 : 				for (secnum = -1; (secnum = P_FindSectorFromTag(sectag, secnum)) >= 0 ;)

  015fb	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _secnum$[ebp], -1
$LN32@P_ProcessL:
  01602	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  01605	50		 push	 eax
  01606	0f b7 8d 7c ff
	ff ff		 movzx	 ecx, WORD PTR _sectag$6[ebp]
  0160d	51		 push	 ecx
  0160e	e8 00 00 00 00	 call	 _P_FindSectorFromTag
  01613	83 c4 08	 add	 esp, 8
  01616	89 45 f8	 mov	 DWORD PTR _secnum$[ebp], eax
  01619	83 7d f8 00	 cmp	 DWORD PTR _secnum$[ebp], 0
  0161d	0f 8c c1 00 00
	00		 jl	 $LN33@P_ProcessL

; 2479 : 				{
; 2480 : 					sec = sectors + secnum;

  01623	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _secnum$[ebp], 248
  0162a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  01630	89 85 74 ff ff
	ff		 mov	 DWORD PTR _sec$4[ebp], eax

; 2481 : 
; 2482 : 					if (!sec->ffloors)

  01636	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sec$4[ebp]
  0163c	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  01643	75 16		 jne	 SHORT $LN169@P_ProcessL

; 2483 : 					{
; 2484 : 						CONS_Printf("Line type 436 Executor: Target sector #%d has no FOFs.\n", secnum);

  01645	8b 45 f8	 mov	 eax, DWORD PTR _secnum$[ebp]
  01648	50		 push	 eax
  01649	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HBJMHHLC@Line?5type?5436?5Executor?3?5Target?5@
  0164e	e8 00 00 00 00	 call	 _CONS_Printf
  01653	83 c4 08	 add	 esp, 8

; 2485 : 						return;

  01656	e9 fd 01 00 00	 jmp	 $LN2@P_ProcessL
$LN169@P_ProcessL:

; 2486 : 					}
; 2487 : 
; 2488 : 					for (rover = sec->ffloors; rover; rover = rover->next)

  0165b	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sec$4[ebp]
  01661	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  01667	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _rover$3[ebp], ecx
  0166d	eb 0f		 jmp	 SHORT $LN37@P_ProcessL
$LN35@P_ProcessL:
  0166f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _rover$3[ebp]
  01675	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01678	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _rover$3[ebp], ecx
$LN37@P_ProcessL:
  0167e	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _rover$3[ebp], 0
  01685	74 1f		 je	 SHORT $LN36@P_ProcessL

; 2489 : 					{
; 2490 : 						if (rover->master->frontsector->tag == foftag)

  01687	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _rover$3[ebp]
  0168d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01690	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  01693	0f bf 42 14	 movsx	 eax, WORD PTR [edx+20]
  01697	0f bf 8d 78 ff
	ff ff		 movsx	 ecx, WORD PTR _foftag$5[ebp]
  0169e	3b c1		 cmp	 eax, ecx
  016a0	75 02		 jne	 SHORT $LN170@P_ProcessL

; 2491 : 							break;

  016a2	eb 02		 jmp	 SHORT $LN36@P_ProcessL
$LN170@P_ProcessL:

; 2492 : 					}

  016a4	eb c9		 jmp	 SHORT $LN35@P_ProcessL
$LN36@P_ProcessL:

; 2493 : 
; 2494 : 					if (!rover)

  016a6	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _rover$3[ebp], 0
  016ad	75 1a		 jne	 SHORT $LN171@P_ProcessL

; 2495 : 					{
; 2496 : 						CONS_Printf("Line type 436 Executor: Can't find a FOF control sector with tag %d\n", foftag);

  016af	0f bf 85 78 ff
	ff ff		 movsx	 eax, WORD PTR _foftag$5[ebp]
  016b6	50		 push	 eax
  016b7	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@ONKOONKC@Line?5type?5436?5Executor?3?5Can?8t?5f@
  016bc	e8 00 00 00 00	 call	 _CONS_Printf
  016c1	83 c4 08	 add	 esp, 8

; 2497 : 						return;

  016c4	e9 8f 01 00 00	 jmp	 $LN2@P_ProcessL
$LN171@P_ProcessL:

; 2498 : 					}
; 2499 : 
; 2500 : 					EV_CrumbleChain(sec, rover);

  016c9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _rover$3[ebp]
  016cf	50		 push	 eax
  016d0	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sec$4[ebp]
  016d6	51		 push	 ecx
  016d7	e8 00 00 00 00	 call	 _EV_CrumbleChain
  016dc	83 c4 08	 add	 esp, 8

; 2501 : 				}

  016df	e9 1e ff ff ff	 jmp	 $LN32@P_ProcessL
$LN33@P_ProcessL:

; 2502 : 			}
; 2503 : 			break;

  016e4	e9 6f 01 00 00	 jmp	 $LN2@P_ProcessL
$LN172@P_ProcessL:

; 2504 : 		case 437: // Disable Player Controls
; 2505 : 			if (mo->player)

  016e9	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  016ec	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  016f3	74 70		 je	 SHORT $LN173@P_ProcessL

; 2506 : 				{
; 2507 : 				fixed_t fractime = (fixed_t)sides[line->sidenum[0]].textureoffset>>FRACBITS;

  016f5	b8 02 00 00 00	 mov	 eax, 2
  016fa	6b c8 00	 imul	 ecx, eax, 0
  016fd	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  01700	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  01705	6b c8 1c	 imul	 ecx, eax, 28
  01708	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0170e	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01711	c1 f8 10	 sar	 eax, 16			; 00000010H
  01714	89 85 6c ff ff
	ff		 mov	 DWORD PTR _fractime$2[ebp], eax

; 2508 : 				if (fractime < 1)

  0171a	83 bd 6c ff ff
	ff 01		 cmp	 DWORD PTR _fractime$2[ebp], 1
  01721	7d 0a		 jge	 SHORT $LN174@P_ProcessL

; 2509 : 					fractime = 1; //instantly wears off upon leaving

  01723	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _fractime$2[ebp], 1
$LN174@P_ProcessL:

; 2510 : 				if (line->flags & ML_NOCLIMB)

  0172d	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01730	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  01734	83 e1 40	 and	 ecx, 64			; 00000040H
  01737	74 11		 je	 SHORT $LN175@P_ProcessL

; 2511 : 					fractime += FRACUNIT; //more crazy &ing, as if music stuff wasn't enough

  01739	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _fractime$2[ebp]
  0173f	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  01744	89 85 6c ff ff
	ff		 mov	 DWORD PTR _fractime$2[ebp], eax
$LN175@P_ProcessL:

; 2512 : 				mo->player->powers[pw_nocontrol] = fractime;

  0174a	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0174d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01753	ba 04 00 00 00	 mov	 edx, 4
  01758	6b c2 1b	 imul	 eax, edx, 27
  0175b	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _fractime$2[ebp]
  01761	89 54 01 38	 mov	 DWORD PTR [ecx+eax+56], edx
$LN173@P_ProcessL:

; 2513 : 				}
; 2514 : 			break;

  01765	e9 ee 00 00 00	 jmp	 $LN2@P_ProcessL
$LN176@P_ProcessL:

; 2515 : 
; 2516 : 		case 438: // Set player scale
; 2517 : 			if (mo)

  0176a	83 7d 0c 00	 cmp	 DWORD PTR _mo$[ebp], 0
  0176e	74 6e		 je	 SHORT $LN180@P_ProcessL

; 2518 : 			{
; 2519 : 				mo->destscale = (UINT16)(P_AproxDistance(line->dx, line->dy) >> FRACBITS);

  01770	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01773	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01776	51		 push	 ecx
  01777	8b 55 08	 mov	 edx, DWORD PTR _line$[ebp]
  0177a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0177d	50		 push	 eax
  0177e	e8 00 00 00 00	 call	 _P_AproxDistance
  01783	83 c4 08	 add	 esp, 8
  01786	c1 f8 10	 sar	 eax, 16			; 00000010H
  01789	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  0178c	66 89 81 ce 00
	00 00		 mov	 WORD PTR [ecx+206], ax

; 2520 : 
; 2521 : 				if (mo->player)

  01793	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  01796	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0179d	74 3f		 je	 SHORT $LN180@P_ProcessL

; 2522 : 				{
; 2523 : 					if (mo->destscale < 25)

  0179f	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  017a2	0f b7 88 ce 00
	00 00		 movzx	 ecx, WORD PTR [eax+206]
  017a9	83 f9 19	 cmp	 ecx, 25			; 00000019H
  017ac	7d 0f		 jge	 SHORT $LN179@P_ProcessL

; 2524 : 						mo->destscale = 25;

  017ae	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  017b3	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  017b6	66 89 81 ce 00
	00 00		 mov	 WORD PTR [ecx+206], ax
$LN179@P_ProcessL:

; 2525 : 
; 2526 : 					if (mo->destscale > 250)

  017bd	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  017c0	0f b7 88 ce 00
	00 00		 movzx	 ecx, WORD PTR [eax+206]
  017c7	81 f9 fa 00 00
	00		 cmp	 ecx, 250		; 000000faH
  017cd	7e 0f		 jle	 SHORT $LN180@P_ProcessL

; 2527 : 						mo->destscale = 250;

  017cf	b8 fa 00 00 00	 mov	 eax, 250		; 000000faH
  017d4	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  017d7	66 89 81 ce 00
	00 00		 mov	 WORD PTR [ecx+206], ax
$LN180@P_ProcessL:

; 2528 : 				}
; 2529 : 			}
; 2530 : 			break;

  017de	eb 78		 jmp	 SHORT $LN2@P_ProcessL
$LN181@P_ProcessL:

; 2531 : 
; 2532 : 		case 450: // Execute Linedef Executor - for recursion
; 2533 : 			P_LinedefExecute(line->tag, mo, NULL);

  017e0	6a 00		 push	 0
  017e2	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  017e5	50		 push	 eax
  017e6	8b 4d 08	 mov	 ecx, DWORD PTR _line$[ebp]
  017e9	0f bf 51 14	 movsx	 edx, WORD PTR [ecx+20]
  017ed	52		 push	 edx
  017ee	e8 00 00 00 00	 call	 _P_LinedefExecute
  017f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2534 : 			break;

  017f6	eb 60		 jmp	 SHORT $LN2@P_ProcessL
$LN182@P_ProcessL:

; 2535 : 
; 2536 : #ifdef POLYOBJECTS
; 2537 : 		case 480: // Polyobj_DoorSlide
; 2538 : 		case 481: // Polyobj_DoorSwing
; 2539 : 			PolyDoor(line);

  017f8	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  017fb	50		 push	 eax
  017fc	e8 00 00 00 00	 call	 _PolyDoor
  01801	83 c4 04	 add	 esp, 4

; 2540 : 			break;

  01804	eb 52		 jmp	 SHORT $LN2@P_ProcessL
$LN184@P_ProcessL:

; 2541 : 		case 482: // Polyobj_Move
; 2542 : 		case 483: // Polyobj_OR_Move
; 2543 : 			PolyMove(line);

  01806	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01809	50		 push	 eax
  0180a	e8 00 00 00 00	 call	 _PolyMove
  0180f	83 c4 04	 add	 esp, 4

; 2544 : 			break;

  01812	eb 44		 jmp	 SHORT $LN2@P_ProcessL
$LN186@P_ProcessL:

; 2545 : 		case 484: // Polyobj_RotateRight
; 2546 : 		case 485: // Polyobj_OR_RotateRight
; 2547 : 		case 486: // Polyobj_RotateLeft
; 2548 : 		case 487: // Polyobj_OR_RotateLeft
; 2549 : 			PolyRotate(line);

  01814	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01817	50		 push	 eax
  01818	e8 00 00 00 00	 call	 _PolyRotate
  0181d	83 c4 04	 add	 esp, 4

; 2550 : 			break;

  01820	eb 36		 jmp	 SHORT $LN2@P_ProcessL
$LN190@P_ProcessL:

; 2551 : 		case 488: // Polyobj_Waypoint
; 2552 : 			PolyWaypoint(line);

  01822	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01825	50		 push	 eax
  01826	e8 00 00 00 00	 call	 _PolyWaypoint
  0182b	83 c4 04	 add	 esp, 4

; 2553 : 			break;

  0182e	eb 28		 jmp	 SHORT $LN2@P_ProcessL
$LN191@P_ProcessL:

; 2554 : 		case 489:
; 2555 : 			PolyInvisible(line);

  01830	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01833	50		 push	 eax
  01834	e8 00 00 00 00	 call	 _PolyInvisible
  01839	83 c4 04	 add	 esp, 4

; 2556 : 			break;

  0183c	eb 1a		 jmp	 SHORT $LN2@P_ProcessL
$LN192@P_ProcessL:

; 2557 : 		case 490:
; 2558 : 			PolyVisible(line);

  0183e	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  01841	50		 push	 eax
  01842	e8 00 00 00 00	 call	 _PolyVisible
  01847	83 c4 04	 add	 esp, 4

; 2559 : 			break;

  0184a	eb 0c		 jmp	 SHORT $LN2@P_ProcessL
$LN193@P_ProcessL:

; 2560 : 		case 491:
; 2561 : 			PolyTranslucency(line);

  0184c	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0184f	50		 push	 eax
  01850	e8 00 00 00 00	 call	 _PolyTranslucency
  01855	83 c4 04	 add	 esp, 4
$LN194@P_ProcessL:
$LN2@P_ProcessL:

; 2562 : 			break;
; 2563 : #endif
; 2564 : 
; 2565 : 		default:
; 2566 : 			break;
; 2567 : 	}
; 2568 : }

  01858	5f		 pop	 edi
  01859	5e		 pop	 esi
  0185a	5b		 pop	 ebx
  0185b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0185e	33 cd		 xor	 ecx, ebp
  01860	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01865	8b e5		 mov	 esp, ebp
  01867	5d		 pop	 ebp
  01868	c3		 ret	 0
  01869	0f 1f 00	 npad	 3
$LN205@P_ProcessL:
  0186c	00 00 00 00	 DD	 $LN38@P_ProcessL
  01870	00 00 00 00	 DD	 $LN39@P_ProcessL
  01874	00 00 00 00	 DD	 $LN40@P_ProcessL
  01878	00 00 00 00	 DD	 $LN42@P_ProcessL
  0187c	00 00 00 00	 DD	 $LN43@P_ProcessL
  01880	00 00 00 00	 DD	 $LN44@P_ProcessL
  01884	00 00 00 00	 DD	 $LN45@P_ProcessL
  01888	00 00 00 00	 DD	 $LN46@P_ProcessL
  0188c	00 00 00 00	 DD	 $LN47@P_ProcessL
  01890	00 00 00 00	 DD	 $LN48@P_ProcessL
  01894	00 00 00 00	 DD	 $LN49@P_ProcessL
  01898	00 00 00 00	 DD	 $LN50@P_ProcessL
  0189c	00 00 00 00	 DD	 $LN55@P_ProcessL
  018a0	00 00 00 00	 DD	 $LN67@P_ProcessL
  018a4	00 00 00 00	 DD	 $LN72@P_ProcessL
  018a8	00 00 00 00	 DD	 $LN94@P_ProcessL
  018ac	00 00 00 00	 DD	 $LN101@P_ProcessL
  018b0	00 00 00 00	 DD	 $LN107@P_ProcessL
  018b4	00 00 00 00	 DD	 $LN113@P_ProcessL
  018b8	00 00 00 00	 DD	 $LN119@P_ProcessL
  018bc	00 00 00 00	 DD	 $LN125@P_ProcessL
  018c0	00 00 00 00	 DD	 $LN126@P_ProcessL
  018c4	00 00 00 00	 DD	 $LN128@P_ProcessL
  018c8	00 00 00 00	 DD	 $LN135@P_ProcessL
  018cc	00 00 00 00	 DD	 $LN140@P_ProcessL
  018d0	00 00 00 00	 DD	 $LN145@P_ProcessL
  018d4	00 00 00 00	 DD	 $LN147@P_ProcessL
  018d8	00 00 00 00	 DD	 $LN151@P_ProcessL
  018dc	00 00 00 00	 DD	 $LN153@P_ProcessL
  018e0	00 00 00 00	 DD	 $LN154@P_ProcessL
  018e4	00 00 00 00	 DD	 $LN155@P_ProcessL
  018e8	00 00 00 00	 DD	 $LN156@P_ProcessL
  018ec	00 00 00 00	 DD	 $LN157@P_ProcessL
  018f0	00 00 00 00	 DD	 $LN159@P_ProcessL
  018f4	00 00 00 00	 DD	 $LN161@P_ProcessL
  018f8	00 00 00 00	 DD	 $LN165@P_ProcessL
  018fc	00 00 00 00	 DD	 $LN168@P_ProcessL
  01900	00 00 00 00	 DD	 $LN172@P_ProcessL
  01904	00 00 00 00	 DD	 $LN176@P_ProcessL
  01908	00 00 00 00	 DD	 $LN181@P_ProcessL
  0190c	00 00 00 00	 DD	 $LN182@P_ProcessL
  01910	00 00 00 00	 DD	 $LN184@P_ProcessL
  01914	00 00 00 00	 DD	 $LN186@P_ProcessL
  01918	00 00 00 00	 DD	 $LN190@P_ProcessL
  0191c	00 00 00 00	 DD	 $LN191@P_ProcessL
  01920	00 00 00 00	 DD	 $LN192@P_ProcessL
  01924	00 00 00 00	 DD	 $LN193@P_ProcessL
  01928	00 00 00 00	 DD	 $LN194@P_ProcessL
$LN204@P_ProcessL:
  0192c	00		 DB	 0
  0192d	01		 DB	 1
  0192e	02		 DB	 2
  0192f	03		 DB	 3
  01930	04		 DB	 4
  01931	05		 DB	 5
  01932	06		 DB	 6
  01933	07		 DB	 7
  01934	08		 DB	 8
  01935	09		 DB	 9
  01936	0a		 DB	 10			; 0000000aH
  01937	0b		 DB	 11			; 0000000bH
  01938	0c		 DB	 12			; 0000000cH
  01939	0d		 DB	 13			; 0000000dH
  0193a	0e		 DB	 14			; 0000000eH
  0193b	0f		 DB	 15			; 0000000fH
  0193c	10		 DB	 16			; 00000010H
  0193d	11		 DB	 17			; 00000011H
  0193e	12		 DB	 18			; 00000012H
  0193f	13		 DB	 19			; 00000013H
  01940	14		 DB	 20			; 00000014H
  01941	15		 DB	 21			; 00000015H
  01942	16		 DB	 22			; 00000016H
  01943	17		 DB	 23			; 00000017H
  01944	18		 DB	 24			; 00000018H
  01945	19		 DB	 25			; 00000019H
  01946	1a		 DB	 26			; 0000001aH
  01947	1b		 DB	 27			; 0000001bH
  01948	1c		 DB	 28			; 0000001cH
  01949	1d		 DB	 29			; 0000001dH
  0194a	1e		 DB	 30			; 0000001eH
  0194b	1f		 DB	 31			; 0000001fH
  0194c	20		 DB	 32			; 00000020H
  0194d	21		 DB	 33			; 00000021H
  0194e	22		 DB	 34			; 00000022H
  0194f	23		 DB	 35			; 00000023H
  01950	24		 DB	 36			; 00000024H
  01951	25		 DB	 37			; 00000025H
  01952	26		 DB	 38			; 00000026H
  01953	2f		 DB	 47			; 0000002fH
  01954	2f		 DB	 47			; 0000002fH
  01955	2f		 DB	 47			; 0000002fH
  01956	2f		 DB	 47			; 0000002fH
  01957	2f		 DB	 47			; 0000002fH
  01958	2f		 DB	 47			; 0000002fH
  01959	2f		 DB	 47			; 0000002fH
  0195a	2f		 DB	 47			; 0000002fH
  0195b	2f		 DB	 47			; 0000002fH
  0195c	2f		 DB	 47			; 0000002fH
  0195d	2f		 DB	 47			; 0000002fH
  0195e	27		 DB	 39			; 00000027H
  0195f	2f		 DB	 47			; 0000002fH
  01960	2f		 DB	 47			; 0000002fH
  01961	2f		 DB	 47			; 0000002fH
  01962	2f		 DB	 47			; 0000002fH
  01963	2f		 DB	 47			; 0000002fH
  01964	2f		 DB	 47			; 0000002fH
  01965	2f		 DB	 47			; 0000002fH
  01966	2f		 DB	 47			; 0000002fH
  01967	2f		 DB	 47			; 0000002fH
  01968	2f		 DB	 47			; 0000002fH
  01969	2f		 DB	 47			; 0000002fH
  0196a	2f		 DB	 47			; 0000002fH
  0196b	2f		 DB	 47			; 0000002fH
  0196c	2f		 DB	 47			; 0000002fH
  0196d	2f		 DB	 47			; 0000002fH
  0196e	2f		 DB	 47			; 0000002fH
  0196f	2f		 DB	 47			; 0000002fH
  01970	2f		 DB	 47			; 0000002fH
  01971	2f		 DB	 47			; 0000002fH
  01972	2f		 DB	 47			; 0000002fH
  01973	2f		 DB	 47			; 0000002fH
  01974	2f		 DB	 47			; 0000002fH
  01975	2f		 DB	 47			; 0000002fH
  01976	2f		 DB	 47			; 0000002fH
  01977	2f		 DB	 47			; 0000002fH
  01978	2f		 DB	 47			; 0000002fH
  01979	2f		 DB	 47			; 0000002fH
  0197a	2f		 DB	 47			; 0000002fH
  0197b	2f		 DB	 47			; 0000002fH
  0197c	28		 DB	 40			; 00000028H
  0197d	28		 DB	 40			; 00000028H
  0197e	29		 DB	 41			; 00000029H
  0197f	29		 DB	 41			; 00000029H
  01980	2a		 DB	 42			; 0000002aH
  01981	2a		 DB	 42			; 0000002aH
  01982	2a		 DB	 42			; 0000002aH
  01983	2a		 DB	 42			; 0000002aH
  01984	2b		 DB	 43			; 0000002bH
  01985	2c		 DB	 44			; 0000002cH
  01986	2d		 DB	 45			; 0000002dH
  01987	2e		 DB	 46			; 0000002eH
_P_ProcessLineSpecial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddFakeFloorsByLine
_TEXT	SEGMENT
_sec$ = -8						; size = 4
_s$ = -4						; size = 4
_line$ = 8						; size = 4
_ffloorflags$ = 12					; size = 4
_P_AddFakeFloorsByLine PROC				; COMDAT

; 5905 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5906 : 	INT32 s;
; 5907 : 	size_t sec = sides[*lines[line].sidenum].sector-sectors;

  00009	6b 45 08 4c	 imul	 eax, DWORD PTR _line$[ebp], 76
  0000d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00013	b9 02 00 00 00	 mov	 ecx, 2
  00018	6b d1 00	 imul	 edx, ecx, 0
  0001b	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  00020	6b c8 1c	 imul	 ecx, eax, 28
  00023	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00029	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0002d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00033	99		 cdq
  00034	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00039	f7 f9		 idiv	 ecx
  0003b	89 45 f8	 mov	 DWORD PTR _sec$[ebp], eax

; 5908 : 
; 5909 : 	for (s = -1; (s = P_FindSectorFromLineTag(lines+line, s)) >= 0 ;)

  0003e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN2@P_AddFakeF:
  00045	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00048	50		 push	 eax
  00049	6b 4d 08 4c	 imul	 ecx, DWORD PTR _line$[ebp], 76
  0004d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00059	83 c4 08	 add	 esp, 8
  0005c	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax
  0005f	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  00063	7c 35		 jl	 SHORT $LN3@P_AddFakeF

; 5910 : 		P_AddFakeFloor(&sectors[s], &sectors[sec], lines+line, ffloorflags);

  00065	8b 45 0c	 mov	 eax, DWORD PTR _ffloorflags$[ebp]
  00068	50		 push	 eax
  00069	6b 4d 08 4c	 imul	 ecx, DWORD PTR _line$[ebp], 76
  0006d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00073	51		 push	 ecx
  00074	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _sec$[ebp], 248
  0007b	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  00081	52		 push	 edx
  00082	69 45 fc f8 00
	00 00		 imul	 eax, DWORD PTR _s$[ebp], 248
  00089	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _P_AddFakeFloor
  00095	83 c4 10	 add	 esp, 16			; 00000010H
  00098	eb ab		 jmp	 SHORT $LN2@P_AddFakeF
$LN3@P_AddFakeF:

; 5911 : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_P_AddFakeFloorsByLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddFloatThinker
_TEXT	SEGMENT
_floater$ = -4						; size = 4
_sec$ = 8						; size = 4
_tag$ = 12						; size = 4
_sourceline$ = 16					; size = 4
_P_AddFloatThinker PROC					; COMDAT

; 4508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4509 : 	levelspecthink_t *floater;
; 4510 : 
; 4511 : 	// create and initialize new thinker
; 4512 : 	floater = Z_Calloc(sizeof (*floater), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _floater$[ebp], eax

; 4513 : 	P_AddThinker(&floater->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _floater$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4514 : 
; 4515 : 	floater->thinker.function.acp1 = (actionf_p1)T_FloatSector;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _floater$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_FloatSector

; 4516 : 
; 4517 : 	floater->sector = sec;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _floater$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00038	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4518 : 	floater->vars[0] = tag;

  0003b	b8 04 00 00 00	 mov	 eax, 4
  00040	6b c8 00	 imul	 ecx, eax, 0
  00043	8b 55 fc	 mov	 edx, DWORD PTR _floater$[ebp]
  00046	8b 45 0c	 mov	 eax, DWORD PTR _tag$[ebp]
  00049	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 4519 : 	floater->sourceline = sourceline;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _floater$[ebp]
  00050	8b 4d 10	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  00053	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4520 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_P_AddFloatThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_AddBlockThinker
_TEXT	SEGMENT
_block$ = -4						; size = 4
_sec$ = 8						; size = 4
_sourceline$ = 12					; size = 4
_P_AddBlockThinker PROC					; COMDAT

; 4564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4565 : 	levelspecthink_t *block;
; 4566 : 
; 4567 : 	// create and initialize new elevator thinker
; 4568 : 	block = Z_Calloc(sizeof (*block), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 58		 push	 88			; 00000058H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 4569 : 	P_AddThinker(&block->thinker);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _P_AddThinker
  00025	83 c4 04	 add	 esp, 4

; 4570 : 
; 4571 : 	block->thinker.function.acp1 = (actionf_p1)T_MarioBlockChecker;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0002b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_MarioBlockChecker

; 4572 : 	block->sourceline = sourceline;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  00038	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 4573 : 
; 4574 : 	block->sector = sec;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00041	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 4575 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_P_AddBlockThinker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _Add_MasterDisappearer
_TEXT	SEGMENT
_d$ = -4						; size = 4
_appeartime$ = 8					; size = 4
_disappeartime$ = 12					; size = 4
_offset$ = 16						; size = 4
_line$ = 20						; size = 4
_sourceline$ = 24					; size = 4
_Add_MasterDisappearer PROC				; COMDAT

; 6365 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6366 : 	disappear_t *d = Z_Malloc(sizeof *d, PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 2c		 push	 44			; 0000002cH
  00011	e8 00 00 00 00	 call	 _Z_MallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _d$[ebp], eax

; 6367 : 
; 6368 : 	d->thinker.function.acp1 = (actionf_p1)T_Disappear;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_Disappear

; 6369 : 	d->appeartime = appeartime;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _appeartime$[ebp]
  0002c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 6370 : 	d->disappeartime = disappeartime;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _disappeartime$[ebp]
  00035	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 6371 : 	d->offset = offset;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp]
  0003e	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 6372 : 	d->affectee = line;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  00044	8b 4d 14	 mov	 ecx, DWORD PTR _line$[ebp]
  00047	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 6373 : 	d->sourceline = sourceline;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  0004d	8b 4d 18	 mov	 ecx, DWORD PTR _sourceline$[ebp]
  00050	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 6374 : 	d->exists = true;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  00056	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1

; 6375 : 	d->timer = 1;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  00060	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1

; 6376 : 
; 6377 : 	P_AddThinker(&d->thinker);

  00067	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _P_AddThinker
  00070	83 c4 04	 add	 esp, 4

; 6378 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_Add_MasterDisappearer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _Add_Pusher
_TEXT	SEGMENT
_p$ = -4						; size = 4
_type$ = 8						; size = 4
_x_mag$ = 12						; size = 4
_y_mag$ = 16						; size = 4
_source$ = 20						; size = 4
_affectee$ = 24						; size = 4
_referrer$ = 28						; size = 4
_exclusive$ = 32					; size = 4
_slider$ = 36						; size = 4
_Add_Pusher PROC					; COMDAT

; 6607 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6608 : 	pusher_t *p = Z_Calloc(sizeof *p, PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 48		 push	 72			; 00000048H
  00011	e8 00 00 00 00	 call	 _Z_CallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 6609 : 
; 6610 : 	p->thinker.function.acp1 = (actionf_p1)T_Pusher;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_Pusher

; 6611 : 	p->source = source;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00029	8b 4d 14	 mov	 ecx, DWORD PTR _source$[ebp]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 6612 : 	p->type = type;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  00035	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 6613 : 	p->x_mag = x_mag>>FRACBITS;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _x_mag$[ebp]
  0003b	c1 f8 10	 sar	 eax, 16			; 00000010H
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00041	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 6614 : 	p->y_mag = y_mag>>FRACBITS;

  00044	8b 45 10	 mov	 eax, DWORD PTR _y_mag$[ebp]
  00047	c1 f8 10	 sar	 eax, 16			; 00000010H
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0004d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 6615 : 	p->exclusive = exclusive;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00053	8b 4d 20	 mov	 ecx, DWORD PTR _exclusive$[ebp]
  00056	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 6616 : 	p->slider = slider;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0005c	8b 4d 24	 mov	 ecx, DWORD PTR _slider$[ebp]
  0005f	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 6617 : 
; 6618 : 	if (referrer != -1)

  00062	83 7d 1c ff	 cmp	 DWORD PTR _referrer$[ebp], -1
  00066	74 12		 je	 SHORT $LN2@Add_Pusher

; 6619 : 	{
; 6620 : 		p->roverpusher = true;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0006b	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1

; 6621 : 		p->referrer = referrer;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00072	8b 4d 1c	 mov	 ecx, DWORD PTR _referrer$[ebp]
  00075	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 6622 : 	}

  00078	eb 07		 jmp	 SHORT $LN3@Add_Pusher
$LN2@Add_Pusher:

; 6623 : 	else
; 6624 : 		p->roverpusher = false;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0007d	c6 40 38 00	 mov	 BYTE PTR [eax+56], 0
$LN3@Add_Pusher:

; 6625 : 
; 6626 : 	// "The right triangle of the square of the length of the hypotenuse is equal to the sum of the squares of the lengths of the other two sides."
; 6627 : 	// "Bah! Stupid brains! Don't you know anything besides the Pythagorean Theorem?" - Earthworm Jim
; 6628 : 	if (type == p_downcurrent || type == p_upcurrent || type == p_upwind || type == p_downwind)

  00081	83 7d 08 04	 cmp	 DWORD PTR _type$[ebp], 4
  00085	74 12		 je	 SHORT $LN6@Add_Pusher
  00087	83 7d 08 03	 cmp	 DWORD PTR _type$[ebp], 3
  0008b	74 0c		 je	 SHORT $LN6@Add_Pusher
  0008d	83 7d 08 05	 cmp	 DWORD PTR _type$[ebp], 5
  00091	74 06		 je	 SHORT $LN6@Add_Pusher
  00093	83 7d 08 06	 cmp	 DWORD PTR _type$[ebp], 6
  00097	75 21		 jne	 SHORT $LN4@Add_Pusher
$LN6@Add_Pusher:

; 6629 : 		p->magnitude = P_AproxDistance(p->x_mag,p->y_mag)<<(FRACBITS-PUSH_FACTOR);

  00099	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0009c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0009f	51		 push	 ecx
  000a0	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000a3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _P_AproxDistance
  000ac	83 c4 08	 add	 esp, 8
  000af	c1 e0 09	 shl	 eax, 9
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000b5	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  000b8	eb 1c		 jmp	 SHORT $LN5@Add_Pusher
$LN4@Add_Pusher:

; 6630 : 	else
; 6631 : 		p->magnitude = P_AproxDistance(p->x_mag,p->y_mag);

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000bd	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000c0	51		 push	 ecx
  000c1	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000c4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _P_AproxDistance
  000cd	83 c4 08	 add	 esp, 8
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  000d3	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN5@Add_Pusher:

; 6632 : 	if (source) // point source exist?

  000d6	83 7d 14 00	 cmp	 DWORD PTR _source$[ebp], 0
  000da	74 59		 je	 SHORT $LN7@Add_Pusher

; 6633 : 	{
; 6634 : 		// where force goes to zero
; 6635 : 		if (type == p_push)

  000dc	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  000e0	75 17		 jne	 SHORT $LN8@Add_Pusher

; 6636 : 			p->radius = AngleFixed(source->angle);

  000e2	8b 45 14	 mov	 eax, DWORD PTR _source$[ebp]
  000e5	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _AngleFixed
  000ee	83 c4 04	 add	 esp, 4
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  000f4	89 42 24	 mov	 DWORD PTR [edx+36], eax
  000f7	eb 0f		 jmp	 SHORT $LN9@Add_Pusher
$LN8@Add_Pusher:

; 6637 : 		else
; 6638 : 			p->radius = (p->magnitude)<<(FRACBITS+1);

  000f9	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  000fc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000ff	c1 e1 11	 shl	 ecx, 17			; 00000011H
  00102	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00105	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
$LN9@Add_Pusher:

; 6639 : 
; 6640 : 		p->x = p->source->x;

  00108	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0010b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0010e	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00111	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00114	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 6641 : 		p->y = p->source->y;

  00117	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0011a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0011d	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00120	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00123	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 6642 : 		p->z = p->source->z;

  00126	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00129	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0012c	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0012f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00132	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN7@Add_Pusher:

; 6643 : 	}
; 6644 : 	p->affectee = affectee;

  00135	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00138	8b 4d 18	 mov	 ecx, DWORD PTR _affectee$[ebp]
  0013b	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 6645 : 	P_AddThinker(&p->thinker);

  0013e	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _P_AddThinker
  00147	83 c4 04	 add	 esp, 4

; 6646 : }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
_Add_Pusher ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SpawnPushers
_TEXT	SEGMENT
tv69 = -84						; size = 4
_thing$ = -16						; size = 4
_s$ = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -4						; size = 4
_P_SpawnPushers PROC					; COMDAT

; 7098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7099 : 	size_t i;
; 7100 : 	line_t *l = lines;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  0000e	89 45 f8	 mov	 DWORD PTR _l$[ebp], eax

; 7101 : 	register INT32 s;
; 7102 : 	mobj_t *thing;
; 7103 : 
; 7104 : 	for (i = 0; i < numlines; i++, l++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00018	eb 12		 jmp	 SHORT $LN4@P_SpawnPus
$LN2@P_SpawnPus:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00026	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00029	89 4d f8	 mov	 DWORD PTR _l$[ebp], ecx
$LN4@P_SpawnPus:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00035	0f 83 de 02 00
	00		 jae	 $LN3@P_SpawnPus

; 7105 : 		switch (l->special)

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0003e	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00042	89 4d ac	 mov	 DWORD PTR tv69[ebp], ecx
  00045	8b 55 ac	 mov	 edx, DWORD PTR tv69[ebp]
  00048	81 ea 1d 02 00
	00		 sub	 edx, 541		; 0000021dH
  0004e	89 55 ac	 mov	 DWORD PTR tv69[ebp], edx
  00051	83 7d ac 06	 cmp	 DWORD PTR tv69[ebp], 6
  00055	0f 87 b9 02 00
	00		 ja	 $LN5@P_SpawnPus
  0005b	8b 45 ac	 mov	 eax, DWORD PTR tv69[ebp]
  0005e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN37@P_SpawnPus[eax*4]
$LN28@P_SpawnPus:

; 7106 : 		{
; 7107 : 			case 541: // wind
; 7108 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  00065	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN7@P_SpawnPus:
  0006c	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00079	83 c4 08	 add	 esp, 8
  0007c	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  0007f	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  00083	7c 3b		 jl	 SHORT $LN8@P_SpawnPus

; 7109 : 					Add_Pusher(p_wind, l->dx, l->dy, NULL, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  00085	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  00088	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0008c	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00092	51		 push	 ecx
  00093	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  00096	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  0009a	83 e0 40	 and	 eax, 64			; 00000040H
  0009d	50		 push	 eax
  0009e	6a ff		 push	 -1
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  000a3	51		 push	 ecx
  000a4	6a 00		 push	 0
  000a6	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  000a9	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000ac	50		 push	 eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  000b0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b3	52		 push	 edx
  000b4	6a 01		 push	 1
  000b6	e8 00 00 00 00	 call	 _Add_Pusher
  000bb	83 c4 20	 add	 esp, 32			; 00000020H
  000be	eb ac		 jmp	 SHORT $LN7@P_SpawnPus
$LN8@P_SpawnPus:

; 7110 : 				break;

  000c0	e9 4f 02 00 00	 jmp	 $LN5@P_SpawnPus
$LN29@P_SpawnPus:

; 7111 : 			case 544: // current
; 7112 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  000c5	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN10@P_SpawnPus:
  000cc	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  000d9	83 c4 08	 add	 esp, 8
  000dc	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  000df	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  000e3	7c 3b		 jl	 SHORT $LN11@P_SpawnPus

; 7113 : 					Add_Pusher(p_current, l->dx, l->dy, NULL, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  000e5	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  000e8	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  000ec	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  000f2	51		 push	 ecx
  000f3	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  000f6	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  000fa	83 e0 40	 and	 eax, 64			; 00000040H
  000fd	50		 push	 eax
  000fe	6a ff		 push	 -1
  00100	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00103	51		 push	 ecx
  00104	6a 00		 push	 0
  00106	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  00109	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010c	50		 push	 eax
  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00110	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00113	52		 push	 edx
  00114	6a 02		 push	 2
  00116	e8 00 00 00 00	 call	 _Add_Pusher
  0011b	83 c4 20	 add	 esp, 32			; 00000020H
  0011e	eb ac		 jmp	 SHORT $LN10@P_SpawnPus
$LN11@P_SpawnPus:

; 7114 : 				break;

  00120	e9 ef 01 00 00	 jmp	 $LN5@P_SpawnPus
$LN30@P_SpawnPus:

; 7115 : 			case 547: // push/pull
; 7116 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  00125	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN13@P_SpawnPus:
  0012c	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  0012f	50		 push	 eax
  00130	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00133	51		 push	 ecx
  00134	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00139	83 c4 08	 add	 esp, 8
  0013c	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  0013f	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  00143	7c 52		 jl	 SHORT $LN14@P_SpawnPus

; 7117 : 				{
; 7118 : 					thing = P_GetPushThing(s);

  00145	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _P_GetPushThing
  0014e	83 c4 04	 add	 esp, 4
  00151	89 45 f0	 mov	 DWORD PTR _thing$[ebp], eax

; 7119 : 					if (thing) // No MT_P* means no effect

  00154	83 7d f0 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00158	74 3b		 je	 SHORT $LN31@P_SpawnPus

; 7120 : 						Add_Pusher(p_push, l->dx, l->dy, thing, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  0015a	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0015d	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00161	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00167	51		 push	 ecx
  00168	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  0016b	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  0016f	83 e0 40	 and	 eax, 64			; 00000040H
  00172	50		 push	 eax
  00173	6a ff		 push	 -1
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00178	51		 push	 ecx
  00179	8b 55 f0	 mov	 edx, DWORD PTR _thing$[ebp]
  0017c	52		 push	 edx
  0017d	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  00180	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00183	51		 push	 ecx
  00184	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  00187	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0018a	50		 push	 eax
  0018b	6a 00		 push	 0
  0018d	e8 00 00 00 00	 call	 _Add_Pusher
  00192	83 c4 20	 add	 esp, 32			; 00000020H
$LN31@P_SpawnPus:

; 7121 : 				}

  00195	eb 95		 jmp	 SHORT $LN13@P_SpawnPus
$LN14@P_SpawnPus:

; 7122 : 				break;

  00197	e9 78 01 00 00	 jmp	 $LN5@P_SpawnPus
$LN32@P_SpawnPus:

; 7123 : 			case 545: // current up
; 7124 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  0019c	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN16@P_SpawnPus:
  001a3	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  001a6	50		 push	 eax
  001a7	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  001b0	83 c4 08	 add	 esp, 8
  001b3	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  001b6	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  001ba	7c 3b		 jl	 SHORT $LN17@P_SpawnPus

; 7125 : 					Add_Pusher(p_upcurrent, l->dx, l->dy, NULL, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  001bf	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  001c3	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  001c9	51		 push	 ecx
  001ca	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  001cd	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  001d1	83 e0 40	 and	 eax, 64			; 00000040H
  001d4	50		 push	 eax
  001d5	6a ff		 push	 -1
  001d7	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  001da	51		 push	 ecx
  001db	6a 00		 push	 0
  001dd	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  001e0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001e3	50		 push	 eax
  001e4	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  001e7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ea	52		 push	 edx
  001eb	6a 03		 push	 3
  001ed	e8 00 00 00 00	 call	 _Add_Pusher
  001f2	83 c4 20	 add	 esp, 32			; 00000020H
  001f5	eb ac		 jmp	 SHORT $LN16@P_SpawnPus
$LN17@P_SpawnPus:

; 7126 : 				break;

  001f7	e9 18 01 00 00	 jmp	 $LN5@P_SpawnPus
$LN33@P_SpawnPus:

; 7127 : 			case 546: // current down
; 7128 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  001fc	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN19@P_SpawnPus:
  00203	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00206	50		 push	 eax
  00207	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00210	83 c4 08	 add	 esp, 8
  00213	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  00216	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  0021a	7c 3b		 jl	 SHORT $LN20@P_SpawnPus

; 7129 : 					Add_Pusher(p_downcurrent, l->dx, l->dy, NULL, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  0021c	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0021f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00223	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00229	51		 push	 ecx
  0022a	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  0022d	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00231	83 e0 40	 and	 eax, 64			; 00000040H
  00234	50		 push	 eax
  00235	6a ff		 push	 -1
  00237	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  0023a	51		 push	 ecx
  0023b	6a 00		 push	 0
  0023d	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  00240	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00243	50		 push	 eax
  00244	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00247	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0024a	52		 push	 edx
  0024b	6a 04		 push	 4
  0024d	e8 00 00 00 00	 call	 _Add_Pusher
  00252	83 c4 20	 add	 esp, 32			; 00000020H
  00255	eb ac		 jmp	 SHORT $LN19@P_SpawnPus
$LN20@P_SpawnPus:

; 7130 : 				break;

  00257	e9 b8 00 00 00	 jmp	 $LN5@P_SpawnPus
$LN34@P_SpawnPus:

; 7131 : 			case 542: // wind up
; 7132 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  0025c	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN22@P_SpawnPus:
  00263	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00266	50		 push	 eax
  00267	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  0026a	51		 push	 ecx
  0026b	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00270	83 c4 08	 add	 esp, 8
  00273	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  00276	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  0027a	7c 3b		 jl	 SHORT $LN23@P_SpawnPus

; 7133 : 					Add_Pusher(p_upwind, l->dx, l->dy, NULL, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  0027c	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0027f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00283	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00289	51		 push	 ecx
  0028a	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  0028d	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00291	83 e0 40	 and	 eax, 64			; 00000040H
  00294	50		 push	 eax
  00295	6a ff		 push	 -1
  00297	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  0029a	51		 push	 ecx
  0029b	6a 00		 push	 0
  0029d	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  002a0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002a3	50		 push	 eax
  002a4	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  002a7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002aa	52		 push	 edx
  002ab	6a 05		 push	 5
  002ad	e8 00 00 00 00	 call	 _Add_Pusher
  002b2	83 c4 20	 add	 esp, 32			; 00000020H
  002b5	eb ac		 jmp	 SHORT $LN22@P_SpawnPus
$LN23@P_SpawnPus:

; 7134 : 				break;

  002b7	eb 5b		 jmp	 SHORT $LN5@P_SpawnPus
$LN35@P_SpawnPus:

; 7135 : 			case 543: // wind down
; 7136 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  002b9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN25@P_SpawnPus:
  002c0	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  002c3	50		 push	 eax
  002c4	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  002c7	51		 push	 ecx
  002c8	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  002cd	83 c4 08	 add	 esp, 8
  002d0	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  002d3	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  002d7	7c 3b		 jl	 SHORT $LN26@P_SpawnPus

; 7137 : 					Add_Pusher(p_downwind, l->dx, l->dy, NULL, s, -1, l->flags & ML_NOCLIMB, l->flags & ML_EFFECT4);

  002d9	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  002dc	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  002e0	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  002e6	51		 push	 ecx
  002e7	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  002ea	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  002ee	83 e0 40	 and	 eax, 64			; 00000040H
  002f1	50		 push	 eax
  002f2	6a ff		 push	 -1
  002f4	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  002f7	51		 push	 ecx
  002f8	6a 00		 push	 0
  002fa	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  002fd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00300	50		 push	 eax
  00301	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00304	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00307	52		 push	 edx
  00308	6a 06		 push	 6
  0030a	e8 00 00 00 00	 call	 _Add_Pusher
  0030f	83 c4 20	 add	 esp, 32			; 00000020H
  00312	eb ac		 jmp	 SHORT $LN25@P_SpawnPus
$LN26@P_SpawnPus:
$LN5@P_SpawnPus:

; 7138 : 				break;
; 7139 : 		}

  00314	e9 01 fd ff ff	 jmp	 $LN2@P_SpawnPus
$LN3@P_SpawnPus:

; 7140 : }

  00319	5f		 pop	 edi
  0031a	5e		 pop	 esi
  0031b	5b		 pop	 ebx
  0031c	8b e5		 mov	 esp, ebp
  0031e	5d		 pop	 ebp
  0031f	c3		 ret	 0
$LN37@P_SpawnPus:
  00320	00 00 00 00	 DD	 $LN28@P_SpawnPus
  00324	00 00 00 00	 DD	 $LN34@P_SpawnPus
  00328	00 00 00 00	 DD	 $LN35@P_SpawnPus
  0032c	00 00 00 00	 DD	 $LN29@P_SpawnPus
  00330	00 00 00 00	 DD	 $LN32@P_SpawnPus
  00334	00 00 00 00	 DD	 $LN33@P_SpawnPus
  00338	00 00 00 00	 DD	 $LN30@P_SpawnPus
_P_SpawnPushers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SpawnFriction
_TEXT	SEGMENT
_movefactor$ = -24					; size = 4
_friction$ = -20					; size = 4
_length$ = -16						; size = 4
_s$ = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -4						; size = 4
_P_SpawnFriction PROC					; COMDAT

; 6548 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6549 : 	size_t i;
; 6550 : 	line_t *l = lines;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  0000e	89 45 f8	 mov	 DWORD PTR _l$[ebp], eax

; 6551 : 	register INT32 s;
; 6552 : 	fixed_t length; // line length controls magnitude
; 6553 : 	fixed_t friction; // friction value to be applied during movement
; 6554 : 	INT32 movefactor; // applied to each player move to simulate inertia
; 6555 : 
; 6556 : 	for (i = 0; i < numlines; i++, l++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00018	eb 12		 jmp	 SHORT $LN4@P_SpawnFri
$LN2@P_SpawnFri:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00026	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00029	89 4d f8	 mov	 DWORD PTR _l$[ebp], ecx
$LN4@P_SpawnFri:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00035	0f 83 e6 00 00
	00		 jae	 $LN3@P_SpawnFri

; 6557 : 		if (l->special == 540)

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0003e	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00042	81 f9 1c 02 00
	00		 cmp	 ecx, 540		; 0000021cH
  00048	0f 85 ce 00 00
	00		 jne	 $LN6@P_SpawnFri

; 6558 : 		{
; 6559 : 			length = P_AproxDistance(l->dx, l->dy)>>FRACBITS;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  00051	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00054	51		 push	 ecx
  00055	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  00058	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _P_AproxDistance
  00061	83 c4 08	 add	 esp, 8
  00064	c1 f8 10	 sar	 eax, 16			; 00000010H
  00067	89 45 f0	 mov	 DWORD PTR _length$[ebp], eax

; 6560 : 			friction = (0x1EB8*length)/0x80 + 0xD000;

  0006a	69 45 f0 b8 1e
	00 00		 imul	 eax, DWORD PTR _length$[ebp], 7864
  00071	99		 cdq
  00072	83 e2 7f	 and	 edx, 127		; 0000007fH
  00075	03 c2		 add	 eax, edx
  00077	c1 f8 07	 sar	 eax, 7
  0007a	05 00 d0 00 00	 add	 eax, 53248		; 0000d000H
  0007f	89 45 ec	 mov	 DWORD PTR _friction$[ebp], eax

; 6561 : 
; 6562 : 			if (friction > FRACUNIT)

  00082	81 7d ec 00 00
	01 00		 cmp	 DWORD PTR _friction$[ebp], 65536 ; 00010000H
  00089	7e 07		 jle	 SHORT $LN9@P_SpawnFri

; 6563 : 				friction = FRACUNIT;

  0008b	c7 45 ec 00 00
	01 00		 mov	 DWORD PTR _friction$[ebp], 65536 ; 00010000H
$LN9@P_SpawnFri:

; 6564 : 			if (friction < 0)

  00092	83 7d ec 00	 cmp	 DWORD PTR _friction$[ebp], 0
  00096	7d 07		 jge	 SHORT $LN10@P_SpawnFri

; 6565 : 				friction = 0;

  00098	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _friction$[ebp], 0
$LN10@P_SpawnFri:

; 6566 : 
; 6567 : 			// The following check might seem odd. At the time of movement,
; 6568 : 			// the move distance is multiplied by 'friction/0x10000', so a
; 6569 : 			// higher friction value actually means 'less friction'.
; 6570 : 
; 6571 : 			if (friction > ORIG_FRICTION) // ice

  0009f	81 7d ec 00 e8
	00 00		 cmp	 DWORD PTR _friction$[ebp], 59392 ; 0000e800H
  000a6	7e 18		 jle	 SHORT $LN11@P_SpawnFri

; 6572 : 				movefactor = ((0x10092 - friction)*(0x70))/0x158;

  000a8	b8 92 00 01 00	 mov	 eax, 65682		; 00010092H
  000ad	2b 45 ec	 sub	 eax, DWORD PTR _friction$[ebp]
  000b0	6b c0 70	 imul	 eax, eax, 112
  000b3	99		 cdq
  000b4	b9 58 01 00 00	 mov	 ecx, 344		; 00000158H
  000b9	f7 f9		 idiv	 ecx
  000bb	89 45 e8	 mov	 DWORD PTR _movefactor$[ebp], eax
  000be	eb 17		 jmp	 SHORT $LN12@P_SpawnFri
$LN11@P_SpawnFri:

; 6573 : 			else
; 6574 : 				movefactor = ((friction - 0xDB34)*(0xA))/0x80;

  000c0	8b 45 ec	 mov	 eax, DWORD PTR _friction$[ebp]
  000c3	2d 34 db 00 00	 sub	 eax, 56116		; 0000db34H
  000c8	6b c0 0a	 imul	 eax, eax, 10
  000cb	99		 cdq
  000cc	83 e2 7f	 and	 edx, 127		; 0000007fH
  000cf	03 c2		 add	 eax, edx
  000d1	c1 f8 07	 sar	 eax, 7
  000d4	89 45 e8	 mov	 DWORD PTR _movefactor$[ebp], eax
$LN12@P_SpawnFri:

; 6575 : 
; 6576 : 			// killough 8/28/98: prevent odd situations
; 6577 : 			if (movefactor < 32)

  000d7	83 7d e8 20	 cmp	 DWORD PTR _movefactor$[ebp], 32 ; 00000020H
  000db	7d 07		 jge	 SHORT $LN13@P_SpawnFri

; 6578 : 				movefactor = 32;

  000dd	c7 45 e8 20 00
	00 00		 mov	 DWORD PTR _movefactor$[ebp], 32 ; 00000020H
$LN13@P_SpawnFri:

; 6579 : 
; 6580 : 			for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  000e4	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
$LN5@P_SpawnFri:
  000eb	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  000f8	83 c4 08	 add	 esp, 8
  000fb	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
  000fe	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  00102	7c 18		 jl	 SHORT $LN6@P_SpawnFri

; 6581 : 				Add_Friction(friction, movefactor, s, -1);

  00104	6a ff		 push	 -1
  00106	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00109	50		 push	 eax
  0010a	8b 4d e8	 mov	 ecx, DWORD PTR _movefactor$[ebp]
  0010d	51		 push	 ecx
  0010e	8b 55 ec	 mov	 edx, DWORD PTR _friction$[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 _Add_Friction
  00117	83 c4 10	 add	 esp, 16			; 00000010H
  0011a	eb cf		 jmp	 SHORT $LN5@P_SpawnFri
$LN6@P_SpawnFri:

; 6582 : 		}

  0011c	e9 f9 fe ff ff	 jmp	 $LN2@P_SpawnFri
$LN3@P_SpawnFri:

; 6583 : }

  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
_P_SpawnFriction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SpawnScrollers
_TEXT	SEGMENT
tv159 = -100						; size = 4
_s$1 = -32						; size = 4
_special$2 = -28					; size = 4
_accel$3 = -24						; size = 4
_control$4 = -20					; size = 4
_dy$5 = -16						; size = 4
_dx$6 = -12						; size = 4
_l$ = -8						; size = 4
_i$ = -4						; size = 4
_P_SpawnScrollers PROC					; COMDAT

; 6254 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6255 : 	size_t i;
; 6256 : 	line_t *l = lines;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  0000e	89 45 f8	 mov	 DWORD PTR _l$[ebp], eax

; 6257 : 
; 6258 : 	for (i = 0; i < numlines; i++, l++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00018	eb 12		 jmp	 SHORT $LN4@P_SpawnScr
$LN2@P_SpawnScr:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00026	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00029	89 4d f8	 mov	 DWORD PTR _l$[ebp], ecx
$LN4@P_SpawnScr:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00035	0f 83 03 05 00
	00		 jae	 $LN3@P_SpawnScr

; 6259 : 	{
; 6260 : 		fixed_t dx = l->dx >> SCROLL_SHIFT; // direction and speed of scrolling

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0003e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00041	c1 f9 05	 sar	 ecx, 5
  00044	89 4d f4	 mov	 DWORD PTR _dx$6[ebp], ecx

; 6261 : 		fixed_t dy = l->dy >> SCROLL_SHIFT;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0004a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004d	c1 f9 05	 sar	 ecx, 5
  00050	89 4d f0	 mov	 DWORD PTR _dy$5[ebp], ecx

; 6262 : 		INT32 control = -1, accel = 0; // no control sector or acceleration

  00053	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _control$4[ebp], -1
  0005a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _accel$3[ebp], 0

; 6263 : 		INT32 special = l->special;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  00064	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00068	89 4d e4	 mov	 DWORD PTR _special$2[ebp], ecx

; 6264 : 
; 6265 : 		// These types are same as the ones they get set to except that the
; 6266 : 		// first side's sector's heights cause scrolling when they change, and
; 6267 : 		// this linedef controls the direction and speed of the scrolling. The
; 6268 : 		// most complicated linedef since donuts, but powerful :)
; 6269 : 
; 6270 : 		if (special == 515 || special == 512 || special == 522 || special == 532 || special == 504) // displacement scrollers

  0006b	81 7d e4 03 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 515 ; 00000203H
  00072	74 24		 je	 SHORT $LN24@P_SpawnScr
  00074	81 7d e4 00 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 512 ; 00000200H
  0007b	74 1b		 je	 SHORT $LN24@P_SpawnScr
  0007d	81 7d e4 0a 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 522 ; 0000020aH
  00084	74 12		 je	 SHORT $LN24@P_SpawnScr
  00086	81 7d e4 14 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 532 ; 00000214H
  0008d	74 09		 je	 SHORT $LN24@P_SpawnScr
  0008f	81 7d e4 f8 01
	00 00		 cmp	 DWORD PTR _special$2[ebp], 504 ; 000001f8H
  00096	75 3c		 jne	 SHORT $LN22@P_SpawnScr
$LN24@P_SpawnScr:

; 6271 : 		{
; 6272 : 			special -= 2;

  00098	8b 45 e4	 mov	 eax, DWORD PTR _special$2[ebp]
  0009b	83 e8 02	 sub	 eax, 2
  0009e	89 45 e4	 mov	 DWORD PTR _special$2[ebp], eax

; 6273 : 			control = (INT32)(sides[*l->sidenum].sector - sectors);

  000a1	b8 02 00 00 00	 mov	 eax, 2
  000a6	6b c8 00	 imul	 ecx, eax, 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  000ac	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  000b1	6b c8 1c	 imul	 ecx, eax, 28
  000b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  000ba	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  000be	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  000c4	99		 cdq
  000c5	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  000ca	f7 f9		 idiv	 ecx
  000cc	89 45 ec	 mov	 DWORD PTR _control$4[ebp], eax

; 6274 : 		}

  000cf	e9 0b 01 00 00	 jmp	 $LN31@P_SpawnScr
$LN22@P_SpawnScr:

; 6275 : 		else if (special == 514 || special == 511 || special == 521 || special == 531 || special == 503) // accelerative scrollers

  000d4	81 7d e4 02 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 514 ; 00000202H
  000db	74 24		 je	 SHORT $LN27@P_SpawnScr
  000dd	81 7d e4 ff 01
	00 00		 cmp	 DWORD PTR _special$2[ebp], 511 ; 000001ffH
  000e4	74 1b		 je	 SHORT $LN27@P_SpawnScr
  000e6	81 7d e4 09 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 521 ; 00000209H
  000ed	74 12		 je	 SHORT $LN27@P_SpawnScr
  000ef	81 7d e4 13 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 531 ; 00000213H
  000f6	74 09		 je	 SHORT $LN27@P_SpawnScr
  000f8	81 7d e4 f7 01
	00 00		 cmp	 DWORD PTR _special$2[ebp], 503 ; 000001f7H
  000ff	75 43		 jne	 SHORT $LN25@P_SpawnScr
$LN27@P_SpawnScr:

; 6276 : 		{
; 6277 : 			special--;

  00101	8b 45 e4	 mov	 eax, DWORD PTR _special$2[ebp]
  00104	83 e8 01	 sub	 eax, 1
  00107	89 45 e4	 mov	 DWORD PTR _special$2[ebp], eax

; 6278 : 			accel = 1;

  0010a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _accel$3[ebp], 1

; 6279 : 			control = (INT32)(sides[*l->sidenum].sector - sectors);

  00111	b8 02 00 00 00	 mov	 eax, 2
  00116	6b c8 00	 imul	 ecx, eax, 0
  00119	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  0011c	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  00121	6b c8 1c	 imul	 ecx, eax, 28
  00124	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0012a	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0012e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00134	99		 cdq
  00135	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0013a	f7 f9		 idiv	 ecx
  0013c	89 45 ec	 mov	 DWORD PTR _control$4[ebp], eax

; 6280 : 		}

  0013f	e9 9b 00 00 00	 jmp	 $LN31@P_SpawnScr
$LN25@P_SpawnScr:

; 6281 : 		else if (special == 535 || special == 525) // displacement scrollers

  00144	81 7d e4 17 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 535 ; 00000217H
  0014b	74 09		 je	 SHORT $LN30@P_SpawnScr
  0014d	81 7d e4 0d 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 525 ; 0000020dH
  00154	75 39		 jne	 SHORT $LN28@P_SpawnScr
$LN30@P_SpawnScr:

; 6282 : 		{
; 6283 : 			special -= 2;

  00156	8b 45 e4	 mov	 eax, DWORD PTR _special$2[ebp]
  00159	83 e8 02	 sub	 eax, 2
  0015c	89 45 e4	 mov	 DWORD PTR _special$2[ebp], eax

; 6284 : 			control = (INT32)(sides[*l->sidenum].sector - sectors);

  0015f	b8 02 00 00 00	 mov	 eax, 2
  00164	6b c8 00	 imul	 ecx, eax, 0
  00167	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  0016a	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0016f	6b c8 1c	 imul	 ecx, eax, 28
  00172	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00178	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0017c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00182	99		 cdq
  00183	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00188	f7 f9		 idiv	 ecx
  0018a	89 45 ec	 mov	 DWORD PTR _control$4[ebp], eax

; 6285 : 		}

  0018d	eb 50		 jmp	 SHORT $LN31@P_SpawnScr
$LN28@P_SpawnScr:

; 6286 : 		else if (special == 534 || special == 524) // accelerative scrollers

  0018f	81 7d e4 16 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 534 ; 00000216H
  00196	74 09		 je	 SHORT $LN32@P_SpawnScr
  00198	81 7d e4 0c 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 524 ; 0000020cH
  0019f	75 3e		 jne	 SHORT $LN31@P_SpawnScr
$LN32@P_SpawnScr:

; 6287 : 		{
; 6288 : 			accel = 1;

  001a1	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _accel$3[ebp], 1

; 6289 : 			special--;

  001a8	8b 45 e4	 mov	 eax, DWORD PTR _special$2[ebp]
  001ab	83 e8 01	 sub	 eax, 1
  001ae	89 45 e4	 mov	 DWORD PTR _special$2[ebp], eax

; 6290 : 			control = (INT32)(sides[*l->sidenum].sector - sectors);

  001b1	b8 02 00 00 00	 mov	 eax, 2
  001b6	6b c8 00	 imul	 ecx, eax, 0
  001b9	8b 55 f8	 mov	 edx, DWORD PTR _l$[ebp]
  001bc	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  001c1	6b c8 1c	 imul	 ecx, eax, 28
  001c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  001ca	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  001ce	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  001d4	99		 cdq
  001d5	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  001da	f7 f9		 idiv	 ecx
  001dc	89 45 ec	 mov	 DWORD PTR _control$4[ebp], eax
$LN31@P_SpawnScr:

; 6291 : 		}
; 6292 : 
; 6293 : 		switch (special)

  001df	8b 45 e4	 mov	 eax, DWORD PTR _special$2[ebp]
  001e2	89 45 9c	 mov	 DWORD PTR tv159[ebp], eax
  001e5	8b 4d 9c	 mov	 ecx, DWORD PTR tv159[ebp]
  001e8	81 e9 f4 01 00
	00		 sub	 ecx, 500		; 000001f4H
  001ee	89 4d 9c	 mov	 DWORD PTR tv159[ebp], ecx
  001f1	83 7d 9c 21	 cmp	 DWORD PTR tv159[ebp], 33 ; 00000021H
  001f5	0f 87 3e 03 00
	00		 ja	 $LN5@P_SpawnScr
  001fb	8b 55 9c	 mov	 edx, DWORD PTR tv159[ebp]
  001fe	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN50@P_SpawnScr[edx]
  00205	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN51@P_SpawnScr[eax*4]
$LN33@P_SpawnScr:

; 6294 : 		{
; 6295 : 			register INT32 s;
; 6296 : 
; 6297 : 			case 513: // scroll effect ceiling
; 6298 : 			case 533: // scroll and carry objects on ceiling
; 6299 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  0020c	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _s$1[ebp], -1
$LN7@P_SpawnScr:
  00213	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  00216	50		 push	 eax
  00217	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00220	83 c4 08	 add	 esp, 8
  00223	89 45 e0	 mov	 DWORD PTR _s$1[ebp], eax
  00226	83 7d e0 00	 cmp	 DWORD PTR _s$1[ebp], 0
  0022a	7c 2d		 jl	 SHORT $LN8@P_SpawnScr

; 6300 : 					Add_Scroller(sc_ceiling, -dx, dy, control, s, accel, l->flags & ML_NOCLIMB);

  0022c	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  0022f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00233	83 e1 40	 and	 ecx, 64			; 00000040H
  00236	51		 push	 ecx
  00237	8b 55 e8	 mov	 edx, DWORD PTR _accel$3[ebp]
  0023a	52		 push	 edx
  0023b	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  0023e	50		 push	 eax
  0023f	8b 4d ec	 mov	 ecx, DWORD PTR _control$4[ebp]
  00242	51		 push	 ecx
  00243	8b 55 f0	 mov	 edx, DWORD PTR _dy$5[ebp]
  00246	52		 push	 edx
  00247	8b 45 f4	 mov	 eax, DWORD PTR _dx$6[ebp]
  0024a	f7 d8		 neg	 eax
  0024c	50		 push	 eax
  0024d	6a 02		 push	 2
  0024f	e8 00 00 00 00	 call	 _Add_Scroller
  00254	83 c4 1c	 add	 esp, 28			; 0000001cH
  00257	eb ba		 jmp	 SHORT $LN7@P_SpawnScr
$LN8@P_SpawnScr:

; 6301 : 				if (special != 533)

  00259	81 7d e4 15 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 533 ; 00000215H
  00260	74 05		 je	 SHORT $LN35@P_SpawnScr

; 6302 : 					break;

  00262	e9 d2 02 00 00	 jmp	 $LN5@P_SpawnScr
$LN35@P_SpawnScr:

; 6303 : 
; 6304 : 			case 523:	// carry objects on ceiling
; 6305 : 				dx = FixedMul(dx, CARRYFACTOR);

  00267	68 00 18 00 00	 push	 6144			; 00001800H
  0026c	8b 45 f4	 mov	 eax, DWORD PTR _dx$6[ebp]
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 _FixedMul
  00275	83 c4 08	 add	 esp, 8
  00278	89 45 f4	 mov	 DWORD PTR _dx$6[ebp], eax

; 6306 : 				dy = FixedMul(dy, CARRYFACTOR);

  0027b	68 00 18 00 00	 push	 6144			; 00001800H
  00280	8b 45 f0	 mov	 eax, DWORD PTR _dy$5[ebp]
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 _FixedMul
  00289	83 c4 08	 add	 esp, 8
  0028c	89 45 f0	 mov	 DWORD PTR _dy$5[ebp], eax

; 6307 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  0028f	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _s$1[ebp], -1
$LN10@P_SpawnScr:
  00296	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  00299	50		 push	 eax
  0029a	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  0029d	51		 push	 ecx
  0029e	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  002a3	83 c4 08	 add	 esp, 8
  002a6	89 45 e0	 mov	 DWORD PTR _s$1[ebp], eax
  002a9	83 7d e0 00	 cmp	 DWORD PTR _s$1[ebp], 0
  002ad	7c 2b		 jl	 SHORT $LN11@P_SpawnScr

; 6308 : 					Add_Scroller(sc_carry_ceiling, dx, dy, control, s, accel, l->flags & ML_NOCLIMB);

  002af	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  002b2	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  002b6	83 e1 40	 and	 ecx, 64			; 00000040H
  002b9	51		 push	 ecx
  002ba	8b 55 e8	 mov	 edx, DWORD PTR _accel$3[ebp]
  002bd	52		 push	 edx
  002be	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  002c1	50		 push	 eax
  002c2	8b 4d ec	 mov	 ecx, DWORD PTR _control$4[ebp]
  002c5	51		 push	 ecx
  002c6	8b 55 f0	 mov	 edx, DWORD PTR _dy$5[ebp]
  002c9	52		 push	 edx
  002ca	8b 45 f4	 mov	 eax, DWORD PTR _dx$6[ebp]
  002cd	50		 push	 eax
  002ce	6a 04		 push	 4
  002d0	e8 00 00 00 00	 call	 _Add_Scroller
  002d5	83 c4 1c	 add	 esp, 28			; 0000001cH
  002d8	eb bc		 jmp	 SHORT $LN10@P_SpawnScr
$LN11@P_SpawnScr:

; 6309 : 				break;

  002da	e9 5a 02 00 00	 jmp	 $LN5@P_SpawnScr
$LN37@P_SpawnScr:

; 6310 : 
; 6311 : 			case 510: // scroll effect floor
; 6312 : 			case 530: // scroll and carry objects on floor
; 6313 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  002df	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _s$1[ebp], -1
$LN13@P_SpawnScr:
  002e6	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  002e9	50		 push	 eax
  002ea	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  002f3	83 c4 08	 add	 esp, 8
  002f6	89 45 e0	 mov	 DWORD PTR _s$1[ebp], eax
  002f9	83 7d e0 00	 cmp	 DWORD PTR _s$1[ebp], 0
  002fd	7c 2d		 jl	 SHORT $LN14@P_SpawnScr

; 6314 : 					Add_Scroller(sc_floor, -dx, dy, control, s, accel, l->flags & ML_NOCLIMB);

  002ff	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  00302	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00306	83 e1 40	 and	 ecx, 64			; 00000040H
  00309	51		 push	 ecx
  0030a	8b 55 e8	 mov	 edx, DWORD PTR _accel$3[ebp]
  0030d	52		 push	 edx
  0030e	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  00311	50		 push	 eax
  00312	8b 4d ec	 mov	 ecx, DWORD PTR _control$4[ebp]
  00315	51		 push	 ecx
  00316	8b 55 f0	 mov	 edx, DWORD PTR _dy$5[ebp]
  00319	52		 push	 edx
  0031a	8b 45 f4	 mov	 eax, DWORD PTR _dx$6[ebp]
  0031d	f7 d8		 neg	 eax
  0031f	50		 push	 eax
  00320	6a 01		 push	 1
  00322	e8 00 00 00 00	 call	 _Add_Scroller
  00327	83 c4 1c	 add	 esp, 28			; 0000001cH
  0032a	eb ba		 jmp	 SHORT $LN13@P_SpawnScr
$LN14@P_SpawnScr:

; 6315 : 				if (special != 530)

  0032c	81 7d e4 12 02
	00 00		 cmp	 DWORD PTR _special$2[ebp], 530 ; 00000212H
  00333	74 05		 je	 SHORT $LN39@P_SpawnScr

; 6316 : 					break;

  00335	e9 ff 01 00 00	 jmp	 $LN5@P_SpawnScr
$LN39@P_SpawnScr:

; 6317 : 
; 6318 : 			case 520:	// carry objects on floor
; 6319 : 				dx = FixedMul(dx, CARRYFACTOR);

  0033a	68 00 18 00 00	 push	 6144			; 00001800H
  0033f	8b 45 f4	 mov	 eax, DWORD PTR _dx$6[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 _FixedMul
  00348	83 c4 08	 add	 esp, 8
  0034b	89 45 f4	 mov	 DWORD PTR _dx$6[ebp], eax

; 6320 : 				dy = FixedMul(dy, CARRYFACTOR);

  0034e	68 00 18 00 00	 push	 6144			; 00001800H
  00353	8b 45 f0	 mov	 eax, DWORD PTR _dy$5[ebp]
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 _FixedMul
  0035c	83 c4 08	 add	 esp, 8
  0035f	89 45 f0	 mov	 DWORD PTR _dy$5[ebp], eax

; 6321 : 				for (s = -1; (s = P_FindSectorFromLineTag(l, s)) >= 0 ;)

  00362	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _s$1[ebp], -1
$LN16@P_SpawnScr:
  00369	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  0036c	50		 push	 eax
  0036d	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  00370	51		 push	 ecx
  00371	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00376	83 c4 08	 add	 esp, 8
  00379	89 45 e0	 mov	 DWORD PTR _s$1[ebp], eax
  0037c	83 7d e0 00	 cmp	 DWORD PTR _s$1[ebp], 0
  00380	7c 2b		 jl	 SHORT $LN17@P_SpawnScr

; 6322 : 					Add_Scroller(sc_carry, dx, dy, control, s, accel, l->flags & ML_NOCLIMB);

  00382	8b 45 f8	 mov	 eax, DWORD PTR _l$[ebp]
  00385	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00389	83 e1 40	 and	 ecx, 64			; 00000040H
  0038c	51		 push	 ecx
  0038d	8b 55 e8	 mov	 edx, DWORD PTR _accel$3[ebp]
  00390	52		 push	 edx
  00391	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  00394	50		 push	 eax
  00395	8b 4d ec	 mov	 ecx, DWORD PTR _control$4[ebp]
  00398	51		 push	 ecx
  00399	8b 55 f0	 mov	 edx, DWORD PTR _dy$5[ebp]
  0039c	52		 push	 edx
  0039d	8b 45 f4	 mov	 eax, DWORD PTR _dx$6[ebp]
  003a0	50		 push	 eax
  003a1	6a 03		 push	 3
  003a3	e8 00 00 00 00	 call	 _Add_Scroller
  003a8	83 c4 1c	 add	 esp, 28			; 0000001cH
  003ab	eb bc		 jmp	 SHORT $LN16@P_SpawnScr
$LN17@P_SpawnScr:

; 6323 : 				break;

  003ad	e9 87 01 00 00	 jmp	 $LN5@P_SpawnScr
$LN41@P_SpawnScr:

; 6324 : 
; 6325 : 			// scroll wall according to linedef
; 6326 : 			// (same direction and speed as scrolling floors)
; 6327 : 			case 502:
; 6328 : 				for (s = -1; (s = P_FindLineFromLineTag(l, s)) >= 0 ;)

  003b2	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _s$1[ebp], -1
$LN19@P_SpawnScr:
  003b9	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  003bc	50		 push	 eax
  003bd	8b 4d f8	 mov	 ecx, DWORD PTR _l$[ebp]
  003c0	51		 push	 ecx
  003c1	e8 00 00 00 00	 call	 _P_FindLineFromLineTag
  003c6	83 c4 08	 add	 esp, 8
  003c9	89 45 e0	 mov	 DWORD PTR _s$1[ebp], eax
  003cc	83 7d e0 00	 cmp	 DWORD PTR _s$1[ebp], 0
  003d0	7c 2d		 jl	 SHORT $LN20@P_SpawnScr

; 6329 : 					if (s != (INT32)i)

  003d2	8b 45 e0	 mov	 eax, DWORD PTR _s$1[ebp]
  003d5	3b 45 fc	 cmp	 eax, DWORD PTR _i$[ebp]
  003d8	74 23		 je	 SHORT $LN42@P_SpawnScr

; 6330 : 						Add_WallScroller(dx, dy, lines+s, control, accel);

  003da	8b 45 e8	 mov	 eax, DWORD PTR _accel$3[ebp]
  003dd	50		 push	 eax
  003de	8b 4d ec	 mov	 ecx, DWORD PTR _control$4[ebp]
  003e1	51		 push	 ecx
  003e2	6b 55 e0 4c	 imul	 edx, DWORD PTR _s$1[ebp], 76
  003e6	03 15 00 00 00
	00		 add	 edx, DWORD PTR _lines
  003ec	52		 push	 edx
  003ed	8b 45 f0	 mov	 eax, DWORD PTR _dy$5[ebp]
  003f0	50		 push	 eax
  003f1	8b 4d f4	 mov	 ecx, DWORD PTR _dx$6[ebp]
  003f4	51		 push	 ecx
  003f5	e8 00 00 00 00	 call	 _Add_WallScroller
  003fa	83 c4 14	 add	 esp, 20			; 00000014H
$LN42@P_SpawnScr:
  003fd	eb ba		 jmp	 SHORT $LN19@P_SpawnScr
$LN20@P_SpawnScr:

; 6331 : 				break;

  003ff	e9 35 01 00 00	 jmp	 $LN5@P_SpawnScr
$LN43@P_SpawnScr:

; 6332 : 
; 6333 : 			case 505:
; 6334 : 				s = lines[i].sidenum[0];

  00404	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00408	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  0040e	b9 02 00 00 00	 mov	 ecx, 2
  00413	6b d1 00	 imul	 edx, ecx, 0
  00416	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  0041b	89 45 e0	 mov	 DWORD PTR _s$1[ebp], eax

; 6335 : 				Add_Scroller(sc_side, -sides[s].textureoffset, sides[s].rowoffset, -1, s, accel, 0);

  0041e	6a 00		 push	 0
  00420	8b 45 e8	 mov	 eax, DWORD PTR _accel$3[ebp]
  00423	50		 push	 eax
  00424	8b 4d e0	 mov	 ecx, DWORD PTR _s$1[ebp]
  00427	51		 push	 ecx
  00428	6a ff		 push	 -1
  0042a	6b 55 e0 1c	 imul	 edx, DWORD PTR _s$1[ebp], 28
  0042e	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  00433	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00437	51		 push	 ecx
  00438	6b 55 e0 1c	 imul	 edx, DWORD PTR _s$1[ebp], 28
  0043c	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  00441	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00444	f7 d9		 neg	 ecx
  00446	51		 push	 ecx
  00447	6a 00		 push	 0
  00449	e8 00 00 00 00	 call	 _Add_Scroller
  0044e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 6336 : 				break;

  00451	e9 e3 00 00 00	 jmp	 $LN5@P_SpawnScr
$LN44@P_SpawnScr:

; 6337 : 
; 6338 : 			case 506:
; 6339 : 				s = lines[i].sidenum[1];

  00456	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0045a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00460	b9 02 00 00 00	 mov	 ecx, 2
  00465	c1 e1 00	 shl	 ecx, 0
  00468	0f b7 54 08 16	 movzx	 edx, WORD PTR [eax+ecx+22]
  0046d	89 55 e0	 mov	 DWORD PTR _s$1[ebp], edx

; 6340 : 
; 6341 : 				if (s != 0xffff)

  00470	81 7d e0 ff ff
	00 00		 cmp	 DWORD PTR _s$1[ebp], 65535 ; 0000ffffH
  00477	74 49		 je	 SHORT $LN45@P_SpawnScr

; 6342 : 					Add_Scroller(sc_side, -sides[s].textureoffset, sides[s].rowoffset, -1, lines[i].sidenum[0], accel, 0);

  00479	6a 00		 push	 0
  0047b	8b 45 e8	 mov	 eax, DWORD PTR _accel$3[ebp]
  0047e	50		 push	 eax
  0047f	6b 4d fc 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00483	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00489	ba 02 00 00 00	 mov	 edx, 2
  0048e	6b c2 00	 imul	 eax, edx, 0
  00491	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  00496	51		 push	 ecx
  00497	6a ff		 push	 -1
  00499	6b 55 e0 1c	 imul	 edx, DWORD PTR _s$1[ebp], 28
  0049d	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  004a2	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  004a6	51		 push	 ecx
  004a7	6b 55 e0 1c	 imul	 edx, DWORD PTR _s$1[ebp], 28
  004ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _sides
  004b0	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  004b3	f7 d9		 neg	 ecx
  004b5	51		 push	 ecx
  004b6	6a 00		 push	 0
  004b8	e8 00 00 00 00	 call	 _Add_Scroller
  004bd	83 c4 1c	 add	 esp, 28			; 0000001cH
  004c0	eb 11		 jmp	 SHORT $LN46@P_SpawnScr
$LN45@P_SpawnScr:

; 6343 : 				else
; 6344 : 					CONS_Printf("Line special 506 (line #%"PRIdS") missing 2nd side!\n", i);

  004c2	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  004c5	50		 push	 eax
  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IAIAPEMG@Line?5special?5506?5?$CIline?5?$CD?$CFIu?$CJ?5mi@
  004cb	e8 00 00 00 00	 call	 _CONS_Printf
  004d0	83 c4 08	 add	 esp, 8
$LN46@P_SpawnScr:

; 6345 : 				break;

  004d3	eb 64		 jmp	 SHORT $LN5@P_SpawnScr
$LN47@P_SpawnScr:

; 6346 : 
; 6347 : 			case 500: // scroll first side
; 6348 : 				Add_Scroller(sc_side, FRACUNIT, 0, -1, lines[i].sidenum[0], accel, 0);

  004d5	6a 00		 push	 0
  004d7	8b 45 e8	 mov	 eax, DWORD PTR _accel$3[ebp]
  004da	50		 push	 eax
  004db	6b 4d fc 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  004df	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  004e5	ba 02 00 00 00	 mov	 edx, 2
  004ea	6b c2 00	 imul	 eax, edx, 0
  004ed	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  004f2	51		 push	 ecx
  004f3	6a ff		 push	 -1
  004f5	6a 00		 push	 0
  004f7	68 00 00 01 00	 push	 65536			; 00010000H
  004fc	6a 00		 push	 0
  004fe	e8 00 00 00 00	 call	 _Add_Scroller
  00503	83 c4 1c	 add	 esp, 28			; 0000001cH

; 6349 : 				break;

  00506	eb 31		 jmp	 SHORT $LN5@P_SpawnScr
$LN48@P_SpawnScr:

; 6350 : 
; 6351 : 			case 501: // jff 1/30/98 2-way scroll
; 6352 : 				Add_Scroller(sc_side, -FRACUNIT, 0, -1, lines[i].sidenum[0], accel, 0);

  00508	6a 00		 push	 0
  0050a	8b 45 e8	 mov	 eax, DWORD PTR _accel$3[ebp]
  0050d	50		 push	 eax
  0050e	6b 4d fc 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00512	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00518	ba 02 00 00 00	 mov	 edx, 2
  0051d	6b c2 00	 imul	 eax, edx, 0
  00520	0f b7 4c 01 16	 movzx	 ecx, WORD PTR [ecx+eax+22]
  00525	51		 push	 ecx
  00526	6a ff		 push	 -1
  00528	6a 00		 push	 0
  0052a	68 00 00 ff ff	 push	 -65536			; ffff0000H
  0052f	6a 00		 push	 0
  00531	e8 00 00 00 00	 call	 _Add_Scroller
  00536	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@P_SpawnScr:

; 6353 : 				break;
; 6354 : 		}
; 6355 : 	}

  00539	e9 dc fa ff ff	 jmp	 $LN2@P_SpawnScr
$LN3@P_SpawnScr:

; 6356 : }

  0053e	5f		 pop	 edi
  0053f	5e		 pop	 esi
  00540	5b		 pop	 ebx
  00541	8b e5		 mov	 esp, ebp
  00543	5d		 pop	 ebp
  00544	c3		 ret	 0
  00545	0f 1f 00	 npad	 3
$LN51@P_SpawnScr:
  00548	00 00 00 00	 DD	 $LN47@P_SpawnScr
  0054c	00 00 00 00	 DD	 $LN48@P_SpawnScr
  00550	00 00 00 00	 DD	 $LN41@P_SpawnScr
  00554	00 00 00 00	 DD	 $LN43@P_SpawnScr
  00558	00 00 00 00	 DD	 $LN44@P_SpawnScr
  0055c	00 00 00 00	 DD	 $LN37@P_SpawnScr
  00560	00 00 00 00	 DD	 $LN33@P_SpawnScr
  00564	00 00 00 00	 DD	 $LN39@P_SpawnScr
  00568	00 00 00 00	 DD	 $LN35@P_SpawnScr
  0056c	00 00 00 00	 DD	 $LN5@P_SpawnScr
$LN50@P_SpawnScr:
  00570	00		 DB	 0
  00571	01		 DB	 1
  00572	02		 DB	 2
  00573	09		 DB	 9
  00574	09		 DB	 9
  00575	03		 DB	 3
  00576	04		 DB	 4
  00577	09		 DB	 9
  00578	09		 DB	 9
  00579	09		 DB	 9
  0057a	05		 DB	 5
  0057b	09		 DB	 9
  0057c	09		 DB	 9
  0057d	06		 DB	 6
  0057e	09		 DB	 9
  0057f	09		 DB	 9
  00580	09		 DB	 9
  00581	09		 DB	 9
  00582	09		 DB	 9
  00583	09		 DB	 9
  00584	07		 DB	 7
  00585	09		 DB	 9
  00586	09		 DB	 9
  00587	08		 DB	 8
  00588	09		 DB	 9
  00589	09		 DB	 9
  0058a	09		 DB	 9
  0058b	09		 DB	 9
  0058c	09		 DB	 9
  0058d	09		 DB	 9
  0058e	05		 DB	 5
  0058f	09		 DB	 9
  00590	09		 DB	 9
  00591	06		 DB	 6
_P_SpawnScrollers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_ThingOnSpecial3DFloor
_TEXT	SEGMENT
_rover$ = -8						; size = 4
_sector$ = -4						; size = 4
_mo$ = 8						; size = 4
_P_ThingOnSpecial3DFloor PROC				; COMDAT

; 3832 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3833 : 	sector_t *sector;
; 3834 : 	ffloor_t *rover;
; 3835 : 
; 3836 : 	sector = mo->subsector->sector;

  00009	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0000c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 fc	 mov	 DWORD PTR _sector$[ebp], edx

; 3837 : 	if (!sector->ffloors)

  00014	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00017	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0001e	75 07		 jne	 SHORT $LN5@P_ThingOnS

; 3838 : 		return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	e9 b1 01 00 00	 jmp	 $LN1@P_ThingOnS
$LN5@P_ThingOnS:

; 3839 : 
; 3840 : 	for (rover = sector->ffloors; rover; rover = rover->next)

  00027	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  0002a	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00030	89 4d f8	 mov	 DWORD PTR _rover$[ebp], ecx
  00033	eb 09		 jmp	 SHORT $LN4@P_ThingOnS
$LN2@P_ThingOnS:
  00035	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00038	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0003b	89 4d f8	 mov	 DWORD PTR _rover$[ebp], ecx
$LN4@P_ThingOnS:
  0003e	83 7d f8 00	 cmp	 DWORD PTR _rover$[ebp], 0
  00042	0f 84 8e 01 00
	00		 je	 $LN3@P_ThingOnS

; 3841 : 	{
; 3842 : 		if (!rover->master->frontsector->special)

  00048	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0004b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0004e	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00051	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  00055	85 c0		 test	 eax, eax
  00057	75 02		 jne	 SHORT $LN6@P_ThingOnS

; 3843 : 			continue;

  00059	eb da		 jmp	 SHORT $LN2@P_ThingOnS
$LN6@P_ThingOnS:

; 3844 : 
; 3845 : 		if (!(rover->flags & FF_EXISTS))

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0005e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00061	83 e1 01	 and	 ecx, 1
  00064	75 02		 jne	 SHORT $LN7@P_ThingOnS

; 3846 : 			continue;

  00066	eb cd		 jmp	 SHORT $LN2@P_ThingOnS
$LN7@P_ThingOnS:

; 3847 : 
; 3848 : 		// Check the 3D floor's type...
; 3849 : 		if (((rover->flags & FF_BLOCKPLAYER) && mo->player)
; 3850 : 			|| ((rover->flags & FF_BLOCKOTHERS) && !mo->player))

  00068	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0006b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006e	83 e1 02	 and	 ecx, 2
  00071	74 0c		 je	 SHORT $LN11@P_ThingOnS
  00073	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00076	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0007d	75 1f		 jne	 SHORT $LN10@P_ThingOnS
$LN11@P_ThingOnS:
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00082	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00085	83 e1 04	 and	 ecx, 4
  00088	0f 84 0e 01 00
	00		 je	 $LN8@P_ThingOnS
  0008e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00091	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00098	0f 85 fe 00 00
	00		 jne	 $LN8@P_ThingOnS
$LN10@P_ThingOnS:

; 3851 : 		{
; 3852 : 			// Thing must be on top of the floor to be affected...
; 3853 : 			if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR)
; 3854 : 				&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING))

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000a1	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a4	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000a7	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000ad	83 e0 01	 and	 eax, 1
  000b0	74 3b		 je	 SHORT $LN12@P_ThingOnS
  000b2	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000b5	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b8	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000bb	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000c1	83 e0 02	 and	 eax, 2
  000c4	75 27		 jne	 SHORT $LN12@P_ThingOnS

; 3855 : 			{
; 3856 : 				if ((mo->eflags & MFE_VERTICALFLIP) || mo->z != *rover->topheight)

  000c6	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000c9	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000cf	83 e1 20	 and	 ecx, 32			; 00000020H
  000d2	75 0f		 jne	 SHORT $LN15@P_ThingOnS
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  000dc	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000df	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000e1	74 05		 je	 SHORT $LN14@P_ThingOnS
$LN15@P_ThingOnS:

; 3857 : 					continue;

  000e3	e9 4d ff ff ff	 jmp	 $LN2@P_ThingOnS
$LN14@P_ThingOnS:

; 3858 : 			}

  000e8	e9 ad 00 00 00	 jmp	 $LN21@P_ThingOnS
$LN12@P_ThingOnS:

; 3859 : 			else if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING)
; 3860 : 				&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR))

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000f0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000f3	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000f6	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000fc	83 e0 02	 and	 eax, 2
  000ff	74 3f		 je	 SHORT $LN16@P_ThingOnS
  00101	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00104	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00107	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0010a	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00110	83 e0 01	 and	 eax, 1
  00113	75 2b		 jne	 SHORT $LN16@P_ThingOnS

; 3861 : 			{
; 3862 : 				if (!(mo->eflags & MFE_VERTICALFLIP)
; 3863 : 					|| mo->z + mo->height != *rover->bottomheight)

  00115	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00118	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0011e	83 e1 20	 and	 ecx, 32			; 00000020H
  00121	74 16		 je	 SHORT $LN19@P_ThingOnS
  00123	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00126	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00129	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0012c	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0012f	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00132	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00135	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00137	74 05		 je	 SHORT $LN18@P_ThingOnS
$LN19@P_ThingOnS:

; 3864 : 					continue;

  00139	e9 f7 fe ff ff	 jmp	 $LN2@P_ThingOnS
$LN18@P_ThingOnS:

; 3865 : 			}

  0013e	eb 5a		 jmp	 SHORT $LN21@P_ThingOnS
$LN16@P_ThingOnS:

; 3866 : 			else if (rover->master->frontsector->flags & SF_FLIPSPECIAL_BOTH)

  00140	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00143	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00146	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00149	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  0014f	83 e0 03	 and	 eax, 3
  00152	74 46		 je	 SHORT $LN21@P_ThingOnS

; 3867 : 			{
; 3868 : 				if (!((mo->eflags & MFE_VERTICALFLIP && mo->z + mo->height == *rover->bottomheight)

  00154	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00157	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0015d	83 e1 20	 and	 ecx, 32			; 00000020H
  00160	74 16		 je	 SHORT $LN22@P_ThingOnS
  00162	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00165	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00168	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0016b	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0016e	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00171	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00174	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00176	74 22		 je	 SHORT $LN21@P_ThingOnS
$LN22@P_ThingOnS:
  00178	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0017b	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00181	83 e1 20	 and	 ecx, 32			; 00000020H
  00184	75 0f		 jne	 SHORT $LN23@P_ThingOnS
  00186	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0018e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00191	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00193	74 05		 je	 SHORT $LN21@P_ThingOnS
$LN23@P_ThingOnS:

; 3869 : 					|| (!(mo->eflags & MFE_VERTICALFLIP) && mo->z == *rover->topheight)))
; 3870 : 					continue;

  00195	e9 9b fe ff ff	 jmp	 $LN2@P_ThingOnS
$LN21@P_ThingOnS:

; 3871 : 			}
; 3872 : 		}

  0019a	eb 2a		 jmp	 SHORT $LN24@P_ThingOnS
$LN8@P_ThingOnS:

; 3873 : 		else
; 3874 : 		{
; 3875 : 			// Water and intangible FOFs
; 3876 : 			if (mo->z > *rover->topheight || (mo->z + mo->height) < *rover->bottomheight)

  0019c	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001a4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001a7	3b 01		 cmp	 eax, DWORD PTR [ecx]
  001a9	7f 16		 jg	 SHORT $LN25@P_ThingOnS
  001ab	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001ae	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001b1	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001b4	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  001b7	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  001ba	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  001bd	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  001bf	7d 05		 jge	 SHORT $LN24@P_ThingOnS
$LN25@P_ThingOnS:

; 3877 : 				continue;

  001c1	e9 6f fe ff ff	 jmp	 $LN2@P_ThingOnS
$LN24@P_ThingOnS:

; 3878 : 		}
; 3879 : 
; 3880 : 		return rover->master->frontsector;

  001c6	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  001c9	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001cc	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001cf	eb 07		 jmp	 SHORT $LN1@P_ThingOnS

; 3881 : 	}

  001d1	e9 5f fe ff ff	 jmp	 $LN2@P_ThingOnS
$LN3@P_ThingOnS:

; 3882 : 
; 3883 : 	return NULL;

  001d6	33 c0		 xor	 eax, eax
$LN1@P_ThingOnS:

; 3884 : }

  001d8	5f		 pop	 edi
  001d9	5e		 pop	 esi
  001da	5b		 pop	 ebx
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c3		 ret	 0
_P_ThingOnSpecial3DFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_GetPushThing
_TEXT	SEGMENT
tv69 = -76						; size = 4
_sec$ = -8						; size = 4
_thing$ = -4						; size = 4
_s$ = 8							; size = 4
_P_GetPushThing PROC					; COMDAT

; 7071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7072 : 	mobj_t *thing;
; 7073 : 	sector_t *sec;
; 7074 : 
; 7075 : 	sec = sectors + s;

  00009	69 45 08 f8 00
	00 00		 imul	 eax, DWORD PTR _s$[ebp], 248
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00016	89 45 f8	 mov	 DWORD PTR _sec$[ebp], eax

; 7076 : 	thing = sec->thinglist;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _sec$[ebp]
  0001c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001f	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
$LN2@P_GetPushT:

; 7077 : 	while (thing)

  00022	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00026	74 2d		 je	 SHORT $LN3@P_GetPushT

; 7078 : 	{
; 7079 : 		switch (thing->type)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0002b	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0002e	89 4d b4	 mov	 DWORD PTR tv69[ebp], ecx
  00031	81 7d b4 07 01
	00 00		 cmp	 DWORD PTR tv69[ebp], 263 ; 00000107H
  00038	74 0b		 je	 SHORT $LN6@P_GetPushT
  0003a	81 7d b4 08 01
	00 00		 cmp	 DWORD PTR tv69[ebp], 264 ; 00000108H
  00041	74 02		 je	 SHORT $LN6@P_GetPushT
  00043	eb 05		 jmp	 SHORT $LN8@P_GetPushT
$LN6@P_GetPushT:

; 7080 : 		{
; 7081 : 			case MT_PUSH:
; 7082 : 			case MT_PULL:
; 7083 : 				return thing;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00048	eb 0d		 jmp	 SHORT $LN1@P_GetPushT
$LN8@P_GetPushT:

; 7084 : 			default:
; 7085 : 				break;
; 7086 : 		}
; 7087 : 		thing = thing->snext;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0004d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00050	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx

; 7088 : 	}

  00053	eb cd		 jmp	 SHORT $LN2@P_GetPushT
$LN3@P_GetPushT:

; 7089 : 	return NULL;

  00055	33 c0		 xor	 eax, eax
$LN1@P_GetPushT:

; 7090 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_P_GetPushThing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _T_Pusher
_TEXT	SEGMENT
_jumped$1 = -80						; size = 4
_special$2 = -76					; size = 4
_referrer$3 = -72					; size = 4
_referrer$4 = -68					; size = 4
_moved$ = -64						; size = 4
_foundfloor$ = -60					; size = 4
_touching$ = -56					; size = 4
_inFOF$ = -52						; size = 4
_radius$ = -48						; size = 4
_by$ = -44						; size = 4
_bx$ = -40						; size = 4
_yh$ = -36						; size = 4
_yl$ = -32						; size = 4
_xh$ = -28						; size = 4
_xl$ = -24						; size = 4
_yspeed$ = -20						; size = 4
_xspeed$ = -16						; size = 4
_node$ = -12						; size = 4
_thing$ = -8						; size = 4
_sec$ = -4						; size = 4
_p$ = 8							; size = 4
_T_Pusher PROC						; COMDAT

; 6805 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 6806 : 	sector_t *sec;
; 6807 : 	mobj_t *thing;
; 6808 : 	msecnode_t *node;
; 6809 : 	INT32 xspeed = 0,yspeed = 0;

  0000c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _xspeed$[ebp], 0
  00013	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _yspeed$[ebp], 0

; 6810 : 	INT32 xl, xh, yl, yh, bx, by;
; 6811 : 	INT32 radius;
; 6812 : 	//INT32 ht = 0;
; 6813 : 	boolean inFOF;
; 6814 : 	boolean touching;
; 6815 : 	boolean foundfloor = false;

  0001a	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _foundfloor$[ebp], 0

; 6816 : 	boolean moved;
; 6817 : 
; 6818 : 	xspeed = yspeed = 0;

  00021	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _yspeed$[ebp], 0
  00028	8b 45 ec	 mov	 eax, DWORD PTR _yspeed$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR _xspeed$[ebp], eax

; 6819 : 
; 6820 : 	sec = sectors + p->affectee;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00031	69 48 34 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+52], 248
  00038	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0003e	89 4d fc	 mov	 DWORD PTR _sec$[ebp], ecx

; 6821 : 
; 6822 : 	// Be sure the special sector type is still turned on. If so, proceed.
; 6823 : 	// Else, bail out; the sector type has been changed on us.
; 6824 : 
; 6825 : 	if (p->roverpusher)

  00041	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00044	0f b6 48 38	 movzx	 ecx, BYTE PTR [eax+56]
  00048	85 c9		 test	 ecx, ecx
  0004a	74 40		 je	 SHORT $LN11@T_Pusher

; 6826 : 	{
; 6827 : 		sector_t *referrer = &sectors[p->referrer];

  0004c	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0004f	69 48 3c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+60], 248
  00056	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0005c	89 4d bc	 mov	 DWORD PTR _referrer$4[ebp], ecx

; 6828 : 
; 6829 : 		if (GETSECSPECIAL(referrer->special, 3) == 2
; 6830 : 			|| GETSECSPECIAL(referrer->special, 3) == 3)

  0005f	8b 45 bc	 mov	 eax, DWORD PTR _referrer$4[ebp]
  00062	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00066	c1 f9 08	 sar	 ecx, 8
  00069	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0006c	83 f9 02	 cmp	 ecx, 2
  0006f	74 12		 je	 SHORT $LN14@T_Pusher
  00071	8b 45 bc	 mov	 eax, DWORD PTR _referrer$4[ebp]
  00074	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00078	c1 f9 08	 sar	 ecx, 8
  0007b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0007e	83 f9 03	 cmp	 ecx, 3
  00081	75 07		 jne	 SHORT $LN13@T_Pusher
$LN14@T_Pusher:

; 6831 : 			foundfloor = true;

  00083	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _foundfloor$[ebp], 1
$LN13@T_Pusher:

; 6832 : 	}

  0008a	eb 29		 jmp	 SHORT $LN15@T_Pusher
$LN11@T_Pusher:

; 6833 : 	else if (!(GETSECSPECIAL(sec->special, 3) == 2

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  0008f	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00093	c1 f9 08	 sar	 ecx, 8
  00096	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00099	83 f9 02	 cmp	 ecx, 2
  0009c	74 17		 je	 SHORT $LN15@T_Pusher
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  000a1	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  000a5	c1 f9 08	 sar	 ecx, 8
  000a8	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000ab	83 f9 03	 cmp	 ecx, 3
  000ae	74 05		 je	 SHORT $LN15@T_Pusher

; 6834 : 			|| GETSECSPECIAL(sec->special, 3) == 3))
; 6835 : 		return;

  000b0	e9 2a 08 00 00	 jmp	 $LN9@T_Pusher
$LN15@T_Pusher:

; 6836 : 
; 6837 : 	if (p->roverpusher && foundfloor == false) // Not even a 3d floor has the PUSH_MASK.

  000b5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000b8	0f b6 48 38	 movzx	 ecx, BYTE PTR [eax+56]
  000bc	85 c9		 test	 ecx, ecx
  000be	74 0b		 je	 SHORT $LN16@T_Pusher
  000c0	83 7d c4 00	 cmp	 DWORD PTR _foundfloor$[ebp], 0
  000c4	75 05		 jne	 SHORT $LN16@T_Pusher

; 6838 : 		return;

  000c6	e9 14 08 00 00	 jmp	 $LN9@T_Pusher
$LN16@T_Pusher:

; 6839 : 
; 6840 : 	// For constant pushers (wind/current) there are 3 situations:
; 6841 : 	//
; 6842 : 	// 1) Affected Thing is above the floor.
; 6843 : 	//
; 6844 : 	//    Apply the full force if wind, no force if current.
; 6845 : 	//
; 6846 : 	// 2) Affected Thing is on the ground.
; 6847 : 	//
; 6848 : 	//    Apply half force if wind, full force if current.
; 6849 : 	//
; 6850 : 	// 3) Affected Thing is below the ground (underwater effect).
; 6851 : 	//
; 6852 : 	//    Apply no force if wind, full force if current.
; 6853 : 	//
; 6854 : 	// Apply the effect to clipped players only for now.
; 6855 : 	//
; 6856 : 	// In Phase II, you can apply these effects to Things other than players.
; 6857 : 
; 6858 : 	if (p->type == p_push)

  000cb	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ce	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000d2	0f 85 3b 01 00
	00		 jne	 $LN17@T_Pusher

; 6859 : 	{
; 6860 : 
; 6861 : 		// Seek out all pushable things within the force radius of this
; 6862 : 		// point pusher. Crosses sectors, so use blockmap.
; 6863 : 
; 6864 : 		tmpusher = p; // MT_PUSH/MT_PULL point source

  000d8	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000db	a3 00 00 00 00	 mov	 DWORD PTR _tmpusher, eax

; 6865 : 		radius = p->radius; // where force goes to zero

  000e0	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000e3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e6	89 4d d0	 mov	 DWORD PTR _radius$[ebp], ecx

; 6866 : 		tmbbox[BOXTOP]    = p->y + radius;

  000e9	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ec	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000ef	03 4d d0	 add	 ecx, DWORD PTR _radius$[ebp]
  000f2	ba 04 00 00 00	 mov	 edx, 4
  000f7	6b c2 00	 imul	 eax, edx, 0
  000fa	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 6867 : 		tmbbox[BOXBOTTOM] = p->y - radius;

  00100	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00103	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00106	2b 4d d0	 sub	 ecx, DWORD PTR _radius$[ebp]
  00109	ba 04 00 00 00	 mov	 edx, 4
  0010e	c1 e2 00	 shl	 edx, 0
  00111	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 6868 : 		tmbbox[BOXRIGHT]  = p->x + radius;

  00117	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0011a	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0011d	03 4d d0	 add	 ecx, DWORD PTR _radius$[ebp]
  00120	ba 04 00 00 00	 mov	 edx, 4
  00125	6b c2 03	 imul	 eax, edx, 3
  00128	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 6869 : 		tmbbox[BOXLEFT]   = p->x - radius;

  0012e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00131	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00134	2b 4d d0	 sub	 ecx, DWORD PTR _radius$[ebp]
  00137	ba 04 00 00 00	 mov	 edx, 4
  0013c	d1 e2		 shl	 edx, 1
  0013e	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 6870 : 
; 6871 : 		xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;

  00144	b8 04 00 00 00	 mov	 eax, 4
  00149	d1 e0		 shl	 eax, 1
  0014b	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  00151	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  00157	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  0015d	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00160	89 4d e8	 mov	 DWORD PTR _xl$[ebp], ecx

; 6872 : 		xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;

  00163	b8 04 00 00 00	 mov	 eax, 4
  00168	6b c8 03	 imul	 ecx, eax, 3
  0016b	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  00171	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  00177	81 c2 00 00 20
	00		 add	 edx, 2097152		; 00200000H
  0017d	c1 ea 17	 shr	 edx, 23			; 00000017H
  00180	89 55 e4	 mov	 DWORD PTR _xh$[ebp], edx

; 6873 : 		yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;

  00183	b8 04 00 00 00	 mov	 eax, 4
  00188	c1 e0 00	 shl	 eax, 0
  0018b	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  00191	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  00197	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  0019d	c1 e9 17	 shr	 ecx, 23			; 00000017H
  001a0	89 4d e0	 mov	 DWORD PTR _yl$[ebp], ecx

; 6874 : 		yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;

  001a3	b8 04 00 00 00	 mov	 eax, 4
  001a8	6b c8 00	 imul	 ecx, eax, 0
  001ab	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  001b1	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  001b7	81 c2 00 00 20
	00		 add	 edx, 2097152		; 00200000H
  001bd	c1 ea 17	 shr	 edx, 23			; 00000017H
  001c0	89 55 dc	 mov	 DWORD PTR _yh$[ebp], edx

; 6875 : 		for (bx = xl; bx <= xh; bx++)

  001c3	8b 45 e8	 mov	 eax, DWORD PTR _xl$[ebp]
  001c6	89 45 d8	 mov	 DWORD PTR _bx$[ebp], eax
  001c9	eb 09		 jmp	 SHORT $LN4@T_Pusher
$LN2@T_Pusher:
  001cb	8b 45 d8	 mov	 eax, DWORD PTR _bx$[ebp]
  001ce	83 c0 01	 add	 eax, 1
  001d1	89 45 d8	 mov	 DWORD PTR _bx$[ebp], eax
$LN4@T_Pusher:
  001d4	8b 45 d8	 mov	 eax, DWORD PTR _bx$[ebp]
  001d7	3b 45 e4	 cmp	 eax, DWORD PTR _xh$[ebp]
  001da	7f 32		 jg	 SHORT $LN3@T_Pusher

; 6876 : 			for (by = yl; by <= yh; by++)

  001dc	8b 45 e0	 mov	 eax, DWORD PTR _yl$[ebp]
  001df	89 45 d4	 mov	 DWORD PTR _by$[ebp], eax
  001e2	eb 09		 jmp	 SHORT $LN7@T_Pusher
$LN5@T_Pusher:
  001e4	8b 45 d4	 mov	 eax, DWORD PTR _by$[ebp]
  001e7	83 c0 01	 add	 eax, 1
  001ea	89 45 d4	 mov	 DWORD PTR _by$[ebp], eax
$LN7@T_Pusher:
  001ed	8b 45 d4	 mov	 eax, DWORD PTR _by$[ebp]
  001f0	3b 45 dc	 cmp	 eax, DWORD PTR _yh$[ebp]
  001f3	7f 17		 jg	 SHORT $LN6@T_Pusher

; 6877 : 				P_BlockThingsIterator(bx,by, PIT_PushThing);

  001f5	68 00 00 00 00	 push	 OFFSET _PIT_PushThing
  001fa	8b 45 d4	 mov	 eax, DWORD PTR _by$[ebp]
  001fd	50		 push	 eax
  001fe	8b 4d d8	 mov	 ecx, DWORD PTR _bx$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 _P_BlockThingsIterator
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020a	eb d8		 jmp	 SHORT $LN5@T_Pusher
$LN6@T_Pusher:
  0020c	eb bd		 jmp	 SHORT $LN2@T_Pusher
$LN3@T_Pusher:

; 6878 : 		return;

  0020e	e9 cc 06 00 00	 jmp	 $LN9@T_Pusher
$LN17@T_Pusher:

; 6879 : 	}
; 6880 : 
; 6881 : 	// constant pushers p_wind and p_current
; 6882 : 	node = sec->touching_thinglist; // things touching this sector

  00213	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00216	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0021c	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx

; 6883 : 	for (; node; node = node->m_snext)

  0021f	eb 09		 jmp	 SHORT $LN10@T_Pusher
$LN8@T_Pusher:
  00221	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00224	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00227	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx
$LN10@T_Pusher:
  0022a	83 7d f4 00	 cmp	 DWORD PTR _node$[ebp], 0
  0022e	0f 84 ab 06 00
	00		 je	 $LN9@T_Pusher

; 6884 : 	{
; 6885 : 		thing = node->m_thing;

  00234	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00237	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0023a	89 4d f8	 mov	 DWORD PTR _thing$[ebp], ecx

; 6886 : 		if (thing->flags & (MF_NOGRAVITY | MF_NOCLIP)
; 6887 : 			&& !(thing->type == MT_SMALLBUBBLE

  0023d	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00240	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00243	81 e1 00 12 00
	00		 and	 ecx, 4608		; 00001200H
  00249	74 26		 je	 SHORT $LN18@T_Pusher
  0024b	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0024e	81 78 7c b7 00
	00 00		 cmp	 DWORD PTR [eax+124], 183 ; 000000b7H
  00255	74 1a		 je	 SHORT $LN18@T_Pusher
  00257	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0025a	81 78 7c b8 00
	00 00		 cmp	 DWORD PTR [eax+124], 184 ; 000000b8H
  00261	74 0e		 je	 SHORT $LN18@T_Pusher
  00263	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00266	81 78 7c b9 00
	00 00		 cmp	 DWORD PTR [eax+124], 185 ; 000000b9H
  0026d	74 02		 je	 SHORT $LN18@T_Pusher

; 6888 : 											|| thing->type == MT_MEDIUMBUBBLE
; 6889 : 											|| thing->type == MT_EXTRALARGEBUBBLE))
; 6890 : 			continue;

  0026f	eb b0		 jmp	 SHORT $LN8@T_Pusher
$LN18@T_Pusher:

; 6891 : 
; 6892 : 		if (!(thing->flags & MF_PUSHABLE) && !(thing->type == MT_PLAYER

  00271	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00274	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00277	83 e1 40	 and	 ecx, 64			; 00000040H
  0027a	75 4a		 jne	 SHORT $LN19@T_Pusher
  0027c	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0027f	83 78 7c 00	 cmp	 DWORD PTR [eax+124], 0
  00283	74 41		 je	 SHORT $LN19@T_Pusher
  00285	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00288	81 78 7c b7 00
	00 00		 cmp	 DWORD PTR [eax+124], 183 ; 000000b7H
  0028f	74 35		 je	 SHORT $LN19@T_Pusher
  00291	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00294	81 78 7c b8 00
	00 00		 cmp	 DWORD PTR [eax+124], 184 ; 000000b8H
  0029b	74 29		 je	 SHORT $LN19@T_Pusher
  0029d	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002a0	81 78 7c b9 00
	00 00		 cmp	 DWORD PTR [eax+124], 185 ; 000000b9H
  002a7	74 1d		 je	 SHORT $LN19@T_Pusher
  002a9	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002ac	81 78 7c 90 00
	00 00		 cmp	 DWORD PTR [eax+124], 144 ; 00000090H
  002b3	74 11		 je	 SHORT $LN19@T_Pusher
  002b5	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002b8	81 78 7c 8f 00
	00 00		 cmp	 DWORD PTR [eax+124], 143 ; 0000008fH
  002bf	74 05		 je	 SHORT $LN19@T_Pusher

; 6893 : 											|| thing->type == MT_SMALLBUBBLE
; 6894 : 											|| thing->type == MT_MEDIUMBUBBLE
; 6895 : 											|| thing->type == MT_EXTRALARGEBUBBLE
; 6896 : 											|| thing->type == MT_LITTLETUMBLEWEED
; 6897 : 											|| thing->type == MT_BIGTUMBLEWEED))
; 6898 : 			continue;

  002c1	e9 5b ff ff ff	 jmp	 $LN8@T_Pusher
$LN19@T_Pusher:

; 6899 : 
; 6900 : 		if (thing->flags2 & MF2_PUSHED)

  002c6	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002c9	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  002cf	83 e1 01	 and	 ecx, 1
  002d2	74 05		 je	 SHORT $LN20@T_Pusher

; 6901 : 			continue;

  002d4	e9 48 ff ff ff	 jmp	 $LN8@T_Pusher
$LN20@T_Pusher:

; 6902 : 
; 6903 : 		if (thing->player && (thing->player->pflags & PF_ROPEHANG || thing->player->pflags & PF_MINECART))

  002d9	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002dc	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  002e3	74 33		 je	 SHORT $LN21@T_Pusher
  002e5	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002e8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002ee	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  002f4	81 e2 00 00 00
	20		 and	 edx, 536870912		; 20000000H
  002fa	75 17		 jne	 SHORT $LN22@T_Pusher
  002fc	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  002ff	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00305	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0030b	81 e2 00 00 00
	40		 and	 edx, 1073741824		; 40000000H
  00311	74 05		 je	 SHORT $LN21@T_Pusher
$LN22@T_Pusher:

; 6904 : 			continue;

  00313	e9 09 ff ff ff	 jmp	 $LN8@T_Pusher
$LN21@T_Pusher:

; 6905 : 
; 6906 : 		if (thing->player && (thing->state == &states[thing->info->painstate]) && (thing->player->powers[pw_flashing] > (flashingtics/4)*3 && thing->player->powers[pw_flashing] <= flashingtics))

  00318	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0031b	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00322	74 63		 je	 SHORT $LN23@T_Pusher
  00324	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00327	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0032d	6b 51 1c 1c	 imul	 edx, DWORD PTR [ecx+28], 28
  00331	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  00337	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0033a	39 50 5c	 cmp	 DWORD PTR [eax+92], edx
  0033d	75 48		 jne	 SHORT $LN23@T_Pusher
  0033f	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00342	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00348	be 04 00 00 00	 mov	 esi, 4
  0034d	d1 e6		 shl	 esi, 1
  0034f	a1 00 00 00 00	 mov	 eax, DWORD PTR _flashingtics
  00354	99		 cdq
  00355	83 e2 03	 and	 edx, 3
  00358	03 c2		 add	 eax, edx
  0035a	c1 f8 02	 sar	 eax, 2
  0035d	6b d0 03	 imul	 edx, eax, 3
  00360	39 54 31 38	 cmp	 DWORD PTR [ecx+esi+56], edx
  00364	7e 21		 jle	 SHORT $LN23@T_Pusher
  00366	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00369	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0036f	ba 04 00 00 00	 mov	 edx, 4
  00374	d1 e2		 shl	 edx, 1
  00376	8b 44 11 38	 mov	 eax, DWORD PTR [ecx+edx+56]
  0037a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _flashingtics
  00380	7f 05		 jg	 SHORT $LN23@T_Pusher

; 6907 : 			continue;

  00382	e9 9a fe ff ff	 jmp	 $LN8@T_Pusher
$LN23@T_Pusher:

; 6908 : 
; 6909 : 		inFOF = touching = moved = false;

  00387	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 0
  0038e	8b 45 c0	 mov	 eax, DWORD PTR _moved$[ebp]
  00391	89 45 c8	 mov	 DWORD PTR _touching$[ebp], eax
  00394	8b 4d c8	 mov	 ecx, DWORD PTR _touching$[ebp]
  00397	89 4d cc	 mov	 DWORD PTR _inFOF$[ebp], ecx

; 6910 : 
; 6911 : 		// Find the area that the 'thing' is in
; 6912 : 		if (p->roverpusher)

  0039a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0039d	0f b6 48 38	 movzx	 ecx, BYTE PTR [eax+56]
  003a1	85 c9		 test	 ecx, ecx
  003a3	0f 84 04 01 00
	00		 je	 $LN24@T_Pusher

; 6913 : 		{
; 6914 : 			sector_t *referrer = &sectors[p->referrer];

  003a9	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  003ac	69 48 3c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+60], 248
  003b3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  003b9	89 4d b8	 mov	 DWORD PTR _referrer$3[ebp], ecx

; 6915 : 			INT32 special;
; 6916 : 
; 6917 : 			special = GETSECSPECIAL(referrer->special, 3);

  003bc	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  003bf	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  003c3	c1 f9 08	 sar	 ecx, 8
  003c6	83 e1 0f	 and	 ecx, 15			; 0000000fH
  003c9	89 4d b4	 mov	 DWORD PTR _special$2[ebp], ecx

; 6918 : 
; 6919 : 			if (!(special == 2 || special == 3))

  003cc	83 7d b4 02	 cmp	 DWORD PTR _special$2[ebp], 2
  003d0	74 0b		 je	 SHORT $LN26@T_Pusher
  003d2	83 7d b4 03	 cmp	 DWORD PTR _special$2[ebp], 3
  003d6	74 05		 je	 SHORT $LN26@T_Pusher

; 6920 : 				return;

  003d8	e9 02 05 00 00	 jmp	 $LN9@T_Pusher
$LN26@T_Pusher:

; 6921 : 
; 6922 : 			if (thing->eflags & MFE_VERTICALFLIP)

  003dd	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  003e0	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  003e6	83 e1 20	 and	 ecx, 32			; 00000020H
  003e9	74 60		 je	 SHORT $LN27@T_Pusher

; 6923 : 			{
; 6924 : 				if (referrer->floorheight > thing->z + thing->height
; 6925 : 					|| referrer->ceilingheight < (thing->z + (thing->height >> 1)))

  003eb	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  003ee	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003f1	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  003f4	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  003f7	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  003fa	39 08		 cmp	 DWORD PTR [eax], ecx
  003fc	7f 16		 jg	 SHORT $LN30@T_Pusher
  003fe	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00401	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00404	d1 f9		 sar	 ecx, 1
  00406	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00409	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0040c	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  0040f	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00412	7d 05		 jge	 SHORT $LN29@T_Pusher
$LN30@T_Pusher:

; 6926 : 					return;

  00414	e9 c6 04 00 00	 jmp	 $LN9@T_Pusher
$LN29@T_Pusher:

; 6927 : 
; 6928 : 				if (thing->z < referrer->floorheight)

  00419	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0041c	8b 4d b8	 mov	 ecx, DWORD PTR _referrer$3[ebp]
  0041f	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00422	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00424	7d 07		 jge	 SHORT $LN31@T_Pusher

; 6929 : 					touching = true;

  00426	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _touching$[ebp], 1
$LN31@T_Pusher:

; 6930 : 
; 6931 : 				if (thing->z + (thing->height >> 1) > referrer->floorheight)

  0042d	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00430	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00433	d1 f9		 sar	 ecx, 1
  00435	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00438	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0043b	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  0043e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00440	7e 07		 jle	 SHORT $LN32@T_Pusher

; 6932 : 					inFOF = true;

  00442	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _inFOF$[ebp], 1
$LN32@T_Pusher:

; 6933 : 
; 6934 : 			}

  00449	eb 60		 jmp	 SHORT $LN36@T_Pusher
$LN27@T_Pusher:

; 6935 : 			else
; 6936 : 			{
; 6937 : 				if (referrer->ceilingheight < thing->z || referrer->floorheight > (thing->z + (thing->height >> 1)))

  0044b	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  0044e	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  00451	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00454	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  00457	7c 15		 jl	 SHORT $LN34@T_Pusher
  00459	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0045c	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0045f	d1 f9		 sar	 ecx, 1
  00461	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00464	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00467	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  0046a	39 08		 cmp	 DWORD PTR [eax], ecx
  0046c	7e 05		 jle	 SHORT $LN33@T_Pusher
$LN34@T_Pusher:

; 6938 : 					return;

  0046e	e9 6c 04 00 00	 jmp	 $LN9@T_Pusher
$LN33@T_Pusher:

; 6939 : 
; 6940 : 				if (thing->z + thing->height > referrer->ceilingheight)

  00473	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00476	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00479	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  0047c	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0047f	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  00482	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00485	7e 07		 jle	 SHORT $LN35@T_Pusher

; 6941 : 					touching = true;

  00487	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _touching$[ebp], 1
$LN35@T_Pusher:

; 6942 : 
; 6943 : 				if (thing->z + (thing->height >> 1) < referrer->ceilingheight)

  0048e	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00491	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00494	d1 f9		 sar	 ecx, 1
  00496	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00499	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0049c	8b 45 b8	 mov	 eax, DWORD PTR _referrer$3[ebp]
  0049f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  004a2	7d 07		 jge	 SHORT $LN36@T_Pusher

; 6944 : 					inFOF = true;

  004a4	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _inFOF$[ebp], 1
$LN36@T_Pusher:

; 6945 : 			}
; 6946 : 		}

  004ab	eb 2b		 jmp	 SHORT $LN39@T_Pusher
$LN24@T_Pusher:

; 6947 : 		else // Treat the entire sector as one big FOF
; 6948 : 		{
; 6949 : 			if (thing->z == thing->subsector->sector->floorheight)

  004ad	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  004b0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  004b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  004b5	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  004b8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004bb	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  004bd	75 09		 jne	 SHORT $LN37@T_Pusher

; 6950 : 				touching = true;

  004bf	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _touching$[ebp], 1
  004c6	eb 10		 jmp	 SHORT $LN39@T_Pusher
$LN37@T_Pusher:

; 6951 : 			else if (p->type != p_current)

  004c8	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  004cb	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  004cf	74 07		 je	 SHORT $LN39@T_Pusher

; 6952 : 				inFOF = true;

  004d1	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _inFOF$[ebp], 1
$LN39@T_Pusher:

; 6953 : 		}
; 6954 : 
; 6955 : 		if (!touching && !inFOF) // Object is out of range of effect

  004d8	83 7d c8 00	 cmp	 DWORD PTR _touching$[ebp], 0
  004dc	75 0b		 jne	 SHORT $LN40@T_Pusher
  004de	83 7d cc 00	 cmp	 DWORD PTR _inFOF$[ebp], 0
  004e2	75 05		 jne	 SHORT $LN40@T_Pusher

; 6956 : 			continue;

  004e4	e9 38 fd ff ff	 jmp	 $LN8@T_Pusher
$LN40@T_Pusher:

; 6957 : 
; 6958 : 		if (p->type == p_wind)

  004e9	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  004ec	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  004f0	75 49		 jne	 SHORT $LN41@T_Pusher

; 6959 : 		{
; 6960 : 			if (touching) // on ground

  004f2	83 7d c8 00	 cmp	 DWORD PTR _touching$[ebp], 0
  004f6	74 1f		 je	 SHORT $LN43@T_Pusher

; 6961 : 			{
; 6962 : 				xspeed = (p->x_mag)>>1; // half force

  004f8	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  004fb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004fe	d1 f9		 sar	 ecx, 1
  00500	89 4d f0	 mov	 DWORD PTR _xspeed$[ebp], ecx

; 6963 : 				yspeed = (p->y_mag)>>1;

  00503	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00506	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00509	d1 f9		 sar	 ecx, 1
  0050b	89 4d ec	 mov	 DWORD PTR _yspeed$[ebp], ecx

; 6964 : 				moved = true;

  0050e	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1

; 6965 : 			}

  00515	eb 1f		 jmp	 SHORT $LN45@T_Pusher
$LN43@T_Pusher:

; 6966 : 			else if (inFOF)

  00517	83 7d cc 00	 cmp	 DWORD PTR _inFOF$[ebp], 0
  0051b	74 19		 je	 SHORT $LN45@T_Pusher

; 6967 : 			{
; 6968 : 				xspeed = (p->x_mag); // full force

  0051d	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00520	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00523	89 4d f0	 mov	 DWORD PTR _xspeed$[ebp], ecx

; 6969 : 				yspeed = (p->y_mag);

  00526	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00529	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0052c	89 4d ec	 mov	 DWORD PTR _yspeed$[ebp], ecx

; 6970 : 				moved = true;

  0052f	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1
$LN45@T_Pusher:

; 6971 : 			}
; 6972 : 		}

  00536	e9 0d 01 00 00	 jmp	 $LN57@T_Pusher
$LN41@T_Pusher:

; 6973 : 		else if (p->type == p_upwind)

  0053b	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0053e	83 78 10 05	 cmp	 DWORD PTR [eax+16], 5
  00542	75 47		 jne	 SHORT $LN46@T_Pusher

; 6974 : 		{
; 6975 : 			if (touching) // on ground

  00544	83 7d c8 00	 cmp	 DWORD PTR _touching$[ebp], 0
  00548	74 1d		 je	 SHORT $LN48@T_Pusher

; 6976 : 			{
; 6977 : 				thing->momz += (p->magnitude)>>1;

  0054a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0054d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00550	d1 f9		 sar	 ecx, 1
  00552	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00555	03 4a 50	 add	 ecx, DWORD PTR [edx+80]
  00558	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0055b	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 6978 : 				moved = true;

  0055e	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1

; 6979 : 			}

  00565	eb 1f		 jmp	 SHORT $LN50@T_Pusher
$LN48@T_Pusher:

; 6980 : 			else if (inFOF)

  00567	83 7d cc 00	 cmp	 DWORD PTR _inFOF$[ebp], 0
  0056b	74 19		 je	 SHORT $LN50@T_Pusher

; 6981 : 			{
; 6982 : 				thing->momz += p->magnitude;

  0056d	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00570	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00573	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00576	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  00579	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0057c	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 6983 : 				moved = true;

  0057f	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1
$LN50@T_Pusher:

; 6984 : 			}
; 6985 : 		}

  00586	e9 bd 00 00 00	 jmp	 $LN57@T_Pusher
$LN46@T_Pusher:

; 6986 : 		else if (p->type == p_downwind)

  0058b	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0058e	83 78 10 06	 cmp	 DWORD PTR [eax+16], 6
  00592	75 46		 jne	 SHORT $LN51@T_Pusher

; 6987 : 		{
; 6988 : 			if (touching) // on ground

  00594	83 7d c8 00	 cmp	 DWORD PTR _touching$[ebp], 0
  00598	74 1f		 je	 SHORT $LN53@T_Pusher

; 6989 : 			{
; 6990 : 				thing->momz -= (p->magnitude)>>1;

  0059a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0059d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  005a0	d1 f9		 sar	 ecx, 1
  005a2	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  005a5	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  005a8	2b c1		 sub	 eax, ecx
  005aa	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  005ad	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 6991 : 				moved = true;

  005b0	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1

; 6992 : 			}

  005b7	eb 1f		 jmp	 SHORT $LN55@T_Pusher
$LN53@T_Pusher:

; 6993 : 			else if (inFOF)

  005b9	83 7d cc 00	 cmp	 DWORD PTR _inFOF$[ebp], 0
  005bd	74 19		 je	 SHORT $LN55@T_Pusher

; 6994 : 			{
; 6995 : 				thing->momz -= p->magnitude;

  005bf	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  005c2	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  005c5	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  005c8	2b 51 20	 sub	 edx, DWORD PTR [ecx+32]
  005cb	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  005ce	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 6996 : 				moved = true;

  005d1	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1
$LN55@T_Pusher:

; 6997 : 			}
; 6998 : 		}

  005d8	eb 6e		 jmp	 SHORT $LN57@T_Pusher
$LN51@T_Pusher:

; 6999 : 		else // p_current
; 7000 : 		{
; 7001 : 			if (!touching && !inFOF) // Not in water at all

  005da	83 7d c8 00	 cmp	 DWORD PTR _touching$[ebp], 0
  005de	75 15		 jne	 SHORT $LN56@T_Pusher
  005e0	83 7d cc 00	 cmp	 DWORD PTR _inFOF$[ebp], 0
  005e4	75 0f		 jne	 SHORT $LN56@T_Pusher

; 7002 : 				xspeed = yspeed = 0; // no force

  005e6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _yspeed$[ebp], 0
  005ed	8b 45 ec	 mov	 eax, DWORD PTR _yspeed$[ebp]
  005f0	89 45 f0	 mov	 DWORD PTR _xspeed$[ebp], eax
  005f3	eb 53		 jmp	 SHORT $LN57@T_Pusher
$LN56@T_Pusher:

; 7003 : 			else // underwater / touching water
; 7004 : 			{
; 7005 : 				if (p->type == p_upcurrent)

  005f5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  005f8	83 78 10 03	 cmp	 DWORD PTR [eax+16], 3
  005fc	75 14		 jne	 SHORT $LN58@T_Pusher

; 7006 : 					thing->momz += p->magnitude;

  005fe	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00601	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00604	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00607	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  0060a	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0060d	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00610	eb 2f		 jmp	 SHORT $LN61@T_Pusher
$LN58@T_Pusher:

; 7007 : 				else if (p->type == p_downcurrent)

  00612	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00615	83 78 10 04	 cmp	 DWORD PTR [eax+16], 4
  00619	75 14		 jne	 SHORT $LN60@T_Pusher

; 7008 : 					thing->momz -= p->magnitude;

  0061b	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0061e	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00621	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00624	2b 51 20	 sub	 edx, DWORD PTR [ecx+32]
  00627	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0062a	89 50 50	 mov	 DWORD PTR [eax+80], edx
  0062d	eb 12		 jmp	 SHORT $LN61@T_Pusher
$LN60@T_Pusher:

; 7009 : 				else
; 7010 : 				{
; 7011 : 					xspeed = p->x_mag; // full force

  0062f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00632	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00635	89 4d f0	 mov	 DWORD PTR _xspeed$[ebp], ecx

; 7012 : 					yspeed = p->y_mag;

  00638	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0063b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0063e	89 4d ec	 mov	 DWORD PTR _yspeed$[ebp], ecx
$LN61@T_Pusher:

; 7013 : 				}
; 7014 : 				moved = true;

  00641	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _moved$[ebp], 1
$LN57@T_Pusher:

; 7015 : 			}
; 7016 : 		}
; 7017 : 
; 7018 : 		if (p->type != p_downcurrent && p->type != p_upcurrent
; 7019 : 			&& p->type != p_upwind && p->type != p_downwind)

  00648	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0064b	83 78 10 04	 cmp	 DWORD PTR [eax+16], 4
  0064f	0f 84 38 01 00
	00		 je	 $LN64@T_Pusher
  00655	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00658	83 78 10 03	 cmp	 DWORD PTR [eax+16], 3
  0065c	0f 84 2b 01 00
	00		 je	 $LN64@T_Pusher
  00662	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00665	83 78 10 05	 cmp	 DWORD PTR [eax+16], 5
  00669	0f 84 1e 01 00
	00		 je	 $LN64@T_Pusher
  0066f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00672	83 78 10 06	 cmp	 DWORD PTR [eax+16], 6
  00676	0f 84 11 01 00
	00		 je	 $LN64@T_Pusher

; 7020 : 		{
; 7021 : 			thing->momx += xspeed<<(FRACBITS-PUSH_FACTOR);

  0067c	8b 45 f0	 mov	 eax, DWORD PTR _xspeed$[ebp]
  0067f	c1 e0 09	 shl	 eax, 9
  00682	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  00685	03 41 48	 add	 eax, DWORD PTR [ecx+72]
  00688	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  0068b	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 7022 : 			thing->momy += yspeed<<(FRACBITS-PUSH_FACTOR);

  0068e	8b 45 ec	 mov	 eax, DWORD PTR _yspeed$[ebp]
  00691	c1 e0 09	 shl	 eax, 9
  00694	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  00697	03 41 4c	 add	 eax, DWORD PTR [ecx+76]
  0069a	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  0069d	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 7023 : 			if (thing->player)

  006a0	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  006a3	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  006aa	0f 84 a0 00 00
	00		 je	 $LN63@T_Pusher

; 7024 : 			{
; 7025 : 				thing->player->cmomx += xspeed<<(FRACBITS-PUSH_FACTOR);

  006b0	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  006b3	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  006b9	8b 55 f0	 mov	 edx, DWORD PTR _xspeed$[ebp]
  006bc	c1 e2 09	 shl	 edx, 9
  006bf	03 91 3c 01 00
	00		 add	 edx, DWORD PTR [ecx+316]
  006c5	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  006c8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  006ce	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 7026 : 				thing->player->cmomy += yspeed<<(FRACBITS-PUSH_FACTOR);

  006d4	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  006d7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  006dd	8b 55 ec	 mov	 edx, DWORD PTR _yspeed$[ebp]
  006e0	c1 e2 09	 shl	 edx, 9
  006e3	03 91 40 01 00
	00		 add	 edx, DWORD PTR [ecx+320]
  006e9	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  006ec	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  006f2	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 7027 : 				thing->player->cmomx = FixedMul(thing->player->cmomx, ORIG_FRICTION);

  006f8	68 00 e8 00 00	 push	 59392			; 0000e800H
  006fd	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00700	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00706	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  0070c	52		 push	 edx
  0070d	e8 00 00 00 00	 call	 _FixedMul
  00712	83 c4 08	 add	 esp, 8
  00715	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  00718	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0071e	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 7028 : 				thing->player->cmomy = FixedMul(thing->player->cmomy, ORIG_FRICTION);

  00724	68 00 e8 00 00	 push	 59392			; 0000e800H
  00729	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0072c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00732	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00738	52		 push	 edx
  00739	e8 00 00 00 00	 call	 _FixedMul
  0073e	83 c4 08	 add	 esp, 8
  00741	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  00744	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0074a	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN63@T_Pusher:

; 7029 : 			}
; 7030 : 
; 7031 : 			// Tumbleweeds bounce a bit...
; 7032 : 			if (thing->type == MT_LITTLETUMBLEWEED || thing->type == MT_BIGTUMBLEWEED)

  00750	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00753	81 78 7c 90 00
	00 00		 cmp	 DWORD PTR [eax+124], 144 ; 00000090H
  0075a	74 0c		 je	 SHORT $LN65@T_Pusher
  0075c	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0075f	81 78 7c 8f 00
	00 00		 cmp	 DWORD PTR [eax+124], 143 ; 0000008fH
  00766	75 25		 jne	 SHORT $LN64@T_Pusher
$LN65@T_Pusher:

; 7033 : 				thing->momz += P_AproxDistance(xspeed<<(FRACBITS-PUSH_FACTOR), yspeed<<(FRACBITS-PUSH_FACTOR)) >> 2;

  00768	8b 45 ec	 mov	 eax, DWORD PTR _yspeed$[ebp]
  0076b	c1 e0 09	 shl	 eax, 9
  0076e	50		 push	 eax
  0076f	8b 4d f0	 mov	 ecx, DWORD PTR _xspeed$[ebp]
  00772	c1 e1 09	 shl	 ecx, 9
  00775	51		 push	 ecx
  00776	e8 00 00 00 00	 call	 _P_AproxDistance
  0077b	83 c4 08	 add	 esp, 8
  0077e	c1 f8 02	 sar	 eax, 2
  00781	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00784	03 42 50	 add	 eax, DWORD PTR [edx+80]
  00787	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  0078a	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN64@T_Pusher:

; 7034 : 		}
; 7035 : 
; 7036 : 		if (moved)

  0078d	83 7d c0 00	 cmp	 DWORD PTR _moved$[ebp], 0
  00791	0f 84 43 01 00
	00		 je	 $LN72@T_Pusher

; 7037 : 		{
; 7038 : 			if (p->slider && thing->player)

  00797	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0079a	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0079e	0f 84 18 01 00
	00		 je	 $LN71@T_Pusher
  007a4	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  007a7	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  007ae	0f 84 08 01 00
	00		 je	 $LN71@T_Pusher

; 7039 : 			{
; 7040 : 				boolean jumped = (thing->player->pflags & PF_JUMPED);

  007b4	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  007b7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  007bd	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  007c3	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  007c9	89 55 b0	 mov	 DWORD PTR _jumped$1[ebp], edx

; 7041 : 				P_ResetPlayer (thing->player);

  007cc	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  007cf	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  007d5	51		 push	 ecx
  007d6	e8 00 00 00 00	 call	 _P_ResetPlayer
  007db	83 c4 04	 add	 esp, 4

; 7042 : 
; 7043 : 				if (jumped)

  007de	83 7d b0 00	 cmp	 DWORD PTR _jumped$1[ebp], 0
  007e2	74 24		 je	 SHORT $LN68@T_Pusher

; 7044 : 					thing->player->pflags |= PF_JUMPED;

  007e4	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  007e7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  007ed	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  007f3	81 ca 00 10 00
	00		 or	 edx, 4096		; 00001000H
  007f9	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  007fc	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00802	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx
$LN68@T_Pusher:

; 7045 : 
; 7046 : 				thing->player->pflags |= PF_SLIDING;

  00808	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0080b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00811	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00817	81 ca 00 00 04
	00		 or	 edx, 262144		; 00040000H
  0081d	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00820	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00826	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 7047 : 				P_SetPlayerMobjState (thing, thing->info->painstate); // Whee!

  0082c	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0082f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00835	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00838	52		 push	 edx
  00839	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0083c	50		 push	 eax
  0083d	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  00842	83 c4 08	 add	 esp, 8

; 7048 : 				thing->angle = R_PointToAngle2 (0, 0, xspeed<<(FRACBITS-PUSH_FACTOR), yspeed<<(FRACBITS-PUSH_FACTOR));

  00845	8b 45 ec	 mov	 eax, DWORD PTR _yspeed$[ebp]
  00848	c1 e0 09	 shl	 eax, 9
  0084b	50		 push	 eax
  0084c	8b 4d f0	 mov	 ecx, DWORD PTR _xspeed$[ebp]
  0084f	c1 e1 09	 shl	 ecx, 9
  00852	51		 push	 ecx
  00853	6a 00		 push	 0
  00855	6a 00		 push	 0
  00857	e8 00 00 00 00	 call	 _R_PointToAngle2
  0085c	83 c4 10	 add	 esp, 16			; 00000010H
  0085f	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  00862	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 7049 : 
; 7050 : 				if (thing->player == &players[consoleplayer])

  00865	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  0086f	05 00 00 00 00	 add	 eax, OFFSET _players
  00874	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  00877	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  0087d	75 0e		 jne	 SHORT $LN69@T_Pusher

; 7051 : 					localangle = thing->angle;

  0087f	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00882	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00885	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle, ecx
  0088b	eb 2f		 jmp	 SHORT $LN71@T_Pusher
$LN69@T_Pusher:

; 7052 : 				else if (splitscreen && thing->player == &players[secondarydisplayplayer])

  0088d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00894	74 26		 je	 SHORT $LN71@T_Pusher
  00896	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  008a0	05 00 00 00 00	 add	 eax, OFFSET _players
  008a5	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  008a8	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  008ae	75 0c		 jne	 SHORT $LN71@T_Pusher

; 7053 : 					localangle2 = thing->angle;

  008b0	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  008b3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  008b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle2, ecx
$LN71@T_Pusher:

; 7054 : 			}
; 7055 : 
; 7056 : 			if (p->exclusive)

  008bc	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  008bf	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  008c3	74 15		 je	 SHORT $LN72@T_Pusher

; 7057 : 				thing->flags2 |= MF2_PUSHED;

  008c5	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  008c8	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  008ce	83 c9 01	 or	 ecx, 1
  008d1	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  008d4	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN72@T_Pusher:

; 7058 : 		}
; 7059 : 	}

  008da	e9 42 f9 ff ff	 jmp	 $LN8@T_Pusher
$LN9@T_Pusher:

; 7060 : }

  008df	5f		 pop	 edi
  008e0	5e		 pop	 esi
  008e1	5b		 pop	 ebx
  008e2	8b e5		 mov	 esp, ebp
  008e4	5d		 pop	 ebp
  008e5	c3		 ret	 0
_T_Pusher ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _T_Disappear
_TEXT	SEGMENT
tv72 = -76						; size = 4
_s$1 = -8						; size = 4
_rover$2 = -4						; size = 4
_d$ = 8							; size = 4
_T_Disappear PROC					; COMDAT

; 6386 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6387 : 	if (d->offset)

  00009	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0000c	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00010	74 14		 je	 SHORT $LN8@T_Disappea

; 6388 : 	{
; 6389 : 		d->offset--;

  00012	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00015	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00018	83 e9 01	 sub	 ecx, 1
  0001b	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  0001e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 6390 : 		return;

  00021	e9 5c 01 00 00	 jmp	 $LN15@T_Disappea
$LN8@T_Disappea:

; 6391 : 	}
; 6392 : 
; 6393 : 	if (--d->timer <= 0)

  00026	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00029	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0002c	83 e9 01	 sub	 ecx, 1
  0002f	89 4d b4	 mov	 DWORD PTR tv72[ebp], ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _d$[ebp]
  00035	8b 45 b4	 mov	 eax, DWORD PTR tv72[ebp]
  00038	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  0003b	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  0003f	0f 87 3d 01 00
	00		 ja	 $LN15@T_Disappea

; 6394 : 	{
; 6395 : 		ffloor_t *rover;
; 6396 : 		register INT32 s;
; 6397 : 
; 6398 : 		for (s = -1; (s = P_FindSectorFromLineTag(&lines[d->affectee], s)) >= 0 ;)

  00045	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _s$1[ebp], -1
$LN2@T_Disappea:
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _s$1[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00053	6b 51 20 4c	 imul	 edx, DWORD PTR [ecx+32], 76
  00057	03 15 00 00 00
	00		 add	 edx, DWORD PTR _lines
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00063	83 c4 08	 add	 esp, 8
  00066	89 45 f8	 mov	 DWORD PTR _s$1[ebp], eax
  00069	83 7d f8 00	 cmp	 DWORD PTR _s$1[ebp], 0
  0006d	0f 8c d8 00 00
	00		 jl	 $LN3@T_Disappea

; 6399 : 		{
; 6400 : 			for (rover = sectors[s].ffloors; rover; rover = rover->next)

  00073	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _s$1[ebp], 248
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00080	8b 94 01 90 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+144]
  00087	89 55 fc	 mov	 DWORD PTR _rover$2[ebp], edx
  0008a	eb 09		 jmp	 SHORT $LN7@T_Disappea
$LN5@T_Disappea:
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _rover$2[ebp]
  0008f	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00092	89 4d fc	 mov	 DWORD PTR _rover$2[ebp], ecx
$LN7@T_Disappea:
  00095	83 7d fc 00	 cmp	 DWORD PTR _rover$2[ebp], 0
  00099	0f 84 8f 00 00
	00		 je	 $LN6@T_Disappea

; 6401 : 			{
; 6402 : 				if (rover->master != &lines[d->affectee])

  0009f	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  000a2	6b 48 20 4c	 imul	 ecx, DWORD PTR [eax+32], 76
  000a6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _rover$2[ebp]
  000af	39 4a 38	 cmp	 DWORD PTR [edx+56], ecx
  000b2	74 02		 je	 SHORT $LN10@T_Disappea

; 6403 : 					continue;

  000b4	eb d6		 jmp	 SHORT $LN5@T_Disappea
$LN10@T_Disappea:

; 6404 : 
; 6405 : 				if (d->exists)

  000b6	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  000b9	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  000bd	74 11		 je	 SHORT $LN11@T_Disappea

; 6406 : 					rover->flags &= ~FF_EXISTS;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _rover$2[ebp]
  000c2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000c5	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000c8	8b 55 fc	 mov	 edx, DWORD PTR _rover$2[ebp]
  000cb	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
  000ce	eb 59		 jmp	 SHORT $LN13@T_Disappea
$LN11@T_Disappea:

; 6407 : 				else
; 6408 : 				{
; 6409 : 					rover->flags |= FF_EXISTS;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _rover$2[ebp]
  000d3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d6	83 c9 01	 or	 ecx, 1
  000d9	8b 55 fc	 mov	 edx, DWORD PTR _rover$2[ebp]
  000dc	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 6410 : 
; 6411 : 					if (!(lines[d->sourceline].flags & ML_NOCLIMB))

  000df	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  000e2	6b 48 24 4c	 imul	 ecx, DWORD PTR [eax+36], 76
  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  000ec	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  000f1	83 e0 40	 and	 eax, 64			; 00000040H
  000f4	75 33		 jne	 SHORT $LN13@T_Disappea

; 6412 : 					{
; 6413 : 						sectors[s].soundorg.z = *rover->topheight;

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _rover$2[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	69 55 f8 f8 00
	00 00		 imul	 edx, DWORD PTR _s$1[ebp], 248
  00102	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00107	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00109	89 4c 10 38	 mov	 DWORD PTR [eax+edx+56], ecx

; 6414 : 						S_StartSound(&sectors[s].soundorg, sfx_appear);

  0010d	6a 1a		 push	 26			; 0000001aH
  0010f	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _s$1[ebp], 248
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0011c	8d 54 01 20	 lea	 edx, DWORD PTR [ecx+eax+32]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _S_StartSound
  00126	83 c4 08	 add	 esp, 8
$LN13@T_Disappea:

; 6415 : 					}
; 6416 : 				}
; 6417 : 			}

  00129	e9 5e ff ff ff	 jmp	 $LN5@T_Disappea
$LN6@T_Disappea:

; 6418 : 			sectors[s].moved = true;

  0012e	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _s$1[ebp], 248
  00135	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0013b	c7 84 01 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+172], 1

; 6419 : 		}

  00146	e9 01 ff ff ff	 jmp	 $LN2@T_Disappea
$LN3@T_Disappea:

; 6420 : 
; 6421 : 		if (d->exists)

  0014b	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0014e	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00152	74 18		 je	 SHORT $LN14@T_Disappea

; 6422 : 		{
; 6423 : 			d->timer = d->disappeartime;

  00154	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  0015a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0015d	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 6424 : 			d->exists = false;

  00160	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  00163	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 6425 : 		}

  0016a	eb 16		 jmp	 SHORT $LN15@T_Disappea
$LN14@T_Disappea:

; 6426 : 		else
; 6427 : 		{
; 6428 : 			d->timer = d->appeartime;

  0016c	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00172	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00175	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 6429 : 			d->exists = true;

  00178	8b 45 08	 mov	 eax, DWORD PTR _d$[ebp]
  0017b	c7 40 28 01 00
	00 00		 mov	 DWORD PTR [eax+40], 1
$LN15@T_Disappea:

; 6430 : 		}
; 6431 : 	}
; 6432 : }

  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_T_Disappear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _T_Friction
_TEXT	SEGMENT
_referrer$1 = -20					; size = 4
_referrer$2 = -16					; size = 4
_node$ = -12						; size = 4
_thing$ = -8						; size = 4
_sec$ = -4						; size = 4
_f$ = 8							; size = 4
_T_Friction PROC					; COMDAT

; 6475 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6476 : 	sector_t *sec;
; 6477 : 	mobj_t *thing;
; 6478 : 	msecnode_t *node;
; 6479 : 
; 6480 : 	sec = sectors + f->affectee;

  00009	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0000c	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  00013	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00019	89 4d fc	 mov	 DWORD PTR _sec$[ebp], ecx

; 6481 : 
; 6482 : 	// Make sure the sector type hasn't changed
; 6483 : 	if (f->roverfriction)

  0001c	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0001f	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  00023	85 c9		 test	 ecx, ecx
  00025	74 3e		 je	 SHORT $LN4@T_Friction

; 6484 : 	{
; 6485 : 		sector_t *referrer = sectors + f->referrer;

  00027	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0002a	69 48 1c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+28], 248
  00031	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00037	89 4d f0	 mov	 DWORD PTR _referrer$2[ebp], ecx

; 6486 : 
; 6487 : 		if (!(GETSECSPECIAL(referrer->special, 3) == 1

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _referrer$2[ebp]
  0003d	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00041	c1 f9 08	 sar	 ecx, 8
  00044	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00047	83 f9 01	 cmp	 ecx, 1
  0004a	74 17		 je	 SHORT $LN6@T_Friction
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _referrer$2[ebp]
  0004f	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00053	c1 f9 08	 sar	 ecx, 8
  00056	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00059	83 f9 03	 cmp	 ecx, 3
  0005c	74 05		 je	 SHORT $LN6@T_Friction

; 6488 : 			|| GETSECSPECIAL(referrer->special, 3) == 3))
; 6489 : 			return;

  0005e	e9 3e 01 00 00	 jmp	 $LN3@T_Friction
$LN6@T_Friction:

; 6490 : 	}

  00063	eb 29		 jmp	 SHORT $LN7@T_Friction
$LN4@T_Friction:

; 6491 : 	else
; 6492 : 	{
; 6493 : 		if (!(GETSECSPECIAL(sec->special, 3) == 1

  00065	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00068	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0006c	c1 f9 08	 sar	 ecx, 8
  0006f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00072	83 f9 01	 cmp	 ecx, 1
  00075	74 17		 je	 SHORT $LN7@T_Friction
  00077	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  0007a	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0007e	c1 f9 08	 sar	 ecx, 8
  00081	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00084	83 f9 03	 cmp	 ecx, 3
  00087	74 05		 je	 SHORT $LN7@T_Friction

; 6494 : 			|| GETSECSPECIAL(sec->special, 3) == 3))
; 6495 : 			return;

  00089	e9 13 01 00 00	 jmp	 $LN3@T_Friction
$LN7@T_Friction:

; 6496 : 	}
; 6497 : 
; 6498 : 	// Assign the friction value to players on the floor, non-floating,
; 6499 : 	// and clipped. Normally the object's friction value is kept at
; 6500 : 	// ORIG_FRICTION and this thinker changes it for icy or muddy floors.
; 6501 : 
; 6502 : 	// When the object is straddling sectors with the same
; 6503 : 	// floorheight that have different frictions, use the lowest
; 6504 : 	// friction value (muddy has precedence over icy).
; 6505 : 
; 6506 : 	node = sec->touching_thinglist; // things touching this sector

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00091	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00097	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx
$LN17@T_Friction:

; 6507 : 	while (node)

  0009a	83 7d f4 00	 cmp	 DWORD PTR _node$[ebp], 0
  0009e	0f 84 fd 00 00
	00		 je	 $LN3@T_Friction

; 6508 : 	{
; 6509 : 		thing = node->m_thing;

  000a4	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  000a7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000aa	89 4d f8	 mov	 DWORD PTR _thing$[ebp], ecx

; 6510 : 		// apparently, all I had to do was comment out part of the next line and
; 6511 : 		// friction works for all mobj's
; 6512 : 		// (or at least MF_PUSHABLEs, which is all I care about anyway)
; 6513 : 		if (!(thing->flags & (MF_NOGRAVITY | MF_NOCLIP)) && thing->z == thing->floorz)

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  000b0	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000b3	81 e1 00 12 00
	00		 and	 ecx, 4608		; 00001200H
  000b9	0f 85 d4 00 00
	00		 jne	 $LN14@T_Friction
  000bf	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  000c5	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000c8	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  000cb	0f 85 c2 00 00
	00		 jne	 $LN14@T_Friction

; 6514 : 		{
; 6515 : 			if (f->roverfriction)

  000d1	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  000d4	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  000d8	85 c9		 test	 ecx, ecx
  000da	74 6c		 je	 SHORT $LN9@T_Friction

; 6516 : 			{
; 6517 : 				sector_t *referrer = &sectors[f->referrer];

  000dc	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  000df	69 48 1c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+28], 248
  000e6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  000ec	89 4d ec	 mov	 DWORD PTR _referrer$1[ebp], ecx

; 6518 : 
; 6519 : 				if (thing->floorz != referrer->ceilingheight)

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  000f2	8b 4d ec	 mov	 ecx, DWORD PTR _referrer$1[ebp]
  000f5	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  000f8	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000fb	74 0b		 je	 SHORT $LN11@T_Friction

; 6520 : 				{
; 6521 : 					node = node->m_snext;

  000fd	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00100	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00103	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx

; 6522 : 					continue;

  00106	eb 92		 jmp	 SHORT $LN17@T_Friction
$LN11@T_Friction:

; 6523 : 				}
; 6524 : 
; 6525 : 				if ((thing->friction == ORIG_FRICTION) // normal friction?
; 6526 : 					|| (f->friction < thing->friction))

  00108	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0010b	81 b8 b4 00 00
	00 00 e8 00 00	 cmp	 DWORD PTR [eax+180], 59392 ; 0000e800H
  00115	74 11		 je	 SHORT $LN13@T_Friction
  00117	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  0011d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00120	3b 91 b4 00 00
	00		 cmp	 edx, DWORD PTR [ecx+180]
  00126	7d 1e		 jge	 SHORT $LN12@T_Friction
$LN13@T_Friction:

; 6527 : 				{
; 6528 : 					thing->friction = f->friction;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0012e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00131	89 90 b4 00 00
	00		 mov	 DWORD PTR [eax+180], edx

; 6529 : 					thing->movefactor = f->movefactor;

  00137	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0013d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00140	89 90 b8 00 00
	00		 mov	 DWORD PTR [eax+184], edx
$LN12@T_Friction:

; 6530 : 				}
; 6531 : 			}

  00146	eb 4b		 jmp	 SHORT $LN14@T_Friction
$LN9@T_Friction:

; 6532 : 			else if (sec->floorheight == thing->floorz && (thing->friction == ORIG_FRICTION // normal friction?

  00148	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  0014e	8b 10		 mov	 edx, DWORD PTR [eax]
  00150	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  00153	75 3e		 jne	 SHORT $LN14@T_Friction
  00155	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00158	81 b8 b4 00 00
	00 00 e8 00 00	 cmp	 DWORD PTR [eax+180], 59392 ; 0000e800H
  00162	74 11		 je	 SHORT $LN15@T_Friction
  00164	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _thing$[ebp]
  0016a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0016d	3b 91 b4 00 00
	00		 cmp	 edx, DWORD PTR [ecx+180]
  00173	7d 1e		 jge	 SHORT $LN14@T_Friction
$LN15@T_Friction:

; 6533 : 				|| f->friction < thing->friction))
; 6534 : 			{
; 6535 : 				thing->friction = f->friction;

  00175	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00178	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0017b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0017e	89 90 b4 00 00
	00		 mov	 DWORD PTR [eax+180], edx

; 6536 : 				thing->movefactor = f->movefactor;

  00184	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00187	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0018a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0018d	89 90 b8 00 00
	00		 mov	 DWORD PTR [eax+184], edx
$LN14@T_Friction:

; 6537 : 			}
; 6538 : 		}
; 6539 : 		node = node->m_snext;

  00193	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00196	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00199	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx

; 6540 : 	}

  0019c	e9 f9 fe ff ff	 jmp	 $LN17@T_Friction
$LN3@T_Friction:

; 6541 : }

  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
_T_Friction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _T_LaserFlash
_TEXT	SEGMENT
_sector$ = -24						; size = 4
_ffloor$ = -20						; size = 4
_zplusheight$ = -16					; size = 4
_sourcesec$ = -12					; size = 4
_thing$ = -8						; size = 4
_node$ = -4						; size = 4
_flash$ = 8						; size = 4
_T_LaserFlash PROC					; COMDAT

; 4800 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4801 : 	msecnode_t *node;
; 4802 : 	mobj_t *thing;
; 4803 : 	sector_t *sourcesec;
; 4804 : 	fixed_t zplusheight;
; 4805 : 	ffloor_t *ffloor = flash->ffloor;

  00009	8b 45 08	 mov	 eax, DWORD PTR _flash$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d ec	 mov	 DWORD PTR _ffloor$[ebp], ecx

; 4806 : 	sector_t *sector = flash->sector;

  00012	8b 45 08	 mov	 eax, DWORD PTR _flash$[ebp]
  00015	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00018	89 4d e8	 mov	 DWORD PTR _sector$[ebp], ecx

; 4807 : 
; 4808 : 	if (!ffloor)

  0001b	83 7d ec 00	 cmp	 DWORD PTR _ffloor$[ebp], 0
  0001f	75 2c		 jne	 SHORT $LN5@T_LaserFla

; 4809 : 		flash->ffloor = ffloor = P_AddFakeFloor(sector, flash->sec, flash->sourceline, laserflags);

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _laserflags
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _flash$[ebp]
  0002a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _flash$[ebp]
  00031	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00034	51		 push	 ecx
  00035	8b 55 e8	 mov	 edx, DWORD PTR _sector$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _P_AddFakeFloor
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	89 45 ec	 mov	 DWORD PTR _ffloor$[ebp], eax
  00044	8b 45 08	 mov	 eax, DWORD PTR _flash$[ebp]
  00047	8b 4d ec	 mov	 ecx, DWORD PTR _ffloor$[ebp]
  0004a	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN5@T_LaserFla:

; 4810 : 
; 4811 : 	if (!ffloor || !(ffloor->flags & FF_EXISTS))

  0004d	83 7d ec 00	 cmp	 DWORD PTR _ffloor$[ebp], 0
  00051	74 0b		 je	 SHORT $LN7@T_LaserFla
  00053	8b 45 ec	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00056	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00059	83 e1 01	 and	 ecx, 1
  0005c	75 05		 jne	 SHORT $LN6@T_LaserFla
$LN7@T_LaserFla:

; 4812 : 		return;

  0005e	e9 fa 00 00 00	 jmp	 $LN3@T_LaserFla
$LN6@T_LaserFla:

; 4813 : 
; 4814 : 	if (leveltime & 1)

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  00068	83 e0 01	 and	 eax, 1
  0006b	74 11		 je	 SHORT $LN8@T_LaserFla

; 4815 : 		ffloor->flags |= FF_RENDERALL;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00070	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00073	83 c9 18	 or	 ecx, 24			; 00000018H
  00076	8b 55 ec	 mov	 edx, DWORD PTR _ffloor$[ebp]
  00079	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
  0007c	eb 0f		 jmp	 SHORT $LN9@T_LaserFla
$LN8@T_LaserFla:

; 4816 : 	else
; 4817 : 		ffloor->flags &= ~FF_RENDERALL;

  0007e	8b 45 ec	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00081	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00084	83 e1 e7	 and	 ecx, -25		; ffffffe7H
  00087	8b 55 ec	 mov	 edx, DWORD PTR _ffloor$[ebp]
  0008a	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
$LN9@T_LaserFla:

; 4818 : 
; 4819 : 	sourcesec = ffloor->master->frontsector; // Less to type!

  0008d	8b 45 ec	 mov	 eax, DWORD PTR _ffloor$[ebp]
  00090	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00093	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00096	89 55 f4	 mov	 DWORD PTR _sourcesec$[ebp], edx

; 4820 : 
; 4821 : 	sector->soundorg.z = (*ffloor->topheight + *ffloor->bottomheight)/2;

  00099	8b 45 ec	 mov	 eax, DWORD PTR _ffloor$[ebp]
  0009c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009e	8b 55 ec	 mov	 edx, DWORD PTR _ffloor$[ebp]
  000a1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000a4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a6	03 08		 add	 ecx, DWORD PTR [eax]
  000a8	8b c1		 mov	 eax, ecx
  000aa	99		 cdq
  000ab	2b c2		 sub	 eax, edx
  000ad	d1 f8		 sar	 eax, 1
  000af	8b 55 e8	 mov	 edx, DWORD PTR _sector$[ebp]
  000b2	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 4822 : 	S_StartSound(&sector->soundorg, sfx_laser);

  000b5	6a 56		 push	 86			; 00000056H
  000b7	8b 45 e8	 mov	 eax, DWORD PTR _sector$[ebp]
  000ba	83 c0 20	 add	 eax, 32			; 00000020H
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _S_StartSound
  000c3	83 c4 08	 add	 esp, 8

; 4823 : 
; 4824 : 	// Seek out objects to DESTROY! MUAHAHHAHAHAA!!!*cough*
; 4825 : 	for (node = sector->touching_thinglist; node && node->m_thing; node = node->m_snext)

  000c6	8b 45 e8	 mov	 eax, DWORD PTR _sector$[ebp]
  000c9	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000cf	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx
  000d2	eb 09		 jmp	 SHORT $LN4@T_LaserFla
$LN2@T_LaserFla:
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000d7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000da	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx
$LN4@T_LaserFla:
  000dd	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  000e1	74 7a		 je	 SHORT $LN3@T_LaserFla
  000e3	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000e6	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000ea	74 71		 je	 SHORT $LN3@T_LaserFla

; 4826 : 	{
; 4827 : 		thing = node->m_thing;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000ef	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f2	89 4d f8	 mov	 DWORD PTR _thing$[ebp], ecx

; 4828 : 
; 4829 : 		if ((ffloor->master->flags & ML_EFFECT1)
; 4830 : 			&& thing->flags & MF_BOSS)

  000f5	8b 45 ec	 mov	 eax, DWORD PTR _ffloor$[ebp]
  000f8	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000fb	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  000ff	83 e2 20	 and	 edx, 32			; 00000020H
  00102	74 10		 je	 SHORT $LN10@T_LaserFla
  00104	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00107	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0010a	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00110	74 02		 je	 SHORT $LN10@T_LaserFla

; 4831 : 			continue; // Don't hurt bosses

  00112	eb c0		 jmp	 SHORT $LN2@T_LaserFla
$LN10@T_LaserFla:

; 4832 : 
; 4833 : 		zplusheight = thing->z + thing->height;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00117	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0011a	8b 55 f8	 mov	 edx, DWORD PTR _thing$[ebp]
  0011d	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00120	89 4d f0	 mov	 DWORD PTR _zplusheight$[ebp], ecx

; 4834 : 
; 4835 : 		if ((thing->flags & MF_SHOOTABLE)
; 4836 : 			&& (thing->z < sourcesec->ceilingheight && zplusheight > sourcesec->floorheight))

  00123	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00126	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00129	83 e1 04	 and	 ecx, 4
  0012c	74 2a		 je	 SHORT $LN11@T_LaserFla
  0012e	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  00131	8b 4d f4	 mov	 ecx, DWORD PTR _sourcesec$[ebp]
  00134	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00137	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0013a	7d 1c		 jge	 SHORT $LN11@T_LaserFla
  0013c	8b 45 f4	 mov	 eax, DWORD PTR _sourcesec$[ebp]
  0013f	8b 4d f0	 mov	 ecx, DWORD PTR _zplusheight$[ebp]
  00142	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00144	7e 12		 jle	 SHORT $LN11@T_LaserFla

; 4837 : 		{
; 4838 : 			P_DamageMobj(thing, NULL, NULL, 1);

  00146	6a 01		 push	 1
  00148	6a 00		 push	 0
  0014a	6a 00		 push	 0
  0014c	8b 45 f8	 mov	 eax, DWORD PTR _thing$[ebp]
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _P_DamageMobj
  00155	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@T_LaserFla:

; 4839 : 		}
; 4840 : 	}

  00158	e9 77 ff ff ff	 jmp	 $LN2@T_LaserFla
$LN3@T_LaserFla:

; 4841 : }

  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_T_LaserFlash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _T_Scroll
_TEXT	SEGMENT
tv129 = -128						; size = 4
_psec$1 = -60						; size = 4
_psec$2 = -56						; size = 4
_sect$3 = -52						; size = 4
_i$4 = -48						; size = 4
_line$5 = -44						; size = 4
_thing$6 = -40						; size = 4
_node$7 = -36						; size = 4
_height$8 = -32						; size = 4
_sec$9 = -28						; size = 4
_side$10 = -24						; size = 4
_delta$11 = -20						; size = 4
_height$12 = -16					; size = 4
_is3dblock$ = -12					; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_s$ = 8							; size = 4
_T_Scroll PROC						; COMDAT

; 5944 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 5945 : 	fixed_t dx = s->dx, dy = s->dy;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	89 4d fc	 mov	 DWORD PTR _dx$[ebp], ecx
  00015	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00018	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001b	89 4d f8	 mov	 DWORD PTR _dy$[ebp], ecx

; 5946 : 	boolean is3dblock = false;

  0001e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _is3dblock$[ebp], 0

; 5947 : 
; 5948 : 	if (P_FreezeObjectplace())

  00025	e8 00 00 00 00	 call	 _P_FreezeObjectplace
  0002a	85 c0		 test	 eax, eax
  0002c	74 05		 je	 SHORT $LN28@T_Scroll

; 5949 : 		return;

  0002e	e9 43 09 00 00	 jmp	 $LN2@T_Scroll
$LN28@T_Scroll:

; 5950 : 
; 5951 : 	if (s->control != -1)

  00033	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00036	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  0003a	74 65		 je	 SHORT $LN29@T_Scroll

; 5952 : 	{ // compute scroll amounts based on a sector's height changes
; 5953 : 		fixed_t height = sectors[s->control].floorheight +

  0003c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003f	69 48 1c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+28], 248
  00046	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00049	69 42 1c f8 00
	00 00		 imul	 eax, DWORD PTR [edx+28], 248
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00056	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  00059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0005f	03 4c 02 04	 add	 ecx, DWORD PTR [edx+eax+4]
  00063	89 4d f0	 mov	 DWORD PTR _height$12[ebp], ecx

; 5954 : 			sectors[s->control].ceilingheight;
; 5955 : 		fixed_t delta = height - s->last_height;

  00066	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00069	8b 4d f0	 mov	 ecx, DWORD PTR _height$12[ebp]
  0006c	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  0006f	89 4d ec	 mov	 DWORD PTR _delta$11[ebp], ecx

; 5956 : 		s->last_height = height;

  00072	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _height$12[ebp]
  00078	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 5957 : 		dx = FixedMul(dx, delta);

  0007b	8b 45 ec	 mov	 eax, DWORD PTR _delta$11[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _dx$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _FixedMul
  00088	83 c4 08	 add	 esp, 8
  0008b	89 45 fc	 mov	 DWORD PTR _dx$[ebp], eax

; 5958 : 		dy = FixedMul(dy, delta);

  0008e	8b 45 ec	 mov	 eax, DWORD PTR _delta$11[ebp]
  00091	50		 push	 eax
  00092	8b 4d f8	 mov	 ecx, DWORD PTR _dy$[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _FixedMul
  0009b	83 c4 08	 add	 esp, 8
  0009e	89 45 f8	 mov	 DWORD PTR _dy$[ebp], eax
$LN29@T_Scroll:

; 5959 : 	}
; 5960 : 
; 5961 : 	if (s->accel)

  000a1	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000a4	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  000a8	74 2a		 je	 SHORT $LN30@T_Scroll

; 5962 : 	{
; 5963 : 		s->vdx = dx += s->vdx;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _dx$[ebp]
  000b0	03 48 24	 add	 ecx, DWORD PTR [eax+36]
  000b3	89 4d fc	 mov	 DWORD PTR _dx$[ebp], ecx
  000b6	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b9	8b 45 fc	 mov	 eax, DWORD PTR _dx$[ebp]
  000bc	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 5964 : 		s->vdy = dy += s->vdy;

  000bf	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _dy$[ebp]
  000c5	03 48 28	 add	 ecx, DWORD PTR [eax+40]
  000c8	89 4d f8	 mov	 DWORD PTR _dy$[ebp], ecx
  000cb	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000ce	8b 45 f8	 mov	 eax, DWORD PTR _dy$[ebp]
  000d1	89 42 28	 mov	 DWORD PTR [edx+40], eax
$LN30@T_Scroll:

; 5965 : 	}
; 5966 : 
; 5967 : //	if (!(dx | dy)) // no-op if both (x,y) offsets 0
; 5968 : //		return;
; 5969 : 
; 5970 : 	switch (s->type)

  000d4	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000d7	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000da	89 4d 80	 mov	 DWORD PTR tv129[ebp], ecx
  000dd	83 7d 80 04	 cmp	 DWORD PTR tv129[ebp], 4
  000e1	0f 87 8f 08 00
	00		 ja	 $LN2@T_Scroll
  000e7	8b 55 80	 mov	 edx, DWORD PTR tv129[ebp]
  000ea	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN73@T_Scroll[edx*4]
$LN31@T_Scroll:

; 5971 : 	{
; 5972 : 		side_t *side;
; 5973 : 		sector_t *sec;
; 5974 : 		fixed_t height;
; 5975 : 		msecnode_t *node;
; 5976 : 		mobj_t *thing;
; 5977 : 		line_t *line;
; 5978 : 		size_t i;
; 5979 : 		INT32 sect;
; 5980 : 
; 5981 : 		case sc_side: // scroll wall texture
; 5982 : 			side = sides + s->affectee;

  000f1	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000f4	6b 48 18 1c	 imul	 ecx, DWORD PTR [eax+24], 28
  000f8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sides
  000fe	89 4d e8	 mov	 DWORD PTR _side$10[ebp], ecx

; 5983 : 			side->textureoffset += dx;

  00101	8b 45 e8	 mov	 eax, DWORD PTR _side$10[ebp]
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  00109	8b 55 e8	 mov	 edx, DWORD PTR _side$10[ebp]
  0010c	89 0a		 mov	 DWORD PTR [edx], ecx

; 5984 : 			side->rowoffset += dy;

  0010e	8b 45 e8	 mov	 eax, DWORD PTR _side$10[ebp]
  00111	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00114	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  00117	8b 55 e8	 mov	 edx, DWORD PTR _side$10[ebp]
  0011a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 5985 : 			break;

  0011d	e9 54 08 00 00	 jmp	 $LN2@T_Scroll
$LN32@T_Scroll:

; 5986 : 
; 5987 : 		case sc_floor: // scroll floor texture
; 5988 : 			sec = sectors + s->affectee;

  00122	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00125	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  0012c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00132	89 4d e4	 mov	 DWORD PTR _sec$9[ebp], ecx

; 5989 : 			sec->floor_xoffs += dx;

  00135	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  00138	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0013b	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  0013e	8b 55 e4	 mov	 edx, DWORD PTR _sec$9[ebp]
  00141	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 5990 : 			sec->floor_yoffs += dy;

  00144	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  00147	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0014a	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  0014d	8b 55 e4	 mov	 edx, DWORD PTR _sec$9[ebp]
  00150	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 5991 : 			break;

  00153	e9 1e 08 00 00	 jmp	 $LN2@T_Scroll
$LN33@T_Scroll:

; 5992 : 
; 5993 : 		case sc_ceiling: // scroll ceiling texture
; 5994 : 			sec = sectors + s->affectee;

  00158	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0015b	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  00162	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00168	89 4d e4	 mov	 DWORD PTR _sec$9[ebp], ecx

; 5995 : 			sec->ceiling_xoffs += dx;

  0016b	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  0016e	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00171	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  00174	8b 55 e4	 mov	 edx, DWORD PTR _sec$9[ebp]
  00177	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 5996 : 			sec->ceiling_yoffs += dy;

  0017a	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  0017d	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00180	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  00183	8b 55 e4	 mov	 edx, DWORD PTR _sec$9[ebp]
  00186	89 4a 5c	 mov	 DWORD PTR [edx+92], ecx

; 5997 : 			break;

  00189	e9 e8 07 00 00	 jmp	 $LN2@T_Scroll
$LN34@T_Scroll:

; 5998 : 
; 5999 : 		case sc_carry:
; 6000 : 			sec = sectors + s->affectee;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00191	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  00198	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0019e	89 4d e4	 mov	 DWORD PTR _sec$9[ebp], ecx

; 6001 : 			height = sec->floorheight;

  001a1	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  001a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a6	89 4d e0	 mov	 DWORD PTR _height$8[ebp], ecx

; 6002 : 
; 6003 : 			// sec is the control sector, find the real sector(s) to use
; 6004 : 			for (i = 0; i < sec->linecount; i++)

  001a9	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  001b0	eb 09		 jmp	 SHORT $LN6@T_Scroll
$LN4@T_Scroll:
  001b2	8b 45 d0	 mov	 eax, DWORD PTR _i$4[ebp]
  001b5	83 c0 01	 add	 eax, 1
  001b8	89 45 d0	 mov	 DWORD PTR _i$4[ebp], eax
$LN6@T_Scroll:
  001bb	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  001be	8b 4d d0	 mov	 ecx, DWORD PTR _i$4[ebp]
  001c1	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  001c7	0f 83 18 02 00
	00		 jae	 $LN5@T_Scroll

; 6005 : 			{
; 6006 : 				line = sec->lines[i];

  001cd	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  001d0	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  001d6	8b 55 d0	 mov	 edx, DWORD PTR _i$4[ebp]
  001d9	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001dc	89 45 d4	 mov	 DWORD PTR _line$5[ebp], eax

; 6007 : 
; 6008 : 				if (line->special < 100 || line->special >= 300)

  001df	8b 45 d4	 mov	 eax, DWORD PTR _line$5[ebp]
  001e2	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  001e6	83 f9 64	 cmp	 ecx, 100		; 00000064H
  001e9	7c 0f		 jl	 SHORT $LN37@T_Scroll
  001eb	8b 45 d4	 mov	 eax, DWORD PTR _line$5[ebp]
  001ee	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  001f2	81 f9 2c 01 00
	00		 cmp	 ecx, 300		; 0000012cH
  001f8	7c 09		 jl	 SHORT $LN35@T_Scroll
$LN37@T_Scroll:

; 6009 : 					is3dblock = false;

  001fa	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _is3dblock$[ebp], 0
  00201	eb 07		 jmp	 SHORT $LN36@T_Scroll
$LN35@T_Scroll:

; 6010 : 				else
; 6011 : 					is3dblock = true;

  00203	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _is3dblock$[ebp], 1
$LN36@T_Scroll:

; 6012 : 
; 6013 : 				if (!is3dblock)

  0020a	83 7d f4 00	 cmp	 DWORD PTR _is3dblock$[ebp], 0
  0020e	75 02		 jne	 SHORT $LN38@T_Scroll

; 6014 : 					continue;

  00210	eb a0		 jmp	 SHORT $LN4@T_Scroll
$LN38@T_Scroll:

; 6015 : 
; 6016 : 				for (sect = -1; (sect = P_FindSectorFromTag(line->tag, sect)) >= 0 ;)

  00212	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _sect$3[ebp], -1
$LN7@T_Scroll:
  00219	8b 45 cc	 mov	 eax, DWORD PTR _sect$3[ebp]
  0021c	50		 push	 eax
  0021d	8b 4d d4	 mov	 ecx, DWORD PTR _line$5[ebp]
  00220	0f b7 51 14	 movzx	 edx, WORD PTR [ecx+20]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 _P_FindSectorFromTag
  0022a	83 c4 08	 add	 esp, 8
  0022d	89 45 cc	 mov	 DWORD PTR _sect$3[ebp], eax
  00230	83 7d cc 00	 cmp	 DWORD PTR _sect$3[ebp], 0
  00234	0f 8c a6 01 00
	00		 jl	 $LN8@T_Scroll

; 6017 : 				{
; 6018 : 					sector_t *psec;
; 6019 : 					psec = sectors + sect;

  0023a	69 45 cc f8 00
	00 00		 imul	 eax, DWORD PTR _sect$3[ebp], 248
  00241	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00247	89 45 c8	 mov	 DWORD PTR _psec$2[ebp], eax

; 6020 : 
; 6021 : 					for (node = psec->touching_thinglist; node; node = node->m_snext)

  0024a	8b 45 c8	 mov	 eax, DWORD PTR _psec$2[ebp]
  0024d	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00253	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
  00256	eb 09		 jmp	 SHORT $LN12@T_Scroll
$LN10@T_Scroll:
  00258	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  0025b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0025e	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
$LN12@T_Scroll:
  00261	83 7d dc 00	 cmp	 DWORD PTR _node$7[ebp], 0
  00265	0f 84 70 01 00
	00		 je	 $LN11@T_Scroll

; 6022 : 					{
; 6023 : 						thing = node->m_thing;

  0026b	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  0026e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00271	89 4d d8	 mov	 DWORD PTR _thing$6[ebp], ecx

; 6024 : 
; 6025 : 						if (thing->flags2 & MF2_PUSHED) // Already pushed this tic by an exclusive pusher.

  00274	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00277	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0027d	83 e1 01	 and	 ecx, 1
  00280	74 02		 je	 SHORT $LN39@T_Scroll

; 6026 : 							continue;

  00282	eb d4		 jmp	 SHORT $LN10@T_Scroll
$LN39@T_Scroll:

; 6027 : 
; 6028 : 						if (!(thing->flags & MF_NOCLIP)) // Thing must be clipped

  00284	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00287	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0028a	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00290	0f 85 40 01 00
	00		 jne	 $LN45@T_Scroll

; 6029 : 						if (!(thing->flags & MF_NOGRAVITY || thing->z+thing->height != height)) // Thing must a) be non-floating and have z+height == height

  00296	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00299	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0029c	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  002a2	0f 85 2e 01 00
	00		 jne	 $LN45@T_Scroll
  002a8	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  002ab	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002ae	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  002b1	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  002b4	3b 4d e0	 cmp	 ecx, DWORD PTR _height$8[ebp]
  002b7	0f 85 19 01 00
	00		 jne	 $LN45@T_Scroll

; 6030 : 						{
; 6031 : 							// Move objects only if on floor
; 6032 : 							// non-floating, and clipped.
; 6033 : 							thing->momx += dx;

  002bd	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  002c0	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  002c3	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  002c6	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  002c9	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 6034 : 							thing->momy += dy;

  002cc	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  002cf	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  002d2	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  002d5	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  002d8	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 6035 : 							if (thing->player)

  002db	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  002de	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  002e5	0f 84 cd 00 00
	00		 je	 $LN44@T_Scroll

; 6036 : 							{
; 6037 : 								if (!(dx | dy))

  002eb	8b 45 fc	 mov	 eax, DWORD PTR _dx$[ebp]
  002ee	0b 45 f8	 or	 eax, DWORD PTR _dy$[ebp]
  002f1	75 2b		 jne	 SHORT $LN43@T_Scroll

; 6038 : 								{
; 6039 : 									thing->player->cmomx = 0;

  002f3	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  002f6	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002fc	c7 81 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+316], 0

; 6040 : 									thing->player->cmomy = 0;

  00306	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00309	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0030f	c7 81 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+320], 0

; 6041 : 								}

  00319	e9 9a 00 00 00	 jmp	 $LN44@T_Scroll
$LN43@T_Scroll:

; 6042 : 								else
; 6043 : 								{
; 6044 : 									thing->player->cmomx += dx;

  0031e	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00321	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00327	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  0032d	03 55 fc	 add	 edx, DWORD PTR _dx$[ebp]
  00330	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00333	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00339	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 6045 : 									thing->player->cmomy += dy;

  0033f	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00342	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00348	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  0034e	03 55 f8	 add	 edx, DWORD PTR _dy$[ebp]
  00351	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00354	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0035a	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 6046 : 									thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  00360	68 00 e8 00 00	 push	 59392			; 0000e800H
  00365	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00368	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0036e	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  00374	52		 push	 edx
  00375	e8 00 00 00 00	 call	 _FixedMul
  0037a	83 c4 08	 add	 esp, 8
  0037d	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  00380	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00386	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6047 : 									thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  0038c	68 00 e8 00 00	 push	 59392			; 0000e800H
  00391	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00394	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0039a	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  003a0	52		 push	 edx
  003a1	e8 00 00 00 00	 call	 _FixedMul
  003a6	83 c4 08	 add	 esp, 8
  003a9	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  003ac	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  003b2	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN44@T_Scroll:

; 6048 : 								}
; 6049 : 							}
; 6050 : 
; 6051 : 							if (s->exclusive)

  003b8	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  003bb	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  003bf	74 15		 je	 SHORT $LN45@T_Scroll

; 6052 : 								thing->flags2 |= MF2_PUSHED;

  003c1	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  003c4	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  003ca	83 c9 01	 or	 ecx, 1
  003cd	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  003d0	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN45@T_Scroll:

; 6053 : 						}
; 6054 : 					} // end of for loop through touching_thinglist

  003d6	e9 7d fe ff ff	 jmp	 $LN10@T_Scroll
$LN11@T_Scroll:

; 6055 : 				} // end of loop through sectors

  003db	e9 39 fe ff ff	 jmp	 $LN7@T_Scroll
$LN8@T_Scroll:

; 6056 : 			}

  003e0	e9 cd fd ff ff	 jmp	 $LN4@T_Scroll
$LN5@T_Scroll:

; 6057 : 
; 6058 : 			if (!is3dblock)

  003e5	83 7d f4 00	 cmp	 DWORD PTR _is3dblock$[ebp], 0
  003e9	0f 85 93 01 00
	00		 jne	 $LN14@T_Scroll

; 6059 : 			{
; 6060 : 				for (node = sec->touching_thinglist; node; node = node->m_snext)

  003ef	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  003f2	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  003f8	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
  003fb	eb 09		 jmp	 SHORT $LN15@T_Scroll
$LN13@T_Scroll:
  003fd	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  00400	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00403	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
$LN15@T_Scroll:
  00406	83 7d dc 00	 cmp	 DWORD PTR _node$7[ebp], 0
  0040a	0f 84 72 01 00
	00		 je	 $LN14@T_Scroll

; 6061 : 				{
; 6062 : 					thing = node->m_thing;

  00410	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  00413	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00416	89 4d d8	 mov	 DWORD PTR _thing$6[ebp], ecx

; 6063 : 
; 6064 : 					if (thing->flags2 & MF2_PUSHED)

  00419	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0041c	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00422	83 e1 01	 and	 ecx, 1
  00425	74 02		 je	 SHORT $LN47@T_Scroll

; 6065 : 						continue;

  00427	eb d4		 jmp	 SHORT $LN13@T_Scroll
$LN47@T_Scroll:

; 6066 : 
; 6067 : 					if (!((thing = node->m_thing)->flags & MF_NOCLIP) &&

  00429	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  0042c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0042f	89 4d d8	 mov	 DWORD PTR _thing$6[ebp], ecx
  00432	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  00435	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00438	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0043d	0f 85 3a 01 00
	00		 jne	 $LN52@T_Scroll
  00443	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00446	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00449	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0044f	0f 85 28 01 00
	00		 jne	 $LN52@T_Scroll
  00455	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00458	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0045b	3b 4d e0	 cmp	 ecx, DWORD PTR _height$8[ebp]
  0045e	0f 8f 19 01 00
	00		 jg	 $LN52@T_Scroll

; 6068 : 						(!(thing->flags & MF_NOGRAVITY || thing->z > height)))
; 6069 : 					{
; 6070 : 						// Move objects only if on floor or underwater,
; 6071 : 						// non-floating, and clipped.
; 6072 : 						thing->momx += dx;

  00464	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00467	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0046a	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  0046d	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  00470	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 6073 : 						thing->momy += dy;

  00473	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00476	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00479	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  0047c	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  0047f	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 6074 : 						if (thing->player)

  00482	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00485	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0048c	0f 84 cd 00 00
	00		 je	 $LN51@T_Scroll

; 6075 : 						{
; 6076 : 							if (!(dx | dy))

  00492	8b 45 fc	 mov	 eax, DWORD PTR _dx$[ebp]
  00495	0b 45 f8	 or	 eax, DWORD PTR _dy$[ebp]
  00498	75 2b		 jne	 SHORT $LN50@T_Scroll

; 6077 : 							{
; 6078 : 								thing->player->cmomx = 0;

  0049a	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0049d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004a3	c7 81 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+316], 0

; 6079 : 								thing->player->cmomy = 0;

  004ad	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  004b0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004b6	c7 81 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+320], 0

; 6080 : 							}

  004c0	e9 9a 00 00 00	 jmp	 $LN51@T_Scroll
$LN50@T_Scroll:

; 6081 : 							else
; 6082 : 							{
; 6083 : 								thing->player->cmomx += dx;

  004c5	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  004c8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004ce	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  004d4	03 55 fc	 add	 edx, DWORD PTR _dx$[ebp]
  004d7	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  004da	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004e0	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 6084 : 								thing->player->cmomy += dy;

  004e6	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  004e9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004ef	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  004f5	03 55 f8	 add	 edx, DWORD PTR _dy$[ebp]
  004f8	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  004fb	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00501	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 6085 : 								thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  00507	68 00 e8 00 00	 push	 59392			; 0000e800H
  0050c	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0050f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00515	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  0051b	52		 push	 edx
  0051c	e8 00 00 00 00	 call	 _FixedMul
  00521	83 c4 08	 add	 esp, 8
  00524	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  00527	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0052d	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6086 : 								thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  00533	68 00 e8 00 00	 push	 59392			; 0000e800H
  00538	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0053b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00541	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00547	52		 push	 edx
  00548	e8 00 00 00 00	 call	 _FixedMul
  0054d	83 c4 08	 add	 esp, 8
  00550	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  00553	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00559	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN51@T_Scroll:

; 6087 : 							}
; 6088 : 						}
; 6089 : 
; 6090 : 						if (s->exclusive)

  0055f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00562	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00566	74 15		 je	 SHORT $LN52@T_Scroll

; 6091 : 							thing->flags2 |= MF2_PUSHED;

  00568	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0056b	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00571	83 c9 01	 or	 ecx, 1
  00574	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  00577	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN52@T_Scroll:

; 6092 : 					}
; 6093 : 				}

  0057d	e9 7b fe ff ff	 jmp	 $LN13@T_Scroll
$LN14@T_Scroll:

; 6094 : 			}
; 6095 : 			break;

  00582	e9 ef 03 00 00	 jmp	 $LN2@T_Scroll
$LN53@T_Scroll:

; 6096 : 
; 6097 : 		case sc_carry_ceiling: // carry on ceiling (FOF scrolling)
; 6098 : 			sec = sectors + s->affectee;

  00587	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0058a	69 48 18 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+24], 248
  00591	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  00597	89 4d e4	 mov	 DWORD PTR _sec$9[ebp], ecx

; 6099 : 			height = sec->ceilingheight;

  0059a	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  0059d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005a0	89 4d e0	 mov	 DWORD PTR _height$8[ebp], ecx

; 6100 : 
; 6101 : 			// sec is the control sector, find the real sector(s) to use
; 6102 : 			for (i = 0; i < sec->linecount; i++)

  005a3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  005aa	eb 09		 jmp	 SHORT $LN18@T_Scroll
$LN16@T_Scroll:
  005ac	8b 45 d0	 mov	 eax, DWORD PTR _i$4[ebp]
  005af	83 c0 01	 add	 eax, 1
  005b2	89 45 d0	 mov	 DWORD PTR _i$4[ebp], eax
$LN18@T_Scroll:
  005b5	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  005b8	8b 4d d0	 mov	 ecx, DWORD PTR _i$4[ebp]
  005bb	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  005c1	0f 83 12 02 00
	00		 jae	 $LN17@T_Scroll

; 6103 : 			{
; 6104 : 				line = sec->lines[i];

  005c7	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  005ca	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  005d0	8b 55 d0	 mov	 edx, DWORD PTR _i$4[ebp]
  005d3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  005d6	89 45 d4	 mov	 DWORD PTR _line$5[ebp], eax

; 6105 : 				if (line->special < 100 || line->special >= 300)

  005d9	8b 45 d4	 mov	 eax, DWORD PTR _line$5[ebp]
  005dc	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  005e0	83 f9 64	 cmp	 ecx, 100		; 00000064H
  005e3	7c 0f		 jl	 SHORT $LN56@T_Scroll
  005e5	8b 45 d4	 mov	 eax, DWORD PTR _line$5[ebp]
  005e8	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  005ec	81 f9 2c 01 00
	00		 cmp	 ecx, 300		; 0000012cH
  005f2	7c 09		 jl	 SHORT $LN54@T_Scroll
$LN56@T_Scroll:

; 6106 : 					is3dblock = false;

  005f4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _is3dblock$[ebp], 0
  005fb	eb 07		 jmp	 SHORT $LN55@T_Scroll
$LN54@T_Scroll:

; 6107 : 				else
; 6108 : 					is3dblock = true;

  005fd	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _is3dblock$[ebp], 1
$LN55@T_Scroll:

; 6109 : 
; 6110 : 				if (!is3dblock)

  00604	83 7d f4 00	 cmp	 DWORD PTR _is3dblock$[ebp], 0
  00608	75 02		 jne	 SHORT $LN57@T_Scroll

; 6111 : 					continue;

  0060a	eb a0		 jmp	 SHORT $LN16@T_Scroll
$LN57@T_Scroll:

; 6112 : 
; 6113 : 				for (sect = -1; (sect = P_FindSectorFromTag(line->tag, sect)) >= 0 ;)

  0060c	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _sect$3[ebp], -1
$LN19@T_Scroll:
  00613	8b 45 cc	 mov	 eax, DWORD PTR _sect$3[ebp]
  00616	50		 push	 eax
  00617	8b 4d d4	 mov	 ecx, DWORD PTR _line$5[ebp]
  0061a	0f b7 51 14	 movzx	 edx, WORD PTR [ecx+20]
  0061e	52		 push	 edx
  0061f	e8 00 00 00 00	 call	 _P_FindSectorFromTag
  00624	83 c4 08	 add	 esp, 8
  00627	89 45 cc	 mov	 DWORD PTR _sect$3[ebp], eax
  0062a	83 7d cc 00	 cmp	 DWORD PTR _sect$3[ebp], 0
  0062e	0f 8c a0 01 00
	00		 jl	 $LN20@T_Scroll

; 6114 : 				{
; 6115 : 					sector_t *psec;
; 6116 : 					psec = sectors + sect;

  00634	69 45 cc f8 00
	00 00		 imul	 eax, DWORD PTR _sect$3[ebp], 248
  0063b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00641	89 45 c4	 mov	 DWORD PTR _psec$1[ebp], eax

; 6117 : 
; 6118 : 					for (node = psec->touching_thinglist; node; node = node->m_snext)

  00644	8b 45 c4	 mov	 eax, DWORD PTR _psec$1[ebp]
  00647	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0064d	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
  00650	eb 09		 jmp	 SHORT $LN24@T_Scroll
$LN22@T_Scroll:
  00652	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  00655	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00658	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
$LN24@T_Scroll:
  0065b	83 7d dc 00	 cmp	 DWORD PTR _node$7[ebp], 0
  0065f	0f 84 6a 01 00
	00		 je	 $LN23@T_Scroll

; 6119 : 					{
; 6120 : 						thing = node->m_thing;

  00665	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  00668	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0066b	89 4d d8	 mov	 DWORD PTR _thing$6[ebp], ecx

; 6121 : 
; 6122 : 						if (thing->flags2 & MF2_PUSHED)

  0066e	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00671	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00677	83 e1 01	 and	 ecx, 1
  0067a	74 02		 je	 SHORT $LN58@T_Scroll

; 6123 : 							continue;

  0067c	eb d4		 jmp	 SHORT $LN22@T_Scroll
$LN58@T_Scroll:

; 6124 : 
; 6125 : 						if (!(thing->flags & MF_NOCLIP)) // Thing must be clipped

  0067e	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00681	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00684	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0068a	0f 85 3a 01 00
	00		 jne	 $LN64@T_Scroll

; 6126 : 						if (!(thing->flags & MF_NOGRAVITY || thing->z != height))// Thing must a) be non-floating and have z == height

  00690	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00693	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00696	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0069c	0f 85 28 01 00
	00		 jne	 $LN64@T_Scroll
  006a2	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  006a5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  006a8	3b 4d e0	 cmp	 ecx, DWORD PTR _height$8[ebp]
  006ab	0f 85 19 01 00
	00		 jne	 $LN64@T_Scroll

; 6127 : 						{
; 6128 : 							// Move objects only if on floor or underwater,
; 6129 : 							// non-floating, and clipped.
; 6130 : 							thing->momx += dx;

  006b1	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  006b4	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  006b7	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  006ba	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  006bd	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 6131 : 							thing->momy += dy;

  006c0	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  006c3	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  006c6	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  006c9	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  006cc	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 6132 : 							if (thing->player)

  006cf	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  006d2	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  006d9	0f 84 cd 00 00
	00		 je	 $LN63@T_Scroll

; 6133 : 							{
; 6134 : 								if (!(dx | dy))

  006df	8b 45 fc	 mov	 eax, DWORD PTR _dx$[ebp]
  006e2	0b 45 f8	 or	 eax, DWORD PTR _dy$[ebp]
  006e5	75 2b		 jne	 SHORT $LN62@T_Scroll

; 6135 : 								{
; 6136 : 									thing->player->cmomx = 0;

  006e7	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  006ea	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  006f0	c7 81 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+316], 0

; 6137 : 									thing->player->cmomy = 0;

  006fa	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  006fd	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00703	c7 81 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+320], 0

; 6138 : 								}

  0070d	e9 9a 00 00 00	 jmp	 $LN63@T_Scroll
$LN62@T_Scroll:

; 6139 : 								else
; 6140 : 								{
; 6141 : 									thing->player->cmomx += dx;

  00712	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00715	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0071b	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  00721	03 55 fc	 add	 edx, DWORD PTR _dx$[ebp]
  00724	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00727	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0072d	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 6142 : 									thing->player->cmomy += dy;

  00733	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00736	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0073c	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00742	03 55 f8	 add	 edx, DWORD PTR _dy$[ebp]
  00745	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00748	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0074e	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 6143 : 									thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  00754	68 00 e8 00 00	 push	 59392			; 0000e800H
  00759	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0075c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00762	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  00768	52		 push	 edx
  00769	e8 00 00 00 00	 call	 _FixedMul
  0076e	83 c4 08	 add	 esp, 8
  00771	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  00774	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0077a	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6144 : 									thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  00780	68 00 e8 00 00	 push	 59392			; 0000e800H
  00785	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00788	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0078e	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  00794	52		 push	 edx
  00795	e8 00 00 00 00	 call	 _FixedMul
  0079a	83 c4 08	 add	 esp, 8
  0079d	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  007a0	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  007a6	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN63@T_Scroll:

; 6145 : 								}
; 6146 : 							}
; 6147 : 
; 6148 : 							if (s->exclusive)

  007ac	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  007af	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  007b3	74 15		 je	 SHORT $LN64@T_Scroll

; 6149 : 								thing->flags2 |= MF2_PUSHED;

  007b5	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  007b8	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  007be	83 c9 01	 or	 ecx, 1
  007c1	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  007c4	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN64@T_Scroll:

; 6150 : 						}
; 6151 : 					} // end of for loop through touching_thinglist

  007ca	e9 83 fe ff ff	 jmp	 $LN22@T_Scroll
$LN23@T_Scroll:

; 6152 : 				} // end of loop through sectors

  007cf	e9 3f fe ff ff	 jmp	 $LN19@T_Scroll
$LN20@T_Scroll:

; 6153 : 			}

  007d4	e9 d3 fd ff ff	 jmp	 $LN16@T_Scroll
$LN17@T_Scroll:

; 6154 : 
; 6155 : 			if (!is3dblock)

  007d9	83 7d f4 00	 cmp	 DWORD PTR _is3dblock$[ebp], 0
  007dd	0f 85 93 01 00
	00		 jne	 $LN26@T_Scroll

; 6156 : 			{
; 6157 : 				for (node = sec->touching_thinglist; node; node = node->m_snext)

  007e3	8b 45 e4	 mov	 eax, DWORD PTR _sec$9[ebp]
  007e6	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  007ec	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
  007ef	eb 09		 jmp	 SHORT $LN27@T_Scroll
$LN25@T_Scroll:
  007f1	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  007f4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  007f7	89 4d dc	 mov	 DWORD PTR _node$7[ebp], ecx
$LN27@T_Scroll:
  007fa	83 7d dc 00	 cmp	 DWORD PTR _node$7[ebp], 0
  007fe	0f 84 72 01 00
	00		 je	 $LN26@T_Scroll

; 6158 : 				{
; 6159 : 					thing = node->m_thing;

  00804	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  00807	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0080a	89 4d d8	 mov	 DWORD PTR _thing$6[ebp], ecx

; 6160 : 
; 6161 : 					if (thing->flags2 & MF2_PUSHED)

  0080d	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00810	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00816	83 e1 01	 and	 ecx, 1
  00819	74 02		 je	 SHORT $LN66@T_Scroll

; 6162 : 						continue;

  0081b	eb d4		 jmp	 SHORT $LN25@T_Scroll
$LN66@T_Scroll:

; 6163 : 
; 6164 : 					if (!((thing = node->m_thing)->flags & MF_NOCLIP) &&

  0081d	8b 45 dc	 mov	 eax, DWORD PTR _node$7[ebp]
  00820	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00823	89 4d d8	 mov	 DWORD PTR _thing$6[ebp], ecx
  00826	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  00829	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0082c	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00831	0f 85 3a 01 00
	00		 jne	 $LN71@T_Scroll
  00837	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0083a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0083d	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00843	0f 85 28 01 00
	00		 jne	 $LN71@T_Scroll
  00849	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0084c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0084f	3b 4d e0	 cmp	 ecx, DWORD PTR _height$8[ebp]
  00852	0f 8c 19 01 00
	00		 jl	 $LN71@T_Scroll

; 6165 : 						(!(thing->flags & MF_NOGRAVITY || thing->z < height)))
; 6166 : 					{
; 6167 : 						// Move objects only if on floor or underwater,
; 6168 : 						// non-floating, and clipped.
; 6169 : 						thing->momx += dx;

  00858	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0085b	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0085e	03 4d fc	 add	 ecx, DWORD PTR _dx$[ebp]
  00861	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  00864	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 6170 : 						thing->momy += dy;

  00867	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0086a	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0086d	03 4d f8	 add	 ecx, DWORD PTR _dy$[ebp]
  00870	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  00873	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 6171 : 						if (thing->player)

  00876	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00879	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00880	0f 84 cd 00 00
	00		 je	 $LN70@T_Scroll

; 6172 : 						{
; 6173 : 							if (!(dx | dy))

  00886	8b 45 fc	 mov	 eax, DWORD PTR _dx$[ebp]
  00889	0b 45 f8	 or	 eax, DWORD PTR _dy$[ebp]
  0088c	75 2b		 jne	 SHORT $LN69@T_Scroll

; 6174 : 							{
; 6175 : 								thing->player->cmomx = 0;

  0088e	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00891	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00897	c7 81 3c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+316], 0

; 6176 : 								thing->player->cmomy = 0;

  008a1	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  008a4	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  008aa	c7 81 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+320], 0

; 6177 : 							}

  008b4	e9 9a 00 00 00	 jmp	 $LN70@T_Scroll
$LN69@T_Scroll:

; 6178 : 							else
; 6179 : 							{
; 6180 : 								thing->player->cmomx += dx;

  008b9	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  008bc	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  008c2	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  008c8	03 55 fc	 add	 edx, DWORD PTR _dx$[ebp]
  008cb	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  008ce	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  008d4	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 6181 : 								thing->player->cmomy += dy;

  008da	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  008dd	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  008e3	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  008e9	03 55 f8	 add	 edx, DWORD PTR _dy$[ebp]
  008ec	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  008ef	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  008f5	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 6182 : 								thing->player->cmomx = FixedMul(thing->player->cmomx, 0xe800);

  008fb	68 00 e8 00 00	 push	 59392			; 0000e800H
  00900	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  00903	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00909	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  0090f	52		 push	 edx
  00910	e8 00 00 00 00	 call	 _FixedMul
  00915	83 c4 08	 add	 esp, 8
  00918	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  0091b	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00921	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 6183 : 								thing->player->cmomy = FixedMul(thing->player->cmomy, 0xe800);

  00927	68 00 e8 00 00	 push	 59392			; 0000e800H
  0092c	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0092f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00935	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  0093b	52		 push	 edx
  0093c	e8 00 00 00 00	 call	 _FixedMul
  00941	83 c4 08	 add	 esp, 8
  00944	8b 4d d8	 mov	 ecx, DWORD PTR _thing$6[ebp]
  00947	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0094d	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN70@T_Scroll:

; 6184 : 							}
; 6185 : 						}
; 6186 : 
; 6187 : 						if (s->exclusive)

  00953	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00956	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0095a	74 15		 je	 SHORT $LN71@T_Scroll

; 6188 : 							thing->flags2 |= MF2_PUSHED;

  0095c	8b 45 d8	 mov	 eax, DWORD PTR _thing$6[ebp]
  0095f	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00965	83 c9 01	 or	 ecx, 1
  00968	8b 55 d8	 mov	 edx, DWORD PTR _thing$6[ebp]
  0096b	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx
$LN71@T_Scroll:

; 6189 : 					}
; 6190 : 				}

  00971	e9 7b fe ff ff	 jmp	 $LN25@T_Scroll
$LN26@T_Scroll:
$LN2@T_Scroll:

; 6191 : 			}
; 6192 : 			break; // end of sc_carry_ceiling
; 6193 : 	} // end of switch
; 6194 : }

  00976	5f		 pop	 edi
  00977	5e		 pop	 esi
  00978	5b		 pop	 ebx
  00979	8b e5		 mov	 esp, ebp
  0097b	5d		 pop	 ebp
  0097c	c3		 ret	 0
  0097d	0f 1f 00	 npad	 3
$LN73@T_Scroll:
  00980	00 00 00 00	 DD	 $LN31@T_Scroll
  00984	00 00 00 00	 DD	 $LN32@T_Scroll
  00988	00 00 00 00	 DD	 $LN33@T_Scroll
  0098c	00 00 00 00	 DD	 $LN34@T_Scroll
  00990	00 00 00 00	 DD	 $LN53@T_Scroll
_T_Scroll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _T_ExecutorDelay
_TEXT	SEGMENT
tv66 = -68						; size = 4
_e$ = 8							; size = 4
_T_ExecutorDelay PROC					; COMDAT

; 1276 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1277 : 	if (--e->timer <= 0)

  00009	8b 45 08	 mov	 eax, DWORD PTR _e$[ebp]
  0000c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0000f	83 e9 01	 sub	 ecx, 1
  00012	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _e$[ebp]
  00018	8b 45 bc	 mov	 eax, DWORD PTR tv66[ebp]
  0001b	89 42 18	 mov	 DWORD PTR [edx+24], eax
  0001e	83 7d bc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00022	7f 22		 jg	 SHORT $LN2@T_Executor

; 1278 : 	{
; 1279 : 		P_ProcessLineSpecial(e->line, e->caller);

  00024	8b 45 08	 mov	 eax, DWORD PTR _e$[ebp]
  00027	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _e$[ebp]
  0002e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _P_ProcessLineSpecial
  00037	83 c4 08	 add	 esp, 8

; 1280 : 		P_RemoveThinker(&e->thinker);

  0003a	8b 45 08	 mov	 eax, DWORD PTR _e$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _P_RemoveThinker
  00043	83 c4 04	 add	 esp, 4
$LN2@T_Executor:

; 1281 : 	}
; 1282 : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_T_ExecutorDelay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_ChangeSectorTag
_TEXT	SEGMENT
_i$ = -8						; size = 4
_oldtag$ = -4						; size = 2
_sector$ = 8						; size = 4
_newtag$ = 12						; size = 2
_P_ChangeSectorTag PROC					; COMDAT

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1172 : 	INT16 oldtag;
; 1173 : 	INT32 i;
; 1174 : 
; 1175 : 	I_Assert(sector < numsectors);
; 1176 : 
; 1177 : 	if ((oldtag = sectors[sector].tag) == newtag)

  00009	69 45 08 f8 00
	00 00		 imul	 eax, DWORD PTR _sector$[ebp], 248
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00016	66 8b 54 01 14	 mov	 dx, WORD PTR [ecx+eax+20]
  0001b	66 89 55 fc	 mov	 WORD PTR _oldtag$[ebp], dx
  0001f	0f bf 45 fc	 movsx	 eax, WORD PTR _oldtag$[ebp]
  00023	0f bf 4d 0c	 movsx	 ecx, WORD PTR _newtag$[ebp]
  00027	3b c1		 cmp	 eax, ecx
  00029	75 05		 jne	 SHORT $LN6@P_ChangeSe

; 1178 : 		return;

  0002b	e9 2c 02 00 00	 jmp	 $LN14@P_ChangeSe
$LN6@P_ChangeSe:

; 1179 : 
; 1180 : 	// first you have to remove it from the old tag's taglist
; 1181 : 	i = sectors[(unsigned)oldtag % numsectors].firsttag;

  00030	0f bf 45 fc	 movsx	 eax, WORD PTR _oldtag$[ebp]
  00034	33 d2		 xor	 edx, edx
  00036	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  0003c	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00048	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  0004c	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 1182 : 
; 1183 : 	if (i == -1) // shouldn't happen

  0004f	83 7d f8 ff	 cmp	 DWORD PTR _i$[ebp], -1
  00053	75 16		 jne	 SHORT $LN7@P_ChangeSe

; 1184 : 		I_Error("Corrupt tag list for sector %u\n", sector);

  00055	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EIHMNEPK@Corrupt?5tag?5list?5for?5sector?5?$CFu?6@
  0005e	e8 00 00 00 00	 call	 _I_Error
  00063	83 c4 08	 add	 esp, 8
  00066	e9 98 00 00 00	 jmp	 $LN10@P_ChangeSe
$LN7@P_ChangeSe:

; 1185 : 	else if ((UINT32)i == sector)

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006e	3b 45 08	 cmp	 eax, DWORD PTR _sector$[ebp]
  00071	75 2e		 jne	 SHORT $LN9@P_ChangeSe

; 1186 : 		sectors[(unsigned)oldtag % numsectors].firsttag = sectors[sector].nexttag;

  00073	69 4d 08 f8 00
	00 00		 imul	 ecx, DWORD PTR _sector$[ebp], 248
  0007a	0f bf 45 fc	 movsx	 eax, WORD PTR _oldtag$[ebp]
  0007e	33 d2		 xor	 edx, edx
  00080	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  00086	69 d2 f8 00 00
	00		 imul	 edx, edx, 248
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00091	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  00097	8b 4c 0e 18	 mov	 ecx, DWORD PTR [esi+ecx+24]
  0009b	89 4c 10 1c	 mov	 DWORD PTR [eax+edx+28], ecx
  0009f	eb 62		 jmp	 SHORT $LN10@P_ChangeSe
$LN9@P_ChangeSe:

; 1187 : 	else
; 1188 : 	{
; 1189 : 		while (sectors[i].nexttag != -1 && (UINT32)sectors[i].nexttag < sector )

  000a1	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000ae	83 7c 01 18 ff	 cmp	 DWORD PTR [ecx+eax+24], -1
  000b3	74 2c		 je	 SHORT $LN3@P_ChangeSe
  000b5	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000c2	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  000c6	3b 55 08	 cmp	 edx, DWORD PTR _sector$[ebp]
  000c9	73 16		 jae	 SHORT $LN3@P_ChangeSe

; 1190 : 			i = sectors[i].nexttag;

  000cb	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000d8	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  000dc	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  000df	eb c0		 jmp	 SHORT $LN9@P_ChangeSe
$LN3@P_ChangeSe:

; 1191 : 
; 1192 : 		sectors[i].nexttag = sectors[sector].nexttag;

  000e1	69 45 08 f8 00
	00 00		 imul	 eax, DWORD PTR _sector$[ebp], 248
  000e8	69 4d f8 f8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 248
  000ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  000f5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  000fb	8b 44 06 18	 mov	 eax, DWORD PTR [esi+eax+24]
  000ff	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax
$LN10@P_ChangeSe:

; 1193 : 	}
; 1194 : 
; 1195 : 	sectors[sector].tag = newtag;

  00103	69 45 08 f8 00
	00 00		 imul	 eax, DWORD PTR _sector$[ebp], 248
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00110	66 8b 55 0c	 mov	 dx, WORD PTR _newtag$[ebp]
  00114	66 89 54 01 14	 mov	 WORD PTR [ecx+eax+20], dx

; 1196 : 
; 1197 : 	// now add it to the new tag's taglist
; 1198 : 	if ((UINT32)sectors[(unsigned)newtag % numsectors].firsttag > sector)

  00119	0f bf 45 0c	 movsx	 eax, WORD PTR _newtag$[ebp]
  0011d	33 d2		 xor	 edx, edx
  0011f	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  00125	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00131	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  00135	3b 55 08	 cmp	 edx, DWORD PTR _sector$[ebp]
  00138	76 51		 jbe	 SHORT $LN11@P_ChangeSe

; 1199 : 	{
; 1200 : 		sectors[sector].nexttag = sectors[(unsigned)newtag % numsectors].firsttag;

  0013a	0f bf 45 0c	 movsx	 eax, WORD PTR _newtag$[ebp]
  0013e	33 d2		 xor	 edx, edx
  00140	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  00146	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  0014c	69 4d 08 f8 00
	00 00		 imul	 ecx, DWORD PTR _sector$[ebp], 248
  00153	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00159	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  0015f	8b 44 06 1c	 mov	 eax, DWORD PTR [esi+eax+28]
  00163	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax

; 1201 : 		sectors[(unsigned)newtag % numsectors].firsttag = sector;

  00167	0f bf 45 0c	 movsx	 eax, WORD PTR _newtag$[ebp]
  0016b	33 d2		 xor	 edx, edx
  0016d	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  00173	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  00179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0017f	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00182	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1202 : 	}

  00186	e9 d1 00 00 00	 jmp	 $LN14@P_ChangeSe
$LN11@P_ChangeSe:

; 1203 : 	else
; 1204 : 	{
; 1205 : 		i = sectors[(unsigned)newtag % numsectors].firsttag;

  0018b	0f bf 45 0c	 movsx	 eax, WORD PTR _newtag$[ebp]
  0018f	33 d2		 xor	 edx, edx
  00191	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  00197	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  0019d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  001a3	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  001a7	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 1206 : 
; 1207 : 		if (i == -1)

  001aa	83 7d f8 ff	 cmp	 DWORD PTR _i$[ebp], -1
  001ae	75 36		 jne	 SHORT $LN13@P_ChangeSe

; 1208 : 		{
; 1209 : 			sectors[(unsigned)newtag % numsectors].firsttag = sector;

  001b0	0f bf 45 0c	 movsx	 eax, WORD PTR _newtag$[ebp]
  001b4	33 d2		 xor	 edx, edx
  001b6	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  001bc	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  001c8	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  001cb	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1210 : 			sectors[sector].nexttag = -1;

  001cf	69 45 08 f8 00
	00 00		 imul	 eax, DWORD PTR _sector$[ebp], 248
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  001dc	c7 44 01 18 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+24], -1

; 1211 : 		}

  001e4	eb 76		 jmp	 SHORT $LN14@P_ChangeSe
$LN13@P_ChangeSe:

; 1212 : 		else
; 1213 : 		{
; 1214 : 			while (sectors[i].nexttag != -1 && (UINT32)sectors[i].nexttag < sector )

  001e6	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  001f3	83 7c 01 18 ff	 cmp	 DWORD PTR [ecx+eax+24], -1
  001f8	74 2c		 je	 SHORT $LN5@P_ChangeSe
  001fa	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00201	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00207	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  0020b	3b 55 08	 cmp	 edx, DWORD PTR _sector$[ebp]
  0020e	73 16		 jae	 SHORT $LN5@P_ChangeSe

; 1215 : 				i = sectors[i].nexttag;

  00210	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0021d	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  00221	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  00224	eb c0		 jmp	 SHORT $LN13@P_ChangeSe
$LN5@P_ChangeSe:

; 1216 : 
; 1217 : 			sectors[sector].nexttag = sectors[i].nexttag;

  00226	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0022d	69 4d 08 f8 00
	00 00		 imul	 ecx, DWORD PTR _sector$[ebp], 248
  00234	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0023a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _sectors
  00240	8b 44 06 18	 mov	 eax, DWORD PTR [esi+eax+24]
  00244	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax

; 1218 : 			sectors[i].nexttag = sector;

  00248	69 45 f8 f8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 248
  0024f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00255	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00258	89 54 01 18	 mov	 DWORD PTR [ecx+eax+24], edx
$LN14@P_ChangeSe:

; 1219 : 		}
; 1220 : 	}
; 1221 : }

  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	8b e5		 mov	 esp, ebp
  00261	5d		 pop	 ebp
  00262	c3		 ret	 0
_P_ChangeSectorTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_LinedefExecute
_TEXT	SEGMENT
_vertexei$1 = -72					; size = 4
_vertexei$2 = -68					; size = 4
_masterlineindex$3 = -64				; size = 4
_j$4 = -60						; size = 4
_backwards$5 = -56					; size = 4
_numneeded$6 = -52					; size = 4
_numpush$7 = -48					; size = 4
_mo$8 = -44						; size = 4
_node$9 = -40						; size = 4
_mare$10 = -33						; size = 1
_rings$11 = -32						; size = 4
_specialtype$ = -28					; size = 2
_sectori$ = -24						; size = 4
_linecnt$ = -20						; size = 4
_i$ = -16						; size = 4
_masterline$ = -12					; size = 4
_dist$ = -8						; size = 4
_ctlsector$ = -4					; size = 4
_tag$ = 8						; size = 4
_actor$ = 12						; size = 4
_caller$ = 16						; size = 4
_P_LinedefExecute PROC					; COMDAT

; 1316 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1317 : 	sector_t *ctlsector;
; 1318 : 	fixed_t dist;
; 1319 : 	size_t masterline, i, linecnt, sectori;
; 1320 : 	INT16 specialtype;
; 1321 : 
; 1322 : 	for (masterline = 0; masterline < numlines; masterline++)

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _masterline$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@P_LinedefE
$LN2@P_LinedefE:
  00015	8b 45 f4	 mov	 eax, DWORD PTR _masterline$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f4	 mov	 DWORD PTR _masterline$[ebp], eax
$LN4@P_LinedefE:
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _masterline$[ebp]
  00021	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00027	0f 83 02 09 00
	00		 jae	 $LN3@P_LinedefE

; 1323 : 	{
; 1324 : 		if (lines[masterline].tag != tag)

  0002d	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00037	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  0003c	3b 55 08	 cmp	 edx, DWORD PTR _tag$[ebp]
  0003f	74 02		 je	 SHORT $LN25@P_LinedefE

; 1325 : 			continue;

  00041	eb d2		 jmp	 SHORT $LN2@P_LinedefE
$LN25@P_LinedefE:

; 1326 : 
; 1327 : 		// "No More Enemies" takes care of itself.
; 1328 : 		if (lines[masterline].special == 313
; 1329 : 			// Each-time exectors handle themselves, too
; 1330 : 			|| lines[masterline].special == 301
; 1331 : 			|| lines[masterline].special == 306
; 1332 : 			|| lines[masterline].special == 310
; 1333 : 			|| lines[masterline].special == 312)

  00043	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0004d	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00052	81 fa 39 01 00
	00		 cmp	 edx, 313		; 00000139H
  00058	74 5c		 je	 SHORT $LN27@P_LinedefE
  0005a	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00064	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00069	81 fa 2d 01 00
	00		 cmp	 edx, 301		; 0000012dH
  0006f	74 45		 je	 SHORT $LN27@P_LinedefE
  00071	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0007b	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00080	81 fa 32 01 00
	00		 cmp	 edx, 306		; 00000132H
  00086	74 2e		 je	 SHORT $LN27@P_LinedefE
  00088	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00092	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00097	81 fa 36 01 00
	00		 cmp	 edx, 310		; 00000136H
  0009d	74 17		 je	 SHORT $LN27@P_LinedefE
  0009f	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000a9	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  000ae	81 fa 38 01 00
	00		 cmp	 edx, 312		; 00000138H
  000b4	75 05		 jne	 SHORT $LN26@P_LinedefE
$LN27@P_LinedefE:

; 1334 : 			continue;

  000b6	e9 5a ff ff ff	 jmp	 $LN2@P_LinedefE
$LN26@P_LinedefE:

; 1335 : 
; 1336 : 		if (lines[masterline].special < 300
; 1337 : 			|| lines[masterline].special > 399)

  000bb	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000c5	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  000ca	81 fa 2c 01 00
	00		 cmp	 edx, 300		; 0000012cH
  000d0	7c 17		 jl	 SHORT $LN29@P_LinedefE
  000d2	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000dc	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  000e1	81 fa 8f 01 00
	00		 cmp	 edx, 399		; 0000018fH
  000e7	7e 05		 jle	 SHORT $LN28@P_LinedefE
$LN29@P_LinedefE:

; 1338 : 			continue;

  000e9	e9 27 ff ff ff	 jmp	 $LN2@P_LinedefE
$LN28@P_LinedefE:

; 1339 : 
; 1340 : 		specialtype = lines[masterline].special;

  000ee	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000f8	66 8b 54 01 12	 mov	 dx, WORD PTR [ecx+eax+18]
  000fd	66 89 55 e4	 mov	 WORD PTR _specialtype$[ebp], dx

; 1341 : 
; 1342 : 		// Special handling for some executors
; 1343 : 
; 1344 : 		// Linetypes 303 and 304 require a specific
; 1345 : 		// number, or minimum or maximum, of rings.
; 1346 : 		if (actor && actor->player && (specialtype == 303

  00101	83 7d 0c 00	 cmp	 DWORD PTR _actor$[ebp], 0
  00105	0f 84 35 01 00
	00		 je	 $LN30@P_LinedefE
  0010b	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  0010e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00115	0f 84 25 01 00
	00		 je	 $LN30@P_LinedefE
  0011b	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  0011f	3d 2f 01 00 00	 cmp	 eax, 303		; 0000012fH
  00124	74 0f		 je	 SHORT $LN32@P_LinedefE
  00126	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  0012a	3d 30 01 00 00	 cmp	 eax, 304		; 00000130H
  0012f	0f 85 0b 01 00
	00		 jne	 $LN30@P_LinedefE
$LN32@P_LinedefE:

; 1347 : 			|| specialtype == 304))
; 1348 : 		{
; 1349 : 			fixed_t rings = 0;

  00135	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _rings$11[ebp], 0

; 1350 : 
; 1351 : 			// With the passuse flag, count all player's
; 1352 : 			// rings.
; 1353 : 			if (lines[masterline].flags & ML_EFFECT4)

  0013c	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00146	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0014b	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00151	74 5a		 je	 SHORT $LN33@P_LinedefE

; 1354 : 			{
; 1355 : 				for (i = 0; i < MAXPLAYERS; i++)

  00153	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0015a	eb 09		 jmp	 SHORT $LN7@P_LinedefE
$LN5@P_LinedefE:
  0015c	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_LinedefE:
  00165	83 7d f0 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00169	73 40		 jae	 SHORT $LN6@P_LinedefE

; 1356 : 				{
; 1357 : 					if (!playeringame[i])

  0016b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0016e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00176	75 02		 jne	 SHORT $LN35@P_LinedefE

; 1358 : 						continue;

  00178	eb e2		 jmp	 SHORT $LN5@P_LinedefE
$LN35@P_LinedefE:

; 1359 : 
; 1360 : 					if (!players[i].mo)

  0017a	69 45 f0 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00181	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00188	75 02		 jne	 SHORT $LN36@P_LinedefE

; 1361 : 						continue;

  0018a	eb d0		 jmp	 SHORT $LN5@P_LinedefE
$LN36@P_LinedefE:

; 1362 : 
; 1363 : 					rings += players[i].mo->health-1;

  0018c	69 45 f0 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00193	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00199	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0019f	8b 45 e0	 mov	 eax, DWORD PTR _rings$11[ebp]
  001a2	8d 4c 10 ff	 lea	 ecx, DWORD PTR [eax+edx-1]
  001a6	89 4d e0	 mov	 DWORD PTR _rings$11[ebp], ecx

; 1364 : 				}

  001a9	eb b1		 jmp	 SHORT $LN5@P_LinedefE
$LN6@P_LinedefE:

; 1365 : 			}

  001ab	eb 0f		 jmp	 SHORT $LN34@P_LinedefE
$LN33@P_LinedefE:

; 1366 : 			else
; 1367 : 				rings = actor->health-1;

  001ad	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  001b0	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  001b6	83 e9 01	 sub	 ecx, 1
  001b9	89 4d e0	 mov	 DWORD PTR _rings$11[ebp], ecx
$LN34@P_LinedefE:

; 1368 : 
; 1369 : 			dist = P_AproxDistance(lines[masterline].dx, lines[masterline].dy)>>FRACBITS;

  001bc	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  001c6	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  001ca	52		 push	 edx
  001cb	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  001d5	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  001d9	52		 push	 edx
  001da	e8 00 00 00 00	 call	 _P_AproxDistance
  001df	83 c4 08	 add	 esp, 8
  001e2	c1 f8 10	 sar	 eax, 16			; 00000010H
  001e5	89 45 f8	 mov	 DWORD PTR _dist$[ebp], eax

; 1370 : 
; 1371 : 			if (lines[masterline].flags & ML_NOCLIMB)

  001e8	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  001ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  001f2	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  001f7	83 e2 40	 and	 edx, 64			; 00000040H
  001fa	74 0f		 je	 SHORT $LN37@P_LinedefE

; 1372 : 			{
; 1373 : 				if (rings > dist)

  001fc	8b 45 e0	 mov	 eax, DWORD PTR _rings$11[ebp]
  001ff	3b 45 f8	 cmp	 eax, DWORD PTR _dist$[ebp]
  00202	7e 05		 jle	 SHORT $LN39@P_LinedefE

; 1374 : 					return;

  00204	e9 26 07 00 00	 jmp	 $LN3@P_LinedefE
$LN39@P_LinedefE:

; 1375 : 			}

  00209	eb 30		 jmp	 SHORT $LN43@P_LinedefE
$LN37@P_LinedefE:

; 1376 : 			else if (lines[masterline].flags & ML_BLOCKMONSTERS)

  0020b	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0020f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00215	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0021a	83 e2 02	 and	 edx, 2
  0021d	74 0f		 je	 SHORT $LN40@P_LinedefE

; 1377 : 			{
; 1378 : 				if (rings < dist)

  0021f	8b 45 e0	 mov	 eax, DWORD PTR _rings$11[ebp]
  00222	3b 45 f8	 cmp	 eax, DWORD PTR _dist$[ebp]
  00225	7d 05		 jge	 SHORT $LN42@P_LinedefE

; 1379 : 					return;

  00227	e9 03 07 00 00	 jmp	 $LN3@P_LinedefE
$LN42@P_LinedefE:

; 1380 : 			}

  0022c	eb 0d		 jmp	 SHORT $LN43@P_LinedefE
$LN40@P_LinedefE:

; 1381 : 			else
; 1382 : 			{
; 1383 : 				if (rings != dist)

  0022e	8b 45 e0	 mov	 eax, DWORD PTR _rings$11[ebp]
  00231	3b 45 f8	 cmp	 eax, DWORD PTR _dist$[ebp]
  00234	74 05		 je	 SHORT $LN43@P_LinedefE

; 1384 : 					return;

  00236	e9 f4 06 00 00	 jmp	 $LN3@P_LinedefE
$LN43@P_LinedefE:

; 1385 : 			}
; 1386 : 		}

  0023b	e9 c7 01 00 00	 jmp	 $LN65@P_LinedefE
$LN30@P_LinedefE:

; 1387 : 		else if (caller)

  00240	83 7d 10 00	 cmp	 DWORD PTR _caller$[ebp], 0
  00244	0f 84 bd 01 00
	00		 je	 $LN65@P_LinedefE

; 1388 : 		{
; 1389 : 			if (GETSECSPECIAL(caller->special, 2) == 6)

  0024a	8b 45 10	 mov	 eax, DWORD PTR _caller$[ebp]
  0024d	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00251	c1 f9 04	 sar	 ecx, 4
  00254	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00257	83 f9 06	 cmp	 ecx, 6
  0025a	75 19		 jne	 SHORT $LN45@P_LinedefE

; 1390 : 			{
; 1391 : 				if (!(ALL7EMERALDS(emeralds)))

  0025c	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  00263	83 e0 7f	 and	 eax, 127		; 0000007fH
  00266	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00269	74 05		 je	 SHORT $LN47@P_LinedefE

; 1392 : 					return;

  0026b	e9 bf 06 00 00	 jmp	 $LN3@P_LinedefE
$LN47@P_LinedefE:

; 1393 : 			}

  00270	e9 b1 00 00 00	 jmp	 $LN56@P_LinedefE
$LN45@P_LinedefE:

; 1394 : 			else if (GETSECSPECIAL(caller->special, 2) == 7)

  00275	8b 45 10	 mov	 eax, DWORD PTR _caller$[ebp]
  00278	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0027c	c1 f9 04	 sar	 ecx, 4
  0027f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00282	83 f9 07	 cmp	 ecx, 7
  00285	0f 85 9b 00 00
	00		 jne	 $LN56@P_LinedefE

; 1395 : 			{
; 1396 : 				UINT8 mare;
; 1397 : 
; 1398 : 				if (!(maptol & TOL_NIGHTS))

  0028b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  00292	83 e0 40	 and	 eax, 64			; 00000040H
  00295	75 05		 jne	 SHORT $LN49@P_LinedefE

; 1399 : 					return;

  00297	e9 93 06 00 00	 jmp	 $LN3@P_LinedefE
$LN49@P_LinedefE:

; 1400 : 
; 1401 : 				dist = P_AproxDistance(lines[masterline].dx, lines[masterline].dy)>>FRACBITS;

  0029c	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  002a6	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  002aa	52		 push	 edx
  002ab	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  002af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  002b5	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  002b9	52		 push	 edx
  002ba	e8 00 00 00 00	 call	 _P_AproxDistance
  002bf	83 c4 08	 add	 esp, 8
  002c2	c1 f8 10	 sar	 eax, 16			; 00000010H
  002c5	89 45 f8	 mov	 DWORD PTR _dist$[ebp], eax

; 1402 : 				mare = P_FindLowestMare();

  002c8	e8 00 00 00 00	 call	 _P_FindLowestMare
  002cd	88 45 df	 mov	 BYTE PTR _mare$10[ebp], al

; 1403 : 
; 1404 : 				if (lines[masterline].flags & ML_NOCLIMB)

  002d0	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  002d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  002da	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  002df	83 e2 40	 and	 edx, 64			; 00000040H
  002e2	74 10		 je	 SHORT $LN50@P_LinedefE

; 1405 : 				{
; 1406 : 					if (!(mare <= dist))

  002e4	0f b6 45 df	 movzx	 eax, BYTE PTR _mare$10[ebp]
  002e8	3b 45 f8	 cmp	 eax, DWORD PTR _dist$[ebp]
  002eb	7e 05		 jle	 SHORT $LN52@P_LinedefE

; 1407 : 						return;

  002ed	e9 3d 06 00 00	 jmp	 $LN3@P_LinedefE
$LN52@P_LinedefE:

; 1408 : 				}

  002f2	eb 32		 jmp	 SHORT $LN56@P_LinedefE
$LN50@P_LinedefE:

; 1409 : 				else if (lines[masterline].flags & ML_BLOCKMONSTERS)

  002f4	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  002f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  002fe	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00303	83 e2 02	 and	 edx, 2
  00306	74 10		 je	 SHORT $LN53@P_LinedefE

; 1410 : 				{
; 1411 : 					if (!(mare >= dist))

  00308	0f b6 45 df	 movzx	 eax, BYTE PTR _mare$10[ebp]
  0030c	3b 45 f8	 cmp	 eax, DWORD PTR _dist$[ebp]
  0030f	7d 05		 jge	 SHORT $LN55@P_LinedefE

; 1412 : 						return;

  00311	e9 19 06 00 00	 jmp	 $LN3@P_LinedefE
$LN55@P_LinedefE:

; 1413 : 				}

  00316	eb 0e		 jmp	 SHORT $LN56@P_LinedefE
$LN53@P_LinedefE:

; 1414 : 				else
; 1415 : 				{
; 1416 : 					if (!(mare == dist))

  00318	0f b6 45 df	 movzx	 eax, BYTE PTR _mare$10[ebp]
  0031c	3b 45 f8	 cmp	 eax, DWORD PTR _dist$[ebp]
  0031f	74 05		 je	 SHORT $LN56@P_LinedefE

; 1417 : 						return;

  00321	e9 09 06 00 00	 jmp	 $LN3@P_LinedefE
$LN56@P_LinedefE:

; 1418 : 				}
; 1419 : 			}
; 1420 : 
; 1421 : 			if (specialtype >= 314 && specialtype <= 315)

  00326	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  0032a	3d 3a 01 00 00	 cmp	 eax, 314		; 0000013aH
  0032f	0f 8c d2 00 00
	00		 jl	 $LN65@P_LinedefE
  00335	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  00339	3d 3b 01 00 00	 cmp	 eax, 315		; 0000013bH
  0033e	0f 8f c3 00 00
	00		 jg	 $LN65@P_LinedefE

; 1422 : 			{
; 1423 : 				msecnode_t *node;
; 1424 : 				mobj_t *mo;
; 1425 : 				INT32 numpush = 0;

  00344	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _numpush$7[ebp], 0

; 1426 : 				INT32 numneeded = P_AproxDistance(lines[masterline].dx, lines[masterline].dy)>>FRACBITS;

  0034b	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0034f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00355	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00359	52		 push	 edx
  0035a	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0035e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00364	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00368	52		 push	 edx
  00369	e8 00 00 00 00	 call	 _P_AproxDistance
  0036e	83 c4 08	 add	 esp, 8
  00371	c1 f8 10	 sar	 eax, 16			; 00000010H
  00374	89 45 cc	 mov	 DWORD PTR _numneeded$6[ebp], eax

; 1427 : 
; 1428 : 				// Count the pushables in this sector
; 1429 : 				node = caller->touching_thinglist; // things touching this sector

  00377	8b 45 10	 mov	 eax, DWORD PTR _caller$[ebp]
  0037a	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00380	89 4d d8	 mov	 DWORD PTR _node$9[ebp], ecx
$LN8@P_LinedefE:

; 1430 : 				while (node)

  00383	83 7d d8 00	 cmp	 DWORD PTR _node$9[ebp], 0
  00387	74 28		 je	 SHORT $LN9@P_LinedefE

; 1431 : 				{
; 1432 : 					mo = node->m_thing;

  00389	8b 45 d8	 mov	 eax, DWORD PTR _node$9[ebp]
  0038c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0038f	89 4d d4	 mov	 DWORD PTR _mo$8[ebp], ecx

; 1433 : 					if (mo->flags & MF_PUSHABLE)

  00392	8b 45 d4	 mov	 eax, DWORD PTR _mo$8[ebp]
  00395	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00398	83 e1 40	 and	 ecx, 64			; 00000040H
  0039b	74 09		 je	 SHORT $LN58@P_LinedefE

; 1434 : 						numpush++;

  0039d	8b 45 d0	 mov	 eax, DWORD PTR _numpush$7[ebp]
  003a0	83 c0 01	 add	 eax, 1
  003a3	89 45 d0	 mov	 DWORD PTR _numpush$7[ebp], eax
$LN58@P_LinedefE:

; 1435 : 					node = node->m_snext;

  003a6	8b 45 d8	 mov	 eax, DWORD PTR _node$9[ebp]
  003a9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003ac	89 4d d8	 mov	 DWORD PTR _node$9[ebp], ecx

; 1436 : 				}

  003af	eb d2		 jmp	 SHORT $LN8@P_LinedefE
$LN9@P_LinedefE:

; 1437 : 
; 1438 : 				if (lines[masterline].flags & ML_NOCLIMB) // Need at least or more

  003b1	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  003b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  003bb	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  003c0	83 e2 40	 and	 edx, 64			; 00000040H
  003c3	74 0f		 je	 SHORT $LN59@P_LinedefE

; 1439 : 				{
; 1440 : 					if (numpush < numneeded)

  003c5	8b 45 d0	 mov	 eax, DWORD PTR _numpush$7[ebp]
  003c8	3b 45 cc	 cmp	 eax, DWORD PTR _numneeded$6[ebp]
  003cb	7d 05		 jge	 SHORT $LN61@P_LinedefE

; 1441 : 						return;

  003cd	e9 5d 05 00 00	 jmp	 $LN3@P_LinedefE
$LN61@P_LinedefE:

; 1442 : 				}

  003d2	eb 33		 jmp	 SHORT $LN65@P_LinedefE
$LN59@P_LinedefE:

; 1443 : 				else if (lines[masterline].flags & ML_EFFECT4) // Need less than

  003d4	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  003d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  003de	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  003e3	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  003e9	74 0f		 je	 SHORT $LN62@P_LinedefE

; 1444 : 				{
; 1445 : 					if (numpush >= numneeded)

  003eb	8b 45 d0	 mov	 eax, DWORD PTR _numpush$7[ebp]
  003ee	3b 45 cc	 cmp	 eax, DWORD PTR _numneeded$6[ebp]
  003f1	7c 05		 jl	 SHORT $LN64@P_LinedefE

; 1446 : 						return;

  003f3	e9 37 05 00 00	 jmp	 $LN3@P_LinedefE
$LN64@P_LinedefE:

; 1447 : 				}

  003f8	eb 0d		 jmp	 SHORT $LN65@P_LinedefE
$LN62@P_LinedefE:

; 1448 : 				else // Need exact
; 1449 : 				{
; 1450 : 					if (numpush != numneeded)

  003fa	8b 45 d0	 mov	 eax, DWORD PTR _numpush$7[ebp]
  003fd	3b 45 cc	 cmp	 eax, DWORD PTR _numneeded$6[ebp]
  00400	74 05		 je	 SHORT $LN65@P_LinedefE

; 1451 : 						return;

  00402	e9 28 05 00 00	 jmp	 $LN3@P_LinedefE
$LN65@P_LinedefE:

; 1452 : 				}
; 1453 : 			}
; 1454 : 		}
; 1455 : 
; 1456 : 		if (specialtype >= 305 && specialtype <= 307)

  00407	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  0040b	3d 31 01 00 00	 cmp	 eax, 305		; 00000131H
  00410	7c 6e		 jl	 SHORT $LN69@P_LinedefE
  00412	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  00416	3d 33 01 00 00	 cmp	 eax, 307		; 00000133H
  0041b	7f 63		 jg	 SHORT $LN69@P_LinedefE

; 1457 : 		{
; 1458 : 			if (!actor)

  0041d	83 7d 0c 00	 cmp	 DWORD PTR _actor$[ebp], 0
  00421	75 05		 jne	 SHORT $LN67@P_LinedefE

; 1459 : 				return;

  00423	e9 07 05 00 00	 jmp	 $LN3@P_LinedefE
$LN67@P_LinedefE:

; 1460 : 
; 1461 : 			if (!actor->player)

  00428	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  0042b	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00432	75 05		 jne	 SHORT $LN68@P_LinedefE

; 1462 : 				return;

  00434	e9 f6 04 00 00	 jmp	 $LN3@P_LinedefE
$LN68@P_LinedefE:

; 1463 : 
; 1464 : 			if (actor->player->charability != (P_AproxDistance(lines[masterline].dx, lines[masterline].dy)>>FRACBITS)/10)

  00439	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  0043c	8b b0 a4 00 00
	00		 mov	 esi, DWORD PTR [eax+164]
  00442	6b 4d f4 4c	 imul	 ecx, DWORD PTR _masterline$[ebp], 76
  00446	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0044c	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00450	50		 push	 eax
  00451	6b 4d f4 4c	 imul	 ecx, DWORD PTR _masterline$[ebp], 76
  00455	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0045b	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  0045f	50		 push	 eax
  00460	e8 00 00 00 00	 call	 _P_AproxDistance
  00465	83 c4 08	 add	 esp, 8
  00468	c1 f8 10	 sar	 eax, 16			; 00000010H
  0046b	99		 cdq
  0046c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00471	f7 f9		 idiv	 ecx
  00473	39 86 d8 00 00
	00		 cmp	 DWORD PTR [esi+216], eax
  00479	74 05		 je	 SHORT $LN69@P_LinedefE

; 1465 : 				return;

  0047b	e9 af 04 00 00	 jmp	 $LN3@P_LinedefE
$LN69@P_LinedefE:

; 1466 : 		}
; 1467 : 
; 1468 : 		// Only red team members can activate this.
; 1469 : 		if ((specialtype == 309 || specialtype == 310)
; 1470 : 			&& !(actor && actor->player && actor->player->ctfteam == 1))

  00480	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  00484	3d 35 01 00 00	 cmp	 eax, 309		; 00000135H
  00489	74 0b		 je	 SHORT $LN71@P_LinedefE
  0048b	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  0048f	3d 36 01 00 00	 cmp	 eax, 310		; 00000136H
  00494	75 29		 jne	 SHORT $LN70@P_LinedefE
$LN71@P_LinedefE:
  00496	83 7d 0c 00	 cmp	 DWORD PTR _actor$[ebp], 0
  0049a	74 1e		 je	 SHORT $LN72@P_LinedefE
  0049c	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  0049f	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  004a6	74 12		 je	 SHORT $LN72@P_LinedefE
  004a8	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  004ab	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004b1	83 b9 60 01 00
	00 01		 cmp	 DWORD PTR [ecx+352], 1
  004b8	74 05		 je	 SHORT $LN70@P_LinedefE
$LN72@P_LinedefE:

; 1471 : 			return;

  004ba	e9 70 04 00 00	 jmp	 $LN3@P_LinedefE
$LN70@P_LinedefE:

; 1472 : 
; 1473 : 		// Only blue team members can activate this.
; 1474 : 		if ((specialtype == 311 || specialtype == 312)
; 1475 : 			&& !(actor && actor->player && actor->player->ctfteam == 2))

  004bf	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  004c3	3d 37 01 00 00	 cmp	 eax, 311		; 00000137H
  004c8	74 0b		 je	 SHORT $LN74@P_LinedefE
  004ca	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  004ce	3d 38 01 00 00	 cmp	 eax, 312		; 00000138H
  004d3	75 29		 jne	 SHORT $LN73@P_LinedefE
$LN74@P_LinedefE:
  004d5	83 7d 0c 00	 cmp	 DWORD PTR _actor$[ebp], 0
  004d9	74 1e		 je	 SHORT $LN75@P_LinedefE
  004db	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  004de	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  004e5	74 12		 je	 SHORT $LN75@P_LinedefE
  004e7	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  004ea	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004f0	83 b9 60 01 00
	00 02		 cmp	 DWORD PTR [ecx+352], 2
  004f7	74 05		 je	 SHORT $LN73@P_LinedefE
$LN75@P_LinedefE:

; 1476 : 			return;

  004f9	e9 31 04 00 00	 jmp	 $LN3@P_LinedefE
$LN73@P_LinedefE:

; 1477 : 
; 1478 : 		triplinecaller = caller;

  004fe	8b 45 10	 mov	 eax, DWORD PTR _caller$[ebp]
  00501	a3 00 00 00 00	 mov	 DWORD PTR _triplinecaller, eax

; 1479 : 		ctlsector = lines[masterline].frontsector;

  00506	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0050a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00510	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00514	89 55 fc	 mov	 DWORD PTR _ctlsector$[ebp], edx

; 1480 : 		sectori = (size_t)(ctlsector - sectors);

  00517	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0051a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00520	99		 cdq
  00521	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00526	f7 f9		 idiv	 ecx
  00528	89 45 e8	 mov	 DWORD PTR _sectori$[ebp], eax

; 1481 : 		linecnt = ctlsector->linecount;

  0052b	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0052e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00534	89 4d ec	 mov	 DWORD PTR _linecnt$[ebp], ecx

; 1482 : 
; 1483 : 		if (lines[masterline].flags & ML_EFFECT5) // disregard order for efficiency

  00537	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0053b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00541	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00546	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  0054c	0f 84 b0 00 00
	00		 je	 $LN76@P_LinedefE

; 1484 : 		{
; 1485 : 			for (i = 0; i < linecnt; i++)

  00552	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00559	eb 09		 jmp	 SHORT $LN12@P_LinedefE
$LN10@P_LinedefE:
  0055b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0055e	83 c0 01	 add	 eax, 1
  00561	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN12@P_LinedefE:
  00564	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00567	3b 45 ec	 cmp	 eax, DWORD PTR _linecnt$[ebp]
  0056a	0f 83 8d 00 00
	00		 jae	 $LN11@P_LinedefE

; 1486 : 				if (ctlsector->lines[i]->special >= 400
; 1487 : 					&& ctlsector->lines[i]->special < 500)

  00570	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00573	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00579	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0057c	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0057f	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00583	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  00589	7c 6d		 jl	 SHORT $LN80@P_LinedefE
  0058b	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0058e	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00594	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00597	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0059a	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0059e	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  005a4	7d 52		 jge	 SHORT $LN80@P_LinedefE

; 1488 : 				{
; 1489 : 					if (ctlsector->lines[i]->flags & ML_DONTPEGTOP)

  005a6	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  005a9	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  005af	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  005b2	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  005b5	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  005b9	83 e1 08	 and	 ecx, 8
  005bc	74 1e		 je	 SHORT $LN79@P_LinedefE

; 1490 : 						P_AddExecutorDelay(ctlsector->lines[i], actor);

  005be	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  005c1	50		 push	 eax
  005c2	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  005c5	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  005cb	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  005ce	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  005d1	51		 push	 ecx
  005d2	e8 00 00 00 00	 call	 _P_AddExecutorDelay
  005d7	83 c4 08	 add	 esp, 8
  005da	eb 1c		 jmp	 SHORT $LN80@P_LinedefE
$LN79@P_LinedefE:

; 1491 : 					else
; 1492 : 						P_ProcessLineSpecial(ctlsector->lines[i], actor);

  005dc	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  005df	50		 push	 eax
  005e0	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  005e3	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  005e9	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  005ec	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  005ef	51		 push	 ecx
  005f0	e8 00 00 00 00	 call	 _P_ProcessLineSpecial
  005f5	83 c4 08	 add	 esp, 8
$LN80@P_LinedefE:

; 1493 : 				}

  005f8	e9 5e ff ff ff	 jmp	 $LN10@P_LinedefE
$LN11@P_LinedefE:

; 1494 : 		}

  005fd	e9 e0 02 00 00	 jmp	 $LN17@P_LinedefE
$LN76@P_LinedefE:

; 1495 : 		else // walk around the sector in a defined order
; 1496 : 		{
; 1497 : 			boolean backwards = false;

  00602	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _backwards$5[ebp], 0

; 1498 : 			size_t j, masterlineindex = (size_t)-1;

  00609	c7 45 c0 ff ff
	ff ff		 mov	 DWORD PTR _masterlineindex$3[ebp], -1

; 1499 : 
; 1500 : 			for (i = 0; i < linecnt; i++)

  00610	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00617	eb 09		 jmp	 SHORT $LN15@P_LinedefE
$LN13@P_LinedefE:
  00619	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0061c	83 c0 01	 add	 eax, 1
  0061f	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN15@P_LinedefE:
  00622	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00625	3b 45 ec	 cmp	 eax, DWORD PTR _linecnt$[ebp]
  00628	73 25		 jae	 SHORT $LN14@P_LinedefE

; 1501 : 				if (ctlsector->lines[i] == &lines[masterline])

  0062a	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0062d	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00633	6b 55 f4 4c	 imul	 edx, DWORD PTR _masterline$[ebp], 76
  00637	03 15 00 00 00
	00		 add	 edx, DWORD PTR _lines
  0063d	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00640	39 14 81	 cmp	 DWORD PTR [ecx+eax*4], edx
  00643	75 08		 jne	 SHORT $LN81@P_LinedefE

; 1502 : 				{
; 1503 : 					masterlineindex = i;

  00645	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00648	89 45 c0	 mov	 DWORD PTR _masterlineindex$3[ebp], eax

; 1504 : 					break;

  0064b	eb 02		 jmp	 SHORT $LN14@P_LinedefE
$LN81@P_LinedefE:

; 1505 : 				}

  0064d	eb ca		 jmp	 SHORT $LN13@P_LinedefE
$LN14@P_LinedefE:
$LN16@P_LinedefE:

; 1506 : 
; 1507 : #ifdef PARANOIA
; 1508 : 			if (masterlineindex == (size_t)-1)
; 1509 : 			{
; 1510 : 				const size_t li = (size_t)(ctlsector->lines[i] - lines);
; 1511 : 				I_Error("Line %"PRIdS" isn't linked into its front sector", li);
; 1512 : 			}
; 1513 : #endif
; 1514 : 
; 1515 : 			// i == masterlineindex
; 1516 : 			for (;;)
; 1517 : 			{
; 1518 : 				if (backwards) // v2 to v1

  0064f	83 7d c8 00	 cmp	 DWORD PTR _backwards$5[ebp], 0
  00653	0f 84 f8 00 00
	00		 je	 $LN82@P_LinedefE

; 1519 : 				{
; 1520 : 					for (j = 0; j < linecnt; j++)

  00659	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _j$4[ebp], 0
  00660	eb 09		 jmp	 SHORT $LN21@P_LinedefE
$LN19@P_LinedefE:
  00662	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  00665	83 c0 01	 add	 eax, 1
  00668	89 45 c4	 mov	 DWORD PTR _j$4[ebp], eax
$LN21@P_LinedefE:
  0066b	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  0066e	3b 45 ec	 cmp	 eax, DWORD PTR _linecnt$[ebp]
  00671	73 6c		 jae	 SHORT $LN20@P_LinedefE

; 1521 : 					{
; 1522 : 						if (i == j)

  00673	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00676	3b 45 c4	 cmp	 eax, DWORD PTR _j$4[ebp]
  00679	75 02		 jne	 SHORT $LN84@P_LinedefE

; 1523 : 							continue;

  0067b	eb e5		 jmp	 SHORT $LN19@P_LinedefE
$LN84@P_LinedefE:

; 1524 : 						if (ctlsector->lines[i]->v1 == ctlsector->lines[j]->v2)

  0067d	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00680	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00686	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00689	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0068c	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  0068f	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00695	8b 4d c4	 mov	 ecx, DWORD PTR _j$4[ebp]
  00698	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  0069b	8b 00		 mov	 eax, DWORD PTR [eax]
  0069d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  006a0	75 08		 jne	 SHORT $LN85@P_LinedefE

; 1525 : 						{
; 1526 : 							i = j;

  006a2	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  006a5	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 1527 : 							break;

  006a8	eb 35		 jmp	 SHORT $LN20@P_LinedefE
$LN85@P_LinedefE:

; 1528 : 						}
; 1529 : 						if (ctlsector->lines[i]->v1 == ctlsector->lines[j]->v1)

  006aa	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  006ad	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  006b3	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  006b6	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  006b9	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  006bc	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  006c2	8b 4d c4	 mov	 ecx, DWORD PTR _j$4[ebp]
  006c5	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  006c8	8b 00		 mov	 eax, DWORD PTR [eax]
  006ca	3b 02		 cmp	 eax, DWORD PTR [edx]
  006cc	75 0f		 jne	 SHORT $LN86@P_LinedefE

; 1530 : 						{
; 1531 : 							i = j;

  006ce	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  006d1	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 1532 : 							backwards = false;

  006d4	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _backwards$5[ebp], 0

; 1533 : 							break;

  006db	eb 02		 jmp	 SHORT $LN20@P_LinedefE
$LN86@P_LinedefE:

; 1534 : 						}
; 1535 : 					}

  006dd	eb 83		 jmp	 SHORT $LN19@P_LinedefE
$LN20@P_LinedefE:

; 1536 : 					if (j == linecnt)

  006df	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  006e2	3b 45 ec	 cmp	 eax, DWORD PTR _linecnt$[ebp]
  006e5	75 65		 jne	 SHORT $LN87@P_LinedefE

; 1537 : 					{
; 1538 : 						const size_t vertexei = (size_t)(ctlsector->lines[i]->v1 - vertexes);

  006e7	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  006ea	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  006f0	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  006f3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  006f6	8b 00		 mov	 eax, DWORD PTR [eax]
  006f8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _vertexes
  006fe	99		 cdq
  006ff	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00704	f7 f9		 idiv	 ecx
  00706	89 45 bc	 mov	 DWORD PTR _vertexei$2[ebp], eax

; 1539 : 						CONS_Printf("Warning: Sector %"PRIdS" is not closed at vertex %"PRIdS" (%d, %d)\n",

  00709	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0070c	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00712	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00715	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00718	8b 08		 mov	 ecx, DWORD PTR [eax]
  0071a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0071d	52		 push	 edx
  0071e	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00721	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00727	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0072a	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0072d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0072f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00731	52		 push	 edx
  00732	8b 45 bc	 mov	 eax, DWORD PTR _vertexei$2[ebp]
  00735	50		 push	 eax
  00736	8b 4d e8	 mov	 ecx, DWORD PTR _sectori$[ebp]
  00739	51		 push	 ecx
  0073a	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HMODDHIJ@Warning?3?5Sector?5?$CFIu?5is?5not?5clos@
  0073f	e8 00 00 00 00	 call	 _CONS_Printf
  00744	83 c4 14	 add	 esp, 20			; 00000014H

; 1540 : 							sectori, vertexei,
; 1541 : 							ctlsector->lines[i]->v1->x, ctlsector->lines[i]->v1->y);
; 1542 : 						return; // abort

  00747	e9 e3 01 00 00	 jmp	 $LN3@P_LinedefE
$LN87@P_LinedefE:

; 1543 : 					}
; 1544 : 				}

  0074c	e9 f7 00 00 00	 jmp	 $LN91@P_LinedefE
$LN82@P_LinedefE:

; 1545 : 				else // v1 to v2
; 1546 : 				{
; 1547 : 					for (j = 0; j < linecnt; j++)

  00751	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _j$4[ebp], 0
  00758	eb 09		 jmp	 SHORT $LN24@P_LinedefE
$LN22@P_LinedefE:
  0075a	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  0075d	83 c0 01	 add	 eax, 1
  00760	89 45 c4	 mov	 DWORD PTR _j$4[ebp], eax
$LN24@P_LinedefE:
  00763	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  00766	3b 45 ec	 cmp	 eax, DWORD PTR _linecnt$[ebp]
  00769	73 6e		 jae	 SHORT $LN23@P_LinedefE

; 1548 : 					{
; 1549 : 						if (i == j)

  0076b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0076e	3b 45 c4	 cmp	 eax, DWORD PTR _j$4[ebp]
  00771	75 02		 jne	 SHORT $LN88@P_LinedefE

; 1550 : 							continue;

  00773	eb e5		 jmp	 SHORT $LN22@P_LinedefE
$LN88@P_LinedefE:

; 1551 : 						if (ctlsector->lines[i]->v2 == ctlsector->lines[j]->v1)

  00775	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00778	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0077e	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00781	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00784	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  00787	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0078d	8b 4d c4	 mov	 ecx, DWORD PTR _j$4[ebp]
  00790	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  00793	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00796	3b 02		 cmp	 eax, DWORD PTR [edx]
  00798	75 08		 jne	 SHORT $LN89@P_LinedefE

; 1552 : 						{
; 1553 : 							i = j;

  0079a	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  0079d	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 1554 : 							break;

  007a0	eb 37		 jmp	 SHORT $LN23@P_LinedefE
$LN89@P_LinedefE:

; 1555 : 						}
; 1556 : 						if (ctlsector->lines[i]->v2 == ctlsector->lines[j]->v2)

  007a2	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  007a5	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  007ab	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  007ae	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  007b1	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  007b4	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  007ba	8b 4d c4	 mov	 ecx, DWORD PTR _j$4[ebp]
  007bd	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  007c0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  007c3	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  007c6	75 0f		 jne	 SHORT $LN90@P_LinedefE

; 1557 : 						{
; 1558 : 							i = j;

  007c8	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  007cb	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 1559 : 							backwards = true;

  007ce	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _backwards$5[ebp], 1

; 1560 : 							break;

  007d5	eb 02		 jmp	 SHORT $LN23@P_LinedefE
$LN90@P_LinedefE:

; 1561 : 						}
; 1562 : 					}

  007d7	eb 81		 jmp	 SHORT $LN22@P_LinedefE
$LN23@P_LinedefE:

; 1563 : 					if (j == linecnt)

  007d9	8b 45 c4	 mov	 eax, DWORD PTR _j$4[ebp]
  007dc	3b 45 ec	 cmp	 eax, DWORD PTR _linecnt$[ebp]
  007df	75 67		 jne	 SHORT $LN91@P_LinedefE

; 1564 : 					{
; 1565 : 						const size_t vertexei = (size_t)(ctlsector->lines[i]->v1 - vertexes);

  007e1	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  007e4	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  007ea	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  007ed	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  007f0	8b 00		 mov	 eax, DWORD PTR [eax]
  007f2	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _vertexes
  007f8	99		 cdq
  007f9	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  007fe	f7 f9		 idiv	 ecx
  00800	89 45 b8	 mov	 DWORD PTR _vertexei$1[ebp], eax

; 1566 : 						CONS_Printf("Warning: Sector %"PRIdS" is not closed at vertex %"PRIdS" (%d, %d)\n",

  00803	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00806	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0080c	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0080f	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00812	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00815	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00818	52		 push	 edx
  00819	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0081c	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00822	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00825	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00828	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0082b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0082d	52		 push	 edx
  0082e	8b 45 b8	 mov	 eax, DWORD PTR _vertexei$1[ebp]
  00831	50		 push	 eax
  00832	8b 4d e8	 mov	 ecx, DWORD PTR _sectori$[ebp]
  00835	51		 push	 ecx
  00836	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HMODDHIJ@Warning?3?5Sector?5?$CFIu?5is?5not?5clos@
  0083b	e8 00 00 00 00	 call	 _CONS_Printf
  00840	83 c4 14	 add	 esp, 20			; 00000014H

; 1567 : 							sectori, vertexei,
; 1568 : 							ctlsector->lines[i]->v2->x, ctlsector->lines[i]->v2->y);
; 1569 : 						return; // abort

  00843	e9 e7 00 00 00	 jmp	 $LN3@P_LinedefE
$LN91@P_LinedefE:

; 1570 : 					}
; 1571 : 				}
; 1572 : 
; 1573 : 				if (i == masterlineindex)

  00848	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0084b	3b 45 c0	 cmp	 eax, DWORD PTR _masterlineindex$3[ebp]
  0084e	75 05		 jne	 SHORT $LN92@P_LinedefE

; 1574 : 					break;

  00850	e9 8d 00 00 00	 jmp	 $LN17@P_LinedefE
$LN92@P_LinedefE:

; 1575 : 
; 1576 : 				if (ctlsector->lines[i]->special >= 400
; 1577 : 					&& ctlsector->lines[i]->special < 500)

  00855	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00858	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0085e	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00861	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00864	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00868	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  0086e	7c 6d		 jl	 SHORT $LN95@P_LinedefE
  00870	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  00873	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00879	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0087c	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0087f	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00883	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  00889	7d 52		 jge	 SHORT $LN95@P_LinedefE

; 1578 : 				{
; 1579 : 					if (ctlsector->lines[i]->flags & ML_DONTPEGTOP)

  0088b	8b 45 fc	 mov	 eax, DWORD PTR _ctlsector$[ebp]
  0088e	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00894	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00897	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0089a	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0089e	83 e1 08	 and	 ecx, 8
  008a1	74 1e		 je	 SHORT $LN94@P_LinedefE

; 1580 : 						P_AddExecutorDelay(ctlsector->lines[i], actor);

  008a3	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  008a6	50		 push	 eax
  008a7	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  008aa	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  008b0	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  008b3	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  008b6	51		 push	 ecx
  008b7	e8 00 00 00 00	 call	 _P_AddExecutorDelay
  008bc	83 c4 08	 add	 esp, 8
  008bf	eb 1c		 jmp	 SHORT $LN95@P_LinedefE
$LN94@P_LinedefE:

; 1581 : 					else
; 1582 : 						P_ProcessLineSpecial(ctlsector->lines[i], actor);

  008c1	8b 45 0c	 mov	 eax, DWORD PTR _actor$[ebp]
  008c4	50		 push	 eax
  008c5	8b 4d fc	 mov	 ecx, DWORD PTR _ctlsector$[ebp]
  008c8	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  008ce	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  008d1	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  008d4	51		 push	 ecx
  008d5	e8 00 00 00 00	 call	 _P_ProcessLineSpecial
  008da	83 c4 08	 add	 esp, 8
$LN95@P_LinedefE:

; 1583 : 				}
; 1584 : 			}

  008dd	e9 6d fd ff ff	 jmp	 $LN16@P_LinedefE
$LN17@P_LinedefE:

; 1585 : 		}
; 1586 : 
; 1587 : 		// Special type 308, 307, 302, 304 & 315 only work once
; 1588 : 		if (specialtype == 302 || specialtype == 304 || specialtype == 307 || specialtype == 308 || specialtype == 315)

  008e2	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  008e6	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  008eb	74 2c		 je	 SHORT $LN97@P_LinedefE
  008ed	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  008f1	3d 30 01 00 00	 cmp	 eax, 304		; 00000130H
  008f6	74 21		 je	 SHORT $LN97@P_LinedefE
  008f8	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  008fc	3d 33 01 00 00	 cmp	 eax, 307		; 00000133H
  00901	74 16		 je	 SHORT $LN97@P_LinedefE
  00903	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  00907	3d 34 01 00 00	 cmp	 eax, 308		; 00000134H
  0090c	74 0b		 je	 SHORT $LN97@P_LinedefE
  0090e	0f bf 45 e4	 movsx	 eax, WORD PTR _specialtype$[ebp]
  00912	3d 3b 01 00 00	 cmp	 eax, 315		; 0000013bH
  00917	75 11		 jne	 SHORT $LN96@P_LinedefE
$LN97@P_LinedefE:

; 1589 : 		{
; 1590 : 			lines[masterline].special = 0; // Clear it out

  00919	6b 45 f4 4c	 imul	 eax, DWORD PTR _masterline$[ebp], 76
  0091d	33 c9		 xor	 ecx, ecx
  0091f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00925	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx
$LN96@P_LinedefE:

; 1591 : 
; 1592 : 			// Hmm, I'm thinking that we shouldn't touch the sector special, incase
; 1593 : 			// we have continuous executors associated with it, too?
; 1594 : 			/*
; 1595 : 			if (caller && (GETSECSPECIAL(caller->special, 2) >= 1 && GETSECSPECIAL(caller->special, 2) <= 7))
; 1596 : 				caller->special = (UINT16)(caller->special-(GETSECSPECIAL(caller->special, 2) << 4)); // Only remove the relevant section
; 1597 : 				*/
; 1598 : 		}
; 1599 : 	}

  0092a	e9 e6 f6 ff ff	 jmp	 $LN2@P_LinedefE
$LN3@P_LinedefE:

; 1600 : }

  0092f	5f		 pop	 edi
  00930	5e		 pop	 esi
  00931	5b		 pop	 ebx
  00932	8b e5		 mov	 esp, ebp
  00934	5d		 pop	 ebp
  00935	c3		 ret	 0
_P_LinedefExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SwitchWeather
_TEXT	SEGMENT
tv64 = -112						; size = 4
tv204 = -112						; size = 4
_dontspawn$1 = -44					; size = 4
_dontspawn$2 = -40					; size = 4
_dontspawn$3 = -36					; size = 4
_z$4 = -32						; size = 4
_st$5 = -28						; size = 4
_precipmobj$6 = -24					; size = 4
_think$7 = -20						; size = 4
_precipmobj$8 = -16					; size = 4
_think$9 = -12						; size = 4
_swap$ = -8						; size = 4
_purge$ = -4						; size = 4
_weathernum$ = 8					; size = 4
_P_SwitchWeather PROC					; COMDAT

; 1608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1609 : 	boolean purge = false;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _purge$[ebp], 0

; 1610 : 	INT32 swap = 0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _swap$[ebp], 0

; 1611 : 
; 1612 : 	switch (weathernum)

  00017	8b 45 08	 mov	 eax, DWORD PTR _weathernum$[ebp]
  0001a	89 45 90	 mov	 DWORD PTR tv64[ebp], eax
  0001d	83 7d 90 06	 cmp	 DWORD PTR tv64[ebp], 6
  00021	0f 87 27 01 00
	00		 ja	 $LN35@P_SwitchWe
  00027	8b 4d 90	 mov	 ecx, DWORD PTR tv64[ebp]
  0002a	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN75@P_SwitchWe[ecx*4]
$LN12@P_SwitchWe:

; 1613 : 	{
; 1614 : 		case PRECIP_NONE: // None
; 1615 : 			if (curWeather == PRECIP_NONE)

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _curWeather, 0
  00038	75 05		 jne	 SHORT $LN13@P_SwitchWe

; 1616 : 				return; // Nothing to do.

  0003a	e9 07 05 00 00	 jmp	 $LN10@P_SwitchWe
$LN13@P_SwitchWe:

; 1617 : 			purge = true;

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _purge$[ebp], 1

; 1618 : 			break;

  00046	e9 14 01 00 00	 jmp	 $LN2@P_SwitchWe
$LN14@P_SwitchWe:

; 1619 : 		case PRECIP_STORM: // Storm
; 1620 : 		case PRECIP_STORM_NOSTRIKES: // Storm w/ no lightning
; 1621 : 		case PRECIP_RAIN: // Rain
; 1622 : 			if (curWeather == PRECIP_SNOW || curWeather == PRECIP_BLANK || curWeather == PRECIP_STORM_NORAIN)

  0004b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _curWeather, 2
  00052	74 12		 je	 SHORT $LN18@P_SwitchWe
  00054	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _curWeather, 4
  0005b	74 09		 je	 SHORT $LN18@P_SwitchWe
  0005d	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _curWeather, 5
  00064	75 07		 jne	 SHORT $LN17@P_SwitchWe
$LN18@P_SwitchWe:

; 1623 : 				swap = PRECIP_RAIN;

  00066	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _swap$[ebp], 3
$LN17@P_SwitchWe:

; 1624 : 			break;

  0006d	e9 ed 00 00 00	 jmp	 $LN2@P_SwitchWe
$LN19@P_SwitchWe:

; 1625 : 		case PRECIP_SNOW: // Snow
; 1626 : 			if (curWeather == PRECIP_SNOW)

  00072	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _curWeather, 2
  00079	75 05		 jne	 SHORT $LN20@P_SwitchWe

; 1627 : 				return; // Nothing to do.

  0007b	e9 c6 04 00 00	 jmp	 $LN10@P_SwitchWe
$LN20@P_SwitchWe:

; 1628 : 			if (curWeather == PRECIP_RAIN || curWeather == PRECIP_STORM || curWeather == PRECIP_STORM_NOSTRIKES || curWeather == PRECIP_BLANK || curWeather == PRECIP_STORM_NORAIN)

  00080	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _curWeather, 3
  00087	74 24		 je	 SHORT $LN22@P_SwitchWe
  00089	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _curWeather, 1
  00090	74 1b		 je	 SHORT $LN22@P_SwitchWe
  00092	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _curWeather, 6
  00099	74 12		 je	 SHORT $LN22@P_SwitchWe
  0009b	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _curWeather, 4
  000a2	74 09		 je	 SHORT $LN22@P_SwitchWe
  000a4	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _curWeather, 5
  000ab	75 07		 jne	 SHORT $LN21@P_SwitchWe
$LN22@P_SwitchWe:

; 1629 : 				swap = PRECIP_SNOW; // Need to delete the other precips.

  000ad	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _swap$[ebp], 2
$LN21@P_SwitchWe:

; 1630 : 			break;

  000b4	e9 a6 00 00 00	 jmp	 $LN2@P_SwitchWe
$LN23@P_SwitchWe:

; 1631 : 		case PRECIP_STORM_NORAIN: // Storm w/o rain
; 1632 : 			if (curWeather == PRECIP_SNOW
; 1633 : 				|| curWeather == PRECIP_STORM
; 1634 : 				|| curWeather == PRECIP_STORM_NOSTRIKES
; 1635 : 				|| curWeather == PRECIP_RAIN
; 1636 : 				|| curWeather == PRECIP_BLANK)

  000b9	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _curWeather, 2
  000c0	74 24		 je	 SHORT $LN26@P_SwitchWe
  000c2	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _curWeather, 1
  000c9	74 1b		 je	 SHORT $LN26@P_SwitchWe
  000cb	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _curWeather, 6
  000d2	74 12		 je	 SHORT $LN26@P_SwitchWe
  000d4	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _curWeather, 3
  000db	74 09		 je	 SHORT $LN26@P_SwitchWe
  000dd	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _curWeather, 4
  000e4	75 09		 jne	 SHORT $LN24@P_SwitchWe
$LN26@P_SwitchWe:

; 1637 : 				swap = PRECIP_STORM_NORAIN;

  000e6	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _swap$[ebp], 5
  000ed	eb 0e		 jmp	 SHORT $LN27@P_SwitchWe
$LN24@P_SwitchWe:

; 1638 : 			else if (curWeather == PRECIP_STORM_NORAIN)

  000ef	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _curWeather, 5
  000f6	75 05		 jne	 SHORT $LN27@P_SwitchWe

; 1639 : 				return;

  000f8	e9 49 04 00 00	 jmp	 $LN10@P_SwitchWe
$LN27@P_SwitchWe:

; 1640 : 			break;

  000fd	eb 60		 jmp	 SHORT $LN2@P_SwitchWe
$LN28@P_SwitchWe:

; 1641 : 		case PRECIP_BLANK:
; 1642 : 			if (curWeather == PRECIP_SNOW
; 1643 : 				|| curWeather == PRECIP_STORM
; 1644 : 				|| curWeather == PRECIP_STORM_NOSTRIKES
; 1645 : 				|| curWeather == PRECIP_RAIN)

  000ff	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _curWeather, 2
  00106	74 1b		 je	 SHORT $LN31@P_SwitchWe
  00108	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _curWeather, 1
  0010f	74 12		 je	 SHORT $LN31@P_SwitchWe
  00111	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _curWeather, 6
  00118	74 09		 je	 SHORT $LN31@P_SwitchWe
  0011a	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _curWeather, 3
  00121	75 09		 jne	 SHORT $LN29@P_SwitchWe
$LN31@P_SwitchWe:

; 1646 : 				swap = PRECIP_BLANK;

  00123	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _swap$[ebp], 4
  0012a	eb 20		 jmp	 SHORT $LN34@P_SwitchWe
$LN29@P_SwitchWe:

; 1647 : 			else if (curWeather == PRECIP_STORM_NORAIN)

  0012c	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _curWeather, 5
  00133	75 09		 jne	 SHORT $LN32@P_SwitchWe

; 1648 : 				swap = PRECIP_BLANK;

  00135	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _swap$[ebp], 4
  0013c	eb 0e		 jmp	 SHORT $LN34@P_SwitchWe
$LN32@P_SwitchWe:

; 1649 : 			else if (curWeather == PRECIP_BLANK)

  0013e	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _curWeather, 4
  00145	75 05		 jne	 SHORT $LN34@P_SwitchWe

; 1650 : 				return;

  00147	e9 fa 03 00 00	 jmp	 $LN10@P_SwitchWe
$LN34@P_SwitchWe:

; 1651 : 			break;

  0014c	eb 11		 jmp	 SHORT $LN2@P_SwitchWe
$LN35@P_SwitchWe:

; 1652 : 		default:
; 1653 : 			CONS_Printf("Unknown weather type %d.\n", weathernum);

  0014e	8b 45 08	 mov	 eax, DWORD PTR _weathernum$[ebp]
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DKKFEAKA@Unknown?5weather?5type?5?$CFd?4?6@
  00157	e8 00 00 00 00	 call	 _CONS_Printf
  0015c	83 c4 08	 add	 esp, 8
$LN2@P_SwitchWe:

; 1654 : 			break;
; 1655 : 	}
; 1656 : 
; 1657 : 	if (purge)

  0015f	83 7d fc 00	 cmp	 DWORD PTR _purge$[ebp], 0
  00163	74 4f		 je	 SHORT $LN36@P_SwitchWe

; 1658 : 	{
; 1659 : 		thinker_t *think;
; 1660 : 		precipmobj_t *precipmobj;
; 1661 : 
; 1662 : 		for (think = thinkercap.next; think != &thinkercap; think = think->next)

  00165	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0016a	89 45 f4	 mov	 DWORD PTR _think$9[ebp], eax
  0016d	eb 09		 jmp	 SHORT $LN6@P_SwitchWe
$LN4@P_SwitchWe:
  0016f	8b 45 f4	 mov	 eax, DWORD PTR _think$9[ebp]
  00172	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00175	89 4d f4	 mov	 DWORD PTR _think$9[ebp], ecx
$LN6@P_SwitchWe:
  00178	81 7d f4 00 00
	00 00		 cmp	 DWORD PTR _think$9[ebp], OFFSET _thinkercap
  0017f	74 2e		 je	 SHORT $LN5@P_SwitchWe

; 1663 : 		{
; 1664 : 			if ((think->function.acp1 != (actionf_p1)P_SnowThinker)
; 1665 : 				&& (think->function.acp1 != (actionf_p1)P_RainThinker))

  00181	8b 45 f4	 mov	 eax, DWORD PTR _think$9[ebp]
  00184	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_SnowThinker
  0018b	74 0e		 je	 SHORT $LN38@P_SwitchWe
  0018d	8b 45 f4	 mov	 eax, DWORD PTR _think$9[ebp]
  00190	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_RainThinker
  00197	74 02		 je	 SHORT $LN38@P_SwitchWe

; 1666 : 				continue; // not a precipmobj thinker

  00199	eb d4		 jmp	 SHORT $LN4@P_SwitchWe
$LN38@P_SwitchWe:

; 1667 : 
; 1668 : 			precipmobj = (precipmobj_t *)think;

  0019b	8b 45 f4	 mov	 eax, DWORD PTR _think$9[ebp]
  0019e	89 45 f0	 mov	 DWORD PTR _precipmobj$8[ebp], eax

; 1669 : 
; 1670 : 			P_RemovePrecipMobj(precipmobj);

  001a1	8b 45 f0	 mov	 eax, DWORD PTR _precipmobj$8[ebp]
  001a4	50		 push	 eax
  001a5	e8 00 00 00 00	 call	 _P_RemovePrecipMobj
  001aa	83 c4 04	 add	 esp, 4

; 1671 : 		}

  001ad	eb c0		 jmp	 SHORT $LN4@P_SwitchWe
$LN5@P_SwitchWe:

; 1672 : 	}

  001af	e9 3f 02 00 00	 jmp	 $LN8@P_SwitchWe
$LN36@P_SwitchWe:

; 1673 : 	else if (swap && !((swap == PRECIP_BLANK && curWeather == PRECIP_STORM_NORAIN) || (swap == PRECIP_STORM_NORAIN && curWeather == PRECIP_BLANK))) // Rather than respawn all that crap, reuse it!

  001b4	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  001b8	0f 84 35 02 00
	00		 je	 $LN8@P_SwitchWe
  001be	83 7d f8 04	 cmp	 DWORD PTR _swap$[ebp], 4
  001c2	75 0d		 jne	 SHORT $LN40@P_SwitchWe
  001c4	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _curWeather, 5
  001cb	0f 84 22 02 00
	00		 je	 $LN8@P_SwitchWe
$LN40@P_SwitchWe:
  001d1	83 7d f8 05	 cmp	 DWORD PTR _swap$[ebp], 5
  001d5	75 0d		 jne	 SHORT $LN41@P_SwitchWe
  001d7	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _curWeather, 4
  001de	0f 84 0f 02 00
	00		 je	 $LN8@P_SwitchWe
$LN41@P_SwitchWe:

; 1674 : 	{
; 1675 : 		thinker_t *think;
; 1676 : 		precipmobj_t *precipmobj;
; 1677 : 		state_t *st;
; 1678 : 
; 1679 : 		for (think = thinkercap.next; think != &thinkercap; think = think->next)

  001e4	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  001e9	89 45 ec	 mov	 DWORD PTR _think$7[ebp], eax
  001ec	eb 09		 jmp	 SHORT $LN9@P_SwitchWe
$LN7@P_SwitchWe:
  001ee	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  001f1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001f4	89 4d ec	 mov	 DWORD PTR _think$7[ebp], ecx
$LN9@P_SwitchWe:
  001f7	81 7d ec 00 00
	00 00		 cmp	 DWORD PTR _think$7[ebp], OFFSET _thinkercap
  001fe	0f 84 ef 01 00
	00		 je	 $LN8@P_SwitchWe

; 1680 : 		{
; 1681 : 			if (swap == PRECIP_RAIN) // Snow To Rain

  00204	83 7d f8 03	 cmp	 DWORD PTR _swap$[ebp], 3
  00208	0f 85 ae 00 00
	00		 jne	 $LN42@P_SwitchWe

; 1682 : 			{
; 1683 : 				if (!(think->function.acp1 == (actionf_p1)P_SnowThinker

  0020e	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  00211	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_SnowThinker
  00218	74 0e		 je	 SHORT $LN44@P_SwitchWe
  0021a	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  0021d	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_NullPrecipThinker
  00224	74 02		 je	 SHORT $LN44@P_SwitchWe

; 1684 : 					|| think->function.acp1 == (actionf_p1)P_NullPrecipThinker))
; 1685 : 					continue; // not a precipmobj thinker

  00226	eb c6		 jmp	 SHORT $LN7@P_SwitchWe
$LN44@P_SwitchWe:

; 1686 : 
; 1687 : 				precipmobj = (precipmobj_t *)think;

  00228	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  0022b	89 45 e8	 mov	 DWORD PTR _precipmobj$6[ebp], eax

; 1688 : 
; 1689 : 				precipmobj->flags = mobjinfo[MT_RAIN].flags;

  0022e	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00233	69 c8 b3 00 00
	00		 imul	 ecx, eax, 179
  00239	8b 55 e8	 mov	 edx, DWORD PTR _precipmobj$6[ebp]
  0023c	8b 81 58 00 00
	00		 mov	 eax, DWORD PTR _mobjinfo[ecx+88]
  00242	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 1690 : 				st = &states[mobjinfo[MT_RAIN].spawnstate];

  00245	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0024a	69 c8 b3 00 00
	00		 imul	 ecx, eax, 179
  00250	6b 91 04 00 00
	00 1c		 imul	 edx, DWORD PTR _mobjinfo[ecx+4], 28
  00257	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  0025d	89 55 e4	 mov	 DWORD PTR _st$5[ebp], edx

; 1691 : 				precipmobj->state = st;

  00260	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  00263	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  00266	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 1692 : 				precipmobj->tics = st->tics;

  00269	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  0026c	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  0026f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00272	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 1693 : 				precipmobj->sprite = st->sprite;

  00275	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  00278	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  0027b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027d	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 1694 : 				precipmobj->frame = st->frame;

  00280	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  00283	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  00286	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00289	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 1695 : 				precipmobj->momz = mobjinfo[MT_RAIN].speed;

  0028c	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00291	69 c8 b3 00 00
	00		 imul	 ecx, eax, 179
  00297	8b 55 e8	 mov	 edx, DWORD PTR _precipmobj$6[ebp]
  0029a	8b 81 3c 00 00
	00		 mov	 eax, DWORD PTR _mobjinfo[ecx+60]
  002a0	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 1696 : 
; 1697 : 				precipmobj->invisible = 0;

  002a3	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  002a6	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 1698 : 
; 1699 : 				think->function.acp1 = (actionf_p1)P_RainThinker;

  002ad	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  002b0	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_RainThinker

; 1700 : 			}

  002b7	e9 32 01 00 00	 jmp	 $LN52@P_SwitchWe
$LN42@P_SwitchWe:

; 1701 : 			else if (swap == PRECIP_SNOW) // Rain To Snow

  002bc	83 7d f8 02	 cmp	 DWORD PTR _swap$[ebp], 2
  002c0	0f 85 e5 00 00
	00		 jne	 $LN45@P_SwitchWe

; 1702 : 			{
; 1703 : 				INT32 z;
; 1704 : 
; 1705 : 				if (!(think->function.acp1 == (actionf_p1)P_RainThinker

  002c6	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  002c9	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_RainThinker
  002d0	74 11		 je	 SHORT $LN47@P_SwitchWe
  002d2	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  002d5	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_NullPrecipThinker
  002dc	74 05		 je	 SHORT $LN47@P_SwitchWe

; 1706 : 					|| think->function.acp1 == (actionf_p1)P_NullPrecipThinker))
; 1707 : 					continue; // not a precipmobj thinker

  002de	e9 0b ff ff ff	 jmp	 $LN7@P_SwitchWe
$LN47@P_SwitchWe:

; 1708 : 
; 1709 : 				precipmobj = (precipmobj_t *)think;

  002e3	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  002e6	89 45 e8	 mov	 DWORD PTR _precipmobj$6[ebp], eax

; 1710 : 
; 1711 : 				precipmobj->flags = mobjinfo[MT_SNOWFLAKE].flags;

  002e9	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  002ee	69 c8 b4 00 00
	00		 imul	 ecx, eax, 180
  002f4	8b 55 e8	 mov	 edx, DWORD PTR _precipmobj$6[ebp]
  002f7	8b 81 58 00 00
	00		 mov	 eax, DWORD PTR _mobjinfo[ecx+88]
  002fd	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 1712 : 				z = M_Random();

  00300	e8 00 00 00 00	 call	 _M_Random
  00305	0f b6 c0	 movzx	 eax, al
  00308	89 45 e0	 mov	 DWORD PTR _z$4[ebp], eax

; 1713 : 
; 1714 : 				if (z < 64)

  0030b	83 7d e0 40	 cmp	 DWORD PTR _z$4[ebp], 64	; 00000040H
  0030f	7d 09		 jge	 SHORT $LN48@P_SwitchWe

; 1715 : 					z = 2;

  00311	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _z$4[ebp], 2
  00318	eb 19		 jmp	 SHORT $LN51@P_SwitchWe
$LN48@P_SwitchWe:

; 1716 : 				else if (z < 144)

  0031a	81 7d e0 90 00
	00 00		 cmp	 DWORD PTR _z$4[ebp], 144 ; 00000090H
  00321	7d 09		 jge	 SHORT $LN50@P_SwitchWe

; 1717 : 					z = 1;

  00323	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _z$4[ebp], 1
  0032a	eb 07		 jmp	 SHORT $LN51@P_SwitchWe
$LN50@P_SwitchWe:

; 1718 : 				else
; 1719 : 					z = 0;

  0032c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _z$4[ebp], 0
$LN51@P_SwitchWe:

; 1720 : 
; 1721 : 				st = &states[mobjinfo[MT_SNOWFLAKE].spawnstate+z];

  00333	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00338	69 c8 b4 00 00
	00		 imul	 ecx, eax, 180
  0033e	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _mobjinfo[ecx+4]
  00344	03 55 e0	 add	 edx, DWORD PTR _z$4[ebp]
  00347	6b c2 1c	 imul	 eax, edx, 28
  0034a	05 00 00 00 00	 add	 eax, OFFSET _states
  0034f	89 45 e4	 mov	 DWORD PTR _st$5[ebp], eax

; 1722 : 				precipmobj->state = st;

  00352	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  00355	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  00358	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 1723 : 				precipmobj->tics = st->tics;

  0035b	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  0035e	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  00361	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00364	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 1724 : 				precipmobj->sprite = st->sprite;

  00367	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  0036a	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  0036d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0036f	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 1725 : 				precipmobj->frame = st->frame;

  00372	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  00375	8b 4d e4	 mov	 ecx, DWORD PTR _st$5[ebp]
  00378	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0037b	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 1726 : 				precipmobj->momz = mobjinfo[MT_SNOWFLAKE].speed;

  0037e	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00383	69 c8 b4 00 00
	00		 imul	 ecx, eax, 180
  00389	8b 55 e8	 mov	 edx, DWORD PTR _precipmobj$6[ebp]
  0038c	8b 81 3c 00 00
	00		 mov	 eax, DWORD PTR _mobjinfo[ecx+60]
  00392	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 1727 : 
; 1728 : 				precipmobj->invisible = 0;

  00395	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  00398	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 1729 : 
; 1730 : 				think->function.acp1 = (actionf_p1)P_SnowThinker;

  0039f	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  003a2	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_SnowThinker

; 1731 : 			}

  003a9	eb 43		 jmp	 SHORT $LN52@P_SwitchWe
$LN45@P_SwitchWe:

; 1732 : 			else if (swap == PRECIP_BLANK || swap == PRECIP_STORM_NORAIN) // Remove precip, but keep it around for reuse.

  003ab	83 7d f8 04	 cmp	 DWORD PTR _swap$[ebp], 4
  003af	74 06		 je	 SHORT $LN53@P_SwitchWe
  003b1	83 7d f8 05	 cmp	 DWORD PTR _swap$[ebp], 5
  003b5	75 37		 jne	 SHORT $LN52@P_SwitchWe
$LN53@P_SwitchWe:

; 1733 : 			{
; 1734 : 				if (!(think->function.acp1 == (actionf_p1)P_RainThinker

  003b7	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  003ba	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_RainThinker
  003c1	74 11		 je	 SHORT $LN54@P_SwitchWe
  003c3	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  003c6	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_SnowThinker
  003cd	74 05		 je	 SHORT $LN54@P_SwitchWe

; 1735 : 					|| think->function.acp1 == (actionf_p1)P_SnowThinker))
; 1736 : 					continue;

  003cf	e9 1a fe ff ff	 jmp	 $LN7@P_SwitchWe
$LN54@P_SwitchWe:

; 1737 : 
; 1738 : 				precipmobj = (precipmobj_t *)think;

  003d4	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  003d7	89 45 e8	 mov	 DWORD PTR _precipmobj$6[ebp], eax

; 1739 : 
; 1740 : 				think->function.acp1 = (actionf_p1)P_NullPrecipThinker;

  003da	8b 45 ec	 mov	 eax, DWORD PTR _think$7[ebp]
  003dd	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _P_NullPrecipThinker

; 1741 : 
; 1742 : 				precipmobj->invisible = 1;

  003e4	8b 45 e8	 mov	 eax, DWORD PTR _precipmobj$6[ebp]
  003e7	c7 40 54 01 00
	00 00		 mov	 DWORD PTR [eax+84], 1
$LN52@P_SwitchWe:

; 1743 : 			}
; 1744 : 		}

  003ee	e9 fb fd ff ff	 jmp	 $LN7@P_SwitchWe
$LN8@P_SwitchWe:

; 1745 : 	}
; 1746 : 
; 1747 : 	switch (weathernum)

  003f3	8b 45 08	 mov	 eax, DWORD PTR _weathernum$[ebp]
  003f6	89 45 90	 mov	 DWORD PTR tv204[ebp], eax
  003f9	8b 4d 90	 mov	 ecx, DWORD PTR tv204[ebp]
  003fc	83 e9 01	 sub	 ecx, 1
  003ff	89 4d 90	 mov	 DWORD PTR tv204[ebp], ecx
  00402	83 7d 90 05	 cmp	 DWORD PTR tv204[ebp], 5
  00406	0f 87 30 01 00
	00		 ja	 $LN73@P_SwitchWe
  0040c	8b 55 90	 mov	 edx, DWORD PTR tv204[ebp]
  0040f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN76@P_SwitchWe[edx*4]
$LN55@P_SwitchWe:

; 1748 : 	{
; 1749 : 		case PRECIP_SNOW: // snow
; 1750 : 			curWeather = PRECIP_SNOW;

  00416	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _curWeather, 2

; 1751 : 
; 1752 : 			if (!swap)

  00420	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  00424	75 06		 jne	 SHORT $LN56@P_SwitchWe

; 1753 : 				P_SpawnPrecipitation();

  00426	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  0042b	90		 npad	 1
$LN56@P_SwitchWe:

; 1754 : 
; 1755 : 			break;

  0042c	e9 15 01 00 00	 jmp	 $LN10@P_SwitchWe
$LN57@P_SwitchWe:

; 1756 : 		case PRECIP_RAIN: // rain
; 1757 : 		{
; 1758 : 			boolean dontspawn = false;

  00431	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _dontspawn$3[ebp], 0

; 1759 : 
; 1760 : 			if (curWeather == PRECIP_RAIN || curWeather == PRECIP_STORM || curWeather == PRECIP_STORM_NOSTRIKES)

  00438	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _curWeather, 3
  0043f	74 12		 je	 SHORT $LN59@P_SwitchWe
  00441	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _curWeather, 1
  00448	74 09		 je	 SHORT $LN59@P_SwitchWe
  0044a	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _curWeather, 6
  00451	75 07		 jne	 SHORT $LN58@P_SwitchWe
$LN59@P_SwitchWe:

; 1761 : 				dontspawn = true;

  00453	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _dontspawn$3[ebp], 1
$LN58@P_SwitchWe:

; 1762 : 
; 1763 : 			curWeather = PRECIP_RAIN;

  0045a	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _curWeather, 3

; 1764 : 
; 1765 : 			if (!dontspawn && !swap)

  00464	83 7d dc 00	 cmp	 DWORD PTR _dontspawn$3[ebp], 0
  00468	75 0c		 jne	 SHORT $LN60@P_SwitchWe
  0046a	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  0046e	75 06		 jne	 SHORT $LN60@P_SwitchWe

; 1766 : 				P_SpawnPrecipitation();

  00470	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  00475	90		 npad	 1
$LN60@P_SwitchWe:

; 1767 : 
; 1768 : 			break;

  00476	e9 cb 00 00 00	 jmp	 $LN10@P_SwitchWe
$LN61@P_SwitchWe:

; 1769 : 		}
; 1770 : 		case PRECIP_STORM: // storm
; 1771 : 		{
; 1772 : 			boolean dontspawn = false;

  0047b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dontspawn$2[ebp], 0

; 1773 : 
; 1774 : 			if (curWeather == PRECIP_RAIN || curWeather == PRECIP_STORM || curWeather == PRECIP_STORM_NOSTRIKES)

  00482	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _curWeather, 3
  00489	74 12		 je	 SHORT $LN63@P_SwitchWe
  0048b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _curWeather, 1
  00492	74 09		 je	 SHORT $LN63@P_SwitchWe
  00494	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _curWeather, 6
  0049b	75 07		 jne	 SHORT $LN62@P_SwitchWe
$LN63@P_SwitchWe:

; 1775 : 				dontspawn = true;

  0049d	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _dontspawn$2[ebp], 1
$LN62@P_SwitchWe:

; 1776 : 
; 1777 : 			curWeather = PRECIP_STORM;

  004a4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _curWeather, 1

; 1778 : 
; 1779 : 			if (!dontspawn && !swap)

  004ae	83 7d d8 00	 cmp	 DWORD PTR _dontspawn$2[ebp], 0
  004b2	75 0c		 jne	 SHORT $LN64@P_SwitchWe
  004b4	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  004b8	75 06		 jne	 SHORT $LN64@P_SwitchWe

; 1780 : 				P_SpawnPrecipitation();

  004ba	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  004bf	90		 npad	 1
$LN64@P_SwitchWe:

; 1781 : 
; 1782 : 			break;

  004c0	e9 81 00 00 00	 jmp	 $LN10@P_SwitchWe
$LN65@P_SwitchWe:

; 1783 : 		}
; 1784 : 		case PRECIP_STORM_NOSTRIKES: // storm w/o lightning
; 1785 : 		{
; 1786 : 			boolean dontspawn = false;

  004c5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _dontspawn$1[ebp], 0

; 1787 : 
; 1788 : 			if (curWeather == PRECIP_RAIN || curWeather == PRECIP_STORM || curWeather == PRECIP_STORM_NOSTRIKES)

  004cc	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _curWeather, 3
  004d3	74 12		 je	 SHORT $LN67@P_SwitchWe
  004d5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _curWeather, 1
  004dc	74 09		 je	 SHORT $LN67@P_SwitchWe
  004de	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _curWeather, 6
  004e5	75 07		 jne	 SHORT $LN66@P_SwitchWe
$LN67@P_SwitchWe:

; 1789 : 				dontspawn = true;

  004e7	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _dontspawn$1[ebp], 1
$LN66@P_SwitchWe:

; 1790 : 
; 1791 : 			curWeather = PRECIP_STORM_NOSTRIKES;

  004ee	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _curWeather, 6

; 1792 : 
; 1793 : 			if (!dontspawn && !swap)

  004f8	83 7d d4 00	 cmp	 DWORD PTR _dontspawn$1[ebp], 0
  004fc	75 0c		 jne	 SHORT $LN68@P_SwitchWe
  004fe	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  00502	75 06		 jne	 SHORT $LN68@P_SwitchWe

; 1794 : 				P_SpawnPrecipitation();

  00504	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  00509	90		 npad	 1
$LN68@P_SwitchWe:

; 1795 : 
; 1796 : 			break;

  0050a	eb 3a		 jmp	 SHORT $LN10@P_SwitchWe
$LN69@P_SwitchWe:

; 1797 : 		}
; 1798 : 		case PRECIP_STORM_NORAIN: // storm w/o rain
; 1799 : 			curWeather = PRECIP_STORM_NORAIN;

  0050c	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _curWeather, 5

; 1800 : 
; 1801 : 			if (!swap)

  00516	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  0051a	75 06		 jne	 SHORT $LN70@P_SwitchWe

; 1802 : 				P_SpawnPrecipitation();

  0051c	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  00521	90		 npad	 1
$LN70@P_SwitchWe:

; 1803 : 
; 1804 : 			break;

  00522	eb 22		 jmp	 SHORT $LN10@P_SwitchWe
$LN71@P_SwitchWe:

; 1805 : 		case PRECIP_BLANK:
; 1806 : 			curWeather = PRECIP_BLANK;

  00524	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR _curWeather, 4

; 1807 : 
; 1808 : 			if (!swap)

  0052e	83 7d f8 00	 cmp	 DWORD PTR _swap$[ebp], 0
  00532	75 06		 jne	 SHORT $LN72@P_SwitchWe

; 1809 : 				P_SpawnPrecipitation();

  00534	e8 00 00 00 00	 call	 _P_SpawnPrecipitation
  00539	90		 npad	 1
$LN72@P_SwitchWe:

; 1810 : 
; 1811 : 			break;

  0053a	eb 0a		 jmp	 SHORT $LN10@P_SwitchWe
$LN73@P_SwitchWe:

; 1812 : 		default:
; 1813 : 			curWeather = PRECIP_NONE;

  0053c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _curWeather, 0
$LN10@P_SwitchWe:

; 1814 : 			break;
; 1815 : 	}
; 1816 : }

  00546	5f		 pop	 edi
  00547	5e		 pop	 esi
  00548	5b		 pop	 ebx
  00549	8b e5		 mov	 esp, ebp
  0054b	5d		 pop	 ebp
  0054c	c3		 ret	 0
  0054d	0f 1f 00	 npad	 3
$LN75@P_SwitchWe:
  00550	00 00 00 00	 DD	 $LN12@P_SwitchWe
  00554	00 00 00 00	 DD	 $LN14@P_SwitchWe
  00558	00 00 00 00	 DD	 $LN19@P_SwitchWe
  0055c	00 00 00 00	 DD	 $LN14@P_SwitchWe
  00560	00 00 00 00	 DD	 $LN28@P_SwitchWe
  00564	00 00 00 00	 DD	 $LN23@P_SwitchWe
  00568	00 00 00 00	 DD	 $LN14@P_SwitchWe
$LN76@P_SwitchWe:
  0056c	00 00 00 00	 DD	 $LN61@P_SwitchWe
  00570	00 00 00 00	 DD	 $LN55@P_SwitchWe
  00574	00 00 00 00	 DD	 $LN57@P_SwitchWe
  00578	00 00 00 00	 DD	 $LN71@P_SwitchWe
  0057c	00 00 00 00	 DD	 $LN69@P_SwitchWe
  00580	00 00 00 00	 DD	 $LN65@P_SwitchWe
_P_SwitchWeather ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SetupSignExit
_TEXT	SEGMENT
_node$ = -8						; size = 4
_thing$ = -4						; size = 4
_player$ = 8						; size = 4
_P_SetupSignExit PROC					; COMDAT

; 2577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2578 : 	mobj_t *thing;
; 2579 : 	msecnode_t *node = player->mo->subsector->sector->touching_thinglist; // things touching this sector

  00009	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00019	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx

; 2580 : 
; 2581 : 	for (; node; node = node->m_snext)

  0001c	eb 09		 jmp	 SHORT $LN4@P_SetupSig
$LN2@P_SetupSig:
  0001e	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00021	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00024	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx
$LN4@P_SetupSig:
  00027	83 7d f8 00	 cmp	 DWORD PTR _node$[ebp], 0
  0002b	0f 84 87 00 00
	00		 je	 $LN3@P_SetupSig

; 2582 : 	{
; 2583 : 		thing = node->m_thing;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx

; 2584 : 		if (thing->type != MT_SIGN)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0003d	83 78 7c 43	 cmp	 DWORD PTR [eax+124], 67	; 00000043H
  00041	74 02		 je	 SHORT $LN5@P_SetupSig

; 2585 : 			continue;

  00043	eb d9		 jmp	 SHORT $LN2@P_SetupSig
$LN5@P_SetupSig:

; 2586 : 
; 2587 : 		if (thing->state != &states[thing->info->spawnstate])

  00045	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00048	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0004e	6b 51 04 1c	 imul	 edx, DWORD PTR [ecx+4], 28
  00052	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  00058	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0005b	39 50 5c	 cmp	 DWORD PTR [eax+92], edx
  0005e	74 02		 je	 SHORT $LN6@P_SetupSig

; 2588 : 			continue;

  00060	eb bc		 jmp	 SHORT $LN2@P_SetupSig
$LN6@P_SetupSig:

; 2589 : 
; 2590 : 		P_SetTarget(&thing->target, player->mo);

  00062	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00065	8b 08		 mov	 ecx, DWORD PTR [eax]
  00067	51		 push	 ecx
  00068	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  0006b	81 c2 98 00 00
	00		 add	 edx, 152		; 00000098H
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 _P_SetTarget
  00077	83 c4 08	 add	 esp, 8

; 2591 : 		P_SetMobjState(thing, S_SIGN1);

  0007a	68 22 02 00 00	 push	 546			; 00000222H
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _P_SetMobjState
  00088	83 c4 08	 add	 esp, 8

; 2592 : 		if (thing->info->seesound)

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0008e	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00094	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00098	74 19		 je	 SHORT $LN7@P_SetupSig

; 2593 : 			S_StartSound(thing, thing->info->seesound);

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0009d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000a3	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a6	52		 push	 edx
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _S_StartSound
  000b0	83 c4 08	 add	 esp, 8
$LN7@P_SetupSig:

; 2594 : 	}

  000b3	e9 66 ff ff ff	 jmp	 $LN2@P_SetupSig
$LN3@P_SetupSig:

; 2595 : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_P_SetupSignExit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindMinSurroundingLight
_TEXT	SEGMENT
_check$ = -16						; size = 4
_line$ = -12						; size = 4
_min$ = -8						; size = 4
_i$ = -4						; size = 4
_sector$ = 8						; size = 4
_max$ = 12						; size = 4
_P_FindMinSurroundingLight PROC				; COMDAT

; 1255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1256 : 	size_t i;
; 1257 : 	INT32 min = max;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _max$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _min$[ebp], eax

; 1258 : 	line_t *line;
; 1259 : 	sector_t *check;
; 1260 : 
; 1261 : 	for (i = 0; i < sector->linecount; i++)

  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN4@P_FindMinS
$LN2@P_FindMinS:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindMinS:
  00021	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  0002d	73 45		 jae	 SHORT $LN3@P_FindMinS

; 1262 : 	{
; 1263 : 		line = sector->lines[i];

  0002f	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00032	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00038	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003b	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0003e	89 45 f4	 mov	 DWORD PTR _line$[ebp], eax

; 1264 : 		check = getNextSector(line,sector);

  00041	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _line$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _getNextSector
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR _check$[ebp], eax

; 1265 : 
; 1266 : 		if (!check)

  00054	83 7d f0 00	 cmp	 DWORD PTR _check$[ebp], 0
  00058	75 02		 jne	 SHORT $LN5@P_FindMinS

; 1267 : 			continue;

  0005a	eb bc		 jmp	 SHORT $LN2@P_FindMinS
$LN5@P_FindMinS:

; 1268 : 
; 1269 : 		if (check->lightlevel < min)

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _check$[ebp]
  0005f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00063	3b 4d f8	 cmp	 ecx, DWORD PTR _min$[ebp]
  00066	7d 0a		 jge	 SHORT $LN6@P_FindMinS

; 1270 : 			min = check->lightlevel;

  00068	8b 45 f0	 mov	 eax, DWORD PTR _check$[ebp]
  0006b	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0006f	89 4d f8	 mov	 DWORD PTR _min$[ebp], ecx
$LN6@P_FindMinS:

; 1271 : 	}

  00072	eb a4		 jmp	 SHORT $LN2@P_FindMinS
$LN3@P_FindMinS:

; 1272 : 	return min;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _min$[ebp]

; 1273 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_P_FindMinSurroundingLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindSpecialLineFromTag
_TEXT	SEGMENT
tv84 = -68						; size = 4
_special$ = 8						; size = 2
_tag$ = 12						; size = 2
_start$ = 16						; size = 4
_P_FindSpecialLineFromTag PROC				; COMDAT

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 950  : 	if (tag == -1)

  00009	0f bf 45 0c	 movsx	 eax, WORD PTR _tag$[ebp]
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 4b		 jne	 SHORT $LN6@P_FindSpec

; 951  : 	{
; 952  : 		start++;

  00012	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 10	 mov	 DWORD PTR _start$[ebp], eax
$LN2@P_FindSpec:

; 953  : 
; 954  : 		while (lines[start].special != special)

  0001b	6b 45 10 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00025	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  0002a	0f bf 45 08	 movsx	 eax, WORD PTR _special$[ebp]
  0002e	3b d0		 cmp	 edx, eax
  00030	74 0b		 je	 SHORT $LN3@P_FindSpec

; 955  : 			start++;

  00032	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 10	 mov	 DWORD PTR _start$[ebp], eax
  0003b	eb de		 jmp	 SHORT $LN2@P_FindSpec
$LN3@P_FindSpec:

; 956  : 
; 957  : 		if (start >= (INT32)numlines)

  0003d	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00040	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00046	7c 08		 jl	 SHORT $LN8@P_FindSpec

; 958  : 			return -1;

  00048	83 c8 ff	 or	 eax, -1
  0004b	e9 92 00 00 00	 jmp	 $LN7@P_FindSpec
$LN8@P_FindSpec:

; 959  : 
; 960  : 		return start;

  00050	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
  00053	e9 8a 00 00 00	 jmp	 $LN7@P_FindSpec

; 961  : 	}

  00058	e9 85 00 00 00	 jmp	 $LN7@P_FindSpec
$LN6@P_FindSpec:

; 962  : 	else
; 963  : 	{
; 964  : 		start = start >= 0 ? lines[start].nexttag :

  0005d	83 7d 10 00	 cmp	 DWORD PTR _start$[ebp], 0
  00061	7c 13		 jl	 SHORT $LN11@P_FindSpec
  00063	6b 45 10 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0006d	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  00071	89 55 bc	 mov	 DWORD PTR tv84[ebp], edx
  00074	eb 1c		 jmp	 SHORT $LN12@P_FindSpec
$LN11@P_FindSpec:
  00076	0f bf 45 0c	 movsx	 eax, WORD PTR _tag$[ebp]
  0007a	33 d2		 xor	 edx, edx
  0007c	f7 35 00 00 00
	00		 div	 DWORD PTR _numlines
  00082	6b c2 4c	 imul	 eax, edx, 76
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0008b	8b 54 01 40	 mov	 edx, DWORD PTR [ecx+eax+64]
  0008f	89 55 bc	 mov	 DWORD PTR tv84[ebp], edx
$LN12@P_FindSpec:
  00092	8b 45 bc	 mov	 eax, DWORD PTR tv84[ebp]
  00095	89 45 10	 mov	 DWORD PTR _start$[ebp], eax
$LN4@P_FindSpec:

; 965  : 			lines[(unsigned)tag % numlines].firsttag;
; 966  : 		while (start >= 0 && (lines[start].tag != tag || lines[start].special != special))

  00098	83 7d 10 00	 cmp	 DWORD PTR _start$[ebp], 0
  0009c	7c 41		 jl	 SHORT $LN5@P_FindSpec
  0009e	6b 45 10 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000a8	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  000ad	0f bf 45 0c	 movsx	 eax, WORD PTR _tag$[ebp]
  000b1	3b d0		 cmp	 edx, eax
  000b3	75 17		 jne	 SHORT $LN9@P_FindSpec
  000b5	6b 45 10 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000bf	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  000c4	0f bf 45 08	 movsx	 eax, WORD PTR _special$[ebp]
  000c8	3b d0		 cmp	 edx, eax
  000ca	74 13		 je	 SHORT $LN5@P_FindSpec
$LN9@P_FindSpec:

; 967  : 			start = lines[start].nexttag;

  000cc	6b 45 10 4c	 imul	 eax, DWORD PTR _start$[ebp], 76
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  000d6	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  000da	89 55 10	 mov	 DWORD PTR _start$[ebp], edx
  000dd	eb b9		 jmp	 SHORT $LN4@P_FindSpec
$LN5@P_FindSpec:

; 968  : 		return start;

  000df	8b 45 10	 mov	 eax, DWORD PTR _start$[ebp]
$LN7@P_FindSpec:

; 969  : 	}
; 970  : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_P_FindSpecialLineFromTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindSectorFromTag
_TEXT	SEGMENT
tv77 = -68						; size = 4
_tag$ = 8						; size = 2
_start$ = 12						; size = 4
_P_FindSectorFromTag PROC				; COMDAT

; 866  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 867  : 	if (tag == -1)

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _tag$[ebp]
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	75 23		 jne	 SHORT $LN4@P_FindSect

; 868  : 	{
; 869  : 		start++;

  00012	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 0c	 mov	 DWORD PTR _start$[ebp], eax

; 870  : 
; 871  : 		if (start >= (INT32)numsectors)

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00024	7c 08		 jl	 SHORT $LN6@P_FindSect

; 872  : 			return -1;

  00026	83 c8 ff	 or	 eax, -1
  00029	e9 81 00 00 00	 jmp	 $LN5@P_FindSect
$LN6@P_FindSect:

; 873  : 
; 874  : 		return start;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00031	eb 7c		 jmp	 SHORT $LN5@P_FindSect

; 875  : 	}

  00033	eb 7a		 jmp	 SHORT $LN5@P_FindSect
$LN4@P_FindSect:

; 876  : 	else
; 877  : 	{
; 878  : 		start = start >= 0 ? sectors[start].nexttag :

  00035	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  00039	7c 16		 jl	 SHORT $LN8@P_FindSect
  0003b	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _start$[ebp], 248
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00048	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  0004c	89 55 bc	 mov	 DWORD PTR tv77[ebp], edx
  0004f	eb 1f		 jmp	 SHORT $LN9@P_FindSect
$LN8@P_FindSect:
  00051	0f bf 45 08	 movsx	 eax, WORD PTR _tag$[ebp]
  00055	33 d2		 xor	 edx, edx
  00057	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  0005d	69 c2 f8 00 00
	00		 imul	 eax, edx, 248
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00069	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  0006d	89 55 bc	 mov	 DWORD PTR tv77[ebp], edx
$LN9@P_FindSect:
  00070	8b 45 bc	 mov	 eax, DWORD PTR tv77[ebp]
  00073	89 45 0c	 mov	 DWORD PTR _start$[ebp], eax
$LN2@P_FindSect:

; 879  : 			sectors[(unsigned)tag % numsectors].firsttag;
; 880  : 		while (start >= 0 && sectors[start].tag != tag)

  00076	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  0007a	7c 30		 jl	 SHORT $LN3@P_FindSect
  0007c	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _start$[ebp], 248
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00089	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  0008e	0f bf 45 08	 movsx	 eax, WORD PTR _tag$[ebp]
  00092	3b d0		 cmp	 edx, eax
  00094	74 16		 je	 SHORT $LN3@P_FindSect

; 881  : 			start = sectors[start].nexttag;

  00096	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _start$[ebp], 248
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000a3	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  000a7	89 55 0c	 mov	 DWORD PTR _start$[ebp], edx
  000aa	eb ca		 jmp	 SHORT $LN2@P_FindSect
$LN3@P_FindSect:

; 882  : 		return start;

  000ac	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
$LN5@P_FindSect:

; 883  : 	}
; 884  : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_P_FindSectorFromTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindSectorFromLineTag
_TEXT	SEGMENT
tv79 = -68						; size = 4
_line$ = 8						; size = 4
_start$ = 12						; size = 4
_P_FindSectorFromLineTag PROC				; COMDAT

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 838  : 	if (line->tag == -1)

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00010	83 f9 ff	 cmp	 ecx, -1
  00013	75 29		 jne	 SHORT $LN4@P_FindSect

; 839  : 	{
; 840  : 		start++;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 0c	 mov	 DWORD PTR _start$[ebp], eax

; 841  : 
; 842  : 		if (start >= (INT32)numsectors)

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00021	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00027	7c 08		 jl	 SHORT $LN6@P_FindSect

; 843  : 			return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	e9 8d 00 00 00	 jmp	 $LN5@P_FindSect
$LN6@P_FindSect:

; 844  : 
; 845  : 		return start;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00034	e9 85 00 00 00	 jmp	 $LN5@P_FindSect

; 846  : 	}

  00039	e9 80 00 00 00	 jmp	 $LN5@P_FindSect
$LN4@P_FindSect:

; 847  : 	else
; 848  : 	{
; 849  : 		start = start >= 0 ? sectors[start].nexttag :

  0003e	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  00042	7c 16		 jl	 SHORT $LN8@P_FindSect
  00044	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _start$[ebp], 248
  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00051	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  00055	89 55 bc	 mov	 DWORD PTR tv79[ebp], edx
  00058	eb 22		 jmp	 SHORT $LN9@P_FindSect
$LN8@P_FindSect:
  0005a	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0005d	0f bf 40 14	 movsx	 eax, WORD PTR [eax+20]
  00061	33 d2		 xor	 edx, edx
  00063	f7 35 00 00 00
	00		 div	 DWORD PTR _numsectors
  00069	69 ca f8 00 00
	00		 imul	 ecx, edx, 248
  0006f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00075	8b 44 0a 1c	 mov	 eax, DWORD PTR [edx+ecx+28]
  00079	89 45 bc	 mov	 DWORD PTR tv79[ebp], eax
$LN9@P_FindSect:
  0007c	8b 4d bc	 mov	 ecx, DWORD PTR tv79[ebp]
  0007f	89 4d 0c	 mov	 DWORD PTR _start$[ebp], ecx
$LN2@P_FindSect:

; 850  : 			sectors[(unsigned)line->tag % numsectors].firsttag;
; 851  : 		while (start >= 0 && sectors[start].tag != line->tag)

  00082	83 7d 0c 00	 cmp	 DWORD PTR _start$[ebp], 0
  00086	7c 33		 jl	 SHORT $LN3@P_FindSect
  00088	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _start$[ebp], 248
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00095	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  0009a	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0009d	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  000a1	3b d1		 cmp	 edx, ecx
  000a3	74 16		 je	 SHORT $LN3@P_FindSect

; 852  : 			start = sectors[start].nexttag;

  000a5	69 45 0c f8 00
	00 00		 imul	 eax, DWORD PTR _start$[ebp], 248
  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  000b2	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  000b6	89 55 0c	 mov	 DWORD PTR _start$[ebp], edx
  000b9	eb c7		 jmp	 SHORT $LN2@P_FindSect
$LN3@P_FindSect:

; 853  : 		return start;

  000bb	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
$LN5@P_FindSect:

; 854  : 	}
; 855  : }

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_P_FindSectorFromLineTag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindHighestCeilingSurrounding
_TEXT	SEGMENT
_foundsector$ = -20					; size = 4
_height$ = -16						; size = 4
_other$ = -12						; size = 4
_check$ = -8						; size = 4
_i$ = -4						; size = 4
_sec$ = 8						; size = 4
_P_FindHighestCeilingSurrounding PROC			; COMDAT

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 677  : 	size_t i;
; 678  : 	line_t *check;
; 679  : 	sector_t *other;
; 680  : 	fixed_t height = 0;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _height$[ebp], 0

; 681  : 	INT32 foundsector = 0;

  00010	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _foundsector$[ebp], 0

; 682  : 
; 683  : 	for (i = 0; i < sec->linecount; i++)

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@P_FindHigh
$LN2@P_FindHigh:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindHigh:
  00029	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  00035	73 56		 jae	 SHORT $LN3@P_FindHigh

; 684  : 	{
; 685  : 		check = sec->lines[i];

  00037	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0003a	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00040	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00043	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00046	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 686  : 		other = getNextSector(check, sec);

  00049	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _check$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _getNextSector
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 f4	 mov	 DWORD PTR _other$[ebp], eax

; 687  : 
; 688  : 		if (!other)

  0005c	83 7d f4 00	 cmp	 DWORD PTR _other$[ebp], 0
  00060	75 02		 jne	 SHORT $LN5@P_FindHigh

; 689  : 			continue;

  00062	eb bc		 jmp	 SHORT $LN2@P_FindHigh
$LN5@P_FindHigh:

; 690  : 
; 691  : 		if (other->ceilingheight > height || !foundsector)

  00064	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	3b 4d f0	 cmp	 ecx, DWORD PTR _height$[ebp]
  0006d	7f 06		 jg	 SHORT $LN7@P_FindHigh
  0006f	83 7d ec 00	 cmp	 DWORD PTR _foundsector$[ebp], 0
  00073	75 09		 jne	 SHORT $LN6@P_FindHigh
$LN7@P_FindHigh:

; 692  : 			height = other->ceilingheight;

  00075	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 4d f0	 mov	 DWORD PTR _height$[ebp], ecx
$LN6@P_FindHigh:

; 693  : 
; 694  : 		if (!foundsector)

  0007e	83 7d ec 00	 cmp	 DWORD PTR _foundsector$[ebp], 0
  00082	75 07		 jne	 SHORT $LN8@P_FindHigh

; 695  : 			foundsector = 1;

  00084	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _foundsector$[ebp], 1
$LN8@P_FindHigh:

; 696  : 	}

  0008b	eb 93		 jmp	 SHORT $LN2@P_FindHigh
$LN3@P_FindHigh:

; 697  : 	return height;

  0008d	8b 45 f0	 mov	 eax, DWORD PTR _height$[ebp]

; 698  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_P_FindHighestCeilingSurrounding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindLowestCeilingSurrounding
_TEXT	SEGMENT
_foundsector$ = -20					; size = 4
_height$ = -16						; size = 4
_other$ = -12						; size = 4
_check$ = -8						; size = 4
_i$ = -4						; size = 4
_sec$ = 8						; size = 4
_P_FindLowestCeilingSurrounding PROC			; COMDAT

; 644  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  : 	size_t i;
; 646  : 	line_t *check;
; 647  : 	sector_t *other;
; 648  : 	fixed_t height = 32000*FRACUNIT; //SoM: 3/7/2000: Remove ovf

  00009	c7 45 f0 00 00
	00 7d		 mov	 DWORD PTR _height$[ebp], 2097152000 ; 7d000000H

; 649  : 	INT32 foundsector = 0;

  00010	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _foundsector$[ebp], 0

; 650  : 
; 651  : 	for (i = 0; i < sec->linecount; i++)

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@P_FindLowe
$LN2@P_FindLowe:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindLowe:
  00029	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  00035	73 56		 jae	 SHORT $LN3@P_FindLowe

; 652  : 	{
; 653  : 		check = sec->lines[i];

  00037	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0003a	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00040	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00043	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00046	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 654  : 		other = getNextSector(check, sec);

  00049	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _check$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _getNextSector
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 f4	 mov	 DWORD PTR _other$[ebp], eax

; 655  : 
; 656  : 		if (!other)

  0005c	83 7d f4 00	 cmp	 DWORD PTR _other$[ebp], 0
  00060	75 02		 jne	 SHORT $LN5@P_FindLowe

; 657  : 			continue;

  00062	eb bc		 jmp	 SHORT $LN2@P_FindLowe
$LN5@P_FindLowe:

; 658  : 
; 659  : 		if (other->ceilingheight < height || !foundsector)

  00064	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	3b 4d f0	 cmp	 ecx, DWORD PTR _height$[ebp]
  0006d	7c 06		 jl	 SHORT $LN7@P_FindLowe
  0006f	83 7d ec 00	 cmp	 DWORD PTR _foundsector$[ebp], 0
  00073	75 09		 jne	 SHORT $LN6@P_FindLowe
$LN7@P_FindLowe:

; 660  : 			height = other->ceilingheight;

  00075	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 4d f0	 mov	 DWORD PTR _height$[ebp], ecx
$LN6@P_FindLowe:

; 661  : 
; 662  : 		if (!foundsector)

  0007e	83 7d ec 00	 cmp	 DWORD PTR _foundsector$[ebp], 0
  00082	75 07		 jne	 SHORT $LN8@P_FindLowe

; 663  : 			foundsector = 1;

  00084	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _foundsector$[ebp], 1
$LN8@P_FindLowe:

; 664  : 	}

  0008b	eb 93		 jmp	 SHORT $LN2@P_FindLowe
$LN3@P_FindLowe:

; 665  : 	return height;

  0008d	8b 45 f0	 mov	 eax, DWORD PTR _height$[ebp]

; 666  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_P_FindLowestCeilingSurrounding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindNextLowestFloor
_TEXT	SEGMENT
_height$ = -12						; size = 4
_i$ = -8						; size = 4
_other$ = -4						; size = 4
_sec$ = 8						; size = 4
_currentheight$ = 12					; size = 4
_P_FindNextLowestFloor PROC				; COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 537  : 	sector_t *other;
; 538  : 	size_t i;
; 539  : 	fixed_t height;
; 540  : 
; 541  : 	for (i = 0; i < sec->linecount; i++)

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_FindNext
$LN2@P_FindNext:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindNext:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  00027	0f 83 9b 00 00
	00		 jae	 $LN3@P_FindNext

; 542  : 	{
; 543  : 		other = getNextSector(sec->lines[i], sec);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00034	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _getNextSector
  00046	83 c4 08	 add	 esp, 8
  00049	89 45 fc	 mov	 DWORD PTR _other$[ebp], eax

; 544  : 		if (other && other->floorheight < currentheight)

  0004c	83 7d fc 00	 cmp	 DWORD PTR _other$[ebp], 0
  00050	74 71		 je	 SHORT $LN7@P_FindNext
  00052	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	3b 4d 0c	 cmp	 ecx, DWORD PTR _currentheight$[ebp]
  0005a	7d 67		 jge	 SHORT $LN7@P_FindNext

; 545  : 		{
; 546  : 			height = other->floorheight;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f4	 mov	 DWORD PTR _height$[ebp], ecx
$LN5@P_FindNext:

; 547  : 			while (++i < sec->linecount)

  00064	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00070	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00073	3b 91 88 00 00
	00		 cmp	 edx, DWORD PTR [ecx+136]
  00079	73 43		 jae	 SHORT $LN6@P_FindNext

; 548  : 			{
; 549  : 				other = getNextSector(sec->lines[i], sec);

  0007b	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00082	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00088	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008b	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _getNextSector
  00094	83 c4 08	 add	 esp, 8
  00097	89 45 fc	 mov	 DWORD PTR _other$[ebp], eax

; 550  : 				if (other &&	other->floorheight > height
; 551  : 					&& other->floorheight < currentheight)

  0009a	83 7d fc 00	 cmp	 DWORD PTR _other$[ebp], 0
  0009e	74 1c		 je	 SHORT $LN8@P_FindNext
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	3b 4d f4	 cmp	 ecx, DWORD PTR _height$[ebp]
  000a8	7e 12		 jle	 SHORT $LN8@P_FindNext
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	3b 4d 0c	 cmp	 ecx, DWORD PTR _currentheight$[ebp]
  000b2	7d 08		 jge	 SHORT $LN8@P_FindNext

; 552  : 					height = other->floorheight;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	89 4d f4	 mov	 DWORD PTR _height$[ebp], ecx
$LN8@P_FindNext:

; 553  : 			}

  000bc	eb a6		 jmp	 SHORT $LN5@P_FindNext
$LN6@P_FindNext:

; 554  : 			return height;

  000be	8b 45 f4	 mov	 eax, DWORD PTR _height$[ebp]
  000c1	eb 08		 jmp	 SHORT $LN1@P_FindNext
$LN7@P_FindNext:

; 555  : 		}
; 556  : 	}

  000c3	e9 4a ff ff ff	 jmp	 $LN2@P_FindNext
$LN3@P_FindNext:

; 557  : 	return currentheight;

  000c8	8b 45 0c	 mov	 eax, DWORD PTR _currentheight$[ebp]
$LN1@P_FindNext:

; 558  : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_P_FindNextLowestFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindNextHighestFloor
_TEXT	SEGMENT
_height$ = -12						; size = 4
_i$ = -8						; size = 4
_other$ = -4						; size = 4
_sec$ = 8						; size = 4
_currentheight$ = 12					; size = 4
_P_FindNextHighestFloor PROC				; COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 497  : 	sector_t *other;
; 498  : 	size_t i;
; 499  : 	fixed_t height;
; 500  : 
; 501  : 	for (i = 0; i < sec->linecount; i++)

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_FindNext
$LN2@P_FindNext:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindNext:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  00027	0f 83 9b 00 00
	00		 jae	 $LN3@P_FindNext

; 502  : 	{
; 503  : 		other = getNextSector(sec->lines[i],sec);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00034	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _getNextSector
  00046	83 c4 08	 add	 esp, 8
  00049	89 45 fc	 mov	 DWORD PTR _other$[ebp], eax

; 504  : 		if (other && other->floorheight > currentheight)

  0004c	83 7d fc 00	 cmp	 DWORD PTR _other$[ebp], 0
  00050	74 71		 je	 SHORT $LN7@P_FindNext
  00052	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	3b 4d 0c	 cmp	 ecx, DWORD PTR _currentheight$[ebp]
  0005a	7e 67		 jle	 SHORT $LN7@P_FindNext

; 505  : 		{
; 506  : 			height = other->floorheight;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f4	 mov	 DWORD PTR _height$[ebp], ecx
$LN5@P_FindNext:

; 507  : 			while (++i < sec->linecount)

  00064	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00070	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00073	3b 91 88 00 00
	00		 cmp	 edx, DWORD PTR [ecx+136]
  00079	73 43		 jae	 SHORT $LN6@P_FindNext

; 508  : 			{
; 509  : 				other = getNextSector(sec->lines[i], sec);

  0007b	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00082	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00088	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008b	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _getNextSector
  00094	83 c4 08	 add	 esp, 8
  00097	89 45 fc	 mov	 DWORD PTR _other$[ebp], eax

; 510  : 				if (other &&
; 511  : 					other->floorheight < height &&

  0009a	83 7d fc 00	 cmp	 DWORD PTR _other$[ebp], 0
  0009e	74 1c		 je	 SHORT $LN8@P_FindNext
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	3b 4d f4	 cmp	 ecx, DWORD PTR _height$[ebp]
  000a8	7d 12		 jge	 SHORT $LN8@P_FindNext
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	3b 4d 0c	 cmp	 ecx, DWORD PTR _currentheight$[ebp]
  000b2	7e 08		 jle	 SHORT $LN8@P_FindNext

; 512  : 					other->floorheight > currentheight)
; 513  : 					height = other->floorheight;

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _other$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	89 4d f4	 mov	 DWORD PTR _height$[ebp], ecx
$LN8@P_FindNext:

; 514  : 			}

  000bc	eb a6		 jmp	 SHORT $LN5@P_FindNext
$LN6@P_FindNext:

; 515  : 			return height;

  000be	8b 45 f4	 mov	 eax, DWORD PTR _height$[ebp]
  000c1	eb 08		 jmp	 SHORT $LN1@P_FindNext
$LN7@P_FindNext:

; 516  : 		}
; 517  : 	}

  000c3	e9 4a ff ff ff	 jmp	 $LN2@P_FindNext
$LN3@P_FindNext:

; 518  : 	return currentheight;

  000c8	8b 45 0c	 mov	 eax, DWORD PTR _currentheight$[ebp]
$LN1@P_FindNext:

; 519  : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_P_FindNextHighestFloor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindHighestFloorSurrounding
_TEXT	SEGMENT
_foundsector$ = -20					; size = 4
_floorh$ = -16						; size = 4
_other$ = -12						; size = 4
_check$ = -8						; size = 4
_i$ = -4						; size = 4
_sec$ = 8						; size = 4
_P_FindHighestFloorSurrounding PROC			; COMDAT

; 461  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 462  : 	size_t i;
; 463  : 	line_t *check;
; 464  : 	sector_t *other;
; 465  : 	fixed_t floorh = -500*FRACUNIT;

  00009	c7 45 f0 00 00
	0c fe		 mov	 DWORD PTR _floorh$[ebp], -32768000 ; fe0c0000H

; 466  : 	INT32 foundsector = 0;

  00010	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _foundsector$[ebp], 0

; 467  : 
; 468  : 	for (i = 0; i < sec->linecount; i++)

  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@P_FindHigh
$LN2@P_FindHigh:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindHigh:
  00029	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002f	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  00035	73 54		 jae	 SHORT $LN3@P_FindHigh

; 469  : 	{
; 470  : 		check = sec->lines[i];

  00037	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0003a	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00040	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00043	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00046	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 471  : 		other = getNextSector(check, sec);

  00049	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _check$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _getNextSector
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 f4	 mov	 DWORD PTR _other$[ebp], eax

; 472  : 
; 473  : 		if (!other)

  0005c	83 7d f4 00	 cmp	 DWORD PTR _other$[ebp], 0
  00060	75 02		 jne	 SHORT $LN5@P_FindHigh

; 474  : 			continue;

  00062	eb bc		 jmp	 SHORT $LN2@P_FindHigh
$LN5@P_FindHigh:

; 475  : 
; 476  : 		if (other->floorheight > floorh || !foundsector)

  00064	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	3b 4d f0	 cmp	 ecx, DWORD PTR _floorh$[ebp]
  0006c	7f 06		 jg	 SHORT $LN7@P_FindHigh
  0006e	83 7d ec 00	 cmp	 DWORD PTR _foundsector$[ebp], 0
  00072	75 08		 jne	 SHORT $LN6@P_FindHigh
$LN7@P_FindHigh:

; 477  : 			floorh = other->floorheight;

  00074	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	89 4d f0	 mov	 DWORD PTR _floorh$[ebp], ecx
$LN6@P_FindHigh:

; 478  : 
; 479  : 		if (!foundsector)

  0007c	83 7d ec 00	 cmp	 DWORD PTR _foundsector$[ebp], 0
  00080	75 07		 jne	 SHORT $LN8@P_FindHigh

; 480  : 			foundsector = 1;

  00082	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _foundsector$[ebp], 1
$LN8@P_FindHigh:

; 481  : 	}

  00089	eb 95		 jmp	 SHORT $LN2@P_FindHigh
$LN3@P_FindHigh:

; 482  : 	return floorh;

  0008b	8b 45 f0	 mov	 eax, DWORD PTR _floorh$[ebp]

; 483  : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_P_FindHighestFloorSurrounding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_FindLowestFloorSurrounding
_TEXT	SEGMENT
_floorh$ = -16						; size = 4
_other$ = -12						; size = 4
_check$ = -8						; size = 4
_i$ = -4						; size = 4
_sec$ = 8						; size = 4
_P_FindLowestFloorSurrounding PROC			; COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 432  : 	size_t i;
; 433  : 	line_t *check;
; 434  : 	sector_t *other;
; 435  : 	fixed_t floorh;
; 436  : 
; 437  : 	floorh = sec->floorheight;

  00009	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f0	 mov	 DWORD PTR _floorh$[ebp], ecx

; 438  : 
; 439  : 	for (i = 0; i < sec->linecount; i++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN4@P_FindLowe
$LN2@P_FindLowe:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_FindLowe:
  00023	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00029	3b 88 88 00 00
	00		 cmp	 ecx, DWORD PTR [eax+136]
  0002f	73 41		 jae	 SHORT $LN3@P_FindLowe

; 440  : 	{
; 441  : 		check = sec->lines[i];

  00031	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00034	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003d	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00040	89 45 f8	 mov	 DWORD PTR _check$[ebp], eax

; 442  : 		other = getNextSector(check,sec);

  00043	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00046	50		 push	 eax
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _check$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _getNextSector
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 f4	 mov	 DWORD PTR _other$[ebp], eax

; 443  : 
; 444  : 		if (!other)

  00056	83 7d f4 00	 cmp	 DWORD PTR _other$[ebp], 0
  0005a	75 02		 jne	 SHORT $LN5@P_FindLowe

; 445  : 			continue;

  0005c	eb bc		 jmp	 SHORT $LN2@P_FindLowe
$LN5@P_FindLowe:

; 446  : 
; 447  : 		if (other->floorheight < floorh)

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	3b 4d f0	 cmp	 ecx, DWORD PTR _floorh$[ebp]
  00066	7d 08		 jge	 SHORT $LN6@P_FindLowe

; 448  : 			floorh = other->floorheight;

  00068	8b 45 f4	 mov	 eax, DWORD PTR _other$[ebp]
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	89 4d f0	 mov	 DWORD PTR _floorh$[ebp], ecx
$LN6@P_FindLowe:

; 449  : 	}

  00070	eb a8		 jmp	 SHORT $LN2@P_FindLowe
$LN3@P_FindLowe:

; 450  : 	return floorh;

  00072	8b 45 f0	 mov	 eax, DWORD PTR _floorh$[ebp]

; 451  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_FindLowestFloorSurrounding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_ProcessSpecialSector
_TEXT	SEGMENT
tv1486 = -452						; size = 4
tv585 = -448						; size = 4
tv461 = -448						; size = 4
tv85 = -448						; size = 4
tv1482 = -448						; size = 4
tv393 = -448						; size = 4
_minecart$1 = -380					; size = 4
_highest$2 = -376					; size = 4
_resultlow$3 = -372					; size = 12
_resulthigh$4 = -360					; size = 12
_v2$5 = -348						; size = 12
_v1$6 = -336						; size = 12
_junk$7 = -324						; size = 76
_closest$8 = -248					; size = 4
_mo2$9 = -244						; size = 4
_waypointlow$10 = -240					; size = 4
_waypointhigh$11 = -236					; size = 4
_waypointmid$12 = -232					; size = 4
_th$13 = -228						; size = 4
_lineindex$14 = -224					; size = 4
_speed$15 = -220					; size = 4
_sequence$16 = -216					; size = 4
_post$17 = -212						; size = 4
_th$18 = -208						; size = 4
_an$19 = -204						; size = 4
_mo2$20 = -200						; size = 4
_waypoint$21 = -196					; size = 4
_th$22 = -192						; size = 4
_lineindex$23 = -188					; size = 4
_speed$24 = -184					; size = 4
_sequence$25 = -180					; size = 4
_an$26 = -176						; size = 4
_mo2$27 = -172						; size = 4
_waypoint$28 = -168					; size = 4
_th$29 = -164						; size = 4
_lineindex$30 = -160					; size = 4
_speed$31 = -156					; size = 4
_sequence$32 = -152					; size = 4
_mo$33 = -148						; size = 4
_mo$34 = -144						; size = 4
_mo$35 = -140						; size = 4
_mo$36 = -136						; size = 4
_xofs$37 = -132						; size = 4
_lineindex$38 = -128					; size = 4
_post$39 = -124						; size = 4
_linespeed$40 = -120					; size = 4
_lineangle$41 = -116					; size = 4
_junk$42 = -112						; size = 76
_mo2$43 = -36						; size = 4
_th$44 = -32						; size = 4
_special$ = -28						; size = 4
_section4$ = -24					; size = 4
_section3$ = -20					; size = 4
_section2$ = -16					; size = 4
_section1$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_player$ = 8						; size = 4
_sector$ = 12						; size = 4
_roversector$ = 16					; size = 4
_P_ProcessSpecialSector PROC				; COMDAT

; 2784 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 01 00
	00		 sub	 esp, 452		; 000001c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2785 : 	INT32 i = 0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2786 : 	INT32 section1, section2, section3, section4;
; 2787 : 	INT32 special;
; 2788 : 
; 2789 : 	section1 = GETSECSPECIAL(sector->special, 1);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00020	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00024	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00027	89 4d f4	 mov	 DWORD PTR _section1$[ebp], ecx

; 2790 : 	section2 = GETSECSPECIAL(sector->special, 2);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0002d	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00031	c1 f9 04	 sar	 ecx, 4
  00034	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00037	89 4d f0	 mov	 DWORD PTR _section2$[ebp], ecx

; 2791 : 	section3 = GETSECSPECIAL(sector->special, 3);

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0003d	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00041	c1 f9 08	 sar	 ecx, 8
  00044	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00047	89 4d ec	 mov	 DWORD PTR _section3$[ebp], ecx

; 2792 : 	section4 = GETSECSPECIAL(sector->special, 4);

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0004d	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00051	c1 f9 0c	 sar	 ecx, 12			; 0000000cH
  00054	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00057	89 4d e8	 mov	 DWORD PTR _section4$[ebp], ecx

; 2793 : 
; 2794 : 	// Ignore spectators
; 2795 : 	if (player->spectator)

  0005a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0005d	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR [eax+496]
  00064	85 c9		 test	 ecx, ecx
  00066	74 05		 je	 SHORT $LN43@P_ProcessS

; 2796 : 		return;

  00068	e9 b1 27 00 00	 jmp	 $LN17@P_ProcessS
$LN43@P_ProcessS:

; 2797 : 
; 2798 : 	// Conveyor stuff
; 2799 : 	if (section3 == 2 || section3 == 4)

  0006d	83 7d ec 02	 cmp	 DWORD PTR _section3$[ebp], 2
  00071	74 06		 je	 SHORT $LN45@P_ProcessS
  00073	83 7d ec 04	 cmp	 DWORD PTR _section3$[ebp], 4
  00077	75 0c		 jne	 SHORT $LN44@P_ProcessS
$LN45@P_ProcessS:

; 2800 : 		player->onconveyor = section3;

  00079	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR _section3$[ebp]
  0007f	89 88 e4 01 00
	00		 mov	 DWORD PTR [eax+484], ecx
$LN44@P_ProcessS:

; 2801 : 
; 2802 : 	special = section1;

  00085	8b 45 f4	 mov	 eax, DWORD PTR _section1$[ebp]
  00088	89 45 e4	 mov	 DWORD PTR _special$[ebp], eax

; 2803 : 
; 2804 : 	// Process Section 1
; 2805 : 	switch (special)

  0008b	8b 45 e4	 mov	 eax, DWORD PTR _special$[ebp]
  0008e	89 85 40 fe ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  00094	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  0009a	83 e9 01	 sub	 ecx, 1
  0009d	89 8d 40 fe ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
  000a3	83 bd 40 fe ff
	ff 0b		 cmp	 DWORD PTR tv85[ebp], 11	; 0000000bH
  000aa	0f 87 77 05 00
	00		 ja	 $LN2@P_ProcessS
  000b0	8b 95 40 fe ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  000b6	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN280@P_ProcessS[edx*4]
$LN46@P_ProcessS:

; 2806 : 	{
; 2807 : 		case 1: // Damage (Generic)
; 2808 : 			P_DamageMobj(player->mo, NULL, NULL, 1);

  000bd	6a 01		 push	 1
  000bf	6a 00		 push	 0
  000c1	6a 00		 push	 0
  000c3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _P_DamageMobj
  000ce	83 c4 10	 add	 esp, 16			; 00000010H

; 2809 : 			break;

  000d1	e9 51 05 00 00	 jmp	 $LN2@P_ProcessS
$LN47@P_ProcessS:

; 2810 : 		case 2: // Damage (Water)
; 2811 : 			if ((player->powers[pw_underwater] || player->pflags & PF_NIGHTSMODE) && !player->powers[pw_watershield])

  000d6	b8 04 00 00 00	 mov	 eax, 4
  000db	6b c8 06	 imul	 ecx, eax, 6
  000de	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  000e1	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  000e6	75 11		 jne	 SHORT $LN49@P_ProcessS
  000e8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000eb	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  000f1	81 e1 00 00 20
	00		 and	 ecx, 2097152		; 00200000H
  000f7	74 26		 je	 SHORT $LN48@P_ProcessS
$LN49@P_ProcessS:
  000f9	b8 04 00 00 00	 mov	 eax, 4
  000fe	6b c8 0b	 imul	 ecx, eax, 11
  00101	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00104	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  00109	75 14		 jne	 SHORT $LN48@P_ProcessS

; 2812 : 				P_DamageMobj(player->mo, NULL, NULL, 1);

  0010b	6a 01		 push	 1
  0010d	6a 00		 push	 0
  0010f	6a 00		 push	 0
  00111	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00114	8b 08		 mov	 ecx, DWORD PTR [eax]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 _P_DamageMobj
  0011c	83 c4 10	 add	 esp, 16			; 00000010H
$LN48@P_ProcessS:

; 2813 : 			break;

  0011f	e9 03 05 00 00	 jmp	 $LN2@P_ProcessS
$LN50@P_ProcessS:

; 2814 : 		case 3: // Damage (Fire)
; 2815 : 			if (!player->powers[pw_watershield])

  00124	b8 04 00 00 00	 mov	 eax, 4
  00129	6b c8 0b	 imul	 ecx, eax, 11
  0012c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0012f	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  00134	75 14		 jne	 SHORT $LN51@P_ProcessS

; 2816 : 				P_DamageMobj(player->mo, NULL, NULL, 1);

  00136	6a 01		 push	 1
  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0013f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _P_DamageMobj
  00147	83 c4 10	 add	 esp, 16			; 00000010H
$LN51@P_ProcessS:

; 2817 : 			break;

  0014a	e9 d8 04 00 00	 jmp	 $LN2@P_ProcessS
$LN52@P_ProcessS:

; 2818 : 		case 4: // Damage (Electrical)
; 2819 : 			if (!player->powers[pw_watershield])

  0014f	b8 04 00 00 00	 mov	 eax, 4
  00154	6b c8 0b	 imul	 ecx, eax, 11
  00157	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0015a	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  0015f	75 14		 jne	 SHORT $LN53@P_ProcessS

; 2820 : 				P_DamageMobj(player->mo, NULL, NULL, 1);

  00161	6a 01		 push	 1
  00163	6a 00		 push	 0
  00165	6a 00		 push	 0
  00167	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _P_DamageMobj
  00172	83 c4 10	 add	 esp, 16			; 00000010H
$LN53@P_ProcessS:

; 2821 : 			break;

  00175	e9 ad 04 00 00	 jmp	 $LN2@P_ProcessS

; 2822 : 		case 5: // Spikes
; 2823 : 			// Don't do anything. In Soviet Russia, spikes find you.
; 2824 : 			break;

  0017a	e9 a8 04 00 00	 jmp	 $LN2@P_ProcessS
$LN55@P_ProcessS:

; 2825 : 		case 6: // Death Pit (Camera Mod)
; 2826 : 			P_DamageMobj(player->mo, NULL, NULL, 10000);

  0017f	68 10 27 00 00	 push	 10000			; 00002710H
  00184	6a 00		 push	 0
  00186	6a 00		 push	 0
  00188	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0018b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _P_DamageMobj
  00193	83 c4 10	 add	 esp, 16			; 00000010H

; 2827 : 			break;

  00196	e9 8c 04 00 00	 jmp	 $LN2@P_ProcessS
$LN56@P_ProcessS:

; 2828 : 		case 7: // Death Pit (No Camera Mod)
; 2829 : 			P_DamageMobj(player->mo, NULL, NULL, 10000);

  0019b	68 10 27 00 00	 push	 10000			; 00002710H
  001a0	6a 00		 push	 0
  001a2	6a 00		 push	 0
  001a4	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 _P_DamageMobj
  001af	83 c4 10	 add	 esp, 16			; 00000010H

; 2830 : 			break;

  001b2	e9 70 04 00 00	 jmp	 $LN2@P_ProcessS
$LN57@P_ProcessS:

; 2831 : 		case 8: // Instant Kill
; 2832 : 			P_DamageMobj(player->mo, NULL, NULL, 10000);

  001b7	68 10 27 00 00	 push	 10000			; 00002710H
  001bc	6a 00		 push	 0
  001be	6a 00		 push	 0
  001c0	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 _P_DamageMobj
  001cb	83 c4 10	 add	 esp, 16			; 00000010H

; 2833 : 			break;

  001ce	e9 54 04 00 00	 jmp	 $LN2@P_ProcessS
$LN58@P_ProcessS:

; 2834 : 		case 9: // Ring Drainer (Floor Touch)
; 2835 : 		case 10: // Ring Drainer (No Floor Touch)
; 2836 : 			if (leveltime % (TICRATE/2) == 0 && player->mo->health > 1)

  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  001d8	33 d2		 xor	 edx, edx
  001da	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  001df	f7 f1		 div	 ecx
  001e1	85 d2		 test	 edx, edx
  001e3	75 46		 jne	 SHORT $LN60@P_ProcessS
  001e5	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ea	83 b9 8c 00 00
	00 01		 cmp	 DWORD PTR [ecx+140], 1
  001f1	7e 38		 jle	 SHORT $LN60@P_ProcessS

; 2837 : 			{
; 2838 : 				player->mo->health--;

  001f3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f8	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  001fe	83 ea 01	 sub	 edx, 1
  00201	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00204	8b 08		 mov	 ecx, DWORD PTR [eax]
  00206	89 91 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], edx

; 2839 : 				player->health--;

  0020c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0020f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00212	83 e9 01	 sub	 ecx, 1
  00215	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00218	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 2840 : 				S_StartSound(player->mo, sfx_itemup);

  0021b	6a 53		 push	 83			; 00000053H
  0021d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00220	8b 08		 mov	 ecx, DWORD PTR [eax]
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 _S_StartSound
  00228	83 c4 08	 add	 esp, 8
$LN60@P_ProcessS:

; 2841 : 			}
; 2842 : 			break;

  0022b	e9 f7 03 00 00	 jmp	 $LN2@P_ProcessS
$LN61@P_ProcessS:

; 2843 : 		case 11: // Special Stage Damage - Kind of like a mini-P_DamageMobj()
; 2844 : 			if (player->powers[pw_invulnerability] || player->powers[pw_super] || player->exiting)

  00230	b8 04 00 00 00	 mov	 eax, 4
  00235	6b c8 00	 imul	 ecx, eax, 0
  00238	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0023b	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  00240	75 1e		 jne	 SHORT $LN63@P_ProcessS
  00242	b8 04 00 00 00	 mov	 eax, 4
  00247	6b c8 0f	 imul	 ecx, eax, 15
  0024a	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0024d	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  00252	75 0c		 jne	 SHORT $LN63@P_ProcessS
  00254	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00257	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [eax+304], 0
  0025e	74 05		 je	 SHORT $LN62@P_ProcessS
$LN63@P_ProcessS:

; 2845 : 				break;

  00260	e9 c2 03 00 00	 jmp	 $LN2@P_ProcessS
$LN62@P_ProcessS:

; 2846 : 
; 2847 : 			if (player->powers[pw_forceshield] || player->powers[pw_ringshield] || player->powers[pw_jumpshield] || player->powers[pw_watershield] || player->powers[pw_bombshield])

  00265	b8 04 00 00 00	 mov	 eax, 4
  0026a	c1 e0 02	 shl	 eax, 2
  0026d	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00270	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00275	75 4c		 jne	 SHORT $LN65@P_ProcessS
  00277	b8 04 00 00 00	 mov	 eax, 4
  0027c	6b c8 09	 imul	 ecx, eax, 9
  0027f	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00282	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  00287	75 3a		 jne	 SHORT $LN65@P_ProcessS
  00289	b8 04 00 00 00	 mov	 eax, 4
  0028e	6b c8 03	 imul	 ecx, eax, 3
  00291	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00294	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  00299	75 28		 jne	 SHORT $LN65@P_ProcessS
  0029b	b8 04 00 00 00	 mov	 eax, 4
  002a0	6b c8 0b	 imul	 ecx, eax, 11
  002a3	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  002a6	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  002ab	75 16		 jne	 SHORT $LN65@P_ProcessS
  002ad	b8 04 00 00 00	 mov	 eax, 4
  002b2	6b c8 0a	 imul	 ecx, eax, 10
  002b5	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  002b8	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  002bd	0f 84 f0 01 00
	00		 je	 $LN70@P_ProcessS
$LN65@P_ProcessS:

; 2848 : 			{
; 2849 : 				if (player->powers[pw_forceshield] > 0) // Multi-hit

  002c3	b8 04 00 00 00	 mov	 eax, 4
  002c8	c1 e0 02	 shl	 eax, 2
  002cb	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  002ce	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  002d3	7e 21		 jle	 SHORT $LN66@P_ProcessS

; 2850 : 					player->powers[pw_forceshield]--;

  002d5	b8 04 00 00 00	 mov	 eax, 4
  002da	c1 e0 02	 shl	 eax, 2
  002dd	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  002e0	8b 54 01 38	 mov	 edx, DWORD PTR [ecx+eax+56]
  002e4	83 ea 01	 sub	 edx, 1
  002e7	b8 04 00 00 00	 mov	 eax, 4
  002ec	c1 e0 02	 shl	 eax, 2
  002ef	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  002f2	89 54 01 38	 mov	 DWORD PTR [ecx+eax+56], edx
$LN66@P_ProcessS:

; 2851 : 
; 2852 : 				player->powers[pw_jumpshield] = false;

  002f6	b8 04 00 00 00	 mov	 eax, 4
  002fb	6b c8 03	 imul	 ecx, eax, 3
  002fe	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00301	c7 44 0a 38 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+56], 0

; 2853 : 				player->powers[pw_watershield] = false;

  00309	b8 04 00 00 00	 mov	 eax, 4
  0030e	6b c8 0b	 imul	 ecx, eax, 11
  00311	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00314	c7 44 0a 38 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+56], 0

; 2854 : 				player->powers[pw_ringshield] = false;

  0031c	b8 04 00 00 00	 mov	 eax, 4
  00321	6b c8 09	 imul	 ecx, eax, 9
  00324	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00327	c7 44 0a 38 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+56], 0

; 2855 : 
; 2856 : 				if (player->powers[pw_bombshield]) // Give them what's coming to them!

  0032f	b8 04 00 00 00	 mov	 eax, 4
  00334	6b c8 0a	 imul	 ecx, eax, 10
  00337	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0033a	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  0033f	74 35		 je	 SHORT $LN67@P_ProcessS

; 2857 : 				{
; 2858 : 					player->blackow = 1; // BAM!

  00341	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00344	c7 80 34 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+308], 1

; 2859 : 					player->powers[pw_bombshield] = false;

  0034e	b8 04 00 00 00	 mov	 eax, 4
  00353	6b c8 0a	 imul	 ecx, eax, 10
  00356	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00359	c7 44 0a 38 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+56], 0

; 2860 : 					player->pflags |= PF_JUMPDOWN;

  00361	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00364	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0036a	83 c9 08	 or	 ecx, 8
  0036d	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00370	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx
$LN67@P_ProcessS:

; 2861 : 				}
; 2862 : 				player->mo->z++;

  00376	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00379	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0037e	83 c2 01	 add	 edx, 1
  00381	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00384	8b 08		 mov	 ecx, DWORD PTR [eax]
  00386	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 2863 : 
; 2864 : 				if (player->mo->eflags & MFE_UNDERWATER)

  00389	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0038c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0038e	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00394	83 e2 08	 and	 edx, 8
  00397	74 1c		 je	 SHORT $LN68@P_ProcessS

; 2865 : 					player->mo->momz = FixedDiv(10511*FRACUNIT,2600*FRACUNIT);

  00399	68 00 00 28 0a	 push	 170393600		; 0a280000H
  0039e	68 00 00 0f 29	 push	 688848896		; 290f0000H
  003a3	e8 00 00 00 00	 call	 _FixedDiv
  003a8	83 c4 08	 add	 esp, 8
  003ab	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  003ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b0	89 42 50	 mov	 DWORD PTR [edx+80], eax
  003b3	eb 1a		 jmp	 SHORT $LN69@P_ProcessS
$LN68@P_ProcessS:

; 2866 : 				else
; 2867 : 					player->mo->momz = FixedDiv(69*FRACUNIT,10*FRACUNIT);

  003b5	68 00 00 0a 00	 push	 655360			; 000a0000H
  003ba	68 00 00 45 00	 push	 4521984			; 00450000H
  003bf	e8 00 00 00 00	 call	 _FixedDiv
  003c4	83 c4 08	 add	 esp, 8
  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  003ca	8b 11		 mov	 edx, DWORD PTR [ecx]
  003cc	89 42 50	 mov	 DWORD PTR [edx+80], eax
$LN69@P_ProcessS:

; 2868 : 
; 2869 : 				P_InstaThrust(player->mo, player->mo->angle-ANGLE_180, 4*FRACUNIT);

  003cf	68 00 00 04 00	 push	 262144			; 00040000H
  003d4	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d9	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  003dc	81 ea 00 00 00
	80		 sub	 edx, -2147483648	; 80000000H
  003e2	52		 push	 edx
  003e3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e8	51		 push	 ecx
  003e9	e8 00 00 00 00	 call	 _P_InstaThrust
  003ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2870 : 
; 2871 : 				P_SetPlayerMobjState(player->mo, player->mo->info->painstate);

  003f1	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f6	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  003fc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  003ff	50		 push	 eax
  00400	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00403	8b 11		 mov	 edx, DWORD PTR [ecx]
  00405	52		 push	 edx
  00406	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  0040b	83 c4 08	 add	 esp, 8

; 2872 : 				player->powers[pw_flashing] = flashingtics;

  0040e	b8 04 00 00 00	 mov	 eax, 4
  00413	d1 e0		 shl	 eax, 1
  00415	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00418	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _flashingtics
  0041e	89 54 01 38	 mov	 DWORD PTR [ecx+eax+56], edx

; 2873 : 
; 2874 : 				player->powers[pw_fireflower] = false;

  00422	b8 04 00 00 00	 mov	 eax, 4
  00427	6b c8 11	 imul	 ecx, eax, 17
  0042a	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0042d	c7 44 0a 38 00
	00 00 00	 mov	 DWORD PTR [edx+ecx+56], 0

; 2875 : 				player->mo->flags |= MF_TRANSLATION;

  00435	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00438	8b 08		 mov	 ecx, DWORD PTR [eax]
  0043a	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0043d	81 ca 00 00 00
	04		 or	 edx, 67108864		; 04000000H
  00443	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00446	8b 08		 mov	 ecx, DWORD PTR [eax]
  00448	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 2876 : 				player->mo->color = (UINT8)player->skincolor;

  0044b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0044e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00450	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00453	8a 82 b4 00 00
	00		 mov	 al, BYTE PTR [edx+180]
  00459	88 41 68	 mov	 BYTE PTR [ecx+104], al

; 2877 : 
; 2878 : 				P_ResetPlayer(player);

  0045c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0045f	50		 push	 eax
  00460	e8 00 00 00 00	 call	 _P_ResetPlayer
  00465	83 c4 04	 add	 esp, 4

; 2879 : 
; 2880 : 				S_StartSound(player->mo, sfx_shldls); // Ba-Dum! Shield loss.

  00468	68 d1 00 00 00	 push	 209			; 000000d1H
  0046d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00470	8b 08		 mov	 ecx, DWORD PTR [eax]
  00472	51		 push	 ecx
  00473	e8 00 00 00 00	 call	 _S_StartSound
  00478	83 c4 08	 add	 esp, 8

; 2881 : 
; 2882 : 				if (gametype == GT_CTF && (player->gotflag & MF_REDFLAG || player->gotflag & MF_BLUEFLAG))

  0047b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00482	83 f8 04	 cmp	 eax, 4
  00485	75 2c		 jne	 SHORT $LN70@P_ProcessS
  00487	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0048a	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  00491	83 e1 01	 and	 ecx, 1
  00494	75 0f		 jne	 SHORT $LN71@P_ProcessS
  00496	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00499	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  004a0	83 e1 02	 and	 ecx, 2
  004a3	74 0e		 je	 SHORT $LN70@P_ProcessS
$LN71@P_ProcessS:

; 2883 : 					P_PlayerFlagBurst(player, false);

  004a5	6a 00		 push	 0
  004a7	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  004aa	50		 push	 eax
  004ab	e8 00 00 00 00	 call	 _P_PlayerFlagBurst
  004b0	83 c4 08	 add	 esp, 8
$LN70@P_ProcessS:

; 2884 : 			}
; 2885 : 			if (player->mo->health > 1)

  004b3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  004b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b8	83 b9 8c 00 00
	00 01		 cmp	 DWORD PTR [ecx+140], 1
  004bf	0f 8e 25 01 00
	00		 jle	 $LN72@P_ProcessS

; 2886 : 			{
; 2887 : 				if (player->powers[pw_flashing])

  004c5	b8 04 00 00 00	 mov	 eax, 4
  004ca	d1 e0		 shl	 eax, 1
  004cc	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  004cf	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  004d4	74 05		 je	 SHORT $LN73@P_ProcessS

; 2888 : 					return;

  004d6	e9 43 23 00 00	 jmp	 $LN17@P_ProcessS
$LN73@P_ProcessS:

; 2889 : 				player->powers[pw_flashing] = flashingtics;

  004db	b8 04 00 00 00	 mov	 eax, 4
  004e0	d1 e0		 shl	 eax, 1
  004e2	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  004e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _flashingtics
  004eb	89 54 01 38	 mov	 DWORD PTR [ecx+eax+56], edx

; 2890 : 				P_PlayRinglossSound(player->mo);

  004ef	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  004f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f4	51		 push	 ecx
  004f5	e8 00 00 00 00	 call	 _P_PlayRinglossSound
  004fa	83 c4 04	 add	 esp, 4

; 2891 : 				if (player->mo->health > 10)

  004fd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00500	8b 08		 mov	 ecx, DWORD PTR [eax]
  00502	83 b9 8c 00 00
	00 0a		 cmp	 DWORD PTR [ecx+140], 10	; 0000000aH
  00509	7e 1b		 jle	 SHORT $LN74@P_ProcessS

; 2892 : 					player->mo->health -= 10;

  0050b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0050e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00510	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00516	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00519	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0051c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051e	89 91 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], edx
  00524	eb 0f		 jmp	 SHORT $LN75@P_ProcessS
$LN74@P_ProcessS:

; 2893 : 				else
; 2894 : 					player->mo->health = 1;

  00526	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00529	8b 08		 mov	 ecx, DWORD PTR [eax]
  0052b	c7 81 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+140], 1
$LN75@P_ProcessS:

; 2895 : 				player->health = player->mo->health;

  00535	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00538	8b 08		 mov	 ecx, DWORD PTR [eax]
  0053a	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0053d	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  00543	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 2896 : 				player->mo->z++;

  00546	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00549	8b 08		 mov	 ecx, DWORD PTR [eax]
  0054b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0054e	83 c2 01	 add	 edx, 1
  00551	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00554	8b 08		 mov	 ecx, DWORD PTR [eax]
  00556	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 2897 : 				if (player->mo->eflags & MFE_UNDERWATER)

  00559	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0055c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055e	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00564	83 e2 08	 and	 edx, 8
  00567	74 1c		 je	 SHORT $LN76@P_ProcessS

; 2898 : 					player->mo->momz = FixedDiv(10511*FRACUNIT,2600*FRACUNIT);

  00569	68 00 00 28 0a	 push	 170393600		; 0a280000H
  0056e	68 00 00 0f 29	 push	 688848896		; 290f0000H
  00573	e8 00 00 00 00	 call	 _FixedDiv
  00578	83 c4 08	 add	 esp, 8
  0057b	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0057e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00580	89 42 50	 mov	 DWORD PTR [edx+80], eax
  00583	eb 1a		 jmp	 SHORT $LN77@P_ProcessS
$LN76@P_ProcessS:

; 2899 : 				else
; 2900 : 					player->mo->momz = FixedDiv(69*FRACUNIT,10*FRACUNIT);

  00585	68 00 00 0a 00	 push	 655360			; 000a0000H
  0058a	68 00 00 45 00	 push	 4521984			; 00450000H
  0058f	e8 00 00 00 00	 call	 _FixedDiv
  00594	83 c4 08	 add	 esp, 8
  00597	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0059a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0059c	89 42 50	 mov	 DWORD PTR [edx+80], eax
$LN77@P_ProcessS:

; 2901 : 				P_InstaThrust (player->mo, player->mo->angle - ANGLE_180, 4*FRACUNIT);

  0059f	68 00 00 04 00	 push	 262144			; 00040000H
  005a4	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  005a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  005a9	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  005ac	81 ea 00 00 00
	80		 sub	 edx, -2147483648	; 80000000H
  005b2	52		 push	 edx
  005b3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  005b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  005b8	51		 push	 ecx
  005b9	e8 00 00 00 00	 call	 _P_InstaThrust
  005be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2902 : 				P_ResetPlayer(player);

  005c1	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  005c4	50		 push	 eax
  005c5	e8 00 00 00 00	 call	 _P_ResetPlayer
  005ca	83 c4 04	 add	 esp, 4

; 2903 : 				P_SetPlayerMobjState(player->mo, player->mo->info->painstate);

  005cd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  005d0	8b 08		 mov	 ecx, DWORD PTR [eax]
  005d2	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  005d8	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  005db	50		 push	 eax
  005dc	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  005df	8b 11		 mov	 edx, DWORD PTR [ecx]
  005e1	52		 push	 edx
  005e2	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  005e7	83 c4 08	 add	 esp, 8
$LN72@P_ProcessS:

; 2904 : 			}
; 2905 : 			break;

  005ea	eb 3b		 jmp	 SHORT $LN2@P_ProcessS
$LN78@P_ProcessS:

; 2906 : 		case 12: // Space Countdown
; 2907 : 			if (!player->powers[pw_watershield] && !player->powers[pw_spacetime])

  005ec	b8 04 00 00 00	 mov	 eax, 4
  005f1	6b c8 0b	 imul	 ecx, eax, 11
  005f4	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  005f7	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  005fc	75 29		 jne	 SHORT $LN79@P_ProcessS
  005fe	b8 04 00 00 00	 mov	 eax, 4
  00603	6b c8 07	 imul	 ecx, eax, 7
  00606	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00609	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  0060e	75 17		 jne	 SHORT $LN79@P_ProcessS

; 2908 : 			{
; 2909 : 				player->powers[pw_spacetime] = spacetimetics + 1;

  00610	a1 00 00 00 00	 mov	 eax, DWORD PTR _spacetimetics
  00615	83 c0 01	 add	 eax, 1
  00618	b9 04 00 00 00	 mov	 ecx, 4
  0061d	6b d1 07	 imul	 edx, ecx, 7
  00620	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00623	89 44 11 38	 mov	 DWORD PTR [ecx+edx+56], eax
$LN79@P_ProcessS:
$LN2@P_ProcessS:

; 2910 : 			}
; 2911 : 			break;
; 2912 : 		case 13: // Ramp Sector (Increase step-up)
; 2913 : 		case 14: // Non-Ramp Sector (Don't step-down)
; 2914 : 		case 15: // Bouncy Sector (FOF Control Only)
; 2915 : 			break;
; 2916 : 	}
; 2917 : 
; 2918 : 	special = section2;

  00627	8b 45 f0	 mov	 eax, DWORD PTR _section2$[ebp]
  0062a	89 45 e4	 mov	 DWORD PTR _special$[ebp], eax

; 2919 : 
; 2920 : 	// Process Section 2
; 2921 : 	switch (special)

  0062d	8b 45 e4	 mov	 eax, DWORD PTR _special$[ebp]
  00630	89 85 40 fe ff
	ff		 mov	 DWORD PTR tv393[ebp], eax
  00636	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv393[ebp]
  0063c	83 e9 02	 sub	 ecx, 2
  0063f	89 8d 40 fe ff
	ff		 mov	 DWORD PTR tv393[ebp], ecx
  00645	83 bd 40 fe ff
	ff 07		 cmp	 DWORD PTR tv393[ebp], 7
  0064c	0f 87 d3 01 00
	00		 ja	 $DoneSection2$283
  00652	8b 95 40 fe ff
	ff		 mov	 edx, DWORD PTR tv393[ebp]
  00658	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN281@P_ProcessS[edx*4]

; 2922 : 	{
; 2923 : 		case 1: // Trigger Linedef Exec (Pushable Objects)
; 2924 : 			break;

  0065f	e9 c1 01 00 00	 jmp	 $DoneSection2$283
$LN84@P_ProcessS:

; 2925 : 		case 2: // Linedef executor requires all players present+doesn't require touching floor
; 2926 : 		case 3: // Linedef executor requires all players present
; 2927 : 			/// \todo take FOFs into account (+continues for proper splitscreen support?)
; 2928 : 			for (i = 0; i < MAXPLAYERS; i++)

  00664	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0066b	eb 09		 jmp	 SHORT $LN8@P_ProcessS
$LN6@P_ProcessS:
  0066d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00670	83 c0 01	 add	 eax, 1
  00673	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN8@P_ProcessS:
  00676	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0067a	7d 7e		 jge	 SHORT $LN7@P_ProcessS

; 2929 : 				if (playeringame[i] && players[i].mo && (gametype != GT_COOP || players[i].lives > 0) && !(P_PlayerTouchingSectorSpecial(&players[i], 2, 3) == sector || P_PlayerTouchingSectorSpecial(&players[i], 2, 2) == sector))

  0067c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0067f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00687	74 6c		 je	 SHORT $LN86@P_ProcessS
  00689	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00690	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00697	74 5c		 je	 SHORT $LN86@P_ProcessS
  00699	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  006a0	85 c0		 test	 eax, eax
  006a2	75 10		 jne	 SHORT $LN87@P_ProcessS
  006a4	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  006ab	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR _players[eax+256], 0
  006b2	7e 41		 jle	 SHORT $LN86@P_ProcessS
$LN87@P_ProcessS:
  006b4	6a 03		 push	 3
  006b6	6a 02		 push	 2
  006b8	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  006bf	05 00 00 00 00	 add	 eax, OFFSET _players
  006c4	50		 push	 eax
  006c5	e8 00 00 00 00	 call	 _P_PlayerTouchingSectorSpecial
  006ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  006cd	3b 45 0c	 cmp	 eax, DWORD PTR _sector$[ebp]
  006d0	74 23		 je	 SHORT $LN86@P_ProcessS
  006d2	6a 02		 push	 2
  006d4	6a 02		 push	 2
  006d6	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  006dd	05 00 00 00 00	 add	 eax, OFFSET _players
  006e2	50		 push	 eax
  006e3	e8 00 00 00 00	 call	 _P_PlayerTouchingSectorSpecial
  006e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  006eb	3b 45 0c	 cmp	 eax, DWORD PTR _sector$[ebp]
  006ee	74 05		 je	 SHORT $LN86@P_ProcessS

; 2930 : 					goto DoneSection2;

  006f0	e9 30 01 00 00	 jmp	 $DoneSection2$283
$LN86@P_ProcessS:
  006f5	e9 73 ff ff ff	 jmp	 $LN6@P_ProcessS
$LN7@P_ProcessS:

; 2931 : 		case 4: // Linedef executor that doesn't require touching floor
; 2932 : 		case 5: // Linedef executor
; 2933 : 		case 6: // Linedef executor (7 Emeralds)
; 2934 : 		case 7: // Linedef executor (NiGHTS Mare)
; 2935 : 			P_LinedefExecute(sector->tag, player->mo, sector);

  006fa	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  006fd	50		 push	 eax
  006fe	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00701	8b 11		 mov	 edx, DWORD PTR [ecx]
  00703	52		 push	 edx
  00704	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00707	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  0070b	51		 push	 ecx
  0070c	e8 00 00 00 00	 call	 _P_LinedefExecute
  00711	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2936 : 			break;

  00714	e9 0c 01 00 00	 jmp	 $DoneSection2$283

; 2937 : 		case 8: // Tells pushable things to check FOFs
; 2938 : 			break;

  00719	e9 07 01 00 00	 jmp	 $DoneSection2$283
$LN93@P_ProcessS:

; 2939 : 		case 9: // Egg trap capsule
; 2940 : 		{
; 2941 : 			thinker_t *th;
; 2942 : 			mobj_t *mo2;
; 2943 : 			line_t junk;
; 2944 : 
; 2945 : 			if (sector->ceilingdata || sector->floordata)

  0071e	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00721	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00725	75 09		 jne	 SHORT $LN95@P_ProcessS
  00727	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0072a	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0072e	74 05		 je	 SHORT $LN94@P_ProcessS
$LN95@P_ProcessS:

; 2946 : 				return;

  00730	e9 e9 20 00 00	 jmp	 $LN17@P_ProcessS
$LN94@P_ProcessS:

; 2947 : 			junk.tag = 680;

  00735	b8 a8 02 00 00	 mov	 eax, 680		; 000002a8H
  0073a	66 89 45 a4	 mov	 WORD PTR _junk$42[ebp+20], ax

; 2948 : 			EV_DoElevator(&junk, elevateDown, false);

  0073e	6a 00		 push	 0
  00740	6a 01		 push	 1
  00742	8d 45 90	 lea	 eax, DWORD PTR _junk$42[ebp]
  00745	50		 push	 eax
  00746	e8 00 00 00 00	 call	 _EV_DoElevator
  0074b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2949 : 			junk.tag = 681;

  0074e	b8 a9 02 00 00	 mov	 eax, 681		; 000002a9H
  00753	66 89 45 a4	 mov	 WORD PTR _junk$42[ebp+20], ax

; 2950 : 			EV_DoFloor(&junk, raiseFloorToNearestFast);

  00757	6a 01		 push	 1
  00759	8d 45 90	 lea	 eax, DWORD PTR _junk$42[ebp]
  0075c	50		 push	 eax
  0075d	e8 00 00 00 00	 call	 _EV_DoFloor
  00762	83 c4 08	 add	 esp, 8

; 2951 : 			junk.tag = 682;

  00765	b8 aa 02 00 00	 mov	 eax, 682		; 000002aaH
  0076a	66 89 45 a4	 mov	 WORD PTR _junk$42[ebp+20], ax

; 2952 : 			EV_DoCeiling(&junk, lowerToLowestFast);

  0076e	6a 03		 push	 3
  00770	8d 45 90	 lea	 eax, DWORD PTR _junk$42[ebp]
  00773	50		 push	 eax
  00774	e8 00 00 00 00	 call	 _EV_DoCeiling
  00779	83 c4 08	 add	 esp, 8

; 2953 : 			sector->special = 0;

  0077c	33 c0		 xor	 eax, eax
  0077e	8b 4d 0c	 mov	 ecx, DWORD PTR _sector$[ebp]
  00781	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 2954 : 
; 2955 : 			// Find the center of the Eggtrap and release all the pretty animals!
; 2956 : 			// The chimps are my friends.. heeheeheheehehee..... - LouisJM
; 2957 : 			for (th = thinkercap.next; th != &thinkercap; th = th->next)

  00785	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0078a	89 45 e0	 mov	 DWORD PTR _th$44[ebp], eax
  0078d	eb 09		 jmp	 SHORT $LN11@P_ProcessS
$LN9@P_ProcessS:
  0078f	8b 45 e0	 mov	 eax, DWORD PTR _th$44[ebp]
  00792	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00795	89 4d e0	 mov	 DWORD PTR _th$44[ebp], ecx
$LN11@P_ProcessS:
  00798	81 7d e0 00 00
	00 00		 cmp	 DWORD PTR _th$44[ebp], OFFSET _thinkercap
  0079f	0f 84 80 00 00
	00		 je	 $LN10@P_ProcessS

; 2958 : 			{
; 2959 : 				if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  007a5	8b 45 e0	 mov	 eax, DWORD PTR _th$44[ebp]
  007a8	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  007af	74 02		 je	 SHORT $LN96@P_ProcessS

; 2960 : 					continue;

  007b1	eb dc		 jmp	 SHORT $LN9@P_ProcessS
$LN96@P_ProcessS:

; 2961 : 
; 2962 : 				mo2 = (mobj_t *)th;

  007b3	8b 45 e0	 mov	 eax, DWORD PTR _th$44[ebp]
  007b6	89 45 dc	 mov	 DWORD PTR _mo2$43[ebp], eax

; 2963 : 				if (mo2->type == MT_EGGTRAP)

  007b9	8b 45 dc	 mov	 eax, DWORD PTR _mo2$43[ebp]
  007bc	83 78 7c 1b	 cmp	 DWORD PTR [eax+124], 27	; 0000001bH
  007c0	75 5e		 jne	 SHORT $LN97@P_ProcessS

; 2964 : 				{
; 2965 : 					mo2->fuse = TICRATE*2;

  007c2	8b 45 dc	 mov	 eax, DWORD PTR _mo2$43[ebp]
  007c5	c7 80 bc 00 00
	00 46 00 00 00	 mov	 DWORD PTR [eax+188], 70	; 00000046H

; 2966 : 
; 2967 : 					// Mark all players with the time to exit thingy!
; 2968 : 					for (i = 0; i < MAXPLAYERS; i++)

  007cf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  007d6	eb 09		 jmp	 SHORT $LN14@P_ProcessS
$LN12@P_ProcessS:
  007d8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  007db	83 c0 01	 add	 eax, 1
  007de	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN14@P_ProcessS:
  007e1	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  007e5	7d 17		 jge	 SHORT $LN13@P_ProcessS

; 2969 : 						P_DoPlayerExit(&players[i]);

  007e7	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  007ee	05 00 00 00 00	 add	 eax, OFFSET _players
  007f3	50		 push	 eax
  007f4	e8 00 00 00 00	 call	 _P_DoPlayerExit
  007f9	83 c4 04	 add	 esp, 4
  007fc	eb da		 jmp	 SHORT $LN12@P_ProcessS
$LN13@P_ProcessS:

; 2970 : 
; 2971 : 					if (player->mo)

  007fe	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00801	83 38 00	 cmp	 DWORD PTR [eax], 0
  00804	74 18		 je	 SHORT $LN98@P_ProcessS

; 2972 : 						P_SetTarget(&player->mo->tracer, mo2);

  00806	8b 45 dc	 mov	 eax, DWORD PTR _mo2$43[ebp]
  00809	50		 push	 eax
  0080a	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0080d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0080f	81 c2 b0 00 00
	00		 add	 edx, 176		; 000000b0H
  00815	52		 push	 edx
  00816	e8 00 00 00 00	 call	 _P_SetTarget
  0081b	83 c4 08	 add	 esp, 8
$LN98@P_ProcessS:

; 2973 : 					break;

  0081e	eb 05		 jmp	 SHORT $LN10@P_ProcessS
$LN97@P_ProcessS:

; 2974 : 				}
; 2975 : 			}

  00820	e9 6a ff ff ff	 jmp	 $LN9@P_ProcessS
$LN10@P_ProcessS:
$DoneSection2$283:

; 2976 : 			break;
; 2977 : 		}
; 2978 : 		case 10: // Special Stage Time/Rings
; 2979 : 		case 11: // Custom Gravity
; 2980 : 			break;
; 2981 : 	}
; 2982 : DoneSection2:
; 2983 : 
; 2984 : 	special = section3;

  00825	8b 45 ec	 mov	 eax, DWORD PTR _section3$[ebp]
  00828	89 45 e4	 mov	 DWORD PTR _special$[ebp], eax

; 2985 : 
; 2986 : 	// Process Section 3
; 2987 : 	switch (special)

  0082b	8b 45 e4	 mov	 eax, DWORD PTR _special$[ebp]
  0082e	89 85 40 fe ff
	ff		 mov	 DWORD PTR tv461[ebp], eax
  00834	83 bd 40 fe ff
	ff 05		 cmp	 DWORD PTR tv461[ebp], 5
  0083b	74 13		 je	 SHORT $LN105@P_ProcessS
  0083d	83 bd 40 fe ff
	ff 06		 cmp	 DWORD PTR tv461[ebp], 6
  00844	74 0a		 je	 SHORT $LN105@P_ProcessS
  00846	e9 5d 02 00 00	 jmp	 $LN15@P_ProcessS

; 2988 : 	{
; 2989 : 		case 1: // Ice/Sludge
; 2990 : 		case 2: // Wind/Current
; 2991 : 		case 3: // Ice/Sludge and Wind/Current
; 2992 : 		case 4: // Conveyor Belt
; 2993 : 			break;

  0084b	e9 58 02 00 00	 jmp	 $LN15@P_ProcessS
$LN105@P_ProcessS:

; 2994 : 
; 2995 : 		case 5: // Speed pad w/o spin
; 2996 : 		case 6: // Speed pad w/ spin
; 2997 : 			if (player->powers[pw_flashing] != 0 && player->powers[pw_flashing] < TICRATE/2)

  00850	b8 04 00 00 00	 mov	 eax, 4
  00855	d1 e0		 shl	 eax, 1
  00857	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0085a	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  0085f	74 16		 je	 SHORT $LN107@P_ProcessS
  00861	b8 04 00 00 00	 mov	 eax, 4
  00866	d1 e0		 shl	 eax, 1
  00868	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0086b	83 7c 01 38 11	 cmp	 DWORD PTR [ecx+eax+56], 17 ; 00000011H
  00870	7d 05		 jge	 SHORT $LN107@P_ProcessS

; 2998 : 				break;

  00872	e9 31 02 00 00	 jmp	 $LN15@P_ProcessS
$LN107@P_ProcessS:

; 2999 : 
; 3000 : 			i = P_FindSpecialLineFromTag(4, sector->tag, -1);

  00877	6a ff		 push	 -1
  00879	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0087c	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00880	51		 push	 ecx
  00881	6a 04		 push	 4
  00883	e8 00 00 00 00	 call	 _P_FindSpecialLineFromTag
  00888	83 c4 0c	 add	 esp, 12			; 0000000cH
  0088b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 3001 : 
; 3002 : 			if (i != -1)

  0088e	83 7d f8 ff	 cmp	 DWORD PTR _i$[ebp], -1
  00892	0f 84 10 02 00
	00		 je	 $LN108@P_ProcessS

; 3003 : 			{
; 3004 : 				angle_t lineangle;
; 3005 : 				fixed_t linespeed;
; 3006 : 
; 3007 : 				lineangle = R_PointToAngle2(lines[i].v1->x, lines[i].v1->y, lines[i].v2->x, lines[i].v2->y);

  00898	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0089c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  008a2	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  008a6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008a9	50		 push	 eax
  008aa	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  008ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  008b4	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  008b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  008ba	51		 push	 ecx
  008bb	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  008bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  008c4	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  008c7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  008ca	52		 push	 edx
  008cb	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  008cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  008d5	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  008d8	8b 02		 mov	 eax, DWORD PTR [edx]
  008da	50		 push	 eax
  008db	e8 00 00 00 00	 call	 _R_PointToAngle2
  008e0	83 c4 10	 add	 esp, 16			; 00000010H
  008e3	89 45 8c	 mov	 DWORD PTR _lineangle$41[ebp], eax

; 3008 : 				linespeed = P_AproxDistance(lines[i].v2->x-lines[i].v1->x, lines[i].v2->y-lines[i].v1->y);

  008e6	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  008ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  008f0	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  008f4	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  008f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  008fe	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00901	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00904	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00907	51		 push	 ecx
  00908	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  0090c	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  00911	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00915	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  00919	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  0091e	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  00921	8b 01		 mov	 eax, DWORD PTR [ecx]
  00923	2b 02		 sub	 eax, DWORD PTR [edx]
  00925	50		 push	 eax
  00926	e8 00 00 00 00	 call	 _P_AproxDistance
  0092b	83 c4 08	 add	 esp, 8
  0092e	89 45 88	 mov	 DWORD PTR _linespeed$40[ebp], eax

; 3009 : 
; 3010 : 				if (linespeed > MAXMOVE)

  00931	81 7d 88 00 00
	3c 00		 cmp	 DWORD PTR _linespeed$40[ebp], 3932160 ; 003c0000H
  00938	7e 07		 jle	 SHORT $LN109@P_ProcessS

; 3011 : 					linespeed = MAXMOVE;

  0093a	c7 45 88 00 00
	3c 00		 mov	 DWORD PTR _linespeed$40[ebp], 3932160 ; 003c0000H
$LN109@P_ProcessS:

; 3012 : 
; 3013 : 				player->mo->angle = lineangle;

  00941	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00944	8b 08		 mov	 ecx, DWORD PTR [eax]
  00946	8b 55 8c	 mov	 edx, DWORD PTR _lineangle$41[ebp]
  00949	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 3014 : 
; 3015 : 				if (player == &players[consoleplayer])

  0094c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00956	05 00 00 00 00	 add	 eax, OFFSET _players
  0095b	39 45 08	 cmp	 DWORD PTR _player$[ebp], eax
  0095e	75 10		 jne	 SHORT $LN110@P_ProcessS

; 3016 : 					localangle = player->mo->angle;

  00960	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00963	8b 08		 mov	 ecx, DWORD PTR [eax]
  00965	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00968	89 15 00 00 00
	00		 mov	 DWORD PTR _localangle, edx
  0096e	eb 22		 jmp	 SHORT $LN112@P_ProcessS
$LN110@P_ProcessS:

; 3017 : 				else if (player == &players[secondarydisplayplayer])

  00970	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0097a	05 00 00 00 00	 add	 eax, OFFSET _players
  0097f	39 45 08	 cmp	 DWORD PTR _player$[ebp], eax
  00982	75 0e		 jne	 SHORT $LN112@P_ProcessS

; 3018 : 					localangle2 = player->mo->angle;

  00984	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00987	8b 08		 mov	 ecx, DWORD PTR [eax]
  00989	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0098c	89 15 00 00 00
	00		 mov	 DWORD PTR _localangle2, edx
$LN112@P_ProcessS:

; 3019 : 
; 3020 : 				if (!(lines[i].flags & ML_EFFECT4))

  00992	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00996	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0099c	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  009a1	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  009a7	75 5c		 jne	 SHORT $LN113@P_ProcessS

; 3021 : 				{
; 3022 : 					P_UnsetThingPosition(player->mo);

  009a9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  009ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  009ae	51		 push	 ecx
  009af	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  009b4	83 c4 04	 add	 esp, 4

; 3023 : 					if (roversector) // make FOF speed pads work

  009b7	83 7d 10 00	 cmp	 DWORD PTR _roversector$[ebp], 0
  009bb	74 1e		 je	 SHORT $LN114@P_ProcessS

; 3024 : 					{
; 3025 : 						player->mo->x = roversector->soundorg.x;

  009bd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  009c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  009c2	8b 55 10	 mov	 edx, DWORD PTR _roversector$[ebp]
  009c5	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  009c8	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3026 : 						player->mo->y = roversector->soundorg.y;

  009cb	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  009ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d0	8b 55 10	 mov	 edx, DWORD PTR _roversector$[ebp]
  009d3	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  009d6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 3027 : 					}

  009d9	eb 1c		 jmp	 SHORT $LN115@P_ProcessS
$LN114@P_ProcessS:

; 3028 : 					else
; 3029 : 					{
; 3030 : 						player->mo->x = sector->soundorg.x;

  009db	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  009de	8b 08		 mov	 ecx, DWORD PTR [eax]
  009e0	8b 55 0c	 mov	 edx, DWORD PTR _sector$[ebp]
  009e3	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  009e6	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3031 : 						player->mo->y = sector->soundorg.y;

  009e9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  009ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  009ee	8b 55 0c	 mov	 edx, DWORD PTR _sector$[ebp]
  009f1	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  009f4	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN115@P_ProcessS:

; 3032 : 					}
; 3033 : 					P_SetThingPosition(player->mo);

  009f7	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  009fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  009fc	51		 push	 ecx
  009fd	e8 00 00 00 00	 call	 _P_SetThingPosition
  00a02	83 c4 04	 add	 esp, 4
$LN113@P_ProcessS:

; 3034 : 				}
; 3035 : 
; 3036 : 				P_InstaThrust(player->mo, player->mo->angle, linespeed);

  00a05	8b 45 88	 mov	 eax, DWORD PTR _linespeed$40[ebp]
  00a08	50		 push	 eax
  00a09	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00a0c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a0e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00a11	50		 push	 eax
  00a12	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00a15	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a17	52		 push	 edx
  00a18	e8 00 00 00 00	 call	 _P_InstaThrust
  00a1d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3037 : 
; 3038 : 				if (GETSECSPECIAL(sector->special, 3) == 6 && (player->charability2 == CA2_SPINDASH))

  00a20	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00a23	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  00a27	c1 f9 08	 sar	 ecx, 8
  00a2a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00a2d	83 f9 06	 cmp	 ecx, 6
  00a30	75 51		 jne	 SHORT $LN116@P_ProcessS
  00a32	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00a35	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [eax+220], 0
  00a3c	75 45		 jne	 SHORT $LN116@P_ProcessS

; 3039 : 				{
; 3040 : 					if (!(player->pflags & PF_SPINNING))

  00a3e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00a41	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00a47	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  00a4d	75 24		 jne	 SHORT $LN117@P_ProcessS

; 3041 : 					{
; 3042 : 						P_ResetScore(player);

  00a4f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00a52	50		 push	 eax
  00a53	e8 00 00 00 00	 call	 _P_ResetScore
  00a58	83 c4 04	 add	 esp, 4

; 3043 : 						player->pflags |= PF_SPINNING;

  00a5b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00a5e	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00a64	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  00a6a	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00a6d	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx
$LN117@P_ProcessS:

; 3044 : 					}
; 3045 : 
; 3046 : 					P_SetPlayerMobjState(player->mo, S_PLAY_ATK1);

  00a73	6a 0c		 push	 12			; 0000000cH
  00a75	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00a78	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a7a	51		 push	 ecx
  00a7b	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  00a80	83 c4 08	 add	 esp, 8
$LN116@P_ProcessS:

; 3047 : 				}
; 3048 : 
; 3049 : 				player->powers[pw_flashing] = TICRATE/3;

  00a83	b8 04 00 00 00	 mov	 eax, 4
  00a88	d1 e0		 shl	 eax, 1
  00a8a	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00a8d	c7 44 01 38 0b
	00 00 00	 mov	 DWORD PTR [ecx+eax+56], 11 ; 0000000bH

; 3050 : 				S_StartSound(player->mo, sfx_spdpad);

  00a95	68 d2 00 00 00	 push	 210			; 000000d2H
  00a9a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00a9d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a9f	51		 push	 ecx
  00aa0	e8 00 00 00 00	 call	 _S_StartSound
  00aa5	83 c4 08	 add	 esp, 8
$LN108@P_ProcessS:
$LN15@P_ProcessS:

; 3051 : 			}
; 3052 : 			break;
; 3053 : 
; 3054 : 		case 7: // Bustable block sprite parameter
; 3055 : 		case 8:
; 3056 : 		case 9:
; 3057 : 		case 10:
; 3058 : 		case 11:
; 3059 : 		case 12:
; 3060 : 		case 13:
; 3061 : 		case 14:
; 3062 : 		case 15:
; 3063 : 			break;
; 3064 : 	}
; 3065 : 
; 3066 : 	special = section4;

  00aa8	8b 45 e8	 mov	 eax, DWORD PTR _section4$[ebp]
  00aab	89 45 e4	 mov	 DWORD PTR _special$[ebp], eax

; 3067 : 
; 3068 : 	// Process Section 4
; 3069 : 	switch (special)

  00aae	8b 45 e4	 mov	 eax, DWORD PTR _special$[ebp]
  00ab1	89 85 40 fe ff
	ff		 mov	 DWORD PTR tv585[ebp], eax
  00ab7	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv585[ebp]
  00abd	83 e9 01	 sub	 ecx, 1
  00ac0	89 8d 40 fe ff
	ff		 mov	 DWORD PTR tv585[ebp], ecx
  00ac6	83 bd 40 fe ff
	ff 0a		 cmp	 DWORD PTR tv585[ebp], 10 ; 0000000aH
  00acd	0f 87 4b 1d 00
	00		 ja	 $LN17@P_ProcessS
  00ad3	8b 95 40 fe ff
	ff		 mov	 edx, DWORD PTR tv585[ebp]
  00ad9	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN282@P_ProcessS[edx*4]
$LN127@P_ProcessS:

; 3070 : 	{
; 3071 : 		case 1: // Starpost Activator
; 3072 : 		{
; 3073 : 			mobj_t *post = P_GetObjectTypeInSectorNum(MT_STARPOST, sector - sectors);

  00ae0	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00ae3	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00ae9	99		 cdq
  00aea	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00aef	f7 f9		 idiv	 ecx
  00af1	50		 push	 eax
  00af2	6a 4a		 push	 74			; 0000004aH
  00af4	e8 00 00 00 00	 call	 _P_GetObjectTypeInSectorNum
  00af9	83 c4 08	 add	 esp, 8
  00afc	89 45 84	 mov	 DWORD PTR _post$39[ebp], eax

; 3074 : 
; 3075 : 			if (!post)

  00aff	83 7d 84 00	 cmp	 DWORD PTR _post$39[ebp], 0
  00b03	75 05		 jne	 SHORT $LN128@P_ProcessS

; 3076 : 				break;

  00b05	e9 14 1d 00 00	 jmp	 $LN17@P_ProcessS
$LN128@P_ProcessS:

; 3077 : 
; 3078 : 			P_TouchSpecialThing(post, player->mo, false);

  00b0a	6a 00		 push	 0
  00b0c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00b0f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b11	51		 push	 ecx
  00b12	8b 55 84	 mov	 edx, DWORD PTR _post$39[ebp]
  00b15	52		 push	 edx
  00b16	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  00b1b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3079 : 			break;

  00b1e	e9 fb 1c 00 00	 jmp	 $LN17@P_ProcessS
$LN129@P_ProcessS:

; 3080 : 		}
; 3081 : 
; 3082 : 		case 2: // Special stage GOAL sector / Exit Sector / CTF Flag Return
; 3083 : 			if (!useNightsSS && sstimer > 6 && gamemap >= sstage_start && gamemap <= sstage_end)

  00b23	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _useNightsSS, 0
  00b2a	75 37		 jne	 SHORT $LN130@P_ProcessS
  00b2c	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _sstimer, 6
  00b33	7e 2e		 jle	 SHORT $LN130@P_ProcessS
  00b35	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00b3c	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _sstage_start
  00b43	3b c1		 cmp	 eax, ecx
  00b45	7c 1c		 jl	 SHORT $LN130@P_ProcessS
  00b47	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00b4e	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _sstage_end
  00b55	3b c1		 cmp	 eax, ecx
  00b57	7f 0a		 jg	 SHORT $LN130@P_ProcessS

; 3084 : 				sstimer = 6; // Just let P_Ticker take care of the rest.

  00b59	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _sstimer, 6
$LN130@P_ProcessS:

; 3085 : 
; 3086 : 			// Exit (for FOF exits; others are handled in P_PlayerThink in p_user.c)
; 3087 : 			{
; 3088 : 				INT32 lineindex;
; 3089 : 
; 3090 : 				P_DoPlayerExit(player);

  00b63	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00b66	50		 push	 eax
  00b67	e8 00 00 00 00	 call	 _P_DoPlayerExit
  00b6c	83 c4 04	 add	 esp, 4

; 3091 : 
; 3092 : 				P_SetupSignExit(player);

  00b6f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00b72	50		 push	 eax
  00b73	e8 00 00 00 00	 call	 _P_SetupSignExit
  00b78	83 c4 04	 add	 esp, 4

; 3093 : 				// important: use sector->tag on next line instead of player->mo->subsector->tag
; 3094 : 				// this part is different from in P_PlayerThink, this is what was causing
; 3095 : 				// FOF custom exits not to work.
; 3096 : 				lineindex = P_FindSpecialLineFromTag(2, sector->tag, -1);

  00b7b	6a ff		 push	 -1
  00b7d	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  00b80	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00b84	51		 push	 ecx
  00b85	6a 02		 push	 2
  00b87	e8 00 00 00 00	 call	 _P_FindSpecialLineFromTag
  00b8c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b8f	89 45 80	 mov	 DWORD PTR _lineindex$38[ebp], eax

; 3097 : 
; 3098 : 				if (gametype != GT_RACE && lineindex != -1) // Custom exit!

  00b92	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00b99	83 f8 02	 cmp	 eax, 2
  00b9c	0f 84 e6 00 00
	00		 je	 $LN136@P_ProcessS
  00ba2	83 7d 80 ff	 cmp	 DWORD PTR _lineindex$38[ebp], -1
  00ba6	0f 84 dc 00 00
	00		 je	 $LN136@P_ProcessS

; 3099 : 				{
; 3100 : 					// Special goodies with the block monsters flag depending on emeralds collected
; 3101 : 					if ((lines[lineindex].flags & ML_BLOCKMONSTERS) && ALL7EMERALDS(emeralds))

  00bac	6b 45 80 4c	 imul	 eax, DWORD PTR _lineindex$38[ebp], 76
  00bb0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00bb6	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00bbb	83 e2 02	 and	 edx, 2
  00bbe	74 2b		 je	 SHORT $LN132@P_ProcessS
  00bc0	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  00bc7	83 e0 7f	 and	 eax, 127		; 0000007fH
  00bca	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00bcd	75 1c		 jne	 SHORT $LN132@P_ProcessS

; 3102 : 						nextmapoverride = (INT16)(lines[lineindex].frontsector->ceilingheight>>FRACBITS);

  00bcf	6b 45 80 4c	 imul	 eax, DWORD PTR _lineindex$38[ebp], 76
  00bd3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00bd9	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00bdd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00be0	c1 f8 10	 sar	 eax, 16			; 00000010H
  00be3	66 a3 00 00 00
	00		 mov	 WORD PTR _nextmapoverride, ax
  00be9	eb 19		 jmp	 SHORT $LN133@P_ProcessS
$LN132@P_ProcessS:

; 3103 : 					else
; 3104 : 						nextmapoverride = (INT16)(lines[lineindex].frontsector->floorheight>>FRACBITS);

  00beb	6b 45 80 4c	 imul	 eax, DWORD PTR _lineindex$38[ebp], 76
  00bef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00bf5	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00bf9	8b 02		 mov	 eax, DWORD PTR [edx]
  00bfb	c1 f8 10	 sar	 eax, 16			; 00000010H
  00bfe	66 a3 00 00 00
	00		 mov	 WORD PTR _nextmapoverride, ax
$LN133@P_ProcessS:

; 3105 : 
; 3106 : 					if (lines[lineindex].flags & ML_NOCLIMB)

  00c04	6b 45 80 4c	 imul	 eax, DWORD PTR _lineindex$38[ebp], 76
  00c08	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00c0e	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00c13	83 e2 40	 and	 edx, 64			; 00000040H
  00c16	74 0a		 je	 SHORT $LN134@P_ProcessS

; 3107 : 						skipstats = true;

  00c18	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _skipstats, 1
$LN134@P_ProcessS:

; 3108 : 
; 3109 : 					// change the gametype using front x offset if passuse flag is given
; 3110 : 					// ...but not in single player!
; 3111 : 					if (multiplayer && lines[lineindex].flags & ML_EFFECT4)

  00c22	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00c29	74 5d		 je	 SHORT $LN136@P_ProcessS
  00c2b	6b 45 80 4c	 imul	 eax, DWORD PTR _lineindex$38[ebp], 76
  00c2f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00c35	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00c3a	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00c40	74 46		 je	 SHORT $LN136@P_ProcessS

; 3112 : 					{
; 3113 : 						INT32 xofs = sides[lines[lineindex].sidenum[0]].textureoffset;

  00c42	6b 45 80 4c	 imul	 eax, DWORD PTR _lineindex$38[ebp], 76
  00c46	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00c4c	b9 02 00 00 00	 mov	 ecx, 2
  00c51	6b d1 00	 imul	 edx, ecx, 0
  00c54	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  00c59	6b c8 1c	 imul	 ecx, eax, 28
  00c5c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00c62	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00c65	89 85 7c ff ff
	ff		 mov	 DWORD PTR _xofs$37[ebp], eax

; 3114 : 						if (xofs >= 0 && xofs < NUMGAMETYPES)

  00c6b	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _xofs$37[ebp], 0
  00c72	7c 14		 jl	 SHORT $LN136@P_ProcessS
  00c74	83 bd 7c ff ff
	ff 05		 cmp	 DWORD PTR _xofs$37[ebp], 5
  00c7b	7d 0b		 jge	 SHORT $LN136@P_ProcessS

; 3115 : 							nextmapgametype = xofs;

  00c7d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _xofs$37[ebp]
  00c83	a3 00 00 00 00	 mov	 DWORD PTR _nextmapgametype, eax
$LN136@P_ProcessS:

; 3116 : 					}
; 3117 : 				}
; 3118 : 			}
; 3119 : 			break;

  00c88	e9 91 1b 00 00	 jmp	 $LN17@P_ProcessS
$LN137@P_ProcessS:

; 3120 : 
; 3121 : 		case 3: // Red Team's Base
; 3122 : 			if (gametype == GT_CTF && P_IsObjectOnGround(player->mo))

  00c8d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00c94	83 f8 04	 cmp	 eax, 4
  00c97	0f 85 53 03 00
	00		 jne	 $LN154@P_ProcessS
  00c9d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00ca0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ca2	51		 push	 ecx
  00ca3	e8 00 00 00 00	 call	 _P_IsObjectOnGround
  00ca8	83 c4 04	 add	 esp, 4
  00cab	85 c0		 test	 eax, eax
  00cad	0f 84 3d 03 00
	00		 je	 $LN154@P_ProcessS

; 3123 : 			{
; 3124 : 				if (!player->ctfteam)

  00cb3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00cb6	83 b8 60 01 00
	00 00		 cmp	 DWORD PTR [eax+352], 0
  00cbd	75 52		 jne	 SHORT $LN139@P_ProcessS

; 3125 : 				{
; 3126 : 					if (player == &players[consoleplayer])

  00cbf	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00cc9	05 00 00 00 00	 add	 eax, OFFSET _players
  00cce	39 45 08	 cmp	 DWORD PTR _player$[ebp], eax
  00cd1	75 0f		 jne	 SHORT $LN140@P_ProcessS

; 3127 : 					{
; 3128 : 						COM_ImmedExecute("changeteam red");

  00cd3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HLFJDFHH@changeteam?5red@
  00cd8	e8 00 00 00 00	 call	 _COM_ImmedExecute
  00cdd	83 c4 04	 add	 esp, 4

; 3129 : 					}

  00ce0	eb 2a		 jmp	 SHORT $LN142@P_ProcessS
$LN140@P_ProcessS:

; 3130 : 					else if (splitscreen && player == &players[secondarydisplayplayer])

  00ce2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00ce9	74 21		 je	 SHORT $LN142@P_ProcessS
  00ceb	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00cf5	05 00 00 00 00	 add	 eax, OFFSET _players
  00cfa	39 45 08	 cmp	 DWORD PTR _player$[ebp], eax
  00cfd	75 0d		 jne	 SHORT $LN142@P_ProcessS

; 3131 : 					{
; 3132 : 						COM_ImmedExecute("changeteam2 red");

  00cff	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PEKCJCD@changeteam2?5red@
  00d04	e8 00 00 00 00	 call	 _COM_ImmedExecute
  00d09	83 c4 04	 add	 esp, 4
$LN142@P_ProcessS:

; 3133 : 					}
; 3134 : 					break;

  00d0c	e9 0d 1b 00 00	 jmp	 $LN17@P_ProcessS
$LN139@P_ProcessS:

; 3135 : 				}
; 3136 : 
; 3137 : 				if (player->ctfteam == 1)

  00d11	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00d14	83 b8 60 01 00
	00 01		 cmp	 DWORD PTR [eax+352], 1
  00d1b	0f 85 cf 02 00
	00		 jne	 $LN154@P_ProcessS

; 3138 : 				{
; 3139 : 					if (player->gotflag & MF_BLUEFLAG)

  00d21	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00d24	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  00d2b	83 e1 02	 and	 ecx, 2
  00d2e	0f 84 b4 01 00
	00		 je	 $LN144@P_ProcessS

; 3140 : 					{
; 3141 : 						mobj_t *mo;
; 3142 : 
; 3143 : 						// Make sure the red team still has their own
; 3144 : 						// flag at their base so they can score.
; 3145 : 						for (i = 0; i < MAXPLAYERS; i++)

  00d34	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d3b	eb 09		 jmp	 SHORT $LN21@P_ProcessS
$LN19@P_ProcessS:
  00d3d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d40	83 c0 01	 add	 eax, 1
  00d43	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN21@P_ProcessS:
  00d46	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00d4a	7d 26		 jge	 SHORT $LN20@P_ProcessS

; 3146 : 						{
; 3147 : 							if (!playeringame[i])

  00d4c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00d4f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00d57	75 02		 jne	 SHORT $LN145@P_ProcessS

; 3148 : 								continue;

  00d59	eb e2		 jmp	 SHORT $LN19@P_ProcessS
$LN145@P_ProcessS:

; 3149 : 
; 3150 : 							if (players[i].gotflag & MF_REDFLAG)

  00d5b	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00d62	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR _players[eax+356]
  00d69	83 e1 01	 and	 ecx, 1
  00d6c	74 02		 je	 SHORT $LN146@P_ProcessS

; 3151 : 								break;

  00d6e	eb 02		 jmp	 SHORT $LN20@P_ProcessS
$LN146@P_ProcessS:

; 3152 : 						}

  00d70	eb cb		 jmp	 SHORT $LN19@P_ProcessS
$LN20@P_ProcessS:

; 3153 : 
; 3154 : 						if (!P_IsFlagAtBase(MT_REDFLAG))

  00d72	6a 34		 push	 52			; 00000034H
  00d74	e8 00 00 00 00	 call	 _P_IsFlagAtBase
  00d79	83 c4 04	 add	 esp, 4
  00d7c	85 c0		 test	 eax, eax
  00d7e	75 05		 jne	 SHORT $LN147@P_ProcessS

; 3155 : 							break;

  00d80	e9 99 1a 00 00	 jmp	 $LN17@P_ProcessS
$LN147@P_ProcessS:

; 3156 : 
; 3157 : 						HU_SetCEchoFlags(0);

  00d85	6a 00		 push	 0
  00d87	e8 00 00 00 00	 call	 _HU_SetCEchoFlags
  00d8c	83 c4 04	 add	 esp, 4

; 3158 : 						HU_SetCEchoDuration(5);

  00d8f	6a 05		 push	 5
  00d91	e8 00 00 00 00	 call	 _HU_SetCEchoDuration
  00d96	83 c4 04	 add	 esp, 4

; 3159 : 						HU_DoCEcho(va("%s\\captured the blue flag.\\\\\\\\", player_names[player-players]));

  00d99	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00d9c	2d 00 00 00 00	 sub	 eax, OFFSET _players
  00da1	99		 cdq
  00da2	b9 fc 01 00 00	 mov	 ecx, 508		; 000001fcH
  00da7	f7 f9		 idiv	 ecx
  00da9	6b d0 16	 imul	 edx, eax, 22
  00dac	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  00db2	52		 push	 edx
  00db3	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMOKFAHO@?$CFs?2captured?5the?5blue?5flag?4?2?2?2?2@
  00db8	e8 00 00 00 00	 call	 _va
  00dbd	83 c4 08	 add	 esp, 8
  00dc0	50		 push	 eax
  00dc1	e8 00 00 00 00	 call	 _HU_DoCEcho
  00dc6	83 c4 04	 add	 esp, 4

; 3160 : 						I_OutputMsg("%s captured the blue flag.\n", player_names[player-players]);

  00dc9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00dcc	2d 00 00 00 00	 sub	 eax, OFFSET _players
  00dd1	99		 cdq
  00dd2	b9 fc 01 00 00	 mov	 ecx, 508		; 000001fcH
  00dd7	f7 f9		 idiv	 ecx
  00dd9	6b d0 16	 imul	 edx, eax, 22
  00ddc	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  00de2	52		 push	 edx
  00de3	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NCHIJMJN@?$CFs?5captured?5the?5blue?5flag?4?6@
  00de8	e8 00 00 00 00	 call	 _I_OutputMsg
  00ded	83 c4 08	 add	 esp, 8

; 3161 : 
; 3162 : 						if (players[consoleplayer].ctfteam == 1)

  00df0	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00dfa	83 b8 60 01 00
	00 01		 cmp	 DWORD PTR _players[eax+352], 1
  00e01	75 11		 jne	 SHORT $LN148@P_ProcessS

; 3163 : 							S_StartSound(NULL, sfx_flgcap);

  00e03	68 07 01 00 00	 push	 263			; 00000107H
  00e08	6a 00		 push	 0
  00e0a	e8 00 00 00 00	 call	 _S_StartSound
  00e0f	83 c4 08	 add	 esp, 8
  00e12	eb 1f		 jmp	 SHORT $LN150@P_ProcessS
$LN148@P_ProcessS:

; 3164 : 						else if (players[consoleplayer].ctfteam == 2)

  00e14	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00e1e	83 b8 60 01 00
	00 02		 cmp	 DWORD PTR _players[eax+352], 2
  00e25	75 0c		 jne	 SHORT $LN150@P_ProcessS

; 3165 : 							S_StartSound(NULL, sfx_lose);

  00e27	6a 5b		 push	 91			; 0000005bH
  00e29	6a 00		 push	 0
  00e2b	e8 00 00 00 00	 call	 _S_StartSound
  00e30	83 c4 08	 add	 esp, 8
$LN150@P_ProcessS:

; 3166 : 
; 3167 : 						mo = P_SpawnMobj(player->mo->x,

  00e33	6a 35		 push	 53			; 00000035H
  00e35	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00e38	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e3a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00e3d	52		 push	 edx
  00e3e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00e41	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e43	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00e46	52		 push	 edx
  00e47	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00e4a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e4c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00e4f	52		 push	 edx
  00e50	e8 00 00 00 00	 call	 _P_SpawnMobj
  00e55	83 c4 10	 add	 esp, 16			; 00000010H
  00e58	89 85 78 ff ff
	ff		 mov	 DWORD PTR _mo$36[ebp], eax

; 3168 : 										player->mo->y,
; 3169 : 										player->mo->z,
; 3170 : 										MT_BLUEFLAG);
; 3171 : 						player->gotflag &= ~MF_BLUEFLAG;

  00e5e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00e61	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  00e68	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00e6b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00e6e	66 89 8a 64 01
	00 00		 mov	 WORD PTR [edx+356], cx

; 3172 : 						mo->flags &= ~MF_SPECIAL;

  00e75	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _mo$36[ebp]
  00e7b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00e7e	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00e81	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _mo$36[ebp]
  00e87	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 3173 : 						mo->fuse = TICRATE;

  00e8a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _mo$36[ebp]
  00e90	c7 80 bc 00 00
	00 23 00 00 00	 mov	 DWORD PTR [eax+188], 35	; 00000023H

; 3174 : 						mo->spawnpoint = bflagpoint;

  00e9a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _mo$36[ebp]
  00ea0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bflagpoint
  00ea6	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx

; 3175 : 						mo->flags2 |= MF2_JUSTATTACKED;

  00eac	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _mo$36[ebp]
  00eb2	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00eb8	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  00ebe	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _mo$36[ebp]
  00ec4	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 3176 : 						redscore += 1;

  00eca	a1 00 00 00 00	 mov	 eax, DWORD PTR _redscore
  00ecf	83 c0 01	 add	 eax, 1
  00ed2	a3 00 00 00 00	 mov	 DWORD PTR _redscore, eax

; 3177 : 						P_AddPlayerScore(player, 250);

  00ed7	68 fa 00 00 00	 push	 250			; 000000faH
  00edc	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00edf	50		 push	 eax
  00ee0	e8 00 00 00 00	 call	 _P_AddPlayerScore
  00ee5	83 c4 08	 add	 esp, 8
$LN144@P_ProcessS:

; 3178 : 					}
; 3179 : 					if (player->gotflag & MF_REDFLAG) // Returning a flag to your base

  00ee8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00eeb	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  00ef2	83 e1 01	 and	 ecx, 1
  00ef5	0f 84 f5 00 00
	00		 je	 $LN154@P_ProcessS

; 3180 : 					{
; 3181 : 						mobj_t *mo;
; 3182 : 
; 3183 : 						mo = P_SpawnMobj(player->mo->x,

  00efb	6a 34		 push	 52			; 00000034H
  00efd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00f00	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f02	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00f05	52		 push	 edx
  00f06	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00f09	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f0b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00f0e	52		 push	 edx
  00f0f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00f12	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f14	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00f17	52		 push	 edx
  00f18	e8 00 00 00 00	 call	 _P_SpawnMobj
  00f1d	83 c4 10	 add	 esp, 16			; 00000010H
  00f20	89 85 74 ff ff
	ff		 mov	 DWORD PTR _mo$35[ebp], eax

; 3184 : 										player->mo->y,
; 3185 : 										player->mo->z,
; 3186 : 										MT_REDFLAG);
; 3187 : 						mo->flags &= ~MF_SPECIAL;

  00f26	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _mo$35[ebp]
  00f2c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00f2f	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00f32	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _mo$35[ebp]
  00f38	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 3188 : 						player->gotflag &= ~MF_REDFLAG;

  00f3b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00f3e	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  00f45	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00f48	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00f4b	66 89 8a 64 01
	00 00		 mov	 WORD PTR [edx+356], cx

; 3189 : 						mo->fuse = TICRATE;

  00f52	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _mo$35[ebp]
  00f58	c7 80 bc 00 00
	00 23 00 00 00	 mov	 DWORD PTR [eax+188], 35	; 00000023H

; 3190 : 						mo->spawnpoint = rflagpoint;

  00f62	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _mo$35[ebp]
  00f68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rflagpoint
  00f6e	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx

; 3191 : 						HU_SetCEchoFlags(0);

  00f74	6a 00		 push	 0
  00f76	e8 00 00 00 00	 call	 _HU_SetCEchoFlags
  00f7b	83 c4 04	 add	 esp, 4

; 3192 : 						HU_SetCEchoDuration(5);

  00f7e	6a 05		 push	 5
  00f80	e8 00 00 00 00	 call	 _HU_SetCEchoDuration
  00f85	83 c4 04	 add	 esp, 4

; 3193 : 
; 3194 : 						if (players[consoleplayer].ctfteam == 2)

  00f88	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00f92	83 b8 60 01 00
	00 02		 cmp	 DWORD PTR _players[eax+352], 2
  00f99	75 1c		 jne	 SHORT $LN152@P_ProcessS

; 3195 : 						{
; 3196 : 							HU_DoCEcho("the enemy has returned\\their flag.\\\\\\\\");

  00f9b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LFDGLEBD@the?5enemy?5has?5returned?2their?5fl@
  00fa0	e8 00 00 00 00	 call	 _HU_DoCEcho
  00fa5	83 c4 04	 add	 esp, 4

; 3197 : 							I_OutputMsg("the blue team has returned their flag.\n");

  00fa8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PCBKHFLB@the?5blue?5team?5has?5returned?5thei@
  00fad	e8 00 00 00 00	 call	 _I_OutputMsg
  00fb2	83 c4 04	 add	 esp, 4

; 3198 : 						}

  00fb5	eb 39		 jmp	 SHORT $LN154@P_ProcessS
$LN152@P_ProcessS:

; 3199 : 						else if (players[consoleplayer].ctfteam == 1)

  00fb7	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00fc1	83 b8 60 01 00
	00 01		 cmp	 DWORD PTR _players[eax+352], 1
  00fc8	75 26		 jne	 SHORT $LN154@P_ProcessS

; 3200 : 						{
; 3201 : 							HU_DoCEcho("your flag was returned\\to base.\\\\\\\\");

  00fca	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EBPGLBCL@your?5flag?5was?5returned?2to?5base?4@
  00fcf	e8 00 00 00 00	 call	 _HU_DoCEcho
  00fd4	83 c4 04	 add	 esp, 4

; 3202 : 							I_OutputMsg("your red flag was returned to base.\n");

  00fd7	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IFDPBPCN@your?5red?5flag?5was?5returned?5to?5b@
  00fdc	e8 00 00 00 00	 call	 _I_OutputMsg
  00fe1	83 c4 04	 add	 esp, 4

; 3203 : 							S_StartSound(NULL, sfx_chchng);

  00fe4	6a 2a		 push	 42			; 0000002aH
  00fe6	6a 00		 push	 0
  00fe8	e8 00 00 00 00	 call	 _S_StartSound
  00fed	83 c4 08	 add	 esp, 8
$LN154@P_ProcessS:

; 3204 : 						}
; 3205 : 					}
; 3206 : 				}
; 3207 : 			}
; 3208 : 			break;

  00ff0	e9 29 18 00 00	 jmp	 $LN17@P_ProcessS
$LN155@P_ProcessS:

; 3209 : 
; 3210 : 		case 4: // Blue Team's Base
; 3211 : 			if (gametype == GT_CTF && P_IsObjectOnGround(player->mo))

  00ff5	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00ffc	83 f8 04	 cmp	 eax, 4
  00fff	0f 85 3f 03 00
	00		 jne	 $LN172@P_ProcessS
  01005	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0100a	51		 push	 ecx
  0100b	e8 00 00 00 00	 call	 _P_IsObjectOnGround
  01010	83 c4 04	 add	 esp, 4
  01013	85 c0		 test	 eax, eax
  01015	0f 84 29 03 00
	00		 je	 $LN172@P_ProcessS

; 3212 : 			{
; 3213 : 				if (!player->ctfteam)

  0101b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0101e	83 b8 60 01 00
	00 00		 cmp	 DWORD PTR [eax+352], 0
  01025	75 52		 jne	 SHORT $LN157@P_ProcessS

; 3214 : 				{
; 3215 : 					if (player == &players[consoleplayer])

  01027	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  01031	05 00 00 00 00	 add	 eax, OFFSET _players
  01036	39 45 08	 cmp	 DWORD PTR _player$[ebp], eax
  01039	75 0f		 jne	 SHORT $LN158@P_ProcessS

; 3216 : 					{
; 3217 : 						COM_ImmedExecute("changeteam blue");

  0103b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NGJMDDAH@changeteam?5blue@
  01040	e8 00 00 00 00	 call	 _COM_ImmedExecute
  01045	83 c4 04	 add	 esp, 4

; 3218 : 					}

  01048	eb 2a		 jmp	 SHORT $LN160@P_ProcessS
$LN158@P_ProcessS:

; 3219 : 					else if (splitscreen && player == &players[secondarydisplayplayer])

  0104a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  01051	74 21		 je	 SHORT $LN160@P_ProcessS
  01053	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0105d	05 00 00 00 00	 add	 eax, OFFSET _players
  01062	39 45 08	 cmp	 DWORD PTR _player$[ebp], eax
  01065	75 0d		 jne	 SHORT $LN160@P_ProcessS

; 3220 : 					{
; 3221 : 						COM_ImmedExecute("changeteam2 blue");

  01067	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LKOOLFPG@changeteam2?5blue@
  0106c	e8 00 00 00 00	 call	 _COM_ImmedExecute
  01071	83 c4 04	 add	 esp, 4
$LN160@P_ProcessS:

; 3222 : 					}
; 3223 : 					break;

  01074	e9 a5 17 00 00	 jmp	 $LN17@P_ProcessS
$LN157@P_ProcessS:

; 3224 : 				}
; 3225 : 
; 3226 : 				if (player->ctfteam == 2)

  01079	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0107c	83 b8 60 01 00
	00 02		 cmp	 DWORD PTR [eax+352], 2
  01083	0f 85 bb 02 00
	00		 jne	 $LN172@P_ProcessS

; 3227 : 				{
; 3228 : 					if (player->gotflag & MF_REDFLAG)

  01089	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0108c	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  01093	83 e1 01	 and	 ecx, 1
  01096	0f 84 b4 01 00
	00		 je	 $LN162@P_ProcessS

; 3229 : 					{
; 3230 : 						mobj_t *mo;
; 3231 : 
; 3232 : 						for (i = 0; i < MAXPLAYERS; i++)

  0109c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  010a3	eb 09		 jmp	 SHORT $LN24@P_ProcessS
$LN22@P_ProcessS:
  010a5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  010a8	83 c0 01	 add	 eax, 1
  010ab	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN24@P_ProcessS:
  010ae	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  010b2	7d 26		 jge	 SHORT $LN23@P_ProcessS

; 3233 : 						{
; 3234 : 							if (!playeringame[i])

  010b4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  010b7	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  010bf	75 02		 jne	 SHORT $LN163@P_ProcessS

; 3235 : 								continue;

  010c1	eb e2		 jmp	 SHORT $LN22@P_ProcessS
$LN163@P_ProcessS:

; 3236 : 
; 3237 : 							if (players[i].gotflag & MF_BLUEFLAG)

  010c3	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  010ca	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR _players[eax+356]
  010d1	83 e1 02	 and	 ecx, 2
  010d4	74 02		 je	 SHORT $LN164@P_ProcessS

; 3238 : 								break;

  010d6	eb 02		 jmp	 SHORT $LN23@P_ProcessS
$LN164@P_ProcessS:

; 3239 : 						}

  010d8	eb cb		 jmp	 SHORT $LN22@P_ProcessS
$LN23@P_ProcessS:

; 3240 : 
; 3241 : 						if (!P_IsFlagAtBase(MT_BLUEFLAG))

  010da	6a 35		 push	 53			; 00000035H
  010dc	e8 00 00 00 00	 call	 _P_IsFlagAtBase
  010e1	83 c4 04	 add	 esp, 4
  010e4	85 c0		 test	 eax, eax
  010e6	75 05		 jne	 SHORT $LN165@P_ProcessS

; 3242 : 							break;

  010e8	e9 31 17 00 00	 jmp	 $LN17@P_ProcessS
$LN165@P_ProcessS:

; 3243 : 
; 3244 : 						HU_SetCEchoFlags(0);

  010ed	6a 00		 push	 0
  010ef	e8 00 00 00 00	 call	 _HU_SetCEchoFlags
  010f4	83 c4 04	 add	 esp, 4

; 3245 : 						HU_SetCEchoDuration(5);

  010f7	6a 05		 push	 5
  010f9	e8 00 00 00 00	 call	 _HU_SetCEchoDuration
  010fe	83 c4 04	 add	 esp, 4

; 3246 : 						HU_DoCEcho(va("%s\\captured the red flag.\\\\\\\\", player_names[player-players]));

  01101	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01104	2d 00 00 00 00	 sub	 eax, OFFSET _players
  01109	99		 cdq
  0110a	b9 fc 01 00 00	 mov	 ecx, 508		; 000001fcH
  0110f	f7 f9		 idiv	 ecx
  01111	6b d0 16	 imul	 edx, eax, 22
  01114	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  0111a	52		 push	 edx
  0111b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GPOAFCDN@?$CFs?2captured?5the?5red?5flag?4?2?2?2?2@
  01120	e8 00 00 00 00	 call	 _va
  01125	83 c4 08	 add	 esp, 8
  01128	50		 push	 eax
  01129	e8 00 00 00 00	 call	 _HU_DoCEcho
  0112e	83 c4 04	 add	 esp, 4

; 3247 : 						I_OutputMsg("%s captured the red flag.\n", player_names[player-players]);

  01131	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01134	2d 00 00 00 00	 sub	 eax, OFFSET _players
  01139	99		 cdq
  0113a	b9 fc 01 00 00	 mov	 ecx, 508		; 000001fcH
  0113f	f7 f9		 idiv	 ecx
  01141	6b d0 16	 imul	 edx, eax, 22
  01144	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  0114a	52		 push	 edx
  0114b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MIPBFDCD@?$CFs?5captured?5the?5red?5flag?4?6@
  01150	e8 00 00 00 00	 call	 _I_OutputMsg
  01155	83 c4 08	 add	 esp, 8

; 3248 : 
; 3249 : 						if (players[consoleplayer].ctfteam == 2)

  01158	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  01162	83 b8 60 01 00
	00 02		 cmp	 DWORD PTR _players[eax+352], 2
  01169	75 11		 jne	 SHORT $LN166@P_ProcessS

; 3250 : 							S_StartSound(NULL, sfx_flgcap);

  0116b	68 07 01 00 00	 push	 263			; 00000107H
  01170	6a 00		 push	 0
  01172	e8 00 00 00 00	 call	 _S_StartSound
  01177	83 c4 08	 add	 esp, 8
  0117a	eb 1f		 jmp	 SHORT $LN168@P_ProcessS
$LN166@P_ProcessS:

; 3251 : 						else if (players[consoleplayer].ctfteam == 1)

  0117c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  01186	83 b8 60 01 00
	00 01		 cmp	 DWORD PTR _players[eax+352], 1
  0118d	75 0c		 jne	 SHORT $LN168@P_ProcessS

; 3252 : 							S_StartSound(NULL, sfx_lose);

  0118f	6a 5b		 push	 91			; 0000005bH
  01191	6a 00		 push	 0
  01193	e8 00 00 00 00	 call	 _S_StartSound
  01198	83 c4 08	 add	 esp, 8
$LN168@P_ProcessS:

; 3253 : 
; 3254 : 						mo = P_SpawnMobj(player->mo->x,

  0119b	6a 34		 push	 52			; 00000034H
  0119d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  011a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  011a2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  011a5	52		 push	 edx
  011a6	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  011a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  011ab	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  011ae	52		 push	 edx
  011af	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  011b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  011b4	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  011b7	52		 push	 edx
  011b8	e8 00 00 00 00	 call	 _P_SpawnMobj
  011bd	83 c4 10	 add	 esp, 16			; 00000010H
  011c0	89 85 70 ff ff
	ff		 mov	 DWORD PTR _mo$34[ebp], eax

; 3255 : 										player->mo->y,
; 3256 : 										player->mo->z,
; 3257 : 										MT_REDFLAG);
; 3258 : 						player->gotflag &= ~MF_REDFLAG;

  011c6	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  011c9	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  011d0	83 e1 fe	 and	 ecx, -2			; fffffffeH
  011d3	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  011d6	66 89 8a 64 01
	00 00		 mov	 WORD PTR [edx+356], cx

; 3259 : 						mo->flags &= ~MF_SPECIAL;

  011dd	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _mo$34[ebp]
  011e3	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  011e6	83 e1 fe	 and	 ecx, -2			; fffffffeH
  011e9	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _mo$34[ebp]
  011ef	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 3260 : 						mo->fuse = TICRATE;

  011f2	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _mo$34[ebp]
  011f8	c7 80 bc 00 00
	00 23 00 00 00	 mov	 DWORD PTR [eax+188], 35	; 00000023H

; 3261 : 						mo->spawnpoint = rflagpoint;

  01202	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _mo$34[ebp]
  01208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rflagpoint
  0120e	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx

; 3262 : 						mo->flags2 |= MF2_JUSTATTACKED;

  01214	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _mo$34[ebp]
  0121a	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  01220	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  01226	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _mo$34[ebp]
  0122c	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 3263 : 						bluescore += 1;

  01232	a1 00 00 00 00	 mov	 eax, DWORD PTR _bluescore
  01237	83 c0 01	 add	 eax, 1
  0123a	a3 00 00 00 00	 mov	 DWORD PTR _bluescore, eax

; 3264 : 						P_AddPlayerScore(player, 250);

  0123f	68 fa 00 00 00	 push	 250			; 000000faH
  01244	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01247	50		 push	 eax
  01248	e8 00 00 00 00	 call	 _P_AddPlayerScore
  0124d	83 c4 08	 add	 esp, 8
$LN162@P_ProcessS:

; 3265 : 					}
; 3266 : 					if (player->gotflag & MF_BLUEFLAG) // Returning a flag to your base

  01250	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01253	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  0125a	83 e1 02	 and	 ecx, 2
  0125d	0f 84 e1 00 00
	00		 je	 $LN172@P_ProcessS

; 3267 : 					{
; 3268 : 						mobj_t *mo;
; 3269 : 
; 3270 : 						mo = P_SpawnMobj(player->mo->x,

  01263	6a 35		 push	 53			; 00000035H
  01265	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01268	8b 08		 mov	 ecx, DWORD PTR [eax]
  0126a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0126d	52		 push	 edx
  0126e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01271	8b 08		 mov	 ecx, DWORD PTR [eax]
  01273	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01276	52		 push	 edx
  01277	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0127a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0127c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0127f	52		 push	 edx
  01280	e8 00 00 00 00	 call	 _P_SpawnMobj
  01285	83 c4 10	 add	 esp, 16			; 00000010H
  01288	89 85 6c ff ff
	ff		 mov	 DWORD PTR _mo$33[ebp], eax

; 3271 : 										player->mo->y,
; 3272 : 										player->mo->z,
; 3273 : 										MT_BLUEFLAG);
; 3274 : 						mo->flags &= ~MF_SPECIAL;

  0128e	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _mo$33[ebp]
  01294	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01297	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0129a	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _mo$33[ebp]
  012a0	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 3275 : 						player->gotflag &= ~MF_BLUEFLAG;

  012a3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  012a6	0f b7 88 64 01
	00 00		 movzx	 ecx, WORD PTR [eax+356]
  012ad	83 e1 fd	 and	 ecx, -3			; fffffffdH
  012b0	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  012b3	66 89 8a 64 01
	00 00		 mov	 WORD PTR [edx+356], cx

; 3276 : 						mo->fuse = TICRATE;

  012ba	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _mo$33[ebp]
  012c0	c7 80 bc 00 00
	00 23 00 00 00	 mov	 DWORD PTR [eax+188], 35	; 00000023H

; 3277 : 						mo->spawnpoint = bflagpoint;

  012ca	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _mo$33[ebp]
  012d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bflagpoint
  012d6	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx

; 3278 : 						if (players[consoleplayer].ctfteam == 1)

  012dc	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  012e6	83 b8 60 01 00
	00 01		 cmp	 DWORD PTR _players[eax+352], 1
  012ed	75 1c		 jne	 SHORT $LN170@P_ProcessS

; 3279 : 						{
; 3280 : 							HU_DoCEcho("the enemy has returned\\their flag.\\\\\\\\");

  012ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LFDGLEBD@the?5enemy?5has?5returned?2their?5fl@
  012f4	e8 00 00 00 00	 call	 _HU_DoCEcho
  012f9	83 c4 04	 add	 esp, 4

; 3281 : 							I_OutputMsg("the red team has returned their flag.\n");

  012fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GHLKNNGA@the?5red?5team?5has?5returned?5their@
  01301	e8 00 00 00 00	 call	 _I_OutputMsg
  01306	83 c4 04	 add	 esp, 4

; 3282 : 						}

  01309	eb 39		 jmp	 SHORT $LN172@P_ProcessS
$LN170@P_ProcessS:

; 3283 : 						else if (players[consoleplayer].ctfteam == 2)

  0130b	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  01315	83 b8 60 01 00
	00 02		 cmp	 DWORD PTR _players[eax+352], 2
  0131c	75 26		 jne	 SHORT $LN172@P_ProcessS

; 3284 : 						{
; 3285 : 							HU_DoCEcho("your flag was returned\\to base.\\\\\\\\");

  0131e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EBPGLBCL@your?5flag?5was?5returned?2to?5base?4@
  01323	e8 00 00 00 00	 call	 _HU_DoCEcho
  01328	83 c4 04	 add	 esp, 4

; 3286 : 							I_OutputMsg("your blue flag was returned to base.\n");

  0132b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CLJLMGKF@your?5blue?5flag?5was?5returned?5to?5@
  01330	e8 00 00 00 00	 call	 _I_OutputMsg
  01335	83 c4 04	 add	 esp, 4

; 3287 : 							S_StartSound(NULL, sfx_chchng);

  01338	6a 2a		 push	 42			; 0000002aH
  0133a	6a 00		 push	 0
  0133c	e8 00 00 00 00	 call	 _S_StartSound
  01341	83 c4 08	 add	 esp, 8
$LN172@P_ProcessS:

; 3288 : 						}
; 3289 : 					}
; 3290 : 				}
; 3291 : 			}
; 3292 : 			break;

  01344	e9 d5 14 00 00	 jmp	 $LN17@P_ProcessS
$LN173@P_ProcessS:

; 3293 : 
; 3294 : 		case 5: // Fan sector
; 3295 : 			player->mo->momz += mobjinfo[MT_FAN].speed/4;

  01349	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0134c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0134e	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  01353	6b c2 41	 imul	 eax, edx, 65
  01356	8b 80 3c 00 00
	00		 mov	 eax, DWORD PTR _mobjinfo[eax+60]
  0135c	99		 cdq
  0135d	83 e2 03	 and	 edx, 3
  01360	03 c2		 add	 eax, edx
  01362	c1 f8 02	 sar	 eax, 2
  01365	03 41 50	 add	 eax, DWORD PTR [ecx+80]
  01368	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0136b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0136d	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 3296 : 
; 3297 : 			if (player->mo->momz > mobjinfo[MT_FAN].speed)

  01370	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01373	8b 08		 mov	 ecx, DWORD PTR [eax]
  01375	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0137a	6b c2 41	 imul	 eax, edx, 65
  0137d	8b 49 50	 mov	 ecx, DWORD PTR [ecx+80]
  01380	3b 88 3c 00 00
	00		 cmp	 ecx, DWORD PTR _mobjinfo[eax+60]
  01386	7e 16		 jle	 SHORT $LN174@P_ProcessS

; 3298 : 				player->mo->momz = mobjinfo[MT_FAN].speed;

  01388	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0138d	6b c8 41	 imul	 ecx, eax, 65
  01390	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01393	8b 02		 mov	 eax, DWORD PTR [edx]
  01395	8b 89 3c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[ecx+60]
  0139b	89 48 50	 mov	 DWORD PTR [eax+80], ecx
$LN174@P_ProcessS:

; 3299 : 
; 3300 : 			P_ResetPlayer(player);

  0139e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  013a1	50		 push	 eax
  013a2	e8 00 00 00 00	 call	 _P_ResetPlayer
  013a7	83 c4 04	 add	 esp, 4

; 3301 : 			if (player->mo->state != &states[S_PLAY_FALL1]
; 3302 : 				&& player->mo->state != &states[S_PLAY_FALL2])

  013aa	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  013ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  013af	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  013b4	6b c2 27	 imul	 eax, edx, 39
  013b7	05 00 00 00 00	 add	 eax, OFFSET _states
  013bc	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  013bf	74 27		 je	 SHORT $LN175@P_ProcessS
  013c1	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  013c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  013c6	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  013cb	6b c2 28	 imul	 eax, edx, 40
  013ce	05 00 00 00 00	 add	 eax, OFFSET _states
  013d3	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  013d6	74 10		 je	 SHORT $LN175@P_ProcessS

; 3303 : 			{
; 3304 : 				P_SetPlayerMobjState(player->mo, S_PLAY_FALL1);

  013d8	6a 27		 push	 39			; 00000027H
  013da	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  013dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  013df	51		 push	 ecx
  013e0	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  013e5	83 c4 08	 add	 esp, 8
$LN175@P_ProcessS:

; 3305 : 			}
; 3306 : 			break;

  013e8	e9 31 14 00 00	 jmp	 $LN17@P_ProcessS
$LN176@P_ProcessS:

; 3307 : 
; 3308 : 		case 6: // Super Sonic transformer
; 3309 : 			if (player->mo->health > 0 && (player->skin == 0) && !player->powers[pw_super] && ALL7EMERALDS(emeralds))

  013ed	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  013f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  013f2	83 b9 8c 00 00
	00 00		 cmp	 DWORD PTR [ecx+140], 0
  013f9	7e 3b		 jle	 SHORT $LN177@P_ProcessS
  013fb	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  013fe	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  01405	75 2f		 jne	 SHORT $LN177@P_ProcessS
  01407	b8 04 00 00 00	 mov	 eax, 4
  0140c	6b c8 0f	 imul	 ecx, eax, 15
  0140f	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01412	83 7c 0a 38 00	 cmp	 DWORD PTR [edx+ecx+56], 0
  01417	75 1d		 jne	 SHORT $LN177@P_ProcessS
  01419	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  01420	83 e0 7f	 and	 eax, 127		; 0000007fH
  01423	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  01426	75 0e		 jne	 SHORT $LN177@P_ProcessS

; 3310 : 				P_DoSuperTransformation(player, true);

  01428	6a 01		 push	 1
  0142a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0142d	50		 push	 eax
  0142e	e8 00 00 00 00	 call	 _P_DoSuperTransformation
  01433	83 c4 08	 add	 esp, 8
$LN177@P_ProcessS:

; 3311 : 			break;

  01436	e9 e3 13 00 00	 jmp	 $LN17@P_ProcessS
$LN178@P_ProcessS:

; 3312 : 
; 3313 : 		case 7: // Make player spin
; 3314 : 			/// Question: Do we really need to check z with floorz here?
; 3315 : 			// Answer: YES.
; 3316 : 			if (!(player->pflags & PF_SPINNING) && P_IsObjectOnGround(player->mo) && (player->charability2 == CA2_SPINDASH))

  0143b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0143e	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  01444	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  0144a	0f 85 c5 00 00
	00		 jne	 $LN180@P_ProcessS
  01450	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01453	8b 08		 mov	 ecx, DWORD PTR [eax]
  01455	51		 push	 ecx
  01456	e8 00 00 00 00	 call	 _P_IsObjectOnGround
  0145b	83 c4 04	 add	 esp, 4
  0145e	85 c0		 test	 eax, eax
  01460	0f 84 af 00 00
	00		 je	 $LN180@P_ProcessS
  01466	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01469	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [eax+220], 0
  01470	0f 85 9f 00 00
	00		 jne	 $LN180@P_ProcessS

; 3317 : 			{
; 3318 : 				P_ResetScore(player);

  01476	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01479	50		 push	 eax
  0147a	e8 00 00 00 00	 call	 _P_ResetScore
  0147f	83 c4 04	 add	 esp, 4

; 3319 : 				player->pflags |= PF_SPINNING;

  01482	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01485	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0148b	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  01491	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01494	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3320 : 				P_SetPlayerMobjState(player->mo, S_PLAY_ATK1);

  0149a	6a 0c		 push	 12			; 0000000cH
  0149c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0149f	8b 08		 mov	 ecx, DWORD PTR [eax]
  014a1	51		 push	 ecx
  014a2	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  014a7	83 c4 08	 add	 esp, 8

; 3321 : 				S_StartAttackSound(player->mo, sfx_spin);

  014aa	68 d3 00 00 00	 push	 211			; 000000d3H
  014af	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  014b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  014b4	51		 push	 ecx
  014b5	e8 00 00 00 00	 call	 _S_StartAttackSound
  014ba	83 c4 08	 add	 esp, 8

; 3322 : 
; 3323 : 				if ((player->rmomx < 5*FRACUNIT/NEWTICRATERATIO
; 3324 : 				&& player->rmomx > -5*FRACUNIT/NEWTICRATERATIO)
; 3325 : 				&& (player->rmomy < 5*FRACUNIT/NEWTICRATERATIO

  014bd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  014c0	81 b8 44 01 00
	00 00 00 05 00	 cmp	 DWORD PTR [eax+324], 327680 ; 00050000H
  014ca	7d 49		 jge	 SHORT $LN180@P_ProcessS
  014cc	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  014cf	81 b8 44 01 00
	00 00 00 fb ff	 cmp	 DWORD PTR [eax+324], -327680 ; fffb0000H
  014d9	7e 3a		 jle	 SHORT $LN180@P_ProcessS
  014db	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  014de	81 b8 48 01 00
	00 00 00 05 00	 cmp	 DWORD PTR [eax+328], 327680 ; 00050000H
  014e8	7d 2b		 jge	 SHORT $LN180@P_ProcessS
  014ea	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  014ed	81 b8 48 01 00
	00 00 00 fb ff	 cmp	 DWORD PTR [eax+328], -327680 ; fffb0000H
  014f7	7e 1c		 jle	 SHORT $LN180@P_ProcessS

; 3326 : 				&& player->rmomy > -5*FRACUNIT/NEWTICRATERATIO))
; 3327 : 					P_InstaThrust(player->mo, player->mo->angle, 10*FRACUNIT);

  014f9	68 00 00 0a 00	 push	 655360			; 000a0000H
  014fe	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01501	8b 08		 mov	 ecx, DWORD PTR [eax]
  01503	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  01506	52		 push	 edx
  01507	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0150a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0150c	51		 push	 ecx
  0150d	e8 00 00 00 00	 call	 _P_InstaThrust
  01512	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@P_ProcessS:

; 3328 : 			}
; 3329 : 			break;

  01515	e9 04 13 00 00	 jmp	 $LN17@P_ProcessS
$LN181@P_ProcessS:

; 3330 : 
; 3331 : 		case 8: // Zoom Tube Start
; 3332 : 			{
; 3333 : 				INT32 sequence;
; 3334 : 				fixed_t speed;
; 3335 : 				INT32 lineindex;
; 3336 : 				thinker_t *th;
; 3337 : 				mobj_t *waypoint = NULL;

  0151a	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _waypoint$28[ebp], 0

; 3338 : 				mobj_t *mo2;
; 3339 : 				angle_t an;
; 3340 : 
; 3341 : 				if (player->mo->tracer && player->mo->tracer->type == MT_TUBEWAYPOINT)

  01524	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01527	8b 08		 mov	 ecx, DWORD PTR [eax]
  01529	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [ecx+176], 0
  01530	74 19		 je	 SHORT $LN182@P_ProcessS
  01532	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01535	8b 08		 mov	 ecx, DWORD PTR [eax]
  01537	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  0153d	81 7a 7c 06 01
	00 00		 cmp	 DWORD PTR [edx+124], 262 ; 00000106H
  01544	75 05		 jne	 SHORT $LN182@P_ProcessS

; 3342 : 					break;

  01546	e9 d3 12 00 00	 jmp	 $LN17@P_ProcessS
$LN182@P_ProcessS:

; 3343 : 
; 3344 : 				// Find line #3 tagged to this sector
; 3345 : 				lineindex = P_FindSpecialLineFromTag(3, sector->tag, -1);

  0154b	6a ff		 push	 -1
  0154d	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  01550	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  01554	51		 push	 ecx
  01555	6a 03		 push	 3
  01557	e8 00 00 00 00	 call	 _P_FindSpecialLineFromTag
  0155c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0155f	89 85 60 ff ff
	ff		 mov	 DWORD PTR _lineindex$30[ebp], eax

; 3346 : 
; 3347 : 				if (lineindex == -1)

  01565	83 bd 60 ff ff
	ff ff		 cmp	 DWORD PTR _lineindex$30[ebp], -1
  0156c	75 1a		 jne	 SHORT $LN183@P_ProcessS

; 3348 : 				{
; 3349 : 					CONS_Printf("ERROR: Sector special %d missing line special #3.\n", sector->special);

  0156e	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  01571	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  01575	51		 push	 ecx
  01576	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@HOADDFGL@ERROR?3?5Sector?5special?5?$CFd?5missin@
  0157b	e8 00 00 00 00	 call	 _CONS_Printf
  01580	83 c4 08	 add	 esp, 8

; 3350 : 					break;

  01583	e9 96 12 00 00	 jmp	 $LN17@P_ProcessS
$LN183@P_ProcessS:

; 3351 : 				}
; 3352 : 
; 3353 : 				// Grab speed and sequence values
; 3354 : 				speed = abs(lines[lineindex].dx)/8;

  01588	6b 85 60 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$30[ebp], 76
  0158f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01595	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  01599	52		 push	 edx
  0159a	e8 00 00 00 00	 call	 _abs
  0159f	83 c4 04	 add	 esp, 4
  015a2	99		 cdq
  015a3	83 e2 07	 and	 edx, 7
  015a6	03 c2		 add	 eax, edx
  015a8	c1 f8 03	 sar	 eax, 3
  015ab	89 85 64 ff ff
	ff		 mov	 DWORD PTR _speed$31[ebp], eax

; 3355 : 				sequence = abs(lines[lineindex].dy)>>FRACBITS;

  015b1	6b 85 60 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$30[ebp], 76
  015b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  015be	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  015c2	52		 push	 edx
  015c3	e8 00 00 00 00	 call	 _abs
  015c8	83 c4 04	 add	 esp, 4
  015cb	c1 f8 10	 sar	 eax, 16			; 00000010H
  015ce	89 85 68 ff ff
	ff		 mov	 DWORD PTR _sequence$32[ebp], eax

; 3356 : 
; 3357 : 				// scan the thinkers
; 3358 : 				// to find the first waypoint
; 3359 : 				for (th = thinkercap.next; th != &thinkercap; th = th->next)

  015d4	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  015d9	89 85 5c ff ff
	ff		 mov	 DWORD PTR _th$29[ebp], eax
  015df	eb 0f		 jmp	 SHORT $LN27@P_ProcessS
$LN25@P_ProcessS:
  015e1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _th$29[ebp]
  015e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  015ea	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _th$29[ebp], ecx
$LN27@P_ProcessS:
  015f0	81 bd 5c ff ff
	ff 00 00 00 00	 cmp	 DWORD PTR _th$29[ebp], OFFSET _thinkercap
  015fa	74 5f		 je	 SHORT $LN26@P_ProcessS

; 3360 : 				{
; 3361 : 					if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  015fc	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _th$29[ebp]
  01602	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  01609	74 02		 je	 SHORT $LN184@P_ProcessS

; 3362 : 						continue;

  0160b	eb d4		 jmp	 SHORT $LN25@P_ProcessS
$LN184@P_ProcessS:

; 3363 : 
; 3364 : 					mo2 = (mobj_t *)th;

  0160d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _th$29[ebp]
  01613	89 85 54 ff ff
	ff		 mov	 DWORD PTR _mo2$27[ebp], eax

; 3365 : 
; 3366 : 					if (mo2->type == MT_TUBEWAYPOINT && mo2->threshold == sequence
; 3367 : 						&& mo2->health == 0)

  01619	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$27[ebp]
  0161f	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  01626	75 31		 jne	 SHORT $LN185@P_ProcessS
  01628	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$27[ebp]
  0162e	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  01634	3b 8d 68 ff ff
	ff		 cmp	 ecx, DWORD PTR _sequence$32[ebp]
  0163a	75 1d		 jne	 SHORT $LN185@P_ProcessS
  0163c	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$27[ebp]
  01642	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  01649	75 0e		 jne	 SHORT $LN185@P_ProcessS

; 3368 : 					{
; 3369 : 						waypoint = mo2;

  0164b	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$27[ebp]
  01651	89 85 58 ff ff
	ff		 mov	 DWORD PTR _waypoint$28[ebp], eax

; 3370 : 						break;

  01657	eb 02		 jmp	 SHORT $LN26@P_ProcessS
$LN185@P_ProcessS:

; 3371 : 					}
; 3372 : 				}

  01659	eb 86		 jmp	 SHORT $LN25@P_ProcessS
$LN26@P_ProcessS:

; 3373 : 
; 3374 : 				if (!waypoint)

  0165b	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _waypoint$28[ebp], 0
  01662	75 1b		 jne	 SHORT $LN186@P_ProcessS

; 3375 : 				{
; 3376 : 					CONS_Printf("ERROR: FIRST WAYPOINT IN SEQUENCE %d NOT FOUND.\n", sequence);

  01664	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _sequence$32[ebp]
  0166a	50		 push	 eax
  0166b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IDAAEOCG@ERROR?3?5FIRST?5WAYPOINT?5IN?5SEQUEN@
  01670	e8 00 00 00 00	 call	 _CONS_Printf
  01675	83 c4 08	 add	 esp, 8

; 3377 : 					break;

  01678	e9 a1 11 00 00	 jmp	 $LN17@P_ProcessS

; 3378 : 				}

  0167d	eb 31		 jmp	 SHORT $LN188@P_ProcessS
$LN186@P_ProcessS:

; 3379 : 				else if (cv_debug)

  0167f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  01686	74 28		 je	 SHORT $LN188@P_ProcessS

; 3380 : 					CONS_Printf("Waypoint %d found in sequence %d - speed = %d\n",

  01688	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _speed$31[ebp]
  0168e	50		 push	 eax
  0168f	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _sequence$32[ebp]
  01695	51		 push	 ecx
  01696	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _waypoint$28[ebp]
  0169c	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  016a2	50		 push	 eax
  016a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BGLBOMJP@Waypoint?5?$CFd?5found?5in?5sequence?5?$CF@
  016a8	e8 00 00 00 00	 call	 _CONS_Printf
  016ad	83 c4 10	 add	 esp, 16			; 00000010H
$LN188@P_ProcessS:

; 3381 : 																waypoint->health,
; 3382 : 																sequence,
; 3383 : 																speed);
; 3384 : 
; 3385 : 				an = R_PointToAngle2(player->mo->x, player->mo->y, waypoint->x, waypoint->y) - player->mo->angle;

  016b0	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _waypoint$28[ebp]
  016b6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  016b9	51		 push	 ecx
  016ba	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _waypoint$28[ebp]
  016c0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  016c3	50		 push	 eax
  016c4	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  016c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  016c9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  016cc	50		 push	 eax
  016cd	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  016d0	8b 11		 mov	 edx, DWORD PTR [ecx]
  016d2	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  016d5	50		 push	 eax
  016d6	e8 00 00 00 00	 call	 _R_PointToAngle2
  016db	83 c4 10	 add	 esp, 16			; 00000010H
  016de	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  016e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  016e3	2b 42 24	 sub	 eax, DWORD PTR [edx+36]
  016e6	89 85 50 ff ff
	ff		 mov	 DWORD PTR _an$26[ebp], eax

; 3386 : 
; 3387 : 				if (an > ANGLE_90 && an < ANGLE_270 && !(lines[lineindex].flags & ML_EFFECT4))

  016ec	81 bd 50 ff ff
	ff 00 00 00 40	 cmp	 DWORD PTR _an$26[ebp], 1073741824 ; 40000000H
  016f6	76 2b		 jbe	 SHORT $LN189@P_ProcessS
  016f8	81 bd 50 ff ff
	ff 00 00 00 c0	 cmp	 DWORD PTR _an$26[ebp], -1073741824 ; c0000000H
  01702	73 1f		 jae	 SHORT $LN189@P_ProcessS
  01704	6b 85 60 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$30[ebp], 76
  0170b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01711	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01716	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  0171c	75 05		 jne	 SHORT $LN189@P_ProcessS

; 3388 : 					break; // behind back

  0171e	e9 fb 10 00 00	 jmp	 $LN17@P_ProcessS
$LN189@P_ProcessS:

; 3389 : 
; 3390 : 				P_SetTarget(&player->mo->tracer, waypoint);

  01723	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _waypoint$28[ebp]
  01729	50		 push	 eax
  0172a	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0172d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0172f	81 c2 b0 00 00
	00		 add	 edx, 176		; 000000b0H
  01735	52		 push	 edx
  01736	e8 00 00 00 00	 call	 _P_SetTarget
  0173b	83 c4 08	 add	 esp, 8

; 3391 : 				player->speed = speed;

  0173e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01741	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _speed$31[ebp]
  01747	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 3392 : 				player->pflags |= PF_SPINNING;

  0174d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01750	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  01756	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  0175c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0175f	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3393 : 				player->pflags &= ~PF_JUMPED;

  01765	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01768	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0176e	81 e1 ff ef ff
	ff		 and	 ecx, -4097		; ffffefffH
  01774	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01777	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3394 : 				player->pflags &= ~PF_GLIDING;

  0177d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01780	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  01786	81 e1 ff ff fe
	ff		 and	 ecx, -65537		; fffeffffH
  0178c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0178f	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3395 : 				player->climbing = 0;

  01795	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01798	c7 80 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+292], 0

; 3396 : 				player->scoreadd = 0;

  017a2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017a5	c7 80 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+284], 0

; 3397 : 
; 3398 : 				if (!(player->mo->state >= &states[S_PLAY_ATK1] && player->mo->state <= &states[S_PLAY_ATK4]))

  017af	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  017b4	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  017b9	6b c2 0c	 imul	 eax, edx, 12
  017bc	05 00 00 00 00	 add	 eax, OFFSET _states
  017c1	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  017c4	72 17		 jb	 SHORT $LN191@P_ProcessS
  017c6	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  017cb	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  017d0	6b c2 0f	 imul	 eax, edx, 15
  017d3	05 00 00 00 00	 add	 eax, OFFSET _states
  017d8	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  017db	76 23		 jbe	 SHORT $LN190@P_ProcessS
$LN191@P_ProcessS:

; 3399 : 				{
; 3400 : 					P_SetPlayerMobjState(player->mo, S_PLAY_ATK1);

  017dd	6a 0c		 push	 12			; 0000000cH
  017df	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  017e4	51		 push	 ecx
  017e5	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  017ea	83 c4 08	 add	 esp, 8

; 3401 : 					S_StartSound(player->mo, sfx_spin);

  017ed	68 d3 00 00 00	 push	 211			; 000000d3H
  017f2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  017f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  017f7	51		 push	 ecx
  017f8	e8 00 00 00 00	 call	 _S_StartSound
  017fd	83 c4 08	 add	 esp, 8
$LN190@P_ProcessS:

; 3402 : 				}
; 3403 : 			}
; 3404 : 			break;

  01800	e9 19 10 00 00	 jmp	 $LN17@P_ProcessS
$LN192@P_ProcessS:

; 3405 : 
; 3406 : 		case 9: // Zoom Tube End
; 3407 : 			{
; 3408 : 				INT32 sequence;
; 3409 : 				fixed_t speed;
; 3410 : 				INT32 lineindex;
; 3411 : 				thinker_t *th;
; 3412 : 				mobj_t *waypoint = NULL;

  01805	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _waypoint$21[ebp], 0

; 3413 : 				mobj_t *mo2;
; 3414 : 				angle_t an;
; 3415 : 
; 3416 : 				if (player->mo->tracer && player->mo->tracer->type == MT_TUBEWAYPOINT)

  0180f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01812	8b 08		 mov	 ecx, DWORD PTR [eax]
  01814	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [ecx+176], 0
  0181b	74 19		 je	 SHORT $LN193@P_ProcessS
  0181d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01820	8b 08		 mov	 ecx, DWORD PTR [eax]
  01822	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  01828	81 7a 7c 06 01
	00 00		 cmp	 DWORD PTR [edx+124], 262 ; 00000106H
  0182f	75 05		 jne	 SHORT $LN193@P_ProcessS

; 3417 : 					break;

  01831	e9 e8 0f 00 00	 jmp	 $LN17@P_ProcessS
$LN193@P_ProcessS:

; 3418 : 
; 3419 : 				// Find line #3 tagged to this sector
; 3420 : 				lineindex = P_FindSpecialLineFromTag(3, sector->tag, -1);

  01836	6a ff		 push	 -1
  01838	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0183b	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0183f	51		 push	 ecx
  01840	6a 03		 push	 3
  01842	e8 00 00 00 00	 call	 _P_FindSpecialLineFromTag
  01847	83 c4 0c	 add	 esp, 12			; 0000000cH
  0184a	89 85 44 ff ff
	ff		 mov	 DWORD PTR _lineindex$23[ebp], eax

; 3421 : 
; 3422 : 				if (lineindex == -1)

  01850	83 bd 44 ff ff
	ff ff		 cmp	 DWORD PTR _lineindex$23[ebp], -1
  01857	75 1a		 jne	 SHORT $LN194@P_ProcessS

; 3423 : 				{
; 3424 : 					CONS_Printf("ERROR: Sector special %d missing line special #3.\n", sector->special);

  01859	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  0185c	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  01860	51		 push	 ecx
  01861	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@HOADDFGL@ERROR?3?5Sector?5special?5?$CFd?5missin@
  01866	e8 00 00 00 00	 call	 _CONS_Printf
  0186b	83 c4 08	 add	 esp, 8

; 3425 : 					break;

  0186e	e9 ab 0f 00 00	 jmp	 $LN17@P_ProcessS
$LN194@P_ProcessS:

; 3426 : 				}
; 3427 : 
; 3428 : 				// Grab speed and sequence values
; 3429 : 				speed = -(abs(lines[lineindex].dx)/8); // Negative means reverse

  01873	6b 85 44 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$23[ebp], 76
  0187a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01880	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  01884	52		 push	 edx
  01885	e8 00 00 00 00	 call	 _abs
  0188a	83 c4 04	 add	 esp, 4
  0188d	99		 cdq
  0188e	83 e2 07	 and	 edx, 7
  01891	03 c2		 add	 eax, edx
  01893	c1 f8 03	 sar	 eax, 3
  01896	f7 d8		 neg	 eax
  01898	89 85 48 ff ff
	ff		 mov	 DWORD PTR _speed$24[ebp], eax

; 3430 : 				sequence = abs(lines[lineindex].dy)>>FRACBITS;

  0189e	6b 85 44 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$23[ebp], 76
  018a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  018ab	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  018af	52		 push	 edx
  018b0	e8 00 00 00 00	 call	 _abs
  018b5	83 c4 04	 add	 esp, 4
  018b8	c1 f8 10	 sar	 eax, 16			; 00000010H
  018bb	89 85 4c ff ff
	ff		 mov	 DWORD PTR _sequence$25[ebp], eax

; 3431 : 
; 3432 : 				// scan the thinkers
; 3433 : 				// to find the last waypoint
; 3434 : 				for (th = thinkercap.next; th != &thinkercap; th = th->next)

  018c1	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  018c6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _th$22[ebp], eax
  018cc	eb 0f		 jmp	 SHORT $LN30@P_ProcessS
$LN28@P_ProcessS:
  018ce	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _th$22[ebp]
  018d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  018d7	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _th$22[ebp], ecx
$LN30@P_ProcessS:
  018dd	81 bd 40 ff ff
	ff 00 00 00 00	 cmp	 DWORD PTR _th$22[ebp], OFFSET _thinkercap
  018e7	0f 84 82 00 00
	00		 je	 $LN29@P_ProcessS

; 3435 : 				{
; 3436 : 					if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  018ed	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _th$22[ebp]
  018f3	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  018fa	74 02		 je	 SHORT $LN195@P_ProcessS

; 3437 : 						continue;

  018fc	eb d0		 jmp	 SHORT $LN28@P_ProcessS
$LN195@P_ProcessS:

; 3438 : 
; 3439 : 					mo2 = (mobj_t *)th;

  018fe	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _th$22[ebp]
  01904	89 85 38 ff ff
	ff		 mov	 DWORD PTR _mo2$20[ebp], eax

; 3440 : 
; 3441 : 					if (mo2->type == MT_TUBEWAYPOINT && mo2->threshold == sequence)

  0190a	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$20[ebp]
  01910	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  01917	75 51		 jne	 SHORT $LN199@P_ProcessS
  01919	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$20[ebp]
  0191f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  01925	3b 8d 4c ff ff
	ff		 cmp	 ecx, DWORD PTR _sequence$25[ebp]
  0192b	75 3d		 jne	 SHORT $LN199@P_ProcessS

; 3442 : 					{
; 3443 : 						if (!waypoint)

  0192d	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR _waypoint$21[ebp], 0
  01934	75 0e		 jne	 SHORT $LN197@P_ProcessS

; 3444 : 							waypoint = mo2;

  01936	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$20[ebp]
  0193c	89 85 3c ff ff
	ff		 mov	 DWORD PTR _waypoint$21[ebp], eax
  01942	eb 26		 jmp	 SHORT $LN199@P_ProcessS
$LN197@P_ProcessS:

; 3445 : 						else if (mo2->health > waypoint->health)

  01944	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$20[ebp]
  0194a	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _waypoint$21[ebp]
  01950	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  01956	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  0195c	7e 0c		 jle	 SHORT $LN199@P_ProcessS

; 3446 : 							waypoint = mo2;

  0195e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _mo2$20[ebp]
  01964	89 85 3c ff ff
	ff		 mov	 DWORD PTR _waypoint$21[ebp], eax
$LN199@P_ProcessS:

; 3447 : 					}
; 3448 : 				}

  0196a	e9 5f ff ff ff	 jmp	 $LN28@P_ProcessS
$LN29@P_ProcessS:

; 3449 : 
; 3450 : 				if (!waypoint)

  0196f	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR _waypoint$21[ebp], 0
  01976	75 1b		 jne	 SHORT $LN200@P_ProcessS

; 3451 : 				{
; 3452 : 					CONS_Printf("ERROR: LAST WAYPOINT IN SEQUENCE %d NOT FOUND.\n", sequence);

  01978	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _sequence$25[ebp]
  0197e	50		 push	 eax
  0197f	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MHOJGJAN@ERROR?3?5LAST?5WAYPOINT?5IN?5SEQUENC@
  01984	e8 00 00 00 00	 call	 _CONS_Printf
  01989	83 c4 08	 add	 esp, 8

; 3453 : 					break;

  0198c	e9 8d 0e 00 00	 jmp	 $LN17@P_ProcessS

; 3454 : 				}

  01991	eb 31		 jmp	 SHORT $LN202@P_ProcessS
$LN200@P_ProcessS:

; 3455 : 				else if (cv_debug)

  01993	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  0199a	74 28		 je	 SHORT $LN202@P_ProcessS

; 3456 : 					CONS_Printf("Waypoint %d found in sequence %d - speed = %d\n",

  0199c	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _speed$24[ebp]
  019a2	50		 push	 eax
  019a3	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _sequence$25[ebp]
  019a9	51		 push	 ecx
  019aa	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _waypoint$21[ebp]
  019b0	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  019b6	50		 push	 eax
  019b7	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BGLBOMJP@Waypoint?5?$CFd?5found?5in?5sequence?5?$CF@
  019bc	e8 00 00 00 00	 call	 _CONS_Printf
  019c1	83 c4 10	 add	 esp, 16			; 00000010H
$LN202@P_ProcessS:

; 3457 : 																waypoint->health,
; 3458 : 																sequence,
; 3459 : 																speed);
; 3460 : 
; 3461 : 				an = R_PointToAngle2(player->mo->x, player->mo->y, waypoint->x, waypoint->y) - player->mo->angle;

  019c4	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _waypoint$21[ebp]
  019ca	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  019cd	51		 push	 ecx
  019ce	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _waypoint$21[ebp]
  019d4	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  019d7	50		 push	 eax
  019d8	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  019db	8b 11		 mov	 edx, DWORD PTR [ecx]
  019dd	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  019e0	50		 push	 eax
  019e1	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  019e4	8b 11		 mov	 edx, DWORD PTR [ecx]
  019e6	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  019e9	50		 push	 eax
  019ea	e8 00 00 00 00	 call	 _R_PointToAngle2
  019ef	83 c4 10	 add	 esp, 16			; 00000010H
  019f2	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  019f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  019f7	2b 42 24	 sub	 eax, DWORD PTR [edx+36]
  019fa	89 85 34 ff ff
	ff		 mov	 DWORD PTR _an$19[ebp], eax

; 3462 : 
; 3463 : 				if (an > ANGLE_90 && an < ANGLE_270 && !(lines[lineindex].flags & ML_EFFECT4))

  01a00	81 bd 34 ff ff
	ff 00 00 00 40	 cmp	 DWORD PTR _an$19[ebp], 1073741824 ; 40000000H
  01a0a	76 2b		 jbe	 SHORT $LN203@P_ProcessS
  01a0c	81 bd 34 ff ff
	ff 00 00 00 c0	 cmp	 DWORD PTR _an$19[ebp], -1073741824 ; c0000000H
  01a16	73 1f		 jae	 SHORT $LN203@P_ProcessS
  01a18	6b 85 44 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$23[ebp], 76
  01a1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01a25	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01a2a	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  01a30	75 05		 jne	 SHORT $LN203@P_ProcessS

; 3464 : 					break; // behind back

  01a32	e9 e7 0d 00 00	 jmp	 $LN17@P_ProcessS
$LN203@P_ProcessS:

; 3465 : 
; 3466 : 				P_SetTarget(&player->mo->tracer, waypoint);

  01a37	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _waypoint$21[ebp]
  01a3d	50		 push	 eax
  01a3e	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  01a41	8b 11		 mov	 edx, DWORD PTR [ecx]
  01a43	81 c2 b0 00 00
	00		 add	 edx, 176		; 000000b0H
  01a49	52		 push	 edx
  01a4a	e8 00 00 00 00	 call	 _P_SetTarget
  01a4f	83 c4 08	 add	 esp, 8

; 3467 : 				player->speed = speed;

  01a52	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01a55	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _speed$24[ebp]
  01a5b	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 3468 : 				player->pflags |= PF_SPINNING;

  01a61	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01a64	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  01a6a	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  01a70	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01a73	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3469 : 				player->pflags &= ~PF_JUMPED;

  01a79	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01a7c	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  01a82	81 e1 ff ef ff
	ff		 and	 ecx, -4097		; ffffefffH
  01a88	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01a8b	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3470 : 				player->scoreadd = 0;

  01a91	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01a94	c7 80 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+284], 0

; 3471 : 
; 3472 : 				if (!(player->mo->state >= &states[S_PLAY_ATK1] && player->mo->state <= &states[S_PLAY_ATK4]))

  01a9e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01aa1	8b 08		 mov	 ecx, DWORD PTR [eax]
  01aa3	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  01aa8	6b c2 0c	 imul	 eax, edx, 12
  01aab	05 00 00 00 00	 add	 eax, OFFSET _states
  01ab0	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  01ab3	72 17		 jb	 SHORT $LN205@P_ProcessS
  01ab5	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01ab8	8b 08		 mov	 ecx, DWORD PTR [eax]
  01aba	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  01abf	6b c2 0f	 imul	 eax, edx, 15
  01ac2	05 00 00 00 00	 add	 eax, OFFSET _states
  01ac7	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  01aca	76 23		 jbe	 SHORT $LN204@P_ProcessS
$LN205@P_ProcessS:

; 3473 : 				{
; 3474 : 					P_SetPlayerMobjState(player->mo, S_PLAY_ATK1);

  01acc	6a 0c		 push	 12			; 0000000cH
  01ace	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01ad1	8b 08		 mov	 ecx, DWORD PTR [eax]
  01ad3	51		 push	 ecx
  01ad4	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  01ad9	83 c4 08	 add	 esp, 8

; 3475 : 					S_StartSound(player->mo, sfx_spin);

  01adc	68 d3 00 00 00	 push	 211			; 000000d3H
  01ae1	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01ae4	8b 08		 mov	 ecx, DWORD PTR [eax]
  01ae6	51		 push	 ecx
  01ae7	e8 00 00 00 00	 call	 _S_StartSound
  01aec	83 c4 08	 add	 esp, 8
$LN204@P_ProcessS:

; 3476 : 				}
; 3477 : 			}
; 3478 : 			break;

  01aef	e9 2a 0d 00 00	 jmp	 $LN17@P_ProcessS
$LN206@P_ProcessS:

; 3479 : 
; 3480 : 		case 10: // Finish Line
; 3481 : 			if (gametype == GT_RACE && !player->exiting)

  01af4	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  01afb	83 f8 02	 cmp	 eax, 2
  01afe	0f 85 06 02 00
	00		 jne	 $LN214@P_ProcessS
  01b04	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b07	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [eax+304], 0
  01b0e	0f 85 f6 01 00
	00		 jne	 $LN214@P_ProcessS

; 3482 : 			{
; 3483 : 				if (player->starpostnum == numstarposts) // Must have touched all the starposts

  01b14	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b17	8b 88 8c 01 00
	00		 mov	 ecx, DWORD PTR [eax+396]
  01b1d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numstarposts
  01b23	0f 85 93 01 00
	00		 jne	 $LN32@P_ProcessS

; 3484 : 				{
; 3485 : 					thinker_t *th;
; 3486 : 					mobj_t *post;
; 3487 : 
; 3488 : 					player->laps++;

  01b29	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b2c	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  01b32	83 c1 01	 add	 ecx, 1
  01b35	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01b38	89 8a 5c 01 00
	00		 mov	 DWORD PTR [edx+348], ecx

; 3489 : 
; 3490 : 					if (player->pflags & PF_NIGHTSMODE)

  01b3e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b41	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  01b47	81 e1 00 00 20
	00		 and	 ecx, 2097152		; 00200000H
  01b4d	74 18		 je	 SHORT $LN209@P_ProcessS

; 3491 : 						player->drillmeter += 48*20;

  01b4f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b52	8b 88 c8 01 00
	00		 mov	 ecx, DWORD PTR [eax+456]
  01b58	81 c1 c0 03 00
	00		 add	 ecx, 960		; 000003c0H
  01b5e	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01b61	89 8a c8 01 00
	00		 mov	 DWORD PTR [edx+456], ecx
$LN209@P_ProcessS:

; 3492 : 
; 3493 : 					if (player->laps >= (unsigned)cv_numlaps.value)

  01b67	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b6a	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  01b70	3b 0d 14 00 00
	00		 cmp	 ecx, DWORD PTR _cv_numlaps+20
  01b76	72 36		 jb	 SHORT $LN210@P_ProcessS

; 3494 : 						CONS_Printf(text[FINISHEDFINALLAP], player_names[player-players]);

  01b78	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01b7b	2d 00 00 00 00	 sub	 eax, OFFSET _players
  01b80	99		 cdq
  01b81	b9 fc 01 00 00	 mov	 ecx, 508		; 000001fcH
  01b86	f7 f9		 idiv	 ecx
  01b88	6b d0 16	 imul	 edx, eax, 22
  01b8b	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  01b91	52		 push	 edx
  01b92	b8 04 00 00 00	 mov	 eax, 4
  01b97	69 c8 30 01 00
	00		 imul	 ecx, eax, 304
  01b9d	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  01ba3	52		 push	 edx
  01ba4	e8 00 00 00 00	 call	 _CONS_Printf
  01ba9	83 c4 08	 add	 esp, 8
  01bac	eb 41		 jmp	 SHORT $LN211@P_ProcessS
$LN210@P_ProcessS:

; 3495 : 					else
; 3496 : 						CONS_Printf(text[STARTEDLAP], player_names[player-players],player->laps+1);

  01bae	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01bb1	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  01bb7	83 c1 01	 add	 ecx, 1
  01bba	51		 push	 ecx
  01bbb	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01bbe	2d 00 00 00 00	 sub	 eax, OFFSET _players
  01bc3	99		 cdq
  01bc4	b9 fc 01 00 00	 mov	 ecx, 508		; 000001fcH
  01bc9	f7 f9		 idiv	 ecx
  01bcb	6b d0 16	 imul	 edx, eax, 22
  01bce	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  01bd4	52		 push	 edx
  01bd5	b8 04 00 00 00	 mov	 eax, 4
  01bda	69 c8 31 01 00
	00		 imul	 ecx, eax, 305
  01be0	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  01be6	52		 push	 edx
  01be7	e8 00 00 00 00	 call	 _CONS_Printf
  01bec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN211@P_ProcessS:

; 3497 : 
; 3498 : 					// Reset starposts (checkpoints) info
; 3499 : 					player->starpostangle = player->starposttime = player->starpostnum = player->starpostbit = 0;

  01bef	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01bf2	c7 80 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+408], 0
  01bfc	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  01bff	c7 81 8c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+396], 0
  01c09	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01c0c	c7 82 90 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+400], 0
  01c16	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01c19	c7 80 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+404], 0

; 3500 : 					player->starpostx = player->starposty = player->starpostz = 0;

  01c23	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01c26	c7 80 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+392], 0
  01c30	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  01c33	c7 81 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+388], 0
  01c3d	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01c40	c7 82 80 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+384], 0

; 3501 : 					for (th = thinkercap.next; th != &thinkercap; th = th->next)

  01c4a	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  01c4f	89 85 30 ff ff
	ff		 mov	 DWORD PTR _th$18[ebp], eax
  01c55	eb 0f		 jmp	 SHORT $LN33@P_ProcessS
$LN31@P_ProcessS:
  01c57	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _th$18[ebp]
  01c5d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01c60	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _th$18[ebp], ecx
$LN33@P_ProcessS:
  01c66	81 bd 30 ff ff
	ff 00 00 00 00	 cmp	 DWORD PTR _th$18[ebp], OFFSET _thinkercap
  01c70	74 4a		 je	 SHORT $LN32@P_ProcessS

; 3502 : 					{
; 3503 : 						if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  01c72	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _th$18[ebp]
  01c78	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  01c7f	74 02		 je	 SHORT $LN212@P_ProcessS

; 3504 : 							continue;

  01c81	eb d4		 jmp	 SHORT $LN31@P_ProcessS
$LN212@P_ProcessS:

; 3505 : 
; 3506 : 						post = (mobj_t *)th;

  01c83	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _th$18[ebp]
  01c89	89 85 2c ff ff
	ff		 mov	 DWORD PTR _post$17[ebp], eax

; 3507 : 
; 3508 : 						if (post->type == MT_STARPOST)

  01c8f	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _post$17[ebp]
  01c95	83 78 7c 4a	 cmp	 DWORD PTR [eax+124], 74	; 0000004aH
  01c99	75 1f		 jne	 SHORT $LN213@P_ProcessS

; 3509 : 							P_SetMobjState(post, post->info->spawnstate);

  01c9b	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _post$17[ebp]
  01ca1	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01ca7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01caa	52		 push	 edx
  01cab	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _post$17[ebp]
  01cb1	50		 push	 eax
  01cb2	e8 00 00 00 00	 call	 _P_SetMobjState
  01cb7	83 c4 08	 add	 esp, 8
$LN213@P_ProcessS:

; 3510 : 					}

  01cba	eb 9b		 jmp	 SHORT $LN31@P_ProcessS
$LN32@P_ProcessS:

; 3511 : 				}
; 3512 : 
; 3513 : 				if (player->laps >= (unsigned)cv_numlaps.value)

  01cbc	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01cbf	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  01cc5	3b 0d 14 00 00
	00		 cmp	 ecx, DWORD PTR _cv_numlaps+20
  01ccb	72 3d		 jb	 SHORT $LN214@P_ProcessS

; 3514 : 				{
; 3515 : 					if (P_IsLocalPlayer(player))

  01ccd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01cd0	50		 push	 eax
  01cd1	e8 00 00 00 00	 call	 _P_IsLocalPlayer
  01cd6	83 c4 04	 add	 esp, 4
  01cd9	85 c0		 test	 eax, eax
  01cdb	74 21		 je	 SHORT $LN215@P_ProcessS

; 3516 : 					{
; 3517 : 						HU_SetCEchoFlags(0);

  01cdd	6a 00		 push	 0
  01cdf	e8 00 00 00 00	 call	 _HU_SetCEchoFlags
  01ce4	83 c4 04	 add	 esp, 4

; 3518 : 						HU_SetCEchoDuration(5);

  01ce7	6a 05		 push	 5
  01ce9	e8 00 00 00 00	 call	 _HU_SetCEchoDuration
  01cee	83 c4 04	 add	 esp, 4

; 3519 : 						HU_DoCEcho("FINISHED!");

  01cf1	68 00 00 00 00	 push	 OFFSET ??_C@_09KFDLEEGG@FINISHED?$CB@
  01cf6	e8 00 00 00 00	 call	 _HU_DoCEcho
  01cfb	83 c4 04	 add	 esp, 4
$LN215@P_ProcessS:

; 3520 : 					}
; 3521 : 
; 3522 : 					P_DoPlayerExit(player);

  01cfe	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01d01	50		 push	 eax
  01d02	e8 00 00 00 00	 call	 _P_DoPlayerExit
  01d07	83 c4 04	 add	 esp, 4
$LN214@P_ProcessS:

; 3523 : 				}
; 3524 : 			}
; 3525 : 			break;

  01d0a	e9 0f 0b 00 00	 jmp	 $LN17@P_ProcessS
$LN216@P_ProcessS:

; 3526 : 
; 3527 : 		case 11: // Rope hang
; 3528 : 			{
; 3529 : 				INT32 sequence;
; 3530 : 				fixed_t speed;
; 3531 : 				INT32 lineindex;
; 3532 : 				thinker_t *th;
; 3533 : 				mobj_t *waypointmid = NULL;

  01d0f	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _waypointmid$12[ebp], 0

; 3534 : 				mobj_t *waypointhigh = NULL;

  01d19	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _waypointhigh$11[ebp], 0

; 3535 : 				mobj_t *waypointlow = NULL;

  01d23	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _waypointlow$10[ebp], 0

; 3536 : 				mobj_t *mo2;
; 3537 : 				mobj_t *closest = NULL;

  01d2d	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _closest$8[ebp], 0

; 3538 : 				line_t junk;
; 3539 : 				vertex_t v1, v2, resulthigh, resultlow;
; 3540 : 				mobj_t *highest = NULL;

  01d37	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _highest$2[ebp], 0

; 3541 : 				boolean minecart = false;

  01d41	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _minecart$1[ebp], 0

; 3542 : 
; 3543 : 				if (player->mo->tracer && player->mo->tracer->type == MT_TUBEWAYPOINT)

  01d4b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01d4e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d50	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [ecx+176], 0
  01d57	74 19		 je	 SHORT $LN217@P_ProcessS
  01d59	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01d5c	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d5e	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  01d64	81 7a 7c 06 01
	00 00		 cmp	 DWORD PTR [edx+124], 262 ; 00000106H
  01d6b	75 05		 jne	 SHORT $LN217@P_ProcessS

; 3544 : 					break;

  01d6d	e9 ac 0a 00 00	 jmp	 $LN17@P_ProcessS
$LN217@P_ProcessS:

; 3545 : 
; 3546 : 				if (player->mo->momz > 0)

  01d72	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01d75	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d77	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  01d7b	7e 05		 jle	 SHORT $LN218@P_ProcessS

; 3547 : 					break;

  01d7d	e9 9c 0a 00 00	 jmp	 $LN17@P_ProcessS
$LN218@P_ProcessS:

; 3548 : 
; 3549 : 				if (player->cmd.buttons & BT_USE)

  01d82	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01d85	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  01d89	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  01d8f	74 05		 je	 SHORT $LN219@P_ProcessS

; 3550 : 					break;

  01d91	e9 88 0a 00 00	 jmp	 $LN17@P_ProcessS
$LN219@P_ProcessS:

; 3551 : 
; 3552 : 				if (player->mo->state == &states[player->mo->info->painstate])

  01d96	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01d99	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d9b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01d9e	8b 02		 mov	 eax, DWORD PTR [edx]
  01da0	8b 90 80 00 00
	00		 mov	 edx, DWORD PTR [eax+128]
  01da6	6b 42 1c 1c	 imul	 eax, DWORD PTR [edx+28], 28
  01daa	05 00 00 00 00	 add	 eax, OFFSET _states
  01daf	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  01db2	75 05		 jne	 SHORT $LN220@P_ProcessS

; 3553 : 					break;

  01db4	e9 65 0a 00 00	 jmp	 $LN17@P_ProcessS
$LN220@P_ProcessS:

; 3554 : 
; 3555 : 				if (player->exiting)

  01db9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01dbc	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [eax+304], 0
  01dc3	74 05		 je	 SHORT $LN221@P_ProcessS

; 3556 : 					break;

  01dc5	e9 54 0a 00 00	 jmp	 $LN17@P_ProcessS
$LN221@P_ProcessS:

; 3557 : 
; 3558 : 				//initialize resulthigh and resultlow with 0
; 3559 : 				memset(&resultlow, 0x00, sizeof(resultlow));

  01dca	6a 0c		 push	 12			; 0000000cH
  01dcc	6a 00		 push	 0
  01dce	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _resultlow$3[ebp]
  01dd4	50		 push	 eax
  01dd5	e8 00 00 00 00	 call	 _memset
  01dda	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3560 : 				memset(&resulthigh, 0x00, sizeof(resulthigh));

  01ddd	6a 0c		 push	 12			; 0000000cH
  01ddf	6a 00		 push	 0
  01de1	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _resulthigh$4[ebp]
  01de7	50		 push	 eax
  01de8	e8 00 00 00 00	 call	 _memset
  01ded	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3561 : 
; 3562 : 				// Find line #11 tagged to this sector
; 3563 : 				lineindex = P_FindSpecialLineFromTag(11, sector->tag, -1);

  01df0	6a ff		 push	 -1
  01df2	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  01df5	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  01df9	51		 push	 ecx
  01dfa	6a 0b		 push	 11			; 0000000bH
  01dfc	e8 00 00 00 00	 call	 _P_FindSpecialLineFromTag
  01e01	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e04	89 85 20 ff ff
	ff		 mov	 DWORD PTR _lineindex$14[ebp], eax

; 3564 : 
; 3565 : 				if (lineindex == -1)

  01e0a	83 bd 20 ff ff
	ff ff		 cmp	 DWORD PTR _lineindex$14[ebp], -1
  01e11	75 1a		 jne	 SHORT $LN222@P_ProcessS

; 3566 : 				{
; 3567 : 					CONS_Printf("ERROR: Sector special %d missing line special #11.\n", sector->special);

  01e13	8b 45 0c	 mov	 eax, DWORD PTR _sector$[ebp]
  01e16	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  01e1a	51		 push	 ecx
  01e1b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GNAPKJPK@ERROR?3?5Sector?5special?5?$CFd?5missin@
  01e20	e8 00 00 00 00	 call	 _CONS_Printf
  01e25	83 c4 08	 add	 esp, 8

; 3568 : 					break;

  01e28	e9 f1 09 00 00	 jmp	 $LN17@P_ProcessS
$LN222@P_ProcessS:

; 3569 : 				}
; 3570 : 
; 3571 : 				if (lines[lineindex].flags & ML_EFFECT5)

  01e2d	6b 85 20 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$14[ebp], 76
  01e34	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01e3a	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01e3f	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  01e45	74 0a		 je	 SHORT $LN223@P_ProcessS

; 3572 : 					minecart = true;

  01e47	c7 85 84 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _minecart$1[ebp], 1
$LN223@P_ProcessS:

; 3573 : 
; 3574 : 				// Grab speed and sequence values
; 3575 : 				speed = abs(lines[lineindex].dx)/8;

  01e51	6b 85 20 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$14[ebp], 76
  01e58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01e5e	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  01e62	52		 push	 edx
  01e63	e8 00 00 00 00	 call	 _abs
  01e68	83 c4 04	 add	 esp, 4
  01e6b	99		 cdq
  01e6c	83 e2 07	 and	 edx, 7
  01e6f	03 c2		 add	 eax, edx
  01e71	c1 f8 03	 sar	 eax, 3
  01e74	89 85 24 ff ff
	ff		 mov	 DWORD PTR _speed$15[ebp], eax

; 3576 : 				sequence = abs(lines[lineindex].dy)>>FRACBITS;

  01e7a	6b 85 20 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$14[ebp], 76
  01e81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01e87	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  01e8b	52		 push	 edx
  01e8c	e8 00 00 00 00	 call	 _abs
  01e91	83 c4 04	 add	 esp, 4
  01e94	c1 f8 10	 sar	 eax, 16			; 00000010H
  01e97	89 85 28 ff ff
	ff		 mov	 DWORD PTR _sequence$16[ebp], eax

; 3577 : 
; 3578 : 				// Find the two closest waypoints
; 3579 : 				// Determine the closest spot on the line between the two waypoints
; 3580 : 				// Put player at that location.
; 3581 : 
; 3582 : 				// scan the thinkers
; 3583 : 				// to find the first waypoint
; 3584 : 				for (th = thinkercap.next; th != &thinkercap; th = th->next)

  01e9d	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  01ea2	89 85 1c ff ff
	ff		 mov	 DWORD PTR _th$13[ebp], eax
  01ea8	eb 0f		 jmp	 SHORT $LN36@P_ProcessS
$LN34@P_ProcessS:
  01eaa	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  01eb0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01eb3	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _th$13[ebp], ecx
$LN36@P_ProcessS:
  01eb9	81 bd 1c ff ff
	ff 00 00 00 00	 cmp	 DWORD PTR _th$13[ebp], OFFSET _thinkercap
  01ec3	0f 84 38 01 00
	00		 je	 $LN35@P_ProcessS

; 3585 : 				{
; 3586 : 					if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  01ec9	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  01ecf	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  01ed6	74 02		 je	 SHORT $LN224@P_ProcessS

; 3587 : 						continue;

  01ed8	eb d0		 jmp	 SHORT $LN34@P_ProcessS
$LN224@P_ProcessS:

; 3588 : 
; 3589 : 					mo2 = (mobj_t *)th;

  01eda	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  01ee0	89 85 0c ff ff
	ff		 mov	 DWORD PTR _mo2$9[ebp], eax

; 3590 : 
; 3591 : 					if (mo2->type != MT_TUBEWAYPOINT)

  01ee6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01eec	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  01ef3	74 02		 je	 SHORT $LN225@P_ProcessS

; 3592 : 						continue;

  01ef5	eb b3		 jmp	 SHORT $LN34@P_ProcessS
$LN225@P_ProcessS:

; 3593 : 
; 3594 : 					if (mo2->threshold != sequence)

  01ef7	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01efd	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  01f03	3b 8d 28 ff ff
	ff		 cmp	 ecx, DWORD PTR _sequence$16[ebp]
  01f09	74 02		 je	 SHORT $LN226@P_ProcessS

; 3595 : 						continue;

  01f0b	eb 9d		 jmp	 SHORT $LN34@P_ProcessS
$LN226@P_ProcessS:

; 3596 : 
; 3597 : 					if (!highest)

  01f0d	83 bd 88 fe ff
	ff 00		 cmp	 DWORD PTR _highest$2[ebp], 0
  01f14	75 0e		 jne	 SHORT $LN227@P_ProcessS

; 3598 : 						highest = mo2;

  01f16	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01f1c	89 85 88 fe ff
	ff		 mov	 DWORD PTR _highest$2[ebp], eax
  01f22	eb 26		 jmp	 SHORT $LN229@P_ProcessS
$LN227@P_ProcessS:

; 3599 : 					else if (mo2->health > highest->health) // Find the highest waypoint # in case we wrap

  01f24	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01f2a	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _highest$2[ebp]
  01f30	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  01f36	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  01f3c	7e 0c		 jle	 SHORT $LN229@P_ProcessS

; 3600 : 						highest = mo2;

  01f3e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01f44	89 85 88 fe ff
	ff		 mov	 DWORD PTR _highest$2[ebp], eax
$LN229@P_ProcessS:

; 3601 : 
; 3602 : 					if (closest && P_AproxDistance(P_AproxDistance(player->mo->x-mo2->x, player->mo->y-mo2->y),

  01f4a	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR _closest$8[ebp], 0
  01f51	0f 84 99 00 00
	00		 je	 $LN230@P_ProcessS
  01f57	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01f5a	8b 08		 mov	 ecx, DWORD PTR [eax]
  01f5c	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _mo2$9[ebp]
  01f62	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01f65	2b 42 18	 sub	 eax, DWORD PTR [edx+24]
  01f68	50		 push	 eax
  01f69	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  01f6c	8b 11		 mov	 edx, DWORD PTR [ecx]
  01f6e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01f74	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  01f77	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  01f7a	51		 push	 ecx
  01f7b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01f7e	8b 02		 mov	 eax, DWORD PTR [edx]
  01f80	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _mo2$9[ebp]
  01f86	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01f89	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  01f8c	52		 push	 edx
  01f8d	e8 00 00 00 00	 call	 _P_AproxDistance
  01f92	83 c4 08	 add	 esp, 8
  01f95	50		 push	 eax
  01f96	e8 00 00 00 00	 call	 _P_AproxDistance
  01f9b	83 c4 08	 add	 esp, 8
  01f9e	8b f0		 mov	 esi, eax
  01fa0	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  01fa3	8b 08		 mov	 ecx, DWORD PTR [eax]
  01fa5	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _closest$8[ebp]
  01fab	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  01fae	2b 42 18	 sub	 eax, DWORD PTR [edx+24]
  01fb1	50		 push	 eax
  01fb2	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  01fb5	8b 11		 mov	 edx, DWORD PTR [ecx]
  01fb7	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _closest$8[ebp]
  01fbd	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  01fc0	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  01fc3	51		 push	 ecx
  01fc4	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  01fc7	8b 02		 mov	 eax, DWORD PTR [edx]
  01fc9	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _closest$8[ebp]
  01fcf	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01fd2	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  01fd5	52		 push	 edx
  01fd6	e8 00 00 00 00	 call	 _P_AproxDistance
  01fdb	83 c4 08	 add	 esp, 8
  01fde	50		 push	 eax
  01fdf	e8 00 00 00 00	 call	 _P_AproxDistance
  01fe4	83 c4 08	 add	 esp, 8
  01fe7	3b f0		 cmp	 esi, eax
  01fe9	7e 05		 jle	 SHORT $LN230@P_ProcessS

; 3603 : 						player->mo->z-mo2->z) > P_AproxDistance(P_AproxDistance(player->mo->x-closest->x,
; 3604 : 						player->mo->y-closest->y), player->mo->z-closest->z))
; 3605 : 						continue;

  01feb	e9 ba fe ff ff	 jmp	 $LN34@P_ProcessS
$LN230@P_ProcessS:

; 3606 : 
; 3607 : 					// Found a target
; 3608 : 					closest = mo2;

  01ff0	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  01ff6	89 85 08 ff ff
	ff		 mov	 DWORD PTR _closest$8[ebp], eax

; 3609 : 				}

  01ffc	e9 a9 fe ff ff	 jmp	 $LN34@P_ProcessS
$LN35@P_ProcessS:

; 3610 : 
; 3611 : 				waypointmid = closest;

  02001	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _closest$8[ebp]
  02007	89 85 18 ff ff
	ff		 mov	 DWORD PTR _waypointmid$12[ebp], eax

; 3612 : 
; 3613 : 				closest = NULL;

  0200d	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _closest$8[ebp], 0

; 3614 : 
; 3615 : 				if (waypointmid == NULL)

  02017	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _waypointmid$12[ebp], 0
  0201e	75 19		 jne	 SHORT $LN231@P_ProcessS

; 3616 : 				{
; 3617 : 					CONS_Printf("ERROR: WAYPOINT(S) IN SEQUENCE %d NOT FOUND.\n", sequence);

  02020	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _sequence$16[ebp]
  02026	50		 push	 eax
  02027	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@NDOBHENA@ERROR?3?5WAYPOINT?$CIS?$CJ?5IN?5SEQUENCE?5@
  0202c	e8 00 00 00 00	 call	 _CONS_Printf
  02031	83 c4 08	 add	 esp, 8

; 3618 : 					break;

  02034	e9 e5 07 00 00	 jmp	 $LN17@P_ProcessS
$LN231@P_ProcessS:

; 3619 : 				}
; 3620 : 
; 3621 : 				// Find waypoint before this one (waypointlow)
; 3622 : 				for (th = thinkercap.next; th != &thinkercap; th = th->next)

  02039	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0203e	89 85 1c ff ff
	ff		 mov	 DWORD PTR _th$13[ebp], eax
  02044	eb 0f		 jmp	 SHORT $LN39@P_ProcessS
$LN37@P_ProcessS:
  02046	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  0204c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0204f	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _th$13[ebp], ecx
$LN39@P_ProcessS:
  02055	81 bd 1c ff ff
	ff 00 00 00 00	 cmp	 DWORD PTR _th$13[ebp], OFFSET _thinkercap
  0205f	0f 84 a9 00 00
	00		 je	 $LN38@P_ProcessS

; 3623 : 				{
; 3624 : 					if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  02065	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  0206b	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  02072	74 02		 je	 SHORT $LN232@P_ProcessS

; 3625 : 						continue;

  02074	eb d0		 jmp	 SHORT $LN37@P_ProcessS
$LN232@P_ProcessS:

; 3626 : 
; 3627 : 					mo2 = (mobj_t *)th;

  02076	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  0207c	89 85 0c ff ff
	ff		 mov	 DWORD PTR _mo2$9[ebp], eax

; 3628 : 
; 3629 : 					if (mo2->type != MT_TUBEWAYPOINT)

  02082	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  02088	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  0208f	74 02		 je	 SHORT $LN233@P_ProcessS

; 3630 : 						continue;

  02091	eb b3		 jmp	 SHORT $LN37@P_ProcessS
$LN233@P_ProcessS:

; 3631 : 
; 3632 : 					if (mo2->threshold != sequence)

  02093	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  02099	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0209f	3b 8d 28 ff ff
	ff		 cmp	 ecx, DWORD PTR _sequence$16[ebp]
  020a5	74 02		 je	 SHORT $LN234@P_ProcessS

; 3633 : 						continue;

  020a7	eb 9d		 jmp	 SHORT $LN37@P_ProcessS
$LN234@P_ProcessS:

; 3634 : 
; 3635 : 					if (waypointmid->health == 0)

  020a9	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  020af	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  020b6	75 21		 jne	 SHORT $LN235@P_ProcessS

; 3636 : 					{
; 3637 : 						if (mo2->health != highest->health)

  020b8	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  020be	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _highest$2[ebp]
  020c4	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  020ca	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  020d0	74 05		 je	 SHORT $LN237@P_ProcessS

; 3638 : 							continue;

  020d2	e9 6f ff ff ff	 jmp	 $LN37@P_ProcessS
$LN237@P_ProcessS:

; 3639 : 					}

  020d7	eb 22		 jmp	 SHORT $LN238@P_ProcessS
$LN235@P_ProcessS:

; 3640 : 					else if (mo2->health != waypointmid->health - 1)

  020d9	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  020df	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  020e5	83 e9 01	 sub	 ecx, 1
  020e8	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _mo2$9[ebp]
  020ee	39 8a 8c 00 00
	00		 cmp	 DWORD PTR [edx+140], ecx
  020f4	74 05		 je	 SHORT $LN238@P_ProcessS

; 3641 : 						continue;

  020f6	e9 4b ff ff ff	 jmp	 $LN37@P_ProcessS
$LN238@P_ProcessS:

; 3642 : 
; 3643 : 					// Found a target
; 3644 : 					waypointlow = mo2;

  020fb	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  02101	89 85 10 ff ff
	ff		 mov	 DWORD PTR _waypointlow$10[ebp], eax

; 3645 : 					break;

  02107	eb 05		 jmp	 SHORT $LN38@P_ProcessS

; 3646 : 				}

  02109	e9 38 ff ff ff	 jmp	 $LN37@P_ProcessS
$LN38@P_ProcessS:

; 3647 : 
; 3648 : 				// Find waypoint before this one (waypointhigh)
; 3649 : 				for (th = thinkercap.next; th != &thinkercap; th = th->next)

  0210e	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  02113	89 85 1c ff ff
	ff		 mov	 DWORD PTR _th$13[ebp], eax
  02119	eb 0f		 jmp	 SHORT $LN42@P_ProcessS
$LN40@P_ProcessS:
  0211b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  02121	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02124	89 8d 1c ff ff
	ff		 mov	 DWORD PTR _th$13[ebp], ecx
$LN42@P_ProcessS:
  0212a	81 bd 1c ff ff
	ff 00 00 00 00	 cmp	 DWORD PTR _th$13[ebp], OFFSET _thinkercap
  02134	0f 84 a9 00 00
	00		 je	 $LN41@P_ProcessS

; 3650 : 				{
; 3651 : 					if (th->function.acp1 != (actionf_p1)P_MobjThinker)

  0213a	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  02140	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  02147	74 02		 je	 SHORT $LN239@P_ProcessS

; 3652 : 						continue;

  02149	eb d0		 jmp	 SHORT $LN40@P_ProcessS
$LN239@P_ProcessS:

; 3653 : 
; 3654 : 					mo2 = (mobj_t *)th;

  0214b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _th$13[ebp]
  02151	89 85 0c ff ff
	ff		 mov	 DWORD PTR _mo2$9[ebp], eax

; 3655 : 
; 3656 : 					if (mo2->type != MT_TUBEWAYPOINT)

  02157	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  0215d	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  02164	74 02		 je	 SHORT $LN240@P_ProcessS

; 3657 : 						continue;

  02166	eb b3		 jmp	 SHORT $LN40@P_ProcessS
$LN240@P_ProcessS:

; 3658 : 
; 3659 : 					if (mo2->threshold != sequence)

  02168	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  0216e	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  02174	3b 8d 28 ff ff
	ff		 cmp	 ecx, DWORD PTR _sequence$16[ebp]
  0217a	74 02		 je	 SHORT $LN241@P_ProcessS

; 3660 : 						continue;

  0217c	eb 9d		 jmp	 SHORT $LN40@P_ProcessS
$LN241@P_ProcessS:

; 3661 : 
; 3662 : 					if (waypointmid->health == highest->health)

  0217e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  02184	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _highest$2[ebp]
  0218a	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  02190	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  02196	75 16		 jne	 SHORT $LN242@P_ProcessS

; 3663 : 					{
; 3664 : 						if (mo2->health != 0)

  02198	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  0219e	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  021a5	74 05		 je	 SHORT $LN244@P_ProcessS

; 3665 : 							continue;

  021a7	e9 6f ff ff ff	 jmp	 $LN40@P_ProcessS
$LN244@P_ProcessS:

; 3666 : 					}

  021ac	eb 22		 jmp	 SHORT $LN245@P_ProcessS
$LN242@P_ProcessS:

; 3667 : 					else if (mo2->health != waypointmid->health + 1)

  021ae	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  021b4	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  021ba	83 c1 01	 add	 ecx, 1
  021bd	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _mo2$9[ebp]
  021c3	39 8a 8c 00 00
	00		 cmp	 DWORD PTR [edx+140], ecx
  021c9	74 05		 je	 SHORT $LN245@P_ProcessS

; 3668 : 						continue;

  021cb	e9 4b ff ff ff	 jmp	 $LN40@P_ProcessS
$LN245@P_ProcessS:

; 3669 : 
; 3670 : 					// Found a target
; 3671 : 					waypointhigh = mo2;

  021d0	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _mo2$9[ebp]
  021d6	89 85 14 ff ff
	ff		 mov	 DWORD PTR _waypointhigh$11[ebp], eax

; 3672 : 					break;

  021dc	eb 05		 jmp	 SHORT $LN41@P_ProcessS

; 3673 : 				}

  021de	e9 38 ff ff ff	 jmp	 $LN40@P_ProcessS
$LN41@P_ProcessS:

; 3674 : 
; 3675 : 				if (cv_debug)

  021e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  021ea	74 76		 je	 SHORT $LN246@P_ProcessS

; 3676 : 					CONS_Printf("WaypointMid: %d; WaypointLow: %d; WaypointHigh: %d\n", waypointmid->health, waypointlow ? waypointlow->health : -1, waypointhigh ? waypointhigh->health : -1);

  021ec	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR _waypointhigh$11[ebp], 0
  021f3	74 14		 je	 SHORT $LN276@P_ProcessS
  021f5	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  021fb	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  02201	89 8d 40 fe ff
	ff		 mov	 DWORD PTR tv1482[ebp], ecx
  02207	eb 0a		 jmp	 SHORT $LN277@P_ProcessS
$LN276@P_ProcessS:
  02209	c7 85 40 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv1482[ebp], -1
$LN277@P_ProcessS:
  02213	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR _waypointlow$10[ebp], 0
  0221a	74 14		 je	 SHORT $LN278@P_ProcessS
  0221c	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _waypointlow$10[ebp]
  02222	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  02228	89 85 3c fe ff
	ff		 mov	 DWORD PTR tv1486[ebp], eax
  0222e	eb 0a		 jmp	 SHORT $LN279@P_ProcessS
$LN278@P_ProcessS:
  02230	c7 85 3c fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv1486[ebp], -1
$LN279@P_ProcessS:
  0223a	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv1482[ebp]
  02240	51		 push	 ecx
  02241	8b 95 3c fe ff
	ff		 mov	 edx, DWORD PTR tv1486[ebp]
  02247	52		 push	 edx
  02248	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  0224e	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  02254	51		 push	 ecx
  02255	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KBAFCDBG@WaypointMid?3?5?$CFd?$DL?5WaypointLow?3?5?$CF@
  0225a	e8 00 00 00 00	 call	 _CONS_Printf
  0225f	83 c4 10	 add	 esp, 16			; 00000010H
$LN246@P_ProcessS:

; 3677 : 
; 3678 : 				// Now we have three waypoints... the closest one we're near, and the one that comes before, and after.
; 3679 : 				// Next, we need to find the closest point on the line between each set, and determine which one we're
; 3680 : 				// closest to.
; 3681 : 
; 3682 : 				// Waypointmid and Waypointlow:
; 3683 : 				if (waypointlow)

  02262	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR _waypointlow$10[ebp], 0
  02269	0f 84 cd 00 00
	00		 je	 $LN247@P_ProcessS

; 3684 : 				{
; 3685 : 					v1.x = waypointmid->x;

  0226f	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  02275	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02278	89 8d b0 fe ff
	ff		 mov	 DWORD PTR _v1$6[ebp], ecx

; 3686 : 					v1.y = waypointmid->y;

  0227e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  02284	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  02287	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _v1$6[ebp+4], ecx

; 3687 : 					v1.z = waypointmid->z;

  0228d	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  02293	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02296	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _v1$6[ebp+8], ecx

; 3688 : 					v2.x = waypointlow->x;

  0229c	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _waypointlow$10[ebp]
  022a2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  022a5	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _v2$5[ebp], ecx

; 3689 : 					v2.y = waypointlow->y;

  022ab	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _waypointlow$10[ebp]
  022b1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  022b4	89 8d a8 fe ff
	ff		 mov	 DWORD PTR _v2$5[ebp+4], ecx

; 3690 : 					v2.z = waypointlow->z;

  022ba	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _waypointlow$10[ebp]
  022c0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  022c3	89 8d ac fe ff
	ff		 mov	 DWORD PTR _v2$5[ebp+8], ecx

; 3691 : 					junk.v1 = &v1;

  022c9	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _v1$6[ebp]
  022cf	89 85 bc fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp], eax

; 3692 : 					junk.v2 = &v2;

  022d5	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _v2$5[ebp]
  022db	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp+4], eax

; 3693 : 					junk.dx = v2.x - v1.x;

  022e1	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _v2$5[ebp]
  022e7	2b 85 b0 fe ff
	ff		 sub	 eax, DWORD PTR _v1$6[ebp]
  022ed	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp+8], eax

; 3694 : 					junk.dy = v2.y - v1.y;

  022f3	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _v2$5[ebp+4]
  022f9	2b 85 b4 fe ff
	ff		 sub	 eax, DWORD PTR _v1$6[ebp+4]
  022ff	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp+12], eax

; 3695 : 
; 3696 : 					P_ClosestPointOnLine(player->mo->x, player->mo->y, &junk, &resultlow);

  02305	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _resultlow$3[ebp]
  0230b	50		 push	 eax
  0230c	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _junk$7[ebp]
  02312	51		 push	 ecx
  02313	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02316	8b 02		 mov	 eax, DWORD PTR [edx]
  02318	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0231b	51		 push	 ecx
  0231c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0231f	8b 02		 mov	 eax, DWORD PTR [edx]
  02321	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02324	51		 push	 ecx
  02325	e8 00 00 00 00	 call	 _P_ClosestPointOnLine
  0232a	83 c4 10	 add	 esp, 16			; 00000010H

; 3697 : 					resultlow.z = waypointmid->z;

  0232d	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  02333	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02336	89 8d 94 fe ff
	ff		 mov	 DWORD PTR _resultlow$3[ebp+8], ecx
$LN247@P_ProcessS:

; 3698 : 				}
; 3699 : 
; 3700 : 				// Waypointmid and Waypointhigh:
; 3701 : 				if (waypointhigh)

  0233c	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR _waypointhigh$11[ebp], 0
  02343	0f 84 cd 00 00
	00		 je	 $LN248@P_ProcessS

; 3702 : 				{
; 3703 : 					v1.x = waypointmid->x;

  02349	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  0234f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02352	89 8d b0 fe ff
	ff		 mov	 DWORD PTR _v1$6[ebp], ecx

; 3704 : 					v1.y = waypointmid->y;

  02358	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  0235e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  02361	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _v1$6[ebp+4], ecx

; 3705 : 					v1.z = waypointmid->z;

  02367	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  0236d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02370	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _v1$6[ebp+8], ecx

; 3706 : 					v2.x = waypointhigh->x;

  02376	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  0237c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0237f	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _v2$5[ebp], ecx

; 3707 : 					v2.y = waypointhigh->y;

  02385	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  0238b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0238e	89 8d a8 fe ff
	ff		 mov	 DWORD PTR _v2$5[ebp+4], ecx

; 3708 : 					v2.z = waypointhigh->z;

  02394	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  0239a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0239d	89 8d ac fe ff
	ff		 mov	 DWORD PTR _v2$5[ebp+8], ecx

; 3709 : 					junk.v1 = &v1;

  023a3	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _v1$6[ebp]
  023a9	89 85 bc fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp], eax

; 3710 : 					junk.v2 = &v2;

  023af	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _v2$5[ebp]
  023b5	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp+4], eax

; 3711 : 					junk.dx = v2.x - v1.x;

  023bb	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _v2$5[ebp]
  023c1	2b 85 b0 fe ff
	ff		 sub	 eax, DWORD PTR _v1$6[ebp]
  023c7	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp+8], eax

; 3712 : 					junk.dy = v2.y - v1.y;

  023cd	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _v2$5[ebp+4]
  023d3	2b 85 b4 fe ff
	ff		 sub	 eax, DWORD PTR _v1$6[ebp+4]
  023d9	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _junk$7[ebp+12], eax

; 3713 : 
; 3714 : 					P_ClosestPointOnLine(player->mo->x, player->mo->y, &junk, &resulthigh);

  023df	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _resulthigh$4[ebp]
  023e5	50		 push	 eax
  023e6	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _junk$7[ebp]
  023ec	51		 push	 ecx
  023ed	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  023f0	8b 02		 mov	 eax, DWORD PTR [edx]
  023f2	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  023f5	51		 push	 ecx
  023f6	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  023f9	8b 02		 mov	 eax, DWORD PTR [edx]
  023fb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  023fe	51		 push	 ecx
  023ff	e8 00 00 00 00	 call	 _P_ClosestPointOnLine
  02404	83 c4 10	 add	 esp, 16			; 00000010H

; 3715 : 					resulthigh.z = waypointhigh->z;

  02407	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  0240d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02410	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _resulthigh$4[ebp+8], ecx
$LN248@P_ProcessS:

; 3716 : 				}
; 3717 : 
; 3718 : 				// 3D support not available yet. Need a 3D version of P_ClosestPointOnLine.
; 3719 : 
; 3720 : 				P_UnsetThingPosition(player->mo);

  02416	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02419	8b 08		 mov	 ecx, DWORD PTR [eax]
  0241b	51		 push	 ecx
  0241c	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  02421	83 c4 04	 add	 esp, 4

; 3721 : 				P_ResetPlayer(player);

  02424	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02427	50		 push	 eax
  02428	e8 00 00 00 00	 call	 _P_ResetPlayer
  0242d	83 c4 04	 add	 esp, 4

; 3722 : 				player->mo->momx = player->mo->momy = player->mo->momz = 0;

  02430	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02433	8b 08		 mov	 ecx, DWORD PTR [eax]
  02435	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0
  0243c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0243f	8b 02		 mov	 eax, DWORD PTR [edx]
  02441	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  02448	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0244b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0244d	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 3723 : 
; 3724 : 				if (lines[lineindex].flags & ML_EFFECT1) // Don't wrap

  02454	6b 85 20 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$14[ebp], 76
  0245b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  02461	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  02466	83 e2 20	 and	 edx, 32			; 00000020H
  02469	0f 84 eb 00 00
	00		 je	 $LN249@P_ProcessS

; 3725 : 				{
; 3726 : 					if (waypointhigh)

  0246f	83 bd 14 ff ff
	ff 00		 cmp	 DWORD PTR _waypointhigh$11[ebp], 0
  02476	74 5f		 je	 SHORT $LN251@P_ProcessS

; 3727 : 					{
; 3728 : 						closest = waypointhigh;

  02478	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  0247e	89 85 08 ff ff
	ff		 mov	 DWORD PTR _closest$8[ebp], eax

; 3729 : 						player->mo->x = resulthigh.x;

  02484	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02487	8b 08		 mov	 ecx, DWORD PTR [eax]
  02489	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _resulthigh$4[ebp]
  0248f	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 3730 : 						player->mo->y = resulthigh.y;

  02492	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02495	8b 08		 mov	 ecx, DWORD PTR [eax]
  02497	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _resulthigh$4[ebp+4]
  0249d	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 3731 : 
; 3732 : 						if (minecart)

  024a0	83 bd 84 fe ff
	ff 00		 cmp	 DWORD PTR _minecart$1[ebp], 0
  024a7	74 10		 je	 SHORT $LN253@P_ProcessS

; 3733 : 							player->mo->z = resulthigh.z;

  024a9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  024ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  024ae	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _resulthigh$4[ebp+8]
  024b4	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  024b7	eb 1c		 jmp	 SHORT $LN254@P_ProcessS
$LN253@P_ProcessS:

; 3734 : 						else
; 3735 : 							player->mo->z = resulthigh.z - P_GetPlayerHeight(player);

  024b9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  024bc	50		 push	 eax
  024bd	e8 00 00 00 00	 call	 _P_GetPlayerHeight
  024c2	83 c4 04	 add	 esp, 4
  024c5	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _resulthigh$4[ebp+8]
  024cb	2b c8		 sub	 ecx, eax
  024cd	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  024d0	8b 02		 mov	 eax, DWORD PTR [edx]
  024d2	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN254@P_ProcessS:

; 3736 : 					}

  024d5	eb 66		 jmp	 SHORT $LN257@P_ProcessS
$LN251@P_ProcessS:

; 3737 : 					else if (waypointlow)

  024d7	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR _waypointlow$10[ebp], 0
  024de	74 5d		 je	 SHORT $LN257@P_ProcessS

; 3738 : 					{
; 3739 : 						closest = waypointmid;

  024e0	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  024e6	89 85 08 ff ff
	ff		 mov	 DWORD PTR _closest$8[ebp], eax

; 3740 : 						player->mo->x = resultlow.x;

  024ec	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  024ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  024f1	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR _resultlow$3[ebp]
  024f7	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 3741 : 						player->mo->y = resultlow.y;

  024fa	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  024fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  024ff	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _resultlow$3[ebp+4]
  02505	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 3742 : 
; 3743 : 						if (minecart)

  02508	83 bd 84 fe ff
	ff 00		 cmp	 DWORD PTR _minecart$1[ebp], 0
  0250f	74 10		 je	 SHORT $LN256@P_ProcessS

; 3744 : 							player->mo->z = resultlow.z;

  02511	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02514	8b 08		 mov	 ecx, DWORD PTR [eax]
  02516	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _resultlow$3[ebp+8]
  0251c	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0251f	eb 1c		 jmp	 SHORT $LN257@P_ProcessS
$LN256@P_ProcessS:

; 3745 : 						else
; 3746 : 							player->mo->z = resultlow.z - P_GetPlayerHeight(player);

  02521	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02524	50		 push	 eax
  02525	e8 00 00 00 00	 call	 _P_GetPlayerHeight
  0252a	83 c4 04	 add	 esp, 4
  0252d	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _resultlow$3[ebp+8]
  02533	2b c8		 sub	 ecx, eax
  02535	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02538	8b 02		 mov	 eax, DWORD PTR [edx]
  0253a	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN257@P_ProcessS:

; 3747 : 					}
; 3748 : 
; 3749 : 					highest->flags |= MF_SLIDEME;

  0253d	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _highest$2[ebp]
  02543	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  02546	81 c9 00 08 00
	00		 or	 ecx, 2048		; 00000800H
  0254c	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR _highest$2[ebp]
  02552	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 3750 : 				}

  02555	e9 3e 01 00 00	 jmp	 $LN263@P_ProcessS
$LN249@P_ProcessS:

; 3751 : 				else
; 3752 : 				{
; 3753 : 					if (P_AproxDistance(P_AproxDistance(player->mo->x-resultlow.x, player->mo->y-resultlow.y),
; 3754 : 							player->mo->z-resultlow.z) < P_AproxDistance(P_AproxDistance(player->mo->x-resulthigh.x,

  0255a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0255d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0255f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  02562	2b 95 94 fe ff
	ff		 sub	 edx, DWORD PTR _resultlow$3[ebp+8]
  02568	52		 push	 edx
  02569	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0256c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0256e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  02571	2b 95 90 fe ff
	ff		 sub	 edx, DWORD PTR _resultlow$3[ebp+4]
  02577	52		 push	 edx
  02578	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0257b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0257d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  02580	2b 95 8c fe ff
	ff		 sub	 edx, DWORD PTR _resultlow$3[ebp]
  02586	52		 push	 edx
  02587	e8 00 00 00 00	 call	 _P_AproxDistance
  0258c	83 c4 08	 add	 esp, 8
  0258f	50		 push	 eax
  02590	e8 00 00 00 00	 call	 _P_AproxDistance
  02595	83 c4 08	 add	 esp, 8
  02598	8b f0		 mov	 esi, eax
  0259a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0259d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0259f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  025a2	2b 95 a0 fe ff
	ff		 sub	 edx, DWORD PTR _resulthigh$4[ebp+8]
  025a8	52		 push	 edx
  025a9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  025ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  025ae	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  025b1	2b 95 9c fe ff
	ff		 sub	 edx, DWORD PTR _resulthigh$4[ebp+4]
  025b7	52		 push	 edx
  025b8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  025bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  025bd	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  025c0	2b 95 98 fe ff
	ff		 sub	 edx, DWORD PTR _resulthigh$4[ebp]
  025c6	52		 push	 edx
  025c7	e8 00 00 00 00	 call	 _P_AproxDistance
  025cc	83 c4 08	 add	 esp, 8
  025cf	50		 push	 eax
  025d0	e8 00 00 00 00	 call	 _P_AproxDistance
  025d5	83 c4 08	 add	 esp, 8
  025d8	3b f0		 cmp	 esi, eax
  025da	7d 5f		 jge	 SHORT $LN258@P_ProcessS

; 3755 : 								player->mo->y-resulthigh.y), player->mo->z-resulthigh.z))
; 3756 : 					{
; 3757 : 						// Line between Mid and Low is closer
; 3758 : 						closest = waypointmid;

  025dc	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _waypointmid$12[ebp]
  025e2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _closest$8[ebp], eax

; 3759 : 						player->mo->x = resultlow.x;

  025e8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  025eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  025ed	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR _resultlow$3[ebp]
  025f3	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 3760 : 						player->mo->y = resultlow.y;

  025f6	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  025f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  025fb	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _resultlow$3[ebp+4]
  02601	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 3761 : 
; 3762 : 						if (minecart)

  02604	83 bd 84 fe ff
	ff 00		 cmp	 DWORD PTR _minecart$1[ebp], 0
  0260b	74 10		 je	 SHORT $LN260@P_ProcessS

; 3763 : 							player->mo->z = resultlow.z;

  0260d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02610	8b 08		 mov	 ecx, DWORD PTR [eax]
  02612	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _resultlow$3[ebp+8]
  02618	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0261b	eb 1c		 jmp	 SHORT $LN261@P_ProcessS
$LN260@P_ProcessS:

; 3764 : 						else
; 3765 : 							player->mo->z = resultlow.z - P_GetPlayerHeight(player);

  0261d	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02620	50		 push	 eax
  02621	e8 00 00 00 00	 call	 _P_GetPlayerHeight
  02626	83 c4 04	 add	 esp, 4
  02629	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _resultlow$3[ebp+8]
  0262f	2b c8		 sub	 ecx, eax
  02631	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02634	8b 02		 mov	 eax, DWORD PTR [edx]
  02636	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN261@P_ProcessS:

; 3766 : 					}

  02639	eb 5d		 jmp	 SHORT $LN263@P_ProcessS
$LN258@P_ProcessS:

; 3767 : 					else
; 3768 : 					{
; 3769 : 						// Line between Mid and High is closer
; 3770 : 						closest = waypointhigh;

  0263b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _waypointhigh$11[ebp]
  02641	89 85 08 ff ff
	ff		 mov	 DWORD PTR _closest$8[ebp], eax

; 3771 : 						player->mo->x = resulthigh.x;

  02647	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0264a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0264c	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _resulthigh$4[ebp]
  02652	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 3772 : 						player->mo->y = resulthigh.y;

  02655	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02658	8b 08		 mov	 ecx, DWORD PTR [eax]
  0265a	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _resulthigh$4[ebp+4]
  02660	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 3773 : 
; 3774 : 						if (minecart)

  02663	83 bd 84 fe ff
	ff 00		 cmp	 DWORD PTR _minecart$1[ebp], 0
  0266a	74 10		 je	 SHORT $LN262@P_ProcessS

; 3775 : 							player->mo->z = resulthigh.z;

  0266c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0266f	8b 08		 mov	 ecx, DWORD PTR [eax]
  02671	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _resulthigh$4[ebp+8]
  02677	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0267a	eb 1c		 jmp	 SHORT $LN263@P_ProcessS
$LN262@P_ProcessS:

; 3776 : 						else
; 3777 : 							player->mo->z = resulthigh.z - P_GetPlayerHeight(player);

  0267c	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0267f	50		 push	 eax
  02680	e8 00 00 00 00	 call	 _P_GetPlayerHeight
  02685	83 c4 04	 add	 esp, 4
  02688	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _resulthigh$4[ebp+8]
  0268e	2b c8		 sub	 ecx, eax
  02690	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02693	8b 02		 mov	 eax, DWORD PTR [edx]
  02695	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN263@P_ProcessS:

; 3778 : 					}
; 3779 : 				}
; 3780 : 
; 3781 : 				P_SetTarget(&player->mo->tracer, closest);

  02698	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _closest$8[ebp]
  0269e	50		 push	 eax
  0269f	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  026a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  026a4	81 c2 b0 00 00
	00		 add	 edx, 176		; 000000b0H
  026aa	52		 push	 edx
  026ab	e8 00 00 00 00	 call	 _P_SetTarget
  026b0	83 c4 08	 add	 esp, 8

; 3782 : 
; 3783 : 				// Option for static ropes.
; 3784 : 				if (lines[lineindex].flags & ML_NOCLIMB)

  026b3	6b 85 20 ff ff
	ff 4c		 imul	 eax, DWORD PTR _lineindex$14[ebp], 76
  026ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  026c0	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  026c5	83 e2 40	 and	 edx, 64			; 00000040H
  026c8	74 0f		 je	 SHORT $LN264@P_ProcessS

; 3785 : 					player->speed = 0;

  026ca	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  026cd	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0
  026d7	eb 0f		 jmp	 SHORT $LN265@P_ProcessS
$LN264@P_ProcessS:

; 3786 : 				else
; 3787 : 					player->speed = speed;

  026d9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  026dc	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _speed$15[ebp]
  026e2	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx
$LN265@P_ProcessS:

; 3788 : 
; 3789 : 				if (minecart)

  026e8	83 bd 84 fe ff
	ff 00		 cmp	 DWORD PTR _minecart$1[ebp], 0
  026ef	74 1a		 je	 SHORT $LN266@P_ProcessS

; 3790 : 					player->pflags |= PF_MINECART;

  026f1	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  026f4	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  026fa	81 c9 00 00 00
	40		 or	 ecx, 1073741824		; 40000000H
  02700	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02703	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx
  02709	eb 18		 jmp	 SHORT $LN267@P_ProcessS
$LN266@P_ProcessS:

; 3791 : 				else
; 3792 : 					player->pflags |= PF_ROPEHANG;

  0270b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0270e	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  02714	81 c9 00 00 00
	20		 or	 ecx, 536870912		; 20000000H
  0271a	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0271d	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx
$LN267@P_ProcessS:

; 3793 : 
; 3794 : 				S_StartSound(player->mo, sfx_s3k_25);

  02723	68 8d 00 00 00	 push	 141			; 0000008dH
  02728	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0272b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0272d	51		 push	 ecx
  0272e	e8 00 00 00 00	 call	 _S_StartSound
  02733	83 c4 08	 add	 esp, 8

; 3795 : 
; 3796 : 				player->pflags &= ~PF_JUMPED;

  02736	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02739	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0273f	81 e1 ff ef ff
	ff		 and	 ecx, -4097		; ffffefffH
  02745	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02748	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3797 : 				player->pflags &= ~PF_GLIDING;

  0274e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02751	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  02757	81 e1 ff ff fe
	ff		 and	 ecx, -65537		; fffeffffH
  0275d	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  02760	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3798 : 				player->climbing = 0;

  02766	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02769	c7 80 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+292], 0

; 3799 : 				player->scoreadd = 0;

  02773	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02776	c7 80 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+284], 0

; 3800 : 				P_SetThingPosition(player->mo);

  02780	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02783	8b 08		 mov	 ecx, DWORD PTR [eax]
  02785	51		 push	 ecx
  02786	e8 00 00 00 00	 call	 _P_SetThingPosition
  0278b	83 c4 04	 add	 esp, 4

; 3801 : 
; 3802 : 				if (minecart)

  0278e	83 bd 84 fe ff
	ff 00		 cmp	 DWORD PTR _minecart$1[ebp], 0
  02795	74 77		 je	 SHORT $LN268@P_ProcessS

; 3803 : 				{
; 3804 : 					P_ResetScore(player);

  02797	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0279a	50		 push	 eax
  0279b	e8 00 00 00 00	 call	 _P_ResetScore
  027a0	83 c4 04	 add	 esp, 4

; 3805 : 					player->pflags |= PF_SPINNING;

  027a3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  027a6	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  027ac	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  027b2	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  027b5	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 3806 : 					P_SetPlayerMobjState(player->mo, S_PLAY_ATK1);

  027bb	6a 0c		 push	 12			; 0000000cH
  027bd	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  027c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  027c2	51		 push	 ecx
  027c3	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  027c8	83 c4 08	 add	 esp, 8

; 3807 : 					S_StartSound(player->mo, sfx_spin);

  027cb	68 d3 00 00 00	 push	 211			; 000000d3H
  027d0	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  027d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  027d5	51		 push	 ecx
  027d6	e8 00 00 00 00	 call	 _S_StartSound
  027db	83 c4 08	 add	 esp, 8

; 3808 : 					if (player->mo->eflags & MFE_VERTICALFLIP)

  027de	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  027e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  027e3	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  027e9	83 e2 20	 and	 edx, 32			; 00000020H
  027ec	74 1e		 je	 SHORT $LN270@P_ProcessS

; 3809 : 						player->mo->z = player->mo->ceilingz - P_GetPlayerSpinHeight(player);

  027ee	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  027f1	8b 30		 mov	 esi, DWORD PTR [eax]
  027f3	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  027f6	51		 push	 ecx
  027f7	e8 00 00 00 00	 call	 _P_GetPlayerSpinHeight
  027fc	83 c4 04	 add	 esp, 4
  027ff	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  02802	2b d0		 sub	 edx, eax
  02804	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02807	8b 08		 mov	 ecx, DWORD PTR [eax]
  02809	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$LN270@P_ProcessS:

; 3810 : 				}

  0280c	eb 10		 jmp	 SHORT $LN269@P_ProcessS
$LN268@P_ProcessS:

; 3811 : 				else
; 3812 : 					P_SetPlayerMobjState(player->mo, S_PLAY_CARRY);

  0280e	6a 29		 push	 41			; 00000029H
  02810	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  02813	8b 08		 mov	 ecx, DWORD PTR [eax]
  02815	51		 push	 ecx
  02816	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  0281b	83 c4 08	 add	 esp, 8
$LN269@P_ProcessS:
$LN17@P_ProcessS:

; 3813 : 			}
; 3814 : 			break;
; 3815 : 		case 12: // Unused
; 3816 : 		case 13: // Unused
; 3817 : 		case 14: // Unused
; 3818 : 		case 15: // Unused
; 3819 : 			break;
; 3820 : 	}
; 3821 : }

  0281e	5f		 pop	 edi
  0281f	5e		 pop	 esi
  02820	5b		 pop	 ebx
  02821	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02824	33 cd		 xor	 ecx, ebp
  02826	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0282b	8b e5		 mov	 esp, ebp
  0282d	5d		 pop	 ebp
  0282e	c3		 ret	 0
  0282f	90		 npad	 1
$LN280@P_ProcessS:
  02830	00 00 00 00	 DD	 $LN46@P_ProcessS
  02834	00 00 00 00	 DD	 $LN47@P_ProcessS
  02838	00 00 00 00	 DD	 $LN50@P_ProcessS
  0283c	00 00 00 00	 DD	 $LN52@P_ProcessS
  02840	00 00 00 00	 DD	 $LN2@P_ProcessS
  02844	00 00 00 00	 DD	 $LN55@P_ProcessS
  02848	00 00 00 00	 DD	 $LN56@P_ProcessS
  0284c	00 00 00 00	 DD	 $LN57@P_ProcessS
  02850	00 00 00 00	 DD	 $LN58@P_ProcessS
  02854	00 00 00 00	 DD	 $LN58@P_ProcessS
  02858	00 00 00 00	 DD	 $LN61@P_ProcessS
  0285c	00 00 00 00	 DD	 $LN78@P_ProcessS
$LN281@P_ProcessS:
  02860	00 00 00 00	 DD	 $LN84@P_ProcessS
  02864	00 00 00 00	 DD	 $LN84@P_ProcessS
  02868	00 00 00 00	 DD	 $LN7@P_ProcessS
  0286c	00 00 00 00	 DD	 $LN7@P_ProcessS
  02870	00 00 00 00	 DD	 $LN7@P_ProcessS
  02874	00 00 00 00	 DD	 $LN7@P_ProcessS
  02878	00 00 00 00	 DD	 $DoneSection2$283
  0287c	00 00 00 00	 DD	 $LN93@P_ProcessS
$LN282@P_ProcessS:
  02880	00 00 00 00	 DD	 $LN127@P_ProcessS
  02884	00 00 00 00	 DD	 $LN129@P_ProcessS
  02888	00 00 00 00	 DD	 $LN137@P_ProcessS
  0288c	00 00 00 00	 DD	 $LN155@P_ProcessS
  02890	00 00 00 00	 DD	 $LN173@P_ProcessS
  02894	00 00 00 00	 DD	 $LN176@P_ProcessS
  02898	00 00 00 00	 DD	 $LN178@P_ProcessS
  0289c	00 00 00 00	 DD	 $LN181@P_ProcessS
  028a0	00 00 00 00	 DD	 $LN192@P_ProcessS
  028a4	00 00 00 00	 DD	 $LN206@P_ProcessS
  028a8	00 00 00 00	 DD	 $LN216@P_ProcessS
_P_ProcessSpecialSector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_PlayerInSpecialSector
_TEXT	SEGMENT
_node$ = -8						; size = 4
_sector$ = -4						; size = 4
_player$ = 8						; size = 4
_P_PlayerInSpecialSector PROC				; COMDAT

; 4124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4125 : 	sector_t *sector;
; 4126 : 	msecnode_t *node;
; 4127 : 
; 4128 : 	if (!player->mo)

  00009	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 05		 jne	 SHORT $LN5@P_PlayerIn

; 4129 : 		return;

  00011	e9 94 00 00 00	 jmp	 $LN3@P_PlayerIn
$LN5@P_PlayerIn:

; 4130 : 
; 4131 : 	// Do your ->subsector->sector first
; 4132 : 	sector = player->mo->subsector->sector;

  00016	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	89 45 fc	 mov	 DWORD PTR _sector$[ebp], eax

; 4133 : 	P_PlayerOnSpecial3DFloor(player, sector);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _P_PlayerOnSpecial3DFloor
  00030	83 c4 08	 add	 esp, 8

; 4134 : 	P_RunSpecialSectorCheck(player, sector);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _P_RunSpecialSectorCheck
  00040	83 c4 08	 add	 esp, 8

; 4135 : 
; 4136 : 	// Iterate through touching_sectorlist
; 4137 : 	for (node = player->mo->touching_sectorlist; node; node = node->m_snext)

  00043	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0004b	89 55 f8	 mov	 DWORD PTR _node$[ebp], edx
  0004e	eb 09		 jmp	 SHORT $LN4@P_PlayerIn
$LN2@P_PlayerIn:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00053	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00056	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx
$LN4@P_PlayerIn:
  00059	83 7d f8 00	 cmp	 DWORD PTR _node$[ebp], 0
  0005d	74 4b		 je	 SHORT $LN3@P_PlayerIn

; 4138 : 	{
; 4139 : 		sector = node->m_sector;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	89 4d fc	 mov	 DWORD PTR _sector$[ebp], ecx

; 4140 : 
; 4141 : 		if (sector == player->mo->subsector->sector) // Don't duplicate

  00067	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00072	3b 02		 cmp	 eax, DWORD PTR [edx]
  00074	75 02		 jne	 SHORT $LN6@P_PlayerIn

; 4142 : 			continue;

  00076	eb d8		 jmp	 SHORT $LN2@P_PlayerIn
$LN6@P_PlayerIn:

; 4143 : 
; 4144 : 		// Check 3D floors...
; 4145 : 		P_PlayerOnSpecial3DFloor(player, sector);

  00078	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _P_PlayerOnSpecial3DFloor
  00085	83 c4 08	 add	 esp, 8

; 4146 : 
; 4147 : 		if (!(sector->flags & SF_TRIGGERSPECIAL_TOUCH))

  00088	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  0008b	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00091	83 e1 04	 and	 ecx, 4
  00094	75 02		 jne	 SHORT $LN7@P_PlayerIn

; 4148 : 			return;

  00096	eb 12		 jmp	 SHORT $LN3@P_PlayerIn
$LN7@P_PlayerIn:

; 4149 : 
; 4150 : 		P_RunSpecialSectorCheck(player, sector);

  00098	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 _P_RunSpecialSectorCheck
  000a5	83 c4 08	 add	 esp, 8

; 4151 : 	}

  000a8	eb a6		 jmp	 SHORT $LN2@P_PlayerIn
$LN3@P_PlayerIn:

; 4152 : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_P_PlayerInSpecialSector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_PlayerTouchingSectorSpecial
_TEXT	SEGMENT
_rover$ = -8						; size = 4
_node$ = -4						; size = 4
_player$ = 8						; size = 4
_section$ = 12						; size = 4
_number$ = 16						; size = 4
_P_PlayerTouchingSectorSpecial PROC			; COMDAT

; 2658 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2659 : 	msecnode_t *node;
; 2660 : 	ffloor_t *rover;
; 2661 : 
; 2662 : 	if (!player->mo)

  00009	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 07		 jne	 SHORT $LN11@P_PlayerTo

; 2663 : 		return false;

  00011	33 c0		 xor	 eax, eax
  00013	e9 35 04 00 00	 jmp	 $LN1@P_PlayerTo
$LN11@P_PlayerTo:

; 2664 : 
; 2665 : 	// Check default case first
; 2666 : 	if (GETSECSPECIAL(player->mo->subsector->sector->special, section) == number)

  00018	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	0f bf 50 12	 movsx	 edx, WORD PTR [eax+18]
  00026	8b 45 0c	 mov	 eax, DWORD PTR _section$[ebp]
  00029	8d 0c 85 fc ff
	ff ff		 lea	 ecx, DWORD PTR [eax*4-4]
  00030	d3 fa		 sar	 edx, cl
  00032	83 e2 0f	 and	 edx, 15			; 0000000fH
  00035	3b 55 10	 cmp	 edx, DWORD PTR _number$[ebp]
  00038	75 0f		 jne	 SHORT $LN12@P_PlayerTo

; 2667 : 		return player->mo->subsector->sector;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	e9 04 04 00 00	 jmp	 $LN1@P_PlayerTo
$LN12@P_PlayerTo:

; 2668 : 
; 2669 : 	// Hmm.. maybe there's a FOF that has it...
; 2670 : 	for (rover = player->mo->subsector->sector->ffloors; rover; rover = rover->next)

  00049	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00059	89 4d f8	 mov	 DWORD PTR _rover$[ebp], ecx
  0005c	eb 09		 jmp	 SHORT $LN4@P_PlayerTo
$LN2@P_PlayerTo:
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00061	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00064	89 4d f8	 mov	 DWORD PTR _rover$[ebp], ecx
$LN4@P_PlayerTo:
  00067	83 7d f8 00	 cmp	 DWORD PTR _rover$[ebp], 0
  0006b	0f 84 94 01 00
	00		 je	 $LN3@P_PlayerTo

; 2671 : 	{
; 2672 : 		if (GETSECSPECIAL(rover->master->frontsector->special, section) != number)

  00071	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00074	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00077	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0007a	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _section$[ebp]
  00081	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [ecx*4-4]
  00088	d3 f8		 sar	 eax, cl
  0008a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0008d	3b 45 10	 cmp	 eax, DWORD PTR _number$[ebp]
  00090	74 02		 je	 SHORT $LN13@P_PlayerTo

; 2673 : 			continue;

  00092	eb ca		 jmp	 SHORT $LN2@P_PlayerTo
$LN13@P_PlayerTo:

; 2674 : 
; 2675 : 		if (!(rover->flags & FF_EXISTS))

  00094	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00097	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0009a	83 e1 01	 and	 ecx, 1
  0009d	75 02		 jne	 SHORT $LN14@P_PlayerTo

; 2676 : 			continue;

  0009f	eb bd		 jmp	 SHORT $LN2@P_PlayerTo
$LN14@P_PlayerTo:

; 2677 : 
; 2678 : 		// Check the 3D floor's type...
; 2679 : 		if (rover->flags & FF_BLOCKPLAYER)

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000a4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a7	83 e1 02	 and	 ecx, 2
  000aa	0f 84 12 01 00
	00		 je	 $LN15@P_PlayerTo

; 2680 : 		{
; 2681 : 			// Thing must be on top of the floor to be affected...
; 2682 : 			if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR)
; 2683 : 				&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING))

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000b3	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b6	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000b9	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000bf	83 e0 01	 and	 eax, 1
  000c2	74 3f		 je	 SHORT $LN17@P_PlayerTo
  000c4	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  000c7	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000ca	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000cd	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  000d3	83 e0 02	 and	 eax, 2
  000d6	75 2b		 jne	 SHORT $LN17@P_PlayerTo

; 2684 : 			{
; 2685 : 				if ((player->mo->eflags & MFE_VERTICALFLIP) || player->mo->z != *rover->topheight)

  000d8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  000e3	83 e2 20	 and	 edx, 32			; 00000020H
  000e6	75 11		 jne	 SHORT $LN20@P_PlayerTo
  000e8	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  000f0	8b 02		 mov	 eax, DWORD PTR [edx]
  000f2	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  000f5	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000f7	74 05		 je	 SHORT $LN19@P_PlayerTo
$LN20@P_PlayerTo:

; 2686 : 					continue;

  000f9	e9 60 ff ff ff	 jmp	 $LN2@P_PlayerTo
$LN19@P_PlayerTo:

; 2687 : 			}

  000fe	e9 bd 00 00 00	 jmp	 $LN26@P_PlayerTo
$LN17@P_PlayerTo:

; 2688 : 			else if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING)
; 2689 : 				&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR))

  00103	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00106	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00109	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0010c	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00112	83 e0 02	 and	 eax, 2
  00115	74 45		 je	 SHORT $LN21@P_PlayerTo
  00117	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0011a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0011d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00120	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00126	83 e0 01	 and	 eax, 1
  00129	75 31		 jne	 SHORT $LN21@P_PlayerTo

; 2690 : 			{
; 2691 : 				if (!(player->mo->eflags & MFE_VERTICALFLIP)
; 2692 : 					|| player->mo->z + player->mo->height != *rover->bottomheight)

  0012b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0012e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00130	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00136	83 e2 20	 and	 edx, 32			; 00000020H
  00139	74 1a		 je	 SHORT $LN24@P_PlayerTo
  0013b	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0013e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00140	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00143	8b 02		 mov	 eax, DWORD PTR [edx]
  00145	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00148	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  0014b	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  0014e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00151	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00153	74 05		 je	 SHORT $LN23@P_PlayerTo
$LN24@P_PlayerTo:

; 2693 : 					continue;

  00155	e9 04 ff ff ff	 jmp	 $LN2@P_PlayerTo
$LN23@P_PlayerTo:

; 2694 : 			}

  0015a	eb 64		 jmp	 SHORT $LN26@P_PlayerTo
$LN21@P_PlayerTo:

; 2695 : 			else if (rover->master->frontsector->flags & SF_FLIPSPECIAL_BOTH)

  0015c	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0015f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00162	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00165	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  0016b	83 e0 03	 and	 eax, 3
  0016e	74 50		 je	 SHORT $LN26@P_PlayerTo

; 2696 : 			{
; 2697 : 				if (!((player->mo->eflags & MFE_VERTICALFLIP && player->mo->z + player->mo->height == *rover->bottomheight)

  00170	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00173	8b 08		 mov	 ecx, DWORD PTR [eax]
  00175	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0017b	83 e2 20	 and	 edx, 32			; 00000020H
  0017e	74 1a		 je	 SHORT $LN27@P_PlayerTo
  00180	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00183	8b 08		 mov	 ecx, DWORD PTR [eax]
  00185	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00188	8b 02		 mov	 eax, DWORD PTR [edx]
  0018a	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0018d	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00190	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  00193	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00196	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00198	74 26		 je	 SHORT $LN26@P_PlayerTo
$LN27@P_PlayerTo:
  0019a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  001a5	83 e2 20	 and	 edx, 32			; 00000020H
  001a8	75 11		 jne	 SHORT $LN28@P_PlayerTo
  001aa	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  001af	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  001b2	8b 02		 mov	 eax, DWORD PTR [edx]
  001b4	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  001b7	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001b9	74 05		 je	 SHORT $LN26@P_PlayerTo
$LN28@P_PlayerTo:

; 2698 : 					|| (!(player->mo->eflags & MFE_VERTICALFLIP) && player->mo->z == *rover->topheight)))
; 2699 : 					continue;

  001bb	e9 9e fe ff ff	 jmp	 $LN2@P_PlayerTo
$LN26@P_PlayerTo:

; 2700 : 			}
; 2701 : 		}

  001c0	eb 30		 jmp	 SHORT $LN29@P_PlayerTo
$LN15@P_PlayerTo:

; 2702 : 		else
; 2703 : 		{
; 2704 : 			// Water and DEATH FOG!!! heh
; 2705 : 			if (player->mo->z > *rover->topheight || (player->mo->z + player->mo->height) < *rover->bottomheight)

  001c2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c7	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  001ca	8b 02		 mov	 eax, DWORD PTR [edx]
  001cc	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  001cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d1	7f 1a		 jg	 SHORT $LN30@P_PlayerTo
  001d3	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d8	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  001db	8b 02		 mov	 eax, DWORD PTR [edx]
  001dd	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  001e0	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  001e3	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  001e6	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001e9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001eb	7d 05		 jge	 SHORT $LN29@P_PlayerTo
$LN30@P_PlayerTo:

; 2706 : 				continue;

  001ed	e9 6c fe ff ff	 jmp	 $LN2@P_PlayerTo
$LN29@P_PlayerTo:

; 2707 : 		}
; 2708 : 
; 2709 : 		// This FOF has the special we're looking for!
; 2710 : 		return rover->master->frontsector;

  001f2	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  001f5	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001f8	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001fb	e9 4d 02 00 00	 jmp	 $LN1@P_PlayerTo

; 2711 : 	}

  00200	e9 59 fe ff ff	 jmp	 $LN2@P_PlayerTo
$LN3@P_PlayerTo:

; 2712 : 
; 2713 : 	for (node = player->mo->touching_sectorlist; node; node = node->m_snext)

  00205	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00208	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0020d	89 55 fc	 mov	 DWORD PTR _node$[ebp], edx
  00210	eb 09		 jmp	 SHORT $LN7@P_PlayerTo
$LN5@P_PlayerTo:
  00212	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00215	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00218	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx
$LN7@P_PlayerTo:
  0021b	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  0021f	0f 84 26 02 00
	00		 je	 $LN6@P_PlayerTo

; 2714 : 	{
; 2715 : 		if (GETSECSPECIAL(node->m_sector->special, section) == number)

  00225	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	0f bf 51 12	 movsx	 edx, WORD PTR [ecx+18]
  0022e	8b 45 0c	 mov	 eax, DWORD PTR _section$[ebp]
  00231	8d 0c 85 fc ff
	ff ff		 lea	 ecx, DWORD PTR [eax*4-4]
  00238	d3 fa		 sar	 edx, cl
  0023a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0023d	3b 55 10	 cmp	 edx, DWORD PTR _number$[ebp]
  00240	75 2b		 jne	 SHORT $LN32@P_PlayerTo

; 2716 : 		{
; 2717 : 			// This sector has the special we're looking for, but
; 2718 : 			// are we allowed to touch it?
; 2719 : 			if (node->m_sector == player->mo->subsector->sector
; 2720 : 				|| (node->m_sector->flags & SF_TRIGGERSPECIAL_TOUCH))

  00242	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00245	8b 08		 mov	 ecx, DWORD PTR [eax]
  00247	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0024a	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0024d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024f	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00251	74 10		 je	 SHORT $LN33@P_PlayerTo
  00253	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00256	8b 08		 mov	 ecx, DWORD PTR [eax]
  00258	8b 91 e0 00 00
	00		 mov	 edx, DWORD PTR [ecx+224]
  0025e	83 e2 04	 and	 edx, 4
  00261	74 0a		 je	 SHORT $LN32@P_PlayerTo
$LN33@P_PlayerTo:

; 2721 : 				return node->m_sector;

  00263	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00266	8b 00		 mov	 eax, DWORD PTR [eax]
  00268	e9 e0 01 00 00	 jmp	 $LN1@P_PlayerTo
$LN32@P_PlayerTo:

; 2722 : 		}
; 2723 : 
; 2724 : 		// Hmm.. maybe there's a FOF that has it...
; 2725 : 		for (rover = node->m_sector->ffloors; rover; rover = rover->next)

  0026d	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00270	8b 08		 mov	 ecx, DWORD PTR [eax]
  00272	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00278	89 55 f8	 mov	 DWORD PTR _rover$[ebp], edx
  0027b	eb 09		 jmp	 SHORT $LN10@P_PlayerTo
$LN8@P_PlayerTo:
  0027d	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00280	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00283	89 4d f8	 mov	 DWORD PTR _rover$[ebp], ecx
$LN10@P_PlayerTo:
  00286	83 7d f8 00	 cmp	 DWORD PTR _rover$[ebp], 0
  0028a	0f 84 b6 01 00
	00		 je	 $LN9@P_PlayerTo

; 2726 : 		{
; 2727 : 			if (GETSECSPECIAL(rover->master->frontsector->special, section) != number)

  00290	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00293	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00296	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00299	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  0029d	8b 4d 0c	 mov	 ecx, DWORD PTR _section$[ebp]
  002a0	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [ecx*4-4]
  002a7	d3 f8		 sar	 eax, cl
  002a9	83 e0 0f	 and	 eax, 15			; 0000000fH
  002ac	3b 45 10	 cmp	 eax, DWORD PTR _number$[ebp]
  002af	74 02		 je	 SHORT $LN34@P_PlayerTo

; 2728 : 				continue;

  002b1	eb ca		 jmp	 SHORT $LN8@P_PlayerTo
$LN34@P_PlayerTo:

; 2729 : 
; 2730 : 			if (!(rover->flags & FF_EXISTS))

  002b3	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  002b6	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002b9	83 e1 01	 and	 ecx, 1
  002bc	75 02		 jne	 SHORT $LN35@P_PlayerTo

; 2731 : 				continue;

  002be	eb bd		 jmp	 SHORT $LN8@P_PlayerTo
$LN35@P_PlayerTo:

; 2732 : 
; 2733 : 			// Check the 3D floor's type...
; 2734 : 			if (rover->flags & FF_BLOCKPLAYER)

  002c0	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  002c3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002c6	83 e1 02	 and	 ecx, 2
  002c9	0f 84 12 01 00
	00		 je	 $LN36@P_PlayerTo

; 2735 : 			{
; 2736 : 				// Thing must be on top of the floor to be affected...
; 2737 : 				if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR)
; 2738 : 					&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING))

  002cf	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  002d2	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  002d5	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002d8	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  002de	83 e0 01	 and	 eax, 1
  002e1	74 3f		 je	 SHORT $LN38@P_PlayerTo
  002e3	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  002e6	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  002e9	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002ec	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  002f2	83 e0 02	 and	 eax, 2
  002f5	75 2b		 jne	 SHORT $LN38@P_PlayerTo

; 2739 : 				{
; 2740 : 					if ((player->mo->eflags & MFE_VERTICALFLIP) || player->mo->z != *rover->topheight)

  002f7	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  002fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fc	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00302	83 e2 20	 and	 edx, 32			; 00000020H
  00305	75 11		 jne	 SHORT $LN41@P_PlayerTo
  00307	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0030a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030c	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  0030f	8b 02		 mov	 eax, DWORD PTR [edx]
  00311	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00314	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00316	74 05		 je	 SHORT $LN40@P_PlayerTo
$LN41@P_PlayerTo:

; 2741 : 						continue;

  00318	e9 60 ff ff ff	 jmp	 $LN8@P_PlayerTo
$LN40@P_PlayerTo:

; 2742 : 				}

  0031d	e9 bd 00 00 00	 jmp	 $LN47@P_PlayerTo
$LN38@P_PlayerTo:

; 2743 : 				else if ((rover->master->frontsector->flags & SF_FLIPSPECIAL_CEILING)
; 2744 : 					&& !(rover->master->frontsector->flags & SF_FLIPSPECIAL_FLOOR))

  00322	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00325	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00328	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0032b	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00331	83 e0 02	 and	 eax, 2
  00334	74 45		 je	 SHORT $LN42@P_PlayerTo
  00336	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00339	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0033c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0033f	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00345	83 e0 01	 and	 eax, 1
  00348	75 31		 jne	 SHORT $LN42@P_PlayerTo

; 2745 : 				{
; 2746 : 					if (!(player->mo->eflags & MFE_VERTICALFLIP)
; 2747 : 						|| player->mo->z + player->mo->height != *rover->bottomheight)

  0034a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0034d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034f	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00355	83 e2 20	 and	 edx, 32			; 00000020H
  00358	74 1a		 je	 SHORT $LN45@P_PlayerTo
  0035a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0035d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035f	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00362	8b 02		 mov	 eax, DWORD PTR [edx]
  00364	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00367	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  0036a	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  0036d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00370	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00372	74 05		 je	 SHORT $LN44@P_PlayerTo
$LN45@P_PlayerTo:

; 2748 : 						continue;

  00374	e9 04 ff ff ff	 jmp	 $LN8@P_PlayerTo
$LN44@P_PlayerTo:

; 2749 : 				}

  00379	eb 64		 jmp	 SHORT $LN47@P_PlayerTo
$LN42@P_PlayerTo:

; 2750 : 				else if (rover->master->frontsector->flags & SF_FLIPSPECIAL_BOTH)

  0037b	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0037e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00381	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00384	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  0038a	83 e0 03	 and	 eax, 3
  0038d	74 50		 je	 SHORT $LN47@P_PlayerTo

; 2751 : 				{
; 2752 : 					if (!((player->mo->eflags & MFE_VERTICALFLIP && player->mo->z + player->mo->height == *rover->bottomheight)

  0038f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00392	8b 08		 mov	 ecx, DWORD PTR [eax]
  00394	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0039a	83 e2 20	 and	 edx, 32			; 00000020H
  0039d	74 1a		 je	 SHORT $LN48@P_PlayerTo
  0039f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a4	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  003a7	8b 02		 mov	 eax, DWORD PTR [edx]
  003a9	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003ac	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  003af	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  003b2	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  003b5	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003b7	74 26		 je	 SHORT $LN47@P_PlayerTo
$LN48@P_PlayerTo:
  003b9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003be	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  003c4	83 e2 20	 and	 edx, 32			; 00000020H
  003c7	75 11		 jne	 SHORT $LN49@P_PlayerTo
  003c9	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ce	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  003d1	8b 02		 mov	 eax, DWORD PTR [edx]
  003d3	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003d6	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003d8	74 05		 je	 SHORT $LN47@P_PlayerTo
$LN49@P_PlayerTo:

; 2753 : 						|| (!(player->mo->eflags & MFE_VERTICALFLIP) && player->mo->z == *rover->topheight)))
; 2754 : 						continue;

  003da	e9 9e fe ff ff	 jmp	 $LN8@P_PlayerTo
$LN47@P_PlayerTo:

; 2755 : 				}
; 2756 : 			}

  003df	eb 30		 jmp	 SHORT $LN50@P_PlayerTo
$LN36@P_PlayerTo:

; 2757 : 			else
; 2758 : 			{
; 2759 : 				// Water and DEATH FOG!!! heh
; 2760 : 				if (player->mo->z > *rover->topheight || (player->mo->z + player->mo->height) < *rover->bottomheight)

  003e1	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e6	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  003e9	8b 02		 mov	 eax, DWORD PTR [edx]
  003eb	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003ee	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003f0	7f 1a		 jg	 SHORT $LN51@P_PlayerTo
  003f2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  003f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f7	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  003fa	8b 02		 mov	 eax, DWORD PTR [edx]
  003fc	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003ff	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00402	8b 55 f8	 mov	 edx, DWORD PTR _rover$[ebp]
  00405	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00408	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0040a	7d 05		 jge	 SHORT $LN50@P_PlayerTo
$LN51@P_PlayerTo:

; 2761 : 					continue;

  0040c	e9 6c fe ff ff	 jmp	 $LN8@P_PlayerTo
$LN50@P_PlayerTo:

; 2762 : 			}
; 2763 : 
; 2764 : 			// This FOF has the special we're looking for, but are we allowed to touch it?
; 2765 : 			if (node->m_sector == player->mo->subsector->sector
; 2766 : 				|| (rover->master->frontsector->flags & SF_TRIGGERSPECIAL_TOUCH))

  00411	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00414	8b 08		 mov	 ecx, DWORD PTR [eax]
  00416	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00419	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0041c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0041e	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00420	74 14		 je	 SHORT $LN53@P_PlayerTo
  00422	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00425	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00428	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0042b	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  00431	83 e0 04	 and	 eax, 4
  00434	74 0b		 je	 SHORT $LN52@P_PlayerTo
$LN53@P_PlayerTo:

; 2767 : 				return rover->master->frontsector;

  00436	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00439	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0043c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0043f	eb 0c		 jmp	 SHORT $LN1@P_PlayerTo
$LN52@P_PlayerTo:

; 2768 : 		}

  00441	e9 37 fe ff ff	 jmp	 $LN8@P_PlayerTo
$LN9@P_PlayerTo:

; 2769 : 	}

  00446	e9 c7 fd ff ff	 jmp	 $LN5@P_PlayerTo
$LN6@P_PlayerTo:

; 2770 : 
; 2771 : 	return NULL;

  0044b	33 c0		 xor	 eax, eax
$LN1@P_PlayerTo:

; 2772 : }

  0044d	5f		 pop	 edi
  0044e	5e		 pop	 esi
  0044f	5b		 pop	 ebx
  00450	8b e5		 mov	 esp, ebp
  00452	5d		 pop	 ebp
  00453	c3		 ret	 0
_P_PlayerTouchingSectorSpecial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_UpdateSpecials
_TEXT	SEGMENT
_playercount$1 = -172					; size = 4
_spectators$2 = -168					; size = 4
_tempplayer$3 = -164					; size = 4
_playerarray$4 = -160					; size = 128
_pexit$5 = -32						; size = 4
_foundflats$ = -28					; size = 4
_j$ = -24						; size = 4
_pic$ = -20						; size = 4
_k$ = -16						; size = 4
_i$ = -12						; size = 4
_anim$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_P_UpdateSpecials PROC					; COMDAT

; 4159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4160 : 	anim_t *anim;
; 4161 : 	INT32 i, k;
; 4162 : 	INT32 pic;
; 4163 : 	size_t j;
; 4164 : 
; 4165 : 	levelflat_t *foundflats; // for flat animation
; 4166 : 
; 4167 : 	// LEVEL TIMER
; 4168 : 	// Exit if the timer is equal to or greater the timelimit, unless you are
; 4169 : 	// in overtime. In which case leveltime may stretch out beyond timelimitintics
; 4170 : 	// and overtime's status will be checked here each tick.
; 4171 : 	if (cv_timelimit.value && timelimitintics <= leveltime && (multiplayer || netgame)
; 4172 : 		&& (gametype != GT_COOP && gametype != GT_RACE) && (gameaction != ga_completed))

  00016	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_timelimit+20, 0
  0001d	0f 84 8e 03 00
	00		 je	 $LN45@P_UpdateSp
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _timelimitintics
  00028	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _leveltime
  0002e	0f 87 7d 03 00
	00		 ja	 $LN45@P_UpdateSp
  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  0003b	75 0d		 jne	 SHORT $LN27@P_UpdateSp
  0003d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00044	0f 84 67 03 00
	00		 je	 $LN45@P_UpdateSp
$LN27@P_UpdateSp:
  0004a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00051	85 c0		 test	 eax, eax
  00053	0f 84 58 03 00
	00		 je	 $LN45@P_UpdateSp
  00059	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00060	83 f8 02	 cmp	 eax, 2
  00063	0f 84 48 03 00
	00		 je	 $LN45@P_UpdateSp
  00069	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gameaction, 1
  00070	0f 84 3b 03 00
	00		 je	 $LN45@P_UpdateSp

; 4173 : 	{
; 4174 : 		boolean pexit = false;

  00076	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pexit$5[ebp], 0

; 4175 : 
; 4176 : 		//Tagmode round end but only on the tic before the
; 4177 : 		//XD_EXITLEVEL packet is recieved by all players.
; 4178 : 		if (gametype == GT_TAG && (leveltime == (timelimitintics + 1)))

  0007d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00084	83 f8 03	 cmp	 eax, 3
  00087	0f 85 c2 00 00
	00		 jne	 $LN28@P_UpdateSp
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _timelimitintics
  00092	83 c0 01	 add	 eax, 1
  00095	39 05 00 00 00
	00		 cmp	 DWORD PTR _leveltime, eax
  0009b	0f 85 ae 00 00
	00		 jne	 $LN28@P_UpdateSp

; 4179 : 		{
; 4180 : 			for (i = 0; i < MAXPLAYERS; i++)

  000a1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a8	eb 09		 jmp	 SHORT $LN4@P_UpdateSp
$LN2@P_UpdateSp:
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	83 c0 01	 add	 eax, 1
  000b0	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_UpdateSp:
  000b3	83 7d f4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000b7	0f 8d 8b 00 00
	00		 jge	 $LN3@P_UpdateSp

; 4181 : 			{
; 4182 : 				if (!playeringame[i] || players[i].spectator)

  000bd	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000c0	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000c8	74 12		 je	 SHORT $LN30@P_UpdateSp
  000ca	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000d1	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  000d8	85 c9		 test	 ecx, ecx
  000da	74 02		 je	 SHORT $LN29@P_UpdateSp
$LN30@P_UpdateSp:

; 4183 : 					continue;

  000dc	eb cc		 jmp	 SHORT $LN2@P_UpdateSp
$LN29@P_UpdateSp:

; 4184 : 
; 4185 : 				if (!(players[i].pflags & PF_TAGGED) && !(players[i].pflags & PF_TAGIT))

  000de	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000e5	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  000eb	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  000f1	75 50		 jne	 SHORT $LN31@P_UpdateSp
  000f3	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000fa	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  00100	81 e1 00 00 00
	10		 and	 ecx, 268435456		; 10000000H
  00106	75 3b		 jne	 SHORT $LN31@P_UpdateSp

; 4186 : 				{
; 4187 : 					CONS_Printf("%s recieved double points for surviving the round.\n", player_names[i]);

  00108	6b 45 f4 16	 imul	 eax, DWORD PTR _i$[ebp], 22
  0010c	05 00 00 00 00	 add	 eax, OFFSET _player_names
  00111	50		 push	 eax
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OPMPDJLP@?$CFs?5recieved?5double?5points?5for?5s@
  00117	e8 00 00 00 00	 call	 _CONS_Printf
  0011c	83 c4 08	 add	 esp, 8

; 4188 : 					P_AddPlayerScore(&players[i], players[i].score);

  0011f	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00126	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  0012c	51		 push	 ecx
  0012d	69 55 f4 fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  00134	81 c2 00 00 00
	00		 add	 edx, OFFSET _players
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 _P_AddPlayerScore
  00140	83 c4 08	 add	 esp, 8
$LN31@P_UpdateSp:

; 4189 : 				}
; 4190 : 			}

  00143	e9 62 ff ff ff	 jmp	 $LN2@P_UpdateSp
$LN3@P_UpdateSp:

; 4191 : 
; 4192 : 			pexit = true;

  00148	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _pexit$5[ebp], 1
$LN28@P_UpdateSp:

; 4193 : 		}
; 4194 : 
; 4195 : 		//Optional tie-breaker for Match/CTF
; 4196 : 		if ((gametype == GT_MATCH || gametype == GT_CTF) && cv_overtime.value)

  0014f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00156	83 f8 01	 cmp	 eax, 1
  00159	74 10		 je	 SHORT $LN34@P_UpdateSp
  0015b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00162	83 f8 04	 cmp	 eax, 4
  00165	0f 85 22 02 00
	00		 jne	 $LN32@P_UpdateSp
$LN34@P_UpdateSp:
  0016b	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_overtime+20, 0
  00172	0f 84 15 02 00
	00		 je	 $LN32@P_UpdateSp

; 4197 : 		{
; 4198 : 			INT32 playerarray[MAXPLAYERS];
; 4199 : 			INT32 tempplayer = 0;

  00178	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tempplayer$3[ebp], 0

; 4200 : 			INT32 spectators = 0;

  00182	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _spectators$2[ebp], 0

; 4201 : 			INT32 playercount = 0;

  0018c	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _playercount$1[ebp], 0

; 4202 : 
; 4203 : 			//Figure out if we have enough participating players to care.
; 4204 : 			for (i = 0; i < MAXPLAYERS; i++)

  00196	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0019d	eb 09		 jmp	 SHORT $LN7@P_UpdateSp
$LN5@P_UpdateSp:
  0019f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_UpdateSp:
  001a8	83 7d f4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  001ac	7d 30		 jge	 SHORT $LN6@P_UpdateSp

; 4205 : 			{
; 4206 : 				if (playeringame[i] && players[i].spectator)

  001ae	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  001b1	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  001b9	74 21		 je	 SHORT $LN35@P_UpdateSp
  001bb	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001c2	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  001c9	85 c9		 test	 ecx, ecx
  001cb	74 0f		 je	 SHORT $LN35@P_UpdateSp

; 4207 : 					spectators++;

  001cd	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _spectators$2[ebp]
  001d3	83 c0 01	 add	 eax, 1
  001d6	89 85 58 ff ff
	ff		 mov	 DWORD PTR _spectators$2[ebp], eax
$LN35@P_UpdateSp:

; 4208 : 			}

  001dc	eb c1		 jmp	 SHORT $LN5@P_UpdateSp
$LN6@P_UpdateSp:

; 4209 : 
; 4210 : 			if ((D_NumPlayers() - spectators) > 1)

  001de	e8 00 00 00 00	 call	 _D_NumPlayers
  001e3	2b 85 58 ff ff
	ff		 sub	 eax, DWORD PTR _spectators$2[ebp]
  001e9	83 f8 01	 cmp	 eax, 1
  001ec	0f 8e 92 01 00
	00		 jle	 $LN36@P_UpdateSp

; 4211 : 			{
; 4212 : 				// Play the starpost sfx after the first second of overtime.
; 4213 : 				if (gamestate == GS_LEVEL && (leveltime == (timelimitintics + TICRATE)))

  001f2	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  001f9	75 1f		 jne	 SHORT $LN38@P_UpdateSp
  001fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _timelimitintics
  00200	83 c0 23	 add	 eax, 35			; 00000023H
  00203	39 05 00 00 00
	00		 cmp	 DWORD PTR _leveltime, eax
  00209	75 0f		 jne	 SHORT $LN38@P_UpdateSp

; 4214 : 					S_StartSound(NULL, sfx_strpst);

  0020b	68 dd 00 00 00	 push	 221			; 000000ddH
  00210	6a 00		 push	 0
  00212	e8 00 00 00 00	 call	 _S_StartSound
  00217	83 c4 08	 add	 esp, 8
$LN38@P_UpdateSp:

; 4215 : 
; 4216 : 				// Normal Match
; 4217 : 				if (gametype == GT_MATCH && !cv_matchtype.value)

  0021a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00221	83 f8 01	 cmp	 eax, 1
  00224	0f 85 44 01 00
	00		 jne	 $LN39@P_UpdateSp
  0022a	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  00231	0f 85 37 01 00
	00		 jne	 $LN39@P_UpdateSp

; 4218 : 				{
; 4219 : 					//Store the nodes of participating players in an array.
; 4220 : 					for (i = 0; i < MAXPLAYERS; i++)

  00237	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0023e	eb 09		 jmp	 SHORT $LN10@P_UpdateSp
$LN8@P_UpdateSp:
  00240	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00243	83 c0 01	 add	 eax, 1
  00246	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@P_UpdateSp:
  00249	83 7d f4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0024d	7d 40		 jge	 SHORT $LN9@P_UpdateSp

; 4221 : 					{
; 4222 : 						if (playeringame[i] && !players[i].spectator)

  0024f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00252	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0025a	74 31		 je	 SHORT $LN41@P_UpdateSp
  0025c	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00263	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  0026a	85 c9		 test	 ecx, ecx
  0026c	75 1f		 jne	 SHORT $LN41@P_UpdateSp

; 4223 : 						{
; 4224 : 							playerarray[playercount] = i;

  0026e	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _playercount$1[ebp]
  00274	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00277	89 8c 85 60 ff
	ff ff		 mov	 DWORD PTR _playerarray$4[ebp+eax*4], ecx

; 4225 : 							playercount++;

  0027e	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _playercount$1[ebp]
  00284	83 c0 01	 add	 eax, 1
  00287	89 85 54 ff ff
	ff		 mov	 DWORD PTR _playercount$1[ebp], eax
$LN41@P_UpdateSp:

; 4226 : 						}
; 4227 : 					}

  0028d	eb b1		 jmp	 SHORT $LN8@P_UpdateSp
$LN9@P_UpdateSp:

; 4228 : 
; 4229 : 					//Sort 'em.
; 4230 : 					for (i = 1; i < playercount; i++)

  0028f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00296	eb 09		 jmp	 SHORT $LN13@P_UpdateSp
$LN11@P_UpdateSp:
  00298	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0029b	83 c0 01	 add	 eax, 1
  0029e	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN13@P_UpdateSp:
  002a1	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002a4	3b 85 54 ff ff
	ff		 cmp	 eax, DWORD PTR _playercount$1[ebp]
  002aa	0f 8d 81 00 00
	00		 jge	 $LN12@P_UpdateSp

; 4231 : 					{
; 4232 : 						for (k = i; k < playercount; k++)

  002b0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002b3	89 45 f0	 mov	 DWORD PTR _k$[ebp], eax
  002b6	eb 09		 jmp	 SHORT $LN16@P_UpdateSp
$LN14@P_UpdateSp:
  002b8	8b 45 f0	 mov	 eax, DWORD PTR _k$[ebp]
  002bb	83 c0 01	 add	 eax, 1
  002be	89 45 f0	 mov	 DWORD PTR _k$[ebp], eax
$LN16@P_UpdateSp:
  002c1	8b 45 f0	 mov	 eax, DWORD PTR _k$[ebp]
  002c4	3b 85 54 ff ff
	ff		 cmp	 eax, DWORD PTR _playercount$1[ebp]
  002ca	7d 60		 jge	 SHORT $LN15@P_UpdateSp

; 4233 : 						{
; 4234 : 							if (players[playerarray[i-1]].score < players[playerarray[k]].score)

  002cc	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002cf	69 8c 85 5c ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playerarray$4[ebp+eax*4-4], 508
  002da	8b 55 f0	 mov	 edx, DWORD PTR _k$[ebp]
  002dd	69 84 95 60 ff
	ff ff fc 01 00
	00		 imul	 eax, DWORD PTR _playerarray$4[ebp+edx*4], 508
  002e8	8b 89 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[ecx+188]
  002ee	3b 88 bc 00 00
	00		 cmp	 ecx, DWORD PTR _players[eax+188]
  002f4	73 34		 jae	 SHORT $LN42@P_UpdateSp

; 4235 : 							{
; 4236 : 								tempplayer = playerarray[i-1];

  002f6	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  002f9	8b 8c 85 5c ff
	ff ff		 mov	 ecx, DWORD PTR _playerarray$4[ebp+eax*4-4]
  00300	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _tempplayer$3[ebp], ecx

; 4237 : 								playerarray[i-1] = playerarray[k];

  00306	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00309	8b 4d f0	 mov	 ecx, DWORD PTR _k$[ebp]
  0030c	8b 94 8d 60 ff
	ff ff		 mov	 edx, DWORD PTR _playerarray$4[ebp+ecx*4]
  00313	89 94 85 5c ff
	ff ff		 mov	 DWORD PTR _playerarray$4[ebp+eax*4-4], edx

; 4238 : 								playerarray[k] = tempplayer;

  0031a	8b 45 f0	 mov	 eax, DWORD PTR _k$[ebp]
  0031d	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _tempplayer$3[ebp]
  00323	89 8c 85 60 ff
	ff ff		 mov	 DWORD PTR _playerarray$4[ebp+eax*4], ecx
$LN42@P_UpdateSp:

; 4239 : 							}
; 4240 : 						}

  0032a	eb 8c		 jmp	 SHORT $LN14@P_UpdateSp
$LN15@P_UpdateSp:

; 4241 : 					}

  0032c	e9 67 ff ff ff	 jmp	 $LN11@P_UpdateSp
$LN12@P_UpdateSp:

; 4242 : 
; 4243 : 					//End the round if the top players aren't tied.
; 4244 : 					if (!(players[playerarray[0]].score == players[playerarray[1]].score))

  00331	b8 04 00 00 00	 mov	 eax, 4
  00336	6b c8 00	 imul	 ecx, eax, 0
  00339	69 94 0d 60 ff
	ff ff fc 01 00
	00		 imul	 edx, DWORD PTR _playerarray$4[ebp+ecx], 508
  00344	b8 04 00 00 00	 mov	 eax, 4
  00349	c1 e0 00	 shl	 eax, 0
  0034c	69 8c 05 60 ff
	ff ff fc 01 00
	00		 imul	 ecx, DWORD PTR _playerarray$4[ebp+eax], 508
  00357	8b 92 bc 00 00
	00		 mov	 edx, DWORD PTR _players[edx+188]
  0035d	3b 91 bc 00 00
	00		 cmp	 edx, DWORD PTR _players[ecx+188]
  00363	74 07		 je	 SHORT $LN43@P_UpdateSp

; 4245 : 						pexit = true;

  00365	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _pexit$5[ebp], 1
$LN43@P_UpdateSp:

; 4246 : 				}

  0036c	eb 14		 jmp	 SHORT $LN44@P_UpdateSp
$LN39@P_UpdateSp:

; 4247 : 				else
; 4248 : 				{
; 4249 : 					//In team match and CTF, determining a tie is much simpler. =P
; 4250 : 					if (!(redscore == bluescore))

  0036e	a1 00 00 00 00	 mov	 eax, DWORD PTR _redscore
  00373	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bluescore
  00379	74 07		 je	 SHORT $LN44@P_UpdateSp

; 4251 : 						pexit = true;

  0037b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _pexit$5[ebp], 1
$LN44@P_UpdateSp:

; 4252 : 				}
; 4253 : 			}

  00382	eb 07		 jmp	 SHORT $LN37@P_UpdateSp
$LN36@P_UpdateSp:

; 4254 : 			else
; 4255 : 				pexit = true;

  00384	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _pexit$5[ebp], 1
$LN37@P_UpdateSp:

; 4256 : 		}

  0038b	eb 07		 jmp	 SHORT $LN33@P_UpdateSp
$LN32@P_UpdateSp:

; 4257 : 		else
; 4258 : 			pexit = true;

  0038d	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _pexit$5[ebp], 1
$LN33@P_UpdateSp:

; 4259 : 
; 4260 : 		if (server && pexit)

  00394	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  0039b	74 14		 je	 SHORT $LN45@P_UpdateSp
  0039d	83 7d e0 00	 cmp	 DWORD PTR _pexit$5[ebp], 0
  003a1	74 0e		 je	 SHORT $LN45@P_UpdateSp

; 4261 : 			SendNetXCmd(XD_EXITLEVEL, NULL, 0);

  003a3	6a 00		 push	 0
  003a5	6a 00		 push	 0
  003a7	6a 07		 push	 7
  003a9	e8 00 00 00 00	 call	 _SendNetXCmd
  003ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN45@P_UpdateSp:

; 4262 : 	}
; 4263 : 
; 4264 : 	// POINT LIMIT
; 4265 : 	P_CheckPointLimit();

  003b1	e8 00 00 00 00	 call	 _P_CheckPointLimit
  003b6	90		 npad	 1

; 4266 : 
; 4267 : 	// ANIMATE TEXTURES
; 4268 : 	for (anim = anims; anim < lastanim; anim++)

  003b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _anims
  003bc	89 45 f8	 mov	 DWORD PTR _anim$[ebp], eax
  003bf	eb 09		 jmp	 SHORT $LN19@P_UpdateSp
$LN17@P_UpdateSp:
  003c1	8b 45 f8	 mov	 eax, DWORD PTR _anim$[ebp]
  003c4	83 c0 14	 add	 eax, 20			; 00000014H
  003c7	89 45 f8	 mov	 DWORD PTR _anim$[ebp], eax
$LN19@P_UpdateSp:
  003ca	8b 45 f8	 mov	 eax, DWORD PTR _anim$[ebp]
  003cd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lastanim
  003d3	73 63		 jae	 SHORT $LN18@P_UpdateSp

; 4269 : 	{
; 4270 : 		for (i = anim->basepic; i < anim->basepic + anim->numpics; i++)

  003d5	8b 45 f8	 mov	 eax, DWORD PTR _anim$[ebp]
  003d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003db	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
  003de	eb 09		 jmp	 SHORT $LN22@P_UpdateSp
$LN20@P_UpdateSp:
  003e0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  003e3	83 c0 01	 add	 eax, 1
  003e6	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN22@P_UpdateSp:
  003e9	8b 45 f8	 mov	 eax, DWORD PTR _anim$[ebp]
  003ec	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003ef	8b 55 f8	 mov	 edx, DWORD PTR _anim$[ebp]
  003f2	03 4a 0c	 add	 ecx, DWORD PTR [edx+12]
  003f5	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  003f8	7d 3c		 jge	 SHORT $LN21@P_UpdateSp

; 4271 : 		{
; 4272 : 			pic = anim->basepic + ((leveltime/anim->speed + i) % anim->numpics);

  003fa	8b 4d f8	 mov	 ecx, DWORD PTR _anim$[ebp]
  003fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  00402	33 d2		 xor	 edx, edx
  00404	f7 71 10	 div	 DWORD PTR [ecx+16]
  00407	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  0040a	8b 4d f8	 mov	 ecx, DWORD PTR _anim$[ebp]
  0040d	33 d2		 xor	 edx, edx
  0040f	f7 71 0c	 div	 DWORD PTR [ecx+12]
  00412	8b 45 f8	 mov	 eax, DWORD PTR _anim$[ebp]
  00415	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00418	89 55 ec	 mov	 DWORD PTR _pic$[ebp], edx

; 4273 : 			if (anim->istexture)

  0041b	8b 45 f8	 mov	 eax, DWORD PTR _anim$[ebp]
  0041e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00421	85 c9		 test	 ecx, ecx
  00423	74 0f		 je	 SHORT $LN46@P_UpdateSp

; 4274 : 				texturetranslation[i] = pic;

  00425	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00428	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _texturetranslation
  0042e	8b 55 ec	 mov	 edx, DWORD PTR _pic$[ebp]
  00431	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$LN46@P_UpdateSp:

; 4275 : 		}

  00434	eb aa		 jmp	 SHORT $LN20@P_UpdateSp
$LN21@P_UpdateSp:

; 4276 : 	}

  00436	eb 89		 jmp	 SHORT $LN17@P_UpdateSp
$LN18@P_UpdateSp:

; 4277 : 
; 4278 : 	// ANIMATE FLATS
; 4279 : 	/// \todo do not check the non-animate flat.. link the animated ones?
; 4280 : 	/// \note its faster than the original anywaysince it animates only
; 4281 : 	///    flats used in the level, and there's usually very few of them
; 4282 : 	foundflats = levelflats;

  00438	a1 00 00 00 00	 mov	 eax, DWORD PTR _levelflats
  0043d	89 45 e4	 mov	 DWORD PTR _foundflats$[ebp], eax

; 4283 : 	for (j = 0; j < numlevelflats; j++, foundflats++)

  00440	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00447	eb 12		 jmp	 SHORT $LN25@P_UpdateSp
$LN23@P_UpdateSp:
  00449	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  0044c	83 c0 01	 add	 eax, 1
  0044f	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
  00452	8b 4d e4	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00455	83 c1 20	 add	 ecx, 32			; 00000020H
  00458	89 4d e4	 mov	 DWORD PTR _foundflats$[ebp], ecx
$LN25@P_UpdateSp:
  0045b	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  0045e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlevelflats
  00464	73 32		 jae	 SHORT $LN24@P_UpdateSp

; 4284 : 	{
; 4285 : 		if (foundflats->speed) // it is an animated flat

  00466	8b 45 e4	 mov	 eax, DWORD PTR _foundflats$[ebp]
  00469	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0046d	74 27		 je	 SHORT $LN47@P_UpdateSp

; 4286 : 		{
; 4287 : 			// update the levelflat lump number
; 4288 : 			foundflats->lumpnum = foundflats->baselumpnum +

  0046f	8b 4d e4	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00472	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  00477	33 d2		 xor	 edx, edx
  00479	f7 71 1c	 div	 DWORD PTR [ecx+28]
  0047c	8b 55 e4	 mov	 edx, DWORD PTR _foundflats$[ebp]
  0047f	03 42 14	 add	 eax, DWORD PTR [edx+20]
  00482	8b 4d e4	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00485	33 d2		 xor	 edx, edx
  00487	f7 71 18	 div	 DWORD PTR [ecx+24]
  0048a	8b 45 e4	 mov	 eax, DWORD PTR _foundflats$[ebp]
  0048d	03 50 10	 add	 edx, DWORD PTR [eax+16]
  00490	8b 4d e4	 mov	 ecx, DWORD PTR _foundflats$[ebp]
  00493	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN47@P_UpdateSp:

; 4289 : 				((leveltime/foundflats->speed + foundflats->animseq) % foundflats->numpics);
; 4290 : 		}
; 4291 : 	}

  00496	eb b1		 jmp	 SHORT $LN23@P_UpdateSp
$LN24@P_UpdateSp:

; 4292 : }

  00498	5f		 pop	 edi
  00499	5e		 pop	 esi
  0049a	5b		 pop	 ebx
  0049b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049e	33 cd		 xor	 ecx, ebp
  004a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a5	8b e5		 mov	 esp, ebp
  004a7	5d		 pop	 ebp
  004a8	c3		 ret	 0
_P_UpdateSpecials ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SpawnSpecials
_TEXT	SEGMENT
tv73 = -108						; size = 4
tv84 = -108						; size = 4
tv131 = -108						; size = 4
tv247 = -108						; size = 4
tv952 = -108						; size = 4
tv1750 = -108						; size = 4
_FOF_Flags$1 = -40					; size = 4
_msd$2 = -36						; size = 4
_b$3 = -32						; size = 2
_data$4 = -28						; size = 4
_ffloorflags$5 = -24					; size = 4
_sec$6 = -20						; size = 4
_s$7 = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_sector$ = -4						; size = 4
_fromnetsave$ = 8					; size = 4
_P_SpawnSpecials PROC					; COMDAT

; 4934 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4935 : 	sector_t *sector;
; 4936 : 	size_t i;
; 4937 : 	INT32 j;
; 4938 : 
; 4939 : 	// Set the default gravity. Custom gravity overrides this setting.
; 4940 : 	gravity = FRACUNIT/2;

  00009	c7 05 00 00 00
	00 00 80 00 00	 mov	 DWORD PTR _gravity, 32768 ; 00008000H

; 4941 : 
; 4942 : 	// Defaults in case levels don't have them set.
; 4943 : 	sstimer = 90*TICRATE + 6;

  00013	c7 05 00 00 00
	00 54 0c 00 00	 mov	 DWORD PTR _sstimer, 3156 ; 00000c54H

; 4944 : 	totalrings = 1;

  0001d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _totalrings, 1

; 4945 : 
; 4946 : 	CheckForBustableBlocks = CheckForBouncySector = CheckForQuicksand = CheckForMarioBlocks = CheckForFloatBob = CheckForReverseGravity = false;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CheckForReverseGravity, 0
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _CheckForReverseGravity
  00036	a3 00 00 00 00	 mov	 DWORD PTR _CheckForFloatBob, eax
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CheckForFloatBob
  00041	89 0d 00 00 00
	00		 mov	 DWORD PTR _CheckForMarioBlocks, ecx
  00047	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _CheckForMarioBlocks
  0004d	89 15 00 00 00
	00		 mov	 DWORD PTR _CheckForQuicksand, edx
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _CheckForQuicksand
  00058	a3 00 00 00 00	 mov	 DWORD PTR _CheckForBouncySector, eax
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _CheckForBouncySector
  00063	89 0d 00 00 00
	00		 mov	 DWORD PTR _CheckForBustableBlocks, ecx

; 4947 : 
; 4948 : 	// Init special SECTORs.
; 4949 : 	sector = sectors;

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  0006e	89 45 fc	 mov	 DWORD PTR _sector$[ebp], eax

; 4950 : 	for (i = 0; i < numsectors; i++, sector++)

  00071	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 15		 jmp	 SHORT $LN4@P_SpawnSpe
$LN2@P_SpawnSpe:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _sector$[ebp]
  00086	81 c1 f8 00 00
	00		 add	 ecx, 248		; 000000f8H
  0008c	89 4d fc	 mov	 DWORD PTR _sector$[ebp], ecx
$LN4@P_SpawnSpe:
  0008f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00092	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsectors
  00098	0f 83 ce 00 00
	00		 jae	 $LN3@P_SpawnSpe

; 4951 : 	{
; 4952 : 		if (!sector->special)

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  000a1	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  000a5	85 c9		 test	 ecx, ecx
  000a7	75 02		 jne	 SHORT $LN105@P_SpawnSpe

; 4953 : 			continue;

  000a9	eb cf		 jmp	 SHORT $LN2@P_SpawnSpe
$LN105@P_SpawnSpe:

; 4954 : 
; 4955 : 		// Process Section 1
; 4956 : 		switch(GETSECSPECIAL(sector->special, 1))

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  000ae	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  000b2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000b5	89 4d 94	 mov	 DWORD PTR tv73[ebp], ecx
  000b8	83 7d 94 05	 cmp	 DWORD PTR tv73[ebp], 5
  000bc	74 08		 je	 SHORT $LN106@P_SpawnSpe
  000be	83 7d 94 0f	 cmp	 DWORD PTR tv73[ebp], 15	; 0000000fH
  000c2	74 22		 je	 SHORT $LN107@P_SpawnSpe
  000c4	eb 2a		 jmp	 SHORT $LN5@P_SpawnSpe
$LN106@P_SpawnSpe:

; 4957 : 		{
; 4958 : 			case 5: // Spikes
; 4959 : 				P_AddSpikeThinker(sector, (INT32)(sector-sectors));

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  000c9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  000cf	99		 cdq
  000d0	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  000d5	f7 f9		 idiv	 ecx
  000d7	50		 push	 eax
  000d8	8b 55 fc	 mov	 edx, DWORD PTR _sector$[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 _P_AddSpikeThinker
  000e1	83 c4 08	 add	 esp, 8

; 4960 : 				break;

  000e4	eb 0a		 jmp	 SHORT $LN5@P_SpawnSpe
$LN107@P_SpawnSpe:

; 4961 : 
; 4962 : 			case 15: // Bouncy sector
; 4963 : 				CheckForBouncySector = true;

  000e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CheckForBouncySector, 1
$LN5@P_SpawnSpe:

; 4964 : 				break;
; 4965 : 		}
; 4966 : 
; 4967 : 		// Process Section 2
; 4968 : 		switch(GETSECSPECIAL(sector->special, 2))

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  000f3	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  000f7	c1 f9 04	 sar	 ecx, 4
  000fa	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000fd	89 4d 94	 mov	 DWORD PTR tv84[ebp], ecx
  00100	83 7d 94 0a	 cmp	 DWORD PTR tv84[ebp], 10	; 0000000aH
  00104	74 08		 je	 SHORT $LN108@P_SpawnSpe
  00106	83 7d 94 0b	 cmp	 DWORD PTR tv84[ebp], 11	; 0000000bH
  0010a	74 27		 je	 SHORT $LN109@P_SpawnSpe
  0010c	eb 37		 jmp	 SHORT $LN7@P_SpawnSpe
$LN108@P_SpawnSpe:

; 4969 : 		{
; 4970 : 			case 10: // Time for special stage
; 4971 : 				sstimer = (sector->floorheight>>FRACBITS) * TICRATE + 6; // Time to finish

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00111	8b 08		 mov	 ecx, DWORD PTR [eax]
  00113	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00116	6b d1 23	 imul	 edx, ecx, 35
  00119	83 c2 06	 add	 edx, 6
  0011c	89 15 00 00 00
	00		 mov	 DWORD PTR _sstimer, edx

; 4972 : 				totalrings = sector->ceilingheight>>FRACBITS; // Ring count for special stage

  00122	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00125	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00128	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0012b	89 0d 00 00 00
	00		 mov	 DWORD PTR _totalrings, ecx

; 4973 : 				break;

  00131	eb 12		 jmp	 SHORT $LN7@P_SpawnSpe
$LN109@P_SpawnSpe:

; 4974 : 
; 4975 : 			case 11: // Custom global gravity!
; 4976 : 				gravity = sector->floorheight/1000;

  00133	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00136	8b 00		 mov	 eax, DWORD PTR [eax]
  00138	99		 cdq
  00139	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0013e	f7 f9		 idiv	 ecx
  00140	a3 00 00 00 00	 mov	 DWORD PTR _gravity, eax
$LN7@P_SpawnSpe:

; 4977 : 				break;
; 4978 : 		}
; 4979 : 
; 4980 : 		// Process Section 3
; 4981 : /*		switch(GETSECSPECIAL(player->specialsector, 3))
; 4982 : 		{
; 4983 : 
; 4984 : 		}*/
; 4985 : 
; 4986 : 		// Process Section 4
; 4987 : 		switch(GETSECSPECIAL(sector->special, 4))

  00145	8b 45 fc	 mov	 eax, DWORD PTR _sector$[ebp]
  00148	0f bf 48 12	 movsx	 ecx, WORD PTR [eax+18]
  0014c	c1 f9 0c	 sar	 ecx, 12			; 0000000cH
  0014f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00152	89 4d 94	 mov	 DWORD PTR tv131[ebp], ecx
  00155	83 7d 94 0a	 cmp	 DWORD PTR tv131[ebp], 10 ; 0000000aH
  00159	74 02		 je	 SHORT $LN110@P_SpawnSpe
  0015b	eb 0a		 jmp	 SHORT $LN9@P_SpawnSpe
$LN110@P_SpawnSpe:

; 4988 : 		{
; 4989 : 			case 10: // Circuit finish line
; 4990 : 				circuitmap = true;

  0015d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _circuitmap, 1
$LN9@P_SpawnSpe:

; 4991 : 				break;
; 4992 : 		}
; 4993 : 	}

  00167	e9 0e ff ff ff	 jmp	 $LN2@P_SpawnSpe
$LN3@P_SpawnSpe:

; 4994 : 
; 4995 : 	if (mapheaderinfo[gamemap-1].weather == 2) // snow

  0016c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00173	83 e8 01	 sub	 eax, 1
  00176	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0017c	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  00183	83 fa 02	 cmp	 edx, 2
  00186	75 0f		 jne	 SHORT $LN111@P_SpawnSpe

; 4996 : 		curWeather = PRECIP_SNOW;

  00188	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _curWeather, 2
  00192	e9 d8 00 00 00	 jmp	 $LN122@P_SpawnSpe
$LN111@P_SpawnSpe:

; 4997 : 	else if (mapheaderinfo[gamemap-1].weather == 3) // rain

  00197	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0019e	83 e8 01	 sub	 eax, 1
  001a1	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001a7	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  001ae	83 fa 03	 cmp	 edx, 3
  001b1	75 0f		 jne	 SHORT $LN113@P_SpawnSpe

; 4998 : 		curWeather = PRECIP_RAIN;

  001b3	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _curWeather, 3
  001bd	e9 ad 00 00 00	 jmp	 $LN122@P_SpawnSpe
$LN113@P_SpawnSpe:

; 4999 : 	else if (mapheaderinfo[gamemap-1].weather == 1) // storm

  001c2	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  001c9	83 e8 01	 sub	 eax, 1
  001cc	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001d2	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  001d9	83 fa 01	 cmp	 edx, 1
  001dc	75 0f		 jne	 SHORT $LN115@P_SpawnSpe

; 5000 : 		curWeather = PRECIP_STORM;

  001de	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _curWeather, 1
  001e8	e9 82 00 00 00	 jmp	 $LN122@P_SpawnSpe
$LN115@P_SpawnSpe:

; 5001 : 	else if (mapheaderinfo[gamemap-1].weather == 5) // storm w/o rain

  001ed	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  001f4	83 e8 01	 sub	 eax, 1
  001f7	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001fd	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  00204	83 fa 05	 cmp	 edx, 5
  00207	75 0c		 jne	 SHORT $LN117@P_SpawnSpe

; 5002 : 		curWeather = PRECIP_STORM_NORAIN;

  00209	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _curWeather, 5
  00213	eb 5a		 jmp	 SHORT $LN122@P_SpawnSpe
$LN117@P_SpawnSpe:

; 5003 : 	else if (mapheaderinfo[gamemap-1].weather == 6) // storm w/o lightning

  00215	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0021c	83 e8 01	 sub	 eax, 1
  0021f	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00225	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  0022c	83 fa 06	 cmp	 edx, 6
  0022f	75 0c		 jne	 SHORT $LN119@P_SpawnSpe

; 5004 : 		curWeather = PRECIP_STORM_NOSTRIKES;

  00231	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _curWeather, 6
  0023b	eb 32		 jmp	 SHORT $LN122@P_SpawnSpe
$LN119@P_SpawnSpe:

; 5005 : 	else if (mapheaderinfo[gamemap-1].weather == 7) // heat wave

  0023d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00244	83 e8 01	 sub	 eax, 1
  00247	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0024d	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  00254	83 fa 07	 cmp	 edx, 7
  00257	75 0c		 jne	 SHORT $LN121@P_SpawnSpe

; 5006 : 		curWeather = PRECIP_HEATWAVE;

  00259	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR _curWeather, 7
  00263	eb 0a		 jmp	 SHORT $LN122@P_SpawnSpe
$LN121@P_SpawnSpe:

; 5007 : 	else
; 5008 : 		curWeather = PRECIP_NONE;

  00265	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _curWeather, 0
$LN122@P_SpawnSpe:

; 5009 : 
; 5010 : 	P_InitTagLists();   // Create xref tables for tags

  0026f	e8 00 00 00 00	 call	 _P_InitTagLists
  00274	90		 npad	 1

; 5011 : 	P_SpawnScrollers(); // Add generalized scrollers

  00275	e8 00 00 00 00	 call	 _P_SpawnScrollers
  0027a	90		 npad	 1

; 5012 : 	P_SpawnFriction();  // Friction model using linedefs

  0027b	e8 00 00 00 00	 call	 _P_SpawnFriction
  00280	90		 npad	 1

; 5013 : 	P_SpawnPushers();   // Pusher model using linedefs

  00281	e8 00 00 00 00	 call	 _P_SpawnPushers
  00286	90		 npad	 1

; 5014 : 
; 5015 : 	// Look for disable linedefs
; 5016 : 	for (i = 0; i < numlines; i++)

  00287	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0028e	eb 09		 jmp	 SHORT $LN13@P_SpawnSpe
$LN11@P_SpawnSpe:
  00290	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00293	83 c0 01	 add	 eax, 1
  00296	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@P_SpawnSpe:
  00299	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0029c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  002a2	0f 83 86 00 00
	00		 jae	 $LN12@P_SpawnSpe

; 5017 : 	{
; 5018 : 		if (lines[i].special == 6)

  002a8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  002b2	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  002b7	83 fa 06	 cmp	 edx, 6
  002ba	75 6d		 jne	 SHORT $LN123@P_SpawnSpe

; 5019 : 		{
; 5020 : 			for (j = -1; (j = P_FindLineFromLineTag(&lines[i], j)) >= 0;)

  002bc	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _j$[ebp], -1
$LN14@P_SpawnSpe:
  002c3	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  002c6	50		 push	 eax
  002c7	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  002cb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  002d1	51		 push	 ecx
  002d2	e8 00 00 00 00	 call	 _P_FindLineFromLineTag
  002d7	83 c4 08	 add	 esp, 8
  002da	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
  002dd	83 7d f4 00	 cmp	 DWORD PTR _j$[ebp], 0
  002e1	7c 24		 jl	 SHORT $LN15@P_SpawnSpe

; 5021 : 			{
; 5022 : 				lines[j].tag = 0;

  002e3	6b 45 f4 4c	 imul	 eax, DWORD PTR _j$[ebp], 76
  002e7	33 c9		 xor	 ecx, ecx
  002e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  002ef	66 89 4c 02 14	 mov	 WORD PTR [edx+eax+20], cx

; 5023 : 				lines[j].special = 0;

  002f4	6b 45 f4 4c	 imul	 eax, DWORD PTR _j$[ebp], 76
  002f8	33 c9		 xor	 ecx, ecx
  002fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00300	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx

; 5024 : 			}

  00305	eb bc		 jmp	 SHORT $LN14@P_SpawnSpe
$LN15@P_SpawnSpe:

; 5025 : 			lines[i].special = 0;

  00307	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0030b	33 c9		 xor	 ecx, ecx
  0030d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00313	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx

; 5026 : 			lines[i].tag = 0;

  00318	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0031c	33 c9		 xor	 ecx, ecx
  0031e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00324	66 89 4c 02 14	 mov	 WORD PTR [edx+eax+20], cx
$LN123@P_SpawnSpe:

; 5027 : 		}
; 5028 : 	}

  00329	e9 62 ff ff ff	 jmp	 $LN11@P_SpawnSpe
$LN12@P_SpawnSpe:

; 5029 : 
; 5030 : 	// Init line EFFECTs
; 5031 : 	for (i = 0; i < numlines; i++)

  0032e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00335	eb 09		 jmp	 SHORT $LN19@P_SpawnSpe
$LN17@P_SpawnSpe:
  00337	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0033a	83 c0 01	 add	 eax, 1
  0033d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN19@P_SpawnSpe:
  00340	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00343	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  00349	0f 83 4c 22 00
	00		 jae	 $LN18@P_SpawnSpe

; 5032 : 	{
; 5033 : 		// set line specials to 0 here too, same reason as above
; 5034 : 		if (!(netgame || multiplayer))

  0034f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00356	0f 85 ca 00 00
	00		 jne	 $LN127@P_SpawnSpe
  0035c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00363	0f 85 bd 00 00
	00		 jne	 $LN127@P_SpawnSpe

; 5035 : 		{
; 5036 : 			if (players[consoleplayer].charability == CA_THOK && (lines[i].flags & ML_NOSONIC))

  00369	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00373	83 b8 d8 00 00
	00 00		 cmp	 DWORD PTR _players[eax+216], 0
  0037a	75 2a		 jne	 SHORT $LN125@P_SpawnSpe
  0037c	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00386	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0038b	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  00391	74 13		 je	 SHORT $LN125@P_SpawnSpe

; 5037 : 			{
; 5038 : 				lines[i].special = 0;

  00393	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00397	33 c9		 xor	 ecx, ecx
  00399	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0039f	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx

; 5039 : 				continue;

  003a4	eb 91		 jmp	 SHORT $LN17@P_SpawnSpe
$LN125@P_SpawnSpe:

; 5040 : 			}
; 5041 : 			if (players[consoleplayer].charability == CA_FLY && (lines[i].flags & ML_NOTAILS))

  003a6	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  003b0	83 b8 d8 00 00
	00 01		 cmp	 DWORD PTR _players[eax+216], 1
  003b7	75 2d		 jne	 SHORT $LN126@P_SpawnSpe
  003b9	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  003bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  003c3	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  003c8	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  003ce	74 16		 je	 SHORT $LN126@P_SpawnSpe

; 5042 : 			{
; 5043 : 				lines[i].special = 0;

  003d0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  003d4	33 c9		 xor	 ecx, ecx
  003d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  003dc	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx

; 5044 : 				continue;

  003e1	e9 51 ff ff ff	 jmp	 $LN17@P_SpawnSpe
$LN126@P_SpawnSpe:

; 5045 : 			}
; 5046 : 			if (players[consoleplayer].charability == CA_GLIDEANDCLIMB && (lines[i].flags & ML_NOKNUX))

  003e6	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  003f0	83 b8 d8 00 00
	00 02		 cmp	 DWORD PTR _players[eax+216], 2
  003f7	75 2d		 jne	 SHORT $LN127@P_SpawnSpe
  003f9	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  003fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00403	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00408	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  0040e	74 16		 je	 SHORT $LN127@P_SpawnSpe

; 5047 : 			{
; 5048 : 				lines[i].special = 0;

  00410	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00414	33 c9		 xor	 ecx, ecx
  00416	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0041c	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx

; 5049 : 				continue;

  00421	e9 11 ff ff ff	 jmp	 $LN17@P_SpawnSpe
$LN127@P_SpawnSpe:

; 5050 : 			}
; 5051 : 		}
; 5052 : 
; 5053 : 		switch (lines[i].special)

  00426	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0042a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00430	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00435	89 55 94	 mov	 DWORD PTR tv247[ebp], edx
  00438	81 7d 94 fa 00
	00 00		 cmp	 DWORD PTR tv247[ebp], 250 ; 000000faH
  0043f	7f 34		 jg	 SHORT $LN337@P_SpawnSpe
  00441	81 7d 94 fa 00
	00 00		 cmp	 DWORD PTR tv247[ebp], 250 ; 000000faH
  00448	0f 84 d0 17 00
	00		 je	 $LN250@P_SpawnSpe
  0044e	8b 45 94	 mov	 eax, DWORD PTR tv247[ebp]
  00451	83 e8 01	 sub	 eax, 1
  00454	89 45 94	 mov	 DWORD PTR tv247[ebp], eax
  00457	81 7d 94 de 00
	00 00		 cmp	 DWORD PTR tv247[ebp], 222 ; 000000deH
  0045e	0f 87 32 21 00
	00		 ja	 $LN332@P_SpawnSpe
  00464	8b 4d 94	 mov	 ecx, DWORD PTR tv247[ebp]
  00467	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN339@P_SpawnSpe[ecx]
  0046e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN340@P_SpawnSpe[edx*4]
$LN337@P_SpawnSpe:
  00475	81 7d 94 58 02
	00 00		 cmp	 DWORD PTR tv247[ebp], 600 ; 00000258H
  0047c	7f 33		 jg	 SHORT $LN338@P_SpawnSpe
  0047e	81 7d 94 58 02
	00 00		 cmp	 DWORD PTR tv247[ebp], 600 ; 00000258H
  00485	0f 84 f5 1c 00
	00		 je	 $LN325@P_SpawnSpe
  0048b	8b 45 94	 mov	 eax, DWORD PTR tv247[ebp]
  0048e	2d fb 00 00 00	 sub	 eax, 251		; 000000fbH
  00493	89 45 94	 mov	 DWORD PTR tv247[ebp], eax
  00496	83 7d 94 3e	 cmp	 DWORD PTR tv247[ebp], 62 ; 0000003eH
  0049a	0f 87 f6 20 00
	00		 ja	 $LN332@P_SpawnSpe
  004a0	8b 4d 94	 mov	 ecx, DWORD PTR tv247[ebp]
  004a3	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN341@P_SpawnSpe[ecx]
  004aa	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN342@P_SpawnSpe[edx*4]
$LN338@P_SpawnSpe:
  004b1	8b 45 94	 mov	 eax, DWORD PTR tv247[ebp]
  004b4	2d 59 02 00 00	 sub	 eax, 601		; 00000259H
  004b9	89 45 94	 mov	 DWORD PTR tv247[ebp], eax
  004bc	83 7d 94 05	 cmp	 DWORD PTR tv247[ebp], 5
  004c0	0f 87 d0 20 00
	00		 ja	 $LN332@P_SpawnSpe
  004c6	8b 4d 94	 mov	 ecx, DWORD PTR tv247[ebp]
  004c9	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN343@P_SpawnSpe[ecx*4]
$LN128@P_SpawnSpe:

; 5054 : 		{
; 5055 : 			INT32 s;
; 5056 : 			size_t sec;
; 5057 : 			ffloortype_e ffloorflags;
; 5058 : 
; 5059 : 			case 1: // Definable gravity per sector
; 5060 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  004d0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  004d4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  004da	b9 02 00 00 00	 mov	 ecx, 2
  004df	6b d1 00	 imul	 edx, ecx, 0
  004e2	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  004e7	6b c8 1c	 imul	 ecx, eax, 28
  004ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  004f0	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  004f4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  004fa	99		 cdq
  004fb	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00500	f7 f9		 idiv	 ecx
  00502	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5061 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  00505	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN22@P_SpawnSpe:
  0050c	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  0050f	50		 push	 eax
  00510	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00514	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  0051a	51		 push	 ecx
  0051b	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00520	83 c4 08	 add	 esp, 8
  00523	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00526	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  0052a	0f 8c 86 00 00
	00		 jl	 $LN23@P_SpawnSpe

; 5062 : 				{
; 5063 : 					sectors[s].gravity = &sectors[sec].floorheight; // This allows it to change in realtime!

  00530	69 45 ec f8 00
	00 00		 imul	 eax, DWORD PTR _sec$6[ebp], 248
  00537	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  0053d	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00544	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0054a	89 84 0a d8 00
	00 00		 mov	 DWORD PTR [edx+ecx+216], eax

; 5064 : 
; 5065 : 					if (lines[i].flags & ML_NOCLIMB)

  00551	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00555	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0055b	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00560	83 e2 40	 and	 edx, 64			; 00000040H
  00563	74 1a		 je	 SHORT $LN129@P_SpawnSpe

; 5066 : 						sectors[s].verticalflip = true;

  00565	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  0056c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00572	c7 84 01 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+220], 1
  0057d	eb 18		 jmp	 SHORT $LN130@P_SpawnSpe
$LN129@P_SpawnSpe:

; 5067 : 					else
; 5068 : 						sectors[s].verticalflip = false;

  0057f	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00586	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0058c	c7 84 01 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+220], 0
$LN130@P_SpawnSpe:

; 5069 : 
; 5070 : 					CheckForReverseGravity = sectors[s].verticalflip;

  00597	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  0059e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  005a4	8b 94 01 dc 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+220]
  005ab	89 15 00 00 00
	00		 mov	 DWORD PTR _CheckForReverseGravity, edx

; 5071 : 				}

  005b1	e9 56 ff ff ff	 jmp	 $LN22@P_SpawnSpe
$LN23@P_SpawnSpe:

; 5072 : 				break;

  005b6	e9 db 1f 00 00	 jmp	 $LN20@P_SpawnSpe

; 5073 : 
; 5074 : 			case 2: // Custom exit
; 5075 : 				break;

  005bb	e9 d6 1f 00 00	 jmp	 $LN20@P_SpawnSpe

; 5076 : 
; 5077 : 			case 3: // Zoom Tube Parameters
; 5078 : 				break;

  005c0	e9 d1 1f 00 00	 jmp	 $LN20@P_SpawnSpe

; 5079 : 
; 5080 : 			case 4: // Speed pad (combines with sector special Section3:5 or Section3:6)
; 5081 : 				break;

  005c5	e9 cc 1f 00 00	 jmp	 $LN20@P_SpawnSpe
$LN134@P_SpawnSpe:

; 5082 : 
; 5083 : 			case 5: // Change camera info
; 5084 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  005ca	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  005ce	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  005d4	b9 02 00 00 00	 mov	 ecx, 2
  005d9	6b d1 00	 imul	 edx, ecx, 0
  005dc	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  005e1	6b c8 1c	 imul	 ecx, eax, 28
  005e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  005ea	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  005ee	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  005f4	99		 cdq
  005f5	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  005fa	f7 f9		 idiv	 ecx
  005fc	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5085 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  005ff	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN25@P_SpawnSpe:
  00606	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00609	50		 push	 eax
  0060a	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0060e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00614	51		 push	 ecx
  00615	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  0061a	83 c4 08	 add	 esp, 8
  0061d	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00620	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  00624	7c 75		 jl	 SHORT $LN26@P_SpawnSpe

; 5086 : 					P_AddCameraScanner(&sectors[sec], &sectors[s], R_PointToAngle2(lines[i].v2->x, lines[i].v2->y, lines[i].v1->x, lines[i].v1->y));

  00626	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0062a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00630	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00633	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00636	50		 push	 eax
  00637	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0063b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00641	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00644	8b 08		 mov	 ecx, DWORD PTR [eax]
  00646	51		 push	 ecx
  00647	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  0064b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  00650	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00654	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00657	52		 push	 edx
  00658	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0065c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00662	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00666	8b 02		 mov	 eax, DWORD PTR [edx]
  00668	50		 push	 eax
  00669	e8 00 00 00 00	 call	 _R_PointToAngle2
  0066e	83 c4 10	 add	 esp, 16			; 00000010H
  00671	50		 push	 eax
  00672	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00679	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0067f	51		 push	 ecx
  00680	69 55 ec f8 00
	00 00		 imul	 edx, DWORD PTR _sec$6[ebp], 248
  00687	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  0068d	52		 push	 edx
  0068e	e8 00 00 00 00	 call	 _P_AddCameraScanner
  00693	83 c4 0c	 add	 esp, 12			; 0000000cH
  00696	e9 6b ff ff ff	 jmp	 $LN25@P_SpawnSpe
$LN26@P_SpawnSpe:

; 5087 : 				break;

  0069b	e9 f6 1e 00 00	 jmp	 $LN20@P_SpawnSpe
$LN135@P_SpawnSpe:

; 5088 : 
; 5089 : #ifdef PARANOIA
; 5090 : 			case 6: // Disable tags if level not cleared
; 5091 : 				I_Error("Failed to catch a disable linedef");
; 5092 : 				break;
; 5093 : #endif
; 5094 : 
; 5095 : 			case 7: // Flat alignment
; 5096 : 				if (lines[i].flags & ML_EFFECT4) // Align angle

  006a0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  006a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  006aa	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  006af	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  006b5	0f 84 45 01 00
	00		 je	 $LN136@P_SpawnSpe

; 5097 : 				{
; 5098 : 					if (!(lines[i].flags & ML_EFFECT5)) // Align floor unless ALLTRIGGER flag is set

  006bb	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  006bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  006c5	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  006ca	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  006d0	0f 85 85 00 00
	00		 jne	 $LN29@P_SpawnSpe

; 5099 : 					{
; 5100 : 						for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  006d6	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN28@P_SpawnSpe:
  006dd	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  006e0	50		 push	 eax
  006e1	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  006e5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  006eb	51		 push	 ecx
  006ec	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  006f1	83 c4 08	 add	 esp, 8
  006f4	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  006f7	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  006fb	7c 5e		 jl	 SHORT $LN29@P_SpawnSpe

; 5101 : 							sectors[s].floorpic_angle = R_PointToAngle2(lines[i].v1->x, lines[i].v1->y, lines[i].v2->x, lines[i].v2->y);

  006fd	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00701	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00707	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0070b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0070e	50		 push	 eax
  0070f	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00713	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00719	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0071d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0071f	51		 push	 ecx
  00720	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  00724	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  00729	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0072c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0072f	52		 push	 edx
  00730	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00734	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0073a	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0073d	8b 02		 mov	 eax, DWORD PTR [edx]
  0073f	50		 push	 eax
  00740	e8 00 00 00 00	 call	 _R_PointToAngle2
  00745	83 c4 10	 add	 esp, 16			; 00000010H
  00748	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  0074f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00755	89 44 0a 60	 mov	 DWORD PTR [edx+ecx+96], eax
  00759	eb 82		 jmp	 SHORT $LN28@P_SpawnSpe
$LN29@P_SpawnSpe:

; 5102 : 					}
; 5103 : 
; 5104 : 					if (!(lines[i].flags & ML_BOUNCY)) // Align ceiling unless BOUNCY flag is set

  0075b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0075f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00765	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0076a	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  00770	0f 85 85 00 00
	00		 jne	 $LN32@P_SpawnSpe

; 5105 : 					{
; 5106 : 						for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  00776	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN31@P_SpawnSpe:
  0077d	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00780	50		 push	 eax
  00781	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00785	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  0078b	51		 push	 ecx
  0078c	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00791	83 c4 08	 add	 esp, 8
  00794	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00797	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  0079b	7c 5e		 jl	 SHORT $LN32@P_SpawnSpe

; 5107 : 							sectors[s].ceilingpic_angle = R_PointToAngle2(lines[i].v1->x, lines[i].v1->y, lines[i].v2->x, lines[i].v2->y);

  0079d	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  007a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  007a7	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  007ab	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  007ae	50		 push	 eax
  007af	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  007b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  007b9	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  007bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  007bf	51		 push	 ecx
  007c0	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  007c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  007c9	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  007cc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  007cf	52		 push	 edx
  007d0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  007d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  007da	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  007dd	8b 02		 mov	 eax, DWORD PTR [edx]
  007df	50		 push	 eax
  007e0	e8 00 00 00 00	 call	 _R_PointToAngle2
  007e5	83 c4 10	 add	 esp, 16			; 00000010H
  007e8	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  007ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  007f5	89 44 0a 64	 mov	 DWORD PTR [edx+ecx+100], eax
  007f9	eb 82		 jmp	 SHORT $LN31@P_SpawnSpe
$LN32@P_SpawnSpe:

; 5108 : 					}
; 5109 : 				}

  007fb	e9 48 01 00 00	 jmp	 $LN38@P_SpawnSpe
$LN136@P_SpawnSpe:

; 5110 : 				else // Do offsets
; 5111 : 				{
; 5112 : 					if (!(lines[i].flags & ML_BLOCKMONSTERS)) // Align floor unless BLOCKMONSTERS flag is set

  00800	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00804	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0080a	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0080f	83 e2 02	 and	 edx, 2
  00812	0f 85 8c 00 00
	00		 jne	 $LN35@P_SpawnSpe

; 5113 : 					{
; 5114 : 						for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  00818	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN34@P_SpawnSpe:
  0081f	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00822	50		 push	 eax
  00823	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00827	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  0082d	51		 push	 ecx
  0082e	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00833	83 c4 08	 add	 esp, 8
  00836	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00839	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  0083d	7c 65		 jl	 SHORT $LN35@P_SpawnSpe

; 5115 : 						{
; 5116 : 							sectors[s].floor_xoffs += lines[i].dx;

  0083f	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00846	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0084a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00850	8b 44 02 50	 mov	 eax, DWORD PTR [edx+eax+80]
  00854	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0085a	03 44 0a 08	 add	 eax, DWORD PTR [edx+ecx+8]
  0085e	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00865	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0086b	89 44 0a 50	 mov	 DWORD PTR [edx+ecx+80], eax

; 5117 : 							sectors[s].floor_yoffs += lines[i].dy;

  0086f	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00876	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0087a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00880	8b 44 02 54	 mov	 eax, DWORD PTR [edx+eax+84]
  00884	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0088a	03 44 0a 0c	 add	 eax, DWORD PTR [edx+ecx+12]
  0088e	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00895	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0089b	89 44 0a 54	 mov	 DWORD PTR [edx+ecx+84], eax

; 5118 : 						}

  0089f	e9 7b ff ff ff	 jmp	 $LN34@P_SpawnSpe
$LN35@P_SpawnSpe:

; 5119 : 					}
; 5120 : 
; 5121 : 					if (!(lines[i].flags & ML_NOCLIMB)) // Align ceiling unless NOCLIMB flag is set

  008a4	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  008a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  008ae	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  008b3	83 e2 40	 and	 edx, 64			; 00000040H
  008b6	0f 85 8c 00 00
	00		 jne	 $LN38@P_SpawnSpe

; 5122 : 					{
; 5123 : 						for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  008bc	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN37@P_SpawnSpe:
  008c3	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  008c6	50		 push	 eax
  008c7	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  008cb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  008d1	51		 push	 ecx
  008d2	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  008d7	83 c4 08	 add	 esp, 8
  008da	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  008dd	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  008e1	7c 65		 jl	 SHORT $LN38@P_SpawnSpe

; 5124 : 						{
; 5125 : 							sectors[s].ceiling_xoffs += lines[i].dx;

  008e3	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  008ea	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  008ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  008f4	8b 44 02 58	 mov	 eax, DWORD PTR [edx+eax+88]
  008f8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  008fe	03 44 0a 08	 add	 eax, DWORD PTR [edx+ecx+8]
  00902	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00909	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0090f	89 44 0a 58	 mov	 DWORD PTR [edx+ecx+88], eax

; 5126 : 							sectors[s].ceiling_yoffs += lines[i].dy;

  00913	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  0091a	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0091e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00924	8b 44 02 5c	 mov	 eax, DWORD PTR [edx+eax+92]
  00928	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0092e	03 44 0a 0c	 add	 eax, DWORD PTR [edx+ecx+12]
  00932	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00939	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0093f	89 44 0a 5c	 mov	 DWORD PTR [edx+ecx+92], eax

; 5127 : 						}

  00943	e9 7b ff ff ff	 jmp	 $LN37@P_SpawnSpe
$LN38@P_SpawnSpe:

; 5128 : 					}
; 5129 : 				}
; 5130 : 				break;

  00948	e9 49 1c 00 00	 jmp	 $LN20@P_SpawnSpe
$LN142@P_SpawnSpe:

; 5131 : 
; 5132 : 			case 8: // Sector Parameters
; 5133 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  0094d	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN40@P_SpawnSpe:
  00954	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00957	50		 push	 eax
  00958	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0095c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00962	51		 push	 ecx
  00963	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00968	83 c4 08	 add	 esp, 8
  0096b	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  0096e	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  00972	0f 8c f5 00 00
	00		 jl	 $LN41@P_SpawnSpe

; 5134 : 				{
; 5135 : 					if (lines[i].flags & ML_NOCLIMB)

  00978	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0097c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00982	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00987	83 e2 40	 and	 edx, 64			; 00000040H
  0098a	74 58		 je	 SHORT $LN143@P_SpawnSpe

; 5136 : 					{
; 5137 : 						sectors[s].flags &= ~SF_FLIPSPECIAL_FLOOR;

  0098c	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00993	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00999	8b 94 01 e0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+224]
  009a0	83 e2 fe	 and	 edx, -2			; fffffffeH
  009a3	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  009aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  009b0	89 94 01 e0 00
	00 00		 mov	 DWORD PTR [ecx+eax+224], edx

; 5138 : 						sectors[s].flags |= SF_FLIPSPECIAL_CEILING;

  009b7	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  009be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  009c4	8b 94 01 e0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+224]
  009cb	83 ca 02	 or	 edx, 2
  009ce	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  009d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  009db	89 94 01 e0 00
	00 00		 mov	 DWORD PTR [ecx+eax+224], edx

; 5139 : 					}

  009e2	eb 42		 jmp	 SHORT $LN145@P_SpawnSpe
$LN143@P_SpawnSpe:

; 5140 : 					else if (lines[i].flags & ML_EFFECT4)

  009e4	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  009e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  009ee	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  009f3	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  009f9	74 2b		 je	 SHORT $LN145@P_SpawnSpe

; 5141 : 						sectors[s].flags |= SF_FLIPSPECIAL_BOTH;

  009fb	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00a02	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00a08	8b 94 01 e0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+224]
  00a0f	83 ca 03	 or	 edx, 3
  00a12	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00a19	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00a1f	89 94 01 e0 00
	00 00		 mov	 DWORD PTR [ecx+eax+224], edx
$LN145@P_SpawnSpe:

; 5142 : 
; 5143 : 					if (lines[i].flags & ML_EFFECT3)

  00a26	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00a2a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00a30	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00a35	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00a3b	74 2b		 je	 SHORT $LN146@P_SpawnSpe

; 5144 : 						sectors[s].flags |= SF_TRIGGERSPECIAL_TOUCH;

  00a3d	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00a44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00a4a	8b 94 01 e0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+224]
  00a51	83 ca 04	 or	 edx, 4
  00a54	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00a5b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00a61	89 94 01 e0 00
	00 00		 mov	 DWORD PTR [ecx+eax+224], edx
$LN146@P_SpawnSpe:

; 5145 : 				}

  00a68	e9 e7 fe ff ff	 jmp	 $LN40@P_SpawnSpe
$LN41@P_SpawnSpe:

; 5146 : 				break;

  00a6d	e9 24 1b 00 00	 jmp	 $LN20@P_SpawnSpe

; 5147 : 
; 5148 : 			case 9: // Chain Parameters
; 5149 : 				break;

  00a72	e9 1f 1b 00 00	 jmp	 $LN20@P_SpawnSpe
$LN148@P_SpawnSpe:

; 5150 : 
; 5151 : 			case 10: // Vertical culling plane for sprites and FOFs
; 5152 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  00a77	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00a7b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00a81	b9 02 00 00 00	 mov	 ecx, 2
  00a86	6b d1 00	 imul	 edx, ecx, 0
  00a89	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  00a8e	6b c8 1c	 imul	 ecx, eax, 28
  00a91	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00a97	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  00a9b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00aa1	99		 cdq
  00aa2	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00aa7	f7 f9		 idiv	 ecx
  00aa9	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5153 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  00aac	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN43@P_SpawnSpe:
  00ab3	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00ab6	50		 push	 eax
  00ab7	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00abb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00ac1	51		 push	 ecx
  00ac2	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00ac7	83 c4 08	 add	 esp, 8
  00aca	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00acd	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  00ad1	7c 20		 jl	 SHORT $LN44@P_SpawnSpe

; 5154 : 					sectors[s].cullheight = &lines[i]; // This allows it to change in realtime!

  00ad3	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00ad7	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00add	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  00ae4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00aea	89 84 0a e4 00
	00 00		 mov	 DWORD PTR [edx+ecx+228], eax
  00af1	eb c0		 jmp	 SHORT $LN43@P_SpawnSpe
$LN44@P_SpawnSpe:

; 5155 : 				break;

  00af3	e9 9e 1a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN149@P_SpawnSpe:

; 5156 : 
; 5157 : 			case 50: // Insta-Lower Sector
; 5158 : 				EV_DoFloor(&lines[i], instantLower);

  00af8	6a 02		 push	 2
  00afa	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00afe	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00b04	50		 push	 eax
  00b05	e8 00 00 00 00	 call	 _EV_DoFloor
  00b0a	83 c4 08	 add	 esp, 8

; 5159 : 				break;

  00b0d	e9 84 1a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN150@P_SpawnSpe:

; 5160 : 
; 5161 : 			case 51: // Instant raise for ceilings
; 5162 : 				EV_DoCeiling(&lines[i], instantRaise);

  00b12	6a 04		 push	 4
  00b14	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b18	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00b1e	50		 push	 eax
  00b1f	e8 00 00 00 00	 call	 _EV_DoCeiling
  00b24	83 c4 08	 add	 esp, 8

; 5163 : 				break;

  00b27	e9 6a 1a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN151@P_SpawnSpe:

; 5164 : 
; 5165 : 			case 52: // Continuously Falling sector
; 5166 : 				EV_DoContinuousFall(lines[i].frontsector, lines[i].backsector, P_AproxDistance(lines[i].dx, lines[i].dy), (lines[i].flags & ML_NOCLIMB));

  00b2c	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00b36	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00b3b	83 e2 40	 and	 edx, 64			; 00000040H
  00b3e	52		 push	 edx
  00b3f	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b43	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00b49	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00b4d	52		 push	 edx
  00b4e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00b58	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00b5c	52		 push	 edx
  00b5d	e8 00 00 00 00	 call	 _P_AproxDistance
  00b62	83 c4 08	 add	 esp, 8
  00b65	50		 push	 eax
  00b66	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00b70	8b 54 01 34	 mov	 edx, DWORD PTR [ecx+eax+52]
  00b74	52		 push	 edx
  00b75	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b79	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00b7f	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00b83	52		 push	 edx
  00b84	e8 00 00 00 00	 call	 _EV_DoContinuousFall
  00b89	83 c4 10	 add	 esp, 16			; 00000010H

; 5167 : 				break;

  00b8c	e9 05 1a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN152@P_SpawnSpe:

; 5168 : 
; 5169 : 			case 53: // New super cool and awesome moving floor and ceiling type
; 5170 : 			case 54: // New super cool and awesome moving floor type
; 5171 : 				if (lines[i].backsector)

  00b91	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00b95	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00b9b	83 7c 01 34 00	 cmp	 DWORD PTR [ecx+eax+52], 0
  00ba0	74 15		 je	 SHORT $LN154@P_SpawnSpe

; 5172 : 					EV_DoFloor(&lines[i], bounceFloor);

  00ba2	6a 07		 push	 7
  00ba4	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00ba8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00bae	50		 push	 eax
  00baf	e8 00 00 00 00	 call	 _EV_DoFloor
  00bb4	83 c4 08	 add	 esp, 8
$LN154@P_SpawnSpe:

; 5173 : 				if (lines[i].special == 54)

  00bb7	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00bbb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00bc1	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  00bc6	83 fa 36	 cmp	 edx, 54			; 00000036H
  00bc9	75 05		 jne	 SHORT $LN155@P_SpawnSpe

; 5174 : 					break;

  00bcb	e9 c6 19 00 00	 jmp	 $LN20@P_SpawnSpe
$LN155@P_SpawnSpe:

; 5175 : 			case 55: // New super cool and awesome moving ceiling type
; 5176 : 				if (lines[i].backsector)

  00bd0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00bd4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00bda	83 7c 01 34 00	 cmp	 DWORD PTR [ecx+eax+52], 0
  00bdf	74 15		 je	 SHORT $LN157@P_SpawnSpe

; 5177 : 					EV_DoCeiling(&lines[i], bounceCeiling);

  00be1	6a 0e		 push	 14			; 0000000eH
  00be3	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00be7	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00bed	50		 push	 eax
  00bee	e8 00 00 00 00	 call	 _EV_DoCeiling
  00bf3	83 c4 08	 add	 esp, 8
$LN157@P_SpawnSpe:

; 5178 : 				break;

  00bf6	e9 9b 19 00 00	 jmp	 $LN20@P_SpawnSpe
$LN158@P_SpawnSpe:

; 5179 : 
; 5180 : 			case 56: // New super cool and awesome moving floor and ceiling crush type
; 5181 : 			case 57: // New super cool and awesome moving floor crush type
; 5182 : 				if (lines[i].backsector)

  00bfb	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00bff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00c05	83 7c 01 34 00	 cmp	 DWORD PTR [ecx+eax+52], 0
  00c0a	74 15		 je	 SHORT $LN160@P_SpawnSpe

; 5183 : 					EV_DoFloor(&lines[i], bounceFloorCrush);

  00c0c	6a 08		 push	 8
  00c0e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00c12	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00c18	50		 push	 eax
  00c19	e8 00 00 00 00	 call	 _EV_DoFloor
  00c1e	83 c4 08	 add	 esp, 8
$LN160@P_SpawnSpe:

; 5184 : 
; 5185 : 			case 58: // New super cool and awesome moving ceiling crush type
; 5186 : 				if (lines[i].backsector)

  00c21	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00c25	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00c2b	83 7c 01 34 00	 cmp	 DWORD PTR [ecx+eax+52], 0
  00c30	74 15		 je	 SHORT $LN162@P_SpawnSpe

; 5187 : 					EV_DoCeiling(&lines[i], bounceCeilingCrush);

  00c32	6a 0f		 push	 15			; 0000000fH
  00c34	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00c38	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00c3e	50		 push	 eax
  00c3f	e8 00 00 00 00	 call	 _EV_DoCeiling
  00c44	83 c4 08	 add	 esp, 8
$LN162@P_SpawnSpe:

; 5188 : 				break;

  00c47	e9 4a 19 00 00	 jmp	 $LN20@P_SpawnSpe
$LN163@P_SpawnSpe:

; 5189 : 
; 5190 : 			case 59: // Activate floating platform
; 5191 : 				EV_DoElevator(&lines[i], elevateContinuous, false);

  00c4c	6a 00		 push	 0
  00c4e	6a 03		 push	 3
  00c50	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00c54	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00c5a	50		 push	 eax
  00c5b	e8 00 00 00 00	 call	 _EV_DoElevator
  00c60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5192 : 				break;

  00c63	e9 2e 19 00 00	 jmp	 $LN20@P_SpawnSpe
$LN164@P_SpawnSpe:

; 5193 : 
; 5194 : 			case 60: // Floating platform with adjustable speed
; 5195 : 				EV_DoElevator(&lines[i], elevateContinuous, true);

  00c68	6a 01		 push	 1
  00c6a	6a 03		 push	 3
  00c6c	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00c70	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00c76	50		 push	 eax
  00c77	e8 00 00 00 00	 call	 _EV_DoElevator
  00c7c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5196 : 				break;

  00c7f	e9 12 19 00 00	 jmp	 $LN20@P_SpawnSpe
$LN165@P_SpawnSpe:

; 5197 : 
; 5198 : 			case 61: // Crusher!
; 5199 : 				EV_DoCrush(&lines[i], crushAndRaise);

  00c84	6a 06		 push	 6
  00c86	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00c8a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00c90	50		 push	 eax
  00c91	e8 00 00 00 00	 call	 _EV_DoCrush
  00c96	83 c4 08	 add	 esp, 8

; 5200 : 				break;

  00c99	e9 f8 18 00 00	 jmp	 $LN20@P_SpawnSpe
$LN166@P_SpawnSpe:

; 5201 : 
; 5202 : 			case 62: // Crusher (up and then down)!
; 5203 : 				EV_DoCrush(&lines[i], fastCrushAndRaise);

  00c9e	6a 07		 push	 7
  00ca0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00ca4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00caa	50		 push	 eax
  00cab	e8 00 00 00 00	 call	 _EV_DoCrush
  00cb0	83 c4 08	 add	 esp, 8

; 5204 : 				break;

  00cb3	e9 de 18 00 00	 jmp	 $LN20@P_SpawnSpe
$LN167@P_SpawnSpe:

; 5205 : 
; 5206 : 			case 63: // support for drawn heights coming from different sector
; 5207 : 				sec = sides[*lines[i].sidenum].sector-sectors;

  00cb8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00cbc	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00cc2	b9 02 00 00 00	 mov	 ecx, 2
  00cc7	6b d1 00	 imul	 edx, ecx, 0
  00cca	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  00ccf	6b c8 1c	 imul	 ecx, eax, 28
  00cd2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00cd8	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  00cdc	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  00ce2	99		 cdq
  00ce3	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  00ce8	f7 f9		 idiv	 ecx
  00cea	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5208 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  00ced	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN46@P_SpawnSpe:
  00cf4	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00cf7	50		 push	 eax
  00cf8	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00cfc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00d02	51		 push	 ecx
  00d03	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  00d08	83 c4 08	 add	 esp, 8
  00d0b	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00d0e	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  00d12	7c 16		 jl	 SHORT $LN47@P_SpawnSpe

; 5209 : 					sectors[s].heightsec = (INT32)sec;

  00d14	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  00d1b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00d21	8b 55 ec	 mov	 edx, DWORD PTR _sec$6[ebp]
  00d24	89 54 01 68	 mov	 DWORD PTR [ecx+eax+104], edx
  00d28	eb ca		 jmp	 SHORT $LN46@P_SpawnSpe
$LN47@P_SpawnSpe:

; 5210 : 				break;

  00d2a	e9 67 18 00 00	 jmp	 $LN20@P_SpawnSpe
$LN168@P_SpawnSpe:

; 5211 : 
; 5212 : 			case 64: // Appearing/Disappearing FOF option
; 5213 : 				for (s = -1; (s = P_FindLineFromLineTag(&lines[i], s)) >= 0 ;)

  00d2f	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN49@P_SpawnSpe:
  00d36	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00d39	50		 push	 eax
  00d3a	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00d3e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  00d44	51		 push	 ecx
  00d45	e8 00 00 00 00	 call	 _P_FindLineFromLineTag
  00d4a	83 c4 08	 add	 esp, 8
  00d4d	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  00d50	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  00d54	0f 8c dc 00 00
	00		 jl	 $LN50@P_SpawnSpe

; 5214 : 				{
; 5215 : 					if ((size_t)s == i)

  00d5a	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  00d5d	3b 45 f8	 cmp	 eax, DWORD PTR _i$[ebp]
  00d60	75 02		 jne	 SHORT $LN169@P_SpawnSpe

; 5216 : 						continue;

  00d62	eb d2		 jmp	 SHORT $LN49@P_SpawnSpe
$LN169@P_SpawnSpe:

; 5217 : 
; 5218 : 					if (sides[lines[s].sidenum[0]].sector->tag == sides[lines[i].sidenum[0]].sector->tag)

  00d64	6b 45 f0 4c	 imul	 eax, DWORD PTR _s$7[ebp], 76
  00d68	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  00d6e	b9 02 00 00 00	 mov	 ecx, 2
  00d73	6b d1 00	 imul	 edx, ecx, 0
  00d76	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  00d7b	6b c8 1c	 imul	 ecx, eax, 28
  00d7e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00d84	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  00d88	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00d8c	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  00d90	03 15 00 00 00
	00		 add	 edx, DWORD PTR _lines
  00d96	b8 02 00 00 00	 mov	 eax, 2
  00d9b	6b c0 00	 imul	 eax, eax, 0
  00d9e	0f b7 54 02 16	 movzx	 edx, WORD PTR [edx+eax+22]
  00da3	6b c2 1c	 imul	 eax, edx, 28
  00da6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00dac	8b 44 02 14	 mov	 eax, DWORD PTR [edx+eax+20]
  00db0	0f bf 50 14	 movsx	 edx, WORD PTR [eax+20]
  00db4	3b ca		 cmp	 ecx, edx
  00db6	75 79		 jne	 SHORT $LN170@P_SpawnSpe

; 5219 : 						Add_MasterDisappearer(abs(lines[i].dx>>FRACBITS), abs(lines[i].dy>>FRACBITS), abs(sides[lines[i].sidenum[0]].sector->floorheight>>FRACBITS), s, (INT32)i);

  00db8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00dbb	50		 push	 eax
  00dbc	8b 4d f0	 mov	 ecx, DWORD PTR _s$7[ebp]
  00dbf	51		 push	 ecx
  00dc0	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  00dc4	03 15 00 00 00
	00		 add	 edx, DWORD PTR _lines
  00dca	b8 02 00 00 00	 mov	 eax, 2
  00dcf	6b c8 00	 imul	 ecx, eax, 0
  00dd2	0f b7 54 0a 16	 movzx	 edx, WORD PTR [edx+ecx+22]
  00dd7	6b c2 1c	 imul	 eax, edx, 28
  00dda	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sides
  00de0	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00de4	8b 02		 mov	 eax, DWORD PTR [edx]
  00de6	c1 f8 10	 sar	 eax, 16			; 00000010H
  00de9	50		 push	 eax
  00dea	e8 00 00 00 00	 call	 _abs
  00def	83 c4 04	 add	 esp, 4
  00df2	50		 push	 eax
  00df3	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00df7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00dfd	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00e01	c1 f8 10	 sar	 eax, 16			; 00000010H
  00e04	50		 push	 eax
  00e05	e8 00 00 00 00	 call	 _abs
  00e0a	83 c4 04	 add	 esp, 4
  00e0d	50		 push	 eax
  00e0e	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  00e12	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  00e18	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  00e1c	c1 f8 10	 sar	 eax, 16			; 00000010H
  00e1f	50		 push	 eax
  00e20	e8 00 00 00 00	 call	 _abs
  00e25	83 c4 04	 add	 esp, 4
  00e28	50		 push	 eax
  00e29	e8 00 00 00 00	 call	 _Add_MasterDisappearer
  00e2e	83 c4 14	 add	 esp, 20			; 00000014H
$LN170@P_SpawnSpe:

; 5220 : 				}

  00e31	e9 00 ff ff ff	 jmp	 $LN49@P_SpawnSpe
$LN50@P_SpawnSpe:

; 5221 : 				break;

  00e36	e9 5b 17 00 00	 jmp	 $LN20@P_SpawnSpe

; 5222 : 
; 5223 : 			case 65: // Bridge Thinker
; 5224 : 				/*
; 5225 : 				// Disable this until it's working right!
; 5226 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)
; 5227 : 					P_AddBridgeThinker(&lines[i], &sectors[s]);*/
; 5228 : 				break;

  00e3b	e9 56 17 00 00	 jmp	 $LN20@P_SpawnSpe
$LN172@P_SpawnSpe:

; 5229 : 
; 5230 : 			case 100: // FOF (solid, opaque, shadows)
; 5231 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL);

  00e40	68 9f 01 00 00	 push	 415			; 0000019fH
  00e45	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e48	50		 push	 eax
  00e49	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00e4e	83 c4 08	 add	 esp, 8

; 5232 : 				break;

  00e51	e9 40 17 00 00	 jmp	 $LN20@P_SpawnSpe
$LN173@P_SpawnSpe:

; 5233 : 
; 5234 : 			case 101: // FOF (solid, opaque, no shadows)
; 5235 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_NOSHADE|FF_CUTLEVEL);

  00e56	68 df 01 00 00	 push	 479			; 000001dfH
  00e5b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e5e	50		 push	 eax
  00e5f	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00e64	83 c4 08	 add	 esp, 8

; 5236 : 				break;

  00e67	e9 2a 17 00 00	 jmp	 $LN20@P_SpawnSpe
$LN174@P_SpawnSpe:

; 5237 : 
; 5238 : 			case 102: // TL block: FOF (solid, translucent)
; 5239 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_NOSHADE|FF_TRANSLUCENT|FF_EXTRA|FF_CUTEXTRA;

  00e6c	c7 45 e8 5f 19
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 6495 ; 0000195fH

; 5240 : 
; 5241 : 				// Draw the 'insides' of the block too
; 5242 : 				if (lines[i].flags & ML_NOCLIMB)

  00e73	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00e77	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00e7d	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00e82	83 e2 40	 and	 edx, 64			; 00000040H
  00e85	74 37		 je	 SHORT $LN175@P_SpawnSpe

; 5243 : 				{
; 5244 : 					ffloorflags |= FF_CUTLEVEL;

  00e87	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00e8a	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  00e8f	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5245 : 					ffloorflags |= FF_BOTHPLANES;

  00e92	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00e95	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  00e9a	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5246 : 					ffloorflags |= FF_ALLSIDES;

  00e9d	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00ea0	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00ea5	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5247 : 					ffloorflags &= ~FF_EXTRA;

  00ea8	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00eab	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  00eb0	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5248 : 					ffloorflags &= ~FF_CUTEXTRA;

  00eb3	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00eb6	25 ff fe ff ff	 and	 eax, -257		; fffffeffH
  00ebb	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN175@P_SpawnSpe:

; 5249 : 				}
; 5250 : 
; 5251 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  00ebe	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00ec1	50		 push	 eax
  00ec2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00ec5	51		 push	 ecx
  00ec6	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00ecb	83 c4 08	 add	 esp, 8

; 5252 : 				break;

  00ece	e9 c3 16 00 00	 jmp	 $LN20@P_SpawnSpe
$LN176@P_SpawnSpe:

; 5253 : 
; 5254 : 			case 103: // Solid FOF with no floor/ceiling (quite possibly useless)
; 5255 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERSIDES|FF_NOSHADE|FF_CUTLEVEL);

  00ed3	68 cf 01 00 00	 push	 463			; 000001cfH
  00ed8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00edb	50		 push	 eax
  00edc	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00ee1	83 c4 08	 add	 esp, 8

; 5256 : 				break;

  00ee4	e9 ad 16 00 00	 jmp	 $LN20@P_SpawnSpe
$LN177@P_SpawnSpe:

; 5257 : 
; 5258 : 			case 104: // 3D Floor type that doesn't draw sides
; 5259 : 				// If line has no-climb set, give it shadows, otherwise don't
; 5260 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERPLANES|FF_CUTLEVEL;

  00ee9	c7 45 e8 97 01
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 407 ; 00000197H

; 5261 : 				if (!(lines[i].flags & ML_NOCLIMB))

  00ef0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00ef4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00efa	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00eff	83 e2 40	 and	 edx, 64			; 00000040H
  00f02	75 09		 jne	 SHORT $LN178@P_SpawnSpe

; 5262 : 					ffloorflags |= FF_NOSHADE;

  00f04	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00f07	83 c8 40	 or	 eax, 64			; 00000040H
  00f0a	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN178@P_SpawnSpe:

; 5263 : 
; 5264 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  00f0d	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00f10	50		 push	 eax
  00f11	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00f14	51		 push	 ecx
  00f15	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00f1a	83 c4 08	 add	 esp, 8

; 5265 : 				break;

  00f1d	e9 74 16 00 00	 jmp	 $LN20@P_SpawnSpe
$LN179@P_SpawnSpe:

; 5266 : 
; 5267 : 			case 105: // FOF (solid, invisible)
; 5268 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_NOSHADE);

  00f22	6a 47		 push	 71			; 00000047H
  00f24	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00f27	50		 push	 eax
  00f28	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00f2d	83 c4 08	 add	 esp, 8

; 5269 : 				break;

  00f30	e9 61 16 00 00	 jmp	 $LN20@P_SpawnSpe
$LN180@P_SpawnSpe:

; 5270 : 
; 5271 : 			case 120: // Opaque water
; 5272 : 				ffloorflags = FF_EXISTS|FF_RENDERALL|FF_SWIMMABLE|FF_BOTHPLANES|FF_ALLSIDES|FF_CUTEXTRA|FF_EXTRA|FF_CUTSPRITES;

  00f35	c7 45 e8 39 8f
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 36665 ; 00008f39H

; 5273 : 				if (lines[i].flags & ML_NOCLIMB)

  00f3c	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00f40	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00f46	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00f4b	83 e2 40	 and	 edx, 64			; 00000040H
  00f4e	74 0b		 je	 SHORT $LN181@P_SpawnSpe

; 5274 : 					ffloorflags |= FF_DOUBLESHADOW;

  00f50	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00f53	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  00f58	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN181@P_SpawnSpe:

; 5275 : 				if (lines[i].flags & ML_EFFECT4)

  00f5b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00f5f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00f65	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00f6a	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00f70	74 0b		 je	 SHORT $LN182@P_SpawnSpe

; 5276 : 					ffloorflags |= FF_COLORMAPONLY;

  00f72	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00f75	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  00f7a	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN182@P_SpawnSpe:

; 5277 : 				if (lines[i].flags & ML_EFFECT5)

  00f7d	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00f81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00f87	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00f8c	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  00f92	74 0b		 je	 SHORT $LN183@P_SpawnSpe

; 5278 : 					ffloorflags |= FF_RIPPLE;

  00f94	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00f97	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  00f9c	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN183@P_SpawnSpe:

; 5279 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  00f9f	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00fa2	50		 push	 eax
  00fa3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00fa6	51		 push	 ecx
  00fa7	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  00fac	83 c4 08	 add	 esp, 8

; 5280 : 				break;

  00faf	e9 e2 15 00 00	 jmp	 $LN20@P_SpawnSpe
$LN184@P_SpawnSpe:

; 5281 : 
; 5282 : 			case 121: // TL water
; 5283 : 				ffloorflags = FF_EXISTS|FF_RENDERALL|FF_TRANSLUCENT|FF_SWIMMABLE|FF_BOTHPLANES|FF_ALLSIDES|FF_CUTEXTRA|FF_EXTRA|FF_CUTSPRITES;

  00fb4	c7 45 e8 39 9f
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 40761 ; 00009f39H

; 5284 : 				if (lines[i].flags & ML_NOCLIMB)

  00fbb	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00fbf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00fc5	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00fca	83 e2 40	 and	 edx, 64			; 00000040H
  00fcd	74 0b		 je	 SHORT $LN185@P_SpawnSpe

; 5285 : 					ffloorflags |= FF_DOUBLESHADOW;

  00fcf	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00fd2	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  00fd7	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN185@P_SpawnSpe:

; 5286 : 				if (lines[i].flags & ML_EFFECT4)

  00fda	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00fde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00fe4	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  00fe9	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00fef	74 0b		 je	 SHORT $LN186@P_SpawnSpe

; 5287 : 					ffloorflags |= FF_COLORMAPONLY;

  00ff1	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  00ff4	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  00ff9	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN186@P_SpawnSpe:

; 5288 : 				if (lines[i].flags & ML_EFFECT5)

  00ffc	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01006	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0100b	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  01011	74 0b		 je	 SHORT $LN187@P_SpawnSpe

; 5289 : 					ffloorflags |= FF_RIPPLE;

  01013	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01016	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  0101b	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN187@P_SpawnSpe:

; 5290 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  0101e	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01021	50		 push	 eax
  01022	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01025	51		 push	 ecx
  01026	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  0102b	83 c4 08	 add	 esp, 8

; 5291 : 				break;

  0102e	e9 63 15 00 00	 jmp	 $LN20@P_SpawnSpe
$LN188@P_SpawnSpe:

; 5292 : 
; 5293 : 			case 122: // Opaque water, no sides
; 5294 : 				ffloorflags = FF_EXISTS|FF_RENDERPLANES|FF_SWIMMABLE|FF_BOTHPLANES|FF_CUTEXTRA|FF_EXTRA|FF_CUTSPRITES;

  01033	c7 45 e8 31 0f
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 3889 ; 00000f31H

; 5295 : 				if (lines[i].flags & ML_NOCLIMB)

  0103a	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0103e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01044	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01049	83 e2 40	 and	 edx, 64			; 00000040H
  0104c	74 0b		 je	 SHORT $LN189@P_SpawnSpe

; 5296 : 					ffloorflags |= FF_DOUBLESHADOW;

  0104e	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01051	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  01056	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN189@P_SpawnSpe:

; 5297 : 				if (lines[i].flags & ML_EFFECT4)

  01059	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0105d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01063	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01068	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  0106e	74 0b		 je	 SHORT $LN190@P_SpawnSpe

; 5298 : 					ffloorflags |= FF_COLORMAPONLY;

  01070	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01073	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  01078	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN190@P_SpawnSpe:

; 5299 : 				if (lines[i].flags & ML_EFFECT5)

  0107b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0107f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01085	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0108a	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  01090	74 0b		 je	 SHORT $LN191@P_SpawnSpe

; 5300 : 					ffloorflags |= FF_RIPPLE;

  01092	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01095	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  0109a	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN191@P_SpawnSpe:

; 5301 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  0109d	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  010a0	50		 push	 eax
  010a1	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  010a4	51		 push	 ecx
  010a5	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  010aa	83 c4 08	 add	 esp, 8

; 5302 : 				break;

  010ad	e9 e4 14 00 00	 jmp	 $LN20@P_SpawnSpe
$LN192@P_SpawnSpe:

; 5303 : 
; 5304 : 			case 123: // TL water, no sides
; 5305 : 				ffloorflags = FF_EXISTS|FF_RENDERPLANES|FF_TRANSLUCENT|FF_SWIMMABLE|FF_BOTHPLANES|FF_CUTEXTRA|FF_EXTRA|FF_CUTSPRITES;

  010b2	c7 45 e8 31 1f
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 7985 ; 00001f31H

; 5306 : 				if (lines[i].flags & ML_NOCLIMB)

  010b9	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  010bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  010c3	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  010c8	83 e2 40	 and	 edx, 64			; 00000040H
  010cb	74 0b		 je	 SHORT $LN193@P_SpawnSpe

; 5307 : 					ffloorflags |= FF_DOUBLESHADOW;

  010cd	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  010d0	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  010d5	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN193@P_SpawnSpe:

; 5308 : 				if (lines[i].flags & ML_EFFECT4)

  010d8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  010dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  010e2	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  010e7	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  010ed	74 0b		 je	 SHORT $LN194@P_SpawnSpe

; 5309 : 					ffloorflags |= FF_COLORMAPONLY;

  010ef	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  010f2	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  010f7	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN194@P_SpawnSpe:

; 5310 : 				if (lines[i].flags & ML_EFFECT5)

  010fa	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  010fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01104	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01109	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  0110f	74 0b		 je	 SHORT $LN195@P_SpawnSpe

; 5311 : 					ffloorflags |= FF_RIPPLE;

  01111	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01114	0d 00 00 00 40	 or	 eax, 1073741824		; 40000000H
  01119	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN195@P_SpawnSpe:

; 5312 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  0111c	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0111f	50		 push	 eax
  01120	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01123	51		 push	 ecx
  01124	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01129	83 c4 08	 add	 esp, 8

; 5313 : 				break;

  0112c	e9 65 14 00 00	 jmp	 $LN20@P_SpawnSpe
$LN196@P_SpawnSpe:

; 5314 : 
; 5315 : 			case 140: // 'Platform' - You can jump up through it
; 5316 : 				// If line has no-climb set, don't give it shadows, otherwise do
; 5317 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_PLATFORM|FF_BOTHPLANES|FF_ALLSIDES;

  01131	c7 45 e8 1f 84
	00 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 33588255 ; 0200841fH

; 5318 : 				if (lines[i].flags & ML_NOCLIMB)

  01138	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0113c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01142	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01147	83 e2 40	 and	 edx, 64			; 00000040H
  0114a	74 09		 je	 SHORT $LN197@P_SpawnSpe

; 5319 : 					ffloorflags |= FF_NOSHADE;

  0114c	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0114f	83 c8 40	 or	 eax, 64			; 00000040H
  01152	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN197@P_SpawnSpe:

; 5320 : 
; 5321 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01155	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01158	50		 push	 eax
  01159	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0115c	51		 push	 ecx
  0115d	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01162	83 c4 08	 add	 esp, 8

; 5322 : 				break;

  01165	e9 2c 14 00 00	 jmp	 $LN20@P_SpawnSpe
$LN198@P_SpawnSpe:

; 5323 : 
; 5324 : 			case 141: // Translucent "platform"
; 5325 : 				// If line has no-climb set, don't give it shadows, otherwise do
; 5326 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_PLATFORM|FF_TRANSLUCENT|FF_EXTRA|FF_CUTEXTRA;

  0116a	c7 45 e8 1f 19
	00 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 33560863 ; 0200191fH

; 5327 : 				if (lines[i].flags & ML_NOCLIMB)

  01171	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01175	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0117b	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01180	83 e2 40	 and	 edx, 64			; 00000040H
  01183	74 09		 je	 SHORT $LN199@P_SpawnSpe

; 5328 : 					ffloorflags |= FF_NOSHADE;

  01185	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01188	83 c8 40	 or	 eax, 64			; 00000040H
  0118b	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN199@P_SpawnSpe:

; 5329 : 
; 5330 : 				// Draw the 'insides' of the block too
; 5331 : 				if (lines[i].flags & ML_EFFECT2)

  0118e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01192	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01198	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0119d	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  011a3	74 37		 je	 SHORT $LN200@P_SpawnSpe

; 5332 : 				{
; 5333 : 					ffloorflags |= FF_CUTLEVEL;

  011a5	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  011a8	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  011ad	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5334 : 					ffloorflags |= FF_BOTHPLANES;

  011b0	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  011b3	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  011b8	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5335 : 					ffloorflags |= FF_ALLSIDES;

  011bb	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  011be	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  011c3	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5336 : 					ffloorflags &= ~FF_EXTRA;

  011c6	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  011c9	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  011ce	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5337 : 					ffloorflags &= ~FF_CUTEXTRA;

  011d1	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  011d4	25 ff fe ff ff	 and	 eax, -257		; fffffeffH
  011d9	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN200@P_SpawnSpe:

; 5338 : 				}
; 5339 : 
; 5340 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  011dc	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  011df	50		 push	 eax
  011e0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  011e3	51		 push	 ecx
  011e4	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  011e9	83 c4 08	 add	 esp, 8

; 5341 : 				break;

  011ec	e9 a5 13 00 00	 jmp	 $LN20@P_SpawnSpe
$LN201@P_SpawnSpe:

; 5342 : 
; 5343 : 			case 142: // Translucent "platform" with no sides
; 5344 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERPLANES|FF_TRANSLUCENT|FF_PLATFORM|FF_EXTRA|FF_CUTEXTRA;

  011f1	c7 45 e8 17 19
	00 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 33560855 ; 02001917H

; 5345 : 				if (lines[i].flags & ML_NOCLIMB) // shade it unless no-climb

  011f8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  011fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01202	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01207	83 e2 40	 and	 edx, 64			; 00000040H
  0120a	74 09		 je	 SHORT $LN202@P_SpawnSpe

; 5346 : 					ffloorflags |= FF_NOSHADE;

  0120c	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0120f	83 c8 40	 or	 eax, 64			; 00000040H
  01212	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN202@P_SpawnSpe:

; 5347 : 
; 5348 : 				// Draw the 'insides' of the block too
; 5349 : 				if (lines[i].flags & ML_EFFECT2)

  01215	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0121f	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01224	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0122a	74 37		 je	 SHORT $LN203@P_SpawnSpe

; 5350 : 				{
; 5351 : 					ffloorflags |= FF_CUTLEVEL;

  0122c	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0122f	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  01234	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5352 : 					ffloorflags |= FF_BOTHPLANES;

  01237	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0123a	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  0123f	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5353 : 					ffloorflags |= FF_ALLSIDES;

  01242	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01245	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  0124a	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5354 : 					ffloorflags &= ~FF_EXTRA;

  0124d	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01250	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  01255	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5355 : 					ffloorflags &= ~FF_CUTEXTRA;

  01258	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0125b	25 ff fe ff ff	 and	 eax, -257		; fffffeffH
  01260	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN203@P_SpawnSpe:

; 5356 : 				}
; 5357 : 
; 5358 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01263	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01266	50		 push	 eax
  01267	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0126a	51		 push	 ecx
  0126b	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01270	83 c4 08	 add	 esp, 8

; 5359 : 				break;

  01273	e9 1e 13 00 00	 jmp	 $LN20@P_SpawnSpe
$LN204@P_SpawnSpe:

; 5360 : 
; 5361 : 			case 143: // 'Reverse platform' - You fall through it
; 5362 : 				// If line has no-climb set, don't give it shadows, otherwise do
; 5363 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_REVERSEPLATFORM|FF_BOTHPLANES|FF_ALLSIDES;

  01278	c7 45 e8 1f 84
	00 04		 mov	 DWORD PTR _ffloorflags$5[ebp], 67142687 ; 0400841fH

; 5364 : 				if (lines[i].flags & ML_NOCLIMB)

  0127f	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01289	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0128e	83 e2 40	 and	 edx, 64			; 00000040H
  01291	74 09		 je	 SHORT $LN205@P_SpawnSpe

; 5365 : 					ffloorflags |= FF_NOSHADE;

  01293	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01296	83 c8 40	 or	 eax, 64			; 00000040H
  01299	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN205@P_SpawnSpe:

; 5366 : 
; 5367 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  0129c	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0129f	50		 push	 eax
  012a0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  012a3	51		 push	 ecx
  012a4	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  012a9	83 c4 08	 add	 esp, 8

; 5368 : 				break;

  012ac	e9 e5 12 00 00	 jmp	 $LN20@P_SpawnSpe
$LN206@P_SpawnSpe:

; 5369 : 
; 5370 : 			case 144: // Translucent "reverse platform"
; 5371 : 				// If line has no-climb set, don't give it shadows, otherwise do
; 5372 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_REVERSEPLATFORM|FF_TRANSLUCENT|FF_EXTRA|FF_CUTEXTRA;

  012b1	c7 45 e8 1f 19
	00 04		 mov	 DWORD PTR _ffloorflags$5[ebp], 67115295 ; 0400191fH

; 5373 : 				if (lines[i].flags & ML_NOCLIMB)

  012b8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  012bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  012c2	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  012c7	83 e2 40	 and	 edx, 64			; 00000040H
  012ca	74 09		 je	 SHORT $LN207@P_SpawnSpe

; 5374 : 					ffloorflags |= FF_NOSHADE;

  012cc	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  012cf	83 c8 40	 or	 eax, 64			; 00000040H
  012d2	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN207@P_SpawnSpe:

; 5375 : 
; 5376 : 				// Draw the 'insides' of the block too
; 5377 : 				if (lines[i].flags & ML_EFFECT2)

  012d5	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  012d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  012df	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  012e4	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  012ea	74 37		 je	 SHORT $LN208@P_SpawnSpe

; 5378 : 				{
; 5379 : 					ffloorflags |= FF_CUTLEVEL;

  012ec	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  012ef	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  012f4	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5380 : 					ffloorflags |= FF_BOTHPLANES;

  012f7	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  012fa	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  012ff	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5381 : 					ffloorflags |= FF_ALLSIDES;

  01302	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01305	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  0130a	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5382 : 					ffloorflags &= ~FF_EXTRA;

  0130d	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01310	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  01315	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5383 : 					ffloorflags &= ~FF_CUTEXTRA;

  01318	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0131b	25 ff fe ff ff	 and	 eax, -257		; fffffeffH
  01320	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN208@P_SpawnSpe:

; 5384 : 				}
; 5385 : 
; 5386 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01323	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01326	50		 push	 eax
  01327	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0132a	51		 push	 ecx
  0132b	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01330	83 c4 08	 add	 esp, 8

; 5387 : 				break;

  01333	e9 5e 12 00 00	 jmp	 $LN20@P_SpawnSpe
$LN209@P_SpawnSpe:

; 5388 : 
; 5389 : 			case 145: // Translucent "reverse platform" with no sides
; 5390 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERPLANES|FF_TRANSLUCENT|FF_REVERSEPLATFORM|FF_EXTRA|FF_CUTEXTRA;

  01338	c7 45 e8 17 19
	00 04		 mov	 DWORD PTR _ffloorflags$5[ebp], 67115287 ; 04001917H

; 5391 : 				if (lines[i].flags & ML_NOCLIMB) // shade it unless no-climb

  0133f	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01343	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01349	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0134e	83 e2 40	 and	 edx, 64			; 00000040H
  01351	74 09		 je	 SHORT $LN210@P_SpawnSpe

; 5392 : 					ffloorflags |= FF_NOSHADE;

  01353	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01356	83 c8 40	 or	 eax, 64			; 00000040H
  01359	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN210@P_SpawnSpe:

; 5393 : 
; 5394 : 				// Draw the 'insides' of the block too
; 5395 : 				if (lines[i].flags & ML_EFFECT2)

  0135c	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01360	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01366	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0136b	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  01371	74 37		 je	 SHORT $LN211@P_SpawnSpe

; 5396 : 				{
; 5397 : 					ffloorflags |= FF_CUTLEVEL;

  01373	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01376	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  0137b	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5398 : 					ffloorflags |= FF_BOTHPLANES;

  0137e	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01381	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  01386	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5399 : 					ffloorflags |= FF_ALLSIDES;

  01389	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0138c	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  01391	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5400 : 					ffloorflags &= ~FF_EXTRA;

  01394	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01397	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  0139c	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax

; 5401 : 					ffloorflags &= ~FF_CUTEXTRA;

  0139f	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  013a2	25 ff fe ff ff	 and	 eax, -257		; fffffeffH
  013a7	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN211@P_SpawnSpe:

; 5402 : 				}
; 5403 : 
; 5404 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  013aa	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  013ad	50		 push	 eax
  013ae	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  013b1	51		 push	 ecx
  013b2	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  013b7	83 c4 08	 add	 esp, 8

; 5405 : 				break;

  013ba	e9 d7 11 00 00	 jmp	 $LN20@P_SpawnSpe
$LN212@P_SpawnSpe:

; 5406 : 
; 5407 : 			case 146: // Intangible floor/ceiling with solid sides (fences/hoops maybe?)
; 5408 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERSIDES|FF_ALLSIDES|FF_INTANGABLEFLATS);

  013bf	68 0f 80 00 06	 push	 100696079		; 0600800fH
  013c4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  013c7	50		 push	 eax
  013c8	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  013cd	83 c4 08	 add	 esp, 8

; 5409 : 				break;

  013d0	e9 c1 11 00 00	 jmp	 $LN20@P_SpawnSpe
$LN213@P_SpawnSpe:

; 5410 : 
; 5411 : 			case 150: // Air bobbing platform
; 5412 : 			case 151: // Adjustable air bobbing platform
; 5413 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL);

  013d5	68 9f 01 00 00	 push	 415			; 0000019fH
  013da	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  013dd	50		 push	 eax
  013de	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  013e3	83 c4 08	 add	 esp, 8

; 5414 : 				lines[i].flags |= ML_BLOCKMONSTERS;

  013e6	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  013ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  013f0	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  013f5	83 ca 02	 or	 edx, 2
  013f8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  013fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01402	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 5415 : 				P_AddOldAirbob(lines[i].frontsector, lines + i, (lines[i].special != 151));

  01407	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0140b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01411	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  01416	81 fa 97 00 00
	00		 cmp	 edx, 151		; 00000097H
  0141c	74 09		 je	 SHORT $LN335@P_SpawnSpe
  0141e	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv952[ebp], 1
  01425	eb 07		 jmp	 SHORT $LN336@P_SpawnSpe
$LN335@P_SpawnSpe:
  01427	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv952[ebp], 0
$LN336@P_SpawnSpe:
  0142e	8b 45 94	 mov	 eax, DWORD PTR tv952[ebp]
  01431	50		 push	 eax
  01432	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01436	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  0143c	51		 push	 ecx
  0143d	6b 55 f8 4c	 imul	 edx, DWORD PTR _i$[ebp], 76
  01441	a1 00 00 00 00	 mov	 eax, DWORD PTR _lines
  01446	8b 4c 10 30	 mov	 ecx, DWORD PTR [eax+edx+48]
  0144a	51		 push	 ecx
  0144b	e8 00 00 00 00	 call	 _P_AddOldAirbob
  01450	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5416 : 				break;

  01453	e9 3e 11 00 00	 jmp	 $LN20@P_SpawnSpe
$LN215@P_SpawnSpe:

; 5417 : 			case 152: // Adjustable air bobbing platform in reverse
; 5418 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL);

  01458	68 9f 01 00 00	 push	 415			; 0000019fH
  0145d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01460	50		 push	 eax
  01461	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01466	83 c4 08	 add	 esp, 8

; 5419 : 				P_AddOldAirbob(lines[i].frontsector, lines + i, true);

  01469	6a 01		 push	 1
  0146b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0146f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01475	50		 push	 eax
  01476	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0147a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  01480	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01484	50		 push	 eax
  01485	e8 00 00 00 00	 call	 _P_AddOldAirbob
  0148a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5420 : 				break;

  0148d	e9 04 11 00 00	 jmp	 $LN20@P_SpawnSpe
$LN216@P_SpawnSpe:

; 5421 : 
; 5422 : 			case 160: // Float/bob platform
; 5423 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01492	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01496	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  0149c	b9 02 00 00 00	 mov	 ecx, 2
  014a1	6b d1 00	 imul	 edx, ecx, 0
  014a4	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  014a9	6b c8 1c	 imul	 ecx, eax, 28
  014ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  014b2	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  014b6	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  014bc	99		 cdq
  014bd	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  014c2	f7 f9		 idiv	 ecx
  014c4	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5424 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  014c7	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN52@P_SpawnSpe:
  014ce	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  014d1	50		 push	 eax
  014d2	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  014d6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  014dc	51		 push	 ecx
  014dd	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  014e2	83 c4 08	 add	 esp, 8
  014e5	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  014e8	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  014ec	7c 36		 jl	 SHORT $LN53@P_SpawnSpe

; 5425 : 				{
; 5426 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  014ee	68 9f 01 04 00	 push	 262559			; 0004019fH
  014f3	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  014f7	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  014fd	50		 push	 eax
  014fe	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  01505	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0150b	51		 push	 ecx
  0150c	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  01513	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  01519	52		 push	 edx
  0151a	e8 00 00 00 00	 call	 _P_AddFakeFloor
  0151f	83 c4 10	 add	 esp, 16			; 00000010H

; 5427 : 						FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_FLOATBOB);
; 5428 : 				}

  01522	eb aa		 jmp	 SHORT $LN52@P_SpawnSpe
$LN53@P_SpawnSpe:

; 5429 : 				break;

  01524	e9 6d 10 00 00	 jmp	 $LN20@P_SpawnSpe
$LN217@P_SpawnSpe:

; 5430 : 
; 5431 : 			case 170: // Crumbling platform
; 5432 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_CRUMBLE);

  01529	68 9f 01 10 00	 push	 1048991			; 0010019fH
  0152e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01531	50		 push	 eax
  01532	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01537	83 c4 08	 add	 esp, 8

; 5433 : 				break;

  0153a	e9 57 10 00 00	 jmp	 $LN20@P_SpawnSpe
$LN218@P_SpawnSpe:

; 5434 : 
; 5435 : 			case 171: // Crumbling platform that will not return
; 5436 : 				P_AddFakeFloorsByLine(i,

  0153f	68 9f 01 18 00	 push	 1573279			; 0018019fH
  01544	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01547	50		 push	 eax
  01548	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  0154d	83 c4 08	 add	 esp, 8

; 5437 : 					FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_CRUMBLE|FF_NORETURN);
; 5438 : 				break;

  01550	e9 41 10 00 00	 jmp	 $LN20@P_SpawnSpe
$LN219@P_SpawnSpe:

; 5439 : 
; 5440 : 			case 172: // "Platform" that crumbles and returns
; 5441 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_PLATFORM|FF_CRUMBLE|FF_BOTHPLANES|FF_ALLSIDES;

  01555	c7 45 e8 1f 84
	10 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 34636831 ; 0210841fH

; 5442 : 				if (lines[i].flags & ML_NOCLIMB) // shade it unless no-climb

  0155c	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01560	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01566	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0156b	83 e2 40	 and	 edx, 64			; 00000040H
  0156e	74 09		 je	 SHORT $LN220@P_SpawnSpe

; 5443 : 					ffloorflags |= FF_NOSHADE;

  01570	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01573	83 c8 40	 or	 eax, 64			; 00000040H
  01576	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN220@P_SpawnSpe:

; 5444 : 
; 5445 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01579	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0157c	50		 push	 eax
  0157d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01580	51		 push	 ecx
  01581	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01586	83 c4 08	 add	 esp, 8

; 5446 : 				break;

  01589	e9 08 10 00 00	 jmp	 $LN20@P_SpawnSpe
$LN221@P_SpawnSpe:

; 5447 : 
; 5448 : 			case 173: // "Platform" that crumbles and doesn't return
; 5449 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_PLATFORM|FF_CRUMBLE|FF_NORETURN|FF_BOTHPLANES|FF_ALLSIDES;

  0158e	c7 45 e8 1f 84
	18 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 35161119 ; 0218841fH

; 5450 : 				if (lines[i].flags & ML_NOCLIMB) // shade it unless no-climb

  01595	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01599	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0159f	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  015a4	83 e2 40	 and	 edx, 64			; 00000040H
  015a7	74 09		 je	 SHORT $LN222@P_SpawnSpe

; 5451 : 					ffloorflags |= FF_NOSHADE;

  015a9	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  015ac	83 c8 40	 or	 eax, 64			; 00000040H
  015af	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN222@P_SpawnSpe:

; 5452 : 
; 5453 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  015b2	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  015b5	50		 push	 eax
  015b6	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  015b9	51		 push	 ecx
  015ba	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  015bf	83 c4 08	 add	 esp, 8

; 5454 : 				break;

  015c2	e9 cf 0f 00 00	 jmp	 $LN20@P_SpawnSpe
$LN223@P_SpawnSpe:

; 5455 : 
; 5456 : 			case 174: // Translucent "platform" that crumbles and returns
; 5457 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_PLATFORM|FF_CRUMBLE|FF_TRANSLUCENT|FF_BOTHPLANES|FF_ALLSIDES;

  015c7	c7 45 e8 9f 95
	10 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 34641311 ; 0210959fH

; 5458 : 				if (lines[i].flags & ML_NOCLIMB) // shade it unless no-climb

  015ce	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  015d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  015d8	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  015dd	83 e2 40	 and	 edx, 64			; 00000040H
  015e0	74 09		 je	 SHORT $LN224@P_SpawnSpe

; 5459 : 					ffloorflags |= FF_NOSHADE;

  015e2	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  015e5	83 c8 40	 or	 eax, 64			; 00000040H
  015e8	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN224@P_SpawnSpe:

; 5460 : 
; 5461 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  015eb	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  015ee	50		 push	 eax
  015ef	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  015f2	51		 push	 ecx
  015f3	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  015f8	83 c4 08	 add	 esp, 8

; 5462 : 				break;

  015fb	e9 96 0f 00 00	 jmp	 $LN20@P_SpawnSpe
$LN225@P_SpawnSpe:

; 5463 : 
; 5464 : 			case 175: // Translucent "platform" that crumbles and doesn't return
; 5465 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_PLATFORM|FF_CRUMBLE|FF_NORETURN|FF_TRANSLUCENT|FF_BOTHPLANES|FF_ALLSIDES;

  01600	c7 45 e8 9f 95
	18 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 35165599 ; 0218959fH

; 5466 : 				if (lines[i].flags & ML_NOCLIMB) // shade it unless no-climb

  01607	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0160b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01611	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01616	83 e2 40	 and	 edx, 64			; 00000040H
  01619	74 09		 je	 SHORT $LN226@P_SpawnSpe

; 5467 : 					ffloorflags |= FF_NOSHADE;

  0161b	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  0161e	83 c8 40	 or	 eax, 64			; 00000040H
  01621	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN226@P_SpawnSpe:

; 5468 : 
; 5469 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01624	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01627	50		 push	 eax
  01628	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0162b	51		 push	 ecx
  0162c	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01631	83 c4 08	 add	 esp, 8

; 5470 : 				break;

  01634	e9 5d 0f 00 00	 jmp	 $LN20@P_SpawnSpe
$LN227@P_SpawnSpe:

; 5471 : 
; 5472 : 			case 176: // Air bobbing platform that will crumble and bob on the water when it falls and hits
; 5473 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01639	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0163d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01643	b9 02 00 00 00	 mov	 ecx, 2
  01648	6b d1 00	 imul	 edx, ecx, 0
  0164b	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  01650	6b c8 1c	 imul	 ecx, eax, 28
  01653	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01659	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0165d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  01663	99		 cdq
  01664	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  01669	f7 f9		 idiv	 ecx
  0166b	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5474 : 				lines[i].flags |= ML_BLOCKMONSTERS;

  0166e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01672	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01678	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  0167d	83 ca 02	 or	 edx, 2
  01680	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01684	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0168a	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 5475 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  0168f	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN55@P_SpawnSpe:
  01696	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  01699	50		 push	 eax
  0169a	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0169e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  016a4	51		 push	 ecx
  016a5	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  016aa	83 c4 08	 add	 esp, 8
  016ad	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  016b0	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  016b4	7c 36		 jl	 SHORT $LN56@P_SpawnSpe

; 5476 : 				{
; 5477 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  016b6	68 9f 01 14 00	 push	 1311135			; 0014019fH
  016bb	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  016bf	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  016c5	50		 push	 eax
  016c6	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  016cd	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  016d3	51		 push	 ecx
  016d4	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  016db	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  016e1	52		 push	 edx
  016e2	e8 00 00 00 00	 call	 _P_AddFakeFloor
  016e7	83 c4 10	 add	 esp, 16			; 00000010H

; 5478 : 						FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_FLOATBOB|FF_CRUMBLE);
; 5479 : 				}

  016ea	eb aa		 jmp	 SHORT $LN55@P_SpawnSpe
$LN56@P_SpawnSpe:

; 5480 : 				P_AddOldAirbob(lines[i].frontsector, lines + i, true);

  016ec	6a 01		 push	 1
  016ee	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  016f2	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  016f8	50		 push	 eax
  016f9	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  016fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  01703	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01707	50		 push	 eax
  01708	e8 00 00 00 00	 call	 _P_AddOldAirbob
  0170d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5481 : 				break;

  01710	e9 81 0e 00 00	 jmp	 $LN20@P_SpawnSpe
$LN228@P_SpawnSpe:

; 5482 : 
; 5483 : 			case 177: // Air bobbing platform that will crumble and bob on
; 5484 : 				// the water when it falls and hits, then never return
; 5485 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_FLOATBOB|FF_CRUMBLE|FF_NORETURN);

  01715	68 9f 01 1c 00	 push	 1835423			; 001c019fH
  0171a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0171d	50		 push	 eax
  0171e	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01723	83 c4 08	 add	 esp, 8

; 5486 : 				lines[i].flags |= ML_BLOCKMONSTERS;

  01726	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0172a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01730	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01735	83 ca 02	 or	 edx, 2
  01738	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0173c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01742	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 5487 : 				P_AddOldAirbob(lines[i].frontsector, lines + i, true);

  01747	6a 01		 push	 1
  01749	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0174d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01753	50		 push	 eax
  01754	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01758	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0175e	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01762	50		 push	 eax
  01763	e8 00 00 00 00	 call	 _P_AddOldAirbob
  01768	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5488 : 				break;

  0176b	e9 26 0e 00 00	 jmp	 $LN20@P_SpawnSpe
$LN229@P_SpawnSpe:

; 5489 : 
; 5490 : 			case 178: // Crumbling platform that will float when it hits water
; 5491 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01770	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01774	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  0177a	b9 02 00 00 00	 mov	 ecx, 2
  0177f	6b d1 00	 imul	 edx, ecx, 0
  01782	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  01787	6b c8 1c	 imul	 ecx, eax, 28
  0178a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01790	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  01794	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  0179a	99		 cdq
  0179b	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  017a0	f7 f9		 idiv	 ecx
  017a2	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5492 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  017a5	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN58@P_SpawnSpe:
  017ac	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  017af	50		 push	 eax
  017b0	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  017b4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  017ba	51		 push	 ecx
  017bb	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  017c0	83 c4 08	 add	 esp, 8
  017c3	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  017c6	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  017ca	7c 36		 jl	 SHORT $LN59@P_SpawnSpe

; 5493 : 				{
; 5494 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  017cc	68 9f 01 14 00	 push	 1311135			; 0014019fH
  017d1	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  017d5	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  017db	50		 push	 eax
  017dc	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  017e3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  017e9	51		 push	 ecx
  017ea	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  017f1	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  017f7	52		 push	 edx
  017f8	e8 00 00 00 00	 call	 _P_AddFakeFloor
  017fd	83 c4 10	 add	 esp, 16			; 00000010H

; 5495 : 						FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_CRUMBLE|FF_FLOATBOB);
; 5496 : 				}

  01800	eb aa		 jmp	 SHORT $LN58@P_SpawnSpe
$LN59@P_SpawnSpe:

; 5497 : 				break;

  01802	e9 8f 0d 00 00	 jmp	 $LN20@P_SpawnSpe
$LN230@P_SpawnSpe:

; 5498 : 
; 5499 : 			case 179: // Crumbling platform that will float when it hits water, but not return
; 5500 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01807	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0180b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01811	b9 02 00 00 00	 mov	 ecx, 2
  01816	6b d1 00	 imul	 edx, ecx, 0
  01819	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  0181e	6b c8 1c	 imul	 ecx, eax, 28
  01821	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01827	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0182b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  01831	99		 cdq
  01832	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  01837	f7 f9		 idiv	 ecx
  01839	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5501 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  0183c	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN61@P_SpawnSpe:
  01843	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  01846	50		 push	 eax
  01847	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0184b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  01851	51		 push	 ecx
  01852	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  01857	83 c4 08	 add	 esp, 8
  0185a	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  0185d	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  01861	7c 36		 jl	 SHORT $LN62@P_SpawnSpe

; 5502 : 				{
; 5503 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  01863	68 9f 01 1c 00	 push	 1835423			; 001c019fH
  01868	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0186c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01872	50		 push	 eax
  01873	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  0187a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  01880	51		 push	 ecx
  01881	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  01888	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  0188e	52		 push	 edx
  0188f	e8 00 00 00 00	 call	 _P_AddFakeFloor
  01894	83 c4 10	 add	 esp, 16			; 00000010H

; 5504 : 						FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_CRUMBLE|FF_FLOATBOB|FF_NORETURN);
; 5505 : 				}

  01897	eb aa		 jmp	 SHORT $LN61@P_SpawnSpe
$LN62@P_SpawnSpe:

; 5506 : 				break;

  01899	e9 f8 0c 00 00	 jmp	 $LN20@P_SpawnSpe
$LN231@P_SpawnSpe:

; 5507 : 
; 5508 : 			case 180: // Air bobbing platform that will crumble
; 5509 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_CRUMBLE);

  0189e	68 9f 01 10 00	 push	 1048991			; 0010019fH
  018a3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  018a6	50		 push	 eax
  018a7	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  018ac	83 c4 08	 add	 esp, 8

; 5510 : 				lines[i].flags |= ML_BLOCKMONSTERS;

  018af	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  018b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  018b9	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  018be	83 ca 02	 or	 edx, 2
  018c1	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  018c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  018cb	66 89 54 01 10	 mov	 WORD PTR [ecx+eax+16], dx

; 5511 : 				P_AddOldAirbob(lines[i].frontsector, lines + i, true);

  018d0	6a 01		 push	 1
  018d2	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  018d6	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  018dc	50		 push	 eax
  018dd	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  018e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  018e7	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  018eb	50		 push	 eax
  018ec	e8 00 00 00 00	 call	 _P_AddOldAirbob
  018f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5512 : 				break;

  018f4	e9 9d 0c 00 00	 jmp	 $LN20@P_SpawnSpe
$LN232@P_SpawnSpe:

; 5513 : 
; 5514 : 			case 190: // Rising Platform FOF (solid, opaque, shadows)
; 5515 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL);

  018f9	68 9f 01 00 00	 push	 415			; 0000019fH
  018fe	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01901	50		 push	 eax
  01902	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01907	83 c4 08	 add	 esp, 8

; 5516 : 				P_AddRaiseThinker(lines[i].frontsector, &lines[i]);

  0190a	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0190e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01914	50		 push	 eax
  01915	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01919	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0191f	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01923	50		 push	 eax
  01924	e8 00 00 00 00	 call	 _P_AddRaiseThinker
  01929	83 c4 08	 add	 esp, 8

; 5517 : 				break;

  0192c	e9 65 0c 00 00	 jmp	 $LN20@P_SpawnSpe
$LN233@P_SpawnSpe:

; 5518 : 
; 5519 : 			case 191: // Rising Platform FOF (solid, opaque, no shadows)
; 5520 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_NOSHADE|FF_CUTLEVEL);

  01931	68 df 01 00 00	 push	 479			; 000001dfH
  01936	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01939	50		 push	 eax
  0193a	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  0193f	83 c4 08	 add	 esp, 8

; 5521 : 				P_AddRaiseThinker(lines[i].frontsector, &lines[i]);

  01942	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01946	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  0194c	50		 push	 eax
  0194d	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01951	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  01957	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  0195b	50		 push	 eax
  0195c	e8 00 00 00 00	 call	 _P_AddRaiseThinker
  01961	83 c4 08	 add	 esp, 8

; 5522 : 				break;

  01964	e9 2d 0c 00 00	 jmp	 $LN20@P_SpawnSpe
$LN234@P_SpawnSpe:

; 5523 : 
; 5524 : 			case 192: // Rising Platform TL block: FOF (solid, translucent)
; 5525 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_NOSHADE|FF_TRANSLUCENT|FF_EXTRA|FF_CUTEXTRA);

  01969	68 5f 19 00 00	 push	 6495			; 0000195fH
  0196e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01971	50		 push	 eax
  01972	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01977	83 c4 08	 add	 esp, 8

; 5526 : 				P_AddRaiseThinker(lines[i].frontsector, &lines[i]);

  0197a	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0197e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01984	50		 push	 eax
  01985	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01989	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0198f	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01993	50		 push	 eax
  01994	e8 00 00 00 00	 call	 _P_AddRaiseThinker
  01999	83 c4 08	 add	 esp, 8

; 5527 : 				break;

  0199c	e9 f5 0b 00 00	 jmp	 $LN20@P_SpawnSpe
$LN235@P_SpawnSpe:

; 5528 : 
; 5529 : 			case 193: // Rising Platform FOF (solid, invisible)
; 5530 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_NOSHADE);

  019a1	6a 47		 push	 71			; 00000047H
  019a3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  019a6	50		 push	 eax
  019a7	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  019ac	83 c4 08	 add	 esp, 8

; 5531 : 				P_AddRaiseThinker(lines[i].frontsector, &lines[i]);

  019af	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  019b3	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  019b9	50		 push	 eax
  019ba	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  019be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  019c4	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  019c8	50		 push	 eax
  019c9	e8 00 00 00 00	 call	 _P_AddRaiseThinker
  019ce	83 c4 08	 add	 esp, 8

; 5532 : 				break;

  019d1	e9 c0 0b 00 00	 jmp	 $LN20@P_SpawnSpe
$LN236@P_SpawnSpe:

; 5533 : 
; 5534 : 			case 194: // Rising Platform 'Platform' - You can jump up through it
; 5535 : 				// If line has no-climb set, don't give it shadows, otherwise do
; 5536 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_PLATFORM|FF_BOTHPLANES|FF_ALLSIDES;

  019d6	c7 45 e8 1f 84
	00 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 33588255 ; 0200841fH

; 5537 : 				if (lines[i].flags & ML_NOCLIMB)

  019dd	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  019e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  019e7	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  019ec	83 e2 40	 and	 edx, 64			; 00000040H
  019ef	74 09		 je	 SHORT $LN237@P_SpawnSpe

; 5538 : 					ffloorflags |= FF_NOSHADE;

  019f1	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  019f4	83 c8 40	 or	 eax, 64			; 00000040H
  019f7	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN237@P_SpawnSpe:

; 5539 : 
; 5540 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  019fa	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  019fd	50		 push	 eax
  019fe	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01a01	51		 push	 ecx
  01a02	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01a07	83 c4 08	 add	 esp, 8

; 5541 : 				P_AddRaiseThinker(lines[i].frontsector, &lines[i]);

  01a0a	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01a0e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01a14	50		 push	 eax
  01a15	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01a19	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  01a1f	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01a23	50		 push	 eax
  01a24	e8 00 00 00 00	 call	 _P_AddRaiseThinker
  01a29	83 c4 08	 add	 esp, 8

; 5542 : 				break;

  01a2c	e9 65 0b 00 00	 jmp	 $LN20@P_SpawnSpe
$LN238@P_SpawnSpe:

; 5543 : 
; 5544 : 			case 195: // Rising Platform Translucent "platform"
; 5545 : 				// If line has no-climb set, don't give it shadows, otherwise do
; 5546 : 				ffloorflags = FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_PLATFORM|FF_TRANSLUCENT|FF_BOTHPLANES|FF_ALLSIDES|FF_EXTRA|FF_CUTEXTRA;

  01a31	c7 45 e8 1f 9d
	00 02		 mov	 DWORD PTR _ffloorflags$5[ebp], 33594655 ; 02009d1fH

; 5547 : 				if (lines[i].flags & ML_NOCLIMB)

  01a38	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01a3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01a42	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01a47	83 e2 40	 and	 edx, 64			; 00000040H
  01a4a	74 09		 je	 SHORT $LN239@P_SpawnSpe

; 5548 : 					ffloorflags |= FF_NOSHADE;

  01a4c	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01a4f	83 c8 40	 or	 eax, 64			; 00000040H
  01a52	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN239@P_SpawnSpe:

; 5549 : 
; 5550 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01a55	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01a58	50		 push	 eax
  01a59	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01a5c	51		 push	 ecx
  01a5d	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01a62	83 c4 08	 add	 esp, 8

; 5551 : 				P_AddRaiseThinker(lines[i].frontsector, &lines[i]);

  01a65	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01a69	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01a6f	50		 push	 eax
  01a70	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01a74	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  01a7a	8b 44 0a 30	 mov	 eax, DWORD PTR [edx+ecx+48]
  01a7e	50		 push	 eax
  01a7f	e8 00 00 00 00	 call	 _P_AddRaiseThinker
  01a84	83 c4 08	 add	 esp, 8

; 5552 : 				break;

  01a87	e9 0a 0b 00 00	 jmp	 $LN20@P_SpawnSpe
$LN240@P_SpawnSpe:

; 5553 : 
; 5554 : #ifdef SLOPENESS
; 5555 : 			case 999:
; 5556 : 				sec = sides[*lines[i].sidenum].sector-sectors;
; 5557 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)
; 5558 : 				{
; 5559 : 					size_t counting;
; 5560 : 
; 5561 : 					sectors[s].floorangle = ANGLE_45;
; 5562 : 					for (counting = 0; counting < sectors[s].linecount/2; counting++)
; 5563 : 					{
; 5564 : 						sectors[s].lines[counting]->v1->z = sectors[sec].floorheight;
; 5565 : 						CONS_Printf("Set it to %d\n", sectors[s].lines[counting]->v1->z>>FRACBITS);
; 5566 : 					}
; 5567 : 
; 5568 : 					for (counting = sectors[s].linecount/2; counting < sectors[s].linecount; counting++)
; 5569 : 					{
; 5570 : 						sectors[s].lines[counting]->v1->z = sectors[sec].ceilingheight;
; 5571 : 						CONS_Printf("Set it to %d\n", sectors[s].lines[counting]->v1->z>>FRACBITS);
; 5572 : 					}
; 5573 : 					sectors[s].special = 65535;
; 5574 : 					CONS_Printf("Found & Set slope!\n");
; 5575 : 				}
; 5576 : 				break;
; 5577 : #endif
; 5578 : 
; 5579 : 			case 200: // Double light effect
; 5580 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_CUTSPRITES|FF_DOUBLESHADOW);

  01a8c	68 01 02 02 00	 push	 131585			; 00020201H
  01a91	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01a94	50		 push	 eax
  01a95	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01a9a	83 c4 08	 add	 esp, 8

; 5581 : 				break;

  01a9d	e9 f4 0a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN241@P_SpawnSpe:

; 5582 : 
; 5583 : 			case 201: // Light effect
; 5584 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_CUTSPRITES);

  01aa2	68 01 02 00 00	 push	 513			; 00000201H
  01aa7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01aaa	50		 push	 eax
  01aab	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01ab0	83 c4 08	 add	 esp, 8

; 5585 : 				break;

  01ab3	e9 de 0a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN242@P_SpawnSpe:

; 5586 : 
; 5587 : 			case 202: // Fog
; 5588 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01ab8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01abc	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01ac2	b9 02 00 00 00	 mov	 ecx, 2
  01ac7	6b d1 00	 imul	 edx, ecx, 0
  01aca	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  01acf	6b c8 1c	 imul	 ecx, eax, 28
  01ad2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01ad8	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  01adc	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  01ae2	99		 cdq
  01ae3	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  01ae8	f7 f9		 idiv	 ecx
  01aea	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5589 : 				// SoM: Because it's fog, check for an extra colormap and set
; 5590 : 				// the fog flag...
; 5591 : 				if (sectors[sec].extra_colormap)

  01aed	69 45 ec f8 00
	00 00		 imul	 eax, DWORD PTR _sec$6[ebp], 248
  01af4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  01afa	83 bc 01 b0 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax+176], 0
  01b02	74 1b		 je	 SHORT $LN243@P_SpawnSpe

; 5592 : 					sectors[sec].extra_colormap->fog = 1;

  01b04	69 45 ec f8 00
	00 00		 imul	 eax, DWORD PTR _sec$6[ebp], 248
  01b0b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  01b11	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  01b18	c7 42 14 01 00
	00 00		 mov	 DWORD PTR [edx+20], 1
$LN243@P_SpawnSpe:

; 5593 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  01b1f	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN64@P_SpawnSpe:
  01b26	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  01b29	50		 push	 eax
  01b2a	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01b2e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  01b34	51		 push	 ecx
  01b35	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  01b3a	83 c4 08	 add	 esp, 8
  01b3d	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  01b40	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  01b44	7c 36		 jl	 SHORT $LN65@P_SpawnSpe

; 5594 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  01b46	68 19 ef 03 00	 push	 257817			; 0003ef19H
  01b4b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01b4f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01b55	50		 push	 eax
  01b56	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  01b5d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  01b63	51		 push	 ecx
  01b64	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  01b6b	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  01b71	52		 push	 edx
  01b72	e8 00 00 00 00	 call	 _P_AddFakeFloor
  01b77	83 c4 10	 add	 esp, 16			; 00000010H
  01b7a	eb aa		 jmp	 SHORT $LN64@P_SpawnSpe
$LN65@P_SpawnSpe:

; 5595 : 						FF_EXISTS|FF_RENDERALL|FF_FOG|FF_BOTHPLANES|FF_INVERTPLANES|FF_ALLSIDES|FF_INVERTSIDES|FF_CUTEXTRA|FF_EXTRA|FF_DOUBLESHADOW|FF_CUTSPRITES);
; 5596 : 				break;

  01b7c	e9 15 0a 00 00	 jmp	 $LN20@P_SpawnSpe
$LN244@P_SpawnSpe:

; 5597 : 
; 5598 : 			case 220: // Like opaque water, but not swimmable. (Good for snow effect on FOFs)
; 5599 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_RENDERALL|FF_BOTHPLANES|FF_ALLSIDES|FF_CUTEXTRA|FF_EXTRA|FF_CUTSPRITES);

  01b81	68 19 8f 00 00	 push	 36633			; 00008f19H
  01b86	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01b89	50		 push	 eax
  01b8a	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01b8f	83 c4 08	 add	 esp, 8

; 5600 : 				break;

  01b92	e9 ff 09 00 00	 jmp	 $LN20@P_SpawnSpe
$LN245@P_SpawnSpe:

; 5601 : 
; 5602 : 			case 221: // FOF (intangible, translucent)
; 5603 : 				// If line has no-climb set, give it shadows, otherwise don't
; 5604 : 				ffloorflags = FF_EXISTS|FF_RENDERALL|FF_TRANSLUCENT|FF_EXTRA|FF_CUTEXTRA|FF_CUTSPRITES;

  01b97	c7 45 e8 19 1b
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 6937 ; 00001b19H

; 5605 : 				if (!(lines[i].flags & ML_NOCLIMB))

  01b9e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01ba2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01ba8	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01bad	83 e2 40	 and	 edx, 64			; 00000040H
  01bb0	75 09		 jne	 SHORT $LN246@P_SpawnSpe

; 5606 : 					ffloorflags |= FF_NOSHADE;

  01bb2	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01bb5	83 c8 40	 or	 eax, 64			; 00000040H
  01bb8	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN246@P_SpawnSpe:

; 5607 : 
; 5608 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01bbb	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01bbe	50		 push	 eax
  01bbf	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01bc2	51		 push	 ecx
  01bc3	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01bc8	83 c4 08	 add	 esp, 8

; 5609 : 				break;

  01bcb	e9 c6 09 00 00	 jmp	 $LN20@P_SpawnSpe
$LN247@P_SpawnSpe:

; 5610 : 
; 5611 : 			case 222: // FOF with no floor/ceiling (good for GFZGRASS effect on FOFs)
; 5612 : 				// If line has no-climb set, give it shadows, otherwise don't
; 5613 : 				ffloorflags = FF_EXISTS|FF_RENDERSIDES|FF_ALLSIDES;

  01bd0	c7 45 e8 09 80
	00 00		 mov	 DWORD PTR _ffloorflags$5[ebp], 32777 ; 00008009H

; 5614 : 				if (!(lines[i].flags & ML_NOCLIMB))

  01bd7	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01bdb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01be1	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01be6	83 e2 40	 and	 edx, 64			; 00000040H
  01be9	75 0b		 jne	 SHORT $LN248@P_SpawnSpe

; 5615 : 					ffloorflags |= FF_NOSHADE|FF_CUTSPRITES;

  01beb	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01bee	0d 40 02 00 00	 or	 eax, 576		; 00000240H
  01bf3	89 45 e8	 mov	 DWORD PTR _ffloorflags$5[ebp], eax
$LN248@P_SpawnSpe:

; 5616 : 
; 5617 : 				P_AddFakeFloorsByLine(i, ffloorflags);

  01bf6	8b 45 e8	 mov	 eax, DWORD PTR _ffloorflags$5[ebp]
  01bf9	50		 push	 eax
  01bfa	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01bfd	51		 push	 ecx
  01bfe	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01c03	83 c4 08	 add	 esp, 8

; 5618 : 				break;

  01c06	e9 8b 09 00 00	 jmp	 $LN20@P_SpawnSpe
$LN249@P_SpawnSpe:

; 5619 : 
; 5620 : 			case 223: // FOF (intangible, invisible) - for combining specials in a sector
; 5621 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_NOSHADE);

  01c0b	6a 41		 push	 65			; 00000041H
  01c0d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01c10	50		 push	 eax
  01c11	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01c16	83 c4 08	 add	 esp, 8

; 5622 : 				break;

  01c19	e9 78 09 00 00	 jmp	 $LN20@P_SpawnSpe
$LN250@P_SpawnSpe:

; 5623 : 
; 5624 : 			case 250: // Mario Block
; 5625 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01c1e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01c22	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01c28	b9 02 00 00 00	 mov	 ecx, 2
  01c2d	6b d1 00	 imul	 edx, ecx, 0
  01c30	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  01c35	6b c8 1c	 imul	 ecx, eax, 28
  01c38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01c3e	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  01c42	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  01c48	99		 cdq
  01c49	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  01c4e	f7 f9		 idiv	 ecx
  01c50	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5626 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  01c53	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN67@P_SpawnSpe:
  01c5a	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  01c5d	50		 push	 eax
  01c5e	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01c62	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  01c68	51		 push	 ecx
  01c69	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  01c6e	83 c4 08	 add	 esp, 8
  01c71	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  01c74	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  01c78	7c 36		 jl	 SHORT $LN68@P_SpawnSpe

; 5627 : 				{
; 5628 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  01c7a	68 9f 01 40 00	 push	 4194719			; 0040019fH
  01c7f	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01c83	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01c89	50		 push	 eax
  01c8a	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  01c91	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  01c97	51		 push	 ecx
  01c98	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  01c9f	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  01ca5	52		 push	 edx
  01ca6	e8 00 00 00 00	 call	 _P_AddFakeFloor
  01cab	83 c4 10	 add	 esp, 16			; 00000010H

; 5629 : 						FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL|FF_MARIO);
; 5630 : 				}

  01cae	eb aa		 jmp	 SHORT $LN67@P_SpawnSpe
$LN68@P_SpawnSpe:

; 5631 : 				break;

  01cb0	e9 e1 08 00 00	 jmp	 $LN20@P_SpawnSpe
$LN251@P_SpawnSpe:

; 5632 : 
; 5633 : 			case 251: // A THWOMP!
; 5634 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  01cb5	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01cb9	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01cbf	b9 02 00 00 00	 mov	 ecx, 2
  01cc4	6b d1 00	 imul	 edx, ecx, 0
  01cc7	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  01ccc	6b c8 1c	 imul	 ecx, eax, 28
  01ccf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01cd5	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  01cd9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  01cdf	99		 cdq
  01ce0	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  01ce5	f7 f9		 idiv	 ecx
  01ce7	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5635 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  01cea	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN70@P_SpawnSpe:
  01cf1	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  01cf4	50		 push	 eax
  01cf5	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01cf9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  01cff	51		 push	 ecx
  01d00	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  01d05	83 c4 08	 add	 esp, 8
  01d08	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  01d0b	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  01d0f	7c 68		 jl	 SHORT $LN71@P_SpawnSpe

; 5636 : 				{
; 5637 : 					P_AddThwompThinker(&sectors[sec], &sectors[s], &lines[i]);

  01d11	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01d15	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01d1b	50		 push	 eax
  01d1c	69 4d f0 f8 00
	00 00		 imul	 ecx, DWORD PTR _s$7[ebp], 248
  01d23	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  01d29	51		 push	 ecx
  01d2a	69 55 ec f8 00
	00 00		 imul	 edx, DWORD PTR _sec$6[ebp], 248
  01d31	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  01d37	52		 push	 edx
  01d38	e8 00 00 00 00	 call	 _P_AddThwompThinker
  01d3d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5638 : 					P_AddFakeFloor(&sectors[s], &sectors[sec], lines + i,

  01d40	68 9f 01 00 00	 push	 415			; 0000019fH
  01d45	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01d49	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01d4f	50		 push	 eax
  01d50	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  01d57	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  01d5d	51		 push	 ecx
  01d5e	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  01d65	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  01d6b	52		 push	 edx
  01d6c	e8 00 00 00 00	 call	 _P_AddFakeFloor
  01d71	83 c4 10	 add	 esp, 16			; 00000010H

; 5639 : 						FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_CUTLEVEL);
; 5640 : 				}

  01d74	e9 78 ff ff ff	 jmp	 $LN70@P_SpawnSpe
$LN71@P_SpawnSpe:

; 5641 : 				break;

  01d79	e9 18 08 00 00	 jmp	 $LN20@P_SpawnSpe
$LN252@P_SpawnSpe:

; 5642 : 
; 5643 : 			case 252: // Shatter block (breaks when touched)
; 5644 : 				if (lines[i].flags & ML_NOCLIMB)

  01d7e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01d82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01d88	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01d8d	83 e2 40	 and	 edx, 64			; 00000040H
  01d90	74 13		 je	 SHORT $LN253@P_SpawnSpe

; 5645 : 					P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP|FF_SHATTER|FF_SHATTERBOTTOM);

  01d92	68 1f 00 a0 08	 push	 144703519		; 08a0001fH
  01d97	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01d9a	50		 push	 eax
  01d9b	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01da0	83 c4 08	 add	 esp, 8
  01da3	eb 11		 jmp	 SHORT $LN254@P_SpawnSpe
$LN253@P_SpawnSpe:

; 5646 : 				else
; 5647 : 					P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP|FF_SHATTER);

  01da5	68 1f 00 80 08	 push	 142606367		; 0880001fH
  01daa	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01dad	50		 push	 eax
  01dae	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01db3	83 c4 08	 add	 esp, 8
$LN254@P_SpawnSpe:

; 5648 : 				break;

  01db6	e9 db 07 00 00	 jmp	 $LN20@P_SpawnSpe
$LN255@P_SpawnSpe:

; 5649 : 
; 5650 : 			case 253: // Translucent shatter block (see 76)
; 5651 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP|FF_SHATTER|FF_TRANSLUCENT);

  01dbb	68 1f 10 80 08	 push	 142610463		; 0880101fH
  01dc0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01dc3	50		 push	 eax
  01dc4	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01dc9	83 c4 08	 add	 esp, 8

; 5652 : 				break;

  01dcc	e9 c5 07 00 00	 jmp	 $LN20@P_SpawnSpe
$LN256@P_SpawnSpe:

; 5653 : 
; 5654 : 			case 254: // Bustable block
; 5655 : 				if (lines[i].flags & ML_NOCLIMB)

  01dd1	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01dd5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01ddb	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01de0	83 e2 40	 and	 edx, 64			; 00000040H
  01de3	74 13		 je	 SHORT $LN257@P_SpawnSpe

; 5656 : 					P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP|FF_ONLYKNUX);

  01de5	68 1f 00 80 20	 push	 545259551		; 2080001fH
  01dea	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01ded	50		 push	 eax
  01dee	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01df3	83 c4 08	 add	 esp, 8
  01df6	eb 11		 jmp	 SHORT $LN258@P_SpawnSpe
$LN257@P_SpawnSpe:

; 5657 : 				else
; 5658 : 					P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP);

  01df8	68 1f 00 80 00	 push	 8388639			; 0080001fH
  01dfd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e00	50		 push	 eax
  01e01	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01e06	83 c4 08	 add	 esp, 8
$LN258@P_SpawnSpe:

; 5659 : 				break;

  01e09	e9 88 07 00 00	 jmp	 $LN20@P_SpawnSpe
$LN259@P_SpawnSpe:

; 5660 : 
; 5661 : 			case 255: // Spin bust block (breaks when jumped or spun downwards onto)
; 5662 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP|FF_SPINBUST);

  01e0e	68 1f 00 80 10	 push	 276824095		; 1080001fH
  01e13	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e16	50		 push	 eax
  01e17	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01e1c	83 c4 08	 add	 esp, 8

; 5663 : 				break;

  01e1f	e9 72 07 00 00	 jmp	 $LN20@P_SpawnSpe
$LN260@P_SpawnSpe:

; 5664 : 
; 5665 : 			case 256: // Translucent spin bust block (see 78)
; 5666 : 				P_AddFakeFloorsByLine(i, FF_EXISTS|FF_SOLID|FF_RENDERALL|FF_BUSTUP|FF_SPINBUST|FF_TRANSLUCENT);

  01e24	68 1f 10 80 10	 push	 276828191		; 1080101fH
  01e29	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e2c	50		 push	 eax
  01e2d	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01e32	83 c4 08	 add	 esp, 8

; 5667 : 				break;

  01e35	e9 5c 07 00 00	 jmp	 $LN20@P_SpawnSpe
$LN261@P_SpawnSpe:

; 5668 : 
; 5669 : 			case 257: // Quicksand
; 5670 : 				if (lines[i].flags & ML_EFFECT5)

  01e3a	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01e3e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  01e44	0f bf 54 01 10	 movsx	 edx, WORD PTR [ecx+eax+16]
  01e49	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  01e4f	74 13		 je	 SHORT $LN262@P_SpawnSpe

; 5671 : 					P_AddFakeFloorsByLine(i, FF_EXISTS|FF_QUICKSAND|FF_RENDERALL|FF_ALLSIDES|FF_CUTSPRITES|FF_RIPPLE);

  01e51	68 19 82 00 41	 push	 1090552345		; 41008219H
  01e56	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e59	50		 push	 eax
  01e5a	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01e5f	83 c4 08	 add	 esp, 8
  01e62	eb 11		 jmp	 SHORT $LN263@P_SpawnSpe
$LN262@P_SpawnSpe:

; 5672 : 				else
; 5673 : 					P_AddFakeFloorsByLine(i, FF_EXISTS|FF_QUICKSAND|FF_RENDERALL|FF_ALLSIDES|FF_CUTSPRITES);

  01e64	68 19 82 00 01	 push	 16810521		; 01008219H
  01e69	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01e6c	50		 push	 eax
  01e6d	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  01e72	83 c4 08	 add	 esp, 8
$LN263@P_SpawnSpe:

; 5674 : 				break;

  01e75	e9 1c 07 00 00	 jmp	 $LN20@P_SpawnSpe
$LN264@P_SpawnSpe:

; 5675 : 
; 5676 : 			case 258: // Laser block
; 5677 : 				if (!fromnetsave) // Don't load in netsaves, this call creates an FOF which causes LOTS of problems

  01e7a	83 7d 08 00	 cmp	 DWORD PTR _fromnetsave$[ebp], 0
  01e7e	0f 85 8d 00 00
	00		 jne	 $LN74@P_SpawnSpe

; 5678 : 				{
; 5679 : 					sec = sides[*lines[i].sidenum].sector - sectors;

  01e84	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01e88	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01e8e	b9 02 00 00 00	 mov	 ecx, 2
  01e93	6b d1 00	 imul	 edx, ecx, 0
  01e96	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  01e9b	6b c8 1c	 imul	 ecx, eax, 28
  01e9e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  01ea4	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  01ea8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  01eae	99		 cdq
  01eaf	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  01eb4	f7 f9		 idiv	 ecx
  01eb6	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5680 : 
; 5681 : 					for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  01eb9	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN73@P_SpawnSpe:
  01ec0	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  01ec3	50		 push	 eax
  01ec4	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01ec8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  01ece	51		 push	 ecx
  01ecf	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  01ed4	83 c4 08	 add	 esp, 8
  01ed7	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  01eda	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  01ede	7c 31		 jl	 SHORT $LN74@P_SpawnSpe

; 5682 : 						EV_AddLaserThinker(&sectors[s], &sectors[sec], lines + i);

  01ee0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01ee4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01eea	50		 push	 eax
  01eeb	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  01ef2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  01ef8	51		 push	 ecx
  01ef9	69 55 f0 f8 00
	00 00		 imul	 edx, DWORD PTR _s$7[ebp], 248
  01f00	03 15 00 00 00
	00		 add	 edx, DWORD PTR _sectors
  01f06	52		 push	 edx
  01f07	e8 00 00 00 00	 call	 _EV_AddLaserThinker
  01f0c	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f0f	eb af		 jmp	 SHORT $LN73@P_SpawnSpe
$LN74@P_SpawnSpe:

; 5683 : 				}
; 5684 : 				break;

  01f11	e9 80 06 00 00	 jmp	 $LN20@P_SpawnSpe
$LN266@P_SpawnSpe:

; 5685 : 
; 5686 : 			case 259: // Make-Your-Own FOF!
; 5687 : 				if (lines[i].sidenum[1] != 0xffff)

  01f16	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  01f1a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  01f20	b9 02 00 00 00	 mov	 ecx, 2
  01f25	c1 e1 00	 shl	 ecx, 0
  01f28	0f b7 54 08 16	 movzx	 edx, WORD PTR [eax+ecx+22]
  01f2d	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  01f33	0f 84 17 01 00
	00		 je	 $LN267@P_SpawnSpe

; 5688 : 				{
; 5689 : 					UINT8 *data = W_CacheLumpNum(lastloadedmaplumpnum + ML_SIDEDEFS,PU_STATIC);

  01f39	6a 01		 push	 1
  01f3b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastloadedmaplumpnum
  01f40	83 c0 03	 add	 eax, 3
  01f43	50		 push	 eax
  01f44	e8 00 00 00 00	 call	 _W_CacheLumpNum
  01f49	83 c4 08	 add	 esp, 8
  01f4c	89 45 e4	 mov	 DWORD PTR _data$4[ebp], eax

; 5690 : 					UINT16 b;
; 5691 : 
; 5692 : 					for (b = 0; b < (INT16)numsides; b++)

  01f4f	33 c0		 xor	 eax, eax
  01f51	66 89 45 e0	 mov	 WORD PTR _b$3[ebp], ax
  01f55	eb 0c		 jmp	 SHORT $LN78@P_SpawnSpe
$LN76@P_SpawnSpe:
  01f57	66 8b 45 e0	 mov	 ax, WORD PTR _b$3[ebp]
  01f5b	66 83 c0 01	 add	 ax, 1
  01f5f	66 89 45 e0	 mov	 WORD PTR _b$3[ebp], ax
$LN78@P_SpawnSpe:
  01f63	0f b7 45 e0	 movzx	 eax, WORD PTR _b$3[ebp]
  01f67	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _numsides
  01f6e	3b c1		 cmp	 eax, ecx
  01f70	0f 8d cc 00 00
	00		 jge	 $LN77@P_SpawnSpe

; 5693 : 					{
; 5694 : 						register mapsidedef_t *msd = (mapsidedef_t *)data + b;

  01f76	0f b7 45 e0	 movzx	 eax, WORD PTR _b$3[ebp]
  01f7a	6b c8 1e	 imul	 ecx, eax, 30
  01f7d	03 4d e4	 add	 ecx, DWORD PTR _data$4[ebp]
  01f80	89 4d dc	 mov	 DWORD PTR _msd$2[ebp], ecx

; 5695 : 
; 5696 : 						if (b == lines[i].sidenum[1])

  01f83	0f b7 45 e0	 movzx	 eax, WORD PTR _b$3[ebp]
  01f87	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  01f8b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  01f91	ba 02 00 00 00	 mov	 edx, 2
  01f96	c1 e2 00	 shl	 edx, 0
  01f99	0f b7 4c 11 16	 movzx	 ecx, WORD PTR [ecx+edx+22]
  01f9e	3b c1		 cmp	 eax, ecx
  01fa0	0f 85 97 00 00
	00		 jne	 $LN271@P_SpawnSpe

; 5697 : 						{
; 5698 : 							if ((msd->toptexture[0] >= '0' && msd->toptexture[0] <= '9')
; 5699 : 								|| (msd->toptexture[0] >= 'A' && msd->toptexture[0] <= 'F'))

  01fa6	b8 01 00 00 00	 mov	 eax, 1
  01fab	6b c8 00	 imul	 ecx, eax, 0
  01fae	8b 55 dc	 mov	 edx, DWORD PTR _msd$2[ebp]
  01fb1	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  01fb6	83 f8 30	 cmp	 eax, 48			; 00000030H
  01fb9	7c 15		 jl	 SHORT $LN273@P_SpawnSpe
  01fbb	b8 01 00 00 00	 mov	 eax, 1
  01fc0	6b c8 00	 imul	 ecx, eax, 0
  01fc3	8b 55 dc	 mov	 edx, DWORD PTR _msd$2[ebp]
  01fc6	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  01fcb	83 f8 39	 cmp	 eax, 57			; 00000039H
  01fce	7e 2a		 jle	 SHORT $LN272@P_SpawnSpe
$LN273@P_SpawnSpe:
  01fd0	b8 01 00 00 00	 mov	 eax, 1
  01fd5	6b c8 00	 imul	 ecx, eax, 0
  01fd8	8b 55 dc	 mov	 edx, DWORD PTR _msd$2[ebp]
  01fdb	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  01fe0	83 f8 41	 cmp	 eax, 65			; 00000041H
  01fe3	7c 3b		 jl	 SHORT $LN270@P_SpawnSpe
  01fe5	b8 01 00 00 00	 mov	 eax, 1
  01fea	6b c8 00	 imul	 ecx, eax, 0
  01fed	8b 55 dc	 mov	 edx, DWORD PTR _msd$2[ebp]
  01ff0	0f be 44 0a 04	 movsx	 eax, BYTE PTR [edx+ecx+4]
  01ff5	83 f8 46	 cmp	 eax, 70			; 00000046H
  01ff8	7f 26		 jg	 SHORT $LN270@P_SpawnSpe
$LN272@P_SpawnSpe:

; 5700 : 							{
; 5701 : 								ffloortype_e FOF_Flags = axtoi(msd->toptexture);

  01ffa	8b 45 dc	 mov	 eax, DWORD PTR _msd$2[ebp]
  01ffd	83 c0 04	 add	 eax, 4
  02000	50		 push	 eax
  02001	e8 00 00 00 00	 call	 _axtoi
  02006	83 c4 04	 add	 esp, 4
  02009	89 45 d8	 mov	 DWORD PTR _FOF_Flags$1[ebp], eax

; 5702 : 
; 5703 : 								P_AddFakeFloorsByLine(i, FOF_Flags);

  0200c	8b 45 d8	 mov	 eax, DWORD PTR _FOF_Flags$1[ebp]
  0200f	50		 push	 eax
  02010	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02013	51		 push	 ecx
  02014	e8 00 00 00 00	 call	 _P_AddFakeFloorsByLine
  02019	83 c4 08	 add	 esp, 8

; 5704 : 								break;

  0201c	eb 24		 jmp	 SHORT $LN77@P_SpawnSpe

; 5705 : 							}

  0201e	eb 1d		 jmp	 SHORT $LN271@P_SpawnSpe
$LN270@P_SpawnSpe:

; 5706 : 							else
; 5707 : 								I_Error("Make-Your-Own-FOF (tag %d) needs a value in the linedef's second side upper texture field.", lines[i].tag);

  02020	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0202a	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  0202f	52		 push	 edx
  02030	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@BIGCHJLL@Make?9Your?9Own?9FOF?5?$CItag?5?$CFd?$CJ?5need@
  02035	e8 00 00 00 00	 call	 _I_Error
  0203a	83 c4 08	 add	 esp, 8
$LN271@P_SpawnSpe:

; 5708 : 						}
; 5709 : 					}

  0203d	e9 15 ff ff ff	 jmp	 $LN76@P_SpawnSpe
$LN77@P_SpawnSpe:

; 5710 : 					Z_Free(data);

  02042	8b 45 e4	 mov	 eax, DWORD PTR _data$4[ebp]
  02045	50		 push	 eax
  02046	e8 00 00 00 00	 call	 _Z_Free
  0204b	83 c4 04	 add	 esp, 4

; 5711 : 				}

  0204e	eb 1d		 jmp	 SHORT $LN268@P_SpawnSpe
$LN267@P_SpawnSpe:

; 5712 : 				else
; 5713 : 					I_Error("Make-Your-Own FOF (tag %d) found without a 2nd linedef side!", lines[i].tag);

  02050	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0205a	0f bf 54 01 14	 movsx	 edx, WORD PTR [ecx+eax+20]
  0205f	52		 push	 edx
  02060	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MNKJLNKI@Make?9Your?9Own?5FOF?5?$CItag?5?$CFd?$CJ?5foun@
  02065	e8 00 00 00 00	 call	 _I_Error
  0206a	83 c4 08	 add	 esp, 8
$LN268@P_SpawnSpe:

; 5714 : 				break;

  0206d	e9 24 05 00 00	 jmp	 $LN20@P_SpawnSpe

; 5715 : 
; 5716 : 			case 300: // Linedef executor (combines with sector special 974/975) and commands
; 5717 : 			case 302:
; 5718 : 			case 303:
; 5719 : 			case 304:
; 5720 : 
; 5721 : 			// Charability linedef executors
; 5722 : 			case 305:
; 5723 : 			case 307:
; 5724 : 				break;

  02072	e9 1f 05 00 00	 jmp	 $LN20@P_SpawnSpe
$LN280@P_SpawnSpe:

; 5725 : 
; 5726 : 			case 308: // Race-only linedef executor. Triggers once.
; 5727 : 				if (gametype != GT_RACE)

  02077	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  0207e	83 f8 02	 cmp	 eax, 2
  02081	74 11		 je	 SHORT $LN281@P_SpawnSpe

; 5728 : 					lines[i].special = 0;

  02083	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02087	33 c9		 xor	 ecx, ecx
  02089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  0208f	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx
$LN281@P_SpawnSpe:

; 5729 : 				break;

  02094	e9 fd 04 00 00	 jmp	 $LN20@P_SpawnSpe
$LN282@P_SpawnSpe:

; 5730 : 
; 5731 : 			// Linedef executor triggers for CTF teams.
; 5732 : 			case 309:
; 5733 : 			case 311:
; 5734 : 				if (gametype != GT_CTF)

  02099	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  020a0	83 f8 04	 cmp	 eax, 4
  020a3	74 11		 je	 SHORT $LN284@P_SpawnSpe

; 5735 : 					lines[i].special = 0;

  020a5	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  020a9	33 c9		 xor	 ecx, ecx
  020ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lines
  020b1	66 89 4c 02 12	 mov	 WORD PTR [edx+eax+18], cx
$LN284@P_SpawnSpe:

; 5736 : 				break;

  020b6	e9 db 04 00 00	 jmp	 $LN20@P_SpawnSpe
$LN285@P_SpawnSpe:

; 5737 : 
; 5738 : 			// Each time executors
; 5739 : 			case 306:
; 5740 : 			case 301:
; 5741 : 			case 310:
; 5742 : 			case 312:
; 5743 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  020bb	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  020bf	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  020c5	b9 02 00 00 00	 mov	 ecx, 2
  020ca	6b d1 00	 imul	 edx, ecx, 0
  020cd	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  020d2	6b c8 1c	 imul	 ecx, eax, 28
  020d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  020db	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  020df	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  020e5	99		 cdq
  020e6	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  020eb	f7 f9		 idiv	 ecx
  020ed	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5744 : 				P_AddEachTimeThinker(&sectors[sec], &lines[i]);

  020f0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  020f4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  020fa	50		 push	 eax
  020fb	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  02102	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  02108	51		 push	 ecx
  02109	e8 00 00 00 00	 call	 _P_AddEachTimeThinker
  0210e	83 c4 08	 add	 esp, 8

; 5745 : 				break;

  02111	e9 80 04 00 00	 jmp	 $LN20@P_SpawnSpe
$LN289@P_SpawnSpe:

; 5746 : 
; 5747 : 			// No More Enemies Linedef Exec
; 5748 : 			case 313:
; 5749 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  02116	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0211a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  02120	b9 02 00 00 00	 mov	 ecx, 2
  02125	6b d1 00	 imul	 edx, ecx, 0
  02128	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  0212d	6b c8 1c	 imul	 ecx, eax, 28
  02130	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  02136	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0213a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  02140	99		 cdq
  02141	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  02146	f7 f9		 idiv	 ecx
  02148	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5750 : 				P_AddNoEnemiesThinker(&sectors[sec], &lines[i]);

  0214b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0214f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  02155	50		 push	 eax
  02156	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  0215d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  02163	51		 push	 ecx
  02164	e8 00 00 00 00	 call	 _P_AddNoEnemiesThinker
  02169	83 c4 08	 add	 esp, 8

; 5751 : 				break;

  0216c	e9 25 04 00 00	 jmp	 $LN20@P_SpawnSpe

; 5752 : 
; 5753 : 			// Pushable linedef executors (count # of pushables)
; 5754 : 			case 314:
; 5755 : 			case 315:
; 5756 : 				break;

  02171	e9 20 04 00 00	 jmp	 $LN20@P_SpawnSpe

; 5757 : 
; 5758 : 			case 399: // Linedef execute on map load
; 5759 : 				// This is handled in P_RunLevelLoadExecutors.
; 5760 : 				break;

  02176	e9 1b 04 00 00	 jmp	 $LN20@P_SpawnSpe

; 5761 : 
; 5762 : 			case 400:
; 5763 : 			case 401:
; 5764 : 			case 402:
; 5765 : 			case 403:
; 5766 : 			case 404:
; 5767 : 			case 405:
; 5768 : 			case 406:
; 5769 : 			case 407:
; 5770 : 			case 408:
; 5771 : 			case 409:
; 5772 : 			case 410:
; 5773 : 			case 411:
; 5774 : 			case 412:
; 5775 : 			case 413:
; 5776 : 			case 414:
; 5777 : 			case 415:
; 5778 : 			case 416:
; 5779 : 			case 417:
; 5780 : 			case 418:
; 5781 : 			case 419:
; 5782 : 			case 420:
; 5783 : 			case 421:
; 5784 : 			case 422:
; 5785 : 			case 423:
; 5786 : 			case 424:
; 5787 : 			case 425:
; 5788 : 			case 426:
; 5789 : 			case 427:
; 5790 : 			case 428:
; 5791 : 			case 429:
; 5792 : 			case 430:
; 5793 : 			case 431:
; 5794 : 				break;

  0217b	e9 16 04 00 00	 jmp	 $LN20@P_SpawnSpe
$LN325@P_SpawnSpe:

; 5795 : 
; 5796 : 			// 500 is used for a scroller
; 5797 : 			// 501 is used for a scroller
; 5798 : 			// 502 is used for a scroller
; 5799 : 			// 503 is used for a scroller
; 5800 : 			// 504 is used for a scroller
; 5801 : 			// 505 is used for a scroller
; 5802 : 			// 510 is used for a scroller
; 5803 : 			// 511 is used for a scroller
; 5804 : 			// 512 is used for a scroller
; 5805 : 			// 513 is used for a scroller
; 5806 : 			// 514 is used for a scroller
; 5807 : 			// 515 is used for a scroller
; 5808 : 			// 520 is used for a scroller
; 5809 : 			// 521 is used for a scroller
; 5810 : 			// 522 is used for a scroller
; 5811 : 			// 523 is used for a scroller
; 5812 : 			// 524 is used for a scroller
; 5813 : 			// 525 is used for a scroller
; 5814 : 			// 530 is used for a scroller
; 5815 : 			// 531 is used for a scroller
; 5816 : 			// 532 is used for a scroller
; 5817 : 			// 533 is used for a scroller
; 5818 : 			// 534 is used for a scroller
; 5819 : 			// 535 is used for a scroller
; 5820 : 			// 540 is used for friction
; 5821 : 			// 541 is used for wind
; 5822 : 			// 542 is used for upwards wind
; 5823 : 			// 543 is used for downwards wind
; 5824 : 			// 544 is used for current
; 5825 : 			// 545 is used for upwards current
; 5826 : 			// 546 is used for downwards current
; 5827 : 			// 547 is used for push/pull
; 5828 : 
; 5829 : 			case 600: // floor lighting independently (e.g. lava)
; 5830 : 				sec = sides[*lines[i].sidenum].sector-sectors;

  02180	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02184	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  0218a	b9 02 00 00 00	 mov	 ecx, 2
  0218f	6b d1 00	 imul	 edx, ecx, 0
  02192	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  02197	6b c8 1c	 imul	 ecx, eax, 28
  0219a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  021a0	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  021a4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  021aa	99		 cdq
  021ab	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  021b0	f7 f9		 idiv	 ecx
  021b2	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5831 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  021b5	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN79@P_SpawnSpe:
  021bc	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  021bf	50		 push	 eax
  021c0	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  021c4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  021ca	51		 push	 ecx
  021cb	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  021d0	83 c4 08	 add	 esp, 8
  021d3	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  021d6	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  021da	7c 16		 jl	 SHORT $LN80@P_SpawnSpe

; 5832 : 					sectors[s].floorlightsec = (INT32)sec;

  021dc	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  021e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  021e9	8b 55 ec	 mov	 edx, DWORD PTR _sec$6[ebp]
  021ec	89 54 01 6c	 mov	 DWORD PTR [ecx+eax+108], edx
  021f0	eb ca		 jmp	 SHORT $LN79@P_SpawnSpe
$LN80@P_SpawnSpe:

; 5833 : 				break;

  021f2	e9 9f 03 00 00	 jmp	 $LN20@P_SpawnSpe
$LN326@P_SpawnSpe:

; 5834 : 
; 5835 : 			case 601: // ceiling lighting independently
; 5836 : 				sec = sides[*lines[i].sidenum].sector-sectors;

  021f7	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  021fb	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  02201	b9 02 00 00 00	 mov	 ecx, 2
  02206	6b d1 00	 imul	 edx, ecx, 0
  02209	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  0220e	6b c8 1c	 imul	 ecx, eax, 28
  02211	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  02217	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  0221b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  02221	99		 cdq
  02222	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  02227	f7 f9		 idiv	 ecx
  02229	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5837 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  0222c	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN82@P_SpawnSpe:
  02233	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  02236	50		 push	 eax
  02237	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0223b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  02241	51		 push	 ecx
  02242	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  02247	83 c4 08	 add	 esp, 8
  0224a	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  0224d	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  02251	7c 16		 jl	 SHORT $LN83@P_SpawnSpe

; 5838 : 					sectors[s].ceilinglightsec = (INT32)sec;

  02253	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  0225a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  02260	8b 55 ec	 mov	 edx, DWORD PTR _sec$6[ebp]
  02263	89 54 01 70	 mov	 DWORD PTR [ecx+eax+112], edx
  02267	eb ca		 jmp	 SHORT $LN82@P_SpawnSpe
$LN83@P_SpawnSpe:

; 5839 : 				break;

  02269	e9 28 03 00 00	 jmp	 $LN20@P_SpawnSpe
$LN327@P_SpawnSpe:

; 5840 : 
; 5841 : 			case 602: // Adjustable pulsating light
; 5842 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  0226e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02272	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  02278	b9 02 00 00 00	 mov	 ecx, 2
  0227d	6b d1 00	 imul	 edx, ecx, 0
  02280	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  02285	6b c8 1c	 imul	 ecx, eax, 28
  02288	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0228e	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  02292	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  02298	99		 cdq
  02299	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0229e	f7 f9		 idiv	 ecx
  022a0	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5843 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  022a3	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN85@P_SpawnSpe:
  022aa	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  022ad	50		 push	 eax
  022ae	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  022b2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  022b8	51		 push	 ecx
  022b9	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  022be	83 c4 08	 add	 esp, 8
  022c1	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  022c4	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  022c8	7c 50		 jl	 SHORT $LN86@P_SpawnSpe

; 5844 : 					P_SpawnAdjustableGlowingLight(&sectors[sec], &sectors[s],

  022ca	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  022ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  022d4	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  022d8	52		 push	 edx
  022d9	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  022dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  022e3	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  022e7	52		 push	 edx
  022e8	e8 00 00 00 00	 call	 _P_AproxDistance
  022ed	83 c4 08	 add	 esp, 8
  022f0	c1 f8 10	 sar	 eax, 16			; 00000010H
  022f3	50		 push	 eax
  022f4	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  022fb	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  02301	50		 push	 eax
  02302	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  02309	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0230f	51		 push	 ecx
  02310	e8 00 00 00 00	 call	 _P_SpawnAdjustableGlowingLight
  02315	83 c4 0c	 add	 esp, 12			; 0000000cH
  02318	eb 90		 jmp	 SHORT $LN85@P_SpawnSpe
$LN86@P_SpawnSpe:

; 5845 : 						P_AproxDistance(lines[i].dx, lines[i].dy)>>FRACBITS);
; 5846 : 				break;

  0231a	e9 77 02 00 00	 jmp	 $LN20@P_SpawnSpe
$LN328@P_SpawnSpe:

; 5847 : 
; 5848 : 			case 603: // Adjustable flickering light
; 5849 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  0231f	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02323	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  02329	b9 02 00 00 00	 mov	 ecx, 2
  0232e	6b d1 00	 imul	 edx, ecx, 0
  02331	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  02336	6b c8 1c	 imul	 ecx, eax, 28
  02339	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  0233f	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  02343	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  02349	99		 cdq
  0234a	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0234f	f7 f9		 idiv	 ecx
  02351	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5850 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  02354	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN88@P_SpawnSpe:
  0235b	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  0235e	50		 push	 eax
  0235f	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  02363	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  02369	51		 push	 ecx
  0236a	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  0236f	83 c4 08	 add	 esp, 8
  02372	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  02375	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  02379	7c 50		 jl	 SHORT $LN89@P_SpawnSpe

; 5851 : 					P_SpawnAdjustableFireFlicker(&sectors[sec], &sectors[s],

  0237b	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0237f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  02385	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  02389	52		 push	 edx
  0238a	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0238e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  02394	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  02398	52		 push	 edx
  02399	e8 00 00 00 00	 call	 _P_AproxDistance
  0239e	83 c4 08	 add	 esp, 8
  023a1	c1 f8 10	 sar	 eax, 16			; 00000010H
  023a4	50		 push	 eax
  023a5	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  023ac	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  023b2	50		 push	 eax
  023b3	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  023ba	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  023c0	51		 push	 ecx
  023c1	e8 00 00 00 00	 call	 _P_SpawnAdjustableFireFlicker
  023c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  023c9	eb 90		 jmp	 SHORT $LN88@P_SpawnSpe
$LN89@P_SpawnSpe:

; 5852 : 						P_AproxDistance(lines[i].dx, lines[i].dy)>>FRACBITS);
; 5853 : 				break;

  023cb	e9 c6 01 00 00	 jmp	 $LN20@P_SpawnSpe
$LN329@P_SpawnSpe:

; 5854 : 
; 5855 : 			case 604: // Adjustable Blinking Light (unsynchronized)
; 5856 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  023d0	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  023d4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  023da	b9 02 00 00 00	 mov	 ecx, 2
  023df	6b d1 00	 imul	 edx, ecx, 0
  023e2	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  023e7	6b c8 1c	 imul	 ecx, eax, 28
  023ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  023f0	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  023f4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  023fa	99		 cdq
  023fb	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  02400	f7 f9		 idiv	 ecx
  02402	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5857 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  02405	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN91@P_SpawnSpe:
  0240c	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  0240f	50		 push	 eax
  02410	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  02414	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  0241a	51		 push	 ecx
  0241b	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  02420	83 c4 08	 add	 esp, 8
  02423	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  02426	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  0242a	7c 5e		 jl	 SHORT $LN92@P_SpawnSpe

; 5858 : 					P_SpawnAdjustableStrobeFlash(&sectors[sec], &sectors[s],

  0242c	6a 00		 push	 0
  0242e	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02432	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  02438	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0243c	52		 push	 edx
  0243d	e8 00 00 00 00	 call	 _abs
  02442	83 c4 04	 add	 esp, 4
  02445	c1 f8 10	 sar	 eax, 16			; 00000010H
  02448	50		 push	 eax
  02449	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0244d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  02453	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  02457	52		 push	 edx
  02458	e8 00 00 00 00	 call	 _abs
  0245d	83 c4 04	 add	 esp, 4
  02460	c1 f8 10	 sar	 eax, 16			; 00000010H
  02463	50		 push	 eax
  02464	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  0246b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  02471	50		 push	 eax
  02472	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  02479	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0247f	51		 push	 ecx
  02480	e8 00 00 00 00	 call	 _P_SpawnAdjustableStrobeFlash
  02485	83 c4 14	 add	 esp, 20			; 00000014H
  02488	eb 82		 jmp	 SHORT $LN91@P_SpawnSpe
$LN92@P_SpawnSpe:

; 5859 : 						abs(lines[i].dx)>>FRACBITS, abs(lines[i].dy)>>FRACBITS, false);
; 5860 : 				break;

  0248a	e9 07 01 00 00	 jmp	 $LN20@P_SpawnSpe
$LN330@P_SpawnSpe:

; 5861 : 
; 5862 : 			case 605: // Adjustable Blinking Light (synchronized)
; 5863 : 				sec = sides[*lines[i].sidenum].sector - sectors;

  0248f	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02493	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  02499	b9 02 00 00 00	 mov	 ecx, 2
  0249e	6b d1 00	 imul	 edx, ecx, 0
  024a1	0f b7 44 10 16	 movzx	 eax, WORD PTR [eax+edx+22]
  024a6	6b c8 1c	 imul	 ecx, eax, 28
  024a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  024af	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  024b3	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _sectors
  024b9	99		 cdq
  024ba	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  024bf	f7 f9		 idiv	 ecx
  024c1	89 45 ec	 mov	 DWORD PTR _sec$6[ebp], eax

; 5864 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  024c4	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN94@P_SpawnSpe:
  024cb	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  024ce	50		 push	 eax
  024cf	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  024d3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  024d9	51		 push	 ecx
  024da	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  024df	83 c4 08	 add	 esp, 8
  024e2	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  024e5	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  024e9	7c 5e		 jl	 SHORT $LN95@P_SpawnSpe

; 5865 : 					P_SpawnAdjustableStrobeFlash(&sectors[sec], &sectors[s],

  024eb	6a 01		 push	 1
  024ed	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  024f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  024f7	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  024fb	52		 push	 edx
  024fc	e8 00 00 00 00	 call	 _abs
  02501	83 c4 04	 add	 esp, 4
  02504	c1 f8 10	 sar	 eax, 16			; 00000010H
  02507	50		 push	 eax
  02508	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0250c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  02512	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  02516	52		 push	 edx
  02517	e8 00 00 00 00	 call	 _abs
  0251c	83 c4 04	 add	 esp, 4
  0251f	c1 f8 10	 sar	 eax, 16			; 00000010H
  02522	50		 push	 eax
  02523	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  0252a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  02530	50		 push	 eax
  02531	69 4d ec f8 00
	00 00		 imul	 ecx, DWORD PTR _sec$6[ebp], 248
  02538	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  0253e	51		 push	 ecx
  0253f	e8 00 00 00 00	 call	 _P_SpawnAdjustableStrobeFlash
  02544	83 c4 14	 add	 esp, 20			; 00000014H
  02547	eb 82		 jmp	 SHORT $LN94@P_SpawnSpe
$LN95@P_SpawnSpe:

; 5866 : 						abs(lines[i].dx)>>FRACBITS, abs(lines[i].dy)>>FRACBITS, true);
; 5867 : 				break;

  02549	eb 4b		 jmp	 SHORT $LN20@P_SpawnSpe
$LN331@P_SpawnSpe:

; 5868 : 
; 5869 : 			case 606: // HACK! Copy colormaps. Just plain colormaps.
; 5870 : 				for (s = -1; (s = P_FindSectorFromLineTag(lines + i, s)) >= 0 ;)

  0254b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _s$7[ebp], -1
$LN97@P_SpawnSpe:
  02552	8b 45 f0	 mov	 eax, DWORD PTR _s$7[ebp]
  02555	50		 push	 eax
  02556	6b 4d f8 4c	 imul	 ecx, DWORD PTR _i$[ebp], 76
  0255a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  02560	51		 push	 ecx
  02561	e8 00 00 00 00	 call	 _P_FindSectorFromLineTag
  02566	83 c4 08	 add	 esp, 8
  02569	89 45 f0	 mov	 DWORD PTR _s$7[ebp], eax
  0256c	83 7d f0 00	 cmp	 DWORD PTR _s$7[ebp], 0
  02570	7c 24		 jl	 SHORT $LN98@P_SpawnSpe

; 5871 : 					sectors[s].midmap = lines[i].frontsector->midmap;

  02572	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  02576	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  0257c	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  02580	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _s$7[ebp], 248
  02587	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0258d	8b 52 7c	 mov	 edx, DWORD PTR [edx+124]
  02590	89 54 01 7c	 mov	 DWORD PTR [ecx+eax+124], edx
  02594	eb bc		 jmp	 SHORT $LN97@P_SpawnSpe
$LN98@P_SpawnSpe:
$LN332@P_SpawnSpe:
$LN20@P_SpawnSpe:

; 5872 : 				break;
; 5873 : 
; 5874 : 			default:
; 5875 : 				break;
; 5876 : 		}
; 5877 : 	}

  02596	e9 9c dd ff ff	 jmp	 $LN17@P_SpawnSpe
$LN18@P_SpawnSpe:

; 5878 : 
; 5879 : #ifdef POLYOBJECTS
; 5880 : 	// haleyjd 02/20/06: spawn polyobjects
; 5881 : 	Polyobj_InitLevel();

  0259b	e8 00 00 00 00	 call	 _Polyobj_InitLevel
  025a0	90		 npad	 1

; 5882 : 
; 5883 : 	for (i = 0; i < numlines; i++)

  025a1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  025a8	eb 09		 jmp	 SHORT $LN102@P_SpawnSpe
$LN100@P_SpawnSpe:
  025aa	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  025ad	83 c0 01	 add	 eax, 1
  025b0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN102@P_SpawnSpe:
  025b3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  025b6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numlines
  025bc	73 2f		 jae	 SHORT $LN101@P_SpawnSpe

; 5884 : 	{
; 5885 : 		switch (lines[i].special)

  025be	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  025c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  025c8	0f bf 54 01 12	 movsx	 edx, WORD PTR [ecx+eax+18]
  025cd	89 55 94	 mov	 DWORD PTR tv1750[ebp], edx
  025d0	83 7d 94 1e	 cmp	 DWORD PTR tv1750[ebp], 30 ; 0000001eH
  025d4	74 02		 je	 SHORT $LN333@P_SpawnSpe
  025d6	eb 13		 jmp	 SHORT $LN103@P_SpawnSpe
$LN333@P_SpawnSpe:

; 5886 : 		{
; 5887 : 			case 30: // Polyobj_Flag
; 5888 : 				EV_DoPolyObjFlag(&lines[i]);

  025d8	6b 45 f8 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  025dc	03 05 00 00 00
	00		 add	 eax, DWORD PTR _lines
  025e2	50		 push	 eax
  025e3	e8 00 00 00 00	 call	 _EV_DoPolyObjFlag
  025e8	83 c4 04	 add	 esp, 4
$LN103@P_SpawnSpe:

; 5889 : 				break;
; 5890 : 		}
; 5891 : 	}

  025eb	eb bd		 jmp	 SHORT $LN100@P_SpawnSpe
$LN101@P_SpawnSpe:

; 5892 : #endif
; 5893 : 
; 5894 : 	P_RunLevelLoadExecutors();

  025ed	e8 00 00 00 00	 call	 _P_RunLevelLoadExecutors
  025f2	90		 npad	 1

; 5895 : }

  025f3	5f		 pop	 edi
  025f4	5e		 pop	 esi
  025f5	5b		 pop	 ebx
  025f6	8b e5		 mov	 esp, ebp
  025f8	5d		 pop	 ebp
  025f9	c3		 ret	 0
  025fa	66 90		 npad	 2
$LN340@P_SpawnSpe:
  025fc	00 00 00 00	 DD	 $LN128@P_SpawnSpe
  02600	00 00 00 00	 DD	 $LN134@P_SpawnSpe
  02604	00 00 00 00	 DD	 $LN135@P_SpawnSpe
  02608	00 00 00 00	 DD	 $LN142@P_SpawnSpe
  0260c	00 00 00 00	 DD	 $LN148@P_SpawnSpe
  02610	00 00 00 00	 DD	 $LN149@P_SpawnSpe
  02614	00 00 00 00	 DD	 $LN150@P_SpawnSpe
  02618	00 00 00 00	 DD	 $LN151@P_SpawnSpe
  0261c	00 00 00 00	 DD	 $LN152@P_SpawnSpe
  02620	00 00 00 00	 DD	 $LN155@P_SpawnSpe
  02624	00 00 00 00	 DD	 $LN158@P_SpawnSpe
  02628	00 00 00 00	 DD	 $LN160@P_SpawnSpe
  0262c	00 00 00 00	 DD	 $LN163@P_SpawnSpe
  02630	00 00 00 00	 DD	 $LN164@P_SpawnSpe
  02634	00 00 00 00	 DD	 $LN165@P_SpawnSpe
  02638	00 00 00 00	 DD	 $LN166@P_SpawnSpe
  0263c	00 00 00 00	 DD	 $LN167@P_SpawnSpe
  02640	00 00 00 00	 DD	 $LN168@P_SpawnSpe
  02644	00 00 00 00	 DD	 $LN172@P_SpawnSpe
  02648	00 00 00 00	 DD	 $LN173@P_SpawnSpe
  0264c	00 00 00 00	 DD	 $LN174@P_SpawnSpe
  02650	00 00 00 00	 DD	 $LN176@P_SpawnSpe
  02654	00 00 00 00	 DD	 $LN177@P_SpawnSpe
  02658	00 00 00 00	 DD	 $LN179@P_SpawnSpe
  0265c	00 00 00 00	 DD	 $LN180@P_SpawnSpe
  02660	00 00 00 00	 DD	 $LN184@P_SpawnSpe
  02664	00 00 00 00	 DD	 $LN188@P_SpawnSpe
  02668	00 00 00 00	 DD	 $LN192@P_SpawnSpe
  0266c	00 00 00 00	 DD	 $LN196@P_SpawnSpe
  02670	00 00 00 00	 DD	 $LN198@P_SpawnSpe
  02674	00 00 00 00	 DD	 $LN201@P_SpawnSpe
  02678	00 00 00 00	 DD	 $LN204@P_SpawnSpe
  0267c	00 00 00 00	 DD	 $LN206@P_SpawnSpe
  02680	00 00 00 00	 DD	 $LN209@P_SpawnSpe
  02684	00 00 00 00	 DD	 $LN212@P_SpawnSpe
  02688	00 00 00 00	 DD	 $LN213@P_SpawnSpe
  0268c	00 00 00 00	 DD	 $LN215@P_SpawnSpe
  02690	00 00 00 00	 DD	 $LN216@P_SpawnSpe
  02694	00 00 00 00	 DD	 $LN217@P_SpawnSpe
  02698	00 00 00 00	 DD	 $LN218@P_SpawnSpe
  0269c	00 00 00 00	 DD	 $LN219@P_SpawnSpe
  026a0	00 00 00 00	 DD	 $LN221@P_SpawnSpe
  026a4	00 00 00 00	 DD	 $LN223@P_SpawnSpe
  026a8	00 00 00 00	 DD	 $LN225@P_SpawnSpe
  026ac	00 00 00 00	 DD	 $LN227@P_SpawnSpe
  026b0	00 00 00 00	 DD	 $LN228@P_SpawnSpe
  026b4	00 00 00 00	 DD	 $LN229@P_SpawnSpe
  026b8	00 00 00 00	 DD	 $LN230@P_SpawnSpe
  026bc	00 00 00 00	 DD	 $LN231@P_SpawnSpe
  026c0	00 00 00 00	 DD	 $LN232@P_SpawnSpe
  026c4	00 00 00 00	 DD	 $LN233@P_SpawnSpe
  026c8	00 00 00 00	 DD	 $LN234@P_SpawnSpe
  026cc	00 00 00 00	 DD	 $LN235@P_SpawnSpe
  026d0	00 00 00 00	 DD	 $LN236@P_SpawnSpe
  026d4	00 00 00 00	 DD	 $LN238@P_SpawnSpe
  026d8	00 00 00 00	 DD	 $LN240@P_SpawnSpe
  026dc	00 00 00 00	 DD	 $LN241@P_SpawnSpe
  026e0	00 00 00 00	 DD	 $LN242@P_SpawnSpe
  026e4	00 00 00 00	 DD	 $LN244@P_SpawnSpe
  026e8	00 00 00 00	 DD	 $LN245@P_SpawnSpe
  026ec	00 00 00 00	 DD	 $LN247@P_SpawnSpe
  026f0	00 00 00 00	 DD	 $LN249@P_SpawnSpe
  026f4	00 00 00 00	 DD	 $LN332@P_SpawnSpe
$LN339@P_SpawnSpe:
  026f8	00		 DB	 0
  026f9	3e		 DB	 62			; 0000003eH
  026fa	3e		 DB	 62			; 0000003eH
  026fb	3e		 DB	 62			; 0000003eH
  026fc	01		 DB	 1
  026fd	3e		 DB	 62			; 0000003eH
  026fe	02		 DB	 2
  026ff	03		 DB	 3
  02700	3e		 DB	 62			; 0000003eH
  02701	04		 DB	 4
  02702	3e		 DB	 62			; 0000003eH
  02703	3e		 DB	 62			; 0000003eH
  02704	3e		 DB	 62			; 0000003eH
  02705	3e		 DB	 62			; 0000003eH
  02706	3e		 DB	 62			; 0000003eH
  02707	3e		 DB	 62			; 0000003eH
  02708	3e		 DB	 62			; 0000003eH
  02709	3e		 DB	 62			; 0000003eH
  0270a	3e		 DB	 62			; 0000003eH
  0270b	3e		 DB	 62			; 0000003eH
  0270c	3e		 DB	 62			; 0000003eH
  0270d	3e		 DB	 62			; 0000003eH
  0270e	3e		 DB	 62			; 0000003eH
  0270f	3e		 DB	 62			; 0000003eH
  02710	3e		 DB	 62			; 0000003eH
  02711	3e		 DB	 62			; 0000003eH
  02712	3e		 DB	 62			; 0000003eH
  02713	3e		 DB	 62			; 0000003eH
  02714	3e		 DB	 62			; 0000003eH
  02715	3e		 DB	 62			; 0000003eH
  02716	3e		 DB	 62			; 0000003eH
  02717	3e		 DB	 62			; 0000003eH
  02718	3e		 DB	 62			; 0000003eH
  02719	3e		 DB	 62			; 0000003eH
  0271a	3e		 DB	 62			; 0000003eH
  0271b	3e		 DB	 62			; 0000003eH
  0271c	3e		 DB	 62			; 0000003eH
  0271d	3e		 DB	 62			; 0000003eH
  0271e	3e		 DB	 62			; 0000003eH
  0271f	3e		 DB	 62			; 0000003eH
  02720	3e		 DB	 62			; 0000003eH
  02721	3e		 DB	 62			; 0000003eH
  02722	3e		 DB	 62			; 0000003eH
  02723	3e		 DB	 62			; 0000003eH
  02724	3e		 DB	 62			; 0000003eH
  02725	3e		 DB	 62			; 0000003eH
  02726	3e		 DB	 62			; 0000003eH
  02727	3e		 DB	 62			; 0000003eH
  02728	3e		 DB	 62			; 0000003eH
  02729	05		 DB	 5
  0272a	06		 DB	 6
  0272b	07		 DB	 7
  0272c	08		 DB	 8
  0272d	08		 DB	 8
  0272e	09		 DB	 9
  0272f	0a		 DB	 10			; 0000000aH
  02730	0a		 DB	 10			; 0000000aH
  02731	0b		 DB	 11			; 0000000bH
  02732	0c		 DB	 12			; 0000000cH
  02733	0d		 DB	 13			; 0000000dH
  02734	0e		 DB	 14			; 0000000eH
  02735	0f		 DB	 15			; 0000000fH
  02736	10		 DB	 16			; 00000010H
  02737	11		 DB	 17			; 00000011H
  02738	3e		 DB	 62			; 0000003eH
  02739	3e		 DB	 62			; 0000003eH
  0273a	3e		 DB	 62			; 0000003eH
  0273b	3e		 DB	 62			; 0000003eH
  0273c	3e		 DB	 62			; 0000003eH
  0273d	3e		 DB	 62			; 0000003eH
  0273e	3e		 DB	 62			; 0000003eH
  0273f	3e		 DB	 62			; 0000003eH
  02740	3e		 DB	 62			; 0000003eH
  02741	3e		 DB	 62			; 0000003eH
  02742	3e		 DB	 62			; 0000003eH
  02743	3e		 DB	 62			; 0000003eH
  02744	3e		 DB	 62			; 0000003eH
  02745	3e		 DB	 62			; 0000003eH
  02746	3e		 DB	 62			; 0000003eH
  02747	3e		 DB	 62			; 0000003eH
  02748	3e		 DB	 62			; 0000003eH
  02749	3e		 DB	 62			; 0000003eH
  0274a	3e		 DB	 62			; 0000003eH
  0274b	3e		 DB	 62			; 0000003eH
  0274c	3e		 DB	 62			; 0000003eH
  0274d	3e		 DB	 62			; 0000003eH
  0274e	3e		 DB	 62			; 0000003eH
  0274f	3e		 DB	 62			; 0000003eH
  02750	3e		 DB	 62			; 0000003eH
  02751	3e		 DB	 62			; 0000003eH
  02752	3e		 DB	 62			; 0000003eH
  02753	3e		 DB	 62			; 0000003eH
  02754	3e		 DB	 62			; 0000003eH
  02755	3e		 DB	 62			; 0000003eH
  02756	3e		 DB	 62			; 0000003eH
  02757	3e		 DB	 62			; 0000003eH
  02758	3e		 DB	 62			; 0000003eH
  02759	3e		 DB	 62			; 0000003eH
  0275a	3e		 DB	 62			; 0000003eH
  0275b	12		 DB	 18			; 00000012H
  0275c	13		 DB	 19			; 00000013H
  0275d	14		 DB	 20			; 00000014H
  0275e	15		 DB	 21			; 00000015H
  0275f	16		 DB	 22			; 00000016H
  02760	17		 DB	 23			; 00000017H
  02761	3e		 DB	 62			; 0000003eH
  02762	3e		 DB	 62			; 0000003eH
  02763	3e		 DB	 62			; 0000003eH
  02764	3e		 DB	 62			; 0000003eH
  02765	3e		 DB	 62			; 0000003eH
  02766	3e		 DB	 62			; 0000003eH
  02767	3e		 DB	 62			; 0000003eH
  02768	3e		 DB	 62			; 0000003eH
  02769	3e		 DB	 62			; 0000003eH
  0276a	3e		 DB	 62			; 0000003eH
  0276b	3e		 DB	 62			; 0000003eH
  0276c	3e		 DB	 62			; 0000003eH
  0276d	3e		 DB	 62			; 0000003eH
  0276e	3e		 DB	 62			; 0000003eH
  0276f	18		 DB	 24			; 00000018H
  02770	19		 DB	 25			; 00000019H
  02771	1a		 DB	 26			; 0000001aH
  02772	1b		 DB	 27			; 0000001bH
  02773	3e		 DB	 62			; 0000003eH
  02774	3e		 DB	 62			; 0000003eH
  02775	3e		 DB	 62			; 0000003eH
  02776	3e		 DB	 62			; 0000003eH
  02777	3e		 DB	 62			; 0000003eH
  02778	3e		 DB	 62			; 0000003eH
  02779	3e		 DB	 62			; 0000003eH
  0277a	3e		 DB	 62			; 0000003eH
  0277b	3e		 DB	 62			; 0000003eH
  0277c	3e		 DB	 62			; 0000003eH
  0277d	3e		 DB	 62			; 0000003eH
  0277e	3e		 DB	 62			; 0000003eH
  0277f	3e		 DB	 62			; 0000003eH
  02780	3e		 DB	 62			; 0000003eH
  02781	3e		 DB	 62			; 0000003eH
  02782	3e		 DB	 62			; 0000003eH
  02783	1c		 DB	 28			; 0000001cH
  02784	1d		 DB	 29			; 0000001dH
  02785	1e		 DB	 30			; 0000001eH
  02786	1f		 DB	 31			; 0000001fH
  02787	20		 DB	 32			; 00000020H
  02788	21		 DB	 33			; 00000021H
  02789	22		 DB	 34			; 00000022H
  0278a	3e		 DB	 62			; 0000003eH
  0278b	3e		 DB	 62			; 0000003eH
  0278c	3e		 DB	 62			; 0000003eH
  0278d	23		 DB	 35			; 00000023H
  0278e	23		 DB	 35			; 00000023H
  0278f	24		 DB	 36			; 00000024H
  02790	3e		 DB	 62			; 0000003eH
  02791	3e		 DB	 62			; 0000003eH
  02792	3e		 DB	 62			; 0000003eH
  02793	3e		 DB	 62			; 0000003eH
  02794	3e		 DB	 62			; 0000003eH
  02795	3e		 DB	 62			; 0000003eH
  02796	3e		 DB	 62			; 0000003eH
  02797	25		 DB	 37			; 00000025H
  02798	3e		 DB	 62			; 0000003eH
  02799	3e		 DB	 62			; 0000003eH
  0279a	3e		 DB	 62			; 0000003eH
  0279b	3e		 DB	 62			; 0000003eH
  0279c	3e		 DB	 62			; 0000003eH
  0279d	3e		 DB	 62			; 0000003eH
  0279e	3e		 DB	 62			; 0000003eH
  0279f	3e		 DB	 62			; 0000003eH
  027a0	3e		 DB	 62			; 0000003eH
  027a1	26		 DB	 38			; 00000026H
  027a2	27		 DB	 39			; 00000027H
  027a3	28		 DB	 40			; 00000028H
  027a4	29		 DB	 41			; 00000029H
  027a5	2a		 DB	 42			; 0000002aH
  027a6	2b		 DB	 43			; 0000002bH
  027a7	2c		 DB	 44			; 0000002cH
  027a8	2d		 DB	 45			; 0000002dH
  027a9	2e		 DB	 46			; 0000002eH
  027aa	2f		 DB	 47			; 0000002fH
  027ab	30		 DB	 48			; 00000030H
  027ac	3e		 DB	 62			; 0000003eH
  027ad	3e		 DB	 62			; 0000003eH
  027ae	3e		 DB	 62			; 0000003eH
  027af	3e		 DB	 62			; 0000003eH
  027b0	3e		 DB	 62			; 0000003eH
  027b1	3e		 DB	 62			; 0000003eH
  027b2	3e		 DB	 62			; 0000003eH
  027b3	3e		 DB	 62			; 0000003eH
  027b4	3e		 DB	 62			; 0000003eH
  027b5	31		 DB	 49			; 00000031H
  027b6	32		 DB	 50			; 00000032H
  027b7	33		 DB	 51			; 00000033H
  027b8	34		 DB	 52			; 00000034H
  027b9	35		 DB	 53			; 00000035H
  027ba	36		 DB	 54			; 00000036H
  027bb	3e		 DB	 62			; 0000003eH
  027bc	3e		 DB	 62			; 0000003eH
  027bd	3e		 DB	 62			; 0000003eH
  027be	3e		 DB	 62			; 0000003eH
  027bf	37		 DB	 55			; 00000037H
  027c0	38		 DB	 56			; 00000038H
  027c1	39		 DB	 57			; 00000039H
  027c2	3e		 DB	 62			; 0000003eH
  027c3	3e		 DB	 62			; 0000003eH
  027c4	3e		 DB	 62			; 0000003eH
  027c5	3e		 DB	 62			; 0000003eH
  027c6	3e		 DB	 62			; 0000003eH
  027c7	3e		 DB	 62			; 0000003eH
  027c8	3e		 DB	 62			; 0000003eH
  027c9	3e		 DB	 62			; 0000003eH
  027ca	3e		 DB	 62			; 0000003eH
  027cb	3e		 DB	 62			; 0000003eH
  027cc	3e		 DB	 62			; 0000003eH
  027cd	3e		 DB	 62			; 0000003eH
  027ce	3e		 DB	 62			; 0000003eH
  027cf	3e		 DB	 62			; 0000003eH
  027d0	3e		 DB	 62			; 0000003eH
  027d1	3e		 DB	 62			; 0000003eH
  027d2	3e		 DB	 62			; 0000003eH
  027d3	3a		 DB	 58			; 0000003aH
  027d4	3b		 DB	 59			; 0000003bH
  027d5	3c		 DB	 60			; 0000003cH
  027d6	3d		 DB	 61			; 0000003dH
  027d7	90		 npad	 1
$LN342@P_SpawnSpe:
  027d8	00 00 00 00	 DD	 $LN251@P_SpawnSpe
  027dc	00 00 00 00	 DD	 $LN252@P_SpawnSpe
  027e0	00 00 00 00	 DD	 $LN255@P_SpawnSpe
  027e4	00 00 00 00	 DD	 $LN256@P_SpawnSpe
  027e8	00 00 00 00	 DD	 $LN259@P_SpawnSpe
  027ec	00 00 00 00	 DD	 $LN260@P_SpawnSpe
  027f0	00 00 00 00	 DD	 $LN261@P_SpawnSpe
  027f4	00 00 00 00	 DD	 $LN264@P_SpawnSpe
  027f8	00 00 00 00	 DD	 $LN266@P_SpawnSpe
  027fc	00 00 00 00	 DD	 $LN285@P_SpawnSpe
  02800	00 00 00 00	 DD	 $LN280@P_SpawnSpe
  02804	00 00 00 00	 DD	 $LN282@P_SpawnSpe
  02808	00 00 00 00	 DD	 $LN289@P_SpawnSpe
  0280c	00 00 00 00	 DD	 $LN332@P_SpawnSpe
$LN341@P_SpawnSpe:
  02810	00		 DB	 0
  02811	01		 DB	 1
  02812	02		 DB	 2
  02813	03		 DB	 3
  02814	04		 DB	 4
  02815	05		 DB	 5
  02816	06		 DB	 6
  02817	07		 DB	 7
  02818	08		 DB	 8
  02819	0d		 DB	 13			; 0000000dH
  0281a	0d		 DB	 13			; 0000000dH
  0281b	0d		 DB	 13			; 0000000dH
  0281c	0d		 DB	 13			; 0000000dH
  0281d	0d		 DB	 13			; 0000000dH
  0281e	0d		 DB	 13			; 0000000dH
  0281f	0d		 DB	 13			; 0000000dH
  02820	0d		 DB	 13			; 0000000dH
  02821	0d		 DB	 13			; 0000000dH
  02822	0d		 DB	 13			; 0000000dH
  02823	0d		 DB	 13			; 0000000dH
  02824	0d		 DB	 13			; 0000000dH
  02825	0d		 DB	 13			; 0000000dH
  02826	0d		 DB	 13			; 0000000dH
  02827	0d		 DB	 13			; 0000000dH
  02828	0d		 DB	 13			; 0000000dH
  02829	0d		 DB	 13			; 0000000dH
  0282a	0d		 DB	 13			; 0000000dH
  0282b	0d		 DB	 13			; 0000000dH
  0282c	0d		 DB	 13			; 0000000dH
  0282d	0d		 DB	 13			; 0000000dH
  0282e	0d		 DB	 13			; 0000000dH
  0282f	0d		 DB	 13			; 0000000dH
  02830	0d		 DB	 13			; 0000000dH
  02831	0d		 DB	 13			; 0000000dH
  02832	0d		 DB	 13			; 0000000dH
  02833	0d		 DB	 13			; 0000000dH
  02834	0d		 DB	 13			; 0000000dH
  02835	0d		 DB	 13			; 0000000dH
  02836	0d		 DB	 13			; 0000000dH
  02837	0d		 DB	 13			; 0000000dH
  02838	0d		 DB	 13			; 0000000dH
  02839	0d		 DB	 13			; 0000000dH
  0283a	0d		 DB	 13			; 0000000dH
  0283b	0d		 DB	 13			; 0000000dH
  0283c	0d		 DB	 13			; 0000000dH
  0283d	0d		 DB	 13			; 0000000dH
  0283e	0d		 DB	 13			; 0000000dH
  0283f	0d		 DB	 13			; 0000000dH
  02840	0d		 DB	 13			; 0000000dH
  02841	0d		 DB	 13			; 0000000dH
  02842	09		 DB	 9
  02843	0d		 DB	 13			; 0000000dH
  02844	0d		 DB	 13			; 0000000dH
  02845	0d		 DB	 13			; 0000000dH
  02846	0d		 DB	 13			; 0000000dH
  02847	09		 DB	 9
  02848	0d		 DB	 13			; 0000000dH
  02849	0a		 DB	 10			; 0000000aH
  0284a	0b		 DB	 11			; 0000000bH
  0284b	09		 DB	 9
  0284c	0b		 DB	 11			; 0000000bH
  0284d	09		 DB	 9
  0284e	0c		 DB	 12			; 0000000cH
  0284f	90		 npad	 1
$LN343@P_SpawnSpe:
  02850	00 00 00 00	 DD	 $LN326@P_SpawnSpe
  02854	00 00 00 00	 DD	 $LN327@P_SpawnSpe
  02858	00 00 00 00	 DD	 $LN328@P_SpawnSpe
  0285c	00 00 00 00	 DD	 $LN329@P_SpawnSpe
  02860	00 00 00 00	 DD	 $LN330@P_SpawnSpe
  02864	00 00 00 00	 DD	 $LN331@P_SpawnSpe
_P_SpawnSpecials ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_SetupLevelFlatAnims
_TEXT	SEGMENT
_i$ = -4						; size = 4
_P_SetupLevelFlatAnims PROC				; COMDAT

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 348  : 	INT32 i;
; 349  : 
; 350  : 	// the original game flat anim sequences
; 351  : 	for (i = 0; anims[i].istexture != -1; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_SetupLev
$LN2@P_SetupLev:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_SetupLev:
  0001b	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _anims
  00025	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00029	83 fa ff	 cmp	 edx, -1
  0002c	74 20		 je	 SHORT $LN3@P_SetupLev

; 352  : 	{
; 353  : 		if (!anims[i].istexture)

  0002e	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _anims
  00038	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0003c	85 d2		 test	 edx, edx
  0003e	75 0c		 jne	 SHORT $LN5@P_SetupLev

; 354  : 			P_FindAnimatedFlat(i);

  00040	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _P_FindAnimatedFlat
  00049	83 c4 04	 add	 esp, 4
$LN5@P_SetupLev:

; 355  : 	}

  0004c	eb c4		 jmp	 SHORT $LN2@P_SetupLev
$LN3@P_SetupLev:

; 356  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_P_SetupLevelFlatAnims ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_spec.c
;	COMDAT _P_InitPicAnims
_TEXT	SEGMENT
_i$ = -4						; size = 4
_P_InitPicAnims PROC					; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 241  : 	// Init animation
; 242  : 	INT32 i;
; 243  : 
; 244  : 	if (W_CheckNumForName("ANIMATED") != LUMPERROR)

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_08ENOFCJPE@ANIMATED@
  0000e	e8 00 00 00 00	 call	 _W_CheckNumForName
  00013	83 c4 04	 add	 esp, 4
  00016	83 f8 ff	 cmp	 eax, -1
  00019	74 16		 je	 SHORT $LN8@P_InitPicA

; 245  : 		animdefs = (animdef_t *)W_CacheLumpName("ANIMATED", PU_STATIC);

  0001b	6a 01		 push	 1
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_08ENOFCJPE@ANIMATED@
  00022	e8 00 00 00 00	 call	 _W_CacheLumpName
  00027	83 c4 08	 add	 esp, 8
  0002a	a3 00 00 00 00	 mov	 DWORD PTR _animdefs, eax
  0002f	eb 0a		 jmp	 SHORT $LN9@P_InitPicA
$LN8@P_InitPicA:

; 246  : 	else
; 247  : 		animdefs = harddefs;

  00031	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _animdefs, OFFSET _harddefs
$LN9@P_InitPicA:

; 248  : 
; 249  : 	for (i = 0; animdefs[i].istexture != -1; i++, maxanims++);

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00042	eb 18		 jmp	 SHORT $LN4@P_InitPicA
$LN2@P_InitPicA:
  00044	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _maxanims
  00053	83 c1 01	 add	 ecx, 1
  00056	89 0d 00 00 00
	00		 mov	 DWORD PTR _maxanims, ecx
$LN4@P_InitPicA:
  0005c	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  00066	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0006a	83 fa ff	 cmp	 edx, -1
  0006d	74 02		 je	 SHORT $LN3@P_InitPicA
  0006f	eb d3		 jmp	 SHORT $LN2@P_InitPicA
$LN3@P_InitPicA:

; 250  : 
; 251  : 	if (anims)

  00071	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _anims, 0
  00078	74 0e		 je	 SHORT $LN10@P_InitPicA

; 252  : 		free(anims);

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR _anims
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _free
  00085	83 c4 04	 add	 esp, 4
$LN10@P_InitPicA:

; 253  : 
; 254  : 	anims = (anim_t *)malloc(sizeof (*anims)*(maxanims + 1));

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _maxanims
  0008d	83 c0 01	 add	 eax, 1
  00090	6b c8 14	 imul	 ecx, eax, 20
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _malloc
  00099	83 c4 04	 add	 esp, 4
  0009c	a3 00 00 00 00	 mov	 DWORD PTR _anims, eax

; 255  : 	if (!anims)

  000a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _anims, 0
  000a8	75 0d		 jne	 SHORT $LN11@P_InitPicA

; 256  : 		I_Error("No free memory for ANIMATED data");

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LGALMIEA@No?5free?5memory?5for?5ANIMATED?5dat@
  000af	e8 00 00 00 00	 call	 _I_Error
  000b4	83 c4 04	 add	 esp, 4
$LN11@P_InitPicA:

; 257  : 
; 258  : 	lastanim = anims;

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _anims
  000bc	a3 00 00 00 00	 mov	 DWORD PTR _lastanim, eax

; 259  : 	for (i = 0; animdefs[i].istexture !=-1; i++)

  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c8	eb 09		 jmp	 SHORT $LN7@P_InitPicA
$LN5@P_InitPicA:
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@P_InitPicA:
  000d3	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  000dd	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  000e1	83 fa ff	 cmp	 edx, -1
  000e4	0f 84 a5 01 00
	00		 je	 $LN6@P_InitPicA

; 260  : 	{
; 261  : 		if (animdefs[i].istexture)

  000ea	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  000f4	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  000f8	85 d2		 test	 edx, edx
  000fa	74 6f		 je	 SHORT $LN12@P_InitPicA

; 262  : 		{
; 263  : 			if (R_CheckTextureNumForName(animdefs[i].startname, 0xffff) == -1)

  000fc	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00101	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  0010b	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _R_CheckTextureNumForName
  00115	83 c4 08	 add	 esp, 8
  00118	83 f8 ff	 cmp	 eax, -1
  0011b	75 02		 jne	 SHORT $LN14@P_InitPicA

; 264  : 				continue;

  0011d	eb ab		 jmp	 SHORT $LN5@P_InitPicA
$LN14@P_InitPicA:

; 265  : 
; 266  : 			lastanim->picnum = R_TextureNumForName(animdefs[i].endname, 0xffff);

  0011f	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00124	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  0012e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 _R_TextureNumForName
  00138	83 c4 08	 add	 esp, 8
  0013b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  00141	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 267  : 			lastanim->basepic = R_TextureNumForName(animdefs[i].startname, 0xffff);

  00144	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00149	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  00153	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _R_TextureNumForName
  0015d	83 c4 08	 add	 esp, 8
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  00166	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 268  : 		}

  00169	eb 61		 jmp	 SHORT $LN13@P_InitPicA
$LN12@P_InitPicA:

; 269  : 		else
; 270  : 		{
; 271  : 			if ((W_CheckNumForName(animdefs[i].startname)) == LUMPERROR)

  0016b	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  00175	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 _W_CheckNumForName
  0017f	83 c4 04	 add	 esp, 4
  00182	83 f8 ff	 cmp	 eax, -1
  00185	75 05		 jne	 SHORT $LN15@P_InitPicA

; 272  : 				continue;

  00187	e9 3e ff ff ff	 jmp	 $LN5@P_InitPicA
$LN15@P_InitPicA:

; 273  : 
; 274  : 			lastanim->picnum = R_FlatNumForName(animdefs[i].endname);

  0018c	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  00196	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0019a	52		 push	 edx
  0019b	e8 00 00 00 00	 call	 _R_GetFlatNumForName
  001a0	83 c4 04	 add	 esp, 4
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  001a9	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 275  : 			lastanim->basepic = R_FlatNumForName(animdefs[i].startname);

  001ac	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  001b6	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 _R_GetFlatNumForName
  001c0	83 c4 04	 add	 esp, 4
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  001c9	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@P_InitPicA:

; 276  : 		}
; 277  : 
; 278  : 		lastanim->istexture = animdefs[i].istexture;

  001cc	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  001d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _animdefs
  001dc	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001df	88 01		 mov	 BYTE PTR [ecx], al

; 279  : 		lastanim->numpics = lastanim->picnum - lastanim->basepic + 1;

  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastanim
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  001ec	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ef	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  001f2	83 c2 01	 add	 edx, 1
  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastanim
  001fa	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 280  : 
; 281  : 		if (lastanim->numpics < 2)

  001fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastanim
  00202	83 78 0c 02	 cmp	 DWORD PTR [eax+12], 2
  00206	7d 39		 jge	 SHORT $LN16@P_InitPicA

; 282  : 		{
; 283  : 			free(anims);

  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR _anims
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 _free
  00213	83 c4 04	 add	 esp, 4

; 284  : 			I_Error("P_InitPicAnims: bad cycle from %s to %s",

  00216	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  00220	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00224	52		 push	 edx
  00225	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _animdefs
  0022f	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00233	52		 push	 edx
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NPDMFJCJ@P_InitPicAnims?3?5bad?5cycle?5from?5@
  00239	e8 00 00 00 00	 call	 _I_Error
  0023e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@P_InitPicA:

; 285  : 				animdefs[i].startname, animdefs[i].endname);
; 286  : 		}
; 287  : 
; 288  : 		if (animdefs == harddefs)

  00241	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _animdefs, OFFSET _harddefs
  0024b	75 19		 jne	 SHORT $LN17@P_InitPicA

; 289  : 			lastanim->speed = animdefs[i].speed * NEWTICRATERATIO;

  0024d	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  00251	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  00257	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _animdefs
  0025d	8b 44 02 13	 mov	 eax, DWORD PTR [edx+eax+19]
  00261	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00264	eb 17		 jmp	 SHORT $LN18@P_InitPicA
$LN17@P_InitPicA:

; 290  : 		else
; 291  : 			lastanim->speed = LONG(animdefs[i].speed) * NEWTICRATERATIO;

  00266	6b 45 fc 17	 imul	 eax, DWORD PTR _i$[ebp], 23
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lastanim
  00270	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _animdefs
  00276	8b 44 02 13	 mov	 eax, DWORD PTR [edx+eax+19]
  0027a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN18@P_InitPicA:

; 292  : 		lastanim++;

  0027d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastanim
  00282	83 c0 14	 add	 eax, 20			; 00000014H
  00285	a3 00 00 00 00	 mov	 DWORD PTR _lastanim, eax

; 293  : 	}

  0028a	e9 3b fe ff ff	 jmp	 $LN5@P_InitPicA
$LN6@P_InitPicA:

; 294  : 	lastanim->istexture = -1;

  0028f	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastanim
  00294	c6 00 ff	 mov	 BYTE PTR [eax], -1

; 295  : 
; 296  : 	if (animdefs != harddefs)

  00297	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _animdefs, OFFSET _harddefs
  002a1	74 10		 je	 SHORT $LN19@P_InitPicA

; 297  : 		Z_ChangeTag(animdefs, PU_CACHE);

  002a3	6a 65		 push	 101			; 00000065H
  002a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _animdefs
  002aa	50		 push	 eax
  002ab	e8 00 00 00 00	 call	 _Z_ChangeTag2
  002b0	83 c4 08	 add	 esp, 8
$LN19@P_InitPicA:

; 298  : }

  002b3	5f		 pop	 edi
  002b4	5e		 pop	 esi
  002b5	5b		 pop	 ebx
  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c3		 ret	 0
_P_InitPicAnims ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedInt
_TEXT	SEGMENT
_a$ = 8							; size = 4
_FixedInt PROC						; COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 222  : 	return FixedMul(a, 1);

  00009	6a 01		 push	 1
  0000b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _FixedMul
  00014	83 c4 08	 add	 esp, 8

; 223  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_FixedInt ENDP
_TEXT	ENDS
END
