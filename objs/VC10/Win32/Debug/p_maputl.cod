; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\p_maputl.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_opentop:DWORD
COMM	_openbottom:DWORD
COMM	_openrange:DWORD
COMM	_lowfloor:DWORD
COMM	_trace:BYTE:010H
_DATA	ENDS
PUBLIC	_P_PathTraverse
PUBLIC	_P_AproxDistance
PUBLIC	_P_ClosestPointOnLine
PUBLIC	_P_PointOnLineSide
PUBLIC	_P_MakeDivline
PUBLIC	_P_CameraLineOpening
PUBLIC	_P_InterceptVector
PUBLIC	_P_BoxOnLineSide
PUBLIC	_P_UnsetPrecipThingPosition
PUBLIC	_P_SetPrecipitationThingPosition
PUBLIC	_P_LineOpening
PUBLIC	_P_BlockLinesIterator
PUBLIC	_P_BlockThingsIterator
PUBLIC	_P_UnsetThingPosition
PUBLIC	_P_SetThingPosition
PUBLIC	??_C@_0CH@HHFBIKFP@P_BoxOnLineSide?3?5unknown?5slopet@ ; `string'
PUBLIC	??_C@_0EF@LFOMGHFI@P_SetUnsetThingPosition?3?5Tried?5@ ; `string'
PUBLIC	??_C@_0DO@COBEEHJD@P_SetThingPosition?3?5Tried?5to?5se@ ; `string'
EXTRN	_abs:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_P_CreatePrecipSecNodeList:PROC
EXTRN	_P_CreateSecNodeList:PROC
EXTRN	_R_PointToDist2:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_Z_ReallocAlign:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_polyblocklinks:DWORD
EXTRN	_camera:BYTE
EXTRN	_tmthing:DWORD
EXTRN	_sector_list:DWORD
EXTRN	_precipsector_list:DWORD
EXTRN	_blockmaplump:DWORD
EXTRN	_blockmap:DWORD
EXTRN	_bmapwidth:DWORD
EXTRN	_bmapheight:DWORD
EXTRN	_bmaporgx:DWORD
EXTRN	_bmaporgy:DWORD
EXTRN	_blocklinks:DWORD
EXTRN	_sectors:DWORD
EXTRN	_lines:DWORD
EXTRN	_validcount:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_intercepts DD	01H DUP (?)
_intercept_p DD	01H DUP (?)
_earlyout DD	01H DUP (?)
?max_intercepts@?1??P_CheckIntercepts@@9@9 DD 01H DUP (?) ; `P_CheckIntercepts'::`2'::max_intercepts
_BSS	ENDS
;	COMDAT ??_C@_0DO@COBEEHJD@P_SetThingPosition?3?5Tried?5to?5se@
CONST	SEGMENT
??_C@_0DO@COBEEHJD@P_SetThingPosition?3?5Tried?5to?5se@ DB 'P_SetThingPos'
	DB	'ition: Tried to set a thing that doesn''t exist!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@LFOMGHFI@P_SetUnsetThingPosition?3?5Tried?5@
CONST	SEGMENT
??_C@_0EF@LFOMGHFI@P_SetUnsetThingPosition?3?5Tried?5@ DB 'P_SetUnsetThin'
	DB	'gPosition: Tried to unset a thing that doesn''t exist!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HHFBIKFP@P_BoxOnLineSide?3?5unknown?5slopet@
CONST	SEGMENT
??_C@_0CH@HHFBIKFP@P_BoxOnLineSide?3?5unknown?5slopet@ DB 'P_BoxOnLineSid'
	DB	'e: unknown slopetype %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0170H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	016dH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_TraverseIntercepts
_TEXT	SEGMENT
tv68 = -84						; size = 4
_in$ = -16						; size = 4
_scan$ = -12						; size = 4
_dist$ = -8						; size = 4
_count$ = -4						; size = 4
_func$ = 8						; size = 4
_maxfrac$ = 12						; size = 4
_P_TraverseIntercepts PROC				; COMDAT

; 992  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 993  : 	size_t count;
; 994  : 	fixed_t dist;
; 995  : 	intercept_t *scan, *in = NULL;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _in$[ebp], 0

; 996  : 
; 997  : 	count = intercept_p - intercepts;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  00015	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _intercepts
  0001b	99		 cdq
  0001c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00021	f7 f9		 idiv	 ecx
  00023	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN2@P_Traverse:

; 998  : 
; 999  : 	while (count--)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00029	89 45 ac	 mov	 DWORD PTR tv68[ebp], eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0002f	83 e9 01	 sub	 ecx, 1
  00032	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00035	83 7d ac 00	 cmp	 DWORD PTR tv68[ebp], 0
  00039	74 6b		 je	 SHORT $LN3@P_Traverse

; 1000 : 	{
; 1001 : 		dist = INT32_MAX;

  0003b	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _dist$[ebp], 2147483647 ; 7fffffffH

; 1002 : 		for (scan = intercepts; scan < intercept_p; scan++)

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercepts
  00047	89 45 f4	 mov	 DWORD PTR _scan$[ebp], eax
  0004a	eb 09		 jmp	 SHORT $LN6@P_Traverse
$LN4@P_Traverse:
  0004c	8b 45 f4	 mov	 eax, DWORD PTR _scan$[ebp]
  0004f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00052	89 45 f4	 mov	 DWORD PTR _scan$[ebp], eax
$LN6@P_Traverse:
  00055	8b 45 f4	 mov	 eax, DWORD PTR _scan$[ebp]
  00058	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _intercept_p
  0005e	73 1a		 jae	 SHORT $LN5@P_Traverse

; 1003 : 		{
; 1004 : 			if (scan->frac < dist)

  00060	8b 45 f4	 mov	 eax, DWORD PTR _scan$[ebp]
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	3b 4d f8	 cmp	 ecx, DWORD PTR _dist$[ebp]
  00068	7d 0e		 jge	 SHORT $LN7@P_Traverse

; 1005 : 			{
; 1006 : 				dist = scan->frac;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _scan$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	89 4d f8	 mov	 DWORD PTR _dist$[ebp], ecx

; 1007 : 				in = scan;

  00072	8b 45 f4	 mov	 eax, DWORD PTR _scan$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR _in$[ebp], eax
$LN7@P_Traverse:

; 1008 : 			}
; 1009 : 		}

  00078	eb d2		 jmp	 SHORT $LN4@P_Traverse
$LN5@P_Traverse:

; 1010 : 
; 1011 : 		if (dist > maxfrac)

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _dist$[ebp]
  0007d	3b 45 0c	 cmp	 eax, DWORD PTR _maxfrac$[ebp]
  00080	7e 07		 jle	 SHORT $LN8@P_Traverse

; 1012 : 			return true; // Checked everything in range.

  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	eb 22		 jmp	 SHORT $LN1@P_Traverse
$LN8@P_Traverse:

; 1013 : 
; 1014 : 		if (!func(in))

  00089	8b 45 f0	 mov	 eax, DWORD PTR _in$[ebp]
  0008c	50		 push	 eax
  0008d	ff 55 08	 call	 DWORD PTR _func$[ebp]
  00090	83 c4 04	 add	 esp, 4
  00093	85 c0		 test	 eax, eax
  00095	75 04		 jne	 SHORT $LN9@P_Traverse

; 1015 : 			return false; // Don't bother going farther.

  00097	33 c0		 xor	 eax, eax
  00099	eb 10		 jmp	 SHORT $LN1@P_Traverse
$LN9@P_Traverse:

; 1016 : 
; 1017 : 		in->frac = INT32_MAX;

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _in$[ebp]
  0009e	c7 00 ff ff ff
	7f		 mov	 DWORD PTR [eax], 2147483647 ; 7fffffffH

; 1018 : 	}

  000a4	eb 80		 jmp	 SHORT $LN2@P_Traverse
$LN3@P_Traverse:

; 1019 : 
; 1020 : 	return true; // Everything was traversed.

  000a6	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_Traverse:

; 1021 : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_P_TraverseIntercepts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _PIT_AddThingIntercepts
_TEXT	SEGMENT
tv66 = -120						; size = 4
_dl$ = -52						; size = 16
_tracepositive$ = -36					; size = 4
_s2$ = -32						; size = 4
_s1$ = -28						; size = 4
_frac$ = -24						; size = 4
_py2$ = -20						; size = 4
_px2$ = -16						; size = 4
_py1$ = -12						; size = 4
_px1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_thing$ = 8						; size = 4
_PIT_AddThingIntercepts PROC				; COMDAT

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 935  : 	fixed_t px1, py1, px2, py2, frac;
; 936  : 	INT32 s1, s2;
; 937  : 	boolean tracepositive;
; 938  : 	divline_t dl;
; 939  : 
; 940  : 	tracepositive = (trace.dx ^ trace.dy) > 0;

  00013	a1 08 00 00 00	 mov	 eax, DWORD PTR _trace+8
  00018	33 05 0c 00 00
	00		 xor	 eax, DWORD PTR _trace+12
  0001e	7e 09		 jle	 SHORT $LN7@PIT_AddThi
  00020	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00027	eb 07		 jmp	 SHORT $LN8@PIT_AddThi
$LN7@PIT_AddThi:
  00029	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN8@PIT_AddThi:
  00030	8b 4d 88	 mov	 ecx, DWORD PTR tv66[ebp]
  00033	89 4d dc	 mov	 DWORD PTR _tracepositive$[ebp], ecx

; 941  : 
; 942  : 	// check a corner to corner crossection for hit
; 943  : 	if (tracepositive)

  00036	83 7d dc 00	 cmp	 DWORD PTR _tracepositive$[ebp], 0
  0003a	74 3e		 je	 SHORT $LN2@PIT_AddThi

; 944  : 	{
; 945  : 		px1 = thing->x - thing->radius;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00042	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00045	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00048	89 55 f8	 mov	 DWORD PTR _px1$[ebp], edx

; 946  : 		py1 = thing->y + thing->radius;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0004e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00051	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00054	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00057	89 4d f4	 mov	 DWORD PTR _py1$[ebp], ecx

; 947  : 
; 948  : 		px2 = thing->x + thing->radius;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0005d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00060	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00063	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00066	89 4d f0	 mov	 DWORD PTR _px2$[ebp], ecx

; 949  : 		py2 = thing->y - thing->radius;

  00069	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0006f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00072	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00075	89 55 ec	 mov	 DWORD PTR _py2$[ebp], edx

; 950  : 	}

  00078	eb 3c		 jmp	 SHORT $LN3@PIT_AddThi
$LN2@PIT_AddThi:

; 951  : 	else
; 952  : 	{
; 953  : 		px1 = thing->x - thing->radius;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00080	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00083	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00086	89 55 f8	 mov	 DWORD PTR _px1$[ebp], edx

; 954  : 		py1 = thing->y - thing->radius;

  00089	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0008f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00092	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00095	89 55 f4	 mov	 DWORD PTR _py1$[ebp], edx

; 955  : 
; 956  : 		px2 = thing->x + thing->radius;

  00098	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0009b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0009e	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000a1	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  000a4	89 4d f0	 mov	 DWORD PTR _px2$[ebp], ecx

; 957  : 		py2 = thing->y + thing->radius;

  000a7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000aa	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ad	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000b0	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  000b3	89 4d ec	 mov	 DWORD PTR _py2$[ebp], ecx
$LN3@PIT_AddThi:

; 958  : 	}
; 959  : 
; 960  : 	s1 = P_PointOnDivlineSide(px1, py1, &trace);

  000b6	68 00 00 00 00	 push	 OFFSET _trace
  000bb	8b 45 f4	 mov	 eax, DWORD PTR _py1$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _px1$[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 _P_PointOnDivlineSide
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	89 45 e4	 mov	 DWORD PTR _s1$[ebp], eax

; 961  : 	s2 = P_PointOnDivlineSide(px2, py2, &trace);

  000ce	68 00 00 00 00	 push	 OFFSET _trace
  000d3	8b 45 ec	 mov	 eax, DWORD PTR _py2$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d f0	 mov	 ecx, DWORD PTR _px2$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _P_PointOnDivlineSide
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e3	89 45 e0	 mov	 DWORD PTR _s2$[ebp], eax

; 962  : 
; 963  : 	if (s1 == s2)

  000e6	8b 45 e4	 mov	 eax, DWORD PTR _s1$[ebp]
  000e9	3b 45 e0	 cmp	 eax, DWORD PTR _s2$[ebp]
  000ec	75 07		 jne	 SHORT $LN4@PIT_AddThi

; 964  : 		return true; // Line isn't crossed.

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	eb 78		 jmp	 SHORT $LN1@PIT_AddThi
$LN4@PIT_AddThi:

; 965  : 
; 966  : 	dl.x = px1;

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _px1$[ebp]
  000f8	89 45 cc	 mov	 DWORD PTR _dl$[ebp], eax

; 967  : 	dl.y = py1;

  000fb	8b 45 f4	 mov	 eax, DWORD PTR _py1$[ebp]
  000fe	89 45 d0	 mov	 DWORD PTR _dl$[ebp+4], eax

; 968  : 	dl.dx = px2 - px1;

  00101	8b 45 f0	 mov	 eax, DWORD PTR _px2$[ebp]
  00104	2b 45 f8	 sub	 eax, DWORD PTR _px1$[ebp]
  00107	89 45 d4	 mov	 DWORD PTR _dl$[ebp+8], eax

; 969  : 	dl.dy = py2 - py1;

  0010a	8b 45 ec	 mov	 eax, DWORD PTR _py2$[ebp]
  0010d	2b 45 f4	 sub	 eax, DWORD PTR _py1$[ebp]
  00110	89 45 d8	 mov	 DWORD PTR _dl$[ebp+12], eax

; 970  : 
; 971  : 	frac = P_InterceptVector(&trace, &dl);

  00113	8d 45 cc	 lea	 eax, DWORD PTR _dl$[ebp]
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET _trace
  0011c	e8 00 00 00 00	 call	 _P_InterceptVector
  00121	83 c4 08	 add	 esp, 8
  00124	89 45 e8	 mov	 DWORD PTR _frac$[ebp], eax

; 972  : 
; 973  : 	if (frac < 0)

  00127	83 7d e8 00	 cmp	 DWORD PTR _frac$[ebp], 0
  0012b	7d 07		 jge	 SHORT $LN5@PIT_AddThi

; 974  : 		return true; // Behind source.

  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	eb 39		 jmp	 SHORT $LN1@PIT_AddThi
$LN5@PIT_AddThi:

; 975  : 
; 976  : 	P_CheckIntercepts();

  00134	e8 00 00 00 00	 call	 _P_CheckIntercepts
  00139	90		 npad	 1

; 977  : 
; 978  : 	intercept_p->frac = frac;

  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  0013f	8b 4d e8	 mov	 ecx, DWORD PTR _frac$[ebp]
  00142	89 08		 mov	 DWORD PTR [eax], ecx

; 979  : 	intercept_p->isaline = false;

  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  00149	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 980  : 	intercept_p->d.thing = thing;

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  00155	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00158	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 981  : 	intercept_p++;

  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  00160	83 c0 0c	 add	 eax, 12			; 0000000cH
  00163	a3 00 00 00 00	 mov	 DWORD PTR _intercept_p, eax

; 982  : 
; 983  : 	return true; // Keep going.

  00168	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_AddThi:

; 984  : }

  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx
  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
_PIT_AddThingIntercepts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _PIT_AddLineIntercepts
_TEXT	SEGMENT
_dl$ = -32						; size = 16
_frac$ = -16						; size = 4
_s2$ = -12						; size = 4
_s1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ld$ = 8						; size = 4
_PIT_AddLineIntercepts PROC				; COMDAT

; 885  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 886  : 	INT32 s1, s2;
; 887  : 	fixed_t frac;
; 888  : 	divline_t dl;
; 889  : 
; 890  : 	// avoid precision problems with two routines
; 891  : 	if (trace.dx > FRACUNIT*16 || trace.dy > FRACUNIT*16
; 892  : 		|| trace.dx < -FRACUNIT*16 || trace.dy < -FRACUNIT*16)

  00013	81 3d 08 00 00
	00 00 00 10 00	 cmp	 DWORD PTR _trace+8, 1048576 ; 00100000H
  0001d	7f 24		 jg	 SHORT $LN4@PIT_AddLin
  0001f	81 3d 0c 00 00
	00 00 00 10 00	 cmp	 DWORD PTR _trace+12, 1048576 ; 00100000H
  00029	7f 18		 jg	 SHORT $LN4@PIT_AddLin
  0002b	81 3d 08 00 00
	00 00 00 f0 ff	 cmp	 DWORD PTR _trace+8, -1048576 ; fff00000H
  00035	7c 0c		 jl	 SHORT $LN4@PIT_AddLin
  00037	81 3d 0c 00 00
	00 00 00 f0 ff	 cmp	 DWORD PTR _trace+12, -1048576 ; fff00000H
  00041	7d 46		 jge	 SHORT $LN2@PIT_AddLin
$LN4@PIT_AddLin:

; 893  : 	{
; 894  : 		// Hurdler: crash here with phobia when you shoot
; 895  : 		// on the door next the stone bridge
; 896  : 		// stack overflow???
; 897  : 		s1 = P_PointOnDivlineSide(ld->v1->x, ld->v1->y, &trace);

  00043	68 00 00 00 00	 push	 OFFSET _trace
  00048	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00050	52		 push	 edx
  00051	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	8b 11		 mov	 edx, DWORD PTR [ecx]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 _P_PointOnDivlineSide
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	89 45 f8	 mov	 DWORD PTR _s1$[ebp], eax

; 898  : 		s2 = P_PointOnDivlineSide(ld->v2->x, ld->v2->y, &trace);

  00064	68 00 00 00 00	 push	 OFFSET _trace
  00069	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _P_PointOnDivlineSide
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	89 45 f4	 mov	 DWORD PTR _s2$[ebp], eax

; 899  : 	}

  00087	eb 46		 jmp	 SHORT $LN3@PIT_AddLin
$LN2@PIT_AddLin:

; 900  : 	else
; 901  : 	{
; 902  : 		s1 = P_PointOnLineSide(trace.x, trace.y, ld);

  00089	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0008c	50		 push	 eax
  0008d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _trace+4
  00093	51		 push	 ecx
  00094	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _trace
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 _P_PointOnLineSide
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	89 45 f8	 mov	 DWORD PTR _s1$[ebp], eax

; 903  : 		s2 = P_PointOnLineSide(trace.x+trace.dx, trace.y+trace.dy, ld);

  000a6	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000a9	50		 push	 eax
  000aa	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _trace+4
  000b0	03 0d 0c 00 00
	00		 add	 ecx, DWORD PTR _trace+12
  000b6	51		 push	 ecx
  000b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _trace
  000bd	03 15 08 00 00
	00		 add	 edx, DWORD PTR _trace+8
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _P_PointOnLineSide
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cc	89 45 f4	 mov	 DWORD PTR _s2$[ebp], eax
$LN3@PIT_AddLin:

; 904  : 	}
; 905  : 
; 906  : 	if (s1 == s2)

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _s1$[ebp]
  000d2	3b 45 f4	 cmp	 eax, DWORD PTR _s2$[ebp]
  000d5	75 0a		 jne	 SHORT $LN5@PIT_AddLin

; 907  : 		return true; // Line isn't crossed.

  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	e9 89 00 00 00	 jmp	 $LN1@PIT_AddLin
$LN5@PIT_AddLin:

; 908  : 
; 909  : 	// Hit the line.
; 910  : 	P_MakeDivline(ld, &dl);

  000e1	8d 45 e0	 lea	 eax, DWORD PTR _dl$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _P_MakeDivline
  000ee	83 c4 08	 add	 esp, 8

; 911  : 	frac = P_InterceptVector(&trace, &dl);

  000f1	8d 45 e0	 lea	 eax, DWORD PTR _dl$[ebp]
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET _trace
  000fa	e8 00 00 00 00	 call	 _P_InterceptVector
  000ff	83 c4 08	 add	 esp, 8
  00102	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax

; 912  : 
; 913  : 	if (frac < 0)

  00105	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00109	7d 07		 jge	 SHORT $LN6@PIT_AddLin

; 914  : 		return true; // Behind source.

  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	eb 58		 jmp	 SHORT $LN1@PIT_AddLin
$LN6@PIT_AddLin:

; 915  : 
; 916  : 	// Try to take an early out of the check.
; 917  : 	if (earlyout && frac < FRACUNIT && !ld->backsector)

  00112	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _earlyout, 0
  00119	74 16		 je	 SHORT $LN7@PIT_AddLin
  0011b	81 7d f0 00 00
	01 00		 cmp	 DWORD PTR _frac$[ebp], 65536 ; 00010000H
  00122	7d 0d		 jge	 SHORT $LN7@PIT_AddLin
  00124	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00127	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0012b	75 04		 jne	 SHORT $LN7@PIT_AddLin

; 918  : 		return false; // stop checking

  0012d	33 c0		 xor	 eax, eax
  0012f	eb 39		 jmp	 SHORT $LN1@PIT_AddLin
$LN7@PIT_AddLin:

; 919  : 
; 920  : 	P_CheckIntercepts();

  00131	e8 00 00 00 00	 call	 _P_CheckIntercepts
  00136	90		 npad	 1

; 921  : 
; 922  : 	intercept_p->frac = frac;

  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  0013c	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx

; 923  : 	intercept_p->isaline = true;

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  00146	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 924  : 	intercept_p->d.line = ld;

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  00152	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00155	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 925  : 	intercept_p++;

  00158	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  0015d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00160	a3 00 00 00 00	 mov	 DWORD PTR _intercept_p, eax

; 926  : 
; 927  : 	return true; // continue

  00165	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_AddLin:

; 928  : }

  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00170	33 cd		 xor	 ecx, ebp
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
_PIT_AddLineIntercepts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_CheckIntercepts
_TEXT	SEGMENT
_count$ = -4						; size = 4
_P_CheckIntercepts PROC					; COMDAT

; 857  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 858  : 	static size_t max_intercepts = 0;
; 859  : 	size_t count = intercept_p - intercepts;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercept_p
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _intercepts
  00014	99		 cdq
  00015	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001a	f7 f9		 idiv	 ecx
  0001c	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 860  : 
; 861  : 	if (max_intercepts <= count)

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?max_intercepts@?1??P_CheckIntercepts@@9@9
  00024	3b 45 fc	 cmp	 eax, DWORD PTR _count$[ebp]
  00027	77 52		 ja	 SHORT $LN2@P_CheckInt

; 862  : 	{
; 863  : 		if (!max_intercepts)

  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?max_intercepts@?1??P_CheckIntercepts@@9@9, 0
  00030	75 0c		 jne	 SHORT $LN3@P_CheckInt

; 864  : 			max_intercepts = 128;

  00032	c7 05 00 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?max_intercepts@?1??P_CheckIntercepts@@9@9, 128 ; 00000080H
  0003c	eb 0c		 jmp	 SHORT $LN4@P_CheckInt
$LN3@P_CheckInt:

; 865  : 		else
; 866  : 			max_intercepts *= 2;

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?max_intercepts@?1??P_CheckIntercepts@@9@9
  00043	d1 e0		 shl	 eax, 1
  00045	a3 00 00 00 00	 mov	 DWORD PTR ?max_intercepts@?1??P_CheckIntercepts@@9@9, eax
$LN4@P_CheckInt:

; 867  : 
; 868  : 		intercepts = Z_Realloc(intercepts, sizeof (*intercepts) * max_intercepts, PU_STATIC, NULL);

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 01		 push	 1
  00050	6b 05 00 00 00
	00 0c		 imul	 eax, DWORD PTR ?max_intercepts@?1??P_CheckIntercepts@@9@9, 12
  00057	50		 push	 eax
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _intercepts
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _Z_ReallocAlign
  00064	83 c4 14	 add	 esp, 20			; 00000014H
  00067	a3 00 00 00 00	 mov	 DWORD PTR _intercepts, eax

; 869  : 
; 870  : 		intercept_p = intercepts + count;

  0006c	6b 45 fc 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  00070	03 05 00 00 00
	00		 add	 eax, DWORD PTR _intercepts
  00076	a3 00 00 00 00	 mov	 DWORD PTR _intercept_p, eax
$LN2@P_CheckInt:

; 871  : 	}
; 872  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_P_CheckIntercepts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_PointOnDivlineSide
_TEXT	SEGMENT
tv70 = -84						; size = 4
tv73 = -84						; size = 4
tv80 = -84						; size = 4
tv83 = -84						; size = 4
_right$ = -16						; size = 4
_left$ = -12						; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_line$ = 16						; size = 4
_P_PointOnDivlineSide PROC				; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 190  : 	fixed_t dx, dy, left, right;
; 191  : 
; 192  : 	if (!line->dx)

  00009	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	75 4c		 jne	 SHORT $LN2@P_PointOnD

; 193  : 	{
; 194  : 		if (x <= line->x)

  00012	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00018	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0001a	7f 21		 jg	 SHORT $LN3@P_PointOnD

; 195  : 			return line->dy > 0;

  0001c	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0001f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00023	7e 09		 jle	 SHORT $LN10@P_PointOnD
  00025	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  0002c	eb 07		 jmp	 SHORT $LN11@P_PointOnD
$LN10@P_PointOnD:
  0002e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN11@P_PointOnD:
  00035	8b 45 ac	 mov	 eax, DWORD PTR tv70[ebp]
  00038	e9 0d 01 00 00	 jmp	 $LN1@P_PointOnD
$LN3@P_PointOnD:

; 196  : 
; 197  : 		return line->dy < 0;

  0003d	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00040	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00044	7d 09		 jge	 SHORT $LN12@P_PointOnD
  00046	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0004d	eb 07		 jmp	 SHORT $LN13@P_PointOnD
$LN12@P_PointOnD:
  0004f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN13@P_PointOnD:
  00056	8b 45 ac	 mov	 eax, DWORD PTR tv73[ebp]
  00059	e9 ec 00 00 00	 jmp	 $LN1@P_PointOnD
$LN2@P_PointOnD:

; 198  : 	}
; 199  : 	if (!line->dy)

  0005e	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00061	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00065	75 4d		 jne	 SHORT $LN4@P_PointOnD

; 200  : 	{
; 201  : 		if (y <= line->y)

  00067	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0006d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00070	7f 21		 jg	 SHORT $LN5@P_PointOnD

; 202  : 			return line->dx < 0;

  00072	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00075	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00079	7d 09		 jge	 SHORT $LN14@P_PointOnD
  0007b	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00082	eb 07		 jmp	 SHORT $LN15@P_PointOnD
$LN14@P_PointOnD:
  00084	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN15@P_PointOnD:
  0008b	8b 45 ac	 mov	 eax, DWORD PTR tv80[ebp]
  0008e	e9 b7 00 00 00	 jmp	 $LN1@P_PointOnD
$LN5@P_PointOnD:

; 203  : 
; 204  : 		return line->dx > 0;

  00093	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00096	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0009a	7e 09		 jle	 SHORT $LN16@P_PointOnD
  0009c	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  000a3	eb 07		 jmp	 SHORT $LN17@P_PointOnD
$LN16@P_PointOnD:
  000a5	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN17@P_PointOnD:
  000ac	8b 45 ac	 mov	 eax, DWORD PTR tv83[ebp]
  000af	e9 96 00 00 00	 jmp	 $LN1@P_PointOnD
$LN4@P_PointOnD:

; 205  : 	}
; 206  : 
; 207  : 	dx = (x - line->x);

  000b4	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000ba	2b 08		 sub	 ecx, DWORD PTR [eax]
  000bc	89 4d fc	 mov	 DWORD PTR _dx$[ebp], ecx

; 208  : 	dy = (y - line->y);

  000bf	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000c5	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000c8	89 4d f8	 mov	 DWORD PTR _dy$[ebp], ecx

; 209  : 
; 210  : 	// try to quickly decide by looking at sign bits
; 211  : 	if ((line->dy ^ line->dx ^ dx ^ dy) & 0x80000000)

  000cb	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  000ce	8b 4d 10	 mov	 ecx, DWORD PTR _line$[ebp]
  000d1	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000d4	33 51 08	 xor	 edx, DWORD PTR [ecx+8]
  000d7	33 55 fc	 xor	 edx, DWORD PTR _dx$[ebp]
  000da	33 55 f8	 xor	 edx, DWORD PTR _dy$[ebp]
  000dd	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  000e3	74 1c		 je	 SHORT $LN6@P_PointOnD

; 212  : 	{
; 213  : 		if ((line->dy ^ dx) & 0x80000000)

  000e5	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  000e8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000eb	33 4d fc	 xor	 ecx, DWORD PTR _dx$[ebp]
  000ee	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  000f4	74 07		 je	 SHORT $LN7@P_PointOnD

; 214  : 			return 1; // left is negative

  000f6	b8 01 00 00 00	 mov	 eax, 1
  000fb	eb 4d		 jmp	 SHORT $LN1@P_PointOnD
$LN7@P_PointOnD:

; 215  : 		return 0;

  000fd	33 c0		 xor	 eax, eax
  000ff	eb 49		 jmp	 SHORT $LN1@P_PointOnD
$LN6@P_PointOnD:

; 216  : 	}
; 217  : 
; 218  : 	left = FixedMul(line->dy>>8, dx>>8);

  00101	8b 45 fc	 mov	 eax, DWORD PTR _dx$[ebp]
  00104	c1 f8 08	 sar	 eax, 8
  00107	50		 push	 eax
  00108	8b 4d 10	 mov	 ecx, DWORD PTR _line$[ebp]
  0010b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0010e	c1 fa 08	 sar	 edx, 8
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 _FixedMul
  00117	83 c4 08	 add	 esp, 8
  0011a	89 45 f4	 mov	 DWORD PTR _left$[ebp], eax

; 219  : 	right = FixedMul(dy>>8, line->dx>>8);

  0011d	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00120	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00123	c1 f9 08	 sar	 ecx, 8
  00126	51		 push	 ecx
  00127	8b 55 f8	 mov	 edx, DWORD PTR _dy$[ebp]
  0012a	c1 fa 08	 sar	 edx, 8
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 _FixedMul
  00133	83 c4 08	 add	 esp, 8
  00136	89 45 f0	 mov	 DWORD PTR _right$[ebp], eax

; 220  : 
; 221  : 	if (right < left)

  00139	8b 45 f0	 mov	 eax, DWORD PTR _right$[ebp]
  0013c	3b 45 f4	 cmp	 eax, DWORD PTR _left$[ebp]
  0013f	7d 04		 jge	 SHORT $LN8@P_PointOnD

; 222  : 		return 0; // front side

  00141	33 c0		 xor	 eax, eax
  00143	eb 05		 jmp	 SHORT $LN1@P_PointOnD
$LN8@P_PointOnD:

; 223  : 	return 1; // back side

  00145	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_PointOnD:

; 224  : }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
_P_PointOnDivlineSide ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_SetThingPosition
_TEXT	SEGMENT
tv76 = -100						; size = 4
_bnext$1 = -32						; size = 4
_link$2 = -28						; size = 4
_blocky$3 = -24						; size = 4
_blockx$4 = -20						; size = 4
_snext$5 = -16						; size = 4
_link$6 = -12						; size = 4
_oldsec$ = -8						; size = 4
_ss$ = -4						; size = 4
_thing$ = 8						; size = 4
_P_SetThingPosition PROC				; COMDAT

; 651  : {                                                      // link into subsector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 652  : 	subsector_t *ss;
; 653  : 	sector_t *oldsec = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _oldsec$[ebp], 0

; 654  : 
; 655  : 	// Better safe than sorry!
; 656  : 	if (!thing)

  00010	83 7d 08 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00014	75 12		 jne	 SHORT $LN2@P_SetThing

; 657  : 	{
; 658  : 		CONS_Printf("P_SetThingPosition: Tried to set a thing that doesn't exist!\n");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@COBEEHJD@P_SetThingPosition?3?5Tried?5to?5se@
  0001b	e8 00 00 00 00	 call	 _CONS_Printf
  00020	83 c4 04	 add	 esp, 4

; 659  : 		return;

  00023	e9 d7 01 00 00	 jmp	 $LN10@P_SetThing
$LN2@P_SetThing:

; 660  : 	}
; 661  : 
; 662  : 	if (thing->player && thing->z <= thing->floorz && thing->subsector)

  00028	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0002b	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00032	74 22		 je	 SHORT $LN3@P_SetThing
  00034	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0003a	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0003d	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  00040	7f 14		 jg	 SHORT $LN3@P_SetThing
  00042	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00045	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00049	74 0b		 je	 SHORT $LN3@P_SetThing

; 663  : 		oldsec = thing->subsector->sector;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0004e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00051	8b 11		 mov	 edx, DWORD PTR [ecx]
  00053	89 55 f8	 mov	 DWORD PTR _oldsec$[ebp], edx
$LN3@P_SetThing:

; 664  : 
; 665  : 	ss = thing->subsector = R_PointInSubsector(thing->x, thing->y);

  00056	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00059	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00060	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _R_PointInSubsector
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 9c	 mov	 DWORD PTR tv76[ebp], eax
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00072	8b 55 9c	 mov	 edx, DWORD PTR tv76[ebp]
  00075	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00078	8b 45 9c	 mov	 eax, DWORD PTR tv76[ebp]
  0007b	89 45 fc	 mov	 DWORD PTR _ss$[ebp], eax

; 666  : 
; 667  : 	if (!(thing->flags & MF_NOSECTOR))

  0007e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00081	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00084	83 e1 08	 and	 ecx, 8
  00087	75 6f		 jne	 SHORT $LN4@P_SetThing

; 668  : 	{
; 669  : 		// invisible things don't go into the sector links
; 670  : 
; 671  : 		// killough 8/11/98: simpler scheme using pointer-to-pointer prev
; 672  : 		// pointers, allows head nodes to be treated like everything else
; 673  : 
; 674  : 		mobj_t **link = &ss->sector->thinglist;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _ss$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	83 c1 40	 add	 ecx, 64			; 00000040H
  00091	89 4d f4	 mov	 DWORD PTR _link$6[ebp], ecx

; 675  : 		mobj_t *snext = *link;

  00094	8b 45 f4	 mov	 eax, DWORD PTR _link$6[ebp]
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	89 4d f0	 mov	 DWORD PTR _snext$5[ebp], ecx

; 676  : 		if ((thing->snext = snext) != NULL)

  0009c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _snext$5[ebp]
  000a2	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  000a5	83 7d f0 00	 cmp	 DWORD PTR _snext$5[ebp], 0
  000a9	74 0c		 je	 SHORT $LN5@P_SetThing

; 677  : 			snext->sprev = &thing->snext;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ae	83 c0 1c	 add	 eax, 28			; 0000001cH
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR _snext$5[ebp]
  000b4	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN5@P_SetThing:

; 678  : 		thing->sprev = link;

  000b7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _link$6[ebp]
  000bd	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 679  : 		*link = thing;

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _link$6[ebp]
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 680  : 
; 681  : 		// phares 3/16/98
; 682  : 		//
; 683  : 		// If sector_list isn't NULL, it has a collection of sector
; 684  : 		// nodes that were just removed from this Thing.
; 685  : 
; 686  : 		// Collect the sectors the object will live in by looking at
; 687  : 		// the existing sector_list and adding new nodes and deleting
; 688  : 		// obsolete ones.
; 689  : 
; 690  : 		// When a node is deleted, its sector links (the links starting
; 691  : 		// at sector_t->touching_thinglist) are broken. When a node is
; 692  : 		// added, new sector links are created.
; 693  : 
; 694  : 		P_CreateSecNodeList(thing,thing->x,thing->y);

  000c8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000cb	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ce	51		 push	 ecx
  000cf	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000d2	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000d5	50		 push	 eax
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _P_CreateSecNodeList
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 695  : 		thing->touching_sectorlist = sector_list; // Attach to Thing's mobj_t

  000e2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sector_list
  000eb	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 696  : 		sector_list = NULL; // clear for next time

  000ee	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _sector_list, 0
$LN4@P_SetThing:

; 697  : 	}
; 698  : 
; 699  : 	// link into blockmap
; 700  : 	if (!(thing->flags & MF_NOBLOCKMAP))

  000f8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000fb	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000fe	83 e1 10	 and	 ecx, 16			; 00000010H
  00101	0f 85 a9 00 00
	00		 jne	 $LN8@P_SetThing

; 701  : 	{
; 702  : 		// inert things don't need to be in blockmap
; 703  : 		const INT32 blockx = (unsigned)(thing->x - bmaporgx)>>MAPBLOCKSHIFT;

  00107	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0010a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0010d	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  00113	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00116	89 4d ec	 mov	 DWORD PTR _blockx$4[ebp], ecx

; 704  : 		const INT32 blocky = (unsigned)(thing->y - bmaporgy)>>MAPBLOCKSHIFT;

  00119	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0011c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0011f	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  00125	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00128	89 4d e8	 mov	 DWORD PTR _blocky$3[ebp], ecx

; 705  : 		if (blockx >= 0 && blockx < bmapwidth
; 706  : 			&& blocky >= 0 && blocky < bmapheight)

  0012b	83 7d ec 00	 cmp	 DWORD PTR _blockx$4[ebp], 0
  0012f	7c 6b		 jl	 SHORT $LN7@P_SetThing
  00131	8b 45 ec	 mov	 eax, DWORD PTR _blockx$4[ebp]
  00134	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  0013a	7d 60		 jge	 SHORT $LN7@P_SetThing
  0013c	83 7d e8 00	 cmp	 DWORD PTR _blocky$3[ebp], 0
  00140	7c 5a		 jl	 SHORT $LN7@P_SetThing
  00142	8b 45 e8	 mov	 eax, DWORD PTR _blocky$3[ebp]
  00145	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  0014b	7d 4f		 jge	 SHORT $LN7@P_SetThing

; 707  : 		{
; 708  : 			// killough 8/11/98: simpler scheme using
; 709  : 			// pointer-to-pointer prev pointers --
; 710  : 			// allows head nodes to be treated like everything else
; 711  : 
; 712  : 			mobj_t **link = &blocklinks[blocky*bmapwidth + blockx];

  0014d	8b 45 e8	 mov	 eax, DWORD PTR _blocky$3[ebp]
  00150	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  00157	03 45 ec	 add	 eax, DWORD PTR _blockx$4[ebp]
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blocklinks
  00160	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00163	89 55 e4	 mov	 DWORD PTR _link$2[ebp], edx

; 713  : 			mobj_t *bnext = *link;

  00166	8b 45 e4	 mov	 eax, DWORD PTR _link$2[ebp]
  00169	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016b	89 4d e0	 mov	 DWORD PTR _bnext$1[ebp], ecx

; 714  : 			if ((thing->bnext = bnext) != NULL)

  0016e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00171	8b 4d e0	 mov	 ecx, DWORD PTR _bnext$1[ebp]
  00174	89 48 6c	 mov	 DWORD PTR [eax+108], ecx
  00177	83 7d e0 00	 cmp	 DWORD PTR _bnext$1[ebp], 0
  0017b	74 0c		 je	 SHORT $LN9@P_SetThing

; 715  : 				bnext->bprev = &thing->bnext;

  0017d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00180	83 c0 6c	 add	 eax, 108		; 0000006cH
  00183	8b 4d e0	 mov	 ecx, DWORD PTR _bnext$1[ebp]
  00186	89 41 70	 mov	 DWORD PTR [ecx+112], eax
$LN9@P_SetThing:

; 716  : 			thing->bprev = link;

  00189	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0018c	8b 4d e4	 mov	 ecx, DWORD PTR _link$2[ebp]
  0018f	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 717  : 			*link = thing;

  00192	8b 45 e4	 mov	 eax, DWORD PTR _link$2[ebp]
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00198	89 08		 mov	 DWORD PTR [eax], ecx

; 718  : 		}

  0019a	eb 14		 jmp	 SHORT $LN8@P_SetThing
$LN7@P_SetThing:

; 719  : 		else // thing is off the map
; 720  : 			thing->bnext = NULL, thing->bprev = NULL;

  0019c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0019f	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
  001a6	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  001a9	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0
$LN8@P_SetThing:

; 721  : 	}
; 722  : 
; 723  : 	// Allows you to 'step' on a new linedef exec when the previous
; 724  : 	// sector's floor is the same height.
; 725  : 	if (thing->player && oldsec != NULL && thing->subsector
; 726  : 		&& oldsec != thing->subsector->sector
; 727  : 		&& thing->z <= thing->subsector->sector->floorheight)

  001b0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001b3	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001ba	74 43		 je	 SHORT $LN10@P_SetThing
  001bc	83 7d f8 00	 cmp	 DWORD PTR _oldsec$[ebp], 0
  001c0	74 3d		 je	 SHORT $LN10@P_SetThing
  001c2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001c5	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  001c9	74 34		 je	 SHORT $LN10@P_SetThing
  001cb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001ce	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001d1	8b 55 f8	 mov	 edx, DWORD PTR _oldsec$[ebp]
  001d4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001d6	74 27		 je	 SHORT $LN10@P_SetThing
  001d8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001db	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001de	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001e3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001e6	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  001e8	7f 15		 jg	 SHORT $LN10@P_SetThing

; 728  : 	{
; 729  : 		thing->eflags |= MFE_JUSTSTEPPEDDOWN;

  001ea	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001ed	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  001f3	83 c9 10	 or	 ecx, 16			; 00000010H
  001f6	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  001f9	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
$LN10@P_SetThing:

; 730  : 	}
; 731  : }

  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi
  00201	5b		 pop	 ebx
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
_P_SetThingPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_UnsetThingPosition
_TEXT	SEGMENT
_bprev$1 = -16						; size = 4
_bnext$2 = -12						; size = 4
_snext$3 = -8						; size = 4
_sprev$4 = -4						; size = 4
_thing$ = 8						; size = 4
_P_UnsetThingPosition PROC				; COMDAT

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 576  : 	// Better safe than sorry!
; 577  : 	if (!thing)

  00009	83 7d 08 00	 cmp	 DWORD PTR _thing$[ebp], 0
  0000d	75 12		 jne	 SHORT $LN2@P_UnsetThi

; 578  : 	{
; 579  : 		CONS_Printf("P_SetUnsetThingPosition: Tried to unset a thing that doesn't exist!\n");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@LFOMGHFI@P_SetUnsetThingPosition?3?5Tried?5@
  00014	e8 00 00 00 00	 call	 _CONS_Printf
  00019	83 c4 04	 add	 esp, 4

; 580  : 		return;

  0001c	e9 84 00 00 00	 jmp	 $LN6@P_UnsetThi
$LN2@P_UnsetThi:

; 581  : 	}
; 582  : 
; 583  : 	if (!(thing->flags & MF_NOSECTOR))

  00021	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00024	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00027	83 e1 08	 and	 ecx, 8
  0002a	75 3f		 jne	 SHORT $LN3@P_UnsetThi

; 584  : 	{
; 585  : 		/* invisible things don't need to be in sector list
; 586  : 		* unlink from subsector
; 587  : 		*
; 588  : 		* killough 8/11/98: simpler scheme using pointers-to-pointers for prev
; 589  : 		* pointers, allows head node pointers to be treated like everything else
; 590  : 		*/
; 591  : 
; 592  : 		mobj_t **sprev = thing->sprev;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0002f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00032	89 4d fc	 mov	 DWORD PTR _sprev$4[ebp], ecx

; 593  : 		mobj_t  *snext = thing->snext;

  00035	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00038	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003b	89 4d f8	 mov	 DWORD PTR _snext$3[ebp], ecx

; 594  : 		if ((*sprev = snext) != NULL)  // unlink from sector list

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _sprev$4[ebp]
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _snext$3[ebp]
  00044	89 08		 mov	 DWORD PTR [eax], ecx
  00046	83 7d f8 00	 cmp	 DWORD PTR _snext$3[ebp], 0
  0004a	74 09		 je	 SHORT $LN4@P_UnsetThi

; 595  : 			snext->sprev = sprev;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _snext$3[ebp]
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _sprev$4[ebp]
  00052	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$LN4@P_UnsetThi:

; 596  : 
; 597  : 		// phares 3/14/98
; 598  : 		//
; 599  : 		// Save the sector list pointed to by touching_sectorlist.
; 600  : 		// In P_SetThingPosition, we'll keep any nodes that represent
; 601  : 		// sectors the Thing still touches. We'll add new ones then, and
; 602  : 		// delete any nodes for sectors the Thing has vacated. Then we'll
; 603  : 		// put it back into touching_sectorlist. It's done this way to
; 604  : 		// avoid a lot of deleting/creating for nodes, when most of the
; 605  : 		// time you just get back what you deleted anyway.
; 606  : 		//
; 607  : 		// If this Thing is being removed entirely, then the calling
; 608  : 		// routine will clear out the nodes in sector_list.
; 609  : 
; 610  : 		sector_list = thing->touching_sectorlist;

  00055	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00058	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0005b	89 0d 00 00 00
	00		 mov	 DWORD PTR _sector_list, ecx

; 611  : 		thing->touching_sectorlist = NULL; //to be restored by P_SetThingPosition

  00061	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00064	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
$LN3@P_UnsetThi:

; 612  : 	}
; 613  : 
; 614  : 	if (!(thing->flags & MF_NOBLOCKMAP))

  0006b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0006e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00071	83 e1 10	 and	 ecx, 16			; 00000010H
  00074	75 2f		 jne	 SHORT $LN6@P_UnsetThi

; 615  : 	{
; 616  : 		/* inert things don't need to be in blockmap
; 617  : 		*
; 618  : 		* killough 8/11/98: simpler scheme using pointers-to-pointers for prev
; 619  : 		* pointers, allows head node pointers to be treated like everything else
; 620  : 		*
; 621  : 		* Also more robust, since it doesn't depend on current position for
; 622  : 		* unlinking. Old method required computing head node based on position
; 623  : 		* at time of unlinking, assuming it was the same position as during
; 624  : 		* linking.
; 625  : 		*/
; 626  : 
; 627  : 		mobj_t *bnext, **bprev = thing->bprev;

  00076	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00079	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0007c	89 4d f0	 mov	 DWORD PTR _bprev$1[ebp], ecx

; 628  : 		if (bprev && (*bprev = bnext = thing->bnext) != NULL)  // unlink from block map

  0007f	83 7d f0 00	 cmp	 DWORD PTR _bprev$1[ebp], 0
  00083	74 20		 je	 SHORT $LN6@P_UnsetThi
  00085	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00088	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0008b	89 4d f4	 mov	 DWORD PTR _bnext$2[ebp], ecx
  0008e	8b 55 f0	 mov	 edx, DWORD PTR _bprev$1[ebp]
  00091	8b 45 f4	 mov	 eax, DWORD PTR _bnext$2[ebp]
  00094	89 02		 mov	 DWORD PTR [edx], eax
  00096	83 7d f4 00	 cmp	 DWORD PTR _bnext$2[ebp], 0
  0009a	74 09		 je	 SHORT $LN6@P_UnsetThi

; 629  : 			bnext->bprev = bprev;

  0009c	8b 45 f4	 mov	 eax, DWORD PTR _bnext$2[ebp]
  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _bprev$1[ebp]
  000a2	89 48 70	 mov	 DWORD PTR [eax+112], ecx
$LN6@P_UnsetThi:

; 630  : 	}
; 631  : }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
_P_UnsetThingPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_BlockThingsIterator
_TEXT	SEGMENT
_mobj$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_func$ = 16						; size = 4
_P_BlockThingsIterator PROC				; COMDAT

; 829  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 830  : 	mobj_t *mobj;
; 831  : 
; 832  : 	if (x < 0 || y < 0 || x >= bmapwidth || y >= bmapheight)

  00009	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0000d	7c 1c		 jl	 SHORT $LN6@P_BlockThi
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  00013	7c 16		 jl	 SHORT $LN6@P_BlockThi
  00015	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00018	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  0001e	7d 0b		 jge	 SHORT $LN6@P_BlockThi
  00020	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00023	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  00029	7c 07		 jl	 SHORT $LN5@P_BlockThi
$LN6@P_BlockThi:

; 833  : 		return true;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	eb 43		 jmp	 SHORT $LN1@P_BlockThi
$LN5@P_BlockThi:

; 834  : 
; 835  : 	// Check interaction with the objects in the blockmap.
; 836  : 	for (mobj = blocklinks[y*bmapwidth + x]; mobj; mobj = mobj->bnext)

  00032	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00035	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  0003c	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blocklinks
  00045	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00048	89 55 fc	 mov	 DWORD PTR _mobj$[ebp], edx
  0004b	eb 09		 jmp	 SHORT $LN4@P_BlockThi
$LN2@P_BlockThi:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _mobj$[ebp]
  00050	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00053	89 4d fc	 mov	 DWORD PTR _mobj$[ebp], ecx
$LN4@P_BlockThi:
  00056	83 7d fc 00	 cmp	 DWORD PTR _mobj$[ebp], 0
  0005a	74 14		 je	 SHORT $LN3@P_BlockThi

; 837  : 	{
; 838  : 		if (!func(mobj))

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _mobj$[ebp]
  0005f	50		 push	 eax
  00060	ff 55 10	 call	 DWORD PTR _func$[ebp]
  00063	83 c4 04	 add	 esp, 4
  00066	85 c0		 test	 eax, eax
  00068	75 04		 jne	 SHORT $LN7@P_BlockThi

; 839  : 			return false;

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 07		 jmp	 SHORT $LN1@P_BlockThi
$LN7@P_BlockThi:

; 840  : 	}

  0006e	eb dd		 jmp	 SHORT $LN2@P_BlockThi
$LN3@P_BlockThi:

; 841  : 	return true;

  00070	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_BlockThi:

; 842  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_P_BlockThingsIterator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_BlockLinesIterator
_TEXT	SEGMENT
_i$1 = -24						; size = 4
_po$2 = -20						; size = 4
_ld$ = -16						; size = 4
_plink$ = -12						; size = 4
_list$ = -8						; size = 4
_offset$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_func$ = 16						; size = 4
_P_BlockLinesIterator PROC				; COMDAT

; 767  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 768  : 	INT32 offset;
; 769  : 	const INT32 *list; // Big blockmap
; 770  : #ifdef POLYOBJECTS
; 771  : 	polymaplink_t *plink; // haleyjd 02/22/06
; 772  : #endif
; 773  : 	line_t *ld;
; 774  : 
; 775  : 	if (x < 0 || y < 0 || x >= bmapwidth || y >= bmapheight)

  00009	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0000d	7c 1c		 jl	 SHORT $LN11@P_BlockLin
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  00013	7c 16		 jl	 SHORT $LN11@P_BlockLin
  00015	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00018	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  0001e	7d 0b		 jge	 SHORT $LN11@P_BlockLin
  00020	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00023	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  00029	7c 0a		 jl	 SHORT $LN10@P_BlockLin
$LN11@P_BlockLin:

; 776  : 		return true;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	e9 40 01 00 00	 jmp	 $LN1@P_BlockLin
$LN10@P_BlockLin:

; 777  : 
; 778  : 	offset = y*bmapwidth + x;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00038	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  0003f	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  00042	89 45 fc	 mov	 DWORD PTR _offset$[ebp], eax

; 779  : 
; 780  : #ifdef POLYOBJECTS
; 781  : 	// haleyjd 02/22/06: consider polyobject lines
; 782  : 	plink = polyblocklinks[offset];

  00045	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _polyblocklinks
  0004e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00051	89 55 f4	 mov	 DWORD PTR _plink$[ebp], edx
$LN2@P_BlockLin:

; 783  : 
; 784  : 	while (plink)

  00054	83 7d f4 00	 cmp	 DWORD PTR _plink$[ebp], 0
  00058	0f 84 a1 00 00
	00		 je	 $LN3@P_BlockLin

; 785  : 	{
; 786  : 		polyobj_t *po = plink->po;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _plink$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	89 4d ec	 mov	 DWORD PTR _po$2[ebp], ecx

; 787  : 
; 788  : 		if (po->validcount != validcount) // if polyobj hasn't been checked

  00067	8b 45 ec	 mov	 eax, DWORD PTR _po$2[ebp]
  0006a	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00070	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00076	74 7a		 je	 SHORT $LN5@P_BlockLin

; 789  : 		{
; 790  : 			size_t i;
; 791  : 			po->validcount = validcount;

  00078	8b 45 ec	 mov	 eax, DWORD PTR _po$2[ebp]
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00081	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx

; 792  : 
; 793  : 			for (i = 0; i < po->numLines; ++i)

  00087	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0008e	eb 09		 jmp	 SHORT $LN6@P_BlockLin
$LN4@P_BlockLin:
  00090	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN6@P_BlockLin:
  00099	8b 45 ec	 mov	 eax, DWORD PTR _po$2[ebp]
  0009c	8b 4d e8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0009f	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  000a2	73 4e		 jae	 SHORT $LN5@P_BlockLin

; 794  : 			{
; 795  : 				if (po->lines[i]->validcount == validcount) // line has been checked

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _po$2[ebp]
  000a7	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000aa	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000ad	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000b0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  000b9	75 02		 jne	 SHORT $LN13@P_BlockLin

; 796  : 					continue;

  000bb	eb d3		 jmp	 SHORT $LN4@P_BlockLin
$LN13@P_BlockLin:

; 797  : 				po->lines[i]->validcount = validcount;

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _po$2[ebp]
  000c0	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000c3	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000c6	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  000cf	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 798  : 				if (!func(po->lines[i]))

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _po$2[ebp]
  000d5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000d8	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000db	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000de	50		 push	 eax
  000df	ff 55 10	 call	 DWORD PTR _func$[ebp]
  000e2	83 c4 04	 add	 esp, 4
  000e5	85 c0		 test	 eax, eax
  000e7	75 07		 jne	 SHORT $LN14@P_BlockLin

; 799  : 					return false;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 85 00 00 00	 jmp	 $LN1@P_BlockLin
$LN14@P_BlockLin:

; 800  : 			}

  000f0	eb 9e		 jmp	 SHORT $LN4@P_BlockLin
$LN5@P_BlockLin:

; 801  : 		}
; 802  : 		plink = (polymaplink_t *)(plink->link.next);

  000f2	8b 45 f4	 mov	 eax, DWORD PTR _plink$[ebp]
  000f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f7	89 4d f4	 mov	 DWORD PTR _plink$[ebp], ecx

; 803  : 	}

  000fa	e9 55 ff ff ff	 jmp	 $LN2@P_BlockLin
$LN3@P_BlockLin:

; 804  : #endif
; 805  : 
; 806  : 	offset = *(blockmap + offset); // offset = blockmap[y*bmapwidth+x];

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp]
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmap
  00108	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0010b	89 55 fc	 mov	 DWORD PTR _offset$[ebp], edx

; 807  : 
; 808  : 	// First index is really empty, so +1 it.
; 809  : 	for (list = blockmaplump + offset + 1; *list != -1; list++)

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp]
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blockmaplump
  00117	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  0011b	89 55 f8	 mov	 DWORD PTR _list$[ebp], edx
  0011e	eb 09		 jmp	 SHORT $LN9@P_BlockLin
$LN7@P_BlockLin:
  00120	8b 45 f8	 mov	 eax, DWORD PTR _list$[ebp]
  00123	83 c0 04	 add	 eax, 4
  00126	89 45 f8	 mov	 DWORD PTR _list$[ebp], eax
$LN9@P_BlockLin:
  00129	8b 45 f8	 mov	 eax, DWORD PTR _list$[ebp]
  0012c	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0012f	74 3f		 je	 SHORT $LN8@P_BlockLin

; 810  : 	{
; 811  : 		ld = &lines[*list];

  00131	8b 45 f8	 mov	 eax, DWORD PTR _list$[ebp]
  00134	6b 08 4c	 imul	 ecx, DWORD PTR [eax], 76
  00137	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _lines
  0013d	89 4d f0	 mov	 DWORD PTR _ld$[ebp], ecx

; 812  : 
; 813  : 		if (ld->validcount == validcount)

  00140	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00143	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00146	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  0014c	75 02		 jne	 SHORT $LN15@P_BlockLin

; 814  : 			continue; // Line has already been checked.

  0014e	eb d0		 jmp	 SHORT $LN7@P_BlockLin
$LN15@P_BlockLin:

; 815  : 
; 816  : 		ld->validcount = validcount;

  00150	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00159	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 817  : 
; 818  : 		if (!func(ld))

  0015c	8b 45 f0	 mov	 eax, DWORD PTR _ld$[ebp]
  0015f	50		 push	 eax
  00160	ff 55 10	 call	 DWORD PTR _func$[ebp]
  00163	83 c4 04	 add	 esp, 4
  00166	85 c0		 test	 eax, eax
  00168	75 04		 jne	 SHORT $LN16@P_BlockLin

; 819  : 			return false;

  0016a	33 c0		 xor	 eax, eax
  0016c	eb 07		 jmp	 SHORT $LN1@P_BlockLin
$LN16@P_BlockLin:

; 820  : 	}

  0016e	eb b0		 jmp	 SHORT $LN7@P_BlockLin
$LN8@P_BlockLin:

; 821  : 	return true; // Everything was checked.

  00170	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_BlockLin:

; 822  : }

  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
_P_BlockLinesIterator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_LineOpening
_TEXT	SEGMENT
_polysec$1 = -44					; size = 4
_delta2$2 = -40						; size = 4
_delta1$3 = -36						; size = 4
_lowestfloor$4 = -32					; size = 4
_highestfloor$5 = -28					; size = 4
_lowestceiling$6 = -24					; size = 4
_rover$7 = -20						; size = 4
_thingtop$8 = -16					; size = 4
_thingbot$9 = -12					; size = 4
_back$ = -8						; size = 4
_front$ = -4						; size = 4
_linedef$ = 8						; size = 4
_P_LineOpening PROC					; COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 391  : 	sector_t *front, *back;
; 392  : 
; 393  : 	if (linedef->sidenum[1] == 0xffff)

  00009	b8 02 00 00 00	 mov	 eax, 2
  0000e	c1 e0 00	 shl	 eax, 0
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _linedef$[ebp]
  00014	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  00019	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0001f	75 0f		 jne	 SHORT $LN8@P_LineOpen

; 394  : 	{
; 395  : 		// single sided line
; 396  : 		openrange = 0;

  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _openrange, 0

; 397  : 		return;

  0002b	e9 7b 05 00 00	 jmp	 $LN1@P_LineOpen
$LN8@P_LineOpen:

; 398  : 	}
; 399  : 
; 400  : 	// Treat polyobjects kind of like 3D Floors
; 401  : #ifdef POLYOBJECTS
; 402  : 	if (linedef->polyobj && (linedef->polyobj->flags & POF_TESTHEIGHT))

  00030	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  00033	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00037	74 25		 je	 SHORT $LN9@P_LineOpen
  00039	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  0003c	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0003f	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00045	83 e2 04	 and	 edx, 4
  00048	74 14		 je	 SHORT $LN9@P_LineOpen

; 403  : 	{
; 404  : 		front = linedef->frontsector;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  0004d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00050	89 4d fc	 mov	 DWORD PTR _front$[ebp], ecx

; 405  : 		back = linedef->frontsector;

  00053	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  00056	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00059	89 4d f8	 mov	 DWORD PTR _back$[ebp], ecx

; 406  : 	}

  0005c	eb 12		 jmp	 SHORT $LN10@P_LineOpen
$LN9@P_LineOpen:

; 407  : 	else
; 408  : #endif
; 409  : 	{
; 410  : 		front = linedef->frontsector;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  00061	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00064	89 4d fc	 mov	 DWORD PTR _front$[ebp], ecx

; 411  : 		back = linedef->backsector;

  00067	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  0006a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006d	89 4d f8	 mov	 DWORD PTR _back$[ebp], ecx
$LN10@P_LineOpen:

; 412  : 	}
; 413  : 
; 414  : 	I_Assert(front != NULL);
; 415  : 	I_Assert(back != NULL);
; 416  : 
; 417  : 	if (tmthing)

  00070	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmthing, 0
  00077	0f 84 bc 04 00
	00		 je	 $LN11@P_LineOpen

; 418  : 	{
; 419  : 		fixed_t thingbot, thingtop;
; 420  : 
; 421  : 		thingbot = tmthing->z;

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00082	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00085	89 4d f4	 mov	 DWORD PTR _thingbot$9[ebp], ecx

; 422  : 		thingtop = thingbot + tmthing->height;

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR _thingbot$9[ebp]
  00090	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00093	89 4d f0	 mov	 DWORD PTR _thingtop$8[ebp], ecx

; 423  : 
; 424  : 		if (front->ceilingheight < back->ceilingheight)

  00096	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _back$[ebp]
  0009c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009f	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000a2	7d 0e		 jge	 SHORT $LN12@P_LineOpen

; 425  : 			opentop = front->ceilingheight;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  000a7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000aa	89 0d 00 00 00
	00		 mov	 DWORD PTR _opentop, ecx
  000b0	eb 0c		 jmp	 SHORT $LN13@P_LineOpen
$LN12@P_LineOpen:

; 426  : 		else
; 427  : 			opentop = back->ceilingheight;

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  000b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b8	89 0d 00 00 00
	00		 mov	 DWORD PTR _opentop, ecx
$LN13@P_LineOpen:

; 428  : 
; 429  : 		if (front->floorheight > back->floorheight)

  000be	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _back$[ebp]
  000c4	8b 10		 mov	 edx, DWORD PTR [eax]
  000c6	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000c8	7e 18		 jle	 SHORT $LN14@P_LineOpen

; 430  : 		{
; 431  : 			openbottom = front->floorheight;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  000cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cf	89 0d 00 00 00
	00		 mov	 DWORD PTR _openbottom, ecx

; 432  : 			lowfloor = back->floorheight;

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	89 0d 00 00 00
	00		 mov	 DWORD PTR _lowfloor, ecx

; 433  : 		}

  000e0	eb 16		 jmp	 SHORT $LN15@P_LineOpen
$LN14@P_LineOpen:

; 434  : 		else
; 435  : 		{
; 436  : 			openbottom = back->floorheight;

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	89 0d 00 00 00
	00		 mov	 DWORD PTR _openbottom, ecx

; 437  : 			lowfloor = front->floorheight;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  000f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f2	89 0d 00 00 00
	00		 mov	 DWORD PTR _lowfloor, ecx
$LN15@P_LineOpen:

; 438  : 		}
; 439  : 
; 440  : 		// Check for fake floors in the sector.
; 441  : 		if (front->ffloors || back->ffloors
; 442  : #ifdef POLYOBJECTS
; 443  : 		    || linedef->polyobj

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  000fb	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00102	75 19		 jne	 SHORT $LN17@P_LineOpen
  00104	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  00107	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0010e	75 0d		 jne	 SHORT $LN17@P_LineOpen
  00110	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  00113	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00117	0f 84 0a 04 00
	00		 je	 $LN48@P_LineOpen
$LN17@P_LineOpen:

; 444  : #endif
; 445  : 		   )
; 446  : 		{
; 447  : 			ffloor_t *rover;
; 448  : 
; 449  : 			fixed_t lowestceiling = opentop;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  00122	89 45 e8	 mov	 DWORD PTR _lowestceiling$6[ebp], eax

; 450  : 			fixed_t highestfloor = openbottom;

  00125	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  0012a	89 45 e4	 mov	 DWORD PTR _highestfloor$5[ebp], eax

; 451  : 			fixed_t lowestfloor = lowfloor;

  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowfloor
  00132	89 45 e0	 mov	 DWORD PTR _lowestfloor$4[ebp], eax

; 452  : 			fixed_t delta1;
; 453  : 			fixed_t delta2;
; 454  : 
; 455  : 			if (!tmthing)

  00135	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmthing, 0
  0013c	75 05		 jne	 SHORT $LN18@P_LineOpen

; 456  : 				goto no_thing;

  0013e	e9 58 04 00 00	 jmp	 $no_thing$54
$LN18@P_LineOpen:

; 457  : 
; 458  : 			thingtop = tmthing->z + tmthing->height;

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00148	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0014b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00151	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00154	89 4d f0	 mov	 DWORD PTR _thingtop$8[ebp], ecx

; 459  : 
; 460  : 			// Check for frontsector's fake floors
; 461  : 			for (rover = front->ffloors; rover; rover = rover->next)

  00157	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  0015a	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00160	89 4d ec	 mov	 DWORD PTR _rover$7[ebp], ecx
  00163	eb 09		 jmp	 SHORT $LN4@P_LineOpen
$LN2@P_LineOpen:
  00165	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00168	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0016b	89 4d ec	 mov	 DWORD PTR _rover$7[ebp], ecx
$LN4@P_LineOpen:
  0016e	83 7d ec 00	 cmp	 DWORD PTR _rover$7[ebp], 0
  00172	0f 84 40 01 00
	00		 je	 $LN3@P_LineOpen

; 462  : 			{
; 463  : 				if (!(rover->flags & FF_EXISTS) || !(((rover->flags & FF_BLOCKPLAYER) && tmthing->player)

  00178	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0017b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0017e	83 e1 01	 and	 ecx, 1
  00181	74 32		 je	 SHORT $LN22@P_LineOpen
  00183	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00186	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00189	83 e1 02	 and	 ecx, 2
  0018c	74 0e		 je	 SHORT $LN21@P_LineOpen
  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00193	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0019a	75 1b		 jne	 SHORT $LN19@P_LineOpen
$LN21@P_LineOpen:
  0019c	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0019f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001a2	83 e1 04	 and	 ecx, 4
  001a5	74 0e		 je	 SHORT $LN22@P_LineOpen
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  001ac	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001b3	74 02		 je	 SHORT $LN19@P_LineOpen
$LN22@P_LineOpen:

; 464  : 				|| ((rover->flags & FF_BLOCKOTHERS) && !tmthing->player))) continue;

  001b5	eb ae		 jmp	 SHORT $LN2@P_LineOpen
$LN19@P_LineOpen:

; 465  : 
; 466  : 				delta1 = abs(tmthing->z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  001b7	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  001ba	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001bd	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  001c0	8b 02		 mov	 eax, DWORD PTR [edx]
  001c2	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  001c5	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001c8	8b 00		 mov	 eax, DWORD PTR [eax]
  001ca	2b 02		 sub	 eax, DWORD PTR [edx]
  001cc	99		 cdq
  001cd	2b c2		 sub	 eax, edx
  001cf	d1 f8		 sar	 eax, 1
  001d1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001d3	03 c8		 add	 ecx, eax
  001d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  001db	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001de	2b c1		 sub	 eax, ecx
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 _abs
  001e6	83 c4 04	 add	 esp, 4
  001e9	89 45 dc	 mov	 DWORD PTR _delta1$3[ebp], eax

; 467  : 				delta2 = abs(thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  001ec	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  001ef	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001f2	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  001f5	8b 02		 mov	 eax, DWORD PTR [edx]
  001f7	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  001fa	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001fd	8b 00		 mov	 eax, DWORD PTR [eax]
  001ff	2b 02		 sub	 eax, DWORD PTR [edx]
  00201	99		 cdq
  00202	2b c2		 sub	 eax, edx
  00204	d1 f8		 sar	 eax, 1
  00206	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00208	03 c8		 add	 ecx, eax
  0020a	8b 55 f0	 mov	 edx, DWORD PTR _thingtop$8[ebp]
  0020d	2b d1		 sub	 edx, ecx
  0020f	52		 push	 edx
  00210	e8 00 00 00 00	 call	 _abs
  00215	83 c4 04	 add	 esp, 4
  00218	89 45 d8	 mov	 DWORD PTR _delta2$2[ebp], eax

; 468  : 				if (*rover->bottomheight < lowestceiling && delta1 >= delta2)

  0021b	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0021e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00221	8b 11		 mov	 edx, DWORD PTR [ecx]
  00223	3b 55 e8	 cmp	 edx, DWORD PTR _lowestceiling$6[ebp]
  00226	7d 21		 jge	 SHORT $LN24@P_LineOpen
  00228	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  0022b	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  0022e	7c 19		 jl	 SHORT $LN24@P_LineOpen

; 469  : 				{
; 470  : 					if (!(rover->flags & FF_PLATFORM))

  00230	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00233	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00236	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  0023c	75 0b		 jne	 SHORT $LN24@P_LineOpen

; 471  : 						lowestceiling = *rover->bottomheight;

  0023e	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00241	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00244	8b 11		 mov	 edx, DWORD PTR [ecx]
  00246	89 55 e8	 mov	 DWORD PTR _lowestceiling$6[ebp], edx
$LN24@P_LineOpen:

; 472  : 				}
; 473  : 				if (*rover->topheight < highestfloor && delta1 >= delta2)

  00249	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0024c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00250	3b 55 e4	 cmp	 edx, DWORD PTR _highestfloor$5[ebp]
  00253	7d 20		 jge	 SHORT $LN26@P_LineOpen
  00255	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  00258	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  0025b	7c 18		 jl	 SHORT $LN26@P_LineOpen

; 474  : 				{
; 475  : 					if (!(rover->flags & FF_REVERSEPLATFORM))

  0025d	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00260	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00263	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  00269	75 0a		 jne	 SHORT $LN26@P_LineOpen

; 476  : 						lowestceiling = *rover->topheight;

  0026b	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0026e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00270	8b 11		 mov	 edx, DWORD PTR [ecx]
  00272	89 55 e8	 mov	 DWORD PTR _lowestceiling$6[ebp], edx
$LN26@P_LineOpen:

; 477  : 				}
; 478  : 
; 479  : 				if (*rover->topheight > highestfloor && delta1 < delta2)

  00275	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00278	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027c	3b 55 e4	 cmp	 edx, DWORD PTR _highestfloor$5[ebp]
  0027f	7e 14		 jle	 SHORT $LN27@P_LineOpen
  00281	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  00284	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  00287	7d 0c		 jge	 SHORT $LN27@P_LineOpen

; 480  : 					highestfloor = *rover->topheight;

  00289	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0028c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00290	89 55 e4	 mov	 DWORD PTR _highestfloor$5[ebp], edx
  00293	eb 1e		 jmp	 SHORT $LN29@P_LineOpen
$LN27@P_LineOpen:

; 481  : 				else if (*rover->topheight > lowestfloor && delta1 < delta2)

  00295	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00298	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0029c	3b 55 e0	 cmp	 edx, DWORD PTR _lowestfloor$4[ebp]
  0029f	7e 12		 jle	 SHORT $LN29@P_LineOpen
  002a1	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  002a4	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  002a7	7d 0a		 jge	 SHORT $LN29@P_LineOpen

; 482  : 					lowestfloor = *rover->topheight;

  002a9	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  002ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  002b0	89 55 e0	 mov	 DWORD PTR _lowestfloor$4[ebp], edx
$LN29@P_LineOpen:

; 483  : 			}

  002b3	e9 ad fe ff ff	 jmp	 $LN2@P_LineOpen
$LN3@P_LineOpen:

; 484  : 
; 485  : 			// Check for backsectors fake floors
; 486  : 			for (rover = back->ffloors; rover; rover = rover->next)

  002b8	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  002bb	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  002c1	89 4d ec	 mov	 DWORD PTR _rover$7[ebp], ecx
  002c4	eb 09		 jmp	 SHORT $LN7@P_LineOpen
$LN5@P_LineOpen:
  002c6	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  002c9	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  002cc	89 4d ec	 mov	 DWORD PTR _rover$7[ebp], ecx
$LN7@P_LineOpen:
  002cf	83 7d ec 00	 cmp	 DWORD PTR _rover$7[ebp], 0
  002d3	0f 84 40 01 00
	00		 je	 $LN6@P_LineOpen

; 487  : 			{
; 488  : 				if (!(rover->flags & FF_EXISTS) || !(((rover->flags & FF_BLOCKPLAYER) && tmthing->player)

  002d9	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  002dc	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002df	83 e1 01	 and	 ecx, 1
  002e2	74 32		 je	 SHORT $LN33@P_LineOpen
  002e4	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  002e7	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002ea	83 e1 02	 and	 ecx, 2
  002ed	74 0e		 je	 SHORT $LN32@P_LineOpen
  002ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  002f4	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  002fb	75 1b		 jne	 SHORT $LN30@P_LineOpen
$LN32@P_LineOpen:
  002fd	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00300	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00303	83 e1 04	 and	 ecx, 4
  00306	74 0e		 je	 SHORT $LN33@P_LineOpen
  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0030d	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00314	74 02		 je	 SHORT $LN30@P_LineOpen
$LN33@P_LineOpen:

; 489  : 				|| ((rover->flags & FF_BLOCKOTHERS) && !tmthing->player))) continue;

  00316	eb ae		 jmp	 SHORT $LN5@P_LineOpen
$LN30@P_LineOpen:

; 490  : 
; 491  : 				delta1 = abs(tmthing->z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  00318	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0031b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0031e	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  00321	8b 02		 mov	 eax, DWORD PTR [edx]
  00323	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  00326	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00329	8b 00		 mov	 eax, DWORD PTR [eax]
  0032b	2b 02		 sub	 eax, DWORD PTR [edx]
  0032d	99		 cdq
  0032e	2b c2		 sub	 eax, edx
  00330	d1 f8		 sar	 eax, 1
  00332	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00334	03 c8		 add	 ecx, eax
  00336	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0033c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0033f	2b c1		 sub	 eax, ecx
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _abs
  00347	83 c4 04	 add	 esp, 4
  0034a	89 45 dc	 mov	 DWORD PTR _delta1$3[ebp], eax

; 492  : 				delta2 = abs(thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  0034d	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00350	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00353	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  00356	8b 02		 mov	 eax, DWORD PTR [edx]
  00358	8b 55 ec	 mov	 edx, DWORD PTR _rover$7[ebp]
  0035b	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0035e	8b 00		 mov	 eax, DWORD PTR [eax]
  00360	2b 02		 sub	 eax, DWORD PTR [edx]
  00362	99		 cdq
  00363	2b c2		 sub	 eax, edx
  00365	d1 f8		 sar	 eax, 1
  00367	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00369	03 c8		 add	 ecx, eax
  0036b	8b 55 f0	 mov	 edx, DWORD PTR _thingtop$8[ebp]
  0036e	2b d1		 sub	 edx, ecx
  00370	52		 push	 edx
  00371	e8 00 00 00 00	 call	 _abs
  00376	83 c4 04	 add	 esp, 4
  00379	89 45 d8	 mov	 DWORD PTR _delta2$2[ebp], eax

; 493  : 				if (*rover->bottomheight < lowestceiling && delta1 >= delta2)

  0037c	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0037f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00382	8b 11		 mov	 edx, DWORD PTR [ecx]
  00384	3b 55 e8	 cmp	 edx, DWORD PTR _lowestceiling$6[ebp]
  00387	7d 21		 jge	 SHORT $LN35@P_LineOpen
  00389	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  0038c	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  0038f	7c 19		 jl	 SHORT $LN35@P_LineOpen

; 494  : 				{
; 495  : 					if (!(rover->flags & FF_PLATFORM))

  00391	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  00394	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00397	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  0039d	75 0b		 jne	 SHORT $LN35@P_LineOpen

; 496  : 						lowestceiling = *rover->bottomheight;

  0039f	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003a2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  003a7	89 55 e8	 mov	 DWORD PTR _lowestceiling$6[ebp], edx
$LN35@P_LineOpen:

; 497  : 				}
; 498  : 				if (*rover->topheight < highestfloor && delta1 >= delta2)

  003aa	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  003af	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b1	3b 55 e4	 cmp	 edx, DWORD PTR _highestfloor$5[ebp]
  003b4	7d 20		 jge	 SHORT $LN37@P_LineOpen
  003b6	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  003b9	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  003bc	7c 18		 jl	 SHORT $LN37@P_LineOpen

; 499  : 				{
; 500  : 					if (!(rover->flags & FF_REVERSEPLATFORM))

  003be	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003c1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003c4	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  003ca	75 0a		 jne	 SHORT $LN37@P_LineOpen

; 501  : 						lowestceiling = *rover->topheight;

  003cc	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d3	89 55 e8	 mov	 DWORD PTR _lowestceiling$6[ebp], edx
$LN37@P_LineOpen:

; 502  : 				}
; 503  : 
; 504  : 				if (*rover->topheight > highestfloor && delta1 < delta2)

  003d6	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003db	8b 11		 mov	 edx, DWORD PTR [ecx]
  003dd	3b 55 e4	 cmp	 edx, DWORD PTR _highestfloor$5[ebp]
  003e0	7e 14		 jle	 SHORT $LN38@P_LineOpen
  003e2	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  003e5	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  003e8	7d 0c		 jge	 SHORT $LN38@P_LineOpen

; 505  : 					highestfloor = *rover->topheight;

  003ea	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ef	8b 11		 mov	 edx, DWORD PTR [ecx]
  003f1	89 55 e4	 mov	 DWORD PTR _highestfloor$5[ebp], edx
  003f4	eb 1e		 jmp	 SHORT $LN40@P_LineOpen
$LN38@P_LineOpen:

; 506  : 				else if (*rover->topheight > lowestfloor && delta1 < delta2)

  003f6	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  003f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  003fd	3b 55 e0	 cmp	 edx, DWORD PTR _lowestfloor$4[ebp]
  00400	7e 12		 jle	 SHORT $LN40@P_LineOpen
  00402	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  00405	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  00408	7d 0a		 jge	 SHORT $LN40@P_LineOpen

; 507  : 					lowestfloor = *rover->topheight;

  0040a	8b 45 ec	 mov	 eax, DWORD PTR _rover$7[ebp]
  0040d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0040f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00411	89 55 e0	 mov	 DWORD PTR _lowestfloor$4[ebp], edx
$LN40@P_LineOpen:

; 508  : 			}

  00414	e9 ad fe ff ff	 jmp	 $LN5@P_LineOpen
$LN6@P_LineOpen:

; 509  : 
; 510  : #ifdef POLYOBJECTS
; 511  : 			// Treat polyobj's backsector like a 3D Floor
; 512  : 			if (linedef->polyobj && (linedef->polyobj->flags & POF_TESTHEIGHT))

  00419	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  0041c	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00420	0f 84 c8 00 00
	00		 je	 $LN45@P_LineOpen
  00426	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  00429	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0042c	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00432	83 e2 04	 and	 edx, 4
  00435	0f 84 b3 00 00
	00		 je	 $LN45@P_LineOpen

; 513  : 			{
; 514  : 				const sector_t *polysec = linedef->backsector;

  0043b	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  0043e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00441	89 4d d4	 mov	 DWORD PTR _polysec$1[ebp], ecx

; 515  : 
; 516  : 				delta1 = abs(tmthing->z - (polysec->floorheight + ((polysec->ceilingheight - polysec->floorheight)/2)));

  00444	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  00447	8b 4d d4	 mov	 ecx, DWORD PTR _polysec$1[ebp]
  0044a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0044d	2b 01		 sub	 eax, DWORD PTR [ecx]
  0044f	99		 cdq
  00450	2b c2		 sub	 eax, edx
  00452	d1 f8		 sar	 eax, 1
  00454	8b 55 d4	 mov	 edx, DWORD PTR _polysec$1[ebp]
  00457	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00459	03 c8		 add	 ecx, eax
  0045b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00461	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00464	2b c1		 sub	 eax, ecx
  00466	50		 push	 eax
  00467	e8 00 00 00 00	 call	 _abs
  0046c	83 c4 04	 add	 esp, 4
  0046f	89 45 dc	 mov	 DWORD PTR _delta1$3[ebp], eax

; 517  : 				delta2 = abs(thingtop - (polysec->floorheight + ((polysec->ceilingheight - polysec->floorheight)/2)));

  00472	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  00475	8b 4d d4	 mov	 ecx, DWORD PTR _polysec$1[ebp]
  00478	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0047b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0047d	99		 cdq
  0047e	2b c2		 sub	 eax, edx
  00480	d1 f8		 sar	 eax, 1
  00482	8b 55 d4	 mov	 edx, DWORD PTR _polysec$1[ebp]
  00485	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00487	03 c8		 add	 ecx, eax
  00489	8b 55 f0	 mov	 edx, DWORD PTR _thingtop$8[ebp]
  0048c	2b d1		 sub	 edx, ecx
  0048e	52		 push	 edx
  0048f	e8 00 00 00 00	 call	 _abs
  00494	83 c4 04	 add	 esp, 4
  00497	89 45 d8	 mov	 DWORD PTR _delta2$2[ebp], eax

; 518  : 				if (polysec->floorheight < lowestceiling && delta1 >= delta2)

  0049a	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  0049d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0049f	3b 4d e8	 cmp	 ecx, DWORD PTR _lowestceiling$6[ebp]
  004a2	7d 10		 jge	 SHORT $LN42@P_LineOpen
  004a4	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  004a7	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  004aa	7c 08		 jl	 SHORT $LN42@P_LineOpen

; 519  : 					lowestceiling = polysec->floorheight;

  004ac	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  004af	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b1	89 4d e8	 mov	 DWORD PTR _lowestceiling$6[ebp], ecx
$LN42@P_LineOpen:

; 520  : 
; 521  : 				if (polysec->ceilingheight > highestfloor && delta1 < delta2)

  004b4	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  004b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004ba	3b 4d e4	 cmp	 ecx, DWORD PTR _highestfloor$5[ebp]
  004bd	7e 13		 jle	 SHORT $LN43@P_LineOpen
  004bf	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  004c2	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  004c5	7d 0b		 jge	 SHORT $LN43@P_LineOpen

; 522  : 					highestfloor = polysec->ceilingheight;

  004c7	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  004ca	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004cd	89 4d e4	 mov	 DWORD PTR _highestfloor$5[ebp], ecx
  004d0	eb 1c		 jmp	 SHORT $LN45@P_LineOpen
$LN43@P_LineOpen:

; 523  : 				else if (polysec->ceilingheight > lowestfloor && delta1 < delta2)

  004d2	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  004d5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004d8	3b 4d e0	 cmp	 ecx, DWORD PTR _lowestfloor$4[ebp]
  004db	7e 11		 jle	 SHORT $LN45@P_LineOpen
  004dd	8b 45 dc	 mov	 eax, DWORD PTR _delta1$3[ebp]
  004e0	3b 45 d8	 cmp	 eax, DWORD PTR _delta2$2[ebp]
  004e3	7d 09		 jge	 SHORT $LN45@P_LineOpen

; 524  : 					lowestfloor = polysec->ceilingheight;

  004e5	8b 45 d4	 mov	 eax, DWORD PTR _polysec$1[ebp]
  004e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004eb	89 4d e0	 mov	 DWORD PTR _lowestfloor$4[ebp], ecx
$LN45@P_LineOpen:

; 525  : 			}
; 526  : #endif
; 527  : 
; 528  : 			if (highestfloor > openbottom)

  004ee	8b 45 e4	 mov	 eax, DWORD PTR _highestfloor$5[ebp]
  004f1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _openbottom
  004f7	7e 08		 jle	 SHORT $LN46@P_LineOpen

; 529  : 				openbottom = highestfloor;

  004f9	8b 45 e4	 mov	 eax, DWORD PTR _highestfloor$5[ebp]
  004fc	a3 00 00 00 00	 mov	 DWORD PTR _openbottom, eax
$LN46@P_LineOpen:

; 530  : 
; 531  : 			if (lowestceiling < opentop)

  00501	8b 45 e8	 mov	 eax, DWORD PTR _lowestceiling$6[ebp]
  00504	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _opentop
  0050a	7d 08		 jge	 SHORT $LN47@P_LineOpen

; 532  : 				opentop = lowestceiling;

  0050c	8b 45 e8	 mov	 eax, DWORD PTR _lowestceiling$6[ebp]
  0050f	a3 00 00 00 00	 mov	 DWORD PTR _opentop, eax
$LN47@P_LineOpen:

; 533  : 
; 534  : 			if (lowestfloor > lowfloor)

  00514	8b 45 e0	 mov	 eax, DWORD PTR _lowestfloor$4[ebp]
  00517	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lowfloor
  0051d	7e 08		 jle	 SHORT $LN48@P_LineOpen

; 535  : 				lowfloor = lowestfloor;

  0051f	8b 45 e0	 mov	 eax, DWORD PTR _lowestfloor$4[ebp]
  00522	a3 00 00 00 00	 mov	 DWORD PTR _lowfloor, eax
$LN48@P_LineOpen:

; 536  : 		}
; 537  : 		openrange = opentop - openbottom;

  00527	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  0052c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _openbottom
  00532	a3 00 00 00 00	 mov	 DWORD PTR _openrange, eax

; 538  : 		return;

  00537	eb 72		 jmp	 SHORT $LN1@P_LineOpen
$LN11@P_LineOpen:

; 539  : 	}
; 540  : 
; 541  : 	if (front->ceilingheight < back->ceilingheight)

  00539	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  0053c	8b 4d f8	 mov	 ecx, DWORD PTR _back$[ebp]
  0053f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00542	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00545	7d 0e		 jge	 SHORT $LN49@P_LineOpen

; 542  : 		opentop = front->ceilingheight;

  00547	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  0054a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0054d	89 0d 00 00 00
	00		 mov	 DWORD PTR _opentop, ecx
  00553	eb 0c		 jmp	 SHORT $LN50@P_LineOpen
$LN49@P_LineOpen:

; 543  : 	else
; 544  : 		opentop = back->ceilingheight;

  00555	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  00558	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0055b	89 0d 00 00 00
	00		 mov	 DWORD PTR _opentop, ecx
$LN50@P_LineOpen:

; 545  : 
; 546  : 	if (front->floorheight > back->floorheight)

  00561	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00564	8b 4d f8	 mov	 ecx, DWORD PTR _back$[ebp]
  00567	8b 10		 mov	 edx, DWORD PTR [eax]
  00569	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0056b	7e 18		 jle	 SHORT $LN51@P_LineOpen

; 547  : 	{
; 548  : 		openbottom = front->floorheight;

  0056d	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00570	8b 08		 mov	 ecx, DWORD PTR [eax]
  00572	89 0d 00 00 00
	00		 mov	 DWORD PTR _openbottom, ecx

; 549  : 		lowfloor = back->floorheight;

  00578	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  0057b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0057d	89 0d 00 00 00
	00		 mov	 DWORD PTR _lowfloor, ecx

; 550  : 	}

  00583	eb 16		 jmp	 SHORT $no_thing$54
$LN51@P_LineOpen:

; 551  : 	else
; 552  : 	{
; 553  : 		openbottom = back->floorheight;

  00585	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  00588	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058a	89 0d 00 00 00
	00		 mov	 DWORD PTR _openbottom, ecx

; 554  : 		lowfloor = front->floorheight;

  00590	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00593	8b 08		 mov	 ecx, DWORD PTR [eax]
  00595	89 0d 00 00 00
	00		 mov	 DWORD PTR _lowfloor, ecx
$no_thing$54:

; 555  : 	}
; 556  : 
; 557  : no_thing:
; 558  : 
; 559  : 	openrange = opentop - openbottom;

  0059b	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  005a0	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _openbottom
  005a6	a3 00 00 00 00	 mov	 DWORD PTR _openrange, eax
$LN1@P_LineOpen:

; 560  : }

  005ab	5f		 pop	 edi
  005ac	5e		 pop	 esi
  005ad	5b		 pop	 ebx
  005ae	8b e5		 mov	 esp, ebp
  005b0	5d		 pop	 ebp
  005b1	c3		 ret	 0
_P_LineOpening ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_SetPrecipitationThingPosition
_TEXT	SEGMENT
tv65 = -80						; size = 4
_snext$ = -12						; size = 4
_link$ = -8						; size = 4
_ss$ = -4						; size = 4
_thing$ = 8						; size = 4
_P_SetPrecipitationThingPosition PROC			; COMDAT

; 734  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 735  : 	subsector_t *ss = thing->subsector = R_PointInSubsector(thing->x, thing->y);

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00013	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _R_PointInSubsector
  0001c	83 c4 08	 add	 esp, 8
  0001f	89 45 b0	 mov	 DWORD PTR tv65[ebp], eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00025	8b 55 b0	 mov	 edx, DWORD PTR tv65[ebp]
  00028	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  0002b	8b 45 b0	 mov	 eax, DWORD PTR tv65[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR _ss$[ebp], eax

; 736  : 
; 737  : 	precipmobj_t **link = &ss->sector->preciplist;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _ss$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	81 c1 f0 00 00
	00		 add	 ecx, 240		; 000000f0H
  0003c	89 4d f8	 mov	 DWORD PTR _link$[ebp], ecx

; 738  : 	precipmobj_t *snext = *link;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _link$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	89 4d f4	 mov	 DWORD PTR _snext$[ebp], ecx

; 739  : 	if ((thing->snext = snext) != NULL)

  00047	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _snext$[ebp]
  0004d	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00050	83 7d f4 00	 cmp	 DWORD PTR _snext$[ebp], 0
  00054	74 0c		 je	 SHORT $LN2@P_SetPreci

; 740  : 		snext->sprev = &thing->snext;

  00056	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00059	83 c0 1c	 add	 eax, 28			; 0000001cH
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _snext$[ebp]
  0005f	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN2@P_SetPreci:

; 741  : 	thing->sprev = link;

  00062	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _link$[ebp]
  00068	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 742  : 	*link = thing;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _link$[ebp]
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00071	89 08		 mov	 DWORD PTR [eax], ecx

; 743  : 
; 744  : 	P_CreatePrecipSecNodeList(thing, thing->x, thing->y);

  00073	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00076	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00079	51		 push	 ecx
  0007a	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0007d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _P_CreatePrecipSecNodeList
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 745  : 	thing->touching_sectorlist = precipsector_list; // Attach to Thing's precipmobj_t

  0008d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _precipsector_list
  00096	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 746  : 	precipsector_list = NULL; // clear for next time

  00099	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _precipsector_list, 0

; 747  : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_P_SetPrecipitationThingPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_UnsetPrecipThingPosition
_TEXT	SEGMENT
_snext$ = -8						; size = 4
_sprev$ = -4						; size = 4
_thing$ = 8						; size = 4
_P_UnsetPrecipThingPosition PROC			; COMDAT

; 634  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 635  : 	precipmobj_t **sprev = thing->sprev;

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	89 4d fc	 mov	 DWORD PTR _sprev$[ebp], ecx

; 636  : 	precipmobj_t  *snext = thing->snext;

  00012	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00015	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00018	89 4d f8	 mov	 DWORD PTR _snext$[ebp], ecx

; 637  : 	if ((*sprev = snext) != NULL)  // unlink from sector list

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _sprev$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _snext$[ebp]
  00021	89 08		 mov	 DWORD PTR [eax], ecx
  00023	83 7d f8 00	 cmp	 DWORD PTR _snext$[ebp], 0
  00027	74 09		 je	 SHORT $LN2@P_UnsetPre

; 638  : 		snext->sprev = sprev;

  00029	8b 45 f8	 mov	 eax, DWORD PTR _snext$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _sprev$[ebp]
  0002f	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$LN2@P_UnsetPre:

; 639  : 
; 640  : 	precipsector_list = thing->touching_sectorlist;

  00032	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00035	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00038	89 0d 00 00 00
	00		 mov	 DWORD PTR _precipsector_list, ecx

; 641  : 	thing->touching_sectorlist = NULL; //to be restored by P_SetPrecipThingPosition

  0003e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00041	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 642  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_P_UnsetPrecipThingPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_BoxOnLineSide
_TEXT	SEGMENT
tv65 = -76						; size = 4
tv71 = -76						; size = 4
tv77 = -76						; size = 4
tv87 = -76						; size = 4
tv93 = -76						; size = 4
_p2$ = -8						; size = 4
_p1$ = -4						; size = 4
_tmbox$ = 8						; size = 4
_ld$ = 12						; size = 4
_P_BoxOnLineSide PROC					; COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 140  : 	INT32 p1, p2;
; 141  : 
; 142  : 	switch (ld->slopetype)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0000f	89 4d b4	 mov	 DWORD PTR tv65[ebp], ecx
  00012	83 7d b4 03	 cmp	 DWORD PTR tv65[ebp], 3
  00016	0f 87 b5 01 00
	00		 ja	 $LN10@P_BoxOnLin
  0001c	8b 55 b4	 mov	 edx, DWORD PTR tv65[ebp]
  0001f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN21@P_BoxOnLin[edx*4]
$LN4@P_BoxOnLin:

; 143  : 	{
; 144  : 		case ST_HORIZONTAL:
; 145  : 			p1 = tmbox[BOXTOP] > ld->v1->y;

  00026	b8 04 00 00 00	 mov	 eax, 4
  0002b	6b c8 00	 imul	 ecx, eax, 0
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _ld$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	8b 55 08	 mov	 edx, DWORD PTR _tmbox$[ebp]
  00036	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  00039	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0003c	7e 09		 jle	 SHORT $LN13@P_BoxOnLin
  0003e	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00045	eb 07		 jmp	 SHORT $LN14@P_BoxOnLin
$LN13@P_BoxOnLin:
  00047	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN14@P_BoxOnLin:
  0004e	8b 55 b4	 mov	 edx, DWORD PTR tv71[ebp]
  00051	89 55 fc	 mov	 DWORD PTR _p1$[ebp], edx

; 146  : 			p2 = tmbox[BOXBOTTOM] > ld->v1->y;

  00054	b8 04 00 00 00	 mov	 eax, 4
  00059	c1 e0 00	 shl	 eax, 0
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _ld$[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _tmbox$[ebp]
  00064	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00067	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0006a	7e 09		 jle	 SHORT $LN15@P_BoxOnLin
  0006c	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00073	eb 07		 jmp	 SHORT $LN16@P_BoxOnLin
$LN15@P_BoxOnLin:
  00075	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN16@P_BoxOnLin:
  0007c	8b 4d b4	 mov	 ecx, DWORD PTR tv77[ebp]
  0007f	89 4d f8	 mov	 DWORD PTR _p2$[ebp], ecx

; 147  : 			if (ld->dx < 0)

  00082	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  00085	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00089	7d 12		 jge	 SHORT $LN5@P_BoxOnLin

; 148  : 			{
; 149  : 				p1 ^= 1;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  0008e	83 f0 01	 xor	 eax, 1
  00091	89 45 fc	 mov	 DWORD PTR _p1$[ebp], eax

; 150  : 				p2 ^= 1;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _p2$[ebp]
  00097	83 f0 01	 xor	 eax, 1
  0009a	89 45 f8	 mov	 DWORD PTR _p2$[ebp], eax
$LN5@P_BoxOnLin:

; 151  : 			}
; 152  : 			break;

  0009d	e9 48 01 00 00	 jmp	 $LN2@P_BoxOnLin
$LN6@P_BoxOnLin:

; 153  : 
; 154  : 		case ST_VERTICAL:
; 155  : 			p1 = tmbox[BOXRIGHT] < ld->v1->x;

  000a2	b8 04 00 00 00	 mov	 eax, 4
  000a7	6b c8 03	 imul	 ecx, eax, 3
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _ld$[ebp]
  000ad	8b 02		 mov	 eax, DWORD PTR [edx]
  000af	8b 55 08	 mov	 edx, DWORD PTR _tmbox$[ebp]
  000b2	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  000b5	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000b7	7d 09		 jge	 SHORT $LN17@P_BoxOnLin
  000b9	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  000c0	eb 07		 jmp	 SHORT $LN18@P_BoxOnLin
$LN17@P_BoxOnLin:
  000c2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN18@P_BoxOnLin:
  000c9	8b 55 b4	 mov	 edx, DWORD PTR tv87[ebp]
  000cc	89 55 fc	 mov	 DWORD PTR _p1$[ebp], edx

; 156  : 			p2 = tmbox[BOXLEFT] < ld->v1->x;

  000cf	b8 04 00 00 00	 mov	 eax, 4
  000d4	d1 e0		 shl	 eax, 1
  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _ld$[ebp]
  000d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _tmbox$[ebp]
  000de	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  000e1	3b 02		 cmp	 eax, DWORD PTR [edx]
  000e3	7d 09		 jge	 SHORT $LN19@P_BoxOnLin
  000e5	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
  000ec	eb 07		 jmp	 SHORT $LN20@P_BoxOnLin
$LN19@P_BoxOnLin:
  000ee	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$LN20@P_BoxOnLin:
  000f5	8b 4d b4	 mov	 ecx, DWORD PTR tv93[ebp]
  000f8	89 4d f8	 mov	 DWORD PTR _p2$[ebp], ecx

; 157  : 			if (ld->dy < 0)

  000fb	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  000fe	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00102	7d 12		 jge	 SHORT $LN7@P_BoxOnLin

; 158  : 			{
; 159  : 				p1 ^= 1;

  00104	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  00107	83 f0 01	 xor	 eax, 1
  0010a	89 45 fc	 mov	 DWORD PTR _p1$[ebp], eax

; 160  : 				p2 ^= 1;

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _p2$[ebp]
  00110	83 f0 01	 xor	 eax, 1
  00113	89 45 f8	 mov	 DWORD PTR _p2$[ebp], eax
$LN7@P_BoxOnLin:

; 161  : 			}
; 162  : 			break;

  00116	e9 cf 00 00 00	 jmp	 $LN2@P_BoxOnLin
$LN8@P_BoxOnLin:

; 163  : 
; 164  : 		case ST_POSITIVE:
; 165  : 			p1 = P_PointOnLineSide(tmbox[BOXLEFT], tmbox[BOXTOP], ld);

  0011b	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  0011e	50		 push	 eax
  0011f	b9 04 00 00 00	 mov	 ecx, 4
  00124	6b d1 00	 imul	 edx, ecx, 0
  00127	8b 45 08	 mov	 eax, DWORD PTR _tmbox$[ebp]
  0012a	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0012d	51		 push	 ecx
  0012e	ba 04 00 00 00	 mov	 edx, 4
  00133	d1 e2		 shl	 edx, 1
  00135	8b 45 08	 mov	 eax, DWORD PTR _tmbox$[ebp]
  00138	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00141	83 c4 0c	 add	 esp, 12			; 0000000cH
  00144	89 45 fc	 mov	 DWORD PTR _p1$[ebp], eax

; 166  : 			p2 = P_PointOnLineSide(tmbox[BOXRIGHT], tmbox[BOXBOTTOM], ld);

  00147	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  0014a	50		 push	 eax
  0014b	b9 04 00 00 00	 mov	 ecx, 4
  00150	c1 e1 00	 shl	 ecx, 0
  00153	8b 55 08	 mov	 edx, DWORD PTR _tmbox$[ebp]
  00156	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00159	50		 push	 eax
  0015a	b9 04 00 00 00	 mov	 ecx, 4
  0015f	6b d1 03	 imul	 edx, ecx, 3
  00162	8b 45 08	 mov	 eax, DWORD PTR _tmbox$[ebp]
  00165	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	89 45 f8	 mov	 DWORD PTR _p2$[ebp], eax

; 167  : 			break;

  00174	eb 74		 jmp	 SHORT $LN2@P_BoxOnLin
$LN9@P_BoxOnLin:

; 168  : 
; 169  : 		case ST_NEGATIVE:
; 170  : 			p1 = P_PointOnLineSide(tmbox[BOXRIGHT], tmbox[BOXTOP], ld);

  00176	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  00179	50		 push	 eax
  0017a	b9 04 00 00 00	 mov	 ecx, 4
  0017f	6b d1 00	 imul	 edx, ecx, 0
  00182	8b 45 08	 mov	 eax, DWORD PTR _tmbox$[ebp]
  00185	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00188	51		 push	 ecx
  00189	ba 04 00 00 00	 mov	 edx, 4
  0018e	6b c2 03	 imul	 eax, edx, 3
  00191	8b 4d 08	 mov	 ecx, DWORD PTR _tmbox$[ebp]
  00194	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00197	52		 push	 edx
  00198	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a0	89 45 fc	 mov	 DWORD PTR _p1$[ebp], eax

; 171  : 			p2 = P_PointOnLineSide(tmbox[BOXLEFT], tmbox[BOXBOTTOM], ld);

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  001a6	50		 push	 eax
  001a7	b9 04 00 00 00	 mov	 ecx, 4
  001ac	c1 e1 00	 shl	 ecx, 0
  001af	8b 55 08	 mov	 edx, DWORD PTR _tmbox$[ebp]
  001b2	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001b5	50		 push	 eax
  001b6	b9 04 00 00 00	 mov	 ecx, 4
  001bb	d1 e1		 shl	 ecx, 1
  001bd	8b 55 08	 mov	 edx, DWORD PTR _tmbox$[ebp]
  001c0	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _P_PointOnLineSide
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	89 45 f8	 mov	 DWORD PTR _p2$[ebp], eax

; 172  : 			break;

  001cf	eb 19		 jmp	 SHORT $LN2@P_BoxOnLin
$LN10@P_BoxOnLin:

; 173  : 
; 174  : 		default:
; 175  : 			I_Error("P_BoxOnLineSide: unknown slopetype %d\n", ld->slopetype);

  001d1	8b 45 0c	 mov	 eax, DWORD PTR _ld$[ebp]
  001d4	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001d7	51		 push	 ecx
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@HHFBIKFP@P_BoxOnLineSide?3?5unknown?5slopet@
  001dd	e8 00 00 00 00	 call	 _I_Error
  001e2	83 c4 08	 add	 esp, 8

; 176  : 			return -1;

  001e5	83 c8 ff	 or	 eax, -1
  001e8	eb 10		 jmp	 SHORT $LN1@P_BoxOnLin
$LN2@P_BoxOnLin:

; 177  : 	}
; 178  : 
; 179  : 	if (p1 == p2)

  001ea	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  001ed	3b 45 f8	 cmp	 eax, DWORD PTR _p2$[ebp]
  001f0	75 05		 jne	 SHORT $LN11@P_BoxOnLin

; 180  : 		return p1;

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  001f5	eb 03		 jmp	 SHORT $LN1@P_BoxOnLin
$LN11@P_BoxOnLin:

; 181  : 	return -1;

  001f7	83 c8 ff	 or	 eax, -1
$LN1@P_BoxOnLin:

; 182  : }

  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	5b		 pop	 ebx
  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c3		 ret	 0
  00201	0f 1f 00	 npad	 3
$LN21@P_BoxOnLin:
  00204	00 00 00 00	 DD	 $LN4@P_BoxOnLin
  00208	00 00 00 00	 DD	 $LN6@P_BoxOnLin
  0020c	00 00 00 00	 DD	 $LN8@P_BoxOnLin
  00210	00 00 00 00	 DD	 $LN9@P_BoxOnLin
_P_BoxOnLineSide ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_InterceptVector
_TEXT	SEGMENT
_den$ = -12						; size = 4
_num$ = -8						; size = 4
_frac$ = -4						; size = 4
_v2$ = 8						; size = 4
_v1$ = 12						; size = 4
_P_InterceptVector PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 244  : 	fixed_t frac, num, den;
; 245  : 
; 246  : 	den = FixedMul(v1->dy>>8, v2->dx) - FixedMul(v1->dx>>8, v2->dy);

  00009	8b 45 08	 mov	 eax, DWORD PTR _v2$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00013	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00016	c1 f8 08	 sar	 eax, 8
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _FixedMul
  0001f	83 c4 08	 add	 esp, 8
  00022	8b f0		 mov	 esi, eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _v2$[ebp]
  00027	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002a	52		 push	 edx
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0002e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00031	c1 f9 08	 sar	 ecx, 8
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _FixedMul
  0003a	83 c4 08	 add	 esp, 8
  0003d	2b f0		 sub	 esi, eax
  0003f	89 75 f4	 mov	 DWORD PTR _den$[ebp], esi

; 247  : 
; 248  : 	if (!den)

  00042	75 04		 jne	 SHORT $LN2@P_Intercep

; 249  : 		return 0;

  00044	33 c0		 xor	 eax, eax
  00046	eb 59		 jmp	 SHORT $LN1@P_Intercep
$LN2@P_Intercep:

; 250  : 
; 251  : 	num = FixedMul((v1->x - v2->x)>>8, v1->dy) + FixedMul((v2->y - v1->y)>>8, v1->dx);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0004b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004e	51		 push	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00052	8b 45 08	 mov	 eax, DWORD PTR _v2$[ebp]
  00055	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00057	2b 08		 sub	 ecx, DWORD PTR [eax]
  00059	c1 f9 08	 sar	 ecx, 8
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 _FixedMul
  00062	83 c4 08	 add	 esp, 8
  00065	8b f0		 mov	 esi, eax
  00067	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  0006a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _v2$[ebp]
  00071	8b 55 0c	 mov	 edx, DWORD PTR _v1$[ebp]
  00074	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00077	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0007a	c1 f8 08	 sar	 eax, 8
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _FixedMul
  00083	83 c4 08	 add	 esp, 8
  00086	03 f0		 add	 esi, eax
  00088	89 75 f8	 mov	 DWORD PTR _num$[ebp], esi

; 252  : 	frac = FixedDiv(num, den);

  0008b	8b 45 f4	 mov	 eax, DWORD PTR _den$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _num$[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _FixedDiv
  00098	83 c4 08	 add	 esp, 8
  0009b	89 45 fc	 mov	 DWORD PTR _frac$[ebp], eax

; 253  : 
; 254  : 	return frac;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _frac$[ebp]
$LN1@P_Intercep:

; 255  : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_P_InterceptVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_CameraLineOpening
_TEXT	SEGMENT
_delta2$1 = -56						; size = 4
_delta1$2 = -52						; size = 4
_lowestfloor$3 = -48					; size = 4
_highestfloor$4 = -44					; size = 4
_lowestceiling$5 = -40					; size = 4
_rover$6 = -36						; size = 4
_thingtop$7 = -32					; size = 4
_thingbot$8 = -28					; size = 4
_backceiling$ = -24					; size = 4
_backfloor$ = -20					; size = 4
_frontceiling$ = -16					; size = 4
_frontfloor$ = -12					; size = 4
_back$ = -8						; size = 4
_front$ = -4						; size = 4
_linedef$ = 8						; size = 4
_P_CameraLineOpening PROC				; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 269  : 	sector_t *front;
; 270  : 	sector_t *back;
; 271  : 	fixed_t frontfloor, frontceiling, backfloor, backceiling;
; 272  : 
; 273  : 	if (linedef->sidenum[1] == 0xffff)

  00009	b8 02 00 00 00	 mov	 eax, 2
  0000e	c1 e0 00	 shl	 eax, 0
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _linedef$[ebp]
  00014	0f b7 54 01 16	 movzx	 edx, WORD PTR [ecx+eax+22]
  00019	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0001f	75 0f		 jne	 SHORT $LN8@P_CameraLi

; 274  : 	{
; 275  : 		// single sided line
; 276  : 		openrange = 0;

  00021	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _openrange, 0

; 277  : 		return;

  0002b	e9 b7 03 00 00	 jmp	 $LN1@P_CameraLi
$LN8@P_CameraLi:

; 278  : 	}
; 279  : 
; 280  : 	front = linedef->frontsector;

  00030	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  00033	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00036	89 4d fc	 mov	 DWORD PTR _front$[ebp], ecx

; 281  : 	back = linedef->backsector;

  00039	8b 45 08	 mov	 eax, DWORD PTR _linedef$[ebp]
  0003c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0003f	89 4d f8	 mov	 DWORD PTR _back$[ebp], ecx

; 282  : 
; 283  : 	// Cameras use the heightsec's heights rather then the actual sector heights.
; 284  : 	// If you can see through it, why not move the camera through it too?
; 285  : 	if (front->heightsec >= 0)

  00042	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00045	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00049	7c 2f		 jl	 SHORT $LN9@P_CameraLi

; 286  : 	{
; 287  : 		frontfloor = sectors[front->heightsec].floorheight;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  0004e	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0005b	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0005e	89 45 f4	 mov	 DWORD PTR _frontfloor$[ebp], eax

; 288  : 		frontceiling = sectors[front->heightsec].ceilingheight;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00064	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  0006b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00071	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00075	89 45 f0	 mov	 DWORD PTR _frontceiling$[ebp], eax

; 289  : 	}

  00078	eb 11		 jmp	 SHORT $LN10@P_CameraLi
$LN9@P_CameraLi:

; 290  : 	else
; 291  : 	{
; 292  : 		frontfloor = front->floorheight;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	89 4d f4	 mov	 DWORD PTR _frontfloor$[ebp], ecx

; 293  : 		frontceiling = front->ceilingheight;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00085	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00088	89 4d f0	 mov	 DWORD PTR _frontceiling$[ebp], ecx
$LN10@P_CameraLi:

; 294  : 	}
; 295  : 	if (back->heightsec >= 0)

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  0008e	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00092	7c 2f		 jl	 SHORT $LN11@P_CameraLi

; 296  : 	{
; 297  : 		backfloor = sectors[back->heightsec].floorheight;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  00097	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  0009e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  000a4	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  000a7	89 45 ec	 mov	 DWORD PTR _backfloor$[ebp], eax

; 298  : 		backceiling = sectors[back->heightsec].ceilingheight;

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  000ad	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  000b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  000ba	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  000be	89 45 e8	 mov	 DWORD PTR _backceiling$[ebp], eax

; 299  : 	}

  000c1	eb 11		 jmp	 SHORT $LN12@P_CameraLi
$LN11@P_CameraLi:

; 300  : 	else
; 301  : 	{
; 302  : 		backfloor = back->floorheight;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	89 4d ec	 mov	 DWORD PTR _backfloor$[ebp], ecx

; 303  : 		backceiling = back->ceilingheight;

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  000ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d1	89 4d e8	 mov	 DWORD PTR _backceiling$[ebp], ecx
$LN12@P_CameraLi:

; 304  : 	}
; 305  : 
; 306  : 	{
; 307  : 		fixed_t thingbot, thingtop;
; 308  : 
; 309  : 		thingbot = camera.z;

  000d4	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera+24
  000d9	89 45 e4	 mov	 DWORD PTR _thingbot$8[ebp], eax

; 310  : 		thingtop = thingbot + camera.height;

  000dc	8b 45 e4	 mov	 eax, DWORD PTR _thingbot$8[ebp]
  000df	03 05 30 00 00
	00		 add	 eax, DWORD PTR _camera+48
  000e5	89 45 e0	 mov	 DWORD PTR _thingtop$7[ebp], eax

; 311  : 
; 312  : 		if (frontceiling < backceiling)

  000e8	8b 45 f0	 mov	 eax, DWORD PTR _frontceiling$[ebp]
  000eb	3b 45 e8	 cmp	 eax, DWORD PTR _backceiling$[ebp]
  000ee	7d 0a		 jge	 SHORT $LN13@P_CameraLi

; 313  : 			opentop = frontceiling;

  000f0	8b 45 f0	 mov	 eax, DWORD PTR _frontceiling$[ebp]
  000f3	a3 00 00 00 00	 mov	 DWORD PTR _opentop, eax
  000f8	eb 08		 jmp	 SHORT $LN14@P_CameraLi
$LN13@P_CameraLi:

; 314  : 		else
; 315  : 			opentop = backceiling;

  000fa	8b 45 e8	 mov	 eax, DWORD PTR _backceiling$[ebp]
  000fd	a3 00 00 00 00	 mov	 DWORD PTR _opentop, eax
$LN14@P_CameraLi:

; 316  : 
; 317  : 		if (frontfloor > backfloor)

  00102	8b 45 f4	 mov	 eax, DWORD PTR _frontfloor$[ebp]
  00105	3b 45 ec	 cmp	 eax, DWORD PTR _backfloor$[ebp]
  00108	7e 12		 jle	 SHORT $LN15@P_CameraLi

; 318  : 		{
; 319  : 			openbottom = frontfloor;

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _frontfloor$[ebp]
  0010d	a3 00 00 00 00	 mov	 DWORD PTR _openbottom, eax

; 320  : 			lowfloor = backfloor;

  00112	8b 45 ec	 mov	 eax, DWORD PTR _backfloor$[ebp]
  00115	a3 00 00 00 00	 mov	 DWORD PTR _lowfloor, eax

; 321  : 		}

  0011a	eb 10		 jmp	 SHORT $LN16@P_CameraLi
$LN15@P_CameraLi:

; 322  : 		else
; 323  : 		{
; 324  : 			openbottom = backfloor;

  0011c	8b 45 ec	 mov	 eax, DWORD PTR _backfloor$[ebp]
  0011f	a3 00 00 00 00	 mov	 DWORD PTR _openbottom, eax

; 325  : 			lowfloor = frontfloor;

  00124	8b 45 f4	 mov	 eax, DWORD PTR _frontfloor$[ebp]
  00127	a3 00 00 00 00	 mov	 DWORD PTR _lowfloor, eax
$LN16@P_CameraLi:

; 326  : 		}
; 327  : 
; 328  : 		// Check for fake floors in the sector.
; 329  : 		if (front->ffloors || back->ffloors)

  0012c	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  0012f	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00136	75 10		 jne	 SHORT $LN18@P_CameraLi
  00138	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  0013b	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00142	0f 84 8f 02 00
	00		 je	 $LN35@P_CameraLi
$LN18@P_CameraLi:

; 330  : 		{
; 331  : 			ffloor_t *rover;
; 332  : 			fixed_t lowestceiling = opentop;

  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  0014d	89 45 d8	 mov	 DWORD PTR _lowestceiling$5[ebp], eax

; 333  : 			fixed_t highestfloor = openbottom;

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  00155	89 45 d4	 mov	 DWORD PTR _highestfloor$4[ebp], eax

; 334  : 			fixed_t lowestfloor = lowfloor;

  00158	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowfloor
  0015d	89 45 d0	 mov	 DWORD PTR _lowestfloor$3[ebp], eax

; 335  : 			fixed_t delta1, delta2;
; 336  : 
; 337  : 			thingtop = camera.z + camera.height;

  00160	a1 18 00 00 00	 mov	 eax, DWORD PTR _camera+24
  00165	03 05 30 00 00
	00		 add	 eax, DWORD PTR _camera+48
  0016b	89 45 e0	 mov	 DWORD PTR _thingtop$7[ebp], eax

; 338  : 
; 339  : 			// Check for frontsector's fake floors
; 340  : 			if (front->ffloors)

  0016e	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00171	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00178	0f 84 08 01 00
	00		 je	 $LN3@P_CameraLi

; 341  : 				for (rover = front->ffloors; rover; rover = rover->next)

  0017e	8b 45 fc	 mov	 eax, DWORD PTR _front$[ebp]
  00181	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00187	89 4d dc	 mov	 DWORD PTR _rover$6[ebp], ecx
  0018a	eb 09		 jmp	 SHORT $LN4@P_CameraLi
$LN2@P_CameraLi:
  0018c	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0018f	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00192	89 4d dc	 mov	 DWORD PTR _rover$6[ebp], ecx
$LN4@P_CameraLi:
  00195	83 7d dc 00	 cmp	 DWORD PTR _rover$6[ebp], 0
  00199	0f 84 e7 00 00
	00		 je	 $LN3@P_CameraLi

; 342  : 				{
; 343  : 					if (!(rover->flags & FF_BLOCKOTHERS) || !(rover->flags & FF_RENDERALL) || !(rover->flags & FF_EXISTS))

  0019f	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001a2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001a5	83 e1 04	 and	 ecx, 4
  001a8	74 16		 je	 SHORT $LN21@P_CameraLi
  001aa	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001ad	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001b0	83 e1 18	 and	 ecx, 24			; 00000018H
  001b3	74 0b		 je	 SHORT $LN21@P_CameraLi
  001b5	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001b8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001bb	83 e1 01	 and	 ecx, 1
  001be	75 02		 jne	 SHORT $LN20@P_CameraLi
$LN21@P_CameraLi:

; 344  : 						continue;

  001c0	eb ca		 jmp	 SHORT $LN2@P_CameraLi
$LN20@P_CameraLi:

; 345  : 
; 346  : 					delta1 = abs(camera.z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  001c2	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001c5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001c8	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  001cb	8b 02		 mov	 eax, DWORD PTR [edx]
  001cd	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  001d0	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001d3	8b 00		 mov	 eax, DWORD PTR [eax]
  001d5	2b 02		 sub	 eax, DWORD PTR [edx]
  001d7	99		 cdq
  001d8	2b c2		 sub	 eax, edx
  001da	d1 f8		 sar	 eax, 1
  001dc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001de	03 c8		 add	 ecx, eax
  001e0	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR _camera+24
  001e6	2b d1		 sub	 edx, ecx
  001e8	52		 push	 edx
  001e9	e8 00 00 00 00	 call	 _abs
  001ee	83 c4 04	 add	 esp, 4
  001f1	89 45 cc	 mov	 DWORD PTR _delta1$2[ebp], eax

; 347  : 					delta2 = abs(thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  001f4	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001f7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001fa	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  001fd	8b 02		 mov	 eax, DWORD PTR [edx]
  001ff	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  00202	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00205	8b 00		 mov	 eax, DWORD PTR [eax]
  00207	2b 02		 sub	 eax, DWORD PTR [edx]
  00209	99		 cdq
  0020a	2b c2		 sub	 eax, edx
  0020c	d1 f8		 sar	 eax, 1
  0020e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00210	03 c8		 add	 ecx, eax
  00212	8b 55 e0	 mov	 edx, DWORD PTR _thingtop$7[ebp]
  00215	2b d1		 sub	 edx, ecx
  00217	52		 push	 edx
  00218	e8 00 00 00 00	 call	 _abs
  0021d	83 c4 04	 add	 esp, 4
  00220	89 45 c8	 mov	 DWORD PTR _delta2$1[ebp], eax

; 348  : 					if (*rover->bottomheight < lowestceiling && delta1 >= delta2)

  00223	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00226	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00229	8b 11		 mov	 edx, DWORD PTR [ecx]
  0022b	3b 55 d8	 cmp	 edx, DWORD PTR _lowestceiling$5[ebp]
  0022e	7d 13		 jge	 SHORT $LN22@P_CameraLi
  00230	8b 45 cc	 mov	 eax, DWORD PTR _delta1$2[ebp]
  00233	3b 45 c8	 cmp	 eax, DWORD PTR _delta2$1[ebp]
  00236	7c 0b		 jl	 SHORT $LN22@P_CameraLi

; 349  : 						lowestceiling = *rover->bottomheight;

  00238	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0023b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0023e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00240	89 55 d8	 mov	 DWORD PTR _lowestceiling$5[ebp], edx
$LN22@P_CameraLi:

; 350  : 
; 351  : 					if (*rover->topheight > highestfloor && delta1 < delta2)

  00243	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00246	8b 08		 mov	 ecx, DWORD PTR [eax]
  00248	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024a	3b 55 d4	 cmp	 edx, DWORD PTR _highestfloor$4[ebp]
  0024d	7e 14		 jle	 SHORT $LN23@P_CameraLi
  0024f	8b 45 cc	 mov	 eax, DWORD PTR _delta1$2[ebp]
  00252	3b 45 c8	 cmp	 eax, DWORD PTR _delta2$1[ebp]
  00255	7d 0c		 jge	 SHORT $LN23@P_CameraLi

; 352  : 						highestfloor = *rover->topheight;

  00257	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0025a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025e	89 55 d4	 mov	 DWORD PTR _highestfloor$4[ebp], edx
  00261	eb 1e		 jmp	 SHORT $LN25@P_CameraLi
$LN23@P_CameraLi:

; 353  : 					else if (*rover->topheight > lowestfloor && delta1 < delta2)

  00263	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00266	8b 08		 mov	 ecx, DWORD PTR [eax]
  00268	8b 11		 mov	 edx, DWORD PTR [ecx]
  0026a	3b 55 d0	 cmp	 edx, DWORD PTR _lowestfloor$3[ebp]
  0026d	7e 12		 jle	 SHORT $LN25@P_CameraLi
  0026f	8b 45 cc	 mov	 eax, DWORD PTR _delta1$2[ebp]
  00272	3b 45 c8	 cmp	 eax, DWORD PTR _delta2$1[ebp]
  00275	7d 0a		 jge	 SHORT $LN25@P_CameraLi

; 354  : 						lowestfloor = *rover->topheight;

  00277	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0027a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0027e	89 55 d0	 mov	 DWORD PTR _lowestfloor$3[ebp], edx
$LN25@P_CameraLi:

; 355  : 				}

  00281	e9 06 ff ff ff	 jmp	 $LN2@P_CameraLi
$LN3@P_CameraLi:

; 356  : 
; 357  : 			// Check for backsectors fake floors
; 358  : 			if (back->ffloors)

  00286	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  00289	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00290	0f 84 08 01 00
	00		 je	 $LN6@P_CameraLi

; 359  : 				for (rover = back->ffloors; rover; rover = rover->next)

  00296	8b 45 f8	 mov	 eax, DWORD PTR _back$[ebp]
  00299	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0029f	89 4d dc	 mov	 DWORD PTR _rover$6[ebp], ecx
  002a2	eb 09		 jmp	 SHORT $LN7@P_CameraLi
$LN5@P_CameraLi:
  002a4	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  002a7	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  002aa	89 4d dc	 mov	 DWORD PTR _rover$6[ebp], ecx
$LN7@P_CameraLi:
  002ad	83 7d dc 00	 cmp	 DWORD PTR _rover$6[ebp], 0
  002b1	0f 84 e7 00 00
	00		 je	 $LN6@P_CameraLi

; 360  : 				{
; 361  : 					if (!(rover->flags & FF_BLOCKOTHERS) || !(rover->flags & FF_RENDERALL) || !(rover->flags & FF_EXISTS))

  002b7	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  002ba	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002bd	83 e1 04	 and	 ecx, 4
  002c0	74 16		 je	 SHORT $LN28@P_CameraLi
  002c2	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  002c5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002c8	83 e1 18	 and	 ecx, 24			; 00000018H
  002cb	74 0b		 je	 SHORT $LN28@P_CameraLi
  002cd	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  002d0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002d3	83 e1 01	 and	 ecx, 1
  002d6	75 02		 jne	 SHORT $LN27@P_CameraLi
$LN28@P_CameraLi:

; 362  : 						continue;

  002d8	eb ca		 jmp	 SHORT $LN5@P_CameraLi
$LN27@P_CameraLi:

; 363  : 
; 364  : 					delta1 = abs(camera.z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  002da	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  002dd	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002e0	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  002e3	8b 02		 mov	 eax, DWORD PTR [edx]
  002e5	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  002e8	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  002eb	8b 00		 mov	 eax, DWORD PTR [eax]
  002ed	2b 02		 sub	 eax, DWORD PTR [edx]
  002ef	99		 cdq
  002f0	2b c2		 sub	 eax, edx
  002f2	d1 f8		 sar	 eax, 1
  002f4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002f6	03 c8		 add	 ecx, eax
  002f8	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR _camera+24
  002fe	2b d1		 sub	 edx, ecx
  00300	52		 push	 edx
  00301	e8 00 00 00 00	 call	 _abs
  00306	83 c4 04	 add	 esp, 4
  00309	89 45 cc	 mov	 DWORD PTR _delta1$2[ebp], eax

; 365  : 					delta2 = abs(thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2)));

  0030c	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0030f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00312	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  00315	8b 02		 mov	 eax, DWORD PTR [edx]
  00317	8b 55 dc	 mov	 edx, DWORD PTR _rover$6[ebp]
  0031a	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0031d	8b 00		 mov	 eax, DWORD PTR [eax]
  0031f	2b 02		 sub	 eax, DWORD PTR [edx]
  00321	99		 cdq
  00322	2b c2		 sub	 eax, edx
  00324	d1 f8		 sar	 eax, 1
  00326	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00328	03 c8		 add	 ecx, eax
  0032a	8b 55 e0	 mov	 edx, DWORD PTR _thingtop$7[ebp]
  0032d	2b d1		 sub	 edx, ecx
  0032f	52		 push	 edx
  00330	e8 00 00 00 00	 call	 _abs
  00335	83 c4 04	 add	 esp, 4
  00338	89 45 c8	 mov	 DWORD PTR _delta2$1[ebp], eax

; 366  : 					if (*rover->bottomheight < lowestceiling && delta1 >= delta2)

  0033b	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0033e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00341	8b 11		 mov	 edx, DWORD PTR [ecx]
  00343	3b 55 d8	 cmp	 edx, DWORD PTR _lowestceiling$5[ebp]
  00346	7d 13		 jge	 SHORT $LN29@P_CameraLi
  00348	8b 45 cc	 mov	 eax, DWORD PTR _delta1$2[ebp]
  0034b	3b 45 c8	 cmp	 eax, DWORD PTR _delta2$1[ebp]
  0034e	7c 0b		 jl	 SHORT $LN29@P_CameraLi

; 367  : 						lowestceiling = *rover->bottomheight;

  00350	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00353	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00356	8b 11		 mov	 edx, DWORD PTR [ecx]
  00358	89 55 d8	 mov	 DWORD PTR _lowestceiling$5[ebp], edx
$LN29@P_CameraLi:

; 368  : 
; 369  : 					if (*rover->topheight > highestfloor && delta1 < delta2)

  0035b	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0035e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00360	8b 11		 mov	 edx, DWORD PTR [ecx]
  00362	3b 55 d4	 cmp	 edx, DWORD PTR _highestfloor$4[ebp]
  00365	7e 14		 jle	 SHORT $LN30@P_CameraLi
  00367	8b 45 cc	 mov	 eax, DWORD PTR _delta1$2[ebp]
  0036a	3b 45 c8	 cmp	 eax, DWORD PTR _delta2$1[ebp]
  0036d	7d 0c		 jge	 SHORT $LN30@P_CameraLi

; 370  : 						highestfloor = *rover->topheight;

  0036f	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00372	8b 08		 mov	 ecx, DWORD PTR [eax]
  00374	8b 11		 mov	 edx, DWORD PTR [ecx]
  00376	89 55 d4	 mov	 DWORD PTR _highestfloor$4[ebp], edx
  00379	eb 1e		 jmp	 SHORT $LN32@P_CameraLi
$LN30@P_CameraLi:

; 371  : 					else if (*rover->topheight > lowestfloor && delta1 < delta2)

  0037b	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0037e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00380	8b 11		 mov	 edx, DWORD PTR [ecx]
  00382	3b 55 d0	 cmp	 edx, DWORD PTR _lowestfloor$3[ebp]
  00385	7e 12		 jle	 SHORT $LN32@P_CameraLi
  00387	8b 45 cc	 mov	 eax, DWORD PTR _delta1$2[ebp]
  0038a	3b 45 c8	 cmp	 eax, DWORD PTR _delta2$1[ebp]
  0038d	7d 0a		 jge	 SHORT $LN32@P_CameraLi

; 372  : 						lowestfloor = *rover->topheight;

  0038f	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00392	8b 08		 mov	 ecx, DWORD PTR [eax]
  00394	8b 11		 mov	 edx, DWORD PTR [ecx]
  00396	89 55 d0	 mov	 DWORD PTR _lowestfloor$3[ebp], edx
$LN32@P_CameraLi:

; 373  : 				}

  00399	e9 06 ff ff ff	 jmp	 $LN5@P_CameraLi
$LN6@P_CameraLi:

; 374  : 
; 375  : 			if (highestfloor > openbottom)

  0039e	8b 45 d4	 mov	 eax, DWORD PTR _highestfloor$4[ebp]
  003a1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _openbottom
  003a7	7e 08		 jle	 SHORT $LN33@P_CameraLi

; 376  : 				openbottom = highestfloor;

  003a9	8b 45 d4	 mov	 eax, DWORD PTR _highestfloor$4[ebp]
  003ac	a3 00 00 00 00	 mov	 DWORD PTR _openbottom, eax
$LN33@P_CameraLi:

; 377  : 
; 378  : 			if (lowestceiling < opentop)

  003b1	8b 45 d8	 mov	 eax, DWORD PTR _lowestceiling$5[ebp]
  003b4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _opentop
  003ba	7d 08		 jge	 SHORT $LN34@P_CameraLi

; 379  : 				opentop = lowestceiling;

  003bc	8b 45 d8	 mov	 eax, DWORD PTR _lowestceiling$5[ebp]
  003bf	a3 00 00 00 00	 mov	 DWORD PTR _opentop, eax
$LN34@P_CameraLi:

; 380  : 
; 381  : 			if (lowestfloor > lowfloor)

  003c4	8b 45 d0	 mov	 eax, DWORD PTR _lowestfloor$3[ebp]
  003c7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _lowfloor
  003cd	7e 08		 jle	 SHORT $LN35@P_CameraLi

; 382  : 				lowfloor = lowestfloor;

  003cf	8b 45 d0	 mov	 eax, DWORD PTR _lowestfloor$3[ebp]
  003d2	a3 00 00 00 00	 mov	 DWORD PTR _lowfloor, eax
$LN35@P_CameraLi:

; 383  : 		}
; 384  : 		openrange = opentop - openbottom;

  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  003dc	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _openbottom
  003e2	a3 00 00 00 00	 mov	 DWORD PTR _openrange, eax
$LN1@P_CameraLi:

; 385  : 		return;
; 386  : 	}
; 387  : }

  003e7	5f		 pop	 edi
  003e8	5e		 pop	 esi
  003e9	5b		 pop	 ebx
  003ea	8b e5		 mov	 esp, ebp
  003ec	5d		 pop	 ebp
  003ed	c3		 ret	 0
_P_CameraLineOpening ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_MakeDivline
_TEXT	SEGMENT
_li$ = 8						; size = 4
_dl$ = 12						; size = 4
_P_MakeDivline PROC					; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 231  : 	dl->x = li->v1->x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _li$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _dl$[ebp]
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	89 02		 mov	 DWORD PTR [edx], eax

; 232  : 	dl->y = li->v1->y;

  00015	8b 45 08	 mov	 eax, DWORD PTR _li$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _dl$[ebp]
  0001d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00020	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 233  : 	dl->dx = li->dx;

  00023	8b 45 0c	 mov	 eax, DWORD PTR _dl$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _li$[ebp]
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 234  : 	dl->dy = li->dy;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _dl$[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _li$[ebp]
  00035	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00038	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 235  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_P_MakeDivline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_PointOnLineSide
_TEXT	SEGMENT
tv71 = -88						; size = 4
tv74 = -88						; size = 4
tv81 = -88						; size = 4
tv84 = -88						; size = 4
_right$ = -20						; size = 4
_left$ = -16						; size = 4
_dy$ = -12						; size = 4
_dx$ = -8						; size = 4
_v1$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_line$ = 16						; size = 4
_P_PointOnLineSide PROC					; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 104  : 	const vertex_t *v1 = line->v1;

  00009	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _v1$[ebp], ecx

; 105  : 	fixed_t dx, dy, left, right;
; 106  : 
; 107  : 	if (!line->dx)

  00011	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00014	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00018	75 4c		 jne	 SHORT $LN2@P_PointOnL

; 108  : 	{
; 109  : 		if (x <= v1->x)

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00020	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00022	7f 21		 jg	 SHORT $LN3@P_PointOnL

; 110  : 			return (line->dy > 0);

  00024	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00027	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0002b	7e 09		 jle	 SHORT $LN8@P_PointOnL
  0002d	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00034	eb 07		 jmp	 SHORT $LN9@P_PointOnL
$LN8@P_PointOnL:
  00036	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN9@P_PointOnL:
  0003d	8b 45 a8	 mov	 eax, DWORD PTR tv71[ebp]
  00040	e9 cb 00 00 00	 jmp	 $LN1@P_PointOnL
$LN3@P_PointOnL:

; 111  : 
; 112  : 		return (line->dy < 0);

  00045	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00048	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0004c	7d 09		 jge	 SHORT $LN10@P_PointOnL
  0004e	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00055	eb 07		 jmp	 SHORT $LN11@P_PointOnL
$LN10@P_PointOnL:
  00057	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN11@P_PointOnL:
  0005e	8b 45 a8	 mov	 eax, DWORD PTR tv74[ebp]
  00061	e9 aa 00 00 00	 jmp	 $LN1@P_PointOnL
$LN2@P_PointOnL:

; 113  : 	}
; 114  : 	if (!line->dy)

  00066	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00069	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0006d	75 47		 jne	 SHORT $LN4@P_PointOnL

; 115  : 	{
; 116  : 		if (y <= v1->y)

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00075	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00078	7f 1e		 jg	 SHORT $LN5@P_PointOnL

; 117  : 			return (line->dx < 0);

  0007a	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0007d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00081	7d 09		 jge	 SHORT $LN12@P_PointOnL
  00083	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  0008a	eb 07		 jmp	 SHORT $LN13@P_PointOnL
$LN12@P_PointOnL:
  0008c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN13@P_PointOnL:
  00093	8b 45 a8	 mov	 eax, DWORD PTR tv81[ebp]
  00096	eb 78		 jmp	 SHORT $LN1@P_PointOnL
$LN5@P_PointOnL:

; 118  : 
; 119  : 		return (line->dx > 0);

  00098	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0009b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0009f	7e 09		 jle	 SHORT $LN14@P_PointOnL
  000a1	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  000a8	eb 07		 jmp	 SHORT $LN15@P_PointOnL
$LN14@P_PointOnL:
  000aa	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN15@P_PointOnL:
  000b1	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  000b4	eb 5a		 jmp	 SHORT $LN1@P_PointOnL
$LN4@P_PointOnL:

; 120  : 	}
; 121  : 
; 122  : 	dx = (x - v1->x);

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000bc	2b 08		 sub	 ecx, DWORD PTR [eax]
  000be	89 4d f8	 mov	 DWORD PTR _dx$[ebp], ecx

; 123  : 	dy = (y - v1->y);

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000c7	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000ca	89 4d f4	 mov	 DWORD PTR _dy$[ebp], ecx

; 124  : 
; 125  : 	left = FixedMul(line->dy>>FRACBITS, dx);

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _dx$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 10	 mov	 ecx, DWORD PTR _line$[ebp]
  000d4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000d7	c1 fa 10	 sar	 edx, 16			; 00000010H
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 _FixedMul
  000e0	83 c4 08	 add	 esp, 8
  000e3	89 45 f0	 mov	 DWORD PTR _left$[ebp], eax

; 126  : 	right = FixedMul(dy, line->dx>>FRACBITS);

  000e6	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  000e9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ec	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000ef	51		 push	 ecx
  000f0	8b 55 f4	 mov	 edx, DWORD PTR _dy$[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 _FixedMul
  000f9	83 c4 08	 add	 esp, 8
  000fc	89 45 ec	 mov	 DWORD PTR _right$[ebp], eax

; 127  : 
; 128  : 	if (right < left)

  000ff	8b 45 ec	 mov	 eax, DWORD PTR _right$[ebp]
  00102	3b 45 f0	 cmp	 eax, DWORD PTR _left$[ebp]
  00105	7d 04		 jge	 SHORT $LN6@P_PointOnL

; 129  : 		return 0; // front side

  00107	33 c0		 xor	 eax, eax
  00109	eb 05		 jmp	 SHORT $LN1@P_PointOnL
$LN6@P_PointOnL:

; 130  : 	return 1; // back side

  0010b	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_PointOnL:

; 131  : }

  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_P_PointOnLineSide ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_ClosestPointOnLine
_TEXT	SEGMENT
_t$ = -40						; size = 4
_magnitude$ = -36					; size = 4
_vy$ = -32						; size = 4
_vx$ = -28						; size = 4
_cy$ = -24						; size = 4
_cx$ = -20						; size = 4
_dy$ = -16						; size = 4
_dx$ = -12						; size = 4
_starty$ = -8						; size = 4
_startx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_line$ = 16						; size = 4
_result$ = 20						; size = 4
_P_ClosestPointOnLine PROC				; COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 62   : 	fixed_t startx = line->v1->x;

  00009	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 55 fc	 mov	 DWORD PTR _startx$[ebp], edx

; 63   : 	fixed_t starty = line->v1->y;

  00013	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 f8	 mov	 DWORD PTR _starty$[ebp], edx

; 64   : 	fixed_t dx = line->dx;

  0001e	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  00021	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00024	89 4d f4	 mov	 DWORD PTR _dx$[ebp], ecx

; 65   : 	fixed_t dy = line->dy;

  00027	8b 45 10	 mov	 eax, DWORD PTR _line$[ebp]
  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	89 4d f0	 mov	 DWORD PTR _dy$[ebp], ecx

; 66   : 
; 67   : 	// Determine t (the length of the vector from �Line[0]� to �p�)
; 68   : 	fixed_t cx, cy;
; 69   : 	fixed_t vx, vy;
; 70   : 	fixed_t magnitude;
; 71   : 	fixed_t t;
; 72   : 
; 73   : 	//Sub (p, &Line[0], &c);
; 74   : 	cx = x - startx;

  00030	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00033	2b 45 fc	 sub	 eax, DWORD PTR _startx$[ebp]
  00036	89 45 ec	 mov	 DWORD PTR _cx$[ebp], eax

; 75   : 	cy = y - starty;

  00039	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0003c	2b 45 f8	 sub	 eax, DWORD PTR _starty$[ebp]
  0003f	89 45 e8	 mov	 DWORD PTR _cy$[ebp], eax

; 76   : 
; 77   : 	//Sub (&Line[1], &Line[0], &V);
; 78   : 	vx = dx;

  00042	8b 45 f4	 mov	 eax, DWORD PTR _dx$[ebp]
  00045	89 45 e4	 mov	 DWORD PTR _vx$[ebp], eax

; 79   : 	vy = dy;

  00048	8b 45 f0	 mov	 eax, DWORD PTR _dy$[ebp]
  0004b	89 45 e0	 mov	 DWORD PTR _vy$[ebp], eax

; 80   : 
; 81   : 	//Normalize (&V, &V);
; 82   : 	magnitude = R_PointToDist2(line->v2->x, line->v2->y, startx, starty);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _starty$[ebp]
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _startx$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 10	 mov	 edx, DWORD PTR _line$[ebp]
  00059	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 55 10	 mov	 edx, DWORD PTR _line$[ebp]
  00063	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _R_PointToDist2
  0006e	83 c4 10	 add	 esp, 16			; 00000010H
  00071	89 45 dc	 mov	 DWORD PTR _magnitude$[ebp], eax

; 83   : 	vx = FixedDiv(vx, magnitude);

  00074	8b 45 dc	 mov	 eax, DWORD PTR _magnitude$[ebp]
  00077	50		 push	 eax
  00078	8b 4d e4	 mov	 ecx, DWORD PTR _vx$[ebp]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 _FixedDiv
  00081	83 c4 08	 add	 esp, 8
  00084	89 45 e4	 mov	 DWORD PTR _vx$[ebp], eax

; 84   : 	vy = FixedDiv(vy, magnitude);

  00087	8b 45 dc	 mov	 eax, DWORD PTR _magnitude$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d e0	 mov	 ecx, DWORD PTR _vy$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _FixedDiv
  00094	83 c4 08	 add	 esp, 8
  00097	89 45 e0	 mov	 DWORD PTR _vy$[ebp], eax

; 85   : 
; 86   : 	t = (FixedMul(vx, cx) + FixedMul(vy, cy));

  0009a	8b 45 ec	 mov	 eax, DWORD PTR _cx$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d e4	 mov	 ecx, DWORD PTR _vx$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 _FixedMul
  000a7	83 c4 08	 add	 esp, 8
  000aa	8b f0		 mov	 esi, eax
  000ac	8b 55 e8	 mov	 edx, DWORD PTR _cy$[ebp]
  000af	52		 push	 edx
  000b0	8b 45 e0	 mov	 eax, DWORD PTR _vy$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _FixedMul
  000b9	83 c4 08	 add	 esp, 8
  000bc	03 f0		 add	 esi, eax
  000be	89 75 d8	 mov	 DWORD PTR _t$[ebp], esi

; 87   : 
; 88   : 	// Return the point between �Line[0]� and �Line[1]�
; 89   : 	vx = FixedMul(vx, t);

  000c1	8b 45 d8	 mov	 eax, DWORD PTR _t$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d e4	 mov	 ecx, DWORD PTR _vx$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _FixedMul
  000ce	83 c4 08	 add	 esp, 8
  000d1	89 45 e4	 mov	 DWORD PTR _vx$[ebp], eax

; 90   : 	vy = FixedMul(vy, t);

  000d4	8b 45 d8	 mov	 eax, DWORD PTR _t$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR _vy$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _FixedMul
  000e1	83 c4 08	 add	 esp, 8
  000e4	89 45 e0	 mov	 DWORD PTR _vy$[ebp], eax

; 91   : 
; 92   : 	//Add (&Line[0], &V, out);
; 93   : 	result->x = startx + vx;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _startx$[ebp]
  000ea	03 45 e4	 add	 eax, DWORD PTR _vx$[ebp]
  000ed	8b 4d 14	 mov	 ecx, DWORD PTR _result$[ebp]
  000f0	89 01		 mov	 DWORD PTR [ecx], eax

; 94   : 	result->y = starty + vy;

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _starty$[ebp]
  000f5	03 45 e0	 add	 eax, DWORD PTR _vy$[ebp]
  000f8	8b 4d 14	 mov	 ecx, DWORD PTR _result$[ebp]
  000fb	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 95   : 	return;
; 96   : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_P_ClosestPointOnLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_AproxDistance
_TEXT	SEGMENT
_dx$ = 8						; size = 4
_dy$ = 12						; size = 4
_P_AproxDistance PROC					; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 34   : 	dx = abs(dx);

  00009	8b 45 08	 mov	 eax, DWORD PTR _dx$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 08	 mov	 DWORD PTR _dx$[ebp], eax

; 35   : 	dy = abs(dy);

  00018	8b 45 0c	 mov	 eax, DWORD PTR _dy$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _abs
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 0c	 mov	 DWORD PTR _dy$[ebp], eax

; 36   : 	if (dx < dy)

  00027	8b 45 08	 mov	 eax, DWORD PTR _dx$[ebp]
  0002a	3b 45 0c	 cmp	 eax, DWORD PTR _dy$[ebp]
  0002d	7d 0f		 jge	 SHORT $LN2@P_AproxDis

; 37   : 		return dx + dy - (dx>>1);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _dx$[ebp]
  00032	03 45 0c	 add	 eax, DWORD PTR _dy$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _dx$[ebp]
  00038	d1 f9		 sar	 ecx, 1
  0003a	2b c1		 sub	 eax, ecx
  0003c	eb 0d		 jmp	 SHORT $LN1@P_AproxDis
$LN2@P_AproxDis:

; 38   : 	return dx + dy - (dy>>1);

  0003e	8b 45 08	 mov	 eax, DWORD PTR _dx$[ebp]
  00041	03 45 0c	 add	 eax, DWORD PTR _dy$[ebp]
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _dy$[ebp]
  00047	d1 f9		 sar	 ecx, 1
  00049	2b c1		 sub	 eax, ecx
$LN1@P_AproxDis:

; 39   : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_P_AproxDistance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_maputl.c
;	COMDAT _P_PathTraverse
_TEXT	SEGMENT
_count$ = -56						; size = 4
_mapystep$ = -52					; size = 4
_mapxstep$ = -48					; size = 4
_mapy$ = -44						; size = 4
_mapx$ = -40						; size = 4
_yintercept$ = -36					; size = 4
_xintercept$ = -32					; size = 4
_partial$ = -28						; size = 4
_ystep$ = -24						; size = 4
_xstep$ = -20						; size = 4
_yt2$ = -16						; size = 4
_xt2$ = -12						; size = 4
_yt1$ = -8						; size = 4
_xt1$ = -4						; size = 4
_px1$ = 8						; size = 4
_py1$ = 12						; size = 4
_px2$ = 16						; size = 4
_py2$ = 20						; size = 4
_flags$ = 24						; size = 4
_trav$ = 28						; size = 4
_P_PathTraverse PROC					; COMDAT

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1033 : 	fixed_t xt1, yt1, xt2, yt2;
; 1034 : 	fixed_t xstep, ystep, partial, xintercept, yintercept;
; 1035 : 	INT32 mapx, mapy, mapxstep, mapystep, count;
; 1036 : 
; 1037 : 	earlyout = flags & PT_EARLYOUT;

  00009	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0000c	83 e0 04	 and	 eax, 4
  0000f	a3 00 00 00 00	 mov	 DWORD PTR _earlyout, eax

; 1038 : 
; 1039 : 	validcount++;

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  00019	83 c0 01	 add	 eax, 1
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 1040 : 	intercept_p = intercepts;

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _intercepts
  00026	a3 00 00 00 00	 mov	 DWORD PTR _intercept_p, eax

; 1041 : 
; 1042 : 	if (((px1 - bmaporgx) & (MAPBLOCKSIZE-1)) == 0)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  0002e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgx
  00034	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00039	75 0b		 jne	 SHORT $LN5@P_PathTrav

; 1043 : 		px1 += FRACUNIT; // Don't side exactly on a line.

  0003b	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  0003e	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00043	89 45 08	 mov	 DWORD PTR _px1$[ebp], eax
$LN5@P_PathTrav:

; 1044 : 
; 1045 : 	if (((py1 - bmaporgy) & (MAPBLOCKSIZE-1)) == 0)

  00046	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  00049	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgy
  0004f	25 ff ff 7f 00	 and	 eax, 8388607		; 007fffffH
  00054	75 0b		 jne	 SHORT $LN6@P_PathTrav

; 1046 : 		py1 += FRACUNIT; // Don't side exactly on a line.

  00056	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  00059	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  0005e	89 45 0c	 mov	 DWORD PTR _py1$[ebp], eax
$LN6@P_PathTrav:

; 1047 : 
; 1048 : 	trace.x = px1;

  00061	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  00064	a3 00 00 00 00	 mov	 DWORD PTR _trace, eax

; 1049 : 	trace.y = py1;

  00069	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  0006c	a3 04 00 00 00	 mov	 DWORD PTR _trace+4, eax

; 1050 : 	trace.dx = px2 - px1;

  00071	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  00074	2b 45 08	 sub	 eax, DWORD PTR _px1$[ebp]
  00077	a3 08 00 00 00	 mov	 DWORD PTR _trace+8, eax

; 1051 : 	trace.dy = py2 - py1;

  0007c	8b 45 14	 mov	 eax, DWORD PTR _py2$[ebp]
  0007f	2b 45 0c	 sub	 eax, DWORD PTR _py1$[ebp]
  00082	a3 0c 00 00 00	 mov	 DWORD PTR _trace+12, eax

; 1052 : 
; 1053 : 	px1 -= bmaporgx;

  00087	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  0008a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgx
  00090	89 45 08	 mov	 DWORD PTR _px1$[ebp], eax

; 1054 : 	py1 -= bmaporgy;

  00093	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  00096	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgy
  0009c	89 45 0c	 mov	 DWORD PTR _py1$[ebp], eax

; 1055 : 	xt1 = (unsigned)px1>>MAPBLOCKSHIFT;

  0009f	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  000a2	c1 e8 17	 shr	 eax, 23			; 00000017H
  000a5	89 45 fc	 mov	 DWORD PTR _xt1$[ebp], eax

; 1056 : 	yt1 = (unsigned)py1>>MAPBLOCKSHIFT;

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  000ab	c1 e8 17	 shr	 eax, 23			; 00000017H
  000ae	89 45 f8	 mov	 DWORD PTR _yt1$[ebp], eax

; 1057 : 
; 1058 : 	px2 -= bmaporgx;

  000b1	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  000b4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgx
  000ba	89 45 10	 mov	 DWORD PTR _px2$[ebp], eax

; 1059 : 	py2 -= bmaporgy;

  000bd	8b 45 14	 mov	 eax, DWORD PTR _py2$[ebp]
  000c0	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgy
  000c6	89 45 14	 mov	 DWORD PTR _py2$[ebp], eax

; 1060 : 	xt2 = (unsigned)px2>>MAPBLOCKSHIFT;

  000c9	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  000cc	c1 e8 17	 shr	 eax, 23			; 00000017H
  000cf	89 45 f4	 mov	 DWORD PTR _xt2$[ebp], eax

; 1061 : 	yt2 = (unsigned)py2>>MAPBLOCKSHIFT;

  000d2	8b 45 14	 mov	 eax, DWORD PTR _py2$[ebp]
  000d5	c1 e8 17	 shr	 eax, 23			; 00000017H
  000d8	89 45 f0	 mov	 DWORD PTR _yt2$[ebp], eax

; 1062 : 
; 1063 : 	if (xt2 > xt1)

  000db	8b 45 f4	 mov	 eax, DWORD PTR _xt2$[ebp]
  000de	3b 45 fc	 cmp	 eax, DWORD PTR _xt1$[ebp]
  000e1	7e 40		 jle	 SHORT $LN7@P_PathTrav

; 1064 : 	{
; 1065 : 		mapxstep = 1;

  000e3	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _mapxstep$[ebp], 1

; 1066 : 		partial = FRACUNIT - ((px1>>MAPBTOFRAC) & FRACMASK);

  000ea	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  000ed	c1 f8 07	 sar	 eax, 7
  000f0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000f5	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  000fa	2b c8		 sub	 ecx, eax
  000fc	89 4d e4	 mov	 DWORD PTR _partial$[ebp], ecx

; 1067 : 		ystep = FixedDiv(py2 - py1, abs(px2 - px1));

  000ff	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  00102	2b 45 08	 sub	 eax, DWORD PTR _px1$[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _abs
  0010b	83 c4 04	 add	 esp, 4
  0010e	50		 push	 eax
  0010f	8b 4d 14	 mov	 ecx, DWORD PTR _py2$[ebp]
  00112	2b 4d 0c	 sub	 ecx, DWORD PTR _py1$[ebp]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _FixedDiv
  0011b	83 c4 08	 add	 esp, 8
  0011e	89 45 e8	 mov	 DWORD PTR _ystep$[ebp], eax

; 1068 : 	}

  00121	eb 56		 jmp	 SHORT $LN10@P_PathTrav
$LN7@P_PathTrav:

; 1069 : 	else if (xt2 < xt1)

  00123	8b 45 f4	 mov	 eax, DWORD PTR _xt2$[ebp]
  00126	3b 45 fc	 cmp	 eax, DWORD PTR _xt1$[ebp]
  00129	7d 39		 jge	 SHORT $LN9@P_PathTrav

; 1070 : 	{
; 1071 : 		mapxstep = -1;

  0012b	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR _mapxstep$[ebp], -1

; 1072 : 		partial = (px1>>MAPBTOFRAC) & FRACMASK;

  00132	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  00135	c1 f8 07	 sar	 eax, 7
  00138	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0013d	89 45 e4	 mov	 DWORD PTR _partial$[ebp], eax

; 1073 : 		ystep = FixedDiv(py2 - py1, abs(px2 - px1));

  00140	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  00143	2b 45 08	 sub	 eax, DWORD PTR _px1$[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _abs
  0014c	83 c4 04	 add	 esp, 4
  0014f	50		 push	 eax
  00150	8b 4d 14	 mov	 ecx, DWORD PTR _py2$[ebp]
  00153	2b 4d 0c	 sub	 ecx, DWORD PTR _py1$[ebp]
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 _FixedDiv
  0015c	83 c4 08	 add	 esp, 8
  0015f	89 45 e8	 mov	 DWORD PTR _ystep$[ebp], eax

; 1074 : 	}

  00162	eb 15		 jmp	 SHORT $LN10@P_PathTrav
$LN9@P_PathTrav:

; 1075 : 	else
; 1076 : 	{
; 1077 : 		mapxstep = 0;

  00164	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _mapxstep$[ebp], 0

; 1078 : 		partial = FRACUNIT;

  0016b	c7 45 e4 00 00
	01 00		 mov	 DWORD PTR _partial$[ebp], 65536 ; 00010000H

; 1079 : 		ystep = 256*FRACUNIT;

  00172	c7 45 e8 00 00
	00 01		 mov	 DWORD PTR _ystep$[ebp], 16777216 ; 01000000H
$LN10@P_PathTrav:

; 1080 : 	}
; 1081 : 
; 1082 : 	yintercept = (py1>>MAPBTOFRAC) + FixedMul(partial, ystep);

  00179	8b 75 0c	 mov	 esi, DWORD PTR _py1$[ebp]
  0017c	c1 fe 07	 sar	 esi, 7
  0017f	8b 45 e8	 mov	 eax, DWORD PTR _ystep$[ebp]
  00182	50		 push	 eax
  00183	8b 4d e4	 mov	 ecx, DWORD PTR _partial$[ebp]
  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 _FixedMul
  0018c	83 c4 08	 add	 esp, 8
  0018f	03 f0		 add	 esi, eax
  00191	89 75 dc	 mov	 DWORD PTR _yintercept$[ebp], esi

; 1083 : 
; 1084 : 	if (yt2 > yt1)

  00194	8b 45 f0	 mov	 eax, DWORD PTR _yt2$[ebp]
  00197	3b 45 f8	 cmp	 eax, DWORD PTR _yt1$[ebp]
  0019a	7e 40		 jle	 SHORT $LN11@P_PathTrav

; 1085 : 	{
; 1086 : 		mapystep = 1;

  0019c	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _mapystep$[ebp], 1

; 1087 : 		partial = FRACUNIT - ((py1>>MAPBTOFRAC) & FRACMASK);

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  001a6	c1 f8 07	 sar	 eax, 7
  001a9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001ae	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  001b3	2b c8		 sub	 ecx, eax
  001b5	89 4d e4	 mov	 DWORD PTR _partial$[ebp], ecx

; 1088 : 		xstep = FixedDiv(px2 - px1, abs(py2 - py1));

  001b8	8b 45 14	 mov	 eax, DWORD PTR _py2$[ebp]
  001bb	2b 45 0c	 sub	 eax, DWORD PTR _py1$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 _abs
  001c4	83 c4 04	 add	 esp, 4
  001c7	50		 push	 eax
  001c8	8b 4d 10	 mov	 ecx, DWORD PTR _px2$[ebp]
  001cb	2b 4d 08	 sub	 ecx, DWORD PTR _px1$[ebp]
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 _FixedDiv
  001d4	83 c4 08	 add	 esp, 8
  001d7	89 45 ec	 mov	 DWORD PTR _xstep$[ebp], eax

; 1089 : 	}

  001da	eb 56		 jmp	 SHORT $LN14@P_PathTrav
$LN11@P_PathTrav:

; 1090 : 	else if (yt2 < yt1)

  001dc	8b 45 f0	 mov	 eax, DWORD PTR _yt2$[ebp]
  001df	3b 45 f8	 cmp	 eax, DWORD PTR _yt1$[ebp]
  001e2	7d 39		 jge	 SHORT $LN13@P_PathTrav

; 1091 : 	{
; 1092 : 		mapystep = -1;

  001e4	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _mapystep$[ebp], -1

; 1093 : 		partial = (py1>>MAPBTOFRAC) & FRACMASK;

  001eb	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  001ee	c1 f8 07	 sar	 eax, 7
  001f1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001f6	89 45 e4	 mov	 DWORD PTR _partial$[ebp], eax

; 1094 : 		xstep = FixedDiv(px2 - px1, abs(py2 - py1));

  001f9	8b 45 14	 mov	 eax, DWORD PTR _py2$[ebp]
  001fc	2b 45 0c	 sub	 eax, DWORD PTR _py1$[ebp]
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 _abs
  00205	83 c4 04	 add	 esp, 4
  00208	50		 push	 eax
  00209	8b 4d 10	 mov	 ecx, DWORD PTR _px2$[ebp]
  0020c	2b 4d 08	 sub	 ecx, DWORD PTR _px1$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _FixedDiv
  00215	83 c4 08	 add	 esp, 8
  00218	89 45 ec	 mov	 DWORD PTR _xstep$[ebp], eax

; 1095 : 	}

  0021b	eb 15		 jmp	 SHORT $LN14@P_PathTrav
$LN13@P_PathTrav:

; 1096 : 	else
; 1097 : 	{
; 1098 : 		mapystep = 0;

  0021d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _mapystep$[ebp], 0

; 1099 : 		partial = FRACUNIT;

  00224	c7 45 e4 00 00
	01 00		 mov	 DWORD PTR _partial$[ebp], 65536 ; 00010000H

; 1100 : 		xstep = 256*FRACUNIT;

  0022b	c7 45 ec 00 00
	00 01		 mov	 DWORD PTR _xstep$[ebp], 16777216 ; 01000000H
$LN14@P_PathTrav:

; 1101 : 	}
; 1102 : 	xintercept = (px1>>MAPBTOFRAC) + FixedMul(partial, xstep);

  00232	8b 75 08	 mov	 esi, DWORD PTR _px1$[ebp]
  00235	c1 fe 07	 sar	 esi, 7
  00238	8b 45 ec	 mov	 eax, DWORD PTR _xstep$[ebp]
  0023b	50		 push	 eax
  0023c	8b 4d e4	 mov	 ecx, DWORD PTR _partial$[ebp]
  0023f	51		 push	 ecx
  00240	e8 00 00 00 00	 call	 _FixedMul
  00245	83 c4 08	 add	 esp, 8
  00248	03 f0		 add	 esi, eax
  0024a	89 75 e0	 mov	 DWORD PTR _xintercept$[ebp], esi

; 1103 : 
; 1104 : 	// Step through map blocks.
; 1105 : 	// Count is present to prevent a round off error
; 1106 : 	// from skipping the break.
; 1107 : 	mapx = xt1;

  0024d	8b 45 fc	 mov	 eax, DWORD PTR _xt1$[ebp]
  00250	89 45 d8	 mov	 DWORD PTR _mapx$[ebp], eax

; 1108 : 	mapy = yt1;

  00253	8b 45 f8	 mov	 eax, DWORD PTR _yt1$[ebp]
  00256	89 45 d4	 mov	 DWORD PTR _mapy$[ebp], eax

; 1109 : 
; 1110 : 	for (count = 0; count < 64; count++)

  00259	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00260	eb 09		 jmp	 SHORT $LN4@P_PathTrav
$LN2@P_PathTrav:
  00262	8b 45 c8	 mov	 eax, DWORD PTR _count$[ebp]
  00265	83 c0 01	 add	 eax, 1
  00268	89 45 c8	 mov	 DWORD PTR _count$[ebp], eax
$LN4@P_PathTrav:
  0026b	83 7d c8 40	 cmp	 DWORD PTR _count$[ebp], 64 ; 00000040H
  0026f	0f 8d a0 00 00
	00		 jge	 $LN3@P_PathTrav

; 1111 : 	{
; 1112 : 		if (flags & PT_ADDLINES)

  00275	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00278	83 e0 01	 and	 eax, 1
  0027b	74 20		 je	 SHORT $LN16@P_PathTrav

; 1113 : 			if (!P_BlockLinesIterator(mapx, mapy, PIT_AddLineIntercepts))

  0027d	68 00 00 00 00	 push	 OFFSET _PIT_AddLineIntercepts
  00282	8b 45 d4	 mov	 eax, DWORD PTR _mapy$[ebp]
  00285	50		 push	 eax
  00286	8b 4d d8	 mov	 ecx, DWORD PTR _mapx$[ebp]
  00289	51		 push	 ecx
  0028a	e8 00 00 00 00	 call	 _P_BlockLinesIterator
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00292	85 c0		 test	 eax, eax
  00294	75 07		 jne	 SHORT $LN16@P_PathTrav

; 1114 : 				return false; // early out

  00296	33 c0		 xor	 eax, eax
  00298	e9 89 00 00 00	 jmp	 $LN1@P_PathTrav
$LN16@P_PathTrav:

; 1115 : 
; 1116 : 		if (flags & PT_ADDTHINGS)

  0029d	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  002a0	83 e0 02	 and	 eax, 2
  002a3	74 1d		 je	 SHORT $LN18@P_PathTrav

; 1117 : 			if (!P_BlockThingsIterator(mapx, mapy, PIT_AddThingIntercepts))

  002a5	68 00 00 00 00	 push	 OFFSET _PIT_AddThingIntercepts
  002aa	8b 45 d4	 mov	 eax, DWORD PTR _mapy$[ebp]
  002ad	50		 push	 eax
  002ae	8b 4d d8	 mov	 ecx, DWORD PTR _mapx$[ebp]
  002b1	51		 push	 ecx
  002b2	e8 00 00 00 00	 call	 _P_BlockThingsIterator
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ba	85 c0		 test	 eax, eax
  002bc	75 04		 jne	 SHORT $LN18@P_PathTrav

; 1118 : 				return false; // early out

  002be	33 c0		 xor	 eax, eax
  002c0	eb 64		 jmp	 SHORT $LN1@P_PathTrav
$LN18@P_PathTrav:

; 1119 : 
; 1120 : 		if (mapx == xt2 && mapy == yt2)

  002c2	8b 45 d8	 mov	 eax, DWORD PTR _mapx$[ebp]
  002c5	3b 45 f4	 cmp	 eax, DWORD PTR _xt2$[ebp]
  002c8	75 0a		 jne	 SHORT $LN19@P_PathTrav
  002ca	8b 45 d4	 mov	 eax, DWORD PTR _mapy$[ebp]
  002cd	3b 45 f0	 cmp	 eax, DWORD PTR _yt2$[ebp]
  002d0	75 02		 jne	 SHORT $LN19@P_PathTrav

; 1121 : 			break;

  002d2	eb 41		 jmp	 SHORT $LN3@P_PathTrav
$LN19@P_PathTrav:

; 1122 : 
; 1123 : 		if ((yintercept >> FRACBITS) == mapy)

  002d4	8b 45 dc	 mov	 eax, DWORD PTR _yintercept$[ebp]
  002d7	c1 f8 10	 sar	 eax, 16			; 00000010H
  002da	3b 45 d4	 cmp	 eax, DWORD PTR _mapy$[ebp]
  002dd	75 14		 jne	 SHORT $LN20@P_PathTrav

; 1124 : 		{
; 1125 : 			yintercept += ystep;

  002df	8b 45 dc	 mov	 eax, DWORD PTR _yintercept$[ebp]
  002e2	03 45 e8	 add	 eax, DWORD PTR _ystep$[ebp]
  002e5	89 45 dc	 mov	 DWORD PTR _yintercept$[ebp], eax

; 1126 : 			mapx += mapxstep;

  002e8	8b 45 d8	 mov	 eax, DWORD PTR _mapx$[ebp]
  002eb	03 45 d0	 add	 eax, DWORD PTR _mapxstep$[ebp]
  002ee	89 45 d8	 mov	 DWORD PTR _mapx$[ebp], eax

; 1127 : 		}

  002f1	eb 1d		 jmp	 SHORT $LN22@P_PathTrav
$LN20@P_PathTrav:

; 1128 : 		else if ((xintercept >> FRACBITS) == mapx)

  002f3	8b 45 e0	 mov	 eax, DWORD PTR _xintercept$[ebp]
  002f6	c1 f8 10	 sar	 eax, 16			; 00000010H
  002f9	3b 45 d8	 cmp	 eax, DWORD PTR _mapx$[ebp]
  002fc	75 12		 jne	 SHORT $LN22@P_PathTrav

; 1129 : 		{
; 1130 : 			xintercept += xstep;

  002fe	8b 45 e0	 mov	 eax, DWORD PTR _xintercept$[ebp]
  00301	03 45 ec	 add	 eax, DWORD PTR _xstep$[ebp]
  00304	89 45 e0	 mov	 DWORD PTR _xintercept$[ebp], eax

; 1131 : 			mapy += mapystep;

  00307	8b 45 d4	 mov	 eax, DWORD PTR _mapy$[ebp]
  0030a	03 45 cc	 add	 eax, DWORD PTR _mapystep$[ebp]
  0030d	89 45 d4	 mov	 DWORD PTR _mapy$[ebp], eax
$LN22@P_PathTrav:

; 1132 : 		}
; 1133 : 	}

  00310	e9 4d ff ff ff	 jmp	 $LN2@P_PathTrav
$LN3@P_PathTrav:

; 1134 : 	// Go through the sorted list
; 1135 : 	return P_TraverseIntercepts(trav, FRACUNIT);

  00315	68 00 00 01 00	 push	 65536			; 00010000H
  0031a	8b 45 1c	 mov	 eax, DWORD PTR _trav$[ebp]
  0031d	50		 push	 eax
  0031e	e8 00 00 00 00	 call	 _P_TraverseIntercepts
  00323	83 c4 08	 add	 esp, 8
$LN1@P_PathTrav:

; 1136 : }

  00326	5f		 pop	 edi
  00327	5e		 pop	 esi
  00328	5b		 pop	 ebx
  00329	8b e5		 mov	 esp, ebp
  0032b	5d		 pop	 ebp
  0032c	c3		 ret	 0
_P_PathTraverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
END
