; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\lzf.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
PUBLIC	_lzf_decompress
EXTRN	__errno:PROC
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\lzf.c
;	COMDAT _lzf_decompress
_TEXT	SEGMENT
_ref$1 = -28						; size = 4
_len$2 = -24						; size = 4
_ctrl$3 = -20						; size = 4
_out_end$ = -16						; size = 4
_in_end$ = -12						; size = 4
_op$ = -8						; size = 4
_ip$ = -4						; size = 4
_in_data$ = 8						; size = 4
_in_len$ = 12						; size = 4
_out_data$ = 16						; size = 4
_out_len$ = 20						; size = 4
_lzf_decompress PROC					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 189  :   u8 const *ip = (const u8 *)in_data;

  00009	8b 45 08	 mov	 eax, DWORD PTR _in_data$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _ip$[ebp], eax

; 190  :   u8       *op = (u8 *)out_data;

  0000f	8b 45 10	 mov	 eax, DWORD PTR _out_data$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _op$[ebp], eax

; 191  :   u8 const *const in_end  = ip + in_len;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  00018	03 45 0c	 add	 eax, DWORD PTR _in_len$[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR _in_end$[ebp], eax

; 192  :   u8       *const out_end = op + out_len;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  00021	03 45 14	 add	 eax, DWORD PTR _out_len$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _out_end$[ebp], eax
$LN4@lzf_decomp:

; 193  : 
; 194  :   do
; 195  :     {
; 196  :       unsigned int ctrl = *ip++;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  0002a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002d	89 4d ec	 mov	 DWORD PTR _ctrl$3[ebp], ecx
  00030	8b 55 fc	 mov	 edx, DWORD PTR _ip$[ebp]
  00033	83 c2 01	 add	 edx, 1
  00036	89 55 fc	 mov	 DWORD PTR _ip$[ebp], edx

; 197  : 
; 198  :       if (ctrl < (1 << 5)) /* literal run */

  00039	83 7d ec 20	 cmp	 DWORD PTR _ctrl$3[ebp], 32 ; 00000020H
  0003d	73 6f		 jae	 SHORT $LN11@lzf_decomp

; 199  :         {
; 200  :           ctrl++;

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _ctrl$3[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 ec	 mov	 DWORD PTR _ctrl$3[ebp], eax

; 201  : 
; 202  :           if (op + ctrl > out_end)

  00048	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  0004b	03 45 ec	 add	 eax, DWORD PTR _ctrl$3[ebp]
  0004e	3b 45 f0	 cmp	 eax, DWORD PTR _out_end$[ebp]
  00051	76 12		 jbe	 SHORT $LN13@lzf_decomp

; 203  :             {
; 204  :               SET_ERRNO (E2BIG);

  00053	e8 00 00 00 00	 call	 __errno
  00058	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 205  :               return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 75 01 00 00	 jmp	 $LN1@lzf_decomp
$LN13@lzf_decomp:

; 206  :             }
; 207  : 
; 208  : #if CHECK_INPUT
; 209  :           if (ip + ctrl > in_end)

  00065	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  00068	03 45 ec	 add	 eax, DWORD PTR _ctrl$3[ebp]
  0006b	3b 45 f4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  0006e	76 12		 jbe	 SHORT $LN14@lzf_decomp

; 210  :             {
; 211  :               SET_ERRNO (EINVAL);

  00070	e8 00 00 00 00	 call	 __errno
  00075	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 212  :               return 0;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 58 01 00 00	 jmp	 $LN1@lzf_decomp
$LN14@lzf_decomp:

; 213  :             }
; 214  : #endif
; 215  : 
; 216  : #if USE_MEMCPY
; 217  :           M_Memcpy (op, ip, ctrl);
; 218  :           op += ctrl;
; 219  :           ip += ctrl;
; 220  : #else
; 221  :           do
; 222  :             *op++ = *ip++;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _ip$[ebp]
  00088	8a 11		 mov	 dl, BYTE PTR [ecx]
  0008a	88 10		 mov	 BYTE PTR [eax], dl
  0008c	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  0008f	83 c0 01	 add	 eax, 1
  00092	89 45 f8	 mov	 DWORD PTR _op$[ebp], eax
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _ip$[ebp]
  00098	83 c1 01	 add	 ecx, 1
  0009b	89 4d fc	 mov	 DWORD PTR _ip$[ebp], ecx

; 223  :           while (--ctrl);

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _ctrl$3[ebp]
  000a1	83 e8 01	 sub	 eax, 1
  000a4	89 45 ec	 mov	 DWORD PTR _ctrl$3[ebp], eax
  000a7	75 d9		 jne	 SHORT $LN14@lzf_decomp

; 224  : #endif
; 225  :         }

  000a9	e9 1a 01 00 00	 jmp	 $LN9@lzf_decomp
$LN11@lzf_decomp:

; 226  :       else /* back reference */
; 227  :         {
; 228  :           unsigned int len = ctrl >> 5;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _ctrl$3[ebp]
  000b1	c1 e8 05	 shr	 eax, 5
  000b4	89 45 e8	 mov	 DWORD PTR _len$2[ebp], eax

; 229  : 
; 230  :           u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;

  000b7	8b 45 ec	 mov	 eax, DWORD PTR _ctrl$3[ebp]
  000ba	83 e0 1f	 and	 eax, 31			; 0000001fH
  000bd	c1 e0 08	 shl	 eax, 8
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _op$[ebp]
  000c3	2b c8		 sub	 ecx, eax
  000c5	83 e9 01	 sub	 ecx, 1
  000c8	89 4d e4	 mov	 DWORD PTR _ref$1[ebp], ecx

; 231  : 
; 232  : #if CHECK_INPUT
; 233  :           if (ip >= in_end)

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  000ce	3b 45 f4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  000d1	72 12		 jb	 SHORT $LN15@lzf_decomp

; 234  :             {
; 235  :               SET_ERRNO (EINVAL);

  000d3	e8 00 00 00 00	 call	 __errno
  000d8	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 236  :               return 0;

  000de	33 c0		 xor	 eax, eax
  000e0	e9 f5 00 00 00	 jmp	 $LN1@lzf_decomp
$LN15@lzf_decomp:

; 237  :             }
; 238  : #endif
; 239  :           if (len == 7)

  000e5	83 7d e8 07	 cmp	 DWORD PTR _len$2[ebp], 7
  000e9	75 2f		 jne	 SHORT $LN17@lzf_decomp

; 240  :             {
; 241  :               len += *ip++;

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  000ee	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f1	03 4d e8	 add	 ecx, DWORD PTR _len$2[ebp]
  000f4	89 4d e8	 mov	 DWORD PTR _len$2[ebp], ecx
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _ip$[ebp]
  000fa	83 c2 01	 add	 edx, 1
  000fd	89 55 fc	 mov	 DWORD PTR _ip$[ebp], edx

; 242  : #if CHECK_INPUT
; 243  :               if (ip >= in_end)

  00100	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  00103	3b 45 f4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  00106	72 12		 jb	 SHORT $LN17@lzf_decomp

; 244  :                 {
; 245  :                   SET_ERRNO (EINVAL);

  00108	e8 00 00 00 00	 call	 __errno
  0010d	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 246  :                   return 0;

  00113	33 c0		 xor	 eax, eax
  00115	e9 c0 00 00 00	 jmp	 $LN1@lzf_decomp
$LN17@lzf_decomp:

; 247  :                 }
; 248  : #endif
; 249  :             }
; 250  : 
; 251  :           ref -= *ip++;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  0011d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00120	8b 55 e4	 mov	 edx, DWORD PTR _ref$1[ebp]
  00123	2b d1		 sub	 edx, ecx
  00125	89 55 e4	 mov	 DWORD PTR _ref$1[ebp], edx
  00128	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  0012b	83 c0 01	 add	 eax, 1
  0012e	89 45 fc	 mov	 DWORD PTR _ip$[ebp], eax

; 252  : 
; 253  :           if (op + len + 2 > out_end)

  00131	8b 45 e8	 mov	 eax, DWORD PTR _len$2[ebp]
  00134	8b 4d f8	 mov	 ecx, DWORD PTR _op$[ebp]
  00137	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  0013b	3b 55 f0	 cmp	 edx, DWORD PTR _out_end$[ebp]
  0013e	76 12		 jbe	 SHORT $LN18@lzf_decomp

; 254  :             {
; 255  :               SET_ERRNO (E2BIG);

  00140	e8 00 00 00 00	 call	 __errno
  00145	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 256  :               return 0;

  0014b	33 c0		 xor	 eax, eax
  0014d	e9 88 00 00 00	 jmp	 $LN1@lzf_decomp
$LN18@lzf_decomp:

; 257  :             }
; 258  : 
; 259  :           if (ref < (u8 *)out_data)

  00152	8b 45 e4	 mov	 eax, DWORD PTR _ref$1[ebp]
  00155	3b 45 10	 cmp	 eax, DWORD PTR _out_data$[ebp]
  00158	73 0f		 jae	 SHORT $LN19@lzf_decomp

; 260  :             {
; 261  :               SET_ERRNO (EINVAL);

  0015a	e8 00 00 00 00	 call	 __errno
  0015f	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 262  :               return 0;

  00165	33 c0		 xor	 eax, eax
  00167	eb 71		 jmp	 SHORT $LN1@lzf_decomp
$LN19@lzf_decomp:

; 263  :             }
; 264  : 
; 265  :           *op++ = *ref++;

  00169	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  0016c	8b 4d e4	 mov	 ecx, DWORD PTR _ref$1[ebp]
  0016f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00171	88 10		 mov	 BYTE PTR [eax], dl
  00173	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  00176	83 c0 01	 add	 eax, 1
  00179	89 45 f8	 mov	 DWORD PTR _op$[ebp], eax
  0017c	8b 4d e4	 mov	 ecx, DWORD PTR _ref$1[ebp]
  0017f	83 c1 01	 add	 ecx, 1
  00182	89 4d e4	 mov	 DWORD PTR _ref$1[ebp], ecx

; 266  :           *op++ = *ref++;

  00185	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  00188	8b 4d e4	 mov	 ecx, DWORD PTR _ref$1[ebp]
  0018b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0018d	88 10		 mov	 BYTE PTR [eax], dl
  0018f	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  00192	83 c0 01	 add	 eax, 1
  00195	89 45 f8	 mov	 DWORD PTR _op$[ebp], eax
  00198	8b 4d e4	 mov	 ecx, DWORD PTR _ref$1[ebp]
  0019b	83 c1 01	 add	 ecx, 1
  0019e	89 4d e4	 mov	 DWORD PTR _ref$1[ebp], ecx
$LN10@lzf_decomp:

; 267  : 
; 268  :           do
; 269  :             *op++ = *ref++;

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  001a4	8b 4d e4	 mov	 ecx, DWORD PTR _ref$1[ebp]
  001a7	8a 11		 mov	 dl, BYTE PTR [ecx]
  001a9	88 10		 mov	 BYTE PTR [eax], dl
  001ab	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  001ae	83 c0 01	 add	 eax, 1
  001b1	89 45 f8	 mov	 DWORD PTR _op$[ebp], eax
  001b4	8b 4d e4	 mov	 ecx, DWORD PTR _ref$1[ebp]
  001b7	83 c1 01	 add	 ecx, 1
  001ba	89 4d e4	 mov	 DWORD PTR _ref$1[ebp], ecx

; 270  :           while (--len);

  001bd	8b 45 e8	 mov	 eax, DWORD PTR _len$2[ebp]
  001c0	83 e8 01	 sub	 eax, 1
  001c3	89 45 e8	 mov	 DWORD PTR _len$2[ebp], eax
  001c6	75 d9		 jne	 SHORT $LN10@lzf_decomp
$LN9@lzf_decomp:

; 271  :         }
; 272  :     }
; 273  :   while (ip < in_end);

  001c8	8b 45 fc	 mov	 eax, DWORD PTR _ip$[ebp]
  001cb	3b 45 f4	 cmp	 eax, DWORD PTR _in_end$[ebp]
  001ce	0f 82 53 fe ff
	ff		 jb	 $LN4@lzf_decomp

; 274  : 
; 275  :   return op - (u8 *)out_data;

  001d4	8b 45 f8	 mov	 eax, DWORD PTR _op$[ebp]
  001d7	2b 45 10	 sub	 eax, DWORD PTR _out_data$[ebp]
$LN1@lzf_decomp:

; 276  : }

  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
_lzf_decompress ENDP
_TEXT	ENDS
END
