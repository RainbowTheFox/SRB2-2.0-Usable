; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\p_polyobj.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_PolyObjects:DWORD
COMM	_numPolyObjects:DWORD
COMM	_polyblocklinks:DWORD
_DATA	ENDS
PUBLIC	_Polyobj_GetForNum
PUBLIC	_Polyobj_InitLevel
PUBLIC	_Polyobj_MoveOnLoad
PUBLIC	_P_PointInsidePolyobj
PUBLIC	_P_MobjTouchingPolyobj
PUBLIC	_P_MobjInsidePolyobj
PUBLIC	_P_BBoxInsidePolyobj
PUBLIC	_Polyobj_GetInfo
PUBLIC	_T_PolyObjRotate
PUBLIC	_T_PolyObjMove
PUBLIC	_T_PolyObjWaypoint
PUBLIC	_T_PolyDoorSlide
PUBLIC	_T_PolyDoorSwing
PUBLIC	_T_PolyObjFlag
PUBLIC	_EV_DoPolyDoor
PUBLIC	_EV_DoPolyObjMove
PUBLIC	_EV_DoPolyObjWaypoint
PUBLIC	_EV_DoPolyObjRotate
PUBLIC	_EV_DoPolyObjFlag
PUBLIC	??_C@_0DF@ILBNMOLG@Polyobject?5?$CItag?3?5?$CFd?$CJ?5needs?5line@ ; `string'
PUBLIC	??_C@_0BN@PGDMLNHH@polyobject?5?$CFd?5is?5not?5closed?6@ ; `string'
PUBLIC	??_C@_0BI@BPFKKBMH@polyobject?5?$CFd?5is?5empty?6@ ; `string'
PUBLIC	??_C@_0CI@NNIJBMDC@polyobj?5?$CFd?5has?5more?5than?5one?5sp@ ; `string'
PUBLIC	??_C@_0BL@MKGPPMAC@PO?5ID?3?5?$CFd?$DL?5Num?5verts?3?5?$CFIu?6@ ; `string'
PUBLIC	??_C@_0BM@JFHGKJAG@polyobject?5id?5conflict?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CE@LHDOOFDP@bad?5polyobject?5?$CFd?5for?5anchor?5po@ ; `string'
PUBLIC	??_C@_0CF@NOFEPMCH@polyobj?5?$CFd?5has?5more?5than?5one?5an@ ; `string'
PUBLIC	??_C@_0DG@HJMIMBAC@T_PolyObjRotate?3?5thinker?5with?5i@ ; `string'
PUBLIC	??_C@_0DH@PGOHMFJA@T_PolyObjWaypoint?3?5thinker?5with@ ; `string'
PUBLIC	??_C@_0DE@NOIPMJIG@T_PolyObjWaypoint?3?5Unable?5to?5fi@ ; `string'
PUBLIC	??_C@_0BO@OPDLNCEP@Looking?5for?5next?5waypoint?4?4?4?6@ ; `string'
PUBLIC	??_C@_0CK@OOJOEGDC@Found?5waypoint?5?$CIsequence?5?$CFd?0?5nu@ ; `string'
PUBLIC	??_C@_0BK@JEFHHCNP@Next?5waypoint?5not?5found?$CB?6@ ; `string'
PUBLIC	??_C@_0DG@MPIKCKOA@T_PolyDoorSlide?3?5thinker?5with?5i@ ; `string'
PUBLIC	??_C@_0DG@FKHFGPAA@T_PolyDoorSwing?3?5thinker?5with?5i@ ; `string'
PUBLIC	??_C@_0CE@HHEDECGB@EV_DoPolyObjRotate?3?5bad?5polyobj@ ; `string'
PUBLIC	??_C@_0CC@KHKDIAJP@EV_DoPolyObjMove?3?5bad?5polyobj?5?$CF@ ; `string'
PUBLIC	??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@ ; `string'
PUBLIC	??_C@_0DC@EFOAJPAK@EV_DoPolyObjWaypoint?3?5Missing?5s@ ; `string'
PUBLIC	??_C@_0DA@IDOMMLDN@EV_DoPolyObjWaypoint?3?5Missing?5t@ ; `string'
PUBLIC	??_C@_0BP@BIDPEPNN@EV_DoPolyDoor?3?5bad?5polyobj?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CE@FPAINNDC@EV_DoPolyDoor?3?5unknown?5door?5typ@ ; `string'
PUBLIC	??_C@_0DE@BLCKHLDP@T_PolyObjFlag?3?5thinker?5with?5inv@ ; `string'
PUBLIC	??_C@_0BP@HJEBPJGJ@EV_DoPolyFlag?3?5bad?5polyobj?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0DC@KODGNCDM@EV_DoPolyFlag?3?5Polyobject?5has?5o@ ; `string'
EXTRN	_memset:PROC
EXTRN	_malloc:PROC
EXTRN	_qsort:PROC
EXTRN	_abs:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_Z_ReallocAlign:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_FixedAngle:PROC
EXTRN	_M_AddToBox:PROC
EXTRN	_M_QueueInit:PROC
EXTRN	_M_QueueInsert:PROC
EXTRN	_M_QueueIterator:PROC
EXTRN	_M_QueueFree:PROC
EXTRN	_P_AproxDistance:PROC
EXTRN	_P_ClosestPointOnLine:PROC
EXTRN	_P_PointOnLineSide:PROC
EXTRN	_P_BoxOnLineSide:PROC
EXTRN	_P_RemoveThinkerDelayed:PROC
EXTRN	_P_AddThinker:PROC
EXTRN	_P_RemoveThinker:PROC
EXTRN	_P_MobjThinker:PROC
EXTRN	_P_UnsetThingPosition:PROC
EXTRN	_P_SetThingPosition:PROC
EXTRN	_P_CheckPosition:PROC
EXTRN	_P_TryMove:PROC
EXTRN	_P_ProcessSpecialSector:PROC
EXTRN	_P_FindSpecialLineFromTag:PROC
EXTRN	_R_PointToAngle2:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_finesine:BYTE
EXTRN	_finecosine:DWORD
EXTRN	_cv_debug:DWORD
EXTRN	_thinkercap:BYTE
EXTRN	_tmfloorz:DWORD
EXTRN	_tmceilingz:DWORD
EXTRN	_bmapwidth:DWORD
EXTRN	_bmapheight:DWORD
EXTRN	_bmaporgx:DWORD
EXTRN	_bmaporgy:DWORD
EXTRN	_blocklinks:DWORD
EXTRN	_numsegs:DWORD
EXTRN	_segs:DWORD
EXTRN	_lines:DWORD
EXTRN	_sides:DWORD
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_bmap_freelist DD 01H DUP (?)
?pomovecount@?1??Polyobj_carryThings@@9@9 DD 01H DUP (?) ; `Polyobj_carryThings'::`2'::pomovecount
_BSS	ENDS
;	COMDAT ??_C@_0DC@KODGNCDM@EV_DoPolyFlag?3?5Polyobject?5has?5o@
CONST	SEGMENT
??_C@_0DC@KODGNCDM@EV_DoPolyFlag?3?5Polyobject?5has?5o@ DB 'EV_DoPolyFlag'
	DB	': Polyobject has odd # of vertices!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HJEBPJGJ@EV_DoPolyFlag?3?5bad?5polyobj?5?$CFd?6@
CONST	SEGMENT
??_C@_0BP@HJEBPJGJ@EV_DoPolyFlag?3?5bad?5polyobj?5?$CFd?6@ DB 'EV_DoPolyF'
	DB	'lag: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BLCKHLDP@T_PolyObjFlag?3?5thinker?5with?5inv@
CONST	SEGMENT
??_C@_0DE@BLCKHLDP@T_PolyObjFlag?3?5thinker?5with?5inv@ DB 'T_PolyObjFlag'
	DB	': thinker with invalid id %d removed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FPAINNDC@EV_DoPolyDoor?3?5unknown?5door?5typ@
CONST	SEGMENT
??_C@_0CE@FPAINNDC@EV_DoPolyDoor?3?5unknown?5door?5typ@ DB 'EV_DoPolyDoor'
	DB	': unknown door type %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BIDPEPNN@EV_DoPolyDoor?3?5bad?5polyobj?5?$CFd?6@
CONST	SEGMENT
??_C@_0BP@BIDPEPNN@EV_DoPolyDoor?3?5bad?5polyobj?5?$CFd?6@ DB 'EV_DoPolyD'
	DB	'oor: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IDOMMLDN@EV_DoPolyObjWaypoint?3?5Missing?5t@
CONST	SEGMENT
??_C@_0DA@IDOMMLDN@EV_DoPolyObjWaypoint?3?5Missing?5t@ DB 'EV_DoPolyObjWa'
	DB	'ypoint: Missing target waypoint!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EFOAJPAK@EV_DoPolyObjWaypoint?3?5Missing?5s@
CONST	SEGMENT
??_C@_0DC@EFOAJPAK@EV_DoPolyObjWaypoint?3?5Missing?5s@ DB 'EV_DoPolyObjWa'
	DB	'ypoint: Missing starting waypoint!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@
CONST	SEGMENT
??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@ DB 'EV_DoPolyObjWa'
	DB	'ypoint: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KHKDIAJP@EV_DoPolyObjMove?3?5bad?5polyobj?5?$CF@
CONST	SEGMENT
??_C@_0CC@KHKDIAJP@EV_DoPolyObjMove?3?5bad?5polyobj?5?$CF@ DB 'EV_DoPolyO'
	DB	'bjMove: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HHEDECGB@EV_DoPolyObjRotate?3?5bad?5polyobj@
CONST	SEGMENT
??_C@_0CE@HHEDECGB@EV_DoPolyObjRotate?3?5bad?5polyobj@ DB 'EV_DoPolyObjRo'
	DB	'tate: bad polyobj %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FKHFGPAA@T_PolyDoorSwing?3?5thinker?5with?5i@
CONST	SEGMENT
??_C@_0DG@FKHFGPAA@T_PolyDoorSwing?3?5thinker?5with?5i@ DB 'T_PolyDoorSwi'
	DB	'ng: thinker with invalid id %d removed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MPIKCKOA@T_PolyDoorSlide?3?5thinker?5with?5i@
CONST	SEGMENT
??_C@_0DG@MPIKCKOA@T_PolyDoorSlide?3?5thinker?5with?5i@ DB 'T_PolyDoorSli'
	DB	'de: thinker with invalid id %d removed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JEFHHCNP@Next?5waypoint?5not?5found?$CB?6@
CONST	SEGMENT
??_C@_0BK@JEFHHCNP@Next?5waypoint?5not?5found?$CB?6@ DB 'Next waypoint no'
	DB	't found!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OOJOEGDC@Found?5waypoint?5?$CIsequence?5?$CFd?0?5nu@
CONST	SEGMENT
??_C@_0CK@OOJOEGDC@Found?5waypoint?5?$CIsequence?5?$CFd?0?5nu@ DB 'Found '
	DB	'waypoint (sequence %d, number %d).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OPDLNCEP@Looking?5for?5next?5waypoint?4?4?4?6@
CONST	SEGMENT
??_C@_0BO@OPDLNCEP@Looking?5for?5next?5waypoint?4?4?4?6@ DB 'Looking for '
	DB	'next waypoint...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NOIPMJIG@T_PolyObjWaypoint?3?5Unable?5to?5fi@
CONST	SEGMENT
??_C@_0DE@NOIPMJIG@T_PolyObjWaypoint?3?5Unable?5to?5fi@ DB 'T_PolyObjWayp'
	DB	'oint: Unable to find target waypoint!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PGOHMFJA@T_PolyObjWaypoint?3?5thinker?5with@
CONST	SEGMENT
??_C@_0DH@PGOHMFJA@T_PolyObjWaypoint?3?5thinker?5with@ DB 'T_PolyObjWaypo'
	DB	'int: thinker with invalid id %d removed.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HJMIMBAC@T_PolyObjRotate?3?5thinker?5with?5i@
CONST	SEGMENT
??_C@_0DG@HJMIMBAC@T_PolyObjRotate?3?5thinker?5with?5i@ DB 'T_PolyObjRota'
	DB	'te: thinker with invalid id %d removed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NOFEPMCH@polyobj?5?$CFd?5has?5more?5than?5one?5an@
CONST	SEGMENT
??_C@_0CF@NOFEPMCH@polyobj?5?$CFd?5has?5more?5than?5one?5an@ DB 'polyobj '
	DB	'%d has more than one anchor', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LHDOOFDP@bad?5polyobject?5?$CFd?5for?5anchor?5po@
CONST	SEGMENT
??_C@_0CE@LHDOOFDP@bad?5polyobject?5?$CFd?5for?5anchor?5po@ DB 'bad polyo'
	DB	'bject %d for anchor point', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JFHGKJAG@polyobject?5id?5conflict?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@JFHGKJAG@polyobject?5id?5conflict?3?5?$CFd?6@ DB 'polyobject id'
	DB	' conflict: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MKGPPMAC@PO?5ID?3?5?$CFd?$DL?5Num?5verts?3?5?$CFIu?6@
CONST	SEGMENT
??_C@_0BL@MKGPPMAC@PO?5ID?3?5?$CFd?$DL?5Num?5verts?3?5?$CFIu?6@ DB 'PO ID'
	DB	': %d; Num verts: %Iu', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NNIJBMDC@polyobj?5?$CFd?5has?5more?5than?5one?5sp@
CONST	SEGMENT
??_C@_0CI@NNIJBMDC@polyobj?5?$CFd?5has?5more?5than?5one?5sp@ DB 'polyobj '
	DB	'%d has more than one spawn spot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BPFKKBMH@polyobject?5?$CFd?5is?5empty?6@
CONST	SEGMENT
??_C@_0BI@BPFKKBMH@polyobject?5?$CFd?5is?5empty?6@ DB 'polyobject %d is e'
	DB	'mpty', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PGDMLNHH@polyobject?5?$CFd?5is?5not?5closed?6@
CONST	SEGMENT
??_C@_0BN@PGDMLNHH@polyobject?5?$CFd?5is?5not?5closed?6@ DB 'polyobject %'
	DB	'd is not closed', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ILBNMOLG@Polyobject?5?$CItag?3?5?$CFd?$CJ?5needs?5line@
CONST	SEGMENT
??_C@_0DF@ILBNMOLG@Polyobject?5?$CItag?3?5?$CFd?$CJ?5needs?5line@ DB 'Pol'
	DB	'yobject (tag: %d) needs line %d for information.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0273H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0beH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01e7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02c0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	018cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0112H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0154H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	019eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0baH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0bbH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_doSwingDoor
_TEXT	SEGMENT
tv82 = -80						; size = 4
_start$ = -12						; size = 4
_oldpo$ = -8						; size = 4
_th$ = -4						; size = 4
_po$ = 8						; size = 4
_doordata$ = 12						; size = 4
_Polyobj_doSwingDoor PROC				; COMDAT

; 2446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2447 : 	polyswingdoor_t *th;
; 2448 : 	polyobj_t *oldpo;
; 2449 : 	INT32 start;
; 2450 : 
; 2451 : 	// allocate and add a new swing door thinker
; 2452 : 	th = Z_Malloc(sizeof(polyswingdoor_t), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 30		 push	 48			; 00000030H
  00011	e8 00 00 00 00	 call	 _Z_MallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _th$[ebp], eax

; 2453 : 	th->thinker.function.acp1 = (actionf_p1)T_PolyDoorSwing;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_PolyDoorSwing

; 2454 : 	P_AddThinker(&th->thinker);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _P_AddThinker
  0002f	83 c4 04	 add	 esp, 4

; 2455 : 
; 2456 : 	// point the polyobject to this thinker
; 2457 : 	po->thinker = &th->thinker;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00038	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2458 : 
; 2459 : 	// setup fields of the thinker
; 2460 : 	th->polyObjNum   = po->id;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2461 : 	th->closing      = false;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0004d	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0

; 2462 : 	th->delay        = doordata->delay;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _doordata$[ebp]
  00057	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0005a	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2463 : 	th->delayCount   = 0;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00060	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 2464 : 	th->distance     = th->initDistance = FixedAngle(doordata->distance*FRACUNIT);

  00067	8b 45 0c	 mov	 eax, DWORD PTR _doordata$[ebp]
  0006a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0006d	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _FixedAngle
  00076	83 c4 04	 add	 esp, 4
  00079	89 45 b0	 mov	 DWORD PTR tv82[ebp], eax
  0007c	8b 55 fc	 mov	 edx, DWORD PTR _th$[ebp]
  0007f	8b 45 b0	 mov	 eax, DWORD PTR tv82[ebp]
  00082	89 42 24	 mov	 DWORD PTR [edx+36], eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  00088	8b 55 b0	 mov	 edx, DWORD PTR tv82[ebp]
  0008b	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 2465 : 	th->speed        = Polyobj_AngSpeed(doordata->speed);

  0008e	8b 45 0c	 mov	 eax, DWORD PTR _doordata$[ebp]
  00091	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _Polyobj_AngSpeed
  0009a	83 c4 04	 add	 esp, 4
  0009d	8b 55 fc	 mov	 edx, DWORD PTR _th$[ebp]
  000a0	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 2466 : 	th->initSpeed    = th->speed;

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  000a9	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000ac	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 2467 : 
; 2468 : 	// set polyobject's thrust
; 2469 : 	po->thrust = abs(th->speed) >> 3;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000b2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 _abs
  000bb	83 c4 04	 add	 esp, 4
  000be	c1 f8 03	 sar	 eax, 3
  000c1	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000c4	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 2470 : 	if (po->thrust < FRACUNIT)

  000ca	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000cd	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  000d7	7d 0f		 jge	 SHORT $LN4@Polyobj_do

; 2471 : 		po->thrust = FRACUNIT;

  000d9	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000dc	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  000e6	eb 1c		 jmp	 SHORT $LN6@Polyobj_do
$LN4@Polyobj_do:

; 2472 : 	else if (po->thrust > 4*FRACUNIT)

  000e8	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000eb	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  000f5	7e 0d		 jle	 SHORT $LN6@Polyobj_do

; 2473 : 		po->thrust = 4*FRACUNIT;

  000f7	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000fa	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN6@Polyobj_do:

; 2474 : 
; 2475 : 	// TODO: sound sequence start event
; 2476 : 
; 2477 : 	oldpo = po;

  00104	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00107	89 45 f8	 mov	 DWORD PTR _oldpo$[ebp], eax

; 2478 : 
; 2479 : 	// start action on mirroring polyobjects as well
; 2480 : 	start = 0;

  0010a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN2@Polyobj_do:

; 2481 : 	while ((po = Polyobj_GetChild(oldpo, &start)))

  00111	8d 45 f4	 lea	 eax, DWORD PTR _start$[ebp]
  00114	50		 push	 eax
  00115	8b 4d f8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 _Polyobj_GetChild
  0011e	83 c4 08	 add	 esp, 8
  00121	89 45 08	 mov	 DWORD PTR _po$[ebp], eax
  00124	83 7d 08 00	 cmp	 DWORD PTR _po$[ebp], 0
  00128	74 12		 je	 SHORT $LN3@Polyobj_do

; 2482 : 		Polyobj_doSwingDoor(po, doordata);

  0012a	8b 45 0c	 mov	 eax, DWORD PTR _doordata$[ebp]
  0012d	50		 push	 eax
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 _Polyobj_doSwingDoor
  00137	83 c4 08	 add	 esp, 8
  0013a	eb d5		 jmp	 SHORT $LN2@Polyobj_do
$LN3@Polyobj_do:

; 2483 : }

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
_Polyobj_doSwingDoor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_doSlideDoor
_TEXT	SEGMENT
_start$ = -16						; size = 4
_angtemp$ = -12						; size = 4
_oldpo$ = -8						; size = 4
_th$ = -4						; size = 4
_po$ = 8						; size = 4
_doordata$ = 12						; size = 4
_Polyobj_doSlideDoor PROC				; COMDAT

; 2397 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2398 : 	polyslidedoor_t *th;
; 2399 : 	polyobj_t *oldpo;
; 2400 : 	angle_t angtemp;
; 2401 : 	INT32 start;
; 2402 : 
; 2403 : 	// allocate and add a new slide door thinker
; 2404 : 	th = Z_Malloc(sizeof(polyslidedoor_t), PU_LEVSPEC, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 33		 push	 51			; 00000033H
  0000f	6a 44		 push	 68			; 00000044H
  00011	e8 00 00 00 00	 call	 _Z_MallocAlign
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	89 45 fc	 mov	 DWORD PTR _th$[ebp], eax

; 2405 : 	th->thinker.function.acp1 = (actionf_p1)T_PolyDoorSlide;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_PolyDoorSlide

; 2406 : 	P_AddThinker(&th->thinker);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _P_AddThinker
  0002f	83 c4 04	 add	 esp, 4

; 2407 : 
; 2408 : 	// point the polyobject to this thinker
; 2409 : 	po->thinker = &th->thinker;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00038	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2410 : 
; 2411 : 	// setup fields of the thinker
; 2412 : 	th->polyObjNum = po->id;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00044	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00047	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2413 : 	th->closing = false;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0004d	c6 40 40 00	 mov	 BYTE PTR [eax+64], 0

; 2414 : 	th->delay = doordata->delay;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _doordata$[ebp]
  00057	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0005a	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2415 : 	th->delayCount = 0;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00060	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 2416 : 	th->distance = th->initDistance = doordata->distance;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _doordata$[ebp]
  0006d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00070	89 50 24	 mov	 DWORD PTR [eax+36], edx
  00073	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  00079	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0007c	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2417 : 	th->speed = th->initSpeed = doordata->speed;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _doordata$[ebp]
  00085	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00088	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  00091	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00094	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 2418 : 
; 2419 : 	// haleyjd: do angle reverse calculation in full precision to avoid
; 2420 : 	// drift due to ANGLETOFINESHIFT.
; 2421 : 	angtemp       = doordata->angle;

  00097	8b 45 0c	 mov	 eax, DWORD PTR _doordata$[ebp]
  0009a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0009d	89 4d f4	 mov	 DWORD PTR _angtemp$[ebp], ecx

; 2422 : 	th->angle     = angtemp >> ANGLETOFINESHIFT;

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _angtemp$[ebp]
  000a3	c1 e8 13	 shr	 eax, 19			; 00000013H
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  000a9	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 2423 : 	th->initAngle = th->angle;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  000b2	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000b5	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 2424 : 	th->revAngle  = (angtemp + ANGLE_180) >> ANGLETOFINESHIFT;

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _angtemp$[ebp]
  000bb	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  000c0	c1 e8 13	 shr	 eax, 19			; 00000013H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  000c6	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 2425 : 
; 2426 : 	Polyobj_componentSpeed(th->speed, th->angle, &th->momx, &th->momy);

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000cc	83 c0 3c	 add	 eax, 60			; 0000003cH
  000cf	50		 push	 eax
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  000d3	83 c1 38	 add	 ecx, 56			; 00000038H
  000d6	51		 push	 ecx
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _th$[ebp]
  000da	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000dd	50		 push	 eax
  000de	8b 4d fc	 mov	 ecx, DWORD PTR _th$[ebp]
  000e1	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  000ea	83 c4 10	 add	 esp, 16			; 00000010H

; 2427 : 
; 2428 : 	// set polyobject's thrust
; 2429 : 	po->thrust = abs(th->speed) >> 3;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  000f0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _abs
  000f9	83 c4 04	 add	 esp, 4
  000fc	c1 f8 03	 sar	 eax, 3
  000ff	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00102	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 2430 : 	if (po->thrust < FRACUNIT)

  00108	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0010b	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00115	7d 0f		 jge	 SHORT $LN4@Polyobj_do

; 2431 : 		po->thrust = FRACUNIT;

  00117	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0011a	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  00124	eb 1c		 jmp	 SHORT $LN6@Polyobj_do
$LN4@Polyobj_do:

; 2432 : 	else if (po->thrust > 4*FRACUNIT)

  00126	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00129	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  00133	7e 0d		 jle	 SHORT $LN6@Polyobj_do

; 2433 : 		po->thrust = 4*FRACUNIT;

  00135	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00138	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN6@Polyobj_do:

; 2434 : 
; 2435 : 	// TODO: sound sequence start event
; 2436 : 
; 2437 : 	oldpo = po;

  00142	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00145	89 45 f8	 mov	 DWORD PTR _oldpo$[ebp], eax

; 2438 : 
; 2439 : 	// start action on mirroring polyobjects as well
; 2440 : 	start = 0;

  00148	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN2@Polyobj_do:

; 2441 : 	while ((po = Polyobj_GetChild(oldpo, &start)))

  0014f	8d 45 f0	 lea	 eax, DWORD PTR _start$[ebp]
  00152	50		 push	 eax
  00153	8b 4d f8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  00156	51		 push	 ecx
  00157	e8 00 00 00 00	 call	 _Polyobj_GetChild
  0015c	83 c4 08	 add	 esp, 8
  0015f	89 45 08	 mov	 DWORD PTR _po$[ebp], eax
  00162	83 7d 08 00	 cmp	 DWORD PTR _po$[ebp], 0
  00166	74 12		 je	 SHORT $LN3@Polyobj_do

; 2442 : 		Polyobj_doSlideDoor(po, doordata);

  00168	8b 45 0c	 mov	 eax, DWORD PTR _doordata$[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 _Polyobj_doSlideDoor
  00175	83 c4 08	 add	 esp, 8
  00178	eb d5		 jmp	 SHORT $LN2@Polyobj_do
$LN3@Polyobj_do:

; 2443 : }

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
_Polyobj_doSlideDoor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_AngSpeed
_TEXT	SEGMENT
_speed$ = 8						; size = 4
_Polyobj_AngSpeed PROC					; COMDAT

; 2113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2114 : 	return (speed*ANG1)>>3; // no FixedAngle()

  00009	69 45 08 61 0b
	b6 00		 imul	 eax, DWORD PTR _speed$[ebp], 11930465
  00010	c1 f8 03	 sar	 eax, 3

; 2115 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_Polyobj_AngSpeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_componentSpeed
_TEXT	SEGMENT
_resVel$ = 8						; size = 4
_angle$ = 12						; size = 4
_xVel$ = 16						; size = 4
_yVel$ = 20						; size = 4
_Polyobj_componentSpeed PROC				; COMDAT

; 1569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1570 : 	*xVel = FixedMul(resVel, FINECOSINE(angle));

  00009	8b 45 0c	 mov	 eax, DWORD PTR _angle$[ebp]
  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00012	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00015	52		 push	 edx
  00016	8b 45 08	 mov	 eax, DWORD PTR _resVel$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _FixedMul
  0001f	83 c4 08	 add	 esp, 8
  00022	8b 4d 10	 mov	 ecx, DWORD PTR _xVel$[ebp]
  00025	89 01		 mov	 DWORD PTR [ecx], eax

; 1571 : 	*yVel = FixedMul(resVel,   FINESINE(angle));

  00027	8b 45 0c	 mov	 eax, DWORD PTR _angle$[ebp]
  0002a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _resVel$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _FixedMul
  0003b	83 c4 08	 add	 esp, 8
  0003e	8b 4d 14	 mov	 ecx, DWORD PTR _yVel$[ebp]
  00041	89 01		 mov	 DWORD PTR [ecx], eax

; 1572 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_Polyobj_componentSpeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_GetChild
_TEXT	SEGMENT
tv74 = -68						; size = 4
_po$ = 8						; size = 4
_start$ = 12						; size = 4
_Polyobj_GetChild PROC					; COMDAT

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1335 : 	for (; *start < numPolyObjects; (*start)++)

  00009	eb 0d		 jmp	 SHORT $LN4@Polyobj_Ge
$LN2@Polyobj_Ge:
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	83 c1 01	 add	 ecx, 1
  00013	8b 55 0c	 mov	 edx, DWORD PTR _start$[ebp]
  00016	89 0a		 mov	 DWORD PTR [edx], ecx
$LN4@Polyobj_Ge:
  00018	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numPolyObjects
  00023	7d 41		 jge	 SHORT $LN3@Polyobj_Ge

; 1336 : 	{
; 1337 : 		if (PolyObjects[*start].parent == po->id)

  00025	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00028	69 08 a8 00 00
	00		 imul	 ecx, DWORD PTR [eax], 168
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _PolyObjects
  00034	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00037	8b 4c 0a 14	 mov	 ecx, DWORD PTR [edx+ecx+20]
  0003b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003e	75 24		 jne	 SHORT $LN5@Polyobj_Ge

; 1338 : 			return &PolyObjects[(*start)++];

  00040	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  00043	69 08 a8 00 00
	00		 imul	 ecx, DWORD PTR [eax], 168
  00049	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _PolyObjects
  0004f	89 4d bc	 mov	 DWORD PTR tv74[ebp], ecx
  00052	8b 55 0c	 mov	 edx, DWORD PTR _start$[ebp]
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	83 c0 01	 add	 eax, 1
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  0005d	89 01		 mov	 DWORD PTR [ecx], eax
  0005f	8b 45 bc	 mov	 eax, DWORD PTR tv74[ebp]
  00062	eb 04		 jmp	 SHORT $LN1@Polyobj_Ge
$LN5@Polyobj_Ge:

; 1339 : 	}

  00064	eb a5		 jmp	 SHORT $LN2@Polyobj_Ge
$LN3@Polyobj_Ge:

; 1340 : 
; 1341 : 	return NULL;

  00066	33 c0		 xor	 eax, eax
$LN1@Polyobj_Ge:

; 1342 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_Polyobj_GetChild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_rotate
_TEXT	SEGMENT
tv187 = -96						; size = 4
_hitflags$ = -28					; size = 4
_origin$ = -24						; size = 12
_angle$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_delta$ = 12						; size = 4
_Polyobj_rotate PROC					; COMDAT

; 1231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1232 : 	size_t i;
; 1233 : 	angle_t angle;
; 1234 : 	vertex_t origin;
; 1235 : 	INT32 hitflags = 0;

  00013	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hitflags$[ebp], 0

; 1236 : 
; 1237 : 	// don't move bad polyobjects
; 1238 : 	if (po->isBad)

  0001a	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001d	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00024	85 c9		 test	 ecx, ecx
  00026	74 07		 je	 SHORT $LN20@Polyobj_ro

; 1239 : 		return false;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 41 02 00 00	 jmp	 $LN1@Polyobj_ro
$LN20@Polyobj_ro:

; 1240 : 
; 1241 : 	angle = (po->angle + delta) >> ANGLETOFINESHIFT;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00032	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00035	03 4d 0c	 add	 ecx, DWORD PTR _delta$[ebp]
  00038	c1 e9 13	 shr	 ecx, 19			; 00000013H
  0003b	89 4d f4	 mov	 DWORD PTR _angle$[ebp], ecx

; 1242 : 
; 1243 : 	// point about which to rotate is the spawn spot
; 1244 : 	origin.x = po->spawnSpot.x;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00041	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00044	89 4d e8	 mov	 DWORD PTR _origin$[ebp], ecx

; 1245 : 	origin.y = po->spawnSpot.y;

  00047	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0004a	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0004d	89 4d ec	 mov	 DWORD PTR _origin$[ebp+4], ecx

; 1246 : 
; 1247 : 	// save current positions and rotate all vertices
; 1248 : 	for (i = 0; i < po->numVertices; ++i)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@Polyobj_ro
$LN2@Polyobj_ro:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_ro:
  00062	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00068	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  0006b	73 72		 jae	 SHORT $LN3@Polyobj_ro

; 1249 : 	{
; 1250 : 		po->tmpVerts[i] = *(po->vertices[i]);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00070	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00073	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00076	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0007a	8b 75 08	 mov	 esi, DWORD PTR _po$[ebp]
  0007d	8b 76 30	 mov	 esi, DWORD PTR [esi+48]
  00080	03 f0		 add	 esi, eax
  00082	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00085	8b 11		 mov	 edx, DWORD PTR [ecx]
  00087	89 16		 mov	 DWORD PTR [esi], edx
  00089	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0008f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00092	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 1251 : 
; 1252 : 		// use original pts to rotate to new position
; 1253 : 		*(po->vertices[i]) = po->origVerts[i];

  00095	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0009c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0009f	03 d0		 add	 edx, eax
  000a1	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000a4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  000ad	8b 02		 mov	 eax, DWORD PTR [edx]
  000af	89 01		 mov	 DWORD PTR [ecx], eax
  000b1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b4	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000b7	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000ba	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1254 : 
; 1255 : 		Polyobj_rotatePoint(po->vertices[i], &origin, angle);

  000bd	8b 45 f4	 mov	 eax, DWORD PTR _angle$[ebp]
  000c0	50		 push	 eax
  000c1	8d 4d e8	 lea	 ecx, DWORD PTR _origin$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000c8	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000ce	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _Polyobj_rotatePoint
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1256 : 	}

  000da	e9 7a ff ff ff	 jmp	 $LN2@Polyobj_ro
$LN3@Polyobj_ro:

; 1257 : 
; 1258 : 	// rotate lines
; 1259 : 	for (i = 0; i < po->numLines; ++i)

  000df	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e6	eb 09		 jmp	 SHORT $LN7@Polyobj_ro
$LN5@Polyobj_ro:
  000e8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000eb	83 c0 01	 add	 eax, 1
  000ee	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Polyobj_ro:
  000f1	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000f4	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000f7	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  000fa	73 17		 jae	 SHORT $LN6@Polyobj_ro

; 1260 : 		Polyobj_rotateLine(po->lines[i]);

  000fc	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000ff	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00102	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00105	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _Polyobj_rotateLine
  0010e	83 c4 04	 add	 esp, 4
  00111	eb d5		 jmp	 SHORT $LN5@Polyobj_ro
$LN6@Polyobj_ro:

; 1261 : 
; 1262 : 	// check for blocking things
; 1263 : 	for (i = 0; i < po->numLines; ++i)

  00113	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011a	eb 09		 jmp	 SHORT $LN10@Polyobj_ro
$LN8@Polyobj_ro:
  0011c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011f	83 c0 01	 add	 eax, 1
  00122	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Polyobj_ro:
  00125	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00128	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0012b	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  0012e	73 21		 jae	 SHORT $LN9@Polyobj_ro

; 1264 : 		hitflags |= Polyobj_clipThings(po, po->lines[i]);

  00130	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00133	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00136	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00139	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0013c	50		 push	 eax
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _Polyobj_clipThings
  00146	83 c4 08	 add	 esp, 8
  00149	0b 45 e4	 or	 eax, DWORD PTR _hitflags$[ebp]
  0014c	89 45 e4	 mov	 DWORD PTR _hitflags$[ebp], eax
  0014f	eb cb		 jmp	 SHORT $LN8@Polyobj_ro
$LN9@Polyobj_ro:

; 1265 : 
; 1266 : 	if (hitflags & 2)

  00151	8b 45 e4	 mov	 eax, DWORD PTR _hitflags$[ebp]
  00154	83 e0 02	 and	 eax, 2
  00157	74 7d		 je	 SHORT $LN21@Polyobj_ro

; 1267 : 	{
; 1268 : 		// reset vertices to previous positions
; 1269 : 		for (i = 0; i < po->numVertices; ++i)

  00159	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00160	eb 09		 jmp	 SHORT $LN13@Polyobj_ro
$LN11@Polyobj_ro:
  00162	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00165	83 c0 01	 add	 eax, 1
  00168	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@Polyobj_ro:
  0016b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00171	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00174	73 2a		 jae	 SHORT $LN12@Polyobj_ro

; 1270 : 			*(po->vertices[i]) = po->tmpVerts[i];

  00176	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0017a	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0017d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00180	03 d0		 add	 edx, eax
  00182	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00185	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00188	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0018b	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0018e	8b 02		 mov	 eax, DWORD PTR [edx]
  00190	89 01		 mov	 DWORD PTR [ecx], eax
  00192	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00195	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00198	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0019b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0019e	eb c2		 jmp	 SHORT $LN11@Polyobj_ro
$LN12@Polyobj_ro:

; 1271 : 
; 1272 : 		// reset lines
; 1273 : 		for (i = 0; i < po->numLines; ++i)

  001a0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001a7	eb 09		 jmp	 SHORT $LN16@Polyobj_ro
$LN14@Polyobj_ro:
  001a9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001ac	83 c0 01	 add	 eax, 1
  001af	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN16@Polyobj_ro:
  001b2	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001b5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001b8	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  001bb	73 17		 jae	 SHORT $LN15@Polyobj_ro

; 1274 : 			Polyobj_rotateLine(po->lines[i]);

  001bd	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001c0	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001c3	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  001c6	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 _Polyobj_rotateLine
  001cf	83 c4 04	 add	 esp, 4
  001d2	eb d5		 jmp	 SHORT $LN14@Polyobj_ro
$LN15@Polyobj_ro:

; 1275 : 	}

  001d4	eb 7f		 jmp	 SHORT $LN22@Polyobj_ro
$LN21@Polyobj_ro:

; 1276 : 	else
; 1277 : 	{
; 1278 : 		// update seg angles (used only by renderer)
; 1279 : 		for (i = 0; i < po->segCount; ++i)

  001d6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001dd	eb 09		 jmp	 SHORT $LN19@Polyobj_ro
$LN17@Polyobj_ro:
  001df	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001e2	83 c0 01	 add	 eax, 1
  001e5	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN19@Polyobj_ro:
  001e8	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001ee	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  001f1	73 23		 jae	 SHORT $LN18@Polyobj_ro

; 1280 : 			po->segs[i]->angle += delta;

  001f3	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001f6	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001f9	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  001fc	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001ff	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00202	03 4d 0c	 add	 ecx, DWORD PTR _delta$[ebp]
  00205	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00208	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0020b	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0020e	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00211	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00214	eb c9		 jmp	 SHORT $LN17@Polyobj_ro
$LN18@Polyobj_ro:

; 1281 : 
; 1282 : 		// update polyobject's angle
; 1283 : 		po->angle += delta;

  00216	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00219	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0021c	03 4d 0c	 add	 ecx, DWORD PTR _delta$[ebp]
  0021f	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00222	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 1284 : 
; 1285 : 		Polyobj_removeFromBlockmap(po); // unlink it from the blockmap

  00225	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _Polyobj_removeFromBlockmap
  0022e	83 c4 04	 add	 esp, 4

; 1286 : 		Polyobj_removeFromSubsec(po);   // remove from subsector

  00231	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 _Polyobj_removeFromSubsec
  0023a	83 c4 04	 add	 esp, 4

; 1287 : 		Polyobj_linkToBlockmap(po);     // relink to blockmap

  0023d	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 _Polyobj_linkToBlockmap
  00246	83 c4 04	 add	 esp, 4

; 1288 : 		Polyobj_attachToSubsec(po);     // relink to subsector

  00249	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 _Polyobj_attachToSubsec
  00252	83 c4 04	 add	 esp, 4
$LN22@Polyobj_ro:

; 1289 : 	}
; 1290 : 
; 1291 : 	return !(hitflags & 2);

  00255	8b 45 e4	 mov	 eax, DWORD PTR _hitflags$[ebp]
  00258	83 e0 02	 and	 eax, 2
  0025b	75 09		 jne	 SHORT $LN24@Polyobj_ro
  0025d	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv187[ebp], 1
  00264	eb 07		 jmp	 SHORT $LN25@Polyobj_ro
$LN24@Polyobj_ro:
  00266	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv187[ebp], 0
$LN25@Polyobj_ro:
  0026d	8b 45 a0	 mov	 eax, DWORD PTR tv187[ebp]
$LN1@Polyobj_ro:

; 1292 : }

  00270	5f		 pop	 edi
  00271	5e		 pop	 esi
  00272	5b		 pop	 ebx
  00273	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00276	33 cd		 xor	 ecx, ebp
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c3		 ret	 0
_Polyobj_rotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_rotateLine
_TEXT	SEGMENT
tv87 = -92						; size = 4
tv89 = -88						; size = 4
tv80 = -84						; size = 4
tv91 = -80						; size = 4
tv77 = -76						; size = 4
_v2$ = -8						; size = 4
_v1$ = -4						; size = 4
_ld$ = 8						; size = 4
_Polyobj_rotateLine PROC				; COMDAT

; 1187 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1188 : 	vertex_t *v1, *v2;
; 1189 : 
; 1190 : 	v1 = ld->v1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _v1$[ebp], ecx

; 1191 : 	v2 = ld->v2;

  00011	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00014	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00017	89 4d f8	 mov	 DWORD PTR _v2$[ebp], ecx

; 1192 : 
; 1193 : 	// set dx, dy
; 1194 : 	ld->dx = v2->x - v1->x;

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _v2$[ebp]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _v1$[ebp]
  00020	8b 10		 mov	 edx, DWORD PTR [eax]
  00022	2b 11		 sub	 edx, DWORD PTR [ecx]
  00024	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1195 : 	ld->dy = v2->y - v1->y;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _v2$[ebp]
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _v1$[ebp]
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00036	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00039	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1196 : 
; 1197 : 	// determine slopetype
; 1198 : 	ld->slopetype = !ld->dx ? ST_VERTICAL : !ld->dy ? ST_HORIZONTAL :

  0003c	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0003f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00043	75 09		 jne	 SHORT $LN7@Polyobj_ro
  00045	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  0004c	eb 07		 jmp	 SHORT $LN8@Polyobj_ro
$LN7@Polyobj_ro:
  0004e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN8@Polyobj_ro:
  00055	83 7d b4 00	 cmp	 DWORD PTR tv77[ebp], 0
  00059	74 09		 je	 SHORT $LN15@Polyobj_ro
  0005b	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00062	eb 5e		 jmp	 SHORT $LN16@Polyobj_ro
$LN15@Polyobj_ro:
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00067	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0006b	75 09		 jne	 SHORT $LN9@Polyobj_ro
  0006d	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00074	eb 07		 jmp	 SHORT $LN10@Polyobj_ro
$LN9@Polyobj_ro:
  00076	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN10@Polyobj_ro:
  0007d	83 7d ac 00	 cmp	 DWORD PTR tv80[ebp], 0
  00081	74 09		 je	 SHORT $LN13@Polyobj_ro
  00083	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  0008a	eb 30		 jmp	 SHORT $LN14@Polyobj_ro
$LN13@Polyobj_ro:
  0008c	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  0008f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00092	50		 push	 eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00096	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 _FixedDiv
  0009f	83 c4 08	 add	 esp, 8
  000a2	85 c0		 test	 eax, eax
  000a4	7e 09		 jle	 SHORT $LN11@Polyobj_ro
  000a6	c7 45 a4 02 00
	00 00		 mov	 DWORD PTR tv87[ebp], 2
  000ad	eb 07		 jmp	 SHORT $LN12@Polyobj_ro
$LN11@Polyobj_ro:
  000af	c7 45 a4 03 00
	00 00		 mov	 DWORD PTR tv87[ebp], 3
$LN12@Polyobj_ro:
  000b6	8b 45 a4	 mov	 eax, DWORD PTR tv87[ebp]
  000b9	89 45 a8	 mov	 DWORD PTR tv89[ebp], eax
$LN14@Polyobj_ro:
  000bc	8b 4d a8	 mov	 ecx, DWORD PTR tv89[ebp]
  000bf	89 4d b0	 mov	 DWORD PTR tv91[ebp], ecx
$LN16@Polyobj_ro:
  000c2	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000c5	8b 45 b0	 mov	 eax, DWORD PTR tv91[ebp]
  000c8	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 1199 : 			FixedDiv(ld->dy, ld->dx) > 0 ? ST_POSITIVE : ST_NEGATIVE;
; 1200 : 
; 1201 : 	// update bounding box
; 1202 : 	if (v1->x < v2->x)

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _v2$[ebp]
  000d1	8b 10		 mov	 edx, DWORD PTR [eax]
  000d3	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000d5	7d 29		 jge	 SHORT $LN2@Polyobj_ro

; 1203 : 	{
; 1204 : 		ld->bbox[BOXLEFT]  = v1->x;

  000d7	b8 04 00 00 00	 mov	 eax, 4
  000dc	d1 e0		 shl	 eax, 1
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _v1$[ebp]
  000e4	8b 12		 mov	 edx, DWORD PTR [edx]
  000e6	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1205 : 		ld->bbox[BOXRIGHT] = v2->x;

  000ea	b8 04 00 00 00	 mov	 eax, 4
  000ef	6b c8 03	 imul	 ecx, eax, 3
  000f2	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000f5	8b 45 f8	 mov	 eax, DWORD PTR _v2$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 1206 : 	}

  000fe	eb 27		 jmp	 SHORT $LN3@Polyobj_ro
$LN2@Polyobj_ro:

; 1207 : 	else
; 1208 : 	{
; 1209 : 		ld->bbox[BOXLEFT]  = v2->x;

  00100	b8 04 00 00 00	 mov	 eax, 4
  00105	d1 e0		 shl	 eax, 1
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  0010a	8b 55 f8	 mov	 edx, DWORD PTR _v2$[ebp]
  0010d	8b 12		 mov	 edx, DWORD PTR [edx]
  0010f	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1210 : 		ld->bbox[BOXRIGHT] = v1->x;

  00113	b8 04 00 00 00	 mov	 eax, 4
  00118	6b c8 03	 imul	 ecx, eax, 3
  0011b	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  0011e	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  00121	8b 00		 mov	 eax, DWORD PTR [eax]
  00123	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax
$LN3@Polyobj_ro:

; 1211 : 	}
; 1212 : 
; 1213 : 	if (v1->y < v2->y)

  00127	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _v2$[ebp]
  0012d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00130	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00133	7d 2c		 jge	 SHORT $LN4@Polyobj_ro

; 1214 : 	{
; 1215 : 		ld->bbox[BOXBOTTOM] = v1->y;

  00135	b8 04 00 00 00	 mov	 eax, 4
  0013a	c1 e0 00	 shl	 eax, 0
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00140	8b 55 fc	 mov	 edx, DWORD PTR _v1$[ebp]
  00143	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00146	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1216 : 		ld->bbox[BOXTOP]    = v2->y;

  0014a	b8 04 00 00 00	 mov	 eax, 4
  0014f	6b c8 00	 imul	 ecx, eax, 0
  00152	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  00155	8b 45 f8	 mov	 eax, DWORD PTR _v2$[ebp]
  00158	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015b	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax

; 1217 : 	}

  0015f	eb 2a		 jmp	 SHORT $LN5@Polyobj_ro
$LN4@Polyobj_ro:

; 1218 : 	else
; 1219 : 	{
; 1220 : 		ld->bbox[BOXBOTTOM] = v2->y;

  00161	b8 04 00 00 00	 mov	 eax, 4
  00166	c1 e0 00	 shl	 eax, 0
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  0016c	8b 55 f8	 mov	 edx, DWORD PTR _v2$[ebp]
  0016f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00172	89 54 01 1c	 mov	 DWORD PTR [ecx+eax+28], edx

; 1221 : 		ld->bbox[BOXTOP]    = v1->y;

  00176	b8 04 00 00 00	 mov	 eax, 4
  0017b	6b c8 00	 imul	 ecx, eax, 0
  0017e	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  00181	8b 45 fc	 mov	 eax, DWORD PTR _v1$[ebp]
  00184	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00187	89 44 0a 1c	 mov	 DWORD PTR [edx+ecx+28], eax
$LN5@Polyobj_ro:

; 1222 : 	}
; 1223 : }

  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
_Polyobj_rotateLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_rotatePoint
_TEXT	SEGMENT
_tmp$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_c$ = 12						; size = 4
_ang$ = 16						; size = 4
_Polyobj_rotatePoint PROC				; COMDAT

; 1170 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1171 : 	vertex_t tmp = *v;

  00013	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d f0	 mov	 DWORD PTR _tmp$[ebp], ecx
  0001b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001e	89 55 f4	 mov	 DWORD PTR _tmp$[ebp+4], edx
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 f8	 mov	 DWORD PTR _tmp$[ebp+8], eax

; 1172 : 
; 1173 : 	v->x = FixedMul(tmp.x, FINECOSINE(ang)) - FixedMul(tmp.y,   FINESINE(ang));

  00027	8b 45 10	 mov	 eax, DWORD PTR _ang$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00030	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00033	52		 push	 edx
  00034	8b 45 f0	 mov	 eax, DWORD PTR _tmp$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _FixedMul
  0003d	83 c4 08	 add	 esp, 8
  00040	8b f0		 mov	 esi, eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _ang$[ebp]
  00045	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finesine[ecx*4]
  0004c	52		 push	 edx
  0004d	8b 45 f4	 mov	 eax, DWORD PTR _tmp$[ebp+4]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _FixedMul
  00056	83 c4 08	 add	 esp, 8
  00059	2b f0		 sub	 esi, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0005e	89 31		 mov	 DWORD PTR [ecx], esi

; 1174 : 	v->y = FixedMul(tmp.x,   FINESINE(ang)) + FixedMul(tmp.y, FINECOSINE(ang));

  00060	8b 45 10	 mov	 eax, DWORD PTR _ang$[ebp]
  00063	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  0006a	51		 push	 ecx
  0006b	8b 55 f0	 mov	 edx, DWORD PTR _tmp$[ebp]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _FixedMul
  00074	83 c4 08	 add	 esp, 8
  00077	8b f0		 mov	 esi, eax
  00079	8b 45 10	 mov	 eax, DWORD PTR _ang$[ebp]
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00082	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00085	52		 push	 edx
  00086	8b 45 f4	 mov	 eax, DWORD PTR _tmp$[ebp+4]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _FixedMul
  0008f	83 c4 08	 add	 esp, 8
  00092	03 f0		 add	 esi, eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00097	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 1175 : 
; 1176 : 	v->x += c->x;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0009d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _c$[ebp]
  000a2	03 0a		 add	 ecx, DWORD PTR [edx]
  000a4	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000a7	89 08		 mov	 DWORD PTR [eax], ecx

; 1177 : 	v->y += c->y;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000ac	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000af	8b 55 0c	 mov	 edx, DWORD PTR _c$[ebp]
  000b2	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000b5	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000b8	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1178 : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
_Polyobj_rotatePoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_moveXY
_TEXT	SEGMENT
tv159 = -92						; size = 4
_hitflags$ = -24					; size = 4
_vec$ = -20						; size = 12
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_Polyobj_moveXY PROC					; COMDAT

; 1111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1112 : 	size_t i;
; 1113 : 	vertex_t vec;
; 1114 : 	INT32 hitflags = 0;

  00013	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hitflags$[ebp], 0

; 1115 : 
; 1116 : 	vec.x = x;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0001d	89 45 ec	 mov	 DWORD PTR _vec$[ebp], eax

; 1117 : 	vec.y = y;

  00020	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR _vec$[ebp+4], eax

; 1118 : 
; 1119 : 	// don't move bad polyobjects
; 1120 : 	if (po->isBad)

  00026	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00029	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00030	85 c9		 test	 ecx, ecx
  00032	74 07		 je	 SHORT $LN17@Polyobj_mo

; 1121 : 		return false;

  00034	33 c0		 xor	 eax, eax
  00036	e9 a9 01 00 00	 jmp	 $LN1@Polyobj_mo
$LN17@Polyobj_mo:

; 1122 : 
; 1123 : 	// translate vertices
; 1124 : 	for (i = 0; i < po->numVertices; ++i)

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00042	eb 09		 jmp	 SHORT $LN4@Polyobj_mo
$LN2@Polyobj_mo:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_mo:
  0004d	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00053	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00056	73 1b		 jae	 SHORT $LN3@Polyobj_mo

; 1125 : 		Polyobj_vecAdd(po->vertices[i], &vec);

  00058	8d 45 ec	 lea	 eax, DWORD PTR _vec$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0005f	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00062	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00065	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _Polyobj_vecAdd
  0006e	83 c4 08	 add	 esp, 8
  00071	eb d1		 jmp	 SHORT $LN2@Polyobj_mo
$LN3@Polyobj_mo:

; 1126 : 
; 1127 : 	// translate each line
; 1128 : 	for (i = 0; i < po->numLines; ++i)

  00073	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007a	eb 09		 jmp	 SHORT $LN7@Polyobj_mo
$LN5@Polyobj_mo:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Polyobj_mo:
  00085	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00088	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0008b	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  0008e	73 1e		 jae	 SHORT $LN6@Polyobj_mo

; 1129 : 		Polyobj_bboxAdd(po->lines[i]->bbox, &vec);

  00090	8d 45 ec	 lea	 eax, DWORD PTR _vec$[ebp]
  00093	50		 push	 eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00097	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009d	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  000a0	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _Polyobj_bboxAdd
  000a9	83 c4 08	 add	 esp, 8
  000ac	eb ce		 jmp	 SHORT $LN5@Polyobj_mo
$LN6@Polyobj_mo:

; 1130 : 
; 1131 : 	// check for blocking things (yes, it needs to be done separately)
; 1132 : 	for (i = 0; i < po->numLines; ++i)

  000ae	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b5	eb 09		 jmp	 SHORT $LN10@Polyobj_mo
$LN8@Polyobj_mo:
  000b7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Polyobj_mo:
  000c0	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000c6	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  000c9	73 21		 jae	 SHORT $LN9@Polyobj_mo

; 1133 : 		hitflags |= Polyobj_clipThings(po, po->lines[i]);

  000cb	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000ce	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000d1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000d4	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000d7	50		 push	 eax
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _Polyobj_clipThings
  000e1	83 c4 08	 add	 esp, 8
  000e4	0b 45 e8	 or	 eax, DWORD PTR _hitflags$[ebp]
  000e7	89 45 e8	 mov	 DWORD PTR _hitflags$[ebp], eax
  000ea	eb cb		 jmp	 SHORT $LN8@Polyobj_mo
$LN9@Polyobj_mo:

; 1134 : 
; 1135 : 	if (hitflags & 2)

  000ec	8b 45 e8	 mov	 eax, DWORD PTR _hitflags$[ebp]
  000ef	83 e0 02	 and	 eax, 2
  000f2	74 75		 je	 SHORT $LN18@Polyobj_mo

; 1136 : 	{
; 1137 : 		// reset vertices
; 1138 : 		for (i = 0; i < po->numVertices; ++i)

  000f4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000fb	eb 09		 jmp	 SHORT $LN13@Polyobj_mo
$LN11@Polyobj_mo:
  000fd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@Polyobj_mo:
  00106	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00109	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0010c	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  0010f	73 1b		 jae	 SHORT $LN12@Polyobj_mo

; 1139 : 			Polyobj_vecSub(po->vertices[i], &vec);

  00111	8d 45 ec	 lea	 eax, DWORD PTR _vec$[ebp]
  00114	50		 push	 eax
  00115	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00118	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011e	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 _Polyobj_vecSub
  00127	83 c4 08	 add	 esp, 8
  0012a	eb d1		 jmp	 SHORT $LN11@Polyobj_mo
$LN12@Polyobj_mo:

; 1140 : 
; 1141 : 		// reset lines that have been moved
; 1142 : 		for (i = 0; i < po->numLines; ++i)

  0012c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00133	eb 09		 jmp	 SHORT $LN16@Polyobj_mo
$LN14@Polyobj_mo:
  00135	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00138	83 c0 01	 add	 eax, 1
  0013b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN16@Polyobj_mo:
  0013e	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00141	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00144	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00147	73 1e		 jae	 SHORT $LN15@Polyobj_mo

; 1143 : 			Polyobj_bboxSub(po->lines[i]->bbox, &vec);

  00149	8d 45 ec	 lea	 eax, DWORD PTR _vec$[ebp]
  0014c	50		 push	 eax
  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00150	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00153	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00156	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00159	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _Polyobj_bboxSub
  00162	83 c4 08	 add	 esp, 8
  00165	eb ce		 jmp	 SHORT $LN14@Polyobj_mo
$LN15@Polyobj_mo:

; 1144 : 	}

  00167	eb 62		 jmp	 SHORT $LN19@Polyobj_mo
$LN18@Polyobj_mo:

; 1145 : 	else
; 1146 : 	{
; 1147 : 		// translate the spawnSpot as well
; 1148 : 		po->spawnSpot.x += vec.x;

  00169	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0016c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0016f	03 4d ec	 add	 ecx, DWORD PTR _vec$[ebp]
  00172	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00175	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 1149 : 		po->spawnSpot.y += vec.y;

  00178	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0017b	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0017e	03 4d f0	 add	 ecx, DWORD PTR _vec$[ebp+4]
  00181	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00184	89 4a 58	 mov	 DWORD PTR [edx+88], ecx

; 1150 : 
; 1151 : 		Polyobj_carryThings(po, x, y);

  00187	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0018a	50		 push	 eax
  0018b	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0018e	51		 push	 ecx
  0018f	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 _Polyobj_carryThings
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1152 : 		Polyobj_removeFromBlockmap(po); // unlink it from the blockmap

  0019b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _Polyobj_removeFromBlockmap
  001a4	83 c4 04	 add	 esp, 4

; 1153 : 		Polyobj_removeFromSubsec(po);   // unlink it from its subsector

  001a7	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 _Polyobj_removeFromSubsec
  001b0	83 c4 04	 add	 esp, 4

; 1154 : 		Polyobj_linkToBlockmap(po);     // relink to blockmap

  001b3	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _Polyobj_linkToBlockmap
  001bc	83 c4 04	 add	 esp, 4

; 1155 : 		Polyobj_attachToSubsec(po);     // relink to subsector

  001bf	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 _Polyobj_attachToSubsec
  001c8	83 c4 04	 add	 esp, 4
$LN19@Polyobj_mo:

; 1156 : 	}
; 1157 : 
; 1158 : 	return (hitflags == 0);

  001cb	83 7d e8 00	 cmp	 DWORD PTR _hitflags$[ebp], 0
  001cf	75 09		 jne	 SHORT $LN21@Polyobj_mo
  001d1	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv159[ebp], 1
  001d8	eb 07		 jmp	 SHORT $LN22@Polyobj_mo
$LN21@Polyobj_mo:
  001da	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
$LN22@Polyobj_mo:
  001e1	8b 45 a4	 mov	 eax, DWORD PTR tv159[ebp]
$LN1@Polyobj_mo:

; 1159 : }

  001e4	5f		 pop	 edi
  001e5	5e		 pop	 esi
  001e6	5b		 pop	 ebx
  001e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ea	33 cd		 xor	 ecx, ebp
  001ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c3		 ret	 0
_Polyobj_moveXY ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_clipThings
_TEXT	SEGMENT
_mo$1 = -36						; size = 4
_y$ = -32						; size = 4
_x$ = -28						; size = 4
_linebox$ = -24						; size = 16
_hitflags$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_line$ = 12						; size = 4
_Polyobj_clipThings PROC				; COMDAT

; 1047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1048 : 	INT32 hitflags = 0;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hitflags$[ebp], 0

; 1049 : 	fixed_t linebox[4];
; 1050 : 	INT32 x, y;
; 1051 : 
; 1052 : 	if (!(po->flags & POF_SOLID))

  0001a	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001d	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00023	83 e1 03	 and	 ecx, 3
  00026	75 08		 jne	 SHORT $LN11@Polyobj_cl

; 1053 : 		return hitflags;

  00028	8b 45 f8	 mov	 eax, DWORD PTR _hitflags$[ebp]
  0002b	e9 8d 02 00 00	 jmp	 $LN1@Polyobj_cl
$LN11@Polyobj_cl:

; 1054 : 
; 1055 : 	// adjust linedef bounding box to blockmap, extend by MAXRADIUS
; 1056 : 	linebox[BOXLEFT]   = (unsigned)(line->bbox[BOXLEFT]   - bmaporgx - MAXRADIUS) >> MAPBLOCKSHIFT;

  00030	b8 04 00 00 00	 mov	 eax, 4
  00035	d1 e0		 shl	 eax, 1
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  0003a	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  0003e	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  00044	81 ea 00 00 20
	00		 sub	 edx, 2097152		; 00200000H
  0004a	c1 ea 17	 shr	 edx, 23			; 00000017H
  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	d1 e0		 shl	 eax, 1
  00054	89 54 05 e8	 mov	 DWORD PTR _linebox$[ebp+eax], edx

; 1057 : 	linebox[BOXRIGHT]  = (unsigned)(line->bbox[BOXRIGHT]  - bmaporgx + MAXRADIUS) >> MAPBLOCKSHIFT;

  00058	b8 04 00 00 00	 mov	 eax, 4
  0005d	6b c8 03	 imul	 ecx, eax, 3
  00060	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  00063	8b 44 0a 1c	 mov	 eax, DWORD PTR [edx+ecx+28]
  00067	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgx
  0006d	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  00072	c1 e8 17	 shr	 eax, 23			; 00000017H
  00075	b9 04 00 00 00	 mov	 ecx, 4
  0007a	6b d1 03	 imul	 edx, ecx, 3
  0007d	89 44 15 e8	 mov	 DWORD PTR _linebox$[ebp+edx], eax

; 1058 : 	linebox[BOXBOTTOM] = (unsigned)(line->bbox[BOXBOTTOM] - bmaporgy - MAXRADIUS) >> MAPBLOCKSHIFT;

  00081	b8 04 00 00 00	 mov	 eax, 4
  00086	c1 e0 00	 shl	 eax, 0
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  0008c	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  00090	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  00096	81 ea 00 00 20
	00		 sub	 edx, 2097152		; 00200000H
  0009c	c1 ea 17	 shr	 edx, 23			; 00000017H
  0009f	b8 04 00 00 00	 mov	 eax, 4
  000a4	c1 e0 00	 shl	 eax, 0
  000a7	89 54 05 e8	 mov	 DWORD PTR _linebox$[ebp+eax], edx

; 1059 : 	linebox[BOXTOP]    = (unsigned)(line->bbox[BOXTOP]    - bmaporgy + MAXRADIUS) >> MAPBLOCKSHIFT;

  000ab	b8 04 00 00 00	 mov	 eax, 4
  000b0	6b c8 00	 imul	 ecx, eax, 0
  000b3	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  000b6	8b 44 0a 1c	 mov	 eax, DWORD PTR [edx+ecx+28]
  000ba	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgy
  000c0	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  000c5	c1 e8 17	 shr	 eax, 23			; 00000017H
  000c8	b9 04 00 00 00	 mov	 ecx, 4
  000cd	6b d1 00	 imul	 edx, ecx, 0
  000d0	89 44 15 e8	 mov	 DWORD PTR _linebox$[ebp+edx], eax

; 1060 : 
; 1061 : 	// check all mobj blockmap cells the line contacts
; 1062 : 	for (y = linebox[BOXBOTTOM]; y <= linebox[BOXTOP]; ++y)

  000d4	b8 04 00 00 00	 mov	 eax, 4
  000d9	c1 e0 00	 shl	 eax, 0
  000dc	8b 4c 05 e8	 mov	 ecx, DWORD PTR _linebox$[ebp+eax]
  000e0	89 4d e0	 mov	 DWORD PTR _y$[ebp], ecx
  000e3	eb 09		 jmp	 SHORT $LN4@Polyobj_cl
$LN2@Polyobj_cl:
  000e5	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  000e8	83 c0 01	 add	 eax, 1
  000eb	89 45 e0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@Polyobj_cl:
  000ee	b8 04 00 00 00	 mov	 eax, 4
  000f3	6b c8 00	 imul	 ecx, eax, 0
  000f6	8b 55 e0	 mov	 edx, DWORD PTR _y$[ebp]
  000f9	3b 54 0d e8	 cmp	 edx, DWORD PTR _linebox$[ebp+ecx]
  000fd	0f 8f b7 01 00
	00		 jg	 $LN3@Polyobj_cl

; 1063 : 	{
; 1064 : 		for (x = linebox[BOXLEFT]; x <= linebox[BOXRIGHT]; ++x)

  00103	b8 04 00 00 00	 mov	 eax, 4
  00108	d1 e0		 shl	 eax, 1
  0010a	8b 4c 05 e8	 mov	 ecx, DWORD PTR _linebox$[ebp+eax]
  0010e	89 4d e4	 mov	 DWORD PTR _x$[ebp], ecx
  00111	eb 09		 jmp	 SHORT $LN7@Polyobj_cl
$LN5@Polyobj_cl:
  00113	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00116	83 c0 01	 add	 eax, 1
  00119	89 45 e4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@Polyobj_cl:
  0011c	b8 04 00 00 00	 mov	 eax, 4
  00121	6b c8 03	 imul	 ecx, eax, 3
  00124	8b 55 e4	 mov	 edx, DWORD PTR _x$[ebp]
  00127	3b 54 0d e8	 cmp	 edx, DWORD PTR _linebox$[ebp+ecx]
  0012b	0f 8f 84 01 00
	00		 jg	 $LN6@Polyobj_cl

; 1065 : 		{
; 1066 : 			if (!(x < 0 || y < 0 || x >= bmapwidth || y >= bmapheight))

  00131	83 7d e4 00	 cmp	 DWORD PTR _x$[ebp], 0
  00135	0f 8c 75 01 00
	00		 jl	 $LN9@Polyobj_cl
  0013b	83 7d e0 00	 cmp	 DWORD PTR _y$[ebp], 0
  0013f	0f 8c 6b 01 00
	00		 jl	 $LN9@Polyobj_cl
  00145	8b 45 e4	 mov	 eax, DWORD PTR _x$[ebp]
  00148	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  0014e	0f 8d 5c 01 00
	00		 jge	 $LN9@Polyobj_cl
  00154	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00157	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  0015d	0f 8d 4d 01 00
	00		 jge	 $LN9@Polyobj_cl

; 1067 : 			{
; 1068 : 				mobj_t *mo = blocklinks[y * bmapwidth + x];

  00163	8b 45 e0	 mov	 eax, DWORD PTR _y$[ebp]
  00166	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  0016d	03 45 e4	 add	 eax, DWORD PTR _x$[ebp]
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blocklinks
  00176	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00179	89 55 dc	 mov	 DWORD PTR _mo$1[ebp], edx

; 1069 : 
; 1070 : 				for (; mo; mo = mo->bnext)

  0017c	eb 09		 jmp	 SHORT $LN10@Polyobj_cl
$LN8@Polyobj_cl:
  0017e	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  00181	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00184	89 4d dc	 mov	 DWORD PTR _mo$1[ebp], ecx
$LN10@Polyobj_cl:
  00187	83 7d dc 00	 cmp	 DWORD PTR _mo$1[ebp], 0
  0018b	0f 84 1f 01 00
	00		 je	 $LN9@Polyobj_cl

; 1071 : 				{
; 1072 : 					// always push players even if not solid
; 1073 : 					if (!((mo->flags & MF_SOLID) || mo->player))

  00191	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  00194	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00197	83 e1 02	 and	 ecx, 2
  0019a	75 0e		 jne	 SHORT $LN13@Polyobj_cl
  0019c	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  0019f	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001a6	75 02		 jne	 SHORT $LN13@Polyobj_cl

; 1074 : 						continue;

  001a8	eb d4		 jmp	 SHORT $LN8@Polyobj_cl
$LN13@Polyobj_cl:

; 1075 : 
; 1076 : 					if (mo->flags & MF_NOCLIP)

  001aa	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  001ad	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  001b0	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  001b6	74 02		 je	 SHORT $LN14@Polyobj_cl

; 1077 : 						continue;

  001b8	eb c4		 jmp	 SHORT $LN8@Polyobj_cl
$LN14@Polyobj_cl:

; 1078 : 
; 1079 : 					if (mo->z + mo->height <= line->backsector->floorheight)

  001ba	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  001bd	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001c0	8b 55 dc	 mov	 edx, DWORD PTR _mo$1[ebp]
  001c3	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  001c6	8b 45 0c	 mov	 eax, DWORD PTR _line$[ebp]
  001c9	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  001cc	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  001ce	7f 02		 jg	 SHORT $LN15@Polyobj_cl

; 1080 : 						continue;

  001d0	eb ac		 jmp	 SHORT $LN8@Polyobj_cl
$LN15@Polyobj_cl:

; 1081 : 
; 1082 : 					if (mo->z >= line->backsector->ceilingheight)

  001d2	8b 45 0c	 mov	 eax, DWORD PTR _line$[ebp]
  001d5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001d8	8b 55 dc	 mov	 edx, DWORD PTR _mo$1[ebp]
  001db	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001de	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  001e1	7c 02		 jl	 SHORT $LN16@Polyobj_cl

; 1083 : 						continue;

  001e3	eb 99		 jmp	 SHORT $LN8@Polyobj_cl
$LN16@Polyobj_cl:

; 1084 : 
; 1085 : 					if (Polyobj_untouched(line, mo))

  001e5	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 _Polyobj_untouched
  001f2	83 c4 08	 add	 esp, 8
  001f5	85 c0		 test	 eax, eax
  001f7	74 02		 je	 SHORT $LN17@Polyobj_cl

; 1086 : 						continue;

  001f9	eb 83		 jmp	 SHORT $LN8@Polyobj_cl
$LN17@Polyobj_cl:

; 1087 : 
; 1088 : 					if (mo->flags & MF_PUSHABLE && (po->flags & POF_PUSHABLESTOP))

  001fb	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  001fe	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00201	83 e1 40	 and	 ecx, 64			; 00000040H
  00204	74 1c		 je	 SHORT $LN18@Polyobj_cl
  00206	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00209	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0020f	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00215	74 0b		 je	 SHORT $LN18@Polyobj_cl

; 1089 : 						hitflags |= 2;

  00217	8b 45 f8	 mov	 eax, DWORD PTR _hitflags$[ebp]
  0021a	83 c8 02	 or	 eax, 2
  0021d	89 45 f8	 mov	 DWORD PTR _hitflags$[ebp], eax
  00220	eb 14		 jmp	 SHORT $LN19@Polyobj_cl
$LN18@Polyobj_cl:

; 1090 : 					else
; 1091 : 						Polyobj_pushThing(po, line, mo);

  00222	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  00225	50		 push	 eax
  00226	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  00229	51		 push	 ecx
  0022a	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0022d	52		 push	 edx
  0022e	e8 00 00 00 00	 call	 _Polyobj_pushThing
  00233	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@Polyobj_cl:

; 1092 : 
; 1093 : 					if (mo->player && (po->lines[0]->backsector->flags & SF_TRIGGERSPECIAL_TOUCH) && !(po->flags & POF_NOSPECIALS))

  00236	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  00239	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00240	74 60		 je	 SHORT $LN20@Polyobj_cl
  00242	b8 04 00 00 00	 mov	 eax, 4
  00247	6b c8 00	 imul	 ecx, eax, 0
  0024a	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0024d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00250	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00253	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00256	8b 82 e0 00 00
	00		 mov	 eax, DWORD PTR [edx+224]
  0025c	83 e0 04	 and	 eax, 4
  0025f	74 41		 je	 SHORT $LN20@Polyobj_cl
  00261	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00264	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0026a	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00270	75 30		 jne	 SHORT $LN20@Polyobj_cl

; 1094 : 						P_ProcessSpecialSector(mo->player, mo->subsector->sector, po->lines[0]->backsector);

  00272	b8 04 00 00 00	 mov	 eax, 4
  00277	6b c8 00	 imul	 ecx, eax, 0
  0027a	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0027d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00280	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00283	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00286	52		 push	 edx
  00287	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  0028a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0028d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028f	52		 push	 edx
  00290	8b 45 dc	 mov	 eax, DWORD PTR _mo$1[ebp]
  00293	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00299	51		 push	 ecx
  0029a	e8 00 00 00 00	 call	 _P_ProcessSpecialSector
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@Polyobj_cl:

; 1095 : 
; 1096 : 					hitflags |= 1;

  002a2	8b 45 f8	 mov	 eax, DWORD PTR _hitflags$[ebp]
  002a5	83 c8 01	 or	 eax, 1
  002a8	89 45 f8	 mov	 DWORD PTR _hitflags$[ebp], eax

; 1097 : 				}

  002ab	e9 ce fe ff ff	 jmp	 $LN8@Polyobj_cl
$LN9@Polyobj_cl:

; 1098 : 			} // end if
; 1099 : 		} // end for (y)

  002b0	e9 5e fe ff ff	 jmp	 $LN5@Polyobj_cl
$LN6@Polyobj_cl:

; 1100 : 	} // end for (x)

  002b5	e9 2b fe ff ff	 jmp	 $LN2@Polyobj_cl
$LN3@Polyobj_cl:

; 1101 : 
; 1102 : 	return hitflags;

  002ba	8b 45 f8	 mov	 eax, DWORD PTR _hitflags$[ebp]
$LN1@Polyobj_cl:

; 1103 : }

  002bd	5f		 pop	 edi
  002be	5e		 pop	 esi
  002bf	5b		 pop	 ebx
  002c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c3	33 cd		 xor	 ecx, ebp
  002c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c3		 ret	 0
_Polyobj_clipThings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_carryThings
_TEXT	SEGMENT
_mo$1 = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_po$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
_Polyobj_carryThings PROC				; COMDAT

; 991  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 992  : 	static INT32 pomovecount = 0;
; 993  : 	INT32 x, y;
; 994  : 
; 995  : 	pomovecount++;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pomovecount@?1??Polyobj_carryThings@@9@9
  0000e	83 c0 01	 add	 eax, 1
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?pomovecount@?1??Polyobj_carryThings@@9@9, eax

; 996  : 
; 997  : 	if (!(po->flags & POF_SOLID))

  00016	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00019	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0001f	83 e1 03	 and	 ecx, 3
  00022	75 05		 jne	 SHORT $LN11@Polyobj_ca

; 998  : 		return;

  00024	e9 b9 01 00 00	 jmp	 $LN3@Polyobj_ca
$LN11@Polyobj_ca:

; 999  : 
; 1000 : 	for (y = po->blockbox[BOXBOTTOM]; y <= po->blockbox[BOXTOP]; ++y)

  00029	b8 04 00 00 00	 mov	 eax, 4
  0002e	c1 e0 00	 shl	 eax, 0
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00034	8b 54 01 78	 mov	 edx, DWORD PTR [ecx+eax+120]
  00038	89 55 f8	 mov	 DWORD PTR _y$[ebp], edx
  0003b	eb 09		 jmp	 SHORT $LN4@Polyobj_ca
$LN2@Polyobj_ca:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@Polyobj_ca:
  00046	b8 04 00 00 00	 mov	 eax, 4
  0004b	6b c8 00	 imul	 ecx, eax, 0
  0004e	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00051	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00054	3b 44 0a 78	 cmp	 eax, DWORD PTR [edx+ecx+120]
  00058	0f 8f 84 01 00
	00		 jg	 $LN3@Polyobj_ca

; 1001 : 	{
; 1002 : 		for (x = po->blockbox[BOXLEFT]; x <= po->blockbox[BOXRIGHT]; ++x)

  0005e	b8 04 00 00 00	 mov	 eax, 4
  00063	d1 e0		 shl	 eax, 1
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00068	8b 54 01 78	 mov	 edx, DWORD PTR [ecx+eax+120]
  0006c	89 55 fc	 mov	 DWORD PTR _x$[ebp], edx
  0006f	eb 09		 jmp	 SHORT $LN7@Polyobj_ca
$LN5@Polyobj_ca:
  00071	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@Polyobj_ca:
  0007a	b8 04 00 00 00	 mov	 eax, 4
  0007f	6b c8 03	 imul	 ecx, eax, 3
  00082	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00085	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00088	3b 44 0a 78	 cmp	 eax, DWORD PTR [edx+ecx+120]
  0008c	0f 8f 4b 01 00
	00		 jg	 $LN6@Polyobj_ca

; 1003 : 		{
; 1004 : 			mobj_t *mo;
; 1005 : 
; 1006 : 			if (x < 0 || y < 0 || x >= bmapwidth || y >= bmapheight)

  00092	83 7d fc 00	 cmp	 DWORD PTR _x$[ebp], 0
  00096	7c 1c		 jl	 SHORT $LN13@Polyobj_ca
  00098	83 7d f8 00	 cmp	 DWORD PTR _y$[ebp], 0
  0009c	7c 16		 jl	 SHORT $LN13@Polyobj_ca
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000a1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  000a7	7d 0b		 jge	 SHORT $LN13@Polyobj_ca
  000a9	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  000ac	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  000b2	7c 02		 jl	 SHORT $LN12@Polyobj_ca
$LN13@Polyobj_ca:

; 1007 : 				continue;

  000b4	eb bb		 jmp	 SHORT $LN5@Polyobj_ca
$LN12@Polyobj_ca:

; 1008 : 
; 1009 : 			mo = blocklinks[y * bmapwidth + x];

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  000b9	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  000c0	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _blocklinks
  000c9	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000cc	89 55 f4	 mov	 DWORD PTR _mo$1[ebp], edx

; 1010 : 
; 1011 : 			for (; mo; mo = mo->bnext)

  000cf	eb 09		 jmp	 SHORT $LN10@Polyobj_ca
$LN8@Polyobj_ca:
  000d1	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  000d4	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  000d7	89 4d f4	 mov	 DWORD PTR _mo$1[ebp], ecx
$LN10@Polyobj_ca:
  000da	83 7d f4 00	 cmp	 DWORD PTR _mo$1[ebp], 0
  000de	0f 84 f4 00 00
	00		 je	 $LN9@Polyobj_ca

; 1012 : 			{
; 1013 : 				if (mo->lastlook == pomovecount)

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  000e7	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  000ed	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?pomovecount@?1??Polyobj_carryThings@@9@9
  000f3	75 02		 jne	 SHORT $LN14@Polyobj_ca

; 1014 : 					continue;

  000f5	eb da		 jmp	 SHORT $LN8@Polyobj_ca
$LN14@Polyobj_ca:

; 1015 : 
; 1016 : 				mo->lastlook = pomovecount;

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pomovecount@?1??Polyobj_carryThings@@9@9
  00100	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx

; 1017 : 
; 1018 : 				// always push players even if not solid
; 1019 : 				if (!((mo->flags & MF_SOLID) || mo->player))

  00106	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00109	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0010c	83 e1 02	 and	 ecx, 2
  0010f	75 0e		 jne	 SHORT $LN15@Polyobj_ca
  00111	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00114	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0011b	75 02		 jne	 SHORT $LN15@Polyobj_ca

; 1020 : 					continue;

  0011d	eb b2		 jmp	 SHORT $LN8@Polyobj_ca
$LN15@Polyobj_ca:

; 1021 : 
; 1022 : 				if (mo->flags & MF_NOCLIP)

  0011f	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00122	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00125	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0012b	74 02		 je	 SHORT $LN16@Polyobj_ca

; 1023 : 					continue;

  0012d	eb a2		 jmp	 SHORT $LN8@Polyobj_ca
$LN16@Polyobj_ca:

; 1024 : 
; 1025 : 				if ((mo->eflags & MFE_VERTICALFLIP) && mo->z + mo->height != po->lines[0]->backsector->floorheight)

  0012f	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00132	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00138	83 e1 20	 and	 ecx, 32			; 00000020H
  0013b	74 29		 je	 SHORT $LN17@Polyobj_ca
  0013d	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00140	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00143	8b 55 f4	 mov	 edx, DWORD PTR _mo$1[ebp]
  00146	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00149	b8 04 00 00 00	 mov	 eax, 4
  0014e	6b d0 00	 imul	 edx, eax, 0
  00151	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00154	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  00157	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  0015a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0015d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0015f	74 05		 je	 SHORT $LN17@Polyobj_ca

; 1026 : 					continue;

  00161	e9 6b ff ff ff	 jmp	 $LN8@Polyobj_ca
$LN17@Polyobj_ca:

; 1027 : 
; 1028 : 				if (!(mo->eflags & MFE_VERTICALFLIP) && mo->z != po->lines[0]->backsector->ceilingheight)

  00166	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00169	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0016f	83 e1 20	 and	 ecx, 32			; 00000020H
  00172	75 24		 jne	 SHORT $LN18@Polyobj_ca
  00174	b8 04 00 00 00	 mov	 eax, 4
  00179	6b c8 00	 imul	 ecx, eax, 0
  0017c	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0017f	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00182	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00185	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00188	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  0018b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0018e	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00191	74 05		 je	 SHORT $LN18@Polyobj_ca

; 1029 : 					continue;

  00193	e9 39 ff ff ff	 jmp	 $LN8@Polyobj_ca
$LN18@Polyobj_ca:

; 1030 : 
; 1031 : 				if (!P_MobjInsidePolyobj(po, mo))

  00198	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  0019b	50		 push	 eax
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _P_MobjInsidePolyobj
  001a5	83 c4 08	 add	 esp, 8
  001a8	85 c0		 test	 eax, eax
  001aa	75 05		 jne	 SHORT $LN19@Polyobj_ca

; 1032 : 					continue;

  001ac	e9 20 ff ff ff	 jmp	 $LN8@Polyobj_ca
$LN19@Polyobj_ca:

; 1033 : 
; 1034 : 				P_TryMove(mo, mo->x+dx, mo->y+dy, true);

  001b1	6a 01		 push	 1
  001b3	8b 45 f4	 mov	 eax, DWORD PTR _mo$1[ebp]
  001b6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001b9	03 4d 10	 add	 ecx, DWORD PTR _dy$[ebp]
  001bc	51		 push	 ecx
  001bd	8b 55 f4	 mov	 edx, DWORD PTR _mo$1[ebp]
  001c0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001c3	03 45 0c	 add	 eax, DWORD PTR _dx$[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR _mo$1[ebp]
  001ca	51		 push	 ecx
  001cb	e8 00 00 00 00	 call	 _P_TryMove
  001d0	83 c4 10	 add	 esp, 16			; 00000010H

; 1035 : 			}

  001d3	e9 f9 fe ff ff	 jmp	 $LN8@Polyobj_ca
$LN9@Polyobj_ca:

; 1036 : 		}

  001d8	e9 94 fe ff ff	 jmp	 $LN5@Polyobj_ca
$LN6@Polyobj_ca:

; 1037 : 	}

  001dd	e9 5b fe ff ff	 jmp	 $LN2@Polyobj_ca
$LN3@Polyobj_ca:

; 1038 : }

  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
_Polyobj_carryThings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_pushThing
_TEXT	SEGMENT
_closest$ = -28						; size = 12
_momy$ = -16						; size = 4
_momx$ = -12						; size = 4
_lineangle$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_line$ = 12						; size = 4
_mo$ = 16						; size = 4
_Polyobj_pushThing PROC					; COMDAT

; 954  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 955  : 	angle_t lineangle;
; 956  : 	fixed_t momx, momy;
; 957  : 	vertex_t closest;
; 958  : 
; 959  : 	// calculate angle of line and subtract 90 degrees to get normal
; 960  : 	lineangle = R_PointToAngle2(0, 0, line->dx, line->dy) - ANGLE_90;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _line$[ebp]
  00016	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00019	51		 push	 ecx
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _line$[ebp]
  0001d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00020	50		 push	 eax
  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 _R_PointToAngle2
  0002a	83 c4 10	 add	 esp, 16			; 00000010H
  0002d	2d 00 00 00 40	 sub	 eax, 1073741824		; 40000000H
  00032	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 961  : 	lineangle >>= ANGLETOFINESHIFT;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00038	c1 e8 13	 shr	 eax, 19			; 00000013H
  0003b	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 962  : 	momx = FixedMul(po->thrust, FINECOSINE(lineangle));

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00047	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0004a	52		 push	 edx
  0004b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0004e	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _FixedMul
  0005a	83 c4 08	 add	 esp, 8
  0005d	89 45 f4	 mov	 DWORD PTR _momx$[ebp], eax

; 963  : 	momy = FixedMul(po->thrust, FINESINE(lineangle));

  00060	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00063	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  0006a	51		 push	 ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0006e	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _FixedMul
  0007a	83 c4 08	 add	 esp, 8
  0007d	89 45 f0	 mov	 DWORD PTR _momy$[ebp], eax

; 964  : 	mo->momx += momx;

  00080	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00083	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00086	03 4d f4	 add	 ecx, DWORD PTR _momx$[ebp]
  00089	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  0008c	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 965  : 	mo->momy += momy;

  0008f	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00092	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00095	03 4d f0	 add	 ecx, DWORD PTR _momy$[ebp]
  00098	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  0009b	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 966  : 
; 967  : 	// Prevent 'sticking'
; 968  : 	P_UnsetThingPosition(mo);

  0009e	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  000a7	83 c4 04	 add	 esp, 4

; 969  : 	P_ClosestPointOnLine(mo->x, mo->y, line, &closest);

  000aa	8d 45 e4	 lea	 eax, DWORD PTR _closest$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  000b1	51		 push	 ecx
  000b2	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  000b5	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000b8	50		 push	 eax
  000b9	8b 4d 10	 mov	 ecx, DWORD PTR _mo$[ebp]
  000bc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _P_ClosestPointOnLine
  000c5	83 c4 10	 add	 esp, 16			; 00000010H

; 970  : 	mo->x = closest.x + FixedMul(mo->radius, FINECOSINE(lineangle));

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  000d1	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000d4	52		 push	 edx
  000d5	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  000d8	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _FixedMul
  000e1	83 c4 08	 add	 esp, 8
  000e4	03 45 e4	 add	 eax, DWORD PTR _closest$[ebp]
  000e7	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  000ea	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 971  : 	mo->y = closest.y + FixedMul(mo->radius, FINESINE(lineangle));

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  000f0	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  000f7	51		 push	 ecx
  000f8	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  000fb	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 _FixedMul
  00104	83 c4 08	 add	 esp, 8
  00107	03 45 e8	 add	 eax, DWORD PTR _closest$[ebp+4]
  0010a	8b 4d 10	 mov	 ecx, DWORD PTR _mo$[ebp]
  0010d	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 972  : 	mo->x += momx;

  00110	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00113	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00116	03 4d f4	 add	 ecx, DWORD PTR _momx$[ebp]
  00119	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  0011c	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 973  : 	mo->y += momy;

  0011f	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00122	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00125	03 4d f0	 add	 ecx, DWORD PTR _momy$[ebp]
  00128	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  0012b	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 974  : 	P_SetThingPosition(mo);

  0012e	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 _P_SetThingPosition
  00137	83 c4 04	 add	 esp, 4

; 975  : 
; 976  : 	// if object doesn't fit at desired location, possibly hurt it
; 977  : 	if (po->damage && (mo->flags & MF_SHOOTABLE))

  0013a	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0013d	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00144	74 43		 je	 SHORT $LN2@Polyobj_pu
  00146	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00149	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0014c	83 e1 04	 and	 ecx, 4
  0014f	74 38		 je	 SHORT $LN2@Polyobj_pu

; 978  : 	{
; 979  : 		P_CheckPosition(mo, mo->x + momx, mo->y + momy);

  00151	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00154	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00157	03 4d f0	 add	 ecx, DWORD PTR _momy$[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 10	 mov	 edx, DWORD PTR _mo$[ebp]
  0015e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00161	03 45 f4	 add	 eax, DWORD PTR _momx$[ebp]
  00164	50		 push	 eax
  00165	8b 4d 10	 mov	 ecx, DWORD PTR _mo$[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 _P_CheckPosition
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 980  : 		mo->floorz = tmfloorz;

  00171	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  0017a	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 981  : 		mo->ceilingz = tmceilingz;

  0017d	8b 45 10	 mov	 eax, DWORD PTR _mo$[ebp]
  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  00186	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
$LN2@Polyobj_pu:

; 982  : 	}
; 983  : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018f	33 cd		 xor	 ecx, ebp
  00191	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
_Polyobj_pushThing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_untouched
_TEXT	SEGMENT
tv134 = -112						; size = 4
tv93 = -108						; size = 4
tv85 = -104						; size = 4
tv76 = -100						; size = 4
tv68 = -96						; size = 4
_ptmbbox$ = -28						; size = 16
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ld$ = 8						; size = 4
_mo$ = 12						; size = 4
_Polyobj_untouched PROC					; COMDAT

; 935  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 936  : 	fixed_t x, y, ptmbbox[4];
; 937  : 
; 938  : 	return

  00013	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00016	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00019	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00022	03 42 40	 add	 eax, DWORD PTR [edx+64]
  00025	89 45 a0	 mov	 DWORD PTR tv68[ebp], eax
  00028	b9 04 00 00 00	 mov	 ecx, 4
  0002d	6b d1 03	 imul	 edx, ecx, 3
  00030	8b 45 a0	 mov	 eax, DWORD PTR tv68[ebp]
  00033	89 44 15 e4	 mov	 DWORD PTR _ptmbbox$[ebp+edx], eax
  00037	b9 04 00 00 00	 mov	 ecx, 4
  0003c	d1 e1		 shl	 ecx, 1
  0003e	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  00041	8b 45 a0	 mov	 eax, DWORD PTR tv68[ebp]
  00044	3b 44 0a 1c	 cmp	 eax, DWORD PTR [edx+ecx+28]
  00048	0f 8e b7 00 00
	00		 jle	 $LN3@Polyobj_un
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00051	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  00054	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00057	89 55 9c	 mov	 DWORD PTR tv76[ebp], edx
  0005a	b8 04 00 00 00	 mov	 eax, 4
  0005f	d1 e0		 shl	 eax, 1
  00061	8b 4d 9c	 mov	 ecx, DWORD PTR tv76[ebp]
  00064	89 4c 05 e4	 mov	 DWORD PTR _ptmbbox$[ebp+eax], ecx
  00068	ba 04 00 00 00	 mov	 edx, 4
  0006d	6b c2 03	 imul	 eax, edx, 3
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00073	8b 55 9c	 mov	 edx, DWORD PTR tv76[ebp]
  00076	3b 54 01 1c	 cmp	 edx, DWORD PTR [ecx+eax+28]
  0007a	0f 8d 85 00 00
	00		 jge	 $LN3@Polyobj_un
  00080	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00083	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00086	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  00089	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0008c	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  0008f	03 42 40	 add	 eax, DWORD PTR [edx+64]
  00092	89 45 98	 mov	 DWORD PTR tv85[ebp], eax
  00095	b9 04 00 00 00	 mov	 ecx, 4
  0009a	6b d1 00	 imul	 edx, ecx, 0
  0009d	8b 45 98	 mov	 eax, DWORD PTR tv85[ebp]
  000a0	89 44 15 e4	 mov	 DWORD PTR _ptmbbox$[ebp+edx], eax
  000a4	b9 04 00 00 00	 mov	 ecx, 4
  000a9	c1 e1 00	 shl	 ecx, 0
  000ac	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000af	8b 45 98	 mov	 eax, DWORD PTR tv85[ebp]
  000b2	3b 44 0a 1c	 cmp	 eax, DWORD PTR [edx+ecx+28]
  000b6	7e 4d		 jle	 SHORT $LN3@Polyobj_un
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  000bb	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  000be	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000c1	89 55 94	 mov	 DWORD PTR tv93[ebp], edx
  000c4	b8 04 00 00 00	 mov	 eax, 4
  000c9	c1 e0 00	 shl	 eax, 0
  000cc	8b 4d 94	 mov	 ecx, DWORD PTR tv93[ebp]
  000cf	89 4c 05 e4	 mov	 DWORD PTR _ptmbbox$[ebp+eax], ecx
  000d3	ba 04 00 00 00	 mov	 edx, 4
  000d8	6b c2 00	 imul	 eax, edx, 0
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  000de	8b 55 94	 mov	 edx, DWORD PTR tv93[ebp]
  000e1	3b 54 01 1c	 cmp	 edx, DWORD PTR [ecx+eax+28]
  000e5	7d 1e		 jge	 SHORT $LN3@Polyobj_un
  000e7	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000ea	50		 push	 eax
  000eb	8d 4d e4	 lea	 ecx, DWORD PTR _ptmbbox$[ebp]
  000ee	51		 push	 ecx
  000ef	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  000f4	83 c4 08	 add	 esp, 8
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	75 09		 jne	 SHORT $LN3@Polyobj_un
  000fc	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
  00103	eb 07		 jmp	 SHORT $LN4@Polyobj_un
$LN3@Polyobj_un:
  00105	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
$LN4@Polyobj_un:
  0010c	8b 45 90	 mov	 eax, DWORD PTR tv134[ebp]

; 939  : 		(ptmbbox[BOXRIGHT]  = (x = mo->x) + mo->radius) <= ld->bbox[BOXLEFT]   ||
; 940  : 		(ptmbbox[BOXLEFT]   =           x - mo->radius) >= ld->bbox[BOXRIGHT]  ||
; 941  : 		(ptmbbox[BOXTOP]    = (y = mo->y) + mo->radius) <= ld->bbox[BOXBOTTOM] ||
; 942  : 		(ptmbbox[BOXBOTTOM] =           y - mo->radius) >= ld->bbox[BOXTOP]    ||
; 943  : 		P_BoxOnLineSide(ptmbbox, ld) != -1;
; 944  : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
_Polyobj_untouched ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_removeFromBlockmap
_TEXT	SEGMENT
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_blockbox$ = -8						; size = 4
_rover$ = -4						; size = 4
_po$ = 8						; size = 4
_Polyobj_removeFromBlockmap PROC			; COMDAT

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 891  : 	polymaplink_t *rover;
; 892  : 	fixed_t *blockbox = po->blockbox;

  00009	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0000c	83 c0 78	 add	 eax, 120		; 00000078H
  0000f	89 45 f8	 mov	 DWORD PTR _blockbox$[ebp], eax

; 893  : 	INT32 x, y;
; 894  : 
; 895  : 	// don't bother trying to unlink one that's not linked
; 896  : 	if (!po->linked)

  00012	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00015	0f b6 88 88 00
	00 00		 movzx	 ecx, BYTE PTR [eax+136]
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 05		 jne	 SHORT $LN10@Polyobj_re

; 897  : 		return;

  00020	e9 eb 00 00 00	 jmp	 $LN1@Polyobj_re
$LN10@Polyobj_re:

; 898  : 
; 899  : 	// search all cells the polyobject touches
; 900  : 	for (y = blockbox[BOXBOTTOM]; y <= blockbox[BOXTOP]; ++y)

  00025	b8 04 00 00 00	 mov	 eax, 4
  0002a	c1 e0 00	 shl	 eax, 0
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00030	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00033	89 55 f0	 mov	 DWORD PTR _y$[ebp], edx
  00036	eb 09		 jmp	 SHORT $LN4@Polyobj_re
$LN2@Polyobj_re:
  00038	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0003b	83 c0 01	 add	 eax, 1
  0003e	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@Polyobj_re:
  00041	b8 04 00 00 00	 mov	 eax, 4
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f8	 mov	 edx, DWORD PTR _blockbox$[ebp]
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0004f	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  00052	0f 8f ae 00 00
	00		 jg	 $LN3@Polyobj_re

; 901  : 	{
; 902  : 		for (x = blockbox[BOXLEFT]; x <= blockbox[BOXRIGHT]; ++x)

  00058	b8 04 00 00 00	 mov	 eax, 4
  0005d	d1 e0		 shl	 eax, 1
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00062	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00065	89 55 f4	 mov	 DWORD PTR _x$[ebp], edx
  00068	eb 09		 jmp	 SHORT $LN7@Polyobj_re
$LN5@Polyobj_re:
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0006d	83 c0 01	 add	 eax, 1
  00070	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
$LN7@Polyobj_re:
  00073	b8 04 00 00 00	 mov	 eax, 4
  00078	6b c8 03	 imul	 ecx, eax, 3
  0007b	8b 55 f8	 mov	 edx, DWORD PTR _blockbox$[ebp]
  0007e	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00081	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  00084	7f 7b		 jg	 SHORT $LN6@Polyobj_re

; 903  : 		{
; 904  : 			if (!(x < 0 || y < 0 || x >= bmapwidth || y >= bmapheight))

  00086	83 7d f4 00	 cmp	 DWORD PTR _x$[ebp], 0
  0008a	7c 70		 jl	 SHORT $LN11@Polyobj_re
  0008c	83 7d f0 00	 cmp	 DWORD PTR _y$[ebp], 0
  00090	7c 6a		 jl	 SHORT $LN11@Polyobj_re
  00092	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00095	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  0009b	7d 5f		 jge	 SHORT $LN11@Polyobj_re
  0009d	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  000a0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  000a6	7d 54		 jge	 SHORT $LN11@Polyobj_re

; 905  : 			{
; 906  : 				rover = polyblocklinks[y * bmapwidth + x];

  000a8	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  000ab	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  000b2	03 45 f4	 add	 eax, DWORD PTR _x$[ebp]
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _polyblocklinks
  000bb	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000be	89 55 fc	 mov	 DWORD PTR _rover$[ebp], edx
$LN8@Polyobj_re:

; 907  : 
; 908  : 				while (rover && rover->po != po)

  000c1	83 7d fc 00	 cmp	 DWORD PTR _rover$[ebp], 0
  000c5	74 15		 je	 SHORT $LN9@Polyobj_re
  000c7	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  000ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000cd	3b 4d 08	 cmp	 ecx, DWORD PTR _po$[ebp]
  000d0	74 0a		 je	 SHORT $LN9@Polyobj_re

; 909  : 					rover = (polymaplink_t *)(rover->link.next);

  000d2	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
  000da	eb e5		 jmp	 SHORT $LN8@Polyobj_re
$LN9@Polyobj_re:

; 910  : 
; 911  : 				// polyobject not in this cell? go on to next.
; 912  : 				if (!rover)

  000dc	83 7d fc 00	 cmp	 DWORD PTR _rover$[ebp], 0
  000e0	75 02		 jne	 SHORT $LN12@Polyobj_re

; 913  : 					continue;

  000e2	eb 86		 jmp	 SHORT $LN5@Polyobj_re
$LN12@Polyobj_re:

; 914  : 
; 915  : 				// remove this link from the blockmap and put it on the freelist
; 916  : 				M_DLListRemove(&rover->link);

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _M_DLListRemove
  000ed	83 c4 04	 add	 esp, 4

; 917  : 				Polyobj_putLink(rover);

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _Polyobj_putLink
  000f9	83 c4 04	 add	 esp, 4
$LN11@Polyobj_re:

; 918  : 			}
; 919  : 		}

  000fc	e9 69 ff ff ff	 jmp	 $LN5@Polyobj_re
$LN6@Polyobj_re:

; 920  : 	}

  00101	e9 32 ff ff ff	 jmp	 $LN2@Polyobj_re
$LN3@Polyobj_re:

; 921  : 
; 922  : 	po->linked = false;

  00106	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00109	c6 80 88 00 00
	00 00		 mov	 BYTE PTR [eax+136], 0
$LN1@Polyobj_re:

; 923  : }

  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_Polyobj_removeFromBlockmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_linkToBlockmap
_TEXT	SEGMENT
_l$1 = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_blockbox$ = -4						; size = 4
_po$ = 8						; size = 4
_Polyobj_linkToBlockmap PROC				; COMDAT

; 840  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 841  : 	fixed_t *blockbox = po->blockbox;

  00009	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0000c	83 c0 78	 add	 eax, 120		; 00000078H
  0000f	89 45 fc	 mov	 DWORD PTR _blockbox$[ebp], eax

; 842  : 	size_t i;
; 843  : 	fixed_t x, y;
; 844  : 
; 845  : 	// never link a bad polyobject or a polyobject already linked
; 846  : 	if (po->isBad || po->linked)

  00012	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00015	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 0e		 jne	 SHORT $LN12@Polyobj_li
  00020	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00023	0f b6 88 88 00
	00 00		 movzx	 ecx, BYTE PTR [eax+136]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 05		 je	 SHORT $LN11@Polyobj_li
$LN12@Polyobj_li:

; 847  : 		return;

  0002e	e9 1e 02 00 00	 jmp	 $LN1@Polyobj_li
$LN11@Polyobj_li:

; 848  : 
; 849  : 	// 2/26/06: start line box with values of first vertex, not INT32_MIN/INT32_MAX
; 850  : 	blockbox[BOXLEFT]   = blockbox[BOXRIGHT] = po->vertices[0]->x;

  00033	b8 04 00 00 00	 mov	 eax, 4
  00038	6b c8 00	 imul	 ecx, eax, 0
  0003b	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0003e	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00041	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00044	ba 04 00 00 00	 mov	 edx, 4
  00049	6b c2 03	 imul	 eax, edx, 3
  0004c	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  0004f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00051	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
  00054	ba 04 00 00 00	 mov	 edx, 4
  00059	6b c2 03	 imul	 eax, edx, 3
  0005c	b9 04 00 00 00	 mov	 ecx, 4
  00061	d1 e1		 shl	 ecx, 1
  00063	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  00066	8b 75 fc	 mov	 esi, DWORD PTR _blockbox$[ebp]
  00069	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0006c	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 851  : 	blockbox[BOXBOTTOM] = blockbox[BOXTOP]   = po->vertices[0]->y;

  0006f	b8 04 00 00 00	 mov	 eax, 4
  00074	6b c8 00	 imul	 ecx, eax, 0
  00077	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0007a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0007d	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00080	ba 04 00 00 00	 mov	 edx, 4
  00085	6b c2 00	 imul	 eax, edx, 0
  00088	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  0008b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0008e	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
  00091	ba 04 00 00 00	 mov	 edx, 4
  00096	6b c2 00	 imul	 eax, edx, 0
  00099	b9 04 00 00 00	 mov	 ecx, 4
  0009e	c1 e1 00	 shl	 ecx, 0
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  000a4	8b 75 fc	 mov	 esi, DWORD PTR _blockbox$[ebp]
  000a7	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  000aa	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 852  : 
; 853  : 	// add all vertices to the bounding box
; 854  : 	for (i = 1; i < po->numVertices; ++i)

  000ad	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000b4	eb 09		 jmp	 SHORT $LN4@Polyobj_li
$LN2@Polyobj_li:
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_li:
  000bf	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000c5	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  000c8	73 2d		 jae	 SHORT $LN3@Polyobj_li

; 855  : 		M_AddToBox(blockbox, po->vertices[i]->x, po->vertices[i]->y);

  000ca	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000cd	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d0	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000d3	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d9	51		 push	 ecx
  000da	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000dd	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000e3	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  000e6	8b 02		 mov	 eax, DWORD PTR [edx]
  000e8	50		 push	 eax
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 _M_AddToBox
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	eb bf		 jmp	 SHORT $LN2@Polyobj_li
$LN3@Polyobj_li:

; 856  : 
; 857  : 	// adjust bounding box relative to blockmap
; 858  : 	blockbox[BOXRIGHT]  = (unsigned)(blockbox[BOXRIGHT]  - bmaporgx) >> MAPBLOCKSHIFT;

  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 03	 imul	 ecx, eax, 3
  000ff	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  00102	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00105	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgx
  0010b	c1 e8 17	 shr	 eax, 23			; 00000017H
  0010e	b9 04 00 00 00	 mov	 ecx, 4
  00113	6b d1 03	 imul	 edx, ecx, 3
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00119	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 859  : 	blockbox[BOXLEFT]   = (unsigned)(blockbox[BOXLEFT]   - bmaporgx) >> MAPBLOCKSHIFT;

  0011c	b8 04 00 00 00	 mov	 eax, 4
  00121	d1 e0		 shl	 eax, 1
  00123	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00126	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00129	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  0012f	c1 ea 17	 shr	 edx, 23			; 00000017H
  00132	b8 04 00 00 00	 mov	 eax, 4
  00137	d1 e0		 shl	 eax, 1
  00139	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  0013c	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 860  : 	blockbox[BOXTOP]    = (unsigned)(blockbox[BOXTOP]    - bmaporgy) >> MAPBLOCKSHIFT;

  0013f	b8 04 00 00 00	 mov	 eax, 4
  00144	6b c8 00	 imul	 ecx, eax, 0
  00147	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  0014a	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0014d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bmaporgy
  00153	c1 e8 17	 shr	 eax, 23			; 00000017H
  00156	b9 04 00 00 00	 mov	 ecx, 4
  0015b	6b d1 00	 imul	 edx, ecx, 0
  0015e	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00161	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 861  : 	blockbox[BOXBOTTOM] = (unsigned)(blockbox[BOXBOTTOM] - bmaporgy) >> MAPBLOCKSHIFT;

  00164	b8 04 00 00 00	 mov	 eax, 4
  00169	c1 e0 00	 shl	 eax, 0
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  0016f	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00172	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  00178	c1 ea 17	 shr	 edx, 23			; 00000017H
  0017b	b8 04 00 00 00	 mov	 eax, 4
  00180	c1 e0 00	 shl	 eax, 0
  00183	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00186	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 862  : 
; 863  : 	// link polyobject to every block its bounding box intersects
; 864  : 	for (y = blockbox[BOXBOTTOM]; y <= blockbox[BOXTOP]; ++y)

  00189	b8 04 00 00 00	 mov	 eax, 4
  0018e	c1 e0 00	 shl	 eax, 0
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  00194	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00197	89 55 f0	 mov	 DWORD PTR _y$[ebp], edx
  0019a	eb 09		 jmp	 SHORT $LN7@Polyobj_li
$LN5@Polyobj_li:
  0019c	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0019f	83 c0 01	 add	 eax, 1
  001a2	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN7@Polyobj_li:
  001a5	b8 04 00 00 00	 mov	 eax, 4
  001aa	6b c8 00	 imul	 ecx, eax, 0
  001ad	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  001b0	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  001b3	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  001b6	0f 8f 8b 00 00
	00		 jg	 $LN6@Polyobj_li

; 865  : 	{
; 866  : 		for (x = blockbox[BOXLEFT]; x <= blockbox[BOXRIGHT]; ++x)

  001bc	b8 04 00 00 00	 mov	 eax, 4
  001c1	d1 e0		 shl	 eax, 1
  001c3	8b 4d fc	 mov	 ecx, DWORD PTR _blockbox$[ebp]
  001c6	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001c9	89 55 f4	 mov	 DWORD PTR _x$[ebp], edx
  001cc	eb 09		 jmp	 SHORT $LN10@Polyobj_li
$LN8@Polyobj_li:
  001ce	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  001d1	83 c0 01	 add	 eax, 1
  001d4	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
$LN10@Polyobj_li:
  001d7	b8 04 00 00 00	 mov	 eax, 4
  001dc	6b c8 03	 imul	 ecx, eax, 3
  001df	8b 55 fc	 mov	 edx, DWORD PTR _blockbox$[ebp]
  001e2	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  001e5	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  001e8	7f 58		 jg	 SHORT $LN9@Polyobj_li

; 867  : 		{
; 868  : 			if (!(x < 0 || y < 0 || x >= bmapwidth || y >= bmapheight))

  001ea	83 7d f4 00	 cmp	 DWORD PTR _x$[ebp], 0
  001ee	7c 50		 jl	 SHORT $LN13@Polyobj_li
  001f0	83 7d f0 00	 cmp	 DWORD PTR _y$[ebp], 0
  001f4	7c 4a		 jl	 SHORT $LN13@Polyobj_li
  001f6	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  001f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  001ff	7d 3f		 jge	 SHORT $LN13@Polyobj_li
  00201	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00204	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  0020a	7d 34		 jge	 SHORT $LN13@Polyobj_li

; 869  : 			{
; 870  : 				polymaplink_t  *l = Polyobj_getLink();

  0020c	e8 00 00 00 00	 call	 _Polyobj_getLink
  00211	89 45 ec	 mov	 DWORD PTR _l$1[ebp], eax

; 871  : 
; 872  : 				l->po = po;

  00214	8b 45 ec	 mov	 eax, DWORD PTR _l$1[ebp]
  00217	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0021a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 873  : 
; 874  : 				M_DLListInsert(&l->link,

  0021d	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00220	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  00227	03 45 f4	 add	 eax, DWORD PTR _x$[ebp]
  0022a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _polyblocklinks
  00230	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00233	52		 push	 edx
  00234	8b 45 ec	 mov	 eax, DWORD PTR _l$1[ebp]
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _M_DLListInsert
  0023d	83 c4 08	 add	 esp, 8
$LN13@Polyobj_li:

; 875  : 							(mdllistitem_t **)(&polyblocklinks[y*bmapwidth + x]));
; 876  : 			}
; 877  : 		}

  00240	eb 8c		 jmp	 SHORT $LN8@Polyobj_li
$LN9@Polyobj_li:

; 878  : 	}

  00242	e9 55 ff ff ff	 jmp	 $LN5@Polyobj_li
$LN6@Polyobj_li:

; 879  : 
; 880  : 	po->linked = true;

  00247	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0024a	c6 80 88 00 00
	00 01		 mov	 BYTE PTR [eax+136], 1
$LN1@Polyobj_li:

; 881  : }

  00251	5f		 pop	 edi
  00252	5e		 pop	 esi
  00253	5b		 pop	 ebx
  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c3		 ret	 0
_Polyobj_linkToBlockmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_putLink
_TEXT	SEGMENT
_l$ = 8							; size = 4
_Polyobj_putLink PROC					; COMDAT

; 825  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 826  : 	memset(l, 0, sizeof(*l));

  00009	6a 0c		 push	 12			; 0000000cH
  0000b	6a 00		 push	 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _l$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 827  : 	l->link.next = (mdllistitem_t *)bmap_freelist;

  00019	8b 45 08	 mov	 eax, DWORD PTR _l$[ebp]
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bmap_freelist
  00022	89 08		 mov	 DWORD PTR [eax], ecx

; 828  : 	bmap_freelist = l;

  00024	8b 45 08	 mov	 eax, DWORD PTR _l$[ebp]
  00027	a3 00 00 00 00	 mov	 DWORD PTR _bmap_freelist, eax

; 829  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_Polyobj_putLink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_getLink
_TEXT	SEGMENT
_l$ = -4						; size = 4
_Polyobj_getLink PROC					; COMDAT

; 802  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 803  : 	polymaplink_t *l;
; 804  : 
; 805  : 	if (bmap_freelist)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bmap_freelist, 0
  00010	74 15		 je	 SHORT $LN2@Polyobj_ge

; 806  : 	{
; 807  : 		l = bmap_freelist;

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmap_freelist
  00017	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax

; 808  : 		bmap_freelist = (polymaplink_t *)(l->link.next);

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 0d 00 00 00
	00		 mov	 DWORD PTR _bmap_freelist, ecx

; 809  : 	}

  00025	eb 23		 jmp	 SHORT $LN3@Polyobj_ge
$LN2@Polyobj_ge:

; 810  : 	else
; 811  : 	{
; 812  : 		l = Z_Malloc(sizeof(*l), PU_LEVEL, NULL);

  00027	6a 00		 push	 0
  00029	6a 00		 push	 0
  0002b	6a 32		 push	 50			; 00000032H
  0002d	6a 0c		 push	 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 _Z_MallocAlign
  00034	83 c4 10	 add	 esp, 16			; 00000010H
  00037	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax

; 813  : 		memset(l, 0, sizeof(*l));

  0003a	6a 0c		 push	 12			; 0000000cH
  0003c	6a 00		 push	 0
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memset
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Polyobj_ge:

; 814  : 	}
; 815  : 
; 816  : 	return l;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]

; 817  : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_Polyobj_getLink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_removeFromSubsec
_TEXT	SEGMENT
_po$ = 8						; size = 4
_Polyobj_removeFromSubsec PROC				; COMDAT

; 786  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 787  : 	if (po->attached)

  00009	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0000c	0f b6 48 74	 movzx	 ecx, BYTE PTR [eax+116]
  00010	85 c9		 test	 ecx, ecx
  00012	74 13		 je	 SHORT $LN2@Polyobj_re

; 788  : 	{
; 789  : 		M_DLListRemove(&po->link);

  00014	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _M_DLListRemove
  0001d	83 c4 04	 add	 esp, 4

; 790  : 		po->attached = false;

  00020	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00023	c6 40 74 00	 mov	 BYTE PTR [eax+116], 0
$LN2@Polyobj_re:

; 791  : 	}
; 792  : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_Polyobj_removeFromSubsec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_moveToSpawnSpot
_TEXT	SEGMENT
_i$ = -36						; size = 4
_sspot$ = -32						; size = 12
_dist$ = -20						; size = 12
_po$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_anchor$ = 8						; size = 4
_Polyobj_moveToSpawnSpot PROC				; COMDAT

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 697  : 	polyobj_t *po;
; 698  : 	vertex_t  dist, sspot;
; 699  : 	size_t i;
; 700  : 
; 701  : 	if (!(po = Polyobj_GetForNum(anchor->angle)))

  00013	8b 45 08	 mov	 eax, DWORD PTR _anchor$[ebp]
  00016	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f8	 mov	 DWORD PTR _po$[ebp], eax
  00026	83 7d f8 00	 cmp	 DWORD PTR _po$[ebp], 0
  0002a	75 1a		 jne	 SHORT $LN8@Polyobj_mo

; 702  : 	{
; 703  : 		CONS_Printf("bad polyobject %d for anchor point\n", anchor->angle);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _anchor$[ebp]
  0002f	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00033	51		 push	 ecx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LHDOOFDP@bad?5polyobject?5?$CFd?5for?5anchor?5po@
  00039	e8 00 00 00 00	 call	 _CONS_Printf
  0003e	83 c4 08	 add	 esp, 8

; 704  : 		return;

  00041	e9 0b 01 00 00	 jmp	 $LN1@Polyobj_mo
$LN8@Polyobj_mo:

; 705  : 	}
; 706  : 
; 707  : 	// don't move any bad polyobject that may have gotten through
; 708  : 	if (po->isBad)

  00046	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00049	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00050	85 c9		 test	 ecx, ecx
  00052	74 05		 je	 SHORT $LN9@Polyobj_mo

; 709  : 		return;

  00054	e9 f8 00 00 00	 jmp	 $LN1@Polyobj_mo
$LN9@Polyobj_mo:

; 710  : 
; 711  : 	// don't move any polyobject more than once
; 712  : 	if (po->attached)

  00059	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0005c	0f b6 48 74	 movzx	 ecx, BYTE PTR [eax+116]
  00060	85 c9		 test	 ecx, ecx
  00062	74 19		 je	 SHORT $LN10@Polyobj_mo

; 713  : 	{
; 714  : 		CONS_Printf("polyobj %d has more than one anchor\n", po->id);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00067	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006a	51		 push	 ecx
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NOFEPMCH@polyobj?5?$CFd?5has?5more?5than?5one?5an@
  00070	e8 00 00 00 00	 call	 _CONS_Printf
  00075	83 c4 08	 add	 esp, 8

; 715  : 		return;

  00078	e9 d4 00 00 00	 jmp	 $LN1@Polyobj_mo
$LN10@Polyobj_mo:

; 716  : 	}
; 717  : 
; 718  : 	sspot.x = po->spawnSpot.x;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00080	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00083	89 4d e0	 mov	 DWORD PTR _sspot$[ebp], ecx

; 719  : 	sspot.y = po->spawnSpot.y;

  00086	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00089	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  0008c	89 4d e4	 mov	 DWORD PTR _sspot$[ebp+4], ecx

; 720  : 
; 721  : 	// calculate distance from anchor to spawn spot
; 722  : 	dist.x = (anchor->x << FRACBITS) - sspot.x;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _anchor$[ebp]
  00092	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00095	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00098	2b 4d e0	 sub	 ecx, DWORD PTR _sspot$[ebp]
  0009b	89 4d ec	 mov	 DWORD PTR _dist$[ebp], ecx

; 723  : 	dist.y = (anchor->y << FRACBITS) - sspot.y;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _anchor$[ebp]
  000a1	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000a5	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000a8	2b 4d e4	 sub	 ecx, DWORD PTR _sspot$[ebp+4]
  000ab	89 4d f0	 mov	 DWORD PTR _dist$[ebp+4], ecx

; 724  : 
; 725  : 	// update linedef bounding boxes
; 726  : 	for (i = 0; i < po->numLines; ++i)

  000ae	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b5	eb 09		 jmp	 SHORT $LN4@Polyobj_mo
$LN2@Polyobj_mo:
  000b7	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_mo:
  000c0	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  000c3	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c6	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  000c9	73 1e		 jae	 SHORT $LN3@Polyobj_mo

; 727  : 		Polyobj_bboxSub(po->lines[i]->bbox, &dist);

  000cb	8d 45 ec	 lea	 eax, DWORD PTR _dist$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  000d2	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000d5	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  000d8	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  000db	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 _Polyobj_bboxSub
  000e4	83 c4 08	 add	 esp, 8
  000e7	eb ce		 jmp	 SHORT $LN2@Polyobj_mo
$LN3@Polyobj_mo:

; 728  : 
; 729  : 	// translate vertices and record original coordinates relative to spawn spot
; 730  : 	for (i = 0; i < po->numVertices; ++i)

  000e9	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f0	eb 09		 jmp	 SHORT $LN7@Polyobj_mo
$LN5@Polyobj_mo:
  000f2	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Polyobj_mo:
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  000fe	8b 4d dc	 mov	 ecx, DWORD PTR _i$[ebp]
  00101	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00104	73 3f		 jae	 SHORT $LN6@Polyobj_mo

; 731  : 	{
; 732  : 		Polyobj_vecSub(po->vertices[i], &dist);

  00106	8d 45 ec	 lea	 eax, DWORD PTR _dist$[ebp]
  00109	50		 push	 eax
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  0010d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00110	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00113	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 _Polyobj_vecSub
  0011c	83 c4 08	 add	 esp, 8

; 733  : 
; 734  : 		Polyobj_vecSub2(&(po->origVerts[i]), po->vertices[i], &sspot);

  0011f	8d 45 e0	 lea	 eax, DWORD PTR _sspot$[ebp]
  00122	50		 push	 eax
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  00126	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00129	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  0012c	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0012f	51		 push	 ecx
  00130	6b 55 dc 0c	 imul	 edx, DWORD PTR _i$[ebp], 12
  00134	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00137	03 50 2c	 add	 edx, DWORD PTR [eax+44]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 _Polyobj_vecSub2
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 735  : 	}

  00143	eb ad		 jmp	 SHORT $LN5@Polyobj_mo
$LN6@Polyobj_mo:

; 736  : 
; 737  : 	// attach to subsector
; 738  : 	Polyobj_attachToSubsec(po);

  00145	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _Polyobj_attachToSubsec
  0014e	83 c4 04	 add	 esp, 4
$LN1@Polyobj_mo:

; 739  : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00157	33 cd		 xor	 ecx, ebp
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
_Polyobj_moveToSpawnSpot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_attachToSubsec
_TEXT	SEGMENT
_i$ = -20						; size = 4
_numVertices$ = -16					; size = 4
_center_y$ = -12					; size = 4
_center_x$ = -8						; size = 4
_ss$ = -4						; size = 4
_po$ = 8						; size = 4
_Polyobj_attachToSubsec PROC				; COMDAT

; 747  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 748  : 	subsector_t  *ss;
; 749  : 	fixed_t center_x = 0, center_y = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _center_x$[ebp], 0
  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _center_y$[ebp], 0

; 750  : 	fixed_t numVertices;
; 751  : 	size_t i;
; 752  : 
; 753  : 	// never attach a bad polyobject
; 754  : 	if (po->isBad)

  00017	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001a	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00021	85 c9		 test	 ecx, ecx
  00023	74 05		 je	 SHORT $LN5@Polyobj_at

; 755  : 		return;

  00025	e9 b3 00 00 00	 jmp	 $LN1@Polyobj_at
$LN5@Polyobj_at:

; 756  : 
; 757  : 	numVertices = (fixed_t)(po->numVertices*FRACUNIT);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0002d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00030	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00033	89 4d f0	 mov	 DWORD PTR _numVertices$[ebp], ecx

; 758  : 
; 759  : 	for (i = 0; i < po->numVertices; ++i)

  00036	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@Polyobj_at
$LN2@Polyobj_at:
  0003f	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_at:
  00048	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0004e	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00051	73 45		 jae	 SHORT $LN3@Polyobj_at

; 760  : 	{
; 761  : 		center_x += FixedDiv(po->vertices[i]->x, numVertices);

  00053	8b 45 f0	 mov	 eax, DWORD PTR _numVertices$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0005a	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0005d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00060	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _FixedDiv
  0006b	83 c4 08	 add	 esp, 8
  0006e	03 45 f8	 add	 eax, DWORD PTR _center_x$[ebp]
  00071	89 45 f8	 mov	 DWORD PTR _center_x$[ebp], eax

; 762  : 		center_y += FixedDiv(po->vertices[i]->y, numVertices);

  00074	8b 45 f0	 mov	 eax, DWORD PTR _numVertices$[ebp]
  00077	50		 push	 eax
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0007b	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00081	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00084	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _FixedDiv
  0008d	83 c4 08	 add	 esp, 8
  00090	03 45 f4	 add	 eax, DWORD PTR _center_y$[ebp]
  00093	89 45 f4	 mov	 DWORD PTR _center_y$[ebp], eax

; 763  : 	}

  00096	eb a7		 jmp	 SHORT $LN2@Polyobj_at
$LN3@Polyobj_at:

; 764  : 
; 765  : 	po->centerPt.x = center_x;

  00098	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _center_x$[ebp]
  0009e	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 766  : 	po->centerPt.y = center_y;

  000a1	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR _center_y$[ebp]
  000a7	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 767  : 
; 768  : 	ss = R_PointInSubsector(po->centerPt.x, po->centerPt.y);

  000aa	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000ad	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000b0	51		 push	 ecx
  000b1	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000b4	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _R_PointInSubsector
  000bd	83 c4 08	 add	 esp, 8
  000c0	89 45 fc	 mov	 DWORD PTR _ss$[ebp], eax

; 769  : 
; 770  : 	M_DLListInsert(&po->link, (mdllistitem_t **)(void *)(&ss->polyList));

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _ss$[ebp]
  000c6	83 c0 08	 add	 eax, 8
  000c9	50		 push	 eax
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _M_DLListInsert
  000d3	83 c4 08	 add	 esp, 8

; 771  : 
; 772  : #ifdef R_LINKEDPORTALS
; 773  : 	// set spawnSpot's groupid for correct portal sound behavior
; 774  : 	po->spawnSpot.groupid = ss->sector->groupid;
; 775  : #endif
; 776  : 
; 777  : 	po->attached = true;

  000d6	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000d9	c6 40 74 01	 mov	 BYTE PTR [eax+116], 1
$LN1@Polyobj_at:

; 778  : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_Polyobj_attachToSubsec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_spawnPolyObj
_TEXT	SEGMENT
_hashkey$1 = -28					; size = 4
_parent$2 = -24						; size = 2
_parentID$3 = -20					; size = 4
_polyID$4 = -16						; size = 4
_seg$5 = -12						; size = 4
_po$ = -8						; size = 4
_i$ = -4						; size = 4
_num$ = 8						; size = 4
_spawnSpot$ = 12					; size = 4
_id$ = 16						; size = 4
_Polyobj_spawnPolyObj PROC				; COMDAT

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 574  : 	size_t i;
; 575  : 	polyobj_t *po = &PolyObjects[num];

  00009	69 45 08 a8 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 168
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR _PolyObjects
  00016	89 45 f8	 mov	 DWORD PTR _po$[ebp], eax

; 576  : 
; 577  : 	// don't spawn a polyobject more than once
; 578  : 	if (po->segCount)

  00019	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0001c	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00020	74 19		 je	 SHORT $LN5@Polyobj_sp

; 579  : 	{
; 580  : 		CONS_Printf("polyobj %d has more than one spawn spot", po->id);

  00022	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00025	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00028	51		 push	 ecx
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NNIJBMDC@polyobj?5?$CFd?5has?5more?5than?5one?5sp@
  0002e	e8 00 00 00 00	 call	 _CONS_Printf
  00033	83 c4 08	 add	 esp, 8

; 581  : 		return;

  00036	e9 0b 03 00 00	 jmp	 $LN22@Polyobj_sp
$LN5@Polyobj_sp:

; 582  : 	}
; 583  : 
; 584  : 	po->id = id;

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _id$[ebp]
  00041	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 585  : 
; 586  : 	// TODO: support customized damage somehow?
; 587  : 	if (spawnSpot->info->doomednum == POLYOBJ_SPAWNCRUSH_DOOMEDNUM)

  00044	8b 45 0c	 mov	 eax, DWORD PTR _spawnSpot$[ebp]
  00047	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0004d	81 39 fa 02 00
	00		 cmp	 DWORD PTR [ecx], 762	; 000002faH
  00053	75 0d		 jne	 SHORT $LN6@Polyobj_sp

; 588  : 		po->damage = 3;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00058	c7 80 90 00 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+144], 3
$LN6@Polyobj_sp:

; 589  : 
; 590  : 	// set to default thrust; may be modified by attached thinkers
; 591  : 	// TODO: support customized thrust?
; 592  : 	po->thrust = FRACUNIT;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00065	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H

; 593  : 	po->flags = 0;

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00072	c7 80 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+152], 0

; 594  : 
; 595  : 	// 1. Search segs for "line start" special with tag matching this
; 596  : 	//    polyobject's id number. If found, iterate through segs which
; 597  : 	//    share common vertices and record them into the polyobject.
; 598  : 	for (i = 0; i < numsegs; ++i)

  0007c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00083	eb 09		 jmp	 SHORT $LN4@Polyobj_sp
$LN2@Polyobj_sp:
  00085	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_sp:
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00091	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsegs
  00097	0f 83 7c 01 00
	00		 jae	 $LN3@Polyobj_sp

; 599  : 	{
; 600  : 		seg_t *seg = &segs[i];

  0009d	6b 45 fc 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  000a1	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  000a7	89 45 f4	 mov	 DWORD PTR _seg$5[ebp], eax

; 601  : 		INT32 polyID, parentID;
; 602  : 
; 603  : 		if (seg->linedef->special != POLYOBJ_START_LINE)

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  000ad	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b0	0f bf 51 12	 movsx	 edx, WORD PTR [ecx+18]
  000b4	83 fa 14	 cmp	 edx, 20			; 00000014H
  000b7	74 02		 je	 SHORT $LN7@Polyobj_sp

; 604  : 			continue;

  000b9	eb ca		 jmp	 SHORT $LN2@Polyobj_sp
$LN7@Polyobj_sp:

; 605  : 
; 606  : 		Polyobj_GetInfo(seg->linedef->tag, &polyID, &parentID, NULL);

  000bb	6a 00		 push	 0
  000bd	8d 45 ec	 lea	 eax, DWORD PTR _parentID$3[ebp]
  000c0	50		 push	 eax
  000c1	8d 4d f0	 lea	 ecx, DWORD PTR _polyID$4[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 f4	 mov	 edx, DWORD PTR _seg$5[ebp]
  000c8	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000cb	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 _Polyobj_GetInfo
  000d5	83 c4 10	 add	 esp, 16			; 00000010H

; 607  : 
; 608  : 		// is it a START line with this polyobject's id?
; 609  : 		if (polyID == po->id)

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  000db	8b 4d f0	 mov	 ecx, DWORD PTR _polyID$4[ebp]
  000de	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000e1	0f 85 2d 01 00
	00		 jne	 $LN8@Polyobj_sp

; 610  : 		{
; 611  : 			po->flags = POF_SOLID|POF_TESTHEIGHT|POF_RENDERSIDES;

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  000ea	c7 80 98 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [eax+152], 15	; 0000000fH

; 612  : 
; 613  : 			if (seg->linedef->flags & ML_EFFECT1)

  000f4	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  000f7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000fa	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  000fe	83 e2 20	 and	 edx, 32			; 00000020H
  00101	74 18		 je	 SHORT $LN9@Polyobj_sp

; 614  : 				po->flags |= POF_ONESIDE;

  00103	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00106	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0010c	81 c9 00 08 00
	00		 or	 ecx, 2048		; 00000800H
  00112	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00115	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN9@Polyobj_sp:

; 615  : 
; 616  : 			if (seg->linedef->flags & ML_EFFECT2)

  0011b	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  0011e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00121	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00125	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0012b	74 15		 je	 SHORT $LN10@Polyobj_sp

; 617  : 				po->flags &= ~POF_SOLID;

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00130	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00136	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00139	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  0013c	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN10@Polyobj_sp:

; 618  : 
; 619  : 			if (seg->linedef->flags & ML_EFFECT3)

  00142	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  00145	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00148	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  0014c	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00152	74 18		 je	 SHORT $LN11@Polyobj_sp

; 620  : 				po->flags |= POF_PUSHABLESTOP;

  00154	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00157	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0015d	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  00163	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  00166	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN11@Polyobj_sp:

; 621  : 
; 622  : 			if (seg->linedef->flags & ML_EFFECT4)

  0016c	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  0016f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00172	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00176	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  0017c	74 15		 je	 SHORT $LN12@Polyobj_sp

; 623  : 				po->flags |= POF_RENDERPLANES;

  0017e	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00181	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00187	83 c9 30	 or	 ecx, 48			; 00000030H
  0018a	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  0018d	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN12@Polyobj_sp:

; 624  : 
; 625  : 			if (seg->linedef->flags & ML_EFFECT5)

  00193	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  00196	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00199	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  0019d	81 e2 00 04 00
	00		 and	 edx, 1024		; 00000400H
  001a3	74 15		 je	 SHORT $LN13@Polyobj_sp

; 626  : 				po->flags &= ~POF_CLIPPLANES;

  001a5	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  001a8	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  001ae	83 e1 fd	 and	 ecx, -3			; fffffffdH
  001b1	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  001b4	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN13@Polyobj_sp:

; 627  : 
; 628  : 			if (seg->linedef->flags & ML_NOCLIMB) // Has a linedef executor

  001ba	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  001bd	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001c0	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  001c4	83 e2 40	 and	 edx, 64			; 00000040H
  001c7	74 18		 je	 SHORT $LN14@Polyobj_sp

; 629  : 				po->flags |= POF_LDEXEC;

  001c9	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  001cc	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  001d2	81 c9 00 04 00
	00		 or	 ecx, 1024		; 00000400H
  001d8	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  001db	89 8a 98 00 00
	00		 mov	 DWORD PTR [edx+152], ecx
$LN14@Polyobj_sp:

; 630  : 
; 631  : 			Polyobj_findSegs(po, seg);

  001e1	8b 45 f4	 mov	 eax, DWORD PTR _seg$5[ebp]
  001e4	50		 push	 eax
  001e5	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 _Polyobj_findSegs
  001ee	83 c4 08	 add	 esp, 8

; 632  : 			po->parent = parentID;

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  001f4	8b 4d ec	 mov	 ecx, DWORD PTR _parentID$3[ebp]
  001f7	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 633  : 			if (po->parent == po->id) // do not allow a self-reference

  001fa	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  001fd	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  00200	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00203	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00206	75 0a		 jne	 SHORT $LN15@Polyobj_sp

; 634  : 				po->parent = -1;

  00208	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0020b	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1
$LN15@Polyobj_sp:

; 635  : 			// TODO: sound sequence is in args[2]
; 636  : 			break;

  00212	eb 05		 jmp	 SHORT $LN3@Polyobj_sp
$LN8@Polyobj_sp:

; 637  : 		}
; 638  : 	}

  00214	e9 6c fe ff ff	 jmp	 $LN2@Polyobj_sp
$LN3@Polyobj_sp:

; 639  : 
; 640  : 	if (cv_debug)

  00219	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  00220	74 1b		 je	 SHORT $LN16@Polyobj_sp

; 641  : 		CONS_Printf("PO ID: %d; Num verts: %"PRIdS"\n", po->id, po->numVertices);

  00222	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00225	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00228	51		 push	 ecx
  00229	8b 55 f8	 mov	 edx, DWORD PTR _po$[ebp]
  0022c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0022f	50		 push	 eax
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MKGPPMAC@PO?5ID?3?5?$CFd?$DL?5Num?5verts?3?5?$CFIu?6@
  00235	e8 00 00 00 00	 call	 _CONS_Printf
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@Polyobj_sp:

; 642  : 
; 643  : 	// if an error occurred above, quit processing this object
; 644  : 	if (po->isBad)

  0023d	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00240	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00247	85 c9		 test	 ecx, ecx
  00249	74 05		 je	 SHORT $LN17@Polyobj_sp

; 645  : 		return;

  0024b	e9 f6 00 00 00	 jmp	 $LN22@Polyobj_sp
$LN17@Polyobj_sp:

; 646  : 
; 647  : 	// 2. If no such line existed in the first step, look for a seg with the
; 648  : 	//    "explicit" special with tag matching this polyobject's id number. If
; 649  : 	//    found, continue to search for all such lines, storing them in a
; 650  : 	//    temporary list of segs which is then copied into the polyobject in
; 651  : 	//    sorted order.
; 652  : 	if (po->segCount == 0)

  00250	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00253	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00257	75 6a		 jne	 SHORT $LN20@Polyobj_sp

; 653  : 	{
; 654  : 		UINT16 parent;
; 655  : 		Polyobj_findExplicit(po);

  00259	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 _Polyobj_findExplicit
  00262	83 c4 04	 add	 esp, 4

; 656  : 		// if an error occurred above, quit processing this object
; 657  : 		if (po->isBad)

  00265	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00268	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  0026f	85 c9		 test	 ecx, ecx
  00271	74 05		 je	 SHORT $LN19@Polyobj_sp

; 658  : 			return;

  00273	e9 ce 00 00 00	 jmp	 $LN22@Polyobj_sp
$LN19@Polyobj_sp:

; 659  : 
; 660  : 		Polyobj_GetInfo(po->segs[0]->linedef->tag, NULL, NULL, &parent);

  00278	8d 45 e8	 lea	 eax, DWORD PTR _parent$2[ebp]
  0027b	50		 push	 eax
  0027c	6a 00		 push	 0
  0027e	6a 00		 push	 0
  00280	b9 04 00 00 00	 mov	 ecx, 4
  00285	6b d1 00	 imul	 edx, ecx, 0
  00288	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0028b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0028e	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00291	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00294	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00298	51		 push	 ecx
  00299	e8 00 00 00 00	 call	 _Polyobj_GetInfo
  0029e	83 c4 10	 add	 esp, 16			; 00000010H

; 661  : 		po->parent = parent;

  002a1	0f b7 45 e8	 movzx	 eax, WORD PTR _parent$2[ebp]
  002a5	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  002a8	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 662  : 		if (po->parent == po->id) // do not allow a self-reference

  002ab	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  002b1	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002b4	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  002b7	75 0a		 jne	 SHORT $LN20@Polyobj_sp

; 663  : 			po->parent = -1;

  002b9	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  002bc	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1
$LN20@Polyobj_sp:

; 664  : 		// TODO: sound sequence is in args[3]
; 665  : 	}
; 666  : 
; 667  : 
; 668  : 	// set the polyobject's spawn spot
; 669  : 	po->spawnSpot.x = spawnSpot->x;

  002c3	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  002c6	8b 4d 0c	 mov	 ecx, DWORD PTR _spawnSpot$[ebp]
  002c9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002cc	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 670  : 	po->spawnSpot.y = spawnSpot->y;

  002cf	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  002d2	8b 4d 0c	 mov	 ecx, DWORD PTR _spawnSpot$[ebp]
  002d5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002d8	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 671  : 
; 672  : 	// hash the polyobject by its numeric id
; 673  : 	if (Polyobj_GetForNum(po->id))

  002db	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  002de	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e1	51		 push	 ecx
  002e2	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  002e7	83 c4 04	 add	 esp, 4
  002ea	85 c0		 test	 eax, eax
  002ec	74 1d		 je	 SHORT $LN21@Polyobj_sp

; 674  : 	{
; 675  : 		// bad polyobject due to id conflict
; 676  : 		po->isBad = true;

  002ee	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  002f1	c6 80 a0 00 00
	00 01		 mov	 BYTE PTR [eax+160], 1

; 677  : 		CONS_Printf("polyobject id conflict: %d\n", id);

  002f8	8b 45 10	 mov	 eax, DWORD PTR _id$[ebp]
  002fb	50		 push	 eax
  002fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JFHGKJAG@polyobject?5id?5conflict?3?5?$CFd?6@
  00301	e8 00 00 00 00	 call	 _CONS_Printf
  00306	83 c4 08	 add	 esp, 8

; 678  : 	}

  00309	eb 3b		 jmp	 SHORT $LN22@Polyobj_sp
$LN21@Polyobj_sp:

; 679  : 	else
; 680  : 	{
; 681  : 		INT32 hashkey = po->id % numPolyObjects;

  0030b	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0030e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00311	99		 cdq
  00312	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _numPolyObjects
  00318	89 55 e4	 mov	 DWORD PTR _hashkey$1[ebp], edx

; 682  : 		po->next = PolyObjects[hashkey].first;

  0031b	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _hashkey$1[ebp], 168
  00322	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  00325	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _PolyObjects
  0032b	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  0032f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 683  : 		PolyObjects[hashkey].first = num;

  00332	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _hashkey$1[ebp], 168
  00339	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PolyObjects
  0033f	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  00342	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx
$LN22@Polyobj_sp:

; 684  : 	}
; 685  : }

  00346	5f		 pop	 edi
  00347	5e		 pop	 esi
  00348	5b		 pop	 ebx
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c3		 ret	 0
_Polyobj_spawnPolyObj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_findExplicit
_TEXT	SEGMENT
tv86 = -92						; size = 4
_parentID$1 = -24					; size = 4
_polyID$2 = -20						; size = 4
_i$ = -16						; size = 4
_numSegItemsAlloc$ = -12				; size = 4
_numSegItems$ = -8					; size = 4
_segitems$ = -4						; size = 4
_po$ = 8						; size = 4
_Polyobj_findExplicit PROC				; COMDAT

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 515  : 	// temporary dynamic seg array
; 516  : 	segitem_t *segitems = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _segitems$[ebp], 0

; 517  : 	size_t numSegItems = 0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _numSegItems$[ebp], 0

; 518  : 	size_t numSegItemsAlloc = 0;

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _numSegItemsAlloc$[ebp], 0

; 519  : 
; 520  : 	size_t i;
; 521  : 
; 522  : 	// first loop: save off all segs with polyobject's id number
; 523  : 	for (i = 0; i < numsegs; ++i)

  0001e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@Polyobj_fi
$LN2@Polyobj_fi:
  00027	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_fi:
  00030	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsegs
  00039	0f 83 bd 00 00
	00		 jae	 $LN3@Polyobj_fi

; 524  : 	{
; 525  : 		INT32 polyID, parentID;
; 526  : 
; 527  : 		if (segs[i].linedef->special != POLYOBJ_EXPLICIT_LINE)

  0003f	6b 45 f0 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  00049	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  0004d	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  00051	83 f8 15	 cmp	 eax, 21			; 00000015H
  00054	74 02		 je	 SHORT $LN8@Polyobj_fi

; 528  : 			continue;

  00056	eb cf		 jmp	 SHORT $LN2@Polyobj_fi
$LN8@Polyobj_fi:

; 529  : 
; 530  : 		Polyobj_GetInfo(segs[i].linedef->tag, &polyID, &parentID, NULL);

  00058	6a 00		 push	 0
  0005a	8d 45 e8	 lea	 eax, DWORD PTR _parentID$1[ebp]
  0005d	50		 push	 eax
  0005e	8d 4d ec	 lea	 ecx, DWORD PTR _polyID$2[ebp]
  00061	51		 push	 ecx
  00062	6b 55 f0 3c	 imul	 edx, DWORD PTR _i$[ebp], 60
  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR _segs
  0006b	8b 4c 10 18	 mov	 ecx, DWORD PTR [eax+edx+24]
  0006f	0f b7 51 14	 movzx	 edx, WORD PTR [ecx+20]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _Polyobj_GetInfo
  00079	83 c4 10	 add	 esp, 16			; 00000010H

; 531  : 
; 532  : 		if (polyID == po->id && parentID > 0)

  0007c	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _polyID$2[ebp]
  00082	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00085	75 70		 jne	 SHORT $LN9@Polyobj_fi
  00087	83 7d e8 00	 cmp	 DWORD PTR _parentID$1[ebp], 0
  0008b	7e 6a		 jle	 SHORT $LN9@Polyobj_fi

; 533  : 		{
; 534  : 			if (numSegItems >= numSegItemsAlloc)

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _numSegItems$[ebp]
  00090	3b 45 f4	 cmp	 eax, DWORD PTR _numSegItemsAlloc$[ebp]
  00093	72 39		 jb	 SHORT $LN10@Polyobj_fi

; 535  : 			{
; 536  : 				numSegItemsAlloc = numSegItemsAlloc ? numSegItemsAlloc*2 : 4;

  00095	83 7d f4 00	 cmp	 DWORD PTR _numSegItemsAlloc$[ebp], 0
  00099	74 0a		 je	 SHORT $LN14@Polyobj_fi
  0009b	8b 45 f4	 mov	 eax, DWORD PTR _numSegItemsAlloc$[ebp]
  0009e	d1 e0		 shl	 eax, 1
  000a0	89 45 a4	 mov	 DWORD PTR tv86[ebp], eax
  000a3	eb 07		 jmp	 SHORT $LN15@Polyobj_fi
$LN14@Polyobj_fi:
  000a5	c7 45 a4 04 00
	00 00		 mov	 DWORD PTR tv86[ebp], 4
$LN15@Polyobj_fi:
  000ac	8b 4d a4	 mov	 ecx, DWORD PTR tv86[ebp]
  000af	89 4d f4	 mov	 DWORD PTR _numSegItemsAlloc$[ebp], ecx

; 537  : 				segitems = Z_Realloc(segitems, numSegItemsAlloc*sizeof(segitem_t), PU_STATIC, NULL);

  000b2	6a 00		 push	 0
  000b4	6a 00		 push	 0
  000b6	6a 01		 push	 1
  000b8	8b 45 f4	 mov	 eax, DWORD PTR _numSegItemsAlloc$[ebp]
  000bb	c1 e0 03	 shl	 eax, 3
  000be	50		 push	 eax
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _segitems$[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 _Z_ReallocAlign
  000c8	83 c4 14	 add	 esp, 20			; 00000014H
  000cb	89 45 fc	 mov	 DWORD PTR _segitems$[ebp], eax
$LN10@Polyobj_fi:

; 538  : 			}
; 539  : 			segitems[numSegItems].seg = &segs[i];

  000ce	6b 45 f0 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  000d2	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _numSegItems$[ebp]
  000db	8b 55 fc	 mov	 edx, DWORD PTR _segitems$[ebp]
  000de	89 04 ca	 mov	 DWORD PTR [edx+ecx*8], eax

; 540  : 			segitems[numSegItems].num = parentID;

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _numSegItems$[ebp]
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _segitems$[ebp]
  000e7	8b 55 e8	 mov	 edx, DWORD PTR _parentID$1[ebp]
  000ea	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx

; 541  : 			++numSegItems;

  000ee	8b 45 f8	 mov	 eax, DWORD PTR _numSegItems$[ebp]
  000f1	83 c0 01	 add	 eax, 1
  000f4	89 45 f8	 mov	 DWORD PTR _numSegItems$[ebp], eax
$LN9@Polyobj_fi:

; 542  : 		}
; 543  : 	}

  000f7	e9 2b ff ff ff	 jmp	 $LN2@Polyobj_fi
$LN3@Polyobj_fi:

; 544  : 
; 545  : 	// make sure array isn't empty
; 546  : 	if (numSegItems == 0)

  000fc	83 7d f8 00	 cmp	 DWORD PTR _numSegItems$[ebp], 0
  00100	75 20		 jne	 SHORT $LN11@Polyobj_fi

; 547  : 	{
; 548  : 		po->isBad = true;

  00102	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00105	c6 80 a0 00 00
	00 01		 mov	 BYTE PTR [eax+160], 1

; 549  : 		CONS_Printf("polyobject %d is empty\n", po->id);

  0010c	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0010f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00112	51		 push	 ecx
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BPFKKBMH@polyobject?5?$CFd?5is?5empty?6@
  00118	e8 00 00 00 00	 call	 _CONS_Printf
  0011d	83 c4 08	 add	 esp, 8

; 550  : 		return;

  00120	eb 5b		 jmp	 SHORT $LN1@Polyobj_fi
$LN11@Polyobj_fi:

; 551  : 	}
; 552  : 
; 553  : 	// sort the array if necessary
; 554  : 	if (numSegItems >= 2)

  00122	83 7d f8 02	 cmp	 DWORD PTR _numSegItems$[ebp], 2
  00126	72 17		 jb	 SHORT $LN12@Polyobj_fi

; 555  : 		qsort(segitems, numSegItems, sizeof(segitem_t), Polyobj_segCompare);

  00128	68 00 00 00 00	 push	 OFFSET _Polyobj_segCompare
  0012d	6a 08		 push	 8
  0012f	8b 45 f8	 mov	 eax, DWORD PTR _numSegItems$[ebp]
  00132	50		 push	 eax
  00133	8b 4d fc	 mov	 ecx, DWORD PTR _segitems$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _qsort
  0013c	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@Polyobj_fi:

; 556  : 
; 557  : 	// second loop: put the sorted segs into the polyobject
; 558  : 	for (i = 0; i < numSegItems; ++i)

  0013f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00146	eb 09		 jmp	 SHORT $LN7@Polyobj_fi
$LN5@Polyobj_fi:
  00148	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0014b	83 c0 01	 add	 eax, 1
  0014e	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Polyobj_fi:
  00151	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00154	3b 45 f8	 cmp	 eax, DWORD PTR _numSegItems$[ebp]
  00157	73 18		 jae	 SHORT $LN6@Polyobj_fi

; 559  : 		Polyobj_addSeg(po, segitems[i].seg);

  00159	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0015c	8b 4d fc	 mov	 ecx, DWORD PTR _segitems$[ebp]
  0015f	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00162	52		 push	 edx
  00163	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _Polyobj_addSeg
  0016c	83 c4 08	 add	 esp, 8
  0016f	eb d7		 jmp	 SHORT $LN5@Polyobj_fi
$LN6@Polyobj_fi:

; 560  : 
; 561  : 	// free the temporary array
; 562  : 	Z_Free(segitems);

  00171	8b 45 fc	 mov	 eax, DWORD PTR _segitems$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _Z_Free
  0017a	83 c4 04	 add	 esp, 4
$LN1@Polyobj_fi:

; 563  : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_Polyobj_findExplicit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_segCompare
_TEXT	SEGMENT
_si2$ = -8						; size = 4
_si1$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_Polyobj_segCompare PROC				; COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 502  : 	const segitem_t *si1 = s1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _si1$[ebp], eax

; 503  : 	const segitem_t *si2 = s2;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _si2$[ebp], eax

; 504  : 
; 505  : 	return si2->num - si1->num;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _si2$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _si1$[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 506  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_Polyobj_segCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_findSegs
_TEXT	SEGMENT
_r$1 = -28						; size = 4
_q$2 = -24						; size = 4
_r$3 = -20						; size = 4
_s$ = -16						; size = 4
_i$ = -12						; size = 4
_starty$ = -8						; size = 4
_startx$ = -4						; size = 4
_po$ = 8						; size = 4
_seg$ = 12						; size = 4
_Polyobj_findSegs PROC					; COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 390  : 	fixed_t startx, starty;
; 391  : 	size_t i;
; 392  : 	size_t s;
; 393  : 
; 394  : 	Polyobj_addSeg(po, seg);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _Polyobj_addSeg
  00016	83 c4 08	 add	 esp, 8

; 395  : 
; 396  : 	if (!(po->flags & POF_ONESIDE))

  00019	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001c	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00022	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  00028	0f 85 c3 00 00
	00		 jne	 $LN3@Polyobj_fi

; 397  : 	{
; 398  : 		// Find backfacings
; 399  : 		for (s = 0;  s < numsegs; s++)

  0002e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  00035	eb 09		 jmp	 SHORT $LN4@Polyobj_fi
$LN2@Polyobj_fi:
  00037	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax
$LN4@Polyobj_fi:
  00040	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsegs
  00049	0f 83 a2 00 00
	00		 jae	 $LN3@Polyobj_fi

; 400  : 		{
; 401  : 			if (segs[s].linedef == seg->linedef
; 402  : 				&& segs[s].side == 1)

  0004f	6b 45 f0 3c	 imul	 eax, DWORD PTR _s$[ebp], 60
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  00059	8b 55 0c	 mov	 edx, DWORD PTR _seg$[ebp]
  0005c	8b 44 01 18	 mov	 eax, DWORD PTR [ecx+eax+24]
  00060	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00063	0f 85 83 00 00
	00		 jne	 $LN21@Polyobj_fi
  00069	6b 45 f0 3c	 imul	 eax, DWORD PTR _s$[ebp], 60
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  00073	83 7c 01 08 01	 cmp	 DWORD PTR [ecx+eax+8], 1
  00078	75 72		 jne	 SHORT $LN21@Polyobj_fi

; 403  : 			{
; 404  : 				size_t r;
; 405  : 				for (r = 0; r < po->segCount; r++)

  0007a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _r$3[ebp], 0
  00081	eb 09		 jmp	 SHORT $LN7@Polyobj_fi
$LN5@Polyobj_fi:
  00083	8b 45 ec	 mov	 eax, DWORD PTR _r$3[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 ec	 mov	 DWORD PTR _r$3[ebp], eax
$LN7@Polyobj_fi:
  0008c	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _r$3[ebp]
  00092	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00095	73 1c		 jae	 SHORT $LN6@Polyobj_fi

; 406  : 				{
; 407  : 					if (po->segs[r] == &segs[s])

  00097	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0009a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0009d	6b 55 f0 3c	 imul	 edx, DWORD PTR _s$[ebp], 60
  000a1	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  000a7	8b 45 ec	 mov	 eax, DWORD PTR _r$3[ebp]
  000aa	39 14 81	 cmp	 DWORD PTR [ecx+eax*4], edx
  000ad	75 02		 jne	 SHORT $LN22@Polyobj_fi

; 408  : 						break;

  000af	eb 02		 jmp	 SHORT $LN6@Polyobj_fi
$LN22@Polyobj_fi:

; 409  : 				}

  000b1	eb d0		 jmp	 SHORT $LN5@Polyobj_fi
$LN6@Polyobj_fi:

; 410  : 
; 411  : 				if (r != po->segCount)

  000b3	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _r$3[ebp]
  000b9	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  000bc	74 05		 je	 SHORT $LN23@Polyobj_fi

; 412  : 					continue;

  000be	e9 74 ff ff ff	 jmp	 $LN2@Polyobj_fi
$LN23@Polyobj_fi:

; 413  : 
; 414  : 				segs[s].dontrenderme = true;

  000c3	6b 45 f0 3c	 imul	 eax, DWORD PTR _s$[ebp], 60
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  000cd	c7 44 01 38 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+56], 1

; 415  : 
; 416  : 				Polyobj_addSeg(po, &segs[s]);

  000d5	6b 45 f0 3c	 imul	 eax, DWORD PTR _s$[ebp], 60
  000d9	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  000df	50		 push	 eax
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _Polyobj_addSeg
  000e9	83 c4 08	 add	 esp, 8
$LN21@Polyobj_fi:

; 417  : 			}
; 418  : 		}

  000ec	e9 46 ff ff ff	 jmp	 $LN2@Polyobj_fi
$LN3@Polyobj_fi:

; 419  : 	}
; 420  : 
; 421  : 	// on first seg, save the initial vertex
; 422  : 	startx = seg->v1->x;

  000f1	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  000f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f8	89 55 fc	 mov	 DWORD PTR _startx$[ebp], edx

; 423  : 	starty = seg->v1->y;

  000fb	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00103	89 55 f8	 mov	 DWORD PTR _starty$[ebp], edx
$newseg$33:

; 424  : 
; 425  : 	// use goto instead of recursion for maximum efficiency - thanks to lament
; 426  : newseg:
; 427  : 
; 428  : 	// terminal case: we have reached a seg where v2 is the same as v1 of the
; 429  : 	// initial seg
; 430  : 	if (seg->v2->x == startx && seg->v2->y == starty)

  00106	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  00109	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010e	3b 55 fc	 cmp	 edx, DWORD PTR _startx$[ebp]
  00111	75 13		 jne	 SHORT $LN24@Polyobj_fi
  00113	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  00116	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00119	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0011c	3b 55 f8	 cmp	 edx, DWORD PTR _starty$[ebp]
  0011f	75 05		 jne	 SHORT $LN24@Polyobj_fi

; 431  : 		return;

  00121	e9 d2 01 00 00	 jmp	 $LN1@Polyobj_fi
$LN24@Polyobj_fi:

; 432  : 
; 433  : 	// search the segs for one whose starting vertex is equal to the current
; 434  : 	// seg's ending vertex.
; 435  : 	for (i = 0; i < numsegs; ++i)

  00126	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0012d	eb 09		 jmp	 SHORT $LN10@Polyobj_fi
$LN8@Polyobj_fi:
  0012f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00132	83 c0 01	 add	 eax, 1
  00135	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Polyobj_fi:
  00138	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0013b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsegs
  00141	0f 83 93 01 00
	00		 jae	 $LN9@Polyobj_fi

; 436  : 	{
; 437  : 		if (segs[i].v1->x == seg->v2->x && segs[i].v1->y == seg->v2->y)

  00147	6b 45 f4 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  00151	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00154	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  00157	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015a	8b 12		 mov	 edx, DWORD PTR [edx]
  0015c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0015e	0f 85 71 01 00
	00		 jne	 $LN25@Polyobj_fi
  00164	6b 45 f4 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  0016e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00171	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  00174	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00177	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0017a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0017d	0f 85 52 01 00
	00		 jne	 $LN25@Polyobj_fi

; 438  : 		{
; 439  : 			// Make sure you didn't already add this seg...
; 440  : 			size_t q;
; 441  : 			for (q = 0; q < po->segCount; q++)

  00183	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _q$2[ebp], 0
  0018a	eb 09		 jmp	 SHORT $LN13@Polyobj_fi
$LN11@Polyobj_fi:
  0018c	8b 45 e8	 mov	 eax, DWORD PTR _q$2[ebp]
  0018f	83 c0 01	 add	 eax, 1
  00192	89 45 e8	 mov	 DWORD PTR _q$2[ebp], eax
$LN13@Polyobj_fi:
  00195	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00198	8b 4d e8	 mov	 ecx, DWORD PTR _q$2[ebp]
  0019b	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0019e	73 1c		 jae	 SHORT $LN12@Polyobj_fi

; 442  : 			{
; 443  : 				if (po->segs[q] == &segs[i])

  001a0	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001a3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001a6	6b 55 f4 3c	 imul	 edx, DWORD PTR _i$[ebp], 60
  001aa	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  001b0	8b 45 e8	 mov	 eax, DWORD PTR _q$2[ebp]
  001b3	39 14 81	 cmp	 DWORD PTR [ecx+eax*4], edx
  001b6	75 02		 jne	 SHORT $LN26@Polyobj_fi

; 444  : 					break;

  001b8	eb 02		 jmp	 SHORT $LN12@Polyobj_fi
$LN26@Polyobj_fi:

; 445  : 			}

  001ba	eb d0		 jmp	 SHORT $LN11@Polyobj_fi
$LN12@Polyobj_fi:

; 446  : 
; 447  : 			if (q != po->segCount)

  001bc	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001bf	8b 4d e8	 mov	 ecx, DWORD PTR _q$2[ebp]
  001c2	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  001c5	74 05		 je	 SHORT $LN27@Polyobj_fi

; 448  : 				continue;

  001c7	e9 63 ff ff ff	 jmp	 $LN8@Polyobj_fi
$LN27@Polyobj_fi:

; 449  : 
; 450  : 			// add the new seg and recurse
; 451  : 			Polyobj_addSeg(po, &segs[i]);

  001cc	6b 45 f4 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  001d0	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  001d6	50		 push	 eax
  001d7	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  001da	51		 push	 ecx
  001db	e8 00 00 00 00	 call	 _Polyobj_addSeg
  001e0	83 c4 08	 add	 esp, 8

; 452  : 			seg = &segs[i];

  001e3	6b 45 f4 3c	 imul	 eax, DWORD PTR _i$[ebp], 60
  001e7	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  001ed	89 45 0c	 mov	 DWORD PTR _seg$[ebp], eax

; 453  : 
; 454  : 			if (!(po->flags & POF_ONESIDE))

  001f0	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  001f3	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  001f9	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  001ff	0f 85 cb 00 00
	00		 jne	 $LN15@Polyobj_fi

; 455  : 			{
; 456  : 				// Find backfacings
; 457  : 				for (q = 0;  q < numsegs; q++)

  00205	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _q$2[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN16@Polyobj_fi
$LN14@Polyobj_fi:
  0020e	8b 45 e8	 mov	 eax, DWORD PTR _q$2[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 e8	 mov	 DWORD PTR _q$2[ebp], eax
$LN16@Polyobj_fi:
  00217	8b 45 e8	 mov	 eax, DWORD PTR _q$2[ebp]
  0021a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsegs
  00220	0f 83 aa 00 00
	00		 jae	 $LN15@Polyobj_fi

; 458  : 				{
; 459  : 					if (segs[q].linedef == segs[i].linedef
; 460  : 						&& segs[q].side == 1)

  00226	6b 45 e8 3c	 imul	 eax, DWORD PTR _q$2[ebp], 60
  0022a	6b 4d f4 3c	 imul	 ecx, DWORD PTR _i$[ebp], 60
  0022e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _segs
  00234	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _segs
  0023a	8b 44 02 18	 mov	 eax, DWORD PTR [edx+eax+24]
  0023e	3b 44 0e 18	 cmp	 eax, DWORD PTR [esi+ecx+24]
  00242	0f 85 83 00 00
	00		 jne	 $LN29@Polyobj_fi
  00248	6b 45 e8 3c	 imul	 eax, DWORD PTR _q$2[ebp], 60
  0024c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  00252	83 7c 01 08 01	 cmp	 DWORD PTR [ecx+eax+8], 1
  00257	75 72		 jne	 SHORT $LN29@Polyobj_fi

; 461  : 					{
; 462  : 						size_t r;
; 463  : 						for (r=0; r < po->segCount; r++)

  00259	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$1[ebp], 0
  00260	eb 09		 jmp	 SHORT $LN19@Polyobj_fi
$LN17@Polyobj_fi:
  00262	8b 45 e4	 mov	 eax, DWORD PTR _r$1[ebp]
  00265	83 c0 01	 add	 eax, 1
  00268	89 45 e4	 mov	 DWORD PTR _r$1[ebp], eax
$LN19@Polyobj_fi:
  0026b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0026e	8b 4d e4	 mov	 ecx, DWORD PTR _r$1[ebp]
  00271	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00274	73 1c		 jae	 SHORT $LN18@Polyobj_fi

; 464  : 						{
; 465  : 							if (po->segs[r] == &segs[q])

  00276	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00279	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0027c	6b 55 e8 3c	 imul	 edx, DWORD PTR _q$2[ebp], 60
  00280	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  00286	8b 45 e4	 mov	 eax, DWORD PTR _r$1[ebp]
  00289	39 14 81	 cmp	 DWORD PTR [ecx+eax*4], edx
  0028c	75 02		 jne	 SHORT $LN30@Polyobj_fi

; 466  : 								break;

  0028e	eb 02		 jmp	 SHORT $LN18@Polyobj_fi
$LN30@Polyobj_fi:

; 467  : 						}

  00290	eb d0		 jmp	 SHORT $LN17@Polyobj_fi
$LN18@Polyobj_fi:

; 468  : 
; 469  : 						if (r != po->segCount)

  00292	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00295	8b 4d e4	 mov	 ecx, DWORD PTR _r$1[ebp]
  00298	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0029b	74 05		 je	 SHORT $LN31@Polyobj_fi

; 470  : 							continue;

  0029d	e9 6c ff ff ff	 jmp	 $LN14@Polyobj_fi
$LN31@Polyobj_fi:

; 471  : 
; 472  : 						segs[q].dontrenderme = true;

  002a2	6b 45 e8 3c	 imul	 eax, DWORD PTR _q$2[ebp], 60
  002a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _segs
  002ac	c7 44 01 38 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+56], 1

; 473  : 						Polyobj_addSeg(po, &segs[q]);

  002b4	6b 45 e8 3c	 imul	 eax, DWORD PTR _q$2[ebp], 60
  002b8	03 05 00 00 00
	00		 add	 eax, DWORD PTR _segs
  002be	50		 push	 eax
  002bf	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  002c2	51		 push	 ecx
  002c3	e8 00 00 00 00	 call	 _Polyobj_addSeg
  002c8	83 c4 08	 add	 esp, 8
$LN29@Polyobj_fi:

; 474  : 					}
; 475  : 				}

  002cb	e9 3e ff ff ff	 jmp	 $LN14@Polyobj_fi
$LN15@Polyobj_fi:

; 476  : 			}
; 477  : 
; 478  : 			goto newseg;

  002d0	e9 31 fe ff ff	 jmp	 $newseg$33
$LN25@Polyobj_fi:

; 479  : 		}
; 480  : 	}

  002d5	e9 55 fe ff ff	 jmp	 $LN8@Polyobj_fi
$LN9@Polyobj_fi:

; 481  : 
; 482  : 	// error: if we reach here, the seg search never found another seg to
; 483  : 	// continue the loop, and thus the polyobject is open. This isn't allowed.
; 484  : 	po->isBad = true;

  002da	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  002dd	c6 80 a0 00 00
	00 01		 mov	 BYTE PTR [eax+160], 1

; 485  : 	CONS_Printf("polyobject %d is not closed\n", po->id);

  002e4	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  002e7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ea	51		 push	 ecx
  002eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PGDMLNHH@polyobject?5?$CFd?5is?5not?5closed?6@
  002f0	e8 00 00 00 00	 call	 _CONS_Printf
  002f5	83 c4 08	 add	 esp, 8
$LN1@Polyobj_fi:

; 486  : }

  002f8	5f		 pop	 edi
  002f9	5e		 pop	 esi
  002fa	5b		 pop	 ebx
  002fb	8b e5		 mov	 esp, ebp
  002fd	5d		 pop	 ebp
  002fe	c3		 ret	 0
_Polyobj_findSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_addSeg
_TEXT	SEGMENT
tv72 = -68						; size = 4
_po$ = 8						; size = 4
_seg$ = 12						; size = 4
_Polyobj_addSeg PROC					; COMDAT

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 357  : 	if (po->segCount >= po->numSegsAlloc)

  00009	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0000f	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00012	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00015	72 4b		 jb	 SHORT $LN2@Polyobj_ad

; 358  : 	{
; 359  : 		po->numSegsAlloc = po->numSegsAlloc ? po->numSegsAlloc * 2 : 4;

  00017	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001a	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0001e	74 0d		 je	 SHORT $LN4@Polyobj_ad
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00023	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00026	d1 e2		 shl	 edx, 1
  00028	89 55 bc	 mov	 DWORD PTR tv72[ebp], edx
  0002b	eb 07		 jmp	 SHORT $LN5@Polyobj_ad
$LN4@Polyobj_ad:
  0002d	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR tv72[ebp], 4
$LN5@Polyobj_ad:
  00034	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00037	8b 4d bc	 mov	 ecx, DWORD PTR tv72[ebp]
  0003a	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 360  : 		po->segs = (seg_t **)Z_Realloc(po->segs,

  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 32		 push	 50			; 00000032H
  00043	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00046	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00049	c1 e1 02	 shl	 ecx, 2
  0004c	51		 push	 ecx
  0004d	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00050	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _Z_ReallocAlign
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0005f	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN2@Polyobj_ad:

; 361  : 										po->numSegsAlloc * sizeof(seg_t *),
; 362  : 										PU_LEVEL, NULL);
; 363  : 	}
; 364  : 
; 365  : 	seg->polyseg = po;

  00062	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00068	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 366  : 
; 367  : 	po->segs[po->segCount++] = seg;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0006e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00071	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00074	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00077	8b 55 0c	 mov	 edx, DWORD PTR _seg$[ebp]
  0007a	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  0007d	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00080	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00083	83 c1 01	 add	 ecx, 1
  00086	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00089	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 368  : 
; 369  : 	// possibly add the lines and vertices for this seg. It may be technically
; 370  : 	// unnecessary to add the v2 vertex of segs, but this makes sure that even
; 371  : 	// erroneously open "explicit" segs will have both vertices added and will
; 372  : 	// reduce problems.
; 373  : 	Polyobj_addVertex(po, seg->v1);

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  0008f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00091	51		 push	 ecx
  00092	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 _Polyobj_addVertex
  0009b	83 c4 08	 add	 esp, 8

; 374  : 	Polyobj_addVertex(po, seg->v2);

  0009e	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  000a1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a4	51		 push	 ecx
  000a5	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _Polyobj_addVertex
  000ae	83 c4 08	 add	 esp, 8

; 375  : 	Polyobj_addLine(po, seg->linedef);

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _seg$[ebp]
  000b4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b7	51		 push	 ecx
  000b8	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _Polyobj_addLine
  000c1	83 c4 08	 add	 esp, 8

; 376  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
_Polyobj_addSeg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_addLine
_TEXT	SEGMENT
tv79 = -72						; size = 4
_i$ = -4						; size = 4
_po$ = 8						; size = 4
_l$ = 12						; size = 4
_Polyobj_addLine PROC					; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 325  : 	size_t i;
; 326  : 
; 327  : 	// First: search the existing line pointers for a match. If one is found,
; 328  : 	// do not add this line again.
; 329  : 	for (i = 0; i < po->numLines; ++i)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Polyobj_ad
$LN2@Polyobj_ad:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_ad:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00024	73 18		 jae	 SHORT $LN3@Polyobj_ad

; 330  : 	{
; 331  : 		if (po->lines[i] == l)

  00026	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00029	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00032	3b 45 0c	 cmp	 eax, DWORD PTR _l$[ebp]
  00035	75 05		 jne	 SHORT $LN5@Polyobj_ad

; 332  : 			return;

  00037	e9 85 00 00 00	 jmp	 $LN1@Polyobj_ad
$LN5@Polyobj_ad:

; 333  : 	}

  0003c	eb d4		 jmp	 SHORT $LN2@Polyobj_ad
$LN3@Polyobj_ad:

; 334  : 
; 335  : 	// add the line to the array
; 336  : 	if (po->numLines >= po->numLinesAlloc)

  0003e	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00044	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00047	3b 51 3c	 cmp	 edx, DWORD PTR [ecx+60]
  0004a	72 4b		 jb	 SHORT $LN6@Polyobj_ad

; 337  : 	{
; 338  : 		po->numLinesAlloc = po->numLinesAlloc ? po->numLinesAlloc * 2 : 4;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0004f	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00053	74 0d		 je	 SHORT $LN8@Polyobj_ad
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00058	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0005b	d1 e2		 shl	 edx, 1
  0005d	89 55 b8	 mov	 DWORD PTR tv79[ebp], edx
  00060	eb 07		 jmp	 SHORT $LN9@Polyobj_ad
$LN8@Polyobj_ad:
  00062	c7 45 b8 04 00
	00 00		 mov	 DWORD PTR tv79[ebp], 4
$LN9@Polyobj_ad:
  00069	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0006c	8b 4d b8	 mov	 ecx, DWORD PTR tv79[ebp]
  0006f	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 339  : 		po->lines = (line_t **)Z_Realloc(po->lines,

  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	6a 32		 push	 50			; 00000032H
  00078	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0007b	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0007e	c1 e1 02	 shl	 ecx, 2
  00081	51		 push	 ecx
  00082	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00085	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _Z_ReallocAlign
  0008e	83 c4 14	 add	 esp, 20			; 00000014H
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00094	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN6@Polyobj_ad:

; 340  : 										po->numLinesAlloc * sizeof(line_t *),
; 341  : 										PU_LEVEL, NULL);
; 342  : 	}
; 343  : 	l->polyobj = po;

  00097	8b 45 0c	 mov	 eax, DWORD PTR _l$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0009d	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 344  : 	po->lines[po->numLines++] = l;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000a3	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a6	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000a9	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000ac	8b 55 0c	 mov	 edx, DWORD PTR _l$[ebp]
  000af	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  000b2	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000b5	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b8	83 c1 01	 add	 ecx, 1
  000bb	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000be	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$LN1@Polyobj_ad:

; 345  : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_Polyobj_addLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_addVertex
_TEXT	SEGMENT
tv79 = -72						; size = 4
_i$ = -4						; size = 4
_po$ = 8						; size = 4
_v$ = 12						; size = 4
_Polyobj_addVertex PROC					; COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 282  : 	size_t i;
; 283  : 
; 284  : 	// First: search the existing vertex pointers for a match. If one is found,
; 285  : 	// do not add this vertex again.
; 286  : 	for (i = 0; i < po->numVertices; ++i)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Polyobj_ad
$LN2@Polyobj_ad:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Polyobj_ad:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00024	73 18		 jae	 SHORT $LN3@Polyobj_ad

; 287  : 	{
; 288  : 		if (po->vertices[i] == v)

  00026	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00029	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00032	3b 45 0c	 cmp	 eax, DWORD PTR _v$[ebp]
  00035	75 05		 jne	 SHORT $LN5@Polyobj_ad

; 289  : 			return;

  00037	e9 e8 00 00 00	 jmp	 $LN1@Polyobj_ad
$LN5@Polyobj_ad:

; 290  : 	}

  0003c	eb d4		 jmp	 SHORT $LN2@Polyobj_ad
$LN3@Polyobj_ad:

; 291  : 
; 292  : 	// add the vertex to all arrays (translation for origVerts is done later)
; 293  : 	if (po->numVertices >= po->numVerticesAlloc)

  0003e	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00044	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00047	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  0004a	0f 82 91 00 00
	00		 jb	 $LN6@Polyobj_ad

; 294  : 	{
; 295  : 		po->numVerticesAlloc = po->numVerticesAlloc ? po->numVerticesAlloc * 2 : 4;

  00050	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00053	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00057	74 0d		 je	 SHORT $LN8@Polyobj_ad
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  0005c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0005f	d1 e2		 shl	 edx, 1
  00061	89 55 b8	 mov	 DWORD PTR tv79[ebp], edx
  00064	eb 07		 jmp	 SHORT $LN9@Polyobj_ad
$LN8@Polyobj_ad:
  00066	c7 45 b8 04 00
	00 00		 mov	 DWORD PTR tv79[ebp], 4
$LN9@Polyobj_ad:
  0006d	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00070	8b 4d b8	 mov	 ecx, DWORD PTR tv79[ebp]
  00073	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 296  : 		po->vertices =

  00076	6a 00		 push	 0
  00078	6a 00		 push	 0
  0007a	6a 32		 push	 50			; 00000032H
  0007c	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0007f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00082	c1 e1 02	 shl	 ecx, 2
  00085	51		 push	 ecx
  00086	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00089	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _Z_ReallocAlign
  00092	83 c4 14	 add	 esp, 20			; 00000014H
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00098	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 297  : 			(vertex_t **)Z_Realloc(po->vertices,
; 298  : 			                       po->numVerticesAlloc * sizeof(vertex_t *),
; 299  : 			                       PU_LEVEL, NULL);
; 300  : 		po->origVerts =

  0009b	6a 00		 push	 0
  0009d	6a 00		 push	 0
  0009f	6a 32		 push	 50			; 00000032H
  000a1	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000a4	6b 48 28 0c	 imul	 ecx, DWORD PTR [eax+40], 12
  000a8	51		 push	 ecx
  000a9	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000ac	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _Z_ReallocAlign
  000b5	83 c4 14	 add	 esp, 20			; 00000014H
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  000bb	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 301  : 			(vertex_t *)Z_Realloc(po->origVerts,
; 302  : 			                      po->numVerticesAlloc * sizeof(vertex_t),
; 303  : 			                      PU_LEVEL, NULL);
; 304  : 
; 305  : 		po->tmpVerts =

  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	6a 32		 push	 50			; 00000032H
  000c4	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000c7	6b 48 28 0c	 imul	 ecx, DWORD PTR [eax+40], 12
  000cb	51		 push	 ecx
  000cc	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000cf	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _Z_ReallocAlign
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  000de	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN6@Polyobj_ad:

; 306  : 			(vertex_t *)Z_Realloc(po->tmpVerts,
; 307  : 			                      po->numVerticesAlloc * sizeof(vertex_t),
; 308  : 			                      PU_LEVEL, NULL);
; 309  : 	}
; 310  : 	po->vertices[po->numVertices] = v;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000e4	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e7	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000ea	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000ed	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  000f0	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 311  : 	po->origVerts[po->numVertices] = *v;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  000f6	6b 48 24 0c	 imul	 ecx, DWORD PTR [eax+36], 12
  000fa	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  000fd	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00100	03 c1		 add	 eax, ecx
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00105	8b 11		 mov	 edx, DWORD PTR [ecx]
  00107	89 10		 mov	 DWORD PTR [eax], edx
  00109	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0010c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00112	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 312  : 	po->numVertices++;

  00115	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00118	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  00121	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
$LN1@Polyobj_ad:

; 313  : }

  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_Polyobj_addVertex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_vecSub2
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_Polyobj_vecSub2 PROC					; COMDAT

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 158  : 	dst->x = v1->x - v2->x;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _v2$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	2b 11		 sub	 edx, DWORD PTR [ecx]
  00013	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00016	89 10		 mov	 DWORD PTR [eax], edx

; 159  : 	dst->y = v1->y - v2->y;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _v1$[ebp]
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _v2$[ebp]
  0001e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00021	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00024	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00027	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 160  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_Polyobj_vecSub2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_vecSub
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_sub$ = 12						; size = 4
_Polyobj_vecSub PROC					; COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 152  : 	dst->x -= sub->x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _sub$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	2b 11		 sub	 edx, DWORD PTR [ecx]
  00013	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00016	89 10		 mov	 DWORD PTR [eax], edx

; 153  : 	dst->y -= sub->y;

  00018	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _sub$[ebp]
  0001e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00021	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00024	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00027	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 154  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_Polyobj_vecSub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_vecAdd
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_add$ = 12						; size = 4
_Polyobj_vecAdd PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 146  : 	dst->x += add->x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 55 0c	 mov	 edx, DWORD PTR _add$[ebp]
  00011	03 0a		 add	 ecx, DWORD PTR [edx]
  00013	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 147  : 	dst->y += add->y;

  00018	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	8b 55 0c	 mov	 edx, DWORD PTR _add$[ebp]
  00021	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00024	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00027	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 148  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_Polyobj_vecAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_bboxSub
_TEXT	SEGMENT
_bbox$ = 8						; size = 4
_sub$ = 12						; size = 4
_Polyobj_bboxSub PROC					; COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 138  : 	bbox[BOXTOP]    -= sub->y;

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00014	8b 45 0c	 mov	 eax, DWORD PTR _sub$[ebp]
  00017	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0001a	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0001d	ba 04 00 00 00	 mov	 edx, 4
  00022	6b c2 00	 imul	 eax, edx, 0
  00025	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00028	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 139  : 	bbox[BOXBOTTOM] -= sub->y;

  0002b	b8 04 00 00 00	 mov	 eax, 4
  00030	c1 e0 00	 shl	 eax, 0
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _bbox$[ebp]
  00036	8b 55 0c	 mov	 edx, DWORD PTR _sub$[ebp]
  00039	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  0003c	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0003f	b9 04 00 00 00	 mov	 ecx, 4
  00044	c1 e1 00	 shl	 ecx, 0
  00047	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  0004a	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 140  : 	bbox[BOXLEFT]   -= sub->x;

  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	d1 e0		 shl	 eax, 1
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _bbox$[ebp]
  00057	8b 55 0c	 mov	 edx, DWORD PTR _sub$[ebp]
  0005a	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  0005d	2b 02		 sub	 eax, DWORD PTR [edx]
  0005f	b9 04 00 00 00	 mov	 ecx, 4
  00064	d1 e1		 shl	 ecx, 1
  00066	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00069	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 141  : 	bbox[BOXRIGHT]  -= sub->x;

  0006c	b8 04 00 00 00	 mov	 eax, 4
  00071	6b c8 03	 imul	 ecx, eax, 3
  00074	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00077	8b 45 0c	 mov	 eax, DWORD PTR _sub$[ebp]
  0007a	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0007d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0007f	ba 04 00 00 00	 mov	 edx, 4
  00084	6b c2 03	 imul	 eax, edx, 3
  00087	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  0008a	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 142  : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_Polyobj_bboxSub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_bboxAdd
_TEXT	SEGMENT
_bbox$ = 8						; size = 4
_add$ = 12						; size = 4
_Polyobj_bboxAdd PROC					; COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 130  : 	bbox[BOXTOP]    += add->y;

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00014	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _add$[ebp]
  0001a	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0001d	ba 04 00 00 00	 mov	 edx, 4
  00022	6b ca 00	 imul	 ecx, edx, 0
  00025	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00028	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 131  : 	bbox[BOXBOTTOM] += add->y;

  0002b	b8 04 00 00 00	 mov	 eax, 4
  00030	c1 e0 00	 shl	 eax, 0
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _bbox$[ebp]
  00036	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00039	8b 45 0c	 mov	 eax, DWORD PTR _add$[ebp]
  0003c	03 50 04	 add	 edx, DWORD PTR [eax+4]
  0003f	b9 04 00 00 00	 mov	 ecx, 4
  00044	c1 e1 00	 shl	 ecx, 0
  00047	8b 45 08	 mov	 eax, DWORD PTR _bbox$[ebp]
  0004a	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 132  : 	bbox[BOXLEFT]   += add->x;

  0004d	b8 04 00 00 00	 mov	 eax, 4
  00052	d1 e0		 shl	 eax, 1
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _bbox$[ebp]
  00057	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _add$[ebp]
  0005d	03 10		 add	 edx, DWORD PTR [eax]
  0005f	b9 04 00 00 00	 mov	 ecx, 4
  00064	d1 e1		 shl	 ecx, 1
  00066	8b 45 08	 mov	 eax, DWORD PTR _bbox$[ebp]
  00069	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 133  : 	bbox[BOXRIGHT]  += add->x;

  0006c	b8 04 00 00 00	 mov	 eax, 4
  00071	6b c8 03	 imul	 ecx, eax, 3
  00074	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  00077	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _add$[ebp]
  0007d	03 01		 add	 eax, DWORD PTR [ecx]
  0007f	ba 04 00 00 00	 mov	 edx, 4
  00084	6b ca 03	 imul	 ecx, edx, 3
  00087	8b 55 08	 mov	 edx, DWORD PTR _bbox$[ebp]
  0008a	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 134  : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_Polyobj_bboxAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _EV_DoPolyObjFlag
_TEXT	SEGMENT
_start$ = -20						; size = 4
_i$ = -16						; size = 4
_th$ = -12						; size = 4
_oldpo$ = -8						; size = 4
_po$ = -4						; size = 4
_pfdata$ = 8						; size = 4
_EV_DoPolyObjFlag PROC					; COMDAT

; 2565 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2566 : 	polyobj_t *po;
; 2567 : 	polyobj_t *oldpo;
; 2568 : 	polymove_t *th;
; 2569 : 	size_t i;
; 2570 : 	INT32 start;
; 2571 : 
; 2572 : 	if (!(po = Polyobj_GetForNum(pfdata->tag)))

  00009	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  0000c	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00016	83 c4 04	 add	 esp, 4
  00019	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  0001c	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00020	75 1c		 jne	 SHORT $LN7@EV_DoPolyO

; 2573 : 	{
; 2574 : 		CONS_Printf("EV_DoPolyFlag: bad polyobj %d\n",

  00022	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  00025	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00029	51		 push	 ecx
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HJEBPJGJ@EV_DoPolyFlag?3?5bad?5polyobj?5?$CFd?6@
  0002f	e8 00 00 00 00	 call	 _CONS_Printf
  00034	83 c4 08	 add	 esp, 8

; 2575 : 					pfdata->tag);
; 2576 : 		return 0;

  00037	33 c0		 xor	 eax, eax
  00039	e9 85 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN7@EV_DoPolyO:

; 2577 : 	}
; 2578 : 
; 2579 : 	// don't allow line actions to affect bad polyobjects,
; 2580 : 	// polyobject doors don't allow action overrides
; 2581 : 	if (po->isBad || po->thinker)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00041	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00048	85 c9		 test	 ecx, ecx
  0004a	75 0c		 jne	 SHORT $LN9@EV_DoPolyO
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0004f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00056	74 07		 je	 SHORT $LN8@EV_DoPolyO
$LN9@EV_DoPolyO:

; 2582 : 		return 0;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 64 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN8@EV_DoPolyO:

; 2583 : 
; 2584 : 	// Must have even # of vertices
; 2585 : 	if (po->numVertices & 1)

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00062	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00065	83 e1 01	 and	 ecx, 1
  00068	74 14		 je	 SHORT $LN10@EV_DoPolyO

; 2586 : 	{
; 2587 : 		CONS_Printf("EV_DoPolyFlag: Polyobject has odd # of vertices!\n");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KODGNCDM@EV_DoPolyFlag?3?5Polyobject?5has?5o@
  0006f	e8 00 00 00 00	 call	 _CONS_Printf
  00074	83 c4 04	 add	 esp, 4

; 2588 : 		return 0;

  00077	33 c0		 xor	 eax, eax
  00079	e9 45 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN10@EV_DoPolyO:

; 2589 : 	}
; 2590 : 
; 2591 : 	// create a new thinker
; 2592 : 	th = Z_Malloc(sizeof(polymove_t), PU_LEVSPEC, NULL);

  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 33		 push	 51			; 00000033H
  00084	6a 28		 push	 40			; 00000028H
  00086	e8 00 00 00 00	 call	 _Z_MallocAlign
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	89 45 f4	 mov	 DWORD PTR _th$[ebp], eax

; 2593 : 	th->thinker.function.acp1 = (actionf_p1)T_PolyObjFlag;

  00091	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  00094	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_PolyObjFlag

; 2594 : 	P_AddThinker(&th->thinker);

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _P_AddThinker
  000a4	83 c4 04	 add	 esp, 4

; 2595 : 	po->thinker = &th->thinker;

  000a7	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  000ad	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2596 : 
; 2597 : 	// set fields
; 2598 : 	th->polyObjNum = pfdata->tag;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  000b6	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  000ba	8b 55 f4	 mov	 edx, DWORD PTR _th$[ebp]
  000bd	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 2599 : 	th->distance   = 0;

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000c3	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2600 : 	th->speed      = P_AproxDistance(pfdata->dx, pfdata->dy)>>FRACBITS;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  000cd	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d0	51		 push	 ecx
  000d1	8b 55 08	 mov	 edx, DWORD PTR _pfdata$[ebp]
  000d4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _P_AproxDistance
  000dd	83 c4 08	 add	 esp, 8
  000e0	c1 f8 10	 sar	 eax, 16			; 00000010H
  000e3	8b 4d f4	 mov	 ecx, DWORD PTR _th$[ebp]
  000e6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 2601 : 	th->angle      = R_PointToAngle2(pfdata->v1->x, pfdata->v1->y, pfdata->v2->x, pfdata->v2->y)>>ANGLETOFINESHIFT;

  000e9	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  000ec	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ef	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f2	52		 push	 edx
  000f3	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  000f6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fb	52		 push	 edx
  000fc	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  000ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00101	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00104	52		 push	 edx
  00105	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  00108	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 _R_PointToAngle2
  00112	83 c4 10	 add	 esp, 16			; 00000010H
  00115	c1 e8 13	 shr	 eax, 19			; 00000013H
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _th$[ebp]
  0011b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 2602 : 	th->momx       = sides[pfdata->sidenum[0]].textureoffset>>FRACBITS;

  0011e	b8 02 00 00 00	 mov	 eax, 2
  00123	6b c8 00	 imul	 ecx, eax, 0
  00126	8b 55 08	 mov	 edx, DWORD PTR _pfdata$[ebp]
  00129	0f b7 44 0a 16	 movzx	 eax, WORD PTR [edx+ecx+22]
  0012e	6b c8 1c	 imul	 ecx, eax, 28
  00131	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sides
  00137	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0013a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR _th$[ebp]
  00140	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 2603 : 
; 2604 : 	// save current positions
; 2605 : 	for (i = 0; i < po->numVertices; ++i)

  00143	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0014a	eb 09		 jmp	 SHORT $LN4@EV_DoPolyO
$LN2@EV_DoPolyO:
  0014c	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0014f	83 c0 01	 add	 eax, 1
  00152	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@EV_DoPolyO:
  00155	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00158	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  0015b	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  0015e	73 2a		 jae	 SHORT $LN3@EV_DoPolyO

; 2606 : 		po->tmpVerts[i] = *(po->vertices[i]);

  00160	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00163	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00166	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00169	6b 45 f0 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  0016d	8b 75 fc	 mov	 esi, DWORD PTR _po$[ebp]
  00170	8b 76 30	 mov	 esi, DWORD PTR [esi+48]
  00173	03 f0		 add	 esi, eax
  00175	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00178	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017a	89 16		 mov	 DWORD PTR [esi], edx
  0017c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0017f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00182	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00185	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00188	eb c2		 jmp	 SHORT $LN2@EV_DoPolyO
$LN3@EV_DoPolyO:

; 2607 : 
; 2608 : 	oldpo = po;

  0018a	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0018d	89 45 f8	 mov	 DWORD PTR _oldpo$[ebp], eax

; 2609 : 
; 2610 : 	// apply action to mirroring polyobjects as well
; 2611 : 	start = 0;

  00190	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN5@EV_DoPolyO:

; 2612 : 	while ((po = Polyobj_GetChild(oldpo, &start)))

  00197	8d 45 ec	 lea	 eax, DWORD PTR _start$[ebp]
  0019a	50		 push	 eax
  0019b	8b 4d f8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  0019e	51		 push	 ecx
  0019f	e8 00 00 00 00	 call	 _Polyobj_GetChild
  001a4	83 c4 08	 add	 esp, 8
  001a7	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  001aa	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  001ae	74 0e		 je	 SHORT $LN6@EV_DoPolyO

; 2613 : 		EV_DoPolyObjFlag(pfdata);

  001b0	8b 45 08	 mov	 eax, DWORD PTR _pfdata$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _EV_DoPolyObjFlag
  001b9	83 c4 04	 add	 esp, 4
  001bc	eb d9		 jmp	 SHORT $LN5@EV_DoPolyO
$LN6@EV_DoPolyO:

; 2614 : 
; 2615 : 	// action was successful
; 2616 : 	return 1;

  001be	b8 01 00 00 00	 mov	 eax, 1
$LN1@EV_DoPolyO:

; 2617 : }

  001c3	5f		 pop	 edi
  001c4	5e		 pop	 esi
  001c5	5b		 pop	 ebx
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
_EV_DoPolyObjFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _EV_DoPolyObjRotate
_TEXT	SEGMENT
_start$ = -16						; size = 4
_th$ = -12						; size = 4
_oldpo$ = -8						; size = 4
_po$ = -4						; size = 4
_prdata$ = 8						; size = 4
_EV_DoPolyObjRotate PROC				; COMDAT

; 2120 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2121 : 	polyobj_t *po;
; 2122 : 	polyobj_t *oldpo;
; 2123 : 	polyrotate_t *th;
; 2124 : 	INT32 start;
; 2125 : 
; 2126 : 	if (!(po = Polyobj_GetForNum(prdata->polyObjNum)))

  00009	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  0001a	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001e	75 1a		 jne	 SHORT $LN4@EV_DoPolyO

; 2127 : 	{
; 2128 : 		CONS_Printf("EV_DoPolyObjRotate: bad polyobj %d\n",

  00020	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	51		 push	 ecx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HHEDECGB@EV_DoPolyObjRotate?3?5bad?5polyobj@
  0002b	e8 00 00 00 00	 call	 _CONS_Printf
  00030	83 c4 08	 add	 esp, 8

; 2129 : 			prdata->polyObjNum);
; 2130 : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	e9 62 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN4@EV_DoPolyO:

; 2131 : 	}
; 2132 : 
; 2133 : 	// don't allow line actions to affect bad polyobjects
; 2134 : 	if (po->isBad)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0003d	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00044	85 c9		 test	 ecx, ecx
  00046	74 07		 je	 SHORT $LN5@EV_DoPolyO

; 2135 : 		return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 4d 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN5@EV_DoPolyO:

; 2136 : 
; 2137 : 	// check for override if this polyobj already has a thinker
; 2138 : 	if (po->thinker && !prdata->overRide)

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00052	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00059	74 12		 je	 SHORT $LN6@EV_DoPolyO
  0005b	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  0005e	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00062	85 c9		 test	 ecx, ecx
  00064	75 07		 jne	 SHORT $LN6@EV_DoPolyO

; 2139 : 		return 0;

  00066	33 c0		 xor	 eax, eax
  00068	e9 2f 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN6@EV_DoPolyO:

; 2140 : 
; 2141 : 	// create a new thinker
; 2142 : 	th = Z_Malloc(sizeof(polyrotate_t), PU_LEVSPEC, NULL);

  0006d	6a 00		 push	 0
  0006f	6a 00		 push	 0
  00071	6a 33		 push	 51			; 00000033H
  00073	6a 1c		 push	 28			; 0000001cH
  00075	e8 00 00 00 00	 call	 _Z_MallocAlign
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	89 45 f4	 mov	 DWORD PTR _th$[ebp], eax

; 2143 : 	th->thinker.function.acp1 = (actionf_p1)T_PolyObjRotate;

  00080	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  00083	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_PolyObjRotate

; 2144 : 	P_AddThinker(&th->thinker);

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _P_AddThinker
  00093	83 c4 04	 add	 esp, 4

; 2145 : 	po->thinker = &th->thinker;

  00096	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  0009c	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2146 : 
; 2147 : 	// set fields
; 2148 : 	th->polyObjNum = prdata->polyObjNum;

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _prdata$[ebp]
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2149 : 
; 2150 : 	// use Hexen-style byte angles for speed and distance
; 2151 : 	th->speed = Polyobj_AngSpeed(prdata->speed * prdata->direction);

  000ad	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _prdata$[ebp]
  000b3	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000b6	0f af 51 04	 imul	 edx, DWORD PTR [ecx+4]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 _Polyobj_AngSpeed
  000c0	83 c4 04	 add	 esp, 4
  000c3	8b 4d f4	 mov	 ecx, DWORD PTR _th$[ebp]
  000c6	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 2152 : 
; 2153 : 	if (prdata->distance == 360)    // 360 means perpetual

  000c9	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  000cc	81 78 0c 68 01
	00 00		 cmp	 DWORD PTR [eax+12], 360	; 00000168H
  000d3	75 0c		 jne	 SHORT $LN7@EV_DoPolyO

; 2154 : 		th->distance = -1;

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000d8	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [eax+24], -1
  000df	eb 2d		 jmp	 SHORT $LN10@EV_DoPolyO
$LN7@EV_DoPolyO:

; 2155 : 	else if (prdata->distance == 0) // 0 means 360 degrees

  000e1	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  000e4	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000e8	75 0c		 jne	 SHORT $LN9@EV_DoPolyO

; 2156 : 		th->distance = 0xffffffff - 1;

  000ea	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000ed	c7 40 18 fe ff
	ff ff		 mov	 DWORD PTR [eax+24], -2	; fffffffeH
  000f4	eb 18		 jmp	 SHORT $LN10@EV_DoPolyO
$LN9@EV_DoPolyO:

; 2157 : 	else
; 2158 : 		th->distance = FixedAngle(prdata->distance*FRACUNIT);

  000f6	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  000f9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000fc	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 _FixedAngle
  00105	83 c4 04	 add	 esp, 4
  00108	8b 55 f4	 mov	 edx, DWORD PTR _th$[ebp]
  0010b	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN10@EV_DoPolyO:

; 2159 : 
; 2160 : 	// set polyobject's thrust
; 2161 : 	po->thrust = abs(th->speed) >> 8;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  00111	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 _abs
  0011a	83 c4 04	 add	 esp, 4
  0011d	c1 f8 08	 sar	 eax, 8
  00120	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  00123	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 2162 : 	if (po->thrust < FRACUNIT)

  00129	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0012c	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00136	7d 0f		 jge	 SHORT $LN11@EV_DoPolyO

; 2163 : 		po->thrust = FRACUNIT;

  00138	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0013b	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  00145	eb 1c		 jmp	 SHORT $LN13@EV_DoPolyO
$LN11@EV_DoPolyO:

; 2164 : 	else if (po->thrust > 4*FRACUNIT)

  00147	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0014a	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  00154	7e 0d		 jle	 SHORT $LN13@EV_DoPolyO

; 2165 : 		po->thrust = 4*FRACUNIT;

  00156	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00159	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN13@EV_DoPolyO:

; 2166 : 
; 2167 : 	// TODO: start sound sequence event
; 2168 : 
; 2169 : 	oldpo = po;

  00163	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00166	89 45 f8	 mov	 DWORD PTR _oldpo$[ebp], eax

; 2170 : 
; 2171 : 	// apply action to mirroring polyobjects as well
; 2172 : 	start = 0;

  00169	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN2@EV_DoPolyO:

; 2173 : 	while ((po = Polyobj_GetChild(oldpo, &start)))

  00170	8d 45 f0	 lea	 eax, DWORD PTR _start$[ebp]
  00173	50		 push	 eax
  00174	8b 4d f8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 _Polyobj_GetChild
  0017d	83 c4 08	 add	 esp, 8
  00180	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  00183	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00187	74 0e		 je	 SHORT $LN3@EV_DoPolyO

; 2174 : 		EV_DoPolyObjRotate(prdata);

  00189	8b 45 08	 mov	 eax, DWORD PTR _prdata$[ebp]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 _EV_DoPolyObjRotate
  00192	83 c4 04	 add	 esp, 4
  00195	eb d9		 jmp	 SHORT $LN2@EV_DoPolyO
$LN3@EV_DoPolyO:

; 2175 : 
; 2176 : 	// action was successful
; 2177 : 	return 1;

  00197	b8 01 00 00 00	 mov	 eax, 1
$LN1@EV_DoPolyO:

; 2178 : }

  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
_EV_DoPolyObjRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _EV_DoPolyObjWaypoint
_TEXT	SEGMENT
_wp$ = -28						; size = 4
_target$ = -24						; size = 4
_last$ = -20						; size = 4
_first$ = -16						; size = 4
_mo2$ = -12						; size = 4
_th$ = -8						; size = 4
_po$ = -4						; size = 4
_pwdata$ = 8						; size = 4
_EV_DoPolyObjWaypoint PROC				; COMDAT

; 2238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2239 : 	polyobj_t *po;
; 2240 : 	polywaypoint_t *th;
; 2241 : 	mobj_t *mo2;
; 2242 : 	mobj_t *first = NULL;

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0

; 2243 : 	mobj_t *last = NULL;

  00010	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _last$[ebp], 0

; 2244 : 	mobj_t *target = NULL;

  00017	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _target$[ebp], 0

; 2245 : 	thinker_t *wp;
; 2246 : 
; 2247 : 	if (!(po = Polyobj_GetForNum(pwdata->polyObjNum)))

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pwdata$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  0002f	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00033	75 1a		 jne	 SHORT $LN5@EV_DoPolyO

; 2248 : 	{
; 2249 : 		CONS_Printf("EV_DoPolyObjWaypoint: bad polyobj %d\n",

  00035	8b 45 08	 mov	 eax, DWORD PTR _pwdata$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GPADFMGC@EV_DoPolyObjWaypoint?3?5bad?5polyo@
  00040	e8 00 00 00 00	 call	 _CONS_Printf
  00045	83 c4 08	 add	 esp, 8

; 2250 : 			pwdata->polyObjNum);
; 2251 : 		return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 dc 02 00 00	 jmp	 $LN1@EV_DoPolyO
$LN5@EV_DoPolyO:

; 2252 : 	}
; 2253 : 
; 2254 : 	// don't allow line actions to affect bad polyobjects
; 2255 : 	if (po->isBad)

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00052	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00059	85 c9		 test	 ecx, ecx
  0005b	74 07		 je	 SHORT $LN6@EV_DoPolyO

; 2256 : 		return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 c7 02 00 00	 jmp	 $LN1@EV_DoPolyO
$LN6@EV_DoPolyO:

; 2257 : 
; 2258 : 	if (po->thinker) // Don't crowd out another thinker.

  00064	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00067	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  0006e	74 07		 je	 SHORT $LN7@EV_DoPolyO

; 2259 : 		return 0;

  00070	33 c0		 xor	 eax, eax
  00072	e9 b4 02 00 00	 jmp	 $LN1@EV_DoPolyO
$LN7@EV_DoPolyO:

; 2260 : 
; 2261 : 	// create a new thinker
; 2262 : 	th = Z_Malloc(sizeof(polywaypoint_t), PU_LEVSPEC, NULL);

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	6a 33		 push	 51			; 00000033H
  0007d	6a 34		 push	 52			; 00000034H
  0007f	e8 00 00 00 00	 call	 _Z_MallocAlign
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	89 45 f8	 mov	 DWORD PTR _th$[ebp], eax

; 2263 : 	th->thinker.function.acp1 = (actionf_p1)T_PolyObjWaypoint;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0008d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_PolyObjWaypoint

; 2264 : 	P_AddThinker(&th->thinker);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _P_AddThinker
  0009d	83 c4 04	 add	 esp, 4

; 2265 : 	po->thinker = &th->thinker;

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  000a6	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2266 : 
; 2267 : 	// set fields
; 2268 : 	th->polyObjNum = pwdata->polyObjNum;

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _pwdata$[ebp]
  000b2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b4	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2269 : 	th->speed = pwdata->speed;

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _pwdata$[ebp]
  000bd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c0	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2270 : 	th->sequence = pwdata->sequence; // Used to specify sequence #

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pwdata$[ebp]
  000c9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000cc	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 2271 : 	if (pwdata->reverse)

  000cf	8b 45 08	 mov	 eax, DWORD PTR _pwdata$[ebp]
  000d2	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  000d6	85 c9		 test	 ecx, ecx
  000d8	74 0c		 je	 SHORT $LN8@EV_DoPolyO

; 2272 : 		th->direction = -1;

  000da	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000dd	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [eax+32], -1
  000e4	eb 0a		 jmp	 SHORT $LN9@EV_DoPolyO
$LN8@EV_DoPolyO:

; 2273 : 	else
; 2274 : 		th->direction = 1;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000e9	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1
$LN9@EV_DoPolyO:

; 2275 : 
; 2276 : 	th->comeback = pwdata->comeback;

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _pwdata$[ebp]
  000f6	8a 51 0d	 mov	 dl, BYTE PTR [ecx+13]
  000f9	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 2277 : 	th->continuous = pwdata->continuous;

  000fc	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _pwdata$[ebp]
  00102	8a 51 0f	 mov	 dl, BYTE PTR [ecx+15]
  00105	88 50 26	 mov	 BYTE PTR [eax+38], dl

; 2278 : 	th->wrap = pwdata->wrap;

  00108	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _pwdata$[ebp]
  0010e	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  00111	88 50 25	 mov	 BYTE PTR [eax+37], dl

; 2279 : 	th->stophere = false;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00117	c6 40 27 00	 mov	 BYTE PTR [eax+39], 0

; 2280 : 
; 2281 : 	// Find the first waypoint we need to use
; 2282 : 	for (wp = thinkercap.next; wp != &thinkercap; wp = wp->next)

  0011b	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00120	89 45 e4	 mov	 DWORD PTR _wp$[ebp], eax
  00123	eb 09		 jmp	 SHORT $LN4@EV_DoPolyO
$LN2@EV_DoPolyO:
  00125	8b 45 e4	 mov	 eax, DWORD PTR _wp$[ebp]
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	89 4d e4	 mov	 DWORD PTR _wp$[ebp], ecx
$LN4@EV_DoPolyO:
  0012e	81 7d e4 00 00
	00 00		 cmp	 DWORD PTR _wp$[ebp], OFFSET _thinkercap
  00135	0f 84 bf 00 00
	00		 je	 $LN3@EV_DoPolyO

; 2283 : 	{
; 2284 : 		if (wp->function.acp1 != (actionf_p1)P_MobjThinker) // Not a mobj thinker

  0013b	8b 45 e4	 mov	 eax, DWORD PTR _wp$[ebp]
  0013e	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  00145	74 02		 je	 SHORT $LN10@EV_DoPolyO

; 2285 : 			continue;

  00147	eb dc		 jmp	 SHORT $LN2@EV_DoPolyO
$LN10@EV_DoPolyO:

; 2286 : 
; 2287 : 		mo2 = (mobj_t *)wp;

  00149	8b 45 e4	 mov	 eax, DWORD PTR _wp$[ebp]
  0014c	89 45 f4	 mov	 DWORD PTR _mo2$[ebp], eax

; 2288 : 
; 2289 : 		if (mo2->type != MT_TUBEWAYPOINT)

  0014f	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  00152	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  00159	74 02		 je	 SHORT $LN11@EV_DoPolyO

; 2290 : 			continue;

  0015b	eb c8		 jmp	 SHORT $LN2@EV_DoPolyO
$LN11@EV_DoPolyO:

; 2291 : 
; 2292 : 		if (mo2->threshold == th->sequence)

  0015d	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  00160	8b 4d f8	 mov	 ecx, DWORD PTR _th$[ebp]
  00163	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  00169	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0016c	0f 85 83 00 00
	00		 jne	 $LN24@EV_DoPolyO

; 2293 : 		{
; 2294 : 			if (th->direction == -1) // highest waypoint #

  00172	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00175	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  00179	75 3e		 jne	 SHORT $LN13@EV_DoPolyO

; 2295 : 			{
; 2296 : 				if (mo2->health == 0)

  0017b	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  0017e	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  00185	75 08		 jne	 SHORT $LN15@EV_DoPolyO

; 2297 : 					last = mo2;

  00187	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  0018a	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
  0018d	eb 28		 jmp	 SHORT $LN19@EV_DoPolyO
$LN15@EV_DoPolyO:

; 2298 : 				else
; 2299 : 				{
; 2300 : 					if (first == NULL)

  0018f	83 7d f0 00	 cmp	 DWORD PTR _first$[ebp], 0
  00193	75 08		 jne	 SHORT $LN17@EV_DoPolyO

; 2301 : 						first = mo2;

  00195	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  00198	89 45 f0	 mov	 DWORD PTR _first$[ebp], eax
  0019b	eb 1a		 jmp	 SHORT $LN19@EV_DoPolyO
$LN17@EV_DoPolyO:

; 2302 : 					else if (mo2->health > first->health)

  0019d	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR _first$[ebp]
  001a3	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  001a9	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  001af	7e 06		 jle	 SHORT $LN19@EV_DoPolyO

; 2303 : 						first = mo2;

  001b1	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001b4	89 45 f0	 mov	 DWORD PTR _first$[ebp], eax
$LN19@EV_DoPolyO:

; 2304 : 				}
; 2305 : 			}

  001b7	eb 3c		 jmp	 SHORT $LN24@EV_DoPolyO
$LN13@EV_DoPolyO:

; 2306 : 			else // waypoint 0
; 2307 : 			{
; 2308 : 				if (mo2->health == 0)

  001b9	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001bc	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  001c3	75 08		 jne	 SHORT $LN20@EV_DoPolyO

; 2309 : 					first = mo2;

  001c5	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001c8	89 45 f0	 mov	 DWORD PTR _first$[ebp], eax
  001cb	eb 28		 jmp	 SHORT $LN24@EV_DoPolyO
$LN20@EV_DoPolyO:

; 2310 : 				else
; 2311 : 				{
; 2312 : 					if (last == NULL)

  001cd	83 7d ec 00	 cmp	 DWORD PTR _last$[ebp], 0
  001d1	75 08		 jne	 SHORT $LN22@EV_DoPolyO

; 2313 : 						last = mo2;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001d6	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
  001d9	eb 1a		 jmp	 SHORT $LN24@EV_DoPolyO
$LN22@EV_DoPolyO:

; 2314 : 					else if (mo2->health > last->health)

  001db	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001de	8b 4d ec	 mov	 ecx, DWORD PTR _last$[ebp]
  001e1	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  001e7	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  001ed	7e 06		 jle	 SHORT $LN24@EV_DoPolyO

; 2315 : 						last = mo2;

  001ef	8b 45 f4	 mov	 eax, DWORD PTR _mo2$[ebp]
  001f2	89 45 ec	 mov	 DWORD PTR _last$[ebp], eax
$LN24@EV_DoPolyO:

; 2316 : 				}
; 2317 : 			}
; 2318 : 		}
; 2319 : 	}

  001f5	e9 2b ff ff ff	 jmp	 $LN2@EV_DoPolyO
$LN3@EV_DoPolyO:

; 2320 : 
; 2321 : 	if (!first)

  001fa	83 7d f0 00	 cmp	 DWORD PTR _first$[ebp], 0
  001fe	75 2d		 jne	 SHORT $LN25@EV_DoPolyO

; 2322 : 	{
; 2323 : 		CONS_Printf("EV_DoPolyObjWaypoint: Missing starting waypoint!\n");

  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EFOAJPAK@EV_DoPolyObjWaypoint?3?5Missing?5s@
  00205	e8 00 00 00 00	 call	 _CONS_Printf
  0020a	83 c4 04	 add	 esp, 4

; 2324 : 		po->thinker = NULL;

  0020d	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00210	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 2325 : 		P_RemoveThinker(&th->thinker);

  0021a	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _P_RemoveThinker
  00223	83 c4 04	 add	 esp, 4

; 2326 : 		return 0;

  00226	33 c0		 xor	 eax, eax
  00228	e9 fe 00 00 00	 jmp	 $LN1@EV_DoPolyO
$LN25@EV_DoPolyO:

; 2327 : 	}
; 2328 : 
; 2329 : 	// Set diffx, diffy, diffz
; 2330 : 	// Put these at 0 for now...might not be needed after all.
; 2331 : 	th->diffx = 0;//first->x - po->centerPt.x;

  0022d	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00230	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 2332 : 	th->diffy = 0;//first->y - po->centerPt.y;

  00237	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0023a	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2333 : 	th->diffz = 0;//first->z - (po->lines[0]->backsector->floorheight + (po->lines[0]->backsector->ceilingheight - po->lines[0]->backsector->floorheight)/2);

  00241	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00244	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 2334 : 
; 2335 : 	if (last->x == po->centerPt.x
; 2336 : 		&& last->y == po->centerPt.y
; 2337 : 		&& last->z == (po->lines[0]->backsector->floorheight + (po->lines[0]->backsector->ceilingheight - po->lines[0]->backsector->floorheight)/2))

  0024b	8b 45 ec	 mov	 eax, DWORD PTR _last$[ebp]
  0024e	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00251	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00254	3b 51 60	 cmp	 edx, DWORD PTR [ecx+96]
  00257	0f 85 84 00 00
	00		 jne	 $LN27@EV_DoPolyO
  0025d	8b 45 ec	 mov	 eax, DWORD PTR _last$[ebp]
  00260	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00263	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00266	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  00269	75 76		 jne	 SHORT $LN27@EV_DoPolyO
  0026b	b8 04 00 00 00	 mov	 eax, 4
  00270	6b c8 00	 imul	 ecx, eax, 0
  00273	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  00276	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00279	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0027c	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0027f	ba 04 00 00 00	 mov	 edx, 4
  00284	6b c2 00	 imul	 eax, edx, 0
  00287	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  0028a	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  0028d	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00290	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00293	b8 04 00 00 00	 mov	 eax, 4
  00298	6b c0 00	 imul	 eax, eax, 0
  0029b	8b 75 fc	 mov	 esi, DWORD PTR _po$[ebp]
  0029e	8b 76 40	 mov	 esi, DWORD PTR [esi+64]
  002a1	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  002a4	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  002a7	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  002aa	2b 10		 sub	 edx, DWORD PTR [eax]
  002ac	8b c2		 mov	 eax, edx
  002ae	99		 cdq
  002af	2b c2		 sub	 eax, edx
  002b1	d1 f8		 sar	 eax, 1
  002b3	03 01		 add	 eax, DWORD PTR [ecx]
  002b5	8b 4d ec	 mov	 ecx, DWORD PTR _last$[ebp]
  002b8	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  002bb	75 24		 jne	 SHORT $LN27@EV_DoPolyO

; 2338 : 	{
; 2339 : 		// Already at the destination point...
; 2340 : 		if (!th->wrap)

  002bd	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  002c0	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  002c4	85 c9		 test	 ecx, ecx
  002c6	75 19		 jne	 SHORT $LN27@EV_DoPolyO

; 2341 : 		{
; 2342 : 			po->thinker = NULL;

  002c8	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  002cb	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 2343 : 			P_RemoveThinker(&th->thinker);

  002d5	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  002d8	50		 push	 eax
  002d9	e8 00 00 00 00	 call	 _P_RemoveThinker
  002de	83 c4 04	 add	 esp, 4
$LN27@EV_DoPolyO:

; 2344 : 		}
; 2345 : 	}
; 2346 : 
; 2347 : 	// Find the actual target movement waypoint
; 2348 : 	target = first;

  002e1	8b 45 f0	 mov	 eax, DWORD PTR _first$[ebp]
  002e4	89 45 e8	 mov	 DWORD PTR _target$[ebp], eax

; 2349 : 	/*for (wp = thinkercap.next; wp != &thinkercap; wp = wp->next)
; 2350 : 	{
; 2351 : 		if (wp->function.acp1 != (actionf_p1)P_MobjThinker) // Not a mobj thinker
; 2352 : 			continue;
; 2353 : 
; 2354 : 		mo2 = (mobj_t *)wp;
; 2355 : 
; 2356 : 		if (mo2->type != MT_TUBEWAYPOINT)
; 2357 : 			continue;
; 2358 : 
; 2359 : 		if (mo2->threshold == th->sequence)
; 2360 : 		{
; 2361 : 			if (th->direction == -1) // highest waypoint #
; 2362 : 			{
; 2363 : 				if (mo2->health == first->health - 1)
; 2364 : 				{
; 2365 : 					target = mo2;
; 2366 : 					break;
; 2367 : 				}
; 2368 : 			}
; 2369 : 			else // waypoint 0
; 2370 : 			{
; 2371 : 				if (mo2->health == first->health + 1)
; 2372 : 				{
; 2373 : 					target = mo2;
; 2374 : 					break;
; 2375 : 				}
; 2376 : 			}
; 2377 : 		}
; 2378 : 	}*/
; 2379 : 
; 2380 : 	if (!target)

  002e7	83 7d e8 00	 cmp	 DWORD PTR _target$[ebp], 0
  002eb	75 2a		 jne	 SHORT $LN28@EV_DoPolyO

; 2381 : 	{
; 2382 : 		CONS_Printf("EV_DoPolyObjWaypoint: Missing target waypoint!\n");

  002ed	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IDOMMLDN@EV_DoPolyObjWaypoint?3?5Missing?5t@
  002f2	e8 00 00 00 00	 call	 _CONS_Printf
  002f7	83 c4 04	 add	 esp, 4

; 2383 : 		po->thinker = NULL;

  002fa	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  002fd	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 2384 : 		P_RemoveThinker(&th->thinker);

  00307	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 _P_RemoveThinker
  00310	83 c4 04	 add	 esp, 4

; 2385 : 		return 0;

  00313	33 c0		 xor	 eax, eax
  00315	eb 14		 jmp	 SHORT $LN1@EV_DoPolyO
$LN28@EV_DoPolyO:

; 2386 : 	}
; 2387 : 
; 2388 : 	// Set pointnum
; 2389 : 	th->pointnum = target->health;

  00317	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0031a	8b 4d e8	 mov	 ecx, DWORD PTR _target$[ebp]
  0031d	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  00323	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 2390 : 
; 2391 : 	// We don't deal with the mirror crap here, we'll
; 2392 : 	// handle that in the T_Thinker function.
; 2393 : 	return 1;

  00326	b8 01 00 00 00	 mov	 eax, 1
$LN1@EV_DoPolyO:

; 2394 : }

  0032b	5f		 pop	 edi
  0032c	5e		 pop	 esi
  0032d	5b		 pop	 ebx
  0032e	8b e5		 mov	 esp, ebp
  00330	5d		 pop	 ebp
  00331	c3		 ret	 0
_EV_DoPolyObjWaypoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _EV_DoPolyObjMove
_TEXT	SEGMENT
_start$ = -16						; size = 4
_th$ = -12						; size = 4
_oldpo$ = -8						; size = 4
_po$ = -4						; size = 4
_pmdata$ = 8						; size = 4
_EV_DoPolyObjMove PROC					; COMDAT

; 2181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2182 : 	polyobj_t *po;
; 2183 : 	polyobj_t *oldpo;
; 2184 : 	polymove_t *th;
; 2185 : 	INT32 start;
; 2186 : 
; 2187 : 	if (!(po = Polyobj_GetForNum(pmdata->polyObjNum)))

  00009	8b 45 08	 mov	 eax, DWORD PTR _pmdata$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  0001a	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001e	75 1a		 jne	 SHORT $LN4@EV_DoPolyO

; 2188 : 	{
; 2189 : 		CONS_Printf("EV_DoPolyObjMove: bad polyobj %d\n",

  00020	8b 45 08	 mov	 eax, DWORD PTR _pmdata$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	51		 push	 ecx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KHKDIAJP@EV_DoPolyObjMove?3?5bad?5polyobj?5?$CF@
  0002b	e8 00 00 00 00	 call	 _CONS_Printf
  00030	83 c4 08	 add	 esp, 8

; 2190 : 			pmdata->polyObjNum);
; 2191 : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	e9 4c 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN4@EV_DoPolyO:

; 2192 : 	}
; 2193 : 
; 2194 : 	// don't allow line actions to affect bad polyobjects
; 2195 : 	if (po->isBad)

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0003d	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00044	85 c9		 test	 ecx, ecx
  00046	74 07		 je	 SHORT $LN5@EV_DoPolyO

; 2196 : 		return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 37 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN5@EV_DoPolyO:

; 2197 : 
; 2198 : 	// check for override if this polyobj already has a thinker
; 2199 : 	if (po->thinker && !pmdata->overRide)

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00052	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00059	74 12		 je	 SHORT $LN6@EV_DoPolyO
  0005b	8b 45 08	 mov	 eax, DWORD PTR _pmdata$[ebp]
  0005e	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00062	85 c9		 test	 ecx, ecx
  00064	75 07		 jne	 SHORT $LN6@EV_DoPolyO

; 2200 : 		return 0;

  00066	33 c0		 xor	 eax, eax
  00068	e9 19 01 00 00	 jmp	 $LN1@EV_DoPolyO
$LN6@EV_DoPolyO:

; 2201 : 
; 2202 : 	// create a new thinker
; 2203 : 	th = Z_Malloc(sizeof(polymove_t), PU_LEVSPEC, NULL);

  0006d	6a 00		 push	 0
  0006f	6a 00		 push	 0
  00071	6a 33		 push	 51			; 00000033H
  00073	6a 28		 push	 40			; 00000028H
  00075	e8 00 00 00 00	 call	 _Z_MallocAlign
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	89 45 f4	 mov	 DWORD PTR _th$[ebp], eax

; 2204 : 	th->thinker.function.acp1 = (actionf_p1)T_PolyObjMove;

  00080	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  00083	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _T_PolyObjMove

; 2205 : 	P_AddThinker(&th->thinker);

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _P_AddThinker
  00093	83 c4 04	 add	 esp, 4

; 2206 : 	po->thinker = &th->thinker;

  00096	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  0009c	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2207 : 
; 2208 : 	// set fields
; 2209 : 	th->polyObjNum = pmdata->polyObjNum;

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _pmdata$[ebp]
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2210 : 	th->distance   = pmdata->distance;

  000ad	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _pmdata$[ebp]
  000b3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b6	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 2211 : 	th->speed      = pmdata->speed;

  000b9	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _pmdata$[ebp]
  000bf	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c2	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2212 : 	th->angle      = pmdata->angle >> ANGLETOFINESHIFT;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _pmdata$[ebp]
  000c8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000cb	c1 e9 13	 shr	 ecx, 19			; 00000013H
  000ce	8b 55 f4	 mov	 edx, DWORD PTR _th$[ebp]
  000d1	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 2213 : 
; 2214 : 	// set component speeds
; 2215 : 	Polyobj_componentSpeed(th->speed, th->angle, &th->momx, &th->momy);

  000d4	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000d7	83 c0 1c	 add	 eax, 28			; 0000001cH
  000da	50		 push	 eax
  000db	8b 4d f4	 mov	 ecx, DWORD PTR _th$[ebp]
  000de	83 c1 18	 add	 ecx, 24			; 00000018H
  000e1	51		 push	 ecx
  000e2	8b 55 f4	 mov	 edx, DWORD PTR _th$[ebp]
  000e5	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000e8	50		 push	 eax
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _th$[ebp]
  000ec	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  000f5	83 c4 10	 add	 esp, 16			; 00000010H

; 2216 : 
; 2217 : 	// set polyobject's thrust
; 2218 : 	po->thrust = abs(th->speed) >> 3;

  000f8	8b 45 f4	 mov	 eax, DWORD PTR _th$[ebp]
  000fb	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _abs
  00104	83 c4 04	 add	 esp, 4
  00107	c1 f8 03	 sar	 eax, 3
  0010a	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  0010d	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 2219 : 	if (po->thrust < FRACUNIT)

  00113	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00116	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00120	7d 0f		 jge	 SHORT $LN7@EV_DoPolyO

; 2220 : 		po->thrust = FRACUNIT;

  00122	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00125	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  0012f	eb 1c		 jmp	 SHORT $LN9@EV_DoPolyO
$LN7@EV_DoPolyO:

; 2221 : 	else if (po->thrust > 4*FRACUNIT)

  00131	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00134	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  0013e	7e 0d		 jle	 SHORT $LN9@EV_DoPolyO

; 2222 : 		po->thrust = 4*FRACUNIT;

  00140	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00143	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN9@EV_DoPolyO:

; 2223 : 
; 2224 : 	// TODO: start sound sequence event
; 2225 : 
; 2226 : 	oldpo = po;

  0014d	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00150	89 45 f8	 mov	 DWORD PTR _oldpo$[ebp], eax

; 2227 : 
; 2228 : 	// apply action to mirroring polyobjects as well
; 2229 : 	start = 0;

  00153	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN2@EV_DoPolyO:

; 2230 : 	while ((po = Polyobj_GetChild(oldpo, &start)))

  0015a	8d 45 f0	 lea	 eax, DWORD PTR _start$[ebp]
  0015d	50		 push	 eax
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _Polyobj_GetChild
  00167	83 c4 08	 add	 esp, 8
  0016a	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  0016d	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00171	74 0e		 je	 SHORT $LN3@EV_DoPolyO

; 2231 : 		EV_DoPolyObjMove(pmdata);

  00173	8b 45 08	 mov	 eax, DWORD PTR _pmdata$[ebp]
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _EV_DoPolyObjMove
  0017c	83 c4 04	 add	 esp, 4
  0017f	eb d9		 jmp	 SHORT $LN2@EV_DoPolyO
$LN3@EV_DoPolyO:

; 2232 : 
; 2233 : 	// action was successful
; 2234 : 	return 1;

  00181	b8 01 00 00 00	 mov	 eax, 1
$LN1@EV_DoPolyO:

; 2235 : }

  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
_EV_DoPolyObjMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _EV_DoPolyDoor
_TEXT	SEGMENT
tv77 = -72						; size = 4
_po$ = -4						; size = 4
_doordata$ = 8						; size = 4
_EV_DoPolyDoor PROC					; COMDAT

; 2486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2487 : 	polyobj_t *po;
; 2488 : 
; 2489 : 	if (!(po = Polyobj_GetForNum(doordata->polyObjNum)))

  00009	8b 45 08	 mov	 eax, DWORD PTR _doordata$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax
  0001a	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001e	75 17		 jne	 SHORT $LN4@EV_DoPolyD

; 2490 : 	{
; 2491 : 		CONS_Printf("EV_DoPolyDoor: bad polyobj %d\n",

  00020	8b 45 08	 mov	 eax, DWORD PTR _doordata$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	51		 push	 ecx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BIDPEPNN@EV_DoPolyDoor?3?5bad?5polyobj?5?$CFd?6@
  0002b	e8 00 00 00 00	 call	 _CONS_Printf
  00030	83 c4 08	 add	 esp, 8

; 2492 : 						doordata->polyObjNum);
; 2493 : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	eb 76		 jmp	 SHORT $LN1@EV_DoPolyD
$LN4@EV_DoPolyD:

; 2494 : 	}
; 2495 : 
; 2496 : 	// don't allow line actions to affect bad polyobjects;
; 2497 : 	// polyobject doors don't allow action overrides
; 2498 : 	if (po->isBad || po->thinker)

  00037	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0003a	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00041	85 c9		 test	 ecx, ecx
  00043	75 0c		 jne	 SHORT $LN6@EV_DoPolyD
  00045	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00048	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  0004f	74 04		 je	 SHORT $LN5@EV_DoPolyD
$LN6@EV_DoPolyD:

; 2499 : 		return 0;

  00051	33 c0		 xor	 eax, eax
  00053	eb 58		 jmp	 SHORT $LN1@EV_DoPolyD
$LN5@EV_DoPolyD:

; 2500 : 
; 2501 : 	switch (doordata->doorType)

  00055	8b 45 08	 mov	 eax, DWORD PTR _doordata$[ebp]
  00058	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005b	89 4d b8	 mov	 DWORD PTR tv77[ebp], ecx
  0005e	83 7d b8 00	 cmp	 DWORD PTR tv77[ebp], 0
  00062	74 08		 je	 SHORT $LN7@EV_DoPolyD
  00064	83 7d b8 01	 cmp	 DWORD PTR tv77[ebp], 1
  00068	74 14		 je	 SHORT $LN8@EV_DoPolyD
  0006a	eb 24		 jmp	 SHORT $LN9@EV_DoPolyD
$LN7@EV_DoPolyD:

; 2502 : 	{
; 2503 : 	case POLY_DOOR_SLIDE:
; 2504 : 		Polyobj_doSlideDoor(po, doordata);

  0006c	8b 45 08	 mov	 eax, DWORD PTR _doordata$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 _Polyobj_doSlideDoor
  00079	83 c4 08	 add	 esp, 8

; 2505 : 		break;

  0007c	eb 2a		 jmp	 SHORT $LN2@EV_DoPolyD
$LN8@EV_DoPolyD:

; 2506 : 	case POLY_DOOR_SWING:
; 2507 : 		Polyobj_doSwingDoor(po, doordata);

  0007e	8b 45 08	 mov	 eax, DWORD PTR _doordata$[ebp]
  00081	50		 push	 eax
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _Polyobj_doSwingDoor
  0008b	83 c4 08	 add	 esp, 8

; 2508 : 		break;

  0008e	eb 18		 jmp	 SHORT $LN2@EV_DoPolyD
$LN9@EV_DoPolyD:

; 2509 : 	default:
; 2510 : 		CONS_Printf("EV_DoPolyDoor: unknown door type %d",

  00090	8b 45 08	 mov	 eax, DWORD PTR _doordata$[ebp]
  00093	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00096	51		 push	 ecx
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FPAINNDC@EV_DoPolyDoor?3?5unknown?5door?5typ@
  0009c	e8 00 00 00 00	 call	 _CONS_Printf
  000a1	83 c4 08	 add	 esp, 8

; 2511 : 						doordata->doorType);
; 2512 : 		return 0;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 05		 jmp	 SHORT $LN1@EV_DoPolyD
$LN2@EV_DoPolyD:

; 2513 : 	}
; 2514 : 
; 2515 : 	return 1;

  000a8	b8 01 00 00 00	 mov	 eax, 1
$LN1@EV_DoPolyD:

; 2516 : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
_EV_DoPolyDoor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _T_PolyObjFlag
_TEXT	SEGMENT
_sine$1 = -28						; size = 4
_vec$2 = -24						; size = 12
_i$ = -12						; size = 4
_po$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_th$ = 8						; size = 4
_T_PolyObjFlag PROC					; COMDAT

; 2519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2520 : 	polyobj_t *po = Polyobj_GetForNum(th->polyObjNum);

  00013	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00016	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 f8	 mov	 DWORD PTR _po$[ebp], eax

; 2521 : 	size_t i;
; 2522 : 
; 2523 : 	if (!po)

  00025	83 7d f8 00	 cmp	 DWORD PTR _po$[ebp], 0
  00029	75 25		 jne	 SHORT $LN8@T_PolyObjF

; 2524 : #ifdef RANGECHECK
; 2525 : 		I_Error("T_PolyObjFlag: thinker has invalid id %d\n", th->polyObjNum);
; 2526 : #else
; 2527 : 	{
; 2528 : 		CONS_Printf("T_PolyObjFlag: thinker with invalid id %d removed.\n", th->polyObjNum);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0002e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00031	51		 push	 ecx
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@BLCKHLDP@T_PolyObjFlag?3?5thinker?5with?5inv@
  00037	e8 00 00 00 00	 call	 _CONS_Printf
  0003c	83 c4 08	 add	 esp, 8

; 2529 : 		P_RemoveThinkerDelayed(&th->thinker);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _P_RemoveThinkerDelayed
  00048	83 c4 04	 add	 esp, 4

; 2530 : 		return;

  0004b	e9 4b 01 00 00	 jmp	 $LN1@T_PolyObjF
$LN8@T_PolyObjF:

; 2531 : 	}
; 2532 : #endif
; 2533 : 
; 2534 : 	// check for displacement due to override and reattach when possible
; 2535 : 	if (po->thinker == NULL)

  00050	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00053	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  0005a	75 0c		 jne	 SHORT $LN9@T_PolyObjF

; 2536 : 		po->thinker = &th->thinker;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  00062	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax
$LN9@T_PolyObjF:

; 2537 : 
; 2538 : 	// Iterate through polyobject's vertices
; 2539 : 	for (i = 0; i < po->numVertices/2; i++)

  00068	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006f	eb 09		 jmp	 SHORT $LN4@T_PolyObjF
$LN2@T_PolyObjF:
  00071	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@T_PolyObjF:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0007d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00080	d1 e9		 shr	 ecx, 1
  00082	39 4d f4	 cmp	 DWORD PTR _i$[ebp], ecx
  00085	0f 83 ac 00 00
	00		 jae	 $LN3@T_PolyObjF

; 2540 : 	{
; 2541 : 		vertex_t vec;
; 2542 : 		fixed_t sine = FINESINE(th->distance)*th->momx;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0008e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00091	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00094	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR _finesine[ecx*4]
  0009b	0f af 42 18	 imul	 eax, DWORD PTR [edx+24]
  0009f	89 45 e4	 mov	 DWORD PTR _sine$1[ebp], eax

; 2543 : 
; 2544 : 		Polyobj_componentSpeed(sine, th->angle, &vec.x, &vec.y);

  000a2	8d 45 ec	 lea	 eax, DWORD PTR _vec$2[ebp+4]
  000a5	50		 push	 eax
  000a6	8d 4d e8	 lea	 ecx, DWORD PTR _vec$2[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000ad	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b0	50		 push	 eax
  000b1	8b 4d e4	 mov	 ecx, DWORD PTR _sine$1[ebp]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  000ba	83 c4 10	 add	 esp, 16			; 00000010H

; 2545 : 
; 2546 : 		po->vertices[i]->x = po->tmpVerts[i].x;

  000bd	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  000c4	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  000ca	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  000cd	8b 75 f4	 mov	 esi, DWORD PTR _i$[ebp]
  000d0	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  000d3	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  000d6	89 11		 mov	 DWORD PTR [ecx], edx

; 2547 : 		po->vertices[i]->y = po->tmpVerts[i].y;

  000d8	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  000dc	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  000df	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  000e5	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  000e8	8b 75 f4	 mov	 esi, DWORD PTR _i$[ebp]
  000eb	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  000ee	8b 54 02 04	 mov	 edx, DWORD PTR [edx+eax+4]
  000f2	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2548 : 
; 2549 : 		Polyobj_vecAdd(po->vertices[i], &vec);

  000f5	8d 45 e8	 lea	 eax, DWORD PTR _vec$2[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _po$[ebp]
  000fc	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000ff	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00102	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 _Polyobj_vecAdd
  0010b	83 c4 08	 add	 esp, 8

; 2550 : 
; 2551 : 		th->distance += th->speed;

  0010e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00111	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00114	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00117	03 4a 14	 add	 ecx, DWORD PTR [edx+20]
  0011a	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0011d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2552 : 		th->distance &= FINEMASK;

  00120	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00123	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00126	81 e1 ff 1f 00
	00		 and	 ecx, 8191		; 00001fffH
  0012c	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  0012f	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 2553 : 	}

  00132	e9 3a ff ff ff	 jmp	 $LN2@T_PolyObjF
$LN3@T_PolyObjF:

; 2554 : 
; 2555 : 	for (i = 0; i < po->numLines; i++)

  00137	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013e	eb 09		 jmp	 SHORT $LN7@T_PolyObjF
$LN5@T_PolyObjF:
  00140	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00143	83 c0 01	 add	 eax, 1
  00146	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@T_PolyObjF:
  00149	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0014c	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0014f	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00152	73 17		 jae	 SHORT $LN6@T_PolyObjF

; 2556 : 		Polyobj_rotateLine(po->lines[i]);

  00154	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00157	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0015a	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0015d	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _Polyobj_rotateLine
  00166	83 c4 04	 add	 esp, 4
  00169	eb d5		 jmp	 SHORT $LN5@T_PolyObjF
$LN6@T_PolyObjF:

; 2557 : 
; 2558 : 	Polyobj_removeFromBlockmap(po); // unlink it from the blockmap

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _Polyobj_removeFromBlockmap
  00174	83 c4 04	 add	 esp, 4

; 2559 : 	Polyobj_removeFromSubsec(po);   // unlink it from its subsector

  00177	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _Polyobj_removeFromSubsec
  00180	83 c4 04	 add	 esp, 4

; 2560 : 	Polyobj_linkToBlockmap(po);     // relink to blockmap

  00183	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 _Polyobj_linkToBlockmap
  0018c	83 c4 04	 add	 esp, 4

; 2561 : 	Polyobj_attachToSubsec(po);     // relink to subsector

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _po$[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 _Polyobj_attachToSubsec
  00198	83 c4 04	 add	 esp, 4
$LN1@T_PolyObjF:

; 2562 : }

  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
_T_PolyObjFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _T_PolyDoorSwing
_TEXT	SEGMENT
tv92 = -76						; size = 4
tv167 = -76						; size = 4
_avel$1 = -8						; size = 4
_po$ = -4						; size = 4
_th$ = 8						; size = 4
_T_PolyDoorSwing PROC					; COMDAT

; 2017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2018 : 	polyobj_t *po = Polyobj_GetForNum(th->polyObjNum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax

; 2019 : 
; 2020 : 	if (!po)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001f	75 25		 jne	 SHORT $LN2@T_PolyDoor

; 2021 : #ifdef RANGECHECK
; 2022 : 		I_Error("T_PolyDoorSwing: thinker has invalid id %d\n", th->polyObjNum);
; 2023 : #else
; 2024 : 	{
; 2025 : 		CONS_Printf("T_PolyDoorSwing: thinker with invalid id %d removed.\n", th->polyObjNum);

  00021	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00024	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00027	51		 push	 ecx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@FKHFGPAA@T_PolyDoorSwing?3?5thinker?5with?5i@
  0002d	e8 00 00 00 00	 call	 _CONS_Printf
  00032	83 c4 08	 add	 esp, 8

; 2026 : 		P_RemoveThinkerDelayed(&th->thinker);

  00035	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _P_RemoveThinkerDelayed
  0003e	83 c4 04	 add	 esp, 4

; 2027 : 		return;

  00041	e9 c5 01 00 00	 jmp	 $LN17@T_PolyDoor
$LN2@T_PolyDoor:

; 2028 : 	}
; 2029 : #endif
; 2030 : 
; 2031 : 	// check for displacement due to override and reattach when possible
; 2032 : 	if (po->thinker == NULL)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00049	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00050	75 61		 jne	 SHORT $LN6@T_PolyDoor

; 2033 : 	{
; 2034 : 		po->thinker = &th->thinker;

  00052	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00058	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 2035 : 
; 2036 : 		// reset polyobject's thrust
; 2037 : 		po->thrust = abs(th->speed) >> 3;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00061	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _abs
  0006a	83 c4 04	 add	 esp, 4
  0006d	c1 f8 03	 sar	 eax, 3
  00070	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  00073	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 2038 : 		if (po->thrust < FRACUNIT)

  00079	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0007c	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00086	7d 0f		 jge	 SHORT $LN4@T_PolyDoor

; 2039 : 			po->thrust = FRACUNIT;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0008b	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  00095	eb 1c		 jmp	 SHORT $LN6@T_PolyDoor
$LN4@T_PolyDoor:

; 2040 : 		else if (po->thrust > 4*FRACUNIT)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0009a	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  000a4	7e 0d		 jle	 SHORT $LN6@T_PolyDoor

; 2041 : 			po->thrust = 4*FRACUNIT;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  000a9	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN6@T_PolyDoor:

; 2042 : 	}
; 2043 : 
; 2044 : 	// count down wait period
; 2045 : 	if (th->delayCount)

  000b3	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000b6	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000ba	74 1a		 je	 SHORT $LN7@T_PolyDoor

; 2046 : 	{
; 2047 : 		if (--th->delayCount == 0)

  000bc	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000bf	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c2	83 e9 01	 sub	 ecx, 1
  000c5	89 4d b4	 mov	 DWORD PTR tv92[ebp], ecx
  000c8	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000cb	8b 45 b4	 mov	 eax, DWORD PTR tv92[ebp]
  000ce	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 2048 : 		{
; 2049 : 			; // TODO: start sound sequence event
; 2050 : 		}
; 2051 : 		return;

  000d1	e9 35 01 00 00	 jmp	 $LN17@T_PolyDoor
$LN7@T_PolyDoor:

; 2052 : 	}
; 2053 : 
; 2054 : 	// rotate by 'speed' angle per frame
; 2055 : 	// if distance == -1, this polyobject rotates perpetually
; 2056 : 	if (Polyobj_rotate(po, th->speed) && th->distance != -1)

  000d6	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000d9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000dc	51		 push	 ecx
  000dd	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _Polyobj_rotate
  000e6	83 c4 08	 add	 esp, 8
  000e9	85 c0		 test	 eax, eax
  000eb	0f 84 dc 00 00
	00		 je	 $LN9@T_PolyDoor
  000f1	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000f4	83 78 28 ff	 cmp	 DWORD PTR [eax+40], -1
  000f8	0f 84 cf 00 00
	00		 je	 $LN9@T_PolyDoor

; 2057 : 	{
; 2058 : 		INT32 avel = abs(th->speed);

  000fe	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00101	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 _abs
  0010a	83 c4 04	 add	 esp, 4
  0010d	89 45 f8	 mov	 DWORD PTR _avel$1[ebp], eax

; 2059 : 
; 2060 : 		// decrement distance by the amount it moved
; 2061 : 		th->distance -= avel;

  00110	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00113	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00116	2b 4d f8	 sub	 ecx, DWORD PTR _avel$1[ebp]
  00119	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  0011c	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 2062 : 
; 2063 : 		// are we at or past the destination?
; 2064 : 		if (th->distance <= 0)

  0011f	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00122	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00126	7f 70		 jg	 SHORT $LN11@T_PolyDoor

; 2065 : 		{
; 2066 : 			// does it need to close?
; 2067 : 			if (!th->closing)

  00128	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0012b	0f b6 48 2c	 movzx	 ecx, BYTE PTR [eax+44]
  0012f	85 c9		 test	 ecx, ecx
  00131	75 2f		 jne	 SHORT $LN13@T_PolyDoor

; 2068 : 			{
; 2069 : 				th->closing = true;

  00133	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00136	c6 40 2c 01	 mov	 BYTE PTR [eax+44], 1

; 2070 : 
; 2071 : 				// reset distance and speed
; 2072 : 				th->distance =  th->initDistance;

  0013a	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00140	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00143	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2073 : 				th->speed    = -th->initSpeed; // reverse speed on close

  00146	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00149	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0014c	f7 d9		 neg	 ecx
  0014e	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00151	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 2074 : 
; 2075 : 				// start delay
; 2076 : 				th->delayCount = th->delay;

  00154	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0015a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0015d	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 2077 : 			}

  00160	eb 34		 jmp	 SHORT $LN14@T_PolyDoor
$LN13@T_PolyDoor:

; 2078 : 			else
; 2079 : 			{
; 2080 : 				// remove thinker
; 2081 : 				if (po->thinker == &th->thinker)

  00162	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00165	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00168	39 81 9c 00 00
	00		 cmp	 DWORD PTR [ecx+156], eax
  0016e	75 1a		 jne	 SHORT $LN15@T_PolyDoor

; 2082 : 				{
; 2083 : 					po->thinker = NULL;

  00170	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00173	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 2084 : 					po->thrust = FRACUNIT;

  0017d	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00180	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
$LN15@T_PolyDoor:

; 2085 : 				}
; 2086 : 				P_RemoveThinker(&th->thinker);

  0018a	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 _P_RemoveThinker
  00193	83 c4 04	 add	 esp, 4
$LN14@T_PolyDoor:

; 2087 : 				// TODO: notify scripts
; 2088 : 			}
; 2089 : 			// TODO: sound sequence stop event
; 2090 : 		}

  00196	eb 33		 jmp	 SHORT $LN16@T_PolyDoor
$LN11@T_PolyDoor:

; 2091 : 		else if (th->distance < avel)

  00198	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0019b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0019e	3b 4d f8	 cmp	 ecx, DWORD PTR _avel$1[ebp]
  001a1	7d 28		 jge	 SHORT $LN16@T_PolyDoor

; 2092 : 		{
; 2093 : 			// we have less than one multiple of 'speed' left to go,
; 2094 : 			// so change the speed so that it doesn't pass the
; 2095 : 			// destination
; 2096 : 			th->speed = th->speed >= 0

  001a3	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001a6	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  001aa	7c 0b		 jl	 SHORT $LN19@T_PolyDoor
  001ac	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  001af	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  001b2	89 55 b4	 mov	 DWORD PTR tv167[ebp], edx
  001b5	eb 0b		 jmp	 SHORT $LN20@T_PolyDoor
$LN19@T_PolyDoor:
  001b7	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001ba	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001bd	f7 d9		 neg	 ecx
  001bf	89 4d b4	 mov	 DWORD PTR tv167[ebp], ecx
$LN20@T_PolyDoor:
  001c2	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  001c5	8b 45 b4	 mov	 eax, DWORD PTR tv167[ebp]
  001c8	89 42 20	 mov	 DWORD PTR [edx+32], eax
$LN16@T_PolyDoor:

; 2097 : 				? th->distance : -th->distance;
; 2098 : 		}
; 2099 : 	}

  001cb	eb 3e		 jmp	 SHORT $LN17@T_PolyDoor
$LN9@T_PolyDoor:

; 2100 : 	else if (th->closing && th->distance != th->initDistance)

  001cd	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001d0	0f b6 48 2c	 movzx	 ecx, BYTE PTR [eax+44]
  001d4	85 c9		 test	 ecx, ecx
  001d6	74 33		 je	 SHORT $LN17@T_PolyDoor
  001d8	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001db	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  001de	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  001e1	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  001e4	74 25		 je	 SHORT $LN17@T_PolyDoor

; 2101 : 	{
; 2102 : 		// move was blocked, special handling required -- make it reopen
; 2103 : 
; 2104 : 		th->distance = th->initDistance - th->distance;

  001e6	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001e9	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  001ec	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  001ef	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  001f2	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001f5	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2105 : 		th->speed    = th->initSpeed;

  001f8	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  001fe	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00201	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 2106 : 		th->closing  = false;

  00204	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00207	c6 40 2c 00	 mov	 BYTE PTR [eax+44], 0
$LN17@T_PolyDoor:

; 2107 : 
; 2108 : 		// TODO: sound sequence start event
; 2109 : 	}
; 2110 : }

  0020b	5f		 pop	 edi
  0020c	5e		 pop	 esi
  0020d	5b		 pop	 ebx
  0020e	8b e5		 mov	 esp, ebp
  00210	5d		 pop	 ebp
  00211	c3		 ret	 0
_T_PolyDoorSwing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _T_PolyDoorSlide
_TEXT	SEGMENT
tv92 = -76						; size = 4
tv176 = -76						; size = 4
_avel$1 = -8						; size = 4
_po$ = -4						; size = 4
_th$ = 8						; size = 4
_T_PolyDoorSlide PROC					; COMDAT

; 1912 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1913 : 	polyobj_t *po = Polyobj_GetForNum(th->polyObjNum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax

; 1914 : 
; 1915 : 	if (!po)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001f	75 25		 jne	 SHORT $LN2@T_PolyDoor

; 1916 : #ifdef RANGECHECK
; 1917 : 		I_Error("T_PolyDoorSlide: thinker has invalid id %d\n", th->polyObjNum);
; 1918 : #else
; 1919 : 	{
; 1920 : 		CONS_Printf("T_PolyDoorSlide: thinker with invalid id %d removed.\n", th->polyObjNum);

  00021	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00024	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00027	51		 push	 ecx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MPIKCKOA@T_PolyDoorSlide?3?5thinker?5with?5i@
  0002d	e8 00 00 00 00	 call	 _CONS_Printf
  00032	83 c4 08	 add	 esp, 8

; 1921 : 		P_RemoveThinkerDelayed(&th->thinker);

  00035	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _P_RemoveThinkerDelayed
  0003e	83 c4 04	 add	 esp, 4

; 1922 : 		return;

  00041	e9 45 02 00 00	 jmp	 $LN17@T_PolyDoor
$LN2@T_PolyDoor:

; 1923 : 	}
; 1924 : #endif
; 1925 : 
; 1926 : 	// check for displacement due to override and reattach when possible
; 1927 : 	if (po->thinker == NULL)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00049	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00050	75 61		 jne	 SHORT $LN6@T_PolyDoor

; 1928 : 	{
; 1929 : 		po->thinker = &th->thinker;

  00052	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00058	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 1930 : 
; 1931 : 		// reset polyobject's thrust
; 1932 : 		po->thrust = abs(th->speed) >> 3;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00061	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _abs
  0006a	83 c4 04	 add	 esp, 4
  0006d	c1 f8 03	 sar	 eax, 3
  00070	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  00073	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 1933 : 		if (po->thrust < FRACUNIT)

  00079	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0007c	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00086	7d 0f		 jge	 SHORT $LN4@T_PolyDoor

; 1934 : 			po->thrust = FRACUNIT;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0008b	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  00095	eb 1c		 jmp	 SHORT $LN6@T_PolyDoor
$LN4@T_PolyDoor:

; 1935 : 		else if (po->thrust > 4*FRACUNIT)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0009a	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  000a4	7e 0d		 jle	 SHORT $LN6@T_PolyDoor

; 1936 : 			po->thrust = 4*FRACUNIT;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  000a9	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN6@T_PolyDoor:

; 1937 : 	}
; 1938 : 
; 1939 : 	// count down wait period
; 1940 : 	if (th->delayCount)

  000b3	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000b6	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000ba	74 1a		 je	 SHORT $LN7@T_PolyDoor

; 1941 : 	{
; 1942 : 		if (--th->delayCount == 0)

  000bc	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000bf	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c2	83 e9 01	 sub	 ecx, 1
  000c5	89 4d b4	 mov	 DWORD PTR tv92[ebp], ecx
  000c8	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000cb	8b 45 b4	 mov	 eax, DWORD PTR tv92[ebp]
  000ce	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1943 : 		{
; 1944 : 			; // TODO: start sound sequence event
; 1945 : 		}
; 1946 : 		return;

  000d1	e9 b5 01 00 00	 jmp	 $LN17@T_PolyDoor
$LN7@T_PolyDoor:

; 1947 : 	}
; 1948 : 
; 1949 : 	// move the polyobject one step along its movement angle
; 1950 : 	if (Polyobj_moveXY(po, th->momx, th->momy))

  000d6	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000d9	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000dc	51		 push	 ecx
  000dd	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000e0	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000e3	50		 push	 eax
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 _Polyobj_moveXY
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 25 01 00
	00		 je	 $LN9@T_PolyDoor

; 1951 : 	{
; 1952 : 		INT32 avel = abs(th->speed);

  000f8	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000fb	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _abs
  00104	83 c4 04	 add	 esp, 4
  00107	89 45 f8	 mov	 DWORD PTR _avel$1[ebp], eax

; 1953 : 
; 1954 : 		// decrement distance by the amount it moved
; 1955 : 		th->distance -= avel;

  0010a	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0010d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00110	2b 4d f8	 sub	 ecx, DWORD PTR _avel$1[ebp]
  00113	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00116	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 1956 : 
; 1957 : 
; 1958 : 		// are we at or past the destination?
; 1959 : 		if (th->distance <= 0)

  00119	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0011c	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00120	0f 8f 9e 00 00
	00		 jg	 $LN11@T_PolyDoor

; 1960 : 		{
; 1961 : 			// does it need to close?
; 1962 : 			if (!th->closing)

  00126	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00129	0f b6 48 40	 movzx	 ecx, BYTE PTR [eax+64]
  0012d	85 c9		 test	 ecx, ecx
  0012f	75 5d		 jne	 SHORT $LN13@T_PolyDoor

; 1963 : 			{
; 1964 : 				th->closing = true;

  00131	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00134	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1

; 1965 : 
; 1966 : 				// reset distance and speed
; 1967 : 				th->distance = th->initDistance;

  00138	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0013e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00141	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 1968 : 				th->speed    = th->initSpeed;

  00144	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00147	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0014a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0014d	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 1969 : 
; 1970 : 				// start delay
; 1971 : 				th->delayCount = th->delay;

  00150	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00153	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00156	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00159	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1972 : 
; 1973 : 				// reverse angle
; 1974 : 				th->angle = th->revAngle;

  0015c	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00162	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00165	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 1975 : 
; 1976 : 				// reset component speeds
; 1977 : 				Polyobj_componentSpeed(th->speed, th->angle, &th->momx, &th->momy);

  00168	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0016b	83 c0 3c	 add	 eax, 60			; 0000003cH
  0016e	50		 push	 eax
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00172	83 c1 38	 add	 ecx, 56			; 00000038H
  00175	51		 push	 ecx
  00176	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00179	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0017c	50		 push	 eax
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00180	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  00189	83 c4 10	 add	 esp, 16			; 00000010H

; 1978 : 			}

  0018c	eb 34		 jmp	 SHORT $LN14@T_PolyDoor
$LN13@T_PolyDoor:

; 1979 : 			else
; 1980 : 			{
; 1981 : 				// remove thinker
; 1982 : 				if (po->thinker == &th->thinker)

  0018e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00194	39 81 9c 00 00
	00		 cmp	 DWORD PTR [ecx+156], eax
  0019a	75 1a		 jne	 SHORT $LN15@T_PolyDoor

; 1983 : 				{
; 1984 : 					po->thinker = NULL;

  0019c	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0019f	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 1985 : 					po->thrust = FRACUNIT;

  001a9	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  001ac	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
$LN15@T_PolyDoor:

; 1986 : 				}
; 1987 : 				P_RemoveThinker(&th->thinker);

  001b6	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 _P_RemoveThinker
  001bf	83 c4 04	 add	 esp, 4
$LN14@T_PolyDoor:

; 1988 : 				// TODO: notify scripts
; 1989 : 			}
; 1990 : 			// TODO: sound sequence stop event
; 1991 : 		}

  001c2	eb 57		 jmp	 SHORT $LN16@T_PolyDoor
$LN11@T_PolyDoor:

; 1992 : 		else if (th->distance < avel)

  001c4	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001c7	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001ca	3b 4d f8	 cmp	 ecx, DWORD PTR _avel$1[ebp]
  001cd	7d 4c		 jge	 SHORT $LN16@T_PolyDoor

; 1993 : 		{
; 1994 : 			// we have less than one multiple of 'speed' left to go,
; 1995 : 			// so change the speed so that it doesn't pass the
; 1996 : 			// destination
; 1997 : 			th->speed = th->speed >= 0

  001cf	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001d2	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  001d6	7c 0b		 jl	 SHORT $LN19@T_PolyDoor
  001d8	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  001db	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  001de	89 55 b4	 mov	 DWORD PTR tv176[ebp], edx
  001e1	eb 0b		 jmp	 SHORT $LN20@T_PolyDoor
$LN19@T_PolyDoor:
  001e3	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001e6	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001e9	f7 d9		 neg	 ecx
  001eb	89 4d b4	 mov	 DWORD PTR tv176[ebp], ecx
$LN20@T_PolyDoor:
  001ee	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  001f1	8b 45 b4	 mov	 eax, DWORD PTR tv176[ebp]
  001f4	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 1998 : 				? th->distance : -th->distance;
; 1999 : 			Polyobj_componentSpeed(th->speed, th->angle,

  001f7	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001fa	83 c0 3c	 add	 eax, 60			; 0000003cH
  001fd	50		 push	 eax
  001fe	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00201	83 c1 38	 add	 ecx, 56			; 00000038H
  00204	51		 push	 ecx
  00205	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00208	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0020b	50		 push	 eax
  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0020f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  00218	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@T_PolyDoor:

; 2000 : 				&th->momx, &th->momy);
; 2001 : 		}
; 2002 : 	}

  0021b	eb 6e		 jmp	 SHORT $LN17@T_PolyDoor
$LN9@T_PolyDoor:

; 2003 : 	else if (th->closing && th->distance != th->initDistance)

  0021d	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00220	0f b6 48 40	 movzx	 ecx, BYTE PTR [eax+64]
  00224	85 c9		 test	 ecx, ecx
  00226	74 63		 je	 SHORT $LN17@T_PolyDoor
  00228	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0022b	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0022e	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  00231	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  00234	74 55		 je	 SHORT $LN17@T_PolyDoor

; 2004 : 	{
; 2005 : 		// move was blocked, special handling required -- make it reopen
; 2006 : 		th->distance = th->initDistance - th->distance;

  00236	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00239	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0023c	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0023f	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  00242	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00245	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 2007 : 		th->speed    = th->initSpeed;

  00248	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0024b	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0024e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00251	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 2008 : 		th->angle    = th->initAngle;

  00254	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00257	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0025a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0025d	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 2009 : 		Polyobj_componentSpeed(th->speed, th->angle,

  00260	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00263	83 c0 3c	 add	 eax, 60			; 0000003cH
  00266	50		 push	 eax
  00267	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0026a	83 c1 38	 add	 ecx, 56			; 00000038H
  0026d	51		 push	 ecx
  0026e	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00271	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00274	50		 push	 eax
  00275	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00278	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0027b	52		 push	 edx
  0027c	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  00281	83 c4 10	 add	 esp, 16			; 00000010H

; 2010 : 			&th->momx, &th->momy);
; 2011 : 		th->closing  = false;

  00284	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00287	c6 40 40 00	 mov	 BYTE PTR [eax+64], 0
$LN17@T_PolyDoor:

; 2012 : 		// TODO: sound sequence start event
; 2013 : 	}
; 2014 : }

  0028b	5f		 pop	 edi
  0028c	5e		 pop	 esi
  0028d	5b		 pop	 ebx
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
_T_PolyDoorSlide ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _T_PolyObjWaypoint
_TEXT	SEGMENT
_amty$1 = -64						; size = 4
_amtx$2 = -60						; size = 4
_oldpo$ = -56						; size = 4
_po$ = -52						; size = 4
_start$ = -48						; size = 4
_dist$ = -44						; size = 4
_momz$ = -40						; size = 4
_momy$ = -36						; size = 4
_momx$ = -32						; size = 4
_adjustz$ = -28						; size = 4
_adjusty$ = -24						; size = 4
_adjustx$ = -20						; size = 4
_wp$ = -16						; size = 4
_waypoint$ = -12					; size = 4
_target$ = -8						; size = 4
_mo2$ = -4						; size = 4
_th$ = 8						; size = 4
_T_PolyObjWaypoint PROC					; COMDAT

; 1640 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1641 : 	mobj_t *mo2;
; 1642 : 	mobj_t *target = NULL;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _target$[ebp], 0

; 1643 : 	mobj_t *waypoint = NULL;

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _waypoint$[ebp], 0

; 1644 : 	thinker_t *wp;
; 1645 : 	fixed_t adjustx, adjusty, adjustz;
; 1646 : 	fixed_t momx, momy, momz, dist;
; 1647 : 	INT32 start;
; 1648 : 	polyobj_t *po = Polyobj_GetForNum(th->polyObjNum);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0001d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00026	83 c4 04	 add	 esp, 4
  00029	89 45 cc	 mov	 DWORD PTR _po$[ebp], eax

; 1649 : 	polyobj_t *oldpo = po;

  0002c	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  0002f	89 45 c8	 mov	 DWORD PTR _oldpo$[ebp], eax

; 1650 : 
; 1651 : 	if (!po)

  00032	83 7d cc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00036	75 25		 jne	 SHORT $LN18@T_PolyObjW

; 1652 : #ifdef RANGECHECK
; 1653 : 		I_Error("T_PolyObjWaypoint: thinker has invalid id %d\n", th->polyObjNum);
; 1654 : #else
; 1655 : 	{
; 1656 : 		CONS_Printf("T_PolyObjWaypoint: thinker with invalid id %d removed.", th->polyObjNum);

  00038	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0003b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003e	51		 push	 ecx
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PGOHMFJA@T_PolyObjWaypoint?3?5thinker?5with@
  00044	e8 00 00 00 00	 call	 _CONS_Printf
  00049	83 c4 08	 add	 esp, 8

; 1657 : 		P_RemoveThinkerDelayed(&th->thinker);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _P_RemoveThinkerDelayed
  00055	83 c4 04	 add	 esp, 4

; 1658 : 		return;

  00058	e9 85 08 00 00	 jmp	 $LN17@T_PolyObjW
$LN18@T_PolyObjW:

; 1659 : 	}
; 1660 : #endif
; 1661 : 
; 1662 : 	// check for displacement due to override and reattach when possible
; 1663 : 	if (po->thinker == NULL)

  0005d	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  00060	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00067	75 0c		 jne	 SHORT $LN19@T_PolyObjW

; 1664 : 		po->thinker = &th->thinker;

  00069	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0006c	8b 4d cc	 mov	 ecx, DWORD PTR _po$[ebp]
  0006f	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax
$LN19@T_PolyObjW:

; 1665 : 
; 1666 : 	// Find out target first.
; 1667 : 	// We redo this each tic to make savegame compatibility easier.
; 1668 : 	for (wp = thinkercap.next; wp != &thinkercap; wp = wp->next)

  00075	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0007a	89 45 f0	 mov	 DWORD PTR _wp$[ebp], eax
  0007d	eb 09		 jmp	 SHORT $LN4@T_PolyObjW
$LN2@T_PolyObjW:
  0007f	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  00082	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00085	89 4d f0	 mov	 DWORD PTR _wp$[ebp], ecx
$LN4@T_PolyObjW:
  00088	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _wp$[ebp], OFFSET _thinkercap
  0008f	74 4e		 je	 SHORT $LN3@T_PolyObjW

; 1669 : 	{
; 1670 : 		if (wp->function.acp1 != (actionf_p1)P_MobjThinker) // Not a mobj thinker

  00091	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  00094	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  0009b	74 02		 je	 SHORT $LN20@T_PolyObjW

; 1671 : 			continue;

  0009d	eb e0		 jmp	 SHORT $LN2@T_PolyObjW
$LN20@T_PolyObjW:

; 1672 : 
; 1673 : 		mo2 = (mobj_t *)wp;

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  000a2	89 45 fc	 mov	 DWORD PTR _mo2$[ebp], eax

; 1674 : 
; 1675 : 		if (mo2->type != MT_TUBEWAYPOINT)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  000a8	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  000af	74 02		 je	 SHORT $LN21@T_PolyObjW

; 1676 : 			continue;

  000b1	eb cc		 jmp	 SHORT $LN2@T_PolyObjW
$LN21@T_PolyObjW:

; 1677 : 
; 1678 : 		if (mo2->threshold == th->sequence && mo2->health == th->pointnum)

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  000b9	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  000bf	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  000c2	75 19		 jne	 SHORT $LN22@T_PolyObjW
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  000ca	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  000d0	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  000d3	75 08		 jne	 SHORT $LN22@T_PolyObjW

; 1679 : 		{
; 1680 : 			target = mo2;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  000d8	89 45 f8	 mov	 DWORD PTR _target$[ebp], eax

; 1681 : 			break;

  000db	eb 02		 jmp	 SHORT $LN3@T_PolyObjW
$LN22@T_PolyObjW:

; 1682 : 		}
; 1683 : 	}

  000dd	eb a0		 jmp	 SHORT $LN2@T_PolyObjW
$LN3@T_PolyObjW:

; 1684 : 
; 1685 : 	if (!target)

  000df	83 7d f8 00	 cmp	 DWORD PTR _target$[ebp], 0
  000e3	75 12		 jne	 SHORT $LN23@T_PolyObjW

; 1686 : 	{
; 1687 : 		CONS_Printf("T_PolyObjWaypoint: Unable to find target waypoint!\n");

  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@NOIPMJIG@T_PolyObjWaypoint?3?5Unable?5to?5fi@
  000ea	e8 00 00 00 00	 call	 _CONS_Printf
  000ef	83 c4 04	 add	 esp, 4

; 1688 : 		return;

  000f2	e9 eb 07 00 00	 jmp	 $LN17@T_PolyObjW
$LN23@T_PolyObjW:

; 1689 : 	}
; 1690 : 
; 1691 : 	// Compensate for position offset
; 1692 : 	adjustx = po->centerPt.x + th->diffx;

  000f7	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  000fa	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000fd	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00100	03 4a 28	 add	 ecx, DWORD PTR [edx+40]
  00103	89 4d ec	 mov	 DWORD PTR _adjustx$[ebp], ecx

; 1693 : 	adjusty = po->centerPt.y + th->diffy;

  00106	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  00109	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0010c	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  0010f	03 4a 2c	 add	 ecx, DWORD PTR [edx+44]
  00112	89 4d e8	 mov	 DWORD PTR _adjusty$[ebp], ecx

; 1694 : 	adjustz = po->lines[0]->backsector->floorheight + (po->lines[0]->backsector->ceilingheight - po->lines[0]->backsector->floorheight)/2 + th->diffz;

  00115	b8 04 00 00 00	 mov	 eax, 4
  0011a	6b c8 00	 imul	 ecx, eax, 0
  0011d	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00120	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00123	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00126	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00129	ba 04 00 00 00	 mov	 edx, 4
  0012e	6b c2 00	 imul	 eax, edx, 0
  00131	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00134	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  00137	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0013a	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0013d	b8 04 00 00 00	 mov	 eax, 4
  00142	6b c0 00	 imul	 eax, eax, 0
  00145	8b 75 cc	 mov	 esi, DWORD PTR _po$[ebp]
  00148	8b 76 40	 mov	 esi, DWORD PTR [esi+64]
  0014b	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0014e	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00151	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00154	2b 10		 sub	 edx, DWORD PTR [eax]
  00156	8b c2		 mov	 eax, edx
  00158	99		 cdq
  00159	2b c2		 sub	 eax, edx
  0015b	d1 f8		 sar	 eax, 1
  0015d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0015f	03 c8		 add	 ecx, eax
  00161	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00164	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  00167	89 4d e4	 mov	 DWORD PTR _adjustz$[ebp], ecx

; 1695 : 
; 1696 : 	dist = P_AproxDistance(P_AproxDistance(target->x - adjustx, target->y - adjusty), target->z - adjustz);

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0016d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00170	2b 4d e4	 sub	 ecx, DWORD PTR _adjustz$[ebp]
  00173	51		 push	 ecx
  00174	8b 55 f8	 mov	 edx, DWORD PTR _target$[ebp]
  00177	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0017a	2b 45 e8	 sub	 eax, DWORD PTR _adjusty$[ebp]
  0017d	50		 push	 eax
  0017e	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  00181	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00184	2b 55 ec	 sub	 edx, DWORD PTR _adjustx$[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _P_AproxDistance
  0018d	83 c4 08	 add	 esp, 8
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _P_AproxDistance
  00196	83 c4 08	 add	 esp, 8
  00199	89 45 d4	 mov	 DWORD PTR _dist$[ebp], eax

; 1697 : 
; 1698 : 	if (dist < 1)

  0019c	83 7d d4 01	 cmp	 DWORD PTR _dist$[ebp], 1
  001a0	7d 07		 jge	 SHORT $LN24@T_PolyObjW

; 1699 : 		dist = 1;

  001a2	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _dist$[ebp], 1
$LN24@T_PolyObjW:

; 1700 : 
; 1701 : 	momx = FixedMul(FixedDiv(target->x - adjustx, dist), (th->speed));

  001a9	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001ac	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001af	51		 push	 ecx
  001b0	8b 55 d4	 mov	 edx, DWORD PTR _dist$[ebp]
  001b3	52		 push	 edx
  001b4	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  001b7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001ba	2b 4d ec	 sub	 ecx, DWORD PTR _adjustx$[ebp]
  001bd	51		 push	 ecx
  001be	e8 00 00 00 00	 call	 _FixedDiv
  001c3	83 c4 08	 add	 esp, 8
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _FixedMul
  001cc	83 c4 08	 add	 esp, 8
  001cf	89 45 e0	 mov	 DWORD PTR _momx$[ebp], eax

; 1702 : 	momy = FixedMul(FixedDiv(target->y - adjusty, dist), (th->speed));

  001d2	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001d5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001d8	51		 push	 ecx
  001d9	8b 55 d4	 mov	 edx, DWORD PTR _dist$[ebp]
  001dc	52		 push	 edx
  001dd	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  001e0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001e3	2b 4d e8	 sub	 ecx, DWORD PTR _adjusty$[ebp]
  001e6	51		 push	 ecx
  001e7	e8 00 00 00 00	 call	 _FixedDiv
  001ec	83 c4 08	 add	 esp, 8
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _FixedMul
  001f5	83 c4 08	 add	 esp, 8
  001f8	89 45 dc	 mov	 DWORD PTR _momy$[ebp], eax

; 1703 : 	momz = FixedMul(FixedDiv(target->z - adjustz, dist), (th->speed));

  001fb	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  001fe	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00201	51		 push	 ecx
  00202	8b 55 d4	 mov	 edx, DWORD PTR _dist$[ebp]
  00205	52		 push	 edx
  00206	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00209	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0020c	2b 4d e4	 sub	 ecx, DWORD PTR _adjustz$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _FixedDiv
  00215	83 c4 08	 add	 esp, 8
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _FixedMul
  0021e	83 c4 08	 add	 esp, 8
  00221	89 45 d8	 mov	 DWORD PTR _momz$[ebp], eax

; 1704 : 
; 1705 : 	// Calculate the distance between the polyobject and the waypoint
; 1706 : 	// 'dist' already equals this.
; 1707 : 
; 1708 : 	// Will the polyobject be FURTHER away if the momx/momy/momz is added to
; 1709 : 	// its current coordinates, or closer? (shift down to fracunits to avoid approximation errors)
; 1710 : 	if (dist>>FRACBITS <= P_AproxDistance(P_AproxDistance(target->x - adjustx - momx, target->y - adjusty - momy), target->z - adjustz - momz)>>FRACBITS)

  00224	8b 75 d4	 mov	 esi, DWORD PTR _dist$[ebp]
  00227	c1 fe 10	 sar	 esi, 16			; 00000010H
  0022a	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0022d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00230	2b 4d e4	 sub	 ecx, DWORD PTR _adjustz$[ebp]
  00233	2b 4d d8	 sub	 ecx, DWORD PTR _momz$[ebp]
  00236	51		 push	 ecx
  00237	8b 55 f8	 mov	 edx, DWORD PTR _target$[ebp]
  0023a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0023d	2b 45 e8	 sub	 eax, DWORD PTR _adjusty$[ebp]
  00240	2b 45 dc	 sub	 eax, DWORD PTR _momy$[ebp]
  00243	50		 push	 eax
  00244	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  00247	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0024a	2b 55 ec	 sub	 edx, DWORD PTR _adjustx$[ebp]
  0024d	2b 55 e0	 sub	 edx, DWORD PTR _momx$[ebp]
  00250	52		 push	 edx
  00251	e8 00 00 00 00	 call	 _P_AproxDistance
  00256	83 c4 08	 add	 esp, 8
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _P_AproxDistance
  0025f	83 c4 08	 add	 esp, 8
  00262	c1 f8 10	 sar	 eax, 16			; 00000010H
  00265	3b f0		 cmp	 esi, eax
  00267	0f 8f 54 05 00
	00		 jg	 $LN25@T_PolyObjW

; 1711 : 	{
; 1712 : 		// If further away, set XYZ of polyobject to waypoint location
; 1713 : 		fixed_t amtx, amty;
; 1714 : 		amtx = (target->x - th->diffx) - po->centerPt.x;

  0026d	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00270	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00273	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00276	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  00279	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  0027c	2b 50 60	 sub	 edx, DWORD PTR [eax+96]
  0027f	89 55 c4	 mov	 DWORD PTR _amtx$2[ebp], edx

; 1715 : 		amty = (target->y - th->diffy) - po->centerPt.y;

  00282	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00288	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0028b	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  0028e	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  00291	2b 50 64	 sub	 edx, DWORD PTR [eax+100]
  00294	89 55 c0	 mov	 DWORD PTR _amty$1[ebp], edx

; 1716 : 		Polyobj_moveXY(po, amtx, amty);

  00297	8b 45 c0	 mov	 eax, DWORD PTR _amty$1[ebp]
  0029a	50		 push	 eax
  0029b	8b 4d c4	 mov	 ecx, DWORD PTR _amtx$2[ebp]
  0029e	51		 push	 ecx
  0029f	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  002a2	52		 push	 edx
  002a3	e8 00 00 00 00	 call	 _Polyobj_moveXY
  002a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1717 : 		// TODO: use T_MovePlane
; 1718 : 		amtx = (po->lines[0]->backsector->ceilingheight - po->lines[0]->backsector->floorheight)/2;

  002ab	b8 04 00 00 00	 mov	 eax, 4
  002b0	6b c8 00	 imul	 ecx, eax, 0
  002b3	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  002b6	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  002b9	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002bc	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  002bf	b8 04 00 00 00	 mov	 eax, 4
  002c4	6b c8 00	 imul	 ecx, eax, 0
  002c7	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  002ca	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  002cd	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d0	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  002d3	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002d6	2b 08		 sub	 ecx, DWORD PTR [eax]
  002d8	8b c1		 mov	 eax, ecx
  002da	99		 cdq
  002db	2b c2		 sub	 eax, edx
  002dd	d1 f8		 sar	 eax, 1
  002df	89 45 c4	 mov	 DWORD PTR _amtx$2[ebp], eax

; 1719 : 		po->lines[0]->backsector->floorheight = target->z - amtx;

  002e2	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  002e5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002e8	2b 4d c4	 sub	 ecx, DWORD PTR _amtx$2[ebp]
  002eb	ba 04 00 00 00	 mov	 edx, 4
  002f0	6b c2 00	 imul	 eax, edx, 0
  002f3	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  002f6	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  002f9	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002fc	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  002ff	89 0a		 mov	 DWORD PTR [edx], ecx

; 1720 : 		po->lines[0]->backsector->ceilingheight = target->z + amtx;

  00301	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00304	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00307	03 4d c4	 add	 ecx, DWORD PTR _amtx$2[ebp]
  0030a	ba 04 00 00 00	 mov	 edx, 4
  0030f	6b c2 00	 imul	 eax, edx, 0
  00312	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00315	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  00318	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0031b	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0031e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1721 : 
; 1722 : 		// Apply action to mirroring polyobjects as well
; 1723 : 		start = 0;

  00321	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN66@T_PolyObjW:

; 1724 : 		while ((po = Polyobj_GetChild(oldpo, &start)))

  00328	8d 45 d0	 lea	 eax, DWORD PTR _start$[ebp]
  0032b	50		 push	 eax
  0032c	8b 4d c8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  0032f	51		 push	 ecx
  00330	e8 00 00 00 00	 call	 _Polyobj_GetChild
  00335	83 c4 08	 add	 esp, 8
  00338	89 45 cc	 mov	 DWORD PTR _po$[ebp], eax
  0033b	83 7d cc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0033f	0f 84 9f 00 00
	00		 je	 $LN6@T_PolyObjW

; 1725 : 		{
; 1726 : 			if (po->isBad)

  00345	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  00348	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  0034f	85 c9		 test	 ecx, ecx
  00351	74 02		 je	 SHORT $LN27@T_PolyObjW

; 1727 : 				continue;

  00353	eb d3		 jmp	 SHORT $LN66@T_PolyObjW
$LN27@T_PolyObjW:

; 1728 : 
; 1729 : 			Polyobj_moveXY(po, amtx, amty);

  00355	8b 45 c0	 mov	 eax, DWORD PTR _amty$1[ebp]
  00358	50		 push	 eax
  00359	8b 4d c4	 mov	 ecx, DWORD PTR _amtx$2[ebp]
  0035c	51		 push	 ecx
  0035d	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00360	52		 push	 edx
  00361	e8 00 00 00 00	 call	 _Polyobj_moveXY
  00366	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1730 : 			// TODO: use T_MovePlane
; 1731 : 			amtx = (po->lines[0]->backsector->ceilingheight - po->lines[0]->backsector->floorheight)/2;

  00369	b8 04 00 00 00	 mov	 eax, 4
  0036e	6b c8 00	 imul	 ecx, eax, 0
  00371	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00374	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00377	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0037a	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0037d	b8 04 00 00 00	 mov	 eax, 4
  00382	6b c8 00	 imul	 ecx, eax, 0
  00385	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  00388	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  0038b	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0038e	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00391	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00394	2b 08		 sub	 ecx, DWORD PTR [eax]
  00396	8b c1		 mov	 eax, ecx
  00398	99		 cdq
  00399	2b c2		 sub	 eax, edx
  0039b	d1 f8		 sar	 eax, 1
  0039d	89 45 c4	 mov	 DWORD PTR _amtx$2[ebp], eax

; 1732 : 			po->lines[0]->backsector->floorheight = target->z - amtx;

  003a0	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  003a3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003a6	2b 4d c4	 sub	 ecx, DWORD PTR _amtx$2[ebp]
  003a9	ba 04 00 00 00	 mov	 edx, 4
  003ae	6b c2 00	 imul	 eax, edx, 0
  003b1	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  003b4	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  003b7	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  003ba	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  003bd	89 0a		 mov	 DWORD PTR [edx], ecx

; 1733 : 			po->lines[0]->backsector->ceilingheight = target->z + amtx;

  003bf	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  003c2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003c5	03 4d c4	 add	 ecx, DWORD PTR _amtx$2[ebp]
  003c8	ba 04 00 00 00	 mov	 edx, 4
  003cd	6b c2 00	 imul	 eax, edx, 0
  003d0	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  003d3	8b 52 40	 mov	 edx, DWORD PTR [edx+64]
  003d6	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  003d9	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  003dc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1734 : 		}

  003df	e9 44 ff ff ff	 jmp	 $LN66@T_PolyObjW
$LN6@T_PolyObjW:

; 1735 : 
; 1736 : 		po = oldpo;

  003e4	8b 45 c8	 mov	 eax, DWORD PTR _oldpo$[ebp]
  003e7	89 45 cc	 mov	 DWORD PTR _po$[ebp], eax

; 1737 : 
; 1738 : 		if (!th->stophere)

  003ea	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  003ed	0f b6 48 27	 movzx	 ecx, BYTE PTR [eax+39]
  003f1	85 c9		 test	 ecx, ecx
  003f3	0f 85 63 02 00
	00		 jne	 $LN14@T_PolyObjW

; 1739 : 		{
; 1740 : 			if (cv_debug)

  003f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  00400	74 0d		 je	 SHORT $LN29@T_PolyObjW

; 1741 : 				CONS_Printf("Looking for next waypoint...\n");

  00402	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OPDLNCEP@Looking?5for?5next?5waypoint?4?4?4?6@
  00407	e8 00 00 00 00	 call	 _CONS_Printf
  0040c	83 c4 04	 add	 esp, 4
$LN29@T_PolyObjW:

; 1742 : 
; 1743 : 			// Find next waypoint
; 1744 : 			for (wp = thinkercap.next; wp != &thinkercap; wp = wp->next)

  0040f	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00414	89 45 f0	 mov	 DWORD PTR _wp$[ebp], eax
  00417	eb 09		 jmp	 SHORT $LN9@T_PolyObjW
$LN7@T_PolyObjW:
  00419	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  0041c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0041f	89 4d f0	 mov	 DWORD PTR _wp$[ebp], ecx
$LN9@T_PolyObjW:
  00422	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _wp$[ebp], OFFSET _thinkercap
  00429	0f 84 81 00 00
	00		 je	 $LN8@T_PolyObjW

; 1745 : 			{
; 1746 : 				if (wp->function.acp1 != (actionf_p1)P_MobjThinker) // Not a mobj thinker

  0042f	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  00432	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  00439	74 02		 je	 SHORT $LN30@T_PolyObjW

; 1747 : 					continue;

  0043b	eb dc		 jmp	 SHORT $LN7@T_PolyObjW
$LN30@T_PolyObjW:

; 1748 : 
; 1749 : 				mo2 = (mobj_t *)wp;

  0043d	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  00440	89 45 fc	 mov	 DWORD PTR _mo2$[ebp], eax

; 1750 : 
; 1751 : 				if (mo2->type != MT_TUBEWAYPOINT)

  00443	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00446	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  0044d	74 02		 je	 SHORT $LN31@T_PolyObjW

; 1752 : 					continue;

  0044f	eb c8		 jmp	 SHORT $LN7@T_PolyObjW
$LN31@T_PolyObjW:

; 1753 : 
; 1754 : 				if (mo2->threshold == th->sequence)

  00451	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00454	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00457	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  0045d	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  00460	75 49		 jne	 SHORT $LN36@T_PolyObjW

; 1755 : 				{
; 1756 : 					if (th->direction == -1)

  00462	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00465	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  00469	75 21		 jne	 SHORT $LN33@T_PolyObjW

; 1757 : 					{
; 1758 : 						if (mo2->health == target->health - 1)

  0046b	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0046e	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00474	83 e9 01	 sub	 ecx, 1
  00477	8b 55 fc	 mov	 edx, DWORD PTR _mo2$[ebp]
  0047a	39 8a 8c 00 00
	00		 cmp	 DWORD PTR [edx+140], ecx
  00480	75 08		 jne	 SHORT $LN35@T_PolyObjW

; 1759 : 						{
; 1760 : 							waypoint = mo2;

  00482	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00485	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax

; 1761 : 							break;

  00488	eb 26		 jmp	 SHORT $LN8@T_PolyObjW
$LN35@T_PolyObjW:

; 1762 : 						}
; 1763 : 					}

  0048a	eb 1f		 jmp	 SHORT $LN36@T_PolyObjW
$LN33@T_PolyObjW:

; 1764 : 					else
; 1765 : 					{
; 1766 : 						if (mo2->health == target->health + 1)

  0048c	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0048f	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00495	83 c1 01	 add	 ecx, 1
  00498	8b 55 fc	 mov	 edx, DWORD PTR _mo2$[ebp]
  0049b	39 8a 8c 00 00
	00		 cmp	 DWORD PTR [edx+140], ecx
  004a1	75 08		 jne	 SHORT $LN36@T_PolyObjW

; 1767 : 						{
; 1768 : 							waypoint = mo2;

  004a3	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  004a6	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax

; 1769 : 							break;

  004a9	eb 05		 jmp	 SHORT $LN8@T_PolyObjW
$LN36@T_PolyObjW:

; 1770 : 						}
; 1771 : 					}
; 1772 : 				}
; 1773 : 			}

  004ab	e9 69 ff ff ff	 jmp	 $LN7@T_PolyObjW
$LN8@T_PolyObjW:

; 1774 : 
; 1775 : 			if (!waypoint && th->wrap) // If specified, wrap waypoints

  004b0	83 7d f4 00	 cmp	 DWORD PTR _waypoint$[ebp], 0
  004b4	0f 85 c8 00 00
	00		 jne	 $LN37@T_PolyObjW
  004ba	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  004bd	0f b6 48 25	 movzx	 ecx, BYTE PTR [eax+37]
  004c1	85 c9		 test	 ecx, ecx
  004c3	0f 84 b9 00 00
	00		 je	 $LN37@T_PolyObjW

; 1776 : 			{
; 1777 : 				if (!th->continuous)

  004c9	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  004cc	0f b6 48 26	 movzx	 ecx, BYTE PTR [eax+38]
  004d0	85 c9		 test	 ecx, ecx
  004d2	75 0e		 jne	 SHORT $LN39@T_PolyObjW

; 1778 : 				{
; 1779 : 					th->wrap = 0;

  004d4	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  004d7	c6 40 25 00	 mov	 BYTE PTR [eax+37], 0

; 1780 : 					th->stophere = true;

  004db	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  004de	c6 40 27 01	 mov	 BYTE PTR [eax+39], 1
$LN39@T_PolyObjW:

; 1781 : 				}
; 1782 : 
; 1783 : 				for (wp = thinkercap.next; wp != &thinkercap; wp = wp->next)

  004e2	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  004e7	89 45 f0	 mov	 DWORD PTR _wp$[ebp], eax
  004ea	eb 09		 jmp	 SHORT $LN12@T_PolyObjW
$LN10@T_PolyObjW:
  004ec	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  004ef	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004f2	89 4d f0	 mov	 DWORD PTR _wp$[ebp], ecx
$LN12@T_PolyObjW:
  004f5	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _wp$[ebp], OFFSET _thinkercap
  004fc	74 7f		 je	 SHORT $LN11@T_PolyObjW

; 1784 : 				{
; 1785 : 					if (wp->function.acp1 != (actionf_p1)P_MobjThinker) // Not a mobj thinker

  004fe	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  00501	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  00508	74 02		 je	 SHORT $LN40@T_PolyObjW

; 1786 : 						continue;

  0050a	eb e0		 jmp	 SHORT $LN10@T_PolyObjW
$LN40@T_PolyObjW:

; 1787 : 
; 1788 : 					mo2 = (mobj_t *)wp;

  0050c	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  0050f	89 45 fc	 mov	 DWORD PTR _mo2$[ebp], eax

; 1789 : 
; 1790 : 					if (mo2->type != MT_TUBEWAYPOINT)

  00512	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00515	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  0051c	74 02		 je	 SHORT $LN41@T_PolyObjW

; 1791 : 						continue;

  0051e	eb cc		 jmp	 SHORT $LN10@T_PolyObjW
$LN41@T_PolyObjW:

; 1792 : 
; 1793 : 					if (mo2->threshold == th->sequence)

  00520	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00523	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00526	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  0052c	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0052f	75 47		 jne	 SHORT $LN48@T_PolyObjW

; 1794 : 					{
; 1795 : 						if (th->direction == -1)

  00531	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00534	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  00538	75 2a		 jne	 SHORT $LN43@T_PolyObjW

; 1796 : 						{
; 1797 : 							if (waypoint == NULL)

  0053a	83 7d f4 00	 cmp	 DWORD PTR _waypoint$[ebp], 0
  0053e	75 08		 jne	 SHORT $LN45@T_PolyObjW

; 1798 : 								waypoint = mo2;

  00540	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00543	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax
  00546	eb 1a		 jmp	 SHORT $LN47@T_PolyObjW
$LN45@T_PolyObjW:

; 1799 : 							else if (mo2->health > waypoint->health)

  00548	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  0054b	8b 4d f4	 mov	 ecx, DWORD PTR _waypoint$[ebp]
  0054e	8b 90 8c 00 00
	00		 mov	 edx, DWORD PTR [eax+140]
  00554	3b 91 8c 00 00
	00		 cmp	 edx, DWORD PTR [ecx+140]
  0055a	7e 06		 jle	 SHORT $LN47@T_PolyObjW

; 1800 : 								waypoint = mo2;

  0055c	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  0055f	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax
$LN47@T_PolyObjW:

; 1801 : 						}

  00562	eb 14		 jmp	 SHORT $LN48@T_PolyObjW
$LN43@T_PolyObjW:

; 1802 : 						else
; 1803 : 						{
; 1804 : 							if (mo2->health == 0)

  00564	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00567	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  0056e	75 08		 jne	 SHORT $LN48@T_PolyObjW

; 1805 : 							{
; 1806 : 								waypoint = mo2;

  00570	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00573	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax

; 1807 : 								break;

  00576	eb 05		 jmp	 SHORT $LN11@T_PolyObjW
$LN48@T_PolyObjW:

; 1808 : 							}
; 1809 : 						}
; 1810 : 					}
; 1811 : 				}

  00578	e9 6f ff ff ff	 jmp	 $LN10@T_PolyObjW
$LN11@T_PolyObjW:

; 1812 : 			}

  0057d	e9 da 00 00 00	 jmp	 $LN14@T_PolyObjW
$LN37@T_PolyObjW:

; 1813 : 			else if (!waypoint && th->comeback) // Come back to the start

  00582	83 7d f4 00	 cmp	 DWORD PTR _waypoint$[ebp], 0
  00586	0f 85 d0 00 00
	00		 jne	 $LN14@T_PolyObjW
  0058c	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0058f	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  00593	85 c9		 test	 ecx, ecx
  00595	0f 84 c1 00 00
	00		 je	 $LN14@T_PolyObjW

; 1814 : 			{
; 1815 : 				th->direction = -th->direction;

  0059b	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0059e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  005a1	f7 d9		 neg	 ecx
  005a3	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  005a6	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 1816 : 
; 1817 : 				if (!th->continuous)

  005a9	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  005ac	0f b6 48 26	 movzx	 ecx, BYTE PTR [eax+38]
  005b0	85 c9		 test	 ecx, ecx
  005b2	75 07		 jne	 SHORT $LN50@T_PolyObjW

; 1818 : 					th->comeback = false;

  005b4	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  005b7	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
$LN50@T_PolyObjW:

; 1819 : 
; 1820 : 				for (wp = thinkercap.next; wp != &thinkercap; wp = wp->next)

  005bb	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  005c0	89 45 f0	 mov	 DWORD PTR _wp$[ebp], eax
  005c3	eb 09		 jmp	 SHORT $LN15@T_PolyObjW
$LN13@T_PolyObjW:
  005c5	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  005c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005cb	89 4d f0	 mov	 DWORD PTR _wp$[ebp], ecx
$LN15@T_PolyObjW:
  005ce	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _wp$[ebp], OFFSET _thinkercap
  005d5	0f 84 81 00 00
	00		 je	 $LN14@T_PolyObjW

; 1821 : 				{
; 1822 : 					if (wp->function.acp1 != (actionf_p1)P_MobjThinker) // Not a mobj thinker

  005db	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  005de	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  005e5	74 02		 je	 SHORT $LN51@T_PolyObjW

; 1823 : 						continue;

  005e7	eb dc		 jmp	 SHORT $LN13@T_PolyObjW
$LN51@T_PolyObjW:

; 1824 : 
; 1825 : 					mo2 = (mobj_t *)wp;

  005e9	8b 45 f0	 mov	 eax, DWORD PTR _wp$[ebp]
  005ec	89 45 fc	 mov	 DWORD PTR _mo2$[ebp], eax

; 1826 : 
; 1827 : 					if (mo2->type != MT_TUBEWAYPOINT)

  005ef	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  005f2	81 78 7c 06 01
	00 00		 cmp	 DWORD PTR [eax+124], 262 ; 00000106H
  005f9	74 02		 je	 SHORT $LN52@T_PolyObjW

; 1828 : 						continue;

  005fb	eb c8		 jmp	 SHORT $LN13@T_PolyObjW
$LN52@T_PolyObjW:

; 1829 : 
; 1830 : 					if (mo2->threshold == th->sequence)

  005fd	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00600	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00603	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [eax+160]
  00609	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0060c	75 49		 jne	 SHORT $LN57@T_PolyObjW

; 1831 : 					{
; 1832 : 						if (th->direction == -1)

  0060e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00611	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  00615	75 21		 jne	 SHORT $LN54@T_PolyObjW

; 1833 : 						{
; 1834 : 							if (mo2->health == target->health - 1)

  00617	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0061a	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00620	83 e9 01	 sub	 ecx, 1
  00623	8b 55 fc	 mov	 edx, DWORD PTR _mo2$[ebp]
  00626	39 8a 8c 00 00
	00		 cmp	 DWORD PTR [edx+140], ecx
  0062c	75 08		 jne	 SHORT $LN56@T_PolyObjW

; 1835 : 							{
; 1836 : 								waypoint = mo2;

  0062e	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00631	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax

; 1837 : 								break;

  00634	eb 26		 jmp	 SHORT $LN14@T_PolyObjW
$LN56@T_PolyObjW:

; 1838 : 							}
; 1839 : 						}

  00636	eb 1f		 jmp	 SHORT $LN57@T_PolyObjW
$LN54@T_PolyObjW:

; 1840 : 						else
; 1841 : 						{
; 1842 : 							if (mo2->health == target->health + 1)

  00638	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0063b	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00641	83 c1 01	 add	 ecx, 1
  00644	8b 55 fc	 mov	 edx, DWORD PTR _mo2$[ebp]
  00647	39 8a 8c 00 00
	00		 cmp	 DWORD PTR [edx+140], ecx
  0064d	75 08		 jne	 SHORT $LN57@T_PolyObjW

; 1843 : 							{
; 1844 : 								waypoint = mo2;

  0064f	8b 45 fc	 mov	 eax, DWORD PTR _mo2$[ebp]
  00652	89 45 f4	 mov	 DWORD PTR _waypoint$[ebp], eax

; 1845 : 								break;

  00655	eb 05		 jmp	 SHORT $LN14@T_PolyObjW
$LN57@T_PolyObjW:

; 1846 : 							}
; 1847 : 						}
; 1848 : 					}
; 1849 : 				}

  00657	e9 69 ff ff ff	 jmp	 $LN13@T_PolyObjW
$LN14@T_PolyObjW:

; 1850 : 			}
; 1851 : 		}
; 1852 : 
; 1853 : 		if (waypoint)

  0065c	83 7d f4 00	 cmp	 DWORD PTR _waypoint$[ebp], 0
  00660	0f 84 fb 00 00
	00		 je	 $LN58@T_PolyObjW

; 1854 : 		{
; 1855 : 			if (cv_debug)

  00666	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  0066d	74 21		 je	 SHORT $LN60@T_PolyObjW

; 1856 : 				CONS_Printf("Found waypoint (sequence %d, number %d).\n", waypoint->threshold, waypoint->health);

  0066f	8b 45 f4	 mov	 eax, DWORD PTR _waypoint$[ebp]
  00672	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00678	51		 push	 ecx
  00679	8b 55 f4	 mov	 edx, DWORD PTR _waypoint$[ebp]
  0067c	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00682	50		 push	 eax
  00683	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OOJOEGDC@Found?5waypoint?5?$CIsequence?5?$CFd?0?5nu@
  00688	e8 00 00 00 00	 call	 _CONS_Printf
  0068d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@T_PolyObjW:

; 1857 : 
; 1858 : 			target = waypoint;

  00690	8b 45 f4	 mov	 eax, DWORD PTR _waypoint$[ebp]
  00693	89 45 f8	 mov	 DWORD PTR _target$[ebp], eax

; 1859 : 			th->pointnum = target->health;

  00696	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00699	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  0069c	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  006a2	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1860 : 
; 1861 : 			// calculate MOMX/MOMY/MOMZ for next waypoint
; 1862 : 			// change slope
; 1863 : 			dist = P_AproxDistance(P_AproxDistance(target->x - adjustx, target->y - adjusty), target->z - adjustz);

  006a5	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  006a8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  006ab	2b 4d e4	 sub	 ecx, DWORD PTR _adjustz$[ebp]
  006ae	51		 push	 ecx
  006af	8b 55 f8	 mov	 edx, DWORD PTR _target$[ebp]
  006b2	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  006b5	2b 45 e8	 sub	 eax, DWORD PTR _adjusty$[ebp]
  006b8	50		 push	 eax
  006b9	8b 4d f8	 mov	 ecx, DWORD PTR _target$[ebp]
  006bc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  006bf	2b 55 ec	 sub	 edx, DWORD PTR _adjustx$[ebp]
  006c2	52		 push	 edx
  006c3	e8 00 00 00 00	 call	 _P_AproxDistance
  006c8	83 c4 08	 add	 esp, 8
  006cb	50		 push	 eax
  006cc	e8 00 00 00 00	 call	 _P_AproxDistance
  006d1	83 c4 08	 add	 esp, 8
  006d4	89 45 d4	 mov	 DWORD PTR _dist$[ebp], eax

; 1864 : 
; 1865 : 			if (dist < 1)

  006d7	83 7d d4 01	 cmp	 DWORD PTR _dist$[ebp], 1
  006db	7d 07		 jge	 SHORT $LN61@T_PolyObjW

; 1866 : 				dist = 1;

  006dd	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _dist$[ebp], 1
$LN61@T_PolyObjW:

; 1867 : 
; 1868 : 			momx = FixedMul(FixedDiv(target->x - adjustx, dist), (th->speed));

  006e4	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  006e7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  006ea	51		 push	 ecx
  006eb	8b 55 d4	 mov	 edx, DWORD PTR _dist$[ebp]
  006ee	52		 push	 edx
  006ef	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  006f2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006f5	2b 4d ec	 sub	 ecx, DWORD PTR _adjustx$[ebp]
  006f8	51		 push	 ecx
  006f9	e8 00 00 00 00	 call	 _FixedDiv
  006fe	83 c4 08	 add	 esp, 8
  00701	50		 push	 eax
  00702	e8 00 00 00 00	 call	 _FixedMul
  00707	83 c4 08	 add	 esp, 8
  0070a	89 45 e0	 mov	 DWORD PTR _momx$[ebp], eax

; 1869 : 			momy = FixedMul(FixedDiv(target->y - adjusty, dist), (th->speed));

  0070d	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00710	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00713	51		 push	 ecx
  00714	8b 55 d4	 mov	 edx, DWORD PTR _dist$[ebp]
  00717	52		 push	 edx
  00718	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0071b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0071e	2b 4d e8	 sub	 ecx, DWORD PTR _adjusty$[ebp]
  00721	51		 push	 ecx
  00722	e8 00 00 00 00	 call	 _FixedDiv
  00727	83 c4 08	 add	 esp, 8
  0072a	50		 push	 eax
  0072b	e8 00 00 00 00	 call	 _FixedMul
  00730	83 c4 08	 add	 esp, 8
  00733	89 45 dc	 mov	 DWORD PTR _momy$[ebp], eax

; 1870 : 			momz = FixedMul(FixedDiv(target->z - adjustz, dist), (th->speed));

  00736	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00739	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0073c	51		 push	 ecx
  0073d	8b 55 d4	 mov	 edx, DWORD PTR _dist$[ebp]
  00740	52		 push	 edx
  00741	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00744	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00747	2b 4d e4	 sub	 ecx, DWORD PTR _adjustz$[ebp]
  0074a	51		 push	 ecx
  0074b	e8 00 00 00 00	 call	 _FixedDiv
  00750	83 c4 08	 add	 esp, 8
  00753	50		 push	 eax
  00754	e8 00 00 00 00	 call	 _FixedMul
  00759	83 c4 08	 add	 esp, 8
  0075c	89 45 d8	 mov	 DWORD PTR _momz$[ebp], eax

; 1871 : 		}

  0075f	eb 60		 jmp	 SHORT $LN59@T_PolyObjW
$LN58@T_PolyObjW:

; 1872 : 		else
; 1873 : 		{
; 1874 : 			momx = momy = momz = 0;

  00761	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _momz$[ebp], 0
  00768	8b 45 d8	 mov	 eax, DWORD PTR _momz$[ebp]
  0076b	89 45 dc	 mov	 DWORD PTR _momy$[ebp], eax
  0076e	8b 4d dc	 mov	 ecx, DWORD PTR _momy$[ebp]
  00771	89 4d e0	 mov	 DWORD PTR _momx$[ebp], ecx

; 1875 : 
; 1876 : 			if (cv_debug && !th->stophere)

  00774	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cv_debug, 0
  0077b	74 18		 je	 SHORT $LN62@T_PolyObjW
  0077d	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00780	0f b6 48 27	 movzx	 ecx, BYTE PTR [eax+39]
  00784	85 c9		 test	 ecx, ecx
  00786	75 0d		 jne	 SHORT $LN62@T_PolyObjW

; 1877 : 				CONS_Printf("Next waypoint not found!\n");

  00788	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JEFHHCNP@Next?5waypoint?5not?5found?$CB?6@
  0078d	e8 00 00 00 00	 call	 _CONS_Printf
  00792	83 c4 04	 add	 esp, 4
$LN62@T_PolyObjW:

; 1878 : 
; 1879 : 			if (po->thinker == &th->thinker)

  00795	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00798	8b 4d cc	 mov	 ecx, DWORD PTR _po$[ebp]
  0079b	39 81 9c 00 00
	00		 cmp	 DWORD PTR [ecx+156], eax
  007a1	75 0d		 jne	 SHORT $LN63@T_PolyObjW

; 1880 : 				po->thinker = NULL;

  007a3	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  007a6	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0
$LN63@T_PolyObjW:

; 1881 : 
; 1882 : 			P_RemoveThinker(&th->thinker);

  007b0	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  007b3	50		 push	 eax
  007b4	e8 00 00 00 00	 call	 _P_RemoveThinker
  007b9	83 c4 04	 add	 esp, 4

; 1883 : 			return;

  007bc	e9 21 01 00 00	 jmp	 $LN17@T_PolyObjW
$LN59@T_PolyObjW:
$LN25@T_PolyObjW:

; 1884 : 		}
; 1885 : 	}
; 1886 : 	else
; 1887 : 	{
; 1888 : 		// momx/momy/momz already equals the right speed
; 1889 : 	}
; 1890 : 
; 1891 : 	// Move the polyobject
; 1892 : 	Polyobj_moveXY(po, momx, momy);

  007c1	8b 45 dc	 mov	 eax, DWORD PTR _momy$[ebp]
  007c4	50		 push	 eax
  007c5	8b 4d e0	 mov	 ecx, DWORD PTR _momx$[ebp]
  007c8	51		 push	 ecx
  007c9	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  007cc	52		 push	 edx
  007cd	e8 00 00 00 00	 call	 _Polyobj_moveXY
  007d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1893 : 	// TODO: use T_MovePlane
; 1894 : 	po->lines[0]->backsector->floorheight += momz;

  007d5	b8 04 00 00 00	 mov	 eax, 4
  007da	6b c8 00	 imul	 ecx, eax, 0
  007dd	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  007e0	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  007e3	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  007e6	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  007e9	8b 02		 mov	 eax, DWORD PTR [edx]
  007eb	03 45 d8	 add	 eax, DWORD PTR _momz$[ebp]
  007ee	b9 04 00 00 00	 mov	 ecx, 4
  007f3	6b d1 00	 imul	 edx, ecx, 0
  007f6	8b 4d cc	 mov	 ecx, DWORD PTR _po$[ebp]
  007f9	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  007fc	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  007ff	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  00802	89 01		 mov	 DWORD PTR [ecx], eax

; 1895 : 	po->lines[0]->backsector->ceilingheight += momz;

  00804	b8 04 00 00 00	 mov	 eax, 4
  00809	6b c8 00	 imul	 ecx, eax, 0
  0080c	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  0080f	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00812	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00815	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00818	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0081b	03 45 d8	 add	 eax, DWORD PTR _momz$[ebp]
  0081e	b9 04 00 00 00	 mov	 ecx, 4
  00823	6b d1 00	 imul	 edx, ecx, 0
  00826	8b 4d cc	 mov	 ecx, DWORD PTR _po$[ebp]
  00829	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  0082c	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  0082f	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  00832	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1896 : 
; 1897 : 	// Apply action to mirroring polyobjects as well
; 1898 : 	start = 0;

  00835	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
$LN67@T_PolyObjW:

; 1899 : 	while ((po = Polyobj_GetChild(oldpo, &start)))

  0083c	8d 45 d0	 lea	 eax, DWORD PTR _start$[ebp]
  0083f	50		 push	 eax
  00840	8b 4d c8	 mov	 ecx, DWORD PTR _oldpo$[ebp]
  00843	51		 push	 ecx
  00844	e8 00 00 00 00	 call	 _Polyobj_GetChild
  00849	83 c4 08	 add	 esp, 8
  0084c	89 45 cc	 mov	 DWORD PTR _po$[ebp], eax
  0084f	83 7d cc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00853	0f 84 89 00 00
	00		 je	 $LN17@T_PolyObjW

; 1900 : 	{
; 1901 : 		if (po->isBad)

  00859	8b 45 cc	 mov	 eax, DWORD PTR _po$[ebp]
  0085c	0f b6 88 a0 00
	00 00		 movzx	 ecx, BYTE PTR [eax+160]
  00863	85 c9		 test	 ecx, ecx
  00865	74 02		 je	 SHORT $LN64@T_PolyObjW

; 1902 : 			continue;

  00867	eb d3		 jmp	 SHORT $LN67@T_PolyObjW
$LN64@T_PolyObjW:

; 1903 : 
; 1904 : 		Polyobj_moveXY(po, momx, momy);

  00869	8b 45 dc	 mov	 eax, DWORD PTR _momy$[ebp]
  0086c	50		 push	 eax
  0086d	8b 4d e0	 mov	 ecx, DWORD PTR _momx$[ebp]
  00870	51		 push	 ecx
  00871	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00874	52		 push	 edx
  00875	e8 00 00 00 00	 call	 _Polyobj_moveXY
  0087a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1905 : 		// TODO: use T_MovePlane
; 1906 : 		po->lines[0]->backsector->floorheight += momz;

  0087d	b8 04 00 00 00	 mov	 eax, 4
  00882	6b c8 00	 imul	 ecx, eax, 0
  00885	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  00888	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0088b	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0088e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00891	8b 02		 mov	 eax, DWORD PTR [edx]
  00893	03 45 d8	 add	 eax, DWORD PTR _momz$[ebp]
  00896	b9 04 00 00 00	 mov	 ecx, 4
  0089b	6b d1 00	 imul	 edx, ecx, 0
  0089e	8b 4d cc	 mov	 ecx, DWORD PTR _po$[ebp]
  008a1	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  008a4	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  008a7	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  008aa	89 01		 mov	 DWORD PTR [ecx], eax

; 1907 : 		po->lines[0]->backsector->ceilingheight += momz;

  008ac	b8 04 00 00 00	 mov	 eax, 4
  008b1	6b c8 00	 imul	 ecx, eax, 0
  008b4	8b 55 cc	 mov	 edx, DWORD PTR _po$[ebp]
  008b7	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  008ba	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  008bd	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  008c0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008c3	03 45 d8	 add	 eax, DWORD PTR _momz$[ebp]
  008c6	b9 04 00 00 00	 mov	 ecx, 4
  008cb	6b d1 00	 imul	 edx, ecx, 0
  008ce	8b 4d cc	 mov	 ecx, DWORD PTR _po$[ebp]
  008d1	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  008d4	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  008d7	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  008da	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1908 : 	}

  008dd	e9 5a ff ff ff	 jmp	 $LN67@T_PolyObjW
$LN17@T_PolyObjW:

; 1909 : }

  008e2	5f		 pop	 edi
  008e3	5e		 pop	 esi
  008e4	5b		 pop	 ebx
  008e5	8b e5		 mov	 esp, ebp
  008e7	5d		 pop	 ebp
  008e8	c3		 ret	 0
_T_PolyObjWaypoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _T_PolyObjMove
_TEXT	SEGMENT
tv150 = -76						; size = 4
_avel$1 = -8						; size = 4
_po$ = -4						; size = 4
_th$ = 8						; size = 4
_T_PolyObjMove PROC					; COMDAT

; 1575 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1576 : 	polyobj_t *po = Polyobj_GetForNum(th->polyObjNum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax

; 1577 : 
; 1578 : 	if (!po)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001f	75 25		 jne	 SHORT $LN2@T_PolyObjM

; 1579 : #ifdef RANGECHECK
; 1580 : 		I_Error("T_PolyObjRotate: thinker has invalid id %d\n", th->polyObjNum);
; 1581 : #else
; 1582 : 	{
; 1583 : 		CONS_Printf("T_PolyObjRotate: thinker with invalid id %d removed.\n", th->polyObjNum);

  00021	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00024	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00027	51		 push	 ecx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HJMIMBAC@T_PolyObjRotate?3?5thinker?5with?5i@
  0002d	e8 00 00 00 00	 call	 _CONS_Printf
  00032	83 c4 08	 add	 esp, 8

; 1584 : 		P_RemoveThinkerDelayed(&th->thinker);

  00035	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _P_RemoveThinkerDelayed
  0003e	83 c4 04	 add	 esp, 4

; 1585 : 		return;

  00041	e9 46 01 00 00	 jmp	 $LN11@T_PolyObjM
$LN2@T_PolyObjM:

; 1586 : 	}
; 1587 : #endif
; 1588 : 
; 1589 : 	// check for displacement due to override and reattach when possible
; 1590 : 	if (po->thinker == NULL)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00049	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00050	75 61		 jne	 SHORT $LN6@T_PolyObjM

; 1591 : 	{
; 1592 : 		po->thinker = &th->thinker;

  00052	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00058	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 1593 : 
; 1594 : 		// reset polyobject's thrust
; 1595 : 		po->thrust = abs(th->speed) >> 3;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00061	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _abs
  0006a	83 c4 04	 add	 esp, 4
  0006d	c1 f8 03	 sar	 eax, 3
  00070	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  00073	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 1596 : 		if (po->thrust < FRACUNIT)

  00079	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0007c	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00086	7d 0f		 jge	 SHORT $LN4@T_PolyObjM

; 1597 : 			po->thrust = FRACUNIT;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0008b	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  00095	eb 1c		 jmp	 SHORT $LN6@T_PolyObjM
$LN4@T_PolyObjM:

; 1598 : 		else if (po->thrust > 4*FRACUNIT)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0009a	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  000a4	7e 0d		 jle	 SHORT $LN6@T_PolyObjM

; 1599 : 			po->thrust = 4*FRACUNIT;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  000a9	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN6@T_PolyObjM:

; 1600 : 	}
; 1601 : 
; 1602 : 	// move the polyobject one step along its movement angle
; 1603 : 	if (Polyobj_moveXY(po, th->momx, th->momy))

  000b3	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000b6	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000b9	51		 push	 ecx
  000ba	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000bd	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000c0	50		 push	 eax
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 _Polyobj_moveXY
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cd	85 c0		 test	 eax, eax
  000cf	0f 84 b7 00 00
	00		 je	 $LN11@T_PolyObjM

; 1604 : 	{
; 1605 : 		INT32 avel = abs(th->speed);

  000d5	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000d8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _abs
  000e1	83 c4 04	 add	 esp, 4
  000e4	89 45 f8	 mov	 DWORD PTR _avel$1[ebp], eax

; 1606 : 
; 1607 : 		// decrement distance by the amount it moved
; 1608 : 		th->distance -= avel;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000ea	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000ed	2b 4d f8	 sub	 ecx, DWORD PTR _avel$1[ebp]
  000f0	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000f3	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 1609 : 
; 1610 : 		// are we at or past the destination?
; 1611 : 		if (th->distance <= 0)

  000f6	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000f9	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000fd	7f 36		 jg	 SHORT $LN8@T_PolyObjM

; 1612 : 		{
; 1613 : 			// remove thinker
; 1614 : 			if (po->thinker == &th->thinker)

  000ff	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00102	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00105	39 81 9c 00 00
	00		 cmp	 DWORD PTR [ecx+156], eax
  0010b	75 1a		 jne	 SHORT $LN10@T_PolyObjM

; 1615 : 			{
; 1616 : 				po->thinker = NULL;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00110	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 1617 : 				po->thrust = FRACUNIT;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0011d	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
$LN10@T_PolyObjM:

; 1618 : 			}
; 1619 : 			P_RemoveThinker(&th->thinker);

  00127	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _P_RemoveThinker
  00130	83 c4 04	 add	 esp, 4

; 1620 : 
; 1621 : 			// TODO: notify scripts
; 1622 : 			// TODO: sound sequence stop event
; 1623 : 		}

  00133	eb 57		 jmp	 SHORT $LN11@T_PolyObjM
$LN8@T_PolyObjM:

; 1624 : 		else if (th->distance < avel)

  00135	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00138	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0013b	3b 4d f8	 cmp	 ecx, DWORD PTR _avel$1[ebp]
  0013e	7d 4c		 jge	 SHORT $LN11@T_PolyObjM

; 1625 : 		{
; 1626 : 			// we have less than one multiple of 'speed' left to go,
; 1627 : 			// so change the speed so that it doesn't pass the destination
; 1628 : 			th->speed = th->speed >= 0 ? th->distance : -th->distance;

  00140	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00143	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00147	7c 0b		 jl	 SHORT $LN13@T_PolyObjM
  00149	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  0014c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0014f	89 55 b4	 mov	 DWORD PTR tv150[ebp], edx
  00152	eb 0b		 jmp	 SHORT $LN14@T_PolyObjM
$LN13@T_PolyObjM:
  00154	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00157	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0015a	f7 d9		 neg	 ecx
  0015c	89 4d b4	 mov	 DWORD PTR tv150[ebp], ecx
$LN14@T_PolyObjM:
  0015f	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00162	8b 45 b4	 mov	 eax, DWORD PTR tv150[ebp]
  00165	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1629 : 			Polyobj_componentSpeed(th->speed, th->angle, &th->momx, &th->momy);

  00168	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0016b	83 c0 1c	 add	 eax, 28			; 0000001cH
  0016e	50		 push	 eax
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00172	83 c1 18	 add	 ecx, 24			; 00000018H
  00175	51		 push	 ecx
  00176	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00179	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0017c	50		 push	 eax
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00180	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 _Polyobj_componentSpeed
  00189	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@T_PolyObjM:

; 1630 : 		}
; 1631 : 	}
; 1632 : }

  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5b		 pop	 ebx
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c3		 ret	 0
_T_PolyObjMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _T_PolyObjRotate
_TEXT	SEGMENT
tv150 = -76						; size = 4
_avel$1 = -8						; size = 4
_po$ = -4						; size = 4
_th$ = 8						; size = 4
_T_PolyObjRotate PROC					; COMDAT

; 1503 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1504 : 	polyobj_t *po = Polyobj_GetForNum(th->polyObjNum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _Polyobj_GetForNum
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 fc	 mov	 DWORD PTR _po$[ebp], eax

; 1505 : 
; 1506 : 	if (!po)

  0001b	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  0001f	75 25		 jne	 SHORT $LN2@T_PolyObjR

; 1507 : #ifdef RANGECHECK
; 1508 : 		I_Error("T_PolyObjRotate: thinker has invalid id %d\n", th->polyObjNum);
; 1509 : #else
; 1510 : 	{
; 1511 : 		CONS_Printf("T_PolyObjRotate: thinker with invalid id %d removed.\n", th->polyObjNum);

  00021	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00024	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00027	51		 push	 ecx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HJMIMBAC@T_PolyObjRotate?3?5thinker?5with?5i@
  0002d	e8 00 00 00 00	 call	 _CONS_Printf
  00032	83 c4 08	 add	 esp, 8

; 1512 : 		P_RemoveThinkerDelayed(&th->thinker);

  00035	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _P_RemoveThinkerDelayed
  0003e	83 c4 04	 add	 esp, 4

; 1513 : 		return;

  00041	e9 28 01 00 00	 jmp	 $LN11@T_PolyObjR
$LN2@T_PolyObjR:

; 1514 : 	}
; 1515 : #endif
; 1516 : 
; 1517 : 	// check for displacement due to override and reattach when possible
; 1518 : 	if (po->thinker == NULL)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00049	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00050	75 61		 jne	 SHORT $LN6@T_PolyObjR

; 1519 : 	{
; 1520 : 		po->thinker = &th->thinker;

  00052	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  00058	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 1521 : 
; 1522 : 		// reset polyobject's thrust
; 1523 : 		po->thrust = abs(th->speed) >> 8;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00061	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _abs
  0006a	83 c4 04	 add	 esp, 4
  0006d	c1 f8 08	 sar	 eax, 8
  00070	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  00073	89 82 94 00 00
	00		 mov	 DWORD PTR [edx+148], eax

; 1524 : 		if (po->thrust < FRACUNIT)

  00079	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0007c	81 b8 94 00 00
	00 00 00 01 00	 cmp	 DWORD PTR [eax+148], 65536 ; 00010000H
  00086	7d 0f		 jge	 SHORT $LN4@T_PolyObjR

; 1525 : 			po->thrust = FRACUNIT;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0008b	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
  00095	eb 1c		 jmp	 SHORT $LN6@T_PolyObjR
$LN4@T_PolyObjR:

; 1526 : 		else if (po->thrust > 4*FRACUNIT)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  0009a	81 b8 94 00 00
	00 00 00 04 00	 cmp	 DWORD PTR [eax+148], 262144 ; 00040000H
  000a4	7e 0d		 jle	 SHORT $LN6@T_PolyObjR

; 1527 : 			po->thrust = 4*FRACUNIT;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  000a9	c7 80 94 00 00
	00 00 00 04 00	 mov	 DWORD PTR [eax+148], 262144 ; 00040000H
$LN6@T_PolyObjR:

; 1528 : 	}
; 1529 : 
; 1530 : 	// rotate by 'speed' angle per frame
; 1531 : 	// if distance == -1, this polyobject rotates perpetually
; 1532 : 	if (Polyobj_rotate(po, th->speed) && th->distance != -1)

  000b3	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000b6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000b9	51		 push	 ecx
  000ba	8b 55 fc	 mov	 edx, DWORD PTR _po$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _Polyobj_rotate
  000c3	83 c4 08	 add	 esp, 8
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 a0 00 00
	00		 je	 $LN11@T_PolyObjR
  000ce	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000d1	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  000d5	0f 84 93 00 00
	00		 je	 $LN11@T_PolyObjR

; 1533 : 	{
; 1534 : 		INT32 avel = abs(th->speed);

  000db	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000de	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _abs
  000e7	83 c4 04	 add	 esp, 4
  000ea	89 45 f8	 mov	 DWORD PTR _avel$1[ebp], eax

; 1535 : 
; 1536 : 		// decrement distance by the amount it moved
; 1537 : 		th->distance -= avel;

  000ed	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000f0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f3	2b 4d f8	 sub	 ecx, DWORD PTR _avel$1[ebp]
  000f6	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  000f9	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1538 : 
; 1539 : 		// are we at or past the destination?
; 1540 : 		if (th->distance <= 0)

  000fc	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  000ff	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00103	7f 36		 jg	 SHORT $LN8@T_PolyObjR

; 1541 : 		{
; 1542 : 			// remove thinker
; 1543 : 			if (po->thinker == &th->thinker)

  00105	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _po$[ebp]
  0010b	39 81 9c 00 00
	00		 cmp	 DWORD PTR [ecx+156], eax
  00111	75 1a		 jne	 SHORT $LN10@T_PolyObjR

; 1544 : 			{
; 1545 : 				po->thinker = NULL;

  00113	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00116	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 1546 : 				po->thrust = FRACUNIT;

  00120	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00123	c7 80 94 00 00
	00 00 00 01 00	 mov	 DWORD PTR [eax+148], 65536 ; 00010000H
$LN10@T_PolyObjR:

; 1547 : 			}
; 1548 : 			P_RemoveThinker(&th->thinker);

  0012d	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _P_RemoveThinker
  00136	83 c4 04	 add	 esp, 4

; 1549 : 
; 1550 : 			// TODO: notify scripts
; 1551 : 			// TODO: sound sequence stop event
; 1552 : 		}

  00139	eb 33		 jmp	 SHORT $LN11@T_PolyObjR
$LN8@T_PolyObjR:

; 1553 : 		else if (th->distance < avel)

  0013b	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0013e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00141	3b 4d f8	 cmp	 ecx, DWORD PTR _avel$1[ebp]
  00144	7d 28		 jge	 SHORT $LN11@T_PolyObjR

; 1554 : 		{
; 1555 : 			// we have less than one multiple of 'speed' left to go,
; 1556 : 			// so change the speed so that it doesn't pass the destination
; 1557 : 			th->speed = th->speed >= 0 ? th->distance : -th->distance;

  00146	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  00149	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0014d	7c 0b		 jl	 SHORT $LN13@T_PolyObjR
  0014f	8b 4d 08	 mov	 ecx, DWORD PTR _th$[ebp]
  00152	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00155	89 55 b4	 mov	 DWORD PTR tv150[ebp], edx
  00158	eb 0b		 jmp	 SHORT $LN14@T_PolyObjR
$LN13@T_PolyObjR:
  0015a	8b 45 08	 mov	 eax, DWORD PTR _th$[ebp]
  0015d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00160	f7 d9		 neg	 ecx
  00162	89 4d b4	 mov	 DWORD PTR tv150[ebp], ecx
$LN14@T_PolyObjR:
  00165	8b 55 08	 mov	 edx, DWORD PTR _th$[ebp]
  00168	8b 45 b4	 mov	 eax, DWORD PTR tv150[ebp]
  0016b	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN11@T_PolyObjR:

; 1558 : 		}
; 1559 : 	}
; 1560 : }

  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
_T_PolyObjRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_GetInfo
_TEXT	SEGMENT
_i$ = -4						; size = 4
_tag$ = 8						; size = 2
_polyID$ = 12						; size = 4
_mirrorID$ = 16						; size = 4
_exparg$ = 20						; size = 4
_Polyobj_GetInfo PROC					; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 254  : 	INT32 i = P_FindSpecialLineFromTag(POLYINFO_SPECIALNUM, tag, -1);

  00009	6a ff		 push	 -1
  0000b	0f b7 45 08	 movzx	 eax, WORD PTR _tag$[ebp]
  0000f	50		 push	 eax
  00010	6a 16		 push	 22			; 00000016H
  00012	e8 00 00 00 00	 call	 _P_FindSpecialLineFromTag
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 255  : 
; 256  : 	if (i == -1)

  0001d	83 7d fc ff	 cmp	 DWORD PTR _i$[ebp], -1
  00021	75 14		 jne	 SHORT $LN2@Polyobj_Ge

; 257  : 		I_Error("Polyobject (tag: %d) needs line %d for information.\n", tag, POLYINFO_SPECIALNUM);

  00023	6a 16		 push	 22			; 00000016H
  00025	0f bf 45 08	 movsx	 eax, WORD PTR _tag$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@ILBNMOLG@Polyobject?5?$CItag?3?5?$CFd?$CJ?5needs?5line@
  0002f	e8 00 00 00 00	 call	 _I_Error
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Polyobj_Ge:

; 258  : 
; 259  : 	if (polyID)

  00037	83 7d 0c 00	 cmp	 DWORD PTR _polyID$[ebp], 0
  0003b	74 18		 je	 SHORT $LN3@Polyobj_Ge

; 260  : 		*polyID = lines[i].frontsector->floorheight>>FRACBITS;

  0003d	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00047	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  0004b	8b 02		 mov	 eax, DWORD PTR [edx]
  0004d	c1 f8 10	 sar	 eax, 16			; 00000010H
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _polyID$[ebp]
  00053	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Polyobj_Ge:

; 261  : 
; 262  : 	if (mirrorID)

  00055	83 7d 10 00	 cmp	 DWORD PTR _mirrorID$[ebp], 0
  00059	74 17		 je	 SHORT $LN4@Polyobj_Ge

; 263  : 		*mirrorID = lines[i].frontsector->special;

  0005b	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00065	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00069	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _mirrorID$[ebp]
  00070	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Polyobj_Ge:

; 264  : 
; 265  : 	if (exparg)

  00072	83 7d 14 00	 cmp	 DWORD PTR _exparg$[ebp], 0
  00076	74 18		 je	 SHORT $LN5@Polyobj_Ge

; 266  : 		*exparg = (UINT16)lines[i].frontsector->lightlevel;

  00078	6b 45 fc 4c	 imul	 eax, DWORD PTR _i$[ebp], 76
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _lines
  00082	8b 54 01 30	 mov	 edx, DWORD PTR [ecx+eax+48]
  00086	8b 45 14	 mov	 eax, DWORD PTR _exparg$[ebp]
  00089	66 8b 4a 10	 mov	 cx, WORD PTR [edx+16]
  0008d	66 89 08	 mov	 WORD PTR [eax], cx
$LN5@Polyobj_Ge:

; 267  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_Polyobj_GetInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _P_BBoxInsidePolyobj
_TEXT	SEGMENT
_i$ = -4						; size = 4
_po$ = 8						; size = 4
_bbox$ = 12						; size = 4
_P_BBoxInsidePolyobj PROC				; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 235  : 	size_t i;
; 236  : 
; 237  : 	for (i = 0; i < po->numLines; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_BBoxInsi
$LN2@P_BBoxInsi:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_BBoxInsi:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00024	73 23		 jae	 SHORT $LN3@P_BBoxInsi

; 238  : 	{
; 239  : 		if (P_BoxOnLineSide(bbox, po->lines[i]) == 0)

  00026	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00029	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00032	50		 push	 eax
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _bbox$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  0003c	83 c4 08	 add	 esp, 8
  0003f	85 c0		 test	 eax, eax
  00041	75 04		 jne	 SHORT $LN5@P_BBoxInsi

; 240  : 			return false;

  00043	33 c0		 xor	 eax, eax
  00045	eb 07		 jmp	 SHORT $LN1@P_BBoxInsi
$LN5@P_BBoxInsi:

; 241  : 	}

  00047	eb c9		 jmp	 SHORT $LN2@P_BBoxInsi
$LN3@P_BBoxInsi:

; 242  : 
; 243  : 	return true;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_BBoxInsi:

; 244  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_P_BBoxInsidePolyobj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _P_MobjInsidePolyobj
_TEXT	SEGMENT
_i$ = -24						; size = 4
_mbbox$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_mo$ = 12						; size = 4
_P_MobjInsidePolyobj PROC				; COMDAT

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 211  : 	fixed_t mbbox[4];
; 212  : 	size_t i;
; 213  : 
; 214  : 	mbbox[BOXTOP] = mo->y + mo->radius;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00016	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00019	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0001c	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  0001f	b8 04 00 00 00	 mov	 eax, 4
  00024	6b d0 00	 imul	 edx, eax, 0
  00027	89 4c 15 ec	 mov	 DWORD PTR _mbbox$[ebp+edx], ecx

; 215  : 	mbbox[BOXBOTTOM] = mo->y - mo->radius;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00031	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00034	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00037	b8 04 00 00 00	 mov	 eax, 4
  0003c	c1 e0 00	 shl	 eax, 0
  0003f	89 54 05 ec	 mov	 DWORD PTR _mbbox$[ebp+eax], edx

; 216  : 	mbbox[BOXRIGHT] = mo->x + mo->radius;

  00043	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00046	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00049	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0004c	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b d0 03	 imul	 edx, eax, 3
  00057	89 4c 15 ec	 mov	 DWORD PTR _mbbox$[ebp+edx], ecx

; 217  : 	mbbox[BOXLEFT] = mo->x - mo->radius;

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00061	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00064	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00067	b8 04 00 00 00	 mov	 eax, 4
  0006c	d1 e0		 shl	 eax, 1
  0006e	89 54 05 ec	 mov	 DWORD PTR _mbbox$[ebp+eax], edx

; 218  : 
; 219  : 	for (i = 0; i < po->numLines; i++)

  00072	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00079	eb 09		 jmp	 SHORT $LN4@P_MobjInsi
$LN2@P_MobjInsi:
  0007b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_MobjInsi:
  00084	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00087	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0008a	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  0008d	73 23		 jae	 SHORT $LN3@P_MobjInsi

; 220  : 	{
; 221  : 		if (P_BoxOnLineSide(mbbox, po->lines[i]) == 0)

  0008f	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00092	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00095	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  00098	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0009b	50		 push	 eax
  0009c	8d 4d ec	 lea	 ecx, DWORD PTR _mbbox$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  000a5	83 c4 08	 add	 esp, 8
  000a8	85 c0		 test	 eax, eax
  000aa	75 04		 jne	 SHORT $LN5@P_MobjInsi

; 222  : 			return false;

  000ac	33 c0		 xor	 eax, eax
  000ae	eb 07		 jmp	 SHORT $LN1@P_MobjInsi
$LN5@P_MobjInsi:

; 223  : 	}

  000b0	eb c9		 jmp	 SHORT $LN2@P_MobjInsi
$LN3@P_MobjInsi:

; 224  : 
; 225  : 	return true;

  000b2	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_MobjInsi:

; 226  : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bd	33 cd		 xor	 ecx, ebp
  000bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_P_MobjInsidePolyobj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _P_MobjTouchingPolyobj
_TEXT	SEGMENT
_i$ = -24						; size = 4
_mbbox$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_po$ = 8						; size = 4
_mo$ = 12						; size = 4
_P_MobjTouchingPolyobj PROC				; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 187  : 	fixed_t mbbox[4];
; 188  : 	size_t i;
; 189  : 
; 190  : 	mbbox[BOXTOP] = mo->y + mo->radius;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00016	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00019	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0001c	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  0001f	b8 04 00 00 00	 mov	 eax, 4
  00024	6b d0 00	 imul	 edx, eax, 0
  00027	89 4c 15 ec	 mov	 DWORD PTR _mbbox$[ebp+edx], ecx

; 191  : 	mbbox[BOXBOTTOM] = mo->y - mo->radius;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00031	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00034	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00037	b8 04 00 00 00	 mov	 eax, 4
  0003c	c1 e0 00	 shl	 eax, 0
  0003f	89 54 05 ec	 mov	 DWORD PTR _mbbox$[ebp+eax], edx

; 192  : 	mbbox[BOXRIGHT] = mo->x + mo->radius;

  00043	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  00046	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00049	8b 55 0c	 mov	 edx, DWORD PTR _mo$[ebp]
  0004c	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b d0 03	 imul	 edx, eax, 3
  00057	89 4c 15 ec	 mov	 DWORD PTR _mbbox$[ebp+edx], ecx

; 193  : 	mbbox[BOXLEFT] = mo->x - mo->radius;

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  00061	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00064	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00067	b8 04 00 00 00	 mov	 eax, 4
  0006c	d1 e0		 shl	 eax, 1
  0006e	89 54 05 ec	 mov	 DWORD PTR _mbbox$[ebp+eax], edx

; 194  : 
; 195  : 	for (i = 0; i < po->numLines; i++)

  00072	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00079	eb 09		 jmp	 SHORT $LN4@P_MobjTouc
$LN2@P_MobjTouc:
  0007b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_MobjTouc:
  00084	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00087	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0008a	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  0008d	73 27		 jae	 SHORT $LN3@P_MobjTouc

; 196  : 	{
; 197  : 		if (P_BoxOnLineSide(mbbox, po->lines[i]) == -1)

  0008f	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00092	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00095	8b 55 e8	 mov	 edx, DWORD PTR _i$[ebp]
  00098	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0009b	50		 push	 eax
  0009c	8d 4d ec	 lea	 ecx, DWORD PTR _mbbox$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  000a5	83 c4 08	 add	 esp, 8
  000a8	83 f8 ff	 cmp	 eax, -1
  000ab	75 07		 jne	 SHORT $LN5@P_MobjTouc

; 198  : 			return true;

  000ad	b8 01 00 00 00	 mov	 eax, 1
  000b2	eb 04		 jmp	 SHORT $LN1@P_MobjTouc
$LN5@P_MobjTouc:

; 199  : 	}

  000b4	eb c5		 jmp	 SHORT $LN2@P_MobjTouc
$LN3@P_MobjTouc:

; 200  : 
; 201  : 	return false;

  000b6	33 c0		 xor	 eax, eax
$LN1@P_MobjTouc:

; 202  : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_P_MobjTouchingPolyobj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _P_PointInsidePolyobj
_TEXT	SEGMENT
_i$ = -4						; size = 4
_po$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_P_PointInsidePolyobj PROC				; COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 169  : 	size_t i;
; 170  : 
; 171  : 	for (i = 0; i < po->numLines; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_PointIns
$LN2@P_PointIns:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_PointIns:
  0001b	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	3b 48 38	 cmp	 ecx, DWORD PTR [eax+56]
  00024	73 27		 jae	 SHORT $LN3@P_PointIns

; 172  : 	{
; 173  : 		if (P_PointOnLineSide(x, y, po->lines[i]) == 0)

  00026	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00029	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00032	50		 push	 eax
  00033	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	85 c0		 test	 eax, eax
  00045	75 04		 jne	 SHORT $LN5@P_PointIns

; 174  : 			return false;

  00047	33 c0		 xor	 eax, eax
  00049	eb 07		 jmp	 SHORT $LN1@P_PointIns
$LN5@P_PointIns:

; 175  : 	}

  0004b	eb c5		 jmp	 SHORT $LN2@P_PointIns
$LN3@P_PointIns:

; 176  : 
; 177  : 	return true;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_PointIns:

; 178  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_P_PointInsidePolyobj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_MoveOnLoad
_TEXT	SEGMENT
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_po$ = 8						; size = 4
_angle$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_Polyobj_MoveOnLoad PROC				; COMDAT

; 1481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1482 : 	fixed_t dx, dy;
; 1483 : 
; 1484 : 	// first, rotate to the saved angle
; 1485 : 	Polyobj_rotate(po, angle);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _angle$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _po$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _Polyobj_rotate
  00016	83 c4 08	 add	 esp, 8

; 1486 : 
; 1487 : 	// determine component distances to translate
; 1488 : 	dx = x - po->spawnSpot.x;

  00019	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]
  0001f	2b 48 54	 sub	 ecx, DWORD PTR [eax+84]
  00022	89 4d fc	 mov	 DWORD PTR _dx$[ebp], ecx

; 1489 : 	dy = y - po->spawnSpot.y;

  00025	8b 45 08	 mov	 eax, DWORD PTR _po$[ebp]
  00028	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  0002b	2b 48 58	 sub	 ecx, DWORD PTR [eax+88]
  0002e	89 4d f8	 mov	 DWORD PTR _dy$[ebp], ecx

; 1490 : 
; 1491 : 	// translate
; 1492 : 	Polyobj_moveXY(po, dx, dy);

  00031	8b 45 f8	 mov	 eax, DWORD PTR _dy$[ebp]
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _dx$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _po$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _Polyobj_moveXY
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1493 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_Polyobj_MoveOnLoad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_InitLevel
_TEXT	SEGMENT
_mo$1 = -44						; size = 4
_numAnchors$ = -40					; size = 4
_i$ = -36						; size = 4
_qitem$ = -32						; size = 4
_anchorqueue$ = -28					; size = 12
_spawnqueue$ = -16					; size = 12
_th$ = -4						; size = 4
_Polyobj_InitLevel PROC					; COMDAT

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1359 : 	thinker_t   *th;
; 1360 : 	mqueue_t    spawnqueue;
; 1361 : 	mqueue_t    anchorqueue;
; 1362 : 	mobjqitem_t *qitem;
; 1363 : 	INT32 i, numAnchors = 0;

  00009	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _numAnchors$[ebp], 0

; 1364 : 
; 1365 : 	M_QueueInit(&spawnqueue);

  00010	8d 45 f0	 lea	 eax, DWORD PTR _spawnqueue$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _M_QueueInit
  00019	83 c4 04	 add	 esp, 4

; 1366 : 	M_QueueInit(&anchorqueue);

  0001c	8d 45 e4	 lea	 eax, DWORD PTR _anchorqueue$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _M_QueueInit
  00025	83 c4 04	 add	 esp, 4

; 1367 : 
; 1368 : 	// get rid of values from previous level
; 1369 : 	// note: as with msecnodes, it is very important to clear out the blockmap
; 1370 : 	// node freelist, otherwise it may contain dangling pointers to old objects
; 1371 : 	PolyObjects    = NULL;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _PolyObjects, 0

; 1372 : 	numPolyObjects = 0;

  00032	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numPolyObjects, 0

; 1373 : 	bmap_freelist  = NULL;

  0003c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bmap_freelist, 0

; 1374 : 
; 1375 : 	// run down the thinker list, count the number of spawn points, and save
; 1376 : 	// the mobj_t pointers on a queue for use below.
; 1377 : 	for (th = thinkercap.next; th != &thinkercap; th = th->next)

  00046	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  0004b	89 45 fc	 mov	 DWORD PTR _th$[ebp], eax
  0004e	eb 09		 jmp	 SHORT $LN4@Polyobj_In
$LN2@Polyobj_In:
  00050	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	89 4d fc	 mov	 DWORD PTR _th$[ebp], ecx
$LN4@Polyobj_In:
  00059	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _th$[ebp], OFFSET _thinkercap
  00060	0f 84 d2 00 00
	00		 je	 $LN3@Polyobj_In

; 1378 : 	{
; 1379 : 		if (th->function.acp1 == (actionf_p1)P_MobjThinker)

  00066	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00069	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _P_MobjThinker
  00070	0f 85 bd 00 00
	00		 jne	 $LN21@Polyobj_In

; 1380 : 		{
; 1381 : 			mobj_t *mo = (mobj_t *)th;

  00076	8b 45 fc	 mov	 eax, DWORD PTR _th$[ebp]
  00079	89 45 d4	 mov	 DWORD PTR _mo$1[ebp], eax

; 1382 : 
; 1383 : 			if (mo->info->doomednum == POLYOBJ_SPAWN_DOOMEDNUM ||

  0007c	8b 45 d4	 mov	 eax, DWORD PTR _mo$1[ebp]
  0007f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00085	81 39 f9 02 00
	00		 cmp	 DWORD PTR [ecx], 761	; 000002f9H
  0008b	74 11		 je	 SHORT $LN20@Polyobj_In
  0008d	8b 45 d4	 mov	 eax, DWORD PTR _mo$1[ebp]
  00090	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00096	81 39 fa 02 00
	00		 cmp	 DWORD PTR [ecx], 762	; 000002faH
  0009c	75 45		 jne	 SHORT $LN18@Polyobj_In
$LN20@Polyobj_In:

; 1384 : 				mo->info->doomednum == POLYOBJ_SPAWNCRUSH_DOOMEDNUM)
; 1385 : 			{
; 1386 : 				++numPolyObjects;

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _numPolyObjects
  000a3	83 c0 01	 add	 eax, 1
  000a6	a3 00 00 00 00	 mov	 DWORD PTR _numPolyObjects, eax

; 1387 : 
; 1388 : 				qitem = malloc(sizeof(mobjqitem_t));

  000ab	6a 08		 push	 8
  000ad	e8 00 00 00 00	 call	 _malloc
  000b2	83 c4 04	 add	 esp, 4
  000b5	89 45 e0	 mov	 DWORD PTR _qitem$[ebp], eax

; 1389 : 				memset(qitem, 0, sizeof(mobjqitem_t));

  000b8	6a 08		 push	 8
  000ba	6a 00		 push	 0
  000bc	8b 45 e0	 mov	 eax, DWORD PTR _qitem$[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _memset
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 : 				qitem->mo = mo;

  000c8	8b 45 e0	 mov	 eax, DWORD PTR _qitem$[ebp]
  000cb	8b 4d d4	 mov	 ecx, DWORD PTR _mo$1[ebp]
  000ce	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1391 : 				M_QueueInsert(&(qitem->mqitem), &spawnqueue);

  000d1	8d 45 f0	 lea	 eax, DWORD PTR _spawnqueue$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d e0	 mov	 ecx, DWORD PTR _qitem$[ebp]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _M_QueueInsert
  000de	83 c4 08	 add	 esp, 8

; 1392 : 			}

  000e1	eb 50		 jmp	 SHORT $LN21@Polyobj_In
$LN18@Polyobj_In:

; 1393 : 			else if (mo->info->doomednum == POLYOBJ_ANCHOR_DOOMEDNUM)

  000e3	8b 45 d4	 mov	 eax, DWORD PTR _mo$1[ebp]
  000e6	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000ec	81 39 f8 02 00
	00		 cmp	 DWORD PTR [ecx], 760	; 000002f8H
  000f2	75 3f		 jne	 SHORT $LN21@Polyobj_In

; 1394 : 			{
; 1395 : 				++numAnchors;

  000f4	8b 45 d8	 mov	 eax, DWORD PTR _numAnchors$[ebp]
  000f7	83 c0 01	 add	 eax, 1
  000fa	89 45 d8	 mov	 DWORD PTR _numAnchors$[ebp], eax

; 1396 : 
; 1397 : 				qitem = malloc(sizeof(mobjqitem_t));

  000fd	6a 08		 push	 8
  000ff	e8 00 00 00 00	 call	 _malloc
  00104	83 c4 04	 add	 esp, 4
  00107	89 45 e0	 mov	 DWORD PTR _qitem$[ebp], eax

; 1398 : 				memset(qitem, 0, sizeof(mobjqitem_t));

  0010a	6a 08		 push	 8
  0010c	6a 00		 push	 0
  0010e	8b 45 e0	 mov	 eax, DWORD PTR _qitem$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _memset
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1399 : 				qitem->mo = mo;

  0011a	8b 45 e0	 mov	 eax, DWORD PTR _qitem$[ebp]
  0011d	8b 4d d4	 mov	 ecx, DWORD PTR _mo$1[ebp]
  00120	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1400 : 				M_QueueInsert(&(qitem->mqitem), &anchorqueue);

  00123	8d 45 e4	 lea	 eax, DWORD PTR _anchorqueue$[ebp]
  00126	50		 push	 eax
  00127	8b 4d e0	 mov	 ecx, DWORD PTR _qitem$[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 _M_QueueInsert
  00130	83 c4 08	 add	 esp, 8
$LN21@Polyobj_In:

; 1401 : 			}
; 1402 : 		}
; 1403 : 	}

  00133	e9 18 ff ff ff	 jmp	 $LN2@Polyobj_In
$LN3@Polyobj_In:

; 1404 : 
; 1405 : 	if (numPolyObjects)

  00138	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numPolyObjects, 0
  0013f	0f 84 32 01 00
	00		 je	 $LN15@Polyobj_In

; 1406 : 	{
; 1407 : 		// allocate the PolyObjects array
; 1408 : 		PolyObjects = Z_Calloc(numPolyObjects * sizeof(polyobj_t),

  00145	6a 00		 push	 0
  00147	6a 00		 push	 0
  00149	6a 32		 push	 50			; 00000032H
  0014b	69 05 00 00 00
	00 a8 00 00 00	 imul	 eax, DWORD PTR _numPolyObjects, 168
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _Z_CallocAlign
  0015b	83 c4 10	 add	 esp, 16			; 00000010H
  0015e	a3 00 00 00 00	 mov	 DWORD PTR _PolyObjects, eax

; 1409 : 													PU_LEVEL, NULL);
; 1410 : 
; 1411 : 		// setup hash fields
; 1412 : 		for (i = 0; i < numPolyObjects; ++i)

  00163	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0016a	eb 09		 jmp	 SHORT $LN7@Polyobj_In
$LN5@Polyobj_In:
  0016c	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  0016f	83 c0 01	 add	 eax, 1
  00172	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Polyobj_In:
  00175	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00178	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numPolyObjects
  0017e	7d 30		 jge	 SHORT $LN6@Polyobj_In

; 1413 : 			PolyObjects[i].first = PolyObjects[i].next = numPolyObjects;

  00180	69 45 dc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PolyObjects
  0018d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numPolyObjects
  00193	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx
  00197	69 45 dc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  0019e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PolyObjects
  001a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numPolyObjects
  001aa	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx
  001ae	eb bc		 jmp	 SHORT $LN5@Polyobj_In
$LN6@Polyobj_In:

; 1414 : 
; 1415 : 		// setup polyobjects
; 1416 : 		for (i = 0; i < numPolyObjects; ++i)

  001b0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001b7	eb 09		 jmp	 SHORT $LN10@Polyobj_In
$LN8@Polyobj_In:
  001b9	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  001bc	83 c0 01	 add	 eax, 1
  001bf	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Polyobj_In:
  001c2	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  001c5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numPolyObjects
  001cb	7d 35		 jge	 SHORT $LN9@Polyobj_In

; 1417 : 		{
; 1418 : 			qitem = (mobjqitem_t *)M_QueueIterator(&spawnqueue);

  001cd	8d 45 f0	 lea	 eax, DWORD PTR _spawnqueue$[ebp]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _M_QueueIterator
  001d6	83 c4 04	 add	 esp, 4
  001d9	89 45 e0	 mov	 DWORD PTR _qitem$[ebp], eax

; 1419 : 
; 1420 : 			Polyobj_spawnPolyObj(i, qitem->mo, qitem->mo->spawnpoint->angle);

  001dc	8b 45 e0	 mov	 eax, DWORD PTR _qitem$[ebp]
  001df	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e2	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  001e8	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  001ec	50		 push	 eax
  001ed	8b 4d e0	 mov	 ecx, DWORD PTR _qitem$[ebp]
  001f0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001f3	52		 push	 edx
  001f4	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _Polyobj_spawnPolyObj
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1421 : 		}

  00200	eb b7		 jmp	 SHORT $LN8@Polyobj_In
$LN9@Polyobj_In:

; 1422 : 
; 1423 : 		// move polyobjects to spawn points
; 1424 : 		for (i = 0; i < numAnchors; ++i)

  00202	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00209	eb 09		 jmp	 SHORT $LN13@Polyobj_In
$LN11@Polyobj_In:
  0020b	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  0020e	83 c0 01	 add	 eax, 1
  00211	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@Polyobj_In:
  00214	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00217	3b 45 d8	 cmp	 eax, DWORD PTR _numAnchors$[ebp]
  0021a	7d 26		 jge	 SHORT $LN12@Polyobj_In

; 1425 : 		{
; 1426 : 			qitem = (mobjqitem_t *)M_QueueIterator(&anchorqueue);

  0021c	8d 45 e4	 lea	 eax, DWORD PTR _anchorqueue$[ebp]
  0021f	50		 push	 eax
  00220	e8 00 00 00 00	 call	 _M_QueueIterator
  00225	83 c4 04	 add	 esp, 4
  00228	89 45 e0	 mov	 DWORD PTR _qitem$[ebp], eax

; 1427 : 
; 1428 : 			Polyobj_moveToSpawnSpot((qitem->mo->spawnpoint));

  0022b	8b 45 e0	 mov	 eax, DWORD PTR _qitem$[ebp]
  0022e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00231	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00237	52		 push	 edx
  00238	e8 00 00 00 00	 call	 _Polyobj_moveToSpawnSpot
  0023d	83 c4 04	 add	 esp, 4

; 1429 : 		}

  00240	eb c9		 jmp	 SHORT $LN11@Polyobj_In
$LN12@Polyobj_In:

; 1430 : 
; 1431 : 		// setup polyobject clipping
; 1432 : 		for (i = 0; i < numPolyObjects; ++i)

  00242	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00249	eb 09		 jmp	 SHORT $LN16@Polyobj_In
$LN14@Polyobj_In:
  0024b	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  0024e	83 c0 01	 add	 eax, 1
  00251	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@Polyobj_In:
  00254	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00257	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numPolyObjects
  0025d	7d 18		 jge	 SHORT $LN15@Polyobj_In

; 1433 : 			Polyobj_linkToBlockmap(&PolyObjects[i]);

  0025f	69 45 dc a8 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 168
  00266	03 05 00 00 00
	00		 add	 eax, DWORD PTR _PolyObjects
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _Polyobj_linkToBlockmap
  00272	83 c4 04	 add	 esp, 4
  00275	eb d4		 jmp	 SHORT $LN14@Polyobj_In
$LN15@Polyobj_In:

; 1434 : 	}
; 1435 : 
; 1436 : #if 0
; 1437 : 	// haleyjd 02/22/06: temporary debug
; 1438 : 	printf("DEBUG: numPolyObjects = %d\n", numPolyObjects);
; 1439 : 	for (i = 0; i < numPolyObjects; ++i)
; 1440 : 	{
; 1441 : 		INT32 j;
; 1442 : 		polyobj_t *po = &PolyObjects[i];
; 1443 : 
; 1444 : 		printf("polyobj %d:\n", i);
; 1445 : 		printf("id = %d, first = %d, next = %d\n", po->id, po->first, po->next);
; 1446 : 		printf("segCount = %d, numSegsAlloc = %d\n", po->segCount, po->numSegsAlloc);
; 1447 : 		for (j = 0; j < po->segCount; ++j)
; 1448 : 			printf("\tseg %d: %p\n", j, po->segs[j]);
; 1449 : 		printf("numVertices = %d, numVerticesAlloc = %d\n", po->numVertices, po->numVerticesAlloc);
; 1450 : 		for (j = 0; j < po->numVertices; ++j)
; 1451 : 		{
; 1452 : 			printf("\tvtx %d: (%d, %d) / orig: (%d, %d)\n",
; 1453 : 				j, po->vertices[j]->x>>FRACBITS, po->vertices[j]->y>>FRACBITS,
; 1454 : 				po->origVerts[j].x>>FRACBITS, po->origVerts[j].y>>FRACBITS);
; 1455 : 		}
; 1456 : 		printf("numLines = %d, numLinesAlloc = %d\n", po->numLines, po->numLinesAlloc);
; 1457 : 		for (j = 0; j < po->numLines; ++j)
; 1458 : 			printf("\tline %d: %p\n", j, po->lines[j]);
; 1459 : 		printf("spawnSpot = (%d, %d)\n", po->spawnSpot.x >> FRACBITS, po->spawnSpot.y >> FRACBITS);
; 1460 : 		printf("centerPt = (%d, %d)\n", po->centerPt.x >> FRACBITS, po->centerPt.y >> FRACBITS);
; 1461 : 		printf("attached = %d, linked = %d, validcount = %d, isBad = %d\n",
; 1462 : 			po->attached, po->linked, po->validcount, po->isBad);
; 1463 : 		printf("blockbox: [%d, %d, %d, %d]\n",
; 1464 : 			po->blockbox[BOXLEFT], po->blockbox[BOXRIGHT], po->blockbox[BOXBOTTOM],
; 1465 : 			po->blockbox[BOXTOP]);
; 1466 : 	}
; 1467 : #endif
; 1468 : 
; 1469 : 	// done with mobj queues
; 1470 : 	M_QueueFree(&spawnqueue);

  00277	8d 45 f0	 lea	 eax, DWORD PTR _spawnqueue$[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 _M_QueueFree
  00280	83 c4 04	 add	 esp, 4

; 1471 : 	M_QueueFree(&anchorqueue);

  00283	8d 45 e4	 lea	 eax, DWORD PTR _anchorqueue$[ebp]
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 _M_QueueFree
  0028c	83 c4 04	 add	 esp, 4

; 1472 : }

  0028f	5f		 pop	 edi
  00290	5e		 pop	 esi
  00291	5b		 pop	 ebx
  00292	8b e5		 mov	 esp, ebp
  00294	5d		 pop	 ebp
  00295	c3		 ret	 0
_Polyobj_InitLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\p_polyobj.c
;	COMDAT _Polyobj_GetForNum
_TEXT	SEGMENT
tv79 = -72						; size = 4
_curidx$ = -4						; size = 4
_id$ = 8						; size = 4
_Polyobj_GetForNum PROC					; COMDAT

; 1305 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1306 : 	INT32 curidx  = PolyObjects[id % numPolyObjects].first;

  00009	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0000c	99		 cdq
  0000d	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _numPolyObjects
  00013	69 c2 a8 00 00
	00		 imul	 eax, edx, 168
  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PolyObjects
  0001f	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00023	89 55 fc	 mov	 DWORD PTR _curidx$[ebp], edx
$LN2@Polyobj_Ge:

; 1307 : 
; 1308 : 	while (curidx != numPolyObjects && PolyObjects[curidx].id != id)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _curidx$[ebp]
  00029	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numPolyObjects
  0002f	74 2c		 je	 SHORT $LN3@Polyobj_Ge
  00031	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _curidx$[ebp], 168
  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PolyObjects
  0003e	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  00042	3b 55 08	 cmp	 edx, DWORD PTR _id$[ebp]
  00045	74 16		 je	 SHORT $LN3@Polyobj_Ge

; 1309 : 		curidx = PolyObjects[curidx].next;

  00047	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _curidx$[ebp], 168
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PolyObjects
  00054	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00058	89 55 fc	 mov	 DWORD PTR _curidx$[ebp], edx
  0005b	eb c9		 jmp	 SHORT $LN2@Polyobj_Ge
$LN3@Polyobj_Ge:

; 1310 : 
; 1311 : 	return curidx == numPolyObjects ? NULL : &PolyObjects[curidx];

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _curidx$[ebp]
  00060	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numPolyObjects
  00066	75 09		 jne	 SHORT $LN5@Polyobj_Ge
  00068	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  0006f	eb 10		 jmp	 SHORT $LN6@Polyobj_Ge
$LN5@Polyobj_Ge:
  00071	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _curidx$[ebp], 168
  00078	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _PolyObjects
  0007e	89 4d b8	 mov	 DWORD PTR tv79[ebp], ecx
$LN6@Polyobj_Ge:
  00081	8b 45 b8	 mov	 eax, DWORD PTR tv79[ebp]

; 1312 : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_Polyobj_GetForNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_dllist.h
;	COMDAT _M_DLListRemove
_TEXT	SEGMENT
_next$ = -8						; size = 4
_prev$ = -4						; size = 4
_item$ = 8						; size = 4
_M_DLListRemove PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 64   : 	mdllistitem_t **prev = item->prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	89 4d fc	 mov	 DWORD PTR _prev$[ebp], ecx

; 65   : 	mdllistitem_t *next  = item->next;

  00012	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 66   : 
; 67   : 	if ((*prev = next))

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _prev$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00020	89 08		 mov	 DWORD PTR [eax], ecx
  00022	83 7d f8 00	 cmp	 DWORD PTR _next$[ebp], 0
  00026	74 09		 je	 SHORT $LN2@M_DLListRe

; 68   : 		next->prev = prev;

  00028	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _prev$[ebp]
  0002e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@M_DLListRe:

; 69   : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_M_DLListRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_dllist.h
;	COMDAT _M_DLListInsert
_TEXT	SEGMENT
_next$ = -4						; size = 4
_item$ = 8						; size = 4
_head$ = 12						; size = 4
_M_DLListInsert PROC					; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 54   : 	mdllistitem_t *next = *head;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 55   : 
; 56   : 	if ((item->next = next))

  00011	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	83 7d fc 00	 cmp	 DWORD PTR _next$[ebp], 0
  0001d	74 09		 je	 SHORT $LN2@M_DLListIn

; 57   : 		next->prev = &item->next;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN2@M_DLListIn:

; 58   : 	item->prev = head;

  00028	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  0002e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 59   : 	*head = item;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 60   : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_M_DLListInsert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
END
