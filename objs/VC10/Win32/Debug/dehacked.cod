; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\dehacked.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_deh_loaded
PUBLIC	_modcredits
PUBLIC	??_C@_09BJMGHFGB@A_EXPLODE@			; `string'
PUBLIC	??_C@_06HHDNMADJ@A_PAIN@			; `string'
PUBLIC	??_C@_06KMGAACHC@A_FALL@			; `string'
PUBLIC	??_C@_0N@ONKHEMAF@A_MONITORPOP@			; `string'
PUBLIC	??_C@_06ELAIEFHO@A_LOOK@			; `string'
PUBLIC	??_C@_07ILGEAEAA@A_CHASE@			; `string'
PUBLIC	??_C@_0N@OIJAEHGO@A_FACETARGET@			; `string'
PUBLIC	??_C@_08BNHOHEIM@A_SCREAM@			; `string'
PUBLIC	??_C@_0M@OCDNBEND@A_BOSSDEATH@			; `string'
PUBLIC	??_C@_0O@EEMLAPNN@A_CUSTOMPOWER@		; `string'
PUBLIC	??_C@_0N@CBNDHKJG@A_GIVEWEAPON@			; `string'
PUBLIC	??_C@_0N@EMIAHIHJ@A_RINGSHIELD@			; `string'
PUBLIC	??_C@_09OBEONDPD@A_RINGBOX@			; `string'
PUBLIC	??_C@_0BA@EOCKJFCP@A_INVINCIBILITY@		; `string'
PUBLIC	??_C@_0BA@PILBDMPL@A_SUPERSNEAKERS@		; `string'
PUBLIC	??_C@_0L@KNLLKMCD@A_BUNNYHOP@			; `string'
PUBLIC	??_C@_0O@JNDLILOG@A_BUBBLESPAWN@		; `string'
PUBLIC	??_C@_0N@PLPBDHK@A_BUBBLERISE@			; `string'
PUBLIC	??_C@_0O@CHEHDNIA@A_BUBBLECHECK@		; `string'
PUBLIC	??_C@_0M@FGJHPAMB@A_EXTRALIFE@			; `string'
PUBLIC	??_C@_0N@JOAFPOFE@A_BOMBSHIELD@			; `string'
PUBLIC	??_C@_0N@CKNEDIGG@A_JUMPSHIELD@			; `string'
PUBLIC	??_C@_0O@FFFOIECP@A_WATERSHIELD@		; `string'
PUBLIC	??_C@_0O@JIOPDPEF@A_FORCESHIELD@		; `string'
PUBLIC	??_C@_0N@INHLNJNE@A_GRAVITYBOX@			; `string'
PUBLIC	??_C@_0M@CNMPPKNB@A_SCORERISE@			; `string'
PUBLIC	??_C@_0BA@GNGNFDEI@A_PARTICLESPAWN@		; `string'
PUBLIC	??_C@_0P@JICBJCDN@A_ATTRACTCHASE@		; `string'
PUBLIC	??_C@_0L@FAGEGOOL@A_DROPMINE@			; `string'
PUBLIC	??_C@_0L@INKEHBCG@A_FISHJUMP@			; `string'
PUBLIC	??_C@_0N@IFLPCKFM@A_THROWNRING@			; `string'
PUBLIC	??_C@_0O@LNPHKGMC@A_GRENADERING@		; `string'
PUBLIC	??_C@_0BA@GCOHKLLG@A_SETSOLIDSTEAM@		; `string'
PUBLIC	??_C@_0BC@PPICBAMN@A_UNSETSOLIDSTEAM@		; `string'
PUBLIC	??_C@_0N@KNGNHPPM@A_SIGNPLAYER@			; `string'
PUBLIC	??_C@_0L@BHOJKCPG@A_JETCHASE@			; `string'
PUBLIC	??_C@_0M@KLMGNLHK@A_JETBTHINK@			; `string'
PUBLIC	??_C@_0M@PJPOPENN@A_JETGTHINK@			; `string'
PUBLIC	??_C@_0M@NAIPPBA@A_JETGSHOOT@			; `string'
PUBLIC	??_C@_0O@CPAABHMI@A_SHOOTBULLET@		; `string'
PUBLIC	??_C@_0P@EKOOHBIL@A_MINUSDIGGING@		; `string'
PUBLIC	??_C@_0N@HFELODHD@A_MINUSPOPUP@			; `string'
PUBLIC	??_C@_0N@JEHDPMKD@A_MINUSCHECK@			; `string'
PUBLIC	??_C@_0P@MBEJLNCB@A_CHICKENCHECK@		; `string'
PUBLIC	??_C@_0N@CJEEOOPD@A_MOUSETHINK@			; `string'
PUBLIC	??_C@_0N@CKFJCDAD@A_DETONCHASE@			; `string'
PUBLIC	??_C@_0M@BKMIJGKJ@A_CAPECHASE@			; `string'
PUBLIC	??_C@_0BC@HNBHOLIF@A_ROTATESPIKEBALL@		; `string'
PUBLIC	??_C@_0N@HGHNNEEL@A_MACEROTATE@			; `string'
PUBLIC	??_C@_0M@PNGEFLH@A_ROCKSPAWN@			; `string'
PUBLIC	??_C@_0L@DLHGIFJG@A_SNOWBALL@			; `string'
PUBLIC	??_C@_0BH@LCFLDBKE@A_CRAWLACOMMANDERTHINK@	; `string'
PUBLIC	??_C@_0P@FMAPOIFK@A_SMOKETRAILER@		; `string'
PUBLIC	??_C@_0O@ECONMIAO@A_RINGEXPLODE@		; `string'
PUBLIC	??_C@_0BB@LMKNJAFP@A_OLDRINGEXPLODE@		; `string'
PUBLIC	??_C@_07JCCHMOHD@A_MIXUP@			; `string'
PUBLIC	??_C@_0BA@ECFAMBON@A_RECYCLEPOWERS@		; `string'
PUBLIC	??_C@_0N@OOPLCIEI@A_BOSSSCREAM@			; `string'
PUBLIC	??_C@_0BB@OEKDEFGL@A_INVINCIBLERIZE@		; `string'
PUBLIC	??_C@_0BD@OJMFPBOH@A_DEINVINCIBLERIZE@		; `string'
PUBLIC	??_C@_0M@KGMLCPKE@A_GOOPSPLAT@			; `string'
PUBLIC	??_C@_0P@PGHLMEMF@A_BOSS2POGOSFX@		; `string'
PUBLIC	??_C@_0O@LLEBMPPF@A_BOSSJETFUME@		; `string'
PUBLIC	??_C@_0M@BLDACEHM@A_EGGMANBOX@			; `string'
PUBLIC	??_C@_0N@FADHKBDA@A_TURRETFIRE@			; `string'
PUBLIC	??_C@_0BC@MEIAKHOI@A_SUPERTURRETFIRE@		; `string'
PUBLIC	??_C@_0N@HJAPOALH@A_TURRETSTOP@			; `string'
PUBLIC	??_C@_0N@EDDEDDAD@A_JETJAWROAM@			; `string'
PUBLIC	??_C@_0O@LJIEECMA@A_JETJAWCHOMP@		; `string'
PUBLIC	??_C@_0O@MGBEBIKD@A_POINTYTHINK@		; `string'
PUBLIC	??_C@_0N@NDFMEJOG@A_CHECKBUDDY@			; `string'
PUBLIC	??_C@_0M@HIBMJJJO@A_HOODTHINK@			; `string'
PUBLIC	??_C@_0N@BCOHKMOO@A_ARROWCHECK@			; `string'
PUBLIC	??_C@_0P@KPFAEKCM@A_SNAILERTHINK@		; `string'
PUBLIC	??_C@_0N@GOGCLNKM@A_SHARPCHASE@			; `string'
PUBLIC	??_C@_0M@LDPCLNO@A_SHARPSPIN@			; `string'
PUBLIC	??_C@_0O@IPLAPNKM@A_VULTUREVTOL@		; `string'
PUBLIC	??_C@_0P@FOIIIHAC@A_VULTURECHECK@		; `string'
PUBLIC	??_C@_0M@PIFDPJLI@A_SKIMCHASE@			; `string'
PUBLIC	??_C@_0N@MBCBHIOH@A_1UPTHINKER@			; `string'
PUBLIC	??_C@_0O@IBCEMJDJ@A_SKULLATTACK@		; `string'
PUBLIC	??_C@_09MKAFJLIB@A_LOBSHOT@			; `string'
PUBLIC	??_C@_0N@HLMEOAII@A_CANNONLOOK@			; `string'
PUBLIC	??_C@_0L@DPCGACJH@A_FIRESHOT@			; `string'
PUBLIC	??_C@_0BA@NEIOHAPA@A_SUPERFIRESHOT@		; `string'
PUBLIC	??_C@_0P@PCGNPOIH@A_BOSSFIRESHOT@		; `string'
PUBLIC	??_C@_0O@KNFAFHKP@A_SPARKFOLLOW@		; `string'
PUBLIC	??_C@_09KJIDBPJD@A_BUZZFLY@			; `string'
PUBLIC	??_C@_0N@DBIMLIGA@A_GUARDCHASE@			; `string'
PUBLIC	??_C@_0BC@IEAHIAIA@A_SETREACTIONTIME@		; `string'
PUBLIC	??_C@_0BC@HBGLJLHG@A_BOSS3TAKEDAMAGE@		; `string'
PUBLIC	??_C@_0BB@LNGKEENP@A_LINEDEFEXECUTE@		; `string'
PUBLIC	??_C@_0P@DKHNAODF@A_PLAYSEESOUND@		; `string'
PUBLIC	??_C@_0BC@ONICOINE@A_PLAYATTACKSOUND@		; `string'
PUBLIC	??_C@_0BC@LFPDNPJG@A_PLAYACTIVESOUND@		; `string'
PUBLIC	??_C@_0BG@ELDBAFFM@A_SPAWNOBJECTABSOLUTE@	; `string'
PUBLIC	??_C@_0BG@DGPOBPKM@A_SPAWNOBJECTRELATIVE@	; `string'
PUBLIC	??_C@_0BG@LDPDDKM@A_CHANGEANGLERELATIVE@	; `string'
PUBLIC	??_C@_0BG@HGPACJFM@A_CHANGEANGLEABSOLUTE@	; `string'
PUBLIC	??_C@_0M@FEBJJDDL@A_PLAYSOUND@			; `string'
PUBLIC	??_C@_0N@MGKCOAFD@A_FINDTARGET@			; `string'
PUBLIC	??_C@_0N@LNJIENOF@A_FINDTRACER@			; `string'
PUBLIC	??_C@_09FCKGNCBI@A_SETTICS@			; `string'
PUBLIC	??_C@_0BA@KOJLBKIK@A_SETRANDOMTICS@		; `string'
PUBLIC	??_C@_0BG@BKMFHGBK@A_CHANGECOLORRELATIVE@	; `string'
PUBLIC	??_C@_0BG@GHAKGMOK@A_CHANGECOLORABSOLUTE@	; `string'
PUBLIC	??_C@_0P@MOLLNFHC@A_MOVERELATIVE@		; `string'
PUBLIC	??_C@_0P@LDHEMPIC@A_MOVEABSOLUTE@		; `string'
PUBLIC	??_C@_08GGKFDDFI@A_THRUST@			; `string'
PUBLIC	??_C@_09DOLMLEJJ@A_ZTHRUST@			; `string'
PUBLIC	??_C@_0BD@JGAAAMJF@A_SETTARGETSTARGET@		; `string'
PUBLIC	??_C@_0BB@BLKBOCAM@A_SETOBJECTFLAGS@		; `string'
PUBLIC	??_C@_0BC@OENNLJLI@A_SETOBJECTFLAGS2@		; `string'
PUBLIC	??_C@_0O@EPHIMAIB@A_RANDOMSTATE@		; `string'
PUBLIC	??_C@_0BD@HAANMKAI@A_RANDOMSTATERANGE@		; `string'
PUBLIC	??_C@_0N@FALADGM@A_DUALACTION@			; `string'
PUBLIC	??_C@_0P@ICAIGFMP@A_REMOTEACTION@		; `string'
PUBLIC	??_C@_0BB@NHHDDBPG@A_TOGGLEFLAMEJET@		; `string'
PUBLIC	??_C@_04OKGDLNCL@NONE@				; `string'
EXTRN	_A_Explode:PROC
EXTRN	_A_Pain:PROC
EXTRN	_A_Fall:PROC
EXTRN	_A_MonitorPop:PROC
EXTRN	_A_Look:PROC
EXTRN	_A_Chase:PROC
EXTRN	_A_FaceTarget:PROC
EXTRN	_A_Scream:PROC
EXTRN	_A_BossDeath:PROC
EXTRN	_A_CustomPower:PROC
EXTRN	_A_GiveWeapon:PROC
EXTRN	_A_JumpShield:PROC
EXTRN	_A_RingShield:PROC
EXTRN	_A_RingBox:PROC
EXTRN	_A_Invincibility:PROC
EXTRN	_A_SuperSneakers:PROC
EXTRN	_A_BunnyHop:PROC
EXTRN	_A_BubbleSpawn:PROC
EXTRN	_A_BubbleRise:PROC
EXTRN	_A_BubbleCheck:PROC
EXTRN	_A_ExtraLife:PROC
EXTRN	_A_BombShield:PROC
EXTRN	_A_WaterShield:PROC
EXTRN	_A_ForceShield:PROC
EXTRN	_A_GravityBox:PROC
EXTRN	_A_ScoreRise:PROC
EXTRN	_A_ParticleSpawn:PROC
EXTRN	_A_AttractChase:PROC
EXTRN	_A_DropMine:PROC
EXTRN	_A_FishJump:PROC
EXTRN	_A_ThrownRing:PROC
EXTRN	_A_GrenadeRing:PROC
EXTRN	_A_SetSolidSteam:PROC
EXTRN	_A_UnsetSolidSteam:PROC
EXTRN	_A_SignPlayer:PROC
EXTRN	_A_JetChase:PROC
EXTRN	_A_JetbThink:PROC
EXTRN	_A_JetgThink:PROC
EXTRN	_A_JetgShoot:PROC
EXTRN	_A_ShootBullet:PROC
EXTRN	_A_MinusDigging:PROC
EXTRN	_A_MinusPopup:PROC
EXTRN	_A_MinusCheck:PROC
EXTRN	_A_ChickenCheck:PROC
EXTRN	_A_MouseThink:PROC
EXTRN	_A_DetonChase:PROC
EXTRN	_A_CapeChase:PROC
EXTRN	_A_RotateSpikeBall:PROC
EXTRN	_A_MaceRotate:PROC
EXTRN	_A_RockSpawn:PROC
EXTRN	_A_SnowBall:PROC
EXTRN	_A_CrawlaCommanderThink:PROC
EXTRN	_A_SmokeTrailer:PROC
EXTRN	_A_RingExplode:PROC
EXTRN	_A_OldRingExplode:PROC
EXTRN	_A_MixUp:PROC
EXTRN	_A_RecyclePowers:PROC
EXTRN	_A_BossScream:PROC
EXTRN	_A_Invinciblerize:PROC
EXTRN	_A_DeInvinciblerize:PROC
EXTRN	_A_GoopSplat:PROC
EXTRN	_A_Boss2PogoSFX:PROC
EXTRN	_A_EggmanBox:PROC
EXTRN	_A_TurretFire:PROC
EXTRN	_A_SuperTurretFire:PROC
EXTRN	_A_TurretStop:PROC
EXTRN	_A_JetJawRoam:PROC
EXTRN	_A_JetJawChomp:PROC
EXTRN	_A_PointyThink:PROC
EXTRN	_A_CheckBuddy:PROC
EXTRN	_A_HoodThink:PROC
EXTRN	_A_ArrowCheck:PROC
EXTRN	_A_SnailerThink:PROC
EXTRN	_A_SharpChase:PROC
EXTRN	_A_SharpSpin:PROC
EXTRN	_A_VultureVtol:PROC
EXTRN	_A_VultureCheck:PROC
EXTRN	_A_SkimChase:PROC
EXTRN	_A_SkullAttack:PROC
EXTRN	_A_LobShot:PROC
EXTRN	_A_CannonLook:PROC
EXTRN	_A_FireShot:PROC
EXTRN	_A_SuperFireShot:PROC
EXTRN	_A_BossFireShot:PROC
EXTRN	_A_SparkFollow:PROC
EXTRN	_A_BuzzFly:PROC
EXTRN	_A_GuardChase:PROC
EXTRN	_A_SetReactionTime:PROC
EXTRN	_A_Boss3TakeDamage:PROC
EXTRN	_A_LinedefExecute:PROC
EXTRN	_A_PlaySeeSound:PROC
EXTRN	_A_PlayAttackSound:PROC
EXTRN	_A_PlayActiveSound:PROC
EXTRN	_A_1upThinker:PROC
EXTRN	_A_BossJetFume:PROC
EXTRN	_A_SpawnObjectAbsolute:PROC
EXTRN	_A_SpawnObjectRelative:PROC
EXTRN	_A_ChangeAngleRelative:PROC
EXTRN	_A_ChangeAngleAbsolute:PROC
EXTRN	_A_PlaySound:PROC
EXTRN	_A_FindTarget:PROC
EXTRN	_A_FindTracer:PROC
EXTRN	_A_SetTics:PROC
EXTRN	_A_SetRandomTics:PROC
EXTRN	_A_ChangeColorRelative:PROC
EXTRN	_A_ChangeColorAbsolute:PROC
EXTRN	_A_MoveRelative:PROC
EXTRN	_A_MoveAbsolute:PROC
EXTRN	_A_Thrust:PROC
EXTRN	_A_ZThrust:PROC
EXTRN	_A_SetTargetsTarget:PROC
EXTRN	_A_SetObjectFlags:PROC
EXTRN	_A_SetObjectFlags2:PROC
EXTRN	_A_RandomState:PROC
EXTRN	_A_RandomStateRange:PROC
EXTRN	_A_DualAction:PROC
EXTRN	_A_RemoteAction:PROC
EXTRN	_A_ToggleFlameJet:PROC
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_deh_loaded DD	01H DUP (?)
_modcredits DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04OKGDLNCL@NONE@
CONST	SEGMENT
??_C@_04OKGDLNCL@NONE@ DB 'NONE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NHHDDBPG@A_TOGGLEFLAMEJET@
CONST	SEGMENT
??_C@_0BB@NHHDDBPG@A_TOGGLEFLAMEJET@ DB 'A_TOGGLEFLAMEJET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ICAIGFMP@A_REMOTEACTION@
CONST	SEGMENT
??_C@_0P@ICAIGFMP@A_REMOTEACTION@ DB 'A_REMOTEACTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FALADGM@A_DUALACTION@
CONST	SEGMENT
??_C@_0N@FALADGM@A_DUALACTION@ DB 'A_DUALACTION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HAANMKAI@A_RANDOMSTATERANGE@
CONST	SEGMENT
??_C@_0BD@HAANMKAI@A_RANDOMSTATERANGE@ DB 'A_RANDOMSTATERANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EPHIMAIB@A_RANDOMSTATE@
CONST	SEGMENT
??_C@_0O@EPHIMAIB@A_RANDOMSTATE@ DB 'A_RANDOMSTATE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OENNLJLI@A_SETOBJECTFLAGS2@
CONST	SEGMENT
??_C@_0BC@OENNLJLI@A_SETOBJECTFLAGS2@ DB 'A_SETOBJECTFLAGS2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BLKBOCAM@A_SETOBJECTFLAGS@
CONST	SEGMENT
??_C@_0BB@BLKBOCAM@A_SETOBJECTFLAGS@ DB 'A_SETOBJECTFLAGS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGAAAMJF@A_SETTARGETSTARGET@
CONST	SEGMENT
??_C@_0BD@JGAAAMJF@A_SETTARGETSTARGET@ DB 'A_SETTARGETSTARGET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DOLMLEJJ@A_ZTHRUST@
CONST	SEGMENT
??_C@_09DOLMLEJJ@A_ZTHRUST@ DB 'A_ZTHRUST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GGKFDDFI@A_THRUST@
CONST	SEGMENT
??_C@_08GGKFDDFI@A_THRUST@ DB 'A_THRUST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDHEMPIC@A_MOVEABSOLUTE@
CONST	SEGMENT
??_C@_0P@LDHEMPIC@A_MOVEABSOLUTE@ DB 'A_MOVEABSOLUTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOLLNFHC@A_MOVERELATIVE@
CONST	SEGMENT
??_C@_0P@MOLLNFHC@A_MOVERELATIVE@ DB 'A_MOVERELATIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GHAKGMOK@A_CHANGECOLORABSOLUTE@
CONST	SEGMENT
??_C@_0BG@GHAKGMOK@A_CHANGECOLORABSOLUTE@ DB 'A_CHANGECOLORABSOLUTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKMFHGBK@A_CHANGECOLORRELATIVE@
CONST	SEGMENT
??_C@_0BG@BKMFHGBK@A_CHANGECOLORRELATIVE@ DB 'A_CHANGECOLORRELATIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KOJLBKIK@A_SETRANDOMTICS@
CONST	SEGMENT
??_C@_0BA@KOJLBKIK@A_SETRANDOMTICS@ DB 'A_SETRANDOMTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCKGNCBI@A_SETTICS@
CONST	SEGMENT
??_C@_09FCKGNCBI@A_SETTICS@ DB 'A_SETTICS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LNJIENOF@A_FINDTRACER@
CONST	SEGMENT
??_C@_0N@LNJIENOF@A_FINDTRACER@ DB 'A_FINDTRACER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MGKCOAFD@A_FINDTARGET@
CONST	SEGMENT
??_C@_0N@MGKCOAFD@A_FINDTARGET@ DB 'A_FINDTARGET', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEBJJDDL@A_PLAYSOUND@
CONST	SEGMENT
??_C@_0M@FEBJJDDL@A_PLAYSOUND@ DB 'A_PLAYSOUND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGPACJFM@A_CHANGEANGLEABSOLUTE@
CONST	SEGMENT
??_C@_0BG@HGPACJFM@A_CHANGEANGLEABSOLUTE@ DB 'A_CHANGEANGLEABSOLUTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LDPDDKM@A_CHANGEANGLERELATIVE@
CONST	SEGMENT
??_C@_0BG@LDPDDKM@A_CHANGEANGLERELATIVE@ DB 'A_CHANGEANGLERELATIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGPOBPKM@A_SPAWNOBJECTRELATIVE@
CONST	SEGMENT
??_C@_0BG@DGPOBPKM@A_SPAWNOBJECTRELATIVE@ DB 'A_SPAWNOBJECTRELATIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ELDBAFFM@A_SPAWNOBJECTABSOLUTE@
CONST	SEGMENT
??_C@_0BG@ELDBAFFM@A_SPAWNOBJECTABSOLUTE@ DB 'A_SPAWNOBJECTABSOLUTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LFPDNPJG@A_PLAYACTIVESOUND@
CONST	SEGMENT
??_C@_0BC@LFPDNPJG@A_PLAYACTIVESOUND@ DB 'A_PLAYACTIVESOUND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ONICOINE@A_PLAYATTACKSOUND@
CONST	SEGMENT
??_C@_0BC@ONICOINE@A_PLAYATTACKSOUND@ DB 'A_PLAYATTACKSOUND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKHNAODF@A_PLAYSEESOUND@
CONST	SEGMENT
??_C@_0P@DKHNAODF@A_PLAYSEESOUND@ DB 'A_PLAYSEESOUND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNGKEENP@A_LINEDEFEXECUTE@
CONST	SEGMENT
??_C@_0BB@LNGKEENP@A_LINEDEFEXECUTE@ DB 'A_LINEDEFEXECUTE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBGLJLHG@A_BOSS3TAKEDAMAGE@
CONST	SEGMENT
??_C@_0BC@HBGLJLHG@A_BOSS3TAKEDAMAGE@ DB 'A_BOSS3TAKEDAMAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEAHIAIA@A_SETREACTIONTIME@
CONST	SEGMENT
??_C@_0BC@IEAHIAIA@A_SETREACTIONTIME@ DB 'A_SETREACTIONTIME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBIMLIGA@A_GUARDCHASE@
CONST	SEGMENT
??_C@_0N@DBIMLIGA@A_GUARDCHASE@ DB 'A_GUARDCHASE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KJIDBPJD@A_BUZZFLY@
CONST	SEGMENT
??_C@_09KJIDBPJD@A_BUZZFLY@ DB 'A_BUZZFLY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KNFAFHKP@A_SPARKFOLLOW@
CONST	SEGMENT
??_C@_0O@KNFAFHKP@A_SPARKFOLLOW@ DB 'A_SPARKFOLLOW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PCGNPOIH@A_BOSSFIRESHOT@
CONST	SEGMENT
??_C@_0P@PCGNPOIH@A_BOSSFIRESHOT@ DB 'A_BOSSFIRESHOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NEIOHAPA@A_SUPERFIRESHOT@
CONST	SEGMENT
??_C@_0BA@NEIOHAPA@A_SUPERFIRESHOT@ DB 'A_SUPERFIRESHOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPCGACJH@A_FIRESHOT@
CONST	SEGMENT
??_C@_0L@DPCGACJH@A_FIRESHOT@ DB 'A_FIRESHOT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HLMEOAII@A_CANNONLOOK@
CONST	SEGMENT
??_C@_0N@HLMEOAII@A_CANNONLOOK@ DB 'A_CANNONLOOK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MKAFJLIB@A_LOBSHOT@
CONST	SEGMENT
??_C@_09MKAFJLIB@A_LOBSHOT@ DB 'A_LOBSHOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IBCEMJDJ@A_SKULLATTACK@
CONST	SEGMENT
??_C@_0O@IBCEMJDJ@A_SKULLATTACK@ DB 'A_SKULLATTACK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MBCBHIOH@A_1UPTHINKER@
CONST	SEGMENT
??_C@_0N@MBCBHIOH@A_1UPTHINKER@ DB 'A_1UPTHINKER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIFDPJLI@A_SKIMCHASE@
CONST	SEGMENT
??_C@_0M@PIFDPJLI@A_SKIMCHASE@ DB 'A_SKIMCHASE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FOIIIHAC@A_VULTURECHECK@
CONST	SEGMENT
??_C@_0P@FOIIIHAC@A_VULTURECHECK@ DB 'A_VULTURECHECK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IPLAPNKM@A_VULTUREVTOL@
CONST	SEGMENT
??_C@_0O@IPLAPNKM@A_VULTUREVTOL@ DB 'A_VULTUREVTOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LDPCLNO@A_SHARPSPIN@
CONST	SEGMENT
??_C@_0M@LDPCLNO@A_SHARPSPIN@ DB 'A_SHARPSPIN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOGCLNKM@A_SHARPCHASE@
CONST	SEGMENT
??_C@_0N@GOGCLNKM@A_SHARPCHASE@ DB 'A_SHARPCHASE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KPFAEKCM@A_SNAILERTHINK@
CONST	SEGMENT
??_C@_0P@KPFAEKCM@A_SNAILERTHINK@ DB 'A_SNAILERTHINK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BCOHKMOO@A_ARROWCHECK@
CONST	SEGMENT
??_C@_0N@BCOHKMOO@A_ARROWCHECK@ DB 'A_ARROWCHECK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIBMJJJO@A_HOODTHINK@
CONST	SEGMENT
??_C@_0M@HIBMJJJO@A_HOODTHINK@ DB 'A_HOODTHINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDFMEJOG@A_CHECKBUDDY@
CONST	SEGMENT
??_C@_0N@NDFMEJOG@A_CHECKBUDDY@ DB 'A_CHECKBUDDY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGBEBIKD@A_POINTYTHINK@
CONST	SEGMENT
??_C@_0O@MGBEBIKD@A_POINTYTHINK@ DB 'A_POINTYTHINK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJIEECMA@A_JETJAWCHOMP@
CONST	SEGMENT
??_C@_0O@LJIEECMA@A_JETJAWCHOMP@ DB 'A_JETJAWCHOMP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EDDEDDAD@A_JETJAWROAM@
CONST	SEGMENT
??_C@_0N@EDDEDDAD@A_JETJAWROAM@ DB 'A_JETJAWROAM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HJAPOALH@A_TURRETSTOP@
CONST	SEGMENT
??_C@_0N@HJAPOALH@A_TURRETSTOP@ DB 'A_TURRETSTOP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEIAKHOI@A_SUPERTURRETFIRE@
CONST	SEGMENT
??_C@_0BC@MEIAKHOI@A_SUPERTURRETFIRE@ DB 'A_SUPERTURRETFIRE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FADHKBDA@A_TURRETFIRE@
CONST	SEGMENT
??_C@_0N@FADHKBDA@A_TURRETFIRE@ DB 'A_TURRETFIRE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BLDACEHM@A_EGGMANBOX@
CONST	SEGMENT
??_C@_0M@BLDACEHM@A_EGGMANBOX@ DB 'A_EGGMANBOX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLEBMPPF@A_BOSSJETFUME@
CONST	SEGMENT
??_C@_0O@LLEBMPPF@A_BOSSJETFUME@ DB 'A_BOSSJETFUME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PGHLMEMF@A_BOSS2POGOSFX@
CONST	SEGMENT
??_C@_0P@PGHLMEMF@A_BOSS2POGOSFX@ DB 'A_BOSS2POGOSFX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGMLCPKE@A_GOOPSPLAT@
CONST	SEGMENT
??_C@_0M@KGMLCPKE@A_GOOPSPLAT@ DB 'A_GOOPSPLAT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJMFPBOH@A_DEINVINCIBLERIZE@
CONST	SEGMENT
??_C@_0BD@OJMFPBOH@A_DEINVINCIBLERIZE@ DB 'A_DEINVINCIBLERIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OEKDEFGL@A_INVINCIBLERIZE@
CONST	SEGMENT
??_C@_0BB@OEKDEFGL@A_INVINCIBLERIZE@ DB 'A_INVINCIBLERIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOPLCIEI@A_BOSSSCREAM@
CONST	SEGMENT
??_C@_0N@OOPLCIEI@A_BOSSSCREAM@ DB 'A_BOSSSCREAM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ECFAMBON@A_RECYCLEPOWERS@
CONST	SEGMENT
??_C@_0BA@ECFAMBON@A_RECYCLEPOWERS@ DB 'A_RECYCLEPOWERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JCCHMOHD@A_MIXUP@
CONST	SEGMENT
??_C@_07JCCHMOHD@A_MIXUP@ DB 'A_MIXUP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMKNJAFP@A_OLDRINGEXPLODE@
CONST	SEGMENT
??_C@_0BB@LMKNJAFP@A_OLDRINGEXPLODE@ DB 'A_OLDRINGEXPLODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECONMIAO@A_RINGEXPLODE@
CONST	SEGMENT
??_C@_0O@ECONMIAO@A_RINGEXPLODE@ DB 'A_RINGEXPLODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMAPOIFK@A_SMOKETRAILER@
CONST	SEGMENT
??_C@_0P@FMAPOIFK@A_SMOKETRAILER@ DB 'A_SMOKETRAILER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LCFLDBKE@A_CRAWLACOMMANDERTHINK@
CONST	SEGMENT
??_C@_0BH@LCFLDBKE@A_CRAWLACOMMANDERTHINK@ DB 'A_CRAWLACOMMANDERTHINK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLHGIFJG@A_SNOWBALL@
CONST	SEGMENT
??_C@_0L@DLHGIFJG@A_SNOWBALL@ DB 'A_SNOWBALL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PNGEFLH@A_ROCKSPAWN@
CONST	SEGMENT
??_C@_0M@PNGEFLH@A_ROCKSPAWN@ DB 'A_ROCKSPAWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGHNNEEL@A_MACEROTATE@
CONST	SEGMENT
??_C@_0N@HGHNNEEL@A_MACEROTATE@ DB 'A_MACEROTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HNBHOLIF@A_ROTATESPIKEBALL@
CONST	SEGMENT
??_C@_0BC@HNBHOLIF@A_ROTATESPIKEBALL@ DB 'A_ROTATESPIKEBALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BKMIJGKJ@A_CAPECHASE@
CONST	SEGMENT
??_C@_0M@BKMIJGKJ@A_CAPECHASE@ DB 'A_CAPECHASE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKFJCDAD@A_DETONCHASE@
CONST	SEGMENT
??_C@_0N@CKFJCDAD@A_DETONCHASE@ DB 'A_DETONCHASE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJEEOOPD@A_MOUSETHINK@
CONST	SEGMENT
??_C@_0N@CJEEOOPD@A_MOUSETHINK@ DB 'A_MOUSETHINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MBEJLNCB@A_CHICKENCHECK@
CONST	SEGMENT
??_C@_0P@MBEJLNCB@A_CHICKENCHECK@ DB 'A_CHICKENCHECK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JEHDPMKD@A_MINUSCHECK@
CONST	SEGMENT
??_C@_0N@JEHDPMKD@A_MINUSCHECK@ DB 'A_MINUSCHECK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HFELODHD@A_MINUSPOPUP@
CONST	SEGMENT
??_C@_0N@HFELODHD@A_MINUSPOPUP@ DB 'A_MINUSPOPUP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EKOOHBIL@A_MINUSDIGGING@
CONST	SEGMENT
??_C@_0P@EKOOHBIL@A_MINUSDIGGING@ DB 'A_MINUSDIGGING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CPAABHMI@A_SHOOTBULLET@
CONST	SEGMENT
??_C@_0O@CPAABHMI@A_SHOOTBULLET@ DB 'A_SHOOTBULLET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NAIPPBA@A_JETGSHOOT@
CONST	SEGMENT
??_C@_0M@NAIPPBA@A_JETGSHOOT@ DB 'A_JETGSHOOT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJPOPENN@A_JETGTHINK@
CONST	SEGMENT
??_C@_0M@PJPOPENN@A_JETGTHINK@ DB 'A_JETGTHINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLMGNLHK@A_JETBTHINK@
CONST	SEGMENT
??_C@_0M@KLMGNLHK@A_JETBTHINK@ DB 'A_JETBTHINK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHOJKCPG@A_JETCHASE@
CONST	SEGMENT
??_C@_0L@BHOJKCPG@A_JETCHASE@ DB 'A_JETCHASE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNGNHPPM@A_SIGNPLAYER@
CONST	SEGMENT
??_C@_0N@KNGNHPPM@A_SIGNPLAYER@ DB 'A_SIGNPLAYER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PPICBAMN@A_UNSETSOLIDSTEAM@
CONST	SEGMENT
??_C@_0BC@PPICBAMN@A_UNSETSOLIDSTEAM@ DB 'A_UNSETSOLIDSTEAM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GCOHKLLG@A_SETSOLIDSTEAM@
CONST	SEGMENT
??_C@_0BA@GCOHKLLG@A_SETSOLIDSTEAM@ DB 'A_SETSOLIDSTEAM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LNPHKGMC@A_GRENADERING@
CONST	SEGMENT
??_C@_0O@LNPHKGMC@A_GRENADERING@ DB 'A_GRENADERING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFLPCKFM@A_THROWNRING@
CONST	SEGMENT
??_C@_0N@IFLPCKFM@A_THROWNRING@ DB 'A_THROWNRING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INKEHBCG@A_FISHJUMP@
CONST	SEGMENT
??_C@_0L@INKEHBCG@A_FISHJUMP@ DB 'A_FISHJUMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FAGEGOOL@A_DROPMINE@
CONST	SEGMENT
??_C@_0L@FAGEGOOL@A_DROPMINE@ DB 'A_DROPMINE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JICBJCDN@A_ATTRACTCHASE@
CONST	SEGMENT
??_C@_0P@JICBJCDN@A_ATTRACTCHASE@ DB 'A_ATTRACTCHASE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNGNFDEI@A_PARTICLESPAWN@
CONST	SEGMENT
??_C@_0BA@GNGNFDEI@A_PARTICLESPAWN@ DB 'A_PARTICLESPAWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CNMPPKNB@A_SCORERISE@
CONST	SEGMENT
??_C@_0M@CNMPPKNB@A_SCORERISE@ DB 'A_SCORERISE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INHLNJNE@A_GRAVITYBOX@
CONST	SEGMENT
??_C@_0N@INHLNJNE@A_GRAVITYBOX@ DB 'A_GRAVITYBOX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIOPDPEF@A_FORCESHIELD@
CONST	SEGMENT
??_C@_0O@JIOPDPEF@A_FORCESHIELD@ DB 'A_FORCESHIELD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FFFOIECP@A_WATERSHIELD@
CONST	SEGMENT
??_C@_0O@FFFOIECP@A_WATERSHIELD@ DB 'A_WATERSHIELD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKNEDIGG@A_JUMPSHIELD@
CONST	SEGMENT
??_C@_0N@CKNEDIGG@A_JUMPSHIELD@ DB 'A_JUMPSHIELD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOAFPOFE@A_BOMBSHIELD@
CONST	SEGMENT
??_C@_0N@JOAFPOFE@A_BOMBSHIELD@ DB 'A_BOMBSHIELD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGJHPAMB@A_EXTRALIFE@
CONST	SEGMENT
??_C@_0M@FGJHPAMB@A_EXTRALIFE@ DB 'A_EXTRALIFE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHEHDNIA@A_BUBBLECHECK@
CONST	SEGMENT
??_C@_0O@CHEHDNIA@A_BUBBLECHECK@ DB 'A_BUBBLECHECK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PLPBDHK@A_BUBBLERISE@
CONST	SEGMENT
??_C@_0N@PLPBDHK@A_BUBBLERISE@ DB 'A_BUBBLERISE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JNDLILOG@A_BUBBLESPAWN@
CONST	SEGMENT
??_C@_0O@JNDLILOG@A_BUBBLESPAWN@ DB 'A_BUBBLESPAWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNLLKMCD@A_BUNNYHOP@
CONST	SEGMENT
??_C@_0L@KNLLKMCD@A_BUNNYHOP@ DB 'A_BUNNYHOP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PILBDMPL@A_SUPERSNEAKERS@
CONST	SEGMENT
??_C@_0BA@PILBDMPL@A_SUPERSNEAKERS@ DB 'A_SUPERSNEAKERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EOCKJFCP@A_INVINCIBILITY@
CONST	SEGMENT
??_C@_0BA@EOCKJFCP@A_INVINCIBILITY@ DB 'A_INVINCIBILITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OBEONDPD@A_RINGBOX@
CONST	SEGMENT
??_C@_09OBEONDPD@A_RINGBOX@ DB 'A_RINGBOX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMIAHIHJ@A_RINGSHIELD@
CONST	SEGMENT
??_C@_0N@EMIAHIHJ@A_RINGSHIELD@ DB 'A_RINGSHIELD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBNDHKJG@A_GIVEWEAPON@
CONST	SEGMENT
??_C@_0N@CBNDHKJG@A_GIVEWEAPON@ DB 'A_GIVEWEAPON', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EEMLAPNN@A_CUSTOMPOWER@
CONST	SEGMENT
??_C@_0O@EEMLAPNN@A_CUSTOMPOWER@ DB 'A_CUSTOMPOWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCDNBEND@A_BOSSDEATH@
CONST	SEGMENT
??_C@_0M@OCDNBEND@A_BOSSDEATH@ DB 'A_BOSSDEATH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNHOHEIM@A_SCREAM@
CONST	SEGMENT
??_C@_08BNHOHEIM@A_SCREAM@ DB 'A_SCREAM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIJAEHGO@A_FACETARGET@
CONST	SEGMENT
??_C@_0N@OIJAEHGO@A_FACETARGET@ DB 'A_FACETARGET', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ILGEAEAA@A_CHASE@
CONST	SEGMENT
??_C@_07ILGEAEAA@A_CHASE@ DB 'A_CHASE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ELAIEFHO@A_LOOK@
CONST	SEGMENT
??_C@_06ELAIEFHO@A_LOOK@ DB 'A_LOOK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONKHEMAF@A_MONITORPOP@
CONST	SEGMENT
??_C@_0N@ONKHEMAF@A_MONITORPOP@ DB 'A_MONITORPOP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMGAACHC@A_FALL@
CONST	SEGMENT
??_C@_06KMGAACHC@A_FALL@ DB 'A_FALL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHDNMADJ@A_PAIN@
CONST	SEGMENT
??_C@_06HHDNMADJ@A_PAIN@ DB 'A_PAIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BJMGHFGB@A_EXPLODE@
CONST	SEGMENT
??_C@_09BJMGHFGB@A_EXPLODE@ DB 'A_EXPLODE', 00H		; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_DEH_WriteUndoline
PUBLIC	_DEH_UnloadDehackedWad
PUBLIC	_DEH_LoadDehackedLump
PUBLIC	_DEH_LoadDehackedLumpPwad
PUBLIC	_myfgets
PUBLIC	??_C@_03MHLONNLM@?5?$DN?5@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BN@IANMBFDG@Out?5of?5memory?5for?5unsoc?5line@ ; `string'
PUBLIC	??_C@_01IPJKGB@?$CD@				; `string'
PUBLIC	??_C@_0BN@MFJFLK@Out?5of?5memory?5for?5unsoc?5data@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0P@MABBGDAN@No?5value?5found@		; `string'
PUBLIC	??_C@_0L@GBJEFOMO@PLAYERTEXT@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0L@INJCAEDB@PLAYERNAME@			; `string'
PUBLIC	??_C@_0N@PPNPBINO@MENUPOSITION@			; `string'
PUBLIC	??_C@_07KGIDOHJL@PICNAME@			; `string'
PUBLIC	??_C@_06DNKMJCIK@STATUS@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_08PDDIGPEM@SKINNAME@			; `string'
PUBLIC	??_C@_0CB@DKMGFKIF@readPlayer?5?$CFd?3?5unknown?5word?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0M@LILCLDJ@MAPTHINGNUM@			; `string'
PUBLIC	??_C@_0L@MMJEIBOH@SPAWNSTATE@			; `string'
PUBLIC	??_C@_0M@CDBIIJGK@SPAWNHEALTH@			; `string'
PUBLIC	??_C@_08KHPNBBJD@SEESTATE@			; `string'
PUBLIC	??_C@_08GHBMGACP@SEESOUND@			; `string'
PUBLIC	??_C@_0N@BDGIPNHE@REACTIONTIME@			; `string'
PUBLIC	??_C@_0M@DNPINJMI@ATTACKSOUND@			; `string'
PUBLIC	??_C@_09MMPEMAEB@PAINSTATE@			; `string'
PUBLIC	??_C@_0L@KEPKKLOB@PAINCHANCE@			; `string'
PUBLIC	??_C@_09MBFLBPN@PAINSOUND@			; `string'
PUBLIC	??_C@_0L@DMEFKBHN@MELEESTATE@			; `string'
PUBLIC	??_C@_0N@IMDFGKKB@MISSILESTATE@			; `string'
PUBLIC	??_C@_0L@GHIBCINK@DEATHSTATE@			; `string'
PUBLIC	??_C@_0L@KHGAFJGG@DEATHSOUND@			; `string'
PUBLIC	??_C@_0M@ENKEHDKL@XDEATHSTATE@			; `string'
PUBLIC	??_C@_05LCLKIGOL@SPEED@				; `string'
PUBLIC	??_C@_06KCFDAKCE@RADIUS@			; `string'
PUBLIC	??_C@_06LJJMJONE@HEIGHT@			; `string'
PUBLIC	??_C@_0L@EDHALAFO@DISPOFFSET@			; `string'
PUBLIC	??_C@_04EFHKDFDM@MASS@				; `string'
PUBLIC	??_C@_06GNMDCLIH@DAMAGE@			; `string'
PUBLIC	??_C@_0M@GFIJOOIK@ACTIVESOUND@			; `string'
PUBLIC	??_C@_05MNNEKIOP@FLAGS@				; `string'
PUBLIC	??_C@_0L@PIODEMOJ@RAISESTATE@			; `string'
PUBLIC	??_C@_0BM@FEGHJPGL@Thing?5?$CFd?3?5unknown?5word?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_09MADBCAME@LEVELNAME@			; `string'
PUBLIC	??_C@_08OOGGCINI@SUBTITLE@			; `string'
PUBLIC	??_C@_03FBBILEHC@ACT@				; `string'
PUBLIC	??_C@_0CH@CHCEALKM@Level?5header?5?$CFd?3?5invalid?5act?5nu@ ; `string'
PUBLIC	??_C@_0M@GOKBOJDC@TYPEOFLEVEL@			; `string'
PUBLIC	??_C@_09HFCIMBHH@NEXTLEVEL@			; `string'
PUBLIC	??_C@_09MHGCKDNO@MUSICSLOT@			; `string'
PUBLIC	??_C@_0P@HOGKHGAO@FORCECHARACTER@		; `string'
PUBLIC	??_C@_07HKOGDAHK@WEATHER@			; `string'
PUBLIC	??_C@_06HEFJHGKD@SKYNUM@			; `string'
PUBLIC	??_C@_0M@PDGEIADF@INTERSCREEN@			; `string'
PUBLIC	??_C@_0L@OPDCCGFG@SCRIPTNAME@			; `string'
PUBLIC	??_C@_0N@BKNFDAOL@SCRIPTISLUMP@			; `string'
PUBLIC	??_C@_0P@DFENKLKN@PRECUTSCENENUM@		; `string'
PUBLIC	??_C@_0M@HBBFKHJP@CUTSCENENUM@			; `string'
PUBLIC	??_C@_09JPDDLCMH@COUNTDOWN@			; `string'
PUBLIC	??_C@_06MOHHBCJH@NOZONE@			; `string'
PUBLIC	??_C@_06JMIOFMHI@HIDDEN@			; `string'
PUBLIC	??_C@_09GKCLDIIP@NOSSMUSIC@			; `string'
PUBLIC	??_C@_0L@LHJOPLBJ@SPEEDMUSIC@			; `string'
PUBLIC	??_C@_08KPPNBABB@NORELOAD@			; `string'
PUBLIC	??_C@_0L@IKBJCDCO@TIMEATTACK@			; `string'
PUBLIC	??_C@_0M@JIALMPNC@LEVELSELECT@			; `string'
PUBLIC	??_C@_0P@PGCBNPFL@NOPERFECTBONUS@		; `string'
PUBLIC	??_C@_06BEHDNBAE@RUNSOC@			; `string'
PUBLIC	??_C@_07GHNKBFGK@PALETTE@			; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_0CD@DEOJKBPN@Level?5header?5?$CFd?3?5unknown?5word?5?8@ ; `string'
PUBLIC	??_C@_09FOLEOKCO@SCENETEXT@			; `string'
PUBLIC	??_C@_0N@EBKKDBGP@NUMBEROFPICS@			; `string'
PUBLIC	??_C@_08NGJELEKO@PIC1NAME@			; `string'
PUBLIC	??_C@_08FAAAMGAA@PIC2NAME@			; `string'
PUBLIC	??_C@_08JLFMBFKF@PIC3NAME@			; `string'
PUBLIC	??_C@_08IGFJCFBN@PIC4NAME@			; `string'
PUBLIC	??_C@_08ENAFPGLI@PIC5NAME@			; `string'
PUBLIC	??_C@_08MLJBIEBG@PIC6NAME@			; `string'
PUBLIC	??_C@_08MNFHLD@PIC7NAME@			; `string'
PUBLIC	??_C@_08PBJLOFGG@PIC8NAME@			; `string'
PUBLIC	??_C@_09EOHNPLNJ@PIC1HIRES@			; `string'
PUBLIC	??_C@_09HPJFOBEE@PIC2HIRES@			; `string'
PUBLIC	??_C@_09NJOCOKPA@PIC3HIRES@			; `string'
PUBLIC	??_C@_09BMEFNEHO@PIC4HIRES@			; `string'
PUBLIC	??_C@_09LKDCNPMK@PIC5HIRES@			; `string'
PUBLIC	??_C@_09ILNKMFFH@PIC6HIRES@			; `string'
PUBLIC	??_C@_09CNKNMOOD@PIC7HIRES@			; `string'
PUBLIC	??_C@_09NLOFLOAK@PIC8HIRES@			; `string'
PUBLIC	??_C@_0N@EMBFMNLB@PIC1DURATION@			; `string'
PUBLIC	??_C@_0N@KHCCHGLC@PIC2DURATION@			; `string'
PUBLIC	??_C@_0N@EIOABNIM@PIC3DURATION@			; `string'
PUBLIC	??_C@_0N@KKDMAGPF@PIC4DURATION@			; `string'
PUBLIC	??_C@_0N@EFPOGNML@PIC5DURATION@			; `string'
PUBLIC	??_C@_0N@KOMJNGMI@PIC6DURATION@			; `string'
PUBLIC	??_C@_0N@EBALLNPG@PIC7DURATION@			; `string'
PUBLIC	??_C@_0N@LAAAOGHL@PIC8DURATION@			; `string'
PUBLIC	??_C@_0L@FLBOPLEC@PIC1XCOORD@			; `string'
PUBLIC	??_C@_0L@NFJBPMKB@PIC2XCOORD@			; `string'
PUBLIC	??_C@_0L@BJDLPMDP@PIC3XCOORD@			; `string'
PUBLIC	??_C@_0L@BDPOPFCG@PIC4XCOORD@			; `string'
PUBLIC	??_C@_0L@NPFEPFLI@PIC5XCOORD@			; `string'
PUBLIC	??_C@_0L@FBNLPCFL@PIC6XCOORD@			; `string'
PUBLIC	??_C@_0L@JNHBPCMF@PIC7XCOORD@			; `string'
PUBLIC	??_C@_0L@EEFBOAGJ@PIC8XCOORD@			; `string'
PUBLIC	??_C@_0L@PNGJPAPG@PIC1YCOORD@			; `string'
PUBLIC	??_C@_0L@HDOGPHBF@PIC2YCOORD@			; `string'
PUBLIC	??_C@_0L@LPEMPHIL@PIC3YCOORD@			; `string'
PUBLIC	??_C@_0L@LFIJPOJC@PIC4YCOORD@			; `string'
PUBLIC	??_C@_0L@HJCDPOAM@PIC5YCOORD@			; `string'
PUBLIC	??_C@_0L@PHKMPJOP@PIC6YCOORD@			; `string'
PUBLIC	??_C@_0L@DLAGPJHB@PIC7YCOORD@			; `string'
PUBLIC	??_C@_0L@OCCGOLNN@PIC8YCOORD@			; `string'
PUBLIC	??_C@_09FDALMJGH@MUSICLOOP@			; `string'
PUBLIC	??_C@_08PJCOJFFB@TEXTXPOS@			; `string'
PUBLIC	??_C@_08MEEOLMOB@TEXTYPOS@			; `string'
PUBLIC	??_C@_0CE@BHIFLOEA@CutSceneScene?5?$CFd?3?5unknown?5word?5@ ; `string'
PUBLIC	??_C@_0BG@KFBFNACM@No?5value?5for?5token?5?$CFs@ ; `string'
PUBLIC	??_C@_09IBLFEBPM@NUMSCENES@			; `string'
PUBLIC	??_C@_05IALELFBJ@SCENE@				; `string'
PUBLIC	??_C@_0BN@HKLMADIL@Scene?5number?5?$CFd?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0DG@GFCLHAEP@Cutscene?5?$CFd?3?5unknown?5word?5?8?$CFs?8?0@ ; `string'
PUBLIC	??_C@_0O@OPFEEMIH@NEEDEDEMBLEMS@		; `string'
PUBLIC	??_C@_0L@NDOPDIK@NEEDEDTIME@			; `string'
PUBLIC	??_C@_0M@FJAIOMKE@NEEDEDGRADE@			; `string'
PUBLIC	??_C@_04IPKHEEB@NAME@				; `string'
PUBLIC	??_C@_09GKLCILOC@OBJECTIVE@			; `string'
PUBLIC	??_C@_04KDPJLEDB@TYPE@				; `string'
PUBLIC	??_C@_03MJAIKILM@VAR@				; `string'
PUBLIC	??_C@_0CB@PNJBHKCI@Unlockable?5?$CFd?3?5unknown?5word?5?8?$CFs@ ; `string'
PUBLIC	??_C@_01MMEEDKFM@X@				; `string'
PUBLIC	??_C@_01NFFPALBN@Y@				; `string'
PUBLIC	??_C@_0N@FDNLMHGB@SPRITENUMBER@			; `string'
PUBLIC	??_C@_0BA@DONIHLJC@SPRITESUBNUMBER@		; `string'
PUBLIC	??_C@_08MJLDLDGF@DURATION@			; `string'
PUBLIC	??_C@_04MOKMKBJN@NEXT@				; `string'
PUBLIC	??_C@_04EEDPALN@VAR1@				; `string'
PUBLIC	??_C@_04CPGOKDHO@VAR2@				; `string'
PUBLIC	??_C@_06DHJAPAEE@ACTION@			; `string'
PUBLIC	??_C@_0BC@GEOOGJAL@Unknown?5action?5?$CFs@	; `string'
PUBLIC	??_C@_0BM@LEECKIDM@Frame?5?$CFd?3?5unknown?5word?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_08LKHGAEML@SINGULAR@			; `string'
PUBLIC	??_C@_08PHDJDNOC@PRIORITY@			; `string'
PUBLIC	??_C@_0BN@OIKDCDHK@Sound?5?$CFd?5?3?5unknown?5word?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_04PBCOOEDG@?4dat@				; `string'
PUBLIC	??_C@_0N@JCMAOFIJ@gamedata?4dat@		; `string'
PUBLIC	??_C@_0N@GNOMNNJL@SSTAGE_START@			; `string'
PUBLIC	??_C@_0O@DJABEAKP@NSSTAGE_START@		; `string'
PUBLIC	??_C@_07OJNCCNOK@EXECCFG@			; `string'
PUBLIC	??_C@_08NNCMPFKC@exec?5?$CFs?6@			; `string'
PUBLIC	??_C@_0O@FFIDGAFG@SPSTAGE_START@		; `string'
PUBLIC	??_C@_0M@JHKIJPM@SPSTAGE_END@			; `string'
PUBLIC	??_C@_0BA@JLOADGPD@RACESTAGE_START@		; `string'
PUBLIC	??_C@_0L@NLLMKMJH@INVULNTICS@			; `string'
PUBLIC	??_C@_0M@BBMMDGAO@SNEAKERTICS@			; `string'
PUBLIC	??_C@_0N@FLPJIF@FLASHINGTICS@			; `string'
PUBLIC	??_C@_0N@HPDPGMBI@TAILSFLYTICS@			; `string'
PUBLIC	??_C@_0P@DGMLJMDB@UNDERWATERTICS@		; `string'
PUBLIC	??_C@_0O@ELLLBCPC@SPACETIMETICS@		; `string'
PUBLIC	??_C@_0O@GIPPCDEL@EXTRALIFETICS@		; `string'
PUBLIC	??_C@_0O@KGLHIKIO@GRAVBOOTSTICS@		; `string'
PUBLIC	??_C@_0N@LNHOBDGP@PARALOOPTICS@			; `string'
PUBLIC	??_C@_0L@HCFAMJBI@HELPERTICS@			; `string'
PUBLIC	??_C@_0N@PDCOMLBK@GAMEOVERTICS@			; `string'
PUBLIC	??_C@_0M@GLFMEFCC@INTROTOPLAY@			; `string'
PUBLIC	??_C@_09DIKNKCEP@LOOPTITLE@			; `string'
PUBLIC	??_C@_0BB@IKJKJFLM@TITLESCROLLSPEED@		; `string'
PUBLIC	??_C@_0BA@FOIHDLKN@CREDITSCUTSCENE@		; `string'
PUBLIC	??_C@_0BD@KJADGDCM@DISABLESPEEDADJUST@		; `string'
PUBLIC	??_C@_08DAHHPBHD@GAMEDATA@			; `string'
PUBLIC	??_C@_0CC@BCDGLAPN@Maincfg?3?5bad?5data?5file?5name?5?8?$CFs@ ; `string'
PUBLIC	??_C@_06NPIJBPLG@?$CFu?4ssg@			; `string'
PUBLIC	??_C@_0L@LOIKKLLC@NUMEMBLEMS@			; `string'
PUBLIC	??_C@_0CM@FNJPMFEA@Sorry?0?5a?5maximum?5of?5?$CFd?5emblems?5@ ; `string'
PUBLIC	??_C@_09GDBIFKFH@RESETDATA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0O@IMHIENOO@CUSTOMVERSION@		; `string'
PUBLIC	??_C@_0BL@DOOIFKJP@Maincfg?3?5unknown?5word?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_01POHCFINO@Z@				; `string'
PUBLIC	??_C@_09IHJAHKKM@PLAYERNUM@			; `string'
PUBLIC	??_C@_06OPDDNACH@MAPNUM@			; `string'
PUBLIC	??_C@_0BK@IPCLALDD@Emblem?3?5unknown?5word?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_05JCIBGJIK@THING@				; `string'
PUBLIC	??_C@_05CLEJPIKP@MODBY@				; `string'
PUBLIC	??_C@_09DMCLKDIA@CHARACTER@			; `string'
PUBLIC	??_C@_05MFNJIKNP@LIGHT@				; `string'
PUBLIC	??_C@_06DOFEGNGM@SPRITE@			; `string'
PUBLIC	??_C@_05GCEPFMCO@LEVEL@				; `string'
PUBLIC	??_C@_08PKDMAPNA@CUTSCENE@			; `string'
PUBLIC	??_C@_0L@GFIFJDNE@UNLOCKABLE@			; `string'
PUBLIC	??_C@_05DALLBAN@FRAME@				; `string'
PUBLIC	??_C@_05MEGDOMG@SOUND@				; `string'
PUBLIC	??_C@_07KHILKLAK@HUDITEM@			; `string'
PUBLIC	??_C@_06HBBPBCC@EMBLEM@				; `string'
PUBLIC	??_C@_07EHCDOLII@MAINCFG@			; `string'
PUBLIC	??_C@_04LJAEHHAP@SRB2@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_01LKDEMHDF@s@				; `string'
PUBLIC	??_C@_0BO@IPBFEFIB@?$CD?5uload?5for?5wad?3?5?$CFu?0?5lump?3?5?$CFu@ ; `string'
PUBLIC	??_C@_02BKFDOEMK@wt@				; `string'
PUBLIC	??_C@_08OKNICAFF@undo?4soc@			; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isalnum:PROC
EXTRN	_strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncat:PROC
EXTRN	_strncpy:PROC
EXTRN	_strtok:PROC
EXTRN	_stricmp:PROC
EXTRN	_strlwr:PROC
EXTRN	_strupr:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_atoi:PROC
EXTRN	_strlcat:PROC
EXTRN	_strlcpy:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_I_GetKey:PROC
EXTRN	_P_ResetData:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_G_SaveGameData:PROC
EXTRN	_G_LoadGameData:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_StrDup:PROC
EXTRN	_W_LumpLengthPwad:PROC
EXTRN	_W_ReadLumpPwad:PROC
EXTRN	_M_MapNumber:PROC
EXTRN	_I_OsPolling:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_devparm:DWORD
EXTRN	_S_sfx:BYTE
EXTRN	_states:BYTE
EXTRN	_sprnames:BYTE
EXTRN	_mobjinfo:BYTE
EXTRN	_savemoddata:DWORD
EXTRN	_disableSpeedAdjust:DWORD
EXTRN	_spstage_start:WORD
EXTRN	_spstage_end:WORD
EXTRN	_sstage_start:WORD
EXTRN	_sstage_end:WORD
EXTRN	_nsstage_start:WORD
EXTRN	_nsstage_end:WORD
EXTRN	_racestage_start:WORD
EXTRN	_looptitle:DWORD
EXTRN	_useNightsSS:DWORD
EXTRN	_cutscenes:BYTE
EXTRN	_mapheaderinfo:BYTE
EXTRN	_numemblems:DWORD
EXTRN	_emblemlocations:BYTE
EXTRN	_invulntics:DWORD
EXTRN	_sneakertics:DWORD
EXTRN	_flashingtics:DWORD
EXTRN	_tailsflytics:DWORD
EXTRN	_underwatertics:DWORD
EXTRN	_spacetimetics:DWORD
EXTRN	_extralifetics:DWORD
EXTRN	_gravbootstics:DWORD
EXTRN	_paralooptics:DWORD
EXTRN	_helpertics:DWORD
EXTRN	_introtoplay:BYTE
EXTRN	_creditscutscene:BYTE
EXTRN	_savegamename:BYTE
EXTRN	_text:BYTE
EXTRN	_gamedatafilename:ZWORD
EXTRN	_timeattackfolder:ZWORD
EXTRN	_customversionstring:BYTE
EXTRN	_gameovertics:DWORD
EXTRN	_PlayerMenu:BYTE
EXTRN	_customsecretinfo:BYTE
EXTRN	_description:BYTE
EXTRN	_credits:BYTE
EXTRN	_titlescrollspeed:DWORD
EXTRN	_hudinfo:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_unsocwad DW	01H DUP (?)
	ALIGN	4

_unsocdata DD	030H DUP (?)
_disableundo DD	01H DUP (?)
_deh_num_warning DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08OKNICAFF@undo?4soc@
CONST	SEGMENT
??_C@_08OKNICAFF@undo?4soc@ DB 'undo.soc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt@
CONST	SEGMENT
??_C@_02BKFDOEMK@wt@ DB 'wt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IPBFEFIB@?$CD?5uload?5for?5wad?3?5?$CFu?0?5lump?3?5?$CFu@
CONST	SEGMENT
??_C@_0BO@IPBFEFIB@?$CD?5uload?5for?5wad?3?5?$CFu?0?5lump?3?5?$CFu@ DB '#'
	DB	' uload for wad: %u, lump: %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s@
CONST	SEGMENT
??_C@_01LKDEMHDF@s@ DB 's', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJAEHHAP@SRB2@
CONST	SEGMENT
??_C@_04LJAEHHAP@SRB2@ DB 'SRB2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EHCDOLII@MAINCFG@
CONST	SEGMENT
??_C@_07EHCDOLII@MAINCFG@ DB 'MAINCFG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBBPBCC@EMBLEM@
CONST	SEGMENT
??_C@_06HBBPBCC@EMBLEM@ DB 'EMBLEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHILKLAK@HUDITEM@
CONST	SEGMENT
??_C@_07KHILKLAK@HUDITEM@ DB 'HUDITEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEGDOMG@SOUND@
CONST	SEGMENT
??_C@_05MEGDOMG@SOUND@ DB 'SOUND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DALLBAN@FRAME@
CONST	SEGMENT
??_C@_05DALLBAN@FRAME@ DB 'FRAME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GFIFJDNE@UNLOCKABLE@
CONST	SEGMENT
??_C@_0L@GFIFJDNE@UNLOCKABLE@ DB 'UNLOCKABLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PKDMAPNA@CUTSCENE@
CONST	SEGMENT
??_C@_08PKDMAPNA@CUTSCENE@ DB 'CUTSCENE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCEPFMCO@LEVEL@
CONST	SEGMENT
??_C@_05GCEPFMCO@LEVEL@ DB 'LEVEL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOFEGNGM@SPRITE@
CONST	SEGMENT
??_C@_06DOFEGNGM@SPRITE@ DB 'SPRITE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFNJIKNP@LIGHT@
CONST	SEGMENT
??_C@_05MFNJIKNP@LIGHT@ DB 'LIGHT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMCLKDIA@CHARACTER@
CONST	SEGMENT
??_C@_09DMCLKDIA@CHARACTER@ DB 'CHARACTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CLEJPIKP@MODBY@
CONST	SEGMENT
??_C@_05CLEJPIKP@MODBY@ DB 'MODBY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCIBGJIK@THING@
CONST	SEGMENT
??_C@_05JCIBGJIK@THING@ DB 'THING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IPCLALDD@Emblem?3?5unknown?5word?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BK@IPCLALDD@Emblem?3?5unknown?5word?5?8?$CFs?8@ DB 'Emblem: unknow'
	DB	'n word ''%s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06OPDDNACH@MAPNUM@
CONST	SEGMENT
??_C@_06OPDDNACH@MAPNUM@ DB 'MAPNUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IHJAHKKM@PLAYERNUM@
CONST	SEGMENT
??_C@_09IHJAHKKM@PLAYERNUM@ DB 'PLAYERNUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01POHCFINO@Z@
CONST	SEGMENT
??_C@_01POHCFINO@Z@ DB 'Z', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOOIFKJP@Maincfg?3?5unknown?5word?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BL@DOOIFKJP@Maincfg?3?5unknown?5word?5?8?$CFs?8@ DB 'Maincfg: unkn'
	DB	'own word ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IMHIENOO@CUSTOMVERSION@
CONST	SEGMENT
??_C@_0O@IMHIENOO@CUSTOMVERSION@ DB 'CUSTOMVERSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDBIFKFH@RESETDATA@
CONST	SEGMENT
??_C@_09GDBIFKFH@RESETDATA@ DB 'RESETDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FNJPMFEA@Sorry?0?5a?5maximum?5of?5?$CFd?5emblems?5@
CONST	SEGMENT
??_C@_0CM@FNJPMFEA@Sorry?0?5a?5maximum?5of?5?$CFd?5emblems?5@ DB 'Sorry, '
	DB	'a maximum of %d emblems is allowed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LOIKKLLC@NUMEMBLEMS@
CONST	SEGMENT
??_C@_0L@LOIKKLLC@NUMEMBLEMS@ DB 'NUMEMBLEMS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPIJBPLG@?$CFu?4ssg@
CONST	SEGMENT
??_C@_06NPIJBPLG@?$CFu?4ssg@ DB '%u.ssg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BCDGLAPN@Maincfg?3?5bad?5data?5file?5name?5?8?$CFs@
CONST	SEGMENT
??_C@_0CC@BCDGLAPN@Maincfg?3?5bad?5data?5file?5name?5?8?$CFs@ DB 'Maincfg'
	DB	': bad data file name ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DAHHPBHD@GAMEDATA@
CONST	SEGMENT
??_C@_08DAHHPBHD@GAMEDATA@ DB 'GAMEDATA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJADGDCM@DISABLESPEEDADJUST@
CONST	SEGMENT
??_C@_0BD@KJADGDCM@DISABLESPEEDADJUST@ DB 'DISABLESPEEDADJUST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIHDLKN@CREDITSCUTSCENE@
CONST	SEGMENT
??_C@_0BA@FOIHDLKN@CREDITSCUTSCENE@ DB 'CREDITSCUTSCENE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IKJKJFLM@TITLESCROLLSPEED@
CONST	SEGMENT
??_C@_0BB@IKJKJFLM@TITLESCROLLSPEED@ DB 'TITLESCROLLSPEED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DIKNKCEP@LOOPTITLE@
CONST	SEGMENT
??_C@_09DIKNKCEP@LOOPTITLE@ DB 'LOOPTITLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GLFMEFCC@INTROTOPLAY@
CONST	SEGMENT
??_C@_0M@GLFMEFCC@INTROTOPLAY@ DB 'INTROTOPLAY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDCOMLBK@GAMEOVERTICS@
CONST	SEGMENT
??_C@_0N@PDCOMLBK@GAMEOVERTICS@ DB 'GAMEOVERTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HCFAMJBI@HELPERTICS@
CONST	SEGMENT
??_C@_0L@HCFAMJBI@HELPERTICS@ DB 'HELPERTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LNHOBDGP@PARALOOPTICS@
CONST	SEGMENT
??_C@_0N@LNHOBDGP@PARALOOPTICS@ DB 'PARALOOPTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGLHIKIO@GRAVBOOTSTICS@
CONST	SEGMENT
??_C@_0O@KGLHIKIO@GRAVBOOTSTICS@ DB 'GRAVBOOTSTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GIPPCDEL@EXTRALIFETICS@
CONST	SEGMENT
??_C@_0O@GIPPCDEL@EXTRALIFETICS@ DB 'EXTRALIFETICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ELLLBCPC@SPACETIMETICS@
CONST	SEGMENT
??_C@_0O@ELLLBCPC@SPACETIMETICS@ DB 'SPACETIMETICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGMLJMDB@UNDERWATERTICS@
CONST	SEGMENT
??_C@_0P@DGMLJMDB@UNDERWATERTICS@ DB 'UNDERWATERTICS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPDPGMBI@TAILSFLYTICS@
CONST	SEGMENT
??_C@_0N@HPDPGMBI@TAILSFLYTICS@ DB 'TAILSFLYTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FLPJIF@FLASHINGTICS@
CONST	SEGMENT
??_C@_0N@FLPJIF@FLASHINGTICS@ DB 'FLASHINGTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBMMDGAO@SNEAKERTICS@
CONST	SEGMENT
??_C@_0M@BBMMDGAO@SNEAKERTICS@ DB 'SNEAKERTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLLMKMJH@INVULNTICS@
CONST	SEGMENT
??_C@_0L@NLLMKMJH@INVULNTICS@ DB 'INVULNTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLOADGPD@RACESTAGE_START@
CONST	SEGMENT
??_C@_0BA@JLOADGPD@RACESTAGE_START@ DB 'RACESTAGE_START', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JHKIJPM@SPSTAGE_END@
CONST	SEGMENT
??_C@_0M@JHKIJPM@SPSTAGE_END@ DB 'SPSTAGE_END', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FFIDGAFG@SPSTAGE_START@
CONST	SEGMENT
??_C@_0O@FFIDGAFG@SPSTAGE_START@ DB 'SPSTAGE_START', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNCMPFKC@exec?5?$CFs?6@
CONST	SEGMENT
??_C@_08NNCMPFKC@exec?5?$CFs?6@ DB 'exec %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJNCCNOK@EXECCFG@
CONST	SEGMENT
??_C@_07OJNCCNOK@EXECCFG@ DB 'EXECCFG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJABEAKP@NSSTAGE_START@
CONST	SEGMENT
??_C@_0O@DJABEAKP@NSSTAGE_START@ DB 'NSSTAGE_START', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GNOMNNJL@SSTAGE_START@
CONST	SEGMENT
??_C@_0N@GNOMNNJL@SSTAGE_START@ DB 'SSTAGE_START', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCMAOFIJ@gamedata?4dat@
CONST	SEGMENT
??_C@_0N@JCMAOFIJ@gamedata?4dat@ DB 'gamedata.dat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PBCOOEDG@?4dat@
CONST	SEGMENT
??_C@_04PBCOOEDG@?4dat@ DB '.dat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OIKDCDHK@Sound?5?$CFd?5?3?5unknown?5word?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BN@OIKDCDHK@Sound?5?$CFd?5?3?5unknown?5word?5?8?$CFs?8@ DB 'Sound '
	DB	'%d : unknown word ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PHDJDNOC@PRIORITY@
CONST	SEGMENT
??_C@_08PHDJDNOC@PRIORITY@ DB 'PRIORITY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LKHGAEML@SINGULAR@
CONST	SEGMENT
??_C@_08LKHGAEML@SINGULAR@ DB 'SINGULAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LEECKIDM@Frame?5?$CFd?3?5unknown?5word?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BM@LEECKIDM@Frame?5?$CFd?3?5unknown?5word?5?8?$CFs?8@ DB 'Frame %d'
	DB	': unknown word ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEOOGJAL@Unknown?5action?5?$CFs@
CONST	SEGMENT
??_C@_0BC@GEOOGJAL@Unknown?5action?5?$CFs@ DB 'Unknown action %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DHJAPAEE@ACTION@
CONST	SEGMENT
??_C@_06DHJAPAEE@ACTION@ DB 'ACTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPGOKDHO@VAR2@
CONST	SEGMENT
??_C@_04CPGOKDHO@VAR2@ DB 'VAR2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EEDPALN@VAR1@
CONST	SEGMENT
??_C@_04EEDPALN@VAR1@ DB 'VAR1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOKMKBJN@NEXT@
CONST	SEGMENT
??_C@_04MOKMKBJN@NEXT@ DB 'NEXT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MJLDLDGF@DURATION@
CONST	SEGMENT
??_C@_08MJLDLDGF@DURATION@ DB 'DURATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DONIHLJC@SPRITESUBNUMBER@
CONST	SEGMENT
??_C@_0BA@DONIHLJC@SPRITESUBNUMBER@ DB 'SPRITESUBNUMBER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDNLMHGB@SPRITENUMBER@
CONST	SEGMENT
??_C@_0N@FDNLMHGB@SPRITENUMBER@ DB 'SPRITENUMBER', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_actionpointers DD FLAT:_A_Explode
	DD	FLAT:??_C@_09BJMGHFGB@A_EXPLODE@
	DD	FLAT:_A_Pain
	DD	FLAT:??_C@_06HHDNMADJ@A_PAIN@
	DD	FLAT:_A_Fall
	DD	FLAT:??_C@_06KMGAACHC@A_FALL@
	DD	FLAT:_A_MonitorPop
	DD	FLAT:??_C@_0N@ONKHEMAF@A_MONITORPOP@
	DD	FLAT:_A_Look
	DD	FLAT:??_C@_06ELAIEFHO@A_LOOK@
	DD	FLAT:_A_Chase
	DD	FLAT:??_C@_07ILGEAEAA@A_CHASE@
	DD	FLAT:_A_FaceTarget
	DD	FLAT:??_C@_0N@OIJAEHGO@A_FACETARGET@
	DD	FLAT:_A_Scream
	DD	FLAT:??_C@_08BNHOHEIM@A_SCREAM@
	DD	FLAT:_A_BossDeath
	DD	FLAT:??_C@_0M@OCDNBEND@A_BOSSDEATH@
	DD	FLAT:_A_CustomPower
	DD	FLAT:??_C@_0O@EEMLAPNN@A_CUSTOMPOWER@
	DD	FLAT:_A_GiveWeapon
	DD	FLAT:??_C@_0N@CBNDHKJG@A_GIVEWEAPON@
	DD	FLAT:_A_RingShield
	DD	FLAT:??_C@_0N@EMIAHIHJ@A_RINGSHIELD@
	DD	FLAT:_A_RingBox
	DD	FLAT:??_C@_09OBEONDPD@A_RINGBOX@
	DD	FLAT:_A_Invincibility
	DD	FLAT:??_C@_0BA@EOCKJFCP@A_INVINCIBILITY@
	DD	FLAT:_A_SuperSneakers
	DD	FLAT:??_C@_0BA@PILBDMPL@A_SUPERSNEAKERS@
	DD	FLAT:_A_BunnyHop
	DD	FLAT:??_C@_0L@KNLLKMCD@A_BUNNYHOP@
	DD	FLAT:_A_BubbleSpawn
	DD	FLAT:??_C@_0O@JNDLILOG@A_BUBBLESPAWN@
	DD	FLAT:_A_BubbleRise
	DD	FLAT:??_C@_0N@PLPBDHK@A_BUBBLERISE@
	DD	FLAT:_A_BubbleCheck
	DD	FLAT:??_C@_0O@CHEHDNIA@A_BUBBLECHECK@
	DD	FLAT:_A_ExtraLife
	DD	FLAT:??_C@_0M@FGJHPAMB@A_EXTRALIFE@
	DD	FLAT:_A_BombShield
	DD	FLAT:??_C@_0N@JOAFPOFE@A_BOMBSHIELD@
	DD	FLAT:_A_JumpShield
	DD	FLAT:??_C@_0N@CKNEDIGG@A_JUMPSHIELD@
	DD	FLAT:_A_WaterShield
	DD	FLAT:??_C@_0O@FFFOIECP@A_WATERSHIELD@
	DD	FLAT:_A_ForceShield
	DD	FLAT:??_C@_0O@JIOPDPEF@A_FORCESHIELD@
	DD	FLAT:_A_GravityBox
	DD	FLAT:??_C@_0N@INHLNJNE@A_GRAVITYBOX@
	DD	FLAT:_A_ScoreRise
	DD	FLAT:??_C@_0M@CNMPPKNB@A_SCORERISE@
	DD	FLAT:_A_ParticleSpawn
	DD	FLAT:??_C@_0BA@GNGNFDEI@A_PARTICLESPAWN@
	DD	FLAT:_A_AttractChase
	DD	FLAT:??_C@_0P@JICBJCDN@A_ATTRACTCHASE@
	DD	FLAT:_A_DropMine
	DD	FLAT:??_C@_0L@FAGEGOOL@A_DROPMINE@
	DD	FLAT:_A_FishJump
	DD	FLAT:??_C@_0L@INKEHBCG@A_FISHJUMP@
	DD	FLAT:_A_ThrownRing
	DD	FLAT:??_C@_0N@IFLPCKFM@A_THROWNRING@
	DD	FLAT:_A_GrenadeRing
	DD	FLAT:??_C@_0O@LNPHKGMC@A_GRENADERING@
	DD	FLAT:_A_SetSolidSteam
	DD	FLAT:??_C@_0BA@GCOHKLLG@A_SETSOLIDSTEAM@
	DD	FLAT:_A_UnsetSolidSteam
	DD	FLAT:??_C@_0BC@PPICBAMN@A_UNSETSOLIDSTEAM@
	DD	FLAT:_A_SignPlayer
	DD	FLAT:??_C@_0N@KNGNHPPM@A_SIGNPLAYER@
	DD	FLAT:_A_JetChase
	DD	FLAT:??_C@_0L@BHOJKCPG@A_JETCHASE@
	DD	FLAT:_A_JetbThink
	DD	FLAT:??_C@_0M@KLMGNLHK@A_JETBTHINK@
	DD	FLAT:_A_JetgThink
	DD	FLAT:??_C@_0M@PJPOPENN@A_JETGTHINK@
	DD	FLAT:_A_JetgShoot
	DD	FLAT:??_C@_0M@NAIPPBA@A_JETGSHOOT@
	DD	FLAT:_A_ShootBullet
	DD	FLAT:??_C@_0O@CPAABHMI@A_SHOOTBULLET@
	DD	FLAT:_A_MinusDigging
	DD	FLAT:??_C@_0P@EKOOHBIL@A_MINUSDIGGING@
	DD	FLAT:_A_MinusPopup
	DD	FLAT:??_C@_0N@HFELODHD@A_MINUSPOPUP@
	DD	FLAT:_A_MinusCheck
	DD	FLAT:??_C@_0N@JEHDPMKD@A_MINUSCHECK@
	DD	FLAT:_A_ChickenCheck
	DD	FLAT:??_C@_0P@MBEJLNCB@A_CHICKENCHECK@
	DD	FLAT:_A_MouseThink
	DD	FLAT:??_C@_0N@CJEEOOPD@A_MOUSETHINK@
	DD	FLAT:_A_DetonChase
	DD	FLAT:??_C@_0N@CKFJCDAD@A_DETONCHASE@
	DD	FLAT:_A_CapeChase
	DD	FLAT:??_C@_0M@BKMIJGKJ@A_CAPECHASE@
	DD	FLAT:_A_RotateSpikeBall
	DD	FLAT:??_C@_0BC@HNBHOLIF@A_ROTATESPIKEBALL@
	DD	FLAT:_A_MaceRotate
	DD	FLAT:??_C@_0N@HGHNNEEL@A_MACEROTATE@
	DD	FLAT:_A_RockSpawn
	DD	FLAT:??_C@_0M@PNGEFLH@A_ROCKSPAWN@
	DD	FLAT:_A_SnowBall
	DD	FLAT:??_C@_0L@DLHGIFJG@A_SNOWBALL@
	DD	FLAT:_A_CrawlaCommanderThink
	DD	FLAT:??_C@_0BH@LCFLDBKE@A_CRAWLACOMMANDERTHINK@
	DD	FLAT:_A_SmokeTrailer
	DD	FLAT:??_C@_0P@FMAPOIFK@A_SMOKETRAILER@
	DD	FLAT:_A_RingExplode
	DD	FLAT:??_C@_0O@ECONMIAO@A_RINGEXPLODE@
	DD	FLAT:_A_OldRingExplode
	DD	FLAT:??_C@_0BB@LMKNJAFP@A_OLDRINGEXPLODE@
	DD	FLAT:_A_MixUp
	DD	FLAT:??_C@_07JCCHMOHD@A_MIXUP@
	DD	FLAT:_A_RecyclePowers
	DD	FLAT:??_C@_0BA@ECFAMBON@A_RECYCLEPOWERS@
	DD	FLAT:_A_BossScream
	DD	FLAT:??_C@_0N@OOPLCIEI@A_BOSSSCREAM@
	DD	FLAT:_A_Invinciblerize
	DD	FLAT:??_C@_0BB@OEKDEFGL@A_INVINCIBLERIZE@
	DD	FLAT:_A_DeInvinciblerize
	DD	FLAT:??_C@_0BD@OJMFPBOH@A_DEINVINCIBLERIZE@
	DD	FLAT:_A_GoopSplat
	DD	FLAT:??_C@_0M@KGMLCPKE@A_GOOPSPLAT@
	DD	FLAT:_A_Boss2PogoSFX
	DD	FLAT:??_C@_0P@PGHLMEMF@A_BOSS2POGOSFX@
	DD	FLAT:_A_BossJetFume
	DD	FLAT:??_C@_0O@LLEBMPPF@A_BOSSJETFUME@
	DD	FLAT:_A_EggmanBox
	DD	FLAT:??_C@_0M@BLDACEHM@A_EGGMANBOX@
	DD	FLAT:_A_TurretFire
	DD	FLAT:??_C@_0N@FADHKBDA@A_TURRETFIRE@
	DD	FLAT:_A_SuperTurretFire
	DD	FLAT:??_C@_0BC@MEIAKHOI@A_SUPERTURRETFIRE@
	DD	FLAT:_A_TurretStop
	DD	FLAT:??_C@_0N@HJAPOALH@A_TURRETSTOP@
	DD	FLAT:_A_JetJawRoam
	DD	FLAT:??_C@_0N@EDDEDDAD@A_JETJAWROAM@
	DD	FLAT:_A_JetJawChomp
	DD	FLAT:??_C@_0O@LJIEECMA@A_JETJAWCHOMP@
	DD	FLAT:_A_PointyThink
	DD	FLAT:??_C@_0O@MGBEBIKD@A_POINTYTHINK@
	DD	FLAT:_A_CheckBuddy
	DD	FLAT:??_C@_0N@NDFMEJOG@A_CHECKBUDDY@
	DD	FLAT:_A_HoodThink
	DD	FLAT:??_C@_0M@HIBMJJJO@A_HOODTHINK@
	DD	FLAT:_A_ArrowCheck
	DD	FLAT:??_C@_0N@BCOHKMOO@A_ARROWCHECK@
	DD	FLAT:_A_SnailerThink
	DD	FLAT:??_C@_0P@KPFAEKCM@A_SNAILERTHINK@
	DD	FLAT:_A_SharpChase
	DD	FLAT:??_C@_0N@GOGCLNKM@A_SHARPCHASE@
	DD	FLAT:_A_SharpSpin
	DD	FLAT:??_C@_0M@LDPCLNO@A_SHARPSPIN@
	DD	FLAT:_A_VultureVtol
	DD	FLAT:??_C@_0O@IPLAPNKM@A_VULTUREVTOL@
	DD	FLAT:_A_VultureCheck
	DD	FLAT:??_C@_0P@FOIIIHAC@A_VULTURECHECK@
	DD	FLAT:_A_SkimChase
	DD	FLAT:??_C@_0M@PIFDPJLI@A_SKIMCHASE@
	DD	FLAT:_A_1upThinker
	DD	FLAT:??_C@_0N@MBCBHIOH@A_1UPTHINKER@
	DD	FLAT:_A_SkullAttack
	DD	FLAT:??_C@_0O@IBCEMJDJ@A_SKULLATTACK@
	DD	FLAT:_A_LobShot
	DD	FLAT:??_C@_09MKAFJLIB@A_LOBSHOT@
	DD	FLAT:_A_CannonLook
	DD	FLAT:??_C@_0N@HLMEOAII@A_CANNONLOOK@
	DD	FLAT:_A_FireShot
	DD	FLAT:??_C@_0L@DPCGACJH@A_FIRESHOT@
	DD	FLAT:_A_SuperFireShot
	DD	FLAT:??_C@_0BA@NEIOHAPA@A_SUPERFIRESHOT@
	DD	FLAT:_A_BossFireShot
	DD	FLAT:??_C@_0P@PCGNPOIH@A_BOSSFIRESHOT@
	DD	FLAT:_A_SparkFollow
	DD	FLAT:??_C@_0O@KNFAFHKP@A_SPARKFOLLOW@
	DD	FLAT:_A_BuzzFly
	DD	FLAT:??_C@_09KJIDBPJD@A_BUZZFLY@
	DD	FLAT:_A_GuardChase
	DD	FLAT:??_C@_0N@DBIMLIGA@A_GUARDCHASE@
	DD	FLAT:_A_SetReactionTime
	DD	FLAT:??_C@_0BC@IEAHIAIA@A_SETREACTIONTIME@
	DD	FLAT:_A_Boss3TakeDamage
	DD	FLAT:??_C@_0BC@HBGLJLHG@A_BOSS3TAKEDAMAGE@
	DD	FLAT:_A_LinedefExecute
	DD	FLAT:??_C@_0BB@LNGKEENP@A_LINEDEFEXECUTE@
	DD	FLAT:_A_PlaySeeSound
	DD	FLAT:??_C@_0P@DKHNAODF@A_PLAYSEESOUND@
	DD	FLAT:_A_PlayAttackSound
	DD	FLAT:??_C@_0BC@ONICOINE@A_PLAYATTACKSOUND@
	DD	FLAT:_A_PlayActiveSound
	DD	FLAT:??_C@_0BC@LFPDNPJG@A_PLAYACTIVESOUND@
	DD	FLAT:_A_SpawnObjectAbsolute
	DD	FLAT:??_C@_0BG@ELDBAFFM@A_SPAWNOBJECTABSOLUTE@
	DD	FLAT:_A_SpawnObjectRelative
	DD	FLAT:??_C@_0BG@DGPOBPKM@A_SPAWNOBJECTRELATIVE@
	DD	FLAT:_A_ChangeAngleRelative
	DD	FLAT:??_C@_0BG@LDPDDKM@A_CHANGEANGLERELATIVE@
	DD	FLAT:_A_ChangeAngleAbsolute
	DD	FLAT:??_C@_0BG@HGPACJFM@A_CHANGEANGLEABSOLUTE@
	DD	FLAT:_A_PlaySound
	DD	FLAT:??_C@_0M@FEBJJDDL@A_PLAYSOUND@
	DD	FLAT:_A_FindTarget
	DD	FLAT:??_C@_0N@MGKCOAFD@A_FINDTARGET@
	DD	FLAT:_A_FindTracer
	DD	FLAT:??_C@_0N@LNJIENOF@A_FINDTRACER@
	DD	FLAT:_A_SetTics
	DD	FLAT:??_C@_09FCKGNCBI@A_SETTICS@
	DD	FLAT:_A_SetRandomTics
	DD	FLAT:??_C@_0BA@KOJLBKIK@A_SETRANDOMTICS@
	DD	FLAT:_A_ChangeColorRelative
	DD	FLAT:??_C@_0BG@BKMFHGBK@A_CHANGECOLORRELATIVE@
	DD	FLAT:_A_ChangeColorAbsolute
	DD	FLAT:??_C@_0BG@GHAKGMOK@A_CHANGECOLORABSOLUTE@
	DD	FLAT:_A_MoveRelative
	DD	FLAT:??_C@_0P@MOLLNFHC@A_MOVERELATIVE@
	DD	FLAT:_A_MoveAbsolute
	DD	FLAT:??_C@_0P@LDHEMPIC@A_MOVEABSOLUTE@
	DD	FLAT:_A_Thrust
	DD	FLAT:??_C@_08GGKFDDFI@A_THRUST@
	DD	FLAT:_A_ZThrust
	DD	FLAT:??_C@_09DOLMLEJJ@A_ZTHRUST@
	DD	FLAT:_A_SetTargetsTarget
	DD	FLAT:??_C@_0BD@JGAAAMJF@A_SETTARGETSTARGET@
	DD	FLAT:_A_SetObjectFlags
	DD	FLAT:??_C@_0BB@BLKBOCAM@A_SETOBJECTFLAGS@
	DD	FLAT:_A_SetObjectFlags2
	DD	FLAT:??_C@_0BC@OENNLJLI@A_SETOBJECTFLAGS2@
	DD	FLAT:_A_RandomState
	DD	FLAT:??_C@_0O@EPHIMAIB@A_RANDOMSTATE@
	DD	FLAT:_A_RandomStateRange
	DD	FLAT:??_C@_0BD@HAANMKAI@A_RANDOMSTATERANGE@
	DD	FLAT:_A_DualAction
	DD	FLAT:??_C@_0N@FALADGM@A_DUALACTION@
	DD	FLAT:_A_RemoteAction
	DD	FLAT:??_C@_0P@ICAIGFMP@A_REMOTEACTION@
	DD	FLAT:_A_ToggleFlameJet
	DD	FLAT:??_C@_0BB@NHHDDBPG@A_TOGGLEFLAMEJET@
	DD	00H
	DD	FLAT:??_C@_04OKGDLNCL@NONE@
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_01NFFPALBN@Y@
CONST	SEGMENT
??_C@_01NFFPALBN@Y@ DB 'Y', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01MMEEDKFM@X@
CONST	SEGMENT
??_C@_01MMEEDKFM@X@ DB 'X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PNJBHKCI@Unlockable?5?$CFd?3?5unknown?5word?5?8?$CFs@
CONST	SEGMENT
??_C@_0CB@PNJBHKCI@Unlockable?5?$CFd?3?5unknown?5word?5?8?$CFs@ DB 'Unloc'
	DB	'kable %d: unknown word ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJAIKILM@VAR@
CONST	SEGMENT
??_C@_03MJAIKILM@VAR@ DB 'VAR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDPJLEDB@TYPE@
CONST	SEGMENT
??_C@_04KDPJLEDB@TYPE@ DB 'TYPE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKLCILOC@OBJECTIVE@
CONST	SEGMENT
??_C@_09GKLCILOC@OBJECTIVE@ DB 'OBJECTIVE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKHEEB@NAME@
CONST	SEGMENT
??_C@_04IPKHEEB@NAME@ DB 'NAME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FJAIOMKE@NEEDEDGRADE@
CONST	SEGMENT
??_C@_0M@FJAIOMKE@NEEDEDGRADE@ DB 'NEEDEDGRADE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDOPDIK@NEEDEDTIME@
CONST	SEGMENT
??_C@_0L@NDOPDIK@NEEDEDTIME@ DB 'NEEDEDTIME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPFEEMIH@NEEDEDEMBLEMS@
CONST	SEGMENT
??_C@_0O@OPFEEMIH@NEEDEDEMBLEMS@ DB 'NEEDEDEMBLEMS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GFCLHAEP@Cutscene?5?$CFd?3?5unknown?5word?5?8?$CFs?8?0@
CONST	SEGMENT
??_C@_0DG@GFCLHAEP@Cutscene?5?$CFd?3?5unknown?5word?5?8?$CFs?8?0@ DB 'Cut'
	DB	'scene %d: unknown word ''%s'', Scene <num> expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HKLMADIL@Scene?5number?5?$CFd?5out?5of?5range@
CONST	SEGMENT
??_C@_0BN@HKLMADIL@Scene?5number?5?$CFd?5out?5of?5range@ DB 'Scene number'
	DB	' %d out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IALELFBJ@SCENE@
CONST	SEGMENT
??_C@_05IALELFBJ@SCENE@ DB 'SCENE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBLFEBPM@NUMSCENES@
CONST	SEGMENT
??_C@_09IBLFEBPM@NUMSCENES@ DB 'NUMSCENES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KFBFNACM@No?5value?5for?5token?5?$CFs@
CONST	SEGMENT
??_C@_0BG@KFBFNACM@No?5value?5for?5token?5?$CFs@ DB 'No value for token %'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BHIFLOEA@CutSceneScene?5?$CFd?3?5unknown?5word?5@
CONST	SEGMENT
??_C@_0CE@BHIFLOEA@CutSceneScene?5?$CFd?3?5unknown?5word?5@ DB 'CutSceneS'
	DB	'cene %d: unknown word ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MEEOLMOB@TEXTYPOS@
CONST	SEGMENT
??_C@_08MEEOLMOB@TEXTYPOS@ DB 'TEXTYPOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJCOJFFB@TEXTXPOS@
CONST	SEGMENT
??_C@_08PJCOJFFB@TEXTXPOS@ DB 'TEXTXPOS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FDALMJGH@MUSICLOOP@
CONST	SEGMENT
??_C@_09FDALMJGH@MUSICLOOP@ DB 'MUSICLOOP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCCGOLNN@PIC8YCOORD@
CONST	SEGMENT
??_C@_0L@OCCGOLNN@PIC8YCOORD@ DB 'PIC8YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLAGPJHB@PIC7YCOORD@
CONST	SEGMENT
??_C@_0L@DLAGPJHB@PIC7YCOORD@ DB 'PIC7YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHKMPJOP@PIC6YCOORD@
CONST	SEGMENT
??_C@_0L@PHKMPJOP@PIC6YCOORD@ DB 'PIC6YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HJCDPOAM@PIC5YCOORD@
CONST	SEGMENT
??_C@_0L@HJCDPOAM@PIC5YCOORD@ DB 'PIC5YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LFIJPOJC@PIC4YCOORD@
CONST	SEGMENT
??_C@_0L@LFIJPOJC@PIC4YCOORD@ DB 'PIC4YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPEMPHIL@PIC3YCOORD@
CONST	SEGMENT
??_C@_0L@LPEMPHIL@PIC3YCOORD@ DB 'PIC3YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDOGPHBF@PIC2YCOORD@
CONST	SEGMENT
??_C@_0L@HDOGPHBF@PIC2YCOORD@ DB 'PIC2YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PNGJPAPG@PIC1YCOORD@
CONST	SEGMENT
??_C@_0L@PNGJPAPG@PIC1YCOORD@ DB 'PIC1YCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EEFBOAGJ@PIC8XCOORD@
CONST	SEGMENT
??_C@_0L@EEFBOAGJ@PIC8XCOORD@ DB 'PIC8XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNHBPCMF@PIC7XCOORD@
CONST	SEGMENT
??_C@_0L@JNHBPCMF@PIC7XCOORD@ DB 'PIC7XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBNLPCFL@PIC6XCOORD@
CONST	SEGMENT
??_C@_0L@FBNLPCFL@PIC6XCOORD@ DB 'PIC6XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPFEPFLI@PIC5XCOORD@
CONST	SEGMENT
??_C@_0L@NPFEPFLI@PIC5XCOORD@ DB 'PIC5XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BDPOPFCG@PIC4XCOORD@
CONST	SEGMENT
??_C@_0L@BDPOPFCG@PIC4XCOORD@ DB 'PIC4XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJDLPMDP@PIC3XCOORD@
CONST	SEGMENT
??_C@_0L@BJDLPMDP@PIC3XCOORD@ DB 'PIC3XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFJBPMKB@PIC2XCOORD@
CONST	SEGMENT
??_C@_0L@NFJBPMKB@PIC2XCOORD@ DB 'PIC2XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLBOPLEC@PIC1XCOORD@
CONST	SEGMENT
??_C@_0L@FLBOPLEC@PIC1XCOORD@ DB 'PIC1XCOORD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LAAAOGHL@PIC8DURATION@
CONST	SEGMENT
??_C@_0N@LAAAOGHL@PIC8DURATION@ DB 'PIC8DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBALLNPG@PIC7DURATION@
CONST	SEGMENT
??_C@_0N@EBALLNPG@PIC7DURATION@ DB 'PIC7DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KOMJNGMI@PIC6DURATION@
CONST	SEGMENT
??_C@_0N@KOMJNGMI@PIC6DURATION@ DB 'PIC6DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EFPOGNML@PIC5DURATION@
CONST	SEGMENT
??_C@_0N@EFPOGNML@PIC5DURATION@ DB 'PIC5DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KKDMAGPF@PIC4DURATION@
CONST	SEGMENT
??_C@_0N@KKDMAGPF@PIC4DURATION@ DB 'PIC4DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EIOABNIM@PIC3DURATION@
CONST	SEGMENT
??_C@_0N@EIOABNIM@PIC3DURATION@ DB 'PIC3DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHCCHGLC@PIC2DURATION@
CONST	SEGMENT
??_C@_0N@KHCCHGLC@PIC2DURATION@ DB 'PIC2DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMBFMNLB@PIC1DURATION@
CONST	SEGMENT
??_C@_0N@EMBFMNLB@PIC1DURATION@ DB 'PIC1DURATION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLOFLOAK@PIC8HIRES@
CONST	SEGMENT
??_C@_09NLOFLOAK@PIC8HIRES@ DB 'PIC8HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNKNMOOD@PIC7HIRES@
CONST	SEGMENT
??_C@_09CNKNMOOD@PIC7HIRES@ DB 'PIC7HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILNKMFFH@PIC6HIRES@
CONST	SEGMENT
??_C@_09ILNKMFFH@PIC6HIRES@ DB 'PIC6HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKDCNPMK@PIC5HIRES@
CONST	SEGMENT
??_C@_09LKDCNPMK@PIC5HIRES@ DB 'PIC5HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BMEFNEHO@PIC4HIRES@
CONST	SEGMENT
??_C@_09BMEFNEHO@PIC4HIRES@ DB 'PIC4HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NJOCOKPA@PIC3HIRES@
CONST	SEGMENT
??_C@_09NJOCOKPA@PIC3HIRES@ DB 'PIC3HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPJFOBEE@PIC2HIRES@
CONST	SEGMENT
??_C@_09HPJFOBEE@PIC2HIRES@ DB 'PIC2HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOHNPLNJ@PIC1HIRES@
CONST	SEGMENT
??_C@_09EOHNPLNJ@PIC1HIRES@ DB 'PIC1HIRES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PBJLOFGG@PIC8NAME@
CONST	SEGMENT
??_C@_08PBJLOFGG@PIC8NAME@ DB 'PIC8NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNFHLD@PIC7NAME@
CONST	SEGMENT
??_C@_08MNFHLD@PIC7NAME@ DB 'PIC7NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLJBIEBG@PIC6NAME@
CONST	SEGMENT
??_C@_08MLJBIEBG@PIC6NAME@ DB 'PIC6NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENAFPGLI@PIC5NAME@
CONST	SEGMENT
??_C@_08ENAFPGLI@PIC5NAME@ DB 'PIC5NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGFJCFBN@PIC4NAME@
CONST	SEGMENT
??_C@_08IGFJCFBN@PIC4NAME@ DB 'PIC4NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLFMBFKF@PIC3NAME@
CONST	SEGMENT
??_C@_08JLFMBFKF@PIC3NAME@ DB 'PIC3NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FAAAMGAA@PIC2NAME@
CONST	SEGMENT
??_C@_08FAAAMGAA@PIC2NAME@ DB 'PIC2NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGJELEKO@PIC1NAME@
CONST	SEGMENT
??_C@_08NGJELEKO@PIC1NAME@ DB 'PIC1NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBKKDBGP@NUMBEROFPICS@
CONST	SEGMENT
??_C@_0N@EBKKDBGP@NUMBEROFPICS@ DB 'NUMBEROFPICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOLEOKCO@SCENETEXT@
CONST	SEGMENT
??_C@_09FOLEOKCO@SCENETEXT@ DB 'SCENETEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DEOJKBPN@Level?5header?5?$CFd?3?5unknown?5word?5?8@
CONST	SEGMENT
??_C@_0CD@DEOJKBPN@Level?5header?5?$CFd?3?5unknown?5word?5?8@ DB 'Level h'
	DB	'eader %d: unknown word ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHNKBFGK@PALETTE@
CONST	SEGMENT
??_C@_07GHNKBFGK@PALETTE@ DB 'PALETTE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BEHDNBAE@RUNSOC@
CONST	SEGMENT
??_C@_06BEHDNBAE@RUNSOC@ DB 'RUNSOC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PGCBNPFL@NOPERFECTBONUS@
CONST	SEGMENT
??_C@_0P@PGCBNPFL@NOPERFECTBONUS@ DB 'NOPERFECTBONUS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIALMPNC@LEVELSELECT@
CONST	SEGMENT
??_C@_0M@JIALMPNC@LEVELSELECT@ DB 'LEVELSELECT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKBJCDCO@TIMEATTACK@
CONST	SEGMENT
??_C@_0L@IKBJCDCO@TIMEATTACK@ DB 'TIMEATTACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPPNBABB@NORELOAD@
CONST	SEGMENT
??_C@_08KPPNBABB@NORELOAD@ DB 'NORELOAD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHJOPLBJ@SPEEDMUSIC@
CONST	SEGMENT
??_C@_0L@LHJOPLBJ@SPEEDMUSIC@ DB 'SPEEDMUSIC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKCLDIIP@NOSSMUSIC@
CONST	SEGMENT
??_C@_09GKCLDIIP@NOSSMUSIC@ DB 'NOSSMUSIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMIOFMHI@HIDDEN@
CONST	SEGMENT
??_C@_06JMIOFMHI@HIDDEN@ DB 'HIDDEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MOHHBCJH@NOZONE@
CONST	SEGMENT
??_C@_06MOHHBCJH@NOZONE@ DB 'NOZONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JPDDLCMH@COUNTDOWN@
CONST	SEGMENT
??_C@_09JPDDLCMH@COUNTDOWN@ DB 'COUNTDOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBBFKHJP@CUTSCENENUM@
CONST	SEGMENT
??_C@_0M@HBBFKHJP@CUTSCENENUM@ DB 'CUTSCENENUM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFENKLKN@PRECUTSCENENUM@
CONST	SEGMENT
??_C@_0P@DFENKLKN@PRECUTSCENENUM@ DB 'PRECUTSCENENUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BKNFDAOL@SCRIPTISLUMP@
CONST	SEGMENT
??_C@_0N@BKNFDAOL@SCRIPTISLUMP@ DB 'SCRIPTISLUMP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPDCCGFG@SCRIPTNAME@
CONST	SEGMENT
??_C@_0L@OPDCCGFG@SCRIPTNAME@ DB 'SCRIPTNAME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PDGEIADF@INTERSCREEN@
CONST	SEGMENT
??_C@_0M@PDGEIADF@INTERSCREEN@ DB 'INTERSCREEN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HEFJHGKD@SKYNUM@
CONST	SEGMENT
??_C@_06HEFJHGKD@SKYNUM@ DB 'SKYNUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HKOGDAHK@WEATHER@
CONST	SEGMENT
??_C@_07HKOGDAHK@WEATHER@ DB 'WEATHER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOGKHGAO@FORCECHARACTER@
CONST	SEGMENT
??_C@_0P@HOGKHGAO@FORCECHARACTER@ DB 'FORCECHARACTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHGCKDNO@MUSICSLOT@
CONST	SEGMENT
??_C@_09MHGCKDNO@MUSICSLOT@ DB 'MUSICSLOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFCIMBHH@NEXTLEVEL@
CONST	SEGMENT
??_C@_09HFCIMBHH@NEXTLEVEL@ DB 'NEXTLEVEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOKBOJDC@TYPEOFLEVEL@
CONST	SEGMENT
??_C@_0M@GOKBOJDC@TYPEOFLEVEL@ DB 'TYPEOFLEVEL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CHCEALKM@Level?5header?5?$CFd?3?5invalid?5act?5nu@
CONST	SEGMENT
??_C@_0CH@CHCEALKM@Level?5header?5?$CFd?3?5invalid?5act?5nu@ DB 'Level he'
	DB	'ader %d: invalid act number %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FBBILEHC@ACT@
CONST	SEGMENT
??_C@_03FBBILEHC@ACT@ DB 'ACT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOGGCINI@SUBTITLE@
CONST	SEGMENT
??_C@_08OOGGCINI@SUBTITLE@ DB 'SUBTITLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MADBCAME@LEVELNAME@
CONST	SEGMENT
??_C@_09MADBCAME@LEVELNAME@ DB 'LEVELNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FEGHJPGL@Thing?5?$CFd?3?5unknown?5word?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BM@FEGHJPGL@Thing?5?$CFd?3?5unknown?5word?5?8?$CFs?8@ DB 'Thing %d'
	DB	': unknown word ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PIODEMOJ@RAISESTATE@
CONST	SEGMENT
??_C@_0L@PIODEMOJ@RAISESTATE@ DB 'RAISESTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNNEKIOP@FLAGS@
CONST	SEGMENT
??_C@_05MNNEKIOP@FLAGS@ DB 'FLAGS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GFIJOOIK@ACTIVESOUND@
CONST	SEGMENT
??_C@_0M@GFIJOOIK@ACTIVESOUND@ DB 'ACTIVESOUND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNMDCLIH@DAMAGE@
CONST	SEGMENT
??_C@_06GNMDCLIH@DAMAGE@ DB 'DAMAGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFHKDFDM@MASS@
CONST	SEGMENT
??_C@_04EFHKDFDM@MASS@ DB 'MASS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDHALAFO@DISPOFFSET@
CONST	SEGMENT
??_C@_0L@EDHALAFO@DISPOFFSET@ DB 'DISPOFFSET', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJJMJONE@HEIGHT@
CONST	SEGMENT
??_C@_06LJJMJONE@HEIGHT@ DB 'HEIGHT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCFDAKCE@RADIUS@
CONST	SEGMENT
??_C@_06KCFDAKCE@RADIUS@ DB 'RADIUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCLKIGOL@SPEED@
CONST	SEGMENT
??_C@_05LCLKIGOL@SPEED@ DB 'SPEED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENKEHDKL@XDEATHSTATE@
CONST	SEGMENT
??_C@_0M@ENKEHDKL@XDEATHSTATE@ DB 'XDEATHSTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHGAFJGG@DEATHSOUND@
CONST	SEGMENT
??_C@_0L@KHGAFJGG@DEATHSOUND@ DB 'DEATHSOUND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GHIBCINK@DEATHSTATE@
CONST	SEGMENT
??_C@_0L@GHIBCINK@DEATHSTATE@ DB 'DEATHSTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IMDFGKKB@MISSILESTATE@
CONST	SEGMENT
??_C@_0N@IMDFGKKB@MISSILESTATE@ DB 'MISSILESTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMEFKBHN@MELEESTATE@
CONST	SEGMENT
??_C@_0L@DMEFKBHN@MELEESTATE@ DB 'MELEESTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBFLBPN@PAINSOUND@
CONST	SEGMENT
??_C@_09MBFLBPN@PAINSOUND@ DB 'PAINSOUND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEPKKLOB@PAINCHANCE@
CONST	SEGMENT
??_C@_0L@KEPKKLOB@PAINCHANCE@ DB 'PAINCHANCE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMPEMAEB@PAINSTATE@
CONST	SEGMENT
??_C@_09MMPEMAEB@PAINSTATE@ DB 'PAINSTATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DNPINJMI@ATTACKSOUND@
CONST	SEGMENT
??_C@_0M@DNPINJMI@ATTACKSOUND@ DB 'ATTACKSOUND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDGIPNHE@REACTIONTIME@
CONST	SEGMENT
??_C@_0N@BDGIPNHE@REACTIONTIME@ DB 'REACTIONTIME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHBMGACP@SEESOUND@
CONST	SEGMENT
??_C@_08GHBMGACP@SEESOUND@ DB 'SEESOUND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KHPNBBJD@SEESTATE@
CONST	SEGMENT
??_C@_08KHPNBBJD@SEESTATE@ DB 'SEESTATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CDBIIJGK@SPAWNHEALTH@
CONST	SEGMENT
??_C@_0M@CDBIIJGK@SPAWNHEALTH@ DB 'SPAWNHEALTH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MMJEIBOH@SPAWNSTATE@
CONST	SEGMENT
??_C@_0L@MMJEIBOH@SPAWNSTATE@ DB 'SPAWNSTATE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LILCLDJ@MAPTHINGNUM@
CONST	SEGMENT
??_C@_0M@LILCLDJ@MAPTHINGNUM@ DB 'MAPTHINGNUM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DKMGFKIF@readPlayer?5?$CFd?3?5unknown?5word?5?8?$CFs@
CONST	SEGMENT
??_C@_0CB@DKMGFKIF@readPlayer?5?$CFd?3?5unknown?5word?5?8?$CFs@ DB 'readP'
	DB	'layer %d: unknown word ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PDDIGPEM@SKINNAME@
CONST	SEGMENT
??_C@_08PDDIGPEM@SKINNAME@ DB 'SKINNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNKMJCIK@STATUS@
CONST	SEGMENT
??_C@_06DNKMJCIK@STATUS@ DB 'STATUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGIDOHJL@PICNAME@
CONST	SEGMENT
??_C@_07KGIDOHJL@PICNAME@ DB 'PICNAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PPNPBINO@MENUPOSITION@
CONST	SEGMENT
??_C@_0N@PPNPBINO@MENUPOSITION@ DB 'MENUPOSITION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INJCAEDB@PLAYERNAME@
CONST	SEGMENT
??_C@_0L@INJCAEDB@PLAYERNAME@ DB 'PLAYERNAME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GBJEFOMO@PLAYERTEXT@
CONST	SEGMENT
??_C@_0L@GBJEFOMO@PLAYERTEXT@ DB 'PLAYERTEXT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MABBGDAN@No?5value?5found@
CONST	SEGMENT
??_C@_0P@MABBGDAN@No?5value?5found@ DB 'No value found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MFJFLK@Out?5of?5memory?5for?5unsoc?5data@
CONST	SEGMENT
??_C@_0BN@MFJFLK@Out?5of?5memory?5for?5unsoc?5data@ DB 'Out of memory for'
	DB	' unsoc data', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IANMBFDG@Out?5of?5memory?5for?5unsoc?5line@
CONST	SEGMENT
??_C@_0BN@IANMBFDG@Out?5of?5memory?5for?5unsoc?5line@ DB 'Out of memory f'
	DB	'or unsoc line', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHLONNLM@?5?$DN?5@
CONST	SEGMENT
??_C@_03MHLONNLM@?5?$DN?5@ DB ' = ', 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	09f0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	037eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0c91H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05bbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0477H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0214H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01ab4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0bf7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	091bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05f3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	063H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _DEH_LoadDehackedFile
_TEXT	SEGMENT
tv389 = -20872						; size = 4
$T1 = -20868						; size = 4
_ver$2 = -20352						; size = 4
_mod$3 = -20348						; size = 4
_traverse$4 = -20344					; size = 4
_size$5 = -20340					; size = 4
_origpos$6 = -20336					; size = 32
_savesfxnames$ = -20304					; size = 7564
_savesprnames$ = -12740					; size = 1484
_saveactions$ = -11256					; size = 10240
_i$ = -1016						; size = 4
_word2$ = -1012						; size = 4
_word$ = -1008						; size = 4
_s$ = -1004						; size = 1000
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_DEH_LoadDehackedFile PROC				; COMDAT

; 1959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 88 51 00 00	 mov	 eax, 20872		; 00005188H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 1960 : 	XBOXSTATIC char s[1000];
; 1961 : 	char *word;
; 1962 : 	char *word2;
; 1963 : 	INT32 i;
; 1964 : 	// do a copy of this for cross references probleme
; 1965 : 	XBOXSTATIC actionf_t saveactions[NUMSTATES];
; 1966 : 	XBOXSTATIC const char *savesprnames[NUMSPRITES];
; 1967 : 	XBOXSTATIC const char *savesfxnames[NUMSFX];
; 1968 : 
; 1969 : 	deh_num_warning = 0;

  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _deh_num_warning, 0

; 1970 : 	// save values for cross reference
; 1971 : 	for (i = 0; i < NUMSTATES; i++)

  00024	c7 85 08 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0002e	eb 0f		 jmp	 SHORT $LN4@DEH_LoadDe
$LN2@DEH_LoadDe:
  00030	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 85 08 fc ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@DEH_LoadDe:
  0003f	81 bd 08 fc ff
	ff 00 0a 00 00	 cmp	 DWORD PTR _i$[ebp], 2560 ; 00000a00H
  00049	7d 1c		 jge	 SHORT $LN3@DEH_LoadDe

; 1972 : 		saveactions[i] = states[i].action;

  0004b	6b 85 08 fc ff
	ff 1c		 imul	 eax, DWORD PTR _i$[ebp], 28
  00052	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _states[eax+12]
  00058	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0005e	89 8c 95 08 d4
	ff ff		 mov	 DWORD PTR _saveactions$[ebp+edx*4], ecx
  00065	eb c9		 jmp	 SHORT $LN2@DEH_LoadDe
$LN3@DEH_LoadDe:

; 1973 : 	for (i = 0; i < NUMSPRITES; i++)

  00067	c7 85 08 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00071	eb 0f		 jmp	 SHORT $LN7@DEH_LoadDe
$LN5@DEH_LoadDe:
  00073	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 85 08 fc ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN7@DEH_LoadDe:
  00082	81 bd 08 fc ff
	ff 73 01 00 00	 cmp	 DWORD PTR _i$[ebp], 371	; 00000173H
  0008c	7d 1b		 jge	 SHORT $LN6@DEH_LoadDe

; 1974 : 		savesprnames[i] = sprnames[i];

  0008e	6b 85 08 fc ff
	ff 05		 imul	 eax, DWORD PTR _i$[ebp], 5
  00095	05 00 00 00 00	 add	 eax, OFFSET _sprnames
  0009a	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000a0	89 84 8d 3c ce
	ff ff		 mov	 DWORD PTR _savesprnames$[ebp+ecx*4], eax
  000a7	eb ca		 jmp	 SHORT $LN5@DEH_LoadDe
$LN6@DEH_LoadDe:

; 1975 : 	for (i = 0; i < NUMSFX; i++)

  000a9	c7 85 08 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  000b3	eb 0f		 jmp	 SHORT $LN10@DEH_LoadDe
$LN8@DEH_LoadDe:
  000b5	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 85 08 fc ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN10@DEH_LoadDe:
  000c4	81 bd 08 fc ff
	ff 63 07 00 00	 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  000ce	7d 1c		 jge	 SHORT $LN9@DEH_LoadDe

; 1976 : 		savesfxnames[i] = S_sfx[i].name;

  000d0	6b 85 08 fc ff
	ff 2c		 imul	 eax, DWORD PTR _i$[ebp], 44
  000d7	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  000dd	8b 90 00 00 00
	00		 mov	 edx, DWORD PTR _S_sfx[eax]
  000e3	89 94 8d b0 b0
	ff ff		 mov	 DWORD PTR _savesfxnames$[ebp+ecx*4], edx
  000ea	eb c9		 jmp	 SHORT $LN8@DEH_LoadDe
$LN9@DEH_LoadDe:

; 1977 : 
; 1978 : 	// it doesn't test the version of SRB2 and version of dehacked file
; 1979 : 	while (!myfeof(f))

  000ec	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  000f4	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000f7	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  000fa	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000fd	0f 86 76 08 00
	00		 jbe	 $LN12@DEH_LoadDe

; 1980 : 	{
; 1981 : 		XBOXSTATIC char origpos[32];
; 1982 : 		INT32 size = 0;

  00103	c7 85 8c b0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _size$5[ebp], 0

; 1983 : 		char *traverse;
; 1984 : 
; 1985 : 		myfgets(s, sizeof (s), f);

  0010d	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00110	50		 push	 eax
  00111	68 e8 03 00 00	 push	 1000			; 000003e8H
  00116	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0011c	51		 push	 ecx
  0011d	e8 00 00 00 00	 call	 _myfgets
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1986 : 		if (s[0] == '\n' || s[0] == '#')

  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	6b c8 00	 imul	 ecx, eax, 0
  0012d	0f be 94 0d 14
	fc ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00135	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00138	74 15		 je	 SHORT $LN18@DEH_LoadDe
  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	6b c8 00	 imul	 ecx, eax, 0
  00142	0f be 94 0d 14
	fc ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  0014a	83 fa 23	 cmp	 edx, 35			; 00000023H
  0014d	75 02		 jne	 SHORT $LN17@DEH_LoadDe
$LN18@DEH_LoadDe:

; 1987 : 			continue;

  0014f	eb 9b		 jmp	 SHORT $LN9@DEH_LoadDe
$LN17@DEH_LoadDe:

; 1988 : 
; 1989 : 		traverse = s;

  00151	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00157	89 85 88 b0 ff
	ff		 mov	 DWORD PTR _traverse$4[ebp], eax
$LN13@DEH_LoadDe:

; 1990 : 
; 1991 : 		while (traverse[0] != '\n')

  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	6b c8 00	 imul	 ecx, eax, 0
  00165	8b 95 88 b0 ff
	ff		 mov	 edx, DWORD PTR _traverse$4[ebp]
  0016b	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0016f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00172	74 20		 je	 SHORT $LN14@DEH_LoadDe

; 1992 : 		{
; 1993 : 			traverse++;

  00174	8b 85 88 b0 ff
	ff		 mov	 eax, DWORD PTR _traverse$4[ebp]
  0017a	83 c0 01	 add	 eax, 1
  0017d	89 85 88 b0 ff
	ff		 mov	 DWORD PTR _traverse$4[ebp], eax

; 1994 : 			size++;

  00183	8b 85 8c b0 ff
	ff		 mov	 eax, DWORD PTR _size$5[ebp]
  00189	83 c0 01	 add	 eax, 1
  0018c	89 85 8c b0 ff
	ff		 mov	 DWORD PTR _size$5[ebp], eax

; 1995 : 		}

  00192	eb c9		 jmp	 SHORT $LN13@DEH_LoadDe
$LN14@DEH_LoadDe:

; 1996 : 
; 1997 : 		strncpy(origpos, s, size);

  00194	8b 85 8c b0 ff
	ff		 mov	 eax, DWORD PTR _size$5[ebp]
  0019a	50		 push	 eax
  0019b	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  001a1	51		 push	 ecx
  001a2	8d 95 90 b0 ff
	ff		 lea	 edx, DWORD PTR _origpos$6[ebp]
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 _strncpy
  001ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1998 : 		origpos[size] = '\0';

  001b1	8b 85 8c b0 ff
	ff		 mov	 eax, DWORD PTR _size$5[ebp]
  001b7	89 85 7c ae ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  001bd	83 bd 7c ae ff
	ff 20		 cmp	 DWORD PTR $T1[ebp], 32	; 00000020H
  001c4	73 02		 jae	 SHORT $LN75@DEH_LoadDe
  001c6	eb 06		 jmp	 SHORT $LN76@DEH_LoadDe
$LN75@DEH_LoadDe:
  001c8	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  001cd	90		 npad	 1
$LN76@DEH_LoadDe:
  001ce	8b 8d 7c ae ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  001d4	c6 84 0d 90 b0
	ff ff 00	 mov	 BYTE PTR _origpos$6[ebp+ecx], 0

; 1999 : 
; 2000 : 		if (NULL != (word = strtok(s, " ")))

  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  001e1	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 _strtok
  001ed	83 c4 08	 add	 esp, 8
  001f0	89 85 10 fc ff
	ff		 mov	 DWORD PTR _word$[ebp], eax
  001f6	83 bd 10 fc ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  001fd	74 0f		 je	 SHORT $LN19@DEH_LoadDe

; 2001 : 			strupr(word);

  001ff	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _strupr
  0020b	83 c4 04	 add	 esp, 4
$LN19@DEH_LoadDe:

; 2002 : 		if (word)

  0020e	83 bd 10 fc ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  00215	0f 84 38 07 00
	00		 je	 $LN20@DEH_LoadDe

; 2003 : 		{
; 2004 : 			word2 = strtok(NULL, " ");

  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00220	6a 00		 push	 0
  00222	e8 00 00 00 00	 call	 _strtok
  00227	83 c4 08	 add	 esp, 8
  0022a	89 85 0c fc ff
	ff		 mov	 DWORD PTR _word2$[ebp], eax

; 2005 : 			if (word2)

  00230	83 bd 0c fc ff
	ff 00		 cmp	 DWORD PTR _word2$[ebp], 0
  00237	0f 84 f3 06 00
	00		 je	 $LN22@DEH_LoadDe

; 2006 : 			{
; 2007 : 				strupr(word2);

  0023d	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 _strupr
  00249	83 c4 04	 add	 esp, 4

; 2008 : 				i = atoi(word2);

  0024c	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 _atoi
  00258	83 c4 04	 add	 esp, 4
  0025b	89 85 08 fc ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 2009 : 
; 2010 : 				if (!strcmp(word, "THING"))

  00261	68 00 00 00 00	 push	 OFFSET ??_C@_05JCIBGJIK@THING@
  00266	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _strcmp
  00272	83 c4 08	 add	 esp, 8
  00275	85 c0		 test	 eax, eax
  00277	75 68		 jne	 SHORT $LN24@DEH_LoadDe

; 2011 : 				{
; 2012 : 					if (i < NUMMOBJTYPES && i >= 0)

  00279	81 bd 08 fc ff
	ff be 01 00 00	 cmp	 DWORD PTR _i$[ebp], 446	; 000001beH
  00283	7d 1e		 jge	 SHORT $LN26@DEH_LoadDe
  00285	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  0028c	7c 15		 jl	 SHORT $LN26@DEH_LoadDe

; 2013 : 						readthing(f, i);

  0028e	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00294	50		 push	 eax
  00295	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  00298	51		 push	 ecx
  00299	e8 00 00 00 00	 call	 _readthing
  0029e	83 c4 08	 add	 esp, 8
  002a1	eb 21		 jmp	 SHORT $LN27@DEH_LoadDe
$LN26@DEH_LoadDe:

; 2014 : 					else
; 2015 : 						deh_warning(text[THING_NOTEXIST], i);

  002a3	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  002a9	50		 push	 eax
  002aa	b9 04 00 00 00	 mov	 ecx, 4
  002af	69 d1 d0 00 00
	00		 imul	 edx, ecx, 208
  002b5	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 _deh_warning
  002c1	83 c4 08	 add	 esp, 8
$LN27@DEH_LoadDe:

; 2016 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  002c4	6a 07		 push	 7
  002c6	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  002cc	50		 push	 eax
  002cd	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  002d3	51		 push	 ecx
  002d4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  002d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2017 : 				}

  002dc	e9 4d 06 00 00	 jmp	 $LN70@DEH_LoadDe
$LN24@DEH_LoadDe:

; 2018 : 				else if (!strcmp(word, "MODBY"))

  002e1	68 00 00 00 00	 push	 OFFSET ??_C@_05CLEJPIKP@MODBY@
  002e6	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 _strcmp
  002f2	83 c4 08	 add	 esp, 8
  002f5	85 c0		 test	 eax, eax
  002f7	0f 85 b0 00 00
	00		 jne	 $LN28@DEH_LoadDe

; 2019 : 				{
; 2020 : 					const INT32 mod = 18;

  002fd	c7 85 84 b0 ff
	ff 12 00 00 00	 mov	 DWORD PTR _mod$3[ebp], 18 ; 00000012H

; 2021 : 					strcpy(credits[mod].fakenames[0], origpos+6);

  00307	8d 85 96 b0 ff
	ff		 lea	 eax, DWORD PTR _origpos$6[ebp+6]
  0030d	50		 push	 eax
  0030e	69 8d 84 b0 ff
	ff 22 08 00 00	 imul	 ecx, DWORD PTR _mod$3[ebp], 2082
  00318	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0031d	6b c2 00	 imul	 eax, edx, 0
  00320	8d 8c 01 22 00
	00 00		 lea	 ecx, DWORD PTR _credits[ecx+eax+34]
  00327	51		 push	 ecx
  00328	e8 00 00 00 00	 call	 _strcpy
  0032d	83 c4 08	 add	 esp, 8

; 2022 : 					strcpy(credits[mod].realnames[0], origpos+6);

  00330	8d 85 96 b0 ff
	ff		 lea	 eax, DWORD PTR _origpos$6[ebp+6]
  00336	50		 push	 eax
  00337	69 8d 84 b0 ff
	ff 22 08 00 00	 imul	 ecx, DWORD PTR _mod$3[ebp], 2082
  00341	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00346	6b c2 00	 imul	 eax, edx, 0
  00349	8d 8c 01 22 04
	00 00		 lea	 ecx, DWORD PTR _credits[ecx+eax+1058]
  00350	51		 push	 ecx
  00351	e8 00 00 00 00	 call	 _strcpy
  00356	83 c4 08	 add	 esp, 8

; 2023 : 					credits[mod].numnames = 1;

  00359	69 85 84 b0 ff
	ff 22 08 00 00	 imul	 eax, DWORD PTR _mod$3[ebp], 2082
  00363	c6 80 20 00 00
	00 01		 mov	 BYTE PTR _credits[eax+32], 1

; 2024 : 					strcpy(&credits[mod].header[0], text[MOD_BY]);

  0036a	b8 04 00 00 00	 mov	 eax, 4
  0036f	69 c8 d1 00 00
	00		 imul	 ecx, eax, 209
  00375	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  0037b	52		 push	 edx
  0037c	69 85 84 b0 ff
	ff 22 08 00 00	 imul	 eax, DWORD PTR _mod$3[ebp], 2082
  00386	b9 01 00 00 00	 mov	 ecx, 1
  0038b	6b d1 00	 imul	 edx, ecx, 0
  0038e	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR _credits[eax+edx]
  00395	50		 push	 eax
  00396	e8 00 00 00 00	 call	 _strcpy
  0039b	83 c4 08	 add	 esp, 8

; 2025 : 					modcredits = true;

  0039e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _modcredits, 1

; 2026 : 				}

  003a8	e9 81 05 00 00	 jmp	 $LN70@DEH_LoadDe
$LN28@DEH_LoadDe:

; 2027 : /*				else if (!strcmp(word, "ANIMTEX"))
; 2028 : 				{
; 2029 : 					readAnimTex(f, i);
; 2030 : 				}*/
; 2031 : 				else if (!strcmp(word, "CHARACTER"))

  003ad	68 00 00 00 00	 push	 OFFSET ??_C@_09DMCLKDIA@CHARACTER@
  003b2	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003b8	50		 push	 eax
  003b9	e8 00 00 00 00	 call	 _strcmp
  003be	83 c4 08	 add	 esp, 8
  003c1	85 c0		 test	 eax, eax
  003c3	75 5c		 jne	 SHORT $LN30@DEH_LoadDe

; 2032 : 				{
; 2033 : 					if (i < 15)

  003c5	83 bd 08 fc ff
	ff 0f		 cmp	 DWORD PTR _i$[ebp], 15	; 0000000fH
  003cc	7d 15		 jge	 SHORT $LN32@DEH_LoadDe

; 2034 : 						readPlayer(f, i);

  003ce	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  003d4	50		 push	 eax
  003d5	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  003d8	51		 push	 ecx
  003d9	e8 00 00 00 00	 call	 _readPlayer
  003de	83 c4 08	 add	 esp, 8
  003e1	eb 21		 jmp	 SHORT $LN33@DEH_LoadDe
$LN32@DEH_LoadDe:

; 2035 : 					else
; 2036 : 						deh_warning(text[CHAR_OUTOFRANGE], i);

  003e3	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  003e9	50		 push	 eax
  003ea	b9 04 00 00 00	 mov	 ecx, 4
  003ef	69 d1 d2 00 00
	00		 imul	 edx, ecx, 210
  003f5	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 _deh_warning
  00401	83 c4 08	 add	 esp, 8
$LN33@DEH_LoadDe:

; 2037 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  00404	6a 07		 push	 7
  00406	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0040c	50		 push	 eax
  0040d	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00413	51		 push	 ecx
  00414	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00419	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2038 : 				}

  0041c	e9 0d 05 00 00	 jmp	 $LN70@DEH_LoadDe
$LN30@DEH_LoadDe:

; 2039 : 				else if (!strcmp(word, "LIGHT"))

  00421	68 00 00 00 00	 push	 OFFSET ??_C@_05MFNJIKNP@LIGHT@
  00426	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 _strcmp
  00432	83 c4 08	 add	 esp, 8
  00435	85 c0		 test	 eax, eax
  00437	75 05		 jne	 SHORT $LN34@DEH_LoadDe

; 2040 : 				{
; 2041 : 				}

  00439	e9 f0 04 00 00	 jmp	 $LN70@DEH_LoadDe
$LN34@DEH_LoadDe:

; 2042 : 				else if (!strcmp(word, "SPRITE"))

  0043e	68 00 00 00 00	 push	 OFFSET ??_C@_06DOFEGNGM@SPRITE@
  00443	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 _strcmp
  0044f	83 c4 08	 add	 esp, 8
  00452	85 c0		 test	 eax, eax
  00454	75 05		 jne	 SHORT $LN36@DEH_LoadDe

; 2043 : 				{
; 2044 : 				}

  00456	e9 d3 04 00 00	 jmp	 $LN70@DEH_LoadDe
$LN36@DEH_LoadDe:

; 2045 : 				else if (!strcmp(word, "LEVEL"))

  0045b	68 00 00 00 00	 push	 OFFSET ??_C@_05GCEPFMCO@LEVEL@
  00460	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00466	50		 push	 eax
  00467	e8 00 00 00 00	 call	 _strcmp
  0046c	83 c4 08	 add	 esp, 8
  0046f	85 c0		 test	 eax, eax
  00471	0f 85 ca 00 00
	00		 jne	 $LN38@DEH_LoadDe

; 2046 : 				{
; 2047 : 					// Support using the actual map name,
; 2048 : 					// i.e., Level AB, Level FZ, etc.
; 2049 : 
; 2050 : 					// Convert to map number
; 2051 : 					if (word2[0] >= 'A' && word2[0] <= 'Z')

  00477	b8 01 00 00 00	 mov	 eax, 1
  0047c	6b c8 00	 imul	 ecx, eax, 0
  0047f	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00485	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00489	83 f8 41	 cmp	 eax, 65			; 00000041H
  0048c	7c 4b		 jl	 SHORT $LN40@DEH_LoadDe
  0048e	b8 01 00 00 00	 mov	 eax, 1
  00493	6b c8 00	 imul	 ecx, eax, 0
  00496	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  0049c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  004a0	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  004a3	7f 34		 jg	 SHORT $LN40@DEH_LoadDe

; 2052 : 						i = M_MapNumber(word2[0], word2[1]);

  004a5	b8 01 00 00 00	 mov	 eax, 1
  004aa	c1 e0 00	 shl	 eax, 0
  004ad	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  004b3	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004b7	52		 push	 edx
  004b8	b8 01 00 00 00	 mov	 eax, 1
  004bd	6b c8 00	 imul	 ecx, eax, 0
  004c0	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  004c6	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  004ca	50		 push	 eax
  004cb	e8 00 00 00 00	 call	 _M_MapNumber
  004d0	83 c4 08	 add	 esp, 8
  004d3	89 85 08 fc ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN40@DEH_LoadDe:

; 2053 : 
; 2054 : 					if (i > 0 && i <= NUMMAPS)

  004d9	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  004e0	7e 21		 jle	 SHORT $LN41@DEH_LoadDe
  004e2	81 bd 08 fc ff
	ff 0b 04 00 00	 cmp	 DWORD PTR _i$[ebp], 1035 ; 0000040bH
  004ec	7f 15		 jg	 SHORT $LN41@DEH_LoadDe

; 2055 : 						readlevelheader(f, i);

  004ee	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  004f4	50		 push	 eax
  004f5	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  004f8	51		 push	 ecx
  004f9	e8 00 00 00 00	 call	 _readlevelheader
  004fe	83 c4 08	 add	 esp, 8
  00501	eb 21		 jmp	 SHORT $LN42@DEH_LoadDe
$LN41@DEH_LoadDe:

; 2056 : 					else
; 2057 : 						deh_warning(text[LEVEL_OUTOFRANGE], i);

  00503	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00509	50		 push	 eax
  0050a	b9 04 00 00 00	 mov	 ecx, 4
  0050f	69 d1 d3 00 00
	00		 imul	 edx, ecx, 211
  00515	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 _deh_warning
  00521	83 c4 08	 add	 esp, 8
$LN42@DEH_LoadDe:

; 2058 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  00524	6a 07		 push	 7
  00526	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0052c	50		 push	 eax
  0052d	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00533	51		 push	 ecx
  00534	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00539	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2059 : 				}

  0053c	e9 ed 03 00 00	 jmp	 $LN70@DEH_LoadDe
$LN38@DEH_LoadDe:

; 2060 : 				else if (!strcmp(word, "CUTSCENE"))

  00541	68 00 00 00 00	 push	 OFFSET ??_C@_08PKDMAPNA@CUTSCENE@
  00546	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0054c	50		 push	 eax
  0054d	e8 00 00 00 00	 call	 _strcmp
  00552	83 c4 08	 add	 esp, 8
  00555	85 c0		 test	 eax, eax
  00557	75 6b		 jne	 SHORT $LN43@DEH_LoadDe

; 2061 : 				{
; 2062 : 					if (i > 0 && i < 129)

  00559	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  00560	7e 24		 jle	 SHORT $LN45@DEH_LoadDe
  00562	81 bd 08 fc ff
	ff 81 00 00 00	 cmp	 DWORD PTR _i$[ebp], 129	; 00000081H
  0056c	7d 18		 jge	 SHORT $LN45@DEH_LoadDe

; 2063 : 						readcutscene(f, i - 1);

  0056e	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00574	83 e8 01	 sub	 eax, 1
  00577	50		 push	 eax
  00578	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0057b	51		 push	 ecx
  0057c	e8 00 00 00 00	 call	 _readcutscene
  00581	83 c4 08	 add	 esp, 8
  00584	eb 21		 jmp	 SHORT $LN46@DEH_LoadDe
$LN45@DEH_LoadDe:

; 2064 : 					else
; 2065 : 						deh_warning(text[CUTSCENE_OUTOFRANGE], i);

  00586	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0058c	50		 push	 eax
  0058d	b9 04 00 00 00	 mov	 ecx, 4
  00592	69 d1 d4 00 00
	00		 imul	 edx, ecx, 212
  00598	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0059e	50		 push	 eax
  0059f	e8 00 00 00 00	 call	 _deh_warning
  005a4	83 c4 08	 add	 esp, 8
$LN46@DEH_LoadDe:

; 2066 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  005a7	6a 07		 push	 7
  005a9	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  005af	50		 push	 eax
  005b0	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  005b6	51		 push	 ecx
  005b7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2067 : 				}

  005bf	e9 6a 03 00 00	 jmp	 $LN70@DEH_LoadDe
$LN43@DEH_LoadDe:

; 2068 : 				else if (!strcmp(word, "UNLOCKABLE"))

  005c4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GFIFJDNE@UNLOCKABLE@
  005c9	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 _strcmp
  005d5	83 c4 08	 add	 esp, 8
  005d8	85 c0		 test	 eax, eax
  005da	75 68		 jne	 SHORT $LN47@DEH_LoadDe

; 2069 : 				{
; 2070 : 					if (i > 0 && i < 16)

  005dc	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  005e3	7e 21		 jle	 SHORT $LN49@DEH_LoadDe
  005e5	83 bd 08 fc ff
	ff 10		 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  005ec	7d 18		 jge	 SHORT $LN49@DEH_LoadDe

; 2071 : 						readunlockable(f, i - 1);

  005ee	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  005f4	83 e8 01	 sub	 eax, 1
  005f7	50		 push	 eax
  005f8	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  005fb	51		 push	 ecx
  005fc	e8 00 00 00 00	 call	 _readunlockable
  00601	83 c4 08	 add	 esp, 8
  00604	eb 21		 jmp	 SHORT $LN50@DEH_LoadDe
$LN49@DEH_LoadDe:

; 2072 : 					else
; 2073 : 						deh_warning(text[UNLOCKABLE_OUTOFRANGE], i);

  00606	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0060c	50		 push	 eax
  0060d	b9 04 00 00 00	 mov	 ecx, 4
  00612	69 d1 d5 00 00
	00		 imul	 edx, ecx, 213
  00618	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0061e	50		 push	 eax
  0061f	e8 00 00 00 00	 call	 _deh_warning
  00624	83 c4 08	 add	 esp, 8
$LN50@DEH_LoadDe:

; 2074 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  00627	6a 07		 push	 7
  00629	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0062f	50		 push	 eax
  00630	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00636	51		 push	 ecx
  00637	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0063c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2075 : 				}

  0063f	e9 ea 02 00 00	 jmp	 $LN70@DEH_LoadDe
$LN47@DEH_LoadDe:

; 2076 : 				else if (!strcmp(word, "FRAME"))

  00644	68 00 00 00 00	 push	 OFFSET ??_C@_05DALLBAN@FRAME@
  00649	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0064f	50		 push	 eax
  00650	e8 00 00 00 00	 call	 _strcmp
  00655	83 c4 08	 add	 esp, 8
  00658	85 c0		 test	 eax, eax
  0065a	75 68		 jne	 SHORT $LN51@DEH_LoadDe

; 2077 : 				{
; 2078 : 					if (i < NUMSTATES && i >= 0)

  0065c	81 bd 08 fc ff
	ff 00 0a 00 00	 cmp	 DWORD PTR _i$[ebp], 2560 ; 00000a00H
  00666	7d 1e		 jge	 SHORT $LN53@DEH_LoadDe
  00668	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  0066f	7c 15		 jl	 SHORT $LN53@DEH_LoadDe

; 2079 : 						readframe(f, i);

  00671	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00677	50		 push	 eax
  00678	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0067b	51		 push	 ecx
  0067c	e8 00 00 00 00	 call	 _readframe
  00681	83 c4 08	 add	 esp, 8
  00684	eb 21		 jmp	 SHORT $LN54@DEH_LoadDe
$LN53@DEH_LoadDe:

; 2080 : 					else
; 2081 : 						deh_warning(text[FRAME_NOTEXIST], i);

  00686	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0068c	50		 push	 eax
  0068d	b9 04 00 00 00	 mov	 ecx, 4
  00692	69 d1 d6 00 00
	00		 imul	 edx, ecx, 214
  00698	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0069e	50		 push	 eax
  0069f	e8 00 00 00 00	 call	 _deh_warning
  006a4	83 c4 08	 add	 esp, 8
$LN54@DEH_LoadDe:

; 2082 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  006a7	6a 07		 push	 7
  006a9	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  006af	50		 push	 eax
  006b0	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  006b6	51		 push	 ecx
  006b7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  006bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2083 : 				}

  006bf	e9 6a 02 00 00	 jmp	 $LN70@DEH_LoadDe
$LN51@DEH_LoadDe:

; 2084 : /*				else if (!strcmp(word, "POINTER"))
; 2085 : 				{
; 2086 : 					word = strtok(NULL, " "); // get frame
; 2087 : 					word = strtok(NULL, ")");
; 2088 : 					if (word)
; 2089 : 					{
; 2090 : 						i = atoi(word);
; 2091 : 						if (i < NUMSTATES && i >= 0)
; 2092 : 						{
; 2093 : 							if (myfgets(s, sizeof (s), f))
; 2094 : 								states[i].action = saveactions[searchvalue(s)];
; 2095 : 						}
; 2096 : 						else
; 2097 : 							deh_warning("Pointer: Frame %d doesn't exist", i);
; 2098 : 					}
; 2099 : 					else
; 2100 : 						deh_warning("pointer (Frame %d) : missing ')'", i);
; 2101 : 				}*/
; 2102 : 				else if (!strcmp(word, "SOUND"))

  006c4	68 00 00 00 00	 push	 OFFSET ??_C@_05MEGDOMG@SOUND@
  006c9	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006cf	50		 push	 eax
  006d0	e8 00 00 00 00	 call	 _strcmp
  006d5	83 c4 08	 add	 esp, 8
  006d8	85 c0		 test	 eax, eax
  006da	75 6f		 jne	 SHORT $LN55@DEH_LoadDe

; 2103 : 				{
; 2104 : 					if (i < NUMSFX && i >= 0)

  006dc	81 bd 08 fc ff
	ff 63 07 00 00	 cmp	 DWORD PTR _i$[ebp], 1891 ; 00000763H
  006e6	7d 25		 jge	 SHORT $LN57@DEH_LoadDe
  006e8	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  006ef	7c 1c		 jl	 SHORT $LN57@DEH_LoadDe

; 2105 : 						readsound(f, i, savesfxnames);

  006f1	8d 85 b0 b0 ff
	ff		 lea	 eax, DWORD PTR _savesfxnames$[ebp]
  006f7	50		 push	 eax
  006f8	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006fe	51		 push	 ecx
  006ff	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00702	52		 push	 edx
  00703	e8 00 00 00 00	 call	 _readsound
  00708	83 c4 0c	 add	 esp, 12			; 0000000cH
  0070b	eb 21		 jmp	 SHORT $LN58@DEH_LoadDe
$LN57@DEH_LoadDe:

; 2106 : 					else
; 2107 : 						deh_warning(text[SOUND_NOTEXIST], i);

  0070d	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00713	50		 push	 eax
  00714	b9 04 00 00 00	 mov	 ecx, 4
  00719	69 d1 d7 00 00
	00		 imul	 edx, ecx, 215
  0071f	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  00725	50		 push	 eax
  00726	e8 00 00 00 00	 call	 _deh_warning
  0072b	83 c4 08	 add	 esp, 8
$LN58@DEH_LoadDe:

; 2108 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  0072e	6a 07		 push	 7
  00730	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00736	50		 push	 eax
  00737	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0073d	51		 push	 ecx
  0073e	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00743	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2109 : 				}

  00746	e9 e3 01 00 00	 jmp	 $LN70@DEH_LoadDe
$LN55@DEH_LoadDe:

; 2110 : /*				else if (!strcmp(word, "SPRITE"))
; 2111 : 				{
; 2112 : 					if (i < NUMSPRITES && i >= 0)
; 2113 : 					{
; 2114 : 						if (myfgets(s, sizeof (s), f))
; 2115 : 						{
; 2116 : 							INT32 k;
; 2117 : 							k = (searchvalue(s) - 151328)/8;
; 2118 : 							if (k >= 0 && k < NUMSPRITES)
; 2119 : 								sprnames[i] = savesprnames[k];
; 2120 : 							else
; 2121 : 								deh_warning("Sprite %d: offset out of bound", i);
; 2122 : 						}
; 2123 : 					}
; 2124 : 					else
; 2125 : 						deh_warning("Sprite %d doesn't exist",i);
; 2126 : 				}*/
; 2127 : 				else if (!strcmp(word, "HUDITEM"))

  0074b	68 00 00 00 00	 push	 OFFSET ??_C@_07KHILKLAK@HUDITEM@
  00750	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00756	50		 push	 eax
  00757	e8 00 00 00 00	 call	 _strcmp
  0075c	83 c4 08	 add	 esp, 8
  0075f	85 c0		 test	 eax, eax
  00761	75 65		 jne	 SHORT $LN59@DEH_LoadDe

; 2128 : 				{
; 2129 : 					if (i >= 0 && i < NUMHUDITEMS)

  00763	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  0076a	7c 1e		 jl	 SHORT $LN61@DEH_LoadDe
  0076c	83 bd 08 fc ff
	ff 23		 cmp	 DWORD PTR _i$[ebp], 35	; 00000023H
  00773	7d 15		 jge	 SHORT $LN61@DEH_LoadDe

; 2130 : 						readhuditem(f, i);

  00775	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0077b	50		 push	 eax
  0077c	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  0077f	51		 push	 ecx
  00780	e8 00 00 00 00	 call	 _readhuditem
  00785	83 c4 08	 add	 esp, 8
  00788	eb 21		 jmp	 SHORT $LN62@DEH_LoadDe
$LN61@DEH_LoadDe:

; 2131 : 					else
; 2132 : 						deh_warning(text[HUDITEM_OUTOFRANGE], i);

  0078a	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00790	50		 push	 eax
  00791	b9 04 00 00 00	 mov	 ecx, 4
  00796	69 d1 d8 00 00
	00		 imul	 edx, ecx, 216
  0079c	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  007a2	50		 push	 eax
  007a3	e8 00 00 00 00	 call	 _deh_warning
  007a8	83 c4 08	 add	 esp, 8
$LN62@DEH_LoadDe:

; 2133 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  007ab	6a 07		 push	 7
  007ad	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  007b3	50		 push	 eax
  007b4	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  007ba	51		 push	 ecx
  007bb	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  007c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2134 : 				}

  007c3	e9 66 01 00 00	 jmp	 $LN70@DEH_LoadDe
$LN59@DEH_LoadDe:

; 2135 : 				else if (!strcmp(word, "EMBLEM"))

  007c8	68 00 00 00 00	 push	 OFFSET ??_C@_06HBBPBCC@EMBLEM@
  007cd	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  007d3	50		 push	 eax
  007d4	e8 00 00 00 00	 call	 _strcmp
  007d9	83 c4 08	 add	 esp, 8
  007dc	85 c0		 test	 eax, eax
  007de	75 68		 jne	 SHORT $LN63@DEH_LoadDe

; 2136 : 				{
; 2137 : 					if (i > 0 && i <= MAXEMBLEMS)

  007e0	83 bd 08 fc ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  007e7	7e 21		 jle	 SHORT $LN65@DEH_LoadDe
  007e9	81 bd 08 fc ff
	ff 00 02 00 00	 cmp	 DWORD PTR _i$[ebp], 512	; 00000200H
  007f3	7f 15		 jg	 SHORT $LN65@DEH_LoadDe

; 2138 : 						reademblemdata(f, i);

  007f5	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  007fb	50		 push	 eax
  007fc	8b 4d 08	 mov	 ecx, DWORD PTR _f$[ebp]
  007ff	51		 push	 ecx
  00800	e8 00 00 00 00	 call	 _reademblemdata
  00805	83 c4 08	 add	 esp, 8
  00808	eb 21		 jmp	 SHORT $LN66@DEH_LoadDe
$LN65@DEH_LoadDe:

; 2139 : 					else
; 2140 : 						deh_warning(text[EMBLEM_OUTOFRANGE], i);

  0080a	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00810	50		 push	 eax
  00811	b9 04 00 00 00	 mov	 ecx, 4
  00816	69 d1 d9 00 00
	00		 imul	 edx, ecx, 217
  0081c	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  00822	50		 push	 eax
  00823	e8 00 00 00 00	 call	 _deh_warning
  00828	83 c4 08	 add	 esp, 8
$LN66@DEH_LoadDe:

; 2141 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  0082b	6a 07		 push	 7
  0082d	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00833	50		 push	 eax
  00834	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0083a	51		 push	 ecx
  0083b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00840	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2142 : 				}

  00843	e9 e6 00 00 00	 jmp	 $LN70@DEH_LoadDe
$LN63@DEH_LoadDe:

; 2143 : 				else if (!strcmp(word, "MAINCFG"))

  00848	68 00 00 00 00	 push	 OFFSET ??_C@_07EHCDOLII@MAINCFG@
  0084d	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00853	50		 push	 eax
  00854	e8 00 00 00 00	 call	 _strcmp
  00859	83 c4 08	 add	 esp, 8
  0085c	85 c0		 test	 eax, eax
  0085e	75 29		 jne	 SHORT $LN67@DEH_LoadDe

; 2144 : 				{
; 2145 : 					readmaincfg(f);

  00860	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00863	50		 push	 eax
  00864	e8 00 00 00 00	 call	 _readmaincfg
  00869	83 c4 04	 add	 esp, 4

; 2146 : 					DEH_WriteUndoline(word, word2, UNDO_HEADER);

  0086c	6a 07		 push	 7
  0086e	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00874	50		 push	 eax
  00875	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0087b	51		 push	 ecx
  0087c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00881	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2147 : 				}

  00884	e9 a5 00 00 00	 jmp	 $LN70@DEH_LoadDe
$LN67@DEH_LoadDe:

; 2148 : 				else if (!strcmp(word, "SRB2"))

  00889	68 00 00 00 00	 push	 OFFSET ??_C@_04LJAEHHAP@SRB2@
  0088e	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00894	50		 push	 eax
  00895	e8 00 00 00 00	 call	 _strcmp
  0089a	83 c4 08	 add	 esp, 8
  0089d	85 c0		 test	 eax, eax
  0089f	75 6c		 jne	 SHORT $LN69@DEH_LoadDe

; 2149 : 				{
; 2150 : 					INT32 ver = searchvalue(strtok(NULL, "\n"));

  008a1	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  008a6	6a 00		 push	 0
  008a8	e8 00 00 00 00	 call	 _strtok
  008ad	83 c4 08	 add	 esp, 8
  008b0	50		 push	 eax
  008b1	e8 00 00 00 00	 call	 _searchvalue
  008b6	83 c4 04	 add	 esp, 4
  008b9	89 85 80 b0 ff
	ff		 mov	 DWORD PTR _ver$2[ebp], eax

; 2151 : 					if (ver != 200)

  008bf	81 bd 80 b0 ff
	ff c8 00 00 00	 cmp	 DWORD PTR _ver$2[ebp], 200 ; 000000c8H
  008c9	74 40		 je	 SHORT $LN71@DEH_LoadDe

; 2152 : 					{
; 2153 : 						deh_warning(text[WRONG_VERSION_WARNING], ver);

  008cb	8b 85 80 b0 ff
	ff		 mov	 eax, DWORD PTR _ver$2[ebp]
  008d1	50		 push	 eax
  008d2	b9 04 00 00 00	 mov	 ecx, 4
  008d7	69 d1 da 00 00
	00		 imul	 edx, ecx, 218
  008dd	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  008e3	50		 push	 eax
  008e4	e8 00 00 00 00	 call	 _deh_warning
  008e9	83 c4 08	 add	 esp, 8

; 2154 : 						deh_warning("%s", text[SUPPORTED_VERSION]);

  008ec	b8 04 00 00 00	 mov	 eax, 4
  008f1	69 c8 db 00 00
	00		 imul	 ecx, eax, 219
  008f7	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  008fd	52		 push	 edx
  008fe	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00903	e8 00 00 00 00	 call	 _deh_warning
  00908	83 c4 08	 add	 esp, 8
$LN71@DEH_LoadDe:

; 2155 : 					}
; 2156 : 					//DEH_WriteUndoline(word, va("%d", ver), UNDO_NONE);
; 2157 : 				}

  0090b	eb 21		 jmp	 SHORT $LN70@DEH_LoadDe
$LN69@DEH_LoadDe:

; 2158 : 				else
; 2159 : 					deh_warning(text[UNKNOWN_WORD], word);

  0090d	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00913	50		 push	 eax
  00914	b9 04 00 00 00	 mov	 ecx, 4
  00919	69 d1 dc 00 00
	00		 imul	 edx, ecx, 220
  0091f	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  00925	50		 push	 eax
  00926	e8 00 00 00 00	 call	 _deh_warning
  0092b	83 c4 08	 add	 esp, 8
$LN70@DEH_LoadDe:

; 2160 : 			}

  0092e	eb 21		 jmp	 SHORT $LN23@DEH_LoadDe
$LN22@DEH_LoadDe:

; 2161 : 			else
; 2162 : 				deh_warning(text[MISSING_ARGUMENT], word);

  00930	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00936	50		 push	 eax
  00937	b9 04 00 00 00	 mov	 ecx, 4
  0093c	69 d1 dd 00 00
	00		 imul	 edx, ecx, 221
  00942	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  00948	50		 push	 eax
  00949	e8 00 00 00 00	 call	 _deh_warning
  0094e	83 c4 08	 add	 esp, 8
$LN23@DEH_LoadDe:

; 2163 : 		}

  00951	eb 21		 jmp	 SHORT $LN21@DEH_LoadDe
$LN20@DEH_LoadDe:

; 2164 : 		else
; 2165 : 			deh_warning(text[MISSING_WORD], s);

  00953	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00959	50		 push	 eax
  0095a	b9 04 00 00 00	 mov	 ecx, 4
  0095f	69 d1 de 00 00
	00		 imul	 edx, ecx, 222
  00965	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0096b	50		 push	 eax
  0096c	e8 00 00 00 00	 call	 _deh_warning
  00971	83 c4 08	 add	 esp, 8
$LN21@DEH_LoadDe:

; 2166 : 	} // end while

  00974	e9 73 f7 ff ff	 jmp	 $LN9@DEH_LoadDe
$LN12@DEH_LoadDe:

; 2167 : 	if (deh_num_warning)

  00979	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _deh_num_warning, 0
  00980	74 61		 je	 SHORT $LN16@DEH_LoadDe

; 2168 : 	{
; 2169 : 		CONS_Printf(text[WARNING_IN_SOC_LUMP], deh_num_warning,

  00982	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _deh_num_warning, 1
  00989	75 0c		 jne	 SHORT $LN77@DEH_LoadDe
  0098b	c7 85 78 ae ff
	ff 00 00 00 00	 mov	 DWORD PTR tv389[ebp], OFFSET ??_C@_00CNPNBAHC@@
  00995	eb 0a		 jmp	 SHORT $LN78@DEH_LoadDe
$LN77@DEH_LoadDe:
  00997	c7 85 78 ae ff
	ff 00 00 00 00	 mov	 DWORD PTR tv389[ebp], OFFSET ??_C@_01LKDEMHDF@s@
$LN78@DEH_LoadDe:
  009a1	8b 85 78 ae ff
	ff		 mov	 eax, DWORD PTR tv389[ebp]
  009a7	50		 push	 eax
  009a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _deh_num_warning
  009ae	51		 push	 ecx
  009af	ba 04 00 00 00	 mov	 edx, 4
  009b4	69 c2 df 00 00
	00		 imul	 eax, edx, 223
  009ba	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _text[eax]
  009c0	51		 push	 ecx
  009c1	e8 00 00 00 00	 call	 _CONS_Printf
  009c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2170 : 			deh_num_warning == 1 ? "" : "s");
; 2171 : 		if (devparm)

  009c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  009d0	74 11		 je	 SHORT $LN16@DEH_LoadDe
$LN15@DEH_LoadDe:

; 2172 : 			while (!I_GetKey())

  009d2	e8 00 00 00 00	 call	 _I_GetKey
  009d7	85 c0		 test	 eax, eax
  009d9	75 08		 jne	 SHORT $LN16@DEH_LoadDe

; 2173 : 				I_OsPolling();

  009db	e8 00 00 00 00	 call	 _I_OsPolling
  009e0	90		 npad	 1
  009e1	eb ef		 jmp	 SHORT $LN15@DEH_LoadDe
$LN16@DEH_LoadDe:

; 2174 : 	}
; 2175 : 
; 2176 : 	deh_loaded = true;

  009e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _deh_loaded, 1
$LN1@DEH_LoadDe:

; 2177 : }

  009ed	5f		 pop	 edi
  009ee	5e		 pop	 esi
  009ef	5b		 pop	 ebx
  009f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009f3	33 cd		 xor	 ecx, ebp
  009f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009fa	8b e5		 mov	 esp, ebp
  009fc	5d		 pop	 ebp
  009fd	c3		 ret	 0
_DEH_LoadDehackedFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _reademblemdata
_TEXT	SEGMENT
_value$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_reademblemdata PROC					; COMDAT

; 1889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
$LN4@reademblem:

; 1890 : 	XBOXSTATIC char s[MAXLINELEN];
; 1891 : 	char *word;
; 1892 : 	char *word2;
; 1893 : 	char *tmp;
; 1894 : 	INT32 value;
; 1895 : 
; 1896 : 	do
; 1897 : 	{
; 1898 : 		if (myfgets(s, sizeof (s), f))

  00016	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00019	50		 push	 eax
  0001a	68 00 04 00 00	 push	 1024			; 00000400H
  0001f	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _myfgets
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 2e 03 00
	00		 je	 $LN21@reademblem

; 1899 : 		{
; 1900 : 			if (s[0] == '\n')

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	6b c8 00	 imul	 ecx, eax, 0
  0003e	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00046	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00049	75 05		 jne	 SHORT $LN6@reademblem

; 1901 : 				break;

  0004b	e9 2b 03 00 00	 jmp	 $LN3@reademblem
$LN6@reademblem:

; 1902 : 
; 1903 : 			tmp = strchr(s, '#');

  00050	6a 23		 push	 35			; 00000023H
  00052	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _strchr
  0005e	83 c4 08	 add	 esp, 8
  00061	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1904 : 			if (tmp)

  00067	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  0006e	74 09		 je	 SHORT $LN7@reademblem

; 1905 : 				*tmp = '\0';

  00070	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00076	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@reademblem:

; 1906 : 
; 1907 : 			value = searchvalue(s);

  00079	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _searchvalue
  00085	83 c4 04	 add	 esp, 4
  00088	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax

; 1908 : 			word = strtok(s, " ");

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00093	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _strtok
  0009f	83 c4 08	 add	 esp, 8
  000a2	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 1909 : 			if (word)

  000a8	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  000af	74 11		 je	 SHORT $LN8@reademblem

; 1910 : 				strupr(word);

  000b1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _strupr
  000bd	83 c4 04	 add	 esp, 4
  000c0	eb 05		 jmp	 SHORT $LN9@reademblem
$LN8@reademblem:

; 1911 : 			else
; 1912 : 				break;

  000c2	e9 b4 02 00 00	 jmp	 $LN3@reademblem
$LN9@reademblem:

; 1913 : 
; 1914 : 			word2 = strtok(NULL, " ");

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  000cc	6a 00		 push	 0
  000ce	e8 00 00 00 00	 call	 _strtok
  000d3	83 c4 08	 add	 esp, 8
  000d6	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], eax

; 1915 : 			if (word2)

  000dc	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _word2$[ebp], 0
  000e3	74 11		 je	 SHORT $LN10@reademblem

; 1916 : 				strupr(word2);

  000e5	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _strupr
  000f1	83 c4 04	 add	 esp, 4
  000f4	eb 05		 jmp	 SHORT $LN11@reademblem
$LN10@reademblem:

; 1917 : 			else
; 1918 : 				break;

  000f6	e9 80 02 00 00	 jmp	 $LN3@reademblem
$LN11@reademblem:

; 1919 : 
; 1920 : 			if (!strcmp(word, "X"))

  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_01MMEEDKFM@X@
  00100	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _strcmp
  0010c	83 c4 08	 add	 esp, 8
  0010f	85 c0		 test	 eax, eax
  00111	75 4c		 jne	 SHORT $LN12@reademblem

; 1921 : 			{
; 1922 : 				DEH_WriteUndoline(word, va("%d", emblemlocations[num-1].x), UNDO_NONE);

  00113	6a 00		 push	 0
  00115	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00118	83 e8 01	 sub	 eax, 1
  0011b	6b c8 0c	 imul	 ecx, eax, 12
  0011e	0f bf 91 00 00
	00 00		 movsx	 edx, WORD PTR _emblemlocations[ecx]
  00125	52		 push	 edx
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0012b	e8 00 00 00 00	 call	 _va
  00130	83 c4 08	 add	 esp, 8
  00133	50		 push	 eax
  00134	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1923 : 				emblemlocations[num-1].x = (INT16)value;

  00143	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00146	83 e8 01	 sub	 eax, 1
  00149	6b c8 0c	 imul	 ecx, eax, 12
  0014c	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _value$[ebp]
  00153	66 89 91 00 00
	00 00		 mov	 WORD PTR _emblemlocations[ecx], dx

; 1924 : 			}

  0015a	e9 05 02 00 00	 jmp	 $LN21@reademblem
$LN12@reademblem:

; 1925 : 			else if (!strcmp(word, "Y"))

  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_01NFFPALBN@Y@
  00164	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _strcmp
  00170	83 c4 08	 add	 esp, 8
  00173	85 c0		 test	 eax, eax
  00175	75 4c		 jne	 SHORT $LN14@reademblem

; 1926 : 			{
; 1927 : 				DEH_WriteUndoline(word, va("%d", emblemlocations[num-1].y), UNDO_NONE);

  00177	6a 00		 push	 0
  00179	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0017c	83 e8 01	 sub	 eax, 1
  0017f	6b c8 0c	 imul	 ecx, eax, 12
  00182	0f bf 91 02 00
	00 00		 movsx	 edx, WORD PTR _emblemlocations[ecx+2]
  00189	52		 push	 edx
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0018f	e8 00 00 00 00	 call	 _va
  00194	83 c4 08	 add	 esp, 8
  00197	50		 push	 eax
  00198	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1928 : 				emblemlocations[num-1].y = (INT16)value;

  001a7	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  001aa	83 e8 01	 sub	 eax, 1
  001ad	6b c8 0c	 imul	 ecx, eax, 12
  001b0	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _value$[ebp]
  001b7	66 89 91 02 00
	00 00		 mov	 WORD PTR _emblemlocations[ecx+2], dx

; 1929 : 			}

  001be	e9 a1 01 00 00	 jmp	 $LN21@reademblem
$LN14@reademblem:

; 1930 : 			else if (!strcmp(word, "Z"))

  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_01POHCFINO@Z@
  001c8	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _strcmp
  001d4	83 c4 08	 add	 esp, 8
  001d7	85 c0		 test	 eax, eax
  001d9	75 4c		 jne	 SHORT $LN16@reademblem

; 1931 : 			{
; 1932 : 				DEH_WriteUndoline(word, va("%d", emblemlocations[num-1].z), UNDO_NONE);

  001db	6a 00		 push	 0
  001dd	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  001e0	83 e8 01	 sub	 eax, 1
  001e3	6b c8 0c	 imul	 ecx, eax, 12
  001e6	0f bf 91 04 00
	00 00		 movsx	 edx, WORD PTR _emblemlocations[ecx+4]
  001ed	52		 push	 edx
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001f3	e8 00 00 00 00	 call	 _va
  001f8	83 c4 08	 add	 esp, 8
  001fb	50		 push	 eax
  001fc	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1933 : 				emblemlocations[num-1].z = (INT16)value;

  0020b	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0020e	83 e8 01	 sub	 eax, 1
  00211	6b c8 0c	 imul	 ecx, eax, 12
  00214	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _value$[ebp]
  0021b	66 89 91 04 00
	00 00		 mov	 WORD PTR _emblemlocations[ecx+4], dx

; 1934 : 			}

  00222	e9 3d 01 00 00	 jmp	 $LN21@reademblem
$LN16@reademblem:

; 1935 : 			else if (!strcmp(word, "PLAYERNUM"))

  00227	68 00 00 00 00	 push	 OFFSET ??_C@_09IHJAHKKM@PLAYERNUM@
  0022c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 _strcmp
  00238	83 c4 08	 add	 esp, 8
  0023b	85 c0		 test	 eax, eax
  0023d	75 4a		 jne	 SHORT $LN18@reademblem

; 1936 : 			{
; 1937 : 				DEH_WriteUndoline(word, va("%d", emblemlocations[num-1].player), UNDO_NONE);

  0023f	6a 00		 push	 0
  00241	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00244	83 e8 01	 sub	 eax, 1
  00247	6b c8 0c	 imul	 ecx, eax, 12
  0024a	0f b6 91 06 00
	00 00		 movzx	 edx, BYTE PTR _emblemlocations[ecx+6]
  00251	52		 push	 edx
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00257	e8 00 00 00 00	 call	 _va
  0025c	83 c4 08	 add	 esp, 8
  0025f	50		 push	 eax
  00260	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0026c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1938 : 				emblemlocations[num-1].player = (UINT8)value;

  0026f	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00272	83 e8 01	 sub	 eax, 1
  00275	6b c8 0c	 imul	 ecx, eax, 12
  00278	8a 95 ec fb ff
	ff		 mov	 dl, BYTE PTR _value$[ebp]
  0027e	88 91 06 00 00
	00		 mov	 BYTE PTR _emblemlocations[ecx+6], dl

; 1939 : 			}

  00284	e9 db 00 00 00	 jmp	 $LN21@reademblem
$LN18@reademblem:

; 1940 : 			else if (!strcmp(word, "MAPNUM"))

  00289	68 00 00 00 00	 push	 OFFSET ??_C@_06OPDDNACH@MAPNUM@
  0028e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _strcmp
  0029a	83 c4 08	 add	 esp, 8
  0029d	85 c0		 test	 eax, eax
  0029f	0f 85 ab 00 00
	00		 jne	 $LN20@reademblem

; 1941 : 			{
; 1942 : 				// Support using the actual map name,
; 1943 : 				// i.e., Level AB, Level FZ, etc.
; 1944 : 
; 1945 : 				// Convert to map number
; 1946 : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	6b c8 00	 imul	 ecx, eax, 0
  002ad	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  002b3	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  002b7	83 f8 41	 cmp	 eax, 65			; 00000041H
  002ba	7c 4b		 jl	 SHORT $LN22@reademblem
  002bc	b8 01 00 00 00	 mov	 eax, 1
  002c1	6b c8 00	 imul	 ecx, eax, 0
  002c4	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  002ca	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  002ce	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  002d1	7f 34		 jg	 SHORT $LN22@reademblem

; 1947 : 					value = M_MapNumber(word2[0], word2[1]);

  002d3	b8 01 00 00 00	 mov	 eax, 1
  002d8	c1 e0 00	 shl	 eax, 0
  002db	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  002e1	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002e5	52		 push	 edx
  002e6	b8 01 00 00 00	 mov	 eax, 1
  002eb	6b c8 00	 imul	 ecx, eax, 0
  002ee	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  002f4	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 _M_MapNumber
  002fe	83 c4 08	 add	 esp, 8
  00301	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
$LN22@reademblem:

; 1948 : 
; 1949 : 				DEH_WriteUndoline(word, va("%d", emblemlocations[num-1].level), UNDO_NONE);

  00307	6a 00		 push	 0
  00309	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0030c	83 e8 01	 sub	 eax, 1
  0030f	6b c8 0c	 imul	 ecx, eax, 12
  00312	0f bf 91 08 00
	00 00		 movsx	 edx, WORD PTR _emblemlocations[ecx+8]
  00319	52		 push	 edx
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0031f	e8 00 00 00 00	 call	 _va
  00324	83 c4 08	 add	 esp, 8
  00327	50		 push	 eax
  00328	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00334	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1950 : 				emblemlocations[num-1].level = (INT16)value;

  00337	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0033a	83 e8 01	 sub	 eax, 1
  0033d	6b c8 0c	 imul	 ecx, eax, 12
  00340	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _value$[ebp]
  00347	66 89 91 08 00
	00 00		 mov	 WORD PTR _emblemlocations[ecx+8], dx

; 1951 : 			}

  0034e	eb 14		 jmp	 SHORT $LN21@reademblem
$LN20@reademblem:

; 1952 : 			else
; 1953 : 				deh_warning("Emblem: unknown word '%s'", word);

  00350	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00356	50		 push	 eax
  00357	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IPCLALDD@Emblem?3?5unknown?5word?5?8?$CFs?8@
  0035c	e8 00 00 00 00	 call	 _deh_warning
  00361	83 c4 08	 add	 esp, 8
$LN21@reademblem:

; 1954 : 		}
; 1955 : 	} while (!myfeof(f));

  00364	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00367	8b 08		 mov	 ecx, DWORD PTR [eax]
  00369	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  0036c	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  0036f	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00372	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00375	0f 87 9b fc ff
	ff		 ja	 $LN4@reademblem
$LN3@reademblem:

; 1956 : }

  0037b	5f		 pop	 edi
  0037c	5e		 pop	 esi
  0037d	5b		 pop	 ebx
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00381	33 cd		 xor	 ecx, ebp
  00383	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
_reademblemdata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readmaincfg
_TEXT	SEGMENT
tv482 = -1252						; size = 4
tv486 = -1252						; size = 4
$T1 = -1248						; size = 4
_filenamelen$2 = -1052					; size = 4
_reload$ = -1048					; size = 4
_value$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_readmaincfg PROC					; COMDAT

; 1656 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 04 00
	00		 sub	 esp, 1252		; 000004e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1657 : 	XBOXSTATIC char s[MAXLINELEN];
; 1658 : 	char *word = s;

  00016	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0001c	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 1659 : 	char *word2;
; 1660 : 	char *tmp;
; 1661 : 	INT32 value;
; 1662 : 	boolean reload = false;

  00022	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _reload$[ebp], 0
$LN4@readmaincf:

; 1663 : 
; 1664 : 	do
; 1665 : 	{
; 1666 : 		if (myfgets(s, sizeof (s), f))

  0002c	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0002f	50		 push	 eax
  00030	68 00 04 00 00	 push	 1024			; 00000400H
  00035	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _myfgets
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	85 c0		 test	 eax, eax
  00046	0f 84 1c 0c 00
	00		 je	 $LN67@readmaincf

; 1667 : 		{
; 1668 : 			if (s[0] == '\n')

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	6b c8 00	 imul	 ecx, eax, 0
  00054	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  0005c	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0005f	75 05		 jne	 SHORT $LN6@readmaincf

; 1669 : 				break;

  00061	e9 19 0c 00 00	 jmp	 $LN3@readmaincf
$LN6@readmaincf:

; 1670 : 
; 1671 : 			// First remove trailing newline, if there is one
; 1672 : 			tmp = strchr(s, '\n');

  00066	6a 0a		 push	 10			; 0000000aH
  00068	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _strchr
  00074	83 c4 08	 add	 esp, 8
  00077	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1673 : 			if (tmp)

  0007d	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  00084	74 09		 je	 SHORT $LN7@readmaincf

; 1674 : 				*tmp = '\0';

  00086	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  0008c	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readmaincf:

; 1675 : 
; 1676 : 			tmp = strchr(s, '#');

  0008f	6a 23		 push	 35			; 00000023H
  00091	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _strchr
  0009d	83 c4 08	 add	 esp, 8
  000a0	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1677 : 			if (tmp)

  000a6	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  000ad	74 09		 je	 SHORT $LN8@readmaincf

; 1678 : 				*tmp = '\0';

  000af	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000b5	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN8@readmaincf:

; 1679 : 
; 1680 : 			// Get the part before the " = "
; 1681 : 			tmp = strchr(s, '=');

  000b8	6a 3d		 push	 61			; 0000003dH
  000ba	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _strchr
  000c6	83 c4 08	 add	 esp, 8
  000c9	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1682 : 			*(tmp-1) = '\0';

  000cf	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000d5	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 1683 : 			strupr(word);

  000d9	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _strupr
  000e5	83 c4 04	 add	 esp, 4

; 1684 : 
; 1685 : 			// Now get the part after
; 1686 : 			word2 = tmp += 2;

  000e8	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000ee	83 c0 02	 add	 eax, 2
  000f1	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax
  000f7	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _tmp$[ebp]
  000fd	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], ecx

; 1687 : 			strupr(word2);

  00103	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _strupr
  0010f	83 c4 04	 add	 esp, 4

; 1688 : 
; 1689 : 			value = atoi(word2); // used for numerical settings

  00112	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _atoi
  0011e	83 c4 04	 add	 esp, 4
  00121	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax

; 1690 : 
; 1691 : 			if (!strcmp(word, "SSTAGE_START"))

  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GNOMNNJL@SSTAGE_START@
  0012c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _strcmp
  00138	83 c4 08	 add	 esp, 8
  0013b	85 c0		 test	 eax, eax
  0013d	0f 85 b5 00 00
	00		 jne	 $LN9@readmaincf

; 1692 : 			{
; 1693 : 				// Support using the actual map name,
; 1694 : 				// i.e., Level AB, Level FZ, etc.
; 1695 : 
; 1696 : 				// Convert to map number
; 1697 : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	6b c8 00	 imul	 ecx, eax, 0
  0014b	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00151	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00155	83 f8 41	 cmp	 eax, 65			; 00000041H
  00158	7c 4b		 jl	 SHORT $LN11@readmaincf
  0015a	b8 01 00 00 00	 mov	 eax, 1
  0015f	6b c8 00	 imul	 ecx, eax, 0
  00162	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00168	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0016c	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  0016f	7f 34		 jg	 SHORT $LN11@readmaincf

; 1698 : 					value = M_MapNumber(word2[0], word2[1]);

  00171	b8 01 00 00 00	 mov	 eax, 1
  00176	c1 e0 00	 shl	 eax, 0
  00179	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  0017f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00183	52		 push	 edx
  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	6b c8 00	 imul	 ecx, eax, 0
  0018c	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00192	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _M_MapNumber
  0019c	83 c4 08	 add	 esp, 8
  0019f	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
$LN11@readmaincf:

; 1699 : 
; 1700 : 				DEH_WriteUndoline(word, va("%d", sstage_start), UNDO_NONE);

  001a5	6a 00		 push	 0
  001a7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _sstage_start
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001b4	e8 00 00 00 00	 call	 _va
  001b9	83 c4 08	 add	 esp, 8
  001bc	50		 push	 eax
  001bd	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1701 : 				sstage_start = (INT16)value;

  001cc	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _value$[ebp]
  001d3	66 a3 00 00 00
	00		 mov	 WORD PTR _sstage_start, ax

; 1702 : 				sstage_end = (INT16)(sstage_start+6);

  001d9	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _sstage_start
  001e0	83 c0 06	 add	 eax, 6
  001e3	66 a3 00 00 00
	00		 mov	 WORD PTR _sstage_end, ax

; 1703 : 				useNightsSS = false;

  001e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useNightsSS, 0

; 1704 : 			}

  001f3	e9 70 0a 00 00	 jmp	 $LN67@readmaincf
$LN9@readmaincf:

; 1705 : 			else if (!strcmp(word, "NSSTAGE_START"))

  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DJABEAKP@NSSTAGE_START@
  001fd	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 _strcmp
  00209	83 c4 08	 add	 esp, 8
  0020c	85 c0		 test	 eax, eax
  0020e	0f 85 b5 00 00
	00		 jne	 $LN12@readmaincf

; 1706 : 			{
; 1707 : 				// Support using the actual map name,
; 1708 : 				// i.e., Level AB, Level FZ, etc.
; 1709 : 
; 1710 : 				// Convert to map number
; 1711 : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  00214	b8 01 00 00 00	 mov	 eax, 1
  00219	6b c8 00	 imul	 ecx, eax, 0
  0021c	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00222	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00226	83 f8 41	 cmp	 eax, 65			; 00000041H
  00229	7c 4b		 jl	 SHORT $LN14@readmaincf
  0022b	b8 01 00 00 00	 mov	 eax, 1
  00230	6b c8 00	 imul	 ecx, eax, 0
  00233	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00239	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0023d	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00240	7f 34		 jg	 SHORT $LN14@readmaincf

; 1712 : 					value = M_MapNumber(word2[0], word2[1]);

  00242	b8 01 00 00 00	 mov	 eax, 1
  00247	c1 e0 00	 shl	 eax, 0
  0024a	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  00250	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00254	52		 push	 edx
  00255	b8 01 00 00 00	 mov	 eax, 1
  0025a	6b c8 00	 imul	 ecx, eax, 0
  0025d	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00263	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 _M_MapNumber
  0026d	83 c4 08	 add	 esp, 8
  00270	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
$LN14@readmaincf:

; 1713 : 
; 1714 : 				DEH_WriteUndoline(word, va("%d", nsstage_start), UNDO_NONE);

  00276	6a 00		 push	 0
  00278	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _nsstage_start
  0027f	50		 push	 eax
  00280	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00285	e8 00 00 00 00	 call	 _va
  0028a	83 c4 08	 add	 esp, 8
  0028d	50		 push	 eax
  0028e	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00294	51		 push	 ecx
  00295	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0029a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1715 : 				nsstage_start = (INT16)value;

  0029d	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _value$[ebp]
  002a4	66 a3 00 00 00
	00		 mov	 WORD PTR _nsstage_start, ax

; 1716 : 				nsstage_end = (INT16)(nsstage_start+6);

  002aa	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _nsstage_start
  002b1	83 c0 06	 add	 eax, 6
  002b4	66 a3 00 00 00
	00		 mov	 WORD PTR _nsstage_end, ax

; 1717 : 				useNightsSS = true;

  002ba	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _useNightsSS, 1

; 1718 : 			}

  002c4	e9 9f 09 00 00	 jmp	 $LN67@readmaincf
$LN12@readmaincf:

; 1719 : 			else if (!strcmp(word, "EXECCFG"))

  002c9	68 00 00 00 00	 push	 OFFSET ??_C@_07OJNCCNOK@EXECCFG@
  002ce	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002d4	50		 push	 eax
  002d5	e8 00 00 00 00	 call	 _strcmp
  002da	83 c4 08	 add	 esp, 8
  002dd	85 c0		 test	 eax, eax
  002df	75 22		 jne	 SHORT $LN15@readmaincf

; 1720 : 				COM_BufAddText(va("exec %s\n", word2));

  002e1	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  002e7	50		 push	 eax
  002e8	68 00 00 00 00	 push	 OFFSET ??_C@_08NNCMPFKC@exec?5?$CFs?6@
  002ed	e8 00 00 00 00	 call	 _va
  002f2	83 c4 08	 add	 esp, 8
  002f5	50		 push	 eax
  002f6	e8 00 00 00 00	 call	 _COM_BufAddText
  002fb	83 c4 04	 add	 esp, 4
  002fe	e9 65 09 00 00	 jmp	 $LN67@readmaincf
$LN15@readmaincf:

; 1721 : 			else if (!strcmp(word, "SPSTAGE_START"))

  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FFIDGAFG@SPSTAGE_START@
  00308	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 _strcmp
  00314	83 c4 08	 add	 esp, 8
  00317	85 c0		 test	 eax, eax
  00319	0f 85 9b 00 00
	00		 jne	 $LN17@readmaincf

; 1722 : 			{
; 1723 : 				// Support using the actual map name,
; 1724 : 				// i.e., Level AB, Level FZ, etc.
; 1725 : 
; 1726 : 				// Convert to map number
; 1727 : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	6b c8 00	 imul	 ecx, eax, 0
  00327	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  0032d	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00331	83 f8 41	 cmp	 eax, 65			; 00000041H
  00334	7c 4b		 jl	 SHORT $LN19@readmaincf
  00336	b8 01 00 00 00	 mov	 eax, 1
  0033b	6b c8 00	 imul	 ecx, eax, 0
  0033e	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00344	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00348	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  0034b	7f 34		 jg	 SHORT $LN19@readmaincf

; 1728 : 					value = M_MapNumber(word2[0], word2[1]);

  0034d	b8 01 00 00 00	 mov	 eax, 1
  00352	c1 e0 00	 shl	 eax, 0
  00355	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  0035b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0035f	52		 push	 edx
  00360	b8 01 00 00 00	 mov	 eax, 1
  00365	6b c8 00	 imul	 ecx, eax, 0
  00368	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  0036e	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 _M_MapNumber
  00378	83 c4 08	 add	 esp, 8
  0037b	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
$LN19@readmaincf:

; 1729 : 
; 1730 : 				DEH_WriteUndoline(word, va("%d", spstage_start), UNDO_NONE);

  00381	6a 00		 push	 0
  00383	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _spstage_start
  0038a	50		 push	 eax
  0038b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00390	e8 00 00 00 00	 call	 _va
  00395	83 c4 08	 add	 esp, 8
  00398	50		 push	 eax
  00399	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0039f	51		 push	 ecx
  003a0	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  003a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1731 : 				spstage_start = (INT16)value;

  003a8	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _value$[ebp]
  003af	66 a3 00 00 00
	00		 mov	 WORD PTR _spstage_start, ax

; 1732 : 			}

  003b5	e9 ae 08 00 00	 jmp	 $LN67@readmaincf
$LN17@readmaincf:

; 1733 : 			else if (!strcmp(word, "SPSTAGE_END"))

  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JHKIJPM@SPSTAGE_END@
  003bf	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 _strcmp
  003cb	83 c4 08	 add	 esp, 8
  003ce	85 c0		 test	 eax, eax
  003d0	0f 85 9b 00 00
	00		 jne	 $LN20@readmaincf

; 1734 : 			{
; 1735 : 				// Support using the actual map name,
; 1736 : 				// i.e., Level AB, Level FZ, etc.
; 1737 : 
; 1738 : 				// Convert to map number
; 1739 : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  003d6	b8 01 00 00 00	 mov	 eax, 1
  003db	6b c8 00	 imul	 ecx, eax, 0
  003de	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  003e4	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  003e8	83 f8 41	 cmp	 eax, 65			; 00000041H
  003eb	7c 4b		 jl	 SHORT $LN22@readmaincf
  003ed	b8 01 00 00 00	 mov	 eax, 1
  003f2	6b c8 00	 imul	 ecx, eax, 0
  003f5	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  003fb	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  003ff	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00402	7f 34		 jg	 SHORT $LN22@readmaincf

; 1740 : 					value = M_MapNumber(word2[0], word2[1]);

  00404	b8 01 00 00 00	 mov	 eax, 1
  00409	c1 e0 00	 shl	 eax, 0
  0040c	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  00412	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00416	52		 push	 edx
  00417	b8 01 00 00 00	 mov	 eax, 1
  0041c	6b c8 00	 imul	 ecx, eax, 0
  0041f	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00425	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 _M_MapNumber
  0042f	83 c4 08	 add	 esp, 8
  00432	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
$LN22@readmaincf:

; 1741 : 
; 1742 : 				DEH_WriteUndoline(word, va("%d", spstage_end), UNDO_NONE);

  00438	6a 00		 push	 0
  0043a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _spstage_end
  00441	50		 push	 eax
  00442	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00447	e8 00 00 00 00	 call	 _va
  0044c	83 c4 08	 add	 esp, 8
  0044f	50		 push	 eax
  00450	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00456	51		 push	 ecx
  00457	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0045c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1743 : 				spstage_end = (INT16)value;

  0045f	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _value$[ebp]
  00466	66 a3 00 00 00
	00		 mov	 WORD PTR _spstage_end, ax

; 1744 : 			}

  0046c	e9 f7 07 00 00	 jmp	 $LN67@readmaincf
$LN20@readmaincf:

; 1745 : 			else if (!strcmp(word, "RACESTAGE_START"))

  00471	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JLOADGPD@RACESTAGE_START@
  00476	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0047c	50		 push	 eax
  0047d	e8 00 00 00 00	 call	 _strcmp
  00482	83 c4 08	 add	 esp, 8
  00485	85 c0		 test	 eax, eax
  00487	0f 85 9b 00 00
	00		 jne	 $LN23@readmaincf

; 1746 : 			{
; 1747 : 				// Support using the actual map name,
; 1748 : 				// i.e., Level AB, Level FZ, etc.
; 1749 : 
; 1750 : 				// Convert to map number
; 1751 : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  0048d	b8 01 00 00 00	 mov	 eax, 1
  00492	6b c8 00	 imul	 ecx, eax, 0
  00495	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  0049b	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0049f	83 f8 41	 cmp	 eax, 65			; 00000041H
  004a2	7c 4b		 jl	 SHORT $LN25@readmaincf
  004a4	b8 01 00 00 00	 mov	 eax, 1
  004a9	6b c8 00	 imul	 ecx, eax, 0
  004ac	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  004b2	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  004b6	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  004b9	7f 34		 jg	 SHORT $LN25@readmaincf

; 1752 : 					value = M_MapNumber(word2[0], word2[1]);

  004bb	b8 01 00 00 00	 mov	 eax, 1
  004c0	c1 e0 00	 shl	 eax, 0
  004c3	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  004c9	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004cd	52		 push	 edx
  004ce	b8 01 00 00 00	 mov	 eax, 1
  004d3	6b c8 00	 imul	 ecx, eax, 0
  004d6	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  004dc	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  004e0	50		 push	 eax
  004e1	e8 00 00 00 00	 call	 _M_MapNumber
  004e6	83 c4 08	 add	 esp, 8
  004e9	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
$LN25@readmaincf:

; 1753 : 
; 1754 : 				DEH_WriteUndoline(word, va("%d", racestage_start), UNDO_NONE);

  004ef	6a 00		 push	 0
  004f1	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _racestage_start
  004f8	50		 push	 eax
  004f9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004fe	e8 00 00 00 00	 call	 _va
  00503	83 c4 08	 add	 esp, 8
  00506	50		 push	 eax
  00507	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0050d	51		 push	 ecx
  0050e	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00513	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1755 : 				racestage_start = (INT16)value;

  00516	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _value$[ebp]
  0051d	66 a3 00 00 00
	00		 mov	 WORD PTR _racestage_start, ax

; 1756 : 			}

  00523	e9 40 07 00 00	 jmp	 $LN67@readmaincf
$LN23@readmaincf:

; 1757 : 			else if (!strcmp(word, "INVULNTICS"))

  00528	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NLLMKMJH@INVULNTICS@
  0052d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00533	50		 push	 eax
  00534	e8 00 00 00 00	 call	 _strcmp
  00539	83 c4 08	 add	 esp, 8
  0053c	85 c0		 test	 eax, eax
  0053e	75 35		 jne	 SHORT $LN26@readmaincf

; 1758 : 			{
; 1759 : 				DEH_WriteUndoline(word, va("%u", invulntics), UNDO_NONE);

  00540	6a 00		 push	 0
  00542	a1 00 00 00 00	 mov	 eax, DWORD PTR _invulntics
  00547	50		 push	 eax
  00548	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  0054d	e8 00 00 00 00	 call	 _va
  00552	83 c4 08	 add	 esp, 8
  00555	50		 push	 eax
  00556	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0055c	51		 push	 ecx
  0055d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00562	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1760 : 				invulntics = value;

  00565	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  0056b	a3 00 00 00 00	 mov	 DWORD PTR _invulntics, eax

; 1761 : 			}

  00570	e9 f3 06 00 00	 jmp	 $LN67@readmaincf
$LN26@readmaincf:

; 1762 : 			else if (!strcmp(word, "SNEAKERTICS"))

  00575	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BBMMDGAO@SNEAKERTICS@
  0057a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 _strcmp
  00586	83 c4 08	 add	 esp, 8
  00589	85 c0		 test	 eax, eax
  0058b	75 35		 jne	 SHORT $LN28@readmaincf

; 1763 : 			{
; 1764 : 				DEH_WriteUndoline(word, va("%u", sneakertics), UNDO_NONE);

  0058d	6a 00		 push	 0
  0058f	a1 00 00 00 00	 mov	 eax, DWORD PTR _sneakertics
  00594	50		 push	 eax
  00595	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  0059a	e8 00 00 00 00	 call	 _va
  0059f	83 c4 08	 add	 esp, 8
  005a2	50		 push	 eax
  005a3	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  005a9	51		 push	 ecx
  005aa	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 : 				sneakertics = value;

  005b2	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  005b8	a3 00 00 00 00	 mov	 DWORD PTR _sneakertics, eax

; 1766 : 			}

  005bd	e9 a6 06 00 00	 jmp	 $LN67@readmaincf
$LN28@readmaincf:

; 1767 : 			else if (!strcmp(word, "FLASHINGTICS"))

  005c2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FLPJIF@FLASHINGTICS@
  005c7	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  005cd	50		 push	 eax
  005ce	e8 00 00 00 00	 call	 _strcmp
  005d3	83 c4 08	 add	 esp, 8
  005d6	85 c0		 test	 eax, eax
  005d8	75 35		 jne	 SHORT $LN30@readmaincf

; 1768 : 			{
; 1769 : 				DEH_WriteUndoline(word, va("%u", flashingtics), UNDO_NONE);

  005da	6a 00		 push	 0
  005dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _flashingtics
  005e1	50		 push	 eax
  005e2	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  005e7	e8 00 00 00 00	 call	 _va
  005ec	83 c4 08	 add	 esp, 8
  005ef	50		 push	 eax
  005f0	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  005f6	51		 push	 ecx
  005f7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1770 : 				flashingtics = value;

  005ff	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00605	a3 00 00 00 00	 mov	 DWORD PTR _flashingtics, eax

; 1771 : 			}

  0060a	e9 59 06 00 00	 jmp	 $LN67@readmaincf
$LN30@readmaincf:

; 1772 : 			else if (!strcmp(word, "TAILSFLYTICS"))

  0060f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HPDPGMBI@TAILSFLYTICS@
  00614	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0061a	50		 push	 eax
  0061b	e8 00 00 00 00	 call	 _strcmp
  00620	83 c4 08	 add	 esp, 8
  00623	85 c0		 test	 eax, eax
  00625	75 35		 jne	 SHORT $LN32@readmaincf

; 1773 : 			{
; 1774 : 				DEH_WriteUndoline(word, va("%u", tailsflytics), UNDO_NONE);

  00627	6a 00		 push	 0
  00629	a1 00 00 00 00	 mov	 eax, DWORD PTR _tailsflytics
  0062e	50		 push	 eax
  0062f	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00634	e8 00 00 00 00	 call	 _va
  00639	83 c4 08	 add	 esp, 8
  0063c	50		 push	 eax
  0063d	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00643	51		 push	 ecx
  00644	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00649	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1775 : 				tailsflytics = value;

  0064c	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00652	a3 00 00 00 00	 mov	 DWORD PTR _tailsflytics, eax

; 1776 : 			}

  00657	e9 0c 06 00 00	 jmp	 $LN67@readmaincf
$LN32@readmaincf:

; 1777 : 			else if (!strcmp(word, "UNDERWATERTICS"))

  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DGMLJMDB@UNDERWATERTICS@
  00661	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00667	50		 push	 eax
  00668	e8 00 00 00 00	 call	 _strcmp
  0066d	83 c4 08	 add	 esp, 8
  00670	85 c0		 test	 eax, eax
  00672	75 35		 jne	 SHORT $LN34@readmaincf

; 1778 : 			{
; 1779 : 				DEH_WriteUndoline(word, va("%u", underwatertics), UNDO_NONE);

  00674	6a 00		 push	 0
  00676	a1 00 00 00 00	 mov	 eax, DWORD PTR _underwatertics
  0067b	50		 push	 eax
  0067c	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00681	e8 00 00 00 00	 call	 _va
  00686	83 c4 08	 add	 esp, 8
  00689	50		 push	 eax
  0068a	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00690	51		 push	 ecx
  00691	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00696	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1780 : 				underwatertics = value;

  00699	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  0069f	a3 00 00 00 00	 mov	 DWORD PTR _underwatertics, eax

; 1781 : 			}

  006a4	e9 bf 05 00 00	 jmp	 $LN67@readmaincf
$LN34@readmaincf:

; 1782 : 			else if (!strcmp(word, "SPACETIMETICS"))

  006a9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ELLLBCPC@SPACETIMETICS@
  006ae	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006b4	50		 push	 eax
  006b5	e8 00 00 00 00	 call	 _strcmp
  006ba	83 c4 08	 add	 esp, 8
  006bd	85 c0		 test	 eax, eax
  006bf	75 35		 jne	 SHORT $LN36@readmaincf

; 1783 : 			{
; 1784 : 				DEH_WriteUndoline(word, va("%u", spacetimetics), UNDO_NONE);

  006c1	6a 00		 push	 0
  006c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _spacetimetics
  006c8	50		 push	 eax
  006c9	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  006ce	e8 00 00 00 00	 call	 _va
  006d3	83 c4 08	 add	 esp, 8
  006d6	50		 push	 eax
  006d7	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  006dd	51		 push	 ecx
  006de	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  006e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1785 : 				spacetimetics = value;

  006e6	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  006ec	a3 00 00 00 00	 mov	 DWORD PTR _spacetimetics, eax

; 1786 : 			}

  006f1	e9 72 05 00 00	 jmp	 $LN67@readmaincf
$LN36@readmaincf:

; 1787 : 			else if (!strcmp(word, "EXTRALIFETICS"))

  006f6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GIPPCDEL@EXTRALIFETICS@
  006fb	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00701	50		 push	 eax
  00702	e8 00 00 00 00	 call	 _strcmp
  00707	83 c4 08	 add	 esp, 8
  0070a	85 c0		 test	 eax, eax
  0070c	75 35		 jne	 SHORT $LN38@readmaincf

; 1788 : 			{
; 1789 : 				DEH_WriteUndoline(word, va("%u", extralifetics), UNDO_NONE);

  0070e	6a 00		 push	 0
  00710	a1 00 00 00 00	 mov	 eax, DWORD PTR _extralifetics
  00715	50		 push	 eax
  00716	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  0071b	e8 00 00 00 00	 call	 _va
  00720	83 c4 08	 add	 esp, 8
  00723	50		 push	 eax
  00724	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0072a	51		 push	 ecx
  0072b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00730	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1790 : 				extralifetics = value;

  00733	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00739	a3 00 00 00 00	 mov	 DWORD PTR _extralifetics, eax

; 1791 : 			}

  0073e	e9 25 05 00 00	 jmp	 $LN67@readmaincf
$LN38@readmaincf:

; 1792 : 			else if (!strcmp(word, "GRAVBOOTSTICS"))

  00743	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KGLHIKIO@GRAVBOOTSTICS@
  00748	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0074e	50		 push	 eax
  0074f	e8 00 00 00 00	 call	 _strcmp
  00754	83 c4 08	 add	 esp, 8
  00757	85 c0		 test	 eax, eax
  00759	75 35		 jne	 SHORT $LN40@readmaincf

; 1793 : 			{
; 1794 : 				DEH_WriteUndoline(word, va("%u", gravbootstics), UNDO_NONE);

  0075b	6a 00		 push	 0
  0075d	a1 00 00 00 00	 mov	 eax, DWORD PTR _gravbootstics
  00762	50		 push	 eax
  00763	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00768	e8 00 00 00 00	 call	 _va
  0076d	83 c4 08	 add	 esp, 8
  00770	50		 push	 eax
  00771	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00777	51		 push	 ecx
  00778	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0077d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1795 : 				gravbootstics = value;

  00780	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00786	a3 00 00 00 00	 mov	 DWORD PTR _gravbootstics, eax

; 1796 : 			}

  0078b	e9 d8 04 00 00	 jmp	 $LN67@readmaincf
$LN40@readmaincf:

; 1797 : 			else if (!strcmp(word, "PARALOOPTICS"))

  00790	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LNHOBDGP@PARALOOPTICS@
  00795	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0079b	50		 push	 eax
  0079c	e8 00 00 00 00	 call	 _strcmp
  007a1	83 c4 08	 add	 esp, 8
  007a4	85 c0		 test	 eax, eax
  007a6	75 35		 jne	 SHORT $LN42@readmaincf

; 1798 : 			{
; 1799 : 				DEH_WriteUndoline(word, va("%u", paralooptics), UNDO_NONE);

  007a8	6a 00		 push	 0
  007aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _paralooptics
  007af	50		 push	 eax
  007b0	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  007b5	e8 00 00 00 00	 call	 _va
  007ba	83 c4 08	 add	 esp, 8
  007bd	50		 push	 eax
  007be	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  007c4	51		 push	 ecx
  007c5	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  007ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1800 : 				paralooptics = value;

  007cd	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  007d3	a3 00 00 00 00	 mov	 DWORD PTR _paralooptics, eax

; 1801 : 			}

  007d8	e9 8b 04 00 00	 jmp	 $LN67@readmaincf
$LN42@readmaincf:

; 1802 : 			else if (!strcmp(word, "HELPERTICS"))

  007dd	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HCFAMJBI@HELPERTICS@
  007e2	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  007e8	50		 push	 eax
  007e9	e8 00 00 00 00	 call	 _strcmp
  007ee	83 c4 08	 add	 esp, 8
  007f1	85 c0		 test	 eax, eax
  007f3	75 35		 jne	 SHORT $LN44@readmaincf

; 1803 : 			{
; 1804 : 				DEH_WriteUndoline(word, va("%u", helpertics), UNDO_NONE);

  007f5	6a 00		 push	 0
  007f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _helpertics
  007fc	50		 push	 eax
  007fd	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00802	e8 00 00 00 00	 call	 _va
  00807	83 c4 08	 add	 esp, 8
  0080a	50		 push	 eax
  0080b	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00811	51		 push	 ecx
  00812	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00817	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1805 : 				helpertics = value;

  0081a	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00820	a3 00 00 00 00	 mov	 DWORD PTR _helpertics, eax

; 1806 : 			}

  00825	e9 3e 04 00 00	 jmp	 $LN67@readmaincf
$LN44@readmaincf:

; 1807 : 			else if (!strcmp(word, "GAMEOVERTICS"))

  0082a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PDCOMLBK@GAMEOVERTICS@
  0082f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00835	50		 push	 eax
  00836	e8 00 00 00 00	 call	 _strcmp
  0083b	83 c4 08	 add	 esp, 8
  0083e	85 c0		 test	 eax, eax
  00840	75 35		 jne	 SHORT $LN46@readmaincf

; 1808 : 			{
; 1809 : 				DEH_WriteUndoline(word, va("%u", gameovertics), UNDO_NONE);

  00842	6a 00		 push	 0
  00844	a1 00 00 00 00	 mov	 eax, DWORD PTR _gameovertics
  00849	50		 push	 eax
  0084a	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  0084f	e8 00 00 00 00	 call	 _va
  00854	83 c4 08	 add	 esp, 8
  00857	50		 push	 eax
  00858	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0085e	51		 push	 ecx
  0085f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00864	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1810 : 				gameovertics = value;

  00867	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  0086d	a3 00 00 00 00	 mov	 DWORD PTR _gameovertics, eax

; 1811 : 			}

  00872	e9 f1 03 00 00	 jmp	 $LN67@readmaincf
$LN46@readmaincf:

; 1812 : 			else if (!strcmp(word, "INTROTOPLAY"))

  00877	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GLFMEFCC@INTROTOPLAY@
  0087c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00882	50		 push	 eax
  00883	e8 00 00 00 00	 call	 _strcmp
  00888	83 c4 08	 add	 esp, 8
  0088b	85 c0		 test	 eax, eax
  0088d	75 37		 jne	 SHORT $LN48@readmaincf

; 1813 : 			{
; 1814 : 				DEH_WriteUndoline(word, va("%d", introtoplay), UNDO_NONE);

  0088f	6a 00		 push	 0
  00891	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _introtoplay
  00898	50		 push	 eax
  00899	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0089e	e8 00 00 00 00	 call	 _va
  008a3	83 c4 08	 add	 esp, 8
  008a6	50		 push	 eax
  008a7	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  008ad	51		 push	 ecx
  008ae	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  008b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1815 : 				introtoplay = (UINT8)value;

  008b6	8a 85 ec fb ff
	ff		 mov	 al, BYTE PTR _value$[ebp]
  008bc	a2 00 00 00 00	 mov	 BYTE PTR _introtoplay, al

; 1816 : 			}

  008c1	e9 a2 03 00 00	 jmp	 $LN67@readmaincf
$LN48@readmaincf:

; 1817 : 			else if (!strcmp(word, "LOOPTITLE"))

  008c6	68 00 00 00 00	 push	 OFFSET ??_C@_09DIKNKCEP@LOOPTITLE@
  008cb	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  008d1	50		 push	 eax
  008d2	e8 00 00 00 00	 call	 _strcmp
  008d7	83 c4 08	 add	 esp, 8
  008da	85 c0		 test	 eax, eax
  008dc	75 35		 jne	 SHORT $LN50@readmaincf

; 1818 : 			{
; 1819 : 				DEH_WriteUndoline(word, va("%d", looptitle), UNDO_NONE);

  008de	6a 00		 push	 0
  008e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _looptitle
  008e5	50		 push	 eax
  008e6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  008eb	e8 00 00 00 00	 call	 _va
  008f0	83 c4 08	 add	 esp, 8
  008f3	50		 push	 eax
  008f4	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  008fa	51		 push	 ecx
  008fb	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00900	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1820 : 				looptitle = value;

  00903	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00909	a3 00 00 00 00	 mov	 DWORD PTR _looptitle, eax

; 1821 : 			}

  0090e	e9 55 03 00 00	 jmp	 $LN67@readmaincf
$LN50@readmaincf:

; 1822 : 			else if (!strcmp(word, "TITLESCROLLSPEED"))

  00913	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IKJKJFLM@TITLESCROLLSPEED@
  00918	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0091e	50		 push	 eax
  0091f	e8 00 00 00 00	 call	 _strcmp
  00924	83 c4 08	 add	 esp, 8
  00927	85 c0		 test	 eax, eax
  00929	75 35		 jne	 SHORT $LN52@readmaincf

; 1823 : 			{
; 1824 : 				DEH_WriteUndoline(word, va("%d", titlescrollspeed), UNDO_NONE);

  0092b	6a 00		 push	 0
  0092d	a1 00 00 00 00	 mov	 eax, DWORD PTR _titlescrollspeed
  00932	50		 push	 eax
  00933	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00938	e8 00 00 00 00	 call	 _va
  0093d	83 c4 08	 add	 esp, 8
  00940	50		 push	 eax
  00941	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00947	51		 push	 ecx
  00948	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0094d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1825 : 				titlescrollspeed = value;

  00950	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00956	a3 00 00 00 00	 mov	 DWORD PTR _titlescrollspeed, eax

; 1826 : 			}

  0095b	e9 08 03 00 00	 jmp	 $LN67@readmaincf
$LN52@readmaincf:

; 1827 : 			else if (!strcmp(word, "CREDITSCUTSCENE"))

  00960	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIHDLKN@CREDITSCUTSCENE@
  00965	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0096b	50		 push	 eax
  0096c	e8 00 00 00 00	 call	 _strcmp
  00971	83 c4 08	 add	 esp, 8
  00974	85 c0		 test	 eax, eax
  00976	75 37		 jne	 SHORT $LN54@readmaincf

; 1828 : 			{
; 1829 : 				DEH_WriteUndoline(word, va("%d", creditscutscene), UNDO_NONE);

  00978	6a 00		 push	 0
  0097a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _creditscutscene
  00981	50		 push	 eax
  00982	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00987	e8 00 00 00 00	 call	 _va
  0098c	83 c4 08	 add	 esp, 8
  0098f	50		 push	 eax
  00990	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00996	51		 push	 ecx
  00997	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0099c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1830 : 				creditscutscene = (UINT8)value;

  0099f	8a 85 ec fb ff
	ff		 mov	 al, BYTE PTR _value$[ebp]
  009a5	a2 00 00 00 00	 mov	 BYTE PTR _creditscutscene, al

; 1831 : 			}

  009aa	e9 b9 02 00 00	 jmp	 $LN67@readmaincf
$LN54@readmaincf:

; 1832 : 			else if (!strcmp(word, "DISABLESPEEDADJUST"))

  009af	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KJADGDCM@DISABLESPEEDADJUST@
  009b4	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  009ba	50		 push	 eax
  009bb	e8 00 00 00 00	 call	 _strcmp
  009c0	83 c4 08	 add	 esp, 8
  009c3	85 c0		 test	 eax, eax
  009c5	75 36		 jne	 SHORT $LN56@readmaincf

; 1833 : 			{
; 1834 : 				DEH_WriteUndoline(word, va("%d", disableSpeedAdjust), UNDO_NONE);

  009c7	6a 00		 push	 0
  009c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _disableSpeedAdjust
  009ce	50		 push	 eax
  009cf	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  009d4	e8 00 00 00 00	 call	 _va
  009d9	83 c4 08	 add	 esp, 8
  009dc	50		 push	 eax
  009dd	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  009e3	51		 push	 ecx
  009e4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  009e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1835 : 				disableSpeedAdjust = (UINT8)value;

  009ec	0f b6 85 ec fb
	ff ff		 movzx	 eax, BYTE PTR _value$[ebp]
  009f3	a3 00 00 00 00	 mov	 DWORD PTR _disableSpeedAdjust, eax

; 1836 : 			}

  009f8	e9 6b 02 00 00	 jmp	 $LN67@readmaincf
$LN56@readmaincf:

; 1837 : 			else if (!strcmp(word, "GAMEDATA"))

  009fd	68 00 00 00 00	 push	 OFFSET ??_C@_08DAHHPBHD@GAMEDATA@
  00a02	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00a08	50		 push	 eax
  00a09	e8 00 00 00 00	 call	 _strcmp
  00a0e	83 c4 08	 add	 esp, 8
  00a11	85 c0		 test	 eax, eax
  00a13	0f 85 45 01 00
	00		 jne	 $LN58@readmaincf

; 1838 : 			{
; 1839 : 				size_t filenamelen;
; 1840 : 
; 1841 : 				// Check the data filename so that mods
; 1842 : 				// can't write arbitrary files.
; 1843 : 				if (!GoodDataFileName(word2))

  00a19	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00a1f	50		 push	 eax
  00a20	e8 00 00 00 00	 call	 _GoodDataFileName
  00a25	83 c4 04	 add	 esp, 4
  00a28	85 c0		 test	 eax, eax
  00a2a	75 14		 jne	 SHORT $LN60@readmaincf

; 1844 : 					I_Error("Maincfg: bad data file name '%s'\n", word2);

  00a2c	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00a32	50		 push	 eax
  00a33	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BCDGLAPN@Maincfg?3?5bad?5data?5file?5name?5?8?$CFs@
  00a38	e8 00 00 00 00	 call	 _I_Error
  00a3d	83 c4 08	 add	 esp, 8
$LN60@readmaincf:

; 1845 : 
; 1846 : 				G_SaveGameData();

  00a40	e8 00 00 00 00	 call	 _G_SaveGameData
  00a45	90		 npad	 1

; 1847 : 				DEH_WriteUndoline(word, gamedatafilename, UNDO_NONE);

  00a46	6a 00		 push	 0
  00a48	68 00 00 00 00	 push	 OFFSET _gamedatafilename
  00a4d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00a53	50		 push	 eax
  00a54	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00a59	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1848 : 				strlcpy(gamedatafilename, word2, sizeof (gamedatafilename));

  00a5c	6a 40		 push	 64			; 00000040H
  00a5e	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00a64	50		 push	 eax
  00a65	68 00 00 00 00	 push	 OFFSET _gamedatafilename
  00a6a	e8 00 00 00 00	 call	 _strlcpy
  00a6f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1849 : 				strlwr(gamedatafilename);

  00a72	68 00 00 00 00	 push	 OFFSET _gamedatafilename
  00a77	e8 00 00 00 00	 call	 _strlwr
  00a7c	83 c4 04	 add	 esp, 4

; 1850 : 				savemoddata = true;

  00a7f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _savemoddata, 1

; 1851 : 
; 1852 : 				// Also save a time attack folder
; 1853 : 				filenamelen = strlen(gamedatafilename)-4;  // Strip off the extension

  00a89	68 00 00 00 00	 push	 OFFSET _gamedatafilename
  00a8e	e8 00 00 00 00	 call	 _strlen
  00a93	83 c4 04	 add	 esp, 4
  00a96	83 e8 04	 sub	 eax, 4
  00a99	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _filenamelen$2[ebp], eax

; 1854 : 				strncpy(timeattackfolder, gamedatafilename, min(filenamelen, sizeof (timeattackfolder)));

  00a9f	83 bd e4 fb ff
	ff 40		 cmp	 DWORD PTR _filenamelen$2[ebp], 64 ; 00000040H
  00aa6	73 0e		 jae	 SHORT $LN70@readmaincf
  00aa8	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _filenamelen$2[ebp]
  00aae	89 85 1c fb ff
	ff		 mov	 DWORD PTR tv482[ebp], eax
  00ab4	eb 0a		 jmp	 SHORT $LN71@readmaincf
$LN70@readmaincf:
  00ab6	c7 85 1c fb ff
	ff 40 00 00 00	 mov	 DWORD PTR tv482[ebp], 64 ; 00000040H
$LN71@readmaincf:
  00ac0	8b 8d 1c fb ff
	ff		 mov	 ecx, DWORD PTR tv482[ebp]
  00ac6	51		 push	 ecx
  00ac7	68 00 00 00 00	 push	 OFFSET _gamedatafilename
  00acc	68 00 00 00 00	 push	 OFFSET _timeattackfolder
  00ad1	e8 00 00 00 00	 call	 _strncpy
  00ad6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1855 : 				timeattackfolder[min(filenamelen, sizeof (timeattackfolder) - 1)] = '\0';

  00ad9	83 bd e4 fb ff
	ff 3f		 cmp	 DWORD PTR _filenamelen$2[ebp], 63 ; 0000003fH
  00ae0	73 0e		 jae	 SHORT $LN72@readmaincf
  00ae2	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _filenamelen$2[ebp]
  00ae8	89 85 1c fb ff
	ff		 mov	 DWORD PTR tv486[ebp], eax
  00aee	eb 0a		 jmp	 SHORT $LN73@readmaincf
$LN72@readmaincf:
  00af0	c7 85 1c fb ff
	ff 3f 00 00 00	 mov	 DWORD PTR tv486[ebp], 63 ; 0000003fH
$LN73@readmaincf:
  00afa	8b 8d 1c fb ff
	ff		 mov	 ecx, DWORD PTR tv486[ebp]
  00b00	89 8d 20 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00b06	83 bd 20 fb ff
	ff 40		 cmp	 DWORD PTR $T1[ebp], 64	; 00000040H
  00b0d	73 02		 jae	 SHORT $LN74@readmaincf
  00b0f	eb 06		 jmp	 SHORT $LN75@readmaincf
$LN74@readmaincf:
  00b11	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00b16	90		 npad	 1
$LN75@readmaincf:
  00b17	8b 95 20 fb ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00b1d	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _timeattackfolder[edx], 0

; 1856 : 
; 1857 : 				strncpy(savegamename, timeattackfolder, sizeof (timeattackfolder));

  00b24	6a 40		 push	 64			; 00000040H
  00b26	68 00 00 00 00	 push	 OFFSET _timeattackfolder
  00b2b	68 00 00 00 00	 push	 OFFSET _savegamename
  00b30	e8 00 00 00 00	 call	 _strncpy
  00b35	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1858 : 				strlcat(savegamename, "%u.ssg", sizeof(savegamename));

  00b38	68 00 01 00 00	 push	 256			; 00000100H
  00b3d	68 00 00 00 00	 push	 OFFSET ??_C@_06NPIJBPLG@?$CFu?4ssg@
  00b42	68 00 00 00 00	 push	 OFFSET _savegamename
  00b47	e8 00 00 00 00	 call	 _strlcat
  00b4c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1859 : 
; 1860 : 				reload = true;

  00b4f	c7 85 e8 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _reload$[ebp], 1

; 1861 : 			}

  00b59	e9 0a 01 00 00	 jmp	 $LN67@readmaincf
$LN58@readmaincf:

; 1862 : 			else if (!strcmp(word, "NUMEMBLEMS"))

  00b5e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LOIKKLLC@NUMEMBLEMS@
  00b63	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00b69	50		 push	 eax
  00b6a	e8 00 00 00 00	 call	 _strcmp
  00b6f	83 c4 08	 add	 esp, 8
  00b72	85 c0		 test	 eax, eax
  00b74	75 59		 jne	 SHORT $LN61@readmaincf

; 1863 : 			{
; 1864 : 				DEH_WriteUndoline(word, va("%d", numemblems-2), UNDO_NONE);

  00b76	6a 00		 push	 0
  00b78	a1 00 00 00 00	 mov	 eax, DWORD PTR _numemblems
  00b7d	83 e8 02	 sub	 eax, 2
  00b80	50		 push	 eax
  00b81	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00b86	e8 00 00 00 00	 call	 _va
  00b8b	83 c4 08	 add	 esp, 8
  00b8e	50		 push	 eax
  00b8f	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00b95	51		 push	 ecx
  00b96	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00b9b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1865 : 				numemblems = value+2;

  00b9e	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00ba4	83 c0 02	 add	 eax, 2
  00ba7	a3 00 00 00 00	 mov	 DWORD PTR _numemblems, eax

; 1866 : 				if (numemblems > MAXEMBLEMS-2)

  00bac	81 3d 00 00 00
	00 fe 01 00 00	 cmp	 DWORD PTR _numemblems, 510 ; 000001feH
  00bb6	7e 12		 jle	 SHORT $LN63@readmaincf

; 1867 : 					I_Error("Sorry, a maximum of %d emblems is allowed.\n", MAXEMBLEMS-2);

  00bb8	68 fe 01 00 00	 push	 510			; 000001feH
  00bbd	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@FNJPMFEA@Sorry?0?5a?5maximum?5of?5?$CFd?5emblems?5@
  00bc2	e8 00 00 00 00	 call	 _I_Error
  00bc7	83 c4 08	 add	 esp, 8
$LN63@readmaincf:

; 1868 : 			}

  00bca	e9 99 00 00 00	 jmp	 $LN67@readmaincf
$LN61@readmaincf:

; 1869 : 			else if (!strcmp(word, "RESETDATA"))

  00bcf	68 00 00 00 00	 push	 OFFSET ??_C@_09GDBIFKFH@RESETDATA@
  00bd4	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00bda	50		 push	 eax
  00bdb	e8 00 00 00 00	 call	 _strcmp
  00be0	83 c4 08	 add	 esp, 8
  00be3	85 c0		 test	 eax, eax
  00be5	75 27		 jne	 SHORT $LN64@readmaincf

; 1870 : 			{
; 1871 : 				DEH_WriteUndoline(word, "0", UNDO_TODO); /// \todo

  00be7	6a 00		 push	 0
  00be9	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  00bee	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00bf4	50		 push	 eax
  00bf5	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00bfa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1872 : 				P_ResetData(value);

  00bfd	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  00c03	50		 push	 eax
  00c04	e8 00 00 00 00	 call	 _P_ResetData
  00c09	83 c4 04	 add	 esp, 4

; 1873 : 			}

  00c0c	eb 5a		 jmp	 SHORT $LN67@readmaincf
$LN64@readmaincf:

; 1874 : 			else if (!strcmp(word, "CUSTOMVERSION"))

  00c0e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IMHIENOO@CUSTOMVERSION@
  00c13	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00c19	50		 push	 eax
  00c1a	e8 00 00 00 00	 call	 _strcmp
  00c1f	83 c4 08	 add	 esp, 8
  00c22	85 c0		 test	 eax, eax
  00c24	75 2e		 jne	 SHORT $LN66@readmaincf

; 1875 : 			{
; 1876 : 				DEH_WriteUndoline(word, customversionstring, UNDO_NONE);

  00c26	6a 00		 push	 0
  00c28	68 00 00 00 00	 push	 OFFSET _customversionstring
  00c2d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00c33	50		 push	 eax
  00c34	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00c39	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1877 : 				strlcpy(customversionstring, word2, sizeof (customversionstring));

  00c3c	6a 20		 push	 32			; 00000020H
  00c3e	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00c44	50		 push	 eax
  00c45	68 00 00 00 00	 push	 OFFSET _customversionstring
  00c4a	e8 00 00 00 00	 call	 _strlcpy
  00c4f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1878 : 			}

  00c52	eb 14		 jmp	 SHORT $LN67@readmaincf
$LN66@readmaincf:

; 1879 : 			else
; 1880 : 				deh_warning("Maincfg: unknown word '%s'", word);

  00c54	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00c5a	50		 push	 eax
  00c5b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DOOIFKJP@Maincfg?3?5unknown?5word?5?8?$CFs?8@
  00c60	e8 00 00 00 00	 call	 _deh_warning
  00c65	83 c4 08	 add	 esp, 8
$LN67@readmaincf:

; 1881 : 		}
; 1882 : 	} while (!myfeof(f));

  00c68	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00c6b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c6d	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00c70	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00c73	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00c76	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00c79	0f 87 ad f3 ff
	ff		 ja	 $LN4@readmaincf
$LN3@readmaincf:

; 1883 : 
; 1884 : 	if (reload)

  00c7f	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _reload$[ebp], 0
  00c86	74 06		 je	 SHORT $LN68@readmaincf

; 1885 : 		G_LoadGameData();

  00c88	e8 00 00 00 00	 call	 _G_LoadGameData
  00c8d	90		 npad	 1
$LN68@readmaincf:

; 1886 : }

  00c8e	5f		 pop	 edi
  00c8f	5e		 pop	 esi
  00c90	5b		 pop	 ebx
  00c91	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c94	33 cd		 xor	 ecx, ebp
  00c96	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c9b	8b e5		 mov	 esp, ebp
  00c9d	5d		 pop	 ebp
  00c9e	c3		 ret	 0
_readmaincfg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _GoodDataFileName
_TEXT	SEGMENT
_tail$ = -8						; size = 4
_p$ = -4						; size = 4
_s$ = 8							; size = 4
_GoodDataFileName PROC					; COMDAT

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1640 : 	const char *p;
; 1641 : 	const char *tail = ".dat";

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tail$[ebp], OFFSET ??_C@_04PBCOOEDG@?4dat@

; 1642 : 
; 1643 : 	for (p = s; *p != '\0'; p++)

  00010	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00013	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  00016	eb 09		 jmp	 SHORT $LN4@GoodDataFi
$LN2@GoodDataFi:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
$LN4@GoodDataFi:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00027	85 c9		 test	 ecx, ecx
  00029	74 3a		 je	 SHORT $LN3@GoodDataFi

; 1644 : 		if (!isalnum(*p) && *p != '_' && *p != '-' && *p != '.')

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0002e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _isalnum
  00037	83 c4 04	 add	 esp, 4
  0003a	85 c0		 test	 eax, eax
  0003c	75 25		 jne	 SHORT $LN5@GoodDataFi
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00041	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00044	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  00047	74 1a		 je	 SHORT $LN5@GoodDataFi
  00049	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0004c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004f	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00052	74 0f		 je	 SHORT $LN5@GoodDataFi
  00054	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00057	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005a	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  0005d	74 04		 je	 SHORT $LN5@GoodDataFi

; 1645 : 			return false;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 6f		 jmp	 SHORT $LN1@GoodDataFi
$LN5@GoodDataFi:
  00063	eb b3		 jmp	 SHORT $LN2@GoodDataFi
$LN3@GoodDataFi:

; 1646 : 
; 1647 : 	p = s + strlen(s) - strlen(tail);

  00065	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _strlen
  0006e	83 c4 04	 add	 esp, 4
  00071	8b f0		 mov	 esi, eax
  00073	03 75 08	 add	 esi, DWORD PTR _s$[ebp]
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _tail$[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _strlen
  0007f	83 c4 04	 add	 esp, 4
  00082	2b f0		 sub	 esi, eax
  00084	89 75 fc	 mov	 DWORD PTR _p$[ebp], esi

; 1648 : 	if (p <= s) return false; // too short

  00087	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0008a	3b 45 08	 cmp	 eax, DWORD PTR _s$[ebp]
  0008d	77 04		 ja	 SHORT $LN6@GoodDataFi
  0008f	33 c0		 xor	 eax, eax
  00091	eb 3f		 jmp	 SHORT $LN1@GoodDataFi
$LN6@GoodDataFi:

; 1649 : 	if (stricmp(p, tail) != 0) return false; // doesn't end in .dat

  00093	8b 45 f8	 mov	 eax, DWORD PTR _tail$[ebp]
  00096	50		 push	 eax
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _stricmp
  000a0	83 c4 08	 add	 esp, 8
  000a3	85 c0		 test	 eax, eax
  000a5	74 04		 je	 SHORT $LN7@GoodDataFi
  000a7	33 c0		 xor	 eax, eax
  000a9	eb 27		 jmp	 SHORT $LN1@GoodDataFi
$LN7@GoodDataFi:

; 1650 : 	if (stricmp(s, "gamedata.dat") == 0 && !disableundo) return false;

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JCMAOFIJ@gamedata?4dat@
  000b0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _stricmp
  000b9	83 c4 08	 add	 esp, 8
  000bc	85 c0		 test	 eax, eax
  000be	75 0d		 jne	 SHORT $LN8@GoodDataFi
  000c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _disableundo, 0
  000c7	75 04		 jne	 SHORT $LN8@GoodDataFi
  000c9	33 c0		 xor	 eax, eax
  000cb	eb 05		 jmp	 SHORT $LN1@GoodDataFi
$LN8@GoodDataFi:

; 1651 : 
; 1652 : 	return true;

  000cd	b8 01 00 00 00	 mov	 eax, 1
$LN1@GoodDataFi:

; 1653 : }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
_GoodDataFileName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readsound
_TEXT	SEGMENT
_value$ = -1040						; size = 4
_tmp$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_savesfxnames$ = 16					; size = 4
_readsound PROC						; COMDAT

; 1561 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 04 00
	00		 sub	 esp, 1232		; 000004d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
$LN4@readsound:

; 1562 : 	XBOXSTATIC char s[MAXLINELEN];
; 1563 : 	char *word;
; 1564 : 	char *tmp;
; 1565 : 	INT32 value;
; 1566 : 
; 1567 : 	do
; 1568 : 	{
; 1569 : 		if (myfgets(s, sizeof (s), f))

  00016	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00019	50		 push	 eax
  0001a	68 00 04 00 00	 push	 1024			; 00000400H
  0001f	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _myfgets
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 a8 01 00
	00		 je	 $LN15@readsound

; 1570 : 		{
; 1571 : 			if (s[0] == '\n')

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	6b c8 00	 imul	 ecx, eax, 0
  0003e	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00046	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00049	75 05		 jne	 SHORT $LN6@readsound

; 1572 : 				break;

  0004b	e9 a5 01 00 00	 jmp	 $LN3@readsound
$LN6@readsound:

; 1573 : 
; 1574 : 			tmp = strchr(s, '#');

  00050	6a 23		 push	 35			; 00000023H
  00052	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _strchr
  0005e	83 c4 08	 add	 esp, 8
  00061	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1575 : 			if (tmp)

  00067	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  0006e	74 09		 je	 SHORT $LN7@readsound

; 1576 : 				*tmp = '\0';

  00070	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00076	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readsound:

; 1577 : 
; 1578 : 			value = searchvalue(s);

  00079	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _searchvalue
  00085	83 c4 04	 add	 esp, 4
  00088	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax

; 1579 : 
; 1580 : 			word = strtok(s, " ");

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00093	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _strtok
  0009f	83 c4 08	 add	 esp, 8
  000a2	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 1581 : 			if (word)

  000a8	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  000af	74 11		 je	 SHORT $LN8@readsound

; 1582 : 				strupr(word);

  000b1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _strupr
  000bd	83 c4 04	 add	 esp, 4
  000c0	eb 05		 jmp	 SHORT $LN9@readsound
$LN8@readsound:

; 1583 : 			else
; 1584 : 				break;

  000c2	e9 2e 01 00 00	 jmp	 $LN3@readsound
$LN9@readsound:

; 1585 : 
; 1586 : /*			if (!strcmp(word, "OFFSET"))
; 1587 : 			{
; 1588 : 				value -= 150360;
; 1589 : 				if (value <= 64)
; 1590 : 					value /= 8;
; 1591 : 				else if (value <= 260)
; 1592 : 					value = (value+4)/8;
; 1593 : 				else
; 1594 : 					value = (value+8)/8;
; 1595 : 				if (value >= -1 && value < sfx_freeslot0 - 1)
; 1596 : 					S_sfx[num].name = savesfxnames[value+1];
; 1597 : 				else
; 1598 : 					deh_warning("Sound %d: offset out of bounds", num);
; 1599 : 			}
; 1600 : 			else */if (!strcmp(word, "SINGULAR"))

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_08LKHGAEML@SINGULAR@
  000cc	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _strcmp
  000d8	83 c4 08	 add	 esp, 8
  000db	85 c0		 test	 eax, eax
  000dd	75 3f		 jne	 SHORT $LN10@readsound

; 1601 : 			{
; 1602 : 				DEH_WriteUndoline(word, va("%d", S_sfx[num].singularity), UNDO_NONE);

  000df	6a 00		 push	 0
  000e1	6b 45 0c 2c	 imul	 eax, DWORD PTR _num$[ebp], 44
  000e5	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+4]
  000eb	51		 push	 ecx
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000f1	e8 00 00 00 00	 call	 _va
  000f6	83 c4 08	 add	 esp, 8
  000f9	50		 push	 eax
  000fa	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1603 : 				S_sfx[num].singularity = value;

  00109	6b 45 0c 2c	 imul	 eax, DWORD PTR _num$[ebp], 44
  0010d	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00113	89 88 04 00 00
	00		 mov	 DWORD PTR _S_sfx[eax+4], ecx

; 1604 : 			}

  00119	e9 c0 00 00 00	 jmp	 $LN15@readsound
$LN10@readsound:

; 1605 : 			else if (!strcmp(word, "PRIORITY"))

  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_08PHDJDNOC@PRIORITY@
  00123	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _strcmp
  0012f	83 c4 08	 add	 esp, 8
  00132	85 c0		 test	 eax, eax
  00134	75 3c		 jne	 SHORT $LN12@readsound

; 1606 : 			{
; 1607 : 				DEH_WriteUndoline(word, va("%d", S_sfx[num].priority), UNDO_NONE);

  00136	6a 00		 push	 0
  00138	6b 45 0c 2c	 imul	 eax, DWORD PTR _num$[ebp], 44
  0013c	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+8]
  00142	51		 push	 ecx
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00148	e8 00 00 00 00	 call	 _va
  0014d	83 c4 08	 add	 esp, 8
  00150	50		 push	 eax
  00151	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1608 : 				S_sfx[num].priority = value;

  00160	6b 45 0c 2c	 imul	 eax, DWORD PTR _num$[ebp], 44
  00164	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0016a	89 88 08 00 00
	00		 mov	 DWORD PTR _S_sfx[eax+8], ecx

; 1609 : 			}

  00170	eb 6c		 jmp	 SHORT $LN15@readsound
$LN12@readsound:

; 1610 : 			else if (!strcmp(word, "FLAGS"))

  00172	68 00 00 00 00	 push	 OFFSET ??_C@_05MNNEKIOP@FLAGS@
  00177	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _strcmp
  00183	83 c4 08	 add	 esp, 8
  00186	85 c0		 test	 eax, eax
  00188	75 3c		 jne	 SHORT $LN14@readsound

; 1611 : 			{
; 1612 : 				DEH_WriteUndoline(word, va("%d", S_sfx[num].pitch), UNDO_NONE);

  0018a	6a 00		 push	 0
  0018c	6b 45 0c 2c	 imul	 eax, DWORD PTR _num$[ebp], 44
  00190	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+12]
  00196	51		 push	 ecx
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0019c	e8 00 00 00 00	 call	 _va
  001a1	83 c4 08	 add	 esp, 8
  001a4	50		 push	 eax
  001a5	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  001ab	52		 push	 edx
  001ac	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 : 				S_sfx[num].pitch = value;

  001b4	6b 45 0c 2c	 imul	 eax, DWORD PTR _num$[ebp], 44
  001b8	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  001be	89 88 0c 00 00
	00		 mov	 DWORD PTR _S_sfx[eax+12], ecx

; 1614 : 			}

  001c4	eb 18		 jmp	 SHORT $LN15@readsound
$LN14@readsound:

; 1615 : 			else
; 1616 : 				deh_warning("Sound %d : unknown word '%s'",num,word);

  001c6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001cc	50		 push	 eax
  001cd	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  001d0	51		 push	 ecx
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OIKDCDHK@Sound?5?$CFd?5?3?5unknown?5word?5?8?$CFs?8@
  001d6	e8 00 00 00 00	 call	 _deh_warning
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@readsound:

; 1617 : 		}
; 1618 : 	} while (!myfeof(f));

  001de	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  001e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e3	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  001e6	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  001e9	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  001ec	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001ef	0f 87 21 fe ff
	ff		 ja	 $LN4@readsound
$LN3@readsound:

; 1619 : 	(void)savesfxnames;
; 1620 : }

  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	33 cd		 xor	 ecx, ebp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
_readsound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readframe
_TEXT	SEGMENT
$T1 = -1284						; size = 4
_actiontocompare$2 = -1088				; size = 32
_found$3 = -1056					; size = 4
_z$4 = -1052						; size = 4
_j$ = -1048						; size = 4
_i$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word1$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readframe PROC						; COMDAT

; 1437 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 05 00
	00		 sub	 esp, 1284		; 00000504H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1438 : 	XBOXSTATIC char s[MAXLINELEN];
; 1439 : 	char *word1;
; 1440 : 	char *word2 = NULL;

  00016	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _word2$[ebp], 0
$LN4@readframe:

; 1441 : 	char *tmp;
; 1442 : 	INT32 i, j;
; 1443 : 
; 1444 : 	do
; 1445 : 	{
; 1446 : 		if (myfgets(s, sizeof (s), f))

  00020	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00023	50		 push	 eax
  00024	68 00 04 00 00	 push	 1024			; 00000400H
  00029	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _myfgets
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 61 05 00
	00		 je	 $LN37@readframe

; 1447 : 		{
; 1448 : 			if (s[0] == '\n')

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	6b c8 00	 imul	 ecx, eax, 0
  00048	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00050	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00053	75 05		 jne	 SHORT $LN17@readframe

; 1449 : 				break;

  00055	e9 5e 05 00 00	 jmp	 $LN3@readframe
$LN17@readframe:

; 1450 : 
; 1451 : 			tmp = strchr(s, '#');

  0005a	6a 23		 push	 35			; 00000023H
  0005c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _strchr
  00068	83 c4 08	 add	 esp, 8
  0006b	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1452 : 			if (tmp)

  00071	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  00078	74 09		 je	 SHORT $LN18@readframe

; 1453 : 				*tmp = '\0';

  0007a	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00080	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN18@readframe:

; 1454 : 
; 1455 : 			for (j = 0; s[j] != '\n'; j++)

  00083	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  0008d	eb 0f		 jmp	 SHORT $LN7@readframe
$LN5@readframe:
  0008f	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], eax
$LN7@readframe:
  0009e	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000a4	0f be 8c 05 fc
	fb ff ff	 movsx	 ecx, BYTE PTR _s$[ebp+eax]
  000ac	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000af	74 42		 je	 SHORT $LN6@readframe

; 1456 : 			{
; 1457 : 				if (s[j] == '=')

  000b1	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000b7	0f be 8c 05 fc
	fb ff ff	 movsx	 ecx, BYTE PTR _s$[ebp+eax]
  000bf	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  000c2	75 2d		 jne	 SHORT $LN19@readframe

; 1458 : 				{
; 1459 : 					j += 2;

  000c4	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000ca	83 c0 02	 add	 eax, 2
  000cd	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 1460 : 					j = atoi(&s[j]);

  000d3	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  000d9	8d 8c 05 fc fb
	ff ff		 lea	 ecx, DWORD PTR _s$[ebp+eax]
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _atoi
  000e6	83 c4 04	 add	 esp, 4
  000e9	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], eax

; 1461 : 					break;

  000ef	eb 02		 jmp	 SHORT $LN6@readframe
$LN19@readframe:

; 1462 : 				}
; 1463 : 			}

  000f1	eb 9c		 jmp	 SHORT $LN5@readframe
$LN6@readframe:

; 1464 : 
; 1465 : 			word1 = strtok(s, " ");

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  000f8	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 _strtok
  00104	83 c4 08	 add	 esp, 8
  00107	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word1$[ebp], eax

; 1466 : 			if (word1)

  0010d	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word1$[ebp], 0
  00114	74 11		 je	 SHORT $LN20@readframe

; 1467 : 				strupr(word1);

  00116	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _strupr
  00122	83 c4 04	 add	 esp, 4
  00125	eb 05		 jmp	 SHORT $LN21@readframe
$LN20@readframe:

; 1468 : 			else
; 1469 : 				break;

  00127	e9 8c 04 00 00	 jmp	 $LN3@readframe
$LN21@readframe:

; 1470 : 
; 1471 : 			word2 = strtok(NULL, " = ");

  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_03MHLONNLM@?5?$DN?5@
  00131	6a 00		 push	 0
  00133	e8 00 00 00 00	 call	 _strtok
  00138	83 c4 08	 add	 esp, 8
  0013b	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], eax

; 1472 : 			if (word2)

  00141	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _word2$[ebp], 0
  00148	74 11		 je	 SHORT $LN22@readframe

; 1473 : 				strupr(word2);

  0014a	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _strupr
  00156	83 c4 04	 add	 esp, 4
  00159	eb 05		 jmp	 SHORT $LN23@readframe
$LN22@readframe:

; 1474 : 			else
; 1475 : 				break;

  0015b	e9 58 04 00 00	 jmp	 $LN3@readframe
$LN23@readframe:

; 1476 : 
; 1477 : 			word2[strlen(word2)-1] = '\0';

  00160	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _strlen
  0016c	83 c4 04	 add	 esp, 4
  0016f	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  00175	c6 44 01 ff 00	 mov	 BYTE PTR [ecx+eax-1], 0

; 1478 : 			i = atoi(word2);

  0017a	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _atoi
  00186	83 c4 04	 add	 esp, 4
  00189	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 1479 : 
; 1480 : 			if (!strcmp(word1, "SPRITENUMBER"))

  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FDNLMHGB@SPRITENUMBER@
  00194	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _strcmp
  001a0	83 c4 08	 add	 esp, 8
  001a3	85 c0		 test	 eax, eax
  001a5	75 3f		 jne	 SHORT $LN24@readframe

; 1481 : 			{
; 1482 : 				DEH_WriteUndoline(word1, va("%u", states[num].sprite), UNDO_NONE);

  001a7	6a 00		 push	 0
  001a9	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  001ad	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _states[eax]
  001b3	51		 push	 ecx
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  001b9	e8 00 00 00 00	 call	 _va
  001be	83 c4 08	 add	 esp, 8
  001c1	50		 push	 eax
  001c2	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  001c8	52		 push	 edx
  001c9	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1483 : 				states[num].sprite = i;

  001d1	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  001d5	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  001db	89 88 00 00 00
	00		 mov	 DWORD PTR _states[eax], ecx

; 1484 : 			}

  001e1	e9 bb 03 00 00	 jmp	 $LN37@readframe
$LN24@readframe:

; 1485 : 			else if (!strcmp(word1, "SPRITESUBNUMBER"))

  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DONIHLJC@SPRITESUBNUMBER@
  001eb	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _strcmp
  001f7	83 c4 08	 add	 esp, 8
  001fa	85 c0		 test	 eax, eax
  001fc	75 3f		 jne	 SHORT $LN26@readframe

; 1486 : 			{
; 1487 : 				DEH_WriteUndoline(word1, va("%d", states[num].frame), UNDO_NONE);

  001fe	6a 00		 push	 0
  00200	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00204	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _states[eax+4]
  0020a	51		 push	 ecx
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00210	e8 00 00 00 00	 call	 _va
  00215	83 c4 08	 add	 esp, 8
  00218	50		 push	 eax
  00219	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  0021f	52		 push	 edx
  00220	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00225	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1488 : 				states[num].frame = i;

  00228	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  0022c	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00232	89 88 04 00 00
	00		 mov	 DWORD PTR _states[eax+4], ecx

; 1489 : 			}

  00238	e9 64 03 00 00	 jmp	 $LN37@readframe
$LN26@readframe:

; 1490 : 			else if (!strcmp(word1, "DURATION"))

  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_08MJLDLDGF@DURATION@
  00242	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 _strcmp
  0024e	83 c4 08	 add	 esp, 8
  00251	85 c0		 test	 eax, eax
  00253	75 3f		 jne	 SHORT $LN28@readframe

; 1491 : 			{
; 1492 : 				DEH_WriteUndoline(word1, va("%u", states[num].tics), UNDO_NONE);

  00255	6a 00		 push	 0
  00257	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  0025b	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _states[eax+8]
  00261	51		 push	 ecx
  00262	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00267	e8 00 00 00 00	 call	 _va
  0026c	83 c4 08	 add	 esp, 8
  0026f	50		 push	 eax
  00270	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  00276	52		 push	 edx
  00277	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1493 : 				states[num].tics = i;

  0027f	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00283	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00289	89 88 08 00 00
	00		 mov	 DWORD PTR _states[eax+8], ecx

; 1494 : 			}

  0028f	e9 0d 03 00 00	 jmp	 $LN37@readframe
$LN28@readframe:

; 1495 : 			else if (!strcmp(word1, "NEXT"))

  00294	68 00 00 00 00	 push	 OFFSET ??_C@_04MOKMKBJN@NEXT@
  00299	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 _strcmp
  002a5	83 c4 08	 add	 esp, 8
  002a8	85 c0		 test	 eax, eax
  002aa	75 3f		 jne	 SHORT $LN30@readframe

; 1496 : 			{
; 1497 : 				DEH_WriteUndoline(word1, va("%d", states[num].nextstate), UNDO_NONE);

  002ac	6a 00		 push	 0
  002ae	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  002b2	8b 88 18 00 00
	00		 mov	 ecx, DWORD PTR _states[eax+24]
  002b8	51		 push	 ecx
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  002be	e8 00 00 00 00	 call	 _va
  002c3	83 c4 08	 add	 esp, 8
  002c6	50		 push	 eax
  002c7	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  002cd	52		 push	 edx
  002ce	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  002d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1498 : 				states[num].nextstate = i;

  002d6	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  002da	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  002e0	89 88 18 00 00
	00		 mov	 DWORD PTR _states[eax+24], ecx

; 1499 : 			}

  002e6	e9 b6 02 00 00	 jmp	 $LN37@readframe
$LN30@readframe:

; 1500 : 			else if (!strcmp(word1, "VAR1"))

  002eb	68 00 00 00 00	 push	 OFFSET ??_C@_04EEDPALN@VAR1@
  002f0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  002f6	50		 push	 eax
  002f7	e8 00 00 00 00	 call	 _strcmp
  002fc	83 c4 08	 add	 esp, 8
  002ff	85 c0		 test	 eax, eax
  00301	75 3f		 jne	 SHORT $LN32@readframe

; 1501 : 			{
; 1502 : 				DEH_WriteUndoline(word1, va("%d", states[num].var1), UNDO_NONE);

  00303	6a 00		 push	 0
  00305	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00309	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR _states[eax+16]
  0030f	51		 push	 ecx
  00310	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00315	e8 00 00 00 00	 call	 _va
  0031a	83 c4 08	 add	 esp, 8
  0031d	50		 push	 eax
  0031e	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  00324	52		 push	 edx
  00325	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1503 : 				states[num].var1 = i;

  0032d	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00331	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00337	89 88 10 00 00
	00		 mov	 DWORD PTR _states[eax+16], ecx

; 1504 : 			}

  0033d	e9 5f 02 00 00	 jmp	 $LN37@readframe
$LN32@readframe:

; 1505 : 			else if (!strcmp(word1, "VAR2"))

  00342	68 00 00 00 00	 push	 OFFSET ??_C@_04CPGOKDHO@VAR2@
  00347	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  0034d	50		 push	 eax
  0034e	e8 00 00 00 00	 call	 _strcmp
  00353	83 c4 08	 add	 esp, 8
  00356	85 c0		 test	 eax, eax
  00358	75 3f		 jne	 SHORT $LN34@readframe

; 1506 : 			{
; 1507 : 				DEH_WriteUndoline(word1, va("%d", states[num].var2), UNDO_NONE);

  0035a	6a 00		 push	 0
  0035c	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00360	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR _states[eax+20]
  00366	51		 push	 ecx
  00367	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0036c	e8 00 00 00 00	 call	 _va
  00371	83 c4 08	 add	 esp, 8
  00374	50		 push	 eax
  00375	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  0037b	52		 push	 edx
  0037c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00381	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1508 : 				states[num].var2 = i;

  00384	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00388	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0038e	89 88 14 00 00
	00		 mov	 DWORD PTR _states[eax+20], ecx

; 1509 : 			}

  00394	e9 08 02 00 00	 jmp	 $LN37@readframe
$LN34@readframe:

; 1510 : 			else if (!strcmp(word1, "ACTION"))

  00399	68 00 00 00 00	 push	 OFFSET ??_C@_06DHJAPAEE@ACTION@
  0039e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  003a4	50		 push	 eax
  003a5	e8 00 00 00 00	 call	 _strcmp
  003aa	83 c4 08	 add	 esp, 8
  003ad	85 c0		 test	 eax, eax
  003af	0f 85 d4 01 00
	00		 jne	 $LN36@readframe

; 1511 : 			{
; 1512 : 				size_t z;
; 1513 : 				boolean found = false;

  003b5	c7 85 e0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _found$3[ebp], 0

; 1514 : 				XBOXSTATIC char actiontocompare[32];
; 1515 : 
; 1516 : 				strlcpy(actiontocompare, word2, sizeof (actiontocompare));

  003bf	6a 20		 push	 32			; 00000020H
  003c1	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  003c7	50		 push	 eax
  003c8	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _actiontocompare$2[ebp]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 _strlcpy
  003d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1517 : 				strupr(actiontocompare);

  003d7	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _actiontocompare$2[ebp]
  003dd	50		 push	 eax
  003de	e8 00 00 00 00	 call	 _strupr
  003e3	83 c4 04	 add	 esp, 4

; 1518 : 
; 1519 : 				for (z = 0; z < 32; z++)

  003e6	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$4[ebp], 0
  003f0	eb 0f		 jmp	 SHORT $LN10@readframe
$LN8@readframe:
  003f2	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  003f8	83 c0 01	 add	 eax, 1
  003fb	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _z$4[ebp], eax
$LN10@readframe:
  00401	83 bd e4 fb ff
	ff 20		 cmp	 DWORD PTR _z$4[ebp], 32	; 00000020H
  00408	73 55		 jae	 SHORT $LN9@readframe

; 1520 : 				{
; 1521 : 					if (actiontocompare[z] == '\n' || actiontocompare[z] == '\r')

  0040a	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  00410	0f be 8c 05 c0
	fb ff ff	 movsx	 ecx, BYTE PTR _actiontocompare$2[ebp+eax]
  00418	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0041b	74 13		 je	 SHORT $LN39@readframe
  0041d	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  00423	0f be 8c 05 c0
	fb ff ff	 movsx	 ecx, BYTE PTR _actiontocompare$2[ebp+eax]
  0042b	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0042e	75 2d		 jne	 SHORT $LN38@readframe
$LN39@readframe:

; 1522 : 					{
; 1523 : 						actiontocompare[z] = '\0';

  00430	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  00436	89 85 fc fa ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0043c	83 bd fc fa ff
	ff 20		 cmp	 DWORD PTR $T1[ebp], 32	; 00000020H
  00443	73 02		 jae	 SHORT $LN44@readframe
  00445	eb 06		 jmp	 SHORT $LN45@readframe
$LN44@readframe:
  00447	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0044c	90		 npad	 1
$LN45@readframe:
  0044d	8b 8d fc fa ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00453	c6 84 0d c0 fb
	ff ff 00	 mov	 BYTE PTR _actiontocompare$2[ebp+ecx], 0

; 1524 : 						break;

  0045b	eb 02		 jmp	 SHORT $LN9@readframe
$LN38@readframe:

; 1525 : 					}
; 1526 : 				}

  0045d	eb 93		 jmp	 SHORT $LN8@readframe
$LN9@readframe:

; 1527 : 
; 1528 : 				for (z = 0; actionpointers[z].name; z++)

  0045f	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$4[ebp], 0
  00469	eb 0f		 jmp	 SHORT $LN13@readframe
$LN11@readframe:
  0046b	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  00471	83 c0 01	 add	 eax, 1
  00474	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _z$4[ebp], eax
$LN13@readframe:
  0047a	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  00480	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR _actionpointers[eax*8+4], 0
  00488	74 3c		 je	 SHORT $LN12@readframe

; 1529 : 				{
; 1530 : 					if (actionpointers[z].action.acv == states[num].action.acv)

  0048a	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  0048e	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR _z$4[ebp]
  00494	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR _actionpointers[ecx*8]
  0049b	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _states[eax+12]
  004a1	75 21		 jne	 SHORT $LN40@readframe

; 1531 : 					{
; 1532 : 						DEH_WriteUndoline(word1, actionpointers[z].name, UNDO_NONE);

  004a3	6a 00		 push	 0
  004a5	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  004ab	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _actionpointers[eax*8+4]
  004b2	51		 push	 ecx
  004b3	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word1$[ebp]
  004b9	52		 push	 edx
  004ba	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  004bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1533 : 						break;

  004c2	eb 02		 jmp	 SHORT $LN12@readframe
$LN40@readframe:

; 1534 : 					}
; 1535 : 				}

  004c4	eb a5		 jmp	 SHORT $LN11@readframe
$LN12@readframe:

; 1536 : 
; 1537 : 				z = 0;

  004c6	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _z$4[ebp], 0
$LN14@readframe:

; 1538 : 				while (actionpointers[z].name)

  004d0	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  004d6	83 3c c5 04 00
	00 00 00	 cmp	 DWORD PTR _actionpointers[eax*8+4], 0
  004de	0f 84 86 00 00
	00		 je	 $LN15@readframe

; 1539 : 				{
; 1540 : 					if (!strcmp(actiontocompare, actionpointers[z].name))

  004e4	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  004ea	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _actionpointers[eax*8+4]
  004f1	51		 push	 ecx
  004f2	8d 95 c0 fb ff
	ff		 lea	 edx, DWORD PTR _actiontocompare$2[ebp]
  004f8	52		 push	 edx
  004f9	e8 00 00 00 00	 call	 _strcmp
  004fe	83 c4 08	 add	 esp, 8
  00501	85 c0		 test	 eax, eax
  00503	75 51		 jne	 SHORT $LN41@readframe

; 1541 : 					{
; 1542 : 						states[num].action = actionpointers[z].action;

  00505	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  0050b	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _actionpointers[eax*8]
  00512	6b 55 0c 1c	 imul	 edx, DWORD PTR _num$[ebp], 28
  00516	89 8a 0c 00 00
	00		 mov	 DWORD PTR _states[edx+12], ecx

; 1543 : 						states[num].action.acv = actionpointers[z].action.acv; // assign

  0051c	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00520	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR _z$4[ebp]
  00526	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR _actionpointers[ecx*8]
  0052d	89 90 0c 00 00
	00		 mov	 DWORD PTR _states[eax+12], edx

; 1544 : 						states[num].action.acp1 = actionpointers[z].action.acp1;

  00533	6b 45 0c 1c	 imul	 eax, DWORD PTR _num$[ebp], 28
  00537	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR _z$4[ebp]
  0053d	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR _actionpointers[ecx*8]
  00544	89 90 0c 00 00
	00		 mov	 DWORD PTR _states[eax+12], edx

; 1545 : 						found = true;

  0054a	c7 85 e0 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _found$3[ebp], 1

; 1546 : 						break;

  00554	eb 14		 jmp	 SHORT $LN15@readframe
$LN41@readframe:

; 1547 : 					}
; 1548 : 					z++;

  00556	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _z$4[ebp]
  0055c	83 c0 01	 add	 eax, 1
  0055f	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _z$4[ebp], eax

; 1549 : 				}

  00565	e9 66 ff ff ff	 jmp	 $LN14@readframe
$LN15@readframe:

; 1550 : 
; 1551 : 				if (!found)

  0056a	83 bd e0 fb ff
	ff 00		 cmp	 DWORD PTR _found$3[ebp], 0
  00571	75 14		 jne	 SHORT $LN42@readframe

; 1552 : 					deh_warning("Unknown action %s", actiontocompare);

  00573	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _actiontocompare$2[ebp]
  00579	50		 push	 eax
  0057a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GEOOGJAL@Unknown?5action?5?$CFs@
  0057f	e8 00 00 00 00	 call	 _deh_warning
  00584	83 c4 08	 add	 esp, 8
$LN42@readframe:

; 1553 : 			}

  00587	eb 18		 jmp	 SHORT $LN37@readframe
$LN36@readframe:

; 1554 : 			else
; 1555 : 				deh_warning("Frame %d: unknown word '%s'", num, word1);

  00589	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word1$[ebp]
  0058f	50		 push	 eax
  00590	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00593	51		 push	 ecx
  00594	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LEECKIDM@Frame?5?$CFd?3?5unknown?5word?5?8?$CFs?8@
  00599	e8 00 00 00 00	 call	 _deh_warning
  0059e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@readframe:

; 1556 : 		}
; 1557 : 	} while (!myfeof(f));

  005a1	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  005a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  005a6	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  005a9	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  005ac	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  005af	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  005b2	0f 87 68 fa ff
	ff		 ja	 $LN4@readframe
$LN3@readframe:

; 1558 : }

  005b8	5f		 pop	 edi
  005b9	5e		 pop	 esi
  005ba	5b		 pop	 ebx
  005bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005be	33 cd		 xor	 ecx, ebp
  005c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005c5	8b e5		 mov	 esp, ebp
  005c7	5d		 pop	 ebp
  005c8	c3		 ret	 0
_readframe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readhuditem
_TEXT	SEGMENT
_i$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readhuditem PROC					; COMDAT

; 1241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1242 : 	XBOXSTATIC char s[MAXLINELEN];
; 1243 : 	char *word = s;

  00016	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0001c	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax
$LN4@readhudite:

; 1244 : 	char *word2;
; 1245 : 	char *tmp;
; 1246 : 	INT32 i;
; 1247 : 
; 1248 : 	do
; 1249 : 	{
; 1250 : 		if (myfgets(s, sizeof (s), f))

  00022	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00025	50		 push	 eax
  00026	68 00 04 00 00	 push	 1024			; 00000400H
  0002b	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _myfgets
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 9b 01 00
	00		 je	 $LN12@readhudite

; 1251 : 		{
; 1252 : 			if (s[0] == '\n')

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00052	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00055	75 05		 jne	 SHORT $LN6@readhudite

; 1253 : 				break;

  00057	e9 98 01 00 00	 jmp	 $LN3@readhudite
$LN6@readhudite:

; 1254 : 
; 1255 : 			// First remove trailing newline, if there is one
; 1256 : 			tmp = strchr(s, '\n');

  0005c	6a 0a		 push	 10			; 0000000aH
  0005e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _strchr
  0006a	83 c4 08	 add	 esp, 8
  0006d	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1257 : 			if (tmp)

  00073	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  0007a	74 09		 je	 SHORT $LN7@readhudite

; 1258 : 				*tmp = '\0';

  0007c	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readhudite:

; 1259 : 
; 1260 : 			tmp = strchr(s, '#');

  00085	6a 23		 push	 35			; 00000023H
  00087	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _strchr
  00093	83 c4 08	 add	 esp, 8
  00096	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1261 : 			if (tmp)

  0009c	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  000a3	74 09		 je	 SHORT $LN8@readhudite

; 1262 : 				*tmp = '\0';

  000a5	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000ab	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN8@readhudite:

; 1263 : 
; 1264 : 			// Get the part before the " = "
; 1265 : 			tmp = strchr(s, '=');

  000ae	6a 3d		 push	 61			; 0000003dH
  000b0	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _strchr
  000bc	83 c4 08	 add	 esp, 8
  000bf	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1266 : 			*(tmp-1) = '\0';

  000c5	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000cb	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 1267 : 			strupr(word);

  000cf	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _strupr
  000db	83 c4 04	 add	 esp, 4

; 1268 : 
; 1269 : 			// Now get the part after
; 1270 : 			word2 = tmp += 2;

  000de	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000e4	83 c0 02	 add	 eax, 2
  000e7	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax
  000ed	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _tmp$[ebp]
  000f3	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], ecx

; 1271 : 			strupr(word2);

  000f9	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _strupr
  00105	83 c4 04	 add	 esp, 4

; 1272 : 
; 1273 : 			i = atoi(word2); // used for numerical settings

  00108	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _atoi
  00114	83 c4 04	 add	 esp, 4
  00117	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 1274 : 
; 1275 : 			if (!strcmp(word, "X"))

  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_01MMEEDKFM@X@
  00122	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _strcmp
  0012e	83 c4 08	 add	 esp, 8
  00131	85 c0		 test	 eax, eax
  00133	75 3c		 jne	 SHORT $LN9@readhudite

; 1276 : 			{
; 1277 : 				DEH_WriteUndoline(word, va("%d", hudinfo[num].x), UNDO_NONE);

  00135	6a 00		 push	 0
  00137	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0013a	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _hudinfo[eax*8]
  00141	51		 push	 ecx
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00147	e8 00 00 00 00	 call	 _va
  0014c	83 c4 08	 add	 esp, 8
  0014f	50		 push	 eax
  00150	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00156	52		 push	 edx
  00157	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1278 : 				hudinfo[num].x = i;

  0015f	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00162	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00168	89 0c c5 00 00
	00 00		 mov	 DWORD PTR _hudinfo[eax*8], ecx

; 1279 : 			}

  0016f	eb 6c		 jmp	 SHORT $LN12@readhudite
$LN9@readhudite:

; 1280 : 			else if (!strcmp(word, "Y"))

  00171	68 00 00 00 00	 push	 OFFSET ??_C@_01NFFPALBN@Y@
  00176	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _strcmp
  00182	83 c4 08	 add	 esp, 8
  00185	85 c0		 test	 eax, eax
  00187	75 3c		 jne	 SHORT $LN11@readhudite

; 1281 : 			{
; 1282 : 				DEH_WriteUndoline(word, va("%d", hudinfo[num].y), UNDO_NONE);

  00189	6a 00		 push	 0
  0018b	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0018e	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _hudinfo[eax*8+4]
  00195	51		 push	 ecx
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0019b	e8 00 00 00 00	 call	 _va
  001a0	83 c4 08	 add	 esp, 8
  001a3	50		 push	 eax
  001a4	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  001aa	52		 push	 edx
  001ab	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1283 : 				hudinfo[num].y = i;

  001b3	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  001b6	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  001bc	89 0c c5 04 00
	00 00		 mov	 DWORD PTR _hudinfo[eax*8+4], ecx

; 1284 : 			}

  001c3	eb 18		 jmp	 SHORT $LN12@readhudite
$LN11@readhudite:

; 1285 : 			else
; 1286 : 				deh_warning("Level header %d: unknown word '%s'", num, word);

  001c5	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001cb	50		 push	 eax
  001cc	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  001cf	51		 push	 ecx
  001d0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DEOJKBPN@Level?5header?5?$CFd?3?5unknown?5word?5?8@
  001d5	e8 00 00 00 00	 call	 _deh_warning
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@readhudite:

; 1287 : 		}
; 1288 : 	} while (!myfeof(f)); // finish when the line is empty

  001dd	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  001e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e2	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  001e5	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  001e8	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  001eb	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001ee	0f 87 2e fe ff
	ff		 ja	 $LN4@readhudite
$LN3@readhudite:

; 1289 : }

  001f4	5f		 pop	 edi
  001f5	5e		 pop	 esi
  001f6	5b		 pop	 ebx
  001f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fa	33 cd		 xor	 ecx, ebp
  001fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00201	8b e5		 mov	 esp, ebp
  00203	5d		 pop	 ebp
  00204	c3		 ret	 0
_readhuditem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readunlockable
_TEXT	SEGMENT
_i$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readunlockable PROC					; COMDAT

; 1147 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1148 : 	XBOXSTATIC char s[MAXLINELEN];
; 1149 : 	char *word = s;

  00016	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0001c	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 1150 : 	char *word2;
; 1151 : 	char *tmp;
; 1152 : 	INT32 i;
; 1153 : 
; 1154 : 	DEH_WriteUndoline("NEEDEDEMBLEMS", va("%d", customsecretinfo[num].neededemblems), UNDO_NONE);

  00022	6a 00		 push	 0
  00024	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  0002b	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR _customsecretinfo[eax+132]
  00031	51		 push	 ecx
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00037	e8 00 00 00 00	 call	 _va
  0003c	83 c4 08	 add	 esp, 8
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OPFEEMIH@NEEDEDEMBLEMS@
  00045	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1155 : 	DEH_WriteUndoline("NEEDEDTIME", va("%d", customsecretinfo[num].neededtime), UNDO_NONE);

  0004d	6a 00		 push	 0
  0004f	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00056	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR _customsecretinfo[eax+136]
  0005c	51		 push	 ecx
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00062	e8 00 00 00 00	 call	 _va
  00067	83 c4 08	 add	 esp, 8
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NDOPDIK@NEEDEDTIME@
  00070	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1156 : 	DEH_WriteUndoline("NEEDEDGRADE", va("%d", customsecretinfo[num].neededgrade), UNDO_NONE);

  00078	6a 00		 push	 0
  0007a	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00081	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR _customsecretinfo[eax+128]
  00087	51		 push	 ecx
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0008d	e8 00 00 00 00	 call	 _va
  00092	83 c4 08	 add	 esp, 8
  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJAIOMKE@NEEDEDGRADE@
  0009b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1157 : 
; 1158 : 	customsecretinfo[num].neededemblems =

  000a3	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  000aa	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR _customsecretinfo[eax+128], 0
  000b4	69 4d 0c 94 00
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 148
  000bb	c7 81 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR _customsecretinfo[ecx+136], 0
  000c5	69 55 0c 94 00
	00 00		 imul	 edx, DWORD PTR _num$[ebp], 148
  000cc	c7 82 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR _customsecretinfo[edx+132], 0
$LN4@readunlock:

; 1159 : 	customsecretinfo[num].neededtime =
; 1160 : 	customsecretinfo[num].neededgrade = 0;
; 1161 : 
; 1162 : 	do
; 1163 : 	{
; 1164 : 		if (myfgets(s, sizeof (s), f))

  000d6	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  000d9	50		 push	 eax
  000da	68 00 04 00 00	 push	 1024			; 00000400H
  000df	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _myfgets
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	85 c0		 test	 eax, eax
  000f0	0f 84 67 03 00
	00		 je	 $LN22@readunlock

; 1165 : 		{
; 1166 : 			if (s[0] == '\n')

  000f6	b8 01 00 00 00	 mov	 eax, 1
  000fb	6b c8 00	 imul	 ecx, eax, 0
  000fe	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00106	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00109	75 05		 jne	 SHORT $LN6@readunlock

; 1167 : 				break;

  0010b	e9 64 03 00 00	 jmp	 $LN3@readunlock
$LN6@readunlock:

; 1168 : 
; 1169 : 			// First remove trailing newline, if there is one
; 1170 : 			tmp = strchr(s, '\n');

  00110	6a 0a		 push	 10			; 0000000aH
  00112	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _strchr
  0011e	83 c4 08	 add	 esp, 8
  00121	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1171 : 			if (tmp)

  00127	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  0012e	74 09		 je	 SHORT $LN7@readunlock

; 1172 : 				*tmp = '\0';

  00130	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readunlock:

; 1173 : 
; 1174 : 			tmp = strchr(s, '#');

  00139	6a 23		 push	 35			; 00000023H
  0013b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _strchr
  00147	83 c4 08	 add	 esp, 8
  0014a	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1175 : 			if (tmp)

  00150	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  00157	74 09		 je	 SHORT $LN8@readunlock

; 1176 : 				*tmp = '\0';

  00159	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  0015f	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN8@readunlock:

; 1177 : 
; 1178 : 			// Get the part before the " = "
; 1179 : 			tmp = strchr(s, '=');

  00162	6a 3d		 push	 61			; 0000003dH
  00164	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _strchr
  00170	83 c4 08	 add	 esp, 8
  00173	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1180 : 			*(tmp-1) = '\0';

  00179	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  0017f	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 1181 : 			strupr(word);

  00183	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 _strupr
  0018f	83 c4 04	 add	 esp, 4

; 1182 : 
; 1183 : 			// Now get the part after
; 1184 : 			word2 = tmp += 2;

  00192	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00198	83 c0 02	 add	 eax, 2
  0019b	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax
  001a1	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _tmp$[ebp]
  001a7	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], ecx

; 1185 : 			strupr(word2);

  001ad	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _strupr
  001b9	83 c4 04	 add	 esp, 4

; 1186 : 
; 1187 : 			i = atoi(word2); // used for numerical settings

  001bc	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 _atoi
  001c8	83 c4 04	 add	 esp, 4
  001cb	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 1188 : 
; 1189 : 			if (!strcmp(word, "NAME"))

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_04IPKHEEB@NAME@
  001d6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _strcmp
  001e2	83 c4 08	 add	 esp, 8
  001e5	85 c0		 test	 eax, eax
  001e7	75 42		 jne	 SHORT $LN9@readunlock

; 1190 : 			{
; 1191 : 				DEH_WriteUndoline(word, customsecretinfo[num].name, UNDO_NONE);

  001e9	6a 00		 push	 0
  001eb	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  001f2	05 00 00 00 00	 add	 eax, OFFSET _customsecretinfo
  001f7	50		 push	 eax
  001f8	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  001fe	51		 push	 ecx
  001ff	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00204	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1192 : 				strlcpy(customsecretinfo[num].name, word2, sizeof (customsecretinfo[num].name));

  00207	6a 40		 push	 64			; 00000040H
  00209	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0020f	50		 push	 eax
  00210	69 4d 0c 94 00
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 148
  00217	81 c1 00 00 00
	00		 add	 ecx, OFFSET _customsecretinfo
  0021d	51		 push	 ecx
  0021e	e8 00 00 00 00	 call	 _strlcpy
  00223	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1193 : 			}

  00226	e9 32 02 00 00	 jmp	 $LN22@readunlock
$LN9@readunlock:

; 1194 : 			else if (!strcmp(word, "OBJECTIVE"))

  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_09GKLCILOC@OBJECTIVE@
  00230	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 _strcmp
  0023c	83 c4 08	 add	 esp, 8
  0023f	85 c0		 test	 eax, eax
  00241	75 42		 jne	 SHORT $LN11@readunlock

; 1195 : 			{
; 1196 : 				DEH_WriteUndoline(word, customsecretinfo[num].objective, UNDO_NONE);

  00243	6a 00		 push	 0
  00245	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  0024c	05 40 00 00 00	 add	 eax, OFFSET _customsecretinfo+64
  00251	50		 push	 eax
  00252	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00258	51		 push	 ecx
  00259	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0025e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1197 : 				strlcpy(customsecretinfo[num].objective, word2, sizeof (customsecretinfo[num].objective));

  00261	6a 40		 push	 64			; 00000040H
  00263	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00269	50		 push	 eax
  0026a	69 4d 0c 94 00
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 148
  00271	81 c1 40 00 00
	00		 add	 ecx, OFFSET _customsecretinfo+64
  00277	51		 push	 ecx
  00278	e8 00 00 00 00	 call	 _strlcpy
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1198 : 			}

  00280	e9 d8 01 00 00	 jmp	 $LN22@readunlock
$LN11@readunlock:

; 1199 : 			else if (!strcmp(word, "NEEDEDGRADE"))

  00285	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJAIOMKE@NEEDEDGRADE@
  0028a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 _strcmp
  00296	83 c4 08	 add	 esp, 8
  00299	85 c0		 test	 eax, eax
  0029b	75 18		 jne	 SHORT $LN13@readunlock

; 1200 : 			{
; 1201 : 				//DEH_WriteUndoline(word, va("%d", customsecretinfo[num].neededgrade), UNDO_NONE);
; 1202 : 				customsecretinfo[num].neededgrade = i;

  0029d	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  002a4	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  002aa	89 88 80 00 00
	00		 mov	 DWORD PTR _customsecretinfo[eax+128], ecx

; 1203 : 			}

  002b0	e9 a8 01 00 00	 jmp	 $LN22@readunlock
$LN13@readunlock:

; 1204 : 			else if (!strcmp(word, "NEEDEDEMBLEMS"))

  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OPFEEMIH@NEEDEDEMBLEMS@
  002ba	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 _strcmp
  002c6	83 c4 08	 add	 esp, 8
  002c9	85 c0		 test	 eax, eax
  002cb	75 18		 jne	 SHORT $LN15@readunlock

; 1205 : 			{
; 1206 : 				//DEH_WriteUndoline(word, va("%d", customsecretinfo[num].neededemblems), UNDO_NONE);
; 1207 : 				customsecretinfo[num].neededemblems = i;

  002cd	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  002d4	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  002da	89 88 84 00 00
	00		 mov	 DWORD PTR _customsecretinfo[eax+132], ecx

; 1208 : 			}

  002e0	e9 78 01 00 00	 jmp	 $LN22@readunlock
$LN15@readunlock:

; 1209 : 			else if (!strcmp(word, "NEEDEDTIME"))

  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NDOPDIK@NEEDEDTIME@
  002ea	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 _strcmp
  002f6	83 c4 08	 add	 esp, 8
  002f9	85 c0		 test	 eax, eax
  002fb	75 18		 jne	 SHORT $LN17@readunlock

; 1210 : 			{
; 1211 : 				//DEH_WriteUndoline(word, va("%d", customsecretinfo[num].neededtime), UNDO_NONE);
; 1212 : 				customsecretinfo[num].neededtime = i;

  002fd	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00304	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0030a	89 88 88 00 00
	00		 mov	 DWORD PTR _customsecretinfo[eax+136], ecx

; 1213 : 			}

  00310	e9 48 01 00 00	 jmp	 $LN22@readunlock
$LN17@readunlock:

; 1214 : 			else if (!strcmp(word, "TYPE"))

  00315	68 00 00 00 00	 push	 OFFSET ??_C@_04KDPJLEDB@TYPE@
  0031a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 _strcmp
  00326	83 c4 08	 add	 esp, 8
  00329	85 c0		 test	 eax, eax
  0032b	75 45		 jne	 SHORT $LN19@readunlock

; 1215 : 			{
; 1216 : 				DEH_WriteUndoline(word, va("%d", customsecretinfo[num].type), UNDO_NONE);

  0032d	6a 00		 push	 0
  0032f	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00336	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR _customsecretinfo[eax+140]
  0033c	51		 push	 ecx
  0033d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00342	e8 00 00 00 00	 call	 _va
  00347	83 c4 08	 add	 esp, 8
  0034a	50		 push	 eax
  0034b	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00351	52		 push	 edx
  00352	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1217 : 				customsecretinfo[num].type = i;

  0035a	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00361	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00367	89 88 8c 00 00
	00		 mov	 DWORD PTR _customsecretinfo[eax+140], ecx

; 1218 : 			}

  0036d	e9 eb 00 00 00	 jmp	 $LN22@readunlock
$LN19@readunlock:

; 1219 : 			else if (!strcmp(word, "VAR"))

  00372	68 00 00 00 00	 push	 OFFSET ??_C@_03MJAIKILM@VAR@
  00377	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 _strcmp
  00383	83 c4 08	 add	 esp, 8
  00386	85 c0		 test	 eax, eax
  00388	0f 85 b4 00 00
	00		 jne	 $LN21@readunlock

; 1220 : 			{
; 1221 : 				if (customsecretinfo[num].type == 1)

  0038e	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00395	83 b8 8c 00 00
	00 01		 cmp	 DWORD PTR _customsecretinfo[eax+140], 1
  0039c	75 62		 jne	 SHORT $LN24@readunlock

; 1222 : 				{
; 1223 : 					// Support using the actual map name,
; 1224 : 					// i.e., Level AB, Level FZ, etc.
; 1225 : 
; 1226 : 					// Convert to map number
; 1227 : 					if (word2[0] >= 'A' && word2[0] <= 'Z')

  0039e	b8 01 00 00 00	 mov	 eax, 1
  003a3	6b c8 00	 imul	 ecx, eax, 0
  003a6	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  003ac	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  003b0	83 f8 41	 cmp	 eax, 65			; 00000041H
  003b3	7c 4b		 jl	 SHORT $LN24@readunlock
  003b5	b8 01 00 00 00	 mov	 eax, 1
  003ba	6b c8 00	 imul	 ecx, eax, 0
  003bd	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  003c3	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  003c7	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  003ca	7f 34		 jg	 SHORT $LN24@readunlock

; 1228 : 						i = M_MapNumber(word2[0], word2[1]);

  003cc	b8 01 00 00 00	 mov	 eax, 1
  003d1	c1 e0 00	 shl	 eax, 0
  003d4	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  003da	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003de	52		 push	 edx
  003df	b8 01 00 00 00	 mov	 eax, 1
  003e4	6b c8 00	 imul	 ecx, eax, 0
  003e7	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  003ed	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 _M_MapNumber
  003f7	83 c4 08	 add	 esp, 8
  003fa	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN24@readunlock:

; 1229 : 				}
; 1230 : 
; 1231 : 				DEH_WriteUndoline(word, va("%d", customsecretinfo[num].variable), UNDO_NONE);

  00400	6a 00		 push	 0
  00402	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00409	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR _customsecretinfo[eax+144]
  0040f	51		 push	 ecx
  00410	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00415	e8 00 00 00 00	 call	 _va
  0041a	83 c4 08	 add	 esp, 8
  0041d	50		 push	 eax
  0041e	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00424	52		 push	 edx
  00425	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0042a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 : 				customsecretinfo[num].variable = i;

  0042d	69 45 0c 94 00
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 148
  00434	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0043a	89 88 90 00 00
	00		 mov	 DWORD PTR _customsecretinfo[eax+144], ecx

; 1233 : 			}

  00440	eb 1b		 jmp	 SHORT $LN22@readunlock
$LN21@readunlock:

; 1234 : 			else
; 1235 : 				deh_warning("Unlockable %d: unknown word '%s'", num+1, word);

  00442	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00448	50		 push	 eax
  00449	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0044c	83 c1 01	 add	 ecx, 1
  0044f	51		 push	 ecx
  00450	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNJBHKCI@Unlockable?5?$CFd?3?5unknown?5word?5?8?$CFs@
  00455	e8 00 00 00 00	 call	 _deh_warning
  0045a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@readunlock:

; 1236 : 		}
; 1237 : 	} while (!myfeof(f)); // finish when the line is empty

  0045d	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00460	8b 08		 mov	 ecx, DWORD PTR [eax]
  00462	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00465	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00468	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0046b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0046e	0f 87 62 fc ff
	ff		 ja	 $LN4@readunlock
$LN3@readunlock:

; 1238 : }

  00474	5f		 pop	 edi
  00475	5e		 pop	 esi
  00476	5b		 pop	 ebx
  00477	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047a	33 cd		 xor	 ecx, ebp
  0047c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00481	8b e5		 mov	 esp, ebp
  00483	5d		 pop	 ebp
  00484	c3		 ret	 0
_readunlockable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readcutscene
_TEXT	SEGMENT
_oldnumscenes$ = -1048					; size = 4
_value$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readcutscene PROC					; COMDAT

; 1090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 04 00
	00		 sub	 esp, 1240		; 000004d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1091 : 	XBOXSTATIC char s[MAXLINELEN];
; 1092 : 	char *word;
; 1093 : 	char *word2;
; 1094 : 	char *tmp;
; 1095 : 	INT32 value;
; 1096 : 	const INT32 oldnumscenes = cutscenes[num].numscenes;

  00016	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0001d	8b 88 00 52 00
	00		 mov	 ecx, DWORD PTR _cutscenes[eax+20992]
  00023	89 8d e8 fb ff
	ff		 mov	 DWORD PTR _oldnumscenes$[ebp], ecx
$LN4@readcutsce:

; 1097 : 
; 1098 : 	do
; 1099 : 	{
; 1100 : 		if (myfgets(s, sizeof (s), f))

  00029	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0002c	50		 push	 eax
  0002d	68 00 04 00 00	 push	 1024			; 00000400H
  00032	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _myfgets
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	85 c0		 test	 eax, eax
  00043	0f 84 b1 01 00
	00		 je	 $LN15@readcutsce

; 1101 : 		{
; 1102 : 			if (s[0] == '\n')

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	6b c8 00	 imul	 ecx, eax, 0
  00051	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00059	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0005c	75 05		 jne	 SHORT $LN6@readcutsce

; 1103 : 				break;

  0005e	e9 ae 01 00 00	 jmp	 $LN3@readcutsce
$LN6@readcutsce:

; 1104 : 
; 1105 : 			tmp = strchr(s, '#');

  00063	6a 23		 push	 35			; 00000023H
  00065	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _strchr
  00071	83 c4 08	 add	 esp, 8
  00074	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 1106 : 			if (tmp)

  0007a	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  00081	74 09		 je	 SHORT $LN7@readcutsce

; 1107 : 				*tmp = '\0';

  00083	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00089	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readcutsce:

; 1108 : 
; 1109 : 			word = strtok(s, " ");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00091	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _strtok
  0009d	83 c4 08	 add	 esp, 8
  000a0	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 1110 : 			if (word)

  000a6	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  000ad	74 11		 je	 SHORT $LN8@readcutsce

; 1111 : 				strupr(word);

  000af	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _strupr
  000bb	83 c4 04	 add	 esp, 4
  000be	eb 05		 jmp	 SHORT $LN9@readcutsce
$LN8@readcutsce:

; 1112 : 			else
; 1113 : 				break;

  000c0	e9 4c 01 00 00	 jmp	 $LN3@readcutsce
$LN9@readcutsce:

; 1114 : 
; 1115 : 			word2 = strtok(NULL, " ");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 _strtok
  000d1	83 c4 08	 add	 esp, 8
  000d4	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], eax

; 1116 : 			if (word2)

  000da	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _word2$[ebp], 0
  000e1	74 17		 je	 SHORT $LN10@readcutsce

; 1117 : 				value = atoi(word2);

  000e3	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _atoi
  000ef	83 c4 04	 add	 esp, 4
  000f2	89 85 ec fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax
  000f8	eb 19		 jmp	 SHORT $LN11@readcutsce
$LN10@readcutsce:

; 1118 : 			else
; 1119 : 			{
; 1120 : 				deh_warning("No value for token %s", word);

  000fa	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00100	50		 push	 eax
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KFBFNACM@No?5value?5for?5token?5?$CFs@
  00106	e8 00 00 00 00	 call	 _deh_warning
  0010b	83 c4 08	 add	 esp, 8

; 1121 : 				continue;

  0010e	e9 e7 00 00 00	 jmp	 $LN15@readcutsce
$LN11@readcutsce:

; 1122 : 			}
; 1123 : 
; 1124 : 			if (!strcmp(word, "NUMSCENES"))

  00113	68 00 00 00 00	 push	 OFFSET ??_C@_09IBLFEBPM@NUMSCENES@
  00118	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _strcmp
  00124	83 c4 08	 add	 esp, 8
  00127	85 c0		 test	 eax, eax
  00129	75 18		 jne	 SHORT $LN12@readcutsce

; 1125 : 			{
; 1126 : 				cutscenes[num].numscenes = value;

  0012b	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00132	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00138	89 88 00 52 00
	00		 mov	 DWORD PTR _cutscenes[eax+20992], ecx

; 1127 : 			}

  0013e	e9 b7 00 00 00	 jmp	 $LN15@readcutsce
$LN12@readcutsce:

; 1128 : 			else if (!strcmp(word, "SCENE"))

  00143	68 00 00 00 00	 push	 OFFSET ??_C@_05IALELFBJ@SCENE@
  00148	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _strcmp
  00154	83 c4 08	 add	 esp, 8
  00157	85 c0		 test	 eax, eax
  00159	0f 85 83 00 00
	00		 jne	 $LN14@readcutsce

; 1129 : 			{
; 1130 : 				if (1 <= value && value <= 128)

  0015f	83 bd ec fb ff
	ff 01		 cmp	 DWORD PTR _value$[ebp], 1
  00166	7c 64		 jl	 SHORT $LN16@readcutsce
  00168	81 bd ec fb ff
	ff 80 00 00 00	 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00172	7f 58		 jg	 SHORT $LN16@readcutsce

; 1131 : 				{
; 1132 : 					readcutscenescene(f, num, value - 1);

  00174	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  0017a	83 e8 01	 sub	 eax, 1
  0017d	50		 push	 eax
  0017e	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00181	51		 push	 ecx
  00182	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _readcutscenescene
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1133 : 					DEH_WriteUndoline(word, word2, UNDO_SPACE|UNDO_CUTLINE);

  0018e	6a 06		 push	 6
  00190	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00196	50		 push	 eax
  00197	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1134 : 					DEH_WriteUndoline("NUMSCENES", va("%d", oldnumscenes), UNDO_SPACE);

  001a6	6a 02		 push	 2
  001a8	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _oldnumscenes$[ebp]
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001b4	e8 00 00 00 00	 call	 _va
  001b9	83 c4 08	 add	 esp, 8
  001bc	50		 push	 eax
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_09IBLFEBPM@NUMSCENES@
  001c2	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1135 : 				}

  001ca	eb 14		 jmp	 SHORT $LN17@readcutsce
$LN16@readcutsce:

; 1136 : 				else
; 1137 : 					deh_warning("Scene number %d out of range", value);

  001cc	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _value$[ebp]
  001d2	50		 push	 eax
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HKLMADIL@Scene?5number?5?$CFd?5out?5of?5range@
  001d8	e8 00 00 00 00	 call	 _deh_warning
  001dd	83 c4 08	 add	 esp, 8
$LN17@readcutsce:

; 1138 : 
; 1139 : 			}

  001e0	eb 18		 jmp	 SHORT $LN15@readcutsce
$LN14@readcutsce:

; 1140 : 			else
; 1141 : 				deh_warning("Cutscene %d: unknown word '%s', Scene <num> expected.", num, word);

  001e2	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  001ec	51		 push	 ecx
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@GFCLHAEP@Cutscene?5?$CFd?3?5unknown?5word?5?8?$CFs?8?0@
  001f2	e8 00 00 00 00	 call	 _deh_warning
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@readcutsce:

; 1142 : 		}
; 1143 : 	} while (!myfeof(f)); // finish when the line is empty

  001fa	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  001fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ff	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00202	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00205	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00208	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0020b	0f 87 18 fe ff
	ff		 ja	 $LN4@readcutsce
$LN3@readcutsce:

; 1144 : }

  00211	5f		 pop	 edi
  00212	5e		 pop	 esi
  00213	5b		 pop	 ebx
  00214	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00217	33 cd		 xor	 ecx, ebp
  00219	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c3		 ret	 0
_readcutscene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readcutscenescene
_TEXT	SEGMENT
$T1 = -5660						; size = 4
_buffer$2 = -5144					; size = 4096
_scenetext$3 = -1048					; size = 4
_usi$ = -1044						; size = 2
_i$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_scenenum$ = 16						; size = 4
_readcutscenescene PROC					; COMDAT

; 781  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 1c 16 00 00	 mov	 eax, 5660		; 0000161cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 782  : 	XBOXSTATIC char s[MAXLINELEN] = "";

  0001a	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001f	88 85 fc fb ff
	ff		 mov	 BYTE PTR _s$[ebp], al
  00025	68 ff 03 00 00	 push	 1023			; 000003ffH
  0002a	6a 00		 push	 0
  0002c	8d 85 fd fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp+1]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _memset
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 783  : 	char *word;
; 784  : 	char *word2;
; 785  : 	INT32 i;
; 786  : 	UINT16 usi;
; 787  : 
; 788  : 	DEH_WriteUndoline("SCENETEXT", cutscenes[num].scene[scenenum].text, UNDO_ENDTEXT);

  0003b	6a 08		 push	 8
  0003d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00044	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0004b	8b 94 08 64 00
	00 00		 mov	 edx, DWORD PTR _cutscenes[eax+ecx+100]
  00052	52		 push	 edx
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_09FOLEOKCO@SCENETEXT@
  00058	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@readcutsce:

; 789  : 
; 790  : 	do
; 791  : 	{
; 792  : 		if (myfgets(s, sizeof (s), f))

  00060	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00063	50		 push	 eax
  00064	68 00 04 00 00	 push	 1024			; 00000400H
  00069	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _myfgets
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	85 c0		 test	 eax, eax
  0007a	0f 84 1a 1a 00
	00		 je	 $LN110@readcutsce

; 793  : 		{
; 794  : 			if (s[0] == '\n')

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	6b c8 00	 imul	 ecx, eax, 0
  00088	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00090	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00093	75 05		 jne	 SHORT $LN12@readcutsce

; 795  : 				break;

  00095	e9 17 1a 00 00	 jmp	 $LN3@readcutsce
$LN12@readcutsce:

; 796  : 
; 797  : 			word = strtok(s, " ");

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0009f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _strtok
  000ab	83 c4 08	 add	 esp, 8
  000ae	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 798  : 			if (word)

  000b4	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  000bb	74 11		 je	 SHORT $LN13@readcutsce

; 799  : 				strupr(word);

  000bd	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _strupr
  000c9	83 c4 04	 add	 esp, 4
  000cc	eb 05		 jmp	 SHORT $LN14@readcutsce
$LN13@readcutsce:

; 800  : 			else
; 801  : 				break;

  000ce	e9 de 19 00 00	 jmp	 $LN3@readcutsce
$LN14@readcutsce:

; 802  : 
; 803  : 			if (!strcmp(word, "SCENETEXT"))

  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_09FOLEOKCO@SCENETEXT@
  000d8	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _strcmp
  000e4	83 c4 08	 add	 esp, 8
  000e7	85 c0		 test	 eax, eax
  000e9	0f 85 d7 01 00
	00		 jne	 $LN15@readcutsce

; 804  : 			{
; 805  : 				char *scenetext = NULL;

  000ef	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _scenetext$3[ebp], 0

; 806  : 				XBOXSTATIC char buffer[4096] = "";

  000f9	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  000fe	88 85 e8 eb ff
	ff		 mov	 BYTE PTR _buffer$2[ebp], al
  00104	68 ff 0f 00 00	 push	 4095			; 00000fffH
  00109	6a 00		 push	 0
  0010b	8d 85 e9 eb ff
	ff		 lea	 eax, DWORD PTR _buffer$2[ebp+1]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _memset
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH

; 807  : 				for (i = 0; i < MAXLINELEN; i++)

  0011a	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00124	eb 0f		 jmp	 SHORT $LN7@readcutsce
$LN5@readcutsce:
  00126	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0012c	83 c0 01	 add	 eax, 1
  0012f	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN7@readcutsce:
  00135	81 bd f0 fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR _i$[ebp], 1024 ; 00000400H
  0013f	7d 2a		 jge	 SHORT $LN6@readcutsce

; 808  : 				{
; 809  : 					if (s[i] == '=')

  00141	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00147	0f be 8c 05 fc
	fb ff ff	 movsx	 ecx, BYTE PTR _s$[ebp+eax]
  0014f	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00152	75 15		 jne	 SHORT $LN16@readcutsce

; 810  : 					{
; 811  : 						scenetext = &s[i+2];

  00154	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0015a	8d 8c 05 fe fb
	ff ff		 lea	 ecx, DWORD PTR _s$[ebp+eax+2]
  00161	89 8d e8 fb ff
	ff		 mov	 DWORD PTR _scenetext$3[ebp], ecx

; 812  : 						break;

  00167	eb 02		 jmp	 SHORT $LN6@readcutsce
$LN16@readcutsce:

; 813  : 					}
; 814  : 				}

  00169	eb bb		 jmp	 SHORT $LN5@readcutsce
$LN6@readcutsce:

; 815  : 
; 816  : 				if (!scenetext)

  0016b	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _scenetext$3[ebp], 0
  00172	75 3c		 jne	 SHORT $LN17@readcutsce

; 817  : 				{
; 818  : 					Z_Free(cutscenes[num].scene[scenenum].text);

  00174	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0017b	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00182	8b 94 08 64 00
	00 00		 mov	 edx, DWORD PTR _cutscenes[eax+ecx+100]
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 _Z_Free
  0018f	83 c4 04	 add	 esp, 4

; 819  : 					cutscenes[num].scene[scenenum].text = NULL;

  00192	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00199	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  001a0	c7 84 08 64 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _cutscenes[eax+ecx+100], 0

; 820  : 					continue;

  001ab	e9 ea 18 00 00	 jmp	 $LN110@readcutsce
$LN17@readcutsce:

; 821  : 				}
; 822  : 
; 823  : 				for (i = 0; i < MAXLINELEN; i++)

  001b0	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  001ba	eb 0f		 jmp	 SHORT $LN10@readcutsce
$LN8@readcutsce:
  001bc	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001c2	83 c0 01	 add	 eax, 1
  001c5	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN10@readcutsce:
  001cb	81 bd f0 fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR _i$[ebp], 1024 ; 00000400H
  001d5	7d 55		 jge	 SHORT $LN9@readcutsce

; 824  : 				{
; 825  : 					if (s[i] == '\0')

  001d7	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001dd	0f be 8c 05 fc
	fb ff ff	 movsx	 ecx, BYTE PTR _s$[ebp+eax]
  001e5	85 c9		 test	 ecx, ecx
  001e7	75 41		 jne	 SHORT $LN18@readcutsce

; 826  : 					{
; 827  : 						s[i] = '\n';

  001e9	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001ef	c6 84 05 fc fb
	ff ff 0a	 mov	 BYTE PTR _s$[ebp+eax], 10 ; 0000000aH

; 828  : 						s[i+1] = '\0';

  001f7	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001fd	83 c0 01	 add	 eax, 1
  00200	89 85 e4 e9 ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00206	81 bd e4 e9 ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  00210	73 02		 jae	 SHORT $LN112@readcutsce
  00212	eb 06		 jmp	 SHORT $LN113@readcutsce
$LN112@readcutsce:
  00214	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00219	90		 npad	 1
$LN113@readcutsce:
  0021a	8b 8d e4 e9 ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00220	c6 84 0d fc fb
	ff ff 00	 mov	 BYTE PTR _s$[ebp+ecx], 0

; 829  : 						break;

  00228	eb 02		 jmp	 SHORT $LN9@readcutsce
$LN18@readcutsce:

; 830  : 					}
; 831  : 				}

  0022a	eb 90		 jmp	 SHORT $LN8@readcutsce
$LN9@readcutsce:

; 832  : 
; 833  : 				strcpy(buffer, scenetext);

  0022c	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _scenetext$3[ebp]
  00232	50		 push	 eax
  00233	8d 8d e8 eb ff
	ff		 lea	 ecx, DWORD PTR _buffer$2[ebp]
  00239	51		 push	 ecx
  0023a	e8 00 00 00 00	 call	 _strcpy
  0023f	83 c4 08	 add	 esp, 8

; 834  : 
; 835  : 				strcat(buffer,

  00242	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00245	50		 push	 eax
  00246	8d 8d e8 eb ff
	ff		 lea	 ecx, DWORD PTR _buffer$2[ebp]
  0024c	51		 push	 ecx
  0024d	e8 00 00 00 00	 call	 _strlen
  00252	83 c4 04	 add	 esp, 4
  00255	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0025a	2b d0		 sub	 edx, eax
  0025c	83 ea 01	 sub	 edx, 1
  0025f	52		 push	 edx
  00260	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _scenetext$3[ebp]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 _myhashfgets
  0026c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026f	50		 push	 eax
  00270	8d 8d e8 eb ff
	ff		 lea	 ecx, DWORD PTR _buffer$2[ebp]
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 _strcat
  0027c	83 c4 08	 add	 esp, 8

; 836  : 					myhashfgets(scenetext, sizeof (buffer)
; 837  : 					- strlen(buffer) - 1, f));
; 838  : 
; 839  : 				// A cutscene overwriting another one...
; 840  : 				Z_Free(cutscenes[num].scene[scenenum].text);

  0027f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00286	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0028d	8b 94 08 64 00
	00 00		 mov	 edx, DWORD PTR _cutscenes[eax+ecx+100]
  00294	52		 push	 edx
  00295	e8 00 00 00 00	 call	 _Z_Free
  0029a	83 c4 04	 add	 esp, 4

; 841  : 
; 842  : 				cutscenes[num].scene[scenenum].text = Z_StrDup(buffer);

  0029d	8d 85 e8 eb ff
	ff		 lea	 eax, DWORD PTR _buffer$2[ebp]
  002a3	50		 push	 eax
  002a4	e8 00 00 00 00	 call	 _Z_StrDup
  002a9	83 c4 04	 add	 esp, 4
  002ac	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  002b3	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  002ba	89 84 11 64 00
	00 00		 mov	 DWORD PTR _cutscenes[ecx+edx+100], eax

; 843  : 
; 844  : 				continue;

  002c1	e9 d4 17 00 00	 jmp	 $LN110@readcutsce
$LN15@readcutsce:

; 845  : 			}
; 846  : 
; 847  : 			word2 = strtok(NULL, " = ");

  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_03MHLONNLM@?5?$DN?5@
  002cb	6a 00		 push	 0
  002cd	e8 00 00 00 00	 call	 _strtok
  002d2	83 c4 08	 add	 esp, 8
  002d5	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], eax

; 848  : 			if (word2)

  002db	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _word2$[ebp], 0
  002e2	74 11		 je	 SHORT $LN19@readcutsce

; 849  : 				strupr(word2);

  002e4	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  002ea	50		 push	 eax
  002eb	e8 00 00 00 00	 call	 _strupr
  002f0	83 c4 04	 add	 esp, 4
  002f3	eb 05		 jmp	 SHORT $LN20@readcutsce
$LN19@readcutsce:

; 850  : 			else
; 851  : 				break;

  002f5	e9 b7 17 00 00	 jmp	 $LN3@readcutsce
$LN20@readcutsce:

; 852  : 
; 853  : 			word2[strlen(word2)-1] = '\0';

  002fa	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00300	50		 push	 eax
  00301	e8 00 00 00 00	 call	 _strlen
  00306	83 c4 04	 add	 esp, 4
  00309	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  0030f	c6 44 01 ff 00	 mov	 BYTE PTR [ecx+eax-1], 0

; 854  : 			i = atoi(word2);

  00314	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 _atoi
  00320	83 c4 04	 add	 esp, 4
  00323	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 855  : 			usi = (UINT16)i;

  00329	66 8b 85 f0 fb
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00330	66 89 85 ec fb
	ff ff		 mov	 WORD PTR _usi$[ebp], ax

; 856  : 
; 857  : 
; 858  : 			if (!strcmp(word, "NUMBEROFPICS"))

  00337	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EBKKDBGP@NUMBEROFPICS@
  0033c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 _strcmp
  00348	83 c4 08	 add	 esp, 8
  0034b	85 c0		 test	 eax, eax
  0034d	75 56		 jne	 SHORT $LN21@readcutsce

; 859  : 			{
; 860  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].numpics), UNDO_NONE);

  0034f	6a 00		 push	 0
  00351	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00358	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0035f	0f b6 94 08 00
	00 00 00	 movzx	 edx, BYTE PTR _cutscenes[eax+ecx]
  00367	52		 push	 edx
  00368	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0036d	e8 00 00 00 00	 call	 _va
  00372	83 c4 08	 add	 esp, 8
  00375	50		 push	 eax
  00376	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00382	83 c4 0c	 add	 esp, 12			; 0000000cH

; 861  : 				cutscenes[num].scene[scenenum].numpics = (UINT8)i;

  00385	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0038c	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00393	8a 95 f0 fb ff
	ff		 mov	 dl, BYTE PTR _i$[ebp]
  00399	88 94 08 00 00
	00 00		 mov	 BYTE PTR _cutscenes[eax+ecx], dl

; 862  : 			}

  003a0	e9 f5 16 00 00	 jmp	 $LN110@readcutsce
$LN21@readcutsce:

; 863  : 			else if (!strcmp(word, "PIC1NAME"))

  003a5	68 00 00 00 00	 push	 OFFSET ??_C@_08NGJELEKO@PIC1NAME@
  003aa	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003b0	50		 push	 eax
  003b1	e8 00 00 00 00	 call	 _strcmp
  003b6	83 c4 08	 add	 esp, 8
  003b9	85 c0		 test	 eax, eax
  003bb	75 6b		 jne	 SHORT $LN23@readcutsce

; 864  : 			{
; 865  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[0], UNDO_NONE);

  003bd	6a 00		 push	 0
  003bf	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  003c6	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  003cd	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  003d4	b8 08 00 00 00	 mov	 eax, 8
  003d9	6b c8 00	 imul	 ecx, eax, 0
  003dc	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  003e0	52		 push	 edx
  003e1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  003ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 866  : 				strncpy(cutscenes[num].scene[scenenum].picname[0], word2, 8);

  003f0	6a 08		 push	 8
  003f2	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  003f8	50		 push	 eax
  003f9	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  00400	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  00407	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  0040e	b9 08 00 00 00	 mov	 ecx, 8
  00413	6b d1 00	 imul	 edx, ecx, 0
  00416	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  0041a	50		 push	 eax
  0041b	e8 00 00 00 00	 call	 _strncpy
  00420	83 c4 0c	 add	 esp, 12			; 0000000cH

; 867  : 			}

  00423	e9 72 16 00 00	 jmp	 $LN110@readcutsce
$LN23@readcutsce:

; 868  : 			else if (!strcmp(word, "PIC2NAME"))

  00428	68 00 00 00 00	 push	 OFFSET ??_C@_08FAAAMGAA@PIC2NAME@
  0042d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00433	50		 push	 eax
  00434	e8 00 00 00 00	 call	 _strcmp
  00439	83 c4 08	 add	 esp, 8
  0043c	85 c0		 test	 eax, eax
  0043e	75 6b		 jne	 SHORT $LN25@readcutsce

; 869  : 			{
; 870  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[1], UNDO_NONE);

  00440	6a 00		 push	 0
  00442	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00449	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00450	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00457	b8 08 00 00 00	 mov	 eax, 8
  0045c	c1 e0 00	 shl	 eax, 0
  0045f	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  00463	51		 push	 ecx
  00464	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0046a	52		 push	 edx
  0046b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00470	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 				strncpy(cutscenes[num].scene[scenenum].picname[1], word2, 8);

  00473	6a 08		 push	 8
  00475	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0047b	50		 push	 eax
  0047c	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  00483	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  0048a	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  00491	b9 08 00 00 00	 mov	 ecx, 8
  00496	c1 e1 00	 shl	 ecx, 0
  00499	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  0049d	52		 push	 edx
  0049e	e8 00 00 00 00	 call	 _strncpy
  004a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 872  : 			}

  004a6	e9 ef 15 00 00	 jmp	 $LN110@readcutsce
$LN25@readcutsce:

; 873  : 			else if (!strcmp(word, "PIC3NAME"))

  004ab	68 00 00 00 00	 push	 OFFSET ??_C@_08JLFMBFKF@PIC3NAME@
  004b0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  004b6	50		 push	 eax
  004b7	e8 00 00 00 00	 call	 _strcmp
  004bc	83 c4 08	 add	 esp, 8
  004bf	85 c0		 test	 eax, eax
  004c1	75 69		 jne	 SHORT $LN27@readcutsce

; 874  : 			{
; 875  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[2], UNDO_NONE);

  004c3	6a 00		 push	 0
  004c5	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  004cc	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  004d3	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  004da	b8 08 00 00 00	 mov	 eax, 8
  004df	d1 e0		 shl	 eax, 1
  004e1	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  004e5	51		 push	 ecx
  004e6	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  004ec	52		 push	 edx
  004ed	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  004f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 876  : 				strncpy(cutscenes[num].scene[scenenum].picname[2], word2, 8);

  004f5	6a 08		 push	 8
  004f7	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  004fd	50		 push	 eax
  004fe	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  00505	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  0050c	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  00513	b9 08 00 00 00	 mov	 ecx, 8
  00518	d1 e1		 shl	 ecx, 1
  0051a	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  0051e	52		 push	 edx
  0051f	e8 00 00 00 00	 call	 _strncpy
  00524	83 c4 0c	 add	 esp, 12			; 0000000cH

; 877  : 			}

  00527	e9 6e 15 00 00	 jmp	 $LN110@readcutsce
$LN27@readcutsce:

; 878  : 			else if (!strcmp(word, "PIC4NAME"))

  0052c	68 00 00 00 00	 push	 OFFSET ??_C@_08IGFJCFBN@PIC4NAME@
  00531	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00537	50		 push	 eax
  00538	e8 00 00 00 00	 call	 _strcmp
  0053d	83 c4 08	 add	 esp, 8
  00540	85 c0		 test	 eax, eax
  00542	75 6b		 jne	 SHORT $LN29@readcutsce

; 879  : 			{
; 880  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[3], UNDO_NONE);

  00544	6a 00		 push	 0
  00546	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0054d	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00554	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0055b	b8 08 00 00 00	 mov	 eax, 8
  00560	6b c8 03	 imul	 ecx, eax, 3
  00563	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  00567	52		 push	 edx
  00568	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0056e	50		 push	 eax
  0056f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00574	83 c4 0c	 add	 esp, 12			; 0000000cH

; 881  : 				strncpy(cutscenes[num].scene[scenenum].picname[3], word2, 8);

  00577	6a 08		 push	 8
  00579	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0057f	50		 push	 eax
  00580	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  00587	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  0058e	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  00595	b9 08 00 00 00	 mov	 ecx, 8
  0059a	6b d1 03	 imul	 edx, ecx, 3
  0059d	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  005a1	50		 push	 eax
  005a2	e8 00 00 00 00	 call	 _strncpy
  005a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 882  : 			}

  005aa	e9 eb 14 00 00	 jmp	 $LN110@readcutsce
$LN29@readcutsce:

; 883  : 			else if (!strcmp(word, "PIC5NAME"))

  005af	68 00 00 00 00	 push	 OFFSET ??_C@_08ENAFPGLI@PIC5NAME@
  005b4	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  005ba	50		 push	 eax
  005bb	e8 00 00 00 00	 call	 _strcmp
  005c0	83 c4 08	 add	 esp, 8
  005c3	85 c0		 test	 eax, eax
  005c5	75 6b		 jne	 SHORT $LN31@readcutsce

; 884  : 			{
; 885  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[4], UNDO_NONE);

  005c7	6a 00		 push	 0
  005c9	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  005d0	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  005d7	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  005de	b8 08 00 00 00	 mov	 eax, 8
  005e3	c1 e0 02	 shl	 eax, 2
  005e6	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  005ea	51		 push	 ecx
  005eb	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  005f1	52		 push	 edx
  005f2	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 886  : 				strncpy(cutscenes[num].scene[scenenum].picname[4], word2, 8);

  005fa	6a 08		 push	 8
  005fc	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00602	50		 push	 eax
  00603	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  0060a	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  00611	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  00618	b9 08 00 00 00	 mov	 ecx, 8
  0061d	c1 e1 02	 shl	 ecx, 2
  00620	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00624	52		 push	 edx
  00625	e8 00 00 00 00	 call	 _strncpy
  0062a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  : 			}

  0062d	e9 68 14 00 00	 jmp	 $LN110@readcutsce
$LN31@readcutsce:

; 888  : 			else if (!strcmp(word, "PIC6NAME"))

  00632	68 00 00 00 00	 push	 OFFSET ??_C@_08MLJBIEBG@PIC6NAME@
  00637	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0063d	50		 push	 eax
  0063e	e8 00 00 00 00	 call	 _strcmp
  00643	83 c4 08	 add	 esp, 8
  00646	85 c0		 test	 eax, eax
  00648	75 6b		 jne	 SHORT $LN33@readcutsce

; 889  : 			{
; 890  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[5], UNDO_NONE);

  0064a	6a 00		 push	 0
  0064c	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00653	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0065a	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00661	b8 08 00 00 00	 mov	 eax, 8
  00666	6b c8 05	 imul	 ecx, eax, 5
  00669	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  0066d	52		 push	 edx
  0066e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00674	50		 push	 eax
  00675	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0067a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 891  : 				strncpy(cutscenes[num].scene[scenenum].picname[5], word2, 8);

  0067d	6a 08		 push	 8
  0067f	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00685	50		 push	 eax
  00686	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  0068d	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  00694	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  0069b	b9 08 00 00 00	 mov	 ecx, 8
  006a0	6b d1 05	 imul	 edx, ecx, 5
  006a3	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  006a7	50		 push	 eax
  006a8	e8 00 00 00 00	 call	 _strncpy
  006ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 892  : 			}

  006b0	e9 e5 13 00 00	 jmp	 $LN110@readcutsce
$LN33@readcutsce:

; 893  : 			else if (!strcmp(word, "PIC7NAME"))

  006b5	68 00 00 00 00	 push	 OFFSET ??_C@_08MNFHLD@PIC7NAME@
  006ba	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006c0	50		 push	 eax
  006c1	e8 00 00 00 00	 call	 _strcmp
  006c6	83 c4 08	 add	 esp, 8
  006c9	85 c0		 test	 eax, eax
  006cb	75 6b		 jne	 SHORT $LN35@readcutsce

; 894  : 			{
; 895  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[6], UNDO_NONE);

  006cd	6a 00		 push	 0
  006cf	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  006d6	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  006dd	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  006e4	b8 08 00 00 00	 mov	 eax, 8
  006e9	6b c8 06	 imul	 ecx, eax, 6
  006ec	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  006f0	52		 push	 edx
  006f1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006f7	50		 push	 eax
  006f8	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  006fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 896  : 				strncpy(cutscenes[num].scene[scenenum].picname[6], word2, 8);

  00700	6a 08		 push	 8
  00702	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00708	50		 push	 eax
  00709	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  00710	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  00717	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  0071e	b9 08 00 00 00	 mov	 ecx, 8
  00723	6b d1 06	 imul	 edx, ecx, 6
  00726	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  0072a	50		 push	 eax
  0072b	e8 00 00 00 00	 call	 _strncpy
  00730	83 c4 0c	 add	 esp, 12			; 0000000cH

; 897  : 			}

  00733	e9 62 13 00 00	 jmp	 $LN110@readcutsce
$LN35@readcutsce:

; 898  : 			else if (!strcmp(word, "PIC8NAME"))

  00738	68 00 00 00 00	 push	 OFFSET ??_C@_08PBJLOFGG@PIC8NAME@
  0073d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00743	50		 push	 eax
  00744	e8 00 00 00 00	 call	 _strcmp
  00749	83 c4 08	 add	 esp, 8
  0074c	85 c0		 test	 eax, eax
  0074e	75 6b		 jne	 SHORT $LN37@readcutsce

; 899  : 			{
; 900  : 				DEH_WriteUndoline(word, cutscenes[num].scene[scenenum].picname[7], UNDO_NONE);

  00750	6a 00		 push	 0
  00752	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00759	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00760	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00767	b8 08 00 00 00	 mov	 eax, 8
  0076c	6b c8 07	 imul	 ecx, eax, 7
  0076f	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  00773	52		 push	 edx
  00774	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0077a	50		 push	 eax
  0077b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00780	83 c4 0c	 add	 esp, 12			; 0000000cH

; 901  : 				strncpy(cutscenes[num].scene[scenenum].picname[7], word2, 8);

  00783	6a 08		 push	 8
  00785	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0078b	50		 push	 eax
  0078c	69 4d 0c 04 52
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 20996
  00793	69 55 10 a4 00
	00 00		 imul	 edx, DWORD PTR _scenenum$[ebp], 164
  0079a	8d 84 11 00 00
	00 00		 lea	 eax, DWORD PTR _cutscenes[ecx+edx]
  007a1	b9 08 00 00 00	 mov	 ecx, 8
  007a6	6b d1 07	 imul	 edx, ecx, 7
  007a9	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  007ad	50		 push	 eax
  007ae	e8 00 00 00 00	 call	 _strncpy
  007b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 902  : 			}

  007b6	e9 df 12 00 00	 jmp	 $LN110@readcutsce
$LN37@readcutsce:

; 903  : 			else if (!strcmp(word, "PIC1HIRES"))

  007bb	68 00 00 00 00	 push	 OFFSET ??_C@_09EOHNPLNJ@PIC1HIRES@
  007c0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  007c6	50		 push	 eax
  007c7	e8 00 00 00 00	 call	 _strcmp
  007cc	83 c4 08	 add	 esp, 8
  007cf	85 c0		 test	 eax, eax
  007d1	75 6d		 jne	 SHORT $LN39@readcutsce

; 904  : 			{
; 905  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[0]), UNDO_NONE);

  007d3	6a 00		 push	 0
  007d5	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  007dc	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  007e3	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  007ea	b8 04 00 00 00	 mov	 eax, 4
  007ef	6b c8 00	 imul	 ecx, eax, 0
  007f2	8b 54 0a 44	 mov	 edx, DWORD PTR [edx+ecx+68]
  007f6	52		 push	 edx
  007f7	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  007fc	e8 00 00 00 00	 call	 _va
  00801	83 c4 08	 add	 esp, 8
  00804	50		 push	 eax
  00805	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0080b	50		 push	 eax
  0080c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00811	83 c4 0c	 add	 esp, 12			; 0000000cH

; 906  : 				cutscenes[num].scene[scenenum].pichires[0] = i;

  00814	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0081b	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00822	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00829	b8 04 00 00 00	 mov	 eax, 4
  0082e	6b c8 00	 imul	 ecx, eax, 0
  00831	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00837	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 907  : 			}

  0083b	e9 5a 12 00 00	 jmp	 $LN110@readcutsce
$LN39@readcutsce:

; 908  : 			else if (!strcmp(word, "PIC2HIRES"))

  00840	68 00 00 00 00	 push	 OFFSET ??_C@_09HPJFOBEE@PIC2HIRES@
  00845	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0084b	50		 push	 eax
  0084c	e8 00 00 00 00	 call	 _strcmp
  00851	83 c4 08	 add	 esp, 8
  00854	85 c0		 test	 eax, eax
  00856	75 6d		 jne	 SHORT $LN41@readcutsce

; 909  : 			{
; 910  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[1]), UNDO_NONE);

  00858	6a 00		 push	 0
  0085a	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00861	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00868	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0086f	b8 04 00 00 00	 mov	 eax, 4
  00874	c1 e0 00	 shl	 eax, 0
  00877	8b 4c 02 44	 mov	 ecx, DWORD PTR [edx+eax+68]
  0087b	51		 push	 ecx
  0087c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00881	e8 00 00 00 00	 call	 _va
  00886	83 c4 08	 add	 esp, 8
  00889	50		 push	 eax
  0088a	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00890	52		 push	 edx
  00891	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00896	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  : 				cutscenes[num].scene[scenenum].pichires[1] = i;

  00899	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  008a0	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  008a7	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  008ae	b8 04 00 00 00	 mov	 eax, 4
  008b3	c1 e0 00	 shl	 eax, 0
  008b6	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  008bc	89 4c 02 44	 mov	 DWORD PTR [edx+eax+68], ecx

; 912  : 			}

  008c0	e9 d5 11 00 00	 jmp	 $LN110@readcutsce
$LN41@readcutsce:

; 913  : 			else if (!strcmp(word, "PIC3HIRES"))

  008c5	68 00 00 00 00	 push	 OFFSET ??_C@_09NJOCOKPA@PIC3HIRES@
  008ca	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  008d0	50		 push	 eax
  008d1	e8 00 00 00 00	 call	 _strcmp
  008d6	83 c4 08	 add	 esp, 8
  008d9	85 c0		 test	 eax, eax
  008db	75 6b		 jne	 SHORT $LN43@readcutsce

; 914  : 			{
; 915  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[2]), UNDO_NONE);

  008dd	6a 00		 push	 0
  008df	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  008e6	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  008ed	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  008f4	b8 04 00 00 00	 mov	 eax, 4
  008f9	d1 e0		 shl	 eax, 1
  008fb	8b 4c 02 44	 mov	 ecx, DWORD PTR [edx+eax+68]
  008ff	51		 push	 ecx
  00900	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00905	e8 00 00 00 00	 call	 _va
  0090a	83 c4 08	 add	 esp, 8
  0090d	50		 push	 eax
  0090e	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00914	52		 push	 edx
  00915	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0091a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 916  : 				cutscenes[num].scene[scenenum].pichires[2] = i;

  0091d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00924	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0092b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00932	b8 04 00 00 00	 mov	 eax, 4
  00937	d1 e0		 shl	 eax, 1
  00939	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0093f	89 4c 02 44	 mov	 DWORD PTR [edx+eax+68], ecx

; 917  : 			}

  00943	e9 52 11 00 00	 jmp	 $LN110@readcutsce
$LN43@readcutsce:

; 918  : 			else if (!strcmp(word, "PIC4HIRES"))

  00948	68 00 00 00 00	 push	 OFFSET ??_C@_09BMEFNEHO@PIC4HIRES@
  0094d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00953	50		 push	 eax
  00954	e8 00 00 00 00	 call	 _strcmp
  00959	83 c4 08	 add	 esp, 8
  0095c	85 c0		 test	 eax, eax
  0095e	75 6d		 jne	 SHORT $LN45@readcutsce

; 919  : 			{
; 920  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[3]), UNDO_NONE);

  00960	6a 00		 push	 0
  00962	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00969	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00970	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00977	b8 04 00 00 00	 mov	 eax, 4
  0097c	6b c8 03	 imul	 ecx, eax, 3
  0097f	8b 54 0a 44	 mov	 edx, DWORD PTR [edx+ecx+68]
  00983	52		 push	 edx
  00984	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00989	e8 00 00 00 00	 call	 _va
  0098e	83 c4 08	 add	 esp, 8
  00991	50		 push	 eax
  00992	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00998	50		 push	 eax
  00999	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0099e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 921  : 				cutscenes[num].scene[scenenum].pichires[3] = i;

  009a1	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  009a8	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  009af	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  009b6	b8 04 00 00 00	 mov	 eax, 4
  009bb	6b c8 03	 imul	 ecx, eax, 3
  009be	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  009c4	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 922  : 			}

  009c8	e9 cd 10 00 00	 jmp	 $LN110@readcutsce
$LN45@readcutsce:

; 923  : 			else if (!strcmp(word, "PIC5HIRES"))

  009cd	68 00 00 00 00	 push	 OFFSET ??_C@_09LKDCNPMK@PIC5HIRES@
  009d2	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  009d8	50		 push	 eax
  009d9	e8 00 00 00 00	 call	 _strcmp
  009de	83 c4 08	 add	 esp, 8
  009e1	85 c0		 test	 eax, eax
  009e3	75 6d		 jne	 SHORT $LN47@readcutsce

; 924  : 			{
; 925  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[4]), UNDO_NONE);

  009e5	6a 00		 push	 0
  009e7	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  009ee	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  009f5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  009fc	b8 04 00 00 00	 mov	 eax, 4
  00a01	c1 e0 02	 shl	 eax, 2
  00a04	8b 4c 02 44	 mov	 ecx, DWORD PTR [edx+eax+68]
  00a08	51		 push	 ecx
  00a09	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00a0e	e8 00 00 00 00	 call	 _va
  00a13	83 c4 08	 add	 esp, 8
  00a16	50		 push	 eax
  00a17	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00a1d	52		 push	 edx
  00a1e	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00a23	83 c4 0c	 add	 esp, 12			; 0000000cH

; 926  : 				cutscenes[num].scene[scenenum].pichires[4] = i;

  00a26	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00a2d	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00a34	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00a3b	b8 04 00 00 00	 mov	 eax, 4
  00a40	c1 e0 02	 shl	 eax, 2
  00a43	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00a49	89 4c 02 44	 mov	 DWORD PTR [edx+eax+68], ecx

; 927  : 			}

  00a4d	e9 48 10 00 00	 jmp	 $LN110@readcutsce
$LN47@readcutsce:

; 928  : 			else if (!strcmp(word, "PIC6HIRES"))

  00a52	68 00 00 00 00	 push	 OFFSET ??_C@_09ILNKMFFH@PIC6HIRES@
  00a57	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00a5d	50		 push	 eax
  00a5e	e8 00 00 00 00	 call	 _strcmp
  00a63	83 c4 08	 add	 esp, 8
  00a66	85 c0		 test	 eax, eax
  00a68	75 6d		 jne	 SHORT $LN49@readcutsce

; 929  : 			{
; 930  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[5]), UNDO_NONE);

  00a6a	6a 00		 push	 0
  00a6c	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00a73	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00a7a	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00a81	b8 04 00 00 00	 mov	 eax, 4
  00a86	6b c8 05	 imul	 ecx, eax, 5
  00a89	8b 54 0a 44	 mov	 edx, DWORD PTR [edx+ecx+68]
  00a8d	52		 push	 edx
  00a8e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00a93	e8 00 00 00 00	 call	 _va
  00a98	83 c4 08	 add	 esp, 8
  00a9b	50		 push	 eax
  00a9c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00aa2	50		 push	 eax
  00aa3	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00aa8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 931  : 				cutscenes[num].scene[scenenum].pichires[5] = i;

  00aab	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00ab2	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00ab9	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00ac0	b8 04 00 00 00	 mov	 eax, 4
  00ac5	6b c8 05	 imul	 ecx, eax, 5
  00ac8	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00ace	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 932  : 			}

  00ad2	e9 c3 0f 00 00	 jmp	 $LN110@readcutsce
$LN49@readcutsce:

; 933  : 			else if (!strcmp(word, "PIC7HIRES"))

  00ad7	68 00 00 00 00	 push	 OFFSET ??_C@_09CNKNMOOD@PIC7HIRES@
  00adc	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00ae2	50		 push	 eax
  00ae3	e8 00 00 00 00	 call	 _strcmp
  00ae8	83 c4 08	 add	 esp, 8
  00aeb	85 c0		 test	 eax, eax
  00aed	75 6d		 jne	 SHORT $LN51@readcutsce

; 934  : 			{
; 935  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[6]), UNDO_NONE);

  00aef	6a 00		 push	 0
  00af1	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00af8	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00aff	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00b06	b8 04 00 00 00	 mov	 eax, 4
  00b0b	6b c8 06	 imul	 ecx, eax, 6
  00b0e	8b 54 0a 44	 mov	 edx, DWORD PTR [edx+ecx+68]
  00b12	52		 push	 edx
  00b13	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00b18	e8 00 00 00 00	 call	 _va
  00b1d	83 c4 08	 add	 esp, 8
  00b20	50		 push	 eax
  00b21	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00b27	50		 push	 eax
  00b28	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00b2d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 936  : 				cutscenes[num].scene[scenenum].pichires[6] = i;

  00b30	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00b37	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00b3e	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00b45	b8 04 00 00 00	 mov	 eax, 4
  00b4a	6b c8 06	 imul	 ecx, eax, 6
  00b4d	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b53	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 937  : 			}

  00b57	e9 3e 0f 00 00	 jmp	 $LN110@readcutsce
$LN51@readcutsce:

; 938  : 			else if (!strcmp(word, "PIC8HIRES"))

  00b5c	68 00 00 00 00	 push	 OFFSET ??_C@_09NLOFLOAK@PIC8HIRES@
  00b61	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00b67	50		 push	 eax
  00b68	e8 00 00 00 00	 call	 _strcmp
  00b6d	83 c4 08	 add	 esp, 8
  00b70	85 c0		 test	 eax, eax
  00b72	75 6d		 jne	 SHORT $LN53@readcutsce

; 939  : 			{
; 940  : 				DEH_WriteUndoline(word, va("%d", cutscenes[num].scene[scenenum].pichires[7]), UNDO_NONE);

  00b74	6a 00		 push	 0
  00b76	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00b7d	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00b84	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00b8b	b8 04 00 00 00	 mov	 eax, 4
  00b90	6b c8 07	 imul	 ecx, eax, 7
  00b93	8b 54 0a 44	 mov	 edx, DWORD PTR [edx+ecx+68]
  00b97	52		 push	 edx
  00b98	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00b9d	e8 00 00 00 00	 call	 _va
  00ba2	83 c4 08	 add	 esp, 8
  00ba5	50		 push	 eax
  00ba6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00bac	50		 push	 eax
  00bad	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00bb2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 941  : 				cutscenes[num].scene[scenenum].pichires[7] = i;

  00bb5	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00bbc	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00bc3	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00bca	b8 04 00 00 00	 mov	 eax, 4
  00bcf	6b c8 07	 imul	 ecx, eax, 7
  00bd2	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bd8	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 942  : 			}

  00bdc	e9 b9 0e 00 00	 jmp	 $LN110@readcutsce
$LN53@readcutsce:

; 943  : 			else if (!strcmp(word, "PIC1DURATION"))

  00be1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMBFMNLB@PIC1DURATION@
  00be6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00bec	50		 push	 eax
  00bed	e8 00 00 00 00	 call	 _strcmp
  00bf2	83 c4 08	 add	 esp, 8
  00bf5	85 c0		 test	 eax, eax
  00bf7	75 76		 jne	 SHORT $LN55@readcutsce

; 944  : 			{
; 945  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[0]), UNDO_NONE);

  00bf9	6a 00		 push	 0
  00bfb	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00c02	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00c09	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00c10	b8 02 00 00 00	 mov	 eax, 2
  00c15	6b c8 00	 imul	 ecx, eax, 0
  00c18	0f b7 94 0a 88
	00 00 00	 movzx	 edx, WORD PTR [edx+ecx+136]
  00c20	52		 push	 edx
  00c21	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00c26	e8 00 00 00 00	 call	 _va
  00c2b	83 c4 08	 add	 esp, 8
  00c2e	50		 push	 eax
  00c2f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00c35	50		 push	 eax
  00c36	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00c3b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 946  : 				cutscenes[num].scene[scenenum].picduration[0] = usi;

  00c3e	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00c45	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00c4c	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00c53	b8 02 00 00 00	 mov	 eax, 2
  00c58	6b c8 00	 imul	 ecx, eax, 0
  00c5b	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  00c62	66 89 84 0a 88
	00 00 00	 mov	 WORD PTR [edx+ecx+136], ax

; 947  : 			}

  00c6a	e9 2b 0e 00 00	 jmp	 $LN110@readcutsce
$LN55@readcutsce:

; 948  : 			else if (!strcmp(word, "PIC2DURATION"))

  00c6f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KHCCHGLC@PIC2DURATION@
  00c74	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00c7a	50		 push	 eax
  00c7b	e8 00 00 00 00	 call	 _strcmp
  00c80	83 c4 08	 add	 esp, 8
  00c83	85 c0		 test	 eax, eax
  00c85	75 76		 jne	 SHORT $LN57@readcutsce

; 949  : 			{
; 950  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[1]), UNDO_NONE);

  00c87	6a 00		 push	 0
  00c89	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00c90	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00c97	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00c9e	b8 02 00 00 00	 mov	 eax, 2
  00ca3	c1 e0 00	 shl	 eax, 0
  00ca6	0f b7 8c 02 88
	00 00 00	 movzx	 ecx, WORD PTR [edx+eax+136]
  00cae	51		 push	 ecx
  00caf	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00cb4	e8 00 00 00 00	 call	 _va
  00cb9	83 c4 08	 add	 esp, 8
  00cbc	50		 push	 eax
  00cbd	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00cc3	52		 push	 edx
  00cc4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00cc9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 951  : 				cutscenes[num].scene[scenenum].picduration[1] = usi;

  00ccc	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00cd3	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00cda	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00ce1	b8 02 00 00 00	 mov	 eax, 2
  00ce6	c1 e0 00	 shl	 eax, 0
  00ce9	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  00cf0	66 89 8c 02 88
	00 00 00	 mov	 WORD PTR [edx+eax+136], cx

; 952  : 			}

  00cf8	e9 9d 0d 00 00	 jmp	 $LN110@readcutsce
$LN57@readcutsce:

; 953  : 			else if (!strcmp(word, "PIC3DURATION"))

  00cfd	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EIOABNIM@PIC3DURATION@
  00d02	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00d08	50		 push	 eax
  00d09	e8 00 00 00 00	 call	 _strcmp
  00d0e	83 c4 08	 add	 esp, 8
  00d11	85 c0		 test	 eax, eax
  00d13	75 74		 jne	 SHORT $LN59@readcutsce

; 954  : 			{
; 955  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[2]), UNDO_NONE);

  00d15	6a 00		 push	 0
  00d17	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00d1e	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00d25	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00d2c	b8 02 00 00 00	 mov	 eax, 2
  00d31	d1 e0		 shl	 eax, 1
  00d33	0f b7 8c 02 88
	00 00 00	 movzx	 ecx, WORD PTR [edx+eax+136]
  00d3b	51		 push	 ecx
  00d3c	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00d41	e8 00 00 00 00	 call	 _va
  00d46	83 c4 08	 add	 esp, 8
  00d49	50		 push	 eax
  00d4a	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00d50	52		 push	 edx
  00d51	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00d56	83 c4 0c	 add	 esp, 12			; 0000000cH

; 956  : 				cutscenes[num].scene[scenenum].picduration[2] = usi;

  00d59	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00d60	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00d67	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00d6e	b8 02 00 00 00	 mov	 eax, 2
  00d73	d1 e0		 shl	 eax, 1
  00d75	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  00d7c	66 89 8c 02 88
	00 00 00	 mov	 WORD PTR [edx+eax+136], cx

; 957  : 			}

  00d84	e9 11 0d 00 00	 jmp	 $LN110@readcutsce
$LN59@readcutsce:

; 958  : 			else if (!strcmp(word, "PIC4DURATION"))

  00d89	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KKDMAGPF@PIC4DURATION@
  00d8e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00d94	50		 push	 eax
  00d95	e8 00 00 00 00	 call	 _strcmp
  00d9a	83 c4 08	 add	 esp, 8
  00d9d	85 c0		 test	 eax, eax
  00d9f	75 76		 jne	 SHORT $LN61@readcutsce

; 959  : 			{
; 960  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[3]), UNDO_NONE);

  00da1	6a 00		 push	 0
  00da3	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00daa	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00db1	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00db8	b8 02 00 00 00	 mov	 eax, 2
  00dbd	6b c8 03	 imul	 ecx, eax, 3
  00dc0	0f b7 94 0a 88
	00 00 00	 movzx	 edx, WORD PTR [edx+ecx+136]
  00dc8	52		 push	 edx
  00dc9	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00dce	e8 00 00 00 00	 call	 _va
  00dd3	83 c4 08	 add	 esp, 8
  00dd6	50		 push	 eax
  00dd7	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00ddd	50		 push	 eax
  00dde	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00de3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 961  : 				cutscenes[num].scene[scenenum].picduration[3] = usi;

  00de6	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00ded	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00df4	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00dfb	b8 02 00 00 00	 mov	 eax, 2
  00e00	6b c8 03	 imul	 ecx, eax, 3
  00e03	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  00e0a	66 89 84 0a 88
	00 00 00	 mov	 WORD PTR [edx+ecx+136], ax

; 962  : 			}

  00e12	e9 83 0c 00 00	 jmp	 $LN110@readcutsce
$LN61@readcutsce:

; 963  : 			else if (!strcmp(word, "PIC5DURATION"))

  00e17	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EFPOGNML@PIC5DURATION@
  00e1c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00e22	50		 push	 eax
  00e23	e8 00 00 00 00	 call	 _strcmp
  00e28	83 c4 08	 add	 esp, 8
  00e2b	85 c0		 test	 eax, eax
  00e2d	75 76		 jne	 SHORT $LN63@readcutsce

; 964  : 			{
; 965  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[4]), UNDO_NONE);

  00e2f	6a 00		 push	 0
  00e31	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00e38	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00e3f	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00e46	b8 02 00 00 00	 mov	 eax, 2
  00e4b	c1 e0 02	 shl	 eax, 2
  00e4e	0f b7 8c 02 88
	00 00 00	 movzx	 ecx, WORD PTR [edx+eax+136]
  00e56	51		 push	 ecx
  00e57	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00e5c	e8 00 00 00 00	 call	 _va
  00e61	83 c4 08	 add	 esp, 8
  00e64	50		 push	 eax
  00e65	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00e6b	52		 push	 edx
  00e6c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00e71	83 c4 0c	 add	 esp, 12			; 0000000cH

; 966  : 				cutscenes[num].scene[scenenum].picduration[4] = usi;

  00e74	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00e7b	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00e82	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00e89	b8 02 00 00 00	 mov	 eax, 2
  00e8e	c1 e0 02	 shl	 eax, 2
  00e91	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  00e98	66 89 8c 02 88
	00 00 00	 mov	 WORD PTR [edx+eax+136], cx

; 967  : 			}

  00ea0	e9 f5 0b 00 00	 jmp	 $LN110@readcutsce
$LN63@readcutsce:

; 968  : 			else if (!strcmp(word, "PIC6DURATION"))

  00ea5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KOMJNGMI@PIC6DURATION@
  00eaa	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00eb0	50		 push	 eax
  00eb1	e8 00 00 00 00	 call	 _strcmp
  00eb6	83 c4 08	 add	 esp, 8
  00eb9	85 c0		 test	 eax, eax
  00ebb	75 76		 jne	 SHORT $LN65@readcutsce

; 969  : 			{
; 970  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[5]), UNDO_NONE);

  00ebd	6a 00		 push	 0
  00ebf	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00ec6	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00ecd	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00ed4	b8 02 00 00 00	 mov	 eax, 2
  00ed9	6b c8 05	 imul	 ecx, eax, 5
  00edc	0f b7 94 0a 88
	00 00 00	 movzx	 edx, WORD PTR [edx+ecx+136]
  00ee4	52		 push	 edx
  00ee5	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00eea	e8 00 00 00 00	 call	 _va
  00eef	83 c4 08	 add	 esp, 8
  00ef2	50		 push	 eax
  00ef3	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00ef9	50		 push	 eax
  00efa	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00eff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 971  : 				cutscenes[num].scene[scenenum].picduration[5] = usi;

  00f02	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00f09	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00f10	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00f17	b8 02 00 00 00	 mov	 eax, 2
  00f1c	6b c8 05	 imul	 ecx, eax, 5
  00f1f	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  00f26	66 89 84 0a 88
	00 00 00	 mov	 WORD PTR [edx+ecx+136], ax

; 972  : 			}

  00f2e	e9 67 0b 00 00	 jmp	 $LN110@readcutsce
$LN65@readcutsce:

; 973  : 			else if (!strcmp(word, "PIC7DURATION"))

  00f33	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EBALLNPG@PIC7DURATION@
  00f38	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00f3e	50		 push	 eax
  00f3f	e8 00 00 00 00	 call	 _strcmp
  00f44	83 c4 08	 add	 esp, 8
  00f47	85 c0		 test	 eax, eax
  00f49	75 76		 jne	 SHORT $LN67@readcutsce

; 974  : 			{
; 975  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[6]), UNDO_NONE);

  00f4b	6a 00		 push	 0
  00f4d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00f54	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00f5b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00f62	b8 02 00 00 00	 mov	 eax, 2
  00f67	6b c8 06	 imul	 ecx, eax, 6
  00f6a	0f b7 94 0a 88
	00 00 00	 movzx	 edx, WORD PTR [edx+ecx+136]
  00f72	52		 push	 edx
  00f73	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00f78	e8 00 00 00 00	 call	 _va
  00f7d	83 c4 08	 add	 esp, 8
  00f80	50		 push	 eax
  00f81	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00f87	50		 push	 eax
  00f88	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00f8d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 976  : 				cutscenes[num].scene[scenenum].picduration[6] = usi;

  00f90	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00f97	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00f9e	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00fa5	b8 02 00 00 00	 mov	 eax, 2
  00faa	6b c8 06	 imul	 ecx, eax, 6
  00fad	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  00fb4	66 89 84 0a 88
	00 00 00	 mov	 WORD PTR [edx+ecx+136], ax

; 977  : 			}

  00fbc	e9 d9 0a 00 00	 jmp	 $LN110@readcutsce
$LN67@readcutsce:

; 978  : 			else if (!strcmp(word, "PIC8DURATION"))

  00fc1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LAAAOGHL@PIC8DURATION@
  00fc6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00fcc	50		 push	 eax
  00fcd	e8 00 00 00 00	 call	 _strcmp
  00fd2	83 c4 08	 add	 esp, 8
  00fd5	85 c0		 test	 eax, eax
  00fd7	75 76		 jne	 SHORT $LN69@readcutsce

; 979  : 			{
; 980  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].picduration[7]), UNDO_NONE);

  00fd9	6a 00		 push	 0
  00fdb	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  00fe2	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  00fe9	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  00ff0	b8 02 00 00 00	 mov	 eax, 2
  00ff5	6b c8 07	 imul	 ecx, eax, 7
  00ff8	0f b7 94 0a 88
	00 00 00	 movzx	 edx, WORD PTR [edx+ecx+136]
  01000	52		 push	 edx
  01001	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01006	e8 00 00 00 00	 call	 _va
  0100b	83 c4 08	 add	 esp, 8
  0100e	50		 push	 eax
  0100f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01015	50		 push	 eax
  01016	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0101b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 981  : 				cutscenes[num].scene[scenenum].picduration[7] = usi;

  0101e	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01025	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0102c	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01033	b8 02 00 00 00	 mov	 eax, 2
  01038	6b c8 07	 imul	 ecx, eax, 7
  0103b	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  01042	66 89 84 0a 88
	00 00 00	 mov	 WORD PTR [edx+ecx+136], ax

; 982  : 			}

  0104a	e9 4b 0a 00 00	 jmp	 $LN110@readcutsce
$LN69@readcutsce:

; 983  : 			else if (!strcmp(word, "PIC1XCOORD"))

  0104f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FLBOPLEC@PIC1XCOORD@
  01054	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0105a	50		 push	 eax
  0105b	e8 00 00 00 00	 call	 _strcmp
  01060	83 c4 08	 add	 esp, 8
  01063	85 c0		 test	 eax, eax
  01065	75 70		 jne	 SHORT $LN71@readcutsce

; 984  : 			{
; 985  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[0]), UNDO_NONE);

  01067	6a 00		 push	 0
  01069	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01070	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01077	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0107e	b8 02 00 00 00	 mov	 eax, 2
  01083	6b c8 00	 imul	 ecx, eax, 0
  01086	0f b7 54 0a 68	 movzx	 edx, WORD PTR [edx+ecx+104]
  0108b	52		 push	 edx
  0108c	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01091	e8 00 00 00 00	 call	 _va
  01096	83 c4 08	 add	 esp, 8
  01099	50		 push	 eax
  0109a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  010a0	50		 push	 eax
  010a1	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  010a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 986  : 				cutscenes[num].scene[scenenum].xcoord[0] = usi;

  010a9	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  010b0	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  010b7	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  010be	b8 02 00 00 00	 mov	 eax, 2
  010c3	6b c8 00	 imul	 ecx, eax, 0
  010c6	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  010cd	66 89 44 0a 68	 mov	 WORD PTR [edx+ecx+104], ax

; 987  : 			}

  010d2	e9 c3 09 00 00	 jmp	 $LN110@readcutsce
$LN71@readcutsce:

; 988  : 			else if (!strcmp(word, "PIC2XCOORD"))

  010d7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NFJBPMKB@PIC2XCOORD@
  010dc	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  010e2	50		 push	 eax
  010e3	e8 00 00 00 00	 call	 _strcmp
  010e8	83 c4 08	 add	 esp, 8
  010eb	85 c0		 test	 eax, eax
  010ed	75 70		 jne	 SHORT $LN73@readcutsce

; 989  : 			{
; 990  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[1]), UNDO_NONE);

  010ef	6a 00		 push	 0
  010f1	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  010f8	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  010ff	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01106	b8 02 00 00 00	 mov	 eax, 2
  0110b	c1 e0 00	 shl	 eax, 0
  0110e	0f b7 4c 02 68	 movzx	 ecx, WORD PTR [edx+eax+104]
  01113	51		 push	 ecx
  01114	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01119	e8 00 00 00 00	 call	 _va
  0111e	83 c4 08	 add	 esp, 8
  01121	50		 push	 eax
  01122	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  01128	52		 push	 edx
  01129	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0112e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 991  : 				cutscenes[num].scene[scenenum].xcoord[1] = usi;

  01131	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01138	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0113f	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01146	b8 02 00 00 00	 mov	 eax, 2
  0114b	c1 e0 00	 shl	 eax, 0
  0114e	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  01155	66 89 4c 02 68	 mov	 WORD PTR [edx+eax+104], cx

; 992  : 			}

  0115a	e9 3b 09 00 00	 jmp	 $LN110@readcutsce
$LN73@readcutsce:

; 993  : 			else if (!strcmp(word, "PIC3XCOORD"))

  0115f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BJDLPMDP@PIC3XCOORD@
  01164	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0116a	50		 push	 eax
  0116b	e8 00 00 00 00	 call	 _strcmp
  01170	83 c4 08	 add	 esp, 8
  01173	85 c0		 test	 eax, eax
  01175	75 6e		 jne	 SHORT $LN75@readcutsce

; 994  : 			{
; 995  : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[2]), UNDO_NONE);

  01177	6a 00		 push	 0
  01179	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01180	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01187	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0118e	b8 02 00 00 00	 mov	 eax, 2
  01193	d1 e0		 shl	 eax, 1
  01195	0f b7 4c 02 68	 movzx	 ecx, WORD PTR [edx+eax+104]
  0119a	51		 push	 ecx
  0119b	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  011a0	e8 00 00 00 00	 call	 _va
  011a5	83 c4 08	 add	 esp, 8
  011a8	50		 push	 eax
  011a9	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  011af	52		 push	 edx
  011b0	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  011b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 				cutscenes[num].scene[scenenum].xcoord[2] = usi;

  011b8	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  011bf	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  011c6	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  011cd	b8 02 00 00 00	 mov	 eax, 2
  011d2	d1 e0		 shl	 eax, 1
  011d4	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  011db	66 89 4c 02 68	 mov	 WORD PTR [edx+eax+104], cx

; 997  : 			}

  011e0	e9 b5 08 00 00	 jmp	 $LN110@readcutsce
$LN75@readcutsce:

; 998  : 			else if (!strcmp(word, "PIC4XCOORD"))

  011e5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BDPOPFCG@PIC4XCOORD@
  011ea	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  011f0	50		 push	 eax
  011f1	e8 00 00 00 00	 call	 _strcmp
  011f6	83 c4 08	 add	 esp, 8
  011f9	85 c0		 test	 eax, eax
  011fb	75 70		 jne	 SHORT $LN77@readcutsce

; 999  : 			{
; 1000 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[3]), UNDO_NONE);

  011fd	6a 00		 push	 0
  011ff	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01206	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0120d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01214	b8 02 00 00 00	 mov	 eax, 2
  01219	6b c8 03	 imul	 ecx, eax, 3
  0121c	0f b7 54 0a 68	 movzx	 edx, WORD PTR [edx+ecx+104]
  01221	52		 push	 edx
  01222	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01227	e8 00 00 00 00	 call	 _va
  0122c	83 c4 08	 add	 esp, 8
  0122f	50		 push	 eax
  01230	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01236	50		 push	 eax
  01237	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0123c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1001 : 				cutscenes[num].scene[scenenum].xcoord[3] = usi;

  0123f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01246	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0124d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01254	b8 02 00 00 00	 mov	 eax, 2
  01259	6b c8 03	 imul	 ecx, eax, 3
  0125c	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  01263	66 89 44 0a 68	 mov	 WORD PTR [edx+ecx+104], ax

; 1002 : 			}

  01268	e9 2d 08 00 00	 jmp	 $LN110@readcutsce
$LN77@readcutsce:

; 1003 : 			else if (!strcmp(word, "PIC5XCOORD"))

  0126d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NPFEPFLI@PIC5XCOORD@
  01272	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01278	50		 push	 eax
  01279	e8 00 00 00 00	 call	 _strcmp
  0127e	83 c4 08	 add	 esp, 8
  01281	85 c0		 test	 eax, eax
  01283	75 70		 jne	 SHORT $LN79@readcutsce

; 1004 : 			{
; 1005 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[4]), UNDO_NONE);

  01285	6a 00		 push	 0
  01287	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0128e	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01295	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0129c	b8 02 00 00 00	 mov	 eax, 2
  012a1	c1 e0 02	 shl	 eax, 2
  012a4	0f b7 4c 02 68	 movzx	 ecx, WORD PTR [edx+eax+104]
  012a9	51		 push	 ecx
  012aa	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  012af	e8 00 00 00 00	 call	 _va
  012b4	83 c4 08	 add	 esp, 8
  012b7	50		 push	 eax
  012b8	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  012be	52		 push	 edx
  012bf	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  012c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1006 : 				cutscenes[num].scene[scenenum].xcoord[4] = usi;

  012c7	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  012ce	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  012d5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  012dc	b8 02 00 00 00	 mov	 eax, 2
  012e1	c1 e0 02	 shl	 eax, 2
  012e4	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  012eb	66 89 4c 02 68	 mov	 WORD PTR [edx+eax+104], cx

; 1007 : 			}

  012f0	e9 a5 07 00 00	 jmp	 $LN110@readcutsce
$LN79@readcutsce:

; 1008 : 			else if (!strcmp(word, "PIC6XCOORD"))

  012f5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FBNLPCFL@PIC6XCOORD@
  012fa	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01300	50		 push	 eax
  01301	e8 00 00 00 00	 call	 _strcmp
  01306	83 c4 08	 add	 esp, 8
  01309	85 c0		 test	 eax, eax
  0130b	75 70		 jne	 SHORT $LN81@readcutsce

; 1009 : 			{
; 1010 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[5]), UNDO_NONE);

  0130d	6a 00		 push	 0
  0130f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01316	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0131d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01324	b8 02 00 00 00	 mov	 eax, 2
  01329	6b c8 05	 imul	 ecx, eax, 5
  0132c	0f b7 54 0a 68	 movzx	 edx, WORD PTR [edx+ecx+104]
  01331	52		 push	 edx
  01332	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01337	e8 00 00 00 00	 call	 _va
  0133c	83 c4 08	 add	 esp, 8
  0133f	50		 push	 eax
  01340	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01346	50		 push	 eax
  01347	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0134c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1011 : 				cutscenes[num].scene[scenenum].xcoord[5] = usi;

  0134f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01356	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0135d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01364	b8 02 00 00 00	 mov	 eax, 2
  01369	6b c8 05	 imul	 ecx, eax, 5
  0136c	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  01373	66 89 44 0a 68	 mov	 WORD PTR [edx+ecx+104], ax

; 1012 : 			}

  01378	e9 1d 07 00 00	 jmp	 $LN110@readcutsce
$LN81@readcutsce:

; 1013 : 			else if (!strcmp(word, "PIC7XCOORD"))

  0137d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JNHBPCMF@PIC7XCOORD@
  01382	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01388	50		 push	 eax
  01389	e8 00 00 00 00	 call	 _strcmp
  0138e	83 c4 08	 add	 esp, 8
  01391	85 c0		 test	 eax, eax
  01393	75 70		 jne	 SHORT $LN83@readcutsce

; 1014 : 			{
; 1015 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[6]), UNDO_NONE);

  01395	6a 00		 push	 0
  01397	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0139e	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  013a5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  013ac	b8 02 00 00 00	 mov	 eax, 2
  013b1	6b c8 06	 imul	 ecx, eax, 6
  013b4	0f b7 54 0a 68	 movzx	 edx, WORD PTR [edx+ecx+104]
  013b9	52		 push	 edx
  013ba	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  013bf	e8 00 00 00 00	 call	 _va
  013c4	83 c4 08	 add	 esp, 8
  013c7	50		 push	 eax
  013c8	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  013ce	50		 push	 eax
  013cf	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  013d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1016 : 				cutscenes[num].scene[scenenum].xcoord[6] = usi;

  013d7	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  013de	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  013e5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  013ec	b8 02 00 00 00	 mov	 eax, 2
  013f1	6b c8 06	 imul	 ecx, eax, 6
  013f4	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  013fb	66 89 44 0a 68	 mov	 WORD PTR [edx+ecx+104], ax

; 1017 : 			}

  01400	e9 95 06 00 00	 jmp	 $LN110@readcutsce
$LN83@readcutsce:

; 1018 : 			else if (!strcmp(word, "PIC8XCOORD"))

  01405	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EEFBOAGJ@PIC8XCOORD@
  0140a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01410	50		 push	 eax
  01411	e8 00 00 00 00	 call	 _strcmp
  01416	83 c4 08	 add	 esp, 8
  01419	85 c0		 test	 eax, eax
  0141b	75 70		 jne	 SHORT $LN85@readcutsce

; 1019 : 			{
; 1020 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].xcoord[7]), UNDO_NONE);

  0141d	6a 00		 push	 0
  0141f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01426	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0142d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01434	b8 02 00 00 00	 mov	 eax, 2
  01439	6b c8 07	 imul	 ecx, eax, 7
  0143c	0f b7 54 0a 68	 movzx	 edx, WORD PTR [edx+ecx+104]
  01441	52		 push	 edx
  01442	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01447	e8 00 00 00 00	 call	 _va
  0144c	83 c4 08	 add	 esp, 8
  0144f	50		 push	 eax
  01450	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01456	50		 push	 eax
  01457	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0145c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1021 : 				cutscenes[num].scene[scenenum].xcoord[7] = usi;

  0145f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01466	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0146d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01474	b8 02 00 00 00	 mov	 eax, 2
  01479	6b c8 07	 imul	 ecx, eax, 7
  0147c	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  01483	66 89 44 0a 68	 mov	 WORD PTR [edx+ecx+104], ax

; 1022 : 			}

  01488	e9 0d 06 00 00	 jmp	 $LN110@readcutsce
$LN85@readcutsce:

; 1023 : 			else if (!strcmp(word, "PIC1YCOORD"))

  0148d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PNGJPAPG@PIC1YCOORD@
  01492	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01498	50		 push	 eax
  01499	e8 00 00 00 00	 call	 _strcmp
  0149e	83 c4 08	 add	 esp, 8
  014a1	85 c0		 test	 eax, eax
  014a3	75 70		 jne	 SHORT $LN87@readcutsce

; 1024 : 			{
; 1025 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[0]), UNDO_NONE);

  014a5	6a 00		 push	 0
  014a7	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  014ae	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  014b5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  014bc	b8 02 00 00 00	 mov	 eax, 2
  014c1	6b c8 00	 imul	 ecx, eax, 0
  014c4	0f b7 54 0a 78	 movzx	 edx, WORD PTR [edx+ecx+120]
  014c9	52		 push	 edx
  014ca	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  014cf	e8 00 00 00 00	 call	 _va
  014d4	83 c4 08	 add	 esp, 8
  014d7	50		 push	 eax
  014d8	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  014de	50		 push	 eax
  014df	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  014e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1026 : 				cutscenes[num].scene[scenenum].ycoord[0] = usi;

  014e7	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  014ee	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  014f5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  014fc	b8 02 00 00 00	 mov	 eax, 2
  01501	6b c8 00	 imul	 ecx, eax, 0
  01504	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  0150b	66 89 44 0a 78	 mov	 WORD PTR [edx+ecx+120], ax

; 1027 : 			}

  01510	e9 85 05 00 00	 jmp	 $LN110@readcutsce
$LN87@readcutsce:

; 1028 : 			else if (!strcmp(word, "PIC2YCOORD"))

  01515	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HDOGPHBF@PIC2YCOORD@
  0151a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01520	50		 push	 eax
  01521	e8 00 00 00 00	 call	 _strcmp
  01526	83 c4 08	 add	 esp, 8
  01529	85 c0		 test	 eax, eax
  0152b	75 70		 jne	 SHORT $LN89@readcutsce

; 1029 : 			{
; 1030 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[1]), UNDO_NONE);

  0152d	6a 00		 push	 0
  0152f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01536	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0153d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01544	b8 02 00 00 00	 mov	 eax, 2
  01549	c1 e0 00	 shl	 eax, 0
  0154c	0f b7 4c 02 78	 movzx	 ecx, WORD PTR [edx+eax+120]
  01551	51		 push	 ecx
  01552	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01557	e8 00 00 00 00	 call	 _va
  0155c	83 c4 08	 add	 esp, 8
  0155f	50		 push	 eax
  01560	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  01566	52		 push	 edx
  01567	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0156c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1031 : 				cutscenes[num].scene[scenenum].ycoord[1] = usi;

  0156f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01576	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0157d	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01584	b8 02 00 00 00	 mov	 eax, 2
  01589	c1 e0 00	 shl	 eax, 0
  0158c	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  01593	66 89 4c 02 78	 mov	 WORD PTR [edx+eax+120], cx

; 1032 : 			}

  01598	e9 fd 04 00 00	 jmp	 $LN110@readcutsce
$LN89@readcutsce:

; 1033 : 			else if (!strcmp(word, "PIC3YCOORD"))

  0159d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LPEMPHIL@PIC3YCOORD@
  015a2	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  015a8	50		 push	 eax
  015a9	e8 00 00 00 00	 call	 _strcmp
  015ae	83 c4 08	 add	 esp, 8
  015b1	85 c0		 test	 eax, eax
  015b3	75 6e		 jne	 SHORT $LN91@readcutsce

; 1034 : 			{
; 1035 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[2]), UNDO_NONE);

  015b5	6a 00		 push	 0
  015b7	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  015be	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  015c5	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  015cc	b8 02 00 00 00	 mov	 eax, 2
  015d1	d1 e0		 shl	 eax, 1
  015d3	0f b7 4c 02 78	 movzx	 ecx, WORD PTR [edx+eax+120]
  015d8	51		 push	 ecx
  015d9	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  015de	e8 00 00 00 00	 call	 _va
  015e3	83 c4 08	 add	 esp, 8
  015e6	50		 push	 eax
  015e7	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  015ed	52		 push	 edx
  015ee	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  015f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1036 : 				cutscenes[num].scene[scenenum].ycoord[2] = usi;

  015f6	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  015fd	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01604	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0160b	b8 02 00 00 00	 mov	 eax, 2
  01610	d1 e0		 shl	 eax, 1
  01612	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  01619	66 89 4c 02 78	 mov	 WORD PTR [edx+eax+120], cx

; 1037 : 			}

  0161e	e9 77 04 00 00	 jmp	 $LN110@readcutsce
$LN91@readcutsce:

; 1038 : 			else if (!strcmp(word, "PIC4YCOORD"))

  01623	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LFIJPOJC@PIC4YCOORD@
  01628	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0162e	50		 push	 eax
  0162f	e8 00 00 00 00	 call	 _strcmp
  01634	83 c4 08	 add	 esp, 8
  01637	85 c0		 test	 eax, eax
  01639	75 70		 jne	 SHORT $LN93@readcutsce

; 1039 : 			{
; 1040 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[3]), UNDO_NONE);

  0163b	6a 00		 push	 0
  0163d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01644	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0164b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01652	b8 02 00 00 00	 mov	 eax, 2
  01657	6b c8 03	 imul	 ecx, eax, 3
  0165a	0f b7 54 0a 78	 movzx	 edx, WORD PTR [edx+ecx+120]
  0165f	52		 push	 edx
  01660	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01665	e8 00 00 00 00	 call	 _va
  0166a	83 c4 08	 add	 esp, 8
  0166d	50		 push	 eax
  0166e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01674	50		 push	 eax
  01675	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0167a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1041 : 				cutscenes[num].scene[scenenum].ycoord[3] = usi;

  0167d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01684	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0168b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01692	b8 02 00 00 00	 mov	 eax, 2
  01697	6b c8 03	 imul	 ecx, eax, 3
  0169a	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  016a1	66 89 44 0a 78	 mov	 WORD PTR [edx+ecx+120], ax

; 1042 : 			}

  016a6	e9 ef 03 00 00	 jmp	 $LN110@readcutsce
$LN93@readcutsce:

; 1043 : 			else if (!strcmp(word, "PIC5YCOORD"))

  016ab	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HJCDPOAM@PIC5YCOORD@
  016b0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  016b6	50		 push	 eax
  016b7	e8 00 00 00 00	 call	 _strcmp
  016bc	83 c4 08	 add	 esp, 8
  016bf	85 c0		 test	 eax, eax
  016c1	75 70		 jne	 SHORT $LN95@readcutsce

; 1044 : 			{
; 1045 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[4]), UNDO_NONE);

  016c3	6a 00		 push	 0
  016c5	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  016cc	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  016d3	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  016da	b8 02 00 00 00	 mov	 eax, 2
  016df	c1 e0 02	 shl	 eax, 2
  016e2	0f b7 4c 02 78	 movzx	 ecx, WORD PTR [edx+eax+120]
  016e7	51		 push	 ecx
  016e8	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  016ed	e8 00 00 00 00	 call	 _va
  016f2	83 c4 08	 add	 esp, 8
  016f5	50		 push	 eax
  016f6	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  016fc	52		 push	 edx
  016fd	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  01702	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1046 : 				cutscenes[num].scene[scenenum].ycoord[4] = usi;

  01705	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0170c	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01713	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0171a	b8 02 00 00 00	 mov	 eax, 2
  0171f	c1 e0 02	 shl	 eax, 2
  01722	66 8b 8d ec fb
	ff ff		 mov	 cx, WORD PTR _usi$[ebp]
  01729	66 89 4c 02 78	 mov	 WORD PTR [edx+eax+120], cx

; 1047 : 			}

  0172e	e9 67 03 00 00	 jmp	 $LN110@readcutsce
$LN95@readcutsce:

; 1048 : 			else if (!strcmp(word, "PIC6YCOORD"))

  01733	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PHKMPJOP@PIC6YCOORD@
  01738	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0173e	50		 push	 eax
  0173f	e8 00 00 00 00	 call	 _strcmp
  01744	83 c4 08	 add	 esp, 8
  01747	85 c0		 test	 eax, eax
  01749	75 70		 jne	 SHORT $LN97@readcutsce

; 1049 : 			{
; 1050 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[5]), UNDO_NONE);

  0174b	6a 00		 push	 0
  0174d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01754	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0175b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01762	b8 02 00 00 00	 mov	 eax, 2
  01767	6b c8 05	 imul	 ecx, eax, 5
  0176a	0f b7 54 0a 78	 movzx	 edx, WORD PTR [edx+ecx+120]
  0176f	52		 push	 edx
  01770	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01775	e8 00 00 00 00	 call	 _va
  0177a	83 c4 08	 add	 esp, 8
  0177d	50		 push	 eax
  0177e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01784	50		 push	 eax
  01785	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0178a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1051 : 				cutscenes[num].scene[scenenum].ycoord[5] = usi;

  0178d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01794	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0179b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  017a2	b8 02 00 00 00	 mov	 eax, 2
  017a7	6b c8 05	 imul	 ecx, eax, 5
  017aa	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  017b1	66 89 44 0a 78	 mov	 WORD PTR [edx+ecx+120], ax

; 1052 : 			}

  017b6	e9 df 02 00 00	 jmp	 $LN110@readcutsce
$LN97@readcutsce:

; 1053 : 			else if (!strcmp(word, "PIC7YCOORD"))

  017bb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DLAGPJHB@PIC7YCOORD@
  017c0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  017c6	50		 push	 eax
  017c7	e8 00 00 00 00	 call	 _strcmp
  017cc	83 c4 08	 add	 esp, 8
  017cf	85 c0		 test	 eax, eax
  017d1	75 70		 jne	 SHORT $LN99@readcutsce

; 1054 : 			{
; 1055 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[6]), UNDO_NONE);

  017d3	6a 00		 push	 0
  017d5	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  017dc	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  017e3	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  017ea	b8 02 00 00 00	 mov	 eax, 2
  017ef	6b c8 06	 imul	 ecx, eax, 6
  017f2	0f b7 54 0a 78	 movzx	 edx, WORD PTR [edx+ecx+120]
  017f7	52		 push	 edx
  017f8	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  017fd	e8 00 00 00 00	 call	 _va
  01802	83 c4 08	 add	 esp, 8
  01805	50		 push	 eax
  01806	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0180c	50		 push	 eax
  0180d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  01812	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1056 : 				cutscenes[num].scene[scenenum].ycoord[6] = usi;

  01815	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0181c	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01823	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  0182a	b8 02 00 00 00	 mov	 eax, 2
  0182f	6b c8 06	 imul	 ecx, eax, 6
  01832	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  01839	66 89 44 0a 78	 mov	 WORD PTR [edx+ecx+120], ax

; 1057 : 			}

  0183e	e9 57 02 00 00	 jmp	 $LN110@readcutsce
$LN99@readcutsce:

; 1058 : 			else if (!strcmp(word, "PIC8YCOORD"))

  01843	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OCCGOLNN@PIC8YCOORD@
  01848	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0184e	50		 push	 eax
  0184f	e8 00 00 00 00	 call	 _strcmp
  01854	83 c4 08	 add	 esp, 8
  01857	85 c0		 test	 eax, eax
  01859	75 70		 jne	 SHORT $LN101@readcutsce

; 1059 : 			{
; 1060 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].ycoord[7]), UNDO_NONE);

  0185b	6a 00		 push	 0
  0185d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01864	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  0186b	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  01872	b8 02 00 00 00	 mov	 eax, 2
  01877	6b c8 07	 imul	 ecx, eax, 7
  0187a	0f b7 54 0a 78	 movzx	 edx, WORD PTR [edx+ecx+120]
  0187f	52		 push	 edx
  01880	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01885	e8 00 00 00 00	 call	 _va
  0188a	83 c4 08	 add	 esp, 8
  0188d	50		 push	 eax
  0188e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01894	50		 push	 eax
  01895	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0189a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1061 : 				cutscenes[num].scene[scenenum].ycoord[7] = usi;

  0189d	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  018a4	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  018ab	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR _cutscenes[eax+ecx]
  018b2	b8 02 00 00 00	 mov	 eax, 2
  018b7	6b c8 07	 imul	 ecx, eax, 7
  018ba	66 8b 85 ec fb
	ff ff		 mov	 ax, WORD PTR _usi$[ebp]
  018c1	66 89 44 0a 78	 mov	 WORD PTR [edx+ecx+120], ax

; 1062 : 			}

  018c6	e9 cf 01 00 00	 jmp	 $LN110@readcutsce
$LN101@readcutsce:

; 1063 : 			else if (!strcmp(word, "MUSICSLOT"))

  018cb	68 00 00 00 00	 push	 OFFSET ??_C@_09MHGCKDNO@MUSICSLOT@
  018d0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  018d6	50		 push	 eax
  018d7	e8 00 00 00 00	 call	 _strcmp
  018dc	83 c4 08	 add	 esp, 8
  018df	85 c0		 test	 eax, eax
  018e1	75 55		 jne	 SHORT $LN103@readcutsce

; 1064 : 			{
; 1065 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].musicslot), UNDO_NONE);

  018e3	6a 00		 push	 0
  018e5	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  018ec	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  018f3	8b 94 08 98 00
	00 00		 mov	 edx, DWORD PTR _cutscenes[eax+ecx+152]
  018fa	52		 push	 edx
  018fb	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01900	e8 00 00 00 00	 call	 _va
  01905	83 c4 08	 add	 esp, 8
  01908	50		 push	 eax
  01909	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0190f	50		 push	 eax
  01910	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  01915	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1066 : 				cutscenes[num].scene[scenenum].musicslot = (musicenum_t)i;

  01918	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0191f	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01926	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0192c	89 94 08 98 00
	00 00		 mov	 DWORD PTR _cutscenes[eax+ecx+152], edx

; 1067 : 			}

  01933	e9 62 01 00 00	 jmp	 $LN110@readcutsce
$LN103@readcutsce:

; 1068 : 			else if (!strcmp(word, "MUSICLOOP"))

  01938	68 00 00 00 00	 push	 OFFSET ??_C@_09FDALMJGH@MUSICLOOP@
  0193d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01943	50		 push	 eax
  01944	e8 00 00 00 00	 call	 _strcmp
  01949	83 c4 08	 add	 esp, 8
  0194c	85 c0		 test	 eax, eax
  0194e	75 55		 jne	 SHORT $LN105@readcutsce

; 1069 : 			{
; 1070 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].musicloop), UNDO_NONE);

  01950	6a 00		 push	 0
  01952	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01959	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01960	8b 94 08 9c 00
	00 00		 mov	 edx, DWORD PTR _cutscenes[eax+ecx+156]
  01967	52		 push	 edx
  01968	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  0196d	e8 00 00 00 00	 call	 _va
  01972	83 c4 08	 add	 esp, 8
  01975	50		 push	 eax
  01976	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0197c	50		 push	 eax
  0197d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  01982	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1071 : 				cutscenes[num].scene[scenenum].musicloop = i;

  01985	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  0198c	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01993	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  01999	89 94 08 9c 00
	00 00		 mov	 DWORD PTR _cutscenes[eax+ecx+156], edx

; 1072 : 			}

  019a0	e9 f5 00 00 00	 jmp	 $LN110@readcutsce
$LN105@readcutsce:

; 1073 : 			else if (!strcmp(word, "TEXTXPOS"))

  019a5	68 00 00 00 00	 push	 OFFSET ??_C@_08PJCOJFFB@TEXTXPOS@
  019aa	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  019b0	50		 push	 eax
  019b1	e8 00 00 00 00	 call	 _strcmp
  019b6	83 c4 08	 add	 esp, 8
  019b9	85 c0		 test	 eax, eax
  019bb	75 58		 jne	 SHORT $LN107@readcutsce

; 1074 : 			{
; 1075 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].textxpos), UNDO_NONE);

  019bd	6a 00		 push	 0
  019bf	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  019c6	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  019cd	0f b7 94 08 a0
	00 00 00	 movzx	 edx, WORD PTR _cutscenes[eax+ecx+160]
  019d5	52		 push	 edx
  019d6	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  019db	e8 00 00 00 00	 call	 _va
  019e0	83 c4 08	 add	 esp, 8
  019e3	50		 push	 eax
  019e4	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  019ea	50		 push	 eax
  019eb	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  019f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1076 : 				cutscenes[num].scene[scenenum].textxpos = usi;

  019f3	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  019fa	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01a01	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _usi$[ebp]
  01a08	66 89 94 08 a0
	00 00 00	 mov	 WORD PTR _cutscenes[eax+ecx+160], dx

; 1077 : 			}

  01a10	e9 85 00 00 00	 jmp	 $LN110@readcutsce
$LN107@readcutsce:

; 1078 : 			else if (!strcmp(word, "TEXTYPOS"))

  01a15	68 00 00 00 00	 push	 OFFSET ??_C@_08MEEOLMOB@TEXTYPOS@
  01a1a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01a20	50		 push	 eax
  01a21	e8 00 00 00 00	 call	 _strcmp
  01a26	83 c4 08	 add	 esp, 8
  01a29	85 c0		 test	 eax, eax
  01a2b	75 55		 jne	 SHORT $LN109@readcutsce

; 1079 : 			{
; 1080 : 				DEH_WriteUndoline(word, va("%u", cutscenes[num].scene[scenenum].textypos), UNDO_NONE);

  01a2d	6a 00		 push	 0
  01a2f	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01a36	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01a3d	0f b7 94 08 a2
	00 00 00	 movzx	 edx, WORD PTR _cutscenes[eax+ecx+162]
  01a45	52		 push	 edx
  01a46	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01a4b	e8 00 00 00 00	 call	 _va
  01a50	83 c4 08	 add	 esp, 8
  01a53	50		 push	 eax
  01a54	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01a5a	50		 push	 eax
  01a5b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  01a60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1081 : 				cutscenes[num].scene[scenenum].textypos = usi;

  01a63	69 45 0c 04 52
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 20996
  01a6a	69 4d 10 a4 00
	00 00		 imul	 ecx, DWORD PTR _scenenum$[ebp], 164
  01a71	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _usi$[ebp]
  01a78	66 89 94 08 a2
	00 00 00	 mov	 WORD PTR _cutscenes[eax+ecx+162], dx

; 1082 : 			}

  01a80	eb 18		 jmp	 SHORT $LN110@readcutsce
$LN109@readcutsce:

; 1083 : 			else
; 1084 : 				deh_warning("CutSceneScene %d: unknown word '%s'", num, word);

  01a82	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  01a88	50		 push	 eax
  01a89	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  01a8c	51		 push	 ecx
  01a8d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BHIFLOEA@CutSceneScene?5?$CFd?3?5unknown?5word?5@
  01a92	e8 00 00 00 00	 call	 _deh_warning
  01a97	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN110@readcutsce:

; 1085 : 		}
; 1086 : 	} while (!myfeof(f)); // finish when the line is empty

  01a9a	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  01a9d	8b 08		 mov	 ecx, DWORD PTR [eax]
  01a9f	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  01aa2	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  01aa5	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  01aa8	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  01aab	0f 87 af e5 ff
	ff		 ja	 $LN4@readcutsce
$LN3@readcutsce:

; 1087 : }

  01ab1	5f		 pop	 edi
  01ab2	5e		 pop	 esi
  01ab3	5b		 pop	 ebx
  01ab4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ab7	33 cd		 xor	 ecx, ebp
  01ab9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01abe	8b e5		 mov	 esp, ebp
  01ac0	5d		 pop	 ebp
  01ac1	c3		 ret	 0
_readcutscenescene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readlevelheader
_TEXT	SEGMENT
_i$ = -1044						; size = 4
_tmp$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readlevelheader PROC					; COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 605  : 	XBOXSTATIC char s[MAXLINELEN];
; 606  : 	char *word = s;

  00016	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0001c	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax
$LN4@readlevelh:

; 607  : 	char *word2;
; 608  : 	char *tmp;
; 609  : 	INT32 i;
; 610  : 
; 611  : 	do
; 612  : 	{
; 613  : 		if (myfgets(s, sizeof (s), f))

  00022	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00025	50		 push	 eax
  00026	68 00 04 00 00	 push	 1024			; 00000400H
  0002b	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _myfgets
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 9b 0b 00
	00		 je	 $LN61@readlevelh

; 614  : 		{
; 615  : 			if (s[0] == '\n')

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00052	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00055	75 05		 jne	 SHORT $LN6@readlevelh

; 616  : 				break;

  00057	e9 98 0b 00 00	 jmp	 $LN3@readlevelh
$LN6@readlevelh:

; 617  : 
; 618  : 			// First remove trailing newline, if there is one
; 619  : 			tmp = strchr(s, '\n');

  0005c	6a 0a		 push	 10			; 0000000aH
  0005e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _strchr
  0006a	83 c4 08	 add	 esp, 8
  0006d	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 620  : 			if (tmp)

  00073	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  0007a	74 09		 je	 SHORT $LN7@readlevelh

; 621  : 				*tmp = '\0';

  0007c	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00082	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readlevelh:

; 622  : 
; 623  : 			tmp = strchr(s, '#');

  00085	6a 23		 push	 35			; 00000023H
  00087	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _strchr
  00093	83 c4 08	 add	 esp, 8
  00096	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 624  : 			if (tmp)

  0009c	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  000a3	74 09		 je	 SHORT $LN8@readlevelh

; 625  : 				*tmp = '\0';

  000a5	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000ab	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN8@readlevelh:

; 626  : 
; 627  : 			// Get the part before the " = "
; 628  : 			tmp = strchr(s, '=');

  000ae	6a 3d		 push	 61			; 0000003dH
  000b0	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _strchr
  000bc	83 c4 08	 add	 esp, 8
  000bf	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 629  : 			*(tmp-1) = '\0';

  000c5	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000cb	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 630  : 			strupr(word);

  000cf	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _strupr
  000db	83 c4 04	 add	 esp, 4

; 631  : 
; 632  : 			// Now get the part after
; 633  : 			word2 = tmp += 2;

  000de	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  000e4	83 c0 02	 add	 eax, 2
  000e7	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax
  000ed	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _tmp$[ebp]
  000f3	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], ecx

; 634  : 			strupr(word2);

  000f9	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _strupr
  00105	83 c4 04	 add	 esp, 4

; 635  : 
; 636  : 			i = atoi(word2); // used for numerical settings

  00108	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _atoi
  00114	83 c4 04	 add	 esp, 4
  00117	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 637  : 
; 638  : 			if (!strcmp(word, "LEVELNAME"))

  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_09MADBCAME@LEVELNAME@
  00122	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _strcmp
  0012e	83 c4 08	 add	 esp, 8
  00131	85 c0		 test	 eax, eax
  00133	75 4d		 jne	 SHORT $LN9@readlevelh

; 639  : 			{
; 640  : 				DEH_WriteUndoline(word, mapheaderinfo[num-1].lvlttl, UNDO_NONE);

  00135	6a 00		 push	 0
  00137	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0013a	83 e8 01	 sub	 eax, 1
  0013d	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00143	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00149	51		 push	 ecx
  0014a	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 				strlcpy(mapheaderinfo[num-1].lvlttl, word2, 33);

  00159	6a 21		 push	 33			; 00000021H
  0015b	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00161	50		 push	 eax
  00162	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00165	83 e9 01	 sub	 ecx, 1
  00168	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  0016e	81 c2 00 00 00
	00		 add	 edx, OFFSET _mapheaderinfo
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 _strlcpy
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 642  : 			}

  0017d	e9 5b 0a 00 00	 jmp	 $LN61@readlevelh
$LN9@readlevelh:

; 643  : 			else if (!strcmp(word, "SUBTITLE"))

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_08OOGGCINI@SUBTITLE@
  00187	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 _strcmp
  00193	83 c4 08	 add	 esp, 8
  00196	85 c0		 test	 eax, eax
  00198	75 4d		 jne	 SHORT $LN11@readlevelh

; 644  : 			{
; 645  : 				DEH_WriteUndoline(word, mapheaderinfo[num-1].subttl, UNDO_NONE);

  0019a	6a 00		 push	 0
  0019c	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0019f	83 e8 01	 sub	 eax, 1
  001a2	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001a8	81 c1 21 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+33
  001ae	51		 push	 ecx
  001af	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 646  : 				strlcpy(mapheaderinfo[num-1].subttl, word2, 33);

  001be	6a 21		 push	 33			; 00000021H
  001c0	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  001ca	83 e9 01	 sub	 ecx, 1
  001cd	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  001d3	81 c2 21 00 00
	00		 add	 edx, OFFSET _mapheaderinfo+33
  001d9	52		 push	 edx
  001da	e8 00 00 00 00	 call	 _strlcpy
  001df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 			}

  001e2	e9 f6 09 00 00	 jmp	 $LN61@readlevelh
$LN11@readlevelh:

; 648  : 			else if (!strcmp(word, "ACT"))

  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_03FBBILEHC@ACT@
  001ec	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 _strcmp
  001f8	83 c4 08	 add	 esp, 8
  001fb	85 c0		 test	 eax, eax
  001fd	75 7c		 jne	 SHORT $LN13@readlevelh

; 649  : 			{
; 650  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].actnum), UNDO_NONE);

  001ff	6a 00		 push	 0
  00201	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00204	83 e8 01	 sub	 eax, 1
  00207	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0020d	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00214	52		 push	 edx
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0021a	e8 00 00 00 00	 call	 _va
  0021f	83 c4 08	 add	 esp, 8
  00222	50		 push	 eax
  00223	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 				if (i >= 0 && i < 20) // 0 for no act number, TTL1 through TTL19

  00232	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _i$[ebp], 0
  00239	7c 23		 jl	 SHORT $LN15@readlevelh
  0023b	83 bd ec fb ff
	ff 14		 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  00242	7d 1a		 jge	 SHORT $LN15@readlevelh

; 652  : 					mapheaderinfo[num-1].actnum = (UINT8)i;

  00244	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00247	83 e8 01	 sub	 eax, 1
  0024a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00250	8a 95 ec fb ff
	ff		 mov	 dl, BYTE PTR _i$[ebp]
  00256	88 91 42 00 00
	00		 mov	 BYTE PTR _mapheaderinfo[ecx+66], dl
  0025c	eb 18		 jmp	 SHORT $LN16@readlevelh
$LN15@readlevelh:

; 653  : 				else
; 654  : 					deh_warning("Level header %d: invalid act number %d", num, i);

  0025e	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00264	50		 push	 eax
  00265	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00268	51		 push	 ecx
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CHCEALKM@Level?5header?5?$CFd?3?5invalid?5act?5nu@
  0026e	e8 00 00 00 00	 call	 _deh_warning
  00273	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@readlevelh:

; 655  : 			}

  00276	e9 62 09 00 00	 jmp	 $LN61@readlevelh
$LN13@readlevelh:

; 656  : 			else if (!strcmp(word, "TYPEOFLEVEL"))

  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GOKBOJDC@TYPEOFLEVEL@
  00280	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 _strcmp
  0028c	83 c4 08	 add	 esp, 8
  0028f	85 c0		 test	 eax, eax
  00291	75 52		 jne	 SHORT $LN17@readlevelh

; 657  : 			{
; 658  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].typeoflevel), UNDO_NONE);

  00293	6a 00		 push	 0
  00295	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00298	83 e8 01	 sub	 eax, 1
  0029b	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002a1	0f bf 91 44 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+68]
  002a8	52		 push	 edx
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  002ae	e8 00 00 00 00	 call	 _va
  002b3	83 c4 08	 add	 esp, 8
  002b6	50		 push	 eax
  002b7	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 659  : 				mapheaderinfo[num-1].typeoflevel = (INT16)i;

  002c6	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  002c9	83 e8 01	 sub	 eax, 1
  002cc	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  002d2	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  002d9	66 89 91 44 00
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+68], dx

; 660  : 			}

  002e0	e9 f8 08 00 00	 jmp	 $LN61@readlevelh
$LN17@readlevelh:

; 661  : 			else if (!strcmp(word, "NEXTLEVEL"))

  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_09HFCIMBHH@NEXTLEVEL@
  002ea	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 _strcmp
  002f6	83 c4 08	 add	 esp, 8
  002f9	85 c0		 test	 eax, eax
  002fb	0f 85 b4 00 00
	00		 jne	 $LN19@readlevelh

; 662  : 			{
; 663  : 				// Support using the actual map name,
; 664  : 				// i.e., Level AB, Level FZ, etc.
; 665  : 
; 666  : 				// Convert to map number
; 667  : 				if (word2[0] >= 'A' && word2[0] <= 'Z')

  00301	b8 01 00 00 00	 mov	 eax, 1
  00306	6b c8 00	 imul	 ecx, eax, 0
  00309	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  0030f	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00313	83 f8 41	 cmp	 eax, 65			; 00000041H
  00316	7c 4b		 jl	 SHORT $LN21@readlevelh
  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	6b c8 00	 imul	 ecx, eax, 0
  00320	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00326	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0032a	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  0032d	7f 34		 jg	 SHORT $LN21@readlevelh

; 668  : 					i = M_MapNumber(word2[0], word2[1]);

  0032f	b8 01 00 00 00	 mov	 eax, 1
  00334	c1 e0 00	 shl	 eax, 0
  00337	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  0033d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00341	52		 push	 edx
  00342	b8 01 00 00 00	 mov	 eax, 1
  00347	6b c8 00	 imul	 ecx, eax, 0
  0034a	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _word2$[ebp]
  00350	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 _M_MapNumber
  0035a	83 c4 08	 add	 esp, 8
  0035d	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN21@readlevelh:

; 669  : 
; 670  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].nextlevel), UNDO_NONE);

  00363	6a 00		 push	 0
  00365	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00368	83 e8 01	 sub	 eax, 1
  0036b	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00371	0f bf 91 46 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+70]
  00378	52		 push	 edx
  00379	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0037e	e8 00 00 00 00	 call	 _va
  00383	83 c4 08	 add	 esp, 8
  00386	50		 push	 eax
  00387	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0038d	50		 push	 eax
  0038e	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00393	83 c4 0c	 add	 esp, 12			; 0000000cH

; 671  : 				mapheaderinfo[num-1].nextlevel = (INT16)i;

  00396	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00399	83 e8 01	 sub	 eax, 1
  0039c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  003a2	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  003a9	66 89 91 46 00
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+70], dx

; 672  : 			}

  003b0	e9 28 08 00 00	 jmp	 $LN61@readlevelh
$LN19@readlevelh:

; 673  : 			else if (!strcmp(word, "MUSICSLOT"))

  003b5	68 00 00 00 00	 push	 OFFSET ??_C@_09MHGCKDNO@MUSICSLOT@
  003ba	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003c0	50		 push	 eax
  003c1	e8 00 00 00 00	 call	 _strcmp
  003c6	83 c4 08	 add	 esp, 8
  003c9	85 c0		 test	 eax, eax
  003cb	75 4f		 jne	 SHORT $LN22@readlevelh

; 674  : 			{
; 675  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].musicslot), UNDO_NONE);

  003cd	6a 00		 push	 0
  003cf	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  003d2	83 e8 01	 sub	 eax, 1
  003d5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  003db	8b 91 48 00 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+72]
  003e1	52		 push	 edx
  003e2	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  003e7	e8 00 00 00 00	 call	 _va
  003ec	83 c4 08	 add	 esp, 8
  003ef	50		 push	 eax
  003f0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  003fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 676  : 				mapheaderinfo[num-1].musicslot = i;

  003ff	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00402	83 e8 01	 sub	 eax, 1
  00405	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0040b	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00411	89 91 48 00 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+72], edx

; 677  : 			}

  00417	e9 c1 07 00 00	 jmp	 $LN61@readlevelh
$LN22@readlevelh:

; 678  : 			else if (!strcmp(word, "FORCECHARACTER"))

  0041c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HOGKHGAO@FORCECHARACTER@
  00421	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00427	50		 push	 eax
  00428	e8 00 00 00 00	 call	 _strcmp
  0042d	83 c4 08	 add	 esp, 8
  00430	85 c0		 test	 eax, eax
  00432	75 50		 jne	 SHORT $LN24@readlevelh

; 679  : 			{
; 680  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].forcecharacter), UNDO_NONE);

  00434	6a 00		 push	 0
  00436	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00439	83 e8 01	 sub	 eax, 1
  0043c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00442	0f b6 91 4c 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+76]
  00449	52		 push	 edx
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0044f	e8 00 00 00 00	 call	 _va
  00454	83 c4 08	 add	 esp, 8
  00457	50		 push	 eax
  00458	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0045e	50		 push	 eax
  0045f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00464	83 c4 0c	 add	 esp, 12			; 0000000cH

; 681  : 				mapheaderinfo[num-1].forcecharacter = (UINT8)i;

  00467	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0046a	83 e8 01	 sub	 eax, 1
  0046d	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00473	8a 95 ec fb ff
	ff		 mov	 dl, BYTE PTR _i$[ebp]
  00479	88 91 4c 00 00
	00		 mov	 BYTE PTR _mapheaderinfo[ecx+76], dl

; 682  : 			}

  0047f	e9 59 07 00 00	 jmp	 $LN61@readlevelh
$LN24@readlevelh:

; 683  : 			else if (!strcmp(word, "WEATHER"))

  00484	68 00 00 00 00	 push	 OFFSET ??_C@_07HKOGDAHK@WEATHER@
  00489	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0048f	50		 push	 eax
  00490	e8 00 00 00 00	 call	 _strcmp
  00495	83 c4 08	 add	 esp, 8
  00498	85 c0		 test	 eax, eax
  0049a	75 50		 jne	 SHORT $LN26@readlevelh

; 684  : 			{
; 685  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].weather), UNDO_NONE);

  0049c	6a 00		 push	 0
  0049e	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  004a1	83 e8 01	 sub	 eax, 1
  004a4	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  004aa	0f b6 91 4d 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+77]
  004b1	52		 push	 edx
  004b2	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004b7	e8 00 00 00 00	 call	 _va
  004bc	83 c4 08	 add	 esp, 8
  004bf	50		 push	 eax
  004c0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  004c6	50		 push	 eax
  004c7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  004cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 686  : 				mapheaderinfo[num-1].weather = (UINT8)i;

  004cf	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  004d2	83 e8 01	 sub	 eax, 1
  004d5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  004db	8a 95 ec fb ff
	ff		 mov	 dl, BYTE PTR _i$[ebp]
  004e1	88 91 4d 00 00
	00		 mov	 BYTE PTR _mapheaderinfo[ecx+77], dl

; 687  : 			}

  004e7	e9 f1 06 00 00	 jmp	 $LN61@readlevelh
$LN26@readlevelh:

; 688  : 			else if (!strcmp(word, "SKYNUM"))

  004ec	68 00 00 00 00	 push	 OFFSET ??_C@_06HEFJHGKD@SKYNUM@
  004f1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  004f7	50		 push	 eax
  004f8	e8 00 00 00 00	 call	 _strcmp
  004fd	83 c4 08	 add	 esp, 8
  00500	85 c0		 test	 eax, eax
  00502	75 52		 jne	 SHORT $LN28@readlevelh

; 689  : 			{
; 690  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].skynum), UNDO_NONE);

  00504	6a 00		 push	 0
  00506	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00509	83 e8 01	 sub	 eax, 1
  0050c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00512	0f bf 91 4e 00
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+78]
  00519	52		 push	 edx
  0051a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0051f	e8 00 00 00 00	 call	 _va
  00524	83 c4 08	 add	 esp, 8
  00527	50		 push	 eax
  00528	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00534	83 c4 0c	 add	 esp, 12			; 0000000cH

; 691  : 				mapheaderinfo[num-1].skynum = (INT16)i;

  00537	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0053a	83 e8 01	 sub	 eax, 1
  0053d	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00543	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  0054a	66 89 91 4e 00
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+78], dx

; 692  : 			}

  00551	e9 87 06 00 00	 jmp	 $LN61@readlevelh
$LN28@readlevelh:

; 693  : 			else if (!strcmp(word, "INTERSCREEN"))

  00556	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PDGEIADF@INTERSCREEN@
  0055b	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00561	50		 push	 eax
  00562	e8 00 00 00 00	 call	 _strcmp
  00567	83 c4 08	 add	 esp, 8
  0056a	85 c0		 test	 eax, eax
  0056c	75 4d		 jne	 SHORT $LN30@readlevelh

; 694  : 			{
; 695  : 				DEH_WriteUndoline(word, mapheaderinfo[num-1].interscreen, UNDO_NONE);

  0056e	6a 00		 push	 0
  00570	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00573	83 e8 01	 sub	 eax, 1
  00576	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0057c	81 c1 50 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+80
  00582	51		 push	 ecx
  00583	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00589	52		 push	 edx
  0058a	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0058f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 696  : 				strncpy(mapheaderinfo[num-1].interscreen, word2, 8);

  00592	6a 08		 push	 8
  00594	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0059a	50		 push	 eax
  0059b	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0059e	83 e9 01	 sub	 ecx, 1
  005a1	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  005a7	81 c2 50 00 00
	00		 add	 edx, OFFSET _mapheaderinfo+80
  005ad	52		 push	 edx
  005ae	e8 00 00 00 00	 call	 _strncpy
  005b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 697  : 				// TODO: This needs fixed. DEH_WriteUndoline expects a terminated string.
; 698  : 			}

  005b6	e9 22 06 00 00	 jmp	 $LN61@readlevelh
$LN30@readlevelh:

; 699  : 			else if (!strcmp(word, "SCRIPTNAME"))

  005bb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OPDCCGFG@SCRIPTNAME@
  005c0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  005c6	50		 push	 eax
  005c7	e8 00 00 00 00	 call	 _strcmp
  005cc	83 c4 08	 add	 esp, 8
  005cf	85 c0		 test	 eax, eax
  005d1	75 50		 jne	 SHORT $LN32@readlevelh

; 700  : 			{
; 701  : 				DEH_WriteUndoline(word, mapheaderinfo[num-1].scriptname, UNDO_NONE);

  005d3	6a 00		 push	 0
  005d5	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  005d8	83 e8 01	 sub	 eax, 1
  005db	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  005e1	81 c1 58 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+88
  005e7	51		 push	 ecx
  005e8	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  005ee	52		 push	 edx
  005ef	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 				strlcpy(mapheaderinfo[num-1].scriptname, word2, sizeof (mapheaderinfo[num-1].scriptname));

  005f7	68 c0 00 00 00	 push	 192			; 000000c0H
  005fc	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00602	50		 push	 eax
  00603	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00606	83 e9 01	 sub	 ecx, 1
  00609	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  0060f	81 c2 58 00 00
	00		 add	 edx, OFFSET _mapheaderinfo+88
  00615	52		 push	 edx
  00616	e8 00 00 00 00	 call	 _strlcpy
  0061b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 703  : 			}

  0061e	e9 ba 05 00 00	 jmp	 $LN61@readlevelh
$LN32@readlevelh:

; 704  : 			else if (!strcmp(word, "SCRIPTISLUMP"))

  00623	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BKNFDAOL@SCRIPTISLUMP@
  00628	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0062e	50		 push	 eax
  0062f	e8 00 00 00 00	 call	 _strcmp
  00634	83 c4 08	 add	 esp, 8
  00637	85 c0		 test	 eax, eax
  00639	75 4f		 jne	 SHORT $LN34@readlevelh

; 705  : 			{
; 706  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].scriptislump), UNDO_NONE);

  0063b	6a 00		 push	 0
  0063d	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00640	83 e8 01	 sub	 eax, 1
  00643	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00649	8b 91 18 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+280]
  0064f	52		 push	 edx
  00650	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00655	e8 00 00 00 00	 call	 _va
  0065a	83 c4 08	 add	 esp, 8
  0065d	50		 push	 eax
  0065e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00664	50		 push	 eax
  00665	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0066a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 707  : 				mapheaderinfo[num-1].scriptislump = i;

  0066d	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00670	83 e8 01	 sub	 eax, 1
  00673	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00679	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0067f	89 91 18 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+280], edx

; 708  : 			}

  00685	e9 53 05 00 00	 jmp	 $LN61@readlevelh
$LN34@readlevelh:

; 709  : 			else if (!strcmp(word, "PRECUTSCENENUM"))

  0068a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DFENKLKN@PRECUTSCENENUM@
  0068f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00695	50		 push	 eax
  00696	e8 00 00 00 00	 call	 _strcmp
  0069b	83 c4 08	 add	 esp, 8
  0069e	85 c0		 test	 eax, eax
  006a0	75 50		 jne	 SHORT $LN36@readlevelh

; 710  : 			{
; 711  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].precutscenenum), UNDO_NONE);

  006a2	6a 00		 push	 0
  006a4	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  006a7	83 e8 01	 sub	 eax, 1
  006aa	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  006b0	0f b6 91 1c 01
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+284]
  006b7	52		 push	 edx
  006b8	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  006bd	e8 00 00 00 00	 call	 _va
  006c2	83 c4 08	 add	 esp, 8
  006c5	50		 push	 eax
  006c6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006cc	50		 push	 eax
  006cd	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  006d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 712  : 				mapheaderinfo[num-1].precutscenenum = (UINT8)i;

  006d5	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  006d8	83 e8 01	 sub	 eax, 1
  006db	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  006e1	8a 95 ec fb ff
	ff		 mov	 dl, BYTE PTR _i$[ebp]
  006e7	88 91 1c 01 00
	00		 mov	 BYTE PTR _mapheaderinfo[ecx+284], dl

; 713  : 			}

  006ed	e9 eb 04 00 00	 jmp	 $LN61@readlevelh
$LN36@readlevelh:

; 714  : 			else if (!strcmp(word, "CUTSCENENUM"))

  006f2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HBBFKHJP@CUTSCENENUM@
  006f7	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006fd	50		 push	 eax
  006fe	e8 00 00 00 00	 call	 _strcmp
  00703	83 c4 08	 add	 esp, 8
  00706	85 c0		 test	 eax, eax
  00708	75 50		 jne	 SHORT $LN38@readlevelh

; 715  : 			{
; 716  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].cutscenenum), UNDO_NONE);

  0070a	6a 00		 push	 0
  0070c	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0070f	83 e8 01	 sub	 eax, 1
  00712	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00718	0f b6 91 1d 01
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+285]
  0071f	52		 push	 edx
  00720	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00725	e8 00 00 00 00	 call	 _va
  0072a	83 c4 08	 add	 esp, 8
  0072d	50		 push	 eax
  0072e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00734	50		 push	 eax
  00735	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0073a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 717  : 				mapheaderinfo[num-1].cutscenenum = (UINT8)i;

  0073d	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00740	83 e8 01	 sub	 eax, 1
  00743	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00749	8a 95 ec fb ff
	ff		 mov	 dl, BYTE PTR _i$[ebp]
  0074f	88 91 1d 01 00
	00		 mov	 BYTE PTR _mapheaderinfo[ecx+285], dl

; 718  : 			}

  00755	e9 83 04 00 00	 jmp	 $LN61@readlevelh
$LN38@readlevelh:

; 719  : 			else if (!strcmp(word, "COUNTDOWN"))

  0075a	68 00 00 00 00	 push	 OFFSET ??_C@_09JPDDLCMH@COUNTDOWN@
  0075f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00765	50		 push	 eax
  00766	e8 00 00 00 00	 call	 _strcmp
  0076b	83 c4 08	 add	 esp, 8
  0076e	85 c0		 test	 eax, eax
  00770	75 52		 jne	 SHORT $LN40@readlevelh

; 720  : 			{
; 721  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].countdown), UNDO_NONE);

  00772	6a 00		 push	 0
  00774	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00777	83 e8 01	 sub	 eax, 1
  0077a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00780	0f bf 91 1e 01
	00 00		 movsx	 edx, WORD PTR _mapheaderinfo[ecx+286]
  00787	52		 push	 edx
  00788	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0078d	e8 00 00 00 00	 call	 _va
  00792	83 c4 08	 add	 esp, 8
  00795	50		 push	 eax
  00796	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0079c	50		 push	 eax
  0079d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  007a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 722  : 				mapheaderinfo[num-1].countdown = (INT16)i;

  007a5	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  007a8	83 e8 01	 sub	 eax, 1
  007ab	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  007b1	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  007b8	66 89 91 1e 01
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+286], dx

; 723  : 			}

  007bf	e9 19 04 00 00	 jmp	 $LN61@readlevelh
$LN40@readlevelh:

; 724  : 			else if (!strcmp(word, "NOZONE"))

  007c4	68 00 00 00 00	 push	 OFFSET ??_C@_06MOHHBCJH@NOZONE@
  007c9	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  007cf	50		 push	 eax
  007d0	e8 00 00 00 00	 call	 _strcmp
  007d5	83 c4 08	 add	 esp, 8
  007d8	85 c0		 test	 eax, eax
  007da	75 4f		 jne	 SHORT $LN42@readlevelh

; 725  : 			{
; 726  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].nozone), UNDO_NONE);

  007dc	6a 00		 push	 0
  007de	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  007e1	83 e8 01	 sub	 eax, 1
  007e4	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  007ea	8b 91 20 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+288]
  007f0	52		 push	 edx
  007f1	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  007f6	e8 00 00 00 00	 call	 _va
  007fb	83 c4 08	 add	 esp, 8
  007fe	50		 push	 eax
  007ff	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00805	50		 push	 eax
  00806	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0080b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 727  : 				mapheaderinfo[num-1].nozone = i;

  0080e	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00811	83 e8 01	 sub	 eax, 1
  00814	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0081a	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00820	89 91 20 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+288], edx

; 728  : 			}

  00826	e9 b2 03 00 00	 jmp	 $LN61@readlevelh
$LN42@readlevelh:

; 729  : 			else if (!strcmp(word, "HIDDEN"))

  0082b	68 00 00 00 00	 push	 OFFSET ??_C@_06JMIOFMHI@HIDDEN@
  00830	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00836	50		 push	 eax
  00837	e8 00 00 00 00	 call	 _strcmp
  0083c	83 c4 08	 add	 esp, 8
  0083f	85 c0		 test	 eax, eax
  00841	75 4f		 jne	 SHORT $LN44@readlevelh

; 730  : 			{
; 731  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].hideinmenu), UNDO_NONE);

  00843	6a 00		 push	 0
  00845	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00848	83 e8 01	 sub	 eax, 1
  0084b	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00851	8b 91 24 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+292]
  00857	52		 push	 edx
  00858	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0085d	e8 00 00 00 00	 call	 _va
  00862	83 c4 08	 add	 esp, 8
  00865	50		 push	 eax
  00866	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0086c	50		 push	 eax
  0086d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00872	83 c4 0c	 add	 esp, 12			; 0000000cH

; 732  : 				mapheaderinfo[num-1].hideinmenu = i;

  00875	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00878	83 e8 01	 sub	 eax, 1
  0087b	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00881	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00887	89 91 24 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+292], edx

; 733  : 			}

  0088d	e9 4b 03 00 00	 jmp	 $LN61@readlevelh
$LN44@readlevelh:

; 734  : 			else if (!strcmp(word, "NOSSMUSIC"))

  00892	68 00 00 00 00	 push	 OFFSET ??_C@_09GKCLDIIP@NOSSMUSIC@
  00897	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0089d	50		 push	 eax
  0089e	e8 00 00 00 00	 call	 _strcmp
  008a3	83 c4 08	 add	 esp, 8
  008a6	85 c0		 test	 eax, eax
  008a8	75 4f		 jne	 SHORT $LN46@readlevelh

; 735  : 			{
; 736  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].nossmusic), UNDO_NONE);

  008aa	6a 00		 push	 0
  008ac	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  008af	83 e8 01	 sub	 eax, 1
  008b2	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  008b8	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+296]
  008be	52		 push	 edx
  008bf	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  008c4	e8 00 00 00 00	 call	 _va
  008c9	83 c4 08	 add	 esp, 8
  008cc	50		 push	 eax
  008cd	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  008d3	50		 push	 eax
  008d4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  008d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 737  : 				mapheaderinfo[num-1].nossmusic = i;

  008dc	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  008df	83 e8 01	 sub	 eax, 1
  008e2	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  008e8	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  008ee	89 91 28 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+296], edx

; 738  : 			}

  008f4	e9 e4 02 00 00	 jmp	 $LN61@readlevelh
$LN46@readlevelh:

; 739  : 			else if (!strcmp(word, "SPEEDMUSIC"))

  008f9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LHJOPLBJ@SPEEDMUSIC@
  008fe	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00904	50		 push	 eax
  00905	e8 00 00 00 00	 call	 _strcmp
  0090a	83 c4 08	 add	 esp, 8
  0090d	85 c0		 test	 eax, eax
  0090f	75 4f		 jne	 SHORT $LN48@readlevelh

; 740  : 			{
; 741  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].speedmusic), UNDO_NONE);

  00911	6a 00		 push	 0
  00913	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00916	83 e8 01	 sub	 eax, 1
  00919	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0091f	8b 91 2c 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+300]
  00925	52		 push	 edx
  00926	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0092b	e8 00 00 00 00	 call	 _va
  00930	83 c4 08	 add	 esp, 8
  00933	50		 push	 eax
  00934	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0093a	50		 push	 eax
  0093b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00940	83 c4 0c	 add	 esp, 12			; 0000000cH

; 742  : 				mapheaderinfo[num-1].speedmusic = i;

  00943	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00946	83 e8 01	 sub	 eax, 1
  00949	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0094f	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00955	89 91 2c 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+300], edx

; 743  : 			}

  0095b	e9 7d 02 00 00	 jmp	 $LN61@readlevelh
$LN48@readlevelh:

; 744  : 			else if (!strcmp(word, "NORELOAD"))

  00960	68 00 00 00 00	 push	 OFFSET ??_C@_08KPPNBABB@NORELOAD@
  00965	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0096b	50		 push	 eax
  0096c	e8 00 00 00 00	 call	 _strcmp
  00971	83 c4 08	 add	 esp, 8
  00974	85 c0		 test	 eax, eax
  00976	75 4f		 jne	 SHORT $LN50@readlevelh

; 745  : 			{
; 746  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].noreload), UNDO_NONE);

  00978	6a 00		 push	 0
  0097a	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0097d	83 e8 01	 sub	 eax, 1
  00980	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00986	8b 91 30 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+304]
  0098c	52		 push	 edx
  0098d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00992	e8 00 00 00 00	 call	 _va
  00997	83 c4 08	 add	 esp, 8
  0099a	50		 push	 eax
  0099b	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  009a1	50		 push	 eax
  009a2	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  009a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 747  : 				mapheaderinfo[num-1].noreload = i;

  009aa	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  009ad	83 e8 01	 sub	 eax, 1
  009b0	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  009b6	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  009bc	89 91 30 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+304], edx

; 748  : 			}

  009c2	e9 16 02 00 00	 jmp	 $LN61@readlevelh
$LN50@readlevelh:

; 749  : 			else if (!strcmp(word, "TIMEATTACK"))

  009c7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IKBJCDCO@TIMEATTACK@
  009cc	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  009d2	50		 push	 eax
  009d3	e8 00 00 00 00	 call	 _strcmp
  009d8	83 c4 08	 add	 esp, 8
  009db	85 c0		 test	 eax, eax
  009dd	75 4f		 jne	 SHORT $LN52@readlevelh

; 750  : 			{
; 751  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].timeattack), UNDO_NONE);

  009df	6a 00		 push	 0
  009e1	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  009e4	83 e8 01	 sub	 eax, 1
  009e7	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  009ed	8b 91 34 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+308]
  009f3	52		 push	 edx
  009f4	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  009f9	e8 00 00 00 00	 call	 _va
  009fe	83 c4 08	 add	 esp, 8
  00a01	50		 push	 eax
  00a02	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00a08	50		 push	 eax
  00a09	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00a0e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  : 				mapheaderinfo[num-1].timeattack = i;

  00a11	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00a14	83 e8 01	 sub	 eax, 1
  00a17	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00a1d	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00a23	89 91 34 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+308], edx

; 753  : 			}

  00a29	e9 af 01 00 00	 jmp	 $LN61@readlevelh
$LN52@readlevelh:

; 754  : 			else if (!strcmp(word, "LEVELSELECT"))

  00a2e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JIALMPNC@LEVELSELECT@
  00a33	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00a39	50		 push	 eax
  00a3a	e8 00 00 00 00	 call	 _strcmp
  00a3f	83 c4 08	 add	 esp, 8
  00a42	85 c0		 test	 eax, eax
  00a44	75 4f		 jne	 SHORT $LN54@readlevelh

; 755  : 			{
; 756  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].levelselect), UNDO_NONE);

  00a46	6a 00		 push	 0
  00a48	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00a4b	83 e8 01	 sub	 eax, 1
  00a4e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00a54	8b 91 38 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+312]
  00a5a	52		 push	 edx
  00a5b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00a60	e8 00 00 00 00	 call	 _va
  00a65	83 c4 08	 add	 esp, 8
  00a68	50		 push	 eax
  00a69	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00a6f	50		 push	 eax
  00a70	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00a75	83 c4 0c	 add	 esp, 12			; 0000000cH

; 757  : 				mapheaderinfo[num-1].levelselect = i;

  00a78	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00a7b	83 e8 01	 sub	 eax, 1
  00a7e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00a84	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00a8a	89 91 38 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+312], edx

; 758  : 			}

  00a90	e9 48 01 00 00	 jmp	 $LN61@readlevelh
$LN54@readlevelh:

; 759  : 			else if (!strcmp(word, "NOPERFECTBONUS"))

  00a95	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PGCBNPFL@NOPERFECTBONUS@
  00a9a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00aa0	50		 push	 eax
  00aa1	e8 00 00 00 00	 call	 _strcmp
  00aa6	83 c4 08	 add	 esp, 8
  00aa9	85 c0		 test	 eax, eax
  00aab	75 4f		 jne	 SHORT $LN56@readlevelh

; 760  : 			{
; 761  : 				DEH_WriteUndoline(word, va("%d", mapheaderinfo[num-1].noperfectbns), UNDO_NONE);

  00aad	6a 00		 push	 0
  00aaf	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00ab2	83 e8 01	 sub	 eax, 1
  00ab5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00abb	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR _mapheaderinfo[ecx+316]
  00ac1	52		 push	 edx
  00ac2	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00ac7	e8 00 00 00 00	 call	 _va
  00acc	83 c4 08	 add	 esp, 8
  00acf	50		 push	 eax
  00ad0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00ad6	50		 push	 eax
  00ad7	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00adc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 762  : 				mapheaderinfo[num-1].noperfectbns = i;

  00adf	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00ae2	83 e8 01	 sub	 eax, 1
  00ae5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00aeb	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00af1	89 91 3c 01 00
	00		 mov	 DWORD PTR _mapheaderinfo[ecx+316], edx

; 763  : 			}

  00af7	e9 e1 00 00 00	 jmp	 $LN61@readlevelh
$LN56@readlevelh:

; 764  : 			else if (!strcmp(word, "RUNSOC"))

  00afc	68 00 00 00 00	 push	 OFFSET ??_C@_06BEHDNBAE@RUNSOC@
  00b01	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00b07	50		 push	 eax
  00b08	e8 00 00 00 00	 call	 _strcmp
  00b0d	83 c4 08	 add	 esp, 8
  00b10	85 c0		 test	 eax, eax
  00b12	75 4a		 jne	 SHORT $LN58@readlevelh

; 765  : 			{
; 766  : 				DEH_WriteUndoline(word, mapheaderinfo[num-1].runsoc, UNDO_NONE);

  00b14	6a 00		 push	 0
  00b16	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00b19	83 e8 01	 sub	 eax, 1
  00b1c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00b22	81 c1 40 01 00
	00		 add	 ecx, OFFSET _mapheaderinfo+320
  00b28	51		 push	 ecx
  00b29	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00b2f	52		 push	 edx
  00b30	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00b35	83 c4 0c	 add	 esp, 12			; 0000000cH

; 767  : 				strlcpy(mapheaderinfo[num-1].runsoc, word2, sizeof (mapheaderinfo[num-1].runsoc));

  00b38	6a 40		 push	 64			; 00000040H
  00b3a	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00b40	50		 push	 eax
  00b41	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00b44	83 e9 01	 sub	 ecx, 1
  00b47	69 d1 84 01 00
	00		 imul	 edx, ecx, 388
  00b4d	81 c2 40 01 00
	00		 add	 edx, OFFSET _mapheaderinfo+320
  00b53	52		 push	 edx
  00b54	e8 00 00 00 00	 call	 _strlcpy
  00b59	83 c4 0c	 add	 esp, 12			; 0000000cH

; 768  : 			}

  00b5c	eb 7f		 jmp	 SHORT $LN61@readlevelh
$LN58@readlevelh:

; 769  : 			else if (!strcmp(word, "PALETTE"))

  00b5e	68 00 00 00 00	 push	 OFFSET ??_C@_07GHNKBFGK@PALETTE@
  00b63	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00b69	50		 push	 eax
  00b6a	e8 00 00 00 00	 call	 _strcmp
  00b6f	83 c4 08	 add	 esp, 8
  00b72	85 c0		 test	 eax, eax
  00b74	75 4f		 jne	 SHORT $LN60@readlevelh

; 770  : 			{
; 771  : 				DEH_WriteUndoline(word, va("%u", mapheaderinfo[num-1].palette), UNDO_NONE);

  00b76	6a 00		 push	 0
  00b78	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00b7b	83 e8 01	 sub	 eax, 1
  00b7e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00b84	0f b7 91 80 01
	00 00		 movzx	 edx, WORD PTR _mapheaderinfo[ecx+384]
  00b8b	52		 push	 edx
  00b8c	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00b91	e8 00 00 00 00	 call	 _va
  00b96	83 c4 08	 add	 esp, 8
  00b99	50		 push	 eax
  00b9a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00ba0	50		 push	 eax
  00ba1	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00ba6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 772  : 				mapheaderinfo[num-1].palette = (UINT16)i;

  00ba9	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00bac	83 e8 01	 sub	 eax, 1
  00baf	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00bb5	66 8b 95 ec fb
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  00bbc	66 89 91 80 01
	00 00		 mov	 WORD PTR _mapheaderinfo[ecx+384], dx

; 773  : 			}

  00bc3	eb 18		 jmp	 SHORT $LN61@readlevelh
$LN60@readlevelh:

; 774  : 			else
; 775  : 				deh_warning("Level header %d: unknown word '%s'", num, word);

  00bc5	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00bcb	50		 push	 eax
  00bcc	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00bcf	51		 push	 ecx
  00bd0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DEOJKBPN@Level?5header?5?$CFd?3?5unknown?5word?5?8@
  00bd5	e8 00 00 00 00	 call	 _deh_warning
  00bda	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN61@readlevelh:

; 776  : 		}
; 777  : 	} while (!myfeof(f)); // finish when the line is empty

  00bdd	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00be0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00be2	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00be5	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00be8	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00beb	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00bee	0f 87 2e f4 ff
	ff		 ja	 $LN4@readlevelh
$LN3@readlevelh:

; 778  : }

  00bf4	5f		 pop	 edi
  00bf5	5e		 pop	 esi
  00bf6	5b		 pop	 ebx
  00bf7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bfa	33 cd		 xor	 ecx, ebp
  00bfc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c01	8b e5		 mov	 esp, ebp
  00c03	5d		 pop	 ebp
  00c04	c3		 ret	 0
_readlevelheader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readthing
_TEXT	SEGMENT
_value$ = -1040						; size = 4
_tmp$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readthing PROC						; COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 04 00
	00		 sub	 esp, 1232		; 000004d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
$LN4@readthing:

; 453  : 	XBOXSTATIC char s[MAXLINELEN];
; 454  : 	char *word;
; 455  : 	char *tmp;
; 456  : 	INT32 value;
; 457  : 
; 458  : 	do
; 459  : 	{
; 460  : 		if (myfgets(s, sizeof (s), f))

  00016	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00019	50		 push	 eax
  0001a	68 00 04 00 00	 push	 1024			; 00000400H
  0001f	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _myfgets
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 cb 08 00
	00		 je	 $LN57@readthing

; 461  : 		{
; 462  : 			if (s[0] == '\n')

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	6b c8 00	 imul	 ecx, eax, 0
  0003e	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  00046	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00049	75 05		 jne	 SHORT $LN6@readthing

; 463  : 				break;

  0004b	e9 c8 08 00 00	 jmp	 $LN3@readthing
$LN6@readthing:

; 464  : 
; 465  : 			tmp = strchr(s, '#');

  00050	6a 23		 push	 35			; 00000023H
  00052	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _strchr
  0005e	83 c4 08	 add	 esp, 8
  00061	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _tmp$[ebp], eax

; 466  : 			if (tmp)

  00067	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _tmp$[ebp], 0
  0006e	74 09		 je	 SHORT $LN7@readthing

; 467  : 				*tmp = '\0';

  00070	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _tmp$[ebp]
  00076	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN7@readthing:

; 468  : 
; 469  : 			value = searchvalue(s);

  00079	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _searchvalue
  00085	83 c4 04	 add	 esp, 4
  00088	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _value$[ebp], eax

; 470  : 
; 471  : 			word = strtok(s, " ");

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00093	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _strtok
  0009f	83 c4 08	 add	 esp, 8
  000a2	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 472  : 			if (word)

  000a8	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  000af	74 11		 je	 SHORT $LN8@readthing

; 473  : 				strupr(word);

  000b1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _strupr
  000bd	83 c4 04	 add	 esp, 4
  000c0	eb 05		 jmp	 SHORT $LN9@readthing
$LN8@readthing:

; 474  : 			else
; 475  : 				break;

  000c2	e9 51 08 00 00	 jmp	 $LN3@readthing
$LN9@readthing:

; 476  : 
; 477  : 			if (!strcmp(word, "MAPTHINGNUM"))

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LILCLDJ@MAPTHINGNUM@
  000cc	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _strcmp
  000d8	83 c4 08	 add	 esp, 8
  000db	85 c0		 test	 eax, eax
  000dd	75 3f		 jne	 SHORT $LN10@readthing

; 478  : 			{
; 479  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].doomednum), UNDO_NONE);

  000df	6a 00		 push	 0
  000e1	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  000e5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax]
  000eb	51		 push	 ecx
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000f1	e8 00 00 00 00	 call	 _va
  000f6	83 c4 08	 add	 esp, 8
  000f9	50		 push	 eax
  000fa	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH

; 480  : 				mobjinfo[num].doomednum = value;

  00109	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0010d	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00113	89 88 00 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax], ecx

; 481  : 			}

  00119	e9 e3 07 00 00	 jmp	 $LN57@readthing
$LN10@readthing:

; 482  : 			else if (!strcmp(word, "SPAWNSTATE"))

  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MMJEIBOH@SPAWNSTATE@
  00123	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _strcmp
  0012f	83 c4 08	 add	 esp, 8
  00132	85 c0		 test	 eax, eax
  00134	75 3f		 jne	 SHORT $LN12@readthing

; 483  : 			{
; 484  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].spawnstate), UNDO_NONE);

  00136	6a 00		 push	 0
  00138	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0013c	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+4]
  00142	51		 push	 ecx
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00148	e8 00 00 00 00	 call	 _va
  0014d	83 c4 08	 add	 esp, 8
  00150	50		 push	 eax
  00151	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 485  : 				mobjinfo[num].spawnstate = value;

  00160	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00164	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0016a	89 88 04 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+4], ecx

; 486  : 			}

  00170	e9 8c 07 00 00	 jmp	 $LN57@readthing
$LN12@readthing:

; 487  : 			else if (!strcmp(word, "SPAWNHEALTH"))

  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CDBIIJGK@SPAWNHEALTH@
  0017a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _strcmp
  00186	83 c4 08	 add	 esp, 8
  00189	85 c0		 test	 eax, eax
  0018b	75 3f		 jne	 SHORT $LN14@readthing

; 488  : 			{
; 489  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].spawnhealth), UNDO_NONE);

  0018d	6a 00		 push	 0
  0018f	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00193	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+8]
  00199	51		 push	 ecx
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0019f	e8 00 00 00 00	 call	 _va
  001a4	83 c4 08	 add	 esp, 8
  001a7	50		 push	 eax
  001a8	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 490  : 				mobjinfo[num].spawnhealth = value;

  001b7	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  001bb	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  001c1	89 88 08 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+8], ecx

; 491  : 			}

  001c7	e9 35 07 00 00	 jmp	 $LN57@readthing
$LN14@readthing:

; 492  : 			else if (!strcmp(word, "SEESTATE"))

  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_08KHPNBBJD@SEESTATE@
  001d1	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 _strcmp
  001dd	83 c4 08	 add	 esp, 8
  001e0	85 c0		 test	 eax, eax
  001e2	75 3f		 jne	 SHORT $LN16@readthing

; 493  : 			{
; 494  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].seestate), UNDO_NONE);

  001e4	6a 00		 push	 0
  001e6	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  001ea	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+12]
  001f0	51		 push	 ecx
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001f6	e8 00 00 00 00	 call	 _va
  001fb	83 c4 08	 add	 esp, 8
  001fe	50		 push	 eax
  001ff	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00205	52		 push	 edx
  00206	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 495  : 				mobjinfo[num].seestate = value;

  0020e	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00212	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00218	89 88 0c 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+12], ecx

; 496  : 			}

  0021e	e9 de 06 00 00	 jmp	 $LN57@readthing
$LN16@readthing:

; 497  : 			else if (!strcmp(word, "SEESOUND"))

  00223	68 00 00 00 00	 push	 OFFSET ??_C@_08GHBMGACP@SEESOUND@
  00228	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _strcmp
  00234	83 c4 08	 add	 esp, 8
  00237	85 c0		 test	 eax, eax
  00239	75 3f		 jne	 SHORT $LN18@readthing

; 498  : 			{
; 499  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].seesound), UNDO_NONE);

  0023b	6a 00		 push	 0
  0023d	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00241	8b 88 10 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+16]
  00247	51		 push	 ecx
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0024d	e8 00 00 00 00	 call	 _va
  00252	83 c4 08	 add	 esp, 8
  00255	50		 push	 eax
  00256	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0025c	52		 push	 edx
  0025d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 500  : 				mobjinfo[num].seesound = value;

  00265	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00269	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0026f	89 88 10 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+16], ecx

; 501  : 			}

  00275	e9 87 06 00 00	 jmp	 $LN57@readthing
$LN18@readthing:

; 502  : 			else if (!strcmp(word, "REACTIONTIME"))

  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BDGIPNHE@REACTIONTIME@
  0027f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 _strcmp
  0028b	83 c4 08	 add	 esp, 8
  0028e	85 c0		 test	 eax, eax
  00290	75 3f		 jne	 SHORT $LN20@readthing

; 503  : 			{
; 504  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].reactiontime), UNDO_NONE);

  00292	6a 00		 push	 0
  00294	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00298	8b 88 14 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+20]
  0029e	51		 push	 ecx
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  002a4	e8 00 00 00 00	 call	 _va
  002a9	83 c4 08	 add	 esp, 8
  002ac	50		 push	 eax
  002ad	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  002b3	52		 push	 edx
  002b4	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  002b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 505  : 				mobjinfo[num].reactiontime = value;

  002bc	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  002c0	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  002c6	89 88 14 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+20], ecx

; 506  : 			}

  002cc	e9 30 06 00 00	 jmp	 $LN57@readthing
$LN20@readthing:

; 507  : 			else if (!strcmp(word, "ATTACKSOUND"))

  002d1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DNPINJMI@ATTACKSOUND@
  002d6	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  002dc	50		 push	 eax
  002dd	e8 00 00 00 00	 call	 _strcmp
  002e2	83 c4 08	 add	 esp, 8
  002e5	85 c0		 test	 eax, eax
  002e7	75 3f		 jne	 SHORT $LN22@readthing

; 508  : 			{
; 509  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].attacksound), UNDO_NONE);

  002e9	6a 00		 push	 0
  002eb	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  002ef	8b 88 18 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+24]
  002f5	51		 push	 ecx
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  002fb	e8 00 00 00 00	 call	 _va
  00300	83 c4 08	 add	 esp, 8
  00303	50		 push	 eax
  00304	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0030a	52		 push	 edx
  0030b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00310	83 c4 0c	 add	 esp, 12			; 0000000cH

; 510  : 				mobjinfo[num].attacksound = value;

  00313	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00317	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0031d	89 88 18 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+24], ecx

; 511  : 			}

  00323	e9 d9 05 00 00	 jmp	 $LN57@readthing
$LN22@readthing:

; 512  : 			else if (!strcmp(word, "PAINSTATE"))

  00328	68 00 00 00 00	 push	 OFFSET ??_C@_09MMPEMAEB@PAINSTATE@
  0032d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 _strcmp
  00339	83 c4 08	 add	 esp, 8
  0033c	85 c0		 test	 eax, eax
  0033e	75 3f		 jne	 SHORT $LN24@readthing

; 513  : 			{
; 514  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].painstate), UNDO_NONE);

  00340	6a 00		 push	 0
  00342	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00346	8b 88 1c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+28]
  0034c	51		 push	 ecx
  0034d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00352	e8 00 00 00 00	 call	 _va
  00357	83 c4 08	 add	 esp, 8
  0035a	50		 push	 eax
  0035b	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00361	52		 push	 edx
  00362	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00367	83 c4 0c	 add	 esp, 12			; 0000000cH

; 515  : 				mobjinfo[num].painstate = value;

  0036a	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0036e	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00374	89 88 1c 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+28], ecx

; 516  : 			}

  0037a	e9 82 05 00 00	 jmp	 $LN57@readthing
$LN24@readthing:

; 517  : 			else if (!strcmp(word, "PAINCHANCE"))

  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KEPKKLOB@PAINCHANCE@
  00384	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0038a	50		 push	 eax
  0038b	e8 00 00 00 00	 call	 _strcmp
  00390	83 c4 08	 add	 esp, 8
  00393	85 c0		 test	 eax, eax
  00395	75 3f		 jne	 SHORT $LN26@readthing

; 518  : 			{
; 519  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].painchance), UNDO_NONE);

  00397	6a 00		 push	 0
  00399	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0039d	8b 88 20 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+32]
  003a3	51		 push	 ecx
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  003a9	e8 00 00 00 00	 call	 _va
  003ae	83 c4 08	 add	 esp, 8
  003b1	50		 push	 eax
  003b2	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  003b8	52		 push	 edx
  003b9	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  003be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 520  : 				mobjinfo[num].painchance = value;

  003c1	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  003c5	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  003cb	89 88 20 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+32], ecx

; 521  : 			}

  003d1	e9 2b 05 00 00	 jmp	 $LN57@readthing
$LN26@readthing:

; 522  : 			else if (!strcmp(word, "PAINSOUND"))

  003d6	68 00 00 00 00	 push	 OFFSET ??_C@_09MBFLBPN@PAINSOUND@
  003db	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003e1	50		 push	 eax
  003e2	e8 00 00 00 00	 call	 _strcmp
  003e7	83 c4 08	 add	 esp, 8
  003ea	85 c0		 test	 eax, eax
  003ec	75 3f		 jne	 SHORT $LN28@readthing

; 523  : 			{
; 524  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].painsound), UNDO_NONE);

  003ee	6a 00		 push	 0
  003f0	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  003f4	8b 88 24 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+36]
  003fa	51		 push	 ecx
  003fb	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00400	e8 00 00 00 00	 call	 _va
  00405	83 c4 08	 add	 esp, 8
  00408	50		 push	 eax
  00409	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0040f	52		 push	 edx
  00410	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00415	83 c4 0c	 add	 esp, 12			; 0000000cH

; 525  : 				mobjinfo[num].painsound = value;

  00418	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0041c	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00422	89 88 24 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+36], ecx

; 526  : 			}

  00428	e9 d4 04 00 00	 jmp	 $LN57@readthing
$LN28@readthing:

; 527  : 			else if (!strcmp(word, "MELEESTATE"))

  0042d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DMEFKBHN@MELEESTATE@
  00432	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 _strcmp
  0043e	83 c4 08	 add	 esp, 8
  00441	85 c0		 test	 eax, eax
  00443	75 3f		 jne	 SHORT $LN30@readthing

; 528  : 			{
; 529  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].meleestate), UNDO_NONE);

  00445	6a 00		 push	 0
  00447	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0044b	8b 88 28 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+40]
  00451	51		 push	 ecx
  00452	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00457	e8 00 00 00 00	 call	 _va
  0045c	83 c4 08	 add	 esp, 8
  0045f	50		 push	 eax
  00460	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00466	52		 push	 edx
  00467	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0046c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 				mobjinfo[num].meleestate = value;

  0046f	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00473	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00479	89 88 28 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+40], ecx

; 531  : 			}

  0047f	e9 7d 04 00 00	 jmp	 $LN57@readthing
$LN30@readthing:

; 532  : 			else if (!strcmp(word, "MISSILESTATE"))

  00484	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IMDFGKKB@MISSILESTATE@
  00489	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0048f	50		 push	 eax
  00490	e8 00 00 00 00	 call	 _strcmp
  00495	83 c4 08	 add	 esp, 8
  00498	85 c0		 test	 eax, eax
  0049a	75 3f		 jne	 SHORT $LN32@readthing

; 533  : 			{
; 534  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].missilestate), UNDO_NONE);

  0049c	6a 00		 push	 0
  0049e	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  004a2	8b 88 2c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+44]
  004a8	51		 push	 ecx
  004a9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004ae	e8 00 00 00 00	 call	 _va
  004b3	83 c4 08	 add	 esp, 8
  004b6	50		 push	 eax
  004b7	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  004bd	52		 push	 edx
  004be	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  004c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 535  : 				mobjinfo[num].missilestate = value;

  004c6	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  004ca	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  004d0	89 88 2c 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+44], ecx

; 536  : 			}

  004d6	e9 26 04 00 00	 jmp	 $LN57@readthing
$LN32@readthing:

; 537  : 			else if (!strcmp(word, "DEATHSTATE"))

  004db	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GHIBCINK@DEATHSTATE@
  004e0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  004e6	50		 push	 eax
  004e7	e8 00 00 00 00	 call	 _strcmp
  004ec	83 c4 08	 add	 esp, 8
  004ef	85 c0		 test	 eax, eax
  004f1	75 3f		 jne	 SHORT $LN34@readthing

; 538  : 			{
; 539  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].deathstate), UNDO_NONE);

  004f3	6a 00		 push	 0
  004f5	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  004f9	8b 88 30 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+48]
  004ff	51		 push	 ecx
  00500	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00505	e8 00 00 00 00	 call	 _va
  0050a	83 c4 08	 add	 esp, 8
  0050d	50		 push	 eax
  0050e	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00514	52		 push	 edx
  00515	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0051a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 540  : 				mobjinfo[num].deathstate = value;

  0051d	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00521	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00527	89 88 30 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+48], ecx

; 541  : 			}

  0052d	e9 cf 03 00 00	 jmp	 $LN57@readthing
$LN34@readthing:

; 542  : 			else if (!strcmp(word, "DEATHSOUND"))

  00532	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KHGAFJGG@DEATHSOUND@
  00537	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0053d	50		 push	 eax
  0053e	e8 00 00 00 00	 call	 _strcmp
  00543	83 c4 08	 add	 esp, 8
  00546	85 c0		 test	 eax, eax
  00548	75 3f		 jne	 SHORT $LN36@readthing

; 543  : 			{
; 544  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].deathsound), UNDO_NONE);

  0054a	6a 00		 push	 0
  0054c	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00550	8b 88 38 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+56]
  00556	51		 push	 ecx
  00557	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0055c	e8 00 00 00 00	 call	 _va
  00561	83 c4 08	 add	 esp, 8
  00564	50		 push	 eax
  00565	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0056b	52		 push	 edx
  0056c	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00571	83 c4 0c	 add	 esp, 12			; 0000000cH

; 545  : 				mobjinfo[num].deathsound = value;

  00574	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00578	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0057e	89 88 38 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+56], ecx

; 546  : 			}

  00584	e9 78 03 00 00	 jmp	 $LN57@readthing
$LN36@readthing:

; 547  : 			else if (!strcmp(word, "XDEATHSTATE"))

  00589	68 00 00 00 00	 push	 OFFSET ??_C@_0M@ENKEHDKL@XDEATHSTATE@
  0058e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00594	50		 push	 eax
  00595	e8 00 00 00 00	 call	 _strcmp
  0059a	83 c4 08	 add	 esp, 8
  0059d	85 c0		 test	 eax, eax
  0059f	75 3f		 jne	 SHORT $LN38@readthing

; 548  : 			{
; 549  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].xdeathstate), UNDO_NONE);

  005a1	6a 00		 push	 0
  005a3	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  005a7	8b 88 34 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+52]
  005ad	51		 push	 ecx
  005ae	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  005b3	e8 00 00 00 00	 call	 _va
  005b8	83 c4 08	 add	 esp, 8
  005bb	50		 push	 eax
  005bc	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  005c2	52		 push	 edx
  005c3	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 550  : 				mobjinfo[num].xdeathstate = value;

  005cb	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  005cf	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  005d5	89 88 34 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+52], ecx

; 551  : 			}

  005db	e9 21 03 00 00	 jmp	 $LN57@readthing
$LN38@readthing:

; 552  : 			else if (!strcmp(word, "SPEED"))

  005e0	68 00 00 00 00	 push	 OFFSET ??_C@_05LCLKIGOL@SPEED@
  005e5	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  005eb	50		 push	 eax
  005ec	e8 00 00 00 00	 call	 _strcmp
  005f1	83 c4 08	 add	 esp, 8
  005f4	85 c0		 test	 eax, eax
  005f6	75 3f		 jne	 SHORT $LN40@readthing

; 553  : 			{
; 554  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].speed), UNDO_NONE);

  005f8	6a 00		 push	 0
  005fa	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  005fe	8b 88 3c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+60]
  00604	51		 push	 ecx
  00605	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0060a	e8 00 00 00 00	 call	 _va
  0060f	83 c4 08	 add	 esp, 8
  00612	50		 push	 eax
  00613	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00619	52		 push	 edx
  0061a	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0061f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 				mobjinfo[num].speed = value;

  00622	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00626	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0062c	89 88 3c 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+60], ecx

; 556  : 			}

  00632	e9 ca 02 00 00	 jmp	 $LN57@readthing
$LN40@readthing:

; 557  : 			else if (!strcmp(word, "RADIUS"))

  00637	68 00 00 00 00	 push	 OFFSET ??_C@_06KCFDAKCE@RADIUS@
  0063c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00642	50		 push	 eax
  00643	e8 00 00 00 00	 call	 _strcmp
  00648	83 c4 08	 add	 esp, 8
  0064b	85 c0		 test	 eax, eax
  0064d	75 3f		 jne	 SHORT $LN42@readthing

; 558  : 			{
; 559  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].radius), UNDO_NONE);

  0064f	6a 00		 push	 0
  00651	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00655	8b 88 40 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+64]
  0065b	51		 push	 ecx
  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00661	e8 00 00 00 00	 call	 _va
  00666	83 c4 08	 add	 esp, 8
  00669	50		 push	 eax
  0066a	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00670	52		 push	 edx
  00671	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00676	83 c4 0c	 add	 esp, 12			; 0000000cH

; 560  : 				mobjinfo[num].radius = value;

  00679	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0067d	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00683	89 88 40 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+64], ecx

; 561  : 			}

  00689	e9 73 02 00 00	 jmp	 $LN57@readthing
$LN42@readthing:

; 562  : 			else if (!strcmp(word, "HEIGHT"))

  0068e	68 00 00 00 00	 push	 OFFSET ??_C@_06LJJMJONE@HEIGHT@
  00693	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00699	50		 push	 eax
  0069a	e8 00 00 00 00	 call	 _strcmp
  0069f	83 c4 08	 add	 esp, 8
  006a2	85 c0		 test	 eax, eax
  006a4	75 3f		 jne	 SHORT $LN44@readthing

; 563  : 			{
; 564  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].height), UNDO_NONE);

  006a6	6a 00		 push	 0
  006a8	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  006ac	8b 88 44 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+68]
  006b2	51		 push	 ecx
  006b3	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  006b8	e8 00 00 00 00	 call	 _va
  006bd	83 c4 08	 add	 esp, 8
  006c0	50		 push	 eax
  006c1	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  006c7	52		 push	 edx
  006c8	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  006cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 565  : 				mobjinfo[num].height = value;

  006d0	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  006d4	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  006da	89 88 44 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+68], ecx

; 566  : 			}

  006e0	e9 1c 02 00 00	 jmp	 $LN57@readthing
$LN44@readthing:

; 567  : 			else if (!strcmp(word, "DISPOFFSET"))

  006e5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EDHALAFO@DISPOFFSET@
  006ea	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  006f0	50		 push	 eax
  006f1	e8 00 00 00 00	 call	 _strcmp
  006f6	83 c4 08	 add	 esp, 8
  006f9	85 c0		 test	 eax, eax
  006fb	75 3f		 jne	 SHORT $LN46@readthing

; 568  : 			{
; 569  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].dispoffset), UNDO_NONE);

  006fd	6a 00		 push	 0
  006ff	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00703	8b 88 48 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+72]
  00709	51		 push	 ecx
  0070a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0070f	e8 00 00 00 00	 call	 _va
  00714	83 c4 08	 add	 esp, 8
  00717	50		 push	 eax
  00718	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0071e	52		 push	 edx
  0071f	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00724	83 c4 0c	 add	 esp, 12			; 0000000cH

; 570  : 				mobjinfo[num].dispoffset = value;

  00727	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0072b	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00731	89 88 48 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+72], ecx

; 571  : 			}

  00737	e9 c5 01 00 00	 jmp	 $LN57@readthing
$LN46@readthing:

; 572  : 			else if (!strcmp(word, "MASS"))

  0073c	68 00 00 00 00	 push	 OFFSET ??_C@_04EFHKDFDM@MASS@
  00741	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00747	50		 push	 eax
  00748	e8 00 00 00 00	 call	 _strcmp
  0074d	83 c4 08	 add	 esp, 8
  00750	85 c0		 test	 eax, eax
  00752	75 3f		 jne	 SHORT $LN48@readthing

; 573  : 			{
; 574  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].mass), UNDO_NONE);

  00754	6a 00		 push	 0
  00756	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0075a	8b 88 4c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+76]
  00760	51		 push	 ecx
  00761	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00766	e8 00 00 00 00	 call	 _va
  0076b	83 c4 08	 add	 esp, 8
  0076e	50		 push	 eax
  0076f	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00775	52		 push	 edx
  00776	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  0077b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 575  : 				mobjinfo[num].mass = value;

  0077e	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00782	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00788	89 88 4c 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+76], ecx

; 576  : 			}

  0078e	e9 6e 01 00 00	 jmp	 $LN57@readthing
$LN48@readthing:

; 577  : 			else if (!strcmp(word, "DAMAGE"))

  00793	68 00 00 00 00	 push	 OFFSET ??_C@_06GNMDCLIH@DAMAGE@
  00798	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0079e	50		 push	 eax
  0079f	e8 00 00 00 00	 call	 _strcmp
  007a4	83 c4 08	 add	 esp, 8
  007a7	85 c0		 test	 eax, eax
  007a9	75 3f		 jne	 SHORT $LN50@readthing

; 578  : 			{
; 579  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].damage), UNDO_NONE);

  007ab	6a 00		 push	 0
  007ad	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  007b1	8b 88 50 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+80]
  007b7	51		 push	 ecx
  007b8	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  007bd	e8 00 00 00 00	 call	 _va
  007c2	83 c4 08	 add	 esp, 8
  007c5	50		 push	 eax
  007c6	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  007cc	52		 push	 edx
  007cd	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  007d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 580  : 				mobjinfo[num].damage = value;

  007d5	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  007d9	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  007df	89 88 50 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+80], ecx

; 581  : 			}

  007e5	e9 17 01 00 00	 jmp	 $LN57@readthing
$LN50@readthing:

; 582  : 			else if (!strcmp(word, "ACTIVESOUND"))

  007ea	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GFIJOOIK@ACTIVESOUND@
  007ef	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  007f5	50		 push	 eax
  007f6	e8 00 00 00 00	 call	 _strcmp
  007fb	83 c4 08	 add	 esp, 8
  007fe	85 c0		 test	 eax, eax
  00800	75 3f		 jne	 SHORT $LN52@readthing

; 583  : 			{
; 584  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].activesound), UNDO_NONE);

  00802	6a 00		 push	 0
  00804	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00808	8b 88 54 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+84]
  0080e	51		 push	 ecx
  0080f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00814	e8 00 00 00 00	 call	 _va
  00819	83 c4 08	 add	 esp, 8
  0081c	50		 push	 eax
  0081d	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  00823	52		 push	 edx
  00824	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00829	83 c4 0c	 add	 esp, 12			; 0000000cH

; 585  : 				mobjinfo[num].activesound = value;

  0082c	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00830	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  00836	89 88 54 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+84], ecx

; 586  : 			}

  0083c	e9 c0 00 00 00	 jmp	 $LN57@readthing
$LN52@readthing:

; 587  : 			else if (!strcmp(word, "FLAGS"))

  00841	68 00 00 00 00	 push	 OFFSET ??_C@_05MNNEKIOP@FLAGS@
  00846	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0084c	50		 push	 eax
  0084d	e8 00 00 00 00	 call	 _strcmp
  00852	83 c4 08	 add	 esp, 8
  00855	85 c0		 test	 eax, eax
  00857	75 3c		 jne	 SHORT $LN54@readthing

; 588  : 			{
; 589  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].flags), UNDO_NONE);

  00859	6a 00		 push	 0
  0085b	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  0085f	8b 88 58 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+88]
  00865	51		 push	 ecx
  00866	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0086b	e8 00 00 00 00	 call	 _va
  00870	83 c4 08	 add	 esp, 8
  00873	50		 push	 eax
  00874	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  0087a	52		 push	 edx
  0087b	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00880	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  : 				mobjinfo[num].flags = value;

  00883	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  00887	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  0088d	89 88 58 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+88], ecx

; 591  : 			}

  00893	eb 6c		 jmp	 SHORT $LN57@readthing
$LN54@readthing:

; 592  : 			else if (!strcmp(word, "RAISESTATE"))

  00895	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PIODEMOJ@RAISESTATE@
  0089a	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  008a0	50		 push	 eax
  008a1	e8 00 00 00 00	 call	 _strcmp
  008a6	83 c4 08	 add	 esp, 8
  008a9	85 c0		 test	 eax, eax
  008ab	75 3c		 jne	 SHORT $LN56@readthing

; 593  : 			{
; 594  : 				DEH_WriteUndoline(word, va("%d", mobjinfo[num].raisestate), UNDO_NONE);

  008ad	6a 00		 push	 0
  008af	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  008b3	8b 88 5c 00 00
	00		 mov	 ecx, DWORD PTR _mobjinfo[eax+92]
  008b9	51		 push	 ecx
  008ba	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  008bf	e8 00 00 00 00	 call	 _va
  008c4	83 c4 08	 add	 esp, 8
  008c7	50		 push	 eax
  008c8	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  008ce	52		 push	 edx
  008cf	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  008d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 595  : 				mobjinfo[num].raisestate = value;

  008d7	6b 45 0c 60	 imul	 eax, DWORD PTR _num$[ebp], 96
  008db	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _value$[ebp]
  008e1	89 88 5c 00 00
	00		 mov	 DWORD PTR _mobjinfo[eax+92], ecx

; 596  : 			}

  008e7	eb 18		 jmp	 SHORT $LN57@readthing
$LN56@readthing:

; 597  : 			else
; 598  : 				deh_warning("Thing %d: unknown word '%s'", num, word);

  008e9	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  008ef	50		 push	 eax
  008f0	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  008f3	51		 push	 ecx
  008f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@FEGHJPGL@Thing?5?$CFd?3?5unknown?5word?5?8?$CFs?8@
  008f9	e8 00 00 00 00	 call	 _deh_warning
  008fe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@readthing:

; 599  : 		}
; 600  : 	} while (!myfeof(f)); // finish when the line is empty

  00901	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00904	8b 08		 mov	 ecx, DWORD PTR [eax]
  00906	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  00909	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  0090c	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0090f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00912	0f 87 fe f6 ff
	ff		 ja	 $LN4@readthing
$LN3@readthing:

; 601  : }

  00918	5f		 pop	 edi
  00919	5e		 pop	 esi
  0091a	5b		 pop	 ebx
  0091b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091e	33 cd		 xor	 ecx, ebp
  00920	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00925	8b e5		 mov	 esp, ebp
  00927	5d		 pop	 ebp
  00928	c3		 ret	 0
_readthing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _readPlayer
_TEXT	SEGMENT
_numlines$1 = -1052					; size = 4
_playertext$2 = -1048					; size = 4
_slotfound$ = -1044					; size = 4
_i$ = -1040						; size = 4
_word2$ = -1036						; size = 4
_word$ = -1032						; size = 4
_s$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_f$ = 8							; size = 4
_num$ = 12						; size = 4
_readPlayer PROC					; COMDAT

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 04 00
	00		 sub	 esp, 1244		; 000004dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 320  : 	XBOXSTATIC char s[MAXLINELEN];
; 321  : 	char *word;
; 322  : 	char *word2;
; 323  : 	INT32 i;
; 324  : 	boolean slotfound = false;

  00016	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _slotfound$[ebp], 0

; 325  : 
; 326  : 	DEH_WriteUndoline("PLAYERTEXT", description[num].info, UNDO_ENDTEXT);

  00020	6a 08		 push	 8
  00022	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00029	05 00 00 00 00	 add	 eax, OFFSET _description
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GBJEFOMO@PLAYERTEXT@
  00034	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@readPlayer:

; 327  : 
; 328  : 	do
; 329  : 	{
; 330  : 		if (myfgets(s, sizeof (s), f))

  0003c	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  0003f	50		 push	 eax
  00040	68 00 04 00 00	 push	 1024			; 00000400H
  00045	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _myfgets
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	85 c0		 test	 eax, eax
  00056	0f 84 53 05 00
	00		 je	 $LN40@readPlayer

; 331  : 		{
; 332  : 			if (s[0] == '\n')

  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	6b c8 00	 imul	 ecx, eax, 0
  00064	0f be 94 0d fc
	fb ff ff	 movsx	 edx, BYTE PTR _s$[ebp+ecx]
  0006c	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0006f	75 05		 jne	 SHORT $LN12@readPlayer

; 333  : 				break;

  00071	e9 50 05 00 00	 jmp	 $LN3@readPlayer
$LN12@readPlayer:

; 334  : 
; 335  : 			word = strtok(s, " ");

  00076	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0007b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _strtok
  00087	83 c4 08	 add	 esp, 8
  0008a	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _word$[ebp], eax

; 336  : 			if (word)

  00090	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _word$[ebp], 0
  00097	74 11		 je	 SHORT $LN13@readPlayer

; 337  : 				strupr(word);

  00099	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _strupr
  000a5	83 c4 04	 add	 esp, 4
  000a8	eb 05		 jmp	 SHORT $LN14@readPlayer
$LN13@readPlayer:

; 338  : 			else
; 339  : 				break;

  000aa	e9 17 05 00 00	 jmp	 $LN3@readPlayer
$LN14@readPlayer:

; 340  : 
; 341  : 			if (!strcmp(word, "PLAYERTEXT"))

  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GBJEFOMO@PLAYERTEXT@
  000b4	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _strcmp
  000c0	83 c4 08	 add	 esp, 8
  000c3	85 c0		 test	 eax, eax
  000c5	0f 85 d9 01 00
	00		 jne	 $LN15@readPlayer

; 342  : 			{
; 343  : 				char *playertext = NULL;

  000cb	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _playertext$2[ebp], 0

; 344  : 
; 345  : 				if (!slotfound && (slotfound = findFreeSlot(&num)) == false)

  000d5	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  000dc	75 20		 jne	 SHORT $LN16@readPlayer
  000de	8d 45 0c	 lea	 eax, DWORD PTR _num$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _findFreeSlot
  000e7	83 c4 04	 add	 esp, 4
  000ea	89 85 ec fb ff
	ff		 mov	 DWORD PTR _slotfound$[ebp], eax
  000f0	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  000f7	75 05		 jne	 SHORT $LN16@readPlayer

; 346  : 					return;

  000f9	e9 f2 04 00 00	 jmp	 $LN42@readPlayer
$LN16@readPlayer:

; 347  : 
; 348  : 				for (i = 0; i < MAXLINELEN-3; i++)

  000fe	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00108	eb 0f		 jmp	 SHORT $LN7@readPlayer
$LN5@readPlayer:
  0010a	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN7@readPlayer:
  00119	81 bd f0 fb ff
	ff fd 03 00 00	 cmp	 DWORD PTR _i$[ebp], 1021 ; 000003fdH
  00123	7d 2a		 jge	 SHORT $LN6@readPlayer

; 349  : 				{
; 350  : 					if (s[i] == '=')

  00125	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0012b	0f be 8c 05 fc
	fb ff ff	 movsx	 ecx, BYTE PTR _s$[ebp+eax]
  00133	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  00136	75 15		 jne	 SHORT $LN17@readPlayer

; 351  : 					{
; 352  : 						playertext = &s[i+2];

  00138	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0013e	8d 8c 05 fe fb
	ff ff		 lea	 ecx, DWORD PTR _s$[ebp+eax+2]
  00145	89 8d e8 fb ff
	ff		 mov	 DWORD PTR _playertext$2[ebp], ecx

; 353  : 						break;

  0014b	eb 02		 jmp	 SHORT $LN6@readPlayer
$LN17@readPlayer:

; 354  : 					}
; 355  : 				}

  0014d	eb bb		 jmp	 SHORT $LN5@readPlayer
$LN6@readPlayer:

; 356  : 				if (playertext)

  0014f	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _playertext$2[ebp], 0
  00156	74 4e		 je	 SHORT $LN18@readPlayer

; 357  : 				{
; 358  : 					strcpy(description[num].info, playertext);

  00158	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _playertext$2[ebp]
  0015e	50		 push	 eax
  0015f	69 4d 0c 58 01
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 344
  00166	81 c1 00 00 00
	00		 add	 ecx, OFFSET _description
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _strcpy
  00172	83 c4 08	 add	 esp, 8

; 359  : 					strcat(description[num].info, myhashfgets(playertext, sizeof (description[num].info), f));

  00175	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  00178	50		 push	 eax
  00179	68 ff 00 00 00	 push	 255			; 000000ffH
  0017e	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _playertext$2[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _myhashfgets
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018d	50		 push	 eax
  0018e	69 55 0c 58 01
	00 00		 imul	 edx, DWORD PTR _num$[ebp], 344
  00195	81 c2 00 00 00
	00		 add	 edx, OFFSET _description
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 _strcat
  001a1	83 c4 08	 add	 esp, 8

; 360  : 				}

  001a4	eb 1a		 jmp	 SHORT $LN19@readPlayer
$LN18@readPlayer:

; 361  : 				else
; 362  : 					strcpy(description[num].info, "");

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  001ab	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  001b2	05 00 00 00 00	 add	 eax, OFFSET _description
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 _strcpy
  001bd	83 c4 08	 add	 esp, 8
$LN19@readPlayer:

; 363  : 
; 364  : 				// For some reason, cutting the string did not work above. Most likely due to strcpy or strcat...
; 365  : 				// It works down here, though.
; 366  : 				{
; 367  : 					INT32 numlines = 0;

  001c0	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _numlines$1[ebp], 0

; 368  : 					for (i = 0; i < MAXLINELEN-1; i++)

  001ca	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  001d4	eb 0f		 jmp	 SHORT $LN10@readPlayer
$LN8@readPlayer:
  001d6	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001dc	83 c0 01	 add	 eax, 1
  001df	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN10@readPlayer:
  001e5	81 bd f0 fb ff
	ff ff 03 00 00	 cmp	 DWORD PTR _i$[ebp], 1023 ; 000003ffH
  001ef	7d 75		 jge	 SHORT $LN9@readPlayer

; 369  : 					{
; 370  : 						if (numlines < 7 && description[num].info[i] == '\n')

  001f1	83 bd e4 fb ff
	ff 07		 cmp	 DWORD PTR _numlines$1[ebp], 7
  001f8	7d 29		 jge	 SHORT $LN20@readPlayer
  001fa	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00201	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00207	0f be 94 08 00
	00 00 00	 movsx	 edx, BYTE PTR _description[eax+ecx]
  0020f	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00212	75 0f		 jne	 SHORT $LN20@readPlayer

; 371  : 							numlines++;

  00214	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR _numlines$1[ebp]
  0021a	83 c0 01	 add	 eax, 1
  0021d	89 85 e4 fb ff
	ff		 mov	 DWORD PTR _numlines$1[ebp], eax
$LN20@readPlayer:

; 372  : 
; 373  : 						if (numlines >= 7 || description[num].info[i] == '\0' || description[num].info[i] == '#')

  00223	83 bd e4 fb ff
	ff 07		 cmp	 DWORD PTR _numlines$1[ebp], 7
  0022a	7d 33		 jge	 SHORT $LN22@readPlayer
  0022c	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00233	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00239	0f be 94 08 00
	00 00 00	 movsx	 edx, BYTE PTR _description[eax+ecx]
  00241	85 d2		 test	 edx, edx
  00243	74 1a		 je	 SHORT $LN22@readPlayer
  00245	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  0024c	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00252	0f be 94 08 00
	00 00 00	 movsx	 edx, BYTE PTR _description[eax+ecx]
  0025a	83 fa 23	 cmp	 edx, 35			; 00000023H
  0025d	75 02		 jne	 SHORT $LN21@readPlayer
$LN22@readPlayer:

; 374  : 							break;

  0025f	eb 05		 jmp	 SHORT $LN9@readPlayer
$LN21@readPlayer:

; 375  : 					}

  00261	e9 70 ff ff ff	 jmp	 $LN8@readPlayer
$LN9@readPlayer:

; 376  : 				}
; 377  : 				description[num].info[strlen(description[num].info)-1] = '\0';

  00266	69 75 0c 58 01
	00 00		 imul	 esi, DWORD PTR _num$[ebp], 344
  0026d	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00274	05 00 00 00 00	 add	 eax, OFFSET _description
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _strlen
  0027f	83 c4 04	 add	 esp, 4
  00282	c6 84 06 ff ff
	ff ff 00	 mov	 BYTE PTR _description[esi+eax-1], 0

; 378  : 				description[num].info[i] = '\0';

  0028a	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00291	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00297	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR _description[eax+ecx], 0

; 379  : 				continue;

  0029f	e9 0b 03 00 00	 jmp	 $LN40@readPlayer
$LN15@readPlayer:

; 380  : 			}
; 381  : 
; 382  : 			word2 = strtok(NULL, " = ");

  002a4	68 00 00 00 00	 push	 OFFSET ??_C@_03MHLONNLM@?5?$DN?5@
  002a9	6a 00		 push	 0
  002ab	e8 00 00 00 00	 call	 _strtok
  002b0	83 c4 08	 add	 esp, 8
  002b3	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _word2$[ebp], eax

; 383  : 			if (word2)

  002b9	83 bd f4 fb ff
	ff 00		 cmp	 DWORD PTR _word2$[ebp], 0
  002c0	74 11		 je	 SHORT $LN23@readPlayer

; 384  : 				strupr(word2);

  002c2	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  002c8	50		 push	 eax
  002c9	e8 00 00 00 00	 call	 _strupr
  002ce	83 c4 04	 add	 esp, 4
  002d1	eb 05		 jmp	 SHORT $LN24@readPlayer
$LN23@readPlayer:

; 385  : 			else
; 386  : 				break;

  002d3	e9 ee 02 00 00	 jmp	 $LN3@readPlayer
$LN24@readPlayer:

; 387  : 
; 388  : 			word2[strlen(word2)-1] = '\0';

  002d8	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 _strlen
  002e4	83 c4 04	 add	 esp, 4
  002e7	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _word2$[ebp]
  002ed	c6 44 01 ff 00	 mov	 BYTE PTR [ecx+eax-1], 0

; 389  : 			i = atoi(word2);

  002f2	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 _atoi
  002fe	83 c4 04	 add	 esp, 4
  00301	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 390  : 
; 391  : 			if (!strcmp(word, "PLAYERNAME"))

  00307	68 00 00 00 00	 push	 OFFSET ??_C@_0L@INJCAEDB@PLAYERNAME@
  0030c	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00312	50		 push	 eax
  00313	e8 00 00 00 00	 call	 _strcmp
  00318	83 c4 08	 add	 esp, 8
  0031b	85 c0		 test	 eax, eax
  0031d	0f 85 81 00 00
	00		 jne	 $LN25@readPlayer

; 392  : 			{
; 393  : 				if (!slotfound && (slotfound = findFreeSlot(&num)) == false)

  00323	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  0032a	75 20		 jne	 SHORT $LN27@readPlayer
  0032c	8d 45 0c	 lea	 eax, DWORD PTR _num$[ebp]
  0032f	50		 push	 eax
  00330	e8 00 00 00 00	 call	 _findFreeSlot
  00335	83 c4 04	 add	 esp, 4
  00338	89 85 ec fb ff
	ff		 mov	 DWORD PTR _slotfound$[ebp], eax
  0033e	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  00345	75 05		 jne	 SHORT $LN27@readPlayer

; 394  : 					return;

  00347	e9 a4 02 00 00	 jmp	 $LN42@readPlayer
$LN27@readPlayer:

; 395  : 				DEH_WriteUndoline(word, description[num].text, UNDO_NONE);

  0034c	6a 00		 push	 0
  0034e	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00355	05 08 01 00 00	 add	 eax, OFFSET _description+264
  0035a	50		 push	 eax
  0035b	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  00361	51		 push	 ecx
  00362	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00367	83 c4 0c	 add	 esp, 12			; 0000000cH

; 396  : 				strlcpy(description[num].text, word2, sizeof (description[num].text));

  0036a	6a 40		 push	 64			; 00000040H
  0036c	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  00372	50		 push	 eax
  00373	69 4d 0c 58 01
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 344
  0037a	81 c1 08 01 00
	00		 add	 ecx, OFFSET _description+264
  00380	51		 push	 ecx
  00381	e8 00 00 00 00	 call	 _strlcpy
  00386	83 c4 0c	 add	 esp, 12			; 0000000cH

; 397  : 				PlayerMenu[num].text = description[num].text;

  00389	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00390	05 08 01 00 00	 add	 eax, OFFSET _description+264
  00395	6b 4d 0c 14	 imul	 ecx, DWORD PTR _num$[ebp], 20
  00399	89 81 08 00 00
	00		 mov	 DWORD PTR _PlayerMenu[ecx+8], eax

; 398  : 			}

  0039f	e9 0b 02 00 00	 jmp	 $LN40@readPlayer
$LN25@readPlayer:

; 399  : 			else if (!strcmp(word, "MENUPOSITION"))

  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PPNPBINO@MENUPOSITION@
  003a9	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 _strcmp
  003b5	83 c4 08	 add	 esp, 8
  003b8	85 c0		 test	 eax, eax
  003ba	75 21		 jne	 SHORT $LN28@readPlayer

; 400  : 			{
; 401  : 				if (disableundo) // NO SCREWING UP MY MENU, FOOL!

  003bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _disableundo, 0
  003c3	74 13		 je	 SHORT $LN30@readPlayer

; 402  : 				{
; 403  : 					slotfound = true;

  003c5	c7 85 ec fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _slotfound$[ebp], 1

; 404  : 					num = i;

  003cf	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  003d5	89 45 0c	 mov	 DWORD PTR _num$[ebp], eax
$LN30@readPlayer:

; 405  : 				}
; 406  : 			}

  003d8	e9 d2 01 00 00	 jmp	 $LN40@readPlayer
$LN28@readPlayer:

; 407  : 			else if (!strcmp(word, "PICNAME"))

  003dd	68 00 00 00 00	 push	 OFFSET ??_C@_07KGIDOHJL@PICNAME@
  003e2	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  003e8	50		 push	 eax
  003e9	e8 00 00 00 00	 call	 _strcmp
  003ee	83 c4 08	 add	 esp, 8
  003f1	85 c0		 test	 eax, eax
  003f3	75 75		 jne	 SHORT $LN31@readPlayer

; 408  : 			{
; 409  : 				if (!slotfound && (slotfound = findFreeSlot(&num)) == false)

  003f5	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  003fc	75 20		 jne	 SHORT $LN33@readPlayer
  003fe	8d 45 0c	 lea	 eax, DWORD PTR _num$[ebp]
  00401	50		 push	 eax
  00402	e8 00 00 00 00	 call	 _findFreeSlot
  00407	83 c4 04	 add	 esp, 4
  0040a	89 85 ec fb ff
	ff		 mov	 DWORD PTR _slotfound$[ebp], eax
  00410	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  00417	75 05		 jne	 SHORT $LN33@readPlayer

; 410  : 					return;

  00419	e9 d2 01 00 00	 jmp	 $LN42@readPlayer
$LN33@readPlayer:

; 411  : 				DEH_WriteUndoline(word, &description[num].picname[0], UNDO_NONE);

  0041e	6a 00		 push	 0
  00420	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00427	b9 01 00 00 00	 mov	 ecx, 1
  0042c	6b d1 00	 imul	 edx, ecx, 0
  0042f	8d 84 10 ff 00
	00 00		 lea	 eax, DWORD PTR _description[eax+edx+255]
  00436	50		 push	 eax
  00437	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0043d	51		 push	 ecx
  0043e	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00443	83 c4 0c	 add	 esp, 12			; 0000000cH

; 412  : 				strlcpy(description[num].picname, word2, 9);

  00446	6a 09		 push	 9
  00448	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0044e	50		 push	 eax
  0044f	69 4d 0c 58 01
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 344
  00456	81 c1 ff 00 00
	00		 add	 ecx, OFFSET _description+255
  0045c	51		 push	 ecx
  0045d	e8 00 00 00 00	 call	 _strlcpy
  00462	83 c4 0c	 add	 esp, 12			; 0000000cH

; 413  : 			}

  00465	e9 45 01 00 00	 jmp	 $LN40@readPlayer
$LN31@readPlayer:

; 414  : 			else if (!strcmp(word, "STATUS"))

  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_06DNKMJCIK@STATUS@
  0046f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00475	50		 push	 eax
  00476	e8 00 00 00 00	 call	 _strcmp
  0047b	83 c4 08	 add	 esp, 8
  0047e	85 c0		 test	 eax, eax
  00480	0f 85 93 00 00
	00		 jne	 $LN34@readPlayer

; 415  : 			{
; 416  : 				// Limit the status to only IT_DISABLED and IT_CALL|IT_STRING
; 417  : 				if (i != IT_STRING)

  00486	83 bd f0 fb ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0048d	74 0c		 je	 SHORT $LN36@readPlayer

; 418  : 					i = IT_DISABLED;

  0048f	c7 85 f0 fb ff
	ff 7a 00 00 00	 mov	 DWORD PTR _i$[ebp], 122	; 0000007aH
  00499	eb 0a		 jmp	 SHORT $LN37@readPlayer
$LN36@readPlayer:

; 419  : 				else
; 420  : 					i = IT_STRING;

  0049b	c7 85 f0 fb ff
	ff 20 00 00 00	 mov	 DWORD PTR _i$[ebp], 32	; 00000020H
$LN37@readPlayer:

; 421  : 
; 422  : 				/*
; 423  : 					You MAY disable previous entries if you so desire...
; 424  : 					But try to enable something that's already enabled and you will be sent to a free slot.
; 425  : 
; 426  : 					Because of this, you are allowed to edit any previous entrys you like, but only if you
; 427  : 					signal that you are purposely doing so by disabling and then reenabling the slot.
; 428  : 				*/
; 429  : 				if (i != IT_DISABLED && !slotfound && (slotfound = findFreeSlot(&num)) == false)

  004a5	83 bd f0 fb ff
	ff 7a		 cmp	 DWORD PTR _i$[ebp], 122	; 0000007aH
  004ac	74 29		 je	 SHORT $LN38@readPlayer
  004ae	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  004b5	75 20		 jne	 SHORT $LN38@readPlayer
  004b7	8d 45 0c	 lea	 eax, DWORD PTR _num$[ebp]
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 _findFreeSlot
  004c0	83 c4 04	 add	 esp, 4
  004c3	89 85 ec fb ff
	ff		 mov	 DWORD PTR _slotfound$[ebp], eax
  004c9	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  004d0	75 05		 jne	 SHORT $LN38@readPlayer

; 430  : 					return;

  004d2	e9 19 01 00 00	 jmp	 $LN42@readPlayer
$LN38@readPlayer:

; 431  : 				DEH_WriteUndoline(word, va("%d", PlayerMenu[num].status), UNDO_NONE);

  004d7	6a 00		 push	 0
  004d9	6b 45 0c 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  004dd	0f bf 88 00 00
	00 00		 movsx	 ecx, WORD PTR _PlayerMenu[eax]
  004e4	51		 push	 ecx
  004e5	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004ea	e8 00 00 00 00	 call	 _va
  004ef	83 c4 08	 add	 esp, 8
  004f2	50		 push	 eax
  004f3	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _word$[ebp]
  004f9	52		 push	 edx
  004fa	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  004ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 				PlayerMenu[num].status = (INT16)i;

  00502	6b 45 0c 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  00506	66 8b 8d f0 fb
	ff ff		 mov	 cx, WORD PTR _i$[ebp]
  0050d	66 89 88 00 00
	00 00		 mov	 WORD PTR _PlayerMenu[eax], cx

; 433  : 			}

  00514	e9 96 00 00 00	 jmp	 $LN40@readPlayer
$LN34@readPlayer:

; 434  : 			else if (!strcmp(word, "SKINNAME"))

  00519	68 00 00 00 00	 push	 OFFSET ??_C@_08PDDIGPEM@SKINNAME@
  0051e	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 _strcmp
  0052a	83 c4 08	 add	 esp, 8
  0052d	85 c0		 test	 eax, eax
  0052f	75 66		 jne	 SHORT $LN39@readPlayer

; 435  : 			{
; 436  : 				// Send to free slot.
; 437  : 				if (!slotfound && (slotfound = findFreeSlot(&num)) == false)

  00531	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  00538	75 20		 jne	 SHORT $LN41@readPlayer
  0053a	8d 45 0c	 lea	 eax, DWORD PTR _num$[ebp]
  0053d	50		 push	 eax
  0053e	e8 00 00 00 00	 call	 _findFreeSlot
  00543	83 c4 04	 add	 esp, 4
  00546	89 85 ec fb ff
	ff		 mov	 DWORD PTR _slotfound$[ebp], eax
  0054c	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  00553	75 05		 jne	 SHORT $LN41@readPlayer

; 438  : 					return;

  00555	e9 96 00 00 00	 jmp	 $LN42@readPlayer
$LN41@readPlayer:

; 439  : 				DEH_WriteUndoline(word, description[num].skinname, UNDO_NONE);

  0055a	6a 00		 push	 0
  0055c	69 45 0c 58 01
	00 00		 imul	 eax, DWORD PTR _num$[ebp], 344
  00563	05 48 01 00 00	 add	 eax, OFFSET _description+328
  00568	50		 push	 eax
  00569	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _word$[ebp]
  0056f	51		 push	 ecx
  00570	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00575	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  : 				strcpy(description[num].skinname, word2);

  00578	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _word2$[ebp]
  0057e	50		 push	 eax
  0057f	69 4d 0c 58 01
	00 00		 imul	 ecx, DWORD PTR _num$[ebp], 344
  00586	81 c1 48 01 00
	00		 add	 ecx, OFFSET _description+328
  0058c	51		 push	 ecx
  0058d	e8 00 00 00 00	 call	 _strcpy
  00592	83 c4 08	 add	 esp, 8

; 441  : 			}

  00595	eb 18		 jmp	 SHORT $LN40@readPlayer
$LN39@readPlayer:

; 442  : 			else
; 443  : 				deh_warning("readPlayer %d: unknown word '%s'", num, word);

  00597	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _word$[ebp]
  0059d	50		 push	 eax
  0059e	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  005a1	51		 push	 ecx
  005a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DKMGFKIF@readPlayer?5?$CFd?3?5unknown?5word?5?8?$CFs@
  005a7	e8 00 00 00 00	 call	 _deh_warning
  005ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN40@readPlayer:

; 444  : 		}
; 445  : 	} while (!myfeof(f)); // finish when the line is empty

  005af	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  005b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  005b4	8b 55 08	 mov	 edx, DWORD PTR _f$[ebp]
  005b7	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  005ba	8b 45 08	 mov	 eax, DWORD PTR _f$[ebp]
  005bd	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  005c0	0f 87 76 fa ff
	ff		 ja	 $LN4@readPlayer
$LN3@readPlayer:

; 446  : 
; 447  : 	if (slotfound)

  005c6	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _slotfound$[ebp], 0
  005cd	74 21		 je	 SHORT $LN42@readPlayer

; 448  : 		DEH_WriteUndoline("MENUPOSITION", va("%d", num), UNDO_NONE);

  005cf	6a 00		 push	 0
  005d1	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  005d4	50		 push	 eax
  005d5	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  005da	e8 00 00 00 00	 call	 _va
  005df	83 c4 08	 add	 esp, 8
  005e2	50		 push	 eax
  005e3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PPNPBINO@MENUPOSITION@
  005e8	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  005ed	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@readPlayer:

; 449  : }

  005f0	5f		 pop	 edi
  005f1	5e		 pop	 esi
  005f2	5b		 pop	 ebx
  005f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f6	33 cd		 xor	 ecx, ebp
  005f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005fd	8b e5		 mov	 esp, ebp
  005ff	5d		 pop	 ebp
  00600	c3		 ret	 0
_readPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _findFreeSlot
_TEXT	SEGMENT
_num$ = 8						; size = 4
_findFreeSlot PROC					; COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@findFreeSl:

; 304  : 	// Send the character select entry to a free slot.
; 305  : 	while (*num < 15 && PlayerMenu[*num].status != IT_DISABLED)

  00009	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  0000c	83 38 0f	 cmp	 DWORD PTR [eax], 15	; 0000000fH
  0000f	7d 21		 jge	 SHORT $LN3@findFreeSl
  00011	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00014	6b 08 14	 imul	 ecx, DWORD PTR [eax], 20
  00017	0f bf 91 00 00
	00 00		 movsx	 edx, WORD PTR _PlayerMenu[ecx]
  0001e	83 fa 7a	 cmp	 edx, 122		; 0000007aH
  00021	74 0f		 je	 SHORT $LN3@findFreeSl

; 306  : 		*num = *num+1;

  00023	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	83 c1 01	 add	 ecx, 1
  0002b	8b 55 08	 mov	 edx, DWORD PTR _num$[ebp]
  0002e	89 0a		 mov	 DWORD PTR [edx], ecx
  00030	eb d7		 jmp	 SHORT $LN2@findFreeSl
$LN3@findFreeSl:

; 307  : 
; 308  : 	// No more free slots. :(
; 309  : 	if (*num >= 15)

  00032	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  00035	83 38 0f	 cmp	 DWORD PTR [eax], 15	; 0000000fH
  00038	7c 04		 jl	 SHORT $LN4@findFreeSl

; 310  : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 05		 jmp	 SHORT $LN1@findFreeSl
$LN4@findFreeSl:

; 311  : 
; 312  : 	// Found one! ^_^
; 313  : 	return true;

  0003e	b8 01 00 00 00	 mov	 eax, 1
$LN1@findFreeSl:

; 314  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_findFreeSlot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _searchvalue
_TEXT	SEGMENT
_s$ = 8							; size = 4
_searchvalue PROC					; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@searchvalu:

; 227  : 	while (s[0] != '=' && s[0])

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00014	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00018	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0001b	74 1e		 je	 SHORT $LN3@searchvalu
  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	6b c8 00	 imul	 ecx, eax, 0
  00025	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00028	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0002c	85 c0		 test	 eax, eax
  0002e	74 0b		 je	 SHORT $LN3@searchvalu

; 228  : 		s++;

  00030	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 08	 mov	 DWORD PTR _s$[ebp], eax
  00039	eb ce		 jmp	 SHORT $LN2@searchvalu
$LN3@searchvalu:

; 229  : 	if (s[0] == '=')

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	6b c8 00	 imul	 ecx, eax, 0
  00043	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00046	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0004a	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0004d	75 18		 jne	 SHORT $LN4@searchvalu

; 230  : 		return atoi(&s[1]);

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	c1 e0 00	 shl	 eax, 0
  00057	03 45 08	 add	 eax, DWORD PTR _s$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _atoi
  00060	83 c4 04	 add	 esp, 4
  00063	eb 11		 jmp	 SHORT $LN5@searchvalu
  00065	eb 0f		 jmp	 SHORT $LN5@searchvalu
$LN4@searchvalu:

; 231  : 	else
; 232  : 	{
; 233  : 		deh_warning("No value found");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MABBGDAN@No?5value?5found@
  0006c	e8 00 00 00 00	 call	 _deh_warning
  00071	83 c4 04	 add	 esp, 4

; 234  : 		return 0;

  00074	33 c0		 xor	 eax, eax
$LN5@searchvalu:

; 235  : 	}
; 236  : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_searchvalue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _deh_warning
_TEXT	SEGMENT
_buf$ = -1008						; size = 1000
_argptr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_first$ = 8						; size = 4
_deh_warning PROC					; COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 04 00
	00		 sub	 esp, 1136		; 00000470H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 182  : 	va_list argptr;
; 183  : 	XBOXSTATIC char buf[1000];
; 184  : 
; 185  : 	va_start(argptr, first);

  00016	8d 45 0c	 lea	 eax, DWORD PTR _first$[ebp+4]
  00019	89 45 f8	 mov	 DWORD PTR _argptr$[ebp], eax

; 186  : 	_vsnprintf(buf, sizeof buf, first, argptr);

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _argptr$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  00023	51		 push	 ecx
  00024	68 e8 03 00 00	 push	 1000			; 000003e8H
  00029	8d 95 10 fc ff
	ff		 lea	 edx, DWORD PTR _buf$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 __vsnprintf
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 187  : 	va_end(argptr);

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _argptr$[ebp], 0

; 188  : 
; 189  : 	CONS_Printf("%s\n", buf);

  0003f	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  0004b	e8 00 00 00 00	 call	 _CONS_Printf
  00050	83 c4 08	 add	 esp, 8

; 190  : 
; 191  : 	deh_num_warning++;

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _deh_num_warning
  00058	83 c0 01	 add	 eax, 1
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _deh_num_warning, eax

; 192  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_deh_warning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _myhashfgets
_TEXT	SEGMENT
_c$1 = -5						; size = 1
_i$ = -4						; size = 4
_buf$ = 8						; size = 4
_bufsize$ = 12						; size = 4
_f$ = 16						; size = 4
_myhashfgets PROC					; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 159  : 	size_t i = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 160  : 	if (myfeof(f))

  00010	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 55 10	 mov	 edx, DWORD PTR _f$[ebp]
  00018	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  0001b	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0001e	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00021	77 04		 ja	 SHORT $LN4@myhashfget

; 161  : 		return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 7d		 jmp	 SHORT $LN1@myhashfget
$LN4@myhashfget:

; 162  : 	// we need one byte for a null terminated string
; 163  : 	bufsize--;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _bufsize$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 0c	 mov	 DWORD PTR _bufsize$[ebp], eax
$LN2@myhashfget:

; 164  : 	while (i < bufsize && !myfeof(f))

  00030	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 45 0c	 cmp	 eax, DWORD PTR _bufsize$[ebp]
  00036	73 57		 jae	 SHORT $LN3@myhashfget
  00038	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8b 55 10	 mov	 edx, DWORD PTR _f$[ebp]
  00040	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00043	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  00046	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00049	76 44		 jbe	 SHORT $LN3@myhashfget

; 165  : 	{
; 166  : 		char c = *f->curpos++;

  0004b	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0004e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00051	8a 11		 mov	 dl, BYTE PTR [ecx]
  00053	88 55 fb	 mov	 BYTE PTR _c$1[ebp], dl
  00056	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	83 c1 01	 add	 ecx, 1
  0005f	8b 55 10	 mov	 edx, DWORD PTR _f$[ebp]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 167  : 		if (c != '\r')

  00065	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  00069	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0006c	74 14		 je	 SHORT $LN5@myhashfget

; 168  : 			buf[i++] = c;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00071	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00074	8a 4d fb	 mov	 cl, BYTE PTR _c$1[ebp]
  00077	88 08		 mov	 BYTE PTR [eax], cl
  00079	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0007c	83 c2 01	 add	 edx, 1
  0007f	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN5@myhashfget:

; 169  : 		if (c == '#')

  00082	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  00086	83 f8 23	 cmp	 eax, 35			; 00000023H
  00089	75 02		 jne	 SHORT $LN6@myhashfget

; 170  : 			break;

  0008b	eb 02		 jmp	 SHORT $LN3@myhashfget
$LN6@myhashfget:

; 171  : 	}

  0008d	eb a1		 jmp	 SHORT $LN2@myhashfget
$LN3@myhashfget:

; 172  : 	i++;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00092	83 c0 01	 add	 eax, 1
  00095	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 173  : 	buf[i] = '\0';

  00098	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0009b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 174  : 
; 175  : 	return buf;

  000a1	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
$LN1@myhashfget:

; 176  : }

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_myhashfgets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _myfgets
_TEXT	SEGMENT
_c$1 = -5						; size = 1
_i$ = -4						; size = 4
_buf$ = 8						; size = 4
_bufsize$ = 12						; size = 4
_f$ = 16						; size = 4
_myfgets PROC						; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 139  : 	size_t i = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 140  : 	if (myfeof(f))

  00010	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 55 10	 mov	 edx, DWORD PTR _f$[ebp]
  00018	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  0001b	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0001e	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00021	77 04		 ja	 SHORT $LN4@myfgets

; 141  : 		return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 74		 jmp	 SHORT $LN1@myfgets
$LN4@myfgets:

; 142  : 	// we need one byte for a null terminated string
; 143  : 	bufsize--;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _bufsize$[ebp]
  0002a	83 e8 01	 sub	 eax, 1
  0002d	89 45 0c	 mov	 DWORD PTR _bufsize$[ebp], eax
$LN2@myfgets:

; 144  : 	while (i < bufsize && !myfeof(f))

  00030	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 45 0c	 cmp	 eax, DWORD PTR _bufsize$[ebp]
  00036	73 57		 jae	 SHORT $LN3@myfgets
  00038	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8b 55 10	 mov	 edx, DWORD PTR _f$[ebp]
  00040	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00043	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  00046	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00049	76 44		 jbe	 SHORT $LN3@myfgets

; 145  : 	{
; 146  : 		char c = *f->curpos++;

  0004b	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  0004e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00051	8a 11		 mov	 dl, BYTE PTR [ecx]
  00053	88 55 fb	 mov	 BYTE PTR _c$1[ebp], dl
  00056	8b 45 10	 mov	 eax, DWORD PTR _f$[ebp]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	83 c1 01	 add	 ecx, 1
  0005f	8b 55 10	 mov	 edx, DWORD PTR _f$[ebp]
  00062	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 147  : 		if (c != '\r')

  00065	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  00069	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0006c	74 14		 je	 SHORT $LN5@myfgets

; 148  : 			buf[i++] = c;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00071	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00074	8a 4d fb	 mov	 cl, BYTE PTR _c$1[ebp]
  00077	88 08		 mov	 BYTE PTR [eax], cl
  00079	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0007c	83 c2 01	 add	 edx, 1
  0007f	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN5@myfgets:

; 149  : 		if (c == '\n')

  00082	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  00086	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00089	75 02		 jne	 SHORT $LN6@myfgets

; 150  : 			break;

  0008b	eb 02		 jmp	 SHORT $LN3@myfgets
$LN6@myfgets:

; 151  : 	}

  0008d	eb a1		 jmp	 SHORT $LN2@myfgets
$LN3@myfgets:

; 152  : 	buf[i] = '\0';

  0008f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00092	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0

; 153  : 
; 154  : 	return buf;

  00098	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
$LN1@myfgets:

; 155  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_myfgets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _DEH_LoadDehackedLumpPwad
_TEXT	SEGMENT
_f$ = -12						; size = 12
_wad$ = 8						; size = 2
_lump$ = 12						; size = 2
_DEH_LoadDehackedLumpPwad PROC				; COMDAT

; 2182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2183 : 	MYFILE f;
; 2184 : 	unsocwad = wad;

  00009	66 8b 45 08	 mov	 ax, WORD PTR _wad$[ebp]
  0000d	66 a3 00 00 00
	00		 mov	 WORD PTR _unsocwad, ax

; 2185 : 	f.size = W_LumpLengthPwad(wad,lump);

  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _lump$[ebp]
  00017	50		 push	 eax
  00018	0f b7 4d 08	 movzx	 ecx, WORD PTR _wad$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _W_LumpLengthPwad
  00022	83 c4 08	 add	 esp, 8
  00025	89 45 fc	 mov	 DWORD PTR _f$[ebp+8], eax

; 2186 : 	f.data = Z_Malloc(f.size + 1, PU_STATIC, NULL);

  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	6a 01		 push	 1
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _f$[ebp+8]
  00031	83 c0 01	 add	 eax, 1
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _Z_MallocAlign
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
  0003d	89 45 f4	 mov	 DWORD PTR _f$[ebp], eax

; 2187 : 	W_ReadLumpPwad(wad, lump, f.data);

  00040	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00043	50		 push	 eax
  00044	0f b7 4d 0c	 movzx	 ecx, WORD PTR _lump$[ebp]
  00048	51		 push	 ecx
  00049	0f b7 55 08	 movzx	 edx, WORD PTR _wad$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _W_ReadLumpPwad
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2188 : 	f.curpos = f.data;

  00056	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00059	89 45 f8	 mov	 DWORD PTR _f$[ebp+4], eax

; 2189 : 	f.data[f.size] = 0;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  0005f	03 45 fc	 add	 eax, DWORD PTR _f$[ebp+8]
  00062	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2190 : 	DEH_LoadDehackedFile(&f);

  00065	8d 45 f4	 lea	 eax, DWORD PTR _f$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _DEH_LoadDehackedFile
  0006e	83 c4 04	 add	 esp, 4

; 2191 : 	DEH_WriteUndoline(va("# uload for wad: %u, lump: %u", wad, lump), NULL, UNDO_DONE);

  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	0f b7 45 0c	 movzx	 eax, WORD PTR _lump$[ebp]
  00079	50		 push	 eax
  0007a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wad$[ebp]
  0007e	51		 push	 ecx
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IPBFEFIB@?$CD?5uload?5for?5wad?3?5?$CFu?0?5lump?3?5?$CFu@
  00084	e8 00 00 00 00	 call	 _va
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _DEH_WriteUndoline
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2192 : 	Z_Free(f.data);

  00095	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _Z_Free
  0009e	83 c4 04	 add	 esp, 4

; 2193 : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_DEH_LoadDehackedLumpPwad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _DEH_LoadDehackedLump
_TEXT	SEGMENT
_lumpnum$ = 8						; size = 4
_DEH_LoadDehackedLump PROC				; COMDAT

; 2196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2197 : 	DEH_LoadDehackedLumpPwad(WADFILENUM(lumpnum),LUMPNUM(lumpnum));

  00009	8b 45 08	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _lumpnum$[ebp]
  00015	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _DEH_LoadDehackedLumpPwad
  0001e	83 c4 08	 add	 esp, 8

; 2198 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_DEH_LoadDehackedLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _DEH_UnloadDehackedWad
_TEXT	SEGMENT
_UNDO$ = -32						; size = 4
_data$ = -28						; size = 4
_len$ = -24						; size = 4
_f$ = -20						; size = 12
_curundo$ = -8						; size = 4
_tmp$ = -4						; size = 4
_wad$ = 8						; size = 2
_DEH_UnloadDehackedWad PROC				; COMDAT

; 2204 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2205 : 	undehacked_t *tmp, *curundo = unsocdata[wad];

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _wad$[ebp]
  0000d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _unsocdata[eax*4]
  00014	89 4d f8	 mov	 DWORD PTR _curundo$[ebp], ecx

; 2206 : 	MYFILE f;
; 2207 : 	size_t len = 0;

  00017	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 2208 : 	char *data;
; 2209 : #ifdef DUMPUNDONE
; 2210 : 	FILE *UNDO = fopen("undo.soc", "wt");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_02BKFDOEMK@wt@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_08OKNICAFF@undo?4soc@
  00028	e8 00 00 00 00	 call	 _fopen
  0002d	83 c4 08	 add	 esp, 8
  00030	89 45 e0	 mov	 DWORD PTR _UNDO$[ebp], eax

; 2211 : #endif
; 2212 : 	CONS_Printf("%s", text[UNLOADING_SOC_EDITS]);

  00033	b8 04 00 00 00	 mov	 eax, 4
  00038	69 c8 e0 00 00
	00		 imul	 ecx, eax, 224
  0003e	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _text[ecx]
  00044	52		 push	 edx
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0004a	e8 00 00 00 00	 call	 _CONS_Printf
  0004f	83 c4 08	 add	 esp, 8
$LN2@DEH_Unload:

; 2213 : 	while (curundo)

  00052	83 7d f8 00	 cmp	 DWORD PTR _curundo$[ebp], 0
  00056	74 68		 je	 SHORT $LN3@DEH_Unload

; 2214 : 	{
; 2215 : 		data = curundo->undata;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _curundo$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 4d e4	 mov	 DWORD PTR _data$[ebp], ecx

; 2216 : 		curundo = curundo->next;

  00060	8b 45 f8	 mov	 eax, DWORD PTR _curundo$[ebp]
  00063	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00066	89 4d f8	 mov	 DWORD PTR _curundo$[ebp], ecx

; 2217 : 		if (data)

  00069	83 7d e4 00	 cmp	 DWORD PTR _data$[ebp], 0
  0006d	74 12		 je	 SHORT $LN6@DEH_Unload

; 2218 : 			len += strlen(data);

  0006f	8b 45 e4	 mov	 eax, DWORD PTR _data$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _strlen
  00078	83 c4 04	 add	 esp, 4
  0007b	03 45 e8	 add	 eax, DWORD PTR _len$[ebp]
  0007e	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax
$LN6@DEH_Unload:

; 2219 : 		len += 1;

  00081	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 2220 : #ifdef DUMPUNDONE
; 2221 : 		if (UNDO)

  0008a	83 7d e0 00	 cmp	 DWORD PTR _UNDO$[ebp], 0
  0008e	74 2e		 je	 SHORT $LN9@DEH_Unload

; 2222 : 		{
; 2223 : 			if (data)

  00090	83 7d e4 00	 cmp	 DWORD PTR _data$[ebp], 0
  00094	74 17		 je	 SHORT $LN8@DEH_Unload

; 2224 : 				fprintf(UNDO, "%s\n", data);

  00096	8b 45 e4	 mov	 eax, DWORD PTR _data$[ebp]
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR _UNDO$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _fprintf
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	eb 11		 jmp	 SHORT $LN9@DEH_Unload
$LN8@DEH_Unload:

; 2225 : 			else
; 2226 : 				fprintf(UNDO, "\n");

  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000b2	8b 45 e0	 mov	 eax, DWORD PTR _UNDO$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _fprintf
  000bb	83 c4 08	 add	 esp, 8
$LN9@DEH_Unload:

; 2227 : 		}
; 2228 : #endif
; 2229 : 	}

  000be	eb 92		 jmp	 SHORT $LN2@DEH_Unload
$LN3@DEH_Unload:

; 2230 : #ifndef DUMPUNDONE
; 2231 : 	if (UNDO) fclose(UNDO);
; 2232 : #endif
; 2233 : 	if (!len) return;

  000c0	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  000c4	75 05		 jne	 SHORT $LN10@DEH_Unload
  000c6	e9 f3 00 00 00	 jmp	 $LN1@DEH_Unload
$LN10@DEH_Unload:

; 2234 : 	f.size = len;

  000cb	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  000ce	89 45 f4	 mov	 DWORD PTR _f$[ebp+8], eax

; 2235 : 	data = f.data = Z_Malloc(f.size + 1, PU_STATIC, NULL);

  000d1	6a 00		 push	 0
  000d3	6a 00		 push	 0
  000d5	6a 01		 push	 1
  000d7	8b 45 f4	 mov	 eax, DWORD PTR _f$[ebp+8]
  000da	83 c0 01	 add	 eax, 1
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _Z_MallocAlign
  000e3	83 c4 10	 add	 esp, 16			; 00000010H
  000e6	89 45 ec	 mov	 DWORD PTR _f$[ebp], eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _f$[ebp]
  000ec	89 4d e4	 mov	 DWORD PTR _data$[ebp], ecx

; 2236 : 	curundo = unsocdata[wad];

  000ef	0f b7 45 08	 movzx	 eax, WORD PTR _wad$[ebp]
  000f3	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _unsocdata[eax*4]
  000fa	89 4d f8	 mov	 DWORD PTR _curundo$[ebp], ecx

; 2237 : 	unsocdata[wad] = NULL;

  000fd	0f b7 45 08	 movzx	 eax, WORD PTR _wad$[ebp]
  00101	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _unsocdata[eax*4], 0
$LN4@DEH_Unload:

; 2238 : 	while (curundo)

  0010c	83 7d f8 00	 cmp	 DWORD PTR _curundo$[ebp], 0
  00110	74 71		 je	 SHORT $LN5@DEH_Unload

; 2239 : 	{
; 2240 : 		tmp = curundo;

  00112	8b 45 f8	 mov	 eax, DWORD PTR _curundo$[ebp]
  00115	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax

; 2241 : 		curundo = curundo->next;

  00118	8b 45 f8	 mov	 eax, DWORD PTR _curundo$[ebp]
  0011b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011e	89 4d f8	 mov	 DWORD PTR _curundo$[ebp], ecx

; 2242 : 		if (tmp->undata)

  00121	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  00124	83 38 00	 cmp	 DWORD PTR [eax], 0
  00127	74 1f		 je	 SHORT $LN11@DEH_Unload

; 2243 : 			data += sprintf(data, "%s\n", tmp->undata);

  00129	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  0012c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012e	51		 push	 ecx
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  00134	8b 55 e4	 mov	 edx, DWORD PTR _data$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _sprintf
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	03 45 e4	 add	 eax, DWORD PTR _data$[ebp]
  00143	89 45 e4	 mov	 DWORD PTR _data$[ebp], eax
  00146	eb 17		 jmp	 SHORT $LN12@DEH_Unload
$LN11@DEH_Unload:

; 2244 : 		else
; 2245 : 			data += sprintf(data, "\n");

  00148	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0014d	8b 45 e4	 mov	 eax, DWORD PTR _data$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _sprintf
  00156	83 c4 08	 add	 esp, 8
  00159	03 45 e4	 add	 eax, DWORD PTR _data$[ebp]
  0015c	89 45 e4	 mov	 DWORD PTR _data$[ebp], eax
$LN12@DEH_Unload:

; 2246 : 		if (tmp->undata) free(tmp->undata);

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  00162	83 38 00	 cmp	 DWORD PTR [eax], 0
  00165	74 0e		 je	 SHORT $LN13@DEH_Unload
  00167	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _free
  00172	83 c4 04	 add	 esp, 4
$LN13@DEH_Unload:

; 2247 : 		free(tmp);

  00175	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _free
  0017e	83 c4 04	 add	 esp, 4

; 2248 : 	}

  00181	eb 89		 jmp	 SHORT $LN4@DEH_Unload
$LN5@DEH_Unload:

; 2249 : 	f.curpos = f.data;

  00183	8b 45 ec	 mov	 eax, DWORD PTR _f$[ebp]
  00186	89 45 f0	 mov	 DWORD PTR _f$[ebp+4], eax

; 2250 : 	f.data[f.size] = 0;

  00189	8b 45 ec	 mov	 eax, DWORD PTR _f$[ebp]
  0018c	03 45 f4	 add	 eax, DWORD PTR _f$[ebp+8]
  0018f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2251 : 	disableundo = true;

  00192	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _disableundo, 1

; 2252 : 	DEH_LoadDehackedFile(&f);

  0019c	8d 45 ec	 lea	 eax, DWORD PTR _f$[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _DEH_LoadDehackedFile
  001a5	83 c4 04	 add	 esp, 4

; 2253 : 	disableundo = false;

  001a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _disableundo, 0

; 2254 : 	Z_Free(f.data);

  001b2	8b 45 ec	 mov	 eax, DWORD PTR _f$[ebp]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _Z_Free
  001bb	83 c4 04	 add	 esp, 4
$LN1@DEH_Unload:

; 2255 : }

  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5b		 pop	 ebx
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c3		 ret	 0
_DEH_UnloadDehackedWad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\dehacked.c
;	COMDAT _DEH_WriteUndoline
_TEXT	SEGMENT
_len$1 = -44						; size = 4
_dlen$2 = -40						; size = 4
_vlen$3 = -36						; size = 4
_elen$4 = -32						; size = 4
_undata$5 = -28						; size = 4
_pound$6 = -24						; size = 4
_plen$7 = -20						; size = 4
_newdata$ = -16						; size = 4
_pader$ = -12						; size = 4
_space$ = -8						; size = 4
_eqstr$ = -4						; size = 4
_value$ = 8						; size = 4
_data$ = 12						; size = 4
_flags$ = 16						; size = 4
_DEH_WriteUndoline PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 60   : 	const char *eqstr = " = ";

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _eqstr$[ebp], OFFSET ??_C@_03MHLONNLM@?5?$DN?5@

; 61   : 	const char *space = " ";

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _space$[ebp], OFFSET ??_C@_01CLKCMJKC@?5@

; 62   : 	const char *pader = eqstr;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _eqstr$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR _pader$[ebp], eax

; 63   : 	undehacked_t *newdata;
; 64   : 
; 65   : 	if (disableundo || !unsocwad)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _disableundo, 0
  00024	75 0b		 jne	 SHORT $LN3@DEH_WriteU
  00026	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _unsocwad
  0002d	85 c0		 test	 eax, eax
  0002f	75 05		 jne	 SHORT $LN2@DEH_WriteU
$LN3@DEH_WriteU:

; 66   : 		return;

  00031	e9 2f 02 00 00	 jmp	 $LN1@DEH_WriteU
$LN2@DEH_WriteU:

; 67   : 
; 68   : 	if ((newdata = malloc(sizeof(*newdata))) == NULL)

  00036	6a 08		 push	 8
  00038	e8 00 00 00 00	 call	 _malloc
  0003d	83 c4 04	 add	 esp, 4
  00040	89 45 f0	 mov	 DWORD PTR _newdata$[ebp], eax
  00043	83 7d f0 00	 cmp	 DWORD PTR _newdata$[ebp], 0
  00047	75 0d		 jne	 SHORT $LN4@DEH_WriteU

; 69   : 		I_Error("Out of memory for unsoc line");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IANMBFDG@Out?5of?5memory?5for?5unsoc?5line@
  0004e	e8 00 00 00 00	 call	 _I_Error
  00053	83 c4 04	 add	 esp, 4
$LN4@DEH_WriteU:

; 70   : 
; 71   : 	if (flags & UNDO_SPACE)

  00056	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00059	83 e0 02	 and	 eax, 2
  0005c	74 06		 je	 SHORT $LN5@DEH_WriteU

; 72   : 		pader = space;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _space$[ebp]
  00061	89 45 f4	 mov	 DWORD PTR _pader$[ebp], eax
$LN5@DEH_WriteU:

; 73   : 
; 74   : 	if (flags & UNDO_ENDTEXT && !data)

  00064	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00067	83 e0 08	 and	 eax, 8
  0006a	74 0c		 je	 SHORT $LN6@DEH_WriteU
  0006c	83 7d 0c 00	 cmp	 DWORD PTR _data$[ebp], 0
  00070	75 06		 jne	 SHORT $LN6@DEH_WriteU

; 75   : 		data = space;

  00072	8b 45 f8	 mov	 eax, DWORD PTR _space$[ebp]
  00075	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax
$LN6@DEH_WriteU:

; 76   : 
; 77   : 	if (value)

  00078	83 7d 08 00	 cmp	 DWORD PTR _value$[ebp], 0
  0007c	0f 84 b5 01 00
	00		 je	 $LN7@DEH_WriteU

; 78   : 	{
; 79   : 		const size_t plen = strlen(pader);

  00082	8b 45 f4	 mov	 eax, DWORD PTR _pader$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _strlen
  0008b	83 c4 04	 add	 esp, 4
  0008e	89 45 ec	 mov	 DWORD PTR _plen$7[ebp], eax

; 80   : 		const char *pound = "#";

  00091	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pound$6[ebp], OFFSET ??_C@_01IPJKGB@?$CD@

; 81   : 		char *undata = NULL;

  00098	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _undata$5[ebp], 0

; 82   : 		const size_t elen = strlen(pound);

  0009f	8b 45 e8	 mov	 eax, DWORD PTR _pound$6[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _strlen
  000a8	83 c4 04	 add	 esp, 4
  000ab	89 45 e0	 mov	 DWORD PTR _elen$4[ebp], eax

; 83   : 		size_t vlen = strlen(value), dlen = 0, len = 1;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _strlen
  000b7	83 c4 04	 add	 esp, 4
  000ba	89 45 dc	 mov	 DWORD PTR _vlen$3[ebp], eax
  000bd	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dlen$2[ebp], 0
  000c4	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _len$1[ebp], 1

; 84   : 
; 85   : 		if (*(value+vlen-1) == '\n')

  000cb	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  000ce	03 45 dc	 add	 eax, DWORD PTR _vlen$3[ebp]
  000d1	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  000d5	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000d8	75 09		 jne	 SHORT $LN9@DEH_WriteU

; 86   : 			vlen--; // lnet not copy the ending \n

  000da	8b 45 dc	 mov	 eax, DWORD PTR _vlen$3[ebp]
  000dd	83 e8 01	 sub	 eax, 1
  000e0	89 45 dc	 mov	 DWORD PTR _vlen$3[ebp], eax
$LN9@DEH_WriteU:

; 87   : 
; 88   : 		if (flags & UNDO_ENDTEXT)

  000e3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000e6	83 e0 08	 and	 eax, 8
  000e9	74 09		 je	 SHORT $LN10@DEH_WriteU

; 89   : 			len += elen; // let malloc more space

  000eb	8b 45 d4	 mov	 eax, DWORD PTR _len$1[ebp]
  000ee	03 45 e0	 add	 eax, DWORD PTR _elen$4[ebp]
  000f1	89 45 d4	 mov	 DWORD PTR _len$1[ebp], eax
$LN10@DEH_WriteU:

; 90   : 
; 91   : 		if (flags & UNDO_NEWLINE)

  000f4	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000f7	83 e0 01	 and	 eax, 1
  000fa	74 09		 je	 SHORT $LN11@DEH_WriteU

; 92   : 			len++; // more space for the beginning \n

  000fc	8b 45 d4	 mov	 eax, DWORD PTR _len$1[ebp]
  000ff	83 c0 01	 add	 eax, 1
  00102	89 45 d4	 mov	 DWORD PTR _len$1[ebp], eax
$LN11@DEH_WriteU:

; 93   : 
; 94   : 		if (data)

  00105	83 7d 0c 00	 cmp	 DWORD PTR _data$[ebp], 0
  00109	74 61		 je	 SHORT $LN12@DEH_WriteU

; 95   : 		{
; 96   : 			dlen = strlen(data);

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _strlen
  00114	83 c4 04	 add	 esp, 4
  00117	89 45 d8	 mov	 DWORD PTR _dlen$2[ebp], eax

; 97   : 			if (flags & UNDO_CUTLINE && *(data+dlen-1) == '\n')

  0011a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0011d	83 e0 04	 and	 eax, 4
  00120	74 18		 je	 SHORT $LN14@DEH_WriteU
  00122	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00125	03 45 d8	 add	 eax, DWORD PTR _dlen$2[ebp]
  00128	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  0012c	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0012f	75 09		 jne	 SHORT $LN14@DEH_WriteU

; 98   : 				dlen--; // let not copy the ending \n

  00131	8b 45 d8	 mov	 eax, DWORD PTR _dlen$2[ebp]
  00134	83 e8 01	 sub	 eax, 1
  00137	89 45 d8	 mov	 DWORD PTR _dlen$2[ebp], eax
$LN14@DEH_WriteU:

; 99   : 			newdata->undata = malloc(vlen+plen+dlen+len);

  0013a	8b 45 dc	 mov	 eax, DWORD PTR _vlen$3[ebp]
  0013d	03 45 ec	 add	 eax, DWORD PTR _plen$7[ebp]
  00140	03 45 d8	 add	 eax, DWORD PTR _dlen$2[ebp]
  00143	03 45 d4	 add	 eax, DWORD PTR _len$1[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _malloc
  0014c	83 c4 04	 add	 esp, 4
  0014f	8b 4d f0	 mov	 ecx, DWORD PTR _newdata$[ebp]
  00152	89 01		 mov	 DWORD PTR [ecx], eax

; 100  : 			newdata->undata[vlen+plen+dlen+len-1] = '\0';

  00154	8b 45 dc	 mov	 eax, DWORD PTR _vlen$3[ebp]
  00157	03 45 ec	 add	 eax, DWORD PTR _plen$7[ebp]
  0015a	03 45 d8	 add	 eax, DWORD PTR _dlen$2[ebp]
  0015d	03 45 d4	 add	 eax, DWORD PTR _len$1[ebp]
  00160	8b 4d f0	 mov	 ecx, DWORD PTR _newdata$[ebp]
  00163	8b 11		 mov	 edx, DWORD PTR [ecx]
  00165	c6 44 02 ff 00	 mov	 BYTE PTR [edx+eax-1], 0

; 101  : 		}

  0016a	eb 24		 jmp	 SHORT $LN13@DEH_WriteU
$LN12@DEH_WriteU:

; 102  : 		else
; 103  : 		{
; 104  : 			newdata->undata = malloc(vlen+len);

  0016c	8b 45 dc	 mov	 eax, DWORD PTR _vlen$3[ebp]
  0016f	03 45 d4	 add	 eax, DWORD PTR _len$1[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _malloc
  00178	83 c4 04	 add	 esp, 4
  0017b	8b 4d f0	 mov	 ecx, DWORD PTR _newdata$[ebp]
  0017e	89 01		 mov	 DWORD PTR [ecx], eax

; 105  : 			newdata->undata[vlen+len-1] = '\0';

  00180	8b 45 dc	 mov	 eax, DWORD PTR _vlen$3[ebp]
  00183	03 45 d4	 add	 eax, DWORD PTR _len$1[ebp]
  00186	8b 4d f0	 mov	 ecx, DWORD PTR _newdata$[ebp]
  00189	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018b	c6 44 02 ff 00	 mov	 BYTE PTR [edx+eax-1], 0
$LN13@DEH_WriteU:

; 106  : 		}
; 107  : 
; 108  : 		if (newdata->undata)

  00190	8b 45 f0	 mov	 eax, DWORD PTR _newdata$[ebp]
  00193	83 38 00	 cmp	 DWORD PTR [eax], 0
  00196	74 10		 je	 SHORT $LN15@DEH_WriteU

; 109  : 		{
; 110  : 			undata = newdata->undata;

  00198	8b 45 f0	 mov	 eax, DWORD PTR _newdata$[ebp]
  0019b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019d	89 4d e4	 mov	 DWORD PTR _undata$5[ebp], ecx

; 111  : 			*undata = '\0';

  001a0	8b 45 e4	 mov	 eax, DWORD PTR _undata$5[ebp]
  001a3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 112  : 		}

  001a6	eb 19		 jmp	 SHORT $LN16@DEH_WriteU
$LN15@DEH_WriteU:

; 113  : 		else
; 114  : 		{
; 115  : 			free(newdata);

  001a8	8b 45 f0	 mov	 eax, DWORD PTR _newdata$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _free
  001b1	83 c4 04	 add	 esp, 4

; 116  : 			I_Error("Out of memory for unsoc data");

  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MFJFLK@Out?5of?5memory?5for?5unsoc?5data@
  001b9	e8 00 00 00 00	 call	 _I_Error
  001be	83 c4 04	 add	 esp, 4
$LN16@DEH_WriteU:

; 117  : 		}
; 118  : 
; 119  : 		if (flags & UNDO_NEWLINE) // let start with \n

  001c1	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001c4	83 e0 01	 and	 eax, 1
  001c7	74 11		 je	 SHORT $LN17@DEH_WriteU

; 120  : 			strcat(undata, "\n");

  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  001ce	8b 45 e4	 mov	 eax, DWORD PTR _undata$5[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _strcat
  001d7	83 c4 08	 add	 esp, 8
$LN17@DEH_WriteU:

; 121  : 
; 122  : 		strncat(undata, value, vlen);

  001da	8b 45 dc	 mov	 eax, DWORD PTR _vlen$3[ebp]
  001dd	50		 push	 eax
  001de	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  001e1	51		 push	 ecx
  001e2	8b 55 e4	 mov	 edx, DWORD PTR _undata$5[ebp]
  001e5	52		 push	 edx
  001e6	e8 00 00 00 00	 call	 _strncat
  001eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : 
; 124  : 		if (data) // value+pader+data

  001ee	83 7d 0c 00	 cmp	 DWORD PTR _data$[ebp], 0
  001f2	74 25		 je	 SHORT $LN18@DEH_WriteU

; 125  : 			strncat(strncat(undata, pader, plen), data, dlen);

  001f4	8b 45 d8	 mov	 eax, DWORD PTR _dlen$2[ebp]
  001f7	50		 push	 eax
  001f8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  001fb	51		 push	 ecx
  001fc	8b 55 ec	 mov	 edx, DWORD PTR _plen$7[ebp]
  001ff	52		 push	 edx
  00200	8b 45 f4	 mov	 eax, DWORD PTR _pader$[ebp]
  00203	50		 push	 eax
  00204	8b 4d e4	 mov	 ecx, DWORD PTR _undata$5[ebp]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _strncat
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _strncat
  00216	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@DEH_WriteU:

; 126  : 
; 127  : 		if (flags & UNDO_ENDTEXT) // let end the text

  00219	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0021c	83 e0 08	 and	 eax, 8
  0021f	74 14		 je	 SHORT $LN19@DEH_WriteU

; 128  : 			strncat(undata, pound, elen);

  00221	8b 45 e0	 mov	 eax, DWORD PTR _elen$4[ebp]
  00224	50		 push	 eax
  00225	8b 4d e8	 mov	 ecx, DWORD PTR _pound$6[ebp]
  00228	51		 push	 ecx
  00229	8b 55 e4	 mov	 edx, DWORD PTR _undata$5[ebp]
  0022c	52		 push	 edx
  0022d	e8 00 00 00 00	 call	 _strncat
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@DEH_WriteU:

; 129  : 	}

  00235	eb 09		 jmp	 SHORT $LN8@DEH_WriteU
$LN7@DEH_WriteU:

; 130  : 	else
; 131  : 		newdata->undata = NULL;

  00237	8b 45 f0	 mov	 eax, DWORD PTR _newdata$[ebp]
  0023a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN8@DEH_WriteU:

; 132  : 
; 133  : 	newdata->next = unsocdata[unsocwad];

  00240	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _unsocwad
  00247	8b 4d f0	 mov	 ecx, DWORD PTR _newdata$[ebp]
  0024a	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _unsocdata[eax*4]
  00251	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 134  : 	unsocdata[unsocwad] = newdata;

  00254	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _unsocwad
  0025b	8b 4d f0	 mov	 ecx, DWORD PTR _newdata$[ebp]
  0025e	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _unsocdata[eax*4], ecx
$LN1@DEH_WriteU:

; 135  : }

  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5b		 pop	 ebx
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c3		 ret	 0
_DEH_WriteUndoline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1411 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1413 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
