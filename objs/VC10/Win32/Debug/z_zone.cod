; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\z_zone.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
PUBLIC	_Z_Init
PUBLIC	_Z_FreeTags
PUBLIC	_Z_CheckMemCleanup
PUBLIC	_Z_CheckHeap
PUBLIC	_Z_ChangeTag2
PUBLIC	_Z_SetUser2
PUBLIC	_Z_Free
PUBLIC	_Z_MallocAlign
PUBLIC	_Z_CallocAlign
PUBLIC	_Z_ReallocAlign
PUBLIC	_Z_TagUsage
PUBLIC	_Z_TagsUsage
PUBLIC	_Z_StrDup
PUBLIC	??_C@_0N@HAJGDCGP@?$CFs?3?5wrong?5id@		; `string'
PUBLIC	??_C@_0BO@EDNAGBNJ@system?5memory?5?$CFuMB?5free?5?$CFuMB?6@ ; `string'
PUBLIC	??_C@_07DNAFJGOJ@memfree@			; `string'
PUBLIC	??_C@_06FIPNHPIN@Z_Free@			; `string'
PUBLIC	??_C@_0CD@LGGDFDAG@Out?5of?5memory?5allocating?5?$CFIu?5by@ ; `string'
PUBLIC	??_C@_0EH@HAMCMOPH@Z_Malloc?3?5attempted?5to?5allocate@ ; `string'
PUBLIC	??_C@_09DCOECCCH@Z_Realloc@			; `string'
PUBLIC	??_C@_0DE@LMFNDHIH@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@ ; `string'
PUBLIC	??_C@_0CP@JBIAPKCO@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@ ; `string'
PUBLIC	??_C@_0DD@PAIKMPDP@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@ ; `string'
PUBLIC	??_C@_0EF@KLEMHKHC@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@ ; `string'
PUBLIC	??_C@_0CL@BHMFGNNL@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5have?5t@ ; `string'
PUBLIC	??_C@_0FD@HFJCOGCH@Internal?5memory?5management?5erro@ ; `string'
PUBLIC	??_C@_0O@DFFNCKCO@?$ACMemory?5Info?6@		; `string'
PUBLIC	??_C@_0BN@OMNOEHB@Total?5heap?5used?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@LJFLHOPG@Static?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@LNDBCBKL@Static?5?$CIsound?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@MOKJEJNA@Static?5?$CImusic?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@JINJIKHF@Level?5?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@NPIIMHKM@Special?5thinker?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@FJPMNJBN@All?5purgable?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@PMEDPAB@Patch?5info?5headers?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@KKPGPFPM@Mipmap?5patches?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@EFEACLKD@HW?5Texture?5cache?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BN@DNFMLEH@Plane?5polygons?5?5?5?5?3?5?$CF7Iu?5KB?6@ ; `string'
PUBLIC	??_C@_0BM@JGHKLFAP@HW?5Texture?5used?5?5?5?3?5?$CF7d?5KB?6@ ; `string'
PUBLIC	??_C@_0BF@HIEMJGJA@?$ACSystem?5Memory?5Info?6@	; `string'
PUBLIC	??_C@_0CD@IBJJKJOC@?5?5?5?5Total?5physical?5memory?3?5?$CF7u?5@ ; `string'
PUBLIC	??_C@_0CD@EDAMFCLH@Available?5physical?5memory?3?5?$CF7u?5@ ; `string'
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_COM_AddCommand:PROC
EXTRN	_I_GetFreeMem:PROC
EXTRN	_HWR_GetTextureUsed:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_rendermode:DWORD
_BSS	SEGMENT
_head	DB	020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CD@EDAMFCLH@Available?5physical?5memory?3?5?$CF7u?5@
CONST	SEGMENT
??_C@_0CD@EDAMFCLH@Available?5physical?5memory?3?5?$CF7u?5@ DB 'Available'
	DB	' physical memory: %7u KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IBJJKJOC@?5?5?5?5Total?5physical?5memory?3?5?$CF7u?5@
CONST	SEGMENT
??_C@_0CD@IBJJKJOC@?5?5?5?5Total?5physical?5memory?3?5?$CF7u?5@ DB '    T'
	DB	'otal physical memory: %7u KB', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HIEMJGJA@?$ACSystem?5Memory?5Info?6@
CONST	SEGMENT
??_C@_0BF@HIEMJGJA@?$ACSystem?5Memory?5Info?6@ DB 02H, 'System Memory Inf'
	DB	'o', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JGHKLFAP@HW?5Texture?5used?5?5?5?3?5?$CF7d?5KB?6@
CONST	SEGMENT
??_C@_0BM@JGHKLFAP@HW?5Texture?5used?5?5?5?3?5?$CF7d?5KB?6@ DB 'HW Textur'
	DB	'e used   : %7d KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DNFMLEH@Plane?5polygons?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@DNFMLEH@Plane?5polygons?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'Plane pol'
	DB	'ygons    : %7Iu KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EFEACLKD@HW?5Texture?5cache?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@EFEACLKD@HW?5Texture?5cache?5?5?3?5?$CF7Iu?5KB?6@ DB 'HW Textur'
	DB	'e cache  : %7Iu KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KKPGPFPM@Mipmap?5patches?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@KKPGPFPM@Mipmap?5patches?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'Mipmap p'
	DB	'atches    : %7Iu KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PMEDPAB@Patch?5info?5headers?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@PMEDPAB@Patch?5info?5headers?3?5?$CF7Iu?5KB?6@ DB 'Patch info h'
	DB	'eaders: %7Iu KB', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FJPMNJBN@All?5purgable?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@FJPMNJBN@All?5purgable?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'All pu'
	DB	'rgable      : %7Iu KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NPIIMHKM@Special?5thinker?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@NPIIMHKM@Special?5thinker?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'Special t'
	DB	'hinker   : %7Iu KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JINJIKHF@Level?5?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@JINJIKHF@Level?5?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'L'
	DB	'evel             : %7Iu KB', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MOKJEJNA@Static?5?$CImusic?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@MOKJEJNA@Static?5?$CImusic?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'St'
	DB	'atic (music)    : %7Iu KB', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LNDBCBKL@Static?5?$CIsound?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@LNDBCBKL@Static?5?$CIsound?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'St'
	DB	'atic (sound)    : %7Iu KB', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LJFLHOPG@Static?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@LJFLHOPG@Static?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'S'
	DB	'tatic            : %7Iu KB', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OMNOEHB@Total?5heap?5used?5?5?5?3?5?$CF7Iu?5KB?6@
CONST	SEGMENT
??_C@_0BN@OMNOEHB@Total?5heap?5used?5?5?5?3?5?$CF7Iu?5KB?6@ DB 'Total hea'
	DB	'p used   : %7Iu KB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFFNCKCO@?$ACMemory?5Info?6@
CONST	SEGMENT
??_C@_0O@DFFNCKCO@?$ACMemory?5Info?6@ DB 02H, 'Memory Info', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@HFJCOGCH@Internal?5memory?5management?5erro@
CONST	SEGMENT
??_C@_0FD@HFJCOGCH@Internal?5memory?5management?5erro@ DB 'Internal memor'
	DB	'y management error: tried to make block purgable but it has n'
	DB	'o owner', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BHMFGNNL@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5have?5t@
CONST	SEGMENT
??_C@_0CL@BHMFGNNL@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5have?5t@ DB 'Z_Che'
	DB	'ckHeap %d: block %u have the wrong ID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KLEMHKHC@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@
CONST	SEGMENT
??_C@_0EF@KLEMHKHC@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@ DB 'Z_Che'
	DB	'ckHeap %d: block %u doesn''t have linkback from allocated mem'
	DB	'ory', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PAIKMPDP@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@
CONST	SEGMENT
??_C@_0DD@PAIKMPDP@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@ DB 'Z_Che'
	DB	'ckHeap %d: block %u lacks proper forward link', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JBIAPKCO@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@
CONST	SEGMENT
??_C@_0CP@JBIAPKCO@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@ DB 'Z_Che'
	DB	'ckHeap %d: block %u lacks proper backlink', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LMFNDHIH@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@
CONST	SEGMENT
??_C@_0DE@LMFNDHIH@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@ DB 'Z_Che'
	DB	'ckHeap %d: block %u doesn''t have a proper user', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_nextcleanup DD	07d0H
_DATA	ENDS
;	COMDAT ??_C@_09DCOECCCH@Z_Realloc@
CONST	SEGMENT
??_C@_09DCOECCCH@Z_Realloc@ DB 'Z_Realloc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@HAMCMOPH@Z_Malloc?3?5attempted?5to?5allocate@
CONST	SEGMENT
??_C@_0EH@HAMCMOPH@Z_Malloc?3?5attempted?5to?5allocate@ DB 'Z_Malloc: att'
	DB	'empted to allocate purgable block (size %Iu) with no user', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LGGDFDAG@Out?5of?5memory?5allocating?5?$CFIu?5by@
CONST	SEGMENT
??_C@_0CD@LGGDFDAG@Out?5of?5memory?5allocating?5?$CFIu?5by@ DB 'Out of me'
	DB	'mory allocating %Iu bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIPNHPIN@Z_Free@
CONST	SEGMENT
??_C@_06FIPNHPIN@Z_Free@ DB 'Z_Free', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DNAFJGOJ@memfree@
CONST	SEGMENT
??_C@_07DNAFJGOJ@memfree@ DB 'memfree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EDNAGBNJ@system?5memory?5?$CFuMB?5free?5?$CFuMB?6@
CONST	SEGMENT
??_C@_0BO@EDNAGBNJ@system?5memory?5?$CFuMB?5free?5?$CFuMB?6@ DB 'system m'
	DB	'emory %uMB free %uMB', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HAJGDCGP@?$CFs?3?5wrong?5id@
CONST	SEGMENT
??_C@_0N@HAJGDCGP@?$CFs?3?5wrong?5id@ DB '%s: wrong id', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _xm
_TEXT	SEGMENT
_p$ = -8						; size = 4
_padedsize$ = -4					; size = 4
_size$ = 8						; size = 4
_xm	PROC						; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 204  : 	const size_t padedsize = size+sizeof (size_t);

  00009	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 fc	 mov	 DWORD PTR _padedsize$[ebp], eax

; 205  : 	void *p = malloc(padedsize);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _padedsize$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _malloc
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 206  : 
; 207  : 	if (p == NULL)

  00021	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00025	75 35		 jne	 SHORT $LN3@xm

; 208  : 	{
; 209  : 		// Oh crumbs: we're out of heap. Try purging the cache and reallocating.
; 210  : 		Z_FreeTags(PU_PURGELEVEL, INT32_MAX);

  00027	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0002c	6a 64		 push	 100			; 00000064H
  0002e	e8 00 00 00 00	 call	 _Z_FreeTags
  00033	83 c4 08	 add	 esp, 8

; 211  : 		p = malloc(padedsize);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _padedsize$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _malloc
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 212  : 
; 213  : 		if (p == NULL)

  00045	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00049	75 11		 jne	 SHORT $LN3@xm

; 214  : 		{
; 215  : 			I_Error("Out of memory allocating %"PRIdS" bytes", size);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0004e	50		 push	 eax
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LGGDFDAG@Out?5of?5memory?5allocating?5?$CFIu?5by@
  00054	e8 00 00 00 00	 call	 _I_Error
  00059	83 c4 08	 add	 esp, 8
$LN3@xm:

; 216  : 		}
; 217  : 	}
; 218  : 
; 219  : 	return p;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]

; 220  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_xm	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Command_Memfree_f
_TEXT	SEGMENT
_totalbytes$ = -8					; size = 4
_freebytes$ = -4					; size = 4
_Command_Memfree_f PROC					; COMDAT

; 600  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 601  : 	UINT32 freebytes, totalbytes;
; 602  : 
; 603  : 	Z_CheckHeap(-1);

  00009	6a ff		 push	 -1
  0000b	e8 00 00 00 00	 call	 _Z_CheckHeap
  00010	83 c4 04	 add	 esp, 4

; 604  : 	CONS_Printf("\2Memory Info\n");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DFFNCKCO@?$ACMemory?5Info?6@
  00018	e8 00 00 00 00	 call	 _CONS_Printf
  0001d	83 c4 04	 add	 esp, 4

; 605  : 	CONS_Printf("Total heap used   : %7"PRIdS" KB\n", Z_TagsUsage(0, INT32_MAX)>>10);

  00020	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00025	6a 00		 push	 0
  00027	e8 00 00 00 00	 call	 _Z_TagsUsage
  0002c	83 c4 08	 add	 esp, 8
  0002f	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OMNOEHB@Total?5heap?5used?5?5?5?3?5?$CF7Iu?5KB?6@
  00038	e8 00 00 00 00	 call	 _CONS_Printf
  0003d	83 c4 08	 add	 esp, 8

; 606  : 	CONS_Printf("Static            : %7"PRIdS" KB\n", Z_TagUsage(PU_STATIC)>>10);

  00040	6a 01		 push	 1
  00042	e8 00 00 00 00	 call	 _Z_TagUsage
  00047	83 c4 04	 add	 esp, 4
  0004a	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LJFLHOPG@Static?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@
  00053	e8 00 00 00 00	 call	 _CONS_Printf
  00058	83 c4 08	 add	 esp, 8

; 607  : 	CONS_Printf("Static (sound)    : %7"PRIdS" KB\n", Z_TagUsage(PU_SOUND)>>10);

  0005b	6a 02		 push	 2
  0005d	e8 00 00 00 00	 call	 _Z_TagUsage
  00062	83 c4 04	 add	 esp, 4
  00065	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LNDBCBKL@Static?5?$CIsound?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@
  0006e	e8 00 00 00 00	 call	 _CONS_Printf
  00073	83 c4 08	 add	 esp, 8

; 608  : 	CONS_Printf("Static (music)    : %7"PRIdS" KB\n", Z_TagUsage(PU_MUSIC)>>10);

  00076	6a 03		 push	 3
  00078	e8 00 00 00 00	 call	 _Z_TagUsage
  0007d	83 c4 04	 add	 esp, 4
  00080	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MOKJEJNA@Static?5?$CImusic?$CJ?5?5?5?5?3?5?$CF7Iu?5KB?6@
  00089	e8 00 00 00 00	 call	 _CONS_Printf
  0008e	83 c4 08	 add	 esp, 8

; 609  : 	CONS_Printf("Level             : %7"PRIdS" KB\n", Z_TagUsage(PU_LEVEL)>>10);

  00091	6a 32		 push	 50			; 00000032H
  00093	e8 00 00 00 00	 call	 _Z_TagUsage
  00098	83 c4 04	 add	 esp, 4
  0009b	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JINJIKHF@Level?5?5?5?5?5?5?5?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@
  000a4	e8 00 00 00 00	 call	 _CONS_Printf
  000a9	83 c4 08	 add	 esp, 8

; 610  : 	CONS_Printf("Special thinker   : %7"PRIdS" KB\n", Z_TagUsage(PU_LEVSPEC)>>10);

  000ac	6a 33		 push	 51			; 00000033H
  000ae	e8 00 00 00 00	 call	 _Z_TagUsage
  000b3	83 c4 04	 add	 esp, 4
  000b6	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NPIIMHKM@Special?5thinker?5?5?5?3?5?$CF7Iu?5KB?6@
  000bf	e8 00 00 00 00	 call	 _CONS_Printf
  000c4	83 c4 08	 add	 esp, 8

; 611  : 	CONS_Printf("All purgable      : %7"PRIdS" KB\n",

  000c7	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000cc	6a 64		 push	 100			; 00000064H
  000ce	e8 00 00 00 00	 call	 _Z_TagsUsage
  000d3	83 c4 08	 add	 esp, 8
  000d6	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FJPMNJBN@All?5purgable?5?5?5?5?5?5?3?5?$CF7Iu?5KB?6@
  000df	e8 00 00 00 00	 call	 _CONS_Printf
  000e4	83 c4 08	 add	 esp, 8

; 612  : 		Z_TagsUsage(PU_PURGELEVEL, INT32_MAX)>>10);
; 613  : 
; 614  : #ifdef HWRENDER
; 615  : 	if (rendermode != render_soft && rendermode != render_none)

  000e7	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000ee	0f 84 8f 00 00
	00		 je	 $LN2@Command_Me
  000f4	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  000fb	0f 84 82 00 00
	00		 je	 $LN2@Command_Me

; 616  : 	{
; 617  : 		CONS_Printf("Patch info headers: %7"PRIdS" KB\n",

  00101	6a 05		 push	 5
  00103	e8 00 00 00 00	 call	 _Z_TagUsage
  00108	83 c4 04	 add	 esp, 4
  0010b	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  0010e	50		 push	 eax
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PMEDPAB@Patch?5info?5headers?3?5?$CF7Iu?5KB?6@
  00114	e8 00 00 00 00	 call	 _CONS_Printf
  00119	83 c4 08	 add	 esp, 8

; 618  : 			Z_TagUsage(PU_HWRPATCHINFO)>>10);
; 619  : 		CONS_Printf("Mipmap patches    : %7"PRIdS" KB\n",

  0011c	6a 06		 push	 6
  0011e	e8 00 00 00 00	 call	 _Z_TagUsage
  00123	83 c4 04	 add	 esp, 4
  00126	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KKPGPFPM@Mipmap?5patches?5?5?5?5?3?5?$CF7Iu?5KB?6@
  0012f	e8 00 00 00 00	 call	 _CONS_Printf
  00134	83 c4 08	 add	 esp, 8

; 620  : 			Z_TagUsage(PU_HWRPATCHCOLMIPMAP)>>10);
; 621  : 		CONS_Printf("HW Texture cache  : %7"PRIdS" KB\n",

  00137	6a 66		 push	 102			; 00000066H
  00139	e8 00 00 00 00	 call	 _Z_TagUsage
  0013e	83 c4 04	 add	 esp, 4
  00141	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00144	50		 push	 eax
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EFEACLKD@HW?5Texture?5cache?5?5?3?5?$CF7Iu?5KB?6@
  0014a	e8 00 00 00 00	 call	 _CONS_Printf
  0014f	83 c4 08	 add	 esp, 8

; 622  : 			Z_TagUsage(PU_HWRCACHE)>>10);
; 623  : 		CONS_Printf("Plane polygons    : %7"PRIdS" KB\n",

  00152	6a 34		 push	 52			; 00000034H
  00154	e8 00 00 00 00	 call	 _Z_TagUsage
  00159	83 c4 04	 add	 esp, 4
  0015c	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  0015f	50		 push	 eax
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DNFMLEH@Plane?5polygons?5?5?5?5?3?5?$CF7Iu?5KB?6@
  00165	e8 00 00 00 00	 call	 _CONS_Printf
  0016a	83 c4 08	 add	 esp, 8

; 624  : 			Z_TagUsage(PU_HWRPLANE)>>10);
; 625  : 		CONS_Printf("HW Texture used   : %7d KB\n",

  0016d	e8 00 00 00 00	 call	 _HWR_GetTextureUsed
  00172	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00175	50		 push	 eax
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JGHKLFAP@HW?5Texture?5used?5?5?5?3?5?$CF7d?5KB?6@
  0017b	e8 00 00 00 00	 call	 _CONS_Printf
  00180	83 c4 08	 add	 esp, 8
$LN2@Command_Me:

; 626  : 			HWR_GetTextureUsed()>>10);
; 627  : 	}
; 628  : #endif
; 629  : 
; 630  : 	CONS_Printf("\2System Memory Info\n");

  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HIEMJGJA@?$ACSystem?5Memory?5Info?6@
  00188	e8 00 00 00 00	 call	 _CONS_Printf
  0018d	83 c4 04	 add	 esp, 4

; 631  : 	freebytes = I_GetFreeMem(&totalbytes);

  00190	8d 45 f8	 lea	 eax, DWORD PTR _totalbytes$[ebp]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _I_GetFreeMem
  00199	83 c4 04	 add	 esp, 4
  0019c	89 45 fc	 mov	 DWORD PTR _freebytes$[ebp], eax

; 632  : 	CONS_Printf("    Total physical memory: %7u KB\n", totalbytes>>10);

  0019f	8b 45 f8	 mov	 eax, DWORD PTR _totalbytes$[ebp]
  001a2	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  001a5	50		 push	 eax
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@IBJJKJOC@?5?5?5?5Total?5physical?5memory?3?5?$CF7u?5@
  001ab	e8 00 00 00 00	 call	 _CONS_Printf
  001b0	83 c4 08	 add	 esp, 8

; 633  : 	CONS_Printf("Available physical memory: %7u KB\n", freebytes>>10);

  001b3	8b 45 fc	 mov	 eax, DWORD PTR _freebytes$[ebp]
  001b6	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  001b9	50		 push	 eax
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@EDAMFCLH@Available?5physical?5memory?3?5?$CF7u?5@
  001bf	e8 00 00 00 00	 call	 _CONS_Printf
  001c4	83 c4 08	 add	 esp, 8

; 634  : }

  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
  001c9	5b		 pop	 ebx
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
_Command_Memfree_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Ptr2Memblock
_TEXT	SEGMENT
_block$ = -8						; size = 4
_hdr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_func$ = 12						; size = 4
_Ptr2Memblock PROC					; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 90   : 	memhdr_t *hdr;
; 91   : 	memblock_t *block;
; 92   : 
; 93   : 	if (ptr == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN2@Ptr2Memblo

; 94   : 		return NULL;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 31		 jmp	 SHORT $LN1@Ptr2Memblo
$LN2@Ptr2Memblo:

; 95   : 
; 96   : #ifdef ZDEBUG2
; 97   : 	CONS_Printf("%s %s:%d\n", func, file, line);
; 98   : #endif
; 99   : 
; 100  : 	hdr = (memhdr_t *)((UINT8 *)ptr - sizeof *hdr);

  00013	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00016	83 e8 08	 sub	 eax, 8
  00019	89 45 fc	 mov	 DWORD PTR _hdr$[ebp], eax

; 101  : 
; 102  : #ifdef VALGRIND_MAKE_MEM_DEFINED
; 103  : 	VALGRIND_MAKE_MEM_DEFINED(hdr, sizeof *hdr);
; 104  : #endif
; 105  : 
; 106  : #ifdef VALGRIND_MEMPOOL_EXISTS
; 107  : 	if (!VALGRIND_MEMPOOL_EXISTS(hdr->block))
; 108  : 	{
; 109  : #ifdef ZDEBUG
; 110  : 		I_Error("%s: bad memblock from %s:%d", func, file, line);
; 111  : #else
; 112  : 		I_Error("%s: bad memblock", func);
; 113  : #endif
; 114  : 	}
; 115  : #endif
; 116  : 	if (hdr->id != ZONEID)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _hdr$[ebp]
  0001f	81 78 04 3d d1
	41 a4		 cmp	 DWORD PTR [eax+4], -1539190467 ; a441d13dH
  00026	74 11		 je	 SHORT $LN3@Ptr2Memblo

; 117  : 	{
; 118  : #ifdef ZDEBUG
; 119  : 		I_Error("%s: wrong id from %s:%d", func, file, line);
; 120  : #else
; 121  : 		I_Error("%s: wrong id", func);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _func$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HAJGDCGP@?$CFs?3?5wrong?5id@
  00031	e8 00 00 00 00	 call	 _I_Error
  00036	83 c4 08	 add	 esp, 8
$LN3@Ptr2Memblo:

; 122  : #endif
; 123  : 	}
; 124  : 	block = hdr->block;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _hdr$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4d f8	 mov	 DWORD PTR _block$[ebp], ecx

; 125  : #ifdef VALGRIND_MAKE_MEM_NOACCESS
; 126  : 	VALGRIND_MAKE_MEM_NOACCESS(hdr, sizeof *hdr);
; 127  : #endif
; 128  : 	return block;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _block$[ebp]
$LN1@Ptr2Memblo:

; 129  : 
; 130  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_Ptr2Memblock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_StrDup
_TEXT	SEGMENT
_s$ = 8							; size = 4
_Z_StrDup PROC						; COMDAT

; 660  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 661  : 	return strcpy(ZZ_Alloc(strlen(s) + 1), s);

  00009	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	6a 01		 push	 1
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _strlen
  0001c	83 c4 04	 add	 esp, 4
  0001f	83 c0 01	 add	 eax, 1
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _Z_MallocAlign
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _strcpy
  00031	83 c4 08	 add	 esp, 8

; 662  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_Z_StrDup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_TagsUsage
_TEXT	SEGMENT
_rover$ = -8						; size = 4
_cnt$ = -4						; size = 4
_lowtag$ = 8						; size = 4
_hightag$ = 12						; size = 4
_Z_TagsUsage PROC					; COMDAT

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 581  : 	size_t cnt = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 0

; 582  : 	memblock_t *rover;
; 583  : 
; 584  : 	for (rover = head.next; rover != &head; rover = rover->next)

  00010	a1 18 00 00 00	 mov	 eax, DWORD PTR _head+24
  00015	89 45 f8	 mov	 DWORD PTR _rover$[ebp], eax
  00018	eb 09		 jmp	 SHORT $LN4@Z_TagsUsag
$LN2@Z_TagsUsag:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0001d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00020	89 4d f8	 mov	 DWORD PTR _rover$[ebp], ecx
$LN4@Z_TagsUsag:
  00023	81 7d f8 00 00
	00 00		 cmp	 DWORD PTR _rover$[ebp], OFFSET _head
  0002a	74 2a		 je	 SHORT $LN3@Z_TagsUsag

; 585  : 	{
; 586  : 		if (rover->tag < lowtag || rover->tag > hightag)

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0002f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00032	3b 4d 08	 cmp	 ecx, DWORD PTR _lowtag$[ebp]
  00035	7c 0b		 jl	 SHORT $LN6@Z_TagsUsag
  00037	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  0003a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003d	3b 4d 0c	 cmp	 ecx, DWORD PTR _hightag$[ebp]
  00040	7e 02		 jle	 SHORT $LN5@Z_TagsUsag
$LN6@Z_TagsUsag:

; 587  : 			continue;

  00042	eb d6		 jmp	 SHORT $LN2@Z_TagsUsag
$LN5@Z_TagsUsag:

; 588  : 		cnt += rover->size + sizeof *rover;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _rover$[ebp]
  00047	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _cnt$[ebp]
  0004d	8d 44 0a 20	 lea	 eax, DWORD PTR [edx+ecx+32]
  00051	89 45 fc	 mov	 DWORD PTR _cnt$[ebp], eax

; 589  : 	}

  00054	eb c4		 jmp	 SHORT $LN2@Z_TagsUsag
$LN3@Z_TagsUsag:

; 590  : 
; 591  : 	return cnt;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _cnt$[ebp]

; 592  : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_Z_TagsUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_TagUsage
_TEXT	SEGMENT
_tagnum$ = 8						; size = 4
_Z_TagUsage PROC					; COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 596  : 	return Z_TagsUsage(tagnum, tagnum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _tagnum$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _tagnum$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _Z_TagsUsage
  00016	83 c4 08	 add	 esp, 8

; 597  : }

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
_Z_TagUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_ReallocAlign
_TEXT	SEGMENT
_copysize$ = -12					; size = 4
_block$ = -8						; size = 4
_rez$ = -4						; size = 4
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_tag$ = 16						; size = 4
_user$ = 20						; size = 4
_alignbits$ = 24					; size = 4
_Z_ReallocAlign PROC					; COMDAT

; 323  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 324  : 	void *rez;
; 325  : 	memblock_t *block;
; 326  : 	size_t copysize;
; 327  : 
; 328  : #ifdef ZDEBUG2
; 329  : 	CONS_Printf("Z_Realloc %s:%d\n", file, line);
; 330  : #endif
; 331  : 
; 332  : 	if (!size)

  00009	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  0000d	75 13		 jne	 SHORT $LN2@Z_ReallocA

; 333  : 	{
; 334  : 		Z_Free(ptr);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _Z_Free
  00018	83 c4 04	 add	 esp, 4

; 335  : 		return NULL;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 cd 00 00 00	 jmp	 $LN1@Z_ReallocA
$LN2@Z_ReallocA:

; 336  : 	}
; 337  : 
; 338  : 	if (!ptr)

  00022	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  00026	75 1d		 jne	 SHORT $LN3@Z_ReallocA

; 339  : 		return Z_CallocAlign(size, tag, user, alignbits);

  00028	8b 45 18	 mov	 eax, DWORD PTR _alignbits$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _user$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 10	 mov	 edx, DWORD PTR _tag$[ebp]
  00033	52		 push	 edx
  00034	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _Z_CallocAlign
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	e9 aa 00 00 00	 jmp	 $LN1@Z_ReallocA
$LN3@Z_ReallocA:

; 340  : 
; 341  : #ifdef ZDEBUG
; 342  : 	block = Ptr2Memblock2(ptr, "Z_Realloc", file, line);
; 343  : #else
; 344  : 	block = Ptr2Memblock(ptr, "Z_Realloc");

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_09DCOECCCH@Z_Realloc@
  0004a	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _Ptr2Memblock
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 f8	 mov	 DWORD PTR _block$[ebp], eax

; 345  : #endif
; 346  : 
; 347  : 	if (block == NULL)

  00059	83 7d f8 00	 cmp	 DWORD PTR _block$[ebp], 0
  0005d	75 07		 jne	 SHORT $LN4@Z_ReallocA

; 348  : 		return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 89 00 00 00	 jmp	 $LN1@Z_ReallocA
$LN4@Z_ReallocA:

; 349  : 
; 350  : #ifdef ZDEBUG
; 351  : 	// Write every Z_Realloc call to a debug file.
; 352  : 	DEBFILE(va("Z_Realloc at %s:%d\n", file, line));
; 353  : 	rez = Z_Malloc2(size, tag, user, alignbits, file, line);
; 354  : #else
; 355  : 	rez = Z_MallocAlign(size, tag, user, alignbits);

  00066	8b 45 18	 mov	 eax, DWORD PTR _alignbits$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d 14	 mov	 ecx, DWORD PTR _user$[ebp]
  0006d	51		 push	 ecx
  0006e	8b 55 10	 mov	 edx, DWORD PTR _tag$[ebp]
  00071	52		 push	 edx
  00072	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _Z_MallocAlign
  0007b	83 c4 10	 add	 esp, 16			; 00000010H
  0007e	89 45 fc	 mov	 DWORD PTR _rez$[ebp], eax

; 356  : #endif
; 357  : 
; 358  : 	if (size < block->realsize)

  00081	8b 45 f8	 mov	 eax, DWORD PTR _block$[ebp]
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00087	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0008a	73 08		 jae	 SHORT $LN5@Z_ReallocA

; 359  : 		copysize = size;

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0008f	89 45 f4	 mov	 DWORD PTR _copysize$[ebp], eax
  00092	eb 09		 jmp	 SHORT $LN6@Z_ReallocA
$LN5@Z_ReallocA:

; 360  : 	else
; 361  : 		copysize = block->realsize;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _block$[ebp]
  00097	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0009a	89 4d f4	 mov	 DWORD PTR _copysize$[ebp], ecx
$LN6@Z_ReallocA:

; 362  : 
; 363  : 	M_Memcpy(rez, ptr, copysize);

  0009d	8b 45 f4	 mov	 eax, DWORD PTR _copysize$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _rez$[ebp]
  000a8	52		 push	 edx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 364  : 
; 365  : #ifdef ZDEBUG
; 366  : 	Z_Free2(ptr, file, line);
; 367  : #else
; 368  : 	Z_Free(ptr);

  000b2	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _Z_Free
  000bb	83 c4 04	 add	 esp, 4

; 369  : #endif
; 370  : 
; 371  : 	// Need to set the user in case the old block had the same one, in
; 372  : 	// which case the Z_Free will just have NULLed it out.
; 373  : 	if (user)

  000be	83 7d 14 00	 cmp	 DWORD PTR _user$[ebp], 0
  000c2	74 08		 je	 SHORT $LN7@Z_ReallocA

; 374  : 		*((void**)user) = rez;

  000c4	8b 45 14	 mov	 eax, DWORD PTR _user$[ebp]
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _rez$[ebp]
  000ca	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Z_ReallocA:

; 375  : 
; 376  : 	if (size > copysize)

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  000cf	3b 45 f4	 cmp	 eax, DWORD PTR _copysize$[ebp]
  000d2	76 18		 jbe	 SHORT $LN8@Z_ReallocA

; 377  : 		memset((char*)rez+copysize, 0x00, size-copysize);

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  000d7	2b 45 f4	 sub	 eax, DWORD PTR _copysize$[ebp]
  000da	50		 push	 eax
  000db	6a 00		 push	 0
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _rez$[ebp]
  000e0	03 4d f4	 add	 ecx, DWORD PTR _copysize$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _memset
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@Z_ReallocA:

; 378  : 
; 379  : 	return rez;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _rez$[ebp]
$LN1@Z_ReallocA:

; 380  : }

  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
_Z_ReallocAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_CallocAlign
_TEXT	SEGMENT
_size$ = 8						; size = 4
_tag$ = 12						; size = 4
_user$ = 16						; size = 4
_alignbits$ = 20					; size = 4
_Z_CallocAlign PROC					; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 308  : #ifdef VALGRIND_MEMPOOL_ALLOC
; 309  : 	Z_calloc = true;
; 310  : #endif
; 311  : #ifdef ZDEBUG
; 312  : 	return memset(Z_Malloc2    (size, tag, user, alignbits, file, line), 0, size);
; 313  : #else
; 314  : 	return memset(Z_MallocAlign(size, tag, user, alignbits            ), 0, size);

  00009	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 14	 mov	 ecx, DWORD PTR _alignbits$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 10	 mov	 edx, DWORD PTR _user$[ebp]
  00016	52		 push	 edx
  00017	8b 45 0c	 mov	 eax, DWORD PTR _tag$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _Z_MallocAlign
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : #endif
; 316  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_Z_CallocAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_MallocAlign
_TEXT	SEGMENT
_blocksize$ = -28					; size = 4
_given$ = -24						; size = 4
_hdr$ = -20						; size = 4
_ptr$ = -16						; size = 4
_block$ = -12						; size = 4
_padsize$ = -8						; size = 4
_extrabytes$ = -4					; size = 4
_size$ = 8						; size = 4
_tag$ = 12						; size = 4
_user$ = 16						; size = 4
_alignbits$ = 20					; size = 4
_Z_MallocAlign PROC					; COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 233  : 	size_t extrabytes = (1<<alignbits) - 1;

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	8b 4d 14	 mov	 ecx, DWORD PTR _alignbits$[ebp]
  00011	d3 e0		 shl	 eax, cl
  00013	83 e8 01	 sub	 eax, 1
  00016	89 45 fc	 mov	 DWORD PTR _extrabytes$[ebp], eax

; 234  : 	size_t padsize = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _padsize$[ebp], 0

; 235  : 	memblock_t *block;
; 236  : 	void *ptr;
; 237  : 	memhdr_t *hdr;
; 238  : 	void *given;
; 239  : 	size_t blocksize = extrabytes + sizeof *hdr + size;

  00020	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _extrabytes$[ebp]
  00026	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0002a	89 55 e4	 mov	 DWORD PTR _blocksize$[ebp], edx

; 240  : 
; 241  : #ifdef ZDEBUG2
; 242  : 	CONS_Debug(DBG_MEMORY, "Z_Malloc %s:%d\n", file, line);
; 243  : #endif
; 244  : 
; 245  : 	block = xm(sizeof *block);

  0002d	6a 20		 push	 32			; 00000020H
  0002f	e8 00 00 00 00	 call	 _xm
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 f4	 mov	 DWORD PTR _block$[ebp], eax

; 246  : #ifdef HAVE_VALGRIND
; 247  : 	padsize += (1<<sizeof(size_t))*2;
; 248  : #endif
; 249  : 	ptr = xm(blocksize + padsize*2);

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _padsize$[ebp]
  0003d	8b 4d e4	 mov	 ecx, DWORD PTR _blocksize$[ebp]
  00040	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _xm
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 f0	 mov	 DWORD PTR _ptr$[ebp], eax

; 250  : 
; 251  : 	// This horrible calculation makes sure that "given" is aligned
; 252  : 	// properly.
; 253  : 	given = (void *)((size_t)((UINT8 *)ptr + extrabytes + sizeof *hdr + padsize/2)

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _ptr$[ebp]
  00052	03 45 fc	 add	 eax, DWORD PTR _extrabytes$[ebp]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _padsize$[ebp]
  00058	d1 e9		 shr	 ecx, 1
  0005a	8d 54 08 08	 lea	 edx, DWORD PTR [eax+ecx+8]
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _extrabytes$[ebp]
  00061	f7 d0		 not	 eax
  00063	23 d0		 and	 edx, eax
  00065	89 55 e8	 mov	 DWORD PTR _given$[ebp], edx

; 254  : 		& ~extrabytes);
; 255  : 
; 256  : 	// The mem header lives 'sizeof (memhdr_t)' bytes before given.
; 257  : 	hdr = (memhdr_t *)((UINT8 *)given - sizeof *hdr);

  00068	8b 45 e8	 mov	 eax, DWORD PTR _given$[ebp]
  0006b	83 e8 08	 sub	 eax, 8
  0006e	89 45 ec	 mov	 DWORD PTR _hdr$[ebp], eax

; 258  : 
; 259  : #ifdef VALGRIND_CREATE_MEMPOOL
; 260  : 	VALGRIND_CREATE_MEMPOOL(block, padsize, Z_calloc);
; 261  : 	Z_calloc = false;
; 262  : #endif
; 263  : #ifdef VALGRIND_MEMPOOL_ALLOC
; 264  : 	VALGRIND_MEMPOOL_ALLOC(block, hdr, size + sizeof *hdr);
; 265  : #endif
; 266  : 
; 267  : 	block->next = head.next;

  00071	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  00074	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR _head+24
  0007a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 268  : 	block->prev = &head;

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  00080	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET _head

; 269  : 	head.next = block;

  00087	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  0008a	a3 18 00 00 00	 mov	 DWORD PTR _head+24, eax

; 270  : 	block->next->prev = block;

  0008f	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  00092	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00095	8b 55 f4	 mov	 edx, DWORD PTR _block$[ebp]
  00098	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 271  : 
; 272  : 	block->real = ptr;

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  0009e	8b 4d f0	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx

; 273  : 	block->hdr = hdr;

  000a3	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _hdr$[ebp]
  000a9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 274  : 	block->tag = tag;

  000ac	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _tag$[ebp]
  000b2	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 275  : 	block->user = NULL;

  000b5	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  000b8	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 276  : #ifdef ZDEBUG
; 277  : 	block->ownerline = line;
; 278  : 	block->ownerfile = file;
; 279  : #endif
; 280  : 	block->size = blocksize;

  000bf	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  000c2	8b 4d e4	 mov	 ecx, DWORD PTR _blocksize$[ebp]
  000c5	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 281  : 	block->realsize = size;

  000c8	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  000ce	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 282  : 
; 283  : 	hdr->id = ZONEID;

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _hdr$[ebp]
  000d4	c7 40 04 3d d1
	41 a4		 mov	 DWORD PTR [eax+4], -1539190467 ; a441d13dH

; 284  : 	hdr->block = block;

  000db	8b 45 ec	 mov	 eax, DWORD PTR _hdr$[ebp]
  000de	8b 4d f4	 mov	 ecx, DWORD PTR _block$[ebp]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx

; 285  : 
; 286  : #ifdef VALGRIND_MAKE_MEM_NOACCESS
; 287  : 	VALGRIND_MAKE_MEM_NOACCESS(hdr, sizeof *hdr);
; 288  : #endif
; 289  : 
; 290  : 	if (user != NULL)

  000e3	83 7d 10 00	 cmp	 DWORD PTR _user$[ebp], 0
  000e7	74 13		 je	 SHORT $LN2@Z_MallocAl

; 291  : 	{
; 292  : 		block->user = user;

  000e9	8b 45 f4	 mov	 eax, DWORD PTR _block$[ebp]
  000ec	8b 4d 10	 mov	 ecx, DWORD PTR _user$[ebp]
  000ef	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 293  : 		*(void **)user = given;

  000f2	8b 45 10	 mov	 eax, DWORD PTR _user$[ebp]
  000f5	8b 4d e8	 mov	 ecx, DWORD PTR _given$[ebp]
  000f8	89 08		 mov	 DWORD PTR [eax], ecx

; 294  : 	}

  000fa	eb 17		 jmp	 SHORT $LN4@Z_MallocAl
$LN2@Z_MallocAl:

; 295  : 	else if (tag >= PU_PURGELEVEL)

  000fc	83 7d 0c 64	 cmp	 DWORD PTR _tag$[ebp], 100 ; 00000064H
  00100	7c 11		 jl	 SHORT $LN4@Z_MallocAl

; 296  : 		I_Error("Z_Malloc: attempted to allocate purgable block "

  00102	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00105	50		 push	 eax
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@HAMCMOPH@Z_Malloc?3?5attempted?5to?5allocate@
  0010b	e8 00 00 00 00	 call	 _I_Error
  00110	83 c4 08	 add	 esp, 8
$LN4@Z_MallocAl:

; 297  : 			"(size %"PRIdS") with no user", size);
; 298  : 
; 299  : 	return given;

  00113	8b 45 e8	 mov	 eax, DWORD PTR _given$[ebp]

; 300  : }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
_Z_MallocAlign ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_Free
_TEXT	SEGMENT
_block$ = -4						; size = 4
_ptr$ = 8						; size = 4
_Z_Free	PROC						; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 164  : 	memblock_t *block;
; 165  : 
; 166  : 	if (ptr == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN2@Z_Free

; 167  : 		return;

  0000f	eb 61		 jmp	 SHORT $LN1@Z_Free
$LN2@Z_Free:

; 168  : 
; 169  : #ifdef ZDEBUG2
; 170  : 	CONS_Printf("Z_Free %s:%d\n", file, line);
; 171  : #endif
; 172  : 
; 173  : #ifdef ZDEBUG
; 174  : 	block = Ptr2Memblock2(ptr, "Z_Free", file, line);
; 175  : #else
; 176  : 	block = Ptr2Memblock(ptr, "Z_Free");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_06FIPNHPIN@Z_Free@
  00016	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _Ptr2Memblock
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax

; 177  : #endif
; 178  : 
; 179  : #ifdef ZDEBUG
; 180  : 	// Write every Z_Free call to a debug file.
; 181  : 	DEBFILE(va("Z_Free at %s:%d\n", file, line));
; 182  : #endif
; 183  : 
; 184  : 	// TODO: if zdebugging, make sure no other block has a user
; 185  : 	// that is about to be freed.
; 186  : 
; 187  : 	// Clear the user's mark.
; 188  : 	if (block->user != NULL)

  00025	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00028	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002c	74 0c		 je	 SHORT $LN3@Z_Free

; 189  : 		*block->user = NULL;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00031	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN3@Z_Free:

; 190  : 
; 191  : 	// Free the memory and get rid of the block.
; 192  : 	free(block->real);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _free
  00045	83 c4 04	 add	 esp, 4

; 193  : 	block->prev->next = block->next;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0004b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  00051	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00054	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 194  : 	block->next->prev = block->prev;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0005a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _block$[ebp]
  00060	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00063	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 195  : 	free(block);

  00066	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _free
  0006f	83 c4 04	 add	 esp, 4
$LN1@Z_Free:

; 196  : #ifdef VALGRIND_DESTROY_MEMPOOL
; 197  : 	VALGRIND_DESTROY_MEMPOOL(block);
; 198  : #endif
; 199  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_Z_Free	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_SetUser2
_TEXT	SEGMENT
_hdr$ = -8						; size = 4
_block$ = -4						; size = 4
_ptr$ = 8						; size = 4
_newuser$ = 12						; size = 4
_Z_SetUser2 PROC					; COMDAT

; 670  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 671  : 	memblock_t *block;
; 672  : 	memhdr_t *hdr;
; 673  : 
; 674  : 	if (ptr == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN2@Z_SetUser2

; 675  : 		return;

  0000f	eb 3e		 jmp	 SHORT $LN1@Z_SetUser2
$LN2@Z_SetUser2:

; 676  : 
; 677  : 	hdr = (memhdr_t *)((UINT8 *)ptr - sizeof *hdr);

  00011	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00014	83 e8 08	 sub	 eax, 8
  00017	89 45 f8	 mov	 DWORD PTR _hdr$[ebp], eax

; 678  : 
; 679  : #ifdef VALGRIND_MAKE_MEM_DEFINED
; 680  : 	VALGRIND_MAKE_MEM_DEFINED(hdr, sizeof *hdr);
; 681  : #endif
; 682  : 
; 683  : #ifdef PARANOIA
; 684  : 	if (hdr->id != ZONEID) I_Error("Z_CT at %s:%d: wrong id", file, line);
; 685  : #endif
; 686  : 
; 687  : 	block = hdr->block;

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _hdr$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d fc	 mov	 DWORD PTR _block$[ebp], ecx

; 688  : 
; 689  : #ifdef VALGRIND_MAKE_MEM_NOACCESS
; 690  : 	VALGRIND_MAKE_MEM_NOACCESS(hdr, sizeof *hdr);
; 691  : #endif
; 692  : 
; 693  : 	if (block->tag >= PU_PURGELEVEL && newuser == NULL)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00025	83 78 0c 64	 cmp	 DWORD PTR [eax+12], 100	; 00000064H
  00029	7c 13		 jl	 SHORT $LN3@Z_SetUser2
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _newuser$[ebp], 0
  0002f	75 0d		 jne	 SHORT $LN3@Z_SetUser2

; 694  : 		I_Error("Internal memory management error: "

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@HFJCOGCH@Internal?5memory?5management?5erro@
  00036	e8 00 00 00 00	 call	 _I_Error
  0003b	83 c4 04	 add	 esp, 4
$LN3@Z_SetUser2:

; 695  : 			"tried to make block purgable but it has no owner");
; 696  : 
; 697  : 	block->user = (void*)newuser;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _newuser$[ebp]
  00044	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 698  : 	*newuser = ptr;

  00047	8b 45 0c	 mov	 eax, DWORD PTR _newuser$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0004d	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@Z_SetUser2:

; 699  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_Z_SetUser2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_ChangeTag2
_TEXT	SEGMENT
_hdr$ = -8						; size = 4
_block$ = -4						; size = 4
_ptr$ = 8						; size = 4
_tag$ = 12						; size = 4
_Z_ChangeTag2 PROC					; COMDAT

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 533  : 	memblock_t *block;
; 534  : 	memhdr_t *hdr;
; 535  : 
; 536  : 	if (ptr == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _ptr$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN2@Z_ChangeTa

; 537  : 		return;

  0000f	eb 36		 jmp	 SHORT $LN1@Z_ChangeTa
$LN2@Z_ChangeTa:

; 538  : 
; 539  : 	hdr = (memhdr_t *)((UINT8 *)ptr - sizeof *hdr);

  00011	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00014	83 e8 08	 sub	 eax, 8
  00017	89 45 f8	 mov	 DWORD PTR _hdr$[ebp], eax

; 540  : 
; 541  : #ifdef VALGRIND_MAKE_MEM_DEFINED
; 542  : 	VALGRIND_MAKE_MEM_DEFINED(hdr, sizeof *hdr);
; 543  : #endif
; 544  : 
; 545  : #ifdef VALGRIND_MEMPOOL_EXISTS
; 546  : 	if (!VALGRIND_MEMPOOL_EXISTS(hdr->block))
; 547  : 	{
; 548  : #ifdef PARANOIA
; 549  : 		I_Error("Z_CT at %s:%d: bad memblock", file, line);
; 550  : #else
; 551  : 		I_Error("Z_CT: bad memblock");
; 552  : #endif
; 553  : 	}
; 554  : #endif
; 555  : #ifdef PARANOIA
; 556  : 	if (hdr->id != ZONEID) I_Error("Z_CT at %s:%d: wrong id", file, line);
; 557  : #endif
; 558  : 
; 559  : 	block = hdr->block;

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _hdr$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d fc	 mov	 DWORD PTR _block$[ebp], ecx

; 560  : 
; 561  : #ifdef VALGRIND_MAKE_MEM_NOACCESS
; 562  : 	VALGRIND_MAKE_MEM_NOACCESS(hdr, sizeof *hdr);
; 563  : #endif
; 564  : 
; 565  : 	if (tag >= PU_PURGELEVEL && block->user == NULL)

  00022	83 7d 0c 64	 cmp	 DWORD PTR _tag$[ebp], 100 ; 00000064H
  00026	7c 16		 jl	 SHORT $LN3@Z_ChangeTa
  00028	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0002b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002f	75 0d		 jne	 SHORT $LN3@Z_ChangeTa

; 566  : 		I_Error("Internal memory management error: "

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@HFJCOGCH@Internal?5memory?5management?5erro@
  00036	e8 00 00 00 00	 call	 _I_Error
  0003b	83 c4 04	 add	 esp, 4
$LN3@Z_ChangeTa:

; 567  : 			"tried to make block purgable but it has no owner");
; 568  : 
; 569  : 	block->tag = tag;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _tag$[ebp]
  00044	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN1@Z_ChangeTa:

; 570  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_Z_ChangeTag2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_CheckHeap
_TEXT	SEGMENT
_given$ = -16						; size = 4
_blocknumon$ = -12					; size = 4
_hdr$ = -8						; size = 4
_block$ = -4						; size = 4
_i$ = 8							; size = 4
_Z_CheckHeap PROC					; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 429  : 	memblock_t *block;
; 430  : 	memhdr_t *hdr;
; 431  : 	UINT32 blocknumon = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blocknumon$[ebp], 0

; 432  : 	void *given;
; 433  : 
; 434  : 	for (block = head.next; block != &head; block = block->next)

  00010	a1 18 00 00 00	 mov	 eax, DWORD PTR _head+24
  00015	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax
  00018	eb 09		 jmp	 SHORT $LN4@Z_CheckHea
$LN2@Z_CheckHea:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0001d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00020	89 4d fc	 mov	 DWORD PTR _block$[ebp], ecx
$LN4@Z_CheckHea:
  00023	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _block$[ebp], OFFSET _head
  0002a	0f 84 d1 00 00
	00		 je	 $LN3@Z_CheckHea

; 435  : 	{
; 436  : 		blocknumon++;

  00030	8b 45 f4	 mov	 eax, DWORD PTR _blocknumon$[ebp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 f4	 mov	 DWORD PTR _blocknumon$[ebp], eax

; 437  : 		hdr = block->hdr;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	89 4d f8	 mov	 DWORD PTR _hdr$[ebp], ecx

; 438  : 		given = (UINT8 *)hdr + sizeof *hdr;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _hdr$[ebp]
  00045	83 c0 08	 add	 eax, 8
  00048	89 45 f0	 mov	 DWORD PTR _given$[ebp], eax

; 439  : #ifdef ZDEBUG2
; 440  : 		CONS_Debug(DBG_MEMORY, "block %u owned by %s:%d\n",
; 441  : 			blocknumon, block->ownerfile, block->ownerline);
; 442  : #endif
; 443  : #ifdef VALGRIND_MEMPOOL_EXISTS
; 444  : 		if (!VALGRIND_MEMPOOL_EXISTS(block))
; 445  : 		{
; 446  : 			I_Error("Z_CheckHeap %d: block %u"
; 447  : #ifdef ZDEBUG
; 448  : 				"(owned by %s:%d)"
; 449  : #endif
; 450  : 				" should not exist", i, blocknumon
; 451  : #ifdef ZDEBUG
; 452  : 				, block->ownerfile, block->ownerline
; 453  : #endif
; 454  : 			        );
; 455  : 		}
; 456  : #endif
; 457  : 		if (block->user != NULL && *(block->user) != given)

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0004e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00052	74 22		 je	 SHORT $LN5@Z_CheckHea
  00054	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	3b 55 f0	 cmp	 edx, DWORD PTR _given$[ebp]
  0005f	74 15		 je	 SHORT $LN5@Z_CheckHea

; 458  : 		{
; 459  : 			I_Error("Z_CheckHeap %d: block %u"

  00061	8b 45 f4	 mov	 eax, DWORD PTR _blocknumon$[ebp]
  00064	50		 push	 eax
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00068	51		 push	 ecx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LMFNDHIH@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@
  0006e	e8 00 00 00 00	 call	 _I_Error
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@Z_CheckHea:

; 460  : #ifdef ZDEBUG
; 461  : 				"(owned by %s:%d)"
; 462  : #endif
; 463  : 				" doesn't have a proper user", i, blocknumon
; 464  : #ifdef ZDEBUG
; 465  : 				, block->ownerfile, block->ownerline
; 466  : #endif
; 467  : 			       );
; 468  : 		}
; 469  : 		if (block->next->prev != block)

  00076	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00079	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0007c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0007f	3b 55 fc	 cmp	 edx, DWORD PTR _block$[ebp]
  00082	74 15		 je	 SHORT $LN6@Z_CheckHea

; 470  : 		{
; 471  : 			I_Error("Z_CheckHeap %d: block %u"

  00084	8b 45 f4	 mov	 eax, DWORD PTR _blocknumon$[ebp]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0008b	51		 push	 ecx
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JBIAPKCO@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@
  00091	e8 00 00 00 00	 call	 _I_Error
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Z_CheckHea:

; 472  : #ifdef ZDEBUG
; 473  : 				"(owned by %s:%d)"
; 474  : #endif
; 475  : 				" lacks proper backlink", i, blocknumon
; 476  : #ifdef ZDEBUG
; 477  : 				, block->ownerfile, block->ownerline
; 478  : #endif
; 479  : 			       );
; 480  : 		}
; 481  : 		if (block->prev->next != block)

  00099	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0009c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0009f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000a2	3b 55 fc	 cmp	 edx, DWORD PTR _block$[ebp]
  000a5	74 15		 je	 SHORT $LN7@Z_CheckHea

; 482  : 		{
; 483  : 			I_Error("Z_CheckHeap %d: block %u"

  000a7	8b 45 f4	 mov	 eax, DWORD PTR _blocknumon$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  000ae	51		 push	 ecx
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PAIKMPDP@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5lacks?5@
  000b4	e8 00 00 00 00	 call	 _I_Error
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Z_CheckHea:

; 484  : #ifdef ZDEBUG
; 485  : 				"(owned by %s:%d)"
; 486  : #endif
; 487  : 				" lacks proper forward link", i, blocknumon
; 488  : #ifdef ZDEBUG
; 489  : 				, block->ownerfile, block->ownerline
; 490  : #endif
; 491  : 			       );
; 492  : 		}
; 493  : #ifdef VALGRIND_MAKE_MEM_DEFINED
; 494  : 		VALGRIND_MAKE_MEM_DEFINED(hdr, sizeof *hdr);
; 495  : #endif
; 496  : 		if (hdr->block != block)

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _hdr$[ebp]
  000bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c1	3b 4d fc	 cmp	 ecx, DWORD PTR _block$[ebp]
  000c4	74 15		 je	 SHORT $LN8@Z_CheckHea

; 497  : 		{
; 498  : 			I_Error("Z_CheckHeap %d: block %u"

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _blocknumon$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  000cd	51		 push	 ecx
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@KLEMHKHC@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5doesn?8@
  000d3	e8 00 00 00 00	 call	 _I_Error
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@Z_CheckHea:

; 499  : #ifdef ZDEBUG
; 500  : 				"(owned by %s:%d)"
; 501  : #endif
; 502  : 				" doesn't have linkback from allocated memory",
; 503  : 				i, blocknumon
; 504  : #ifdef ZDEBUG
; 505  : 				, block->ownerfile, block->ownerline
; 506  : #endif
; 507  : 					);
; 508  : 		}
; 509  : 		if (hdr->id != ZONEID)

  000db	8b 45 f8	 mov	 eax, DWORD PTR _hdr$[ebp]
  000de	81 78 04 3d d1
	41 a4		 cmp	 DWORD PTR [eax+4], -1539190467 ; a441d13dH
  000e5	74 15		 je	 SHORT $LN9@Z_CheckHea

; 510  : 		{
; 511  : 			I_Error("Z_CheckHeap %d: block %u"

  000e7	8b 45 f4	 mov	 eax, DWORD PTR _blocknumon$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  000ee	51		 push	 ecx
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BHMFGNNL@Z_CheckHeap?5?$CFd?3?5block?5?$CFu?5have?5t@
  000f4	e8 00 00 00 00	 call	 _I_Error
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@Z_CheckHea:

; 512  : #ifdef ZDEBUG
; 513  : 				"(owned by %s:%d)"
; 514  : #endif
; 515  : 				" have the wrong ID", i, blocknumon
; 516  : #ifdef ZDEBUG
; 517  : 				, block->ownerfile, block->ownerline
; 518  : #endif
; 519  : 					);
; 520  : 		}
; 521  : #ifdef VALGRIND_MAKE_MEM_NOACCESS
; 522  : 	VALGRIND_MAKE_MEM_NOACCESS(hdr, sizeof *hdr);
; 523  : #endif
; 524  : 	}

  000fc	e9 19 ff ff ff	 jmp	 $LN2@Z_CheckHea
$LN3@Z_CheckHea:

; 525  : }

  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_Z_CheckHeap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_CheckMemCleanup
_TEXT	SEGMENT
tv66 = -68						; size = 4
_Z_CheckMemCleanup PROC					; COMDAT

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 414  : 	if (nextcleanup-- == 0)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _nextcleanup
  0000e	89 45 bc	 mov	 DWORD PTR tv66[ebp], eax
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nextcleanup
  00017	83 e9 01	 sub	 ecx, 1
  0001a	89 0d 00 00 00
	00		 mov	 DWORD PTR _nextcleanup, ecx
  00020	83 7d bc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00024	75 19		 jne	 SHORT $LN2@Z_CheckMem

; 415  : 	{
; 416  : 		nextcleanup = CLEANUPCOUNT;

  00026	c7 05 00 00 00
	00 d0 07 00 00	 mov	 DWORD PTR _nextcleanup, 2000 ; 000007d0H

; 417  : 		Z_FreeTags(PU_PURGELEVEL, INT32_MAX);

  00030	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00035	6a 64		 push	 100			; 00000064H
  00037	e8 00 00 00 00	 call	 _Z_FreeTags
  0003c	83 c4 08	 add	 esp, 8
$LN2@Z_CheckMem:

; 418  : 	}
; 419  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_Z_CheckMemCleanup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_FreeTags
_TEXT	SEGMENT
_next$ = -8						; size = 4
_block$ = -4						; size = 4
_lowtag$ = 8						; size = 4
_hightag$ = 12						; size = 4
_Z_FreeTags PROC					; COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 384  : 	memblock_t *block, *next;
; 385  : 
; 386  : 	Z_CheckHeap(420);

  00009	68 a4 01 00 00	 push	 420			; 000001a4H
  0000e	e8 00 00 00 00	 call	 _Z_CheckHeap
  00013	83 c4 04	 add	 esp, 4

; 387  : 	for (block = head.next; block != &head; block = next)

  00016	a1 18 00 00 00	 mov	 eax, DWORD PTR _head+24
  0001b	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax
  0001e	eb 06		 jmp	 SHORT $LN4@Z_FreeTags
$LN2@Z_FreeTags:
  00020	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _block$[ebp], eax
$LN4@Z_FreeTags:
  00026	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _block$[ebp], OFFSET _head
  0002d	74 33		 je	 SHORT $LN3@Z_FreeTags

; 388  : 	{
; 389  : 		next = block->next; // get link before freeing

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00032	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00035	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 390  : 
; 391  : 		if (block->tag >= lowtag && block->tag <= hightag)

  00038	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  0003b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003e	3b 4d 08	 cmp	 ecx, DWORD PTR _lowtag$[ebp]
  00041	7c 1d		 jl	 SHORT $LN5@Z_FreeTags
  00043	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00046	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00049	3b 4d 0c	 cmp	 ecx, DWORD PTR _hightag$[ebp]
  0004c	7f 12		 jg	 SHORT $LN5@Z_FreeTags

; 392  : 			Z_Free((UINT8 *)block->hdr + sizeof *block->hdr);

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _block$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	83 c1 08	 add	 ecx, 8
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 _Z_Free
  0005d	83 c4 04	 add	 esp, 4
$LN5@Z_FreeTags:

; 393  : 	}

  00060	eb be		 jmp	 SHORT $LN2@Z_FreeTags
$LN3@Z_FreeTags:

; 394  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_Z_FreeTags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\z_zone.c
;	COMDAT _Z_Init
_TEXT	SEGMENT
_memfree$ = -8						; size = 4
_total$ = -4						; size = 4
_Z_Init	PROC						; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 141  : 	UINT32 total, memfree;
; 142  : 
; 143  : 	memset(&head, 0x00, sizeof(head));

  00009	6a 20		 push	 32			; 00000020H
  0000b	6a 00		 push	 0
  0000d	68 00 00 00 00	 push	 OFFSET _head
  00012	e8 00 00 00 00	 call	 _memset
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 
; 145  : 	head.next = head.prev = &head;

  0001a	c7 05 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _head+28, OFFSET _head
  00024	a1 1c 00 00 00	 mov	 eax, DWORD PTR _head+28
  00029	a3 18 00 00 00	 mov	 DWORD PTR _head+24, eax

; 146  : 
; 147  : 	memfree = I_GetFreeMem(&total)>>20;

  0002e	8d 45 fc	 lea	 eax, DWORD PTR _total$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _I_GetFreeMem
  00037	83 c4 04	 add	 esp, 4
  0003a	c1 e8 14	 shr	 eax, 20			; 00000014H
  0003d	89 45 f8	 mov	 DWORD PTR _memfree$[ebp], eax

; 148  : 	CONS_Printf("system memory %uMB free %uMB\n", total>>20, memfree);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _memfree$[ebp]
  00043	50		 push	 eax
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _total$[ebp]
  00047	c1 e9 14	 shr	 ecx, 20			; 00000014H
  0004a	51		 push	 ecx
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@EDNAGBNJ@system?5memory?5?$CFuMB?5free?5?$CFuMB?6@
  00050	e8 00 00 00 00	 call	 _CONS_Printf
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 
; 150  : 	// Note: This allocates memory. Watch out.
; 151  : 	COM_AddCommand("memfree", Command_Memfree_f);

  00058	68 00 00 00 00	 push	 OFFSET _Command_Memfree_f
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_07DNAFJGOJ@memfree@
  00062	e8 00 00 00 00	 call	 _COM_AddCommand
  00067	83 c4 08	 add	 esp, 8

; 152  : 
; 153  : #ifdef ZDEBUG
; 154  : 	COM_AddCommand("memdump", Command_Memdump_f);
; 155  : #endif
; 156  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_Z_Init	ENDP
_TEXT	ENDS
END
