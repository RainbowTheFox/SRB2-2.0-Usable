; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\win_cd.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_cdaudio_started
PUBLIC	_cd_volume
PUBLIC	_cdUpdate
PUBLIC	??_C@_09IFJAEMNF@cd_volume@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31@				; `string'
PUBLIC	??_C@_09LKAEPFPA@cd_update@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
EXTRN	_soundvolume_cons_t:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_cdaudio_started DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKAEPFPA@cd_update@
CONST	SEGMENT
??_C@_09LKAEPFPA@cd_update@ DB 'cd_update', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31@
CONST	SEGMENT
??_C@_02OAMOHKJG@31@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFJAEMNF@cd_volume@
CONST	SEGMENT
??_C@_09IFJAEMNF@cd_volume@ DB 'cd_volume', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_cd_volume DD	FLAT:??_C@_09IFJAEMNF@cd_volume@
	DD	FLAT:??_C@_02OAMOHKJG@31@
	DD	01H
	DD	FLAT:_soundvolume_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cdUpdate DD	FLAT:??_C@_09LKAEPFPA@cd_update@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_I_InitCD
PUBLIC	_I_StopCD
PUBLIC	_I_ResumeCD
PUBLIC	_I_ShutdownCD
PUBLIC	_I_UpdateCD
PUBLIC	_I_PlayCD
PUBLIC	_I_SetVolumeCD
PUBLIC	??_C@_0BP@BMEJADJN@MCI?5CD?5Audio?5Unknow?5Error?5?$CD?$CFd?6@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d@	; `string'
PUBLIC	??_C@_08BDBEPDAI@?$CF2d?3?$CF02d@		; `string'
PUBLIC	??_C@_0GB@HLMIOJMK@cd?5?$FLon?$FN?5?$FLoff?$FN?5?$FLremap?$FN?5?$FLreset?$FN?5?$FL@ ; `string'
PUBLIC	??_C@_02LIELOMNJ@on@				; `string'
PUBLIC	??_C@_03MCADLMAF@off@				; `string'
PUBLIC	??_C@_05PGGDPNJE@remap@				; `string'
PUBLIC	??_C@_0CE@DBFDGMKA@CD?5tracks?5remapped?5in?5that?5orde@ ; `string'
PUBLIC	??_C@_0N@JCCNDNIC@?5?$CF2d?5?9?$DO?5?$CF2d?6@	; `string'
PUBLIC	??_C@_05CFMALAOA@reset@				; `string'
PUBLIC	??_C@_0BC@NJFEMFBD@CD?5is?5not?5ready?4?6@	; `string'
PUBLIC	??_C@_04NIDJFNBE@info@				; `string'
PUBLIC	??_C@_0BB@PGNAFNE@No?5audio?5tracks?6@		; `string'
PUBLIC	??_C@_05KNIAAKIP@audio@				; `string'
PUBLIC	??_C@_05EBMGPPJD@data?5@			; `string'
PUBLIC	??_C@_02JGLONGCB@?$AC?5@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0P@PBIEADKN@?$CFs?$CF2d?4?5?$CFs?5?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BC@MEAJJGDM@?$ACTotal?5time?5?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_07EOMMFHON@looping@			; `string'
PUBLIC	??_C@_07GDCKGKBF@playing@			; `string'
PUBLIC	??_C@_0P@GIBGHIDE@?$CFs?5track?5?3?5?$CFd?6@	; `string'
PUBLIC	??_C@_04GBHMDDO@play@				; `string'
PUBLIC	??_C@_04PEGFANN@stop@				; `string'
PUBLIC	??_C@_04GKOOIABA@loop@				; `string'
PUBLIC	??_C@_06PLELHCEK@resume@			; `string'
PUBLIC	??_C@_0BJ@HBFNPJAI@cd?5command?5?8?$CFs?8?5unknown?6@ ; `string'
PUBLIC	??_C@_0BA@GNFIIKPA@I_ShutdownCD?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0BM@GHADCGBE@I_InitCD?3?5CD?5Audio?5started?6@ ; `string'
PUBLIC	??_C@_0BN@CMFOHIJM@?$ACI_InitCD?3?5no?5CD?5in?5player?4?6@ ; `string'
PUBLIC	??_C@_02ELLOPNDH@cd@				; `string'
EXTRN	_strncmp:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__mciSendCommandA@16:PROC
EXTRN	__imp__mciGetErrorStringA@12:PROC
EXTRN	_atoi:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_COM_AddCommand:PROC
EXTRN	_COM_Argc:PROC
EXTRN	_COM_Argv:PROC
EXTRN	_I_StopSong:PROC
EXTRN	_I_AddExitFunc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_hWndMain:DWORD
EXTRN	_cv_digmusicvolume:BYTE
EXTRN	_cv_midimusicvolume:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

_m_nTracks DB	0ff0H DUP (?)
_m_nTracksCount DD 01H DUP (?)
_m_MCIStatus DB	010H DUP (?)
_m_MCIOpen DB	014H DUP (?)
_cdPlaying DD	01H DUP (?)
_cdPlayTrack DD	01H DUP (?)
_cdLooping DD	01H DUP (?)
_cdRemap DB	0ffH DUP (?)
	ALIGN	4

_cdValid DD	01H DUP (?)
_wasPlaying DD	01H DUP (?)
?s@?1??hms@@9@9 DB 09H DUP (?)				; `hms'::`2'::s
_BSS	ENDS
;	COMDAT ??_C@_02ELLOPNDH@cd@
CONST	SEGMENT
??_C@_02ELLOPNDH@cd@ DB 'cd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CMFOHIJM@?$ACI_InitCD?3?5no?5CD?5in?5player?4?6@
CONST	SEGMENT
??_C@_0BN@CMFOHIJM@?$ACI_InitCD?3?5no?5CD?5in?5player?4?6@ DB 02H, 'I_Ini'
	DB	'tCD: no CD in player.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GHADCGBE@I_InitCD?3?5CD?5Audio?5started?6@
CONST	SEGMENT
??_C@_0BM@GHADCGBE@I_InitCD?3?5CD?5Audio?5started?6@ DB 'I_InitCD: CD Aud'
	DB	'io started', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNFIIKPA@I_ShutdownCD?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0BA@GNFIIKPA@I_ShutdownCD?$CI?$CJ?6@ DB 'I_ShutdownCD()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HBFNPJAI@cd?5command?5?8?$CFs?8?5unknown?6@
CONST	SEGMENT
??_C@_0BJ@HBFNPJAI@cd?5command?5?8?$CFs?8?5unknown?6@ DB 'cd command ''%s'
	DB	''' unknown', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PLELHCEK@resume@
CONST	SEGMENT
??_C@_06PLELHCEK@resume@ DB 'resume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKOOIABA@loop@
CONST	SEGMENT
??_C@_04GKOOIABA@loop@ DB 'loop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PEGFANN@stop@
CONST	SEGMENT
??_C@_04PEGFANN@stop@ DB 'stop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBHMDDO@play@
CONST	SEGMENT
??_C@_04GBHMDDO@play@ DB 'play', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GIBGHIDE@?$CFs?5track?5?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0P@GIBGHIDE@?$CFs?5track?5?3?5?$CFd?6@ DB '%s track : %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GDCKGKBF@playing@
CONST	SEGMENT
??_C@_07GDCKGKBF@playing@ DB 'playing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOMMFHON@looping@
CONST	SEGMENT
??_C@_07EOMMFHON@looping@ DB 'looping', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEAJJGDM@?$ACTotal?5time?5?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@MEAJJGDM@?$ACTotal?5time?5?3?5?$CFs?6@ DB 02H, 'Total time : %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PBIEADKN@?$CFs?$CF2d?4?5?$CFs?5?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@PBIEADKN@?$CFs?$CF2d?4?5?$CFs?5?5?$CFs?6@ DB '%s%2d. %s  %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JGLONGCB@?$AC?5@
CONST	SEGMENT
??_C@_02JGLONGCB@?$AC?5@ DB 02H, ' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBMGPPJD@data?5@
CONST	SEGMENT
??_C@_05EBMGPPJD@data?5@ DB 'data ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNIAAKIP@audio@
CONST	SEGMENT
??_C@_05KNIAAKIP@audio@ DB 'audio', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PGNAFNE@No?5audio?5tracks?6@
CONST	SEGMENT
??_C@_0BB@PGNAFNE@No?5audio?5tracks?6@ DB 'No audio tracks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIDJFNBE@info@
CONST	SEGMENT
??_C@_04NIDJFNBE@info@ DB 'info', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NJFEMFBD@CD?5is?5not?5ready?4?6@
CONST	SEGMENT
??_C@_0BC@NJFEMFBD@CD?5is?5not?5ready?4?6@ DB 'CD is not ready.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFMALAOA@reset@
CONST	SEGMENT
??_C@_05CFMALAOA@reset@ DB 'reset', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JCCNDNIC@?5?$CF2d?5?9?$DO?5?$CF2d?6@
CONST	SEGMENT
??_C@_0N@JCCNDNIC@?5?$CF2d?5?9?$DO?5?$CF2d?6@ DB ' %2d -> %2d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DBFDGMKA@CD?5tracks?5remapped?5in?5that?5orde@
CONST	SEGMENT
??_C@_0CE@DBFDGMKA@CD?5tracks?5remapped?5in?5that?5orde@ DB 'CD tracks re'
	DB	'mapped in that order :', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGGDPNJE@remap@
CONST	SEGMENT
??_C@_05PGGDPNJE@remap@ DB 'remap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off@
CONST	SEGMENT
??_C@_03MCADLMAF@off@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on@
CONST	SEGMENT
??_C@_02LIELOMNJ@on@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@HLMIOJMK@cd?5?$FLon?$FN?5?$FLoff?$FN?5?$FLremap?$FN?5?$FLreset?$FN?5?$FL@
CONST	SEGMENT
??_C@_0GB@HLMIOJMK@cd?5?$FLon?$FN?5?$FLoff?$FN?5?$FLremap?$FN?5?$FLreset?$FN?5?$FL@ DB 'c'
	DB	'd [on] [off] [remap] [reset] [open]', 0aH, '   [info] [play <'
	DB	'track>] [loop <track>]', 0aH, '   [stop] [resume]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BDBEPDAI@?$CF2d?3?$CF02d@
CONST	SEGMENT
??_C@_08BDBEPDAI@?$CF2d?3?$CF02d@ DB '%2d:%02d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d@
CONST	SEGMENT
??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d@ DB '%d:%02d:%02d', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_cdEnabled DD	01H
_DATA	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BMEJADJN@MCI?5CD?5Audio?5Unknow?5Error?5?$CD?$CFd?6@
CONST	SEGMENT
??_C@_0BP@BMEJADJN@MCI?5CD?5Audio?5Unknow?5Error?5?$CD?$CFd?6@ DB 'MCI CD'
	DB	' Audio Unknow Error #%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	060H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0146H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	016eH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _hms
_TEXT	SEGMENT
_minutes$ = -8						; size = 4
_hours$ = -4						; size = 4
_seconds$ = 8						; size = 4
_hms	PROC						; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 174  : 	UINT hours, minutes;
; 175  : 	static CHAR s[9];
; 176  : 
; 177  : 	minutes = seconds / 60;

  00009	8b 45 08	 mov	 eax, DWORD PTR _seconds$[ebp]
  0000c	33 d2		 xor	 edx, edx
  0000e	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00013	f7 f1		 div	 ecx
  00015	89 45 f8	 mov	 DWORD PTR _minutes$[ebp], eax

; 178  : 	seconds %= 60;

  00018	8b 45 08	 mov	 eax, DWORD PTR _seconds$[ebp]
  0001b	33 d2		 xor	 edx, edx
  0001d	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00022	f7 f1		 div	 ecx
  00024	89 55 08	 mov	 DWORD PTR _seconds$[ebp], edx

; 179  : 	hours = minutes / 60;

  00027	8b 45 f8	 mov	 eax, DWORD PTR _minutes$[ebp]
  0002a	33 d2		 xor	 edx, edx
  0002c	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00031	f7 f1		 div	 ecx
  00033	89 45 fc	 mov	 DWORD PTR _hours$[ebp], eax

; 180  : 	minutes %= 60;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _minutes$[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00040	f7 f1		 div	 ecx
  00042	89 55 f8	 mov	 DWORD PTR _minutes$[ebp], edx

; 181  : 	if (hours > 0)

  00045	83 7d fc 00	 cmp	 DWORD PTR _hours$[ebp], 0
  00049	76 20		 jbe	 SHORT $LN2@hms

; 182  : 		sprintf (s, "%d:%02d:%02d", hours, minutes, seconds);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _seconds$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _minutes$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 fc	 mov	 edx, DWORD PTR _hours$[ebp]
  00056	52		 push	 edx
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d@
  0005c	68 00 00 00 00	 push	 OFFSET ?s@?1??hms@@9@9
  00061	e8 00 00 00 00	 call	 _sprintf
  00066	83 c4 14	 add	 esp, 20			; 00000014H
  00069	eb 1a		 jmp	 SHORT $LN3@hms
$LN2@hms:

; 183  : 	else
; 184  : 		sprintf (s, "%2d:%02d", minutes, seconds);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _seconds$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _minutes$[ebp]
  00072	51		 push	 ecx
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_08BDBEPDAI@?$CF2d?3?$CF02d@
  00078	68 00 00 00 00	 push	 OFFSET ?s@?1??hms@@9@9
  0007d	e8 00 00 00 00	 call	 _sprintf
  00082	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@hms:

; 185  : 	return s;

  00085	b8 00 00 00 00	 mov	 eax, OFFSET ?s@?1??hms@@9@9

; 186  : }

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_hms	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _CD_TotalTime
_TEXT	SEGMENT
_nTrack$ = -8						; size = 4
_nTotalLength$ = -4					; size = 4
_CD_TotalTime PROC					; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 136  : 	UINT nTotalLength = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nTotalLength$[ebp], 0

; 137  : 	INT nTrack;
; 138  : 	for (nTrack = 0; nTrack < m_nTracksCount; nTrack++)

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nTrack$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@CD_TotalTi
$LN2@CD_TotalTi:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _nTrack$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _nTrack$[ebp], eax
$LN4@CD_TotalTi:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _nTrack$[ebp]
  00025	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _m_nTracksCount
  0002b	7d 23		 jge	 SHORT $LN3@CD_TotalTi

; 139  : 	{
; 140  : 		if (m_nTracks[nTrack].IsAudio)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _nTrack$[ebp]
  00030	c1 e0 04	 shl	 eax, 4
  00033	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _m_nTracks[eax], 0
  0003a	74 12		 je	 SHORT $LN5@CD_TotalTi

; 141  : 			nTotalLength += m_nTracks[nTrack].Length;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _nTrack$[ebp]
  0003f	c1 e0 04	 shl	 eax, 4
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _nTotalLength$[ebp]
  00045	03 88 0c 00 00
	00		 add	 ecx, DWORD PTR _m_nTracks[eax+12]
  0004b	89 4d fc	 mov	 DWORD PTR _nTotalLength$[ebp], ecx
$LN5@CD_TotalTi:

; 142  : 	}

  0004e	eb c9		 jmp	 SHORT $LN2@CD_TotalTi
$LN3@CD_TotalTi:

; 143  : 	return nTotalLength;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _nTotalLength$[ebp]

; 144  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_CD_TotalTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _CD_ReadTrackInfo
_TEXT	SEGMENT
tv135 = -80						; size = 4
_iErr$ = -12						; size = 4
_i$ = -8						; size = 4
_nTrackLength$ = -4					; size = 4
_CD_ReadTrackInfo PROC					; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 86   : 	UINT     nTrackLength;
; 87   : 	INT      i;
; 88   : 	MCIERROR iErr;
; 89   : 
; 90   : 	m_nTracksCount = 0;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_nTracksCount, 0

; 91   : 
; 92   : 	m_MCIStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

  00013	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR _m_MCIStatus+8, 3

; 93   : 	iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_STATUS, MCI_STATUS_ITEM|MCI_WAIT, (DWORD_PTR)&m_MCIStatus);

  0001d	68 00 00 00 00	 push	 OFFSET _m_MCIStatus
  00022	68 02 01 00 00	 push	 258			; 00000102H
  00027	68 14 08 00 00	 push	 2068			; 00000814H
  0002c	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00038	89 45 f4	 mov	 DWORD PTR _iErr$[ebp], eax

; 94   : 	if (iErr)

  0003b	83 7d f4 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  0003f	74 13		 je	 SHORT $LN5@CD_ReadTra

; 95   : 	{
; 96   : 		MCIErrorMessageBox (iErr);

  00041	8b 45 f4	 mov	 eax, DWORD PTR _iErr$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  0004a	83 c4 04	 add	 esp, 4

; 97   : 		return FALSE;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 2b 01 00 00	 jmp	 $LN1@CD_ReadTra
$LN5@CD_ReadTra:

; 98   : 	}
; 99   : 	m_nTracksCount = (int)m_MCIStatus.dwReturn;

  00054	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIStatus+4
  00059	a3 00 00 00 00	 mov	 DWORD PTR _m_nTracksCount, eax

; 100  : 	if (m_nTracksCount > MAX_CD_TRACKS)

  0005e	81 3d 00 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR _m_nTracksCount, 255 ; 000000ffH
  00068	7e 0a		 jle	 SHORT $LN6@CD_ReadTra

; 101  : 		m_nTracksCount = MAX_CD_TRACKS;

  0006a	c7 05 00 00 00
	00 ff 00 00 00	 mov	 DWORD PTR _m_nTracksCount, 255 ; 000000ffH
$LN6@CD_ReadTra:

; 102  : 
; 103  : 	for (i = 0; i < m_nTracksCount; i++)

  00074	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007b	eb 09		 jmp	 SHORT $LN4@CD_ReadTra
$LN2@CD_ReadTra:
  0007d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CD_ReadTra:
  00086	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00089	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _m_nTracksCount
  0008f	0f 8d e5 00 00
	00		 jge	 $LN3@CD_ReadTra

; 104  : 	{
; 105  : 		m_MCIStatus.dwTrack = (DWORD)(i+1);

  00095	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	a3 0c 00 00 00	 mov	 DWORD PTR _m_MCIStatus+12, eax

; 106  : 		m_MCIStatus.dwItem = MCI_STATUS_LENGTH;

  000a0	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_MCIStatus+8, 1

; 107  : 		iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_STATUS, MCI_TRACK|MCI_STATUS_ITEM|MCI_WAIT, (DWORD_PTR)&m_MCIStatus);

  000aa	68 00 00 00 00	 push	 OFFSET _m_MCIStatus
  000af	68 12 01 00 00	 push	 274			; 00000112H
  000b4	68 14 08 00 00	 push	 2068			; 00000814H
  000b9	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  000be	50		 push	 eax
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  000c5	89 45 f4	 mov	 DWORD PTR _iErr$[ebp], eax

; 108  : 		if (iErr)

  000c8	83 7d f4 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  000cc	74 13		 je	 SHORT $LN7@CD_ReadTra

; 109  : 		{
; 110  : 			MCIErrorMessageBox (iErr);

  000ce	8b 45 f4	 mov	 eax, DWORD PTR _iErr$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  000d7	83 c4 04	 add	 esp, 4

; 111  : 			return FALSE;

  000da	33 c0		 xor	 eax, eax
  000dc	e9 9e 00 00 00	 jmp	 $LN1@CD_ReadTra
$LN7@CD_ReadTra:

; 112  : 		}
; 113  : 		nTrackLength = (DWORD)(MCI_MSF_MINUTE(m_MCIStatus.dwReturn)*60 + MCI_MSF_SECOND(m_MCIStatus.dwReturn));

  000e1	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR _m_MCIStatus+4
  000e8	6b c8 3c	 imul	 ecx, eax, 60
  000eb	0f b7 15 04 00
	00 00		 movzx	 edx, WORD PTR _m_MCIStatus+4
  000f2	c1 fa 08	 sar	 edx, 8
  000f5	0f b6 c2	 movzx	 eax, dl
  000f8	03 c8		 add	 ecx, eax
  000fa	89 4d fc	 mov	 DWORD PTR _nTrackLength$[ebp], ecx

; 114  : 		m_nTracks[i].Length = nTrackLength;

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00100	c1 e0 04	 shl	 eax, 4
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _nTrackLength$[ebp]
  00106	89 88 0c 00 00
	00		 mov	 DWORD PTR _m_nTracks[eax+12], ecx

; 115  : 
; 116  : 		m_MCIStatus.dwItem = MCI_CDA_STATUS_TYPE_TRACK;

  0010c	c7 05 08 00 00
	00 01 40 00 00	 mov	 DWORD PTR _m_MCIStatus+8, 16385 ; 00004001H

; 117  : 		iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_STATUS, MCI_TRACK|MCI_STATUS_ITEM|MCI_WAIT, (DWORD_PTR)&m_MCIStatus);

  00116	68 00 00 00 00	 push	 OFFSET _m_MCIStatus
  0011b	68 12 01 00 00	 push	 274			; 00000112H
  00120	68 14 08 00 00	 push	 2068			; 00000814H
  00125	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  0012a	50		 push	 eax
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00131	89 45 f4	 mov	 DWORD PTR _iErr$[ebp], eax

; 118  : 		if (iErr)

  00134	83 7d f4 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  00138	74 10		 je	 SHORT $LN8@CD_ReadTra

; 119  : 		{
; 120  : 			MCIErrorMessageBox (iErr);

  0013a	8b 45 f4	 mov	 eax, DWORD PTR _iErr$[ebp]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  00143	83 c4 04	 add	 esp, 4

; 121  : 			return FALSE;

  00146	33 c0		 xor	 eax, eax
  00148	eb 35		 jmp	 SHORT $LN1@CD_ReadTra
$LN8@CD_ReadTra:

; 122  : 		}
; 123  : 		m_nTracks[i].IsAudio = (m_MCIStatus.dwReturn == MCI_CDA_TRACK_AUDIO);

  0014a	81 3d 04 00 00
	00 40 04 00 00	 cmp	 DWORD PTR _m_MCIStatus+4, 1088 ; 00000440H
  00154	75 09		 jne	 SHORT $LN10@CD_ReadTra
  00156	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
  0015d	eb 07		 jmp	 SHORT $LN11@CD_ReadTra
$LN10@CD_ReadTra:
  0015f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
$LN11@CD_ReadTra:
  00166	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00169	c1 e0 04	 shl	 eax, 4
  0016c	8b 4d b0	 mov	 ecx, DWORD PTR tv135[ebp]
  0016f	89 88 00 00 00
	00		 mov	 DWORD PTR _m_nTracks[eax], ecx

; 124  : 	}

  00175	e9 03 ff ff ff	 jmp	 $LN2@CD_ReadTra
$LN3@CD_ReadTra:

; 125  : 
; 126  : 	return TRUE;

  0017a	b8 01 00 00 00	 mov	 eax, 1
$LN1@CD_ReadTra:

; 127  : }

  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
_CD_ReadTrackInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _CD_Reset
_TEXT	SEGMENT
_CD_Reset PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 74   : 	// no win32 equivalent
; 75   : 	//faB: for DOS, some odd drivers like to be reset sometimes.. useless in MCI I guess
; 76   : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_CD_Reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _MCIErrorMessageBox
_TEXT	SEGMENT
_szErrorText$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_iErrorCode$ = 8					; size = 4
_MCIErrorMessageBox PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 60   : 	char szErrorText[128];
; 61   : 	if (!mciGetErrorStringA (iErrorCode, szErrorText, sizeof (szErrorText)))

  00016	68 80 00 00 00	 push	 128			; 00000080H
  0001b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szErrorText$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _iErrorCode$[ebp]
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciGetErrorStringA@12
  0002c	85 c0		 test	 eax, eax
  0002e	75 19		 jne	 SHORT $LN2@MCIErrorMe

; 62   : 		wsprintfA(szErrorText,"MCI CD Audio Unknow Error #%d\n", iErrorCode);

  00030	8b 45 08	 mov	 eax, DWORD PTR _iErrorCode$[ebp]
  00033	50		 push	 eax
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BMEJADJN@MCI?5CD?5Audio?5Unknow?5Error?5?$CD?$CFd?6@
  00039	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szErrorText$[ebp]
  0003f	51		 push	 ecx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@MCIErrorMe:

; 63   : 	CONS_Printf("%s", szErrorText);

  00049	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szErrorText$[ebp]
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00055	e8 00 00 00 00	 call	 _CONS_Printf
  0005a	83 c4 08	 add	 esp, 8

; 64   : 	/*MessageBox (GetActiveWindow(), szTemp+1, "LEGACY",
; 65   : 				MB_OK | MB_ICONSTOP);*/
; 66   : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_MCIErrorMessageBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _Command_Cd_f
_TEXT	SEGMENT
tv185 = -84						; size = 4
tv179 = -80						; size = 4
tv196 = -80						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_s$ = -4						; size = 4
_Command_Cd_f PROC					; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 190  : 	LPCSTR    s;
; 191  : 	int       i,j;
; 192  : 
; 193  : 	if (!cdaudio_started)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _cdaudio_started
  00010	85 c0		 test	 eax, eax
  00012	75 05		 jne	 SHORT $LN14@Command_Cd

; 194  : 		return;

  00014	e9 de 03 00 00	 jmp	 $LN1@Command_Cd
$LN14@Command_Cd:

; 195  : 
; 196  : 	if (COM_Argc()<2)

  00019	e8 00 00 00 00	 call	 _COM_Argc
  0001e	83 f8 02	 cmp	 eax, 2
  00021	73 12		 jae	 SHORT $LN15@Command_Cd

; 197  : 	{
; 198  : 		CONS_Printf ("cd [on] [off] [remap] [reset] [open]\n"

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@HLMIOJMK@cd?5?$FLon?$FN?5?$FLoff?$FN?5?$FLremap?$FN?5?$FLreset?$FN?5?$FL@
  00028	e8 00 00 00 00	 call	 _CONS_Printf
  0002d	83 c4 04	 add	 esp, 4

; 199  : 		             "   [info] [play <track>] [loop <track>]\n"
; 200  : 		             "   [stop] [resume]\n");
; 201  : 		return;

  00030	e9 c2 03 00 00	 jmp	 $LN1@Command_Cd
$LN15@Command_Cd:

; 202  : 	}
; 203  : 
; 204  : 	s = COM_Argv(1);

  00035	6a 01		 push	 1
  00037	e8 00 00 00 00	 call	 _COM_Argv
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 205  : 
; 206  : 	// activate cd music
; 207  : 	if (!strncmp(s,"on",2))

  00042	6a 02		 push	 2
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_02LIELOMNJ@on@
  00049	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _strncmp
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	85 c0		 test	 eax, eax
  00057	75 0f		 jne	 SHORT $LN16@Command_Cd

; 208  : 	{
; 209  : 		cdEnabled = TRUE;

  00059	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdEnabled, 1

; 210  : 		return;

  00063	e9 8f 03 00 00	 jmp	 $LN1@Command_Cd
$LN16@Command_Cd:

; 211  : 	}
; 212  : 
; 213  : 	// stop/deactivate cd music
; 214  : 	if (!strncmp(s,"off",3))

  00068	6a 03		 push	 3
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_03MCADLMAF@off@
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _strncmp
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	85 c0		 test	 eax, eax
  0007d	75 1e		 jne	 SHORT $LN17@Command_Cd

; 215  : 	{
; 216  : 		if (cdPlaying)

  0007f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdPlaying, 0
  00086	74 06		 je	 SHORT $LN18@Command_Cd

; 217  : 			I_StopCD ();

  00088	e8 00 00 00 00	 call	 _I_StopCD
  0008d	90		 npad	 1
$LN18@Command_Cd:

; 218  : 		cdEnabled = FALSE;

  0008e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdEnabled, 0

; 219  : 		return;

  00098	e9 5a 03 00 00	 jmp	 $LN1@Command_Cd
$LN17@Command_Cd:

; 220  : 	}
; 221  : 
; 222  : 	// remap tracks
; 223  : 	if (!strncmp(s,"remap",5))

  0009d	6a 05		 push	 5
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_05PGGDPNJE@remap@
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _strncmp
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	85 c0		 test	 eax, eax
  000b2	0f 85 ad 00 00
	00		 jne	 $LN19@Command_Cd

; 224  : 	{
; 225  : 		i = (int)COM_Argc() - 2;

  000b8	e8 00 00 00 00	 call	 _COM_Argc
  000bd	83 e8 02	 sub	 eax, 2
  000c0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 226  : 		if (i <= 0)

  000c3	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000c7	7f 5a		 jg	 SHORT $LN20@Command_Cd

; 227  : 		{
; 228  : 			CONS_Printf ("CD tracks remapped in that order :\n");

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DBFDGMKA@CD?5tracks?5remapped?5in?5that?5orde@
  000ce	e8 00 00 00 00	 call	 _CONS_Printf
  000d3	83 c4 04	 add	 esp, 4

; 229  : 			for (j = 1; j < MAX_CD_TRACKS; j++)

  000d6	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  000dd	eb 09		 jmp	 SHORT $LN4@Command_Cd
$LN2@Command_Cd:
  000df	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN4@Command_Cd:
  000e8	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _j$[ebp], 255	; 000000ffH
  000ef	7d 2d		 jge	 SHORT $LN3@Command_Cd

; 230  : 				if (cdRemap[j] != j)

  000f1	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000f4	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _cdRemap[eax]
  000fb	3b 4d f4	 cmp	 ecx, DWORD PTR _j$[ebp]
  000fe	74 1c		 je	 SHORT $LN21@Command_Cd

; 231  : 					CONS_Printf (" %2d -> %2d\n", j, cdRemap[j]);

  00100	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00103	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _cdRemap[eax]
  0010a	51		 push	 ecx
  0010b	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  0010e	52		 push	 edx
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JCCNDNIC@?5?$CF2d?5?9?$DO?5?$CF2d?6@
  00114	e8 00 00 00 00	 call	 _CONS_Printf
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@Command_Cd:
  0011c	eb c1		 jmp	 SHORT $LN2@Command_Cd
$LN3@Command_Cd:

; 232  : 			return;

  0011e	e9 d4 02 00 00	 jmp	 $LN1@Command_Cd
$LN20@Command_Cd:

; 233  : 		}
; 234  : 		for (j = 1; j <= i; j++)

  00123	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _j$[ebp], 1
  0012a	eb 09		 jmp	 SHORT $LN7@Command_Cd
$LN5@Command_Cd:
  0012c	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0012f	83 c0 01	 add	 eax, 1
  00132	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN7@Command_Cd:
  00135	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00138	3b 45 f8	 cmp	 eax, DWORD PTR _i$[ebp]
  0013b	7f 23		 jg	 SHORT $LN6@Command_Cd

; 235  : 			cdRemap[j] = (UINT8)atoi (COM_Argv (j+1));

  0013d	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _COM_Argv
  00149	83 c4 04	 add	 esp, 4
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _atoi
  00152	83 c4 04	 add	 esp, 4
  00155	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  00158	88 81 00 00 00
	00		 mov	 BYTE PTR _cdRemap[ecx], al
  0015e	eb cc		 jmp	 SHORT $LN5@Command_Cd
$LN6@Command_Cd:

; 236  : 		return;

  00160	e9 92 02 00 00	 jmp	 $LN1@Command_Cd
$LN19@Command_Cd:

; 237  : 	}
; 238  : 
; 239  : 	// reset the CD driver, useful on some odd cd's
; 240  : 	if (!strncmp(s,"reset",5))

  00165	6a 05		 push	 5
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_05CFMALAOA@reset@
  0016c	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 _strncmp
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
  00178	85 c0		 test	 eax, eax
  0017a	75 57		 jne	 SHORT $LN22@Command_Cd

; 241  : 	{
; 242  : 		cdEnabled = TRUE;

  0017c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdEnabled, 1

; 243  : 		if (cdPlaying)

  00186	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdPlaying, 0
  0018d	74 06		 je	 SHORT $LN23@Command_Cd

; 244  : 			I_StopCD ();

  0018f	e8 00 00 00 00	 call	 _I_StopCD
  00194	90		 npad	 1
$LN23@Command_Cd:

; 245  : 		for (i = 0; i < MAX_CD_TRACKS; i++)

  00195	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0019c	eb 09		 jmp	 SHORT $LN10@Command_Cd
$LN8@Command_Cd:
  0019e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001a1	83 c0 01	 add	 eax, 1
  001a4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Command_Cd:
  001a7	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 255	; 000000ffH
  001ae	7d 0e		 jge	 SHORT $LN9@Command_Cd

; 246  : 			cdRemap[i] = (UINT8)i;

  001b0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001b3	8a 4d f8	 mov	 cl, BYTE PTR _i$[ebp]
  001b6	88 88 00 00 00
	00		 mov	 BYTE PTR _cdRemap[eax], cl
  001bc	eb e0		 jmp	 SHORT $LN8@Command_Cd
$LN9@Command_Cd:

; 247  : 		CD_Reset();

  001be	e8 00 00 00 00	 call	 _CD_Reset
  001c3	90		 npad	 1

; 248  : 		cdValid = CD_ReadTrackInfo();

  001c4	e8 00 00 00 00	 call	 _CD_ReadTrackInfo
  001c9	a3 00 00 00 00	 mov	 DWORD PTR _cdValid, eax

; 249  : 		return;

  001ce	e9 24 02 00 00	 jmp	 $LN1@Command_Cd
$LN22@Command_Cd:

; 250  : 	}
; 251  : 
; 252  : 	// any other command is not allowed until we could retrieve cd information
; 253  : 	if (!cdValid)

  001d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdValid, 0
  001da	75 12		 jne	 SHORT $LN24@Command_Cd

; 254  : 	{
; 255  : 		CONS_Printf ("CD is not ready.\n");

  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NJFEMFBD@CD?5is?5not?5ready?4?6@
  001e1	e8 00 00 00 00	 call	 _CONS_Printf
  001e6	83 c4 04	 add	 esp, 4

; 256  : 		return;

  001e9	e9 09 02 00 00	 jmp	 $LN1@Command_Cd
$LN24@Command_Cd:

; 257  : 	}
; 258  : 
; 259  : 	/* faB: not with MCI, didn't find it, useless anyway
; 260  : 	if (!strncmp(s,"open",4))
; 261  : 	{
; 262  : 		if (cdPlaying)
; 263  : 			I_StopCD ();
; 264  : 		bcd_open_door();
; 265  : 		cdValid = FALSE;
; 266  : 		return;
; 267  : 	}*/
; 268  : 
; 269  : 	if (!strncmp(s,"info",4))

  001ee	6a 04		 push	 4
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_04NIDJFNBE@info@
  001f5	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 _strncmp
  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00201	85 c0		 test	 eax, eax
  00203	0f 85 2e 01 00
	00		 jne	 $LN25@Command_Cd

; 270  : 	{
; 271  : 		if (!CD_ReadTrackInfo())

  00209	e8 00 00 00 00	 call	 _CD_ReadTrackInfo
  0020e	85 c0		 test	 eax, eax
  00210	75 0f		 jne	 SHORT $LN26@Command_Cd

; 272  : 		{
; 273  : 			cdValid = FALSE;

  00212	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdValid, 0

; 274  : 			return;

  0021c	e9 d6 01 00 00	 jmp	 $LN1@Command_Cd
$LN26@Command_Cd:

; 275  : 		}
; 276  : 
; 277  : 		cdValid = TRUE;

  00221	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdValid, 1

; 278  : 
; 279  : 		if (m_nTracksCount <= 0)

  0022b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_nTracksCount, 0
  00232	7f 12		 jg	 SHORT $LN27@Command_Cd

; 280  : 			CONS_Printf ("No audio tracks\n");

  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PGNAFNE@No?5audio?5tracks?6@
  00239	e8 00 00 00 00	 call	 _CONS_Printf
  0023e	83 c4 04	 add	 esp, 4
  00241	e9 b3 00 00 00	 jmp	 $LN28@Command_Cd
$LN27@Command_Cd:

; 281  : 		else
; 282  : 		{
; 283  : 			// display list of tracks
; 284  : 			// highlight current playing track
; 285  : 			for (i = 0; i < m_nTracksCount; i++)

  00246	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0024d	eb 09		 jmp	 SHORT $LN13@Command_Cd
$LN11@Command_Cd:
  0024f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00252	83 c0 01	 add	 eax, 1
  00255	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN13@Command_Cd:
  00258	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0025b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _m_nTracksCount
  00261	7d 7a		 jge	 SHORT $LN12@Command_Cd

; 286  : 			{
; 287  : 				CONS_Printf("%s%2d. %s  %s\n",

  00263	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00266	c1 e0 04	 shl	 eax, 4
  00269	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _m_nTracks[eax], 0
  00270	74 09		 je	 SHORT $LN35@Command_Cd
  00272	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], OFFSET ??_C@_05KNIAAKIP@audio@
  00279	eb 07		 jmp	 SHORT $LN36@Command_Cd
$LN35@Command_Cd:
  0027b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], OFFSET ??_C@_05EBMGPPJD@data?5@
$LN36@Command_Cd:
  00282	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdPlaying, 0
  00289	74 14		 je	 SHORT $LN37@Command_Cd
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _cdPlayTrack
  00291	3b 4d f8	 cmp	 ecx, DWORD PTR _i$[ebp]
  00294	75 09		 jne	 SHORT $LN37@Command_Cd
  00296	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv185[ebp], OFFSET ??_C@_02JGLONGCB@?$AC?5@
  0029d	eb 07		 jmp	 SHORT $LN38@Command_Cd
$LN37@Command_Cd:
  0029f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv185[ebp], OFFSET ??_C@_01CLKCMJKC@?5@
$LN38@Command_Cd:
  002a6	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002a9	c1 e2 04	 shl	 edx, 4
  002ac	8b 82 0c 00 00
	00		 mov	 eax, DWORD PTR _m_nTracks[edx+12]
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 _hms
  002b8	83 c4 04	 add	 esp, 4
  002bb	50		 push	 eax
  002bc	8b 4d b0	 mov	 ecx, DWORD PTR tv179[ebp]
  002bf	51		 push	 ecx
  002c0	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002c3	83 c2 01	 add	 edx, 1
  002c6	52		 push	 edx
  002c7	8b 45 ac	 mov	 eax, DWORD PTR tv185[ebp]
  002ca	50		 push	 eax
  002cb	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PBIEADKN@?$CFs?$CF2d?4?5?$CFs?5?5?$CFs?6@
  002d0	e8 00 00 00 00	 call	 _CONS_Printf
  002d5	83 c4 14	 add	 esp, 20			; 00000014H

; 288  : 				            cdPlaying && (cdPlayTrack == i) ? "\2 " : " ",
; 289  : 				            i+1, m_nTracks[i].IsAudio ? "audio" : "data ",
; 290  : 				            hms(m_nTracks[i].Length));
; 291  : 			}

  002d8	e9 72 ff ff ff	 jmp	 $LN11@Command_Cd
$LN12@Command_Cd:

; 292  : 			CONS_Printf ("\2Total time : %s\n", hms(CD_TotalTime()));

  002dd	e8 00 00 00 00	 call	 _CD_TotalTime
  002e2	50		 push	 eax
  002e3	e8 00 00 00 00	 call	 _hms
  002e8	83 c4 04	 add	 esp, 4
  002eb	50		 push	 eax
  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MEAJJGDM@?$ACTotal?5time?5?3?5?$CFs?6@
  002f1	e8 00 00 00 00	 call	 _CONS_Printf
  002f6	83 c4 08	 add	 esp, 8
$LN28@Command_Cd:

; 293  : 		}
; 294  : 		if (cdPlaying)

  002f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdPlaying, 0
  00300	74 30		 je	 SHORT $LN29@Command_Cd

; 295  : 		{
; 296  : 			CONS_Printf ("%s track : %d\n", cdLooping ? "looping" : "playing",

  00302	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdLooping, 0
  00309	74 09		 je	 SHORT $LN39@Command_Cd
  0030b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv196[ebp], OFFSET ??_C@_07EOMMFHON@looping@
  00312	eb 07		 jmp	 SHORT $LN40@Command_Cd
$LN39@Command_Cd:
  00314	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv196[ebp], OFFSET ??_C@_07GDCKGKBF@playing@
$LN40@Command_Cd:
  0031b	a1 00 00 00 00	 mov	 eax, DWORD PTR _cdPlayTrack
  00320	50		 push	 eax
  00321	8b 4d b0	 mov	 ecx, DWORD PTR tv196[ebp]
  00324	51		 push	 ecx
  00325	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIBGHIDE@?$CFs?5track?5?3?5?$CFd?6@
  0032a	e8 00 00 00 00	 call	 _CONS_Printf
  0032f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@Command_Cd:

; 297  : 			             cdPlayTrack);
; 298  : 		}
; 299  : 		return;

  00332	e9 c0 00 00 00	 jmp	 $LN1@Command_Cd
$LN25@Command_Cd:

; 300  : 	}
; 301  : 
; 302  : 	if (!strncmp(s,"play",4))

  00337	6a 04		 push	 4
  00339	68 00 00 00 00	 push	 OFFSET ??_C@_04GBHMDDO@play@
  0033e	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _strncmp
  00347	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034a	85 c0		 test	 eax, eax
  0034c	75 23		 jne	 SHORT $LN30@Command_Cd

; 303  : 	{
; 304  : 		I_PlayCD ((UINT8)atoi (COM_Argv (2)), false);

  0034e	6a 00		 push	 0
  00350	6a 02		 push	 2
  00352	e8 00 00 00 00	 call	 _COM_Argv
  00357	83 c4 04	 add	 esp, 4
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 _atoi
  00360	83 c4 04	 add	 esp, 4
  00363	50		 push	 eax
  00364	e8 00 00 00 00	 call	 _I_PlayCD
  00369	83 c4 08	 add	 esp, 8

; 305  : 		return;

  0036c	e9 86 00 00 00	 jmp	 $LN1@Command_Cd
$LN30@Command_Cd:

; 306  : 	}
; 307  : 
; 308  : 	if (!strncmp(s,"stop",4))

  00371	6a 04		 push	 4
  00373	68 00 00 00 00	 push	 OFFSET ??_C@_04PEGFANN@stop@
  00378	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 _strncmp
  00381	83 c4 0c	 add	 esp, 12			; 0000000cH
  00384	85 c0		 test	 eax, eax
  00386	75 08		 jne	 SHORT $LN31@Command_Cd

; 309  : 	{
; 310  : 		I_StopCD ();

  00388	e8 00 00 00 00	 call	 _I_StopCD
  0038d	90		 npad	 1

; 311  : 		return;

  0038e	eb 67		 jmp	 SHORT $LN1@Command_Cd
$LN31@Command_Cd:

; 312  : 	}
; 313  : 
; 314  : 	if (!strncmp(s,"loop",4))

  00390	6a 04		 push	 4
  00392	68 00 00 00 00	 push	 OFFSET ??_C@_04GKOOIABA@loop@
  00397	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0039a	50		 push	 eax
  0039b	e8 00 00 00 00	 call	 _strncmp
  003a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a3	85 c0		 test	 eax, eax
  003a5	75 20		 jne	 SHORT $LN32@Command_Cd

; 315  : 	{
; 316  : 		I_PlayCD((UINT8)atoi (COM_Argv (2)), true);

  003a7	6a 01		 push	 1
  003a9	6a 02		 push	 2
  003ab	e8 00 00 00 00	 call	 _COM_Argv
  003b0	83 c4 04	 add	 esp, 4
  003b3	50		 push	 eax
  003b4	e8 00 00 00 00	 call	 _atoi
  003b9	83 c4 04	 add	 esp, 4
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 _I_PlayCD
  003c2	83 c4 08	 add	 esp, 8

; 317  : 		return;

  003c5	eb 30		 jmp	 SHORT $LN1@Command_Cd
$LN32@Command_Cd:

; 318  : 	}
; 319  : 
; 320  : 	if (!strncmp(s,"resume",4))

  003c7	6a 04		 push	 4
  003c9	68 00 00 00 00	 push	 OFFSET ??_C@_06PLELHCEK@resume@
  003ce	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  003d1	50		 push	 eax
  003d2	e8 00 00 00 00	 call	 _strncmp
  003d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003da	85 c0		 test	 eax, eax
  003dc	75 08		 jne	 SHORT $LN33@Command_Cd

; 321  : 	{
; 322  : 		I_ResumeCD ();

  003de	e8 00 00 00 00	 call	 _I_ResumeCD
  003e3	90		 npad	 1

; 323  : 		return;

  003e4	eb 11		 jmp	 SHORT $LN1@Command_Cd
$LN33@Command_Cd:

; 324  : 	}
; 325  : 
; 326  : 	CONS_Printf ("cd command '%s' unknown\n", s);

  003e6	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  003e9	50		 push	 eax
  003ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HBFNPJAI@cd?5command?5?8?$CFs?8?5unknown?6@
  003ef	e8 00 00 00 00	 call	 _CONS_Printf
  003f4	83 c4 08	 add	 esp, 8
$LN1@Command_Cd:

; 327  : }

  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx
  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c3		 ret	 0
_Command_Cd_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_SetVolumeCD
_TEXT	SEGMENT
_volume$ = 8						; size = 4
_I_SetVolumeCD PROC					; COMDAT

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 528  : 	UNREFERENCED_PARAMETER(volume);
; 529  : 	return false;

  00009	33 c0		 xor	 eax, eax

; 530  : }

  0000b	5f		 pop	 edi
  0000c	5e		 pop	 esi
  0000d	5b		 pop	 ebx
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_I_SetVolumeCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_PlayCD
_TEXT	SEGMENT
_iErr$ = -20						; size = 4
_mciPlay$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_nTrack$ = 8						; size = 1
_bLooping$ = 12						; size = 1
_I_PlayCD PROC						; COMDAT

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 427  : 	MCI_PLAY_PARMS  mciPlay;
; 428  : 	MCIERROR        iErr;
; 429  : 
; 430  : 	if (!cdaudio_started || !cdEnabled)

  00013	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _cdaudio_started
  0001a	85 c0		 test	 eax, eax
  0001c	74 09		 je	 SHORT $LN3@I_PlayCD
  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdEnabled, 0
  00025	75 05		 jne	 SHORT $LN2@I_PlayCD
$LN3@I_PlayCD:

; 431  : 		return;

  00027	e9 17 01 00 00	 jmp	 $LN1@I_PlayCD
$LN2@I_PlayCD:

; 432  : 
; 433  : 	//faB: try again if it didn't work (just free the user of typing 'cd reset' command)
; 434  : 	if (!cdValid)

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdValid, 0
  00033	75 0a		 jne	 SHORT $LN4@I_PlayCD

; 435  : 		cdValid = CD_ReadTrackInfo();

  00035	e8 00 00 00 00	 call	 _CD_ReadTrackInfo
  0003a	a3 00 00 00 00	 mov	 DWORD PTR _cdValid, eax
$LN4@I_PlayCD:

; 436  : 	if (!cdValid)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdValid, 0
  00046	75 05		 jne	 SHORT $LN5@I_PlayCD

; 437  : 		return;

  00048	e9 f6 00 00 00	 jmp	 $LN1@I_PlayCD
$LN5@I_PlayCD:

; 438  : 
; 439  : 	// tracks start at 0 in the code..
; 440  : 	nTrack--;

  0004d	8a 45 08	 mov	 al, BYTE PTR _nTrack$[ebp]
  00050	2c 01		 sub	 al, 1
  00052	88 45 08	 mov	 BYTE PTR _nTrack$[ebp], al

; 441  : 	if (nTrack >= m_nTracksCount)

  00055	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  00059	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _m_nTracksCount
  0005f	7c 0e		 jl	 SHORT $LN6@I_PlayCD

; 442  : 		nTrack = (UINT8) (nTrack % m_nTracksCount);

  00061	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  00065	99		 cdq
  00066	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _m_nTracksCount
  0006c	88 55 08	 mov	 BYTE PTR _nTrack$[ebp], dl
$LN6@I_PlayCD:

; 443  : 
; 444  : 	nTrack = cdRemap[nTrack];

  0006f	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  00073	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _cdRemap[eax]
  00079	88 4d 08	 mov	 BYTE PTR _nTrack$[ebp], cl

; 445  : 
; 446  : 	if (cdPlaying)

  0007c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdPlaying, 0
  00083	74 17		 je	 SHORT $LN7@I_PlayCD

; 447  : 	{
; 448  : 		if (cdPlayTrack == nTrack)

  00085	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  00089	39 05 00 00 00
	00		 cmp	 DWORD PTR _cdPlayTrack, eax
  0008f	75 05		 jne	 SHORT $LN8@I_PlayCD

; 449  : 			return;

  00091	e9 ad 00 00 00	 jmp	 $LN1@I_PlayCD
$LN8@I_PlayCD:

; 450  : 		I_StopCD ();

  00096	e8 00 00 00 00	 call	 _I_StopCD
  0009b	90		 npad	 1
$LN7@I_PlayCD:

; 451  : 	}
; 452  : 
; 453  : 	cdPlayTrack = nTrack;

  0009c	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  000a0	a3 00 00 00 00	 mov	 DWORD PTR _cdPlayTrack, eax

; 454  : 
; 455  : 	if (!m_nTracks[nTrack].IsAudio)

  000a5	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  000a9	c1 e0 04	 shl	 eax, 4
  000ac	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _m_nTracks[eax], 0
  000b3	75 05		 jne	 SHORT $LN9@I_PlayCD

; 456  : 	{
; 457  : 		//CONS_Printf ("\2CD Play: not an audio track\n"); // Tails 03-25-2001
; 458  : 		return;

  000b5	e9 89 00 00 00	 jmp	 $LN1@I_PlayCD
$LN9@I_PlayCD:

; 459  : 	}
; 460  : 
; 461  : 	cdLooping = bLooping;

  000ba	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLooping$[ebp]
  000be	a3 00 00 00 00	 mov	 DWORD PTR _cdLooping, eax

; 462  : 
; 463  : 	//faB: stop MIDI music, MIDI music will restart if volume is upped later
; 464  : 	cv_digmusicvolume.value = 0;

  000c3	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_digmusicvolume+20, 0

; 465  : 	cv_midimusicvolume.value = 0;

  000cd	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cv_midimusicvolume+20, 0

; 466  : 	I_StopSong (0);

  000d7	6a 00		 push	 0
  000d9	e8 00 00 00 00	 call	 _I_StopSong
  000de	83 c4 04	 add	 esp, 4

; 467  : 
; 468  : 	//faB: I don't use the notify message, I'm trying to minimize the delay
; 469  : 	mciPlay.dwCallback = (DWORD)((size_t)hWndMain);

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _hWndMain
  000e6	89 45 f0	 mov	 DWORD PTR _mciPlay$[ebp], eax

; 470  : 	mciPlay.dwFrom = MCI_MAKE_TMSF(nTrack+1, 0, 0, 0);

  000e9	0f b6 45 08	 movzx	 eax, BYTE PTR _nTrack$[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	0f b6 c8	 movzx	 ecx, al
  000f3	89 4d f4	 mov	 DWORD PTR _mciPlay$[ebp+4], ecx

; 471  : 	iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_PLAY, MCI_FROM|MCI_NOTIFY, (DWORD_PTR)&mciPlay);

  000f6	8d 45 f0	 lea	 eax, DWORD PTR _mciPlay$[ebp]
  000f9	50		 push	 eax
  000fa	6a 05		 push	 5
  000fc	68 06 08 00 00	 push	 2054			; 00000806H
  00101	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _m_MCIOpen+4
  00107	51		 push	 ecx
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0010e	89 45 ec	 mov	 DWORD PTR _iErr$[ebp], eax

; 472  : 	if (iErr)

  00111	83 7d ec 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  00115	74 22		 je	 SHORT $LN10@I_PlayCD

; 473  : 	{
; 474  : 		MCIErrorMessageBox (iErr);

  00117	8b 45 ec	 mov	 eax, DWORD PTR _iErr$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  00120	83 c4 04	 add	 esp, 4

; 475  : 		cdValid = FALSE;

  00123	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdValid, 0

; 476  : 		cdPlaying = FALSE;

  0012d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdPlaying, 0

; 477  : 		return;

  00137	eb 0a		 jmp	 SHORT $LN1@I_PlayCD
$LN10@I_PlayCD:

; 478  : 	}
; 479  : 
; 480  : 	cdPlaying = TRUE;

  00139	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdPlaying, 1
$LN1@I_PlayCD:

; 481  : }

  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
_I_PlayCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_UpdateCD
_TEXT	SEGMENT
_I_UpdateCD PROC					; COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 420  : 		/// \todo check for cd change and restart music ?
; 421  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_I_UpdateCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_ShutdownCD
_TEXT	SEGMENT
_iErr$ = -4						; size = 4
_I_ShutdownCD PROC					; COMDAT

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 336  : 	MCIERROR    iErr;
; 337  : 
; 338  : 	if (!cdaudio_started)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _cdaudio_started
  00010	85 c0		 test	 eax, eax
  00012	75 02		 jne	 SHORT $LN2@I_Shutdown

; 339  : 		return;

  00014	eb 3d		 jmp	 SHORT $LN3@I_Shutdown
$LN2@I_Shutdown:

; 340  : 
; 341  : 	CONS_Printf ("I_ShutdownCD()\n");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GNFIIKPA@I_ShutdownCD?$CI?$CJ?6@
  0001b	e8 00 00 00 00	 call	 _CONS_Printf
  00020	83 c4 04	 add	 esp, 4

; 342  : 
; 343  : 	I_StopCD();

  00023	e8 00 00 00 00	 call	 _I_StopCD
  00028	90		 npad	 1

; 344  : 
; 345  : 	// closes MCI CD
; 346  : 	iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_CLOSE, 0, 0);

  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	68 04 08 00 00	 push	 2052			; 00000804H
  00032	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0003e	89 45 fc	 mov	 DWORD PTR _iErr$[ebp], eax

; 347  : 	if (iErr)

  00041	83 7d fc 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  00045	74 0c		 je	 SHORT $LN3@I_Shutdown

; 348  : 		MCIErrorMessageBox (iErr);

  00047	8b 45 fc	 mov	 eax, DWORD PTR _iErr$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  00050	83 c4 04	 add	 esp, 4
$LN3@I_Shutdown:

; 349  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_I_ShutdownCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_ResumeCD
_TEXT	SEGMENT
_iErr$ = -4						; size = 4
_I_ResumeCD PROC					; COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 506  : 	MCIERROR    iErr;
; 507  : 
; 508  : 	if (!cdaudio_started || !cdEnabled)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _cdaudio_started
  00010	85 c0		 test	 eax, eax
  00012	74 09		 je	 SHORT $LN3@I_ResumeCD
  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdEnabled, 0
  0001b	75 02		 jne	 SHORT $LN2@I_ResumeCD
$LN3@I_ResumeCD:

; 509  : 		return;

  0001d	eb 4c		 jmp	 SHORT $LN7@I_ResumeCD
$LN2@I_ResumeCD:

; 510  : 
; 511  : 	if (!cdValid)

  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdValid, 0
  00026	75 02		 jne	 SHORT $LN4@I_ResumeCD

; 512  : 		return;

  00028	eb 41		 jmp	 SHORT $LN7@I_ResumeCD
$LN4@I_ResumeCD:

; 513  : 
; 514  : 	if (!wasPlaying)

  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _wasPlaying, 0
  00031	75 02		 jne	 SHORT $LN5@I_ResumeCD

; 515  : 		return;

  00033	eb 36		 jmp	 SHORT $LN7@I_ResumeCD
$LN5@I_ResumeCD:

; 516  : 
; 517  : 	iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_RESUME, MCI_WAIT, 0);

  00035	6a 00		 push	 0
  00037	6a 02		 push	 2
  00039	68 55 08 00 00	 push	 2133			; 00000855H
  0003e	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0004a	89 45 fc	 mov	 DWORD PTR _iErr$[ebp], eax

; 518  : 	if (iErr)

  0004d	83 7d fc 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  00051	74 0e		 je	 SHORT $LN6@I_ResumeCD

; 519  : 		MCIErrorMessageBox (iErr);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _iErr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  0005c	83 c4 04	 add	 esp, 4
  0005f	eb 0a		 jmp	 SHORT $LN7@I_ResumeCD
$LN6@I_ResumeCD:

; 520  : 	else
; 521  : 		cdPlaying = TRUE;

  00061	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdPlaying, 1
$LN7@I_ResumeCD:

; 522  : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_I_ResumeCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_StopCD
_TEXT	SEGMENT
_iErr$ = -4						; size = 4
_I_StopCD PROC						; COMDAT

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 487  : 	MCIERROR    iErr;
; 488  : 
; 489  : 	if (!cdaudio_started || !cdEnabled)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _cdaudio_started
  00010	85 c0		 test	 eax, eax
  00012	74 09		 je	 SHORT $LN3@I_StopCD
  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cdEnabled, 0
  0001b	75 02		 jne	 SHORT $LN2@I_StopCD
$LN3@I_StopCD:

; 490  : 		return;

  0001d	eb 40		 jmp	 SHORT $LN5@I_StopCD
$LN2@I_StopCD:

; 491  : 
; 492  : 	iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_PAUSE, MCI_WAIT, 0);

  0001f	6a 00		 push	 0
  00021	6a 02		 push	 2
  00023	68 09 08 00 00	 push	 2057			; 00000809H
  00028	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  00034	89 45 fc	 mov	 DWORD PTR _iErr$[ebp], eax

; 493  : 	if (iErr)

  00037	83 7d fc 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  0003b	74 0e		 je	 SHORT $LN4@I_StopCD

; 494  : 		MCIErrorMessageBox (iErr);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _iErr$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  00046	83 c4 04	 add	 esp, 4
  00049	eb 14		 jmp	 SHORT $LN5@I_StopCD
$LN4@I_StopCD:

; 495  : 	else
; 496  : 	{
; 497  : 		wasPlaying = cdPlaying;

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _cdPlaying
  00050	a3 00 00 00 00	 mov	 DWORD PTR _wasPlaying, eax

; 498  : 		cdPlaying = FALSE;

  00055	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdPlaying, 0
$LN5@I_StopCD:

; 499  : 	}
; 500  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_I_StopCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\win32\win_cd.c
;	COMDAT _I_InitCD
_TEXT	SEGMENT
_i$ = -24						; size = 4
_iErr$ = -20						; size = 4
_mciSet$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_I_InitCD PROC						; COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 358  : 	MCI_SET_PARMS   mciSet;
; 359  : 	MCIERROR    iErr;
; 360  : 	int         i;
; 361  : 
; 362  : 	// We don't have an open device yet
; 363  : 	m_MCIOpen.wDeviceID = 0;

  00013	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_MCIOpen+4, 0

; 364  : 	m_nTracksCount = 0;

  0001d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_nTracksCount, 0

; 365  : 
; 366  : 	cdaudio_started = false;

  00027	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _cdaudio_started, 0

; 367  : 
; 368  : 	m_MCIOpen.lpstrDeviceType = (LPCTSTR)MCI_DEVTYPE_CD_AUDIO;

  0002e	c7 05 08 00 00
	00 04 02 00 00	 mov	 DWORD PTR _m_MCIOpen+8, 516 ; 00000204H

; 369  : 	iErr = mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE|MCI_OPEN_TYPE_ID, (DWORD_PTR)&m_MCIOpen);

  00038	68 00 00 00 00	 push	 OFFSET _m_MCIOpen
  0003d	68 00 30 00 00	 push	 12288			; 00003000H
  00042	68 03 08 00 00	 push	 2051			; 00000803H
  00047	6a 00		 push	 0
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0004f	89 45 ec	 mov	 DWORD PTR _iErr$[ebp], eax

; 370  : 	if (iErr)

  00052	83 7d ec 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  00056	74 11		 je	 SHORT $LN5@I_InitCD

; 371  : 	{
; 372  : 		MCIErrorMessageBox (iErr);

  00058	8b 45 ec	 mov	 eax, DWORD PTR _iErr$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  00061	83 c4 04	 add	 esp, 4

; 373  : 		return;

  00064	e9 02 01 00 00	 jmp	 $LN1@I_InitCD
$LN5@I_InitCD:

; 374  : 	}
; 375  : 
; 376  : 	// Set the time format to track/minute/second/frame (TMSF).
; 377  : 	mciSet.dwTimeFormat = MCI_FORMAT_TMSF;

  00069	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _mciSet$[ebp+4], 10 ; 0000000aH

; 378  : 	iErr = mciSendCommand(m_MCIOpen.wDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)&mciSet);

  00070	8d 45 f0	 lea	 eax, DWORD PTR _mciSet$[ebp]
  00073	50		 push	 eax
  00074	68 00 04 00 00	 push	 1024			; 00000400H
  00079	68 0d 08 00 00	 push	 2061			; 0000080dH
  0007e	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _m_MCIOpen+4
  00084	51		 push	 ecx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  0008b	89 45 ec	 mov	 DWORD PTR _iErr$[ebp], eax

; 379  : 	if (iErr)

  0008e	83 7d ec 00	 cmp	 DWORD PTR _iErr$[ebp], 0
  00092	74 27		 je	 SHORT $LN6@I_InitCD

; 380  : 	{
; 381  : 		MCIErrorMessageBox (iErr);

  00094	8b 45 ec	 mov	 eax, DWORD PTR _iErr$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _MCIErrorMessageBox
  0009d	83 c4 04	 add	 esp, 4

; 382  : 		mciSendCommand(m_MCIOpen.wDeviceID, MCI_CLOSE, 0, 0);

  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	68 04 08 00 00	 push	 2052			; 00000804H
  000a9	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MCIOpen+4
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__mciSendCommandA@16
  000b5	90		 npad	 1

; 383  : 		return;

  000b6	e9 b0 00 00 00	 jmp	 $LN1@I_InitCD
$LN6@I_InitCD:

; 384  : 	}
; 385  : 
; 386  : 	I_AddExitFunc (I_ShutdownCD);

  000bb	68 00 00 00 00	 push	 OFFSET _I_ShutdownCD
  000c0	e8 00 00 00 00	 call	 _I_AddExitFunc
  000c5	83 c4 04	 add	 esp, 4

; 387  : 	cdaudio_started = true;

  000c8	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _cdaudio_started, 1

; 388  : 
; 389  : 	CONS_Printf ("I_InitCD: CD Audio started\n");

  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GHADCGBE@I_InitCD?3?5CD?5Audio?5started?6@
  000d4	e8 00 00 00 00	 call	 _CONS_Printf
  000d9	83 c4 04	 add	 esp, 4

; 390  : 
; 391  : 	// last saved in config.cfg
; 392  : 	i = cd_volume.value;

  000dc	a1 14 00 00 00	 mov	 eax, DWORD PTR _cd_volume+20
  000e1	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax

; 393  : 	//I_SetVolumeCD (0);   // initialize to 0 for some odd cd drivers
; 394  : 	I_SetVolumeCD (i);   // now set the last saved volume

  000e4	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _I_SetVolumeCD
  000ed	83 c4 04	 add	 esp, 4

; 395  : 
; 396  : 	for (i = 0; i < MAX_CD_TRACKS; i++)

  000f0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000f7	eb 09		 jmp	 SHORT $LN4@I_InitCD
$LN2@I_InitCD:
  000f9	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000fc	83 c0 01	 add	 eax, 1
  000ff	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@I_InitCD:
  00102	81 7d e8 ff 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 255	; 000000ffH
  00109	7d 0e		 jge	 SHORT $LN3@I_InitCD

; 397  : 		cdRemap[i] = (UINT8)i;

  0010b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0010e	8a 4d e8	 mov	 cl, BYTE PTR _i$[ebp]
  00111	88 88 00 00 00
	00		 mov	 BYTE PTR _cdRemap[eax], cl
  00117	eb e0		 jmp	 SHORT $LN2@I_InitCD
$LN3@I_InitCD:

; 398  : 
; 399  : 	if (!CD_ReadTrackInfo())

  00119	e8 00 00 00 00	 call	 _CD_ReadTrackInfo
  0011e	85 c0		 test	 eax, eax
  00120	75 23		 jne	 SHORT $LN7@I_InitCD

; 400  : 	{
; 401  : 		CONS_Printf("\2I_InitCD: no CD in player.\n");

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CMFOHIJM@?$ACI_InitCD?3?5no?5CD?5in?5player?4?6@
  00127	e8 00 00 00 00	 call	 _CONS_Printf
  0012c	83 c4 04	 add	 esp, 4

; 402  : 		cdEnabled = FALSE;

  0012f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdEnabled, 0

; 403  : 		cdValid = FALSE;

  00139	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cdValid, 0

; 404  : 	}

  00143	eb 14		 jmp	 SHORT $LN8@I_InitCD
$LN7@I_InitCD:

; 405  : 	else
; 406  : 	{
; 407  : 		cdEnabled = TRUE;

  00145	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdEnabled, 1

; 408  : 		cdValid = TRUE;

  0014f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cdValid, 1
$LN8@I_InitCD:

; 409  : 	}
; 410  : 
; 411  : 	COM_AddCommand ("cd", Command_Cd_f);

  00159	68 00 00 00 00	 push	 OFFSET _Command_Cd_f
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_02ELLOPNDH@cd@
  00163	e8 00 00 00 00	 call	 _COM_AddCommand
  00168	83 c4 08	 add	 esp, 8
$LN1@I_InitCD:

; 412  : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00171	33 cd		 xor	 ecx, ebp
  00173	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
_I_InitCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
