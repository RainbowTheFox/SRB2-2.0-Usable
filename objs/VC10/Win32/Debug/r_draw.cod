; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\r_draw.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_Color_Names
PUBLIC	_dc_x
PUBLIC	_dc_yl
PUBLIC	_dc_yh
PUBLIC	_dc_lightlist
PUBLIC	_dc_numlights
PUBLIC	??_C@_04OHJIHAFH@None@				; `string'
PUBLIC	??_C@_04ICNCCCFD@Cyan@				; `string'
PUBLIC	??_C@_05HHEOKKCG@Peach@				; `string'
PUBLIC	??_C@_08CLMDHLFI@Lavender@			; `string'
PUBLIC	??_C@_06BONGPKIK@Silver@			; `string'
PUBLIC	??_C@_06LMIDBFFB@Orange@			; `string'
PUBLIC	??_C@_03PADCEAKC@Red@				; `string'
PUBLIC	??_C@_04CAKOHOCJ@Blue@				; `string'
PUBLIC	??_C@_0L@KMMEFAJI@Steel_Blue@			; `string'
PUBLIC	??_C@_04IDKACLOG@Pink@				; `string'
PUBLIC	??_C@_05EOEDPHMI@Beige@				; `string'
PUBLIC	??_C@_06KLMDOLNB@Purple@			; `string'
PUBLIC	??_C@_05GGOIJPPE@Green@				; `string'
PUBLIC	??_C@_05PLKILNHI@White@				; `string'
PUBLIC	??_C@_04PABHPHAJ@Gold@				; `string'
PUBLIC	??_C@_06ICCAKDNH@Yellow@			; `string'
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_viewwindowx:DWORD
COMM	_viewwindowy:DWORD
COMM	_viewwidth:DWORD
COMM	_scaledviewwidth:DWORD
COMM	_Color_cons_t:QWORD:011H
COMM	_viewheight:DWORD
COMM	_ylookup:DWORD:012c0H
COMM	_ylookup1:DWORD:012c0H
COMM	_ylookup2:DWORD:012c0H
COMM	_columnofs:DWORD:01e00H
COMM	_topleft:DWORD
COMM	_dc_colormap:DWORD
_DATA	ENDS
_BSS	SEGMENT
_dc_x	DD	01H DUP (?)
_dc_yl	DD	01H DUP (?)
_dc_yh	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_dc_iscale:DWORD
COMM	_dc_texturemid:DWORD
COMM	_dc_hires:BYTE
COMM	_dc_source:DWORD
COMM	_transtables:DWORD
COMM	_dc_transmap:DWORD
COMM	_translationtables:DWORD:020H
COMM	_defaulttranslationtables:DWORD
COMM	_bosstranslationtables:DWORD
COMM	_dc_translation:DWORD
_DATA	ENDS
_BSS	SEGMENT
_dc_lightlist DD 01H DUP (?)
_dc_numlights DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_dc_maxlights:DWORD
COMM	_dc_texheight:DWORD
COMM	_ds_y:DWORD
COMM	_ds_x1:DWORD
COMM	_ds_x2:DWORD
COMM	_ds_colormap:DWORD
COMM	_ds_xfrac:DWORD
COMM	_ds_yfrac:DWORD
COMM	_ds_xstep:DWORD
COMM	_ds_ystep:DWORD
COMM	_ds_source:DWORD
COMM	_ds_transmap:DWORD
COMM	_nflatxshift:DWORD
COMM	_nflatyshift:DWORD
COMM	_nflatshiftup:DWORD
COMM	_nflatmask:DWORD
COMM	_viewborderlump:DWORD:08H
_DATA	ENDS
;	COMDAT ??_C@_06ICCAKDNH@Yellow@
CONST	SEGMENT
??_C@_06ICCAKDNH@Yellow@ DB 'Yellow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PABHPHAJ@Gold@
CONST	SEGMENT
??_C@_04PABHPHAJ@Gold@ DB 'Gold', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PLKILNHI@White@
CONST	SEGMENT
??_C@_05PLKILNHI@White@ DB 'White', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGOIJPPE@Green@
CONST	SEGMENT
??_C@_05GGOIJPPE@Green@ DB 'Green', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLMDOLNB@Purple@
CONST	SEGMENT
??_C@_06KLMDOLNB@Purple@ DB 'Purple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EOEDPHMI@Beige@
CONST	SEGMENT
??_C@_05EOEDPHMI@Beige@ DB 'Beige', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IDKACLOG@Pink@
CONST	SEGMENT
??_C@_04IDKACLOG@Pink@ DB 'Pink', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMMEFAJI@Steel_Blue@
CONST	SEGMENT
??_C@_0L@KMMEFAJI@Steel_Blue@ DB 'Steel_Blue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAKOHOCJ@Blue@
CONST	SEGMENT
??_C@_04CAKOHOCJ@Blue@ DB 'Blue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PADCEAKC@Red@
CONST	SEGMENT
??_C@_03PADCEAKC@Red@ DB 'Red', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMIDBFFB@Orange@
CONST	SEGMENT
??_C@_06LMIDBFFB@Orange@ DB 'Orange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BONGPKIK@Silver@
CONST	SEGMENT
??_C@_06BONGPKIK@Silver@ DB 'Silver', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLMDHLFI@Lavender@
CONST	SEGMENT
??_C@_08CLMDHLFI@Lavender@ DB 'Lavender', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HHEOKKCG@Peach@
CONST	SEGMENT
??_C@_05HHEOKKCG@Peach@ DB 'Peach', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ICNCCCFD@Cyan@
CONST	SEGMENT
??_C@_04ICNCCCFD@Cyan@ DB 'Cyan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None@
CONST	SEGMENT
??_C@_04OHJIHAFH@None@ DB 'None', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_Color_Names DD	FLAT:??_C@_04OHJIHAFH@None@
	DD	FLAT:??_C@_04ICNCCCFD@Cyan@
	DD	FLAT:??_C@_05HHEOKKCG@Peach@
	DD	FLAT:??_C@_08CLMDHLFI@Lavender@
	DD	FLAT:??_C@_06BONGPKIK@Silver@
	DD	FLAT:??_C@_06LMIDBFFB@Orange@
	DD	FLAT:??_C@_03PADCEAKC@Red@
	DD	FLAT:??_C@_04CAKOHOCJ@Blue@
	DD	FLAT:??_C@_0L@KMMEFAJI@Steel_Blue@
	DD	FLAT:??_C@_04IDKACLOG@Pink@
	DD	FLAT:??_C@_05EOEDPHMI@Beige@
	DD	FLAT:??_C@_06KLMDOLNB@Purple@
	DD	FLAT:??_C@_05GGOIJPPE@Green@
	DD	FLAT:??_C@_05PLKILNHI@White@
	DD	FLAT:??_C@_04PABHPHAJ@Gold@
	DD	FLAT:??_C@_06ICCAKDNH@Yellow@
_DATA	ENDS
PUBLIC	_R_InitTranslationTables
PUBLIC	_R_LoadSkinTable
PUBLIC	_R_InitSkinTranslationTables
PUBLIC	_R_InitViewBuffer
PUBLIC	_R_InitViewBorder
PUBLIC	_R_VideoErase
PUBLIC	_R_DrawColumn_8
PUBLIC	_R_DrawWallColumn_8
PUBLIC	_R_DrawShadeColumn_8
PUBLIC	_R_DrawTranslucentColumn_8
PUBLIC	_R_DrawTranslatedColumn_8
PUBLIC	_R_DrawTranslatedTranslucentColumn_8
PUBLIC	_R_DrawSpan_8
PUBLIC	_R_DrawSplat_8
PUBLIC	_R_DrawTranslucentSplat_8
PUBLIC	_R_DrawTranslucentSpan_8
PUBLIC	_R_Draw2sMultiPatchColumn_8
PUBLIC	_R_DrawFogSpan_8
PUBLIC	_R_DrawFogColumn_8
PUBLIC	_R_DrawColumnShadowed_8
PUBLIC	_R_DrawColumn_16
PUBLIC	_R_DrawWallColumn_16
PUBLIC	_R_DrawTranslucentColumn_16
PUBLIC	_R_DrawTranslatedColumn_16
PUBLIC	_R_DrawSpan_16
PUBLIC	??_C@_07PPGLADMN@TRANS10@			; `string'
PUBLIC	??_C@_07PNCNLNJE@TRANS20@			; `string'
PUBLIC	??_C@_07PMOPNHKD@TRANS30@			; `string'
PUBLIC	??_C@_07PJKAMBCG@TRANS40@			; `string'
PUBLIC	??_C@_07PIGCKLBB@TRANS50@			; `string'
PUBLIC	??_C@_07PKCEBFEI@TRANS60@			; `string'
PUBLIC	??_C@_07PLOGHPHP@TRANS70@			; `string'
PUBLIC	??_C@_07PALKDIEC@TRANS80@			; `string'
PUBLIC	??_C@_07PBHIFCHF@TRANS90@			; `string'
PUBLIC	??_C@_0DA@JHACMJAF@R_InitViewBuffer?3?5wrong?5bytespe@ ; `string'
PUBLIC	??_C@_06LJGHLNGC@brdr_t@			; `string'
PUBLIC	??_C@_06KFPPAILF@brdr_b@			; `string'
PUBLIC	??_C@_06DLHMCFDL@brdr_l@			; `string'
PUBLIC	??_C@_06OPDNBKOE@brdr_r@			; `string'
PUBLIC	??_C@_07GKENEDGC@brdr_tl@			; `string'
PUBLIC	??_C@_07HCOGJMKA@brdr_bl@			; `string'
PUBLIC	??_C@_07LOAMHMLN@brdr_tr@			; `string'
PUBLIC	??_C@_07KGKHKDHP@brdr_br@			; `string'
EXTRN	_I_Error:PROC
EXTRN	_FixedMul:PROC
EXTRN	_W_GetNumForName:PROC
EXTRN	_W_ReadLump:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	__allmul:PROC
EXTRN	__allshl:PROC
EXTRN	__allshr:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_vid:BYTE
EXTRN	_colormaps:DWORD
EXTRN	_color8to16:BYTE
EXTRN	_hicolormaps:DWORD
EXTRN	_centery:DWORD
EXTRN	_centeryfrac:DWORD
EXTRN	_screens:BYTE
;	COMDAT ??_C@_07KGKHKDHP@brdr_br@
CONST	SEGMENT
??_C@_07KGKHKDHP@brdr_br@ DB 'brdr_br', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LOAMHMLN@brdr_tr@
CONST	SEGMENT
??_C@_07LOAMHMLN@brdr_tr@ DB 'brdr_tr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCOGJMKA@brdr_bl@
CONST	SEGMENT
??_C@_07HCOGJMKA@brdr_bl@ DB 'brdr_bl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GKENEDGC@brdr_tl@
CONST	SEGMENT
??_C@_07GKENEDGC@brdr_tl@ DB 'brdr_tl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OPDNBKOE@brdr_r@
CONST	SEGMENT
??_C@_06OPDNBKOE@brdr_r@ DB 'brdr_r', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLHMCFDL@brdr_l@
CONST	SEGMENT
??_C@_06DLHMCFDL@brdr_l@ DB 'brdr_l', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KFPPAILF@brdr_b@
CONST	SEGMENT
??_C@_06KFPPAILF@brdr_b@ DB 'brdr_b', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJGHLNGC@brdr_t@
CONST	SEGMENT
??_C@_06LJGHLNGC@brdr_t@ DB 'brdr_t', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JHACMJAF@R_InitViewBuffer?3?5wrong?5bytespe@
CONST	SEGMENT
??_C@_0DA@JHACMJAF@R_InitViewBuffer?3?5wrong?5bytespe@ DB 'R_InitViewBuff'
	DB	'er: wrong bytesperpixel value %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBHIFCHF@TRANS90@
CONST	SEGMENT
??_C@_07PBHIFCHF@TRANS90@ DB 'TRANS90', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PALKDIEC@TRANS80@
CONST	SEGMENT
??_C@_07PALKDIEC@TRANS80@ DB 'TRANS80', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PLOGHPHP@TRANS70@
CONST	SEGMENT
??_C@_07PLOGHPHP@TRANS70@ DB 'TRANS70', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PKCEBFEI@TRANS60@
CONST	SEGMENT
??_C@_07PKCEBFEI@TRANS60@ DB 'TRANS60', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PIGCKLBB@TRANS50@
CONST	SEGMENT
??_C@_07PIGCKLBB@TRANS50@ DB 'TRANS50', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJKAMBCG@TRANS40@
CONST	SEGMENT
??_C@_07PJKAMBCG@TRANS40@ DB 'TRANS40', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PMOPNHKD@TRANS30@
CONST	SEGMENT
??_C@_07PMOPNHKD@TRANS30@ DB 'TRANS30', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PNCNLNJE@TRANS20@
CONST	SEGMENT
??_C@_07PNCNLNJE@TRANS20@ DB 'TRANS20', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PPGLADMN@TRANS10@
CONST	SEGMENT
??_C@_07PPGLADMN@TRANS10@ DB 'TRANS10', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw16.c
;	COMDAT _R_DrawSpan_16
_TEXT	SEGMENT
tv87 = -88						; size = 4
_spot$ = -20						; size = 4
_count$ = -16						; size = 4
_dest$ = -12						; size = 4
_yfrac$ = -8						; size = 4
_xfrac$ = -4						; size = 4
_R_DrawSpan_16 PROC					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 189  : 	fixed_t xfrac, yfrac;
; 190  : 	INT16 *dest;
; 191  : 	INT32 count, spot;
; 192  : 
; 193  : #ifdef RANGECHECK
; 194  : 	if (ds_x2 < ds_x1 || ds_x1 < 0 || ds_x2 >= vid.width || ds_y > vid.height)
; 195  : 		I_Error("R_DrawSpan_16: %d to %d at %d", ds_x1, ds_x2, ds_y);
; 196  : #endif
; 197  : 
; 198  : 	xfrac = ds_xfrac;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xfrac
  0000e	89 45 fc	 mov	 DWORD PTR _xfrac$[ebp], eax

; 199  : 	yfrac = ds_yfrac;

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_yfrac
  00016	89 45 f8	 mov	 DWORD PTR _yfrac$[ebp], eax

; 200  : 
; 201  : 	dest = (INT16 *)(void *)(ylookup[ds_y] + columnofs[ds_x1]);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_y
  0001e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ds_x1
  0002b	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00032	89 4d f4	 mov	 DWORD PTR _dest$[ebp], ecx

; 202  : 
; 203  : 	// We do not check for zero spans here?
; 204  : 	count = ds_x2 - ds_x1;

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_x2
  0003a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ds_x1
  00040	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax

; 205  : 
; 206  : 	if (count <= 0) // We do now!

  00043	83 7d f0 00	 cmp	 DWORD PTR _count$[ebp], 0
  00047	7f 02		 jg	 SHORT $LN5@R_DrawSpan

; 207  : 		return;

  00049	eb 6e		 jmp	 SHORT $LN3@R_DrawSpan
$LN5@R_DrawSpan:

; 208  : 
; 209  : 	do
; 210  : 	{
; 211  : 		// Current texture index in u, v.
; 212  : 		spot = ((yfrac>>(16-6))&(63*64)) + ((xfrac>>16)&63);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _yfrac$[ebp]
  0004e	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00051	25 c0 0f 00 00	 and	 eax, 4032		; 00000fc0H
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _xfrac$[ebp]
  00059	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0005c	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0005f	03 c1		 add	 eax, ecx
  00061	89 45 ec	 mov	 DWORD PTR _spot$[ebp], eax

; 213  : 
; 214  : 		// Lookup pixel from flat texture tile, re-index using light/colormap.
; 215  : 		*dest++ = hicolormaps[((INT16 *)(void *)ds_source)[spot]>>1];

  00064	8b 45 ec	 mov	 eax, DWORD PTR _spot$[ebp]
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ds_source
  0006d	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00071	d1 fa		 sar	 edx, 1
  00073	8b 45 f4	 mov	 eax, DWORD PTR _dest$[ebp]
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hicolormaps
  0007c	66 8b 14 51	 mov	 dx, WORD PTR [ecx+edx*2]
  00080	66 89 10	 mov	 WORD PTR [eax], dx
  00083	8b 45 f4	 mov	 eax, DWORD PTR _dest$[ebp]
  00086	83 c0 02	 add	 eax, 2
  00089	89 45 f4	 mov	 DWORD PTR _dest$[ebp], eax

; 216  : 
; 217  : 		// Next step in u, v.
; 218  : 		xfrac += ds_xstep;

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _xfrac$[ebp]
  0008f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ds_xstep
  00095	89 45 fc	 mov	 DWORD PTR _xfrac$[ebp], eax

; 219  : 		yfrac += ds_ystep;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _yfrac$[ebp]
  0009b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ds_ystep
  000a1	89 45 f8	 mov	 DWORD PTR _yfrac$[ebp], eax

; 220  : 	} while (count--);

  000a4	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  000a7	89 45 a8	 mov	 DWORD PTR tv87[ebp], eax
  000aa	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  000ad	83 e9 01	 sub	 ecx, 1
  000b0	89 4d f0	 mov	 DWORD PTR _count$[ebp], ecx
  000b3	83 7d a8 00	 cmp	 DWORD PTR tv87[ebp], 0
  000b7	75 92		 jne	 SHORT $LN5@R_DrawSpan
$LN3@R_DrawSpan:

; 221  : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_R_DrawSpan_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw16.c
;	COMDAT _R_DrawTranslatedColumn_16
_TEXT	SEGMENT
tv91 = -84						; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawTranslatedColumn_16 PROC				; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 151  : 	INT32 count;
; 152  : 	INT16 *dest;
; 153  : 	fixed_t frac, fracstep;
; 154  : 
; 155  : 	count = dc_yh - dc_yl;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 156  : 	if (count < 0)

  00017	79 05		 jns	 SHORT $LN5@R_DrawTran

; 157  : 		return;

  00019	e9 99 00 00 00	 jmp	 $LN3@R_DrawTran
$LN5@R_DrawTran:

; 158  : 
; 159  : #ifdef RANGECHECK
; 160  : 	if (dc_x >= vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 161  : 		I_Error("R_DrawTranslatedColumn_16: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 162  : #endif
; 163  : 
; 164  : 	dest = (INT16 *)(void *)(ylookup[dc_yl] + columnofs[dc_x]);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00023	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  0002a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_x
  00030	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00037	89 4d f8	 mov	 DWORD PTR _dest$[ebp], ecx

; 165  : 
; 166  : 	// Looks familiar.
; 167  : 	fracstep = dc_iscale;

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  0003f	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 168  : 	frac = dc_texturemid + (dc_yl - centery)*fracstep;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00047	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _centery
  0004d	0f af 45 f0	 imul	 eax, DWORD PTR _fracstep$[ebp]
  00051	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00057	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN4@R_DrawTran:

; 169  : 
; 170  : 	// Here we do an additional index re-mapping.
; 171  : 	do
; 172  : 	{
; 173  : 		*dest = color8to16[dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]]];

  0005a	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0005d	c1 f8 10	 sar	 eax, 16			; 00000010H
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00066	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_translation
  0006f	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  00079	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00080	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _color8to16[eax*2]
  00088	66 89 11	 mov	 WORD PTR [ecx], dx

; 174  : 		dest += vid.width;

  0008b	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00093	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00096	89 55 f8	 mov	 DWORD PTR _dest$[ebp], edx

; 175  : 
; 176  : 		frac += fracstep;

  00099	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0009c	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  0009f	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 177  : 	} while (count--);

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000a5	89 45 ac	 mov	 DWORD PTR tv91[ebp], eax
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  000ab	83 e9 01	 sub	 ecx, 1
  000ae	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  000b1	83 7d ac 00	 cmp	 DWORD PTR tv91[ebp], 0
  000b5	75 a3		 jne	 SHORT $LN4@R_DrawTran
$LN3@R_DrawTran:

; 178  : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_R_DrawTranslatedColumn_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw16.c
;	COMDAT _R_DrawTranslucentColumn_16
_TEXT	SEGMENT
tv131 = -84						; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawTranslucentColumn_16 PROC			; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	INT32 count;
; 112  : 	INT16 *dest;
; 113  : 	fixed_t frac, fracstep;
; 114  : 
; 115  : 	// check out coords for src*
; 116  : 	if ((dc_yl < 0) || (dc_x >= vid.width))

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dc_yl, 0
  00010	7c 0d		 jl	 SHORT $LN6@R_DrawTran
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  00017	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  0001d	7c 05		 jl	 SHORT $LN5@R_DrawTran
$LN6@R_DrawTran:

; 117  : 		return;

  0001f	e9 ba 00 00 00	 jmp	 $LN3@R_DrawTran
$LN5@R_DrawTran:

; 118  : 
; 119  : 	count = dc_yh - dc_yl;

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  00029	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  0002f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 120  : 	if (count < 0)

  00032	79 05		 jns	 SHORT $LN7@R_DrawTran

; 121  : 		return;

  00034	e9 a5 00 00 00	 jmp	 $LN3@R_DrawTran
$LN7@R_DrawTran:

; 122  : 
; 123  : #ifdef RANGECHECK
; 124  : 	if (dc_x >= vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 125  : 		I_Error("R_DrawTranslucentColumn_16: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 126  : #endif
; 127  : 
; 128  : 	// FIXME. As above.
; 129  : 	dest = (INT16 *)(void *)(ylookup[dc_yl] + columnofs[dc_x]);

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0003e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_x
  0004b	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00052	89 4d f8	 mov	 DWORD PTR _dest$[ebp], ecx

; 130  : 
; 131  : 	// Looks familiar.
; 132  : 	fracstep = dc_iscale;

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  0005a	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 133  : 	frac = dc_texturemid + (dc_yl - centery)*fracstep;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00062	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _centery
  00068	0f af 45 f0	 imul	 eax, DWORD PTR _fracstep$[ebp]
  0006c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00072	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN4@R_DrawTran:

; 134  : 
; 135  : 	// Here we do an additional index re-mapping.
; 136  : 	do
; 137  : 	{
; 138  : 		*dest = (INT16)((INT16)((color8to16[dc_source[frac>>FRACBITS]]>>1) & 0x39ce)

  00075	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00078	c1 f8 10	 sar	 eax, 16			; 00000010H
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00081	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00085	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR _color8to16[edx*2]
  0008d	d1 f8		 sar	 eax, 1
  0008f	25 ce 39 00 00	 and	 eax, 14798		; 000039ceH
  00094	0f bf c8	 movsx	 ecx, ax
  00097	8b 55 f8	 mov	 edx, DWORD PTR _dest$[ebp]
  0009a	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0009d	25 de 7b 00 00	 and	 eax, 31710		; 00007bdeH
  000a2	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  000a7	0f bf d0	 movsx	 edx, ax
  000aa	03 ca		 add	 ecx, edx
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  000af	66 89 08	 mov	 WORD PTR [eax], cx

; 139  : 			+ (INT16)(((*dest & HIMASK1)) & 0x7fff));
; 140  : 
; 141  : 		dest += vid.width;

  000b2	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  000ba	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000bd	89 55 f8	 mov	 DWORD PTR _dest$[ebp], edx

; 142  : 		frac += fracstep;

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000c3	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  000c6	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 143  : 	} while (count--);

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000cc	89 45 ac	 mov	 DWORD PTR tv131[ebp], eax
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  000d2	83 e9 01	 sub	 ecx, 1
  000d5	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  000d8	83 7d ac 00	 cmp	 DWORD PTR tv131[ebp], 0
  000dc	75 97		 jne	 SHORT $LN4@R_DrawTran
$LN3@R_DrawTran:

; 144  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_R_DrawTranslucentColumn_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw16.c
;	COMDAT _R_DrawWallColumn_16
_TEXT	SEGMENT
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawWallColumn_16 PROC				; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 76   : 	INT32 count;
; 77   : 	INT16 *dest;
; 78   : 	fixed_t frac, fracstep;
; 79   : 
; 80   : 	count = dc_yh - dc_yl + 1;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 81   : 
; 82   : 	// Zero length, column does not exceed a pixel.
; 83   : 	if (count <= 0)

  0001a	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0001e	7f 05		 jg	 SHORT $LN5@R_DrawWall

; 84   : 		return;

  00020	e9 85 00 00 00	 jmp	 $LN3@R_DrawWall
$LN5@R_DrawWall:

; 85   : 
; 86   : #ifdef RANGECHECK
; 87   : 	if (dc_x >= vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 88   : 		I_Error("R_DrawWallColumn_16: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 89   : #endif
; 90   : 
; 91   : 	dest = (INT16 *)(void *)(ylookup[dc_yl] + columnofs[dc_x]);

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0002a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00031	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_x
  00037	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  0003e	89 4d f8	 mov	 DWORD PTR _dest$[ebp], ecx

; 92   : 
; 93   : 	fracstep = dc_iscale;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00046	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 94   : 	frac = dc_texturemid + (dc_yl - centery)*fracstep;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0004e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _centery
  00054	0f af 45 f0	 imul	 eax, DWORD PTR _fracstep$[ebp]
  00058	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  0005e	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN4@R_DrawWall:

; 95   : 
; 96   : 	do
; 97   : 	{
; 98   : 		*dest = hicolormaps[((INT16 *)(void *)dc_source)[(frac>>FRACBITS)&255]>>1];

  00061	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00064	c1 f8 10	 sar	 eax, 16			; 00000010H
  00067	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00072	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00076	d1 fa		 sar	 edx, 1
  00078	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hicolormaps
  00081	66 8b 14 51	 mov	 dx, WORD PTR [ecx+edx*2]
  00085	66 89 10	 mov	 WORD PTR [eax], dx

; 99   : 
; 100  : 		dest += vid.width;

  00088	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00090	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00093	89 55 f8	 mov	 DWORD PTR _dest$[ebp], edx

; 101  : 		frac += fracstep;

  00096	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00099	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  0009c	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 102  : 	} while (--count);

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000a2	83 e8 01	 sub	 eax, 1
  000a5	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  000a8	75 b7		 jne	 SHORT $LN4@R_DrawWall
$LN3@R_DrawWall:

; 103  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_R_DrawWallColumn_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw16.c
;	COMDAT _R_DrawColumn_16
_TEXT	SEGMENT
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawColumn_16 PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 33   : 	INT32 count;
; 34   : 	INT16 *dest;
; 35   : 	fixed_t frac, fracstep;
; 36   : 
; 37   : 	count = dc_yh - dc_yl + 1;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 38   : 
; 39   : 	// Zero length, column does not exceed a pixel.
; 40   : 	if (count <= 0)

  0001a	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0001e	7f 05		 jg	 SHORT $LN5@R_DrawColu

; 41   : 		return;

  00020	e9 83 00 00 00	 jmp	 $LN3@R_DrawColu
$LN5@R_DrawColu:

; 42   : 
; 43   : #ifdef RANGECHECK
; 44   : 	if (dc_x >= vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 45   : 		I_Error("R_DrawColumn_16: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 46   : #endif
; 47   : 
; 48   : 	// Framebuffer destination address.
; 49   : 	// Use ylookup LUT to avoid multiply with ScreenWidth.
; 50   : 	// Use columnofs LUT for subwindows?
; 51   : 	dest = (INT16 *)(void *)(ylookup[dc_yl] + columnofs[dc_x]);

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0002a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00031	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_x
  00037	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  0003e	89 4d f8	 mov	 DWORD PTR _dest$[ebp], ecx

; 52   : 
; 53   : 	// Determine scaling, which is the only mapping to be done.
; 54   : 	fracstep = dc_iscale;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00046	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 55   : 	frac = dc_texturemid + (dc_yl - centery)*fracstep;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0004e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _centery
  00054	0f af 45 f0	 imul	 eax, DWORD PTR _fracstep$[ebp]
  00058	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  0005e	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN4@R_DrawColu:

; 56   : 
; 57   : 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
; 58   : 	// This is as fast as it gets.
; 59   : 
; 60   : 	do
; 61   : 	{
; 62   : 		// Re-map color indices from wall texture column using a lighting/special effects LUT.
; 63   : 		*dest = hicolormaps[((INT16 *)(void *)dc_source)[(frac>>FRACBITS)&127]>>1];

  00061	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00064	c1 f8 10	 sar	 eax, 16			; 00000010H
  00067	83 e0 7f	 and	 eax, 127		; 0000007fH
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00070	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00074	d1 fa		 sar	 edx, 1
  00076	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hicolormaps
  0007f	66 8b 14 51	 mov	 dx, WORD PTR [ecx+edx*2]
  00083	66 89 10	 mov	 WORD PTR [eax], dx

; 64   : 
; 65   : 		dest += vid.width;

  00086	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  0008e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00091	89 55 f8	 mov	 DWORD PTR _dest$[ebp], edx

; 66   : 		frac += fracstep;

  00094	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00097	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  0009a	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 67   : 	} while (--count);

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000a0	83 e8 01	 sub	 eax, 1
  000a3	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  000a6	75 b9		 jne	 SHORT $LN4@R_DrawColu
$LN3@R_DrawColu:

; 68   : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_R_DrawColumn_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawColumnShadowed_8
_TEXT	SEGMENT
_solid$ = -28						; size = 4
_bheight$ = -24						; size = 4
_height$ = -20						; size = 4
_i$ = -16						; size = 4
_realyl$ = -12						; size = 4
_realyh$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawColumnShadowed_8 PROC				; COMDAT

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 969  : 	INT32 count, realyh, realyl, i, height, bheight = 0, solid = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bheight$[ebp], 0
  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _solid$[ebp], 0

; 970  : 
; 971  : 	realyh = dc_yh;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0001c	89 45 f8	 mov	 DWORD PTR _realyh$[ebp], eax

; 972  : 	realyl = dc_yl;

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00024	89 45 f4	 mov	 DWORD PTR _realyl$[ebp], eax

; 973  : 
; 974  : 	count = dc_yh - dc_yl;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0002c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00032	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 975  : 
; 976  : 	// Zero length, column does not exceed a pixel.
; 977  : 	if (count < 0)

  00035	79 05		 jns	 SHORT $LN5@R_DrawColu

; 978  : 		return;

  00037	e9 0f 01 00 00	 jmp	 $LN12@R_DrawColu
$LN5@R_DrawColu:

; 979  : 
; 980  : #ifdef RANGECHECK
; 981  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 982  : 		I_Error("R_DrawColumnShadowed_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 983  : #endif
; 984  : 
; 985  : 	// This runs through the lightlist from top to bottom and cuts up the column accordingly.
; 986  : 	for (i = 0; i < dc_numlights; i++)

  0003c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN4@R_DrawColu
$LN2@R_DrawColu:
  00045	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_DrawColu:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00051	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dc_numlights
  00057	0f 8d d6 00 00
	00		 jge	 $LN3@R_DrawColu

; 987  : 	{
; 988  : 		// If the height of the light is above the column, get the colormap
; 989  : 		// anyway because the lighting of the top should be affected.
; 990  : 		solid = dc_lightlist[i].flags & FF_CUTSOLIDS;

  0005d	6b 45 f0 24	 imul	 eax, DWORD PTR _i$[ebp], 36
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_lightlist
  00067	8b 54 01 1c	 mov	 edx, DWORD PTR [ecx+eax+28]
  0006b	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00071	89 55 e4	 mov	 DWORD PTR _solid$[ebp], edx

; 991  : 
; 992  : 		height = dc_lightlist[i].height >> LIGHTSCALESHIFT;

  00074	6b 45 f0 24	 imul	 eax, DWORD PTR _i$[ebp], 36
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_lightlist
  0007e	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00081	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  00084	89 55 ec	 mov	 DWORD PTR _height$[ebp], edx

; 993  : 		if (solid)

  00087	83 7d e4 00	 cmp	 DWORD PTR _solid$[ebp], 0
  0008b	74 14		 je	 SHORT $LN6@R_DrawColu

; 994  : 			bheight = dc_lightlist[i].botheight >> LIGHTSCALESHIFT;

  0008d	6b 45 f0 24	 imul	 eax, DWORD PTR _i$[ebp], 36
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_lightlist
  00097	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0009b	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  0009e	89 55 e8	 mov	 DWORD PTR _bheight$[ebp], edx
$LN6@R_DrawColu:

; 995  : 		if (height <= dc_yl)

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _height$[ebp]
  000a4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dc_yl
  000aa	7f 31		 jg	 SHORT $LN7@R_DrawColu

; 996  : 		{
; 997  : 			dc_colormap = dc_lightlist[i].rcolormap;

  000ac	6b 45 f0 24	 imul	 eax, DWORD PTR _i$[ebp], 36
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_lightlist
  000b6	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  000ba	89 15 00 00 00
	00		 mov	 DWORD PTR _dc_colormap, edx

; 998  : 			if (solid && dc_yl < bheight)

  000c0	83 7d e4 00	 cmp	 DWORD PTR _solid$[ebp], 0
  000c4	74 12		 je	 SHORT $LN8@R_DrawColu
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  000cb	3b 45 e8	 cmp	 eax, DWORD PTR _bheight$[ebp]
  000ce	7d 08		 jge	 SHORT $LN8@R_DrawColu

; 999  : 				dc_yl = bheight;

  000d0	8b 45 e8	 mov	 eax, DWORD PTR _bheight$[ebp]
  000d3	a3 00 00 00 00	 mov	 DWORD PTR _dc_yl, eax
$LN8@R_DrawColu:

; 1000 : 			continue;

  000d8	e9 68 ff ff ff	 jmp	 $LN2@R_DrawColu
$LN7@R_DrawColu:

; 1001 : 		}
; 1002 : 		// Found a break in the column!
; 1003 : 		dc_yh = height;

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _height$[ebp]
  000e0	a3 00 00 00 00	 mov	 DWORD PTR _dc_yh, eax

; 1004 : 
; 1005 : 		if (dc_yh > realyh)

  000e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  000ea	3b 45 f8	 cmp	 eax, DWORD PTR _realyh$[ebp]
  000ed	7e 08		 jle	 SHORT $LN9@R_DrawColu

; 1006 : 			dc_yh = realyh;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _realyh$[ebp]
  000f2	a3 00 00 00 00	 mov	 DWORD PTR _dc_yh, eax
$LN9@R_DrawColu:

; 1007 : 		R_DrawColumn_8();

  000f7	e8 00 00 00 00	 call	 _R_DrawColumn_8
  000fc	90		 npad	 1

; 1008 : 		if (solid)

  000fd	83 7d e4 00	 cmp	 DWORD PTR _solid$[ebp], 0
  00101	74 0a		 je	 SHORT $LN10@R_DrawColu

; 1009 : 			dc_yl = bheight;

  00103	8b 45 e8	 mov	 eax, DWORD PTR _bheight$[ebp]
  00106	a3 00 00 00 00	 mov	 DWORD PTR _dc_yl, eax
  0010b	eb 0d		 jmp	 SHORT $LN11@R_DrawColu
$LN10@R_DrawColu:

; 1010 : 		else
; 1011 : 			dc_yl = dc_yh + 1;

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  00112	83 c0 01	 add	 eax, 1
  00115	a3 00 00 00 00	 mov	 DWORD PTR _dc_yl, eax
$LN11@R_DrawColu:

; 1012 : 
; 1013 : 		dc_colormap = dc_lightlist[i].rcolormap;

  0011a	6b 45 f0 24	 imul	 eax, DWORD PTR _i$[ebp], 36
  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_lightlist
  00124	8b 54 01 18	 mov	 edx, DWORD PTR [ecx+eax+24]
  00128	89 15 00 00 00
	00		 mov	 DWORD PTR _dc_colormap, edx

; 1014 : 	}

  0012e	e9 12 ff ff ff	 jmp	 $LN2@R_DrawColu
$LN3@R_DrawColu:

; 1015 : 	dc_yh = realyh;

  00133	8b 45 f8	 mov	 eax, DWORD PTR _realyh$[ebp]
  00136	a3 00 00 00 00	 mov	 DWORD PTR _dc_yh, eax

; 1016 : 	if (dc_yl <= realyh)

  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00140	3b 45 f8	 cmp	 eax, DWORD PTR _realyh$[ebp]
  00143	7f 06		 jg	 SHORT $LN12@R_DrawColu

; 1017 : 		R_DrawWallColumn_8();

  00145	e8 00 00 00 00	 call	 _R_DrawWallColumn_8
  0014a	90		 npad	 1
$LN12@R_DrawColu:

; 1018 : }

  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_R_DrawColumnShadowed_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawFogColumn_8
_TEXT	SEGMENT
tv76 = -76						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawFogColumn_8 PROC					; COMDAT

; 932  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 933  : 	INT32 count;
; 934  : 	UINT8 *dest;
; 935  : 
; 936  : 	count = dc_yh - dc_yl;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 937  : 
; 938  : 	// Zero length, column does not exceed a pixel.
; 939  : 	if (count < 0)

  00017	79 02		 jns	 SHORT $LN5@R_DrawFogC

; 940  : 		return;

  00019	eb 4f		 jmp	 SHORT $LN3@R_DrawFogC
$LN5@R_DrawFogC:

; 941  : 
; 942  : #ifdef RANGECHECK
; 943  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 944  : 		I_Error("R_DrawFogColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 945  : #endif
; 946  : 
; 947  : 	// Framebuffer destination address.
; 948  : 	// Use ylookup LUT to avoid multiply with ScreenWidth.
; 949  : 	// Use columnofs LUT for subwindows?
; 950  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 951  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00020	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00027	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  0002d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00033	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax
$LN4@R_DrawFogC:

; 952  : 
; 953  : 	// Determine scaling, which is the only mapping to be done.
; 954  : 	do
; 955  : 	{
; 956  : 		// Simple. Apply the colormap to what's already on the screen.
; 957  : 		*dest = dc_colormap[*dest];

  00036	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00039	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003c	8b 55 f8	 mov	 edx, DWORD PTR _dest$[ebp]
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_colormap
  00044	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00047	88 0a		 mov	 BYTE PTR [edx], cl

; 958  : 		dest += vid.width;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0004c	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00052	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 959  : 	} while (count--);

  00055	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00058	89 45 b4	 mov	 DWORD PTR tv76[ebp], eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0005e	83 e9 01	 sub	 ecx, 1
  00061	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00064	83 7d b4 00	 cmp	 DWORD PTR tv76[ebp], 0
  00068	75 cc		 jne	 SHORT $LN4@R_DrawFogC
$LN3@R_DrawFogC:

; 960  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_R_DrawFogColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawFogSpan_8
_TEXT	SEGMENT
tv135 = -84						; size = 4
_count$ = -16						; size = 4
_dest$ = -12						; size = 4
_transmap$ = -8						; size = 4
_colormap$ = -4						; size = 4
_R_DrawFogSpan_8 PROC					; COMDAT

; 896  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 897  : 	UINT8 *colormap;
; 898  : 	UINT8 *transmap;
; 899  : 	UINT8 *dest;
; 900  : 
; 901  : 	size_t count;
; 902  : 
; 903  : 	colormap = ds_colormap;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_colormap
  0000e	89 45 fc	 mov	 DWORD PTR _colormap$[ebp], eax

; 904  : 	transmap = ds_transmap;

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_transmap
  00016	89 45 f8	 mov	 DWORD PTR _transmap$[ebp], eax

; 905  : 	//dest = ylookup[ds_y] + columnofs[ds_x1];
; 906  : 	dest = &topleft[ds_y *vid.width + ds_x1];

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_y
  0001e	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00025	03 05 00 00 00
	00		 add	 eax, DWORD PTR _ds_x1
  0002b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00031	89 45 f4	 mov	 DWORD PTR _dest$[ebp], eax

; 907  : 
; 908  : 	count = ds_x2 - ds_x1 + 1;

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_x2
  00039	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ds_x1
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax
$LN2@R_DrawFogS:

; 909  : 
; 910  : 	while (count >= 4)

  00045	83 7d f0 04	 cmp	 DWORD PTR _count$[ebp], 4
  00049	0f 82 a1 00 00
	00		 jb	 $LN3@R_DrawFogS

; 911  : 	{
; 912  : 		dest[0] = colormap[dest[0]];

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	6b c8 00	 imul	 ecx, eax, 0
  00057	8b 55 f4	 mov	 edx, DWORD PTR _dest$[ebp]
  0005a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0005e	b9 01 00 00 00	 mov	 ecx, 1
  00063	6b d1 00	 imul	 edx, ecx, 0
  00066	8b 4d f4	 mov	 ecx, DWORD PTR _dest$[ebp]
  00069	8b 75 fc	 mov	 esi, DWORD PTR _colormap$[ebp]
  0006c	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0006f	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 913  : 		dest[1] = colormap[dest[1]];

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	c1 e0 00	 shl	 eax, 0
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0007d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	c1 e0 00	 shl	 eax, 0
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0008c	8b 75 fc	 mov	 esi, DWORD PTR _colormap$[ebp]
  0008f	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00092	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 914  : 		dest[2] = colormap[dest[2]];

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	d1 e0		 shl	 eax, 1
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0009f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	d1 e0		 shl	 eax, 1
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR _dest$[ebp]
  000ad	8b 75 fc	 mov	 esi, DWORD PTR _colormap$[ebp]
  000b0	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000b3	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 915  : 		dest[3] = colormap[dest[3]];

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	6b c8 03	 imul	 ecx, eax, 3
  000be	8b 55 f4	 mov	 edx, DWORD PTR _dest$[ebp]
  000c1	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000c5	b9 01 00 00 00	 mov	 ecx, 1
  000ca	6b d1 03	 imul	 edx, ecx, 3
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR _dest$[ebp]
  000d0	8b 75 fc	 mov	 esi, DWORD PTR _colormap$[ebp]
  000d3	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  000d6	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 916  : 
; 917  : 		dest += 4;

  000d9	8b 45 f4	 mov	 eax, DWORD PTR _dest$[ebp]
  000dc	83 c0 04	 add	 eax, 4
  000df	89 45 f4	 mov	 DWORD PTR _dest$[ebp], eax

; 918  : 		count -= 4;

  000e2	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  000e5	83 e8 04	 sub	 eax, 4
  000e8	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax

; 919  : 	}

  000eb	e9 55 ff ff ff	 jmp	 $LN2@R_DrawFogS
$LN3@R_DrawFogS:

; 920  : 
; 921  : 	while (count--)

  000f0	8b 45 f0	 mov	 eax, DWORD PTR _count$[ebp]
  000f3	89 45 ac	 mov	 DWORD PTR tv135[ebp], eax
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR _count$[ebp]
  000f9	83 e9 01	 sub	 ecx, 1
  000fc	89 4d f0	 mov	 DWORD PTR _count$[ebp], ecx
  000ff	83 7d ac 00	 cmp	 DWORD PTR tv135[ebp], 0
  00103	74 1c		 je	 SHORT $LN5@R_DrawFogS

; 922  : 	{
; 923  : 		*dest = colormap[*dest];

  00105	8b 45 f4	 mov	 eax, DWORD PTR _dest$[ebp]
  00108	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010b	8b 55 f4	 mov	 edx, DWORD PTR _dest$[ebp]
  0010e	8b 45 fc	 mov	 eax, DWORD PTR _colormap$[ebp]
  00111	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00114	88 0a		 mov	 BYTE PTR [edx], cl

; 924  : 		dest++;

  00116	8b 45 f4	 mov	 eax, DWORD PTR _dest$[ebp]
  00119	83 c0 01	 add	 eax, 1
  0011c	89 45 f4	 mov	 DWORD PTR _dest$[ebp], eax

; 925  : 	}

  0011f	eb cf		 jmp	 SHORT $LN3@R_DrawFogS
$LN5@R_DrawFogS:

; 926  : }

  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
_R_DrawFogSpan_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_Draw2sMultiPatchColumn_8
_TEXT	SEGMENT
tv212 = -112						; size = 8
tv79 = -108						; size = 4
_val$1 = -37						; size = 1
_heightmask$2 = -36					; size = 8
_colormap$3 = -28					; size = 4
_source$4 = -24						; size = 4
_fracstep$ = -20					; size = 4
_frac$ = -16						; size = 8
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_Draw2sMultiPatchColumn_8 PROC			; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 191  : 	INT32 count;
; 192  : 	register UINT8 *dest;
; 193  : 	register INT64 frac;
; 194  : 	fixed_t fracstep;
; 195  : 
; 196  : 	count = dc_yh - dc_yl;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 197  : 
; 198  : 	if (count < 0) // Zero length, column does not exceed a pixel.

  00017	79 05		 jns	 SHORT $LN11@R_Draw2sMu

; 199  : 		return;

  00019	e9 d4 02 00 00	 jmp	 $LN21@R_Draw2sMu
$LN11@R_Draw2sMu:

; 200  : 
; 201  : #ifdef RANGECHECK
; 202  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 203  : 		return;
; 204  : #endif
; 205  : 
; 206  : 	// Framebuffer destination address.
; 207  : 	// Use ylookup LUT to avoid multiply with ScreenWidth.
; 208  : 	// Use columnofs LUT for subwindows?
; 209  : 
; 210  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 211  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00023	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0002a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00036	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 212  : 
; 213  : 	count++;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 214  : 
; 215  : 	// Determine scaling, which is the only mapping to be done.
; 216  : 	fracstep = dc_iscale;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00047	89 45 ec	 mov	 DWORD PTR _fracstep$[ebp], eax

; 217  : 	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
; 218  : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  0004a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  00051	85 c0		 test	 eax, eax
  00053	75 09		 jne	 SHORT $LN23@R_Draw2sMu
  00055	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN24@R_Draw2sMu
$LN23@R_Draw2sMu:
  0005e	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN24@R_Draw2sMu:
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  00068	51		 push	 ecx
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  0006f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00072	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _FixedMul
  0007e	83 c4 08	 add	 esp, 8
  00081	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00087	0f af 45 94	 imul	 eax, DWORD PTR tv79[ebp]
  0008b	99		 cdq
  0008c	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0008f	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 219  : 
; 220  : 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
; 221  : 	// This is as fast as it gets.
; 222  : 	{
; 223  : 		register const UINT8 *source = dc_source;

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_source
  00097	89 45 e8	 mov	 DWORD PTR _source$4[ebp], eax

; 224  : 		register const lighttable_t *colormap = dc_colormap;

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_colormap
  0009f	89 45 e4	 mov	 DWORD PTR _colormap$3[ebp], eax

; 225  : 		register INT64 heightmask = dc_texheight-1;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000a7	83 e8 01	 sub	 eax, 1
  000aa	99		 cdq
  000ab	89 45 dc	 mov	 DWORD PTR _heightmask$2[ebp], eax
  000ae	89 55 e0	 mov	 DWORD PTR _heightmask$2[ebp+4], edx

; 226  : 		register UINT8 val;
; 227  : 		if (dc_texheight & heightmask)   // not a power of 2 -- killough

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000b6	99		 cdq
  000b7	23 45 dc	 and	 eax, DWORD PTR _heightmask$2[ebp]
  000ba	23 55 e0	 and	 edx, DWORD PTR _heightmask$2[ebp+4]
  000bd	89 45 90	 mov	 DWORD PTR tv212[ebp], eax
  000c0	89 55 94	 mov	 DWORD PTR tv212[ebp+4], edx
  000c3	8b 45 90	 mov	 eax, DWORD PTR tv212[ebp]
  000c6	0b 45 94	 or	 eax, DWORD PTR tv212[ebp+4]
  000c9	0f 84 0c 01 00
	00		 je	 $LN12@R_Draw2sMu

; 228  : 		{
; 229  : 			heightmask++;

  000cf	8b 45 dc	 mov	 eax, DWORD PTR _heightmask$2[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	8b 4d e0	 mov	 ecx, DWORD PTR _heightmask$2[ebp+4]
  000d8	83 d1 00	 adc	 ecx, 0
  000db	89 45 dc	 mov	 DWORD PTR _heightmask$2[ebp], eax
  000de	89 4d e0	 mov	 DWORD PTR _heightmask$2[ebp+4], ecx

; 230  : 			heightmask <<= FRACBITS;

  000e1	8b 45 dc	 mov	 eax, DWORD PTR _heightmask$2[ebp]
  000e4	8b 55 e0	 mov	 edx, DWORD PTR _heightmask$2[ebp+4]
  000e7	b1 10		 mov	 cl, 16			; 00000010H
  000e9	e8 00 00 00 00	 call	 __allshl
  000ee	89 45 dc	 mov	 DWORD PTR _heightmask$2[ebp], eax
  000f1	89 55 e0	 mov	 DWORD PTR _heightmask$2[ebp+4], edx

; 231  : 
; 232  : 			if (frac < 0)

  000f4	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp+4], 0
  000f8	7f 2c		 jg	 SHORT $LN14@R_Draw2sMu
  000fa	7c 06		 jl	 SHORT $LN25@R_Draw2sMu
  000fc	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00100	73 24		 jae	 SHORT $LN14@R_Draw2sMu
$LN25@R_Draw2sMu:

; 233  : 				while ((frac += heightmask) <  0);

  00102	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  00105	03 45 dc	 add	 eax, DWORD PTR _heightmask$2[ebp]
  00108	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  0010b	13 4d e0	 adc	 ecx, DWORD PTR _heightmask$2[ebp+4]
  0010e	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00111	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
  00114	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp+4], 0
  00118	7f 0a		 jg	 SHORT $LN3@R_Draw2sMu
  0011a	7c 06		 jl	 SHORT $LN26@R_Draw2sMu
  0011c	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00120	73 02		 jae	 SHORT $LN3@R_Draw2sMu
$LN26@R_Draw2sMu:
  00122	eb de		 jmp	 SHORT $LN25@R_Draw2sMu
$LN3@R_Draw2sMu:
  00124	eb 26		 jmp	 SHORT $LN5@R_Draw2sMu
$LN14@R_Draw2sMu:

; 234  : 			else
; 235  : 				while (frac >= heightmask)

  00126	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp+4]
  00129	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$2[ebp+4]
  0012c	7c 1e		 jl	 SHORT $LN5@R_Draw2sMu
  0012e	7f 08		 jg	 SHORT $LN27@R_Draw2sMu
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  00133	3b 4d dc	 cmp	 ecx, DWORD PTR _heightmask$2[ebp]
  00136	72 14		 jb	 SHORT $LN5@R_Draw2sMu
$LN27@R_Draw2sMu:

; 236  : 					frac -= heightmask;

  00138	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0013b	2b 45 dc	 sub	 eax, DWORD PTR _heightmask$2[ebp]
  0013e	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  00141	1b 4d e0	 sbb	 ecx, DWORD PTR _heightmask$2[ebp+4]
  00144	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00147	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
  0014a	eb da		 jmp	 SHORT $LN14@R_Draw2sMu
$LN5@R_Draw2sMu:

; 237  : 
; 238  : 			do
; 239  : 			{
; 240  : 				// Re-map color indices from wall texture column
; 241  : 				//  using a lighting/special effects LUT.
; 242  : 				// heightmask is the Tutti-Frutti fix
; 243  : 				val = source[frac>>FRACBITS];

  0014c	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0014f	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00152	b1 10		 mov	 cl, 16			; 00000010H
  00154	e8 00 00 00 00	 call	 __allshr
  00159	6a 00		 push	 0
  0015b	6a 01		 push	 1
  0015d	52		 push	 edx
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 __allmul
  00164	8b 4d e8	 mov	 ecx, DWORD PTR _source$4[ebp]
  00167	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0016a	88 55 db	 mov	 BYTE PTR _val$1[ebp], dl

; 244  : 
; 245  : 				if (val != TRANSPARENTPIXEL)

  0016d	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  00171	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00176	74 0f		 je	 SHORT $LN16@R_Draw2sMu

; 246  : 					*dest = colormap[val];

  00178	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  0017c	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  0017f	8b 55 e4	 mov	 edx, DWORD PTR _colormap$3[ebp]
  00182	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00185	88 01		 mov	 BYTE PTR [ecx], al
$LN16@R_Draw2sMu:

; 247  : 
; 248  : 				dest += vid.width;

  00187	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0018a	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00190	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 249  : 				if ((frac += fracstep) >= heightmask)

  00193	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00196	99		 cdq
  00197	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  0019a	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  0019d	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  001a0	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx
  001a3	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp+4]
  001a6	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$2[ebp+4]
  001a9	7c 1c		 jl	 SHORT $LN17@R_Draw2sMu
  001ab	7f 08		 jg	 SHORT $LN28@R_Draw2sMu
  001ad	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  001b0	3b 4d dc	 cmp	 ecx, DWORD PTR _heightmask$2[ebp]
  001b3	72 12		 jb	 SHORT $LN17@R_Draw2sMu
$LN28@R_Draw2sMu:

; 250  : 					frac -= heightmask;

  001b5	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  001b8	2b 45 dc	 sub	 eax, DWORD PTR _heightmask$2[ebp]
  001bb	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  001be	1b 4d e0	 sbb	 ecx, DWORD PTR _heightmask$2[ebp+4]
  001c1	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  001c4	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
$LN17@R_Draw2sMu:

; 251  : 			} while (--count);

  001c7	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001ca	83 e8 01	 sub	 eax, 1
  001cd	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  001d0	0f 85 76 ff ff
	ff		 jne	 $LN5@R_Draw2sMu

; 252  : 		}

  001d6	e9 17 01 00 00	 jmp	 $LN21@R_Draw2sMu
$LN12@R_Draw2sMu:

; 253  : 		else
; 254  : 		{
; 255  : 			while ((count -= 2) >= 0) // texture height is a power of 2

  001db	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001de	83 e8 02	 sub	 eax, 2
  001e1	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  001e4	0f 88 bf 00 00
	00		 js	 $LN10@R_Draw2sMu

; 256  : 			{
; 257  : 				val = source[(frac>>FRACBITS) & heightmask];

  001ea	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  001ed	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  001f0	b1 10		 mov	 cl, 16			; 00000010H
  001f2	e8 00 00 00 00	 call	 __allshr
  001f7	23 45 dc	 and	 eax, DWORD PTR _heightmask$2[ebp]
  001fa	23 55 e0	 and	 edx, DWORD PTR _heightmask$2[ebp+4]
  001fd	6a 00		 push	 0
  001ff	6a 01		 push	 1
  00201	52		 push	 edx
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 __allmul
  00208	8b 4d e8	 mov	 ecx, DWORD PTR _source$4[ebp]
  0020b	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0020e	88 55 db	 mov	 BYTE PTR _val$1[ebp], dl

; 258  : 				if (val != TRANSPARENTPIXEL)

  00211	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  00215	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  0021a	74 0f		 je	 SHORT $LN18@R_Draw2sMu

; 259  : 					*dest = colormap[val];

  0021c	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  00220	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00223	8b 55 e4	 mov	 edx, DWORD PTR _colormap$3[ebp]
  00226	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00229	88 01		 mov	 BYTE PTR [ecx], al
$LN18@R_Draw2sMu:

; 260  : 				dest += vid.width;

  0022b	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0022e	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00234	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 261  : 				frac += fracstep;

  00237	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  0023a	99		 cdq
  0023b	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  0023e	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  00241	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00244	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 262  : 				val = source[(frac>>FRACBITS) & heightmask];

  00247	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0024a	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  0024d	b1 10		 mov	 cl, 16			; 00000010H
  0024f	e8 00 00 00 00	 call	 __allshr
  00254	23 45 dc	 and	 eax, DWORD PTR _heightmask$2[ebp]
  00257	23 55 e0	 and	 edx, DWORD PTR _heightmask$2[ebp+4]
  0025a	6a 00		 push	 0
  0025c	6a 01		 push	 1
  0025e	52		 push	 edx
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 __allmul
  00265	8b 4d e8	 mov	 ecx, DWORD PTR _source$4[ebp]
  00268	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0026b	88 55 db	 mov	 BYTE PTR _val$1[ebp], dl

; 263  : 				if (val != TRANSPARENTPIXEL)

  0026e	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  00272	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00277	74 0f		 je	 SHORT $LN19@R_Draw2sMu

; 264  : 					*dest = colormap[val];

  00279	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  0027d	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00280	8b 55 e4	 mov	 edx, DWORD PTR _colormap$3[ebp]
  00283	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00286	88 01		 mov	 BYTE PTR [ecx], al
$LN19@R_Draw2sMu:

; 265  : 				dest += vid.width;

  00288	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0028b	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00291	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 266  : 				frac += fracstep;

  00294	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00297	99		 cdq
  00298	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  0029b	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  0029e	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  002a1	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 267  : 			}

  002a4	e9 32 ff ff ff	 jmp	 $LN12@R_Draw2sMu
$LN10@R_Draw2sMu:

; 268  : 			if (count & 1)

  002a9	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  002ac	83 e0 01	 and	 eax, 1
  002af	74 41		 je	 SHORT $LN21@R_Draw2sMu

; 269  : 			{
; 270  : 				val = source[(frac>>FRACBITS) & heightmask];

  002b1	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  002b4	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  002b7	b1 10		 mov	 cl, 16			; 00000010H
  002b9	e8 00 00 00 00	 call	 __allshr
  002be	23 45 dc	 and	 eax, DWORD PTR _heightmask$2[ebp]
  002c1	23 55 e0	 and	 edx, DWORD PTR _heightmask$2[ebp+4]
  002c4	6a 00		 push	 0
  002c6	6a 01		 push	 1
  002c8	52		 push	 edx
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 __allmul
  002cf	8b 4d e8	 mov	 ecx, DWORD PTR _source$4[ebp]
  002d2	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  002d5	88 55 db	 mov	 BYTE PTR _val$1[ebp], dl

; 271  : 				if (val != TRANSPARENTPIXEL)

  002d8	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  002dc	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  002e1	74 0f		 je	 SHORT $LN21@R_Draw2sMu

; 272  : 					*dest = colormap[val];

  002e3	0f b6 45 db	 movzx	 eax, BYTE PTR _val$1[ebp]
  002e7	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  002ea	8b 55 e4	 mov	 edx, DWORD PTR _colormap$3[ebp]
  002ed	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  002f0	88 01		 mov	 BYTE PTR [ecx], al
$LN21@R_Draw2sMu:

; 273  : 			}
; 274  : 		}
; 275  : 	}
; 276  : }

  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	8b e5		 mov	 esp, ebp
  002f7	5d		 pop	 ebp
  002f8	c3		 ret	 0
_R_Draw2sMultiPatchColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawTranslucentSpan_8
_TEXT	SEGMENT
tv288 = -100						; size = 4
_count$ = -32						; size = 4
_dest$ = -28						; size = 4
_colormap$ = -24					; size = 4
_source$ = -20						; size = 4
_ystep$ = -16						; size = 4
_xstep$ = -12						; size = 4
_yposition$ = -8					; size = 4
_xposition$ = -4					; size = 4
_R_DrawTranslucentSpan_8 PROC				; COMDAT

; 817  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 818  : 	UINT32 xposition;
; 819  : 	UINT32 yposition;
; 820  : 	UINT32 xstep, ystep;
; 821  : 
; 822  : 	UINT8 *source;
; 823  : 	UINT8 *colormap;
; 824  : 	UINT8 *dest;
; 825  : 
; 826  : 	size_t count;
; 827  : 
; 828  : 	// SoM: we only need 6 bits for the integer part (0 thru 63) so the rest
; 829  : 	// can be used for the fraction part. This allows calculation of the memory address in the
; 830  : 	// texture with two shifts, an OR and one AND. (see below)
; 831  : 	// for texture sizes > 64 the amount of precision we can allow will decrease, but only by one
; 832  : 	// bit per power of two (obviously)
; 833  : 	// Ok, because I was able to eliminate the variable spot below, this function is now FASTER
; 834  : 	// than the original span renderer. Whodathunkit?
; 835  : 	xposition = ds_xfrac << nflatshiftup; yposition = ds_yfrac << nflatshiftup;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xfrac
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00014	d3 e0		 shl	 eax, cl
  00016	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_yfrac
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00024	d3 e0		 shl	 eax, cl
  00026	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 836  : 	xstep = ds_xstep << nflatshiftup; ystep = ds_ystep << nflatshiftup;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xstep
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00034	d3 e0		 shl	 eax, cl
  00036	89 45 f4	 mov	 DWORD PTR _xstep$[ebp], eax
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_ystep
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00044	d3 e0		 shl	 eax, cl
  00046	89 45 f0	 mov	 DWORD PTR _ystep$[ebp], eax

; 837  : 
; 838  : 	source = ds_source;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_source
  0004e	89 45 ec	 mov	 DWORD PTR _source$[ebp], eax

; 839  : 	colormap = ds_colormap;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_colormap
  00056	89 45 e8	 mov	 DWORD PTR _colormap$[ebp], eax

; 840  : 	dest = ylookup[ds_y] + columnofs[ds_x1];

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_y
  0005e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ds_x1
  0006b	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00072	89 4d e4	 mov	 DWORD PTR _dest$[ebp], ecx

; 841  : 	count = ds_x2 - ds_x1 + 1;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_x2
  0007a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ds_x1
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax
$LN2@R_DrawTran:

; 842  : 
; 843  : 	while (count >= 8)

  00086	83 7d e0 08	 cmp	 DWORD PTR _count$[ebp], 8
  0008a	0f 82 4d 03 00
	00		 jb	 $LN3@R_DrawTran

; 844  : 	{
; 845  : 		// SoM: Why didn't I see this earlier? the spot variable is a waste now because we don't
; 846  : 		// have the uber complicated math to calculate it now, so that was a memory write we didn't
; 847  : 		// need!
; 848  : 		dest[0] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[0])];

  00090	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00099	d3 e8		 shr	 eax, cl
  0009b	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  000aa	d3 ea		 shr	 edx, cl
  000ac	0b c2		 or	 eax, edx
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  000b1	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000b5	c1 e2 08	 shl	 edx, 8
  000b8	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	6b c8 00	 imul	 ecx, eax, 0
  000c6	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  000c9	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  000cd	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	6b c8 00	 imul	 ecx, eax, 0
  000d9	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  000dc	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  000df	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000e2	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 849  : 		xposition += xstep;

  000e5	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  000e8	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  000eb	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 850  : 		yposition += ystep;

  000ee	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000f1	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  000f4	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 851  : 
; 852  : 		dest[1] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[1])];

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00100	d3 e8		 shr	 eax, cl
  00102	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00108	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00111	d3 ea		 shr	 edx, cl
  00113	0b c2		 or	 eax, edx
  00115	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00118	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0011c	c1 e2 08	 shl	 edx, 8
  0011f	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	c1 e0 00	 shl	 eax, 0
  0012d	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  00130	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00134	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00138	ba 01 00 00 00	 mov	 edx, 1
  0013d	c1 e2 00	 shl	 edx, 0
  00140	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00143	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00146	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00149	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 853  : 		xposition += xstep;

  0014c	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0014f	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00152	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 854  : 		yposition += ystep;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00158	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0015b	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 855  : 
; 856  : 		dest[2] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[2])];

  0015e	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00167	d3 e8		 shr	 eax, cl
  00169	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0016f	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00172	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00178	d3 ea		 shr	 edx, cl
  0017a	0b c2		 or	 eax, edx
  0017c	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  0017f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00183	c1 e2 08	 shl	 edx, 8
  00186	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	d1 e0		 shl	 eax, 1
  00193	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  00196	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  0019a	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0019e	ba 01 00 00 00	 mov	 edx, 1
  001a3	d1 e2		 shl	 edx, 1
  001a5	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  001a8	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  001ab	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  001ae	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 857  : 		xposition += xstep;

  001b1	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  001b4	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  001b7	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 858  : 		yposition += ystep;

  001ba	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001bd	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  001c0	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 859  : 
; 860  : 		dest[3] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[3])];

  001c3	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  001cc	d3 e8		 shr	 eax, cl
  001ce	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  001d4	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  001d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  001dd	d3 ea		 shr	 edx, cl
  001df	0b c2		 or	 eax, edx
  001e1	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  001e4	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001e8	c1 e2 08	 shl	 edx, 8
  001eb	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  001f1	b8 01 00 00 00	 mov	 eax, 1
  001f6	6b c8 03	 imul	 ecx, eax, 3
  001f9	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  001fc	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00200	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00204	b8 01 00 00 00	 mov	 eax, 1
  00209	6b c8 03	 imul	 ecx, eax, 3
  0020c	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0020f	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00212	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00215	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 861  : 		xposition += xstep;

  00218	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0021b	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  0021e	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 862  : 		yposition += ystep;

  00221	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00224	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00227	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 863  : 
; 864  : 		dest[4] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[4])];

  0022a	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0022d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00233	d3 e8		 shr	 eax, cl
  00235	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0023b	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00244	d3 ea		 shr	 edx, cl
  00246	0b c2		 or	 eax, edx
  00248	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  0024b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0024f	c1 e2 08	 shl	 edx, 8
  00252	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00258	b8 01 00 00 00	 mov	 eax, 1
  0025d	c1 e0 02	 shl	 eax, 2
  00260	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  00263	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00267	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0026b	ba 01 00 00 00	 mov	 edx, 1
  00270	c1 e2 02	 shl	 edx, 2
  00273	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00276	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00279	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  0027c	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 865  : 		xposition += xstep;

  0027f	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00282	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00285	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 866  : 		yposition += ystep;

  00288	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0028b	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0028e	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 867  : 
; 868  : 		dest[5] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[5])];

  00291	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0029a	d3 e8		 shr	 eax, cl
  0029c	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  002a2	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  002ab	d3 ea		 shr	 edx, cl
  002ad	0b c2		 or	 eax, edx
  002af	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  002b2	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002b6	c1 e2 08	 shl	 edx, 8
  002b9	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  002bf	b8 01 00 00 00	 mov	 eax, 1
  002c4	6b c8 05	 imul	 ecx, eax, 5
  002c7	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002ca	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  002ce	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  002d2	b8 01 00 00 00	 mov	 eax, 1
  002d7	6b c8 05	 imul	 ecx, eax, 5
  002da	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002dd	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  002e0	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  002e3	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 869  : 		xposition += xstep;

  002e6	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  002e9	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  002ec	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 870  : 		yposition += ystep;

  002ef	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  002f2	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  002f5	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 871  : 
; 872  : 		dest[6] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[6])];

  002f8	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00301	d3 e8		 shr	 eax, cl
  00303	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00309	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00312	d3 ea		 shr	 edx, cl
  00314	0b c2		 or	 eax, edx
  00316	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00319	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0031d	c1 e2 08	 shl	 edx, 8
  00320	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00326	b8 01 00 00 00	 mov	 eax, 1
  0032b	6b c8 06	 imul	 ecx, eax, 6
  0032e	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00331	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00335	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00339	b8 01 00 00 00	 mov	 eax, 1
  0033e	6b c8 06	 imul	 ecx, eax, 6
  00341	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00344	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00347	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0034a	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 873  : 		xposition += xstep;

  0034d	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00350	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00353	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 874  : 		yposition += ystep;

  00356	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00359	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0035c	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 875  : 
; 876  : 		dest[7] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[7])];

  0035f	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00362	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00368	d3 e8		 shr	 eax, cl
  0036a	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00370	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00373	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00379	d3 ea		 shr	 edx, cl
  0037b	0b c2		 or	 eax, edx
  0037d	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00380	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00384	c1 e2 08	 shl	 edx, 8
  00387	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  0038d	b8 01 00 00 00	 mov	 eax, 1
  00392	6b c8 07	 imul	 ecx, eax, 7
  00395	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00398	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0039c	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  003a0	b8 01 00 00 00	 mov	 eax, 1
  003a5	6b c8 07	 imul	 ecx, eax, 7
  003a8	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  003ab	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  003ae	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  003b1	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 877  : 		xposition += xstep;

  003b4	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  003b7	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  003ba	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 878  : 		yposition += ystep;

  003bd	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  003c0	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  003c3	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 879  : 
; 880  : 		dest += 8;

  003c6	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  003c9	83 c0 08	 add	 eax, 8
  003cc	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 881  : 		count -= 8;

  003cf	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  003d2	83 e8 08	 sub	 eax, 8
  003d5	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax

; 882  : 	}

  003d8	e9 a9 fc ff ff	 jmp	 $LN2@R_DrawTran
$LN3@R_DrawTran:

; 883  : 	while (count--)

  003dd	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  003e0	89 45 9c	 mov	 DWORD PTR tv288[ebp], eax
  003e3	8b 4d e0	 mov	 ecx, DWORD PTR _count$[ebp]
  003e6	83 e9 01	 sub	 ecx, 1
  003e9	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx
  003ec	83 7d 9c 00	 cmp	 DWORD PTR tv288[ebp], 0
  003f0	74 60		 je	 SHORT $LN5@R_DrawTran

; 884  : 	{
; 885  : 		*dest = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + *dest)];

  003f2	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  003f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  003fb	d3 e8		 shr	 eax, cl
  003fd	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00403	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00406	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0040c	d3 ea		 shr	 edx, cl
  0040e	0b c2		 or	 eax, edx
  00410	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00413	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00417	c1 e2 08	 shl	 edx, 8
  0041a	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00420	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00423	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00426	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  0042a	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0042d	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$[ebp]
  00430	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00433	88 10		 mov	 BYTE PTR [eax], dl

; 886  : 		dest++;

  00435	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00438	83 c0 01	 add	 eax, 1
  0043b	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 887  : 		xposition += xstep;

  0043e	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00441	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00444	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 888  : 		yposition += ystep;

  00447	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0044a	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0044d	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 889  : 	}

  00450	eb 8b		 jmp	 SHORT $LN3@R_DrawTran
$LN5@R_DrawTran:

; 890  : }

  00452	5f		 pop	 edi
  00453	5e		 pop	 esi
  00454	5b		 pop	 ebx
  00455	8b e5		 mov	 esp, ebp
  00457	5d		 pop	 ebp
  00458	c3		 ret	 0
_R_DrawTranslucentSpan_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawTranslucentSplat_8
_TEXT	SEGMENT
tv352 = -104						; size = 4
_val$ = -33						; size = 1
_count$ = -32						; size = 4
_dest$ = -28						; size = 4
_colormap$ = -24					; size = 4
_source$ = -20						; size = 4
_ystep$ = -16						; size = 4
_xstep$ = -12						; size = 4
_yposition$ = -8					; size = 4
_xposition$ = -4					; size = 4
_R_DrawTranslucentSplat_8 PROC				; COMDAT

; 718  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 719  : 	UINT32 xposition;
; 720  : 	UINT32 yposition;
; 721  : 	UINT32 xstep, ystep;
; 722  : 
; 723  : 	UINT8 *source;
; 724  : 	UINT8 *colormap;
; 725  : 	UINT8 *dest;
; 726  : 
; 727  : 	size_t count;
; 728  : 	UINT8 val;
; 729  : 
; 730  : 	// SoM: we only need 6 bits for the integer part (0 thru 63) so the rest
; 731  : 	// can be used for the fraction part. This allows calculation of the memory address in the
; 732  : 	// texture with two shifts, an OR and one AND. (see below)
; 733  : 	// for texture sizes > 64 the amount of precision we can allow will decrease, but only by one
; 734  : 	// bit per power of two (obviously)
; 735  : 	// Ok, because I was able to eliminate the variable spot below, this function is now FASTER
; 736  : 	// than the original span renderer. Whodathunkit?
; 737  : 	xposition = ds_xfrac << nflatshiftup; yposition = ds_yfrac << nflatshiftup;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xfrac
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00014	d3 e0		 shl	 eax, cl
  00016	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_yfrac
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00024	d3 e0		 shl	 eax, cl
  00026	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 738  : 	xstep = ds_xstep << nflatshiftup; ystep = ds_ystep << nflatshiftup;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xstep
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00034	d3 e0		 shl	 eax, cl
  00036	89 45 f4	 mov	 DWORD PTR _xstep$[ebp], eax
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_ystep
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00044	d3 e0		 shl	 eax, cl
  00046	89 45 f0	 mov	 DWORD PTR _ystep$[ebp], eax

; 739  : 
; 740  : 	source = ds_source;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_source
  0004e	89 45 ec	 mov	 DWORD PTR _source$[ebp], eax

; 741  : 	colormap = ds_colormap;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_colormap
  00056	89 45 e8	 mov	 DWORD PTR _colormap$[ebp], eax

; 742  : 	dest = ylookup[ds_y] + columnofs[ds_x1];

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_y
  0005e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ds_x1
  0006b	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00072	89 4d e4	 mov	 DWORD PTR _dest$[ebp], ecx

; 743  : 	count = ds_x2 - ds_x1 + 1;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_x2
  0007a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ds_x1
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax
$LN2@R_DrawTran:

; 744  : 
; 745  : 	while (count >= 8)

  00086	83 7d e0 08	 cmp	 DWORD PTR _count$[ebp], 8
  0008a	0f 82 dd 04 00
	00		 jb	 $LN3@R_DrawTran

; 746  : 	{
; 747  : 		// SoM: Why didn't I see this earlier? the spot variable is a waste now because we don't
; 748  : 		// have the uber complicated math to calculate it now, so that was a memory write we didn't
; 749  : 		// need!
; 750  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  00090	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00099	d3 e8		 shr	 eax, cl
  0009b	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  000aa	d3 ea		 shr	 edx, cl
  000ac	0b c2		 or	 eax, edx
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  000b1	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  000b4	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 751  : 		if (val != TRANSPARENTPIXEL)

  000b7	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  000bb	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  000c0	74 55		 je	 SHORT $LN6@R_DrawTran

; 752  : 			dest[0] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[0])];

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  000cb	d3 e8		 shr	 eax, cl
  000cd	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  000dc	d3 ea		 shr	 edx, cl
  000de	0b c2		 or	 eax, edx
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  000e3	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000e7	c1 e2 08	 shl	 edx, 8
  000ea	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  000f0	b8 01 00 00 00	 mov	 eax, 1
  000f5	6b c8 00	 imul	 ecx, eax, 0
  000f8	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  000fb	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  000ff	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	6b c8 00	 imul	 ecx, eax, 0
  0010b	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0010e	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00111	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00114	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN6@R_DrawTran:

; 753  : 		xposition += xstep;

  00117	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0011a	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  0011d	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 754  : 		yposition += ystep;

  00120	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00123	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00126	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 755  : 
; 756  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  00129	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0012c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00132	d3 e8		 shr	 eax, cl
  00134	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0013a	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0013d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00143	d3 ea		 shr	 edx, cl
  00145	0b c2		 or	 eax, edx
  00147	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  0014a	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0014d	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 757  : 		if (val != TRANSPARENTPIXEL)

  00150	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  00154	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00159	74 55		 je	 SHORT $LN7@R_DrawTran

; 758  : 			dest[1] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[1])];

  0015b	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00164	d3 e8		 shr	 eax, cl
  00166	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0016c	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00175	d3 ea		 shr	 edx, cl
  00177	0b c2		 or	 eax, edx
  00179	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  0017c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00180	c1 e2 08	 shl	 edx, 8
  00183	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00189	b8 01 00 00 00	 mov	 eax, 1
  0018e	c1 e0 00	 shl	 eax, 0
  00191	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  00194	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00198	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0019c	ba 01 00 00 00	 mov	 edx, 1
  001a1	c1 e2 00	 shl	 edx, 0
  001a4	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  001a7	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  001aa	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  001ad	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
$LN7@R_DrawTran:

; 759  : 		xposition += xstep;

  001b0	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  001b3	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  001b6	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 760  : 		yposition += ystep;

  001b9	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001bc	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  001bf	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 761  : 
; 762  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  001c2	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  001cb	d3 e8		 shr	 eax, cl
  001cd	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  001d3	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  001dc	d3 ea		 shr	 edx, cl
  001de	0b c2		 or	 eax, edx
  001e0	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  001e3	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001e6	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 763  : 		if (val != TRANSPARENTPIXEL)

  001e9	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  001ed	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  001f2	74 53		 je	 SHORT $LN8@R_DrawTran

; 764  : 			dest[2] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[2])];

  001f4	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  001fd	d3 e8		 shr	 eax, cl
  001ff	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00205	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0020e	d3 ea		 shr	 edx, cl
  00210	0b c2		 or	 eax, edx
  00212	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00215	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00219	c1 e2 08	 shl	 edx, 8
  0021c	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00222	b8 01 00 00 00	 mov	 eax, 1
  00227	d1 e0		 shl	 eax, 1
  00229	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0022c	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00230	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00234	ba 01 00 00 00	 mov	 edx, 1
  00239	d1 e2		 shl	 edx, 1
  0023b	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0023e	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00241	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00244	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
$LN8@R_DrawTran:

; 765  : 		xposition += xstep;

  00247	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0024a	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  0024d	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 766  : 		yposition += ystep;

  00250	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00253	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00256	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 767  : 
; 768  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  00259	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0025c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00262	d3 e8		 shr	 eax, cl
  00264	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0026a	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00273	d3 ea		 shr	 edx, cl
  00275	0b c2		 or	 eax, edx
  00277	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  0027a	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0027d	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 769  : 		if (val != TRANSPARENTPIXEL)

  00280	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  00284	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00289	74 55		 je	 SHORT $LN9@R_DrawTran

; 770  : 			dest[3] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[3])];

  0028b	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0028e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00294	d3 e8		 shr	 eax, cl
  00296	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0029c	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0029f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  002a5	d3 ea		 shr	 edx, cl
  002a7	0b c2		 or	 eax, edx
  002a9	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  002ac	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002b0	c1 e2 08	 shl	 edx, 8
  002b3	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  002b9	b8 01 00 00 00	 mov	 eax, 1
  002be	6b c8 03	 imul	 ecx, eax, 3
  002c1	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002c4	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  002c8	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	6b c8 03	 imul	 ecx, eax, 3
  002d4	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002d7	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  002da	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  002dd	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN9@R_DrawTran:

; 771  : 		xposition += xstep;

  002e0	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  002e3	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  002e6	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 772  : 		yposition += ystep;

  002e9	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  002ec	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  002ef	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 773  : 
; 774  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  002f2	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  002f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  002fb	d3 e8		 shr	 eax, cl
  002fd	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00303	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0030c	d3 ea		 shr	 edx, cl
  0030e	0b c2		 or	 eax, edx
  00310	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00313	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00316	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 775  : 		if (val != TRANSPARENTPIXEL)

  00319	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  0031d	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00322	74 55		 je	 SHORT $LN10@R_DrawTran

; 776  : 			dest[4] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[4])];

  00324	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0032d	d3 e8		 shr	 eax, cl
  0032f	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00335	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0033e	d3 ea		 shr	 edx, cl
  00340	0b c2		 or	 eax, edx
  00342	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00345	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00349	c1 e2 08	 shl	 edx, 8
  0034c	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00352	b8 01 00 00 00	 mov	 eax, 1
  00357	c1 e0 02	 shl	 eax, 2
  0035a	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0035d	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00361	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00365	ba 01 00 00 00	 mov	 edx, 1
  0036a	c1 e2 02	 shl	 edx, 2
  0036d	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00370	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00373	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00376	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
$LN10@R_DrawTran:

; 777  : 		xposition += xstep;

  00379	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0037c	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  0037f	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 778  : 		yposition += ystep;

  00382	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00385	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00388	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 779  : 
; 780  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  0038b	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0038e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00394	d3 e8		 shr	 eax, cl
  00396	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0039c	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0039f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  003a5	d3 ea		 shr	 edx, cl
  003a7	0b c2		 or	 eax, edx
  003a9	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  003ac	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  003af	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 781  : 		if (val != TRANSPARENTPIXEL)

  003b2	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  003b6	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  003bb	74 55		 je	 SHORT $LN11@R_DrawTran

; 782  : 			dest[5] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[5])];

  003bd	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  003c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  003c6	d3 e8		 shr	 eax, cl
  003c8	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  003ce	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  003d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  003d7	d3 ea		 shr	 edx, cl
  003d9	0b c2		 or	 eax, edx
  003db	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  003de	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003e2	c1 e2 08	 shl	 edx, 8
  003e5	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  003eb	b8 01 00 00 00	 mov	 eax, 1
  003f0	6b c8 05	 imul	 ecx, eax, 5
  003f3	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  003f6	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  003fa	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  003fe	b8 01 00 00 00	 mov	 eax, 1
  00403	6b c8 05	 imul	 ecx, eax, 5
  00406	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00409	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  0040c	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0040f	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN11@R_DrawTran:

; 783  : 		xposition += xstep;

  00412	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00415	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00418	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 784  : 		yposition += ystep;

  0041b	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0041e	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00421	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 785  : 
; 786  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  00424	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00427	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0042d	d3 e8		 shr	 eax, cl
  0042f	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00435	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00438	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0043e	d3 ea		 shr	 edx, cl
  00440	0b c2		 or	 eax, edx
  00442	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00445	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00448	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 787  : 		if (val != TRANSPARENTPIXEL)

  0044b	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  0044f	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00454	74 55		 je	 SHORT $LN12@R_DrawTran

; 788  : 			dest[6] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[6])];

  00456	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00459	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0045f	d3 e8		 shr	 eax, cl
  00461	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00467	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0046a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00470	d3 ea		 shr	 edx, cl
  00472	0b c2		 or	 eax, edx
  00474	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00477	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0047b	c1 e2 08	 shl	 edx, 8
  0047e	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  00484	b8 01 00 00 00	 mov	 eax, 1
  00489	6b c8 06	 imul	 ecx, eax, 6
  0048c	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0048f	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00493	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00497	b8 01 00 00 00	 mov	 eax, 1
  0049c	6b c8 06	 imul	 ecx, eax, 6
  0049f	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  004a2	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  004a5	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  004a8	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN12@R_DrawTran:

; 789  : 		xposition += xstep;

  004ab	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  004ae	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  004b1	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 790  : 		yposition += ystep;

  004b4	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  004b7	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  004ba	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 791  : 
; 792  : 		val = source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)];

  004bd	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  004c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  004c6	d3 e8		 shr	 eax, cl
  004c8	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  004ce	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  004d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  004d7	d3 ea		 shr	 edx, cl
  004d9	0b c2		 or	 eax, edx
  004db	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  004de	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  004e1	88 55 df	 mov	 BYTE PTR _val$[ebp], dl

; 793  : 		if (val != TRANSPARENTPIXEL)

  004e4	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  004e8	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  004ed	74 55		 je	 SHORT $LN13@R_DrawTran

; 794  : 			dest[7] = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + dest[7])];

  004ef	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  004f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  004f8	d3 e8		 shr	 eax, cl
  004fa	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00500	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00503	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00509	d3 ea		 shr	 edx, cl
  0050b	0b c2		 or	 eax, edx
  0050d	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00510	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00514	c1 e2 08	 shl	 edx, 8
  00517	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  0051d	b8 01 00 00 00	 mov	 eax, 1
  00522	6b c8 07	 imul	 ecx, eax, 7
  00525	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00528	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0052c	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00530	b8 01 00 00 00	 mov	 eax, 1
  00535	6b c8 07	 imul	 ecx, eax, 7
  00538	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0053b	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  0053e	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00541	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN13@R_DrawTran:

; 795  : 		xposition += xstep;

  00544	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00547	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  0054a	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 796  : 		yposition += ystep;

  0054d	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00550	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00553	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 797  : 
; 798  : 		dest += 8;

  00556	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00559	83 c0 08	 add	 eax, 8
  0055c	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 799  : 		count -= 8;

  0055f	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  00562	83 e8 08	 sub	 eax, 8
  00565	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax

; 800  : 	}

  00568	e9 19 fb ff ff	 jmp	 $LN2@R_DrawTran
$LN3@R_DrawTran:

; 801  : 	while (count--)

  0056d	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  00570	89 45 98	 mov	 DWORD PTR tv352[ebp], eax
  00573	8b 4d e0	 mov	 ecx, DWORD PTR _count$[ebp]
  00576	83 e9 01	 sub	 ecx, 1
  00579	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx
  0057c	83 7d 98 00	 cmp	 DWORD PTR tv352[ebp], 0
  00580	0f 84 9c 00 00
	00		 je	 $LN5@R_DrawTran

; 802  : 	{
; 803  : 		val =colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00586	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00589	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0058f	d3 e8		 shr	 eax, cl
  00591	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00597	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0059a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  005a0	d3 ea		 shr	 edx, cl
  005a2	0b c2		 or	 eax, edx
  005a4	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  005a7	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005ab	8b 45 e8	 mov	 eax, DWORD PTR _colormap$[ebp]
  005ae	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  005b1	88 4d df	 mov	 BYTE PTR _val$[ebp], cl

; 804  : 		if (val != TRANSPARENTPIXEL)

  005b4	0f b6 45 df	 movzx	 eax, BYTE PTR _val$[ebp]
  005b8	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  005bd	74 43		 je	 SHORT $LN14@R_DrawTran

; 805  : 			*dest = colormap[*(ds_transmap + (source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)] << 8) + *dest)];

  005bf	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  005c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  005c8	d3 e8		 shr	 eax, cl
  005ca	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  005d0	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  005d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  005d9	d3 ea		 shr	 edx, cl
  005db	0b c2		 or	 eax, edx
  005dd	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  005e0	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  005e4	c1 e2 08	 shl	 edx, 8
  005e7	03 15 00 00 00
	00		 add	 edx, DWORD PTR _ds_transmap
  005ed	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  005f0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  005f3	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  005f7	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  005fa	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$[ebp]
  005fd	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00600	88 10		 mov	 BYTE PTR [eax], dl
$LN14@R_DrawTran:

; 806  : 
; 807  : 		dest++;

  00602	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00605	83 c0 01	 add	 eax, 1
  00608	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 808  : 		xposition += xstep;

  0060b	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0060e	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00611	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 809  : 		yposition += ystep;

  00614	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00617	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0061a	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 810  : 	}

  0061d	e9 4b ff ff ff	 jmp	 $LN3@R_DrawTran
$LN5@R_DrawTran:

; 811  : }

  00622	5f		 pop	 edi
  00623	5e		 pop	 esi
  00624	5b		 pop	 ebx
  00625	8b e5		 mov	 esp, ebp
  00627	5d		 pop	 ebp
  00628	c3		 ret	 0
_R_DrawTranslucentSplat_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawSplat_8
_TEXT	SEGMENT
tv232 = -104						; size = 4
_val$ = -36						; size = 4
_count$ = -32						; size = 4
_dest$ = -28						; size = 4
_colormap$ = -24					; size = 4
_source$ = -20						; size = 4
_ystep$ = -16						; size = 4
_xstep$ = -12						; size = 4
_yposition$ = -8					; size = 4
_xposition$ = -4					; size = 4
_R_DrawSplat_8 PROC					; COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 602  : 	UINT32 xposition;
; 603  : 	UINT32 yposition;
; 604  : 	UINT32 xstep, ystep;
; 605  : 
; 606  : 	UINT8 *source;
; 607  : 	UINT8 *colormap;
; 608  : 	UINT8 *dest;
; 609  : 
; 610  : 	size_t count;
; 611  : 	UINT32 val;
; 612  : 
; 613  : 	// SoM: we only need 6 bits for the integer part (0 thru 63) so the rest
; 614  : 	// can be used for the fraction part. This allows calculation of the memory address in the
; 615  : 	// texture with two shifts, an OR and one AND. (see below)
; 616  : 	// for texture sizes > 64 the amount of precision we can allow will decrease, but only by one
; 617  : 	// bit per power of two (obviously)
; 618  : 	// Ok, because I was able to eliminate the variable spot below, this function is now FASTER
; 619  : 	// than the original span renderer. Whodathunkit?
; 620  : 	xposition = ds_xfrac << nflatshiftup; yposition = ds_yfrac << nflatshiftup;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xfrac
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00014	d3 e0		 shl	 eax, cl
  00016	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_yfrac
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00024	d3 e0		 shl	 eax, cl
  00026	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 621  : 	xstep = ds_xstep << nflatshiftup; ystep = ds_ystep << nflatshiftup;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xstep
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00034	d3 e0		 shl	 eax, cl
  00036	89 45 f4	 mov	 DWORD PTR _xstep$[ebp], eax
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_ystep
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00044	d3 e0		 shl	 eax, cl
  00046	89 45 f0	 mov	 DWORD PTR _ystep$[ebp], eax

; 622  : 
; 623  : 	source = ds_source;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_source
  0004e	89 45 ec	 mov	 DWORD PTR _source$[ebp], eax

; 624  : 	colormap = ds_colormap;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_colormap
  00056	89 45 e8	 mov	 DWORD PTR _colormap$[ebp], eax

; 625  : 	dest = ylookup[ds_y] + columnofs[ds_x1];

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_y
  0005e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ds_x1
  0006b	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00072	89 4d e4	 mov	 DWORD PTR _dest$[ebp], ecx

; 626  : 	count = ds_x2 - ds_x1 + 1;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_x2
  0007a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ds_x1
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax
$LN2@R_DrawSpla:

; 627  : 
; 628  : 	while (count >= 8)

  00086	83 7d e0 08	 cmp	 DWORD PTR _count$[ebp], 8
  0008a	0f 82 5e 03 00
	00		 jb	 $LN3@R_DrawSpla

; 629  : 	{
; 630  : 		// SoM: Why didn't I see this earlier? the spot variable is a waste now because we don't
; 631  : 		// have the uber complicated math to calculate it now, so that was a memory write we didn't
; 632  : 		// need!
; 633  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  00090	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00099	d3 e8		 shr	 eax, cl
  0009b	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  000aa	d3 ea		 shr	 edx, cl
  000ac	0b c2		 or	 eax, edx
  000ae	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 634  : 		val &= 4095;

  000b1	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  000b4	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000b9	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 635  : 		val = source[val];

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  000bf	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  000c2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c5	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 636  : 		if (val != TRANSPARENTPIXEL)

  000c8	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  000cf	74 16		 je	 SHORT $LN6@R_DrawSpla

; 637  : 			dest[0] = colormap[val];

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	6b c8 00	 imul	 ecx, eax, 0
  000d9	8b 55 e8	 mov	 edx, DWORD PTR _colormap$[ebp]
  000dc	03 55 dc	 add	 edx, DWORD PTR _val$[ebp]
  000df	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  000e2	8a 12		 mov	 dl, BYTE PTR [edx]
  000e4	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN6@R_DrawSpla:

; 638  : 		xposition += xstep;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  000ea	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  000ed	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 639  : 		yposition += ystep;

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000f3	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  000f6	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 640  : 
; 641  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  000f9	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00102	d3 e8		 shr	 eax, cl
  00104	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0010a	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00113	d3 ea		 shr	 edx, cl
  00115	0b c2		 or	 eax, edx
  00117	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 642  : 		val &= 4095;

  0011a	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  0011d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00122	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 643  : 		val = source[val];

  00125	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  00128	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  0012b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0012e	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 644  : 		if (val != TRANSPARENTPIXEL)

  00131	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  00138	74 16		 je	 SHORT $LN7@R_DrawSpla

; 645  : 			dest[1] = colormap[val];

  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	c1 e0 00	 shl	 eax, 0
  00142	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$[ebp]
  00145	03 4d dc	 add	 ecx, DWORD PTR _val$[ebp]
  00148	8b 55 e4	 mov	 edx, DWORD PTR _dest$[ebp]
  0014b	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014d	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
$LN7@R_DrawSpla:

; 646  : 		xposition += xstep;

  00150	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00153	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00156	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 647  : 		yposition += ystep;

  00159	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0015c	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0015f	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 648  : 
; 649  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  00162	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0016b	d3 e8		 shr	 eax, cl
  0016d	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00173	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00176	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0017c	d3 ea		 shr	 edx, cl
  0017e	0b c2		 or	 eax, edx
  00180	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 650  : 		val &= 4095;

  00183	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  00186	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0018b	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 651  : 		val = source[val];

  0018e	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  00191	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  00194	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00197	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 652  : 		if (val != TRANSPARENTPIXEL)

  0019a	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  001a1	74 15		 je	 SHORT $LN8@R_DrawSpla

; 653  : 			dest[2] = colormap[val];

  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	d1 e0		 shl	 eax, 1
  001aa	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$[ebp]
  001ad	03 4d dc	 add	 ecx, DWORD PTR _val$[ebp]
  001b0	8b 55 e4	 mov	 edx, DWORD PTR _dest$[ebp]
  001b3	8a 09		 mov	 cl, BYTE PTR [ecx]
  001b5	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
$LN8@R_DrawSpla:

; 654  : 		xposition += xstep;

  001b8	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  001bb	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  001be	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 655  : 		yposition += ystep;

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001c4	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  001c7	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 656  : 
; 657  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  001ca	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  001d3	d3 e8		 shr	 eax, cl
  001d5	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  001db	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  001de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  001e4	d3 ea		 shr	 edx, cl
  001e6	0b c2		 or	 eax, edx
  001e8	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 658  : 		val &= 4095;

  001eb	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  001ee	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001f3	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 659  : 		val = source[val];

  001f6	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  001f9	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  001fc	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001ff	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 660  : 		if (val != TRANSPARENTPIXEL)

  00202	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  00209	74 16		 je	 SHORT $LN9@R_DrawSpla

; 661  : 			dest[3] = colormap[val];

  0020b	b8 01 00 00 00	 mov	 eax, 1
  00210	6b c8 03	 imul	 ecx, eax, 3
  00213	8b 55 e8	 mov	 edx, DWORD PTR _colormap$[ebp]
  00216	03 55 dc	 add	 edx, DWORD PTR _val$[ebp]
  00219	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0021c	8a 12		 mov	 dl, BYTE PTR [edx]
  0021e	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN9@R_DrawSpla:

; 662  : 		xposition += xstep;

  00221	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00224	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00227	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 663  : 		yposition += ystep;

  0022a	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0022d	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00230	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 664  : 
; 665  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  00233	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0023c	d3 e8		 shr	 eax, cl
  0023e	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00244	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0024d	d3 ea		 shr	 edx, cl
  0024f	0b c2		 or	 eax, edx
  00251	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 666  : 		val &= 4095;

  00254	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  00257	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0025c	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 667  : 		val = source[val];

  0025f	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  00262	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  00265	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00268	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 668  : 		if (val != TRANSPARENTPIXEL)

  0026b	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  00272	74 16		 je	 SHORT $LN10@R_DrawSpla

; 669  : 			dest[4] = colormap[val];

  00274	b8 01 00 00 00	 mov	 eax, 1
  00279	c1 e0 02	 shl	 eax, 2
  0027c	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$[ebp]
  0027f	03 4d dc	 add	 ecx, DWORD PTR _val$[ebp]
  00282	8b 55 e4	 mov	 edx, DWORD PTR _dest$[ebp]
  00285	8a 09		 mov	 cl, BYTE PTR [ecx]
  00287	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
$LN10@R_DrawSpla:

; 670  : 		xposition += xstep;

  0028a	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0028d	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00290	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 671  : 		yposition += ystep;

  00293	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00296	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00299	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 672  : 
; 673  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  0029c	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0029f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  002a5	d3 e8		 shr	 eax, cl
  002a7	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  002ad	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  002b6	d3 ea		 shr	 edx, cl
  002b8	0b c2		 or	 eax, edx
  002ba	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 674  : 		val &= 4095;

  002bd	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  002c0	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  002c5	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 675  : 		val = source[val];

  002c8	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  002cb	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  002ce	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002d1	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 676  : 		if (val != TRANSPARENTPIXEL)

  002d4	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  002db	74 16		 je	 SHORT $LN11@R_DrawSpla

; 677  : 			dest[5] = colormap[val];

  002dd	b8 01 00 00 00	 mov	 eax, 1
  002e2	6b c8 05	 imul	 ecx, eax, 5
  002e5	8b 55 e8	 mov	 edx, DWORD PTR _colormap$[ebp]
  002e8	03 55 dc	 add	 edx, DWORD PTR _val$[ebp]
  002eb	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002ee	8a 12		 mov	 dl, BYTE PTR [edx]
  002f0	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN11@R_DrawSpla:

; 678  : 		xposition += xstep;

  002f3	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  002f6	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  002f9	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 679  : 		yposition += ystep;

  002fc	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  002ff	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00302	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 680  : 
; 681  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  00305	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00308	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0030e	d3 e8		 shr	 eax, cl
  00310	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00316	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00319	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0031f	d3 ea		 shr	 edx, cl
  00321	0b c2		 or	 eax, edx
  00323	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 682  : 		val &= 4095;

  00326	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  00329	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0032e	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 683  : 		val = source[val];

  00331	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  00334	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  00337	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0033a	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 684  : 		if (val != TRANSPARENTPIXEL)

  0033d	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  00344	74 16		 je	 SHORT $LN12@R_DrawSpla

; 685  : 			dest[6] = colormap[val];

  00346	b8 01 00 00 00	 mov	 eax, 1
  0034b	6b c8 06	 imul	 ecx, eax, 6
  0034e	8b 55 e8	 mov	 edx, DWORD PTR _colormap$[ebp]
  00351	03 55 dc	 add	 edx, DWORD PTR _val$[ebp]
  00354	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00357	8a 12		 mov	 dl, BYTE PTR [edx]
  00359	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN12@R_DrawSpla:

; 686  : 		xposition += xstep;

  0035c	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0035f	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00362	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 687  : 		yposition += ystep;

  00365	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00368	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0036b	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 688  : 
; 689  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  0036e	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00371	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00377	d3 e8		 shr	 eax, cl
  00379	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  0037f	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00382	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00388	d3 ea		 shr	 edx, cl
  0038a	0b c2		 or	 eax, edx
  0038c	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 690  : 		val &= 4095;

  0038f	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  00392	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00397	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 691  : 		val = source[val];

  0039a	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  0039d	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  003a0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  003a3	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 692  : 		if (val != TRANSPARENTPIXEL)

  003a6	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  003ad	74 16		 je	 SHORT $LN13@R_DrawSpla

; 693  : 			dest[7] = colormap[val];

  003af	b8 01 00 00 00	 mov	 eax, 1
  003b4	6b c8 07	 imul	 ecx, eax, 7
  003b7	8b 55 e8	 mov	 edx, DWORD PTR _colormap$[ebp]
  003ba	03 55 dc	 add	 edx, DWORD PTR _val$[ebp]
  003bd	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  003c0	8a 12		 mov	 dl, BYTE PTR [edx]
  003c2	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
$LN13@R_DrawSpla:

; 694  : 		xposition += xstep;

  003c5	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  003c8	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  003cb	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 695  : 		yposition += ystep;

  003ce	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  003d1	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  003d4	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 696  : 
; 697  : 		dest += 8;

  003d7	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  003da	83 c0 08	 add	 eax, 8
  003dd	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 698  : 		count -= 8;

  003e0	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  003e3	83 e8 08	 sub	 eax, 8
  003e6	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax

; 699  : 	}

  003e9	e9 98 fc ff ff	 jmp	 $LN2@R_DrawSpla
$LN3@R_DrawSpla:

; 700  : 	while (count--)

  003ee	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  003f1	89 45 98	 mov	 DWORD PTR tv232[ebp], eax
  003f4	8b 4d e0	 mov	 ecx, DWORD PTR _count$[ebp]
  003f7	83 e9 01	 sub	 ecx, 1
  003fa	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx
  003fd	83 7d 98 00	 cmp	 DWORD PTR tv232[ebp], 0
  00401	74 6b		 je	 SHORT $LN5@R_DrawSpla

; 701  : 	{
; 702  : 		val = ((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift);

  00403	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00406	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0040c	d3 e8		 shr	 eax, cl
  0040e	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00414	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00417	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0041d	d3 ea		 shr	 edx, cl
  0041f	0b c2		 or	 eax, edx
  00421	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 703  : 		val &= 4095;

  00424	8b 45 dc	 mov	 eax, DWORD PTR _val$[ebp]
  00427	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0042c	89 45 dc	 mov	 DWORD PTR _val$[ebp], eax

; 704  : 		val = source[val];

  0042f	8b 45 ec	 mov	 eax, DWORD PTR _source$[ebp]
  00432	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  00435	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00438	89 4d dc	 mov	 DWORD PTR _val$[ebp], ecx

; 705  : 		if (val != TRANSPARENTPIXEL)

  0043b	81 7d dc f7 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 247 ; 000000f7H
  00442	74 0d		 je	 SHORT $LN14@R_DrawSpla

; 706  : 			*dest = colormap[val];

  00444	8b 45 e8	 mov	 eax, DWORD PTR _colormap$[ebp]
  00447	03 45 dc	 add	 eax, DWORD PTR _val$[ebp]
  0044a	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0044d	8a 10		 mov	 dl, BYTE PTR [eax]
  0044f	88 11		 mov	 BYTE PTR [ecx], dl
$LN14@R_DrawSpla:

; 707  : 
; 708  : 		dest++;

  00451	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00454	83 c0 01	 add	 eax, 1
  00457	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 709  : 		xposition += xstep;

  0045a	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0045d	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00460	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 710  : 		yposition += ystep;

  00463	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00466	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00469	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 711  : 	}

  0046c	eb 80		 jmp	 SHORT $LN3@R_DrawSpla
$LN5@R_DrawSpla:

; 712  : }

  0046e	5f		 pop	 edi
  0046f	5e		 pop	 esi
  00470	5b		 pop	 ebx
  00471	8b e5		 mov	 esp, ebp
  00473	5d		 pop	 ebp
  00474	c3		 ret	 0
_R_DrawSplat_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawSpan_8
_TEXT	SEGMENT
tv216 = -100						; size = 4
_count$ = -32						; size = 4
_dest$ = -28						; size = 4
_colormap$ = -24					; size = 4
_source$ = -20						; size = 4
_ystep$ = -16						; size = 4
_xstep$ = -12						; size = 4
_yposition$ = -8					; size = 4
_xposition$ = -4					; size = 4
_R_DrawSpan_8 PROC					; COMDAT

; 523  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 524  : 	UINT32 xposition;
; 525  : 	UINT32 yposition;
; 526  : 	UINT32 xstep, ystep;
; 527  : 
; 528  : 	UINT8 *source;
; 529  : 	UINT8 *colormap;
; 530  : 	UINT8 *dest;
; 531  : 
; 532  : 	size_t count;
; 533  : 
; 534  : 	// SoM: we only need 6 bits for the integer part (0 thru 63) so the rest
; 535  : 	// can be used for the fraction part. This allows calculation of the memory address in the
; 536  : 	// texture with two shifts, an OR and one AND. (see below)
; 537  : 	// for texture sizes > 64 the amount of precision we can allow will decrease, but only by one
; 538  : 	// bit per power of two (obviously)
; 539  : 	// Ok, because I was able to eliminate the variable spot below, this function is now FASTER
; 540  : 	// than the original span renderer. Whodathunkit?
; 541  : 	xposition = ds_xfrac << nflatshiftup; yposition = ds_yfrac << nflatshiftup;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xfrac
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00014	d3 e0		 shl	 eax, cl
  00016	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_yfrac
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00024	d3 e0		 shl	 eax, cl
  00026	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 542  : 	xstep = ds_xstep << nflatshiftup; ystep = ds_ystep << nflatshiftup;

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_xstep
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00034	d3 e0		 shl	 eax, cl
  00036	89 45 f4	 mov	 DWORD PTR _xstep$[ebp], eax
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_ystep
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatshiftup
  00044	d3 e0		 shl	 eax, cl
  00046	89 45 f0	 mov	 DWORD PTR _ystep$[ebp], eax

; 543  : 
; 544  : 	source = ds_source;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_source
  0004e	89 45 ec	 mov	 DWORD PTR _source$[ebp], eax

; 545  : 	colormap = ds_colormap;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_colormap
  00056	89 45 e8	 mov	 DWORD PTR _colormap$[ebp], eax

; 546  : 	dest = ylookup[ds_y] + columnofs[ds_x1];

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_y
  0005e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _ylookup[eax*4]
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ds_x1
  0006b	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _columnofs[edx*4]
  00072	89 4d e4	 mov	 DWORD PTR _dest$[ebp], ecx

; 547  : 	count = ds_x2 - ds_x1 + 1;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_x2
  0007a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _ds_x1
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax
$LN2@R_DrawSpan:

; 548  : 
; 549  : 	while (count >= 8)

  00086	83 7d e0 08	 cmp	 DWORD PTR _count$[ebp], 8
  0008a	0f 82 6e 02 00
	00		 jb	 $LN3@R_DrawSpan

; 550  : 	{
; 551  : 		// SoM: Why didn't I see this earlier? the spot variable is a waste now because we don't
; 552  : 		// have the uber complicated math to calculate it now, so that was a memory write we didn't
; 553  : 		// need!
; 554  : 		dest[0] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00090	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00099	d3 e8		 shr	 eax, cl
  0009b	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  000aa	d3 ea		 shr	 edx, cl
  000ac	0b c2		 or	 eax, edx
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  000b1	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	6b c8 00	 imul	 ecx, eax, 0
  000bd	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  000c0	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  000c3	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000c6	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 555  : 		xposition += xstep;

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  000cc	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  000cf	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 556  : 		yposition += ystep;

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000d5	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  000d8	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 557  : 
; 558  : 		dest[1] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  000db	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  000e4	d3 e8		 shr	 eax, cl
  000e6	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  000f5	d3 ea		 shr	 edx, cl
  000f7	0b c2		 or	 eax, edx
  000f9	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  000fc	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	c1 e0 00	 shl	 eax, 0
  00108	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  0010b	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  0010e	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00111	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 559  : 		xposition += xstep;

  00114	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00117	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  0011a	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 560  : 		yposition += ystep;

  0011d	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00120	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00123	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 561  : 
; 562  : 		dest[2] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00126	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00129	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0012f	d3 e8		 shr	 eax, cl
  00131	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00137	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00140	d3 ea		 shr	 edx, cl
  00142	0b c2		 or	 eax, edx
  00144	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00147	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0014b	b8 01 00 00 00	 mov	 eax, 1
  00150	d1 e0		 shl	 eax, 1
  00152	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  00155	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00158	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0015b	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 563  : 		xposition += xstep;

  0015e	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00161	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00164	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 564  : 		yposition += ystep;

  00167	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0016a	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0016d	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 565  : 
; 566  : 		dest[3] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00170	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  00179	d3 e8		 shr	 eax, cl
  0017b	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00181	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00184	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0018a	d3 ea		 shr	 edx, cl
  0018c	0b c2		 or	 eax, edx
  0018e	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00191	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00195	b8 01 00 00 00	 mov	 eax, 1
  0019a	6b c8 03	 imul	 ecx, eax, 3
  0019d	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  001a0	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  001a3	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  001a6	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 567  : 		xposition += xstep;

  001a9	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  001ac	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  001af	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 568  : 		yposition += ystep;

  001b2	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001b5	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  001b8	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 569  : 
; 570  : 		dest[4] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  001bb	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  001c4	d3 e8		 shr	 eax, cl
  001c6	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  001cc	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  001d5	d3 ea		 shr	 edx, cl
  001d7	0b c2		 or	 eax, edx
  001d9	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  001dc	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001e0	b8 01 00 00 00	 mov	 eax, 1
  001e5	c1 e0 02	 shl	 eax, 2
  001e8	8b 4d e4	 mov	 ecx, DWORD PTR _dest$[ebp]
  001eb	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  001ee	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  001f1	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 571  : 		xposition += xstep;

  001f4	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  001f7	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  001fa	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 572  : 		yposition += ystep;

  001fd	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00200	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00203	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 573  : 
; 574  : 		dest[5] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00206	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0020f	d3 e8		 shr	 eax, cl
  00211	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00217	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  00220	d3 ea		 shr	 edx, cl
  00222	0b c2		 or	 eax, edx
  00224	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00227	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0022b	b8 01 00 00 00	 mov	 eax, 1
  00230	6b c8 05	 imul	 ecx, eax, 5
  00233	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00236	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00239	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0023c	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 575  : 		xposition += xstep;

  0023f	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  00242	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00245	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 576  : 		yposition += ystep;

  00248	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0024b	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0024e	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 577  : 
; 578  : 		dest[6] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00251	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00254	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0025a	d3 e8		 shr	 eax, cl
  0025c	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00262	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00265	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0026b	d3 ea		 shr	 edx, cl
  0026d	0b c2		 or	 eax, edx
  0026f	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00272	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00276	b8 01 00 00 00	 mov	 eax, 1
  0027b	6b c8 06	 imul	 ecx, eax, 6
  0027e	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00281	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  00284	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  00287	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 579  : 		xposition += xstep;

  0028a	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0028d	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00290	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 580  : 		yposition += ystep;

  00293	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00296	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  00299	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 581  : 
; 582  : 		dest[7] = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  0029c	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  0029f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  002a5	d3 e8		 shr	 eax, cl
  002a7	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  002ad	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  002b6	d3 ea		 shr	 edx, cl
  002b8	0b c2		 or	 eax, edx
  002ba	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  002bd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002c1	b8 01 00 00 00	 mov	 eax, 1
  002c6	6b c8 07	 imul	 ecx, eax, 7
  002c9	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002cc	8b 75 e8	 mov	 esi, DWORD PTR _colormap$[ebp]
  002cf	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  002d2	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 583  : 		xposition += xstep;

  002d5	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  002d8	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  002db	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 584  : 		yposition += ystep;

  002de	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  002e1	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  002e4	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 585  : 
; 586  : 		dest += 8;

  002e7	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  002ea	83 c0 08	 add	 eax, 8
  002ed	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 587  : 		count -= 8;

  002f0	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  002f3	83 e8 08	 sub	 eax, 8
  002f6	89 45 e0	 mov	 DWORD PTR _count$[ebp], eax

; 588  : 	}

  002f9	e9 88 fd ff ff	 jmp	 $LN2@R_DrawSpan
$LN3@R_DrawSpan:

; 589  : 	while (count--)

  002fe	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  00301	89 45 9c	 mov	 DWORD PTR tv216[ebp], eax
  00304	8b 4d e0	 mov	 ecx, DWORD PTR _count$[ebp]
  00307	83 e9 01	 sub	 ecx, 1
  0030a	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx
  0030d	83 7d 9c 00	 cmp	 DWORD PTR tv216[ebp], 0
  00311	74 4d		 je	 SHORT $LN5@R_DrawSpan

; 590  : 	{
; 591  : 		*dest++ = colormap[source[((yposition >> nflatyshift) & nflatmask) | (xposition >> nflatxshift)]];

  00313	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00316	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatyshift
  0031c	d3 e8		 shr	 eax, cl
  0031e	23 05 00 00 00
	00		 and	 eax, DWORD PTR _nflatmask
  00324	8b 55 fc	 mov	 edx, DWORD PTR _xposition$[ebp]
  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nflatxshift
  0032d	d3 ea		 shr	 edx, cl
  0032f	0b c2		 or	 eax, edx
  00331	8b 4d ec	 mov	 ecx, DWORD PTR _source$[ebp]
  00334	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00338	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  0033b	8b 4d e8	 mov	 ecx, DWORD PTR _colormap$[ebp]
  0033e	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00341	88 10		 mov	 BYTE PTR [eax], dl
  00343	8b 45 e4	 mov	 eax, DWORD PTR _dest$[ebp]
  00346	83 c0 01	 add	 eax, 1
  00349	89 45 e4	 mov	 DWORD PTR _dest$[ebp], eax

; 592  : 		xposition += xstep;

  0034c	8b 45 fc	 mov	 eax, DWORD PTR _xposition$[ebp]
  0034f	03 45 f4	 add	 eax, DWORD PTR _xstep$[ebp]
  00352	89 45 fc	 mov	 DWORD PTR _xposition$[ebp], eax

; 593  : 		yposition += ystep;

  00355	8b 45 f8	 mov	 eax, DWORD PTR _yposition$[ebp]
  00358	03 45 f0	 add	 eax, DWORD PTR _ystep$[ebp]
  0035b	89 45 f8	 mov	 DWORD PTR _yposition$[ebp], eax

; 594  : 	}

  0035e	eb 9e		 jmp	 SHORT $LN3@R_DrawSpan
$LN5@R_DrawSpan:

; 595  : }

  00360	5f		 pop	 edi
  00361	5e		 pop	 esi
  00362	5b		 pop	 ebx
  00363	8b e5		 mov	 esp, ebp
  00365	5d		 pop	 ebp
  00366	c3		 ret	 0
_R_DrawSpan_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawTranslatedTranslucentColumn_8
_TEXT	SEGMENT
tv79 = -88						; size = 4
_heightmask$1 = -20					; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawTranslatedTranslucentColumn_8 PROC		; COMDAT

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 402  : 	register INT32 count;
; 403  : 	register UINT8 *dest;
; 404  : 	register fixed_t frac, fracstep;
; 405  : 
; 406  : 	count = dc_yh - dc_yl + 1;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 407  : 
; 408  : 	if (count <= 0) // Zero length, column does not exceed a pixel.

  0001a	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0001e	7f 05		 jg	 SHORT $LN11@R_DrawTran

; 409  : 		return;

  00020	e9 46 02 00 00	 jmp	 $LN17@R_DrawTran
$LN11@R_DrawTran:

; 410  : 
; 411  : 	// FIXME. As above.
; 412  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 413  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0002a	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00031	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  00037	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  0003d	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 414  : 
; 415  : 	// Looks familiar.
; 416  : 	fracstep = dc_iscale;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00045	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 417  : 	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
; 418  : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  00048	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  0004f	85 c0		 test	 eax, eax
  00051	75 09		 jne	 SHORT $LN19@R_DrawTran
  00053	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN20@R_DrawTran
$LN19@R_DrawTran:
  0005c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN20@R_DrawTran:
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  00066	51		 push	 ecx
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  0006d	c1 e2 10	 shl	 edx, 16			; 00000010H
  00070	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _FixedMul
  0007c	83 c4 08	 add	 esp, 8
  0007f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00085	0f af 45 a8	 imul	 eax, DWORD PTR tv79[ebp]
  00089	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 419  : 
; 420  : 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
; 421  : 	// This is as fast as it gets.
; 422  : 	{
; 423  : 		register INT32 heightmask = dc_texheight - 1;

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  00091	83 e8 01	 sub	 eax, 1
  00094	89 45 ec	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 424  : 		if (dc_texheight & heightmask)

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  0009c	23 45 ec	 and	 eax, DWORD PTR _heightmask$1[ebp]
  0009f	0f 84 b4 00 00
	00		 je	 $LN12@R_DrawTran

; 425  : 		{
; 426  : 			heightmask++;

  000a5	8b 45 ec	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 ec	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 427  : 			heightmask <<= FRACBITS;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000b1	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b4	89 45 ec	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 428  : 
; 429  : 			if (frac < 0)

  000b7	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp], 0
  000bb	7d 0f		 jge	 SHORT $LN14@R_DrawTran
$LN2@R_DrawTran:

; 430  : 				while ((frac += heightmask) < 0)

  000bd	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000c0	03 45 ec	 add	 eax, DWORD PTR _heightmask$1[ebp]
  000c3	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
  000c6	79 02		 jns	 SHORT $LN3@R_DrawTran

; 431  : 					;

  000c8	eb f3		 jmp	 SHORT $LN2@R_DrawTran
$LN3@R_DrawTran:
  000ca	eb 13		 jmp	 SHORT $LN5@R_DrawTran
$LN14@R_DrawTran:

; 432  : 			else
; 433  : 				while (frac >= heightmask)

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000cf	3b 45 ec	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  000d2	7c 0b		 jl	 SHORT $LN5@R_DrawTran

; 434  : 					frac -= heightmask;

  000d4	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000d7	2b 45 ec	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  000da	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
  000dd	eb ed		 jmp	 SHORT $LN14@R_DrawTran
$LN5@R_DrawTran:

; 435  : 
; 436  : 			do
; 437  : 			{
; 438  : 				// Re-map color indices from wall texture column
; 439  : 				//  using a lighting/special effects LUT.
; 440  : 				// heightmask is the Tutti-Frutti fix
; 441  : 
; 442  : 				*dest = dc_colormap[*(dc_transmap

  000df	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000e2	c1 f8 10	 sar	 eax, 16			; 00000010H
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  000eb	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_translation
  000f4	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  000f8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  000fe	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00102	c1 e0 08	 shl	 eax, 8
  00105	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_transmap
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  0010e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00111	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00115	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  0011e	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00121	88 01		 mov	 BYTE PTR [ecx], al

; 443  : 					+ (dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]]<<8) + (*dest))];
; 444  : 
; 445  : 				dest += vid.width;

  00123	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00126	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0012c	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 446  : 				if ((frac += fracstep) >= heightmask)

  0012f	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00132	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  00135	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
  00138	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp]
  0013b	3b 4d ec	 cmp	 ecx, DWORD PTR _heightmask$1[ebp]
  0013e	7c 09		 jl	 SHORT $LN16@R_DrawTran

; 447  : 					frac -= heightmask;

  00140	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00143	2b 45 ec	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  00146	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN16@R_DrawTran:

; 448  : 			}
; 449  : 			while (--count);

  00149	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0014c	83 e8 01	 sub	 eax, 1
  0014f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  00152	75 8b		 jne	 SHORT $LN5@R_DrawTran

; 450  : 		}

  00154	e9 12 01 00 00	 jmp	 $LN17@R_DrawTran
$LN12@R_DrawTran:

; 451  : 		else
; 452  : 		{
; 453  : 			while ((count -= 2) >= 0) // texture height is a power of 2

  00159	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0015c	83 e8 02	 sub	 eax, 2
  0015f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  00162	0f 88 b7 00 00
	00		 js	 $LN10@R_DrawTran

; 454  : 			{
; 455  : 				*dest = dc_colormap[*(dc_transmap

  00168	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0016b	c1 f8 10	 sar	 eax, 16			; 00000010H
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00174	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00178	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_translation
  0017d	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00181	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  00187	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0018b	c1 e0 08	 shl	 eax, 8
  0018e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_transmap
  00194	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00197	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0019a	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  0019e	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  001a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  001a7	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001aa	88 01		 mov	 BYTE PTR [ecx], al

; 456  : 					+ (dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]]<<8) + (*dest))];
; 457  : 				dest += vid.width;

  001ac	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  001af	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  001b5	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 458  : 				frac += fracstep;

  001b8	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  001bb	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  001be	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 459  : 				*dest = dc_colormap[*(dc_transmap

  001c1	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  001c4	c1 f8 10	 sar	 eax, 16			; 00000010H
  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  001cd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_translation
  001d6	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  001da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  001e0	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001e4	c1 e0 08	 shl	 eax, 8
  001e7	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_transmap
  001ed	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  001f0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001f3	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  001fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  00200	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00203	88 01		 mov	 BYTE PTR [ecx], al

; 460  : 					+ (dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]]<<8) + (*dest))];
; 461  : 				dest += vid.width;

  00205	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00208	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0020e	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 462  : 				frac += fracstep;

  00211	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00214	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  00217	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 463  : 			}

  0021a	e9 3a ff ff ff	 jmp	 $LN12@R_DrawTran
$LN10@R_DrawTran:

; 464  : 			if (count & 1)

  0021f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00222	83 e0 01	 and	 eax, 1
  00225	74 44		 je	 SHORT $LN17@R_DrawTran

; 465  : 				*dest = dc_colormap[*(dc_transmap + (dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]] <<8) + (*dest))];

  00227	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0022a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0022d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00233	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00237	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_translation
  0023c	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00240	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  00246	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0024a	c1 e0 08	 shl	 eax, 8
  0024d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_transmap
  00253	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00256	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00259	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  0025d	8b 4d f8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00260	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  00266	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00269	88 01		 mov	 BYTE PTR [ecx], al
$LN17@R_DrawTran:

; 466  : 		}
; 467  : 	}
; 468  : }

  0026b	5f		 pop	 edi
  0026c	5e		 pop	 esi
  0026d	5b		 pop	 ebx
  0026e	8b e5		 mov	 esp, ebp
  00270	5d		 pop	 ebp
  00271	c3		 ret	 0
_R_DrawTranslatedTranslucentColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawTranslatedColumn_8
_TEXT	SEGMENT
tv78 = -84						; size = 4
tv93 = -84						; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawTranslatedColumn_8 PROC				; COMDAT

; 476  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 477  : 	register INT32 count;
; 478  : 	register UINT8 *dest;
; 479  : 	register fixed_t frac, fracstep;
; 480  : 
; 481  : 	count = dc_yh - dc_yl;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 482  : 	if (count < 0)

  00017	79 05		 jns	 SHORT $LN5@R_DrawTran

; 483  : 		return;

  00019	e9 b7 00 00 00	 jmp	 $LN3@R_DrawTran
$LN5@R_DrawTran:

; 484  : 
; 485  : #ifdef RANGECHECK
; 486  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 487  : 		I_Error("R_DrawTranslatedColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 488  : #endif
; 489  : 
; 490  : 	// FIXME. As above.
; 491  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 492  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00023	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0002a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00036	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 493  : 
; 494  : 	// Looks familiar.
; 495  : 	fracstep = dc_iscale;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  0003e	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 496  : 	//frac = dc_texturemid + (dc_yl-centery)*fracstep;
; 497  : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  00041	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  00048	85 c0		 test	 eax, eax
  0004a	75 09		 jne	 SHORT $LN7@R_DrawTran
  0004c	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00053	eb 07		 jmp	 SHORT $LN8@R_DrawTran
$LN7@R_DrawTran:
  00055	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN8@R_DrawTran:
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  0005f	51		 push	 ecx
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  00066	c1 e2 10	 shl	 edx, 16			; 00000010H
  00069	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _FixedMul
  00075	83 c4 08	 add	 esp, 8
  00078	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  0007e	0f af 45 ac	 imul	 eax, DWORD PTR tv78[ebp]
  00082	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN4@R_DrawTran:

; 498  : 
; 499  : 	// Here we do an additional index re-mapping.
; 500  : 	do
; 501  : 	{
; 502  : 		// Translation tables are used
; 503  : 		//  to map certain colorramps to other ones,
; 504  : 		//  used with PLAY sprites.
; 505  : 		// Thus the "green" ramp of the player 0 sprite
; 506  : 		//  is mapped to gray, red, black/indigo.
; 507  : 		*dest = dc_colormap[dc_translation[dc_source[frac>>FRACBITS]]];

  00085	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00088	c1 f8 10	 sar	 eax, 16			; 00000010H
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  00091	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_translation
  0009a	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0009e	8b 55 f8	 mov	 edx, DWORD PTR _dest$[ebp]
  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_colormap
  000a6	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  000a9	88 0a		 mov	 BYTE PTR [edx], cl

; 508  : 
; 509  : 		dest += vid.width;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  000ae	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  000b4	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 510  : 
; 511  : 		frac += fracstep;

  000b7	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000ba	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  000bd	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 512  : 	} while (count--);

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000c3	89 45 ac	 mov	 DWORD PTR tv93[ebp], eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  000c9	83 e9 01	 sub	 ecx, 1
  000cc	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  000cf	83 7d ac 00	 cmp	 DWORD PTR tv93[ebp], 0
  000d3	75 b0		 jne	 SHORT $LN4@R_DrawTran
$LN3@R_DrawTran:

; 513  : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
_R_DrawTranslatedColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawTranslucentColumn_8
_TEXT	SEGMENT
tv79 = -100						; size = 4
_heightmask$1 = -32					; size = 4
_colormap$2 = -28					; size = 4
_transmap$3 = -24					; size = 4
_source$4 = -20						; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawTranslucentColumn_8 PROC				; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 325  : 	register INT32 count;
; 326  : 	register UINT8 *dest;
; 327  : 	register fixed_t frac, fracstep;
; 328  : 
; 329  : 	count = dc_yh - dc_yl + 1;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 330  : 
; 331  : 	if (count <= 0) // Zero length, column does not exceed a pixel.

  0001a	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0001e	7f 05		 jg	 SHORT $LN11@R_DrawTran

; 332  : 		return;

  00020	e9 f7 01 00 00	 jmp	 $LN17@R_DrawTran
$LN11@R_DrawTran:

; 333  : 
; 334  : #ifdef RANGECHECK
; 335  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 336  : 		I_Error("R_DrawTranslucentColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 337  : #endif
; 338  : 
; 339  : 	// FIXME. As above.
; 340  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 341  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0002a	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00031	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  00037	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  0003d	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 342  : 
; 343  : 	// Looks familiar.
; 344  : 	fracstep = dc_iscale;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00045	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 345  : 	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
; 346  : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  00048	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  0004f	85 c0		 test	 eax, eax
  00051	75 09		 jne	 SHORT $LN19@R_DrawTran
  00053	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN20@R_DrawTran
$LN19@R_DrawTran:
  0005c	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN20@R_DrawTran:
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  00066	51		 push	 ecx
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  0006d	c1 e2 10	 shl	 edx, 16			; 00000010H
  00070	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _FixedMul
  0007c	83 c4 08	 add	 esp, 8
  0007f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00085	0f af 45 9c	 imul	 eax, DWORD PTR tv79[ebp]
  00089	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 347  : 
; 348  : 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
; 349  : 	// This is as fast as it gets.
; 350  : 	{
; 351  : 		register const UINT8 *source = dc_source;

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_source
  00091	89 45 ec	 mov	 DWORD PTR _source$4[ebp], eax

; 352  : 		register const UINT8 *transmap = dc_transmap;

  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_transmap
  00099	89 45 e8	 mov	 DWORD PTR _transmap$3[ebp], eax

; 353  : 		register const lighttable_t *colormap = dc_colormap;

  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_colormap
  000a1	89 45 e4	 mov	 DWORD PTR _colormap$2[ebp], eax

; 354  : 		register INT32 heightmask = dc_texheight - 1;

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000a9	83 e8 01	 sub	 eax, 1
  000ac	89 45 e0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 355  : 		if (dc_texheight & heightmask)

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000b4	23 45 e0	 and	 eax, DWORD PTR _heightmask$1[ebp]
  000b7	0f 84 98 00 00
	00		 je	 $LN12@R_DrawTran

; 356  : 		{
; 357  : 			heightmask++;

  000bd	8b 45 e0	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 e0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 358  : 			heightmask <<= FRACBITS;

  000c6	8b 45 e0	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000c9	c1 e0 10	 shl	 eax, 16			; 00000010H
  000cc	89 45 e0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 359  : 
; 360  : 			if (frac < 0)

  000cf	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp], 0
  000d3	7d 0f		 jge	 SHORT $LN14@R_DrawTran
$LN2@R_DrawTran:

; 361  : 				while ((frac += heightmask) < 0)

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000d8	03 45 e0	 add	 eax, DWORD PTR _heightmask$1[ebp]
  000db	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
  000de	79 02		 jns	 SHORT $LN3@R_DrawTran

; 362  : 					;

  000e0	eb f3		 jmp	 SHORT $LN2@R_DrawTran
$LN3@R_DrawTran:
  000e2	eb 13		 jmp	 SHORT $LN5@R_DrawTran
$LN14@R_DrawTran:

; 363  : 			else
; 364  : 				while (frac >= heightmask)

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000e7	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  000ea	7c 0b		 jl	 SHORT $LN5@R_DrawTran

; 365  : 					frac -= heightmask;

  000ec	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000ef	2b 45 e0	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  000f2	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
  000f5	eb ed		 jmp	 SHORT $LN14@R_DrawTran
$LN5@R_DrawTran:

; 366  : 
; 367  : 			do
; 368  : 			{
; 369  : 				// Re-map color indices from wall texture column
; 370  : 				// using a lighting/special effects LUT.
; 371  : 				// heightmask is the Tutti-Frutti fix
; 372  : 				*dest = colormap[*(transmap + (source[frac>>FRACBITS]<<8) + (*dest))];

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000fa	c1 f8 10	 sar	 eax, 16			; 00000010H
  000fd	8b 4d ec	 mov	 ecx, DWORD PTR _source$4[ebp]
  00100	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00104	c1 e2 08	 shl	 edx, 8
  00107	03 55 e8	 add	 edx, DWORD PTR _transmap$3[ebp]
  0010a	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0010d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00110	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00114	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00117	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  0011a	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0011d	88 10		 mov	 BYTE PTR [eax], dl

; 373  : 				dest += vid.width;

  0011f	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00122	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00128	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 374  : 				if ((frac += fracstep) >= heightmask)

  0012b	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0012e	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  00131	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
  00134	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp]
  00137	3b 4d e0	 cmp	 ecx, DWORD PTR _heightmask$1[ebp]
  0013a	7c 09		 jl	 SHORT $LN16@R_DrawTran

; 375  : 					frac -= heightmask;

  0013c	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0013f	2b 45 e0	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  00142	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN16@R_DrawTran:

; 376  : 			}
; 377  : 			while (--count);

  00145	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00148	83 e8 01	 sub	 eax, 1
  0014b	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  0014e	75 a7		 jne	 SHORT $LN5@R_DrawTran

; 378  : 		}

  00150	e9 c7 00 00 00	 jmp	 $LN17@R_DrawTran
$LN12@R_DrawTran:

; 379  : 		else
; 380  : 		{
; 381  : 			while ((count -= 2) >= 0) // texture height is a power of 2

  00155	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00158	83 e8 02	 sub	 eax, 2
  0015b	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  0015e	0f 88 85 00 00
	00		 js	 $LN10@R_DrawTran

; 382  : 			{
; 383  : 				*dest = colormap[*(transmap + ((source[(frac>>FRACBITS)&heightmask]<<8)) + (*dest))];

  00164	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  00167	c1 f8 10	 sar	 eax, 16			; 00000010H
  0016a	23 45 e0	 and	 eax, DWORD PTR _heightmask$1[ebp]
  0016d	8b 4d ec	 mov	 ecx, DWORD PTR _source$4[ebp]
  00170	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00174	c1 e2 08	 shl	 edx, 8
  00177	03 55 e8	 add	 edx, DWORD PTR _transmap$3[ebp]
  0017a	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0017d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00180	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00184	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00187	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  0018a	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0018d	88 10		 mov	 BYTE PTR [eax], dl

; 384  : 				dest += vid.width;

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00192	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00198	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 385  : 				frac += fracstep;

  0019b	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  0019e	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  001a1	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 386  : 				*dest = colormap[*(transmap + ((source[(frac>>FRACBITS)&heightmask]<<8)) + (*dest))];

  001a4	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  001a7	c1 f8 10	 sar	 eax, 16			; 00000010H
  001aa	23 45 e0	 and	 eax, DWORD PTR _heightmask$1[ebp]
  001ad	8b 4d ec	 mov	 ecx, DWORD PTR _source$4[ebp]
  001b0	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001b4	c1 e2 08	 shl	 edx, 8
  001b7	03 55 e8	 add	 edx, DWORD PTR _transmap$3[ebp]
  001ba	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  001bd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001c0	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  001c4	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  001c7	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  001ca	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  001cd	88 10		 mov	 BYTE PTR [eax], dl

; 387  : 				dest += vid.width;

  001cf	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  001d2	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  001d8	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 388  : 				frac += fracstep;

  001db	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  001de	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  001e1	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 389  : 			}

  001e4	e9 6c ff ff ff	 jmp	 $LN12@R_DrawTran
$LN10@R_DrawTran:

; 390  : 			if (count & 1)

  001e9	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001ec	83 e0 01	 and	 eax, 1
  001ef	74 2b		 je	 SHORT $LN17@R_DrawTran

; 391  : 				*dest = colormap[*(transmap + ((source[(frac>>FRACBITS)&heightmask]<<8)) + (*dest))];

  001f1	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  001f4	c1 f8 10	 sar	 eax, 16			; 00000010H
  001f7	23 45 e0	 and	 eax, DWORD PTR _heightmask$1[ebp]
  001fa	8b 4d ec	 mov	 ecx, DWORD PTR _source$4[ebp]
  001fd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00201	c1 e2 08	 shl	 edx, 8
  00204	03 55 e8	 add	 edx, DWORD PTR _transmap$3[ebp]
  00207	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0020a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0020d	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00211	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00214	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  00217	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0021a	88 10		 mov	 BYTE PTR [eax], dl
$LN17@R_DrawTran:

; 392  : 		}
; 393  : 	}
; 394  : }

  0021c	5f		 pop	 edi
  0021d	5e		 pop	 esi
  0021e	5b		 pop	 ebx
  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
_R_DrawTranslucentColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawShadeColumn_8
_TEXT	SEGMENT
tv80 = -84						; size = 4
tv95 = -84						; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawShadeColumn_8 PROC				; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 283  : 	register INT32 count;
; 284  : 	register UINT8 *dest;
; 285  : 	register fixed_t frac, fracstep;
; 286  : 
; 287  : 	// check out coords for src*
; 288  : 	if ((dc_yl < 0) || (dc_x >= vid.width))

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dc_yl, 0
  00010	7c 0d		 jl	 SHORT $LN6@R_DrawShad
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  00017	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  0001d	7c 05		 jl	 SHORT $LN5@R_DrawShad
$LN6@R_DrawShad:

; 289  : 		return;

  0001f	e9 cd 00 00 00	 jmp	 $LN3@R_DrawShad
$LN5@R_DrawShad:

; 290  : 
; 291  : 	count = dc_yh - dc_yl;

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  00029	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  0002f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 292  : 	if (count < 0)

  00032	79 05		 jns	 SHORT $LN7@R_DrawShad

; 293  : 		return;

  00034	e9 b8 00 00 00	 jmp	 $LN3@R_DrawShad
$LN7@R_DrawShad:

; 294  : 
; 295  : #ifdef RANGECHECK
; 296  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 297  : 		I_Error("R_DrawShadeColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
; 298  : #endif
; 299  : 
; 300  : 	// FIXME. As above.
; 301  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 302  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  0003e	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00045	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  0004b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00051	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 303  : 
; 304  : 	// Looks familiar.
; 305  : 	fracstep = dc_iscale;

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00059	89 45 f0	 mov	 DWORD PTR _fracstep$[ebp], eax

; 306  : 	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
; 307  : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  0005c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  00063	85 c0		 test	 eax, eax
  00065	75 09		 jne	 SHORT $LN9@R_DrawShad
  00067	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  0006e	eb 07		 jmp	 SHORT $LN10@R_DrawShad
$LN9@R_DrawShad:
  00070	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN10@R_DrawShad:
  00077	8b 4d f0	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  00081	c1 e2 10	 shl	 edx, 16			; 00000010H
  00084	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 _FixedMul
  00090	83 c4 08	 add	 esp, 8
  00093	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00099	0f af 45 ac	 imul	 eax, DWORD PTR tv80[ebp]
  0009d	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax
$LN4@R_DrawShad:

; 308  : 
; 309  : 	// Here we do an additional index re-mapping.
; 310  : 	do
; 311  : 	{
; 312  : 		*dest = colormaps[(dc_source[frac>>FRACBITS] <<8) + (*dest)];

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000a3	c1 f8 10	 sar	 eax, 16			; 00000010H
  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_source
  000ac	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000b0	c1 e2 08	 shl	 edx, 8
  000b3	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  000b6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000b9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _colormaps
  000bf	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  000c2	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  000c5	88 08		 mov	 BYTE PTR [eax], cl

; 313  : 		dest += vid.width;

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  000ca	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  000d0	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 314  : 		frac += fracstep;

  000d3	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp]
  000d6	03 45 f0	 add	 eax, DWORD PTR _fracstep$[ebp]
  000d9	89 45 f4	 mov	 DWORD PTR _frac$[ebp], eax

; 315  : 	} while (count--);

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000df	89 45 ac	 mov	 DWORD PTR tv95[ebp], eax
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  000e5	83 e9 01	 sub	 ecx, 1
  000e8	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  000eb	83 7d ac 00	 cmp	 DWORD PTR tv95[ebp], 0
  000ef	75 af		 jne	 SHORT $LN4@R_DrawShad
$LN3@R_DrawShad:

; 316  : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_R_DrawShadeColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawWallColumn_8
_TEXT	SEGMENT
tv204 = -108						; size = 8
tv79 = -104						; size = 4
_heightmask$1 = -36					; size = 8
_colormap$2 = -28					; size = 4
_source$3 = -24						; size = 4
_fracstep$ = -20					; size = 4
_frac$ = -16						; size = 8
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawWallColumn_8 PROC				; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 113  : 	INT32 count;
; 114  : 	register UINT8 *dest;
; 115  : 	register INT64 frac;
; 116  : 	fixed_t fracstep;
; 117  : 
; 118  : 	count = dc_yh - dc_yl;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 119  : 
; 120  : 	if (count < 0) // Zero length, column does not exceed a pixel.

  00017	79 05		 jns	 SHORT $LN11@R_DrawWall

; 121  : 		return;

  00019	e9 8c 02 00 00	 jmp	 $LN17@R_DrawWall
$LN11@R_DrawWall:

; 122  : 
; 123  : #ifdef RANGECHECK
; 124  : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 125  : 		return;
; 126  : #endif
; 127  : 
; 128  : 	// Framebuffer destination address.
; 129  : 	// Use ylookup LUT to avoid multiply with ScreenWidth.
; 130  : 	// Use columnofs LUT for subwindows?
; 131  : 
; 132  : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 133  : 	dest = &topleft[dc_yl*vid.width + dc_x];

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00023	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0002a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00036	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 134  : 
; 135  : 	count++;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 136  : 
; 137  : 	// Determine scaling, which is the only mapping to be done.
; 138  : 	fracstep = dc_iscale;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00047	89 45 ec	 mov	 DWORD PTR _fracstep$[ebp], eax

; 139  : 	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
; 140  : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  0004a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  00051	85 c0		 test	 eax, eax
  00053	75 09		 jne	 SHORT $LN19@R_DrawWall
  00055	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN20@R_DrawWall
$LN19@R_DrawWall:
  0005e	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN20@R_DrawWall:
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  00068	51		 push	 ecx
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  0006f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00072	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _FixedMul
  0007e	83 c4 08	 add	 esp, 8
  00081	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00087	0f af 45 98	 imul	 eax, DWORD PTR tv79[ebp]
  0008b	99		 cdq
  0008c	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0008f	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 141  : 
; 142  : 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
; 143  : 	// This is as fast as it gets.
; 144  : 	{
; 145  : 		register const UINT8 *source = dc_source;

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_source
  00097	89 45 e8	 mov	 DWORD PTR _source$3[ebp], eax

; 146  : 		register const lighttable_t *colormap = dc_colormap;

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_colormap
  0009f	89 45 e4	 mov	 DWORD PTR _colormap$2[ebp], eax

; 147  : 		register INT64 heightmask = dc_texheight-1;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000a7	83 e8 01	 sub	 eax, 1
  000aa	99		 cdq
  000ab	89 45 dc	 mov	 DWORD PTR _heightmask$1[ebp], eax
  000ae	89 55 e0	 mov	 DWORD PTR _heightmask$1[ebp+4], edx

; 148  : 		if (dc_texheight & heightmask)   // not a power of 2 -- killough

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000b6	99		 cdq
  000b7	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  000ba	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  000bd	89 45 94	 mov	 DWORD PTR tv204[ebp], eax
  000c0	89 55 98	 mov	 DWORD PTR tv204[ebp+4], edx
  000c3	8b 45 94	 mov	 eax, DWORD PTR tv204[ebp]
  000c6	0b 45 98	 or	 eax, DWORD PTR tv204[ebp+4]
  000c9	0f 84 f7 00 00
	00		 je	 $LN12@R_DrawWall

; 149  : 		{
; 150  : 			heightmask++;

  000cf	8b 45 dc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	8b 4d e0	 mov	 ecx, DWORD PTR _heightmask$1[ebp+4]
  000d8	83 d1 00	 adc	 ecx, 0
  000db	89 45 dc	 mov	 DWORD PTR _heightmask$1[ebp], eax
  000de	89 4d e0	 mov	 DWORD PTR _heightmask$1[ebp+4], ecx

; 151  : 			heightmask <<= FRACBITS;

  000e1	8b 45 dc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000e4	8b 55 e0	 mov	 edx, DWORD PTR _heightmask$1[ebp+4]
  000e7	b1 10		 mov	 cl, 16			; 00000010H
  000e9	e8 00 00 00 00	 call	 __allshl
  000ee	89 45 dc	 mov	 DWORD PTR _heightmask$1[ebp], eax
  000f1	89 55 e0	 mov	 DWORD PTR _heightmask$1[ebp+4], edx

; 152  : 
; 153  : 			if (frac < 0)

  000f4	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp+4], 0
  000f8	7f 2c		 jg	 SHORT $LN14@R_DrawWall
  000fa	7c 06		 jl	 SHORT $LN21@R_DrawWall
  000fc	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00100	73 24		 jae	 SHORT $LN14@R_DrawWall
$LN21@R_DrawWall:

; 154  : 				while ((frac += heightmask) <  0);

  00102	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  00105	03 45 dc	 add	 eax, DWORD PTR _heightmask$1[ebp]
  00108	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  0010b	13 4d e0	 adc	 ecx, DWORD PTR _heightmask$1[ebp+4]
  0010e	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00111	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
  00114	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp+4], 0
  00118	7f 0a		 jg	 SHORT $LN3@R_DrawWall
  0011a	7c 06		 jl	 SHORT $LN22@R_DrawWall
  0011c	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00120	73 02		 jae	 SHORT $LN3@R_DrawWall
$LN22@R_DrawWall:
  00122	eb de		 jmp	 SHORT $LN21@R_DrawWall
$LN3@R_DrawWall:
  00124	eb 26		 jmp	 SHORT $LN5@R_DrawWall
$LN14@R_DrawWall:

; 155  : 			else
; 156  : 				while (frac >= heightmask)

  00126	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp+4]
  00129	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$1[ebp+4]
  0012c	7c 1e		 jl	 SHORT $LN5@R_DrawWall
  0012e	7f 08		 jg	 SHORT $LN23@R_DrawWall
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  00133	3b 4d dc	 cmp	 ecx, DWORD PTR _heightmask$1[ebp]
  00136	72 14		 jb	 SHORT $LN5@R_DrawWall
$LN23@R_DrawWall:

; 157  : 					frac -= heightmask;

  00138	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0013b	2b 45 dc	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  0013e	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  00141	1b 4d e0	 sbb	 ecx, DWORD PTR _heightmask$1[ebp+4]
  00144	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00147	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
  0014a	eb da		 jmp	 SHORT $LN14@R_DrawWall
$LN5@R_DrawWall:

; 158  : 
; 159  : 			do
; 160  : 			{
; 161  : 				// Re-map color indices from wall texture column
; 162  : 				//  using a lighting/special effects LUT.
; 163  : 				// heightmask is the Tutti-Frutti fix
; 164  : 				*dest = colormap[source[frac>>FRACBITS]];

  0014c	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0014f	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00152	b1 10		 mov	 cl, 16			; 00000010H
  00154	e8 00 00 00 00	 call	 __allshr
  00159	6a 00		 push	 0
  0015b	6a 01		 push	 1
  0015d	52		 push	 edx
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 __allmul
  00164	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  00167	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0016b	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0016e	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  00171	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00174	88 10		 mov	 BYTE PTR [eax], dl

; 165  : 				dest += vid.width;

  00176	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00179	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0017f	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 166  : 				if ((frac += fracstep) >= heightmask)

  00182	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00185	99		 cdq
  00186	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  00189	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  0018c	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0018f	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx
  00192	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp+4]
  00195	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$1[ebp+4]
  00198	7c 1c		 jl	 SHORT $LN16@R_DrawWall
  0019a	7f 08		 jg	 SHORT $LN24@R_DrawWall
  0019c	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  0019f	3b 4d dc	 cmp	 ecx, DWORD PTR _heightmask$1[ebp]
  001a2	72 12		 jb	 SHORT $LN16@R_DrawWall
$LN24@R_DrawWall:

; 167  : 					frac -= heightmask;

  001a4	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  001a7	2b 45 dc	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  001aa	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  001ad	1b 4d e0	 sbb	 ecx, DWORD PTR _heightmask$1[ebp+4]
  001b0	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  001b3	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
$LN16@R_DrawWall:

; 168  : 			} while (--count);

  001b6	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001b9	83 e8 01	 sub	 eax, 1
  001bc	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  001bf	75 8b		 jne	 SHORT $LN5@R_DrawWall

; 169  : 		}

  001c1	e9 e4 00 00 00	 jmp	 $LN17@R_DrawWall
$LN12@R_DrawWall:

; 170  : 		else
; 171  : 		{
; 172  : 			while ((count -= 2) >= 0) // texture height is a power of 2

  001c6	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001c9	83 e8 02	 sub	 eax, 2
  001cc	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  001cf	0f 88 9d 00 00
	00		 js	 $LN10@R_DrawWall

; 173  : 			{
; 174  : 				*dest = colormap[source[(frac>>FRACBITS) & heightmask]];

  001d5	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  001d8	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  001db	b1 10		 mov	 cl, 16			; 00000010H
  001dd	e8 00 00 00 00	 call	 __allshr
  001e2	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  001e5	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  001e8	6a 00		 push	 0
  001ea	6a 01		 push	 1
  001ec	52		 push	 edx
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 __allmul
  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  001f6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001fa	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  001fd	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  00200	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00203	88 10		 mov	 BYTE PTR [eax], dl

; 175  : 				dest += vid.width;

  00205	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00208	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0020e	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 176  : 				frac += fracstep;

  00211	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00214	99		 cdq
  00215	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  00218	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  0021b	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0021e	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 177  : 				*dest = colormap[source[(frac>>FRACBITS) & heightmask]];

  00221	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  00224	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00227	b1 10		 mov	 cl, 16			; 00000010H
  00229	e8 00 00 00 00	 call	 __allshr
  0022e	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  00231	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  00234	6a 00		 push	 0
  00236	6a 01		 push	 1
  00238	52		 push	 edx
  00239	50		 push	 eax
  0023a	e8 00 00 00 00	 call	 __allmul
  0023f	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  00242	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00246	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00249	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  0024c	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0024f	88 10		 mov	 BYTE PTR [eax], dl

; 178  : 				dest += vid.width;

  00251	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00254	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0025a	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 179  : 				frac += fracstep;

  0025d	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00260	99		 cdq
  00261	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  00264	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  00267	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0026a	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 180  : 			}

  0026d	e9 54 ff ff ff	 jmp	 $LN12@R_DrawWall
$LN10@R_DrawWall:

; 181  : 			if (count & 1)

  00272	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00275	83 e0 01	 and	 eax, 1
  00278	74 30		 je	 SHORT $LN17@R_DrawWall

; 182  : 				*dest = colormap[source[(frac>>FRACBITS) & heightmask]];

  0027a	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0027d	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00280	b1 10		 mov	 cl, 16			; 00000010H
  00282	e8 00 00 00 00	 call	 __allshr
  00287	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  0028a	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  0028d	6a 00		 push	 0
  0028f	6a 01		 push	 1
  00291	52		 push	 edx
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 __allmul
  00298	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  0029b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0029f	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  002a2	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  002a5	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  002a8	88 10		 mov	 BYTE PTR [eax], dl
$LN17@R_DrawWall:

; 183  : 		}
; 184  : 	}
; 185  : }

  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi
  002ac	5b		 pop	 ebx
  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c3		 ret	 0
_R_DrawWallColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw8.c
;	COMDAT _R_DrawColumn_8
_TEXT	SEGMENT
tv204 = -108						; size = 8
tv79 = -104						; size = 4
_heightmask$1 = -36					; size = 8
_colormap$2 = -28					; size = 4
_source$3 = -24						; size = 4
_fracstep$ = -20					; size = 4
_frac$ = -16						; size = 8
_dest$ = -8						; size = 4
_count$ = -4						; size = 4
_R_DrawColumn_8 PROC					; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 34   : 	INT32 count;
; 35   : 	register UINT8 *dest;
; 36   : 	register INT64 frac;
; 37   : 	fixed_t fracstep;
; 38   : 
; 39   : 	count = dc_yh - dc_yl;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0000e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _dc_yl
  00014	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 40   : 
; 41   : 	if (count < 0) // Zero length, column does not exceed a pixel.

  00017	79 05		 jns	 SHORT $LN11@R_DrawColu

; 42   : 		return;

  00019	e9 8c 02 00 00	 jmp	 $LN17@R_DrawColu
$LN11@R_DrawColu:

; 43   : 
; 44   : #ifdef RANGECHECK
; 45   : 	if ((unsigned)dc_x >= (unsigned)vid.width || dc_yl < 0 || dc_yh >= vid.height)
; 46   : 		return;
; 47   : #endif
; 48   : 
; 49   : 	// Framebuffer destination address.
; 50   : 	// Use ylookup LUT to avoid multiply with ScreenWidth.
; 51   : 	// Use columnofs LUT for subwindows?
; 52   : 
; 53   : 	//dest = ylookup[dc_yl] + columnofs[dc_x];
; 54   : 	dest = &topleft[dc_yl*vid.width + dc_x];

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00023	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0002a	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_x
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR _topleft
  00036	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 55   : 
; 56   : 	count++;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 57   : 
; 58   : 	// Determine scaling, which is the only mapping to be done.
; 59   : 	fracstep = dc_iscale;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00047	89 45 ec	 mov	 DWORD PTR _fracstep$[ebp], eax

; 60   : 	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
; 61   : 	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);

  0004a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dc_hires
  00051	85 c0		 test	 eax, eax
  00053	75 09		 jne	 SHORT $LN19@R_DrawColu
  00055	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN20@R_DrawColu
$LN19@R_DrawColu:
  0005e	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN20@R_DrawColu:
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _fracstep$[ebp]
  00068	51		 push	 ecx
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_yl
  0006f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00072	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _centeryfrac
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _FixedMul
  0007e	83 c4 08	 add	 esp, 8
  00081	03 05 00 00 00
	00		 add	 eax, DWORD PTR _dc_texturemid
  00087	0f af 45 98	 imul	 eax, DWORD PTR tv79[ebp]
  0008b	99		 cdq
  0008c	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0008f	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 62   : 
; 63   : 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
; 64   : 	// This is as fast as it gets.
; 65   : 	{
; 66   : 		register const UINT8 *source = dc_source;

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_source
  00097	89 45 e8	 mov	 DWORD PTR _source$3[ebp], eax

; 67   : 		register const lighttable_t *colormap = dc_colormap;

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_colormap
  0009f	89 45 e4	 mov	 DWORD PTR _colormap$2[ebp], eax

; 68   : 		register INT64 heightmask = dc_texheight-1;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000a7	83 e8 01	 sub	 eax, 1
  000aa	99		 cdq
  000ab	89 45 dc	 mov	 DWORD PTR _heightmask$1[ebp], eax
  000ae	89 55 e0	 mov	 DWORD PTR _heightmask$1[ebp+4], edx

; 69   : 		if (dc_texheight & heightmask)   // not a power of 2 -- killough

  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texheight
  000b6	99		 cdq
  000b7	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  000ba	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  000bd	89 45 94	 mov	 DWORD PTR tv204[ebp], eax
  000c0	89 55 98	 mov	 DWORD PTR tv204[ebp+4], edx
  000c3	8b 45 94	 mov	 eax, DWORD PTR tv204[ebp]
  000c6	0b 45 98	 or	 eax, DWORD PTR tv204[ebp+4]
  000c9	0f 84 f7 00 00
	00		 je	 $LN12@R_DrawColu

; 70   : 		{
; 71   : 			heightmask++;

  000cf	8b 45 dc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	8b 4d e0	 mov	 ecx, DWORD PTR _heightmask$1[ebp+4]
  000d8	83 d1 00	 adc	 ecx, 0
  000db	89 45 dc	 mov	 DWORD PTR _heightmask$1[ebp], eax
  000de	89 4d e0	 mov	 DWORD PTR _heightmask$1[ebp+4], ecx

; 72   : 			heightmask <<= FRACBITS;

  000e1	8b 45 dc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  000e4	8b 55 e0	 mov	 edx, DWORD PTR _heightmask$1[ebp+4]
  000e7	b1 10		 mov	 cl, 16			; 00000010H
  000e9	e8 00 00 00 00	 call	 __allshl
  000ee	89 45 dc	 mov	 DWORD PTR _heightmask$1[ebp], eax
  000f1	89 55 e0	 mov	 DWORD PTR _heightmask$1[ebp+4], edx

; 73   : 
; 74   : 			if (frac < 0)

  000f4	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp+4], 0
  000f8	7f 2c		 jg	 SHORT $LN14@R_DrawColu
  000fa	7c 06		 jl	 SHORT $LN21@R_DrawColu
  000fc	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00100	73 24		 jae	 SHORT $LN14@R_DrawColu
$LN21@R_DrawColu:

; 75   : 				while ((frac += heightmask) <  0);

  00102	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  00105	03 45 dc	 add	 eax, DWORD PTR _heightmask$1[ebp]
  00108	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  0010b	13 4d e0	 adc	 ecx, DWORD PTR _heightmask$1[ebp+4]
  0010e	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00111	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
  00114	83 7d f4 00	 cmp	 DWORD PTR _frac$[ebp+4], 0
  00118	7f 0a		 jg	 SHORT $LN3@R_DrawColu
  0011a	7c 06		 jl	 SHORT $LN22@R_DrawColu
  0011c	83 7d f0 00	 cmp	 DWORD PTR _frac$[ebp], 0
  00120	73 02		 jae	 SHORT $LN3@R_DrawColu
$LN22@R_DrawColu:
  00122	eb de		 jmp	 SHORT $LN21@R_DrawColu
$LN3@R_DrawColu:
  00124	eb 26		 jmp	 SHORT $LN5@R_DrawColu
$LN14@R_DrawColu:

; 76   : 			else
; 77   : 				while (frac >= heightmask)

  00126	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp+4]
  00129	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$1[ebp+4]
  0012c	7c 1e		 jl	 SHORT $LN5@R_DrawColu
  0012e	7f 08		 jg	 SHORT $LN23@R_DrawColu
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  00133	3b 4d dc	 cmp	 ecx, DWORD PTR _heightmask$1[ebp]
  00136	72 14		 jb	 SHORT $LN5@R_DrawColu
$LN23@R_DrawColu:

; 78   : 					frac -= heightmask;

  00138	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0013b	2b 45 dc	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  0013e	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  00141	1b 4d e0	 sbb	 ecx, DWORD PTR _heightmask$1[ebp+4]
  00144	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  00147	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
  0014a	eb da		 jmp	 SHORT $LN14@R_DrawColu
$LN5@R_DrawColu:

; 79   : 
; 80   : 			do
; 81   : 			{
; 82   : 				// Re-map color indices from wall texture column
; 83   : 				//  using a lighting/special effects LUT.
; 84   : 				// heightmask is the Tutti-Frutti fix
; 85   : 				*dest = colormap[source[frac>>FRACBITS]];

  0014c	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0014f	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00152	b1 10		 mov	 cl, 16			; 00000010H
  00154	e8 00 00 00 00	 call	 __allshr
  00159	6a 00		 push	 0
  0015b	6a 01		 push	 1
  0015d	52		 push	 edx
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 __allmul
  00164	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  00167	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0016b	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  0016e	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  00171	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00174	88 10		 mov	 BYTE PTR [eax], dl

; 86   : 				dest += vid.width;

  00176	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00179	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0017f	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 87   : 				if ((frac += fracstep) >= heightmask)

  00182	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00185	99		 cdq
  00186	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  00189	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  0018c	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0018f	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx
  00192	8b 45 f4	 mov	 eax, DWORD PTR _frac$[ebp+4]
  00195	3b 45 e0	 cmp	 eax, DWORD PTR _heightmask$1[ebp+4]
  00198	7c 1c		 jl	 SHORT $LN16@R_DrawColu
  0019a	7f 08		 jg	 SHORT $LN24@R_DrawColu
  0019c	8b 4d f0	 mov	 ecx, DWORD PTR _frac$[ebp]
  0019f	3b 4d dc	 cmp	 ecx, DWORD PTR _heightmask$1[ebp]
  001a2	72 12		 jb	 SHORT $LN16@R_DrawColu
$LN24@R_DrawColu:

; 88   : 					frac -= heightmask;

  001a4	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  001a7	2b 45 dc	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  001aa	8b 4d f4	 mov	 ecx, DWORD PTR _frac$[ebp+4]
  001ad	1b 4d e0	 sbb	 ecx, DWORD PTR _heightmask$1[ebp+4]
  001b0	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  001b3	89 4d f4	 mov	 DWORD PTR _frac$[ebp+4], ecx
$LN16@R_DrawColu:

; 89   : 			} while (--count);

  001b6	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001b9	83 e8 01	 sub	 eax, 1
  001bc	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  001bf	75 8b		 jne	 SHORT $LN5@R_DrawColu

; 90   : 		}

  001c1	e9 e4 00 00 00	 jmp	 $LN17@R_DrawColu
$LN12@R_DrawColu:

; 91   : 		else
; 92   : 		{
; 93   : 			while ((count -= 2) >= 0) // texture height is a power of 2

  001c6	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  001c9	83 e8 02	 sub	 eax, 2
  001cc	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
  001cf	0f 88 9d 00 00
	00		 js	 $LN10@R_DrawColu

; 94   : 			{
; 95   : 				*dest = colormap[source[(frac>>FRACBITS) & heightmask]];

  001d5	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  001d8	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  001db	b1 10		 mov	 cl, 16			; 00000010H
  001dd	e8 00 00 00 00	 call	 __allshr
  001e2	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  001e5	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  001e8	6a 00		 push	 0
  001ea	6a 01		 push	 1
  001ec	52		 push	 edx
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 __allmul
  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  001f6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001fa	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  001fd	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  00200	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00203	88 10		 mov	 BYTE PTR [eax], dl

; 96   : 				dest += vid.width;

  00205	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00208	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0020e	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 97   : 				frac += fracstep;

  00211	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00214	99		 cdq
  00215	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  00218	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  0021b	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0021e	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 98   : 				*dest = colormap[source[(frac>>FRACBITS) & heightmask]];

  00221	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  00224	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00227	b1 10		 mov	 cl, 16			; 00000010H
  00229	e8 00 00 00 00	 call	 __allshr
  0022e	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  00231	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  00234	6a 00		 push	 0
  00236	6a 01		 push	 1
  00238	52		 push	 edx
  00239	50		 push	 eax
  0023a	e8 00 00 00 00	 call	 __allmul
  0023f	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  00242	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00246	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00249	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  0024c	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0024f	88 10		 mov	 BYTE PTR [eax], dl

; 99   : 				dest += vid.width;

  00251	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  00254	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0025a	89 45 f8	 mov	 DWORD PTR _dest$[ebp], eax

; 100  : 				frac += fracstep;

  0025d	8b 45 ec	 mov	 eax, DWORD PTR _fracstep$[ebp]
  00260	99		 cdq
  00261	03 45 f0	 add	 eax, DWORD PTR _frac$[ebp]
  00264	13 55 f4	 adc	 edx, DWORD PTR _frac$[ebp+4]
  00267	89 45 f0	 mov	 DWORD PTR _frac$[ebp], eax
  0026a	89 55 f4	 mov	 DWORD PTR _frac$[ebp+4], edx

; 101  : 			}

  0026d	e9 54 ff ff ff	 jmp	 $LN12@R_DrawColu
$LN10@R_DrawColu:

; 102  : 			if (count & 1)

  00272	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00275	83 e0 01	 and	 eax, 1
  00278	74 30		 je	 SHORT $LN17@R_DrawColu

; 103  : 				*dest = colormap[source[(frac>>FRACBITS) & heightmask]];

  0027a	8b 45 f0	 mov	 eax, DWORD PTR _frac$[ebp]
  0027d	8b 55 f4	 mov	 edx, DWORD PTR _frac$[ebp+4]
  00280	b1 10		 mov	 cl, 16			; 00000010H
  00282	e8 00 00 00 00	 call	 __allshr
  00287	23 45 dc	 and	 eax, DWORD PTR _heightmask$1[ebp]
  0028a	23 55 e0	 and	 edx, DWORD PTR _heightmask$1[ebp+4]
  0028d	6a 00		 push	 0
  0028f	6a 01		 push	 1
  00291	52		 push	 edx
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 __allmul
  00298	8b 4d e8	 mov	 ecx, DWORD PTR _source$3[ebp]
  0029b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0029f	8b 45 f8	 mov	 eax, DWORD PTR _dest$[ebp]
  002a2	8b 4d e4	 mov	 ecx, DWORD PTR _colormap$2[ebp]
  002a5	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  002a8	88 10		 mov	 BYTE PTR [eax], dl
$LN17@R_DrawColu:

; 104  : 		}
; 105  : 	}
; 106  : }

  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi
  002ac	5b		 pop	 ebx
  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c3		 ret	 0
_R_DrawColumn_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw.c
;	COMDAT _R_VideoErase
_TEXT	SEGMENT
_ofs$ = 8						; size = 4
_count$ = 12						; size = 4
_R_VideoErase PROC					; COMDAT

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 549  : 	// LFB copy.
; 550  : 	// This might not be a good idea if memcpy
; 551  : 	//  is not optimal, e.g. byte by byte on
; 552  : 	//  a 32bit CPU, as GNU GCC/Linux libc did
; 553  : 	//  at one point.
; 554  : 	M_Memcpy(screens[0] + ofs, screens[1] + ofs, count);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  0000c	50		 push	 eax
  0000d	b9 04 00 00 00	 mov	 ecx, 4
  00012	c1 e1 00	 shl	 ecx, 0
  00015	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  0001b	03 55 08	 add	 edx, DWORD PTR _ofs$[ebp]
  0001e	52		 push	 edx
  0001f	b8 04 00 00 00	 mov	 eax, 4
  00024	6b c8 00	 imul	 ecx, eax, 0
  00027	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  0002d	03 55 08	 add	 edx, DWORD PTR _ofs$[ebp]
  00030	52		 push	 edx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_R_VideoErase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw.c
;	COMDAT _R_InitViewBorder
_TEXT	SEGMENT
_R_InitViewBorder PROC					; COMDAT

; 450  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 451  : 	viewborderlump[BRDR_T] = W_GetNumForName("brdr_t");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_06LJGHLNGC@brdr_t@
  0000e	e8 00 00 00 00	 call	 _W_GetNumForName
  00013	83 c4 04	 add	 esp, 4
  00016	b9 04 00 00 00	 mov	 ecx, 4
  0001b	6b d1 00	 imul	 edx, ecx, 0
  0001e	89 82 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[edx], eax

; 452  : 	viewborderlump[BRDR_B] = W_GetNumForName("brdr_b");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_06KFPPAILF@brdr_b@
  00029	e8 00 00 00 00	 call	 _W_GetNumForName
  0002e	83 c4 04	 add	 esp, 4
  00031	b9 04 00 00 00	 mov	 ecx, 4
  00036	c1 e1 00	 shl	 ecx, 0
  00039	89 81 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[ecx], eax

; 453  : 	viewborderlump[BRDR_L] = W_GetNumForName("brdr_l");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_06DLHMCFDL@brdr_l@
  00044	e8 00 00 00 00	 call	 _W_GetNumForName
  00049	83 c4 04	 add	 esp, 4
  0004c	b9 04 00 00 00	 mov	 ecx, 4
  00051	d1 e1		 shl	 ecx, 1
  00053	89 81 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[ecx], eax

; 454  : 	viewborderlump[BRDR_R] = W_GetNumForName("brdr_r");

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_06OPDNBKOE@brdr_r@
  0005e	e8 00 00 00 00	 call	 _W_GetNumForName
  00063	83 c4 04	 add	 esp, 4
  00066	b9 04 00 00 00	 mov	 ecx, 4
  0006b	6b d1 03	 imul	 edx, ecx, 3
  0006e	89 82 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[edx], eax

; 455  : 	viewborderlump[BRDR_TL] = W_GetNumForName("brdr_tl");

  00074	68 00 00 00 00	 push	 OFFSET ??_C@_07GKENEDGC@brdr_tl@
  00079	e8 00 00 00 00	 call	 _W_GetNumForName
  0007e	83 c4 04	 add	 esp, 4
  00081	b9 04 00 00 00	 mov	 ecx, 4
  00086	c1 e1 02	 shl	 ecx, 2
  00089	89 81 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[ecx], eax

; 456  : 	viewborderlump[BRDR_BL] = W_GetNumForName("brdr_bl");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_07HCOGJMKA@brdr_bl@
  00094	e8 00 00 00 00	 call	 _W_GetNumForName
  00099	83 c4 04	 add	 esp, 4
  0009c	b9 04 00 00 00	 mov	 ecx, 4
  000a1	6b d1 06	 imul	 edx, ecx, 6
  000a4	89 82 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[edx], eax

; 457  : 	viewborderlump[BRDR_TR] = W_GetNumForName("brdr_tr");

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_07LOAMHMLN@brdr_tr@
  000af	e8 00 00 00 00	 call	 _W_GetNumForName
  000b4	83 c4 04	 add	 esp, 4
  000b7	b9 04 00 00 00	 mov	 ecx, 4
  000bc	6b d1 05	 imul	 edx, ecx, 5
  000bf	89 82 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[edx], eax

; 458  : 	viewborderlump[BRDR_BR] = W_GetNumForName("brdr_br");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_07KGKHKDHP@brdr_br@
  000ca	e8 00 00 00 00	 call	 _W_GetNumForName
  000cf	83 c4 04	 add	 esp, 4
  000d2	b9 04 00 00 00	 mov	 ecx, 4
  000d7	6b d1 07	 imul	 edx, ecx, 7
  000da	89 82 00 00 00
	00		 mov	 DWORD PTR _viewborderlump[edx], eax

; 459  : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_R_InitViewBorder ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw.c
;	COMDAT _R_InitViewBuffer
_TEXT	SEGMENT
tv92 = -76						; size = 4
_bytesperpixel$ = -8					; size = 4
_i$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_R_InitViewBuffer PROC					; COMDAT

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 412  : 	INT32 i, bytesperpixel = vid.bpp;

  00009	a1 30 00 00 00	 mov	 eax, DWORD PTR _vid+48
  0000e	89 45 f8	 mov	 DWORD PTR _bytesperpixel$[ebp], eax

; 413  : 
; 414  : 	if (width > MAXVIDWIDTH)

  00011	81 7d 08 80 07
	00 00		 cmp	 DWORD PTR _width$[ebp], 1920 ; 00000780H
  00018	7e 07		 jle	 SHORT $LN8@R_InitView

; 415  : 		width = MAXVIDWIDTH;

  0001a	c7 45 08 80 07
	00 00		 mov	 DWORD PTR _width$[ebp], 1920 ; 00000780H
$LN8@R_InitView:

; 416  : 	if (height > MAXVIDHEIGHT)

  00021	81 7d 0c b0 04
	00 00		 cmp	 DWORD PTR _height$[ebp], 1200 ; 000004b0H
  00028	7e 07		 jle	 SHORT $LN9@R_InitView

; 417  : 		height = MAXVIDHEIGHT;

  0002a	c7 45 0c b0 04
	00 00		 mov	 DWORD PTR _height$[ebp], 1200 ; 000004b0H
$LN9@R_InitView:

; 418  : 	if (bytesperpixel < 1 || bytesperpixel > 4)

  00031	83 7d f8 01	 cmp	 DWORD PTR _bytesperpixel$[ebp], 1
  00035	7c 06		 jl	 SHORT $LN11@R_InitView
  00037	83 7d f8 04	 cmp	 DWORD PTR _bytesperpixel$[ebp], 4
  0003b	7e 11		 jle	 SHORT $LN10@R_InitView
$LN11@R_InitView:

; 419  : 		I_Error("R_InitViewBuffer: wrong bytesperpixel value %d\n", bytesperpixel);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _bytesperpixel$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JHACMJAF@R_InitViewBuffer?3?5wrong?5bytespe@
  00046	e8 00 00 00 00	 call	 _I_Error
  0004b	83 c4 08	 add	 esp, 8
$LN10@R_InitView:

; 420  : 
; 421  : 	// Handle resize, e.g. smaller view windows with border and/or status bar.
; 422  : 	viewwindowx = (vid.width - width) >> 1;

  0004e	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00053	2b 45 08	 sub	 eax, DWORD PTR _width$[ebp]
  00056	d1 f8		 sar	 eax, 1
  00058	a3 00 00 00 00	 mov	 DWORD PTR _viewwindowx, eax

; 423  : 
; 424  : 	// Column offset for those columns of the view window, but relative to the entire screen
; 425  : 	for (i = 0; i < width; i++)

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN4@R_InitView
$LN2@R_InitView:
  00066	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_InitView:
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00072	3b 45 08	 cmp	 eax, DWORD PTR _width$[ebp]
  00075	7d 18		 jge	 SHORT $LN3@R_InitView

; 426  : 		columnofs[i] = (viewwindowx + i) * bytesperpixel;

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewwindowx
  0007c	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0007f	0f af 45 f8	 imul	 eax, DWORD PTR _bytesperpixel$[ebp]
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00086	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _columnofs[ecx*4], eax
  0008d	eb d7		 jmp	 SHORT $LN2@R_InitView
$LN3@R_InitView:

; 427  : 
; 428  : 	// Same with base row offset.
; 429  : 	if (width == vid.width)

  0008f	8b 45 08	 mov	 eax, DWORD PTR _width$[ebp]
  00092	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  00098	75 0c		 jne	 SHORT $LN12@R_InitView

; 430  : 		viewwindowy = 0;

  0009a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _viewwindowy, 0
  000a4	eb 0f		 jmp	 SHORT $LN13@R_InitView
$LN12@R_InitView:

; 431  : 	else
; 432  : 		viewwindowy = (vid.height - height) >> 1;

  000a6	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  000ab	2b 45 0c	 sub	 eax, DWORD PTR _height$[ebp]
  000ae	d1 f8		 sar	 eax, 1
  000b0	a3 00 00 00 00	 mov	 DWORD PTR _viewwindowy, eax
$LN13@R_InitView:

; 433  : 
; 434  : 	// Precalculate all row offsets.
; 435  : 	for (i = 0; i < height; i++)

  000b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bc	eb 09		 jmp	 SHORT $LN7@R_InitView
$LN5@R_InitView:
  000be	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@R_InitView:
  000c7	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ca	3b 45 0c	 cmp	 eax, DWORD PTR _height$[ebp]
  000cd	7d 74		 jge	 SHORT $LN6@R_InitView

; 436  : 	{
; 437  : 		ylookup[i] = ylookup1[i] = screens[0] + (i+viewwindowy)*vid.width*bytesperpixel;

  000cf	b8 04 00 00 00	 mov	 eax, 4
  000d4	6b c8 00	 imul	 ecx, eax, 0
  000d7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000da	03 15 00 00 00
	00		 add	 edx, DWORD PTR _viewwindowy
  000e0	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  000e7	0f af 55 f8	 imul	 edx, DWORD PTR _bytesperpixel$[ebp]
  000eb	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  000f1	03 c2		 add	 eax, edx
  000f3	89 45 b4	 mov	 DWORD PTR tv92[ebp], eax
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000f9	8b 55 b4	 mov	 edx, DWORD PTR tv92[ebp]
  000fc	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _ylookup1[ecx*4], edx
  00103	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00106	8b 4d b4	 mov	 ecx, DWORD PTR tv92[ebp]
  00109	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _ylookup[eax*4], ecx

; 438  : 		ylookup2[i] = screens[0] + (i+(vid.height>>1))*vid.width*bytesperpixel; // for splitscreen

  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	6b c8 00	 imul	 ecx, eax, 0
  00118	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  0011e	d1 fa		 sar	 edx, 1
  00120	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00123	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  0012a	0f af 55 f8	 imul	 edx, DWORD PTR _bytesperpixel$[ebp]
  0012e	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  00134	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00137	89 14 85 00 00
	00 00		 mov	 DWORD PTR _ylookup2[eax*4], edx

; 439  : 	}

  0013e	e9 7b ff ff ff	 jmp	 $LN5@R_InitView
$LN6@R_InitView:

; 440  : }

  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
_R_InitViewBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw.c
;	COMDAT _R_InitSkinTranslationTables
_TEXT	SEGMENT
tv218 = -80						; size = 4
_bi$ = -9						; size = 1
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_starttranscolor$ = 8					; size = 4
_skinnum$ = 12						; size = 4
_R_InitSkinTranslationTables PROC			; COMDAT

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 294  : 	INT32 i, j;
; 295  : 	UINT8 bi;
; 296  : 
; 297  : 	// Translate the colors specified by the skin information.
; 298  : 	for (i = 0; i < 256; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@R_InitSkin
$LN2@R_InitSkin:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_InitSkin:
  0001b	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00022	0f 8d 57 03 00
	00		 jge	 $LN3@R_InitSkin

; 299  : 	{
; 300  : 		if (i >= starttranscolor && i < starttranscolor+16)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	3b 45 08	 cmp	 eax, DWORD PTR _starttranscolor$[ebp]
  0002e	0f 8c 11 03 00
	00		 jl	 $LN10@R_InitSkin
  00034	8b 45 08	 mov	 eax, DWORD PTR _starttranscolor$[ebp]
  00037	83 c0 10	 add	 eax, 16			; 00000010H
  0003a	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0003d	0f 8d 02 03 00
	00		 jge	 $LN10@R_InitSkin

; 301  : 		{
; 302  : 			bi = (UINT8)((i - starttranscolor) & 0xf);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	2b 45 08	 sub	 eax, DWORD PTR _starttranscolor$[ebp]
  00049	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004c	88 45 f7	 mov	 BYTE PTR _bi$[ebp], al

; 303  : 
; 304  : 			translationtables[skinnum][i      ] = (UINT8)(0xd0 + bi); // Cyan

  0004f	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00053	05 d0 00 00 00	 add	 eax, 208		; 000000d0H
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  0005b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00065	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 305  : 			translationtables[skinnum][i+  256] = (UINT8)(0x40 + bi); // Peach // Tails 02-19-2000

  00068	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  0006c	83 c0 40	 add	 eax, 64			; 00000040H
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  00072	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0007c	88 84 0a 00 01
	00 00		 mov	 BYTE PTR [edx+ecx+256], al

; 306  : 			translationtables[skinnum][i+2*256] = (UINT8)(0xf8 + bi/2); // Lavender

  00083	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00087	99		 cdq
  00088	2b c2		 sub	 eax, edx
  0008a	d1 f8		 sar	 eax, 1
  0008c	05 f8 00 00 00	 add	 eax, 248		; 000000f8H
  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  00094	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0009e	88 84 0a 00 02
	00 00		 mov	 BYTE PTR [edx+ecx+512], al

; 307  : 			translationtables[skinnum][i+3*256] = (UINT8)(0x00 + bi); // silver // tails 02-19-2000

  000a5	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  000a8	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  000af	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000b2	8a 45 f7	 mov	 al, BYTE PTR _bi$[ebp]
  000b5	88 84 11 00 03
	00 00		 mov	 BYTE PTR [ecx+edx+768], al

; 308  : 			translationtables[skinnum][i+4*256] = (UINT8)(0x50 + bi); // orange // tails 02-19-2000

  000bc	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  000c0	83 c0 50	 add	 eax, 80			; 00000050H
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  000c6	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d0	88 84 0a 00 04
	00 00		 mov	 BYTE PTR [edx+ecx+1024], al

; 309  : 			translationtables[skinnum][i+5*256] = (UINT8)(0x7d + bi); // light red

  000d7	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  000db	83 c0 7d	 add	 eax, 125		; 0000007dH
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  000e1	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000eb	88 84 0a 00 05
	00 00		 mov	 BYTE PTR [edx+ecx+1280], al

; 310  : 			translationtables[skinnum][i+6*256] = (UINT8)(0xe0 + bi); // light blue

  000f2	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  000f6	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  000fb	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  000fe	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00108	88 84 0a 00 06
	00 00		 mov	 BYTE PTR [edx+ecx+1536], al

; 311  : 
; 312  : 			// Steel blue
; 313  : 			translationtables[skinnum][i+7*256] = (UINT8)(0xc8 + bi/2);

  0010f	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00113	99		 cdq
  00114	2b c2		 sub	 eax, edx
  00116	d1 f8		 sar	 eax, 1
  00118	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0011d	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  00120	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0012a	88 84 0a 00 07
	00 00		 mov	 BYTE PTR [edx+ecx+1792], al

; 314  : 
; 315  : 			translationtables[skinnum][i+8*256] = (UINT8)(0x90 + bi/2); // Pink

  00131	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00135	99		 cdq
  00136	2b c2		 sub	 eax, edx
  00138	d1 f8		 sar	 eax, 1
  0013a	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0013f	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  00142	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00149	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0014c	88 84 0a 00 08
	00 00		 mov	 BYTE PTR [edx+ecx+2048], al

; 316  : 			translationtables[skinnum][i+9*256] = (UINT8)(0x20 + bi); // Beige

  00153	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00157	83 c0 20	 add	 eax, 32			; 00000020H
  0015a	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  0015d	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00164	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00167	88 84 0a 00 09
	00 00		 mov	 BYTE PTR [edx+ecx+2304], al

; 317  : 
; 318  : 			// Purple
; 319  : 			translationtables[skinnum][i+10*256] = (UINT8)(0xc0 + bi/2);

  0016e	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00172	99		 cdq
  00173	2b c2		 sub	 eax, edx
  00175	d1 f8		 sar	 eax, 1
  00177	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0017c	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  0017f	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00186	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00189	88 84 0a 00 0a
	00 00		 mov	 BYTE PTR [edx+ecx+2560], al

; 320  : 
; 321  : 			// Green
; 322  : 			translationtables[skinnum][i+11*256] = (UINT8)(0xa0 + bi);

  00190	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00194	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00199	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  0019c	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  001a3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001a6	88 84 0a 00 0b
	00 00		 mov	 BYTE PTR [edx+ecx+2816], al

; 323  : 
; 324  : 			// White
; 325  : 			translationtables[skinnum][i+12*256] = (UINT8)(0x00 + bi/2);

  001ad	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001b1	99		 cdq
  001b2	2b c2		 sub	 eax, edx
  001b4	d1 f8		 sar	 eax, 1
  001b6	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  001b9	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001c3	88 84 0a 00 0c
	00 00		 mov	 BYTE PTR [edx+ecx+3072], al

; 326  : 
; 327  : 			// Gold
; 328  : 			translationtables[skinnum][i+13*256] = (UINT8)(0x70 + bi/2);

  001ca	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001ce	99		 cdq
  001cf	2b c2		 sub	 eax, edx
  001d1	d1 f8		 sar	 eax, 1
  001d3	83 c0 70	 add	 eax, 112		; 00000070H
  001d6	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  001d9	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  001e0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001e3	88 84 0a 00 0d
	00 00		 mov	 BYTE PTR [edx+ecx+3328], al

; 329  : 
; 330  : 			// Yellow
; 331  : 			switch (bi)

  001ea	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001ee	89 45 b0	 mov	 DWORD PTR tv218[ebp], eax
  001f1	83 7d b0 0f	 cmp	 DWORD PTR tv218[ebp], 15 ; 0000000fH
  001f5	0f 87 33 01 00
	00		 ja	 $LN27@R_InitSkin
  001fb	8b 4d b0	 mov	 ecx, DWORD PTR tv218[ebp]
  001fe	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN29@R_InitSkin[ecx*4]
$LN12@R_InitSkin:

; 332  : 			{
; 333  : 				case 0:
; 334  : 					translationtables[skinnum][i+14*256] = 97;

  00205	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00208	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  0020f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00212	c6 84 11 00 0e
	00 00 61	 mov	 BYTE PTR [ecx+edx+3584], 97 ; 00000061H

; 335  : 					break;

  0021a	e9 24 01 00 00	 jmp	 $LN5@R_InitSkin
$LN13@R_InitSkin:

; 336  : 				case 1:
; 337  : 					translationtables[skinnum][i+14*256] = 98;   // yellow

  0021f	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00222	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  00229	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0022c	c6 84 11 00 0e
	00 00 62	 mov	 BYTE PTR [ecx+edx+3584], 98 ; 00000062H

; 338  : 					break;

  00234	e9 0a 01 00 00	 jmp	 $LN5@R_InitSkin
$LN14@R_InitSkin:

; 339  : 				case 2:
; 340  : 					translationtables[skinnum][i+14*256] = 99; // yellow

  00239	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  0023c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  00243	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00246	c6 84 11 00 0e
	00 00 63	 mov	 BYTE PTR [ecx+edx+3584], 99 ; 00000063H

; 341  : 					break;

  0024e	e9 f0 00 00 00	 jmp	 $LN5@R_InitSkin
$LN15@R_InitSkin:

; 342  : 				case 3:
; 343  : 					translationtables[skinnum][i+14*256] = 100;   // yellow

  00253	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00256	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  0025d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00260	c6 84 11 00 0e
	00 00 64	 mov	 BYTE PTR [ecx+edx+3584], 100 ; 00000064H

; 344  : 					break;

  00268	e9 d6 00 00 00	 jmp	 $LN5@R_InitSkin
$LN16@R_InitSkin:

; 345  : 				case 4:
; 346  : 					translationtables[skinnum][i+14*256] = 101; // yellow

  0026d	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00270	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  00277	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0027a	c6 84 11 00 0e
	00 00 65	 mov	 BYTE PTR [ecx+edx+3584], 101 ; 00000065H

; 347  : 					break;

  00282	e9 bc 00 00 00	 jmp	 $LN5@R_InitSkin
$LN17@R_InitSkin:

; 348  : 				case 5:
; 349  : 					translationtables[skinnum][i+14*256] = 102;   // yellow

  00287	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  0028a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  00291	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00294	c6 84 11 00 0e
	00 00 66	 mov	 BYTE PTR [ecx+edx+3584], 102 ; 00000066H

; 350  : 					break;

  0029c	e9 a2 00 00 00	 jmp	 $LN5@R_InitSkin
$LN18@R_InitSkin:

; 351  : 				case 6:
; 352  : 					translationtables[skinnum][i+14*256] = 103; // yellow

  002a1	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  002a4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  002ab	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002ae	c6 84 11 00 0e
	00 00 67	 mov	 BYTE PTR [ecx+edx+3584], 103 ; 00000067H

; 353  : 					break;

  002b6	e9 88 00 00 00	 jmp	 $LN5@R_InitSkin
$LN19@R_InitSkin:

; 354  : 				case 7:
; 355  : 					translationtables[skinnum][i+14*256] = 104;   // yellow

  002bb	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  002be	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  002c5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002c8	c6 84 11 00 0e
	00 00 68	 mov	 BYTE PTR [ecx+edx+3584], 104 ; 00000068H

; 356  : 					break;

  002d0	eb 71		 jmp	 SHORT $LN5@R_InitSkin
$LN20@R_InitSkin:

; 357  : 				case 8:
; 358  : 				case 9:
; 359  : 					translationtables[skinnum][i+14*256] = 113;   // yellow

  002d2	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  002d5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  002dc	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002df	c6 84 11 00 0e
	00 00 71	 mov	 BYTE PTR [ecx+edx+3584], 113 ; 00000071H

; 360  : 					break;

  002e7	eb 5a		 jmp	 SHORT $LN5@R_InitSkin
$LN22@R_InitSkin:

; 361  : 				case 10:
; 362  : 					translationtables[skinnum][i+14*256] = 114;   // yellow

  002e9	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  002ec	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  002f3	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  002f6	c6 84 11 00 0e
	00 00 72	 mov	 BYTE PTR [ecx+edx+3584], 114 ; 00000072H

; 363  : 					break;

  002fe	eb 43		 jmp	 SHORT $LN5@R_InitSkin
$LN23@R_InitSkin:

; 364  : 				case 11:
; 365  : 				case 12:
; 366  : 				case 13:
; 367  : 					translationtables[skinnum][i+14*256] = 115;   // yellow

  00300	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00303	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  0030a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0030d	c6 84 11 00 0e
	00 00 73	 mov	 BYTE PTR [ecx+edx+3584], 115 ; 00000073H

; 368  : 					break;

  00315	eb 2c		 jmp	 SHORT $LN5@R_InitSkin
$LN26@R_InitSkin:

; 369  : 				case 15:
; 370  : 					translationtables[skinnum][i+14*256] = 117; // yellow

  00317	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  0031a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  00321	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00324	c6 84 11 00 0e
	00 00 75	 mov	 BYTE PTR [ecx+edx+3584], 117 ; 00000075H

; 371  : 					break;

  0032c	eb 15		 jmp	 SHORT $LN5@R_InitSkin
$LN27@R_InitSkin:

; 372  : 				default:
; 373  : 					translationtables[skinnum][i+14*256] = 116;   // yellow

  0032e	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00331	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _translationtables[eax*4]
  00338	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0033b	c6 84 11 00 0e
	00 00 74	 mov	 BYTE PTR [ecx+edx+3584], 116 ; 00000074H
$LN5@R_InitSkin:

; 374  : 					break;
; 375  : 			}
; 376  : 		}

  00343	eb 35		 jmp	 SHORT $LN8@R_InitSkin
$LN10@R_InitSkin:

; 377  : 		else // Keep other colors as-is.
; 378  : 		{
; 379  : 			// NOTE: Why MAXSKINCOLORS-1 here, but MAXSKINCOLORS
; 380  : 			// in the above R_InitTranslationTables?
; 381  : 			for (j = 0; j < (MAXSKINCOLORS-1) * 256; j += 256)

  00345	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0034c	eb 0b		 jmp	 SHORT $LN9@R_InitSkin
$LN7@R_InitSkin:
  0034e	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00351	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00356	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN9@R_InitSkin:
  00359	81 7d f8 00 0f
	00 00		 cmp	 DWORD PTR _j$[ebp], 3840 ; 00000f00H
  00360	7d 18		 jge	 SHORT $LN8@R_InitSkin

; 382  : 				translationtables[skinnum][i+j] = (UINT8)i;

  00362	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00365	03 45 f8	 add	 eax, DWORD PTR _j$[ebp]
  00368	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  0036b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[ecx*4]
  00372	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  00375	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00378	eb d4		 jmp	 SHORT $LN7@R_InitSkin
$LN8@R_InitSkin:

; 383  : 		}
; 384  : 	}

  0037a	e9 93 fc ff ff	 jmp	 $LN2@R_InitSkin
$LN3@R_InitSkin:

; 385  : }

  0037f	5f		 pop	 edi
  00380	5e		 pop	 esi
  00381	5b		 pop	 ebx
  00382	8b e5		 mov	 esp, ebp
  00384	5d		 pop	 ebp
  00385	c3		 ret	 0
  00386	66 90		 npad	 2
$LN29@R_InitSkin:
  00388	00 00 00 00	 DD	 $LN12@R_InitSkin
  0038c	00 00 00 00	 DD	 $LN13@R_InitSkin
  00390	00 00 00 00	 DD	 $LN14@R_InitSkin
  00394	00 00 00 00	 DD	 $LN15@R_InitSkin
  00398	00 00 00 00	 DD	 $LN16@R_InitSkin
  0039c	00 00 00 00	 DD	 $LN17@R_InitSkin
  003a0	00 00 00 00	 DD	 $LN18@R_InitSkin
  003a4	00 00 00 00	 DD	 $LN19@R_InitSkin
  003a8	00 00 00 00	 DD	 $LN20@R_InitSkin
  003ac	00 00 00 00	 DD	 $LN20@R_InitSkin
  003b0	00 00 00 00	 DD	 $LN22@R_InitSkin
  003b4	00 00 00 00	 DD	 $LN23@R_InitSkin
  003b8	00 00 00 00	 DD	 $LN23@R_InitSkin
  003bc	00 00 00 00	 DD	 $LN23@R_InitSkin
  003c0	00 00 00 00	 DD	 $LN27@R_InitSkin
  003c4	00 00 00 00	 DD	 $LN26@R_InitSkin
_R_InitSkinTranslationTables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw.c
;	COMDAT _R_LoadSkinTable
_TEXT	SEGMENT
_i$ = -4						; size = 4
_R_LoadSkinTable PROC					; COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 162  : 	INT32 i;
; 163  : 
; 164  : 	for (i = 0; i < MAXSKINS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@R_LoadSkin
$LN2@R_LoadSkin:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_LoadSkin:
  0001b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0001f	7d 1f		 jge	 SHORT $LN3@R_LoadSkin

; 165  : 		translationtables[i] = Z_MallocAlign (256*(MAXSKINCOLORS-1), PU_STATIC, NULL, 16);

  00021	6a 10		 push	 16			; 00000010H
  00023	6a 00		 push	 0
  00025	6a 01		 push	 1
  00027	68 00 0f 00 00	 push	 3840			; 00000f00H
  0002c	e8 00 00 00 00	 call	 _Z_MallocAlign
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00037	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _translationtables[ecx*4], eax
  0003e	eb d2		 jmp	 SHORT $LN2@R_LoadSkin
$LN3@R_LoadSkin:

; 166  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_R_LoadSkinTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_draw.c
;	COMDAT _R_InitTranslationTables
_TEXT	SEGMENT
tv242 = -80						; size = 4
_bi$ = -9						; size = 1
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_R_InitTranslationTables PROC				; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 174  : 	INT32 i, j;
; 175  : 	UINT8 bi;
; 176  : 
; 177  : 	// Load here the transparency lookup tables 'TINTTAB'
; 178  : 	// NOTE: the TINTTAB resource MUST BE aligned on 64k for the asm
; 179  : 	// optimised code (in other words, transtables pointer low word is 0)
; 180  : 	transtables = Z_MallocAlign(NUMTRANSTABLES*0x10000, PU_STATIC,

  00009	6a 10		 push	 16			; 00000010H
  0000b	6a 00		 push	 0
  0000d	6a 01		 push	 1
  0000f	68 00 00 09 00	 push	 589824			; 00090000H
  00014	e8 00 00 00 00	 call	 _Z_MallocAlign
  00019	83 c4 10	 add	 esp, 16			; 00000010H
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _transtables, eax

; 181  : 		NULL, 16);
; 182  : 
; 183  : 	W_ReadLump(W_GetNumForName("TRANS10"), transtables);

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_07PPGLADMN@TRANS10@
  0002c	e8 00 00 00 00	 call	 _W_GetNumForName
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _W_ReadLump
  0003a	83 c4 08	 add	 esp, 8

; 184  : 	W_ReadLump(W_GetNumForName("TRANS20"), transtables+0x10000);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00042	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00047	50		 push	 eax
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_07PNCNLNJE@TRANS20@
  0004d	e8 00 00 00 00	 call	 _W_GetNumForName
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _W_ReadLump
  0005b	83 c4 08	 add	 esp, 8

; 185  : 	W_ReadLump(W_GetNumForName("TRANS30"), transtables+0x20000);

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00063	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_07PMOPNHKD@TRANS30@
  0006e	e8 00 00 00 00	 call	 _W_GetNumForName
  00073	83 c4 04	 add	 esp, 4
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _W_ReadLump
  0007c	83 c4 08	 add	 esp, 8

; 186  : 	W_ReadLump(W_GetNumForName("TRANS40"), transtables+0x30000);

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00084	05 00 00 03 00	 add	 eax, 196608		; 00030000H
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_07PJKAMBCG@TRANS40@
  0008f	e8 00 00 00 00	 call	 _W_GetNumForName
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _W_ReadLump
  0009d	83 c4 08	 add	 esp, 8

; 187  : 	W_ReadLump(W_GetNumForName("TRANS50"), transtables+0x40000);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  000a5	05 00 00 04 00	 add	 eax, 262144		; 00040000H
  000aa	50		 push	 eax
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_07PIGCKLBB@TRANS50@
  000b0	e8 00 00 00 00	 call	 _W_GetNumForName
  000b5	83 c4 04	 add	 esp, 4
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _W_ReadLump
  000be	83 c4 08	 add	 esp, 8

; 188  : 	W_ReadLump(W_GetNumForName("TRANS60"), transtables+0x50000);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  000c6	05 00 00 05 00	 add	 eax, 327680		; 00050000H
  000cb	50		 push	 eax
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_07PKCEBFEI@TRANS60@
  000d1	e8 00 00 00 00	 call	 _W_GetNumForName
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _W_ReadLump
  000df	83 c4 08	 add	 esp, 8

; 189  : 	W_ReadLump(W_GetNumForName("TRANS70"), transtables+0x60000);

  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  000e7	05 00 00 06 00	 add	 eax, 393216		; 00060000H
  000ec	50		 push	 eax
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_07PLOGHPHP@TRANS70@
  000f2	e8 00 00 00 00	 call	 _W_GetNumForName
  000f7	83 c4 04	 add	 esp, 4
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _W_ReadLump
  00100	83 c4 08	 add	 esp, 8

; 190  : 	W_ReadLump(W_GetNumForName("TRANS80"), transtables+0x70000);

  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00108	05 00 00 07 00	 add	 eax, 458752		; 00070000H
  0010d	50		 push	 eax
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_07PALKDIEC@TRANS80@
  00113	e8 00 00 00 00	 call	 _W_GetNumForName
  00118	83 c4 04	 add	 esp, 4
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _W_ReadLump
  00121	83 c4 08	 add	 esp, 8

; 191  : 	W_ReadLump(W_GetNumForName("TRANS90"), transtables+0x80000);

  00124	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00129	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  0012e	50		 push	 eax
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_07PBHIFCHF@TRANS90@
  00134	e8 00 00 00 00	 call	 _W_GetNumForName
  00139	83 c4 04	 add	 esp, 4
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _W_ReadLump
  00142	83 c4 08	 add	 esp, 8

; 192  : 
; 193  : 	// The old "default" transtable for thok mobjs and such
; 194  : 	defaulttranslationtables =

  00145	6a 10		 push	 16			; 00000010H
  00147	6a 00		 push	 0
  00149	6a 01		 push	 1
  0014b	68 00 10 00 00	 push	 4096			; 00001000H
  00150	e8 00 00 00 00	 call	 _Z_MallocAlign
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	a3 00 00 00 00	 mov	 DWORD PTR _defaulttranslationtables, eax

; 195  : 		Z_MallocAlign(256*MAXSKINCOLORS, PU_STATIC, NULL, 16);
; 196  : 
; 197  : 	// Translate the colors specified
; 198  : 	for (i = 0; i < 256; i++)

  0015d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00164	eb 09		 jmp	 SHORT $LN4@R_InitTran
$LN2@R_InitTran:
  00166	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00169	83 c0 01	 add	 eax, 1
  0016c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_InitTran:
  0016f	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  00176	0f 8d 50 02 00
	00		 jge	 $LN3@R_InitTran

; 199  : 	{
; 200  : 		if (i >= 160 && i <= 175)

  0017c	81 7d fc a0 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 160	; 000000a0H
  00183	0f 8c 0f 02 00
	00		 jl	 $LN13@R_InitTran
  00189	81 7d fc af 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 175	; 000000afH
  00190	0f 8f 02 02 00
	00		 jg	 $LN13@R_InitTran

; 201  : 		{
; 202  : 			bi = (UINT8)(i & 0xf);

  00196	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00199	83 e0 0f	 and	 eax, 15			; 0000000fH
  0019c	88 45 f7	 mov	 BYTE PTR _bi$[ebp], al

; 203  : 
; 204  : 			// todo: Is there any particular reason why every color in the palette cannot become a player color?
; 205  : 			defaulttranslationtables[i      ] = (UINT8)(0xd0 + bi); // Cyan

  0019f	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001a3	05 d0 00 00 00	 add	 eax, 208		; 000000d0H
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  001ae	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  001b1	88 01		 mov	 BYTE PTR [ecx], al

; 206  : 			defaulttranslationtables[i+  256] = (UINT8)(0x40 + bi); // Peach // Tails 02-19-2000

  001b3	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001b7	83 c0 40	 add	 eax, 64			; 00000040H
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  001c0	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  001c3	88 81 00 01 00
	00		 mov	 BYTE PTR [ecx+256], al

; 207  : 			defaulttranslationtables[i+2*256] = (UINT8)(0xf8 + bi/2); // Lavender

  001c9	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001cd	99		 cdq
  001ce	2b c2		 sub	 eax, edx
  001d0	d1 f8		 sar	 eax, 1
  001d2	05 f8 00 00 00	 add	 eax, 248		; 000000f8H
  001d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  001dd	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  001e0	88 81 00 02 00
	00		 mov	 BYTE PTR [ecx+512], al

; 208  : 			defaulttranslationtables[i+3*256] = (UINT8)(0x00 + bi); // silver // tails 02-19-2000

  001e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  001eb	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  001ee	8a 4d f7	 mov	 cl, BYTE PTR _bi$[ebp]
  001f1	88 88 00 03 00
	00		 mov	 BYTE PTR [eax+768], cl

; 209  : 			defaulttranslationtables[i+4*256] = (UINT8)(0x50 + bi); // orange // tails 02-19-2000

  001f7	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  001fb	83 c0 50	 add	 eax, 80			; 00000050H
  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  00204	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00207	88 81 00 04 00
	00		 mov	 BYTE PTR [ecx+1024], al

; 210  : 			defaulttranslationtables[i+5*256] = (UINT8)(0x80 + bi); // light red

  0020d	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00211	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  0021c	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0021f	88 81 00 05 00
	00		 mov	 BYTE PTR [ecx+1280], al

; 211  : 			defaulttranslationtables[i+6*256] = (UINT8)(0xe0 + bi); // light blue

  00225	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00229	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  00234	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00237	88 81 00 06 00
	00		 mov	 BYTE PTR [ecx+1536], al

; 212  : 
; 213  : 			// Steel blue
; 214  : 			defaulttranslationtables[i+7*256] = (UINT8)(0xc8 + bi/2);

  0023d	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00241	99		 cdq
  00242	2b c2		 sub	 eax, edx
  00244	d1 f8		 sar	 eax, 1
  00246	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  00251	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00254	88 81 00 07 00
	00		 mov	 BYTE PTR [ecx+1792], al

; 215  : 
; 216  : 			defaulttranslationtables[i+8*256] = (UINT8)(0x90 + bi/2); // Pink

  0025a	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  0025e	99		 cdq
  0025f	2b c2		 sub	 eax, edx
  00261	d1 f8		 sar	 eax, 1
  00263	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  0026e	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00271	88 81 00 08 00
	00		 mov	 BYTE PTR [ecx+2048], al

; 217  : 			defaulttranslationtables[i+9*256] = (UINT8)(0x20 + bi); // Beige

  00277	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  0027b	83 c0 20	 add	 eax, 32			; 00000020H
  0027e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  00284	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00287	88 81 00 09 00
	00		 mov	 BYTE PTR [ecx+2304], al

; 218  : 
; 219  : 			// Purple
; 220  : 			defaulttranslationtables[i+10*256] = (UINT8)(0xc0 + bi/2);

  0028d	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  00291	99		 cdq
  00292	2b c2		 sub	 eax, edx
  00294	d1 f8		 sar	 eax, 1
  00296	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0029b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  002a1	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  002a4	88 81 00 0a 00
	00		 mov	 BYTE PTR [ecx+2560], al

; 221  : 
; 222  : 			// Green
; 223  : 			defaulttranslationtables[i+11*256] = (UINT8)(0xa0 + bi);

  002aa	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  002ae	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  002b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  002b9	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  002bc	88 81 00 0b 00
	00		 mov	 BYTE PTR [ecx+2816], al

; 224  : 
; 225  : 			// White
; 226  : 			defaulttranslationtables[i+12*256] = (UINT8)(0x00 + bi/2);

  002c2	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  002c6	99		 cdq
  002c7	2b c2		 sub	 eax, edx
  002c9	d1 f8		 sar	 eax, 1
  002cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  002d1	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  002d4	88 81 00 0c 00
	00		 mov	 BYTE PTR [ecx+3072], al

; 227  : 
; 228  : 			// Gold
; 229  : 			defaulttranslationtables[i+13*256] = (UINT8)(0x70 + bi/2);

  002da	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  002de	99		 cdq
  002df	2b c2		 sub	 eax, edx
  002e1	d1 f8		 sar	 eax, 1
  002e3	83 c0 70	 add	 eax, 112		; 00000070H
  002e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  002ec	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  002ef	88 81 00 0d 00
	00		 mov	 BYTE PTR [ecx+3328], al

; 230  : 
; 231  : 			// Yellow
; 232  : 			switch (bi)

  002f5	0f b6 45 f7	 movzx	 eax, BYTE PTR _bi$[ebp]
  002f9	89 45 b0	 mov	 DWORD PTR tv242[ebp], eax
  002fc	83 7d b0 0d	 cmp	 DWORD PTR tv242[ebp], 13 ; 0000000dH
  00300	0f 87 81 00 00
	00		 ja	 $LN29@R_InitTran
  00306	8b 4d b0	 mov	 ecx, DWORD PTR tv242[ebp]
  00309	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN31@R_InitTran[ecx*4]
$LN15@R_InitTran:

; 233  : 			{
; 234  : 				case 0:
; 235  : 				case 1:
; 236  : 					defaulttranslationtables[i+14*256] = 0x70;   // yellow

  00310	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  00315	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00318	c6 80 00 0e 00
	00 70		 mov	 BYTE PTR [eax+3584], 112 ; 00000070H

; 237  : 					break;

  0031f	eb 75		 jmp	 SHORT $LN5@R_InitTran
$LN17@R_InitTran:

; 238  : 				case 2:
; 239  : 				case 3:
; 240  : 					defaulttranslationtables[i+14*256] = 0x71;   // yellow

  00321	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  00326	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00329	c6 80 00 0e 00
	00 71		 mov	 BYTE PTR [eax+3584], 113 ; 00000071H

; 241  : 					break;

  00330	eb 64		 jmp	 SHORT $LN5@R_InitTran
$LN19@R_InitTran:

; 242  : 				case 4:
; 243  : 				case 5:
; 244  : 					defaulttranslationtables[i+14*256] = 0x72;   // yellow

  00332	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  00337	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0033a	c6 80 00 0e 00
	00 72		 mov	 BYTE PTR [eax+3584], 114 ; 00000072H

; 245  : 					break;

  00341	eb 53		 jmp	 SHORT $LN5@R_InitTran
$LN21@R_InitTran:

; 246  : 				case 6:
; 247  : 				case 7:
; 248  : 					defaulttranslationtables[i+14*256] = 0x73;   // yellow

  00343	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  00348	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0034b	c6 80 00 0e 00
	00 73		 mov	 BYTE PTR [eax+3584], 115 ; 00000073H

; 249  : 					break;

  00352	eb 42		 jmp	 SHORT $LN5@R_InitTran
$LN23@R_InitTran:

; 250  : 				case 8:
; 251  : 				case 9:
; 252  : 					defaulttranslationtables[i+14*256] = 0x74;   // yellow

  00354	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  00359	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0035c	c6 80 00 0e 00
	00 74		 mov	 BYTE PTR [eax+3584], 116 ; 00000074H

; 253  : 					break;

  00363	eb 31		 jmp	 SHORT $LN5@R_InitTran
$LN25@R_InitTran:

; 254  : 				case 10:
; 255  : 				case 11:
; 256  : 					defaulttranslationtables[i+14*256] = 0x75;   // yellow

  00365	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  0036a	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0036d	c6 80 00 0e 00
	00 75		 mov	 BYTE PTR [eax+3584], 117 ; 00000075H

; 257  : 					break;

  00374	eb 20		 jmp	 SHORT $LN5@R_InitTran
$LN27@R_InitTran:

; 258  : 				case 12:
; 259  : 				case 13:
; 260  : 					defaulttranslationtables[i+14*256] = 0x76;   // yellow

  00376	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  0037b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0037e	c6 80 00 0e 00
	00 76		 mov	 BYTE PTR [eax+3584], 118 ; 00000076H

; 261  : 					break;

  00385	eb 0f		 jmp	 SHORT $LN5@R_InitTran
$LN29@R_InitTran:

; 262  : 				default:
; 263  : 					defaulttranslationtables[i+14*256] = 0x77;   // yellow

  00387	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  0038c	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0038f	c6 80 00 0e 00
	00 77		 mov	 BYTE PTR [eax+3584], 119 ; 00000077H
$LN5@R_InitTran:

; 264  : 					break;
; 265  : 			}
; 266  : 		}

  00396	eb 2f		 jmp	 SHORT $LN8@R_InitTran
$LN13@R_InitTran:

; 267  : 		else // Keep other colors as is.
; 268  : 		{
; 269  : 			for (j = 0; j < MAXSKINCOLORS; j++)

  00398	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0039f	eb 09		 jmp	 SHORT $LN9@R_InitTran
$LN7@R_InitTran:
  003a1	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  003a4	83 c0 01	 add	 eax, 1
  003a7	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN9@R_InitTran:
  003aa	83 7d f8 10	 cmp	 DWORD PTR _j$[ebp], 16	; 00000010H
  003ae	7d 17		 jge	 SHORT $LN8@R_InitTran

; 270  : 				defaulttranslationtables[i+j*256] = (UINT8)i;

  003b0	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  003b3	c1 e0 08	 shl	 eax, 8
  003b6	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  003b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _defaulttranslationtables
  003bf	8a 55 fc	 mov	 dl, BYTE PTR _i$[ebp]
  003c2	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  003c5	eb da		 jmp	 SHORT $LN7@R_InitTran
$LN8@R_InitTran:

; 271  : 		}
; 272  : 	}

  003c7	e9 9a fd ff ff	 jmp	 $LN2@R_InitTran
$LN3@R_InitTran:

; 273  : 
; 274  : 	bosstranslationtables = Z_MallocAlign(256, PU_STATIC, NULL, 16);

  003cc	6a 10		 push	 16			; 00000010H
  003ce	6a 00		 push	 0
  003d0	6a 01		 push	 1
  003d2	68 00 01 00 00	 push	 256			; 00000100H
  003d7	e8 00 00 00 00	 call	 _Z_MallocAlign
  003dc	83 c4 10	 add	 esp, 16			; 00000010H
  003df	a3 00 00 00 00	 mov	 DWORD PTR _bosstranslationtables, eax

; 275  : 
; 276  : 	for (i = 0; i < 256; i++)

  003e4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  003eb	eb 09		 jmp	 SHORT $LN12@R_InitTran
$LN10@R_InitTran:
  003ed	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003f0	83 c0 01	 add	 eax, 1
  003f3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN12@R_InitTran:
  003f6	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 256	; 00000100H
  003fd	7d 0f		 jge	 SHORT $LN11@R_InitTran

; 277  : 		bosstranslationtables[i] = (UINT8)i;

  003ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _bosstranslationtables
  00404	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00407	8a 4d fc	 mov	 cl, BYTE PTR _i$[ebp]
  0040a	88 08		 mov	 BYTE PTR [eax], cl
  0040c	eb df		 jmp	 SHORT $LN10@R_InitTran
$LN11@R_InitTran:

; 278  : 	bosstranslationtables[31] = 0; // White!

  0040e	b8 01 00 00 00	 mov	 eax, 1
  00413	6b c8 1f	 imul	 ecx, eax, 31
  00416	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bosstranslationtables
  0041c	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 279  : }

  00420	5f		 pop	 edi
  00421	5e		 pop	 esi
  00422	5b		 pop	 ebx
  00423	8b e5		 mov	 esp, ebp
  00425	5d		 pop	 ebp
  00426	c3		 ret	 0
  00427	90		 npad	 1
$LN31@R_InitTran:
  00428	00 00 00 00	 DD	 $LN15@R_InitTran
  0042c	00 00 00 00	 DD	 $LN15@R_InitTran
  00430	00 00 00 00	 DD	 $LN17@R_InitTran
  00434	00 00 00 00	 DD	 $LN17@R_InitTran
  00438	00 00 00 00	 DD	 $LN19@R_InitTran
  0043c	00 00 00 00	 DD	 $LN19@R_InitTran
  00440	00 00 00 00	 DD	 $LN21@R_InitTran
  00444	00 00 00 00	 DD	 $LN21@R_InitTran
  00448	00 00 00 00	 DD	 $LN23@R_InitTran
  0044c	00 00 00 00	 DD	 $LN23@R_InitTran
  00450	00 00 00 00	 DD	 $LN25@R_InitTran
  00454	00 00 00 00	 DD	 $LN25@R_InitTran
  00458	00 00 00 00	 DD	 $LN27@R_InitTran
  0045c	00 00 00 00	 DD	 $LN27@R_InitTran
_R_InitTranslationTables ENDP
_TEXT	ENDS
END
