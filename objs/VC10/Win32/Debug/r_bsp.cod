; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\r_bsp.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_checkcoord
PUBLIC	_drawsegs
PUBLIC	_ds_p
PUBLIC	_firstnewseg
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_curline:DWORD
COMM	_sidedef:DWORD
COMM	_linedef:DWORD
COMM	_frontsector:DWORD
COMM	_backsector:DWORD
_DATA	ENDS
_BSS	SEGMENT
_drawsegs DD	01H DUP (?)
_ds_p	DD	01H DUP (?)
_firstnewseg DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_doorclosed:DWORD
COMM	_numpolys:DWORD
COMM	_num_po_ptrs:DWORD
COMM	_po_ptrs:DWORD
COMM	_firstseg:DWORD
_DATA	ENDS
_DATA	SEGMENT
_checkcoord DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	02H
	DD	00H
	DD	03H
	DD	01H
	DD	02H
	DD	00H
	DD	00H
	ORG $+12
	DD	02H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
	ORG $+12
	DD	03H
	DD	01H
	DD	03H
	DD	00H
	DD	00H
	ORG $+12
	DD	02H
	DD	00H
	DD	03H
	DD	01H
	DD	02H
	DD	01H
	DD	03H
	DD	01H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	ORG $+16
_DATA	ENDS
PUBLIC	_R_ClearClipSegs
PUBLIC	_R_ClearDrawSegs
PUBLIC	_R_RenderBSPNode
PUBLIC	_R_SortPolyObjects
PUBLIC	_R_FakeFlat
PUBLIC	_R_GetPlaneLight
PUBLIC	_R_Prep3DFloors
PUBLIC	??_C@_0CO@KEHOKKNP@R_ClipSolidWallSegment?3?5Solid?5S@ ; `string'
EXTRN	_memset:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_qsort:PROC
EXTRN	_I_Error:PROC
EXTRN	_R_PointOnSide:PROC
EXTRN	_R_PointToAngle:PROC
EXTRN	_R_PointToDist2:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_R_StoreWallRange:PROC
EXTRN	_R_FindPlane:PROC
EXTRN	_R_AddSprites:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_splitscreen:DWORD
EXTRN	_viewwidth:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_players:BYTE
EXTRN	_num_extra_colormaps:DWORD
EXTRN	_extra_colormaps:BYTE
EXTRN	_segs:DWORD
EXTRN	_sectors:DWORD
EXTRN	_numsubsectors:DWORD
EXTRN	_subsectors:DWORD
EXTRN	_nodes:DWORD
EXTRN	_viewx:DWORD
EXTRN	_viewy:DWORD
EXTRN	_viewz:DWORD
EXTRN	_viewsector:DWORD
EXTRN	_viewangle:DWORD
EXTRN	_viewplayer:DWORD
EXTRN	_clipangle:DWORD
EXTRN	_doubleclipangle:DWORD
EXTRN	_viewangletox:BYTE
EXTRN	_rw_angle1:DWORD
EXTRN	_floorplane:DWORD
EXTRN	_ceilingplane:DWORD
EXTRN	_ffloor:BYTE
EXTRN	_numffloors:DWORD
EXTRN	_skyflatnum:DWORD
EXTRN	_leveltime:DWORD
EXTRN	_camera:BYTE
EXTRN	_camera2:BYTE
_BSS	SEGMENT
_newend	DD	01H DUP (?)
_solidsegs DQ	03c1H DUP (?)
?tempsec@?1??R_AddLine@@9@9 DB 0f8H DUP (?)		; `R_AddLine'::`2'::tempsec
?tempsec@?1??R_Subsector@@9@9 DB 0f8H DUP (?)		; `R_Subsector'::`2'::tempsec
_BSS	ENDS
;	COMDAT ??_C@_0CO@KEHOKKNP@R_ClipSolidWallSegment?3?5Solid?5S@
CONST	SEGMENT
??_C@_0CO@KEHOKKNP@R_ClipSolidWallSegment?3?5Solid?5S@ DB 'R_ClipSolidWal'
	DB	'lSegment: Solid Segs overflow!', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_Subsector
_TEXT	SEGMENT
tv315 = -104						; size = 4
tv390 = -104						; size = 4
tv447 = -104						; size = 4
_rover$1 = -36						; size = 4
_ceilingcolormap$ = -32					; size = 4
_floorcolormap$ = -28					; size = 4
_sub$ = -24						; size = 4
_line$ = -20						; size = 4
_light$ = -16						; size = 4
_ceilinglightlevel$ = -12				; size = 4
_floorlightlevel$ = -8					; size = 4
_count$ = -4						; size = 4
_num$ = 8						; size = 4
_R_Subsector PROC					; COMDAT

; 718  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 719  : 	INT32 count, floorlightlevel, ceilinglightlevel, light;
; 720  : 	seg_t *line;
; 721  : 	subsector_t *sub;
; 722  : 	static sector_t tempsec; // Deep water hack
; 723  : 	extracolormap_t *floorcolormap;
; 724  : 	extracolormap_t *ceilingcolormap;
; 725  : 
; 726  : #ifdef RANGECHECK
; 727  : 	if (num >= numsubsectors)
; 728  : 		I_Error("R_Subsector: ss %"PRIdS" with numss = %"PRIdS"\n", num, numsubsectors);
; 729  : #endif
; 730  : 
; 731  : 	// subsectors added at run-time
; 732  : 	if (num >= numsubsectors)

  00009	8b 45 08	 mov	 eax, DWORD PTR _num$[ebp]
  0000c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsubsectors
  00012	72 05		 jb	 SHORT $LN7@R_Subsecto

; 733  : 		return;

  00014	e9 37 08 00 00	 jmp	 $LN6@R_Subsecto
$LN7@R_Subsecto:

; 734  : 
; 735  : 	sub = &subsectors[num];

  00019	6b 45 08 14	 imul	 eax, DWORD PTR _num$[ebp], 20
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR _subsectors
  00023	89 45 e8	 mov	 DWORD PTR _sub$[ebp], eax

; 736  : 	frontsector = sub->sector;

  00026	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 0d 00 00 00
	00		 mov	 DWORD PTR _frontsector, ecx

; 737  : 	count = sub->numlines;

  00031	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  00034	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00038	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 738  : 	line = &segs[sub->firstline];

  0003b	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  0003e	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00042	6b d1 3c	 imul	 edx, ecx, 60
  00045	03 15 00 00 00
	00		 add	 edx, DWORD PTR _segs
  0004b	89 55 ec	 mov	 DWORD PTR _line$[ebp], edx

; 739  : 
; 740  : 	// Deep water/fake ceiling effect.
; 741  : 	frontsector = R_FakeFlat(frontsector, &tempsec, &floorlightlevel, &ceilinglightlevel, false);

  0004e	6a 00		 push	 0
  00050	8d 45 f4	 lea	 eax, DWORD PTR _ceilinglightlevel$[ebp]
  00053	50		 push	 eax
  00054	8d 4d f8	 lea	 ecx, DWORD PTR _floorlightlevel$[ebp]
  00057	51		 push	 ecx
  00058	68 00 00 00 00	 push	 OFFSET ?tempsec@?1??R_Subsector@@9@9
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _R_FakeFlat
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	a3 00 00 00 00	 mov	 DWORD PTR _frontsector, eax

; 742  : 
; 743  : 	floorcolormap = ceilingcolormap = frontsector->extra_colormap;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00076	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0007c	89 4d e0	 mov	 DWORD PTR _ceilingcolormap$[ebp], ecx
  0007f	8b 55 e0	 mov	 edx, DWORD PTR _ceilingcolormap$[ebp]
  00082	89 55 e4	 mov	 DWORD PTR _floorcolormap$[ebp], edx

; 744  : 
; 745  : 	// Check and prep all 3D floors. Set the sector floor/ceiling light levels and colormaps.
; 746  : 	if (frontsector->ffloors)

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0008a	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00091	0f 84 38 01 00
	00		 je	 $LN8@R_Subsecto

; 747  : 	{
; 748  : 		if (frontsector->moved)

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0009c	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [eax+172], 0
  000a3	74 79		 je	 SHORT $LN9@R_Subsecto

; 749  : 		{
; 750  : 			frontsector->numlights = sub->sector->numlights = 0;

  000a5	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  000a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000aa	c7 81 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+168], 0
  000b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  000ba	c7 82 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+168], 0

; 751  : 			R_Prep3DFloors(frontsector);

  000c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _R_Prep3DFloors
  000cf	83 c4 04	 add	 esp, 4

; 752  : 			sub->sector->lightlist = frontsector->lightlist;

  000d2	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  000dd	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  000e3	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax

; 753  : 			sub->sector->numlights = frontsector->numlights;

  000e9	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  000ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  000f4	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  000fa	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 754  : 			sub->sector->moved = frontsector->moved = false;

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00105	c7 80 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+172], 0
  0010f	8b 4d e8	 mov	 ecx, DWORD PTR _sub$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	c7 82 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+172], 0
$LN9@R_Subsecto:

; 755  : 		}
; 756  : 
; 757  : 		light = R_GetPlaneLight(frontsector, frontsector->floorheight, false);

  0011e	6a 00		 push	 0
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00125	8b 08		 mov	 ecx, DWORD PTR [eax]
  00127	51		 push	 ecx
  00128	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
  00137	89 45 f0	 mov	 DWORD PTR _light$[ebp], eax

; 758  : 		if (frontsector->floorlightsec == -1)

  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0013f	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  00143	75 1a		 jne	 SHORT $LN10@R_Subsecto

; 759  : 			floorlightlevel = *frontsector->lightlist[light].lightlevel;

  00145	6b 45 f0 14	 imul	 eax, DWORD PTR _light$[ebp], 20
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  0014f	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00155	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00159	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0015c	89 4d f8	 mov	 DWORD PTR _floorlightlevel$[ebp], ecx
$LN10@R_Subsecto:

; 760  : 		floorcolormap = frontsector->lightlist[light].extra_colormap;

  0015f	6b 45 f0 14	 imul	 eax, DWORD PTR _light$[ebp], 20
  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00169	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0016f	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00173	89 45 e4	 mov	 DWORD PTR _floorcolormap$[ebp], eax

; 761  : 		light = R_GetPlaneLight(frontsector, frontsector->ceilingheight, false);

  00176	6a 00		 push	 0
  00178	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0017d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00180	51		 push	 ecx
  00181	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _R_GetPlaneLight
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00190	89 45 f0	 mov	 DWORD PTR _light$[ebp], eax

; 762  : 		if (frontsector->ceilinglightsec == -1)

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00198	83 78 70 ff	 cmp	 DWORD PTR [eax+112], -1
  0019c	75 1a		 jne	 SHORT $LN11@R_Subsecto

; 763  : 			ceilinglightlevel = *frontsector->lightlist[light].lightlevel;

  0019e	6b 45 f0 14	 imul	 eax, DWORD PTR _light$[ebp], 20
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  001a8	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  001ae	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  001b2	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  001b5	89 4d f4	 mov	 DWORD PTR _ceilinglightlevel$[ebp], ecx
$LN11@R_Subsecto:

; 764  : 		ceilingcolormap = frontsector->lightlist[light].extra_colormap;

  001b8	6b 45 f0 14	 imul	 eax, DWORD PTR _light$[ebp], 20
  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  001c2	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  001c8	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  001cc	89 45 e0	 mov	 DWORD PTR _ceilingcolormap$[ebp], eax
$LN8@R_Subsecto:

; 765  : 	}
; 766  : 
; 767  : 	sub->sector->extra_colormap = frontsector->extra_colormap;

  001cf	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  001d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  001da	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  001e0	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax

; 768  : 
; 769  : 	if ((frontsector->floorheight < viewz || (frontsector->heightsec != -1

  001e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  001eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ed	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _viewz
  001f3	7c 29		 jl	 SHORT $LN14@R_Subsecto
  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  001fa	83 78 68 ff	 cmp	 DWORD PTR [eax+104], -1
  001fe	74 67		 je	 SHORT $LN12@R_Subsecto
  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00205	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  0020c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00212	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00216	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _skyflatnum
  0021c	75 49		 jne	 SHORT $LN12@R_Subsecto
$LN14@R_Subsecto:

; 770  : 		&& sectors[frontsector->heightsec].ceilingpic == skyflatnum)))
; 771  : 	{
; 772  : 		floorplane = R_FindPlane(frontsector->floorheight, frontsector->floorpic, floorlightlevel,

  0021e	6a 00		 push	 0
  00220	8b 45 e4	 mov	 eax, DWORD PTR _floorcolormap$[ebp]
  00223	50		 push	 eax
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  0022a	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0022d	52		 push	 edx
  0022e	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00233	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00236	51		 push	 ecx
  00237	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  0023d	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00240	50		 push	 eax
  00241	8b 4d f8	 mov	 ecx, DWORD PTR _floorlightlevel$[ebp]
  00244	51		 push	 ecx
  00245	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  0024b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0024e	50		 push	 eax
  0024f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00255	8b 11		 mov	 edx, DWORD PTR [ecx]
  00257	52		 push	 edx
  00258	e8 00 00 00 00	 call	 _R_FindPlane
  0025d	83 c4 20	 add	 esp, 32			; 00000020H
  00260	a3 00 00 00 00	 mov	 DWORD PTR _floorplane, eax

; 773  : 			frontsector->floor_xoffs, frontsector->floor_yoffs, frontsector->floorpic_angle, floorcolormap, NULL);
; 774  : 	}

  00265	eb 0a		 jmp	 SHORT $LN13@R_Subsecto
$LN12@R_Subsecto:

; 775  : 	else
; 776  : 		floorplane = NULL;

  00267	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _floorplane, 0
$LN13@R_Subsecto:

; 777  : 
; 778  : 	if ((frontsector->ceilingheight > viewz || frontsector->ceilingpic == skyflatnum
; 779  : 		|| (frontsector->heightsec != -1

  00271	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00276	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00279	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _viewz
  0027f	7f 39		 jg	 SHORT $LN17@R_Subsecto
  00281	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00286	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00289	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  0028f	74 29		 je	 SHORT $LN17@R_Subsecto
  00291	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00296	83 78 68 ff	 cmp	 DWORD PTR [eax+104], -1
  0029a	74 68		 je	 SHORT $LN15@R_Subsecto
  0029c	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  002a1	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  002a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  002ae	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  002b2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _skyflatnum
  002b8	75 4a		 jne	 SHORT $LN15@R_Subsecto
$LN17@R_Subsecto:

; 780  : 		&& sectors[frontsector->heightsec].floorpic == skyflatnum)))
; 781  : 	{
; 782  : 		ceilingplane = R_FindPlane(frontsector->ceilingheight, frontsector->ceilingpic,

  002ba	6a 00		 push	 0
  002bc	8b 45 e0	 mov	 eax, DWORD PTR _ceilingcolormap$[ebp]
  002bf	50		 push	 eax
  002c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  002c6	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  002c9	52		 push	 edx
  002ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  002cf	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  002d2	51		 push	 ecx
  002d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  002d9	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  002dc	50		 push	 eax
  002dd	8b 4d f4	 mov	 ecx, DWORD PTR _ceilinglightlevel$[ebp]
  002e0	51		 push	 ecx
  002e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  002e7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002ea	50		 push	 eax
  002eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  002f1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002f4	52		 push	 edx
  002f5	e8 00 00 00 00	 call	 _R_FindPlane
  002fa	83 c4 20	 add	 esp, 32			; 00000020H
  002fd	a3 00 00 00 00	 mov	 DWORD PTR _ceilingplane, eax

; 783  : 			ceilinglightlevel, frontsector->ceiling_xoffs, frontsector->ceiling_yoffs, frontsector->ceilingpic_angle,
; 784  : 			ceilingcolormap, NULL);
; 785  : 	}

  00302	eb 0a		 jmp	 SHORT $LN16@R_Subsecto
$LN15@R_Subsecto:

; 786  : 	else
; 787  : 		ceilingplane = NULL;

  00304	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ceilingplane, 0
$LN16@R_Subsecto:

; 788  : 
; 789  : 	numffloors = 0;

  0030e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numffloors, 0

; 790  : 	ffloor[numffloors].plane = NULL;

  00318	69 05 00 00 00
	00 28 1e 00 00	 imul	 eax, DWORD PTR _numffloors, 7720
  00322	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ffloor[eax], 0

; 791  : 	if (frontsector->ffloors)

  0032c	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00331	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00338	0f 84 a3 04 00
	00		 je	 $LN3@R_Subsecto

; 792  : 	{
; 793  : 		ffloor_t *rover;
; 794  : 
; 795  : 		for (rover = frontsector->ffloors; rover && numffloors < MAXFFLOORS; rover = rover->next)

  0033e	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00343	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00349	89 4d dc	 mov	 DWORD PTR _rover$1[ebp], ecx
  0034c	eb 09		 jmp	 SHORT $LN4@R_Subsecto
$LN2@R_Subsecto:
  0034e	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00351	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00354	89 4d dc	 mov	 DWORD PTR _rover$1[ebp], ecx
$LN4@R_Subsecto:
  00357	83 7d dc 00	 cmp	 DWORD PTR _rover$1[ebp], 0
  0035b	0f 84 80 04 00
	00		 je	 $LN3@R_Subsecto
  00361	83 3d 00 00 00
	00 28		 cmp	 DWORD PTR _numffloors, 40 ; 00000028H
  00368	0f 8d 73 04 00
	00		 jge	 $LN3@R_Subsecto

; 796  : 		{
; 797  : 			if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_RENDERPLANES))

  0036e	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00371	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00374	83 e1 01	 and	 ecx, 1
  00377	74 0b		 je	 SHORT $LN20@R_Subsecto
  00379	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0037c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0037f	83 e1 10	 and	 ecx, 16			; 00000010H
  00382	75 02		 jne	 SHORT $LN19@R_Subsecto
$LN20@R_Subsecto:

; 798  : 				continue;

  00384	eb c8		 jmp	 SHORT $LN2@R_Subsecto
$LN19@R_Subsecto:

; 799  : 
; 800  : 			if (frontsector->cullheight)

  00386	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0038b	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  00392	0f 84 5c 01 00
	00		 je	 $LN28@R_Subsecto

; 801  : 			{
; 802  : 				if (frontsector->cullheight->flags & ML_NOCLIMB) // Group culling

  00398	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0039d	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  003a3	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  003a7	83 e2 40	 and	 edx, 64			; 00000040H
  003aa	0f 84 bf 00 00
	00		 je	 $LN22@R_Subsecto

; 803  : 				{
; 804  : 					// Make sure this is part of the same group
; 805  : 					if (viewsector->cullheight && viewsector->cullheight->frontsector

  003b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsector
  003b5	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  003bc	0f 84 a8 00 00
	00		 je	 $LN26@R_Subsecto
  003c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsector
  003c7	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  003cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  003d3	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  003d9	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  003dc	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  003df	0f 85 85 00 00
	00		 jne	 $LN26@R_Subsecto

; 806  : 						== frontsector->cullheight->frontsector)
; 807  : 					{
; 808  : 						// OK, we can cull
; 809  : 						if (viewz > frontsector->cullheight->frontsector->floorheight
; 810  : 							&& *rover->topheight < frontsector->cullheight->frontsector->floorheight) // Cull if below plane

  003e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  003ea	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  003f0	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  003f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewz
  003f8	3b 02		 cmp	 eax, DWORD PTR [edx]
  003fa	7e 2b		 jle	 SHORT $LN25@R_Subsecto
  003fc	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  003ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00401	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00407	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  0040d	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00410	8b 01		 mov	 eax, DWORD PTR [ecx]
  00412	3b 02		 cmp	 eax, DWORD PTR [edx]
  00414	7d 11		 jge	 SHORT $LN25@R_Subsecto

; 811  : 						{
; 812  : 							rover->norender = leveltime;

  00416	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00419	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _leveltime
  0041f	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 813  : 							continue;

  00422	e9 27 ff ff ff	 jmp	 $LN2@R_Subsecto
$LN25@R_Subsecto:

; 814  : 						}
; 815  : 
; 816  : 						if (*rover->bottomheight > frontsector->cullheight->frontsector->floorheight
; 817  : 							&& viewz <= frontsector->cullheight->frontsector->floorheight) // Cull if above plane

  00427	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0042a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0042d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00433	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00439	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  0043c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0043e	3b 02		 cmp	 eax, DWORD PTR [edx]
  00440	7e 28		 jle	 SHORT $LN26@R_Subsecto
  00442	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00447	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0044d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00450	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewz
  00455	3b 02		 cmp	 eax, DWORD PTR [edx]
  00457	7f 11		 jg	 SHORT $LN26@R_Subsecto

; 818  : 						{
; 819  : 							rover->norender = leveltime;

  00459	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0045c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _leveltime
  00462	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 820  : 							continue;

  00465	e9 e4 fe ff ff	 jmp	 $LN2@R_Subsecto
$LN26@R_Subsecto:

; 821  : 						}
; 822  : 					}
; 823  : 				}

  0046a	e9 85 00 00 00	 jmp	 $LN28@R_Subsecto
$LN22@R_Subsecto:

; 824  : 				else // Quick culling
; 825  : 				{
; 826  : 					if (viewz > frontsector->cullheight->frontsector->floorheight
; 827  : 						&& *rover->topheight < frontsector->cullheight->frontsector->floorheight) // Cull if below plane

  0046f	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00474	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0047a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0047d	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewz
  00482	3b 02		 cmp	 eax, DWORD PTR [edx]
  00484	7e 2b		 jle	 SHORT $LN27@R_Subsecto
  00486	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00489	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00491	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00497	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  0049a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0049c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0049e	7d 11		 jge	 SHORT $LN27@R_Subsecto

; 828  : 					{
; 829  : 						rover->norender = leveltime;

  004a0	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  004a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _leveltime
  004a9	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 830  : 						continue;

  004ac	e9 9d fe ff ff	 jmp	 $LN2@R_Subsecto
$LN27@R_Subsecto:

; 831  : 					}
; 832  : 
; 833  : 					if (*rover->bottomheight > frontsector->cullheight->frontsector->floorheight
; 834  : 						&& viewz <= frontsector->cullheight->frontsector->floorheight) // Cull if above plane

  004b1	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  004b4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  004bd	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  004c3	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  004c6	8b 01		 mov	 eax, DWORD PTR [ecx]
  004c8	3b 02		 cmp	 eax, DWORD PTR [edx]
  004ca	7e 28		 jle	 SHORT $LN28@R_Subsecto
  004cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  004d1	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  004d7	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  004da	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewz
  004df	3b 02		 cmp	 eax, DWORD PTR [edx]
  004e1	7f 11		 jg	 SHORT $LN28@R_Subsecto

; 835  : 					{
; 836  : 						rover->norender = leveltime;

  004e3	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  004e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _leveltime
  004ec	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 837  : 						continue;

  004ef	e9 5a fe ff ff	 jmp	 $LN2@R_Subsecto
$LN28@R_Subsecto:

; 838  : 					}
; 839  : 				}
; 840  : 			}
; 841  : 
; 842  : 			ffloor[numffloors].plane = NULL;

  004f4	69 05 00 00 00
	00 28 1e 00 00	 imul	 eax, DWORD PTR _numffloors, 7720
  004fe	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ffloor[eax], 0

; 843  : 			if (*rover->bottomheight <= frontsector->ceilingheight
; 844  : 				&& *rover->bottomheight >= frontsector->floorheight
; 845  : 				&& ((viewz < *rover->bottomheight && !(rover->flags & FF_INVERTPLANES))

  00508	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0050b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0050e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00514	8b 01		 mov	 eax, DWORD PTR [ecx]
  00516	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00519	0f 8f 46 01 00
	00		 jg	 $LN29@R_Subsecto
  0051f	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00522	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00525	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  0052b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0052d	3b 02		 cmp	 eax, DWORD PTR [edx]
  0052f	0f 8c 30 01 00
	00		 jl	 $LN29@R_Subsecto
  00535	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00538	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0053b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00541	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00543	7d 0e		 jge	 SHORT $LN31@R_Subsecto
  00545	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00548	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0054b	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00551	74 26		 je	 SHORT $LN30@R_Subsecto
$LN31@R_Subsecto:
  00553	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00556	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00559	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  0055f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00561	0f 8e fe 00 00
	00		 jle	 $LN29@R_Subsecto
  00567	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0056a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0056d	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00573	0f 84 ec 00 00
	00		 je	 $LN29@R_Subsecto
$LN30@R_Subsecto:

; 846  : 				|| (viewz > *rover->bottomheight && (rover->flags & FF_BOTHPLANES))))
; 847  : 			{
; 848  : 				light = R_GetPlaneLight(frontsector, *rover->bottomheight,

  00579	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0057c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0057f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00585	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00587	7d 09		 jge	 SHORT $LN38@R_Subsecto
  00589	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv315[ebp], 1
  00590	eb 07		 jmp	 SHORT $LN39@R_Subsecto
$LN38@R_Subsecto:
  00592	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv315[ebp], 0
$LN39@R_Subsecto:
  00599	8b 45 98	 mov	 eax, DWORD PTR tv315[ebp]
  0059c	50		 push	 eax
  0059d	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  005a0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005a3	8b 02		 mov	 eax, DWORD PTR [edx]
  005a5	50		 push	 eax
  005a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  005ac	51		 push	 ecx
  005ad	e8 00 00 00 00	 call	 _R_GetPlaneLight
  005b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b5	89 45 f0	 mov	 DWORD PTR _light$[ebp], eax

; 849  : 					viewz < *rover->bottomheight);
; 850  : 				ffloor[numffloors].plane = R_FindPlane(*rover->bottomheight, *rover->bottompic,

  005b8	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  005bb	50		 push	 eax
  005bc	6b 4d f0 14	 imul	 ecx, DWORD PTR _light$[ebp], 20
  005c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  005c6	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  005cc	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  005d0	51		 push	 ecx
  005d1	8b 55 dc	 mov	 edx, DWORD PTR _rover$1[ebp]
  005d4	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  005d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  005d9	51		 push	 ecx
  005da	8b 55 dc	 mov	 edx, DWORD PTR _rover$1[ebp]
  005dd	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  005e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  005e2	51		 push	 ecx
  005e3	8b 55 dc	 mov	 edx, DWORD PTR _rover$1[ebp]
  005e6	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  005e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005eb	51		 push	 ecx
  005ec	6b 55 f0 14	 imul	 edx, DWORD PTR _light$[ebp], 20
  005f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  005f5	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005fb	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  005ff	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00602	50		 push	 eax
  00603	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  00606	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00609	8b 02		 mov	 eax, DWORD PTR [edx]
  0060b	50		 push	 eax
  0060c	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  0060f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00612	8b 02		 mov	 eax, DWORD PTR [edx]
  00614	50		 push	 eax
  00615	e8 00 00 00 00	 call	 _R_FindPlane
  0061a	83 c4 20	 add	 esp, 32			; 00000020H
  0061d	69 0d 00 00 00
	00 28 1e 00 00	 imul	 ecx, DWORD PTR _numffloors, 7720
  00627	89 81 00 00 00
	00		 mov	 DWORD PTR _ffloor[ecx], eax

; 851  : 					*frontsector->lightlist[light].lightlevel, *rover->bottomxoffs,
; 852  : 					*rover->bottomyoffs, *rover->bottomangle, frontsector->lightlist[light].extra_colormap, rover);
; 853  : 
; 854  : 				ffloor[numffloors].height = *rover->bottomheight;

  0062d	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00630	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00633	69 15 00 00 00
	00 28 1e 00 00	 imul	 edx, DWORD PTR _numffloors, 7720
  0063d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0063f	89 82 04 00 00
	00		 mov	 DWORD PTR _ffloor[edx+4], eax

; 855  : 				ffloor[numffloors].ffloor = rover;

  00645	69 05 00 00 00
	00 28 1e 00 00	 imul	 eax, DWORD PTR _numffloors, 7720
  0064f	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  00652	89 88 24 1e 00
	00		 mov	 DWORD PTR _ffloor[eax+7716], ecx

; 856  : 				numffloors++;

  00658	a1 00 00 00 00	 mov	 eax, DWORD PTR _numffloors
  0065d	83 c0 01	 add	 eax, 1
  00660	a3 00 00 00 00	 mov	 DWORD PTR _numffloors, eax
$LN29@R_Subsecto:

; 857  : 			}
; 858  : 			if (numffloors >= MAXFFLOORS)

  00665	83 3d 00 00 00
	00 28		 cmp	 DWORD PTR _numffloors, 40 ; 00000028H
  0066c	7c 05		 jl	 SHORT $LN32@R_Subsecto

; 859  : 				break;

  0066e	e9 6e 01 00 00	 jmp	 $LN3@R_Subsecto
$LN32@R_Subsecto:

; 860  : 			ffloor[numffloors].plane = NULL;

  00673	69 05 00 00 00
	00 28 1e 00 00	 imul	 eax, DWORD PTR _numffloors, 7720
  0067d	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ffloor[eax], 0

; 861  : 			if (*rover->topheight >= frontsector->floorheight
; 862  : 				&& *rover->topheight <= frontsector->ceilingheight
; 863  : 				&& ((viewz > *rover->topheight && !(rover->flags & FF_INVERTPLANES))

  00687	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0068a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0068c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  00692	8b 01		 mov	 eax, DWORD PTR [ecx]
  00694	3b 02		 cmp	 eax, DWORD PTR [edx]
  00696	0f 8c 40 01 00
	00		 jl	 $LN33@R_Subsecto
  0069c	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  0069f	8b 08		 mov	 ecx, DWORD PTR [eax]
  006a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  006a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  006a9	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  006ac	0f 8f 2a 01 00
	00		 jg	 $LN33@R_Subsecto
  006b2	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  006b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  006bd	3b 11		 cmp	 edx, DWORD PTR [ecx]
  006bf	7e 0e		 jle	 SHORT $LN35@R_Subsecto
  006c1	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  006c4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  006c7	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  006cd	74 25		 je	 SHORT $LN34@R_Subsecto
$LN35@R_Subsecto:
  006cf	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  006d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  006d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  006da	3b 11		 cmp	 edx, DWORD PTR [ecx]
  006dc	0f 8d fa 00 00
	00		 jge	 $LN33@R_Subsecto
  006e2	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  006e5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  006e8	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  006ee	0f 84 e8 00 00
	00		 je	 $LN33@R_Subsecto
$LN34@R_Subsecto:

; 864  : 				|| (viewz < *rover->topheight && (rover->flags & FF_BOTHPLANES))))
; 865  : 			{
; 866  : 				light = R_GetPlaneLight(frontsector, *rover->topheight, viewz < *rover->topheight);

  006f4	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  006f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  006ff	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00701	7d 09		 jge	 SHORT $LN40@R_Subsecto
  00703	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv390[ebp], 1
  0070a	eb 07		 jmp	 SHORT $LN41@R_Subsecto
$LN40@R_Subsecto:
  0070c	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv390[ebp], 0
$LN41@R_Subsecto:
  00713	8b 45 98	 mov	 eax, DWORD PTR tv390[ebp]
  00716	50		 push	 eax
  00717	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  0071a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0071c	8b 02		 mov	 eax, DWORD PTR [edx]
  0071e	50		 push	 eax
  0071f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00725	51		 push	 ecx
  00726	e8 00 00 00 00	 call	 _R_GetPlaneLight
  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0072e	89 45 f0	 mov	 DWORD PTR _light$[ebp], eax

; 867  : 				ffloor[numffloors].plane = R_FindPlane(*rover->topheight, *rover->toppic,

  00731	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  00734	50		 push	 eax
  00735	6b 4d f0 14	 imul	 ecx, DWORD PTR _light$[ebp], 20
  00739	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  0073f	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00745	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  00749	51		 push	 ecx
  0074a	8b 55 dc	 mov	 edx, DWORD PTR _rover$1[ebp]
  0074d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00750	8b 08		 mov	 ecx, DWORD PTR [eax]
  00752	51		 push	 ecx
  00753	8b 55 dc	 mov	 edx, DWORD PTR _rover$1[ebp]
  00756	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00759	8b 08		 mov	 ecx, DWORD PTR [eax]
  0075b	51		 push	 ecx
  0075c	8b 55 dc	 mov	 edx, DWORD PTR _rover$1[ebp]
  0075f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00762	8b 08		 mov	 ecx, DWORD PTR [eax]
  00764	51		 push	 ecx
  00765	6b 55 f0 14	 imul	 edx, DWORD PTR _light$[ebp], 20
  00769	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  0076e	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00774	8b 54 11 04	 mov	 edx, DWORD PTR [ecx+edx+4]
  00778	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0077b	50		 push	 eax
  0077c	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  0077f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00782	8b 02		 mov	 eax, DWORD PTR [edx]
  00784	50		 push	 eax
  00785	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  00788	8b 11		 mov	 edx, DWORD PTR [ecx]
  0078a	8b 02		 mov	 eax, DWORD PTR [edx]
  0078c	50		 push	 eax
  0078d	e8 00 00 00 00	 call	 _R_FindPlane
  00792	83 c4 20	 add	 esp, 32			; 00000020H
  00795	69 0d 00 00 00
	00 28 1e 00 00	 imul	 ecx, DWORD PTR _numffloors, 7720
  0079f	89 81 00 00 00
	00		 mov	 DWORD PTR _ffloor[ecx], eax

; 868  : 					*frontsector->lightlist[light].lightlevel, *rover->topxoffs, *rover->topyoffs, *rover->topangle,
; 869  : 					frontsector->lightlist[light].extra_colormap, rover);
; 870  : 				ffloor[numffloors].height = *rover->topheight;

  007a5	8b 45 dc	 mov	 eax, DWORD PTR _rover$1[ebp]
  007a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  007aa	69 15 00 00 00
	00 28 1e 00 00	 imul	 edx, DWORD PTR _numffloors, 7720
  007b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  007b6	89 82 04 00 00
	00		 mov	 DWORD PTR _ffloor[edx+4], eax

; 871  : 				ffloor[numffloors].ffloor = rover;

  007bc	69 05 00 00 00
	00 28 1e 00 00	 imul	 eax, DWORD PTR _numffloors, 7720
  007c6	8b 4d dc	 mov	 ecx, DWORD PTR _rover$1[ebp]
  007c9	89 88 24 1e 00
	00		 mov	 DWORD PTR _ffloor[eax+7716], ecx

; 872  : 				numffloors++;

  007cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _numffloors
  007d4	83 c0 01	 add	 eax, 1
  007d7	a3 00 00 00 00	 mov	 DWORD PTR _numffloors, eax
$LN33@R_Subsecto:

; 873  : 			}
; 874  : 		}

  007dc	e9 6d fb ff ff	 jmp	 $LN2@R_Subsecto
$LN3@R_Subsecto:

; 875  : 	}
; 876  : 
; 877  : #ifdef POLYOBJECTS_PLANES
; 878  : 	// Polyobjects have planes, too!
; 879  : 	if (sub->polyList)
; 880  : 	{
; 881  : 		polyobj_t *po = sub->polyList;
; 882  : 		sector_t *polysec;
; 883  : 
; 884  : 		while (po)
; 885  : 		{
; 886  : 			if (numffloors >= MAXFFLOORS)
; 887  : 				break;
; 888  : 
; 889  : 			if (!(po->flags & POF_RENDERPLANES)) // Don't draw planes
; 890  : 			{
; 891  : 				po = (polyobj_t *)(po->link.next);
; 892  : 				continue;
; 893  : 			}
; 894  : 
; 895  : 			polysec = po->lines[0]->backsector;
; 896  : 			ffloor[numffloors].plane = NULL;
; 897  : 
; 898  : 			if (polysec->floorheight <= frontsector->ceilingheight
; 899  : 				&& polysec->floorheight >= frontsector->floorheight
; 900  : 				&& (viewz < polysec->floorheight))
; 901  : 			{
; 902  : 				light = R_GetPlaneLight(frontsector, polysec->floorheight, viewz < polysec->floorheight);
; 903  : 				light = 0;
; 904  : 				ffloor[numffloors].plane = R_FindPlane(polysec->floorheight, polysec->floorpic,
; 905  : 						polysec->lightlevel, polysec->floor_xoffs,
; 906  : 						polysec->floor_yoffs,
; 907  : 						polysec->floorpic_angle,
; 908  : 						NULL,
; 909  : 						NULL);
; 910  : 				ffloor[numffloors].plane->polyobj = true;
; 911  : 
; 912  : 				ffloor[numffloors].height = polysec->floorheight;
; 913  : 				ffloor[numffloors].polyobj = po;
; 914  : //				ffloor[numffloors].ffloor = rover;
; 915  : 				numffloors++;
; 916  : 			}
; 917  : 
; 918  : 			if (numffloors >= MAXFFLOORS)
; 919  : 				break;
; 920  : 
; 921  : 			ffloor[numffloors].plane = NULL;
; 922  : 
; 923  : 			if (polysec->ceilingheight >= frontsector->floorheight
; 924  : 				&& polysec->ceilingheight <= frontsector->ceilingheight
; 925  : 				&& (viewz > polysec->ceilingheight))
; 926  : 			{
; 927  : 				light = R_GetPlaneLight(frontsector, polysec->ceilingheight, viewz < polysec->ceilingheight);
; 928  : 				light = 0;
; 929  : 				ffloor[numffloors].plane = R_FindPlane(polysec->ceilingheight, polysec->ceilingpic,
; 930  : 					polysec->lightlevel, polysec->ceiling_xoffs, polysec->ceiling_yoffs, polysec->ceilingpic_angle,
; 931  : 					NULL, NULL);
; 932  : 				ffloor[numffloors].plane->polyobj = true;
; 933  : 				ffloor[numffloors].polyobj = po;
; 934  : 				ffloor[numffloors].height = polysec->ceilingheight;
; 935  : //				ffloor[numffloors].ffloor = rover;
; 936  : 				numffloors++;
; 937  : 			}
; 938  : 
; 939  : 			po = (polyobj_t *)(po->link.next);
; 940  : 		}
; 941  : 	}
; 942  : #endif
; 943  : 
; 944  : #ifdef FLOORSPLATS
; 945  : 	if (sub->splats)
; 946  : 		R_AddVisibleFloorSplats(sub);
; 947  : #endif
; 948  : 
; 949  :    // killough 9/18/98: Fix underwater slowdown, by passing real sector
; 950  :    // instead of fake one. Improve sprite lighting by basing sprite
; 951  :    // lightlevels on floor & ceiling lightlevels in the surrounding area.
; 952  :    //
; 953  :    // 10/98 killough:
; 954  :    //
; 955  :    // NOTE: TeamTNT fixed this bug incorrectly, messing up sprite lighting!!!
; 956  :    // That is part of the 242 effect!!!  If you simply pass sub->sector to
; 957  :    // the old code you will not get correct lighting for underwater sprites!!!
; 958  :    // Either you must pass the fake sector and handle validcount here, on the
; 959  :    // real sector, or you must account for the lighting in some other way,
; 960  :    // like passing it as an argument.
; 961  : 	R_AddSprites(sub->sector, (floorlightlevel+ceilinglightlevel)/2);

  007e1	8b 45 f8	 mov	 eax, DWORD PTR _floorlightlevel$[ebp]
  007e4	03 45 f4	 add	 eax, DWORD PTR _ceilinglightlevel$[ebp]
  007e7	99		 cdq
  007e8	2b c2		 sub	 eax, edx
  007ea	d1 f8		 sar	 eax, 1
  007ec	50		 push	 eax
  007ed	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  007f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  007f2	51		 push	 ecx
  007f3	e8 00 00 00 00	 call	 _R_AddSprites
  007f8	83 c4 08	 add	 esp, 8

; 962  : 
; 963  : 	firstseg = NULL;

  007fb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _firstseg, 0

; 964  : 
; 965  : #ifdef POLYOBJECTS
; 966  : 	// haleyjd 02/19/06: draw polyobjects before static lines
; 967  : 	if (sub->polyList)

  00805	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  00808	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0080c	74 0c		 je	 SHORT $LN36@R_Subsecto

; 968  : 		R_AddPolyObjects(sub);

  0080e	8b 45 e8	 mov	 eax, DWORD PTR _sub$[ebp]
  00811	50		 push	 eax
  00812	e8 00 00 00 00	 call	 _R_AddPolyObjects
  00817	83 c4 04	 add	 esp, 4
$LN36@R_Subsecto:

; 969  : #endif
; 970  : 
; 971  : 	while (count--)

  0081a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0081d	89 45 98	 mov	 DWORD PTR tv447[ebp], eax
  00820	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00823	83 e9 01	 sub	 ecx, 1
  00826	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00829	83 7d 98 00	 cmp	 DWORD PTR tv447[ebp], 0
  0082d	74 21		 je	 SHORT $LN6@R_Subsecto

; 972  : 	{
; 973  : //		CONS_Printf("Adding normal line %d...(%d)\n", line->linedef-lines, leveltime);
; 974  : 		R_AddLine(line);

  0082f	8b 45 ec	 mov	 eax, DWORD PTR _line$[ebp]
  00832	50		 push	 eax
  00833	e8 00 00 00 00	 call	 _R_AddLine
  00838	83 c4 04	 add	 esp, 4

; 975  : 		line++;

  0083b	8b 45 ec	 mov	 eax, DWORD PTR _line$[ebp]
  0083e	83 c0 3c	 add	 eax, 60			; 0000003cH
  00841	89 45 ec	 mov	 DWORD PTR _line$[ebp], eax

; 976  : 		curline = NULL; /* cph 2001/11/18 - must clear curline now we're done with it, so stuff doesn't try using it for other things */

  00844	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _curline, 0

; 977  : 	}

  0084e	eb ca		 jmp	 SHORT $LN36@R_Subsecto
$LN6@R_Subsecto:

; 978  : }

  00850	5f		 pop	 edi
  00851	5e		 pop	 esi
  00852	5b		 pop	 ebx
  00853	8b e5		 mov	 esp, ebp
  00855	5d		 pop	 ebp
  00856	c3		 ret	 0
_R_Subsector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_AddPolyObjects
_TEXT	SEGMENT
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_po$ = -4						; size = 4
_sub$ = 8						; size = 4
_R_AddPolyObjects PROC					; COMDAT

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 684  : 	polyobj_t *po = sub->polyList;

  00009	8b 45 08	 mov	 eax, DWORD PTR _sub$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d fc	 mov	 DWORD PTR _po$[ebp], ecx

; 685  : 	size_t i, j;
; 686  : 
; 687  : 	numpolys = 0;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numpolys, 0
$LN2@R_AddPolyO:

; 688  : 
; 689  : 	// count polyobjects
; 690  : 	while (po)

  0001c	83 7d fc 00	 cmp	 DWORD PTR _po$[ebp], 0
  00020	74 17		 je	 SHORT $LN3@R_AddPolyO

; 691  : 	{
; 692  : 		++numpolys;

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _numpolys
  00027	83 c0 01	 add	 eax, 1
  0002a	a3 00 00 00 00	 mov	 DWORD PTR _numpolys, eax

; 693  : 		po = (polyobj_t *)(po->link.next);

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _po$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	89 4d fc	 mov	 DWORD PTR _po$[ebp], ecx

; 694  : 	}

  00037	eb e3		 jmp	 SHORT $LN2@R_AddPolyO
$LN3@R_AddPolyO:

; 695  : 
; 696  : 	// sort polyobjects
; 697  : 	R_SortPolyObjects(sub);

  00039	8b 45 08	 mov	 eax, DWORD PTR _sub$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _R_SortPolyObjects
  00042	83 c4 04	 add	 esp, 4

; 698  : 
; 699  : 	// render polyobjects
; 700  : 	for (i = 0; i < numpolys; ++i)

  00045	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004c	eb 09		 jmp	 SHORT $LN6@R_AddPolyO
$LN4@R_AddPolyO:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@R_AddPolyO:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numpolys
  00060	73 48		 jae	 SHORT $LN5@R_AddPolyO

; 701  : 	{
; 702  : 		for (j = 0; j < po_ptrs[i]->segCount; ++j)

  00062	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00069	eb 09		 jmp	 SHORT $LN9@R_AddPolyO
$LN7@R_AddPolyO:
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN9@R_AddPolyO:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _po_ptrs
  0007d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00080	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00083	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00086	73 20		 jae	 SHORT $LN8@R_AddPolyO

; 703  : 			R_AddLine(po_ptrs[i]->segs[j]);

  00088	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _po_ptrs
  00091	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00094	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00097	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0009a	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _R_AddLine
  000a3	83 c4 04	 add	 esp, 4
  000a6	eb c3		 jmp	 SHORT $LN7@R_AddPolyO
$LN8@R_AddPolyO:

; 704  : 	}

  000a8	eb a4		 jmp	 SHORT $LN4@R_AddPolyO
$LN5@R_AddPolyO:

; 705  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_R_AddPolyObjects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_PolyobjCompare
_TEXT	SEGMENT
_po2$ = -8						; size = 4
_po1$ = -4						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_R_PolyobjCompare PROC					; COMDAT

; 624  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 625  : 	const polyobj_t *po1 = *(const polyobj_t * const *)p1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _po1$[ebp], ecx

; 626  : 	const polyobj_t *po2 = *(const polyobj_t * const *)p2;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _p2$[ebp]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	89 4d f8	 mov	 DWORD PTR _po2$[ebp], ecx

; 627  : 
; 628  : 	return po1->zdist - po2->zdist;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _po1$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _po2$[ebp]
  0001f	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00022	2b 41 6c	 sub	 eax, DWORD PTR [ecx+108]

; 629  : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_R_PolyobjCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_CheckBBox
_TEXT	SEGMENT
_start$ = -48						; size = 4
_tspan$ = -44						; size = 4
_span$ = -40						; size = 4
_angle2$ = -36						; size = 4
_angle1$ = -32						; size = 4
_py2$ = -28						; size = 4
_px2$ = -24						; size = 4
_py1$ = -20						; size = 4
_px1$ = -16						; size = 4
_sx2$ = -12						; size = 4
_sx1$ = -8						; size = 4
_boxpos$ = -4						; size = 4
_bspcoord$ = 8						; size = 4
_R_CheckBBox PROC					; COMDAT

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 527  : 	INT32 boxpos, sx1, sx2;
; 528  : 	fixed_t px1, py1, px2, py2;
; 529  : 	angle_t angle1, angle2, span, tspan;
; 530  : 	cliprange_t *start;
; 531  : 
; 532  : 	// Find the corners of the box that define the edges from current viewpoint.
; 533  : 	if (viewx <= bspcoord[BOXLEFT])

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	d1 e0		 shl	 eax, 1
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewx
  00019	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  0001c	7f 09		 jg	 SHORT $LN4@R_CheckBBo

; 534  : 		boxpos = 0;

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _boxpos$[ebp], 0
  00025	eb 25		 jmp	 SHORT $LN7@R_CheckBBo
$LN4@R_CheckBBo:

; 535  : 	else if (viewx < bspcoord[BOXRIGHT])

  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	6b c8 03	 imul	 ecx, eax, 3
  0002f	8b 55 08	 mov	 edx, DWORD PTR _bspcoord$[ebp]
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewx
  00037	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  0003a	7d 09		 jge	 SHORT $LN6@R_CheckBBo

; 536  : 		boxpos = 1;

  0003c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _boxpos$[ebp], 1
  00043	eb 07		 jmp	 SHORT $LN7@R_CheckBBo
$LN6@R_CheckBBo:

; 537  : 	else
; 538  : 		boxpos = 2;

  00045	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _boxpos$[ebp], 2
$LN7@R_CheckBBo:

; 539  : 
; 540  : 	if (viewy >= bspcoord[BOXTOP])

  0004c	b8 04 00 00 00	 mov	 eax, 4
  00051	6b c8 00	 imul	 ecx, eax, 0
  00054	8b 55 08	 mov	 edx, DWORD PTR _bspcoord$[ebp]
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewy
  0005c	3b 04 0a	 cmp	 eax, DWORD PTR [edx+ecx]
  0005f	7c 08		 jl	 SHORT $LN8@R_CheckBBo

; 541  : 		boxpos |= 0;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  00064	89 45 fc	 mov	 DWORD PTR _boxpos$[ebp], eax
  00067	eb 2a		 jmp	 SHORT $LN11@R_CheckBBo
$LN8@R_CheckBBo:

; 542  : 	else if (viewy > bspcoord[BOXBOTTOM])

  00069	b8 04 00 00 00	 mov	 eax, 4
  0006e	c1 e0 00	 shl	 eax, 0
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewy
  0007a	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  0007d	7e 0b		 jle	 SHORT $LN10@R_CheckBBo

; 543  : 		boxpos |= 1<<2;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  00082	83 c8 04	 or	 eax, 4
  00085	89 45 fc	 mov	 DWORD PTR _boxpos$[ebp], eax
  00088	eb 09		 jmp	 SHORT $LN11@R_CheckBBo
$LN10@R_CheckBBo:

; 544  : 	else
; 545  : 		boxpos |= 2<<2;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  0008d	83 c8 08	 or	 eax, 8
  00090	89 45 fc	 mov	 DWORD PTR _boxpos$[ebp], eax
$LN11@R_CheckBBo:

; 546  : 
; 547  : 	if (boxpos == 5)

  00093	83 7d fc 05	 cmp	 DWORD PTR _boxpos$[ebp], 5
  00097	75 0a		 jne	 SHORT $LN12@R_CheckBBo

; 548  : 		return true;

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	e9 c0 01 00 00	 jmp	 $LN1@R_CheckBBo
$LN12@R_CheckBBo:

; 549  : 
; 550  : 	px1 = bspcoord[checkcoord[boxpos][0]];

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000a6	c1 e0 04	 shl	 eax, 4
  000a9	b9 04 00 00 00	 mov	 ecx, 4
  000ae	6b d1 00	 imul	 edx, ecx, 0
  000b1	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR _checkcoord[eax+edx]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  000bb	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000be	89 55 f0	 mov	 DWORD PTR _px1$[ebp], edx

; 551  : 	py1 = bspcoord[checkcoord[boxpos][1]];

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000c4	c1 e0 04	 shl	 eax, 4
  000c7	b9 04 00 00 00	 mov	 ecx, 4
  000cc	c1 e1 00	 shl	 ecx, 0
  000cf	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _checkcoord[eax+ecx]
  000d6	8b 45 08	 mov	 eax, DWORD PTR _bspcoord$[ebp]
  000d9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000dc	89 4d ec	 mov	 DWORD PTR _py1$[ebp], ecx

; 552  : 	px2 = bspcoord[checkcoord[boxpos][2]];

  000df	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000e2	c1 e0 04	 shl	 eax, 4
  000e5	b9 04 00 00 00	 mov	 ecx, 4
  000ea	d1 e1		 shl	 ecx, 1
  000ec	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR _checkcoord[eax+ecx]
  000f3	8b 45 08	 mov	 eax, DWORD PTR _bspcoord$[ebp]
  000f6	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000f9	89 4d e8	 mov	 DWORD PTR _px2$[ebp], ecx

; 553  : 	py2 = bspcoord[checkcoord[boxpos][3]];

  000fc	8b 45 fc	 mov	 eax, DWORD PTR _boxpos$[ebp]
  000ff	c1 e0 04	 shl	 eax, 4
  00102	b9 04 00 00 00	 mov	 ecx, 4
  00107	6b d1 03	 imul	 edx, ecx, 3
  0010a	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR _checkcoord[eax+edx]
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _bspcoord$[ebp]
  00114	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00117	89 55 e4	 mov	 DWORD PTR _py2$[ebp], edx

; 554  : 
; 555  : 	// check clip list for an open space
; 556  : 	angle1 = R_PointToAngle(px1, py1) - viewangle;

  0011a	8b 45 ec	 mov	 eax, DWORD PTR _py1$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _px1$[ebp]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 _R_PointToAngle
  00127	83 c4 08	 add	 esp, 8
  0012a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _viewangle
  00130	89 45 e0	 mov	 DWORD PTR _angle1$[ebp], eax

; 557  : 	angle2 = R_PointToAngle(px2, py2) - viewangle;

  00133	8b 45 e4	 mov	 eax, DWORD PTR _py2$[ebp]
  00136	50		 push	 eax
  00137	8b 4d e8	 mov	 ecx, DWORD PTR _px2$[ebp]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _R_PointToAngle
  00140	83 c4 08	 add	 esp, 8
  00143	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _viewangle
  00149	89 45 dc	 mov	 DWORD PTR _angle2$[ebp], eax

; 558  : 
; 559  : 	span = angle1 - angle2;

  0014c	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  0014f	2b 45 dc	 sub	 eax, DWORD PTR _angle2$[ebp]
  00152	89 45 d8	 mov	 DWORD PTR _span$[ebp], eax

; 560  : 
; 561  : 	// Sitting on a line?
; 562  : 	if (span >= ANGLE_180)

  00155	81 7d d8 00 00
	00 80		 cmp	 DWORD PTR _span$[ebp], -2147483648 ; 80000000H
  0015c	72 0a		 jb	 SHORT $LN13@R_CheckBBo

; 563  : 		return true;

  0015e	b8 01 00 00 00	 mov	 eax, 1
  00163	e9 fb 00 00 00	 jmp	 $LN1@R_CheckBBo
$LN13@R_CheckBBo:

; 564  : 
; 565  : 	tspan = angle1 + clipangle;

  00168	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  0016b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _clipangle
  00171	89 45 d4	 mov	 DWORD PTR _tspan$[ebp], eax

; 566  : 
; 567  : 	if (tspan > doubleclipangle)

  00174	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  00177	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _doubleclipangle
  0017d	76 23		 jbe	 SHORT $LN14@R_CheckBBo

; 568  : 	{
; 569  : 		tspan -= doubleclipangle;

  0017f	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  00182	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _doubleclipangle
  00188	89 45 d4	 mov	 DWORD PTR _tspan$[ebp], eax

; 570  : 
; 571  : 		// Totally off the left edge?
; 572  : 		if (tspan >= span)

  0018b	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  0018e	3b 45 d8	 cmp	 eax, DWORD PTR _span$[ebp]
  00191	72 07		 jb	 SHORT $LN15@R_CheckBBo

; 573  : 			return false;

  00193	33 c0		 xor	 eax, eax
  00195	e9 c9 00 00 00	 jmp	 $LN1@R_CheckBBo
$LN15@R_CheckBBo:

; 574  : 
; 575  : 		angle1 = clipangle;

  0019a	a1 00 00 00 00	 mov	 eax, DWORD PTR _clipangle
  0019f	89 45 e0	 mov	 DWORD PTR _angle1$[ebp], eax
$LN14@R_CheckBBo:

; 576  : 	}
; 577  : 	tspan = clipangle - angle2;

  001a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _clipangle
  001a7	2b 45 dc	 sub	 eax, DWORD PTR _angle2$[ebp]
  001aa	89 45 d4	 mov	 DWORD PTR _tspan$[ebp], eax

; 578  : 	if (tspan > doubleclipangle)

  001ad	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  001b0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _doubleclipangle
  001b6	76 25		 jbe	 SHORT $LN16@R_CheckBBo

; 579  : 	{
; 580  : 		tspan -= doubleclipangle;

  001b8	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  001bb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _doubleclipangle
  001c1	89 45 d4	 mov	 DWORD PTR _tspan$[ebp], eax

; 581  : 
; 582  : 		// Totally off the left edge?
; 583  : 		if (tspan >= span)

  001c4	8b 45 d4	 mov	 eax, DWORD PTR _tspan$[ebp]
  001c7	3b 45 d8	 cmp	 eax, DWORD PTR _span$[ebp]
  001ca	72 07		 jb	 SHORT $LN17@R_CheckBBo

; 584  : 			return false;

  001cc	33 c0		 xor	 eax, eax
  001ce	e9 90 00 00 00	 jmp	 $LN1@R_CheckBBo
$LN17@R_CheckBBo:

; 585  : 
; 586  : 		angle2 = -(signed)clipangle;

  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _clipangle
  001d8	f7 d8		 neg	 eax
  001da	89 45 dc	 mov	 DWORD PTR _angle2$[ebp], eax
$LN16@R_CheckBBo:

; 587  : 	}
; 588  : 
; 589  : 	// Find the first clippost that touches the source post (adjacent pixels are touching).
; 590  : 	angle1 = (angle1+ANGLE_90)>>ANGLETOFINESHIFT;

  001dd	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  001e0	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  001e5	c1 e8 13	 shr	 eax, 19			; 00000013H
  001e8	89 45 e0	 mov	 DWORD PTR _angle1$[ebp], eax

; 591  : 	angle2 = (angle2+ANGLE_90)>>ANGLETOFINESHIFT;

  001eb	8b 45 dc	 mov	 eax, DWORD PTR _angle2$[ebp]
  001ee	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  001f3	c1 e8 13	 shr	 eax, 19			; 00000013H
  001f6	89 45 dc	 mov	 DWORD PTR _angle2$[ebp], eax

; 592  : 	sx1 = viewangletox[angle1];

  001f9	8b 45 e0	 mov	 eax, DWORD PTR _angle1$[ebp]
  001fc	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _viewangletox[eax*4]
  00203	89 4d f8	 mov	 DWORD PTR _sx1$[ebp], ecx

; 593  : 	sx2 = viewangletox[angle2];

  00206	8b 45 dc	 mov	 eax, DWORD PTR _angle2$[ebp]
  00209	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _viewangletox[eax*4]
  00210	89 4d f4	 mov	 DWORD PTR _sx2$[ebp], ecx

; 594  : 
; 595  : 	// Does not cross a pixel.
; 596  : 	if (sx1 == sx2)

  00213	8b 45 f8	 mov	 eax, DWORD PTR _sx1$[ebp]
  00216	3b 45 f4	 cmp	 eax, DWORD PTR _sx2$[ebp]
  00219	75 04		 jne	 SHORT $LN18@R_CheckBBo

; 597  : 		return false;

  0021b	33 c0		 xor	 eax, eax
  0021d	eb 44		 jmp	 SHORT $LN1@R_CheckBBo
$LN18@R_CheckBBo:

; 598  : 	sx2--;

  0021f	8b 45 f4	 mov	 eax, DWORD PTR _sx2$[ebp]
  00222	83 e8 01	 sub	 eax, 1
  00225	89 45 f4	 mov	 DWORD PTR _sx2$[ebp], eax

; 599  : 
; 600  : 	start = solidsegs;

  00228	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _solidsegs
$LN2@R_CheckBBo:

; 601  : 	while (start->last < sx2)

  0022f	8b 45 d0	 mov	 eax, DWORD PTR _start$[ebp]
  00232	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00235	3b 4d f4	 cmp	 ecx, DWORD PTR _sx2$[ebp]
  00238	7d 0b		 jge	 SHORT $LN3@R_CheckBBo

; 602  : 		start++;

  0023a	8b 45 d0	 mov	 eax, DWORD PTR _start$[ebp]
  0023d	83 c0 08	 add	 eax, 8
  00240	89 45 d0	 mov	 DWORD PTR _start$[ebp], eax
  00243	eb ea		 jmp	 SHORT $LN2@R_CheckBBo
$LN3@R_CheckBBo:

; 603  : 
; 604  : 	if (sx1 >= start->first && sx2 <= start->last)

  00245	8b 45 d0	 mov	 eax, DWORD PTR _start$[ebp]
  00248	8b 4d f8	 mov	 ecx, DWORD PTR _sx1$[ebp]
  0024b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0024d	7c 0f		 jl	 SHORT $LN19@R_CheckBBo
  0024f	8b 45 d0	 mov	 eax, DWORD PTR _start$[ebp]
  00252	8b 4d f4	 mov	 ecx, DWORD PTR _sx2$[ebp]
  00255	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00258	7f 04		 jg	 SHORT $LN19@R_CheckBBo

; 605  : 		return false; // The clippost contains the new span.

  0025a	33 c0		 xor	 eax, eax
  0025c	eb 05		 jmp	 SHORT $LN1@R_CheckBBo
$LN19@R_CheckBBo:

; 606  : 
; 607  : 	return true;

  0025e	b8 01 00 00 00	 mov	 eax, 1
$LN1@R_CheckBBo:

; 608  : }

  00263	5f		 pop	 edi
  00264	5e		 pop	 esi
  00265	5b		 pop	 ebx
  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
_R_CheckBBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_AddLine
_TEXT	SEGMENT
_tspan$ = -24						; size = 4
_span$ = -20						; size = 4
_angle2$ = -16						; size = 4
_angle1$ = -12						; size = 4
_x2$ = -8						; size = 4
_x1$ = -4						; size = 4
_line$ = 8						; size = 4
_R_AddLine PROC						; COMDAT

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 372  : 	INT32 x1, x2;
; 373  : 	angle_t angle1, angle2, span, tspan;
; 374  : 	static sector_t tempsec; // ceiling/water hack
; 375  : 
; 376  : 	if (line->polyseg && !(line->polyseg->flags & POF_RENDERSIDES))

  00009	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0000c	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00010	74 16		 je	 SHORT $LN2@R_AddLine
  00012	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00015	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00018	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0001e	83 e2 08	 and	 edx, 8
  00021	75 05		 jne	 SHORT $LN2@R_AddLine

; 377  : 		return;

  00023	e9 77 03 00 00	 jmp	 $LN1@R_AddLine
$LN2@R_AddLine:

; 378  : 
; 379  : 	curline = line;

  00028	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR _curline, eax

; 380  : 
; 381  : 	// OPTIMIZE: quickly reject orthogonal back sides.
; 382  : 	angle1 = R_PointToAngle(line->v1->x, line->v1->y);

  00030	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _R_PointToAngle
  00046	83 c4 08	 add	 esp, 8
  00049	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax

; 383  : 	angle2 = R_PointToAngle(line->v2->x, line->v2->y);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  0004f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	52		 push	 edx
  00056	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _R_PointToAngle
  00064	83 c4 08	 add	 esp, 8
  00067	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax

; 384  : 
; 385  : 	// Clip to view edges.
; 386  : 	span = angle1 - angle2;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  0006d	2b 45 f0	 sub	 eax, DWORD PTR _angle2$[ebp]
  00070	89 45 ec	 mov	 DWORD PTR _span$[ebp], eax

; 387  : 
; 388  : 	// Back side? i.e. backface culling?
; 389  : 	if (span >= ANGLE_180)

  00073	81 7d ec 00 00
	00 80		 cmp	 DWORD PTR _span$[ebp], -2147483648 ; 80000000H
  0007a	72 05		 jb	 SHORT $LN3@R_AddLine

; 390  : 		return;

  0007c	e9 1e 03 00 00	 jmp	 $LN1@R_AddLine
$LN3@R_AddLine:

; 391  : 
; 392  : 	// Global angle needed by segcalc.
; 393  : 	rw_angle1 = angle1;

  00081	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  00084	a3 00 00 00 00	 mov	 DWORD PTR _rw_angle1, eax

; 394  : 	angle1 -= viewangle;

  00089	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  0008c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _viewangle
  00092	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax

; 395  : 	angle2 -= viewangle;

  00095	8b 45 f0	 mov	 eax, DWORD PTR _angle2$[ebp]
  00098	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _viewangle
  0009e	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax

; 396  : 
; 397  : 	tspan = angle1 + clipangle;

  000a1	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  000a4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _clipangle
  000aa	89 45 e8	 mov	 DWORD PTR _tspan$[ebp], eax

; 398  : 	if (tspan > doubleclipangle)

  000ad	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  000b0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _doubleclipangle
  000b6	76 21		 jbe	 SHORT $LN4@R_AddLine

; 399  : 	{
; 400  : 		tspan -= doubleclipangle;

  000b8	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  000bb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _doubleclipangle
  000c1	89 45 e8	 mov	 DWORD PTR _tspan$[ebp], eax

; 401  : 
; 402  : 		// Totally off the left edge?
; 403  : 		if (tspan >= span)

  000c4	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  000c7	3b 45 ec	 cmp	 eax, DWORD PTR _span$[ebp]
  000ca	72 05		 jb	 SHORT $LN5@R_AddLine

; 404  : 			return;

  000cc	e9 ce 02 00 00	 jmp	 $LN1@R_AddLine
$LN5@R_AddLine:

; 405  : 
; 406  : 		angle1 = clipangle;

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _clipangle
  000d6	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax
$LN4@R_AddLine:

; 407  : 	}
; 408  : 	tspan = clipangle - angle2;

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _clipangle
  000de	2b 45 f0	 sub	 eax, DWORD PTR _angle2$[ebp]
  000e1	89 45 e8	 mov	 DWORD PTR _tspan$[ebp], eax

; 409  : 	if (tspan > doubleclipangle)

  000e4	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  000e7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _doubleclipangle
  000ed	76 23		 jbe	 SHORT $LN6@R_AddLine

; 410  : 	{
; 411  : 		tspan -= doubleclipangle;

  000ef	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  000f2	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _doubleclipangle
  000f8	89 45 e8	 mov	 DWORD PTR _tspan$[ebp], eax

; 412  : 
; 413  : 		// Totally off the left edge?
; 414  : 		if (tspan >= span)

  000fb	8b 45 e8	 mov	 eax, DWORD PTR _tspan$[ebp]
  000fe	3b 45 ec	 cmp	 eax, DWORD PTR _span$[ebp]
  00101	72 05		 jb	 SHORT $LN7@R_AddLine

; 415  : 			return;

  00103	e9 97 02 00 00	 jmp	 $LN1@R_AddLine
$LN7@R_AddLine:

; 416  : 
; 417  : 		angle2 = -(signed)clipangle;

  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR _clipangle
  0010d	f7 d8		 neg	 eax
  0010f	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax
$LN6@R_AddLine:

; 418  : 	}
; 419  : 
; 420  : 	// The seg is in the view range, but not necessarily visible.
; 421  : 	angle1 = (angle1+ANGLE_90)>>ANGLETOFINESHIFT;

  00112	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  00115	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  0011a	c1 e8 13	 shr	 eax, 19			; 00000013H
  0011d	89 45 f4	 mov	 DWORD PTR _angle1$[ebp], eax

; 422  : 	angle2 = (angle2+ANGLE_90)>>ANGLETOFINESHIFT;

  00120	8b 45 f0	 mov	 eax, DWORD PTR _angle2$[ebp]
  00123	05 00 00 00 40	 add	 eax, 1073741824		; 40000000H
  00128	c1 e8 13	 shr	 eax, 19			; 00000013H
  0012b	89 45 f0	 mov	 DWORD PTR _angle2$[ebp], eax

; 423  : 	x1 = viewangletox[angle1];

  0012e	8b 45 f4	 mov	 eax, DWORD PTR _angle1$[ebp]
  00131	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _viewangletox[eax*4]
  00138	89 4d fc	 mov	 DWORD PTR _x1$[ebp], ecx

; 424  : 	x2 = viewangletox[angle2];

  0013b	8b 45 f0	 mov	 eax, DWORD PTR _angle2$[ebp]
  0013e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _viewangletox[eax*4]
  00145	89 4d f8	 mov	 DWORD PTR _x2$[ebp], ecx

; 425  : 
; 426  : 	// Does not cross a pixel?
; 427  : 	if (x1 >= x2)       // killough 1/31/98 -- change == to >= for robustness

  00148	8b 45 fc	 mov	 eax, DWORD PTR _x1$[ebp]
  0014b	3b 45 f8	 cmp	 eax, DWORD PTR _x2$[ebp]
  0014e	7c 05		 jl	 SHORT $LN8@R_AddLine

; 428  : 		return;

  00150	e9 4a 02 00 00	 jmp	 $LN1@R_AddLine
$LN8@R_AddLine:

; 429  : 
; 430  : 	backsector = line->backsector;

  00155	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00158	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0015b	89 0d 00 00 00
	00		 mov	 DWORD PTR _backsector, ecx

; 431  : 
; 432  : 	// Single sided line?
; 433  : 	if (!backsector)

  00161	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _backsector, 0
  00168	75 05		 jne	 SHORT $LN9@R_AddLine

; 434  : 		goto clipsolid;

  0016a	e9 1d 02 00 00	 jmp	 $clipsolid$20
$LN9@R_AddLine:

; 435  : 
; 436  : 	backsector = R_FakeFlat(backsector, &tempsec, NULL, NULL, true);

  0016f	6a 01		 push	 1
  00171	6a 00		 push	 0
  00173	6a 00		 push	 0
  00175	68 00 00 00 00	 push	 OFFSET ?tempsec@?1??R_AddLine@@9@9
  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 _R_FakeFlat
  00185	83 c4 14	 add	 esp, 20			; 00000014H
  00188	a3 00 00 00 00	 mov	 DWORD PTR _backsector, eax

; 437  : 
; 438  : 	doorclosed = 0;

  0018d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _doorclosed, 0

; 439  : 
; 440  : 	// Closed door.
; 441  : 	if (backsector->ceilingheight <= frontsector->floorheight
; 442  : 		|| backsector->floorheight >= frontsector->ceilingheight)

  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  0019c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  001a2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001a5	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001a7	7e 12		 jle	 SHORT $LN11@R_AddLine
  001a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  001b4	8b 10		 mov	 edx, DWORD PTR [eax]
  001b6	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b9	7c 05		 jl	 SHORT $LN10@R_AddLine
$LN11@R_AddLine:

; 443  : 	{
; 444  : 		goto clipsolid;

  001bb	e9 cc 01 00 00	 jmp	 $clipsolid$20
$LN10@R_AddLine:

; 445  : 	}
; 446  : 
; 447  : 	// Check for automap fix. Store in doorclosed for r_segs.c
; 448  : 	doorclosed = R_DoorClosed();

  001c0	e8 00 00 00 00	 call	 _R_DoorClosed
  001c5	a3 00 00 00 00	 mov	 DWORD PTR _doorclosed, eax

; 449  : 	if (doorclosed)

  001ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _doorclosed, 0
  001d1	74 05		 je	 SHORT $LN12@R_AddLine

; 450  : 		goto clipsolid;

  001d3	e9 b4 01 00 00	 jmp	 $clipsolid$20
$LN12@R_AddLine:

; 451  : 
; 452  : 	// Window.
; 453  : 	if (backsector->ceilingheight != frontsector->ceilingheight
; 454  : 		|| backsector->floorheight != frontsector->floorheight)

  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  001e3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e6	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001e9	75 11		 jne	 SHORT $LN14@R_AddLine
  001eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  001f6	8b 10		 mov	 edx, DWORD PTR [eax]
  001f8	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001fa	74 05		 je	 SHORT $LN13@R_AddLine
$LN14@R_AddLine:

; 455  : 	{
; 456  : 		goto clippass;

  001fc	e9 76 01 00 00	 jmp	 $clippass$21
$LN13@R_AddLine:

; 457  : 	}
; 458  : 
; 459  : 	// Reject empty lines used for triggers and special events.
; 460  : 	// Identical floor and ceiling on both sides, identical light levels on both sides,
; 461  : 	// and no middle texture.
; 462  : 	if (line->linedef->flags & ML_EFFECT6) // Don't even draw these lines

  00201	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00204	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00207	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  0020b	83 e2 01	 and	 edx, 1
  0020e	74 05		 je	 SHORT $LN15@R_AddLine

; 463  : 		return;

  00210	e9 8a 01 00 00	 jmp	 $LN1@R_AddLine
$LN15@R_AddLine:

; 464  : 
; 465  : 	if (
; 466  : #ifdef POLYOBJECTS
; 467  : 		!line->polyseg &&
; 468  : #endif
; 469  : 		backsector->ceilingpic == frontsector->ceilingpic
; 470  : 		&& backsector->floorpic == frontsector->floorpic
; 471  : 		&& backsector->lightlevel == frontsector->lightlevel
; 472  : 		&& !curline->sidedef->midtexture
; 473  : 		// Check offsets too!
; 474  : 		&& backsector->floor_xoffs == frontsector->floor_xoffs
; 475  : 		&& backsector->floor_yoffs == frontsector->floor_yoffs
; 476  : 		&& backsector->floorpic_angle == frontsector->floorpic_angle
; 477  : 		&& backsector->ceiling_xoffs == frontsector->ceiling_xoffs
; 478  : 		&& backsector->ceiling_yoffs == frontsector->ceiling_yoffs
; 479  : 		&& backsector->ceilingpic_angle == frontsector->ceilingpic_angle
; 480  : 		// Consider altered lighting.
; 481  : 		&& backsector->floorlightsec == frontsector->floorlightsec
; 482  : 		&& backsector->ceilinglightsec == frontsector->ceilinglightsec
; 483  : 		// Consider colormaps
; 484  : 		&& backsector->extra_colormap == frontsector->extra_colormap
; 485  : 		&& ((!frontsector->ffloors && !backsector->ffloors)

  00215	8b 45 08	 mov	 eax, DWORD PTR _line$[ebp]
  00218	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0021c	0f 85 55 01 00
	00		 jne	 $clippass$21
  00222	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  0022d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00230	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00233	0f 85 3e 01 00
	00		 jne	 $clippass$21
  00239	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00244	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00247	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0024a	0f 85 27 01 00
	00		 jne	 $clippass$21
  00250	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00255	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00259	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _frontsector
  0025f	0f bf 42 10	 movsx	 eax, WORD PTR [edx+16]
  00263	3b c8		 cmp	 ecx, eax
  00265	0f 85 0c 01 00
	00		 jne	 $clippass$21
  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR _curline
  00270	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00273	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00277	0f 85 fa 00 00
	00		 jne	 $clippass$21
  0027d	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00288	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0028b	3b 51 50	 cmp	 edx, DWORD PTR [ecx+80]
  0028e	0f 85 e3 00 00
	00		 jne	 $clippass$21
  00294	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  0029f	8b 50 54	 mov	 edx, DWORD PTR [eax+84]
  002a2	3b 51 54	 cmp	 edx, DWORD PTR [ecx+84]
  002a5	0f 85 cc 00 00
	00		 jne	 $clippass$21
  002ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  002b6	8b 50 60	 mov	 edx, DWORD PTR [eax+96]
  002b9	3b 51 60	 cmp	 edx, DWORD PTR [ecx+96]
  002bc	0f 85 b5 00 00
	00		 jne	 $clippass$21
  002c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  002cd	8b 50 58	 mov	 edx, DWORD PTR [eax+88]
  002d0	3b 51 58	 cmp	 edx, DWORD PTR [ecx+88]
  002d3	0f 85 9e 00 00
	00		 jne	 $clippass$21
  002d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  002de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  002e4	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  002e7	3b 51 5c	 cmp	 edx, DWORD PTR [ecx+92]
  002ea	0f 85 87 00 00
	00		 jne	 $clippass$21
  002f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  002f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  002fb	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  002fe	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  00301	75 74		 jne	 SHORT $clippass$21
  00303	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00308	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  0030e	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  00311	3b 51 6c	 cmp	 edx, DWORD PTR [ecx+108]
  00314	75 61		 jne	 SHORT $clippass$21
  00316	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  0031b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00321	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00324	3b 51 70	 cmp	 edx, DWORD PTR [ecx+112]
  00327	75 4e		 jne	 SHORT $clippass$21
  00329	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  0032e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00334	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  0033a	3b 91 b0 00 00
	00		 cmp	 edx, DWORD PTR [ecx+176]
  00340	75 35		 jne	 SHORT $clippass$21
  00342	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00347	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0034e	75 0e		 jne	 SHORT $LN18@R_AddLine
  00350	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00355	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  0035c	74 17		 je	 SHORT $LN17@R_AddLine
$LN18@R_AddLine:
  0035e	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00363	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  00367	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _backsector
  0036d	0f bf 42 14	 movsx	 eax, WORD PTR [edx+20]
  00371	3b c8		 cmp	 ecx, eax
  00373	75 02		 jne	 SHORT $clippass$21
$LN17@R_AddLine:

; 486  : 		|| frontsector->tag == backsector->tag))
; 487  : 	{
; 488  : 		return;

  00375	eb 28		 jmp	 SHORT $LN1@R_AddLine
$clippass$21:

; 489  : 	}
; 490  : 
; 491  : 
; 492  : clippass:
; 493  : 	R_ClipPassWallSegment(x1, x2 - 1);

  00377	8b 45 f8	 mov	 eax, DWORD PTR _x2$[ebp]
  0037a	83 e8 01	 sub	 eax, 1
  0037d	50		 push	 eax
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR _x1$[ebp]
  00381	51		 push	 ecx
  00382	e8 00 00 00 00	 call	 _R_ClipPassWallSegment
  00387	83 c4 08	 add	 esp, 8

; 494  : 	return;

  0038a	eb 13		 jmp	 SHORT $LN1@R_AddLine
$clipsolid$20:

; 495  : 
; 496  : clipsolid:
; 497  : 	R_ClipSolidWallSegment(x1, x2 - 1);

  0038c	8b 45 f8	 mov	 eax, DWORD PTR _x2$[ebp]
  0038f	83 e8 01	 sub	 eax, 1
  00392	50		 push	 eax
  00393	8b 4d fc	 mov	 ecx, DWORD PTR _x1$[ebp]
  00396	51		 push	 ecx
  00397	e8 00 00 00 00	 call	 _R_ClipSolidWallSegment
  0039c	83 c4 08	 add	 esp, 8
$LN1@R_AddLine:

; 498  : }

  0039f	5f		 pop	 edi
  003a0	5e		 pop	 esi
  003a1	5b		 pop	 ebx
  003a2	8b e5		 mov	 esp, ebp
  003a4	5d		 pop	 ebp
  003a5	c3		 ret	 0
_R_AddLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_DoorClosed
_TEXT	SEGMENT
tv83 = -68						; size = 4
_R_DoorClosed PROC					; COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 212  : 	return

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _backsector
  00014	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00017	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00019	7f 6b		 jg	 SHORT $LN4@R_DoorClos
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _backsector
  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _frontsector
  00026	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00029	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0002c	7d 0e		 jge	 SHORT $LN3@R_DoorClos
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR _curline
  00033	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00036	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0003a	74 4a		 je	 SHORT $LN4@R_DoorClos
$LN3@R_DoorClos:
  0003c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _backsector
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00047	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00049	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0004b	7e 0f		 jle	 SHORT $LN5@R_DoorClos
  0004d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _curline
  00053	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00056	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0005a	74 2a		 je	 SHORT $LN4@R_DoorClos
$LN5@R_DoorClos:
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _backsector
  00062	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00065	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _skyflatnum
  0006b	75 10		 jne	 SHORT $LN6@R_DoorClos
  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _frontsector
  00072	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00075	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  0007b	74 09		 je	 SHORT $LN4@R_DoorClos
$LN6@R_DoorClos:
  0007d	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  00084	eb 07		 jmp	 SHORT $LN7@R_DoorClos
$LN4@R_DoorClos:
  00086	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN7@R_DoorClos:
  0008d	8b 45 bc	 mov	 eax, DWORD PTR tv83[ebp]

; 213  : 
; 214  : 	// if door is closed because back is shut:
; 215  : 	backsector->ceilingheight <= backsector->floorheight
; 216  : 
; 217  : 	// preserve a kind of transparent door/lift special effect:
; 218  : 	&& (backsector->ceilingheight >= frontsector->ceilingheight || curline->sidedef->toptexture)
; 219  : 
; 220  : 	&& (backsector->floorheight <= frontsector->floorheight || curline->sidedef->bottomtexture)
; 221  : 
; 222  : 	// properly render skies (consider door "open" if both ceilings are sky):
; 223  : 	&& (backsector->ceilingpic != skyflatnum || frontsector->ceilingpic != skyflatnum);
; 224  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_R_DoorClosed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_ClipPassWallSegment
_TEXT	SEGMENT
_start$ = -4						; size = 4
_first$ = 8						; size = 4
_last$ = 12						; size = 4
_R_ClipPassWallSegment PROC				; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 151  : 	cliprange_t *start;
; 152  : 
; 153  : 	// Find the first range that touches the range
; 154  : 	//  (adjacent pixels are touching).
; 155  : 	start = solidsegs;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _solidsegs
$LN2@R_ClipPass:

; 156  : 	while (start->last < first - 1)

  00010	8b 45 08	 mov	 eax, DWORD PTR _first$[ebp]
  00013	83 e8 01	 sub	 eax, 1
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _start$[ebp]
  00019	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  0001c	7d 0b		 jge	 SHORT $LN3@R_ClipPass

; 157  : 		start++;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax
  00027	eb e7		 jmp	 SHORT $LN2@R_ClipPass
$LN3@R_ClipPass:

; 158  : 
; 159  : 	if (first < start->first)

  00029	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  0002f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00031	7d 34		 jge	 SHORT $LN6@R_ClipPass

; 160  : 	{
; 161  : 		if (last < start->first - 1)

  00033	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	83 e9 01	 sub	 ecx, 1
  0003b	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  0003e	7d 12		 jge	 SHORT $LN7@R_ClipPass

; 162  : 		{
; 163  : 			// Post is entirely visible (above start).
; 164  : 			R_StoreWallRange(first, last);

  00040	8b 45 0c	 mov	 eax, DWORD PTR _last$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _R_StoreWallRange
  0004d	83 c4 08	 add	 esp, 8

; 165  : 			return;

  00050	eb 7a		 jmp	 SHORT $LN1@R_ClipPass
$LN7@R_ClipPass:

; 166  : 		}
; 167  : 
; 168  : 		// There is a fragment above *start.
; 169  : 		R_StoreWallRange(first, start->first - 1);

  00052	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	83 e9 01	 sub	 ecx, 1
  0005a	51		 push	 ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _first$[ebp]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _R_StoreWallRange
  00064	83 c4 08	 add	 esp, 8
$LN6@R_ClipPass:

; 170  : 	}
; 171  : 
; 172  : 	// Bottom contained in start?
; 173  : 	if (last <= start->last)

  00067	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  0006d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00070	7f 02		 jg	 SHORT $LN8@R_ClipPass

; 174  : 		return;

  00072	eb 58		 jmp	 SHORT $LN1@R_ClipPass
$LN8@R_ClipPass:

; 175  : 
; 176  : 	while (last >= (start+1)->first - 1)

  00074	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00077	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007a	83 e9 01	 sub	 ecx, 1
  0007d	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00080	7c 34		 jl	 SHORT $LN5@R_ClipPass

; 177  : 	{
; 178  : 		// There is a fragment between two posts.
; 179  : 		R_StoreWallRange(start->last + 1, (start+1)->first - 1);

  00082	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  00085	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00088	83 e9 01	 sub	 ecx, 1
  0008b	51		 push	 ecx
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _start$[ebp]
  0008f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00092	83 c0 01	 add	 eax, 1
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _R_StoreWallRange
  0009b	83 c4 08	 add	 esp, 8

; 180  : 		start++;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  000a1	83 c0 08	 add	 eax, 8
  000a4	89 45 fc	 mov	 DWORD PTR _start$[ebp], eax

; 181  : 
; 182  : 		if (last <= start->last)

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  000ad	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000b0	7f 02		 jg	 SHORT $LN9@R_ClipPass

; 183  : 			return;

  000b2	eb 18		 jmp	 SHORT $LN1@R_ClipPass
$LN9@R_ClipPass:

; 184  : 	}

  000b4	eb be		 jmp	 SHORT $LN8@R_ClipPass
$LN5@R_ClipPass:

; 185  : 
; 186  : 	// There is a fragment after *next.
; 187  : 	R_StoreWallRange(start->last + 1, last);

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _last$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _start$[ebp]
  000bd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c0	83 c2 01	 add	 edx, 1
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _R_StoreWallRange
  000c9	83 c4 08	 add	 esp, 8
$LN1@R_ClipPass:

; 188  : }

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
_R_ClipPassWallSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_ClipSolidWallSegment
_TEXT	SEGMENT
tv150 = -80						; size = 4
tv149 = -76						; size = 4
_start$ = -8						; size = 4
_next$ = -4						; size = 4
_first$ = 8						; size = 4
_last$ = 12						; size = 4
_R_ClipSolidWallSegment PROC				; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   : 	cliprange_t *next;
; 69   : 	cliprange_t *start;
; 70   : 
; 71   : 	// Find the first range that touches the range (adjacent pixels are touching).
; 72   : 	start = solidsegs;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], OFFSET _solidsegs
$LN2@R_ClipSoli:

; 73   : 	while (start->last < first - 1)

  00010	8b 45 08	 mov	 eax, DWORD PTR _first$[ebp]
  00013	83 e8 01	 sub	 eax, 1
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _start$[ebp]
  00019	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  0001c	7d 0b		 jge	 SHORT $LN3@R_ClipSoli

; 74   : 		start++;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 f8	 mov	 DWORD PTR _start$[ebp], eax
  00027	eb e7		 jmp	 SHORT $LN2@R_ClipSoli
$LN3@R_ClipSoli:

; 75   : 
; 76   : 	if (first < start->first)

  00029	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  0002f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00031	0f 8d ae 00 00
	00		 jge	 $LN10@R_ClipSoli

; 77   : 	{
; 78   : 		if (last < start->first - 1)

  00037	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	83 e9 01	 sub	 ecx, 1
  0003f	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00042	0f 8d 80 00 00
	00		 jge	 $LN11@R_ClipSoli

; 79   : 		{
; 80   : 			// Post is entirely visible (above start), so insert a new clippost.
; 81   : 			R_StoreWallRange(first, last);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _last$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _R_StoreWallRange
  00055	83 c4 08	 add	 esp, 8

; 82   : 			next = newend;

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR _newend
  0005d	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 83   : 			newend++;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _newend
  00065	83 c0 08	 add	 eax, 8
  00068	a3 00 00 00 00	 mov	 DWORD PTR _newend, eax

; 84   : 			// NO MORE CRASHING!
; 85   : 			if (newend - solidsegs > MAXSEGS)

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _newend
  00072	2d 00 00 00 00	 sub	 eax, OFFSET _solidsegs
  00077	c1 f8 03	 sar	 eax, 3
  0007a	3d c1 03 00 00	 cmp	 eax, 961		; 000003c1H
  0007f	7e 0d		 jle	 SHORT $LN12@R_ClipSoli

; 86   : 				I_Error("R_ClipSolidWallSegment: Solid Segs overflow!\n");

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KEHOKKNP@R_ClipSolidWallSegment?3?5Solid?5S@
  00086	e8 00 00 00 00	 call	 _I_Error
  0008b	83 c4 04	 add	 esp, 4
$LN12@R_ClipSoli:

; 87   : 
; 88   : 			while (next != start)

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00091	3b 45 f8	 cmp	 eax, DWORD PTR _start$[ebp]
  00094	74 1c		 je	 SHORT $LN5@R_ClipSoli

; 89   : 			{
; 90   : 				*next = *(next-1);

  00096	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00099	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0009c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
  000a4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 91   : 				next--;

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000aa	83 e8 08	 sub	 eax, 8
  000ad	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 92   : 			}

  000b0	eb dc		 jmp	 SHORT $LN12@R_ClipSoli
$LN5@R_ClipSoli:

; 93   : 			next->first = first;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  000b8	89 08		 mov	 DWORD PTR [eax], ecx

; 94   : 			next->last = last;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  000c0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 95   : 			return;

  000c3	e9 11 01 00 00	 jmp	 $LN16@R_ClipSoli
$LN11@R_ClipSoli:

; 96   : 		}
; 97   : 
; 98   : 		// There is a fragment above *start.
; 99   : 		R_StoreWallRange(first, start->first - 1);

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	83 e9 01	 sub	 ecx, 1
  000d0	51		 push	 ecx
  000d1	8b 55 08	 mov	 edx, DWORD PTR _first$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 _R_StoreWallRange
  000da	83 c4 08	 add	 esp, 8

; 100  : 		// Now adjust the clip size.
; 101  : 		start->first = first;

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _first$[ebp]
  000e3	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@R_ClipSoli:

; 102  : 	}
; 103  : 
; 104  : 	// Bottom contained in start?
; 105  : 	if (last <= start->last)

  000e5	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  000eb	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000ee	7f 05		 jg	 SHORT $LN13@R_ClipSoli

; 106  : 		return;

  000f0	e9 e4 00 00 00	 jmp	 $LN16@R_ClipSoli
$LN13@R_ClipSoli:

; 107  : 
; 108  : 	next = start;

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  000f8	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
$LN6@R_ClipSoli:

; 109  : 	while (last >= (next+1)->first - 1)

  000fb	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000fe	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00101	83 e9 01	 sub	 ecx, 1
  00104	39 4d 0c	 cmp	 DWORD PTR _last$[ebp], ecx
  00107	7c 40		 jl	 SHORT $LN7@R_ClipSoli

; 110  : 	{
; 111  : 		// There is a fragment between two posts.
; 112  : 		R_StoreWallRange(next->last + 1, (next+1)->first - 1);

  00109	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0010c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010f	83 e9 01	 sub	 ecx, 1
  00112	51		 push	 ecx
  00113	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00116	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00119	83 c0 01	 add	 eax, 1
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _R_StoreWallRange
  00122	83 c4 08	 add	 esp, 8

; 113  : 		next++;

  00125	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00128	83 c0 08	 add	 eax, 8
  0012b	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 114  : 
; 115  : 		if (last <= next->last)

  0012e	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00131	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00134	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00137	7f 0e		 jg	 SHORT $LN14@R_ClipSoli

; 116  : 		{
; 117  : 			// Bottom is contained in next.
; 118  : 			// Adjust the clip size.
; 119  : 			start->last = next->last;

  00139	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  0013f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00142	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 120  : 			goto crunch;

  00145	eb 21		 jmp	 SHORT $crunch$18
$LN14@R_ClipSoli:

; 121  : 		}
; 122  : 	}

  00147	eb b2		 jmp	 SHORT $LN6@R_ClipSoli
$LN7@R_ClipSoli:

; 123  : 
; 124  : 	// There is a fragment after *next.
; 125  : 	R_StoreWallRange(next->last + 1, last);

  00149	8b 45 0c	 mov	 eax, DWORD PTR _last$[ebp]
  0014c	50		 push	 eax
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00150	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00153	83 c2 01	 add	 edx, 1
  00156	52		 push	 edx
  00157	e8 00 00 00 00	 call	 _R_StoreWallRange
  0015c	83 c4 08	 add	 esp, 8

; 126  : 	// Adjust the clip size.
; 127  : 	start->last = last;

  0015f	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00162	8b 4d 0c	 mov	 ecx, DWORD PTR _last$[ebp]
  00165	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$crunch$18:

; 128  : 
; 129  : 	// Remove start+1 to next from the clip list, because start now covers their area.
; 130  : crunch:
; 131  : 	if (next == start)

  00168	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0016b	3b 45 f8	 cmp	 eax, DWORD PTR _start$[ebp]
  0016e	75 02		 jne	 SHORT $LN15@R_ClipSoli

; 132  : 		return; // Post just extended past the bottom of one post.

  00170	eb 67		 jmp	 SHORT $LN16@R_ClipSoli
$LN15@R_ClipSoli:

; 133  : 
; 134  : 	while (next++ != newend)

  00172	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00175	89 45 b4	 mov	 DWORD PTR tv149[ebp], eax
  00178	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _newend
  0017e	89 4d b0	 mov	 DWORD PTR tv150[ebp], ecx
  00181	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00184	83 c2 08	 add	 edx, 8
  00187	89 55 fc	 mov	 DWORD PTR _next$[ebp], edx
  0018a	8b 45 b4	 mov	 eax, DWORD PTR tv149[ebp]
  0018d	3b 45 b0	 cmp	 eax, DWORD PTR tv150[ebp]
  00190	74 1b		 je	 SHORT $LN9@R_ClipSoli

; 135  : 		*++start = *next; // Remove a post.

  00192	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  00195	83 c0 08	 add	 eax, 8
  00198	89 45 f8	 mov	 DWORD PTR _start$[ebp], eax
  0019b	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  0019e	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001a3	8b 4d f8	 mov	 ecx, DWORD PTR _start$[ebp]
  001a6	89 11		 mov	 DWORD PTR [ecx], edx
  001a8	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001ab	eb c5		 jmp	 SHORT $LN15@R_ClipSoli
$LN9@R_ClipSoli:

; 136  : 
; 137  : 	newend = start + 1;

  001ad	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]
  001b0	83 c0 08	 add	 eax, 8
  001b3	a3 00 00 00 00	 mov	 DWORD PTR _newend, eax

; 138  : 
; 139  : 	// NO MORE CRASHING!
; 140  : 	if (newend - solidsegs > MAXSEGS)

  001b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _newend
  001bd	2d 00 00 00 00	 sub	 eax, OFFSET _solidsegs
  001c2	c1 f8 03	 sar	 eax, 3
  001c5	3d c1 03 00 00	 cmp	 eax, 961		; 000003c1H
  001ca	7e 0d		 jle	 SHORT $LN16@R_ClipSoli

; 141  : 		I_Error("R_ClipSolidWallSegment: Solid Segs overflow!\n");

  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KEHOKKNP@R_ClipSolidWallSegment?3?5Solid?5S@
  001d1	e8 00 00 00 00	 call	 _I_Error
  001d6	83 c4 04	 add	 esp, 4
$LN16@R_ClipSoli:

; 142  : }

  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
_R_ClipSolidWallSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_Prep3DFloors
_TEXT	SEGMENT
_sec$ = -32						; size = 4
_mapnum$ = -28						; size = 4
_i$ = -24						; size = 4
_count$ = -20						; size = 4
_maxheight$ = -16					; size = 4
_bestheight$ = -12					; size = 4
_best$ = -8						; size = 4
_rover$ = -4						; size = 4
_sector$ = 8						; size = 4
_R_Prep3DFloors PROC					; COMDAT

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 987  : 	ffloor_t *rover;
; 988  : 	ffloor_t *best;
; 989  : 	fixed_t bestheight, maxheight;
; 990  : 	INT32 count, i, mapnum;
; 991  : 	sector_t *sec;
; 992  : 
; 993  : 	count = 1;

  00009	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _count$[ebp], 1

; 994  : 	for (rover = sector->ffloors; rover; rover = rover->next)

  00010	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00013	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00019	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
  0001c	eb 09		 jmp	 SHORT $LN4@R_Prep3DFl
$LN2@R_Prep3DFl:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00021	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00024	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
$LN4@R_Prep3DFl:
  00027	83 7d fc 00	 cmp	 DWORD PTR _rover$[ebp], 0
  0002b	74 54		 je	 SHORT $LN3@R_Prep3DFl

; 995  : 	{
; 996  : 		if ((rover->flags & FF_EXISTS) && (!(rover->flags & FF_NOSHADE)

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00030	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00033	83 e1 01	 and	 ecx, 1
  00036	74 47		 je	 SHORT $LN13@R_Prep3DFl
  00038	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0003b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0003e	83 e1 40	 and	 ecx, 64			; 00000040H
  00041	74 1c		 je	 SHORT $LN12@R_Prep3DFl
  00043	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00046	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00049	81 e1 80 01 00
	00		 and	 ecx, 384		; 00000180H
  0004f	75 0e		 jne	 SHORT $LN12@R_Prep3DFl
  00051	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00054	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00057	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0005d	74 20		 je	 SHORT $LN13@R_Prep3DFl
$LN12@R_Prep3DFl:

; 997  : 			|| (rover->flags & FF_CUTLEVEL) || (rover->flags & FF_CUTSPRITES)))
; 998  : 		{
; 999  : 			count++;

  0005f	8b 45 ec	 mov	 eax, DWORD PTR _count$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 ec	 mov	 DWORD PTR _count$[ebp], eax

; 1000 : 			if (rover->flags & FF_DOUBLESHADOW)

  00068	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0006b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006e	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  00074	74 09		 je	 SHORT $LN13@R_Prep3DFl

; 1001 : 				count++;

  00076	8b 45 ec	 mov	 eax, DWORD PTR _count$[ebp]
  00079	83 c0 01	 add	 eax, 1
  0007c	89 45 ec	 mov	 DWORD PTR _count$[ebp], eax
$LN13@R_Prep3DFl:

; 1002 : 		}
; 1003 : 	}

  0007f	eb 9d		 jmp	 SHORT $LN2@R_Prep3DFl
$LN3@R_Prep3DFl:

; 1004 : 
; 1005 : 	if (count != sector->numlights)

  00081	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _count$[ebp]
  00087	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  0008d	74 3c		 je	 SHORT $LN14@R_Prep3DFl

; 1006 : 	{
; 1007 : 		Z_Free(sector->lightlist);

  0008f	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00092	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _Z_Free
  0009e	83 c4 04	 add	 esp, 4

; 1008 : 		sector->lightlist = Z_Calloc(sizeof (*sector->lightlist) * count, PU_LEVEL, NULL);

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	6a 32		 push	 50			; 00000032H
  000a7	6b 45 ec 14	 imul	 eax, DWORD PTR _count$[ebp], 20
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _Z_CallocAlign
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  000b7	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax

; 1009 : 		sector->numlights = count;

  000bd	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _count$[ebp]
  000c3	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx

; 1010 : 	}

  000c9	eb 19		 jmp	 SHORT $LN15@R_Prep3DFl
$LN14@R_Prep3DFl:

; 1011 : 	else
; 1012 : 		memset(sector->lightlist, 0, sizeof (lightlist_t) * count);

  000cb	6b 45 ec 14	 imul	 eax, DWORD PTR _count$[ebp], 20
  000cf	50		 push	 eax
  000d0	6a 00		 push	 0
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  000d5	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 _memset
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@R_Prep3DFl:

; 1013 : 
; 1014 : 	sector->lightlist[0].height = sector->ceilingheight + 1;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ea	83 c1 01	 add	 ecx, 1
  000ed	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  000f2	6b c2 00	 imul	 eax, edx, 0
  000f5	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  000f8	8b 92 a4 00 00
	00		 mov	 edx, DWORD PTR [edx+164]
  000fe	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 1015 : 	sector->lightlist[0].lightlevel = &sector->lightlevel;

  00101	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00104	83 c0 10	 add	 eax, 16			; 00000010H
  00107	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0010c	6b d1 00	 imul	 edx, ecx, 0
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00112	8b 89 a4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+164]
  00118	89 44 11 04	 mov	 DWORD PTR [ecx+edx+4], eax

; 1016 : 	sector->lightlist[0].caster = NULL;

  0011c	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00121	6b c8 00	 imul	 ecx, eax, 0
  00124	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00127	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0012d	c7 44 08 10 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+16], 0

; 1017 : 	sector->lightlist[0].extra_colormap = sector->extra_colormap;

  00135	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0013a	6b c8 00	 imul	 ecx, eax, 0
  0013d	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00140	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00146	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00149	8b 92 b0 00 00
	00		 mov	 edx, DWORD PTR [edx+176]
  0014f	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx

; 1018 : 	sector->lightlist[0].flags = 0;

  00153	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00158	6b c8 00	 imul	 ecx, eax, 0
  0015b	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  0015e	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00164	c7 44 08 0c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx+12], 0

; 1019 : 
; 1020 : 	maxheight = INT32_MAX;

  0016c	c7 45 f0 ff ff
	ff 7f		 mov	 DWORD PTR _maxheight$[ebp], 2147483647 ; 7fffffffH

; 1021 : 	for (i = 1; i < count; i++)

  00173	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0017a	eb 09		 jmp	 SHORT $LN7@R_Prep3DFl
$LN5@R_Prep3DFl:
  0017c	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0017f	83 c0 01	 add	 eax, 1
  00182	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@R_Prep3DFl:
  00185	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00188	3b 45 ec	 cmp	 eax, DWORD PTR _count$[ebp]
  0018b	0f 8d db 02 00
	00		 jge	 $LN6@R_Prep3DFl

; 1022 : 	{
; 1023 : 		bestheight = INT32_MAX * -1;

  00191	c7 45 f4 01 00
	00 80		 mov	 DWORD PTR _bestheight$[ebp], -2147483647 ; 80000001H

; 1024 : 		best = NULL;

  00198	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _best$[ebp], 0

; 1025 : 		for (rover = sector->ffloors; rover; rover = rover->next)

  0019f	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  001a2	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  001a8	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
  001ab	eb 09		 jmp	 SHORT $LN10@R_Prep3DFl
$LN8@R_Prep3DFl:
  001ad	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001b0	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001b3	89 4d fc	 mov	 DWORD PTR _rover$[ebp], ecx
$LN10@R_Prep3DFl:
  001b6	83 7d fc 00	 cmp	 DWORD PTR _rover$[ebp], 0
  001ba	0f 84 ab 00 00
	00		 je	 $LN9@R_Prep3DFl

; 1026 : 		{
; 1027 : 			rover->lastlight = 0;

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001c3	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 1028 : 			if (!(rover->flags & FF_EXISTS) || (rover->flags & FF_NOSHADE

  001ca	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001cd	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001d0	83 e1 01	 and	 ecx, 1
  001d3	74 27		 je	 SHORT $LN17@R_Prep3DFl
  001d5	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001d8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001db	83 e1 40	 and	 ecx, 64			; 00000040H
  001de	74 1e		 je	 SHORT $LN16@R_Prep3DFl
  001e0	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001e3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001e6	81 e1 80 01 00
	00		 and	 ecx, 384		; 00000180H
  001ec	75 10		 jne	 SHORT $LN16@R_Prep3DFl
  001ee	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  001f1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001f4	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  001fa	75 02		 jne	 SHORT $LN16@R_Prep3DFl
$LN17@R_Prep3DFl:

; 1029 : 				&& !(rover->flags & FF_CUTLEVEL) && !(rover->flags & FF_CUTSPRITES)))
; 1030 : 			continue;

  001fc	eb af		 jmp	 SHORT $LN8@R_Prep3DFl
$LN16@R_Prep3DFl:

; 1031 : 
; 1032 : 			if (*rover->topheight > bestheight && *rover->topheight < maxheight)

  001fe	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00201	8b 08		 mov	 ecx, DWORD PTR [eax]
  00203	8b 11		 mov	 edx, DWORD PTR [ecx]
  00205	3b 55 f4	 cmp	 edx, DWORD PTR _bestheight$[ebp]
  00208	7e 1e		 jle	 SHORT $LN18@R_Prep3DFl
  0020a	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0020d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00211	3b 55 f0	 cmp	 edx, DWORD PTR _maxheight$[ebp]
  00214	7d 12		 jge	 SHORT $LN18@R_Prep3DFl

; 1033 : 			{
; 1034 : 				best = rover;

  00216	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00219	89 45 f8	 mov	 DWORD PTR _best$[ebp], eax

; 1035 : 				bestheight = *rover->topheight;

  0021c	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0021f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00221	8b 11		 mov	 edx, DWORD PTR [ecx]
  00223	89 55 f4	 mov	 DWORD PTR _bestheight$[ebp], edx

; 1036 : 				continue;

  00226	eb 85		 jmp	 SHORT $LN8@R_Prep3DFl
$LN18@R_Prep3DFl:

; 1037 : 			}
; 1038 : 			if (rover->flags & FF_DOUBLESHADOW && *rover->bottomheight > bestheight
; 1039 : 				&& *rover->bottomheight < maxheight)

  00228	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0022b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0022e	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  00234	74 30		 je	 SHORT $LN19@R_Prep3DFl
  00236	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00239	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0023c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023e	3b 55 f4	 cmp	 edx, DWORD PTR _bestheight$[ebp]
  00241	7e 23		 jle	 SHORT $LN19@R_Prep3DFl
  00243	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00246	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00249	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024b	3b 55 f0	 cmp	 edx, DWORD PTR _maxheight$[ebp]
  0024e	7d 16		 jge	 SHORT $LN19@R_Prep3DFl

; 1040 : 			{
; 1041 : 				best = rover;

  00250	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00253	89 45 f8	 mov	 DWORD PTR _best$[ebp], eax

; 1042 : 				bestheight = *rover->bottomheight;

  00256	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00259	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0025c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025e	89 55 f4	 mov	 DWORD PTR _bestheight$[ebp], edx

; 1043 : 				continue;

  00261	e9 47 ff ff ff	 jmp	 $LN8@R_Prep3DFl
$LN19@R_Prep3DFl:

; 1044 : 			}
; 1045 : 		}

  00266	e9 42 ff ff ff	 jmp	 $LN8@R_Prep3DFl
$LN9@R_Prep3DFl:

; 1046 : 		if (!best)

  0026b	83 7d f8 00	 cmp	 DWORD PTR _best$[ebp], 0
  0026f	75 11		 jne	 SHORT $LN20@R_Prep3DFl

; 1047 : 		{
; 1048 : 			sector->numlights = i;

  00271	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00274	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  00277	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx

; 1049 : 			return;

  0027d	e9 ea 01 00 00	 jmp	 $LN6@R_Prep3DFl
$LN20@R_Prep3DFl:

; 1050 : 		}
; 1051 : 
; 1052 : 		sector->lightlist[i].height = maxheight = bestheight;

  00282	8b 45 f4	 mov	 eax, DWORD PTR _bestheight$[ebp]
  00285	89 45 f0	 mov	 DWORD PTR _maxheight$[ebp], eax
  00288	6b 4d e8 14	 imul	 ecx, DWORD PTR _i$[ebp], 20
  0028c	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  0028f	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00295	8b 55 f0	 mov	 edx, DWORD PTR _maxheight$[ebp]
  00298	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 1053 : 		sector->lightlist[i].caster = best;

  0029b	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0029f	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  002a2	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  002a8	8b 4d f8	 mov	 ecx, DWORD PTR _best$[ebp]
  002ab	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 1054 : 		sector->lightlist[i].flags = best->flags;

  002af	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  002b6	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  002bc	8b 4d f8	 mov	 ecx, DWORD PTR _best$[ebp]
  002bf	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  002c2	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx

; 1055 : 		sec = &sectors[best->secnum];

  002c6	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  002c9	69 48 30 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+48], 248
  002d0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  002d6	89 4d e0	 mov	 DWORD PTR _sec$[ebp], ecx

; 1056 : 		mapnum = sec->midmap;

  002d9	8b 45 e0	 mov	 eax, DWORD PTR _sec$[ebp]
  002dc	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  002df	89 4d e4	 mov	 DWORD PTR _mapnum$[ebp], ecx

; 1057 : 		if (mapnum >= 0 && (size_t)mapnum < num_extra_colormaps)

  002e2	83 7d e4 00	 cmp	 DWORD PTR _mapnum$[ebp], 0
  002e6	7c 1f		 jl	 SHORT $LN21@R_Prep3DFl
  002e8	8b 45 e4	 mov	 eax, DWORD PTR _mapnum$[ebp]
  002eb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_extra_colormaps
  002f1	73 14		 jae	 SHORT $LN21@R_Prep3DFl

; 1058 : 			sec->extra_colormap = &extra_colormaps[mapnum];

  002f3	6b 45 e4 28	 imul	 eax, DWORD PTR _mapnum$[ebp], 40
  002f7	05 00 00 00 00	 add	 eax, OFFSET _extra_colormaps
  002fc	8b 4d e0	 mov	 ecx, DWORD PTR _sec$[ebp]
  002ff	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax
  00305	eb 0d		 jmp	 SHORT $LN22@R_Prep3DFl
$LN21@R_Prep3DFl:

; 1059 : 		else
; 1060 : 			sec->extra_colormap = NULL;

  00307	8b 45 e0	 mov	 eax, DWORD PTR _sec$[ebp]
  0030a	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN22@R_Prep3DFl:

; 1061 : 
; 1062 : 		if (best->flags & FF_NOSHADE)

  00314	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  00317	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0031a	83 e1 40	 and	 ecx, 64			; 00000040H
  0031d	74 53		 je	 SHORT $LN23@R_Prep3DFl

; 1063 : 		{
; 1064 : 			sector->lightlist[i].lightlevel = sector->lightlist[i-1].lightlevel;

  0031f	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00322	83 e8 01	 sub	 eax, 1
  00325	6b c8 14	 imul	 ecx, eax, 20
  00328	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  0032b	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00331	6b 55 e8 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  00335	8b 75 08	 mov	 esi, DWORD PTR _sector$[ebp]
  00338	8b b6 a4 00 00
	00		 mov	 esi, DWORD PTR [esi+164]
  0033e	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  00342	89 44 16 04	 mov	 DWORD PTR [esi+edx+4], eax

; 1065 : 			sector->lightlist[i].extra_colormap = sector->lightlist[i-1].extra_colormap;

  00346	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00349	83 e8 01	 sub	 eax, 1
  0034c	6b c8 14	 imul	 ecx, eax, 20
  0034f	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00352	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00358	6b 55 e8 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  0035c	8b 75 08	 mov	 esi, DWORD PTR _sector$[ebp]
  0035f	8b b6 a4 00 00
	00		 mov	 esi, DWORD PTR [esi+164]
  00365	8b 44 08 08	 mov	 eax, DWORD PTR [eax+ecx+8]
  00369	89 44 16 08	 mov	 DWORD PTR [esi+edx+8], eax

; 1066 : 		}

  0036d	e9 82 00 00 00	 jmp	 $LN26@R_Prep3DFl
$LN23@R_Prep3DFl:

; 1067 : 		else if (best->flags & FF_COLORMAPONLY)

  00372	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  00375	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00378	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  0037e	74 43		 je	 SHORT $LN25@R_Prep3DFl

; 1068 : 		{
; 1069 : 			sector->lightlist[i].lightlevel = sector->lightlist[i-1].lightlevel;

  00380	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00383	83 e8 01	 sub	 eax, 1
  00386	6b c8 14	 imul	 ecx, eax, 20
  00389	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  0038c	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00392	6b 55 e8 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  00396	8b 75 08	 mov	 esi, DWORD PTR _sector$[ebp]
  00399	8b b6 a4 00 00
	00		 mov	 esi, DWORD PTR [esi+164]
  0039f	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  003a3	89 44 16 04	 mov	 DWORD PTR [esi+edx+4], eax

; 1070 : 			sector->lightlist[i].extra_colormap = sec->extra_colormap;

  003a7	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  003ab	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  003ae	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  003b4	8b 4d e0	 mov	 ecx, DWORD PTR _sec$[ebp]
  003b7	8b 89 b0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+176]
  003bd	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx

; 1071 : 		}

  003c1	eb 31		 jmp	 SHORT $LN26@R_Prep3DFl
$LN25@R_Prep3DFl:

; 1072 : 		else
; 1073 : 		{
; 1074 : 			sector->lightlist[i].lightlevel = best->toplightlevel;

  003c3	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  003ca	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  003d0	8b 4d f8	 mov	 ecx, DWORD PTR _best$[ebp]
  003d3	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  003d6	89 4c 02 04	 mov	 DWORD PTR [edx+eax+4], ecx

; 1075 : 			sector->lightlist[i].extra_colormap = sec->extra_colormap;

  003da	6b 45 e8 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  003de	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  003e1	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  003e7	8b 4d e0	 mov	 ecx, DWORD PTR _sec$[ebp]
  003ea	8b 89 b0 00 00
	00		 mov	 ecx, DWORD PTR [ecx+176]
  003f0	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
$LN26@R_Prep3DFl:

; 1076 : 		}
; 1077 : 
; 1078 : 		if (best->flags & FF_DOUBLESHADOW)

  003f4	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  003f7	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003fa	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  00400	74 65		 je	 SHORT $LN29@R_Prep3DFl

; 1079 : 		{
; 1080 : 			if (bestheight == *best->bottomheight)

  00402	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  00405	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00408	8b 55 f4	 mov	 edx, DWORD PTR _bestheight$[ebp]
  0040b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0040d	75 4c		 jne	 SHORT $LN28@R_Prep3DFl

; 1081 : 			{
; 1082 : 				sector->lightlist[i].lightlevel = sector->lightlist[best->lastlight].lightlevel;

  0040f	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  00412	6b 48 48 14	 imul	 ecx, DWORD PTR [eax+72], 20
  00416	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  00419	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0041f	6b 55 e8 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  00423	8b 75 08	 mov	 esi, DWORD PTR _sector$[ebp]
  00426	8b b6 a4 00 00
	00		 mov	 esi, DWORD PTR [esi+164]
  0042c	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  00430	89 44 16 04	 mov	 DWORD PTR [esi+edx+4], eax

; 1083 : 				sector->lightlist[i].extra_colormap =

  00434	8b 45 f8	 mov	 eax, DWORD PTR _best$[ebp]
  00437	6b 48 48 14	 imul	 ecx, DWORD PTR [eax+72], 20
  0043b	8b 55 08	 mov	 edx, DWORD PTR _sector$[ebp]
  0043e	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00444	6b 55 e8 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  00448	8b 75 08	 mov	 esi, DWORD PTR _sector$[ebp]
  0044b	8b b6 a4 00 00
	00		 mov	 esi, DWORD PTR [esi+164]
  00451	8b 44 08 08	 mov	 eax, DWORD PTR [eax+ecx+8]
  00455	89 44 16 08	 mov	 DWORD PTR [esi+edx+8], eax

; 1084 : 					sector->lightlist[best->lastlight].extra_colormap;
; 1085 : 			}

  00459	eb 0c		 jmp	 SHORT $LN29@R_Prep3DFl
$LN28@R_Prep3DFl:

; 1086 : 			else
; 1087 : 				best->lastlight = i - 1;

  0045b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0045e	83 e8 01	 sub	 eax, 1
  00461	8b 4d f8	 mov	 ecx, DWORD PTR _best$[ebp]
  00464	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$LN29@R_Prep3DFl:

; 1088 : 		}
; 1089 : 	}

  00467	e9 10 fd ff ff	 jmp	 $LN5@R_Prep3DFl
$LN6@R_Prep3DFl:

; 1090 : }

  0046c	5f		 pop	 edi
  0046d	5e		 pop	 esi
  0046e	5b		 pop	 ebx
  0046f	8b e5		 mov	 esp, ebp
  00471	5d		 pop	 ebp
  00472	c3		 ret	 0
_R_Prep3DFloors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_GetPlaneLight
_TEXT	SEGMENT
_i$ = -4						; size = 4
_sector$ = 8						; size = 4
_planeheight$ = 12					; size = 4
_underside$ = 16					; size = 4
_R_GetPlaneLight PROC					; COMDAT

; 1093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1094 : 	INT32 i;
; 1095 : 
; 1096 : 	if (!underside)

  00009	83 7d 10 00	 cmp	 DWORD PTR _underside$[ebp], 0
  0000d	75 4d		 jne	 SHORT $LN8@R_GetPlane

; 1097 : 	{
; 1098 : 		for (i = 1; i < sector->numlights; i++)

  0000f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00016	eb 09		 jmp	 SHORT $LN4@R_GetPlane
$LN2@R_GetPlane:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_GetPlane:
  00021	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  0002d	7d 1f		 jge	 SHORT $LN3@R_GetPlane

; 1099 : 			if (sector->lightlist[i].height <= planeheight)

  0002f	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00036	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0003c	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0003f	3b 45 0c	 cmp	 eax, DWORD PTR _planeheight$[ebp]
  00042	7f 08		 jg	 SHORT $LN9@R_GetPlane

; 1100 : 				return i - 1;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00047	83 e8 01	 sub	 eax, 1
  0004a	eb 5b		 jmp	 SHORT $LN1@R_GetPlane
$LN9@R_GetPlane:
  0004c	eb ca		 jmp	 SHORT $LN2@R_GetPlane
$LN3@R_GetPlane:

; 1101 : 
; 1102 : 		return sector->numlights - 1;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00051	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [eax+168]
  00057	83 e8 01	 sub	 eax, 1
  0005a	eb 4b		 jmp	 SHORT $LN1@R_GetPlane
$LN8@R_GetPlane:

; 1103 : 	}
; 1104 : 
; 1105 : 	for (i = 1; i < sector->numlights; i++)

  0005c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00063	eb 09		 jmp	 SHORT $LN7@R_GetPlane
$LN5@R_GetPlane:
  00065	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00068	83 c0 01	 add	 eax, 1
  0006b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@R_GetPlane:
  0006e	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00074	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  0007a	7d 1f		 jge	 SHORT $LN6@R_GetPlane

; 1106 : 		if (sector->lightlist[i].height < planeheight)

  0007c	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _sector$[ebp]
  00083	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00089	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0008c	3b 45 0c	 cmp	 eax, DWORD PTR _planeheight$[ebp]
  0008f	7d 08		 jge	 SHORT $LN10@R_GetPlane

; 1107 : 			return i - 1;

  00091	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00094	83 e8 01	 sub	 eax, 1
  00097	eb 0e		 jmp	 SHORT $LN1@R_GetPlane
$LN10@R_GetPlane:
  00099	eb ca		 jmp	 SHORT $LN5@R_GetPlane
$LN6@R_GetPlane:

; 1108 : 
; 1109 : 	return sector->numlights - 1;

  0009b	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0009e	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [eax+168]
  000a4	83 e8 01	 sub	 eax, 1
$LN1@R_GetPlane:

; 1110 : }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_R_GetPlaneLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_FakeFlat
_TEXT	SEGMENT
tv76 = -88						; size = 4
tv87 = -88						; size = 4
tv140 = -88						; size = 4
tv218 = -88						; size = 4
tv229 = -88						; size = 4
tv295 = -88						; size = 4
tv306 = -88						; size = 4
_underwater$1 = -20					; size = 4
_heightsec$2 = -16					; size = 4
_s$3 = -12						; size = 4
_viewmobj$ = -8						; size = 4
_mapnum$ = -4						; size = 4
_sec$ = 8						; size = 4
_tempsec$ = 12						; size = 4
_floorlightlevel$ = 16					; size = 4
_ceilinglightlevel$ = 20				; size = 4
_back$ = 24						; size = 4
_R_FakeFlat PROC					; COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 237  : 	INT32 mapnum = -1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _mapnum$[ebp], -1

; 238  : 	mobj_t *viewmobj = viewplayer->mo;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewplayer
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d f8	 mov	 DWORD PTR _viewmobj$[ebp], ecx

; 239  : 
; 240  : 	if (!viewmobj)

  0001a	83 7d f8 00	 cmp	 DWORD PTR _viewmobj$[ebp], 0
  0001e	75 08		 jne	 SHORT $LN2@R_FakeFlat

; 241  : 		return sec;

  00020	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00023	e9 37 05 00 00	 jmp	 $LN1@R_FakeFlat
$LN2@R_FakeFlat:

; 242  : 
; 243  : 	if (floorlightlevel)

  00028	83 7d 10 00	 cmp	 DWORD PTR _floorlightlevel$[ebp], 0
  0002c	74 35		 je	 SHORT $LN3@R_FakeFlat

; 244  : 		*floorlightlevel = sec->floorlightsec == -1 ?

  0002e	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00031	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  00035	75 0c		 jne	 SHORT $LN28@R_FakeFlat
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  0003a	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  0003e	89 55 a8	 mov	 DWORD PTR tv76[ebp], edx
  00041	eb 18		 jmp	 SHORT $LN29@R_FakeFlat
$LN28@R_FakeFlat:
  00043	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00046	69 48 6c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+108], 248
  0004d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00053	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  00058	89 45 a8	 mov	 DWORD PTR tv76[ebp], eax
$LN29@R_FakeFlat:
  0005b	8b 4d 10	 mov	 ecx, DWORD PTR _floorlightlevel$[ebp]
  0005e	8b 55 a8	 mov	 edx, DWORD PTR tv76[ebp]
  00061	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@R_FakeFlat:

; 245  : 			sec->lightlevel : sectors[sec->floorlightsec].lightlevel;
; 246  : 
; 247  : 	if (ceilinglightlevel)

  00063	83 7d 14 00	 cmp	 DWORD PTR _ceilinglightlevel$[ebp], 0
  00067	74 35		 je	 SHORT $LN4@R_FakeFlat

; 248  : 		*ceilinglightlevel = sec->ceilinglightsec == -1 ?

  00069	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0006c	83 78 70 ff	 cmp	 DWORD PTR [eax+112], -1
  00070	75 0c		 jne	 SHORT $LN30@R_FakeFlat
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00075	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00079	89 55 a8	 mov	 DWORD PTR tv87[ebp], edx
  0007c	eb 18		 jmp	 SHORT $LN31@R_FakeFlat
$LN30@R_FakeFlat:
  0007e	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00081	69 48 70 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+112], 248
  00088	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  0008e	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  00093	89 45 a8	 mov	 DWORD PTR tv87[ebp], eax
$LN31@R_FakeFlat:
  00096	8b 4d 14	 mov	 ecx, DWORD PTR _ceilinglightlevel$[ebp]
  00099	8b 55 a8	 mov	 edx, DWORD PTR tv87[ebp]
  0009c	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@R_FakeFlat:

; 249  : 			sec->lightlevel : sectors[sec->ceilinglightsec].lightlevel;
; 250  : 
; 251  : 	// If the sector has a midmap, it's probably from 280 type
; 252  : 	if (sec->midmap != -1)

  0009e	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  000a1	83 78 7c ff	 cmp	 DWORD PTR [eax+124], -1
  000a5	74 0e		 je	 SHORT $LN5@R_FakeFlat

; 253  : 		mapnum = sec->midmap;

  000a7	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  000aa	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  000ad	89 4d fc	 mov	 DWORD PTR _mapnum$[ebp], ecx
  000b0	e9 75 04 00 00	 jmp	 $LN7@R_FakeFlat
$LN5@R_FakeFlat:

; 254  : 	else if (sec->heightsec != -1)

  000b5	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  000b8	83 78 68 ff	 cmp	 DWORD PTR [eax+104], -1
  000bc	0f 84 68 04 00
	00		 je	 $LN7@R_FakeFlat

; 255  : 	{
; 256  : 		const sector_t *s = &sectors[sec->heightsec];

  000c2	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  000c5	69 48 68 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+104], 248
  000cc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sectors
  000d2	89 4d f4	 mov	 DWORD PTR _s$3[ebp], ecx

; 257  : 		INT32 heightsec = R_PointInSubsector(viewmobj->x, viewmobj->y)->sector->heightsec;

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _viewmobj$[ebp]
  000d8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000db	51		 push	 ecx
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _viewmobj$[ebp]
  000df	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _R_PointInSubsector
  000e8	83 c4 08	 add	 esp, 8
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  000f0	89 55 f0	 mov	 DWORD PTR _heightsec$2[ebp], edx

; 258  : 		INT32 underwater = heightsec != -1 && viewz <= sectors[heightsec].floorheight;

  000f3	83 7d f0 ff	 cmp	 DWORD PTR _heightsec$2[ebp], -1
  000f7	74 21		 je	 SHORT $LN32@R_FakeFlat
  000f9	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _heightsec$2[ebp], 248
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  0010c	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  0010f	7f 09		 jg	 SHORT $LN32@R_FakeFlat
  00111	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
  00118	eb 07		 jmp	 SHORT $LN33@R_FakeFlat
$LN32@R_FakeFlat:
  0011a	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN33@R_FakeFlat:
  00121	8b 45 a8	 mov	 eax, DWORD PTR tv140[ebp]
  00124	89 45 ec	 mov	 DWORD PTR _underwater$1[ebp], eax

; 259  : 
; 260  : 		if (splitscreen && viewplayer == &players[secondarydisplayplayer]
; 261  : 			&& camera2.chase)

  00127	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0012e	74 3f		 je	 SHORT $LN8@R_FakeFlat
  00130	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0013a	05 00 00 00 00	 add	 eax, OFFSET _players
  0013f	39 05 00 00 00
	00		 cmp	 DWORD PTR _viewplayer, eax
  00145	75 28		 jne	 SHORT $LN8@R_FakeFlat
  00147	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _camera2, 0
  0014e	74 1f		 je	 SHORT $LN8@R_FakeFlat

; 262  : 		{
; 263  : 			heightsec = R_PointInSubsector(camera2.x, camera2.y)->sector->heightsec;

  00150	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera2+20
  00155	50		 push	 eax
  00156	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _camera2+16
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _R_PointInSubsector
  00162	83 c4 08	 add	 esp, 8
  00165	8b 10		 mov	 edx, DWORD PTR [eax]
  00167	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0016a	89 45 f0	 mov	 DWORD PTR _heightsec$2[ebp], eax

; 264  : 		}

  0016d	eb 3d		 jmp	 SHORT $LN10@R_FakeFlat
$LN8@R_FakeFlat:

; 265  : 		else if (camera.chase && viewplayer == &players[displayplayer])

  0016f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _camera, 0
  00176	74 34		 je	 SHORT $LN10@R_FakeFlat
  00178	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00182	05 00 00 00 00	 add	 eax, OFFSET _players
  00187	39 05 00 00 00
	00		 cmp	 DWORD PTR _viewplayer, eax
  0018d	75 1d		 jne	 SHORT $LN10@R_FakeFlat

; 266  : 			heightsec = R_PointInSubsector(camera.x, camera.y)->sector->heightsec;

  0018f	a1 14 00 00 00	 mov	 eax, DWORD PTR _camera+20
  00194	50		 push	 eax
  00195	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _camera+16
  0019b	51		 push	 ecx
  0019c	e8 00 00 00 00	 call	 _R_PointInSubsector
  001a1	83 c4 08	 add	 esp, 8
  001a4	8b 10		 mov	 edx, DWORD PTR [eax]
  001a6	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  001a9	89 45 f0	 mov	 DWORD PTR _heightsec$2[ebp], eax
$LN10@R_FakeFlat:

; 267  : 
; 268  : 		// Replace sector being drawn, with a copy to be hacked
; 269  : 		*tempsec = *sec;

  001ac	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  001b1	8b 75 08	 mov	 esi, DWORD PTR _sec$[ebp]
  001b4	8b 7d 0c	 mov	 edi, DWORD PTR _tempsec$[ebp]
  001b7	f3 a5		 rep movsd

; 270  : 
; 271  : 		// Replace floor and ceiling height with other sector's heights.
; 272  : 		tempsec->floorheight = s->floorheight;

  001b9	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  001bc	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  001bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c1	89 10		 mov	 DWORD PTR [eax], edx

; 273  : 		tempsec->ceilingheight = s->ceilingheight;

  001c3	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  001c6	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  001c9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001cc	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 274  : 
; 275  : 		mapnum = s->midmap;

  001cf	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  001d2	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  001d5	89 4d fc	 mov	 DWORD PTR _mapnum$[ebp], ecx

; 276  : 
; 277  : 		if ((underwater && (tempsec->  floorheight = sec->floorheight,
; 278  : 			tempsec->ceilingheight = s->floorheight - 1, !back)) || viewz <= s->floorheight)

  001d8	83 7d ec 00	 cmp	 DWORD PTR _underwater$1[ebp], 0
  001dc	74 1e		 je	 SHORT $LN14@R_FakeFlat
  001de	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  001e4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e6	89 10		 mov	 DWORD PTR [eax], edx
  001e8	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  001eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ed	83 e9 01	 sub	 ecx, 1
  001f0	8b 55 0c	 mov	 edx, DWORD PTR _tempsec$[ebp]
  001f3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001f6	83 7d 18 00	 cmp	 DWORD PTR _back$[ebp], 0
  001fa	74 11		 je	 SHORT $LN13@R_FakeFlat
$LN14@R_FakeFlat:
  001fc	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _viewz
  00205	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00207	0f 8f 4a 01 00
	00		 jg	 $LN11@R_FakeFlat
$LN13@R_FakeFlat:

; 279  : 		{ // head-below-floor hack
; 280  : 			tempsec->floorpic = s->floorpic;

  0020d	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00210	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00213	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00216	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 281  : 			tempsec->floor_xoffs = s->floor_xoffs;

  00219	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  0021c	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  0021f	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00222	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 282  : 			tempsec->floor_yoffs = s->floor_yoffs;

  00225	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00228	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  0022b	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0022e	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 283  : 			tempsec->floorpic_angle = s->floorpic_angle;

  00231	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00234	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00237	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0023a	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 284  : 
; 285  : 			if (underwater)

  0023d	83 7d ec 00	 cmp	 DWORD PTR _underwater$1[ebp], 0
  00241	0f 84 87 00 00
	00		 je	 $LN15@R_FakeFlat

; 286  : 			{
; 287  : 				if (s->ceilingpic == skyflatnum)

  00247	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  0024a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0024d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  00253	75 40		 jne	 SHORT $LN16@R_FakeFlat

; 288  : 				{
; 289  : 					tempsec->floorheight = tempsec->ceilingheight+1;

  00255	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00258	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0025b	83 c1 01	 add	 ecx, 1
  0025e	8b 55 0c	 mov	 edx, DWORD PTR _tempsec$[ebp]
  00261	89 0a		 mov	 DWORD PTR [edx], ecx

; 290  : 					tempsec->ceilingpic = tempsec->floorpic;

  00263	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00266	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00269	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0026c	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 291  : 					tempsec->ceiling_xoffs = tempsec->floor_xoffs;

  0026f	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00272	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00275	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00278	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 292  : 					tempsec->ceiling_yoffs = tempsec->floor_yoffs;

  0027b	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  0027e	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00281	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00284	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 293  : 					tempsec->ceilingpic_angle = tempsec->floorpic_angle;

  00287	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  0028a	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  0028d	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00290	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 294  : 				}

  00293	eb 30		 jmp	 SHORT $LN17@R_FakeFlat
$LN16@R_FakeFlat:

; 295  : 				else
; 296  : 				{
; 297  : 					tempsec->ceilingpic = s->ceilingpic;

  00295	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00298	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  0029b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0029e	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 298  : 					tempsec->ceiling_xoffs = s->ceiling_xoffs;

  002a1	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  002a4	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  002a7	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  002aa	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 299  : 					tempsec->ceiling_yoffs = s->ceiling_yoffs;

  002ad	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  002b0	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  002b3	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  002b6	89 50 5c	 mov	 DWORD PTR [eax+92], edx

; 300  : 					tempsec->ceilingpic_angle = s->ceilingpic_angle;

  002b9	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  002bc	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  002bf	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  002c2	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN17@R_FakeFlat:

; 301  : 				}
; 302  : 				mapnum = s->bottommap;

  002c5	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  002c8	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  002cb	89 4d fc	 mov	 DWORD PTR _mapnum$[ebp], ecx
$LN15@R_FakeFlat:

; 303  : 			}
; 304  : 
; 305  : 			tempsec->lightlevel = s->lightlevel;

  002ce	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  002d1	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  002d4	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  002d8	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 306  : 
; 307  : 			if (floorlightlevel)

  002dc	83 7d 10 00	 cmp	 DWORD PTR _floorlightlevel$[ebp], 0
  002e0	74 35		 je	 SHORT $LN18@R_FakeFlat

; 308  : 				*floorlightlevel = s->floorlightsec == -1 ? s->lightlevel

  002e2	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  002e5	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  002e9	75 0c		 jne	 SHORT $LN34@R_FakeFlat
  002eb	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  002ee	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  002f2	89 55 a8	 mov	 DWORD PTR tv218[ebp], edx
  002f5	eb 18		 jmp	 SHORT $LN35@R_FakeFlat
$LN34@R_FakeFlat:
  002f7	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  002fa	69 48 6c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+108], 248
  00301	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00307	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  0030c	89 45 a8	 mov	 DWORD PTR tv218[ebp], eax
$LN35@R_FakeFlat:
  0030f	8b 4d 10	 mov	 ecx, DWORD PTR _floorlightlevel$[ebp]
  00312	8b 55 a8	 mov	 edx, DWORD PTR tv218[ebp]
  00315	89 11		 mov	 DWORD PTR [ecx], edx
$LN18@R_FakeFlat:

; 309  : 					: sectors[s->floorlightsec].lightlevel;
; 310  : 
; 311  : 			if (ceilinglightlevel)

  00317	83 7d 14 00	 cmp	 DWORD PTR _ceilinglightlevel$[ebp], 0
  0031b	74 35		 je	 SHORT $LN19@R_FakeFlat

; 312  : 				*ceilinglightlevel = s->ceilinglightsec == -1 ? s->lightlevel

  0031d	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  00320	83 78 70 ff	 cmp	 DWORD PTR [eax+112], -1
  00324	75 0c		 jne	 SHORT $LN36@R_FakeFlat
  00326	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00329	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  0032d	89 55 a8	 mov	 DWORD PTR tv229[ebp], edx
  00330	eb 18		 jmp	 SHORT $LN37@R_FakeFlat
$LN36@R_FakeFlat:
  00332	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  00335	69 48 70 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+112], 248
  0033c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00342	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  00347	89 45 a8	 mov	 DWORD PTR tv229[ebp], eax
$LN37@R_FakeFlat:
  0034a	8b 4d 14	 mov	 ecx, DWORD PTR _ceilinglightlevel$[ebp]
  0034d	8b 55 a8	 mov	 edx, DWORD PTR tv229[ebp]
  00350	89 11		 mov	 DWORD PTR [ecx], edx
$LN19@R_FakeFlat:

; 313  : 					: sectors[s->ceilinglightsec].lightlevel;
; 314  : 		}

  00352	e9 cd 01 00 00	 jmp	 $LN24@R_FakeFlat
$LN11@R_FakeFlat:

; 315  : 		else if (heightsec != -1 && viewz >= sectors[heightsec].ceilingheight
; 316  : 			&& sec->ceilingheight > s->ceilingheight)

  00357	83 7d f0 ff	 cmp	 DWORD PTR _heightsec$2[ebp], -1
  0035b	0f 84 c3 01 00
	00		 je	 $LN24@R_FakeFlat
  00361	69 45 f0 f8 00
	00 00		 imul	 eax, DWORD PTR _heightsec$2[ebp], 248
  00368	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0036e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00374	3b 54 01 04	 cmp	 edx, DWORD PTR [ecx+eax+4]
  00378	0f 8c a6 01 00
	00		 jl	 $LN24@R_FakeFlat
  0037e	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00381	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00384	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00387	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0038a	0f 8e 94 01 00
	00		 jle	 $LN24@R_FakeFlat

; 317  : 		{ // Above-ceiling hack
; 318  : 			tempsec->ceilingheight = s->ceilingheight;

  00390	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00393	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00396	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00399	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 319  : 			tempsec->floorheight = s->ceilingheight + 1;

  0039c	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  0039f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003a2	83 c1 01	 add	 ecx, 1
  003a5	8b 55 0c	 mov	 edx, DWORD PTR _tempsec$[ebp]
  003a8	89 0a		 mov	 DWORD PTR [edx], ecx

; 320  : 
; 321  : 			tempsec->floorpic = tempsec->ceilingpic = s->ceilingpic;

  003aa	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003ad	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  003b0	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003b3	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  003b6	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003b9	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  003bc	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003bf	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 322  : 			tempsec->floor_xoffs = tempsec->ceiling_xoffs = s->ceiling_xoffs;

  003c2	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003c5	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  003c8	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  003cb	89 50 58	 mov	 DWORD PTR [eax+88], edx
  003ce	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003d1	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  003d4	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  003d7	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 323  : 			tempsec->floor_yoffs = tempsec->ceiling_yoffs = s->ceiling_yoffs;

  003da	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003dd	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  003e0	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  003e3	89 50 5c	 mov	 DWORD PTR [eax+92], edx
  003e6	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003e9	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  003ec	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  003ef	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 324  : 			tempsec->floorpic_angle = tempsec->ceilingpic_angle = s->ceilingpic_angle;

  003f2	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  003f5	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  003f8	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  003fb	89 50 64	 mov	 DWORD PTR [eax+100], edx
  003fe	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00401	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00404	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00407	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 325  : 
; 326  : 			mapnum = s->topmap;

  0040a	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  0040d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00413	89 4d fc	 mov	 DWORD PTR _mapnum$[ebp], ecx

; 327  : 
; 328  : 			if (s->floorpic == skyflatnum) // SKYFIX?

  00416	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  00419	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0041c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _skyflatnum
  00422	75 40		 jne	 SHORT $LN21@R_FakeFlat

; 329  : 			{
; 330  : 				tempsec->ceilingheight = tempsec->floorheight-1;

  00424	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00427	8b 08		 mov	 ecx, DWORD PTR [eax]
  00429	83 e9 01	 sub	 ecx, 1
  0042c	8b 55 0c	 mov	 edx, DWORD PTR _tempsec$[ebp]
  0042f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 331  : 				tempsec->floorpic = tempsec->ceilingpic;

  00432	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00435	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00438	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0043b	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 332  : 				tempsec->floor_xoffs = tempsec->ceiling_xoffs;

  0043e	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00441	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00444	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00447	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 333  : 				tempsec->floor_yoffs = tempsec->ceiling_yoffs;

  0044a	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  0044d	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  00450	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00453	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 334  : 				tempsec->floorpic_angle = tempsec->ceilingpic_angle;

  00456	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00459	8b 4d 0c	 mov	 ecx, DWORD PTR _tempsec$[ebp]
  0045c	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0045f	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 335  : 			}

  00462	eb 3c		 jmp	 SHORT $LN22@R_FakeFlat
$LN21@R_FakeFlat:

; 336  : 			else
; 337  : 			{
; 338  : 				tempsec->ceilingheight = sec->ceilingheight;

  00464	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00467	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  0046a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0046d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 339  : 				tempsec->floorpic = s->floorpic;

  00470	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00473	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00476	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00479	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 340  : 				tempsec->floor_xoffs = s->floor_xoffs;

  0047c	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  0047f	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  00482	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00485	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 341  : 				tempsec->floor_yoffs = s->floor_yoffs;

  00488	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  0048b	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  0048e	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00491	89 50 54	 mov	 DWORD PTR [eax+84], edx

; 342  : 				tempsec->floorpic_angle = s->floorpic_angle;

  00494	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00497	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  0049a	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0049d	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN22@R_FakeFlat:

; 343  : 			}
; 344  : 
; 345  : 			tempsec->lightlevel = s->lightlevel;

  004a0	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  004a3	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  004a6	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  004aa	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 346  : 
; 347  : 			if (floorlightlevel)

  004ae	83 7d 10 00	 cmp	 DWORD PTR _floorlightlevel$[ebp], 0
  004b2	74 35		 je	 SHORT $LN23@R_FakeFlat

; 348  : 				*floorlightlevel = s->floorlightsec == -1 ? s->lightlevel :

  004b4	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  004b7	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  004bb	75 0c		 jne	 SHORT $LN38@R_FakeFlat
  004bd	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  004c0	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  004c4	89 55 a8	 mov	 DWORD PTR tv295[ebp], edx
  004c7	eb 18		 jmp	 SHORT $LN39@R_FakeFlat
$LN38@R_FakeFlat:
  004c9	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  004cc	69 48 6c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+108], 248
  004d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  004d9	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  004de	89 45 a8	 mov	 DWORD PTR tv295[ebp], eax
$LN39@R_FakeFlat:
  004e1	8b 4d 10	 mov	 ecx, DWORD PTR _floorlightlevel$[ebp]
  004e4	8b 55 a8	 mov	 edx, DWORD PTR tv295[ebp]
  004e7	89 11		 mov	 DWORD PTR [ecx], edx
$LN23@R_FakeFlat:

; 349  : 			sectors[s->floorlightsec].lightlevel;
; 350  : 
; 351  : 			if (ceilinglightlevel)

  004e9	83 7d 14 00	 cmp	 DWORD PTR _ceilinglightlevel$[ebp], 0
  004ed	74 35		 je	 SHORT $LN24@R_FakeFlat

; 352  : 				*ceilinglightlevel = s->ceilinglightsec == -1 ? s->lightlevel :

  004ef	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  004f2	83 78 70 ff	 cmp	 DWORD PTR [eax+112], -1
  004f6	75 0c		 jne	 SHORT $LN40@R_FakeFlat
  004f8	8b 4d f4	 mov	 ecx, DWORD PTR _s$3[ebp]
  004fb	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  004ff	89 55 a8	 mov	 DWORD PTR tv306[ebp], edx
  00502	eb 18		 jmp	 SHORT $LN41@R_FakeFlat
$LN40@R_FakeFlat:
  00504	8b 45 f4	 mov	 eax, DWORD PTR _s$3[ebp]
  00507	69 48 70 f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+112], 248
  0050e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00514	0f bf 44 0a 10	 movsx	 eax, WORD PTR [edx+ecx+16]
  00519	89 45 a8	 mov	 DWORD PTR tv306[ebp], eax
$LN41@R_FakeFlat:
  0051c	8b 4d 14	 mov	 ecx, DWORD PTR _ceilinglightlevel$[ebp]
  0051f	8b 55 a8	 mov	 edx, DWORD PTR tv306[ebp]
  00522	89 11		 mov	 DWORD PTR [ecx], edx
$LN24@R_FakeFlat:

; 353  : 			sectors[s->ceilinglightsec].lightlevel;
; 354  : 		}
; 355  : 		sec = tempsec;

  00524	8b 45 0c	 mov	 eax, DWORD PTR _tempsec$[ebp]
  00527	89 45 08	 mov	 DWORD PTR _sec$[ebp], eax
$LN7@R_FakeFlat:

; 356  : 	}
; 357  : 
; 358  : 	if (mapnum >= 0 && (size_t)mapnum < num_extra_colormaps)

  0052a	83 7d fc 00	 cmp	 DWORD PTR _mapnum$[ebp], 0
  0052e	7c 1f		 jl	 SHORT $LN25@R_FakeFlat
  00530	8b 45 fc	 mov	 eax, DWORD PTR _mapnum$[ebp]
  00533	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _num_extra_colormaps
  00539	73 14		 jae	 SHORT $LN25@R_FakeFlat

; 359  : 		sec->extra_colormap = &extra_colormaps[mapnum];

  0053b	6b 45 fc 28	 imul	 eax, DWORD PTR _mapnum$[ebp], 40
  0053f	05 00 00 00 00	 add	 eax, OFFSET _extra_colormaps
  00544	8b 4d 08	 mov	 ecx, DWORD PTR _sec$[ebp]
  00547	89 81 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], eax
  0054d	eb 0d		 jmp	 SHORT $LN26@R_FakeFlat
$LN25@R_FakeFlat:

; 360  : 	else
; 361  : 		sec->extra_colormap = NULL;

  0054f	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00552	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN26@R_FakeFlat:

; 362  : 
; 363  : 	return sec;

  0055c	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
$LN1@R_FakeFlat:

; 364  : }

  0055f	5f		 pop	 edi
  00560	5e		 pop	 esi
  00561	5b		 pop	 ebx
  00562	8b e5		 mov	 esp, ebp
  00564	5d		 pop	 ebp
  00565	c3		 ret	 0
_R_FakeFlat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_SortPolyObjects
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_po$2 = -4						; size = 4
_sub$ = 8						; size = 4
_R_SortPolyObjects PROC					; COMDAT

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 642  : 	if (numpolys)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numpolys, 0
  00010	0f 84 c7 00 00
	00		 je	 $LN6@R_SortPoly

; 643  : 	{
; 644  : 		polyobj_t *po;
; 645  : 		INT32 i = 0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0

; 646  : 
; 647  : 		// allocate twice the number needed to minimize allocations
; 648  : 		if (num_po_ptrs < numpolys*2)

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _numpolys
  00022	d1 e0		 shl	 eax, 1
  00024	39 05 00 00 00
	00		 cmp	 DWORD PTR _num_po_ptrs, eax
  0002a	73 31		 jae	 SHORT $LN5@R_SortPoly

; 649  : 		{
; 650  : 			// use free instead realloc since faster (thanks Lee ^_^)
; 651  : 			free(po_ptrs);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _po_ptrs
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _free
  00037	83 c4 04	 add	 esp, 4

; 652  : 			po_ptrs = malloc((num_po_ptrs = numpolys*2)

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _numpolys
  0003f	d1 e0		 shl	 eax, 1
  00041	a3 00 00 00 00	 mov	 DWORD PTR _num_po_ptrs, eax
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _num_po_ptrs
  0004c	c1 e1 02	 shl	 ecx, 2
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _malloc
  00055	83 c4 04	 add	 esp, 4
  00058	a3 00 00 00 00	 mov	 DWORD PTR _po_ptrs, eax
$LN5@R_SortPoly:

; 653  : 				* sizeof(*po_ptrs));
; 654  : 		}
; 655  : 
; 656  : 		po = sub->polyList;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _sub$[ebp]
  00060	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00063	89 4d fc	 mov	 DWORD PTR _po$2[ebp], ecx
$LN2@R_SortPoly:

; 657  : 
; 658  : 		while (po)

  00066	83 7d fc 00	 cmp	 DWORD PTR _po$2[ebp], 0
  0006a	74 4c		 je	 SHORT $LN3@R_SortPoly

; 659  : 		{
; 660  : 			po->zdist = R_PointToDist2(viewx, viewy,

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _po$2[ebp]
  0006f	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00072	51		 push	 ecx
  00073	8b 55 fc	 mov	 edx, DWORD PTR _po$2[ebp]
  00076	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00079	50		 push	 eax
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _viewy
  00080	51		 push	 ecx
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewx
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 _R_PointToDist2
  0008d	83 c4 10	 add	 esp, 16			; 00000010H
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _po$2[ebp]
  00093	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 661  : 				po->centerPt.x, po->centerPt.y);
; 662  : 			po_ptrs[i++] = po;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _po_ptrs
  0009f	8b 55 fc	 mov	 edx, DWORD PTR _po$2[ebp]
  000a2	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  000a5	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax

; 663  : 			po = (polyobj_t *)(po->link.next);

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _po$2[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	89 4d fc	 mov	 DWORD PTR _po$2[ebp], ecx

; 664  : 		}

  000b6	eb ae		 jmp	 SHORT $LN2@R_SortPoly
$LN3@R_SortPoly:

; 665  : 
; 666  : 		// the polyobjects are NOT in any particular order, so use qsort
; 667  : 		// 03/10/06: only bother if there are actually polys to sort
; 668  : 		if (numpolys >= 2)

  000b8	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _numpolys, 2
  000bf	72 1c		 jb	 SHORT $LN6@R_SortPoly

; 669  : 		{
; 670  : 			qsort(po_ptrs, numpolys, sizeof(polyobj_t *),

  000c1	68 00 00 00 00	 push	 OFFSET _R_PolyobjCompare
  000c6	6a 04		 push	 4
  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _numpolys
  000cd	50		 push	 eax
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _po_ptrs
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 _qsort
  000da	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@R_SortPoly:

; 671  : 				R_PolyobjCompare);
; 672  : 		}
; 673  : 	}
; 674  : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_R_SortPolyObjects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_RenderBSPNode
_TEXT	SEGMENT
tv91 = -76						; size = 4
_side$ = -8						; size = 4
_bsp$ = -4						; size = 4
_bspnum$ = 8						; size = 4
_R_RenderBSPNode PROC					; COMDAT

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@R_RenderBS:

; 1122 : 	node_t *bsp;
; 1123 : 	INT32 side;
; 1124 : 	while (!(bspnum & NF_SUBSECTOR))  // Found a subsector?

  00009	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  0000c	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00011	75 70		 jne	 SHORT $LN3@R_RenderBS

; 1125 : 	{
; 1126 : 		bsp = &nodes[bspnum];

  00013	6b 45 08 34	 imul	 eax, DWORD PTR _bspnum$[ebp], 52
  00017	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nodes
  0001d	89 45 fc	 mov	 DWORD PTR _bsp$[ebp], eax

; 1127 : 
; 1128 : 		// Decide which side the view point is on.
; 1129 : 		side = R_PointOnSide(viewx, viewy, bsp);

  00020	8b 45 fc	 mov	 eax, DWORD PTR _bsp$[ebp]
  00023	50		 push	 eax
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _viewy
  0002a	51		 push	 ecx
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _R_PointOnSide
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	89 45 f8	 mov	 DWORD PTR _side$[ebp], eax

; 1130 : 		// Recursively divide front space.
; 1131 : 		R_RenderBSPNode(bsp->children[side]);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  00043	0f b7 54 41 30	 movzx	 edx, WORD PTR [ecx+eax*2+48]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _R_RenderBSPNode
  0004e	83 c4 04	 add	 esp, 4

; 1132 : 
; 1133 : 		// Possibly divide back space.
; 1134 : 
; 1135 : 		if (!R_CheckBBox(bsp->bbox[side^1]))

  00051	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  00054	83 f0 01	 xor	 eax, 1
  00057	c1 e0 04	 shl	 eax, 4
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  0005d	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _R_CheckBBox
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	75 02		 jne	 SHORT $LN4@R_RenderBS

; 1136 : 			return;

  0006e	eb 39		 jmp	 SHORT $LN1@R_RenderBS
$LN4@R_RenderBS:

; 1137 : 
; 1138 : 		bspnum = bsp->children[side^1];

  00070	8b 45 f8	 mov	 eax, DWORD PTR _side$[ebp]
  00073	83 f0 01	 xor	 eax, 1
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _bsp$[ebp]
  00079	0f b7 54 41 30	 movzx	 edx, WORD PTR [ecx+eax*2+48]
  0007e	89 55 08	 mov	 DWORD PTR _bspnum$[ebp], edx

; 1139 : 	}

  00081	eb 86		 jmp	 SHORT $LN2@R_RenderBS
$LN3@R_RenderBS:

; 1140 : 	R_Subsector(bspnum == -1 ? 0 : bspnum & ~NF_SUBSECTOR);

  00083	83 7d 08 ff	 cmp	 DWORD PTR _bspnum$[ebp], -1
  00087	75 09		 jne	 SHORT $LN6@R_RenderBS
  00089	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00090	eb 0b		 jmp	 SHORT $LN7@R_RenderBS
$LN6@R_RenderBS:
  00092	8b 45 08	 mov	 eax, DWORD PTR _bspnum$[ebp]
  00095	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  0009a	89 45 b4	 mov	 DWORD PTR tv91[ebp], eax
$LN7@R_RenderBS:
  0009d	8b 4d b4	 mov	 ecx, DWORD PTR tv91[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _R_Subsector
  000a6	83 c4 04	 add	 esp, 4
$LN1@R_RenderBS:

; 1141 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
_R_RenderBSPNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_ClearDrawSegs
_TEXT	SEGMENT
_R_ClearDrawSegs PROC					; COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 50   : 	ds_p = drawsegs;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _drawsegs
  0000e	a3 00 00 00 00	 mov	 DWORD PTR _ds_p, eax

; 51   : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_R_ClearDrawSegs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\r_bsp.c
;	COMDAT _R_ClearClipSegs
_TEXT	SEGMENT
_R_ClearClipSegs PROC					; COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 195  : 	solidsegs[0].first = -0x7fffffff;

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	c7 81 00 00 00
	00 01 00 00 80	 mov	 DWORD PTR _solidsegs[ecx], -2147483647 ; 80000001H

; 196  : 	solidsegs[0].last = -1;

  0001b	b8 08 00 00 00	 mov	 eax, 8
  00020	6b c8 00	 imul	 ecx, eax, 0
  00023	c7 81 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _solidsegs[ecx+4], -1

; 197  : 	solidsegs[1].first = viewwidth;

  0002d	b8 08 00 00 00	 mov	 eax, 8
  00032	c1 e0 00	 shl	 eax, 0
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _viewwidth
  0003b	89 88 00 00 00
	00		 mov	 DWORD PTR _solidsegs[eax], ecx

; 198  : 	solidsegs[1].last = 0x7fffffff;

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	c1 e0 00	 shl	 eax, 0
  00049	c7 80 04 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR _solidsegs[eax+4], 2147483647 ; 7fffffffH

; 199  : 	newend = solidsegs + 2;

  00053	c7 05 00 00 00
	00 10 00 00 00	 mov	 DWORD PTR _newend, OFFSET _solidsegs+16

; 200  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_R_ClearClipSegs ENDP
_TEXT	ENDS
END
