; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\win_dbg.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_prevExceptionFilter
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_prevExceptionFilter DD 01H DUP (?)
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	_vsprintf
PUBLIC	_RecordExceptionInfo@4
PUBLIC	??_C@_0BE@GLOKLDAN@an?5Access?5Violation@	; `string'
PUBLIC	??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded@	; `string'
PUBLIC	??_C@_0N@JLDHOHAI@a?5Breakpoint@		; `string'
PUBLIC	??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment@	; `string'
PUBLIC	??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand@	; `string'
PUBLIC	??_C@_0BH@BAAKOIO@a?5Float?5Divide?5By?5Zero@	; `string'
PUBLIC	??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result@	; `string'
PUBLIC	??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation@ ; `string'
PUBLIC	??_C@_0BB@LAJAGHGH@a?5Float?5Overflow@		; `string'
PUBLIC	??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check@	; `string'
PUBLIC	??_C@_0BC@CICINNDB@a?5Float?5Underflow@		; `string'
PUBLIC	??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction@	; `string'
PUBLIC	??_C@_0BB@DKICMMFA@an?5In?5Page?5Error@		; `string'
PUBLIC	??_C@_0BK@KEJCCHHM@an?5Integer?5Divide?5By?5Zero@ ; `string'
PUBLIC	??_C@_0BE@CDPGECPC@an?5Integer?5Overflow@	; `string'
PUBLIC	??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition@	; `string'
PUBLIC	??_C@_0BJ@DJIMDBAI@Noncontinuable?5Exception@	; `string'
PUBLIC	??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction@	; `string'
PUBLIC	??_C@_0O@LIBDHKBA@a?5Single?5Step@		; `string'
PUBLIC	??_C@_0BB@LJENMGNL@a?5Stack?5Overflow@		; `string'
PUBLIC	??_C@_0M@FNOJOPNP@a?5Control?9C@		; `string'
PUBLIC	??_C@_0BA@MNEFCPPO@a?5Control?9Break@		; `string'
PUBLIC	??_C@_0M@JNBECNGI@a?5No?5Memory@		; `string'
PUBLIC	??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception@ ; `string'
PUBLIC	??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed@ ; `string'
PUBLIC	??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception@ ; `string'
PUBLIC	??_C@_0BH@GMMOLJLG@Unknown?5exception?5type@	; `string'
PUBLIC	??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5@	; `string'
PUBLIC	??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes@ ; `string'
PUBLIC	??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresse@ ; `string'
PUBLIC	??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6@ ; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6@ ; `string'
PUBLIC	??_C@_0EE@NGMMDFMM@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?5?$CFd?4?$CFd?4@ ; `string'
PUBLIC	??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6@ ; `string'
PUBLIC	??_C@_0N@BHIHAFGJ@errorlog?4txt@		; `string'
PUBLIC	??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report@ ; `string'
PUBLIC	??_C@_0DB@EPEEFCEA@Email?5Sonic?5Team?5Junior?5so?5we?5c@ ; `string'
PUBLIC	??_C@_0GA@JBOMNEPP@Make?5sure?5you?5tell?5us?5what?5you?5@ ; `string'
PUBLIC	??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6@	; `string'
PUBLIC	??_C@_07IJKPKDGN@?5v2?40?47@			; `string'
PUBLIC	??_C@_0BH@HFCEIAIB@SRB2?$CFs?5?9ERROR?5LOG?9?$AN?6?$AN?6@ ; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_0CK@PECMEOFD@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF0@ ; `string'
PUBLIC	??_C@_0M@NIEGMIHB@main?5thread@			; `string'
PUBLIC	??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4@ ; `string'
PUBLIC	??_C@_09JHOILLPP@Read?5from@			; `string'
PUBLIC	??_C@_08CPFAPHAF@Write?5to@			; `string'
PUBLIC	??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acce@ ; `string'
PUBLIC	??_C@_0BE@GKJKFFJO@Exception?5handler?3?5@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0N@NADCNKKP@Registers?3?$AN?6@		; `string'
PUBLIC	??_C@_0CK@BAALCHIJ@EAX?$DN?$CF?48lx?5CS?$DN?$CF?44x?5EIP?$DN?$CF?48lx?5EFL@ ; `string'
PUBLIC	??_C@_0CI@DHBMJANE@EBX?$DN?$CF?48lx?5SS?$DN?$CF?44x?5ESP?$DN?$CF?48lx?5EBP@ ; `string'
PUBLIC	??_C@_0CG@DNBFEJGL@ECX?$DN?$CF?48lx?5DS?$DN?$CF?44x?5ESI?$DN?$CF?48lx?5FS?$DN@ ; `string'
PUBLIC	??_C@_0CG@LOCMAGNG@EDX?$DN?$CF?48lx?5ES?$DN?$CF?44x?5EDI?$DN?$CF?48lx?5GS?$DN@ ; `string'
PUBLIC	??_C@_0BK@OAKBNDJP@Command?5Line?5parameters?3?5@ ; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5@			; `string'
PUBLIC	??_C@_0BF@FABNJKDP@Bytes?5at?5CS?5?3?5EIP?3?$AN?6@ ; `string'
PUBLIC	??_C@_05CNDJFPDP@?$CF02x?5@			; `string'
PUBLIC	??_C@_03MMEAEOBL@?$DP?$DP?5@			; `string'
PUBLIC	??_C@_0BA@EHPJBAFB@?$AN?6Stack?5dump?3?$AN?6@	; `string'
PUBLIC	??_C@_06HIMOAOMH@?$CF08x?3?5@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_06POCCOEBN@?$CF08x?$CFs@			; `string'
PUBLIC	??_C@_0CL@OMKINDCC@Exception?5encountered?5during?5st@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strrchr:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__FileTimeToLocalFileTime@8:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__GetSystemTimeAsFileTime@4:PROC
EXTRN	__imp__VirtualQuery@12:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__FileTimeToDosDateTime@12:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__GetUserNameA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memset:PROC
EXTRN	_myargc:DWORD
EXTRN	_myargv:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?BeenHere@?1??RecordExceptionInfo@@9@9 DD 01H DUP (?)	; `RecordExceptionInfo'::`2'::BeenHere
_BSS	ENDS
;	COMDAT ??_C@_0CL@OMKINDCC@Exception?5encountered?5during?5st@
CONST	SEGMENT
??_C@_0CL@OMKINDCC@Exception?5encountered?5during?5st@ DB 'Exception enco'
	DB	'untered during stack dump.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06POCCOEBN@?$CF08x?$CFs@
CONST	SEGMENT
??_C@_06POCCOEBN@?$CF08x?$CFs@ DB '%08x%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HIMOAOMH@?$CF08x?3?5@
CONST	SEGMENT
??_C@_06HIMOAOMH@?$CF08x?3?5@ DB '%08x: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EHPJBAFB@?$AN?6Stack?5dump?3?$AN?6@
CONST	SEGMENT
??_C@_0BA@EHPJBAFB@?$AN?6Stack?5dump?3?$AN?6@ DB 0dH, 0aH, 'Stack dump:', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMEAEOBL@?$DP?$DP?5@
CONST	SEGMENT
??_C@_03MMEAEOBL@?$DP?$DP?5@ DB '?? ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNDJFPDP@?$CF02x?5@
CONST	SEGMENT
??_C@_05CNDJFPDP@?$CF02x?5@ DB '%02x ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FABNJKDP@Bytes?5at?5CS?5?3?5EIP?3?$AN?6@
CONST	SEGMENT
??_C@_0BF@FABNJKDP@Bytes?5at?5CS?5?3?5EIP?3?$AN?6@ DB 'Bytes at CS : EIP:'
	DB	0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5@ DB '%s ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OAKBNDJP@Command?5Line?5parameters?3?5@
CONST	SEGMENT
??_C@_0BK@OAKBNDJP@Command?5Line?5parameters?3?5@ DB 'Command Line parame'
	DB	'ters: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LOCMAGNG@EDX?$DN?$CF?48lx?5ES?$DN?$CF?44x?5EDI?$DN?$CF?48lx?5GS?$DN@
CONST	SEGMENT
??_C@_0CG@LOCMAGNG@EDX?$DN?$CF?48lx?5ES?$DN?$CF?44x?5EDI?$DN?$CF?48lx?5GS?$DN@ DB 'E'
	DB	'DX=%.8lx ES=%.4x EDI=%.8lx GS=%.4x', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DNBFEJGL@ECX?$DN?$CF?48lx?5DS?$DN?$CF?44x?5ESI?$DN?$CF?48lx?5FS?$DN@
CONST	SEGMENT
??_C@_0CG@DNBFEJGL@ECX?$DN?$CF?48lx?5DS?$DN?$CF?44x?5ESI?$DN?$CF?48lx?5FS?$DN@ DB 'E'
	DB	'CX=%.8lx DS=%.4x ESI=%.8lx FS=%.4x', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DHBMJANE@EBX?$DN?$CF?48lx?5SS?$DN?$CF?44x?5ESP?$DN?$CF?48lx?5EBP@
CONST	SEGMENT
??_C@_0CI@DHBMJANE@EBX?$DN?$CF?48lx?5SS?$DN?$CF?44x?5ESP?$DN?$CF?48lx?5EBP@ DB 'E'
	DB	'BX=%.8lx SS=%.4x ESP=%.8lx EBP=%.8lx', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BAALCHIJ@EAX?$DN?$CF?48lx?5CS?$DN?$CF?44x?5EIP?$DN?$CF?48lx?5EFL@
CONST	SEGMENT
??_C@_0CK@BAALCHIJ@EAX?$DN?$CF?48lx?5CS?$DN?$CF?44x?5EIP?$DN?$CF?48lx?5EFL@ DB 'E'
	DB	'AX=%.8lx CS=%.4x EIP=%.8lx EFLGS=%.8lx', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NADCNKKP@Registers?3?$AN?6@
CONST	SEGMENT
??_C@_0N@NADCNKKP@Registers?3?$AN?6@ DB 'Registers:', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GKJKFFJO@Exception?5handler?3?5@
CONST	SEGMENT
??_C@_0BE@GKJKFFJO@Exception?5handler?3?5@ DB 'Exception handler: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acce@
CONST	SEGMENT
??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acce@ DB '%s loc'
	DB	'ation %08x caused an access violation.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPFAPHAF@Write?5to@
CONST	SEGMENT
??_C@_08CPFAPHAF@Write?5to@ DB 'Write to', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHOILLPP@Read?5from@
CONST	SEGMENT
??_C@_09JHOILLPP@Read?5from@ DB 'Read from', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4@
CONST	SEGMENT
??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4@ DB 'Exception'
	DB	' handler called in %s.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NIEGMIHB@main?5thread@
CONST	SEGMENT
??_C@_0M@NIEGMIHB@main?5thread@ DB 'main thread', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PECMEOFD@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF0@
CONST	SEGMENT
??_C@_0CK@PECMEOFD@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF0@ DB '%'
	DB	's caused %s in module %s at %04x:%08x.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HFCEIAIB@SRB2?$CFs?5?9ERROR?5LOG?9?$AN?6?$AN?6@
CONST	SEGMENT
??_C@_0BH@HFCEIAIB@SRB2?$CFs?5?9ERROR?5LOG?9?$AN?6?$AN?6@ DB 'SRB2%s -ERR'
	DB	'OR LOG-', 0dH, 0aH, 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJKPKDGN@?5v2?40?47@
CONST	SEGMENT
??_C@_07IJKPKDGN@?5v2?40?47@ DB ' v2.0.7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6@
CONST	SEGMENT
??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6@ DB 0dH, 0aH, 0dH, 0aH, 0dH, 0aH
	DB	0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JBOMNEPP@Make?5sure?5you?5tell?5us?5what?5you?5@
CONST	SEGMENT
??_C@_0GA@JBOMNEPP@Make?5sure?5you?5tell?5us?5what?5you?5@ DB 'Make sure '
	DB	'you tell us what you were doing to cause the crash, and if po'
	DB	'ssible, record a demo!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EPEEFCEA@Email?5Sonic?5Team?5Junior?5so?5we?5c@
CONST	SEGMENT
??_C@_0DB@EPEEFCEA@Email?5Sonic?5Team?5Junior?5so?5we?5c@ DB 'Email Sonic'
	DB	' Team Junior so we can fix the bugs', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report@
CONST	SEGMENT
??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report@ DB 'Error creating'
	DB	' exception report', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BHIHAFGJ@errorlog?4txt@
CONST	SEGMENT
??_C@_0N@BHIHAFGJ@errorlog?4txt@ DB 'errorlog.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6@
CONST	SEGMENT
??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6@ DB '%d MBytes'
	DB	' physical memory.', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@NGMMDFMM@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?5?$CFd?4?$CFd?4@
CONST	SEGMENT
??_C@_0EE@NGMMDFMM@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?5?$CFd?4?$CFd?4@ DB '%'
	DB	'd processor(s), type %d %d.%d.', 0dH, 0aH, 'Program Memory fr'
	DB	'om 0x%p to 0x%p', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6@
CONST	SEGMENT
??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6@ DB '%s, run by %s.', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6@
CONST	SEGMENT
??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6@ DB 'Error occurred'
	DB	' at %s.', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresse@
CONST	SEGMENT
??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresse@ DB 0dH, 0aH
	DB	09H, 'Module list: names, addresses, sizes, time stamps and fi'
	DB	'le times:', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes@
CONST	SEGMENT
??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes@ DB '%'
	DB	's, loaded at 0x%08x - %d bytes - %08x%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5@
CONST	SEGMENT
??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5@ DB ' - file date is ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d@
CONST	SEGMENT
??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d@ DB '%d'
	DB	'/%d/%d %02d:%02d:%02d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GMMOLJLG@Unknown?5exception?5type@
CONST	SEGMENT
??_C@_0BH@GMMOLJLG@Unknown?5exception?5type@ DB 'Unknown exception type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception@
CONST	SEGMENT
??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception@ DB 'a Microsoft C+'
	DB	'+ Exception', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed@
CONST	SEGMENT
??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed@ DB 'a DLL Initializati'
	DB	'on Failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception@
CONST	SEGMENT
??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception@ DB 'a Noncontinuable Exc'
	DB	'eption', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JNBECNGI@a?5No?5Memory@
CONST	SEGMENT
??_C@_0M@JNBECNGI@a?5No?5Memory@ DB 'a No Memory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MNEFCPPO@a?5Control?9Break@
CONST	SEGMENT
??_C@_0BA@MNEFCPPO@a?5Control?9Break@ DB 'a Control-Break', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNOJOPNP@a?5Control?9C@
CONST	SEGMENT
??_C@_0M@FNOJOPNP@a?5Control?9C@ DB 'a Control-C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LJENMGNL@a?5Stack?5Overflow@
CONST	SEGMENT
??_C@_0BB@LJENMGNL@a?5Stack?5Overflow@ DB 'a Stack Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LIBDHKBA@a?5Single?5Step@
CONST	SEGMENT
??_C@_0O@LIBDHKBA@a?5Single?5Step@ DB 'a Single Step', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction@
CONST	SEGMENT
??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction@ DB 'a Privileged Instructi'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DJIMDBAI@Noncontinuable?5Exception@
CONST	SEGMENT
??_C@_0BJ@DJIMDBAI@Noncontinuable?5Exception@ DB 'Noncontinuable Exceptio'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition@
CONST	SEGMENT
??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition@ DB 'an Invalid Disposition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CDPGECPC@an?5Integer?5Overflow@
CONST	SEGMENT
??_C@_0BE@CDPGECPC@an?5Integer?5Overflow@ DB 'an Integer Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KEJCCHHM@an?5Integer?5Divide?5By?5Zero@
CONST	SEGMENT
??_C@_0BK@KEJCCHHM@an?5Integer?5Divide?5By?5Zero@ DB 'an Integer Divide B'
	DB	'y Zero', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DKICMMFA@an?5In?5Page?5Error@
CONST	SEGMENT
??_C@_0BB@DKICMMFA@an?5In?5Page?5Error@ DB 'an In Page Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction@
CONST	SEGMENT
??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction@ DB 'an Illegal Instruction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CICINNDB@a?5Float?5Underflow@
CONST	SEGMENT
??_C@_0BC@CICINNDB@a?5Float?5Underflow@ DB 'a Float Underflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check@
CONST	SEGMENT
??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check@ DB 'a Float Stack Check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LAJAGHGH@a?5Float?5Overflow@
CONST	SEGMENT
??_C@_0BB@LAJAGHGH@a?5Float?5Overflow@ DB 'a Float Overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation@
CONST	SEGMENT
??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation@ DB 'a Float Invalid Oper'
	DB	'ation', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result@
CONST	SEGMENT
??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result@ DB 'a Float Inexact Result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BAAKOIO@a?5Float?5Divide?5By?5Zero@
CONST	SEGMENT
??_C@_0BH@BAAKOIO@a?5Float?5Divide?5By?5Zero@ DB 'a Float Divide By Zero', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand@
CONST	SEGMENT
??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand@ DB 'a Float Denormal Opera'
	DB	'nd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment@
CONST	SEGMENT
??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment@ DB 'a Datatype Misalignment'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JLDHOHAI@a?5Breakpoint@
CONST	SEGMENT
??_C@_0N@JLDHOHAI@a?5Breakpoint@ DB 'a Breakpoint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded@
CONST	SEGMENT
??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded@ DB 'a Array Bounds Exceede'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GLOKLDAN@an?5Access?5Violation@
CONST	SEGMENT
??_C@_0BE@GLOKLDAN@an?5Access?5Violation@ DB 'an Access Violation', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0151H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	026H
	DW	01e9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_ShowModuleInfo DD 0ffffffe4H
	DD	00H
	DD	0fffffe14H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN15@ShowModule
	DD	FLAT:$LN11@ShowModule
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	071H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0229H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	026H
	DW	08b8H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_RecordExceptionInfo@4 DD 0ffffffe4H
	DD	00H
	DD	0fffff30cH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN52@RecordExce
	DD	FLAT:$LN43@RecordExce
	DD	0fffffffeH
	DD	FLAT:$LN53@RecordExce
	DD	FLAT:$LN47@RecordExce
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _RecordSystemInformation
_TEXT	SEGMENT
_MemInfo$ = -644					; size = 32
_SystemInfo$ = -612					; size = 36
_UserNameSize$ = -576					; size = 4
_UserName$ = -572					; size = 200
_ModuleName$ = -372					; size = 260
_TimeBuffer$ = -112					; size = 100
_CurrentTime$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_fileHandle$ = 8					; size = 4
_RecordSystemInformation PROC				; COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 03 00
	00		 sub	 esp, 772		; 00000304H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 338  : 	FILETIME     CurrentTime;
; 339  : 	CHAR         TimeBuffer[100];
; 340  : 	CHAR         ModuleName[MAX_PATH];
; 341  : 	CHAR         UserName[200];
; 342  : 	DWORD        UserNameSize;
; 343  : 	SYSTEM_INFO  SystemInfo;
; 344  : 	MEMORYSTATUS MemInfo;
; 345  : 
; 346  : 	GetSystemTimeAsFileTime(&CurrentTime);

  00016	8d 45 f4	 lea	 eax, DWORD PTR _CurrentTime$[ebp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemTimeAsFileTime@4
  00020	90		 npad	 1

; 347  : 	PrintTime(TimeBuffer, CurrentTime);

  00021	8b 45 f8	 mov	 eax, DWORD PTR _CurrentTime$[ebp+4]
  00024	50		 push	 eax
  00025	8b 4d f4	 mov	 ecx, DWORD PTR _CurrentTime$[ebp]
  00028	51		 push	 ecx
  00029	8d 55 90	 lea	 edx, DWORD PTR _TimeBuffer$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _PrintTime
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 	FPrintf(fileHandle, "Error occurred at %s.\r\n", TimeBuffer);

  00035	8d 45 90	 lea	 eax, DWORD PTR _TimeBuffer$[ebp]
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@JNCPBKJH@Error?5occurred?5at?5?$CFs?4?$AN?6@
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _fileHandle$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _FPrintf
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 349  : 
; 350  : 	if (GetModuleFileNameA(NULL, ModuleName, sizeof(ModuleName)) <= 0)

  0004a	68 04 01 00 00	 push	 260			; 00000104H
  0004f	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _ModuleName$[ebp]
  00055	50		 push	 eax
  00056	6a 00		 push	 0
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  0005e	85 c0		 test	 eax, eax
  00060	77 14		 ja	 SHORT $LN2@RecordSyst

; 351  : 		strcpy(ModuleName, "Unknown");

  00062	68 00 00 00 00	 push	 OFFSET ??_C@_07NBCGADJA@Unknown@
  00067	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _ModuleName$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _strcpy
  00073	83 c4 08	 add	 esp, 8
$LN2@RecordSyst:

; 352  : 	UserNameSize = sizeof(UserName);

  00076	c7 85 c0 fd ff
	ff c8 00 00 00	 mov	 DWORD PTR _UserNameSize$[ebp], 200 ; 000000c8H

; 353  : 	if (!GetUserNameA(UserName, &UserNameSize))

  00080	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _UserNameSize$[ebp]
  00086	50		 push	 eax
  00087	8d 8d c4 fd ff
	ff		 lea	 ecx, DWORD PTR _UserName$[ebp]
  0008d	51		 push	 ecx
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetUserNameA@8
  00094	85 c0		 test	 eax, eax
  00096	75 14		 jne	 SHORT $LN3@RecordSyst

; 354  : 		strcpy(UserName, "Unknown");

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_07NBCGADJA@Unknown@
  0009d	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _UserName$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _strcpy
  000a9	83 c4 08	 add	 esp, 8
$LN3@RecordSyst:

; 355  : 	FPrintf(fileHandle, "%s, run by %s.\r\n", ModuleName, UserName);

  000ac	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _UserName$[ebp]
  000b2	50		 push	 eax
  000b3	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _ModuleName$[ebp]
  000b9	51		 push	 ecx
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GEKHAOPD@?$CFs?0?5run?5by?5?$CFs?4?$AN?6@
  000bf	8b 55 08	 mov	 edx, DWORD PTR _fileHandle$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _FPrintf
  000c8	83 c4 10	 add	 esp, 16			; 00000010H

; 356  : 
; 357  : 	GetSystemInfo(&SystemInfo);

  000cb	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4
  000d8	90		 npad	 1

; 358  : 	FPrintf(fileHandle, "%d processor(s), type %d %d.%d.\r\n"

  000d9	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _SystemInfo$[ebp+12]
  000df	50		 push	 eax
  000e0	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _SystemInfo$[ebp+8]
  000e6	51		 push	 ecx
  000e7	0f b7 95 be fd
	ff ff		 movzx	 edx, WORD PTR _SystemInfo$[ebp+34]
  000ee	52		 push	 edx
  000ef	0f b7 85 bc fd
	ff ff		 movzx	 eax, WORD PTR _SystemInfo$[ebp+32]
  000f6	50		 push	 eax
  000f7	8b 8d b4 fd ff
	ff		 mov	 ecx, DWORD PTR _SystemInfo$[ebp+24]
  000fd	51		 push	 ecx
  000fe	8b 95 b0 fd ff
	ff		 mov	 edx, DWORD PTR _SystemInfo$[ebp+20]
  00104	52		 push	 edx
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@NGMMDFMM@?$CFd?5processor?$CIs?$CJ?0?5type?5?$CFd?5?$CFd?4?$CFd?4@
  0010a	8b 45 08	 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _FPrintf
  00113	83 c4 20	 add	 esp, 32			; 00000020H

; 359  : 	        "Program Memory from 0x%p to 0x%p\r\n",
; 360  : 	        SystemInfo.dwNumberOfProcessors,
; 361  : 	        SystemInfo.dwProcessorType,
; 362  : 	        SystemInfo.wProcessorLevel,
; 363  : 	        SystemInfo.wProcessorRevision,
; 364  : 	        SystemInfo.lpMinimumApplicationAddress,
; 365  : 	        SystemInfo.lpMaximumApplicationAddress);
; 366  : 
; 367  : 	MemInfo.dwLength = sizeof(MemInfo);

  00116	c7 85 7c fd ff
	ff 20 00 00 00	 mov	 DWORD PTR _MemInfo$[ebp], 32 ; 00000020H

; 368  : 	GlobalMemoryStatus(&MemInfo);

  00120	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR _MemInfo$[ebp]
  00126	50		 push	 eax
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatus@4
  0012d	90		 npad	 1

; 369  : 	// Print out the amount of physical memory, rounded up.
; 370  : 	FPrintf(fileHandle, "%d MBytes physical memory.\r\n", (MemInfo.dwTotalPhys +

  0012e	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR _MemInfo$[ebp+8]
  00134	05 ff ff 0f 00	 add	 eax, 1048575		; 000fffffH
  00139	c1 e8 14	 shr	 eax, 20			; 00000014H
  0013c	50		 push	 eax
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PBHEHCOH@?$CFd?5MBytes?5physical?5memory?4?$AN?6@
  00142	8b 4d 08	 mov	 ecx, DWORD PTR _fileHandle$[ebp]
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _FPrintf
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 371  : 	        ONEM - 1) / ONEM);
; 372  : }

  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	33 cd		 xor	 ecx, ebp
  00156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
_RecordSystemInformation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _RecordModuleList
_TEXT	SEGMENT
_LastAllocationBase$ = -80				; size = 4
_pageNum$ = -76						; size = 4
_NumPages$ = -72					; size = 4
_PageSize$ = -68					; size = 4
_MemInfo$ = -64						; size = 28
_SystemInfo$ = -36					; size = 36
_LogFile$ = 8						; size = 4
_RecordModuleList PROC					; COMDAT

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 286  : 	SYSTEM_INFO SystemInfo;
; 287  : 	MEMORY_BASIC_INFORMATION MemInfo;
; 288  : 	size_t PageSize;
; 289  : 	size_t NumPages;
; 290  : 	size_t pageNum = 0;

  0000c	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _pageNum$[ebp], 0

; 291  : 	LPVOID LastAllocationBase = 0;

  00013	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _LastAllocationBase$[ebp], 0

; 292  : 
; 293  : 	FPrintf(LogFile, "\r\n"

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@IAGPJNKE@?$AN?6?7Module?5list?3?5names?0?5addresse@
  0001f	8b 45 08	 mov	 eax, DWORD PTR _LogFile$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _FPrintf
  00028	83 c4 08	 add	 esp, 8

; 294  : 		"\tModule list: names, addresses, sizes, time stamps "
; 295  : 		"and file times:\r\n");
; 296  : 
; 297  : 	// Set NumPages to the number of pages in the 4GByte address space,
; 298  : 	// while being careful to avoid overflowing ints.
; 299  : 	GetSystemInfo(&SystemInfo);

  0002b	8d 45 dc	 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4
  00035	90		 npad	 1

; 300  : 	PageSize = SystemInfo.dwPageSize;

  00036	8b 45 e0	 mov	 eax, DWORD PTR _SystemInfo$[ebp+4]
  00039	89 45 bc	 mov	 DWORD PTR _PageSize$[ebp], eax

; 301  : 	NumPages = 4 * (size_t)(ONEG / PageSize);

  0003c	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00041	33 d2		 xor	 edx, edx
  00043	f7 75 bc	 div	 DWORD PTR _PageSize$[ebp]
  00046	c1 e0 02	 shl	 eax, 2
  00049	89 45 b8	 mov	 DWORD PTR _NumPages$[ebp], eax
$LN2@RecordModu:

; 302  : 	while(pageNum < NumPages)

  0004c	8b 45 b4	 mov	 eax, DWORD PTR _pageNum$[ebp]
  0004f	3b 45 b8	 cmp	 eax, DWORD PTR _NumPages$[ebp]
  00052	73 7c		 jae	 SHORT $LN3@RecordModu

; 303  : 	{
; 304  : 		if (VirtualQuery((LPVOID)(pageNum * PageSize), &MemInfo,

  00054	6a 1c		 push	 28			; 0000001cH
  00056	8d 45 c0	 lea	 eax, DWORD PTR _MemInfo$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d b4	 mov	 ecx, DWORD PTR _pageNum$[ebp]
  0005d	0f af 4d bc	 imul	 ecx, DWORD PTR _PageSize$[ebp]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualQuery@12
  00068	85 c0		 test	 eax, eax
  0006a	74 4f		 je	 SHORT $LN4@RecordModu

; 305  : 			sizeof(MemInfo)))
; 306  : 		{
; 307  : 			if (MemInfo.RegionSize > 0)

  0006c	83 7d cc 00	 cmp	 DWORD PTR _MemInfo$[ebp+12], 0
  00070	76 37		 jbe	 SHORT $LN6@RecordModu

; 308  : 			{
; 309  : 				// Adjust the page number to skip over this block of memory.
; 310  : 				pageNum += MemInfo.RegionSize / PageSize;

  00072	8b 45 cc	 mov	 eax, DWORD PTR _MemInfo$[ebp+12]
  00075	33 d2		 xor	 edx, edx
  00077	f7 75 bc	 div	 DWORD PTR _PageSize$[ebp]
  0007a	03 45 b4	 add	 eax, DWORD PTR _pageNum$[ebp]
  0007d	89 45 b4	 mov	 DWORD PTR _pageNum$[ebp], eax

; 311  : 				if (MemInfo.State == MEM_COMMIT && MemInfo.AllocationBase >

  00080	81 7d d0 00 10
	00 00		 cmp	 DWORD PTR _MemInfo$[ebp+16], 4096 ; 00001000H
  00087	75 1e		 jne	 SHORT $LN8@RecordModu
  00089	8b 45 c4	 mov	 eax, DWORD PTR _MemInfo$[ebp+4]
  0008c	3b 45 b0	 cmp	 eax, DWORD PTR _LastAllocationBase$[ebp]
  0008f	76 16		 jbe	 SHORT $LN8@RecordModu

; 312  : 					LastAllocationBase)
; 313  : 				{
; 314  : 					// Look for new blocks of committed memory, and try
; 315  : 					// recording their module names - this will fail
; 316  : 					// gracefully if they aren't code modules.
; 317  : 					LastAllocationBase = MemInfo.AllocationBase;

  00091	8b 45 c4	 mov	 eax, DWORD PTR _MemInfo$[ebp+4]
  00094	89 45 b0	 mov	 DWORD PTR _LastAllocationBase$[ebp], eax

; 318  : 					ShowModuleInfo(LogFile, (HMODULE)LastAllocationBase);

  00097	8b 45 b0	 mov	 eax, DWORD PTR _LastAllocationBase$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _LogFile$[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _ShowModuleInfo
  000a4	83 c4 08	 add	 esp, 8
$LN8@RecordModu:

; 319  : 				}
; 320  : 			}

  000a7	eb 10		 jmp	 SHORT $LN7@RecordModu
$LN6@RecordModu:

; 321  : 			else
; 322  : 				pageNum += SIXTYFOURK / PageSize;

  000a9	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  000ae	33 d2		 xor	 edx, edx
  000b0	f7 75 bc	 div	 DWORD PTR _PageSize$[ebp]
  000b3	03 45 b4	 add	 eax, DWORD PTR _pageNum$[ebp]
  000b6	89 45 b4	 mov	 DWORD PTR _pageNum$[ebp], eax
$LN7@RecordModu:

; 323  : 		}

  000b9	eb 10		 jmp	 SHORT $LN5@RecordModu
$LN4@RecordModu:

; 324  : 		else
; 325  : 			pageNum += SIXTYFOURK / PageSize;

  000bb	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  000c0	33 d2		 xor	 edx, edx
  000c2	f7 75 bc	 div	 DWORD PTR _PageSize$[ebp]
  000c5	03 45 b4	 add	 eax, DWORD PTR _pageNum$[ebp]
  000c8	89 45 b4	 mov	 DWORD PTR _pageNum$[ebp], eax
$LN5@RecordModu:

; 326  : 		// If VirtualQuery fails we advance by 64K because that is the
; 327  : 		// granularity of address space doled out by VirtualAlloc().
; 328  : 	}

  000cb	e9 7c ff ff ff	 jmp	 $LN2@RecordModu
$LN3@RecordModu:

; 329  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_RecordModuleList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _ShowModuleInfo
_TEXT	SEGMENT
_LastWriteTime$2 = -412					; size = 8
_FileSize$ = -404					; size = 4
_TimeBuffer$ = -400					; size = 100
_ModuleFile$ = -300					; size = 4
_NTHeader$ = -296					; size = 4
_DosHeader$ = -292					; size = 4
_ModName$ = -288					; size = 260
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_LogFile$ = 8						; size = 4
_ModuleHandle$ = 12					; size = 4
_ShowModuleInfo PROC					; COMDAT

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$_ShowModuleInfo
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 c4 34 fe ff
	ff		 add	 esp, -460		; fffffe34H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 224  : 	CHAR ModName[MAX_PATH];
; 225  : 	IMAGE_DOS_HEADER *DosHeader;
; 226  : 	IMAGE_NT_HEADERS *NTHeader;
; 227  : 	HANDLE ModuleFile;
; 228  : 	CHAR TimeBuffer[100] = "";

  00039	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0003e	88 85 70 fe ff
	ff		 mov	 BYTE PTR _TimeBuffer$[ebp], al
  00044	6a 63		 push	 99			; 00000063H
  00046	6a 00		 push	 0
  00048	8d 85 71 fe ff
	ff		 lea	 eax, DWORD PTR _TimeBuffer$[ebp+1]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _memset
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  : 	DWORD FileSize = 0;

  00057	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _FileSize$[ebp], 0

; 230  : #ifdef NO_SEH_MINGW
; 231  : 	__try1(EXCEPTION_EXECUTE_HANDLER)
; 232  : #else
; 233  : 	__try

  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 234  : #endif
; 235  : 	{
; 236  : 		if (GetModuleFileNameA(ModuleHandle, ModName, sizeof(ModName)) > 0)

  00068	68 04 01 00 00	 push	 260			; 00000104H
  0006d	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _ModName$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _ModuleHandle$[ebp]
  00077	51		 push	 ecx
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  0007e	85 c0		 test	 eax, eax
  00080	0f 86 3c 01 00
	00		 jbe	 $LN3@ShowModule

; 237  : 		{
; 238  : 			// If GetModuleFileName returns greater than zero then this must
; 239  : 			// be a valid code module address. Therefore we can try to walk
; 240  : 			// our way through its structures to find the link time stamp.
; 241  : 			DosHeader = (IMAGE_DOS_HEADER*)ModuleHandle;

  00086	8b 45 0c	 mov	 eax, DWORD PTR _ModuleHandle$[ebp]
  00089	89 85 dc fe ff
	ff		 mov	 DWORD PTR _DosHeader$[ebp], eax

; 242  : 			if (IMAGE_DOS_SIGNATURE != DosHeader->e_magic)

  0008f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _DosHeader$[ebp]
  00095	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00098	81 f9 4d 5a 00
	00		 cmp	 ecx, 23117		; 00005a4dH
  0009e	74 0c		 je	 SHORT $LN4@ShowModule

; 243  : 				return;

  000a0	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000a7	e9 2f 01 00 00	 jmp	 $LN13@ShowModule
$LN4@ShowModule:

; 244  : 			NTHeader = (IMAGE_NT_HEADERS*)((char *)DosHeader

  000ac	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _DosHeader$[ebp]
  000b2	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _DosHeader$[ebp]
  000b8	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  000bb	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _NTHeader$[ebp], ecx

; 245  : 				+ DosHeader->e_lfanew);
; 246  : 			if (IMAGE_NT_SIGNATURE != NTHeader->Signature)

  000c1	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _NTHeader$[ebp]
  000c7	81 38 50 45 00
	00		 cmp	 DWORD PTR [eax], 17744	; 00004550H
  000cd	74 0c		 je	 SHORT $LN5@ShowModule

; 247  : 				return;

  000cf	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000d6	e9 00 01 00 00	 jmp	 $LN13@ShowModule
$LN5@ShowModule:

; 248  : 			// Open the code module file so that we can get its file date
; 249  : 			// and size.
; 250  : 			ModuleFile = CreateFileA(ModName, GENERIC_READ,

  000db	6a 00		 push	 0
  000dd	68 80 00 00 00	 push	 128			; 00000080H
  000e2	6a 03		 push	 3
  000e4	6a 00		 push	 0
  000e6	6a 01		 push	 1
  000e8	68 00 00 00 80	 push	 -2147483648		; 80000000H
  000ed	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _ModName$[ebp]
  000f3	50		 push	 eax
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000fa	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _ModuleFile$[ebp], eax

; 251  : 				FILE_SHARE_READ, 0, OPEN_EXISTING,
; 252  : 				FILE_ATTRIBUTE_NORMAL, 0);
; 253  : 			if (ModuleFile != INVALID_HANDLE_VALUE)

  00100	83 bd d4 fe ff
	ff ff		 cmp	 DWORD PTR _ModuleFile$[ebp], -1
  00107	0f 84 81 00 00
	00		 je	 $LN6@ShowModule

; 254  : 			{
; 255  : 				FILETIME LastWriteTime;
; 256  : 				FileSize = GetFileSize(ModuleFile, 0);

  0010d	6a 00		 push	 0
  0010f	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _ModuleFile$[ebp]
  00115	50		 push	 eax
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  0011c	89 85 6c fe ff
	ff		 mov	 DWORD PTR _FileSize$[ebp], eax

; 257  : 				if (GetFileTime(ModuleFile, 0, 0, &LastWriteTime))

  00122	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _LastWriteTime$2[ebp]
  00128	50		 push	 eax
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _ModuleFile$[ebp]
  00133	51		 push	 ecx
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  0013a	85 c0		 test	 eax, eax
  0013c	74 42		 je	 SHORT $LN7@ShowModule

; 258  : 				{
; 259  : 					wsprintfA(TimeBuffer, " - file date is ");

  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CJPAEIHC@?5?9?5file?5date?5is?5@
  00143	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _TimeBuffer$[ebp]
  00149	50		 push	 eax
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00150	83 c4 08	 add	 esp, 8

; 260  : 					PrintTime(TimeBuffer + strlen(TimeBuffer), LastWriteTime);

  00153	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _LastWriteTime$2[ebp+4]
  00159	50		 push	 eax
  0015a	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _LastWriteTime$2[ebp]
  00160	51		 push	 ecx
  00161	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR _TimeBuffer$[ebp]
  00167	52		 push	 edx
  00168	e8 00 00 00 00	 call	 _strlen
  0016d	83 c4 04	 add	 esp, 4
  00170	8d 84 05 70 fe
	ff ff		 lea	 eax, DWORD PTR _TimeBuffer$[ebp+eax]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _PrintTime
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@ShowModule:

; 261  : 				}
; 262  : 				CloseHandle(ModuleFile);

  00180	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _ModuleFile$[ebp]
  00186	50		 push	 eax
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0018d	90		 npad	 1
$LN6@ShowModule:

; 263  : 			}
; 264  : 			FPrintf(LogFile, "%s, loaded at 0x%08x - %d bytes - %08x%s\r\n",

  0018e	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _TimeBuffer$[ebp]
  00194	50		 push	 eax
  00195	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _NTHeader$[ebp]
  0019b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0019e	52		 push	 edx
  0019f	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR _FileSize$[ebp]
  001a5	50		 push	 eax
  001a6	8b 4d 0c	 mov	 ecx, DWORD PTR _ModuleHandle$[ebp]
  001a9	51		 push	 ecx
  001aa	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _ModName$[ebp]
  001b0	52		 push	 edx
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CGOIOKCD@?$CFs?0?5loaded?5at?50x?$CF08x?5?9?5?$CFd?5bytes@
  001b6	8b 45 08	 mov	 eax, DWORD PTR _LogFile$[ebp]
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 _FPrintf
  001bf	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN3@ShowModule:

; 265  : 				ModName, ModuleHandle, FileSize,
; 266  : 				NTHeader->FileHeader.TimeDateStamp, TimeBuffer);
; 267  : 		}
; 268  : 	}

  001c2	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  001c9	eb 10		 jmp	 SHORT $LN13@ShowModule
$LN10@ShowModule:
$LN15@ShowModule:

; 269  : 	// Handle any exceptions by continuing from this point.
; 270  : #ifdef NO_SEH_MINGW
; 271  : 	__except1
; 272  : #else
; 273  : 	__except(EXCEPTION_EXECUTE_HANDLER)

  001cb	b8 01 00 00 00	 mov	 eax, 1
$LN12@ShowModule:
$LN14@ShowModule:
  001d0	c3		 ret	 0
$LN11@ShowModule:
  001d1	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 265  : 				ModName, ModuleHandle, FileSize,
; 266  : 				NTHeader->FileHeader.TimeDateStamp, TimeBuffer);
; 267  : 		}
; 268  : 	}

  001d4	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN13@ShowModule:

; 274  : #endif
; 275  : 	{}
; 276  : }

  001db	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
_ShowModuleInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _GetFilePart
_TEXT	SEGMENT
_result$ = -4						; size = 4
_source$ = 8						; size = 4
_GetFilePart PROC					; COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 210  : 	LPTSTR result = _tcsrchr(source, '\\');

  00009	6a 5c		 push	 92			; 0000005cH
  0000b	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _strrchr
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 211  : 	if (result)

  0001a	83 7d fc 00	 cmp	 DWORD PTR _result$[ebp], 0
  0001e	74 0b		 je	 SHORT $LN2@GetFilePar

; 212  : 		result++;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
  00029	eb 06		 jmp	 SHORT $LN3@GetFilePar
$LN2@GetFilePar:

; 213  : 	else
; 214  : 		result = source;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _source$[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
$LN3@GetFilePar:

; 215  : 	return result;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]

; 216  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_GetFilePart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _PrintTime
_TEXT	SEGMENT
_Time$ = -8						; size = 2
_Date$ = -4						; size = 2
_output$ = 8						; size = 4
_TimeToPrint$ = 12					; size = 8
_PrintTime PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 194  : 	WORD Date, Time;
; 195  : 	if (FileTimeToLocalFileTime(&TimeToPrint, &TimeToPrint) &&

  00009	8d 45 0c	 lea	 eax, DWORD PTR _TimeToPrint$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d 0c	 lea	 ecx, DWORD PTR _TimeToPrint$[ebp]
  00010	51		 push	 ecx
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToLocalFileTime@8
  00017	85 c0		 test	 eax, eax
  00019	0f 84 85 00 00
	00		 je	 $LN2@PrintTime
  0001f	8d 45 f8	 lea	 eax, DWORD PTR _Time$[ebp]
  00022	50		 push	 eax
  00023	8d 4d fc	 lea	 ecx, DWORD PTR _Date$[ebp]
  00026	51		 push	 ecx
  00027	8d 55 0c	 lea	 edx, DWORD PTR _TimeToPrint$[ebp]
  0002a	52		 push	 edx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToDosDateTime@12
  00031	85 c0		 test	 eax, eax
  00033	74 6f		 je	 SHORT $LN2@PrintTime

; 196  : 		FileTimeToDosDateTime(&TimeToPrint, &Date, &Time))
; 197  : 	{
; 198  : 		// What a silly way to print out the file date/time.
; 199  : 		wsprintfA(output, "%d/%d/%d %02d:%02d:%02d",

  00035	0f b7 45 f8	 movzx	 eax, WORD PTR _Time$[ebp]
  00039	83 e0 1f	 and	 eax, 31			; 0000001fH
  0003c	d1 e0		 shl	 eax, 1
  0003e	50		 push	 eax
  0003f	0f b7 45 f8	 movzx	 eax, WORD PTR _Time$[ebp]
  00043	99		 cdq
  00044	83 e2 1f	 and	 edx, 31			; 0000001fH
  00047	03 c2		 add	 eax, edx
  00049	c1 f8 05	 sar	 eax, 5
  0004c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0004f	50		 push	 eax
  00050	0f b7 45 f8	 movzx	 eax, WORD PTR _Time$[ebp]
  00054	99		 cdq
  00055	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  0005b	03 c2		 add	 eax, edx
  0005d	c1 f8 0b	 sar	 eax, 11			; 0000000bH
  00060	50		 push	 eax
  00061	0f b7 45 fc	 movzx	 eax, WORD PTR _Date$[ebp]
  00065	99		 cdq
  00066	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  0006c	03 c2		 add	 eax, edx
  0006e	c1 f8 09	 sar	 eax, 9
  00071	05 bc 07 00 00	 add	 eax, 1980		; 000007bcH
  00076	50		 push	 eax
  00077	0f b7 4d fc	 movzx	 ecx, WORD PTR _Date$[ebp]
  0007b	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0007e	51		 push	 ecx
  0007f	0f b7 45 fc	 movzx	 eax, WORD PTR _Date$[ebp]
  00083	99		 cdq
  00084	83 e2 1f	 and	 edx, 31			; 0000001fH
  00087	03 c2		 add	 eax, edx
  00089	c1 f8 05	 sar	 eax, 5
  0008c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HKCLIKLE@?$CFd?1?$CFd?1?$CFd?5?$CF02d?3?$CF02d?3?$CF02d@
  00095	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  00098	52		 push	 edx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0009f	83 c4 20	 add	 esp, 32			; 00000020H

; 200  : 		          (Date / 32) & 15, Date & 31, (Date / 512) + 1980,
; 201  : 		          (Time / 2048), (Time / 32) & 63, (Time & 31) * 2);
; 202  : 	}

  000a2	eb 0f		 jmp	 SHORT $LN3@PrintTime
$LN2@PrintTime:

; 203  : 	else
; 204  : 		output[0] = 0;

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	6b c8 00	 imul	 ecx, eax, 0
  000ac	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  000af	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
$LN3@PrintTime:

; 205  : }

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_PrintTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _FPrintf
_TEXT	SEGMENT
_bytesWritten$ = -2012					; size = 4
_arglist$ = -2008					; size = 4
_str$ = -2004						; size = 1999
__$ArrayPad$ = -4					; size = 4
_fileHandle$ = 8					; size = 4
_lpFmt$ = 12						; size = 4
_FPrintf PROC						; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 08 00
	00		 sub	 esp, 2268		; 000008dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 177  : 	CHAR    str[1999];
; 178  : 	va_list arglist;
; 179  : 	DWORD   bytesWritten;
; 180  : 
; 181  : 	va_start(arglist, lpFmt);

  00016	8d 45 10	 lea	 eax, DWORD PTR _lpFmt$[ebp+4]
  00019	89 85 28 f8 ff
	ff		 mov	 DWORD PTR _arglist$[ebp], eax

; 182  : 	vsprintf(str, lpFmt, arglist);

  0001f	8b 85 28 f8 ff
	ff		 mov	 eax, DWORD PTR _arglist$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _lpFmt$[ebp]
  00029	51		 push	 ecx
  0002a	8d 95 2c f8 ff
	ff		 lea	 edx, DWORD PTR _str$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 _vsprintf
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 	va_end(arglist);

  00039	c7 85 28 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _arglist$[ebp], 0

; 184  : 
; 185  : 	WriteFile(fileHandle, str, (DWORD)strlen(str), &bytesWritten, NULL);

  00043	6a 00		 push	 0
  00045	8d 85 24 f8 ff
	ff		 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  0004b	50		 push	 eax
  0004c	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _str$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _strlen
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	8d 95 2c f8 ff
	ff		 lea	 edx, DWORD PTR _str$[ebp]
  00062	52		 push	 edx
  00063	8b 45 08	 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0006d	90		 npad	 1

; 186  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_FPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _GetExceptionDescription
_TEXT	SEGMENT
_ExceptionMap$ = -232					; size = 224
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ExceptionCode$ = 8					; size = 4
_GetExceptionDescription PROC				; COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 124  : 	size_t i;
; 125  : 
; 126  : 	struct ExceptionNames
; 127  : 	{
; 128  : 		DWORD   ExceptionCode;
; 129  : 		LPCSTR  ExceptionName;
; 130  : 	};
; 131  : 
; 132  : 	struct ExceptionNames ExceptionMap[] =

  00016	c7 85 18 ff ff
	ff 05 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp], -1073741819 ; c0000005H
  00020	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+4], OFFSET ??_C@_0BE@GLOKLDAN@an?5Access?5Violation@
  0002a	c7 85 20 ff ff
	ff 8c 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+8], -1073741684 ; c000008cH
  00034	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+12], OFFSET ??_C@_0BI@DFIFOIBG@a?5Array?5Bounds?5Exceeded@
  0003e	c7 85 28 ff ff
	ff 03 00 00 80	 mov	 DWORD PTR _ExceptionMap$[ebp+16], -2147483645 ; 80000003H
  00048	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+20], OFFSET ??_C@_0N@JLDHOHAI@a?5Breakpoint@
  00052	c7 85 30 ff ff
	ff 02 00 00 80	 mov	 DWORD PTR _ExceptionMap$[ebp+24], -2147483646 ; 80000002H
  0005c	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+28], OFFSET ??_C@_0BI@IPDDFHBH@a?5Datatype?5Misalignment@
  00066	c7 85 38 ff ff
	ff 8d 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+32], -1073741683 ; c000008dH
  00070	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+36], OFFSET ??_C@_0BJ@LCJBHHL@a?5Float?5Denormal?5Operand@
  0007a	c7 85 40 ff ff
	ff 8e 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+40], -1073741682 ; c000008eH
  00084	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+44], OFFSET ??_C@_0BH@BAAKOIO@a?5Float?5Divide?5By?5Zero@
  0008e	c7 85 48 ff ff
	ff 8f 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+48], -1073741681 ; c000008fH
  00098	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+52], OFFSET ??_C@_0BH@HGODNPMP@a?5Float?5Inexact?5Result@
  000a2	c7 85 50 ff ff
	ff 90 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+56], -1073741680 ; c0000090H
  000ac	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+60], OFFSET ??_C@_0BK@NACDCIPD@a?5Float?5Invalid?5Operation@
  000b6	c7 85 58 ff ff
	ff 91 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+64], -1073741679 ; c0000091H
  000c0	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+68], OFFSET ??_C@_0BB@LAJAGHGH@a?5Float?5Overflow@
  000ca	c7 85 60 ff ff
	ff 92 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+72], -1073741678 ; c0000092H
  000d4	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+76], OFFSET ??_C@_0BE@DOBFFDCD@a?5Float?5Stack?5Check@
  000de	c7 85 68 ff ff
	ff 93 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+80], -1073741677 ; c0000093H
  000e8	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+84], OFFSET ??_C@_0BC@CICINNDB@a?5Float?5Underflow@
  000f2	c7 85 70 ff ff
	ff 1d 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+88], -1073741795 ; c000001dH
  000fc	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+92], OFFSET ??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction@
  00106	c7 85 78 ff ff
	ff 06 00 00 c0	 mov	 DWORD PTR _ExceptionMap$[ebp+96], -1073741818 ; c0000006H
  00110	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _ExceptionMap$[ebp+100], OFFSET ??_C@_0BB@DKICMMFA@an?5In?5Page?5Error@
  0011a	c7 45 80 94 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+104], -1073741676 ; c0000094H
  00121	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+108], OFFSET ??_C@_0BK@KEJCCHHM@an?5Integer?5Divide?5By?5Zero@
  00128	c7 45 88 95 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+112], -1073741675 ; c0000095H
  0012f	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+116], OFFSET ??_C@_0BE@CDPGECPC@an?5Integer?5Overflow@
  00136	c7 45 90 26 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+120], -1073741786 ; c0000026H
  0013d	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+124], OFFSET ??_C@_0BH@HOHCDFKK@an?5Invalid?5Disposition@
  00144	c7 45 98 25 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+128], -1073741787 ; c0000025H
  0014b	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+132], OFFSET ??_C@_0BJ@DJIMDBAI@Noncontinuable?5Exception@
  00152	c7 45 a0 96 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+136], -1073741674 ; c0000096H
  00159	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+140], OFFSET ??_C@_0BJ@HMGNLHOK@a?5Privileged?5Instruction@
  00160	c7 45 a8 04 00
	00 80		 mov	 DWORD PTR _ExceptionMap$[ebp+144], -2147483644 ; 80000004H
  00167	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+148], OFFSET ??_C@_0O@LIBDHKBA@a?5Single?5Step@
  0016e	c7 45 b0 fd 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+152], -1073741571 ; c00000fdH
  00175	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+156], OFFSET ??_C@_0BB@LJENMGNL@a?5Stack?5Overflow@
  0017c	c7 45 b8 05 00
	01 40		 mov	 DWORD PTR _ExceptionMap$[ebp+160], 1073807365 ; 40010005H
  00183	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+164], OFFSET ??_C@_0M@FNOJOPNP@a?5Control?9C@
  0018a	c7 45 c0 08 00
	01 40		 mov	 DWORD PTR _ExceptionMap$[ebp+168], 1073807368 ; 40010008H
  00191	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+172], OFFSET ??_C@_0BA@MNEFCPPO@a?5Control?9Break@
  00198	c7 45 c8 06 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+176], -1073741818 ; c0000006H
  0019f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+180], OFFSET ??_C@_0BB@DKICMMFA@an?5In?5Page?5Error@
  001a6	c7 45 d0 17 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+184], -1073741801 ; c0000017H
  001ad	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+188], OFFSET ??_C@_0M@JNBECNGI@a?5No?5Memory@
  001b4	c7 45 d8 1d 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+192], -1073741795 ; c000001dH
  001bb	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+196], OFFSET ??_C@_0BH@CMGOADMI@an?5Illegal?5Instruction@
  001c2	c7 45 e0 25 00
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+200], -1073741787 ; c0000025H
  001c9	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+204], OFFSET ??_C@_0BL@DFCKDLHL@a?5Noncontinuable?5Exception@
  001d0	c7 45 e8 42 01
	00 c0		 mov	 DWORD PTR _ExceptionMap$[ebp+208], -1073741502 ; c0000142H
  001d7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+212], OFFSET ??_C@_0BM@LDHCKNKI@a?5DLL?5Initialization?5Failed@
  001de	c7 45 f0 63 73
	6d e0		 mov	 DWORD PTR _ExceptionMap$[ebp+216], -529697949 ; e06d7363H
  001e5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ExceptionMap$[ebp+220], OFFSET ??_C@_0BK@HOJFPEEB@a?5Microsoft?5C?$CL?$CL?5Exception@

; 133  : 	{
; 134  : 		{EXCEPTION_ACCESS_VIOLATION, "an Access Violation"},
; 135  : 		{EXCEPTION_ARRAY_BOUNDS_EXCEEDED, "a Array Bounds Exceeded"},
; 136  : 		{EXCEPTION_BREAKPOINT, "a Breakpoint"},
; 137  : 		{EXCEPTION_DATATYPE_MISALIGNMENT, "a Datatype Misalignment"},
; 138  : 		{EXCEPTION_FLT_DENORMAL_OPERAND, "a Float Denormal Operand"},
; 139  : 		{EXCEPTION_FLT_DIVIDE_BY_ZERO, "a Float Divide By Zero"},
; 140  : 		{EXCEPTION_FLT_INEXACT_RESULT, "a Float Inexact Result"},
; 141  : 		{EXCEPTION_FLT_INVALID_OPERATION, "a Float Invalid Operation"},
; 142  : 		{EXCEPTION_FLT_OVERFLOW, "a Float Overflow"},
; 143  : 		{EXCEPTION_FLT_STACK_CHECK, "a Float Stack Check"},
; 144  : 		{EXCEPTION_FLT_UNDERFLOW, "a Float Underflow"},
; 145  : 		{EXCEPTION_ILLEGAL_INSTRUCTION, "an Illegal Instruction"},
; 146  : 		{EXCEPTION_IN_PAGE_ERROR, "an In Page Error"},
; 147  : 		{EXCEPTION_INT_DIVIDE_BY_ZERO, "an Integer Divide By Zero"},
; 148  : 		{EXCEPTION_INT_OVERFLOW, "an Integer Overflow"},
; 149  : 		{EXCEPTION_INVALID_DISPOSITION, "an Invalid Disposition"},
; 150  : 		{EXCEPTION_NONCONTINUABLE_EXCEPTION, "Noncontinuable Exception"},
; 151  : 		{EXCEPTION_PRIV_INSTRUCTION, "a Privileged Instruction"},
; 152  : 		{EXCEPTION_SINGLE_STEP, "a Single Step"},
; 153  : 		{EXCEPTION_STACK_OVERFLOW, "a Stack Overflow"},
; 154  : 		{0x40010005, "a Control-C"},
; 155  : 		{0x40010008, "a Control-Break"},
; 156  : 		{0xc0000006, "an In Page Error"},
; 157  : 		{0xc0000017, "a No Memory"},
; 158  : 		{0xc000001d, "an Illegal Instruction"},
; 159  : 		{0xc0000025, "a Noncontinuable Exception"},
; 160  : 		{0xc0000142, "a DLL Initialization Failed"},
; 161  : 		{0xe06d7363, "a Microsoft C++ Exception"},
; 162  : 	};
; 163  : 
; 164  : 	for (i = 0; i < (sizeof(ExceptionMap) / sizeof(ExceptionMap[0])); i++)

  001ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001f3	eb 09		 jmp	 SHORT $LN4@GetExcepti
$LN2@GetExcepti:
  001f5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001f8	83 c0 01	 add	 eax, 1
  001fb	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetExcepti:
  001fe	83 7d f8 1c	 cmp	 DWORD PTR _i$[ebp], 28	; 0000001cH
  00202	73 1d		 jae	 SHORT $LN3@GetExcepti

; 165  : 		if (ExceptionCode == ExceptionMap[i].ExceptionCode)

  00204	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00207	8b 4d 08	 mov	 ecx, DWORD PTR _ExceptionCode$[ebp]
  0020a	3b 8c c5 18 ff
	ff ff		 cmp	 ecx, DWORD PTR _ExceptionMap$[ebp+eax*8]
  00211	75 0c		 jne	 SHORT $LN5@GetExcepti

; 166  : 			return ExceptionMap[i].ExceptionName;

  00213	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00216	8b 84 c5 1c ff
	ff ff		 mov	 eax, DWORD PTR _ExceptionMap$[ebp+eax*8+4]
  0021d	eb 07		 jmp	 SHORT $LN1@GetExcepti
$LN5@GetExcepti:
  0021f	eb d4		 jmp	 SHORT $LN2@GetExcepti
$LN3@GetExcepti:

; 167  : 
; 168  : 	return "Unknown exception type";

  00221	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@GMMOLJLG@Unknown?5exception?5type@
$LN1@GetExcepti:

; 169  : }

  00226	5f		 pop	 edi
  00227	5e		 pop	 esi
  00228	5b		 pop	 ebx
  00229	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022c	33 cd		 xor	 ecx, ebp
  0022e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c3		 ret	 0
_GetExceptionDescription ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_dbg.c
;	COMDAT _RecordExceptionInfo@4
_TEXT	SEGMENT
$T2 = -3300						; size = 4
$T3 = -3296						; size = 4
_Suffix$4 = -2908					; size = 4
_output$5 = -2904					; size = 4
_nearend$6 = -2900					; size = 4
_safetyzone$7 = -2896					; size = 4
_buffer$8 = -2892					; size = 1000
_Count$9 = -1888					; size = 4
_pStackTop$10 = -1884					; size = 4
_pStack$11 = -1880					; size = 4
_readwrite$12 = -1876					; size = 4
_DebugMessage$13 = -1872				; size = 1000
_i$ = -872						; size = 4
_codebyte$ = -868					; size = 4
_code$ = -864						; size = 4
_fileHandle$ = -860					; size = 4
_MemInfo$ = -856					; size = 28
_CrashModuleFileName$ = -828				; size = 4
_CrashModulePathName$ = -824				; size = 260
_lastperiod$ = -564					; size = 4
_FilePart$ = -560					; size = 4
_FileName$ = -556					; size = 260
_ModuleName$ = -296					; size = 260
_Context$ = -36						; size = 4
_Exception$ = -32					; size = 4
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_data$ = 8						; size = 4
_RecordExceptionInfo@4 PROC				; COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$_RecordExceptionInfo@4
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 c4 2c f3 ff
	ff		 add	 esp, -3284		; fffff32cH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 384  : 	PEXCEPTION_RECORD   Exception = NULL;

  00039	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Exception$[ebp], 0

; 385  : 	PCONTEXT            Context = NULL;

  00040	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Context$[ebp], 0

; 386  : 	TCHAR               ModuleName[MAX_PATH];
; 387  : 	TCHAR               FileName[MAX_PATH] = TEXT("Unknown");

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07NBCGADJA@Unknown@
  0004c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_07NBCGADJA@Unknown@+4
  00052	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _FileName$[ebp], eax
  00058	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _FileName$[ebp+4], ecx
  0005e	68 fc 00 00 00	 push	 252			; 000000fcH
  00063	6a 00		 push	 0
  00065	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _FileName$[ebp+8]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memset
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 388  : 	LPTSTR              FilePart, lastperiod;
; 389  : 	TCHAR               CrashModulePathName[MAX_PATH];
; 390  : 	LPCTSTR             CrashModuleFileName = TEXT("Unknown");

  00074	c7 85 c4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _CrashModuleFileName$[ebp], OFFSET ??_C@_07NBCGADJA@Unknown@

; 391  : 	MEMORY_BASIC_INFORMATION    MemInfo;
; 392  : 	static BOOL         BeenHere = FALSE;
; 393  : 	HANDLE              fileHandle;
; 394  : 	LPBYTE              code = NULL;

  0007e	c7 85 a0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _code$[ebp], 0

; 395  : 	int                 codebyte,i;
; 396  : 
; 397  : 	if (data)

  00088	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  0008c	74 13		 je	 SHORT $LN10@RecordExce

; 398  : 	{
; 399  : 		Exception = data->ExceptionRecord;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	89 4d e0	 mov	 DWORD PTR _Exception$[ebp], ecx

; 400  : 		Context = data->ContextRecord;

  00096	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	89 4d dc	 mov	 DWORD PTR _Context$[ebp], ecx

; 401  : 	}

  0009f	eb 1d		 jmp	 SHORT $LN11@RecordExce
$LN10@RecordExce:

; 402  : 	else if (prevExceptionFilter)

  000a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _prevExceptionFilter, 0
  000a8	74 0d		 je	 SHORT $LN12@RecordExce

; 403  : 		prevExceptionFilter(data);

  000aa	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000ad	50		 push	 eax
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR _prevExceptionFilter
  000b4	90		 npad	 1
  000b5	eb 07		 jmp	 SHORT $LN11@RecordExce
$LN12@RecordExce:

; 404  : 	else
; 405  : 		return EXCEPTION_CONTINUE_SEARCH;

  000b7	33 c0		 xor	 eax, eax
  000b9	e9 ec 07 00 00	 jmp	 $LN41@RecordExce
$LN11@RecordExce:

; 406  : 
; 407  : 	if (BeenHere)       // Going recursive! That must mean this routine crashed!

  000be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BeenHere@?1??RecordExceptionInfo@@9@9, 0
  000c5	74 1f		 je	 SHORT $LN14@RecordExce

; 408  : 	{
; 409  : 		if (prevExceptionFilter)

  000c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _prevExceptionFilter, 0
  000ce	74 0f		 je	 SHORT $LN15@RecordExce

; 410  : 			return prevExceptionFilter(data);

  000d0	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000d3	50		 push	 eax
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR _prevExceptionFilter
  000da	e9 cb 07 00 00	 jmp	 $LN41@RecordExce
$LN15@RecordExce:

; 411  : 		return EXCEPTION_CONTINUE_SEARCH;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 c4 07 00 00	 jmp	 $LN41@RecordExce
$LN14@RecordExce:

; 412  : 	}
; 413  : 	BeenHere = TRUE;

  000e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?BeenHere@?1??RecordExceptionInfo@@9@9, 1

; 414  : 
; 415  : #ifdef _X86_
; 416  : 	code = (LPBYTE)(size_t)Context->Eip;

  000f0	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  000f3	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  000f9	89 8d a0 fc ff
	ff		 mov	 DWORD PTR _code$[ebp], ecx

; 417  : #elif defined (_AMD64_)
; 418  : 	code = (LPBYTE)(size_t)Context->Rip;
; 419  : #endif // || defined (_IA64_)
; 420  : 
; 421  : 	// Create a filename to record the error information to.
; 422  : 	// Store it in the executable directory.
; 423  : 	if (GetModuleFileName(NULL, ModuleName, sizeof(ModuleName)) <= 0)

  000ff	68 04 01 00 00	 push	 260			; 00000104H
  00104	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _ModuleName$[ebp]
  0010a	50		 push	 eax
  0010b	6a 00		 push	 0
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  00113	85 c0		 test	 eax, eax
  00115	77 30		 ja	 SHORT $LN16@RecordExce

; 424  : 		ModuleName[0] = 0;

  00117	b8 01 00 00 00	 mov	 eax, 1
  0011c	6b c8 00	 imul	 ecx, eax, 0
  0011f	89 8d 20 f3 ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00125	81 bd 20 f3 ff
	ff 04 01 00 00	 cmp	 DWORD PTR $T3[ebp], 260	; 00000104H
  0012f	73 02		 jae	 SHORT $LN37@RecordExce
  00131	eb 06		 jmp	 SHORT $LN38@RecordExce
$LN37@RecordExce:
  00133	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00138	90		 npad	 1
$LN38@RecordExce:
  00139	8b 95 20 f3 ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  0013f	c6 84 15 d8 fe
	ff ff 00	 mov	 BYTE PTR _ModuleName$[ebp+edx], 0
$LN16@RecordExce:

; 425  : 	FilePart = GetFilePart(ModuleName);

  00147	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _ModuleName$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _GetFilePart
  00153	83 c4 04	 add	 esp, 4
  00156	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _FilePart$[ebp], eax

; 426  : 
; 427  : 	// Extract the file name portion and remove it's file extension. We'll
; 428  : 	// use that name shortly.
; 429  : 	lstrcpy(FileName, FilePart);

  0015c	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _FilePart$[ebp]
  00162	50		 push	 eax
  00163	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _FileName$[ebp]
  00169	51		 push	 ecx
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  00170	90		 npad	 1

; 430  : 	lastperiod = _tcsrchr(FileName, '.');

  00171	6a 2e		 push	 46			; 0000002eH
  00173	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _FileName$[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _strrchr
  0017f	83 c4 08	 add	 esp, 8
  00182	89 85 cc fd ff
	ff		 mov	 DWORD PTR _lastperiod$[ebp], eax

; 431  : 	if (lastperiod)

  00188	83 bd cc fd ff
	ff 00		 cmp	 DWORD PTR _lastperiod$[ebp], 0
  0018f	74 12		 je	 SHORT $LN17@RecordExce

; 432  : 		lastperiod[0] = 0;

  00191	b8 01 00 00 00	 mov	 eax, 1
  00196	6b c8 00	 imul	 ecx, eax, 0
  00199	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _lastperiod$[ebp]
  0019f	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
$LN17@RecordExce:

; 433  : 	// Replace the executable filename with our error log file name.
; 434  : 	lstrcpy(FilePart, TEXT("errorlog.txt"));

  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BHIHAFGJ@errorlog?4txt@
  001a8	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _FilePart$[ebp]
  001ae	50		 push	 eax
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
  001b5	90		 npad	 1

; 435  : 	fileHandle = CreateFile(ModuleName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,

  001b6	6a 00		 push	 0
  001b8	68 80 00 00 80	 push	 -2147483520		; 80000080H
  001bd	6a 04		 push	 4
  001bf	6a 00		 push	 0
  001c1	6a 00		 push	 0
  001c3	68 00 00 00 40	 push	 1073741824		; 40000000H
  001c8	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _ModuleName$[ebp]
  001ce	50		 push	 eax
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  001d5	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _fileHandle$[ebp], eax

; 436  : 		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
; 437  : 	if (fileHandle == INVALID_HANDLE_VALUE)

  001db	83 bd a4 fc ff
	ff ff		 cmp	 DWORD PTR _fileHandle$[ebp], -1
  001e2	75 27		 jne	 SHORT $LN18@RecordExce

; 438  : 	{
; 439  : 		OutputDebugString(TEXT("Error creating exception report"));

  001e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MGJAALIN@Error?5creating?5exception?5report@
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  001ef	90		 npad	 1

; 440  : 		if (prevExceptionFilter)

  001f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _prevExceptionFilter, 0
  001f7	74 0b		 je	 SHORT $LN19@RecordExce

; 441  : 			prevExceptionFilter(data);

  001f9	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  001fc	50		 push	 eax
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR _prevExceptionFilter
  00203	90		 npad	 1
$LN19@RecordExce:

; 442  : 		return EXCEPTION_CONTINUE_SEARCH;

  00204	33 c0		 xor	 eax, eax
  00206	e9 9f 06 00 00	 jmp	 $LN41@RecordExce
$LN18@RecordExce:

; 443  : 	}
; 444  : 
; 445  : 	// Append to the error log.
; 446  : 	SetFilePointer(fileHandle, 0, 0, FILE_END);

  0020b	6a 02		 push	 2
  0020d	6a 00		 push	 0
  0020f	6a 00		 push	 0
  00211	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00217	50		 push	 eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  0021e	90		 npad	 1

; 447  : 
; 448  : 	// Print out some blank lines to separate this error log from any previous ones.
; 449  : 	FPrintf(fileHandle, "Email Sonic Team Junior so we can fix the bugs\r\n"); // Tails

  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@EPEEFCEA@Email?5Sonic?5Team?5Junior?5so?5we?5c@
  00224	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 _FPrintf
  00230	83 c4 08	 add	 esp, 8

; 450  : 	FPrintf(fileHandle, "Make sure you tell us what you were doing to cause the crash, and if possible, record a demo!\r\n"); // Tails

  00233	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JBOMNEPP@Make?5sure?5you?5tell?5us?5what?5you?5@
  00238	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 _FPrintf
  00244	83 c4 08	 add	 esp, 8

; 451  : 	FPrintf(fileHandle, "\r\n\r\n\r\n\r\n");

  00247	68 00 00 00 00	 push	 OFFSET ??_C@_08NMCPANGE@?$AN?6?$AN?6?$AN?6?$AN?6@
  0024c	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 _FPrintf
  00258	83 c4 08	 add	 esp, 8

; 452  : 	FPrintf(fileHandle, "SRB2%s -ERROR LOG-\r\n\r\n", VERSIONSTRING);

  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_07IJKPKDGN@?5v2?40?47@
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HFCEIAIB@SRB2?$CFs?5?9ERROR?5LOG?9?$AN?6?$AN?6@
  00265	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 _FPrintf
  00271	83 c4 0c	 add	 esp, 12			; 0000000cH

; 453  : 	FPrintf(fileHandle, "\r\n");

  00274	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@
  00279	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 _FPrintf
  00285	83 c4 08	 add	 esp, 8

; 454  : 	// VirtualQuery can be used to get the allocation base associated with a
; 455  : 	// code address, which is the same as the ModuleHandle. This can be used
; 456  : 	// to get the filename of the module that the crash happened in.
; 457  : 	if (code && VirtualQuery(code, &MemInfo, sizeof(MemInfo)) &&

  00288	83 bd a0 fc ff
	ff 00		 cmp	 DWORD PTR _code$[ebp], 0
  0028f	74 4c		 je	 SHORT $LN20@RecordExce
  00291	6a 1c		 push	 28			; 0000001cH
  00293	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR _MemInfo$[ebp]
  00299	50		 push	 eax
  0029a	8b 8d a0 fc ff
	ff		 mov	 ecx, DWORD PTR _code$[ebp]
  002a0	51		 push	 ecx
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualQuery@12
  002a7	85 c0		 test	 eax, eax
  002a9	74 32		 je	 SHORT $LN20@RecordExce
  002ab	68 04 01 00 00	 push	 260			; 00000104H
  002b0	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR _CrashModulePathName$[ebp]
  002b6	50		 push	 eax
  002b7	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR _MemInfo$[ebp+4]
  002bd	51		 push	 ecx
  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  002c4	85 c0		 test	 eax, eax
  002c6	76 15		 jbe	 SHORT $LN20@RecordExce

; 458  : 		GetModuleFileName((HMODULE)MemInfo.AllocationBase,
; 459  : 		                   CrashModulePathName,
; 460  : 		                   sizeof(CrashModulePathName)) > 0)
; 461  : 		CrashModuleFileName = GetFilePart(CrashModulePathName);

  002c8	8d 85 c8 fc ff
	ff		 lea	 eax, DWORD PTR _CrashModulePathName$[ebp]
  002ce	50		 push	 eax
  002cf	e8 00 00 00 00	 call	 _GetFilePart
  002d4	83 c4 04	 add	 esp, 4
  002d7	89 85 c4 fc ff
	ff		 mov	 DWORD PTR _CrashModuleFileName$[ebp], eax
$LN20@RecordExce:

; 462  : 
; 463  : 	// Print out the beginning of the error log in a Win95 error window
; 464  : 	// compatible format.
; 465  : #ifdef _X86_
; 466  : 	FPrintf(fileHandle, "%s caused %s in module %s at %04x:%08x.\r\n",

  002dd	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  002e0	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  002e6	51		 push	 ecx
  002e7	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  002ea	8b 82 bc 00 00
	00		 mov	 eax, DWORD PTR [edx+188]
  002f0	50		 push	 eax
  002f1	8b 8d c4 fc ff
	ff		 mov	 ecx, DWORD PTR _CrashModuleFileName$[ebp]
  002f7	51		 push	 ecx
  002f8	8b 55 e0	 mov	 edx, DWORD PTR _Exception$[ebp]
  002fb	8b 02		 mov	 eax, DWORD PTR [edx]
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 _GetExceptionDescription
  00303	83 c4 04	 add	 esp, 4
  00306	50		 push	 eax
  00307	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _FileName$[ebp]
  0030d	51		 push	 ecx
  0030e	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PECMEOFD@?$CFs?5caused?5?$CFs?5in?5module?5?$CFs?5at?5?$CF0@
  00313	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fileHandle$[ebp]
  00319	52		 push	 edx
  0031a	e8 00 00 00 00	 call	 _FPrintf
  0031f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 467  : 		FileName, GetExceptionDescription(Exception->ExceptionCode),
; 468  : 		CrashModuleFileName, Context->SegCs, Context->Eip);
; 469  : #elif defined (_AMD64_)
; 470  : 	FPrintf(fileHandle, "%s caused %s in module %s at %08x:%016x.\r\n",
; 471  : 		FileName, GetExceptionDescription(Exception->ExceptionCode),
; 472  : 		CrashModuleFileName, Context->SegCs, Context->Rip);
; 473  : #else //defined (_IA64_)
; 474  : 	FPrintf(fileHandle, "%s caused %s in module %s at ????.\r\n",
; 475  : 		FileName, GetExceptionDescription(Exception->ExceptionCode),
; 476  : 		CrashModuleFileName);
; 477  : #endif
; 478  : 	//if (&Message = Null)
; 479  : 		FPrintf(fileHandle, "Exception handler called in %s.\r\n", "main thread");

  00322	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NIEGMIHB@main?5thread@
  00327	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FLHHKNPN@Exception?5handler?5called?5in?5?$CFs?4@
  0032c	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 _FPrintf
  00338	83 c4 0c	 add	 esp, 12			; 0000000cH

; 480  : 	//else
; 481  : 		//FPrintf(fileHandle, "Exception handler called in %s.\r\n", Message);
; 482  : 
; 483  : 	RecordSystemInformation(fileHandle);

  0033b	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _RecordSystemInformation
  00347	83 c4 04	 add	 esp, 4

; 484  : 
; 485  : 	// If the exception was an access violation, print out some additional
; 486  : 	// information, to the error log and the debugger.
; 487  : 	if (Exception->ExceptionCode == STATUS_ACCESS_VIOLATION &&

  0034a	8b 45 e0	 mov	 eax, DWORD PTR _Exception$[ebp]
  0034d	81 38 05 00 00
	c0		 cmp	 DWORD PTR [eax], -1073741819 ; c0000005H
  00353	0f 85 94 00 00
	00		 jne	 $LN21@RecordExce
  00359	8b 45 e0	 mov	 eax, DWORD PTR _Exception$[ebp]
  0035c	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  00360	0f 82 87 00 00
	00		 jb	 $LN21@RecordExce

; 488  : 		Exception->NumberParameters >= 2)
; 489  : 	{
; 490  : 		TCHAR DebugMessage[1000];
; 491  : 		LPCTSTR readwrite = TEXT("Read from");

  00366	c7 85 ac f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _readwrite$12[ebp], OFFSET ??_C@_09JHOILLPP@Read?5from@

; 492  : 		if (Exception->ExceptionInformation[0])

  00370	b8 04 00 00 00	 mov	 eax, 4
  00375	6b c8 00	 imul	 ecx, eax, 0
  00378	8b 55 e0	 mov	 edx, DWORD PTR _Exception$[ebp]
  0037b	83 7c 0a 14 00	 cmp	 DWORD PTR [edx+ecx+20], 0
  00380	74 0a		 je	 SHORT $LN22@RecordExce

; 493  : 			readwrite = TEXT("Write to");

  00382	c7 85 ac f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _readwrite$12[ebp], OFFSET ??_C@_08CPFAPHAF@Write?5to@
$LN22@RecordExce:

; 494  : 		wsprintf(DebugMessage, TEXT("%s location %08x caused an access violation.\r\n"),

  0038c	b8 04 00 00 00	 mov	 eax, 4
  00391	c1 e0 00	 shl	 eax, 0
  00394	8b 4d e0	 mov	 ecx, DWORD PTR _Exception$[ebp]
  00397	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  0039b	52		 push	 edx
  0039c	8b 85 ac f8 ff
	ff		 mov	 eax, DWORD PTR _readwrite$12[ebp]
  003a2	50		 push	 eax
  003a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@PADPOHII@?$CFs?5location?5?$CF08x?5caused?5an?5acce@
  003a8	8d 8d b0 f8 ff
	ff		 lea	 ecx, DWORD PTR _DebugMessage$13[ebp]
  003ae	51		 push	 ecx
  003af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  003b5	83 c4 10	 add	 esp, 16			; 00000010H

; 495  : 			readwrite, Exception->ExceptionInformation[1]);
; 496  : 		// The VisualC++ debugger doesn't actually tell you whether a read
; 497  : 		// or a write caused the access violation, nor does it tell what
; 498  : 		// address was being read or written. So I fixed that.
; 499  : 		OutputDebugString(TEXT("Exception handler: "));

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GKJKFFJO@Exception?5handler?3?5@
  003bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  003c3	90		 npad	 1

; 500  : 		OutputDebugString(DebugMessage);

  003c4	8d 85 b0 f8 ff
	ff		 lea	 eax, DWORD PTR _DebugMessage$13[ebp]
  003ca	50		 push	 eax
  003cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4
  003d1	90		 npad	 1

; 501  : 		FPrintf(fileHandle, "%s", DebugMessage);

  003d2	8d 85 b0 f8 ff
	ff		 lea	 eax, DWORD PTR _DebugMessage$13[ebp]
  003d8	50		 push	 eax
  003d9	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  003de	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _fileHandle$[ebp]
  003e4	51		 push	 ecx
  003e5	e8 00 00 00 00	 call	 _FPrintf
  003ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@RecordExce:

; 502  : 	}
; 503  : 
; 504  : 	FPrintf(fileHandle, "\r\n");

  003ed	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@
  003f2	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 _FPrintf
  003fe	83 c4 08	 add	 esp, 8

; 505  : 
; 506  : 	// Print out the register values in a Win95 error window compatible format.
; 507  : 	if ((Context->ContextFlags & CONTEXT_FULL) == CONTEXT_FULL)

  00401	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  00404	8b 08		 mov	 ecx, DWORD PTR [eax]
  00406	81 e1 07 00 01
	00		 and	 ecx, 65543		; 00010007H
  0040c	81 f9 07 00 01
	00		 cmp	 ecx, 65543		; 00010007H
  00412	0f 85 04 01 00
	00		 jne	 $LN23@RecordExce

; 508  : 	{
; 509  : 		FPrintf(fileHandle, "Registers:\r\n");

  00418	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NADCNKKP@Registers?3?$AN?6@
  0041d	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 _FPrintf
  00429	83 c4 08	 add	 esp, 8

; 510  : #ifdef _X86_
; 511  : 		FPrintf(fileHandle, "EAX=%.8lx CS=%.4x EIP=%.8lx EFLGS=%.8lx\r\n",

  0042c	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  0042f	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  00435	51		 push	 ecx
  00436	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  00439	8b 82 b8 00 00
	00		 mov	 eax, DWORD PTR [edx+184]
  0043f	50		 push	 eax
  00440	8b 4d dc	 mov	 ecx, DWORD PTR _Context$[ebp]
  00443	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  00449	52		 push	 edx
  0044a	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  0044d	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00453	51		 push	 ecx
  00454	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BAALCHIJ@EAX?$DN?$CF?48lx?5CS?$DN?$CF?44x?5EIP?$DN?$CF?48lx?5EFL@
  00459	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fileHandle$[ebp]
  0045f	52		 push	 edx
  00460	e8 00 00 00 00	 call	 _FPrintf
  00465	83 c4 18	 add	 esp, 24			; 00000018H

; 512  : 			Context->Eax,Context->SegCs,Context->Eip,Context->EFlags);
; 513  : 		FPrintf(fileHandle, "EBX=%.8lx SS=%.4x ESP=%.8lx EBP=%.8lx\r\n",

  00468	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  0046b	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR [eax+180]
  00471	51		 push	 ecx
  00472	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  00475	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  0047b	50		 push	 eax
  0047c	8b 4d dc	 mov	 ecx, DWORD PTR _Context$[ebp]
  0047f	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00485	52		 push	 edx
  00486	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  00489	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0048f	51		 push	 ecx
  00490	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DHBMJANE@EBX?$DN?$CF?48lx?5SS?$DN?$CF?44x?5ESP?$DN?$CF?48lx?5EBP@
  00495	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fileHandle$[ebp]
  0049b	52		 push	 edx
  0049c	e8 00 00 00 00	 call	 _FPrintf
  004a1	83 c4 18	 add	 esp, 24			; 00000018H

; 514  : 			Context->Ebx,Context->SegSs,Context->Esp,Context->Ebp);
; 515  : 		FPrintf(fileHandle, "ECX=%.8lx DS=%.4x ESI=%.8lx FS=%.4x\r\n",

  004a4	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  004a7	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  004ad	51		 push	 ecx
  004ae	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  004b1	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  004b7	50		 push	 eax
  004b8	8b 4d dc	 mov	 ecx, DWORD PTR _Context$[ebp]
  004bb	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  004c1	52		 push	 edx
  004c2	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  004c5	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  004cb	51		 push	 ecx
  004cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DNBFEJGL@ECX?$DN?$CF?48lx?5DS?$DN?$CF?44x?5ESI?$DN?$CF?48lx?5FS?$DN@
  004d1	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fileHandle$[ebp]
  004d7	52		 push	 edx
  004d8	e8 00 00 00 00	 call	 _FPrintf
  004dd	83 c4 18	 add	 esp, 24			; 00000018H

; 516  : 			Context->Ecx,Context->SegDs,Context->Esi,Context->SegFs);
; 517  : 		FPrintf(fileHandle, "EDX=%.8lx ES=%.4x EDI=%.8lx GS=%.4x\r\n",

  004e0	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  004e3	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  004e9	51		 push	 ecx
  004ea	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  004ed	8b 82 9c 00 00
	00		 mov	 eax, DWORD PTR [edx+156]
  004f3	50		 push	 eax
  004f4	8b 4d dc	 mov	 ecx, DWORD PTR _Context$[ebp]
  004f7	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  004fd	52		 push	 edx
  004fe	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  00501	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00507	51		 push	 ecx
  00508	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LOCMAGNG@EDX?$DN?$CF?48lx?5ES?$DN?$CF?44x?5EDI?$DN?$CF?48lx?5GS?$DN@
  0050d	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fileHandle$[ebp]
  00513	52		 push	 edx
  00514	e8 00 00 00 00	 call	 _FPrintf
  00519	83 c4 18	 add	 esp, 24			; 00000018H
$LN23@RecordExce:

; 518  : 			Context->Edx,Context->SegEs,Context->Edi,Context->SegGs);
; 519  : #elif defined (_AMD64_)
; 520  : 		FPrintf(fileHandle, "RAX=%.16lx CS=%.8x RIP=%.16lx EFLGS=%.16lx\r\n",
; 521  : 			Context->Rax,Context->SegCs,Context->Rip,Context->EFlags);
; 522  : 		FPrintf(fileHandle, "RBX=%.16lx SS=%.8x RSP=%.16lx EBP=%.16lx\r\n",
; 523  : 			Context->Rbx,Context->SegSs,Context->Rsp,Context->Rbp);
; 524  : 		FPrintf(fileHandle, "RCX=%.16lx DS=%.8x RSI=%.16lx FS=%.8x\r\n",
; 525  : 			Context->Rcx,Context->SegDs,Context->Rsi,Context->SegFs);
; 526  : 		FPrintf(fileHandle, "RDX=%.16lx ES=%.8x RDI=%.16lx GS=%.8x\r\n",
; 527  : 			Context->Rdx,Context->SegEs,Context->Rdi,Context->SegGs);
; 528  : #else //defined (_IA64_)
; 529  : 		FPrintf(fileHandle, "Unknown CPU type\r\n");
; 530  : #endif
; 531  : 	}
; 532  : 
; 533  : 	// moved down because it was causing the printout to stop
; 534  : 	FPrintf(fileHandle, "Command Line parameters: ");

  0051c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OAKBNDJP@Command?5Line?5parameters?3?5@
  00521	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00527	50		 push	 eax
  00528	e8 00 00 00 00	 call	 _FPrintf
  0052d	83 c4 08	 add	 esp, 8

; 535  : 	for(i = 1;i < myargc;i++)

  00530	c7 85 98 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _i$[ebp], 1
  0053a	eb 0f		 jmp	 SHORT $LN4@RecordExce
$LN2@RecordExce:
  0053c	8b 85 98 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00542	83 c0 01	 add	 eax, 1
  00545	89 85 98 fc ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@RecordExce:
  0054b	8b 85 98 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00551	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  00557	7d 26		 jge	 SHORT $LN3@RecordExce

; 536  : 		FPrintf(fileHandle, "%s ", myargv[i]);

  00559	8b 85 98 fc ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0055f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  00565	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00568	52		 push	 edx
  00569	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5@
  0056e	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00574	50		 push	 eax
  00575	e8 00 00 00 00	 call	 _FPrintf
  0057a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0057d	eb bd		 jmp	 SHORT $LN2@RecordExce
$LN3@RecordExce:

; 537  : 
; 538  : 	FPrintf(fileHandle, "Bytes at CS : EIP:\r\n");

  0057f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FABNJKDP@Bytes?5at?5CS?5?3?5EIP?3?$AN?6@
  00584	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0058a	50		 push	 eax
  0058b	e8 00 00 00 00	 call	 _FPrintf
  00590	83 c4 08	 add	 esp, 8

; 539  : 
; 540  : 	// Print out the bytes of code at the instruction pointer. Since the
; 541  : 	// crash may have been caused by an instruction pointer that was bad,
; 542  : 	// this code needs to be wrapped in an exception handler, in case there
; 543  : 	// is no memory to read. If the dereferencing of code[] fails, the
; 544  : 	// exception handler will print '??'.
; 545  : 	if (code)

  00593	83 bd a0 fc ff
	ff 00		 cmp	 DWORD PTR _code$[ebp], 0
  0059a	74 7e		 je	 SHORT $LN24@RecordExce

; 546  : 	for(codebyte = 0; codebyte < NumCodeBytes; codebyte++)

  0059c	c7 85 9c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _codebyte$[ebp], 0
  005a6	eb 0f		 jmp	 SHORT $LN7@RecordExce
$LN5@RecordExce:
  005a8	8b 85 9c fc ff
	ff		 mov	 eax, DWORD PTR _codebyte$[ebp]
  005ae	83 c0 01	 add	 eax, 1
  005b1	89 85 9c fc ff
	ff		 mov	 DWORD PTR _codebyte$[ebp], eax
$LN7@RecordExce:
  005b7	83 bd 9c fc ff
	ff 10		 cmp	 DWORD PTR _codebyte$[ebp], 16 ; 00000010H
  005be	7d 5a		 jge	 SHORT $LN24@RecordExce

; 547  : 	{
; 548  : #ifdef NO_SEH_MINGW
; 549  : 		__try1(EXCEPTION_EXECUTE_HANDLER)
; 550  : #else
; 551  : 		__try

  005c0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 552  : #endif
; 553  : 		{
; 554  : 			FPrintf(fileHandle, "%02x ", code[codebyte]);

  005c7	8b 85 a0 fc ff
	ff		 mov	 eax, DWORD PTR _code$[ebp]
  005cd	03 85 9c fc ff
	ff		 add	 eax, DWORD PTR _codebyte$[ebp]
  005d3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  005d6	51		 push	 ecx
  005d7	68 00 00 00 00	 push	 OFFSET ??_C@_05CNDJFPDP@?$CF02x?5@
  005dc	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _fileHandle$[ebp]
  005e2	52		 push	 edx
  005e3	e8 00 00 00 00	 call	 _FPrintf
  005e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 555  : 		}

  005eb	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  005f2	eb 24		 jmp	 SHORT $LN45@RecordExce
$LN42@RecordExce:
$LN52@RecordExce:

; 556  : #ifdef NO_SEH_MINGW
; 557  : 		__except1
; 558  : #else
; 559  : 		__except(EXCEPTION_EXECUTE_HANDLER)

  005f4	b8 01 00 00 00	 mov	 eax, 1
$LN44@RecordExce:
$LN50@RecordExce:
  005f9	c3		 ret	 0
$LN43@RecordExce:
  005fa	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 560  : #endif
; 561  : 		{
; 562  : 			FPrintf(fileHandle, "?? ");

  005fd	68 00 00 00 00	 push	 OFFSET ??_C@_03MMEAEOBL@?$DP?$DP?5@
  00602	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00608	50		 push	 eax
  00609	e8 00 00 00 00	 call	 _FPrintf
  0060e	83 c4 08	 add	 esp, 8

; 555  : 		}

  00611	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN45@RecordExce:

; 563  : 		}
; 564  : 	}

  00618	eb 8e		 jmp	 SHORT $LN5@RecordExce
$LN24@RecordExce:

; 565  : 
; 566  : 	// Time to print part or all of the stack to the error log. This allows
; 567  : 	// us to figure out the call stack, parameters, local variables, etc.
; 568  : 	FPrintf(fileHandle, "\r\n"

  0061a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EHPJBAFB@?$AN?6Stack?5dump?3?$AN?6@
  0061f	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00625	50		 push	 eax
  00626	e8 00 00 00 00	 call	 _FPrintf
  0062b	83 c4 08	 add	 esp, 8

; 569  : 		"Stack dump:\r\n");
; 570  : #ifdef NO_SEH_MINGW
; 571  : 	__try1(EXCEPTION_EXECUTE_HANDLER)
; 572  : #else
; 573  : 	__try

  0062e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 1

; 574  : #endif
; 575  : 	{
; 576  : 		// Esp contains the bottom of the stack, or at least the bottom of
; 577  : 		// the currently used area.
; 578  : 		LPDWORD   pStack = NULL;

  00635	c7 85 a8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pStack$11[ebp], 0

; 579  : 		LPDWORD   pStackTop = NULL;

  0063f	c7 85 a4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pStackTop$10[ebp], 0

; 580  : 		size_t    Count = 0;

  00649	c7 85 a0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _Count$9[ebp], 0

; 581  : 		TCHAR     buffer[1000] = TEXT("");

  00653	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  00658	88 85 b4 f4 ff
	ff		 mov	 BYTE PTR _buffer$8[ebp], al
  0065e	68 e7 03 00 00	 push	 999			; 000003e7H
  00663	6a 00		 push	 0
  00665	8d 85 b5 f4 ff
	ff		 lea	 eax, DWORD PTR _buffer$8[ebp+1]
  0066b	50		 push	 eax
  0066c	e8 00 00 00 00	 call	 _memset
  00671	83 c4 0c	 add	 esp, 12			; 0000000cH

; 582  : 		const int safetyzone = 50;

  00674	c7 85 b0 f4 ff
	ff 32 00 00 00	 mov	 DWORD PTR _safetyzone$7[ebp], 50 ; 00000032H

; 583  : 		LPTSTR    nearend = buffer + sizeof(buffer) - safetyzone*sizeof(TCHAR);

  0067e	8d 85 9c f8 ff
	ff		 lea	 eax, DWORD PTR _buffer$8[ebp+1000]
  00684	2b 85 b0 f4 ff
	ff		 sub	 eax, DWORD PTR _safetyzone$7[ebp]
  0068a	89 85 ac f4 ff
	ff		 mov	 DWORD PTR _nearend$6[ebp], eax

; 584  : 		LPTSTR    output = buffer;

  00690	8d 85 b4 f4 ff
	ff		 lea	 eax, DWORD PTR _buffer$8[ebp]
  00696	89 85 a8 f4 ff
	ff		 mov	 DWORD PTR _output$5[ebp], eax

; 585  : 		LPCVOID   Suffix;
; 586  : 
; 587  : #ifdef _X86_
; 588  : 		pStack = (LPDWORD)(size_t)Context->Esp;

  0069c	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  0069f	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  006a5	89 8d a8 f8 ff
	ff		 mov	 DWORD PTR _pStack$11[ebp], ecx

; 589  : #elif defined (_AMD64_)
; 590  : 		pStack = (LPDWORD)(size_t)Context->Rsp;
; 591  : #endif // defined (_IA64_)
; 592  : 
; 593  : 
; 594  : 		// Load the top (highest address) of the stack from the
; 595  : 		// thread information block. It will be found there in
; 596  : 		// Win9x and Windows NT.
; 597  : #ifdef _X86_
; 598  : #ifdef __GNUC__
; 599  : 		__asm__("movl %%fs : 4, %%eax": "=a"(pStackTop));
; 600  : #elif defined (_MSC_VER)
; 601  : 		__asm
; 602  : 		{
; 603  : 			mov eax, fs:[4]

  006ab	64 a1 04 00 00
	00		 mov	 eax, DWORD PTR fs:4

; 604  : 			mov pStackTop, eax

  006b1	89 85 a4 f8 ff
	ff		 mov	 DWORD PTR _pStackTop$10[ebp], eax

; 605  : 		}
; 606  : #endif
; 607  : #elif defined (_AMD64_)
; 608  : #ifdef __GNUC__
; 609  : 		__asm__("mov %%gs : 4, %%rax": "=a"(pStackTop));
; 610  : #elif defined (_MSC_VER)
; 611  : /*
; 612  : 		__asm
; 613  : 		{
; 614  : 			mov rax, fs:[4]
; 615  : 			mov pStackTop, rax
; 616  : 		}
; 617  : */
; 618  : #endif
; 619  : #endif
; 620  : 		if (pStackTop == NULL)

  006b7	83 bd a4 f8 ff
	ff 00		 cmp	 DWORD PTR _pStackTop$10[ebp], 0
  006be	75 07		 jne	 SHORT $LN27@RecordExce

; 621  : 			goto StackSkip;

  006c0	e9 69 01 00 00	 jmp	 $StackSkip$54
  006c5	eb 24		 jmp	 SHORT $LN8@RecordExce
$LN27@RecordExce:

; 622  : 		else if (pStackTop > pStack + MaxStackDump)

  006c7	8b 85 a8 f8 ff
	ff		 mov	 eax, DWORD PTR _pStack$11[ebp]
  006cd	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  006d2	39 85 a4 f8 ff
	ff		 cmp	 DWORD PTR _pStackTop$10[ebp], eax
  006d8	76 11		 jbe	 SHORT $LN8@RecordExce

; 623  : 			pStackTop = pStack + MaxStackDump;

  006da	8b 85 a8 f8 ff
	ff		 mov	 eax, DWORD PTR _pStack$11[ebp]
  006e0	05 00 20 00 00	 add	 eax, 8192		; 00002000H
  006e5	89 85 a4 f8 ff
	ff		 mov	 DWORD PTR _pStackTop$10[ebp], eax
$LN8@RecordExce:

; 624  : 		// Too many calls to WriteFile can take a long time, causing
; 625  : 		// confusing delays when programs crash. Therefore I implemented
; 626  : 		// simple buffering for the stack dumping code instead of calling
; 627  : 		// FPrintf directly.
; 628  : 		while(pStack + 1 <= pStackTop)

  006eb	8b 85 a8 f8 ff
	ff		 mov	 eax, DWORD PTR _pStack$11[ebp]
  006f1	83 c0 04	 add	 eax, 4
  006f4	3b 85 a4 f8 ff
	ff		 cmp	 eax, DWORD PTR _pStackTop$10[ebp]
  006fa	0f 87 2e 01 00
	00		 ja	 $StackSkip$54

; 629  : 		{
; 630  : 			if ((Count % StackColumns) == 0)

  00700	8b 85 a0 f8 ff
	ff		 mov	 eax, DWORD PTR _Count$9[ebp]
  00706	33 d2		 xor	 edx, edx
  00708	b9 08 00 00 00	 mov	 ecx, 8
  0070d	f7 f1		 div	 ecx
  0070f	85 d2		 test	 edx, edx
  00711	75 28		 jne	 SHORT $LN30@RecordExce

; 631  : 				output += wsprintf(output, TEXT("%08x: "), pStack);

  00713	8b 85 a8 f8 ff
	ff		 mov	 eax, DWORD PTR _pStack$11[ebp]
  00719	50		 push	 eax
  0071a	68 00 00 00 00	 push	 OFFSET ??_C@_06HIMOAOMH@?$CF08x?3?5@
  0071f	8b 8d a8 f4 ff
	ff		 mov	 ecx, DWORD PTR _output$5[ebp]
  00725	51		 push	 ecx
  00726	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0072c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0072f	03 85 a8 f4 ff
	ff		 add	 eax, DWORD PTR _output$5[ebp]
  00735	89 85 a8 f4 ff
	ff		 mov	 DWORD PTR _output$5[ebp], eax
$LN30@RecordExce:

; 632  : 			if ((++Count % StackColumns) == 0 || pStack + 2 > pStackTop)

  0073b	8b 85 a0 f8 ff
	ff		 mov	 eax, DWORD PTR _Count$9[ebp]
  00741	83 c0 01	 add	 eax, 1
  00744	89 85 a0 f8 ff
	ff		 mov	 DWORD PTR _Count$9[ebp], eax
  0074a	8b 85 a0 f8 ff
	ff		 mov	 eax, DWORD PTR _Count$9[ebp]
  00750	33 d2		 xor	 edx, edx
  00752	b9 08 00 00 00	 mov	 ecx, 8
  00757	f7 f1		 div	 ecx
  00759	85 d2		 test	 edx, edx
  0075b	74 11		 je	 SHORT $LN33@RecordExce
  0075d	8b 85 a8 f8 ff
	ff		 mov	 eax, DWORD PTR _pStack$11[ebp]
  00763	83 c0 08	 add	 eax, 8
  00766	3b 85 a4 f8 ff
	ff		 cmp	 eax, DWORD PTR _pStackTop$10[ebp]
  0076c	76 0c		 jbe	 SHORT $LN31@RecordExce
$LN33@RecordExce:

; 633  : 				Suffix = TEXT("\r\n");

  0076e	c7 85 a4 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR _Suffix$4[ebp], OFFSET ??_C@_02PCIJFNDE@?$AN?6@
  00778	eb 0a		 jmp	 SHORT $LN32@RecordExce
$LN31@RecordExce:

; 634  : 			else
; 635  : 				Suffix = TEXT(" ");

  0077a	c7 85 a4 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR _Suffix$4[ebp], OFFSET ??_C@_01CLKCMJKC@?5@
$LN32@RecordExce:

; 636  : 			output += wsprintf(output, TEXT("%08x%s"), *pStack, Suffix);

  00784	8b 85 a4 f4 ff
	ff		 mov	 eax, DWORD PTR _Suffix$4[ebp]
  0078a	50		 push	 eax
  0078b	8b 8d a8 f8 ff
	ff		 mov	 ecx, DWORD PTR _pStack$11[ebp]
  00791	8b 11		 mov	 edx, DWORD PTR [ecx]
  00793	52		 push	 edx
  00794	68 00 00 00 00	 push	 OFFSET ??_C@_06POCCOEBN@?$CF08x?$CFs@
  00799	8b 85 a8 f4 ff
	ff		 mov	 eax, DWORD PTR _output$5[ebp]
  0079f	50		 push	 eax
  007a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  007a6	83 c4 10	 add	 esp, 16			; 00000010H
  007a9	03 85 a8 f4 ff
	ff		 add	 eax, DWORD PTR _output$5[ebp]
  007af	89 85 a8 f4 ff
	ff		 mov	 DWORD PTR _output$5[ebp], eax

; 637  : 			pStack++;

  007b5	8b 85 a8 f8 ff
	ff		 mov	 eax, DWORD PTR _pStack$11[ebp]
  007bb	83 c0 04	 add	 eax, 4
  007be	89 85 a8 f8 ff
	ff		 mov	 DWORD PTR _pStack$11[ebp], eax

; 638  : 			// Check for when the buffer is almost full, and flush it to disk.
; 639  : 			if ( output > nearend)

  007c4	8b 85 a8 f4 ff
	ff		 mov	 eax, DWORD PTR _output$5[ebp]
  007ca	3b 85 ac f4 ff
	ff		 cmp	 eax, DWORD PTR _nearend$6[ebp]
  007d0	76 57		 jbe	 SHORT $LN34@RecordExce

; 640  : 			{
; 641  : 				FPrintf(fileHandle, "%s", buffer);

  007d2	8d 85 b4 f4 ff
	ff		 lea	 eax, DWORD PTR _buffer$8[ebp]
  007d8	50		 push	 eax
  007d9	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  007de	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _fileHandle$[ebp]
  007e4	51		 push	 ecx
  007e5	e8 00 00 00 00	 call	 _FPrintf
  007ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 642  : 				buffer[0] = 0;

  007ed	b8 01 00 00 00	 mov	 eax, 1
  007f2	6b c8 00	 imul	 ecx, eax, 0
  007f5	89 8d 1c f3 ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  007fb	81 bd 1c f3 ff
	ff e8 03 00 00	 cmp	 DWORD PTR $T2[ebp], 1000 ; 000003e8H
  00805	73 02		 jae	 SHORT $LN39@RecordExce
  00807	eb 06		 jmp	 SHORT $LN40@RecordExce
$LN39@RecordExce:
  00809	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  0080e	90		 npad	 1
$LN40@RecordExce:
  0080f	8b 95 1c f3 ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00815	c6 84 15 b4 f4
	ff ff 00	 mov	 BYTE PTR _buffer$8[ebp+edx], 0

; 643  : 				output = buffer;

  0081d	8d 85 b4 f4 ff
	ff		 lea	 eax, DWORD PTR _buffer$8[ebp]
  00823	89 85 a8 f4 ff
	ff		 mov	 DWORD PTR _output$5[ebp], eax
$LN34@RecordExce:

; 644  : 			}
; 645  : 		}

  00829	e9 bd fe ff ff	 jmp	 $LN8@RecordExce
$StackSkip$54:

; 646  : 		// Print out any final characters from the cache.
; 647  : 		StackSkip:
; 648  : 		FPrintf(fileHandle, "%s", buffer);

  0082e	8d 85 b4 f4 ff
	ff		 lea	 eax, DWORD PTR _buffer$8[ebp]
  00834	50		 push	 eax
  00835	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0083a	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _fileHandle$[ebp]
  00840	51		 push	 ecx
  00841	e8 00 00 00 00	 call	 _FPrintf
  00846	83 c4 0c	 add	 esp, 12			; 0000000cH

; 649  : 	}

  00849	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00850	eb 24		 jmp	 SHORT $LN49@RecordExce
$LN46@RecordExce:
$LN53@RecordExce:

; 650  : #ifdef NO_SEH_MINGW
; 651  : 	__except1
; 652  : #else
; 653  : 	__except(EXCEPTION_EXECUTE_HANDLER)

  00852	b8 01 00 00 00	 mov	 eax, 1
$LN48@RecordExce:
$LN51@RecordExce:
  00857	c3		 ret	 0
$LN47@RecordExce:
  00858	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 654  : #endif
; 655  : 	{
; 656  : 		FPrintf(fileHandle, "Exception encountered during stack dump.\r\n");

  0085b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@OMKINDCC@Exception?5encountered?5during?5st@
  00860	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  00866	50		 push	 eax
  00867	e8 00 00 00 00	 call	 _FPrintf
  0086c	83 c4 08	 add	 esp, 8

; 649  : 	}

  0086f	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN49@RecordExce:

; 657  : 	}
; 658  : 
; 659  : 	RecordModuleList(fileHandle);

  00876	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0087c	50		 push	 eax
  0087d	e8 00 00 00 00	 call	 _RecordModuleList
  00882	83 c4 04	 add	 esp, 4

; 660  : 
; 661  : 	CloseHandle(fileHandle);

  00885	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _fileHandle$[ebp]
  0088b	50		 push	 eax
  0088c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00892	90		 npad	 1

; 662  : 
; 663  : 	// Return the magic value which tells Win32 that this handler didn't
; 664  : 	// actually handle the exception - so that things will proceed as per
; 665  : 	// normal.
; 666  : 	//BP: should put message for end user to send this file to fix any bug
; 667  : 	if (prevExceptionFilter)

  00893	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _prevExceptionFilter, 0
  0089a	74 0c		 je	 SHORT $LN35@RecordExce

; 668  : 		return prevExceptionFilter(data);

  0089c	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0089f	50		 push	 eax
  008a0	ff 15 00 00 00
	00		 call	 DWORD PTR _prevExceptionFilter
  008a6	eb 02		 jmp	 SHORT $LN41@RecordExce
$LN35@RecordExce:

; 669  : 	return EXCEPTION_CONTINUE_SEARCH;

  008a8	33 c0		 xor	 eax, eax
$LN41@RecordExce:

; 670  : }

  008aa	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  008ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  008b4	59		 pop	 ecx
  008b5	5f		 pop	 edi
  008b6	5e		 pop	 esi
  008b7	5b		 pop	 ebx
  008b8	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008bb	33 cd		 xor	 ecx, ebp
  008bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008c2	8b e5		 mov	 esp, ebp
  008c4	5d		 pop	 ebp
  008c5	c2 04 00	 ret	 4
_RecordExceptionInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1474 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1475 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
