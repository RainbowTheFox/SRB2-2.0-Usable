; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\v_video.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_gammatable
PUBLIC	_cv_ticrate
PUBLIC	_cv_usegamma
PUBLIC	_cv_allcaps
PUBLIC	_pLocalPalette
PUBLIC	_cv_grrenderquality
PUBLIC	_cv_grfog
PUBLIC	_cv_grfogcolor
PUBLIC	_cv_grsoftwarefog
PUBLIC	_cv_grgammared
PUBLIC	_cv_grgammagreen
PUBLIC	_cv_grgammablue
PUBLIC	_cv_grfovchange
PUBLIC	??_C@_03GCDBBDDL@Off@				; `string'
PUBLIC	??_C@_07IKJEKJLO@Counter@			; `string'
PUBLIC	??_C@_05KFDNMOLO@Graph@				; `string'
PUBLIC	??_C@_04IGHHMFLN@Both@				; `string'
PUBLIC	??_C@_03KGHEHEMH@MIN@				; `string'
PUBLIC	??_C@_03LEPPJAKI@MAX@				; `string'
PUBLIC	??_C@_0M@OCINAIJL@vid_ticrate@			; `string'
PUBLIC	??_C@_05KDLBCAI@gamma@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_07LIFHLGJN@allcaps@			; `string'
PUBLIC	??_C@_05HOIAGEJD@Speed@				; `string'
PUBLIC	??_C@_07MJEANAEL@Quality@			; `string'
PUBLIC	??_C@_0N@BBHDJDJA@Full?5Quality@		; `string'
PUBLIC	??_C@_02IAAGKKDJ@On@				; `string'
PUBLIC	??_C@_0M@PAGBDCG@LightPlanes@			; `string'
PUBLIC	??_C@_0BA@GGIJLIJJ@gr_renderdetail@		; `string'
PUBLIC	??_C@_0N@OBGALGGC@gr_fovchange@			; `string'
PUBLIC	??_C@_06KHFBHPJI@gr_fog@			; `string'
PUBLIC	??_C@_0M@OEGCPAAI@gr_fogcolor@			; `string'
PUBLIC	??_C@_06JKOKFAJH@AAAAAA@			; `string'
PUBLIC	??_C@_0P@NOLAKGNE@gr_softwarefog@		; `string'
PUBLIC	??_C@_0M@GGBAGGIL@gr_gammared@			; `string'
PUBLIC	??_C@_03CBMECOON@127@				; `string'
PUBLIC	??_C@_0O@PAKDBDMA@gr_gammagreen@		; `string'
PUBLIC	??_C@_0N@GCIKMEGD@gr_gammablue@			; `string'
PUBLIC	_heatshifter
PUBLIC	_lastheight
PUBLIC	_heatindex
EXTRN	_CV_OnOff:BYTE
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_screens:DWORD:05H
_DATA	ENDS
_BSS	SEGMENT
_pLocalPalette DD 01H DUP (?)
_heatshifter DD	01H DUP (?)
_lastheight DD	01H DUP (?)
_heatindex DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@GCIKMEGD@gr_gammablue@
CONST	SEGMENT
??_C@_0N@GCIKMEGD@gr_gammablue@ DB 'gr_gammablue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PAKDBDMA@gr_gammagreen@
CONST	SEGMENT
??_C@_0O@PAKDBDMA@gr_gammagreen@ DB 'gr_gammagreen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CBMECOON@127@
CONST	SEGMENT
??_C@_03CBMECOON@127@ DB '127', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGBAGGIL@gr_gammared@
CONST	SEGMENT
??_C@_0M@GGBAGGIL@gr_gammared@ DB 'gr_gammared', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NOLAKGNE@gr_softwarefog@
CONST	SEGMENT
??_C@_0P@NOLAKGNE@gr_softwarefog@ DB 'gr_softwarefog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JKOKFAJH@AAAAAA@
CONST	SEGMENT
??_C@_06JKOKFAJH@AAAAAA@ DB 'AAAAAA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEGCPAAI@gr_fogcolor@
CONST	SEGMENT
??_C@_0M@OEGCPAAI@gr_fogcolor@ DB 'gr_fogcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KHFBHPJI@gr_fog@
CONST	SEGMENT
??_C@_06KHFBHPJI@gr_fog@ DB 'gr_fog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBGALGGC@gr_fovchange@
CONST	SEGMENT
??_C@_0N@OBGALGGC@gr_fovchange@ DB 'gr_fovchange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGIJLIJJ@gr_renderdetail@
CONST	SEGMENT
??_C@_0BA@GGIJLIJJ@gr_renderdetail@ DB 'gr_renderdetail', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PAGBDCG@LightPlanes@
CONST	SEGMENT
??_C@_0M@PAGBDCG@LightPlanes@ DB 'LightPlanes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBHDJDJA@Full?5Quality@
CONST	SEGMENT
??_C@_0N@BBHDJDJA@Full?5Quality@ DB 'Full Quality', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MJEANAEL@Quality@
CONST	SEGMENT
??_C@_07MJEANAEL@Quality@ DB 'Quality', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HOIAGEJD@Speed@
CONST	SEGMENT
??_C@_05HOIAGEJD@Speed@ DB 'Speed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIFHLGJN@allcaps@
CONST	SEGMENT
??_C@_07LIFHLGJN@allcaps@ DB 'allcaps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDLBCAI@gamma@
CONST	SEGMENT
??_C@_05KDLBCAI@gamma@ DB 'gamma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCINAIJL@vid_ticrate@
CONST	SEGMENT
??_C@_0M@OCINAIJL@vid_ticrate@ DB 'vid_ticrate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEPPJAKI@MAX@
CONST	SEGMENT
??_C@_03LEPPJAKI@MAX@ DB 'MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGHEHEMH@MIN@
CONST	SEGMENT
??_C@_03KGHEHEMH@MIN@ DB 'MIN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IGHHMFLN@Both@
CONST	SEGMENT
??_C@_04IGHHMFLN@Both@ DB 'Both', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFDNMOLO@Graph@
CONST	SEGMENT
??_C@_05KFDNMOLO@Graph@ DB 'Graph', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IKJEKJLO@Counter@
CONST	SEGMENT
??_C@_07IKJEKJLO@Counter@ DB 'Counter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off@ DB 'Off', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_cv_ticrate DD	FLAT:??_C@_0M@OCINAIJL@vid_ticrate@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	00H
	DD	FLAT:_ticrate_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_usegamma DD	FLAT:??_C@_05KDLBCAI@gamma@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	03H
	DD	FLAT:_gamma_cons_t
	DD	FLAT:_CV_usegamma_OnChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_allcaps DD	FLAT:??_C@_07LIFHLGJN@allcaps@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	00H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grrenderquality DD FLAT:??_C@_0BA@GGIJLIJJ@gr_renderdetail@
	DD	FLAT:??_C@_07MJEANAEL@Quality@
	DD	01H
	DD	FLAT:_grrenderquality_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grfog DD	FLAT:??_C@_06KHFBHPJI@gr_fog@
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grfogcolor DD FLAT:??_C@_0M@OEGCPAAI@gr_fogcolor@
	DD	FLAT:??_C@_06JKOKFAJH@AAAAAA@
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grsoftwarefog DD FLAT:??_C@_0P@NOLAKGNE@gr_softwarefog@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:_grsoftwarefog_cons_t
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grgammared DD FLAT:??_C@_0M@GGBAGGIL@gr_gammared@
	DD	FLAT:??_C@_03CBMECOON@127@
	DD	03H
	DD	FLAT:_grgamma_cons_t
	DD	FLAT:_CV_Gammaxxx_ONChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grgammagreen DD FLAT:??_C@_0O@PAKDBDMA@gr_gammagreen@
	DD	FLAT:??_C@_03CBMECOON@127@
	DD	03H
	DD	FLAT:_grgamma_cons_t
	DD	FLAT:_CV_Gammaxxx_ONChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grgammablue DD FLAT:??_C@_0N@GCIKMEGD@gr_gammablue@
	DD	FLAT:??_C@_03CBMECOON@127@
	DD	03H
	DD	FLAT:_grgamma_cons_t
	DD	FLAT:_CV_Gammaxxx_ONChange
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_cv_grfovchange DD FLAT:??_C@_0N@OBGALGGC@gr_fovchange@
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:_CV_OnOff
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	DB	00H
	ORG $+1
	DD	00H
_ticrate_cons_t DD 00H
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:??_C@_07IKJEKJLO@Counter@
	DD	02H
	DD	FLAT:??_C@_05KFDNMOLO@Graph@
	DD	03H
	DD	FLAT:??_C@_04IGHHMFLN@Both@
	DD	00H
	DD	00H
_gamma_cons_t DD 00H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	04H
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_grrenderquality_cons_t DD 01H
	DD	FLAT:??_C@_05HOIAGEJD@Speed@
	DD	02H
	DD	FLAT:??_C@_07MJEANAEL@Quality@
	DD	03H
	DD	FLAT:??_C@_0N@BBHDJDJA@Full?5Quality@
	DD	00H
	DD	00H
_grgamma_cons_t DD 01H
	DD	FLAT:??_C@_03KGHEHEMH@MIN@
	DD	0ffH
	DD	FLAT:??_C@_03LEPPJAKI@MAX@
	DD	00H
	DD	00H
_grsoftwarefog_cons_t DD 00H
	DD	FLAT:??_C@_03GCDBBDDL@Off@
	DD	01H
	DD	FLAT:??_C@_02IAAGKKDJ@On@
	DD	02H
	DD	FLAT:??_C@_0M@PAGBDCG@LightPlanes@
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
_gammatable DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	05bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	080H
	DB	080H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0b0H
	DB	0b1H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	0deH
	DB	0dfH
	DB	0e0H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0ebH
	DB	0ecH
	DB	0edH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0ffH
	DB	02H
	DB	04H
	DB	05H
	DB	07H
	DB	08H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0eH
	DB	0fH
	DB	010H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	041H
	DB	042H
	DB	043H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	05bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	080H
	DB	081H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0afH
	DB	0b0H
	DB	0b1H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	0deH
	DB	0deH
	DB	0dfH
	DB	0e0H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0ebH
	DB	0ecH
	DB	0edH
	DB	0edH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fcH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0ffH
	DB	04H
	DB	07H
	DB	09H
	DB	0bH
	DB	0dH
	DB	0fH
	DB	011H
	DB	013H
	DB	015H
	DB	016H
	DB	018H
	DB	01aH
	DB	01bH
	DB	01dH
	DB	01eH
	DB	020H
	DB	021H
	DB	023H
	DB	024H
	DB	026H
	DB	027H
	DB	028H
	DB	02aH
	DB	02bH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	032H
	DB	033H
	DB	034H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	05bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	080H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	090H
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	0a0H
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0acH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0b0H
	DB	0b1H
	DB	0b2H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bcH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c9H
	DB	0c9H
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0ceH
	DB	0ceH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d5H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d9H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	0ddH
	DB	0deH
	DB	0dfH
	DB	0e0H
	DB	0e0H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e4H
	DB	0e4H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0eaH
	DB	0ebH
	DB	0ebH
	DB	0ecH
	DB	0edH
	DB	0eeH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f1H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0feH
	DB	0ffH
	DB	08H
	DB	0cH
	DB	010H
	DB	013H
	DB	016H
	DB	018H
	DB	01bH
	DB	01dH
	DB	01fH
	DB	022H
	DB	024H
	DB	026H
	DB	028H
	DB	029H
	DB	02bH
	DB	02dH
	DB	02fH
	DB	031H
	DB	032H
	DB	034H
	DB	035H
	DB	037H
	DB	039H
	DB	03aH
	DB	03cH
	DB	03dH
	DB	03fH
	DB	040H
	DB	041H
	DB	043H
	DB	044H
	DB	046H
	DB	047H
	DB	048H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	05aH
	DB	05bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
	DB	080H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	08fH
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	0a0H
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a5H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0adH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0b0H
	DB	0b0H
	DB	0b1H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b7H
	DB	0b7H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0baH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0c0H
	DB	0c0H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c3H
	DB	0c4H
	DB	0c5H
	DB	0c5H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0caH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0cfH
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d2H
	DB	0d3H
	DB	0d4H
	DB	0d4H
	DB	0d5H
	DB	0d6H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d8H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dbH
	DB	0dcH
	DB	0ddH
	DB	0ddH
	DB	0deH
	DB	0dfH
	DB	0dfH
	DB	0e0H
	DB	0e1H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e3H
	DB	0e4H
	DB	0e5H
	DB	0e5H
	DB	0e6H
	DB	0e7H
	DB	0e7H
	DB	0e8H
	DB	0e9H
	DB	0e9H
	DB	0eaH
	DB	0ebH
	DB	0ebH
	DB	0ecH
	DB	0edH
	DB	0edH
	DB	0eeH
	DB	0eeH
	DB	0efH
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f6H
	DB	0f7H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0fdH
	DB	0feH
	DB	0feH
	DB	0ffH
	DB	010H
	DB	017H
	DB	01cH
	DB	020H
	DB	024H
	DB	027H
	DB	02aH
	DB	02dH
	DB	030H
	DB	032H
	DB	035H
	DB	037H
	DB	039H
	DB	03cH
	DB	03eH
	DB	040H
	DB	042H
	DB	044H
	DB	045H
	DB	047H
	DB	049H
	DB	04bH
	DB	04cH
	DB	04eH
	DB	050H
	DB	051H
	DB	053H
	DB	054H
	DB	056H
	DB	057H
	DB	059H
	DB	05aH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	060H
	DB	061H
	DB	062H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	080H
	DB	080H
	DB	081H
	DB	082H
	DB	083H
	DB	084H
	DB	085H
	DB	086H
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	08fH
	DB	090H
	DB	091H
	DB	092H
	DB	093H
	DB	094H
	DB	095H
	DB	096H
	DB	096H
	DB	097H
	DB	098H
	DB	099H
	DB	09aH
	DB	09bH
	DB	09bH
	DB	09cH
	DB	09dH
	DB	09eH
	DB	09fH
	DB	09fH
	DB	0a0H
	DB	0a1H
	DB	0a2H
	DB	0a3H
	DB	0a3H
	DB	0a4H
	DB	0a5H
	DB	0a6H
	DB	0a6H
	DB	0a7H
	DB	0a8H
	DB	0a9H
	DB	0a9H
	DB	0aaH
	DB	0abH
	DB	0acH
	DB	0acH
	DB	0adH
	DB	0aeH
	DB	0afH
	DB	0afH
	DB	0b0H
	DB	0b1H
	DB	0b1H
	DB	0b2H
	DB	0b3H
	DB	0b4H
	DB	0b4H
	DB	0b5H
	DB	0b6H
	DB	0b6H
	DB	0b7H
	DB	0b8H
	DB	0b8H
	DB	0b9H
	DB	0baH
	DB	0bbH
	DB	0bbH
	DB	0bcH
	DB	0bdH
	DB	0bdH
	DB	0beH
	DB	0bfH
	DB	0bfH
	DB	0c0H
	DB	0c1H
	DB	0c1H
	DB	0c2H
	DB	0c3H
	DB	0c3H
	DB	0c4H
	DB	0c4H
	DB	0c5H
	DB	0c6H
	DB	0c6H
	DB	0c7H
	DB	0c8H
	DB	0c8H
	DB	0c9H
	DB	0caH
	DB	0caH
	DB	0cbH
	DB	0cbH
	DB	0ccH
	DB	0cdH
	DB	0cdH
	DB	0ceH
	DB	0cfH
	DB	0cfH
	DB	0d0H
	DB	0d0H
	DB	0d1H
	DB	0d2H
	DB	0d2H
	DB	0d3H
	DB	0d3H
	DB	0d4H
	DB	0d5H
	DB	0d5H
	DB	0d6H
	DB	0d6H
	DB	0d7H
	DB	0d8H
	DB	0d8H
	DB	0d9H
	DB	0d9H
	DB	0daH
	DB	0dbH
	DB	0dbH
	DB	0dcH
	DB	0dcH
	DB	0ddH
	DB	0ddH
	DB	0deH
	DB	0dfH
	DB	0dfH
	DB	0e0H
	DB	0e0H
	DB	0e1H
	DB	0e1H
	DB	0e2H
	DB	0e3H
	DB	0e3H
	DB	0e4H
	DB	0e4H
	DB	0e5H
	DB	0e5H
	DB	0e6H
	DB	0e6H
	DB	0e7H
	DB	0e8H
	DB	0e8H
	DB	0e9H
	DB	0e9H
	DB	0eaH
	DB	0eaH
	DB	0ebH
	DB	0ebH
	DB	0ecH
	DB	0ecH
	DB	0edH
	DB	0edH
	DB	0eeH
	DB	0efH
	DB	0efH
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f1H
	DB	0f2H
	DB	0f2H
	DB	0f3H
	DB	0f3H
	DB	0f4H
	DB	0f4H
	DB	0f5H
	DB	0f5H
	DB	0f6H
	DB	0f6H
	DB	0f7H
	DB	0f7H
	DB	0f8H
	DB	0f8H
	DB	0f9H
	DB	0f9H
	DB	0faH
	DB	0faH
	DB	0fbH
	DB	0fbH
	DB	0fcH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0feH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	___snprintf
PUBLIC	_V_Init
PUBLIC	_V_SetPalette
PUBLIC	_V_SetPaletteLump
PUBLIC	_R_GetPalname
PUBLIC	_GetPalette
PUBLIC	_V_DrawMappedPatch
PUBLIC	_V_DrawScaledPatch
PUBLIC	_V_DrawSmallScaledPatch
PUBLIC	_V_DrawSmallMappedPatch
PUBLIC	_V_DrawSmallTranslucentMappedPatch
PUBLIC	_V_DrawSmallTranslucentPatch
PUBLIC	_V_DrawTranslucentPatch
PUBLIC	_V_DrawPatch
PUBLIC	_V_DrawBlock
PUBLIC	_V_DrawScaledPic
PUBLIC	_V_DrawFill
PUBLIC	_V_DrawFlatFill
PUBLIC	_V_DrawFadeScreen
PUBLIC	_V_DrawFadeConsBack
PUBLIC	_V_DrawCharacter
PUBLIC	_V_DrawLevelTitle
PUBLIC	_V_DrawString
PUBLIC	_V_DrawCenteredString
PUBLIC	_V_DrawRightAlignedString
PUBLIC	_V_DrawTinyNum
PUBLIC	_V_LevelNameWidth
PUBLIC	_V_LevelNameHeight
PUBLIC	_V_DrawCreditString
PUBLIC	_V_CreditStringWidth
PUBLIC	_V_StringWidth
PUBLIC	_V_DoPostProcessor
PUBLIC	_V_DrawPatchFill
PUBLIC	_VID_BlitLinearScreen
PUBLIC	??_C@_07FLMOFAHC@PLAYPAL@			; `string'
PUBLIC	??_C@_07NNDNPPKA@PAL?$CF04u@			; `string'
PUBLIC	??_C@_0CH@MIKIJAOJ@pic?5mode?5?$CFd?5not?5supported?5in?5So@ ; `string'
EXTRN	_toupper:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_abs:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_W_GetNumForName:PROC
EXTRN	_W_LumpLength:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_I_SetPalette:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_M_Random:PROC
EXTRN	_HWR_FadeScreenMenuBack:PROC
EXTRN	_HWR_DrawConsoleBack:PROC
EXTRN	_HWR_DrawFlatFill:PROC
EXTRN	_HWR_DrawPatch:PROC
EXTRN	_HWR_DrawClippedPatch:PROC
EXTRN	_HWR_DrawTranslucentPatch:PROC
EXTRN	_HWR_DrawSmallPatch:PROC
EXTRN	_HWR_DrawMappedPatch:PROC
EXTRN	_HWR_DrawFill:PROC
EXTRN	_HWR_DrawPic:PROC
EXTRN	_HWR_SetPalette:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamestate:DWORD
EXTRN	_M_Memcpy:DWORD
EXTRN	_finesine:BYTE
EXTRN	_vid:BYTE
EXTRN	_scr_bpp:DWORD
EXTRN	_colormaps:DWORD
EXTRN	_transtables:DWORD
EXTRN	_hu_font:BYTE
EXTRN	_tinynum:BYTE
EXTRN	_lt_font:BYTE
EXTRN	_cred_font:BYTE
EXTRN	_yellowmap:DWORD
EXTRN	_purplemap:DWORD
EXTRN	_lgreenmap:DWORD
EXTRN	_bluemap:DWORD
EXTRN	_graymap:DWORD
EXTRN	_redmap:DWORD
EXTRN	_orangemap:DWORD
EXTRN	_cwhitemap:DWORD
EXTRN	_corangemap:DWORD
EXTRN	_cbluemap:DWORD
EXTRN	_cgreenmap:DWORD
EXTRN	_cgraymap:DWORD
EXTRN	_credmap:DWORD
EXTRN	_rendermode:DWORD
EXTRN	_gamemap:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_postimgparam:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?palname@?1??R_GetPalname@@9@9 DB 09H DUP (?)		; `R_GetPalname'::`2'::palname
	ALIGN	4

?disStart@?2??V_DoPostProcessor@@9@9 DD 01H DUP (?)	; `V_DoPostProcessor'::`3'::disStart
_BSS	ENDS
;	COMDAT ??_C@_0CH@MIKIJAOJ@pic?5mode?5?$CFd?5not?5supported?5in?5So@
CONST	SEGMENT
??_C@_0CH@MIKIJAOJ@pic?5mode?5?$CFd?5not?5supported?5in?5So@ DB 'pic mode'
	DB	' %d not supported in Software', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNDNPPKA@PAL?$CF04u@
CONST	SEGMENT
??_C@_07NNDNPPKA@PAL?$CF04u@ DB 'PAL%04u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLMOFAHC@PLAYPAL@
CONST	SEGMENT
??_C@_07FLMOFAHC@PLAYPAL@ DB 'PLAYPAL', 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01b7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	06aH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawWordWrapString
_TEXT	SEGMENT
_lastusablespace$ = -1044				; size = 4
_i$ = -1040						; size = 4
_nx$ = -1036						; size = 4
_c$ = -1032						; size = 4
_newstring$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_option$ = 16						; size = 4
_string$ = 20						; size = 4
_V_DrawWordWrapString PROC				; COMDAT

; 2040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2041 : 	char newstring[1024];
; 2042 : 	int c;
; 2043 : 	size_t nx = x, i, lastusablespace = 0;

  00016	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00019	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _nx$[ebp], eax
  0001f	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lastusablespace$[ebp], 0

; 2044 : 
; 2045 : 	strncpy(newstring, string, 1024);

  00029	68 00 04 00 00	 push	 1024			; 00000400H
  0002e	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  00031	50		 push	 eax
  00032	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _newstring$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _strncpy
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2046 : 
; 2047 : 	for (i = 0; i < strlen(newstring); i++)

  00041	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0004b	eb 0f		 jmp	 SHORT $LN4@V_DrawWord
$LN2@V_DrawWord:
  0004d	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@V_DrawWord:
  0005c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _newstring$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _strlen
  00068	83 c4 04	 add	 esp, 4
  0006b	39 85 f0 fb ff
	ff		 cmp	 DWORD PTR _i$[ebp], eax
  00071	0f 83 17 01 00
	00		 jae	 $LN3@V_DrawWord

; 2048 : 	{
; 2049 : 		c = newstring[i];

  00077	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0007d	0f be 8c 05 fc
	fb ff ff	 movsx	 ecx, BYTE PTR _newstring$[ebp+eax]
  00085	89 8d f8 fb ff
	ff		 mov	 DWORD PTR _c$[ebp], ecx

; 2050 : 		if ((UINT8)c >= 0x80 && (UINT8)c <= 0x89) //color parsing! -Inuyasha 2.16.09

  0008b	0f b6 85 f8 fb
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  00092	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00097	7c 10		 jl	 SHORT $LN5@V_DrawWord
  00099	0f b6 85 f8 fb
	ff ff		 movzx	 eax, BYTE PTR _c$[ebp]
  000a0	3d 89 00 00 00	 cmp	 eax, 137		; 00000089H
  000a5	7f 02		 jg	 SHORT $LN5@V_DrawWord

; 2051 : 			continue;

  000a7	eb a4		 jmp	 SHORT $LN2@V_DrawWord
$LN5@V_DrawWord:

; 2052 : 
; 2053 : 		c = toupper(c) - HU_FONTSTART;

  000a9	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _toupper
  000b5	83 c4 04	 add	 esp, 4
  000b8	83 e8 21	 sub	 eax, 33			; 00000021H
  000bb	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _c$[ebp], eax

; 2054 : 		if (c == '\n')

  000c1	83 bd f8 fb ff
	ff 0a		 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  000c8	75 1a		 jne	 SHORT $LN6@V_DrawWord

; 2055 : 		{
; 2056 : 			nx = x;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000cd	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _nx$[ebp], eax

; 2057 : 			lastusablespace = 0;

  000d3	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lastusablespace$[ebp], 0

; 2058 : 			continue;

  000dd	e9 6b ff ff ff	 jmp	 $LN2@V_DrawWord

; 2059 : 		}

  000e2	eb 60		 jmp	 SHORT $LN9@V_DrawWord
$LN6@V_DrawWord:

; 2060 : 		else if (c < 0 || (c >= HU_REALFONTSIZE && c != '~' - HU_FONTSTART && c != '`' - HU_FONTSTART)
; 2061 : 			|| hu_font[c] == NULL)

  000e4	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _c$[ebp], 0
  000eb	7c 2b		 jl	 SHORT $LN10@V_DrawWord
  000ed	83 bd f8 fb ff
	ff 5a		 cmp	 DWORD PTR _c$[ebp], 90	; 0000005aH
  000f4	7c 12		 jl	 SHORT $LN11@V_DrawWord
  000f6	83 bd f8 fb ff
	ff 5d		 cmp	 DWORD PTR _c$[ebp], 93	; 0000005dH
  000fd	74 09		 je	 SHORT $LN11@V_DrawWord
  000ff	83 bd f8 fb ff
	ff 3f		 cmp	 DWORD PTR _c$[ebp], 63	; 0000003fH
  00106	75 10		 jne	 SHORT $LN10@V_DrawWord
$LN11@V_DrawWord:
  00108	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _c$[ebp]
  0010e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _hu_font[eax*4], 0
  00116	75 1d		 jne	 SHORT $LN8@V_DrawWord
$LN10@V_DrawWord:

; 2062 : 		{
; 2063 : 			nx += 4;

  00118	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _nx$[ebp]
  0011e	83 c0 04	 add	 eax, 4
  00121	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _nx$[ebp], eax

; 2064 : 			lastusablespace = i;

  00127	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0012d	89 85 ec fb ff
	ff		 mov	 DWORD PTR _lastusablespace$[ebp], eax

; 2065 : 		}

  00133	eb 0f		 jmp	 SHORT $LN9@V_DrawWord
$LN8@V_DrawWord:

; 2066 : 		else
; 2067 : 			nx += 8;

  00135	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _nx$[ebp]
  0013b	83 c0 08	 add	 eax, 8
  0013e	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _nx$[ebp], eax
$LN9@V_DrawWord:

; 2068 : 
; 2069 : 		if (lastusablespace != 0 && nx > BASEVIDWIDTH-8)

  00144	83 bd ec fb ff
	ff 00		 cmp	 DWORD PTR _lastusablespace$[ebp], 0
  0014b	74 3c		 je	 SHORT $LN12@V_DrawWord
  0014d	81 bd f4 fb ff
	ff 38 01 00 00	 cmp	 DWORD PTR _nx$[ebp], 312 ; 00000138H
  00157	76 30		 jbe	 SHORT $LN12@V_DrawWord

; 2070 : 		{
; 2071 : 			newstring[lastusablespace] = '\n';

  00159	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _lastusablespace$[ebp]
  0015f	c6 84 05 fc fb
	ff ff 0a	 mov	 BYTE PTR _newstring$[ebp+eax], 10 ; 0000000aH

; 2072 : 			nx = x + ((i-lastusablespace)*8);

  00167	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0016d	2b 85 ec fb ff
	ff		 sub	 eax, DWORD PTR _lastusablespace$[ebp]
  00173	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00176	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00179	89 95 f4 fb ff
	ff		 mov	 DWORD PTR _nx$[ebp], edx

; 2073 : 			lastusablespace = 0;

  0017f	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lastusablespace$[ebp], 0
$LN12@V_DrawWord:

; 2074 : 		}
; 2075 : 	}

  00189	e9 bf fe ff ff	 jmp	 $LN2@V_DrawWord
$LN3@V_DrawWord:

; 2076 : 
; 2077 : 	//Oh the hilarity.
; 2078 : 	//Just call V_DrawString with the new string...
; 2079 : 	//Clear word wrap flag, first, though.  Obvious reasons.
; 2080 : 	option &= ~V_WORDWRAP;

  0018e	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00191	25 ff ff ff fd	 and	 eax, -33554433		; fdffffffH
  00196	89 45 10	 mov	 DWORD PTR _option$[ebp], eax

; 2081 : 	V_DrawString(x, y, option, newstring);

  00199	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _newstring$[ebp]
  0019f	50		 push	 eax
  001a0	8b 4d 10	 mov	 ecx, DWORD PTR _option$[ebp]
  001a3	51		 push	 ecx
  001a4	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  001a7	52		 push	 edx
  001a8	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _V_DrawString
  001b1	83 c4 10	 add	 esp, 16			; 00000010H

; 2082 : }

  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi
  001b6	5b		 pop	 ebx
  001b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ba	33 cd		 xor	 ecx, ebp
  001bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c3		 ret	 0
_V_DrawWordWrapString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_BlitScaledPic
_TEXT	SEGMENT
tv84 = -104						; size = 4
tv81 = -100						; size = 4
tv129 = -100						; size = 4
_height$ = -32						; size = 4
_width$ = -28						; size = 4
_dest$ = -24						; size = 4
_src$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_dupy$ = -8						; size = 4
_dupx$ = -4						; size = 4
_rx1$ = 8						; size = 4
_ry1$ = 12						; size = 4
_scrn$ = 16						; size = 4
_pic$ = 20						; size = 4
_V_BlitScaledPic PROC					; COMDAT

; 1620 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1621 : 	INT32 dupx, dupy;
; 1622 : 	INT32 x, y;
; 1623 : 	UINT8 *src, *dest;
; 1624 : 	INT32 width, height;
; 1625 : 
; 1626 : 	width = SHORT(pic->width);

  00009	8b 45 14	 mov	 eax, DWORD PTR _pic$[ebp]
  0000c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000f	89 4d e4	 mov	 DWORD PTR _width$[ebp], ecx

; 1627 : 	height = SHORT(pic->height);

  00012	8b 45 14	 mov	 eax, DWORD PTR _pic$[ebp]
  00015	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00019	89 4d e0	 mov	 DWORD PTR _height$[ebp], ecx

; 1628 : 	scrn &= 0xffff;

  0001c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0001f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00024	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax

; 1629 : 
; 1630 : 	if (pic->mode != 0)

  00027	8b 45 14	 mov	 eax, DWORD PTR _pic$[ebp]
  0002a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0002e	85 c9		 test	 ecx, ecx
  00030	74 1a		 je	 SHORT $LN14@V_BlitScal

; 1631 : 	{
; 1632 : 		CONS_Printf("pic mode %d not supported in Software\n", pic->mode);

  00032	8b 45 14	 mov	 eax, DWORD PTR _pic$[ebp]
  00035	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MIKIJAOJ@pic?5mode?5?$CFd?5not?5supported?5in?5So@
  0003f	e8 00 00 00 00	 call	 _CONS_Printf
  00044	83 c4 08	 add	 esp, 8

; 1633 : 		return;

  00047	e9 5d 01 00 00	 jmp	 $LN3@V_BlitScal
$LN14@V_BlitScal:

; 1634 : 	}
; 1635 : 
; 1636 : 	dest = screens[scrn] + max(0, ry1 * vid.width) + max(0, rx1);

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _ry1$[ebp]
  0004f	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00056	85 c0		 test	 eax, eax
  00058	7d 09		 jge	 SHORT $LN17@V_BlitScal
  0005a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  00061	eb 0d		 jmp	 SHORT $LN18@V_BlitScal
$LN17@V_BlitScal:
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _ry1$[ebp]
  00066	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0006d	89 4d 9c	 mov	 DWORD PTR tv81[ebp], ecx
$LN18@V_BlitScal:
  00070	83 7d 08 00	 cmp	 DWORD PTR _rx1$[ebp], 0
  00074	7d 09		 jge	 SHORT $LN19@V_BlitScal
  00076	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  0007d	eb 06		 jmp	 SHORT $LN20@V_BlitScal
$LN19@V_BlitScal:
  0007f	8b 55 08	 mov	 edx, DWORD PTR _rx1$[ebp]
  00082	89 55 98	 mov	 DWORD PTR tv84[ebp], edx
$LN20@V_BlitScal:
  00085	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00088	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _screens[eax*4]
  0008f	03 4d 9c	 add	 ecx, DWORD PTR tv81[ebp]
  00092	03 4d 98	 add	 ecx, DWORD PTR tv84[ebp]
  00095	89 4d e8	 mov	 DWORD PTR _dest$[ebp], ecx

; 1637 : 	// y cliping to the screen
; 1638 : 	if (ry1 + height * vid.dupy >= vid.width)

  00098	8b 45 e0	 mov	 eax, DWORD PTR _height$[ebp]
  0009b	0f af 05 24 00
	00 00		 imul	 eax, DWORD PTR _vid+36
  000a2	03 45 0c	 add	 eax, DWORD PTR _ry1$[ebp]
  000a5	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  000ab	7c 15		 jl	 SHORT $LN15@V_BlitScal

; 1639 : 		height = (vid.width - ry1) / vid.dupy - 1;

  000ad	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000b2	2b 45 0c	 sub	 eax, DWORD PTR _ry1$[ebp]
  000b5	99		 cdq
  000b6	f7 3d 24 00 00
	00		 idiv	 DWORD PTR _vid+36
  000bc	83 e8 01	 sub	 eax, 1
  000bf	89 45 e0	 mov	 DWORD PTR _height$[ebp], eax
$LN15@V_BlitScal:

; 1640 : 	// WARNING no x clipping (not needed for the moment)
; 1641 : 
; 1642 : 	for (y = max(0, -ry1 / vid.dupy); y < height; y++)

  000c2	8b 45 0c	 mov	 eax, DWORD PTR _ry1$[ebp]
  000c5	f7 d8		 neg	 eax
  000c7	99		 cdq
  000c8	f7 3d 24 00 00
	00		 idiv	 DWORD PTR _vid+36
  000ce	85 c0		 test	 eax, eax
  000d0	7d 09		 jge	 SHORT $LN21@V_BlitScal
  000d2	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
  000d9	eb 0f		 jmp	 SHORT $LN22@V_BlitScal
$LN21@V_BlitScal:
  000db	8b 45 0c	 mov	 eax, DWORD PTR _ry1$[ebp]
  000de	f7 d8		 neg	 eax
  000e0	99		 cdq
  000e1	f7 3d 24 00 00
	00		 idiv	 DWORD PTR _vid+36
  000e7	89 45 9c	 mov	 DWORD PTR tv129[ebp], eax
$LN22@V_BlitScal:
  000ea	8b 45 9c	 mov	 eax, DWORD PTR tv129[ebp]
  000ed	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
  000f0	eb 09		 jmp	 SHORT $LN4@V_BlitScal
$LN2@V_BlitScal:
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@V_BlitScal:
  000fb	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  000fe	3b 45 e0	 cmp	 eax, DWORD PTR _height$[ebp]
  00101	0f 8d a2 00 00
	00		 jge	 $LN3@V_BlitScal

; 1643 : 	{
; 1644 : 		for (dupy = vid.dupy; dupy; dupy--)

  00107	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  0010c	89 45 f8	 mov	 DWORD PTR _dupy$[ebp], eax
  0010f	eb 09		 jmp	 SHORT $LN7@V_BlitScal
$LN5@V_BlitScal:
  00111	8b 45 f8	 mov	 eax, DWORD PTR _dupy$[ebp]
  00114	83 e8 01	 sub	 eax, 1
  00117	89 45 f8	 mov	 DWORD PTR _dupy$[ebp], eax
$LN7@V_BlitScal:
  0011a	83 7d f8 00	 cmp	 DWORD PTR _dupy$[ebp], 0
  0011e	0f 84 80 00 00
	00		 je	 $LN6@V_BlitScal

; 1645 : 		{
; 1646 : 			src = pic->data + y * width;

  00124	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00127	0f af 45 e4	 imul	 eax, DWORD PTR _width$[ebp]
  0012b	8b 4d 14	 mov	 ecx, DWORD PTR _pic$[ebp]
  0012e	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00132	89 55 ec	 mov	 DWORD PTR _src$[ebp], edx

; 1647 : 			for (x = 0; x < width; x++)

  00135	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  0013c	eb 09		 jmp	 SHORT $LN10@V_BlitScal
$LN8@V_BlitScal:
  0013e	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00141	83 c0 01	 add	 eax, 1
  00144	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
$LN10@V_BlitScal:
  00147	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  0014a	3b 45 e4	 cmp	 eax, DWORD PTR _width$[ebp]
  0014d	7d 39		 jge	 SHORT $LN9@V_BlitScal

; 1648 : 			{
; 1649 : 				for (dupx = vid.dupx; dupx; dupx--)

  0014f	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00154	89 45 fc	 mov	 DWORD PTR _dupx$[ebp], eax
  00157	eb 09		 jmp	 SHORT $LN13@V_BlitScal
$LN11@V_BlitScal:
  00159	8b 45 fc	 mov	 eax, DWORD PTR _dupx$[ebp]
  0015c	83 e8 01	 sub	 eax, 1
  0015f	89 45 fc	 mov	 DWORD PTR _dupx$[ebp], eax
$LN13@V_BlitScal:
  00162	83 7d fc 00	 cmp	 DWORD PTR _dupx$[ebp], 0
  00166	74 15		 je	 SHORT $LN12@V_BlitScal

; 1650 : 					*dest++ = *src;

  00168	8b 45 e8	 mov	 eax, DWORD PTR _dest$[ebp]
  0016b	8b 4d ec	 mov	 ecx, DWORD PTR _src$[ebp]
  0016e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00170	88 10		 mov	 BYTE PTR [eax], dl
  00172	8b 45 e8	 mov	 eax, DWORD PTR _dest$[ebp]
  00175	83 c0 01	 add	 eax, 1
  00178	89 45 e8	 mov	 DWORD PTR _dest$[ebp], eax
  0017b	eb dc		 jmp	 SHORT $LN11@V_BlitScal
$LN12@V_BlitScal:

; 1651 : 				src++;

  0017d	8b 45 ec	 mov	 eax, DWORD PTR _src$[ebp]
  00180	83 c0 01	 add	 eax, 1
  00183	89 45 ec	 mov	 DWORD PTR _src$[ebp], eax

; 1652 : 			}

  00186	eb b6		 jmp	 SHORT $LN8@V_BlitScal
$LN9@V_BlitScal:

; 1653 : 			dest += vid.width - vid.dupx * width;

  00188	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  0018d	0f af 45 e4	 imul	 eax, DWORD PTR _width$[ebp]
  00191	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00197	2b c8		 sub	 ecx, eax
  00199	03 4d e8	 add	 ecx, DWORD PTR _dest$[ebp]
  0019c	89 4d e8	 mov	 DWORD PTR _dest$[ebp], ecx

; 1654 : 		}

  0019f	e9 6d ff ff ff	 jmp	 $LN5@V_BlitScal
$LN6@V_BlitScal:

; 1655 : 	}

  001a4	e9 49 ff ff ff	 jmp	 $LN2@V_BlitScal
$LN3@V_BlitScal:

; 1656 : }

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
_V_BlitScaledPic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawClippedScaledPatch
_TEXT	SEGMENT
tv210 = -124						; size = 4
tv213 = -124						; size = 4
_heightmask$1 = -56					; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_destend$ = -44						; size = 4
_dest$ = -40						; size = 4
_desttop$ = -36						; size = 4
_column$ = -32						; size = 4
_rowfrac$ = -28						; size = 4
_colfrac$ = -24						; size = 4
_ofs$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_V_DrawClippedScaledPatch PROC				; COMDAT

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 646  : 	size_t count;
; 647  : 	INT32 col, dupx, dupy, ofs, colfrac, rowfrac;
; 648  : 	const column_t *column;
; 649  : 	UINT8 *desttop, *dest, *destend;
; 650  : 	const UINT8 *source, *deststop;
; 651  : 
; 652  : #ifdef HWRENDER
; 653  : 	// draw a hardware converted patch
; 654  : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 27		 je	 SHORT $LN16@V_DrawClip
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 1e		 je	 SHORT $LN16@V_DrawClip

; 655  : 	{
; 656  : 		// V_NOSCALESTART might be impled for software, but not for hardware!
; 657  : 		HWR_DrawClippedPatch((GLPatch_t *)patch, x, y, V_NOSCALESTART);

  0001b	68 00 00 01 00	 push	 65536			; 00010000H
  00020	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _HWR_DrawClippedPatch
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 658  : 		return;

  00034	e9 31 03 00 00	 jmp	 $LN3@V_DrawClip
$LN16@V_DrawClip:

; 659  : 	}
; 660  : #endif
; 661  : 
; 662  : 	if ((scrn & V_NOSCALEPATCH))

  00039	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0003c	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00041	74 0f		 je	 SHORT $LN17@V_DrawClip

; 663  : 		dupx = dupy = 1;

  00043	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax
  00050	eb 10		 jmp	 SHORT $LN18@V_DrawClip
$LN17@V_DrawClip:

; 664  : 	else
; 665  : 	{
; 666  : 		dupx = vid.dupx;

  00052	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00057	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 667  : 		dupy = vid.dupy;

  0005a	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  0005f	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax
$LN18@V_DrawClip:

; 668  : 	}
; 669  : 
; 670  : 	y -= SHORT(patch->topoffset);

  00062	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00065	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00069	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006c	2b d1		 sub	 edx, ecx
  0006e	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 671  : 	x -= SHORT(patch->leftoffset);

  00071	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00074	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00078	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0007b	2b d1		 sub	 edx, ecx
  0007d	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 672  : 
; 673  : 	if (x < 0 || y < 0 || x >= vid.width || y >= vid.height)

  00080	78 1c		 js	 SHORT $LN20@V_DrawClip
  00082	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  00086	7c 16		 jl	 SHORT $LN20@V_DrawClip
  00088	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0008b	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  00091	7d 0b		 jge	 SHORT $LN20@V_DrawClip
  00093	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00096	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  0009c	7c 05		 jl	 SHORT $LN19@V_DrawClip
$LN20@V_DrawClip:

; 674  : 		return;

  0009e	e9 c7 02 00 00	 jmp	 $LN3@V_DrawClip
$LN19@V_DrawClip:

; 675  : 
; 676  : 	colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  000a3	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  000a6	c1 e0 10	 shl	 eax, 16			; 00000010H
  000a9	50		 push	 eax
  000aa	68 00 00 01 00	 push	 65536			; 00010000H
  000af	e8 00 00 00 00	 call	 _FixedDiv
  000b4	83 c4 08	 add	 esp, 8
  000b7	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax

; 677  : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  000bd	c1 e0 10	 shl	 eax, 16			; 00000010H
  000c0	50		 push	 eax
  000c1	68 00 00 01 00	 push	 65536			; 00010000H
  000c6	e8 00 00 00 00	 call	 _FixedDiv
  000cb	83 c4 08	 add	 esp, 8
  000ce	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 678  : 
; 679  : 	if (!screens[scrn&0xff])

  000d1	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000d4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d9	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _screens[eax*4], 0
  000e1	75 05		 jne	 SHORT $LN21@V_DrawClip

; 680  : 		return;

  000e3	e9 82 02 00 00	 jmp	 $LN3@V_DrawClip
$LN21@V_DrawClip:

; 681  : 
; 682  : 	desttop = screens[scrn&0xff] + (y*vid.width) + x;

  000e8	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000eb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000f3	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  000fa	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  00101	03 d1		 add	 edx, ecx
  00103	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  00106	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx

; 683  : 	deststop = screens[scrn&0xff] + vid.width * vid.height * vid.bpp;

  00109	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0010c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00111	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00117	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  0011e	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  00125	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  0012c	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 684  : 
; 685  : 	if (!desttop)

  0012f	83 7d dc 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  00133	75 05		 jne	 SHORT $LN22@V_DrawClip

; 686  : 		return;

  00135	e9 30 02 00 00	 jmp	 $LN3@V_DrawClip
$LN22@V_DrawClip:

; 687  : 
; 688  : 	// make sure it doesn't go off the right
; 689  : 	if (x + SHORT(patch->width)*dupx <= vid.width)

  0013a	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0013d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00140	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00144	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  00147	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR _vid+12
  0014d	7f 12		 jg	 SHORT $LN23@V_DrawClip

; 690  : 		destend = desttop + SHORT(patch->width) * dupx;

  0014f	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00152	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00155	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00159	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0015c	89 4d d4	 mov	 DWORD PTR _destend$[ebp], ecx
  0015f	eb 0f		 jmp	 SHORT $LN24@V_DrawClip
$LN23@V_DrawClip:

; 691  : 	else
; 692  : 		destend = desttop + vid.width - x;

  00161	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  00164	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0016a	2b 45 08	 sub	 eax, DWORD PTR _x$[ebp]
  0016d	89 45 d4	 mov	 DWORD PTR _destend$[ebp], eax
$LN24@V_DrawClip:

; 693  : 
; 694  : 	for (col = 0; desttop < destend; col += colfrac, desttop++)

  00170	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  00177	eb 12		 jmp	 SHORT $LN4@V_DrawClip
$LN2@V_DrawClip:
  00179	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  0017c	03 45 e8	 add	 eax, DWORD PTR _colfrac$[ebp]
  0017f	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  00182	8b 4d dc	 mov	 ecx, DWORD PTR _desttop$[ebp]
  00185	83 c1 01	 add	 ecx, 1
  00188	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawClip:
  0018b	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  0018e	3b 45 d4	 cmp	 eax, DWORD PTR _destend$[ebp]
  00191	0f 83 d3 01 00
	00		 jae	 $LN3@V_DrawClip

; 695  : 	{
; 696  : 		register INT32 heightmask;
; 697  : 
; 698  : 		column = (const column_t *)((const UINT8 *)patch + LONG(patch->columnofs[col>>FRACBITS]));

  00197	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  0019a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0019d	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  001a0	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  001a3	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  001a7	89 55 e0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawClip:

; 699  : 
; 700  : 		while (column->topdelta != 0xff)

  001aa	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  001ad	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001b0	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001b6	0f 84 a9 01 00
	00		 je	 $LN6@V_DrawClip

; 701  : 		{
; 702  : 			source = (const UINT8 *)column + 3;

  001bc	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  001bf	83 c0 03	 add	 eax, 3
  001c2	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 703  : 			dest = desttop + column->topdelta*dupy*vid.width;

  001c5	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  001c8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001cb	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  001cf	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001d6	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  001d9	89 4d d8	 mov	 DWORD PTR _dest$[ebp], ecx

; 704  : 			count = column->length*dupy;

  001dc	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  001df	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001e3	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  001e7	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 705  : 			if ((dest-screens[scrn&0xff])/vid.width + count > (unsigned)vid.height - 1)

  001ea	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001ed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001f2	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  001f5	2b 0c 85 00 00
	00 00		 sub	 ecx, DWORD PTR _screens[eax*4]
  001fc	8b c1		 mov	 eax, ecx
  001fe	99		 cdq
  001ff	f7 3d 0c 00 00
	00		 idiv	 DWORD PTR _vid+12
  00205	03 45 fc	 add	 eax, DWORD PTR _count$[ebp]
  00208	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  0020e	83 ea 01	 sub	 edx, 1
  00211	3b c2		 cmp	 eax, edx
  00213	76 28		 jbe	 SHORT $LN25@V_DrawClip

; 706  : 				count = vid.height - 1 - (dest-screens[scrn&0xff])/vid.width;

  00215	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  0021b	83 e9 01	 sub	 ecx, 1
  0021e	8b 55 10	 mov	 edx, DWORD PTR _scrn$[ebp]
  00221	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00227	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0022a	2b 04 95 00 00
	00 00		 sub	 eax, DWORD PTR _screens[edx*4]
  00231	99		 cdq
  00232	f7 3d 0c 00 00
	00		 idiv	 DWORD PTR _vid+12
  00238	2b c8		 sub	 ecx, eax
  0023a	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
$LN25@V_DrawClip:

; 707  : 			if (count <= 0)

  0023d	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  00241	77 05		 ja	 SHORT $LN26@V_DrawClip

; 708  : 				break;

  00243	e9 1d 01 00 00	 jmp	 $LN6@V_DrawClip
$LN26@V_DrawClip:

; 709  : 
; 710  : 			ofs = 0;

  00248	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0

; 711  : 
; 712  : 			heightmask = column->length - 1;

  0024f	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00252	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00256	83 e9 01	 sub	 ecx, 1
  00259	89 4d c8	 mov	 DWORD PTR _heightmask$1[ebp], ecx

; 713  : 
; 714  : 			if (column->length & heightmask)

  0025c	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0025f	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00263	23 4d c8	 and	 ecx, DWORD PTR _heightmask$1[ebp]
  00266	0f 84 95 00 00
	00		 je	 $LN27@V_DrawClip

; 715  : 			{
; 716  : 				// length is not a power of two
; 717  : 				heightmask++;

  0026c	8b 45 c8	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  0026f	83 c0 01	 add	 eax, 1
  00272	89 45 c8	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 718  : 				heightmask <<= FRACBITS;

  00275	8b 45 c8	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  00278	c1 e0 10	 shl	 eax, 16			; 00000010H
  0027b	89 45 c8	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 719  : 
; 720  : 				if (rowfrac < 0)

  0027e	83 7d e4 00	 cmp	 DWORD PTR _rowfrac$[ebp], 0
  00282	7d 0f		 jge	 SHORT $LN29@V_DrawClip
$LN7@V_DrawClip:

; 721  : 					while ((rowfrac += heightmask) < 0)

  00284	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00287	03 45 c8	 add	 eax, DWORD PTR _heightmask$1[ebp]
  0028a	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  0028d	79 02		 jns	 SHORT $LN8@V_DrawClip

; 722  : 						;

  0028f	eb f3		 jmp	 SHORT $LN7@V_DrawClip
$LN8@V_DrawClip:
  00291	eb 13		 jmp	 SHORT $LN10@V_DrawClip
$LN29@V_DrawClip:

; 723  : 				else
; 724  : 					while (rowfrac >= heightmask)

  00293	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00296	3b 45 c8	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  00299	7c 0b		 jl	 SHORT $LN10@V_DrawClip

; 725  : 						rowfrac -= heightmask;

  0029b	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  0029e	2b 45 c8	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  002a1	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  002a4	eb ed		 jmp	 SHORT $LN29@V_DrawClip
$LN10@V_DrawClip:

; 726  : 
; 727  : 				do
; 728  : 				{
; 729  : 					if (dest < deststop)

  002a6	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  002a9	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  002ac	73 13		 jae	 SHORT $LN31@V_DrawClip

; 730  : 						*dest = source[ofs>>FRACBITS];

  002ae	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  002b1	c1 f8 10	 sar	 eax, 16			; 00000010H
  002b4	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  002b7	8b 55 d0	 mov	 edx, DWORD PTR _source$[ebp]
  002ba	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  002bd	88 01		 mov	 BYTE PTR [ecx], al
  002bf	eb 07		 jmp	 SHORT $LN32@V_DrawClip
$LN31@V_DrawClip:

; 731  : 					else
; 732  : 						count = 0;

  002c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN32@V_DrawClip:

; 733  : 					dest += vid.width;

  002c8	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  002cb	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  002d1	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax

; 734  : 					ofs += rowfrac;

  002d4	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  002d7	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  002da	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 735  : 					if ((ofs + rowfrac) > heightmask)

  002dd	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  002e0	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  002e3	3b 45 c8	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  002e6	7e 02		 jle	 SHORT $LN33@V_DrawClip

; 736  : 						goto doneclipping;

  002e8	eb 65		 jmp	 SHORT $doneclipping$37
$LN33@V_DrawClip:

; 737  : 				} while (count--);

  002ea	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  002ed	89 45 84	 mov	 DWORD PTR tv210[ebp], eax
  002f0	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  002f3	83 e9 01	 sub	 ecx, 1
  002f6	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  002f9	83 7d 84 00	 cmp	 DWORD PTR tv210[ebp], 0
  002fd	75 a7		 jne	 SHORT $LN10@V_DrawClip

; 738  : 			}

  002ff	eb 4e		 jmp	 SHORT $doneclipping$37
$LN27@V_DrawClip:

; 739  : 			else
; 740  : 			{
; 741  : 				// length is a power of two
; 742  : 				while (count--)

  00301	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00304	89 45 84	 mov	 DWORD PTR tv213[ebp], eax
  00307	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0030a	83 e9 01	 sub	 ecx, 1
  0030d	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00310	83 7d 84 00	 cmp	 DWORD PTR tv213[ebp], 0
  00314	74 39		 je	 SHORT $doneclipping$37

; 743  : 				{
; 744  : 					if (dest < deststop)

  00316	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00319	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  0031c	73 13		 jae	 SHORT $LN34@V_DrawClip

; 745  : 						*dest = source[ofs>>FRACBITS];

  0031e	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00321	c1 f8 10	 sar	 eax, 16			; 00000010H
  00324	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00327	8b 55 d0	 mov	 edx, DWORD PTR _source$[ebp]
  0032a	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0032d	88 01		 mov	 BYTE PTR [ecx], al
  0032f	eb 07		 jmp	 SHORT $LN35@V_DrawClip
$LN34@V_DrawClip:

; 746  : 					else
; 747  : 						count = 0;

  00331	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN35@V_DrawClip:

; 748  : 					dest += vid.width;

  00338	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0033b	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00341	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax

; 749  : 					ofs += rowfrac;

  00344	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00347	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  0034a	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 750  : 				}

  0034d	eb b2		 jmp	 SHORT $LN27@V_DrawClip
$doneclipping$37:

; 751  : 			}
; 752  : doneclipping:
; 753  : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  0034f	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00352	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00356	8b 55 e0	 mov	 edx, DWORD PTR _column$[ebp]
  00359	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0035d	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 754  : 		}

  00360	e9 45 fe ff ff	 jmp	 $LN5@V_DrawClip
$LN6@V_DrawClip:

; 755  : 	}

  00365	e9 0f fe ff ff	 jmp	 $LN2@V_DrawClip
$LN3@V_DrawClip:

; 756  : }

  0036a	5f		 pop	 edi
  0036b	5e		 pop	 esi
  0036c	5b		 pop	 ebx
  0036d	8b e5		 mov	 esp, ebp
  0036f	5d		 pop	 ebp
  00370	c3		 ret	 0
_V_DrawClippedScaledPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawTranslucentMappedPatch
_TEXT	SEGMENT
tv220 = -124						; size = 4
_deststop$ = -56					; size = 4
_translevel$ = -52					; size = 4
_source$ = -48						; size = 4
_dest$ = -44						; size = 4
_desttop$ = -40						; size = 4
_column$ = -36						; size = 4
_rowfrac$ = -32						; size = 4
_colfrac$ = -28						; size = 4
_ofs$ = -24						; size = 4
_dupy$ = -20						; size = 4
_dupx$ = -16						; size = 4
_w$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_colormap$ = 24						; size = 4
_V_DrawTranslucentMappedPatch PROC			; COMDAT

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 296  : 	size_t count;
; 297  : 	INT32 col, w, dupx, dupy, ofs, colfrac, rowfrac;
; 298  : 	const column_t *column;
; 299  : 	UINT8 *desttop, *dest;
; 300  : 	const UINT8 *source, *translevel, *deststop;
; 301  : 
; 302  : #ifdef HWRENDER
; 303  : 	// draw a hardware converted patch
; 304  : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 2a		 je	 SHORT $LN9@V_DrawTran
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 21		 je	 SHORT $LN9@V_DrawTran

; 305  : 	{
; 306  : 		HWR_DrawMappedPatch((GLPatch_t *)patch, x, y, scrn, colormap);

  0001b	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _HWR_DrawMappedPatch
  00034	83 c4 14	 add	 esp, 20			; 00000014H

; 307  : 		return;

  00037	e9 85 03 00 00	 jmp	 $LN3@V_DrawTran
$LN9@V_DrawTran:

; 308  : 	}
; 309  : #endif
; 310  : 
; 311  : 	if (scrn & V_8020TRANS)

  0003c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0003f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00044	74 0f		 je	 SHORT $LN10@V_DrawTran

; 312  : 		translevel = ((tr_trans80)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  0004b	05 00 00 07 00	 add	 eax, 458752		; 00070000H
  00050	89 45 cc	 mov	 DWORD PTR _translevel$[ebp], eax
  00053	eb 0d		 jmp	 SHORT $LN11@V_DrawTran
$LN10@V_DrawTran:

; 313  : 	else
; 314  : 		translevel = ((tr_trans50)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  0005a	05 00 00 04 00	 add	 eax, 262144		; 00040000H
  0005f	89 45 cc	 mov	 DWORD PTR _translevel$[ebp], eax
$LN11@V_DrawTran:

; 315  : 
; 316  : 	if (scrn & V_NOSCALEPATCH)

  00062	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00065	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0006a	74 0f		 je	 SHORT $LN12@V_DrawTran

; 317  : 		dupx = dupy = 1;

  0006c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  00073	8b 45 ec	 mov	 eax, DWORD PTR _dupy$[ebp]
  00076	89 45 f0	 mov	 DWORD PTR _dupx$[ebp], eax
  00079	eb 10		 jmp	 SHORT $LN13@V_DrawTran
$LN12@V_DrawTran:

; 318  : 	else
; 319  : 	{
; 320  : 		dupx = vid.dupx;

  0007b	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00080	89 45 f0	 mov	 DWORD PTR _dupx$[ebp], eax

; 321  : 		dupy = vid.dupy;

  00083	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00088	89 45 ec	 mov	 DWORD PTR _dupy$[ebp], eax
$LN13@V_DrawTran:

; 322  : 	}
; 323  : 
; 324  : 	y -= SHORT(patch->topoffset);

  0008b	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0008e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00092	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00095	2b d1		 sub	 edx, ecx
  00097	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 325  : 	x -= SHORT(patch->leftoffset);

  0009a	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0009d	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000a1	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000a4	2b d1		 sub	 edx, ecx
  000a6	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 326  : 
; 327  : 	if (scrn & V_NOSCALESTART)

  000a9	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000ac	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  000b1	74 4c		 je	 SHORT $LN14@V_DrawTran

; 328  : 	{
; 329  : 		desttop = screens[scrn&0xffff] + (y*vid.width) + x;

  000b3	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000b6	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000be	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  000c5	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  000cc	03 d1		 add	 edx, ecx
  000ce	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  000d1	89 55 d8	 mov	 DWORD PTR _desttop$[ebp], edx

; 330  : 		deststop = screens[scrn&0xffff] + vid.width * vid.height * vid.bpp;

  000d4	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000d7	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000dc	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  000e2	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  000e9	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  000f0	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  000f7	89 4d c8	 mov	 DWORD PTR _deststop$[ebp], ecx

; 331  : 	}

  000fa	e9 71 01 00 00	 jmp	 $LN25@V_DrawTran
$LN14@V_DrawTran:

; 332  : 	else
; 333  : 	{
; 334  : 		desttop = screens[scrn&0xffff] + (y*vid.dupy*vid.width) + (x*vid.dupx);

  000ff	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00102	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00107	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0010a	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  00111	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00118	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  0011f	03 d1		 add	 edx, ecx
  00121	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00124	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  0012b	03 d0		 add	 edx, eax
  0012d	89 55 d8	 mov	 DWORD PTR _desttop$[ebp], edx

; 335  : 		deststop = screens[scrn&0xffff] + vid.width * vid.height * vid.bpp;

  00130	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00133	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00138	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0013e	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  00145	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  0014c	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  00153	89 4d c8	 mov	 DWORD PTR _deststop$[ebp], ecx

; 336  : 
; 337  : 		// Center it if necessary
; 338  : 		if (!(scrn & V_NOSCALEPATCH))

  00156	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00159	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0015e	0f 85 0c 01 00
	00		 jne	 $LN25@V_DrawTran

; 339  : 		{
; 340  : 			if (vid.fdupx != dupx)

  00164	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupx$[ebp]
  00169	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  00171	0f 2e c8	 ucomiss xmm1, xmm0
  00174	9f		 lahf
  00175	f6 c4 44	 test	 ah, 68			; 00000044H
  00178	7b 47		 jnp	 SHORT $LN20@V_DrawTran

; 341  : 			{
; 342  : 				// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 343  : 				// so center this imaginary screen
; 344  : 				if (scrn & V_SNAPTORIGHT)

  0017a	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0017d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00182	74 17		 je	 SHORT $LN18@V_DrawTran

; 345  : 					desttop += (vid.width - (BASEVIDWIDTH * dupx));

  00184	69 45 f0 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  0018b	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00191	2b c8		 sub	 ecx, eax
  00193	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  00196	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
  00199	eb 26		 jmp	 SHORT $LN20@V_DrawTran
$LN18@V_DrawTran:

; 346  : 				else if (!(scrn & V_SNAPTOLEFT))

  0019b	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0019e	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  001a3	75 1c		 jne	 SHORT $LN20@V_DrawTran

; 347  : 					desttop += (vid.width - (BASEVIDWIDTH * dupx)) / 2;

  001a5	69 45 f0 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  001ac	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  001b2	2b c8		 sub	 ecx, eax
  001b4	8b c1		 mov	 eax, ecx
  001b6	99		 cdq
  001b7	2b c2		 sub	 eax, edx
  001b9	d1 f8		 sar	 eax, 1
  001bb	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  001be	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
$LN20@V_DrawTran:

; 348  : 			}
; 349  : 			if (vid.fdupy != dupy)

  001c1	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  001c6	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  001ce	0f 2e c8	 ucomiss xmm1, xmm0
  001d1	9f		 lahf
  001d2	f6 c4 44	 test	 ah, 68			; 00000044H
  001d5	7b 55		 jnp	 SHORT $LN24@V_DrawTran

; 350  : 			{
; 351  : 				// same thing here
; 352  : 				if (scrn & V_SNAPTOBOTTOM)

  001d7	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001da	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001df	74 1e		 je	 SHORT $LN22@V_DrawTran

; 353  : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width;

  001e1	69 45 ec c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001e8	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001ee	2b c8		 sub	 ecx, eax
  001f0	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001f7	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  001fa	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
  001fd	eb 2d		 jmp	 SHORT $LN24@V_DrawTran
$LN22@V_DrawTran:

; 354  : 				else if (!(scrn & V_SNAPTOTOP))

  001ff	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00202	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00207	75 23		 jne	 SHORT $LN24@V_DrawTran

; 355  : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width / 2;

  00209	69 45 ec c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  00210	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00216	2b c8		 sub	 ecx, eax
  00218	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0021f	8b c1		 mov	 eax, ecx
  00221	99		 cdq
  00222	2b c2		 sub	 eax, edx
  00224	d1 f8		 sar	 eax, 1
  00226	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  00229	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
$LN24@V_DrawTran:

; 356  : 			}
; 357  : 			// if it's meant to cover the whole screen, black out the rest
; 358  : 			if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT)

  0022c	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00230	75 3e		 jne	 SHORT $LN25@V_DrawTran
  00232	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00235	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00238	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  0023e	75 30		 jne	 SHORT $LN25@V_DrawTran
  00240	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  00244	75 2a		 jne	 SHORT $LN25@V_DrawTran
  00246	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00249	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0024d	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  00253	75 1b		 jne	 SHORT $LN25@V_DrawTran

; 359  : 				V_DrawFill(0, 0, vid.width, vid.height, 31);

  00255	6a 1f		 push	 31			; 0000001fH
  00257	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0025c	50		 push	 eax
  0025d	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00263	51		 push	 ecx
  00264	6a 00		 push	 0
  00266	6a 00		 push	 0
  00268	e8 00 00 00 00	 call	 _V_DrawFill
  0026d	83 c4 14	 add	 esp, 20			; 00000014H
$LN25@V_DrawTran:

; 360  : 		}
; 361  : 	}
; 362  : 	scrn &= 0xffff;

  00270	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00273	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00278	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax

; 363  : 
; 364  : 	col = 0;

  0027b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0

; 365  : 	colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  00282	8b 45 f0	 mov	 eax, DWORD PTR _dupx$[ebp]
  00285	c1 e0 10	 shl	 eax, 16			; 00000010H
  00288	50		 push	 eax
  00289	68 00 00 01 00	 push	 65536			; 00010000H
  0028e	e8 00 00 00 00	 call	 _FixedDiv
  00293	83 c4 08	 add	 esp, 8
  00296	89 45 e4	 mov	 DWORD PTR _colfrac$[ebp], eax

; 366  : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  00299	8b 45 ec	 mov	 eax, DWORD PTR _dupy$[ebp]
  0029c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0029f	50		 push	 eax
  002a0	68 00 00 01 00	 push	 65536			; 00010000H
  002a5	e8 00 00 00 00	 call	 _FixedDiv
  002aa	83 c4 08	 add	 esp, 8
  002ad	89 45 e0	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 367  : 
; 368  : 	w = SHORT(patch->width)<<FRACBITS;

  002b0	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002b3	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002b6	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002b9	89 4d f4	 mov	 DWORD PTR _w$[ebp], ecx

; 369  : 
; 370  : 	for (; col < w; col += colfrac, desttop++)

  002bc	eb 12		 jmp	 SHORT $LN4@V_DrawTran
$LN2@V_DrawTran:
  002be	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002c1	03 45 e4	 add	 eax, DWORD PTR _colfrac$[ebp]
  002c4	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  002c7	8b 4d d8	 mov	 ecx, DWORD PTR _desttop$[ebp]
  002ca	83 c1 01	 add	 ecx, 1
  002cd	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawTran:
  002d0	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002d3	3b 45 f4	 cmp	 eax, DWORD PTR _w$[ebp]
  002d6	0f 8d e5 00 00
	00		 jge	 $LN3@V_DrawTran

; 371  : 	{
; 372  : 		column = (const column_t *)((const UINT8 *)patch + LONG(patch->columnofs[col>>FRACBITS]));

  002dc	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002df	c1 f8 10	 sar	 eax, 16			; 00000010H
  002e2	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  002e5	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  002e8	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  002ec	89 55 dc	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawTran:

; 373  : 
; 374  : 		while (column->topdelta != 0xff)

  002ef	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002f2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002f5	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002fb	0f 84 bb 00 00
	00		 je	 $LN6@V_DrawTran

; 375  : 		{
; 376  : 			source = (const UINT8 *)column + 3;

  00301	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  00304	83 c0 03	 add	 eax, 3
  00307	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 377  : 			dest = desttop + column->topdelta*dupy*vid.width;

  0030a	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  0030d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00310	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  00314	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0031b	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  0031e	89 4d d4	 mov	 DWORD PTR _dest$[ebp], ecx

; 378  : 			count = column->length*dupy;

  00321	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  00324	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00328	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  0032c	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 379  : 
; 380  : 			ofs = 0;

  0032f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0
$LN7@V_DrawTran:

; 381  : 			while (count--)

  00336	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00339	89 45 84	 mov	 DWORD PTR tv220[ebp], eax
  0033c	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0033f	83 e9 01	 sub	 ecx, 1
  00342	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00345	83 7d 84 00	 cmp	 DWORD PTR tv220[ebp], 0
  00349	74 5b		 je	 SHORT $LN8@V_DrawTran

; 382  : 			{
; 383  : 				if (dest < deststop)

  0034b	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  0034e	3b 45 c8	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00351	73 35		 jae	 SHORT $LN26@V_DrawTran

; 384  : 					*dest = *(translevel + (((*(colormap + source[ofs>>FRACBITS]))<<8)&0xff00) + (*dest&0xff));

  00353	8b 45 e8	 mov	 eax, DWORD PTR _ofs$[ebp]
  00356	c1 f8 10	 sar	 eax, 16			; 00000010H
  00359	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  0035c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00360	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  00363	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00367	c1 e1 08	 shl	 ecx, 8
  0036a	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00370	03 4d cc	 add	 ecx, DWORD PTR _translevel$[ebp]
  00373	8b 55 d4	 mov	 edx, DWORD PTR _dest$[ebp]
  00376	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00379	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0037e	8b 55 d4	 mov	 edx, DWORD PTR _dest$[ebp]
  00381	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00384	88 02		 mov	 BYTE PTR [edx], al
  00386	eb 07		 jmp	 SHORT $LN27@V_DrawTran
$LN26@V_DrawTran:

; 385  : 				else
; 386  : 					count = 0;

  00388	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN27@V_DrawTran:

; 387  : 				dest += vid.width;

  0038f	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00392	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00398	89 45 d4	 mov	 DWORD PTR _dest$[ebp], eax

; 388  : 				ofs += rowfrac;

  0039b	8b 45 e8	 mov	 eax, DWORD PTR _ofs$[ebp]
  0039e	03 45 e0	 add	 eax, DWORD PTR _rowfrac$[ebp]
  003a1	89 45 e8	 mov	 DWORD PTR _ofs$[ebp], eax

; 389  : 			}

  003a4	eb 90		 jmp	 SHORT $LN7@V_DrawTran
$LN8@V_DrawTran:

; 390  : 
; 391  : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  003a6	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  003a9	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003ad	8b 55 dc	 mov	 edx, DWORD PTR _column$[ebp]
  003b0	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  003b4	89 45 dc	 mov	 DWORD PTR _column$[ebp], eax

; 392  : 		}

  003b7	e9 33 ff ff ff	 jmp	 $LN5@V_DrawTran
$LN6@V_DrawTran:

; 393  : 	}

  003bc	e9 fd fe ff ff	 jmp	 $LN2@V_DrawTran
$LN3@V_DrawTran:

; 394  : }

  003c1	5f		 pop	 edi
  003c2	5e		 pop	 esi
  003c3	5b		 pop	 ebx
  003c4	8b e5		 mov	 esp, ebp
  003c6	5d		 pop	 ebp
  003c7	c3		 ret	 0
_V_DrawTranslucentMappedPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _LoadMapPalette
_TEXT	SEGMENT
_LoadMapPalette PROC					; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 206  : 	LoadPalette(GetPalette());

  00009	e8 00 00 00 00	 call	 _GetPalette
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _LoadPalette
  00014	83 c4 04	 add	 esp, 4

; 207  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_LoadMapPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _LoadPalette
_TEXT	SEGMENT
_pal$ = -20						; size = 4
_palsize$ = -16						; size = 4
_i$ = -12						; size = 4
_lumpnum$ = -8						; size = 4
_usegamma$ = -4						; size = 4
_lumpname$ = 8						; size = 4
_LoadPalette PROC					; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 166  : 	const UINT8 *usegamma = gammatable[cv_usegamma.value];

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_usegamma+20
  0000e	c1 e0 08	 shl	 eax, 8
  00011	05 00 00 00 00	 add	 eax, OFFSET _gammatable
  00016	89 45 fc	 mov	 DWORD PTR _usegamma$[ebp], eax

; 167  : 	lumpnum_t lumpnum = W_GetNumForName(lumpname);

  00019	8b 45 08	 mov	 eax, DWORD PTR _lumpname$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _W_GetNumForName
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 f8	 mov	 DWORD PTR _lumpnum$[ebp], eax

; 168  : 	size_t i, palsize = W_LumpLength(lumpnum)/3;

  00028	8b 45 f8	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _W_LumpLength
  00031	83 c4 04	 add	 esp, 4
  00034	33 d2		 xor	 edx, edx
  00036	b9 03 00 00 00	 mov	 ecx, 3
  0003b	f7 f1		 div	 ecx
  0003d	89 45 f0	 mov	 DWORD PTR _palsize$[ebp], eax

; 169  : 	UINT8 *pal;
; 170  : 
; 171  : 	Z_Free(pLocalPalette);

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLocalPalette
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _Z_Free
  0004b	83 c4 04	 add	 esp, 4

; 172  : 
; 173  : 	pLocalPalette = Z_Malloc(sizeof (*pLocalPalette)*palsize, PU_STATIC, NULL);

  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	6a 01		 push	 1
  00054	8b 45 f0	 mov	 eax, DWORD PTR _palsize$[ebp]
  00057	c1 e0 02	 shl	 eax, 2
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _Z_MallocAlign
  00060	83 c4 10	 add	 esp, 16			; 00000010H
  00063	a3 00 00 00 00	 mov	 DWORD PTR _pLocalPalette, eax

; 174  : 
; 175  : 	pal = W_CacheLumpNum(lumpnum, PU_CACHE);

  00068	6a 65		 push	 101			; 00000065H
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00073	83 c4 08	 add	 esp, 8
  00076	89 45 ec	 mov	 DWORD PTR _pal$[ebp], eax

; 176  : 	for (i = 0; i < palsize; i++)

  00079	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00080	eb 09		 jmp	 SHORT $LN4@LoadPalett
$LN2@LoadPalett:
  00082	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@LoadPalett:
  0008b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0008e	3b 45 f0	 cmp	 eax, DWORD PTR _palsize$[ebp]
  00091	73 75		 jae	 SHORT $LN3@LoadPalett

; 177  : 	{
; 178  : 		pLocalPalette[i].s.red = usegamma[*pal++];

  00093	8b 45 ec	 mov	 eax, DWORD PTR _pal$[ebp]
  00096	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00099	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLocalPalette
  000a1	8b 75 fc	 mov	 esi, DWORD PTR _usegamma$[ebp]
  000a4	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  000a7	88 0c 90	 mov	 BYTE PTR [eax+edx*4], cl
  000aa	8b 55 ec	 mov	 edx, DWORD PTR _pal$[ebp]
  000ad	83 c2 01	 add	 edx, 1
  000b0	89 55 ec	 mov	 DWORD PTR _pal$[ebp], edx

; 179  : 		pLocalPalette[i].s.green = usegamma[*pal++];

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _pal$[ebp]
  000b6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000b9	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLocalPalette
  000c1	8b 75 fc	 mov	 esi, DWORD PTR _usegamma$[ebp]
  000c4	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  000c7	88 4c 90 01	 mov	 BYTE PTR [eax+edx*4+1], cl
  000cb	8b 55 ec	 mov	 edx, DWORD PTR _pal$[ebp]
  000ce	83 c2 01	 add	 edx, 1
  000d1	89 55 ec	 mov	 DWORD PTR _pal$[ebp], edx

; 180  : 		pLocalPalette[i].s.blue = usegamma[*pal++];

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _pal$[ebp]
  000d7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000da	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLocalPalette
  000e2	8b 75 fc	 mov	 esi, DWORD PTR _usegamma$[ebp]
  000e5	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  000e8	88 4c 90 02	 mov	 BYTE PTR [eax+edx*4+2], cl
  000ec	8b 55 ec	 mov	 edx, DWORD PTR _pal$[ebp]
  000ef	83 c2 01	 add	 edx, 1
  000f2	89 55 ec	 mov	 DWORD PTR _pal$[ebp], edx

; 181  : 		pLocalPalette[i].s.alpha = 0xFF;

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  000fe	c6 44 81 03 ff	 mov	 BYTE PTR [ecx+eax*4+3], 255 ; 000000ffH

; 182  : 	}

  00103	e9 7a ff ff ff	 jmp	 $LN2@LoadPalett
$LN3@LoadPalett:

; 183  : }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
_LoadPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _CV_Gammaxxx_ONChange
_TEXT	SEGMENT
_CV_Gammaxxx_ONChange PROC				; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 254  : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 13		 je	 SHORT $LN2@CV_Gammaxx
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 0a		 je	 SHORT $LN2@CV_Gammaxx

; 255  : 		V_SetPalette(0);

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 _V_SetPalette
  00022	83 c4 04	 add	 esp, 4
$LN2@CV_Gammaxx:

; 256  : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_CV_Gammaxxx_ONChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _CV_usegamma_OnChange
_TEXT	SEGMENT
_CV_usegamma_OnChange PROC				; COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 245  : 	// reload palette
; 246  : 	LoadMapPalette();

  00009	e8 00 00 00 00	 call	 _LoadMapPalette
  0000e	90		 npad	 1

; 247  : 	V_SetPalette(0);

  0000f	6a 00		 push	 0
  00011	e8 00 00 00 00	 call	 _V_SetPalette
  00016	83 c4 04	 add	 esp, 4

; 248  : }

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
_CV_usegamma_OnChange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _VID_BlitLinearScreen
_TEXT	SEGMENT
tv71 = -68						; size = 4
_srcptr$ = 8						; size = 4
_destptr$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_srcrowbytes$ = 24					; size = 4
_destrowbytes$ = 28					; size = 4
_VID_BlitLinearScreen PROC				; COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 273  : #ifdef HAVE_VIDCOPY
; 274  :     VID_BlitLinearScreen_ASM(srcptr,destptr,width,height,srcrowbytes,destrowbytes);
; 275  : #else
; 276  : 	if (srcrowbytes == destrowbytes)

  00009	8b 45 18	 mov	 eax, DWORD PTR _srcrowbytes$[ebp]
  0000c	3b 45 1c	 cmp	 eax, DWORD PTR _destrowbytes$[ebp]
  0000f	75 1b		 jne	 SHORT $LN4@VID_BlitLi

; 277  : 		M_Memcpy(destptr, srcptr, srcrowbytes * height);

  00011	8b 45 18	 mov	 eax, DWORD PTR _srcrowbytes$[ebp]
  00014	0f af 45 14	 imul	 eax, DWORD PTR _height$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _srcptr$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _destptr$[ebp]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	eb 3e		 jmp	 SHORT $LN3@VID_BlitLi
$LN4@VID_BlitLi:

; 278  : 	else
; 279  : 	{
; 280  : 		while (height--)

  0002c	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]
  0002f	89 45 bc	 mov	 DWORD PTR tv71[ebp], eax
  00032	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  00035	83 e9 01	 sub	 ecx, 1
  00038	89 4d 14	 mov	 DWORD PTR _height$[ebp], ecx
  0003b	83 7d bc 00	 cmp	 DWORD PTR tv71[ebp], 0
  0003f	74 29		 je	 SHORT $LN3@VID_BlitLi

; 281  : 		{
; 282  : 			M_Memcpy(destptr, srcptr, width);

  00041	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _srcptr$[ebp]
  00048	51		 push	 ecx
  00049	8b 55 0c	 mov	 edx, DWORD PTR _destptr$[ebp]
  0004c	52		 push	 edx
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 283  : 
; 284  : 			destptr += destrowbytes;

  00056	8b 45 0c	 mov	 eax, DWORD PTR _destptr$[ebp]
  00059	03 45 1c	 add	 eax, DWORD PTR _destrowbytes$[ebp]
  0005c	89 45 0c	 mov	 DWORD PTR _destptr$[ebp], eax

; 285  : 			srcptr += srcrowbytes;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _srcptr$[ebp]
  00062	03 45 18	 add	 eax, DWORD PTR _srcrowbytes$[ebp]
  00065	89 45 08	 mov	 DWORD PTR _srcptr$[ebp], eax

; 286  : 		}

  00068	eb c2		 jmp	 SHORT $LN4@VID_BlitLi
$LN3@VID_BlitLi:

; 287  : 	}
; 288  : #endif
; 289  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_VID_BlitLinearScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawPatchFill
_TEXT	SEGMENT
_ph$ = -16						; size = 4
_pw$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_pat$ = 8						; size = 4
_V_DrawPatchFill PROC					; COMDAT

; 1820 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1821 : 	INT32 x, y, pw = SHORT(pat->width) * vid.dupx, ph = SHORT(pat->height) * vid.dupy;

  00009	8b 45 08	 mov	 eax, DWORD PTR _pat$[ebp]
  0000c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0000f	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR _vid+32
  00016	89 4d f4	 mov	 DWORD PTR _pw$[ebp], ecx
  00019	8b 45 08	 mov	 eax, DWORD PTR _pat$[ebp]
  0001c	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00020	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  00027	89 4d f0	 mov	 DWORD PTR _ph$[ebp], ecx

; 1822 : 
; 1823 : 	for (x = 0; x < vid.width; x += pw)

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@V_DrawPatc
$LN2@V_DrawPatc:
  00033	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00036	03 45 f4	 add	 eax, DWORD PTR _pw$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN4@V_DrawPatc:
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0003f	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  00045	7d 71		 jge	 SHORT $LN3@V_DrawPatc

; 1824 : 	{
; 1825 : 		for (y = 0; y < vid.height; y += ph)

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0004e	eb 09		 jmp	 SHORT $LN7@V_DrawPatc
$LN5@V_DrawPatc:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00053	03 45 f0	 add	 eax, DWORD PTR _ph$[ebp]
  00056	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN7@V_DrawPatc:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0005c	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00062	7d 4f		 jge	 SHORT $LN6@V_DrawPatc

; 1826 : 		{
; 1827 : 			if (x + pw >= vid.width || y + ph >= vid.height)

  00064	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00067	03 45 f4	 add	 eax, DWORD PTR _pw$[ebp]
  0006a	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  00070	7d 0e		 jge	 SHORT $LN10@V_DrawPatc
  00072	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00075	03 45 f0	 add	 eax, DWORD PTR _ph$[ebp]
  00078	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  0007e	7c 18		 jl	 SHORT $LN8@V_DrawPatc
$LN10@V_DrawPatc:

; 1828 : 				V_DrawClippedScaledPatch(x, y, 0, pat); // V_NOSCALESTART is implied

  00080	8b 45 08	 mov	 eax, DWORD PTR _pat$[ebp]
  00083	50		 push	 eax
  00084	6a 00		 push	 0
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _x$[ebp]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 _V_DrawClippedScaledPatch
  00093	83 c4 10	 add	 esp, 16			; 00000010H
  00096	eb 19		 jmp	 SHORT $LN9@V_DrawPatc
$LN8@V_DrawPatc:

; 1829 : 			else
; 1830 : 				V_DrawScaledPatch(x, y, V_NOSCALESTART, pat);

  00098	8b 45 08	 mov	 eax, DWORD PTR _pat$[ebp]
  0009b	50		 push	 eax
  0009c	68 00 00 01 00	 push	 65536			; 00010000H
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 fc	 mov	 edx, DWORD PTR _x$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@V_DrawPatc:

; 1831 : 		}

  000b1	eb 9d		 jmp	 SHORT $LN5@V_DrawPatc
$LN6@V_DrawPatc:

; 1832 : 	}

  000b3	e9 7b ff ff ff	 jmp	 $LN2@V_DrawPatc
$LN3@V_DrawPatc:

; 1833 : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_V_DrawPatchFill ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DoPostProcessor
_TEXT	SEGMENT
tv271 = -140						; size = 4
_y$1 = -72						; size = 4
_srcscr$2 = -68						; size = 4
_tmpscr$3 = -64						; size = 4
_y2$4 = -60						; size = 4
_y$5 = -56						; size = 4
_srcscr$6 = -52						; size = 4
_tmpscr$7 = -48						; size = 4
_transme$8 = -44					; size = 4
_y$9 = -40						; size = 4
_x$10 = -36						; size = 4
_srcscr$11 = -32					; size = 4
_tmpscr$12 = -28					; size = 4
_westart$13 = -24					; size = 4
_sine$14 = -20						; size = 4
_newpix$15 = -16					; size = 4
_y$16 = -12						; size = 4
_srcscr$17 = -8						; size = 4
_tmpscr$18 = -4						; size = 4
_type$ = 8						; size = 4
_V_DoPostProcessor PROC					; COMDAT

; 2438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2439 : #ifdef HWRENDER
; 2440 : 	// draw a hardware converted patch
; 2441 : 	if (rendermode != render_soft && rendermode != render_none)

  0000c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00013	74 0e		 je	 SHORT $LN24@V_DoPostPr
  00015	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0001c	74 05		 je	 SHORT $LN24@V_DoPostPr

; 2442 : 		return;

  0001e	e9 ea 05 00 00	 jmp	 $LN34@V_DoPostPr
$LN24@V_DoPostPr:

; 2443 : #endif
; 2444 : 
; 2445 : #if NUMSCREENS < 4
; 2446 : 	return; // do not enable image post processing for ARM, SH and MIPS CPUs
; 2447 : #endif
; 2448 : 
; 2449 : 	if (splitscreen) // Not supported in splitscreen - someone want to add support?

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0002a	74 05		 je	 SHORT $LN25@V_DoPostPr

; 2450 : 		return;

  0002c	e9 dc 05 00 00	 jmp	 $LN34@V_DoPostPr
$LN25@V_DoPostPr:

; 2451 : 
; 2452 : 	if (type == postimg_water)

  00031	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  00035	0f 85 d4 01 00
	00		 jne	 $LN26@V_DoPostPr

; 2453 : 	{
; 2454 : 			UINT8 *tmpscr = screens[4];

  0003b	b8 04 00 00 00	 mov	 eax, 4
  00040	c1 e0 02	 shl	 eax, 2
  00043	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  00049	89 4d fc	 mov	 DWORD PTR _tmpscr$18[ebp], ecx

; 2455 : 			UINT8 *srcscr = screens[0];

  0004c	b8 04 00 00 00	 mov	 eax, 4
  00051	6b c8 00	 imul	 ecx, eax, 0
  00054	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  0005a	89 55 f8	 mov	 DWORD PTR _srcscr$17[ebp], edx

; 2456 : 			INT32 y;
; 2457 : 			static angle_t disStart = 0; // in 0 to FINEANGLE
; 2458 : 			INT32 newpix;
; 2459 : 			INT32 sine;
; 2460 : 			INT32 westart = disStart;

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9
  00062	89 45 e8	 mov	 DWORD PTR _westart$13[ebp], eax

; 2461 : 			//UINT8 *transme = ((tr_trans50)<<FF_TRANSSHIFT) + transtables;
; 2462 : 
; 2463 : 			for (y = 0; y < vid.height; y++)

  00065	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$16[ebp], 0
  0006c	eb 09		 jmp	 SHORT $LN4@V_DoPostPr
$LN2@V_DoPostPr:
  0006e	8b 45 f4	 mov	 eax, DWORD PTR _y$16[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 f4	 mov	 DWORD PTR _y$16[ebp], eax
$LN4@V_DoPostPr:
  00077	8b 45 f4	 mov	 eax, DWORD PTR _y$16[ebp]
  0007a	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00080	0f 8d 25 01 00
	00		 jge	 $LN3@V_DoPostPr

; 2464 : 			{
; 2465 : 				sine = (FINESINE(disStart)*5)>>FRACBITS;

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9
  0008b	6b 0c 85 00 00
	00 00 05	 imul	 ecx, DWORD PTR _finesine[eax*4], 5
  00093	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00096	89 4d ec	 mov	 DWORD PTR _sine$14[ebp], ecx

; 2466 : 				newpix = abs(sine);

  00099	8b 45 ec	 mov	 eax, DWORD PTR _sine$14[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _abs
  000a2	83 c4 04	 add	 esp, 4
  000a5	89 45 f0	 mov	 DWORD PTR _newpix$15[ebp], eax

; 2467 : 
; 2468 : 				if (sine < 0)

  000a8	83 7d ec 00	 cmp	 DWORD PTR _sine$14[ebp], 0
  000ac	7d 67		 jge	 SHORT $LN28@V_DoPostPr

; 2469 : 				{
; 2470 : 					M_Memcpy(&tmpscr[y*vid.width+newpix], &srcscr[y*vid.width], vid.width-newpix);

  000ae	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000b3	2b 45 f0	 sub	 eax, DWORD PTR _newpix$15[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _y$16[ebp]
  000ba	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  000c1	03 4d f8	 add	 ecx, DWORD PTR _srcscr$17[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 f4	 mov	 edx, DWORD PTR _y$16[ebp]
  000c8	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  000cf	03 55 f0	 add	 edx, DWORD PTR _newpix$15[ebp]
  000d2	03 55 fc	 add	 edx, DWORD PTR _tmpscr$18[ebp]
  000d5	52		 push	 edx
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@V_DoPostPr:

; 2471 : 
; 2472 : 					// Cleanup edge
; 2473 : 					while (newpix)

  000df	83 7d f0 00	 cmp	 DWORD PTR _newpix$15[ebp], 0
  000e3	74 2e		 je	 SHORT $LN6@V_DoPostPr

; 2474 : 					{
; 2475 : 						tmpscr[y*vid.width+newpix] = srcscr[y*vid.width];

  000e5	8b 45 f4	 mov	 eax, DWORD PTR _y$16[ebp]
  000e8	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR _y$16[ebp]
  000f2	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  000f9	03 4d f0	 add	 ecx, DWORD PTR _newpix$15[ebp]
  000fc	8b 55 fc	 mov	 edx, DWORD PTR _tmpscr$18[ebp]
  000ff	8b 75 f8	 mov	 esi, DWORD PTR _srcscr$17[ebp]
  00102	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00105	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2476 : 						newpix--;

  00108	8b 45 f0	 mov	 eax, DWORD PTR _newpix$15[ebp]
  0010b	83 e8 01	 sub	 eax, 1
  0010e	89 45 f0	 mov	 DWORD PTR _newpix$15[ebp], eax

; 2477 : 					}

  00111	eb cc		 jmp	 SHORT $LN5@V_DoPostPr
$LN6@V_DoPostPr:

; 2478 : 				}

  00113	eb 75		 jmp	 SHORT $LN8@V_DoPostPr
$LN28@V_DoPostPr:

; 2479 : 				else
; 2480 : 				{
; 2481 : 					M_Memcpy(&tmpscr[y*vid.width+0], &srcscr[y*vid.width+sine], vid.width-newpix);

  00115	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0011a	2b 45 f0	 sub	 eax, DWORD PTR _newpix$15[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d f4	 mov	 ecx, DWORD PTR _y$16[ebp]
  00121	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00128	03 4d ec	 add	 ecx, DWORD PTR _sine$14[ebp]
  0012b	03 4d f8	 add	 ecx, DWORD PTR _srcscr$17[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 f4	 mov	 edx, DWORD PTR _y$16[ebp]
  00132	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  00139	03 55 fc	 add	 edx, DWORD PTR _tmpscr$18[ebp]
  0013c	52		 push	 edx
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@V_DoPostPr:

; 2482 : 
; 2483 : 					// Cleanup edge
; 2484 : 					while (newpix)

  00146	83 7d f0 00	 cmp	 DWORD PTR _newpix$15[ebp], 0
  0014a	74 3e		 je	 SHORT $LN8@V_DoPostPr

; 2485 : 					{
; 2486 : 						tmpscr[y*vid.width+vid.width-newpix] = srcscr[y*vid.width+(vid.width-1)];

  0014c	8b 45 f4	 mov	 eax, DWORD PTR _y$16[ebp]
  0014f	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00156	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0015c	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  00160	8b 45 f4	 mov	 eax, DWORD PTR _y$16[ebp]
  00163	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0016a	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00170	2b 45 f0	 sub	 eax, DWORD PTR _newpix$15[ebp]
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _tmpscr$18[ebp]
  00176	8b 75 f8	 mov	 esi, DWORD PTR _srcscr$17[ebp]
  00179	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0017c	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2487 : 						newpix--;

  0017f	8b 45 f0	 mov	 eax, DWORD PTR _newpix$15[ebp]
  00182	83 e8 01	 sub	 eax, 1
  00185	89 45 f0	 mov	 DWORD PTR _newpix$15[ebp], eax

; 2488 : 					}

  00188	eb bc		 jmp	 SHORT $LN7@V_DoPostPr
$LN8@V_DoPostPr:

; 2489 : 				}
; 2490 : 
; 2491 : /*
; 2492 : Unoptimized version
; 2493 : 				for (x = 0; x < vid.width*vid.bpp; x++)
; 2494 : 				{
; 2495 : 					newpix = (x + sine);
; 2496 : 
; 2497 : 					if (newpix < 0)
; 2498 : 						newpix = 0;
; 2499 : 					else if (newpix >= vid.width)
; 2500 : 						newpix = vid.width-1;
; 2501 : 
; 2502 : 					tmpscr[y*vid.width + x] = srcscr[y*vid.width+newpix]; // *(transme + (srcscr[y*vid.width+x]<<8) + srcscr[y*vid.width+newpix]);
; 2503 : 				}*/
; 2504 : 				disStart += 22;//the offset into the displacement map, increment each game loop

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9
  0018f	83 c0 16	 add	 eax, 22			; 00000016H
  00192	a3 00 00 00 00	 mov	 DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9, eax

; 2505 : 				disStart &= FINEMASK; //clip it to FINEMASK

  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9
  0019c	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  001a1	a3 00 00 00 00	 mov	 DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9, eax

; 2506 : 			}

  001a6	e9 c3 fe ff ff	 jmp	 $LN2@V_DoPostPr
$LN3@V_DoPostPr:

; 2507 : 
; 2508 : 			disStart = westart + 128;

  001ab	8b 45 e8	 mov	 eax, DWORD PTR _westart$13[ebp]
  001ae	05 80 00 00 00	 add	 eax, 128		; 00000080H
  001b3	a3 00 00 00 00	 mov	 DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9, eax

; 2509 : 			disStart &= FINEMASK;

  001b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9
  001bd	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  001c2	a3 00 00 00 00	 mov	 DWORD PTR ?disStart@?2??V_DoPostProcessor@@9@9, eax

; 2510 : 
; 2511 : 			VID_BlitLinearScreen(tmpscr, screens[0], vid.width*vid.bpp, vid.height, vid.width*vid.bpp, vid.width);

  001c7	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  001cc	50		 push	 eax
  001cd	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  001d3	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  001da	51		 push	 ecx
  001db	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  001e1	52		 push	 edx
  001e2	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  001e7	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  001ee	50		 push	 eax
  001ef	b9 04 00 00 00	 mov	 ecx, 4
  001f4	6b d1 00	 imul	 edx, ecx, 0
  001f7	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _screens[edx]
  001fd	50		 push	 eax
  001fe	8b 4d fc	 mov	 ecx, DWORD PTR _tmpscr$18[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  00207	83 c4 18	 add	 esp, 24			; 00000018H

; 2512 : 	}

  0020a	e9 fe 03 00 00	 jmp	 $LN34@V_DoPostPr
$LN26@V_DoPostPr:

; 2513 : 	else if (type == postimg_motion) // Motion Blur!

  0020f	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  00213	0f 85 11 01 00
	00		 jne	 $LN30@V_DoPostPr

; 2514 : 	{
; 2515 : 		UINT8 *tmpscr = screens[4];

  00219	b8 04 00 00 00	 mov	 eax, 4
  0021e	c1 e0 02	 shl	 eax, 2
  00221	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  00227	89 4d e4	 mov	 DWORD PTR _tmpscr$12[ebp], ecx

; 2516 : 		UINT8 *srcscr = screens[0];

  0022a	b8 04 00 00 00	 mov	 eax, 4
  0022f	6b c8 00	 imul	 ecx, eax, 0
  00232	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  00238	89 55 e0	 mov	 DWORD PTR _srcscr$11[ebp], edx

; 2517 : 		INT32 x, y;
; 2518 : 
; 2519 : 		// TODO: Add a postimg_param so that we can pick the translucency level...
; 2520 : 		UINT8 *transme = ((postimgparam)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  0023b	a1 00 00 00 00	 mov	 eax, DWORD PTR _postimgparam
  00240	c1 e0 10	 shl	 eax, 16			; 00000010H
  00243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _transtables
  00249	8d 94 01 00 00
	ff ff		 lea	 edx, DWORD PTR [ecx+eax-65536]
  00250	89 55 d4	 mov	 DWORD PTR _transme$8[ebp], edx

; 2521 : 
; 2522 : 		for (y = 0; y < vid.height; y++)

  00253	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _y$9[ebp], 0
  0025a	eb 09		 jmp	 SHORT $LN11@V_DoPostPr
$LN9@V_DoPostPr:
  0025c	8b 45 d8	 mov	 eax, DWORD PTR _y$9[ebp]
  0025f	83 c0 01	 add	 eax, 1
  00262	89 45 d8	 mov	 DWORD PTR _y$9[ebp], eax
$LN11@V_DoPostPr:
  00265	8b 45 d8	 mov	 eax, DWORD PTR _y$9[ebp]
  00268	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  0026e	7d 72		 jge	 SHORT $LN10@V_DoPostPr

; 2523 : 		{
; 2524 : 			for (x = 0; x < vid.width; x++)

  00270	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _x$10[ebp], 0
  00277	eb 09		 jmp	 SHORT $LN14@V_DoPostPr
$LN12@V_DoPostPr:
  00279	8b 45 dc	 mov	 eax, DWORD PTR _x$10[ebp]
  0027c	83 c0 01	 add	 eax, 1
  0027f	89 45 dc	 mov	 DWORD PTR _x$10[ebp], eax
$LN14@V_DoPostPr:
  00282	8b 45 dc	 mov	 eax, DWORD PTR _x$10[ebp]
  00285	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  0028b	7d 50		 jge	 SHORT $LN13@V_DoPostPr

; 2525 : 			{
; 2526 : 				tmpscr[y*vid.width + x]

  0028d	8b 45 d8	 mov	 eax, DWORD PTR _y$9[ebp]
  00290	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00297	03 45 dc	 add	 eax, DWORD PTR _x$10[ebp]
  0029a	8b 4d e0	 mov	 ecx, DWORD PTR _srcscr$11[ebp]
  0029d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002a1	c1 e2 08	 shl	 edx, 8
  002a4	03 55 d4	 add	 edx, DWORD PTR _transme$8[ebp]
  002a7	8b 45 d8	 mov	 eax, DWORD PTR _y$9[ebp]
  002aa	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  002b1	03 45 dc	 add	 eax, DWORD PTR _x$10[ebp]
  002b4	8b 4d e4	 mov	 ecx, DWORD PTR _tmpscr$12[ebp]
  002b7	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  002bb	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  002bf	8b 55 d8	 mov	 edx, DWORD PTR _y$9[ebp]
  002c2	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  002c9	03 55 dc	 add	 edx, DWORD PTR _x$10[ebp]
  002cc	8b 45 e4	 mov	 eax, DWORD PTR _tmpscr$12[ebp]
  002cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _colormaps
  002d5	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  002d8	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 2527 : 					=     colormaps[*(transme     + (srcscr   [y*vid.width+x ] <<8) + (tmpscr[y*vid.width+x]))];
; 2528 : 			}

  002db	eb 9c		 jmp	 SHORT $LN12@V_DoPostPr
$LN13@V_DoPostPr:

; 2529 : 		}

  002dd	e9 7a ff ff ff	 jmp	 $LN9@V_DoPostPr
$LN10@V_DoPostPr:

; 2530 : 		VID_BlitLinearScreen(tmpscr, screens[0], vid.width*vid.bpp, vid.height, vid.width*vid.bpp, vid.width);

  002e2	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  002e7	50		 push	 eax
  002e8	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  002ee	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  002f5	51		 push	 ecx
  002f6	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  002fc	52		 push	 edx
  002fd	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00302	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  00309	50		 push	 eax
  0030a	b9 04 00 00 00	 mov	 ecx, 4
  0030f	6b d1 00	 imul	 edx, ecx, 0
  00312	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _screens[edx]
  00318	50		 push	 eax
  00319	8b 4d e4	 mov	 ecx, DWORD PTR _tmpscr$12[ebp]
  0031c	51		 push	 ecx
  0031d	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  00322	83 c4 18	 add	 esp, 24			; 00000018H

; 2531 : 	}

  00325	e9 e3 02 00 00	 jmp	 $LN34@V_DoPostPr
$LN30@V_DoPostPr:

; 2532 : 	else if (type == postimg_flip) // Flip the screen upside-down

  0032a	83 7d 08 03	 cmp	 DWORD PTR _type$[ebp], 3
  0032e	0f 85 c8 00 00
	00		 jne	 $LN32@V_DoPostPr

; 2533 : 	{
; 2534 : 		UINT8 *tmpscr = screens[4];

  00334	b8 04 00 00 00	 mov	 eax, 4
  00339	c1 e0 02	 shl	 eax, 2
  0033c	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  00342	89 4d d0	 mov	 DWORD PTR _tmpscr$7[ebp], ecx

; 2535 : 		UINT8 *srcscr = screens[0];

  00345	b8 04 00 00 00	 mov	 eax, 4
  0034a	6b c8 00	 imul	 ecx, eax, 0
  0034d	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  00353	89 55 cc	 mov	 DWORD PTR _srcscr$6[ebp], edx

; 2536 : 		INT32 y, y2;
; 2537 : 
; 2538 : 		for (y = 0, y2 = vid.height - 1; y < vid.height; y++, y2--)

  00356	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _y$5[ebp], 0
  0035d	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00362	83 e8 01	 sub	 eax, 1
  00365	89 45 c4	 mov	 DWORD PTR _y2$4[ebp], eax
  00368	eb 12		 jmp	 SHORT $LN17@V_DoPostPr
$LN15@V_DoPostPr:
  0036a	8b 45 c8	 mov	 eax, DWORD PTR _y$5[ebp]
  0036d	83 c0 01	 add	 eax, 1
  00370	89 45 c8	 mov	 DWORD PTR _y$5[ebp], eax
  00373	8b 4d c4	 mov	 ecx, DWORD PTR _y2$4[ebp]
  00376	83 e9 01	 sub	 ecx, 1
  00379	89 4d c4	 mov	 DWORD PTR _y2$4[ebp], ecx
$LN17@V_DoPostPr:
  0037c	8b 45 c8	 mov	 eax, DWORD PTR _y$5[ebp]
  0037f	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00385	7d 2d		 jge	 SHORT $LN16@V_DoPostPr

; 2539 : 			M_Memcpy(&tmpscr[y2*vid.width], &srcscr[y*vid.width], vid.width);

  00387	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0038c	50		 push	 eax
  0038d	8b 4d c8	 mov	 ecx, DWORD PTR _y$5[ebp]
  00390	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00397	03 4d cc	 add	 ecx, DWORD PTR _srcscr$6[ebp]
  0039a	51		 push	 ecx
  0039b	8b 55 c4	 mov	 edx, DWORD PTR _y2$4[ebp]
  0039e	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  003a5	03 55 d0	 add	 edx, DWORD PTR _tmpscr$7[ebp]
  003a8	52		 push	 edx
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  003af	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b2	eb b6		 jmp	 SHORT $LN15@V_DoPostPr
$LN16@V_DoPostPr:

; 2540 : 
; 2541 : 		VID_BlitLinearScreen(tmpscr, screens[0], vid.width*vid.bpp, vid.height, vid.width*vid.bpp, vid.width);

  003b4	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  003b9	50		 push	 eax
  003ba	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  003c0	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  003c7	51		 push	 ecx
  003c8	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  003ce	52		 push	 edx
  003cf	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  003d4	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  003db	50		 push	 eax
  003dc	b9 04 00 00 00	 mov	 ecx, 4
  003e1	6b d1 00	 imul	 edx, ecx, 0
  003e4	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _screens[edx]
  003ea	50		 push	 eax
  003eb	8b 4d d0	 mov	 ecx, DWORD PTR _tmpscr$7[ebp]
  003ee	51		 push	 ecx
  003ef	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  003f4	83 c4 18	 add	 esp, 24			; 00000018H

; 2542 : 	}

  003f7	e9 11 02 00 00	 jmp	 $LN34@V_DoPostPr
$LN32@V_DoPostPr:

; 2543 : 	else if (type == postimg_heat) // Heat wave

  003fc	83 7d 08 04	 cmp	 DWORD PTR _type$[ebp], 4
  00400	0f 85 07 02 00
	00		 jne	 $LN34@V_DoPostPr

; 2544 : 	{
; 2545 : 		UINT8 *tmpscr = screens[4];

  00406	b8 04 00 00 00	 mov	 eax, 4
  0040b	c1 e0 02	 shl	 eax, 2
  0040e	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _screens[eax]
  00414	89 4d c0	 mov	 DWORD PTR _tmpscr$3[ebp], ecx

; 2546 : 		UINT8 *srcscr = screens[0];

  00417	b8 04 00 00 00	 mov	 eax, 4
  0041c	6b c8 00	 imul	 ecx, eax, 0
  0041f	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  00425	89 55 bc	 mov	 DWORD PTR _srcscr$2[ebp], edx

; 2547 : 		INT32 y;
; 2548 : 
; 2549 : 		// Make sure table is built
; 2550 : 		if (heatshifter == NULL || lastheight != vid.height)

  00428	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _heatshifter, 0
  0042f	74 11		 je	 SHORT $LN36@V_DoPostPr
  00431	a1 00 00 00 00	 mov	 eax, DWORD PTR _lastheight
  00436	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  0043c	0f 84 83 00 00
	00		 je	 $LN35@V_DoPostPr
$LN36@V_DoPostPr:

; 2551 : 		{
; 2552 : 			if (heatshifter)

  00442	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _heatshifter, 0
  00449	74 0e		 je	 SHORT $LN37@V_DoPostPr

; 2553 : 				Z_Free(heatshifter);

  0044b	a1 00 00 00 00	 mov	 eax, DWORD PTR _heatshifter
  00450	50		 push	 eax
  00451	e8 00 00 00 00	 call	 _Z_Free
  00456	83 c4 04	 add	 esp, 4
$LN37@V_DoPostPr:

; 2554 : 
; 2555 : 			heatshifter = Z_Calloc(vid.height * sizeof(boolean), PU_STATIC, NULL);

  00459	6a 00		 push	 0
  0045b	6a 00		 push	 0
  0045d	6a 01		 push	 1
  0045f	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00464	c1 e0 02	 shl	 eax, 2
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 _Z_CallocAlign
  0046d	83 c4 10	 add	 esp, 16			; 00000010H
  00470	a3 00 00 00 00	 mov	 DWORD PTR _heatshifter, eax

; 2556 : 
; 2557 : 			for (y = 0; y < vid.height; y++)

  00475	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$1[ebp], 0
  0047c	eb 09		 jmp	 SHORT $LN20@V_DoPostPr
$LN18@V_DoPostPr:
  0047e	8b 45 b8	 mov	 eax, DWORD PTR _y$1[ebp]
  00481	83 c0 01	 add	 eax, 1
  00484	89 45 b8	 mov	 DWORD PTR _y$1[ebp], eax
$LN20@V_DoPostPr:
  00487	8b 45 b8	 mov	 eax, DWORD PTR _y$1[ebp]
  0048a	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00490	7d 1f		 jge	 SHORT $LN19@V_DoPostPr

; 2558 : 			{
; 2559 : 				if (M_Random() < 32)

  00492	e8 00 00 00 00	 call	 _M_Random
  00497	0f b6 c0	 movzx	 eax, al
  0049a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0049d	7d 10		 jge	 SHORT $LN38@V_DoPostPr

; 2560 : 					heatshifter[y] = true;

  0049f	8b 45 b8	 mov	 eax, DWORD PTR _y$1[ebp]
  004a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heatshifter
  004a8	c7 04 81 01 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 1
$LN38@V_DoPostPr:

; 2561 : 			}

  004af	eb cd		 jmp	 SHORT $LN18@V_DoPostPr
$LN19@V_DoPostPr:

; 2562 : 
; 2563 : 			heatindex = 0;

  004b1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _heatindex, 0

; 2564 : 			lastheight = vid.height;

  004bb	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  004c0	a3 00 00 00 00	 mov	 DWORD PTR _lastheight, eax
$LN35@V_DoPostPr:

; 2565 : 		}
; 2566 : 
; 2567 : 		for (y = 0; y < vid.height; y++)

  004c5	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _y$1[ebp], 0
  004cc	eb 09		 jmp	 SHORT $LN23@V_DoPostPr
$LN21@V_DoPostPr:
  004ce	8b 45 b8	 mov	 eax, DWORD PTR _y$1[ebp]
  004d1	83 c0 01	 add	 eax, 1
  004d4	89 45 b8	 mov	 DWORD PTR _y$1[ebp], eax
$LN23@V_DoPostPr:
  004d7	8b 45 b8	 mov	 eax, DWORD PTR _y$1[ebp]
  004da	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  004e0	0f 8d c5 00 00
	00		 jge	 $LN22@V_DoPostPr

; 2568 : 		{
; 2569 : 			if (heatshifter[heatindex++])

  004e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _heatindex
  004eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _heatshifter
  004f1	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  004f4	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv271[ebp], edx
  004fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _heatindex
  004ff	83 c0 01	 add	 eax, 1
  00502	a3 00 00 00 00	 mov	 DWORD PTR _heatindex, eax
  00507	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv271[ebp], 0
  0050e	74 59		 je	 SHORT $LN39@V_DoPostPr

; 2570 : 			{
; 2571 : 				// Shift this row of pixels to the right by 2
; 2572 : 				tmpscr[y*vid.width] = srcscr[y*vid.width];

  00510	8b 45 b8	 mov	 eax, DWORD PTR _y$1[ebp]
  00513	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0051a	8b 4d b8	 mov	 ecx, DWORD PTR _y$1[ebp]
  0051d	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00524	8b 55 c0	 mov	 edx, DWORD PTR _tmpscr$3[ebp]
  00527	8b 75 bc	 mov	 esi, DWORD PTR _srcscr$2[ebp]
  0052a	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0052d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2573 : 				M_Memcpy(&tmpscr[y*vid.width+vid.dupx], &srcscr[y*vid.width], vid.width-vid.dupx);

  00530	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00535	2b 05 20 00 00
	00		 sub	 eax, DWORD PTR _vid+32
  0053b	50		 push	 eax
  0053c	8b 4d b8	 mov	 ecx, DWORD PTR _y$1[ebp]
  0053f	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00546	03 4d bc	 add	 ecx, DWORD PTR _srcscr$2[ebp]
  00549	51		 push	 ecx
  0054a	8b 55 b8	 mov	 edx, DWORD PTR _y$1[ebp]
  0054d	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  00554	03 15 20 00 00
	00		 add	 edx, DWORD PTR _vid+32
  0055a	03 55 c0	 add	 edx, DWORD PTR _tmpscr$3[ebp]
  0055d	52		 push	 edx
  0055e	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00564	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2574 : 			}

  00567	eb 2b		 jmp	 SHORT $LN40@V_DoPostPr
$LN39@V_DoPostPr:

; 2575 : 			else
; 2576 : 				M_Memcpy(&tmpscr[y*vid.width], &srcscr[y*vid.width], vid.width);

  00569	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0056e	50		 push	 eax
  0056f	8b 4d b8	 mov	 ecx, DWORD PTR _y$1[ebp]
  00572	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00579	03 4d bc	 add	 ecx, DWORD PTR _srcscr$2[ebp]
  0057c	51		 push	 ecx
  0057d	8b 55 b8	 mov	 edx, DWORD PTR _y$1[ebp]
  00580	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  00587	03 55 c0	 add	 edx, DWORD PTR _tmpscr$3[ebp]
  0058a	52		 push	 edx
  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00591	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN40@V_DoPostPr:

; 2577 : 
; 2578 : 			heatindex %= vid.height;

  00594	a1 00 00 00 00	 mov	 eax, DWORD PTR _heatindex
  00599	99		 cdq
  0059a	f7 3d 10 00 00
	00		 idiv	 DWORD PTR _vid+16
  005a0	89 15 00 00 00
	00		 mov	 DWORD PTR _heatindex, edx

; 2579 : 		}

  005a6	e9 23 ff ff ff	 jmp	 $LN21@V_DoPostPr
$LN22@V_DoPostPr:

; 2580 : 
; 2581 : 		heatindex++;

  005ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _heatindex
  005b0	83 c0 01	 add	 eax, 1
  005b3	a3 00 00 00 00	 mov	 DWORD PTR _heatindex, eax

; 2582 : 		heatindex %= vid.height;

  005b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _heatindex
  005bd	99		 cdq
  005be	f7 3d 10 00 00
	00		 idiv	 DWORD PTR _vid+16
  005c4	89 15 00 00 00
	00		 mov	 DWORD PTR _heatindex, edx

; 2583 : 
; 2584 : 		VID_BlitLinearScreen(tmpscr, screens[0], vid.width*vid.bpp, vid.height, vid.width*vid.bpp, vid.width);

  005ca	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  005cf	50		 push	 eax
  005d0	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  005d6	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  005dd	51		 push	 ecx
  005de	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  005e4	52		 push	 edx
  005e5	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  005ea	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  005f1	50		 push	 eax
  005f2	b9 04 00 00 00	 mov	 ecx, 4
  005f7	6b d1 00	 imul	 edx, ecx, 0
  005fa	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _screens[edx]
  00600	50		 push	 eax
  00601	8b 4d c0	 mov	 ecx, DWORD PTR _tmpscr$3[ebp]
  00604	51		 push	 ecx
  00605	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  0060a	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@V_DoPostPr:

; 2585 : 	}
; 2586 : }

  0060d	5f		 pop	 edi
  0060e	5e		 pop	 esi
  0060f	5b		 pop	 ebx
  00610	8b e5		 mov	 esp, ebp
  00612	5d		 pop	 ebp
  00613	c3		 ret	 0
_V_DoPostProcessor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_StringWidth
_TEXT	SEGMENT
_i$ = -12						; size = 4
_w$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_V_StringWidth PROC					; COMDAT

; 2404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2405 : 	INT32 c, w = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0

; 2406 : 	size_t i;
; 2407 : 
; 2408 : 	for (i = 0; i < strlen(string); i++)

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@V_StringWi
$LN2@V_StringWi:
  00019	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@V_StringWi:
  00022	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00031	73 7a		 jae	 SHORT $LN3@V_StringWi

; 2409 : 	{
; 2410 : 		c = string[i];

  00033	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00036	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00039	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003c	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx

; 2411 : 		if ((UINT8)c >= 0x80 && (UINT8)c <= 0x89) //color parsing! -Inuyasha 2.16.09

  0003f	0f b6 45 fc	 movzx	 eax, BYTE PTR _c$[ebp]
  00043	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00048	7c 0d		 jl	 SHORT $LN5@V_StringWi
  0004a	0f b6 45 fc	 movzx	 eax, BYTE PTR _c$[ebp]
  0004e	3d 89 00 00 00	 cmp	 eax, 137		; 00000089H
  00053	7f 02		 jg	 SHORT $LN5@V_StringWi

; 2412 : 			continue;

  00055	eb c2		 jmp	 SHORT $LN2@V_StringWi
$LN5@V_StringWi:

; 2413 : 
; 2414 : 		c = toupper(c) - HU_FONTSTART;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _toupper
  00060	83 c4 04	 add	 esp, 4
  00063	83 e8 21	 sub	 eax, 33			; 00000021H
  00066	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 2415 : 		if (c < 0 || (c >= HU_REALFONTSIZE && c != '~' - HU_FONTSTART && c != '`' - HU_FONTSTART)
; 2416 : 			|| hu_font[c] == NULL)

  00069	78 1f		 js	 SHORT $LN8@V_StringWi
  0006b	83 7d fc 5a	 cmp	 DWORD PTR _c$[ebp], 90	; 0000005aH
  0006f	7c 0c		 jl	 SHORT $LN9@V_StringWi
  00071	83 7d fc 5d	 cmp	 DWORD PTR _c$[ebp], 93	; 0000005dH
  00075	74 06		 je	 SHORT $LN9@V_StringWi
  00077	83 7d fc 3f	 cmp	 DWORD PTR _c$[ebp], 63	; 0000003fH
  0007b	75 0d		 jne	 SHORT $LN8@V_StringWi
$LN9@V_StringWi:
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00080	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _hu_font[eax*4], 0
  00088	75 0b		 jne	 SHORT $LN6@V_StringWi
$LN8@V_StringWi:

; 2417 : 		{
; 2418 : 			w += 4;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  0008d	83 c0 04	 add	 eax, 4
  00090	89 45 f8	 mov	 DWORD PTR _w$[ebp], eax

; 2419 : 		}

  00093	eb 13		 jmp	 SHORT $LN7@V_StringWi
$LN6@V_StringWi:

; 2420 : 		else
; 2421 : 			w += SHORT(hu_font[c]->width);

  00095	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00098	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _hu_font[eax*4]
  0009f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000a2	03 55 f8	 add	 edx, DWORD PTR _w$[ebp]
  000a5	89 55 f8	 mov	 DWORD PTR _w$[ebp], edx
$LN7@V_StringWi:

; 2422 : 	}

  000a8	e9 6c ff ff ff	 jmp	 $LN2@V_StringWi
$LN3@V_StringWi:

; 2423 : 
; 2424 : 	return w;

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]

; 2425 : }

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
_V_StringWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_CreditStringWidth
_TEXT	SEGMENT
_i$ = -12						; size = 4
_w$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_V_CreditStringWidth PROC				; COMDAT

; 2297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2298 : 	INT32 c, w = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0

; 2299 : 	size_t i;
; 2300 : 
; 2301 : 	for (i = 0; i < strlen(string); i++)

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@V_CreditSt
$LN2@V_CreditSt:
  00019	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@V_CreditSt:
  00022	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00031	73 40		 jae	 SHORT $LN3@V_CreditSt

; 2302 : 	{
; 2303 : 		c = toupper(string[i]) - CRED_FONTSTART;

  00033	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00036	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00039	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _toupper
  00042	83 c4 04	 add	 esp, 4
  00045	83 e8 33	 sub	 eax, 51			; 00000033H
  00048	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 2304 : 		if (c < 0 || c >= CRED_FONTSIZE)

  0004b	78 06		 js	 SHORT $LN7@V_CreditSt
  0004d	83 7d fc 28	 cmp	 DWORD PTR _c$[ebp], 40	; 00000028H
  00051	7c 0b		 jl	 SHORT $LN5@V_CreditSt
$LN7@V_CreditSt:

; 2305 : 			w += 8;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  00056	83 c0 08	 add	 eax, 8
  00059	89 45 f8	 mov	 DWORD PTR _w$[ebp], eax
  0005c	eb 13		 jmp	 SHORT $LN6@V_CreditSt
$LN5@V_CreditSt:

; 2306 : 		else
; 2307 : 			w += SHORT(cred_font[c]->width);

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00061	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _cred_font[eax*4]
  00068	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0006b	03 55 f8	 add	 edx, DWORD PTR _w$[ebp]
  0006e	89 55 f8	 mov	 DWORD PTR _w$[ebp], edx
$LN6@V_CreditSt:

; 2308 : 	}

  00071	eb a6		 jmp	 SHORT $LN2@V_CreditSt
$LN3@V_CreditSt:

; 2309 : 
; 2310 : 	return w;

  00073	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]

; 2311 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_V_CreditStringWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawCreditString
_TEXT	SEGMENT
_ch$ = -32						; size = 4
_scrwidth$ = -28					; size = 4
_dupy$ = -24						; size = 4
_dupx$ = -20						; size = 4
_cy$ = -16						; size = 4
_cx$ = -12						; size = 4
_c$ = -8						; size = 4
_w$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_option$ = 16						; size = 4
_string$ = 20						; size = 4
_V_DrawCreditString PROC				; COMDAT

; 2253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2254 : 	INT32 w, c, cx = x, cy = y, dupx, dupy, scrwidth = BASEVIDWIDTH;

  00009	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR _cy$[ebp], eax
  00015	c7 45 e4 40 01
	00 00		 mov	 DWORD PTR _scrwidth$[ebp], 320 ; 00000140H

; 2255 : 	const char *ch = string;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  0001f	89 45 e0	 mov	 DWORD PTR _ch$[ebp], eax

; 2256 : 
; 2257 : 	if (option & V_NOSCALESTART)

  00022	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00025	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0002a	74 1a		 je	 SHORT $LN5@V_DrawCred

; 2258 : 	{
; 2259 : 		dupx = vid.dupx;

  0002c	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00031	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax

; 2260 : 		dupy = vid.dupy;

  00034	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00039	89 45 e8	 mov	 DWORD PTR _dupy$[ebp], eax

; 2261 : 		scrwidth = vid.width;

  0003c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00041	89 45 e4	 mov	 DWORD PTR _scrwidth$[ebp], eax

; 2262 : 	}

  00044	eb 0d		 jmp	 SHORT $LN6@V_DrawCred
$LN5@V_DrawCred:

; 2263 : 	else
; 2264 : 		dupx = dupy = 1;

  00046	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  0004d	8b 45 e8	 mov	 eax, DWORD PTR _dupy$[ebp]
  00050	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax
$LN6@V_DrawCred:
$LN2@V_DrawCred:

; 2265 : 
; 2266 : 	for (;;)
; 2267 : 	{
; 2268 : 		c = *ch++;

  00053	8b 45 e0	 mov	 eax, DWORD PTR _ch$[ebp]
  00056	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00059	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
  0005c	8b 55 e0	 mov	 edx, DWORD PTR _ch$[ebp]
  0005f	83 c2 01	 add	 edx, 1
  00062	89 55 e0	 mov	 DWORD PTR _ch$[ebp], edx

; 2269 : 		if (!c)

  00065	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  00069	75 05		 jne	 SHORT $LN7@V_DrawCred

; 2270 : 			break;

  0006b	e9 8e 00 00 00	 jmp	 $LN3@V_DrawCred
$LN7@V_DrawCred:

; 2271 : 		if (c == '\n')

  00070	83 7d f8 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  00074	75 12		 jne	 SHORT $LN8@V_DrawCred

; 2272 : 		{
; 2273 : 			cx = x;

  00076	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00079	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2274 : 			cy += 12*dupy;

  0007c	6b 45 e8 0c	 imul	 eax, DWORD PTR _dupy$[ebp], 12
  00080	03 45 f0	 add	 eax, DWORD PTR _cy$[ebp]
  00083	89 45 f0	 mov	 DWORD PTR _cy$[ebp], eax

; 2275 : 			continue;

  00086	eb cb		 jmp	 SHORT $LN2@V_DrawCred
$LN8@V_DrawCred:

; 2276 : 		}
; 2277 : 
; 2278 : 		c = toupper(c) - CRED_FONTSTART;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _toupper
  00091	83 c4 04	 add	 esp, 4
  00094	83 e8 33	 sub	 eax, 51			; 00000033H
  00097	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 2279 : 		if (c < 0 || c >= CRED_FONTSIZE)

  0009a	78 06		 js	 SHORT $LN10@V_DrawCred
  0009c	83 7d f8 28	 cmp	 DWORD PTR _c$[ebp], 40	; 00000028H
  000a0	7c 0e		 jl	 SHORT $LN9@V_DrawCred
$LN10@V_DrawCred:

; 2280 : 		{
; 2281 : 			cx += 16*dupx;

  000a2	8b 45 ec	 mov	 eax, DWORD PTR _dupx$[ebp]
  000a5	c1 e0 04	 shl	 eax, 4
  000a8	03 45 f4	 add	 eax, DWORD PTR _cx$[ebp]
  000ab	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2282 : 			continue;

  000ae	eb a3		 jmp	 SHORT $LN2@V_DrawCred
$LN9@V_DrawCred:

; 2283 : 		}
; 2284 : 
; 2285 : 		w = SHORT(cred_font[c]->width) * dupx;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000b3	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _cred_font[eax*4]
  000ba	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000bd	0f af 55 ec	 imul	 edx, DWORD PTR _dupx$[ebp]
  000c1	89 55 fc	 mov	 DWORD PTR _w$[ebp], edx

; 2286 : 		if (cx + w > scrwidth)

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  000c7	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  000ca	3b 45 e4	 cmp	 eax, DWORD PTR _scrwidth$[ebp]
  000cd	7e 02		 jle	 SHORT $LN11@V_DrawCred

; 2287 : 			break;

  000cf	eb 2d		 jmp	 SHORT $LN3@V_DrawCred
$LN11@V_DrawCred:

; 2288 : 
; 2289 : 		V_DrawScaledPatch(cx, cy, option, cred_font[c]);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000d4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _cred_font[eax*4]
  000db	51		 push	 ecx
  000dc	8b 55 10	 mov	 edx, DWORD PTR _option$[ebp]
  000df	52		 push	 edx
  000e0	8b 45 f0	 mov	 eax, DWORD PTR _cy$[ebp]
  000e3	50		 push	 eax
  000e4	8b 4d f4	 mov	 ecx, DWORD PTR _cx$[ebp]
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  000ed	83 c4 10	 add	 esp, 16			; 00000010H

; 2290 : 		cx += w;

  000f0	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  000f3	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  000f6	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2291 : 	}

  000f9	e9 55 ff ff ff	 jmp	 $LN2@V_DrawCred
$LN3@V_DrawCred:

; 2292 : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_V_DrawCreditString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_LevelNameHeight
_TEXT	SEGMENT
_i$ = -12						; size = 4
_w$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_V_LevelNameHeight PROC					; COMDAT

; 2382 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2383 : 	INT32 c, w = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0

; 2384 : 	size_t i;
; 2385 : 
; 2386 : 	for (i = 0; i < strlen(string); i++)

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@V_LevelNam
$LN2@V_LevelNam:
  00019	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@V_LevelNam:
  00022	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00031	73 61		 jae	 SHORT $LN3@V_LevelNam

; 2387 : 	{
; 2388 : 		c = toupper(string[i]) - LT_FONTSTART;

  00033	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00036	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00039	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _toupper
  00042	83 c4 04	 add	 esp, 4
  00045	83 e8 27	 sub	 eax, 39			; 00000027H
  00048	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 2389 : 		if (c < 0 || (c >= HU_REALFONTSIZE && c != '~' - HU_FONTSTART && c != '`' - HU_FONTSTART)
; 2390 : 		    || hu_font[c] == NULL)

  0004b	78 1f		 js	 SHORT $LN6@V_LevelNam
  0004d	83 7d fc 5a	 cmp	 DWORD PTR _c$[ebp], 90	; 0000005aH
  00051	7c 0c		 jl	 SHORT $LN7@V_LevelNam
  00053	83 7d fc 5d	 cmp	 DWORD PTR _c$[ebp], 93	; 0000005dH
  00057	74 06		 je	 SHORT $LN7@V_LevelNam
  00059	83 7d fc 3f	 cmp	 DWORD PTR _c$[ebp], 63	; 0000003fH
  0005d	75 0d		 jne	 SHORT $LN6@V_LevelNam
$LN7@V_LevelNam:
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00062	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _hu_font[eax*4], 0
  0006a	75 02		 jne	 SHORT $LN5@V_LevelNam
$LN6@V_LevelNam:

; 2391 : 			continue;

  0006c	eb ab		 jmp	 SHORT $LN2@V_LevelNam
$LN5@V_LevelNam:

; 2392 : 
; 2393 : 		if (SHORT(lt_font[c]->height) > w)

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00071	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lt_font[eax*4]
  00078	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0007c	3b 55 f8	 cmp	 edx, DWORD PTR _w$[ebp]
  0007f	7e 11		 jle	 SHORT $LN8@V_LevelNam

; 2394 : 			w = SHORT(lt_font[c]->height);

  00081	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00084	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lt_font[eax*4]
  0008b	0f bf 51 02	 movsx	 edx, WORD PTR [ecx+2]
  0008f	89 55 f8	 mov	 DWORD PTR _w$[ebp], edx
$LN8@V_LevelNam:

; 2395 : 	}

  00092	eb 85		 jmp	 SHORT $LN2@V_LevelNam
$LN3@V_LevelNam:

; 2396 : 
; 2397 : 	return w;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]

; 2398 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_V_LevelNameHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_LevelNameWidth
_TEXT	SEGMENT
_i$ = -12						; size = 4
_w$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_V_LevelNameWidth PROC					; COMDAT

; 2363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2364 : 	INT32 c, w = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0

; 2365 : 	size_t i;
; 2366 : 
; 2367 : 	for (i = 0; i < strlen(string); i++)

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@V_LevelNam
$LN2@V_LevelNam:
  00019	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@V_LevelNam:
  00022	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4
  0002e	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  00031	73 4c		 jae	 SHORT $LN3@V_LevelNam

; 2368 : 	{
; 2369 : 		c = toupper(string[i]) - LT_FONTSTART;

  00033	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00036	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00039	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _toupper
  00042	83 c4 04	 add	 esp, 4
  00045	83 e8 27	 sub	 eax, 39			; 00000027H
  00048	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 2370 : 		if (c < 0 || (c > 0 && c < LT_REALFONTSTART - LT_FONTSTART) || c >= LT_FONTSIZE)

  0004b	78 12		 js	 SHORT $LN7@V_LevelNam
  0004d	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00051	7e 06		 jle	 SHORT $LN8@V_LevelNam
  00053	83 7d fc 1a	 cmp	 DWORD PTR _c$[ebp], 26	; 0000001aH
  00057	7c 06		 jl	 SHORT $LN7@V_LevelNam
$LN8@V_LevelNam:
  00059	83 7d fc 34	 cmp	 DWORD PTR _c$[ebp], 52	; 00000034H
  0005d	7c 0b		 jl	 SHORT $LN5@V_LevelNam
$LN7@V_LevelNam:

; 2371 : 			w += 16;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	89 45 f8	 mov	 DWORD PTR _w$[ebp], eax
  00068	eb 13		 jmp	 SHORT $LN6@V_LevelNam
$LN5@V_LevelNam:

; 2372 : 		else
; 2373 : 			w += SHORT(lt_font[c]->width);

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0006d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lt_font[eax*4]
  00074	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00077	03 55 f8	 add	 edx, DWORD PTR _w$[ebp]
  0007a	89 55 f8	 mov	 DWORD PTR _w$[ebp], edx
$LN6@V_LevelNam:

; 2374 : 	}

  0007d	eb 9a		 jmp	 SHORT $LN2@V_LevelNam
$LN3@V_LevelNam:

; 2375 : 
; 2376 : 	return w;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]

; 2377 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_V_LevelNameWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawTinyNum
_TEXT	SEGMENT
_tempnum$ = -8						; size = 4
_w$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_c$ = 16						; size = 4
_num$ = 20						; size = 4
_V_DrawTinyNum PROC					; COMDAT

; 2196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2197 : 	INT32 w = SHORT(tinynum[0]->width);

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tinynum[ecx]
  00017	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0001a	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax

; 2198 : 	INT32 tempnum = num;

  0001d	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _tempnum$[ebp], eax

; 2199 : 
; 2200 : 	// special case for 0
; 2201 : 	if (!num)

  00023	83 7d 14 00	 cmp	 DWORD PTR _num$[ebp], 0
  00027	0f 85 6b 01 00
	00		 jne	 $LN6@V_DrawTiny

; 2202 : 	{
; 2203 : 		if ((c & V_YELLOWMAP) && ((c & V_TRANSLUCENT) || (c & V_8020TRANS)))

  0002d	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00030	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00035	74 42		 je	 SHORT $LN7@V_DrawTiny
  00037	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0003a	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0003f	75 0a		 jne	 SHORT $LN9@V_DrawTiny
  00041	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00044	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00049	74 2e		 je	 SHORT $LN7@V_DrawTiny
$LN9@V_DrawTiny:

; 2204 : 			V_DrawTranslucentMappedPatch(x, y, c, tinynum[0], yellowmap);

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  00050	50		 push	 eax
  00051	b9 04 00 00 00	 mov	 ecx, 4
  00056	6b d1 00	 imul	 edx, ecx, 0
  00059	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tinynum[edx]
  0005f	50		 push	 eax
  00060	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00067	52		 push	 edx
  00068	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _V_DrawTranslucentMappedPatch
  00071	83 c4 14	 add	 esp, 20			; 00000014H
  00074	e9 1a 01 00 00	 jmp	 $LN18@V_DrawTiny
$LN7@V_DrawTiny:

; 2205 : 		else if ((c & V_GREENMAP) && ((c & V_TRANSLUCENT) || (c & V_8020TRANS)))

  00079	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0007c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00081	74 42		 je	 SHORT $LN10@V_DrawTiny
  00083	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00086	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0008b	75 0a		 jne	 SHORT $LN12@V_DrawTiny
  0008d	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00090	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00095	74 2e		 je	 SHORT $LN10@V_DrawTiny
$LN12@V_DrawTiny:

; 2206 : 			V_DrawTranslucentMappedPatch(x, y, c, tinynum[0], lgreenmap);

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  0009c	50		 push	 eax
  0009d	b9 04 00 00 00	 mov	 ecx, 4
  000a2	6b d1 00	 imul	 edx, ecx, 0
  000a5	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tinynum[edx]
  000ab	50		 push	 eax
  000ac	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  000af	51		 push	 ecx
  000b0	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000b3	52		 push	 edx
  000b4	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _V_DrawTranslucentMappedPatch
  000bd	83 c4 14	 add	 esp, 20			; 00000014H
  000c0	e9 ce 00 00 00	 jmp	 $LN18@V_DrawTiny
$LN10@V_DrawTiny:

; 2207 : 		else if (c & V_YELLOWMAP)

  000c5	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  000c8	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  000cd	74 2e		 je	 SHORT $LN13@V_DrawTiny

; 2208 : 			V_DrawMappedPatch(x, y, c, tinynum[0], yellowmap);

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  000d4	50		 push	 eax
  000d5	b9 04 00 00 00	 mov	 ecx, 4
  000da	6b d1 00	 imul	 edx, ecx, 0
  000dd	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tinynum[edx]
  000e3	50		 push	 eax
  000e4	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  000e7	51		 push	 ecx
  000e8	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 _V_DrawMappedPatch
  000f5	83 c4 14	 add	 esp, 20			; 00000014H
  000f8	e9 96 00 00 00	 jmp	 $LN18@V_DrawTiny
$LN13@V_DrawTiny:

; 2209 : 		else if (c & V_GREENMAP)

  000fd	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00100	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00105	74 2b		 je	 SHORT $LN15@V_DrawTiny

; 2210 : 			V_DrawMappedPatch(x, y, c, tinynum[0], lgreenmap);

  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  0010c	50		 push	 eax
  0010d	b9 04 00 00 00	 mov	 ecx, 4
  00112	6b d1 00	 imul	 edx, ecx, 0
  00115	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tinynum[edx]
  0011b	50		 push	 eax
  0011c	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  0011f	51		 push	 ecx
  00120	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00123	52		 push	 edx
  00124	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _V_DrawMappedPatch
  0012d	83 c4 14	 add	 esp, 20			; 00000014H
  00130	eb 61		 jmp	 SHORT $LN18@V_DrawTiny
$LN15@V_DrawTiny:

; 2211 : 		else if ((c & V_TRANSLUCENT) || (c & V_8020TRANS))

  00132	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00135	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0013a	75 0a		 jne	 SHORT $LN19@V_DrawTiny
  0013c	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0013f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00144	74 2a		 je	 SHORT $LN17@V_DrawTiny
$LN19@V_DrawTiny:

; 2212 : 			V_DrawTranslucentPatch(x, y, c & ~V_TRANSLUCENT, tinynum[0]);

  00146	b8 04 00 00 00	 mov	 eax, 4
  0014b	6b c8 00	 imul	 ecx, eax, 0
  0014e	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tinynum[ecx]
  00154	52		 push	 edx
  00155	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00158	25 ff ff bf ff	 and	 eax, -4194305		; ffbfffffH
  0015d	50		 push	 eax
  0015e	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00161	51		 push	 ecx
  00162	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 _V_DrawTranslucentPatch
  0016b	83 c4 10	 add	 esp, 16			; 00000010H
  0016e	eb 23		 jmp	 SHORT $LN18@V_DrawTiny
$LN17@V_DrawTiny:

; 2213 : 		else
; 2214 : 			V_DrawScaledPatch(x, y, c, tinynum[0]);

  00170	b8 04 00 00 00	 mov	 eax, 4
  00175	6b c8 00	 imul	 ecx, eax, 0
  00178	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tinynum[ecx]
  0017e	52		 push	 edx
  0017f	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00182	50		 push	 eax
  00183	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00186	51		 push	 ecx
  00187	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00190	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@V_DrawTiny:

; 2215 : 		return;

  00193	e9 c3 01 00 00	 jmp	 $LN5@V_DrawTiny
$LN6@V_DrawTiny:

; 2216 : 	}
; 2217 : 
; 2218 : 	I_Assert(num >= 0); // this function does not draw negative numbers
; 2219 : 
; 2220 : 	// Position the string correctly.
; 2221 : 	while (tempnum)

  00198	83 7d f8 00	 cmp	 DWORD PTR _tempnum$[ebp], 0
  0019c	74 19		 je	 SHORT $LN3@V_DrawTiny

; 2222 : 	{
; 2223 : 		x += w;

  0019e	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001a1	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  001a4	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 2224 : 		tempnum /= 10;

  001a7	8b 45 f8	 mov	 eax, DWORD PTR _tempnum$[ebp]
  001aa	99		 cdq
  001ab	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  001b0	f7 f9		 idiv	 ecx
  001b2	89 45 f8	 mov	 DWORD PTR _tempnum$[ebp], eax

; 2225 : 	}

  001b5	eb e1		 jmp	 SHORT $LN6@V_DrawTiny
$LN3@V_DrawTiny:

; 2226 : 
; 2227 : 	// draw the number
; 2228 : 	while (num)

  001b7	83 7d 14 00	 cmp	 DWORD PTR _num$[ebp], 0
  001bb	0f 84 9a 01 00
	00		 je	 $LN5@V_DrawTiny

; 2229 : 	{
; 2230 : 		x -= w;

  001c1	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001c4	2b 45 fc	 sub	 eax, DWORD PTR _w$[ebp]
  001c7	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 2231 : 
; 2232 : 		if ((c & V_YELLOWMAP) && ((c & V_TRANSLUCENT) || (c & V_8020TRANS)))

  001ca	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  001cd	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  001d2	74 46		 je	 SHORT $LN20@V_DrawTiny
  001d4	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  001d7	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  001dc	75 0a		 jne	 SHORT $LN22@V_DrawTiny
  001de	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  001e1	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  001e6	74 32		 je	 SHORT $LN20@V_DrawTiny
$LN22@V_DrawTiny:

; 2233 : 			V_DrawTranslucentMappedPatch(x, y, c, tinynum[num % 10], yellowmap);

  001e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  001ed	50		 push	 eax
  001ee	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  001f1	99		 cdq
  001f2	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  001f7	f7 f9		 idiv	 ecx
  001f9	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tinynum[edx*4]
  00200	52		 push	 edx
  00201	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00204	50		 push	 eax
  00205	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00208	51		 push	 ecx
  00209	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 _V_DrawTranslucentMappedPatch
  00212	83 c4 14	 add	 esp, 20			; 00000014H
  00215	e9 2e 01 00 00	 jmp	 $LN31@V_DrawTiny
$LN20@V_DrawTiny:

; 2234 : 		else if ((c & V_GREENMAP) && ((c & V_TRANSLUCENT) || (c & V_8020TRANS)))

  0021a	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0021d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00222	74 46		 je	 SHORT $LN23@V_DrawTiny
  00224	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00227	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0022c	75 0a		 jne	 SHORT $LN25@V_DrawTiny
  0022e	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00231	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00236	74 32		 je	 SHORT $LN23@V_DrawTiny
$LN25@V_DrawTiny:

; 2235 : 			V_DrawTranslucentMappedPatch(x, y, c, tinynum[num % 10], lgreenmap);

  00238	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  0023d	50		 push	 eax
  0023e	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00241	99		 cdq
  00242	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00247	f7 f9		 idiv	 ecx
  00249	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tinynum[edx*4]
  00250	52		 push	 edx
  00251	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00254	50		 push	 eax
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00258	51		 push	 ecx
  00259	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0025c	52		 push	 edx
  0025d	e8 00 00 00 00	 call	 _V_DrawTranslucentMappedPatch
  00262	83 c4 14	 add	 esp, 20			; 00000014H
  00265	e9 de 00 00 00	 jmp	 $LN31@V_DrawTiny
$LN23@V_DrawTiny:

; 2236 : 		else if (c & V_YELLOWMAP)

  0026a	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0026d	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00272	74 32		 je	 SHORT $LN26@V_DrawTiny

; 2237 : 			V_DrawMappedPatch(x, y, c, tinynum[num % 10], yellowmap);

  00274	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  00279	50		 push	 eax
  0027a	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  0027d	99		 cdq
  0027e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00283	f7 f9		 idiv	 ecx
  00285	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tinynum[edx*4]
  0028c	52		 push	 edx
  0028d	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00290	50		 push	 eax
  00291	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00294	51		 push	 ecx
  00295	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00298	52		 push	 edx
  00299	e8 00 00 00 00	 call	 _V_DrawMappedPatch
  0029e	83 c4 14	 add	 esp, 20			; 00000014H
  002a1	e9 a2 00 00 00	 jmp	 $LN31@V_DrawTiny
$LN26@V_DrawTiny:

; 2238 : 		else if (c & V_GREENMAP)

  002a6	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  002a9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002ae	74 2f		 je	 SHORT $LN28@V_DrawTiny

; 2239 : 			V_DrawMappedPatch(x, y, c, tinynum[num % 10], lgreenmap);

  002b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  002b5	50		 push	 eax
  002b6	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  002b9	99		 cdq
  002ba	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  002bf	f7 f9		 idiv	 ecx
  002c1	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tinynum[edx*4]
  002c8	52		 push	 edx
  002c9	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  002cc	50		 push	 eax
  002cd	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  002d0	51		 push	 ecx
  002d1	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 _V_DrawMappedPatch
  002da	83 c4 14	 add	 esp, 20			; 00000014H
  002dd	eb 69		 jmp	 SHORT $LN31@V_DrawTiny
$LN28@V_DrawTiny:

; 2240 : 		else if ((c & V_TRANSLUCENT) || (c & V_8020TRANS))

  002df	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  002e2	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  002e7	75 0a		 jne	 SHORT $LN32@V_DrawTiny
  002e9	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  002ec	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  002f1	74 2e		 je	 SHORT $LN30@V_DrawTiny
$LN32@V_DrawTiny:

; 2241 : 			V_DrawTranslucentPatch(x, y, c & ~V_TRANSLUCENT, tinynum[num % 10]);

  002f3	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  002f6	99		 cdq
  002f7	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  002fc	f7 f9		 idiv	 ecx
  002fe	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tinynum[edx*4]
  00305	52		 push	 edx
  00306	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00309	25 ff ff bf ff	 and	 eax, -4194305		; ffbfffffH
  0030e	50		 push	 eax
  0030f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00312	51		 push	 ecx
  00313	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00316	52		 push	 edx
  00317	e8 00 00 00 00	 call	 _V_DrawTranslucentPatch
  0031c	83 c4 10	 add	 esp, 16			; 00000010H
  0031f	eb 27		 jmp	 SHORT $LN31@V_DrawTiny
$LN30@V_DrawTiny:

; 2242 : 		else
; 2243 : 			V_DrawScaledPatch(x, y, c, tinynum[num % 10]);

  00321	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00324	99		 cdq
  00325	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0032a	f7 f9		 idiv	 ecx
  0032c	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tinynum[edx*4]
  00333	52		 push	 edx
  00334	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00337	50		 push	 eax
  00338	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0033b	51		 push	 ecx
  0033c	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0033f	52		 push	 edx
  00340	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00345	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@V_DrawTiny:

; 2244 : 
; 2245 : 		num /= 10;

  00348	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  0034b	99		 cdq
  0034c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00351	f7 f9		 idiv	 ecx
  00353	89 45 14	 mov	 DWORD PTR _num$[ebp], eax

; 2246 : 	}

  00356	e9 5c fe ff ff	 jmp	 $LN3@V_DrawTiny
$LN5@V_DrawTiny:

; 2247 : }

  0035b	5f		 pop	 edi
  0035c	5e		 pop	 esi
  0035d	5b		 pop	 ebx
  0035e	8b e5		 mov	 esp, ebp
  00360	5d		 pop	 ebp
  00361	c3		 ret	 0
_V_DrawTinyNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawRightAlignedString
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_option$ = 16						; size = 4
_string$ = 20						; size = 4
_V_DrawRightAlignedString PROC				; COMDAT

; 2188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2189 : 	x -= V_StringWidth(string);

  00009	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _V_StringWidth
  00012	83 c4 04	 add	 esp, 4
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00018	2b c8		 sub	 ecx, eax
  0001a	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 2190 : 	V_DrawString(x, y, option, string);

  0001d	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR _option$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00028	52		 push	 edx
  00029	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _V_DrawString
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 2191 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_V_DrawRightAlignedString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawCenteredString
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_option$ = 16						; size = 4
_string$ = 20						; size = 4
_V_DrawCenteredString PROC				; COMDAT

; 2182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2183 : 	x -= V_StringWidth(string)/2;

  00009	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _V_StringWidth
  00012	83 c4 04	 add	 esp, 4
  00015	99		 cdq
  00016	2b c2		 sub	 eax, edx
  00018	d1 f8		 sar	 eax, 1
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0001d	2b c8		 sub	 ecx, eax
  0001f	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 2184 : 	V_DrawString(x, y, option, string);

  00022	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR _option$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _V_DrawString
  00037	83 c4 10	 add	 esp, 16			; 00000010H

; 2185 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_V_DrawCenteredString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawString
_TEXT	SEGMENT
_colormap$ = -40					; size = 4
_lastcolorchar$ = -33					; size = 1
_ch$ = -32						; size = 4
_scrwidth$ = -28					; size = 4
_dupy$ = -24						; size = 4
_dupx$ = -20						; size = 4
_cy$ = -16						; size = 4
_cx$ = -12						; size = 4
_c$ = -8						; size = 4
_w$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_option$ = 16						; size = 4
_string$ = 20						; size = 4
_V_DrawString PROC					; COMDAT

; 2089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2090 : 	INT32 w, c, cx = x, cy = y, dupx, dupy, scrwidth = BASEVIDWIDTH;

  00009	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR _cy$[ebp], eax
  00015	c7 45 e4 40 01
	00 00		 mov	 DWORD PTR _scrwidth$[ebp], 320 ; 00000140H

; 2091 : 	const char *ch = string;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  0001f	89 45 e0	 mov	 DWORD PTR _ch$[ebp], eax

; 2092 : 	UINT8 lastcolorchar = 0x80; //for dynamic colors

  00022	c6 45 df 80	 mov	 BYTE PTR _lastcolorchar$[ebp], 128 ; 00000080H

; 2093 : 	const UINT8 *colormap = NULL;

  00026	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _colormap$[ebp], 0

; 2094 : 
; 2095 : 	if (option & V_WORDWRAP)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00030	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00035	74 1d		 je	 SHORT $LN5@V_DrawStri

; 2096 : 	{
; 2097 : 		V_DrawWordWrapString(x, y, option, string);

  00037	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 10	 mov	 ecx, DWORD PTR _option$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _V_DrawWordWrapString
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 2098 : 		return;

  0004f	e9 b5 02 00 00	 jmp	 $LN3@V_DrawStri
$LN5@V_DrawStri:

; 2099 : 	}
; 2100 : 
; 2101 : 	if (option & V_NOSCALESTART)

  00054	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00057	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0005c	74 1a		 je	 SHORT $LN6@V_DrawStri

; 2102 : 	{
; 2103 : 		dupx = vid.dupx;

  0005e	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00063	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax

; 2104 : 		dupy = vid.dupy;

  00066	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  0006b	89 45 e8	 mov	 DWORD PTR _dupy$[ebp], eax

; 2105 : 		scrwidth = vid.width;

  0006e	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00073	89 45 e4	 mov	 DWORD PTR _scrwidth$[ebp], eax

; 2106 : 	}

  00076	eb 0d		 jmp	 SHORT $LN7@V_DrawStri
$LN6@V_DrawStri:

; 2107 : 	else
; 2108 : 		dupx = dupy = 1;

  00078	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  0007f	8b 45 e8	 mov	 eax, DWORD PTR _dupy$[ebp]
  00082	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax
$LN7@V_DrawStri:
$LN2@V_DrawStri:

; 2109 : 
; 2110 : 	for (;;)
; 2111 : 	{
; 2112 : 		c = *ch++;

  00085	8b 45 e0	 mov	 eax, DWORD PTR _ch$[ebp]
  00088	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008b	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
  0008e	8b 55 e0	 mov	 edx, DWORD PTR _ch$[ebp]
  00091	83 c2 01	 add	 edx, 1
  00094	89 55 e0	 mov	 DWORD PTR _ch$[ebp], edx

; 2113 : 		if (!c)

  00097	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  0009b	75 05		 jne	 SHORT $LN8@V_DrawStri

; 2114 : 			break;

  0009d	e9 67 02 00 00	 jmp	 $LN3@V_DrawStri
$LN8@V_DrawStri:

; 2115 : 		if ((UINT8)c >= 0x80 && (UINT8)c <= 0x89) //color parsing -x 2.16.09

  000a2	0f b6 45 f8	 movzx	 eax, BYTE PTR _c$[ebp]
  000a6	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000ab	7c 13		 jl	 SHORT $LN9@V_DrawStri
  000ad	0f b6 45 f8	 movzx	 eax, BYTE PTR _c$[ebp]
  000b1	3d 89 00 00 00	 cmp	 eax, 137		; 00000089H
  000b6	7f 08		 jg	 SHORT $LN9@V_DrawStri

; 2116 : 		{
; 2117 : 			lastcolorchar = (UINT8)c;

  000b8	8a 45 f8	 mov	 al, BYTE PTR _c$[ebp]
  000bb	88 45 df	 mov	 BYTE PTR _lastcolorchar$[ebp], al

; 2118 : 			continue;

  000be	eb c5		 jmp	 SHORT $LN2@V_DrawStri
$LN9@V_DrawStri:

; 2119 : 		}
; 2120 : 		if (c == '\n')

  000c0	83 7d f8 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  000c4	75 2a		 jne	 SHORT $LN10@V_DrawStri

; 2121 : 		{
; 2122 : 			cx = x;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000c9	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2123 : 
; 2124 : 			if (option & V_RETURN8)

  000cc	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  000cf	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  000d4	74 0e		 je	 SHORT $LN11@V_DrawStri

; 2125 : 				cy += 8*dupy;

  000d6	8b 45 e8	 mov	 eax, DWORD PTR _dupy$[ebp]
  000d9	8b 4d f0	 mov	 ecx, DWORD PTR _cy$[ebp]
  000dc	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  000df	89 55 f0	 mov	 DWORD PTR _cy$[ebp], edx
  000e2	eb 0a		 jmp	 SHORT $LN12@V_DrawStri
$LN11@V_DrawStri:

; 2126 : 			else
; 2127 : 				cy += 12*dupy;

  000e4	6b 45 e8 0c	 imul	 eax, DWORD PTR _dupy$[ebp], 12
  000e8	03 45 f0	 add	 eax, DWORD PTR _cy$[ebp]
  000eb	89 45 f0	 mov	 DWORD PTR _cy$[ebp], eax
$LN12@V_DrawStri:

; 2128 : 
; 2129 : 			continue;

  000ee	eb 95		 jmp	 SHORT $LN2@V_DrawStri
$LN10@V_DrawStri:

; 2130 : 		}
; 2131 : 
; 2132 : 		if (option & V_ALLOWLOWERCASE)

  000f0	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  000f3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f8	74 0b		 je	 SHORT $LN13@V_DrawStri

; 2133 : 			c -= HU_FONTSTART;

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000fd	83 e8 21	 sub	 eax, 33			; 00000021H
  00100	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
  00103	eb 12		 jmp	 SHORT $LN14@V_DrawStri
$LN13@V_DrawStri:

; 2134 : 		else
; 2135 : 			c = toupper(c) - HU_FONTSTART;

  00105	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _toupper
  0010e	83 c4 04	 add	 esp, 4
  00111	83 e8 21	 sub	 eax, 33			; 00000021H
  00114	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
$LN14@V_DrawStri:

; 2136 : 		if (c < 0 || (c >= HU_REALFONTSIZE && c != '~' - HU_FONTSTART && c != '`' - HU_FONTSTART))

  00117	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  0011b	7c 12		 jl	 SHORT $LN16@V_DrawStri
  0011d	83 7d f8 5a	 cmp	 DWORD PTR _c$[ebp], 90	; 0000005aH
  00121	7c 1d		 jl	 SHORT $LN15@V_DrawStri
  00123	83 7d f8 5d	 cmp	 DWORD PTR _c$[ebp], 93	; 0000005dH
  00127	74 17		 je	 SHORT $LN15@V_DrawStri
  00129	83 7d f8 3f	 cmp	 DWORD PTR _c$[ebp], 63	; 0000003fH
  0012d	74 11		 je	 SHORT $LN15@V_DrawStri
$LN16@V_DrawStri:

; 2137 : 		{
; 2138 : 			cx += 4*dupx;

  0012f	8b 45 ec	 mov	 eax, DWORD PTR _dupx$[ebp]
  00132	8b 4d f4	 mov	 ecx, DWORD PTR _cx$[ebp]
  00135	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00138	89 55 f4	 mov	 DWORD PTR _cx$[ebp], edx

; 2139 : 			continue;

  0013b	e9 45 ff ff ff	 jmp	 $LN2@V_DrawStri
$LN15@V_DrawStri:

; 2140 : 		}
; 2141 : 
; 2142 : 		w = SHORT(hu_font[c]->width) * dupx;

  00140	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00143	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _hu_font[eax*4]
  0014a	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  0014d	0f af 55 ec	 imul	 edx, DWORD PTR _dupx$[ebp]
  00151	89 55 fc	 mov	 DWORD PTR _w$[ebp], edx

; 2143 : 		if (cx + w > scrwidth)

  00154	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  00157	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  0015a	3b 45 e4	 cmp	 eax, DWORD PTR _scrwidth$[ebp]
  0015d	7e 05		 jle	 SHORT $LN17@V_DrawStri

; 2144 : 			break;

  0015f	e9 a5 01 00 00	 jmp	 $LN3@V_DrawStri
$LN17@V_DrawStri:

; 2145 : 		if (cx < 0) //left boundary check

  00164	83 7d f4 00	 cmp	 DWORD PTR _cx$[ebp], 0
  00168	7d 0e		 jge	 SHORT $LN18@V_DrawStri

; 2146 : 		{
; 2147 : 			cx += w;

  0016a	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  0016d	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  00170	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2148 : 			continue;

  00173	e9 0d ff ff ff	 jmp	 $LN2@V_DrawStri
$LN18@V_DrawStri:

; 2149 : 		}
; 2150 : 
; 2151 : 		if ((option & V_YELLOWMAP) || lastcolorchar == 0x82)

  00178	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  0017b	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00180	75 0b		 jne	 SHORT $LN21@V_DrawStri
  00182	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  00186	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  0018b	75 0d		 jne	 SHORT $LN19@V_DrawStri
$LN21@V_DrawStri:

; 2152 : 			colormap = yellowmap;

  0018d	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  00192	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  00195	e9 9a 00 00 00	 jmp	 $LN35@V_DrawStri
$LN19@V_DrawStri:

; 2153 : 		else if ((option & V_GREENMAP) || lastcolorchar == 0x83)

  0019a	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  0019d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001a2	75 0b		 jne	 SHORT $LN24@V_DrawStri
  001a4	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  001a8	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  001ad	75 0a		 jne	 SHORT $LN22@V_DrawStri
$LN24@V_DrawStri:

; 2154 : 			colormap = lgreenmap;

  001af	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  001b4	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  001b7	eb 7b		 jmp	 SHORT $LN35@V_DrawStri
$LN22@V_DrawStri:

; 2155 : 		else if (lastcolorchar == 0x81)

  001b9	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  001bd	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  001c2	75 0a		 jne	 SHORT $LN25@V_DrawStri

; 2156 : 			colormap = purplemap;

  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _purplemap
  001c9	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  001cc	eb 66		 jmp	 SHORT $LN35@V_DrawStri
$LN25@V_DrawStri:

; 2157 : 		else if (lastcolorchar == 0x84)

  001ce	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  001d2	3d 84 00 00 00	 cmp	 eax, 132		; 00000084H
  001d7	75 0a		 jne	 SHORT $LN27@V_DrawStri

; 2158 : 			colormap = bluemap;

  001d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _bluemap
  001de	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  001e1	eb 51		 jmp	 SHORT $LN35@V_DrawStri
$LN27@V_DrawStri:

; 2159 : 		else if (lastcolorchar == 0x85)

  001e3	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  001e7	3d 85 00 00 00	 cmp	 eax, 133		; 00000085H
  001ec	75 0a		 jne	 SHORT $LN29@V_DrawStri

; 2160 : 			colormap = redmap;

  001ee	a1 00 00 00 00	 mov	 eax, DWORD PTR _redmap
  001f3	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  001f6	eb 3c		 jmp	 SHORT $LN35@V_DrawStri
$LN29@V_DrawStri:

; 2161 : 		else if (lastcolorchar == 0x86)

  001f8	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  001fc	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  00201	75 0a		 jne	 SHORT $LN31@V_DrawStri

; 2162 : 			colormap = graymap;

  00203	a1 00 00 00 00	 mov	 eax, DWORD PTR _graymap
  00208	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  0020b	eb 27		 jmp	 SHORT $LN35@V_DrawStri
$LN31@V_DrawStri:

; 2163 : 		else if (lastcolorchar == 0x87)

  0020d	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  00211	3d 87 00 00 00	 cmp	 eax, 135		; 00000087H
  00216	75 0a		 jne	 SHORT $LN33@V_DrawStri

; 2164 : 			colormap = orangemap;

  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR _orangemap
  0021d	89 45 d8	 mov	 DWORD PTR _colormap$[ebp], eax
  00220	eb 12		 jmp	 SHORT $LN35@V_DrawStri
$LN33@V_DrawStri:

; 2165 : 		else if (lastcolorchar == 0x80)

  00222	0f b6 45 df	 movzx	 eax, BYTE PTR _lastcolorchar$[ebp]
  00226	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0022b	75 07		 jne	 SHORT $LN35@V_DrawStri

; 2166 : 			colormap = NULL;

  0022d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _colormap$[ebp], 0
$LN35@V_DrawStri:

; 2167 : 
; 2168 : 		if (colormap != NULL && ((option & V_TRANSLUCENT) || (option & V_8020TRANS)))

  00234	83 7d d8 00	 cmp	 DWORD PTR _colormap$[ebp], 0
  00238	74 3c		 je	 SHORT $LN36@V_DrawStri
  0023a	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  0023d	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00242	75 0a		 jne	 SHORT $LN38@V_DrawStri
  00244	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00247	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0024c	74 28		 je	 SHORT $LN36@V_DrawStri
$LN38@V_DrawStri:

; 2169 : 			V_DrawTranslucentMappedPatch(cx, cy, option, hu_font[c], colormap);

  0024e	8b 45 d8	 mov	 eax, DWORD PTR _colormap$[ebp]
  00251	50		 push	 eax
  00252	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00255	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _hu_font[ecx*4]
  0025c	52		 push	 edx
  0025d	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00260	50		 push	 eax
  00261	8b 4d f0	 mov	 ecx, DWORD PTR _cy$[ebp]
  00264	51		 push	 ecx
  00265	8b 55 f4	 mov	 edx, DWORD PTR _cx$[ebp]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 _V_DrawTranslucentMappedPatch
  0026e	83 c4 14	 add	 esp, 20			; 00000014H
  00271	e9 85 00 00 00	 jmp	 $LN42@V_DrawStri
$LN36@V_DrawStri:

; 2170 : 		else if (colormap != NULL)

  00276	83 7d d8 00	 cmp	 DWORD PTR _colormap$[ebp], 0
  0027a	74 25		 je	 SHORT $LN39@V_DrawStri

; 2171 : 			V_DrawMappedPatch(cx, cy, option, hu_font[c], colormap);

  0027c	8b 45 d8	 mov	 eax, DWORD PTR _colormap$[ebp]
  0027f	50		 push	 eax
  00280	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00283	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _hu_font[ecx*4]
  0028a	52		 push	 edx
  0028b	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  0028e	50		 push	 eax
  0028f	8b 4d f0	 mov	 ecx, DWORD PTR _cy$[ebp]
  00292	51		 push	 ecx
  00293	8b 55 f4	 mov	 edx, DWORD PTR _cx$[ebp]
  00296	52		 push	 edx
  00297	e8 00 00 00 00	 call	 _V_DrawMappedPatch
  0029c	83 c4 14	 add	 esp, 20			; 00000014H
  0029f	eb 5a		 jmp	 SHORT $LN42@V_DrawStri
$LN39@V_DrawStri:

; 2172 : 		else if ((option & V_TRANSLUCENT) || (option & V_8020TRANS))

  002a1	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  002a4	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  002a9	75 0a		 jne	 SHORT $LN43@V_DrawStri
  002ab	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  002ae	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  002b3	74 27		 je	 SHORT $LN41@V_DrawStri
$LN43@V_DrawStri:

; 2173 : 			V_DrawTranslucentPatch(cx, cy, option & ~V_TRANSLUCENT, hu_font[c]);

  002b5	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  002b8	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _hu_font[eax*4]
  002bf	51		 push	 ecx
  002c0	8b 55 10	 mov	 edx, DWORD PTR _option$[ebp]
  002c3	81 e2 ff ff bf
	ff		 and	 edx, -4194305		; ffbfffffH
  002c9	52		 push	 edx
  002ca	8b 45 f0	 mov	 eax, DWORD PTR _cy$[ebp]
  002cd	50		 push	 eax
  002ce	8b 4d f4	 mov	 ecx, DWORD PTR _cx$[ebp]
  002d1	51		 push	 ecx
  002d2	e8 00 00 00 00	 call	 _V_DrawTranslucentPatch
  002d7	83 c4 10	 add	 esp, 16			; 00000010H
  002da	eb 1f		 jmp	 SHORT $LN42@V_DrawStri
$LN41@V_DrawStri:

; 2174 : 		else
; 2175 : 			V_DrawScaledPatch(cx, cy, option, hu_font[c]);

  002dc	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  002df	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _hu_font[eax*4]
  002e6	51		 push	 ecx
  002e7	8b 55 10	 mov	 edx, DWORD PTR _option$[ebp]
  002ea	52		 push	 edx
  002eb	8b 45 f0	 mov	 eax, DWORD PTR _cy$[ebp]
  002ee	50		 push	 eax
  002ef	8b 4d f4	 mov	 ecx, DWORD PTR _cx$[ebp]
  002f2	51		 push	 ecx
  002f3	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  002f8	83 c4 10	 add	 esp, 16			; 00000010H
$LN42@V_DrawStri:

; 2176 : 
; 2177 : 		cx += w;

  002fb	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  002fe	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  00301	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2178 : 	}

  00304	e9 7c fd ff ff	 jmp	 $LN2@V_DrawStri
$LN3@V_DrawStri:

; 2179 : }

  00309	5f		 pop	 edi
  0030a	5e		 pop	 esi
  0030b	5b		 pop	 ebx
  0030c	8b e5		 mov	 esp, ebp
  0030e	5d		 pop	 ebp
  0030f	c3		 ret	 0
_V_DrawString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawLevelTitle
_TEXT	SEGMENT
_ch$ = -32						; size = 4
_scrwidth$ = -28					; size = 4
_dupy$ = -24						; size = 4
_dupx$ = -20						; size = 4
_cy$ = -16						; size = 4
_cx$ = -12						; size = 4
_c$ = -8						; size = 4
_w$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_option$ = 16						; size = 4
_string$ = 20						; size = 4
_V_DrawLevelTitle PROC					; COMDAT

; 2317 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2318 : 	INT32 w, c, cx = x, cy = y, dupx, dupy, scrwidth = BASEVIDWIDTH;

  00009	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR _cy$[ebp], eax
  00015	c7 45 e4 40 01
	00 00		 mov	 DWORD PTR _scrwidth$[ebp], 320 ; 00000140H

; 2319 : 	const char *ch = string;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _string$[ebp]
  0001f	89 45 e0	 mov	 DWORD PTR _ch$[ebp], eax

; 2320 : 
; 2321 : 	if (option & V_NOSCALESTART)

  00022	8b 45 10	 mov	 eax, DWORD PTR _option$[ebp]
  00025	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0002a	74 1a		 je	 SHORT $LN5@V_DrawLeve

; 2322 : 	{
; 2323 : 		dupx = vid.dupx;

  0002c	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00031	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax

; 2324 : 		dupy = vid.dupy;

  00034	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00039	89 45 e8	 mov	 DWORD PTR _dupy$[ebp], eax

; 2325 : 		scrwidth = vid.width;

  0003c	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00041	89 45 e4	 mov	 DWORD PTR _scrwidth$[ebp], eax

; 2326 : 	}

  00044	eb 0d		 jmp	 SHORT $LN6@V_DrawLeve
$LN5@V_DrawLeve:

; 2327 : 	else
; 2328 : 		dupx = dupy = 1;

  00046	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  0004d	8b 45 e8	 mov	 eax, DWORD PTR _dupy$[ebp]
  00050	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax
$LN6@V_DrawLeve:
$LN2@V_DrawLeve:

; 2329 : 
; 2330 : 	for (;;)
; 2331 : 	{
; 2332 : 		c = *ch++;

  00053	8b 45 e0	 mov	 eax, DWORD PTR _ch$[ebp]
  00056	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00059	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
  0005c	8b 55 e0	 mov	 edx, DWORD PTR _ch$[ebp]
  0005f	83 c2 01	 add	 edx, 1
  00062	89 55 e0	 mov	 DWORD PTR _ch$[ebp], edx

; 2333 : 		if (!c)

  00065	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  00069	75 05		 jne	 SHORT $LN7@V_DrawLeve

; 2334 : 			break;

  0006b	e9 aa 00 00 00	 jmp	 $LN3@V_DrawLeve
$LN7@V_DrawLeve:

; 2335 : 		if (c == '\n')

  00070	83 7d f8 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  00074	75 12		 jne	 SHORT $LN8@V_DrawLeve

; 2336 : 		{
; 2337 : 			cx = x;

  00076	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00079	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2338 : 			cy += 12*dupy;

  0007c	6b 45 e8 0c	 imul	 eax, DWORD PTR _dupy$[ebp], 12
  00080	03 45 f0	 add	 eax, DWORD PTR _cy$[ebp]
  00083	89 45 f0	 mov	 DWORD PTR _cy$[ebp], eax

; 2339 : 			continue;

  00086	eb cb		 jmp	 SHORT $LN2@V_DrawLeve
$LN8@V_DrawLeve:

; 2340 : 		}
; 2341 : 
; 2342 : 		c = toupper(c);

  00088	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _toupper
  00091	83 c4 04	 add	 esp, 4
  00094	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 2343 : 		if ((c != LT_FONTSTART && (c < '0' || c > '9')) && (c < LT_REALFONTSTART || c > LT_FONTEND))

  00097	83 7d f8 27	 cmp	 DWORD PTR _c$[ebp], 39	; 00000027H
  0009b	74 26		 je	 SHORT $LN9@V_DrawLeve
  0009d	83 7d f8 30	 cmp	 DWORD PTR _c$[ebp], 48	; 00000030H
  000a1	7c 06		 jl	 SHORT $LN10@V_DrawLeve
  000a3	83 7d f8 39	 cmp	 DWORD PTR _c$[ebp], 57	; 00000039H
  000a7	7e 1a		 jle	 SHORT $LN9@V_DrawLeve
$LN10@V_DrawLeve:
  000a9	83 7d f8 41	 cmp	 DWORD PTR _c$[ebp], 65	; 00000041H
  000ad	7c 06		 jl	 SHORT $LN11@V_DrawLeve
  000af	83 7d f8 5a	 cmp	 DWORD PTR _c$[ebp], 90	; 0000005aH
  000b3	7e 0e		 jle	 SHORT $LN9@V_DrawLeve
$LN11@V_DrawLeve:

; 2344 : 		{ /// \note font start hack
; 2345 : 			cx += 16*dupx;

  000b5	8b 45 ec	 mov	 eax, DWORD PTR _dupx$[ebp]
  000b8	c1 e0 04	 shl	 eax, 4
  000bb	03 45 f4	 add	 eax, DWORD PTR _cx$[ebp]
  000be	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2346 : 			continue;

  000c1	eb 90		 jmp	 SHORT $LN2@V_DrawLeve
$LN9@V_DrawLeve:

; 2347 : 		}
; 2348 : 
; 2349 : 		c -= LT_FONTSTART;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000c6	83 e8 27	 sub	 eax, 39			; 00000027H
  000c9	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 2350 : 
; 2351 : 		w = SHORT(lt_font[c]->width) * dupx;

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000cf	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lt_font[eax*4]
  000d6	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  000d9	0f af 55 ec	 imul	 edx, DWORD PTR _dupx$[ebp]
  000dd	89 55 fc	 mov	 DWORD PTR _w$[ebp], edx

; 2352 : 		if (cx + w > scrwidth)

  000e0	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  000e3	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  000e6	3b 45 e4	 cmp	 eax, DWORD PTR _scrwidth$[ebp]
  000e9	7e 02		 jle	 SHORT $LN12@V_DrawLeve

; 2353 : 			break;

  000eb	eb 2d		 jmp	 SHORT $LN3@V_DrawLeve
$LN12@V_DrawLeve:

; 2354 : 
; 2355 : 		V_DrawScaledPatch(cx, cy, option, lt_font[c]);

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000f0	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _lt_font[eax*4]
  000f7	51		 push	 ecx
  000f8	8b 55 10	 mov	 edx, DWORD PTR _option$[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 f0	 mov	 eax, DWORD PTR _cy$[ebp]
  000ff	50		 push	 eax
  00100	8b 4d f4	 mov	 ecx, DWORD PTR _cx$[ebp]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00109	83 c4 10	 add	 esp, 16			; 00000010H

; 2356 : 		cx += w;

  0010c	8b 45 f4	 mov	 eax, DWORD PTR _cx$[ebp]
  0010f	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  00112	89 45 f4	 mov	 DWORD PTR _cx$[ebp], eax

; 2357 : 	}

  00115	e9 39 ff ff ff	 jmp	 $LN2@V_DrawLeve
$LN3@V_DrawLeve:

; 2358 : }

  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
_V_DrawLevelTitle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawCharacter
_TEXT	SEGMENT
tv65 = -80						; size = 4
_colormap$ = -12					; size = 4
_flags$ = -8						; size = 4
_w$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_c$ = 16						; size = 4
_lowercaseallowed$ = 20					; size = 4
_V_DrawCharacter PROC					; COMDAT

; 1987 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1988 : 	INT32 w, flags;
; 1989 : 	const UINT8 *colormap = NULL;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _colormap$[ebp], 0

; 1990 : 
; 1991 : 	switch (c & 0xff00)

  00010	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00013	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00018	89 45 b0	 mov	 DWORD PTR tv65[ebp], eax
  0001b	81 7d b0 00 04
	00 00		 cmp	 DWORD PTR tv65[ebp], 1024 ; 00000400H
  00022	7f 26		 jg	 SHORT $LN19@V_DrawChar
  00024	81 7d b0 00 04
	00 00		 cmp	 DWORD PTR tv65[ebp], 1024 ; 00000400H
  0002b	74 58		 je	 SHORT $LN7@V_DrawChar
  0002d	81 7d b0 00 01
	00 00		 cmp	 DWORD PTR tv65[ebp], 256 ; 00000100H
  00034	74 31		 je	 SHORT $LN4@V_DrawChar
  00036	81 7d b0 00 02
	00 00		 cmp	 DWORD PTR tv65[ebp], 512 ; 00000200H
  0003d	74 32		 je	 SHORT $LN5@V_DrawChar
  0003f	81 7d b0 00 03
	00 00		 cmp	 DWORD PTR tv65[ebp], 768 ; 00000300H
  00046	74 33		 je	 SHORT $LN6@V_DrawChar
  00048	eb 61		 jmp	 SHORT $LN2@V_DrawChar
$LN19@V_DrawChar:
  0004a	81 7d b0 00 05
	00 00		 cmp	 DWORD PTR tv65[ebp], 1280 ; 00000500H
  00051	74 3c		 je	 SHORT $LN8@V_DrawChar
  00053	81 7d b0 00 06
	00 00		 cmp	 DWORD PTR tv65[ebp], 1536 ; 00000600H
  0005a	74 3d		 je	 SHORT $LN9@V_DrawChar
  0005c	81 7d b0 00 07
	00 00		 cmp	 DWORD PTR tv65[ebp], 1792 ; 00000700H
  00063	74 3e		 je	 SHORT $LN10@V_DrawChar
  00065	eb 44		 jmp	 SHORT $LN2@V_DrawChar
$LN4@V_DrawChar:

; 1992 : 	{
; 1993 : 	case 0x100: // 0x81, purple
; 1994 : 		colormap = purplemap;

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _purplemap
  0006c	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax

; 1995 : 		break;

  0006f	eb 3a		 jmp	 SHORT $LN2@V_DrawChar
$LN5@V_DrawChar:

; 1996 : 	case 0x200: // 0x82, yellow
; 1997 : 		colormap = yellowmap;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _yellowmap
  00076	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax

; 1998 : 		break;

  00079	eb 30		 jmp	 SHORT $LN2@V_DrawChar
$LN6@V_DrawChar:

; 1999 : 	case 0x300: // 0x83, lgreen
; 2000 : 		colormap = lgreenmap;

  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lgreenmap
  00080	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax

; 2001 : 		break;

  00083	eb 26		 jmp	 SHORT $LN2@V_DrawChar
$LN7@V_DrawChar:

; 2002 : 	case 0x400: // 0x84, blue
; 2003 : 		colormap = bluemap;

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _bluemap
  0008a	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax

; 2004 : 		break;

  0008d	eb 1c		 jmp	 SHORT $LN2@V_DrawChar
$LN8@V_DrawChar:

; 2005 : 	case 0x500: // 0x85, red
; 2006 : 		colormap = redmap;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _redmap
  00094	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax

; 2007 : 		break;

  00097	eb 12		 jmp	 SHORT $LN2@V_DrawChar
$LN9@V_DrawChar:

; 2008 : 	case 0x600: // 0x86, gray
; 2009 : 		colormap = graymap;

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _graymap
  0009e	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax

; 2010 : 		break;

  000a1	eb 08		 jmp	 SHORT $LN2@V_DrawChar
$LN10@V_DrawChar:

; 2011 : 	case 0x700: // 0x87, orange
; 2012 : 		colormap = orangemap;

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _orangemap
  000a8	89 45 f4	 mov	 DWORD PTR _colormap$[ebp], eax
$LN2@V_DrawChar:

; 2013 : 		break;
; 2014 : 	}
; 2015 : 
; 2016 : 	flags = c & 0xffff0000;

  000ab	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  000ae	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  000b3	89 45 f8	 mov	 DWORD PTR _flags$[ebp], eax

; 2017 : 	c &= 0x7f;

  000b6	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  000b9	83 e0 7f	 and	 eax, 127		; 0000007fH
  000bc	89 45 10	 mov	 DWORD PTR _c$[ebp], eax

; 2018 : 	if (lowercaseallowed)

  000bf	83 7d 14 00	 cmp	 DWORD PTR _lowercaseallowed$[ebp], 0
  000c3	74 0b		 je	 SHORT $LN11@V_DrawChar

; 2019 : 		c -= HU_FONTSTART;

  000c5	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  000c8	83 e8 21	 sub	 eax, 33			; 00000021H
  000cb	89 45 10	 mov	 DWORD PTR _c$[ebp], eax
  000ce	eb 12		 jmp	 SHORT $LN12@V_DrawChar
$LN11@V_DrawChar:

; 2020 : 	else
; 2021 : 		c = toupper(c) - HU_FONTSTART;

  000d0	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _toupper
  000d9	83 c4 04	 add	 esp, 4
  000dc	83 e8 21	 sub	 eax, 33			; 00000021H
  000df	89 45 10	 mov	 DWORD PTR _c$[ebp], eax
$LN12@V_DrawChar:

; 2022 : 	if (c < 0 || (c >= HU_REALFONTSIZE && c != '~' - HU_FONTSTART && c != '`' - HU_FONTSTART))

  000e2	83 7d 10 00	 cmp	 DWORD PTR _c$[ebp], 0
  000e6	7c 12		 jl	 SHORT $LN14@V_DrawChar
  000e8	83 7d 10 5a	 cmp	 DWORD PTR _c$[ebp], 90	; 0000005aH
  000ec	7c 0e		 jl	 SHORT $LN13@V_DrawChar
  000ee	83 7d 10 5d	 cmp	 DWORD PTR _c$[ebp], 93	; 0000005dH
  000f2	74 08		 je	 SHORT $LN13@V_DrawChar
  000f4	83 7d 10 3f	 cmp	 DWORD PTR _c$[ebp], 63	; 0000003fH
  000f8	74 02		 je	 SHORT $LN13@V_DrawChar
$LN14@V_DrawChar:

; 2023 : 		return;

  000fa	eb 6a		 jmp	 SHORT $LN17@V_DrawChar
$LN13@V_DrawChar:

; 2024 : 
; 2025 : 	w = SHORT(hu_font[c]->width);

  000fc	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  000ff	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _hu_font[eax*4]
  00106	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00109	89 55 fc	 mov	 DWORD PTR _w$[ebp], edx

; 2026 : 	if (x + w > vid.width)

  0010c	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0010f	03 45 fc	 add	 eax, DWORD PTR _w$[ebp]
  00112	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  00118	7e 02		 jle	 SHORT $LN15@V_DrawChar

; 2027 : 		return;

  0011a	eb 4a		 jmp	 SHORT $LN17@V_DrawChar
$LN15@V_DrawChar:

; 2028 : 
; 2029 : 	if (colormap != NULL)

  0011c	83 7d f4 00	 cmp	 DWORD PTR _colormap$[ebp], 0
  00120	74 25		 je	 SHORT $LN16@V_DrawChar

; 2030 : 		V_DrawMappedPatch(x, y, flags, hu_font[c], colormap);

  00122	8b 45 f4	 mov	 eax, DWORD PTR _colormap$[ebp]
  00125	50		 push	 eax
  00126	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  00129	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _hu_font[ecx*4]
  00130	52		 push	 edx
  00131	8b 45 f8	 mov	 eax, DWORD PTR _flags$[ebp]
  00134	50		 push	 eax
  00135	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00138	51		 push	 ecx
  00139	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0013c	52		 push	 edx
  0013d	e8 00 00 00 00	 call	 _V_DrawMappedPatch
  00142	83 c4 14	 add	 esp, 20			; 00000014H
  00145	eb 1f		 jmp	 SHORT $LN17@V_DrawChar
$LN16@V_DrawChar:

; 2031 : 	else
; 2032 : 		V_DrawScaledPatch(x, y, flags, hu_font[c]);

  00147	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0014a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _hu_font[eax*4]
  00151	51		 push	 ecx
  00152	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  00155	52		 push	 edx
  00156	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00159	50		 push	 eax
  0015a	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0015d	51		 push	 ecx
  0015e	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00163	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@V_DrawChar:

; 2033 : }

  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
_V_DrawCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawFadeConsBack
_TEXT	SEGMENT
tv71 = -108						; size = 4
tv75 = -108						; size = 4
_hwcolor$1 = -40					; size = 4
_colormap$ = -36					; size = 4
_deststop$ = -32					; size = 4
_wput$ = -28						; size = 4
_p4$ = -24						; size = 1
_p3$ = -23						; size = 1
_p2$ = -22						; size = 1
_p1$ = -21						; size = 1
_quad$ = -20						; size = 4
_buf$ = -16						; size = 4
_w$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_px1$ = 8						; size = 4
_py1$ = 12						; size = 4
_px2$ = 16						; size = 4
_py2$ = 20						; size = 4
_color$ = 24						; size = 4
_V_DrawFadeConsBack PROC				; COMDAT

; 1877 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1878 : 	INT32 x, y, w;
; 1879 : 	INT32 *buf;
; 1880 : 	UINT32 quad;
; 1881 : 	UINT8 p1, p2, p3, p4;
; 1882 : 	INT16 *wput;
; 1883 : 	const UINT8 *deststop = screens[0] + vid.width * vid.height * vid.bpp;

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  00017	0f af 15 10 00
	00 00		 imul	 edx, DWORD PTR _vid+16
  0001e	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR _vid+48
  00025	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  0002b	89 55 e0	 mov	 DWORD PTR _deststop$[ebp], edx

; 1884 : 	UINT8 *colormap;
; 1885 : 
; 1886 : #ifdef HWRENDER // not win32 only 19990829 by Kin
; 1887 : 	if (rendermode != render_soft && rendermode != render_none)

  0002e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00035	74 71		 je	 SHORT $LN18@V_DrawFade
  00037	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0003e	74 68		 je	 SHORT $LN18@V_DrawFade

; 1888 : 	{
; 1889 : 		UINT32 hwcolor;
; 1890 : 
; 1891 : 		switch (color)

  00040	8b 45 18	 mov	 eax, DWORD PTR _color$[ebp]
  00043	89 45 94	 mov	 DWORD PTR tv71[ebp], eax
  00046	83 7d 94 05	 cmp	 DWORD PTR tv71[ebp], 5
  0004a	77 40		 ja	 SHORT $LN25@V_DrawFade
  0004c	8b 4d 94	 mov	 ecx, DWORD PTR tv71[ebp]
  0004f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN38@V_DrawFade[ecx*4]
$LN19@V_DrawFade:

; 1892 : 		{
; 1893 : 			case 0: // white
; 1894 : 				hwcolor = 0xffffff00;

  00056	c7 45 d8 00 ff
	ff ff		 mov	 DWORD PTR _hwcolor$1[ebp], -256 ; ffffff00H

; 1895 : 				break;

  0005d	eb 34		 jmp	 SHORT $LN2@V_DrawFade
$LN20@V_DrawFade:

; 1896 : 			case 1: // orange
; 1897 : 				hwcolor = 0xff800000;

  0005f	c7 45 d8 00 00
	80 ff		 mov	 DWORD PTR _hwcolor$1[ebp], -8388608 ; ff800000H

; 1898 : 				break;

  00066	eb 2b		 jmp	 SHORT $LN2@V_DrawFade
$LN21@V_DrawFade:

; 1899 : 			case 2: // blue
; 1900 : 				hwcolor = 0x0000ff00;

  00068	c7 45 d8 00 ff
	00 00		 mov	 DWORD PTR _hwcolor$1[ebp], 65280 ; 0000ff00H

; 1901 : 				break;

  0006f	eb 22		 jmp	 SHORT $LN2@V_DrawFade
$LN22@V_DrawFade:

; 1902 : 			case 3: // green
; 1903 : 				hwcolor = 0x00800000;

  00071	c7 45 d8 00 00
	80 00		 mov	 DWORD PTR _hwcolor$1[ebp], 8388608 ; 00800000H

; 1904 : 				break;

  00078	eb 19		 jmp	 SHORT $LN2@V_DrawFade
$LN23@V_DrawFade:

; 1905 : 			case 4: // gray
; 1906 : 				hwcolor = 0x80808000;

  0007a	c7 45 d8 00 80
	80 80		 mov	 DWORD PTR _hwcolor$1[ebp], -2139062272 ; 80808000H

; 1907 : 				break;

  00081	eb 10		 jmp	 SHORT $LN2@V_DrawFade
$LN24@V_DrawFade:

; 1908 : 			case 5: // red
; 1909 : 				hwcolor = 0xff000000;

  00083	c7 45 d8 00 00
	00 ff		 mov	 DWORD PTR _hwcolor$1[ebp], -16777216 ; ff000000H

; 1910 : 				break;

  0008a	eb 07		 jmp	 SHORT $LN2@V_DrawFade
$LN25@V_DrawFade:

; 1911 : 			default:
; 1912 : 				hwcolor = 0x00800000;

  0008c	c7 45 d8 00 00
	80 00		 mov	 DWORD PTR _hwcolor$1[ebp], 8388608 ; 00800000H
$LN2@V_DrawFade:

; 1913 : 				break;
; 1914 : 		}
; 1915 : 
; 1916 : 		HWR_DrawConsoleBack(hwcolor, py2);

  00093	8b 45 14	 mov	 eax, DWORD PTR _py2$[ebp]
  00096	50		 push	 eax
  00097	8b 4d d8	 mov	 ecx, DWORD PTR _hwcolor$1[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _HWR_DrawConsoleBack
  000a0	83 c4 08	 add	 esp, 8

; 1917 : 		return;

  000a3	e9 1c 02 00 00	 jmp	 $LN13@V_DrawFade
$LN18@V_DrawFade:

; 1918 : 	}
; 1919 : #endif
; 1920 : 
; 1921 : 	switch (color)

  000a8	8b 45 18	 mov	 eax, DWORD PTR _color$[ebp]
  000ab	89 45 94	 mov	 DWORD PTR tv75[ebp], eax
  000ae	83 7d 94 05	 cmp	 DWORD PTR tv75[ebp], 5
  000b2	77 46		 ja	 SHORT $LN32@V_DrawFade
  000b4	8b 4d 94	 mov	 ecx, DWORD PTR tv75[ebp]
  000b7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN39@V_DrawFade[ecx*4]
$LN26@V_DrawFade:

; 1922 : 	{
; 1923 : 		case 0:
; 1924 : 			colormap = cwhitemap;

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR _cwhitemap
  000c3	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax

; 1925 : 			break;

  000c6	eb 3a		 jmp	 SHORT $LN4@V_DrawFade
$LN27@V_DrawFade:

; 1926 : 		case 1:
; 1927 : 			colormap = corangemap;

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _corangemap
  000cd	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax

; 1928 : 			break;

  000d0	eb 30		 jmp	 SHORT $LN4@V_DrawFade
$LN28@V_DrawFade:

; 1929 : 		case 2:
; 1930 : 			colormap = cbluemap;

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _cbluemap
  000d7	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax

; 1931 : 			break;

  000da	eb 26		 jmp	 SHORT $LN4@V_DrawFade
$LN29@V_DrawFade:

; 1932 : 		case 3:
; 1933 : 			colormap = cgreenmap;

  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _cgreenmap
  000e1	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax

; 1934 : 			break;

  000e4	eb 1c		 jmp	 SHORT $LN4@V_DrawFade
$LN30@V_DrawFade:

; 1935 : 		case 4:
; 1936 : 			colormap = cgraymap;

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _cgraymap
  000eb	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax

; 1937 : 			break;

  000ee	eb 12		 jmp	 SHORT $LN4@V_DrawFade
$LN31@V_DrawFade:

; 1938 : 		case 5:
; 1939 : 			colormap = credmap;

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _credmap
  000f5	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax

; 1940 : 			break;

  000f8	eb 08		 jmp	 SHORT $LN4@V_DrawFade
$LN32@V_DrawFade:

; 1941 : 		default:
; 1942 : 			colormap = cgreenmap;

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _cgreenmap
  000ff	89 45 dc	 mov	 DWORD PTR _colormap$[ebp], eax
$LN4@V_DrawFade:

; 1943 : 			break;
; 1944 : 	}
; 1945 : 
; 1946 : 	if (scr_bpp == 1)

  00102	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _scr_bpp, 1
  00109	0f 85 25 01 00
	00		 jne	 $LN33@V_DrawFade

; 1947 : 	{
; 1948 : 		px1 >>=2;

  0010f	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  00112	c1 f8 02	 sar	 eax, 2
  00115	89 45 08	 mov	 DWORD PTR _px1$[ebp], eax

; 1949 : 		px2 >>=2;

  00118	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  0011b	c1 f8 02	 sar	 eax, 2
  0011e	89 45 10	 mov	 DWORD PTR _px2$[ebp], eax

; 1950 : 		for (y = py1; y < py2; y++)

  00121	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  00124	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
  00127	eb 09		 jmp	 SHORT $LN8@V_DrawFade
$LN6@V_DrawFade:
  00129	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0012c	83 c0 01	 add	 eax, 1
  0012f	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN8@V_DrawFade:
  00132	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00135	3b 45 14	 cmp	 eax, DWORD PTR _py2$[ebp]
  00138	0f 8d f1 00 00
	00		 jge	 $LN7@V_DrawFade

; 1951 : 		{
; 1952 : 			buf = (INT32 *)(void *)(screens[0] + vid.width*y);

  0013e	b8 04 00 00 00	 mov	 eax, 4
  00143	6b c8 00	 imul	 ecx, eax, 0
  00146	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  0014c	0f af 55 f8	 imul	 edx, DWORD PTR _y$[ebp]
  00150	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  00156	89 55 f0	 mov	 DWORD PTR _buf$[ebp], edx

; 1953 : 			for (x = px1; x < px2; x++)

  00159	8b 45 08	 mov	 eax, DWORD PTR _px1$[ebp]
  0015c	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
  0015f	eb 09		 jmp	 SHORT $LN11@V_DrawFade
$LN9@V_DrawFade:
  00161	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00164	83 c0 01	 add	 eax, 1
  00167	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN11@V_DrawFade:
  0016a	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0016d	3b 45 10	 cmp	 eax, DWORD PTR _px2$[ebp]
  00170	0f 8d b4 00 00
	00		 jge	 $LN10@V_DrawFade

; 1954 : 			{
; 1955 : 				if (&buf[x] > (const INT32 *)(const void *)deststop)

  00176	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00179	8b 4d f0	 mov	 ecx, DWORD PTR _buf$[ebp]
  0017c	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0017f	3b 55 e0	 cmp	 edx, DWORD PTR _deststop$[ebp]
  00182	76 05		 jbe	 SHORT $LN35@V_DrawFade

; 1956 : 					return;

  00184	e9 3b 01 00 00	 jmp	 $LN13@V_DrawFade
$LN35@V_DrawFade:

; 1957 : 				M_Memcpy(&quad,buf+x,sizeof (quad)); //quad = buf[x];

  00189	6a 04		 push	 4
  0018b	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0018e	8b 4d f0	 mov	 ecx, DWORD PTR _buf$[ebp]
  00191	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00194	52		 push	 edx
  00195	8d 45 ec	 lea	 eax, DWORD PTR _quad$[ebp]
  00198	50		 push	 eax
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1958 : 				p1 = colormap[quad&255];

  001a2	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  001a5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001aa	8b 4d dc	 mov	 ecx, DWORD PTR _colormap$[ebp]
  001ad	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001b0	88 55 eb	 mov	 BYTE PTR _p1$[ebp], dl

; 1959 : 				p2 = colormap[(quad>>8)&255];

  001b3	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  001b6	c1 e8 08	 shr	 eax, 8
  001b9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001be	8b 4d dc	 mov	 ecx, DWORD PTR _colormap$[ebp]
  001c1	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001c4	88 55 ea	 mov	 BYTE PTR _p2$[ebp], dl

; 1960 : 				p3 = colormap[(quad>>16)&255];

  001c7	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  001ca	c1 e8 10	 shr	 eax, 16			; 00000010H
  001cd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR _colormap$[ebp]
  001d5	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001d8	88 55 e9	 mov	 BYTE PTR _p3$[ebp], dl

; 1961 : 				p4 = colormap[quad>>24];

  001db	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  001de	c1 e8 18	 shr	 eax, 24			; 00000018H
  001e1	8b 4d dc	 mov	 ecx, DWORD PTR _colormap$[ebp]
  001e4	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001e7	88 55 e8	 mov	 BYTE PTR _p4$[ebp], dl

; 1962 : 				quad = (p4<<24) | (p3<<16) | (p2<<8) | p1;//buf[x] = (p4<<24) | (p3<<16) | (p2<<8) | p1;

  001ea	0f b6 45 e8	 movzx	 eax, BYTE PTR _p4$[ebp]
  001ee	c1 e0 18	 shl	 eax, 24			; 00000018H
  001f1	0f b6 4d e9	 movzx	 ecx, BYTE PTR _p3$[ebp]
  001f5	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001f8	0b c1		 or	 eax, ecx
  001fa	0f b6 55 ea	 movzx	 edx, BYTE PTR _p2$[ebp]
  001fe	c1 e2 08	 shl	 edx, 8
  00201	0b c2		 or	 eax, edx
  00203	0f b6 4d eb	 movzx	 ecx, BYTE PTR _p1$[ebp]
  00207	0b c1		 or	 eax, ecx
  00209	89 45 ec	 mov	 DWORD PTR _quad$[ebp], eax

; 1963 : 				M_Memcpy(buf+x, &quad, sizeof (quad));

  0020c	6a 04		 push	 4
  0020e	8d 45 ec	 lea	 eax, DWORD PTR _quad$[ebp]
  00211	50		 push	 eax
  00212	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  00215	8b 55 f0	 mov	 edx, DWORD PTR _buf$[ebp]
  00218	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0021b	50		 push	 eax
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00222	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1964 : 			}

  00225	e9 37 ff ff ff	 jmp	 $LN9@V_DrawFade
$LN10@V_DrawFade:

; 1965 : 		}

  0022a	e9 fa fe ff ff	 jmp	 $LN6@V_DrawFade
$LN7@V_DrawFade:

; 1966 : 	}

  0022f	e9 90 00 00 00	 jmp	 $LN13@V_DrawFade
$LN33@V_DrawFade:

; 1967 : 	else
; 1968 : 	{
; 1969 : 		w = px2 - px1;

  00234	8b 45 10	 mov	 eax, DWORD PTR _px2$[ebp]
  00237	2b 45 08	 sub	 eax, DWORD PTR _px1$[ebp]
  0023a	89 45 f4	 mov	 DWORD PTR _w$[ebp], eax

; 1970 : 		for (y = py1; y < py2; y++)

  0023d	8b 45 0c	 mov	 eax, DWORD PTR _py1$[ebp]
  00240	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
  00243	eb 09		 jmp	 SHORT $LN14@V_DrawFade
$LN12@V_DrawFade:
  00245	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00248	83 c0 01	 add	 eax, 1
  0024b	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN14@V_DrawFade:
  0024e	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00251	3b 45 14	 cmp	 eax, DWORD PTR _py2$[ebp]
  00254	7d 6e		 jge	 SHORT $LN13@V_DrawFade

; 1971 : 		{
; 1972 : 			wput = (INT16 *)(void *)(screens[0] + vid.width*y) + px1;

  00256	b8 04 00 00 00	 mov	 eax, 4
  0025b	6b c8 00	 imul	 ecx, eax, 0
  0025e	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  00264	0f af 55 f8	 imul	 edx, DWORD PTR _y$[ebp]
  00268	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  0026e	03 c2		 add	 eax, edx
  00270	8b 4d 08	 mov	 ecx, DWORD PTR _px1$[ebp]
  00273	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00276	89 55 e4	 mov	 DWORD PTR _wput$[ebp], edx

; 1973 : 			for (x = 0; x < w; x++)

  00279	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00280	eb 09		 jmp	 SHORT $LN17@V_DrawFade
$LN15@V_DrawFade:
  00282	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00285	83 c0 01	 add	 eax, 1
  00288	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN17@V_DrawFade:
  0028b	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0028e	3b 45 f4	 cmp	 eax, DWORD PTR _w$[ebp]
  00291	7d 2f		 jge	 SHORT $LN16@V_DrawFade

; 1974 : 			{
; 1975 : 				if (wput > (const INT16 *)(const void *)deststop)

  00293	8b 45 e4	 mov	 eax, DWORD PTR _wput$[ebp]
  00296	3b 45 e0	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00299	76 02		 jbe	 SHORT $LN36@V_DrawFade

; 1976 : 					return;

  0029b	eb 27		 jmp	 SHORT $LN13@V_DrawFade
$LN36@V_DrawFade:

; 1977 : 				*wput = (INT16)(((*wput&0x7bde) + (15<<5)) >>1);

  0029d	8b 45 e4	 mov	 eax, DWORD PTR _wput$[ebp]
  002a0	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002a3	81 e1 de 7b 00
	00		 and	 ecx, 31710		; 00007bdeH
  002a9	81 c1 e0 01 00
	00		 add	 ecx, 480		; 000001e0H
  002af	d1 f9		 sar	 ecx, 1
  002b1	8b 55 e4	 mov	 edx, DWORD PTR _wput$[ebp]
  002b4	66 89 0a	 mov	 WORD PTR [edx], cx

; 1978 : 				wput++;

  002b7	8b 45 e4	 mov	 eax, DWORD PTR _wput$[ebp]
  002ba	83 c0 02	 add	 eax, 2
  002bd	89 45 e4	 mov	 DWORD PTR _wput$[ebp], eax

; 1979 : 			}

  002c0	eb c0		 jmp	 SHORT $LN15@V_DrawFade
$LN16@V_DrawFade:

; 1980 : 		}

  002c2	eb 81		 jmp	 SHORT $LN12@V_DrawFade
$LN13@V_DrawFade:

; 1981 : 	}
; 1982 : }

  002c4	5f		 pop	 edi
  002c5	5e		 pop	 esi
  002c6	5b		 pop	 ebx
  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
  002cb	90		 npad	 1
$LN38@V_DrawFade:
  002cc	00 00 00 00	 DD	 $LN19@V_DrawFade
  002d0	00 00 00 00	 DD	 $LN20@V_DrawFade
  002d4	00 00 00 00	 DD	 $LN21@V_DrawFade
  002d8	00 00 00 00	 DD	 $LN22@V_DrawFade
  002dc	00 00 00 00	 DD	 $LN23@V_DrawFade
  002e0	00 00 00 00	 DD	 $LN24@V_DrawFade
$LN39@V_DrawFade:
  002e4	00 00 00 00	 DD	 $LN26@V_DrawFade
  002e8	00 00 00 00	 DD	 $LN27@V_DrawFade
  002ec	00 00 00 00	 DD	 $LN28@V_DrawFade
  002f0	00 00 00 00	 DD	 $LN29@V_DrawFade
  002f4	00 00 00 00	 DD	 $LN30@V_DrawFade
  002f8	00 00 00 00	 DD	 $LN31@V_DrawFade
_V_DrawFadeConsBack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawFadeScreen
_TEXT	SEGMENT
_deststop$ = -32					; size = 4
_fadetable$ = -28					; size = 4
_p4$ = -24						; size = 1
_p3$ = -23						; size = 1
_p2$ = -22						; size = 1
_p1$ = -21						; size = 1
_quad$ = -20						; size = 4
_buf$ = -16						; size = 4
_w$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_V_DrawFadeScreen PROC					; COMDAT

; 1840 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1841 : 	INT32 x, y, w;
; 1842 : 	INT32 *buf;
; 1843 : 	UINT32 quad;
; 1844 : 	UINT8 p1, p2, p3, p4;
; 1845 : 	const UINT8 *fadetable = (UINT8 *)colormaps + 16*256, *deststop = screens[0] + vid.width * vid.height * vid.bpp;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _colormaps
  0000e	05 00 10 00 00	 add	 eax, 4096		; 00001000H
  00013	89 45 e4	 mov	 DWORD PTR _fadetable$[ebp], eax
  00016	b8 04 00 00 00	 mov	 eax, 4
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  00024	0f af 15 10 00
	00 00		 imul	 edx, DWORD PTR _vid+16
  0002b	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR _vid+48
  00032	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  00038	89 55 e0	 mov	 DWORD PTR _deststop$[ebp], edx

; 1846 : 
; 1847 : #ifdef HWRENDER
; 1848 : 	if (rendermode != render_soft && rendermode != render_none)

  0003b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00042	74 1d		 je	 SHORT $LN8@V_DrawFade
  00044	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0004b	74 14		 je	 SHORT $LN8@V_DrawFade

; 1849 : 	{
; 1850 : 		HWR_FadeScreenMenuBack(0x01010160, 0); // hack, 0 means full height

  0004d	6a 00		 push	 0
  0004f	68 60 01 01 01	 push	 16843104		; 01010160H
  00054	e8 00 00 00 00	 call	 _HWR_FadeScreenMenuBack
  00059	83 c4 08	 add	 esp, 8

; 1851 : 		return;

  0005c	e9 1e 01 00 00	 jmp	 $LN3@V_DrawFade
$LN8@V_DrawFade:

; 1852 : 	}
; 1853 : #endif
; 1854 : 
; 1855 : 	w = vid.width>>2;

  00061	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00066	c1 f8 02	 sar	 eax, 2
  00069	89 45 f4	 mov	 DWORD PTR _w$[ebp], eax

; 1856 : 	for (y = 0; y < vid.height; y++)

  0006c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN4@V_DrawFade
$LN2@V_DrawFade:
  00075	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@V_DrawFade:
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00081	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00087	0f 8d f2 00 00
	00		 jge	 $LN3@V_DrawFade

; 1857 : 	{
; 1858 : 		buf = (INT32 *)(void *)(screens[0] + vid.width*y);

  0008d	b8 04 00 00 00	 mov	 eax, 4
  00092	6b c8 00	 imul	 ecx, eax, 0
  00095	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  0009b	0f af 55 f8	 imul	 edx, DWORD PTR _y$[ebp]
  0009f	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  000a5	89 55 f0	 mov	 DWORD PTR _buf$[ebp], edx

; 1859 : 		for (x = 0; x < w; x++)

  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  000af	eb 09		 jmp	 SHORT $LN7@V_DrawFade
$LN5@V_DrawFade:
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@V_DrawFade:
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000bd	3b 45 f4	 cmp	 eax, DWORD PTR _w$[ebp]
  000c0	0f 8d b4 00 00
	00		 jge	 $LN6@V_DrawFade

; 1860 : 		{
; 1861 : 			if (buf+ x > (const INT32 *)(const void *)deststop)

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000c9	8b 4d f0	 mov	 ecx, DWORD PTR _buf$[ebp]
  000cc	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000cf	3b 55 e0	 cmp	 edx, DWORD PTR _deststop$[ebp]
  000d2	76 05		 jbe	 SHORT $LN9@V_DrawFade

; 1862 : 				return;

  000d4	e9 a6 00 00 00	 jmp	 $LN3@V_DrawFade
$LN9@V_DrawFade:

; 1863 : 			M_Memcpy(&quad,buf+x,sizeof (quad)); //quad = buf[x];

  000d9	6a 04		 push	 4
  000db	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _buf$[ebp]
  000e1	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000e4	52		 push	 edx
  000e5	8d 45 ec	 lea	 eax, DWORD PTR _quad$[ebp]
  000e8	50		 push	 eax
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1864 : 			p1 = fadetable[quad&255];

  000f2	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  000f5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000fa	8b 4d e4	 mov	 ecx, DWORD PTR _fadetable$[ebp]
  000fd	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00100	88 55 eb	 mov	 BYTE PTR _p1$[ebp], dl

; 1865 : 			p2 = fadetable[(quad>>8)&255];

  00103	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  00106	c1 e8 08	 shr	 eax, 8
  00109	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010e	8b 4d e4	 mov	 ecx, DWORD PTR _fadetable$[ebp]
  00111	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00114	88 55 ea	 mov	 BYTE PTR _p2$[ebp], dl

; 1866 : 			p3 = fadetable[(quad>>16)&255];

  00117	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  0011a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0011d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00122	8b 4d e4	 mov	 ecx, DWORD PTR _fadetable$[ebp]
  00125	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00128	88 55 e9	 mov	 BYTE PTR _p3$[ebp], dl

; 1867 : 			p4 = fadetable[quad>>24];

  0012b	8b 45 ec	 mov	 eax, DWORD PTR _quad$[ebp]
  0012e	c1 e8 18	 shr	 eax, 24			; 00000018H
  00131	8b 4d e4	 mov	 ecx, DWORD PTR _fadetable$[ebp]
  00134	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00137	88 55 e8	 mov	 BYTE PTR _p4$[ebp], dl

; 1868 : 			quad = (p4<<24) | (p3<<16) | (p2<<8) | p1;//buf[x] = (p4<<24) | (p3<<16) | (p2<<8) | p1;

  0013a	0f b6 45 e8	 movzx	 eax, BYTE PTR _p4$[ebp]
  0013e	c1 e0 18	 shl	 eax, 24			; 00000018H
  00141	0f b6 4d e9	 movzx	 ecx, BYTE PTR _p3$[ebp]
  00145	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00148	0b c1		 or	 eax, ecx
  0014a	0f b6 55 ea	 movzx	 edx, BYTE PTR _p2$[ebp]
  0014e	c1 e2 08	 shl	 edx, 8
  00151	0b c2		 or	 eax, edx
  00153	0f b6 4d eb	 movzx	 ecx, BYTE PTR _p1$[ebp]
  00157	0b c1		 or	 eax, ecx
  00159	89 45 ec	 mov	 DWORD PTR _quad$[ebp], eax

; 1869 : 			M_Memcpy(buf+x,&quad,sizeof (quad));

  0015c	6a 04		 push	 4
  0015e	8d 45 ec	 lea	 eax, DWORD PTR _quad$[ebp]
  00161	50		 push	 eax
  00162	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  00165	8b 55 f0	 mov	 edx, DWORD PTR _buf$[ebp]
  00168	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0016b	50		 push	 eax
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1870 : 		}

  00175	e9 37 ff ff ff	 jmp	 $LN5@V_DrawFade
$LN6@V_DrawFade:

; 1871 : 	}

  0017a	e9 f6 fe ff ff	 jmp	 $LN2@V_DrawFade
$LN3@V_DrawFade:

; 1872 : }

  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
_V_DrawFadeScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawFlatFill
_TEXT	SEGMENT
tv73 = -128						; size = 4
_flatshift$ = -60					; size = 4
_lflatsize$ = -56					; size = 4
_size$ = -52						; size = 4
_dest$ = -48						; size = 4
_flat$ = -44						; size = 4
_deststop$ = -40					; size = 4
_src$ = -36						; size = 4
_yfrac$ = -32						; size = 4
_xfrac$ = -28						; size = 4
_dy$ = -24						; size = 4
_dx$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_v$ = -8						; size = 4
_u$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_flatnum$ = 24						; size = 4
_V_DrawFlatFill PROC					; COMDAT

; 1724 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1725 : 	INT32 u, v, dupx, dupy;
; 1726 : 	fixed_t dx, dy, xfrac, yfrac;
; 1727 : 	const UINT8 *src, *deststop;
; 1728 : 	UINT8 *flat, *dest;
; 1729 : 	size_t size, lflatsize, flatshift;
; 1730 : 
; 1731 : #ifdef HWRENDER
; 1732 : 	if (rendermode != render_soft && rendermode != render_none)

  0000c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00013	74 2a		 je	 SHORT $LN10@V_DrawFlat
  00015	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0001c	74 21		 je	 SHORT $LN10@V_DrawFlat

; 1733 : 	{
; 1734 : 		HWR_DrawFlatFill(x, y, w, h, flatnum);

  0001e	8b 45 18	 mov	 eax, DWORD PTR _flatnum$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 10	 mov	 edx, DWORD PTR _w$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _HWR_DrawFlatFill
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 1735 : 		return;

  0003a	e9 92 02 00 00	 jmp	 $LN5@V_DrawFlat
$LN10@V_DrawFlat:

; 1736 : 	}
; 1737 : #endif
; 1738 : 
; 1739 : 	size = W_LumpLength(flatnum);

  0003f	8b 45 18	 mov	 eax, DWORD PTR _flatnum$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _W_LumpLength
  00048	83 c4 04	 add	 esp, 4
  0004b	89 45 cc	 mov	 DWORD PTR _size$[ebp], eax

; 1740 : 
; 1741 : 	switch (size)

  0004e	8b 45 cc	 mov	 eax, DWORD PTR _size$[ebp]
  00051	89 45 80	 mov	 DWORD PTR tv73[ebp], eax
  00054	81 7d 80 00 00
	04 00		 cmp	 DWORD PTR tv73[ebp], 262144 ; 00040000H
  0005b	77 26		 ja	 SHORT $LN22@V_DrawFlat
  0005d	81 7d 80 00 00
	04 00		 cmp	 DWORD PTR tv73[ebp], 262144 ; 00040000H
  00064	74 51		 je	 SHORT $LN13@V_DrawFlat
  00066	81 7d 80 00 04
	00 00		 cmp	 DWORD PTR tv73[ebp], 1024 ; 00000400H
  0006d	74 78		 je	 SHORT $LN16@V_DrawFlat
  0006f	81 7d 80 00 40
	00 00		 cmp	 DWORD PTR tv73[ebp], 16384 ; 00004000H
  00076	74 5f		 je	 SHORT $LN15@V_DrawFlat
  00078	81 7d 80 00 00
	01 00		 cmp	 DWORD PTR tv73[ebp], 65536 ; 00010000H
  0007f	74 46		 je	 SHORT $LN14@V_DrawFlat
  00081	eb 74		 jmp	 SHORT $LN17@V_DrawFlat
$LN22@V_DrawFlat:
  00083	81 7d 80 00 00
	10 00		 cmp	 DWORD PTR tv73[ebp], 1048576 ; 00100000H
  0008a	74 1b		 je	 SHORT $LN12@V_DrawFlat
  0008c	81 7d 80 00 00
	40 00		 cmp	 DWORD PTR tv73[ebp], 4194304 ; 00400000H
  00093	74 02		 je	 SHORT $LN11@V_DrawFlat
  00095	eb 60		 jmp	 SHORT $LN17@V_DrawFlat
$LN11@V_DrawFlat:

; 1742 : 	{
; 1743 : 		case 4194304: // 2048x2048 lump
; 1744 : 			lflatsize = 2048;

  00097	c7 45 c8 00 08
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 2048 ; 00000800H

; 1745 : 			flatshift = 10;

  0009e	c7 45 c4 0a 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 10 ; 0000000aH

; 1746 : 			break;

  000a5	eb 5e		 jmp	 SHORT $LN2@V_DrawFlat
$LN12@V_DrawFlat:

; 1747 : 		case 1048576: // 1024x1024 lump
; 1748 : 			lflatsize = 1024;

  000a7	c7 45 c8 00 04
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 1024 ; 00000400H

; 1749 : 			flatshift = 9;

  000ae	c7 45 c4 09 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 9

; 1750 : 			break;

  000b5	eb 4e		 jmp	 SHORT $LN2@V_DrawFlat
$LN13@V_DrawFlat:

; 1751 : 		case 262144:// 512x512 lump
; 1752 : 			lflatsize = 512;

  000b7	c7 45 c8 00 02
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 512 ; 00000200H

; 1753 : 			flatshift = 8;

  000be	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 8

; 1754 : 			break;

  000c5	eb 3e		 jmp	 SHORT $LN2@V_DrawFlat
$LN14@V_DrawFlat:

; 1755 : 		case 65536: // 256x256 lump
; 1756 : 			lflatsize = 256;

  000c7	c7 45 c8 00 01
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 256 ; 00000100H

; 1757 : 			flatshift = 7;

  000ce	c7 45 c4 07 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 7

; 1758 : 			break;

  000d5	eb 2e		 jmp	 SHORT $LN2@V_DrawFlat
$LN15@V_DrawFlat:

; 1759 : 		case 16384: // 128x128 lump
; 1760 : 			lflatsize = 128;

  000d7	c7 45 c8 80 00
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 128 ; 00000080H

; 1761 : 			flatshift = 7;

  000de	c7 45 c4 07 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 7

; 1762 : 			break;

  000e5	eb 1e		 jmp	 SHORT $LN2@V_DrawFlat
$LN16@V_DrawFlat:

; 1763 : 		case 1024: // 32x32 lump
; 1764 : 			lflatsize = 32;

  000e7	c7 45 c8 20 00
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 32 ; 00000020H

; 1765 : 			flatshift = 5;

  000ee	c7 45 c4 05 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 5

; 1766 : 			break;

  000f5	eb 0e		 jmp	 SHORT $LN2@V_DrawFlat
$LN17@V_DrawFlat:

; 1767 : 		default: // 64x64 lump
; 1768 : 			lflatsize = 64;

  000f7	c7 45 c8 40 00
	00 00		 mov	 DWORD PTR _lflatsize$[ebp], 64 ; 00000040H

; 1769 : 			flatshift = 6;

  000fe	c7 45 c4 06 00
	00 00		 mov	 DWORD PTR _flatshift$[ebp], 6
$LN2@V_DrawFlat:

; 1770 : 			break;
; 1771 : 	}
; 1772 : 
; 1773 : 	flat = W_CacheLumpNum(flatnum, PU_CACHE);

  00105	6a 65		 push	 101			; 00000065H
  00107	8b 45 18	 mov	 eax, DWORD PTR _flatnum$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00110	83 c4 08	 add	 esp, 8
  00113	89 45 d4	 mov	 DWORD PTR _flat$[ebp], eax

; 1774 : 
; 1775 : 	dupx = vid.dupx;

  00116	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  0011b	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 1776 : 	dupy = vid.dupy;

  0011e	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00123	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax

; 1777 : 
; 1778 : 	dest = screens[0] + y*dupy*vid.width + x*dupx;

  00126	b8 04 00 00 00	 mov	 eax, 4
  0012b	6b c8 00	 imul	 ecx, eax, 0
  0012e	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00131	0f af 55 f0	 imul	 edx, DWORD PTR _dupy$[ebp]
  00135	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  0013c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  00142	03 c2		 add	 eax, edx
  00144	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00147	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  0014b	03 c1		 add	 eax, ecx
  0014d	89 45 d0	 mov	 DWORD PTR _dest$[ebp], eax

; 1779 : 	deststop = screens[0] + vid.width * vid.height * vid.bpp;

  00150	b8 04 00 00 00	 mov	 eax, 4
  00155	6b c8 00	 imul	 ecx, eax, 0
  00158	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  0015e	0f af 15 10 00
	00 00		 imul	 edx, DWORD PTR _vid+16
  00165	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR _vid+48
  0016c	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  00172	89 55 d8	 mov	 DWORD PTR _deststop$[ebp], edx

; 1780 : 
; 1781 : 	// from V_DrawScaledPatch
; 1782 : 	if (vid.fdupx != vid.dupx)

  00175	f3 0f 2a 05 20
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+32
  0017d	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  00185	0f 2e c8	 ucomiss xmm1, xmm0
  00188	9f		 lahf
  00189	f6 c4 44	 test	 ah, 68			; 00000044H
  0018c	7b 1c		 jnp	 SHORT $LN18@V_DrawFlat

; 1783 : 	{
; 1784 : 		// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 1785 : 		// so center this imaginary screen
; 1786 : 		dest += (vid.width - (BASEVIDWIDTH * dupx)) / 2;

  0018e	69 45 f4 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00195	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0019b	2b c8		 sub	 ecx, eax
  0019d	8b c1		 mov	 eax, ecx
  0019f	99		 cdq
  001a0	2b c2		 sub	 eax, edx
  001a2	d1 f8		 sar	 eax, 1
  001a4	03 45 d0	 add	 eax, DWORD PTR _dest$[ebp]
  001a7	89 45 d0	 mov	 DWORD PTR _dest$[ebp], eax
$LN18@V_DrawFlat:

; 1787 : 	}
; 1788 : 	if (vid.fdupy != vid.dupy)

  001aa	f3 0f 2a 05 24
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+36
  001b2	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  001ba	0f 2e c8	 ucomiss xmm1, xmm0
  001bd	9f		 lahf
  001be	f6 c4 44	 test	 ah, 68			; 00000044H
  001c1	7b 23		 jnp	 SHORT $LN19@V_DrawFlat

; 1789 : 	{
; 1790 : 		// same thing here
; 1791 : 		dest += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width / 2;

  001c3	69 45 f0 c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001ca	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001d0	2b c8		 sub	 ecx, eax
  001d2	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001d9	8b c1		 mov	 eax, ecx
  001db	99		 cdq
  001dc	2b c2		 sub	 eax, edx
  001de	d1 f8		 sar	 eax, 1
  001e0	03 45 d0	 add	 eax, DWORD PTR _dest$[ebp]
  001e3	89 45 d0	 mov	 DWORD PTR _dest$[ebp], eax
$LN19@V_DrawFlat:

; 1792 : 	}
; 1793 : 
; 1794 : 	w *= dupx;

  001e6	8b 45 10	 mov	 eax, DWORD PTR _w$[ebp]
  001e9	0f af 45 f4	 imul	 eax, DWORD PTR _dupx$[ebp]
  001ed	89 45 10	 mov	 DWORD PTR _w$[ebp], eax

; 1795 : 	h *= dupy;

  001f0	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  001f3	0f af 45 f0	 imul	 eax, DWORD PTR _dupy$[ebp]
  001f7	89 45 14	 mov	 DWORD PTR _h$[ebp], eax

; 1796 : 
; 1797 : 	dx = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  001fa	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  001fd	c1 e0 10	 shl	 eax, 16			; 00000010H
  00200	50		 push	 eax
  00201	68 00 00 01 00	 push	 65536			; 00010000H
  00206	e8 00 00 00 00	 call	 _FixedDiv
  0020b	83 c4 08	 add	 esp, 8
  0020e	89 45 ec	 mov	 DWORD PTR _dx$[ebp], eax

; 1798 : 	dy = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  00211	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  00214	c1 e0 10	 shl	 eax, 16			; 00000010H
  00217	50		 push	 eax
  00218	68 00 00 01 00	 push	 65536			; 00010000H
  0021d	e8 00 00 00 00	 call	 _FixedDiv
  00222	83 c4 08	 add	 esp, 8
  00225	89 45 e8	 mov	 DWORD PTR _dy$[ebp], eax

; 1799 : 
; 1800 : 	yfrac = 0;

  00228	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _yfrac$[ebp], 0

; 1801 : 	for (v = 0; v < h; v++, dest += vid.width)

  0022f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0
  00236	eb 15		 jmp	 SHORT $LN6@V_DrawFlat
$LN4@V_DrawFlat:
  00238	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0023b	83 c0 01	 add	 eax, 1
  0023e	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
  00241	8b 4d d0	 mov	 ecx, DWORD PTR _dest$[ebp]
  00244	03 0d 0c 00 00
	00		 add	 ecx, DWORD PTR _vid+12
  0024a	89 4d d0	 mov	 DWORD PTR _dest$[ebp], ecx
$LN6@V_DrawFlat:
  0024d	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  00250	3b 45 14	 cmp	 eax, DWORD PTR _h$[ebp]
  00253	7d 7c		 jge	 SHORT $LN5@V_DrawFlat

; 1802 : 	{
; 1803 : 		xfrac = 0;

  00255	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _xfrac$[ebp], 0

; 1804 : 		src = flat + (((yfrac >> (FRACBITS - 1)) & (lflatsize - 1)) << flatshift);

  0025c	8b 45 e0	 mov	 eax, DWORD PTR _yfrac$[ebp]
  0025f	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00262	8b 4d c8	 mov	 ecx, DWORD PTR _lflatsize$[ebp]
  00265	83 e9 01	 sub	 ecx, 1
  00268	23 c1		 and	 eax, ecx
  0026a	8b 4d c4	 mov	 ecx, DWORD PTR _flatshift$[ebp]
  0026d	d3 e0		 shl	 eax, cl
  0026f	03 45 d4	 add	 eax, DWORD PTR _flat$[ebp]
  00272	89 45 dc	 mov	 DWORD PTR _src$[ebp], eax

; 1805 : 		for (u = 0; u < w; u++)

  00275	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _u$[ebp], 0
  0027c	eb 09		 jmp	 SHORT $LN9@V_DrawFlat
$LN7@V_DrawFlat:
  0027e	8b 45 fc	 mov	 eax, DWORD PTR _u$[ebp]
  00281	83 c0 01	 add	 eax, 1
  00284	89 45 fc	 mov	 DWORD PTR _u$[ebp], eax
$LN9@V_DrawFlat:
  00287	8b 45 fc	 mov	 eax, DWORD PTR _u$[ebp]
  0028a	3b 45 10	 cmp	 eax, DWORD PTR _w$[ebp]
  0028d	7d 34		 jge	 SHORT $LN8@V_DrawFlat

; 1806 : 		{
; 1807 : 			if (&dest[u] > deststop)

  0028f	8b 45 d0	 mov	 eax, DWORD PTR _dest$[ebp]
  00292	03 45 fc	 add	 eax, DWORD PTR _u$[ebp]
  00295	3b 45 d8	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00298	76 02		 jbe	 SHORT $LN20@V_DrawFlat

; 1808 : 				return;

  0029a	eb 35		 jmp	 SHORT $LN5@V_DrawFlat
$LN20@V_DrawFlat:

; 1809 : 			dest[u] = src[(xfrac>>FRACBITS)&(lflatsize-1)];

  0029c	8b 45 e4	 mov	 eax, DWORD PTR _xfrac$[ebp]
  0029f	c1 f8 10	 sar	 eax, 16			; 00000010H
  002a2	8b 4d c8	 mov	 ecx, DWORD PTR _lflatsize$[ebp]
  002a5	83 e9 01	 sub	 ecx, 1
  002a8	23 c1		 and	 eax, ecx
  002aa	8b 55 d0	 mov	 edx, DWORD PTR _dest$[ebp]
  002ad	03 55 fc	 add	 edx, DWORD PTR _u$[ebp]
  002b0	8b 4d dc	 mov	 ecx, DWORD PTR _src$[ebp]
  002b3	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  002b6	88 02		 mov	 BYTE PTR [edx], al

; 1810 : 			xfrac += dx;

  002b8	8b 45 e4	 mov	 eax, DWORD PTR _xfrac$[ebp]
  002bb	03 45 ec	 add	 eax, DWORD PTR _dx$[ebp]
  002be	89 45 e4	 mov	 DWORD PTR _xfrac$[ebp], eax

; 1811 : 		}

  002c1	eb bb		 jmp	 SHORT $LN7@V_DrawFlat
$LN8@V_DrawFlat:

; 1812 : 		yfrac += dy;

  002c3	8b 45 e0	 mov	 eax, DWORD PTR _yfrac$[ebp]
  002c6	03 45 e8	 add	 eax, DWORD PTR _dy$[ebp]
  002c9	89 45 e0	 mov	 DWORD PTR _yfrac$[ebp], eax

; 1813 : 	}

  002cc	e9 67 ff ff ff	 jmp	 $LN4@V_DrawFlat
$LN5@V_DrawFlat:

; 1814 : }

  002d1	5f		 pop	 edi
  002d2	5e		 pop	 esi
  002d3	5b		 pop	 ebx
  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c3		 ret	 0
_V_DrawFlatFill ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawFill
_TEXT	SEGMENT
_dupy$ = -24						; size = 4
_dupx$ = -20						; size = 4
_v$ = -16						; size = 4
_u$ = -12						; size = 4
_deststop$ = -8						; size = 4
_dest$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_c$ = 24						; size = 4
_V_DrawFill PROC					; COMDAT

; 1662 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1663 : 	UINT8 *dest;
; 1664 : 	const UINT8 *deststop;
; 1665 : 	INT32 u, v, dupx, dupy;
; 1666 : 
; 1667 : #ifdef HWRENDER
; 1668 : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 2a		 je	 SHORT $LN8@V_DrawFill
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 21		 je	 SHORT $LN8@V_DrawFill

; 1669 : 	{
; 1670 : 		HWR_DrawFill(x, y, w, h, c);

  0001b	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 10	 mov	 edx, DWORD PTR _w$[ebp]
  00026	52		 push	 edx
  00027	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _HWR_DrawFill
  00034	83 c4 14	 add	 esp, 20			; 00000014H

; 1671 : 		return;

  00037	e9 ed 01 00 00	 jmp	 $LN3@V_DrawFill
$LN8@V_DrawFill:

; 1672 : 	}
; 1673 : #endif
; 1674 : 
; 1675 : 	dupx = vid.dupx;

  0003c	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00041	89 45 ec	 mov	 DWORD PTR _dupx$[ebp], eax

; 1676 : 	dupy = vid.dupy;

  00044	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00049	89 45 e8	 mov	 DWORD PTR _dupy$[ebp], eax

; 1677 : 
; 1678 : 	if (!screens[0])

  0004c	b8 04 00 00 00	 mov	 eax, 4
  00051	6b c8 00	 imul	 ecx, eax, 0
  00054	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _screens[ecx], 0
  0005b	75 05		 jne	 SHORT $LN9@V_DrawFill

; 1679 : 		return;

  0005d	e9 c7 01 00 00	 jmp	 $LN3@V_DrawFill
$LN9@V_DrawFill:

; 1680 : 
; 1681 : 	dest = screens[0] + y*dupy*vid.width + x*dupx;

  00062	b8 04 00 00 00	 mov	 eax, 4
  00067	6b c8 00	 imul	 ecx, eax, 0
  0006a	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006d	0f af 55 e8	 imul	 edx, DWORD PTR _dupy$[ebp]
  00071	0f af 15 0c 00
	00 00		 imul	 edx, DWORD PTR _vid+12
  00078	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _screens[ecx]
  0007e	03 c2		 add	 eax, edx
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00083	0f af 4d ec	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00087	03 c1		 add	 eax, ecx
  00089	89 45 fc	 mov	 DWORD PTR _dest$[ebp], eax

; 1682 : 	deststop = screens[0] + vid.width * vid.height * vid.bpp;

  0008c	b8 04 00 00 00	 mov	 eax, 4
  00091	6b c8 00	 imul	 ecx, eax, 0
  00094	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _vid+12
  0009a	0f af 15 10 00
	00 00		 imul	 edx, DWORD PTR _vid+16
  000a1	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR _vid+48
  000a8	03 91 00 00 00
	00		 add	 edx, DWORD PTR _screens[ecx]
  000ae	89 55 f8	 mov	 DWORD PTR _deststop$[ebp], edx

; 1683 : 
; 1684 : 	w *= dupx;

  000b1	8b 45 10	 mov	 eax, DWORD PTR _w$[ebp]
  000b4	0f af 45 ec	 imul	 eax, DWORD PTR _dupx$[ebp]
  000b8	89 45 10	 mov	 DWORD PTR _w$[ebp], eax

; 1685 : 	h *= dupy;

  000bb	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  000be	0f af 45 e8	 imul	 eax, DWORD PTR _dupy$[ebp]
  000c2	89 45 14	 mov	 DWORD PTR _h$[ebp], eax

; 1686 : 
; 1687 : 	if (x && y && x + w < vid.width && y + h < vid.height)

  000c5	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  000c9	0f 84 f6 00 00
	00		 je	 $LN18@V_DrawFill
  000cf	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  000d3	0f 84 ec 00 00
	00		 je	 $LN18@V_DrawFill
  000d9	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000dc	03 45 10	 add	 eax, DWORD PTR _w$[ebp]
  000df	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _vid+12
  000e5	0f 8d da 00 00
	00		 jge	 $LN18@V_DrawFill
  000eb	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000ee	03 45 14	 add	 eax, DWORD PTR _h$[ebp]
  000f1	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  000f7	0f 8d c8 00 00
	00		 jge	 $LN18@V_DrawFill

; 1688 : 	{
; 1689 : 		// Center it if necessary
; 1690 : 		if (vid.fdupx != dupx)

  000fd	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _dupx$[ebp]
  00102	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  0010a	0f 2e c8	 ucomiss xmm1, xmm0
  0010d	9f		 lahf
  0010e	f6 c4 44	 test	 ah, 68			; 00000044H
  00111	7b 47		 jnp	 SHORT $LN14@V_DrawFill

; 1691 : 		{
; 1692 : 			// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 1693 : 			// so center this imaginary screen
; 1694 : 			if (c & V_SNAPTORIGHT)

  00113	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  00116	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0011b	74 17		 je	 SHORT $LN12@V_DrawFill

; 1695 : 				dest += (vid.width - (BASEVIDWIDTH * dupx));

  0011d	69 45 ec 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00124	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0012a	2b c8		 sub	 ecx, eax
  0012c	03 4d fc	 add	 ecx, DWORD PTR _dest$[ebp]
  0012f	89 4d fc	 mov	 DWORD PTR _dest$[ebp], ecx
  00132	eb 26		 jmp	 SHORT $LN14@V_DrawFill
$LN12@V_DrawFill:

; 1696 : 			else if (!(c & V_SNAPTOLEFT))

  00134	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  00137	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0013c	75 1c		 jne	 SHORT $LN14@V_DrawFill

; 1697 : 				dest += (vid.width - (BASEVIDWIDTH * dupx)) / 2;

  0013e	69 45 ec 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00145	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0014b	2b c8		 sub	 ecx, eax
  0014d	8b c1		 mov	 eax, ecx
  0014f	99		 cdq
  00150	2b c2		 sub	 eax, edx
  00152	d1 f8		 sar	 eax, 1
  00154	03 45 fc	 add	 eax, DWORD PTR _dest$[ebp]
  00157	89 45 fc	 mov	 DWORD PTR _dest$[ebp], eax
$LN14@V_DrawFill:

; 1698 : 		}
; 1699 : 		if (vid.fdupy != dupy)

  0015a	f3 0f 2a 45 e8	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  0015f	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  00167	0f 2e c8	 ucomiss xmm1, xmm0
  0016a	9f		 lahf
  0016b	f6 c4 44	 test	 ah, 68			; 00000044H
  0016e	7b 55		 jnp	 SHORT $LN18@V_DrawFill

; 1700 : 		{
; 1701 : 			// same thing here
; 1702 : 			if (c & V_SNAPTOBOTTOM)

  00170	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  00173	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00178	74 1e		 je	 SHORT $LN16@V_DrawFill

; 1703 : 				dest += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width;

  0017a	69 45 e8 c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  00181	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00187	2b c8		 sub	 ecx, eax
  00189	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00190	03 4d fc	 add	 ecx, DWORD PTR _dest$[ebp]
  00193	89 4d fc	 mov	 DWORD PTR _dest$[ebp], ecx
  00196	eb 2d		 jmp	 SHORT $LN18@V_DrawFill
$LN16@V_DrawFill:

; 1704 : 			else if (!(c & V_SNAPTOTOP))

  00198	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  0019b	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  001a0	75 23		 jne	 SHORT $LN18@V_DrawFill

; 1705 : 				dest += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width / 2;

  001a2	69 45 e8 c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001a9	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001af	2b c8		 sub	 ecx, eax
  001b1	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001b8	8b c1		 mov	 eax, ecx
  001ba	99		 cdq
  001bb	2b c2		 sub	 eax, edx
  001bd	d1 f8		 sar	 eax, 1
  001bf	03 45 fc	 add	 eax, DWORD PTR _dest$[ebp]
  001c2	89 45 fc	 mov	 DWORD PTR _dest$[ebp], eax
$LN18@V_DrawFill:

; 1706 : 		}
; 1707 : 	}
; 1708 : 
; 1709 : 	c &= 255;

  001c5	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  001c8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001cd	89 45 18	 mov	 DWORD PTR _c$[ebp], eax

; 1710 : 
; 1711 : 	for (v = 0; v < h; v++, dest += vid.width)

  001d0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0
  001d7	eb 15		 jmp	 SHORT $LN4@V_DrawFill
$LN2@V_DrawFill:
  001d9	8b 45 f0	 mov	 eax, DWORD PTR _v$[ebp]
  001dc	83 c0 01	 add	 eax, 1
  001df	89 45 f0	 mov	 DWORD PTR _v$[ebp], eax
  001e2	8b 4d fc	 mov	 ecx, DWORD PTR _dest$[ebp]
  001e5	03 0d 0c 00 00
	00		 add	 ecx, DWORD PTR _vid+12
  001eb	89 4d fc	 mov	 DWORD PTR _dest$[ebp], ecx
$LN4@V_DrawFill:
  001ee	8b 45 f0	 mov	 eax, DWORD PTR _v$[ebp]
  001f1	3b 45 14	 cmp	 eax, DWORD PTR _h$[ebp]
  001f4	7d 33		 jge	 SHORT $LN3@V_DrawFill

; 1712 : 		for (u = 0; u < w; u++)

  001f6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _u$[ebp], 0
  001fd	eb 09		 jmp	 SHORT $LN7@V_DrawFill
$LN5@V_DrawFill:
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _u$[ebp]
  00202	83 c0 01	 add	 eax, 1
  00205	89 45 f4	 mov	 DWORD PTR _u$[ebp], eax
$LN7@V_DrawFill:
  00208	8b 45 f4	 mov	 eax, DWORD PTR _u$[ebp]
  0020b	3b 45 10	 cmp	 eax, DWORD PTR _w$[ebp]
  0020e	7d 17		 jge	 SHORT $LN6@V_DrawFill

; 1713 : 		{
; 1714 : 			if (dest > deststop)

  00210	8b 45 fc	 mov	 eax, DWORD PTR _dest$[ebp]
  00213	3b 45 f8	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00216	76 02		 jbe	 SHORT $LN19@V_DrawFill

; 1715 : 				return;

  00218	eb 0f		 jmp	 SHORT $LN3@V_DrawFill
$LN19@V_DrawFill:

; 1716 : 			dest[u] = (UINT8)c;

  0021a	8b 45 fc	 mov	 eax, DWORD PTR _dest$[ebp]
  0021d	03 45 f4	 add	 eax, DWORD PTR _u$[ebp]
  00220	8a 4d 18	 mov	 cl, BYTE PTR _c$[ebp]
  00223	88 08		 mov	 BYTE PTR [eax], cl

; 1717 : 		}

  00225	eb d8		 jmp	 SHORT $LN5@V_DrawFill
$LN6@V_DrawFill:
  00227	eb b0		 jmp	 SHORT $LN2@V_DrawFill
$LN3@V_DrawFill:

; 1718 : }

  00229	5f		 pop	 edi
  0022a	5e		 pop	 esi
  0022b	5b		 pop	 ebx
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
_V_DrawFill ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawScaledPic
_TEXT	SEGMENT
_rx1$ = 8						; size = 4
_ry1$ = 12						; size = 4
_scrn$ = 16						; size = 4
_lumpnum$ = 20						; size = 4
_V_DrawScaledPic PROC					; COMDAT

; 1607 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1608 : #ifdef HWRENDER
; 1609 : 	if (rendermode != render_soft)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 16		 je	 SHORT $LN2@V_DrawScal

; 1610 : 	{
; 1611 : 		HWR_DrawPic(rx1, ry1, lumpnum);

  00012	8b 45 14	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _ry1$[ebp]
  00019	51		 push	 ecx
  0001a	8b 55 08	 mov	 edx, DWORD PTR _rx1$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _HWR_DrawPic
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1612 : 		return;

  00026	eb 23		 jmp	 SHORT $LN1@V_DrawScal
$LN2@V_DrawScal:

; 1613 : 	}
; 1614 : #endif
; 1615 : 
; 1616 : 	V_BlitScaledPic(rx1, ry1, scrn, W_CacheLumpNum(lumpnum, PU_CACHE));

  00028	6a 65		 push	 101			; 00000065H
  0002a	8b 45 14	 mov	 eax, DWORD PTR _lumpnum$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00033	83 c4 08	 add	 esp, 8
  00036	50		 push	 eax
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  0003a	51		 push	 ecx
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _ry1$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _rx1$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _V_BlitScaledPic
  00048	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@V_DrawScal:

; 1617 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_V_DrawScaledPic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawBlock
_TEXT	SEGMENT
tv76 = -76						; size = 4
_deststop$ = -8						; size = 4
_dest$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_src$ = 28						; size = 4
_V_DrawBlock PROC					; COMDAT

; 1580 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1581 : 	UINT8 *dest;
; 1582 : 	const UINT8 *deststop;
; 1583 : 
; 1584 : #ifdef RANGECHECK
; 1585 : 	if (x < 0 || x + width > vid.width || y < 0 || y + height > vid.height || (unsigned)scrn > 4)
; 1586 : 		I_Error("Bad V_DrawBlock");
; 1587 : #endif
; 1588 : 
; 1589 : 	dest = screens[scrn] + y*vid.width + x;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000c	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  00016	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _screens[ecx*4]
  0001d	03 d0		 add	 edx, eax
  0001f	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  00022	89 55 fc	 mov	 DWORD PTR _dest$[ebp], edx

; 1590 : 	deststop = screens[scrn] + vid.width * vid.height * vid.bpp;

  00025	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  0002a	0f af 05 10 00
	00 00		 imul	 eax, DWORD PTR _vid+16
  00031	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  0003b	03 04 8d 00 00
	00 00		 add	 eax, DWORD PTR _screens[ecx*4]
  00042	89 45 f8	 mov	 DWORD PTR _deststop$[ebp], eax
$LN2@V_DrawBloc:

; 1591 : 
; 1592 : 	while (height--)

  00045	8b 45 18	 mov	 eax, DWORD PTR _height$[ebp]
  00048	89 45 b4	 mov	 DWORD PTR tv76[ebp], eax
  0004b	8b 4d 18	 mov	 ecx, DWORD PTR _height$[ebp]
  0004e	83 e9 01	 sub	 ecx, 1
  00051	89 4d 18	 mov	 DWORD PTR _height$[ebp], ecx
  00054	83 7d b4 00	 cmp	 DWORD PTR tv76[ebp], 0
  00058	74 36		 je	 SHORT $LN3@V_DrawBloc

; 1593 : 	{
; 1594 : 		M_Memcpy(dest, src, width);

  0005a	8b 45 14	 mov	 eax, DWORD PTR _width$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 1c	 mov	 ecx, DWORD PTR _src$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _dest$[ebp]
  00065	52		 push	 edx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1595 : 
; 1596 : 		src += width;

  0006f	8b 45 1c	 mov	 eax, DWORD PTR _src$[ebp]
  00072	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00075	89 45 1c	 mov	 DWORD PTR _src$[ebp], eax

; 1597 : 		dest += vid.width;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _dest$[ebp]
  0007b	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00081	89 45 fc	 mov	 DWORD PTR _dest$[ebp], eax

; 1598 : 		if (dest > deststop)

  00084	8b 45 fc	 mov	 eax, DWORD PTR _dest$[ebp]
  00087	3b 45 f8	 cmp	 eax, DWORD PTR _deststop$[ebp]
  0008a	76 02		 jbe	 SHORT $LN4@V_DrawBloc

; 1599 : 			return;

  0008c	eb 02		 jmp	 SHORT $LN3@V_DrawBloc
$LN4@V_DrawBloc:

; 1600 : 	}

  0008e	eb b5		 jmp	 SHORT $LN2@V_DrawBloc
$LN3@V_DrawBloc:

; 1601 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_V_DrawBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawPatch
_TEXT	SEGMENT
tv141 = -100						; size = 4
_deststop$ = -32					; size = 4
_source$ = -28						; size = 4
_dest$ = -24						; size = 4
_desttop$ = -20						; size = 4
_column$ = -16						; size = 4
_w$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_V_DrawPatch PROC					; COMDAT

; 1518 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1519 : 	size_t count;
; 1520 : 	INT32 col, w;
; 1521 : 	const column_t *column;
; 1522 : 	UINT8 *desttop, *dest;
; 1523 : 	const UINT8 *source, *deststop;
; 1524 : 
; 1525 : #ifdef HWRENDER
; 1526 : 	// draw a hardware converted patch
; 1527 : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 27		 je	 SHORT $LN9@V_DrawPatc
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 1e		 je	 SHORT $LN9@V_DrawPatc

; 1528 : 	{
; 1529 : 		HWR_DrawPatch((GLPatch_t *)patch, x, y, V_NOSCALESTART|V_NOSCALEPATCH);

  0001b	68 00 00 09 00	 push	 589824			; 00090000H
  00020	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _HWR_DrawPatch
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 1530 : 		return;

  00034	e9 43 01 00 00	 jmp	 $LN3@V_DrawPatc
$LN9@V_DrawPatc:

; 1531 : 	}
; 1532 : #endif
; 1533 : 
; 1534 : 	y -= SHORT(patch->topoffset);

  00039	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0003c	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00040	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00043	2b d1		 sub	 edx, ecx
  00045	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 1535 : 	x -= SHORT(patch->leftoffset);

  00048	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0004b	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0004f	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00052	2b d1		 sub	 edx, ecx
  00054	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 1536 : #ifdef RANGECHECK
; 1537 : 	if (x < 0 || x + SHORT(patch->width) > vid.width || y < 0
; 1538 : 		|| y + SHORT(patch->height) > vid.height || (unsigned)scrn > 4)
; 1539 : 	{
; 1540 : 		fprintf(stderr, "Patch at %d, %d exceeds LFB\n", x, y);
; 1541 : 		// No I_Error abort - what is up with TNT.WAD?
; 1542 : 		fprintf(stderr, "V_DrawPatch: bad patch (ignored)\n");
; 1543 : 		return;
; 1544 : 	}
; 1545 : #endif
; 1546 : 
; 1547 : 	desttop = screens[scrn] + y*vid.width + x;

  00057	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0005a	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00061	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  00064	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _screens[ecx*4]
  0006b	03 d0		 add	 edx, eax
  0006d	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  00070	89 55 ec	 mov	 DWORD PTR _desttop$[ebp], edx

; 1548 : 	deststop = screens[scrn&0xffff] + vid.width * vid.height * vid.bpp;

  00073	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00076	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007b	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00081	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  00088	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  0008f	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  00096	89 4d e0	 mov	 DWORD PTR _deststop$[ebp], ecx

; 1549 : 	w = SHORT(patch->width);

  00099	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0009c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0009f	89 4d f4	 mov	 DWORD PTR _w$[ebp], ecx

; 1550 : 
; 1551 : 	for (col = 0; col < w; x++, col++, desttop++)

  000a2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  000a9	eb 1b		 jmp	 SHORT $LN4@V_DrawPatc
$LN2@V_DrawPatc:
  000ab	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 08	 mov	 DWORD PTR _x$[ebp], eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _col$[ebp]
  000b7	83 c1 01	 add	 ecx, 1
  000ba	89 4d f8	 mov	 DWORD PTR _col$[ebp], ecx
  000bd	8b 55 ec	 mov	 edx, DWORD PTR _desttop$[ebp]
  000c0	83 c2 01	 add	 edx, 1
  000c3	89 55 ec	 mov	 DWORD PTR _desttop$[ebp], edx
$LN4@V_DrawPatc:
  000c6	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  000c9	3b 45 f4	 cmp	 eax, DWORD PTR _w$[ebp]
  000cc	0f 8d aa 00 00
	00		 jge	 $LN3@V_DrawPatc

; 1552 : 	{
; 1553 : 		column = (const column_t *)((const UINT8 *)patch + LONG(patch->columnofs[col]));

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  000d5	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  000d8	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  000db	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  000df	89 55 f0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawPatc:

; 1554 : 
; 1555 : 		// step through the posts in a column
; 1556 : 		while (column->topdelta != 0xff)

  000e2	8b 45 f0	 mov	 eax, DWORD PTR _column$[ebp]
  000e5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000ee	0f 84 83 00 00
	00		 je	 $LN6@V_DrawPatc

; 1557 : 		{
; 1558 : 			source = (const UINT8 *)column + 3;

  000f4	8b 45 f0	 mov	 eax, DWORD PTR _column$[ebp]
  000f7	83 c0 03	 add	 eax, 3
  000fa	89 45 e4	 mov	 DWORD PTR _source$[ebp], eax

; 1559 : 			dest = desttop + column->topdelta*vid.width;

  000fd	8b 45 f0	 mov	 eax, DWORD PTR _column$[ebp]
  00100	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00103	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0010a	03 4d ec	 add	 ecx, DWORD PTR _desttop$[ebp]
  0010d	89 4d e8	 mov	 DWORD PTR _dest$[ebp], ecx

; 1560 : 			count = column->length;

  00110	8b 45 f0	 mov	 eax, DWORD PTR _column$[ebp]
  00113	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00117	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
$LN7@V_DrawPatc:

; 1561 : 
; 1562 : 			while (count--)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0011d	89 45 9c	 mov	 DWORD PTR tv141[ebp], eax
  00120	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00123	83 e9 01	 sub	 ecx, 1
  00126	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00129	83 7d 9c 00	 cmp	 DWORD PTR tv141[ebp], 0
  0012d	74 32		 je	 SHORT $LN8@V_DrawPatc

; 1563 : 			{
; 1564 : 				if (dest < deststop)

  0012f	8b 45 e8	 mov	 eax, DWORD PTR _dest$[ebp]
  00132	3b 45 e0	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00135	73 15		 jae	 SHORT $LN10@V_DrawPatc

; 1565 : 					*dest = *source++;

  00137	8b 45 e8	 mov	 eax, DWORD PTR _dest$[ebp]
  0013a	8b 4d e4	 mov	 ecx, DWORD PTR _source$[ebp]
  0013d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0013f	88 10		 mov	 BYTE PTR [eax], dl
  00141	8b 45 e4	 mov	 eax, DWORD PTR _source$[ebp]
  00144	83 c0 01	 add	 eax, 1
  00147	89 45 e4	 mov	 DWORD PTR _source$[ebp], eax
  0014a	eb 07		 jmp	 SHORT $LN11@V_DrawPatc
$LN10@V_DrawPatc:

; 1566 : 				else
; 1567 : 					count = 0;

  0014c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN11@V_DrawPatc:

; 1568 : 				dest += vid.width;

  00153	8b 45 e8	 mov	 eax, DWORD PTR _dest$[ebp]
  00156	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0015c	89 45 e8	 mov	 DWORD PTR _dest$[ebp], eax

; 1569 : 			}

  0015f	eb b9		 jmp	 SHORT $LN7@V_DrawPatc
$LN8@V_DrawPatc:

; 1570 : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  00161	8b 45 f0	 mov	 eax, DWORD PTR _column$[ebp]
  00164	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00168	8b 55 f0	 mov	 edx, DWORD PTR _column$[ebp]
  0016b	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0016f	89 45 f0	 mov	 DWORD PTR _column$[ebp], eax

; 1571 : 		}

  00172	e9 6b ff ff ff	 jmp	 $LN5@V_DrawPatc
$LN6@V_DrawPatc:

; 1572 : 	}

  00177	e9 2f ff ff ff	 jmp	 $LN2@V_DrawPatc
$LN3@V_DrawPatc:

; 1573 : }

  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
_V_DrawPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawTranslucentPatch
_TEXT	SEGMENT
tv220 = -124						; size = 4
_deststop$ = -56					; size = 4
_translevel$ = -52					; size = 4
_source$ = -48						; size = 4
_dest$ = -44						; size = 4
_desttop$ = -40						; size = 4
_column$ = -36						; size = 4
_rowfrac$ = -32						; size = 4
_colfrac$ = -28						; size = 4
_ofs$ = -24						; size = 4
_dupy$ = -20						; size = 4
_dupx$ = -16						; size = 4
_w$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_V_DrawTranslucentPatch PROC				; COMDAT

; 1404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1405 : 	size_t count;
; 1406 : 	INT32 col, w, dupx, dupy, ofs, colfrac, rowfrac;
; 1407 : 	const column_t *column;
; 1408 : 	UINT8 *desttop, *dest;
; 1409 : 	const UINT8 *source, *translevel, *deststop;
; 1410 : 
; 1411 : #ifdef HWRENDER
; 1412 : 	// draw a hardware converted patch
; 1413 : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 26		 je	 SHORT $LN9@V_DrawTran
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 1d		 je	 SHORT $LN9@V_DrawTran

; 1414 : 	{
; 1415 : 		HWR_DrawTranslucentPatch((GLPatch_t *)patch, x, y, scrn);

  0001b	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00026	52		 push	 edx
  00027	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _HWR_DrawTranslucentPatch
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 1416 : 		return;

  00033	e9 7b 03 00 00	 jmp	 $LN3@V_DrawTran
$LN9@V_DrawTran:

; 1417 : 	}
; 1418 : #endif
; 1419 : 
; 1420 : 	if (scrn & V_8020TRANS)

  00038	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0003b	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00040	74 0f		 je	 SHORT $LN10@V_DrawTran

; 1421 : 		translevel = ((tr_trans80)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00047	05 00 00 07 00	 add	 eax, 458752		; 00070000H
  0004c	89 45 cc	 mov	 DWORD PTR _translevel$[ebp], eax
  0004f	eb 0d		 jmp	 SHORT $LN11@V_DrawTran
$LN10@V_DrawTran:

; 1422 : 	else
; 1423 : 		translevel = ((tr_trans50)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00056	05 00 00 04 00	 add	 eax, 262144		; 00040000H
  0005b	89 45 cc	 mov	 DWORD PTR _translevel$[ebp], eax
$LN11@V_DrawTran:

; 1424 : 
; 1425 : 	if ((scrn & V_NOSCALEPATCH))

  0005e	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00061	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00066	74 0f		 je	 SHORT $LN12@V_DrawTran

; 1426 : 		dupx = dupy = 1;

  00068	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  0006f	8b 45 ec	 mov	 eax, DWORD PTR _dupy$[ebp]
  00072	89 45 f0	 mov	 DWORD PTR _dupx$[ebp], eax
  00075	eb 10		 jmp	 SHORT $LN13@V_DrawTran
$LN12@V_DrawTran:

; 1427 : 	else
; 1428 : 	{
; 1429 : 		dupx = vid.dupx;

  00077	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  0007c	89 45 f0	 mov	 DWORD PTR _dupx$[ebp], eax

; 1430 : 		dupy = vid.dupy;

  0007f	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00084	89 45 ec	 mov	 DWORD PTR _dupy$[ebp], eax
$LN13@V_DrawTran:

; 1431 : 	}
; 1432 : 
; 1433 : 	if (scrn & V_TOPLEFT)

  00087	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0008a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0008f	74 20		 je	 SHORT $LN14@V_DrawTran

; 1434 : 	{
; 1435 : 		y -= SHORT(patch->topoffset);

  00091	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00094	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00098	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0009b	2b d1		 sub	 edx, ecx
  0009d	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 1436 : 		x -= SHORT(patch->leftoffset);

  000a0	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000a3	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000a7	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000aa	2b d1		 sub	 edx, ecx
  000ac	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 1437 : 	}

  000af	eb 26		 jmp	 SHORT $LN15@V_DrawTran
$LN14@V_DrawTran:

; 1438 : 	else
; 1439 : 	{
; 1440 : 		y -= SHORT(patch->topoffset)*dupy;

  000b1	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000b4	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000b8	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  000bc	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000bf	2b d1		 sub	 edx, ecx
  000c1	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 1441 : 		x -= SHORT(patch->leftoffset)*dupx;

  000c4	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000c7	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000cb	0f af 4d f0	 imul	 ecx, DWORD PTR _dupx$[ebp]
  000cf	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000d2	2b d1		 sub	 edx, ecx
  000d4	89 55 08	 mov	 DWORD PTR _x$[ebp], edx
$LN15@V_DrawTran:

; 1442 : 	}
; 1443 : 
; 1444 : 	colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  000d7	8b 45 f0	 mov	 eax, DWORD PTR _dupx$[ebp]
  000da	c1 e0 10	 shl	 eax, 16			; 00000010H
  000dd	50		 push	 eax
  000de	68 00 00 01 00	 push	 65536			; 00010000H
  000e3	e8 00 00 00 00	 call	 _FixedDiv
  000e8	83 c4 08	 add	 esp, 8
  000eb	89 45 e4	 mov	 DWORD PTR _colfrac$[ebp], eax

; 1445 : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  000ee	8b 45 ec	 mov	 eax, DWORD PTR _dupy$[ebp]
  000f1	c1 e0 10	 shl	 eax, 16			; 00000010H
  000f4	50		 push	 eax
  000f5	68 00 00 01 00	 push	 65536			; 00010000H
  000fa	e8 00 00 00 00	 call	 _FixedDiv
  000ff	83 c4 08	 add	 esp, 8
  00102	89 45 e0	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 1446 : 
; 1447 : 	desttop = screens[scrn&0xffff];

  00105	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00108	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0010d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _screens[eax*4]
  00114	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx

; 1448 : 	deststop = screens[scrn&0xffff] + vid.width * vid.height * vid.bpp;

  00117	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0011a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0011f	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00125	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  0012c	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  00133	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  0013a	89 4d c8	 mov	 DWORD PTR _deststop$[ebp], ecx

; 1449 : 
; 1450 : 	if (!desttop)

  0013d	83 7d d8 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  00141	75 05		 jne	 SHORT $LN16@V_DrawTran

; 1451 : 		return;

  00143	e9 6b 02 00 00	 jmp	 $LN3@V_DrawTran
$LN16@V_DrawTran:

; 1452 : 
; 1453 : 	if (scrn & V_NOSCALESTART)

  00148	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0014b	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00150	74 18		 je	 SHORT $LN17@V_DrawTran

; 1454 : 		desttop += (y*vid.width) + x;

  00152	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00155	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  0015c	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  0015f	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  00162	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
  00165	e9 37 01 00 00	 jmp	 $LN28@V_DrawTran
$LN17@V_DrawTran:

; 1455 : 	else
; 1456 : 	{
; 1457 : 		desttop += (y*dupy*vid.width) + (x*dupx);

  0016a	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0016d	0f af 45 ec	 imul	 eax, DWORD PTR _dupy$[ebp]
  00171	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00178	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0017b	0f af 4d f0	 imul	 ecx, DWORD PTR _dupx$[ebp]
  0017f	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  00182	03 c8		 add	 ecx, eax
  00184	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx

; 1458 : 
; 1459 : 		// Center it if necessary
; 1460 : 		if (!(scrn & V_NOSCALEPATCH))

  00187	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0018a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0018f	0f 85 0c 01 00
	00		 jne	 $LN28@V_DrawTran

; 1461 : 		{
; 1462 : 			if (vid.fdupx != dupx)

  00195	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupx$[ebp]
  0019a	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  001a2	0f 2e c8	 ucomiss xmm1, xmm0
  001a5	9f		 lahf
  001a6	f6 c4 44	 test	 ah, 68			; 00000044H
  001a9	7b 47		 jnp	 SHORT $LN23@V_DrawTran

; 1463 : 			{
; 1464 : 				// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 1465 : 				// so center this imaginary screen
; 1466 : 				if (scrn & V_SNAPTORIGHT)

  001ab	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001ae	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001b3	74 17		 je	 SHORT $LN21@V_DrawTran

; 1467 : 					desttop += (vid.width - (BASEVIDWIDTH * dupx));

  001b5	69 45 f0 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  001bc	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  001c2	2b c8		 sub	 ecx, eax
  001c4	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  001c7	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
  001ca	eb 26		 jmp	 SHORT $LN23@V_DrawTran
$LN21@V_DrawTran:

; 1468 : 				else if (!(scrn & V_SNAPTOLEFT))

  001cc	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001cf	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  001d4	75 1c		 jne	 SHORT $LN23@V_DrawTran

; 1469 : 					desttop += (vid.width - (BASEVIDWIDTH * dupx)) / 2;

  001d6	69 45 f0 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  001dd	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  001e3	2b c8		 sub	 ecx, eax
  001e5	8b c1		 mov	 eax, ecx
  001e7	99		 cdq
  001e8	2b c2		 sub	 eax, edx
  001ea	d1 f8		 sar	 eax, 1
  001ec	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  001ef	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
$LN23@V_DrawTran:

; 1470 : 			}
; 1471 : 			if (vid.fdupy != dupy)

  001f2	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  001f7	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  001ff	0f 2e c8	 ucomiss xmm1, xmm0
  00202	9f		 lahf
  00203	f6 c4 44	 test	 ah, 68			; 00000044H
  00206	7b 55		 jnp	 SHORT $LN27@V_DrawTran

; 1472 : 			{
; 1473 : 				// same thing here
; 1474 : 				if (scrn & V_SNAPTOBOTTOM)

  00208	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0020b	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00210	74 1e		 je	 SHORT $LN25@V_DrawTran

; 1475 : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width;

  00212	69 45 ec c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  00219	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  0021f	2b c8		 sub	 ecx, eax
  00221	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00228	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  0022b	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
  0022e	eb 2d		 jmp	 SHORT $LN27@V_DrawTran
$LN25@V_DrawTran:

; 1476 : 				else if (!(scrn & V_SNAPTOTOP))

  00230	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00233	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00238	75 23		 jne	 SHORT $LN27@V_DrawTran

; 1477 : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width / 2;

  0023a	69 45 ec c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  00241	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00247	2b c8		 sub	 ecx, eax
  00249	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00250	8b c1		 mov	 eax, ecx
  00252	99		 cdq
  00253	2b c2		 sub	 eax, edx
  00255	d1 f8		 sar	 eax, 1
  00257	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  0025a	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
$LN27@V_DrawTran:

; 1478 : 			}
; 1479 : 			// if it's meant to cover the whole screen, black out the rest
; 1480 : 			if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT)

  0025d	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00261	75 3e		 jne	 SHORT $LN28@V_DrawTran
  00263	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00266	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00269	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  0026f	75 30		 jne	 SHORT $LN28@V_DrawTran
  00271	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  00275	75 2a		 jne	 SHORT $LN28@V_DrawTran
  00277	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0027a	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0027e	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  00284	75 1b		 jne	 SHORT $LN28@V_DrawTran

; 1481 : 				V_DrawFill(0, 0, vid.width, vid.height, 31);

  00286	6a 1f		 push	 31			; 0000001fH
  00288	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  0028d	50		 push	 eax
  0028e	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00294	51		 push	 ecx
  00295	6a 00		 push	 0
  00297	6a 00		 push	 0
  00299	e8 00 00 00 00	 call	 _V_DrawFill
  0029e	83 c4 14	 add	 esp, 20			; 00000014H
$LN28@V_DrawTran:

; 1482 : 		}
; 1483 : 	}
; 1484 : 
; 1485 : 	w = SHORT(patch->width)<<FRACBITS;

  002a1	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002a4	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002a7	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002aa	89 4d f4	 mov	 DWORD PTR _w$[ebp], ecx

; 1486 : 
; 1487 : 	for (col = 0; col < w; col += colfrac, desttop++)

  002ad	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  002b4	eb 12		 jmp	 SHORT $LN4@V_DrawTran
$LN2@V_DrawTran:
  002b6	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002b9	03 45 e4	 add	 eax, DWORD PTR _colfrac$[ebp]
  002bc	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  002bf	8b 4d d8	 mov	 ecx, DWORD PTR _desttop$[ebp]
  002c2	83 c1 01	 add	 ecx, 1
  002c5	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawTran:
  002c8	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002cb	3b 45 f4	 cmp	 eax, DWORD PTR _w$[ebp]
  002ce	0f 8d df 00 00
	00		 jge	 $LN3@V_DrawTran

; 1488 : 	{
; 1489 : 		column = (const column_t *)((const UINT8 *)patch + LONG(patch->columnofs[col>>FRACBITS]));

  002d4	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002d7	c1 f8 10	 sar	 eax, 16			; 00000010H
  002da	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  002dd	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  002e0	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  002e4	89 55 dc	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawTran:

; 1490 : 
; 1491 : 		while (column->topdelta != 0xff)

  002e7	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002ea	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002ed	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002f3	0f 84 b5 00 00
	00		 je	 $LN6@V_DrawTran

; 1492 : 		{
; 1493 : 			source = (const UINT8 *)column + 3;

  002f9	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002fc	83 c0 03	 add	 eax, 3
  002ff	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 1494 : 			dest = desttop + column->topdelta*dupy*vid.width;

  00302	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  00305	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00308	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  0030c	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00313	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  00316	89 4d d4	 mov	 DWORD PTR _dest$[ebp], ecx

; 1495 : 			count = column->length*dupy;

  00319	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  0031c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00320	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  00324	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 1496 : 
; 1497 : 			ofs = 0;

  00327	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0
$LN7@V_DrawTran:

; 1498 : 			while (count--)

  0032e	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00331	89 45 84	 mov	 DWORD PTR tv220[ebp], eax
  00334	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00337	83 e9 01	 sub	 ecx, 1
  0033a	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  0033d	83 7d 84 00	 cmp	 DWORD PTR tv220[ebp], 0
  00341	74 55		 je	 SHORT $LN8@V_DrawTran

; 1499 : 			{
; 1500 : 				if (dest < deststop)

  00343	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00346	3b 45 c8	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00349	73 2f		 jae	 SHORT $LN29@V_DrawTran

; 1501 : 					*dest = *(translevel + ((source[ofs>>FRACBITS]<<8)&0xff00) + (*dest&0xff));

  0034b	8b 45 e8	 mov	 eax, DWORD PTR _ofs$[ebp]
  0034e	c1 f8 10	 sar	 eax, 16			; 00000010H
  00351	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  00354	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00358	c1 e2 08	 shl	 edx, 8
  0035b	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00361	03 55 cc	 add	 edx, DWORD PTR _translevel$[ebp]
  00364	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00367	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0036a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00370	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00373	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00376	88 08		 mov	 BYTE PTR [eax], cl
  00378	eb 07		 jmp	 SHORT $LN30@V_DrawTran
$LN29@V_DrawTran:

; 1502 : 				else
; 1503 : 					count = 0;

  0037a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN30@V_DrawTran:

; 1504 : 				dest += vid.width;

  00381	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00384	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0038a	89 45 d4	 mov	 DWORD PTR _dest$[ebp], eax

; 1505 : 				ofs += rowfrac;

  0038d	8b 45 e8	 mov	 eax, DWORD PTR _ofs$[ebp]
  00390	03 45 e0	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00393	89 45 e8	 mov	 DWORD PTR _ofs$[ebp], eax

; 1506 : 			}

  00396	eb 96		 jmp	 SHORT $LN7@V_DrawTran
$LN8@V_DrawTran:

; 1507 : 
; 1508 : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  00398	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  0039b	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0039f	8b 55 dc	 mov	 edx, DWORD PTR _column$[ebp]
  003a2	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  003a6	89 45 dc	 mov	 DWORD PTR _column$[ebp], eax

; 1509 : 		}

  003a9	e9 39 ff ff ff	 jmp	 $LN5@V_DrawTran
$LN6@V_DrawTran:

; 1510 : 	}

  003ae	e9 03 ff ff ff	 jmp	 $LN2@V_DrawTran
$LN3@V_DrawTran:

; 1511 : }

  003b3	5f		 pop	 edi
  003b4	5e		 pop	 esi
  003b5	5b		 pop	 ebx
  003b6	8b e5		 mov	 esp, ebp
  003b8	5d		 pop	 ebp
  003b9	c3		 ret	 0
_V_DrawTranslucentPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawSmallTranslucentPatch
_TEXT	SEGMENT
tv272 = -136						; size = 4
tv275 = -136						; size = 4
_heightmask$1 = -68					; size = 4
_skiprowcnt$ = -64					; size = 4
_skippixels$ = -60					; size = 4
_translevel$ = -56					; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_destend$ = -44						; size = 4
_dest$ = -40						; size = 4
_desttop$ = -36						; size = 4
_column$ = -32						; size = 4
_rowfrac$ = -28						; size = 4
_colfrac$ = -24						; size = 4
_ofs$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_V_DrawSmallTranslucentPatch PROC			; COMDAT

; 1080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1081 : 	size_t count;
; 1082 : 	INT32 col, dupx, dupy, ofs, colfrac, rowfrac;
; 1083 : 	const column_t *column;
; 1084 : 	UINT8 *desttop, *dest, *destend;
; 1085 : 	const UINT8 *source, *deststop;
; 1086 : 	UINT8 *translevel;
; 1087 : 	boolean skippixels = false;

  0000c	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 0

; 1088 : 	INT32 skiprowcnt;
; 1089 : 
; 1090 : #ifdef HWRENDER
; 1091 : 	// draw a hardware converted patch
; 1092 : 	if (rendermode != render_soft && rendermode != render_none)

  00013	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0001a	74 69		 je	 SHORT $LN16@V_DrawSmal
  0001c	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00023	74 60		 je	 SHORT $LN16@V_DrawSmal

; 1093 : 	{
; 1094 : 		if (!(scrn & V_NOSCALESTART)) // Graue 07-08-2004: I have no idea why this works

  00025	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00028	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0002d	75 33		 jne	 SHORT $LN17@V_DrawSmal

; 1095 : 		{
; 1096 : 			x = (INT32)(vid.fdupx*x);

  0002f	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  00034	f3 0f 59 05 28
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+40
  0003c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00040	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 1097 : 			y = (INT32)(vid.fdupy*y);

  00043	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  00048	f3 0f 59 05 2c
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+44
  00050	f3 0f 2c c0	 cvttss2si eax, xmm0
  00054	89 45 0c	 mov	 DWORD PTR _y$[ebp], eax

; 1098 : 			scrn |= V_NOSCALESTART;

  00057	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0005a	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  0005f	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax
$LN17@V_DrawSmal:

; 1099 : 		}
; 1100 : 		HWR_DrawSmallPatch((GLPatch_t *)patch, x, y, scrn, colormaps);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _colormaps
  00067	50		 push	 eax
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006f	52		 push	 edx
  00070	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _HWR_DrawSmallPatch
  0007d	83 c4 14	 add	 esp, 20			; 00000014H

; 1101 : 		return;

  00080	e9 da 04 00 00	 jmp	 $LN3@V_DrawSmal
$LN16@V_DrawSmal:

; 1102 : 	}
; 1103 : #endif
; 1104 : 
; 1105 : 	if (scrn & V_8020TRANS)

  00085	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00088	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0008d	74 0f		 je	 SHORT $LN18@V_DrawSmal

; 1106 : 		translevel = ((tr_trans80)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00094	05 00 00 07 00	 add	 eax, 458752		; 00070000H
  00099	89 45 c8	 mov	 DWORD PTR _translevel$[ebp], eax
  0009c	eb 0d		 jmp	 SHORT $LN19@V_DrawSmal
$LN18@V_DrawSmal:

; 1107 : 	else
; 1108 : 		translevel = ((tr_trans50)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  000a3	05 00 00 04 00	 add	 eax, 262144		; 00040000H
  000a8	89 45 c8	 mov	 DWORD PTR _translevel$[ebp], eax
$LN19@V_DrawSmal:

; 1109 : 
; 1110 : 	if (vid.dupx > 1 && vid.dupy > 1)

  000ab	83 3d 20 00 00
	00 01		 cmp	 DWORD PTR _vid+32, 1
  000b2	7e 25		 jle	 SHORT $LN20@V_DrawSmal
  000b4	83 3d 24 00 00
	00 01		 cmp	 DWORD PTR _vid+36, 1
  000bb	7e 1c		 jle	 SHORT $LN20@V_DrawSmal

; 1111 : 	{
; 1112 : 		dupx = vid.dupx / 2;

  000bd	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  000c2	99		 cdq
  000c3	2b c2		 sub	 eax, edx
  000c5	d1 f8		 sar	 eax, 1
  000c7	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 1113 : 		dupy = vid.dupy / 2;

  000ca	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  000cf	99		 cdq
  000d0	2b c2		 sub	 eax, edx
  000d2	d1 f8		 sar	 eax, 1
  000d4	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax

; 1114 : 	}

  000d7	eb 14		 jmp	 SHORT $LN21@V_DrawSmal
$LN20@V_DrawSmal:

; 1115 : 	else
; 1116 : 	{
; 1117 : 		dupx = dupy = 1;

  000d9	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  000e0	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  000e3	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 1118 : 		skippixels = true;

  000e6	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 1
$LN21@V_DrawSmal:

; 1119 : 	}
; 1120 : 
; 1121 : 	y -= SHORT(patch->topoffset);

  000ed	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000f0	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000f4	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000f7	2b d1		 sub	 edx, ecx
  000f9	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 1122 : 	x -= SHORT(patch->leftoffset);

  000fc	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000ff	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00103	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00106	2b d1		 sub	 edx, ecx
  00108	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 1123 : 
; 1124 : 	if (skippixels)

  0010b	83 7d c4 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  0010f	74 19		 je	 SHORT $LN22@V_DrawSmal

; 1125 : 		colfrac = FixedDiv(FRACUNIT, (dupx)<<(FRACBITS-1));

  00111	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  00114	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00117	50		 push	 eax
  00118	68 00 00 01 00	 push	 65536			; 00010000H
  0011d	e8 00 00 00 00	 call	 _FixedDiv
  00122	83 c4 08	 add	 esp, 8
  00125	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
  00128	eb 17		 jmp	 SHORT $LN23@V_DrawSmal
$LN22@V_DrawSmal:

; 1126 : 	else
; 1127 : 		colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  0012a	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  0012d	c1 e0 10	 shl	 eax, 16			; 00000010H
  00130	50		 push	 eax
  00131	68 00 00 01 00	 push	 65536			; 00010000H
  00136	e8 00 00 00 00	 call	 _FixedDiv
  0013b	83 c4 08	 add	 esp, 8
  0013e	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
$LN23@V_DrawSmal:

; 1128 : 
; 1129 : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  00141	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  00144	c1 e0 10	 shl	 eax, 16			; 00000010H
  00147	50		 push	 eax
  00148	68 00 00 01 00	 push	 65536			; 00010000H
  0014d	e8 00 00 00 00	 call	 _FixedDiv
  00152	83 c4 08	 add	 esp, 8
  00155	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 1130 : 
; 1131 : 	if (scrn & V_NOSCALESTART)

  00158	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0015b	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00160	74 23		 je	 SHORT $LN24@V_DrawSmal

; 1132 : 		desttop = screens[scrn&0xFF] + (y * vid.width) + x;

  00162	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00165	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016a	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0016d	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00174	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  0017b	03 d1		 add	 edx, ecx
  0017d	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  00180	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
  00183	eb 31		 jmp	 SHORT $LN25@V_DrawSmal
$LN24@V_DrawSmal:

; 1133 : 	else
; 1134 : 		desttop = screens[scrn&0xFF] + (y * vid.dupy * vid.width) + (x * vid.dupx);

  00185	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00188	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0018d	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00190	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  00197	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0019e	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  001a5	03 d1		 add	 edx, ecx
  001a7	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001aa	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  001b1	03 d0		 add	 edx, eax
  001b3	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
$LN25@V_DrawSmal:

; 1135 : 
; 1136 : 	deststop = screens[scrn&0xFF] + vid.width * vid.height * vid.bpp;

  001b6	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001b9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001be	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  001c4	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  001cb	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  001d2	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  001d9	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 1137 : 
; 1138 : 	if (!desttop)

  001dc	83 7d dc 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  001e0	75 05		 jne	 SHORT $LN26@V_DrawSmal

; 1139 : 		return;

  001e2	e9 78 03 00 00	 jmp	 $LN3@V_DrawSmal
$LN26@V_DrawSmal:

; 1140 : 
; 1141 : 	if (!(scrn & V_NOSCALESTART))

  001e7	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001ea	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001ef	0f 85 1b 01 00
	00		 jne	 $LN36@V_DrawSmal

; 1142 : 	{
; 1143 : 		/// \bug yeah... the Y still seems to be off a few lines...
; 1144 : 		/// see rankings in 640x480 or 800x600
; 1145 : 		if (vid.fdupx != vid.dupx)

  001f5	f3 0f 2a 05 20
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+32
  001fd	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  00205	0f 2e c8	 ucomiss xmm1, xmm0
  00208	9f		 lahf
  00209	f6 c4 44	 test	 ah, 68			; 00000044H
  0020c	7b 4d		 jnp	 SHORT $LN31@V_DrawSmal

; 1146 : 		{
; 1147 : 			// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 1148 : 			// so center this imaginary screen
; 1149 : 			if (scrn & V_SNAPTORIGHT)

  0020e	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00211	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00216	74 1a		 je	 SHORT $LN29@V_DrawSmal

; 1150 : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx));

  00218	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  00222	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00228	2b c8		 sub	 ecx, eax
  0022a	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0022d	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  00230	eb 29		 jmp	 SHORT $LN31@V_DrawSmal
$LN29@V_DrawSmal:

; 1151 : 			else if (!(scrn & V_SNAPTOLEFT))

  00232	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00235	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0023a	75 1f		 jne	 SHORT $LN31@V_DrawSmal

; 1152 : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx)) / 2;

  0023c	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  00246	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0024c	2b c8		 sub	 ecx, eax
  0024e	8b c1		 mov	 eax, ecx
  00250	99		 cdq
  00251	2b c2		 sub	 eax, edx
  00253	d1 f8		 sar	 eax, 1
  00255	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00258	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN31@V_DrawSmal:

; 1153 : 		}
; 1154 : 		if (vid.fdupy != dupy)

  0025b	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  00260	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  00268	0f 2e c8	 ucomiss xmm1, xmm0
  0026b	9f		 lahf
  0026c	f6 c4 44	 test	 ah, 68			; 00000044H
  0026f	7b 5b		 jnp	 SHORT $LN35@V_DrawSmal

; 1155 : 		{
; 1156 : 			// same thing here
; 1157 : 			if (scrn & V_SNAPTOBOTTOM)

  00271	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00274	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00279	74 21		 je	 SHORT $LN33@V_DrawSmal

; 1158 : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width;

  0027b	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  00285	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  0028b	2b c8		 sub	 ecx, eax
  0028d	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00294	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00297	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  0029a	eb 30		 jmp	 SHORT $LN35@V_DrawSmal
$LN33@V_DrawSmal:

; 1159 : 			else if (!(scrn & V_SNAPTOTOP))

  0029c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0029f	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  002a4	75 26		 jne	 SHORT $LN35@V_DrawSmal

; 1160 : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width / 2;

  002a6	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  002b0	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  002b6	2b c8		 sub	 ecx, eax
  002b8	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  002bf	8b c1		 mov	 eax, ecx
  002c1	99		 cdq
  002c2	2b c2		 sub	 eax, edx
  002c4	d1 f8		 sar	 eax, 1
  002c6	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  002c9	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN35@V_DrawSmal:

; 1161 : 		}
; 1162 : 
; 1163 : 		// if it's meant to cover the whole screen, black out the rest
; 1164 : 		if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH*2 && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT*2)

  002cc	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  002d0	75 3e		 jne	 SHORT $LN36@V_DrawSmal
  002d2	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002d5	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002d8	81 f9 80 02 00
	00		 cmp	 ecx, 640		; 00000280H
  002de	75 30		 jne	 SHORT $LN36@V_DrawSmal
  002e0	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  002e4	75 2a		 jne	 SHORT $LN36@V_DrawSmal
  002e6	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002e9	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  002ed	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  002f3	75 1b		 jne	 SHORT $LN36@V_DrawSmal

; 1165 : 			V_DrawFill(0, 0, vid.width, vid.height, 31);

  002f5	6a 1f		 push	 31			; 0000001fH
  002f7	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  002fc	50		 push	 eax
  002fd	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00303	51		 push	 ecx
  00304	6a 00		 push	 0
  00306	6a 00		 push	 0
  00308	e8 00 00 00 00	 call	 _V_DrawFill
  0030d	83 c4 14	 add	 esp, 20			; 00000014H
$LN36@V_DrawSmal:

; 1166 : 	}
; 1167 : 
; 1168 : 	if (skippixels)

  00310	83 7d c4 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  00314	74 17		 je	 SHORT $LN37@V_DrawSmal

; 1169 : 		destend = desttop + SHORT(patch->width)/2 * dupx;

  00316	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00319	0f bf 00	 movsx	 eax, WORD PTR [eax]
  0031c	99		 cdq
  0031d	2b c2		 sub	 eax, edx
  0031f	d1 f8		 sar	 eax, 1
  00321	0f af 45 f4	 imul	 eax, DWORD PTR _dupx$[ebp]
  00325	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00328	89 45 d4	 mov	 DWORD PTR _destend$[ebp], eax
  0032b	eb 10		 jmp	 SHORT $LN38@V_DrawSmal
$LN37@V_DrawSmal:

; 1170 : 	else
; 1171 : 		destend = desttop + SHORT(patch->width) * dupx;

  0032d	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00330	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00333	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00337	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0033a	89 4d d4	 mov	 DWORD PTR _destend$[ebp], ecx
$LN38@V_DrawSmal:

; 1172 : 
; 1173 : 	for (col = 0; desttop < destend; col += colfrac, desttop++)

  0033d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  00344	eb 12		 jmp	 SHORT $LN4@V_DrawSmal
$LN2@V_DrawSmal:
  00346	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00349	03 45 e8	 add	 eax, DWORD PTR _colfrac$[ebp]
  0034c	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  0034f	8b 4d dc	 mov	 ecx, DWORD PTR _desttop$[ebp]
  00352	83 c1 01	 add	 ecx, 1
  00355	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawSmal:
  00358	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  0035b	3b 45 d4	 cmp	 eax, DWORD PTR _destend$[ebp]
  0035e	0f 83 fb 01 00
	00		 jae	 $LN3@V_DrawSmal

; 1174 : 	{
; 1175 : 		register INT32 heightmask;
; 1176 : 
; 1177 : 		column = (const column_t *)((const UINT8 *)(patch) + LONG(patch->columnofs[col>>FRACBITS]));

  00364	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00367	c1 f8 10	 sar	 eax, 16			; 00000010H
  0036a	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  0036d	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  00370	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  00374	89 55 e0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawSmal:

; 1178 : 
; 1179 : 		while (column->topdelta != 0xff)

  00377	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0037a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0037d	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00383	0f 84 d1 01 00
	00		 je	 $LN6@V_DrawSmal

; 1180 : 		{
; 1181 : 			source = (const UINT8 *)(column) + 3;

  00389	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0038c	83 c0 03	 add	 eax, 3
  0038f	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 1182 : 			dest = desttop + column->topdelta*dupy*vid.width;

  00392	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00395	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00398	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  0039c	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  003a3	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  003a6	89 4d d8	 mov	 DWORD PTR _dest$[ebp], ecx

; 1183 : 			count = column->length*dupy;

  003a9	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003ac	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003b0	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  003b4	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 1184 : 			skiprowcnt = 0;

  003b7	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _skiprowcnt$[ebp], 0

; 1185 : 
; 1186 : 			ofs = 0;

  003be	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0

; 1187 : 
; 1188 : 			heightmask = column->length - 1;

  003c5	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003c8	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003cc	83 e9 01	 sub	 ecx, 1
  003cf	89 4d bc	 mov	 DWORD PTR _heightmask$1[ebp], ecx

; 1189 : 
; 1190 : 			if (column->length & heightmask)

  003d2	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003d5	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003d9	23 4d bc	 and	 ecx, DWORD PTR _heightmask$1[ebp]
  003dc	0f 84 d8 00 00
	00		 je	 $LN39@V_DrawSmal

; 1191 : 			{
; 1192 : 				heightmask++;

  003e2	8b 45 bc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003e5	83 c0 01	 add	 eax, 1
  003e8	89 45 bc	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 1193 : 				heightmask <<= FRACBITS;

  003eb	8b 45 bc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003ee	c1 e0 10	 shl	 eax, 16			; 00000010H
  003f1	89 45 bc	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 1194 : 
; 1195 : 				if (rowfrac < 0)

  003f4	83 7d e4 00	 cmp	 DWORD PTR _rowfrac$[ebp], 0
  003f8	7d 0f		 jge	 SHORT $LN41@V_DrawSmal
$LN7@V_DrawSmal:

; 1196 : 					while ((rowfrac += heightmask) < 0)

  003fa	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003fd	03 45 bc	 add	 eax, DWORD PTR _heightmask$1[ebp]
  00400	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  00403	79 02		 jns	 SHORT $LN8@V_DrawSmal

; 1197 : 						;

  00405	eb f3		 jmp	 SHORT $LN7@V_DrawSmal
$LN8@V_DrawSmal:
  00407	eb 13		 jmp	 SHORT $LN10@V_DrawSmal
$LN41@V_DrawSmal:

; 1198 : 				else
; 1199 : 					while (rowfrac >= heightmask)

  00409	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  0040c	3b 45 bc	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  0040f	7c 0b		 jl	 SHORT $LN10@V_DrawSmal

; 1200 : 						rowfrac -= heightmask;

  00411	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00414	2b 45 bc	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  00417	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  0041a	eb ed		 jmp	 SHORT $LN41@V_DrawSmal
$LN10@V_DrawSmal:

; 1201 : 
; 1202 : 				do
; 1203 : 				{
; 1204 : 					if (dest < deststop)

  0041c	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0041f	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00422	73 2f		 jae	 SHORT $LN43@V_DrawSmal

; 1205 : 						*dest = *(translevel + ((source[ofs>>FRACBITS]<<8)&0xff00) + (*dest&0xff));

  00424	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00427	c1 f8 10	 sar	 eax, 16			; 00000010H
  0042a	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  0042d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00431	c1 e2 08	 shl	 edx, 8
  00434	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  0043a	03 55 c8	 add	 edx, DWORD PTR _translevel$[ebp]
  0043d	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00440	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00443	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00449	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0044c	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  0044f	88 08		 mov	 BYTE PTR [eax], cl
  00451	eb 07		 jmp	 SHORT $LN44@V_DrawSmal
$LN43@V_DrawSmal:

; 1206 : 					else
; 1207 : 						count = 0;

  00453	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN44@V_DrawSmal:

; 1208 : 
; 1209 : 					if (!(skippixels && (skiprowcnt & 1)))

  0045a	83 7d c4 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  0045e	74 08		 je	 SHORT $LN46@V_DrawSmal
  00460	8b 45 c0	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00463	83 e0 01	 and	 eax, 1
  00466	75 0c		 jne	 SHORT $LN45@V_DrawSmal
$LN46@V_DrawSmal:

; 1210 : 						dest += vid.width;

  00468	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0046b	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00471	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN45@V_DrawSmal:

; 1211 : 
; 1212 : 					ofs += rowfrac;

  00474	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00477	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  0047a	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 1213 : 					if ((ofs + rowfrac) > heightmask)

  0047d	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00480	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00483	3b 45 bc	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  00486	7e 05		 jle	 SHORT $LN47@V_DrawSmal

; 1214 : 						goto donesmallmapping;

  00488	e9 b7 00 00 00	 jmp	 $donesmallmapping$53
$LN47@V_DrawSmal:

; 1215 : 
; 1216 : 					skiprowcnt++;

  0048d	8b 45 c0	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00490	83 c0 01	 add	 eax, 1
  00493	89 45 c0	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 1217 : 				} while (count--);

  00496	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00499	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv272[ebp], eax
  0049f	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  004a2	83 e9 01	 sub	 ecx, 1
  004a5	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  004a8	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv272[ebp], 0
  004af	0f 85 67 ff ff
	ff		 jne	 $LN10@V_DrawSmal

; 1218 : 			}

  004b5	e9 8a 00 00 00	 jmp	 $donesmallmapping$53
$LN39@V_DrawSmal:

; 1219 : 			else
; 1220 : 			{
; 1221 : 				while (count--)

  004ba	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  004bd	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv275[ebp], eax
  004c3	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  004c6	83 e9 01	 sub	 ecx, 1
  004c9	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  004cc	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv275[ebp], 0
  004d3	74 6f		 je	 SHORT $donesmallmapping$53

; 1222 : 				{
; 1223 : 					if (dest < deststop)

  004d5	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  004d8	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  004db	73 2f		 jae	 SHORT $LN48@V_DrawSmal

; 1224 : 						*dest = *(translevel + ((source[ofs>>FRACBITS]<<8)&0xff00) + (*dest&0xff));

  004dd	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  004e0	c1 f8 10	 sar	 eax, 16			; 00000010H
  004e3	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  004e6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004ea	c1 e2 08	 shl	 edx, 8
  004ed	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  004f3	03 55 c8	 add	 edx, DWORD PTR _translevel$[ebp]
  004f6	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  004f9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  004fc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00502	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00505	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00508	88 08		 mov	 BYTE PTR [eax], cl
  0050a	eb 07		 jmp	 SHORT $LN49@V_DrawSmal
$LN48@V_DrawSmal:

; 1225 : 					else
; 1226 : 						count = 0;

  0050c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN49@V_DrawSmal:

; 1227 : 
; 1228 : 					if (!(skippixels && (skiprowcnt & 1)))

  00513	83 7d c4 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  00517	74 08		 je	 SHORT $LN51@V_DrawSmal
  00519	8b 45 c0	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  0051c	83 e0 01	 and	 eax, 1
  0051f	75 0c		 jne	 SHORT $LN50@V_DrawSmal
$LN51@V_DrawSmal:

; 1229 : 						dest += vid.width;

  00521	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00524	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0052a	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN50@V_DrawSmal:

; 1230 : 
; 1231 : 					ofs += rowfrac;

  0052d	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00530	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00533	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 1232 : 					skiprowcnt++;

  00536	8b 45 c0	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00539	83 c0 01	 add	 eax, 1
  0053c	89 45 c0	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 1233 : 				}

  0053f	e9 76 ff ff ff	 jmp	 $LN39@V_DrawSmal
$donesmallmapping$53:

; 1234 : 			}
; 1235 : donesmallmapping:
; 1236 : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  00544	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00547	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0054b	8b 55 e0	 mov	 edx, DWORD PTR _column$[ebp]
  0054e	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00552	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 1237 : 		}

  00555	e9 1d fe ff ff	 jmp	 $LN5@V_DrawSmal
$LN6@V_DrawSmal:

; 1238 : 	}

  0055a	e9 e7 fd ff ff	 jmp	 $LN2@V_DrawSmal
$LN3@V_DrawSmal:

; 1239 : }

  0055f	5f		 pop	 edi
  00560	5e		 pop	 esi
  00561	5b		 pop	 ebx
  00562	8b e5		 mov	 esp, ebp
  00564	5d		 pop	 ebp
  00565	c3		 ret	 0
_V_DrawSmallTranslucentPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawSmallTranslucentMappedPatch
_TEXT	SEGMENT
tv273 = -136						; size = 4
tv276 = -136						; size = 4
_heightmask$1 = -68					; size = 4
_translevel$ = -64					; size = 4
_skiprowcnt$ = -60					; size = 4
_skippixels$ = -56					; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_destend$ = -44						; size = 4
_dest$ = -40						; size = 4
_desttop$ = -36						; size = 4
_column$ = -32						; size = 4
_rowfrac$ = -28						; size = 4
_colfrac$ = -24						; size = 4
_ofs$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_colormap$ = 24						; size = 4
_V_DrawSmallTranslucentMappedPatch PROC			; COMDAT

; 917  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 918  : 	size_t count;
; 919  : 	INT32 col, dupx, dupy, ofs, colfrac, rowfrac;
; 920  : 	const column_t *column;
; 921  : 	UINT8 *desttop, *dest, *destend;
; 922  : 	const UINT8 *source, *deststop;
; 923  : 	boolean skippixels = false;

  0000c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 0

; 924  : 	INT32 skiprowcnt;
; 925  : 	UINT8 *translevel;
; 926  : 
; 927  : 	if (scrn & V_8020TRANS)

  00013	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00016	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0001b	74 0f		 je	 SHORT $LN16@V_DrawSmal

; 928  : 		translevel = ((tr_trans80)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00022	05 00 00 07 00	 add	 eax, 458752		; 00070000H
  00027	89 45 c0	 mov	 DWORD PTR _translevel$[ebp], eax
  0002a	eb 0d		 jmp	 SHORT $LN17@V_DrawSmal
$LN16@V_DrawSmal:

; 929  : 	else
; 930  : 		translevel = ((tr_trans50)<<FF_TRANSSHIFT) - 0x10000 + transtables;

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00031	05 00 00 04 00	 add	 eax, 262144		; 00040000H
  00036	89 45 c0	 mov	 DWORD PTR _translevel$[ebp], eax
$LN17@V_DrawSmal:

; 931  : 
; 932  : #ifdef HWRENDER
; 933  : 	// draw a hardware converted patch
; 934  : 	if (rendermode != render_soft && rendermode != render_none)

  00039	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00040	74 67		 je	 SHORT $LN18@V_DrawSmal
  00042	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00049	74 5e		 je	 SHORT $LN18@V_DrawSmal

; 935  : 	{
; 936  : 		if (!(scrn & V_NOSCALESTART)) // Graue 07-08-2004: I have no idea why this works

  0004b	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0004e	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00053	75 33		 jne	 SHORT $LN19@V_DrawSmal

; 937  : 		{
; 938  : 			x = (INT32)(vid.fdupx*x);

  00055	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  0005a	f3 0f 59 05 28
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+40
  00062	f3 0f 2c c0	 cvttss2si eax, xmm0
  00066	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 939  : 			y = (INT32)(vid.fdupy*y);

  00069	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  0006e	f3 0f 59 05 2c
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+44
  00076	f3 0f 2c c0	 cvttss2si eax, xmm0
  0007a	89 45 0c	 mov	 DWORD PTR _y$[ebp], eax

; 940  : 			scrn |= V_NOSCALESTART;

  0007d	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00080	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  00085	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax
$LN19@V_DrawSmal:

; 941  : 		}
; 942  : 		HWR_DrawSmallPatch((GLPatch_t *)patch, x, y, scrn, colormap);

  00088	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  0008f	51		 push	 ecx
  00090	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00093	52		 push	 edx
  00094	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _HWR_DrawSmallPatch
  000a1	83 c4 14	 add	 esp, 20			; 00000014H

; 943  : 		return;

  000a4	e9 aa 04 00 00	 jmp	 $LN3@V_DrawSmal
$LN18@V_DrawSmal:

; 944  : 	}
; 945  : #endif
; 946  : 
; 947  : 	if (vid.dupx > 1 && vid.dupy > 1)

  000a9	83 3d 20 00 00
	00 01		 cmp	 DWORD PTR _vid+32, 1
  000b0	7e 25		 jle	 SHORT $LN20@V_DrawSmal
  000b2	83 3d 24 00 00
	00 01		 cmp	 DWORD PTR _vid+36, 1
  000b9	7e 1c		 jle	 SHORT $LN20@V_DrawSmal

; 948  : 	{
; 949  : 		dupx = vid.dupx / 2;

  000bb	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  000c0	99		 cdq
  000c1	2b c2		 sub	 eax, edx
  000c3	d1 f8		 sar	 eax, 1
  000c5	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 950  : 		dupy = vid.dupy / 2;

  000c8	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  000cd	99		 cdq
  000ce	2b c2		 sub	 eax, edx
  000d0	d1 f8		 sar	 eax, 1
  000d2	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax

; 951  : 	}

  000d5	eb 14		 jmp	 SHORT $LN21@V_DrawSmal
$LN20@V_DrawSmal:

; 952  : 	else
; 953  : 	{
; 954  : 		dupx = dupy = 1;

  000d7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  000de	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  000e1	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 955  : 		skippixels = true;

  000e4	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 1
$LN21@V_DrawSmal:

; 956  : 	}
; 957  : 
; 958  : 	y -= SHORT(patch->topoffset);

  000eb	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000ee	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000f2	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000f5	2b d1		 sub	 edx, ecx
  000f7	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 959  : 	x -= SHORT(patch->leftoffset);

  000fa	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000fd	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00101	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00104	2b d1		 sub	 edx, ecx
  00106	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 960  : 
; 961  : 	if (skippixels)

  00109	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  0010d	74 19		 je	 SHORT $LN22@V_DrawSmal

; 962  : 		colfrac = FixedDiv(FRACUNIT, (dupx)<<(FRACBITS-1));

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  00112	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00115	50		 push	 eax
  00116	68 00 00 01 00	 push	 65536			; 00010000H
  0011b	e8 00 00 00 00	 call	 _FixedDiv
  00120	83 c4 08	 add	 esp, 8
  00123	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
  00126	eb 17		 jmp	 SHORT $LN23@V_DrawSmal
$LN22@V_DrawSmal:

; 963  : 	else
; 964  : 		colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  00128	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  0012b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0012e	50		 push	 eax
  0012f	68 00 00 01 00	 push	 65536			; 00010000H
  00134	e8 00 00 00 00	 call	 _FixedDiv
  00139	83 c4 08	 add	 esp, 8
  0013c	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
$LN23@V_DrawSmal:

; 965  : 
; 966  : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  0013f	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  00142	c1 e0 10	 shl	 eax, 16			; 00000010H
  00145	50		 push	 eax
  00146	68 00 00 01 00	 push	 65536			; 00010000H
  0014b	e8 00 00 00 00	 call	 _FixedDiv
  00150	83 c4 08	 add	 esp, 8
  00153	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 967  : 
; 968  : 	if (scrn & V_NOSCALESTART)

  00156	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00159	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0015e	74 23		 je	 SHORT $LN24@V_DrawSmal

; 969  : 		desttop = screens[scrn&0xFF] + (y * vid.width) + x;

  00160	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00163	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00168	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0016b	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00172	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  00179	03 d1		 add	 edx, ecx
  0017b	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  0017e	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
  00181	eb 31		 jmp	 SHORT $LN25@V_DrawSmal
$LN24@V_DrawSmal:

; 970  : 	else
; 971  : 		desttop = screens[scrn&0xFF] + (y * vid.dupy * vid.width) + (x * vid.dupx);

  00183	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00186	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0018b	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0018e	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  00195	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0019c	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  001a3	03 d1		 add	 edx, ecx
  001a5	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001a8	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  001af	03 d0		 add	 edx, eax
  001b1	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
$LN25@V_DrawSmal:

; 972  : 
; 973  : 	deststop = screens[scrn&0xFF] + vid.width * vid.height * vid.bpp;

  001b4	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001bc	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  001c2	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  001c9	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  001d0	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  001d7	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 974  : 
; 975  : 	if (!desttop)

  001da	83 7d dc 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  001de	75 05		 jne	 SHORT $LN26@V_DrawSmal

; 976  : 		return;

  001e0	e9 6e 03 00 00	 jmp	 $LN3@V_DrawSmal
$LN26@V_DrawSmal:

; 977  : 
; 978  : 	if (!(scrn & V_NOSCALESTART))

  001e5	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001e8	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001ed	0f 85 1b 01 00
	00		 jne	 $LN36@V_DrawSmal

; 979  : 	{
; 980  : 		/// \bug yeah... the Y still seems to be off a few lines...
; 981  : 		/// see rankings in 640x480 or 800x600
; 982  : 		if (vid.fdupx != vid.dupx)

  001f3	f3 0f 2a 05 20
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+32
  001fb	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  00203	0f 2e c8	 ucomiss xmm1, xmm0
  00206	9f		 lahf
  00207	f6 c4 44	 test	 ah, 68			; 00000044H
  0020a	7b 4d		 jnp	 SHORT $LN31@V_DrawSmal

; 983  : 		{
; 984  : 			// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 985  : 			// so center this imaginary screen
; 986  : 			if (scrn & V_SNAPTORIGHT)

  0020c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0020f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00214	74 1a		 je	 SHORT $LN29@V_DrawSmal

; 987  : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx));

  00216	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  00220	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00226	2b c8		 sub	 ecx, eax
  00228	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0022b	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  0022e	eb 29		 jmp	 SHORT $LN31@V_DrawSmal
$LN29@V_DrawSmal:

; 988  : 			else if (!(scrn & V_SNAPTOLEFT))

  00230	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00233	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00238	75 1f		 jne	 SHORT $LN31@V_DrawSmal

; 989  : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx)) / 2;

  0023a	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  00244	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0024a	2b c8		 sub	 ecx, eax
  0024c	8b c1		 mov	 eax, ecx
  0024e	99		 cdq
  0024f	2b c2		 sub	 eax, edx
  00251	d1 f8		 sar	 eax, 1
  00253	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00256	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN31@V_DrawSmal:

; 990  : 		}
; 991  : 		if (vid.fdupy != dupy)

  00259	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  0025e	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  00266	0f 2e c8	 ucomiss xmm1, xmm0
  00269	9f		 lahf
  0026a	f6 c4 44	 test	 ah, 68			; 00000044H
  0026d	7b 5b		 jnp	 SHORT $LN35@V_DrawSmal

; 992  : 		{
; 993  : 			// same thing here
; 994  : 			if (scrn & V_SNAPTOBOTTOM)

  0026f	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00272	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00277	74 21		 je	 SHORT $LN33@V_DrawSmal

; 995  : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width;

  00279	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  00283	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00289	2b c8		 sub	 ecx, eax
  0028b	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00292	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00295	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  00298	eb 30		 jmp	 SHORT $LN35@V_DrawSmal
$LN33@V_DrawSmal:

; 996  : 			else if (!(scrn & V_SNAPTOTOP))

  0029a	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0029d	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  002a2	75 26		 jne	 SHORT $LN35@V_DrawSmal

; 997  : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width / 2;

  002a4	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  002ae	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  002b4	2b c8		 sub	 ecx, eax
  002b6	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  002bd	8b c1		 mov	 eax, ecx
  002bf	99		 cdq
  002c0	2b c2		 sub	 eax, edx
  002c2	d1 f8		 sar	 eax, 1
  002c4	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  002c7	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN35@V_DrawSmal:

; 998  : 		}
; 999  : 
; 1000 : 		// if it's meant to cover the whole screen, black out the rest
; 1001 : 		if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH*2 && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT*2)

  002ca	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  002ce	75 3e		 jne	 SHORT $LN36@V_DrawSmal
  002d0	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002d3	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002d6	81 f9 80 02 00
	00		 cmp	 ecx, 640		; 00000280H
  002dc	75 30		 jne	 SHORT $LN36@V_DrawSmal
  002de	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  002e2	75 2a		 jne	 SHORT $LN36@V_DrawSmal
  002e4	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002e7	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  002eb	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  002f1	75 1b		 jne	 SHORT $LN36@V_DrawSmal

; 1002 : 			V_DrawFill(0, 0, vid.width, vid.height, 31);

  002f3	6a 1f		 push	 31			; 0000001fH
  002f5	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  002fa	50		 push	 eax
  002fb	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00301	51		 push	 ecx
  00302	6a 00		 push	 0
  00304	6a 00		 push	 0
  00306	e8 00 00 00 00	 call	 _V_DrawFill
  0030b	83 c4 14	 add	 esp, 20			; 00000014H
$LN36@V_DrawSmal:

; 1003 : 	}
; 1004 : 
; 1005 : 	if (skippixels)

  0030e	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  00312	74 17		 je	 SHORT $LN37@V_DrawSmal

; 1006 : 		destend = desttop + SHORT(patch->width)/2 * dupx;

  00314	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00317	0f bf 00	 movsx	 eax, WORD PTR [eax]
  0031a	99		 cdq
  0031b	2b c2		 sub	 eax, edx
  0031d	d1 f8		 sar	 eax, 1
  0031f	0f af 45 f4	 imul	 eax, DWORD PTR _dupx$[ebp]
  00323	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00326	89 45 d4	 mov	 DWORD PTR _destend$[ebp], eax
  00329	eb 10		 jmp	 SHORT $LN38@V_DrawSmal
$LN37@V_DrawSmal:

; 1007 : 	else
; 1008 : 		destend = desttop + SHORT(patch->width) * dupx;

  0032b	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0032e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00331	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00335	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00338	89 4d d4	 mov	 DWORD PTR _destend$[ebp], ecx
$LN38@V_DrawSmal:

; 1009 : 
; 1010 : 	for (col = 0; desttop < destend; col += colfrac, desttop++)

  0033b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  00342	eb 12		 jmp	 SHORT $LN4@V_DrawSmal
$LN2@V_DrawSmal:
  00344	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00347	03 45 e8	 add	 eax, DWORD PTR _colfrac$[ebp]
  0034a	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  0034d	8b 4d dc	 mov	 ecx, DWORD PTR _desttop$[ebp]
  00350	83 c1 01	 add	 ecx, 1
  00353	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawSmal:
  00356	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  00359	3b 45 d4	 cmp	 eax, DWORD PTR _destend$[ebp]
  0035c	0f 83 f1 01 00
	00		 jae	 $LN3@V_DrawSmal

; 1011 : 	{
; 1012 : 		register INT32 heightmask;
; 1013 : 
; 1014 : 		column = (const column_t *)((const UINT8 *)(patch) + LONG(patch->columnofs[col>>FRACBITS]));

  00362	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00365	c1 f8 10	 sar	 eax, 16			; 00000010H
  00368	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  0036b	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  0036e	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  00372	89 55 e0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawSmal:

; 1015 : 
; 1016 : 		while (column->topdelta != 0xff)

  00375	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00378	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0037b	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00381	0f 84 c7 01 00
	00		 je	 $LN6@V_DrawSmal

; 1017 : 		{
; 1018 : 			source = (const UINT8 *)(column) + 3;

  00387	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0038a	83 c0 03	 add	 eax, 3
  0038d	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 1019 : 			dest = desttop + column->topdelta*dupy*vid.width;

  00390	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00393	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00396	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  0039a	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  003a1	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  003a4	89 4d d8	 mov	 DWORD PTR _dest$[ebp], ecx

; 1020 : 			count = column->length*dupy;

  003a7	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003aa	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003ae	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  003b2	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 1021 : 			skiprowcnt = 0;

  003b5	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _skiprowcnt$[ebp], 0

; 1022 : 
; 1023 : 			ofs = 0;

  003bc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0

; 1024 : 
; 1025 : 			heightmask = column->length - 1;

  003c3	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003c6	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003ca	83 e9 01	 sub	 ecx, 1
  003cd	89 4d bc	 mov	 DWORD PTR _heightmask$1[ebp], ecx

; 1026 : 
; 1027 : 			if (column->length & heightmask)

  003d0	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003d3	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003d7	23 4d bc	 and	 ecx, DWORD PTR _heightmask$1[ebp]
  003da	0f 84 d3 00 00
	00		 je	 $LN39@V_DrawSmal

; 1028 : 			{
; 1029 : 				heightmask++;

  003e0	8b 45 bc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003e3	83 c0 01	 add	 eax, 1
  003e6	89 45 bc	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 1030 : 				heightmask <<= FRACBITS;

  003e9	8b 45 bc	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003ec	c1 e0 10	 shl	 eax, 16			; 00000010H
  003ef	89 45 bc	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 1031 : 
; 1032 : 				if (rowfrac < 0)

  003f2	83 7d e4 00	 cmp	 DWORD PTR _rowfrac$[ebp], 0
  003f6	7d 0f		 jge	 SHORT $LN41@V_DrawSmal
$LN7@V_DrawSmal:

; 1033 : 					while ((rowfrac += heightmask) < 0)

  003f8	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003fb	03 45 bc	 add	 eax, DWORD PTR _heightmask$1[ebp]
  003fe	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  00401	79 02		 jns	 SHORT $LN8@V_DrawSmal

; 1034 : 						;

  00403	eb f3		 jmp	 SHORT $LN7@V_DrawSmal
$LN8@V_DrawSmal:
  00405	eb 13		 jmp	 SHORT $LN10@V_DrawSmal
$LN41@V_DrawSmal:

; 1035 : 				else
; 1036 : 					while (rowfrac >= heightmask)

  00407	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  0040a	3b 45 bc	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  0040d	7c 0b		 jl	 SHORT $LN10@V_DrawSmal

; 1037 : 						rowfrac -= heightmask;

  0040f	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00412	2b 45 bc	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  00415	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  00418	eb ed		 jmp	 SHORT $LN41@V_DrawSmal
$LN10@V_DrawSmal:

; 1038 : 
; 1039 : 				do
; 1040 : 				{
; 1041 : 					if (dest < deststop)

  0041a	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0041d	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00420	73 2a		 jae	 SHORT $LN43@V_DrawSmal

; 1042 : 						*dest = *(translevel + (colormap[source[ofs>>FRACBITS]]<<8) + (*dest));

  00422	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00425	c1 f8 10	 sar	 eax, 16			; 00000010H
  00428	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  0042b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0042f	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  00432	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00436	c1 e1 08	 shl	 ecx, 8
  00439	03 4d c0	 add	 ecx, DWORD PTR _translevel$[ebp]
  0043c	8b 55 d8	 mov	 edx, DWORD PTR _dest$[ebp]
  0043f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00442	8b 55 d8	 mov	 edx, DWORD PTR _dest$[ebp]
  00445	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00448	88 02		 mov	 BYTE PTR [edx], al
  0044a	eb 07		 jmp	 SHORT $LN44@V_DrawSmal
$LN43@V_DrawSmal:

; 1043 : 					else
; 1044 : 						count = 0;

  0044c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN44@V_DrawSmal:

; 1045 : 
; 1046 : 					if (!(skippixels && (skiprowcnt & 1)))

  00453	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  00457	74 08		 je	 SHORT $LN46@V_DrawSmal
  00459	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  0045c	83 e0 01	 and	 eax, 1
  0045f	75 0c		 jne	 SHORT $LN45@V_DrawSmal
$LN46@V_DrawSmal:

; 1047 : 						dest += vid.width;

  00461	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00464	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0046a	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN45@V_DrawSmal:

; 1048 : 
; 1049 : 					ofs += rowfrac;

  0046d	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00470	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00473	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 1050 : 					if ((ofs + rowfrac) > heightmask)

  00476	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00479	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  0047c	3b 45 bc	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  0047f	7e 05		 jle	 SHORT $LN47@V_DrawSmal

; 1051 : 						goto donesmallmapping;

  00481	e9 b2 00 00 00	 jmp	 $donesmallmapping$53
$LN47@V_DrawSmal:

; 1052 : 
; 1053 : 					skiprowcnt++;

  00486	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00489	83 c0 01	 add	 eax, 1
  0048c	89 45 c4	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 1054 : 				} while (count--);

  0048f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00492	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv273[ebp], eax
  00498	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0049b	83 e9 01	 sub	 ecx, 1
  0049e	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  004a1	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv273[ebp], 0
  004a8	0f 85 6c ff ff
	ff		 jne	 $LN10@V_DrawSmal

; 1055 : 			}

  004ae	e9 85 00 00 00	 jmp	 $donesmallmapping$53
$LN39@V_DrawSmal:

; 1056 : 			else
; 1057 : 			{
; 1058 : 				while (count--)

  004b3	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  004b6	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv276[ebp], eax
  004bc	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  004bf	83 e9 01	 sub	 ecx, 1
  004c2	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  004c5	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv276[ebp], 0
  004cc	74 6a		 je	 SHORT $donesmallmapping$53

; 1059 : 				{
; 1060 : 					if (dest < deststop)

  004ce	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  004d1	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  004d4	73 2a		 jae	 SHORT $LN48@V_DrawSmal

; 1061 : 						*dest = *(translevel + (colormap[source[ofs>>FRACBITS]]<<8) + (*dest));

  004d6	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  004d9	c1 f8 10	 sar	 eax, 16			; 00000010H
  004dc	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  004df	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004e3	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  004e6	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  004ea	c1 e1 08	 shl	 ecx, 8
  004ed	03 4d c0	 add	 ecx, DWORD PTR _translevel$[ebp]
  004f0	8b 55 d8	 mov	 edx, DWORD PTR _dest$[ebp]
  004f3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  004f6	8b 55 d8	 mov	 edx, DWORD PTR _dest$[ebp]
  004f9	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  004fc	88 02		 mov	 BYTE PTR [edx], al
  004fe	eb 07		 jmp	 SHORT $LN49@V_DrawSmal
$LN48@V_DrawSmal:

; 1062 : 					else
; 1063 : 						count = 0;

  00500	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN49@V_DrawSmal:

; 1064 : 
; 1065 : 					if (!(skippixels && (skiprowcnt & 1)))

  00507	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  0050b	74 08		 je	 SHORT $LN51@V_DrawSmal
  0050d	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00510	83 e0 01	 and	 eax, 1
  00513	75 0c		 jne	 SHORT $LN50@V_DrawSmal
$LN51@V_DrawSmal:

; 1066 : 						dest += vid.width;

  00515	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00518	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0051e	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN50@V_DrawSmal:

; 1067 : 
; 1068 : 					ofs += rowfrac;

  00521	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00524	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00527	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 1069 : 					skiprowcnt++;

  0052a	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  0052d	83 c0 01	 add	 eax, 1
  00530	89 45 c4	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 1070 : 				}

  00533	e9 7b ff ff ff	 jmp	 $LN39@V_DrawSmal
$donesmallmapping$53:

; 1071 : 			}
; 1072 : donesmallmapping:
; 1073 : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  00538	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0053b	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0053f	8b 55 e0	 mov	 edx, DWORD PTR _column$[ebp]
  00542	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00546	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 1074 : 		}

  00549	e9 27 fe ff ff	 jmp	 $LN5@V_DrawSmal
$LN6@V_DrawSmal:

; 1075 : 	}

  0054e	e9 f1 fd ff ff	 jmp	 $LN2@V_DrawSmal
$LN3@V_DrawSmal:

; 1076 : }

  00553	5f		 pop	 edi
  00554	5e		 pop	 esi
  00555	5b		 pop	 ebx
  00556	8b e5		 mov	 esp, ebp
  00558	5d		 pop	 ebp
  00559	c3		 ret	 0
_V_DrawSmallTranslucentMappedPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawSmallMappedPatch
_TEXT	SEGMENT
tv263 = -132						; size = 4
tv266 = -132						; size = 4
_heightmask$1 = -64					; size = 4
_skiprowcnt$ = -60					; size = 4
_skippixels$ = -56					; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_destend$ = -44						; size = 4
_dest$ = -40						; size = 4
_desttop$ = -36						; size = 4
_column$ = -32						; size = 4
_rowfrac$ = -28						; size = 4
_colfrac$ = -24						; size = 4
_ofs$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_colormap$ = 24						; size = 4
_V_DrawSmallMappedPatch PROC				; COMDAT

; 1243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1244 : 	size_t count;
; 1245 : 	INT32 col, dupx, dupy, ofs, colfrac, rowfrac;
; 1246 : 	const column_t *column;
; 1247 : 	UINT8 *desttop, *dest, *destend;
; 1248 : 	const UINT8 *source, *deststop;
; 1249 : 	boolean skippixels = false;

  0000c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 0

; 1250 : 	INT32 skiprowcnt;
; 1251 : 
; 1252 : #ifdef HWRENDER
; 1253 : 	// draw a hardware converted patch
; 1254 : 	if (rendermode != render_soft && rendermode != render_none)

  00013	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0001a	74 67		 je	 SHORT $LN16@V_DrawSmal
  0001c	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00023	74 5e		 je	 SHORT $LN16@V_DrawSmal

; 1255 : 	{
; 1256 : 		if (!(scrn & V_NOSCALESTART)) // Graue 07-08-2004: I have no idea why this works

  00025	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00028	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0002d	75 33		 jne	 SHORT $LN17@V_DrawSmal

; 1257 : 		{
; 1258 : 			x = (INT32)(vid.fdupx*x);

  0002f	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  00034	f3 0f 59 05 28
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+40
  0003c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00040	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 1259 : 			y = (INT32)(vid.fdupy*y);

  00043	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  00048	f3 0f 59 05 2c
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+44
  00050	f3 0f 2c c0	 cvttss2si eax, xmm0
  00054	89 45 0c	 mov	 DWORD PTR _y$[ebp], eax

; 1260 : 			scrn |= V_NOSCALESTART;

  00057	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0005a	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  0005f	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax
$LN17@V_DrawSmal:

; 1261 : 		}
; 1262 : 		HWR_DrawSmallPatch((GLPatch_t *)patch, x, y, scrn, colormap);

  00062	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _HWR_DrawSmallPatch
  0007b	83 c4 14	 add	 esp, 20			; 00000014H

; 1263 : 		return;

  0007e	e9 80 04 00 00	 jmp	 $LN3@V_DrawSmal
$LN16@V_DrawSmal:

; 1264 : 	}
; 1265 : #endif
; 1266 : 
; 1267 : 	if (vid.dupx > 1 && vid.dupy > 1)

  00083	83 3d 20 00 00
	00 01		 cmp	 DWORD PTR _vid+32, 1
  0008a	7e 25		 jle	 SHORT $LN18@V_DrawSmal
  0008c	83 3d 24 00 00
	00 01		 cmp	 DWORD PTR _vid+36, 1
  00093	7e 1c		 jle	 SHORT $LN18@V_DrawSmal

; 1268 : 	{
; 1269 : 		dupx = vid.dupx / 2;

  00095	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  0009a	99		 cdq
  0009b	2b c2		 sub	 eax, edx
  0009d	d1 f8		 sar	 eax, 1
  0009f	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 1270 : 		dupy = vid.dupy / 2;

  000a2	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  000a7	99		 cdq
  000a8	2b c2		 sub	 eax, edx
  000aa	d1 f8		 sar	 eax, 1
  000ac	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax

; 1271 : 	}

  000af	eb 14		 jmp	 SHORT $LN19@V_DrawSmal
$LN18@V_DrawSmal:

; 1272 : 	else
; 1273 : 	{
; 1274 : 		dupx = dupy = 1;

  000b1	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  000b8	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  000bb	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 1275 : 		skippixels = true;

  000be	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 1
$LN19@V_DrawSmal:

; 1276 : 	}
; 1277 : 
; 1278 : 	y -= SHORT(patch->topoffset);

  000c5	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000c8	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000cc	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000cf	2b d1		 sub	 edx, ecx
  000d1	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 1279 : 	x -= SHORT(patch->leftoffset);

  000d4	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000d7	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000db	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000de	2b d1		 sub	 edx, ecx
  000e0	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 1280 : 
; 1281 : 	if (skippixels)

  000e3	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  000e7	74 19		 je	 SHORT $LN20@V_DrawSmal

; 1282 : 		colfrac = FixedDiv(FRACUNIT, (dupx)<<(FRACBITS-1));

  000e9	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  000ec	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  000ef	50		 push	 eax
  000f0	68 00 00 01 00	 push	 65536			; 00010000H
  000f5	e8 00 00 00 00	 call	 _FixedDiv
  000fa	83 c4 08	 add	 esp, 8
  000fd	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
  00100	eb 17		 jmp	 SHORT $LN21@V_DrawSmal
$LN20@V_DrawSmal:

; 1283 : 	else
; 1284 : 		colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  00102	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  00105	c1 e0 10	 shl	 eax, 16			; 00000010H
  00108	50		 push	 eax
  00109	68 00 00 01 00	 push	 65536			; 00010000H
  0010e	e8 00 00 00 00	 call	 _FixedDiv
  00113	83 c4 08	 add	 esp, 8
  00116	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
$LN21@V_DrawSmal:

; 1285 : 
; 1286 : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  00119	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  0011c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0011f	50		 push	 eax
  00120	68 00 00 01 00	 push	 65536			; 00010000H
  00125	e8 00 00 00 00	 call	 _FixedDiv
  0012a	83 c4 08	 add	 esp, 8
  0012d	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 1287 : 
; 1288 : 	if (scrn & V_NOSCALESTART)

  00130	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00133	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00138	74 23		 je	 SHORT $LN22@V_DrawSmal

; 1289 : 		desttop = screens[scrn&0xFF] + (y * vid.width) + x;

  0013a	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0013d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00142	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00145	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0014c	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  00153	03 d1		 add	 edx, ecx
  00155	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  00158	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
  0015b	eb 31		 jmp	 SHORT $LN23@V_DrawSmal
$LN22@V_DrawSmal:

; 1290 : 	else
; 1291 : 		desttop = screens[scrn&0xFF] + (y * vid.dupy * vid.width) + (x * vid.dupx);

  0015d	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00160	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00168	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  0016f	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00176	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  0017d	03 d1		 add	 edx, ecx
  0017f	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00182	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  00189	03 d0		 add	 edx, eax
  0018b	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
$LN23@V_DrawSmal:

; 1292 : 
; 1293 : 	deststop = screens[scrn&0xFF] + vid.width * vid.height * vid.bpp;

  0018e	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00191	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00196	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0019c	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  001a3	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  001aa	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  001b1	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 1294 : 
; 1295 : 	if (!desttop)

  001b4	83 7d dc 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  001b8	75 05		 jne	 SHORT $LN24@V_DrawSmal

; 1296 : 		return;

  001ba	e9 44 03 00 00	 jmp	 $LN3@V_DrawSmal
$LN24@V_DrawSmal:

; 1297 : 
; 1298 : 	if (!(scrn & V_NOSCALESTART))

  001bf	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001c2	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001c7	0f 85 1b 01 00
	00		 jne	 $LN34@V_DrawSmal

; 1299 : 	{
; 1300 : 		/// \bug yeah... the Y still seems to be off a few lines...
; 1301 : 		/// see rankings in 640x480 or 800x600
; 1302 : 		if (vid.fdupx != vid.dupx)

  001cd	f3 0f 2a 05 20
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+32
  001d5	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  001dd	0f 2e c8	 ucomiss xmm1, xmm0
  001e0	9f		 lahf
  001e1	f6 c4 44	 test	 ah, 68			; 00000044H
  001e4	7b 4d		 jnp	 SHORT $LN29@V_DrawSmal

; 1303 : 		{
; 1304 : 			// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 1305 : 			// so center this imaginary screen
; 1306 : 			if (scrn & V_SNAPTORIGHT)

  001e6	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001e9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001ee	74 1a		 je	 SHORT $LN27@V_DrawSmal

; 1307 : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx));

  001f0	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  001fa	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00200	2b c8		 sub	 ecx, eax
  00202	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00205	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  00208	eb 29		 jmp	 SHORT $LN29@V_DrawSmal
$LN27@V_DrawSmal:

; 1308 : 			else if (!(scrn & V_SNAPTOLEFT))

  0020a	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0020d	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00212	75 1f		 jne	 SHORT $LN29@V_DrawSmal

; 1309 : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx)) / 2;

  00214	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  0021e	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00224	2b c8		 sub	 ecx, eax
  00226	8b c1		 mov	 eax, ecx
  00228	99		 cdq
  00229	2b c2		 sub	 eax, edx
  0022b	d1 f8		 sar	 eax, 1
  0022d	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00230	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN29@V_DrawSmal:

; 1310 : 		}
; 1311 : 		if (vid.fdupy != dupy)

  00233	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  00238	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  00240	0f 2e c8	 ucomiss xmm1, xmm0
  00243	9f		 lahf
  00244	f6 c4 44	 test	 ah, 68			; 00000044H
  00247	7b 5b		 jnp	 SHORT $LN33@V_DrawSmal

; 1312 : 		{
; 1313 : 			// same thing here
; 1314 : 			if (scrn & V_SNAPTOBOTTOM)

  00249	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0024c	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00251	74 21		 je	 SHORT $LN31@V_DrawSmal

; 1315 : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width;

  00253	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  0025d	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00263	2b c8		 sub	 ecx, eax
  00265	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0026c	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0026f	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  00272	eb 30		 jmp	 SHORT $LN33@V_DrawSmal
$LN31@V_DrawSmal:

; 1316 : 			else if (!(scrn & V_SNAPTOTOP))

  00274	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00277	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0027c	75 26		 jne	 SHORT $LN33@V_DrawSmal

; 1317 : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width / 2;

  0027e	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  00288	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  0028e	2b c8		 sub	 ecx, eax
  00290	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00297	8b c1		 mov	 eax, ecx
  00299	99		 cdq
  0029a	2b c2		 sub	 eax, edx
  0029c	d1 f8		 sar	 eax, 1
  0029e	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  002a1	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN33@V_DrawSmal:

; 1318 : 		}
; 1319 : 
; 1320 : 		// if it's meant to cover the whole screen, black out the rest
; 1321 : 		if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH*2 && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT*2)

  002a4	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  002a8	75 3e		 jne	 SHORT $LN34@V_DrawSmal
  002aa	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002ad	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002b0	81 f9 80 02 00
	00		 cmp	 ecx, 640		; 00000280H
  002b6	75 30		 jne	 SHORT $LN34@V_DrawSmal
  002b8	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  002bc	75 2a		 jne	 SHORT $LN34@V_DrawSmal
  002be	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002c1	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  002c5	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  002cb	75 1b		 jne	 SHORT $LN34@V_DrawSmal

; 1322 : 			V_DrawFill(0, 0, vid.width, vid.height, 31);

  002cd	6a 1f		 push	 31			; 0000001fH
  002cf	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  002d4	50		 push	 eax
  002d5	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  002db	51		 push	 ecx
  002dc	6a 00		 push	 0
  002de	6a 00		 push	 0
  002e0	e8 00 00 00 00	 call	 _V_DrawFill
  002e5	83 c4 14	 add	 esp, 20			; 00000014H
$LN34@V_DrawSmal:

; 1323 : 	}
; 1324 : 
; 1325 : 	if (skippixels)

  002e8	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  002ec	74 17		 je	 SHORT $LN35@V_DrawSmal

; 1326 : 		destend = desttop + SHORT(patch->width)/2 * dupx;

  002ee	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002f1	0f bf 00	 movsx	 eax, WORD PTR [eax]
  002f4	99		 cdq
  002f5	2b c2		 sub	 eax, edx
  002f7	d1 f8		 sar	 eax, 1
  002f9	0f af 45 f4	 imul	 eax, DWORD PTR _dupx$[ebp]
  002fd	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00300	89 45 d4	 mov	 DWORD PTR _destend$[ebp], eax
  00303	eb 10		 jmp	 SHORT $LN36@V_DrawSmal
$LN35@V_DrawSmal:

; 1327 : 	else
; 1328 : 		destend = desttop + SHORT(patch->width) * dupx;

  00305	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00308	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0030b	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  0030f	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00312	89 4d d4	 mov	 DWORD PTR _destend$[ebp], ecx
$LN36@V_DrawSmal:

; 1329 : 
; 1330 : 	for (col = 0; desttop < destend; col += colfrac, desttop++)

  00315	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  0031c	eb 12		 jmp	 SHORT $LN4@V_DrawSmal
$LN2@V_DrawSmal:
  0031e	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00321	03 45 e8	 add	 eax, DWORD PTR _colfrac$[ebp]
  00324	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  00327	8b 4d dc	 mov	 ecx, DWORD PTR _desttop$[ebp]
  0032a	83 c1 01	 add	 ecx, 1
  0032d	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawSmal:
  00330	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  00333	3b 45 d4	 cmp	 eax, DWORD PTR _destend$[ebp]
  00336	0f 83 c7 01 00
	00		 jae	 $LN3@V_DrawSmal

; 1331 : 	{
; 1332 : 		register INT32 heightmask;
; 1333 : 
; 1334 : 		column = (const column_t *)((const UINT8 *)(patch) + LONG(patch->columnofs[col>>FRACBITS]));

  0033c	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  0033f	c1 f8 10	 sar	 eax, 16			; 00000010H
  00342	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  00345	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  00348	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  0034c	89 55 e0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawSmal:

; 1335 : 
; 1336 : 		while (column->topdelta != 0xff)

  0034f	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00352	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00355	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0035b	0f 84 9d 01 00
	00		 je	 $LN6@V_DrawSmal

; 1337 : 		{
; 1338 : 			source = (const UINT8 *)(column) + 3;

  00361	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00364	83 c0 03	 add	 eax, 3
  00367	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 1339 : 			dest = desttop + column->topdelta*dupy*vid.width;

  0036a	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0036d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00370	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  00374	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0037b	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0037e	89 4d d8	 mov	 DWORD PTR _dest$[ebp], ecx

; 1340 : 			count = column->length*dupy;

  00381	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00384	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00388	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  0038c	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 1341 : 			skiprowcnt = 0;

  0038f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _skiprowcnt$[ebp], 0

; 1342 : 
; 1343 : 			ofs = 0;

  00396	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0

; 1344 : 
; 1345 : 			heightmask = column->length - 1;

  0039d	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003a0	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003a4	83 e9 01	 sub	 ecx, 1
  003a7	89 4d c0	 mov	 DWORD PTR _heightmask$1[ebp], ecx

; 1346 : 
; 1347 : 			if (column->length & heightmask)

  003aa	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003ad	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003b1	23 4d c0	 and	 ecx, DWORD PTR _heightmask$1[ebp]
  003b4	0f 84 bc 00 00
	00		 je	 $LN37@V_DrawSmal

; 1348 : 			{
; 1349 : 				heightmask++;

  003ba	8b 45 c0	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003bd	83 c0 01	 add	 eax, 1
  003c0	89 45 c0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 1350 : 				heightmask <<= FRACBITS;

  003c3	8b 45 c0	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003c6	c1 e0 10	 shl	 eax, 16			; 00000010H
  003c9	89 45 c0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 1351 : 
; 1352 : 				if (rowfrac < 0)

  003cc	83 7d e4 00	 cmp	 DWORD PTR _rowfrac$[ebp], 0
  003d0	7d 0f		 jge	 SHORT $LN39@V_DrawSmal
$LN7@V_DrawSmal:

; 1353 : 					while ((rowfrac += heightmask) < 0)

  003d2	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003d5	03 45 c0	 add	 eax, DWORD PTR _heightmask$1[ebp]
  003d8	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  003db	79 02		 jns	 SHORT $LN8@V_DrawSmal

; 1354 : 						;

  003dd	eb f3		 jmp	 SHORT $LN7@V_DrawSmal
$LN8@V_DrawSmal:
  003df	eb 13		 jmp	 SHORT $LN10@V_DrawSmal
$LN39@V_DrawSmal:

; 1355 : 				else
; 1356 : 					while (rowfrac >= heightmask)

  003e1	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003e4	3b 45 c0	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  003e7	7c 0b		 jl	 SHORT $LN10@V_DrawSmal

; 1357 : 						rowfrac -= heightmask;

  003e9	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003ec	2b 45 c0	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  003ef	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  003f2	eb ed		 jmp	 SHORT $LN39@V_DrawSmal
$LN10@V_DrawSmal:

; 1358 : 
; 1359 : 				do
; 1360 : 				{
; 1361 : 					if (dest < deststop)

  003f4	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  003f7	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  003fa	73 1a		 jae	 SHORT $LN41@V_DrawSmal

; 1362 : 						*dest = *(colormap + source[ofs>>FRACBITS]);

  003fc	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  003ff	c1 f8 10	 sar	 eax, 16			; 00000010H
  00402	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  00405	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00409	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0040c	8b 4d 18	 mov	 ecx, DWORD PTR _colormap$[ebp]
  0040f	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00412	88 10		 mov	 BYTE PTR [eax], dl
  00414	eb 07		 jmp	 SHORT $LN42@V_DrawSmal
$LN41@V_DrawSmal:

; 1363 : 					else
; 1364 : 						count = 0;

  00416	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN42@V_DrawSmal:

; 1365 : 
; 1366 : 					if (!(skippixels && (skiprowcnt & 1)))

  0041d	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  00421	74 08		 je	 SHORT $LN44@V_DrawSmal
  00423	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00426	83 e0 01	 and	 eax, 1
  00429	75 0c		 jne	 SHORT $LN43@V_DrawSmal
$LN44@V_DrawSmal:

; 1367 : 						dest += vid.width;

  0042b	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0042e	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00434	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN43@V_DrawSmal:

; 1368 : 
; 1369 : 					ofs += rowfrac;

  00437	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  0043a	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  0043d	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 1370 : 					if ((ofs + rowfrac) > heightmask)

  00440	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00443	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00446	3b 45 c0	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  00449	7e 05		 jle	 SHORT $LN45@V_DrawSmal

; 1371 : 						goto donesmallmapping;

  0044b	e9 98 00 00 00	 jmp	 $donesmallmapping$51
$LN45@V_DrawSmal:

; 1372 : 
; 1373 : 					skiprowcnt++;

  00450	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00453	83 c0 01	 add	 eax, 1
  00456	89 45 c4	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 1374 : 				} while (count--);

  00459	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0045c	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv263[ebp], eax
  00462	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00465	83 e9 01	 sub	 ecx, 1
  00468	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  0046b	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv263[ebp], 0
  00472	75 80		 jne	 SHORT $LN10@V_DrawSmal

; 1375 : 			}

  00474	eb 72		 jmp	 SHORT $donesmallmapping$51
$LN37@V_DrawSmal:

; 1376 : 			else
; 1377 : 			{
; 1378 : 				while (count--)

  00476	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00479	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv266[ebp], eax
  0047f	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00482	83 e9 01	 sub	 ecx, 1
  00485	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00488	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv266[ebp], 0
  0048f	74 57		 je	 SHORT $donesmallmapping$51

; 1379 : 				{
; 1380 : 					if (dest < deststop)

  00491	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00494	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00497	73 1a		 jae	 SHORT $LN46@V_DrawSmal

; 1381 : 						*dest = *(colormap + source[ofs>>FRACBITS]);

  00499	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  0049c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0049f	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  004a2	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004a6	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  004a9	8b 4d 18	 mov	 ecx, DWORD PTR _colormap$[ebp]
  004ac	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  004af	88 10		 mov	 BYTE PTR [eax], dl
  004b1	eb 07		 jmp	 SHORT $LN47@V_DrawSmal
$LN46@V_DrawSmal:

; 1382 : 					else
; 1383 : 						count = 0;

  004b3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN47@V_DrawSmal:

; 1384 : 
; 1385 : 					if (!(skippixels && (skiprowcnt & 1)))

  004ba	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  004be	74 08		 je	 SHORT $LN49@V_DrawSmal
  004c0	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  004c3	83 e0 01	 and	 eax, 1
  004c6	75 0c		 jne	 SHORT $LN48@V_DrawSmal
$LN49@V_DrawSmal:

; 1386 : 						dest += vid.width;

  004c8	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  004cb	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  004d1	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN48@V_DrawSmal:

; 1387 : 
; 1388 : 					ofs += rowfrac;

  004d4	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  004d7	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  004da	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 1389 : 					skiprowcnt++;

  004dd	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  004e0	83 c0 01	 add	 eax, 1
  004e3	89 45 c4	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 1390 : 				}

  004e6	eb 8e		 jmp	 SHORT $LN37@V_DrawSmal
$donesmallmapping$51:

; 1391 : 			}
; 1392 : donesmallmapping:
; 1393 : 
; 1394 : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  004e8	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  004eb	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  004ef	8b 55 e0	 mov	 edx, DWORD PTR _column$[ebp]
  004f2	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  004f6	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 1395 : 		}

  004f9	e9 51 fe ff ff	 jmp	 $LN5@V_DrawSmal
$LN6@V_DrawSmal:

; 1396 : 	}

  004fe	e9 1b fe ff ff	 jmp	 $LN2@V_DrawSmal
$LN3@V_DrawSmal:

; 1397 : }

  00503	5f		 pop	 edi
  00504	5e		 pop	 esi
  00505	5b		 pop	 ebx
  00506	8b e5		 mov	 esp, ebp
  00508	5d		 pop	 ebp
  00509	c3		 ret	 0
_V_DrawSmallMappedPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawSmallScaledPatch
_TEXT	SEGMENT
tv261 = -132						; size = 4
tv264 = -132						; size = 4
_heightmask$1 = -64					; size = 4
_skiprowcnt$ = -60					; size = 4
_skippixels$ = -56					; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_destend$ = -44						; size = 4
_dest$ = -40						; size = 4
_desttop$ = -36						; size = 4
_column$ = -32						; size = 4
_rowfrac$ = -28						; size = 4
_colfrac$ = -24						; size = 4
_ofs$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_V_DrawSmallScaledPatch PROC				; COMDAT

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 761  : 	size_t count;
; 762  : 	INT32 col, dupx, dupy, ofs, colfrac, rowfrac;
; 763  : 	const column_t *column;
; 764  : 	UINT8 *desttop, *dest, *destend;
; 765  : 	const UINT8 *source, *deststop;
; 766  : 	boolean skippixels = false;

  0000c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 0

; 767  : 	INT32 skiprowcnt;
; 768  : 
; 769  : #ifdef HWRENDER
; 770  : 	// draw a hardware converted patch
; 771  : 	if (rendermode != render_soft && rendermode != render_none)

  00013	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0001a	74 69		 je	 SHORT $LN16@V_DrawSmal
  0001c	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00023	74 60		 je	 SHORT $LN16@V_DrawSmal

; 772  : 	{
; 773  : 		if (!(scrn & V_NOSCALESTART)) // Graue 07-08-2004: I have no idea why this works

  00025	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00028	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0002d	75 33		 jne	 SHORT $LN17@V_DrawSmal

; 774  : 		{
; 775  : 			x = (INT32)(vid.fdupx*x);

  0002f	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  00034	f3 0f 59 05 28
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+40
  0003c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00040	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 776  : 			y = (INT32)(vid.fdupy*y);

  00043	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  00048	f3 0f 59 05 2c
	00 00 00	 mulss	 xmm0, DWORD PTR _vid+44
  00050	f3 0f 2c c0	 cvttss2si eax, xmm0
  00054	89 45 0c	 mov	 DWORD PTR _y$[ebp], eax

; 777  : 			scrn |= V_NOSCALESTART;

  00057	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0005a	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  0005f	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax
$LN17@V_DrawSmal:

; 778  : 		}
; 779  : 		HWR_DrawSmallPatch((GLPatch_t *)patch, x, y, scrn, colormaps);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR _colormaps
  00067	50		 push	 eax
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006f	52		 push	 edx
  00070	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _HWR_DrawSmallPatch
  0007d	83 c4 14	 add	 esp, 20			; 00000014H

; 780  : 		return;

  00080	e9 72 04 00 00	 jmp	 $LN3@V_DrawSmal
$LN16@V_DrawSmal:

; 781  : 	}
; 782  : #endif
; 783  : 
; 784  : 	if (vid.dupx > 1 && vid.dupy > 1)

  00085	83 3d 20 00 00
	00 01		 cmp	 DWORD PTR _vid+32, 1
  0008c	7e 25		 jle	 SHORT $LN18@V_DrawSmal
  0008e	83 3d 24 00 00
	00 01		 cmp	 DWORD PTR _vid+36, 1
  00095	7e 1c		 jle	 SHORT $LN18@V_DrawSmal

; 785  : 	{
; 786  : 		dupx = vid.dupx / 2;

  00097	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  0009c	99		 cdq
  0009d	2b c2		 sub	 eax, edx
  0009f	d1 f8		 sar	 eax, 1
  000a1	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 787  : 		dupy = vid.dupy / 2;

  000a4	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  000a9	99		 cdq
  000aa	2b c2		 sub	 eax, edx
  000ac	d1 f8		 sar	 eax, 1
  000ae	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax

; 788  : 	}

  000b1	eb 14		 jmp	 SHORT $LN19@V_DrawSmal
$LN18@V_DrawSmal:

; 789  : 	else
; 790  : 	{
; 791  : 		dupx = dupy = 1;

  000b3	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  000ba	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  000bd	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 792  : 		skippixels = true;

  000c0	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _skippixels$[ebp], 1
$LN19@V_DrawSmal:

; 793  : 	}
; 794  : 
; 795  : 	y -= SHORT(patch->topoffset);

  000c7	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000ca	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000ce	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  000d1	2b d1		 sub	 edx, ecx
  000d3	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 796  : 	x -= SHORT(patch->leftoffset);

  000d6	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  000d9	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  000dd	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000e0	2b d1		 sub	 edx, ecx
  000e2	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 797  : 
; 798  : 	if (skippixels)

  000e5	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  000e9	74 19		 je	 SHORT $LN20@V_DrawSmal

; 799  : 		colfrac = FixedDiv(FRACUNIT, (dupx)<<(FRACBITS-1));

  000eb	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  000ee	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  000f1	50		 push	 eax
  000f2	68 00 00 01 00	 push	 65536			; 00010000H
  000f7	e8 00 00 00 00	 call	 _FixedDiv
  000fc	83 c4 08	 add	 esp, 8
  000ff	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
  00102	eb 17		 jmp	 SHORT $LN21@V_DrawSmal
$LN20@V_DrawSmal:

; 800  : 	else
; 801  : 		colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  00104	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  00107	c1 e0 10	 shl	 eax, 16			; 00000010H
  0010a	50		 push	 eax
  0010b	68 00 00 01 00	 push	 65536			; 00010000H
  00110	e8 00 00 00 00	 call	 _FixedDiv
  00115	83 c4 08	 add	 esp, 8
  00118	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax
$LN21@V_DrawSmal:

; 802  : 
; 803  : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  0011b	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  0011e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00121	50		 push	 eax
  00122	68 00 00 01 00	 push	 65536			; 00010000H
  00127	e8 00 00 00 00	 call	 _FixedDiv
  0012c	83 c4 08	 add	 esp, 8
  0012f	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 804  : 
; 805  : 	if (scrn & V_NOSCALESTART)

  00132	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00135	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0013a	74 23		 je	 SHORT $LN22@V_DrawSmal

; 806  : 		desttop = screens[scrn&0xFF] + (y * vid.width) + x;

  0013c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0013f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00144	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00147	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0014e	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  00155	03 d1		 add	 edx, ecx
  00157	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  0015a	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
  0015d	eb 31		 jmp	 SHORT $LN23@V_DrawSmal
$LN22@V_DrawSmal:

; 807  : 	else
; 808  : 		desttop = screens[scrn&0xFF] + (y * vid.dupy * vid.width) + (x * vid.dupx);

  0015f	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00162	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00167	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0016a	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  00171	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00178	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  0017f	03 d1		 add	 edx, ecx
  00181	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00184	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  0018b	03 d0		 add	 edx, eax
  0018d	89 55 dc	 mov	 DWORD PTR _desttop$[ebp], edx
$LN23@V_DrawSmal:

; 809  : 
; 810  : 	deststop = screens[scrn&0xFF] + vid.width * vid.height * vid.bpp;

  00190	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00193	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00198	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0019e	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  001a5	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  001ac	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  001b3	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 811  : 
; 812  : 	if (!desttop)

  001b6	83 7d dc 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  001ba	75 05		 jne	 SHORT $LN24@V_DrawSmal

; 813  : 		return;

  001bc	e9 36 03 00 00	 jmp	 $LN3@V_DrawSmal
$LN24@V_DrawSmal:

; 814  : 
; 815  : 	if (!(scrn & V_NOSCALESTART))

  001c1	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001c4	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001c9	0f 85 1b 01 00
	00		 jne	 $LN34@V_DrawSmal

; 816  : 	{
; 817  : 		/// \bug yeah... the Y still seems to be off a few lines...
; 818  : 		/// see rankings in 640x480 or 800x600
; 819  : 		if (vid.fdupx != vid.dupx)

  001cf	f3 0f 2a 05 20
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _vid+32
  001d7	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  001df	0f 2e c8	 ucomiss xmm1, xmm0
  001e2	9f		 lahf
  001e3	f6 c4 44	 test	 ah, 68			; 00000044H
  001e6	7b 4d		 jnp	 SHORT $LN29@V_DrawSmal

; 820  : 		{
; 821  : 			// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 822  : 			// so center this imaginary screen
; 823  : 			if (scrn & V_SNAPTORIGHT)

  001e8	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001eb	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001f0	74 1a		 je	 SHORT $LN27@V_DrawSmal

; 824  : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx));

  001f2	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  001fc	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00202	2b c8		 sub	 ecx, eax
  00204	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00207	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  0020a	eb 29		 jmp	 SHORT $LN29@V_DrawSmal
$LN27@V_DrawSmal:

; 825  : 			else if (!(scrn & V_SNAPTOLEFT))

  0020c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0020f	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00214	75 1f		 jne	 SHORT $LN29@V_DrawSmal

; 826  : 				desttop += (vid.width - (BASEVIDWIDTH * vid.dupx)) / 2;

  00216	69 05 20 00 00
	00 40 01 00 00	 imul	 eax, DWORD PTR _vid+32, 320
  00220	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00226	2b c8		 sub	 ecx, eax
  00228	8b c1		 mov	 eax, ecx
  0022a	99		 cdq
  0022b	2b c2		 sub	 eax, edx
  0022d	d1 f8		 sar	 eax, 1
  0022f	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00232	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN29@V_DrawSmal:

; 827  : 		}
; 828  : 		if (vid.fdupy != dupy)

  00235	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  0023a	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  00242	0f 2e c8	 ucomiss xmm1, xmm0
  00245	9f		 lahf
  00246	f6 c4 44	 test	 ah, 68			; 00000044H
  00249	7b 5b		 jnp	 SHORT $LN33@V_DrawSmal

; 829  : 		{
; 830  : 			// same thing here
; 831  : 			if (scrn & V_SNAPTOBOTTOM)

  0024b	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0024e	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00253	74 21		 je	 SHORT $LN31@V_DrawSmal

; 832  : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width;

  00255	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  0025f	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00265	2b c8		 sub	 ecx, eax
  00267	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0026e	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00271	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  00274	eb 30		 jmp	 SHORT $LN33@V_DrawSmal
$LN31@V_DrawSmal:

; 833  : 			else if (!(scrn & V_SNAPTOTOP))

  00276	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00279	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0027e	75 26		 jne	 SHORT $LN33@V_DrawSmal

; 834  : 				desttop += (vid.height - (BASEVIDHEIGHT * vid.dupy)) * vid.width / 2;

  00280	69 05 24 00 00
	00 c8 00 00 00	 imul	 eax, DWORD PTR _vid+36, 200
  0028a	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  00290	2b c8		 sub	 ecx, eax
  00292	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  00299	8b c1		 mov	 eax, ecx
  0029b	99		 cdq
  0029c	2b c2		 sub	 eax, edx
  0029e	d1 f8		 sar	 eax, 1
  002a0	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  002a3	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN33@V_DrawSmal:

; 835  : 		}
; 836  : 
; 837  : 		// if it's meant to cover the whole screen, black out the rest
; 838  : 		if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH*2 && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT*2)

  002a6	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  002aa	75 3e		 jne	 SHORT $LN34@V_DrawSmal
  002ac	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002af	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  002b2	81 f9 80 02 00
	00		 cmp	 ecx, 640		; 00000280H
  002b8	75 30		 jne	 SHORT $LN34@V_DrawSmal
  002ba	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  002be	75 2a		 jne	 SHORT $LN34@V_DrawSmal
  002c0	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002c3	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  002c7	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  002cd	75 1b		 jne	 SHORT $LN34@V_DrawSmal

; 839  : 			V_DrawFill(0, 0, vid.width, vid.height, 31);

  002cf	6a 1f		 push	 31			; 0000001fH
  002d1	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  002d6	50		 push	 eax
  002d7	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  002dd	51		 push	 ecx
  002de	6a 00		 push	 0
  002e0	6a 00		 push	 0
  002e2	e8 00 00 00 00	 call	 _V_DrawFill
  002e7	83 c4 14	 add	 esp, 20			; 00000014H
$LN34@V_DrawSmal:

; 840  : 	}
; 841  : 
; 842  : 	if (skippixels)

  002ea	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  002ee	74 17		 je	 SHORT $LN35@V_DrawSmal

; 843  : 		destend = desttop + SHORT(patch->width)/2 * dupx;

  002f0	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  002f3	0f bf 00	 movsx	 eax, WORD PTR [eax]
  002f6	99		 cdq
  002f7	2b c2		 sub	 eax, edx
  002f9	d1 f8		 sar	 eax, 1
  002fb	0f af 45 f4	 imul	 eax, DWORD PTR _dupx$[ebp]
  002ff	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00302	89 45 d4	 mov	 DWORD PTR _destend$[ebp], eax
  00305	eb 10		 jmp	 SHORT $LN36@V_DrawSmal
$LN35@V_DrawSmal:

; 844  : 	else
; 845  : 		destend = desttop + SHORT(patch->width) * dupx;

  00307	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0030a	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0030d	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00311	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00314	89 4d d4	 mov	 DWORD PTR _destend$[ebp], ecx
$LN36@V_DrawSmal:

; 846  : 
; 847  : 	for (col = 0; desttop < destend; col += colfrac, desttop++)

  00317	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  0031e	eb 12		 jmp	 SHORT $LN4@V_DrawSmal
$LN2@V_DrawSmal:
  00320	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00323	03 45 e8	 add	 eax, DWORD PTR _colfrac$[ebp]
  00326	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  00329	8b 4d dc	 mov	 ecx, DWORD PTR _desttop$[ebp]
  0032c	83 c1 01	 add	 ecx, 1
  0032f	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawSmal:
  00332	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  00335	3b 45 d4	 cmp	 eax, DWORD PTR _destend$[ebp]
  00338	0f 83 b9 01 00
	00		 jae	 $LN3@V_DrawSmal

; 848  : 	{
; 849  : 		register INT32 heightmask;
; 850  : 
; 851  : 		column = (const column_t *)((const UINT8 *)(patch) + LONG(patch->columnofs[col>>FRACBITS]));

  0033e	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00341	c1 f8 10	 sar	 eax, 16			; 00000010H
  00344	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  00347	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  0034a	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  0034e	89 55 e0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawSmal:

; 852  : 
; 853  : 		while (column->topdelta != 0xff)

  00351	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00354	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00357	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0035d	0f 84 8f 01 00
	00		 je	 $LN6@V_DrawSmal

; 854  : 		{
; 855  : 			source = (const UINT8 *)(column) + 3;

  00363	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00366	83 c0 03	 add	 eax, 3
  00369	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 856  : 			dest = desttop + column->topdelta*dupy*vid.width;

  0036c	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  0036f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00372	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  00376	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0037d	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00380	89 4d d8	 mov	 DWORD PTR _dest$[ebp], ecx

; 857  : 			count = column->length*dupy;

  00383	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00386	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0038a	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  0038e	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 858  : 			skiprowcnt = 0;

  00391	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _skiprowcnt$[ebp], 0

; 859  : 
; 860  : 			ofs = 0;

  00398	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0

; 861  : 
; 862  : 			heightmask = column->length - 1;

  0039f	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003a2	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003a6	83 e9 01	 sub	 ecx, 1
  003a9	89 4d c0	 mov	 DWORD PTR _heightmask$1[ebp], ecx

; 863  : 
; 864  : 			if (column->length & heightmask)

  003ac	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003af	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003b3	23 4d c0	 and	 ecx, DWORD PTR _heightmask$1[ebp]
  003b6	0f 84 b5 00 00
	00		 je	 $LN37@V_DrawSmal

; 865  : 			{
; 866  : 				heightmask++;

  003bc	8b 45 c0	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003bf	83 c0 01	 add	 eax, 1
  003c2	89 45 c0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 867  : 				heightmask <<= FRACBITS;

  003c5	8b 45 c0	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  003c8	c1 e0 10	 shl	 eax, 16			; 00000010H
  003cb	89 45 c0	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 868  : 
; 869  : 				if (rowfrac < 0)

  003ce	83 7d e4 00	 cmp	 DWORD PTR _rowfrac$[ebp], 0
  003d2	7d 0f		 jge	 SHORT $LN39@V_DrawSmal
$LN7@V_DrawSmal:

; 870  : 					while ((rowfrac += heightmask) < 0)

  003d4	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003d7	03 45 c0	 add	 eax, DWORD PTR _heightmask$1[ebp]
  003da	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  003dd	79 02		 jns	 SHORT $LN8@V_DrawSmal

; 871  : 						;

  003df	eb f3		 jmp	 SHORT $LN7@V_DrawSmal
$LN8@V_DrawSmal:
  003e1	eb 13		 jmp	 SHORT $LN10@V_DrawSmal
$LN39@V_DrawSmal:

; 872  : 				else
; 873  : 					while (rowfrac >= heightmask)

  003e3	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003e6	3b 45 c0	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  003e9	7c 0b		 jl	 SHORT $LN10@V_DrawSmal

; 874  : 						rowfrac -= heightmask;

  003eb	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  003ee	2b 45 c0	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  003f1	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  003f4	eb ed		 jmp	 SHORT $LN39@V_DrawSmal
$LN10@V_DrawSmal:

; 875  : 
; 876  : 				do
; 877  : 				{
; 878  : 					if (dest < deststop)

  003f6	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  003f9	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  003fc	73 13		 jae	 SHORT $LN41@V_DrawSmal

; 879  : 						*dest = source[ofs>>FRACBITS];

  003fe	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00401	c1 f8 10	 sar	 eax, 16			; 00000010H
  00404	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00407	8b 55 d0	 mov	 edx, DWORD PTR _source$[ebp]
  0040a	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0040d	88 01		 mov	 BYTE PTR [ecx], al
  0040f	eb 07		 jmp	 SHORT $LN42@V_DrawSmal
$LN41@V_DrawSmal:

; 880  : 					else
; 881  : 						count = 0;

  00411	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN42@V_DrawSmal:

; 882  : 
; 883  : 					if (!(skippixels && (skiprowcnt & 1)))

  00418	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  0041c	74 08		 je	 SHORT $LN44@V_DrawSmal
  0041e	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  00421	83 e0 01	 and	 eax, 1
  00424	75 0c		 jne	 SHORT $LN43@V_DrawSmal
$LN44@V_DrawSmal:

; 884  : 						dest += vid.width;

  00426	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00429	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0042f	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN43@V_DrawSmal:

; 885  : 
; 886  : 					ofs += rowfrac;

  00432	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00435	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00438	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 887  : 					if ((ofs + rowfrac) > heightmask)

  0043b	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  0043e	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00441	3b 45 c0	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  00444	7e 05		 jle	 SHORT $LN45@V_DrawSmal

; 888  : 						goto donesmalling;

  00446	e9 91 00 00 00	 jmp	 $donesmalling$51
$LN45@V_DrawSmal:

; 889  : 
; 890  : 					skiprowcnt++;

  0044b	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  0044e	83 c0 01	 add	 eax, 1
  00451	89 45 c4	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 891  : 				} while (count--);

  00454	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00457	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv261[ebp], eax
  0045d	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00460	83 e9 01	 sub	 ecx, 1
  00463	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00466	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv261[ebp], 0
  0046d	75 87		 jne	 SHORT $LN10@V_DrawSmal

; 892  : 			}

  0046f	eb 6b		 jmp	 SHORT $donesmalling$51
$LN37@V_DrawSmal:

; 893  : 			else
; 894  : 			{
; 895  : 				while (count--)

  00471	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00474	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv264[ebp], eax
  0047a	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0047d	83 e9 01	 sub	 ecx, 1
  00480	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00483	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv264[ebp], 0
  0048a	74 50		 je	 SHORT $donesmalling$51

; 896  : 				{
; 897  : 					if (dest < deststop)

  0048c	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  0048f	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00492	73 13		 jae	 SHORT $LN46@V_DrawSmal

; 898  : 						*dest = source[ofs>>FRACBITS];

  00494	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00497	c1 f8 10	 sar	 eax, 16			; 00000010H
  0049a	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  0049d	8b 55 d0	 mov	 edx, DWORD PTR _source$[ebp]
  004a0	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  004a3	88 01		 mov	 BYTE PTR [ecx], al
  004a5	eb 07		 jmp	 SHORT $LN47@V_DrawSmal
$LN46@V_DrawSmal:

; 899  : 					else
; 900  : 						count = 0;

  004a7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN47@V_DrawSmal:

; 901  : 
; 902  : 					if (!(skippixels && (skiprowcnt & 1)))

  004ae	83 7d c8 00	 cmp	 DWORD PTR _skippixels$[ebp], 0
  004b2	74 08		 je	 SHORT $LN49@V_DrawSmal
  004b4	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  004b7	83 e0 01	 and	 eax, 1
  004ba	75 0c		 jne	 SHORT $LN48@V_DrawSmal
$LN49@V_DrawSmal:

; 903  : 						dest += vid.width;

  004bc	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  004bf	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  004c5	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax
$LN48@V_DrawSmal:

; 904  : 
; 905  : 					ofs += rowfrac;

  004c8	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  004cb	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  004ce	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 906  : 					skiprowcnt++;

  004d1	8b 45 c4	 mov	 eax, DWORD PTR _skiprowcnt$[ebp]
  004d4	83 c0 01	 add	 eax, 1
  004d7	89 45 c4	 mov	 DWORD PTR _skiprowcnt$[ebp], eax

; 907  : 				}

  004da	eb 95		 jmp	 SHORT $LN37@V_DrawSmal
$donesmalling$51:

; 908  : 			}
; 909  : donesmalling:
; 910  : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  004dc	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  004df	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  004e3	8b 55 e0	 mov	 edx, DWORD PTR _column$[ebp]
  004e6	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  004ea	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 911  : 		}

  004ed	e9 5f fe ff ff	 jmp	 $LN5@V_DrawSmal
$LN6@V_DrawSmal:

; 912  : 	}

  004f2	e9 29 fe ff ff	 jmp	 $LN2@V_DrawSmal
$LN3@V_DrawSmal:

; 913  : }

  004f7	5f		 pop	 edi
  004f8	5e		 pop	 esi
  004f9	5b		 pop	 ebx
  004fa	8b e5		 mov	 esp, ebp
  004fc	5d		 pop	 ebp
  004fd	c3		 ret	 0
_V_DrawSmallScaledPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawScaledPatch
_TEXT	SEGMENT
tv229 = -124						; size = 4
tv232 = -124						; size = 4
_heightmask$1 = -56					; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_destend$ = -44						; size = 4
_dest$ = -40						; size = 4
_desttop$ = -36						; size = 4
_column$ = -32						; size = 4
_rowfrac$ = -28						; size = 4
_colfrac$ = -24						; size = 4
_ofs$ = -20						; size = 4
_dupy$ = -16						; size = 4
_dupx$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_V_DrawScaledPatch PROC					; COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 504  : 	size_t count;
; 505  : 	INT32 col, dupx, dupy, ofs, colfrac, rowfrac;
; 506  : 	const column_t *column;
; 507  : 	UINT8 *desttop, *dest, *destend;
; 508  : 	const UINT8 *source, *deststop;
; 509  : 
; 510  : #ifdef HWRENDER
; 511  : 	// draw a hardware converted patch
; 512  : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 26		 je	 SHORT $LN16@V_DrawScal
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 1d		 je	 SHORT $LN16@V_DrawScal

; 513  : 	{
; 514  : 		HWR_DrawPatch((GLPatch_t *)patch, x, y, scrn);

  0001b	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00026	52		 push	 edx
  00027	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _HWR_DrawPatch
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 515  : 		return;

  00033	e9 bd 03 00 00	 jmp	 $LN3@V_DrawScal
$LN16@V_DrawScal:

; 516  : 	}
; 517  : #endif
; 518  : 
; 519  : 	if ((scrn & V_NOSCALEPATCH))

  00038	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0003b	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00040	74 0f		 je	 SHORT $LN17@V_DrawScal

; 520  : 		dupx = dupy = 1;

  00042	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  00049	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  0004c	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax
  0004f	eb 10		 jmp	 SHORT $LN18@V_DrawScal
$LN17@V_DrawScal:

; 521  : 	else
; 522  : 	{
; 523  : 		dupx = vid.dupx;

  00051	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  00056	89 45 f4	 mov	 DWORD PTR _dupx$[ebp], eax

; 524  : 		dupy = vid.dupy;

  00059	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  0005e	89 45 f0	 mov	 DWORD PTR _dupy$[ebp], eax
$LN18@V_DrawScal:

; 525  : 	}
; 526  : 
; 527  : 	y -= SHORT(patch->topoffset);

  00061	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00064	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00068	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006b	2b d1		 sub	 edx, ecx
  0006d	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 528  : 	x -= SHORT(patch->leftoffset);

  00070	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00073	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00077	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0007a	2b d1		 sub	 edx, ecx
  0007c	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 529  : 
; 530  : 	colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  0007f	8b 45 f4	 mov	 eax, DWORD PTR _dupx$[ebp]
  00082	c1 e0 10	 shl	 eax, 16			; 00000010H
  00085	50		 push	 eax
  00086	68 00 00 01 00	 push	 65536			; 00010000H
  0008b	e8 00 00 00 00	 call	 _FixedDiv
  00090	83 c4 08	 add	 esp, 8
  00093	89 45 e8	 mov	 DWORD PTR _colfrac$[ebp], eax

; 531  : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  00096	8b 45 f0	 mov	 eax, DWORD PTR _dupy$[ebp]
  00099	c1 e0 10	 shl	 eax, 16			; 00000010H
  0009c	50		 push	 eax
  0009d	68 00 00 01 00	 push	 65536			; 00010000H
  000a2	e8 00 00 00 00	 call	 _FixedDiv
  000a7	83 c4 08	 add	 esp, 8
  000aa	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 532  : 
; 533  : 	desttop = screens[scrn&0xFF];

  000ad	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000b0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _screens[eax*4]
  000bc	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx

; 534  : 	deststop = screens[scrn&0xFF] + vid.width * vid.height * vid.bpp;

  000bf	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000c2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c7	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  000cd	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  000d4	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  000db	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  000e2	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 535  : 
; 536  : 	if (!desttop)

  000e5	83 7d dc 00	 cmp	 DWORD PTR _desttop$[ebp], 0
  000e9	75 05		 jne	 SHORT $LN19@V_DrawScal

; 537  : 		return;

  000eb	e9 05 03 00 00	 jmp	 $LN3@V_DrawScal
$LN19@V_DrawScal:

; 538  : 
; 539  : 	if (scrn & V_NOSCALESTART)

  000f0	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000f3	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  000f8	74 18		 je	 SHORT $LN20@V_DrawScal

; 540  : 		desttop += (y*vid.width) + x;

  000fa	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000fd	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00104	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  00107	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  0010a	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
  0010d	e9 37 01 00 00	 jmp	 $LN31@V_DrawScal
$LN20@V_DrawScal:

; 541  : 	else
; 542  : 	{
; 543  : 		desttop += (y*dupy*vid.width) + (x*dupx);

  00112	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00115	0f af 45 f0	 imul	 eax, DWORD PTR _dupy$[ebp]
  00119	0f af 05 0c 00
	00 00		 imul	 eax, DWORD PTR _vid+12
  00120	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00123	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00127	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0012a	03 c8		 add	 ecx, eax
  0012c	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx

; 544  : 
; 545  : 		// Center it if necessary
; 546  : 		if (!(scrn & V_NOSCALEPATCH))

  0012f	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00132	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00137	0f 85 0c 01 00
	00		 jne	 $LN31@V_DrawScal

; 547  : 		{
; 548  : 			if (vid.fdupx != dupx)

  0013d	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _dupx$[ebp]
  00142	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  0014a	0f 2e c8	 ucomiss xmm1, xmm0
  0014d	9f		 lahf
  0014e	f6 c4 44	 test	 ah, 68			; 00000044H
  00151	7b 47		 jnp	 SHORT $LN26@V_DrawScal

; 549  : 			{
; 550  : 				// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 551  : 				// so center this imaginary screen
; 552  : 				if (scrn & V_SNAPTORIGHT)

  00153	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00156	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0015b	74 17		 je	 SHORT $LN24@V_DrawScal

; 553  : 					desttop += (vid.width - (BASEVIDWIDTH * dupx));

  0015d	69 45 f4 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00164	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0016a	2b c8		 sub	 ecx, eax
  0016c	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  0016f	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  00172	eb 26		 jmp	 SHORT $LN26@V_DrawScal
$LN24@V_DrawScal:

; 554  : 				else if (!(scrn & V_SNAPTOLEFT))

  00174	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00177	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0017c	75 1c		 jne	 SHORT $LN26@V_DrawScal

; 555  : 					desttop += (vid.width - (BASEVIDWIDTH * dupx)) / 2;

  0017e	69 45 f4 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00185	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0018b	2b c8		 sub	 ecx, eax
  0018d	8b c1		 mov	 eax, ecx
  0018f	99		 cdq
  00190	2b c2		 sub	 eax, edx
  00192	d1 f8		 sar	 eax, 1
  00194	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00197	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN26@V_DrawScal:

; 556  : 			}
; 557  : 			if (vid.fdupy != dupy)

  0019a	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  0019f	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  001a7	0f 2e c8	 ucomiss xmm1, xmm0
  001aa	9f		 lahf
  001ab	f6 c4 44	 test	 ah, 68			; 00000044H
  001ae	7b 55		 jnp	 SHORT $LN30@V_DrawScal

; 558  : 			{
; 559  : 				// same thing here
; 560  : 				if (scrn & V_SNAPTOBOTTOM)

  001b0	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001b3	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001b8	74 1e		 je	 SHORT $LN28@V_DrawScal

; 561  : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width;

  001ba	69 45 f0 c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001c1	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001c7	2b c8		 sub	 ecx, eax
  001c9	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001d0	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  001d3	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
  001d6	eb 2d		 jmp	 SHORT $LN30@V_DrawScal
$LN28@V_DrawScal:

; 562  : 				else if (!(scrn & V_SNAPTOTOP))

  001d8	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001db	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  001e0	75 23		 jne	 SHORT $LN30@V_DrawScal

; 563  : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width / 2;

  001e2	69 45 f0 c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001e9	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001ef	2b c8		 sub	 ecx, eax
  001f1	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001f8	8b c1		 mov	 eax, ecx
  001fa	99		 cdq
  001fb	2b c2		 sub	 eax, edx
  001fd	d1 f8		 sar	 eax, 1
  001ff	03 45 dc	 add	 eax, DWORD PTR _desttop$[ebp]
  00202	89 45 dc	 mov	 DWORD PTR _desttop$[ebp], eax
$LN30@V_DrawScal:

; 564  : 			}
; 565  : 			// if it's meant to cover the whole screen, black out the rest
; 566  : 			if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT)

  00205	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00209	75 3e		 jne	 SHORT $LN31@V_DrawScal
  0020b	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0020e	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00211	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00217	75 30		 jne	 SHORT $LN31@V_DrawScal
  00219	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0021d	75 2a		 jne	 SHORT $LN31@V_DrawScal
  0021f	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00222	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00226	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  0022c	75 1b		 jne	 SHORT $LN31@V_DrawScal

; 567  : 				V_DrawFill(0, 0, vid.width, vid.height, 31);

  0022e	6a 1f		 push	 31			; 0000001fH
  00230	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00235	50		 push	 eax
  00236	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0023c	51		 push	 ecx
  0023d	6a 00		 push	 0
  0023f	6a 00		 push	 0
  00241	e8 00 00 00 00	 call	 _V_DrawFill
  00246	83 c4 14	 add	 esp, 20			; 00000014H
$LN31@V_DrawScal:

; 568  : 		}
; 569  : 	}
; 570  : 	destend = desttop + SHORT(patch->width) * dupx;

  00249	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0024c	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  0024f	0f af 4d f4	 imul	 ecx, DWORD PTR _dupx$[ebp]
  00253	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  00256	89 4d d4	 mov	 DWORD PTR _destend$[ebp], ecx

; 571  : 
; 572  : 	for (col = 0; desttop < destend; col += colfrac, desttop++)

  00259	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0
  00260	eb 12		 jmp	 SHORT $LN4@V_DrawScal
$LN2@V_DrawScal:
  00262	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00265	03 45 e8	 add	 eax, DWORD PTR _colfrac$[ebp]
  00268	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  0026b	8b 4d dc	 mov	 ecx, DWORD PTR _desttop$[ebp]
  0026e	83 c1 01	 add	 ecx, 1
  00271	89 4d dc	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawScal:
  00274	8b 45 dc	 mov	 eax, DWORD PTR _desttop$[ebp]
  00277	3b 45 d4	 cmp	 eax, DWORD PTR _destend$[ebp]
  0027a	0f 83 75 01 00
	00		 jae	 $LN3@V_DrawScal

; 573  : 	{
; 574  : 		register INT32 heightmask;
; 575  : 
; 576  : 		column = (const column_t *)((const UINT8 *)(patch) + LONG(patch->columnofs[col>>FRACBITS]));

  00280	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  00283	c1 f8 10	 sar	 eax, 16			; 00000010H
  00286	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  00289	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  0028c	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  00290	89 55 e0	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawScal:

; 577  : 
; 578  : 		while (column->topdelta != 0xff)

  00293	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00296	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00299	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0029f	0f 84 4b 01 00
	00		 je	 $LN6@V_DrawScal

; 579  : 		{
; 580  : 			source = (const UINT8 *)(column) + 3;

  002a5	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  002a8	83 c0 03	 add	 eax, 3
  002ab	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 581  : 			dest = desttop + column->topdelta*dupy*vid.width;

  002ae	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  002b1	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002b4	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  002b8	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  002bf	03 4d dc	 add	 ecx, DWORD PTR _desttop$[ebp]
  002c2	89 4d d8	 mov	 DWORD PTR _dest$[ebp], ecx

; 582  : 			count = column->length*dupy;

  002c5	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  002c8	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002cc	0f af 4d f0	 imul	 ecx, DWORD PTR _dupy$[ebp]
  002d0	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 583  : 
; 584  : 			ofs = 0;

  002d3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0

; 585  : 
; 586  : 			heightmask = column->length - 1;

  002da	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  002dd	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002e1	83 e9 01	 sub	 ecx, 1
  002e4	89 4d c8	 mov	 DWORD PTR _heightmask$1[ebp], ecx

; 587  : 
; 588  : 			if (column->length & heightmask)

  002e7	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  002ea	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002ee	23 4d c8	 and	 ecx, DWORD PTR _heightmask$1[ebp]
  002f1	0f 84 95 00 00
	00		 je	 $LN32@V_DrawScal

; 589  : 			{
; 590  : 				heightmask++;

  002f7	8b 45 c8	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  002fa	83 c0 01	 add	 eax, 1
  002fd	89 45 c8	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 591  : 				heightmask <<= FRACBITS;

  00300	8b 45 c8	 mov	 eax, DWORD PTR _heightmask$1[ebp]
  00303	c1 e0 10	 shl	 eax, 16			; 00000010H
  00306	89 45 c8	 mov	 DWORD PTR _heightmask$1[ebp], eax

; 592  : 
; 593  : 				if (rowfrac < 0)

  00309	83 7d e4 00	 cmp	 DWORD PTR _rowfrac$[ebp], 0
  0030d	7d 0f		 jge	 SHORT $LN34@V_DrawScal
$LN7@V_DrawScal:

; 594  : 					while ((rowfrac += heightmask) < 0)

  0030f	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00312	03 45 c8	 add	 eax, DWORD PTR _heightmask$1[ebp]
  00315	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  00318	79 02		 jns	 SHORT $LN8@V_DrawScal

; 595  : 						;

  0031a	eb f3		 jmp	 SHORT $LN7@V_DrawScal
$LN8@V_DrawScal:
  0031c	eb 13		 jmp	 SHORT $LN10@V_DrawScal
$LN34@V_DrawScal:

; 596  : 				else
; 597  : 					while (rowfrac >= heightmask)

  0031e	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00321	3b 45 c8	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  00324	7c 0b		 jl	 SHORT $LN10@V_DrawScal

; 598  : 						rowfrac -= heightmask;

  00326	8b 45 e4	 mov	 eax, DWORD PTR _rowfrac$[ebp]
  00329	2b 45 c8	 sub	 eax, DWORD PTR _heightmask$1[ebp]
  0032c	89 45 e4	 mov	 DWORD PTR _rowfrac$[ebp], eax
  0032f	eb ed		 jmp	 SHORT $LN34@V_DrawScal
$LN10@V_DrawScal:

; 599  : 
; 600  : 				do
; 601  : 				{
; 602  : 					if (dest < deststop)

  00331	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00334	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  00337	73 13		 jae	 SHORT $LN36@V_DrawScal

; 603  : 						*dest = source[ofs>>FRACBITS];

  00339	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  0033c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0033f	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  00342	8b 55 d0	 mov	 edx, DWORD PTR _source$[ebp]
  00345	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00348	88 01		 mov	 BYTE PTR [ecx], al
  0034a	eb 07		 jmp	 SHORT $LN37@V_DrawScal
$LN36@V_DrawScal:

; 604  : 					else
; 605  : 						count = 0;

  0034c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN37@V_DrawScal:

; 606  : 					dest += vid.width;

  00353	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  00356	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  0035c	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax

; 607  : 					ofs += rowfrac;

  0035f	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  00362	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00365	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 608  : 					if ((ofs + rowfrac) > heightmask)

  00368	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  0036b	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  0036e	3b 45 c8	 cmp	 eax, DWORD PTR _heightmask$1[ebp]
  00371	7e 02		 jle	 SHORT $LN38@V_DrawScal

; 609  : 						goto donedrawing;

  00373	eb 65		 jmp	 SHORT $donedrawing$42
$LN38@V_DrawScal:

; 610  : 				} while (count--);

  00375	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00378	89 45 84	 mov	 DWORD PTR tv229[ebp], eax
  0037b	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0037e	83 e9 01	 sub	 ecx, 1
  00381	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00384	83 7d 84 00	 cmp	 DWORD PTR tv229[ebp], 0
  00388	75 a7		 jne	 SHORT $LN10@V_DrawScal

; 611  : 			}

  0038a	eb 4e		 jmp	 SHORT $donedrawing$42
$LN32@V_DrawScal:

; 612  : 			else
; 613  : 			{
; 614  : 				while (count--)

  0038c	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0038f	89 45 84	 mov	 DWORD PTR tv232[ebp], eax
  00392	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00395	83 e9 01	 sub	 ecx, 1
  00398	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  0039b	83 7d 84 00	 cmp	 DWORD PTR tv232[ebp], 0
  0039f	74 39		 je	 SHORT $donedrawing$42

; 615  : 				{
; 616  : 					if (dest < deststop)

  003a1	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  003a4	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  003a7	73 13		 jae	 SHORT $LN39@V_DrawScal

; 617  : 						*dest = source[ofs>>FRACBITS];

  003a9	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  003ac	c1 f8 10	 sar	 eax, 16			; 00000010H
  003af	8b 4d d8	 mov	 ecx, DWORD PTR _dest$[ebp]
  003b2	8b 55 d0	 mov	 edx, DWORD PTR _source$[ebp]
  003b5	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  003b8	88 01		 mov	 BYTE PTR [ecx], al
  003ba	eb 07		 jmp	 SHORT $LN40@V_DrawScal
$LN39@V_DrawScal:

; 618  : 					else
; 619  : 						count = 0;

  003bc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN40@V_DrawScal:

; 620  : 					dest += vid.width;

  003c3	8b 45 d8	 mov	 eax, DWORD PTR _dest$[ebp]
  003c6	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  003cc	89 45 d8	 mov	 DWORD PTR _dest$[ebp], eax

; 621  : 					ofs += rowfrac;

  003cf	8b 45 ec	 mov	 eax, DWORD PTR _ofs$[ebp]
  003d2	03 45 e4	 add	 eax, DWORD PTR _rowfrac$[ebp]
  003d5	89 45 ec	 mov	 DWORD PTR _ofs$[ebp], eax

; 622  : 				}

  003d8	eb b2		 jmp	 SHORT $LN32@V_DrawScal
$donedrawing$42:

; 623  : 			}
; 624  : donedrawing:
; 625  : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  003da	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  003dd	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003e1	8b 55 e0	 mov	 edx, DWORD PTR _column$[ebp]
  003e4	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  003e8	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 626  : 		}

  003eb	e9 a3 fe ff ff	 jmp	 $LN5@V_DrawScal
$LN6@V_DrawScal:

; 627  : 	}

  003f0	e9 6d fe ff ff	 jmp	 $LN2@V_DrawScal
$LN3@V_DrawScal:

; 628  : }

  003f5	5f		 pop	 edi
  003f6	5e		 pop	 esi
  003f7	5b		 pop	 ebx
  003f8	8b e5		 mov	 esp, ebp
  003fa	5d		 pop	 ebp
  003fb	c3		 ret	 0
_V_DrawScaledPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_DrawMappedPatch
_TEXT	SEGMENT
tv216 = -120						; size = 4
_deststop$ = -52					; size = 4
_source$ = -48						; size = 4
_dest$ = -44						; size = 4
_desttop$ = -40						; size = 4
_column$ = -36						; size = 4
_rowfrac$ = -32						; size = 4
_colfrac$ = -28						; size = 4
_ofs$ = -24						; size = 4
_dupy$ = -20						; size = 4
_dupx$ = -16						; size = 4
_w$ = -12						; size = 4
_col$ = -8						; size = 4
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scrn$ = 16						; size = 4
_patch$ = 20						; size = 4
_colormap$ = 24						; size = 4
_V_DrawMappedPatch PROC					; COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 401  : 	size_t count;
; 402  : 	INT32 col, w, dupx, dupy, ofs, colfrac, rowfrac;
; 403  : 	const column_t *column;
; 404  : 	UINT8 *desttop, *dest;
; 405  : 	const UINT8 *source, *deststop;
; 406  : 
; 407  : #ifdef HWRENDER
; 408  : 	// draw a hardware converted patch
; 409  : 	if (rendermode != render_soft && rendermode != render_none)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 2a		 je	 SHORT $LN9@V_DrawMapp
  00012	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00019	74 21		 je	 SHORT $LN9@V_DrawMapp

; 410  : 	{
; 411  : 		HWR_DrawMappedPatch((GLPatch_t *)patch, x, y, scrn, colormap);

  0001b	8b 45 18	 mov	 eax, DWORD PTR _colormap$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _scrn$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 _HWR_DrawMappedPatch
  00034	83 c4 14	 add	 esp, 20			; 00000014H

; 412  : 		return;

  00037	e9 44 03 00 00	 jmp	 $LN3@V_DrawMapp
$LN9@V_DrawMapp:

; 413  : 	}
; 414  : #endif
; 415  : 
; 416  : 	if (scrn & V_NOSCALEPATCH)

  0003c	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0003f	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00044	74 0f		 je	 SHORT $LN10@V_DrawMapp

; 417  : 		dupx = dupy = 1;

  00046	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dupy$[ebp], 1
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _dupy$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR _dupx$[ebp], eax
  00053	eb 10		 jmp	 SHORT $LN11@V_DrawMapp
$LN10@V_DrawMapp:

; 418  : 	else
; 419  : 	{
; 420  : 		dupx = vid.dupx;

  00055	a1 20 00 00 00	 mov	 eax, DWORD PTR _vid+32
  0005a	89 45 f0	 mov	 DWORD PTR _dupx$[ebp], eax

; 421  : 		dupy = vid.dupy;

  0005d	a1 24 00 00 00	 mov	 eax, DWORD PTR _vid+36
  00062	89 45 ec	 mov	 DWORD PTR _dupy$[ebp], eax
$LN11@V_DrawMapp:

; 422  : 	}
; 423  : 
; 424  : 	y -= SHORT(patch->topoffset);

  00065	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00068	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0006f	2b d1		 sub	 edx, ecx
  00071	89 55 0c	 mov	 DWORD PTR _y$[ebp], edx

; 425  : 	x -= SHORT(patch->leftoffset);

  00074	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00077	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0007b	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0007e	2b d1		 sub	 edx, ecx
  00080	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 426  : 
; 427  : 	if (scrn & V_NOSCALESTART)

  00083	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00086	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0008b	74 4c		 je	 SHORT $LN12@V_DrawMapp

; 428  : 	{
; 429  : 		desttop = screens[scrn&0xffff] + (y*vid.width) + x;

  0008d	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00090	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00098	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  0009f	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  000a6	03 d1		 add	 edx, ecx
  000a8	03 55 08	 add	 edx, DWORD PTR _x$[ebp]
  000ab	89 55 d8	 mov	 DWORD PTR _desttop$[ebp], edx

; 430  : 		deststop = screens[scrn&0xffff] + vid.width * vid.height * vid.bpp;

  000ae	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000b1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b6	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  000bc	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  000c3	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  000ca	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  000d1	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 431  : 	}

  000d4	e9 71 01 00 00	 jmp	 $LN23@V_DrawMapp
$LN12@V_DrawMapp:

; 432  : 	else
; 433  : 	{
; 434  : 		desttop = screens[scrn&0xffff] + (y*vid.dupy*vid.width) + (x*vid.dupx);

  000d9	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  000dc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000e1	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000e4	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR _vid+36
  000eb	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  000f2	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _screens[eax*4]
  000f9	03 d1		 add	 edx, ecx
  000fb	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000fe	0f af 05 20 00
	00 00		 imul	 eax, DWORD PTR _vid+32
  00105	03 d0		 add	 edx, eax
  00107	89 55 d8	 mov	 DWORD PTR _desttop$[ebp], edx

; 435  : 		deststop = screens[scrn&0xffff] + vid.width * vid.height * vid.bpp;

  0010a	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0010d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00112	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  00118	0f af 0d 10 00
	00 00		 imul	 ecx, DWORD PTR _vid+16
  0011f	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  00126	03 0c 85 00 00
	00 00		 add	 ecx, DWORD PTR _screens[eax*4]
  0012d	89 4d cc	 mov	 DWORD PTR _deststop$[ebp], ecx

; 436  : 
; 437  : 		// Center it if necessary
; 438  : 		if (!(scrn & V_NOSCALEPATCH))

  00130	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00133	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00138	0f 85 0c 01 00
	00		 jne	 $LN23@V_DrawMapp

; 439  : 		{
; 440  : 			if (vid.fdupx != dupx)

  0013e	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _dupx$[ebp]
  00143	f3 0f 10 0d 28
	00 00 00	 movss	 xmm1, DWORD PTR _vid+40
  0014b	0f 2e c8	 ucomiss xmm1, xmm0
  0014e	9f		 lahf
  0014f	f6 c4 44	 test	 ah, 68			; 00000044H
  00152	7b 47		 jnp	 SHORT $LN18@V_DrawMapp

; 441  : 			{
; 442  : 				// dupx adjustments pretend that screen width is BASEVIDWIDTH * dupx,
; 443  : 				// so center this imaginary screen
; 444  : 				if (scrn & V_SNAPTORIGHT)

  00154	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00157	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0015c	74 17		 je	 SHORT $LN16@V_DrawMapp

; 445  : 					desttop += (vid.width - (BASEVIDWIDTH * dupx));

  0015e	69 45 f0 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00165	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0016b	2b c8		 sub	 ecx, eax
  0016d	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  00170	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
  00173	eb 26		 jmp	 SHORT $LN18@V_DrawMapp
$LN16@V_DrawMapp:

; 446  : 				else if (!(scrn & V_SNAPTOLEFT))

  00175	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  00178	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0017d	75 1c		 jne	 SHORT $LN18@V_DrawMapp

; 447  : 					desttop += (vid.width - (BASEVIDWIDTH * dupx)) / 2;

  0017f	69 45 f0 40 01
	00 00		 imul	 eax, DWORD PTR _dupx$[ebp], 320
  00186	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0018c	2b c8		 sub	 ecx, eax
  0018e	8b c1		 mov	 eax, ecx
  00190	99		 cdq
  00191	2b c2		 sub	 eax, edx
  00193	d1 f8		 sar	 eax, 1
  00195	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  00198	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
$LN18@V_DrawMapp:

; 448  : 			}
; 449  : 			if (vid.fdupy != dupy)

  0019b	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _dupy$[ebp]
  001a0	f3 0f 10 0d 2c
	00 00 00	 movss	 xmm1, DWORD PTR _vid+44
  001a8	0f 2e c8	 ucomiss xmm1, xmm0
  001ab	9f		 lahf
  001ac	f6 c4 44	 test	 ah, 68			; 00000044H
  001af	7b 55		 jnp	 SHORT $LN22@V_DrawMapp

; 450  : 			{
; 451  : 				// same thing here
; 452  : 				if (scrn & V_SNAPTOBOTTOM)

  001b1	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001b4	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001b9	74 1e		 je	 SHORT $LN20@V_DrawMapp

; 453  : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width;

  001bb	69 45 ec c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001c2	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001c8	2b c8		 sub	 ecx, eax
  001ca	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001d1	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  001d4	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
  001d7	eb 2d		 jmp	 SHORT $LN22@V_DrawMapp
$LN20@V_DrawMapp:

; 454  : 				else if (!(scrn & V_SNAPTOTOP))

  001d9	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  001dc	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  001e1	75 23		 jne	 SHORT $LN22@V_DrawMapp

; 455  : 					desttop += (vid.height - (BASEVIDHEIGHT * dupy)) * vid.width / 2;

  001e3	69 45 ec c8 00
	00 00		 imul	 eax, DWORD PTR _dupy$[ebp], 200
  001ea	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _vid+16
  001f0	2b c8		 sub	 ecx, eax
  001f2	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  001f9	8b c1		 mov	 eax, ecx
  001fb	99		 cdq
  001fc	2b c2		 sub	 eax, edx
  001fe	d1 f8		 sar	 eax, 1
  00200	03 45 d8	 add	 eax, DWORD PTR _desttop$[ebp]
  00203	89 45 d8	 mov	 DWORD PTR _desttop$[ebp], eax
$LN22@V_DrawMapp:

; 456  : 			}
; 457  : 			// if it's meant to cover the whole screen, black out the rest
; 458  : 			if (x == 0 && SHORT(patch->width) == BASEVIDWIDTH && y == 0 && SHORT(patch->height) == BASEVIDHEIGHT)

  00206	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0020a	75 3e		 jne	 SHORT $LN23@V_DrawMapp
  0020c	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0020f	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00212	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00218	75 30		 jne	 SHORT $LN23@V_DrawMapp
  0021a	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0021e	75 2a		 jne	 SHORT $LN23@V_DrawMapp
  00220	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  00223	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00227	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  0022d	75 1b		 jne	 SHORT $LN23@V_DrawMapp

; 459  : 				V_DrawFill(0, 0, vid.width, vid.height, 31);

  0022f	6a 1f		 push	 31			; 0000001fH
  00231	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00236	50		 push	 eax
  00237	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0023d	51		 push	 ecx
  0023e	6a 00		 push	 0
  00240	6a 00		 push	 0
  00242	e8 00 00 00 00	 call	 _V_DrawFill
  00247	83 c4 14	 add	 esp, 20			; 00000014H
$LN23@V_DrawMapp:

; 460  : 		}
; 461  : 	}
; 462  : 	scrn &= 0xffff;

  0024a	8b 45 10	 mov	 eax, DWORD PTR _scrn$[ebp]
  0024d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00252	89 45 10	 mov	 DWORD PTR _scrn$[ebp], eax

; 463  : 
; 464  : 	col = 0;

  00255	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$[ebp], 0

; 465  : 	colfrac = FixedDiv(FRACUNIT, dupx<<FRACBITS);

  0025c	8b 45 f0	 mov	 eax, DWORD PTR _dupx$[ebp]
  0025f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00262	50		 push	 eax
  00263	68 00 00 01 00	 push	 65536			; 00010000H
  00268	e8 00 00 00 00	 call	 _FixedDiv
  0026d	83 c4 08	 add	 esp, 8
  00270	89 45 e4	 mov	 DWORD PTR _colfrac$[ebp], eax

; 466  : 	rowfrac = FixedDiv(FRACUNIT, dupy<<FRACBITS);

  00273	8b 45 ec	 mov	 eax, DWORD PTR _dupy$[ebp]
  00276	c1 e0 10	 shl	 eax, 16			; 00000010H
  00279	50		 push	 eax
  0027a	68 00 00 01 00	 push	 65536			; 00010000H
  0027f	e8 00 00 00 00	 call	 _FixedDiv
  00284	83 c4 08	 add	 esp, 8
  00287	89 45 e0	 mov	 DWORD PTR _rowfrac$[ebp], eax

; 467  : 
; 468  : 	w = SHORT(patch->width)<<FRACBITS;

  0028a	8b 45 14	 mov	 eax, DWORD PTR _patch$[ebp]
  0028d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00290	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00293	89 4d f4	 mov	 DWORD PTR _w$[ebp], ecx

; 469  : 
; 470  : 	for (; col < w; col += colfrac, desttop++)

  00296	eb 12		 jmp	 SHORT $LN4@V_DrawMapp
$LN2@V_DrawMapp:
  00298	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  0029b	03 45 e4	 add	 eax, DWORD PTR _colfrac$[ebp]
  0029e	89 45 f8	 mov	 DWORD PTR _col$[ebp], eax
  002a1	8b 4d d8	 mov	 ecx, DWORD PTR _desttop$[ebp]
  002a4	83 c1 01	 add	 ecx, 1
  002a7	89 4d d8	 mov	 DWORD PTR _desttop$[ebp], ecx
$LN4@V_DrawMapp:
  002aa	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002ad	3b 45 f4	 cmp	 eax, DWORD PTR _w$[ebp]
  002b0	0f 8d ca 00 00
	00		 jge	 $LN3@V_DrawMapp

; 471  : 	{
; 472  : 		column = (const column_t *)((const UINT8 *)patch + LONG(patch->columnofs[col>>FRACBITS]));

  002b6	8b 45 f8	 mov	 eax, DWORD PTR _col$[ebp]
  002b9	c1 f8 10	 sar	 eax, 16			; 00000010H
  002bc	8b 4d 14	 mov	 ecx, DWORD PTR _patch$[ebp]
  002bf	8b 55 14	 mov	 edx, DWORD PTR _patch$[ebp]
  002c2	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  002c6	89 55 dc	 mov	 DWORD PTR _column$[ebp], edx
$LN5@V_DrawMapp:

; 473  : 
; 474  : 		while (column->topdelta != 0xff)

  002c9	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002cc	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002cf	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d5	0f 84 a0 00 00
	00		 je	 $LN6@V_DrawMapp

; 475  : 		{
; 476  : 			source = (const UINT8 *)column + 3;

  002db	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002de	83 c0 03	 add	 eax, 3
  002e1	89 45 d0	 mov	 DWORD PTR _source$[ebp], eax

; 477  : 			dest = desttop + column->topdelta*dupy*vid.width;

  002e4	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002e7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002ea	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  002ee	0f af 0d 0c 00
	00 00		 imul	 ecx, DWORD PTR _vid+12
  002f5	03 4d d8	 add	 ecx, DWORD PTR _desttop$[ebp]
  002f8	89 4d d4	 mov	 DWORD PTR _dest$[ebp], ecx

; 478  : 			count = column->length*dupy;

  002fb	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  002fe	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00302	0f af 4d ec	 imul	 ecx, DWORD PTR _dupy$[ebp]
  00306	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx

; 479  : 
; 480  : 			ofs = 0;

  00309	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ofs$[ebp], 0
$LN7@V_DrawMapp:

; 481  : 			while (count--)

  00310	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00313	89 45 88	 mov	 DWORD PTR tv216[ebp], eax
  00316	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  00319	83 e9 01	 sub	 ecx, 1
  0031c	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  0031f	83 7d 88 00	 cmp	 DWORD PTR tv216[ebp], 0
  00323	74 40		 je	 SHORT $LN8@V_DrawMapp

; 482  : 			{
; 483  : 				if (dest < deststop)

  00325	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00328	3b 45 cc	 cmp	 eax, DWORD PTR _deststop$[ebp]
  0032b	73 1a		 jae	 SHORT $LN24@V_DrawMapp

; 484  : 					*dest = *(colormap + source[ofs>>FRACBITS]);

  0032d	8b 45 e8	 mov	 eax, DWORD PTR _ofs$[ebp]
  00330	c1 f8 10	 sar	 eax, 16			; 00000010H
  00333	8b 4d d0	 mov	 ecx, DWORD PTR _source$[ebp]
  00336	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0033a	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  0033d	8b 4d 18	 mov	 ecx, DWORD PTR _colormap$[ebp]
  00340	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00343	88 10		 mov	 BYTE PTR [eax], dl
  00345	eb 07		 jmp	 SHORT $LN25@V_DrawMapp
$LN24@V_DrawMapp:

; 485  : 				else
; 486  : 					count = 0;

  00347	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN25@V_DrawMapp:

; 487  : 				dest += vid.width;

  0034e	8b 45 d4	 mov	 eax, DWORD PTR _dest$[ebp]
  00351	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _vid+12
  00357	89 45 d4	 mov	 DWORD PTR _dest$[ebp], eax

; 488  : 				ofs += rowfrac;

  0035a	8b 45 e8	 mov	 eax, DWORD PTR _ofs$[ebp]
  0035d	03 45 e0	 add	 eax, DWORD PTR _rowfrac$[ebp]
  00360	89 45 e8	 mov	 DWORD PTR _ofs$[ebp], eax

; 489  : 			}

  00363	eb ab		 jmp	 SHORT $LN7@V_DrawMapp
$LN8@V_DrawMapp:

; 490  : 
; 491  : 			column = (const column_t *)((const UINT8 *)column + column->length + 4);

  00365	8b 45 dc	 mov	 eax, DWORD PTR _column$[ebp]
  00368	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0036c	8b 55 dc	 mov	 edx, DWORD PTR _column$[ebp]
  0036f	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00373	89 45 dc	 mov	 DWORD PTR _column$[ebp], eax

; 492  : 		}

  00376	e9 4e ff ff ff	 jmp	 $LN5@V_DrawMapp
$LN6@V_DrawMapp:

; 493  : 	}

  0037b	e9 18 ff ff ff	 jmp	 $LN2@V_DrawMapp
$LN3@V_DrawMapp:

; 494  : }

  00380	5f		 pop	 edi
  00381	5e		 pop	 esi
  00382	5b		 pop	 ebx
  00383	8b e5		 mov	 esp, ebp
  00385	5d		 pop	 ebp
  00386	c3		 ret	 0
_V_DrawMappedPatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _GetPalette
_TEXT	SEGMENT
_GetPalette PROC					; COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 199  : 	if (gamestate == GS_LEVEL)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _gamestate, 1
  00010	75 22		 jne	 SHORT $LN2@GetPalette

; 200  : 		return R_GetPalname(mapheaderinfo[gamemap-1].palette);

  00012	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00019	83 e8 01	 sub	 eax, 1
  0001c	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00022	0f b7 91 80 01
	00 00		 movzx	 edx, WORD PTR _mapheaderinfo[ecx+384]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 _R_GetPalname
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 05		 jmp	 SHORT $LN1@GetPalette
$LN2@GetPalette:

; 201  : 	return "PLAYPAL";

  00034	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07FLMOFAHC@PLAYPAL@
$LN1@GetPalette:

; 202  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_GetPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _R_GetPalname
_TEXT	SEGMENT
_newpal$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_num$ = 8						; size = 2
_R_GetPalname PROC					; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 187  : 	static char palname[9];
; 188  : 	char newpal[9] = "PLAYPAL";

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07FLMOFAHC@PLAYPAL@
  00018	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_07FLMOFAHC@PLAYPAL@+4
  0001e	89 45 f0	 mov	 DWORD PTR _newpal$[ebp], eax
  00021	89 4d f4	 mov	 DWORD PTR _newpal$[ebp+4], ecx
  00024	33 c0		 xor	 eax, eax
  00026	88 45 f8	 mov	 BYTE PTR _newpal$[ebp+8], al

; 189  : 
; 190  : 	if (num <= 9999)

  00029	0f b7 45 08	 movzx	 eax, WORD PTR _num$[ebp]
  0002d	3d 0f 27 00 00	 cmp	 eax, 9999		; 0000270fH
  00032	7f 1b		 jg	 SHORT $LN2@R_GetPalna

; 191  : 		_snprintf(newpal, 8, "PAL%04u", num-1);

  00034	0f b7 45 08	 movzx	 eax, WORD PTR _num$[ebp]
  00038	83 e8 01	 sub	 eax, 1
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_07NNDNPPKA@PAL?$CF04u@
  00041	6a 08		 push	 8
  00043	8d 4d f0	 lea	 ecx, DWORD PTR _newpal$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ___snprintf
  0004c	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@R_GetPalna:

; 192  : 
; 193  : 	strncpy(palname, newpal, 8);

  0004f	6a 08		 push	 8
  00051	8d 45 f0	 lea	 eax, DWORD PTR _newpal$[ebp]
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ?palname@?1??R_GetPalname@@9@9
  0005a	e8 00 00 00 00	 call	 _strncpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 194  : 	return palname;

  00062	b8 00 00 00 00	 mov	 eax, OFFSET ?palname@?1??R_GetPalname@@9@9

; 195  : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_R_GetPalname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_SetPaletteLump
_TEXT	SEGMENT
_pal$ = 8						; size = 4
_V_SetPaletteLump PROC					; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 231  : 	LoadPalette(pal);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pal$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _LoadPalette
  00012	83 c4 04	 add	 esp, 4

; 232  : #ifdef HWRENDER
; 233  : 	if (rendermode != render_soft && rendermode != render_none)

  00015	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0001c	74 17		 je	 SHORT $LN2@V_SetPalet
  0001e	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00025	74 0e		 je	 SHORT $LN2@V_SetPalet

; 234  : 		HWR_SetPalette(pLocalPalette);

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLocalPalette
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _HWR_SetPalette
  00032	83 c4 04	 add	 esp, 4
$LN2@V_SetPalet:

; 235  : #if defined (__unix__) || defined (UNIXCOMMON) || defined (SDL)
; 236  : 	else
; 237  : #endif
; 238  : #endif
; 239  : 	if (rendermode != render_none)

  00035	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0003c	74 0e		 je	 SHORT $LN3@V_SetPalet

; 240  : 		I_SetPalette(pLocalPalette);

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLocalPalette
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _I_SetPalette
  00049	83 c4 04	 add	 esp, 4
$LN3@V_SetPalet:

; 241  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_V_SetPaletteLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_SetPalette
_TEXT	SEGMENT
_palettenum$ = 8					; size = 4
_V_SetPalette PROC					; COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 215  : 	if (!pLocalPalette)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLocalPalette, 0
  00010	75 06		 jne	 SHORT $LN2@V_SetPalet

; 216  : 		LoadMapPalette();

  00012	e8 00 00 00 00	 call	 _LoadMapPalette
  00017	90		 npad	 1
$LN2@V_SetPalet:

; 217  : 
; 218  : #ifdef HWRENDER
; 219  : 	if (rendermode != render_soft && rendermode != render_none)

  00018	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0001f	74 21		 je	 SHORT $LN3@V_SetPalet
  00021	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00028	74 18		 je	 SHORT $LN3@V_SetPalet

; 220  : 		HWR_SetPalette(&pLocalPalette[palettenum*256]);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _palettenum$[ebp]
  0002d	c1 e0 08	 shl	 eax, 8
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  00036	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 _HWR_SetPalette
  0003f	83 c4 04	 add	 esp, 4
$LN3@V_SetPalet:

; 221  : #if defined (__unix__) || defined (UNIXCOMMON) || defined (SDL)
; 222  : 	else
; 223  : #endif
; 224  : #endif
; 225  : 	if (rendermode != render_none)

  00042	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00049	74 18		 je	 SHORT $LN4@V_SetPalet

; 226  : 		I_SetPalette(&pLocalPalette[palettenum*256]);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _palettenum$[ebp]
  0004e	c1 e0 08	 shl	 eax, 8
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLocalPalette
  00057	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 _I_SetPalette
  00060	83 c4 04	 add	 esp, 4
$LN4@V_SetPalet:

; 227  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_V_SetPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\v_video.c
;	COMDAT _V_Init
_TEXT	SEGMENT
_screensize$ = -12					; size = 4
_base$ = -8						; size = 4
_i$ = -4						; size = 4
_V_Init	PROC						; COMDAT

; 2593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2594 : 	INT32 i;
; 2595 : 	UINT8 *base = vid.buffer;

  00009	a1 04 00 00 00	 mov	 eax, DWORD PTR _vid+4
  0000e	89 45 f8	 mov	 DWORD PTR _base$[ebp], eax

; 2596 : 	const INT32 screensize = vid.width * vid.height * vid.bpp;

  00011	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00016	0f af 05 10 00
	00 00		 imul	 eax, DWORD PTR _vid+16
  0001d	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  00024	89 45 f4	 mov	 DWORD PTR _screensize$[ebp], eax

; 2597 : 
; 2598 : 	LoadMapPalette();

  00027	e8 00 00 00 00	 call	 _LoadMapPalette
  0002c	90		 npad	 1

; 2599 : 	// hardware modes do not use screens[] pointers
; 2600 : 	for (i = 0; i < NUMSCREENS; i++)

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@V_Init
$LN2@V_Init:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@V_Init:
  0003f	83 7d fc 05	 cmp	 DWORD PTR _i$[ebp], 5
  00043	7d 10		 jge	 SHORT $LN3@V_Init

; 2601 : 		screens[i] = NULL;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00048	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _screens[eax*4], 0
  00053	eb e1		 jmp	 SHORT $LN2@V_Init
$LN3@V_Init:

; 2602 : 	if (rendermode != render_soft)

  00055	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  0005c	74 02		 je	 SHORT $LN8@V_Init

; 2603 : 	{
; 2604 : 		return; // be sure to cause a NULL read/write error so we detect it, in case of..

  0005e	eb 51		 jmp	 SHORT $LN10@V_Init
$LN8@V_Init:

; 2605 : 	}
; 2606 : 
; 2607 : 	// start address of NUMSCREENS * width*height vidbuffers
; 2608 : 	if (base)

  00060	83 7d f8 00	 cmp	 DWORD PTR _base$[ebp], 0
  00064	74 2e		 je	 SHORT $LN6@V_Init

; 2609 : 	{
; 2610 : 		for (i = 0; i < NUMSCREENS; i++)

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006d	eb 09		 jmp	 SHORT $LN7@V_Init
$LN5@V_Init:
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@V_Init:
  00078	83 7d fc 05	 cmp	 DWORD PTR _i$[ebp], 5
  0007c	7d 16		 jge	 SHORT $LN6@V_Init

; 2611 : 			screens[i] = base + i*screensize;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00081	0f af 45 f4	 imul	 eax, DWORD PTR _screensize$[ebp]
  00085	03 45 f8	 add	 eax, DWORD PTR _base$[ebp]
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0008b	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _screens[ecx*4], eax
  00092	eb db		 jmp	 SHORT $LN5@V_Init
$LN6@V_Init:

; 2612 : 	}
; 2613 : 
; 2614 : 	if (vid.direct)

  00094	83 3d 1c 00 00
	00 00		 cmp	 DWORD PTR _vid+28, 0
  0009b	74 14		 je	 SHORT $LN10@V_Init

; 2615 : 		screens[0] = vid.direct;

  0009d	b8 04 00 00 00	 mov	 eax, 4
  000a2	6b c8 00	 imul	 ecx, eax, 0
  000a5	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR _vid+28
  000ab	89 91 00 00 00
	00		 mov	 DWORD PTR _screens[ecx], edx
$LN10@V_Init:

; 2616 : 
; 2617 : #ifdef DEBUG
; 2618 : 	CONS_Printf("V_Init done:\n");
; 2619 : 	for (i = 0; i < NUMSCREENS+1; i++)
; 2620 : 		CONS_Printf(" screens[%d] = %x\n", i, screens[i]);
; 2621 : #endif
; 2622 : }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_V_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT ___snprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
___snprintf PROC					; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 __vsnprintf
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1952 :         __crt_va_end(_ArgList);

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1953 :         return _Result;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1954 :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
___snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1411 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1413 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
