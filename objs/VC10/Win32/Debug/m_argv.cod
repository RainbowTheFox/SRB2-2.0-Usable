; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\m_argv.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_myargc:DWORD
COMM	_myargv:DWORD
_DATA	ENDS
PUBLIC	_M_CheckParm
PUBLIC	_M_PushSpecialParameters
PUBLIC	_M_IsNextParm
PUBLIC	_M_GetNextParm
PUBLIC	_M_FindResponseFile
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BL@NJCHHIFL@Response?5file?5?$CFs?5not?5found@ ; `string'
PUBLIC	??_C@_0BI@EKAAPNIK@Found?5response?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CJ@EOEBABAH@No?5more?5free?5memory?5for?5the?5res@ ; `string'
PUBLIC	??_C@_0CG@OKKMPHDH@Couldn?8t?5read?5respone?5file?5beca@ ; `string'
PUBLIC	??_C@_0CI@JCIIDBLB@Not?5enough?5memory?5to?5read?5respo@ ; `string'
PUBLIC	??_C@_0BH@NFCCGPDB@?$CFd?5command?9line?5args?3?6@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strerror:PROC
EXTRN	_stricmp:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_fclose:PROC
EXTRN	_ferror:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_found	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NFCCGPDB@?$CFd?5command?9line?5args?3?6@
CONST	SEGMENT
??_C@_0BH@NFCCGPDB@?$CFd?5command?9line?5args?3?6@ DB '%d command-line ar'
	DB	'gs:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JCIIDBLB@Not?5enough?5memory?5to?5read?5respo@
CONST	SEGMENT
??_C@_0CI@JCIIDBLB@Not?5enough?5memory?5to?5read?5respo@ DB 'Not enough m'
	DB	'emory to read response file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OKKMPHDH@Couldn?8t?5read?5respone?5file?5beca@
CONST	SEGMENT
??_C@_0CG@OKKMPHDH@Couldn?8t?5read?5respone?5file?5beca@ DB 'Couldn''t re'
	DB	'ad respone file because %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EOEBABAH@No?5more?5free?5memory?5for?5the?5res@
CONST	SEGMENT
??_C@_0CJ@EOEBABAH@No?5more?5free?5memory?5for?5the?5res@ DB 'No more fre'
	DB	'e memory for the respone file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKAAPNIK@Found?5response?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@EKAAPNIK@Found?5response?5file?5?$CFs?6@ DB 'Found response fil'
	DB	'e %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NJCHHIFL@Response?5file?5?$CFs?5not?5found@
CONST	SEGMENT
??_C@_0BL@NJCHHIFL@Response?5file?5?$CFs?5not?5found@ DB 'Response file %'
	DB	's not found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03a3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0197H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_argv.c
;	COMDAT _M_FindResponseFile
_TEXT	SEGMENT
tv180 = -192						; size = 4
_firstargv$1 = -124					; size = 4
_moreargs$2 = -120					; size = 80
_file$3 = -40						; size = 4
_infile$4 = -36						; size = 4
_inquote$5 = -32					; size = 4
_size$6 = -28						; size = 4
_indexinfile$7 = -24					; size = 4
_pindex$8 = -20						; size = 4
_k$9 = -16						; size = 4
_handle$10 = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_M_FindResponseFile PROC				; COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 144  : 	INT32 i;
; 145  : 
; 146  : 	for (i = 1; i < myargc; i++)

  00016	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0001d	eb 09		 jmp	 SHORT $LN4@M_FindResp
$LN2@M_FindResp:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@M_FindResp:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  00031	0f 8d 69 03 00
	00		 jge	 $LN3@M_FindResp

; 147  : 		if (myargv[i][0] == '@')

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	6b c8 00	 imul	 ecx, eax, 0
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  00047	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  0004a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0004e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00051	0f 85 44 03 00
	00		 jne	 $LN21@M_FindResp

; 148  : 		{
; 149  : 			FILE *handle;
; 150  : 			INT32 k, pindex, indexinfile;
; 151  : 			long size;
; 152  : 			boolean inquote = false;

  00057	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _inquote$5[ebp], 0

; 153  : 			UINT8 *infile;
; 154  : 			char *file;
; 155  : 			char *moreargs[20];
; 156  : 			char *firstargv;
; 157  : 
; 158  : 			// read the response file into memory
; 159  : 			handle = fopen(&myargv[i][1], "rb");

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	c1 e0 00	 shl	 eax, 0
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  00074	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _fopen
  0007d	83 c4 08	 add	 esp, 8
  00080	89 45 f4	 mov	 DWORD PTR _handle$10[ebp], eax

; 160  : 			if (!handle)

  00083	83 7d f4 00	 cmp	 DWORD PTR _handle$10[ebp], 0
  00087	75 22		 jne	 SHORT $LN22@M_FindResp

; 161  : 				I_Error("Response file %s not found", &myargv[i][1]);

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	c1 e0 00	 shl	 eax, 0
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00094	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  0009a	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NJCHHIFL@Response?5file?5?$CFs?5not?5found@
  000a3	e8 00 00 00 00	 call	 _I_Error
  000a8	83 c4 08	 add	 esp, 8
$LN22@M_FindResp:

; 162  : 
; 163  : 			CONS_Printf("Found response file %s\n", &myargv[i][1]);

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	c1 e0 00	 shl	 eax, 0
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  000bc	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EKAAPNIK@Found?5response?5file?5?$CFs?6@
  000c5	e8 00 00 00 00	 call	 _CONS_Printf
  000ca	83 c4 08	 add	 esp, 8

; 164  : 			fseek(handle, 0, SEEK_END);

  000cd	6a 02		 push	 2
  000cf	6a 00		 push	 0
  000d1	8b 45 f4	 mov	 eax, DWORD PTR _handle$10[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _fseek
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 			size = ftell(handle);

  000dd	8b 45 f4	 mov	 eax, DWORD PTR _handle$10[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _ftell
  000e6	83 c4 04	 add	 esp, 4
  000e9	89 45 e4	 mov	 DWORD PTR _size$6[ebp], eax

; 166  : 			fseek(handle, 0, SEEK_SET);

  000ec	6a 00		 push	 0
  000ee	6a 00		 push	 0
  000f0	8b 45 f4	 mov	 eax, DWORD PTR _handle$10[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _fseek
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 			file = malloc(size);

  000fc	8b 45 e4	 mov	 eax, DWORD PTR _size$6[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _malloc
  00105	83 c4 04	 add	 esp, 4
  00108	89 45 d8	 mov	 DWORD PTR _file$3[ebp], eax

; 168  : 			if (!file)

  0010b	83 7d d8 00	 cmp	 DWORD PTR _file$3[ebp], 0
  0010f	75 0d		 jne	 SHORT $LN23@M_FindResp

; 169  : 				I_Error("No more free memory for the respone file");

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EOEBABAH@No?5more?5free?5memory?5for?5the?5res@
  00116	e8 00 00 00 00	 call	 _I_Error
  0011b	83 c4 04	 add	 esp, 4
$LN23@M_FindResp:

; 170  : 			if (fread(file, size, 1, handle) != 1)

  0011e	8b 45 f4	 mov	 eax, DWORD PTR _handle$10[ebp]
  00121	50		 push	 eax
  00122	6a 01		 push	 1
  00124	8b 4d e4	 mov	 ecx, DWORD PTR _size$6[ebp]
  00127	51		 push	 ecx
  00128	8b 55 d8	 mov	 edx, DWORD PTR _file$3[ebp]
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 _fread
  00131	83 c4 10	 add	 esp, 16			; 00000010H
  00134	83 f8 01	 cmp	 eax, 1
  00137	74 23		 je	 SHORT $LN24@M_FindResp

; 171  : 				I_Error("Couldn't read respone file because %s", strerror(ferror(handle)));

  00139	8b 45 f4	 mov	 eax, DWORD PTR _handle$10[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _ferror
  00142	83 c4 04	 add	 esp, 4
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _strerror
  0014b	83 c4 04	 add	 esp, 4
  0014e	50		 push	 eax
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OKKMPHDH@Couldn?8t?5read?5respone?5file?5beca@
  00154	e8 00 00 00 00	 call	 _I_Error
  00159	83 c4 08	 add	 esp, 8
$LN24@M_FindResp:

; 172  : 			fclose(handle);

  0015c	8b 45 f4	 mov	 eax, DWORD PTR _handle$10[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _fclose
  00165	83 c4 04	 add	 esp, 4

; 173  : 
; 174  : 			// keep all the command line arguments following @responsefile
; 175  : 			for (pindex = 0, k = i+1; k < myargc; k++)

  00168	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pindex$8[ebp], 0
  0016f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00172	83 c0 01	 add	 eax, 1
  00175	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax
  00178	eb 09		 jmp	 SHORT $LN7@M_FindResp
$LN5@M_FindResp:
  0017a	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  0017d	83 c0 01	 add	 eax, 1
  00180	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax
$LN7@M_FindResp:
  00183	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  00186	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  0018c	7d 1e		 jge	 SHORT $LN6@M_FindResp

; 176  : 				moreargs[pindex++] = myargv[k];

  0018e	8b 45 ec	 mov	 eax, DWORD PTR _pindex$8[ebp]
  00191	8b 4d f0	 mov	 ecx, DWORD PTR _k$9[ebp]
  00194	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  0019a	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0019d	89 4c 85 88	 mov	 DWORD PTR _moreargs$2[ebp+eax*4], ecx
  001a1	8b 55 ec	 mov	 edx, DWORD PTR _pindex$8[ebp]
  001a4	83 c2 01	 add	 edx, 1
  001a7	89 55 ec	 mov	 DWORD PTR _pindex$8[ebp], edx
  001aa	eb ce		 jmp	 SHORT $LN5@M_FindResp
$LN6@M_FindResp:

; 177  : 
; 178  : 			firstargv = myargv[0];

  001ac	b8 04 00 00 00	 mov	 eax, 4
  001b1	6b c8 00	 imul	 ecx, eax, 0
  001b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  001ba	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001bd	89 45 84	 mov	 DWORD PTR _firstargv$1[ebp], eax

; 179  : 			myargv = malloc(sizeof (char *) * MAXARGVS);

  001c0	68 00 04 00 00	 push	 1024			; 00000400H
  001c5	e8 00 00 00 00	 call	 _malloc
  001ca	83 c4 04	 add	 esp, 4
  001cd	a3 00 00 00 00	 mov	 DWORD PTR _myargv, eax

; 180  : 			if (!myargv)

  001d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _myargv, 0
  001d9	75 19		 jne	 SHORT $LN25@M_FindResp

; 181  : 			{
; 182  : 				free(file);

  001db	8b 45 d8	 mov	 eax, DWORD PTR _file$3[ebp]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _free
  001e4	83 c4 04	 add	 esp, 4

; 183  : 				I_Error("Not enough memory to read response file");

  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@JCIIDBLB@Not?5enough?5memory?5to?5read?5respo@
  001ec	e8 00 00 00 00	 call	 _I_Error
  001f1	83 c4 04	 add	 esp, 4
$LN25@M_FindResp:

; 184  : 			}
; 185  : 			memset(myargv, 0, sizeof (char *) * MAXARGVS);

  001f4	68 00 04 00 00	 push	 1024			; 00000400H
  001f9	6a 00		 push	 0
  001fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 _memset
  00206	83 c4 0c	 add	 esp, 12			; 0000000cH

; 186  : 			myargv[0] = firstargv;

  00209	b8 04 00 00 00	 mov	 eax, 4
  0020e	6b c8 00	 imul	 ecx, eax, 0
  00211	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  00217	8b 45 84	 mov	 eax, DWORD PTR _firstargv$1[ebp]
  0021a	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 187  : 
; 188  : 			infile = (UINT8 *)file;

  0021d	8b 45 d8	 mov	 eax, DWORD PTR _file$3[ebp]
  00220	89 45 dc	 mov	 DWORD PTR _infile$4[ebp], eax

; 189  : 			indexinfile = k = 0;

  00223	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _k$9[ebp], 0
  0022a	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  0022d	89 45 e8	 mov	 DWORD PTR _indexinfile$7[ebp], eax

; 190  : 			indexinfile++; // skip past argv[0]

  00230	8b 45 e8	 mov	 eax, DWORD PTR _indexinfile$7[ebp]
  00233	83 c0 01	 add	 eax, 1
  00236	89 45 e8	 mov	 DWORD PTR _indexinfile$7[ebp], eax
$LN10@M_FindResp:

; 191  : 			do
; 192  : 			{
; 193  : 				inquote = infile[k] == '"';

  00239	8b 45 dc	 mov	 eax, DWORD PTR _infile$4[ebp]
  0023c	03 45 f0	 add	 eax, DWORD PTR _k$9[ebp]
  0023f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00242	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00245	75 0c		 jne	 SHORT $LN30@M_FindResp
  00247	c7 85 40 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv180[ebp], 1
  00251	eb 0a		 jmp	 SHORT $LN31@M_FindResp
$LN30@M_FindResp:
  00253	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv180[ebp], 0
$LN31@M_FindResp:
  0025d	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv180[ebp]
  00263	89 55 e0	 mov	 DWORD PTR _inquote$5[ebp], edx

; 194  : 				if (inquote) // strip enclosing double-quote

  00266	83 7d e0 00	 cmp	 DWORD PTR _inquote$5[ebp], 0
  0026a	74 09		 je	 SHORT $LN26@M_FindResp

; 195  : 					k++;

  0026c	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  0026f	83 c0 01	 add	 eax, 1
  00272	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax
$LN26@M_FindResp:

; 196  : 				myargv[indexinfile++] = (char *)&infile[k];

  00275	8b 45 dc	 mov	 eax, DWORD PTR _infile$4[ebp]
  00278	03 45 f0	 add	 eax, DWORD PTR _k$9[ebp]
  0027b	8b 4d e8	 mov	 ecx, DWORD PTR _indexinfile$7[ebp]
  0027e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  00284	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00287	8b 45 e8	 mov	 eax, DWORD PTR _indexinfile$7[ebp]
  0028a	83 c0 01	 add	 eax, 1
  0028d	89 45 e8	 mov	 DWORD PTR _indexinfile$7[ebp], eax
$LN11@M_FindResp:

; 197  : 				while (k < size && ((inquote && infile[k] != '"')

  00290	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  00293	3b 45 e4	 cmp	 eax, DWORD PTR _size$6[ebp]
  00296	7d 33		 jge	 SHORT $LN12@M_FindResp
  00298	83 7d e0 00	 cmp	 DWORD PTR _inquote$5[ebp], 0
  0029c	74 0e		 je	 SHORT $LN28@M_FindResp
  0029e	8b 45 dc	 mov	 eax, DWORD PTR _infile$4[ebp]
  002a1	03 45 f0	 add	 eax, DWORD PTR _k$9[ebp]
  002a4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002a7	83 f9 22	 cmp	 ecx, 34			; 00000022H
  002aa	75 14		 jne	 SHORT $LN27@M_FindResp
$LN28@M_FindResp:
  002ac	83 7d e0 00	 cmp	 DWORD PTR _inquote$5[ebp], 0
  002b0	75 19		 jne	 SHORT $LN12@M_FindResp
  002b2	8b 45 dc	 mov	 eax, DWORD PTR _infile$4[ebp]
  002b5	03 45 f0	 add	 eax, DWORD PTR _k$9[ebp]
  002b8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002bb	83 f9 20	 cmp	 ecx, 32			; 00000020H
  002be	7e 0b		 jle	 SHORT $LN12@M_FindResp
$LN27@M_FindResp:

; 198  : 					|| (!inquote && infile[k] > ' ')))
; 199  : 				{
; 200  : 					k++;

  002c0	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  002c3	83 c0 01	 add	 eax, 1
  002c6	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax

; 201  : 				}

  002c9	eb c5		 jmp	 SHORT $LN11@M_FindResp
$LN12@M_FindResp:

; 202  : 				infile[k] = 0;

  002cb	8b 45 dc	 mov	 eax, DWORD PTR _infile$4[ebp]
  002ce	03 45 f0	 add	 eax, DWORD PTR _k$9[ebp]
  002d1	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN13@M_FindResp:

; 203  : 				while (k < size && (infile[k] <= ' '))

  002d4	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  002d7	3b 45 e4	 cmp	 eax, DWORD PTR _size$6[ebp]
  002da	7d 19		 jge	 SHORT $LN14@M_FindResp
  002dc	8b 45 dc	 mov	 eax, DWORD PTR _infile$4[ebp]
  002df	03 45 f0	 add	 eax, DWORD PTR _k$9[ebp]
  002e2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002e5	83 f9 20	 cmp	 ecx, 32			; 00000020H
  002e8	7f 0b		 jg	 SHORT $LN14@M_FindResp

; 204  : 					k++;

  002ea	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  002ed	83 c0 01	 add	 eax, 1
  002f0	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax
  002f3	eb df		 jmp	 SHORT $LN13@M_FindResp
$LN14@M_FindResp:

; 205  : 			} while (k < size);

  002f5	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  002f8	3b 45 e4	 cmp	 eax, DWORD PTR _size$6[ebp]
  002fb	0f 8c 38 ff ff
	ff		 jl	 $LN10@M_FindResp

; 206  : 
; 207  : 			free(file);

  00301	8b 45 d8	 mov	 eax, DWORD PTR _file$3[ebp]
  00304	50		 push	 eax
  00305	e8 00 00 00 00	 call	 _free
  0030a	83 c4 04	 add	 esp, 4

; 208  : 
; 209  : 			for (k = 0; k < pindex; k++)

  0030d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _k$9[ebp], 0
  00314	eb 09		 jmp	 SHORT $LN17@M_FindResp
$LN15@M_FindResp:
  00316	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  00319	83 c0 01	 add	 eax, 1
  0031c	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax
$LN17@M_FindResp:
  0031f	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  00322	3b 45 ec	 cmp	 eax, DWORD PTR _pindex$8[ebp]
  00325	7d 1e		 jge	 SHORT $LN16@M_FindResp

; 210  : 				myargv[indexinfile++] = moreargs[k];

  00327	8b 45 e8	 mov	 eax, DWORD PTR _indexinfile$7[ebp]
  0032a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  00330	8b 55 f0	 mov	 edx, DWORD PTR _k$9[ebp]
  00333	8b 54 95 88	 mov	 edx, DWORD PTR _moreargs$2[ebp+edx*4]
  00337	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  0033a	8b 45 e8	 mov	 eax, DWORD PTR _indexinfile$7[ebp]
  0033d	83 c0 01	 add	 eax, 1
  00340	89 45 e8	 mov	 DWORD PTR _indexinfile$7[ebp], eax
  00343	eb d1		 jmp	 SHORT $LN15@M_FindResp
$LN16@M_FindResp:

; 211  : 			myargc = indexinfile;

  00345	8b 45 e8	 mov	 eax, DWORD PTR _indexinfile$7[ebp]
  00348	a3 00 00 00 00	 mov	 DWORD PTR _myargc, eax

; 212  : 
; 213  : 			// display arguments
; 214  : 			CONS_Printf("%d command-line args:\n", myargc);

  0034d	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargc
  00352	50		 push	 eax
  00353	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NFCCGPDB@?$CFd?5command?9line?5args?3?6@
  00358	e8 00 00 00 00	 call	 _CONS_Printf
  0035d	83 c4 08	 add	 esp, 8

; 215  : 			for (k = 1; k < myargc; k++)

  00360	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _k$9[ebp], 1
  00367	eb 09		 jmp	 SHORT $LN20@M_FindResp
$LN18@M_FindResp:
  00369	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  0036c	83 c0 01	 add	 eax, 1
  0036f	89 45 f0	 mov	 DWORD PTR _k$9[ebp], eax
$LN20@M_FindResp:
  00372	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  00375	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  0037b	7d 1c		 jge	 SHORT $LN19@M_FindResp

; 216  : 				CONS_Printf("%s\n", myargv[k]);

  0037d	8b 45 f0	 mov	 eax, DWORD PTR _k$9[ebp]
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  00386	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00389	52		 push	 edx
  0038a	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  0038f	e8 00 00 00 00	 call	 _CONS_Printf
  00394	83 c4 08	 add	 esp, 8
  00397	eb d0		 jmp	 SHORT $LN18@M_FindResp
$LN19@M_FindResp:

; 217  : 
; 218  : 			break;

  00399	eb 05		 jmp	 SHORT $LN3@M_FindResp
$LN21@M_FindResp:

; 219  : 		}

  0039b	e9 7f fc ff ff	 jmp	 $LN2@M_FindResp
$LN3@M_FindResp:

; 220  : }

  003a0	5f		 pop	 edi
  003a1	5e		 pop	 esi
  003a2	5b		 pop	 ebx
  003a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a6	33 cd		 xor	 ecx, ebp
  003a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ad	8b e5		 mov	 esp, ebp
  003af	5d		 pop	 ebp
  003b0	c3		 ret	 0
_M_FindResponseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_argv.c
;	COMDAT _M_GetNextParm
_TEXT	SEGMENT
_M_GetNextParm PROC					; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 82   : 	if (M_IsNextParm())

  00009	e8 00 00 00 00	 call	 _M_IsNextParm
  0000e	85 c0		 test	 eax, eax
  00010	74 1d		 je	 SHORT $LN2@M_GetNextP

; 83   : 	{
; 84   : 		found++;

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _found
  00017	83 c0 01	 add	 eax, 1
  0001a	a3 00 00 00 00	 mov	 DWORD PTR _found, eax

; 85   : 		return myargv[found];

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _found
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  0002a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0002d	eb 02		 jmp	 SHORT $LN1@M_GetNextP
$LN2@M_GetNextP:

; 86   : 	}
; 87   : 	return NULL;

  0002f	33 c0		 xor	 eax, eax
$LN1@M_GetNextP:

; 88   : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_M_GetNextParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_argv.c
;	COMDAT _M_IsNextParm
_TEXT	SEGMENT
_M_IsNextParm PROC					; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 70   : 	if (found > 0 && found + 1 < myargc && myargv[found+1][0] != '-' && myargv[found+1][0] != '+')

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _found, 0
  00010	7e 57		 jle	 SHORT $LN2@M_IsNextPa
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _found
  00017	83 c0 01	 add	 eax, 1
  0001a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  00020	7d 47		 jge	 SHORT $LN2@M_IsNextPa
  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	6b c8 00	 imul	 ecx, eax, 0
  0002a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _found
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  00035	8b 54 90 04	 mov	 edx, DWORD PTR [eax+edx*4+4]
  00039	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0003d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00040	74 27		 je	 SHORT $LN2@M_IsNextPa
  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _found
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  00055	8b 54 90 04	 mov	 edx, DWORD PTR [eax+edx*4+4]
  00059	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0005d	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00060	74 07		 je	 SHORT $LN2@M_IsNextPa

; 71   : 		return true;

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	eb 02		 jmp	 SHORT $LN1@M_IsNextPa
$LN2@M_IsNextPa:

; 72   : 	return false;

  00069	33 c0		 xor	 eax, eax
$LN1@M_IsNextPa:

; 73   : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_M_IsNextParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_argv.c
;	COMDAT _M_PushSpecialParameters
_TEXT	SEGMENT
_onetime$ = -268					; size = 4
_s$ = -264						; size = 256
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_M_PushSpecialParameters PROC				; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 95   : 	INT32 i;
; 96   : 	char s[256];
; 97   : 	boolean onetime = false;

  00016	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _onetime$[ebp], 0

; 98   : 
; 99   : 	for (i = 1; i < myargc; i++)

  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00027	eb 09		 jmp	 SHORT $LN4@M_PushSpec
$LN2@M_PushSpec:
  00029	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@M_PushSpec:
  00032	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00035	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  0003b	0f 8d 53 01 00
	00		 jge	 $LN3@M_PushSpec

; 100  : 	{
; 101  : 		if (myargv[i][0] == '+')

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  00051	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00054	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00058	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0005b	0f 85 2e 01 00
	00		 jne	 $LN8@M_PushSpec

; 102  : 		{
; 103  : 			strcpy(s, &myargv[i][1]);

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	c1 e0 00	 shl	 eax, 0
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargv
  00072	03 04 8a	 add	 eax, DWORD PTR [edx+ecx*4]
  00075	50		 push	 eax
  00076	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _strcpy
  00082	83 c4 08	 add	 esp, 8

; 104  : 			i++;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 105  : 
; 106  : 			// get the parameters of the command too
; 107  : 			for (; i < myargc && myargv[i][0] != '+' && myargv[i][0] != '-'; i++)

  0008e	eb 09		 jmp	 SHORT $LN7@M_PushSpec
$LN5@M_PushSpec:
  00090	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@M_PushSpec:
  00099	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  000a2	0f 8d 94 00 00
	00		 jge	 $LN6@M_PushSpec
  000a8	b8 01 00 00 00	 mov	 eax, 1
  000ad	6b c8 00	 imul	 ecx, eax, 0
  000b0	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  000b8	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000bb	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000bf	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  000c2	74 78		 je	 SHORT $LN6@M_PushSpec
  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	6b c8 00	 imul	 ecx, eax, 0
  000cc	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargv
  000d4	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  000d7	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000db	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000de	74 5c		 je	 SHORT $LN6@M_PushSpec

; 108  : 			{
; 109  : 				strcat(s, " ");

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  000e5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _strcat
  000f1	83 c4 08	 add	 esp, 8

; 110  : 				if (!onetime)

  000f4	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _onetime$[ebp], 0
  000fb	75 1e		 jne	 SHORT $LN9@M_PushSpec

; 111  : 				{
; 112  : 					strcat(s, "\"");

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC@
  00102	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _strcat
  0010e	83 c4 08	 add	 esp, 8

; 113  : 					onetime = true;

  00111	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _onetime$[ebp], 1
$LN9@M_PushSpec:

; 114  : 				}
; 115  : 				strcat(s, myargv[i]);

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  00124	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00127	52		 push	 edx
  00128	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 _strcat
  00134	83 c4 08	 add	 esp, 8

; 116  : 			}

  00137	e9 54 ff ff ff	 jmp	 $LN5@M_PushSpec
$LN6@M_PushSpec:

; 117  : 			if (onetime)

  0013c	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _onetime$[ebp], 0
  00143	74 1e		 je	 SHORT $LN10@M_PushSpec

; 118  : 			{
; 119  : 				strcat(s, "\"");

  00145	68 00 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC@
  0014a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _strcat
  00156	83 c4 08	 add	 esp, 8

; 120  : 				onetime = false;

  00159	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _onetime$[ebp], 0
$LN10@M_PushSpec:

; 121  : 			}
; 122  : 			strcat(s, "\n");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00168	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _strcat
  00174	83 c4 08	 add	 esp, 8

; 123  : 
; 124  : 			// push it
; 125  : 			COM_BufAddText(s);

  00177	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _s$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 _COM_BufAddText
  00183	83 c4 04	 add	 esp, 4

; 126  : 			i--;

  00186	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00189	83 e8 01	 sub	 eax, 1
  0018c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN8@M_PushSpec:

; 127  : 		}
; 128  : 	}

  0018f	e9 95 fe ff ff	 jmp	 $LN2@M_PushSpec
$LN3@M_PushSpec:

; 129  : }

  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5b		 pop	 ebx
  00197	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019a	33 cd		 xor	 ecx, ebp
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c3		 ret	 0
_M_PushSpecialParameters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_argv.c
;	COMDAT _M_CheckParm
_TEXT	SEGMENT
_i$ = -4						; size = 4
_check$ = 8						; size = 4
_M_CheckParm PROC					; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 49   : 	INT32 i;
; 50   : 
; 51   : 	for (i = 1; i < myargc; i++)

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00010	eb 09		 jmp	 SHORT $LN4@M_CheckPar
$LN2@M_CheckPar:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@M_CheckPar:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  00024	7d 2c		 jge	 SHORT $LN3@M_CheckPar

; 52   : 	{
; 53   : 		if (!strcasecmp(check, myargv[i]))

  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  0002f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00032	52		 push	 edx
  00033	8b 45 08	 mov	 eax, DWORD PTR _check$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _stricmp
  0003c	83 c4 08	 add	 esp, 8
  0003f	85 c0		 test	 eax, eax
  00041	75 0d		 jne	 SHORT $LN5@M_CheckPar

; 54   : 		{
; 55   : 			found = i;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	a3 00 00 00 00	 mov	 DWORD PTR _found, eax

; 56   : 			return i;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004e	eb 0e		 jmp	 SHORT $LN1@M_CheckPar
$LN5@M_CheckPar:

; 57   : 		}
; 58   : 	}

  00050	eb c0		 jmp	 SHORT $LN2@M_CheckPar
$LN3@M_CheckPar:

; 59   : 	found = 0;

  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _found, 0

; 60   : 	return 0;

  0005c	33 c0		 xor	 eax, eax
$LN1@M_CheckPar:

; 61   : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_M_CheckParm ENDP
_TEXT	ENDS
END
