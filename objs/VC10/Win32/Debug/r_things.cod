; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\r_things.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_spryscale
PUBLIC	_sprtopscreen
PUBLIC	_sprbotscreen
PUBLIC	_windowtop
PUBLIC	_windowbottom
PUBLIC	_numskins
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_numsprites:DWORD
COMM	_sprites:DWORD
COMM	_negonearray:WORD:0780H
COMM	_screenheightarray:WORD:0780H
COMM	_mfloorclip:DWORD
COMM	_mceilingclip:DWORD
_DATA	ENDS
_BSS	SEGMENT
_spryscale DD	01H DUP (?)
_sprtopscreen DD 01H DUP (?)
_sprbotscreen DD 01H DUP (?)
_windowtop DD	01H DUP (?)
_windowbottom DD 01H DUP (?)
_numskins DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_skins:BYTE:01e6cH
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	__snprintf
PUBLIC	_R_DrawMaskedColumn
PUBLIC	_R_SortVisSprites
PUBLIC	_R_AddSpriteDefs
PUBLIC	_R_DelSpriteDefs
PUBLIC	_R_AddSprites
PUBLIC	_R_InitSprites
PUBLIC	_R_ClearSprites
PUBLIC	_R_DrawMasked
PUBLIC	_SetPlayerSkin
PUBLIC	_SetPlayerSkinByNum
PUBLIC	_R_SkinAvailable
PUBLIC	_R_AddSkins
PUBLIC	_R_DelSkins
PUBLIC	_R_InitDrawNodes
PUBLIC	_SetSavedSkin
PUBLIC	??_C@_0DF@FHMKOFFL@R_InstallSpriteLump?3?5Bad?5frame?5@ ; `string'
PUBLIC	??_C@_0DN@CJKANNFJ@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@ ; `string'
PUBLIC	??_C@_0EE@MIEHPANO@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@ ; `string'
PUBLIC	??_C@_0DM@BNBLKIJD@R_InitSprites?3?5Sprite?5?$CFs?3?5?$CFc?3?$CFc@ ; `string'
PUBLIC	??_C@_0BN@OJMBDFML@WARNING?$CB?5Bad?5sprite?5name?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0EF@DJLNLEII@R_AddSingleSpriteDef?3?5too?5much?5@ ; `string'
PUBLIC	??_C@_0DH@PAGKONHI@R_AddSingleSpriteDef?3?5No?5patche@ ; `string'
PUBLIC	??_C@_0DO@CKKDGOMC@R_AddSingleSpriteDef?3?5Sprite?5?$CFs@ ; `string'
PUBLIC	??_C@_07EBCHADGJ@S_START@			; `string'
PUBLIC	??_C@_08IJNDLFBN@SS_START@			; `string'
PUBLIC	??_C@_05DMLPPONL@S_END@				; `string'
PUBLIC	??_C@_06CCMHDCM@SS_END@				; `string'
PUBLIC	??_C@_0BH@ENOHDNK@no?5sprites?5in?5pwad?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BK@JAKAEHGP@sprite?5?$CFs?5set?5in?5pwad?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CA@DDMKBGII@?$CFIu?5sprites?5added?5from?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CC@PFMCHJKE@?$CFIu?5sprites?5removed?5from?5file?5?$CF@ ; `string'
PUBLIC	??_C@_0CJ@CCFDIMJD@R_AddSpriteDefs?3?5no?5sprites?5in?5@ ; `string'
PUBLIC	?__LINE__Var@?0??R_DrawMaskedColumn@@9@9	; `R_DrawMaskedColumn'::`1'::__LINE__Var
PUBLIC	??_C@_0FF@MAHMJHDH@C?3?2Users?2RafaTheFox?2Desktop?2SRB@ ; `string'
PUBLIC	??_C@_0CE@LBNFAKMD@WARNING?3?5avoiding?5a?5crash?5in?5?$CFs@ ; `string'
PUBLIC	??_C@_0EO@MBOIJNDA@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@ ; `string'
PUBLIC	??_C@_0FK@ELEJPCI@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@ ; `string'
PUBLIC	??_C@_0CG@FABMHKKB@No?5more?5free?5memory?5to?5CreateDr@ ; `string'
PUBLIC	??_C@_0BA@GCLAIBNI@sonic?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_08IDMOMEHG@SBOSLIFE@			; `string'
PUBLIC	??_C@_08JCFNPCGH@SUPERICO@			; `string'
PUBLIC	??_C@_07BJIDCJFB@STSONIC@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_03GJIMBAPG@160@				; `string'
PUBLIC	??_C@_01COCBENDE@7@				; `string'
PUBLIC	??_C@_02KPIPOMFB@36@				; `string'
PUBLIC	??_C@_02DAMOKLOI@28@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_03GNABGMEE@100@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_02PPBOIJDM@60@				; `string'
PUBLIC	??_C@_02IHCGGLPM@15@				; `string'
PUBLIC	??_C@_0BD@CPCDCFKG@Skin?5?$CFs?5not?5found?6@	; `string'
PUBLIC	??_C@_0BD@OGFHIFCE@Skin?5?$CFd?5not?5found?6@	; `string'
PUBLIC	??_C@_03KGHEHEMH@MIN@				; `string'
PUBLIC	??_C@_03LEPPJAKI@MAX@				; `string'
PUBLIC	??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@ ; `string'
PUBLIC	??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@ ; `string'
PUBLIC	??_C@_06KPGBNHGK@S_SKIN@			; `string'
PUBLIC	??_C@_0CB@PNKLEDBE@ignored?5skin?5?$CI?$CFd?5skins?5maximum?$CJ@ ; `string'
PUBLIC	??_C@_0CB@KCPBGKKJ@R_AddSkins?3?5No?5more?5free?5memory@ ; `string'
PUBLIC	??_C@_07KHGPLMNC@skin?5?$CFd@			; `string'
PUBLIC	??_C@_04BHMHHOFG@?$AN?6?$DN?5@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_0DL@JCEPAMGD@R_AddSkins?3?5syntax?5error?5in?5S_S@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_04HGGBINEM@?$CFs?$CFd@			; `string'
PUBLIC	??_C@_04POCOPAPC@face@				; `string'
PUBLIC	??_C@_09EPPIIJIA@superface@			; `string'
PUBLIC	??_C@_08DFLEOFBA@facename@			; `string'
PUBLIC	??_C@_07CKHKDBL@ability@			; `string'
PUBLIC	??_C@_08GHBHDKDO@ability2@			; `string'
PUBLIC	??_C@_08MPILJHLH@runspeed@			; `string'
PUBLIC	??_C@_0M@LOLDGOGD@normalspeed@			; `string'
PUBLIC	??_C@_0N@LMABHIBC@thrustfactor@			; `string'
PUBLIC	??_C@_0L@JAFJCEHN@accelstart@			; `string'
PUBLIC	??_C@_0N@OKFAMOHD@acceleration@			; `string'
PUBLIC	??_C@_0L@BHBOEHCJ@superanims@			; `string'
PUBLIC	??_C@_09OBDOPNJF@superspin@			; `string'
PUBLIC	??_C@_08EGEKDPMF@thokitem@			; `string'
PUBLIC	??_C@_0O@OLMJMBP@ghostthokitem@			; `string'
PUBLIC	??_C@_08LOGINMBL@spinitem@			; `string'
PUBLIC	??_C@_0O@PGJOHPMB@ghostspinitem@		; `string'
PUBLIC	??_C@_09ICMAGONI@actionspd@			; `string'
PUBLIC	??_C@_07OJFIIEKN@mindash@			; `string'
PUBLIC	??_C@_07PDICLEM@maxdash@			; `string'
PUBLIC	??_C@_0L@LCAOKIL@startcolor@			; `string'
PUBLIC	??_C@_09POHEGMPI@prefcolor@			; `string'
PUBLIC	??_C@_0L@OIDLFJJH@jumpheight@			; `string'
PUBLIC	??_C@_07LAHGNKCJ@highres@			; `string'
PUBLIC	??_C@_06DKHPLDLO@sprite@			; `string'
PUBLIC	??_C@_0DO@PGDPAONC@R_AddSkins?3?5Unknown?5keyword?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0BB@CAFAKMAD@added?5skin?5?8?$CFs?8?6@	; `string'
PUBLIC	??_C@_0BD@BPNLPHJD@removed?5skin?5?8?$CFs?8?6@	; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_strtok:PROC
EXTRN	_stricmp:PROC
EXTRN	_strlwr:PROC
EXTRN	_strupr:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_abs:PROC
EXTRN	_atoi:PROC
EXTRN	_strlcpy:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_S_InitRuntimeSounds:PROC
EXTRN	_S_AddSoundFx:PROC
EXTRN	_P_SetScale:PROC
EXTRN	_R_PointOnSegSide:PROC
EXTRN	_R_PointToAngle:PROC
EXTRN	_R_GetPlaneLight:PROC
EXTRN	_R_RenderMaskedSegRange:PROC
EXTRN	_R_RenderThickSideRange:PROC
EXTRN	_R_PlaneBounds:PROC
EXTRN	_R_DrawSinglePlane:PROC
EXTRN	_R_InitSkinTranslationTables:PROC
EXTRN	_R_DrawColumn_8:PROC
EXTRN	_R_DrawColumn_8_ASM:PROC
EXTRN	_R_DrawColumn_8_Pentium:PROC
EXTRN	_R_DrawColumn_8_NOMMX:PROC
EXTRN	_R_DrawColumn_8_K6_MMX:PROC
EXTRN	_ST_LoadFaceGraphics:PROC
EXTRN	_ST_UnLoadFaceGraphics:PROC
EXTRN	_ST_LoadFaceNameGraphics:PROC
EXTRN	_ST_UnLoadFaceNameGraphics:PROC
EXTRN	_W_CheckNameForNumPwad:PROC
EXTRN	_W_CheckNameForNum:PROC
EXTRN	_W_CheckNumForNamePwad:PROC
EXTRN	_W_LumpLengthPwad:PROC
EXTRN	_W_ReadLumpHeaderPwad:PROC
EXTRN	_W_CacheLumpNumPwad:PROC
EXTRN	_W_CacheLumpNum:PROC
EXTRN	_W_CacheLumpNumForce:PROC
EXTRN	_W_IsLumpCached:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_Z_StrDup:PROC
EXTRN	_I_OutputMsg:PROC
EXTRN	_P_IsLocalPlayer:PROC
EXTRN	_P_SetPlayerMobjState:PROC
EXTRN	_P_SetMobjState:PROC
EXTRN	_HWR_AddPlayerMD2:PROC
EXTRN	_HWR_AddSpriteMD2:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_devparm:DWORD
EXTRN	_con_clipviewtop:DWORD
EXTRN	_S_sfx:BYTE
EXTRN	_sprnames:BYTE
EXTRN	_maptol:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_viewwidth:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_cv_playercolor:BYTE
EXTRN	_cv_skin:BYTE
EXTRN	_cv_objectplace:BYTE
EXTRN	_players:BYTE
EXTRN	_playeringame:BYTE
EXTRN	_colfunc:DWORD
EXTRN	_basecolfunc:DWORD
EXTRN	_fuzzcolfunc:DWORD
EXTRN	_transcolfunc:DWORD
EXTRN	_transtransfunc:DWORD
EXTRN	_vid:BYTE
EXTRN	_spritecachedinfo:DWORD
EXTRN	_colormaps:DWORD
EXTRN	_numspritelumps:DWORD
EXTRN	_sectors:DWORD
EXTRN	_viewx:DWORD
EXTRN	_viewy:DWORD
EXTRN	_viewz:DWORD
EXTRN	_viewsector:DWORD
EXTRN	_viewplayer:DWORD
EXTRN	_viewcos:DWORD
EXTRN	_viewsin:DWORD
EXTRN	_viewheight:DWORD
EXTRN	_centerxfrac:DWORD
EXTRN	_centeryfrac:DWORD
EXTRN	_projection:DWORD
EXTRN	_projectiony:DWORD
EXTRN	_validcount:DWORD
EXTRN	_scalelight:BYTE
EXTRN	_cv_precipdist:BYTE
EXTRN	_drawsegs:DWORD
EXTRN	_ds_p:DWORD
EXTRN	_ylookup:BYTE
EXTRN	_dc_colormap:DWORD
EXTRN	_dc_x:DWORD
EXTRN	_dc_yl:DWORD
EXTRN	_dc_yh:DWORD
EXTRN	_dc_iscale:DWORD
EXTRN	_dc_texturemid:DWORD
EXTRN	_dc_hires:BYTE
EXTRN	_dc_source:DWORD
EXTRN	_transtables:DWORD
EXTRN	_dc_transmap:DWORD
EXTRN	_translationtables:BYTE
EXTRN	_defaulttranslationtables:DWORD
EXTRN	_bosstranslationtables:DWORD
EXTRN	_dc_translation:DWORD
EXTRN	_dc_texheight:DWORD
EXTRN	_objectsdrawn:WORD
EXTRN	_numwadfiles:WORD
EXTRN	_wadfiles:BYTE
EXTRN	_rendermode:DWORD
EXTRN	_leveltime:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_spritelights DD 01H DUP (?)
_sprtemp DB	01300H DUP (?)
_maxframe DD	01H DUP (?)
_spritename DD	01H DUP (?)
_vissprites DB	038000H DUP (?)
_vissprite_p DD	01H DUP (?)
_overflowsprite DB 070H DUP (?)
_vsprsortedhead DB 070H DUP (?)
_nodebankhead DB 01cH DUP (?)
_nodehead DB	01cH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@BPNLPHJD@removed?5skin?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BD@BPNLPHJD@removed?5skin?5?8?$CFs?8?6@ DB 'removed skin ''%s''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CAFAKMAD@added?5skin?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BB@CAFAKMAD@added?5skin?5?8?$CFs?8?6@ DB 'added skin ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PGDPAONC@R_AddSkins?3?5Unknown?5keyword?5?8?$CFs@
CONST	SEGMENT
??_C@_0DO@PGDPAONC@R_AddSkins?3?5Unknown?5keyword?5?8?$CFs@ DB 'R_AddSkin'
	DB	's: Unknown keyword ''%s'' in S_SKIN lump# %d (WAD %s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKHPLDLO@sprite@
CONST	SEGMENT
??_C@_06DKHPLDLO@sprite@ DB 'sprite', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LAHGNKCJ@highres@
CONST	SEGMENT
??_C@_07LAHGNKCJ@highres@ DB 'highres', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OIDLFJJH@jumpheight@
CONST	SEGMENT
??_C@_0L@OIDLFJJH@jumpheight@ DB 'jumpheight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09POHEGMPI@prefcolor@
CONST	SEGMENT
??_C@_09POHEGMPI@prefcolor@ DB 'prefcolor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LCAOKIL@startcolor@
CONST	SEGMENT
??_C@_0L@LCAOKIL@startcolor@ DB 'startcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PDICLEM@maxdash@
CONST	SEGMENT
??_C@_07PDICLEM@maxdash@ DB 'maxdash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJFIIEKN@mindash@
CONST	SEGMENT
??_C@_07OJFIIEKN@mindash@ DB 'mindash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICMAGONI@actionspd@
CONST	SEGMENT
??_C@_09ICMAGONI@actionspd@ DB 'actionspd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PGJOHPMB@ghostspinitem@
CONST	SEGMENT
??_C@_0O@PGJOHPMB@ghostspinitem@ DB 'ghostspinitem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOGINMBL@spinitem@
CONST	SEGMENT
??_C@_08LOGINMBL@spinitem@ DB 'spinitem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLMJMBP@ghostthokitem@
CONST	SEGMENT
??_C@_0O@OLMJMBP@ghostthokitem@ DB 'ghostthokitem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGEKDPMF@thokitem@
CONST	SEGMENT
??_C@_08EGEKDPMF@thokitem@ DB 'thokitem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OBDOPNJF@superspin@
CONST	SEGMENT
??_C@_09OBDOPNJF@superspin@ DB 'superspin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHBOEHCJ@superanims@
CONST	SEGMENT
??_C@_0L@BHBOEHCJ@superanims@ DB 'superanims', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OKFAMOHD@acceleration@
CONST	SEGMENT
??_C@_0N@OKFAMOHD@acceleration@ DB 'acceleration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JAFJCEHN@accelstart@
CONST	SEGMENT
??_C@_0L@JAFJCEHN@accelstart@ DB 'accelstart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMABHIBC@thrustfactor@
CONST	SEGMENT
??_C@_0N@LMABHIBC@thrustfactor@ DB 'thrustfactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOLDGOGD@normalspeed@
CONST	SEGMENT
??_C@_0M@LOLDGOGD@normalspeed@ DB 'normalspeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPILJHLH@runspeed@
CONST	SEGMENT
??_C@_08MPILJHLH@runspeed@ DB 'runspeed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHBHDKDO@ability2@
CONST	SEGMENT
??_C@_08GHBHDKDO@ability2@ DB 'ability2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CKHKDBL@ability@
CONST	SEGMENT
??_C@_07CKHKDBL@ability@ DB 'ability', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DFLEOFBA@facename@
CONST	SEGMENT
??_C@_08DFLEOFBA@facename@ DB 'facename', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPPIIJIA@superface@
CONST	SEGMENT
??_C@_09EPPIIJIA@superface@ DB 'superface', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POCOPAPC@face@
CONST	SEGMENT
??_C@_04POCOPAPC@face@ DB 'face', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HGGBINEM@?$CFs?$CFd@
CONST	SEGMENT
??_C@_04HGGBINEM@?$CFs?$CFd@ DB '%s%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JCEPAMGD@R_AddSkins?3?5syntax?5error?5in?5S_S@
CONST	SEGMENT
??_C@_0DL@JCEPAMGD@R_AddSkins?3?5syntax?5error?5in?5S_S@ DB 'R_AddSkins: '
	DB	'syntax error in S_SKIN lump# %d(%s) in WAD %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHMHHOFG@?$AN?6?$DN?5@
CONST	SEGMENT
??_C@_04BHMHHOFG@?$AN?6?$DN?5@ DB 0dH, 0aH, '= ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHGPLMNC@skin?5?$CFd@
CONST	SEGMENT
??_C@_07KHGPLMNC@skin?5?$CFd@ DB 'skin %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KCPBGKKJ@R_AddSkins?3?5No?5more?5free?5memory@
CONST	SEGMENT
??_C@_0CB@KCPBGKKJ@R_AddSkins?3?5No?5more?5free?5memory@ DB 'R_AddSkins: '
	DB	'No more free memory', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PNKLEDBE@ignored?5skin?5?$CI?$CFd?5skins?5maximum?$CJ@
CONST	SEGMENT
??_C@_0CB@PNKLEDBE@ignored?5skin?5?$CI?$CFd?5skins?5maximum?$CJ@ DB 'igno'
	DB	'red skin (%d skins maximum)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPGBNHGK@S_SKIN@
CONST	SEGMENT
??_C@_06KPGBNHGK@S_SKIN@ DB 'S_SKIN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@
CONST	SEGMENT
??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@ DB 'V'
	DB	'ariable %s default value "%s" is not a possible value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@
CONST	SEGMENT
??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@ DB '"%'
	DB	's" is not a possible value for "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEPPJAKI@MAX@
CONST	SEGMENT
??_C@_03LEPPJAKI@MAX@ DB 'MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGHEHEMH@MIN@
CONST	SEGMENT
??_C@_03KGHEHEMH@MIN@ DB 'MIN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OGFHIFCE@Skin?5?$CFd?5not?5found?6@
CONST	SEGMENT
??_C@_0BD@OGFHIFCE@Skin?5?$CFd?5not?5found?6@ DB 'Skin %d not found', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPCDCFKG@Skin?5?$CFs?5not?5found?6@
CONST	SEGMENT
??_C@_0BD@CPCDCFKG@Skin?5?$CFs?5not?5found?6@ DB 'Skin %s not found', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15@
CONST	SEGMENT
??_C@_02IHCGGLPM@15@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPBOIJDM@60@
CONST	SEGMENT
??_C@_02PPBOIJDM@60@ DB '60', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03GNABGMEE@100@
CONST	SEGMENT
??_C@_03GNABGMEE@100@ DB '100', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5@
CONST	SEGMENT
??_C@_01BMBHCPLG@5@ DB '5', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28@
CONST	SEGMENT
??_C@_02DAMOKLOI@28@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36@
CONST	SEGMENT
??_C@_02KPIPOMFB@36@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7@
CONST	SEGMENT
??_C@_01COCBENDE@7@ DB '7', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJIMBAPG@160@
CONST	SEGMENT
??_C@_03GJIMBAPG@160@ DB '160', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJIDCJFB@STSONIC@
CONST	SEGMENT
??_C@_07BJIDCJFB@STSONIC@ DB 'STSONIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JCFNPCGH@SUPERICO@
CONST	SEGMENT
??_C@_08JCFNPCGH@SUPERICO@ DB 'SUPERICO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDMOMEHG@SBOSLIFE@
CONST	SEGMENT
??_C@_08IDMOMEHG@SBOSLIFE@ DB 'SBOSLIFE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GCLAIBNI@sonic?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
CONST	SEGMENT
??_C@_0BA@GCLAIBNI@sonic?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@ DB 'son'
	DB	'ic', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FABMHKKB@No?5more?5free?5memory?5to?5CreateDr@
CONST	SEGMENT
??_C@_0CG@FABMHKKB@No?5more?5free?5memory?5to?5CreateDr@ DB 'No more free'
	DB	' memory to CreateDrawNode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@ELEJPCI@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@
CONST	SEGMENT
??_C@_0FK@ELEJPCI@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@ DB 'Warning:'
	DB	' Mobj of type %d with invalid sprite frame (%Iu/%Iu) of %s de'
	DB	'tected and removed.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@MBOIJNDA@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@
CONST	SEGMENT
??_C@_0EO@MBOIJNDA@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@ DB 'Warning'
	DB	': Mobj of type %d with invalid sprite data (%d) detected and '
	DB	'removed.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LBNFAKMD@WARNING?3?5avoiding?5a?5crash?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CE@LBNFAKMD@WARNING?3?5avoiding?5a?5crash?5in?5?$CFs@ DB 'WARNING:'
	DB	' avoiding a crash in %s %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@MAHMJHDH@C?3?2Users?2RafaTheFox?2Desktop?2SRB@
CONST	SEGMENT
??_C@_0FF@MAHMJHDH@C?3?2Users?2RafaTheFox?2Desktop?2SRB@ DB 'C:\Users\Raf'
	DB	'aTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src'
	DB	'\r_things.c', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?first@?6??R_DrawMaskedColumn@@9@9 DD 01H		; `R_DrawMaskedColumn'::`7'::first
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??R_DrawMaskedColumn@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_DrawMaskedColumn@@9@9 DD 0239H	; `R_DrawMaskedColumn'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CJ@CCFDIMJD@R_AddSpriteDefs?3?5no?5sprites?5in?5@
CONST	SEGMENT
??_C@_0CJ@CCFDIMJD@R_AddSpriteDefs?3?5no?5sprites?5in?5@ DB 'R_AddSpriteD'
	DB	'efs: no sprites in namelist', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PFMCHJKE@?$CFIu?5sprites?5removed?5from?5file?5?$CF@
CONST	SEGMENT
??_C@_0CC@PFMCHJKE@?$CFIu?5sprites?5removed?5from?5file?5?$CF@ DB '%Iu sp'
	DB	'rites removed from file %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DDMKBGII@?$CFIu?5sprites?5added?5from?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@DDMKBGII@?$CFIu?5sprites?5added?5from?5file?5?$CFs?6@ DB '%Iu s'
	DB	'prites added from file %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JAKAEHGP@sprite?5?$CFs?5set?5in?5pwad?5?$CFd?6@
CONST	SEGMENT
??_C@_0BK@JAKAEHGP@sprite?5?$CFs?5set?5in?5pwad?5?$CFd?6@ DB 'sprite %s s'
	DB	'et in pwad %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENOHDNK@no?5sprites?5in?5pwad?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@ENOHDNK@no?5sprites?5in?5pwad?5?$CFd?6@ DB 'no sprites in pwad '
	DB	'%d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06CCMHDCM@SS_END@
CONST	SEGMENT
??_C@_06CCMHDCM@SS_END@ DB 'SS_END', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMLPPONL@S_END@
CONST	SEGMENT
??_C@_05DMLPPONL@S_END@ DB 'S_END', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJNDLFBN@SS_START@
CONST	SEGMENT
??_C@_08IJNDLFBN@SS_START@ DB 'SS_START', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBCHADGJ@S_START@
CONST	SEGMENT
??_C@_07EBCHADGJ@S_START@ DB 'S_START', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CKKDGOMC@R_AddSingleSpriteDef?3?5Sprite?5?$CFs@
CONST	SEGMENT
??_C@_0DO@CKKDGOMC@R_AddSingleSpriteDef?3?5Sprite?5?$CFs@ DB 'R_AddSingle'
	DB	'SpriteDef: Sprite %s frame %c is missing rotations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PAGKONHI@R_AddSingleSpriteDef?3?5No?5patche@
CONST	SEGMENT
??_C@_0DH@PAGKONHI@R_AddSingleSpriteDef?3?5No?5patche@ DB 'R_AddSingleSpr'
	DB	'iteDef: No patches found for %s frame %c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DJLNLEII@R_AddSingleSpriteDef?3?5too?5much?5@
CONST	SEGMENT
??_C@_0EF@DJLNLEII@R_AddSingleSpriteDef?3?5too?5much?5@ DB 'R_AddSingleSp'
	DB	'riteDef: too much sprite replacements (numspritelumps)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OJMBDFML@WARNING?$CB?5Bad?5sprite?5name?3?5?$CFs@
CONST	SEGMENT
??_C@_0BN@OJMBDFML@WARNING?$CB?5Bad?5sprite?5name?3?5?$CFs@ DB 'WARNING! '
	DB	'Bad sprite name: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BNBLKIJD@R_InitSprites?3?5Sprite?5?$CFs?3?5?$CFc?3?$CFc@
CONST	SEGMENT
??_C@_0DM@BNBLKIJD@R_InitSprites?3?5Sprite?5?$CFs?3?5?$CFc?3?$CFc@ DB 'R_'
	DB	'InitSprites: Sprite %s: %c:%c has two lumps mapped to it', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@MIEHPANO@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@
CONST	SEGMENT
??_C@_0EE@MIEHPANO@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@ DB 'R_InitSpr'
	DB	'ites: Sprite %s frame %c has rotations and a rot = 0 lump', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CJKANNFJ@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@
CONST	SEGMENT
??_C@_0DN@CJKANNFJ@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@ DB 'R_InitSpr'
	DB	'ites: Sprite %s frame %c has multiple rot = 0 lump', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FHMKOFFL@R_InstallSpriteLump?3?5Bad?5frame?5@
CONST	SEGMENT
??_C@_0DF@FHMKOFFL@R_InstallSpriteLump?3?5Bad?5frame?5@ DB 'R_InstallSpri'
	DB	'teLump: Bad frame characters in lump %s', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0417H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	094fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0469H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0106H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _W_CheckForSkinMarkerInPwad
_TEXT	SEGMENT
_lump_p$ = -12						; size = 4
_S_SKIN$ = -8						; size = 4
_i$ = -4						; size = 2
_wadid$ = 8						; size = 2
_startlump$ = 12					; size = 2
_W_CheckForSkinMarkerInPwad PROC			; COMDAT

; 2629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2630 : 	UINT16 i;
; 2631 : 	const char *S_SKIN = "S_SKIN";

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _S_SKIN$[ebp], OFFSET ??_C@_06KPGBNHGK@S_SKIN@

; 2632 : 	lumpinfo_t *lump_p;
; 2633 : 
; 2634 : 	// scan forward, start at <startlump>
; 2635 : 	if (startlump < wadfiles[wadid]->numlumps)

  00010	0f b7 45 0c	 movzx	 eax, WORD PTR _startlump$[ebp]
  00014	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadid$[ebp]
  00018	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _wadfiles[ecx*4]
  0001f	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  00023	3b c1		 cmp	 eax, ecx
  00025	7d 6f		 jge	 SHORT $LN3@W_CheckFor

; 2636 : 	{
; 2637 : 		lump_p = wadfiles[wadid]->lumpinfo + startlump;

  00027	0f b7 45 08	 movzx	 eax, WORD PTR _wadid$[ebp]
  0002b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00032	0f b7 55 0c	 movzx	 edx, WORD PTR _startlump$[ebp]
  00036	6b c2 1c	 imul	 eax, edx, 28
  00039	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0003c	89 45 f4	 mov	 DWORD PTR _lump_p$[ebp], eax

; 2638 : 		for (i = startlump; i < wadfiles[wadid]->numlumps; i++, lump_p++)

  0003f	66 8b 45 0c	 mov	 ax, WORD PTR _startlump$[ebp]
  00043	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
  00047	eb 15		 jmp	 SHORT $LN4@W_CheckFor
$LN2@W_CheckFor:
  00049	66 8b 45 fc	 mov	 ax, WORD PTR _i$[ebp]
  0004d	66 83 c0 01	 add	 ax, 1
  00051	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
  00055	8b 4d f4	 mov	 ecx, DWORD PTR _lump_p$[ebp]
  00058	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0005b	89 4d f4	 mov	 DWORD PTR _lump_p$[ebp], ecx
$LN4@W_CheckFor:
  0005e	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00062	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadid$[ebp]
  00066	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _wadfiles[ecx*4]
  0006d	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  00071	3b c1		 cmp	 eax, ecx
  00073	7d 21		 jge	 SHORT $LN3@W_CheckFor

; 2639 : 			if (memcmp(lump_p->name,S_SKIN,6)==0)

  00075	6a 06		 push	 6
  00077	8b 45 f8	 mov	 eax, DWORD PTR _S_SKIN$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _lump_p$[ebp]
  0007e	83 c1 08	 add	 ecx, 8
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 _memcmp
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	85 c0		 test	 eax, eax
  0008c	75 06		 jne	 SHORT $LN6@W_CheckFor

; 2640 : 				return i;

  0008e	66 8b 45 fc	 mov	 ax, WORD PTR _i$[ebp]
  00092	eb 07		 jmp	 SHORT $LN1@W_CheckFor
$LN6@W_CheckFor:
  00094	eb b3		 jmp	 SHORT $LN2@W_CheckFor
$LN3@W_CheckFor:

; 2641 : 	}
; 2642 : 	return INT16_MAX; // not found

  00096	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
$LN1@W_CheckFor:

; 2643 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_W_CheckForSkinMarkerInPwad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _SetSkinValues
_TEXT	SEGMENT
tv206 = -80						; size = 4
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_v$3 = -4						; size = 4
_var$ = 8						; size = 4
_valstr$ = 12						; size = 4
_valstrspace$ = 16					; size = 4
_SetSkinValues PROC					; COMDAT

; 2530 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2531 : 	if (var->PossibleValue)

  00009	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	0f 84 07 02 00
	00		 je	 $LN13@SetSkinVal

; 2532 : 	{
; 2533 : 		INT32 v = atoi(valstr);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _atoi
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR _v$3[ebp], eax

; 2534 : 
; 2535 : 		if (!stricmp(var->PossibleValue[0].strvalue, "MIN"))

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_03KGHEHEMH@MIN@
  0002a	b8 08 00 00 00	 mov	 eax, 8
  0002f	6b c8 00	 imul	 ecx, eax, 0
  00032	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00035	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00038	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _stricmp
  00042	83 c4 08	 add	 esp, 8
  00045	85 c0		 test	 eax, eax
  00047	0f 85 d0 00 00
	00		 jne	 $LN12@SetSkinVal

; 2536 : 		{   // bounded cvar
; 2537 : 			INT32 i;
; 2538 : 			// search for maximum
; 2539 : 			for (i = 1; var->PossibleValue[i].strvalue != NULL; i++)

  0004d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 1
  00054	eb 09		 jmp	 SHORT $LN4@SetSkinVal
$LN2@SetSkinVal:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@SetSkinVal:
  0005f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00062	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00065	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00068	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  0006d	74 23		 je	 SHORT $LN3@SetSkinVal

; 2540 : 				if (!stricmp(var->PossibleValue[i].strvalue, "MAX"))

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_03LEPPJAKI@MAX@
  00074	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00077	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007a	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  0007d	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _stricmp
  00087	83 c4 08	 add	 esp, 8
  0008a	85 c0		 test	 eax, eax
  0008c	75 02		 jne	 SHORT $LN14@SetSkinVal

; 2541 : 					break;

  0008e	eb 02		 jmp	 SHORT $LN3@SetSkinVal
$LN14@SetSkinVal:
  00090	eb c4		 jmp	 SHORT $LN2@SetSkinVal
$LN3@SetSkinVal:

; 2542 : 
; 2543 : 			if (v < var->PossibleValue[0].value)

  00092	b8 08 00 00 00	 mov	 eax, 8
  00097	6b c8 00	 imul	 ecx, eax, 0
  0009a	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0009d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a0	8b 55 fc	 mov	 edx, DWORD PTR _v$3[ebp]
  000a3	3b 14 08	 cmp	 edx, DWORD PTR [eax+ecx]
  000a6	7d 2d		 jge	 SHORT $LN15@SetSkinVal

; 2544 : 			{
; 2545 : 				v = var->PossibleValue[0].value;

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	6b c8 00	 imul	 ecx, eax, 0
  000b0	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  000b3	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b6	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  000b9	89 4d fc	 mov	 DWORD PTR _v$3[ebp], ecx

; 2546 : 				_snprintf(valstr, valstrspace, "%d", v);

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _v$3[ebp]
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _valstrspace$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 0c	 mov	 edx, DWORD PTR _valstr$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 __snprintf
  000d2	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@SetSkinVal:

; 2547 : 			}
; 2548 : 			if (v > var->PossibleValue[i].value)

  000d5	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  000d8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000db	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  000de	8b 45 fc	 mov	 eax, DWORD PTR _v$3[ebp]
  000e1	3b 04 d1	 cmp	 eax, DWORD PTR [ecx+edx*8]
  000e4	7e 28		 jle	 SHORT $LN16@SetSkinVal

; 2549 : 			{
; 2550 : 				v = var->PossibleValue[i].value;

  000e6	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  000e9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ec	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  000ef	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  000f2	89 45 fc	 mov	 DWORD PTR _v$3[ebp], eax

; 2551 : 				_snprintf(valstr, valstrspace, "%d", v);

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _v$3[ebp]
  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000fe	8b 4d 10	 mov	 ecx, DWORD PTR _valstrspace$[ebp]
  00101	51		 push	 ecx
  00102	8b 55 0c	 mov	 edx, DWORD PTR _valstr$[ebp]
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 __snprintf
  0010b	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@SetSkinVal:

; 2552 : 			}
; 2553 : 
; 2554 : 			valstr[valstrspace - 1] = '\0';

  0010e	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00111	03 45 10	 add	 eax, DWORD PTR _valstrspace$[ebp]
  00114	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 2555 : 		}

  00118	e9 00 01 00 00	 jmp	 $LN13@SetSkinVal
$LN12@SetSkinVal:

; 2556 : 		else
; 2557 : 		{
; 2558 : 			// waw spaghetti programming ! :)
; 2559 : 			INT32 i;
; 2560 : 
; 2561 : 			// check first strings
; 2562 : 			for (i = 0; var->PossibleValue[i].strvalue != NULL; i++)

  0011d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00124	eb 09		 jmp	 SHORT $LN7@SetSkinVal
$LN5@SetSkinVal:
  00126	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@SetSkinVal:
  0012f	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00132	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00135	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  00138	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  0013d	74 25		 je	 SHORT $LN6@SetSkinVal

; 2563 : 				if (!stricmp(var->PossibleValue[i].strvalue, valstr))

  0013f	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00142	50		 push	 eax
  00143	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00146	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00149	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0014c	8b 4c c2 04	 mov	 ecx, DWORD PTR [edx+eax*8+4]
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 _stricmp
  00156	83 c4 08	 add	 esp, 8
  00159	85 c0		 test	 eax, eax
  0015b	75 05		 jne	 SHORT $LN17@SetSkinVal

; 2564 : 					goto found;

  0015d	e9 94 00 00 00	 jmp	 $found$23
$LN17@SetSkinVal:
  00162	eb c2		 jmp	 SHORT $LN5@SetSkinVal
$LN6@SetSkinVal:

; 2565 : 			if (!v)

  00164	83 7d fc 00	 cmp	 DWORD PTR _v$3[ebp], 0
  00168	75 17		 jne	 SHORT $LN19@SetSkinVal

; 2566 : 				if (strcmp(valstr, "0"))

  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  0016f	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _strcmp
  00178	83 c4 08	 add	 esp, 8
  0017b	85 c0		 test	 eax, eax
  0017d	74 02		 je	 SHORT $LN19@SetSkinVal

; 2567 : 					goto error;

  0017f	eb 37		 jmp	 SHORT $error$24
$LN19@SetSkinVal:

; 2568 : 			// check INT32 now
; 2569 : 			for (i = 0; var->PossibleValue[i].strvalue != NULL; i++)

  00181	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00188	eb 09		 jmp	 SHORT $LN10@SetSkinVal
$LN8@SetSkinVal:
  0018a	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0018d	83 c0 01	 add	 eax, 1
  00190	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN10@SetSkinVal:
  00193	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00196	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00199	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  0019c	83 7c d1 04 00	 cmp	 DWORD PTR [ecx+edx*8+4], 0
  001a1	74 15		 je	 SHORT $error$24

; 2570 : 				if (v == var->PossibleValue[i].value)

  001a3	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001a6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001a9	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  001ac	8b 45 fc	 mov	 eax, DWORD PTR _v$3[ebp]
  001af	3b 04 d1	 cmp	 eax, DWORD PTR [ecx+edx*8]
  001b2	75 02		 jne	 SHORT $LN20@SetSkinVal

; 2571 : 					goto found;

  001b4	eb 40		 jmp	 SHORT $found$23
$LN20@SetSkinVal:
  001b6	eb d2		 jmp	 SHORT $LN8@SetSkinVal
$error$24:

; 2572 : 
; 2573 : error:
; 2574 : 			// not found
; 2575 : 			CONS_Printf("\"%s\" is not a possible value for \"%s\"\n", valstr, var->name);

  001b8	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bd	51		 push	 ecx
  001be	8b 55 0c	 mov	 edx, DWORD PTR _valstr$[ebp]
  001c1	52		 push	 edx
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DMMMIOPN@?$CC?$CFs?$CC?5is?5not?5a?5possible?5value?5fo@
  001c7	e8 00 00 00 00	 call	 _CONS_Printf
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2576 : 			if (var->defaultvalue == valstr)

  001cf	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d5	3b 4d 0c	 cmp	 ecx, DWORD PTR _valstr$[ebp]
  001d8	75 1a		 jne	 SHORT $LN21@SetSkinVal

; 2577 : 				I_Error("Variable %s default value \"%s\" is not a possible value\n",

  001da	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001dd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e0	51		 push	 ecx
  001e1	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  001e4	8b 02		 mov	 eax, DWORD PTR [edx]
  001e6	50		 push	 eax
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DCBODEDL@Variable?5?$CFs?5default?5value?5?$CC?$CFs?$CC?5@
  001ec	e8 00 00 00 00	 call	 _I_Error
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@SetSkinVal:

; 2578 : 					var->name, var->defaultvalue);
; 2579 : 			return;

  001f4	eb 7b		 jmp	 SHORT $LN1@SetSkinVal
$found$23:

; 2580 : found:
; 2581 : 			var->value = var->PossibleValue[i].value;

  001f6	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  001f9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001fc	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  001ff	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00202	8b 0c c1	 mov	 ecx, DWORD PTR [ecx+eax*8]
  00205	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 2582 : 			var->string = var->PossibleValue[i].strvalue;

  00208	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  0020b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0020e	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  00211	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00214	8b 4c c1 04	 mov	 ecx, DWORD PTR [ecx+eax*8+4]
  00218	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 2583 : 			goto finish;

  0021b	eb 45		 jmp	 SHORT $finish$25
$LN13@SetSkinVal:

; 2584 : 		}
; 2585 : 	}
; 2586 : 
; 2587 : 	// free the old value string
; 2588 : 	Z_Free(var->zstring);

  0021d	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00220	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00223	51		 push	 ecx
  00224	e8 00 00 00 00	 call	 _Z_Free
  00229	83 c4 04	 add	 esp, 4

; 2589 : 
; 2590 : 	var->string = var->zstring = Z_StrDup(valstr);

  0022c	8b 45 0c	 mov	 eax, DWORD PTR _valstr$[ebp]
  0022f	50		 push	 eax
  00230	e8 00 00 00 00	 call	 _Z_StrDup
  00235	83 c4 04	 add	 esp, 4
  00238	89 45 b0	 mov	 DWORD PTR tv206[ebp], eax
  0023b	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  0023e	8b 55 b0	 mov	 edx, DWORD PTR tv206[ebp]
  00241	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  00244	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00247	8b 4d b0	 mov	 ecx, DWORD PTR tv206[ebp]
  0024a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2591 : 
; 2592 : 	var->value = atoi(var->string);

  0024d	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00250	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00253	51		 push	 ecx
  00254	e8 00 00 00 00	 call	 _atoi
  00259	83 c4 04	 add	 esp, 4
  0025c	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0025f	89 42 14	 mov	 DWORD PTR [edx+20], eax
$finish$25:

; 2593 : 
; 2594 : finish:
; 2595 : 	var->flags |= CV_MODIFIED;

  00262	8b 45 08	 mov	 eax, DWORD PTR _var$[ebp]
  00265	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00268	83 c9 40	 or	 ecx, 64			; 00000040H
  0026b	8b 55 08	 mov	 edx, DWORD PTR _var$[ebp]
  0026e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@SetSkinVal:

; 2596 : }

  00271	5f		 pop	 edi
  00272	5e		 pop	 esi
  00273	5b		 pop	 ebx
  00274	8b e5		 mov	 esp, ebp
  00276	5d		 pop	 ebp
  00277	c3		 ret	 0
_SetSkinValues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DoSkinTranslationInit
_TEXT	SEGMENT
_i$ = -4						; size = 4
_R_DoSkinTranslationInit PROC				; COMDAT

; 2390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2391 : 	INT32 i;
; 2392 : 
; 2393 : 	for (i = 0; i <= numskins && numskins < MAXSKINS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@R_DoSkinTr
$LN2@R_DoSkinTr:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_DoSkinTr:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numskins
  00024	7f 2e		 jg	 SHORT $LN3@R_DoSkinTr
  00026	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR _numskins, 32	; 00000020H
  0002d	7d 25		 jge	 SHORT $LN3@R_DoSkinTr

; 2394 : 		R_InitSkinTranslationTables(atoi(skins[i].starttranscolor), i);

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00032	50		 push	 eax
  00033	69 4d fc ec 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 236
  0003a	81 c1 7d 00 00
	00		 add	 ecx, OFFSET _skins+125
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _atoi
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _R_InitSkinTranslationTables
  0004f	83 c4 08	 add	 esp, 8
  00052	eb be		 jmp	 SHORT $LN2@R_DoSkinTr
$LN3@R_DoSkinTr:

; 2395 : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_R_DoSkinTranslationInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _Sk_SetDefaultValue
_TEXT	SEGMENT
_i$ = -4						; size = 4
_skin$ = 8						; size = 4
_Sk_SetDefaultValue PROC				; COMDAT

; 2315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2316 : 	INT32 i;
; 2317 : 	//
; 2318 : 	// setup Sonic as default skin
; 2319 : 	//
; 2320 : 	memset(skin, 0, sizeof (skin_t));

  00009	68 ec 00 00 00	 push	 236			; 000000ecH
  0000e	6a 00		 push	 0
  00010	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2321 : 	strcpy(skin->name, DEFAULTSKIN);

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GCLAIBNI@sonic?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
  00021	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _strcpy
  0002a	83 c4 08	 add	 esp, 8

; 2322 : 	skin->wadnum = INT16_MAX;

  0002d	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _skin$[ebp]
  00035	66 89 41 1c	 mov	 WORD PTR [ecx+28], ax

; 2323 : 	strcpy(skin->sprite, "");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0003e	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00041	83 c0 1e	 add	 eax, 30			; 0000001eH
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _strcpy
  0004a	83 c4 08	 add	 esp, 8

; 2324 : 	strcpy(skin->faceprefix, "SBOSLIFE");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_08IDMOMEHG@SBOSLIFE@
  00052	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00055	83 c0 27	 add	 eax, 39			; 00000027H
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _strcpy
  0005e	83 c4 08	 add	 esp, 8

; 2325 : 	strcpy(skin->superprefix, "SUPERICO");

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_08JCFNPCGH@SUPERICO@
  00066	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00069	83 c0 30	 add	 eax, 48			; 00000030H
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _strcpy
  00072	83 c4 08	 add	 esp, 8

; 2326 : 	strcpy(skin->nameprefix, "STSONIC");

  00075	68 00 00 00 00	 push	 OFFSET ??_C@_07BJIDCJFB@STSONIC@
  0007a	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  0007d	83 c0 39	 add	 eax, 57			; 00000039H
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _strcpy
  00086	83 c4 08	 add	 esp, 8

; 2327 : 	strcpy(skin->super, "1");

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  0008e	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00091	83 c0 64	 add	 eax, 100		; 00000064H
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _strcpy
  0009a	83 c4 08	 add	 esp, 8

; 2328 : 	strcpy(skin->superanims, "1");

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  000a2	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  000a5	83 c0 66	 add	 eax, 102		; 00000066H
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _strcpy
  000ae	83 c4 08	 add	 esp, 8

; 2329 : 	strcpy(skin->superspin, "1");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  000b6	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  000b9	83 c0 68	 add	 eax, 104		; 00000068H
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _strcpy
  000c2	83 c4 08	 add	 esp, 8

; 2330 : 	strcpy(skin->starttranscolor, "160");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_03GJIMBAPG@160@
  000ca	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  000cd	83 c0 7d	 add	 eax, 125		; 0000007dH
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _strcpy
  000d6	83 c4 08	 add	 esp, 8

; 2331 : 	strcpy(skin->prefcolor, "7");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_01COCBENDE@7@
  000de	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  000e1	05 81 00 00 00	 add	 eax, 129		; 00000081H
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _strcpy
  000ec	83 c4 08	 add	 esp, 8

; 2332 : 	strcpy(skin->normalspeed, "36");

  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_02KPIPOMFB@36@
  000f4	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  000f7	83 c0 6a	 add	 eax, 106		; 0000006aH
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _strcpy
  00100	83 c4 08	 add	 esp, 8

; 2333 : 	strcpy(skin->runspeed, "28");

  00103	68 00 00 00 00	 push	 OFFSET ??_C@_02DAMOKLOI@28@
  00108	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  0010b	83 c0 6d	 add	 eax, 109		; 0000006dH
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _strcpy
  00114	83 c4 08	 add	 esp, 8

; 2334 : 	strcpy(skin->thrustfactor, "5");

  00117	68 00 00 00 00	 push	 OFFSET ??_C@_01BMBHCPLG@5@
  0011c	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  0011f	83 c0 77	 add	 eax, 119		; 00000077H
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _strcpy
  00128	83 c4 08	 add	 esp, 8

; 2335 : 	sprintf(skin->accelstart, "%d", 96>>(16-FRACBITS));

  0012b	6a 60		 push	 96			; 00000060H
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00132	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00135	83 c0 70	 add	 eax, 112		; 00000070H
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _sprintf
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2336 : 	sprintf(skin->acceleration, "%d", 40>>(16-FRACBITS));

  00141	6a 28		 push	 40			; 00000028H
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00148	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  0014b	83 c0 74	 add	 eax, 116		; 00000074H
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _sprintf
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2337 : 	strcpy(skin->jumpfactor, "100");

  00157	68 00 00 00 00	 push	 OFFSET ??_C@_03GNABGMEE@100@
  0015c	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  0015f	83 c0 79	 add	 eax, 121		; 00000079H
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _strcpy
  00168	83 c4 08	 add	 esp, 8

; 2338 : 	strcpy(skin->ability, "0");

  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  00170	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00173	83 c0 42	 add	 eax, 66			; 00000042H
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _strcpy
  0017c	83 c4 08	 add	 esp, 8

; 2339 : 	strcpy(skin->ability2, "0");

  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  00184	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00187	83 c0 44	 add	 eax, 68			; 00000044H
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _strcpy
  00190	83 c4 08	 add	 esp, 8

; 2340 : 	strcpy(skin->highres, "0");

  00193	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  00198	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  0019b	05 84 00 00 00	 add	 eax, 132		; 00000084H
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _strcpy
  001a6	83 c4 08	 add	 esp, 8

; 2341 : 	strcpy(skin->thokitem, "0");

  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  001ae	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  001b1	83 c0 46	 add	 eax, 70			; 00000046H
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _strcpy
  001ba	83 c4 08	 add	 esp, 8

; 2342 : 	strcpy(skin->ghostthokitem, "1");

  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  001c2	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  001c5	83 c0 4e	 add	 eax, 78			; 0000004eH
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 _strcpy
  001ce	83 c4 08	 add	 esp, 8

; 2343 : 	strcpy(skin->spinitem, "0");

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0@
  001d6	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  001d9	83 c0 50	 add	 eax, 80			; 00000050H
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _strcpy
  001e2	83 c4 08	 add	 esp, 8

; 2344 : 	strcpy(skin->ghostspinitem, "1");

  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1@
  001ea	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  001ed	83 c0 58	 add	 eax, 88			; 00000058H
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 _strcpy
  001f6	83 c4 08	 add	 esp, 8

; 2345 : 	strcpy(skin->actionspd, "60");

  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_02PPBOIJDM@60@
  001fe	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00201	83 c0 5a	 add	 eax, 90			; 0000005aH
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 _strcpy
  0020a	83 c4 08	 add	 esp, 8

; 2346 : 	strcpy(skin->maxdash, "60");

  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_02PPBOIJDM@60@
  00212	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00215	83 c0 61	 add	 eax, 97			; 00000061H
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _strcpy
  0021e	83 c4 08	 add	 esp, 8

; 2347 : 	strcpy(skin->mindash, "15");

  00221	68 00 00 00 00	 push	 OFFSET ??_C@_02IHCGGLPM@15@
  00226	8b 45 08	 mov	 eax, DWORD PTR _skin$[ebp]
  00229	83 c0 5e	 add	 eax, 94			; 0000005eH
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _strcpy
  00232	83 c4 08	 add	 esp, 8

; 2348 : 
; 2349 : 	for (i = 0; i < sfx_skinsoundslot0; i++)

  00235	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0023c	eb 09		 jmp	 SHORT $LN4@Sk_SetDefa
$LN2@Sk_SetDefa:
  0023e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00241	83 c0 01	 add	 eax, 1
  00244	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Sk_SetDefa:
  00247	81 7d fc 43 04
	00 00		 cmp	 DWORD PTR _i$[ebp], 1091 ; 00000443H
  0024e	7d 26		 jge	 SHORT $LN3@Sk_SetDefa

; 2350 : 		if (S_sfx[i].skinsound != -1)

  00250	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00254	83 b8 1c 00 00
	00 ff		 cmp	 DWORD PTR _S_sfx[eax+28], -1
  0025b	74 17		 je	 SHORT $LN5@Sk_SetDefa

; 2351 : 			skin->soundsid[S_sfx[i].skinsound] = i;

  0025d	6b 45 fc 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00261	8b 88 1c 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+28]
  00267	8b 55 08	 mov	 edx, DWORD PTR _skin$[ebp]
  0026a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0026d	89 84 8a 88 00
	00 00		 mov	 DWORD PTR [edx+ecx*4+136], eax
$LN5@Sk_SetDefa:
  00274	eb c8		 jmp	 SHORT $LN2@Sk_SetDefa
$LN3@Sk_SetDefa:

; 2352 : 
; 2353 : 	skins[0].spritedef.numframes = sprites[SPR_PLAY].numframes;

  00276	b8 08 00 00 00	 mov	 eax, 8
  0027b	6b c8 00	 imul	 ecx, eax, 0
  0027e	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  00283	6b c2 00	 imul	 eax, edx, 0
  00286	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sprites
  0028c	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0028f	89 88 14 00 00
	00		 mov	 DWORD PTR _skins[eax+20], ecx

; 2354 : 	skins[0].spritedef.spriteframes = sprites[SPR_PLAY].spriteframes;

  00295	b8 08 00 00 00	 mov	 eax, 8
  0029a	6b c8 00	 imul	 ecx, eax, 0
  0029d	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  002a2	6b c2 00	 imul	 eax, edx, 0
  002a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sprites
  002ab	8b 4c 0a 04	 mov	 ecx, DWORD PTR [edx+ecx+4]
  002af	89 88 18 00 00
	00		 mov	 DWORD PTR _skins[eax+24], ecx

; 2355 : }

  002b5	5f		 pop	 edi
  002b6	5e		 pop	 esi
  002b7	5b		 pop	 ebx
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
_Sk_SetDefaultValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DrawPrecipitationSprite
_TEXT	SEGMENT
tv81 = -8232						; size = 4
tv80 = -8228						; size = 4
tv129 = -8228						; size = 4
tv135 = -8228						; size = 4
_silhouette$ = -7712					; size = 4
_lowscale$ = -7708					; size = 4
_scale$ = -7704						; size = 4
_r2$ = -7700						; size = 4
_r1$ = -7696						; size = 4
_x$ = -7692						; size = 4
_cliptop$ = -7688					; size = 3840
_clipbot$ = -3848					; size = 3840
_ds$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_spr$ = 8						; size = 4
_R_DrawPrecipitationSprite PROC				; COMDAT

; 2140 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 28 20 00 00	 mov	 eax, 8232		; 00002028H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 2141 : 	drawseg_t *ds;
; 2142 : 	INT16      clipbot[MAXVIDWIDTH];
; 2143 : 	INT16      cliptop[MAXVIDWIDTH];
; 2144 : 	INT32        x;
; 2145 : 	INT32        r1;
; 2146 : 	INT32        r2;
; 2147 : 	fixed_t    scale;
; 2148 : 	fixed_t    lowscale;
; 2149 : 	INT32        silhouette;
; 2150 : 
; 2151 : 	memset(clipbot,0x00,sizeof (clipbot));

  0001a	68 00 0f 00 00	 push	 3840			; 00000f00H
  0001f	6a 00		 push	 0
  00021	8d 85 f8 f0 ff
	ff		 lea	 eax, DWORD PTR _clipbot$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2152 : 	memset(cliptop,0x00,sizeof (cliptop));

  00030	68 00 0f 00 00	 push	 3840			; 00000f00H
  00035	6a 00		 push	 0
  00037	8d 85 f8 e1 ff
	ff		 lea	 eax, DWORD PTR _cliptop$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _memset
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2153 : 	for (x = spr->x1; x <= spr->x2; x++)

  00046	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00049	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004c	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00052	eb 0f		 jmp	 SHORT $LN4@R_DrawPrec
$LN2@R_DrawPrec:
  00054	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN4@R_DrawPrec:
  00063	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00066	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0006c	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0006f	7f 28		 jg	 SHORT $LN3@R_DrawPrec

; 2154 : 		clipbot[x] = cliptop[x] = -2;

  00071	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00076	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0007c	66 89 84 4d f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+ecx*2], ax
  00084	ba fe ff ff ff	 mov	 edx, -2			; fffffffeH
  00089	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0008f	66 89 94 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], dx
  00097	eb bb		 jmp	 SHORT $LN2@R_DrawPrec
$LN3@R_DrawPrec:

; 2155 : 
; 2156 : 	// Scan drawsegs from end to start for obscuring segs.
; 2157 : 	// The first drawseg that has a greater scale
; 2158 : 	//  is the clip seg.
; 2159 : 	//SoM: 4/8/2000:
; 2160 : 	// Pointer check was originally nonportable
; 2161 : 	// and buggy, by going past LEFT end of array:
; 2162 : 
; 2163 : 	//    for (ds = ds_p-1; ds >= drawsegs; ds--)    old buggy code
; 2164 : 	for (ds = ds_p; ds-- > drawsegs ;)

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_p
  0009e	89 45 f8	 mov	 DWORD PTR _ds$[ebp], eax
$LN5@R_DrawPrec:
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000a4	89 85 dc df ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _drawsegs
  000b0	89 8d d8 df ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  000b9	81 ea 7c 1f 00
	00		 sub	 edx, 8060		; 00001f7cH
  000bf	89 55 f8	 mov	 DWORD PTR _ds$[ebp], edx
  000c2	8b 85 dc df ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  000c8	3b 85 d8 df ff
	ff		 cmp	 eax, DWORD PTR tv81[ebp]
  000ce	0f 86 a1 02 00
	00		 jbe	 $LN6@R_DrawPrec

; 2165 : 	{
; 2166 : 		// determine if the drawseg obscures the sprite
; 2167 : 		if (ds->x1 > spr->x2 ||
; 2168 : 		    ds->x2 < spr->x1 ||

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  000da	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000dd	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000e0	7f 20		 jg	 SHORT $LN21@R_DrawPrec
  000e2	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  000e8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000eb	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  000ee	7c 12		 jl	 SHORT $LN21@R_DrawPrec
  000f0	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000f3	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000f7	75 0b		 jne	 SHORT $LN20@R_DrawPrec
  000f9	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000fc	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00100	75 02		 jne	 SHORT $LN20@R_DrawPrec
$LN21@R_DrawPrec:

; 2169 : 		    (!ds->silhouette &&
; 2170 : 		     !ds->maskedtexturecol))
; 2171 : 		{
; 2172 : 			// does not cover sprite
; 2173 : 			continue;

  00102	eb 9d		 jmp	 SHORT $LN5@R_DrawPrec
$LN20@R_DrawPrec:

; 2174 : 		}
; 2175 : 
; 2176 : 		r1 = ds->x1 < spr->x1 ? spr->x1 : ds->x1;

  00104	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0010a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010d	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00110	7d 0e		 jge	 SHORT $LN38@R_DrawPrec
  00112	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00115	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00118	89 8d dc df ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
  0011e	eb 0c		 jmp	 SHORT $LN39@R_DrawPrec
$LN38@R_DrawPrec:
  00120	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  00123	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00126	89 85 dc df ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
$LN39@R_DrawPrec:
  0012c	8b 8d dc df ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  00132	89 8d f0 e1 ff
	ff		 mov	 DWORD PTR _r1$[ebp], ecx

; 2177 : 		r2 = ds->x2 > spr->x2 ? spr->x2 : ds->x2;

  00138	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0013e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00141	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00144	7e 0e		 jle	 SHORT $LN40@R_DrawPrec
  00146	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00149	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0014c	89 8d dc df ff
	ff		 mov	 DWORD PTR tv135[ebp], ecx
  00152	eb 0c		 jmp	 SHORT $LN41@R_DrawPrec
$LN40@R_DrawPrec:
  00154	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  00157	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015a	89 85 dc df ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
$LN41@R_DrawPrec:
  00160	8b 8d dc df ff
	ff		 mov	 ecx, DWORD PTR tv135[ebp]
  00166	89 8d ec e1 ff
	ff		 mov	 DWORD PTR _r2$[ebp], ecx

; 2178 : 
; 2179 : 		if (ds->scale1 > ds->scale2)

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0016f	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  00172	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00175	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00178	7e 1a		 jle	 SHORT $LN22@R_DrawPrec

; 2180 : 		{
; 2181 : 			lowscale = ds->scale2;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0017d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00180	89 8d e4 e1 ff
	ff		 mov	 DWORD PTR _lowscale$[ebp], ecx

; 2182 : 			scale = ds->scale1;

  00186	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00189	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0018c	89 8d e8 e1 ff
	ff		 mov	 DWORD PTR _scale$[ebp], ecx

; 2183 : 		}

  00192	eb 18		 jmp	 SHORT $LN23@R_DrawPrec
$LN22@R_DrawPrec:

; 2184 : 		else
; 2185 : 		{
; 2186 : 			lowscale = ds->scale1;

  00194	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00197	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0019a	89 8d e4 e1 ff
	ff		 mov	 DWORD PTR _lowscale$[ebp], ecx

; 2187 : 			scale = ds->scale2;

  001a0	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  001a3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001a6	89 8d e8 e1 ff
	ff		 mov	 DWORD PTR _scale$[ebp], ecx
$LN23@R_DrawPrec:

; 2188 : 		}
; 2189 : 
; 2190 : 		if (scale < spr->scale ||

  001ac	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  001af	8b 8d e8 e1 ff
	ff		 mov	 ecx, DWORD PTR _scale$[ebp]
  001b5	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  001b8	7c 2e		 jl	 SHORT $LN25@R_DrawPrec
  001ba	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  001bd	8b 8d e4 e1 ff
	ff		 mov	 ecx, DWORD PTR _lowscale$[ebp]
  001c3	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  001c6	7d 25		 jge	 SHORT $LN24@R_DrawPrec
  001c8	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  001cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cd	51		 push	 ecx
  001ce	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  001d1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001d4	50		 push	 eax
  001d5	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  001d8	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001db	52		 push	 edx
  001dc	e8 00 00 00 00	 call	 _R_PointOnSegSide
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e4	85 c0		 test	 eax, eax
  001e6	75 05		 jne	 SHORT $LN24@R_DrawPrec
$LN25@R_DrawPrec:

; 2191 : 		    (lowscale < spr->scale &&
; 2192 : 		     !R_PointOnSegSide (spr->gx, spr->gy, ds->curline)))
; 2193 : 		{
; 2194 : 			// masked mid texture?
; 2195 : 			/*if (ds->maskedtexturecol)
; 2196 : 				R_RenderMaskedSegRange(ds, r1, r2);*/
; 2197 : 			// seg is behind sprite
; 2198 : 			continue;

  001e8	e9 b4 fe ff ff	 jmp	 $LN5@R_DrawPrec
$LN24@R_DrawPrec:

; 2199 : 		}
; 2200 : 
; 2201 : 		// clip this piece of the sprite
; 2202 : 		silhouette = ds->silhouette;

  001ed	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  001f0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001f3	89 8d e0 e1 ff
	ff		 mov	 DWORD PTR _silhouette$[ebp], ecx

; 2203 : 
; 2204 : 		if (silhouette == 1)

  001f9	83 bd e0 e1 ff
	ff 01		 cmp	 DWORD PTR _silhouette$[ebp], 1
  00200	75 63		 jne	 SHORT $LN26@R_DrawPrec

; 2205 : 		{
; 2206 : 			// bottom sil
; 2207 : 			for (x = r1; x <= r2; x++)

  00202	8b 85 f0 e1 ff
	ff		 mov	 eax, DWORD PTR _r1$[ebp]
  00208	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
  0020e	eb 0f		 jmp	 SHORT $LN10@R_DrawPrec
$LN8@R_DrawPrec:
  00210	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00216	83 c0 01	 add	 eax, 1
  00219	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN10@R_DrawPrec:
  0021f	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00225	3b 85 ec e1 ff
	ff		 cmp	 eax, DWORD PTR _r2$[ebp]
  0022b	7f 33		 jg	 SHORT $LN9@R_DrawPrec

; 2208 : 				if (clipbot[x] == -2)

  0022d	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00233	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  0023b	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0023e	75 1e		 jne	 SHORT $LN28@R_DrawPrec

; 2209 : 					clipbot[x] = ds->sprbottomclip[x];

  00240	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00243	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00246	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  0024c	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00252	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  00256	66 89 8c 55 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+edx*2], cx
$LN28@R_DrawPrec:
  0025e	eb b0		 jmp	 SHORT $LN8@R_DrawPrec
$LN9@R_DrawPrec:

; 2210 : 		}

  00260	e9 0b 01 00 00	 jmp	 $LN15@R_DrawPrec
$LN26@R_DrawPrec:

; 2211 : 		else if (silhouette == 2)

  00265	83 bd e0 e1 ff
	ff 02		 cmp	 DWORD PTR _silhouette$[ebp], 2
  0026c	75 63		 jne	 SHORT $LN29@R_DrawPrec

; 2212 : 		{
; 2213 : 			// top sil
; 2214 : 			for (x = r1; x <= r2; x++)

  0026e	8b 85 f0 e1 ff
	ff		 mov	 eax, DWORD PTR _r1$[ebp]
  00274	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
  0027a	eb 0f		 jmp	 SHORT $LN13@R_DrawPrec
$LN11@R_DrawPrec:
  0027c	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00282	83 c0 01	 add	 eax, 1
  00285	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN13@R_DrawPrec:
  0028b	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00291	3b 85 ec e1 ff
	ff		 cmp	 eax, DWORD PTR _r2$[ebp]
  00297	7f 33		 jg	 SHORT $LN12@R_DrawPrec

; 2215 : 				if (cliptop[x] == -2)

  00299	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0029f	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  002a7	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  002aa	75 1e		 jne	 SHORT $LN31@R_DrawPrec

; 2216 : 					cliptop[x] = ds->sprtopclip[x];

  002ac	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  002af	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002b2	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  002b8	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  002be	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  002c2	66 89 8c 55 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+edx*2], cx
$LN31@R_DrawPrec:
  002ca	eb b0		 jmp	 SHORT $LN11@R_DrawPrec
$LN12@R_DrawPrec:

; 2217 : 		}

  002cc	e9 9f 00 00 00	 jmp	 $LN15@R_DrawPrec
$LN29@R_DrawPrec:

; 2218 : 		else if (silhouette == 3)

  002d1	83 bd e0 e1 ff
	ff 03		 cmp	 DWORD PTR _silhouette$[ebp], 3
  002d8	0f 85 92 00 00
	00		 jne	 $LN15@R_DrawPrec

; 2219 : 		{
; 2220 : 			// both
; 2221 : 			for (x = r1; x <= r2; x++)

  002de	8b 85 f0 e1 ff
	ff		 mov	 eax, DWORD PTR _r1$[ebp]
  002e4	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
  002ea	eb 0f		 jmp	 SHORT $LN16@R_DrawPrec
$LN14@R_DrawPrec:
  002ec	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  002f2	83 c0 01	 add	 eax, 1
  002f5	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN16@R_DrawPrec:
  002fb	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00301	3b 85 ec e1 ff
	ff		 cmp	 eax, DWORD PTR _r2$[ebp]
  00307	7f 67		 jg	 SHORT $LN15@R_DrawPrec

; 2222 : 			{
; 2223 : 				if (clipbot[x] == -2)

  00309	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0030f	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  00317	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0031a	75 1e		 jne	 SHORT $LN33@R_DrawPrec

; 2224 : 					clipbot[x] = ds->sprbottomclip[x];

  0031c	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0031f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00322	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  00328	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0032e	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  00332	66 89 8c 55 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+edx*2], cx
$LN33@R_DrawPrec:

; 2225 : 				if (cliptop[x] == -2)

  0033a	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00340	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  00348	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0034b	75 1e		 jne	 SHORT $LN34@R_DrawPrec

; 2226 : 					cliptop[x] = ds->sprtopclip[x];

  0034d	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00350	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00353	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  00359	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0035f	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  00363	66 89 8c 55 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+edx*2], cx
$LN34@R_DrawPrec:

; 2227 : 			}

  0036b	e9 7c ff ff ff	 jmp	 $LN14@R_DrawPrec
$LN15@R_DrawPrec:

; 2228 : 		}
; 2229 : 	}

  00370	e9 2c fd ff ff	 jmp	 $LN5@R_DrawPrec
$LN6@R_DrawPrec:

; 2230 : 
; 2231 : 	// all clipping has been performed, so draw the sprite
; 2232 : 
; 2233 : 	// check for unclipped columns
; 2234 : 	for (x = spr->x1; x <= spr->x2; x++)

  00375	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00378	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0037b	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00381	eb 0f		 jmp	 SHORT $LN19@R_DrawPrec
$LN17@R_DrawPrec:
  00383	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00389	83 c0 01	 add	 eax, 1
  0038c	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN19@R_DrawPrec:
  00392	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00395	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0039b	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0039e	7f 52		 jg	 SHORT $LN18@R_DrawPrec

; 2235 : 	{
; 2236 : 		if (clipbot[x] == -2)

  003a0	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  003a6	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  003ae	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  003b1	75 15		 jne	 SHORT $LN35@R_DrawPrec

; 2237 : 			clipbot[x] = (INT16)viewheight;

  003b3	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  003b9	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _viewheight
  003c0	66 89 8c 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], cx
$LN35@R_DrawPrec:

; 2238 : 
; 2239 : 		if (cliptop[x] == -2)

  003c8	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  003ce	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  003d6	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  003d9	75 15		 jne	 SHORT $LN36@R_DrawPrec

; 2240 : 			//Fab : 26-04-98: was -1, now clips against console bottom
; 2241 : 			cliptop[x] = (INT16)con_clipviewtop;

  003db	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  003e1	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _con_clipviewtop
  003e8	66 89 8c 45 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+eax*2], cx
$LN36@R_DrawPrec:

; 2242 : 	}

  003f0	eb 91		 jmp	 SHORT $LN17@R_DrawPrec
$LN18@R_DrawPrec:

; 2243 : 
; 2244 : 	mfloorclip = clipbot;

  003f2	8d 85 f8 f0 ff
	ff		 lea	 eax, DWORD PTR _clipbot$[ebp]
  003f8	a3 00 00 00 00	 mov	 DWORD PTR _mfloorclip, eax

; 2245 : 	mceilingclip = cliptop;

  003fd	8d 85 f8 e1 ff
	ff		 lea	 eax, DWORD PTR _cliptop$[ebp]
  00403	a3 00 00 00 00	 mov	 DWORD PTR _mceilingclip, eax

; 2246 : 	R_DrawPrecipitationVisSprite(spr);

  00408	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 _R_DrawPrecipitationVisSprite
  00411	83 c4 04	 add	 esp, 4

; 2247 : }

  00414	5f		 pop	 edi
  00415	5e		 pop	 esi
  00416	5b		 pop	 ebx
  00417	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041a	33 cd		 xor	 ecx, ebp
  0041c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00421	8b e5		 mov	 esp, ebp
  00423	5d		 pop	 ebp
  00424	c3		 ret	 0
_R_DrawPrecipitationSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DrawSprite
_TEXT	SEGMENT
tv81 = -8244						; size = 4
tv80 = -8240						; size = 4
tv129 = -8240						; size = 4
tv135 = -8240						; size = 4
_phs$1 = -7724						; size = 4
_h$2 = -7720						; size = 4
_mh$3 = -7716						; size = 4
_silhouette$ = -7712					; size = 4
_lowscale$ = -7708					; size = 4
_scale$ = -7704						; size = 4
_r2$ = -7700						; size = 4
_r1$ = -7696						; size = 4
_x$ = -7692						; size = 4
_cliptop$ = -7688					; size = 3840
_clipbot$ = -3848					; size = 3840
_ds$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_spr$ = 8						; size = 4
_R_DrawSprite PROC					; COMDAT

; 1955 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 34 20 00 00	 mov	 eax, 8244		; 00002034H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 1956 : 	drawseg_t *ds;
; 1957 : 	INT16      clipbot[MAXVIDWIDTH];
; 1958 : 	INT16      cliptop[MAXVIDWIDTH];
; 1959 : 	INT32        x;
; 1960 : 	INT32        r1;
; 1961 : 	INT32        r2;
; 1962 : 	fixed_t    scale;
; 1963 : 	fixed_t    lowscale;
; 1964 : 	INT32        silhouette;
; 1965 : 
; 1966 : 	memset(clipbot,0x00,sizeof (clipbot));

  0001a	68 00 0f 00 00	 push	 3840			; 00000f00H
  0001f	6a 00		 push	 0
  00021	8d 85 f8 f0 ff
	ff		 lea	 eax, DWORD PTR _clipbot$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1967 : 	memset(cliptop,0x00,sizeof (cliptop));

  00030	68 00 0f 00 00	 push	 3840			; 00000f00H
  00035	6a 00		 push	 0
  00037	8d 85 f8 e1 ff
	ff		 lea	 eax, DWORD PTR _cliptop$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _memset
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1968 : 	for (x = spr->x1; x <= spr->x2; x++)

  00046	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00049	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004c	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00052	eb 0f		 jmp	 SHORT $LN4@R_DrawSpri
$LN2@R_DrawSpri:
  00054	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN4@R_DrawSpri:
  00063	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00066	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0006c	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0006f	7f 28		 jg	 SHORT $LN3@R_DrawSpri

; 1969 : 		clipbot[x] = cliptop[x] = -2;

  00071	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00076	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0007c	66 89 84 4d f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+ecx*2], ax
  00084	ba fe ff ff ff	 mov	 edx, -2			; fffffffeH
  00089	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0008f	66 89 94 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], dx
  00097	eb bb		 jmp	 SHORT $LN2@R_DrawSpri
$LN3@R_DrawSpri:

; 1970 : 
; 1971 : 	// Scan drawsegs from end to start for obscuring segs.
; 1972 : 	// The first drawseg that has a greater scale
; 1973 : 	//  is the clip seg.
; 1974 : 	//SoM: 4/8/2000:
; 1975 : 	// Pointer check was originally nonportable
; 1976 : 	// and buggy, by going past LEFT end of array:
; 1977 : 
; 1978 : 	//    for (ds = ds_p-1; ds >= drawsegs; ds--)    old buggy code
; 1979 : 	for (ds = ds_p; ds-- > drawsegs ;)

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_p
  0009e	89 45 f8	 mov	 DWORD PTR _ds$[ebp], eax
$LN5@R_DrawSpri:
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000a4	89 85 d0 df ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _drawsegs
  000b0	89 8d cc df ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  000b9	81 ea 7c 1f 00
	00		 sub	 edx, 8060		; 00001f7cH
  000bf	89 55 f8	 mov	 DWORD PTR _ds$[ebp], edx
  000c2	8b 85 d0 df ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  000c8	3b 85 cc df ff
	ff		 cmp	 eax, DWORD PTR tv81[ebp]
  000ce	0f 86 db 02 00
	00		 jbe	 $LN6@R_DrawSpri

; 1980 : 	{
; 1981 : 		// determine if the drawseg obscures the sprite
; 1982 : 		if (ds->x1 > spr->x2 ||
; 1983 : 		    ds->x2 < spr->x1 ||

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  000da	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000dd	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000e0	7f 20		 jg	 SHORT $LN42@R_DrawSpri
  000e2	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  000e8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000eb	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  000ee	7c 12		 jl	 SHORT $LN42@R_DrawSpri
  000f0	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000f3	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000f7	75 0b		 jne	 SHORT $LN41@R_DrawSpri
  000f9	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000fc	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00100	75 02		 jne	 SHORT $LN41@R_DrawSpri
$LN42@R_DrawSpri:

; 1984 : 		    (!ds->silhouette
; 1985 : 		     && !ds->maskedtexturecol))
; 1986 : 		{
; 1987 : 			// does not cover sprite
; 1988 : 			continue;

  00102	eb 9d		 jmp	 SHORT $LN5@R_DrawSpri
$LN41@R_DrawSpri:

; 1989 : 		}
; 1990 : 
; 1991 : 		r1 = ds->x1 < spr->x1 ? spr->x1 : ds->x1;

  00104	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0010a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010d	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00110	7d 0e		 jge	 SHORT $LN90@R_DrawSpri
  00112	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00115	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00118	89 8d d0 df ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
  0011e	eb 0c		 jmp	 SHORT $LN91@R_DrawSpri
$LN90@R_DrawSpri:
  00120	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  00123	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00126	89 85 d0 df ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
$LN91@R_DrawSpri:
  0012c	8b 8d d0 df ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  00132	89 8d f0 e1 ff
	ff		 mov	 DWORD PTR _r1$[ebp], ecx

; 1992 : 		r2 = ds->x2 > spr->x2 ? spr->x2 : ds->x2;

  00138	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0013e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00141	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00144	7e 0e		 jle	 SHORT $LN92@R_DrawSpri
  00146	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00149	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0014c	89 8d d0 df ff
	ff		 mov	 DWORD PTR tv135[ebp], ecx
  00152	eb 0c		 jmp	 SHORT $LN93@R_DrawSpri
$LN92@R_DrawSpri:
  00154	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  00157	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0015a	89 85 d0 df ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
$LN93@R_DrawSpri:
  00160	8b 8d d0 df ff
	ff		 mov	 ecx, DWORD PTR tv135[ebp]
  00166	89 8d ec e1 ff
	ff		 mov	 DWORD PTR _r2$[ebp], ecx

; 1993 : 
; 1994 : 		if (ds->scale1 > ds->scale2)

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0016f	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  00172	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00175	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00178	7e 1a		 jle	 SHORT $LN43@R_DrawSpri

; 1995 : 		{
; 1996 : 			lowscale = ds->scale2;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0017d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00180	89 8d e4 e1 ff
	ff		 mov	 DWORD PTR _lowscale$[ebp], ecx

; 1997 : 			scale = ds->scale1;

  00186	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00189	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0018c	89 8d e8 e1 ff
	ff		 mov	 DWORD PTR _scale$[ebp], ecx

; 1998 : 		}

  00192	eb 18		 jmp	 SHORT $LN44@R_DrawSpri
$LN43@R_DrawSpri:

; 1999 : 		else
; 2000 : 		{
; 2001 : 			lowscale = ds->scale1;

  00194	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00197	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0019a	89 8d e4 e1 ff
	ff		 mov	 DWORD PTR _lowscale$[ebp], ecx

; 2002 : 			scale = ds->scale2;

  001a0	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  001a3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001a6	89 8d e8 e1 ff
	ff		 mov	 DWORD PTR _scale$[ebp], ecx
$LN44@R_DrawSpri:

; 2003 : 		}
; 2004 : 
; 2005 : 		if (scale < spr->scale ||

  001ac	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  001af	8b 8d e8 e1 ff
	ff		 mov	 ecx, DWORD PTR _scale$[ebp]
  001b5	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  001b8	7c 2e		 jl	 SHORT $LN46@R_DrawSpri
  001ba	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  001bd	8b 8d e4 e1 ff
	ff		 mov	 ecx, DWORD PTR _lowscale$[ebp]
  001c3	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  001c6	7d 25		 jge	 SHORT $LN45@R_DrawSpri
  001c8	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  001cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cd	51		 push	 ecx
  001ce	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  001d1	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001d4	50		 push	 eax
  001d5	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  001d8	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001db	52		 push	 edx
  001dc	e8 00 00 00 00	 call	 _R_PointOnSegSide
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e4	85 c0		 test	 eax, eax
  001e6	75 05		 jne	 SHORT $LN45@R_DrawSpri
$LN46@R_DrawSpri:

; 2006 : 		    (lowscale < spr->scale &&
; 2007 : 		     !R_PointOnSegSide (spr->gx, spr->gy, ds->curline)))
; 2008 : 		{
; 2009 : 			// masked mid texture?
; 2010 : 			/*if (ds->maskedtexturecol)
; 2011 : 				R_RenderMaskedSegRange (ds, r1, r2);*/
; 2012 : 			// seg is behind sprite
; 2013 : 			continue;

  001e8	e9 b4 fe ff ff	 jmp	 $LN5@R_DrawSpri
$LN45@R_DrawSpri:

; 2014 : 		}
; 2015 : 
; 2016 : 		// clip this piece of the sprite
; 2017 : 		silhouette = ds->silhouette;

  001ed	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  001f0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001f3	89 8d e0 e1 ff
	ff		 mov	 DWORD PTR _silhouette$[ebp], ecx

; 2018 : 
; 2019 : 		if (spr->gz >= ds->bsilheight)

  001f9	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  001fc	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  001ff	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00202	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00205	7c 0f		 jl	 SHORT $LN47@R_DrawSpri

; 2020 : 			silhouette &= ~SIL_BOTTOM;

  00207	8b 85 e0 e1 ff
	ff		 mov	 eax, DWORD PTR _silhouette$[ebp]
  0020d	83 e0 fe	 and	 eax, -2			; fffffffeH
  00210	89 85 e0 e1 ff
	ff		 mov	 DWORD PTR _silhouette$[ebp], eax
$LN47@R_DrawSpri:

; 2021 : 
; 2022 : 		if (spr->gzt <= ds->tsilheight)

  00216	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00219	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  0021c	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0021f	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  00222	7f 0f		 jg	 SHORT $LN48@R_DrawSpri

; 2023 : 			silhouette &= ~SIL_TOP;

  00224	8b 85 e0 e1 ff
	ff		 mov	 eax, DWORD PTR _silhouette$[ebp]
  0022a	83 e0 fd	 and	 eax, -3			; fffffffdH
  0022d	89 85 e0 e1 ff
	ff		 mov	 DWORD PTR _silhouette$[ebp], eax
$LN48@R_DrawSpri:

; 2024 : 
; 2025 : 		if (silhouette == 1)

  00233	83 bd e0 e1 ff
	ff 01		 cmp	 DWORD PTR _silhouette$[ebp], 1
  0023a	75 63		 jne	 SHORT $LN49@R_DrawSpri

; 2026 : 		{
; 2027 : 			// bottom sil
; 2028 : 			for (x = r1; x <= r2; x++)

  0023c	8b 85 f0 e1 ff
	ff		 mov	 eax, DWORD PTR _r1$[ebp]
  00242	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
  00248	eb 0f		 jmp	 SHORT $LN10@R_DrawSpri
$LN8@R_DrawSpri:
  0024a	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00250	83 c0 01	 add	 eax, 1
  00253	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN10@R_DrawSpri:
  00259	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0025f	3b 85 ec e1 ff
	ff		 cmp	 eax, DWORD PTR _r2$[ebp]
  00265	7f 33		 jg	 SHORT $LN9@R_DrawSpri

; 2029 : 				if (clipbot[x] == -2)

  00267	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0026d	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  00275	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00278	75 1e		 jne	 SHORT $LN51@R_DrawSpri

; 2030 : 					clipbot[x] = ds->sprbottomclip[x];

  0027a	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0027d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00280	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  00286	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0028c	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  00290	66 89 8c 55 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+edx*2], cx
$LN51@R_DrawSpri:
  00298	eb b0		 jmp	 SHORT $LN8@R_DrawSpri
$LN9@R_DrawSpri:

; 2031 : 		}

  0029a	e9 0b 01 00 00	 jmp	 $LN15@R_DrawSpri
$LN49@R_DrawSpri:

; 2032 : 		else if (silhouette == 2)

  0029f	83 bd e0 e1 ff
	ff 02		 cmp	 DWORD PTR _silhouette$[ebp], 2
  002a6	75 63		 jne	 SHORT $LN52@R_DrawSpri

; 2033 : 		{
; 2034 : 			// top sil
; 2035 : 			for (x = r1; x <= r2; x++)

  002a8	8b 85 f0 e1 ff
	ff		 mov	 eax, DWORD PTR _r1$[ebp]
  002ae	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
  002b4	eb 0f		 jmp	 SHORT $LN13@R_DrawSpri
$LN11@R_DrawSpri:
  002b6	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  002bc	83 c0 01	 add	 eax, 1
  002bf	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN13@R_DrawSpri:
  002c5	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  002cb	3b 85 ec e1 ff
	ff		 cmp	 eax, DWORD PTR _r2$[ebp]
  002d1	7f 33		 jg	 SHORT $LN12@R_DrawSpri

; 2036 : 				if (cliptop[x] == -2)

  002d3	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  002d9	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  002e1	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  002e4	75 1e		 jne	 SHORT $LN54@R_DrawSpri

; 2037 : 					cliptop[x] = ds->sprtopclip[x];

  002e6	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  002e9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002ec	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  002f2	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  002f8	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  002fc	66 89 8c 55 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+edx*2], cx
$LN54@R_DrawSpri:
  00304	eb b0		 jmp	 SHORT $LN11@R_DrawSpri
$LN12@R_DrawSpri:

; 2038 : 		}

  00306	e9 9f 00 00 00	 jmp	 $LN15@R_DrawSpri
$LN52@R_DrawSpri:

; 2039 : 		else if (silhouette == 3)

  0030b	83 bd e0 e1 ff
	ff 03		 cmp	 DWORD PTR _silhouette$[ebp], 3
  00312	0f 85 92 00 00
	00		 jne	 $LN15@R_DrawSpri

; 2040 : 		{
; 2041 : 			// both
; 2042 : 			for (x = r1; x <= r2; x++)

  00318	8b 85 f0 e1 ff
	ff		 mov	 eax, DWORD PTR _r1$[ebp]
  0031e	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
  00324	eb 0f		 jmp	 SHORT $LN16@R_DrawSpri
$LN14@R_DrawSpri:
  00326	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0032c	83 c0 01	 add	 eax, 1
  0032f	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN16@R_DrawSpri:
  00335	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0033b	3b 85 ec e1 ff
	ff		 cmp	 eax, DWORD PTR _r2$[ebp]
  00341	7f 67		 jg	 SHORT $LN15@R_DrawSpri

; 2043 : 			{
; 2044 : 				if (clipbot[x] == -2)

  00343	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00349	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  00351	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00354	75 1e		 jne	 SHORT $LN56@R_DrawSpri

; 2045 : 					clipbot[x] = ds->sprbottomclip[x];

  00356	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00359	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0035c	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  00362	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00368	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  0036c	66 89 8c 55 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+edx*2], cx
$LN56@R_DrawSpri:

; 2046 : 				if (cliptop[x] == -2)

  00374	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0037a	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  00382	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00385	75 1e		 jne	 SHORT $LN57@R_DrawSpri

; 2047 : 					cliptop[x] = ds->sprtopclip[x];

  00387	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0038a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0038d	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  00393	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00399	66 8b 0c 41	 mov	 cx, WORD PTR [ecx+eax*2]
  0039d	66 89 8c 55 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+edx*2], cx
$LN57@R_DrawSpri:

; 2048 : 			}

  003a5	e9 7c ff ff ff	 jmp	 $LN14@R_DrawSpri
$LN15@R_DrawSpri:

; 2049 : 		}
; 2050 : 	}

  003aa	e9 f2 fc ff ff	 jmp	 $LN5@R_DrawSpri
$LN6@R_DrawSpri:

; 2051 : 	//SoM: 3/17/2000: Clip sprites in water.
; 2052 : 	if (spr->heightsec != -1)  // only things in specially marked sectors

  003af	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  003b2	83 78 4c ff	 cmp	 DWORD PTR [eax+76], -1
  003b6	0f 84 24 03 00
	00		 je	 $LN27@R_DrawSpri

; 2053 : 	{
; 2054 : 		fixed_t mh, h;
; 2055 : 		INT32 phs = viewplayer->mo->subsector->sector->heightsec;

  003bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewplayer
  003c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c3	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  003c6	8b 02		 mov	 eax, DWORD PTR [edx]
  003c8	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  003cb	89 8d d4 e1 ff
	ff		 mov	 DWORD PTR _phs$1[ebp], ecx

; 2056 : 		if ((mh = sectors[spr->heightsec].floorheight) > spr->gz &&
; 2057 : 		    (h = centeryfrac - FixedMul(mh -= viewz, spr->scale)) >= 0 &&

  003d1	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  003d4	69 48 4c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+76], 248
  003db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  003e1	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  003e4	89 85 dc e1 ff
	ff		 mov	 DWORD PTR _mh$3[ebp], eax
  003ea	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  003ed	8b 95 dc e1 ff
	ff		 mov	 edx, DWORD PTR _mh$3[ebp]
  003f3	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  003f6	0f 8e 66 01 00
	00		 jle	 $LN21@R_DrawSpri
  003fc	8b 85 dc e1 ff
	ff		 mov	 eax, DWORD PTR _mh$3[ebp]
  00402	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _viewz
  00408	89 85 dc e1 ff
	ff		 mov	 DWORD PTR _mh$3[ebp], eax
  0040e	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00411	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00414	52		 push	 edx
  00415	8b 85 dc e1 ff
	ff		 mov	 eax, DWORD PTR _mh$3[ebp]
  0041b	50		 push	 eax
  0041c	e8 00 00 00 00	 call	 _FixedMul
  00421	83 c4 08	 add	 esp, 8
  00424	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  0042a	2b c8		 sub	 ecx, eax
  0042c	89 8d d8 e1 ff
	ff		 mov	 DWORD PTR _h$2[ebp], ecx
  00432	0f 88 2a 01 00
	00		 js	 $LN21@R_DrawSpri
  00438	8b 85 d8 e1 ff
	ff		 mov	 eax, DWORD PTR _h$2[ebp]
  0043e	c1 f8 10	 sar	 eax, 16			; 00000010H
  00441	89 85 d8 e1 ff
	ff		 mov	 DWORD PTR _h$2[ebp], eax
  00447	8b 8d d8 e1 ff
	ff		 mov	 ecx, DWORD PTR _h$2[ebp]
  0044d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _viewheight
  00453	0f 8d 09 01 00
	00		 jge	 $LN21@R_DrawSpri

; 2058 : 		    (h >>= FRACBITS) < viewheight)
; 2059 : 		{
; 2060 : 			if (mh <= 0 || (phs != -1 && viewz > sectors[phs].floorheight))

  00459	83 bd dc e1 ff
	ff 00		 cmp	 DWORD PTR _mh$3[ebp], 0
  00460	7e 28		 jle	 SHORT $LN62@R_DrawSpri
  00462	83 bd d4 e1 ff
	ff ff		 cmp	 DWORD PTR _phs$1[ebp], -1
  00469	0f 84 88 00 00
	00		 je	 $LN60@R_DrawSpri
  0046f	69 85 d4 e1 ff
	ff f8 00 00 00	 imul	 eax, DWORD PTR _phs$1[ebp], 248
  00479	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  0047f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00485	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  00488	7e 6d		 jle	 SHORT $LN60@R_DrawSpri
$LN62@R_DrawSpri:

; 2061 : 			{                          // clip bottom
; 2062 : 				for (x = spr->x1; x <= spr->x2; x++)

  0048a	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0048d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00490	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00496	eb 0f		 jmp	 SHORT $LN19@R_DrawSpri
$LN17@R_DrawSpri:
  00498	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0049e	83 c0 01	 add	 eax, 1
  004a1	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN19@R_DrawSpri:
  004a7	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  004aa	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  004b0	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  004b3	7f 40		 jg	 SHORT $LN18@R_DrawSpri

; 2063 : 					if (clipbot[x] == -2 || h < clipbot[x])

  004b5	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  004bb	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  004c3	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  004c6	74 16		 je	 SHORT $LN64@R_DrawSpri
  004c8	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  004ce	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  004d6	39 8d d8 e1 ff
	ff		 cmp	 DWORD PTR _h$2[ebp], ecx
  004dc	7d 15		 jge	 SHORT $LN63@R_DrawSpri
$LN64@R_DrawSpri:

; 2064 : 						clipbot[x] = (INT16)h;

  004de	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  004e4	66 8b 8d d8 e1
	ff ff		 mov	 cx, WORD PTR _h$2[ebp]
  004eb	66 89 8c 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], cx
$LN63@R_DrawSpri:
  004f3	eb a3		 jmp	 SHORT $LN17@R_DrawSpri
$LN18@R_DrawSpri:

; 2065 : 			}

  004f5	eb 6b		 jmp	 SHORT $LN21@R_DrawSpri
$LN60@R_DrawSpri:

; 2066 : 			else                        // clip top
; 2067 : 			{
; 2068 : 				for (x = spr->x1; x <= spr->x2; x++)

  004f7	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  004fa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  004fd	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00503	eb 0f		 jmp	 SHORT $LN22@R_DrawSpri
$LN20@R_DrawSpri:
  00505	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0050b	83 c0 01	 add	 eax, 1
  0050e	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN22@R_DrawSpri:
  00514	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00517	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0051d	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00520	7f 40		 jg	 SHORT $LN21@R_DrawSpri

; 2069 : 					if (cliptop[x] == -2 || h > cliptop[x])

  00522	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00528	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  00530	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00533	74 16		 je	 SHORT $LN66@R_DrawSpri
  00535	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0053b	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  00543	39 8d d8 e1 ff
	ff		 cmp	 DWORD PTR _h$2[ebp], ecx
  00549	7e 15		 jle	 SHORT $LN65@R_DrawSpri
$LN66@R_DrawSpri:

; 2070 : 						cliptop[x] = (INT16)h;

  0054b	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00551	66 8b 8d d8 e1
	ff ff		 mov	 cx, WORD PTR _h$2[ebp]
  00558	66 89 8c 45 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+eax*2], cx
$LN65@R_DrawSpri:
  00560	eb a3		 jmp	 SHORT $LN20@R_DrawSpri
$LN21@R_DrawSpri:

; 2071 : 			}
; 2072 : 		}
; 2073 : 
; 2074 : 		if ((mh = sectors[spr->heightsec].ceilingheight) < spr->gzt &&
; 2075 : 		    (h = centeryfrac - FixedMul(mh-viewz, spr->scale)) >= 0 &&

  00562	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00565	69 48 4c f8 00
	00 00		 imul	 ecx, DWORD PTR [eax+76], 248
  0056c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00572	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  00576	89 85 dc e1 ff
	ff		 mov	 DWORD PTR _mh$3[ebp], eax
  0057c	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0057f	8b 95 dc e1 ff
	ff		 mov	 edx, DWORD PTR _mh$3[ebp]
  00585	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  00588	0f 8d 52 01 00
	00		 jge	 $LN27@R_DrawSpri
  0058e	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00591	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00594	51		 push	 ecx
  00595	8b 95 dc e1 ff
	ff		 mov	 edx, DWORD PTR _mh$3[ebp]
  0059b	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _viewz
  005a1	52		 push	 edx
  005a2	e8 00 00 00 00	 call	 _FixedMul
  005a7	83 c4 08	 add	 esp, 8
  005aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  005b0	2b c8		 sub	 ecx, eax
  005b2	89 8d d8 e1 ff
	ff		 mov	 DWORD PTR _h$2[ebp], ecx
  005b8	0f 88 22 01 00
	00		 js	 $LN27@R_DrawSpri
  005be	8b 85 d8 e1 ff
	ff		 mov	 eax, DWORD PTR _h$2[ebp]
  005c4	c1 f8 10	 sar	 eax, 16			; 00000010H
  005c7	89 85 d8 e1 ff
	ff		 mov	 DWORD PTR _h$2[ebp], eax
  005cd	8b 8d d8 e1 ff
	ff		 mov	 ecx, DWORD PTR _h$2[ebp]
  005d3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _viewheight
  005d9	0f 8d 01 01 00
	00		 jge	 $LN27@R_DrawSpri

; 2076 : 		    (h >>= FRACBITS) < viewheight)
; 2077 : 		{
; 2078 : 			if (phs != -1 && viewz >= sectors[phs].ceilingheight)

  005df	83 bd d4 e1 ff
	ff ff		 cmp	 DWORD PTR _phs$1[ebp], -1
  005e6	0f 84 89 00 00
	00		 je	 $LN68@R_DrawSpri
  005ec	69 85 d4 e1 ff
	ff f8 00 00 00	 imul	 eax, DWORD PTR _phs$1[ebp], 248
  005f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  005fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00602	3b 54 01 04	 cmp	 edx, DWORD PTR [ecx+eax+4]
  00606	7c 6d		 jl	 SHORT $LN68@R_DrawSpri

; 2079 : 			{                         // clip bottom
; 2080 : 				for (x = spr->x1; x <= spr->x2; x++)

  00608	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0060b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0060e	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00614	eb 0f		 jmp	 SHORT $LN25@R_DrawSpri
$LN23@R_DrawSpri:
  00616	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0061c	83 c0 01	 add	 eax, 1
  0061f	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN25@R_DrawSpri:
  00625	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00628	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0062e	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00631	7f 40		 jg	 SHORT $LN24@R_DrawSpri

; 2081 : 					if (clipbot[x] == -2 || h < clipbot[x])

  00633	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00639	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  00641	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00644	74 16		 je	 SHORT $LN71@R_DrawSpri
  00646	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0064c	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  00654	39 8d d8 e1 ff
	ff		 cmp	 DWORD PTR _h$2[ebp], ecx
  0065a	7d 15		 jge	 SHORT $LN70@R_DrawSpri
$LN71@R_DrawSpri:

; 2082 : 						clipbot[x] = (INT16)h;

  0065c	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00662	66 8b 8d d8 e1
	ff ff		 mov	 cx, WORD PTR _h$2[ebp]
  00669	66 89 8c 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], cx
$LN70@R_DrawSpri:
  00671	eb a3		 jmp	 SHORT $LN23@R_DrawSpri
$LN24@R_DrawSpri:

; 2083 : 			}

  00673	eb 6b		 jmp	 SHORT $LN27@R_DrawSpri
$LN68@R_DrawSpri:

; 2084 : 			else                       // clip top
; 2085 : 			{
; 2086 : 				for (x = spr->x1; x <= spr->x2; x++)

  00675	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00678	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0067b	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  00681	eb 0f		 jmp	 SHORT $LN28@R_DrawSpri
$LN26@R_DrawSpri:
  00683	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00689	83 c0 01	 add	 eax, 1
  0068c	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN28@R_DrawSpri:
  00692	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00695	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  0069b	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0069e	7f 40		 jg	 SHORT $LN27@R_DrawSpri

; 2087 : 					if (cliptop[x] == -2 || h > cliptop[x])

  006a0	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  006a6	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  006ae	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  006b1	74 16		 je	 SHORT $LN73@R_DrawSpri
  006b3	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  006b9	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  006c1	39 8d d8 e1 ff
	ff		 cmp	 DWORD PTR _h$2[ebp], ecx
  006c7	7e 15		 jle	 SHORT $LN72@R_DrawSpri
$LN73@R_DrawSpri:

; 2088 : 						cliptop[x] = (INT16)h;

  006c9	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  006cf	66 8b 8d d8 e1
	ff ff		 mov	 cx, WORD PTR _h$2[ebp]
  006d6	66 89 8c 45 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+eax*2], cx
$LN72@R_DrawSpri:
  006de	eb a3		 jmp	 SHORT $LN26@R_DrawSpri
$LN27@R_DrawSpri:

; 2089 : 			}
; 2090 : 		}
; 2091 : 	}
; 2092 : 	if (spr->cut & SC_TOP && spr->cut & SC_BOTTOM)

  006e0	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  006e3	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  006e6	83 e1 01	 and	 ecx, 1
  006e9	0f 84 ca 00 00
	00		 je	 $LN74@R_DrawSpri
  006ef	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  006f2	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  006f5	83 e1 02	 and	 ecx, 2
  006f8	0f 84 bb 00 00
	00		 je	 $LN74@R_DrawSpri

; 2093 : 	{
; 2094 : 		for (x = spr->x1; x <= spr->x2; x++)

  006fe	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00701	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00704	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  0070a	eb 0f		 jmp	 SHORT $LN31@R_DrawSpri
$LN29@R_DrawSpri:
  0070c	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00712	83 c0 01	 add	 eax, 1
  00715	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN31@R_DrawSpri:
  0071b	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0071e	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  00724	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00727	0f 8f 87 00 00
	00		 jg	 $LN30@R_DrawSpri

; 2095 : 		{
; 2096 : 			if (cliptop[x] == -2 || spr->szt > cliptop[x])

  0072d	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00733	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  0073b	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0073e	74 19		 je	 SHORT $LN77@R_DrawSpri
  00740	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00743	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  00747	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  0074d	0f bf 84 55 f8
	e1 ff ff	 movsx	 eax, WORD PTR _cliptop$[ebp+edx*2]
  00755	3b c8		 cmp	 ecx, eax
  00757	7e 15		 jle	 SHORT $LN76@R_DrawSpri
$LN77@R_DrawSpri:

; 2097 : 				cliptop[x] = spr->szt;

  00759	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0075f	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00762	66 8b 51 62	 mov	 dx, WORD PTR [ecx+98]
  00766	66 89 94 45 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+eax*2], dx
$LN76@R_DrawSpri:

; 2098 : 
; 2099 : 			if (clipbot[x] == -2 || spr->sz < clipbot[x])

  0076e	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00774	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  0077c	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0077f	74 19		 je	 SHORT $LN79@R_DrawSpri
  00781	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00784	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  00788	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  0078e	0f bf 84 55 f8
	f0 ff ff	 movsx	 eax, WORD PTR _clipbot$[ebp+edx*2]
  00796	3b c8		 cmp	 ecx, eax
  00798	7d 15		 jge	 SHORT $LN78@R_DrawSpri
$LN79@R_DrawSpri:

; 2100 : 				clipbot[x] = spr->sz;

  0079a	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  007a0	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  007a3	66 8b 51 60	 mov	 dx, WORD PTR [ecx+96]
  007a7	66 89 94 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], dx
$LN78@R_DrawSpri:

; 2101 : 		}

  007af	e9 58 ff ff ff	 jmp	 $LN29@R_DrawSpri
$LN30@R_DrawSpri:

; 2102 : 	}

  007b4	e9 f4 00 00 00	 jmp	 $LN36@R_DrawSpri
$LN74@R_DrawSpri:

; 2103 : 	else if (spr->cut & SC_TOP)

  007b9	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  007bc	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  007bf	83 e1 01	 and	 ecx, 1
  007c2	74 70		 je	 SHORT $LN80@R_DrawSpri

; 2104 : 	{
; 2105 : 		for (x = spr->x1; x <= spr->x2; x++)

  007c4	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  007c7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  007ca	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  007d0	eb 0f		 jmp	 SHORT $LN34@R_DrawSpri
$LN32@R_DrawSpri:
  007d2	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  007d8	83 c0 01	 add	 eax, 1
  007db	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN34@R_DrawSpri:
  007e1	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  007e4	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  007ea	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  007ed	7f 43		 jg	 SHORT $LN33@R_DrawSpri

; 2106 : 		{
; 2107 : 			if (cliptop[x] == -2 || spr->szt > cliptop[x])

  007ef	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  007f5	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  007fd	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00800	74 19		 je	 SHORT $LN83@R_DrawSpri
  00802	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00805	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  00809	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  0080f	0f bf 84 55 f8
	e1 ff ff	 movsx	 eax, WORD PTR _cliptop$[ebp+edx*2]
  00817	3b c8		 cmp	 ecx, eax
  00819	7e 15		 jle	 SHORT $LN82@R_DrawSpri
$LN83@R_DrawSpri:

; 2108 : 				cliptop[x] = spr->szt;

  0081b	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00821	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  00824	66 8b 51 62	 mov	 dx, WORD PTR [ecx+98]
  00828	66 89 94 45 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+eax*2], dx
$LN82@R_DrawSpri:

; 2109 : 		}

  00830	eb a0		 jmp	 SHORT $LN32@R_DrawSpri
$LN33@R_DrawSpri:

; 2110 : 	}

  00832	eb 79		 jmp	 SHORT $LN36@R_DrawSpri
$LN80@R_DrawSpri:

; 2111 : 	else if (spr->cut & SC_BOTTOM)

  00834	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00837	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0083a	83 e1 02	 and	 ecx, 2
  0083d	74 6e		 je	 SHORT $LN36@R_DrawSpri

; 2112 : 	{
; 2113 : 		for (x = spr->x1; x <= spr->x2; x++)

  0083f	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00842	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00845	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  0084b	eb 0f		 jmp	 SHORT $LN37@R_DrawSpri
$LN35@R_DrawSpri:
  0084d	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00853	83 c0 01	 add	 eax, 1
  00856	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN37@R_DrawSpri:
  0085c	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0085f	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  00865	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00868	7f 43		 jg	 SHORT $LN36@R_DrawSpri

; 2114 : 		{
; 2115 : 			if (clipbot[x] == -2 || spr->sz < clipbot[x])

  0086a	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00870	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  00878	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0087b	74 19		 je	 SHORT $LN86@R_DrawSpri
  0087d	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00880	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  00884	8b 95 f4 e1 ff
	ff		 mov	 edx, DWORD PTR _x$[ebp]
  0088a	0f bf 84 55 f8
	f0 ff ff	 movsx	 eax, WORD PTR _clipbot$[ebp+edx*2]
  00892	3b c8		 cmp	 ecx, eax
  00894	7d 15		 jge	 SHORT $LN85@R_DrawSpri
$LN86@R_DrawSpri:

; 2116 : 				clipbot[x] = spr->sz;

  00896	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  0089c	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  0089f	66 8b 51 60	 mov	 dx, WORD PTR [ecx+96]
  008a3	66 89 94 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], dx
$LN85@R_DrawSpri:

; 2117 : 		}

  008ab	eb a0		 jmp	 SHORT $LN35@R_DrawSpri
$LN36@R_DrawSpri:

; 2118 : 	}
; 2119 : 
; 2120 : 	// all clipping has been performed, so draw the sprite
; 2121 : 
; 2122 : 	// check for unclipped columns
; 2123 : 	for (x = spr->x1; x <= spr->x2; x++)

  008ad	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  008b0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  008b3	89 8d f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], ecx
  008b9	eb 0f		 jmp	 SHORT $LN40@R_DrawSpri
$LN38@R_DrawSpri:
  008bb	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  008c1	83 c0 01	 add	 eax, 1
  008c4	89 85 f4 e1 ff
	ff		 mov	 DWORD PTR _x$[ebp], eax
$LN40@R_DrawSpri:
  008ca	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  008cd	8b 8d f4 e1 ff
	ff		 mov	 ecx, DWORD PTR _x$[ebp]
  008d3	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  008d6	7f 52		 jg	 SHORT $LN39@R_DrawSpri

; 2124 : 	{
; 2125 : 		if (clipbot[x] == -2)

  008d8	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  008de	0f bf 8c 45 f8
	f0 ff ff	 movsx	 ecx, WORD PTR _clipbot$[ebp+eax*2]
  008e6	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  008e9	75 15		 jne	 SHORT $LN87@R_DrawSpri

; 2126 : 			clipbot[x] = (INT16)viewheight;

  008eb	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  008f1	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _viewheight
  008f8	66 89 8c 45 f8
	f0 ff ff	 mov	 WORD PTR _clipbot$[ebp+eax*2], cx
$LN87@R_DrawSpri:

; 2127 : 
; 2128 : 		if (cliptop[x] == -2)

  00900	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00906	0f bf 8c 45 f8
	e1 ff ff	 movsx	 ecx, WORD PTR _cliptop$[ebp+eax*2]
  0090e	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00911	75 15		 jne	 SHORT $LN88@R_DrawSpri

; 2129 : 			//Fab : 26-04-98: was -1, now clips against console bottom
; 2130 : 		cliptop[x] = (INT16)con_clipviewtop;

  00913	8b 85 f4 e1 ff
	ff		 mov	 eax, DWORD PTR _x$[ebp]
  00919	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _con_clipviewtop
  00920	66 89 8c 45 f8
	e1 ff ff	 mov	 WORD PTR _cliptop$[ebp+eax*2], cx
$LN88@R_DrawSpri:

; 2131 : 	}

  00928	eb 91		 jmp	 SHORT $LN38@R_DrawSpri
$LN39@R_DrawSpri:

; 2132 : 
; 2133 : 	mfloorclip = clipbot;

  0092a	8d 85 f8 f0 ff
	ff		 lea	 eax, DWORD PTR _clipbot$[ebp]
  00930	a3 00 00 00 00	 mov	 DWORD PTR _mfloorclip, eax

; 2134 : 	mceilingclip = cliptop;

  00935	8d 85 f8 e1 ff
	ff		 lea	 eax, DWORD PTR _cliptop$[ebp]
  0093b	a3 00 00 00 00	 mov	 DWORD PTR _mceilingclip, eax

; 2135 : 	R_DrawVisSprite(spr);

  00940	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00943	50		 push	 eax
  00944	e8 00 00 00 00	 call	 _R_DrawVisSprite
  00949	83 c4 04	 add	 esp, 4

; 2136 : }

  0094c	5f		 pop	 edi
  0094d	5e		 pop	 esi
  0094e	5b		 pop	 ebx
  0094f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00952	33 cd		 xor	 ecx, ebp
  00954	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00959	8b e5		 mov	 esp, ebp
  0095b	5d		 pop	 ebp
  0095c	c3		 ret	 0
_R_DrawSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_ClearDrawNodes
_TEXT	SEGMENT
_next$ = -8						; size = 4
_rover$ = -4						; size = 4
_R_ClearDrawNodes PROC					; COMDAT

; 1928 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1929 : 	drawnode_t *rover;
; 1930 : 	drawnode_t *next;
; 1931 : 
; 1932 : 	for (rover = nodehead.next; rover != &nodehead ;)

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _nodehead+20
  0000e	89 45 fc	 mov	 DWORD PTR _rover$[ebp], eax
$LN2@R_ClearDra:
  00011	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _rover$[ebp], OFFSET _nodehead
  00018	74 1d		 je	 SHORT $LN3@R_ClearDra

; 1933 : 	{
; 1934 : 		next = rover->next;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  0001d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00020	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 1935 : 		R_DoneWithNode(rover);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _rover$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _R_DoneWithNode
  0002c	83 c4 04	 add	 esp, 4

; 1936 : 		rover = next;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00032	89 45 fc	 mov	 DWORD PTR _rover$[ebp], eax

; 1937 : 	}

  00035	eb da		 jmp	 SHORT $LN2@R_ClearDra
$LN3@R_ClearDra:

; 1938 : 
; 1939 : 	nodehead.next = nodehead.prev = &nodehead;

  00037	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nodehead+24, OFFSET _nodehead
  00041	a1 18 00 00 00	 mov	 eax, DWORD PTR _nodehead+24
  00046	a3 14 00 00 00	 mov	 DWORD PTR _nodehead+20, eax

; 1940 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_R_ClearDrawNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DoneWithNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_R_DoneWithNode PROC					; COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1922 : 	(node->next->prev = node->prev)->next = node->next;

  00009	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000f	8b 55 08	 mov	 edx, DWORD PTR _node$[ebp]
  00012	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00015	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  0001b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0001e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1923 : 	(node->next = nodebankhead.next)->prev = node;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0002d	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _nodebankhead+20
  00033	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00036	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _nodebankhead+20
  0003c	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0003f	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1924 : 	(node->prev = &nodebankhead)->next = node;

  00042	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00045	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _nodebankhead
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  0004f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00052	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00055	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1925 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_R_DoneWithNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_CreateDrawNodes
_TEXT	SEGMENT
tv67 = -132						; size = 4
tv66 = -128						; size = 4
tv284 = -128						; size = 4
tv352 = -128						; size = 4
_scale$ = -60						; size = 4
_gzm$ = -56						; size = 4
_sintersect$ = -52					; size = 4
_plane$ = -48						; size = 4
_r2$ = -44						; size = 4
_rover$ = -40						; size = 4
_delta$ = -36						; size = 4
_bestdelta$ = -32					; size = 4
_x2$ = -28						; size = 4
_x1$ = -24						; size = 4
_best$ = -20						; size = 4
_p$ = -16						; size = 4
_i$ = -12						; size = 4
_ds$ = -8						; size = 4
_entry$ = -4						; size = 4
_R_CreateDrawNodes PROC					; COMDAT

; 1695 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1696 : 	drawnode_t *entry;
; 1697 : 	drawseg_t *ds;
; 1698 : 	INT32 i, p, best, x1, x2;
; 1699 : 	fixed_t bestdelta, delta;
; 1700 : 	vissprite_t *rover;
; 1701 : 	drawnode_t *r2;
; 1702 : 	visplane_t *plane;
; 1703 : 	INT32 sintersect;
; 1704 : 	fixed_t gzm;
; 1705 : 	fixed_t scale = 0;

  0000c	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _scale$[ebp], 0

; 1706 : 
; 1707 : 	// Add the 3D floors, thicksides, and masked textures...
; 1708 : 	for (ds = ds_p; ds-- > drawsegs ;)

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _ds_p
  00018	89 45 f8	 mov	 DWORD PTR _ds$[ebp], eax
$LN2@R_CreateDr:
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0001e	89 45 80	 mov	 DWORD PTR tv66[ebp], eax
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _drawsegs
  00027	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  0002d	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  00030	81 ea 7c 1f 00
	00		 sub	 edx, 8060		; 00001f7cH
  00036	89 55 f8	 mov	 DWORD PTR _ds$[ebp], edx
  00039	8b 45 80	 mov	 eax, DWORD PTR tv66[ebp]
  0003c	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR tv67[ebp]
  00042	0f 86 ce 01 00
	00		 jbe	 $LN3@R_CreateDr

; 1709 : 	{
; 1710 : 		if (ds->numthicksides)

  00048	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0004b	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  00052	74 4e		 je	 SHORT $LN6@R_CreateDr

; 1711 : 		{
; 1712 : 			for (i = 0; i < ds->numthicksides; i++)

  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0005b	eb 09		 jmp	 SHORT $LN7@R_CreateDr
$LN5@R_CreateDr:
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00060	83 c0 01	 add	 eax, 1
  00063	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@R_CreateDr:
  00066	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0006c	3b 88 78 01 00
	00		 cmp	 ecx, DWORD PTR [eax+376]
  00072	7d 2e		 jge	 SHORT $LN6@R_CreateDr

; 1713 : 			{
; 1714 : 				entry = R_CreateDrawNode(&nodehead);

  00074	68 00 00 00 00	 push	 OFFSET _nodehead
  00079	e8 00 00 00 00	 call	 _R_CreateDrawNode
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1715 : 				entry->thickseg = ds;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  0008a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1716 : 				entry->ffloor = ds->thicksides[i];

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00090	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00093	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  00096	8b 8c 8a d4 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*4+212]
  0009d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1717 : 			}

  000a0	eb bb		 jmp	 SHORT $LN5@R_CreateDr
$LN6@R_CreateDr:

; 1718 : 		}
; 1719 : 		if (ds->maskedtexturecol)

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000a5	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  000a9	74 19		 je	 SHORT $LN24@R_CreateDr

; 1720 : 		{
; 1721 : 			entry = R_CreateDrawNode(&nodehead);

  000ab	68 00 00 00 00	 push	 OFFSET _nodehead
  000b0	e8 00 00 00 00	 call	 _R_CreateDrawNode
  000b5	83 c4 04	 add	 esp, 4
  000b8	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1722 : 			entry->seg = ds;

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  000c1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN24@R_CreateDr:

; 1723 : 		}
; 1724 : 		if (ds->numffloorplanes)

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000c7	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  000ce	0f 84 3d 01 00
	00		 je	 $LN9@R_CreateDr

; 1725 : 		{
; 1726 : 			for (i = 0; i < ds->numffloorplanes; i++)

  000d4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000db	eb 09		 jmp	 SHORT $LN10@R_CreateDr
$LN8@R_CreateDr:
  000dd	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000e0	83 c0 01	 add	 eax, 1
  000e3	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@R_CreateDr:
  000e6	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000ec	3b 88 d0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+208]
  000f2	0f 8d 19 01 00
	00		 jge	 $LN9@R_CreateDr

; 1727 : 			{
; 1728 : 				best = -1;

  000f8	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _best$[ebp], -1

; 1729 : 				bestdelta = 0;

  000ff	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bestdelta$[ebp], 0

; 1730 : 				for (p = 0; p < ds->numffloorplanes; p++)

  00106	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  0010d	eb 09		 jmp	 SHORT $LN13@R_CreateDr
$LN11@R_CreateDr:
  0010f	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00112	83 c0 01	 add	 eax, 1
  00115	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
$LN13@R_CreateDr:
  00118	8b 45 f8	 mov	 eax, DWORD PTR _ds$[ebp]
  0011b	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0011e	3b 88 d0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+208]
  00124	0f 8d a2 00 00
	00		 jge	 $LN12@R_CreateDr

; 1731 : 				{
; 1732 : 					if (!ds->ffloorplanes[p])

  0012a	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0012d	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  00130	83 7c 81 30 00	 cmp	 DWORD PTR [ecx+eax*4+48], 0
  00135	75 02		 jne	 SHORT $LN26@R_CreateDr

; 1733 : 						continue;

  00137	eb d6		 jmp	 SHORT $LN11@R_CreateDr
$LN26@R_CreateDr:

; 1734 : 					plane = ds->ffloorplanes[p];

  00139	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0013c	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  0013f	8b 54 81 30	 mov	 edx, DWORD PTR [ecx+eax*4+48]
  00143	89 55 d0	 mov	 DWORD PTR _plane$[ebp], edx

; 1735 : 					R_PlaneBounds(plane);

  00146	8b 45 d0	 mov	 eax, DWORD PTR _plane$[ebp]
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 _R_PlaneBounds
  0014f	83 c4 04	 add	 esp, 4

; 1736 : 
; 1737 : 					if (plane->low < con_clipviewtop || plane->high > vid.height || plane->high > plane->low)

  00152	8b 45 d0	 mov	 eax, DWORD PTR _plane$[ebp]
  00155	8b 88 34 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7732]
  0015b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _con_clipviewtop
  00161	7c 25		 jl	 SHORT $LN28@R_CreateDr
  00163	8b 45 d0	 mov	 eax, DWORD PTR _plane$[ebp]
  00166	8b 88 30 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7728]
  0016c	3b 0d 10 00 00
	00		 cmp	 ecx, DWORD PTR _vid+16
  00172	7f 14		 jg	 SHORT $LN28@R_CreateDr
  00174	8b 45 d0	 mov	 eax, DWORD PTR _plane$[ebp]
  00177	8b 4d d0	 mov	 ecx, DWORD PTR _plane$[ebp]
  0017a	8b 90 30 1e 00
	00		 mov	 edx, DWORD PTR [eax+7728]
  00180	3b 91 34 1e 00
	00		 cmp	 edx, DWORD PTR [ecx+7732]
  00186	7e 13		 jle	 SHORT $LN27@R_CreateDr
$LN28@R_CreateDr:

; 1738 : 					{
; 1739 : 						ds->ffloorplanes[p] = NULL;

  00188	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0018b	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  0018e	c7 44 81 30 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+48], 0

; 1740 : 						continue;

  00196	e9 74 ff ff ff	 jmp	 $LN11@R_CreateDr
$LN27@R_CreateDr:

; 1741 : 					}
; 1742 : 
; 1743 : 					delta = abs(plane->height - viewz);

  0019b	8b 45 d0	 mov	 eax, DWORD PTR _plane$[ebp]
  0019e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a1	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewz
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 _abs
  001ad	83 c4 04	 add	 esp, 4
  001b0	89 45 dc	 mov	 DWORD PTR _delta$[ebp], eax

; 1744 : 					if (delta > bestdelta)

  001b3	8b 45 dc	 mov	 eax, DWORD PTR _delta$[ebp]
  001b6	3b 45 e0	 cmp	 eax, DWORD PTR _bestdelta$[ebp]
  001b9	7e 0c		 jle	 SHORT $LN29@R_CreateDr

; 1745 : 					{
; 1746 : 						best = p;

  001bb	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  001be	89 45 ec	 mov	 DWORD PTR _best$[ebp], eax

; 1747 : 						bestdelta = delta;

  001c1	8b 45 dc	 mov	 eax, DWORD PTR _delta$[ebp]
  001c4	89 45 e0	 mov	 DWORD PTR _bestdelta$[ebp], eax
$LN29@R_CreateDr:

; 1748 : 					}
; 1749 : 				}

  001c7	e9 43 ff ff ff	 jmp	 $LN11@R_CreateDr
$LN12@R_CreateDr:

; 1750 : 				if (best != -1)

  001cc	83 7d ec ff	 cmp	 DWORD PTR _best$[ebp], -1
  001d0	74 38		 je	 SHORT $LN30@R_CreateDr

; 1751 : 				{
; 1752 : 					entry = R_CreateDrawNode(&nodehead);

  001d2	68 00 00 00 00	 push	 OFFSET _nodehead
  001d7	e8 00 00 00 00	 call	 _R_CreateDrawNode
  001dc	83 c4 04	 add	 esp, 4
  001df	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1753 : 					entry->plane = ds->ffloorplanes[best];

  001e2	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  001e5	8b 4d ec	 mov	 ecx, DWORD PTR _best$[ebp]
  001e8	8b 55 f8	 mov	 edx, DWORD PTR _ds$[ebp]
  001eb	8b 4c 8a 30	 mov	 ecx, DWORD PTR [edx+ecx*4+48]
  001ef	89 08		 mov	 DWORD PTR [eax], ecx

; 1754 : 					entry->seg = ds;

  001f1	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  001f4	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  001f7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1755 : 					ds->ffloorplanes[best] = NULL;

  001fa	8b 45 ec	 mov	 eax, DWORD PTR _best$[ebp]
  001fd	8b 4d f8	 mov	 ecx, DWORD PTR _ds$[ebp]
  00200	c7 44 81 30 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+48], 0

; 1756 : 				}

  00208	eb 02		 jmp	 SHORT $LN31@R_CreateDr
$LN30@R_CreateDr:

; 1757 : 				else
; 1758 : 					break;

  0020a	eb 05		 jmp	 SHORT $LN9@R_CreateDr
$LN31@R_CreateDr:

; 1759 : 			}

  0020c	e9 cc fe ff ff	 jmp	 $LN8@R_CreateDr
$LN9@R_CreateDr:

; 1760 : 		}
; 1761 : 	}

  00211	e9 05 fe ff ff	 jmp	 $LN2@R_CreateDr
$LN3@R_CreateDr:

; 1762 : 
; 1763 : 	if (vissprite_p == vissprites)

  00216	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _vissprite_p, OFFSET _vissprites
  00220	75 05		 jne	 SHORT $LN32@R_CreateDr

; 1764 : 		return;

  00222	e9 9f 05 00 00	 jmp	 $LN15@R_CreateDr
$LN32@R_CreateDr:

; 1765 : 
; 1766 : 	R_SortVisSprites();

  00227	e8 00 00 00 00	 call	 _R_SortVisSprites
  0022c	90		 npad	 1

; 1767 : 	for (rover = vsprsortedhead.prev; rover != &vsprsortedhead; rover = rover->prev)

  0022d	a1 00 00 00 00	 mov	 eax, DWORD PTR _vsprsortedhead
  00232	89 45 d8	 mov	 DWORD PTR _rover$[ebp], eax
  00235	eb 08		 jmp	 SHORT $LN16@R_CreateDr
$LN14@R_CreateDr:
  00237	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0023a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023c	89 4d d8	 mov	 DWORD PTR _rover$[ebp], ecx
$LN16@R_CreateDr:
  0023f	81 7d d8 00 00
	00 00		 cmp	 DWORD PTR _rover$[ebp], OFFSET _vsprsortedhead
  00246	0f 84 7a 05 00
	00		 je	 $LN15@R_CreateDr

; 1768 : 	{
; 1769 : 		if (rover->szt > vid.height || rover->sz < 0)

  0024c	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0024f	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  00253	3b 0d 10 00 00
	00		 cmp	 ecx, DWORD PTR _vid+16
  00259	7f 0b		 jg	 SHORT $LN34@R_CreateDr
  0025b	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0025e	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  00262	85 c9		 test	 ecx, ecx
  00264	7d 02		 jge	 SHORT $LN33@R_CreateDr
$LN34@R_CreateDr:

; 1770 : 			continue;

  00266	eb cf		 jmp	 SHORT $LN14@R_CreateDr
$LN33@R_CreateDr:

; 1771 : 
; 1772 : 		sintersect = (rover->x1 + rover->x2) / 2;

  00268	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0026b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0026e	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  00271	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00274	99		 cdq
  00275	2b c2		 sub	 eax, edx
  00277	d1 f8		 sar	 eax, 1
  00279	89 45 cc	 mov	 DWORD PTR _sintersect$[ebp], eax

; 1773 : 		gzm = (rover->gz + rover->gzt) / 2;

  0027c	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0027f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00282	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  00285	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  00288	99		 cdq
  00289	2b c2		 sub	 eax, edx
  0028b	d1 f8		 sar	 eax, 1
  0028d	89 45 c8	 mov	 DWORD PTR _gzm$[ebp], eax

; 1774 : 
; 1775 : 		for (r2 = nodehead.next; r2 != &nodehead; r2 = r2->next)

  00290	a1 14 00 00 00	 mov	 eax, DWORD PTR _nodehead+20
  00295	89 45 d4	 mov	 DWORD PTR _r2$[ebp], eax
  00298	eb 09		 jmp	 SHORT $LN19@R_CreateDr
$LN17@R_CreateDr:
  0029a	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0029d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002a0	89 4d d4	 mov	 DWORD PTR _r2$[ebp], ecx
$LN19@R_CreateDr:
  002a3	81 7d d4 00 00
	00 00		 cmp	 DWORD PTR _r2$[ebp], OFFSET _nodehead
  002aa	0f 84 ef 04 00
	00		 je	 $LN18@R_CreateDr

; 1776 : 		{
; 1777 : 			if (r2->plane)

  002b0	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  002b3	83 38 00	 cmp	 DWORD PTR [eax], 0
  002b6	0f 84 d6 01 00
	00		 je	 $LN35@R_CreateDr

; 1778 : 			{
; 1779 : 				if (r2->plane->minx > rover->x2 || r2->plane->maxx < rover->x1)

  002bc	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  002bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c1	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  002c4	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  002c7	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  002ca	7f 10		 jg	 SHORT $LN38@R_CreateDr
  002cc	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  002d4	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002d7	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  002da	7d 02		 jge	 SHORT $LN37@R_CreateDr
$LN38@R_CreateDr:

; 1780 : 					continue;

  002dc	eb bc		 jmp	 SHORT $LN17@R_CreateDr
$LN37@R_CreateDr:

; 1781 : 				if (rover->szt > r2->plane->low || rover->sz < r2->plane->high)

  002de	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  002e1	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  002e5	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  002e8	8b 02		 mov	 eax, DWORD PTR [edx]
  002ea	3b 88 34 1e 00
	00		 cmp	 ecx, DWORD PTR [eax+7732]
  002f0	7f 14		 jg	 SHORT $LN40@R_CreateDr
  002f2	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  002f5	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  002f9	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  002fc	8b 02		 mov	 eax, DWORD PTR [edx]
  002fe	3b 88 30 1e 00
	00		 cmp	 ecx, DWORD PTR [eax+7728]
  00304	7d 02		 jge	 SHORT $LN39@R_CreateDr
$LN40@R_CreateDr:

; 1782 : 					continue;

  00306	eb 92		 jmp	 SHORT $LN17@R_CreateDr
$LN39@R_CreateDr:

; 1783 : 
; 1784 : 				if (rover->mobjflags & MF_NOCLIPHEIGHT)

  00308	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0030b	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0030e	81 e1 00 00 80
	00		 and	 ecx, 8388608		; 00800000H
  00314	74 64		 je	 SHORT $LN41@R_CreateDr

; 1785 : 				{
; 1786 : 					//Objects with NOCLIPHEIGHT can appear halfway in.
; 1787 : 					if (r2->plane->height < viewz && rover->pz+(rover->thingheight/2) >= r2->plane->height)

  00316	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00319	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0031e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _viewz
  00324	7d 20		 jge	 SHORT $LN43@R_CreateDr
  00326	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  00329	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  0032c	99		 cdq
  0032d	2b c2		 sub	 eax, edx
  0032f	d1 f8		 sar	 eax, 1
  00331	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  00334	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  00337	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  0033a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0033c	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0033f	7c 05		 jl	 SHORT $LN43@R_CreateDr

; 1788 : 						continue;

  00341	e9 54 ff ff ff	 jmp	 $LN17@R_CreateDr
$LN43@R_CreateDr:

; 1789 : 					if (r2->plane->height > viewz && rover->pzt-(rover->thingheight/2) <= r2->plane->height)

  00346	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00349	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0034e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _viewz
  00354	7e 22		 jle	 SHORT $LN44@R_CreateDr
  00356	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  00359	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  0035c	99		 cdq
  0035d	2b c2		 sub	 eax, edx
  0035f	d1 f8		 sar	 eax, 1
  00361	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  00364	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00367	2b d0		 sub	 edx, eax
  00369	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0036c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0036e	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00371	7f 05		 jg	 SHORT $LN44@R_CreateDr

; 1790 : 						continue;

  00373	e9 22 ff ff ff	 jmp	 $LN17@R_CreateDr
$LN44@R_CreateDr:

; 1791 : 				}

  00378	eb 4a		 jmp	 SHORT $LN46@R_CreateDr
$LN41@R_CreateDr:

; 1792 : 				else
; 1793 : 				{
; 1794 : 					if (r2->plane->height < viewz && rover->pz >= r2->plane->height)

  0037a	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0037d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00382	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _viewz
  00388	7d 15		 jge	 SHORT $LN45@R_CreateDr
  0038a	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0038d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0038f	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  00392	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00395	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00398	7c 05		 jl	 SHORT $LN45@R_CreateDr

; 1795 : 						continue;

  0039a	e9 fb fe ff ff	 jmp	 $LN17@R_CreateDr
$LN45@R_CreateDr:

; 1796 : 					if (r2->plane->height > viewz && rover->pzt <= r2->plane->height)

  0039f	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  003a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003a7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _viewz
  003ad	7e 15		 jle	 SHORT $LN46@R_CreateDr
  003af	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  003b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b4	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  003b7	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  003ba	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  003bd	7f 05		 jg	 SHORT $LN46@R_CreateDr

; 1797 : 						continue;

  003bf	e9 d6 fe ff ff	 jmp	 $LN17@R_CreateDr
$LN46@R_CreateDr:

; 1798 : 				}
; 1799 : 
; 1800 : 				// SoM: NOTE: Because a visplane's shape and scale is not directly
; 1801 : 				// bound to any single linedef, a simple poll of it's frontscale is
; 1802 : 				// not adequate. We must check the entire frontscale array for any
; 1803 : 				// part that is in front of the sprite.
; 1804 : 
; 1805 : 				x1 = rover->x1;

  003c4	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  003c7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003ca	89 4d e8	 mov	 DWORD PTR _x1$[ebp], ecx

; 1806 : 				x2 = rover->x2;

  003cd	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  003d0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003d3	89 4d e4	 mov	 DWORD PTR _x2$[ebp], ecx

; 1807 : 				if (x1 < r2->plane->minx) x1 = r2->plane->minx;

  003d6	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  003d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003db	8b 55 e8	 mov	 edx, DWORD PTR _x1$[ebp]
  003de	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  003e1	7d 0b		 jge	 SHORT $LN47@R_CreateDr
  003e3	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  003e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e8	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003eb	89 55 e8	 mov	 DWORD PTR _x1$[ebp], edx
$LN47@R_CreateDr:

; 1808 : 				if (x2 > r2->plane->maxx) x2 = r2->plane->maxx;

  003ee	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  003f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f3	8b 55 e4	 mov	 edx, DWORD PTR _x2$[ebp]
  003f6	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  003f9	7e 0b		 jle	 SHORT $LN48@R_CreateDr
  003fb	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  003fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00400	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00403	89 55 e4	 mov	 DWORD PTR _x2$[ebp], edx
$LN48@R_CreateDr:

; 1809 : 
; 1810 : 				for (i = x1; i <= x2; i++)

  00406	8b 45 e8	 mov	 eax, DWORD PTR _x1$[ebp]
  00409	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  0040c	eb 09		 jmp	 SHORT $LN22@R_CreateDr
$LN20@R_CreateDr:
  0040e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00411	83 c0 01	 add	 eax, 1
  00414	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN22@R_CreateDr:
  00417	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0041a	3b 45 e4	 cmp	 eax, DWORD PTR _x2$[ebp]
  0041d	7f 1c		 jg	 SHORT $LN21@R_CreateDr

; 1811 : 				{
; 1812 : 					if (r2->seg->frontscale[i] > rover->scale)

  0041f	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00422	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00425	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00428	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0042b	8b 8c 91 7c 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+380]
  00432	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00435	7e 02		 jle	 SHORT $LN49@R_CreateDr

; 1813 : 						break;

  00437	eb 02		 jmp	 SHORT $LN21@R_CreateDr
$LN49@R_CreateDr:

; 1814 : 				}

  00439	eb d3		 jmp	 SHORT $LN20@R_CreateDr
$LN21@R_CreateDr:

; 1815 : 				if (i > x2)

  0043b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0043e	3b 45 e4	 cmp	 eax, DWORD PTR _x2$[ebp]
  00441	7e 05		 jle	 SHORT $LN50@R_CreateDr

; 1816 : 					continue;

  00443	e9 52 fe ff ff	 jmp	 $LN17@R_CreateDr
$LN50@R_CreateDr:

; 1817 : 
; 1818 : 				entry = R_CreateDrawNode(NULL);

  00448	6a 00		 push	 0
  0044a	e8 00 00 00 00	 call	 _R_CreateDrawNode
  0044f	83 c4 04	 add	 esp, 4
  00452	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1819 : 				(entry->prev = r2->prev)->next = entry;

  00455	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00458	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  0045b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0045e	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00461	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00464	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00467	8b 55 fc	 mov	 edx, DWORD PTR _entry$[ebp]
  0046a	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1820 : 				(entry->next = r2)->prev = entry;

  0046d	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00470	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  00473	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00476	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00479	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  0047c	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1821 : 				entry->sprite = rover;

  0047f	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00482	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  00485	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1822 : 				break;

  00488	e9 12 03 00 00	 jmp	 $LN18@R_CreateDr

; 1823 : 			}

  0048d	e9 08 03 00 00	 jmp	 $LN72@R_CreateDr
$LN35@R_CreateDr:

; 1824 : 			else if (r2->thickseg)

  00492	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00495	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00499	0f 84 56 01 00
	00		 je	 $LN51@R_CreateDr

; 1825 : 			{
; 1826 : 				if (rover->x1 > r2->thickseg->x2 || rover->x2 < r2->thickseg->x1)

  0049f	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  004a2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004a5	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  004a8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  004ab	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  004ae	7f 11		 jg	 SHORT $LN54@R_CreateDr
  004b0	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  004b3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004b6	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  004b9	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  004bc	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  004bf	7d 05		 jge	 SHORT $LN53@R_CreateDr
$LN54@R_CreateDr:

; 1827 : 					continue;

  004c1	e9 d4 fd ff ff	 jmp	 $LN17@R_CreateDr
$LN53@R_CreateDr:

; 1828 : 
; 1829 : 				scale = r2->thickseg->scale1 > r2->thickseg->scale2 ? r2->thickseg->scale1 : r2->thickseg->scale2;

  004c6	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  004c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004cc	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  004cf	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  004d2	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  004d5	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  004d8	7e 0e		 jle	 SHORT $LN75@R_CreateDr
  004da	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  004dd	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  004e0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  004e3	89 4d 80	 mov	 DWORD PTR tv284[ebp], ecx
  004e6	eb 0c		 jmp	 SHORT $LN76@R_CreateDr
$LN75@R_CreateDr:
  004e8	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  004eb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  004ee	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  004f1	89 4d 80	 mov	 DWORD PTR tv284[ebp], ecx
$LN76@R_CreateDr:
  004f4	8b 55 80	 mov	 edx, DWORD PTR tv284[ebp]
  004f7	89 55 c4	 mov	 DWORD PTR _scale$[ebp], edx

; 1830 : 				if (scale <= rover->scale)

  004fa	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  004fd	8b 4d c4	 mov	 ecx, DWORD PTR _scale$[ebp]
  00500	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00503	7f 05		 jg	 SHORT $LN55@R_CreateDr

; 1831 : 					continue;

  00505	e9 90 fd ff ff	 jmp	 $LN17@R_CreateDr
$LN55@R_CreateDr:

; 1832 : 				scale = r2->thickseg->scale1 + (r2->thickseg->scalestep * (sintersect - r2->thickseg->x1));

  0050a	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0050d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00510	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00513	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00516	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00519	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0051c	8b 75 cc	 mov	 esi, DWORD PTR _sintersect$[ebp]
  0051f	2b 72 04	 sub	 esi, DWORD PTR [edx+4]
  00522	0f af 70 14	 imul	 esi, DWORD PTR [eax+20]
  00526	03 71 0c	 add	 esi, DWORD PTR [ecx+12]
  00529	89 75 c4	 mov	 DWORD PTR _scale$[ebp], esi

; 1833 : 				if (scale <= rover->scale)

  0052c	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0052f	8b 4d c4	 mov	 ecx, DWORD PTR _scale$[ebp]
  00532	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00535	7f 05		 jg	 SHORT $LN56@R_CreateDr

; 1834 : 					continue;

  00537	e9 5e fd ff ff	 jmp	 $LN17@R_CreateDr
$LN56@R_CreateDr:

; 1835 : 
; 1836 : 				if ((*r2->ffloor->topheight > viewz && *r2->ffloor->bottomheight < viewz) ||
; 1837 : 				    (*r2->ffloor->topheight < viewz && rover->gzt < *r2->ffloor->topheight) ||

  0053c	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0053f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00542	8b 11		 mov	 edx, DWORD PTR [ecx]
  00544	8b 02		 mov	 eax, DWORD PTR [edx]
  00546	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewz
  0054c	7e 13		 jle	 SHORT $LN59@R_CreateDr
  0054e	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00551	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00554	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00557	8b 02		 mov	 eax, DWORD PTR [edx]
  00559	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewz
  0055f	7c 4a		 jl	 SHORT $LN58@R_CreateDr
$LN59@R_CreateDr:
  00561	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00564	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00567	8b 11		 mov	 edx, DWORD PTR [ecx]
  00569	8b 02		 mov	 eax, DWORD PTR [edx]
  0056b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewz
  00571	7d 12		 jge	 SHORT $LN60@R_CreateDr
  00573	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00576	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00579	8b 11		 mov	 edx, DWORD PTR [ecx]
  0057b	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0057e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00581	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00583	7c 26		 jl	 SHORT $LN58@R_CreateDr
$LN60@R_CreateDr:
  00585	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00588	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0058b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0058e	8b 02		 mov	 eax, DWORD PTR [edx]
  00590	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewz
  00596	7e 58		 jle	 SHORT $LN57@R_CreateDr
  00598	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0059b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0059e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005a1	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  005a4	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  005a7	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  005a9	7e 45		 jle	 SHORT $LN57@R_CreateDr
$LN58@R_CreateDr:

; 1838 : 				    (*r2->ffloor->bottomheight > viewz && rover->gz > *r2->ffloor->bottomheight))
; 1839 : 				{
; 1840 : 					entry = R_CreateDrawNode(NULL);

  005ab	6a 00		 push	 0
  005ad	e8 00 00 00 00	 call	 _R_CreateDrawNode
  005b2	83 c4 04	 add	 esp, 4
  005b5	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1841 : 					(entry->prev = r2->prev)->next = entry;

  005b8	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  005bb	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  005be	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005c1	89 50 18	 mov	 DWORD PTR [eax+24], edx
  005c4	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  005c7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005ca	8b 55 fc	 mov	 edx, DWORD PTR _entry$[ebp]
  005cd	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1842 : 					(entry->next = r2)->prev = entry;

  005d0	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  005d3	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  005d6	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  005d9	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  005dc	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  005df	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1843 : 					entry->sprite = rover;

  005e2	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  005e5	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  005e8	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1844 : 					break;

  005eb	e9 af 01 00 00	 jmp	 $LN18@R_CreateDr
$LN57@R_CreateDr:

; 1845 : 				}
; 1846 : 			}

  005f0	e9 a5 01 00 00	 jmp	 $LN72@R_CreateDr
$LN51@R_CreateDr:

; 1847 : 			else if (r2->seg)

  005f5	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  005f8	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  005fc	0f 84 e2 00 00
	00		 je	 $LN61@R_CreateDr

; 1848 : 			{
; 1849 : 				if (rover->x1 > r2->seg->x2 || rover->x2 < r2->seg->x1)

  00602	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00605	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00608	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  0060b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0060e	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00611	7f 11		 jg	 SHORT $LN64@R_CreateDr
  00613	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00616	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00619	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  0061c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0061f	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00622	7d 05		 jge	 SHORT $LN63@R_CreateDr
$LN64@R_CreateDr:

; 1850 : 					continue;

  00624	e9 71 fc ff ff	 jmp	 $LN17@R_CreateDr
$LN63@R_CreateDr:

; 1851 : 
; 1852 : 				scale = r2->seg->scale1 > r2->seg->scale2 ? r2->seg->scale1 : r2->seg->scale2;

  00629	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0062c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0062f	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00632	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00635	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00638	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0063b	7e 0e		 jle	 SHORT $LN77@R_CreateDr
  0063d	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00640	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00643	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00646	89 4d 80	 mov	 DWORD PTR tv352[ebp], ecx
  00649	eb 0c		 jmp	 SHORT $LN78@R_CreateDr
$LN77@R_CreateDr:
  0064b	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  0064e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00651	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00654	89 4d 80	 mov	 DWORD PTR tv352[ebp], ecx
$LN78@R_CreateDr:
  00657	8b 55 80	 mov	 edx, DWORD PTR tv352[ebp]
  0065a	89 55 c4	 mov	 DWORD PTR _scale$[ebp], edx

; 1853 : 				if (scale <= rover->scale)

  0065d	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  00660	8b 4d c4	 mov	 ecx, DWORD PTR _scale$[ebp]
  00663	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00666	7f 05		 jg	 SHORT $LN65@R_CreateDr

; 1854 : 					continue;

  00668	e9 2d fc ff ff	 jmp	 $LN17@R_CreateDr
$LN65@R_CreateDr:

; 1855 : 				scale = r2->seg->scale1 + (r2->seg->scalestep * (sintersect - r2->seg->x1));

  0066d	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00670	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00673	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00676	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00679	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  0067c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0067f	8b 75 cc	 mov	 esi, DWORD PTR _sintersect$[ebp]
  00682	2b 72 04	 sub	 esi, DWORD PTR [edx+4]
  00685	0f af 70 14	 imul	 esi, DWORD PTR [eax+20]
  00689	03 71 0c	 add	 esi, DWORD PTR [ecx+12]
  0068c	89 75 c4	 mov	 DWORD PTR _scale$[ebp], esi

; 1856 : 
; 1857 : 				if (rover->scale < scale)

  0068f	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  00692	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00695	3b 4d c4	 cmp	 ecx, DWORD PTR _scale$[ebp]
  00698	7d 45		 jge	 SHORT $LN66@R_CreateDr

; 1858 : 				{
; 1859 : 					entry = R_CreateDrawNode(NULL);

  0069a	6a 00		 push	 0
  0069c	e8 00 00 00 00	 call	 _R_CreateDrawNode
  006a1	83 c4 04	 add	 esp, 4
  006a4	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1860 : 					(entry->prev = r2->prev)->next = entry;

  006a7	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  006aa	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  006ad	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006b0	89 50 18	 mov	 DWORD PTR [eax+24], edx
  006b3	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  006b6	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  006b9	8b 55 fc	 mov	 edx, DWORD PTR _entry$[ebp]
  006bc	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1861 : 					(entry->next = r2)->prev = entry;

  006bf	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  006c2	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  006c5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  006c8	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  006cb	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  006ce	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1862 : 					entry->sprite = rover;

  006d1	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  006d4	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  006d7	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1863 : 					break;

  006da	e9 c0 00 00 00	 jmp	 $LN18@R_CreateDr
$LN66@R_CreateDr:

; 1864 : 				}
; 1865 : 			}

  006df	e9 b6 00 00 00	 jmp	 $LN72@R_CreateDr
$LN61@R_CreateDr:

; 1866 : 			else if (r2->sprite)

  006e4	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  006e7	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  006eb	0f 84 a9 00 00
	00		 je	 $LN72@R_CreateDr

; 1867 : 			{
; 1868 : 				if (r2->sprite->x1 > rover->x2 || r2->sprite->x2 < rover->x1)

  006f1	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  006f4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006f7	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  006fa	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  006fd	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00700	7f 11		 jg	 SHORT $LN69@R_CreateDr
  00702	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00705	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00708	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  0070b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0070e	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00711	7d 05		 jge	 SHORT $LN68@R_CreateDr
$LN69@R_CreateDr:

; 1869 : 					continue;

  00713	e9 82 fb ff ff	 jmp	 $LN17@R_CreateDr
$LN68@R_CreateDr:

; 1870 : 				if (r2->sprite->szt > rover->sz || r2->sprite->sz < rover->szt)

  00718	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0071b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0071e	0f bf 51 62	 movsx	 edx, WORD PTR [ecx+98]
  00722	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  00725	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  00729	3b d1		 cmp	 edx, ecx
  0072b	7f 15		 jg	 SHORT $LN71@R_CreateDr
  0072d	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  00730	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00733	0f bf 51 60	 movsx	 edx, WORD PTR [ecx+96]
  00737	8b 45 d8	 mov	 eax, DWORD PTR _rover$[ebp]
  0073a	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  0073e	3b d1		 cmp	 edx, ecx
  00740	7d 05		 jge	 SHORT $LN70@R_CreateDr
$LN71@R_CreateDr:

; 1871 : 					continue;

  00742	e9 53 fb ff ff	 jmp	 $LN17@R_CreateDr
$LN70@R_CreateDr:

; 1872 : 
; 1873 : 				if (r2->sprite->scale > rover->scale)

  00747	8b 45 d4	 mov	 eax, DWORD PTR _r2$[ebp]
  0074a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0074d	8b 55 d8	 mov	 edx, DWORD PTR _rover$[ebp]
  00750	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00753	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  00756	7e 42		 jle	 SHORT $LN72@R_CreateDr

; 1874 : 				{
; 1875 : 					entry = R_CreateDrawNode(NULL);

  00758	6a 00		 push	 0
  0075a	e8 00 00 00 00	 call	 _R_CreateDrawNode
  0075f	83 c4 04	 add	 esp, 4
  00762	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1876 : 					(entry->prev = r2->prev)->next = entry;

  00765	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00768	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  0076b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0076e	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00771	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00774	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00777	8b 55 fc	 mov	 edx, DWORD PTR _entry$[ebp]
  0077a	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1877 : 					(entry->next = r2)->prev = entry;

  0077d	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00780	8b 4d d4	 mov	 ecx, DWORD PTR _r2$[ebp]
  00783	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00786	8b 55 d4	 mov	 edx, DWORD PTR _r2$[ebp]
  00789	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  0078c	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1878 : 					entry->sprite = rover;

  0078f	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  00792	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  00795	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1879 : 					break;

  00798	eb 05		 jmp	 SHORT $LN18@R_CreateDr
$LN72@R_CreateDr:

; 1880 : 				}
; 1881 : 			}
; 1882 : 		}

  0079a	e9 fb fa ff ff	 jmp	 $LN17@R_CreateDr
$LN18@R_CreateDr:

; 1883 : 		if (r2 == &nodehead)

  0079f	81 7d d4 00 00
	00 00		 cmp	 DWORD PTR _r2$[ebp], OFFSET _nodehead
  007a6	75 19		 jne	 SHORT $LN73@R_CreateDr

; 1884 : 		{
; 1885 : 			entry = R_CreateDrawNode(&nodehead);

  007a8	68 00 00 00 00	 push	 OFFSET _nodehead
  007ad	e8 00 00 00 00	 call	 _R_CreateDrawNode
  007b2	83 c4 04	 add	 esp, 4
  007b5	89 45 fc	 mov	 DWORD PTR _entry$[ebp], eax

; 1886 : 			entry->sprite = rover;

  007b8	8b 45 fc	 mov	 eax, DWORD PTR _entry$[ebp]
  007bb	8b 4d d8	 mov	 ecx, DWORD PTR _rover$[ebp]
  007be	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN73@R_CreateDr:

; 1887 : 		}
; 1888 : 	}

  007c1	e9 71 fa ff ff	 jmp	 $LN14@R_CreateDr
$LN15@R_CreateDr:

; 1889 : }

  007c6	5f		 pop	 edi
  007c7	5e		 pop	 esi
  007c8	5b		 pop	 ebx
  007c9	8b e5		 mov	 esp, ebp
  007cb	5d		 pop	 ebp
  007cc	c3		 ret	 0
_R_CreateDrawNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_CreateDrawNode
_TEXT	SEGMENT
_node$ = -4						; size = 4
_link$ = 8						; size = 4
_R_CreateDrawNode PROC					; COMDAT

; 1892 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1893 : 	drawnode_t *node = nodebankhead.next;

  00009	a1 14 00 00 00	 mov	 eax, DWORD PTR _nodebankhead+20
  0000e	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1894 : 
; 1895 : 	if (node == &nodebankhead)

  00011	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _node$[ebp], OFFSET _nodebankhead
  00018	75 22		 jne	 SHORT $LN2@R_CreateDr

; 1896 : 	{
; 1897 : 		node = malloc(sizeof (*node));

  0001a	6a 1c		 push	 28			; 0000001cH
  0001c	e8 00 00 00 00	 call	 _malloc
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1898 : 		if (!node)

  00027	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  0002b	75 0d		 jne	 SHORT $LN4@R_CreateDr

; 1899 : 			I_Error("No more free memory to CreateDrawNode");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FABMHKKB@No?5more?5free?5memory?5to?5CreateDr@
  00032	e8 00 00 00 00	 call	 _I_Error
  00037	83 c4 04	 add	 esp, 4
$LN4@R_CreateDr:

; 1900 : 	}

  0003a	eb 19		 jmp	 SHORT $LN3@R_CreateDr
$LN2@R_CreateDr:

; 1901 : 	else
; 1902 : 		(nodebankhead.next = node->next)->prev = &nodebankhead;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0003f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00042	89 0d 14 00 00
	00		 mov	 DWORD PTR _nodebankhead+20, ecx
  00048	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _nodebankhead+20
  0004e	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET _nodebankhead
$LN3@R_CreateDr:

; 1903 : 
; 1904 : 	if (link)

  00055	83 7d 08 00	 cmp	 DWORD PTR _link$[ebp], 0
  00059	74 2a		 je	 SHORT $LN5@R_CreateDr

; 1905 : 	{
; 1906 : 		node->next = link;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _link$[ebp]
  00061	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1907 : 		node->prev = link->prev;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _link$[ebp]
  0006a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0006d	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1908 : 		link->prev->next = node;

  00070	8b 45 08	 mov	 eax, DWORD PTR _link$[ebp]
  00073	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00076	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  00079	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1909 : 		link->prev = node;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _link$[ebp]
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  00082	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN5@R_CreateDr:

; 1910 : 	}
; 1911 : 
; 1912 : 	node->plane = NULL;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00088	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1913 : 	node->seg = NULL;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00091	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1914 : 	node->thickseg = NULL;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0009b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1915 : 	node->ffloor = NULL;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000a5	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 1916 : 	node->sprite = NULL;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000af	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 1917 : 	return node;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]

; 1918 : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_R_CreateDrawNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_ProjectPrecipitationSprite
_TEXT	SEGMENT
tv262 = -132						; size = 4
tv266 = -132						; size = 4
_gzt$ = -64						; size = 4
_iscale$ = -60						; size = 4
_vis$ = -56						; size = 4
_lump$ = -52						; size = 4
_sprframe$ = -48					; size = 4
_sprdef$ = -44						; size = 4
_x2$ = -40						; size = 4
_x1$ = -36						; size = 4
_yscale$ = -32						; size = 4
_xscale$ = -28						; size = 4
_tz$ = -24						; size = 4
_tx$ = -20						; size = 4
_gyt$ = -16						; size = 4
_gxt$ = -12						; size = 4
_tr_y$ = -8						; size = 4
_tr_x$ = -4						; size = 4
_thing$ = 8						; size = 4
_R_ProjectPrecipitationSprite PROC			; COMDAT

; 1340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1341 : 	fixed_t tr_x, tr_y;
; 1342 : 	fixed_t gxt, gyt;
; 1343 : 	fixed_t tx, tz;
; 1344 : 	fixed_t xscale, yscale; //added : 02-02-98 : aaargll..if I were a math-guy!!!
; 1345 : 
; 1346 : 	INT32 x1, x2;
; 1347 : 
; 1348 : 	spritedef_t *sprdef;
; 1349 : 	spriteframe_t *sprframe;
; 1350 : 	size_t lump;
; 1351 : 
; 1352 : 	vissprite_t *vis;
; 1353 : 
; 1354 : 	fixed_t iscale;
; 1355 : 
; 1356 : 	//SoM: 3/17/2000
; 1357 : 	fixed_t gzt;
; 1358 : 
; 1359 : 	// transform the origin point
; 1360 : 	tr_x = thing->x - viewx;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewx
  00018	89 4d fc	 mov	 DWORD PTR _tr_x$[ebp], ecx

; 1361 : 	tr_y = thing->y - viewy;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewy
  00027	89 4d f8	 mov	 DWORD PTR _tr_y$[ebp], ecx

; 1362 : 
; 1363 : 	gxt = FixedMul(tr_x, viewcos);

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewcos
  0002f	50		 push	 eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _tr_x$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _FixedMul
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 f4	 mov	 DWORD PTR _gxt$[ebp], eax

; 1364 : 	gyt = -FixedMul(tr_y, viewsin);

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsin
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _tr_y$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _FixedMul
  0004e	83 c4 08	 add	 esp, 8
  00051	f7 d8		 neg	 eax
  00053	89 45 f0	 mov	 DWORD PTR _gyt$[ebp], eax

; 1365 : 
; 1366 : 	tz = gxt - gyt;

  00056	8b 45 f4	 mov	 eax, DWORD PTR _gxt$[ebp]
  00059	2b 45 f0	 sub	 eax, DWORD PTR _gyt$[ebp]
  0005c	89 45 e8	 mov	 DWORD PTR _tz$[ebp], eax

; 1367 : 
; 1368 : 	// thing is behind view plane?
; 1369 : 	if (tz < MINZ)

  0005f	81 7d e8 00 00
	04 00		 cmp	 DWORD PTR _tz$[ebp], 262144 ; 00040000H
  00066	7d 05		 jge	 SHORT $LN2@R_ProjectP

; 1370 : 		return;

  00068	e9 f7 04 00 00	 jmp	 $LN1@R_ProjectP
$LN2@R_ProjectP:

; 1371 : 
; 1372 : 	gxt = -FixedMul(tr_x, viewsin);

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsin
  00072	50		 push	 eax
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _tr_x$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _FixedMul
  0007c	83 c4 08	 add	 esp, 8
  0007f	f7 d8		 neg	 eax
  00081	89 45 f4	 mov	 DWORD PTR _gxt$[ebp], eax

; 1373 : 	gyt = FixedMul(tr_y, viewcos);

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewcos
  00089	50		 push	 eax
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _tr_y$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _FixedMul
  00093	83 c4 08	 add	 esp, 8
  00096	89 45 f0	 mov	 DWORD PTR _gyt$[ebp], eax

; 1374 : 	tx = -(gyt + gxt);

  00099	8b 45 f0	 mov	 eax, DWORD PTR _gyt$[ebp]
  0009c	03 45 f4	 add	 eax, DWORD PTR _gxt$[ebp]
  0009f	f7 d8		 neg	 eax
  000a1	89 45 ec	 mov	 DWORD PTR _tx$[ebp], eax

; 1375 : 
; 1376 : 	// too far off the side?
; 1377 : 	if (abs(tx) > tz<<2)

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _tx$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _abs
  000ad	83 c4 04	 add	 esp, 4
  000b0	8b 4d e8	 mov	 ecx, DWORD PTR _tz$[ebp]
  000b3	c1 e1 02	 shl	 ecx, 2
  000b6	3b c1		 cmp	 eax, ecx
  000b8	7e 05		 jle	 SHORT $LN3@R_ProjectP

; 1378 : 		return;

  000ba	e9 a5 04 00 00	 jmp	 $LN1@R_ProjectP
$LN3@R_ProjectP:

; 1379 : 
; 1380 : 	// aspect ratio stuff :
; 1381 : 	xscale = FixedDiv(projection, tz);

  000bf	8b 45 e8	 mov	 eax, DWORD PTR _tz$[ebp]
  000c2	50		 push	 eax
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _projection
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _FixedDiv
  000cf	83 c4 08	 add	 esp, 8
  000d2	89 45 e4	 mov	 DWORD PTR _xscale$[ebp], eax

; 1382 : 	yscale = FixedDiv(projectiony, tz);

  000d5	8b 45 e8	 mov	 eax, DWORD PTR _tz$[ebp]
  000d8	50		 push	 eax
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _projectiony
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _FixedDiv
  000e5	83 c4 08	 add	 esp, 8
  000e8	89 45 e0	 mov	 DWORD PTR _yscale$[ebp], eax

; 1383 : 
; 1384 : 	// decide which patch to use for sprite relative to player
; 1385 : 	if ((unsigned)thing->sprite >= numsprites)

  000eb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ee	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000f1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numsprites
  000f7	72 05		 jb	 SHORT $LN4@R_ProjectP

; 1386 : #ifdef RANGECHECK
; 1387 : 		I_Error("R_ProjectSprite: invalid sprite number %d ",
; 1388 : 			thing->sprite);
; 1389 : #else
; 1390 : 		return;

  000f9	e9 66 04 00 00	 jmp	 $LN1@R_ProjectP
$LN4@R_ProjectP:

; 1391 : #endif
; 1392 : 
; 1393 : 	sprdef = &sprites[thing->sprite];

  000fe	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00101	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sprites
  0010a	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0010d	89 45 d4	 mov	 DWORD PTR _sprdef$[ebp], eax

; 1394 : 
; 1395 : 	if ((UINT8)(thing->frame&FF_FRAMEMASK) >= sprdef->numframes)

  00110	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00113	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00116	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  0011c	0f b6 d1	 movzx	 edx, cl
  0011f	8b 45 d4	 mov	 eax, DWORD PTR _sprdef$[ebp]
  00122	3b 10		 cmp	 edx, DWORD PTR [eax]
  00124	72 05		 jb	 SHORT $LN5@R_ProjectP

; 1396 : #ifdef RANGECHECK
; 1397 : 		I_Error("R_ProjectSprite: invalid sprite frame %d : %d for %s",
; 1398 : 			thing->sprite, thing->frame, sprnames[thing->sprite]);
; 1399 : #else
; 1400 : 		return;

  00126	e9 39 04 00 00	 jmp	 $LN1@R_ProjectP
$LN5@R_ProjectP:

; 1401 : #endif
; 1402 : 
; 1403 : 	sprframe = &sprdef->spriteframes[thing->frame & FF_FRAMEMASK];

  0012b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0012e	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00131	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  00137	6b d1 4c	 imul	 edx, ecx, 76
  0013a	8b 45 d4	 mov	 eax, DWORD PTR _sprdef$[ebp]
  0013d	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00140	89 55 d0	 mov	 DWORD PTR _sprframe$[ebp], edx

; 1404 : 
; 1405 : 	if (!sprframe)

  00143	75 05		 jne	 SHORT $LN6@R_ProjectP

; 1406 : #ifdef PARANOIA //heretic hack
; 1407 : 		I_Error("sprframes NULL for sprite %d\n", thing->sprite);
; 1408 : #else
; 1409 : 		return;

  00145	e9 1a 04 00 00	 jmp	 $LN1@R_ProjectP
$LN6@R_ProjectP:

; 1410 : #endif
; 1411 : 
; 1412 : 	// use single rotation for all views
; 1413 : 	lump = sprframe->lumpid[0];     //Fab: see note above

  0014a	b8 04 00 00 00	 mov	 eax, 4
  0014f	6b c8 00	 imul	 ecx, eax, 0
  00152	8b 55 d0	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00155	8b 44 0a 24	 mov	 eax, DWORD PTR [edx+ecx+36]
  00159	89 45 cc	 mov	 DWORD PTR _lump$[ebp], eax

; 1414 : 
; 1415 : 	// calculate edges of the shape
; 1416 : 	tx -= spritecachedinfo[lump].offset;

  0015c	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  0015f	c1 e0 04	 shl	 eax, 4
  00162	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00168	8b 55 ec	 mov	 edx, DWORD PTR _tx$[ebp]
  0016b	2b 54 01 04	 sub	 edx, DWORD PTR [ecx+eax+4]
  0016f	89 55 ec	 mov	 DWORD PTR _tx$[ebp], edx

; 1417 : 	x1 = (centerxfrac + FixedMul (tx,xscale)) >>FRACBITS;

  00172	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  00175	50		 push	 eax
  00176	8b 4d ec	 mov	 ecx, DWORD PTR _tx$[ebp]
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 _FixedMul
  0017f	83 c4 08	 add	 esp, 8
  00182	03 05 00 00 00
	00		 add	 eax, DWORD PTR _centerxfrac
  00188	c1 f8 10	 sar	 eax, 16			; 00000010H
  0018b	89 45 dc	 mov	 DWORD PTR _x1$[ebp], eax

; 1418 : 
; 1419 : 	// off the right side?
; 1420 : 	if (x1 > viewwidth)

  0018e	8b 45 dc	 mov	 eax, DWORD PTR _x1$[ebp]
  00191	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewwidth
  00197	7e 05		 jle	 SHORT $LN7@R_ProjectP

; 1421 : 		return;

  00199	e9 c6 03 00 00	 jmp	 $LN1@R_ProjectP
$LN7@R_ProjectP:

; 1422 : 
; 1423 : 	tx += spritecachedinfo[lump].width;

  0019e	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  001a1	c1 e0 04	 shl	 eax, 4
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  001aa	8b 55 ec	 mov	 edx, DWORD PTR _tx$[ebp]
  001ad	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  001b0	89 55 ec	 mov	 DWORD PTR _tx$[ebp], edx

; 1424 : 	x2 = ((centerxfrac + FixedMul (tx,xscale)) >>FRACBITS) - 1;

  001b3	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  001b6	50		 push	 eax
  001b7	8b 4d ec	 mov	 ecx, DWORD PTR _tx$[ebp]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _FixedMul
  001c0	83 c4 08	 add	 esp, 8
  001c3	03 05 00 00 00
	00		 add	 eax, DWORD PTR _centerxfrac
  001c9	c1 f8 10	 sar	 eax, 16			; 00000010H
  001cc	83 e8 01	 sub	 eax, 1
  001cf	89 45 d8	 mov	 DWORD PTR _x2$[ebp], eax

; 1425 : 
; 1426 : 	// off the left side
; 1427 : 	if (x2 < 0)

  001d2	79 05		 jns	 SHORT $LN8@R_ProjectP

; 1428 : 		return;

  001d4	e9 8b 03 00 00	 jmp	 $LN1@R_ProjectP
$LN8@R_ProjectP:

; 1429 : 
; 1430 : 	//SoM: 3/17/2000: Disregard sprites that are out of view..
; 1431 : 	gzt = thing->z + spritecachedinfo[lump].topoffset;

  001d9	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  001dc	c1 e0 04	 shl	 eax, 4
  001df	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  001e2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  001eb	03 54 01 08	 add	 edx, DWORD PTR [ecx+eax+8]
  001ef	89 55 c0	 mov	 DWORD PTR _gzt$[ebp], edx

; 1432 : 
; 1433 : 	if (thing->subsector->sector->cullheight)

  001f2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001f5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fa	83 ba e4 00 00
	00 00		 cmp	 DWORD PTR [edx+228], 0
  00201	0f 84 1e 01 00
	00		 je	 $LN18@R_ProjectP

; 1434 : 	{
; 1435 : 		if (thing->subsector->sector->cullheight->flags & ML_NOCLIMB) // Group culling

  00207	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0020a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0020d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0020f	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00215	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00219	83 e1 40	 and	 ecx, 64			; 00000040H
  0021c	0f 84 9c 00 00
	00		 je	 $LN10@R_ProjectP

; 1436 : 		{
; 1437 : 			// Make sure this is part of the same group
; 1438 : 			if (viewsector->cullheight && viewsector->cullheight->frontsector

  00222	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsector
  00227	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  0022e	0f 84 88 00 00
	00		 je	 $LN15@R_ProjectP
  00234	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsector
  00239	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0023f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00242	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00245	8b 10		 mov	 edx, DWORD PTR [eax]
  00247	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  0024d	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00250	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00253	75 67		 jne	 SHORT $LN15@R_ProjectP

; 1439 : 				== thing->subsector->sector->cullheight->frontsector)
; 1440 : 			{
; 1441 : 				// OK, we can cull
; 1442 : 				if (viewz > thing->subsector->sector->cullheight->frontsector->floorheight
; 1443 : 					&& gzt < thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if below plane

  00255	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00258	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0025b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025d	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00263	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00266	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  0026c	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0026e	7e 1f		 jle	 SHORT $LN13@R_ProjectP
  00270	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00273	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00276	8b 11		 mov	 edx, DWORD PTR [ecx]
  00278	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  0027e	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00281	8b 55 c0	 mov	 edx, DWORD PTR _gzt$[ebp]
  00284	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00286	7d 07		 jge	 SHORT $LN13@R_ProjectP

; 1444 : 					return;

  00288	e9 d7 02 00 00	 jmp	 $LN1@R_ProjectP
  0028d	eb 2d		 jmp	 SHORT $LN15@R_ProjectP
$LN13@R_ProjectP:

; 1445 : 				else if (gzt - spritecachedinfo[lump].height > thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if above plane

  0028f	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00292	c1 e0 04	 shl	 eax, 4
  00295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0029b	8b 55 c0	 mov	 edx, DWORD PTR _gzt$[ebp]
  0029e	2b 54 01 0c	 sub	 edx, DWORD PTR [ecx+eax+12]
  002a2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002a5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002a8	8b 01		 mov	 eax, DWORD PTR [ecx]
  002aa	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  002b0	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  002b3	3b 10		 cmp	 edx, DWORD PTR [eax]
  002b5	7e 05		 jle	 SHORT $LN15@R_ProjectP

; 1446 : 					return;

  002b7	e9 a8 02 00 00	 jmp	 $LN1@R_ProjectP
$LN15@R_ProjectP:

; 1447 : 			}
; 1448 : 		}

  002bc	eb 67		 jmp	 SHORT $LN18@R_ProjectP
$LN10@R_ProjectP:

; 1449 : 		else // Quick culling
; 1450 : 		{
; 1451 : 			if (viewz > thing->subsector->sector->cullheight->frontsector->floorheight
; 1452 : 				&& gzt < thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if below plane

  002be	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002c1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002c4	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c6	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  002cc	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  002cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  002d5	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002d7	7e 1f		 jle	 SHORT $LN16@R_ProjectP
  002d9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002dc	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002df	8b 11		 mov	 edx, DWORD PTR [ecx]
  002e1	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  002e7	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  002ea	8b 55 c0	 mov	 edx, DWORD PTR _gzt$[ebp]
  002ed	3b 11		 cmp	 edx, DWORD PTR [ecx]
  002ef	7d 07		 jge	 SHORT $LN16@R_ProjectP

; 1453 : 				return;

  002f1	e9 6e 02 00 00	 jmp	 $LN1@R_ProjectP
  002f6	eb 2d		 jmp	 SHORT $LN18@R_ProjectP
$LN16@R_ProjectP:

; 1454 : 			else if (gzt - spritecachedinfo[lump].height > thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if above plane

  002f8	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  002fb	c1 e0 04	 shl	 eax, 4
  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00304	8b 55 c0	 mov	 edx, DWORD PTR _gzt$[ebp]
  00307	2b 54 01 0c	 sub	 edx, DWORD PTR [ecx+eax+12]
  0030b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0030e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00311	8b 01		 mov	 eax, DWORD PTR [ecx]
  00313	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  00319	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0031c	3b 10		 cmp	 edx, DWORD PTR [eax]
  0031e	7e 05		 jle	 SHORT $LN18@R_ProjectP

; 1455 : 				return;

  00320	e9 3f 02 00 00	 jmp	 $LN1@R_ProjectP
$LN18@R_ProjectP:

; 1456 : 		}
; 1457 : 	}
; 1458 : 
; 1459 : 	// store information in a vissprite
; 1460 : 	vis = R_NewVisSprite();

  00325	e8 00 00 00 00	 call	 _R_NewVisSprite
  0032a	89 45 c8	 mov	 DWORD PTR _vis$[ebp], eax

; 1461 : 	vis->scale = yscale; //<<detailshift;

  0032d	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00330	8b 4d e0	 mov	 ecx, DWORD PTR _yscale$[ebp]
  00333	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 1462 : 	vis->gx = thing->x;

  00336	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00339	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0033c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0033f	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1463 : 	vis->gy = thing->y;

  00342	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00345	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00348	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0034b	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1464 : 	vis->gz = gzt - spritecachedinfo[lump].height;

  0034e	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00351	c1 e0 04	 shl	 eax, 4
  00354	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0035a	8b 55 c0	 mov	 edx, DWORD PTR _gzt$[ebp]
  0035d	2b 54 01 0c	 sub	 edx, DWORD PTR [ecx+eax+12]
  00361	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00364	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 1465 : 	vis->gzt = gzt;

  00367	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0036a	8b 4d c0	 mov	 ecx, DWORD PTR _gzt$[ebp]
  0036d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1466 : 	vis->thingheight = 4*FRACUNIT;

  00370	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00373	c7 40 58 00 00
	04 00		 mov	 DWORD PTR [eax+88], 262144 ; 00040000H

; 1467 : 	vis->pz = thing->z;

  0037a	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0037d	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00380	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00383	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1468 : 	vis->pzt = vis->pz + vis->thingheight;

  00386	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00389	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0038c	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  0038f	03 4a 58	 add	 ecx, DWORD PTR [edx+88]
  00392	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00395	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1469 : 	vis->texturemid = vis->gzt - viewz;

  00398	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0039b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0039e	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewz
  003a4	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  003a7	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 1470 : 
; 1471 : 	vis->x1 = x1 < 0 ? 0 : x1;

  003aa	83 7d dc 00	 cmp	 DWORD PTR _x1$[ebp], 0
  003ae	7d 0c		 jge	 SHORT $LN23@R_ProjectP
  003b0	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv262[ebp], 0
  003ba	eb 09		 jmp	 SHORT $LN24@R_ProjectP
$LN23@R_ProjectP:
  003bc	8b 45 dc	 mov	 eax, DWORD PTR _x1$[ebp]
  003bf	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv262[ebp], eax
$LN24@R_ProjectP:
  003c5	8b 4d c8	 mov	 ecx, DWORD PTR _vis$[ebp]
  003c8	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv262[ebp]
  003ce	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1472 : 	vis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;

  003d1	8b 45 d8	 mov	 eax, DWORD PTR _x2$[ebp]
  003d4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewwidth
  003da	7c 11		 jl	 SHORT $LN25@R_ProjectP
  003dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _viewwidth
  003e2	83 e9 01	 sub	 ecx, 1
  003e5	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv266[ebp], ecx
  003eb	eb 09		 jmp	 SHORT $LN26@R_ProjectP
$LN25@R_ProjectP:
  003ed	8b 55 d8	 mov	 edx, DWORD PTR _x2$[ebp]
  003f0	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv266[ebp], edx
$LN26@R_ProjectP:
  003f6	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  003f9	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv266[ebp]
  003ff	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1473 : 	vis->xscale = xscale; //SoM: 4/17/2000

  00402	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00405	8b 4d e4	 mov	 ecx, DWORD PTR _xscale$[ebp]
  00408	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 1474 : 	vis->sector = thing->subsector->sector;

  0040b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0040e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00411	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  00414	8b 01		 mov	 eax, DWORD PTR [ecx]
  00416	89 42 5c	 mov	 DWORD PTR [edx+92], eax

; 1475 : 	vis->szt = (INT16)((centeryfrac - FixedMul(vis->gzt - viewz, yscale))>>FRACBITS);

  00419	8b 45 e0	 mov	 eax, DWORD PTR _yscale$[ebp]
  0041c	50		 push	 eax
  0041d	8b 4d c8	 mov	 ecx, DWORD PTR _vis$[ebp]
  00420	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00423	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _viewz
  00429	52		 push	 edx
  0042a	e8 00 00 00 00	 call	 _FixedMul
  0042f	83 c4 08	 add	 esp, 8
  00432	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  00438	2b c8		 sub	 ecx, eax
  0043a	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0043d	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  00440	66 89 4a 62	 mov	 WORD PTR [edx+98], cx

; 1476 : 	vis->sz = (INT16)((centeryfrac - FixedMul(vis->gz - viewz, yscale))>>FRACBITS);

  00444	8b 45 e0	 mov	 eax, DWORD PTR _yscale$[ebp]
  00447	50		 push	 eax
  00448	8b 4d c8	 mov	 ecx, DWORD PTR _vis$[ebp]
  0044b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0044e	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _viewz
  00454	52		 push	 edx
  00455	e8 00 00 00 00	 call	 _FixedMul
  0045a	83 c4 08	 add	 esp, 8
  0045d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  00463	2b c8		 sub	 ecx, eax
  00465	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00468	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  0046b	66 89 4a 60	 mov	 WORD PTR [edx+96], cx

; 1477 : 
; 1478 : 	iscale = FixedDiv(FRACUNIT, xscale);

  0046f	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  00472	50		 push	 eax
  00473	68 00 00 01 00	 push	 65536			; 00010000H
  00478	e8 00 00 00 00	 call	 _FixedDiv
  0047d	83 c4 08	 add	 esp, 8
  00480	89 45 c4	 mov	 DWORD PTR _iscale$[ebp], eax

; 1479 : 
; 1480 : 	vis->startfrac = 0;

  00483	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00486	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 1481 : 	vis->xiscale = iscale;

  0048d	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00490	8b 4d c4	 mov	 ecx, DWORD PTR _iscale$[ebp]
  00493	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 1482 : 
; 1483 : 	if (vis->x1 > x1)

  00496	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00499	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0049c	3b 4d dc	 cmp	 ecx, DWORD PTR _x1$[ebp]
  0049f	7e 1c		 jle	 SHORT $LN19@R_ProjectP

; 1484 : 		vis->startfrac += vis->xiscale*(vis->x1-x1);

  004a1	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  004a4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  004a7	2b 4d dc	 sub	 ecx, DWORD PTR _x1$[ebp]
  004aa	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  004ad	0f af 4a 34	 imul	 ecx, DWORD PTR [edx+52]
  004b1	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  004b4	03 48 2c	 add	 ecx, DWORD PTR [eax+44]
  004b7	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  004ba	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$LN19@R_ProjectP:

; 1485 : 
; 1486 : 	//Fab: lumppat is the lump number of the patch to use, this is different
; 1487 : 	//     than lumpid for sprites-in-pwad : the graphics are patched
; 1488 : 	vis->patch = sprframe->lumppat[0];

  004bd	b8 04 00 00 00	 mov	 eax, 4
  004c2	6b c8 00	 imul	 ecx, eax, 0
  004c5	8b 55 c8	 mov	 edx, DWORD PTR _vis$[ebp]
  004c8	8b 45 d0	 mov	 eax, DWORD PTR _sprframe$[ebp]
  004cb	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  004cf	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 1489 : 
; 1490 : 	// specific translucency
; 1491 : 	if (thing->frame & FF_TRANSMASK)

  004d2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004d5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  004d8	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  004de	74 21		 je	 SHORT $LN20@R_ProjectP

; 1492 : 		vis->transmap = (thing->frame & FF_TRANSMASK) - 0x10000 + transtables;

  004e0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004e3	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  004e6	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  004ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _transtables
  004f2	8d 84 0a 00 00
	ff ff		 lea	 eax, DWORD PTR [edx+ecx-65536]
  004f9	8b 4d c8	 mov	 ecx, DWORD PTR _vis$[ebp]
  004fc	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  004ff	eb 0a		 jmp	 SHORT $LN21@R_ProjectP
$LN20@R_ProjectP:

; 1493 : 	else
; 1494 : 		vis->transmap = NULL;

  00501	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00504	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0
$LN21@R_ProjectP:

; 1495 : 
; 1496 : 	vis->mobjflags = 0;

  0050b	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0050e	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 1497 : 	vis->cut = false;

  00515	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00518	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0

; 1498 : 	vis->extra_colormap = thing->subsector->sector->extra_colormap;

  0051f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00522	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00525	8b 11		 mov	 edx, DWORD PTR [ecx]
  00527	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0052a	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  00530	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 1499 : 	vis->heightsec = thing->subsector->sector->heightsec;

  00533	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00536	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00539	8b 11		 mov	 edx, DWORD PTR [ecx]
  0053b	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0053e	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  00541	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 1500 : 
; 1501 : 	// Fullbright
; 1502 : 	vis->colormap = colormaps;

  00544	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00547	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _colormaps
  0054d	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 1503 : 	vis->precip = true;

  00550	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  00553	c7 40 68 01 00
	00 00		 mov	 DWORD PTR [eax+104], 1

; 1504 : 	vis->vflip = false;

  0055a	8b 45 c8	 mov	 eax, DWORD PTR _vis$[ebp]
  0055d	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
$LN1@R_ProjectP:

; 1505 : }

  00564	5f		 pop	 edi
  00565	5e		 pop	 esi
  00566	5b		 pop	 ebx
  00567	8b e5		 mov	 esp, ebp
  00569	5d		 pop	 ebp
  0056a	c3		 ret	 0
_R_ProjectPrecipitationSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_ProjectSprite
_TEXT	SEGMENT
tv591 = -176						; size = 4
tv613 = -176						; size = 4
tv593 = -172						; size = 4
tv615 = -172						; size = 4
tv649 = -168						; size = 4
tv592 = -168						; size = 4
tv614 = -168						; size = 4
tv645 = -168						; size = 4
_phs$1 = -100						; size = 4
_lightnum$2 = -96					; size = 4
_light$ = -92						; size = 4
_heightsec$ = -88					; size = 4
_gzt$ = -84						; size = 4
_gz$ = -80						; size = 4
_iscale$ = -76						; size = 4
_ang$ = -72						; size = 4
_vis$ = -68						; size = 4
_lindex$ = -64						; size = 4
_flip$ = -57						; size = 1
_rot$ = -56						; size = 4
_lump$ = -52						; size = 4
_sprframe$ = -48					; size = 4
_sprdef$ = -44						; size = 4
_x2$ = -40						; size = 4
_x1$ = -36						; size = 4
_yscale$ = -32						; size = 4
_xscale$ = -28						; size = 4
_tz$ = -24						; size = 4
_tx$ = -20						; size = 4
_gyt$ = -16						; size = 4
_gxt$ = -12						; size = 4
_tr_y$ = -8						; size = 4
_tr_x$ = -4						; size = 4
_thing$ = 8						; size = 4
_R_ProjectSprite PROC					; COMDAT

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 987  : 	fixed_t tr_x, tr_y;
; 988  : 	fixed_t gxt, gyt;
; 989  : 	fixed_t tx, tz;
; 990  : 	fixed_t xscale, yscale; //added : 02-02-98 : aaargll..if I were a math-guy!!!
; 991  : 
; 992  : 	INT32 x1, x2;
; 993  : 
; 994  : 	spritedef_t *sprdef;
; 995  : 	spriteframe_t *sprframe;
; 996  : 	size_t lump;
; 997  : 
; 998  : 	size_t rot;
; 999  : 	UINT8 flip;
; 1000 : 
; 1001 : 	INT32 lindex;
; 1002 : 
; 1003 : 	vissprite_t *vis;
; 1004 : 
; 1005 : 	angle_t ang;
; 1006 : 	fixed_t iscale;
; 1007 : 
; 1008 : 	//SoM: 3/17/2000
; 1009 : 	fixed_t gz, gzt;
; 1010 : 	INT32 heightsec;
; 1011 : 	INT32 light = 0;

  0000c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _light$[ebp], 0

; 1012 : 
; 1013 : 	// transform the origin point
; 1014 : 	tr_x = thing->x - viewx;

  00013	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00016	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00019	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewx
  0001f	89 4d fc	 mov	 DWORD PTR _tr_x$[ebp], ecx

; 1015 : 	tr_y = thing->y - viewy;

  00022	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00025	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00028	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewy
  0002e	89 4d f8	 mov	 DWORD PTR _tr_y$[ebp], ecx

; 1016 : 
; 1017 : 	gxt = FixedMul(tr_x, viewcos);

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewcos
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _tr_x$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _FixedMul
  00040	83 c4 08	 add	 esp, 8
  00043	89 45 f4	 mov	 DWORD PTR _gxt$[ebp], eax

; 1018 : 	gyt = -FixedMul(tr_y, viewsin);

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsin
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _tr_y$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _FixedMul
  00055	83 c4 08	 add	 esp, 8
  00058	f7 d8		 neg	 eax
  0005a	89 45 f0	 mov	 DWORD PTR _gyt$[ebp], eax

; 1019 : 
; 1020 : 	tz = gxt-gyt;

  0005d	8b 45 f4	 mov	 eax, DWORD PTR _gxt$[ebp]
  00060	2b 45 f0	 sub	 eax, DWORD PTR _gyt$[ebp]
  00063	89 45 e8	 mov	 DWORD PTR _tz$[ebp], eax

; 1021 : 
; 1022 : 	// thing is behind view plane?
; 1023 : 	if (tz < MINZ)

  00066	81 7d e8 00 00
	04 00		 cmp	 DWORD PTR _tz$[ebp], 262144 ; 00040000H
  0006d	7d 05		 jge	 SHORT $LN2@R_ProjectS

; 1024 : 		return;

  0006f	e9 52 0e 00 00	 jmp	 $LN74@R_ProjectS
$LN2@R_ProjectS:

; 1025 : 
; 1026 : 	gxt = -FixedMul(tr_x, viewsin);

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsin
  00079	50		 push	 eax
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _tr_x$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _FixedMul
  00083	83 c4 08	 add	 esp, 8
  00086	f7 d8		 neg	 eax
  00088	89 45 f4	 mov	 DWORD PTR _gxt$[ebp], eax

; 1027 : 	gyt = FixedMul(tr_y, viewcos);

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewcos
  00090	50		 push	 eax
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _tr_y$[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _FixedMul
  0009a	83 c4 08	 add	 esp, 8
  0009d	89 45 f0	 mov	 DWORD PTR _gyt$[ebp], eax

; 1028 : 	tx = -(gyt + gxt);

  000a0	8b 45 f0	 mov	 eax, DWORD PTR _gyt$[ebp]
  000a3	03 45 f4	 add	 eax, DWORD PTR _gxt$[ebp]
  000a6	f7 d8		 neg	 eax
  000a8	89 45 ec	 mov	 DWORD PTR _tx$[ebp], eax

; 1029 : 
; 1030 : 	// too far off the side?
; 1031 : 	if (abs(tx) > tz<<2)

  000ab	8b 45 ec	 mov	 eax, DWORD PTR _tx$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _abs
  000b4	83 c4 04	 add	 esp, 4
  000b7	8b 4d e8	 mov	 ecx, DWORD PTR _tz$[ebp]
  000ba	c1 e1 02	 shl	 ecx, 2
  000bd	3b c1		 cmp	 eax, ecx
  000bf	7e 05		 jle	 SHORT $LN3@R_ProjectS

; 1032 : 		return;

  000c1	e9 00 0e 00 00	 jmp	 $LN74@R_ProjectS
$LN3@R_ProjectS:

; 1033 : 
; 1034 : 	// aspect ratio stuff
; 1035 : 	xscale = FixedDiv(projection, tz);

  000c6	8b 45 e8	 mov	 eax, DWORD PTR _tz$[ebp]
  000c9	50		 push	 eax
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _projection
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _FixedDiv
  000d6	83 c4 08	 add	 esp, 8
  000d9	89 45 e4	 mov	 DWORD PTR _xscale$[ebp], eax

; 1036 : 	yscale = FixedDiv(projectiony, tz);

  000dc	8b 45 e8	 mov	 eax, DWORD PTR _tz$[ebp]
  000df	50		 push	 eax
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _projectiony
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 _FixedDiv
  000ec	83 c4 08	 add	 esp, 8
  000ef	89 45 e0	 mov	 DWORD PTR _yscale$[ebp], eax

; 1037 : 
; 1038 : 	// decide which patch to use for sprite relative to player
; 1039 : 	if ((size_t)(thing->sprite) >= numsprites)

  000f2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000f5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000f8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _numsprites
  000fe	72 4d		 jb	 SHORT $LN4@R_ProjectS

; 1040 : #ifdef RANGECHECK
; 1041 : 		I_Error("R_ProjectSprite: invalid sprite number %d ", thing->sprite);
; 1042 : #else
; 1043 : 	{
; 1044 : 		CONS_Printf("Warning: Mobj of type %d with invalid sprite data (%d) detected and removed.\n", thing->type, thing->sprite);

  00100	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00103	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00106	51		 push	 ecx
  00107	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0010a	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  0010d	50		 push	 eax
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@MBOIJNDA@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@
  00113	e8 00 00 00 00	 call	 _CONS_Printf
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1045 : 		if (thing->player)

  0011b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0011e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00125	74 10		 je	 SHORT $LN5@R_ProjectS

; 1046 : 		{
; 1047 : 			P_SetPlayerMobjState(thing, S_PLAY_STND);

  00127	6a 01		 push	 1
  00129	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  00132	83 c4 08	 add	 esp, 8

; 1048 : 		}

  00135	eb 11		 jmp	 SHORT $LN6@R_ProjectS
$LN5@R_ProjectS:

; 1049 : 		else
; 1050 : 		{
; 1051 : 			P_SetMobjState(thing, S_DISS);

  00137	68 4f 06 00 00	 push	 1615			; 0000064fH
  0013c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _P_SetMobjState
  00145	83 c4 08	 add	 esp, 8
$LN6@R_ProjectS:

; 1052 : 		}
; 1053 : 		return;

  00148	e9 79 0d 00 00	 jmp	 $LN74@R_ProjectS
$LN4@R_ProjectS:

; 1054 : 	}
; 1055 : #endif
; 1056 : 
; 1057 : 	rot = thing->frame&FF_FRAMEMASK;

  0014d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00150	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00153	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  00159	89 4d c8	 mov	 DWORD PTR _rot$[ebp], ecx

; 1058 : 
; 1059 : 	//Fab : 02-08-98: 'skin' override spritedef currently used for skin
; 1060 : 	if (thing->skin)

  0015c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0015f	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00163	74 0e		 je	 SHORT $LN7@R_ProjectS

; 1061 : 		sprdef = &((skin_t *)thing->skin)->spritedef;

  00165	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00168	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0016b	83 c1 14	 add	 ecx, 20			; 00000014H
  0016e	89 4d d4	 mov	 DWORD PTR _sprdef$[ebp], ecx
  00171	eb 12		 jmp	 SHORT $LN8@R_ProjectS
$LN7@R_ProjectS:

; 1062 : 	else
; 1063 : 		sprdef = &sprites[thing->sprite];

  00173	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00176	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00179	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sprites
  0017f	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00182	89 45 d4	 mov	 DWORD PTR _sprdef$[ebp], eax
$LN8@R_ProjectS:

; 1064 : 
; 1065 : 	if (rot >= sprdef->numframes)

  00185	8b 45 d4	 mov	 eax, DWORD PTR _sprdef$[ebp]
  00188	8b 4d c8	 mov	 ecx, DWORD PTR _rot$[ebp]
  0018b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0018d	72 5e		 jb	 SHORT $LN9@R_ProjectS

; 1066 : #ifdef RANGECHECK
; 1067 : 		I_Error("R_ProjectSprite: invalid sprite frame %u : %"PRIdS"/%"PRIdS" for %s",
; 1068 : 		 thing->sprite, rot, sprdef->numframes, sprnames[thing->sprite]);
; 1069 : #else
; 1070 : 	{
; 1071 : 		CONS_Printf("Warning: Mobj of type %d with invalid sprite frame (%"PRIdS"/%"PRIdS") of %s detected and removed.\n", thing->type, rot, sprdef->numframes, sprnames[thing->sprite]);

  0018f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00192	6b 48 28 05	 imul	 ecx, DWORD PTR [eax+40], 5
  00196	81 c1 00 00 00
	00		 add	 ecx, OFFSET _sprnames
  0019c	51		 push	 ecx
  0019d	8b 55 d4	 mov	 edx, DWORD PTR _sprdef$[ebp]
  001a0	8b 02		 mov	 eax, DWORD PTR [edx]
  001a2	50		 push	 eax
  001a3	8b 4d c8	 mov	 ecx, DWORD PTR _rot$[ebp]
  001a6	51		 push	 ecx
  001a7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  001aa	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  001ad	50		 push	 eax
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@ELEJPCI@Warning?3?5Mobj?5of?5type?5?$CFd?5with?5i@
  001b3	e8 00 00 00 00	 call	 _CONS_Printf
  001b8	83 c4 14	 add	 esp, 20			; 00000014H

; 1072 : 		if (thing->player)

  001bb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001be	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001c5	74 10		 je	 SHORT $LN10@R_ProjectS

; 1073 : 		{
; 1074 : 			P_SetPlayerMobjState(thing, S_PLAY_STND);

  001c7	6a 01		 push	 1
  001c9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  001d2	83 c4 08	 add	 esp, 8

; 1075 : 		}

  001d5	eb 11		 jmp	 SHORT $LN11@R_ProjectS
$LN10@R_ProjectS:

; 1076 : 		else
; 1077 : 		{
; 1078 : 			P_SetMobjState(thing, S_DISS);

  001d7	68 4f 06 00 00	 push	 1615			; 0000064fH
  001dc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 _P_SetMobjState
  001e5	83 c4 08	 add	 esp, 8
$LN11@R_ProjectS:

; 1079 : 		}
; 1080 : 		return;

  001e8	e9 d9 0c 00 00	 jmp	 $LN74@R_ProjectS
$LN9@R_ProjectS:

; 1081 : 	}
; 1082 : #endif
; 1083 : 
; 1084 : 	sprframe = &sprdef->spriteframes[ thing->frame & FF_FRAMEMASK];

  001ed	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001f0	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001f3	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  001f9	6b d1 4c	 imul	 edx, ecx, 76
  001fc	8b 45 d4	 mov	 eax, DWORD PTR _sprdef$[ebp]
  001ff	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00202	89 55 d0	 mov	 DWORD PTR _sprframe$[ebp], edx

; 1085 : 
; 1086 : 	if (!sprframe)

  00205	75 05		 jne	 SHORT $LN12@R_ProjectS

; 1087 : #ifdef PARANOIA //heretic hack
; 1088 : 		I_Error("sprframes NULL for sprite %d\n", thing->sprite);
; 1089 : #else
; 1090 : 		return;

  00207	e9 ba 0c 00 00	 jmp	 $LN74@R_ProjectS
$LN12@R_ProjectS:

; 1091 : #endif
; 1092 : 
; 1093 : 	if (sprframe->rotate)

  0020c	8b 45 d0	 mov	 eax, DWORD PTR _sprframe$[ebp]
  0020f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00212	85 c9		 test	 ecx, ecx
  00214	74 49		 je	 SHORT $LN13@R_ProjectS

; 1094 : 	{
; 1095 : 		// choose a different rotation based on player view
; 1096 : 		ang = R_PointToAngle (thing->x, thing->y);

  00216	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00219	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0021c	51		 push	 ecx
  0021d	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00220	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 _R_PointToAngle
  00229	83 c4 08	 add	 esp, 8
  0022c	89 45 b8	 mov	 DWORD PTR _ang$[ebp], eax

; 1097 : 		rot = (ang-thing->angle+ANGLE_202h)>>29;

  0022f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00232	8b 4d b8	 mov	 ecx, DWORD PTR _ang$[ebp]
  00235	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  00238	81 e9 00 00 00
	70		 sub	 ecx, 1879048192		; 70000000H
  0023e	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  00241	89 4d c8	 mov	 DWORD PTR _rot$[ebp], ecx

; 1098 : 		//Fab: lumpid is the index for spritewidth,spriteoffset... tables
; 1099 : 		lump = sprframe->lumpid[rot];

  00244	8b 45 c8	 mov	 eax, DWORD PTR _rot$[ebp]
  00247	8b 4d d0	 mov	 ecx, DWORD PTR _sprframe$[ebp]
  0024a	8b 54 81 24	 mov	 edx, DWORD PTR [ecx+eax*4+36]
  0024e	89 55 cc	 mov	 DWORD PTR _lump$[ebp], edx

; 1100 : 		flip = sprframe->flip[rot];

  00251	8b 45 d0	 mov	 eax, DWORD PTR _sprframe$[ebp]
  00254	03 45 c8	 add	 eax, DWORD PTR _rot$[ebp]
  00257	8a 48 44	 mov	 cl, BYTE PTR [eax+68]
  0025a	88 4d c7	 mov	 BYTE PTR _flip$[ebp], cl

; 1101 : 	}

  0025d	eb 2b		 jmp	 SHORT $LN14@R_ProjectS
$LN13@R_ProjectS:

; 1102 : 	else
; 1103 : 	{
; 1104 : 		// use single rotation for all views
; 1105 : 		rot = 0;                        //Fab: for vis->patch below

  0025f	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _rot$[ebp], 0

; 1106 : 		lump = sprframe->lumpid[0];     //Fab: see note above

  00266	b8 04 00 00 00	 mov	 eax, 4
  0026b	6b c8 00	 imul	 ecx, eax, 0
  0026e	8b 55 d0	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00271	8b 44 0a 24	 mov	 eax, DWORD PTR [edx+ecx+36]
  00275	89 45 cc	 mov	 DWORD PTR _lump$[ebp], eax

; 1107 : 		flip = sprframe->flip[0];

  00278	b8 01 00 00 00	 mov	 eax, 1
  0027d	6b c8 00	 imul	 ecx, eax, 0
  00280	8b 55 d0	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00283	8a 44 0a 44	 mov	 al, BYTE PTR [edx+ecx+68]
  00287	88 45 c7	 mov	 BYTE PTR _flip$[ebp], al
$LN14@R_ProjectS:

; 1108 : 	}
; 1109 : 
; 1110 : 	I_Assert(lump < MAXSPRITELUMPS);
; 1111 : 
; 1112 : 	// calculate edges of the shape
; 1113 : 	if (thing->scale > 400)

  0028a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0028d	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00294	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  0029a	7e 39		 jle	 SHORT $LN15@R_ProjectS

; 1114 : 		tx -= FIXEDSCALE(spritecachedinfo[lump].offset,400);

  0029c	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  0029f	c1 e0 04	 shl	 eax, 4
  002a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  002a8	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  002ac	52		 push	 edx
  002ad	68 00 00 64 00	 push	 6553600			; 00640000H
  002b2	68 00 00 90 01	 push	 26214400		; 01900000H
  002b7	e8 00 00 00 00	 call	 _FixedDiv
  002bc	83 c4 08	 add	 esp, 8
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 _FixedMul
  002c5	83 c4 08	 add	 esp, 8
  002c8	8b 4d ec	 mov	 ecx, DWORD PTR _tx$[ebp]
  002cb	2b c8		 sub	 ecx, eax
  002cd	89 4d ec	 mov	 DWORD PTR _tx$[ebp], ecx
  002d0	e9 91 00 00 00	 jmp	 $LN20@R_ProjectS
$LN15@R_ProjectS:

; 1115 : 	else if (thing->scale != 100)

  002d5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002d8	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  002df	83 f9 64	 cmp	 ecx, 100		; 00000064H
  002e2	74 3f		 je	 SHORT $LN17@R_ProjectS

; 1116 : 		tx -= FIXEDSCALE(spritecachedinfo[lump].offset,thing->scale);

  002e4	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  002e7	c1 e0 04	 shl	 eax, 4
  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  002f0	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  002f4	52		 push	 edx
  002f5	68 00 00 64 00	 push	 6553600			; 00640000H
  002fa	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002fd	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00304	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00307	51		 push	 ecx
  00308	e8 00 00 00 00	 call	 _FixedDiv
  0030d	83 c4 08	 add	 esp, 8
  00310	50		 push	 eax
  00311	e8 00 00 00 00	 call	 _FixedMul
  00316	83 c4 08	 add	 esp, 8
  00319	8b 55 ec	 mov	 edx, DWORD PTR _tx$[ebp]
  0031c	2b d0		 sub	 edx, eax
  0031e	89 55 ec	 mov	 DWORD PTR _tx$[ebp], edx
  00321	eb 43		 jmp	 SHORT $LN20@R_ProjectS
$LN17@R_ProjectS:

; 1117 : 	else if (thing->flags & MF_HIRES)

  00323	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00326	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00329	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  0032f	74 1f		 je	 SHORT $LN19@R_ProjectS

; 1118 : 		tx -= spritecachedinfo[lump].offset/2;

  00331	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00334	c1 e0 04	 shl	 eax, 4
  00337	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0033d	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  00341	99		 cdq
  00342	2b c2		 sub	 eax, edx
  00344	d1 f8		 sar	 eax, 1
  00346	8b 55 ec	 mov	 edx, DWORD PTR _tx$[ebp]
  00349	2b d0		 sub	 edx, eax
  0034b	89 55 ec	 mov	 DWORD PTR _tx$[ebp], edx
  0034e	eb 16		 jmp	 SHORT $LN20@R_ProjectS
$LN19@R_ProjectS:

; 1119 : 	else
; 1120 : 		tx -= spritecachedinfo[lump].offset;

  00350	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00353	c1 e0 04	 shl	 eax, 4
  00356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0035c	8b 55 ec	 mov	 edx, DWORD PTR _tx$[ebp]
  0035f	2b 54 01 04	 sub	 edx, DWORD PTR [ecx+eax+4]
  00363	89 55 ec	 mov	 DWORD PTR _tx$[ebp], edx
$LN20@R_ProjectS:

; 1121 : 	x1 = (centerxfrac + FixedMul (tx,xscale)) >>FRACBITS;

  00366	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  00369	50		 push	 eax
  0036a	8b 4d ec	 mov	 ecx, DWORD PTR _tx$[ebp]
  0036d	51		 push	 ecx
  0036e	e8 00 00 00 00	 call	 _FixedMul
  00373	83 c4 08	 add	 esp, 8
  00376	03 05 00 00 00
	00		 add	 eax, DWORD PTR _centerxfrac
  0037c	c1 f8 10	 sar	 eax, 16			; 00000010H
  0037f	89 45 dc	 mov	 DWORD PTR _x1$[ebp], eax

; 1122 : 
; 1123 : 	// off the right side?
; 1124 : 	if (x1 > viewwidth)

  00382	8b 45 dc	 mov	 eax, DWORD PTR _x1$[ebp]
  00385	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewwidth
  0038b	7e 05		 jle	 SHORT $LN21@R_ProjectS

; 1125 : 		return;

  0038d	e9 34 0b 00 00	 jmp	 $LN74@R_ProjectS
$LN21@R_ProjectS:

; 1126 : 
; 1127 : 	if (thing->scale > 400)

  00392	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00395	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  0039c	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  003a2	7e 36		 jle	 SHORT $LN22@R_ProjectS

; 1128 : 		tx += FIXEDSCALE(spritecachedinfo[lump].width,400);

  003a4	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  003a7	c1 e0 04	 shl	 eax, 4
  003aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  003b0	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  003b3	52		 push	 edx
  003b4	68 00 00 64 00	 push	 6553600			; 00640000H
  003b9	68 00 00 90 01	 push	 26214400		; 01900000H
  003be	e8 00 00 00 00	 call	 _FixedDiv
  003c3	83 c4 08	 add	 esp, 8
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 _FixedMul
  003cc	83 c4 08	 add	 esp, 8
  003cf	03 45 ec	 add	 eax, DWORD PTR _tx$[ebp]
  003d2	89 45 ec	 mov	 DWORD PTR _tx$[ebp], eax
  003d5	e9 8a 00 00 00	 jmp	 $LN27@R_ProjectS
$LN22@R_ProjectS:

; 1129 : 	else if (thing->scale != 100)

  003da	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003dd	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  003e4	83 f9 64	 cmp	 ecx, 100		; 00000064H
  003e7	74 3c		 je	 SHORT $LN24@R_ProjectS

; 1130 : 		tx += FIXEDSCALE(spritecachedinfo[lump].width,thing->scale);

  003e9	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  003ec	c1 e0 04	 shl	 eax, 4
  003ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  003f5	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  003f8	52		 push	 edx
  003f9	68 00 00 64 00	 push	 6553600			; 00640000H
  003fe	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00401	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00408	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0040b	51		 push	 ecx
  0040c	e8 00 00 00 00	 call	 _FixedDiv
  00411	83 c4 08	 add	 esp, 8
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 _FixedMul
  0041a	83 c4 08	 add	 esp, 8
  0041d	03 45 ec	 add	 eax, DWORD PTR _tx$[ebp]
  00420	89 45 ec	 mov	 DWORD PTR _tx$[ebp], eax
  00423	eb 3f		 jmp	 SHORT $LN27@R_ProjectS
$LN24@R_ProjectS:

; 1131 : 	else if (thing->flags & MF_HIRES)

  00425	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00428	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0042b	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  00431	74 1c		 je	 SHORT $LN26@R_ProjectS

; 1132 : 		tx += spritecachedinfo[lump].width/2;

  00433	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00436	c1 e0 04	 shl	 eax, 4
  00439	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0043f	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00442	99		 cdq
  00443	2b c2		 sub	 eax, edx
  00445	d1 f8		 sar	 eax, 1
  00447	03 45 ec	 add	 eax, DWORD PTR _tx$[ebp]
  0044a	89 45 ec	 mov	 DWORD PTR _tx$[ebp], eax
  0044d	eb 15		 jmp	 SHORT $LN27@R_ProjectS
$LN26@R_ProjectS:

; 1133 : 	else
; 1134 : 		tx += spritecachedinfo[lump].width;

  0044f	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00452	c1 e0 04	 shl	 eax, 4
  00455	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0045b	8b 55 ec	 mov	 edx, DWORD PTR _tx$[ebp]
  0045e	03 14 01	 add	 edx, DWORD PTR [ecx+eax]
  00461	89 55 ec	 mov	 DWORD PTR _tx$[ebp], edx
$LN27@R_ProjectS:

; 1135 : 	x2 = ((centerxfrac + FixedMul (tx,xscale)) >>FRACBITS) - 1;

  00464	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  00467	50		 push	 eax
  00468	8b 4d ec	 mov	 ecx, DWORD PTR _tx$[ebp]
  0046b	51		 push	 ecx
  0046c	e8 00 00 00 00	 call	 _FixedMul
  00471	83 c4 08	 add	 esp, 8
  00474	03 05 00 00 00
	00		 add	 eax, DWORD PTR _centerxfrac
  0047a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0047d	83 e8 01	 sub	 eax, 1
  00480	89 45 d8	 mov	 DWORD PTR _x2$[ebp], eax

; 1136 : 
; 1137 : 	// off the left side
; 1138 : 	if (x2 < 0)

  00483	79 05		 jns	 SHORT $LN28@R_ProjectS

; 1139 : 		return;

  00485	e9 3c 0a 00 00	 jmp	 $LN74@R_ProjectS
$LN28@R_ProjectS:

; 1140 : 
; 1141 : 	//SoM: 3/17/2000: Disregard sprites that are out of view..
; 1142 : 	if (thing->eflags & MFE_VERTICALFLIP)

  0048a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0048d	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00493	83 e1 20	 and	 ecx, 32			; 00000020H
  00496	0f 84 f4 01 00
	00		 je	 $LN29@R_ProjectS

; 1143 : 	{
; 1144 : 		if (thing->scale > 400)

  0049c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0049f	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  004a6	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  004ac	0f 8e 86 00 00
	00		 jle	 $LN31@R_ProjectS

; 1145 : 		{
; 1146 : 			gzt = thing->z + thing->height + FIXEDSCALE(spritecachedinfo[lump].height - spritecachedinfo[lump].topoffset, 400);

  004b2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004b5	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  004b8	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  004bb	03 71 44	 add	 esi, DWORD PTR [ecx+68]
  004be	8b 55 cc	 mov	 edx, DWORD PTR _lump$[ebp]
  004c1	c1 e2 04	 shl	 edx, 4
  004c4	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  004c7	c1 e0 04	 shl	 eax, 4
  004ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  004d0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _spritecachedinfo
  004d6	8b 54 11 0c	 mov	 edx, DWORD PTR [ecx+edx+12]
  004da	2b 54 07 08	 sub	 edx, DWORD PTR [edi+eax+8]
  004de	52		 push	 edx
  004df	68 00 00 64 00	 push	 6553600			; 00640000H
  004e4	68 00 00 90 01	 push	 26214400		; 01900000H
  004e9	e8 00 00 00 00	 call	 _FixedDiv
  004ee	83 c4 08	 add	 esp, 8
  004f1	50		 push	 eax
  004f2	e8 00 00 00 00	 call	 _FixedMul
  004f7	83 c4 08	 add	 esp, 8
  004fa	03 f0		 add	 esi, eax
  004fc	89 75 ac	 mov	 DWORD PTR _gzt$[ebp], esi

; 1147 : 			gz = gzt - FIXEDSCALE(spritecachedinfo[lump].height, 400);

  004ff	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00502	c1 e0 04	 shl	 eax, 4
  00505	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0050b	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0050f	52		 push	 edx
  00510	68 00 00 64 00	 push	 6553600			; 00640000H
  00515	68 00 00 90 01	 push	 26214400		; 01900000H
  0051a	e8 00 00 00 00	 call	 _FixedDiv
  0051f	83 c4 08	 add	 esp, 8
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 _FixedMul
  00528	83 c4 08	 add	 esp, 8
  0052b	8b 4d ac	 mov	 ecx, DWORD PTR _gzt$[ebp]
  0052e	2b c8		 sub	 ecx, eax
  00530	89 4d b0	 mov	 DWORD PTR _gz$[ebp], ecx

; 1148 : 		}

  00533	e9 53 01 00 00	 jmp	 $LN36@R_ProjectS
$LN31@R_ProjectS:

; 1149 : 		else if (thing->scale != 100)

  00538	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0053b	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00542	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00545	0f 84 98 00 00
	00		 je	 $LN33@R_ProjectS

; 1150 : 		{
; 1151 : 			gzt = thing->z + thing->height + FIXEDSCALE(spritecachedinfo[lump].height - spritecachedinfo[lump].topoffset, thing->scale);

  0054b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0054e	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00551	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00554	03 71 44	 add	 esi, DWORD PTR [ecx+68]
  00557	8b 55 cc	 mov	 edx, DWORD PTR _lump$[ebp]
  0055a	c1 e2 04	 shl	 edx, 4
  0055d	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00560	c1 e0 04	 shl	 eax, 4
  00563	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00569	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _spritecachedinfo
  0056f	8b 54 11 0c	 mov	 edx, DWORD PTR [ecx+edx+12]
  00573	2b 54 07 08	 sub	 edx, DWORD PTR [edi+eax+8]
  00577	52		 push	 edx
  00578	68 00 00 64 00	 push	 6553600			; 00640000H
  0057d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00580	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00587	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0058a	51		 push	 ecx
  0058b	e8 00 00 00 00	 call	 _FixedDiv
  00590	83 c4 08	 add	 esp, 8
  00593	50		 push	 eax
  00594	e8 00 00 00 00	 call	 _FixedMul
  00599	83 c4 08	 add	 esp, 8
  0059c	03 f0		 add	 esi, eax
  0059e	89 75 ac	 mov	 DWORD PTR _gzt$[ebp], esi

; 1152 : 			gz = gzt - FIXEDSCALE(spritecachedinfo[lump].height,thing->scale);

  005a1	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  005a4	c1 e0 04	 shl	 eax, 4
  005a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  005ad	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  005b1	52		 push	 edx
  005b2	68 00 00 64 00	 push	 6553600			; 00640000H
  005b7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005ba	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  005c1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  005c4	51		 push	 ecx
  005c5	e8 00 00 00 00	 call	 _FixedDiv
  005ca	83 c4 08	 add	 esp, 8
  005cd	50		 push	 eax
  005ce	e8 00 00 00 00	 call	 _FixedMul
  005d3	83 c4 08	 add	 esp, 8
  005d6	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  005d9	2b d0		 sub	 edx, eax
  005db	89 55 b0	 mov	 DWORD PTR _gz$[ebp], edx

; 1153 : 		}

  005de	e9 a8 00 00 00	 jmp	 $LN36@R_ProjectS
$LN33@R_ProjectS:

; 1154 : 		else if (thing->flags & MF_HIRES)

  005e3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005e6	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  005e9	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  005ef	74 55		 je	 SHORT $LN35@R_ProjectS

; 1155 : 		{
; 1156 : 			gzt = thing->z + thing->height + (spritecachedinfo[lump].height - spritecachedinfo[lump].topoffset)/2;

  005f1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005f4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005f7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  005fa	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  005fd	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00600	c1 e0 04	 shl	 eax, 4
  00603	8b 55 cc	 mov	 edx, DWORD PTR _lump$[ebp]
  00606	c1 e2 04	 shl	 edx, 4
  00609	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _spritecachedinfo
  0060f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _spritecachedinfo
  00615	8b 44 06 0c	 mov	 eax, DWORD PTR [esi+eax+12]
  00619	2b 44 17 08	 sub	 eax, DWORD PTR [edi+edx+8]
  0061d	99		 cdq
  0061e	2b c2		 sub	 eax, edx
  00620	d1 f8		 sar	 eax, 1
  00622	03 c8		 add	 ecx, eax
  00624	89 4d ac	 mov	 DWORD PTR _gzt$[ebp], ecx

; 1157 : 			gz = gzt - spritecachedinfo[lump].height/2;

  00627	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  0062a	c1 e0 04	 shl	 eax, 4
  0062d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00633	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  00637	99		 cdq
  00638	2b c2		 sub	 eax, edx
  0063a	d1 f8		 sar	 eax, 1
  0063c	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  0063f	2b d0		 sub	 edx, eax
  00641	89 55 b0	 mov	 DWORD PTR _gz$[ebp], edx

; 1158 : 		}

  00644	eb 45		 jmp	 SHORT $LN36@R_ProjectS
$LN35@R_ProjectS:

; 1159 : 		else
; 1160 : 		{
; 1161 : 			// When vertical flipped, draw sprites from the top down, at least as far as offsets are concerned.
; 1162 : 			// Visual errors occur from "thing->height" being inexact otherwise, so you have to use it. Duh.
; 1163 : 			// sprite height - sprite topoffset is the proper inverse of the vertical offset, of course.
; 1164 : 			gzt = thing->z + thing->height + spritecachedinfo[lump].height - spritecachedinfo[lump].topoffset;

  00646	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00649	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0064c	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0064f	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00652	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00655	c1 e0 04	 shl	 eax, 4
  00658	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritecachedinfo
  0065e	03 4c 02 0c	 add	 ecx, DWORD PTR [edx+eax+12]
  00662	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00665	c1 e0 04	 shl	 eax, 4
  00668	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritecachedinfo
  0066e	2b 4c 02 08	 sub	 ecx, DWORD PTR [edx+eax+8]
  00672	89 4d ac	 mov	 DWORD PTR _gzt$[ebp], ecx

; 1165 : 			gz = gzt - spritecachedinfo[lump].height;

  00675	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00678	c1 e0 04	 shl	 eax, 4
  0067b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00681	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  00684	2b 54 01 0c	 sub	 edx, DWORD PTR [ecx+eax+12]
  00688	89 55 b0	 mov	 DWORD PTR _gz$[ebp], edx
$LN36@R_ProjectS:

; 1166 : 		}
; 1167 : 	}

  0068b	e9 86 01 00 00	 jmp	 $LN42@R_ProjectS
$LN29@R_ProjectS:

; 1168 : 	else
; 1169 : 	{
; 1170 : 		if (thing->scale > 400)

  00690	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00693	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  0069a	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  006a0	7e 6e		 jle	 SHORT $LN37@R_ProjectS

; 1171 : 		{
; 1172 : 			gzt = thing->z + FIXEDSCALE(spritecachedinfo[lump].topoffset,400);

  006a2	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  006a5	c1 e0 04	 shl	 eax, 4
  006a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  006ae	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  006b2	52		 push	 edx
  006b3	68 00 00 64 00	 push	 6553600			; 00640000H
  006b8	68 00 00 90 01	 push	 26214400		; 01900000H
  006bd	e8 00 00 00 00	 call	 _FixedDiv
  006c2	83 c4 08	 add	 esp, 8
  006c5	50		 push	 eax
  006c6	e8 00 00 00 00	 call	 _FixedMul
  006cb	83 c4 08	 add	 esp, 8
  006ce	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  006d1	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  006d4	89 45 ac	 mov	 DWORD PTR _gzt$[ebp], eax

; 1173 : 			gz = gzt - FIXEDSCALE(spritecachedinfo[lump].height,400);

  006d7	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  006da	c1 e0 04	 shl	 eax, 4
  006dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  006e3	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  006e7	52		 push	 edx
  006e8	68 00 00 64 00	 push	 6553600			; 00640000H
  006ed	68 00 00 90 01	 push	 26214400		; 01900000H
  006f2	e8 00 00 00 00	 call	 _FixedDiv
  006f7	83 c4 08	 add	 esp, 8
  006fa	50		 push	 eax
  006fb	e8 00 00 00 00	 call	 _FixedMul
  00700	83 c4 08	 add	 esp, 8
  00703	8b 4d ac	 mov	 ecx, DWORD PTR _gzt$[ebp]
  00706	2b c8		 sub	 ecx, eax
  00708	89 4d b0	 mov	 DWORD PTR _gz$[ebp], ecx

; 1174 : 		}

  0070b	e9 06 01 00 00	 jmp	 $LN42@R_ProjectS
$LN37@R_ProjectS:

; 1175 : 		else if (thing->scale != 100)

  00710	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00713	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  0071a	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0071d	74 7d		 je	 SHORT $LN39@R_ProjectS

; 1176 : 		{
; 1177 : 			gzt = thing->z + FIXEDSCALE(spritecachedinfo[lump].topoffset,thing->scale);

  0071f	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00722	c1 e0 04	 shl	 eax, 4
  00725	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0072b	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  0072f	52		 push	 edx
  00730	68 00 00 64 00	 push	 6553600			; 00640000H
  00735	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00738	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  0073f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00742	51		 push	 ecx
  00743	e8 00 00 00 00	 call	 _FixedDiv
  00748	83 c4 08	 add	 esp, 8
  0074b	50		 push	 eax
  0074c	e8 00 00 00 00	 call	 _FixedMul
  00751	83 c4 08	 add	 esp, 8
  00754	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00757	03 42 18	 add	 eax, DWORD PTR [edx+24]
  0075a	89 45 ac	 mov	 DWORD PTR _gzt$[ebp], eax

; 1178 : 			gz = gzt - FIXEDSCALE(spritecachedinfo[lump].height,thing->scale);

  0075d	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00760	c1 e0 04	 shl	 eax, 4
  00763	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00769	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0076d	52		 push	 edx
  0076e	68 00 00 64 00	 push	 6553600			; 00640000H
  00773	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00776	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  0077d	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00780	51		 push	 ecx
  00781	e8 00 00 00 00	 call	 _FixedDiv
  00786	83 c4 08	 add	 esp, 8
  00789	50		 push	 eax
  0078a	e8 00 00 00 00	 call	 _FixedMul
  0078f	83 c4 08	 add	 esp, 8
  00792	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  00795	2b d0		 sub	 edx, eax
  00797	89 55 b0	 mov	 DWORD PTR _gz$[ebp], edx

; 1179 : 		}

  0079a	eb 7a		 jmp	 SHORT $LN42@R_ProjectS
$LN39@R_ProjectS:

; 1180 : 		else if (thing->flags & MF_HIRES)

  0079c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0079f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  007a2	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  007a8	74 3d		 je	 SHORT $LN41@R_ProjectS

; 1181 : 		{
; 1182 : 			gzt = thing->z + spritecachedinfo[lump].topoffset/2;

  007aa	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  007ad	c1 e0 04	 shl	 eax, 4
  007b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  007b6	8b 44 01 08	 mov	 eax, DWORD PTR [ecx+eax+8]
  007ba	99		 cdq
  007bb	2b c2		 sub	 eax, edx
  007bd	d1 f8		 sar	 eax, 1
  007bf	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  007c2	03 42 18	 add	 eax, DWORD PTR [edx+24]
  007c5	89 45 ac	 mov	 DWORD PTR _gzt$[ebp], eax

; 1183 : 			gz = gzt - spritecachedinfo[lump].height/2;

  007c8	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  007cb	c1 e0 04	 shl	 eax, 4
  007ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  007d4	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  007d8	99		 cdq
  007d9	2b c2		 sub	 eax, edx
  007db	d1 f8		 sar	 eax, 1
  007dd	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  007e0	2b d0		 sub	 edx, eax
  007e2	89 55 b0	 mov	 DWORD PTR _gz$[ebp], edx

; 1184 : 		}

  007e5	eb 2f		 jmp	 SHORT $LN42@R_ProjectS
$LN41@R_ProjectS:

; 1185 : 		else
; 1186 : 		{
; 1187 : 			gzt = thing->z + spritecachedinfo[lump].topoffset;

  007e7	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  007ea	c1 e0 04	 shl	 eax, 4
  007ed	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  007f0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  007f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  007f9	03 54 01 08	 add	 edx, DWORD PTR [ecx+eax+8]
  007fd	89 55 ac	 mov	 DWORD PTR _gzt$[ebp], edx

; 1188 : 			gz = gzt - spritecachedinfo[lump].height;

  00800	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00803	c1 e0 04	 shl	 eax, 4
  00806	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  0080c	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  0080f	2b 54 01 0c	 sub	 edx, DWORD PTR [ecx+eax+12]
  00813	89 55 b0	 mov	 DWORD PTR _gz$[ebp], edx
$LN42@R_ProjectS:

; 1189 : 		}
; 1190 : 	}
; 1191 : 
; 1192 : 	if (thing->subsector->sector->cullheight)

  00816	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00819	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0081c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0081e	83 ba e4 00 00
	00 00		 cmp	 DWORD PTR [edx+228], 0
  00825	0f 84 30 01 00
	00		 je	 $LN50@R_ProjectS

; 1193 : 	{
; 1194 : 		if (thing->subsector->sector->cullheight->flags & ML_NOCLIMB) // Group culling

  0082b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0082e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00831	8b 11		 mov	 edx, DWORD PTR [ecx]
  00833	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00839	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0083d	83 e1 40	 and	 ecx, 64			; 00000040H
  00840	0f 84 a5 00 00
	00		 je	 $LN44@R_ProjectS

; 1195 : 		{
; 1196 : 			// Make sure this is part of the same group
; 1197 : 			if (viewsector->cullheight && viewsector->cullheight->frontsector

  00846	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsector
  0084b	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  00852	0f 84 91 00 00
	00		 je	 $LN48@R_ProjectS
  00858	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewsector
  0085d	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  00863	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00866	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00869	8b 10		 mov	 edx, DWORD PTR [eax]
  0086b	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00871	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00874	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00877	75 70		 jne	 SHORT $LN48@R_ProjectS

; 1198 : 				== thing->subsector->sector->cullheight->frontsector)
; 1199 : 			{
; 1200 : 				// OK, we can cull
; 1201 : 				if (viewz > thing->subsector->sector->cullheight->frontsector->floorheight
; 1202 : 					&& gzt < thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if below plane

  00879	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0087c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0087f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00881	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00887	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0088a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00890	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00892	7e 1d		 jle	 SHORT $LN47@R_ProjectS
  00894	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00897	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0089a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0089c	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  008a2	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  008a5	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  008a8	3b 11		 cmp	 edx, DWORD PTR [ecx]
  008aa	7d 05		 jge	 SHORT $LN47@R_ProjectS

; 1203 : 					return;

  008ac	e9 15 06 00 00	 jmp	 $LN74@R_ProjectS
$LN47@R_ProjectS:

; 1204 : 
; 1205 : 				if (gz > thing->subsector->sector->cullheight->frontsector->floorheight
; 1206 : 					&& viewz <= thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if above plane

  008b1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  008b4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  008b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  008b9	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  008bf	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  008c2	8b 55 b0	 mov	 edx, DWORD PTR _gz$[ebp]
  008c5	3b 11		 cmp	 edx, DWORD PTR [ecx]
  008c7	7e 20		 jle	 SHORT $LN48@R_ProjectS
  008c9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  008cc	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  008cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  008d1	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  008d7	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  008da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  008e0	3b 11		 cmp	 edx, DWORD PTR [ecx]
  008e2	7f 05		 jg	 SHORT $LN48@R_ProjectS

; 1207 : 					return;

  008e4	e9 dd 05 00 00	 jmp	 $LN74@R_ProjectS
$LN48@R_ProjectS:

; 1208 : 			}
; 1209 : 		}

  008e9	eb 70		 jmp	 SHORT $LN50@R_ProjectS
$LN44@R_ProjectS:

; 1210 : 		else // Quick culling
; 1211 : 		{
; 1212 : 			if (viewz > thing->subsector->sector->cullheight->frontsector->floorheight
; 1213 : 				&& gzt < thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if below plane

  008eb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  008ee	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  008f1	8b 11		 mov	 edx, DWORD PTR [ecx]
  008f3	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  008f9	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  008fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00902	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00904	7e 1d		 jle	 SHORT $LN49@R_ProjectS
  00906	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00909	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0090c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0090e	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00914	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00917	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  0091a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0091c	7d 05		 jge	 SHORT $LN49@R_ProjectS

; 1214 : 				return;

  0091e	e9 a3 05 00 00	 jmp	 $LN74@R_ProjectS
$LN49@R_ProjectS:

; 1215 : 
; 1216 : 			if (gz > thing->subsector->sector->cullheight->frontsector->floorheight
; 1217 : 				&& viewz <= thing->subsector->sector->cullheight->frontsector->floorheight) // Cull if above plane

  00923	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00926	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00929	8b 11		 mov	 edx, DWORD PTR [ecx]
  0092b	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00931	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00934	8b 55 b0	 mov	 edx, DWORD PTR _gz$[ebp]
  00937	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00939	7e 20		 jle	 SHORT $LN50@R_ProjectS
  0093b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0093e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00941	8b 11		 mov	 edx, DWORD PTR [ecx]
  00943	8b 82 e4 00 00
	00		 mov	 eax, DWORD PTR [edx+228]
  00949	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0094c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00952	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00954	7f 05		 jg	 SHORT $LN50@R_ProjectS

; 1218 : 				return;

  00956	e9 6b 05 00 00	 jmp	 $LN74@R_ProjectS
$LN50@R_ProjectS:

; 1219 : 		}
; 1220 : 	}
; 1221 : 
; 1222 : 	if (thing->subsector->sector->numlights)

  0095b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0095e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00961	8b 11		 mov	 edx, DWORD PTR [ecx]
  00963	83 ba a8 00 00
	00 00		 cmp	 DWORD PTR [edx+168], 0
  0096a	0f 84 82 00 00
	00		 je	 $LN55@R_ProjectS

; 1223 : 	{
; 1224 : 		INT32 lightnum;
; 1225 : 		light = R_GetPlaneLight(thing->subsector->sector, gzt, false);

  00970	6a 00		 push	 0
  00972	8b 45 ac	 mov	 eax, DWORD PTR _gzt$[ebp]
  00975	50		 push	 eax
  00976	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00979	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0097c	8b 02		 mov	 eax, DWORD PTR [edx]
  0097e	50		 push	 eax
  0097f	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00984	83 c4 0c	 add	 esp, 12			; 0000000cH
  00987	89 45 a4	 mov	 DWORD PTR _light$[ebp], eax

; 1226 : 		lightnum = (*thing->subsector->sector->lightlist[light].lightlevel >> LIGHTSEGSHIFT);

  0098a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0098d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00990	8b 11		 mov	 edx, DWORD PTR [ecx]
  00992	6b 45 a4 14	 imul	 eax, DWORD PTR _light$[ebp], 20
  00996	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  0099c	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  009a0	0f bf 02	 movsx	 eax, WORD PTR [edx]
  009a3	c1 f8 03	 sar	 eax, 3
  009a6	89 45 a0	 mov	 DWORD PTR _lightnum$2[ebp], eax

; 1227 : 
; 1228 : 		if (lightnum < 0)

  009a9	83 7d a0 00	 cmp	 DWORD PTR _lightnum$2[ebp], 0
  009ad	7d 16		 jge	 SHORT $LN52@R_ProjectS

; 1229 : 			spritelights = scalelight[0];

  009af	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  009b4	6b c8 00	 imul	 ecx, eax, 0
  009b7	81 c1 00 00 00
	00		 add	 ecx, OFFSET _scalelight
  009bd	89 0d 00 00 00
	00		 mov	 DWORD PTR _spritelights, ecx
  009c3	eb 2d		 jmp	 SHORT $LN55@R_ProjectS
$LN52@R_ProjectS:

; 1230 : 		else if (lightnum >= LIGHTLEVELS)

  009c5	83 7d a0 20	 cmp	 DWORD PTR _lightnum$2[ebp], 32 ; 00000020H
  009c9	7c 16		 jl	 SHORT $LN54@R_ProjectS

; 1231 : 			spritelights = scalelight[LIGHTLEVELS-1];

  009cb	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  009d0	6b c8 1f	 imul	 ecx, eax, 31
  009d3	81 c1 00 00 00
	00		 add	 ecx, OFFSET _scalelight
  009d9	89 0d 00 00 00
	00		 mov	 DWORD PTR _spritelights, ecx
  009df	eb 11		 jmp	 SHORT $LN55@R_ProjectS
$LN54@R_ProjectS:

; 1232 : 		else
; 1233 : 			spritelights = scalelight[lightnum];

  009e1	69 45 a0 c0 00
	00 00		 imul	 eax, DWORD PTR _lightnum$2[ebp], 192
  009e8	05 00 00 00 00	 add	 eax, OFFSET _scalelight
  009ed	a3 00 00 00 00	 mov	 DWORD PTR _spritelights, eax
$LN55@R_ProjectS:

; 1234 : 	}
; 1235 : 
; 1236 : 	heightsec = thing->subsector->sector->heightsec;

  009f2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  009f5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  009f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  009fa	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  009fd	89 45 a8	 mov	 DWORD PTR _heightsec$[ebp], eax

; 1237 : 
; 1238 : 	if (heightsec != -1)   // only clip things which are in special sectors

  00a00	83 7d a8 ff	 cmp	 DWORD PTR _heightsec$[ebp], -1
  00a04	0f 84 6b 01 00
	00		 je	 $LN58@R_ProjectS

; 1239 : 	{
; 1240 : 		INT32 phs = viewplayer->mo->subsector->sector->heightsec;

  00a0a	a1 00 00 00 00	 mov	 eax, DWORD PTR _viewplayer
  00a0f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a11	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00a14	8b 02		 mov	 eax, DWORD PTR [edx]
  00a16	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00a19	89 4d 9c	 mov	 DWORD PTR _phs$1[ebp], ecx

; 1241 : 		if (phs != -1 && viewz < sectors[phs].floorheight ?

  00a1c	83 7d 9c ff	 cmp	 DWORD PTR _phs$1[ebp], -1
  00a20	74 54		 je	 SHORT $LN76@R_ProjectS
  00a22	69 45 9c f8 00
	00 00		 imul	 eax, DWORD PTR _phs$1[ebp], 248
  00a29	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00a2f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00a35	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  00a38	7d 3c		 jge	 SHORT $LN76@R_ProjectS
  00a3a	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _heightsec$[ebp], 248
  00a41	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00a44	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sectors
  00a4a	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00a4d	3b 0c 02	 cmp	 ecx, DWORD PTR [edx+eax]
  00a50	7c 0c		 jl	 SHORT $LN79@R_ProjectS
  00a52	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv592[ebp], 1
  00a5c	eb 0a		 jmp	 SHORT $LN80@R_ProjectS
$LN79@R_ProjectS:
  00a5e	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv592[ebp], 0
$LN80@R_ProjectS:
  00a68	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv592[ebp]
  00a6e	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv593[ebp], edx
  00a74	eb 37		 jmp	 SHORT $LN81@R_ProjectS
$LN76@R_ProjectS:
  00a76	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _heightsec$[ebp], 248
  00a7d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00a83	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  00a86	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  00a89	7d 0c		 jge	 SHORT $LN77@R_ProjectS
  00a8b	c7 85 50 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv591[ebp], 1
  00a95	eb 0a		 jmp	 SHORT $LN78@R_ProjectS
$LN77@R_ProjectS:
  00a97	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv591[ebp], 0
$LN78@R_ProjectS:
  00aa1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv591[ebp]
  00aa7	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv593[ebp], eax
$LN81@R_ProjectS:
  00aad	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv593[ebp], 0
  00ab4	74 05		 je	 SHORT $LN57@R_ProjectS

; 1242 : 		    thing->z >= sectors[heightsec].floorheight :
; 1243 : 		    gzt < sectors[heightsec].floorheight)
; 1244 : 			return;

  00ab6	e9 0b 04 00 00	 jmp	 $LN74@R_ProjectS
$LN57@R_ProjectS:

; 1245 : 		if (phs != -1 && viewz > sectors[phs].ceilingheight ?

  00abb	83 7d 9c ff	 cmp	 DWORD PTR _phs$1[ebp], -1
  00abf	74 6c		 je	 SHORT $LN82@R_ProjectS
  00ac1	69 45 9c f8 00
	00 00		 imul	 eax, DWORD PTR _phs$1[ebp], 248
  00ac8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00ace	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00ad4	3b 54 01 04	 cmp	 edx, DWORD PTR [ecx+eax+4]
  00ad8	7e 53		 jle	 SHORT $LN82@R_ProjectS
  00ada	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _heightsec$[ebp], 248
  00ae1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00ae7	8b 55 ac	 mov	 edx, DWORD PTR _gzt$[ebp]
  00aea	3b 54 01 04	 cmp	 edx, DWORD PTR [ecx+eax+4]
  00aee	7d 25		 jge	 SHORT $LN83@R_ProjectS
  00af0	69 45 a8 f8 00
	00 00		 imul	 eax, DWORD PTR _heightsec$[ebp], 248
  00af7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sectors
  00afd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _viewz
  00b03	3b 54 01 04	 cmp	 edx, DWORD PTR [ecx+eax+4]
  00b07	7c 0c		 jl	 SHORT $LN83@R_ProjectS
  00b09	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv614[ebp], 1
  00b13	eb 0a		 jmp	 SHORT $LN86@R_ProjectS
$LN83@R_ProjectS:
  00b15	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv614[ebp], 0
$LN86@R_ProjectS:
  00b1f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv614[ebp]
  00b25	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv615[ebp], eax
  00b2b	eb 3a		 jmp	 SHORT $LN87@R_ProjectS
$LN82@R_ProjectS:
  00b2d	69 4d a8 f8 00
	00 00		 imul	 ecx, DWORD PTR _heightsec$[ebp], 248
  00b34	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00b37	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00b3c	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00b3f	3b 54 08 04	 cmp	 edx, DWORD PTR [eax+ecx+4]
  00b43	7c 0c		 jl	 SHORT $LN84@R_ProjectS
  00b45	c7 85 50 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv613[ebp], 1
  00b4f	eb 0a		 jmp	 SHORT $LN85@R_ProjectS
$LN84@R_ProjectS:
  00b51	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv613[ebp], 0
$LN85@R_ProjectS:
  00b5b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv613[ebp]
  00b61	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv615[ebp], eax
$LN87@R_ProjectS:
  00b67	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR tv615[ebp], 0
  00b6e	74 05		 je	 SHORT $LN58@R_ProjectS

; 1246 : 		     gzt < sectors[heightsec].ceilingheight &&
; 1247 : 		     viewz >= sectors[heightsec].ceilingheight :
; 1248 : 		     thing->z >= sectors[heightsec].ceilingheight)
; 1249 : 			return;

  00b70	e9 51 03 00 00	 jmp	 $LN74@R_ProjectS
$LN58@R_ProjectS:

; 1250 : 	}
; 1251 : 
; 1252 : 	// store information in a vissprite
; 1253 : 	vis = R_NewVisSprite();

  00b75	e8 00 00 00 00	 call	 _R_NewVisSprite
  00b7a	89 45 bc	 mov	 DWORD PTR _vis$[ebp], eax

; 1254 : 	vis->heightsec = heightsec; //SoM: 3/17/2000

  00b7d	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00b80	8b 4d a8	 mov	 ecx, DWORD PTR _heightsec$[ebp]
  00b83	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 1255 : 	vis->mobjflags = thing->flags;

  00b86	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00b89	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00b8c	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00b8f	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1256 : 	vis->scale = yscale + thing->info->dispoffset;           //<<detailshift;

  00b92	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00b95	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00b9b	8b 55 e0	 mov	 edx, DWORD PTR _yscale$[ebp]
  00b9e	03 51 48	 add	 edx, DWORD PTR [ecx+72]
  00ba1	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00ba4	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 1257 : 	vis->gx = thing->x;

  00ba7	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00baa	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00bad	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00bb0	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1258 : 	vis->gy = thing->y;

  00bb3	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bb6	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00bb9	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00bbc	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 1259 : 	vis->gz = gz;

  00bbf	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bc2	8b 4d b0	 mov	 ecx, DWORD PTR _gz$[ebp]
  00bc5	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 1260 : 	vis->gzt = gzt;

  00bc8	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bcb	8b 4d ac	 mov	 ecx, DWORD PTR _gzt$[ebp]
  00bce	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1261 : 	vis->thingheight = thing->height;

  00bd1	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bd4	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00bd7	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00bda	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 1262 : 	vis->pz = thing->z;

  00bdd	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00be0	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00be3	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00be6	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1263 : 	vis->pzt = vis->pz + vis->thingheight;

  00be9	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bec	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00bef	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00bf2	03 4a 58	 add	 ecx, DWORD PTR [edx+88]
  00bf5	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bf8	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1264 : 	vis->texturemid = vis->gzt - viewz;

  00bfb	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00bfe	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00c01	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _viewz
  00c07	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00c0a	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 1265 : 
; 1266 : 	vis->mobj = thing; // Easy access! Tails 06-07-2002

  00c0d	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00c10	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00c13	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1267 : 
; 1268 : 	vis->x1 = x1 < 0 ? 0 : x1;

  00c16	83 7d dc 00	 cmp	 DWORD PTR _x1$[ebp], 0
  00c1a	7d 0c		 jge	 SHORT $LN88@R_ProjectS
  00c1c	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv645[ebp], 0
  00c26	eb 09		 jmp	 SHORT $LN89@R_ProjectS
$LN88@R_ProjectS:
  00c28	8b 45 dc	 mov	 eax, DWORD PTR _x1$[ebp]
  00c2b	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv645[ebp], eax
$LN89@R_ProjectS:
  00c31	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00c34	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv645[ebp]
  00c3a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1269 : 	vis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;

  00c3d	8b 45 d8	 mov	 eax, DWORD PTR _x2$[ebp]
  00c40	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _viewwidth
  00c46	7c 11		 jl	 SHORT $LN90@R_ProjectS
  00c48	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _viewwidth
  00c4e	83 e9 01	 sub	 ecx, 1
  00c51	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv649[ebp], ecx
  00c57	eb 09		 jmp	 SHORT $LN91@R_ProjectS
$LN90@R_ProjectS:
  00c59	8b 55 d8	 mov	 edx, DWORD PTR _x2$[ebp]
  00c5c	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv649[ebp], edx
$LN91@R_ProjectS:
  00c62	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00c65	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv649[ebp]
  00c6b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1270 : 	vis->xscale = xscale; //SoM: 4/17/2000

  00c6e	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00c71	8b 4d e4	 mov	 ecx, DWORD PTR _xscale$[ebp]
  00c74	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 1271 : 	vis->sector = thing->subsector->sector;

  00c77	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00c7a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00c7d	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00c80	8b 01		 mov	 eax, DWORD PTR [ecx]
  00c82	89 42 5c	 mov	 DWORD PTR [edx+92], eax

; 1272 : 	vis->szt = (INT16)((centeryfrac - FixedMul(vis->gzt - viewz, yscale))>>FRACBITS);

  00c85	8b 45 e0	 mov	 eax, DWORD PTR _yscale$[ebp]
  00c88	50		 push	 eax
  00c89	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00c8c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00c8f	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _viewz
  00c95	52		 push	 edx
  00c96	e8 00 00 00 00	 call	 _FixedMul
  00c9b	83 c4 08	 add	 esp, 8
  00c9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  00ca4	2b c8		 sub	 ecx, eax
  00ca6	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00ca9	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00cac	66 89 4a 62	 mov	 WORD PTR [edx+98], cx

; 1273 : 	vis->sz = (INT16)((centeryfrac - FixedMul(vis->gz - viewz, yscale))>>FRACBITS);

  00cb0	8b 45 e0	 mov	 eax, DWORD PTR _yscale$[ebp]
  00cb3	50		 push	 eax
  00cb4	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00cb7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00cba	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _viewz
  00cc0	52		 push	 edx
  00cc1	e8 00 00 00 00	 call	 _FixedMul
  00cc6	83 c4 08	 add	 esp, 8
  00cc9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  00ccf	2b c8		 sub	 ecx, eax
  00cd1	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00cd4	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00cd7	66 89 4a 60	 mov	 WORD PTR [edx+96], cx

; 1274 : 	vis->cut = false;

  00cdb	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00cde	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0

; 1275 : 	if (thing->subsector->sector->numlights)

  00ce5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ce8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00ceb	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ced	83 ba a8 00 00
	00 00		 cmp	 DWORD PTR [edx+168], 0
  00cf4	74 1e		 je	 SHORT $LN59@R_ProjectS

; 1276 : 		vis->extra_colormap = thing->subsector->sector->lightlist[light].extra_colormap;

  00cf6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00cf9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00cfc	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cfe	6b 45 a4 14	 imul	 eax, DWORD PTR _light$[ebp], 20
  00d02	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  00d08	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00d0b	8b 44 01 08	 mov	 eax, DWORD PTR [ecx+eax+8]
  00d0f	89 42 50	 mov	 DWORD PTR [edx+80], eax
  00d12	eb 14		 jmp	 SHORT $LN60@R_ProjectS
$LN59@R_ProjectS:

; 1277 : 	else
; 1278 : 		vis->extra_colormap = thing->subsector->sector->extra_colormap;

  00d14	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00d17	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00d1a	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d1c	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d1f	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  00d25	89 48 50	 mov	 DWORD PTR [eax+80], ecx
$LN60@R_ProjectS:

; 1279 : 
; 1280 : 	iscale = FixedDiv(FRACUNIT, xscale);

  00d28	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  00d2b	50		 push	 eax
  00d2c	68 00 00 01 00	 push	 65536			; 00010000H
  00d31	e8 00 00 00 00	 call	 _FixedDiv
  00d36	83 c4 08	 add	 esp, 8
  00d39	89 45 b4	 mov	 DWORD PTR _iscale$[ebp], eax

; 1281 : 
; 1282 : 	if (flip)

  00d3c	0f b6 45 c7	 movzx	 eax, BYTE PTR _flip$[ebp]
  00d40	85 c0		 test	 eax, eax
  00d42	74 25		 je	 SHORT $LN61@R_ProjectS

; 1283 : 	{
; 1284 : 		vis->startfrac = spritecachedinfo[lump].width-1;

  00d44	8b 45 cc	 mov	 eax, DWORD PTR _lump$[ebp]
  00d47	c1 e0 04	 shl	 eax, 4
  00d4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritecachedinfo
  00d50	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00d53	83 ea 01	 sub	 edx, 1
  00d56	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d59	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 1285 : 		vis->xiscale = -iscale;

  00d5c	8b 45 b4	 mov	 eax, DWORD PTR _iscale$[ebp]
  00d5f	f7 d8		 neg	 eax
  00d61	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00d64	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 1286 : 	}

  00d67	eb 13		 jmp	 SHORT $LN62@R_ProjectS
$LN61@R_ProjectS:

; 1287 : 	else
; 1288 : 	{
; 1289 : 		vis->startfrac = 0;

  00d69	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d6c	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 1290 : 		vis->xiscale = iscale;

  00d73	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d76	8b 4d b4	 mov	 ecx, DWORD PTR _iscale$[ebp]
  00d79	89 48 34	 mov	 DWORD PTR [eax+52], ecx
$LN62@R_ProjectS:

; 1291 : 	}
; 1292 : 
; 1293 : 	if (vis->x1 > x1)

  00d7c	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d7f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00d82	3b 4d dc	 cmp	 ecx, DWORD PTR _x1$[ebp]
  00d85	7e 1c		 jle	 SHORT $LN63@R_ProjectS

; 1294 : 		vis->startfrac += vis->xiscale*(vis->x1-x1);

  00d87	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d8a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00d8d	2b 4d dc	 sub	 ecx, DWORD PTR _x1$[ebp]
  00d90	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00d93	0f af 4a 34	 imul	 ecx, DWORD PTR [edx+52]
  00d97	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00d9a	03 48 2c	 add	 ecx, DWORD PTR [eax+44]
  00d9d	8b 55 bc	 mov	 edx, DWORD PTR _vis$[ebp]
  00da0	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$LN63@R_ProjectS:

; 1295 : 
; 1296 : 	//Fab: lumppat is the lump number of the patch to use, this is different
; 1297 : 	//     than lumpid for sprites-in-pwad : the graphics are patched
; 1298 : 	vis->patch = sprframe->lumppat[rot];

  00da3	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00da6	8b 4d c8	 mov	 ecx, DWORD PTR _rot$[ebp]
  00da9	8b 55 d0	 mov	 edx, DWORD PTR _sprframe$[ebp]
  00dac	8b 4c 8a 04	 mov	 ecx, DWORD PTR [edx+ecx*4+4]
  00db0	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1299 : 
; 1300 : //
; 1301 : // determine the colormap (lightlevel & special effects)
; 1302 : //
; 1303 : 	vis->transmap = NULL;

  00db3	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00db6	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 1304 : 
; 1305 : 	// specific translucency
; 1306 : 	if (thing->flags2 & MF2_SHADOW) // actually only the player should use this (temporary invisibility)

  00dbd	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00dc0	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00dc6	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00dcc	74 12		 je	 SHORT $LN64@R_ProjectS

; 1307 : 		vis->transmap = ((tr_trans80-1)<<FF_TRANSSHIFT) + transtables; // because now the translucency is set through FF_TRANSMASK

  00dce	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtables
  00dd3	05 00 00 07 00	 add	 eax, 458752		; 00070000H
  00dd8	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00ddb	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  00dde	eb 2d		 jmp	 SHORT $LN66@R_ProjectS
$LN64@R_ProjectS:

; 1308 : 	else if (thing->frame & FF_TRANSMASK)

  00de0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00de3	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00de6	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  00dec	74 1f		 je	 SHORT $LN66@R_ProjectS

; 1309 : 		vis->transmap = (thing->frame & FF_TRANSMASK) - 0x10000 + transtables;

  00dee	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00df1	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00df4	81 e1 00 00 0f
	00		 and	 ecx, 983040		; 000f0000H
  00dfa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _transtables
  00e00	8d 84 0a 00 00
	ff ff		 lea	 eax, DWORD PTR [edx+ecx-65536]
  00e07	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00e0a	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN66@R_ProjectS:

; 1310 : 
; 1311 : 	if (((thing->frame & (FF_FULLBRIGHT|FF_TRANSMASK)) || (thing->flags2 & MF2_SHADOW))
; 1312 : 		&& (!vis->extra_colormap || !vis->extra_colormap->fog))

  00e0d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00e10	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00e13	81 e1 00 80 0f
	00		 and	 ecx, 1015808		; 000f8000H
  00e19	75 11		 jne	 SHORT $LN69@R_ProjectS
  00e1b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00e1e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00e24	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00e2a	74 23		 je	 SHORT $LN67@R_ProjectS
$LN69@R_ProjectS:
  00e2c	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e2f	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00e33	74 0c		 je	 SHORT $LN70@R_ProjectS
  00e35	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e38	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00e3b	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00e3f	75 0e		 jne	 SHORT $LN67@R_ProjectS
$LN70@R_ProjectS:

; 1313 : 	{
; 1314 : 		// full bright: goggles
; 1315 : 		vis->colormap = colormaps;

  00e41	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _colormaps
  00e4a	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 1316 : 	}

  00e4d	eb 28		 jmp	 SHORT $LN68@R_ProjectS
$LN67@R_ProjectS:

; 1317 : 	else
; 1318 : 	{
; 1319 : 		// diminished light
; 1320 : 		lindex = xscale>>(LIGHTSCALESHIFT);

  00e4f	8b 45 e4	 mov	 eax, DWORD PTR _xscale$[ebp]
  00e52	c1 f8 0c	 sar	 eax, 12			; 0000000cH
  00e55	89 45 c0	 mov	 DWORD PTR _lindex$[ebp], eax

; 1321 : 
; 1322 : 		if (lindex >= MAXLIGHTSCALE)

  00e58	83 7d c0 30	 cmp	 DWORD PTR _lindex$[ebp], 48 ; 00000030H
  00e5c	7c 07		 jl	 SHORT $LN71@R_ProjectS

; 1323 : 			lindex = MAXLIGHTSCALE-1;

  00e5e	c7 45 c0 2f 00
	00 00		 mov	 DWORD PTR _lindex$[ebp], 47 ; 0000002fH
$LN71@R_ProjectS:

; 1324 : 
; 1325 : 		vis->colormap = spritelights[lindex];

  00e65	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e68	8b 4d c0	 mov	 ecx, DWORD PTR _lindex$[ebp]
  00e6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritelights
  00e71	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00e74	89 48 40	 mov	 DWORD PTR [eax+64], ecx
$LN68@R_ProjectS:

; 1326 : 	}
; 1327 : 
; 1328 : 	vis->precip = false;

  00e77	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e7a	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 1329 : 
; 1330 : 	if (thing->eflags & MFE_VERTICALFLIP)

  00e81	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00e84	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00e8a	83 e1 20	 and	 ecx, 32			; 00000020H
  00e8d	74 0c		 je	 SHORT $LN72@R_ProjectS

; 1331 : 		vis->vflip = true;

  00e8f	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e92	c7 40 6c 01 00
	00 00		 mov	 DWORD PTR [eax+108], 1
  00e99	eb 0a		 jmp	 SHORT $LN73@R_ProjectS
$LN72@R_ProjectS:

; 1332 : 	else
; 1333 : 		vis->vflip = false;

  00e9b	8b 45 bc	 mov	 eax, DWORD PTR _vis$[ebp]
  00e9e	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
$LN73@R_ProjectS:

; 1334 : 
; 1335 : 	if (thing->subsector->sector->numlights)

  00ea5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ea8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00eab	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ead	83 ba a8 00 00
	00 00		 cmp	 DWORD PTR [edx+168], 0
  00eb4	74 10		 je	 SHORT $LN74@R_ProjectS

; 1336 : 		R_SplitSprite(vis, thing);

  00eb6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00eb9	50		 push	 eax
  00eba	8b 4d bc	 mov	 ecx, DWORD PTR _vis$[ebp]
  00ebd	51		 push	 ecx
  00ebe	e8 00 00 00 00	 call	 _R_SplitSprite
  00ec3	83 c4 08	 add	 esp, 8
$LN74@R_ProjectS:

; 1337 : }

  00ec6	5f		 pop	 edi
  00ec7	5e		 pop	 esi
  00ec8	5b		 pop	 ebx
  00ec9	8b e5		 mov	 esp, ebp
  00ecb	5d		 pop	 ebp
  00ecc	c3		 ret	 0
_R_ProjectSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_SplitSprite
_TEXT	SEGMENT
_newsprite$ = -24					; size = 4
_sector$ = -20						; size = 4
_cutfrac$ = -16						; size = 2
_lindex$ = -12						; size = 4
_lightnum$ = -8						; size = 4
_i$ = -4						; size = 4
_sprite$ = 8						; size = 4
_thing$ = 12						; size = 4
_R_SplitSprite PROC					; COMDAT

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 903  : 	INT32 i, lightnum, lindex;
; 904  : 	INT16 cutfrac;
; 905  : 	sector_t *sector;
; 906  : 	vissprite_t *newsprite;
; 907  : 
; 908  : 	sector = sprite->sector;

  00009	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  0000c	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0000f	89 4d ec	 mov	 DWORD PTR _sector$[ebp], ecx

; 909  : 
; 910  : 	for (i = 1; i < sector->numlights; i++)

  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00019	eb 09		 jmp	 SHORT $LN4@R_SplitSpr
$LN2@R_SplitSpr:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_SplitSpr:
  00024	8b 45 ec	 mov	 eax, DWORD PTR _sector$[ebp]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002a	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  00030	0f 8d 98 02 00
	00		 jge	 $LN3@R_SplitSpr

; 911  : 	{
; 912  : 		if (sector->lightlist[i].height >= sprite->gzt || !(sector->lightlist[i].caster->flags & FF_CUTSPRITES))

  00036	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  0003d	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00046	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  00049	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  0004c	7d 1c		 jge	 SHORT $LN6@R_SplitSpr
  0004e	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00052	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00055	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0005b	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  0005f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00062	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00068	75 02		 jne	 SHORT $LN5@R_SplitSpr
$LN6@R_SplitSpr:

; 913  : 			continue;

  0006a	eb af		 jmp	 SHORT $LN2@R_SplitSpr
$LN5@R_SplitSpr:

; 914  : 		if (sector->lightlist[i].height <= sprite->gz)

  0006c	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00073	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _sprite$[ebp]
  0007c	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  0007f	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  00082	7f 05		 jg	 SHORT $LN7@R_SplitSpr

; 915  : 			return;

  00084	e9 45 02 00 00	 jmp	 $LN3@R_SplitSpr
$LN7@R_SplitSpr:

; 916  : 
; 917  : 		cutfrac = (INT16)((centeryfrac - FixedMul(sector->lightlist[i].height - viewz, sprite->scale))>>FRACBITS);

  00089	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  0008c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0008f	51		 push	 ecx
  00090	6b 55 fc 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  00094	8b 45 ec	 mov	 eax, DWORD PTR _sector$[ebp]
  00097	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0009d	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  000a0	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _viewz
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 _FixedMul
  000ac	83 c4 08	 add	 esp, 8
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _centeryfrac
  000b5	2b c8		 sub	 ecx, eax
  000b7	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000ba	66 89 4d f0	 mov	 WORD PTR _cutfrac$[ebp], cx

; 918  : 		if (cutfrac < 0)

  000be	0f bf 45 f0	 movsx	 eax, WORD PTR _cutfrac$[ebp]
  000c2	85 c0		 test	 eax, eax
  000c4	7d 05		 jge	 SHORT $LN8@R_SplitSpr

; 919  : 			continue;

  000c6	e9 50 ff ff ff	 jmp	 $LN2@R_SplitSpr
$LN8@R_SplitSpr:

; 920  : 		if (cutfrac > vid.height)

  000cb	0f bf 45 f0	 movsx	 eax, WORD PTR _cutfrac$[ebp]
  000cf	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  000d5	7e 05		 jle	 SHORT $LN9@R_SplitSpr

; 921  : 			return;

  000d7	e9 f2 01 00 00	 jmp	 $LN3@R_SplitSpr
$LN9@R_SplitSpr:

; 922  : 
; 923  : 		// Found a split! Make a new sprite, copy the old sprite to it, and
; 924  : 		// adjust the heights.
; 925  : 		newsprite = M_Memcpy(R_NewVisSprite(), sprite, sizeof (vissprite_t));

  000dc	6a 70		 push	 112			; 00000070H
  000de	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _R_NewVisSprite
  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f1	89 45 e8	 mov	 DWORD PTR _newsprite$[ebp], eax

; 926  : 
; 927  : 		sprite->cut |= SC_BOTTOM;

  000f4	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  000f7	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000fa	83 c9 02	 or	 ecx, 2
  000fd	8b 55 08	 mov	 edx, DWORD PTR _sprite$[ebp]
  00100	89 4a 64	 mov	 DWORD PTR [edx+100], ecx

; 928  : 		sprite->gz = sector->lightlist[i].height;

  00103	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00107	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  0010a	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00113	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  00116	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 929  : 
; 930  : 		newsprite->gzt = sprite->gz;

  00119	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  0011c	8b 4d 08	 mov	 ecx, DWORD PTR _sprite$[ebp]
  0011f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00122	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 931  : 
; 932  : 		sprite->sz = cutfrac;

  00125	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  00128	66 8b 4d f0	 mov	 cx, WORD PTR _cutfrac$[ebp]
  0012c	66 89 48 60	 mov	 WORD PTR [eax+96], cx

; 933  : 		newsprite->szt = (INT16)(sprite->sz - 1);

  00130	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  00133	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  00137	83 e9 01	 sub	 ecx, 1
  0013a	8b 55 e8	 mov	 edx, DWORD PTR _newsprite$[ebp]
  0013d	66 89 4a 62	 mov	 WORD PTR [edx+98], cx

; 934  : 
; 935  : 		if (sector->lightlist[i].height < sprite->pzt && sector->lightlist[i].height > sprite->pz)

  00141	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00145	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00148	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00151	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  00154	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  00157	7d 3c		 jge	 SHORT $LN10@R_SplitSpr
  00159	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0015d	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00160	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00166	8b 4d 08	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00169	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  0016c	3b 51 24	 cmp	 edx, DWORD PTR [ecx+36]
  0016f	7e 24		 jle	 SHORT $LN10@R_SplitSpr

; 936  : 			sprite->pz = newsprite->pzt = sector->lightlist[i].height;

  00171	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00175	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00178	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0017e	8b 4d e8	 mov	 ecx, DWORD PTR _newsprite$[ebp]
  00181	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  00184	89 51 28	 mov	 DWORD PTR [ecx+40], edx
  00187	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  0018a	8b 4d e8	 mov	 ecx, DWORD PTR _newsprite$[ebp]
  0018d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00190	89 50 24	 mov	 DWORD PTR [eax+36], edx
  00193	eb 18		 jmp	 SHORT $LN11@R_SplitSpr
$LN10@R_SplitSpr:

; 937  : 		else
; 938  : 		{
; 939  : 			newsprite->pz = newsprite->gz;

  00195	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  00198	8b 4d e8	 mov	 ecx, DWORD PTR _newsprite$[ebp]
  0019b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0019e	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 940  : 			newsprite->pzt = newsprite->gzt;

  001a1	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  001a4	8b 4d e8	 mov	 ecx, DWORD PTR _newsprite$[ebp]
  001a7	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001aa	89 50 28	 mov	 DWORD PTR [eax+40], edx
$LN11@R_SplitSpr:

; 941  : 		}
; 942  : 
; 943  : 		newsprite->szt -= 8;

  001ad	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  001b0	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  001b4	83 e9 08	 sub	 ecx, 8
  001b7	8b 55 e8	 mov	 edx, DWORD PTR _newsprite$[ebp]
  001ba	66 89 4a 62	 mov	 WORD PTR [edx+98], cx

; 944  : 
; 945  : 		newsprite->cut |= SC_TOP;

  001be	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  001c1	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  001c4	83 c9 01	 or	 ecx, 1
  001c7	8b 55 e8	 mov	 edx, DWORD PTR _newsprite$[ebp]
  001ca	89 4a 64	 mov	 DWORD PTR [edx+100], ecx

; 946  : 		if (!(sector->lightlist[i].caster->flags & FF_NOSHADE))

  001cd	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  001d1	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  001d4	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  001da	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  001de	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001e1	83 e1 40	 and	 ecx, 64			; 00000040H
  001e4	0f 85 d9 00 00
	00		 jne	 $LN17@R_SplitSpr

; 947  : 		{
; 948  : 			lightnum = (*sector->lightlist[i].lightlevel >> LIGHTSEGSHIFT);

  001ea	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  001ee	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  001f1	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  001f7	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  001fb	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  001fe	c1 f9 03	 sar	 ecx, 3
  00201	89 4d f8	 mov	 DWORD PTR _lightnum$[ebp], ecx

; 949  : 
; 950  : 			if (lightnum < 0)

  00204	83 7d f8 00	 cmp	 DWORD PTR _lightnum$[ebp], 0
  00208	7d 16		 jge	 SHORT $LN13@R_SplitSpr

; 951  : 				spritelights = scalelight[0];

  0020a	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  0020f	6b c8 00	 imul	 ecx, eax, 0
  00212	81 c1 00 00 00
	00		 add	 ecx, OFFSET _scalelight
  00218	89 0d 00 00 00
	00		 mov	 DWORD PTR _spritelights, ecx
  0021e	eb 2d		 jmp	 SHORT $LN16@R_SplitSpr
$LN13@R_SplitSpr:

; 952  : 			else if (lightnum >= LIGHTLEVELS)

  00220	83 7d f8 20	 cmp	 DWORD PTR _lightnum$[ebp], 32 ; 00000020H
  00224	7c 16		 jl	 SHORT $LN15@R_SplitSpr

; 953  : 				spritelights = scalelight[LIGHTLEVELS-1];

  00226	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  0022b	6b c8 1f	 imul	 ecx, eax, 31
  0022e	81 c1 00 00 00
	00		 add	 ecx, OFFSET _scalelight
  00234	89 0d 00 00 00
	00		 mov	 DWORD PTR _spritelights, ecx
  0023a	eb 11		 jmp	 SHORT $LN16@R_SplitSpr
$LN15@R_SplitSpr:

; 954  : 			else
; 955  : 				spritelights = scalelight[lightnum];

  0023c	69 45 f8 c0 00
	00 00		 imul	 eax, DWORD PTR _lightnum$[ebp], 192
  00243	05 00 00 00 00	 add	 eax, OFFSET _scalelight
  00248	a3 00 00 00 00	 mov	 DWORD PTR _spritelights, eax
$LN16@R_SplitSpr:

; 956  : 
; 957  : 			newsprite->extra_colormap = sector->lightlist[i].extra_colormap;

  0024d	6b 45 fc 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00251	8b 4d ec	 mov	 ecx, DWORD PTR _sector$[ebp]
  00254	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0025a	8b 4d e8	 mov	 ecx, DWORD PTR _newsprite$[ebp]
  0025d	8b 54 02 08	 mov	 edx, DWORD PTR [edx+eax+8]
  00261	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 958  : 
; 959  : /*
; 960  : 			if (thing->frame & FF_TRANSMASK)
; 961  : 				;
; 962  : 			else if (thing->flags2 & MF2_SHADOW)
; 963  : 				;
; 964  : 			else
; 965  : */
; 966  : 			if (!((thing->frame & (FF_FULLBRIGHT|FF_TRANSMASK) || thing->flags2 & MF2_SHADOW)

  00264	8b 45 0c	 mov	 eax, DWORD PTR _thing$[ebp]
  00267	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0026a	81 e1 00 80 0f
	00		 and	 ecx, 1015808		; 000f8000H
  00270	75 11		 jne	 SHORT $LN19@R_SplitSpr
  00272	8b 45 0c	 mov	 eax, DWORD PTR _thing$[ebp]
  00275	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0027b	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00281	74 15		 je	 SHORT $LN18@R_SplitSpr
$LN19@R_SplitSpr:
  00283	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  00286	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  0028a	74 37		 je	 SHORT $LN17@R_SplitSpr
  0028c	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  0028f	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00292	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00296	74 2b		 je	 SHORT $LN17@R_SplitSpr
$LN18@R_SplitSpr:

; 967  : 				&& (!newsprite->extra_colormap || !newsprite->extra_colormap->fog)))
; 968  : 			{
; 969  : 				lindex = sprite->xscale>>(LIGHTSCALESHIFT);

  00298	8b 45 08	 mov	 eax, DWORD PTR _sprite$[ebp]
  0029b	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0029e	c1 f9 0c	 sar	 ecx, 12			; 0000000cH
  002a1	89 4d f4	 mov	 DWORD PTR _lindex$[ebp], ecx

; 970  : 
; 971  : 				if (lindex >= MAXLIGHTSCALE)

  002a4	83 7d f4 30	 cmp	 DWORD PTR _lindex$[ebp], 48 ; 00000030H
  002a8	7c 07		 jl	 SHORT $LN20@R_SplitSpr

; 972  : 					lindex = MAXLIGHTSCALE-1;

  002aa	c7 45 f4 2f 00
	00 00		 mov	 DWORD PTR _lindex$[ebp], 47 ; 0000002fH
$LN20@R_SplitSpr:

; 973  : 				newsprite->colormap = spritelights[lindex];

  002b1	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  002b4	8b 4d f4	 mov	 ecx, DWORD PTR _lindex$[ebp]
  002b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritelights
  002bd	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  002c0	89 48 40	 mov	 DWORD PTR [eax+64], ecx
$LN17@R_SplitSpr:

; 974  : 			}
; 975  : 		}
; 976  : 		sprite = newsprite;

  002c3	8b 45 e8	 mov	 eax, DWORD PTR _newsprite$[ebp]
  002c6	89 45 08	 mov	 DWORD PTR _sprite$[ebp], eax

; 977  : 	}

  002c9	e9 4d fd ff ff	 jmp	 $LN2@R_SplitSpr
$LN3@R_SplitSpr:

; 978  : }

  002ce	5f		 pop	 edi
  002cf	5e		 pop	 esi
  002d0	5b		 pop	 ebx
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c3		 ret	 0
_R_SplitSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DrawPrecipitationVisSprite
_TEXT	SEGMENT
_patch$ = -12						; size = 4
_frac$ = -8						; size = 4
_column$ = -4						; size = 4
_vis$ = 8						; size = 4
_R_DrawPrecipitationVisSprite PROC			; COMDAT

; 844  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 845  : 	column_t *column;
; 846  : #ifdef RANGECHECK
; 847  : 	INT32 texturecolumn;
; 848  : #endif
; 849  : 	fixed_t frac;
; 850  : 	patch_t *patch;
; 851  : 
; 852  : 	//Fab : R_InitSprites now sets a wad lump number
; 853  : 	patch = W_CacheLumpNum(vis->patch, PU_CACHE);

  00009	6a 65		 push	 101			; 00000065H
  0000b	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0000e	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00017	83 c4 08	 add	 esp, 8
  0001a	89 45 f4	 mov	 DWORD PTR _patch$[ebp], eax

; 854  : 	if (!patch)

  0001d	83 7d f4 00	 cmp	 DWORD PTR _patch$[ebp], 0
  00021	75 05		 jne	 SHORT $LN5@R_DrawPrec

; 855  : 		return;

  00023	e9 3f 01 00 00	 jmp	 $LN1@R_DrawPrec
$LN5@R_DrawPrec:

; 856  : 
; 857  : 	if (vis->transmap)

  00028	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0002b	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0002f	74 16		 je	 SHORT $LN6@R_DrawPrec

; 858  : 	{
; 859  : 		colfunc = fuzzcolfunc;

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _fuzzcolfunc
  00036	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax

; 860  : 		dc_transmap = vis->transmap;    //Fab : 29-04-98: translucency table

  0003b	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0003e	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00041	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_transmap, ecx
$LN6@R_DrawPrec:

; 861  : 	}
; 862  : 
; 863  : 	dc_colormap = colormaps;

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _colormaps
  0004c	a3 00 00 00 00	 mov	 DWORD PTR _dc_colormap, eax

; 864  : 
; 865  : 	dc_iscale = FixedDiv(FRACUNIT, vis->scale);

  00051	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00054	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00057	51		 push	 ecx
  00058	68 00 00 01 00	 push	 65536			; 00010000H
  0005d	e8 00 00 00 00	 call	 _FixedDiv
  00062	83 c4 08	 add	 esp, 8
  00065	a3 00 00 00 00	 mov	 DWORD PTR _dc_iscale, eax

; 866  : 	dc_texturemid = vis->texturemid;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0006d	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00070	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_texturemid, ecx

; 867  : 	dc_texheight = 0;

  00076	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dc_texheight, 0

; 868  : 
; 869  : 	frac = vis->startfrac;

  00080	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00083	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00086	89 4d f8	 mov	 DWORD PTR _frac$[ebp], ecx

; 870  : 	spryscale = vis->scale;

  00089	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0008c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0008f	89 0d 00 00 00
	00		 mov	 DWORD PTR _spryscale, ecx

; 871  : 	sprtopscreen = centeryfrac - FixedMul(dc_texturemid,spryscale);

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _spryscale
  0009a	50		 push	 eax
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_texturemid
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 _FixedMul
  000a7	83 c4 08	 add	 esp, 8
  000aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _centeryfrac
  000b0	2b d0		 sub	 edx, eax
  000b2	89 15 00 00 00
	00		 mov	 DWORD PTR _sprtopscreen, edx

; 872  : 	windowtop = windowbottom = sprbotscreen = INT32_MAX;

  000b8	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR _sprbotscreen, 2147483647 ; 7fffffffH
  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _sprbotscreen
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _windowbottom, eax
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _windowbottom
  000d2	89 0d 00 00 00
	00		 mov	 DWORD PTR _windowtop, ecx

; 873  : 
; 874  : 	if (vis->x1 < 0)

  000d8	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  000db	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000df	7d 0a		 jge	 SHORT $LN7@R_DrawPrec

; 875  : 		vis->x1 = 0;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  000e4	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN7@R_DrawPrec:

; 876  : 
; 877  : 	if (vis->x2 >= vid.width)

  000eb	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  000ee	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000f1	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR _vid+12
  000f7	7c 0e		 jl	 SHORT $LN8@R_DrawPrec

; 878  : 		vis->x2 = vid.width-1;

  000f9	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000fe	83 e8 01	 sub	 eax, 1
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00104	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN8@R_DrawPrec:

; 879  : 
; 880  : 	for (dc_x = vis->x1; dc_x <= vis->x2; dc_x++, frac += vis->xiscale)

  00107	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0010a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0010d	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_x, ecx
  00113	eb 19		 jmp	 SHORT $LN4@R_DrawPrec
$LN2@R_DrawPrec:
  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  0011a	83 c0 01	 add	 eax, 1
  0011d	a3 00 00 00 00	 mov	 DWORD PTR _dc_x, eax
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00125	8b 55 f8	 mov	 edx, DWORD PTR _frac$[ebp]
  00128	03 51 34	 add	 edx, DWORD PTR [ecx+52]
  0012b	89 55 f8	 mov	 DWORD PTR _frac$[ebp], edx
$LN4@R_DrawPrec:
  0012e	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_x
  00137	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0013a	7f 21		 jg	 SHORT $LN3@R_DrawPrec

; 881  : 	{
; 882  : #ifdef RANGECHECK
; 883  : 		texturecolumn = frac>>FRACBITS;
; 884  : 
; 885  : 		if (texturecolumn < 0 || texturecolumn >= SHORT(patch->width))
; 886  : 			I_Error("R_DrawPrecipitationSpriteRange: bad texturecolumn");
; 887  : 
; 888  : 		column = (column_t *)((UINT8 *)patch + LONG(patch->columnofs[texturecolumn]));
; 889  : #else
; 890  : 		column = (column_t *)((UINT8 *)patch + LONG(patch->columnofs[frac>>FRACBITS]));

  0013c	8b 45 f8	 mov	 eax, DWORD PTR _frac$[ebp]
  0013f	c1 f8 10	 sar	 eax, 16			; 00000010H
  00142	8b 4d f4	 mov	 ecx, DWORD PTR _patch$[ebp]
  00145	8b 55 f4	 mov	 edx, DWORD PTR _patch$[ebp]
  00148	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  0014c	89 55 fc	 mov	 DWORD PTR _column$[ebp], edx

; 891  : #endif
; 892  : 		R_DrawMaskedColumn(column);

  0014f	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _R_DrawMaskedColumn
  00158	83 c4 04	 add	 esp, 4

; 893  : 	}

  0015b	eb b8		 jmp	 SHORT $LN2@R_DrawPrec
$LN3@R_DrawPrec:

; 894  : 
; 895  : 	colfunc = basecolfunc;

  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR _basecolfunc
  00162	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax
$LN1@R_DrawPrec:

; 896  : }

  00167	5f		 pop	 edi
  00168	5e		 pop	 esi
  00169	5b		 pop	 ebx
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
_R_DrawPrecipitationVisSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DrawVisSprite
_TEXT	SEGMENT
tv139 = -104						; size = 4
_oldpatch$1 = -36					; size = 4
_destcol$2 = -32					; size = 4
_dest$3 = -28						; size = 4
_source$4 = -24						; size = 4
_count$5 = -20						; size = 4
_x$6 = -16						; size = 4
_patch$ = -12						; size = 4
_frac$ = -8						; size = 4
_column$ = -4						; size = 4
_vis$ = 8						; size = 4
_R_DrawVisSprite PROC					; COMDAT

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 642  : 	column_t *column;
; 643  : #ifdef RANGECHECK
; 644  : 	INT32 texturecolumn;
; 645  : #endif
; 646  : 	fixed_t frac;
; 647  : 	patch_t *patch;
; 648  : 
; 649  : 	// flip it in memory here
; 650  : 	if (vis->vflip)

  00009	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0000c	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  00010	0f 84 6b 01 00
	00		 je	 $LN15@R_DrawVisS

; 651  : 	{
; 652  : 		INT32 x, count;
; 653  : 		UINT8 *source, *dest;
; 654  : 		column_t *destcol;
; 655  : 		patch_t *oldpatch;
; 656  : 
; 657  : 		oldpatch = W_CacheLumpNum(vis->patch, PU_STATIC);

  00016	6a 01		 push	 1
  00018	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0001b	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _W_CacheLumpNum
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 dc	 mov	 DWORD PTR _oldpatch$1[ebp], eax

; 658  : 		patch = W_CacheLumpNumForce(vis->patch, PU_STATIC);

  0002a	6a 01		 push	 1
  0002c	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0002f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _W_CacheLumpNumForce
  00038	83 c4 08	 add	 esp, 8
  0003b	89 45 f4	 mov	 DWORD PTR _patch$[ebp], eax

; 659  : 
; 660  : 		if (!(oldpatch && patch))

  0003e	83 7d dc 00	 cmp	 DWORD PTR _oldpatch$1[ebp], 0
  00042	74 06		 je	 SHORT $LN18@R_DrawVisS
  00044	83 7d f4 00	 cmp	 DWORD PTR _patch$[ebp], 0
  00048	75 05		 jne	 SHORT $LN17@R_DrawVisS
$LN18@R_DrawVisS:

; 661  : 			return;

  0004a	e9 2a 06 00 00	 jmp	 $LN48@R_DrawVisS
$LN17@R_DrawVisS:

; 662  : 
; 663  : 		for (x = 0; x < SHORT(oldpatch->width); x++)

  0004f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _x$6[ebp], 0
  00056	eb 09		 jmp	 SHORT $LN4@R_DrawVisS
$LN2@R_DrawVisS:
  00058	8b 45 f0	 mov	 eax, DWORD PTR _x$6[ebp]
  0005b	83 c0 01	 add	 eax, 1
  0005e	89 45 f0	 mov	 DWORD PTR _x$6[ebp], eax
$LN4@R_DrawVisS:
  00061	8b 45 dc	 mov	 eax, DWORD PTR _oldpatch$1[ebp]
  00064	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00067	39 4d f0	 cmp	 DWORD PTR _x$6[ebp], ecx
  0006a	0f 8d ec 00 00
	00		 jge	 $LN3@R_DrawVisS

; 664  : 		{
; 665  : 			column = (column_t *)((UINT8 *)oldpatch + LONG(oldpatch->columnofs[x]));

  00070	8b 45 f0	 mov	 eax, DWORD PTR _x$6[ebp]
  00073	8b 4d dc	 mov	 ecx, DWORD PTR _oldpatch$1[ebp]
  00076	8b 55 dc	 mov	 edx, DWORD PTR _oldpatch$1[ebp]
  00079	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  0007d	89 55 fc	 mov	 DWORD PTR _column$[ebp], edx

; 666  : 			destcol = (column_t *)((UINT8 *)patch + LONG(patch->columnofs[x]));

  00080	8b 45 f0	 mov	 eax, DWORD PTR _x$6[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR _patch$[ebp]
  00086	8b 55 f4	 mov	 edx, DWORD PTR _patch$[ebp]
  00089	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  0008d	89 55 e0	 mov	 DWORD PTR _destcol$2[ebp], edx
$LN5@R_DrawVisS:

; 667  : 
; 668  : 			while (column->topdelta != 0xff)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  00093	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00096	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0009c	0f 84 b5 00 00
	00		 je	 $LN6@R_DrawVisS

; 669  : 			{
; 670  : 				destcol->topdelta = (UINT8)(SHORT(oldpatch->height)-column->length-column->topdelta); //flippy

  000a2	8b 45 dc	 mov	 eax, DWORD PTR _oldpatch$1[ebp]
  000a5	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _column$[ebp]
  000ac	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  000b0	2b c8		 sub	 ecx, eax
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _column$[ebp]
  000b5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000b8	2b c8		 sub	 ecx, eax
  000ba	8b 55 e0	 mov	 edx, DWORD PTR _destcol$2[ebp]
  000bd	88 0a		 mov	 BYTE PTR [edx], cl

; 671  : 
; 672  : 				source = (UINT8 *)column + 3;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  000c2	83 c0 03	 add	 eax, 3
  000c5	89 45 e8	 mov	 DWORD PTR _source$4[ebp], eax

; 673  : 				dest = (UINT8 *)destcol + 3;

  000c8	8b 45 e0	 mov	 eax, DWORD PTR _destcol$2[ebp]
  000cb	83 c0 03	 add	 eax, 3
  000ce	89 45 e4	 mov	 DWORD PTR _dest$3[ebp], eax

; 674  : 				count = column->length;

  000d1	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  000d4	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000d8	89 4d ec	 mov	 DWORD PTR _count$5[ebp], ecx
$LN7@R_DrawVisS:

; 675  : 
; 676  : 				while (count--)

  000db	8b 45 ec	 mov	 eax, DWORD PTR _count$5[ebp]
  000de	89 45 98	 mov	 DWORD PTR tv139[ebp], eax
  000e1	8b 4d ec	 mov	 ecx, DWORD PTR _count$5[ebp]
  000e4	83 e9 01	 sub	 ecx, 1
  000e7	89 4d ec	 mov	 DWORD PTR _count$5[ebp], ecx
  000ea	83 7d 98 00	 cmp	 DWORD PTR tv139[ebp], 0
  000ee	74 0b		 je	 SHORT $LN8@R_DrawVisS

; 677  : 					source++;

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _source$4[ebp]
  000f3	83 c0 01	 add	 eax, 1
  000f6	89 45 e8	 mov	 DWORD PTR _source$4[ebp], eax
  000f9	eb e0		 jmp	 SHORT $LN7@R_DrawVisS
$LN8@R_DrawVisS:

; 678  : 
; 679  : 				for (; count < column->length; count++)

  000fb	eb 09		 jmp	 SHORT $LN11@R_DrawVisS
$LN9@R_DrawVisS:
  000fd	8b 45 ec	 mov	 eax, DWORD PTR _count$5[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 45 ec	 mov	 DWORD PTR _count$5[ebp], eax
$LN11@R_DrawVisS:
  00106	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  00109	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0010d	39 4d ec	 cmp	 DWORD PTR _count$5[ebp], ecx
  00110	7d 1e		 jge	 SHORT $LN10@R_DrawVisS

; 680  : 				{
; 681  : 					source--;

  00112	8b 45 e8	 mov	 eax, DWORD PTR _source$4[ebp]
  00115	83 e8 01	 sub	 eax, 1
  00118	89 45 e8	 mov	 DWORD PTR _source$4[ebp], eax

; 682  : 					*dest++ = *source;

  0011b	8b 45 e4	 mov	 eax, DWORD PTR _dest$3[ebp]
  0011e	8b 4d e8	 mov	 ecx, DWORD PTR _source$4[ebp]
  00121	8a 11		 mov	 dl, BYTE PTR [ecx]
  00123	88 10		 mov	 BYTE PTR [eax], dl
  00125	8b 45 e4	 mov	 eax, DWORD PTR _dest$3[ebp]
  00128	83 c0 01	 add	 eax, 1
  0012b	89 45 e4	 mov	 DWORD PTR _dest$3[ebp], eax

; 683  : 				}

  0012e	eb cd		 jmp	 SHORT $LN9@R_DrawVisS
$LN10@R_DrawVisS:

; 684  : 
; 685  : 				column = (column_t *)((UINT8 *)column + column->length + 4);

  00130	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  00133	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00137	8b 55 fc	 mov	 edx, DWORD PTR _column$[ebp]
  0013a	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0013e	89 45 fc	 mov	 DWORD PTR _column$[ebp], eax

; 686  : 				destcol = (column_t *)((UINT8 *)destcol + destcol->length + 4);

  00141	8b 45 e0	 mov	 eax, DWORD PTR _destcol$2[ebp]
  00144	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00148	8b 55 e0	 mov	 edx, DWORD PTR _destcol$2[ebp]
  0014b	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0014f	89 45 e0	 mov	 DWORD PTR _destcol$2[ebp], eax

; 687  : 			}

  00152	e9 39 ff ff ff	 jmp	 $LN5@R_DrawVisS
$LN6@R_DrawVisS:

; 688  : 		}

  00157	e9 fc fe ff ff	 jmp	 $LN2@R_DrawVisS
$LN3@R_DrawVisS:

; 689  : 
; 690  : 		// Only free oldpatch if it wasn't cached before!
; 691  : 		// Otherwise we may later attempt to draw patches that don't exist!
; 692  : 		if (!(W_IsLumpCached(vis->patch, oldpatch)))

  0015c	8b 45 dc	 mov	 eax, DWORD PTR _oldpatch$1[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00163	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 _W_IsLumpCached
  0016c	83 c4 08	 add	 esp, 8
  0016f	85 c0		 test	 eax, eax
  00171	75 0c		 jne	 SHORT $LN19@R_DrawVisS

; 693  : 			Z_Free(oldpatch);

  00173	8b 45 dc	 mov	 eax, DWORD PTR _oldpatch$1[ebp]
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _Z_Free
  0017c	83 c4 04	 add	 esp, 4
$LN19@R_DrawVisS:

; 694  : 	}

  0017f	eb 1f		 jmp	 SHORT $LN20@R_DrawVisS
$LN15@R_DrawVisS:

; 695  : 	else
; 696  : 	{
; 697  : 		patch = W_CacheLumpNum(vis->patch, PU_CACHE);

  00181	6a 65		 push	 101			; 00000065H
  00183	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00186	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 _W_CacheLumpNum
  0018f	83 c4 08	 add	 esp, 8
  00192	89 45 f4	 mov	 DWORD PTR _patch$[ebp], eax

; 698  : 
; 699  : 		if (!patch)

  00195	83 7d f4 00	 cmp	 DWORD PTR _patch$[ebp], 0
  00199	75 05		 jne	 SHORT $LN20@R_DrawVisS

; 700  : 			return;

  0019b	e9 d9 04 00 00	 jmp	 $LN48@R_DrawVisS
$LN20@R_DrawVisS:

; 701  : 	}
; 702  : 
; 703  : 	colfunc = basecolfunc; // hack: this isn't resetting properly somewhere.

  001a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _basecolfunc
  001a5	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax

; 704  : 	dc_colormap = vis->colormap;

  001aa	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  001ad	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001b0	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_colormap, ecx

; 705  : 	if ((vis->mobjflags & MF_TRANSLATION) && vis->transmap) // Color mapping

  001b6	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  001b9	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  001bc	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  001c2	74 43		 je	 SHORT $LN21@R_DrawVisS
  001c4	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  001c7	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  001cb	74 3a		 je	 SHORT $LN21@R_DrawVisS

; 706  : 	{
; 707  : 		colfunc = transtransfunc;

  001cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _transtransfunc
  001d2	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax

; 708  : 		dc_transmap = vis->transmap;

  001d7	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  001da	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  001dd	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_transmap, ecx

; 709  : 		dc_translation = defaulttranslationtables - 256 + ((INT32)vis->mobj->color<<8);

  001e3	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  001e6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001e9	0f b6 51 68	 movzx	 edx, BYTE PTR [ecx+104]
  001ed	c1 e2 08	 shl	 edx, 8
  001f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  001f5	8d 8c 10 00 ff
	ff ff		 lea	 ecx, DWORD PTR [eax+edx-256]
  001fc	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_translation, ecx

; 710  : 	}

  00202	e9 dc 00 00 00	 jmp	 $LN29@R_DrawVisS
$LN21@R_DrawVisS:

; 711  : 	else if (vis->transmap)

  00207	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0020a	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0020e	74 1b		 je	 SHORT $LN23@R_DrawVisS

; 712  : 	{
; 713  : 		colfunc = fuzzcolfunc;

  00210	a1 00 00 00 00	 mov	 eax, DWORD PTR _fuzzcolfunc
  00215	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax

; 714  : 		dc_transmap = vis->transmap;    //Fab : 29-04-98: translucency table

  0021a	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0021d	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00220	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_transmap, ecx

; 715  : 	}

  00226	e9 b8 00 00 00	 jmp	 $LN29@R_DrawVisS
$LN23@R_DrawVisS:

; 716  : 	else if (vis->mobjflags & MF_TRANSLATION)

  0022b	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0022e	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00231	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  00237	0f 84 a6 00 00
	00		 je	 $LN29@R_DrawVisS

; 717  : 	{
; 718  : 		// translate green skin to another color
; 719  : 		colfunc = transcolfunc;

  0023d	a1 00 00 00 00	 mov	 eax, DWORD PTR _transcolfunc
  00242	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax

; 720  : 
; 721  : 		// New colormap stuff for skins Tails 06-07-2002
; 722  : #ifdef TRANSFIX
; 723  : 		if (vis->mobj->skin) // This thing is a player!

  00247	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0024a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024d	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  00251	74 39		 je	 SHORT $LN26@R_DrawVisS

; 724  : 			dc_translation = translationtables[(skin_t*)vis->mobj->skin-skins] - 256 +

  00253	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00256	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00259	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  0025c	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  00261	99		 cdq
  00262	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  00267	f7 f9		 idiv	 ecx
  00269	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _translationtables[eax*4]
  00270	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00273	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00276	0f b6 41 68	 movzx	 eax, BYTE PTR [ecx+104]
  0027a	c1 e0 08	 shl	 eax, 8
  0027d	8d 8c 02 00 ff
	ff ff		 lea	 ecx, DWORD PTR [edx+eax-256]
  00284	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_translation, ecx
  0028a	eb 57		 jmp	 SHORT $LN29@R_DrawVisS
$LN26@R_DrawVisS:

; 725  : 				((INT32)vis->mobj->color<<8);
; 726  : #else
; 727  : 		if (vis->mobj->player) // This thing is a player!
; 728  : 		{
; 729  : 			if (vis->mobj->player->skincolor)
; 730  : 				dc_translation = translationtables[vis->mobj->player->skin] - 256 + ((INT32)vis->mobj->color<<8);
; 731  : 			else
; 732  : 			{
; 733  : 				static INT32 firsttime = 1;
; 734  : 				colfunc = basecolfunc; // Graue 04-08-2004
; 735  : 				if (firsttime)
; 736  : 				{
; 737  : 					CONS_Printf("Abandoning!\n");
; 738  : 					firsttime = 0;
; 739  : 				}
; 740  : 			}
; 741  : 		}
; 742  : #endif
; 743  : 		else if ((vis->mobj->flags & MF_BOSS) && (vis->mobj->flags2 & MF2_FRET) && (leveltime & 1)) // Bosses "flash"

  0028c	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0028f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00292	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00295	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0029b	74 27		 je	 SHORT $LN28@R_DrawVisS
  0029d	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  002a0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002a3	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  002a9	83 e2 10	 and	 edx, 16			; 00000010H
  002ac	74 16		 je	 SHORT $LN28@R_DrawVisS
  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  002b3	83 e0 01	 and	 eax, 1
  002b6	74 0c		 je	 SHORT $LN28@R_DrawVisS

; 744  : 		{
; 745  : 			dc_translation = bosstranslationtables;

  002b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _bosstranslationtables
  002bd	a3 00 00 00 00	 mov	 DWORD PTR _dc_translation, eax

; 746  : 		}

  002c2	eb 1f		 jmp	 SHORT $LN29@R_DrawVisS
$LN28@R_DrawVisS:

; 747  : 		else // Use the defaults
; 748  : 			dc_translation = defaulttranslationtables - 256 + ((INT32)vis->mobj->color<<8);

  002c4	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  002c7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ca	0f b6 51 68	 movzx	 edx, BYTE PTR [ecx+104]
  002ce	c1 e2 08	 shl	 edx, 8
  002d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaulttranslationtables
  002d6	8d 8c 10 00 ff
	ff ff		 lea	 ecx, DWORD PTR [eax+edx-256]
  002dd	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_translation, ecx
$LN29@R_DrawVisS:

; 749  : 	}
; 750  : 
; 751  : 	if (vis->extra_colormap)

  002e3	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  002e6	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  002ea	74 36		 je	 SHORT $LN32@R_DrawVisS

; 752  : 	{
; 753  : 		if (!dc_colormap)

  002ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dc_colormap, 0
  002f3	75 11		 jne	 SHORT $LN31@R_DrawVisS

; 754  : 			dc_colormap = vis->extra_colormap->colormap;

  002f5	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  002f8	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  002fb	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  002fe	89 15 00 00 00
	00		 mov	 DWORD PTR _dc_colormap, edx
  00304	eb 1c		 jmp	 SHORT $LN32@R_DrawVisS
$LN31@R_DrawVisS:

; 755  : 		else
; 756  : 			dc_colormap = &vis->extra_colormap->colormap[dc_colormap - colormaps];

  00306	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00309	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0030c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _dc_colormap
  00312	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _colormaps
  00318	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0031b	03 c2		 add	 eax, edx
  0031d	a3 00 00 00 00	 mov	 DWORD PTR _dc_colormap, eax
$LN32@R_DrawVisS:

; 757  : 	}
; 758  : 	if (!dc_colormap)

  00322	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dc_colormap, 0
  00329	75 0a		 jne	 SHORT $LN33@R_DrawVisS

; 759  : 		dc_colormap = colormaps;

  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR _colormaps
  00330	a3 00 00 00 00	 mov	 DWORD PTR _dc_colormap, eax
$LN33@R_DrawVisS:

; 760  : 
; 761  : 	dc_iscale = FixedDiv(FRACUNIT, vis->scale);

  00335	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00338	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0033b	51		 push	 ecx
  0033c	68 00 00 01 00	 push	 65536			; 00010000H
  00341	e8 00 00 00 00	 call	 _FixedDiv
  00346	83 c4 08	 add	 esp, 8
  00349	a3 00 00 00 00	 mov	 DWORD PTR _dc_iscale, eax

; 762  : 	dc_texturemid = vis->texturemid;

  0034e	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00351	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00354	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_texturemid, ecx

; 763  : 	dc_texheight = 0;

  0035a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dc_texheight, 0

; 764  : 
; 765  : 	frac = vis->startfrac;

  00364	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00367	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0036a	89 4d f8	 mov	 DWORD PTR _frac$[ebp], ecx

; 766  : 	spryscale = vis->scale;

  0036d	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00370	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00373	89 0d 00 00 00
	00		 mov	 DWORD PTR _spryscale, ecx

; 767  : 	sprtopscreen = centeryfrac - FixedMul(dc_texturemid, spryscale);

  00379	a1 00 00 00 00	 mov	 eax, DWORD PTR _spryscale
  0037e	50		 push	 eax
  0037f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_texturemid
  00385	51		 push	 ecx
  00386	e8 00 00 00 00	 call	 _FixedMul
  0038b	83 c4 08	 add	 esp, 8
  0038e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _centeryfrac
  00394	2b d0		 sub	 edx, eax
  00396	89 15 00 00 00
	00		 mov	 DWORD PTR _sprtopscreen, edx

; 768  : 	windowtop = windowbottom = sprbotscreen = INT32_MAX;

  0039c	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR _sprbotscreen, 2147483647 ; 7fffffffH
  003a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _sprbotscreen
  003ab	a3 00 00 00 00	 mov	 DWORD PTR _windowbottom, eax
  003b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _windowbottom
  003b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _windowtop, ecx

; 769  : 	if (vis->mobjflags & MF_HIRES)

  003bc	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  003bf	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  003c2	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  003c8	74 40		 je	 SHORT $LN34@R_DrawVisS

; 770  : 	{
; 771  : 		spryscale >>= 1;

  003ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _spryscale
  003cf	d1 f8		 sar	 eax, 1
  003d1	a3 00 00 00 00	 mov	 DWORD PTR _spryscale, eax

; 772  : 		vis->scale >>= 1;

  003d6	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  003d9	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  003dc	d1 f9		 sar	 ecx, 1
  003de	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  003e1	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 773  : 		dc_iscale <<= 1;

  003e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  003e9	d1 e0		 shl	 eax, 1
  003eb	a3 00 00 00 00	 mov	 DWORD PTR _dc_iscale, eax

; 774  : 		vis->xiscale <<= 1;

  003f0	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  003f3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003f6	d1 e1		 shl	 ecx, 1
  003f8	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  003fb	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 775  : 		dc_hires = 1;

  003fe	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _dc_hires, 1

; 776  : 	}

  00405	e9 82 01 00 00	 jmp	 $LN41@R_DrawVisS
$LN34@R_DrawVisS:

; 777  : 	else if (vis->mobj->scale >= 400)

  0040a	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0040d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00410	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  00417	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  0041d	0f 8c 89 00 00
	00		 jl	 $LN36@R_DrawVisS

; 778  : 	{ // Scale > 400%? Software can't handle that! Render it as 400% instead.
; 779  : 		spryscale *= 4;

  00423	a1 00 00 00 00	 mov	 eax, DWORD PTR _spryscale
  00428	c1 e0 02	 shl	 eax, 2
  0042b	a3 00 00 00 00	 mov	 DWORD PTR _spryscale, eax

; 780  : 		vis->scale *= 4;

  00430	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00433	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00436	c1 e1 02	 shl	 ecx, 2
  00439	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  0043c	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 781  : 		dc_iscale /= 4;

  0043f	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00444	99		 cdq
  00445	83 e2 03	 and	 edx, 3
  00448	03 c2		 add	 eax, edx
  0044a	c1 f8 02	 sar	 eax, 2
  0044d	a3 00 00 00 00	 mov	 DWORD PTR _dc_iscale, eax

; 782  : 		vis->xiscale /= 4;

  00452	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00455	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00458	99		 cdq
  00459	83 e2 03	 and	 edx, 3
  0045c	03 c2		 add	 eax, edx
  0045e	c1 f8 02	 sar	 eax, 2
  00461	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00464	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 783  : 
; 784  : 		//Oh lordy.  (Fixing scaled sprites messing up if only partway on screen)
; 785  : 		if (vis->xiscale > 0)

  00467	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0046a	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0046e	7e 11		 jle	 SHORT $LN38@R_DrawVisS

; 786  : 			frac /= 4;

  00470	8b 45 f8	 mov	 eax, DWORD PTR _frac$[ebp]
  00473	99		 cdq
  00474	83 e2 03	 and	 edx, 3
  00477	03 c2		 add	 eax, edx
  00479	c1 f8 02	 sar	 eax, 2
  0047c	89 45 f8	 mov	 DWORD PTR _frac$[ebp], eax
  0047f	eb 1f		 jmp	 SHORT $LN40@R_DrawVisS
$LN38@R_DrawVisS:

; 787  : 		else if (vis->x1 <= 0)

  00481	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00484	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00488	7f 16		 jg	 SHORT $LN40@R_DrawVisS

; 788  : 			frac = (vis->x1 - vis->x2) * vis->xiscale;

  0048a	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0048d	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00490	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00493	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00496	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00499	0f af 50 34	 imul	 edx, DWORD PTR [eax+52]
  0049d	89 55 f8	 mov	 DWORD PTR _frac$[ebp], edx
$LN40@R_DrawVisS:

; 789  : 
; 790  : 		dc_hires = 1;

  004a0	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _dc_hires, 1

; 791  : 	}

  004a7	e9 e0 00 00 00	 jmp	 $LN41@R_DrawVisS
$LN36@R_DrawVisS:

; 792  : 	else if (vis->mobj->scale != 100)

  004ac	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  004af	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004b2	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  004b9	83 fa 64	 cmp	 edx, 100		; 00000064H
  004bc	0f 84 ca 00 00
	00		 je	 $LN41@R_DrawVisS

; 793  : 	{
; 794  : 		spryscale = spryscale*vis->mobj->scale/100;

  004c2	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  004c5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004c8	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  004cf	8b c2		 mov	 eax, edx
  004d1	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _spryscale
  004d8	99		 cdq
  004d9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  004de	f7 f9		 idiv	 ecx
  004e0	a3 00 00 00 00	 mov	 DWORD PTR _spryscale, eax

; 795  : 		vis->scale = vis->scale*vis->mobj->scale/100;

  004e5	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  004e8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004eb	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  004f2	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  004f5	8b ca		 mov	 ecx, edx
  004f7	0f af 48 30	 imul	 ecx, DWORD PTR [eax+48]
  004fb	8b c1		 mov	 eax, ecx
  004fd	99		 cdq
  004fe	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00503	f7 f9		 idiv	 ecx
  00505	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  00508	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 796  : 		dc_iscale = dc_iscale*100/vis->mobj->scale;

  0050b	6b 05 00 00 00
	00 64		 imul	 eax, DWORD PTR _dc_iscale, 100
  00512	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00515	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00518	0f b7 8a cc 00
	00 00		 movzx	 ecx, WORD PTR [edx+204]
  0051f	99		 cdq
  00520	f7 f9		 idiv	 ecx
  00522	a3 00 00 00 00	 mov	 DWORD PTR _dc_iscale, eax

; 797  : 		vis->xiscale = vis->xiscale*100/vis->mobj->scale;

  00527	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0052a	6b 40 34 64	 imul	 eax, DWORD PTR [eax+52], 100
  0052e	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00531	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00534	0f b7 8a cc 00
	00 00		 movzx	 ecx, WORD PTR [edx+204]
  0053b	99		 cdq
  0053c	f7 f9		 idiv	 ecx
  0053e	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  00541	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 798  : 
; 799  : 		//Oh lordy, again.  See above.
; 800  : 		if (vis->xiscale > 0)

  00544	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00547	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0054b	7e 19		 jle	 SHORT $LN42@R_DrawVisS

; 801  : 			frac = frac*100/vis->mobj->scale;

  0054d	6b 45 f8 64	 imul	 eax, DWORD PTR _frac$[ebp], 100
  00551	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00554	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00557	0f b7 8a cc 00
	00 00		 movzx	 ecx, WORD PTR [edx+204]
  0055e	99		 cdq
  0055f	f7 f9		 idiv	 ecx
  00561	89 45 f8	 mov	 DWORD PTR _frac$[ebp], eax
  00564	eb 1f		 jmp	 SHORT $LN44@R_DrawVisS
$LN42@R_DrawVisS:

; 802  : 		else if (vis->x1 <= 0)

  00566	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00569	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0056d	7f 16		 jg	 SHORT $LN44@R_DrawVisS

; 803  : 			frac = (vis->x1 - vis->x2) * vis->xiscale;

  0056f	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00572	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  00575	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00578	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  0057b	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0057e	0f af 50 34	 imul	 edx, DWORD PTR [eax+52]
  00582	89 55 f8	 mov	 DWORD PTR _frac$[ebp], edx
$LN44@R_DrawVisS:

; 804  : 
; 805  : 		dc_hires = 1;

  00585	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _dc_hires, 1
$LN41@R_DrawVisS:

; 806  : 	}
; 807  : 
; 808  : 	if (vis->x1 < 0)

  0058c	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0058f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00593	7d 0a		 jge	 SHORT $LN45@R_DrawVisS

; 809  : 		vis->x1 = 0;

  00595	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00598	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN45@R_DrawVisS:

; 810  : 
; 811  : 	if (vis->x2 >= vid.width)

  0059f	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  005a2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  005a5	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR _vid+12
  005ab	7c 0e		 jl	 SHORT $LN46@R_DrawVisS

; 812  : 		vis->x2 = vid.width-1;

  005ad	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  005b2	83 e8 01	 sub	 eax, 1
  005b5	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  005b8	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN46@R_DrawVisS:

; 813  : 
; 814  : 	for (dc_x = vis->x1; dc_x <= vis->x2; dc_x++, frac += vis->xiscale)

  005bb	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  005be	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  005c1	89 0d 00 00 00
	00		 mov	 DWORD PTR _dc_x, ecx
  005c7	eb 19		 jmp	 SHORT $LN14@R_DrawVisS
$LN12@R_DrawVisS:
  005c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  005ce	83 c0 01	 add	 eax, 1
  005d1	a3 00 00 00 00	 mov	 DWORD PTR _dc_x, eax
  005d6	8b 4d 08	 mov	 ecx, DWORD PTR _vis$[ebp]
  005d9	8b 55 f8	 mov	 edx, DWORD PTR _frac$[ebp]
  005dc	03 51 34	 add	 edx, DWORD PTR [ecx+52]
  005df	89 55 f8	 mov	 DWORD PTR _frac$[ebp], edx
$LN14@R_DrawVisS:
  005e2	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  005e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dc_x
  005eb	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  005ee	7f 21		 jg	 SHORT $LN13@R_DrawVisS

; 815  : 	{
; 816  : #ifdef RANGECHECK
; 817  : 		texturecolumn = frac>>FRACBITS;
; 818  : 
; 819  : 		if (texturecolumn < 0 || texturecolumn >= SHORT(patch->width))
; 820  : 			I_Error("R_DrawSpriteRange: bad texturecolumn");
; 821  : 		column = (column_t *)((UINT8 *)patch + LONG(patch->columnofs[texturecolumn]));
; 822  : #else
; 823  : 		column = (column_t *)((UINT8 *)patch + LONG(patch->columnofs[frac>>FRACBITS]));

  005f0	8b 45 f8	 mov	 eax, DWORD PTR _frac$[ebp]
  005f3	c1 f8 10	 sar	 eax, 16			; 00000010H
  005f6	8b 4d f4	 mov	 ecx, DWORD PTR _patch$[ebp]
  005f9	8b 55 f4	 mov	 edx, DWORD PTR _patch$[ebp]
  005fc	03 54 81 08	 add	 edx, DWORD PTR [ecx+eax*4+8]
  00600	89 55 fc	 mov	 DWORD PTR _column$[ebp], edx

; 824  : #endif
; 825  : 		R_DrawMaskedColumn(column);

  00603	8b 45 fc	 mov	 eax, DWORD PTR _column$[ebp]
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 _R_DrawMaskedColumn
  0060c	83 c4 04	 add	 esp, 4

; 826  : 	}

  0060f	eb b8		 jmp	 SHORT $LN12@R_DrawVisS
$LN13@R_DrawVisS:

; 827  : 
; 828  : 	colfunc = basecolfunc;

  00611	a1 00 00 00 00	 mov	 eax, DWORD PTR _basecolfunc
  00616	a3 00 00 00 00	 mov	 DWORD PTR _colfunc, eax

; 829  : 	if (vis->mobjflags & MF_HIRES)

  0061b	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  0061e	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00621	81 e1 00 00 08
	00		 and	 ecx, 524288		; 00080000H
  00627	74 34		 je	 SHORT $LN47@R_DrawVisS

; 830  : 	{
; 831  : 		spryscale <<= 1;

  00629	a1 00 00 00 00	 mov	 eax, DWORD PTR _spryscale
  0062e	d1 e0		 shl	 eax, 1
  00630	a3 00 00 00 00	 mov	 DWORD PTR _spryscale, eax

; 832  : 		vis->scale <<= 1;

  00635	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00638	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0063b	d1 e1		 shl	 ecx, 1
  0063d	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  00640	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 833  : 		dc_iscale >>= 1;

  00643	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_iscale
  00648	d1 f8		 sar	 eax, 1
  0064a	a3 00 00 00 00	 mov	 DWORD PTR _dc_iscale, eax

; 834  : 		vis->xiscale >>= 1;

  0064f	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00652	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00655	d1 f9		 sar	 ecx, 1
  00657	8b 55 08	 mov	 edx, DWORD PTR _vis$[ebp]
  0065a	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
$LN47@R_DrawVisS:

; 835  : 	}
; 836  : 	dc_hires = 0;

  0065d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _dc_hires, 0

; 837  : 
; 838  : 	if (vis->vflip)

  00664	8b 45 08	 mov	 eax, DWORD PTR _vis$[ebp]
  00667	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  0066b	74 0c		 je	 SHORT $LN48@R_DrawVisS

; 839  : 		Z_Free(patch);

  0066d	8b 45 f4	 mov	 eax, DWORD PTR _patch$[ebp]
  00670	50		 push	 eax
  00671	e8 00 00 00 00	 call	 _Z_Free
  00676	83 c4 04	 add	 esp, 4
$LN48@R_DrawVisS:

; 840  : }

  00679	5f		 pop	 edi
  0067a	5e		 pop	 esi
  0067b	5b		 pop	 ebx
  0067c	8b e5		 mov	 esp, ebp
  0067e	5d		 pop	 ebp
  0067f	c3		 ret	 0
_R_DrawVisSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_NewVisSprite
_TEXT	SEGMENT
_R_NewVisSprite PROC					; COMDAT

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 549  : 	if (vissprite_p == &vissprites[MAXVISSPRITES])

  00009	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0000e	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00011	05 00 00 00 00	 add	 eax, OFFSET _vissprites
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR _vissprite_p, eax
  0001c	75 07		 jne	 SHORT $LN2@R_NewVisSp

; 550  : 		return &overflowsprite;

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET _overflowsprite
  00023	eb 15		 jmp	 SHORT $LN1@R_NewVisSp
$LN2@R_NewVisSp:

; 551  : 
; 552  : 	vissprite_p++;

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _vissprite_p
  0002a	83 c0 70	 add	 eax, 112		; 00000070H
  0002d	a3 00 00 00 00	 mov	 DWORD PTR _vissprite_p, eax

; 553  : 	return vissprite_p-1;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _vissprite_p
  00037	83 e8 70	 sub	 eax, 112		; 00000070H
$LN1@R_NewVisSp:

; 554  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_R_NewVisSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DelSingleSpriteDef
_TEXT	SEGMENT
_lumpinfo$ = -12					; size = 4
_rotation$ = -6						; size = 1
_frame$ = -5						; size = 1
_l$ = -4						; size = 2
_sprname$ = 8						; size = 4
_spritedef$ = 12					; size = 4
_wadnum$ = 16						; size = 2
_startlump$ = 20					; size = 2
_endlump$ = 24						; size = 2
_R_DelSingleSpriteDef PROC				; COMDAT

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 330  : 	UINT16 l;
; 331  : 	UINT8 frame;
; 332  : 	UINT8 rotation;
; 333  : 	lumpinfo_t *lumpinfo;
; 334  : 
; 335  : 	maxframe = (size_t)-1;

  00009	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _maxframe, -1

; 336  : 
; 337  : 	// scan the lumps,
; 338  : 	//  filling in the frames for whatever is found
; 339  : 	lumpinfo = wadfiles[wadnum]->lumpinfo;

  00013	0f b7 45 10	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00017	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	89 55 f4	 mov	 DWORD PTR _lumpinfo$[ebp], edx

; 340  : 	if (endlump > wadfiles[wadnum]->numlumps)

  00024	0f b7 45 18	 movzx	 eax, WORD PTR _endlump$[ebp]
  00028	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  0002c	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _wadfiles[ecx*4]
  00033	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  00037	3b c1		 cmp	 eax, ecx
  00039	7e 13		 jle	 SHORT $LN5@R_DelSingl

; 341  : 		endlump = wadfiles[wadnum]->numlumps;

  0003b	0f b7 45 10	 movzx	 eax, WORD PTR _wadnum$[ebp]
  0003f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00046	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  0004a	66 89 55 18	 mov	 WORD PTR _endlump$[ebp], dx
$LN5@R_DelSingl:

; 342  : 
; 343  : 	for (l = startlump; l < endlump; l++)

  0004e	66 8b 45 14	 mov	 ax, WORD PTR _startlump$[ebp]
  00052	66 89 45 fc	 mov	 WORD PTR _l$[ebp], ax
  00056	eb 0c		 jmp	 SHORT $LN4@R_DelSingl
$LN2@R_DelSingl:
  00058	66 8b 45 fc	 mov	 ax, WORD PTR _l$[ebp]
  0005c	66 83 c0 01	 add	 ax, 1
  00060	66 89 45 fc	 mov	 WORD PTR _l$[ebp], ax
$LN4@R_DelSingl:
  00064	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  00068	0f b7 4d 18	 movzx	 ecx, WORD PTR _endlump$[ebp]
  0006c	3b c1		 cmp	 eax, ecx
  0006e	0f 8d 1f 01 00
	00		 jge	 $LN3@R_DelSingl

; 344  : 	{
; 345  : 		if (memcmp(lumpinfo[l].name,sprname,4)==0)

  00074	6a 04		 push	 4
  00076	8b 45 08	 mov	 eax, DWORD PTR _sprname$[ebp]
  00079	50		 push	 eax
  0007a	0f b7 4d fc	 movzx	 ecx, WORD PTR _l$[ebp]
  0007e	6b d1 1c	 imul	 edx, ecx, 28
  00081	8b 45 f4	 mov	 eax, DWORD PTR _lumpinfo$[ebp]
  00084	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _memcmp
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	85 c0		 test	 eax, eax
  00093	0f 85 f5 00 00
	00		 jne	 $LN8@R_DelSingl

; 346  : 		{
; 347  : 			frame = (UINT8)(lumpinfo[l].name[4] - 'A');

  00099	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  0009d	6b c8 1c	 imul	 ecx, eax, 28
  000a0	03 4d f4	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  000a3	ba 01 00 00 00	 mov	 edx, 1
  000a8	c1 e2 02	 shl	 edx, 2
  000ab	0f be 44 11 08	 movsx	 eax, BYTE PTR [ecx+edx+8]
  000b0	83 e8 41	 sub	 eax, 65			; 00000041H
  000b3	88 45 fb	 mov	 BYTE PTR _frame$[ebp], al

; 348  : 			rotation = (UINT8)(lumpinfo[l].name[5] - '0');

  000b6	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  000ba	6b c8 1c	 imul	 ecx, eax, 28
  000bd	03 4d f4	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  000c0	ba 01 00 00 00	 mov	 edx, 1
  000c5	6b c2 05	 imul	 eax, edx, 5
  000c8	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  000cd	83 e9 30	 sub	 ecx, 48			; 00000030H
  000d0	88 4d fa	 mov	 BYTE PTR _rotation$[ebp], cl

; 349  : 
; 350  : 			// skip NULL sprites from very old dmadds pwads
; 351  : 			if (W_LumpLengthPwad(wadnum,l)<=8)

  000d3	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  000d7	50		 push	 eax
  000d8	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _W_LumpLengthPwad
  000e2	83 c4 08	 add	 esp, 8
  000e5	83 f8 08	 cmp	 eax, 8
  000e8	77 05		 ja	 SHORT $LN7@R_DelSingl

; 352  : 				continue;

  000ea	e9 69 ff ff ff	 jmp	 $LN2@R_DelSingl
$LN7@R_DelSingl:

; 353  : 
; 354  : 			//----------------------------------------------------
; 355  : 
; 356  : 			R_RemoveSpriteLump(wadnum, l, numspritelumps, frame, rotation, 0);

  000ef	6a 00		 push	 0
  000f1	0f b6 45 fa	 movzx	 eax, BYTE PTR _rotation$[ebp]
  000f5	50		 push	 eax
  000f6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _frame$[ebp]
  000fa	51		 push	 ecx
  000fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numspritelumps
  00101	52		 push	 edx
  00102	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  00106	50		 push	 eax
  00107	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 _R_RemoveSpriteLump
  00111	83 c4 18	 add	 esp, 24			; 00000018H

; 357  : 
; 358  : 			if (lumpinfo[l].name[6])

  00114	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  00118	6b c8 1c	 imul	 ecx, eax, 28
  0011b	03 4d f4	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  0011e	ba 01 00 00 00	 mov	 edx, 1
  00123	6b c2 06	 imul	 eax, edx, 6
  00126	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  0012b	85 c9		 test	 ecx, ecx
  0012d	74 5f		 je	 SHORT $LN8@R_DelSingl

; 359  : 			{
; 360  : 				frame = (UINT8)(lumpinfo[l].name[6] - 'A');

  0012f	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  00133	6b c8 1c	 imul	 ecx, eax, 28
  00136	03 4d f4	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  00139	ba 01 00 00 00	 mov	 edx, 1
  0013e	6b c2 06	 imul	 eax, edx, 6
  00141	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  00146	83 e9 41	 sub	 ecx, 65			; 00000041H
  00149	88 4d fb	 mov	 BYTE PTR _frame$[ebp], cl

; 361  : 				rotation = (UINT8)(lumpinfo[l].name[7] - '0');

  0014c	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  00150	6b c8 1c	 imul	 ecx, eax, 28
  00153	03 4d f4	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  00156	ba 01 00 00 00	 mov	 edx, 1
  0015b	6b c2 07	 imul	 eax, edx, 7
  0015e	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  00163	83 e9 30	 sub	 ecx, 48			; 00000030H
  00166	88 4d fa	 mov	 BYTE PTR _rotation$[ebp], cl

; 362  : 				R_RemoveSpriteLump(wadnum, l, numspritelumps, frame, rotation, 1);

  00169	6a 01		 push	 1
  0016b	0f b6 45 fa	 movzx	 eax, BYTE PTR _rotation$[ebp]
  0016f	50		 push	 eax
  00170	0f b6 4d fb	 movzx	 ecx, BYTE PTR _frame$[ebp]
  00174	51		 push	 ecx
  00175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numspritelumps
  0017b	52		 push	 edx
  0017c	0f b7 45 fc	 movzx	 eax, WORD PTR _l$[ebp]
  00180	50		 push	 eax
  00181	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00185	51		 push	 ecx
  00186	e8 00 00 00 00	 call	 _R_RemoveSpriteLump
  0018b	83 c4 18	 add	 esp, 24			; 00000018H
$LN8@R_DelSingl:

; 363  : 			}
; 364  : 		}
; 365  : 	}

  0018e	e9 c5 fe ff ff	 jmp	 $LN2@R_DelSingl
$LN3@R_DelSingl:

; 366  : 
; 367  : 	if (maxframe == (size_t)-1)

  00193	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _maxframe, -1
  0019a	75 04		 jne	 SHORT $LN9@R_DelSingl

; 368  : 		return false;

  0019c	33 c0		 xor	 eax, eax
  0019e	eb 27		 jmp	 SHORT $LN1@R_DelSingl
$LN9@R_DelSingl:

; 369  : 
; 370  : 	spritedef->numframes = 0;

  001a0	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  001a3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 371  : 	Z_Free(spritedef->spriteframes);

  001a9	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  001ac	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001af	51		 push	 ecx
  001b0	e8 00 00 00 00	 call	 _Z_Free
  001b5	83 c4 04	 add	 esp, 4

; 372  : 	spritedef->spriteframes = NULL;

  001b8	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  001bb	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 373  : 	return true;

  001c2	b8 01 00 00 00	 mov	 eax, 1
$LN1@R_DelSingl:

; 374  : }

  001c7	5f		 pop	 edi
  001c8	5e		 pop	 esi
  001c9	5b		 pop	 ebx
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
_R_DelSingleSpriteDef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_AddSingleSpriteDef
_TEXT	SEGMENT
tv210 = -124						; size = 4
tv263 = -124						; size = 4
_patch$ = -56						; size = 40
_lumpinfo$ = -16					; size = 4
_rotation$ = -10					; size = 1
_frame$ = -9						; size = 1
_l$ = -8						; size = 2
__$ArrayPad$ = -4					; size = 4
_sprname$ = 8						; size = 4
_spritedef$ = 12					; size = 4
_wadnum$ = 16						; size = 2
_startlump$ = 20					; size = 2
_endlump$ = 24						; size = 2
_R_AddSingleSpriteDef PROC				; COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 183  : 	UINT16 l;
; 184  : 	UINT8 frame;
; 185  : 	UINT8 rotation;
; 186  : 	lumpinfo_t *lumpinfo;
; 187  : 	patch_t patch;
; 188  : 
; 189  : 	memset(sprtemp,0xFF, sizeof (sprtemp));

  00013	68 00 13 00 00	 push	 4864			; 00001300H
  00018	68 ff 00 00 00	 push	 255			; 000000ffH
  0001d	68 00 00 00 00	 push	 OFFSET _sprtemp
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  : 	maxframe = (size_t)-1;

  0002a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _maxframe, -1

; 191  : 
; 192  : 	// are we 'patching' a sprite already loaded ?
; 193  : 	// if so, it might patch only certain frames, not all
; 194  : 	if (spritedef->numframes) // (then spriteframes is not null)

  00034	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  00037	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003a	74 2a		 je	 SHORT $LN13@R_AddSingl

; 195  : 	{
; 196  : 		// copy the already defined sprite frames
; 197  : 		M_Memcpy(sprtemp, spritedef->spriteframes,

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  0003f	6b 08 4c	 imul	 ecx, DWORD PTR [eax], 76
  00042	51		 push	 ecx
  00043	8b 55 0c	 mov	 edx, DWORD PTR _spritedef$[ebp]
  00046	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET _sprtemp
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  : 		 spritedef->numframes * sizeof (spriteframe_t));
; 199  : 		maxframe = spritedef->numframes - 1;

  00058	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	83 e9 01	 sub	 ecx, 1
  00060	89 0d 00 00 00
	00		 mov	 DWORD PTR _maxframe, ecx
$LN13@R_AddSingl:

; 200  : 	}
; 201  : 
; 202  : 	// scan the lumps,
; 203  : 	//  filling in the frames for whatever is found
; 204  : 	lumpinfo = wadfiles[wadnum]->lumpinfo;

  00066	0f b7 45 10	 movzx	 eax, WORD PTR _wadnum$[ebp]
  0006a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00071	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00074	89 55 f0	 mov	 DWORD PTR _lumpinfo$[ebp], edx

; 205  : 	if (endlump > wadfiles[wadnum]->numlumps)

  00077	0f b7 45 18	 movzx	 eax, WORD PTR _endlump$[ebp]
  0007b	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  0007f	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _wadfiles[ecx*4]
  00086	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  0008a	3b c1		 cmp	 eax, ecx
  0008c	7e 13		 jle	 SHORT $LN14@R_AddSingl

; 206  : 		endlump = wadfiles[wadnum]->numlumps;

  0008e	0f b7 45 10	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00092	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00099	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  0009d	66 89 55 18	 mov	 WORD PTR _endlump$[ebp], dx
$LN14@R_AddSingl:

; 207  : 
; 208  : 	for (l = startlump; l < endlump; l++)

  000a1	66 8b 45 14	 mov	 ax, WORD PTR _startlump$[ebp]
  000a5	66 89 45 f8	 mov	 WORD PTR _l$[ebp], ax
  000a9	eb 0c		 jmp	 SHORT $LN4@R_AddSingl
$LN2@R_AddSingl:
  000ab	66 8b 45 f8	 mov	 ax, WORD PTR _l$[ebp]
  000af	66 83 c0 01	 add	 ax, 1
  000b3	66 89 45 f8	 mov	 WORD PTR _l$[ebp], ax
$LN4@R_AddSingl:
  000b7	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  000bb	0f b7 4d 18	 movzx	 ecx, WORD PTR _endlump$[ebp]
  000bf	3b c1		 cmp	 eax, ecx
  000c1	0f 8d 5d 02 00
	00		 jge	 $LN3@R_AddSingl

; 209  : 	{
; 210  : 		if (memcmp(lumpinfo[l].name,sprname,4)==0)

  000c7	6a 04		 push	 4
  000c9	8b 45 08	 mov	 eax, DWORD PTR _sprname$[ebp]
  000cc	50		 push	 eax
  000cd	0f b7 4d f8	 movzx	 ecx, WORD PTR _l$[ebp]
  000d1	6b d1 1c	 imul	 edx, ecx, 28
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _lumpinfo$[ebp]
  000d7	8d 4c 10 08	 lea	 ecx, DWORD PTR [eax+edx+8]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _memcmp
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	85 c0		 test	 eax, eax
  000e6	0f 85 33 02 00
	00		 jne	 $LN21@R_AddSingl

; 211  : 		{
; 212  : 			frame = (UINT8)(lumpinfo[l].name[4] - 'A');

  000ec	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  000f0	6b c8 1c	 imul	 ecx, eax, 28
  000f3	03 4d f0	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  000f6	ba 01 00 00 00	 mov	 edx, 1
  000fb	c1 e2 02	 shl	 edx, 2
  000fe	0f be 44 11 08	 movsx	 eax, BYTE PTR [ecx+edx+8]
  00103	83 e8 41	 sub	 eax, 65			; 00000041H
  00106	88 45 f7	 mov	 BYTE PTR _frame$[ebp], al

; 213  : 			rotation = (UINT8)(lumpinfo[l].name[5] - '0');

  00109	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  0010d	6b c8 1c	 imul	 ecx, eax, 28
  00110	03 4d f0	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  00113	ba 01 00 00 00	 mov	 edx, 1
  00118	6b c2 05	 imul	 eax, edx, 5
  0011b	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  00120	83 e9 30	 sub	 ecx, 48			; 00000030H
  00123	88 4d f6	 mov	 BYTE PTR _rotation$[ebp], cl

; 214  : 
; 215  : 			if (frame >= 64 || rotation > 8) // Give an actual NAME error -_-...

  00126	0f b6 45 f7	 movzx	 eax, BYTE PTR _frame$[ebp]
  0012a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0012d	7d 09		 jge	 SHORT $LN17@R_AddSingl
  0012f	0f b6 45 f6	 movzx	 eax, BYTE PTR _rotation$[ebp]
  00133	83 f8 08	 cmp	 eax, 8
  00136	7e 25		 jle	 SHORT $LN16@R_AddSingl
$LN17@R_AddSingl:

; 216  : 			{
; 217  : 				CONS_Printf("WARNING! Bad sprite name: %s", W_CheckNameForNumPwad(wadnum,l));

  00138	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  0013c	50		 push	 eax
  0013d	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  00147	83 c4 08	 add	 esp, 8
  0014a	50		 push	 eax
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OJMBDFML@WARNING?$CB?5Bad?5sprite?5name?3?5?$CFs@
  00150	e8 00 00 00 00	 call	 _CONS_Printf
  00155	83 c4 08	 add	 esp, 8

; 218  : 				continue;

  00158	e9 4e ff ff ff	 jmp	 $LN2@R_AddSingl
$LN16@R_AddSingl:

; 219  : 			}
; 220  : 
; 221  : 			// skip NULL sprites from very old dmadds pwads
; 222  : 			if (W_LumpLengthPwad(wadnum,l)<=8)

  0015d	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  00161	50		 push	 eax
  00162	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00166	51		 push	 ecx
  00167	e8 00 00 00 00	 call	 _W_LumpLengthPwad
  0016c	83 c4 08	 add	 esp, 8
  0016f	83 f8 08	 cmp	 eax, 8
  00172	77 05		 ja	 SHORT $LN18@R_AddSingl

; 223  : 				continue;

  00174	e9 32 ff ff ff	 jmp	 $LN2@R_AddSingl
$LN18@R_AddSingl:

; 224  : 
; 225  : 			// store sprite info in lookup tables
; 226  : 			//FIXME : numspritelumps do not duplicate sprite replacements
; 227  : 			W_ReadLumpHeaderPwad(wadnum, l, &patch, sizeof (patch_t), 0);

  00179	6a 00		 push	 0
  0017b	6a 28		 push	 40			; 00000028H
  0017d	8d 45 c8	 lea	 eax, DWORD PTR _patch$[ebp]
  00180	50		 push	 eax
  00181	0f b7 4d f8	 movzx	 ecx, WORD PTR _l$[ebp]
  00185	51		 push	 ecx
  00186	0f b7 55 10	 movzx	 edx, WORD PTR _wadnum$[ebp]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 _W_ReadLumpHeaderPwad
  00190	83 c4 14	 add	 esp, 20			; 00000014H

; 228  : 			spritecachedinfo[numspritelumps].width = SHORT(patch.width)<<FRACBITS;

  00193	0f bf 45 c8	 movsx	 eax, WORD PTR _patch$[ebp]
  00197	c1 e0 10	 shl	 eax, 16			; 00000010H
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numspritelumps
  001a0	c1 e1 04	 shl	 ecx, 4
  001a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritecachedinfo
  001a9	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 229  : 			spritecachedinfo[numspritelumps].offset = SHORT(patch.leftoffset)<<FRACBITS;

  001ac	0f bf 45 cc	 movsx	 eax, WORD PTR _patch$[ebp+4]
  001b0	c1 e0 10	 shl	 eax, 16			; 00000010H
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numspritelumps
  001b9	c1 e1 04	 shl	 ecx, 4
  001bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritecachedinfo
  001c2	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 230  : 			spritecachedinfo[numspritelumps].topoffset = SHORT(patch.topoffset)<<FRACBITS;

  001c6	0f bf 45 ce	 movsx	 eax, WORD PTR _patch$[ebp+6]
  001ca	c1 e0 10	 shl	 eax, 16			; 00000010H
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numspritelumps
  001d3	c1 e1 04	 shl	 ecx, 4
  001d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritecachedinfo
  001dc	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 231  : 			spritecachedinfo[numspritelumps].height = SHORT(patch.height)<<FRACBITS;

  001e0	0f bf 45 ca	 movsx	 eax, WORD PTR _patch$[ebp+2]
  001e4	c1 e0 10	 shl	 eax, 16			; 00000010H
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _numspritelumps
  001ed	c1 e1 04	 shl	 ecx, 4
  001f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritecachedinfo
  001f6	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 232  : 
; 233  : #ifdef HWRENDER
; 234  : 			//BP: we cannot use special tric in hardware mode because feet in ground caused by z-buffer
; 235  : 			if (rendermode != render_soft && rendermode != render_none // not for psprite
; 236  : 			 && SHORT(patch.topoffset)>0 && SHORT(patch.topoffset)<SHORT(patch.height))

  001fa	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00201	74 57		 je	 SHORT $LN19@R_AddSingl
  00203	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  0020a	74 4e		 je	 SHORT $LN19@R_AddSingl
  0020c	0f bf 45 ce	 movsx	 eax, WORD PTR _patch$[ebp+6]
  00210	85 c0		 test	 eax, eax
  00212	7e 46		 jle	 SHORT $LN19@R_AddSingl
  00214	0f bf 45 ce	 movsx	 eax, WORD PTR _patch$[ebp+6]
  00218	0f bf 4d ca	 movsx	 ecx, WORD PTR _patch$[ebp+2]
  0021c	3b c1		 cmp	 eax, ecx
  0021e	7d 3a		 jge	 SHORT $LN19@R_AddSingl

; 237  : 				// perfect is patch.height but sometime it is too high
; 238  : 				spritecachedinfo[numspritelumps].topoffset = min(SHORT(patch.topoffset)+4,SHORT(patch.height))<<FRACBITS;

  00220	0f bf 45 ce	 movsx	 eax, WORD PTR _patch$[ebp+6]
  00224	83 c0 04	 add	 eax, 4
  00227	0f bf 4d ca	 movsx	 ecx, WORD PTR _patch$[ebp+2]
  0022b	3b c1		 cmp	 eax, ecx
  0022d	7d 0c		 jge	 SHORT $LN30@R_AddSingl
  0022f	0f bf 55 ce	 movsx	 edx, WORD PTR _patch$[ebp+6]
  00233	83 c2 04	 add	 edx, 4
  00236	89 55 84	 mov	 DWORD PTR tv210[ebp], edx
  00239	eb 07		 jmp	 SHORT $LN31@R_AddSingl
$LN30@R_AddSingl:
  0023b	0f bf 45 ca	 movsx	 eax, WORD PTR _patch$[ebp+2]
  0023f	89 45 84	 mov	 DWORD PTR tv210[ebp], eax
$LN31@R_AddSingl:
  00242	8b 4d 84	 mov	 ecx, DWORD PTR tv210[ebp]
  00245	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00248	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numspritelumps
  0024e	c1 e2 04	 shl	 edx, 4
  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR _spritecachedinfo
  00256	89 4c 10 08	 mov	 DWORD PTR [eax+edx+8], ecx
$LN19@R_AddSingl:

; 239  : #endif
; 240  : 
; 241  : 			//----------------------------------------------------
; 242  : 
; 243  : 			R_InstallSpriteLump(wadnum, l, numspritelumps, frame, rotation, 0);

  0025a	6a 00		 push	 0
  0025c	0f b6 45 f6	 movzx	 eax, BYTE PTR _rotation$[ebp]
  00260	50		 push	 eax
  00261	0f b6 4d f7	 movzx	 ecx, BYTE PTR _frame$[ebp]
  00265	51		 push	 ecx
  00266	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numspritelumps
  0026c	52		 push	 edx
  0026d	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  00271	50		 push	 eax
  00272	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 _R_InstallSpriteLump
  0027c	83 c4 18	 add	 esp, 24			; 00000018H

; 244  : 
; 245  : 			if (lumpinfo[l].name[6])

  0027f	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  00283	6b c8 1c	 imul	 ecx, eax, 28
  00286	03 4d f0	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  00289	ba 01 00 00 00	 mov	 edx, 1
  0028e	6b c2 06	 imul	 eax, edx, 6
  00291	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  00296	85 c9		 test	 ecx, ecx
  00298	74 5f		 je	 SHORT $LN20@R_AddSingl

; 246  : 			{
; 247  : 				frame = (UINT8)(lumpinfo[l].name[6] - 'A');

  0029a	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  0029e	6b c8 1c	 imul	 ecx, eax, 28
  002a1	03 4d f0	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  002a4	ba 01 00 00 00	 mov	 edx, 1
  002a9	6b c2 06	 imul	 eax, edx, 6
  002ac	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  002b1	83 e9 41	 sub	 ecx, 65			; 00000041H
  002b4	88 4d f7	 mov	 BYTE PTR _frame$[ebp], cl

; 248  : 				rotation = (UINT8)(lumpinfo[l].name[7] - '0');

  002b7	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  002bb	6b c8 1c	 imul	 ecx, eax, 28
  002be	03 4d f0	 add	 ecx, DWORD PTR _lumpinfo$[ebp]
  002c1	ba 01 00 00 00	 mov	 edx, 1
  002c6	6b c2 07	 imul	 eax, edx, 7
  002c9	0f be 4c 01 08	 movsx	 ecx, BYTE PTR [ecx+eax+8]
  002ce	83 e9 30	 sub	 ecx, 48			; 00000030H
  002d1	88 4d f6	 mov	 BYTE PTR _rotation$[ebp], cl

; 249  : 				R_InstallSpriteLump(wadnum, l, numspritelumps, frame, rotation, 1);

  002d4	6a 01		 push	 1
  002d6	0f b6 45 f6	 movzx	 eax, BYTE PTR _rotation$[ebp]
  002da	50		 push	 eax
  002db	0f b6 4d f7	 movzx	 ecx, BYTE PTR _frame$[ebp]
  002df	51		 push	 ecx
  002e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _numspritelumps
  002e6	52		 push	 edx
  002e7	0f b7 45 f8	 movzx	 eax, WORD PTR _l$[ebp]
  002eb	50		 push	 eax
  002ec	0f b7 4d 10	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 _R_InstallSpriteLump
  002f6	83 c4 18	 add	 esp, 24			; 00000018H
$LN20@R_AddSingl:

; 250  : 			}
; 251  : 
; 252  : 			if (++numspritelumps >= MAXSPRITELUMPS)

  002f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _numspritelumps
  002fe	83 c0 01	 add	 eax, 1
  00301	a3 00 00 00 00	 mov	 DWORD PTR _numspritelumps, eax
  00306	81 3d 00 00 00
	00 00 20 00 00	 cmp	 DWORD PTR _numspritelumps, 8192 ; 00002000H
  00310	72 0d		 jb	 SHORT $LN21@R_AddSingl

; 253  : 				I_Error("R_AddSingleSpriteDef: too much sprite replacements (numspritelumps)\n");

  00312	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@DJLNLEII@R_AddSingleSpriteDef?3?5too?5much?5@
  00317	e8 00 00 00 00	 call	 _I_Error
  0031c	83 c4 04	 add	 esp, 4
$LN21@R_AddSingl:

; 254  : 		}
; 255  : 	}

  0031f	e9 87 fd ff ff	 jmp	 $LN2@R_AddSingl
$LN3@R_AddSingl:

; 256  : 
; 257  : 	//
; 258  : 	// if no frames found for this sprite
; 259  : 	//
; 260  : 	if (maxframe == (size_t)-1)

  00324	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _maxframe, -1
  0032b	75 07		 jne	 SHORT $LN22@R_AddSingl

; 261  : 	{
; 262  : 		// the first time (which is for the original wad),
; 263  : 		// all sprites should have their initial frames
; 264  : 		// and then, patch wads can replace it
; 265  : 		// we will skip non-replaced sprite frames, only if
; 266  : 		// they have already have been initially defined (original wad)
; 267  : 
; 268  : 		//check only after all initial pwads added
; 269  : 		//if (spritedef->numframes == 0)
; 270  : 		//    I_Error("R_AddSpriteDefs: no initial frames found for sprite %s\n",
; 271  : 		//             namelist[i]);
; 272  : 
; 273  : 		// sprite already has frames, and is not replaced by this wad
; 274  : 		return false;

  0032d	33 c0		 xor	 eax, eax
  0032f	e9 32 01 00 00	 jmp	 $LN1@R_AddSingl
$LN22@R_AddSingl:

; 275  : 	}
; 276  : 
; 277  : 	maxframe++;

  00334	a1 00 00 00 00	 mov	 eax, DWORD PTR _maxframe
  00339	83 c0 01	 add	 eax, 1
  0033c	a3 00 00 00 00	 mov	 DWORD PTR _maxframe, eax

; 278  : 
; 279  : 	//
; 280  : 	//  some checks to help development
; 281  : 	//
; 282  : 	for (frame = 0; frame < maxframe; frame++)

  00341	c6 45 f7 00	 mov	 BYTE PTR _frame$[ebp], 0
  00345	eb 08		 jmp	 SHORT $LN7@R_AddSingl
$LN5@R_AddSingl:
  00347	8a 45 f7	 mov	 al, BYTE PTR _frame$[ebp]
  0034a	04 01		 add	 al, 1
  0034c	88 45 f7	 mov	 BYTE PTR _frame$[ebp], al
$LN7@R_AddSingl:
  0034f	0f b6 45 f7	 movzx	 eax, BYTE PTR _frame$[ebp]
  00353	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _maxframe
  00359	0f 83 87 00 00
	00		 jae	 $LN6@R_AddSingl

; 283  : 	{
; 284  : 		switch (sprtemp[frame].rotate)

  0035f	0f b6 45 f7	 movzx	 eax, BYTE PTR _frame$[ebp]
  00363	6b c8 4c	 imul	 ecx, eax, 76
  00366	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR _sprtemp[ecx]
  0036c	88 55 84	 mov	 BYTE PTR tv263[ebp], dl
  0036f	80 7d 84 01	 cmp	 BYTE PTR tv263[ebp], 1
  00373	74 25		 je	 SHORT $LN25@R_AddSingl
  00375	80 7d 84 ff	 cmp	 BYTE PTR tv263[ebp], 255 ; 000000ffH
  00379	74 02		 je	 SHORT $LN23@R_AddSingl
  0037b	eb 64		 jmp	 SHORT $LN8@R_AddSingl
$LN23@R_AddSingl:

; 285  : 		{
; 286  : 			case 0xff:
; 287  : 			// no rotations were found for that frame at all
; 288  : 			I_Error("R_AddSingleSpriteDef: No patches found "

  0037d	0f b6 45 f7	 movzx	 eax, BYTE PTR _frame$[ebp]
  00381	83 c0 41	 add	 eax, 65			; 00000041H
  00384	50		 push	 eax
  00385	8b 4d 08	 mov	 ecx, DWORD PTR _sprname$[ebp]
  00388	51		 push	 ecx
  00389	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PAGKONHI@R_AddSingleSpriteDef?3?5No?5patche@
  0038e	e8 00 00 00 00	 call	 _I_Error
  00393	83 c4 0c	 add	 esp, 12			; 0000000cH

; 289  : 			        "for %s frame %c", sprname, frame+'A');
; 290  : 			break;

  00396	eb 49		 jmp	 SHORT $LN8@R_AddSingl

; 291  : 
; 292  : 			case 0:
; 293  : 			// only the first rotation is needed
; 294  : 			break;

  00398	eb 47		 jmp	 SHORT $LN8@R_AddSingl
$LN25@R_AddSingl:

; 295  : 
; 296  : 			case 1:
; 297  : 			// must have all 8 frames
; 298  : 			for (rotation = 0; rotation < 8; rotation++)

  0039a	c6 45 f6 00	 mov	 BYTE PTR _rotation$[ebp], 0
  0039e	eb 08		 jmp	 SHORT $LN12@R_AddSingl
$LN10@R_AddSingl:
  003a0	8a 45 f6	 mov	 al, BYTE PTR _rotation$[ebp]
  003a3	04 01		 add	 al, 1
  003a5	88 45 f6	 mov	 BYTE PTR _rotation$[ebp], al
$LN12@R_AddSingl:
  003a8	0f b6 45 f6	 movzx	 eax, BYTE PTR _rotation$[ebp]
  003ac	83 f8 08	 cmp	 eax, 8
  003af	7d 30		 jge	 SHORT $LN11@R_AddSingl

; 299  : 				// we test the patch lump, or the id lump whatever
; 300  : 				// if it was not loaded the two are LUMPERROR
; 301  : 				if (sprtemp[frame].lumppat[rotation] == LUMPERROR)

  003b1	0f b6 45 f7	 movzx	 eax, BYTE PTR _frame$[ebp]
  003b5	6b c8 4c	 imul	 ecx, eax, 76
  003b8	0f b6 55 f6	 movzx	 edx, BYTE PTR _rotation$[ebp]
  003bc	83 bc 91 04 00
	00 00 ff	 cmp	 DWORD PTR _sprtemp[ecx+edx*4+4], -1
  003c4	75 19		 jne	 SHORT $LN26@R_AddSingl

; 302  : 					I_Error("R_AddSingleSpriteDef: Sprite %s frame %c "

  003c6	0f b6 45 f7	 movzx	 eax, BYTE PTR _frame$[ebp]
  003ca	83 c0 41	 add	 eax, 65			; 00000041H
  003cd	50		 push	 eax
  003ce	8b 4d 08	 mov	 ecx, DWORD PTR _sprname$[ebp]
  003d1	51		 push	 ecx
  003d2	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@CKKDGOMC@R_AddSingleSpriteDef?3?5Sprite?5?$CFs@
  003d7	e8 00 00 00 00	 call	 _I_Error
  003dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@R_AddSingl:
  003df	eb bf		 jmp	 SHORT $LN10@R_AddSingl
$LN11@R_AddSingl:
$LN8@R_AddSingl:

; 303  : 					        "is missing rotations",
; 304  : 					        sprname, frame+'A');
; 305  : 			break;
; 306  : 		}
; 307  : 	}

  003e1	e9 61 ff ff ff	 jmp	 $LN5@R_AddSingl
$LN6@R_AddSingl:

; 308  : 
; 309  : 	// allocate space for the frames present and copy sprtemp to it
; 310  : 	if (spritedef->numframes &&             // has been allocated

  003e6	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  003e9	83 38 00	 cmp	 DWORD PTR [eax], 0
  003ec	74 26		 je	 SHORT $LN27@R_AddSingl
  003ee	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  003f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _maxframe
  003f9	73 19		 jae	 SHORT $LN27@R_AddSingl

; 311  : 		spritedef->numframes < maxframe)   // more frames are defined ?
; 312  : 	{
; 313  : 		Z_Free(spritedef->spriteframes);

  003fb	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  003fe	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00401	51		 push	 ecx
  00402	e8 00 00 00 00	 call	 _Z_Free
  00407	83 c4 04	 add	 esp, 4

; 314  : 		spritedef->spriteframes = NULL;

  0040a	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  0040d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN27@R_AddSingl:

; 315  : 	}
; 316  : 
; 317  : 	// allocate this sprite's frames
; 318  : 	if (!spritedef->spriteframes)

  00414	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  00417	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0041b	75 1c		 jne	 SHORT $LN28@R_AddSingl

; 319  : 		spritedef->spriteframes =

  0041d	6a 00		 push	 0
  0041f	6a 00		 push	 0
  00421	6a 01		 push	 1
  00423	6b 05 00 00 00
	00 4c		 imul	 eax, DWORD PTR _maxframe, 76
  0042a	50		 push	 eax
  0042b	e8 00 00 00 00	 call	 _Z_MallocAlign
  00430	83 c4 10	 add	 esp, 16			; 00000010H
  00433	8b 4d 0c	 mov	 ecx, DWORD PTR _spritedef$[ebp]
  00436	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN28@R_AddSingl:

; 320  : 		 Z_Malloc(maxframe * sizeof (*spritedef->spriteframes), PU_STATIC, NULL);
; 321  : 
; 322  : 	spritedef->numframes = maxframe;

  00439	8b 45 0c	 mov	 eax, DWORD PTR _spritedef$[ebp]
  0043c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _maxframe
  00442	89 08		 mov	 DWORD PTR [eax], ecx

; 323  : 	M_Memcpy(spritedef->spriteframes, sprtemp, maxframe*sizeof (spriteframe_t));

  00444	6b 05 00 00 00
	00 4c		 imul	 eax, DWORD PTR _maxframe, 76
  0044b	50		 push	 eax
  0044c	68 00 00 00 00	 push	 OFFSET _sprtemp
  00451	8b 4d 0c	 mov	 ecx, DWORD PTR _spritedef$[ebp]
  00454	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00457	52		 push	 edx
  00458	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0045e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 324  : 
; 325  : 	return true;

  00461	b8 01 00 00 00	 mov	 eax, 1
$LN1@R_AddSingl:

; 326  : }

  00466	5f		 pop	 edi
  00467	5e		 pop	 esi
  00468	5b		 pop	 ebx
  00469	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0046c	33 cd		 xor	 ecx, ebp
  0046e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00473	8b e5		 mov	 esp, ebp
  00475	5d		 pop	 ebp
  00476	c3		 ret	 0
_R_AddSingleSpriteDef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_RemoveSpriteLump
_TEXT	SEGMENT
_wad$ = 8						; size = 2
_lump$ = 12						; size = 2
_lumpid$ = 16						; size = 4
_frame$ = 20						; size = 1
_rotation$ = 24						; size = 1
_flipped$ = 28						; size = 1
_R_RemoveSpriteLump PROC				; COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 160  : 	(void)wad; /// \todo: how do I remove sprites?
; 161  : 	(void)lump;
; 162  : 	(void)lumpid;
; 163  : 	(void)frame;
; 164  : 	(void)rotation;
; 165  : 	(void)flipped;
; 166  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_R_RemoveSpriteLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_InstallSpriteLump
_TEXT	SEGMENT
_lumppat$ = -8						; size = 4
_r$ = -4						; size = 4
_wad$ = 8						; size = 2
_lump$ = 12						; size = 2
_lumpid$ = 16						; size = 4
_frame$ = 20						; size = 1
_rotation$ = 24						; size = 1
_flipped$ = 28						; size = 1
_R_InstallSpriteLump PROC				; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 100  : 	INT32 r;
; 101  : 	lumpnum_t lumppat = wad;

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _wad$[ebp]
  0000d	89 45 f8	 mov	 DWORD PTR _lumppat$[ebp], eax

; 102  : 	lumppat <<= 16;

  00010	8b 45 f8	 mov	 eax, DWORD PTR _lumppat$[ebp]
  00013	c1 e0 10	 shl	 eax, 16			; 00000010H
  00016	89 45 f8	 mov	 DWORD PTR _lumppat$[ebp], eax

; 103  : 	lumppat += lump;

  00019	0f b7 45 0c	 movzx	 eax, WORD PTR _lump$[ebp]
  0001d	03 45 f8	 add	 eax, DWORD PTR _lumppat$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _lumppat$[ebp], eax

; 104  : 
; 105  : 	if (frame >= 64 || rotation > 8)

  00023	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00027	83 f8 40	 cmp	 eax, 64			; 00000040H
  0002a	7d 09		 jge	 SHORT $LN6@R_InstallS
  0002c	0f b6 45 18	 movzx	 eax, BYTE PTR _rotation$[ebp]
  00030	83 f8 08	 cmp	 eax, 8
  00033	7e 1a		 jle	 SHORT $LN5@R_InstallS
$LN6@R_InstallS:

; 106  : 		I_Error("R_InstallSpriteLump: Bad frame characters in lump %s", W_CheckNameForNum(lumppat));

  00035	8b 45 f8	 mov	 eax, DWORD PTR _lumppat$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _W_CheckNameForNum
  0003e	83 c4 04	 add	 esp, 4
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@FHMKOFFL@R_InstallSpriteLump?3?5Bad?5frame?5@
  00047	e8 00 00 00 00	 call	 _I_Error
  0004c	83 c4 08	 add	 esp, 8
$LN5@R_InstallS:

; 107  : 
; 108  : 	if (maxframe ==(size_t)-1 || frame > maxframe)

  0004f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _maxframe, -1
  00056	74 0c		 je	 SHORT $LN8@R_InstallS
  00058	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  0005c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _maxframe
  00062	76 09		 jbe	 SHORT $LN7@R_InstallS
$LN8@R_InstallS:

; 109  : 		maxframe = frame;

  00064	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR _maxframe, eax
$LN7@R_InstallS:

; 110  : 
; 111  : 	if (rotation == 0)

  0006d	0f b6 45 18	 movzx	 eax, BYTE PTR _rotation$[ebp]
  00071	85 c0		 test	 eax, eax
  00073	0f 85 d8 00 00
	00		 jne	 $LN9@R_InstallS

; 112  : 	{
; 113  : 		// the lump should be used for all rotations
; 114  : 		if (sprtemp[frame].rotate == 0 && devparm)

  00079	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  0007d	6b c8 4c	 imul	 ecx, eax, 76
  00080	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _sprtemp[ecx]
  00087	85 d2		 test	 edx, edx
  00089	75 25		 jne	 SHORT $LN10@R_InstallS
  0008b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00092	74 1c		 je	 SHORT $LN10@R_InstallS

; 115  : 			I_OutputMsg("R_InitSprites: Sprite %s frame %c has multiple rot = 0 lump\n",

  00094	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00098	83 c0 41	 add	 eax, 65			; 00000041H
  0009b	50		 push	 eax
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritename
  000a2	51		 push	 ecx
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CJKANNFJ@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@
  000a8	e8 00 00 00 00	 call	 _I_OutputMsg
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@R_InstallS:

; 116  : 				spritename, 'A'+frame);
; 117  : 
; 118  : 		if (sprtemp[frame].rotate == 1 && devparm)

  000b0	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  000b4	6b c8 4c	 imul	 ecx, eax, 76
  000b7	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _sprtemp[ecx]
  000be	83 fa 01	 cmp	 edx, 1
  000c1	75 25		 jne	 SHORT $LN11@R_InstallS
  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  000ca	74 1c		 je	 SHORT $LN11@R_InstallS

; 119  : 			I_OutputMsg("R_InitSprites: Sprite %s frame %c has rotations and a rot = 0 lump\n",

  000cc	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  000d0	83 c0 41	 add	 eax, 65			; 00000041H
  000d3	50		 push	 eax
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritename
  000da	51		 push	 ecx
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@MIEHPANO@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@
  000e0	e8 00 00 00 00	 call	 _I_OutputMsg
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@R_InstallS:

; 120  : 				spritename, 'A'+frame);
; 121  : 
; 122  : 		sprtemp[frame].rotate = 0;

  000e8	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  000ec	6b c8 4c	 imul	 ecx, eax, 76
  000ef	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _sprtemp[ecx], 0

; 123  : 		for (r = 0; r < 8; r++)

  000f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], 0
  000fd	eb 09		 jmp	 SHORT $LN4@R_InstallS
$LN2@R_InstallS:
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  00102	83 c0 01	 add	 eax, 1
  00105	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax
$LN4@R_InstallS:
  00108	83 7d fc 08	 cmp	 DWORD PTR _r$[ebp], 8
  0010c	7d 3e		 jge	 SHORT $LN3@R_InstallS

; 124  : 		{
; 125  : 			sprtemp[frame].lumppat[r] = lumppat;

  0010e	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00112	6b c8 4c	 imul	 ecx, eax, 76
  00115	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  00118	8b 45 f8	 mov	 eax, DWORD PTR _lumppat$[ebp]
  0011b	89 84 91 04 00
	00 00		 mov	 DWORD PTR _sprtemp[ecx+edx*4+4], eax

; 126  : 			sprtemp[frame].lumpid[r] = lumpid;

  00122	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00126	6b c8 4c	 imul	 ecx, eax, 76
  00129	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  0012c	8b 45 10	 mov	 eax, DWORD PTR _lumpid$[ebp]
  0012f	89 84 91 24 00
	00 00		 mov	 DWORD PTR _sprtemp[ecx+edx*4+36], eax

; 127  : 			sprtemp[frame].flip[r] = flipped;

  00136	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  0013a	6b c8 4c	 imul	 ecx, eax, 76
  0013d	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  00140	8a 45 1c	 mov	 al, BYTE PTR _flipped$[ebp]
  00143	88 84 11 44 00
	00 00		 mov	 BYTE PTR _sprtemp[ecx+edx+68], al

; 128  : 		}

  0014a	eb b3		 jmp	 SHORT $LN2@R_InstallS
$LN3@R_InstallS:

; 129  : 		return;

  0014c	e9 ce 00 00 00	 jmp	 $LN1@R_InstallS
$LN9@R_InstallS:

; 130  : 	}
; 131  : 
; 132  : 	// the lump is only used for one rotation
; 133  : 	if (sprtemp[frame].rotate == 0 && devparm)

  00151	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00155	6b c8 4c	 imul	 ecx, eax, 76
  00158	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _sprtemp[ecx]
  0015f	85 d2		 test	 edx, edx
  00161	75 25		 jne	 SHORT $LN12@R_InstallS
  00163	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  0016a	74 1c		 je	 SHORT $LN12@R_InstallS

; 134  : 		I_OutputMsg("R_InitSprites: Sprite %s frame %c has rotations and a rot = 0 lump\n",

  0016c	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  00170	83 c0 41	 add	 eax, 65			; 00000041H
  00173	50		 push	 eax
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritename
  0017a	51		 push	 ecx
  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@MIEHPANO@R_InitSprites?3?5Sprite?5?$CFs?5frame?5@
  00180	e8 00 00 00 00	 call	 _I_OutputMsg
  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@R_InstallS:

; 135  : 			spritename, 'A'+frame);
; 136  : 
; 137  : 	sprtemp[frame].rotate = 1;

  00188	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  0018c	6b c8 4c	 imul	 ecx, eax, 76
  0018f	c6 81 00 00 00
	00 01		 mov	 BYTE PTR _sprtemp[ecx], 1

; 138  : 
; 139  : 	// make 0 based
; 140  : 	rotation--;

  00196	8a 45 18	 mov	 al, BYTE PTR _rotation$[ebp]
  00199	2c 01		 sub	 al, 1
  0019b	88 45 18	 mov	 BYTE PTR _rotation$[ebp], al

; 141  : 
; 142  : 	if (sprtemp[frame].lumppat[rotation] != LUMPERROR && devparm)

  0019e	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  001a2	6b c8 4c	 imul	 ecx, eax, 76
  001a5	0f b6 55 18	 movzx	 edx, BYTE PTR _rotation$[ebp]
  001a9	83 bc 91 04 00
	00 00 ff	 cmp	 DWORD PTR _sprtemp[ecx+edx*4+4], -1
  001b1	74 2d		 je	 SHORT $LN13@R_InstallS
  001b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  001ba	74 24		 je	 SHORT $LN13@R_InstallS

; 143  : 		I_OutputMsg("R_InitSprites: Sprite %s: %c:%c has two lumps mapped to it\n",

  001bc	0f b6 45 18	 movzx	 eax, BYTE PTR _rotation$[ebp]
  001c0	83 c0 31	 add	 eax, 49			; 00000031H
  001c3	50		 push	 eax
  001c4	0f b6 4d 14	 movzx	 ecx, BYTE PTR _frame$[ebp]
  001c8	83 c1 41	 add	 ecx, 65			; 00000041H
  001cb	51		 push	 ecx
  001cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _spritename
  001d2	52		 push	 edx
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BNBLKIJD@R_InitSprites?3?5Sprite?5?$CFs?3?5?$CFc?3?$CFc@
  001d8	e8 00 00 00 00	 call	 _I_OutputMsg
  001dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@R_InstallS:

; 144  : 			spritename, 'A'+frame, '1'+rotation);
; 145  : 
; 146  : 	// lumppat & lumpid are the same for original Doom, but different
; 147  : 	// when using sprites in pwad : the lumppat points the new graphics
; 148  : 	sprtemp[frame].lumppat[rotation] = lumppat;

  001e0	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  001e4	6b c8 4c	 imul	 ecx, eax, 76
  001e7	0f b6 55 18	 movzx	 edx, BYTE PTR _rotation$[ebp]
  001eb	8b 45 f8	 mov	 eax, DWORD PTR _lumppat$[ebp]
  001ee	89 84 91 04 00
	00 00		 mov	 DWORD PTR _sprtemp[ecx+edx*4+4], eax

; 149  : 	sprtemp[frame].lumpid[rotation] = lumpid;

  001f5	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  001f9	6b c8 4c	 imul	 ecx, eax, 76
  001fc	0f b6 55 18	 movzx	 edx, BYTE PTR _rotation$[ebp]
  00200	8b 45 10	 mov	 eax, DWORD PTR _lumpid$[ebp]
  00203	89 84 91 24 00
	00 00		 mov	 DWORD PTR _sprtemp[ecx+edx*4+36], eax

; 150  : 	sprtemp[frame].flip[rotation] = flipped;

  0020a	0f b6 45 14	 movzx	 eax, BYTE PTR _frame$[ebp]
  0020e	6b c8 4c	 imul	 ecx, eax, 76
  00211	0f b6 55 18	 movzx	 edx, BYTE PTR _rotation$[ebp]
  00215	8a 45 1c	 mov	 al, BYTE PTR _flipped$[ebp]
  00218	88 84 11 44 00
	00 00		 mov	 BYTE PTR _sprtemp[ecx+edx+68], al
$LN1@R_InstallS:

; 151  : }

  0021f	5f		 pop	 edi
  00220	5e		 pop	 esi
  00221	5b		 pop	 ebx
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
_R_InstallSpriteLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_InitSkins
_TEXT	SEGMENT
_R_InitSkins PROC					; COMDAT

; 2361 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2362 : #ifdef SKINVALUES
; 2363 : 	INT32 i;
; 2364 : 
; 2365 : 	for (i = 0; i <= MAXSKINS; i++)
; 2366 : 	{
; 2367 : 		skin_cons_t[i].value = 0;
; 2368 : 		skin_cons_t[i].strvalue = NULL;
; 2369 : 	}
; 2370 : #endif
; 2371 : 
; 2372 : 	// initialize free sfx slots for skin sounds
; 2373 : 	S_InitRuntimeSounds();

  00009	e8 00 00 00 00	 call	 _S_InitRuntimeSounds
  0000e	90		 npad	 1

; 2374 : 
; 2375 : 	// skin[0] = Sonic skin
; 2376 : 	Sk_SetDefaultValue(&skins[0]);

  0000f	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  00014	6b c8 00	 imul	 ecx, eax, 0
  00017	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _Sk_SetDefaultValue
  00023	83 c4 04	 add	 esp, 4

; 2377 : #ifdef SKINVALUES
; 2378 : 	skin_cons_t[0].strvalue = skins[0].name;
; 2379 : #endif
; 2380 : 
; 2381 : 	// make Sonic the default skin
; 2382 : 	numskins = 1;

  00026	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _numskins, 1

; 2383 : 
; 2384 : 	// add face/facename graphics (special case: 1 to MAXSKINS-1 handled in R_AddSkins)
; 2385 : 	ST_LoadFaceGraphics(skins[0].faceprefix, skins[0].superprefix, 0);

  00030	6a 00		 push	 0
  00032	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  00037	6b c8 00	 imul	 ecx, eax, 0
  0003a	81 c1 30 00 00
	00		 add	 ecx, OFFSET _skins+48
  00040	51		 push	 ecx
  00041	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  00046	6b c2 00	 imul	 eax, edx, 0
  00049	05 27 00 00 00	 add	 eax, OFFSET _skins+39
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _ST_LoadFaceGraphics
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2386 : 	ST_LoadFaceNameGraphics(skins[0].nameprefix, 0);

  00057	6a 00		 push	 0
  00059	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  0005e	6b c8 00	 imul	 ecx, eax, 0
  00061	81 c1 39 00 00
	00		 add	 ecx, OFFSET _skins+57
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _ST_LoadFaceNameGraphics
  0006d	83 c4 08	 add	 esp, 8

; 2387 : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_R_InitSkins ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _SetSavedSkin
_TEXT	SEGMENT
$T1 = -104						; size = 4
_val$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_playernum$ = 8						; size = 4
_skinnum$ = 12						; size = 4
_skincolor$ = 16					; size = 4
_SetSavedSkin PROC					; COMDAT

; 2600 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2601 : 	char val[32];
; 2602 : 
; 2603 : 	players[playernum].skincolor = skincolor % MAXSKINCOLORS;

  00013	8b 45 10	 mov	 eax, DWORD PTR _skincolor$[ebp]
  00016	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  0001b	79 05		 jns	 SHORT $LN6@SetSavedSk
  0001d	48		 dec	 eax
  0001e	83 c8 f0	 or	 eax, -16		; fffffff0H
  00021	40		 inc	 eax
$LN6@SetSavedSk:
  00022	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00029	89 81 b4 00 00
	00		 mov	 DWORD PTR _players[ecx+180], eax

; 2604 : 	_snprintf(val, sizeof val, "%d", players[playernum].skincolor);

  0002f	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00036	8b 88 b4 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+180]
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00042	6a 20		 push	 32			; 00000020H
  00044	8d 55 dc	 lea	 edx, DWORD PTR _val$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 __snprintf
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 2605 : 	val[sizeof val - 1] = '\0';

  00050	b8 01 00 00 00	 mov	 eax, 1
  00055	6b c8 1f	 imul	 ecx, eax, 31
  00058	89 4d 98	 mov	 DWORD PTR $T1[ebp], ecx
  0005b	83 7d 98 20	 cmp	 DWORD PTR $T1[ebp], 32	; 00000020H
  0005f	73 02		 jae	 SHORT $LN4@SetSavedSk
  00061	eb 06		 jmp	 SHORT $LN5@SetSavedSk
$LN4@SetSavedSk:
  00063	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00068	90		 npad	 1
$LN5@SetSavedSk:
  00069	8b 55 98	 mov	 edx, DWORD PTR $T1[ebp]
  0006c	c6 44 15 dc 00	 mov	 BYTE PTR _val$[ebp+edx], 0

; 2606 : 
; 2607 : 	SetSkinValues(&cv_skin, skins[skinnum].name,

  00071	6a 11		 push	 17			; 00000011H
  00073	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  0007a	05 00 00 00 00	 add	 eax, OFFSET _skins
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET _cv_skin
  00085	e8 00 00 00 00	 call	 _SetSkinValues
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2608 : 		sizeof skins[skinnum].name);
; 2609 : 	SetSkinValues(&cv_playercolor, val, sizeof val);

  0008d	6a 20		 push	 32			; 00000020H
  0008f	8d 45 dc	 lea	 eax, DWORD PTR _val$[ebp]
  00092	50		 push	 eax
  00093	68 00 00 00 00	 push	 OFFSET _cv_playercolor
  00098	e8 00 00 00 00	 call	 _SetSkinValues
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2610 : 
; 2611 : 	if (players[playernum].mo)

  000a0	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  000a7	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  000ae	74 43		 je	 SHORT $LN2@SetSavedSk

; 2612 : 	{
; 2613 : 		players[playernum].mo->flags |= MF_TRANSLATION;

  000b0	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  000b7	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000bd	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000c0	81 ca 00 00 00
	04		 or	 edx, 67108864		; 04000000H
  000c6	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  000cd	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000d3	89 51 60	 mov	 DWORD PTR [ecx+96], edx

; 2614 : 		players[playernum].mo->color = (UINT8)players[playernum].skincolor;

  000d6	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  000dd	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  000e4	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  000ea	8a 80 b4 00 00
	00		 mov	 al, BYTE PTR _players[eax+180]
  000f0	88 42 68	 mov	 BYTE PTR [edx+104], al
$LN2@SetSavedSk:

; 2615 : 	}
; 2616 : 
; 2617 : 	SetPlayerSkinByNum(playernum, skinnum);

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  000f6	50		 push	 eax
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _playernum$[ebp]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _SetPlayerSkinByNum
  00100	83 c4 08	 add	 esp, 8
$LN1@SetSavedSk:

; 2618 : }

  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	33 cd		 xor	 ecx, ebp
  0010b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
_SetSavedSkin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_InitDrawNodes
_TEXT	SEGMENT
_R_InitDrawNodes PROC					; COMDAT

; 1943 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1944 : 	nodebankhead.next = nodebankhead.prev = &nodebankhead;

  00009	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nodebankhead+24, OFFSET _nodebankhead
  00013	a1 18 00 00 00	 mov	 eax, DWORD PTR _nodebankhead+24
  00018	a3 14 00 00 00	 mov	 DWORD PTR _nodebankhead+20, eax

; 1945 : 	nodehead.next = nodehead.prev = &nodehead;

  0001d	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nodehead+24, OFFSET _nodehead
  00027	a1 18 00 00 00	 mov	 eax, DWORD PTR _nodehead+24
  0002c	a3 14 00 00 00	 mov	 DWORD PTR _nodehead+20, eax

; 1946 : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_R_InitDrawNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DelSkins
_TEXT	SEGMENT
_sprname$1 = -24					; size = 4
_found$2 = -20						; size = 4
_name$3 = -16						; size = 4
_csprname$4 = -12					; size = 4
_lastlump$ = -8						; size = 2
_lump$ = -4						; size = 2
_wadnum$ = 8						; size = 2
_R_DelSkins PROC					; COMDAT

; 2871 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2872 : 	UINT16 lump, lastlump = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
$LN2@R_DelSkins:

; 2873 : 	while ((lump = W_CheckForSkinMarkerInPwad(wadnum, lastlump)) != INT16_MAX)

  0000f	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  00013	50		 push	 eax
  00014	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _W_CheckForSkinMarkerInPwad
  0001e	83 c4 08	 add	 esp, 8
  00021	66 89 45 fc	 mov	 WORD PTR _lump$[ebp], ax
  00025	0f b7 55 fc	 movzx	 edx, WORD PTR _lump$[ebp]
  00029	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  0002f	0f 84 26 02 00
	00		 je	 $LN3@R_DelSkins

; 2874 : 	{
; 2875 : 		if (skins[numskins].wadnum != wadnum)

  00035	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0003f	0f b7 88 1c 00
	00 00		 movzx	 ecx, WORD PTR _skins[eax+28]
  00046	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  0004a	3b ca		 cmp	 ecx, edx
  0004c	74 05		 je	 SHORT $LN11@R_DelSkins

; 2876 : 			break;

  0004e	e9 08 02 00 00	 jmp	 $LN3@R_DelSkins
$LN11@R_DelSkins:

; 2877 : 		numskins--;

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00058	83 e8 01	 sub	 eax, 1
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _numskins, eax

; 2878 : 		ST_UnLoadFaceNameGraphics(numskins);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _ST_UnLoadFaceNameGraphics
  0006b	83 c4 04	 add	 esp, 4

; 2879 : 		ST_UnLoadFaceGraphics(numskins);

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _ST_UnLoadFaceGraphics
  00079	83 c4 04	 add	 esp, 4

; 2880 : 		if (skins[numskins].sprite[0] != '\0')

  0007c	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00086	b9 01 00 00 00	 mov	 ecx, 1
  0008b	6b d1 00	 imul	 edx, ecx, 0
  0008e	0f be 84 10 1e
	00 00 00	 movsx	 eax, BYTE PTR _skins[eax+edx+30]
  00096	85 c0		 test	 eax, eax
  00098	0f 84 96 00 00
	00		 je	 $LN12@R_DelSkins

; 2881 : 		{
; 2882 : 			const char *csprname = W_CheckNameForNumPwad(wadnum, lump);

  0009e	0f b7 45 fc	 movzx	 eax, WORD PTR _lump$[ebp]
  000a2	50		 push	 eax
  000a3	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  000ad	83 c4 08	 add	 esp, 8
  000b0	89 45 f4	 mov	 DWORD PTR _csprname$4[ebp], eax

; 2883 : 
; 2884 : 			// skip to end of this skin's frames
; 2885 : 			lastlump = lump;

  000b3	66 8b 45 fc	 mov	 ax, WORD PTR _lump$[ebp]
  000b7	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
$LN4@R_DelSkins:

; 2886 : 			while (W_CheckNameForNumPwad(wadnum,lastlump) && memcmp(W_CheckNameForNumPwad(wadnum, lastlump),csprname,4)==0)

  000bb	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  000bf	50		 push	 eax
  000c0	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  000ca	83 c4 08	 add	 esp, 8
  000cd	85 c0		 test	 eax, eax
  000cf	74 33		 je	 SHORT $LN5@R_DelSkins
  000d1	6a 04		 push	 4
  000d3	8b 45 f4	 mov	 eax, DWORD PTR _csprname$4[ebp]
  000d6	50		 push	 eax
  000d7	0f b7 4d f8	 movzx	 ecx, WORD PTR _lastlump$[ebp]
  000db	51		 push	 ecx
  000dc	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  000e6	83 c4 08	 add	 esp, 8
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _memcmp
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	85 c0		 test	 eax, eax
  000f4	75 0e		 jne	 SHORT $LN5@R_DelSkins

; 2887 : 				lastlump++;

  000f6	66 8b 45 f8	 mov	 ax, WORD PTR _lastlump$[ebp]
  000fa	66 83 c0 01	 add	 ax, 1
  000fe	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
  00102	eb b7		 jmp	 SHORT $LN4@R_DelSkins
$LN5@R_DelSkins:

; 2888 : 			// allocate (or replace) sprite frames, and set spritedef
; 2889 : 			R_DelSingleSpriteDef(csprname, &skins[numskins].spritedef, wadnum, lump, lastlump);

  00104	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  00108	50		 push	 eax
  00109	0f b7 4d fc	 movzx	 ecx, WORD PTR _lump$[ebp]
  0010d	51		 push	 ecx
  0010e	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  00112	52		 push	 edx
  00113	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0011d	05 14 00 00 00	 add	 eax, OFFSET _skins+20
  00122	50		 push	 eax
  00123	8b 4d f4	 mov	 ecx, DWORD PTR _csprname$4[ebp]
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 _R_DelSingleSpriteDef
  0012c	83 c4 14	 add	 esp, 20			; 00000014H

; 2890 : 		}

  0012f	e9 05 01 00 00	 jmp	 $LN10@R_DelSkins
$LN12@R_DelSkins:

; 2891 : 		else
; 2892 : 		{
; 2893 : 			// search in the normal sprite tables
; 2894 : 			size_t name;
; 2895 : 			boolean found = false;

  00134	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _found$2[ebp], 0

; 2896 : 			const char *sprname = skins[numskins].sprite;

  0013b	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00145	05 1e 00 00 00	 add	 eax, OFFSET _skins+30
  0014a	89 45 e8	 mov	 DWORD PTR _sprname$1[ebp], eax

; 2897 : 			for (name = 0;sprnames[name][0] != '\0';name++)

  0014d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _name$3[ebp], 0
  00154	eb 09		 jmp	 SHORT $LN8@R_DelSkins
$LN6@R_DelSkins:
  00156	8b 45 f0	 mov	 eax, DWORD PTR _name$3[ebp]
  00159	83 c0 01	 add	 eax, 1
  0015c	89 45 f0	 mov	 DWORD PTR _name$3[ebp], eax
$LN8@R_DelSkins:
  0015f	6b 45 f0 05	 imul	 eax, DWORD PTR _name$3[ebp], 5
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	6b d1 00	 imul	 edx, ecx, 0
  0016b	0f be 84 10 00
	00 00 00	 movsx	 eax, BYTE PTR _sprnames[eax+edx]
  00173	85 c0		 test	 eax, eax
  00175	74 4a		 je	 SHORT $LN7@R_DelSkins

; 2898 : 				if (strcmp(sprnames[name], sprname) == 0)

  00177	8b 45 e8	 mov	 eax, DWORD PTR _sprname$1[ebp]
  0017a	50		 push	 eax
  0017b	6b 4d f0 05	 imul	 ecx, DWORD PTR _name$3[ebp], 5
  0017f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _sprnames
  00185	51		 push	 ecx
  00186	e8 00 00 00 00	 call	 _strcmp
  0018b	83 c4 08	 add	 esp, 8
  0018e	85 c0		 test	 eax, eax
  00190	75 2d		 jne	 SHORT $LN14@R_DelSkins

; 2899 : 				{
; 2900 : 					found = true;

  00192	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _found$2[ebp], 1

; 2901 : 					skins[numskins].spritedef = sprites[name];

  00199	8b 45 f0	 mov	 eax, DWORD PTR _name$3[ebp]
  0019c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sprites
  001a2	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  001a5	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  001a9	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  001b3	89 91 14 00 00
	00		 mov	 DWORD PTR _skins[ecx+20], edx
  001b9	89 81 18 00 00
	00		 mov	 DWORD PTR _skins[ecx+24], eax
$LN14@R_DelSkins:

; 2902 : 				}

  001bf	eb 95		 jmp	 SHORT $LN6@R_DelSkins
$LN7@R_DelSkins:

; 2903 : 
; 2904 : 			// not found so make a new one
; 2905 : 			if (!found)

  001c1	83 7d ec 00	 cmp	 DWORD PTR _found$2[ebp], 0
  001c5	75 29		 jne	 SHORT $LN15@R_DelSkins

; 2906 : 				R_DelSingleSpriteDef(sprname, &skins[numskins].spritedef, wadnum, 0, INT16_MAX);

  001c7	68 ff 7f 00 00	 push	 32767			; 00007fffH
  001cc	6a 00		 push	 0
  001ce	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  001d2	50		 push	 eax
  001d3	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  001dd	81 c1 14 00 00
	00		 add	 ecx, OFFSET _skins+20
  001e3	51		 push	 ecx
  001e4	8b 55 e8	 mov	 edx, DWORD PTR _sprname$1[ebp]
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 _R_DelSingleSpriteDef
  001ed	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@R_DelSkins:

; 2907 : 
; 2908 : 			while (W_CheckNameForNumPwad(wadnum,lastlump) && memcmp(W_CheckNameForNumPwad(wadnum, lastlump),sprname,4)==0)

  001f0	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  001f4	50		 push	 eax
  001f5	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  001ff	83 c4 08	 add	 esp, 8
  00202	85 c0		 test	 eax, eax
  00204	74 33		 je	 SHORT $LN10@R_DelSkins
  00206	6a 04		 push	 4
  00208	8b 45 e8	 mov	 eax, DWORD PTR _sprname$1[ebp]
  0020b	50		 push	 eax
  0020c	0f b7 4d f8	 movzx	 ecx, WORD PTR _lastlump$[ebp]
  00210	51		 push	 ecx
  00211	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  0021b	83 c4 08	 add	 esp, 8
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _memcmp
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
  00227	85 c0		 test	 eax, eax
  00229	75 0e		 jne	 SHORT $LN10@R_DelSkins

; 2909 : 				lastlump++;

  0022b	66 8b 45 f8	 mov	 ax, WORD PTR _lastlump$[ebp]
  0022f	66 83 c0 01	 add	 ax, 1
  00233	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
  00237	eb b7		 jmp	 SHORT $LN15@R_DelSkins
$LN10@R_DelSkins:

; 2910 : 		}
; 2911 : 		CONS_Printf("removed skin '%s'\n", skins[numskins].name);

  00239	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00243	05 00 00 00 00	 add	 eax, OFFSET _skins
  00248	50		 push	 eax
  00249	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BPNLPHJD@removed?5skin?5?8?$CFs?8?6@
  0024e	e8 00 00 00 00	 call	 _CONS_Printf
  00253	83 c4 08	 add	 esp, 8

; 2912 : 	}

  00256	e9 b4 fd ff ff	 jmp	 $LN2@R_DelSkins
$LN3@R_DelSkins:

; 2913 : }

  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5b		 pop	 ebx
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
_R_DelSkins ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_AddSkins
_TEXT	SEGMENT
_sprname$1 = -64					; size = 4
_found$2 = -60						; size = 4
_name$3 = -56						; size = 4
_csprname$4 = -52					; size = 4
_i$5 = -48						; size = 4
_found$6 = -44						; size = 4
_colorval$7 = -37					; size = 1
_value2$8 = -36						; size = 4
_stringspace$9 = -32					; size = 4
_size$ = -28						; size = 4
_value$ = -24						; size = 4
_stoken$ = -20						; size = 4
_buf2$ = -16						; size = 4
_buf$ = -12						; size = 4
_lastlump$ = -8						; size = 2
_lump$ = -4						; size = 2
_wadnum$ = 8						; size = 2
_R_AddSkins PROC					; COMDAT

; 2649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2650 : 	UINT16 lump, lastlump = 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
$LN85@R_AddSkins:

; 2651 : 	char *buf;
; 2652 : 	char *buf2;
; 2653 : 	char *stoken;
; 2654 : 	char *value;
; 2655 : 	size_t size;
; 2656 : 
; 2657 : 	//
; 2658 : 	// search for all skin markers in pwad
; 2659 : 	//
; 2660 : 
; 2661 : 	while ((lump = W_CheckForSkinMarkerInPwad(wadnum, lastlump)) != INT16_MAX)

  00012	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  00016	50		 push	 eax
  00017	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 _W_CheckForSkinMarkerInPwad
  00021	83 c4 08	 add	 esp, 8
  00024	66 89 45 fc	 mov	 WORD PTR _lump$[ebp], ax
  00028	0f b7 55 fc	 movzx	 edx, WORD PTR _lump$[ebp]
  0002c	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00032	0f 84 40 0e 00
	00		 je	 $LN3@R_AddSkins

; 2662 : 	{
; 2663 : 		if (numskins > MAXSKINS)

  00038	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR _numskins, 32	; 00000020H
  0003f	7e 1d		 jle	 SHORT $LN16@R_AddSkins

; 2664 : 		{
; 2665 : 			CONS_Printf("ignored skin (%d skins maximum)\n", MAXSKINS);

  00041	6a 20		 push	 32			; 00000020H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNKLEDBE@ignored?5skin?5?$CI?$CFd?5skins?5maximum?$CJ@
  00048	e8 00 00 00 00	 call	 _CONS_Printf
  0004d	83 c4 08	 add	 esp, 8

; 2666 : 			lastlump++;

  00050	66 8b 45 f8	 mov	 ax, WORD PTR _lastlump$[ebp]
  00054	66 83 c0 01	 add	 ax, 1
  00058	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax

; 2667 : 			continue; // so we know how many skins couldn't be added

  0005c	eb b4		 jmp	 SHORT $LN85@R_AddSkins
$LN16@R_AddSkins:

; 2668 : 		}
; 2669 : 		buf = W_CacheLumpNumPwad(wadnum, lump, PU_CACHE);

  0005e	6a 65		 push	 101			; 00000065H
  00060	0f b7 45 fc	 movzx	 eax, WORD PTR _lump$[ebp]
  00064	50		 push	 eax
  00065	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _W_CacheLumpNumPwad
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	89 45 f4	 mov	 DWORD PTR _buf$[ebp], eax

; 2670 : 		size = W_LumpLengthPwad(wadnum, lump);

  00075	0f b7 45 fc	 movzx	 eax, WORD PTR _lump$[ebp]
  00079	50		 push	 eax
  0007a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _W_LumpLengthPwad
  00084	83 c4 08	 add	 esp, 8
  00087	89 45 e4	 mov	 DWORD PTR _size$[ebp], eax

; 2671 : 
; 2672 : 		// for strtok
; 2673 : 		buf2 = malloc(size+1);

  0008a	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  0008d	83 c0 01	 add	 eax, 1
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _malloc
  00096	83 c4 04	 add	 esp, 4
  00099	89 45 f0	 mov	 DWORD PTR _buf2$[ebp], eax

; 2674 : 		if (!buf2)

  0009c	83 7d f0 00	 cmp	 DWORD PTR _buf2$[ebp], 0
  000a0	75 0d		 jne	 SHORT $LN17@R_AddSkins

; 2675 : 			I_Error("R_AddSkins: No more free memory\n");

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KCPBGKKJ@R_AddSkins?3?5No?5more?5free?5memory@
  000a7	e8 00 00 00 00	 call	 _I_Error
  000ac	83 c4 04	 add	 esp, 4
$LN17@R_AddSkins:

; 2676 : 		M_Memcpy(buf2,buf,size);

  000af	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d f4	 mov	 ecx, DWORD PTR _buf$[ebp]
  000b6	51		 push	 ecx
  000b7	8b 55 f0	 mov	 edx, DWORD PTR _buf2$[ebp]
  000ba	52		 push	 edx
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2677 : 		buf2[size] = '\0';

  000c4	8b 45 f0	 mov	 eax, DWORD PTR _buf2$[ebp]
  000c7	03 45 e4	 add	 eax, DWORD PTR _size$[ebp]
  000ca	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2678 : 
; 2679 : 		// set defaults
; 2680 : 		Sk_SetDefaultValue(&skins[numskins]);

  000cd	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  000d7	05 00 00 00 00	 add	 eax, OFFSET _skins
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _Sk_SetDefaultValue
  000e2	83 c4 04	 add	 esp, 4

; 2681 : 		skins[numskins].wadnum = wadnum;

  000e5	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  000ef	66 8b 4d 08	 mov	 cx, WORD PTR _wadnum$[ebp]
  000f3	66 89 88 1c 00
	00 00		 mov	 WORD PTR _skins[eax+28], cx

; 2682 : 		_snprintf(skins[numskins].name,

  000fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  000ff	50		 push	 eax
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_07KHGPLMNC@skin?5?$CFd@
  00105	6a 11		 push	 17			; 00000011H
  00107	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00111	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 __snprintf
  0011d	83 c4 10	 add	 esp, 16			; 00000010H

; 2683 : 			sizeof skins[numskins].name, "skin %d", numskins);
; 2684 : 		skins[numskins].name[sizeof skins[numskins].name - 1] = '\0';

  00120	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	c1 e1 04	 shl	 ecx, 4
  00132	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR _skins[eax+ecx], 0

; 2685 : 		// parse
; 2686 : 		stoken = strtok (buf2, "\r\n= ");

  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_04BHMHHOFG@?$AN?6?$DN?5@
  0013f	8b 45 f0	 mov	 eax, DWORD PTR _buf2$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _strtok
  00148	83 c4 08	 add	 esp, 8
  0014b	89 45 ec	 mov	 DWORD PTR _stoken$[ebp], eax
$LN4@R_AddSkins:

; 2687 : 		while (stoken)

  0014e	83 7d ec 00	 cmp	 DWORD PTR _stoken$[ebp], 0
  00152	0f 84 4f 0a 00
	00		 je	 $LN5@R_AddSkins

; 2688 : 		{
; 2689 : 			if ((stoken[0] == '/' && stoken[1] == '/')
; 2690 : 				|| (stoken[0] == '#'))// skip comments

  00158	b8 01 00 00 00	 mov	 eax, 1
  0015d	6b c8 00	 imul	 ecx, eax, 0
  00160	8b 55 ec	 mov	 edx, DWORD PTR _stoken$[ebp]
  00163	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00167	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0016a	75 14		 jne	 SHORT $LN20@R_AddSkins
  0016c	b8 01 00 00 00	 mov	 eax, 1
  00171	c1 e0 00	 shl	 eax, 0
  00174	8b 4d ec	 mov	 ecx, DWORD PTR _stoken$[ebp]
  00177	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0017b	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  0017e	74 14		 je	 SHORT $LN19@R_AddSkins
$LN20@R_AddSkins:
  00180	b8 01 00 00 00	 mov	 eax, 1
  00185	6b c8 00	 imul	 ecx, eax, 0
  00188	8b 55 ec	 mov	 edx, DWORD PTR _stoken$[ebp]
  0018b	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0018f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00192	75 17		 jne	 SHORT $LN18@R_AddSkins
$LN19@R_AddSkins:

; 2691 : 			{
; 2692 : 				stoken = strtok(NULL, "\r\n"); // skip end of line

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@
  00199	6a 00		 push	 0
  0019b	e8 00 00 00 00	 call	 _strtok
  001a0	83 c4 08	 add	 esp, 8
  001a3	89 45 ec	 mov	 DWORD PTR _stoken$[ebp], eax

; 2693 : 				goto next_token;              // find the real next token

  001a6	e9 e5 09 00 00	 jmp	 $next_token$86
$LN18@R_AddSkins:

; 2694 : 			}
; 2695 : 
; 2696 : 			value = strtok(NULL, "\r\n= ");

  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_04BHMHHOFG@?$AN?6?$DN?5@
  001b0	6a 00		 push	 0
  001b2	e8 00 00 00 00	 call	 _strtok
  001b7	83 c4 08	 add	 esp, 8
  001ba	89 45 e8	 mov	 DWORD PTR _value$[ebp], eax

; 2697 : 
; 2698 : 			if (!value)

  001bd	83 7d e8 00	 cmp	 DWORD PTR _value$[ebp], 0
  001c1	75 33		 jne	 SHORT $LN21@R_AddSkins

; 2699 : 				I_Error("R_AddSkins: syntax error in S_SKIN lump# %d(%s) in WAD %s\n", lump, W_CheckNameForNumPwad(wadnum,lump), wadfiles[wadnum]->filename);

  001c3	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  001c7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  001ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d0	52		 push	 edx
  001d1	0f b7 45 fc	 movzx	 eax, WORD PTR _lump$[ebp]
  001d5	50		 push	 eax
  001d6	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  001da	51		 push	 ecx
  001db	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  001e0	83 c4 08	 add	 esp, 8
  001e3	50		 push	 eax
  001e4	0f b7 55 fc	 movzx	 edx, WORD PTR _lump$[ebp]
  001e8	52		 push	 edx
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@JCEPAMGD@R_AddSkins?3?5syntax?5error?5in?5S_S@
  001ee	e8 00 00 00 00	 call	 _I_Error
  001f3	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@R_AddSkins:

; 2700 : 
; 2701 : 			if (!stricmp(stoken, "name"))

  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_04MEMAJGDJ@name@
  001fb	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _stricmp
  00204	83 c4 08	 add	 esp, 8
  00207	85 c0		 test	 eax, eax
  00209	0f 85 f6 00 00
	00		 jne	 $LN22@R_AddSkins

; 2702 : 			{
; 2703 : 				// the skin name must uniquely identify a single skin
; 2704 : 				// I'm lazy so if name is already used I leave the 'skin x'
; 2705 : 				// default skin name set above
; 2706 : 				if (R_SkinAvailable(value) == -1)

  0020f	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _R_SkinAvailable
  00218	83 c4 04	 add	 esp, 4
  0021b	83 f8 ff	 cmp	 eax, -1
  0021e	75 3c		 jne	 SHORT $LN24@R_AddSkins

; 2707 : 				{
; 2708 : 					STRBUFCPY(skins[numskins].name, value);

  00220	6a 11		 push	 17			; 00000011H
  00222	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00225	50		 push	 eax
  00226	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00230	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  00236	51		 push	 ecx
  00237	e8 00 00 00 00	 call	 _strlcpy
  0023c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2709 : 					strlwr(skins[numskins].name);

  0023f	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00249	05 00 00 00 00	 add	 eax, OFFSET _skins
  0024e	50		 push	 eax
  0024f	e8 00 00 00 00	 call	 _strlwr
  00254	83 c4 04	 add	 esp, 4

; 2710 : 				}

  00257	e9 a4 00 00 00	 jmp	 $LN25@R_AddSkins
$LN24@R_AddSkins:

; 2711 : 				// I'm not lazy, so if the name is already used I make the name 'namex'
; 2712 : 				// using the default skin name's number set above
; 2713 : 				else
; 2714 : 				{
; 2715 : 					const size_t stringspace =

  0025c	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _strlen
  00265	83 c4 04	 add	 esp, 4
  00268	83 c0 05	 add	 eax, 5
  0026b	89 45 e0	 mov	 DWORD PTR _stringspace$9[ebp], eax

; 2716 : 						strlen(value) + sizeof (numskins) + 1;
; 2717 : 					char *value2 = Z_Malloc(stringspace, PU_STATIC, NULL);

  0026e	6a 00		 push	 0
  00270	6a 00		 push	 0
  00272	6a 01		 push	 1
  00274	8b 45 e0	 mov	 eax, DWORD PTR _stringspace$9[ebp]
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 _Z_MallocAlign
  0027d	83 c4 10	 add	 esp, 16			; 00000010H
  00280	89 45 dc	 mov	 DWORD PTR _value2$8[ebp], eax

; 2718 : 					_snprintf(value2, stringspace,

  00283	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00288	50		 push	 eax
  00289	8b 4d e8	 mov	 ecx, DWORD PTR _value$[ebp]
  0028c	51		 push	 ecx
  0028d	68 00 00 00 00	 push	 OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd@
  00292	8b 55 e0	 mov	 edx, DWORD PTR _stringspace$9[ebp]
  00295	52		 push	 edx
  00296	8b 45 dc	 mov	 eax, DWORD PTR _value2$8[ebp]
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 __snprintf
  0029f	83 c4 14	 add	 esp, 20			; 00000014H

; 2719 : 						"%s%d", value, numskins);
; 2720 : 					value2[stringspace - 1] = '\0';

  002a2	8b 45 dc	 mov	 eax, DWORD PTR _value2$8[ebp]
  002a5	03 45 e0	 add	 eax, DWORD PTR _stringspace$9[ebp]
  002a8	c6 40 ff 00	 mov	 BYTE PTR [eax-1], 0

; 2721 : 					if (R_SkinAvailable(value2) == -1)

  002ac	8b 45 dc	 mov	 eax, DWORD PTR _value2$8[ebp]
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 _R_SkinAvailable
  002b5	83 c4 04	 add	 esp, 4
  002b8	83 f8 ff	 cmp	 eax, -1
  002bb	75 37		 jne	 SHORT $LN26@R_AddSkins

; 2722 : 					{
; 2723 : 						STRBUFCPY(skins[numskins].name,

  002bd	6a 11		 push	 17			; 00000011H
  002bf	8b 45 dc	 mov	 eax, DWORD PTR _value2$8[ebp]
  002c2	50		 push	 eax
  002c3	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  002cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  002d3	51		 push	 ecx
  002d4	e8 00 00 00 00	 call	 _strlcpy
  002d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2724 : 							value2);
; 2725 : 						strlwr(skins[numskins].name);

  002dc	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  002e6	05 00 00 00 00	 add	 eax, OFFSET _skins
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 _strlwr
  002f1	83 c4 04	 add	 esp, 4
$LN26@R_AddSkins:

; 2726 : 					}
; 2727 : 					Z_Free(value2);

  002f4	8b 45 dc	 mov	 eax, DWORD PTR _value2$8[ebp]
  002f7	50		 push	 eax
  002f8	e8 00 00 00 00	 call	 _Z_Free
  002fd	83 c4 04	 add	 esp, 4
$LN25@R_AddSkins:

; 2728 : 				}
; 2729 : 			}

  00300	e9 8b 08 00 00	 jmp	 $next_token$86
$LN22@R_AddSkins:

; 2730 : // Macro to use for a lot of repeated code:
; 2731 : // str is the string used in the skin config file,
; 2732 : // field is the field in skin_t.
; 2733 : #define GETSKINATTRIB(str,field) \
; 2734 : 	else if (!stricmp(stoken, str))\
; 2735 : 	{\
; 2736 : 		STRBUFCPY(skins[numskins].field, value);\
; 2737 : 		strupr(skins[numskins].field);\
; 2738 : 	}
; 2739 : 
; 2740 : // For those with the same name for the config file and internal field.
; 2741 : #define GETSKINATTRIB_(field) GETSKINATTRIB(#field, field)
; 2742 : 
; 2743 : 			GETSKINATTRIB("face", faceprefix)

  00305	68 00 00 00 00	 push	 OFFSET ??_C@_04POCOPAPC@face@
  0030a	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 _stricmp
  00313	83 c4 08	 add	 esp, 8
  00316	85 c0		 test	 eax, eax
  00318	75 3c		 jne	 SHORT $LN27@R_AddSkins
  0031a	6a 09		 push	 9
  0031c	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0031f	50		 push	 eax
  00320	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0032a	81 c1 27 00 00
	00		 add	 ecx, OFFSET _skins+39
  00330	51		 push	 ecx
  00331	e8 00 00 00 00	 call	 _strlcpy
  00336	83 c4 0c	 add	 esp, 12			; 0000000cH
  00339	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00343	05 27 00 00 00	 add	 eax, OFFSET _skins+39
  00348	50		 push	 eax
  00349	e8 00 00 00 00	 call	 _strupr
  0034e	83 c4 04	 add	 esp, 4
  00351	e9 3a 08 00 00	 jmp	 $next_token$86
$LN27@R_AddSkins:

; 2744 : 			GETSKINATTRIB("superface", superprefix)

  00356	68 00 00 00 00	 push	 OFFSET ??_C@_09EPPIIJIA@superface@
  0035b	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 _stricmp
  00364	83 c4 08	 add	 esp, 8
  00367	85 c0		 test	 eax, eax
  00369	75 3c		 jne	 SHORT $LN29@R_AddSkins
  0036b	6a 09		 push	 9
  0036d	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00370	50		 push	 eax
  00371	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0037b	81 c1 30 00 00
	00		 add	 ecx, OFFSET _skins+48
  00381	51		 push	 ecx
  00382	e8 00 00 00 00	 call	 _strlcpy
  00387	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038a	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00394	05 30 00 00 00	 add	 eax, OFFSET _skins+48
  00399	50		 push	 eax
  0039a	e8 00 00 00 00	 call	 _strupr
  0039f	83 c4 04	 add	 esp, 4
  003a2	e9 e9 07 00 00	 jmp	 $next_token$86
$LN29@R_AddSkins:

; 2745 : 			GETSKINATTRIB("facename", nameprefix) // Life icon name

  003a7	68 00 00 00 00	 push	 OFFSET ??_C@_08DFLEOFBA@facename@
  003ac	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  003af	50		 push	 eax
  003b0	e8 00 00 00 00	 call	 _stricmp
  003b5	83 c4 08	 add	 esp, 8
  003b8	85 c0		 test	 eax, eax
  003ba	75 3c		 jne	 SHORT $LN31@R_AddSkins
  003bc	6a 09		 push	 9
  003be	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  003c1	50		 push	 eax
  003c2	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  003cc	81 c1 39 00 00
	00		 add	 ecx, OFFSET _skins+57
  003d2	51		 push	 ecx
  003d3	e8 00 00 00 00	 call	 _strlcpy
  003d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003db	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  003e5	05 39 00 00 00	 add	 eax, OFFSET _skins+57
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 _strupr
  003f0	83 c4 04	 add	 esp, 4
  003f3	e9 98 07 00 00	 jmp	 $next_token$86
$LN31@R_AddSkins:

; 2746 : 
; 2747 : 			// character type identification
; 2748 : 			GETSKINATTRIB_(ability)

  003f8	68 00 00 00 00	 push	 OFFSET ??_C@_07CKHKDBL@ability@
  003fd	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00400	50		 push	 eax
  00401	e8 00 00 00 00	 call	 _stricmp
  00406	83 c4 08	 add	 esp, 8
  00409	85 c0		 test	 eax, eax
  0040b	75 3c		 jne	 SHORT $LN33@R_AddSkins
  0040d	6a 02		 push	 2
  0040f	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00412	50		 push	 eax
  00413	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0041d	81 c1 42 00 00
	00		 add	 ecx, OFFSET _skins+66
  00423	51		 push	 ecx
  00424	e8 00 00 00 00	 call	 _strlcpy
  00429	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042c	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00436	05 42 00 00 00	 add	 eax, OFFSET _skins+66
  0043b	50		 push	 eax
  0043c	e8 00 00 00 00	 call	 _strupr
  00441	83 c4 04	 add	 esp, 4
  00444	e9 47 07 00 00	 jmp	 $next_token$86
$LN33@R_AddSkins:

; 2749 : 			GETSKINATTRIB_(ability2)

  00449	68 00 00 00 00	 push	 OFFSET ??_C@_08GHBHDKDO@ability2@
  0044e	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00451	50		 push	 eax
  00452	e8 00 00 00 00	 call	 _stricmp
  00457	83 c4 08	 add	 esp, 8
  0045a	85 c0		 test	 eax, eax
  0045c	75 3c		 jne	 SHORT $LN35@R_AddSkins
  0045e	6a 02		 push	 2
  00460	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00463	50		 push	 eax
  00464	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0046e	81 c1 44 00 00
	00		 add	 ecx, OFFSET _skins+68
  00474	51		 push	 ecx
  00475	e8 00 00 00 00	 call	 _strlcpy
  0047a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047d	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00487	05 44 00 00 00	 add	 eax, OFFSET _skins+68
  0048c	50		 push	 eax
  0048d	e8 00 00 00 00	 call	 _strupr
  00492	83 c4 04	 add	 esp, 4
  00495	e9 f6 06 00 00	 jmp	 $next_token$86
$LN35@R_AddSkins:

; 2750 : 
; 2751 : 			GETSKINATTRIB_(runspeed)

  0049a	68 00 00 00 00	 push	 OFFSET ??_C@_08MPILJHLH@runspeed@
  0049f	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  004a2	50		 push	 eax
  004a3	e8 00 00 00 00	 call	 _stricmp
  004a8	83 c4 08	 add	 esp, 8
  004ab	85 c0		 test	 eax, eax
  004ad	75 3c		 jne	 SHORT $LN37@R_AddSkins
  004af	6a 03		 push	 3
  004b1	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  004b4	50		 push	 eax
  004b5	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  004bf	81 c1 6d 00 00
	00		 add	 ecx, OFFSET _skins+109
  004c5	51		 push	 ecx
  004c6	e8 00 00 00 00	 call	 _strlcpy
  004cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ce	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  004d8	05 6d 00 00 00	 add	 eax, OFFSET _skins+109
  004dd	50		 push	 eax
  004de	e8 00 00 00 00	 call	 _strupr
  004e3	83 c4 04	 add	 esp, 4
  004e6	e9 a5 06 00 00	 jmp	 $next_token$86
$LN37@R_AddSkins:

; 2752 : 			GETSKINATTRIB_(normalspeed)

  004eb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LOLDGOGD@normalspeed@
  004f0	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  004f3	50		 push	 eax
  004f4	e8 00 00 00 00	 call	 _stricmp
  004f9	83 c4 08	 add	 esp, 8
  004fc	85 c0		 test	 eax, eax
  004fe	75 3c		 jne	 SHORT $LN39@R_AddSkins
  00500	6a 03		 push	 3
  00502	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00505	50		 push	 eax
  00506	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00510	81 c1 6a 00 00
	00		 add	 ecx, OFFSET _skins+106
  00516	51		 push	 ecx
  00517	e8 00 00 00 00	 call	 _strlcpy
  0051c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0051f	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00529	05 6a 00 00 00	 add	 eax, OFFSET _skins+106
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 _strupr
  00534	83 c4 04	 add	 esp, 4
  00537	e9 54 06 00 00	 jmp	 $next_token$86
$LN39@R_AddSkins:

; 2753 : 			GETSKINATTRIB_(thrustfactor)

  0053c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LMABHIBC@thrustfactor@
  00541	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00544	50		 push	 eax
  00545	e8 00 00 00 00	 call	 _stricmp
  0054a	83 c4 08	 add	 esp, 8
  0054d	85 c0		 test	 eax, eax
  0054f	75 3c		 jne	 SHORT $LN41@R_AddSkins
  00551	6a 02		 push	 2
  00553	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00556	50		 push	 eax
  00557	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00561	81 c1 77 00 00
	00		 add	 ecx, OFFSET _skins+119
  00567	51		 push	 ecx
  00568	e8 00 00 00 00	 call	 _strlcpy
  0056d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00570	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0057a	05 77 00 00 00	 add	 eax, OFFSET _skins+119
  0057f	50		 push	 eax
  00580	e8 00 00 00 00	 call	 _strupr
  00585	83 c4 04	 add	 esp, 4
  00588	e9 03 06 00 00	 jmp	 $next_token$86
$LN41@R_AddSkins:

; 2754 : 			GETSKINATTRIB_(accelstart)

  0058d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JAFJCEHN@accelstart@
  00592	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00595	50		 push	 eax
  00596	e8 00 00 00 00	 call	 _stricmp
  0059b	83 c4 08	 add	 esp, 8
  0059e	85 c0		 test	 eax, eax
  005a0	75 3c		 jne	 SHORT $LN43@R_AddSkins
  005a2	6a 04		 push	 4
  005a4	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  005a7	50		 push	 eax
  005a8	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  005b2	81 c1 70 00 00
	00		 add	 ecx, OFFSET _skins+112
  005b8	51		 push	 ecx
  005b9	e8 00 00 00 00	 call	 _strlcpy
  005be	83 c4 0c	 add	 esp, 12			; 0000000cH
  005c1	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  005cb	05 70 00 00 00	 add	 eax, OFFSET _skins+112
  005d0	50		 push	 eax
  005d1	e8 00 00 00 00	 call	 _strupr
  005d6	83 c4 04	 add	 esp, 4
  005d9	e9 b2 05 00 00	 jmp	 $next_token$86
$LN43@R_AddSkins:

; 2755 : 			GETSKINATTRIB_(acceleration)

  005de	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OKFAMOHD@acceleration@
  005e3	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  005e6	50		 push	 eax
  005e7	e8 00 00 00 00	 call	 _stricmp
  005ec	83 c4 08	 add	 esp, 8
  005ef	85 c0		 test	 eax, eax
  005f1	75 3c		 jne	 SHORT $LN45@R_AddSkins
  005f3	6a 03		 push	 3
  005f5	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  005f8	50		 push	 eax
  005f9	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00603	81 c1 74 00 00
	00		 add	 ecx, OFFSET _skins+116
  00609	51		 push	 ecx
  0060a	e8 00 00 00 00	 call	 _strlcpy
  0060f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00612	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0061c	05 74 00 00 00	 add	 eax, OFFSET _skins+116
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 _strupr
  00627	83 c4 04	 add	 esp, 4
  0062a	e9 61 05 00 00	 jmp	 $next_token$86
$LN45@R_AddSkins:

; 2756 : 			GETSKINATTRIB_(superanims)

  0062f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BHBOEHCJ@superanims@
  00634	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00637	50		 push	 eax
  00638	e8 00 00 00 00	 call	 _stricmp
  0063d	83 c4 08	 add	 esp, 8
  00640	85 c0		 test	 eax, eax
  00642	75 3c		 jne	 SHORT $LN47@R_AddSkins
  00644	6a 02		 push	 2
  00646	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00649	50		 push	 eax
  0064a	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00654	81 c1 66 00 00
	00		 add	 ecx, OFFSET _skins+102
  0065a	51		 push	 ecx
  0065b	e8 00 00 00 00	 call	 _strlcpy
  00660	83 c4 0c	 add	 esp, 12			; 0000000cH
  00663	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0066d	05 66 00 00 00	 add	 eax, OFFSET _skins+102
  00672	50		 push	 eax
  00673	e8 00 00 00 00	 call	 _strupr
  00678	83 c4 04	 add	 esp, 4
  0067b	e9 10 05 00 00	 jmp	 $next_token$86
$LN47@R_AddSkins:

; 2757 : 			GETSKINATTRIB_(superspin)

  00680	68 00 00 00 00	 push	 OFFSET ??_C@_09OBDOPNJF@superspin@
  00685	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00688	50		 push	 eax
  00689	e8 00 00 00 00	 call	 _stricmp
  0068e	83 c4 08	 add	 esp, 8
  00691	85 c0		 test	 eax, eax
  00693	75 3c		 jne	 SHORT $LN49@R_AddSkins
  00695	6a 02		 push	 2
  00697	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0069a	50		 push	 eax
  0069b	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  006a5	81 c1 68 00 00
	00		 add	 ecx, OFFSET _skins+104
  006ab	51		 push	 ecx
  006ac	e8 00 00 00 00	 call	 _strlcpy
  006b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  006b4	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  006be	05 68 00 00 00	 add	 eax, OFFSET _skins+104
  006c3	50		 push	 eax
  006c4	e8 00 00 00 00	 call	 _strupr
  006c9	83 c4 04	 add	 esp, 4
  006cc	e9 bf 04 00 00	 jmp	 $next_token$86
$LN49@R_AddSkins:

; 2758 : 			GETSKINATTRIB_(thokitem)

  006d1	68 00 00 00 00	 push	 OFFSET ??_C@_08EGEKDPMF@thokitem@
  006d6	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 _stricmp
  006df	83 c4 08	 add	 esp, 8
  006e2	85 c0		 test	 eax, eax
  006e4	75 3c		 jne	 SHORT $LN51@R_AddSkins
  006e6	6a 08		 push	 8
  006e8	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  006eb	50		 push	 eax
  006ec	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  006f6	81 c1 46 00 00
	00		 add	 ecx, OFFSET _skins+70
  006fc	51		 push	 ecx
  006fd	e8 00 00 00 00	 call	 _strlcpy
  00702	83 c4 0c	 add	 esp, 12			; 0000000cH
  00705	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0070f	05 46 00 00 00	 add	 eax, OFFSET _skins+70
  00714	50		 push	 eax
  00715	e8 00 00 00 00	 call	 _strupr
  0071a	83 c4 04	 add	 esp, 4
  0071d	e9 6e 04 00 00	 jmp	 $next_token$86
$LN51@R_AddSkins:

; 2759 : 			GETSKINATTRIB_(ghostthokitem)

  00722	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OLMJMBP@ghostthokitem@
  00727	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0072a	50		 push	 eax
  0072b	e8 00 00 00 00	 call	 _stricmp
  00730	83 c4 08	 add	 esp, 8
  00733	85 c0		 test	 eax, eax
  00735	75 3c		 jne	 SHORT $LN53@R_AddSkins
  00737	6a 02		 push	 2
  00739	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0073c	50		 push	 eax
  0073d	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00747	81 c1 4e 00 00
	00		 add	 ecx, OFFSET _skins+78
  0074d	51		 push	 ecx
  0074e	e8 00 00 00 00	 call	 _strlcpy
  00753	83 c4 0c	 add	 esp, 12			; 0000000cH
  00756	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00760	05 4e 00 00 00	 add	 eax, OFFSET _skins+78
  00765	50		 push	 eax
  00766	e8 00 00 00 00	 call	 _strupr
  0076b	83 c4 04	 add	 esp, 4
  0076e	e9 1d 04 00 00	 jmp	 $next_token$86
$LN53@R_AddSkins:

; 2760 : 			GETSKINATTRIB_(spinitem)

  00773	68 00 00 00 00	 push	 OFFSET ??_C@_08LOGINMBL@spinitem@
  00778	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0077b	50		 push	 eax
  0077c	e8 00 00 00 00	 call	 _stricmp
  00781	83 c4 08	 add	 esp, 8
  00784	85 c0		 test	 eax, eax
  00786	75 3c		 jne	 SHORT $LN55@R_AddSkins
  00788	6a 08		 push	 8
  0078a	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0078d	50		 push	 eax
  0078e	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00798	81 c1 50 00 00
	00		 add	 ecx, OFFSET _skins+80
  0079e	51		 push	 ecx
  0079f	e8 00 00 00 00	 call	 _strlcpy
  007a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  007a7	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  007b1	05 50 00 00 00	 add	 eax, OFFSET _skins+80
  007b6	50		 push	 eax
  007b7	e8 00 00 00 00	 call	 _strupr
  007bc	83 c4 04	 add	 esp, 4
  007bf	e9 cc 03 00 00	 jmp	 $next_token$86
$LN55@R_AddSkins:

; 2761 : 			GETSKINATTRIB_(ghostspinitem)

  007c4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PGJOHPMB@ghostspinitem@
  007c9	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  007cc	50		 push	 eax
  007cd	e8 00 00 00 00	 call	 _stricmp
  007d2	83 c4 08	 add	 esp, 8
  007d5	85 c0		 test	 eax, eax
  007d7	75 3c		 jne	 SHORT $LN57@R_AddSkins
  007d9	6a 02		 push	 2
  007db	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  007de	50		 push	 eax
  007df	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  007e9	81 c1 58 00 00
	00		 add	 ecx, OFFSET _skins+88
  007ef	51		 push	 ecx
  007f0	e8 00 00 00 00	 call	 _strlcpy
  007f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  007f8	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00802	05 58 00 00 00	 add	 eax, OFFSET _skins+88
  00807	50		 push	 eax
  00808	e8 00 00 00 00	 call	 _strupr
  0080d	83 c4 04	 add	 esp, 4
  00810	e9 7b 03 00 00	 jmp	 $next_token$86
$LN57@R_AddSkins:

; 2762 : 			GETSKINATTRIB_(actionspd)

  00815	68 00 00 00 00	 push	 OFFSET ??_C@_09ICMAGONI@actionspd@
  0081a	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0081d	50		 push	 eax
  0081e	e8 00 00 00 00	 call	 _stricmp
  00823	83 c4 08	 add	 esp, 8
  00826	85 c0		 test	 eax, eax
  00828	75 3c		 jne	 SHORT $LN59@R_AddSkins
  0082a	6a 04		 push	 4
  0082c	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0082f	50		 push	 eax
  00830	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0083a	81 c1 5a 00 00
	00		 add	 ecx, OFFSET _skins+90
  00840	51		 push	 ecx
  00841	e8 00 00 00 00	 call	 _strlcpy
  00846	83 c4 0c	 add	 esp, 12			; 0000000cH
  00849	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00853	05 5a 00 00 00	 add	 eax, OFFSET _skins+90
  00858	50		 push	 eax
  00859	e8 00 00 00 00	 call	 _strupr
  0085e	83 c4 04	 add	 esp, 4
  00861	e9 2a 03 00 00	 jmp	 $next_token$86
$LN59@R_AddSkins:

; 2763 : 			GETSKINATTRIB_(mindash)

  00866	68 00 00 00 00	 push	 OFFSET ??_C@_07OJFIIEKN@mindash@
  0086b	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0086e	50		 push	 eax
  0086f	e8 00 00 00 00	 call	 _stricmp
  00874	83 c4 08	 add	 esp, 8
  00877	85 c0		 test	 eax, eax
  00879	75 3c		 jne	 SHORT $LN61@R_AddSkins
  0087b	6a 03		 push	 3
  0087d	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00880	50		 push	 eax
  00881	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0088b	81 c1 5e 00 00
	00		 add	 ecx, OFFSET _skins+94
  00891	51		 push	 ecx
  00892	e8 00 00 00 00	 call	 _strlcpy
  00897	83 c4 0c	 add	 esp, 12			; 0000000cH
  0089a	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  008a4	05 5e 00 00 00	 add	 eax, OFFSET _skins+94
  008a9	50		 push	 eax
  008aa	e8 00 00 00 00	 call	 _strupr
  008af	83 c4 04	 add	 esp, 4
  008b2	e9 d9 02 00 00	 jmp	 $next_token$86
$LN61@R_AddSkins:

; 2764 : 			GETSKINATTRIB_(maxdash)

  008b7	68 00 00 00 00	 push	 OFFSET ??_C@_07PDICLEM@maxdash@
  008bc	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  008bf	50		 push	 eax
  008c0	e8 00 00 00 00	 call	 _stricmp
  008c5	83 c4 08	 add	 esp, 8
  008c8	85 c0		 test	 eax, eax
  008ca	75 3c		 jne	 SHORT $LN63@R_AddSkins
  008cc	6a 03		 push	 3
  008ce	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  008d1	50		 push	 eax
  008d2	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  008dc	81 c1 61 00 00
	00		 add	 ecx, OFFSET _skins+97
  008e2	51		 push	 ecx
  008e3	e8 00 00 00 00	 call	 _strlcpy
  008e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  008eb	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  008f5	05 61 00 00 00	 add	 eax, OFFSET _skins+97
  008fa	50		 push	 eax
  008fb	e8 00 00 00 00	 call	 _strupr
  00900	83 c4 04	 add	 esp, 4
  00903	e9 88 02 00 00	 jmp	 $next_token$86
$LN63@R_AddSkins:

; 2765 : 
; 2766 : 			// custom translation table
; 2767 : 			else if (!stricmp(stoken, "startcolor"))

  00908	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LCAOKIL@startcolor@
  0090d	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00910	50		 push	 eax
  00911	e8 00 00 00 00	 call	 _stricmp
  00916	83 c4 08	 add	 esp, 8
  00919	85 c0		 test	 eax, eax
  0091b	75 57		 jne	 SHORT $LN65@R_AddSkins

; 2768 : 			{
; 2769 : 				UINT8 colorval;
; 2770 : 
; 2771 : 				STRBUFCPY(skins[numskins].starttranscolor,

  0091d	6a 04		 push	 4
  0091f	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00922	50		 push	 eax
  00923	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  0092d	81 c1 7d 00 00
	00		 add	 ecx, OFFSET _skins+125
  00933	51		 push	 ecx
  00934	e8 00 00 00 00	 call	 _strlcpy
  00939	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2772 : 					value);
; 2773 : 				strupr(skins[numskins].starttranscolor);

  0093c	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00946	05 7d 00 00 00	 add	 eax, OFFSET _skins+125
  0094b	50		 push	 eax
  0094c	e8 00 00 00 00	 call	 _strupr
  00951	83 c4 04	 add	 esp, 4

; 2774 : 
; 2775 : 				colorval = (UINT8)atoi(skins[numskins].starttranscolor);

  00954	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  0095e	05 7d 00 00 00	 add	 eax, OFFSET _skins+125
  00963	50		 push	 eax
  00964	e8 00 00 00 00	 call	 _atoi
  00969	83 c4 04	 add	 esp, 4
  0096c	88 45 db	 mov	 BYTE PTR _colorval$7[ebp], al

; 2776 : 			}

  0096f	e9 1c 02 00 00	 jmp	 $next_token$86
$LN65@R_AddSkins:

; 2777 : 
; 2778 : 			GETSKINATTRIB_(prefcolor)

  00974	68 00 00 00 00	 push	 OFFSET ??_C@_09POHEGMPI@prefcolor@
  00979	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  0097c	50		 push	 eax
  0097d	e8 00 00 00 00	 call	 _stricmp
  00982	83 c4 08	 add	 esp, 8
  00985	85 c0		 test	 eax, eax
  00987	75 3c		 jne	 SHORT $LN67@R_AddSkins
  00989	6a 03		 push	 3
  0098b	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  0098e	50		 push	 eax
  0098f	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00999	81 c1 81 00 00
	00		 add	 ecx, OFFSET _skins+129
  0099f	51		 push	 ecx
  009a0	e8 00 00 00 00	 call	 _strlcpy
  009a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  009a8	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  009b2	05 81 00 00 00	 add	 eax, OFFSET _skins+129
  009b7	50		 push	 eax
  009b8	e8 00 00 00 00	 call	 _strupr
  009bd	83 c4 04	 add	 esp, 4
  009c0	e9 cb 01 00 00	 jmp	 $next_token$86
$LN67@R_AddSkins:

; 2779 : 			GETSKINATTRIB("jumpheight", jumpfactor)

  009c5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OIDLFJJH@jumpheight@
  009ca	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  009cd	50		 push	 eax
  009ce	e8 00 00 00 00	 call	 _stricmp
  009d3	83 c4 08	 add	 esp, 8
  009d6	85 c0		 test	 eax, eax
  009d8	75 3c		 jne	 SHORT $LN69@R_AddSkins
  009da	6a 04		 push	 4
  009dc	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  009df	50		 push	 eax
  009e0	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  009ea	81 c1 79 00 00
	00		 add	 ecx, OFFSET _skins+121
  009f0	51		 push	 ecx
  009f1	e8 00 00 00 00	 call	 _strlcpy
  009f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  009f9	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00a03	05 79 00 00 00	 add	 eax, OFFSET _skins+121
  00a08	50		 push	 eax
  00a09	e8 00 00 00 00	 call	 _strupr
  00a0e	83 c4 04	 add	 esp, 4
  00a11	e9 7a 01 00 00	 jmp	 $next_token$86
$LN69@R_AddSkins:

; 2780 : 			GETSKINATTRIB_(highres)

  00a16	68 00 00 00 00	 push	 OFFSET ??_C@_07LAHGNKCJ@highres@
  00a1b	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00a1e	50		 push	 eax
  00a1f	e8 00 00 00 00	 call	 _stricmp
  00a24	83 c4 08	 add	 esp, 8
  00a27	85 c0		 test	 eax, eax
  00a29	75 3c		 jne	 SHORT $LN71@R_AddSkins
  00a2b	6a 02		 push	 2
  00a2d	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00a30	50		 push	 eax
  00a31	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00a3b	81 c1 84 00 00
	00		 add	 ecx, OFFSET _skins+132
  00a41	51		 push	 ecx
  00a42	e8 00 00 00 00	 call	 _strlcpy
  00a47	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a4a	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00a54	05 84 00 00 00	 add	 eax, OFFSET _skins+132
  00a59	50		 push	 eax
  00a5a	e8 00 00 00 00	 call	 _strupr
  00a5f	83 c4 04	 add	 esp, 4
  00a62	e9 29 01 00 00	 jmp	 $next_token$86
$LN71@R_AddSkins:

; 2781 : 			GETSKINATTRIB_(sprite)

  00a67	68 00 00 00 00	 push	 OFFSET ??_C@_06DKHPLDLO@sprite@
  00a6c	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00a6f	50		 push	 eax
  00a70	e8 00 00 00 00	 call	 _stricmp
  00a75	83 c4 08	 add	 esp, 8
  00a78	85 c0		 test	 eax, eax
  00a7a	75 3c		 jne	 SHORT $LN73@R_AddSkins
  00a7c	6a 09		 push	 9
  00a7e	8b 45 e8	 mov	 eax, DWORD PTR _value$[ebp]
  00a81	50		 push	 eax
  00a82	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00a8c	81 c1 1e 00 00
	00		 add	 ecx, OFFSET _skins+30
  00a92	51		 push	 ecx
  00a93	e8 00 00 00 00	 call	 _strlcpy
  00a98	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a9b	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00aa5	05 1e 00 00 00	 add	 eax, OFFSET _skins+30
  00aaa	50		 push	 eax
  00aab	e8 00 00 00 00	 call	 _strupr
  00ab0	83 c4 04	 add	 esp, 4
  00ab3	e9 d8 00 00 00	 jmp	 $next_token$86
$LN73@R_AddSkins:

; 2782 : 			else
; 2783 : 			{
; 2784 : 				INT32 found = false;

  00ab8	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _found$6[ebp], 0

; 2785 : 				sfxenum_t i;
; 2786 : 				// copy name of sounds that are remapped
; 2787 : 				// for this skin
; 2788 : 				for (i = 0; i < sfx_skinsoundslot0; i++)

  00abf	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00ac6	eb 09		 jmp	 SHORT $LN8@R_AddSkins
$LN6@R_AddSkins:
  00ac8	8b 45 d0	 mov	 eax, DWORD PTR _i$5[ebp]
  00acb	83 c0 01	 add	 eax, 1
  00ace	89 45 d0	 mov	 DWORD PTR _i$5[ebp], eax
$LN8@R_AddSkins:
  00ad1	81 7d d0 43 04
	00 00		 cmp	 DWORD PTR _i$5[ebp], 1091 ; 00000443H
  00ad8	0f 8d 88 00 00
	00		 jge	 $LN7@R_AddSkins

; 2789 : 				{
; 2790 : 					if (!S_sfx[i].name)

  00ade	6b 45 d0 2c	 imul	 eax, DWORD PTR _i$5[ebp], 44
  00ae2	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _S_sfx[eax], 0
  00ae9	75 02		 jne	 SHORT $LN75@R_AddSkins

; 2791 : 						continue;

  00aeb	eb db		 jmp	 SHORT $LN6@R_AddSkins
$LN75@R_AddSkins:

; 2792 : 					if (S_sfx[i].skinsound != -1
; 2793 : 						&& !stricmp(S_sfx[i].name,

  00aed	6b 45 d0 2c	 imul	 eax, DWORD PTR _i$5[ebp], 44
  00af1	83 b8 1c 00 00
	00 ff		 cmp	 DWORD PTR _S_sfx[eax+28], -1
  00af8	74 67		 je	 SHORT $LN76@R_AddSkins
  00afa	8b 45 ec	 mov	 eax, DWORD PTR _stoken$[ebp]
  00afd	83 c0 02	 add	 eax, 2
  00b00	50		 push	 eax
  00b01	6b 4d d0 2c	 imul	 ecx, DWORD PTR _i$5[ebp], 44
  00b05	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _S_sfx[ecx]
  00b0b	52		 push	 edx
  00b0c	e8 00 00 00 00	 call	 _stricmp
  00b11	83 c4 08	 add	 esp, 8
  00b14	85 c0		 test	 eax, eax
  00b16	75 49		 jne	 SHORT $LN76@R_AddSkins

; 2794 : 							stoken + 2))
; 2795 : 					{
; 2796 : 						skins[numskins].soundsid[S_sfx[i].skinsound] =

  00b18	6a 01		 push	 1
  00b1a	6b 45 d0 2c	 imul	 eax, DWORD PTR _i$5[ebp], 44
  00b1e	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[eax+12]
  00b24	51		 push	 ecx
  00b25	6b 55 d0 2c	 imul	 edx, DWORD PTR _i$5[ebp], 44
  00b29	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _S_sfx[edx+4]
  00b2f	50		 push	 eax
  00b30	8b 4d e8	 mov	 ecx, DWORD PTR _value$[ebp]
  00b33	83 c1 02	 add	 ecx, 2
  00b36	51		 push	 ecx
  00b37	e8 00 00 00 00	 call	 _S_AddSoundFx
  00b3c	83 c4 10	 add	 esp, 16			; 00000010H
  00b3f	69 15 00 00 00
	00 ec 00 00 00	 imul	 edx, DWORD PTR _numskins, 236
  00b49	6b 4d d0 2c	 imul	 ecx, DWORD PTR _i$5[ebp], 44
  00b4d	8b 89 1c 00 00
	00		 mov	 ecx, DWORD PTR _S_sfx[ecx+28]
  00b53	89 84 8a 88 00
	00 00		 mov	 DWORD PTR _skins[edx+ecx*4+136], eax

; 2797 : 							S_AddSoundFx(value+2,S_sfx[i].singularity,S_sfx[i].pitch, true);
; 2798 : 						found = true;

  00b5a	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _found$6[ebp], 1
$LN76@R_AddSkins:

; 2799 : 					}
; 2800 : 				}

  00b61	e9 62 ff ff ff	 jmp	 $LN6@R_AddSkins
$LN7@R_AddSkins:

; 2801 : 				if (!found)

  00b66	83 7d d4 00	 cmp	 DWORD PTR _found$6[ebp], 0
  00b6a	75 24		 jne	 SHORT $next_token$86

; 2802 : 					CONS_Printf("R_AddSkins: Unknown keyword '%s' in S_SKIN lump# %d (WAD %s)\n", stoken, lump, wadfiles[wadnum]->filename);

  00b6c	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00b70	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00b77	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b79	52		 push	 edx
  00b7a	0f b7 45 fc	 movzx	 eax, WORD PTR _lump$[ebp]
  00b7e	50		 push	 eax
  00b7f	8b 4d ec	 mov	 ecx, DWORD PTR _stoken$[ebp]
  00b82	51		 push	 ecx
  00b83	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@PGDPAONC@R_AddSkins?3?5Unknown?5keyword?5?8?$CFs@
  00b88	e8 00 00 00 00	 call	 _CONS_Printf
  00b8d	83 c4 10	 add	 esp, 16			; 00000010H
$next_token$86:

; 2803 : 			}
; 2804 : next_token:
; 2805 : 			stoken = strtok(NULL, "\r\n= ");

  00b90	68 00 00 00 00	 push	 OFFSET ??_C@_04BHMHHOFG@?$AN?6?$DN?5@
  00b95	6a 00		 push	 0
  00b97	e8 00 00 00 00	 call	 _strtok
  00b9c	83 c4 08	 add	 esp, 8
  00b9f	89 45 ec	 mov	 DWORD PTR _stoken$[ebp], eax

; 2806 : 		}

  00ba2	e9 a7 f5 ff ff	 jmp	 $LN4@R_AddSkins
$LN5@R_AddSkins:

; 2807 : 		free(buf2);

  00ba7	8b 45 f0	 mov	 eax, DWORD PTR _buf2$[ebp]
  00baa	50		 push	 eax
  00bab	e8 00 00 00 00	 call	 _free
  00bb0	83 c4 04	 add	 esp, 4

; 2808 : 
; 2809 : 		lump++; // if no sprite defined use spirte just after this one

  00bb3	66 8b 45 fc	 mov	 ax, WORD PTR _lump$[ebp]
  00bb7	66 83 c0 01	 add	 ax, 1
  00bbb	66 89 45 fc	 mov	 WORD PTR _lump$[ebp], ax

; 2810 : 		if (skins[numskins].sprite[0] == '\0')

  00bbf	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00bc9	b9 01 00 00 00	 mov	 ecx, 1
  00bce	6b d1 00	 imul	 edx, ecx, 0
  00bd1	0f be 84 10 1e
	00 00 00	 movsx	 eax, BYTE PTR _skins[eax+edx+30]
  00bd9	85 c0		 test	 eax, eax
  00bdb	0f 85 96 00 00
	00		 jne	 $LN78@R_AddSkins

; 2811 : 		{
; 2812 : 			const char *csprname = W_CheckNameForNumPwad(wadnum, lump);

  00be1	0f b7 45 fc	 movzx	 eax, WORD PTR _lump$[ebp]
  00be5	50		 push	 eax
  00be6	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00bea	51		 push	 ecx
  00beb	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  00bf0	83 c4 08	 add	 esp, 8
  00bf3	89 45 cc	 mov	 DWORD PTR _csprname$4[ebp], eax

; 2813 : 
; 2814 : 			// skip to end of this skin's frames
; 2815 : 			lastlump = lump;

  00bf6	66 8b 45 fc	 mov	 ax, WORD PTR _lump$[ebp]
  00bfa	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
$LN9@R_AddSkins:

; 2816 : 			while (W_CheckNameForNumPwad(wadnum,lastlump) && memcmp(W_CheckNameForNumPwad(wadnum, lastlump),csprname,4)==0)

  00bfe	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  00c02	50		 push	 eax
  00c03	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00c07	51		 push	 ecx
  00c08	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  00c0d	83 c4 08	 add	 esp, 8
  00c10	85 c0		 test	 eax, eax
  00c12	74 33		 je	 SHORT $LN10@R_AddSkins
  00c14	6a 04		 push	 4
  00c16	8b 45 cc	 mov	 eax, DWORD PTR _csprname$4[ebp]
  00c19	50		 push	 eax
  00c1a	0f b7 4d f8	 movzx	 ecx, WORD PTR _lastlump$[ebp]
  00c1e	51		 push	 ecx
  00c1f	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  00c23	52		 push	 edx
  00c24	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  00c29	83 c4 08	 add	 esp, 8
  00c2c	50		 push	 eax
  00c2d	e8 00 00 00 00	 call	 _memcmp
  00c32	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c35	85 c0		 test	 eax, eax
  00c37	75 0e		 jne	 SHORT $LN10@R_AddSkins

; 2817 : 				lastlump++;

  00c39	66 8b 45 f8	 mov	 ax, WORD PTR _lastlump$[ebp]
  00c3d	66 83 c0 01	 add	 ax, 1
  00c41	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
  00c45	eb b7		 jmp	 SHORT $LN9@R_AddSkins
$LN10@R_AddSkins:

; 2818 : 			// allocate (or replace) sprite frames, and set spritedef
; 2819 : 			R_AddSingleSpriteDef(csprname, &skins[numskins].spritedef, wadnum, lump, lastlump);

  00c47	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  00c4b	50		 push	 eax
  00c4c	0f b7 4d fc	 movzx	 ecx, WORD PTR _lump$[ebp]
  00c50	51		 push	 ecx
  00c51	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  00c55	52		 push	 edx
  00c56	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00c60	05 14 00 00 00	 add	 eax, OFFSET _skins+20
  00c65	50		 push	 eax
  00c66	8b 4d cc	 mov	 ecx, DWORD PTR _csprname$4[ebp]
  00c69	51		 push	 ecx
  00c6a	e8 00 00 00 00	 call	 _R_AddSingleSpriteDef
  00c6f	83 c4 14	 add	 esp, 20			; 00000014H

; 2820 : 		}

  00c72	e9 05 01 00 00	 jmp	 $LN15@R_AddSkins
$LN78@R_AddSkins:

; 2821 : 		else
; 2822 : 		{
; 2823 : 			// search in the normal sprite tables
; 2824 : 			size_t name;
; 2825 : 			boolean found = false;

  00c77	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _found$2[ebp], 0

; 2826 : 			const char *sprname = skins[numskins].sprite;

  00c7e	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00c88	05 1e 00 00 00	 add	 eax, OFFSET _skins+30
  00c8d	89 45 c0	 mov	 DWORD PTR _sprname$1[ebp], eax

; 2827 : 			for (name = 0;sprnames[name][0] != '\0';name++)

  00c90	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _name$3[ebp], 0
  00c97	eb 09		 jmp	 SHORT $LN13@R_AddSkins
$LN11@R_AddSkins:
  00c99	8b 45 c8	 mov	 eax, DWORD PTR _name$3[ebp]
  00c9c	83 c0 01	 add	 eax, 1
  00c9f	89 45 c8	 mov	 DWORD PTR _name$3[ebp], eax
$LN13@R_AddSkins:
  00ca2	6b 45 c8 05	 imul	 eax, DWORD PTR _name$3[ebp], 5
  00ca6	b9 01 00 00 00	 mov	 ecx, 1
  00cab	6b d1 00	 imul	 edx, ecx, 0
  00cae	0f be 84 10 00
	00 00 00	 movsx	 eax, BYTE PTR _sprnames[eax+edx]
  00cb6	85 c0		 test	 eax, eax
  00cb8	74 4a		 je	 SHORT $LN12@R_AddSkins

; 2828 : 				if (strcmp(sprnames[name], sprname) == 0)

  00cba	8b 45 c0	 mov	 eax, DWORD PTR _sprname$1[ebp]
  00cbd	50		 push	 eax
  00cbe	6b 4d c8 05	 imul	 ecx, DWORD PTR _name$3[ebp], 5
  00cc2	81 c1 00 00 00
	00		 add	 ecx, OFFSET _sprnames
  00cc8	51		 push	 ecx
  00cc9	e8 00 00 00 00	 call	 _strcmp
  00cce	83 c4 08	 add	 esp, 8
  00cd1	85 c0		 test	 eax, eax
  00cd3	75 2d		 jne	 SHORT $LN80@R_AddSkins

; 2829 : 				{
; 2830 : 					found = true;

  00cd5	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _found$2[ebp], 1

; 2831 : 					skins[numskins].spritedef = sprites[name];

  00cdc	8b 45 c8	 mov	 eax, DWORD PTR _name$3[ebp]
  00cdf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sprites
  00ce5	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00ce8	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00cec	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00cf6	89 91 14 00 00
	00		 mov	 DWORD PTR _skins[ecx+20], edx
  00cfc	89 81 18 00 00
	00		 mov	 DWORD PTR _skins[ecx+24], eax
$LN80@R_AddSkins:

; 2832 : 				}

  00d02	eb 95		 jmp	 SHORT $LN11@R_AddSkins
$LN12@R_AddSkins:

; 2833 : 
; 2834 : 			// not found so make a new one
; 2835 : 			if (!found)

  00d04	83 7d c4 00	 cmp	 DWORD PTR _found$2[ebp], 0
  00d08	75 29		 jne	 SHORT $LN81@R_AddSkins

; 2836 : 				R_AddSingleSpriteDef(sprname, &skins[numskins].spritedef, wadnum, 0, INT16_MAX);

  00d0a	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00d0f	6a 00		 push	 0
  00d11	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00d15	50		 push	 eax
  00d16	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00d20	81 c1 14 00 00
	00		 add	 ecx, OFFSET _skins+20
  00d26	51		 push	 ecx
  00d27	8b 55 c0	 mov	 edx, DWORD PTR _sprname$1[ebp]
  00d2a	52		 push	 edx
  00d2b	e8 00 00 00 00	 call	 _R_AddSingleSpriteDef
  00d30	83 c4 14	 add	 esp, 20			; 00000014H
$LN81@R_AddSkins:

; 2837 : 
; 2838 : 			while (W_CheckNameForNumPwad(wadnum,lastlump) && memcmp(W_CheckNameForNumPwad(wadnum, lastlump),sprname,4)==0)

  00d33	0f b7 45 f8	 movzx	 eax, WORD PTR _lastlump$[ebp]
  00d37	50		 push	 eax
  00d38	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00d3c	51		 push	 ecx
  00d3d	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  00d42	83 c4 08	 add	 esp, 8
  00d45	85 c0		 test	 eax, eax
  00d47	74 33		 je	 SHORT $LN15@R_AddSkins
  00d49	6a 04		 push	 4
  00d4b	8b 45 c0	 mov	 eax, DWORD PTR _sprname$1[ebp]
  00d4e	50		 push	 eax
  00d4f	0f b7 4d f8	 movzx	 ecx, WORD PTR _lastlump$[ebp]
  00d53	51		 push	 ecx
  00d54	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  00d58	52		 push	 edx
  00d59	e8 00 00 00 00	 call	 _W_CheckNameForNumPwad
  00d5e	83 c4 08	 add	 esp, 8
  00d61	50		 push	 eax
  00d62	e8 00 00 00 00	 call	 _memcmp
  00d67	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d6a	85 c0		 test	 eax, eax
  00d6c	75 0e		 jne	 SHORT $LN15@R_AddSkins

; 2839 : 				lastlump++;

  00d6e	66 8b 45 f8	 mov	 ax, WORD PTR _lastlump$[ebp]
  00d72	66 83 c0 01	 add	 ax, 1
  00d76	66 89 45 f8	 mov	 WORD PTR _lastlump$[ebp], ax
  00d7a	eb b7		 jmp	 SHORT $LN81@R_AddSkins
$LN15@R_AddSkins:

; 2840 : 		}
; 2841 : 
; 2842 : 		R_DoSkinTranslationInit();

  00d7c	e8 00 00 00 00	 call	 _R_DoSkinTranslationInit
  00d81	90		 npad	 1

; 2843 : 
; 2844 : 		CONS_Printf("added skin '%s'\n", skins[numskins].name);

  00d82	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00d8c	05 00 00 00 00	 add	 eax, OFFSET _skins
  00d91	50		 push	 eax
  00d92	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CAFAKMAD@added?5skin?5?8?$CFs?8?6@
  00d97	e8 00 00 00 00	 call	 _CONS_Printf
  00d9c	83 c4 08	 add	 esp, 8

; 2845 : #ifdef SKINVALUES
; 2846 : 		skin_cons_t[numskins].value = numskins;
; 2847 : 		skin_cons_t[numskins].strvalue = skins[numskins].name;
; 2848 : #endif
; 2849 : 
; 2850 : 		// add face/facename graphics
; 2851 : 		if (!atoi(skins[numskins].super))

  00d9f	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00da9	05 64 00 00 00	 add	 eax, OFFSET _skins+100
  00dae	50		 push	 eax
  00daf	e8 00 00 00 00	 call	 _atoi
  00db4	83 c4 04	 add	 esp, 4
  00db7	85 c0		 test	 eax, eax
  00db9	75 45		 jne	 SHORT $LN82@R_AddSkins

; 2852 : 		{
; 2853 : 			strncpy(skins[numskins].superprefix, skins[numskins].faceprefix, 8);

  00dbb	6a 08		 push	 8
  00dbd	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00dc7	05 27 00 00 00	 add	 eax, OFFSET _skins+39
  00dcc	50		 push	 eax
  00dcd	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00dd7	81 c1 30 00 00
	00		 add	 ecx, OFFSET _skins+48
  00ddd	51		 push	 ecx
  00dde	e8 00 00 00 00	 call	 _strncpy
  00de3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2854 : 			skins[numskins].superprefix[8] = '\0';

  00de6	69 05 00 00 00
	00 ec 00 00 00	 imul	 eax, DWORD PTR _numskins, 236
  00df0	b9 01 00 00 00	 mov	 ecx, 1
  00df5	c1 e1 03	 shl	 ecx, 3
  00df8	c6 84 08 30 00
	00 00 00	 mov	 BYTE PTR _skins[eax+ecx+48], 0
$LN82@R_AddSkins:

; 2855 : 		}
; 2856 : 
; 2857 : 		ST_LoadFaceGraphics(skins[numskins].faceprefix, skins[numskins].superprefix, numskins);

  00e00	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00e05	50		 push	 eax
  00e06	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00e10	81 c1 30 00 00
	00		 add	 ecx, OFFSET _skins+48
  00e16	51		 push	 ecx
  00e17	69 15 00 00 00
	00 ec 00 00 00	 imul	 edx, DWORD PTR _numskins, 236
  00e21	81 c2 27 00 00
	00		 add	 edx, OFFSET _skins+39
  00e27	52		 push	 edx
  00e28	e8 00 00 00 00	 call	 _ST_LoadFaceGraphics
  00e2d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2858 : 		ST_LoadFaceNameGraphics(skins[numskins].nameprefix, numskins);

  00e30	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00e35	50		 push	 eax
  00e36	69 0d 00 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _numskins, 236
  00e40	81 c1 39 00 00
	00		 add	 ecx, OFFSET _skins+57
  00e46	51		 push	 ecx
  00e47	e8 00 00 00 00	 call	 _ST_LoadFaceNameGraphics
  00e4c	83 c4 08	 add	 esp, 8

; 2859 : 
; 2860 : #ifdef HWRENDER
; 2861 : 		if (rendermode == render_opengl)

  00e4f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _rendermode, 2
  00e56	75 0e		 jne	 SHORT $LN83@R_AddSkins

; 2862 : 			HWR_AddPlayerMD2(numskins);

  00e58	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00e5d	50		 push	 eax
  00e5e	e8 00 00 00 00	 call	 _HWR_AddPlayerMD2
  00e63	83 c4 04	 add	 esp, 4
$LN83@R_AddSkins:

; 2863 : #endif
; 2864 : 
; 2865 : 		numskins++;

  00e66	a1 00 00 00 00	 mov	 eax, DWORD PTR _numskins
  00e6b	83 c0 01	 add	 eax, 1
  00e6e	a3 00 00 00 00	 mov	 DWORD PTR _numskins, eax

; 2866 : 	}

  00e73	e9 9a f1 ff ff	 jmp	 $LN85@R_AddSkins
$LN3@R_AddSkins:

; 2867 : 	return;
; 2868 : }

  00e78	5f		 pop	 edi
  00e79	5e		 pop	 esi
  00e7a	5b		 pop	 ebx
  00e7b	8b e5		 mov	 esp, ebp
  00e7d	5d		 pop	 ebp
  00e7e	c3		 ret	 0
_R_AddSkins ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_SkinAvailable
_TEXT	SEGMENT
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_R_SkinAvailable PROC					; COMDAT

; 2400 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2401 : 	INT32 i;
; 2402 : 
; 2403 : 	for (i = 0; i < numskins; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@R_SkinAvai
$LN2@R_SkinAvai:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_SkinAvai:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numskins
  00024	7d 25		 jge	 SHORT $LN3@R_SkinAvai

; 2404 : 	{
; 2405 : 		if (stricmp(skins[i].name,name)==0)

  00026	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00029	50		 push	 eax
  0002a	69 4d fc ec 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 236
  00031	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _stricmp
  0003d	83 c4 08	 add	 esp, 8
  00040	85 c0		 test	 eax, eax
  00042	75 05		 jne	 SHORT $LN5@R_SkinAvai

; 2406 : 			return i;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00047	eb 05		 jmp	 SHORT $LN1@R_SkinAvai
$LN5@R_SkinAvai:

; 2407 : 	}

  00049	eb c7		 jmp	 SHORT $LN2@R_SkinAvai
$LN3@R_SkinAvai:

; 2408 : 	return -1;

  0004b	83 c8 ff	 or	 eax, -1
$LN1@R_SkinAvai:

; 2409 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_R_SkinAvailable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _SetPlayerSkinByNum
_TEXT	SEGMENT
_player$ = -4						; size = 4
_playernum$ = 8						; size = 4
_skinnum$ = 12						; size = 4
_SetPlayerSkinByNum PROC				; COMDAT

; 2436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2437 : 	player_t *player;
; 2438 : 
; 2439 : 	if (skinnum >= 0 && skinnum < numskins) // Make sure it exists!

  00009	83 7d 0c 00	 cmp	 DWORD PTR _skinnum$[ebp], 0
  0000d	0f 8c b9 04 00
	00		 jl	 $LN2@SetPlayerS
  00013	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  00016	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numskins
  0001c	0f 8d aa 04 00
	00		 jge	 $LN2@SetPlayerS

; 2440 : 	{
; 2441 : 		players[playernum].skin = skinnum;

  00022	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _skinnum$[ebp]
  0002c	89 88 b8 00 00
	00		 mov	 DWORD PTR _players[eax+184], ecx

; 2442 : 		if (players[playernum].mo)

  00032	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00039	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00040	0f 84 83 00 00
	00		 je	 $LN5@SetPlayerS

; 2443 : 		{
; 2444 : 			players[playernum].mo->skin = &skins[skinnum];

  00046	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  0004d	05 00 00 00 00	 add	 eax, OFFSET _skins
  00052	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00059	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _players[ecx]
  0005f	89 42 64	 mov	 DWORD PTR [edx+100], eax

; 2445 : 			if (atoi(skins[skinnum].highres))

  00062	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00069	05 84 00 00 00	 add	 eax, OFFSET _skins+132
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _atoi
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	74 28		 je	 SHORT $LN4@SetPlayerS

; 2446 : 				players[playernum].mo->flags |= MF_HIRES;

  0007b	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00082	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00088	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0008b	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00091	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00098	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  0009e	89 51 60	 mov	 DWORD PTR [ecx+96], edx
  000a1	eb 26		 jmp	 SHORT $LN5@SetPlayerS
$LN4@SetPlayerS:

; 2447 : 			else
; 2448 : 				players[playernum].mo->flags &= ~MF_HIRES;

  000a3	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  000aa	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000b0	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000b3	81 e2 ff ff f7
	ff		 and	 edx, -524289		; fff7ffffH
  000b9	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  000c0	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000c6	89 51 60	 mov	 DWORD PTR [ecx+96], edx
$LN5@SetPlayerS:

; 2449 : 		}
; 2450 : 
; 2451 : 		players[playernum].charability = atoi(skins[skinnum].ability);

  000c9	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  000d0	05 42 00 00 00	 add	 eax, OFFSET _skins+66
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _atoi
  000db	83 c4 04	 add	 esp, 4
  000de	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  000e5	89 81 d8 00 00
	00		 mov	 DWORD PTR _players[ecx+216], eax

; 2452 : 		players[playernum].charability2 = atoi(skins[skinnum].ability2);

  000eb	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  000f2	05 44 00 00 00	 add	 eax, OFFSET _skins+68
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _atoi
  000fd	83 c4 04	 add	 esp, 4
  00100	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00107	89 81 dc 00 00
	00		 mov	 DWORD PTR _players[ecx+220], eax

; 2453 : 
; 2454 : 		players[playernum].charflags = 0;

  0010d	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00114	c7 80 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+224], 0

; 2455 : 
; 2456 : 		if (atoi(skins[skinnum].superanims) == 1)

  0011e	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00125	05 66 00 00 00	 add	 eax, OFFSET _skins+102
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _atoi
  00130	83 c4 04	 add	 esp, 4
  00133	83 f8 01	 cmp	 eax, 1
  00136	75 1d		 jne	 SHORT $LN6@SetPlayerS

; 2457 : 			players[playernum].charflags |= SF_SUPERANIMS;

  00138	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  0013f	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+224]
  00145	83 c9 01	 or	 ecx, 1
  00148	69 55 08 fc 01
	00 00		 imul	 edx, DWORD PTR _playernum$[ebp], 508
  0014f	89 8a e0 00 00
	00		 mov	 DWORD PTR _players[edx+224], ecx
$LN6@SetPlayerS:

; 2458 : 
; 2459 : 		if (atoi(skins[skinnum].superspin) == 1)

  00155	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  0015c	05 68 00 00 00	 add	 eax, OFFSET _skins+104
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _atoi
  00167	83 c4 04	 add	 esp, 4
  0016a	83 f8 01	 cmp	 eax, 1
  0016d	75 1d		 jne	 SHORT $LN7@SetPlayerS

; 2460 : 			players[playernum].charflags |= SF_SUPERSPIN;

  0016f	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00176	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+224]
  0017c	83 c9 02	 or	 ecx, 2
  0017f	69 55 08 fc 01
	00 00		 imul	 edx, DWORD PTR _playernum$[ebp], 508
  00186	89 8a e0 00 00
	00		 mov	 DWORD PTR _players[edx+224], ecx
$LN7@SetPlayerS:

; 2461 : 
; 2462 : 		if (atoi(skins[skinnum].ghostthokitem) == 1)

  0018c	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00193	05 4e 00 00 00	 add	 eax, OFFSET _skins+78
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _atoi
  0019e	83 c4 04	 add	 esp, 4
  001a1	83 f8 01	 cmp	 eax, 1
  001a4	75 1d		 jne	 SHORT $LN8@SetPlayerS

; 2463 : 			players[playernum].charflags |= SF_GHOSTTHOKITEM;

  001a6	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  001ad	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+224]
  001b3	83 c9 04	 or	 ecx, 4
  001b6	69 55 08 fc 01
	00 00		 imul	 edx, DWORD PTR _playernum$[ebp], 508
  001bd	89 8a e0 00 00
	00		 mov	 DWORD PTR _players[edx+224], ecx
$LN8@SetPlayerS:

; 2464 : 
; 2465 : 		if (atoi(skins[skinnum].ghostspinitem) == 1)

  001c3	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  001ca	05 58 00 00 00	 add	 eax, OFFSET _skins+88
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 _atoi
  001d5	83 c4 04	 add	 esp, 4
  001d8	83 f8 01	 cmp	 eax, 1
  001db	75 1d		 jne	 SHORT $LN9@SetPlayerS

; 2466 : 			players[playernum].charflags |= SF_GHOSTSPINITEM;

  001dd	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  001e4	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+224]
  001ea	83 c9 08	 or	 ecx, 8
  001ed	69 55 08 fc 01
	00 00		 imul	 edx, DWORD PTR _playernum$[ebp], 508
  001f4	89 8a e0 00 00
	00		 mov	 DWORD PTR _players[edx+224], ecx
$LN9@SetPlayerS:

; 2467 : 
; 2468 : 		players[playernum].thokitem = atoi(skins[skinnum].thokitem);

  001fa	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00201	05 46 00 00 00	 add	 eax, OFFSET _skins+70
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 _atoi
  0020c	83 c4 04	 add	 esp, 4
  0020f	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00216	89 81 e4 00 00
	00		 mov	 DWORD PTR _players[ecx+228], eax

; 2469 : 		players[playernum].spinitem = atoi(skins[skinnum].spinitem);

  0021c	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00223	05 50 00 00 00	 add	 eax, OFFSET _skins+80
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _atoi
  0022e	83 c4 04	 add	 esp, 4
  00231	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00238	89 81 e8 00 00
	00		 mov	 DWORD PTR _players[ecx+232], eax

; 2470 : 
; 2471 : 		players[playernum].actionspd = atoi(skins[skinnum].actionspd);

  0023e	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00245	05 5a 00 00 00	 add	 eax, OFFSET _skins+90
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 _atoi
  00250	83 c4 04	 add	 esp, 4
  00253	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  0025a	89 81 ec 00 00
	00		 mov	 DWORD PTR _players[ecx+236], eax

; 2472 : 		players[playernum].mindash = atoi(skins[skinnum].mindash);

  00260	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00267	05 5e 00 00 00	 add	 eax, OFFSET _skins+94
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _atoi
  00272	83 c4 04	 add	 esp, 4
  00275	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  0027c	89 81 f0 00 00
	00		 mov	 DWORD PTR _players[ecx+240], eax

; 2473 : 		players[playernum].maxdash = atoi(skins[skinnum].maxdash);

  00282	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00289	05 61 00 00 00	 add	 eax, OFFSET _skins+97
  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 _atoi
  00294	83 c4 04	 add	 esp, 4
  00297	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  0029e	89 81 f4 00 00
	00		 mov	 DWORD PTR _players[ecx+244], eax

; 2474 : 
; 2475 : 		players[playernum].normalspeed = atoi(skins[skinnum].normalspeed);

  002a4	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  002ab	05 6a 00 00 00	 add	 eax, OFFSET _skins+106
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _atoi
  002b6	83 c4 04	 add	 esp, 4
  002b9	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  002c0	89 81 c4 00 00
	00		 mov	 DWORD PTR _players[ecx+196], eax

; 2476 : 		players[playernum].runspeed = atoi(skins[skinnum].runspeed);

  002c6	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  002cd	05 6d 00 00 00	 add	 eax, OFFSET _skins+109
  002d2	50		 push	 eax
  002d3	e8 00 00 00 00	 call	 _atoi
  002d8	83 c4 04	 add	 esp, 4
  002db	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  002e2	89 81 c8 00 00
	00		 mov	 DWORD PTR _players[ecx+200], eax

; 2477 : 		players[playernum].thrustfactor = atoi(skins[skinnum].thrustfactor);

  002e8	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  002ef	05 77 00 00 00	 add	 eax, OFFSET _skins+119
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 _atoi
  002fa	83 c4 04	 add	 esp, 4
  002fd	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00304	89 81 cc 00 00
	00		 mov	 DWORD PTR _players[ecx+204], eax

; 2478 : 		players[playernum].accelstart = atoi(skins[skinnum].accelstart);

  0030a	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00311	05 70 00 00 00	 add	 eax, OFFSET _skins+112
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 _atoi
  0031c	83 c4 04	 add	 esp, 4
  0031f	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00326	89 81 d0 00 00
	00		 mov	 DWORD PTR _players[ecx+208], eax

; 2479 : 		players[playernum].acceleration = atoi(skins[skinnum].acceleration);

  0032c	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00333	05 74 00 00 00	 add	 eax, OFFSET _skins+116
  00338	50		 push	 eax
  00339	e8 00 00 00 00	 call	 _atoi
  0033e	83 c4 04	 add	 esp, 4
  00341	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00348	89 81 d4 00 00
	00		 mov	 DWORD PTR _players[ecx+212], eax

; 2480 : 
; 2481 : 		// Cheat checks!
; 2482 : 		if (players[playernum].normalspeed > 36)

  0034e	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00355	83 b8 c4 00 00
	00 24		 cmp	 DWORD PTR _players[eax+196], 36 ; 00000024H
  0035c	7e 11		 jle	 SHORT $LN10@SetPlayerS

; 2483 : 			players[playernum].normalspeed = 36;

  0035e	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00365	c7 80 c4 00 00
	00 24 00 00 00	 mov	 DWORD PTR _players[eax+196], 36 ; 00000024H
$LN10@SetPlayerS:

; 2484 : 		if (players[playernum].thrustfactor > 5)

  0036f	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00376	83 b8 cc 00 00
	00 05		 cmp	 DWORD PTR _players[eax+204], 5
  0037d	7e 11		 jle	 SHORT $LN11@SetPlayerS

; 2485 : 			players[playernum].thrustfactor = 5;

  0037f	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00386	c7 80 cc 00 00
	00 05 00 00 00	 mov	 DWORD PTR _players[eax+204], 5
$LN11@SetPlayerS:

; 2486 : 		if (players[playernum].accelstart > 192)

  00390	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00397	81 b8 d0 00 00
	00 c0 00 00 00	 cmp	 DWORD PTR _players[eax+208], 192 ; 000000c0H
  003a1	7e 11		 jle	 SHORT $LN12@SetPlayerS

; 2487 : 			players[playernum].accelstart = 192;

  003a3	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  003aa	c7 80 d0 00 00
	00 c0 00 00 00	 mov	 DWORD PTR _players[eax+208], 192 ; 000000c0H
$LN12@SetPlayerS:

; 2488 : 		if (players[playernum].acceleration > 50)

  003b4	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  003bb	83 b8 d4 00 00
	00 32		 cmp	 DWORD PTR _players[eax+212], 50 ; 00000032H
  003c2	7e 11		 jle	 SHORT $LN13@SetPlayerS

; 2489 : 			players[playernum].acceleration = 50;

  003c4	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  003cb	c7 80 d4 00 00
	00 32 00 00 00	 mov	 DWORD PTR _players[eax+212], 50 ; 00000032H
$LN13@SetPlayerS:

; 2490 : 
; 2491 : 		// Convert fractional values in case FRACBITS != 16.
; 2492 : 		players[playernum].accelstart >>= (16-FRACBITS);

  003d5	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  003dc	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  003e3	8b 90 d0 00 00
	00		 mov	 edx, DWORD PTR _players[eax+208]
  003e9	89 91 d0 00 00
	00		 mov	 DWORD PTR _players[ecx+208], edx

; 2493 : 		players[playernum].acceleration >>= (16-FRACBITS);

  003ef	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  003f6	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  003fd	8b 90 d4 00 00
	00		 mov	 edx, DWORD PTR _players[eax+212]
  00403	89 91 d4 00 00
	00		 mov	 DWORD PTR _players[ecx+212], edx

; 2494 : 
; 2495 : 		players[playernum].jumpfactor = atoi(skins[skinnum].jumpfactor);

  00409	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00410	05 79 00 00 00	 add	 eax, OFFSET _skins+121
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 _atoi
  0041b	83 c4 04	 add	 esp, 4
  0041e	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00425	89 81 f8 00 00
	00		 mov	 DWORD PTR _players[ecx+248], eax

; 2496 : 
; 2497 : 		if (players[playernum].jumpfactor > 100)

  0042b	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00432	83 b8 f8 00 00
	00 64		 cmp	 DWORD PTR _players[eax+248], 100 ; 00000064H
  00439	7e 11		 jle	 SHORT $LN14@SetPlayerS

; 2498 : 			players[playernum].jumpfactor = 100;

  0043b	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00442	c7 80 f8 00 00
	00 64 00 00 00	 mov	 DWORD PTR _players[eax+248], 100 ; 00000064H
$LN14@SetPlayerS:

; 2499 : 
; 2500 : 		if (players[playernum].jumpfactor < 0)

  0044c	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00453	83 b8 f8 00 00
	00 00		 cmp	 DWORD PTR _players[eax+248], 0
  0045a	7d 11		 jge	 SHORT $LN15@SetPlayerS

; 2501 : 			players[playernum].jumpfactor = 0;

  0045c	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00463	c7 80 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+248], 0
$LN15@SetPlayerS:

; 2502 : 
; 2503 : #ifndef TRANSFIX
; 2504 : 		// Set the proper translation tables
; 2505 : 		players[playernum].starttranscolor = atoi(skins[skinnum].starttranscolor);
; 2506 : #endif
; 2507 : 
; 2508 : 		players[playernum].prefcolor = atoi(skins[skinnum].prefcolor);

  0046d	69 45 0c ec 00
	00 00		 imul	 eax, DWORD PTR _skinnum$[ebp], 236
  00474	05 81 00 00 00	 add	 eax, OFFSET _skins+129
  00479	50		 push	 eax
  0047a	e8 00 00 00 00	 call	 _atoi
  0047f	83 c4 04	 add	 esp, 4
  00482	69 4d 08 fc 01
	00 00		 imul	 ecx, DWORD PTR _playernum$[ebp], 508
  00489	89 81 fc 00 00
	00		 mov	 DWORD PTR _players[ecx+252], eax

; 2509 : 
; 2510 : 		if (players[playernum].mo)

  0048f	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00496	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  0049d	74 2b		 je	 SHORT $LN16@SetPlayerS

; 2511 : 			P_SetScale(players[playernum].mo, players[playernum].mo->scale);

  0049f	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  004a6	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  004ac	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  004b3	52		 push	 edx
  004b4	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  004bb	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  004c1	51		 push	 ecx
  004c2	e8 00 00 00 00	 call	 _P_SetScale
  004c7	83 c4 08	 add	 esp, 8
$LN16@SetPlayerS:

; 2512 : 
; 2513 : 		return;

  004ca	eb 6f		 jmp	 SHORT $LN18@SetPlayerS
$LN2@SetPlayerS:

; 2514 : 	}
; 2515 : 
; 2516 : 	player = &players[playernum];

  004cc	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  004d3	05 00 00 00 00	 add	 eax, OFFSET _players
  004d8	89 45 fc	 mov	 DWORD PTR _player$[ebp], eax

; 2517 : 
; 2518 : 	if (P_IsLocalPlayer(player))

  004db	8b 45 fc	 mov	 eax, DWORD PTR _player$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 _P_IsLocalPlayer
  004e4	83 c4 04	 add	 esp, 4
  004e7	85 c0		 test	 eax, eax
  004e9	74 11		 je	 SHORT $LN17@SetPlayerS

; 2519 : 		CONS_Printf("Skin %d not found\n", skinnum);

  004eb	8b 45 0c	 mov	 eax, DWORD PTR _skinnum$[ebp]
  004ee	50		 push	 eax
  004ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OGFHIFCE@Skin?5?$CFd?5not?5found?6@
  004f4	e8 00 00 00 00	 call	 _CONS_Printf
  004f9	83 c4 08	 add	 esp, 8
$LN17@SetPlayerS:

; 2520 : 
; 2521 : 	players[playernum].skin = 0;  // not found put the sonic skin

  004fc	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00503	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR _players[eax+184], 0

; 2522 : 
; 2523 : 	// a copy of the skin value
; 2524 : 	// so that dead body detached from respawning player keeps the skin
; 2525 : 	if (players[playernum].mo)

  0050d	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00514	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  0051b	74 1e		 je	 SHORT $LN18@SetPlayerS

; 2526 : 		players[playernum].mo->skin = &skins[0];

  0051d	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  00522	6b c8 00	 imul	 ecx, eax, 0
  00525	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  0052b	69 55 08 fc 01
	00 00		 imul	 edx, DWORD PTR _playernum$[ebp], 508
  00532	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _players[edx]
  00538	89 48 64	 mov	 DWORD PTR [eax+100], ecx
$LN18@SetPlayerS:

; 2527 : }

  0053b	5f		 pop	 edi
  0053c	5e		 pop	 esi
  0053d	5b		 pop	 ebx
  0053e	8b e5		 mov	 esp, ebp
  00540	5d		 pop	 ebp
  00541	c3		 ret	 0
_SetPlayerSkinByNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _SetPlayerSkin
_TEXT	SEGMENT
_player$ = -8						; size = 4
_i$ = -4						; size = 4
_playernum$ = 8						; size = 4
_skinname$ = 12						; size = 4
_SetPlayerSkin PROC					; COMDAT

; 2413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2414 : 	INT32 i;
; 2415 : 	player_t *player = &players[playernum];

  00009	69 45 08 fc 01
	00 00		 imul	 eax, DWORD PTR _playernum$[ebp], 508
  00010	05 00 00 00 00	 add	 eax, OFFSET _players
  00015	89 45 f8	 mov	 DWORD PTR _player$[ebp], eax

; 2416 : 
; 2417 : 	for (i = 0; i < numskins; i++)

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001f	eb 09		 jmp	 SHORT $LN4@SetPlayerS
$LN2@SetPlayerS:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@SetPlayerS:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numskins
  00033	7d 32		 jge	 SHORT $LN3@SetPlayerS

; 2418 : 	{
; 2419 : 		// search in the skin list
; 2420 : 		if (stricmp(skins[i].name, skinname) == 0)

  00035	8b 45 0c	 mov	 eax, DWORD PTR _skinname$[ebp]
  00038	50		 push	 eax
  00039	69 4d fc ec 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 236
  00040	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _stricmp
  0004c	83 c4 08	 add	 esp, 8
  0004f	85 c0		 test	 eax, eax
  00051	75 12		 jne	 SHORT $LN5@SetPlayerS

; 2421 : 		{
; 2422 : 			SetPlayerSkinByNum(playernum, i);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _playernum$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _SetPlayerSkinByNum
  00060	83 c4 08	 add	 esp, 8

; 2423 : 			return;

  00063	eb 31		 jmp	 SHORT $LN1@SetPlayerS
$LN5@SetPlayerS:

; 2424 : 		}
; 2425 : 	}

  00065	eb ba		 jmp	 SHORT $LN2@SetPlayerS
$LN3@SetPlayerS:

; 2426 : 
; 2427 : 	if (P_IsLocalPlayer(player))

  00067	8b 45 f8	 mov	 eax, DWORD PTR _player$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _P_IsLocalPlayer
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	74 11		 je	 SHORT $LN6@SetPlayerS

; 2428 : 		CONS_Printf("Skin %s not found\n", skinname);

  00077	8b 45 0c	 mov	 eax, DWORD PTR _skinname$[ebp]
  0007a	50		 push	 eax
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CPCDCFKG@Skin?5?$CFs?5not?5found?6@
  00080	e8 00 00 00 00	 call	 _CONS_Printf
  00085	83 c4 08	 add	 esp, 8
$LN6@SetPlayerS:

; 2429 : 
; 2430 : 	SetPlayerSkinByNum(playernum, 0);

  00088	6a 00		 push	 0
  0008a	8b 45 08	 mov	 eax, DWORD PTR _playernum$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _SetPlayerSkinByNum
  00093	83 c4 08	 add	 esp, 8
$LN1@SetPlayerS:

; 2431 : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
_SetPlayerSkin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DrawMasked
_TEXT	SEGMENT
_next$ = -8						; size = 4
_r2$ = -4						; size = 4
_R_DrawMasked PROC					; COMDAT

; 2253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2254 : 	drawnode_t *r2;
; 2255 : 	drawnode_t *next;
; 2256 : 
; 2257 : 	R_CreateDrawNodes();

  00009	e8 00 00 00 00	 call	 _R_CreateDrawNodes
  0000e	90		 npad	 1

; 2258 : 
; 2259 : 	for (r2 = nodehead.next; r2 != &nodehead; r2 = r2->next)

  0000f	a1 14 00 00 00	 mov	 eax, DWORD PTR _nodehead+20
  00014	89 45 fc	 mov	 DWORD PTR _r2$[ebp], eax
  00017	eb 09		 jmp	 SHORT $LN4@R_DrawMask
$LN2@R_DrawMask:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0001c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001f	89 4d fc	 mov	 DWORD PTR _r2$[ebp], ecx
$LN4@R_DrawMask:
  00022	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _r2$[ebp], OFFSET _nodehead
  00029	0f 84 40 01 00
	00		 je	 $LN3@R_DrawMask

; 2260 : 	{
; 2261 : 		if (r2->plane)

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00032	83 38 00	 cmp	 DWORD PTR [eax], 0
  00035	74 2e		 je	 SHORT $LN5@R_DrawMask

; 2262 : 		{
; 2263 : 			next = r2->prev;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0003a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003d	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 2264 : 			R_DrawSinglePlane(r2->plane);

  00040	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _R_DrawSinglePlane
  0004b	83 c4 04	 add	 esp, 4

; 2265 : 			R_DoneWithNode(r2);

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _R_DoneWithNode
  00057	83 c4 04	 add	 esp, 4

; 2266 : 			r2 = next;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0005d	89 45 fc	 mov	 DWORD PTR _r2$[ebp], eax

; 2267 : 		}

  00060	e9 05 01 00 00	 jmp	 $LN11@R_DrawMask
$LN5@R_DrawMask:

; 2268 : 		else if (r2->seg && r2->seg->maskedtexturecol != NULL)

  00065	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00068	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0006c	74 5c		 je	 SHORT $LN7@R_DrawMask
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00071	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00074	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00078	74 50		 je	 SHORT $LN7@R_DrawMask

; 2269 : 		{
; 2270 : 			next = r2->prev;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0007d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00080	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 2271 : 			R_RenderMaskedSegRange(r2->seg, r2->seg->x1, r2->seg->x2);

  00083	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00086	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00089	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0008c	52		 push	 edx
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00090	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00093	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00096	52		 push	 edx
  00097	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0009a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _R_RenderMaskedSegRange
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2272 : 			r2->seg->maskedtexturecol = NULL;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  000a9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ac	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 2273 : 			R_DoneWithNode(r2);

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _R_DoneWithNode
  000bc	83 c4 04	 add	 esp, 4

; 2274 : 			r2 = next;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  000c2	89 45 fc	 mov	 DWORD PTR _r2$[ebp], eax

; 2275 : 		}

  000c5	e9 a0 00 00 00	 jmp	 $LN11@R_DrawMask
$LN7@R_DrawMask:

; 2276 : 		else if (r2->thickseg)

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  000cd	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000d1	74 47		 je	 SHORT $LN9@R_DrawMask

; 2277 : 		{
; 2278 : 			next = r2->prev;

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  000d6	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000d9	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 2279 : 			R_RenderThickSideRange(r2->thickseg, r2->thickseg->x1, r2->thickseg->x2, r2->ffloor);

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  000df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000e2	51		 push	 ecx
  000e3	8b 55 fc	 mov	 edx, DWORD PTR _r2$[ebp]
  000e6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ec	51		 push	 ecx
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _r2$[ebp]
  000f0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000f3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f6	51		 push	 ecx
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _r2$[ebp]
  000fa	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _R_RenderThickSideRange
  00103	83 c4 10	 add	 esp, 16			; 00000010H

; 2280 : 			R_DoneWithNode(r2);

  00106	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _R_DoneWithNode
  0010f	83 c4 04	 add	 esp, 4

; 2281 : 			r2 = next;

  00112	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00115	89 45 fc	 mov	 DWORD PTR _r2$[ebp], eax

; 2282 : 		}

  00118	eb 50		 jmp	 SHORT $LN11@R_DrawMask
$LN9@R_DrawMask:

; 2283 : 		else if (r2->sprite)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0011d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00121	74 47		 je	 SHORT $LN11@R_DrawMask

; 2284 : 		{
; 2285 : 			next = r2->prev;

  00123	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  00126	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00129	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 2286 : 
; 2287 : 			// Tails 08-18-2002
; 2288 : 			if (r2->sprite->precip == true)

  0012c	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0012f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00132	83 79 68 01	 cmp	 DWORD PTR [ecx+104], 1
  00136	75 11		 jne	 SHORT $LN12@R_DrawMask

; 2289 : 				R_DrawPrecipitationSprite(r2->sprite);

  00138	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0013b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 _R_DrawPrecipitationSprite
  00144	83 c4 04	 add	 esp, 4
  00147	eb 0f		 jmp	 SHORT $LN13@R_DrawMask
$LN12@R_DrawMask:

; 2290 : 			else
; 2291 : 				R_DrawSprite(r2->sprite);

  00149	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0014c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0014f	51		 push	 ecx
  00150	e8 00 00 00 00	 call	 _R_DrawSprite
  00155	83 c4 04	 add	 esp, 4
$LN13@R_DrawMask:

; 2292 : 
; 2293 : 			R_DoneWithNode(r2);

  00158	8b 45 fc	 mov	 eax, DWORD PTR _r2$[ebp]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _R_DoneWithNode
  00161	83 c4 04	 add	 esp, 4

; 2294 : 			r2 = next;

  00164	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00167	89 45 fc	 mov	 DWORD PTR _r2$[ebp], eax
$LN11@R_DrawMask:

; 2295 : 		}
; 2296 : 	}

  0016a	e9 aa fe ff ff	 jmp	 $LN2@R_DrawMask
$LN3@R_DrawMask:

; 2297 : 	R_ClearDrawNodes();

  0016f	e8 00 00 00 00	 call	 _R_ClearDrawNodes
  00174	90		 npad	 1

; 2298 : }

  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
_R_DrawMasked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_ClearSprites
_TEXT	SEGMENT
_R_ClearSprites PROC					; COMDAT

; 538  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 539  : 	vissprite_p = vissprites;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _vissprite_p, OFFSET _vissprites

; 540  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_R_ClearSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_InitSprites
_TEXT	SEGMENT
_i$ = -4						; size = 4
_R_InitSprites PROC					; COMDAT

; 490  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 491  : 	size_t i;
; 492  : 
; 493  : 	for (i = 0; i < MAXVIDWIDTH; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@R_InitSpri
$LN2@R_InitSpri:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_InitSpri:
  0001b	81 7d fc 80 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1920 ; 00000780H
  00022	73 10		 jae	 SHORT $LN3@R_InitSpri

; 494  : 	{
; 495  : 		negonearray[i] = -1;

  00024	83 c8 ff	 or	 eax, -1
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002a	66 89 04 4d 00
	00 00 00	 mov	 WORD PTR _negonearray[ecx*2], ax

; 496  : 	}

  00032	eb de		 jmp	 SHORT $LN2@R_InitSpri
$LN3@R_InitSpri:

; 497  : 
; 498  : 	//
; 499  : 	// count the number of sprite names, and allocate sprites table
; 500  : 	//
; 501  : 	numsprites = 0;

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _numsprites, 0

; 502  : 	for (i = 0; i < NUMSPRITES + 1; i++)

  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN7@R_InitSpri
$LN5@R_InitSpri:
  00047	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@R_InitSpri:
  00050	81 7d fc 74 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 372	; 00000174H
  00057	73 27		 jae	 SHORT $LN6@R_InitSpri

; 503  : 		if (sprnames[i][0] != '\0') numsprites++;

  00059	6b 45 fc 05	 imul	 eax, DWORD PTR _i$[ebp], 5
  0005d	b9 01 00 00 00	 mov	 ecx, 1
  00062	6b d1 00	 imul	 edx, ecx, 0
  00065	0f be 84 10 00
	00 00 00	 movsx	 eax, BYTE PTR _sprnames[eax+edx]
  0006d	85 c0		 test	 eax, eax
  0006f	74 0d		 je	 SHORT $LN14@R_InitSpri
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsprites
  00076	83 c0 01	 add	 eax, 1
  00079	a3 00 00 00 00	 mov	 DWORD PTR _numsprites, eax
$LN14@R_InitSpri:
  0007e	eb c7		 jmp	 SHORT $LN5@R_InitSpri
$LN6@R_InitSpri:

; 504  : 
; 505  : 	if (!numsprites)

  00080	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsprites, 0
  00087	75 0d		 jne	 SHORT $LN15@R_InitSpri

; 506  : 		I_Error("R_AddSpriteDefs: no sprites in namelist\n");

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CCFDIMJD@R_AddSpriteDefs?3?5no?5sprites?5in?5@
  0008e	e8 00 00 00 00	 call	 _I_Error
  00093	83 c4 04	 add	 esp, 4
$LN15@R_InitSpri:

; 507  : 
; 508  : 	sprites = Z_Calloc(numsprites * sizeof (*sprites), PU_STATIC, NULL);

  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	6a 01		 push	 1
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsprites
  000a1	c1 e0 03	 shl	 eax, 3
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _Z_CallocAlign
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	a3 00 00 00 00	 mov	 DWORD PTR _sprites, eax

; 509  : 
; 510  : 	// find sprites in each -file added pwad
; 511  : 	for (i = 0; i < numwadfiles; i++)

  000b2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b9	eb 09		 jmp	 SHORT $LN10@R_InitSpri
$LN8@R_InitSpri:
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000be	83 c0 01	 add	 eax, 1
  000c1	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@R_InitSpri:
  000c4	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  000cb	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  000ce	73 0f		 jae	 SHORT $LN9@R_InitSpri

; 512  : 		R_AddSpriteDefs((UINT16)i);

  000d0	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _R_AddSpriteDefs
  000da	83 c4 04	 add	 esp, 4
  000dd	eb dc		 jmp	 SHORT $LN8@R_InitSpri
$LN9@R_InitSpri:

; 513  : 
; 514  : 	//
; 515  : 	// now check for skins
; 516  : 	//
; 517  : 
; 518  : 	// it can be is do before loading config for skin cvar possible value
; 519  : 	R_InitSkins();

  000df	e8 00 00 00 00	 call	 _R_InitSkins
  000e4	90		 npad	 1

; 520  : 	for (i = 0; i < numwadfiles; i++)

  000e5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ec	eb 09		 jmp	 SHORT $LN13@R_InitSpri
$LN11@R_InitSpri:
  000ee	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	83 c0 01	 add	 eax, 1
  000f4	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@R_InitSpri:
  000f7	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _numwadfiles
  000fe	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  00101	73 0f		 jae	 SHORT $LN12@R_InitSpri

; 521  : 		R_AddSkins((UINT16)i);

  00103	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _R_AddSkins
  0010d	83 c4 04	 add	 esp, 4
  00110	eb dc		 jmp	 SHORT $LN11@R_InitSpri
$LN12@R_InitSpri:

; 522  : 
; 523  : 	//
; 524  : 	// check if all sprites have frames
; 525  : 	//
; 526  : 	/*
; 527  : 	for (i = 0; i < numsprites; i++)
; 528  : 		if (sprites[i].numframes < 1)
; 529  : 			CONS_Printf("R_InitSprites: sprite %s has no frames at all\n", sprnames[i]);
; 530  : 	*/
; 531  : }

  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	5b		 pop	 ebx
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
_R_InitSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_AddSprites
_TEXT	SEGMENT
tv147 = -92						; size = 4
tv175 = -92						; size = 4
tv226 = -92						; size = 4
tv255 = -92						; size = 4
_approx_dist$ = -24					; size = 4
_ady$ = -20						; size = 4
_adx$ = -16						; size = 4
_lightnum$ = -12					; size = 4
_precipthing$ = -8					; size = 4
_thing$ = -4						; size = 4
_sec$ = 8						; size = 4
_lightlevel$ = 12					; size = 4
_R_AddSprites PROC					; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1512 : 	mobj_t *thing;
; 1513 : 	precipmobj_t *precipthing; // Tails 08-25-2002
; 1514 : 	INT32 lightnum;
; 1515 : 	fixed_t adx, ady, approx_dist;
; 1516 : 
; 1517 : 	if (rendermode != render_soft)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 05		 je	 SHORT $LN11@R_AddSprit

; 1518 : 		return;

  00012	e9 40 04 00 00	 jmp	 $LN9@R_AddSprit
$LN11@R_AddSprit:

; 1519 : 
; 1520 : 	// BSP is traversed by subsector.
; 1521 : 	// A sector might have been split into several
; 1522 : 	//  subsectors during BSP building.
; 1523 : 	// Thus we check whether its already added.
; 1524 : 	if (sec->validcount == validcount)

  00017	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0001a	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0001d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00023	75 05		 jne	 SHORT $LN12@R_AddSprit

; 1525 : 		return;

  00025	e9 2d 04 00 00	 jmp	 $LN9@R_AddSprit
$LN12@R_AddSprit:

; 1526 : 
; 1527 : 	// Well, now it will be done.
; 1528 : 	sec->validcount = validcount;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00033	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1529 : 
; 1530 : 	if (!sec->numlights)

  00036	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00039	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00040	75 65		 jne	 SHORT $LN18@R_AddSprit

; 1531 : 	{
; 1532 : 		if (sec->heightsec == -1) lightlevel = sec->lightlevel;

  00042	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00045	83 78 68 ff	 cmp	 DWORD PTR [eax+104], -1
  00049	75 0a		 jne	 SHORT $LN14@R_AddSprit
  0004b	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  0004e	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00052	89 4d 0c	 mov	 DWORD PTR _lightlevel$[ebp], ecx
$LN14@R_AddSprit:

; 1533 : 
; 1534 : 		lightnum = (lightlevel >> LIGHTSEGSHIFT);

  00055	8b 45 0c	 mov	 eax, DWORD PTR _lightlevel$[ebp]
  00058	c1 f8 03	 sar	 eax, 3
  0005b	89 45 f4	 mov	 DWORD PTR _lightnum$[ebp], eax

; 1535 : 
; 1536 : 		if (lightnum < 0)

  0005e	83 7d f4 00	 cmp	 DWORD PTR _lightnum$[ebp], 0
  00062	7d 16		 jge	 SHORT $LN15@R_AddSprit

; 1537 : 			spritelights = scalelight[0];

  00064	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  00069	6b c8 00	 imul	 ecx, eax, 0
  0006c	81 c1 00 00 00
	00		 add	 ecx, OFFSET _scalelight
  00072	89 0d 00 00 00
	00		 mov	 DWORD PTR _spritelights, ecx
  00078	eb 2d		 jmp	 SHORT $LN18@R_AddSprit
$LN15@R_AddSprit:

; 1538 : 		else if (lightnum >= LIGHTLEVELS)

  0007a	83 7d f4 20	 cmp	 DWORD PTR _lightnum$[ebp], 32 ; 00000020H
  0007e	7c 16		 jl	 SHORT $LN17@R_AddSprit

; 1539 : 			spritelights = scalelight[LIGHTLEVELS-1];

  00080	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  00085	6b c8 1f	 imul	 ecx, eax, 31
  00088	81 c1 00 00 00
	00		 add	 ecx, OFFSET _scalelight
  0008e	89 0d 00 00 00
	00		 mov	 DWORD PTR _spritelights, ecx
  00094	eb 11		 jmp	 SHORT $LN18@R_AddSprit
$LN17@R_AddSprit:

; 1540 : 		else
; 1541 : 			spritelights = scalelight[lightnum];

  00096	69 45 f4 c0 00
	00 00		 imul	 eax, DWORD PTR _lightnum$[ebp], 192
  0009d	05 00 00 00 00	 add	 eax, OFFSET _scalelight
  000a2	a3 00 00 00 00	 mov	 DWORD PTR _spritelights, eax
$LN18@R_AddSprit:

; 1542 : 	}
; 1543 : 
; 1544 : 	// Handle all things in sector.
; 1545 : 
; 1546 : 	// NiGHTS stages have a draw distance limit because of the
; 1547 : 	// HUGE number of SPRiTES!
; 1548 : 	if (maptol & TOL_NIGHTS && players[displayplayer].mo)

  000a7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  000ae	83 e0 40	 and	 eax, 64			; 00000040H
  000b1	0f 84 8c 01 00
	00		 je	 $LN19@R_AddSprit
  000b7	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  000c1	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  000c8	0f 84 75 01 00
	00		 je	 $LN19@R_AddSprit

; 1549 : 	{
; 1550 : 		for (thing = sec->thinglist; thing; thing = thing->snext)

  000ce	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  000d1	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000d4	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
  000d7	eb 09		 jmp	 SHORT $LN4@R_AddSprit
$LN2@R_AddSprit:
  000d9	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  000dc	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000df	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
$LN4@R_AddSprit:
  000e2	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  000e6	0f 84 55 01 00
	00		 je	 $LN3@R_AddSprit

; 1551 : 		{
; 1552 : 			if (!thing)

  000ec	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  000f0	75 02		 jne	 SHORT $LN21@R_AddSprit

; 1553 : 				continue;

  000f2	eb e5		 jmp	 SHORT $LN2@R_AddSprit
$LN21@R_AddSprit:

; 1554 : 
; 1555 : 			if ((thing->flags2 & MF2_DONTDRAW)==0)

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  000f7	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  000fd	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  00103	0f 85 33 01 00
	00		 jne	 $LN26@R_AddSprit

; 1556 : 			{
; 1557 : 				adx = abs(players[displayplayer].mo->x - thing->x);

  00109	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00113	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00119	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  0011c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0011f	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _abs
  00128	83 c4 04	 add	 esp, 4
  0012b	89 45 f0	 mov	 DWORD PTR _adx$[ebp], eax

; 1558 : 				ady = abs(players[displayplayer].mo->y - thing->y);

  0012e	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00138	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  0013e	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  00141	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00144	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _abs
  0014d	83 c4 04	 add	 esp, 4
  00150	89 45 ec	 mov	 DWORD PTR _ady$[ebp], eax

; 1559 : 
; 1560 : 				// From _GG1_ p.428. Approx. eucledian distance fast.
; 1561 : 				approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  00153	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  00156	3b 45 ec	 cmp	 eax, DWORD PTR _ady$[ebp]
  00159	7d 08		 jge	 SHORT $LN39@R_AddSprit
  0015b	8b 4d f0	 mov	 ecx, DWORD PTR _adx$[ebp]
  0015e	89 4d a4	 mov	 DWORD PTR tv147[ebp], ecx
  00161	eb 06		 jmp	 SHORT $LN40@R_AddSprit
$LN39@R_AddSprit:
  00163	8b 55 ec	 mov	 edx, DWORD PTR _ady$[ebp]
  00166	89 55 a4	 mov	 DWORD PTR tv147[ebp], edx
$LN40@R_AddSprit:
  00169	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  0016c	03 45 ec	 add	 eax, DWORD PTR _ady$[ebp]
  0016f	8b 4d a4	 mov	 ecx, DWORD PTR tv147[ebp]
  00172	d1 f9		 sar	 ecx, 1
  00174	2b c1		 sub	 eax, ecx
  00176	89 45 e8	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 1562 : 
; 1563 : 				if (approx_dist < LIMIT_DRAW_DIST)

  00179	81 7d e8 00 00
	00 08		 cmp	 DWORD PTR _approx_dist$[ebp], 134217728 ; 08000000H
  00180	7d 11		 jge	 SHORT $LN23@R_AddSprit

; 1564 : 					R_ProjectSprite(thing);

  00182	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _R_ProjectSprite
  0018b	83 c4 04	 add	 esp, 4
  0018e	e9 a9 00 00 00	 jmp	 $LN26@R_AddSprit
$LN23@R_AddSprit:

; 1565 : 				else if (splitscreen && players[secondarydisplayplayer].mo)

  00193	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0019a	0f 84 9c 00 00
	00		 je	 $LN26@R_AddSprit
  001a0	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  001aa	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  001b1	0f 84 85 00 00
	00		 je	 $LN26@R_AddSprit

; 1566 : 				{
; 1567 : 					adx = abs(players[secondarydisplayplayer].mo->x - thing->x);

  001b7	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  001c1	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  001c7	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  001ca	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  001cd	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _abs
  001d6	83 c4 04	 add	 esp, 4
  001d9	89 45 f0	 mov	 DWORD PTR _adx$[ebp], eax

; 1568 : 					ady = abs(players[secondarydisplayplayer].mo->y - thing->y);

  001dc	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  001e6	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  001ec	8b 55 fc	 mov	 edx, DWORD PTR _thing$[ebp]
  001ef	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  001f2	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 _abs
  001fb	83 c4 04	 add	 esp, 4
  001fe	89 45 ec	 mov	 DWORD PTR _ady$[ebp], eax

; 1569 : 
; 1570 : 					// From _GG1_ p.428. Approx. eucledian distance fast.
; 1571 : 					approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  00201	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  00204	3b 45 ec	 cmp	 eax, DWORD PTR _ady$[ebp]
  00207	7d 08		 jge	 SHORT $LN41@R_AddSprit
  00209	8b 4d f0	 mov	 ecx, DWORD PTR _adx$[ebp]
  0020c	89 4d a4	 mov	 DWORD PTR tv175[ebp], ecx
  0020f	eb 06		 jmp	 SHORT $LN42@R_AddSprit
$LN41@R_AddSprit:
  00211	8b 55 ec	 mov	 edx, DWORD PTR _ady$[ebp]
  00214	89 55 a4	 mov	 DWORD PTR tv175[ebp], edx
$LN42@R_AddSprit:
  00217	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  0021a	03 45 ec	 add	 eax, DWORD PTR _ady$[ebp]
  0021d	8b 4d a4	 mov	 ecx, DWORD PTR tv175[ebp]
  00220	d1 f9		 sar	 ecx, 1
  00222	2b c1		 sub	 eax, ecx
  00224	89 45 e8	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 1572 : 
; 1573 : 					if (approx_dist < LIMIT_DRAW_DIST)

  00227	81 7d e8 00 00
	00 08		 cmp	 DWORD PTR _approx_dist$[ebp], 134217728 ; 08000000H
  0022e	7d 0c		 jge	 SHORT $LN26@R_AddSprit

; 1574 : 						R_ProjectSprite (thing);

  00230	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00233	50		 push	 eax
  00234	e8 00 00 00 00	 call	 _R_ProjectSprite
  00239	83 c4 04	 add	 esp, 4
$LN26@R_AddSprit:

; 1575 : 				}
; 1576 : 			}
; 1577 : 		}

  0023c	e9 98 fe ff ff	 jmp	 $LN2@R_AddSprit
$LN3@R_AddSprit:

; 1578 : 	}

  00241	eb 76		 jmp	 SHORT $LN6@R_AddSprit
$LN19@R_AddSprit:

; 1579 : 	else
; 1580 : 	{
; 1581 : 		for (thing = sec->thinglist; thing; thing = thing->snext)

  00243	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  00246	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00249	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
  0024c	eb 09		 jmp	 SHORT $LN7@R_AddSprit
$LN5@R_AddSprit:
  0024e	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00251	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00254	89 4d fc	 mov	 DWORD PTR _thing$[ebp], ecx
$LN7@R_AddSprit:
  00257	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  0025b	74 5c		 je	 SHORT $LN6@R_AddSprit

; 1582 : 		{
; 1583 : 			if (!thing)

  0025d	83 7d fc 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00261	75 02		 jne	 SHORT $LN27@R_AddSprit

; 1584 : 				continue;

  00263	eb e9		 jmp	 SHORT $LN5@R_AddSprit
$LN27@R_AddSprit:

; 1585 : 
; 1586 : 			if ((thing->flags2 & MF2_DONTDRAW)==0)

  00265	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00268	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0026e	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  00274	75 0c		 jne	 SHORT $LN28@R_AddSprit

; 1587 : 				R_ProjectSprite(thing);

  00276	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 _R_ProjectSprite
  0027f	83 c4 04	 add	 esp, 4
$LN28@R_AddSprit:

; 1588 : 
; 1589 : 			if (cv_objectplace.value
; 1590 : 			&& !(thing->flags2 & MF2_DONTDRAW))

  00282	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_objectplace+20, 0
  00289	74 21		 je	 SHORT $LN29@R_AddSprit
  0028b	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  0028e	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00294	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  0029a	75 10		 jne	 SHORT $LN29@R_AddSprit

; 1591 : 				objectsdrawn++;

  0029c	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _objectsdrawn
  002a2	66 83 c0 01	 add	 ax, 1
  002a6	66 a3 00 00 00
	00		 mov	 WORD PTR _objectsdrawn, ax
$LN29@R_AddSprit:

; 1592 : 
; 1593 : 			if (!thing->snext)

  002ac	8b 45 fc	 mov	 eax, DWORD PTR _thing$[ebp]
  002af	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  002b3	75 02		 jne	 SHORT $LN30@R_AddSprit

; 1594 : 				break;

  002b5	eb 02		 jmp	 SHORT $LN6@R_AddSprit
$LN30@R_AddSprit:

; 1595 : 		}

  002b7	eb 95		 jmp	 SHORT $LN5@R_AddSprit
$LN6@R_AddSprit:

; 1596 : 	}
; 1597 : 
; 1598 : 	// Special function for precipitation Tails 08-18-2002
; 1599 : 	if (playeringame[displayplayer] && players[displayplayer].mo)

  002b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _displayplayer
  002be	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  002c6	0f 84 8b 01 00
	00		 je	 $LN9@R_AddSprit
  002cc	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  002d6	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  002dd	0f 84 74 01 00
	00		 je	 $LN9@R_AddSprit

; 1600 : 	{
; 1601 : 		for (precipthing = sec->preciplist; precipthing; precipthing = precipthing->snext)

  002e3	8b 45 08	 mov	 eax, DWORD PTR _sec$[ebp]
  002e6	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  002ec	89 4d f8	 mov	 DWORD PTR _precipthing$[ebp], ecx
  002ef	eb 09		 jmp	 SHORT $LN10@R_AddSprit
$LN8@R_AddSprit:
  002f1	8b 45 f8	 mov	 eax, DWORD PTR _precipthing$[ebp]
  002f4	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  002f7	89 4d f8	 mov	 DWORD PTR _precipthing$[ebp], ecx
$LN10@R_AddSprit:
  002fa	83 7d f8 00	 cmp	 DWORD PTR _precipthing$[ebp], 0
  002fe	0f 84 53 01 00
	00		 je	 $LN9@R_AddSprit

; 1602 : 		{
; 1603 : 			if (!precipthing)

  00304	83 7d f8 00	 cmp	 DWORD PTR _precipthing$[ebp], 0
  00308	75 02		 jne	 SHORT $LN32@R_AddSprit

; 1604 : 				continue;

  0030a	eb e5		 jmp	 SHORT $LN8@R_AddSprit
$LN32@R_AddSprit:

; 1605 : 
; 1606 : 			if (precipthing->invisible)

  0030c	8b 45 f8	 mov	 eax, DWORD PTR _precipthing$[ebp]
  0030f	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  00313	74 02		 je	 SHORT $LN33@R_AddSprit

; 1607 : 				continue;

  00315	eb da		 jmp	 SHORT $LN8@R_AddSprit
$LN33@R_AddSprit:

; 1608 : 
; 1609 : 			adx = abs(players[displayplayer].mo->x - precipthing->x);

  00317	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00321	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00327	8b 55 f8	 mov	 edx, DWORD PTR _precipthing$[ebp]
  0032a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0032d	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 _abs
  00336	83 c4 04	 add	 esp, 4
  00339	89 45 f0	 mov	 DWORD PTR _adx$[ebp], eax

; 1610 : 			ady = abs(players[displayplayer].mo->y - precipthing->y);

  0033c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00346	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  0034c	8b 55 f8	 mov	 edx, DWORD PTR _precipthing$[ebp]
  0034f	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00352	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00355	50		 push	 eax
  00356	e8 00 00 00 00	 call	 _abs
  0035b	83 c4 04	 add	 esp, 4
  0035e	89 45 ec	 mov	 DWORD PTR _ady$[ebp], eax

; 1611 : 
; 1612 : 			// From _GG1_ p.428. Approx. eucledian distance fast.
; 1613 : 			approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  00361	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  00364	3b 45 ec	 cmp	 eax, DWORD PTR _ady$[ebp]
  00367	7d 08		 jge	 SHORT $LN43@R_AddSprit
  00369	8b 4d f0	 mov	 ecx, DWORD PTR _adx$[ebp]
  0036c	89 4d a4	 mov	 DWORD PTR tv226[ebp], ecx
  0036f	eb 06		 jmp	 SHORT $LN44@R_AddSprit
$LN43@R_AddSprit:
  00371	8b 55 ec	 mov	 edx, DWORD PTR _ady$[ebp]
  00374	89 55 a4	 mov	 DWORD PTR tv226[ebp], edx
$LN44@R_AddSprit:
  00377	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  0037a	03 45 ec	 add	 eax, DWORD PTR _ady$[ebp]
  0037d	8b 4d a4	 mov	 ecx, DWORD PTR tv226[ebp]
  00380	d1 f9		 sar	 ecx, 1
  00382	2b c1		 sub	 eax, ecx
  00384	89 45 e8	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 1614 : 
; 1615 : 			// Only draw the precipitation oh-so-far from the player.
; 1616 : 			if (approx_dist < (cv_precipdist.value << FRACBITS))

  00387	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_precipdist+20
  0038c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0038f	39 45 e8	 cmp	 DWORD PTR _approx_dist$[ebp], eax
  00392	7d 11		 jge	 SHORT $LN34@R_AddSprit

; 1617 : 				R_ProjectPrecipitationSprite(precipthing);

  00394	8b 45 f8	 mov	 eax, DWORD PTR _precipthing$[ebp]
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 _R_ProjectPrecipitationSprite
  0039d	83 c4 04	 add	 esp, 4
  003a0	e9 ad 00 00 00	 jmp	 $LN37@R_AddSprit
$LN34@R_AddSprit:

; 1618 : 			else if (splitscreen && players[secondarydisplayplayer].mo)

  003a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  003ac	0f 84 a0 00 00
	00		 je	 $LN37@R_AddSprit
  003b2	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003bc	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  003c3	0f 84 89 00 00
	00		 je	 $LN37@R_AddSprit

; 1619 : 			{
; 1620 : 				adx = abs(players[secondarydisplayplayer].mo->x - precipthing->x);

  003c9	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003d3	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  003d9	8b 55 f8	 mov	 edx, DWORD PTR _precipthing$[ebp]
  003dc	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  003df	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  003e2	50		 push	 eax
  003e3	e8 00 00 00 00	 call	 _abs
  003e8	83 c4 04	 add	 esp, 4
  003eb	89 45 f0	 mov	 DWORD PTR _adx$[ebp], eax

; 1621 : 				ady = abs(players[secondarydisplayplayer].mo->y - precipthing->y);

  003ee	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  003f8	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  003fe	8b 55 f8	 mov	 edx, DWORD PTR _precipthing$[ebp]
  00401	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00404	2b 42 14	 sub	 eax, DWORD PTR [edx+20]
  00407	50		 push	 eax
  00408	e8 00 00 00 00	 call	 _abs
  0040d	83 c4 04	 add	 esp, 4
  00410	89 45 ec	 mov	 DWORD PTR _ady$[ebp], eax

; 1622 : 
; 1623 : 				// From _GG1_ p.428. Approx. eucledian distance fast.
; 1624 : 				approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);

  00413	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  00416	3b 45 ec	 cmp	 eax, DWORD PTR _ady$[ebp]
  00419	7d 08		 jge	 SHORT $LN45@R_AddSprit
  0041b	8b 4d f0	 mov	 ecx, DWORD PTR _adx$[ebp]
  0041e	89 4d a4	 mov	 DWORD PTR tv255[ebp], ecx
  00421	eb 06		 jmp	 SHORT $LN46@R_AddSprit
$LN45@R_AddSprit:
  00423	8b 55 ec	 mov	 edx, DWORD PTR _ady$[ebp]
  00426	89 55 a4	 mov	 DWORD PTR tv255[ebp], edx
$LN46@R_AddSprit:
  00429	8b 45 f0	 mov	 eax, DWORD PTR _adx$[ebp]
  0042c	03 45 ec	 add	 eax, DWORD PTR _ady$[ebp]
  0042f	8b 4d a4	 mov	 ecx, DWORD PTR tv255[ebp]
  00432	d1 f9		 sar	 ecx, 1
  00434	2b c1		 sub	 eax, ecx
  00436	89 45 e8	 mov	 DWORD PTR _approx_dist$[ebp], eax

; 1625 : 
; 1626 : 				if (approx_dist < (cv_precipdist.value << FRACBITS))

  00439	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_precipdist+20
  0043e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00441	39 45 e8	 cmp	 DWORD PTR _approx_dist$[ebp], eax
  00444	7d 0c		 jge	 SHORT $LN37@R_AddSprit

; 1627 : 					R_ProjectPrecipitationSprite (precipthing);

  00446	8b 45 f8	 mov	 eax, DWORD PTR _precipthing$[ebp]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 _R_ProjectPrecipitationSprite
  0044f	83 c4 04	 add	 esp, 4
$LN37@R_AddSprit:

; 1628 : 			}
; 1629 : 		}

  00452	e9 9a fe ff ff	 jmp	 $LN8@R_AddSprit
$LN9@R_AddSprit:

; 1630 : 	}
; 1631 : }

  00457	5f		 pop	 edi
  00458	5e		 pop	 esi
  00459	5b		 pop	 ebx
  0045a	8b e5		 mov	 esp, ebp
  0045c	5d		 pop	 ebp
  0045d	c3		 ret	 0
_R_AddSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DelSpriteDefs
_TEXT	SEGMENT
_end$ = -16						; size = 2
_start$ = -12						; size = 2
_delsprites$ = -8					; size = 4
_i$ = -4						; size = 4
_wadnum$ = 8						; size = 2
_R_DelSpriteDefs PROC					; COMDAT

; 432  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 433  : 	size_t i, delsprites = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _delsprites$[ebp], 0

; 434  : 	UINT16 start, end;
; 435  : 
; 436  : 	// find the sprites section in this pwad
; 437  : 	// we need at least the S_END
; 438  : 	// (not really, but for speedup)
; 439  : 
; 440  : 	start = W_CheckNumForNamePwad("S_START", wadnum, 0);

  00010	6a 00		 push	 0
  00012	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_07EBCHADGJ@S_START@
  0001c	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax

; 441  : 	if (start == INT16_MAX)

  00028	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  0002c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00031	75 18		 jne	 SHORT $LN5@R_DelSprit

; 442  : 		start = W_CheckNumForNamePwad("SS_START", wadnum, 0); //deutex compatib.

  00033	6a 00		 push	 0
  00035	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_08IJNDLFBN@SS_START@
  0003f	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax
$LN5@R_DelSprit:

; 443  : 	if (start == INT16_MAX)

  0004b	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  0004f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00054	75 08		 jne	 SHORT $LN6@R_DelSprit

; 444  : 		start = 0; //let say S_START is lump 0

  00056	33 c0		 xor	 eax, eax
  00058	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax
  0005c	eb 0c		 jmp	 SHORT $LN7@R_DelSprit
$LN6@R_DelSprit:

; 445  : 	else
; 446  : 		start++;   // just after S_START

  0005e	66 8b 45 f4	 mov	 ax, WORD PTR _start$[ebp]
  00062	66 83 c0 01	 add	 ax, 1
  00066	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax
$LN7@R_DelSprit:

; 447  : 
; 448  : 	end = W_CheckNumForNamePwad("S_END",wadnum,start);

  0006a	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  0006e	50		 push	 eax
  0006f	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00073	51		 push	 ecx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_05DMLPPONL@S_END@
  00079	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	66 89 45 f0	 mov	 WORD PTR _end$[ebp], ax

; 449  : 	if (end == INT16_MAX)

  00085	0f b7 45 f0	 movzx	 eax, WORD PTR _end$[ebp]
  00089	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0008e	75 1b		 jne	 SHORT $LN8@R_DelSprit

; 450  : 		end = W_CheckNumForNamePwad("SS_END",wadnum,start);     //deutex compatib.

  00090	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  00094	50		 push	 eax
  00095	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00099	51		 push	 ecx
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_06CCMHDCM@SS_END@
  0009f	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a7	66 89 45 f0	 mov	 WORD PTR _end$[ebp], ax
$LN8@R_DelSprit:

; 451  : 	if (end == INT16_MAX)

  000ab	0f b7 45 f0	 movzx	 eax, WORD PTR _end$[ebp]
  000af	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000b4	75 20		 jne	 SHORT $LN9@R_DelSprit

; 452  : 	{
; 453  : 		if (devparm)

  000b6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  000bd	74 12		 je	 SHORT $LN10@R_DelSprit

; 454  : 			CONS_Printf("no sprites in pwad %d\n", wadnum);

  000bf	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  000c3	50		 push	 eax
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ENOHDNK@no?5sprites?5in?5pwad?5?$CFd?6@
  000c9	e8 00 00 00 00	 call	 _CONS_Printf
  000ce	83 c4 08	 add	 esp, 8
$LN10@R_DelSprit:

; 455  : 		return;

  000d1	e9 a5 00 00 00	 jmp	 $LN1@R_DelSprit
$LN9@R_DelSprit:

; 456  : 		//I_Error("R_DelSpriteDefs: S_END, or SS_END missing for sprites "
; 457  : 		//         "in pwad %d\n",wadnum);
; 458  : 	}
; 459  : 
; 460  : 	//
; 461  : 	// scan through lumps, for each sprite, find all the sprite frames
; 462  : 	//
; 463  : 	for (i = 0; i < numsprites; i++)

  000d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000dd	eb 09		 jmp	 SHORT $LN4@R_DelSprit
$LN2@R_DelSprit:
  000df	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_DelSprit:
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000eb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsprites
  000f1	73 69		 jae	 SHORT $LN3@R_DelSprit

; 464  : 	{
; 465  : 		spritename = sprnames[i];

  000f3	6b 45 fc 05	 imul	 eax, DWORD PTR _i$[ebp], 5
  000f7	05 00 00 00 00	 add	 eax, OFFSET _sprnames
  000fc	a3 00 00 00 00	 mov	 DWORD PTR _spritename, eax

; 466  : 
; 467  : 		if (R_DelSingleSpriteDef(spritename, &sprites[i], wadnum, start, end))

  00101	0f b7 45 f0	 movzx	 eax, WORD PTR _end$[ebp]
  00105	50		 push	 eax
  00106	0f b7 4d f4	 movzx	 ecx, WORD PTR _start$[ebp]
  0010a	51		 push	 ecx
  0010b	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  0010f	52		 push	 edx
  00110	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sprites
  00119	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0011c	52		 push	 edx
  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR _spritename
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _R_DelSingleSpriteDef
  00128	83 c4 14	 add	 esp, 20			; 00000014H
  0012b	85 c0		 test	 eax, eax
  0012d	74 2b		 je	 SHORT $LN12@R_DelSprit

; 468  : 		{
; 469  : 			// if a new sprite was removed (not just replaced)
; 470  : 			delsprites++;

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _delsprites$[ebp]
  00132	83 c0 01	 add	 eax, 1
  00135	89 45 f8	 mov	 DWORD PTR _delsprites$[ebp], eax

; 471  : 			if (devparm)

  00138	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  0013f	74 19		 je	 SHORT $LN12@R_DelSprit

; 472  : 				I_OutputMsg("sprite %s set in pwad %d\n", spritename, wadnum);//Fab

  00141	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00145	50		 push	 eax
  00146	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritename
  0014c	51		 push	 ecx
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JAKAEHGP@sprite?5?$CFs?5set?5in?5pwad?5?$CFd?6@
  00152	e8 00 00 00 00	 call	 _I_OutputMsg
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@R_DelSprit:

; 473  : 		}
; 474  : 	}

  0015a	eb 83		 jmp	 SHORT $LN2@R_DelSprit
$LN3@R_DelSprit:

; 475  : 
; 476  : 	CONS_Printf("%"PRIdS" sprites removed from file %s\n", delsprites, wadfiles[wadnum]->filename);

  0015c	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00160	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00167	8b 11		 mov	 edx, DWORD PTR [ecx]
  00169	52		 push	 edx
  0016a	8b 45 f8	 mov	 eax, DWORD PTR _delsprites$[ebp]
  0016d	50		 push	 eax
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PFMCHJKE@?$CFIu?5sprites?5removed?5from?5file?5?$CF@
  00173	e8 00 00 00 00	 call	 _CONS_Printf
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@R_DelSprit:

; 477  : }

  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
_R_DelSpriteDefs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_AddSpriteDefs
_TEXT	SEGMENT
_end$ = -16						; size = 2
_start$ = -12						; size = 2
_addsprites$ = -8					; size = 4
_i$ = -4						; size = 4
_wadnum$ = 8						; size = 2
_R_AddSpriteDefs PROC					; COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 381  : 	size_t i, addsprites = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _addsprites$[ebp], 0

; 382  : 	UINT16 start, end;
; 383  : 
; 384  : 	// find the sprites section in this pwad
; 385  : 	// we need at least the S_END
; 386  : 	// (not really, but for speedup)
; 387  : 
; 388  : 	start = W_CheckNumForNamePwad("S_START", wadnum, 0);

  00010	6a 00		 push	 0
  00012	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_07EBCHADGJ@S_START@
  0001c	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax

; 389  : 	if (start == INT16_MAX)

  00028	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  0002c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00031	75 18		 jne	 SHORT $LN5@R_AddSprit

; 390  : 		start = W_CheckNumForNamePwad("SS_START", wadnum, 0); //deutex compatib.

  00033	6a 00		 push	 0
  00035	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_08IJNDLFBN@SS_START@
  0003f	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax
$LN5@R_AddSprit:

; 391  : 	if (start == INT16_MAX)

  0004b	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  0004f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00054	75 08		 jne	 SHORT $LN6@R_AddSprit

; 392  : 		start = 0; //let say S_START is lump 0

  00056	33 c0		 xor	 eax, eax
  00058	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax
  0005c	eb 0c		 jmp	 SHORT $LN7@R_AddSprit
$LN6@R_AddSprit:

; 393  : 	else
; 394  : 		start++;   // just after S_START

  0005e	66 8b 45 f4	 mov	 ax, WORD PTR _start$[ebp]
  00062	66 83 c0 01	 add	 ax, 1
  00066	66 89 45 f4	 mov	 WORD PTR _start$[ebp], ax
$LN7@R_AddSprit:

; 395  : 
; 396  : 	end = W_CheckNumForNamePwad("S_END",wadnum,start);

  0006a	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  0006e	50		 push	 eax
  0006f	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00073	51		 push	 ecx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_05DMLPPONL@S_END@
  00079	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	66 89 45 f0	 mov	 WORD PTR _end$[ebp], ax

; 397  : 	if (end == INT16_MAX)

  00085	0f b7 45 f0	 movzx	 eax, WORD PTR _end$[ebp]
  00089	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0008e	75 1b		 jne	 SHORT $LN8@R_AddSprit

; 398  : 		end = W_CheckNumForNamePwad("SS_END",wadnum,start);     //deutex compatib.

  00090	0f b7 45 f4	 movzx	 eax, WORD PTR _start$[ebp]
  00094	50		 push	 eax
  00095	0f b7 4d 08	 movzx	 ecx, WORD PTR _wadnum$[ebp]
  00099	51		 push	 ecx
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_06CCMHDCM@SS_END@
  0009f	e8 00 00 00 00	 call	 _W_CheckNumForNamePwad
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a7	66 89 45 f0	 mov	 WORD PTR _end$[ebp], ax
$LN8@R_AddSprit:

; 399  : 	if (end == INT16_MAX)

  000ab	0f b7 45 f0	 movzx	 eax, WORD PTR _end$[ebp]
  000af	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000b4	75 20		 jne	 SHORT $LN9@R_AddSprit

; 400  : 	{
; 401  : 		if (devparm)

  000b6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  000bd	74 12		 je	 SHORT $LN10@R_AddSprit

; 402  : 			CONS_Printf("no sprites in pwad %d\n", wadnum);

  000bf	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  000c3	50		 push	 eax
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ENOHDNK@no?5sprites?5in?5pwad?5?$CFd?6@
  000c9	e8 00 00 00 00	 call	 _CONS_Printf
  000ce	83 c4 08	 add	 esp, 8
$LN10@R_AddSprit:

; 403  : 		return;

  000d1	e9 c1 00 00 00	 jmp	 $LN1@R_AddSprit
$LN9@R_AddSprit:

; 404  : 		//I_Error("R_AddSpriteDefs: S_END, or SS_END missing for sprites "
; 405  : 		//         "in pwad %d\n",wadnum);
; 406  : 	}
; 407  : 
; 408  : 	//
; 409  : 	// scan through lumps, for each sprite, find all the sprite frames
; 410  : 	//
; 411  : 	for (i = 0; i < numsprites; i++)

  000d6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000dd	eb 09		 jmp	 SHORT $LN4@R_AddSprit
$LN2@R_AddSprit:
  000df	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@R_AddSprit:
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000eb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numsprites
  000f1	0f 83 81 00 00
	00		 jae	 $LN3@R_AddSprit

; 412  : 	{
; 413  : 		spritename = sprnames[i];

  000f7	6b 45 fc 05	 imul	 eax, DWORD PTR _i$[ebp], 5
  000fb	05 00 00 00 00	 add	 eax, OFFSET _sprnames
  00100	a3 00 00 00 00	 mov	 DWORD PTR _spritename, eax

; 414  : 
; 415  : 		if (R_AddSingleSpriteDef(spritename, &sprites[i], wadnum, start, end))

  00105	0f b7 45 f0	 movzx	 eax, WORD PTR _end$[ebp]
  00109	50		 push	 eax
  0010a	0f b7 4d f4	 movzx	 ecx, WORD PTR _start$[ebp]
  0010e	51		 push	 ecx
  0010f	0f b7 55 08	 movzx	 edx, WORD PTR _wadnum$[ebp]
  00113	52		 push	 edx
  00114	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sprites
  0011d	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00120	52		 push	 edx
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _spritename
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _R_AddSingleSpriteDef
  0012c	83 c4 14	 add	 esp, 20			; 00000014H
  0012f	85 c0		 test	 eax, eax
  00131	74 40		 je	 SHORT $LN13@R_AddSprit

; 416  : 		{
; 417  : #ifdef HWRENDER
; 418  : 			if (rendermode == render_opengl)

  00133	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _rendermode, 2
  0013a	75 0c		 jne	 SHORT $LN12@R_AddSprit

; 419  : 				HWR_AddSpriteMD2(i);

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _HWR_AddSpriteMD2
  00145	83 c4 04	 add	 esp, 4
$LN12@R_AddSprit:

; 420  : #endif
; 421  : 			// if a new sprite was added (not just replaced)
; 422  : 			addsprites++;

  00148	8b 45 f8	 mov	 eax, DWORD PTR _addsprites$[ebp]
  0014b	83 c0 01	 add	 eax, 1
  0014e	89 45 f8	 mov	 DWORD PTR _addsprites$[ebp], eax

; 423  : 			if (devparm)

  00151	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _devparm, 0
  00158	74 19		 je	 SHORT $LN13@R_AddSprit

; 424  : 				I_OutputMsg("sprite %s set in pwad %d\n", spritename, wadnum);//Fab

  0015a	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  0015e	50		 push	 eax
  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _spritename
  00165	51		 push	 ecx
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JAKAEHGP@sprite?5?$CFs?5set?5in?5pwad?5?$CFd?6@
  0016b	e8 00 00 00 00	 call	 _I_OutputMsg
  00170	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@R_AddSprit:

; 425  : 		}
; 426  : 	}

  00173	e9 67 ff ff ff	 jmp	 $LN2@R_AddSprit
$LN3@R_AddSprit:

; 427  : 
; 428  : 	CONS_Printf("%"PRIdS" sprites added from file %s\n", addsprites, wadfiles[wadnum]->filename);

  00178	0f b7 45 08	 movzx	 eax, WORD PTR _wadnum$[ebp]
  0017c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _wadfiles[eax*4]
  00183	8b 11		 mov	 edx, DWORD PTR [ecx]
  00185	52		 push	 edx
  00186	8b 45 f8	 mov	 eax, DWORD PTR _addsprites$[ebp]
  00189	50		 push	 eax
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DDMKBGII@?$CFIu?5sprites?5added?5from?5file?5?$CFs?6@
  0018f	e8 00 00 00 00	 call	 _CONS_Printf
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@R_AddSprit:

; 429  : }

  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5b		 pop	 ebx
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
_R_AddSpriteDefs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_SortVisSprites
_TEXT	SEGMENT
_bestscale$ = -132					; size = 4
_unsorted$ = -128					; size = 112
_best$ = -16						; size = 4
_ds$ = -12						; size = 4
_count$ = -8						; size = 4
_i$ = -4						; size = 4
_R_SortVisSprites PROC					; COMDAT

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1640 : 	size_t       i, count;
; 1641 : 	vissprite_t *ds;
; 1642 : 	vissprite_t *best = NULL;

  0000c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _best$[ebp], 0

; 1643 : 	vissprite_t  unsorted;
; 1644 : 	fixed_t      bestscale;
; 1645 : 
; 1646 : 	count = vissprite_p - vissprites;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _vissprite_p
  00018	2d 00 00 00 00	 sub	 eax, OFFSET _vissprites
  0001d	99		 cdq
  0001e	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00023	f7 f9		 idiv	 ecx
  00025	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 1647 : 
; 1648 : 	unsorted.next = unsorted.prev = &unsorted;

  00028	8d 45 80	 lea	 eax, DWORD PTR _unsorted$[ebp]
  0002b	89 45 80	 mov	 DWORD PTR _unsorted$[ebp], eax
  0002e	8b 4d 80	 mov	 ecx, DWORD PTR _unsorted$[ebp]
  00031	89 4d 84	 mov	 DWORD PTR _unsorted$[ebp+4], ecx

; 1649 : 
; 1650 : 	if (!count)

  00034	83 7d f8 00	 cmp	 DWORD PTR _count$[ebp], 0
  00038	75 05		 jne	 SHORT $LN11@R_SortVisS

; 1651 : 		return;

  0003a	e9 2d 01 00 00	 jmp	 $LN6@R_SortVisS
$LN11@R_SortVisS:

; 1652 : 
; 1653 : 	for (ds = vissprites; ds < vissprite_p; ds++)

  0003f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ds$[ebp], OFFSET _vissprites
  00046	eb 09		 jmp	 SHORT $LN4@R_SortVisS
$LN2@R_SortVisS:
  00048	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0004b	83 c0 70	 add	 eax, 112		; 00000070H
  0004e	89 45 f4	 mov	 DWORD PTR _ds$[ebp], eax
$LN4@R_SortVisS:
  00051	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00054	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _vissprite_p
  0005a	73 19		 jae	 SHORT $LN3@R_SortVisS

; 1654 : 	{
; 1655 : 		ds->next = ds+1;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0005f	83 c0 70	 add	 eax, 112		; 00000070H
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _ds$[ebp]
  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1656 : 		ds->prev = ds-1;

  00068	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0006b	83 e8 70	 sub	 eax, 112		; 00000070H
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _ds$[ebp]
  00071	89 01		 mov	 DWORD PTR [ecx], eax

; 1657 : 	}

  00073	eb d3		 jmp	 SHORT $LN2@R_SortVisS
$LN3@R_SortVisS:

; 1658 : 
; 1659 : 	vissprites[0].prev = &unsorted;

  00075	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0007a	6b c8 00	 imul	 ecx, eax, 0
  0007d	8d 55 80	 lea	 edx, DWORD PTR _unsorted$[ebp]
  00080	89 91 00 00 00
	00		 mov	 DWORD PTR _vissprites[ecx], edx

; 1660 : 	unsorted.next = &vissprites[0];

  00086	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0008b	6b c8 00	 imul	 ecx, eax, 0
  0008e	81 c1 00 00 00
	00		 add	 ecx, OFFSET _vissprites
  00094	89 4d 84	 mov	 DWORD PTR _unsorted$[ebp+4], ecx

; 1661 : 	(vissprite_p-1)->next = &unsorted;

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR _vissprite_p
  0009c	8d 4d 80	 lea	 ecx, DWORD PTR _unsorted$[ebp]
  0009f	89 48 94	 mov	 DWORD PTR [eax-108], ecx

; 1662 : 	unsorted.prev = vissprite_p-1;

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _vissprite_p
  000a7	83 e8 70	 sub	 eax, 112		; 00000070H
  000aa	89 45 80	 mov	 DWORD PTR _unsorted$[ebp], eax

; 1663 : 
; 1664 : 	// pull the vissprites out by scale
; 1665 : 	vsprsortedhead.next = vsprsortedhead.prev = &vsprsortedhead;

  000ad	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _vsprsortedhead, OFFSET _vsprsortedhead
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _vsprsortedhead
  000bc	a3 04 00 00 00	 mov	 DWORD PTR _vsprsortedhead+4, eax

; 1666 : 	for (i = 0; i < count; i++)

  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c8	eb 09		 jmp	 SHORT $LN7@R_SortVisS
$LN5@R_SortVisS:
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@R_SortVisS:
  000d3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d6	3b 45 f8	 cmp	 eax, DWORD PTR _count$[ebp]
  000d9	0f 83 8d 00 00
	00		 jae	 $LN6@R_SortVisS

; 1667 : 	{
; 1668 : 		bestscale = INT32_MAX;

  000df	c7 85 7c ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR _bestscale$[ebp], 2147483647 ; 7fffffffH

; 1669 : 		for (ds = unsorted.next; ds != &unsorted; ds = ds->next)

  000e9	8b 45 84	 mov	 eax, DWORD PTR _unsorted$[ebp+4]
  000ec	89 45 f4	 mov	 DWORD PTR _ds$[ebp], eax
  000ef	eb 09		 jmp	 SHORT $LN10@R_SortVisS
$LN8@R_SortVisS:
  000f1	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  000f4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f7	89 4d f4	 mov	 DWORD PTR _ds$[ebp], ecx
$LN10@R_SortVisS:
  000fa	8d 45 80	 lea	 eax, DWORD PTR _unsorted$[ebp]
  000fd	39 45 f4	 cmp	 DWORD PTR _ds$[ebp], eax
  00100	74 22		 je	 SHORT $LN9@R_SortVisS

; 1670 : 		{
; 1671 : 			if (ds->scale < bestscale)

  00102	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00105	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00108	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _bestscale$[ebp]
  0010e	7d 12		 jge	 SHORT $LN12@R_SortVisS

; 1672 : 			{
; 1673 : 				bestscale = ds->scale;

  00110	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  00113	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00116	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _bestscale$[ebp], ecx

; 1674 : 				best = ds;

  0011c	8b 45 f4	 mov	 eax, DWORD PTR _ds$[ebp]
  0011f	89 45 f0	 mov	 DWORD PTR _best$[ebp], eax
$LN12@R_SortVisS:

; 1675 : 			}
; 1676 : 		}

  00122	eb cd		 jmp	 SHORT $LN8@R_SortVisS
$LN9@R_SortVisS:

; 1677 : 		best->next->prev = best->prev;

  00124	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00127	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012a	8b 55 f0	 mov	 edx, DWORD PTR _best$[ebp]
  0012d	8b 02		 mov	 eax, DWORD PTR [edx]
  0012f	89 01		 mov	 DWORD PTR [ecx], eax

; 1678 : 		best->prev->next = best->next;

  00131	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00134	8b 08		 mov	 ecx, DWORD PTR [eax]
  00136	8b 55 f0	 mov	 edx, DWORD PTR _best$[ebp]
  00139	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0013c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1679 : 		best->next = &vsprsortedhead;

  0013f	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00142	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _vsprsortedhead

; 1680 : 		best->prev = vsprsortedhead.prev;

  00149	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  0014c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _vsprsortedhead
  00152	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 : 		vsprsortedhead.prev->next = best;

  00154	a1 00 00 00 00	 mov	 eax, DWORD PTR _vsprsortedhead
  00159	8b 4d f0	 mov	 ecx, DWORD PTR _best$[ebp]
  0015c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1682 : 		vsprsortedhead.prev = best;

  0015f	8b 45 f0	 mov	 eax, DWORD PTR _best$[ebp]
  00162	a3 00 00 00 00	 mov	 DWORD PTR _vsprsortedhead, eax

; 1683 : 	}

  00167	e9 5e ff ff ff	 jmp	 $LN5@R_SortVisS
$LN6@R_SortVisS:

; 1684 : }

  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	5b		 pop	 ebx
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
_R_SortVisSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\r_things.c
;	COMDAT _R_DrawMaskedColumn
_TEXT	SEGMENT
tv80 = -80						; size = 4
_basetexturemid$ = -12					; size = 4
_bottomscreen$ = -8					; size = 4
_topscreen$ = -4					; size = 4
_column$ = 8						; size = 4
_R_DrawMaskedColumn PROC				; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 570  : 	INT32 topscreen;
; 571  : 	INT32 bottomscreen;
; 572  : 	fixed_t basetexturemid;
; 573  : 
; 574  : 	basetexturemid = dc_texturemid;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_texturemid
  0000e	89 45 f4	 mov	 DWORD PTR _basetexturemid$[ebp], eax
$LN2@R_DrawMask:

; 575  : 
; 576  : 	for (; column->topdelta != 0xff ;)

  00011	8b 45 08	 mov	 eax, DWORD PTR _column$[ebp]
  00014	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00017	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0001d	0f 84 32 02 00
	00		 je	 $LN3@R_DrawMask

; 577  : 	{
; 578  : 		// calculate unclipped screen coordinates
; 579  : 		// for post
; 580  : 		topscreen = sprtopscreen + spryscale*column->topdelta;

  00023	8b 45 08	 mov	 eax, DWORD PTR _column$[ebp]
  00026	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00029	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _spryscale
  00030	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _sprtopscreen
  00036	89 4d fc	 mov	 DWORD PTR _topscreen$[ebp], ecx

; 581  : 		bottomscreen = sprbotscreen == INT32_MAX ? topscreen + spryscale*column->length

  00039	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _sprbotscreen, 2147483647 ; 7fffffffH
  00043	75 16		 jne	 SHORT $LN19@R_DrawMask
  00045	8b 45 08	 mov	 eax, DWORD PTR _column$[ebp]
  00048	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0004c	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _spryscale
  00053	03 4d fc	 add	 ecx, DWORD PTR _topscreen$[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv80[ebp], ecx
  00059	eb 17		 jmp	 SHORT $LN20@R_DrawMask
$LN19@R_DrawMask:
  0005b	8b 55 08	 mov	 edx, DWORD PTR _column$[ebp]
  0005e	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00062	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _spryscale
  00069	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sprbotscreen
  0006f	89 45 b0	 mov	 DWORD PTR tv80[ebp], eax
$LN20@R_DrawMask:
  00072	8b 4d b0	 mov	 ecx, DWORD PTR tv80[ebp]
  00075	89 4d f8	 mov	 DWORD PTR _bottomscreen$[ebp], ecx

; 582  : 		                                      : sprbotscreen + spryscale*column->length;
; 583  : 
; 584  : 		dc_yl = (topscreen+FRACUNIT-1)>>FRACBITS;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _topscreen$[ebp]
  0007b	05 ff ff 00 00	 add	 eax, 65535		; 0000ffffH
  00080	c1 f8 10	 sar	 eax, 16			; 00000010H
  00083	a3 00 00 00 00	 mov	 DWORD PTR _dc_yl, eax

; 585  : 		dc_yh = (bottomscreen-1)>>FRACBITS;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _bottomscreen$[ebp]
  0008b	83 e8 01	 sub	 eax, 1
  0008e	c1 f8 10	 sar	 eax, 16			; 00000010H
  00091	a3 00 00 00 00	 mov	 DWORD PTR _dc_yh, eax

; 586  : 
; 587  : 		if (windowtop != INT32_MAX && windowbottom != INT32_MAX)

  00096	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _windowtop, 2147483647 ; 7fffffffH
  000a0	74 42		 je	 SHORT $LN7@R_DrawMask
  000a2	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _windowbottom, 2147483647 ; 7fffffffH
  000ac	74 36		 je	 SHORT $LN7@R_DrawMask

; 588  : 		{
; 589  : 			if (windowtop > topscreen)

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowtop
  000b3	3b 45 fc	 cmp	 eax, DWORD PTR _topscreen$[ebp]
  000b6	7e 12		 jle	 SHORT $LN6@R_DrawMask

; 590  : 				dc_yl = (windowtop + FRACUNIT - 1)>>FRACBITS;

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowtop
  000bd	05 ff ff 00 00	 add	 eax, 65535		; 0000ffffH
  000c2	c1 f8 10	 sar	 eax, 16			; 00000010H
  000c5	a3 00 00 00 00	 mov	 DWORD PTR _dc_yl, eax
$LN6@R_DrawMask:

; 591  : 			if (windowbottom < bottomscreen)

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowbottom
  000cf	3b 45 f8	 cmp	 eax, DWORD PTR _bottomscreen$[ebp]
  000d2	7d 10		 jge	 SHORT $LN7@R_DrawMask

; 592  : 				dc_yh = (windowbottom - 1)>>FRACBITS;

  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowbottom
  000d9	83 e8 01	 sub	 eax, 1
  000dc	c1 f8 10	 sar	 eax, 16			; 00000010H
  000df	a3 00 00 00 00	 mov	 DWORD PTR _dc_yh, eax
$LN7@R_DrawMask:

; 593  : 		}
; 594  : 
; 595  : 		if (dc_yh >= mfloorclip[dc_x])

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mfloorclip
  000ef	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  000f3	39 15 00 00 00
	00		 cmp	 DWORD PTR _dc_yh, edx
  000f9	7c 18		 jl	 SHORT $LN8@R_DrawMask

; 596  : 			dc_yh = mfloorclip[dc_x]-1;

  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mfloorclip
  00106	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  0010a	83 ea 01	 sub	 edx, 1
  0010d	89 15 00 00 00
	00		 mov	 DWORD PTR _dc_yh, edx
$LN8@R_DrawMask:

; 597  : 		if (dc_yl <= mceilingclip[dc_x])

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mceilingclip
  0011e	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00122	39 15 00 00 00
	00		 cmp	 DWORD PTR _dc_yl, edx
  00128	7f 18		 jg	 SHORT $LN9@R_DrawMask

; 598  : 			dc_yl = mceilingclip[dc_x]+1;

  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_x
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mceilingclip
  00135	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00139	83 c2 01	 add	 edx, 1
  0013c	89 15 00 00 00
	00		 mov	 DWORD PTR _dc_yl, edx
$LN9@R_DrawMask:

; 599  : 		if (dc_yl < 0)

  00142	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dc_yl, 0
  00149	7d 0a		 jge	 SHORT $LN10@R_DrawMask

; 600  : 			dc_yl = 0;

  0014b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dc_yl, 0
$LN10@R_DrawMask:

; 601  : 		if (dc_yh >= vid.height)

  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yh
  0015a	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  00160	7c 0d		 jl	 SHORT $LN11@R_DrawMask

; 602  : 			dc_yh = vid.height - 1;

  00162	a1 10 00 00 00	 mov	 eax, DWORD PTR _vid+16
  00167	83 e8 01	 sub	 eax, 1
  0016a	a3 00 00 00 00	 mov	 DWORD PTR _dc_yh, eax
$LN11@R_DrawMask:

; 603  : 
; 604  : 		if (dc_yl <= dc_yh && dc_yl < vid.height && dc_yh > 0)

  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00174	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _dc_yh
  0017a	0f 8f bf 00 00
	00		 jg	 $LN17@R_DrawMask
  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  00185	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR _vid+16
  0018b	0f 8d ae 00 00
	00		 jge	 $LN17@R_DrawMask
  00191	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dc_yh, 0
  00198	0f 8e a1 00 00
	00		 jle	 $LN17@R_DrawMask

; 605  : 		{
; 606  : 			dc_source = (UINT8 *)column + 3;

  0019e	8b 45 08	 mov	 eax, DWORD PTR _column$[ebp]
  001a1	83 c0 03	 add	 eax, 3
  001a4	a3 00 00 00 00	 mov	 DWORD PTR _dc_source, eax

; 607  : 			dc_texturemid = basetexturemid - (column->topdelta<<FRACBITS);

  001a9	8b 45 08	 mov	 eax, DWORD PTR _column$[ebp]
  001ac	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001af	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001b2	8b 55 f4	 mov	 edx, DWORD PTR _basetexturemid$[ebp]
  001b5	2b d1		 sub	 edx, ecx
  001b7	89 15 00 00 00
	00		 mov	 DWORD PTR _dc_texturemid, edx

; 608  : 
; 609  : 			// Drawn by R_DrawColumn.
; 610  : 			// This stuff is a likely cause of the splitscreen water crash bug.
; 611  : 			// FIXTHIS: Figure out what "something more proper" is and do it.
; 612  : 			// quick fix... something more proper should be done!!!
; 613  : 			if (ylookup[dc_yl])

  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _dc_yl
  001c2	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _ylookup[eax*4], 0
  001ca	74 09		 je	 SHORT $LN13@R_DrawMask

; 614  : 				colfunc();

  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR _colfunc
  001d2	90		 npad	 1
  001d3	eb 6a		 jmp	 SHORT $LN17@R_DrawMask
$LN13@R_DrawMask:

; 615  : 			else if (colfunc == R_DrawColumn_8
; 616  : #ifdef USEASM
; 617  : 			|| colfunc == R_DrawColumn_8_ASM || colfunc == R_DrawColumn_8_Pentium
; 618  : 			|| colfunc == R_DrawColumn_8_NOMMX || colfunc == R_DrawColumn_8_K6_MMX

  001d5	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _colfunc, OFFSET _R_DrawColumn_8
  001df	74 30		 je	 SHORT $LN16@R_DrawMask
  001e1	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _colfunc, OFFSET _R_DrawColumn_8_ASM
  001eb	74 24		 je	 SHORT $LN16@R_DrawMask
  001ed	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _colfunc, OFFSET _R_DrawColumn_8_Pentium
  001f7	74 18		 je	 SHORT $LN16@R_DrawMask
  001f9	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _colfunc, OFFSET _R_DrawColumn_8_NOMMX
  00203	74 0c		 je	 SHORT $LN16@R_DrawMask
  00205	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _colfunc, OFFSET _R_DrawColumn_8_K6_MMX
  0020f	75 2e		 jne	 SHORT $LN17@R_DrawMask
$LN16@R_DrawMask:

; 619  : #endif
; 620  : 			)
; 621  : 			{
; 622  : 				static INT32 first = 1;
; 623  : 				if (first)

  00211	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?first@?6??R_DrawMaskedColumn@@9@9, 0
  00218	74 25		 je	 SHORT $LN17@R_DrawMask

; 624  : 				{
; 625  : 					CONS_Printf("WARNING: avoiding a crash in %s %d\n", __FILE__, __LINE__);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??R_DrawMaskedColumn@@9@9
  0021f	83 c0 38	 add	 eax, 56			; 00000038H
  00222	50		 push	 eax
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@MAHMJHDH@C?3?2Users?2RafaTheFox?2Desktop?2SRB@
  00228	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LBNFAKMD@WARNING?3?5avoiding?5a?5crash?5in?5?$CFs@
  0022d	e8 00 00 00 00	 call	 _CONS_Printf
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH

; 626  : 					first = 0;

  00235	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?first@?6??R_DrawMaskedColumn@@9@9, 0
$LN17@R_DrawMask:

; 627  : 				}
; 628  : 			}
; 629  : 		}
; 630  : 		column = (column_t *)((UINT8 *)column + column->length + 4);

  0023f	8b 45 08	 mov	 eax, DWORD PTR _column$[ebp]
  00242	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00246	8b 55 08	 mov	 edx, DWORD PTR _column$[ebp]
  00249	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0024d	89 45 08	 mov	 DWORD PTR _column$[ebp], eax

; 631  : 	}

  00250	e9 bc fd ff ff	 jmp	 $LN2@R_DrawMask
$LN3@R_DrawMask:

; 632  : 
; 633  : 	dc_texturemid = basetexturemid;

  00255	8b 45 f4	 mov	 eax, DWORD PTR _basetexturemid$[ebp]
  00258	a3 00 00 00 00	 mov	 DWORD PTR _dc_texturemid, eax

; 634  : }

  0025d	5f		 pop	 edi
  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_R_DrawMaskedColumn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 __vsnprintf
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1952 :         __crt_va_end(_ArgList);

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1953 :         return _Result;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1954 :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1411 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1413 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
