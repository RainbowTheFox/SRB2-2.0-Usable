; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\y_inter.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	__snprintf
PUBLIC	_Y_IntermissionDrawer
PUBLIC	_Y_Ticker
PUBLIC	_Y_StartIntermission
PUBLIC	_Y_EndIntermission
PUBLIC	_Y_EndGame
PUBLIC	??_C@_0BH@MACILDBE@GOT?5TIME?5BONUS?5EMBLEM?$CB@ ; `string'
PUBLIC	??_C@_0BK@MPBHKKPP@GOT?5PERFECT?5BONUS?5EMBLEM?$CB@ ; `string'
PUBLIC	??_C@_04OHBONDIN@TIME@				; `string'
PUBLIC	??_C@_05PKDFAPGJ@SCORE@				; `string'
PUBLIC	??_C@_01IPJKGB@?$CD@				; `string'
PUBLIC	??_C@_04IPKHEEB@NAME@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi@				; `string'
PUBLIC	??_C@_0N@CIBLIMGJ@?$CFi?3?$CF02i?4?$CF02i@	; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_07GJAEEPGE@TIME?5O?4@			; `string'
PUBLIC	??_C@_09LHKFGDCI@TIME?5OVER@			; `string'
PUBLIC	??_C@_07KINPDHML@GAME?5O?4@			; `string'
PUBLIC	??_C@_09MAOEPLNL@GAME?5OVER@			; `string'
PUBLIC	??_C@_08MPODPIDC@xxxxxxxx@			; `string'
PUBLIC	??_C@_04FICOPKPG@RING@				; `string'
PUBLIC	??_C@_09IFBADFLC@TOT?4?5RING@			; `string'
PUBLIC	??_C@_08OGCGECEO@ITEM?5BOX@			; `string'
PUBLIC	??_C@_09NBLMCIMK@?$CK?5TOTAL?5?$CK@		; `string'
PUBLIC	??_C@_04PABGLDHE@TIED@				; `string'
PUBLIC	??_C@_04LOGAKCND@WINS@				; `string'
PUBLIC	??_C@_0N@GCMNJCAK@?$CFd?3?$CF02d?4?$CF02d@	; `string'
PUBLIC	??_C@_0BE@KHJLOGLC@start?5in?5?$CFd?5seconds@	; `string'
PUBLIC	??_C@_0CE@HHOHLNCO@Teams?5will?5be?5scrambled?5next?5ro@ ; `string'
PUBLIC	??_C@_07ILADDNDN@TTL?$CF?42d@			; `string'
PUBLIC	??_C@_05CHEFHIBB@TTL01@				; `string'
PUBLIC	??_C@_08MDJCBMEE@INTERSCW@			; `string'
PUBLIC	??_C@_08LOOFOIAB@INTERSCR@			; `string'
PUBLIC	??_C@_06PAJJHGJH@YTOTAL@			; `string'
PUBLIC	??_C@_08CLKOFMME@YTMBONUS@			; `string'
PUBLIC	??_C@_08EJJAJMD@YRINGBNS@			; `string'
PUBLIC	??_C@_08KNODAGME@YPFBONUS@			; `string'
PUBLIC	??_C@_06BALDFEPI@?$CFs?5GOT@			; `string'
PUBLIC	??_C@_0M@FKBFLPCL@THROUGH?5ACT@			; `string'
PUBLIC	??_C@_0BA@LFIOMOPC@THROUGH?5THE?5ACT@		; `string'
PUBLIC	??_C@_0L@MBFANPAO@PASSED?5ACT@			; `string'
PUBLIC	??_C@_0P@IAGGKLFC@PASSED?5THE?5ACT@		; `string'
PUBLIC	??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@	; `string'
PUBLIC	??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@		; `string'
PUBLIC	??_C@_06KNHLOFLP@RESULT@			; `string'
PUBLIC	??_C@_08LPMGDBIJ@SRB2BACK@			; `string'
PUBLIC	??_C@_08EHPBPGGA@SPECTILE@			; `string'
PUBLIC	??_C@_08HNDANEKI@GOTEMALL@			; `string'
PUBLIC	??_C@_08FGFBHBAB@NOWSUPER@			; `string'
PUBLIC	??_C@_08GJDDMKCK@CEMERALD@			; `string'
PUBLIC	??_C@_06KDHIBOFA@CSCORE@			; `string'
PUBLIC	??_C@_01GAPBHFFA@T@				; `string'
PUBLIC	??_C@_02JPKMPEBO@1P@				; `string'
PUBLIC	??_C@_02JNOKEKEH@2P@				; `string'
PUBLIC	??_C@_02JMCICAHA@3P@				; `string'
PUBLIC	??_C@_02JJGHDGPF@4P@				; `string'
PUBLIC	??_C@_02JIKFFMMC@5P@				; `string'
PUBLIC	??_C@_0BJ@GMJPPENF@?$CFs?2replay?2?$CFs?2?$CFs?9?$CF02d?4lmp@ ; `string'
PUBLIC	??_C@_09GCKCNCLD@?$CFs?2replay@			; `string'
PUBLIC	??_C@_0N@PHIBDLFG@?$CFs?2replay?2?$CFs@		; `string'
PUBLIC	??_C@_09ONNEPONB@replay?1?$CFs@			; `string'
PUBLIC	??_C@_0M@HEGGCDPF@?$CFs?2temp?4lmp@		; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strlcpy:PROC
EXTRN	_remove:PROC
EXTRN	_rename:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_va:PROC
EXTRN	_CV_AddValue:PROC
EXTRN	_Command_ExitGame_f:PROC
EXTRN	_D_NumPlayers:PROC
EXTRN	_W_CachePatchName:PROC
EXTRN	_D_StartTitle:PROC
EXTRN	_F_StartGameEvaluation:PROC
EXTRN	_F_StartCustomCutscene:PROC
EXTRN	_F_StartCredits:PROC
EXTRN	_G_BuildMapName:PROC
EXTRN	_G_SaveGameData:PROC
EXTRN	_G_CheckDemoStatus:PROC
EXTRN	_G_IsSpecialStage:PROC
EXTRN	_G_AfterIntermission:PROC
EXTRN	_G_TicsToMinutes:PROC
EXTRN	_G_TicsToSeconds:PROC
EXTRN	_G_TicsToCentiseconds:PROC
EXTRN	_P_DoTeamscrambling:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_S_ChangeMusic:PROC
EXTRN	_S_StopMusic:PROC
EXTRN	_V_DrawScaledPatch:PROC
EXTRN	_V_DrawSmallScaledPatch:PROC
EXTRN	_V_DrawSmallMappedPatch:PROC
EXTRN	_V_DrawFill:PROC
EXTRN	_V_DrawCharacter:PROC
EXTRN	_V_DrawLevelTitle:PROC
EXTRN	_V_DrawString:PROC
EXTRN	_V_DrawCenteredString:PROC
EXTRN	_V_DrawRightAlignedString:PROC
EXTRN	_V_LevelNameWidth:PROC
EXTRN	_V_LevelNameHeight:PROC
EXTRN	_V_DrawPatchFill:PROC
EXTRN	_VID_BlitLinearScreen:PROC
EXTRN	_Z_ChangeTag2:PROC
EXTRN	_M_StartControlPanel:PROC
EXTRN	_M_GotLowEnoughTime:PROC
EXTRN	_FIL_FileExists:PROC
EXTRN	_I_mkdir:PROC
EXTRN	_P_GivePlayerLives:PROC
EXTRN	_HWR_DrawIntermissionBG:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_gamemap:WORD
EXTRN	_maptol:WORD
EXTRN	_modifiedgame:DWORD
EXTRN	_savemoddata:DWORD
EXTRN	_timeattacking:DWORD
EXTRN	_netgame:DWORD
EXTRN	_multiplayer:DWORD
EXTRN	_gametype:WORD
EXTRN	_menuactive:DWORD
EXTRN	_paused:BYTE
EXTRN	_consoleplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_mapheaderinfo:BYTE
EXTRN	_emeralds:WORD
EXTRN	_numemblems:DWORD
EXTRN	_nummaprings:DWORD
EXTRN	_emblemlocations:BYTE
EXTRN	_timedata:BYTE
EXTRN	_bluescore:DWORD
EXTRN	_redscore:DWORD
EXTRN	_grade:DWORD
EXTRN	_cv_matchtype:BYTE
EXTRN	_cv_teamscramble:BYTE
EXTRN	_cv_scrambleonchange:BYTE
EXTRN	_cv_inttime:BYTE
EXTRN	_cv_racetype:BYTE
EXTRN	_server:DWORD
EXTRN	_dedicated:DWORD
EXTRN	_cv_timetic:BYTE
EXTRN	_vid:BYTE
EXTRN	_srb2home:BYTE
EXTRN	_timeattackfolder:ZWORD
EXTRN	_player_names:BYTE
EXTRN	_players:BYTE
EXTRN	_playeringame:BYTE
EXTRN	_demoplayback:DWORD
EXTRN	_prevmap:WORD
EXTRN	_nextmap:WORD
EXTRN	_emeraldpics:BYTE
EXTRN	_rflagico:DWORD
EXTRN	_bflagico:DWORD
EXTRN	_rmatcico:DWORD
EXTRN	_bmatcico:DWORD
EXTRN	_rendermode:DWORD
EXTRN	_leveltime:DWORD
EXTRN	_skins:BYTE
EXTRN	_tallnum:BYTE
EXTRN	_sboscore:DWORD
EXTRN	_sbotime:DWORD
EXTRN	_sbocolon:DWORD
EXTRN	_faceprefix:BYTE
EXTRN	_hudinfo:BYTE
EXTRN	_screens:BYTE
EXTRN	_cv_nextmap:BYTE
EXTRN	_cv_chooseskin:BYTE
EXTRN	_translationtables:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_data	DB	0338H DUP (?)
_bgpatch DD	01H DUP (?)
_widebgpatch DD	01H DUP (?)
_bgtile	DD	01H DUP (?)
_interpic DD	01H DUP (?)
_usetile DD	01H DUP (?)
_usebuffer DD	01H DUP (?)
_useinterpic DD	01H DUP (?)
_timer	DD	01H DUP (?)
_gottimebonus DD 01H DUP (?)
_gotemblem DD	01H DUP (?)
_intertic DD	01H DUP (?)
_inttype DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@HEGGCDPF@?$CFs?2temp?4lmp@
CONST	SEGMENT
??_C@_0M@HEGGCDPF@?$CFs?2temp?4lmp@ DB '%s\temp.lmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONNEPONB@replay?1?$CFs@
CONST	SEGMENT
??_C@_09ONNEPONB@replay?1?$CFs@ DB 'replay/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PHIBDLFG@?$CFs?2replay?2?$CFs@
CONST	SEGMENT
??_C@_0N@PHIBDLFG@?$CFs?2replay?2?$CFs@ DB '%s\replay\%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GCKCNCLD@?$CFs?2replay@
CONST	SEGMENT
??_C@_09GCKCNCLD@?$CFs?2replay@ DB '%s\replay', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GMJPPENF@?$CFs?2replay?2?$CFs?2?$CFs?9?$CF02d?4lmp@
CONST	SEGMENT
??_C@_0BJ@GMJPPENF@?$CFs?2replay?2?$CFs?2?$CFs?9?$CF02d?4lmp@ DB '%s\repl'
	DB	'ay\%s\%s-%02d.lmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JIKFFMMC@5P@
CONST	SEGMENT
??_C@_02JIKFFMMC@5P@ DB '5P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JJGHDGPF@4P@
CONST	SEGMENT
??_C@_02JJGHDGPF@4P@ DB '4P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMCICAHA@3P@
CONST	SEGMENT
??_C@_02JMCICAHA@3P@ DB '3P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNOKEKEH@2P@
CONST	SEGMENT
??_C@_02JNOKEKEH@2P@ DB '2P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JPKMPEBO@1P@
CONST	SEGMENT
??_C@_02JPKMPEBO@1P@ DB '1P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T@
CONST	SEGMENT
??_C@_01GAPBHFFA@T@ DB 'T', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06KDHIBOFA@CSCORE@
CONST	SEGMENT
??_C@_06KDHIBOFA@CSCORE@ DB 'CSCORE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GJDDMKCK@CEMERALD@
CONST	SEGMENT
??_C@_08GJDDMKCK@CEMERALD@ DB 'CEMERALD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FGFBHBAB@NOWSUPER@
CONST	SEGMENT
??_C@_08FGFBHBAB@NOWSUPER@ DB 'NOWSUPER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNDANEKI@GOTEMALL@
CONST	SEGMENT
??_C@_08HNDANEKI@GOTEMALL@ DB 'GOTEMALL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHPBPGGA@SPECTILE@
CONST	SEGMENT
??_C@_08EHPBPGGA@SPECTILE@ DB 'SPECTILE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LPMGDBIJ@SRB2BACK@
CONST	SEGMENT
??_C@_08LPMGDBIJ@SRB2BACK@ DB 'SRB2BACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNHLOFLP@RESULT@
CONST	SEGMENT
??_C@_06KNHLOFLP@RESULT@ DB 'RESULT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@
CONST	SEGMENT
??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@ DB '* %.32s *', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@
CONST	SEGMENT
??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@ DB '%.32s * %d *', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IAGGKLFC@PASSED?5THE?5ACT@
CONST	SEGMENT
??_C@_0P@IAGGKLFC@PASSED?5THE?5ACT@ DB 'PASSED THE ACT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MBFANPAO@PASSED?5ACT@
CONST	SEGMENT
??_C@_0L@MBFANPAO@PASSED?5ACT@ DB 'PASSED ACT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFIOMOPC@THROUGH?5THE?5ACT@
CONST	SEGMENT
??_C@_0BA@LFIOMOPC@THROUGH?5THE?5ACT@ DB 'THROUGH THE ACT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FKBFLPCL@THROUGH?5ACT@
CONST	SEGMENT
??_C@_0M@FKBFLPCL@THROUGH?5ACT@ DB 'THROUGH ACT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BALDFEPI@?$CFs?5GOT@
CONST	SEGMENT
??_C@_06BALDFEPI@?$CFs?5GOT@ DB '%s GOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNODAGME@YPFBONUS@
CONST	SEGMENT
??_C@_08KNODAGME@YPFBONUS@ DB 'YPFBONUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EJJAJMD@YRINGBNS@
CONST	SEGMENT
??_C@_08EJJAJMD@YRINGBNS@ DB 'YRINGBNS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLKOFMME@YTMBONUS@
CONST	SEGMENT
??_C@_08CLKOFMME@YTMBONUS@ DB 'YTMBONUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PAJJHGJH@YTOTAL@
CONST	SEGMENT
??_C@_06PAJJHGJH@YTOTAL@ DB 'YTOTAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOOFOIAB@INTERSCR@
CONST	SEGMENT
??_C@_08LOOFOIAB@INTERSCR@ DB 'INTERSCR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MDJCBMEE@INTERSCW@
CONST	SEGMENT
??_C@_08MDJCBMEE@INTERSCW@ DB 'INTERSCW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHEFHIBB@TTL01@
CONST	SEGMENT
??_C@_05CHEFHIBB@TTL01@ DB 'TTL01', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07ILADDNDN@TTL?$CF?42d@
CONST	SEGMENT
??_C@_07ILADDNDN@TTL?$CF?42d@ DB 'TTL%.2d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HHOHLNCO@Teams?5will?5be?5scrambled?5next?5ro@
CONST	SEGMENT
??_C@_0CE@HHOHLNCO@Teams?5will?5be?5scrambled?5next?5ro@ DB 'Teams will b'
	DB	'e scrambled next round!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KHJLOGLC@start?5in?5?$CFd?5seconds@
CONST	SEGMENT
??_C@_0BE@KHJLOGLC@start?5in?5?$CFd?5seconds@ DB 'start in %d seconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GCMNJCAK@?$CFd?3?$CF02d?4?$CF02d@
CONST	SEGMENT
??_C@_0N@GCMNJCAK@?$CFd?3?$CF02d?4?$CF02d@ DB '%d:%02d.%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOGAKCND@WINS@
CONST	SEGMENT
??_C@_04LOGAKCND@WINS@ DB 'WINS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PABGLDHE@TIED@
CONST	SEGMENT
??_C@_04PABGLDHE@TIED@ DB 'TIED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBLMCIMK@?$CK?5TOTAL?5?$CK@
CONST	SEGMENT
??_C@_09NBLMCIMK@?$CK?5TOTAL?5?$CK@ DB '* TOTAL *', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGCGECEO@ITEM?5BOX@
CONST	SEGMENT
??_C@_08OGCGECEO@ITEM?5BOX@ DB 'ITEM BOX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IFBADFLC@TOT?4?5RING@
CONST	SEGMENT
??_C@_09IFBADFLC@TOT?4?5RING@ DB 'TOT. RING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FICOPKPG@RING@
CONST	SEGMENT
??_C@_04FICOPKPG@RING@ DB 'RING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPODPIDC@xxxxxxxx@
CONST	SEGMENT
??_C@_08MPODPIDC@xxxxxxxx@ DB 'xxxxxxxx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MAOEPLNL@GAME?5OVER@
CONST	SEGMENT
??_C@_09MAOEPLNL@GAME?5OVER@ DB 'GAME OVER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KINPDHML@GAME?5O?4@
CONST	SEGMENT
??_C@_07KINPDHML@GAME?5O?4@ DB 'GAME O.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LHKFGDCI@TIME?5OVER@
CONST	SEGMENT
??_C@_09LHKFGDCI@TIME?5OVER@ DB 'TIME OVER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJAEEPGE@TIME?5O?4@
CONST	SEGMENT
??_C@_07GJAEEPGE@TIME?5O?4@ DB 'TIME O.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIBLIMGJ@?$CFi?3?$CF02i?4?$CF02i@
CONST	SEGMENT
??_C@_0N@CIBLIMGJ@?$CFi?3?$CF02i?4?$CF02i@ DB '%i:%02i.%02i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi@ DB '%i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKHEEB@NAME@
CONST	SEGMENT
??_C@_04IPKHEEB@NAME@ DB 'NAME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKDFAPGJ@SCORE@
CONST	SEGMENT
??_C@_05PKDFAPGJ@SCORE@ DB 'SCORE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHBONDIN@TIME@
CONST	SEGMENT
??_C@_04OHBONDIN@TIME@ DB 'TIME', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MPBHKKPP@GOT?5PERFECT?5BONUS?5EMBLEM?$CB@
CONST	SEGMENT
??_C@_0BK@MPBHKKPP@GOT?5PERFECT?5BONUS?5EMBLEM?$CB@ DB 'GOT PERFECT BONUS'
	DB	' EMBLEM!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MACILDBE@GOT?5TIME?5BONUS?5EMBLEM?$CB@
CONST	SEGMENT
??_C@_0BH@MACILDBE@GOT?5TIME?5BONUS?5EMBLEM?$CB@ DB 'GOT TIME BONUS EMBLE'
	DB	'M!', 00H					; `string'
CONST	ENDS
_DATA	SEGMENT
_endtic	DD	0ffffffffH
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02a9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0ca4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01663H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_UnloadData
_TEXT	SEGMENT
tv73 = -68						; size = 4
_Y_UnloadData PROC					; COMDAT

; 1815 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1816 : 	// In hardware mode, don't Z_ChangeTag a pointer returned by W_CachePatchName().
; 1817 : 	// It doesn't work and is unnecessary.
; 1818 : 	if (rendermode != render_soft)

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00010	74 05		 je	 SHORT $LN4@Y_UnloadDa

; 1819 : 		return;

  00012	e9 ea 01 00 00	 jmp	 $LN2@Y_UnloadDa
$LN4@Y_UnloadDa:

; 1820 : 
; 1821 : 	// unload the background patches
; 1822 : 	UNLOAD(bgpatch);

  00017	6a 65		 push	 101			; 00000065H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _bgpatch
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00024	83 c4 08	 add	 esp, 8
  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bgpatch, 0

; 1823 : 	UNLOAD(widebgpatch);

  00031	6a 65		 push	 101			; 00000065H
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _widebgpatch
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _Z_ChangeTag2
  0003e	83 c4 08	 add	 esp, 8
  00041	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _widebgpatch, 0

; 1824 : 	UNLOAD(bgtile);

  0004b	6a 65		 push	 101			; 00000065H
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bgtile
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00058	83 c4 08	 add	 esp, 8
  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bgtile, 0

; 1825 : 	UNLOAD(interpic);

  00065	6a 65		 push	 101			; 00000065H
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _interpic
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00072	83 c4 08	 add	 esp, 8
  00075	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _interpic, 0

; 1826 : 
; 1827 : 	switch (inttype)

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _inttype
  00084	89 45 bc	 mov	 DWORD PTR tv73[ebp], eax
  00087	8b 4d bc	 mov	 ecx, DWORD PTR tv73[ebp]
  0008a	83 e9 01	 sub	 ecx, 1
  0008d	89 4d bc	 mov	 DWORD PTR tv73[ebp], ecx
  00090	83 7d bc 06	 cmp	 DWORD PTR tv73[ebp], 6
  00094	0f 87 67 01 00
	00		 ja	 $LN11@Y_UnloadDa
  0009a	8b 55 bc	 mov	 edx, DWORD PTR tv73[ebp]
  0009d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@Y_UnloadDa[edx*4]
$LN5@Y_UnloadDa:

; 1828 : 	{
; 1829 : 		case int_coop:
; 1830 : 			// unload the coop and single player patches
; 1831 : 			UNLOAD(data.coop.ttlnum);

  000a4	6a 65		 push	 101			; 00000065H
  000a6	a1 24 00 00 00	 mov	 eax, DWORD PTR _data+36
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _Z_ChangeTag2
  000b1	83 c4 08	 add	 esp, 8
  000b4	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+36, 0

; 1832 : 			UNLOAD(data.coop.ptimebonus);

  000be	6a 65		 push	 101			; 00000065H
  000c0	a1 28 00 00 00	 mov	 eax, DWORD PTR _data+40
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _Z_ChangeTag2
  000cb	83 c4 08	 add	 esp, 8
  000ce	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+40, 0

; 1833 : 			UNLOAD(data.coop.pringbonus);

  000d8	6a 65		 push	 101			; 00000065H
  000da	a1 2c 00 00 00	 mov	 eax, DWORD PTR _data+44
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _Z_ChangeTag2
  000e5	83 c4 08	 add	 esp, 8
  000e8	c7 05 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+44, 0

; 1834 : 			UNLOAD(data.coop.pperfbonus);

  000f2	6a 65		 push	 101			; 00000065H
  000f4	a1 30 00 00 00	 mov	 eax, DWORD PTR _data+48
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _Z_ChangeTag2
  000ff	83 c4 08	 add	 esp, 8
  00102	c7 05 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+48, 0

; 1835 : 			UNLOAD(data.coop.ptotal);

  0010c	6a 65		 push	 101			; 00000065H
  0010e	a1 34 00 00 00	 mov	 eax, DWORD PTR _data+52
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00119	83 c4 08	 add	 esp, 8
  0011c	c7 05 34 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+52, 0

; 1836 : 			break;

  00126	e9 d6 00 00 00	 jmp	 $LN2@Y_UnloadDa
$LN6@Y_UnloadDa:

; 1837 : 		case int_spec:
; 1838 : 			// unload the special stage patches
; 1839 : 			UNLOAD(data.spec.cemerald);

  0012b	6a 65		 push	 101			; 00000065H
  0012d	a1 0c 00 00 00	 mov	 eax, DWORD PTR _data+12
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00138	83 c4 08	 add	 esp, 8
  0013b	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+12, 0

; 1840 : 			UNLOAD(data.spec.pringbonus);

  00145	6a 65		 push	 101			; 00000065H
  00147	a1 14 00 00 00	 mov	 eax, DWORD PTR _data+20
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00152	83 c4 08	 add	 esp, 8
  00155	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+20, 0

; 1841 : 			UNLOAD(data.spec.cscore);

  0015f	6a 65		 push	 101			; 00000065H
  00161	a1 18 00 00 00	 mov	 eax, DWORD PTR _data+24
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _Z_ChangeTag2
  0016c	83 c4 08	 add	 esp, 8
  0016f	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+24, 0

; 1842 : 			UNLOAD(data.spec.nowsuper);

  00179	6a 65		 push	 101			; 00000065H
  0017b	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _Z_ChangeTag2
  00186	83 c4 08	 add	 esp, 8
  00189	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+16, 0

; 1843 : 			break;

  00193	eb 6c		 jmp	 SHORT $LN2@Y_UnloadDa
$LN7@Y_UnloadDa:

; 1844 : 		case int_match:
; 1845 : 			UNLOAD(data.match.result);

  00195	6a 65		 push	 101			; 00000065H
  00197	a1 00 03 00 00	 mov	 eax, DWORD PTR _data+768
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _Z_ChangeTag2
  001a2	83 c4 08	 add	 esp, 8
  001a5	c7 05 00 03 00
	00 00 00 00 00	 mov	 DWORD PTR _data+768, 0

; 1846 : 			break;

  001af	eb 50		 jmp	 SHORT $LN2@Y_UnloadDa
$LN8@Y_UnloadDa:

; 1847 : 		case int_ctf:
; 1848 : 			UNLOAD(data.match.blueflag);

  001b1	6a 65		 push	 101			; 00000065H
  001b3	a1 04 03 00 00	 mov	 eax, DWORD PTR _data+772
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 _Z_ChangeTag2
  001be	83 c4 08	 add	 esp, 8
  001c1	c7 05 04 03 00
	00 00 00 00 00	 mov	 DWORD PTR _data+772, 0

; 1849 : 			UNLOAD(data.match.redflag);

  001cb	6a 65		 push	 101			; 00000065H
  001cd	a1 08 03 00 00	 mov	 eax, DWORD PTR _data+776
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _Z_ChangeTag2
  001d8	83 c4 08	 add	 esp, 8
  001db	c7 05 08 03 00
	00 00 00 00 00	 mov	 DWORD PTR _data+776, 0

; 1850 : 			break;

  001e5	eb 1a		 jmp	 SHORT $LN2@Y_UnloadDa
$LN9@Y_UnloadDa:

; 1851 : 		case int_race:
; 1852 : 		case int_classicrace:
; 1853 : 			// unload the RESULT patch
; 1854 : 			UNLOAD(data.race.result);

  001e7	6a 65		 push	 101			; 00000065H
  001e9	a1 ac 00 00 00	 mov	 eax, DWORD PTR _data+172
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _Z_ChangeTag2
  001f4	83 c4 08	 add	 esp, 8
  001f7	c7 05 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+172, 0
$LN11@Y_UnloadDa:
$LN2@Y_UnloadDa:

; 1855 : 			break;
; 1856 : 		default:
; 1857 : 			//without this default, int_none, int_tag, int_ctf,
; 1858 : 			//int_chaos, and int_classicrace are not handled
; 1859 : 			break;
; 1860 : 	}
; 1861 : }

  00201	5f		 pop	 edi
  00202	5e		 pop	 esi
  00203	5b		 pop	 ebx
  00204	8b e5		 mov	 esp, ebp
  00206	5d		 pop	 ebp
  00207	c3		 ret	 0
$LN13@Y_UnloadDa:
  00208	00 00 00 00	 DD	 $LN5@Y_UnloadDa
  0020c	00 00 00 00	 DD	 $LN7@Y_UnloadDa
  00210	00 00 00 00	 DD	 $LN11@Y_UnloadDa
  00214	00 00 00 00	 DD	 $LN8@Y_UnloadDa
  00218	00 00 00 00	 DD	 $LN6@Y_UnloadDa
  0021c	00 00 00 00	 DD	 $LN9@Y_UnloadDa
  00220	00 00 00 00	 DD	 $LN9@Y_UnloadDa
_Y_UnloadData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_FollowIntermission
_TEXT	SEGMENT
$T1 = -328						; size = 4
_nameofdemo$2 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_Y_FollowIntermission PROC				; COMDAT

; 1756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1757 : 	if (timeattacking)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  0001d	0f 84 73 01 00
	00		 je	 $LN2@Y_FollowIn

; 1758 : 	{
; 1759 : 		char nameofdemo[256];
; 1760 : 		_snprintf(nameofdemo, sizeof nameofdemo,

  00023	a1 14 00 00 00	 mov	 eax, DWORD PTR _cv_chooseskin+20
  00028	83 e8 01	 sub	 eax, 1
  0002b	50		 push	 eax
  0002c	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _gamemap
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _G_BuildMapName
  00039	83 c4 04	 add	 esp, 4
  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET _timeattackfolder
  00042	68 00 00 00 00	 push	 OFFSET _srb2home
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GMJPPENF@?$CFs?2replay?2?$CFs?2?$CFs?9?$CF02d?4lmp@
  0004c	68 00 01 00 00	 push	 256			; 00000100H
  00051	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _nameofdemo$2[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 __snprintf
  0005d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1761 : 			"%s"PATHSEP"replay"PATHSEP"%s"PATHSEP"%s-%02d.lmp",
; 1762 : 			srb2home, timeattackfolder, G_BuildMapName(gamemap),
; 1763 : 			cv_chooseskin.value-1);
; 1764 : 		nameofdemo[sizeof nameofdemo - 1] = '\0';

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	69 c8 ff 00 00
	00		 imul	 ecx, eax, 255
  0006b	89 8d b8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00071	81 bd b8 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR $T1[ebp], 256	; 00000100H
  0007b	73 02		 jae	 SHORT $LN9@Y_FollowIn
  0007d	eb 06		 jmp	 SHORT $LN10@Y_FollowIn
$LN9@Y_FollowIn:
  0007f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00084	90		 npad	 1
$LN10@Y_FollowIn:
  00085	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0008b	c6 84 15 fc fe
	ff ff 00	 mov	 BYTE PTR _nameofdemo$2[ebp+edx], 0

; 1765 : 		G_CheckDemoStatus();

  00093	e8 00 00 00 00	 call	 _G_CheckDemoStatus
  00098	90		 npad	 1

; 1766 : 
; 1767 : 		Command_ExitGame_f();

  00099	e8 00 00 00 00	 call	 _Command_ExitGame_f
  0009e	90		 npad	 1

; 1768 : 
; 1769 : 		timeattacking = true;

  0009f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _timeattacking, 1

; 1770 : 
; 1771 : 		M_StartControlPanel();

  000a9	e8 00 00 00 00	 call	 _M_StartControlPanel
  000ae	90		 npad	 1

; 1772 : 
; 1773 : 		I_mkdir(va("%s"PATHSEP"replay", srb2home), 0755);

  000af	68 ed 01 00 00	 push	 493			; 000001edH
  000b4	68 00 00 00 00	 push	 OFFSET _srb2home
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_09GCKCNCLD@?$CFs?2replay@
  000be	e8 00 00 00 00	 call	 _va
  000c3	83 c4 08	 add	 esp, 8
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _I_mkdir
  000cc	83 c4 08	 add	 esp, 8

; 1774 : 		I_mkdir(va("%s"PATHSEP"replay"PATHSEP"%s", srb2home, timeattackfolder), 0755);

  000cf	68 ed 01 00 00	 push	 493			; 000001edH
  000d4	68 00 00 00 00	 push	 OFFSET _timeattackfolder
  000d9	68 00 00 00 00	 push	 OFFSET _srb2home
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PHIBDLFG@?$CFs?2replay?2?$CFs@
  000e3	e8 00 00 00 00	 call	 _va
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _I_mkdir
  000f1	83 c4 08	 add	 esp, 8

; 1775 : 
; 1776 : 		if (FIL_FileExists(va("replay/%s", timeattackfolder)))

  000f4	68 00 00 00 00	 push	 OFFSET _timeattackfolder
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_09ONNEPONB@replay?1?$CFs@
  000fe	e8 00 00 00 00	 call	 _va
  00103	83 c4 08	 add	 esp, 8
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _FIL_FileExists
  0010c	83 c4 04	 add	 esp, 4
  0010f	85 c0		 test	 eax, eax
  00111	74 63		 je	 SHORT $LN4@Y_FollowIn

; 1777 : 		{
; 1778 : 			if (FIL_FileExists(va("%s"PATHSEP"temp.lmp",srb2home)))

  00113	68 00 00 00 00	 push	 OFFSET _srb2home
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HEGGCDPF@?$CFs?2temp?4lmp@
  0011d	e8 00 00 00 00	 call	 _va
  00122	83 c4 08	 add	 esp, 8
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _FIL_FileExists
  0012b	83 c4 04	 add	 esp, 4
  0012e	85 c0		 test	 eax, eax
  00130	74 44		 je	 SHORT $LN4@Y_FollowIn

; 1779 : 			{
; 1780 : 				if (FIL_FileExists(nameofdemo))

  00132	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _nameofdemo$2[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _FIL_FileExists
  0013e	83 c4 04	 add	 esp, 4
  00141	85 c0		 test	 eax, eax
  00143	74 0f		 je	 SHORT $LN5@Y_FollowIn

; 1781 : 					remove(nameofdemo);

  00145	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _nameofdemo$2[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _remove
  00151	83 c4 04	 add	 esp, 4
$LN5@Y_FollowIn:

; 1782 : 
; 1783 : 				rename(va("%s"PATHSEP"temp.lmp",srb2home), nameofdemo);

  00154	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _nameofdemo$2[ebp]
  0015a	50		 push	 eax
  0015b	68 00 00 00 00	 push	 OFFSET _srb2home
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HEGGCDPF@?$CFs?2temp?4lmp@
  00165	e8 00 00 00 00	 call	 _va
  0016a	83 c4 08	 add	 esp, 8
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _rename
  00173	83 c4 08	 add	 esp, 8
$LN4@Y_FollowIn:

; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 		CV_AddValue(&cv_nextmap, 1);

  00176	6a 01		 push	 1
  00178	68 00 00 00 00	 push	 OFFSET _cv_nextmap
  0017d	e8 00 00 00 00	 call	 _CV_AddValue
  00182	83 c4 08	 add	 esp, 8

; 1788 : 		CV_AddValue(&cv_nextmap, -1);

  00185	6a ff		 push	 -1
  00187	68 00 00 00 00	 push	 OFFSET _cv_nextmap
  0018c	e8 00 00 00 00	 call	 _CV_AddValue
  00191	83 c4 08	 add	 esp, 8

; 1789 : 		return;

  00194	eb 60		 jmp	 SHORT $LN1@Y_FollowIn
$LN2@Y_FollowIn:

; 1790 : 	}
; 1791 : 
; 1792 : 	if (nextmap < 1100-1)

  00196	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _nextmap
  0019d	3d 4b 04 00 00	 cmp	 eax, 1099		; 0000044bH
  001a2	7d 08		 jge	 SHORT $LN6@Y_FollowIn

; 1793 : 	{
; 1794 : 		// normal level
; 1795 : 		G_AfterIntermission();

  001a4	e8 00 00 00 00	 call	 _G_AfterIntermission
  001a9	90		 npad	 1

; 1796 : 		return;

  001aa	eb 4a		 jmp	 SHORT $LN1@Y_FollowIn
$LN6@Y_FollowIn:

; 1797 : 	}
; 1798 : 
; 1799 : 	// Start a custom cutscene if there is one.
; 1800 : 	if (mapheaderinfo[gamemap-1].cutscenenum)

  001ac	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  001b3	83 e8 01	 sub	 eax, 1
  001b6	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001bc	0f b6 91 1d 01
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+285]
  001c3	85 d2		 test	 edx, edx
  001c5	74 29		 je	 SHORT $LN7@Y_FollowIn

; 1801 : 	{
; 1802 : 		F_StartCustomCutscene(mapheaderinfo[gamemap-1].cutscenenum-1, false, false);

  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  001d2	83 e8 01	 sub	 eax, 1
  001d5	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001db	0f b6 91 1d 01
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+285]
  001e2	83 ea 01	 sub	 edx, 1
  001e5	52		 push	 edx
  001e6	e8 00 00 00 00	 call	 _F_StartCustomCutscene
  001eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1803 : 		return;

  001ee	eb 06		 jmp	 SHORT $LN1@Y_FollowIn
$LN7@Y_FollowIn:

; 1804 : 	}
; 1805 : 
; 1806 : 	Y_EndGame();

  001f0	e8 00 00 00 00	 call	 _Y_EndGame
  001f5	90		 npad	 1
$LN1@Y_FollowIn:

; 1807 : }

  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx
  001f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fc	33 cd		 xor	 ecx, ebp
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
_Y_FollowIntermission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_DrawScaledNum
_TEXT	SEGMENT
_w$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_flags$ = 16						; size = 4
_num$ = 20						; size = 4
_Y_DrawScaledNum PROC					; COMDAT

; 1686 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1687 : 	INT32 w = SHORT(tallnum[0]->width);

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tallnum[ecx]
  00017	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0001a	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax

; 1688 : 
; 1689 : 	// special case for 0
; 1690 : 	if (!num)

  0001d	83 7d 14 00	 cmp	 DWORD PTR _num$[ebp], 0
  00021	75 28		 jne	 SHORT $LN4@Y_DrawScal

; 1691 : 	{
; 1692 : 		V_DrawScaledPatch(x - w, y, flags, tallnum[0]);

  00023	b8 04 00 00 00	 mov	 eax, 4
  00028	6b c8 00	 imul	 ecx, eax, 0
  0002b	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tallnum[ecx]
  00031	52		 push	 edx
  00032	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0003d	2b 55 fc	 sub	 edx, DWORD PTR _w$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00046	83 c4 10	 add	 esp, 16			; 00000010H

; 1693 : 		return;

  00049	eb 46		 jmp	 SHORT $LN3@Y_DrawScal
$LN4@Y_DrawScal:

; 1694 : 	}
; 1695 : 
; 1696 : #ifdef PARANOIA
; 1697 : 	if (num < 0)
; 1698 : 		I_Error("Intermission drawer used negative number!");
; 1699 : #endif
; 1700 : 
; 1701 : 	// draw the number
; 1702 : 	while (num)

  0004b	83 7d 14 00	 cmp	 DWORD PTR _num$[ebp], 0
  0004f	74 40		 je	 SHORT $LN3@Y_DrawScal

; 1703 : 	{
; 1704 : 		x -= w;

  00051	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00054	2b 45 fc	 sub	 eax, DWORD PTR _w$[ebp]
  00057	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 1705 : 		V_DrawScaledPatch(x, y, flags, tallnum[num % 10]);

  0005a	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  0005d	99		 cdq
  0005e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00063	f7 f9		 idiv	 ecx
  00065	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _tallnum[edx*4]
  0006c	52		 push	 edx
  0006d	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 1706 : 		num /= 10;

  00081	8b 45 14	 mov	 eax, DWORD PTR _num$[ebp]
  00084	99		 cdq
  00085	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0008a	f7 f9		 idiv	 ecx
  0008c	89 45 14	 mov	 DWORD PTR _num$[ebp], eax

; 1707 : 	}

  0008f	eb ba		 jmp	 SHORT $LN4@Y_DrawScal
$LN3@Y_DrawScal:

; 1708 : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_Y_DrawScaledNum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_CalculateMatchWinners
_TEXT	SEGMENT
_completed$ = -140					; size = 128
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Y_CalculateMatchWinners PROC				; COMDAT

; 1333 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1334 : 	INT32 i, j;
; 1335 : 	boolean completed[MAXPLAYERS];
; 1336 : 
; 1337 : 	// Initialize variables
; 1338 : 	memset(data.match.scores, 0, sizeof (data.match.scores));

  00016	68 80 00 00 00	 push	 128			; 00000080H
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET _data
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1339 : 	memset(data.match.color, 0, sizeof (data.match.color));

  0002a	68 80 00 00 00	 push	 128			; 00000080H
  0002f	6a 00		 push	 0
  00031	68 80 00 00 00	 push	 OFFSET _data+128
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1340 : 	memset(data.match.character, 0, sizeof (data.match.character));

  0003e	68 80 00 00 00	 push	 128			; 00000080H
  00043	6a 00		 push	 0
  00045	68 80 01 00 00	 push	 OFFSET _data+384
  0004a	e8 00 00 00 00	 call	 _memset
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1341 : 	memset(data.match.spectator, 0, sizeof (data.match.spectator));

  00052	68 80 00 00 00	 push	 128			; 00000080H
  00057	6a 00		 push	 0
  00059	68 00 01 00 00	 push	 OFFSET _data+256
  0005e	e8 00 00 00 00	 call	 _memset
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1342 : 	memset(completed, 0, sizeof (completed));

  00066	68 80 00 00 00	 push	 128			; 00000080H
  0006b	6a 00		 push	 0
  0006d	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _completed$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _memset
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1343 : 	data.match.numplayers = 0;

  0007c	c7 05 0c 03 00
	00 00 00 00 00	 mov	 DWORD PTR _data+780, 0

; 1344 : 	i = j = 0;

  00086	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00090	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 1345 : 
; 1346 : 	for (j = 0; j < MAXPLAYERS; j++)

  00093	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0009a	eb 09		 jmp	 SHORT $LN4@Y_Calculat
$LN2@Y_Calculat:
  0009c	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  0009f	83 c0 01	 add	 eax, 1
  000a2	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN4@Y_Calculat:
  000a5	83 7d f4 20	 cmp	 DWORD PTR _j$[ebp], 32	; 00000020H
  000a9	0f 8d f7 01 00
	00		 jge	 $LN3@Y_Calculat

; 1347 : 	{
; 1348 : 		if (!playeringame[j])

  000af	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000b2	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000ba	75 02		 jne	 SHORT $LN8@Y_Calculat

; 1349 : 			continue;

  000bc	eb de		 jmp	 SHORT $LN2@Y_Calculat
$LN8@Y_Calculat:

; 1350 : 
; 1351 : 		for (i = 0; i < MAXPLAYERS; i++)

  000be	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c5	eb 09		 jmp	 SHORT $LN7@Y_Calculat
$LN5@Y_Calculat:
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ca	83 c0 01	 add	 eax, 1
  000cd	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Y_Calculat:
  000d0	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000d4	0f 8d a3 01 00
	00		 jge	 $LN6@Y_Calculat

; 1352 : 		{
; 1353 : 			if (!playeringame[i])

  000da	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000dd	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000e5	75 02		 jne	 SHORT $LN9@Y_Calculat

; 1354 : 				continue;

  000e7	eb de		 jmp	 SHORT $LN5@Y_Calculat
$LN9@Y_Calculat:

; 1355 : 
; 1356 : 			if (gametype == GT_TAG)

  000e9	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  000f0	83 f8 03	 cmp	 eax, 3
  000f3	0f 85 c2 00 00
	00		 jne	 $LN10@Y_Calculat

; 1357 : 			{
; 1358 : 				if (players[i].score >= data.match.scores[data.match.numplayers] && completed[i] == false)

  000f9	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00100	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00106	8b 90 bc 00 00
	00		 mov	 edx, DWORD PTR _players[eax+188]
  0010c	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _data[ecx*4]
  00113	0f 82 9d 00 00
	00		 jb	 $LN12@Y_Calculat
  00119	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011c	83 bc 85 74 ff
	ff ff 00	 cmp	 DWORD PTR _completed$[ebp+eax*4], 0
  00124	0f 85 8c 00 00
	00		 jne	 $LN12@Y_Calculat

; 1359 : 				{
; 1360 : 					data.match.scores[data.match.numplayers] = players[i].score;

  0012a	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00131	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00137	8b 90 bc 00 00
	00		 mov	 edx, DWORD PTR _players[eax+188]
  0013d	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _data[ecx*4], edx

; 1361 : 					data.match.color[data.match.numplayers] = &players[i].skincolor;

  00144	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0014b	05 b4 00 00 00	 add	 eax, OFFSET _players+180
  00150	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00156	89 04 8d 80 00
	00 00		 mov	 DWORD PTR _data[ecx*4+128], eax

; 1362 : 					data.match.character[data.match.numplayers] = &players[i].skin;

  0015d	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00164	05 b8 00 00 00	 add	 eax, OFFSET _players+184
  00169	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  0016f	89 04 8d 80 01
	00 00		 mov	 DWORD PTR _data[ecx*4+384], eax

; 1363 : 					data.match.name[data.match.numplayers] = player_names[i];

  00176	6b 45 f8 16	 imul	 eax, DWORD PTR _i$[ebp], 22
  0017a	05 00 00 00 00	 add	 eax, OFFSET _player_names
  0017f	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00185	89 04 8d 80 02
	00 00		 mov	 DWORD PTR _data[ecx*4+640], eax

; 1364 : 					data.match.spectator[data.match.numplayers] = players[i].spectator;

  0018c	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00193	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  0019a	8b 15 0c 03 00
	00		 mov	 edx, DWORD PTR _data+780
  001a0	89 0c 95 00 01
	00 00		 mov	 DWORD PTR _data[edx*4+256], ecx

; 1365 : 					data.match.num[data.match.numplayers] = i;

  001a7	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  001ac	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  001af	89 0c 85 00 02
	00 00		 mov	 DWORD PTR _data[eax*4+512], ecx
$LN12@Y_Calculat:

; 1366 : 				}
; 1367 : 			}

  001b6	e9 bd 00 00 00	 jmp	 $LN13@Y_Calculat
$LN10@Y_Calculat:

; 1368 : 			else if (players[i].score >= data.match.scores[data.match.numplayers] && completed[i] == false)

  001bb	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001c2	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  001c8	8b 90 bc 00 00
	00		 mov	 edx, DWORD PTR _players[eax+188]
  001ce	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _data[ecx*4]
  001d5	0f 82 9d 00 00
	00		 jb	 $LN13@Y_Calculat
  001db	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001de	83 bc 85 74 ff
	ff ff 00	 cmp	 DWORD PTR _completed$[ebp+eax*4], 0
  001e6	0f 85 8c 00 00
	00		 jne	 $LN13@Y_Calculat

; 1369 : 			{
; 1370 : 				data.match.scores[data.match.numplayers] = players[i].score;

  001ec	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001f3	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  001f9	8b 90 bc 00 00
	00		 mov	 edx, DWORD PTR _players[eax+188]
  001ff	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _data[ecx*4], edx

; 1371 : 				data.match.color[data.match.numplayers] = &players[i].skincolor;

  00206	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0020d	05 b4 00 00 00	 add	 eax, OFFSET _players+180
  00212	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00218	89 04 8d 80 00
	00 00		 mov	 DWORD PTR _data[ecx*4+128], eax

; 1372 : 				data.match.character[data.match.numplayers] = &players[i].skin;

  0021f	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00226	05 b8 00 00 00	 add	 eax, OFFSET _players+184
  0022b	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00231	89 04 8d 80 01
	00 00		 mov	 DWORD PTR _data[ecx*4+384], eax

; 1373 : 				data.match.name[data.match.numplayers] = player_names[i];

  00238	6b 45 f8 16	 imul	 eax, DWORD PTR _i$[ebp], 22
  0023c	05 00 00 00 00	 add	 eax, OFFSET _player_names
  00241	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00247	89 04 8d 80 02
	00 00		 mov	 DWORD PTR _data[ecx*4+640], eax

; 1374 : 				data.match.spectator[data.match.numplayers] = players[i].spectator;

  0024e	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00255	0f b6 88 f0 01
	00 00		 movzx	 ecx, BYTE PTR _players[eax+496]
  0025c	8b 15 0c 03 00
	00		 mov	 edx, DWORD PTR _data+780
  00262	89 0c 95 00 01
	00 00		 mov	 DWORD PTR _data[edx*4+256], ecx

; 1375 : 				data.match.num[data.match.numplayers] = i;

  00269	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  0026e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00271	89 0c 85 00 02
	00 00		 mov	 DWORD PTR _data[eax*4+512], ecx
$LN13@Y_Calculat:

; 1376 : 			}
; 1377 : 		}

  00278	e9 4a fe ff ff	 jmp	 $LN5@Y_Calculat
$LN6@Y_Calculat:

; 1378 : 		completed[data.match.num[data.match.numplayers]] = true;

  0027d	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  00282	8b 0c 85 00 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+512]
  00289	c7 84 8d 74 ff
	ff ff 01 00 00
	00		 mov	 DWORD PTR _completed$[ebp+ecx*4], 1

; 1379 : 		data.match.numplayers++;

  00294	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  00299	83 c0 01	 add	 eax, 1
  0029c	a3 0c 03 00 00	 mov	 DWORD PTR _data+780, eax

; 1380 : 	}

  002a1	e9 f6 fd ff ff	 jmp	 $LN2@Y_Calculat
$LN3@Y_Calculat:

; 1381 : }

  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx
  002a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ac	33 cd		 xor	 ecx, ebp
  002ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
_Y_CalculateMatchWinners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_CalculateTimeRaceWinners
_TEXT	SEGMENT
_completed$ = -140					; size = 128
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Y_CalculateTimeRaceWinners PROC			; COMDAT

; 1387 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1388 : 	INT32 i, j;
; 1389 : 	boolean completed[MAXPLAYERS];
; 1390 : 
; 1391 : 	// Initialize variables
; 1392 : 
; 1393 : 	for (i = 0; i < MAXPLAYERS; i++)

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@Y_Calculat
$LN2@Y_Calculat:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Y_Calculat:
  00028	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0002c	7d 10		 jge	 SHORT $LN3@Y_Calculat

; 1394 : 		data.match.scores[i] = INT32_MAX;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00031	c7 04 85 00 00
	00 00 ff ff ff
	7f		 mov	 DWORD PTR _data[eax*4], 2147483647 ; 7fffffffH
  0003c	eb e1		 jmp	 SHORT $LN2@Y_Calculat
$LN3@Y_Calculat:

; 1395 : 
; 1396 : 	memset(data.match.color, 0, sizeof (data.match.color));

  0003e	68 80 00 00 00	 push	 128			; 00000080H
  00043	6a 00		 push	 0
  00045	68 80 00 00 00	 push	 OFFSET _data+128
  0004a	e8 00 00 00 00	 call	 _memset
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1397 : 	memset(data.match.character, 0, sizeof (data.match.character));

  00052	68 80 00 00 00	 push	 128			; 00000080H
  00057	6a 00		 push	 0
  00059	68 80 01 00 00	 push	 OFFSET _data+384
  0005e	e8 00 00 00 00	 call	 _memset
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1398 : 	memset(data.match.spectator, 0, sizeof (data.match.spectator));

  00066	68 80 00 00 00	 push	 128			; 00000080H
  0006b	6a 00		 push	 0
  0006d	68 00 01 00 00	 push	 OFFSET _data+256
  00072	e8 00 00 00 00	 call	 _memset
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1399 : 	memset(completed, 0, sizeof (completed));

  0007a	68 80 00 00 00	 push	 128			; 00000080H
  0007f	6a 00		 push	 0
  00081	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _completed$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memset
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1400 : 	data.match.numplayers = 0;

  00090	c7 05 0c 03 00
	00 00 00 00 00	 mov	 DWORD PTR _data+780, 0

; 1401 : 	i = j = 0;

  0009a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000a1	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000a4	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 1402 : 
; 1403 : 	for (j = 0; j < MAXPLAYERS; j++)

  000a7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  000ae	eb 09		 jmp	 SHORT $LN7@Y_Calculat
$LN5@Y_Calculat:
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
$LN7@Y_Calculat:
  000b9	83 7d f4 20	 cmp	 DWORD PTR _j$[ebp], 32	; 00000020H
  000bd	0f 8d 02 01 00
	00		 jge	 $LN6@Y_Calculat

; 1404 : 	{
; 1405 : 		if (!playeringame[j])

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000c6	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000ce	75 02		 jne	 SHORT $LN11@Y_Calculat

; 1406 : 			continue;

  000d0	eb de		 jmp	 SHORT $LN5@Y_Calculat
$LN11@Y_Calculat:

; 1407 : 
; 1408 : 		for (i = 0; i < MAXPLAYERS; i++)

  000d2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000d9	eb 09		 jmp	 SHORT $LN10@Y_Calculat
$LN8@Y_Calculat:
  000db	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Y_Calculat:
  000e4	83 7d f8 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000e8	0f 8d ae 00 00
	00		 jge	 $LN9@Y_Calculat

; 1409 : 		{
; 1410 : 			if (!playeringame[i])

  000ee	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000f9	75 02		 jne	 SHORT $LN12@Y_Calculat

; 1411 : 				continue;

  000fb	eb de		 jmp	 SHORT $LN8@Y_Calculat
$LN12@Y_Calculat:

; 1412 : 
; 1413 : 			if (players[i].realtime <= data.match.scores[data.match.numplayers] && completed[i] == false)

  000fd	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00104	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  0010a	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR _players[eax+340]
  00110	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _data[ecx*4]
  00117	77 7e		 ja	 SHORT $LN13@Y_Calculat
  00119	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011c	83 bc 85 74 ff
	ff ff 00	 cmp	 DWORD PTR _completed$[ebp+eax*4], 0
  00124	75 71		 jne	 SHORT $LN13@Y_Calculat

; 1414 : 			{
; 1415 : 				data.match.scores[data.match.numplayers] = players[i].realtime;

  00126	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0012d	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00133	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR _players[eax+340]
  00139	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _data[ecx*4], edx

; 1416 : 				data.match.color[data.match.numplayers] = &players[i].skincolor;

  00140	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00147	05 b4 00 00 00	 add	 eax, OFFSET _players+180
  0014c	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00152	89 04 8d 80 00
	00 00		 mov	 DWORD PTR _data[ecx*4+128], eax

; 1417 : 				data.match.character[data.match.numplayers] = &players[i].skin;

  00159	69 45 f8 fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00160	05 b8 00 00 00	 add	 eax, OFFSET _players+184
  00165	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  0016b	89 04 8d 80 01
	00 00		 mov	 DWORD PTR _data[ecx*4+384], eax

; 1418 : 				data.match.name[data.match.numplayers] = player_names[i];

  00172	6b 45 f8 16	 imul	 eax, DWORD PTR _i$[ebp], 22
  00176	05 00 00 00 00	 add	 eax, OFFSET _player_names
  0017b	8b 0d 0c 03 00
	00		 mov	 ecx, DWORD PTR _data+780
  00181	89 04 8d 80 02
	00 00		 mov	 DWORD PTR _data[ecx*4+640], eax

; 1419 : 				data.match.num[data.match.numplayers] = i;

  00188	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  0018d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00190	89 0c 85 00 02
	00 00		 mov	 DWORD PTR _data[eax*4+512], ecx
$LN13@Y_Calculat:

; 1420 : 			}
; 1421 : 		}

  00197	e9 3f ff ff ff	 jmp	 $LN8@Y_Calculat
$LN9@Y_Calculat:

; 1422 : 		completed[data.match.num[data.match.numplayers]] = true;

  0019c	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  001a1	8b 0c 85 00 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+512]
  001a8	c7 84 8d 74 ff
	ff ff 01 00 00
	00		 mov	 DWORD PTR _completed$[ebp+ecx*4], 1

; 1423 : 		data.match.numplayers++;

  001b3	a1 0c 03 00 00	 mov	 eax, DWORD PTR _data+780
  001b8	83 c0 01	 add	 eax, 1
  001bb	a3 0c 03 00 00	 mov	 DWORD PTR _data+780, eax

; 1424 : 	}

  001c0	e9 eb fe ff ff	 jmp	 $LN5@Y_Calculat
$LN6@Y_Calculat:

; 1425 : }

  001c5	5f		 pop	 edi
  001c6	5e		 pop	 esi
  001c7	5b		 pop	 ebx
  001c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cb	33 cd		 xor	 ecx, ebp
  001cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d2	8b e5		 mov	 esp, ebp
  001d4	5d		 pop	 ebp
  001d5	c3		 ret	 0
_Y_CalculateTimeRaceWinners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_CalculateRaceWinners
_TEXT	SEGMENT
tv192 = -264						; size = 4
tv202 = -264						; size = 4
tv213 = -264						; size = 4
tv436 = -264						; size = 4
_k$1 = -196						; size = 4
_j$2 = -192						; size = 4
_racetime$ = -188					; size = 4
_score$ = -184						; size = 4
_numplayersingame$ = -180				; size = 4
_wins$ = -176						; size = 4
_itembox$ = -172					; size = 4
_totalring$ = -168					; size = 4
_ring$ = -164						; size = 4
_n$ = -160						; size = 4
_i$ = -156						; size = 4
_numwins$ = -152					; size = 128
_winners$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_Y_CalculateRaceWinners PROC				; COMDAT

; 1431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1432 : 	INT32 winners[5], numwins[MAXPLAYERS];
; 1433 : 	INT32 i = 0, n = 0, ring, totalring, itembox, wins;

  00016	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00020	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0

; 1434 : 	INT32 numplayersingame;
; 1435 : 	UINT32 score = 0, racetime;

  0002a	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _score$[ebp], 0

; 1436 : 
; 1437 : 	// Everyone has zero wins.
; 1438 : 	memset(numwins, 0, sizeof (INT32)*MAXPLAYERS);

  00034	68 80 00 00 00	 push	 128			; 00000080H
  00039	6a 00		 push	 0
  0003b	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _numwins$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memset
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1439 : 
; 1440 : 	// No one has won anything.
; 1441 : 	winners[0] = winners[1] = winners[2] = winners[3] = winners[4] = -1;

  0004a	b8 04 00 00 00	 mov	 eax, 4
  0004f	c1 e0 02	 shl	 eax, 2
  00052	c7 44 05 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+eax], -1
  0005a	b9 04 00 00 00	 mov	 ecx, 4
  0005f	6b d1 03	 imul	 edx, ecx, 3
  00062	c7 44 15 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+edx], -1
  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	d1 e0		 shl	 eax, 1
  00071	c7 44 05 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+eax], -1
  00079	b9 04 00 00 00	 mov	 ecx, 4
  0007e	c1 e1 00	 shl	 ecx, 0
  00081	c7 44 0d e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+ecx], -1
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	6b c2 00	 imul	 eax, edx, 0
  00091	c7 44 05 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+eax], -1

; 1442 : 
; 1443 : 	// Find the highest score.
; 1444 : 	for (; i < MAXPLAYERS; i++)

  00099	eb 0f		 jmp	 SHORT $LN4@Y_Calculat
$LN2@Y_Calculat:
  0009b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@Y_Calculat:
  000aa	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  000b1	0f 8d 8a 00 00
	00		 jge	 $LN3@Y_Calculat

; 1445 : 	{
; 1446 : 		if (!playeringame[i] || players[i].score < score)

  000b7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  000bd	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  000c5	74 18		 je	 SHORT $LN45@Y_Calculat
  000c7	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  000d1	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  000d7	3b 8d 48 ff ff
	ff		 cmp	 ecx, DWORD PTR _score$[ebp]
  000dd	73 02		 jae	 SHORT $LN44@Y_Calculat
$LN45@Y_Calculat:

; 1447 : 			continue;

  000df	eb ba		 jmp	 SHORT $LN2@Y_Calculat
$LN44@Y_Calculat:

; 1448 : 
; 1449 : 		if (players[i].score == score)

  000e1	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  000eb	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  000f1	3b 8d 48 ff ff
	ff		 cmp	 ecx, DWORD PTR _score$[ebp]
  000f7	75 11		 jne	 SHORT $LN46@Y_Calculat

; 1450 : 		{
; 1451 : 			n++;

  000f9	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  000ff	83 c0 01	 add	 eax, 1
  00102	89 85 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1452 : 			continue;

  00108	eb 91		 jmp	 SHORT $LN2@Y_Calculat
$LN46@Y_Calculat:

; 1453 : 		}
; 1454 : 
; 1455 : 		n = 1; // number of players with this score

  0010a	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$[ebp], 1

; 1456 : 		score = players[i].score; // best score so far

  00114	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  0011e	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  00124	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _score$[ebp], ecx

; 1457 : 		winners[0] = i; // winner so far

  0012a	b8 04 00 00 00	 mov	 eax, 4
  0012f	6b c8 00	 imul	 ecx, eax, 0
  00132	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00138	89 54 0d e8	 mov	 DWORD PTR _winners$[ebp+ecx], edx

; 1458 : 	}

  0013c	e9 5a ff ff ff	 jmp	 $LN2@Y_Calculat
$LN3@Y_Calculat:

; 1459 : 
; 1460 : 	if (n == 1)

  00141	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _n$[ebp], 1
  00148	75 2b		 jne	 SHORT $LN47@Y_Calculat

; 1461 : 		numwins[winners[0]]++;

  0014a	b8 04 00 00 00	 mov	 eax, 4
  0014f	6b c8 00	 imul	 ecx, eax, 0
  00152	8b 54 0d e8	 mov	 edx, DWORD PTR _winners$[ebp+ecx]
  00156	8b 84 95 68 ff
	ff ff		 mov	 eax, DWORD PTR _numwins$[ebp+edx*4]
  0015d	83 c0 01	 add	 eax, 1
  00160	b9 04 00 00 00	 mov	 ecx, 4
  00165	6b d1 00	 imul	 edx, ecx, 0
  00168	8b 4c 15 e8	 mov	 ecx, DWORD PTR _winners$[ebp+edx]
  0016c	89 84 8d 68 ff
	ff ff		 mov	 DWORD PTR _numwins$[ebp+ecx*4], eax
  00173	eb 10		 jmp	 SHORT $LN48@Y_Calculat
$LN47@Y_Calculat:

; 1462 : 	else
; 1463 : 		winners[0] = -1; // tie

  00175	b8 04 00 00 00	 mov	 eax, 4
  0017a	6b c8 00	 imul	 ecx, eax, 0
  0017d	c7 44 0d e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+ecx], -1
$LN48@Y_Calculat:

; 1464 : 
; 1465 : 	// Find the lowest time.
; 1466 : 	for (i = 0, n = 0, racetime = leveltime; i < MAXPLAYERS; i++)

  00185	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0018f	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _leveltime
  0019e	89 85 44 ff ff
	ff		 mov	 DWORD PTR _racetime$[ebp], eax
  001a4	eb 0f		 jmp	 SHORT $LN7@Y_Calculat
$LN5@Y_Calculat:
  001a6	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001ac	83 c0 01	 add	 eax, 1
  001af	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN7@Y_Calculat:
  001b5	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  001bc	0f 8d 8a 00 00
	00		 jge	 $LN6@Y_Calculat

; 1467 : 	{
; 1468 : 		if (!playeringame[i] || players[i].realtime > racetime)

  001c2	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  001c8	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  001d0	74 18		 je	 SHORT $LN50@Y_Calculat
  001d2	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  001dc	8b 88 54 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+340]
  001e2	3b 8d 44 ff ff
	ff		 cmp	 ecx, DWORD PTR _racetime$[ebp]
  001e8	76 02		 jbe	 SHORT $LN49@Y_Calculat
$LN50@Y_Calculat:

; 1469 : 			continue;

  001ea	eb ba		 jmp	 SHORT $LN5@Y_Calculat
$LN49@Y_Calculat:

; 1470 : 
; 1471 : 		if (players[i].realtime == racetime)

  001ec	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  001f6	8b 88 54 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+340]
  001fc	3b 8d 44 ff ff
	ff		 cmp	 ecx, DWORD PTR _racetime$[ebp]
  00202	75 11		 jne	 SHORT $LN51@Y_Calculat

; 1472 : 		{
; 1473 : 			n++;

  00204	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  0020a	83 c0 01	 add	 eax, 1
  0020d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1474 : 			continue;

  00213	eb 91		 jmp	 SHORT $LN5@Y_Calculat
$LN51@Y_Calculat:

; 1475 : 		}
; 1476 : 
; 1477 : 		n = 1; // number of players with this time

  00215	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$[ebp], 1

; 1478 : 		racetime = players[i].realtime; // best time so far

  0021f	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  00229	8b 88 54 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+340]
  0022f	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _racetime$[ebp], ecx

; 1479 : 		winners[1] = i; // winner so far

  00235	b8 04 00 00 00	 mov	 eax, 4
  0023a	c1 e0 00	 shl	 eax, 0
  0023d	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00243	89 4c 05 e8	 mov	 DWORD PTR _winners$[ebp+eax], ecx

; 1480 : 	}

  00247	e9 5a ff ff ff	 jmp	 $LN5@Y_Calculat
$LN6@Y_Calculat:

; 1481 : 
; 1482 : 	if (n == 1)

  0024c	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _n$[ebp], 1
  00253	75 2b		 jne	 SHORT $LN52@Y_Calculat

; 1483 : 		numwins[winners[1]]++;

  00255	b8 04 00 00 00	 mov	 eax, 4
  0025a	c1 e0 00	 shl	 eax, 0
  0025d	8b 4c 05 e8	 mov	 ecx, DWORD PTR _winners$[ebp+eax]
  00261	8b 94 8d 68 ff
	ff ff		 mov	 edx, DWORD PTR _numwins$[ebp+ecx*4]
  00268	83 c2 01	 add	 edx, 1
  0026b	b8 04 00 00 00	 mov	 eax, 4
  00270	c1 e0 00	 shl	 eax, 0
  00273	8b 4c 05 e8	 mov	 ecx, DWORD PTR _winners$[ebp+eax]
  00277	89 94 8d 68 ff
	ff ff		 mov	 DWORD PTR _numwins$[ebp+ecx*4], edx
  0027e	eb 10		 jmp	 SHORT $LN53@Y_Calculat
$LN52@Y_Calculat:

; 1484 : 	else
; 1485 : 		winners[1] = -1; // tie

  00280	b8 04 00 00 00	 mov	 eax, 4
  00285	c1 e0 00	 shl	 eax, 0
  00288	c7 44 05 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+eax], -1
$LN53@Y_Calculat:

; 1486 : 
; 1487 : 	// Find the highest ring count.
; 1488 : 	for (i = 0, n = 0, ring = -1; i < MAXPLAYERS; i++)

  00290	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0029a	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  002a4	c7 85 5c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _ring$[ebp], -1
  002ae	eb 0f		 jmp	 SHORT $LN10@Y_Calculat
$LN8@Y_Calculat:
  002b0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  002b6	83 c0 01	 add	 eax, 1
  002b9	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN10@Y_Calculat:
  002bf	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  002c6	0f 8d 16 01 00
	00		 jge	 $LN9@Y_Calculat

; 1489 : 	{
; 1490 : 		if (!playeringame[i] || (players[i].health ? players[i].health-1 : 0) < ring)

  002cc	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  002d2	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  002da	74 46		 je	 SHORT $LN55@Y_Calculat
  002dc	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  002e6	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  002ed	74 1b		 je	 SHORT $LN99@Y_Calculat
  002ef	69 8d 64 ff ff
	ff fc 01 00 00	 imul	 ecx, DWORD PTR _i$[ebp], 508
  002f9	8b 91 28 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+40]
  002ff	83 ea 01	 sub	 edx, 1
  00302	89 95 f8 fe ff
	ff		 mov	 DWORD PTR tv192[ebp], edx
  00308	eb 0a		 jmp	 SHORT $LN100@Y_Calculat
$LN99@Y_Calculat:
  0030a	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv192[ebp], 0
$LN100@Y_Calculat:
  00314	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv192[ebp]
  0031a	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _ring$[ebp]
  00320	7d 02		 jge	 SHORT $LN54@Y_Calculat
$LN55@Y_Calculat:

; 1491 : 			continue;

  00322	eb 8c		 jmp	 SHORT $LN8@Y_Calculat
$LN54@Y_Calculat:

; 1492 : 
; 1493 : 		if ((players[i].health ? players[i].health-1 : 0) == ring)

  00324	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  0032e	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  00335	74 1b		 je	 SHORT $LN101@Y_Calculat
  00337	69 8d 64 ff ff
	ff fc 01 00 00	 imul	 ecx, DWORD PTR _i$[ebp], 508
  00341	8b 91 28 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+40]
  00347	83 ea 01	 sub	 edx, 1
  0034a	89 95 f8 fe ff
	ff		 mov	 DWORD PTR tv202[ebp], edx
  00350	eb 0a		 jmp	 SHORT $LN102@Y_Calculat
$LN101@Y_Calculat:
  00352	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv202[ebp], 0
$LN102@Y_Calculat:
  0035c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv202[ebp]
  00362	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _ring$[ebp]
  00368	75 14		 jne	 SHORT $LN56@Y_Calculat

; 1494 : 		{
; 1495 : 			n++;

  0036a	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00370	83 c0 01	 add	 eax, 1
  00373	89 85 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1496 : 			continue;

  00379	e9 32 ff ff ff	 jmp	 $LN8@Y_Calculat
$LN56@Y_Calculat:

; 1497 : 		}
; 1498 : 
; 1499 : 		n = 1; // number of players with this many rings

  0037e	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$[ebp], 1

; 1500 : 		ring = (players[i].health ? players[i].health-1 : 0); // best ring count so far

  00388	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  00392	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  00399	74 1b		 je	 SHORT $LN103@Y_Calculat
  0039b	69 8d 64 ff ff
	ff fc 01 00 00	 imul	 ecx, DWORD PTR _i$[ebp], 508
  003a5	8b 91 28 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+40]
  003ab	83 ea 01	 sub	 edx, 1
  003ae	89 95 f8 fe ff
	ff		 mov	 DWORD PTR tv213[ebp], edx
  003b4	eb 0a		 jmp	 SHORT $LN104@Y_Calculat
$LN103@Y_Calculat:
  003b6	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv213[ebp], 0
$LN104@Y_Calculat:
  003c0	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv213[ebp]
  003c6	89 85 5c ff ff
	ff		 mov	 DWORD PTR _ring$[ebp], eax

; 1501 : 		winners[2] = i; // winner so far

  003cc	b8 04 00 00 00	 mov	 eax, 4
  003d1	d1 e0		 shl	 eax, 1
  003d3	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  003d9	89 4c 05 e8	 mov	 DWORD PTR _winners$[ebp+eax], ecx

; 1502 : 	}

  003dd	e9 ce fe ff ff	 jmp	 $LN8@Y_Calculat
$LN9@Y_Calculat:

; 1503 : 
; 1504 : 	if (n == 1)

  003e2	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _n$[ebp], 1
  003e9	75 29		 jne	 SHORT $LN57@Y_Calculat

; 1505 : 		numwins[winners[2]]++;

  003eb	b8 04 00 00 00	 mov	 eax, 4
  003f0	d1 e0		 shl	 eax, 1
  003f2	8b 4c 05 e8	 mov	 ecx, DWORD PTR _winners$[ebp+eax]
  003f6	8b 94 8d 68 ff
	ff ff		 mov	 edx, DWORD PTR _numwins$[ebp+ecx*4]
  003fd	83 c2 01	 add	 edx, 1
  00400	b8 04 00 00 00	 mov	 eax, 4
  00405	d1 e0		 shl	 eax, 1
  00407	8b 4c 05 e8	 mov	 ecx, DWORD PTR _winners$[ebp+eax]
  0040b	89 94 8d 68 ff
	ff ff		 mov	 DWORD PTR _numwins$[ebp+ecx*4], edx
  00412	eb 0f		 jmp	 SHORT $LN58@Y_Calculat
$LN57@Y_Calculat:

; 1506 : 	else
; 1507 : 		winners[2] = -1; // tie

  00414	b8 04 00 00 00	 mov	 eax, 4
  00419	d1 e0		 shl	 eax, 1
  0041b	c7 44 05 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+eax], -1
$LN58@Y_Calculat:

; 1508 : 
; 1509 : 	// Find the highest total ring count.
; 1510 : 	for (i = 0, n = 0, totalring = -1; i < MAXPLAYERS; i++)

  00423	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0042d	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00437	c7 85 58 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _totalring$[ebp], -1
  00441	eb 0f		 jmp	 SHORT $LN13@Y_Calculat
$LN11@Y_Calculat:
  00443	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00449	83 c0 01	 add	 eax, 1
  0044c	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN13@Y_Calculat:
  00452	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00459	0f 8d 8a 00 00
	00		 jge	 $LN12@Y_Calculat

; 1511 : 	{
; 1512 : 		if (!playeringame[i] || players[i].totalring < totalring)

  0045f	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00465	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0046d	74 18		 je	 SHORT $LN60@Y_Calculat
  0046f	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  00479	8b 88 50 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+336]
  0047f	3b 8d 58 ff ff
	ff		 cmp	 ecx, DWORD PTR _totalring$[ebp]
  00485	7d 02		 jge	 SHORT $LN59@Y_Calculat
$LN60@Y_Calculat:

; 1513 : 			continue;

  00487	eb ba		 jmp	 SHORT $LN11@Y_Calculat
$LN59@Y_Calculat:

; 1514 : 
; 1515 : 		if (players[i].totalring == totalring)

  00489	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  00493	8b 88 50 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+336]
  00499	3b 8d 58 ff ff
	ff		 cmp	 ecx, DWORD PTR _totalring$[ebp]
  0049f	75 11		 jne	 SHORT $LN61@Y_Calculat

; 1516 : 		{
; 1517 : 			n++;

  004a1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  004a7	83 c0 01	 add	 eax, 1
  004aa	89 85 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1518 : 			continue;

  004b0	eb 91		 jmp	 SHORT $LN11@Y_Calculat
$LN61@Y_Calculat:

; 1519 : 		}
; 1520 : 
; 1521 : 		n = 1; // number of players with this many total rings

  004b2	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$[ebp], 1

; 1522 : 		totalring = players[i].totalring; // best total ring count so far

  004bc	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  004c6	8b 88 50 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+336]
  004cc	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _totalring$[ebp], ecx

; 1523 : 		winners[3] = i; // winner so far

  004d2	b8 04 00 00 00	 mov	 eax, 4
  004d7	6b c8 03	 imul	 ecx, eax, 3
  004da	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  004e0	89 54 0d e8	 mov	 DWORD PTR _winners$[ebp+ecx], edx

; 1524 : 	}

  004e4	e9 5a ff ff ff	 jmp	 $LN11@Y_Calculat
$LN12@Y_Calculat:

; 1525 : 
; 1526 : 	if (n == 1)

  004e9	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _n$[ebp], 1
  004f0	75 2b		 jne	 SHORT $LN62@Y_Calculat

; 1527 : 		numwins[winners[3]]++;

  004f2	b8 04 00 00 00	 mov	 eax, 4
  004f7	6b c8 03	 imul	 ecx, eax, 3
  004fa	8b 54 0d e8	 mov	 edx, DWORD PTR _winners$[ebp+ecx]
  004fe	8b 84 95 68 ff
	ff ff		 mov	 eax, DWORD PTR _numwins$[ebp+edx*4]
  00505	83 c0 01	 add	 eax, 1
  00508	b9 04 00 00 00	 mov	 ecx, 4
  0050d	6b d1 03	 imul	 edx, ecx, 3
  00510	8b 4c 15 e8	 mov	 ecx, DWORD PTR _winners$[ebp+edx]
  00514	89 84 8d 68 ff
	ff ff		 mov	 DWORD PTR _numwins$[ebp+ecx*4], eax
  0051b	eb 10		 jmp	 SHORT $LN63@Y_Calculat
$LN62@Y_Calculat:

; 1528 : 	else
; 1529 : 		winners[3] = -1; // tie

  0051d	b8 04 00 00 00	 mov	 eax, 4
  00522	6b c8 03	 imul	 ecx, eax, 3
  00525	c7 44 0d e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+ecx], -1
$LN63@Y_Calculat:

; 1530 : 
; 1531 : 	// Find the highest item box count.
; 1532 : 	for (i = 0, n = 0, itembox = -1; i < MAXPLAYERS; i++)

  0052d	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00537	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00541	c7 85 54 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _itembox$[ebp], -1
  0054b	eb 0f		 jmp	 SHORT $LN16@Y_Calculat
$LN14@Y_Calculat:
  0054d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00553	83 c0 01	 add	 eax, 1
  00556	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN16@Y_Calculat:
  0055c	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00563	0f 8d 8a 00 00
	00		 jge	 $LN15@Y_Calculat

; 1533 : 	{
; 1534 : 		if (!playeringame[i] || players[i].numboxes < itembox)

  00569	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0056f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00577	74 18		 je	 SHORT $LN65@Y_Calculat
  00579	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  00583	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+332]
  00589	3b 8d 54 ff ff
	ff		 cmp	 ecx, DWORD PTR _itembox$[ebp]
  0058f	7d 02		 jge	 SHORT $LN64@Y_Calculat
$LN65@Y_Calculat:

; 1535 : 			continue;

  00591	eb ba		 jmp	 SHORT $LN14@Y_Calculat
$LN64@Y_Calculat:

; 1536 : 
; 1537 : 		if (players[i].numboxes == itembox)

  00593	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  0059d	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+332]
  005a3	3b 8d 54 ff ff
	ff		 cmp	 ecx, DWORD PTR _itembox$[ebp]
  005a9	75 11		 jne	 SHORT $LN66@Y_Calculat

; 1538 : 		{
; 1539 : 			n++;

  005ab	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  005b1	83 c0 01	 add	 eax, 1
  005b4	89 85 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1540 : 			continue;

  005ba	eb 91		 jmp	 SHORT $LN14@Y_Calculat
$LN66@Y_Calculat:

; 1541 : 		}
; 1542 : 
; 1543 : 		n = 1; // number of players with this many item boxes

  005bc	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$[ebp], 1

; 1544 : 		itembox = players[i].numboxes; // best item box count so far

  005c6	69 85 64 ff ff
	ff fc 01 00 00	 imul	 eax, DWORD PTR _i$[ebp], 508
  005d0	8b 88 4c 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+332]
  005d6	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _itembox$[ebp], ecx

; 1545 : 		winners[4] = i; // winner so far

  005dc	b8 04 00 00 00	 mov	 eax, 4
  005e1	c1 e0 02	 shl	 eax, 2
  005e4	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  005ea	89 4c 05 e8	 mov	 DWORD PTR _winners$[ebp+eax], ecx

; 1546 : 	}

  005ee	e9 5a ff ff ff	 jmp	 $LN14@Y_Calculat
$LN15@Y_Calculat:

; 1547 : 
; 1548 : 	if (n == 1)

  005f3	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _n$[ebp], 1
  005fa	75 2b		 jne	 SHORT $LN67@Y_Calculat

; 1549 : 		numwins[winners[4]]++;

  005fc	b8 04 00 00 00	 mov	 eax, 4
  00601	c1 e0 02	 shl	 eax, 2
  00604	8b 4c 05 e8	 mov	 ecx, DWORD PTR _winners$[ebp+eax]
  00608	8b 94 8d 68 ff
	ff ff		 mov	 edx, DWORD PTR _numwins$[ebp+ecx*4]
  0060f	83 c2 01	 add	 edx, 1
  00612	b8 04 00 00 00	 mov	 eax, 4
  00617	c1 e0 02	 shl	 eax, 2
  0061a	8b 4c 05 e8	 mov	 ecx, DWORD PTR _winners$[ebp+eax]
  0061e	89 94 8d 68 ff
	ff ff		 mov	 DWORD PTR _numwins$[ebp+ecx*4], edx
  00625	eb 10		 jmp	 SHORT $LN68@Y_Calculat
$LN67@Y_Calculat:

; 1550 : 	else
; 1551 : 		winners[4] = -1; // tie

  00627	b8 04 00 00 00	 mov	 eax, 4
  0062c	c1 e0 02	 shl	 eax, 2
  0062f	c7 44 05 e8 ff
	ff ff ff	 mov	 DWORD PTR _winners$[ebp+eax], -1
$LN68@Y_Calculat:

; 1552 : 
; 1553 : 	numplayersingame = 0;

  00637	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _numplayersingame$[ebp], 0

; 1554 : 	for (i = 0; i < MAXPLAYERS; i++)

  00641	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0064b	eb 0f		 jmp	 SHORT $LN19@Y_Calculat
$LN17@Y_Calculat:
  0064d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00653	83 c0 01	 add	 eax, 1
  00656	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN19@Y_Calculat:
  0065c	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00663	7d 21		 jge	 SHORT $LN18@Y_Calculat

; 1555 : 	{
; 1556 : 		if (playeringame[i])

  00665	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0066b	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00673	74 0f		 je	 SHORT $LN69@Y_Calculat

; 1557 : 			numplayersingame++;

  00675	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _numplayersingame$[ebp]
  0067b	83 c0 01	 add	 eax, 1
  0067e	89 85 4c ff ff
	ff		 mov	 DWORD PTR _numplayersingame$[ebp], eax
$LN69@Y_Calculat:

; 1558 : 	}

  00684	eb c7		 jmp	 SHORT $LN17@Y_Calculat
$LN18@Y_Calculat:

; 1559 : 
; 1560 : 	// Decide which players to display in the list.
; 1561 : 	if (numplayersingame <= 4) // This is easy!

  00686	83 bd 4c ff ff
	ff 04		 cmp	 DWORD PTR _numplayersingame$[ebp], 4
  0068d	0f 8f aa 00 00
	00		 jg	 $LN70@Y_Calculat

; 1562 : 	{
; 1563 : 		data.race.numplayersshown = numplayersingame;

  00693	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _numplayersingame$[ebp]
  00699	a3 80 00 00 00	 mov	 DWORD PTR _data+128, eax

; 1564 : 		for (i = 0, n = 0; i < MAXPLAYERS; i++)

  0069e	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  006a8	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  006b2	eb 0f		 jmp	 SHORT $LN22@Y_Calculat
$LN20@Y_Calculat:
  006b4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  006ba	83 c0 01	 add	 eax, 1
  006bd	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN22@Y_Calculat:
  006c3	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  006ca	7d 34		 jge	 SHORT $LN21@Y_Calculat

; 1565 : 			if (playeringame[i])

  006cc	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  006d2	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  006da	74 22		 je	 SHORT $LN72@Y_Calculat

; 1566 : 				data.race.playersshown[n++] = i;

  006dc	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  006e2	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  006e8	89 0c 85 84 00
	00 00		 mov	 DWORD PTR _data[eax*4+132], ecx
  006ef	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  006f5	83 c2 01	 add	 edx, 1
  006f8	89 95 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], edx
$LN72@Y_Calculat:
  006fe	eb b4		 jmp	 SHORT $LN20@Y_Calculat
$LN21@Y_Calculat:

; 1567 : 
; 1568 : 		for (i = data.race.numplayersshown; i < 4; i++)

  00700	a1 80 00 00 00	 mov	 eax, DWORD PTR _data+128
  00705	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
  0070b	eb 0f		 jmp	 SHORT $LN25@Y_Calculat
$LN23@Y_Calculat:
  0070d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00713	83 c0 01	 add	 eax, 1
  00716	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN25@Y_Calculat:
  0071c	83 bd 64 ff ff
	ff 04		 cmp	 DWORD PTR _i$[ebp], 4
  00723	7d 13		 jge	 SHORT $LN24@Y_Calculat

; 1569 : 			data.race.playersshown[i] = -1; // no player here

  00725	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0072b	c7 04 85 84 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR _data[eax*4+132], -1
  00736	eb d5		 jmp	 SHORT $LN23@Y_Calculat
$LN24@Y_Calculat:

; 1570 : 	}

  00738	e9 2d 01 00 00	 jmp	 $LN27@Y_Calculat
$LN70@Y_Calculat:

; 1571 : 	else // This is hard!
; 1572 : 	{
; 1573 : 		INT32 j, k;
; 1574 : 
; 1575 : 		data.race.numplayersshown = 4;

  0073d	c7 05 80 00 00
	00 04 00 00 00	 mov	 DWORD PTR _data+128, 4

; 1576 : 		for (i = 0, n = 0; i < MAXPLAYERS; i++)

  00747	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00751	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  0075b	eb 0f		 jmp	 SHORT $LN28@Y_Calculat
$LN26@Y_Calculat:
  0075d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00763	83 c0 01	 add	 eax, 1
  00766	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN28@Y_Calculat:
  0076c	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00773	0f 8d f1 00 00
	00		 jge	 $LN27@Y_Calculat

; 1577 : 			if (playeringame[i])

  00779	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0077f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00787	0f 84 d8 00 00
	00		 je	 $LN73@Y_Calculat

; 1578 : 			{
; 1579 : 				if (n < 4)

  0078d	83 bd 60 ff ff
	ff 04		 cmp	 DWORD PTR _n$[ebp], 4
  00794	7d 24		 jge	 SHORT $LN74@Y_Calculat

; 1580 : 				{
; 1581 : 					data.race.playersshown[n++] = i;

  00796	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  0079c	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  007a2	89 0c 85 84 00
	00 00		 mov	 DWORD PTR _data[eax*4+132], ecx
  007a9	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  007af	83 c2 01	 add	 edx, 1
  007b2	89 95 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], edx

; 1582 : 					continue;

  007b8	eb a3		 jmp	 SHORT $LN26@Y_Calculat
$LN74@Y_Calculat:

; 1583 : 				}
; 1584 : 
; 1585 : 				// n == 4, meaning all four slots are full.
; 1586 : 
; 1587 : 				if (!numwins[i])

  007ba	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  007c0	83 bc 85 68 ff
	ff ff 00	 cmp	 DWORD PTR _numwins$[ebp+eax*4], 0
  007c8	75 02		 jne	 SHORT $LN75@Y_Calculat

; 1588 : 					continue;

  007ca	eb 91		 jmp	 SHORT $LN26@Y_Calculat
$LN75@Y_Calculat:

; 1589 : 
; 1590 : 				// But this player won at least one category, so maybe he can
; 1591 : 				// replace one who didn't.
; 1592 : 
; 1593 : 				for (j = 3; j >= 0; j--)

  007cc	c7 85 40 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _j$2[ebp], 3
  007d6	eb 0f		 jmp	 SHORT $LN31@Y_Calculat
$LN29@Y_Calculat:
  007d8	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  007de	83 e8 01	 sub	 eax, 1
  007e1	89 85 40 ff ff
	ff		 mov	 DWORD PTR _j$2[ebp], eax
$LN31@Y_Calculat:
  007e7	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _j$2[ebp], 0
  007ee	7c 14		 jl	 SHORT $LN30@Y_Calculat

; 1594 : 					if (!numwins[j])

  007f0	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  007f6	83 bc 85 68 ff
	ff ff 00	 cmp	 DWORD PTR _numwins$[ebp+eax*4], 0
  007fe	75 02		 jne	 SHORT $LN76@Y_Calculat

; 1595 : 						break;

  00800	eb 02		 jmp	 SHORT $LN30@Y_Calculat
$LN76@Y_Calculat:
  00802	eb d4		 jmp	 SHORT $LN29@Y_Calculat
$LN30@Y_Calculat:

; 1596 : 
; 1597 : 				if (j < 0)

  00804	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR _j$2[ebp], 0
  0080b	7d 02		 jge	 SHORT $LN77@Y_Calculat

; 1598 : 					break; // Five winners, four slots. Sorry, you get stiffed.

  0080d	eb 5b		 jmp	 SHORT $LN27@Y_Calculat
$LN77@Y_Calculat:

; 1599 : 
; 1600 : 				// j (0 <= j <= 3) is a slot whose player did not win any
; 1601 : 				// categories. Player i can go here instead.
; 1602 : 
; 1603 : 				// If j < 3, first we need to move the other displayed players
; 1604 : 				// back one.
; 1605 : 
; 1606 : 				for (k = j; k < 3; k++)

  0080f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _j$2[ebp]
  00815	89 85 3c ff ff
	ff		 mov	 DWORD PTR _k$1[ebp], eax
  0081b	eb 0f		 jmp	 SHORT $LN34@Y_Calculat
$LN32@Y_Calculat:
  0081d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _k$1[ebp]
  00823	83 c0 01	 add	 eax, 1
  00826	89 85 3c ff ff
	ff		 mov	 DWORD PTR _k$1[ebp], eax
$LN34@Y_Calculat:
  0082c	83 bd 3c ff ff
	ff 03		 cmp	 DWORD PTR _k$1[ebp], 3
  00833	7d 1c		 jge	 SHORT $LN33@Y_Calculat

; 1607 : 					data.race.playersshown[k] = data.race.playersshown[k+1];

  00835	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _k$1[ebp]
  0083b	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _k$1[ebp]
  00841	8b 14 8d 88 00
	00 00		 mov	 edx, DWORD PTR _data[ecx*4+136]
  00848	89 14 85 84 00
	00 00		 mov	 DWORD PTR _data[eax*4+132], edx
  0084f	eb cc		 jmp	 SHORT $LN32@Y_Calculat
$LN33@Y_Calculat:

; 1608 : 
; 1609 : 				// Now player i gets his rightful position.
; 1610 : 
; 1611 : 				data.race.playersshown[3] = i;

  00851	b8 04 00 00 00	 mov	 eax, 4
  00856	6b c8 03	 imul	 ecx, eax, 3
  00859	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0085f	89 91 84 00 00
	00		 mov	 DWORD PTR _data[ecx+132], edx
$LN73@Y_Calculat:

; 1612 : 			}

  00865	e9 f3 fe ff ff	 jmp	 $LN26@Y_Calculat
$LN27@Y_Calculat:

; 1613 : 	}
; 1614 : 
; 1615 : 	// Set up the winner string for each category.
; 1616 : 	//  "1P", "2P", "3P", "4P", "5P" or "T"
; 1617 : 	for (i = 0; i < 5; i++)

  0086a	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00874	eb 0f		 jmp	 SHORT $LN37@Y_Calculat
$LN35@Y_Calculat:
  00876	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0087c	83 c0 01	 add	 eax, 1
  0087f	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN37@Y_Calculat:
  00885	83 bd 64 ff ff
	ff 05		 cmp	 DWORD PTR _i$[ebp], 5
  0088c	0f 8d ef 00 00
	00		 jge	 $LN36@Y_Calculat

; 1618 : 	{
; 1619 : 		if (winners[i] == -1)

  00892	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00898	83 7c 85 e8 ff	 cmp	 DWORD PTR _winners$[ebp+eax*4], -1
  0089d	75 16		 jne	 SHORT $LN78@Y_Calculat

; 1620 : 			data.race.winnerstrings[i] = "T";

  0089f	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  008a5	c7 04 85 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _data[eax*4+148], OFFSET ??_C@_01GAPBHFFA@T@
  008b0	e9 c7 00 00 00	 jmp	 $LN87@Y_Calculat
$LN78@Y_Calculat:

; 1621 : 		else if (winners[i] == data.race.playersshown[0])

  008b5	b8 04 00 00 00	 mov	 eax, 4
  008ba	6b c8 00	 imul	 ecx, eax, 0
  008bd	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  008c3	8b 44 95 e8	 mov	 eax, DWORD PTR _winners$[ebp+edx*4]
  008c7	3b 81 84 00 00
	00		 cmp	 eax, DWORD PTR _data[ecx+132]
  008cd	75 16		 jne	 SHORT $LN80@Y_Calculat

; 1622 : 			data.race.winnerstrings[i] = "1P";

  008cf	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  008d5	c7 04 85 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _data[eax*4+148], OFFSET ??_C@_02JPKMPEBO@1P@
  008e0	e9 97 00 00 00	 jmp	 $LN87@Y_Calculat
$LN80@Y_Calculat:

; 1623 : 		else if (winners[i] == data.race.playersshown[1])

  008e5	b8 04 00 00 00	 mov	 eax, 4
  008ea	c1 e0 00	 shl	 eax, 0
  008ed	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  008f3	8b 54 8d e8	 mov	 edx, DWORD PTR _winners$[ebp+ecx*4]
  008f7	3b 90 84 00 00
	00		 cmp	 edx, DWORD PTR _data[eax+132]
  008fd	75 13		 jne	 SHORT $LN82@Y_Calculat

; 1624 : 			data.race.winnerstrings[i] = "2P";

  008ff	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00905	c7 04 85 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _data[eax*4+148], OFFSET ??_C@_02JNOKEKEH@2P@
  00910	eb 6a		 jmp	 SHORT $LN87@Y_Calculat
$LN82@Y_Calculat:

; 1625 : 		else if (winners[i] == data.race.playersshown[2])

  00912	b8 04 00 00 00	 mov	 eax, 4
  00917	d1 e0		 shl	 eax, 1
  00919	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  0091f	8b 54 8d e8	 mov	 edx, DWORD PTR _winners$[ebp+ecx*4]
  00923	3b 90 84 00 00
	00		 cmp	 edx, DWORD PTR _data[eax+132]
  00929	75 13		 jne	 SHORT $LN84@Y_Calculat

; 1626 : 			data.race.winnerstrings[i] = "3P";

  0092b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00931	c7 04 85 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _data[eax*4+148], OFFSET ??_C@_02JMCICAHA@3P@
  0093c	eb 3e		 jmp	 SHORT $LN87@Y_Calculat
$LN84@Y_Calculat:

; 1627 : 		else if (winners[i] == data.race.playersshown[3])

  0093e	b8 04 00 00 00	 mov	 eax, 4
  00943	6b c8 03	 imul	 ecx, eax, 3
  00946	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0094c	8b 44 95 e8	 mov	 eax, DWORD PTR _winners$[ebp+edx*4]
  00950	3b 81 84 00 00
	00		 cmp	 eax, DWORD PTR _data[ecx+132]
  00956	75 13		 jne	 SHORT $LN86@Y_Calculat

; 1628 : 			data.race.winnerstrings[i] = "4P";

  00958	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0095e	c7 04 85 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _data[eax*4+148], OFFSET ??_C@_02JJGHDGPF@4P@
  00969	eb 11		 jmp	 SHORT $LN87@Y_Calculat
$LN86@Y_Calculat:

; 1629 : 		else
; 1630 : 			data.race.winnerstrings[i] = "5P";

  0096b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00971	c7 04 85 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _data[eax*4+148], OFFSET ??_C@_02JIKFFMMC@5P@
$LN87@Y_Calculat:

; 1631 : 	}

  0097c	e9 f5 fe ff ff	 jmp	 $LN35@Y_Calculat
$LN36@Y_Calculat:

; 1632 : 
; 1633 : 	// Set up the display slot data.
; 1634 : 	for (i = 0; i < data.race.numplayersshown; i++)

  00981	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0098b	eb 0f		 jmp	 SHORT $LN40@Y_Calculat
$LN38@Y_Calculat:
  0098d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00993	83 c0 01	 add	 eax, 1
  00996	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN40@Y_Calculat:
  0099c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  009a2	3b 05 80 00 00
	00		 cmp	 eax, DWORD PTR _data+128
  009a8	0f 8d 25 02 00
	00		 jge	 $LN39@Y_Calculat

; 1635 : 	{
; 1636 : 		data.race.scores[i] = players[data.race.playersshown[i]].score;

  009ae	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  009b4	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  009bf	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  009c5	8b 81 bc 00 00
	00		 mov	 eax, DWORD PTR _players[ecx+188]
  009cb	89 04 95 00 00
	00 00		 mov	 DWORD PTR _data[edx*4], eax

; 1637 : 		data.race.timemin[i] = G_TicsToMinutes(players[data.race.playersshown[i]].realtime, true);

  009d2	6a 01		 push	 1
  009d4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  009da	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  009e5	8b 91 54 01 00
	00		 mov	 edx, DWORD PTR _players[ecx+340]
  009eb	52		 push	 edx
  009ec	e8 00 00 00 00	 call	 _G_TicsToMinutes
  009f1	83 c4 08	 add	 esp, 8
  009f4	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  009fa	89 04 8d 10 00
	00 00		 mov	 DWORD PTR _data[ecx*4+16], eax

; 1638 : 		data.race.timesec[i] = G_TicsToSeconds(players[data.race.playersshown[i]].realtime);

  00a01	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00a07	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  00a12	8b 91 54 01 00
	00		 mov	 edx, DWORD PTR _players[ecx+340]
  00a18	52		 push	 edx
  00a19	e8 00 00 00 00	 call	 _G_TicsToSeconds
  00a1e	83 c4 04	 add	 esp, 4
  00a21	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00a27	89 04 8d 20 00
	00 00		 mov	 DWORD PTR _data[ecx*4+32], eax

; 1639 : 		data.race.timetic[i] = G_TicsToCentiseconds(players[data.race.playersshown[i]].realtime);

  00a2e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00a34	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  00a3f	8b 91 54 01 00
	00		 mov	 edx, DWORD PTR _players[ecx+340]
  00a45	52		 push	 edx
  00a46	e8 00 00 00 00	 call	 _G_TicsToCentiseconds
  00a4b	83 c4 04	 add	 esp, 4
  00a4e	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00a54	89 04 8d 30 00
	00 00		 mov	 DWORD PTR _data[ecx*4+48], eax

; 1640 : 		data.race.rings[i] = players[data.race.playersshown[i]].health ? players[data.race.playersshown[i]].health-1 : 0;

  00a5b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00a61	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  00a6c	83 b9 28 00 00
	00 00		 cmp	 DWORD PTR _players[ecx+40], 0
  00a73	74 22		 je	 SHORT $LN105@Y_Calculat
  00a75	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00a7b	69 04 95 84 00
	00 00 fc 01 00
	00		 imul	 eax, DWORD PTR _data[edx*4+132], 508
  00a86	8b 88 28 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+40]
  00a8c	83 e9 01	 sub	 ecx, 1
  00a8f	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv436[ebp], ecx
  00a95	eb 0a		 jmp	 SHORT $LN106@Y_Calculat
$LN105@Y_Calculat:
  00a97	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv436[ebp], 0
$LN106@Y_Calculat:
  00aa1	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00aa7	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv436[ebp]
  00aad	89 04 95 40 00
	00 00		 mov	 DWORD PTR _data[edx*4+64], eax

; 1641 : 		data.race.totalrings[i] = players[data.race.playersshown[i]].totalring;

  00ab4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00aba	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  00ac5	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00acb	8b 81 50 01 00
	00		 mov	 eax, DWORD PTR _players[ecx+336]
  00ad1	89 04 95 50 00
	00 00		 mov	 DWORD PTR _data[edx*4+80], eax

; 1642 : 		data.race.itemboxes[i] = players[data.race.playersshown[i]].numboxes;

  00ad8	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00ade	69 0c 85 84 00
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+132], 508
  00ae9	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00aef	8b 81 4c 01 00
	00		 mov	 eax, DWORD PTR _players[ecx+332]
  00af5	89 04 95 60 00
	00 00		 mov	 DWORD PTR _data[edx*4+96], eax

; 1643 : 		data.race.totalwins[i] = numwins[data.race.playersshown[i]];

  00afc	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b02	8b 0c 85 84 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+132]
  00b09	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00b0f	8b 84 8d 68 ff
	ff ff		 mov	 eax, DWORD PTR _numwins$[ebp+ecx*4]
  00b16	89 04 95 70 00
	00 00		 mov	 DWORD PTR _data[edx*4+112], eax

; 1644 : 
; 1645 : 		// Make sure it's in bounds so it won't screw up the display.
; 1646 : 		if (data.race.scores[i] > 999999)

  00b1d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b23	81 3c 85 00 00
	00 00 3f 42 0f
	00		 cmp	 DWORD PTR _data[eax*4], 999999 ; 000f423fH
  00b2e	76 11		 jbe	 SHORT $LN88@Y_Calculat

; 1647 : 			data.race.scores[i] = 999999;

  00b30	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b36	c7 04 85 00 00
	00 00 3f 42 0f
	00		 mov	 DWORD PTR _data[eax*4], 999999 ; 000f423fH
$LN88@Y_Calculat:

; 1648 : 		if (data.race.timemin[i] > 99)

  00b41	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b47	83 3c 85 10 00
	00 00 63	 cmp	 DWORD PTR _data[eax*4+16], 99 ; 00000063H
  00b4f	7e 11		 jle	 SHORT $LN89@Y_Calculat

; 1649 : 			data.race.timemin[i] = 99;

  00b51	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b57	c7 04 85 10 00
	00 00 63 00 00
	00		 mov	 DWORD PTR _data[eax*4+16], 99 ; 00000063H
$LN89@Y_Calculat:

; 1650 : 		if (data.race.rings[i] > 999)

  00b62	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b68	81 3c 85 40 00
	00 00 e7 03 00
	00		 cmp	 DWORD PTR _data[eax*4+64], 999 ; 000003e7H
  00b73	7e 11		 jle	 SHORT $LN90@Y_Calculat

; 1651 : 			data.race.rings[i] = 999;

  00b75	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b7b	c7 04 85 40 00
	00 00 e7 03 00
	00		 mov	 DWORD PTR _data[eax*4+64], 999 ; 000003e7H
$LN90@Y_Calculat:

; 1652 : 		if (data.race.totalrings[i] > 999)

  00b86	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b8c	81 3c 85 50 00
	00 00 e7 03 00
	00		 cmp	 DWORD PTR _data[eax*4+80], 999 ; 000003e7H
  00b97	7e 11		 jle	 SHORT $LN91@Y_Calculat

; 1653 : 			data.race.totalrings[i] = 999;

  00b99	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00b9f	c7 04 85 50 00
	00 00 e7 03 00
	00		 mov	 DWORD PTR _data[eax*4+80], 999 ; 000003e7H
$LN91@Y_Calculat:

; 1654 : 		if (data.race.itemboxes[i] > 999)

  00baa	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bb0	81 3c 85 60 00
	00 00 e7 03 00
	00		 cmp	 DWORD PTR _data[eax*4+96], 999 ; 000003e7H
  00bbb	7e 11		 jle	 SHORT $LN92@Y_Calculat

; 1655 : 			data.race.itemboxes[i] = 999;

  00bbd	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bc3	c7 04 85 60 00
	00 00 e7 03 00
	00		 mov	 DWORD PTR _data[eax*4+96], 999 ; 000003e7H
$LN92@Y_Calculat:

; 1656 : 	}

  00bce	e9 ba fd ff ff	 jmp	 $LN38@Y_Calculat
$LN39@Y_Calculat:

; 1657 : 
; 1658 : 	// Find the overall winner.
; 1659 : 	for (i = 0, n = 0, wins = 0; i < MAXPLAYERS; i++)

  00bd3	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00bdd	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00be7	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _wins$[ebp], 0
  00bf1	eb 0f		 jmp	 SHORT $LN43@Y_Calculat
$LN41@Y_Calculat:
  00bf3	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bf9	83 c0 01	 add	 eax, 1
  00bfc	89 85 64 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN43@Y_Calculat:
  00c02	83 bd 64 ff ff
	ff 20		 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00c09	7d 7a		 jge	 SHORT $LN42@Y_Calculat

; 1660 : 	{
; 1661 : 		if (!playeringame[i] || numwins[i] < wins)

  00c0b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c11	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00c19	74 15		 je	 SHORT $LN94@Y_Calculat
  00c1b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c21	8b 8c 85 68 ff
	ff ff		 mov	 ecx, DWORD PTR _numwins$[ebp+eax*4]
  00c28	3b 8d 50 ff ff
	ff		 cmp	 ecx, DWORD PTR _wins$[ebp]
  00c2e	7d 02		 jge	 SHORT $LN93@Y_Calculat
$LN94@Y_Calculat:

; 1662 : 			continue;

  00c30	eb c1		 jmp	 SHORT $LN41@Y_Calculat
$LN93@Y_Calculat:

; 1663 : 
; 1664 : 		if (numwins[i] == wins)

  00c32	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c38	8b 8c 85 68 ff
	ff ff		 mov	 ecx, DWORD PTR _numwins$[ebp+eax*4]
  00c3f	3b 8d 50 ff ff
	ff		 cmp	 ecx, DWORD PTR _wins$[ebp]
  00c45	75 11		 jne	 SHORT $LN95@Y_Calculat

; 1665 : 		{
; 1666 : 			n++;

  00c47	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00c4d	83 c0 01	 add	 eax, 1
  00c50	89 85 60 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], eax

; 1667 : 			continue;

  00c56	eb 9b		 jmp	 SHORT $LN41@Y_Calculat
$LN95@Y_Calculat:

; 1668 : 		}
; 1669 : 
; 1670 : 		n = 1; // number of players with this many wins

  00c58	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$[ebp], 1

; 1671 : 		wins = numwins[i]; // best number of wins so far

  00c62	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c68	8b 8c 85 68 ff
	ff ff		 mov	 ecx, DWORD PTR _numwins$[ebp+eax*4]
  00c6f	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _wins$[ebp], ecx

; 1672 : 		data.race.winner = i; // winner so far

  00c75	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00c7b	a3 a8 00 00 00	 mov	 DWORD PTR _data+168, eax

; 1673 : 	}

  00c80	e9 6e ff ff ff	 jmp	 $LN41@Y_Calculat
$LN42@Y_Calculat:

; 1674 : 
; 1675 : 	if (n != 1 || !wins)

  00c85	83 bd 60 ff ff
	ff 01		 cmp	 DWORD PTR _n$[ebp], 1
  00c8c	75 09		 jne	 SHORT $LN97@Y_Calculat
  00c8e	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _wins$[ebp], 0
  00c95	75 0a		 jne	 SHORT $LN96@Y_Calculat
$LN97@Y_Calculat:

; 1676 : 		data.race.winner = -1; // tie

  00c97	c7 05 a8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _data+168, -1
$LN96@Y_Calculat:

; 1677 : }

  00ca1	5f		 pop	 edi
  00ca2	5e		 pop	 esi
  00ca3	5b		 pop	 ebx
  00ca4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ca7	33 cd		 xor	 ecx, ebp
  00ca9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cae	8b e5		 mov	 esp, ebp
  00cb0	5d		 pop	 ebp
  00cb1	c3		 ret	 0
_Y_CalculateRaceWinners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_AwardSpecialStageBonus
_TEXT	SEGMENT
_oldscore$1 = -8					; size = 4
_i$ = -4						; size = 4
_Y_AwardSpecialStageBonus PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1296 : 	INT32 i;
; 1297 : 
; 1298 : 	for (i = 0; i < MAXPLAYERS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Y_AwardSpe
$LN2@Y_AwardSpe:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Y_AwardSpe:
  0001b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0001f	0f 8d 2b 01 00
	00		 jge	 $LN3@Y_AwardSpe

; 1299 : 	{
; 1300 : 		INT32 oldscore;
; 1301 : 
; 1302 : 		if (!playeringame[i])

  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00030	75 02		 jne	 SHORT $LN5@Y_AwardSpe

; 1303 : 			continue;

  00032	eb de		 jmp	 SHORT $LN2@Y_AwardSpe
$LN5@Y_AwardSpe:

; 1304 : 
; 1305 : 		if (i == consoleplayer)

  00034	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00037	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  0003d	75 48		 jne	 SHORT $LN6@Y_AwardSpe

; 1306 : 		{
; 1307 : 			if (players[i].health)

  0003f	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00046	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  0004d	74 1b		 je	 SHORT $LN7@Y_AwardSpe

; 1308 : 				data.spec.ringbonus = (players[i].health-1) * 100;

  0004f	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00056	8b 88 28 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+40]
  0005c	83 e9 01	 sub	 ecx, 1
  0005f	6b d1 64	 imul	 edx, ecx, 100
  00062	89 15 04 00 00
	00		 mov	 DWORD PTR _data+4, edx
  00068	eb 0a		 jmp	 SHORT $LN8@Y_AwardSpe
$LN7@Y_AwardSpe:

; 1309 : 			else
; 1310 : 				data.spec.ringbonus = 0;

  0006a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+4, 0
$LN8@Y_AwardSpe:

; 1311 : 			data.spec.score = players[i].score;

  00074	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0007b	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  00081	89 0d 00 00 00
	00		 mov	 DWORD PTR _data, ecx
$LN6@Y_AwardSpe:

; 1312 : 		}
; 1313 : 
; 1314 : 		oldscore = players[i].score;

  00087	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0008e	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  00094	89 4d f8	 mov	 DWORD PTR _oldscore$1[ebp], ecx

; 1315 : 
; 1316 : 		if (players[i].health)

  00097	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0009e	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  000a5	74 2d		 je	 SHORT $LN9@Y_AwardSpe

; 1317 : 			players[i].score += (players[i].health-1) * 100; // ring bonus

  000a7	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000ae	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  000b5	8b 91 28 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+40]
  000bb	83 ea 01	 sub	 edx, 1
  000be	6b ca 64	 imul	 ecx, edx, 100
  000c1	03 88 bc 00 00
	00		 add	 ecx, DWORD PTR _players[eax+188]
  000c7	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  000ce	89 8a bc 00 00
	00		 mov	 DWORD PTR _players[edx+188], ecx
$LN9@Y_AwardSpe:

; 1318 : 
; 1319 : 		// grant extra lives right away since tally is faked
; 1320 : 		P_GivePlayerLives(&players[i], (players[i].score/50000) - (oldscore/50000));

  000d4	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000db	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR _players[eax+188]
  000e1	33 d2		 xor	 edx, edx
  000e3	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  000e8	f7 f1		 div	 ecx
  000ea	8b c8		 mov	 ecx, eax
  000ec	8b 45 f8	 mov	 eax, DWORD PTR _oldscore$1[ebp]
  000ef	99		 cdq
  000f0	be 50 c3 00 00	 mov	 esi, 50000		; 0000c350H
  000f5	f7 fe		 idiv	 esi
  000f7	2b c8		 sub	 ecx, eax
  000f9	51		 push	 ecx
  000fa	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  00101	81 c2 00 00 00
	00		 add	 edx, OFFSET _players
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 _P_GivePlayerLives
  0010d	83 c4 08	 add	 esp, 8

; 1321 : 
; 1322 : 		if ((players[i].score/50000) - (oldscore/50000) > 0)

  00110	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00117	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR _players[eax+188]
  0011d	33 d2		 xor	 edx, edx
  0011f	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  00124	f7 f1		 div	 ecx
  00126	8b c8		 mov	 ecx, eax
  00128	8b 45 f8	 mov	 eax, DWORD PTR _oldscore$1[ebp]
  0012b	99		 cdq
  0012c	be 50 c3 00 00	 mov	 esi, 50000		; 0000c350H
  00131	f7 fe		 idiv	 esi
  00133	2b c8		 sub	 ecx, eax
  00135	74 0a		 je	 SHORT $LN10@Y_AwardSpe

; 1323 : 			data.coop.gotlife = i;

  00137	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013a	a3 60 00 00 00	 mov	 DWORD PTR _data+96, eax
  0013f	eb 0a		 jmp	 SHORT $LN11@Y_AwardSpe
$LN10@Y_AwardSpe:

; 1324 : 		else
; 1325 : 			data.coop.gotlife = -1;

  00141	c7 05 60 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _data+96, -1
$LN11@Y_AwardSpe:

; 1326 : 	}

  0014b	e9 c2 fe ff ff	 jmp	 $LN2@Y_AwardSpe
$LN3@Y_AwardSpe:

; 1327 : }

  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
_Y_AwardSpecialStageBonus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_AwardCoopBonuses
_TEXT	SEGMENT
_emblemcount$1 = -28					; size = 4
_j$2 = -24						; size = 4
_oldscore$3 = -20					; size = 4
_bonus$4 = -16						; size = 4
_secs$5 = -12						; size = 4
_sharedringtotal$ = -8					; size = 4
_i$ = -4						; size = 4
_Y_AwardCoopBonuses PROC				; COMDAT

; 1176 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1177 : 	INT32 i;
; 1178 : 	INT32 sharedringtotal = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sharedringtotal$[ebp], 0

; 1179 : 
; 1180 : 	for (i = 0; i < MAXPLAYERS; i++)

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@Y_AwardCoo
$LN2@Y_AwardCoo:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Y_AwardCoo:
  00022	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00026	7d 28		 jge	 SHORT $LN3@Y_AwardCoo

; 1181 : 	{
; 1182 : 		//for the sake of my sanity, let's get this out of the way first
; 1183 : 		if (!playeringame[i])

  00028	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00033	75 02		 jne	 SHORT $LN11@Y_AwardCoo

; 1184 : 			continue;

  00035	eb e2		 jmp	 SHORT $LN2@Y_AwardCoo
$LN11@Y_AwardCoo:

; 1185 : 
; 1186 : 		sharedringtotal += players[i].health - 1;

  00037	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0003e	8b 88 28 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+40]
  00044	8b 55 f8	 mov	 edx, DWORD PTR _sharedringtotal$[ebp]
  00047	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
  0004b	89 45 f8	 mov	 DWORD PTR _sharedringtotal$[ebp], eax

; 1187 : 	}

  0004e	eb c9		 jmp	 SHORT $LN2@Y_AwardCoo
$LN3@Y_AwardCoo:

; 1188 : 
; 1189 : 	// with that out of the way, go back to calculating bonuses like usual
; 1190 : 	for (i = 0; i < MAXPLAYERS; i++)

  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN7@Y_AwardCoo
$LN5@Y_AwardCoo:
  00059	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Y_AwardCoo:
  00062	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00066	0f 8d d0 03 00
	00		 jge	 $LN6@Y_AwardCoo

; 1191 : 	{
; 1192 : 		INT32 secs, bonus, oldscore;
; 1193 : 
; 1194 : 		if (!playeringame[i])

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00077	75 02		 jne	 SHORT $LN12@Y_AwardCoo

; 1195 : 			continue;

  00079	eb de		 jmp	 SHORT $LN5@Y_AwardCoo
$LN12@Y_AwardCoo:

; 1196 : 
; 1197 : 		// calculate time bonus
; 1198 : 		secs = players[i].realtime / TICRATE;

  0007b	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00082	8b 80 54 01 00
	00		 mov	 eax, DWORD PTR _players[eax+340]
  00088	33 d2		 xor	 edx, edx
  0008a	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  0008f	f7 f1		 div	 ecx
  00091	89 45 f4	 mov	 DWORD PTR _secs$5[ebp], eax

; 1199 : 		if (secs < 30)

  00094	83 7d f4 1e	 cmp	 DWORD PTR _secs$5[ebp], 30 ; 0000001eH
  00098	7d 09		 jge	 SHORT $LN13@Y_AwardCoo

; 1200 : 			bonus = 50000;

  0009a	c7 45 f0 50 c3
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 50000 ; 0000c350H
  000a1	eb 79		 jmp	 SHORT $LN28@Y_AwardCoo
$LN13@Y_AwardCoo:

; 1201 : 		else if (secs < 45)

  000a3	83 7d f4 2d	 cmp	 DWORD PTR _secs$5[ebp], 45 ; 0000002dH
  000a7	7d 09		 jge	 SHORT $LN15@Y_AwardCoo

; 1202 : 			bonus = 10000;

  000a9	c7 45 f0 10 27
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 10000 ; 00002710H
  000b0	eb 6a		 jmp	 SHORT $LN28@Y_AwardCoo
$LN15@Y_AwardCoo:

; 1203 : 		else if (secs < 60)

  000b2	83 7d f4 3c	 cmp	 DWORD PTR _secs$5[ebp], 60 ; 0000003cH
  000b6	7d 09		 jge	 SHORT $LN17@Y_AwardCoo

; 1204 : 			bonus = 5000;

  000b8	c7 45 f0 88 13
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 5000 ; 00001388H
  000bf	eb 5b		 jmp	 SHORT $LN28@Y_AwardCoo
$LN17@Y_AwardCoo:

; 1205 : 		else if (secs < 90)

  000c1	83 7d f4 5a	 cmp	 DWORD PTR _secs$5[ebp], 90 ; 0000005aH
  000c5	7d 09		 jge	 SHORT $LN19@Y_AwardCoo

; 1206 : 			bonus = 4000;

  000c7	c7 45 f0 a0 0f
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 4000 ; 00000fa0H
  000ce	eb 4c		 jmp	 SHORT $LN28@Y_AwardCoo
$LN19@Y_AwardCoo:

; 1207 : 		else if (secs < 120)

  000d0	83 7d f4 78	 cmp	 DWORD PTR _secs$5[ebp], 120 ; 00000078H
  000d4	7d 09		 jge	 SHORT $LN21@Y_AwardCoo

; 1208 : 			bonus = 3000;

  000d6	c7 45 f0 b8 0b
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 3000 ; 00000bb8H
  000dd	eb 3d		 jmp	 SHORT $LN28@Y_AwardCoo
$LN21@Y_AwardCoo:

; 1209 : 		else if (secs < 180)

  000df	81 7d f4 b4 00
	00 00		 cmp	 DWORD PTR _secs$5[ebp], 180 ; 000000b4H
  000e6	7d 09		 jge	 SHORT $LN23@Y_AwardCoo

; 1210 : 			bonus = 2000;

  000e8	c7 45 f0 d0 07
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 2000 ; 000007d0H
  000ef	eb 2b		 jmp	 SHORT $LN28@Y_AwardCoo
$LN23@Y_AwardCoo:

; 1211 : 		else if (secs < 240)

  000f1	81 7d f4 f0 00
	00 00		 cmp	 DWORD PTR _secs$5[ebp], 240 ; 000000f0H
  000f8	7d 09		 jge	 SHORT $LN25@Y_AwardCoo

; 1212 : 			bonus = 1000;

  000fa	c7 45 f0 e8 03
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 1000 ; 000003e8H
  00101	eb 19		 jmp	 SHORT $LN28@Y_AwardCoo
$LN25@Y_AwardCoo:

; 1213 : 		else if (secs < 300)

  00103	81 7d f4 2c 01
	00 00		 cmp	 DWORD PTR _secs$5[ebp], 300 ; 0000012cH
  0010a	7d 09		 jge	 SHORT $LN27@Y_AwardCoo

; 1214 : 			bonus = 500;

  0010c	c7 45 f0 f4 01
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 500 ; 000001f4H
  00113	eb 07		 jmp	 SHORT $LN28@Y_AwardCoo
$LN27@Y_AwardCoo:

; 1215 : 		else
; 1216 : 			bonus = 0;

  00115	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bonus$4[ebp], 0
$LN28@Y_AwardCoo:

; 1217 : 
; 1218 : 		if (i == consoleplayer)

  0011c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0011f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  00125	0f 85 ae 00 00
	00		 jne	 $LN33@Y_AwardCoo

; 1219 : 		{
; 1220 : 			data.coop.timebonus = bonus;

  0012b	8b 45 f0	 mov	 eax, DWORD PTR _bonus$4[ebp]
  0012e	a3 04 00 00 00	 mov	 DWORD PTR _data+4, eax

; 1221 : 			if (players[i].health)

  00133	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0013a	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  00141	74 1b		 je	 SHORT $LN30@Y_AwardCoo

; 1222 : 				data.coop.ringbonus = (players[i].health-1) * 100;

  00143	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0014a	8b 88 28 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+40]
  00150	83 e9 01	 sub	 ecx, 1
  00153	6b d1 64	 imul	 edx, ecx, 100
  00156	89 15 08 00 00
	00		 mov	 DWORD PTR _data+8, edx
  0015c	eb 0a		 jmp	 SHORT $LN31@Y_AwardCoo
$LN30@Y_AwardCoo:

; 1223 : 			else
; 1224 : 				data.coop.ringbonus = 0;

  0015e	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+8, 0
$LN31@Y_AwardCoo:

; 1225 : 			data.coop.total = 0;

  00168	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+16, 0

; 1226 : 			data.coop.score = players[i].score;

  00172	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00179	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  0017f	89 0d 00 00 00
	00		 mov	 DWORD PTR _data, ecx

; 1227 : 
; 1228 : 			if (sharedringtotal && sharedringtotal >= nummaprings && (!mapheaderinfo[gamemap-1].noperfectbns)) //perfectionist!

  00185	83 7d f8 00	 cmp	 DWORD PTR _sharedringtotal$[ebp], 0
  00189	74 3a		 je	 SHORT $LN32@Y_AwardCoo
  0018b	8b 45 f8	 mov	 eax, DWORD PTR _sharedringtotal$[ebp]
  0018e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nummaprings
  00194	7c 2f		 jl	 SHORT $LN32@Y_AwardCoo
  00196	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0019d	83 e8 01	 sub	 eax, 1
  001a0	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  001a6	83 b9 3c 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[ecx+316], 0
  001ad	75 16		 jne	 SHORT $LN32@Y_AwardCoo

; 1229 : 			{
; 1230 : 				data.coop.perfbonus = 50000;

  001af	c7 05 0c 00 00
	00 50 c3 00 00	 mov	 DWORD PTR _data+12, 50000 ; 0000c350H

; 1231 : 				data.coop.gotperfbonus = true;

  001b9	c7 05 20 00 00
	00 01 00 00 00	 mov	 DWORD PTR _data+32, 1

; 1232 : 			}

  001c3	eb 14		 jmp	 SHORT $LN33@Y_AwardCoo
$LN32@Y_AwardCoo:

; 1233 : 			else
; 1234 : 			{
; 1235 : 				data.coop.perfbonus = 0;

  001c5	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+12, 0

; 1236 : 				data.coop.gotperfbonus = false;

  001cf	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+32, 0
$LN33@Y_AwardCoo:

; 1237 : 			}
; 1238 : 		}
; 1239 : 
; 1240 : 		oldscore = players[i].score;

  001d9	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001e0	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  001e6	89 4d ec	 mov	 DWORD PTR _oldscore$3[ebp], ecx

; 1241 : 
; 1242 : 		players[i].score += bonus;

  001e9	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  001f0	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  001f6	03 4d f0	 add	 ecx, DWORD PTR _bonus$4[ebp]
  001f9	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  00200	89 8a bc 00 00
	00		 mov	 DWORD PTR _players[edx+188], ecx

; 1243 : 		if (players[i].health)

  00206	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0020d	83 b8 28 00 00
	00 00		 cmp	 DWORD PTR _players[eax+40], 0
  00214	74 2d		 je	 SHORT $LN34@Y_AwardCoo

; 1244 : 			players[i].score += (players[i].health-1) * 100; // ring bonus

  00216	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0021d	69 4d fc fc 01
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 508
  00224	8b 91 28 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+40]
  0022a	83 ea 01	 sub	 edx, 1
  0022d	6b ca 64	 imul	 ecx, edx, 100
  00230	03 88 bc 00 00
	00		 add	 ecx, DWORD PTR _players[eax+188]
  00236	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  0023d	89 8a bc 00 00
	00		 mov	 DWORD PTR _players[edx+188], ecx
$LN34@Y_AwardCoo:

; 1245 : 
; 1246 : 		//todo: more conditions where we shouldn't award a perfect bonus?
; 1247 : 		if (sharedringtotal && sharedringtotal >= nummaprings && (!mapheaderinfo[gamemap-1].noperfectbns))

  00243	83 7d f8 00	 cmp	 DWORD PTR _sharedringtotal$[ebp], 0
  00247	0f 84 73 01 00
	00		 je	 $LN38@Y_AwardCoo
  0024d	8b 45 f8	 mov	 eax, DWORD PTR _sharedringtotal$[ebp]
  00250	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nummaprings
  00256	0f 8c 64 01 00
	00		 jl	 $LN38@Y_AwardCoo
  0025c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00263	83 e8 01	 sub	 eax, 1
  00266	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0026c	83 b9 3c 01 00
	00 00		 cmp	 DWORD PTR _mapheaderinfo[ecx+316], 0
  00273	0f 85 47 01 00
	00		 jne	 $LN38@Y_AwardCoo

; 1248 : 		{
; 1249 : 			players[i].score += 50000; //perfect bonus

  00279	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00280	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+188]
  00286	81 c1 50 c3 00
	00		 add	 ecx, 50000		; 0000c350H
  0028c	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  00293	89 8a bc 00 00
	00		 mov	 DWORD PTR _players[edx+188], ecx

; 1250 : 
; 1251 : 			if ((!modifiedgame || savemoddata) && !(netgame || multiplayer) && !demoplayback)

  00299	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _modifiedgame, 0
  002a0	74 0d		 je	 SHORT $LN37@Y_AwardCoo
  002a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _savemoddata, 0
  002a9	0f 84 11 01 00
	00		 je	 $LN38@Y_AwardCoo
$LN37@Y_AwardCoo:
  002af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  002b6	0f 85 04 01 00
	00		 jne	 $LN38@Y_AwardCoo
  002bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  002c3	0f 85 f7 00 00
	00		 jne	 $LN38@Y_AwardCoo
  002c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demoplayback, 0
  002d0	0f 85 ea 00 00
	00		 jne	 $LN38@Y_AwardCoo

; 1252 : 			{
; 1253 : 				if (!emblemlocations[MAXEMBLEMS-4].collected)

  002d6	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002db	69 c8 fc 01 00
	00		 imul	 ecx, eax, 508
  002e1	0f b6 91 0a 00
	00 00		 movzx	 edx, BYTE PTR _emblemlocations[ecx+10]
  002e8	85 d2		 test	 edx, edx
  002ea	0f 85 d0 00 00
	00		 jne	 $LN38@Y_AwardCoo

; 1254 : 				{
; 1255 : 					INT32 j;
; 1256 : 					INT32 emblemcount = 0;

  002f0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _emblemcount$1[ebp], 0

; 1257 : 					emblemlocations[MAXEMBLEMS-4].collected = true;

  002f7	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002fc	69 c8 fc 01 00
	00		 imul	 ecx, eax, 508
  00302	c6 81 0a 00 00
	00 01		 mov	 BYTE PTR _emblemlocations[ecx+10], 1

; 1258 : 					gotemblem = true;

  00309	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _gotemblem, 1

; 1259 : 
; 1260 : 					for (j = 0; j < MAXEMBLEMS; j++)

  00313	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  0031a	eb 09		 jmp	 SHORT $LN10@Y_AwardCoo
$LN8@Y_AwardCoo:
  0031c	8b 45 e8	 mov	 eax, DWORD PTR _j$2[ebp]
  0031f	83 c0 01	 add	 eax, 1
  00322	89 45 e8	 mov	 DWORD PTR _j$2[ebp], eax
$LN10@Y_AwardCoo:
  00325	81 7d e8 00 02
	00 00		 cmp	 DWORD PTR _j$2[ebp], 512 ; 00000200H
  0032c	7d 1a		 jge	 SHORT $LN9@Y_AwardCoo

; 1261 : 					{
; 1262 : 						if (emblemlocations[j].collected)

  0032e	6b 45 e8 0c	 imul	 eax, DWORD PTR _j$2[ebp], 12
  00332	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+10]
  00339	85 c9		 test	 ecx, ecx
  0033b	74 09		 je	 SHORT $LN39@Y_AwardCoo

; 1263 : 							emblemcount++;

  0033d	8b 45 e4	 mov	 eax, DWORD PTR _emblemcount$1[ebp]
  00340	83 c0 01	 add	 eax, 1
  00343	89 45 e4	 mov	 DWORD PTR _emblemcount$1[ebp], eax
$LN39@Y_AwardCoo:

; 1264 : 					}

  00346	eb d4		 jmp	 SHORT $LN8@Y_AwardCoo
$LN9@Y_AwardCoo:

; 1265 : 
; 1266 : 					if (emblemcount >= numemblems/2 && !(grade & 4)) // Got half of emblems

  00348	a1 00 00 00 00	 mov	 eax, DWORD PTR _numemblems
  0034d	99		 cdq
  0034e	2b c2		 sub	 eax, edx
  00350	d1 f8		 sar	 eax, 1
  00352	39 45 e4	 cmp	 DWORD PTR _emblemcount$1[ebp], eax
  00355	7c 17		 jl	 SHORT $LN40@Y_AwardCoo
  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  0035c	83 e0 04	 and	 eax, 4
  0035f	75 0d		 jne	 SHORT $LN40@Y_AwardCoo

; 1267 : 						grade |= 4;

  00361	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00366	83 c8 04	 or	 eax, 4
  00369	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN40@Y_AwardCoo:

; 1268 : 
; 1269 : 					if (emblemcount >= numemblems/4 && !(grade & 16)) // NiGHTS

  0036e	a1 00 00 00 00	 mov	 eax, DWORD PTR _numemblems
  00373	99		 cdq
  00374	83 e2 03	 and	 edx, 3
  00377	03 c2		 add	 eax, edx
  00379	c1 f8 02	 sar	 eax, 2
  0037c	39 45 e4	 cmp	 DWORD PTR _emblemcount$1[ebp], eax
  0037f	7c 17		 jl	 SHORT $LN41@Y_AwardCoo
  00381	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00386	83 e0 10	 and	 eax, 16			; 00000010H
  00389	75 0d		 jne	 SHORT $LN41@Y_AwardCoo

; 1270 : 						grade |= 16;

  0038b	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00390	83 c8 10	 or	 eax, 16			; 00000010H
  00393	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN41@Y_AwardCoo:

; 1271 : 
; 1272 : 					if (emblemcount == numemblems && !(grade & 8)) // Got ALL emblems!

  00398	8b 45 e4	 mov	 eax, DWORD PTR _emblemcount$1[ebp]
  0039b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numemblems
  003a1	75 17		 jne	 SHORT $LN42@Y_AwardCoo
  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  003a8	83 e0 08	 and	 eax, 8
  003ab	75 0d		 jne	 SHORT $LN42@Y_AwardCoo

; 1273 : 						grade |= 8;

  003ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  003b2	83 c8 08	 or	 eax, 8
  003b5	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN42@Y_AwardCoo:

; 1274 : 
; 1275 : 					G_SaveGameData();

  003ba	e8 00 00 00 00	 call	 _G_SaveGameData
  003bf	90		 npad	 1
$LN38@Y_AwardCoo:

; 1276 : 				}
; 1277 : 			}
; 1278 : 		}
; 1279 : 
; 1280 : 		// grant extra lives right away since tally is faked
; 1281 : 		P_GivePlayerLives(&players[i], (players[i].score/50000) - (oldscore/50000));

  003c0	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  003c7	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR _players[eax+188]
  003cd	33 d2		 xor	 edx, edx
  003cf	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  003d4	f7 f1		 div	 ecx
  003d6	8b c8		 mov	 ecx, eax
  003d8	8b 45 ec	 mov	 eax, DWORD PTR _oldscore$3[ebp]
  003db	99		 cdq
  003dc	be 50 c3 00 00	 mov	 esi, 50000		; 0000c350H
  003e1	f7 fe		 idiv	 esi
  003e3	2b c8		 sub	 ecx, eax
  003e5	51		 push	 ecx
  003e6	69 55 fc fc 01
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 508
  003ed	81 c2 00 00 00
	00		 add	 edx, OFFSET _players
  003f3	52		 push	 edx
  003f4	e8 00 00 00 00	 call	 _P_GivePlayerLives
  003f9	83 c4 08	 add	 esp, 8

; 1282 : 
; 1283 : 		if ((players[i].score/50000) - (oldscore/50000) > 0)

  003fc	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00403	8b 80 bc 00 00
	00		 mov	 eax, DWORD PTR _players[eax+188]
  00409	33 d2		 xor	 edx, edx
  0040b	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  00410	f7 f1		 div	 ecx
  00412	8b c8		 mov	 ecx, eax
  00414	8b 45 ec	 mov	 eax, DWORD PTR _oldscore$3[ebp]
  00417	99		 cdq
  00418	be 50 c3 00 00	 mov	 esi, 50000		; 0000c350H
  0041d	f7 fe		 idiv	 esi
  0041f	2b c8		 sub	 ecx, eax
  00421	74 0a		 je	 SHORT $LN43@Y_AwardCoo

; 1284 : 			data.coop.gotlife = i;

  00423	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00426	a3 60 00 00 00	 mov	 DWORD PTR _data+96, eax
  0042b	eb 0a		 jmp	 SHORT $LN44@Y_AwardCoo
$LN43@Y_AwardCoo:

; 1285 : 		else
; 1286 : 			data.coop.gotlife = -1;

  0042d	c7 05 60 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _data+96, -1
$LN44@Y_AwardCoo:

; 1287 : 	}

  00437	e9 1d fc ff ff	 jmp	 $LN5@Y_AwardCoo
$LN6@Y_AwardCoo:

; 1288 : }

  0043c	5f		 pop	 edi
  0043d	5e		 pop	 esi
  0043e	5b		 pop	 ebx
  0043f	8b e5		 mov	 esp, ebp
  00441	5d		 pop	 ebp
  00442	c3		 ret	 0
_Y_AwardCoopBonuses ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_EndGame
_TEXT	SEGMENT
_Y_EndGame PROC						; COMDAT

; 1732 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1733 : 	// Only do evaluation and credits in coop games.
; 1734 : 	if (gametype == GT_COOP)

  00009	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00010	85 c0		 test	 eax, eax
  00012	75 2c		 jne	 SHORT $LN4@Y_EndGame

; 1735 : 	{
; 1736 : 		if (nextmap == 1102-1) // end game with credits

  00014	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _nextmap
  0001b	3d 4d 04 00 00	 cmp	 eax, 1101		; 0000044dH
  00020	75 08		 jne	 SHORT $LN3@Y_EndGame

; 1737 : 		{
; 1738 : 			F_StartCredits();

  00022	e8 00 00 00 00	 call	 _F_StartCredits
  00027	90		 npad	 1

; 1739 : 			return;

  00028	eb 1c		 jmp	 SHORT $LN1@Y_EndGame
$LN3@Y_EndGame:

; 1740 : 		}
; 1741 : 		if (nextmap == 1101-1) // end game with evaluation

  0002a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _nextmap
  00031	3d 4c 04 00 00	 cmp	 eax, 1100		; 0000044cH
  00036	75 08		 jne	 SHORT $LN4@Y_EndGame

; 1742 : 		{
; 1743 : 			F_StartGameEvaluation();

  00038	e8 00 00 00 00	 call	 _F_StartGameEvaluation
  0003d	90		 npad	 1

; 1744 : 			return;

  0003e	eb 06		 jmp	 SHORT $LN1@Y_EndGame
$LN4@Y_EndGame:

; 1745 : 		}
; 1746 : 	}
; 1747 : 
; 1748 : 	// 1100 or competitive multiplayer, so go back to title screen.
; 1749 : 	D_StartTitle();

  00040	e8 00 00 00 00	 call	 _D_StartTitle
  00045	90		 npad	 1
$LN1@Y_EndGame:

; 1750 : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_Y_EndGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_EndIntermission
_TEXT	SEGMENT
_Y_EndIntermission PROC					; COMDAT

; 1714 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1715 : 	Y_UnloadData();

  00009	e8 00 00 00 00	 call	 _Y_UnloadData
  0000e	90		 npad	 1

; 1716 : 
; 1717 : 	endtic = -1;

  0000f	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _endtic, -1

; 1718 : 	inttype = int_none;

  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _inttype, 0

; 1719 : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_Y_EndIntermission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_StartIntermission
_TEXT	SEGMENT
tv93 = -76						; size = 4
tv528 = -76						; size = 4
tv542 = -76						; size = 4
_i$1 = -8						; size = 4
_emblemcount$2 = -4					; size = 4
_Y_StartIntermission PROC				; COMDAT

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 811  : 	intertic = -1;

  00009	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _intertic, -1

; 812  : 
; 813  : #ifdef PARANOIA
; 814  : 	if (endtic != -1)
; 815  : 		I_Error("endtic is dirty");
; 816  : #endif
; 817  : 
; 818  : 	if (!multiplayer)

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  0001a	75 39		 jne	 SHORT $LN7@Y_StartInt

; 819  : 	{
; 820  : 		timer = 0;

  0001c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _timer, 0

; 821  : 
; 822  : 		if (G_IsSpecialStage(gamemap))

  00026	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _G_IsSpecialStage
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	74 0c		 je	 SHORT $LN9@Y_StartInt

; 823  : 			inttype = int_spec;

  0003a	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _inttype, 5
  00044	eb 0a		 jmp	 SHORT $LN10@Y_StartInt
$LN9@Y_StartInt:

; 824  : 		else
; 825  : 			inttype = int_coop;

  00046	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _inttype, 1
$LN10@Y_StartInt:

; 826  : 	}

  00050	e9 01 01 00 00	 jmp	 $LN27@Y_StartInt
$LN7@Y_StartInt:

; 827  : 	else
; 828  : 	{
; 829  : 		if (cv_inttime.value == 0 && gametype == GT_COOP)

  00055	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_inttime+20, 0
  0005c	75 17		 jne	 SHORT $LN11@Y_StartInt
  0005e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $LN11@Y_StartInt

; 830  : 			timer = 0;

  00069	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _timer, 0
  00073	eb 1f		 jmp	 SHORT $LN13@Y_StartInt
$LN11@Y_StartInt:

; 831  : 		else
; 832  : 		{
; 833  : 			timer = cv_inttime.value*TICRATE;

  00075	6b 05 14 00 00
	00 23		 imul	 eax, DWORD PTR _cv_inttime+20, 35
  0007c	a3 00 00 00 00	 mov	 DWORD PTR _timer, eax

; 834  : 
; 835  : 			if (!timer)

  00081	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timer, 0
  00088	75 0a		 jne	 SHORT $LN13@Y_StartInt

; 836  : 				timer = 1;

  0008a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _timer, 1
$LN13@Y_StartInt:

; 837  : 		}
; 838  : 
; 839  : 		if (gametype == GT_COOP)

  00094	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  0009b	85 c0		 test	 eax, eax
  0009d	75 2f		 jne	 SHORT $LN14@Y_StartInt

; 840  : 		{
; 841  : 			if (G_IsSpecialStage(gamemap))

  0009f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _G_IsSpecialStage
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	74 0c		 je	 SHORT $LN16@Y_StartInt

; 842  : 				inttype = int_spec;

  000b3	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _inttype, 5
  000bd	eb 0a		 jmp	 SHORT $LN17@Y_StartInt
$LN16@Y_StartInt:

; 843  : 			else
; 844  : 				inttype = int_coop;

  000bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _inttype, 1
$LN17@Y_StartInt:

; 845  : 		}

  000c9	e9 88 00 00 00	 jmp	 $LN27@Y_StartInt
$LN14@Y_StartInt:

; 846  : 		else if (gametype == GT_MATCH
; 847  : #ifdef CHAOSISNOTDEADYET
; 848  : 			|| gametype == GT_CHAOS
; 849  : #endif
; 850  : 			|| gametype == GT_TAG)

  000ce	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 0c		 je	 SHORT $LN20@Y_StartInt
  000da	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  000e1	83 f8 03	 cmp	 eax, 3
  000e4	75 2d		 jne	 SHORT $LN18@Y_StartInt
$LN20@Y_StartInt:

; 851  : 		{
; 852  : 			if (gametype != GT_TAG && cv_matchtype.value) // Team Match

  000e6	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  000ed	83 f8 03	 cmp	 eax, 3
  000f0	74 15		 je	 SHORT $LN21@Y_StartInt
  000f2	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  000f9	74 0c		 je	 SHORT $LN21@Y_StartInt

; 853  : 				inttype = int_teammatch;

  000fb	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _inttype, 3
  00105	eb 0a		 jmp	 SHORT $LN22@Y_StartInt
$LN21@Y_StartInt:

; 854  : 			else
; 855  : 				inttype = int_match;

  00107	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR _inttype, 2
$LN22@Y_StartInt:

; 856  : 		}

  00111	eb 43		 jmp	 SHORT $LN27@Y_StartInt
$LN18@Y_StartInt:

; 857  : 		else if (gametype == GT_RACE)

  00113	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  0011a	83 f8 02	 cmp	 eax, 2
  0011d	75 21		 jne	 SHORT $LN23@Y_StartInt

; 858  : 		{
; 859  : 			if (cv_racetype.value) // Classic (Full Race in 1.09.4)

  0011f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_racetype+20, 0
  00126	74 0c		 je	 SHORT $LN25@Y_StartInt

; 860  : 				inttype = int_classicrace;

  00128	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR _inttype, 7
  00132	eb 0a		 jmp	 SHORT $LN26@Y_StartInt
$LN25@Y_StartInt:

; 861  : 			else // Normal (Time-Only in 1.09.4)
; 862  : 				inttype = int_race;

  00134	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _inttype, 6
$LN26@Y_StartInt:

; 863  : 		}

  0013e	eb 16		 jmp	 SHORT $LN27@Y_StartInt
$LN23@Y_StartInt:

; 864  : 		else if (gametype == GT_CTF)

  00140	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00147	83 f8 04	 cmp	 eax, 4
  0014a	75 0a		 jne	 SHORT $LN27@Y_StartInt

; 865  : 		{
; 866  : 			inttype = int_ctf;

  0014c	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR _inttype, 4
$LN27@Y_StartInt:

; 867  : 		}
; 868  : 	}
; 869  : 
; 870  : 	// We couldn't display the intermission even if we wanted to.
; 871  : 	if (dedicated) return;

  00156	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  0015d	74 05		 je	 SHORT $LN28@Y_StartInt
  0015f	e9 81 0a 00 00	 jmp	 $LN2@Y_StartInt
$LN28@Y_StartInt:

; 872  : 
; 873  : 	switch (inttype)

  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR _inttype
  00169	89 45 b4	 mov	 DWORD PTR tv93[ebp], eax
  0016c	8b 4d b4	 mov	 ecx, DWORD PTR tv93[ebp]
  0016f	83 e9 01	 sub	 ecx, 1
  00172	89 4d b4	 mov	 DWORD PTR tv93[ebp], ecx
  00175	83 7d b4 06	 cmp	 DWORD PTR tv93[ebp], 6
  00179	0f 87 66 0a 00
	00		 ja	 $LN73@Y_StartInt
  0017f	8b 55 b4	 mov	 edx, DWORD PTR tv93[ebp]
  00182	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN80@Y_StartInt[edx*4]
$LN29@Y_StartInt:

; 874  : 	{
; 875  : 		case int_coop: // coop or single player, normal level
; 876  : 		{
; 877  : 			gottimebonus = false;

  00189	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gottimebonus, 0

; 878  : 			gotemblem = false;

  00193	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gotemblem, 0

; 879  : 
; 880  : 			// award time and ring bonuses
; 881  : 			Y_AwardCoopBonuses();

  0019d	e8 00 00 00 00	 call	 _Y_AwardCoopBonuses
  001a2	90		 npad	 1

; 882  : 
; 883  : 			// setup time data
; 884  : 			data.coop.tics = players[consoleplayer].realtime; // used if cv_timetic is on

  001a3	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  001ad	8b 88 54 01 00
	00		 mov	 ecx, DWORD PTR _players[eax+340]
  001b3	89 0d 1c 00 00
	00		 mov	 DWORD PTR _data+28, ecx

; 885  : 			data.coop.sec = players[consoleplayer].realtime / TICRATE;

  001b9	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  001c3	8b 80 54 01 00
	00		 mov	 eax, DWORD PTR _players[eax+340]
  001c9	33 d2		 xor	 edx, edx
  001cb	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  001d0	f7 f1		 div	 ecx
  001d2	a3 18 00 00 00	 mov	 DWORD PTR _data+24, eax

; 886  : 			data.coop.min = data.coop.sec / 60;

  001d7	a1 18 00 00 00	 mov	 eax, DWORD PTR _data+24
  001dc	99		 cdq
  001dd	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  001e2	f7 f9		 idiv	 ecx
  001e4	a3 14 00 00 00	 mov	 DWORD PTR _data+20, eax

; 887  : 			data.coop.sec %= 60;

  001e9	a1 18 00 00 00	 mov	 eax, DWORD PTR _data+24
  001ee	99		 cdq
  001ef	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  001f4	f7 f9		 idiv	 ecx
  001f6	89 15 18 00 00
	00		 mov	 DWORD PTR _data+24, edx

; 888  : 
; 889  : 			if ((!modifiedgame || savemoddata) && !multiplayer && !demoplayback)

  001fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _modifiedgame, 0
  00203	74 0d		 je	 SHORT $LN31@Y_StartInt
  00205	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _savemoddata, 0
  0020c	0f 84 aa 01 00
	00		 je	 $LN42@Y_StartInt
$LN31@Y_StartInt:
  00212	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _multiplayer, 0
  00219	0f 85 9d 01 00
	00		 jne	 $LN42@Y_StartInt
  0021f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demoplayback, 0
  00226	0f 85 90 01 00
	00		 jne	 $LN42@Y_StartInt

; 890  : 			{
; 891  : 				if(timeattacking)

  0022c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  00233	0f 84 68 01 00
	00		 je	 $LN32@Y_StartInt

; 892  : 				{
; 893  : 					if ((players[consoleplayer].realtime < timedata[gamemap-1].time) ||

  00239	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00243	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _gamemap
  0024a	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR _players[eax+340]
  00250	3b 14 8d fc ff
	ff ff		 cmp	 edx, DWORD PTR _timedata[ecx*4-4]
  00257	72 11		 jb	 SHORT $LN35@Y_StartInt
  00259	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00260	83 3c 85 fc ff
	ff ff 00	 cmp	 DWORD PTR _timedata[eax*4-4], 0
  00268	75 1e		 jne	 SHORT $LN34@Y_StartInt
$LN35@Y_StartInt:

; 894  : 						(timedata[gamemap-1].time == 0))
; 895  : 						timedata[gamemap-1].time = players[consoleplayer].realtime;

  0026a	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00274	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR _gamemap
  0027b	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR _players[eax+340]
  00281	89 14 8d fc ff
	ff ff		 mov	 DWORD PTR _timedata[ecx*4-4], edx
$LN34@Y_StartInt:

; 896  : 
; 897  : 					if (!savemoddata && !(grade & 512))

  00288	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _savemoddata, 0
  0028f	0f 85 04 01 00
	00		 jne	 $LN41@Y_StartInt
  00295	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  0029a	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0029f	0f 85 f4 00 00
	00		 jne	 $LN41@Y_StartInt

; 898  : 					{
; 899  : 						INT32 emblemcount = 0;

  002a5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _emblemcount$2[ebp], 0

; 900  : 						INT32 i;
; 901  : 
; 902  : 						if (M_GotLowEnoughTime(23*60))

  002ac	68 64 05 00 00	 push	 1380			; 00000564H
  002b1	e8 00 00 00 00	 call	 _M_GotLowEnoughTime
  002b6	83 c4 04	 add	 esp, 4
  002b9	85 c0		 test	 eax, eax
  002bb	74 35		 je	 SHORT $LN37@Y_StartInt

; 903  : 						{
; 904  : 							gottimebonus = true;

  002bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _gottimebonus, 1

; 905  : 							emblemlocations[MAXEMBLEMS-3].collected = true;

  002c7	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  002cc	69 c8 fd 01 00
	00		 imul	 ecx, eax, 509
  002d2	c6 81 0a 00 00
	00 01		 mov	 BYTE PTR _emblemlocations[ecx+10], 1

; 906  : 							gotemblem = true;

  002d9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _gotemblem, 1

; 907  : 							grade |= 512;

  002e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  002e8	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  002ed	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN37@Y_StartInt:

; 908  : 						}
; 909  : 
; 910  : 						for (i = 0; i < MAXEMBLEMS; i++)

  002f2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  002f9	eb 09		 jmp	 SHORT $LN6@Y_StartInt
$LN4@Y_StartInt:
  002fb	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  002fe	83 c0 01	 add	 eax, 1
  00301	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN6@Y_StartInt:
  00304	81 7d f8 00 02
	00 00		 cmp	 DWORD PTR _i$1[ebp], 512 ; 00000200H
  0030b	7d 1a		 jge	 SHORT $LN5@Y_StartInt

; 911  : 						{
; 912  : 							if (emblemlocations[i].collected)

  0030d	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00311	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR _emblemlocations[eax+10]
  00318	85 c9		 test	 ecx, ecx
  0031a	74 09		 je	 SHORT $LN38@Y_StartInt

; 913  : 								emblemcount++;

  0031c	8b 45 fc	 mov	 eax, DWORD PTR _emblemcount$2[ebp]
  0031f	83 c0 01	 add	 eax, 1
  00322	89 45 fc	 mov	 DWORD PTR _emblemcount$2[ebp], eax
$LN38@Y_StartInt:

; 914  : 						}

  00325	eb d4		 jmp	 SHORT $LN4@Y_StartInt
$LN5@Y_StartInt:

; 915  : 
; 916  : 						if (emblemcount >= numemblems/2 && !(grade & 4)) // Got half of emblems

  00327	a1 00 00 00 00	 mov	 eax, DWORD PTR _numemblems
  0032c	99		 cdq
  0032d	2b c2		 sub	 eax, edx
  0032f	d1 f8		 sar	 eax, 1
  00331	39 45 fc	 cmp	 DWORD PTR _emblemcount$2[ebp], eax
  00334	7c 17		 jl	 SHORT $LN39@Y_StartInt
  00336	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  0033b	83 e0 04	 and	 eax, 4
  0033e	75 0d		 jne	 SHORT $LN39@Y_StartInt

; 917  : 							grade |= 4;

  00340	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00345	83 c8 04	 or	 eax, 4
  00348	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN39@Y_StartInt:

; 918  : 
; 919  : 						if (emblemcount >= numemblems/4 && !(grade & 16)) // NiGHTS

  0034d	a1 00 00 00 00	 mov	 eax, DWORD PTR _numemblems
  00352	99		 cdq
  00353	83 e2 03	 and	 edx, 3
  00356	03 c2		 add	 eax, edx
  00358	c1 f8 02	 sar	 eax, 2
  0035b	39 45 fc	 cmp	 DWORD PTR _emblemcount$2[ebp], eax
  0035e	7c 17		 jl	 SHORT $LN40@Y_StartInt
  00360	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00365	83 e0 10	 and	 eax, 16			; 00000010H
  00368	75 0d		 jne	 SHORT $LN40@Y_StartInt

; 920  : 							grade |= 16;

  0036a	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  0036f	83 c8 10	 or	 eax, 16			; 00000010H
  00372	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN40@Y_StartInt:

; 921  : 
; 922  : 						if (emblemcount == numemblems && !(grade & 8)) // Got ALL emblems!

  00377	8b 45 fc	 mov	 eax, DWORD PTR _emblemcount$2[ebp]
  0037a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _numemblems
  00380	75 17		 jne	 SHORT $LN41@Y_StartInt
  00382	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00387	83 e0 08	 and	 eax, 8
  0038a	75 0d		 jne	 SHORT $LN41@Y_StartInt

; 923  : 							grade |= 8;

  0038c	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  00391	83 c8 08	 or	 eax, 8
  00394	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN41@Y_StartInt:

; 924  : 					}
; 925  : 					G_SaveGameData();

  00399	e8 00 00 00 00	 call	 _G_SaveGameData
  0039e	90		 npad	 1

; 926  : 				}

  0039f	eb 1b		 jmp	 SHORT $LN42@Y_StartInt
$LN32@Y_StartInt:

; 927  : 				else if (gamemap == 40) // Cleared NAGZ

  003a1	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  003a8	83 f8 28	 cmp	 eax, 40			; 00000028H
  003ab	75 0f		 jne	 SHORT $LN42@Y_StartInt

; 928  : 					grade |= 2048;

  003ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _grade
  003b2	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  003b7	a3 00 00 00 00	 mov	 DWORD PTR _grade, eax
$LN42@Y_StartInt:

; 929  : 			}
; 930  : 
; 931  : 			// get act number
; 932  : 			if (mapheaderinfo[prevmap].actnum)

  003bc	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  003c3	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  003c9	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  003d0	85 d2		 test	 edx, edx
  003d2	74 34		 je	 SHORT $LN43@Y_StartInt

; 933  : 				data.coop.ttlnum = W_CachePatchName(va("TTL%.2d", mapheaderinfo[prevmap].actnum),

  003d4	6a 01		 push	 1
  003d6	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  003dd	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  003e3	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  003ea	52		 push	 edx
  003eb	68 00 00 00 00	 push	 OFFSET ??_C@_07ILADDNDN@TTL?$CF?42d@
  003f0	e8 00 00 00 00	 call	 _va
  003f5	83 c4 08	 add	 esp, 8
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 _W_CachePatchName
  003fe	83 c4 08	 add	 esp, 8
  00401	a3 24 00 00 00	 mov	 DWORD PTR _data+36, eax
  00406	eb 14		 jmp	 SHORT $LN44@Y_StartInt
$LN43@Y_StartInt:

; 934  : 					PU_STATIC);
; 935  : 			else
; 936  : 				data.coop.ttlnum = W_CachePatchName("TTL01", PU_STATIC);

  00408	6a 01		 push	 1
  0040a	68 00 00 00 00	 push	 OFFSET ??_C@_05CHEFHIBB@TTL01@
  0040f	e8 00 00 00 00	 call	 _W_CachePatchName
  00414	83 c4 08	 add	 esp, 8
  00417	a3 24 00 00 00	 mov	 DWORD PTR _data+36, eax
$LN44@Y_StartInt:

; 937  : 
; 938  : 			// get background patches
; 939  : 			widebgpatch = W_CachePatchName("INTERSCW", PU_STATIC);

  0041c	6a 01		 push	 1
  0041e	68 00 00 00 00	 push	 OFFSET ??_C@_08MDJCBMEE@INTERSCW@
  00423	e8 00 00 00 00	 call	 _W_CachePatchName
  00428	83 c4 08	 add	 esp, 8
  0042b	a3 00 00 00 00	 mov	 DWORD PTR _widebgpatch, eax

; 940  : 			bgpatch = W_CachePatchName("INTERSCR", PU_STATIC);

  00430	6a 01		 push	 1
  00432	68 00 00 00 00	 push	 OFFSET ??_C@_08LOOFOIAB@INTERSCR@
  00437	e8 00 00 00 00	 call	 _W_CachePatchName
  0043c	83 c4 08	 add	 esp, 8
  0043f	a3 00 00 00 00	 mov	 DWORD PTR _bgpatch, eax

; 941  : 
; 942  : 			// grab an interscreen if appropriate
; 943  : 			if (mapheaderinfo[gamemap-1].interscreen[0] != '#')

  00444	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0044b	83 e8 01	 sub	 eax, 1
  0044e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00454	ba 01 00 00 00	 mov	 edx, 1
  00459	6b c2 00	 imul	 eax, edx, 0
  0045c	0f be 8c 01 50
	00 00 00	 movsx	 ecx, BYTE PTR _mapheaderinfo[ecx+eax+80]
  00464	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00467	74 3c		 je	 SHORT $LN45@Y_StartInt

; 944  : 			{
; 945  : 				interpic = W_CachePatchName(mapheaderinfo[gamemap-1].interscreen, PU_STATIC);

  00469	6a 01		 push	 1
  0046b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00472	83 e8 01	 sub	 eax, 1
  00475	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0047b	81 c1 50 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+80
  00481	51		 push	 ecx
  00482	e8 00 00 00 00	 call	 _W_CachePatchName
  00487	83 c4 08	 add	 esp, 8
  0048a	a3 00 00 00 00	 mov	 DWORD PTR _interpic, eax

; 946  : 				useinterpic = true;

  0048f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _useinterpic, 1

; 947  : 				usebuffer = false;

  00499	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _usebuffer, 0

; 948  : 			}

  004a3	eb 14		 jmp	 SHORT $LN46@Y_StartInt
$LN45@Y_StartInt:

; 949  : 			else
; 950  : 			{
; 951  : 				useinterpic = false;

  004a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useinterpic, 0

; 952  : 				usebuffer = true;

  004af	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _usebuffer, 1
$LN46@Y_StartInt:

; 953  : 			}
; 954  : 			usetile = false;

  004b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _usetile, 0

; 955  : 
; 956  : 			// get single player specific patches
; 957  : 			data.coop.ptotal = W_CachePatchName("YTOTAL", PU_STATIC);

  004c3	6a 01		 push	 1
  004c5	68 00 00 00 00	 push	 OFFSET ??_C@_06PAJJHGJH@YTOTAL@
  004ca	e8 00 00 00 00	 call	 _W_CachePatchName
  004cf	83 c4 08	 add	 esp, 8
  004d2	a3 34 00 00 00	 mov	 DWORD PTR _data+52, eax

; 958  : 			data.coop.ptimebonus = W_CachePatchName("YTMBONUS", PU_STATIC);

  004d7	6a 01		 push	 1
  004d9	68 00 00 00 00	 push	 OFFSET ??_C@_08CLKOFMME@YTMBONUS@
  004de	e8 00 00 00 00	 call	 _W_CachePatchName
  004e3	83 c4 08	 add	 esp, 8
  004e6	a3 28 00 00 00	 mov	 DWORD PTR _data+40, eax

; 959  : 			data.coop.pringbonus = W_CachePatchName("YRINGBNS", PU_STATIC);

  004eb	6a 01		 push	 1
  004ed	68 00 00 00 00	 push	 OFFSET ??_C@_08EJJAJMD@YRINGBNS@
  004f2	e8 00 00 00 00	 call	 _W_CachePatchName
  004f7	83 c4 08	 add	 esp, 8
  004fa	a3 2c 00 00 00	 mov	 DWORD PTR _data+44, eax

; 960  : 			data.coop.pperfbonus = W_CachePatchName("YPFBONUS", PU_STATIC);

  004ff	6a 01		 push	 1
  00501	68 00 00 00 00	 push	 OFFSET ??_C@_08KNODAGME@YPFBONUS@
  00506	e8 00 00 00 00	 call	 _W_CachePatchName
  0050b	83 c4 08	 add	 esp, 8
  0050e	a3 30 00 00 00	 mov	 DWORD PTR _data+48, eax

; 961  : 
; 962  : 			// set up the "got through act" message according to skin name
; 963  : 			if (strlen(skins[players[consoleplayer].skin].name) <= 8)

  00513	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  0051d	69 88 b8 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _players[eax+184], 236
  00527	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  0052d	51		 push	 ecx
  0052e	e8 00 00 00 00	 call	 _strlen
  00533	83 c4 04	 add	 esp, 4
  00536	83 f8 08	 cmp	 eax, 8
  00539	0f 87 0a 01 00
	00		 ja	 $LN47@Y_StartInt

; 964  : 			{
; 965  : 				_snprintf(data.coop.passed1,

  0053f	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00549	69 88 b8 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _players[eax+184], 236
  00553	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  00559	51		 push	 ecx
  0055a	68 00 00 00 00	 push	 OFFSET ??_C@_06BALDFEPI@?$CFs?5GOT@
  0055f	6a 0d		 push	 13			; 0000000dH
  00561	68 38 00 00 00	 push	 OFFSET _data+56
  00566	e8 00 00 00 00	 call	 __snprintf
  0056b	83 c4 10	 add	 esp, 16			; 00000010H

; 966  : 					sizeof data.coop.passed1, "%s GOT",
; 967  : 					skins[players[consoleplayer].skin].name);
; 968  : 				data.coop.passed1[sizeof data.coop.passed1 - 1] = '\0';

  0056e	b8 01 00 00 00	 mov	 eax, 1
  00573	6b c8 0c	 imul	 ecx, eax, 12
  00576	c6 81 38 00 00
	00 00		 mov	 BYTE PTR _data[ecx+56], 0

; 969  : 				if (mapheaderinfo[gamemap-1].actnum)

  0057d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00584	83 e8 01	 sub	 eax, 1
  00587	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0058d	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00594	85 d2		 test	 edx, edx
  00596	74 5a		 je	 SHORT $LN49@Y_StartInt

; 970  : 				{
; 971  : 					strcpy(data.coop.passed2, "THROUGH ACT");

  00598	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FKBFLPCL@THROUGH?5ACT@
  0059d	68 45 00 00 00	 push	 OFFSET _data+69
  005a2	e8 00 00 00 00	 call	 _strcpy
  005a7	83 c4 08	 add	 esp, 8

; 972  : 					data.coop.passedx1 = 62 + (176 - V_LevelNameWidth(data.coop.passed1))/2;

  005aa	68 38 00 00 00	 push	 OFFSET _data+56
  005af	e8 00 00 00 00	 call	 _V_LevelNameWidth
  005b4	83 c4 04	 add	 esp, 4
  005b7	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  005bc	2b c8		 sub	 ecx, eax
  005be	8b c1		 mov	 eax, ecx
  005c0	99		 cdq
  005c1	2b c2		 sub	 eax, edx
  005c3	d1 f8		 sar	 eax, 1
  005c5	83 c0 3e	 add	 eax, 62			; 0000003eH
  005c8	a3 58 00 00 00	 mov	 DWORD PTR _data+88, eax

; 973  : 					data.coop.passedx2 = 62 + (176 - V_LevelNameWidth(data.coop.passed2))/2;

  005cd	68 45 00 00 00	 push	 OFFSET _data+69
  005d2	e8 00 00 00 00	 call	 _V_LevelNameWidth
  005d7	83 c4 04	 add	 esp, 4
  005da	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  005df	2b c8		 sub	 ecx, eax
  005e1	8b c1		 mov	 eax, ecx
  005e3	99		 cdq
  005e4	2b c2		 sub	 eax, edx
  005e6	d1 f8		 sar	 eax, 1
  005e8	83 c0 3e	 add	 eax, 62			; 0000003eH
  005eb	a3 5c 00 00 00	 mov	 DWORD PTR _data+92, eax

; 974  : 				}

  005f0	eb 52		 jmp	 SHORT $LN50@Y_StartInt
$LN49@Y_StartInt:

; 975  : 				else
; 976  : 				{
; 977  : 					strcpy(data.coop.passed2, "THROUGH THE ACT");

  005f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LFIOMOPC@THROUGH?5THE?5ACT@
  005f7	68 45 00 00 00	 push	 OFFSET _data+69
  005fc	e8 00 00 00 00	 call	 _strcpy
  00601	83 c4 08	 add	 esp, 8

; 978  : 					data.coop.passedx1 = (BASEVIDWIDTH - V_LevelNameWidth(data.coop.passed1))/2;

  00604	68 38 00 00 00	 push	 OFFSET _data+56
  00609	e8 00 00 00 00	 call	 _V_LevelNameWidth
  0060e	83 c4 04	 add	 esp, 4
  00611	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  00616	2b c8		 sub	 ecx, eax
  00618	8b c1		 mov	 eax, ecx
  0061a	99		 cdq
  0061b	2b c2		 sub	 eax, edx
  0061d	d1 f8		 sar	 eax, 1
  0061f	a3 58 00 00 00	 mov	 DWORD PTR _data+88, eax

; 979  : 					data.coop.passedx2 = (BASEVIDWIDTH - V_LevelNameWidth(data.coop.passed2))/2;

  00624	68 45 00 00 00	 push	 OFFSET _data+69
  00629	e8 00 00 00 00	 call	 _V_LevelNameWidth
  0062e	83 c4 04	 add	 esp, 4
  00631	b9 40 01 00 00	 mov	 ecx, 320		; 00000140H
  00636	2b c8		 sub	 ecx, eax
  00638	8b c1		 mov	 eax, ecx
  0063a	99		 cdq
  0063b	2b c2		 sub	 eax, edx
  0063d	d1 f8		 sar	 eax, 1
  0063f	a3 5c 00 00 00	 mov	 DWORD PTR _data+92, eax
$LN50@Y_StartInt:

; 980  : 				}
; 981  : 				// The above value is not precalculated because it needs only be computed once
; 982  : 				// at the start of intermission, and precalculating it would preclude mods
; 983  : 				// changing the font to one of a slightly different width.
; 984  : 			}

  00644	e9 d2 00 00 00	 jmp	 $LN52@Y_StartInt
$LN47@Y_StartInt:

; 985  : 			else
; 986  : 			{
; 987  : 				strcpy(data.coop.passed1, skins[players[consoleplayer].skin].name);

  00649	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00653	69 88 b8 00 00
	00 ec 00 00 00	 imul	 ecx, DWORD PTR _players[eax+184], 236
  0065d	81 c1 00 00 00
	00		 add	 ecx, OFFSET _skins
  00663	51		 push	 ecx
  00664	68 38 00 00 00	 push	 OFFSET _data+56
  00669	e8 00 00 00 00	 call	 _strcpy
  0066e	83 c4 08	 add	 esp, 8

; 988  : 				data.coop.passedx1 = 62 + (176 - V_LevelNameWidth(data.coop.passed1))/2;

  00671	68 38 00 00 00	 push	 OFFSET _data+56
  00676	e8 00 00 00 00	 call	 _V_LevelNameWidth
  0067b	83 c4 04	 add	 esp, 4
  0067e	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00683	2b c8		 sub	 ecx, eax
  00685	8b c1		 mov	 eax, ecx
  00687	99		 cdq
  00688	2b c2		 sub	 eax, edx
  0068a	d1 f8		 sar	 eax, 1
  0068c	83 c0 3e	 add	 eax, 62			; 0000003eH
  0068f	a3 58 00 00 00	 mov	 DWORD PTR _data+88, eax

; 989  : 				if (mapheaderinfo[gamemap-1].actnum)

  00694	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  0069b	83 e8 01	 sub	 eax, 1
  0069e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  006a4	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  006ab	85 d2		 test	 edx, edx
  006ad	74 37		 je	 SHORT $LN51@Y_StartInt

; 990  : 				{
; 991  : 					strcpy(data.coop.passed2, "PASSED ACT");

  006af	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MBFANPAO@PASSED?5ACT@
  006b4	68 45 00 00 00	 push	 OFFSET _data+69
  006b9	e8 00 00 00 00	 call	 _strcpy
  006be	83 c4 08	 add	 esp, 8

; 992  : 					data.coop.passedx2 = 62 + (176 - V_LevelNameWidth(data.coop.passed2))/2;

  006c1	68 45 00 00 00	 push	 OFFSET _data+69
  006c6	e8 00 00 00 00	 call	 _V_LevelNameWidth
  006cb	83 c4 04	 add	 esp, 4
  006ce	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  006d3	2b c8		 sub	 ecx, eax
  006d5	8b c1		 mov	 eax, ecx
  006d7	99		 cdq
  006d8	2b c2		 sub	 eax, edx
  006da	d1 f8		 sar	 eax, 1
  006dc	83 c0 3e	 add	 eax, 62			; 0000003eH
  006df	a3 5c 00 00 00	 mov	 DWORD PTR _data+92, eax

; 993  : 				}

  006e4	eb 35		 jmp	 SHORT $LN52@Y_StartInt
$LN51@Y_StartInt:

; 994  : 				else
; 995  : 				{
; 996  : 					strcpy(data.coop.passed2, "PASSED THE ACT");

  006e6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IAGGKLFC@PASSED?5THE?5ACT@
  006eb	68 45 00 00 00	 push	 OFFSET _data+69
  006f0	e8 00 00 00 00	 call	 _strcpy
  006f5	83 c4 08	 add	 esp, 8

; 997  : 					data.coop.passedx2 = 62 + (240 - V_LevelNameWidth(data.coop.passed2))/2;

  006f8	68 45 00 00 00	 push	 OFFSET _data+69
  006fd	e8 00 00 00 00	 call	 _V_LevelNameWidth
  00702	83 c4 04	 add	 esp, 4
  00705	b9 f0 00 00 00	 mov	 ecx, 240		; 000000f0H
  0070a	2b c8		 sub	 ecx, eax
  0070c	8b c1		 mov	 eax, ecx
  0070e	99		 cdq
  0070f	2b c2		 sub	 eax, edx
  00711	d1 f8		 sar	 eax, 1
  00713	83 c0 3e	 add	 eax, 62			; 0000003eH
  00716	a3 5c 00 00 00	 mov	 DWORD PTR _data+92, eax
$LN52@Y_StartInt:

; 998  : 				}
; 999  : 			}
; 1000 : 			break;

  0071b	e9 c5 04 00 00	 jmp	 $LN2@Y_StartInt
$LN53@Y_StartInt:

; 1001 : 		}
; 1002 : 
; 1003 : 		case int_match:
; 1004 : 		{
; 1005 : 			// Calculate who won
; 1006 : 			Y_CalculateMatchWinners();

  00720	e8 00 00 00 00	 call	 _Y_CalculateMatchWinners
  00725	90		 npad	 1

; 1007 : 
; 1008 : 			// set up the levelstring
; 1009 : 			if (mapheaderinfo[prevmap].actnum)

  00726	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  0072d	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00733	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  0073a	85 d2		 test	 edx, edx
  0073c	74 3f		 je	 SHORT $LN54@Y_StartInt

; 1010 : 				_snprintf(data.match.levelstring,

  0073e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00745	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0074b	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00752	52		 push	 edx
  00753	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  0075a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00760	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00766	51		 push	 ecx
  00767	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@
  0076c	6a 28		 push	 40			; 00000028H
  0076e	68 10 03 00 00	 push	 OFFSET _data+784
  00773	e8 00 00 00 00	 call	 __snprintf
  00778	83 c4 14	 add	 esp, 20			; 00000014H
  0077b	eb 28		 jmp	 SHORT $LN55@Y_StartInt
$LN54@Y_StartInt:

; 1011 : 					sizeof data.match.levelstring,
; 1012 : 					"%.32s * %d *",
; 1013 : 					mapheaderinfo[prevmap].lvlttl, mapheaderinfo[prevmap].actnum);
; 1014 : 			else
; 1015 : 				_snprintf(data.match.levelstring,

  0077d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00784	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0078a	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00790	51		 push	 ecx
  00791	68 00 00 00 00	 push	 OFFSET ??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@
  00796	6a 28		 push	 40			; 00000028H
  00798	68 10 03 00 00	 push	 OFFSET _data+784
  0079d	e8 00 00 00 00	 call	 __snprintf
  007a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN55@Y_StartInt:

; 1016 : 					sizeof data.match.levelstring,
; 1017 : 					"* %.32s *",
; 1018 : 					mapheaderinfo[prevmap].lvlttl);
; 1019 : 
; 1020 : 			data.match.levelstring[sizeof data.match.levelstring - 1] = '\0';

  007a5	b8 01 00 00 00	 mov	 eax, 1
  007aa	6b c8 27	 imul	 ecx, eax, 39
  007ad	c6 81 10 03 00
	00 00		 mov	 BYTE PTR _data[ecx+784], 0

; 1021 : 
; 1022 : 			// get RESULT header
; 1023 : 			data.match.result =

  007b4	6a 01		 push	 1
  007b6	68 00 00 00 00	 push	 OFFSET ??_C@_06KNHLOFLP@RESULT@
  007bb	e8 00 00 00 00	 call	 _W_CachePatchName
  007c0	83 c4 08	 add	 esp, 8
  007c3	a3 00 03 00 00	 mov	 DWORD PTR _data+768, eax

; 1024 : 				W_CachePatchName("RESULT", PU_STATIC);
; 1025 : 
; 1026 : 			bgtile = W_CachePatchName("SRB2BACK", PU_STATIC);

  007c8	6a 01		 push	 1
  007ca	68 00 00 00 00	 push	 OFFSET ??_C@_08LPMGDBIJ@SRB2BACK@
  007cf	e8 00 00 00 00	 call	 _W_CachePatchName
  007d4	83 c4 08	 add	 esp, 8
  007d7	a3 00 00 00 00	 mov	 DWORD PTR _bgtile, eax

; 1027 : 			usetile = true;

  007dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _usetile, 1

; 1028 : 			useinterpic = false;

  007e6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useinterpic, 0

; 1029 : 			break;

  007f0	e9 f0 03 00 00	 jmp	 $LN2@Y_StartInt
$LN56@Y_StartInt:

; 1030 : 		}
; 1031 : 
; 1032 : 		case int_race: // (time-only race)
; 1033 : 		{
; 1034 : 			// Calculate who won
; 1035 : 			Y_CalculateTimeRaceWinners();

  007f5	e8 00 00 00 00	 call	 _Y_CalculateTimeRaceWinners
  007fa	90		 npad	 1

; 1036 : 
; 1037 : 			// set up the levelstring
; 1038 : 			if (mapheaderinfo[prevmap].actnum)

  007fb	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00802	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00808	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  0080f	85 d2		 test	 edx, edx
  00811	74 3f		 je	 SHORT $LN57@Y_StartInt

; 1039 : 				_snprintf(data.match.levelstring,

  00813	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  0081a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00820	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00827	52		 push	 edx
  00828	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  0082f	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00835	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  0083b	51		 push	 ecx
  0083c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@
  00841	6a 28		 push	 40			; 00000028H
  00843	68 10 03 00 00	 push	 OFFSET _data+784
  00848	e8 00 00 00 00	 call	 __snprintf
  0084d	83 c4 14	 add	 esp, 20			; 00000014H
  00850	eb 28		 jmp	 SHORT $LN58@Y_StartInt
$LN57@Y_StartInt:

; 1040 : 					sizeof data.match.levelstring,
; 1041 : 					"%.32s * %d *",
; 1042 : 					mapheaderinfo[prevmap].lvlttl, mapheaderinfo[prevmap].actnum);
; 1043 : 			else
; 1044 : 				_snprintf(data.match.levelstring,

  00852	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00859	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0085f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00865	51		 push	 ecx
  00866	68 00 00 00 00	 push	 OFFSET ??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@
  0086b	6a 28		 push	 40			; 00000028H
  0086d	68 10 03 00 00	 push	 OFFSET _data+784
  00872	e8 00 00 00 00	 call	 __snprintf
  00877	83 c4 10	 add	 esp, 16			; 00000010H
$LN58@Y_StartInt:

; 1045 : 					sizeof data.match.levelstring,
; 1046 : 					"* %.32s *",
; 1047 : 					mapheaderinfo[prevmap].lvlttl);
; 1048 : 
; 1049 : 			data.match.levelstring[sizeof data.match.levelstring - 1] = '\0';

  0087a	b8 01 00 00 00	 mov	 eax, 1
  0087f	6b c8 27	 imul	 ecx, eax, 39
  00882	c6 81 10 03 00
	00 00		 mov	 BYTE PTR _data[ecx+784], 0

; 1050 : 
; 1051 : 			// get RESULT header
; 1052 : 			data.match.result = W_CachePatchName("RESULT", PU_STATIC);

  00889	6a 01		 push	 1
  0088b	68 00 00 00 00	 push	 OFFSET ??_C@_06KNHLOFLP@RESULT@
  00890	e8 00 00 00 00	 call	 _W_CachePatchName
  00895	83 c4 08	 add	 esp, 8
  00898	a3 00 03 00 00	 mov	 DWORD PTR _data+768, eax

; 1053 : 
; 1054 : 			bgtile = W_CachePatchName("SRB2BACK", PU_STATIC);

  0089d	6a 01		 push	 1
  0089f	68 00 00 00 00	 push	 OFFSET ??_C@_08LPMGDBIJ@SRB2BACK@
  008a4	e8 00 00 00 00	 call	 _W_CachePatchName
  008a9	83 c4 08	 add	 esp, 8
  008ac	a3 00 00 00 00	 mov	 DWORD PTR _bgtile, eax

; 1055 : 			usetile = true;

  008b1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _usetile, 1

; 1056 : 			useinterpic = false;

  008bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useinterpic, 0

; 1057 : 			break;

  008c5	e9 1b 03 00 00	 jmp	 $LN2@Y_StartInt
$LN59@Y_StartInt:

; 1058 : 		}
; 1059 : 
; 1060 : 		case int_teammatch:
; 1061 : 		case int_ctf:
; 1062 : 		{
; 1063 : 			// Calculate who won
; 1064 : 			Y_CalculateMatchWinners();

  008ca	e8 00 00 00 00	 call	 _Y_CalculateMatchWinners
  008cf	90		 npad	 1

; 1065 : 
; 1066 : 			// set up the levelstring
; 1067 : 			if (mapheaderinfo[prevmap].actnum)

  008d0	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  008d7	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  008dd	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  008e4	85 d2		 test	 edx, edx
  008e6	74 3f		 je	 SHORT $LN61@Y_StartInt

; 1068 : 				_snprintf(data.match.levelstring,

  008e8	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  008ef	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  008f5	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  008fc	52		 push	 edx
  008fd	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00904	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0090a	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00910	51		 push	 ecx
  00911	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@
  00916	6a 28		 push	 40			; 00000028H
  00918	68 10 03 00 00	 push	 OFFSET _data+784
  0091d	e8 00 00 00 00	 call	 __snprintf
  00922	83 c4 14	 add	 esp, 20			; 00000014H
  00925	eb 28		 jmp	 SHORT $LN62@Y_StartInt
$LN61@Y_StartInt:

; 1069 : 					sizeof data.match.levelstring,
; 1070 : 					"%.32s * %d *",
; 1071 : 					mapheaderinfo[prevmap].lvlttl, mapheaderinfo[prevmap].actnum);
; 1072 : 			else
; 1073 : 				_snprintf(data.match.levelstring,

  00927	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  0092e	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00934	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  0093a	51		 push	 ecx
  0093b	68 00 00 00 00	 push	 OFFSET ??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@
  00940	6a 28		 push	 40			; 00000028H
  00942	68 10 03 00 00	 push	 OFFSET _data+784
  00947	e8 00 00 00 00	 call	 __snprintf
  0094c	83 c4 10	 add	 esp, 16			; 00000010H
$LN62@Y_StartInt:

; 1074 : 					sizeof data.match.levelstring,
; 1075 : 					"* %.32s *",
; 1076 : 					mapheaderinfo[prevmap].lvlttl);
; 1077 : 
; 1078 : 			data.match.levelstring[sizeof data.match.levelstring - 1] = '\0';

  0094f	b8 01 00 00 00	 mov	 eax, 1
  00954	6b c8 27	 imul	 ecx, eax, 39
  00957	c6 81 10 03 00
	00 00		 mov	 BYTE PTR _data[ecx+784], 0

; 1079 : 
; 1080 : 			if (inttype == int_ctf)

  0095e	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _inttype, 4
  00965	75 16		 jne	 SHORT $LN63@Y_StartInt

; 1081 : 			{
; 1082 : 				data.match.redflag = rflagico;

  00967	a1 00 00 00 00	 mov	 eax, DWORD PTR _rflagico
  0096c	a3 08 03 00 00	 mov	 DWORD PTR _data+776, eax

; 1083 : 				data.match.blueflag = bflagico;

  00971	a1 00 00 00 00	 mov	 eax, DWORD PTR _bflagico
  00976	a3 04 03 00 00	 mov	 DWORD PTR _data+772, eax

; 1084 : 			}

  0097b	eb 14		 jmp	 SHORT $LN64@Y_StartInt
$LN63@Y_StartInt:

; 1085 : 			else // team match
; 1086 : 			{
; 1087 : 				data.match.redflag = rmatcico;

  0097d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rmatcico
  00982	a3 08 03 00 00	 mov	 DWORD PTR _data+776, eax

; 1088 : 				data.match.blueflag = bmatcico;

  00987	a1 00 00 00 00	 mov	 eax, DWORD PTR _bmatcico
  0098c	a3 04 03 00 00	 mov	 DWORD PTR _data+772, eax
$LN64@Y_StartInt:

; 1089 : 			}
; 1090 : 
; 1091 : 			bgtile = W_CachePatchName("SRB2BACK", PU_STATIC);

  00991	6a 01		 push	 1
  00993	68 00 00 00 00	 push	 OFFSET ??_C@_08LPMGDBIJ@SRB2BACK@
  00998	e8 00 00 00 00	 call	 _W_CachePatchName
  0099d	83 c4 08	 add	 esp, 8
  009a0	a3 00 00 00 00	 mov	 DWORD PTR _bgtile, eax

; 1092 : 			usetile = true;

  009a5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _usetile, 1

; 1093 : 			useinterpic = false;

  009af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useinterpic, 0

; 1094 : 			break;

  009b9	e9 27 02 00 00	 jmp	 $LN2@Y_StartInt
$LN65@Y_StartInt:

; 1095 : 		}
; 1096 : 
; 1097 : 		case int_spec: // coop or single player, special stage
; 1098 : 		{
; 1099 : 			// give out ring bonuses
; 1100 : 			Y_AwardSpecialStageBonus();

  009be	e8 00 00 00 00	 call	 _Y_AwardSpecialStageBonus
  009c3	90		 npad	 1

; 1101 : 
; 1102 : 			// get background tile
; 1103 : 			bgtile = W_CachePatchName("SPECTILE", PU_STATIC);

  009c4	6a 01		 push	 1
  009c6	68 00 00 00 00	 push	 OFFSET ??_C@_08EHPBPGGA@SPECTILE@
  009cb	e8 00 00 00 00	 call	 _W_CachePatchName
  009d0	83 c4 08	 add	 esp, 8
  009d3	a3 00 00 00 00	 mov	 DWORD PTR _bgtile, eax

; 1104 : 
; 1105 : 			// grab an interscreen if appropriate
; 1106 : 			if (mapheaderinfo[gamemap-1].interscreen[0] != '#')

  009d8	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  009df	83 e8 01	 sub	 eax, 1
  009e2	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  009e8	ba 01 00 00 00	 mov	 edx, 1
  009ed	6b c2 00	 imul	 eax, edx, 0
  009f0	0f be 8c 01 50
	00 00 00	 movsx	 ecx, BYTE PTR _mapheaderinfo[ecx+eax+80]
  009f8	83 f9 23	 cmp	 ecx, 35			; 00000023H
  009fb	74 32		 je	 SHORT $LN66@Y_StartInt

; 1107 : 			{
; 1108 : 				interpic = W_CachePatchName(mapheaderinfo[gamemap-1].interscreen, PU_STATIC);

  009fd	6a 01		 push	 1
  009ff	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00a06	83 e8 01	 sub	 eax, 1
  00a09	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00a0f	81 c1 50 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo+80
  00a15	51		 push	 ecx
  00a16	e8 00 00 00 00	 call	 _W_CachePatchName
  00a1b	83 c4 08	 add	 esp, 8
  00a1e	a3 00 00 00 00	 mov	 DWORD PTR _interpic, eax

; 1109 : 				useinterpic = true;

  00a23	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _useinterpic, 1

; 1110 : 			}

  00a2d	eb 0a		 jmp	 SHORT $LN67@Y_StartInt
$LN66@Y_StartInt:

; 1111 : 			else
; 1112 : 				useinterpic = false;

  00a2f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useinterpic, 0
$LN67@Y_StartInt:

; 1113 : 
; 1114 : 			// tile if using the default background
; 1115 : 			usetile = !useinterpic;

  00a39	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _useinterpic, 0
  00a40	75 09		 jne	 SHORT $LN76@Y_StartInt
  00a42	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv528[ebp], 1
  00a49	eb 07		 jmp	 SHORT $LN77@Y_StartInt
$LN76@Y_StartInt:
  00a4b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv528[ebp], 0
$LN77@Y_StartInt:
  00a52	8b 45 b4	 mov	 eax, DWORD PTR tv528[ebp]
  00a55	a3 00 00 00 00	 mov	 DWORD PTR _usetile, eax

; 1116 : 
; 1117 : 			// get special stage specific patches
; 1118 : 			if (ALL7EMERALDS(emeralds))

  00a5a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  00a61	83 e0 7f	 and	 eax, 127		; 0000007fH
  00a64	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00a67	75 57		 jne	 SHORT $LN68@Y_StartInt

; 1119 : 			{
; 1120 : 				data.spec.cemerald = W_CachePatchName("GOTEMALL", PU_STATIC);

  00a69	6a 01		 push	 1
  00a6b	68 00 00 00 00	 push	 OFFSET ??_C@_08HNDANEKI@GOTEMALL@
  00a70	e8 00 00 00 00	 call	 _W_CachePatchName
  00a75	83 c4 08	 add	 esp, 8
  00a78	a3 0c 00 00 00	 mov	 DWORD PTR _data+12, eax

; 1121 : 				data.spec.headx = 70;

  00a7d	c7 05 08 00 00
	00 46 00 00 00	 mov	 DWORD PTR _data+8, 70	; 00000046H

; 1122 : 				data.spec.nowsuper = players[consoleplayer].skin

  00a87	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00a91	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR _players[eax+184], 0
  00a98	74 09		 je	 SHORT $LN78@Y_StartInt
  00a9a	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv542[ebp], 0
  00aa1	eb 12		 jmp	 SHORT $LN79@Y_StartInt
$LN78@Y_StartInt:
  00aa3	6a 01		 push	 1
  00aa5	68 00 00 00 00	 push	 OFFSET ??_C@_08FGFBHBAB@NOWSUPER@
  00aaa	e8 00 00 00 00	 call	 _W_CachePatchName
  00aaf	83 c4 08	 add	 esp, 8
  00ab2	89 45 b4	 mov	 DWORD PTR tv542[ebp], eax
$LN79@Y_StartInt:
  00ab5	8b 4d b4	 mov	 ecx, DWORD PTR tv542[ebp]
  00ab8	89 0d 10 00 00
	00		 mov	 DWORD PTR _data+16, ecx

; 1123 : 					? NULL : W_CachePatchName("NOWSUPER", PU_STATIC);
; 1124 : 			}

  00abe	eb 28		 jmp	 SHORT $LN69@Y_StartInt
$LN68@Y_StartInt:

; 1125 : 			else
; 1126 : 			{
; 1127 : 				data.spec.cemerald = W_CachePatchName("CEMERALD", PU_STATIC);

  00ac0	6a 01		 push	 1
  00ac2	68 00 00 00 00	 push	 OFFSET ??_C@_08GJDDMKCK@CEMERALD@
  00ac7	e8 00 00 00 00	 call	 _W_CachePatchName
  00acc	83 c4 08	 add	 esp, 8
  00acf	a3 0c 00 00 00	 mov	 DWORD PTR _data+12, eax

; 1128 : 				data.spec.headx = 48;

  00ad4	c7 05 08 00 00
	00 30 00 00 00	 mov	 DWORD PTR _data+8, 48	; 00000030H

; 1129 : 				data.spec.nowsuper = NULL;

  00ade	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+16, 0
$LN69@Y_StartInt:

; 1130 : 			}
; 1131 : 			data.spec.pringbonus = W_CachePatchName("YRINGBNS", PU_STATIC);

  00ae8	6a 01		 push	 1
  00aea	68 00 00 00 00	 push	 OFFSET ??_C@_08EJJAJMD@YRINGBNS@
  00aef	e8 00 00 00 00	 call	 _W_CachePatchName
  00af4	83 c4 08	 add	 esp, 8
  00af7	a3 14 00 00 00	 mov	 DWORD PTR _data+20, eax

; 1132 : 			data.spec.cscore = W_CachePatchName("CSCORE", PU_STATIC);

  00afc	6a 01		 push	 1
  00afe	68 00 00 00 00	 push	 OFFSET ??_C@_06KDHIBOFA@CSCORE@
  00b03	e8 00 00 00 00	 call	 _W_CachePatchName
  00b08	83 c4 08	 add	 esp, 8
  00b0b	a3 18 00 00 00	 mov	 DWORD PTR _data+24, eax

; 1133 : 			break;

  00b10	e9 d0 00 00 00	 jmp	 $LN2@Y_StartInt
$LN70@Y_StartInt:

; 1134 : 		}
; 1135 : 		case int_classicrace: // classic (full race)
; 1136 : 		{
; 1137 : 			// find out who won
; 1138 : 			Y_CalculateRaceWinners();

  00b15	e8 00 00 00 00	 call	 _Y_CalculateRaceWinners
  00b1a	90		 npad	 1

; 1139 : 
; 1140 : 			// set up the levelstring
; 1141 : 			if (mapheaderinfo[prevmap].actnum)

  00b1b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00b22	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00b28	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00b2f	85 d2		 test	 edx, edx
  00b31	74 3f		 je	 SHORT $LN71@Y_StartInt

; 1142 : 				_snprintf(data.race.levelstring,

  00b33	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00b3a	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00b40	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00b47	52		 push	 edx
  00b48	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00b4f	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00b55	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00b5b	51		 push	 ecx
  00b5c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MECOICCP@?$CF?432s?5?$CK?5?$CFd?5?$CK@
  00b61	6a 28		 push	 40			; 00000028H
  00b63	68 b0 00 00 00	 push	 OFFSET _data+176
  00b68	e8 00 00 00 00	 call	 __snprintf
  00b6d	83 c4 14	 add	 esp, 20			; 00000014H
  00b70	eb 28		 jmp	 SHORT $LN72@Y_StartInt
$LN71@Y_StartInt:

; 1143 : 					sizeof data.race.levelstring,
; 1144 : 					"%.32s * %d *",
; 1145 : 					mapheaderinfo[prevmap].lvlttl, mapheaderinfo[prevmap].actnum);
; 1146 : 			else
; 1147 : 				_snprintf(data.race.levelstring,

  00b72	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _prevmap
  00b79	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  00b7f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _mapheaderinfo
  00b85	51		 push	 ecx
  00b86	68 00 00 00 00	 push	 OFFSET ??_C@_09JPEMLDJP@?$CK?5?$CF?432s?5?$CK@
  00b8b	6a 28		 push	 40			; 00000028H
  00b8d	68 b0 00 00 00	 push	 OFFSET _data+176
  00b92	e8 00 00 00 00	 call	 __snprintf
  00b97	83 c4 10	 add	 esp, 16			; 00000010H
$LN72@Y_StartInt:

; 1148 : 					sizeof data.race.levelstring,
; 1149 : 					"* %.32s *",
; 1150 : 					mapheaderinfo[prevmap].lvlttl);
; 1151 : 
; 1152 : 			data.race.levelstring[sizeof data.race.levelstring - 1] = '\0';

  00b9a	b8 01 00 00 00	 mov	 eax, 1
  00b9f	6b c8 27	 imul	 ecx, eax, 39
  00ba2	c6 81 b0 00 00
	00 00		 mov	 BYTE PTR _data[ecx+176], 0

; 1153 : 
; 1154 : 			// get background tile
; 1155 : 			bgtile = W_CachePatchName("SRB2BACK", PU_STATIC);

  00ba9	6a 01		 push	 1
  00bab	68 00 00 00 00	 push	 OFFSET ??_C@_08LPMGDBIJ@SRB2BACK@
  00bb0	e8 00 00 00 00	 call	 _W_CachePatchName
  00bb5	83 c4 08	 add	 esp, 8
  00bb8	a3 00 00 00 00	 mov	 DWORD PTR _bgtile, eax

; 1156 : 			usetile = true;

  00bbd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _usetile, 1

; 1157 : 			useinterpic = false;

  00bc7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _useinterpic, 0

; 1158 : 
; 1159 : 			// get RESULT header
; 1160 : 			data.race.result = W_CachePatchName("RESULT", PU_STATIC);

  00bd1	6a 01		 push	 1
  00bd3	68 00 00 00 00	 push	 OFFSET ??_C@_06KNHLOFLP@RESULT@
  00bd8	e8 00 00 00 00	 call	 _W_CachePatchName
  00bdd	83 c4 08	 add	 esp, 8
  00be0	a3 ac 00 00 00	 mov	 DWORD PTR _data+172, eax
$LN73@Y_StartInt:
$LN2@Y_StartInt:

; 1161 : 			break;
; 1162 : 		}
; 1163 : 
; 1164 : 		case int_none:
; 1165 : 		default:
; 1166 : 			break;
; 1167 : 	}
; 1168 : }

  00be5	5f		 pop	 edi
  00be6	5e		 pop	 esi
  00be7	5b		 pop	 ebx
  00be8	8b e5		 mov	 esp, ebp
  00bea	5d		 pop	 ebp
  00beb	c3		 ret	 0
$LN80@Y_StartInt:
  00bec	00 00 00 00	 DD	 $LN29@Y_StartInt
  00bf0	00 00 00 00	 DD	 $LN53@Y_StartInt
  00bf4	00 00 00 00	 DD	 $LN59@Y_StartInt
  00bf8	00 00 00 00	 DD	 $LN59@Y_StartInt
  00bfc	00 00 00 00	 DD	 $LN65@Y_StartInt
  00c00	00 00 00 00	 DD	 $LN56@Y_StartInt
  00c04	00 00 00 00	 DD	 $LN70@Y_StartInt
_Y_StartIntermission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_Ticker
_TEXT	SEGMENT
_skip$1 = -16						; size = 4
_i$2 = -12						; size = 4
_skip$3 = -8						; size = 4
_i$4 = -4						; size = 4
_Y_Ticker PROC						; COMDAT

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 577  : 	if (inttype == int_none)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _inttype, 0
  00010	75 05		 jne	 SHORT $LN8@Y_Ticker

; 578  : 		return;

  00012	e9 f3 05 00 00	 jmp	 $LN70@Y_Ticker
$LN8@Y_Ticker:

; 579  : 
; 580  : 	// Check for pause or menu up in single player
; 581  : 	if (paused || (!netgame && menuactive && !demoplayback))

  00017	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  0001e	85 c0		 test	 eax, eax
  00020	75 1b		 jne	 SHORT $LN10@Y_Ticker
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00029	75 17		 jne	 SHORT $LN9@Y_Ticker
  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _menuactive, 0
  00032	74 0e		 je	 SHORT $LN9@Y_Ticker
  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _demoplayback, 0
  0003b	75 05		 jne	 SHORT $LN9@Y_Ticker
$LN10@Y_Ticker:

; 582  : 		return;

  0003d	e9 c8 05 00 00	 jmp	 $LN70@Y_Ticker
$LN9@Y_Ticker:

; 583  : 
; 584  : 	intertic++;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  00047	83 c0 01	 add	 eax, 1
  0004a	a3 00 00 00 00	 mov	 DWORD PTR _intertic, eax

; 585  : 
; 586  : 	// Team scramble code for team match and CTF.
; 587  : 	// Don't do this if we're going to automatically scramble teams next round.
; 588  : 	if ((gametype == GT_CTF || (gametype == GT_MATCH && cv_matchtype.value))
; 589  : 	    && cv_teamscramble.value && !cv_scrambleonchange.value && server)

  0004f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00056	83 f8 04	 cmp	 eax, 4
  00059	74 15		 je	 SHORT $LN12@Y_Ticker
  0005b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00062	83 f8 01	 cmp	 eax, 1
  00065	75 3b		 jne	 SHORT $LN13@Y_Ticker
  00067	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  0006e	74 32		 je	 SHORT $LN13@Y_Ticker
$LN12@Y_Ticker:
  00070	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_teamscramble+20, 0
  00077	74 29		 je	 SHORT $LN13@Y_Ticker
  00079	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_scrambleonchange+20, 0
  00080	75 20		 jne	 SHORT $LN13@Y_Ticker
  00082	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  00089	74 17		 je	 SHORT $LN13@Y_Ticker

; 590  : 	{
; 591  : 		// If we run out of time in intermission, the beauty is that
; 592  : 		// the P_Ticker() team scramble code will pick it up.
; 593  : 		if ((intertic % (TICRATE/7)) == 0)

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  00090	99		 cdq
  00091	b9 05 00 00 00	 mov	 ecx, 5
  00096	f7 f9		 idiv	 ecx
  00098	85 d2		 test	 edx, edx
  0009a	75 06		 jne	 SHORT $LN13@Y_Ticker

; 594  : 			P_DoTeamscrambling();

  0009c	e8 00 00 00 00	 call	 _P_DoTeamscrambling
  000a1	90		 npad	 1
$LN13@Y_Ticker:

; 595  : 	}
; 596  : 
; 597  : 	// multiplayer uses timer (based on cv_inttime)
; 598  : 	if (timer)

  000a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timer, 0
  000a9	74 22		 je	 SHORT $LN14@Y_Ticker

; 599  : 	{
; 600  : 		if (!--timer)

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _timer
  000b0	83 e8 01	 sub	 eax, 1
  000b3	a3 00 00 00 00	 mov	 DWORD PTR _timer, eax
  000b8	75 11		 jne	 SHORT $LN16@Y_Ticker

; 601  : 		{
; 602  : 			Y_EndIntermission();

  000ba	e8 00 00 00 00	 call	 _Y_EndIntermission
  000bf	90		 npad	 1

; 603  : 			Y_FollowIntermission();

  000c0	e8 00 00 00 00	 call	 _Y_FollowIntermission
  000c5	90		 npad	 1

; 604  : 			return;

  000c6	e9 3f 05 00 00	 jmp	 $LN70@Y_Ticker
$LN16@Y_Ticker:

; 605  : 		}
; 606  : 	}

  000cb	eb 1e		 jmp	 SHORT $LN17@Y_Ticker
$LN14@Y_Ticker:

; 607  : 	// single player is hardcoded to go away after awhile
; 608  : 	else if (intertic == endtic)

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  000d2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _endtic
  000d8	75 11		 jne	 SHORT $LN17@Y_Ticker

; 609  : 	{
; 610  : 		Y_EndIntermission();

  000da	e8 00 00 00 00	 call	 _Y_EndIntermission
  000df	90		 npad	 1

; 611  : 		Y_FollowIntermission();

  000e0	e8 00 00 00 00	 call	 _Y_FollowIntermission
  000e5	90		 npad	 1

; 612  : 		return;

  000e6	e9 1f 05 00 00	 jmp	 $LN70@Y_Ticker
$LN17@Y_Ticker:

; 613  : 	}
; 614  : 
; 615  : 	if (endtic != -1)

  000eb	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _endtic, -1
  000f2	74 05		 je	 SHORT $LN18@Y_Ticker

; 616  : 		return; // tally is done

  000f4	e9 11 05 00 00	 jmp	 $LN70@Y_Ticker
$LN18@Y_Ticker:

; 617  : 
; 618  : 	if (inttype == int_coop) // coop or single player, normal level

  000f9	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _inttype, 1
  00100	0f 85 d8 02 00
	00		 jne	 $LN19@Y_Ticker

; 619  : 	{
; 620  : 		if (!intertic) // first time only

  00106	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _intertic, 0
  0010d	75 0f		 jne	 SHORT $LN21@Y_Ticker

; 621  : 			S_ChangeMusic(mus_lclear, false); // don't loop it

  0010f	6a 00		 push	 0
  00111	68 0e 04 00 00	 push	 1038			; 0000040eH
  00116	e8 00 00 00 00	 call	 _S_ChangeMusic
  0011b	83 c4 08	 add	 esp, 8
$LN21@Y_Ticker:

; 622  : 
; 623  : 		if (intertic < TICRATE) // one second pause before tally begins

  0011e	83 3d 00 00 00
	00 23		 cmp	 DWORD PTR _intertic, 35	; 00000023H
  00125	7d 05		 jge	 SHORT $LN22@Y_Ticker

; 624  : 			return;

  00127	e9 de 04 00 00	 jmp	 $LN70@Y_Ticker
$LN22@Y_Ticker:

; 625  : 
; 626  : 		if (data.coop.ringbonus || data.coop.timebonus || data.coop.perfbonus)

  0012c	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _data+8, 0
  00133	75 16		 jne	 SHORT $LN25@Y_Ticker
  00135	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  0013c	75 0d		 jne	 SHORT $LN25@Y_Ticker
  0013e	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _data+12, 0
  00145	0f 84 75 02 00
	00		 je	 $LN23@Y_Ticker
$LN25@Y_Ticker:

; 627  : 		{
; 628  : 			INT32 i;
; 629  : 			boolean skip = false;

  0014b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _skip$3[ebp], 0

; 630  : 
; 631  : 			if (!(intertic & 1))

  00152	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  00157	83 e0 01	 and	 eax, 1
  0015a	75 0c		 jne	 SHORT $LN26@Y_Ticker

; 632  : 				S_StartSound(NULL, sfx_menu1); // tally sound effect

  0015c	6a 67		 push	 103			; 00000067H
  0015e	6a 00		 push	 0
  00160	e8 00 00 00 00	 call	 _S_StartSound
  00165	83 c4 08	 add	 esp, 8
$LN26@Y_Ticker:

; 633  : 
; 634  : 			for (i = 0; i < MAXPLAYERS; i++)

  00168	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  0016f	eb 09		 jmp	 SHORT $LN4@Y_Ticker
$LN2@Y_Ticker:
  00171	8b 45 fc	 mov	 eax, DWORD PTR _i$4[ebp]
  00174	83 c0 01	 add	 eax, 1
  00177	89 45 fc	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@Y_Ticker:
  0017a	83 7d fc 20	 cmp	 DWORD PTR _i$4[ebp], 32	; 00000020H
  0017e	7d 21		 jge	 SHORT $LN3@Y_Ticker

; 635  : 			{
; 636  : 				if (players[i].cmd.buttons & BT_USE)

  00180	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$4[ebp], 508
  00187	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR _players[eax+14]
  0018e	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00194	74 09		 je	 SHORT $LN27@Y_Ticker

; 637  : 				{
; 638  : 					skip = true;

  00196	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _skip$3[ebp], 1

; 639  : 					break;

  0019d	eb 02		 jmp	 SHORT $LN3@Y_Ticker
$LN27@Y_Ticker:

; 640  : 				}
; 641  : 			}

  0019f	eb d0		 jmp	 SHORT $LN2@Y_Ticker
$LN3@Y_Ticker:

; 642  : 
; 643  : 			// ring and time bonuses count down by 222 each tic
; 644  : 			if (data.coop.ringbonus)

  001a1	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _data+8, 0
  001a8	0f 84 b7 00 00
	00		 je	 $LN34@Y_Ticker

; 645  : 			{
; 646  : 				data.coop.ringbonus -= 222;

  001ae	a1 08 00 00 00	 mov	 eax, DWORD PTR _data+8
  001b3	2d de 00 00 00	 sub	 eax, 222		; 000000deH
  001b8	a3 08 00 00 00	 mov	 DWORD PTR _data+8, eax

; 647  : 				data.coop.total += 222;

  001bd	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  001c2	05 de 00 00 00	 add	 eax, 222		; 000000deH
  001c7	a3 10 00 00 00	 mov	 DWORD PTR _data+16, eax

; 648  : 				data.coop.score += 222;

  001cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  001d1	05 de 00 00 00	 add	 eax, 222		; 000000deH
  001d6	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 649  : 				if (data.coop.ringbonus < 0 || skip == true) // went too far

  001db	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _data+8, 0
  001e2	7c 06		 jl	 SHORT $LN30@Y_Ticker
  001e4	83 7d f8 01	 cmp	 DWORD PTR _skip$3[ebp], 1
  001e8	75 7b		 jne	 SHORT $LN34@Y_Ticker
$LN30@Y_Ticker:

; 650  : 				{
; 651  : 					data.coop.score += data.coop.ringbonus;

  001ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  001ef	03 05 08 00 00
	00		 add	 eax, DWORD PTR _data+8
  001f5	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 652  : 					data.coop.total += data.coop.ringbonus;

  001fa	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  001ff	03 05 08 00 00
	00		 add	 eax, DWORD PTR _data+8
  00205	a3 10 00 00 00	 mov	 DWORD PTR _data+16, eax

; 653  : 					data.coop.ringbonus = 0;

  0020a	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+8, 0

; 654  : 
; 655  : 					if (skip == true && (data.coop.gotlife == consoleplayer || data.coop.gotlife == secondarydisplayplayer))

  00214	83 7d f8 01	 cmp	 DWORD PTR _skip$3[ebp], 1
  00218	75 4b		 jne	 SHORT $LN34@Y_Ticker
  0021a	a1 60 00 00 00	 mov	 eax, DWORD PTR _data+96
  0021f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  00225	74 0d		 je	 SHORT $LN32@Y_Ticker
  00227	a1 60 00 00 00	 mov	 eax, DWORD PTR _data+96
  0022c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _secondarydisplayplayer
  00232	75 31		 jne	 SHORT $LN34@Y_Ticker
$LN32@Y_Ticker:

; 656  : 					{
; 657  : 						// lives are already added since tally is fake, but play the music
; 658  : 						if (mariomode)

  00234	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  0023b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00240	74 0e		 je	 SHORT $LN33@Y_Ticker

; 659  : 							S_StartSound(NULL, sfx_marioa);

  00242	6a 66		 push	 102			; 00000066H
  00244	6a 00		 push	 0
  00246	e8 00 00 00 00	 call	 _S_StartSound
  0024b	83 c4 08	 add	 esp, 8
  0024e	eb 15		 jmp	 SHORT $LN34@Y_Ticker
$LN33@Y_Ticker:

; 660  : 						else
; 661  : 						{
; 662  : 							S_StopMusic(); // otherwise it won't restart if this is done twice in a row

  00250	e8 00 00 00 00	 call	 _S_StopMusic
  00255	90		 npad	 1

; 663  : 							S_ChangeMusic(mus_xtlife, false);

  00256	6a 00		 push	 0
  00258	68 14 04 00 00	 push	 1044			; 00000414H
  0025d	e8 00 00 00 00	 call	 _S_ChangeMusic
  00262	83 c4 08	 add	 esp, 8
$LN34@Y_Ticker:

; 664  : 						}
; 665  : 					}
; 666  : 				}
; 667  : 			}
; 668  : 			if (data.coop.timebonus)

  00265	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  0026c	74 66		 je	 SHORT $LN36@Y_Ticker

; 669  : 			{
; 670  : 				data.coop.timebonus -= 222;

  0026e	a1 04 00 00 00	 mov	 eax, DWORD PTR _data+4
  00273	2d de 00 00 00	 sub	 eax, 222		; 000000deH
  00278	a3 04 00 00 00	 mov	 DWORD PTR _data+4, eax

; 671  : 				data.coop.total += 222;

  0027d	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  00282	05 de 00 00 00	 add	 eax, 222		; 000000deH
  00287	a3 10 00 00 00	 mov	 DWORD PTR _data+16, eax

; 672  : 				data.coop.score += 222;

  0028c	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00291	05 de 00 00 00	 add	 eax, 222		; 000000deH
  00296	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 673  : 				if (data.coop.timebonus < 0 || skip == true)

  0029b	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  002a2	7c 06		 jl	 SHORT $LN37@Y_Ticker
  002a4	83 7d f8 01	 cmp	 DWORD PTR _skip$3[ebp], 1
  002a8	75 2a		 jne	 SHORT $LN36@Y_Ticker
$LN37@Y_Ticker:

; 674  : 				{
; 675  : 					data.coop.score += data.coop.timebonus;

  002aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  002af	03 05 04 00 00
	00		 add	 eax, DWORD PTR _data+4
  002b5	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 676  : 					data.coop.total += data.coop.timebonus;

  002ba	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  002bf	03 05 04 00 00
	00		 add	 eax, DWORD PTR _data+4
  002c5	a3 10 00 00 00	 mov	 DWORD PTR _data+16, eax

; 677  : 					data.coop.timebonus = 0;

  002ca	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+4, 0
$LN36@Y_Ticker:

; 678  : 				}
; 679  : 			}
; 680  : 			if (data.coop.perfbonus)

  002d4	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _data+12, 0
  002db	74 66		 je	 SHORT $LN39@Y_Ticker

; 681  : 			{
; 682  : 				data.coop.perfbonus -= 222;

  002dd	a1 0c 00 00 00	 mov	 eax, DWORD PTR _data+12
  002e2	2d de 00 00 00	 sub	 eax, 222		; 000000deH
  002e7	a3 0c 00 00 00	 mov	 DWORD PTR _data+12, eax

; 683  : 				data.coop.total += 222;

  002ec	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  002f1	05 de 00 00 00	 add	 eax, 222		; 000000deH
  002f6	a3 10 00 00 00	 mov	 DWORD PTR _data+16, eax

; 684  : 				data.coop.score += 222;

  002fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00300	05 de 00 00 00	 add	 eax, 222		; 000000deH
  00305	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 685  : 				if (data.coop.perfbonus < 0 || skip == true)

  0030a	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _data+12, 0
  00311	7c 06		 jl	 SHORT $LN40@Y_Ticker
  00313	83 7d f8 01	 cmp	 DWORD PTR _skip$3[ebp], 1
  00317	75 2a		 jne	 SHORT $LN39@Y_Ticker
$LN40@Y_Ticker:

; 686  : 				{
; 687  : 					data.coop.score += data.coop.perfbonus;

  00319	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  0031e	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _data+12
  00324	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 688  : 					data.coop.total += data.coop.perfbonus;

  00329	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  0032e	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _data+12
  00334	a3 10 00 00 00	 mov	 DWORD PTR _data+16, eax

; 689  : 					data.coop.perfbonus = 0;

  00339	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+12, 0
$LN39@Y_Ticker:

; 690  : 				}
; 691  : 			}
; 692  : 			if (!data.coop.timebonus && !data.coop.ringbonus && !data.coop.perfbonus)

  00343	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  0034a	75 2b		 jne	 SHORT $LN41@Y_Ticker
  0034c	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _data+8, 0
  00353	75 22		 jne	 SHORT $LN41@Y_Ticker
  00355	83 3d 0c 00 00
	00 00		 cmp	 DWORD PTR _data+12, 0
  0035c	75 19		 jne	 SHORT $LN41@Y_Ticker

; 693  : 			{
; 694  : 				endtic = intertic + 3*TICRATE; // 3 second pause after end of tally

  0035e	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  00363	83 c0 69	 add	 eax, 105		; 00000069H
  00366	a3 00 00 00 00	 mov	 DWORD PTR _endtic, eax

; 695  : 				S_StartSound(NULL, sfx_chchng); // cha-ching!

  0036b	6a 2a		 push	 42			; 0000002aH
  0036d	6a 00		 push	 0
  0036f	e8 00 00 00 00	 call	 _S_StartSound
  00374	83 c4 08	 add	 esp, 8
$LN41@Y_Ticker:

; 696  : 			}
; 697  : 
; 698  : 			if (data.coop.score % 50000 < 222) // just passed a 50000 point mark

  00377	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  0037c	33 d2		 xor	 edx, edx
  0037e	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  00383	f7 f1		 div	 ecx
  00385	81 fa de 00 00
	00		 cmp	 edx, 222		; 000000deH
  0038b	73 31		 jae	 SHORT $LN44@Y_Ticker

; 699  : 			{
; 700  : 				// lives are already added since tally is fake, but play the music
; 701  : 				if (mariomode)

  0038d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  00394	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00399	74 0e		 je	 SHORT $LN43@Y_Ticker

; 702  : 					S_StartSound(NULL, sfx_marioa);

  0039b	6a 66		 push	 102			; 00000066H
  0039d	6a 00		 push	 0
  0039f	e8 00 00 00 00	 call	 _S_StartSound
  003a4	83 c4 08	 add	 esp, 8
  003a7	eb 15		 jmp	 SHORT $LN44@Y_Ticker
$LN43@Y_Ticker:

; 703  : 				else
; 704  : 				{
; 705  : 					S_StopMusic(); // otherwise it won't restart if this is done twice in a row

  003a9	e8 00 00 00 00	 call	 _S_StopMusic
  003ae	90		 npad	 1

; 706  : 					S_ChangeMusic(mus_xtlife, false);

  003af	6a 00		 push	 0
  003b1	68 14 04 00 00	 push	 1044			; 00000414H
  003b6	e8 00 00 00 00	 call	 _S_ChangeMusic
  003bb	83 c4 08	 add	 esp, 8
$LN44@Y_Ticker:

; 707  : 				}
; 708  : 			}
; 709  : 		}

  003be	eb 19		 jmp	 SHORT $LN24@Y_Ticker
$LN23@Y_Ticker:

; 710  : 		else
; 711  : 		{
; 712  : 			endtic = intertic + 3*TICRATE; // 3 second pause after end of tally

  003c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  003c5	83 c0 69	 add	 eax, 105		; 00000069H
  003c8	a3 00 00 00 00	 mov	 DWORD PTR _endtic, eax

; 713  : 			S_StartSound(NULL, sfx_chchng); // cha-ching!

  003cd	6a 2a		 push	 42			; 0000002aH
  003cf	6a 00		 push	 0
  003d1	e8 00 00 00 00	 call	 _S_StartSound
  003d6	83 c4 08	 add	 esp, 8
$LN24@Y_Ticker:

; 714  : 		}
; 715  : 	}

  003d9	e9 2c 02 00 00	 jmp	 $LN70@Y_Ticker
$LN19@Y_Ticker:

; 716  : 	else if (inttype == int_spec) // coop or single player, special stage

  003de	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _inttype, 5
  003e5	0f 85 ad 01 00
	00		 jne	 $LN45@Y_Ticker

; 717  : 	{
; 718  : 		if (!intertic) // first time only

  003eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _intertic, 0
  003f2	75 0f		 jne	 SHORT $LN47@Y_Ticker

; 719  : 			S_ChangeMusic(mus_lclear, false); // don't loop it

  003f4	6a 00		 push	 0
  003f6	68 0e 04 00 00	 push	 1038			; 0000040eH
  003fb	e8 00 00 00 00	 call	 _S_ChangeMusic
  00400	83 c4 08	 add	 esp, 8
$LN47@Y_Ticker:

; 720  : 
; 721  : 		if (intertic < TICRATE) // one second pause before tally begins

  00403	83 3d 00 00 00
	00 23		 cmp	 DWORD PTR _intertic, 35	; 00000023H
  0040a	7d 05		 jge	 SHORT $LN48@Y_Ticker

; 722  : 			return;

  0040c	e9 f9 01 00 00	 jmp	 $LN70@Y_Ticker
$LN48@Y_Ticker:

; 723  : 
; 724  : 		if (data.spec.ringbonus)

  00411	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  00418	0f 84 5f 01 00
	00		 je	 $LN49@Y_Ticker

; 725  : 		{
; 726  : 			INT32 i;
; 727  : 			boolean skip = false;

  0041e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _skip$1[ebp], 0

; 728  : 
; 729  : 			if (!(intertic & 1))

  00425	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  0042a	83 e0 01	 and	 eax, 1
  0042d	75 0c		 jne	 SHORT $LN51@Y_Ticker

; 730  : 				S_StartSound(NULL, sfx_menu1); // tally sound effect

  0042f	6a 67		 push	 103			; 00000067H
  00431	6a 00		 push	 0
  00433	e8 00 00 00 00	 call	 _S_StartSound
  00438	83 c4 08	 add	 esp, 8
$LN51@Y_Ticker:

; 731  : 
; 732  : 			for (i = 0; i < MAXPLAYERS; i++)

  0043b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00442	eb 09		 jmp	 SHORT $LN7@Y_Ticker
$LN5@Y_Ticker:
  00444	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00447	83 c0 01	 add	 eax, 1
  0044a	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
$LN7@Y_Ticker:
  0044d	83 7d f4 20	 cmp	 DWORD PTR _i$2[ebp], 32	; 00000020H
  00451	7d 21		 jge	 SHORT $LN6@Y_Ticker

; 733  : 			{
; 734  : 				if (players[i].cmd.buttons & BT_USE)

  00453	69 45 f4 fc 01
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 508
  0045a	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR _players[eax+14]
  00461	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00467	74 09		 je	 SHORT $LN52@Y_Ticker

; 735  : 				{
; 736  : 					skip = true;

  00469	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _skip$1[ebp], 1

; 737  : 					break;

  00470	eb 02		 jmp	 SHORT $LN6@Y_Ticker
$LN52@Y_Ticker:

; 738  : 				}
; 739  : 			}

  00472	eb d0		 jmp	 SHORT $LN5@Y_Ticker
$LN6@Y_Ticker:

; 740  : 
; 741  : 			// ring bonus counts down by 222 each tic
; 742  : 			data.spec.ringbonus -= 222;

  00474	a1 04 00 00 00	 mov	 eax, DWORD PTR _data+4
  00479	2d de 00 00 00	 sub	 eax, 222		; 000000deH
  0047e	a3 04 00 00 00	 mov	 DWORD PTR _data+4, eax

; 743  : 			data.spec.score += 222;

  00483	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00488	05 de 00 00 00	 add	 eax, 222		; 000000deH
  0048d	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 744  : 			if (data.spec.ringbonus < 0 || skip == true) // went too far

  00492	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  00499	7c 06		 jl	 SHORT $LN54@Y_Ticker
  0049b	83 7d f0 01	 cmp	 DWORD PTR _skip$1[ebp], 1
  0049f	75 6b		 jne	 SHORT $LN58@Y_Ticker
$LN54@Y_Ticker:

; 745  : 			{
; 746  : 				data.spec.score += data.spec.ringbonus;

  004a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  004a6	03 05 04 00 00
	00		 add	 eax, DWORD PTR _data+4
  004ac	a3 00 00 00 00	 mov	 DWORD PTR _data, eax

; 747  : 				data.spec.ringbonus = 0;

  004b1	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _data+4, 0

; 748  : 
; 749  : 				if (skip == true && (data.coop.gotlife == consoleplayer || data.coop.gotlife == secondarydisplayplayer))

  004bb	83 7d f0 01	 cmp	 DWORD PTR _skip$1[ebp], 1
  004bf	75 4b		 jne	 SHORT $LN58@Y_Ticker
  004c1	a1 60 00 00 00	 mov	 eax, DWORD PTR _data+96
  004c6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _consoleplayer
  004cc	74 0d		 je	 SHORT $LN56@Y_Ticker
  004ce	a1 60 00 00 00	 mov	 eax, DWORD PTR _data+96
  004d3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _secondarydisplayplayer
  004d9	75 31		 jne	 SHORT $LN58@Y_Ticker
$LN56@Y_Ticker:

; 750  : 				{
; 751  : 					// lives are already added since tally is fake, but play the music
; 752  : 					if (mariomode)

  004db	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  004e2	25 00 01 00 00	 and	 eax, 256		; 00000100H
  004e7	74 0e		 je	 SHORT $LN57@Y_Ticker

; 753  : 						S_StartSound(NULL, sfx_marioa);

  004e9	6a 66		 push	 102			; 00000066H
  004eb	6a 00		 push	 0
  004ed	e8 00 00 00 00	 call	 _S_StartSound
  004f2	83 c4 08	 add	 esp, 8
  004f5	eb 15		 jmp	 SHORT $LN58@Y_Ticker
$LN57@Y_Ticker:

; 754  : 					else
; 755  : 					{
; 756  : 						S_StopMusic(); // otherwise it won't restart if this is done twice in a row

  004f7	e8 00 00 00 00	 call	 _S_StopMusic
  004fc	90		 npad	 1

; 757  : 						S_ChangeMusic(mus_xtlife, false);

  004fd	6a 00		 push	 0
  004ff	68 14 04 00 00	 push	 1044			; 00000414H
  00504	e8 00 00 00 00	 call	 _S_ChangeMusic
  00509	83 c4 08	 add	 esp, 8
$LN58@Y_Ticker:

; 758  : 					}
; 759  : 				}
; 760  : 			}
; 761  : 
; 762  : 			if (!data.spec.ringbonus)

  0050c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR _data+4, 0
  00513	75 19		 jne	 SHORT $LN59@Y_Ticker

; 763  : 			{
; 764  : 				endtic = intertic + 3*TICRATE; // 3 second pause after end of tally

  00515	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  0051a	83 c0 69	 add	 eax, 105		; 00000069H
  0051d	a3 00 00 00 00	 mov	 DWORD PTR _endtic, eax

; 765  : 				S_StartSound(NULL, sfx_chchng); // cha-ching!

  00522	6a 2a		 push	 42			; 0000002aH
  00524	6a 00		 push	 0
  00526	e8 00 00 00 00	 call	 _S_StartSound
  0052b	83 c4 08	 add	 esp, 8
$LN59@Y_Ticker:

; 766  : 			}
; 767  : 
; 768  : 			if (data.spec.score % 50000 < 222 && skip == false) // just passed a 50000 point mark

  0052e	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00533	33 d2		 xor	 edx, edx
  00535	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  0053a	f7 f1		 div	 ecx
  0053c	81 fa de 00 00
	00		 cmp	 edx, 222		; 000000deH
  00542	73 37		 jae	 SHORT $LN62@Y_Ticker
  00544	83 7d f0 00	 cmp	 DWORD PTR _skip$1[ebp], 0
  00548	75 31		 jne	 SHORT $LN62@Y_Ticker

; 769  : 			{
; 770  : 				// lives are already added since tally is fake, but play the music
; 771  : 				if (mariomode)

  0054a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  00551	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00556	74 0e		 je	 SHORT $LN61@Y_Ticker

; 772  : 					S_StartSound(NULL, sfx_marioa);

  00558	6a 66		 push	 102			; 00000066H
  0055a	6a 00		 push	 0
  0055c	e8 00 00 00 00	 call	 _S_StartSound
  00561	83 c4 08	 add	 esp, 8
  00564	eb 15		 jmp	 SHORT $LN62@Y_Ticker
$LN61@Y_Ticker:

; 773  : 				else
; 774  : 				{
; 775  : 					S_StopMusic(); // otherwise it won't restart if this is done twice in a row

  00566	e8 00 00 00 00	 call	 _S_StopMusic
  0056b	90		 npad	 1

; 776  : 					S_ChangeMusic(mus_xtlife, false);

  0056c	6a 00		 push	 0
  0056e	68 14 04 00 00	 push	 1044			; 00000414H
  00573	e8 00 00 00 00	 call	 _S_ChangeMusic
  00578	83 c4 08	 add	 esp, 8
$LN62@Y_Ticker:

; 777  : 				}
; 778  : 			}
; 779  : 		}

  0057b	eb 19		 jmp	 SHORT $LN50@Y_Ticker
$LN49@Y_Ticker:

; 780  : 		else
; 781  : 		{
; 782  : 			endtic = intertic + 3*TICRATE; // 3 second pause after end of tally

  0057d	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  00582	83 c0 69	 add	 eax, 105		; 00000069H
  00585	a3 00 00 00 00	 mov	 DWORD PTR _endtic, eax

; 783  : 			S_StartSound(NULL, sfx_chchng); // cha-ching!

  0058a	6a 2a		 push	 42			; 0000002aH
  0058c	6a 00		 push	 0
  0058e	e8 00 00 00 00	 call	 _S_StartSound
  00593	83 c4 08	 add	 esp, 8
$LN50@Y_Ticker:

; 784  : 		}
; 785  : 	}

  00596	eb 72		 jmp	 SHORT $LN70@Y_Ticker
$LN45@Y_Ticker:

; 786  : 	else if (inttype == int_match || inttype == int_ctf || inttype == int_teammatch) // match

  00598	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _inttype, 2
  0059f	74 12		 je	 SHORT $LN65@Y_Ticker
  005a1	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _inttype, 4
  005a8	74 09		 je	 SHORT $LN65@Y_Ticker
  005aa	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _inttype, 3
  005b1	75 2d		 jne	 SHORT $LN63@Y_Ticker
$LN65@Y_Ticker:

; 787  : 	{
; 788  : 		if (!intertic) // first time only

  005b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _intertic, 0
  005ba	75 0f		 jne	 SHORT $LN66@Y_Ticker

; 789  : 			S_ChangeMusic(mus_racent, true); // loop it

  005bc	6a 01		 push	 1
  005be	68 19 04 00 00	 push	 1049			; 00000419H
  005c3	e8 00 00 00 00	 call	 _S_ChangeMusic
  005c8	83 c4 08	 add	 esp, 8
$LN66@Y_Ticker:

; 790  : 
; 791  : 		// If a player has left or joined, recalculate scores.
; 792  : 		if (data.match.numplayers != D_NumPlayers())

  005cb	e8 00 00 00 00	 call	 _D_NumPlayers
  005d0	39 05 0c 03 00
	00		 cmp	 DWORD PTR _data+780, eax
  005d6	74 06		 je	 SHORT $LN67@Y_Ticker

; 793  : 			Y_CalculateMatchWinners();

  005d8	e8 00 00 00 00	 call	 _Y_CalculateMatchWinners
  005dd	90		 npad	 1
$LN67@Y_Ticker:

; 794  : 	}

  005de	eb 2a		 jmp	 SHORT $LN70@Y_Ticker
$LN63@Y_Ticker:

; 795  : 	else if (inttype == int_race || inttype == int_classicrace) // race

  005e0	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  005e7	74 09		 je	 SHORT $LN69@Y_Ticker
  005e9	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _inttype, 7
  005f0	75 18		 jne	 SHORT $LN70@Y_Ticker
$LN69@Y_Ticker:

; 796  : 	{
; 797  : 		if (!intertic) // first time only

  005f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _intertic, 0
  005f9	75 0f		 jne	 SHORT $LN70@Y_Ticker

; 798  : 			S_ChangeMusic(mus_racent, true); // loop it

  005fb	6a 01		 push	 1
  005fd	68 19 04 00 00	 push	 1049			; 00000419H
  00602	e8 00 00 00 00	 call	 _S_ChangeMusic
  00607	83 c4 08	 add	 esp, 8
$LN70@Y_Ticker:

; 799  : 
; 800  : 		// Don't bother recalcing for race. It doesn't make as much sense.
; 801  : 	}
; 802  : }

  0060a	5f		 pop	 edi
  0060b	5e		 pop	 esi
  0060c	5b		 pop	 ebx
  0060d	8b e5		 mov	 esp, ebp
  0060f	5d		 pop	 ebp
  00610	c3		 ret	 0
_Y_Ticker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\y_inter.c
;	COMDAT _Y_IntermissionDrawer
_TEXT	SEGMENT
tv934 = -212						; size = 4
tv951 = -212						; size = 4
$T1 = -208						; size = 4
$T2 = -204						; size = 4
$T3 = -200						; size = 4
$T4 = -196						; size = 4
_i$5 = -128						; size = 4
_name$6 = -124						; size = 9
_colormap$7 = -112					; size = 4
_name$8 = -108						; size = 22
_blueplayers$9 = -84					; size = 4
_redplayers$10 = -80					; size = 4
_y$11 = -76						; size = 4
_x$12 = -72						; size = 4
_i$13 = -68						; size = 4
_colormap$14 = -64					; size = 4
_strtime$15 = -60					; size = 10
_name$16 = -48						; size = 22
_y$17 = -24						; size = 4
_x$18 = -20						; size = 4
_j$19 = -16						; size = 4
_i$20 = -12						; size = 4
_tics$21 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Y_IntermissionDrawer PROC				; COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 173  : 	if (inttype == int_none || rendermode == render_none)

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _inttype, 0
  0001d	74 09		 je	 SHORT $LN12@Y_Intermis
  0001f	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _rendermode, 3
  00026	75 05		 jne	 SHORT $LN11@Y_Intermis
$LN12@Y_Intermis:

; 174  : 		return;

  00028	e9 33 16 00 00	 jmp	 $LN95@Y_Intermis
$LN11@Y_Intermis:

; 175  : 
; 176  : 	if (!usebuffer)

  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usebuffer, 0
  00034	75 18		 jne	 SHORT $LN13@Y_Intermis

; 177  : 		V_DrawFill(0, 0, BASEVIDWIDTH, BASEVIDHEIGHT, 31);

  00036	6a 1f		 push	 31			; 0000001fH
  00038	68 c8 00 00 00	 push	 200			; 000000c8H
  0003d	68 40 01 00 00	 push	 320			; 00000140H
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	e8 00 00 00 00	 call	 _V_DrawFill
  0004b	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@Y_Intermis:

; 178  : 
; 179  : 	if (useinterpic)

  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _useinterpic, 0
  00055	74 19		 je	 SHORT $LN14@Y_Intermis

; 180  : 		V_DrawScaledPatch(0, 0, 0, interpic);

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _interpic
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00068	83 c4 10	 add	 esp, 16			; 00000010H
  0006b	e9 eb 00 00 00	 jmp	 $LN17@Y_Intermis
$LN14@Y_Intermis:

; 181  : 	else if (!usetile)

  00070	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usetile, 0
  00077	0f 85 d0 00 00
	00		 jne	 $LN16@Y_Intermis

; 182  : 	{
; 183  : 		if (rendermode == render_soft && usebuffer)

  0007d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00084	75 59		 jne	 SHORT $LN18@Y_Intermis
  00086	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usebuffer, 0
  0008d	74 50		 je	 SHORT $LN18@Y_Intermis

; 184  : 			VID_BlitLinearScreen(screens[1], screens[0], vid.width*vid.bpp, vid.height, vid.width*vid.bpp, vid.rowbytes);

  0008f	a1 08 00 00 00	 mov	 eax, DWORD PTR _vid+8
  00094	50		 push	 eax
  00095	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _vid+12
  0009b	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR _vid+48
  000a2	51		 push	 ecx
  000a3	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _vid+16
  000a9	52		 push	 edx
  000aa	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  000af	0f af 05 30 00
	00 00		 imul	 eax, DWORD PTR _vid+48
  000b6	50		 push	 eax
  000b7	b9 04 00 00 00	 mov	 ecx, 4
  000bc	6b d1 00	 imul	 edx, ecx, 0
  000bf	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _screens[edx]
  000c5	50		 push	 eax
  000c6	b9 04 00 00 00	 mov	 ecx, 4
  000cb	c1 e1 00	 shl	 ecx, 0
  000ce	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _screens[ecx]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 _VID_BlitLinearScreen
  000da	83 c4 18	 add	 esp, 24			; 00000018H
  000dd	eb 6c		 jmp	 SHORT $LN23@Y_Intermis
$LN18@Y_Intermis:

; 185  : #if defined (SHUFFLE) && defined (HWRENDER)
; 186  : 		else if(rendermode != render_soft && usebuffer)

  000df	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  000e6	74 11		 je	 SHORT $LN20@Y_Intermis
  000e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _usebuffer, 0
  000ef	74 08		 je	 SHORT $LN20@Y_Intermis

; 187  : 		{
; 188  : 			HWR_DrawIntermissionBG();

  000f1	e8 00 00 00 00	 call	 _HWR_DrawIntermissionBG
  000f6	90		 npad	 1

; 189  : 		}

  000f7	eb 52		 jmp	 SHORT $LN23@Y_Intermis
$LN20@Y_Intermis:

; 190  : #endif
; 191  : 		else
; 192  : 		{
; 193  : 			if (widebgpatch && rendermode == render_soft && vid.width / vid.dupx == 400)

  000f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _widebgpatch, 0
  00100	74 35		 je	 SHORT $LN22@Y_Intermis
  00102	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _rendermode, 1
  00109	75 2c		 jne	 SHORT $LN22@Y_Intermis
  0010b	a1 0c 00 00 00	 mov	 eax, DWORD PTR _vid+12
  00110	99		 cdq
  00111	f7 3d 20 00 00
	00		 idiv	 DWORD PTR _vid+32
  00117	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  0011c	75 19		 jne	 SHORT $LN22@Y_Intermis

; 194  : 				V_DrawScaledPatch(0, 0, V_SNAPTOLEFT, widebgpatch);

  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR _widebgpatch
  00123	50		 push	 eax
  00124	68 00 00 00 40	 push	 1073741824		; 40000000H
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00132	83 c4 10	 add	 esp, 16			; 00000010H
  00135	eb 14		 jmp	 SHORT $LN23@Y_Intermis
$LN22@Y_Intermis:

; 195  : 			else
; 196  : 				V_DrawScaledPatch(0, 0, 0, bgpatch);

  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR _bgpatch
  0013c	50		 push	 eax
  0013d	6a 00		 push	 0
  0013f	6a 00		 push	 0
  00141	6a 00		 push	 0
  00143	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00148	83 c4 10	 add	 esp, 16			; 00000010H
$LN23@Y_Intermis:

; 197  : 		}
; 198  : 	}

  0014b	eb 0e		 jmp	 SHORT $LN17@Y_Intermis
$LN16@Y_Intermis:

; 199  : 	else
; 200  : 		V_DrawPatchFill(bgtile);

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bgtile
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _V_DrawPatchFill
  00158	83 c4 04	 add	 esp, 4
$LN17@Y_Intermis:

; 201  : 
; 202  : 	if (inttype == int_coop)

  0015b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _inttype, 1
  00162	0f 85 b5 04 00
	00		 jne	 $LN24@Y_Intermis

; 203  : 	{
; 204  : 		// draw score
; 205  : 		V_DrawScaledPatch(hudinfo[HUD_SCORE].x, hudinfo[HUD_SCORE].y, V_SNAPTOLEFT, sboscore);

  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR _sboscore
  0016d	50		 push	 eax
  0016e	68 00 00 00 40	 push	 1073741824		; 40000000H
  00173	b9 08 00 00 00	 mov	 ecx, 8
  00178	c1 e1 03	 shl	 ecx, 3
  0017b	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _hudinfo[ecx+4]
  00181	52		 push	 edx
  00182	b8 08 00 00 00	 mov	 eax, 8
  00187	c1 e0 03	 shl	 eax, 3
  0018a	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _hudinfo[eax]
  00190	51		 push	 ecx
  00191	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00196	83 c4 10	 add	 esp, 16			; 00000010H

; 206  : 		Y_DrawScaledNum(hudinfo[HUD_SCORENUM].x, hudinfo[HUD_SCORENUM].y, V_SNAPTOLEFT, data.coop.score);

  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  0019e	50		 push	 eax
  0019f	68 00 00 00 40	 push	 1073741824		; 40000000H
  001a4	b9 08 00 00 00	 mov	 ecx, 8
  001a9	6b d1 09	 imul	 edx, ecx, 9
  001ac	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  001b2	50		 push	 eax
  001b3	b9 08 00 00 00	 mov	 ecx, 8
  001b8	6b d1 09	 imul	 edx, ecx, 9
  001bb	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  001c7	83 c4 10	 add	 esp, 16			; 00000010H

; 207  : 
; 208  : 		// draw time
; 209  : 		V_DrawScaledPatch(hudinfo[HUD_TIME].x, hudinfo[HUD_TIME].y, V_SNAPTOLEFT, sbotime);

  001ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _sbotime
  001cf	50		 push	 eax
  001d0	68 00 00 00 40	 push	 1073741824		; 40000000H
  001d5	b9 08 00 00 00	 mov	 ecx, 8
  001da	6b d1 0f	 imul	 edx, ecx, 15
  001dd	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  001e3	50		 push	 eax
  001e4	b9 08 00 00 00	 mov	 ecx, 8
  001e9	6b d1 0f	 imul	 edx, ecx, 15
  001ec	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  001f8	83 c4 10	 add	 esp, 16			; 00000010H

; 210  : 		if (cv_timetic.value == 1)

  001fb	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _cv_timetic+20, 1
  00202	75 36		 jne	 SHORT $LN26@Y_Intermis

; 211  : 			Y_DrawScaledNum(hudinfo[HUD_SECONDS].x, hudinfo[HUD_SECONDS].y, V_SNAPTOLEFT, data.coop.tics);

  00204	a1 1c 00 00 00	 mov	 eax, DWORD PTR _data+28
  00209	50		 push	 eax
  0020a	68 00 00 00 40	 push	 1073741824		; 40000000H
  0020f	b9 08 00 00 00	 mov	 ecx, 8
  00214	6b d1 13	 imul	 edx, ecx, 19
  00217	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  0021d	50		 push	 eax
  0021e	b9 08 00 00 00	 mov	 ecx, 8
  00223	6b d1 13	 imul	 edx, ecx, 19
  00226	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  00232	83 c4 10	 add	 esp, 16			; 00000010H
  00235	e9 83 01 00 00	 jmp	 $LN29@Y_Intermis
$LN26@Y_Intermis:

; 212  : 		else
; 213  : 		{
; 214  : 			if (data.coop.sec < 10)

  0023a	83 3d 18 00 00
	00 0a		 cmp	 DWORD PTR _data+24, 10	; 0000000aH
  00241	7d 2d		 jge	 SHORT $LN28@Y_Intermis

; 215  : 				Y_DrawScaledNum(hudinfo[HUD_LOWSECONDS].x, hudinfo[HUD_LOWSECONDS].y, V_SNAPTOLEFT, 0);

  00243	6a 00		 push	 0
  00245	68 00 00 00 40	 push	 1073741824		; 40000000H
  0024a	b8 08 00 00 00	 mov	 eax, 8
  0024f	6b c8 12	 imul	 ecx, eax, 18
  00252	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _hudinfo[ecx+4]
  00258	52		 push	 edx
  00259	b8 08 00 00 00	 mov	 eax, 8
  0025e	6b c8 12	 imul	 ecx, eax, 18
  00261	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _hudinfo[ecx]
  00267	52		 push	 edx
  00268	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  0026d	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@Y_Intermis:

; 216  : 			Y_DrawScaledNum(hudinfo[HUD_SECONDS].x, hudinfo[HUD_SECONDS].y, V_SNAPTOLEFT, data.coop.sec);

  00270	a1 18 00 00 00	 mov	 eax, DWORD PTR _data+24
  00275	50		 push	 eax
  00276	68 00 00 00 40	 push	 1073741824		; 40000000H
  0027b	b9 08 00 00 00	 mov	 ecx, 8
  00280	6b d1 13	 imul	 edx, ecx, 19
  00283	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  00289	50		 push	 eax
  0028a	b9 08 00 00 00	 mov	 ecx, 8
  0028f	6b d1 13	 imul	 edx, ecx, 19
  00292	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  00298	50		 push	 eax
  00299	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  0029e	83 c4 10	 add	 esp, 16			; 00000010H

; 217  : 			Y_DrawScaledNum(hudinfo[HUD_MINUTES].x, hudinfo[HUD_MINUTES].y, V_SNAPTOLEFT, data.coop.min);

  002a1	a1 14 00 00 00	 mov	 eax, DWORD PTR _data+20
  002a6	50		 push	 eax
  002a7	68 00 00 00 40	 push	 1073741824		; 40000000H
  002ac	b9 08 00 00 00	 mov	 ecx, 8
  002b1	6b d1 14	 imul	 edx, ecx, 20
  002b4	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  002ba	50		 push	 eax
  002bb	b9 08 00 00 00	 mov	 ecx, 8
  002c0	6b d1 14	 imul	 edx, ecx, 20
  002c3	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  002cf	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 			V_DrawScaledPatch(hudinfo[HUD_TIMECOLON].x, hudinfo[HUD_TIMECOLON].y, V_SNAPTOLEFT, sbocolon);

  002d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _sbocolon
  002d7	50		 push	 eax
  002d8	68 00 00 00 40	 push	 1073741824		; 40000000H
  002dd	b9 08 00 00 00	 mov	 ecx, 8
  002e2	6b d1 15	 imul	 edx, ecx, 21
  002e5	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  002eb	50		 push	 eax
  002ec	b9 08 00 00 00	 mov	 ecx, 8
  002f1	6b d1 15	 imul	 edx, ecx, 21
  002f4	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00300	83 c4 10	 add	 esp, 16			; 00000010H

; 219  : 			// we should show centiseconds on the intermission screen too, if the conditions are right.
; 220  : 			if (timeattacking || cv_timetic.value == 2)

  00303	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timeattacking, 0
  0030a	75 0d		 jne	 SHORT $LN30@Y_Intermis
  0030c	83 3d 14 00 00
	00 02		 cmp	 DWORD PTR _cv_timetic+20, 2
  00313	0f 85 a4 00 00
	00		 jne	 $LN29@Y_Intermis
$LN30@Y_Intermis:

; 221  : 			{
; 222  : 				INT32 tics = G_TicsToCentiseconds(data.coop.tics);

  00319	a1 1c 00 00 00	 mov	 eax, DWORD PTR _data+28
  0031e	50		 push	 eax
  0031f	e8 00 00 00 00	 call	 _G_TicsToCentiseconds
  00324	83 c4 04	 add	 esp, 4
  00327	89 45 f8	 mov	 DWORD PTR _tics$21[ebp], eax

; 223  : 				if (tics < 10)

  0032a	83 7d f8 0a	 cmp	 DWORD PTR _tics$21[ebp], 10 ; 0000000aH
  0032e	7d 2d		 jge	 SHORT $LN31@Y_Intermis

; 224  : 					Y_DrawScaledNum(hudinfo[HUD_LOWTICS].x, hudinfo[HUD_LOWTICS].y, V_SNAPTOLEFT, 0);

  00330	6a 00		 push	 0
  00332	68 00 00 00 40	 push	 1073741824		; 40000000H
  00337	b8 08 00 00 00	 mov	 eax, 8
  0033c	c1 e0 04	 shl	 eax, 4
  0033f	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _hudinfo[eax+4]
  00345	51		 push	 ecx
  00346	ba 08 00 00 00	 mov	 edx, 8
  0034b	c1 e2 04	 shl	 edx, 4
  0034e	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  0035a	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@Y_Intermis:

; 225  : 				V_DrawScaledPatch(hudinfo[HUD_TIMETICCOLON].x, hudinfo[HUD_TIMETICCOLON].y, V_SNAPTOLEFT, sbocolon);

  0035d	a1 00 00 00 00	 mov	 eax, DWORD PTR _sbocolon
  00362	50		 push	 eax
  00363	68 00 00 00 40	 push	 1073741824		; 40000000H
  00368	b9 08 00 00 00	 mov	 ecx, 8
  0036d	6b d1 16	 imul	 edx, ecx, 22
  00370	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  00376	50		 push	 eax
  00377	b9 08 00 00 00	 mov	 ecx, 8
  0037c	6b d1 16	 imul	 edx, ecx, 22
  0037f	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0038b	83 c4 10	 add	 esp, 16			; 00000010H

; 226  : 				Y_DrawScaledNum(hudinfo[HUD_TICS].x, hudinfo[HUD_TICS].y, V_SNAPTOLEFT, tics);

  0038e	8b 45 f8	 mov	 eax, DWORD PTR _tics$21[ebp]
  00391	50		 push	 eax
  00392	68 00 00 00 40	 push	 1073741824		; 40000000H
  00397	b9 08 00 00 00	 mov	 ecx, 8
  0039c	6b d1 11	 imul	 edx, ecx, 17
  0039f	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx+4]
  003a5	50		 push	 eax
  003a6	b9 08 00 00 00	 mov	 ecx, 8
  003ab	6b d1 11	 imul	 edx, ecx, 17
  003ae	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _hudinfo[edx]
  003b4	50		 push	 eax
  003b5	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  003ba	83 c4 10	 add	 esp, 16			; 00000010H
$LN29@Y_Intermis:

; 227  : 			}
; 228  : 		}
; 229  : 
; 230  : 		// draw the "got through act" lines and act number
; 231  : 		V_DrawLevelTitle(data.coop.passedx1, 49, 0, data.coop.passed1);

  003bd	68 38 00 00 00	 push	 OFFSET _data+56
  003c2	6a 00		 push	 0
  003c4	6a 31		 push	 49			; 00000031H
  003c6	a1 58 00 00 00	 mov	 eax, DWORD PTR _data+88
  003cb	50		 push	 eax
  003cc	e8 00 00 00 00	 call	 _V_DrawLevelTitle
  003d1	83 c4 10	 add	 esp, 16			; 00000010H

; 232  : 		V_DrawLevelTitle(data.coop.passedx2, 49+V_LevelNameHeight(data.coop.passed2)+2, 0, data.coop.passed2);

  003d4	68 45 00 00 00	 push	 OFFSET _data+69
  003d9	6a 00		 push	 0
  003db	68 45 00 00 00	 push	 OFFSET _data+69
  003e0	e8 00 00 00 00	 call	 _V_LevelNameHeight
  003e5	83 c4 04	 add	 esp, 4
  003e8	83 c0 33	 add	 eax, 51			; 00000033H
  003eb	50		 push	 eax
  003ec	a1 5c 00 00 00	 mov	 eax, DWORD PTR _data+92
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 _V_DrawLevelTitle
  003f7	83 c4 10	 add	 esp, 16			; 00000010H

; 233  : 
; 234  : 		if (mapheaderinfo[gamemap-1].actnum)

  003fa	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gamemap
  00401	83 e8 01	 sub	 eax, 1
  00404	69 c8 84 01 00
	00		 imul	 ecx, eax, 388
  0040a	0f b6 91 42 00
	00 00		 movzx	 edx, BYTE PTR _mapheaderinfo[ecx+66]
  00411	85 d2		 test	 edx, edx
  00413	74 17		 je	 SHORT $LN32@Y_Intermis

; 235  : 			V_DrawScaledPatch(244, 57, 0, data.coop.ttlnum);

  00415	a1 24 00 00 00	 mov	 eax, DWORD PTR _data+36
  0041a	50		 push	 eax
  0041b	6a 00		 push	 0
  0041d	6a 39		 push	 57			; 00000039H
  0041f	68 f4 00 00 00	 push	 244			; 000000f4H
  00424	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00429	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Y_Intermis:

; 236  : 
; 237  : 		V_DrawScaledPatch(68, 84 + 3*SHORT(tallnum[0]->height)/2, 0, data.coop.ptimebonus);

  0042c	a1 28 00 00 00	 mov	 eax, DWORD PTR _data+40
  00431	50		 push	 eax
  00432	6a 00		 push	 0
  00434	b9 04 00 00 00	 mov	 ecx, 4
  00439	6b d1 00	 imul	 edx, ecx, 0
  0043c	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  00442	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00446	6b c1 03	 imul	 eax, ecx, 3
  00449	99		 cdq
  0044a	2b c2		 sub	 eax, edx
  0044c	d1 f8		 sar	 eax, 1
  0044e	83 c0 54	 add	 eax, 84			; 00000054H
  00451	50		 push	 eax
  00452	6a 44		 push	 68			; 00000044H
  00454	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00459	83 c4 10	 add	 esp, 16			; 00000010H

; 238  : 		Y_DrawNum(BASEVIDWIDTH - 68, 85 + 3*SHORT(tallnum[0]->height)/2, data.coop.timebonus);

  0045c	a1 04 00 00 00	 mov	 eax, DWORD PTR _data+4
  00461	50		 push	 eax
  00462	6a 00		 push	 0
  00464	b9 04 00 00 00	 mov	 ecx, 4
  00469	6b d1 00	 imul	 edx, ecx, 0
  0046c	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  00472	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00476	6b c1 03	 imul	 eax, ecx, 3
  00479	99		 cdq
  0047a	2b c2		 sub	 eax, edx
  0047c	d1 f8		 sar	 eax, 1
  0047e	83 c0 55	 add	 eax, 85			; 00000055H
  00481	50		 push	 eax
  00482	68 fc 00 00 00	 push	 252			; 000000fcH
  00487	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  0048c	83 c4 10	 add	 esp, 16			; 00000010H

; 239  : 
; 240  : 		V_DrawScaledPatch(68, 84 + 3*SHORT(tallnum[0]->height), 0, data.coop.pringbonus);

  0048f	a1 2c 00 00 00	 mov	 eax, DWORD PTR _data+44
  00494	50		 push	 eax
  00495	6a 00		 push	 0
  00497	b9 04 00 00 00	 mov	 ecx, 4
  0049c	6b d1 00	 imul	 edx, ecx, 0
  0049f	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  004a5	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  004a9	6b d1 03	 imul	 edx, ecx, 3
  004ac	83 c2 54	 add	 edx, 84			; 00000054H
  004af	52		 push	 edx
  004b0	6a 44		 push	 68			; 00000044H
  004b2	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  004b7	83 c4 10	 add	 esp, 16			; 00000010H

; 241  : 		Y_DrawNum(BASEVIDWIDTH - 68, 85 + 3*SHORT(tallnum[0]->height), data.coop.ringbonus);

  004ba	a1 08 00 00 00	 mov	 eax, DWORD PTR _data+8
  004bf	50		 push	 eax
  004c0	6a 00		 push	 0
  004c2	b9 04 00 00 00	 mov	 ecx, 4
  004c7	6b d1 00	 imul	 edx, ecx, 0
  004ca	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  004d0	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  004d4	6b d1 03	 imul	 edx, ecx, 3
  004d7	83 c2 55	 add	 edx, 85			; 00000055H
  004da	52		 push	 edx
  004db	68 fc 00 00 00	 push	 252			; 000000fcH
  004e0	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  004e5	83 c4 10	 add	 esp, 16			; 00000010H

; 242  : 
; 243  : 		//PERFECT BONUS
; 244  : 		if (data.coop.gotperfbonus)

  004e8	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR _data+32, 0
  004ef	74 69		 je	 SHORT $LN33@Y_Intermis

; 245  : 		{
; 246  : 			V_DrawScaledPatch(56, 84 + ((9*SHORT(tallnum[0]->height))+1)/2, 0, data.coop.pperfbonus);

  004f1	a1 30 00 00 00	 mov	 eax, DWORD PTR _data+48
  004f6	50		 push	 eax
  004f7	6a 00		 push	 0
  004f9	b9 04 00 00 00	 mov	 ecx, 4
  004fe	6b d1 00	 imul	 edx, ecx, 0
  00501	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  00507	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0050b	6b c1 09	 imul	 eax, ecx, 9
  0050e	83 c0 01	 add	 eax, 1
  00511	99		 cdq
  00512	2b c2		 sub	 eax, edx
  00514	d1 f8		 sar	 eax, 1
  00516	83 c0 54	 add	 eax, 84			; 00000054H
  00519	50		 push	 eax
  0051a	6a 38		 push	 56			; 00000038H
  0051c	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00521	83 c4 10	 add	 esp, 16			; 00000010H

; 247  : 			Y_DrawNum(BASEVIDWIDTH - 68, 85 + ((9*SHORT(tallnum[0]->height))+1)/2, data.coop.perfbonus);

  00524	a1 0c 00 00 00	 mov	 eax, DWORD PTR _data+12
  00529	50		 push	 eax
  0052a	6a 00		 push	 0
  0052c	b9 04 00 00 00	 mov	 ecx, 4
  00531	6b d1 00	 imul	 edx, ecx, 0
  00534	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  0053a	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0053e	6b c1 09	 imul	 eax, ecx, 9
  00541	83 c0 01	 add	 eax, 1
  00544	99		 cdq
  00545	2b c2		 sub	 eax, edx
  00547	d1 f8		 sar	 eax, 1
  00549	83 c0 55	 add	 eax, 85			; 00000055H
  0054c	50		 push	 eax
  0054d	68 fc 00 00 00	 push	 252			; 000000fcH
  00552	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  00557	83 c4 10	 add	 esp, 16			; 00000010H
$LN33@Y_Intermis:

; 248  : 		}
; 249  : 
; 250  : 		V_DrawScaledPatch(88, 84 + 6*SHORT(tallnum[0]->height), 0, data.coop.ptotal);

  0055a	a1 34 00 00 00	 mov	 eax, DWORD PTR _data+52
  0055f	50		 push	 eax
  00560	6a 00		 push	 0
  00562	b9 04 00 00 00	 mov	 ecx, 4
  00567	6b d1 00	 imul	 edx, ecx, 0
  0056a	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  00570	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00574	6b d1 06	 imul	 edx, ecx, 6
  00577	83 c2 54	 add	 edx, 84			; 00000054H
  0057a	52		 push	 edx
  0057b	6a 58		 push	 88			; 00000058H
  0057d	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00582	83 c4 10	 add	 esp, 16			; 00000010H

; 251  : 		Y_DrawNum(BASEVIDWIDTH - 68, 85 + 6*SHORT(tallnum[0]->height), data.coop.total);

  00585	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  0058a	50		 push	 eax
  0058b	6a 00		 push	 0
  0058d	b9 04 00 00 00	 mov	 ecx, 4
  00592	6b d1 00	 imul	 edx, ecx, 0
  00595	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _tallnum[edx]
  0059b	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0059f	6b d1 06	 imul	 edx, ecx, 6
  005a2	83 c2 55	 add	 edx, 85			; 00000055H
  005a5	52		 push	 edx
  005a6	68 fc 00 00 00	 push	 252			; 000000fcH
  005ab	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  005b0	83 c4 10	 add	 esp, 16			; 00000010H

; 252  : 
; 253  : 		if (gottimebonus && endtic != -1)

  005b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gottimebonus, 0
  005ba	74 25		 je	 SHORT $LN34@Y_Intermis
  005bc	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _endtic, -1
  005c3	74 1c		 je	 SHORT $LN34@Y_Intermis

; 254  : 			V_DrawCenteredString(BASEVIDWIDTH/2, 136, V_YELLOWMAP, "GOT TIME BONUS EMBLEM!");

  005c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MACILDBE@GOT?5TIME?5BONUS?5EMBLEM?$CB@
  005ca	68 00 00 10 00	 push	 1048576			; 00100000H
  005cf	68 88 00 00 00	 push	 136			; 00000088H
  005d4	68 a0 00 00 00	 push	 160			; 000000a0H
  005d9	e8 00 00 00 00	 call	 _V_DrawCenteredString
  005de	83 c4 10	 add	 esp, 16			; 00000010H
$LN34@Y_Intermis:

; 255  : 		if (gotemblem && !gottimebonus && endtic != -1)

  005e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gotemblem, 0
  005e8	74 2e		 je	 SHORT $LN35@Y_Intermis
  005ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _gottimebonus, 0
  005f1	75 25		 jne	 SHORT $LN35@Y_Intermis
  005f3	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _endtic, -1
  005fa	74 1c		 je	 SHORT $LN35@Y_Intermis

; 256  : 			V_DrawCenteredString(BASEVIDWIDTH/2, 172, V_YELLOWMAP, "GOT PERFECT BONUS EMBLEM!");

  005fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MPBHKKPP@GOT?5PERFECT?5BONUS?5EMBLEM?$CB@
  00601	68 00 00 10 00	 push	 1048576			; 00100000H
  00606	68 ac 00 00 00	 push	 172			; 000000acH
  0060b	68 a0 00 00 00	 push	 160			; 000000a0H
  00610	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00615	83 c4 10	 add	 esp, 16			; 00000010H
$LN35@Y_Intermis:

; 257  : 	}

  00618	e9 b6 0f 00 00	 jmp	 $LN9@Y_Intermis
$LN24@Y_Intermis:

; 258  : 	else if (inttype == int_spec)

  0061d	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _inttype, 5
  00624	0f 85 f2 01 00
	00		 jne	 $LN36@Y_Intermis

; 259  : 	{
; 260  : 		// draw the header
; 261  : 		if (endtic != -1 && ALL7EMERALDS(emeralds) && data.spec.nowsuper != NULL)

  0062a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _endtic, -1
  00631	74 2e		 je	 SHORT $LN38@Y_Intermis
  00633	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  0063a	83 e0 7f	 and	 eax, 127		; 0000007fH
  0063d	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00640	75 1f		 jne	 SHORT $LN38@Y_Intermis
  00642	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _data+16, 0
  00649	74 16		 je	 SHORT $LN38@Y_Intermis

; 262  : 			V_DrawScaledPatch(48, 32, 0, data.spec.nowsuper);

  0064b	a1 10 00 00 00	 mov	 eax, DWORD PTR _data+16
  00650	50		 push	 eax
  00651	6a 00		 push	 0
  00653	6a 20		 push	 32			; 00000020H
  00655	6a 30		 push	 48			; 00000030H
  00657	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0065c	83 c4 10	 add	 esp, 16			; 00000010H
  0065f	eb 19		 jmp	 SHORT $LN39@Y_Intermis
$LN38@Y_Intermis:

; 263  : 		else
; 264  : 			V_DrawScaledPatch(data.spec.headx, 26, 0, data.spec.cemerald);

  00661	a1 0c 00 00 00	 mov	 eax, DWORD PTR _data+12
  00666	50		 push	 eax
  00667	6a 00		 push	 0
  00669	6a 1a		 push	 26			; 0000001aH
  0066b	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _data+8
  00671	51		 push	 ecx
  00672	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00677	83 c4 10	 add	 esp, 16			; 00000010H
$LN39@Y_Intermis:

; 265  : 
; 266  : 		// draw the emeralds
; 267  : 		if (intertic & 1)

  0067a	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  0067f	83 e0 01	 and	 eax, 1
  00682	0f 84 2d 01 00
	00		 je	 $LN47@Y_Intermis

; 268  : 		{
; 269  : 			if (emeralds & EMERALD1)

  00688	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  0068f	83 e0 01	 and	 eax, 1
  00692	74 1d		 je	 SHORT $LN41@Y_Intermis

; 270  : 				V_DrawScaledPatch(80, 92, 0, emeraldpics[0]);

  00694	b8 04 00 00 00	 mov	 eax, 4
  00699	6b c8 00	 imul	 ecx, eax, 0
  0069c	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _emeraldpics[ecx]
  006a2	52		 push	 edx
  006a3	6a 00		 push	 0
  006a5	6a 5c		 push	 92			; 0000005cH
  006a7	6a 50		 push	 80			; 00000050H
  006a9	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  006ae	83 c4 10	 add	 esp, 16			; 00000010H
$LN41@Y_Intermis:

; 271  : 			if (emeralds & EMERALD2)

  006b1	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  006b8	83 e0 02	 and	 eax, 2
  006bb	74 1d		 je	 SHORT $LN42@Y_Intermis

; 272  : 				V_DrawScaledPatch(104, 92, 0, emeraldpics[1]);

  006bd	b8 04 00 00 00	 mov	 eax, 4
  006c2	c1 e0 00	 shl	 eax, 0
  006c5	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _emeraldpics[eax]
  006cb	51		 push	 ecx
  006cc	6a 00		 push	 0
  006ce	6a 5c		 push	 92			; 0000005cH
  006d0	6a 68		 push	 104			; 00000068H
  006d2	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  006d7	83 c4 10	 add	 esp, 16			; 00000010H
$LN42@Y_Intermis:

; 273  : 			if (emeralds & EMERALD3)

  006da	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  006e1	83 e0 04	 and	 eax, 4
  006e4	74 1f		 je	 SHORT $LN43@Y_Intermis

; 274  : 				V_DrawScaledPatch(128, 92, 0, emeraldpics[2]);

  006e6	b8 04 00 00 00	 mov	 eax, 4
  006eb	d1 e0		 shl	 eax, 1
  006ed	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _emeraldpics[eax]
  006f3	51		 push	 ecx
  006f4	6a 00		 push	 0
  006f6	6a 5c		 push	 92			; 0000005cH
  006f8	68 80 00 00 00	 push	 128			; 00000080H
  006fd	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00702	83 c4 10	 add	 esp, 16			; 00000010H
$LN43@Y_Intermis:

; 275  : 			if (emeralds & EMERALD4)

  00705	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  0070c	83 e0 08	 and	 eax, 8
  0070f	74 20		 je	 SHORT $LN44@Y_Intermis

; 276  : 				V_DrawScaledPatch(152, 92, 0, emeraldpics[3]);

  00711	b8 04 00 00 00	 mov	 eax, 4
  00716	6b c8 03	 imul	 ecx, eax, 3
  00719	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _emeraldpics[ecx]
  0071f	52		 push	 edx
  00720	6a 00		 push	 0
  00722	6a 5c		 push	 92			; 0000005cH
  00724	68 98 00 00 00	 push	 152			; 00000098H
  00729	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0072e	83 c4 10	 add	 esp, 16			; 00000010H
$LN44@Y_Intermis:

; 277  : 			if (emeralds & EMERALD5)

  00731	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  00738	83 e0 10	 and	 eax, 16			; 00000010H
  0073b	74 20		 je	 SHORT $LN45@Y_Intermis

; 278  : 				V_DrawScaledPatch(176, 92, 0, emeraldpics[4]);

  0073d	b8 04 00 00 00	 mov	 eax, 4
  00742	c1 e0 02	 shl	 eax, 2
  00745	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _emeraldpics[eax]
  0074b	51		 push	 ecx
  0074c	6a 00		 push	 0
  0074e	6a 5c		 push	 92			; 0000005cH
  00750	68 b0 00 00 00	 push	 176			; 000000b0H
  00755	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0075a	83 c4 10	 add	 esp, 16			; 00000010H
$LN45@Y_Intermis:

; 279  : 			if (emeralds & EMERALD6)

  0075d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  00764	83 e0 20	 and	 eax, 32			; 00000020H
  00767	74 20		 je	 SHORT $LN46@Y_Intermis

; 280  : 				V_DrawScaledPatch(200, 92, 0, emeraldpics[5]);

  00769	b8 04 00 00 00	 mov	 eax, 4
  0076e	6b c8 05	 imul	 ecx, eax, 5
  00771	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _emeraldpics[ecx]
  00777	52		 push	 edx
  00778	6a 00		 push	 0
  0077a	6a 5c		 push	 92			; 0000005cH
  0077c	68 c8 00 00 00	 push	 200			; 000000c8H
  00781	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  00786	83 c4 10	 add	 esp, 16			; 00000010H
$LN46@Y_Intermis:

; 281  : 			if (emeralds & EMERALD7)

  00789	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR _emeralds
  00790	83 e0 40	 and	 eax, 64			; 00000040H
  00793	74 20		 je	 SHORT $LN47@Y_Intermis

; 282  : 				V_DrawScaledPatch(224, 92, 0, emeraldpics[6]);

  00795	b8 04 00 00 00	 mov	 eax, 4
  0079a	6b c8 06	 imul	 ecx, eax, 6
  0079d	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _emeraldpics[ecx]
  007a3	52		 push	 edx
  007a4	6a 00		 push	 0
  007a6	6a 5c		 push	 92			; 0000005cH
  007a8	68 e0 00 00 00	 push	 224			; 000000e0H
  007ad	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  007b2	83 c4 10	 add	 esp, 16			; 00000010H
$LN47@Y_Intermis:

; 283  : 		}
; 284  : 
; 285  : 		V_DrawScaledPatch(80, 132, 0, data.spec.pringbonus);

  007b5	a1 14 00 00 00	 mov	 eax, DWORD PTR _data+20
  007ba	50		 push	 eax
  007bb	6a 00		 push	 0
  007bd	68 84 00 00 00	 push	 132			; 00000084H
  007c2	6a 50		 push	 80			; 00000050H
  007c4	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  007c9	83 c4 10	 add	 esp, 16			; 00000010H

; 286  : 		Y_DrawNum(232, 133, data.spec.ringbonus);

  007cc	a1 04 00 00 00	 mov	 eax, DWORD PTR _data+4
  007d1	50		 push	 eax
  007d2	6a 00		 push	 0
  007d4	68 85 00 00 00	 push	 133			; 00000085H
  007d9	68 e8 00 00 00	 push	 232			; 000000e8H
  007de	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  007e3	83 c4 10	 add	 esp, 16			; 00000010H

; 287  : 		V_DrawScaledPatch(80, 148, 0, data.spec.cscore);

  007e6	a1 18 00 00 00	 mov	 eax, DWORD PTR _data+24
  007eb	50		 push	 eax
  007ec	6a 00		 push	 0
  007ee	68 94 00 00 00	 push	 148			; 00000094H
  007f3	6a 50		 push	 80			; 00000050H
  007f5	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  007fa	83 c4 10	 add	 esp, 16			; 00000010H

; 288  : 		Y_DrawNum(232, 149, data.spec.score);

  007fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _data
  00802	50		 push	 eax
  00803	6a 00		 push	 0
  00805	68 95 00 00 00	 push	 149			; 00000095H
  0080a	68 e8 00 00 00	 push	 232			; 000000e8H
  0080f	e8 00 00 00 00	 call	 _Y_DrawScaledNum
  00814	83 c4 10	 add	 esp, 16			; 00000010H

; 289  : 	}

  00817	e9 b7 0d 00 00	 jmp	 $LN9@Y_Intermis
$LN36@Y_Intermis:

; 290  : 	else if (inttype == int_match || inttype == int_race)

  0081c	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _inttype, 2
  00823	74 0d		 je	 SHORT $LN50@Y_Intermis
  00825	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  0082c	0f 85 a9 05 00
	00		 jne	 $LN48@Y_Intermis
$LN50@Y_Intermis:

; 291  : 	{
; 292  : 		INT32 i = 0, j = 0;

  00832	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$20[ebp], 0
  00839	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _j$19[ebp], 0

; 293  : 		INT32 x = 4;

  00840	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _x$18[ebp], 4

; 294  : 		INT32 y = 48;

  00847	c7 45 e8 30 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 48 ; 00000030H

; 295  : 		char name[MAXPLAYERNAME+1];
; 296  : 
; 297  : 		// draw the header
; 298  : 		V_DrawScaledPatch(112, 2, 0, data.match.result);

  0084e	a1 00 03 00 00	 mov	 eax, DWORD PTR _data+768
  00853	50		 push	 eax
  00854	6a 00		 push	 0
  00856	6a 02		 push	 2
  00858	6a 70		 push	 112			; 00000070H
  0085a	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  0085f	83 c4 10	 add	 esp, 16			; 00000010H

; 299  : 
; 300  : 		// draw the level name
; 301  : 		V_DrawCenteredString(BASEVIDWIDTH/2, 20, 0, data.match.levelstring);

  00862	68 10 03 00 00	 push	 OFFSET _data+784
  00867	6a 00		 push	 0
  00869	6a 14		 push	 20			; 00000014H
  0086b	68 a0 00 00 00	 push	 160			; 000000a0H
  00870	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00875	83 c4 10	 add	 esp, 16			; 00000010H

; 302  : 		V_DrawFill(4, 42, 312, 1, 0);

  00878	6a 00		 push	 0
  0087a	6a 01		 push	 1
  0087c	68 38 01 00 00	 push	 312			; 00000138H
  00881	6a 2a		 push	 42			; 0000002aH
  00883	6a 04		 push	 4
  00885	e8 00 00 00 00	 call	 _V_DrawFill
  0088a	83 c4 14	 add	 esp, 20			; 00000014H

; 303  : 
; 304  : 		if (data.match.numplayers > 9)

  0088d	83 3d 0c 03 00
	00 09		 cmp	 DWORD PTR _data+780, 9
  00894	0f 8e 97 00 00
	00		 jle	 $LN51@Y_Intermis

; 305  : 		{
; 306  : 			V_DrawFill(160, 32, 1, 152, 0);

  0089a	6a 00		 push	 0
  0089c	68 98 00 00 00	 push	 152			; 00000098H
  008a1	6a 01		 push	 1
  008a3	6a 20		 push	 32			; 00000020H
  008a5	68 a0 00 00 00	 push	 160			; 000000a0H
  008aa	e8 00 00 00 00	 call	 _V_DrawFill
  008af	83 c4 14	 add	 esp, 20			; 00000014H

; 307  : 
; 308  : 			if (inttype == int_race)

  008b2	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  008b9	75 1f		 jne	 SHORT $LN52@Y_Intermis

; 309  : 				V_DrawRightAlignedString(x+152, 32, V_YELLOWMAP, "TIME");

  008bb	68 00 00 00 00	 push	 OFFSET ??_C@_04OHBONDIN@TIME@
  008c0	68 00 00 10 00	 push	 1048576			; 00100000H
  008c5	6a 20		 push	 32			; 00000020H
  008c7	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  008ca	05 98 00 00 00	 add	 eax, 152		; 00000098H
  008cf	50		 push	 eax
  008d0	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  008d5	83 c4 10	 add	 esp, 16			; 00000010H
  008d8	eb 1d		 jmp	 SHORT $LN53@Y_Intermis
$LN52@Y_Intermis:

; 310  : 			else
; 311  : 				V_DrawRightAlignedString(x+152, 32, V_YELLOWMAP, "SCORE");

  008da	68 00 00 00 00	 push	 OFFSET ??_C@_05PKDFAPGJ@SCORE@
  008df	68 00 00 10 00	 push	 1048576			; 00100000H
  008e4	6a 20		 push	 32			; 00000020H
  008e6	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  008e9	05 98 00 00 00	 add	 eax, 152		; 00000098H
  008ee	50		 push	 eax
  008ef	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  008f4	83 c4 10	 add	 esp, 16			; 00000010H
$LN53@Y_Intermis:

; 312  : 
; 313  : 			V_DrawCenteredString(x+(BASEVIDWIDTH/2)+6, 32, V_YELLOWMAP, "#");

  008f7	68 00 00 00 00	 push	 OFFSET ??_C@_01IPJKGB@?$CD@
  008fc	68 00 00 10 00	 push	 1048576			; 00100000H
  00901	6a 20		 push	 32			; 00000020H
  00903	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00906	05 a6 00 00 00	 add	 eax, 166		; 000000a6H
  0090b	50		 push	 eax
  0090c	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00911	83 c4 10	 add	 esp, 16			; 00000010H

; 314  : 			V_DrawString(x+(BASEVIDWIDTH/2)+36, 32, V_YELLOWMAP, "NAME");

  00914	68 00 00 00 00	 push	 OFFSET ??_C@_04IPKHEEB@NAME@
  00919	68 00 00 10 00	 push	 1048576			; 00100000H
  0091e	6a 20		 push	 32			; 00000020H
  00920	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00923	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00928	50		 push	 eax
  00929	e8 00 00 00 00	 call	 _V_DrawString
  0092e	83 c4 10	 add	 esp, 16			; 00000010H
$LN51@Y_Intermis:

; 315  : 		}
; 316  : 
; 317  : 		V_DrawCenteredString(x+6, 32, V_YELLOWMAP, "#");

  00931	68 00 00 00 00	 push	 OFFSET ??_C@_01IPJKGB@?$CD@
  00936	68 00 00 10 00	 push	 1048576			; 00100000H
  0093b	6a 20		 push	 32			; 00000020H
  0093d	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00940	83 c0 06	 add	 eax, 6
  00943	50		 push	 eax
  00944	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00949	83 c4 10	 add	 esp, 16			; 00000010H

; 318  : 		V_DrawString(x+36, 32, V_YELLOWMAP, "NAME");

  0094c	68 00 00 00 00	 push	 OFFSET ??_C@_04IPKHEEB@NAME@
  00951	68 00 00 10 00	 push	 1048576			; 00100000H
  00956	6a 20		 push	 32			; 00000020H
  00958	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  0095b	83 c0 24	 add	 eax, 36			; 00000024H
  0095e	50		 push	 eax
  0095f	e8 00 00 00 00	 call	 _V_DrawString
  00964	83 c4 10	 add	 esp, 16			; 00000010H

; 319  : 
; 320  : 		if (inttype == int_race)

  00967	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  0096e	75 1f		 jne	 SHORT $LN54@Y_Intermis

; 321  : 			V_DrawRightAlignedString(x+(BASEVIDWIDTH/2)+152, 32, V_YELLOWMAP, "TIME");

  00970	68 00 00 00 00	 push	 OFFSET ??_C@_04OHBONDIN@TIME@
  00975	68 00 00 10 00	 push	 1048576			; 00100000H
  0097a	6a 20		 push	 32			; 00000020H
  0097c	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  0097f	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00984	50		 push	 eax
  00985	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  0098a	83 c4 10	 add	 esp, 16			; 00000010H
  0098d	eb 1d		 jmp	 SHORT $LN55@Y_Intermis
$LN54@Y_Intermis:

; 322  : 		else
; 323  : 			V_DrawRightAlignedString(x+(BASEVIDWIDTH/2)+152, 32, V_YELLOWMAP, "SCORE");

  0098f	68 00 00 00 00	 push	 OFFSET ??_C@_05PKDFAPGJ@SCORE@
  00994	68 00 00 10 00	 push	 1048576			; 00100000H
  00999	6a 20		 push	 32			; 00000020H
  0099b	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  0099e	05 38 01 00 00	 add	 eax, 312		; 00000138H
  009a3	50		 push	 eax
  009a4	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  009a9	83 c4 10	 add	 esp, 16			; 00000010H
$LN55@Y_Intermis:

; 324  : 
; 325  : 		for (i = 0; i < data.match.numplayers; i++)

  009ac	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$20[ebp], 0
  009b3	eb 09		 jmp	 SHORT $LN4@Y_Intermis
$LN2@Y_Intermis:
  009b5	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  009b8	83 c0 01	 add	 eax, 1
  009bb	89 45 f4	 mov	 DWORD PTR _i$20[ebp], eax
$LN4@Y_Intermis:
  009be	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  009c1	3b 05 0c 03 00
	00		 cmp	 eax, DWORD PTR _data+780
  009c7	0f 8d 09 04 00
	00		 jge	 $LN3@Y_Intermis

; 326  : 		{
; 327  : 			char strtime[10];
; 328  : 
; 329  : 			if (data.match.spectator[i])

  009cd	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  009d0	83 3c 85 00 01
	00 00 00	 cmp	 DWORD PTR _data[eax*4+256], 0
  009d8	74 02		 je	 SHORT $LN56@Y_Intermis

; 330  : 				continue; //Ignore spectators.

  009da	eb d9		 jmp	 SHORT $LN2@Y_Intermis
$LN56@Y_Intermis:

; 331  : 
; 332  : 			V_DrawCenteredString(x+6, y, 0, va("%d", j+1));

  009dc	8b 45 f0	 mov	 eax, DWORD PTR _j$19[ebp]
  009df	83 c0 01	 add	 eax, 1
  009e2	50		 push	 eax
  009e3	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  009e8	e8 00 00 00 00	 call	 _va
  009ed	83 c4 08	 add	 esp, 8
  009f0	50		 push	 eax
  009f1	6a 00		 push	 0
  009f3	8b 4d e8	 mov	 ecx, DWORD PTR _y$17[ebp]
  009f6	51		 push	 ecx
  009f7	8b 55 ec	 mov	 edx, DWORD PTR _x$18[ebp]
  009fa	83 c2 06	 add	 edx, 6
  009fd	52		 push	 edx
  009fe	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00a03	83 c4 10	 add	 esp, 16			; 00000010H

; 333  : 			j++; //We skip spectators, but not their number.

  00a06	8b 45 f0	 mov	 eax, DWORD PTR _j$19[ebp]
  00a09	83 c0 01	 add	 eax, 1
  00a0c	89 45 f0	 mov	 DWORD PTR _j$19[ebp], eax

; 334  : 
; 335  : 			if (playeringame[data.match.num[i]])

  00a0f	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00a12	8b 0c 85 00 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+512]
  00a19	83 3c 8d 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[ecx*4], 0
  00a21	0f 84 86 03 00
	00		 je	 $LN71@Y_Intermis

; 336  : 			{
; 337  : 				if (data.match.color[i] == 0)

  00a27	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00a2a	83 3c 85 80 00
	00 00 00	 cmp	 DWORD PTR _data[eax*4+128], 0
  00a32	75 2e		 jne	 SHORT $LN58@Y_Intermis

; 338  : 					V_DrawSmallScaledPatch(x+16, y-4, 0,faceprefix[*data.match.character[i]]);

  00a34	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00a37	8b 0c 85 80 01
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+384]
  00a3e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a40	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _faceprefix[edx*4]
  00a47	50		 push	 eax
  00a48	6a 00		 push	 0
  00a4a	8b 4d e8	 mov	 ecx, DWORD PTR _y$17[ebp]
  00a4d	83 e9 04	 sub	 ecx, 4
  00a50	51		 push	 ecx
  00a51	8b 55 ec	 mov	 edx, DWORD PTR _x$18[ebp]
  00a54	83 c2 10	 add	 edx, 16			; 00000010H
  00a57	52		 push	 edx
  00a58	e8 00 00 00 00	 call	 _V_DrawSmallScaledPatch
  00a5d	83 c4 10	 add	 esp, 16			; 00000010H
  00a60	eb 5c		 jmp	 SHORT $LN59@Y_Intermis
$LN58@Y_Intermis:

; 339  : 				else
; 340  : 				{
; 341  : 					UINT8 *colormap = (UINT8 *) translationtables[*data.match.character[i]] - 256 + (*data.match.color[i]<<8);

  00a62	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00a65	8b 0c 85 80 01
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+384]
  00a6c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a6e	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _translationtables[edx*4]
  00a75	8b 4d f4	 mov	 ecx, DWORD PTR _i$20[ebp]
  00a78	8b 14 8d 80 00
	00 00		 mov	 edx, DWORD PTR _data[ecx*4+128]
  00a7f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00a81	c1 e1 08	 shl	 ecx, 8
  00a84	8d 94 08 00 ff
	ff ff		 lea	 edx, DWORD PTR [eax+ecx-256]
  00a8b	89 55 c0	 mov	 DWORD PTR _colormap$14[ebp], edx

; 342  : 					V_DrawSmallMappedPatch(x+16, y-4, 0,faceprefix[*data.match.character[i]], colormap);

  00a8e	8b 45 c0	 mov	 eax, DWORD PTR _colormap$14[ebp]
  00a91	50		 push	 eax
  00a92	8b 4d f4	 mov	 ecx, DWORD PTR _i$20[ebp]
  00a95	8b 14 8d 80 01
	00 00		 mov	 edx, DWORD PTR _data[ecx*4+384]
  00a9c	8b 02		 mov	 eax, DWORD PTR [edx]
  00a9e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _faceprefix[eax*4]
  00aa5	51		 push	 ecx
  00aa6	6a 00		 push	 0
  00aa8	8b 55 e8	 mov	 edx, DWORD PTR _y$17[ebp]
  00aab	83 ea 04	 sub	 edx, 4
  00aae	52		 push	 edx
  00aaf	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00ab2	83 c0 10	 add	 eax, 16			; 00000010H
  00ab5	50		 push	 eax
  00ab6	e8 00 00 00 00	 call	 _V_DrawSmallMappedPatch
  00abb	83 c4 14	 add	 esp, 20			; 00000014H
$LN59@Y_Intermis:

; 343  : 				}
; 344  : 
; 345  : 				if (data.match.numplayers > 9)

  00abe	83 3d 0c 03 00
	00 09		 cmp	 DWORD PTR _data+780, 9
  00ac5	7e 3f		 jle	 SHORT $LN60@Y_Intermis

; 346  : 				{
; 347  : 					if (inttype == int_race)

  00ac7	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  00ace	75 1b		 jne	 SHORT $LN62@Y_Intermis

; 348  : 						strlcpy(name, data.match.name[i], 8);

  00ad0	6a 08		 push	 8
  00ad2	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00ad5	8b 0c 85 80 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+640]
  00adc	51		 push	 ecx
  00add	8d 55 d0	 lea	 edx, DWORD PTR _name$16[ebp]
  00ae0	52		 push	 edx
  00ae1	e8 00 00 00 00	 call	 _strlcpy
  00ae6	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ae9	eb 19		 jmp	 SHORT $LN63@Y_Intermis
$LN62@Y_Intermis:

; 349  : 					else
; 350  : 						strlcpy(name, data.match.name[i], 9);

  00aeb	6a 09		 push	 9
  00aed	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00af0	8b 0c 85 80 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+640]
  00af7	51		 push	 ecx
  00af8	8d 55 d0	 lea	 edx, DWORD PTR _name$16[ebp]
  00afb	52		 push	 edx
  00afc	e8 00 00 00 00	 call	 _strlcpy
  00b01	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN63@Y_Intermis:

; 351  : 				}

  00b04	eb 19		 jmp	 SHORT $LN61@Y_Intermis
$LN60@Y_Intermis:

; 352  : 				else
; 353  : 					STRBUFCPY(name, data.match.name[i]);

  00b06	6a 16		 push	 22			; 00000016H
  00b08	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00b0b	8b 0c 85 80 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+640]
  00b12	51		 push	 ecx
  00b13	8d 55 d0	 lea	 edx, DWORD PTR _name$16[ebp]
  00b16	52		 push	 edx
  00b17	e8 00 00 00 00	 call	 _strlcpy
  00b1c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN61@Y_Intermis:

; 354  : 
; 355  : 				V_DrawString(x+36, y, V_ALLOWLOWERCASE, name);

  00b1f	8d 45 d0	 lea	 eax, DWORD PTR _name$16[ebp]
  00b22	50		 push	 eax
  00b23	68 00 00 04 00	 push	 262144			; 00040000H
  00b28	8b 4d e8	 mov	 ecx, DWORD PTR _y$17[ebp]
  00b2b	51		 push	 ecx
  00b2c	8b 55 ec	 mov	 edx, DWORD PTR _x$18[ebp]
  00b2f	83 c2 24	 add	 edx, 36			; 00000024H
  00b32	52		 push	 edx
  00b33	e8 00 00 00 00	 call	 _V_DrawString
  00b38	83 c4 10	 add	 esp, 16			; 00000010H

; 356  : 
; 357  : 				if (data.match.numplayers > 9)

  00b3b	83 3d 0c 03 00
	00 09		 cmp	 DWORD PTR _data+780, 9
  00b42	0f 8e e7 00 00
	00		 jle	 $LN64@Y_Intermis

; 358  : 				{
; 359  : 					if (inttype == int_match)

  00b48	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _inttype, 2
  00b4f	75 35		 jne	 SHORT $LN66@Y_Intermis

; 360  : 						V_DrawRightAlignedString(x+152, y, 0, va("%i", data.match.scores[i]));

  00b51	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00b54	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4]
  00b5b	51		 push	 ecx
  00b5c	68 00 00 00 00	 push	 OFFSET ??_C@_02IKAHHCAI@?$CFi@
  00b61	e8 00 00 00 00	 call	 _va
  00b66	83 c4 08	 add	 esp, 8
  00b69	50		 push	 eax
  00b6a	6a 00		 push	 0
  00b6c	8b 55 e8	 mov	 edx, DWORD PTR _y$17[ebp]
  00b6f	52		 push	 edx
  00b70	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00b73	05 98 00 00 00	 add	 eax, 152		; 00000098H
  00b78	50		 push	 eax
  00b79	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  00b7e	83 c4 10	 add	 esp, 16			; 00000010H
  00b81	e9 a4 00 00 00	 jmp	 $LN68@Y_Intermis
$LN66@Y_Intermis:

; 361  : 					else if (inttype == int_race)

  00b86	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  00b8d	0f 85 97 00 00
	00		 jne	 $LN68@Y_Intermis

; 362  : 					{
; 363  : 						_snprintf(strtime, sizeof strtime,

  00b93	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00b96	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4]
  00b9d	51		 push	 ecx
  00b9e	e8 00 00 00 00	 call	 _G_TicsToCentiseconds
  00ba3	83 c4 04	 add	 esp, 4
  00ba6	50		 push	 eax
  00ba7	8b 55 f4	 mov	 edx, DWORD PTR _i$20[ebp]
  00baa	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _data[edx*4]
  00bb1	50		 push	 eax
  00bb2	e8 00 00 00 00	 call	 _G_TicsToSeconds
  00bb7	83 c4 04	 add	 esp, 4
  00bba	50		 push	 eax
  00bbb	6a 01		 push	 1
  00bbd	8b 4d f4	 mov	 ecx, DWORD PTR _i$20[ebp]
  00bc0	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _data[ecx*4]
  00bc7	52		 push	 edx
  00bc8	e8 00 00 00 00	 call	 _G_TicsToMinutes
  00bcd	83 c4 08	 add	 esp, 8
  00bd0	50		 push	 eax
  00bd1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CIBLIMGJ@?$CFi?3?$CF02i?4?$CF02i@
  00bd6	6a 0a		 push	 10			; 0000000aH
  00bd8	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00bdb	50		 push	 eax
  00bdc	e8 00 00 00 00	 call	 __snprintf
  00be1	83 c4 18	 add	 esp, 24			; 00000018H

; 364  : 							"%i:%02i.%02i",
; 365  : 							G_TicsToMinutes(data.match.scores[i], true),
; 366  : 							G_TicsToSeconds(data.match.scores[i]), G_TicsToCentiseconds(data.match.scores[i]));
; 367  : 						strtime[sizeof strtime - 1] = '\0';

  00be4	b8 01 00 00 00	 mov	 eax, 1
  00be9	6b c8 09	 imul	 ecx, eax, 9
  00bec	89 8d 3c ff ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00bf2	83 bd 3c ff ff
	ff 0a		 cmp	 DWORD PTR $T4[ebp], 10	; 0000000aH
  00bf9	73 02		 jae	 SHORT $LN97@Y_Intermis
  00bfb	eb 06		 jmp	 SHORT $LN98@Y_Intermis
$LN97@Y_Intermis:
  00bfd	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00c02	90		 npad	 1
$LN98@Y_Intermis:
  00c03	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  00c09	c6 44 15 c4 00	 mov	 BYTE PTR _strtime$15[ebp+edx], 0

; 368  : 						V_DrawRightAlignedString(x+152, y, 0, strtime);

  00c0e	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00c11	50		 push	 eax
  00c12	6a 00		 push	 0
  00c14	8b 4d e8	 mov	 ecx, DWORD PTR _y$17[ebp]
  00c17	51		 push	 ecx
  00c18	8b 55 ec	 mov	 edx, DWORD PTR _x$18[ebp]
  00c1b	81 c2 98 00 00
	00		 add	 edx, 152		; 00000098H
  00c21	52		 push	 edx
  00c22	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  00c27	83 c4 10	 add	 esp, 16			; 00000010H
$LN68@Y_Intermis:

; 369  : 					}
; 370  : 				}

  00c2a	e9 7e 01 00 00	 jmp	 $LN71@Y_Intermis
$LN64@Y_Intermis:

; 371  : 				else
; 372  : 				{
; 373  : 					if (inttype == int_match)

  00c2f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _inttype, 2
  00c36	75 35		 jne	 SHORT $LN69@Y_Intermis

; 374  : 						V_DrawRightAlignedString(x+152+BASEVIDWIDTH/2, y, 0, va("%u", data.match.scores[i]));

  00c38	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00c3b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4]
  00c42	51		 push	 ecx
  00c43	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00c48	e8 00 00 00 00	 call	 _va
  00c4d	83 c4 08	 add	 esp, 8
  00c50	50		 push	 eax
  00c51	6a 00		 push	 0
  00c53	8b 55 e8	 mov	 edx, DWORD PTR _y$17[ebp]
  00c56	52		 push	 edx
  00c57	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00c5a	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00c5f	50		 push	 eax
  00c60	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  00c65	83 c4 10	 add	 esp, 16			; 00000010H
  00c68	e9 40 01 00 00	 jmp	 $LN71@Y_Intermis
$LN69@Y_Intermis:

; 375  : 					else if (inttype == int_race)

  00c6d	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _inttype, 6
  00c74	0f 85 33 01 00
	00		 jne	 $LN71@Y_Intermis

; 376  : 					{
; 377  : 						if (players[data.match.num[i]].pflags & PF_TIMEOVER)

  00c7a	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00c7d	69 0c 85 00 02
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+512], 508
  00c88	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR _players[ecx+172]
  00c8e	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00c94	74 36		 je	 SHORT $LN72@Y_Intermis

; 378  : 						{
; 379  : 							if (data.match.numplayers > 9)

  00c96	83 3d 0c 03 00
	00 09		 cmp	 DWORD PTR _data+780, 9
  00c9d	7e 15		 jle	 SHORT $LN74@Y_Intermis

; 380  : 								_snprintf(strtime, sizeof strtime, "TIME O.");

  00c9f	68 00 00 00 00	 push	 OFFSET ??_C@_07GJAEEPGE@TIME?5O?4@
  00ca4	6a 0a		 push	 10			; 0000000aH
  00ca6	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00ca9	50		 push	 eax
  00caa	e8 00 00 00 00	 call	 __snprintf
  00caf	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cb2	eb 13		 jmp	 SHORT $LN75@Y_Intermis
$LN74@Y_Intermis:

; 381  : 							else
; 382  : 								_snprintf(strtime, sizeof strtime, "TIME OVER");

  00cb4	68 00 00 00 00	 push	 OFFSET ??_C@_09LHKFGDCI@TIME?5OVER@
  00cb9	6a 0a		 push	 10			; 0000000aH
  00cbb	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00cbe	50		 push	 eax
  00cbf	e8 00 00 00 00	 call	 __snprintf
  00cc4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN75@Y_Intermis:

; 383  : 						}

  00cc7	e9 9b 00 00 00	 jmp	 $LN77@Y_Intermis
$LN72@Y_Intermis:

; 384  : 						else if (players[data.match.num[i]].lives <= 0)

  00ccc	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00ccf	69 0c 85 00 02
	00 00 fc 01 00
	00		 imul	 ecx, DWORD PTR _data[eax*4+512], 508
  00cda	83 b9 00 01 00
	00 00		 cmp	 DWORD PTR _players[ecx+256], 0
  00ce1	7f 33		 jg	 SHORT $LN76@Y_Intermis

; 385  : 						{
; 386  : 							if (data.match.numplayers > 9)

  00ce3	83 3d 0c 03 00
	00 09		 cmp	 DWORD PTR _data+780, 9
  00cea	7e 15		 jle	 SHORT $LN78@Y_Intermis

; 387  : 								_snprintf(strtime, sizeof strtime, "GAME O.");

  00cec	68 00 00 00 00	 push	 OFFSET ??_C@_07KINPDHML@GAME?5O?4@
  00cf1	6a 0a		 push	 10			; 0000000aH
  00cf3	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00cf6	50		 push	 eax
  00cf7	e8 00 00 00 00	 call	 __snprintf
  00cfc	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cff	eb 13		 jmp	 SHORT $LN79@Y_Intermis
$LN78@Y_Intermis:

; 388  : 							else
; 389  : 								_snprintf(strtime, sizeof strtime, "GAME OVER");

  00d01	68 00 00 00 00	 push	 OFFSET ??_C@_09MAOEPLNL@GAME?5OVER@
  00d06	6a 0a		 push	 10			; 0000000aH
  00d08	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00d0b	50		 push	 eax
  00d0c	e8 00 00 00 00	 call	 __snprintf
  00d11	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN79@Y_Intermis:

; 390  : 						}

  00d14	eb 51		 jmp	 SHORT $LN77@Y_Intermis
$LN76@Y_Intermis:

; 391  : 						else
; 392  : 							_snprintf(strtime, sizeof strtime, "%i:%02i.%02i", G_TicsToMinutes(data.match.scores[i], true),

  00d16	8b 45 f4	 mov	 eax, DWORD PTR _i$20[ebp]
  00d19	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4]
  00d20	51		 push	 ecx
  00d21	e8 00 00 00 00	 call	 _G_TicsToCentiseconds
  00d26	83 c4 04	 add	 esp, 4
  00d29	50		 push	 eax
  00d2a	8b 55 f4	 mov	 edx, DWORD PTR _i$20[ebp]
  00d2d	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _data[edx*4]
  00d34	50		 push	 eax
  00d35	e8 00 00 00 00	 call	 _G_TicsToSeconds
  00d3a	83 c4 04	 add	 esp, 4
  00d3d	50		 push	 eax
  00d3e	6a 01		 push	 1
  00d40	8b 4d f4	 mov	 ecx, DWORD PTR _i$20[ebp]
  00d43	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _data[ecx*4]
  00d4a	52		 push	 edx
  00d4b	e8 00 00 00 00	 call	 _G_TicsToMinutes
  00d50	83 c4 08	 add	 esp, 8
  00d53	50		 push	 eax
  00d54	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CIBLIMGJ@?$CFi?3?$CF02i?4?$CF02i@
  00d59	6a 0a		 push	 10			; 0000000aH
  00d5b	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00d5e	50		 push	 eax
  00d5f	e8 00 00 00 00	 call	 __snprintf
  00d64	83 c4 18	 add	 esp, 24			; 00000018H
$LN77@Y_Intermis:

; 393  : 									G_TicsToSeconds(data.match.scores[i]), G_TicsToCentiseconds(data.match.scores[i]));
; 394  : 
; 395  : 						strtime[sizeof strtime - 1] = '\0';

  00d67	b8 01 00 00 00	 mov	 eax, 1
  00d6c	6b c8 09	 imul	 ecx, eax, 9
  00d6f	89 8d 38 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00d75	83 bd 38 ff ff
	ff 0a		 cmp	 DWORD PTR $T3[ebp], 10	; 0000000aH
  00d7c	73 02		 jae	 SHORT $LN99@Y_Intermis
  00d7e	eb 06		 jmp	 SHORT $LN100@Y_Intermis
$LN99@Y_Intermis:
  00d80	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  00d85	90		 npad	 1
$LN100@Y_Intermis:
  00d86	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00d8c	c6 44 15 c4 00	 mov	 BYTE PTR _strtime$15[ebp+edx], 0

; 396  : 
; 397  : 						V_DrawRightAlignedString(x+152+BASEVIDWIDTH/2, y, 0, strtime);

  00d91	8d 45 c4	 lea	 eax, DWORD PTR _strtime$15[ebp]
  00d94	50		 push	 eax
  00d95	6a 00		 push	 0
  00d97	8b 4d e8	 mov	 ecx, DWORD PTR _y$17[ebp]
  00d9a	51		 push	 ecx
  00d9b	8b 55 ec	 mov	 edx, DWORD PTR _x$18[ebp]
  00d9e	81 c2 38 01 00
	00		 add	 edx, 312		; 00000138H
  00da4	52		 push	 edx
  00da5	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  00daa	83 c4 10	 add	 esp, 16			; 00000010H
$LN71@Y_Intermis:

; 398  : 					}
; 399  : 				}
; 400  : 			}
; 401  : 
; 402  : 			y += 16;

  00dad	8b 45 e8	 mov	 eax, DWORD PTR _y$17[ebp]
  00db0	83 c0 10	 add	 eax, 16			; 00000010H
  00db3	89 45 e8	 mov	 DWORD PTR _y$17[ebp], eax

; 403  : 
; 404  : 			if (y > 176)

  00db6	81 7d e8 b0 00
	00 00		 cmp	 DWORD PTR _y$17[ebp], 176 ; 000000b0H
  00dbd	7e 12		 jle	 SHORT $LN80@Y_Intermis

; 405  : 			{
; 406  : 				y = 48;

  00dbf	c7 45 e8 30 00
	00 00		 mov	 DWORD PTR _y$17[ebp], 48 ; 00000030H

; 407  : 				x += BASEVIDWIDTH/2;

  00dc6	8b 45 ec	 mov	 eax, DWORD PTR _x$18[ebp]
  00dc9	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00dce	89 45 ec	 mov	 DWORD PTR _x$18[ebp], eax
$LN80@Y_Intermis:

; 408  : 			}
; 409  : 		}

  00dd1	e9 df fb ff ff	 jmp	 $LN2@Y_Intermis
$LN3@Y_Intermis:

; 410  : 	}

  00dd6	e9 f8 07 00 00	 jmp	 $LN9@Y_Intermis
$LN48@Y_Intermis:

; 411  : 	else if (inttype == int_ctf || inttype == int_teammatch)

  00ddb	83 3d 00 00 00
	00 04		 cmp	 DWORD PTR _inttype, 4
  00de2	74 0d		 je	 SHORT $LN83@Y_Intermis
  00de4	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR _inttype, 3
  00deb	0f 85 9b 03 00
	00		 jne	 $LN81@Y_Intermis
$LN83@Y_Intermis:

; 412  : 	{
; 413  : 		INT32 i, x = 4, y = 0;

  00df1	c7 45 b8 04 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 4
  00df8	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _y$11[ebp], 0

; 414  : 		INT32 redplayers = 0, blueplayers = 0;

  00dff	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _redplayers$10[ebp], 0
  00e06	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _blueplayers$9[ebp], 0

; 415  : 		char name[MAXPLAYERNAME+1];
; 416  : 
; 417  : 		// Show the team flags and the team score at the top instead of "RESULTS"
; 418  : 		V_DrawSmallScaledPatch(128 - SHORT(data.match.blueflag->width)/4, 2, 0, data.match.blueflag);

  00e0d	a1 04 03 00 00	 mov	 eax, DWORD PTR _data+772
  00e12	50		 push	 eax
  00e13	6a 00		 push	 0
  00e15	6a 02		 push	 2
  00e17	8b 0d 04 03 00
	00		 mov	 ecx, DWORD PTR _data+772
  00e1d	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00e20	99		 cdq
  00e21	83 e2 03	 and	 edx, 3
  00e24	03 c2		 add	 eax, edx
  00e26	c1 f8 02	 sar	 eax, 2
  00e29	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00e2e	2b d0		 sub	 edx, eax
  00e30	52		 push	 edx
  00e31	e8 00 00 00 00	 call	 _V_DrawSmallScaledPatch
  00e36	83 c4 10	 add	 esp, 16			; 00000010H

; 419  : 		V_DrawCenteredString(128, 16, 0, va("%u", bluescore));

  00e39	a1 00 00 00 00	 mov	 eax, DWORD PTR _bluescore
  00e3e	50		 push	 eax
  00e3f	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00e44	e8 00 00 00 00	 call	 _va
  00e49	83 c4 08	 add	 esp, 8
  00e4c	50		 push	 eax
  00e4d	6a 00		 push	 0
  00e4f	6a 10		 push	 16			; 00000010H
  00e51	68 80 00 00 00	 push	 128			; 00000080H
  00e56	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00e5b	83 c4 10	 add	 esp, 16			; 00000010H

; 420  : 
; 421  : 		V_DrawSmallScaledPatch(192 - SHORT(data.match.redflag->width)/4, 2, 0, data.match.redflag);

  00e5e	a1 08 03 00 00	 mov	 eax, DWORD PTR _data+776
  00e63	50		 push	 eax
  00e64	6a 00		 push	 0
  00e66	6a 02		 push	 2
  00e68	8b 0d 08 03 00
	00		 mov	 ecx, DWORD PTR _data+776
  00e6e	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00e71	99		 cdq
  00e72	83 e2 03	 and	 edx, 3
  00e75	03 c2		 add	 eax, edx
  00e77	c1 f8 02	 sar	 eax, 2
  00e7a	ba c0 00 00 00	 mov	 edx, 192		; 000000c0H
  00e7f	2b d0		 sub	 edx, eax
  00e81	52		 push	 edx
  00e82	e8 00 00 00 00	 call	 _V_DrawSmallScaledPatch
  00e87	83 c4 10	 add	 esp, 16			; 00000010H

; 422  : 		V_DrawCenteredString(192, 16, 0, va("%u", redscore));

  00e8a	a1 00 00 00 00	 mov	 eax, DWORD PTR _redscore
  00e8f	50		 push	 eax
  00e90	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  00e95	e8 00 00 00 00	 call	 _va
  00e9a	83 c4 08	 add	 esp, 8
  00e9d	50		 push	 eax
  00e9e	6a 00		 push	 0
  00ea0	6a 10		 push	 16			; 00000010H
  00ea2	68 c0 00 00 00	 push	 192			; 000000c0H
  00ea7	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00eac	83 c4 10	 add	 esp, 16			; 00000010H

; 423  : 
; 424  : 		// draw the level name
; 425  : 		V_DrawCenteredString(BASEVIDWIDTH/2, 24, 0, data.match.levelstring);

  00eaf	68 10 03 00 00	 push	 OFFSET _data+784
  00eb4	6a 00		 push	 0
  00eb6	6a 18		 push	 24			; 00000018H
  00eb8	68 a0 00 00 00	 push	 160			; 000000a0H
  00ebd	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00ec2	83 c4 10	 add	 esp, 16			; 00000010H

; 426  : 		V_DrawFill(4, 42, 312, 1, 0);

  00ec5	6a 00		 push	 0
  00ec7	6a 01		 push	 1
  00ec9	68 38 01 00 00	 push	 312			; 00000138H
  00ece	6a 2a		 push	 42			; 0000002aH
  00ed0	6a 04		 push	 4
  00ed2	e8 00 00 00 00	 call	 _V_DrawFill
  00ed7	83 c4 14	 add	 esp, 20			; 00000014H

; 427  : 
; 428  : 		//vert. line
; 429  : 		V_DrawFill(160, 32, 1, 152, 0);

  00eda	6a 00		 push	 0
  00edc	68 98 00 00 00	 push	 152			; 00000098H
  00ee1	6a 01		 push	 1
  00ee3	6a 20		 push	 32			; 00000020H
  00ee5	68 a0 00 00 00	 push	 160			; 000000a0H
  00eea	e8 00 00 00 00	 call	 _V_DrawFill
  00eef	83 c4 14	 add	 esp, 20			; 00000014H

; 430  : 
; 431  : 		//strings at the top of the list
; 432  : 		V_DrawCenteredString(x+6, 32, V_YELLOWMAP, "#");

  00ef2	68 00 00 00 00	 push	 OFFSET ??_C@_01IPJKGB@?$CD@
  00ef7	68 00 00 10 00	 push	 1048576			; 00100000H
  00efc	6a 20		 push	 32			; 00000020H
  00efe	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  00f01	83 c0 06	 add	 eax, 6
  00f04	50		 push	 eax
  00f05	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00f0a	83 c4 10	 add	 esp, 16			; 00000010H

; 433  : 		V_DrawCenteredString(x+(BASEVIDWIDTH/2)+6, 32, V_YELLOWMAP, "#");

  00f0d	68 00 00 00 00	 push	 OFFSET ??_C@_01IPJKGB@?$CD@
  00f12	68 00 00 10 00	 push	 1048576			; 00100000H
  00f17	6a 20		 push	 32			; 00000020H
  00f19	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  00f1c	05 a6 00 00 00	 add	 eax, 166		; 000000a6H
  00f21	50		 push	 eax
  00f22	e8 00 00 00 00	 call	 _V_DrawCenteredString
  00f27	83 c4 10	 add	 esp, 16			; 00000010H

; 434  : 
; 435  : 		V_DrawString(x+36, 32, V_YELLOWMAP, "NAME");

  00f2a	68 00 00 00 00	 push	 OFFSET ??_C@_04IPKHEEB@NAME@
  00f2f	68 00 00 10 00	 push	 1048576			; 00100000H
  00f34	6a 20		 push	 32			; 00000020H
  00f36	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  00f39	83 c0 24	 add	 eax, 36			; 00000024H
  00f3c	50		 push	 eax
  00f3d	e8 00 00 00 00	 call	 _V_DrawString
  00f42	83 c4 10	 add	 esp, 16			; 00000010H

; 436  : 		V_DrawString(x+(BASEVIDWIDTH/2)+36, 32, V_YELLOWMAP, "NAME");

  00f45	68 00 00 00 00	 push	 OFFSET ??_C@_04IPKHEEB@NAME@
  00f4a	68 00 00 10 00	 push	 1048576			; 00100000H
  00f4f	6a 20		 push	 32			; 00000020H
  00f51	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  00f54	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00f59	50		 push	 eax
  00f5a	e8 00 00 00 00	 call	 _V_DrawString
  00f5f	83 c4 10	 add	 esp, 16			; 00000010H

; 437  : 
; 438  : 		V_DrawRightAlignedString(x+152, 32, V_YELLOWMAP, "SCORE");

  00f62	68 00 00 00 00	 push	 OFFSET ??_C@_05PKDFAPGJ@SCORE@
  00f67	68 00 00 10 00	 push	 1048576			; 00100000H
  00f6c	6a 20		 push	 32			; 00000020H
  00f6e	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  00f71	05 98 00 00 00	 add	 eax, 152		; 00000098H
  00f76	50		 push	 eax
  00f77	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  00f7c	83 c4 10	 add	 esp, 16			; 00000010H

; 439  : 		V_DrawRightAlignedString(x+(BASEVIDWIDTH/2)+152, 32, V_YELLOWMAP, "SCORE");

  00f7f	68 00 00 00 00	 push	 OFFSET ??_C@_05PKDFAPGJ@SCORE@
  00f84	68 00 00 10 00	 push	 1048576			; 00100000H
  00f89	6a 20		 push	 32			; 00000020H
  00f8b	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  00f8e	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00f93	50		 push	 eax
  00f94	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  00f99	83 c4 10	 add	 esp, 16			; 00000010H

; 440  : 
; 441  : 		for (i = 0; i < data.match.numplayers; i++)

  00f9c	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$13[ebp], 0
  00fa3	eb 09		 jmp	 SHORT $LN7@Y_Intermis
$LN5@Y_Intermis:
  00fa5	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  00fa8	83 c0 01	 add	 eax, 1
  00fab	89 45 bc	 mov	 DWORD PTR _i$13[ebp], eax
$LN7@Y_Intermis:
  00fae	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  00fb1	3b 05 0c 03 00
	00		 cmp	 eax, DWORD PTR _data+780
  00fb7	0f 8d ca 01 00
	00		 jge	 $LN6@Y_Intermis

; 442  : 		{
; 443  : 			if (playeringame[data.match.num[i]] && !(data.match.spectator[i]))

  00fbd	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  00fc0	8b 0c 85 00 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+512]
  00fc7	83 3c 8d 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[ecx*4], 0
  00fcf	0f 84 ad 01 00
	00		 je	 $LN84@Y_Intermis
  00fd5	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  00fd8	83 3c 85 00 01
	00 00 00	 cmp	 DWORD PTR _data[eax*4+256], 0
  00fe0	0f 85 9c 01 00
	00		 jne	 $LN84@Y_Intermis

; 444  : 			{
; 445  : 				UINT8 *colormap = (UINT8 *) translationtables[*data.match.character[i]] - 256 + (*data.match.color[i]<<8);

  00fe6	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  00fe9	8b 0c 85 80 01
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+384]
  00ff0	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ff2	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _translationtables[edx*4]
  00ff9	8b 4d bc	 mov	 ecx, DWORD PTR _i$13[ebp]
  00ffc	8b 14 8d 80 00
	00 00		 mov	 edx, DWORD PTR _data[ecx*4+128]
  01003	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01005	c1 e1 08	 shl	 ecx, 8
  01008	8d 94 08 00 ff
	ff ff		 lea	 edx, DWORD PTR [eax+ecx-256]
  0100f	89 55 90	 mov	 DWORD PTR _colormap$7[ebp], edx

; 446  : 
; 447  : 				if (*data.match.color[i] == 6) //red

  01012	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  01015	8b 0c 85 80 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+128]
  0101c	83 39 06	 cmp	 DWORD PTR [ecx], 6
  0101f	75 5c		 jne	 SHORT $LN85@Y_Intermis

; 448  : 				{
; 449  : 					if (redplayers++ > 9)

  01021	8b 45 b0	 mov	 eax, DWORD PTR _redplayers$10[ebp]
  01024	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv934[ebp], eax
  0102a	8b 4d b0	 mov	 ecx, DWORD PTR _redplayers$10[ebp]
  0102d	83 c1 01	 add	 ecx, 1
  01030	89 4d b0	 mov	 DWORD PTR _redplayers$10[ebp], ecx
  01033	83 bd 2c ff ff
	ff 09		 cmp	 DWORD PTR tv934[ebp], 9
  0103a	7e 05		 jle	 SHORT $LN87@Y_Intermis

; 450  : 						continue;

  0103c	e9 64 ff ff ff	 jmp	 $LN5@Y_Intermis
$LN87@Y_Intermis:

; 451  : 					x = 4 + (BASEVIDWIDTH/2);

  01041	c7 45 b8 a4 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 164 ; 000000a4H

; 452  : 					y = (redplayers * 16) + 32;

  01048	8b 45 b0	 mov	 eax, DWORD PTR _redplayers$10[ebp]
  0104b	c1 e0 04	 shl	 eax, 4
  0104e	83 c0 20	 add	 eax, 32			; 00000020H
  01051	89 45 b4	 mov	 DWORD PTR _y$11[ebp], eax

; 453  : 					V_DrawCenteredString(x+6, y, 0, va("%d", redplayers));

  01054	8b 45 b0	 mov	 eax, DWORD PTR _redplayers$10[ebp]
  01057	50		 push	 eax
  01058	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0105d	e8 00 00 00 00	 call	 _va
  01062	83 c4 08	 add	 esp, 8
  01065	50		 push	 eax
  01066	6a 00		 push	 0
  01068	8b 4d b4	 mov	 ecx, DWORD PTR _y$11[ebp]
  0106b	51		 push	 ecx
  0106c	8b 55 b8	 mov	 edx, DWORD PTR _x$12[ebp]
  0106f	83 c2 06	 add	 edx, 6
  01072	52		 push	 edx
  01073	e8 00 00 00 00	 call	 _V_DrawCenteredString
  01078	83 c4 10	 add	 esp, 16			; 00000010H

; 454  : 				}

  0107b	eb 70		 jmp	 SHORT $LN89@Y_Intermis
$LN85@Y_Intermis:

; 455  : 				else if (*data.match.color[i] == 7) //blue

  0107d	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  01080	8b 0c 85 80 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+128]
  01087	83 39 07	 cmp	 DWORD PTR [ecx], 7
  0108a	75 5c		 jne	 SHORT $LN88@Y_Intermis

; 456  : 				{
; 457  : 					if (blueplayers++ > 9)

  0108c	8b 45 ac	 mov	 eax, DWORD PTR _blueplayers$9[ebp]
  0108f	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv951[ebp], eax
  01095	8b 4d ac	 mov	 ecx, DWORD PTR _blueplayers$9[ebp]
  01098	83 c1 01	 add	 ecx, 1
  0109b	89 4d ac	 mov	 DWORD PTR _blueplayers$9[ebp], ecx
  0109e	83 bd 2c ff ff
	ff 09		 cmp	 DWORD PTR tv951[ebp], 9
  010a5	7e 05		 jle	 SHORT $LN90@Y_Intermis

; 458  : 						continue;

  010a7	e9 f9 fe ff ff	 jmp	 $LN5@Y_Intermis
$LN90@Y_Intermis:

; 459  : 					x = 4;

  010ac	c7 45 b8 04 00
	00 00		 mov	 DWORD PTR _x$12[ebp], 4

; 460  : 					y = (blueplayers * 16) + 32;

  010b3	8b 45 ac	 mov	 eax, DWORD PTR _blueplayers$9[ebp]
  010b6	c1 e0 04	 shl	 eax, 4
  010b9	83 c0 20	 add	 eax, 32			; 00000020H
  010bc	89 45 b4	 mov	 DWORD PTR _y$11[ebp], eax

; 461  : 					V_DrawCenteredString(x+6, y, 0, va("%d", blueplayers));

  010bf	8b 45 ac	 mov	 eax, DWORD PTR _blueplayers$9[ebp]
  010c2	50		 push	 eax
  010c3	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  010c8	e8 00 00 00 00	 call	 _va
  010cd	83 c4 08	 add	 esp, 8
  010d0	50		 push	 eax
  010d1	6a 00		 push	 0
  010d3	8b 4d b4	 mov	 ecx, DWORD PTR _y$11[ebp]
  010d6	51		 push	 ecx
  010d7	8b 55 b8	 mov	 edx, DWORD PTR _x$12[ebp]
  010da	83 c2 06	 add	 edx, 6
  010dd	52		 push	 edx
  010de	e8 00 00 00 00	 call	 _V_DrawCenteredString
  010e3	83 c4 10	 add	 esp, 16			; 00000010H

; 462  : 				}

  010e6	eb 05		 jmp	 SHORT $LN89@Y_Intermis
$LN88@Y_Intermis:

; 463  : 				else
; 464  : 					continue;

  010e8	e9 b8 fe ff ff	 jmp	 $LN5@Y_Intermis
$LN89@Y_Intermis:

; 465  : 
; 466  : 				//color is ALWAYS going to be 6/7 here, no need to check if it's nonzero.
; 467  : 				V_DrawSmallMappedPatch(x+16, y-4, 0,faceprefix[*data.match.character[i]], colormap);

  010ed	8b 45 90	 mov	 eax, DWORD PTR _colormap$7[ebp]
  010f0	50		 push	 eax
  010f1	8b 4d bc	 mov	 ecx, DWORD PTR _i$13[ebp]
  010f4	8b 14 8d 80 01
	00 00		 mov	 edx, DWORD PTR _data[ecx*4+384]
  010fb	8b 02		 mov	 eax, DWORD PTR [edx]
  010fd	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _faceprefix[eax*4]
  01104	51		 push	 ecx
  01105	6a 00		 push	 0
  01107	8b 55 b4	 mov	 edx, DWORD PTR _y$11[ebp]
  0110a	83 ea 04	 sub	 edx, 4
  0110d	52		 push	 edx
  0110e	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  01111	83 c0 10	 add	 eax, 16			; 00000010H
  01114	50		 push	 eax
  01115	e8 00 00 00 00	 call	 _V_DrawSmallMappedPatch
  0111a	83 c4 14	 add	 esp, 20			; 00000014H

; 468  : 
; 469  : 				strlcpy(name, data.match.name[i], 9);

  0111d	6a 09		 push	 9
  0111f	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  01122	8b 0c 85 80 02
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+640]
  01129	51		 push	 ecx
  0112a	8d 55 94	 lea	 edx, DWORD PTR _name$8[ebp]
  0112d	52		 push	 edx
  0112e	e8 00 00 00 00	 call	 _strlcpy
  01133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 470  : 
; 471  : 				V_DrawString(x+36, y, V_ALLOWLOWERCASE, name);

  01136	8d 45 94	 lea	 eax, DWORD PTR _name$8[ebp]
  01139	50		 push	 eax
  0113a	68 00 00 04 00	 push	 262144			; 00040000H
  0113f	8b 4d b4	 mov	 ecx, DWORD PTR _y$11[ebp]
  01142	51		 push	 ecx
  01143	8b 55 b8	 mov	 edx, DWORD PTR _x$12[ebp]
  01146	83 c2 24	 add	 edx, 36			; 00000024H
  01149	52		 push	 edx
  0114a	e8 00 00 00 00	 call	 _V_DrawString
  0114f	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 
; 473  : 				V_DrawRightAlignedString(x+152, y, 0, va("%u", data.match.scores[i]));

  01152	8b 45 bc	 mov	 eax, DWORD PTR _i$13[ebp]
  01155	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4]
  0115c	51		 push	 ecx
  0115d	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu@
  01162	e8 00 00 00 00	 call	 _va
  01167	83 c4 08	 add	 esp, 8
  0116a	50		 push	 eax
  0116b	6a 00		 push	 0
  0116d	8b 55 b4	 mov	 edx, DWORD PTR _y$11[ebp]
  01170	52		 push	 edx
  01171	8b 45 b8	 mov	 eax, DWORD PTR _x$12[ebp]
  01174	05 98 00 00 00	 add	 eax, 152		; 00000098H
  01179	50		 push	 eax
  0117a	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  0117f	83 c4 10	 add	 esp, 16			; 00000010H
$LN84@Y_Intermis:

; 474  : 			}
; 475  : 		}

  01182	e9 1e fe ff ff	 jmp	 $LN5@Y_Intermis
$LN6@Y_Intermis:

; 476  : 	}

  01187	e9 47 04 00 00	 jmp	 $LN9@Y_Intermis
$LN81@Y_Intermis:

; 477  : 	else if (inttype == int_classicrace)

  0118c	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _inttype, 7
  01193	0f 85 3a 04 00
	00		 jne	 $LN9@Y_Intermis

; 478  : 	{
; 479  : 		char name[9] = "xxxxxxxx";

  01199	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_08MPODPIDC@xxxxxxxx@
  0119e	89 45 84	 mov	 DWORD PTR _name$6[ebp], eax
  011a1	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_08MPODPIDC@xxxxxxxx@+4
  011a7	89 4d 88	 mov	 DWORD PTR _name$6[ebp+4], ecx
  011aa	8a 15 08 00 00
	00		 mov	 dl, BYTE PTR ??_C@_08MPODPIDC@xxxxxxxx@+8
  011b0	88 55 8c	 mov	 BYTE PTR _name$6[ebp+8], dl

; 480  : 		INT32 i;
; 481  : 
; 482  : 		// draw the header
; 483  : 		V_DrawScaledPatch(112, 8, 0, data.race.result);

  011b3	a1 ac 00 00 00	 mov	 eax, DWORD PTR _data+172
  011b8	50		 push	 eax
  011b9	6a 00		 push	 0
  011bb	6a 08		 push	 8
  011bd	6a 70		 push	 112			; 00000070H
  011bf	e8 00 00 00 00	 call	 _V_DrawScaledPatch
  011c4	83 c4 10	 add	 esp, 16			; 00000010H

; 484  : 
; 485  : 		// draw the level name
; 486  : 		V_DrawCenteredString(BASEVIDWIDTH/2, 28, 0, data.race.levelstring);

  011c7	68 b0 00 00 00	 push	 OFFSET _data+176
  011cc	6a 00		 push	 0
  011ce	6a 1c		 push	 28			; 0000001cH
  011d0	68 a0 00 00 00	 push	 160			; 000000a0H
  011d5	e8 00 00 00 00	 call	 _V_DrawCenteredString
  011da	83 c4 10	 add	 esp, 16			; 00000010H

; 487  : 
; 488  : 		// draw the category names
; 489  : 		V_DrawString(8, 66, 0, "SCORE");

  011dd	68 00 00 00 00	 push	 OFFSET ??_C@_05PKDFAPGJ@SCORE@
  011e2	6a 00		 push	 0
  011e4	6a 42		 push	 66			; 00000042H
  011e6	6a 08		 push	 8
  011e8	e8 00 00 00 00	 call	 _V_DrawString
  011ed	83 c4 10	 add	 esp, 16			; 00000010H

; 490  : 		V_DrawString(8, 78, 0, "TIME");

  011f0	68 00 00 00 00	 push	 OFFSET ??_C@_04OHBONDIN@TIME@
  011f5	6a 00		 push	 0
  011f7	6a 4e		 push	 78			; 0000004eH
  011f9	6a 08		 push	 8
  011fb	e8 00 00 00 00	 call	 _V_DrawString
  01200	83 c4 10	 add	 esp, 16			; 00000010H

; 491  : 		V_DrawString(8, 90, 0, "RING");

  01203	68 00 00 00 00	 push	 OFFSET ??_C@_04FICOPKPG@RING@
  01208	6a 00		 push	 0
  0120a	6a 5a		 push	 90			; 0000005aH
  0120c	6a 08		 push	 8
  0120e	e8 00 00 00 00	 call	 _V_DrawString
  01213	83 c4 10	 add	 esp, 16			; 00000010H

; 492  : 		V_DrawString(8, 102, 0, "TOT. RING");

  01216	68 00 00 00 00	 push	 OFFSET ??_C@_09IFBADFLC@TOT?4?5RING@
  0121b	6a 00		 push	 0
  0121d	6a 66		 push	 102			; 00000066H
  0121f	6a 08		 push	 8
  01221	e8 00 00 00 00	 call	 _V_DrawString
  01226	83 c4 10	 add	 esp, 16			; 00000010H

; 493  : 		V_DrawString(8, 114, 0, "ITEM BOX");

  01229	68 00 00 00 00	 push	 OFFSET ??_C@_08OGCGECEO@ITEM?5BOX@
  0122e	6a 00		 push	 0
  01230	6a 72		 push	 114			; 00000072H
  01232	6a 08		 push	 8
  01234	e8 00 00 00 00	 call	 _V_DrawString
  01239	83 c4 10	 add	 esp, 16			; 00000010H

; 494  : 		V_DrawString(0, 138, 0, "* TOTAL *");

  0123c	68 00 00 00 00	 push	 OFFSET ??_C@_09NBLMCIMK@?$CK?5TOTAL?5?$CK@
  01241	6a 00		 push	 0
  01243	68 8a 00 00 00	 push	 138			; 0000008aH
  01248	6a 00		 push	 0
  0124a	e8 00 00 00 00	 call	 _V_DrawString
  0124f	83 c4 10	 add	 esp, 16			; 00000010H

; 495  : 
; 496  : 		// draw the W
; 497  : 		V_DrawCharacter(304, 50, 'W', false);

  01252	6a 00		 push	 0
  01254	6a 57		 push	 87			; 00000057H
  01256	6a 32		 push	 50			; 00000032H
  01258	68 30 01 00 00	 push	 304			; 00000130H
  0125d	e8 00 00 00 00	 call	 _V_DrawCharacter
  01262	83 c4 10	 add	 esp, 16			; 00000010H

; 498  : 
; 499  : 		// draw the winner in each category
; 500  : 		V_DrawCenteredString(308, 66, V_YELLOWMAP, data.race.winnerstrings[0]);

  01265	b8 04 00 00 00	 mov	 eax, 4
  0126a	6b c8 00	 imul	 ecx, eax, 0
  0126d	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR _data[ecx+148]
  01273	52		 push	 edx
  01274	68 00 00 10 00	 push	 1048576			; 00100000H
  01279	6a 42		 push	 66			; 00000042H
  0127b	68 34 01 00 00	 push	 308			; 00000134H
  01280	e8 00 00 00 00	 call	 _V_DrawCenteredString
  01285	83 c4 10	 add	 esp, 16			; 00000010H

; 501  : 		V_DrawCenteredString(308, 78, V_YELLOWMAP, data.race.winnerstrings[1]);

  01288	b8 04 00 00 00	 mov	 eax, 4
  0128d	c1 e0 00	 shl	 eax, 0
  01290	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _data[eax+148]
  01296	51		 push	 ecx
  01297	68 00 00 10 00	 push	 1048576			; 00100000H
  0129c	6a 4e		 push	 78			; 0000004eH
  0129e	68 34 01 00 00	 push	 308			; 00000134H
  012a3	e8 00 00 00 00	 call	 _V_DrawCenteredString
  012a8	83 c4 10	 add	 esp, 16			; 00000010H

; 502  : 		V_DrawCenteredString(308, 90, V_YELLOWMAP, data.race.winnerstrings[2]);

  012ab	b8 04 00 00 00	 mov	 eax, 4
  012b0	d1 e0		 shl	 eax, 1
  012b2	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _data[eax+148]
  012b8	51		 push	 ecx
  012b9	68 00 00 10 00	 push	 1048576			; 00100000H
  012be	6a 5a		 push	 90			; 0000005aH
  012c0	68 34 01 00 00	 push	 308			; 00000134H
  012c5	e8 00 00 00 00	 call	 _V_DrawCenteredString
  012ca	83 c4 10	 add	 esp, 16			; 00000010H

; 503  : 		V_DrawCenteredString(308, 102, V_YELLOWMAP, data.race.winnerstrings[3]);

  012cd	b8 04 00 00 00	 mov	 eax, 4
  012d2	6b c8 03	 imul	 ecx, eax, 3
  012d5	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR _data[ecx+148]
  012db	52		 push	 edx
  012dc	68 00 00 10 00	 push	 1048576			; 00100000H
  012e1	6a 66		 push	 102			; 00000066H
  012e3	68 34 01 00 00	 push	 308			; 00000134H
  012e8	e8 00 00 00 00	 call	 _V_DrawCenteredString
  012ed	83 c4 10	 add	 esp, 16			; 00000010H

; 504  : 		V_DrawCenteredString(308, 114, V_YELLOWMAP, data.race.winnerstrings[4]);

  012f0	b8 04 00 00 00	 mov	 eax, 4
  012f5	c1 e0 02	 shl	 eax, 2
  012f8	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR _data[eax+148]
  012fe	51		 push	 ecx
  012ff	68 00 00 10 00	 push	 1048576			; 00100000H
  01304	6a 72		 push	 114			; 00000072H
  01306	68 34 01 00 00	 push	 308			; 00000134H
  0130b	e8 00 00 00 00	 call	 _V_DrawCenteredString
  01310	83 c4 10	 add	 esp, 16			; 00000010H

; 505  : 
; 506  : 		// draw the overall winner
; 507  : 		if (data.race.winner == -1)

  01313	83 3d a8 00 00
	00 ff		 cmp	 DWORD PTR _data+168, -1
  0131a	75 1e		 jne	 SHORT $LN92@Y_Intermis

; 508  : 			V_DrawCenteredString(BASEVIDWIDTH/2, 163, V_YELLOWMAP, "TIED");

  0131c	68 00 00 00 00	 push	 OFFSET ??_C@_04PABGLDHE@TIED@
  01321	68 00 00 10 00	 push	 1048576			; 00100000H
  01326	68 a3 00 00 00	 push	 163			; 000000a3H
  0132b	68 a0 00 00 00	 push	 160			; 000000a0H
  01330	e8 00 00 00 00	 call	 _V_DrawCenteredString
  01335	83 c4 10	 add	 esp, 16			; 00000010H
  01338	eb 40		 jmp	 SHORT $LN93@Y_Intermis
$LN92@Y_Intermis:

; 509  : 		else
; 510  : 		{
; 511  : 			V_DrawCenteredString(BASEVIDWIDTH/2, 159, V_YELLOWMAP|V_ALLOWLOWERCASE,

  0133a	6b 05 a8 00 00
	00 16		 imul	 eax, DWORD PTR _data+168, 22
  01341	05 00 00 00 00	 add	 eax, OFFSET _player_names
  01346	50		 push	 eax
  01347	68 00 00 14 00	 push	 1310720			; 00140000H
  0134c	68 9f 00 00 00	 push	 159			; 0000009fH
  01351	68 a0 00 00 00	 push	 160			; 000000a0H
  01356	e8 00 00 00 00	 call	 _V_DrawCenteredString
  0135b	83 c4 10	 add	 esp, 16			; 00000010H

; 512  : 				player_names[data.race.winner]);
; 513  : 			V_DrawCenteredString(BASEVIDWIDTH/2, 167, V_YELLOWMAP, "WINS");

  0135e	68 00 00 00 00	 push	 OFFSET ??_C@_04LOGAKCND@WINS@
  01363	68 00 00 10 00	 push	 1048576			; 00100000H
  01368	68 a7 00 00 00	 push	 167			; 000000a7H
  0136d	68 a0 00 00 00	 push	 160			; 000000a0H
  01372	e8 00 00 00 00	 call	 _V_DrawCenteredString
  01377	83 c4 10	 add	 esp, 16			; 00000010H
$LN93@Y_Intermis:

; 514  : 		}
; 515  : 
; 516  : 		for (i = 0; i < data.race.numplayersshown; i++)

  0137a	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  01381	eb 09		 jmp	 SHORT $LN10@Y_Intermis
$LN8@Y_Intermis:
  01383	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  01386	83 c0 01	 add	 eax, 1
  01389	89 45 80	 mov	 DWORD PTR _i$5[ebp], eax
$LN10@Y_Intermis:
  0138c	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  0138f	3b 05 80 00 00
	00		 cmp	 eax, DWORD PTR _data+128
  01395	0f 8d 38 02 00
	00		 jge	 $LN9@Y_Intermis

; 517  : 		{
; 518  : 			// draw the player's name (max 8 chars)
; 519  : 			strlcpy(name, player_names[data.race.playersshown[i]], 9);

  0139b	6a 09		 push	 9
  0139d	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  013a0	6b 0c 85 84 00
	00 00 16	 imul	 ecx, DWORD PTR _data[eax*4+132], 22
  013a8	81 c1 00 00 00
	00		 add	 ecx, OFFSET _player_names
  013ae	51		 push	 ecx
  013af	8d 55 84	 lea	 edx, DWORD PTR _name$6[ebp]
  013b2	52		 push	 edx
  013b3	e8 00 00 00 00	 call	 _strlcpy
  013b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 520  : 			V_DrawRightAlignedString(104 + 64*i, 46, V_ALLOWLOWERCASE, name);

  013bb	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  013be	50		 push	 eax
  013bf	68 00 00 04 00	 push	 262144			; 00040000H
  013c4	6a 2e		 push	 46			; 0000002eH
  013c6	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  013c9	c1 e1 06	 shl	 ecx, 6
  013cc	83 c1 68	 add	 ecx, 104		; 00000068H
  013cf	51		 push	 ecx
  013d0	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  013d5	83 c4 10	 add	 esp, 16			; 00000010H

; 521  : 
; 522  : 			// draw 1P/2P/3P/4P
; 523  : 			name[2] = '\0';

  013d8	b8 01 00 00 00	 mov	 eax, 1
  013dd	d1 e0		 shl	 eax, 1
  013df	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  013e5	83 bd 34 ff ff
	ff 09		 cmp	 DWORD PTR $T2[ebp], 9
  013ec	73 02		 jae	 SHORT $LN101@Y_Intermis
  013ee	eb 06		 jmp	 SHORT $LN102@Y_Intermis
$LN101@Y_Intermis:
  013f0	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  013f5	90		 npad	 1
$LN102@Y_Intermis:
  013f6	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  013fc	c6 44 0d 84 00	 mov	 BYTE PTR _name$6[ebp+ecx], 0

; 524  : 			name[1] = 'P';

  01401	b8 01 00 00 00	 mov	 eax, 1
  01406	c1 e0 00	 shl	 eax, 0
  01409	c6 44 05 84 50	 mov	 BYTE PTR _name$6[ebp+eax], 80 ; 00000050H

; 525  : 			name[0] = (char)('1' + (char)i);

  0140e	0f be 45 80	 movsx	 eax, BYTE PTR _i$5[ebp]
  01412	83 c0 31	 add	 eax, 49			; 00000031H
  01415	b9 01 00 00 00	 mov	 ecx, 1
  0141a	6b d1 00	 imul	 edx, ecx, 0
  0141d	88 44 15 84	 mov	 BYTE PTR _name$6[ebp+edx], al

; 526  : 			V_DrawRightAlignedString(104 + 64*i, 54, 0, name);

  01421	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  01424	50		 push	 eax
  01425	6a 00		 push	 0
  01427	6a 36		 push	 54			; 00000036H
  01429	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  0142c	c1 e1 06	 shl	 ecx, 6
  0142f	83 c1 68	 add	 ecx, 104		; 00000068H
  01432	51		 push	 ecx
  01433	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  01438	83 c4 10	 add	 esp, 16			; 00000010H

; 527  : 
; 528  : 			name[sizeof name - 1] = '\0';

  0143b	b8 01 00 00 00	 mov	 eax, 1
  01440	c1 e0 03	 shl	 eax, 3
  01443	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  01449	83 bd 30 ff ff
	ff 09		 cmp	 DWORD PTR $T1[ebp], 9
  01450	73 02		 jae	 SHORT $LN103@Y_Intermis
  01452	eb 06		 jmp	 SHORT $LN104@Y_Intermis
$LN103@Y_Intermis:
  01454	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  01459	90		 npad	 1
$LN104@Y_Intermis:
  0145a	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  01460	c6 44 0d 84 00	 mov	 BYTE PTR _name$6[ebp+ecx], 0

; 529  : 
; 530  : 			// draw score
; 531  : 			_snprintf(name, sizeof name - 1, "%d", data.race.scores[i]);

  01465	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  01468	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4]
  0146f	51		 push	 ecx
  01470	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  01475	6a 08		 push	 8
  01477	8d 55 84	 lea	 edx, DWORD PTR _name$6[ebp]
  0147a	52		 push	 edx
  0147b	e8 00 00 00 00	 call	 __snprintf
  01480	83 c4 10	 add	 esp, 16			; 00000010H

; 532  : 			V_DrawRightAlignedString(104 + 64*i, 66, 0, name);

  01483	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  01486	50		 push	 eax
  01487	6a 00		 push	 0
  01489	6a 42		 push	 66			; 00000042H
  0148b	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  0148e	c1 e1 06	 shl	 ecx, 6
  01491	83 c1 68	 add	 ecx, 104		; 00000068H
  01494	51		 push	 ecx
  01495	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  0149a	83 c4 10	 add	 esp, 16			; 00000010H

; 533  : 
; 534  : 			// draw time
; 535  : 			_snprintf(name, sizeof name - 1, "%d:%02d.%02d",

  0149d	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  014a0	8b 0c 85 30 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+48]
  014a7	51		 push	 ecx
  014a8	8b 55 80	 mov	 edx, DWORD PTR _i$5[ebp]
  014ab	8b 04 95 20 00
	00 00		 mov	 eax, DWORD PTR _data[edx*4+32]
  014b2	50		 push	 eax
  014b3	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  014b6	8b 14 8d 10 00
	00 00		 mov	 edx, DWORD PTR _data[ecx*4+16]
  014bd	52		 push	 edx
  014be	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GCMNJCAK@?$CFd?3?$CF02d?4?$CF02d@
  014c3	6a 08		 push	 8
  014c5	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  014c8	50		 push	 eax
  014c9	e8 00 00 00 00	 call	 __snprintf
  014ce	83 c4 18	 add	 esp, 24			; 00000018H

; 536  : 				data.race.timemin[i], data.race.timesec[i],
; 537  : 				data.race.timetic[i]);
; 538  : 			V_DrawRightAlignedString(104 + 64*i, 78, 0, name);

  014d1	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  014d4	50		 push	 eax
  014d5	6a 00		 push	 0
  014d7	6a 4e		 push	 78			; 0000004eH
  014d9	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  014dc	c1 e1 06	 shl	 ecx, 6
  014df	83 c1 68	 add	 ecx, 104		; 00000068H
  014e2	51		 push	 ecx
  014e3	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  014e8	83 c4 10	 add	 esp, 16			; 00000010H

; 539  : 
; 540  : 			// draw ring count
; 541  : 			_snprintf(name, sizeof name - 1, "%d", data.race.rings[i]);

  014eb	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  014ee	8b 0c 85 40 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+64]
  014f5	51		 push	 ecx
  014f6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  014fb	6a 08		 push	 8
  014fd	8d 55 84	 lea	 edx, DWORD PTR _name$6[ebp]
  01500	52		 push	 edx
  01501	e8 00 00 00 00	 call	 __snprintf
  01506	83 c4 10	 add	 esp, 16			; 00000010H

; 542  : 			V_DrawRightAlignedString(104 + 64*i, 90, 0, name);

  01509	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  0150c	50		 push	 eax
  0150d	6a 00		 push	 0
  0150f	6a 5a		 push	 90			; 0000005aH
  01511	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  01514	c1 e1 06	 shl	 ecx, 6
  01517	83 c1 68	 add	 ecx, 104		; 00000068H
  0151a	51		 push	 ecx
  0151b	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  01520	83 c4 10	 add	 esp, 16			; 00000010H

; 543  : 
; 544  : 			// draw total ring count
; 545  : 			_snprintf(name, sizeof name - 1, "%d",

  01523	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  01526	8b 0c 85 50 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+80]
  0152d	51		 push	 ecx
  0152e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  01533	6a 08		 push	 8
  01535	8d 55 84	 lea	 edx, DWORD PTR _name$6[ebp]
  01538	52		 push	 edx
  01539	e8 00 00 00 00	 call	 __snprintf
  0153e	83 c4 10	 add	 esp, 16			; 00000010H

; 546  : 				data.race.totalrings[i]);
; 547  : 			V_DrawRightAlignedString(104 + 64*i, 102, 0, name);

  01541	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  01544	50		 push	 eax
  01545	6a 00		 push	 0
  01547	6a 66		 push	 102			; 00000066H
  01549	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  0154c	c1 e1 06	 shl	 ecx, 6
  0154f	83 c1 68	 add	 ecx, 104		; 00000068H
  01552	51		 push	 ecx
  01553	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  01558	83 c4 10	 add	 esp, 16			; 00000010H

; 548  : 
; 549  : 			// draw item box count
; 550  : 			_snprintf(name, sizeof name - 1, "%d",

  0155b	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  0155e	8b 0c 85 60 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+96]
  01565	51		 push	 ecx
  01566	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0156b	6a 08		 push	 8
  0156d	8d 55 84	 lea	 edx, DWORD PTR _name$6[ebp]
  01570	52		 push	 edx
  01571	e8 00 00 00 00	 call	 __snprintf
  01576	83 c4 10	 add	 esp, 16			; 00000010H

; 551  : 				data.race.itemboxes[i]);
; 552  : 			V_DrawRightAlignedString(104 + 64*i, 114, 0, name);

  01579	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  0157c	50		 push	 eax
  0157d	6a 00		 push	 0
  0157f	6a 72		 push	 114			; 00000072H
  01581	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  01584	c1 e1 06	 shl	 ecx, 6
  01587	83 c1 68	 add	 ecx, 104		; 00000068H
  0158a	51		 push	 ecx
  0158b	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  01590	83 c4 10	 add	 esp, 16			; 00000010H

; 553  : 
; 554  : 			// draw total number of wins
; 555  : 			_snprintf(name, sizeof name - 1, "%d",

  01593	8b 45 80	 mov	 eax, DWORD PTR _i$5[ebp]
  01596	8b 0c 85 70 00
	00 00		 mov	 ecx, DWORD PTR _data[eax*4+112]
  0159d	51		 push	 ecx
  0159e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  015a3	6a 08		 push	 8
  015a5	8d 55 84	 lea	 edx, DWORD PTR _name$6[ebp]
  015a8	52		 push	 edx
  015a9	e8 00 00 00 00	 call	 __snprintf
  015ae	83 c4 10	 add	 esp, 16			; 00000010H

; 556  : 				data.race.totalwins[i]);
; 557  : 			V_DrawRightAlignedString(104 + 64*i, 138, 0, name);

  015b1	8d 45 84	 lea	 eax, DWORD PTR _name$6[ebp]
  015b4	50		 push	 eax
  015b5	6a 00		 push	 0
  015b7	68 8a 00 00 00	 push	 138			; 0000008aH
  015bc	8b 4d 80	 mov	 ecx, DWORD PTR _i$5[ebp]
  015bf	c1 e1 06	 shl	 ecx, 6
  015c2	83 c1 68	 add	 ecx, 104		; 00000068H
  015c5	51		 push	 ecx
  015c6	e8 00 00 00 00	 call	 _V_DrawRightAlignedString
  015cb	83 c4 10	 add	 esp, 16			; 00000010H

; 558  : 		}

  015ce	e9 b0 fd ff ff	 jmp	 $LN8@Y_Intermis
$LN9@Y_Intermis:

; 559  : 	}
; 560  : 
; 561  : 	if (timer)

  015d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _timer, 0
  015da	74 33		 je	 SHORT $LN94@Y_Intermis

; 562  : 		V_DrawCenteredString(BASEVIDWIDTH/2, 188, V_YELLOWMAP,

  015dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _timer
  015e1	99		 cdq
  015e2	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  015e7	f7 f9		 idiv	 ecx
  015e9	50		 push	 eax
  015ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KHJLOGLC@start?5in?5?$CFd?5seconds@
  015ef	e8 00 00 00 00	 call	 _va
  015f4	83 c4 08	 add	 esp, 8
  015f7	50		 push	 eax
  015f8	68 00 00 10 00	 push	 1048576			; 00100000H
  015fd	68 bc 00 00 00	 push	 188			; 000000bcH
  01602	68 a0 00 00 00	 push	 160			; 000000a0H
  01607	e8 00 00 00 00	 call	 _V_DrawCenteredString
  0160c	83 c4 10	 add	 esp, 16			; 00000010H
$LN94@Y_Intermis:

; 563  : 			va("start in %d seconds", timer/TICRATE));
; 564  : 
; 565  : 	// Make it obvious that scrambling is happening next round.
; 566  : 	if (cv_scrambleonchange.value && cv_teamscramble.value && (intertic/TICRATE % 2 == 0))

  0160f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_scrambleonchange+20, 0
  01616	74 48		 je	 SHORT $LN95@Y_Intermis
  01618	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_teamscramble+20, 0
  0161f	74 3f		 je	 SHORT $LN95@Y_Intermis
  01621	a1 00 00 00 00	 mov	 eax, DWORD PTR _intertic
  01626	99		 cdq
  01627	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  0162c	f7 f9		 idiv	 ecx
  0162e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  01633	79 05		 jns	 SHORT $LN105@Y_Intermis
  01635	48		 dec	 eax
  01636	83 c8 fe	 or	 eax, -2			; fffffffeH
  01639	40		 inc	 eax
$LN105@Y_Intermis:
  0163a	85 c0		 test	 eax, eax
  0163c	75 22		 jne	 SHORT $LN95@Y_Intermis

; 567  : 		V_DrawCenteredString(BASEVIDWIDTH/2, BASEVIDHEIGHT/2, V_YELLOWMAP, va("Teams will be scrambled next round!"));

  0163e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HHOHLNCO@Teams?5will?5be?5scrambled?5next?5ro@
  01643	e8 00 00 00 00	 call	 _va
  01648	83 c4 04	 add	 esp, 4
  0164b	50		 push	 eax
  0164c	68 00 00 10 00	 push	 1048576			; 00100000H
  01651	6a 64		 push	 100			; 00000064H
  01653	68 a0 00 00 00	 push	 160			; 000000a0H
  01658	e8 00 00 00 00	 call	 _V_DrawCenteredString
  0165d	83 c4 10	 add	 esp, 16			; 00000010H
$LN95@Y_Intermis:

; 568  : }

  01660	5f		 pop	 edi
  01661	5e		 pop	 esi
  01662	5b		 pop	 ebx
  01663	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01666	33 cd		 xor	 ecx, ebp
  01668	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0166d	8b e5		 mov	 esp, ebp
  0166f	5d		 pop	 ebp
  01670	c3		 ret	 0
_Y_IntermissionDrawer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 __vsnprintf
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1952 :         __crt_va_end(_ArgList);

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1953 :         return _Result;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1954 :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1411 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00016	52		 push	 edx
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1413 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
