; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\hw_md2.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_avertexnormals
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_md2_models:BYTE:05128H
COMM	_md2_playermodels:BYTE:0700H
_DATA	ENDS
_DATA	SEGMENT
_avertexnormals DD 0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	03f06964fr			; 0.525731
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	03f59c444r			; 0.850651
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	0bf59c444r			; -0.850651
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	0bf06964fr			; -0.525731
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f59c444r			; 0.850651
	DD	0bf06964fr			; -0.525731
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	0be9729f6r			; -0.295242
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	03e9729f6r			; 0.295242
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	03e7496abr			; 0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03e86965fr			; 0.262866
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	03f000000r			; 0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	03f59c444r			; 0.850651
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f06964fr			; 0.525731
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	03f74969ar			; 0.955423
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	03f59c444r			; 0.850651
	DD	0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	03f74969ar			; 0.955423
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	03f5d3b6dr			; 0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	03f4f1bbdr			; 0.809017
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	03f737868r			; 0.951056
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	03f2e8512r			; 0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f59c444r			; 0.850651
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	03f4f1bbdr			; 0.809017
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	03f5d3b6dr			; 0.864188
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	03f737868r			; 0.951056
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	03e1729f6r			; 0.147621
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e9e377ar			; 0.309017
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03ed9c433r			; 0.425325
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	03ee2bef0r			; 0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03f167914r			; 0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	03f302d49r			; 0.688191
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	0bf59c444r			; -0.850651
	DD	0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	0bf06964fr			; -0.525731
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	0bf59c444r			; -0.850651
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	03f06964fr			; 0.525731
	DD	000000000r			; 0
	DD	0bf74969ar			; -0.955423
	DD	03e9729f6r			; 0.295242
	DD	03e7496abr			; 0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	03e86965fr			; 0.262866
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	03f000000r			; 0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	03f3770efr			; 0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	03f06964fr			; 0.525731
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	0bf59c444r			; -0.850651
	DD	0bf06964fr			; -0.525731
	DD	000000000r			; 0
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf06964fr			; -0.525731
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	0bf000000r			; -0.5
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	0be7496abr			; -0.238856
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0be86965fr			; -0.262866
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	03e7496abr			; 0.238856
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	03f000000r			; 0.5
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	03f3770efr			; 0.716567
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	03f5d3b6dr			; 0.864188
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	03f737868r			; 0.951056
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	03f4f1bbdr			; 0.809017
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	03f2e8512r			; 0.681718
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	03f59c444r			; 0.850651
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf74969ar			; -0.955423
	DD	03e9729f6r			; 0.295242
	DD	000000000r			; 0
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	03f06964fr			; 0.525731
	DD	0bf74969ar			; -0.955423
	DD	0be9729f6r			; -0.295242
	DD	000000000r			; 0
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	03e86965fr			; 0.262866
	DD	0bf5d3b6dr			; -0.864188
	DD	03ee2bef0r			; 0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf737868r			; -0.951056
	DD	03e265bear			; 0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf4f1bbdr			; -0.809017
	DD	03e9e377ar			; 0.309017
	DD	0bf000000r			; -0.5
	DD	0bf5d3b6dr			; -0.864188
	DD	0bee2bef0r			; -0.442863
	DD	0be7496abr			; -0.238856
	DD	0bf737868r			; -0.951056
	DD	0be265bear			; -0.16246
	DD	0be86965fr			; -0.262866
	DD	0bf4f1bbdr			; -0.809017
	DD	0be9e377ar			; -0.309017
	DD	0bf000000r			; -0.5
	DD	0bf2e8512r			; -0.681718
	DD	03e1729f6r			; 0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf2e8512r			; -0.681718
	DD	0be1729f6r			; -0.147621
	DD	0bf3770efr			; -0.716567
	DD	0bf59c444r			; -0.850651
	DD	000000000r			; 0
	DD	0bf06964fr			; -0.525731
	DD	0bf302d49r			; -0.688191
	DD	03f167914r			; 0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf167914r			; -0.587785
	DD	03ed9c433r			; 0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bed9c433r			; -0.425325
	DD	03f302d49r			; 0.688191
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
	DD	0bf302d49r			; -0.688191
	DD	0bf302d49r			; -0.688191
	DD	0bf167914r			; -0.587785
	DD	0bed9c433r			; -0.425325
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vfscanf_l
PUBLIC	_fscanf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_HWR_InitMD2
PUBLIC	_HWR_DrawMD2
PUBLIC	_HWR_AddPlayerMD2
PUBLIC	_HWR_AddSpriteMD2
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_06CLDLKFI@md2?1?$CFs@			; `string'
PUBLIC	??_C@_04IBGELPJM@?4pcx@				; `string'
PUBLIC	??_C@_0O@MLLNEMJJ@InitMD2?$CI?$CJ?4?4?4?6@	; `string'
PUBLIC	??_C@_02BMJICGCB@rt@				; `string'
PUBLIC	??_C@_07CPILLHHI@md2?4dat@			; `string'
PUBLIC	??_C@_0BN@MJFIHCEA@Error?5while?5loading?5md2?4dat?6@ ; `string'
PUBLIC	??_C@_0BA@FNNGIIBC@?$CF19s?5?$CF31s?5?$CFf?5?$CFf@ ; `string'
PUBLIC	??_C@_04MKCNCBEG@PLAY@				; `string'
PUBLIC	??_C@_0BN@MGIHOKNP@MD2?5for?5sprite?5?$CFs?5not?5found?6@ ; `string'
PUBLIC	??_C@_0CC@KBIOMPJ@MD2?5for?5player?5skin?5?$CFs?5not?5foun@ ; `string'
PUBLIC	??_C@_0BD@KDAOJKBL@AddPlayerMD2?$CI?$CJ?4?4?4?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@42c80000
PUBLIC	__real@47800000
PUBLIC	__real@bf800000
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	___stdio_common_vfscanf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_strcpy:PROC
EXTRN	_stricmp:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_AngleFixed:PROC
EXTRN	_HWR_TranstableToAlpha:PROC
EXTRN	_HWR_Lighting:PROC
EXTRN	_LightLevelToLum:PROC
EXTRN	_HWR_GetMappedPatch:PROC
EXTRN	_R_GetPlaneLight:PROC
EXTRN	_R_PointToAngle:PROC
EXTRN	_W_CachePatchNum:PROC
EXTRN	_FIL_ForceExtension:PROC
EXTRN	_Z_Free:PROC
EXTRN	_Z_MallocAlign:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_states:BYTE
EXTRN	_sprnames:BYTE
EXTRN	_cv_grmd2:BYTE
EXTRN	_hwdriver:BYTE
EXTRN	_sprites:DWORD
EXTRN	_skins:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BD@KDAOJKBL@AddPlayerMD2?$CI?$CJ?4?4?4?6@
CONST	SEGMENT
??_C@_0BD@KDAOJKBL@AddPlayerMD2?$CI?$CJ?4?4?4?6@ DB 'AddPlayerMD2()...', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KBIOMPJ@MD2?5for?5player?5skin?5?$CFs?5not?5foun@
CONST	SEGMENT
??_C@_0CC@KBIOMPJ@MD2?5for?5player?5skin?5?$CFs?5not?5foun@ DB 'MD2 for p'
	DB	'layer skin %s not found', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MGIHOKNP@MD2?5for?5sprite?5?$CFs?5not?5found?6@
CONST	SEGMENT
??_C@_0BN@MGIHOKNP@MD2?5for?5sprite?5?$CFs?5not?5found?6@ DB 'MD2 for spr'
	DB	'ite %s not found', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKCNCBEG@PLAY@
CONST	SEGMENT
??_C@_04MKCNCBEG@PLAY@ DB 'PLAY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FNNGIIBC@?$CF19s?5?$CF31s?5?$CFf?5?$CFf@
CONST	SEGMENT
??_C@_0BA@FNNGIIBC@?$CF19s?5?$CF31s?5?$CFf?5?$CFf@ DB '%19s %31s %f %f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MJFIHCEA@Error?5while?5loading?5md2?4dat?6@
CONST	SEGMENT
??_C@_0BN@MJFIHCEA@Error?5while?5loading?5md2?4dat?6@ DB 'Error while loa'
	DB	'ding md2.dat', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPILLHHI@md2?4dat@
CONST	SEGMENT
??_C@_07CPILLHHI@md2?4dat@ DB 'md2.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt@
CONST	SEGMENT
??_C@_02BMJICGCB@rt@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLNEMJJ@InitMD2?$CI?$CJ?4?4?4?6@
CONST	SEGMENT
??_C@_0O@MLLNEMJJ@InitMD2?$CI?$CJ?4?4?4?6@ DB 'InitMD2()...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBGELPJM@?4pcx@
CONST	SEGMENT
??_C@_04IBGELPJM@?4pcx@ DB '.pcx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLDLKFI@md2?1?$CFs@
CONST	SEGMENT
??_C@_06CLDLKFI@md2?1?$CFs@ DB 'md2/%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0311H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0602H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0123H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0126H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	08b4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02f4H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _md2_loadTexture
_TEXT	SEGMENT
_h$1 = -16						; size = 4
_w$2 = -12						; size = 4
_filename$ = -8						; size = 4
_grpatch$ = -4						; size = 4
_model$ = 8						; size = 4
_md2_loadTexture PROC					; COMDAT

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 843  : 	GLPatch_t *grpatch;
; 844  : 	const char *filename = model->filename;

  00009	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _filename$[ebp], eax

; 845  : 
; 846  : 	if (model->grpatch)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  00012	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00016	74 1a		 je	 SHORT $LN2@md2_loadTe

; 847  : 	{
; 848  : 		grpatch = model->grpatch;

  00018	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  0001b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0001e	89 4d fc	 mov	 DWORD PTR _grpatch$[ebp], ecx

; 849  : 		Z_Free(grpatch->mipmap.grInfo.data);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00024	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _Z_Free
  0002d	83 c4 04	 add	 esp, 4

; 850  : 	}

  00030	eb 18		 jmp	 SHORT $LN3@md2_loadTe
$LN2@md2_loadTe:

; 851  : 	else
; 852  : 		grpatch = Z_Calloc(sizeof *grpatch, PU_HWRPATCHINFO,

  00032	6a 00		 push	 0
  00034	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  00037	83 c0 2c	 add	 eax, 44			; 0000002cH
  0003a	50		 push	 eax
  0003b	6a 05		 push	 5
  0003d	6a 40		 push	 64			; 00000040H
  0003f	e8 00 00 00 00	 call	 _Z_CallocAlign
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	89 45 fc	 mov	 DWORD PTR _grpatch$[ebp], eax
$LN3@md2_loadTe:

; 853  : 		                   &(model->grpatch));
; 854  : 
; 855  : 	if (!grpatch->mipmap.downloaded && !grpatch->mipmap.grInfo.data)

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0004d	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00051	0f 85 a1 00 00
	00		 jne	 $LN4@md2_loadTe
  00057	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0005a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0005e	0f 85 94 00 00
	00		 jne	 $LN4@md2_loadTe

; 856  : 	{
; 857  : 		int w = 0, h = 0;

  00064	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _w$2[ebp], 0
  0006b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _h$1[ebp], 0

; 858  : #ifdef HAVE_PNG
; 859  : 		grpatch->mipmap.grInfo.format = PNG_Load(filename, &w, &h, grpatch);
; 860  : 		if (grpatch->mipmap.grInfo.format == 0)
; 861  : #endif
; 862  : 		grpatch->mipmap.grInfo.format = PCX_Load(filename, &w, &h, grpatch);

  00072	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00075	50		 push	 eax
  00076	8d 4d f0	 lea	 ecx, DWORD PTR _h$1[ebp]
  00079	51		 push	 ecx
  0007a	8d 55 f4	 lea	 edx, DWORD PTR _w$2[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _filename$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _PCX_Load
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _grpatch$[ebp]
  0008d	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 863  : 		if (grpatch->mipmap.grInfo.format == 0)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00093	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00097	75 02		 jne	 SHORT $LN5@md2_loadTe

; 864  : 			return;

  00099	eb 6b		 jmp	 SHORT $LN1@md2_loadTe
$LN5@md2_loadTe:

; 865  : 
; 866  : 		grpatch->mipmap.downloaded = 0;

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  0009e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 867  : 		grpatch->mipmap.flags = 0;

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000a8	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 868  : 
; 869  : 		grpatch->width = (INT16)w;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000b2	66 8b 4d f4	 mov	 cx, WORD PTR _w$2[ebp]
  000b6	66 89 08	 mov	 WORD PTR [eax], cx

; 870  : 		grpatch->height = (INT16)h;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000bc	66 8b 4d f0	 mov	 cx, WORD PTR _h$1[ebp]
  000c0	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 871  : 		grpatch->mipmap.width = (UINT16)w;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000c7	66 8b 4d f4	 mov	 cx, WORD PTR _w$2[ebp]
  000cb	66 89 48 2e	 mov	 WORD PTR [eax+46], cx

; 872  : 		grpatch->mipmap.height = (UINT16)h;

  000cf	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000d2	66 8b 4d f0	 mov	 cx, WORD PTR _h$1[ebp]
  000d6	66 89 48 2c	 mov	 WORD PTR [eax+44], cx

; 873  : 
; 874  : 		// not correct!
; 875  : 		grpatch->mipmap.grInfo.smallLodLog2 = GR_LOD_LOG2_256;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000dd	c7 40 14 08 00
	00 00		 mov	 DWORD PTR [eax+20], 8

; 876  : 		grpatch->mipmap.grInfo.largeLodLog2 = GR_LOD_LOG2_256;

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000e7	c7 40 18 08 00
	00 00		 mov	 DWORD PTR [eax+24], 8

; 877  : 		grpatch->mipmap.grInfo.aspectRatioLog2 = GR_ASPECT_LOG2_1x1;

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000f1	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN4@md2_loadTe:

; 878  : 	}
; 879  : 	HWD.pfnSetTexture(&grpatch->mipmap);

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _grpatch$[ebp]
  000fb	83 c0 14	 add	 eax, 20			; 00000014H
  000fe	50		 push	 eax
  000ff	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  00105	90		 npad	 1
$LN1@md2_loadTe:

; 880  : }

  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
_md2_loadTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _PCX_Load
_TEXT	SEGMENT
tv155 = -1072						; size = 4
_pcxfilename$ = -940					; size = 4
_file$ = -936						; size = 4
_rep$ = -932						; size = 4
_ch$ = -928						; size = 4
_ptr$ = -924						; size = 4
_size$ = -920						; size = 4
_ph$ = -916						; size = 4
_pw$ = -912						; size = 4
_image$ = -908						; size = 4
_pal$ = -904						; size = 4
_palette$ = -900					; size = 768
_header$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_grpatch$ = 20						; size = 4
_PCX_Load PROC						; COMDAT

; 769  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 04 00
	00		 sub	 esp, 1072		; 00000430H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 770  : 	PcxHeader header;
; 771  : #define PALSIZE 768
; 772  : 	UINT8 palette[PALSIZE];
; 773  : 	const UINT8 *pal;
; 774  : 	RGBA_t *image;
; 775  : 	size_t pw, ph, size, ptr = 0;

  00016	c7 85 64 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _ptr$[ebp], 0

; 776  : 	INT32 ch, rep;
; 777  : 	FILE *file;
; 778  : 	char *pcxfilename = va("md2/%s", filename);

  00020	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_06CLDLKFI@md2?1?$CFs@
  00029	e8 00 00 00 00	 call	 _va
  0002e	83 c4 08	 add	 esp, 8
  00031	89 85 54 fc ff
	ff		 mov	 DWORD PTR _pcxfilename$[ebp], eax

; 779  : 
; 780  : 	FIL_ForceExtension(pcxfilename, ".pcx");

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_04IBGELPJM@?4pcx@
  0003c	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _pcxfilename$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _FIL_ForceExtension
  00048	83 c4 08	 add	 esp, 8

; 781  : 	file = fopen(pcxfilename, "rb");

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00050	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _pcxfilename$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _fopen
  0005c	83 c4 08	 add	 esp, 8
  0005f	89 85 58 fc ff
	ff		 mov	 DWORD PTR _file$[ebp], eax

; 782  : 	if (!file)

  00065	83 bd 58 fc ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  0006c	75 07		 jne	 SHORT $LN6@PCX_Load

; 783  : 		return 0;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 99 02 00 00	 jmp	 $LN1@PCX_Load
$LN6@PCX_Load:

; 784  : 
; 785  : 	if (fread(&header, sizeof (PcxHeader), 1, file) != 1)

  00075	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  0007b	50		 push	 eax
  0007c	6a 01		 push	 1
  0007e	68 80 00 00 00	 push	 128			; 00000080H
  00083	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _header$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _fread
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	83 f8 01	 cmp	 eax, 1
  00095	74 16		 je	 SHORT $LN7@PCX_Load

; 786  : 	{
; 787  : 		fclose(file);

  00097	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _fclose
  000a3	83 c4 04	 add	 esp, 4

; 788  : 		return 0;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 61 02 00 00	 jmp	 $LN1@PCX_Load
$LN7@PCX_Load:

; 789  : 	}
; 790  : 
; 791  : 	if (header.bitsPerPixel != 8)

  000ad	0f b6 85 7f ff
	ff ff		 movzx	 eax, BYTE PTR _header$[ebp+3]
  000b4	83 f8 08	 cmp	 eax, 8
  000b7	74 16		 je	 SHORT $LN8@PCX_Load

; 792  : 	{
; 793  : 		fclose(file);

  000b9	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _fclose
  000c5	83 c4 04	 add	 esp, 4

; 794  : 		return 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 3f 02 00 00	 jmp	 $LN1@PCX_Load
$LN8@PCX_Load:

; 795  : 	}
; 796  : 
; 797  : 	fseek(file, -PALSIZE, SEEK_END);

  000cf	6a 02		 push	 2
  000d1	68 00 fd ff ff	 push	 -768			; fffffd00H
  000d6	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _fseek
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  : 
; 799  : 	pw = *w = header.xmax - header.xmin + 1;

  000e5	0f bf 45 84	 movsx	 eax, WORD PTR _header$[ebp+8]
  000e9	0f bf 4d 80	 movsx	 ecx, WORD PTR _header$[ebp+4]
  000ed	2b c1		 sub	 eax, ecx
  000ef	83 c0 01	 add	 eax, 1
  000f2	8b 55 0c	 mov	 edx, DWORD PTR _w$[ebp]
  000f5	89 02		 mov	 DWORD PTR [edx], eax
  000f7	8b 45 0c	 mov	 eax, DWORD PTR _w$[ebp]
  000fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fc	89 8d 70 fc ff
	ff		 mov	 DWORD PTR _pw$[ebp], ecx

; 800  : 	ph = *h = header.ymax - header.ymin + 1;

  00102	0f bf 45 86	 movsx	 eax, WORD PTR _header$[ebp+10]
  00106	0f bf 4d 82	 movsx	 ecx, WORD PTR _header$[ebp+6]
  0010a	2b c1		 sub	 eax, ecx
  0010c	83 c0 01	 add	 eax, 1
  0010f	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  00112	89 02		 mov	 DWORD PTR [edx], eax
  00114	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  00117	8b 08		 mov	 ecx, DWORD PTR [eax]
  00119	89 8d 6c fc ff
	ff		 mov	 DWORD PTR _ph$[ebp], ecx

; 801  : 	image = Z_Malloc(pw*ph*4, PU_HWRCACHE, &grpatch->mipmap.grInfo.data);

  0011f	6a 00		 push	 0
  00121	8b 45 14	 mov	 eax, DWORD PTR _grpatch$[ebp]
  00124	83 c0 24	 add	 eax, 36			; 00000024H
  00127	50		 push	 eax
  00128	6a 66		 push	 102			; 00000066H
  0012a	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _pw$[ebp]
  00130	0f af 8d 6c fc
	ff ff		 imul	 ecx, DWORD PTR _ph$[ebp]
  00137	c1 e1 02	 shl	 ecx, 2
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _Z_MallocAlign
  00140	83 c4 10	 add	 esp, 16			; 00000010H
  00143	89 85 74 fc ff
	ff		 mov	 DWORD PTR _image$[ebp], eax

; 802  : 
; 803  : 	if (fread(palette, sizeof (UINT8), PALSIZE, file) != PALSIZE)

  00149	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  0014f	50		 push	 eax
  00150	68 00 03 00 00	 push	 768			; 00000300H
  00155	6a 01		 push	 1
  00157	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR _palette$[ebp]
  0015d	51		 push	 ecx
  0015e	e8 00 00 00 00	 call	 _fread
  00163	83 c4 10	 add	 esp, 16			; 00000010H
  00166	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  0016b	74 25		 je	 SHORT $LN9@PCX_Load

; 804  : 	{
; 805  : 		Z_Free(image);

  0016d	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _image$[ebp]
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _Z_Free
  00179	83 c4 04	 add	 esp, 4

; 806  : 		fclose(file);

  0017c	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _fclose
  00188	83 c4 04	 add	 esp, 4

; 807  : 		return 0;

  0018b	33 c0		 xor	 eax, eax
  0018d	e9 7c 01 00 00	 jmp	 $LN1@PCX_Load
$LN9@PCX_Load:

; 808  : 	}
; 809  : 	fseek(file, sizeof (PcxHeader), SEEK_SET);

  00192	6a 00		 push	 0
  00194	68 80 00 00 00	 push	 128			; 00000080H
  00199	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _fseek
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 810  : 
; 811  : 	size = pw * ph;

  001a8	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _pw$[ebp]
  001ae	0f af 85 6c fc
	ff ff		 imul	 eax, DWORD PTR _ph$[ebp]
  001b5	89 85 68 fc ff
	ff		 mov	 DWORD PTR _size$[ebp], eax
$LN2@PCX_Load:

; 812  : 	while (ptr < size)

  001bb	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  001c1	3b 85 68 fc ff
	ff		 cmp	 eax, DWORD PTR _size$[ebp]
  001c7	0f 83 2d 01 00
	00		 jae	 $LN3@PCX_Load

; 813  : 	{
; 814  : 		ch = fgetc(file);  //Hurdler: beurk

  001cd	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 _fgetc
  001d9	83 c4 04	 add	 esp, 4
  001dc	89 85 60 fc ff
	ff		 mov	 DWORD PTR _ch$[ebp], eax

; 815  : 		if (ch >= 192)

  001e2	81 bd 60 fc ff
	ff c0 00 00 00	 cmp	 DWORD PTR _ch$[ebp], 192 ; 000000c0H
  001ec	7c 28		 jl	 SHORT $LN10@PCX_Load

; 816  : 		{
; 817  : 			rep = ch - 192;

  001ee	8b 85 60 fc ff
	ff		 mov	 eax, DWORD PTR _ch$[ebp]
  001f4	2d c0 00 00 00	 sub	 eax, 192		; 000000c0H
  001f9	89 85 5c fc ff
	ff		 mov	 DWORD PTR _rep$[ebp], eax

; 818  : 			ch = fgetc(file);

  001ff	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _fgetc
  0020b	83 c4 04	 add	 esp, 4
  0020e	89 85 60 fc ff
	ff		 mov	 DWORD PTR _ch$[ebp], eax

; 819  : 		}

  00214	eb 0a		 jmp	 SHORT $LN11@PCX_Load
$LN10@PCX_Load:

; 820  : 		else
; 821  : 		{
; 822  : 			rep = 1;

  00216	c7 85 5c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _rep$[ebp], 1
$LN11@PCX_Load:

; 823  : 		}
; 824  : 		while (rep--)

  00220	8b 85 5c fc ff
	ff		 mov	 eax, DWORD PTR _rep$[ebp]
  00226	89 85 d0 fb ff
	ff		 mov	 DWORD PTR tv155[ebp], eax
  0022c	8b 8d 5c fc ff
	ff		 mov	 ecx, DWORD PTR _rep$[ebp]
  00232	83 e9 01	 sub	 ecx, 1
  00235	89 8d 5c fc ff
	ff		 mov	 DWORD PTR _rep$[ebp], ecx
  0023b	83 bd d0 fb ff
	ff 00		 cmp	 DWORD PTR tv155[ebp], 0
  00242	0f 84 ad 00 00
	00		 je	 $LN5@PCX_Load

; 825  : 		{
; 826  : 			pal = palette + ch*3;

  00248	6b 85 60 fc ff
	ff 03		 imul	 eax, DWORD PTR _ch$[ebp], 3
  0024f	8d 8c 05 7c fc
	ff ff		 lea	 ecx, DWORD PTR _palette$[ebp+eax]
  00256	89 8d 78 fc ff
	ff		 mov	 DWORD PTR _pal$[ebp], ecx

; 827  : 			image[ptr].s.red   = *pal++;

  0025c	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00262	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR _image$[ebp]
  00268	8b 95 78 fc ff
	ff		 mov	 edx, DWORD PTR _pal$[ebp]
  0026e	8a 12		 mov	 dl, BYTE PTR [edx]
  00270	88 14 81	 mov	 BYTE PTR [ecx+eax*4], dl
  00273	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _pal$[ebp]
  00279	83 c0 01	 add	 eax, 1
  0027c	89 85 78 fc ff
	ff		 mov	 DWORD PTR _pal$[ebp], eax

; 828  : 			image[ptr].s.green = *pal++;

  00282	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  00288	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR _image$[ebp]
  0028e	8b 95 78 fc ff
	ff		 mov	 edx, DWORD PTR _pal$[ebp]
  00294	8a 12		 mov	 dl, BYTE PTR [edx]
  00296	88 54 81 01	 mov	 BYTE PTR [ecx+eax*4+1], dl
  0029a	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _pal$[ebp]
  002a0	83 c0 01	 add	 eax, 1
  002a3	89 85 78 fc ff
	ff		 mov	 DWORD PTR _pal$[ebp], eax

; 829  : 			image[ptr].s.blue  = *pal++;

  002a9	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  002af	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR _image$[ebp]
  002b5	8b 95 78 fc ff
	ff		 mov	 edx, DWORD PTR _pal$[ebp]
  002bb	8a 12		 mov	 dl, BYTE PTR [edx]
  002bd	88 54 81 02	 mov	 BYTE PTR [ecx+eax*4+2], dl
  002c1	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _pal$[ebp]
  002c7	83 c0 01	 add	 eax, 1
  002ca	89 85 78 fc ff
	ff		 mov	 DWORD PTR _pal$[ebp], eax

; 830  : 			image[ptr].s.alpha = 0xFF;

  002d0	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  002d6	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR _image$[ebp]
  002dc	c6 44 81 03 ff	 mov	 BYTE PTR [ecx+eax*4+3], 255 ; 000000ffH

; 831  : 			ptr++;

  002e1	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _ptr$[ebp]
  002e7	83 c0 01	 add	 eax, 1
  002ea	89 85 64 fc ff
	ff		 mov	 DWORD PTR _ptr$[ebp], eax

; 832  : 		}

  002f0	e9 2b ff ff ff	 jmp	 $LN11@PCX_Load
$LN5@PCX_Load:

; 833  : 	}

  002f5	e9 c1 fe ff ff	 jmp	 $LN2@PCX_Load
$LN3@PCX_Load:

; 834  : 	fclose(file);

  002fa	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00300	50		 push	 eax
  00301	e8 00 00 00 00	 call	 _fclose
  00306	83 c4 04	 add	 esp, 4

; 835  : 	return GR_RGBA;

  00309	b8 06 00 00 00	 mov	 eax, 6
$LN1@PCX_Load:

; 836  : }

  0030e	5f		 pop	 edi
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx
  00311	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00314	33 cd		 xor	 ecx, ebp
  00316	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031b	8b e5		 mov	 esp, ebp
  0031d	5d		 pop	 ebp
  0031e	c3		 ret	 0
_PCX_Load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _md2_printModelInfo
_TEXT	SEGMENT
_model$ = 8						; size = 4
_md2_printModelInfo PROC				; COMDAT

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 594  : #if 0
; 595  : 	INT32 i;
; 596  : 
; 597  : 	CONS_Printf("magic:\t\t\t%c%c%c%c\n", model->header.magic>>24,
; 598  : 	            (model->header.magic>>16)&0xff,
; 599  : 	            (model->header.magic>>8)&0xff,
; 600  : 	             model->header.magic&0xff);
; 601  : 	CONS_Printf("version:\t\t%d\n", model->header.version);
; 602  : 	CONS_Printf("skinWidth:\t\t%d\n", model->header.skinWidth);
; 603  : 	CONS_Printf("skinHeight:\t\t%d\n", model->header.skinHeight);
; 604  : 	CONS_Printf("frameSize:\t\t%d\n", model->header.frameSize);
; 605  : 	CONS_Printf("numSkins:\t\t%d\n", model->header.numSkins);
; 606  : 	CONS_Printf("numVertices:\t\t%d\n", model->header.numVertices);
; 607  : 	CONS_Printf("numTexCoords:\t\t%d\n", model->header.numTexCoords);
; 608  : 	CONS_Printf("numTriangles:\t\t%d\n", model->header.numTriangles);
; 609  : 	CONS_Printf("numGlCommands:\t\t%d\n", model->header.numGlCommands);
; 610  : 	CONS_Printf("numFrames:\t\t%d\n", model->header.numFrames);
; 611  : 	CONS_Printf("offsetSkins:\t\t%d\n", model->header.offsetSkins);
; 612  : 	CONS_Printf("offsetTexCoords:\t%d\n", model->header.offsetTexCoords);
; 613  : 	CONS_Printf("offsetTriangles:\t%d\n", model->header.offsetTriangles);
; 614  : 	CONS_Printf("offsetFrames:\t\t%d\n", model->header.offsetFrames);
; 615  : 	CONS_Printf("offsetGlCommands:\t%d\n", model->header.offsetGlCommands);
; 616  : 	CONS_Printf("offsetEnd:\t\t%d\n", model->header.offsetEnd);
; 617  : 
; 618  : 	for (i = 0; i < model->header.numFrames; i++)
; 619  : 		CONS_Printf("%s ", model->frames[i].name);
; 620  : 	CONS_Printf("\n");
; 621  : #else
; 622  : 	model = NULL;

  00009	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _model$[ebp], 0

; 623  : #endif
; 624  : }

  00010	5f		 pop	 edi
  00011	5e		 pop	 esi
  00012	5b		 pop	 ebx
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_md2_printModelInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _md2_readModel
_TEXT	SEGMENT
_j$1 = -8344						; size = 4
_frame$2 = -8340					; size = 4
_i$ = -8336						; size = 4
_buffer$ = -8332					; size = 8320
_model$ = -12						; size = 4
_file$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_md2_readModel PROC					; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 98 22 00 00	 mov	 eax, 8856		; 00002298H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 277  : 	FILE *file;
; 278  : 	md2_model_t *model;
; 279  : 	UINT8 buffer[MD2_MAX_FRAMESIZE];
; 280  : 	size_t i;
; 281  : 
; 282  : 	model = calloc(1, sizeof (*model));

  0001a	6a 58		 push	 88			; 00000058H
  0001c	6a 01		 push	 1
  0001e	e8 00 00 00 00	 call	 _calloc
  00023	83 c4 08	 add	 esp, 8
  00026	89 45 f4	 mov	 DWORD PTR _model$[ebp], eax

; 283  : 	if (model == NULL)

  00029	83 7d f4 00	 cmp	 DWORD PTR _model$[ebp], 0
  0002d	75 07		 jne	 SHORT $LN8@md2_readMo

; 284  : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 c9 05 00 00	 jmp	 $LN1@md2_readMo
$LN8@md2_readMo:

; 285  : 
; 286  : 	file = fopen(filename, "rb");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0003b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _fopen
  00044	83 c4 08	 add	 esp, 8
  00047	89 45 f8	 mov	 DWORD PTR _file$[ebp], eax

; 287  : 	if (!file)

  0004a	83 7d f8 00	 cmp	 DWORD PTR _file$[ebp], 0
  0004e	75 13		 jne	 SHORT $LN9@md2_readMo

; 288  : 	{
; 289  : 		free(model);

  00050	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _free
  00059	83 c4 04	 add	 esp, 4

; 290  : 		return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 9c 05 00 00	 jmp	 $LN1@md2_readMo
$LN9@md2_readMo:

; 291  : 	}
; 292  : 
; 293  : 	// initialize model and read header
; 294  : 
; 295  : 	if (fread(&model->header, sizeof (model->header), 1, file) != 1
; 296  : 		|| model->header.magic !=

  00063	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  00066	50		 push	 eax
  00067	6a 01		 push	 1
  00069	6a 44		 push	 68			; 00000044H
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _fread
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	83 f8 01	 cmp	 eax, 1
  0007a	75 0b		 jne	 SHORT $LN11@md2_readMo
  0007c	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0007f	81 38 49 44 50
	32		 cmp	 DWORD PTR [eax], 844121161 ; 32504449H
  00085	74 1f		 je	 SHORT $LN10@md2_readMo
$LN11@md2_readMo:

; 297  : 		(INT32)(('2' << 24) + ('P' << 16) + ('D' << 8) + 'I'))
; 298  : 	{
; 299  : 		fclose(file);

  00087	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _fclose
  00090	83 c4 04	 add	 esp, 4

; 300  : 		free(model);

  00093	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _free
  0009c	83 c4 04	 add	 esp, 4

; 301  : 		return 0;

  0009f	33 c0		 xor	 eax, eax
  000a1	e9 59 05 00 00	 jmp	 $LN1@md2_readMo
$LN10@md2_readMo:

; 302  : 	}
; 303  : 
; 304  : 	model->header.numSkins = 1;

  000a6	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  000a9	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1

; 305  : 
; 306  : 	// read skins
; 307  : 	fseek(file, model->header.offsetSkins, SEEK_SET);

  000b0	6a 00		 push	 0
  000b2	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  000b5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000b8	51		 push	 ecx
  000b9	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 _fseek
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 308  : 	if (model->header.numSkins > 0)

  000c5	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  000c8	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  000cc	76 57		 jbe	 SHORT $LN13@md2_readMo

; 309  : 	{
; 310  : 		model->skins = calloc(sizeof (md2_skin_t), model->header.numSkins);

  000ce	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  000d1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d4	51		 push	 ecx
  000d5	6a 40		 push	 64			; 00000040H
  000d7	e8 00 00 00 00	 call	 _calloc
  000dc	83 c4 08	 add	 esp, 8
  000df	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  000e2	89 42 44	 mov	 DWORD PTR [edx+68], eax

; 311  : 		if (!model->skins || model->header.numSkins !=

  000e5	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  000e8	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  000ec	74 24		 je	 SHORT $LN14@md2_readMo
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  000f5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000f8	52		 push	 edx
  000f9	6a 40		 push	 64			; 00000040H
  000fb	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  000fe	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00101	51		 push	 ecx
  00102	e8 00 00 00 00	 call	 _fread
  00107	83 c4 10	 add	 esp, 16			; 00000010H
  0010a	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  0010d	39 42 14	 cmp	 DWORD PTR [edx+20], eax
  00110	74 13		 je	 SHORT $LN13@md2_readMo
$LN14@md2_readMo:

; 312  : 			fread(model->skins, sizeof (md2_skin_t), model->header.numSkins, file))
; 313  : 		{
; 314  : 			md2_freeModel (model);

  00112	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _md2_freeModel
  0011b	83 c4 04	 add	 esp, 4

; 315  : 			return 0;

  0011e	33 c0		 xor	 eax, eax
  00120	e9 da 04 00 00	 jmp	 $LN1@md2_readMo
$LN13@md2_readMo:

; 316  : 		}
; 317  : 
; 318  : 		;
; 319  : 	}
; 320  : 
; 321  : 	// read texture coordinates
; 322  : 	fseek(file, model->header.offsetTexCoords, SEEK_SET);

  00125	6a 00		 push	 0
  00127	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0012a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0012d	51		 push	 ecx
  0012e	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _fseek
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH

; 323  : 	if (model->header.numTexCoords > 0)

  0013a	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0013d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00141	76 57		 jbe	 SHORT $LN16@md2_readMo

; 324  : 	{
; 325  : 		model->texCoords = calloc(sizeof (md2_textureCoordinate_t), model->header.numTexCoords);

  00143	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00146	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00149	51		 push	 ecx
  0014a	6a 04		 push	 4
  0014c	e8 00 00 00 00	 call	 _calloc
  00151	83 c4 08	 add	 esp, 8
  00154	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  00157	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 326  : 		if (!model->texCoords || model->header.numTexCoords !=

  0015a	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0015d	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00161	74 24		 je	 SHORT $LN17@md2_readMo
  00163	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  00166	50		 push	 eax
  00167	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  0016a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0016d	52		 push	 edx
  0016e	6a 04		 push	 4
  00170	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00173	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 _fread
  0017c	83 c4 10	 add	 esp, 16			; 00000010H
  0017f	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  00182	39 42 1c	 cmp	 DWORD PTR [edx+28], eax
  00185	74 13		 je	 SHORT $LN16@md2_readMo
$LN17@md2_readMo:

; 327  : 			fread(model->texCoords, sizeof (md2_textureCoordinate_t), model->header.numTexCoords, file))
; 328  : 		{
; 329  : 			md2_freeModel (model);

  00187	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _md2_freeModel
  00190	83 c4 04	 add	 esp, 4

; 330  : 			return 0;

  00193	33 c0		 xor	 eax, eax
  00195	e9 65 04 00 00	 jmp	 $LN1@md2_readMo
$LN16@md2_readMo:

; 331  : 		}
; 332  : 
; 333  : 
; 334  : 	}
; 335  : 
; 336  : 	// read triangles
; 337  : 	fseek(file, model->header.offsetTriangles, SEEK_SET);

  0019a	6a 00		 push	 0
  0019c	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0019f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001a2	51		 push	 ecx
  001a3	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _fseek
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 338  : 	if (model->header.numTriangles > 0)

  001af	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  001b2	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  001b6	76 57		 jbe	 SHORT $LN19@md2_readMo

; 339  : 	{
; 340  : 		model->triangles = calloc(sizeof (md2_triangle_t), model->header.numTriangles);

  001b8	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  001bb	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001be	51		 push	 ecx
  001bf	6a 0c		 push	 12			; 0000000cH
  001c1	e8 00 00 00 00	 call	 _calloc
  001c6	83 c4 08	 add	 esp, 8
  001c9	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  001cc	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 341  : 		if (!model->triangles || model->header.numTriangles !=

  001cf	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  001d2	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  001d6	74 24		 je	 SHORT $LN20@md2_readMo
  001d8	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  001db	50		 push	 eax
  001dc	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  001df	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001e2	52		 push	 edx
  001e3	6a 0c		 push	 12			; 0000000cH
  001e5	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  001e8	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 _fread
  001f1	83 c4 10	 add	 esp, 16			; 00000010H
  001f4	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  001f7	39 42 20	 cmp	 DWORD PTR [edx+32], eax
  001fa	74 13		 je	 SHORT $LN19@md2_readMo
$LN20@md2_readMo:

; 342  : 			fread(model->triangles, sizeof (md2_triangle_t), model->header.numTriangles, file))
; 343  : 		{
; 344  : 			md2_freeModel (model);

  001fc	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 _md2_freeModel
  00205	83 c4 04	 add	 esp, 4

; 345  : 			return 0;

  00208	33 c0		 xor	 eax, eax
  0020a	e9 f0 03 00 00	 jmp	 $LN1@md2_readMo
$LN19@md2_readMo:

; 346  : 		}
; 347  : 	}
; 348  : 
; 349  : 	// read alias frames
; 350  : 	fseek(file, model->header.offsetFrames, SEEK_SET);

  0020f	6a 00		 push	 0
  00211	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00214	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00217	51		 push	 ecx
  00218	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  0021b	52		 push	 edx
  0021c	e8 00 00 00 00	 call	 _fseek
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	if (model->header.numFrames > 0)

  00224	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00227	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0022b	0f 86 4d 03 00
	00		 jbe	 $LN3@md2_readMo

; 352  : 	{
; 353  : 		model->frames = calloc(sizeof (md2_frame_t), model->header.numFrames);

  00231	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00234	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00237	51		 push	 ecx
  00238	6a 14		 push	 20			; 00000014H
  0023a	e8 00 00 00 00	 call	 _calloc
  0023f	83 c4 08	 add	 esp, 8
  00242	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  00245	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 354  : 		if (!model->frames)

  00248	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0024b	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  0024f	75 13		 jne	 SHORT $LN22@md2_readMo

; 355  : 		{
; 356  : 			md2_freeModel (model);

  00251	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 _md2_freeModel
  0025a	83 c4 04	 add	 esp, 4

; 357  : 			return 0;

  0025d	33 c0		 xor	 eax, eax
  0025f	e9 9b 03 00 00	 jmp	 $LN1@md2_readMo
$LN22@md2_readMo:

; 358  : 		}
; 359  : 
; 360  : 		for (i = 0; i < model->header.numFrames; i++)

  00264	c7 85 70 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  0026e	eb 0f		 jmp	 SHORT $LN4@md2_readMo
$LN2@md2_readMo:
  00270	8b 85 70 df ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00276	83 c0 01	 add	 eax, 1
  00279	89 85 70 df ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN4@md2_readMo:
  0027f	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00282	8b 8d 70 df ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00288	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  0028b	0f 83 ed 02 00
	00		 jae	 $LN3@md2_readMo

; 361  : 		{
; 362  : 			md2_alias_frame_t *frame = (md2_alias_frame_t *)(void *)buffer;

  00291	8d 85 74 df ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00297	89 85 6c df ff
	ff		 mov	 DWORD PTR _frame$2[ebp], eax

; 363  : 			size_t j;
; 364  : 
; 365  : 			model->frames[i].vertices = calloc(sizeof (md2_triangleVertex_t), model->header.numVertices);

  0029d	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  002a0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002a3	51		 push	 ecx
  002a4	6a 18		 push	 24			; 00000018H
  002a6	e8 00 00 00 00	 call	 _calloc
  002ab	83 c4 08	 add	 esp, 8
  002ae	6b 95 70 df ff
	ff 14		 imul	 edx, DWORD PTR _i$[ebp], 20
  002b5	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  002b8	8b 49 50	 mov	 ecx, DWORD PTR [ecx+80]
  002bb	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 366  : 			if (!model->frames[i].vertices || model->header.frameSize !=

  002bf	6b 85 70 df ff
	ff 14		 imul	 eax, DWORD PTR _i$[ebp], 20
  002c6	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  002c9	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  002cc	83 7c 02 10 00	 cmp	 DWORD PTR [edx+eax+16], 0
  002d1	74 24		 je	 SHORT $LN24@md2_readMo
  002d3	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  002d6	50		 push	 eax
  002d7	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  002da	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  002dd	52		 push	 edx
  002de	6a 01		 push	 1
  002e0	8b 85 6c df ff
	ff		 mov	 eax, DWORD PTR _frame$2[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _fread
  002ec	83 c4 10	 add	 esp, 16			; 00000010H
  002ef	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  002f2	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  002f5	74 13		 je	 SHORT $LN23@md2_readMo
$LN24@md2_readMo:

; 367  : 				fread(frame, 1, model->header.frameSize, file))
; 368  : 			{
; 369  : 				md2_freeModel (model);

  002f7	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 _md2_freeModel
  00300	83 c4 04	 add	 esp, 4

; 370  : 				return 0;

  00303	33 c0		 xor	 eax, eax
  00305	e9 f5 02 00 00	 jmp	 $LN1@md2_readMo
$LN23@md2_readMo:

; 371  : 			}
; 372  : 
; 373  : 			strcpy(model->frames[i].name, frame->name);

  0030a	8b 85 6c df ff
	ff		 mov	 eax, DWORD PTR _frame$2[ebp]
  00310	83 c0 18	 add	 eax, 24			; 00000018H
  00313	50		 push	 eax
  00314	6b 8d 70 df ff
	ff 14		 imul	 ecx, DWORD PTR _i$[ebp], 20
  0031b	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  0031e	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00321	03 c1		 add	 eax, ecx
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 _strcpy
  00329	83 c4 08	 add	 esp, 8

; 374  : 			for (j = 0; j < model->header.numVertices; j++)

  0032c	c7 85 68 df ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$1[ebp], 0
  00336	eb 0f		 jmp	 SHORT $LN7@md2_readMo
$LN5@md2_readMo:
  00338	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  0033e	83 c0 01	 add	 eax, 1
  00341	89 85 68 df ff
	ff		 mov	 DWORD PTR _j$1[ebp], eax
$LN7@md2_readMo:
  00347	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0034a	8b 8d 68 df ff
	ff		 mov	 ecx, DWORD PTR _j$1[ebp]
  00350	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00353	0f 83 20 02 00
	00		 jae	 $LN6@md2_readMo

; 375  : 			{
; 376  : 				model->frames[i].vertices[j].vertex[0] = (float) ((INT32) frame->alias_vertices[j].vertex[0]) * frame->scale[0] + frame->translate[0];

  00359	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  0035f	8b 8d 6c df ff
	ff		 mov	 ecx, DWORD PTR _frame$2[ebp]
  00365	8d 54 81 28	 lea	 edx, DWORD PTR [ecx+eax*4+40]
  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	6b c8 00	 imul	 ecx, eax, 0
  00371	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00375	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00379	b8 04 00 00 00	 mov	 eax, 4
  0037e	6b c8 00	 imul	 ecx, eax, 0
  00381	8b 95 6c df ff
	ff		 mov	 edx, DWORD PTR _frame$2[ebp]
  00387	f3 0f 59 04 0a	 mulss	 xmm0, DWORD PTR [edx+ecx]
  0038c	b8 04 00 00 00	 mov	 eax, 4
  00391	6b c8 00	 imul	 ecx, eax, 0
  00394	8b 95 6c df ff
	ff		 mov	 edx, DWORD PTR _frame$2[ebp]
  0039a	f3 0f 58 44 0a
	0c		 addss	 xmm0, DWORD PTR [edx+ecx+12]
  003a0	6b 85 70 df ff
	ff 14		 imul	 eax, DWORD PTR _i$[ebp], 20
  003a7	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  003aa	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  003ad	6b 8d 68 df ff
	ff 18		 imul	 ecx, DWORD PTR _j$1[ebp], 24
  003b4	03 4c 02 10	 add	 ecx, DWORD PTR [edx+eax+16]
  003b8	ba 04 00 00 00	 mov	 edx, 4
  003bd	6b c2 00	 imul	 eax, edx, 0
  003c0	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 377  : 				model->frames[i].vertices[j].vertex[2] = -1* ((float) ((INT32) frame->alias_vertices[j].vertex[1]) * frame->scale[1] + frame->translate[1]);

  003c5	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  003cb	8b 8d 6c df ff
	ff		 mov	 ecx, DWORD PTR _frame$2[ebp]
  003d1	8d 54 81 28	 lea	 edx, DWORD PTR [ecx+eax*4+40]
  003d5	b8 01 00 00 00	 mov	 eax, 1
  003da	c1 e0 00	 shl	 eax, 0
  003dd	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  003e1	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  003e5	ba 04 00 00 00	 mov	 edx, 4
  003ea	c1 e2 00	 shl	 edx, 0
  003ed	8b 85 6c df ff
	ff		 mov	 eax, DWORD PTR _frame$2[ebp]
  003f3	f3 0f 59 04 10	 mulss	 xmm0, DWORD PTR [eax+edx]
  003f8	b9 04 00 00 00	 mov	 ecx, 4
  003fd	c1 e1 00	 shl	 ecx, 0
  00400	8b 95 6c df ff
	ff		 mov	 edx, DWORD PTR _frame$2[ebp]
  00406	f3 0f 58 44 0a
	0c		 addss	 xmm0, DWORD PTR [edx+ecx+12]
  0040c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf800000
  00414	6b 85 70 df ff
	ff 14		 imul	 eax, DWORD PTR _i$[ebp], 20
  0041b	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  0041e	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00421	6b 8d 68 df ff
	ff 18		 imul	 ecx, DWORD PTR _j$1[ebp], 24
  00428	03 4c 02 10	 add	 ecx, DWORD PTR [edx+eax+16]
  0042c	ba 04 00 00 00	 mov	 edx, 4
  00431	d1 e2		 shl	 edx, 1
  00433	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 378  : 				model->frames[i].vertices[j].vertex[1] = (float) ((INT32) frame->alias_vertices[j].vertex[2]) * frame->scale[2] + frame->translate[2];

  00438	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  0043e	8b 8d 6c df ff
	ff		 mov	 ecx, DWORD PTR _frame$2[ebp]
  00444	8d 54 81 28	 lea	 edx, DWORD PTR [ecx+eax*4+40]
  00448	b8 01 00 00 00	 mov	 eax, 1
  0044d	d1 e0		 shl	 eax, 1
  0044f	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00453	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00457	ba 04 00 00 00	 mov	 edx, 4
  0045c	d1 e2		 shl	 edx, 1
  0045e	8b 85 6c df ff
	ff		 mov	 eax, DWORD PTR _frame$2[ebp]
  00464	f3 0f 59 04 10	 mulss	 xmm0, DWORD PTR [eax+edx]
  00469	b9 04 00 00 00	 mov	 ecx, 4
  0046e	d1 e1		 shl	 ecx, 1
  00470	8b 95 6c df ff
	ff		 mov	 edx, DWORD PTR _frame$2[ebp]
  00476	f3 0f 58 44 0a
	0c		 addss	 xmm0, DWORD PTR [edx+ecx+12]
  0047c	6b 85 70 df ff
	ff 14		 imul	 eax, DWORD PTR _i$[ebp], 20
  00483	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  00486	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00489	6b 8d 68 df ff
	ff 18		 imul	 ecx, DWORD PTR _j$1[ebp], 24
  00490	03 4c 02 10	 add	 ecx, DWORD PTR [edx+eax+16]
  00494	ba 04 00 00 00	 mov	 edx, 4
  00499	c1 e2 00	 shl	 edx, 0
  0049c	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 379  : 				model->frames[i].vertices[j].normal[0] = avertexnormals[frame->alias_vertices[j].lightNormalIndex][0];

  004a1	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  004a7	8b 8d 6c df ff
	ff		 mov	 ecx, DWORD PTR _frame$2[ebp]
  004ad	0f b6 54 81 2b	 movzx	 edx, BYTE PTR [ecx+eax*4+43]
  004b2	6b c2 0c	 imul	 eax, edx, 12
  004b5	b9 04 00 00 00	 mov	 ecx, 4
  004ba	6b d1 00	 imul	 edx, ecx, 0
  004bd	6b 8d 70 df ff
	ff 14		 imul	 ecx, DWORD PTR _i$[ebp], 20
  004c4	8b 75 f4	 mov	 esi, DWORD PTR _model$[ebp]
  004c7	8b 76 50	 mov	 esi, DWORD PTR [esi+80]
  004ca	6b bd 68 df ff
	ff 18		 imul	 edi, DWORD PTR _j$1[ebp], 24
  004d1	03 7c 0e 10	 add	 edi, DWORD PTR [esi+ecx+16]
  004d5	b9 04 00 00 00	 mov	 ecx, 4
  004da	6b c9 00	 imul	 ecx, ecx, 0
  004dd	8b 94 10 00 00
	00 00		 mov	 edx, DWORD PTR _avertexnormals[eax+edx]
  004e4	89 54 0f 0c	 mov	 DWORD PTR [edi+ecx+12], edx

; 380  : 				model->frames[i].vertices[j].normal[1] = avertexnormals[frame->alias_vertices[j].lightNormalIndex][1];

  004e8	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  004ee	8b 8d 6c df ff
	ff		 mov	 ecx, DWORD PTR _frame$2[ebp]
  004f4	0f b6 54 81 2b	 movzx	 edx, BYTE PTR [ecx+eax*4+43]
  004f9	6b c2 0c	 imul	 eax, edx, 12
  004fc	b9 04 00 00 00	 mov	 ecx, 4
  00501	c1 e1 00	 shl	 ecx, 0
  00504	6b 95 70 df ff
	ff 14		 imul	 edx, DWORD PTR _i$[ebp], 20
  0050b	8b 75 f4	 mov	 esi, DWORD PTR _model$[ebp]
  0050e	8b 76 50	 mov	 esi, DWORD PTR [esi+80]
  00511	6b bd 68 df ff
	ff 18		 imul	 edi, DWORD PTR _j$1[ebp], 24
  00518	03 7c 16 10	 add	 edi, DWORD PTR [esi+edx+16]
  0051c	ba 04 00 00 00	 mov	 edx, 4
  00521	c1 e2 00	 shl	 edx, 0
  00524	8b 84 08 00 00
	00 00		 mov	 eax, DWORD PTR _avertexnormals[eax+ecx]
  0052b	89 44 17 0c	 mov	 DWORD PTR [edi+edx+12], eax

; 381  : 				model->frames[i].vertices[j].normal[2] = avertexnormals[frame->alias_vertices[j].lightNormalIndex][2];

  0052f	8b 85 68 df ff
	ff		 mov	 eax, DWORD PTR _j$1[ebp]
  00535	8b 8d 6c df ff
	ff		 mov	 ecx, DWORD PTR _frame$2[ebp]
  0053b	0f b6 54 81 2b	 movzx	 edx, BYTE PTR [ecx+eax*4+43]
  00540	6b c2 0c	 imul	 eax, edx, 12
  00543	b9 04 00 00 00	 mov	 ecx, 4
  00548	d1 e1		 shl	 ecx, 1
  0054a	6b 95 70 df ff
	ff 14		 imul	 edx, DWORD PTR _i$[ebp], 20
  00551	8b 75 f4	 mov	 esi, DWORD PTR _model$[ebp]
  00554	8b 76 50	 mov	 esi, DWORD PTR [esi+80]
  00557	6b bd 68 df ff
	ff 18		 imul	 edi, DWORD PTR _j$1[ebp], 24
  0055e	03 7c 16 10	 add	 edi, DWORD PTR [esi+edx+16]
  00562	ba 04 00 00 00	 mov	 edx, 4
  00567	d1 e2		 shl	 edx, 1
  00569	8b 84 08 00 00
	00 00		 mov	 eax, DWORD PTR _avertexnormals[eax+ecx]
  00570	89 44 17 0c	 mov	 DWORD PTR [edi+edx+12], eax

; 382  : 			}

  00574	e9 bf fd ff ff	 jmp	 $LN5@md2_readMo
$LN6@md2_readMo:

; 383  : 		}

  00579	e9 f2 fc ff ff	 jmp	 $LN2@md2_readMo
$LN3@md2_readMo:

; 384  : 	}
; 385  : 
; 386  : 	// read gl commands
; 387  : 	fseek(file, model->header.offsetGlCommands, SEEK_SET);

  0057e	6a 00		 push	 0
  00580	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00583	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00586	51		 push	 ecx
  00587	8b 55 f8	 mov	 edx, DWORD PTR _file$[ebp]
  0058a	52		 push	 edx
  0058b	e8 00 00 00 00	 call	 _fseek
  00590	83 c4 0c	 add	 esp, 12			; 0000000cH

; 388  : 	if (model->header.numGlCommands)

  00593	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  00596	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0059a	74 54		 je	 SHORT $LN26@md2_readMo

; 389  : 	{
; 390  : 		model->glCommandBuffer = calloc(sizeof (INT32), model->header.numGlCommands);

  0059c	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  0059f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005a2	51		 push	 ecx
  005a3	6a 04		 push	 4
  005a5	e8 00 00 00 00	 call	 _calloc
  005aa	83 c4 08	 add	 esp, 8
  005ad	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  005b0	89 42 54	 mov	 DWORD PTR [edx+84], eax

; 391  : 		if (!model->glCommandBuffer || model->header.numGlCommands !=

  005b3	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  005b6	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  005ba	74 24		 je	 SHORT $LN27@md2_readMo
  005bc	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  005bf	50		 push	 eax
  005c0	8b 4d f4	 mov	 ecx, DWORD PTR _model$[ebp]
  005c3	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  005c6	52		 push	 edx
  005c7	6a 04		 push	 4
  005c9	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  005cc	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  005cf	51		 push	 ecx
  005d0	e8 00 00 00 00	 call	 _fread
  005d5	83 c4 10	 add	 esp, 16			; 00000010H
  005d8	8b 55 f4	 mov	 edx, DWORD PTR _model$[ebp]
  005db	39 42 24	 cmp	 DWORD PTR [edx+36], eax
  005de	74 10		 je	 SHORT $LN26@md2_readMo
$LN27@md2_readMo:

; 392  : 			fread(model->glCommandBuffer, sizeof (INT32), model->header.numGlCommands, file))
; 393  : 		{
; 394  : 			md2_freeModel (model);

  005e0	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
  005e3	50		 push	 eax
  005e4	e8 00 00 00 00	 call	 _md2_freeModel
  005e9	83 c4 04	 add	 esp, 4

; 395  : 			return 0;

  005ec	33 c0		 xor	 eax, eax
  005ee	eb 0f		 jmp	 SHORT $LN1@md2_readMo
$LN26@md2_readMo:

; 396  : 		}
; 397  : 	}
; 398  : 
; 399  : 	fclose(file);

  005f0	8b 45 f8	 mov	 eax, DWORD PTR _file$[ebp]
  005f3	50		 push	 eax
  005f4	e8 00 00 00 00	 call	 _fclose
  005f9	83 c4 04	 add	 esp, 4

; 400  : 
; 401  : 	return model;

  005fc	8b 45 f4	 mov	 eax, DWORD PTR _model$[ebp]
$LN1@md2_readMo:

; 402  : }

  005ff	5f		 pop	 edi
  00600	5e		 pop	 esi
  00601	5b		 pop	 ebx
  00602	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00605	33 cd		 xor	 ecx, ebp
  00607	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0060c	8b e5		 mov	 esp, ebp
  0060e	5d		 pop	 ebp
  0060f	c3		 ret	 0
_md2_readModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _md2_freeModel
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_model$ = 8						; size = 4
_md2_freeModel PROC					; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 240  : 	if (model)

  00009	83 7d 08 00	 cmp	 DWORD PTR _model$[ebp], 0
  0000d	0f 84 cb 00 00
	00		 je	 $LN5@md2_freeMo

; 241  : 	{
; 242  : 		if (model->skins)

  00013	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  00016	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0001a	74 0f		 je	 SHORT $LN6@md2_freeMo

; 243  : 			free(model->skins);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  0001f	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 _free
  00028	83 c4 04	 add	 esp, 4
$LN6@md2_freeMo:

; 244  : 
; 245  : 		if (model->texCoords)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  0002e	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00032	74 0f		 je	 SHORT $LN7@md2_freeMo

; 246  : 			free(model->texCoords);

  00034	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  00037	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _free
  00040	83 c4 04	 add	 esp, 4
$LN7@md2_freeMo:

; 247  : 
; 248  : 		if (model->triangles)

  00043	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  00046	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0004a	74 0f		 je	 SHORT $LN8@md2_freeMo

; 249  : 			free(model->triangles);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  0004f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _free
  00058	83 c4 04	 add	 esp, 4
$LN8@md2_freeMo:

; 250  : 
; 251  : 		if (model->frames)

  0005b	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  0005e	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00062	74 56		 je	 SHORT $LN9@md2_freeMo

; 252  : 		{
; 253  : 			size_t i;
; 254  : 
; 255  : 			for (i = 0; i < model->header.numFrames; i++)

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0006b	eb 09		 jmp	 SHORT $LN4@md2_freeMo
$LN2@md2_freeMo:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@md2_freeMo:
  00076	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  0007c	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  0007f	73 2a		 jae	 SHORT $LN3@md2_freeMo

; 256  : 			{
; 257  : 				if (model->frames[i].vertices)

  00081	6b 45 fc 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _model$[ebp]
  00088	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0008b	83 7c 02 10 00	 cmp	 DWORD PTR [edx+eax+16], 0
  00090	74 17		 je	 SHORT $LN10@md2_freeMo

; 258  : 					free(model->frames[i].vertices);

  00092	6b 45 fc 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _model$[ebp]
  00099	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0009c	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _free
  000a6	83 c4 04	 add	 esp, 4
$LN10@md2_freeMo:

; 259  : 			}

  000a9	eb c2		 jmp	 SHORT $LN2@md2_freeMo
$LN3@md2_freeMo:

; 260  : 			free(model->frames);

  000ab	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  000ae	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 _free
  000b7	83 c4 04	 add	 esp, 4
$LN9@md2_freeMo:

; 261  : 		}
; 262  : 
; 263  : 		if (model->glCommandBuffer)

  000ba	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  000bd	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  000c1	74 0f		 je	 SHORT $LN11@md2_freeMo

; 264  : 			free(model->glCommandBuffer);

  000c3	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  000c6	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _free
  000cf	83 c4 04	 add	 esp, 4
$LN11@md2_freeMo:

; 265  : 
; 266  : 		free(model);

  000d2	8b 45 08	 mov	 eax, DWORD PTR _model$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _free
  000db	83 c4 04	 add	 esp, 4
$LN5@md2_freeMo:

; 267  : 	}
; 268  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_md2_freeModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _HWR_AddSpriteMD2
_TEXT	SEGMENT
_offset$ = -68						; size = 4
_scale$ = -64						; size = 4
_filename$ = -60					; size = 32
_name$ = -28						; size = 18
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_spritenum$ = 8						; size = 4
_HWR_AddSpriteMD2 PROC					; COMDAT

; 1008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1009 : 	FILE *f;
; 1010 : 	// name[18] is used to check for names in the md2.dat file that match with sprites or player skins
; 1011 : 	// sprite names are always 4 characters long, and names is for player skins can be up to 19 characters long
; 1012 : 	char name[18], filename[32];
; 1013 : 	float scale, offset;
; 1014 : 
; 1015 : 	// Read the md2.dat file
; 1016 : 
; 1017 : 	f = fopen("md2.dat", "rt");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_02BMJICGCB@rt@
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_07CPILLHHI@md2?4dat@
  00020	e8 00 00 00 00	 call	 _fopen
  00025	83 c4 08	 add	 esp, 8
  00028	89 45 f8	 mov	 DWORD PTR _f$[ebp], eax

; 1018 : 
; 1019 : 	if (!f)

  0002b	83 7d f8 00	 cmp	 DWORD PTR _f$[ebp], 0
  0002f	75 12		 jne	 SHORT $LN4@HWR_AddSpr

; 1020 : 	{
; 1021 : 		CONS_Printf("Error while loading md2.dat\n");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MJFIHCEA@Error?5while?5loading?5md2?4dat?6@
  00036	e8 00 00 00 00	 call	 _CONS_Printf
  0003b	83 c4 04	 add	 esp, 4

; 1022 : 		return;

  0003e	e9 dd 00 00 00	 jmp	 $LN1@HWR_AddSpr
$LN4@HWR_AddSpr:

; 1023 : 	}
; 1024 : 
; 1025 : 	// Check for any MD2s that match the names of player skins!
; 1026 : 	while (fscanf(f, "%19s %31s %f %f", name, filename, &scale, &offset) == 4)

  00043	8d 45 bc	 lea	 eax, DWORD PTR _offset$[ebp]
  00046	50		 push	 eax
  00047	8d 4d c0	 lea	 ecx, DWORD PTR _scale$[ebp]
  0004a	51		 push	 ecx
  0004b	8d 55 c4	 lea	 edx, DWORD PTR _filename$[ebp]
  0004e	52		 push	 edx
  0004f	8d 45 e4	 lea	 eax, DWORD PTR _name$[ebp]
  00052	50		 push	 eax
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FNNGIIBC@?$CF19s?5?$CF31s?5?$CFf?5?$CFf@
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _fscanf
  00061	83 c4 18	 add	 esp, 24			; 00000018H
  00064	83 f8 04	 cmp	 eax, 4
  00067	0f 85 a7 00 00
	00		 jne	 $LN3@HWR_AddSpr

; 1027 : 	{
; 1028 : 		{
; 1029 : 			if (stricmp(name, sprnames[spritenum]) == 0)

  0006d	6b 45 08 05	 imul	 eax, DWORD PTR _spritenum$[ebp], 5
  00071	05 00 00 00 00	 add	 eax, OFFSET _sprnames
  00076	50		 push	 eax
  00077	8d 4d e4	 lea	 ecx, DWORD PTR _name$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _stricmp
  00080	83 c4 08	 add	 esp, 8
  00083	85 c0		 test	 eax, eax
  00085	75 60		 jne	 SHORT $LN5@HWR_AddSpr

; 1030 : 			{
; 1031 : 				if (stricmp(name, "PLAY") == 0) // Handled already NEWMD2: Per sprite, per-skin check

  00087	68 00 00 00 00	 push	 OFFSET ??_C@_04MKCNCBEG@PLAY@
  0008c	8d 45 e4	 lea	 eax, DWORD PTR _name$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _stricmp
  00095	83 c4 08	 add	 esp, 8
  00098	85 c0		 test	 eax, eax
  0009a	75 02		 jne	 SHORT $LN6@HWR_AddSpr

; 1032 : 					continue;

  0009c	eb a5		 jmp	 SHORT $LN4@HWR_AddSpr
$LN6@HWR_AddSpr:

; 1033 : 
; 1034 : 				md2_models[spritenum].scale = scale;

  0009e	6b 45 08 38	 imul	 eax, DWORD PTR _spritenum$[ebp], 56
  000a2	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _scale$[ebp]
  000a7	f3 0f 11 80 20
	00 00 00	 movss	 DWORD PTR _md2_models[eax+32], xmm0

; 1035 : 				md2_models[spritenum].offset = offset;

  000af	6b 45 08 38	 imul	 eax, DWORD PTR _spritenum$[ebp], 56
  000b3	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _offset$[ebp]
  000b8	f3 0f 11 80 24
	00 00 00	 movss	 DWORD PTR _md2_models[eax+36], xmm0

; 1036 : 				md2_models[spritenum].notfound = false;

  000c0	6b 45 08 38	 imul	 eax, DWORD PTR _spritenum$[ebp], 56
  000c4	c7 80 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_models[eax+48], 0

; 1037 : 				strcpy(md2_models[spritenum].filename, filename);

  000ce	8d 45 c4	 lea	 eax, DWORD PTR _filename$[ebp]
  000d1	50		 push	 eax
  000d2	6b 4d 08 38	 imul	 ecx, DWORD PTR _spritenum$[ebp], 56
  000d6	81 c1 00 00 00
	00		 add	 ecx, OFFSET _md2_models
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _strcpy
  000e2	83 c4 08	 add	 esp, 8

; 1038 : 				break;

  000e5	eb 2d		 jmp	 SHORT $LN3@HWR_AddSpr
$LN5@HWR_AddSpr:

; 1039 : 			}
; 1040 : 
; 1041 : 			if (spritenum == NUMSPRITES-1)

  000e7	81 7d 08 72 01
	00 00		 cmp	 DWORD PTR _spritenum$[ebp], 370 ; 00000172H
  000ee	75 1f		 jne	 SHORT $LN7@HWR_AddSpr

; 1042 : 			{
; 1043 : 				CONS_Printf("MD2 for sprite %s not found\n", name);

  000f0	8d 45 e4	 lea	 eax, DWORD PTR _name$[ebp]
  000f3	50		 push	 eax
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MGIHOKNP@MD2?5for?5sprite?5?$CFs?5not?5found?6@
  000f9	e8 00 00 00 00	 call	 _CONS_Printf
  000fe	83 c4 08	 add	 esp, 8

; 1044 : 				md2_models[spritenum].notfound = true;

  00101	6b 45 08 38	 imul	 eax, DWORD PTR _spritenum$[ebp], 56
  00105	c7 80 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_models[eax+48], 1
$LN7@HWR_AddSpr:

; 1045 : 			}
; 1046 : 		}
; 1047 : 	}

  0010f	e9 2f ff ff ff	 jmp	 $LN4@HWR_AddSpr
$LN3@HWR_AddSpr:

; 1048 : 
; 1049 : 	fclose(f);

  00114	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _fclose
  0011d	83 c4 04	 add	 esp, 4
$LN1@HWR_AddSpr:

; 1050 : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	33 cd		 xor	 ecx, ebp
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
_HWR_AddSpriteMD2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _HWR_AddPlayerMD2
_TEXT	SEGMENT
_offset$ = -68						; size = 4
_scale$ = -64						; size = 4
_filename$ = -60					; size = 32
_name$ = -28						; size = 18
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_skin$ = 8						; size = 4
_HWR_AddPlayerMD2 PROC					; COMDAT

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 969  : 	FILE *f;
; 970  : 	char name[18], filename[32];
; 971  : 	float scale, offset;
; 972  : 
; 973  : 	CONS_Printf("AddPlayerMD2()...\n");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KDAOJKBL@AddPlayerMD2?$CI?$CJ?4?4?4?6@
  0001b	e8 00 00 00 00	 call	 _CONS_Printf
  00020	83 c4 04	 add	 esp, 4

; 974  : 
; 975  : 	// read the md2.dat file
; 976  : 
; 977  : 	f = fopen("md2.dat", "rt");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02BMJICGCB@rt@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_07CPILLHHI@md2?4dat@
  0002d	e8 00 00 00 00	 call	 _fopen
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 f8	 mov	 DWORD PTR _f$[ebp], eax

; 978  : 	if (!f)

  00038	83 7d f8 00	 cmp	 DWORD PTR _f$[ebp], 0
  0003c	75 12		 jne	 SHORT $LN4@HWR_AddPla

; 979  : 	{
; 980  : 		CONS_Printf("Error while loading md2.dat\n");

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MJFIHCEA@Error?5while?5loading?5md2?4dat?6@
  00043	e8 00 00 00 00	 call	 _CONS_Printf
  00048	83 c4 04	 add	 esp, 4

; 981  : 		return;

  0004b	e9 d3 00 00 00	 jmp	 $LN1@HWR_AddPla
$LN4@HWR_AddPla:

; 982  : 	}
; 983  : 
; 984  : 	// Check for any MD2s that match the names of player skins!
; 985  : 	while (fscanf(f, "%19s %31s %f %f", name, filename, &scale, &offset) == 4)

  00050	8d 45 bc	 lea	 eax, DWORD PTR _offset$[ebp]
  00053	50		 push	 eax
  00054	8d 4d c0	 lea	 ecx, DWORD PTR _scale$[ebp]
  00057	51		 push	 ecx
  00058	8d 55 c4	 lea	 edx, DWORD PTR _filename$[ebp]
  0005b	52		 push	 edx
  0005c	8d 45 e4	 lea	 eax, DWORD PTR _name$[ebp]
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FNNGIIBC@?$CF19s?5?$CF31s?5?$CFf?5?$CFf@
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _fscanf
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
  00071	83 f8 04	 cmp	 eax, 4
  00074	0f 85 9d 00 00
	00		 jne	 $LN3@HWR_AddPla

; 986  : 	{
; 987  : 		if (stricmp(name, skins[skin].name) == 0)

  0007a	69 45 08 ec 00
	00 00		 imul	 eax, DWORD PTR _skin$[ebp], 236
  00081	05 00 00 00 00	 add	 eax, OFFSET _skins
  00086	50		 push	 eax
  00087	8d 4d e4	 lea	 ecx, DWORD PTR _name$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 _stricmp
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	75 56		 jne	 SHORT $LN5@HWR_AddPla

; 988  : 		{
; 989  : 			md2_playermodels[skin].skin = skin;

  00097	6b 45 08 38	 imul	 eax, DWORD PTR _skin$[ebp], 56
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _skin$[ebp]
  0009e	89 88 34 00 00
	00		 mov	 DWORD PTR _md2_playermodels[eax+52], ecx

; 990  : 			md2_playermodels[skin].scale = scale;

  000a4	6b 45 08 38	 imul	 eax, DWORD PTR _skin$[ebp], 56
  000a8	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _scale$[ebp]
  000ad	f3 0f 11 80 20
	00 00 00	 movss	 DWORD PTR _md2_playermodels[eax+32], xmm0

; 991  : 			md2_playermodels[skin].offset = offset;

  000b5	6b 45 08 38	 imul	 eax, DWORD PTR _skin$[ebp], 56
  000b9	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _offset$[ebp]
  000be	f3 0f 11 80 24
	00 00 00	 movss	 DWORD PTR _md2_playermodels[eax+36], xmm0

; 992  : 			md2_playermodels[skin].notfound = false;

  000c6	6b 45 08 38	 imul	 eax, DWORD PTR _skin$[ebp], 56
  000ca	c7 80 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+48], 0

; 993  : 			strcpy(md2_playermodels[skin].filename, filename);

  000d4	8d 45 c4	 lea	 eax, DWORD PTR _filename$[ebp]
  000d7	50		 push	 eax
  000d8	6b 4d 08 38	 imul	 ecx, DWORD PTR _skin$[ebp], 56
  000dc	81 c1 00 00 00
	00		 add	 ecx, OFFSET _md2_playermodels
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 _strcpy
  000e8	83 c4 08	 add	 esp, 8

; 994  : 			break;

  000eb	eb 2a		 jmp	 SHORT $LN3@HWR_AddPla
$LN5@HWR_AddPla:

; 995  : 		}
; 996  : 		if (skin == MAXSKINS-1)

  000ed	83 7d 08 1f	 cmp	 DWORD PTR _skin$[ebp], 31 ; 0000001fH
  000f1	75 1f		 jne	 SHORT $LN6@HWR_AddPla

; 997  : 		{
; 998  : 			CONS_Printf("MD2 for player skin %s not found\n", name);

  000f3	8d 45 e4	 lea	 eax, DWORD PTR _name$[ebp]
  000f6	50		 push	 eax
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KBIOMPJ@MD2?5for?5player?5skin?5?$CFs?5not?5foun@
  000fc	e8 00 00 00 00	 call	 _CONS_Printf
  00101	83 c4 08	 add	 esp, 8

; 999  : 			md2_playermodels[skin].notfound = true;

  00104	6b 45 08 38	 imul	 eax, DWORD PTR _skin$[ebp], 56
  00108	c7 80 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+48], 1
$LN6@HWR_AddPla:

; 1000 : 		}
; 1001 : 	}

  00112	e9 39 ff ff ff	 jmp	 $LN4@HWR_AddPla
$LN3@HWR_AddPla:

; 1002 : 
; 1003 : 	fclose(f);

  00117	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _fclose
  00120	83 c4 04	 add	 esp, 4
$LN1@HWR_AddPla:

; 1004 : 
; 1005 : }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00129	33 cd		 xor	 ecx, ebp
  0012b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
_HWR_AddPlayerMD2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _HWR_DrawMD2
_TEXT	SEGMENT
tv246 = -277						; size = 1
_normscale$1 = -212					; size = 4
_finalscale$2 = -208					; size = 4
_anglef$3 = -204					; size = 4
_anglef$4 = -200					; size = 4
_nextframe$5 = -196					; size = 4
_sprframe$6 = -192					; size = 4
_sprdef$7 = -188					; size = 4
_flip$8 = -181						; size = 1
_next$9 = -180						; size = 4
_curr$10 = -176						; size = 4
_tics$11 = -172						; size = 4
_durs$12 = -168						; size = 4
_buff$13 = -164						; size = 4
_oldgpatch$14 = -160					; size = 4
_blend$15 = -156					; size = 4
_light$16 = -152					; size = 4
_colormap$17 = -148					; size = 4
_lightlevel$18 = -141					; size = 1
_sector$19 = -140					; size = 4
_color$ = -136						; size = 4
_md2$ = -132						; size = 4
_p$ = -128						; size = 44
_frame$ = -84						; size = 4
_filename$ = -80					; size = 64
_Surf$ = -16						; size = 8
_gpatch$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_spr$ = 8						; size = 4
_HWR_DrawMD2 PROC					; COMDAT

; 1074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1075 : 	GLPatch_t *gpatch; // sprite patch converted to hardware
; 1076 : 	FSurfaceInfo Surf;
; 1077 : 
; 1078 : 	char filename[64];
; 1079 : 	INT32 frame;
; 1080 : 	FTransform p;
; 1081 : 	md2_t *md2;
; 1082 : 	UINT8 color[4];
; 1083 : 
; 1084 : 	// cache model graphics
; 1085 : 	//12/12/99: Hurdler:
; 1086 : 	//          OK, I don't change anything for MD2 support because I want to be
; 1087 : 	//          sure to do it the right way. So actually, we keep normal sprite
; 1088 : 	//          in memory and we add the md2 model if it exists for that sprite
; 1089 : 
; 1090 : 	gpatch = W_CachePatchNum(spr->patchlumpnum, PU_CACHE);

  00016	6a 65		 push	 101			; 00000065H
  00018	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0001b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 _W_CachePatchNum
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f8	 mov	 DWORD PTR _gpatch$[ebp], eax

; 1091 : 
; 1092 : 	//12/12/99: Hurdler: same comment as above (for md2)
; 1093 : 	HWR_GetMappedPatch(gpatch, spr->colormap);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0002d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00030	51		 push	 ecx
  00031	8b 55 f8	 mov	 edx, DWORD PTR _gpatch$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 _HWR_GetMappedPatch
  0003a	83 c4 08	 add	 esp, 8

; 1094 : 
; 1095 : 	// MD2 colormap fix
; 1096 : 	// colormap test
; 1097 : 	{
; 1098 : 		sector_t *sector = spr->mobj->subsector->sector;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00040	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00043	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	89 85 74 ff ff
	ff		 mov	 DWORD PTR _sector$19[ebp], eax

; 1099 : 		UINT8 lightlevel = LightLevelToLum(sector->lightlevel);

  0004e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  00054	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _LightLevelToLum
  0005e	83 c4 04	 add	 esp, 4
  00061	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al

; 1100 : 		extracolormap_t *colormap = sector->extra_colormap;

  00067	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  0006d	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00073	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _colormap$17[ebp], ecx

; 1101 : 
; 1102 : 		if (sector->numlights)

  00079	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  0007f	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00086	0f 84 8c 01 00
	00		 je	 $LN2@HWR_DrawMD

; 1103 : 		{
; 1104 : 			INT32 light = R_GetPlaneLight(sector, spr->mobj->z, false);

  0008c	6a 00		 push	 0
  0008e	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00091	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00094	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00097	52		 push	 edx
  00098	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _R_GetPlaneLight
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a7	89 85 68 ff ff
	ff		 mov	 DWORD PTR _light$16[ebp], eax

; 1105 : 
; 1106 : 			if (sector->lightlist[light].height > (spr->mobj->z + spr->mobj->height))

  000ad	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  000b4	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  000ba	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  000c3	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  000c6	8b 75 08	 mov	 esi, DWORD PTR _spr$[ebp]
  000c9	8b 76 24	 mov	 esi, DWORD PTR [esi+36]
  000cc	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  000cf	03 4e 44	 add	 ecx, DWORD PTR [esi+68]
  000d2	39 0c 02	 cmp	 DWORD PTR [edx+eax], ecx
  000d5	0f 8e 8b 00 00
	00		 jle	 $LN4@HWR_DrawMD

; 1107 : 			{
; 1108 : 				if (!(spr->mobj->frame & FF_FULLBRIGHT))

  000db	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  000de	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e1	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000e4	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  000ea	75 2b		 jne	 SHORT $LN6@HWR_DrawMD

; 1109 : 					lightlevel = LightLevelToLum(*sector->lightlist[light].lightlevel);

  000ec	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  000f3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  000f9	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  000ff	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00103	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 _LightLevelToLum
  0010c	83 c4 04	 add	 esp, 4
  0010f	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
  00115	eb 13		 jmp	 SHORT $LN7@HWR_DrawMD
$LN6@HWR_DrawMD:

; 1110 : 				else
; 1111 : 					lightlevel = LightLevelToLum(255);

  00117	68 ff 00 00 00	 push	 255			; 000000ffH
  0011c	e8 00 00 00 00	 call	 _LightLevelToLum
  00121	83 c4 04	 add	 esp, 4
  00124	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
$LN7@HWR_DrawMD:

; 1112 : 
; 1113 : 				if (sector->lightlist[light].extra_colormap)

  0012a	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  00131	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  00137	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0013d	83 7c 02 08 00	 cmp	 DWORD PTR [edx+eax+8], 0
  00142	74 1d		 je	 SHORT $LN8@HWR_DrawMD

; 1114 : 					colormap = sector->lightlist[light].extra_colormap;

  00144	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  0014b	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  00151	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00157	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  0015b	89 85 6c ff ff
	ff		 mov	 DWORD PTR _colormap$17[ebp], eax
$LN8@HWR_DrawMD:

; 1115 : 			}

  00161	e9 b0 00 00 00	 jmp	 $LN11@HWR_DrawMD
$LN4@HWR_DrawMD:

; 1116 : 			else // If we can't use the light at its bottom, we'll use the light at its top
; 1117 : 			{
; 1118 : 				light = R_GetPlaneLight(sector, spr->mobj->z + spr->mobj->height, false);

  00166	6a 00		 push	 0
  00168	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0016b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0016e	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  00171	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00174	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00177	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  0017a	51		 push	 ecx
  0017b	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _sector$19[ebp]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 _R_GetPlaneLight
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018a	89 85 68 ff ff
	ff		 mov	 DWORD PTR _light$16[ebp], eax

; 1119 : 
; 1120 : 				if (!(spr->mobj->frame & FF_FULLBRIGHT))

  00190	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00193	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00196	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00199	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  0019f	75 2b		 jne	 SHORT $LN9@HWR_DrawMD

; 1121 : 					lightlevel = LightLevelToLum(*sector->lightlist[light].lightlevel);

  001a1	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  001a8	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  001ae	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  001b4	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  001b8	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 _LightLevelToLum
  001c1	83 c4 04	 add	 esp, 4
  001c4	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
  001ca	eb 13		 jmp	 SHORT $LN10@HWR_DrawMD
$LN9@HWR_DrawMD:

; 1122 : 				else
; 1123 : 					lightlevel = LightLevelToLum(255);

  001cc	68 ff 00 00 00	 push	 255			; 000000ffH
  001d1	e8 00 00 00 00	 call	 _LightLevelToLum
  001d6	83 c4 04	 add	 esp, 4
  001d9	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
$LN10@HWR_DrawMD:

; 1124 : 
; 1125 : 				if (sector->lightlist[light].extra_colormap)

  001df	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  001e6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  001ec	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  001f2	83 7c 02 08 00	 cmp	 DWORD PTR [edx+eax+8], 0
  001f7	74 1d		 je	 SHORT $LN11@HWR_DrawMD

; 1126 : 					colormap = sector->lightlist[light].extra_colormap;

  001f9	6b 85 68 ff ff
	ff 14		 imul	 eax, DWORD PTR _light$16[ebp], 20
  00200	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _sector$19[ebp]
  00206	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  0020c	8b 44 02 08	 mov	 eax, DWORD PTR [edx+eax+8]
  00210	89 85 6c ff ff
	ff		 mov	 DWORD PTR _colormap$17[ebp], eax
$LN11@HWR_DrawMD:

; 1127 : 			}
; 1128 : 		}

  00216	eb 60		 jmp	 SHORT $LN14@HWR_DrawMD
$LN2@HWR_DrawMD:

; 1129 : 		else
; 1130 : 		{
; 1131 : 			if (!(spr->mobj->frame & FF_FULLBRIGHT))

  00218	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0021b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0021e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00221	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  00227	75 1b		 jne	 SHORT $LN12@HWR_DrawMD

; 1132 : 				lightlevel = LightLevelToLum(sector->lightlevel);

  00229	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  0022f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00233	51		 push	 ecx
  00234	e8 00 00 00 00	 call	 _LightLevelToLum
  00239	83 c4 04	 add	 esp, 4
  0023c	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
  00242	eb 13		 jmp	 SHORT $LN13@HWR_DrawMD
$LN12@HWR_DrawMD:

; 1133 : 			else
; 1134 : 				lightlevel = LightLevelToLum(255);

  00244	68 ff 00 00 00	 push	 255			; 000000ffH
  00249	e8 00 00 00 00	 call	 _LightLevelToLum
  0024e	83 c4 04	 add	 esp, 4
  00251	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
$LN13@HWR_DrawMD:

; 1135 : 
; 1136 : 			if (sector->extra_colormap)

  00257	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  0025d	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  00264	74 12		 je	 SHORT $LN14@HWR_DrawMD

; 1137 : 				colormap = sector->extra_colormap;

  00266	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _sector$19[ebp]
  0026c	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00272	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _colormap$17[ebp], ecx
$LN14@HWR_DrawMD:

; 1138 : 		}
; 1139 : 
; 1140 : 		if (spr->mobj->frame & FF_FULLBRIGHT)

  00278	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0027b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0027e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00281	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  00287	74 13		 je	 SHORT $LN15@HWR_DrawMD

; 1141 : 			lightlevel = LightLevelToLum(255);

  00289	68 ff 00 00 00	 push	 255			; 000000ffH
  0028e	e8 00 00 00 00	 call	 _LightLevelToLum
  00293	83 c4 04	 add	 esp, 4
  00296	88 85 73 ff ff
	ff		 mov	 BYTE PTR _lightlevel$18[ebp], al
$LN15@HWR_DrawMD:

; 1142 : 
; 1143 : 		if (colormap)

  0029c	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR _colormap$17[ebp], 0
  002a3	74 2d		 je	 SHORT $LN16@HWR_DrawMD

; 1144 : 			Surf.FlatColor.rgba = HWR_Lighting(lightlevel, colormap->rgba, colormap->fadergba, false, false);

  002a5	6a 00		 push	 0
  002a7	6a 00		 push	 0
  002a9	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _colormap$17[ebp]
  002af	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  002b2	51		 push	 ecx
  002b3	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _colormap$17[ebp]
  002b9	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  002bc	50		 push	 eax
  002bd	0f b6 8d 73 ff
	ff ff		 movzx	 ecx, BYTE PTR _lightlevel$18[ebp]
  002c4	51		 push	 ecx
  002c5	e8 00 00 00 00	 call	 _HWR_Lighting
  002ca	83 c4 14	 add	 esp, 20			; 00000014H
  002cd	89 45 f4	 mov	 DWORD PTR _Surf$[ebp+4], eax
  002d0	eb 1e		 jmp	 SHORT $LN17@HWR_DrawMD
$LN16@HWR_DrawMD:

; 1145 : 		else
; 1146 : 			Surf.FlatColor.rgba = HWR_Lighting(lightlevel, NORMALFOG, FADEFOG, false, false);

  002d2	6a 00		 push	 0
  002d4	6a 00		 push	 0
  002d6	68 00 00 00 19	 push	 419430400		; 19000000H
  002db	6a 00		 push	 0
  002dd	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR _lightlevel$18[ebp]
  002e4	50		 push	 eax
  002e5	e8 00 00 00 00	 call	 _HWR_Lighting
  002ea	83 c4 14	 add	 esp, 20			; 00000014H
  002ed	89 45 f4	 mov	 DWORD PTR _Surf$[ebp+4], eax
$LN17@HWR_DrawMD:

; 1147 : 	}
; 1148 : 
; 1149 : 	// Look at HWR_ProjetctSprite for more
; 1150 : 	if (cv_grmd2.value && ((md2_models[spr->mobj->sprite].scale > 0.0f) || (md2_playermodels[(skin_t*)spr->mobj->skin-skins].scale > 0.0f)) && !spr->precip)

  002f0	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_grmd2+20, 0
  002f7	0f 84 b4 05 00
	00		 je	 $LN18@HWR_DrawMD
  002fd	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00300	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00303	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  00307	f3 0f 10 82 20
	00 00 00	 movss	 xmm0, DWORD PTR _md2_models[edx+32]
  0030f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00316	77 2e		 ja	 SHORT $LN19@HWR_DrawMD
  00318	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0031b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0031e	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00321	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  00326	99		 cdq
  00327	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  0032c	f7 f9		 idiv	 ecx
  0032e	6b d0 38	 imul	 edx, eax, 56
  00331	f3 0f 10 82 20
	00 00 00	 movss	 xmm0, DWORD PTR _md2_playermodels[edx+32]
  00339	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00340	0f 86 6b 05 00
	00		 jbe	 $LN18@HWR_DrawMD
$LN19@HWR_DrawMD:
  00346	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00349	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0034d	0f 85 5e 05 00
	00		 jne	 $LN18@HWR_DrawMD

; 1151 : 	{
; 1152 : 		FBITFIELD blend = 0;

  00353	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _blend$15[ebp], 0

; 1153 : 		GLPatch_t *oldgpatch = gpatch;

  0035d	8b 45 f8	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00360	89 85 60 ff ff
	ff		 mov	 DWORD PTR _oldgpatch$14[ebp], eax

; 1154 : 		INT32 *buff;
; 1155 : 		UINT32 durs = spr->mobj->state->tics;

  00366	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00369	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0036c	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  0036f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00372	89 85 58 ff ff
	ff		 mov	 DWORD PTR _durs$12[ebp], eax

; 1156 : 		UINT32 tics = spr->mobj->tics;

  00378	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0037b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0037e	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00381	89 95 54 ff ff
	ff		 mov	 DWORD PTR _tics$11[ebp], edx

; 1157 : 		md2_frame_t *curr, *next = NULL;

  00387	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _next$9[ebp], 0

; 1158 : 		const UINT8 flip = (UINT8)((spr->mobj->eflags & MFE_VERTICALFLIP) == MFE_VERTICALFLIP);

  00391	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00394	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00397	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0039d	83 e2 20	 and	 edx, 32			; 00000020H
  003a0	74 09		 je	 SHORT $LN45@HWR_DrawMD
  003a2	c6 85 eb fe ff
	ff 01		 mov	 BYTE PTR tv246[ebp], 1
  003a9	eb 07		 jmp	 SHORT $LN46@HWR_DrawMD
$LN45@HWR_DrawMD:
  003ab	c6 85 eb fe ff
	ff 00		 mov	 BYTE PTR tv246[ebp], 0
$LN46@HWR_DrawMD:
  003b2	8a 85 eb fe ff
	ff		 mov	 al, BYTE PTR tv246[ebp]
  003b8	88 85 4b ff ff
	ff		 mov	 BYTE PTR _flip$8[ebp], al

; 1159 : 
; 1160 : 		spritedef_t *sprdef;
; 1161 : 		spriteframe_t *sprframe;
; 1162 : 
; 1163 : 		if (spr->mobj->flags2 & MF2_SHADOW)

  003be	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  003c1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  003c4	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  003ca	81 e2 00 00 00
	01		 and	 edx, 16777216		; 01000000H
  003d0	74 10		 je	 SHORT $LN20@HWR_DrawMD

; 1164 : 		{
; 1165 : 			Surf.FlatColor.s.alpha = 0x40;

  003d2	c6 45 f7 40	 mov	 BYTE PTR _Surf$[ebp+7], 64 ; 00000040H

; 1166 : 			blend = PF_Translucent;

  003d6	c7 85 64 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _blend$15[ebp], 2

; 1167 : 		}

  003e0	eb 45		 jmp	 SHORT $LN23@HWR_DrawMD
$LN20@HWR_DrawMD:

; 1168 : 		else if (spr->mobj->frame & FF_TRANSMASK)

  003e2	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  003e5	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  003e8	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  003eb	81 e2 00 00 0f
	00		 and	 edx, 983040		; 000f0000H
  003f1	74 26		 je	 SHORT $LN22@HWR_DrawMD

; 1169 : 			blend = HWR_TranstableToAlpha((spr->mobj->frame & FF_TRANSMASK)>>FF_TRANSSHIFT, &Surf);

  003f3	8d 45 f0	 lea	 eax, DWORD PTR _Surf$[ebp]
  003f6	50		 push	 eax
  003f7	8b 4d 08	 mov	 ecx, DWORD PTR _spr$[ebp]
  003fa	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  003fd	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00400	25 00 00 0f 00	 and	 eax, 983040		; 000f0000H
  00405	c1 e8 10	 shr	 eax, 16			; 00000010H
  00408	50		 push	 eax
  00409	e8 00 00 00 00	 call	 _HWR_TranstableToAlpha
  0040e	83 c4 08	 add	 esp, 8
  00411	89 85 64 ff ff
	ff		 mov	 DWORD PTR _blend$15[ebp], eax
  00417	eb 0e		 jmp	 SHORT $LN23@HWR_DrawMD
$LN22@HWR_DrawMD:

; 1170 : 		else
; 1171 : 		{
; 1172 : 			Surf.FlatColor.s.alpha = 0xFF;

  00419	c6 45 f7 ff	 mov	 BYTE PTR _Surf$[ebp+7], 255 ; 000000ffH

; 1173 : 			blend = PF_Translucent;

  0041d	c7 85 64 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _blend$15[ebp], 2
$LN23@HWR_DrawMD:

; 1174 : 		}
; 1175 : 
; 1176 : 		// dont forget to enabled the depth test because we can't do this like
; 1177 : 		// before: polygons models are not sorted
; 1178 : 
; 1179 : 		// 1. load model+texture if not already loaded
; 1180 : 		// 2. draw model with correct position, rotation,...
; 1181 : 		if (spr->mobj->skin)

  00427	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0042a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0042d	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  00431	74 46		 je	 SHORT $LN24@HWR_DrawMD

; 1182 : 		{
; 1183 : 			md2 = &md2_playermodels[(skin_t*)spr->mobj->skin-skins];

  00433	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00436	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00439	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  0043c	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  00441	99		 cdq
  00442	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  00447	f7 f9		 idiv	 ecx
  00449	6b d0 38	 imul	 edx, eax, 56
  0044c	81 c2 00 00 00
	00		 add	 edx, OFFSET _md2_playermodels
  00452	89 95 7c ff ff
	ff		 mov	 DWORD PTR _md2$[ebp], edx

; 1184 : 			md2->skin = (skin_t*)spr->mobj->skin-skins;

  00458	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0045b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0045e	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00461	2d 00 00 00 00	 sub	 eax, OFFSET _skins
  00466	99		 cdq
  00467	b9 ec 00 00 00	 mov	 ecx, 236		; 000000ecH
  0046c	f7 f9		 idiv	 ecx
  0046e	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _md2$[ebp]
  00474	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 1185 : 		}

  00477	eb 16		 jmp	 SHORT $LN25@HWR_DrawMD
$LN24@HWR_DrawMD:

; 1186 : 		else
; 1187 : 			md2 = &md2_models[spr->mobj->sprite];

  00479	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0047c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0047f	6b 51 28 38	 imul	 edx, DWORD PTR [ecx+40], 56
  00483	81 c2 00 00 00
	00		 add	 edx, OFFSET _md2_models
  00489	89 95 7c ff ff
	ff		 mov	 DWORD PTR _md2$[ebp], edx
$LN25@HWR_DrawMD:

; 1188 : 
; 1189 : 		if (!md2->model)

  0048f	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  00495	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00499	75 52		 jne	 SHORT $LN28@HWR_DrawMD

; 1190 : 		{
; 1191 : 			//CONS_Printf("Loading MD2... (%s)", sprnames[spr->mobj->sprite]);
; 1192 : 			sprintf(filename, "md2/%s", md2->filename);

  0049b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  004a1	50		 push	 eax
  004a2	68 00 00 00 00	 push	 OFFSET ??_C@_06CLDLKFI@md2?1?$CFs@
  004a7	8d 4d b0	 lea	 ecx, DWORD PTR _filename$[ebp]
  004aa	51		 push	 ecx
  004ab	e8 00 00 00 00	 call	 _sprintf
  004b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1193 : 			md2->model = md2_readModel(filename);

  004b3	8d 45 b0	 lea	 eax, DWORD PTR _filename$[ebp]
  004b6	50		 push	 eax
  004b7	e8 00 00 00 00	 call	 _md2_readModel
  004bc	83 c4 04	 add	 esp, 4
  004bf	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _md2$[ebp]
  004c5	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 1194 : 
; 1195 : 			if (md2->model)

  004c8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  004ce	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  004d2	74 14		 je	 SHORT $LN27@HWR_DrawMD

; 1196 : 			{
; 1197 : 				md2_printModelInfo(md2->model);

  004d4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  004da	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  004dd	51		 push	 ecx
  004de	e8 00 00 00 00	 call	 _md2_printModelInfo
  004e3	83 c4 04	 add	 esp, 4

; 1198 : 			}

  004e6	eb 05		 jmp	 SHORT $LN28@HWR_DrawMD
$LN27@HWR_DrawMD:

; 1199 : 			else
; 1200 : 			{
; 1201 : 				//CONS_Printf(" FAILED\n");
; 1202 : 				return;

  004e8	e9 c4 03 00 00	 jmp	 $LN18@HWR_DrawMD
$LN28@HWR_DrawMD:

; 1203 : 			}
; 1204 : 		}
; 1205 : 		//Hurdler: arf, I don't like that implementation at all... too much crappy
; 1206 : 		gpatch = md2->grpatch;

  004ed	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  004f3	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  004f6	89 4d f8	 mov	 DWORD PTR _gpatch$[ebp], ecx

; 1207 : 		if (!gpatch || !gpatch->mipmap.grInfo.format ||!gpatch->mipmap.downloaded)

  004f9	83 7d f8 00	 cmp	 DWORD PTR _gpatch$[ebp], 0
  004fd	74 12		 je	 SHORT $LN31@HWR_DrawMD
  004ff	8b 45 f8	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00502	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00506	74 09		 je	 SHORT $LN31@HWR_DrawMD
  00508	8b 45 f8	 mov	 eax, DWORD PTR _gpatch$[ebp]
  0050b	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0050f	75 11		 jne	 SHORT $LN29@HWR_DrawMD
$LN31@HWR_DrawMD:

; 1208 : 			md2_loadTexture(md2);

  00511	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  00517	50		 push	 eax
  00518	e8 00 00 00 00	 call	 _md2_loadTexture
  0051d	83 c4 04	 add	 esp, 4
  00520	eb 2a		 jmp	 SHORT $LN33@HWR_DrawMD
$LN29@HWR_DrawMD:

; 1209 : 		else if (gpatch->mipmap.grInfo.format)

  00522	8b 45 f8	 mov	 eax, DWORD PTR _gpatch$[ebp]
  00525	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00529	74 10		 je	 SHORT $LN32@HWR_DrawMD

; 1210 : 			HWD.pfnSetTexture(&gpatch->mipmap);

  0052b	8b 45 f8	 mov	 eax, DWORD PTR _gpatch$[ebp]
  0052e	83 c0 14	 add	 eax, 20			; 00000014H
  00531	50		 push	 eax
  00532	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  00538	90		 npad	 1
  00539	eb 11		 jmp	 SHORT $LN33@HWR_DrawMD
$LN32@HWR_DrawMD:

; 1211 : 		else
; 1212 : 			HWD.pfnSetTexture(&oldgpatch->mipmap);

  0053b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _oldgpatch$14[ebp]
  00541	83 c0 14	 add	 eax, 20			; 00000014H
  00544	50		 push	 eax
  00545	ff 15 1c 00 00
	00		 call	 DWORD PTR _hwdriver+28
  0054b	90		 npad	 1
$LN33@HWR_DrawMD:

; 1213 : 
; 1214 : 		//FIXME: this is not yet correct
; 1215 : 		frame = (spr->mobj->frame & FF_FRAMEMASK) % md2->model->header.numFrames;

  0054c	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0054f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00552	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00555	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  0055a	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _md2$[ebp]
  00560	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00563	33 d2		 xor	 edx, edx
  00565	f7 71 28	 div	 DWORD PTR [ecx+40]
  00568	89 55 ac	 mov	 DWORD PTR _frame$[ebp], edx

; 1216 : 		buff = md2->model->glCommandBuffer;

  0056b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  00571	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00574	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00577	89 95 5c ff ff
	ff		 mov	 DWORD PTR _buff$13[ebp], edx

; 1217 : 		curr = &md2->model->frames[frame];

  0057d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  00583	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00586	6b 55 ac 14	 imul	 edx, DWORD PTR _frame$[ebp], 20
  0058a	03 51 50	 add	 edx, DWORD PTR [ecx+80]
  0058d	89 95 50 ff ff
	ff		 mov	 DWORD PTR _curr$10[ebp], edx

; 1218 : 		if (cv_grmd2.value == 1
; 1219 : 		    && spr->mobj->state->nextstate != S_DISS
; 1220 : 		    && spr->mobj->state->nextstate != S_NULL
; 1221 : 			&& !(spr->mobj->player && (spr->mobj->state->nextstate == S_PLAY_TAP1 || spr->mobj->state->nextstate == S_PLAY_TAP2) && spr->mobj->state == &states[S_PLAY_STND])

  00593	83 3d 14 00 00
	00 01		 cmp	 DWORD PTR _cv_grmd2+20, 1
  0059a	0f 85 b4 00 00
	00		 jne	 $LN34@HWR_DrawMD
  005a0	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  005a3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005a6	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  005a9	81 7a 18 4f 06
	00 00		 cmp	 DWORD PTR [edx+24], 1615 ; 0000064fH
  005b0	0f 84 9e 00 00
	00		 je	 $LN34@HWR_DrawMD
  005b6	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  005b9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005bc	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  005bf	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  005c3	0f 84 8b 00 00
	00		 je	 $LN34@HWR_DrawMD
  005c9	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  005cc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005cf	83 b9 a4 00 00
	00 00		 cmp	 DWORD PTR [ecx+164], 0
  005d6	74 37		 je	 SHORT $LN35@HWR_DrawMD
  005d8	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  005db	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005de	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  005e1	83 7a 18 02	 cmp	 DWORD PTR [edx+24], 2
  005e5	74 0f		 je	 SHORT $LN36@HWR_DrawMD
  005e7	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  005ea	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005ed	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  005f0	83 7a 18 03	 cmp	 DWORD PTR [edx+24], 3
  005f4	75 19		 jne	 SHORT $LN35@HWR_DrawMD
$LN36@HWR_DrawMD:
  005f6	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  005f9	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005fc	ba 1c 00 00 00	 mov	 edx, 28			; 0000001cH
  00601	c1 e2 00	 shl	 edx, 0
  00604	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  0060a	39 51 5c	 cmp	 DWORD PTR [ecx+92], edx
  0060d	74 45		 je	 SHORT $LN34@HWR_DrawMD
$LN35@HWR_DrawMD:

; 1222 : 			)
; 1223 : 		{
; 1224 : 			const INT32 nextframe = (states[spr->mobj->state->nextstate].frame & FF_FRAMEMASK) % md2->model->header.numFrames;

  0060f	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00612	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00615	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00618	6b 42 18 1c	 imul	 eax, DWORD PTR [edx+24], 28
  0061c	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR _states[eax+4]
  00622	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00627	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _md2$[ebp]
  0062d	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00630	33 d2		 xor	 edx, edx
  00632	f7 71 28	 div	 DWORD PTR [ecx+40]
  00635	89 95 3c ff ff
	ff		 mov	 DWORD PTR _nextframe$5[ebp], edx

; 1225 : 			next = &md2->model->frames[nextframe];

  0063b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  00641	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00644	6b 95 3c ff ff
	ff 14		 imul	 edx, DWORD PTR _nextframe$5[ebp], 20
  0064b	03 51 50	 add	 edx, DWORD PTR [ecx+80]
  0064e	89 95 4c ff ff
	ff		 mov	 DWORD PTR _next$9[ebp], edx
$LN34@HWR_DrawMD:

; 1226 : 		}
; 1227 : 
; 1228 : 		//Hurdler: it seems there is still a small problem with mobj angle
; 1229 : 		p.x = FIXED_TO_FLOAT(spr->mobj->x);

  00654	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00657	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0065a	f3 0f 2a 41 10	 cvtsi2ss xmm0, DWORD PTR [ecx+16]
  0065f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  00667	f3 0f 11 45 80	 movss	 DWORD PTR _p$[ebp], xmm0

; 1230 : 		p.y = FIXED_TO_FLOAT(spr->mobj->y)+md2->offset;

  0066c	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0066f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00672	f3 0f 2a 41 14	 cvtsi2ss xmm0, DWORD PTR [ecx+20]
  00677	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0067f	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _md2$[ebp]
  00685	f3 0f 58 42 24	 addss	 xmm0, DWORD PTR [edx+36]
  0068a	f3 0f 11 45 84	 movss	 DWORD PTR _p$[ebp+4], xmm0

; 1231 : 
; 1232 : 		if (spr->mobj->eflags & MFE_VERTICALFLIP)

  0068f	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00692	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00695	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0069b	83 e2 20	 and	 edx, 32			; 00000020H
  0069e	74 25		 je	 SHORT $LN37@HWR_DrawMD

; 1233 : 			p.z = FIXED_TO_FLOAT(spr->mobj->z + spr->mobj->height);

  006a0	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  006a3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  006a6	8b 55 08	 mov	 edx, DWORD PTR _spr$[ebp]
  006a9	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  006ac	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  006af	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  006b2	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  006b6	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  006be	f3 0f 11 45 88	 movss	 DWORD PTR _p$[ebp+8], xmm0
  006c3	eb 18		 jmp	 SHORT $LN38@HWR_DrawMD
$LN37@HWR_DrawMD:

; 1234 : 		else
; 1235 : 			p.z = FIXED_TO_FLOAT(spr->mobj->z);

  006c5	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  006c8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  006cb	f3 0f 2a 41 18	 cvtsi2ss xmm0, DWORD PTR [ecx+24]
  006d0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  006d8	f3 0f 11 45 88	 movss	 DWORD PTR _p$[ebp+8], xmm0
$LN38@HWR_DrawMD:

; 1236 : 
; 1237 : 		if (spr->mobj->skin)

  006dd	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  006e0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  006e3	83 79 64 00	 cmp	 DWORD PTR [ecx+100], 0
  006e7	74 14		 je	 SHORT $LN39@HWR_DrawMD

; 1238 : 			sprdef = &((skin_t *)spr->mobj->skin)->spritedef;

  006e9	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  006ec	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  006ef	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  006f2	83 c2 14	 add	 edx, 20			; 00000014H
  006f5	89 95 44 ff ff
	ff		 mov	 DWORD PTR _sprdef$7[ebp], edx
  006fb	eb 17		 jmp	 SHORT $LN40@HWR_DrawMD
$LN39@HWR_DrawMD:

; 1239 : 		else
; 1240 : 			sprdef = &sprites[spr->mobj->sprite];

  006fd	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00700	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00703	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00706	a1 00 00 00 00	 mov	 eax, DWORD PTR _sprites
  0070b	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  0070e	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _sprdef$7[ebp], ecx
$LN40@HWR_DrawMD:

; 1241 : 
; 1242 : 		sprframe = &sprdef->spriteframes[spr->mobj->frame & FF_FRAMEMASK];

  00714	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00717	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0071a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0071d	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00723	6b c2 4c	 imul	 eax, edx, 76
  00726	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _sprdef$7[ebp]
  0072c	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  0072f	89 85 40 ff ff
	ff		 mov	 DWORD PTR _sprframe$6[ebp], eax

; 1243 : 
; 1244 : 		if (sprframe->rotate)

  00735	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _sprframe$6[ebp]
  0073b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0073e	85 c9		 test	 ecx, ecx
  00740	74 2f		 je	 SHORT $LN41@HWR_DrawMD

; 1245 : 		{
; 1246 : 			const fixed_t anglef = AngleFixed(spr->mobj->angle);

  00742	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00745	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00748	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0074b	52		 push	 edx
  0074c	e8 00 00 00 00	 call	 _AngleFixed
  00751	83 c4 04	 add	 esp, 4
  00754	89 85 38 ff ff
	ff		 mov	 DWORD PTR _anglef$4[ebp], eax

; 1247 : 			p.angley = FIXED_TO_FLOAT(anglef);

  0075a	f3 0f 2a 85 38
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _anglef$4[ebp]
  00762	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  0076a	f3 0f 11 45 90	 movss	 DWORD PTR _p$[ebp+16], xmm0

; 1248 : 		}

  0076f	eb 45		 jmp	 SHORT $LN42@HWR_DrawMD
$LN41@HWR_DrawMD:

; 1249 : 		else
; 1250 : 		{
; 1251 : 			const fixed_t anglef = AngleFixed((R_PointToAngle(spr->mobj->x, spr->mobj->y))-ANGLE_180);

  00771	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00774	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00777	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0077a	52		 push	 edx
  0077b	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0077e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00781	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00784	52		 push	 edx
  00785	e8 00 00 00 00	 call	 _R_PointToAngle
  0078a	83 c4 08	 add	 esp, 8
  0078d	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  00792	50		 push	 eax
  00793	e8 00 00 00 00	 call	 _AngleFixed
  00798	83 c4 04	 add	 esp, 4
  0079b	89 85 34 ff ff
	ff		 mov	 DWORD PTR _anglef$3[ebp], eax

; 1252 : 			p.angley = FIXED_TO_FLOAT(anglef);

  007a1	f3 0f 2a 85 34
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _anglef$3[ebp]
  007a9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  007b1	f3 0f 11 45 90	 movss	 DWORD PTR _p$[ebp+16], xmm0
$LN42@HWR_DrawMD:

; 1253 : 		}
; 1254 : 		p.anglex = 0.0f;

  007b6	0f 57 c0	 xorps	 xmm0, xmm0
  007b9	f3 0f 11 45 8c	 movss	 DWORD PTR _p$[ebp+12], xmm0

; 1255 : 
; 1256 : 		color[0] = Surf.FlatColor.s.red;

  007be	b8 01 00 00 00	 mov	 eax, 1
  007c3	6b c8 00	 imul	 ecx, eax, 0
  007c6	8a 55 f4	 mov	 dl, BYTE PTR _Surf$[ebp+4]
  007c9	88 94 0d 78 ff
	ff ff		 mov	 BYTE PTR _color$[ebp+ecx], dl

; 1257 : 		color[1] = Surf.FlatColor.s.green;

  007d0	b8 01 00 00 00	 mov	 eax, 1
  007d5	c1 e0 00	 shl	 eax, 0
  007d8	8a 4d f5	 mov	 cl, BYTE PTR _Surf$[ebp+5]
  007db	88 8c 05 78 ff
	ff ff		 mov	 BYTE PTR _color$[ebp+eax], cl

; 1258 : 		color[2] = Surf.FlatColor.s.blue;

  007e2	b8 01 00 00 00	 mov	 eax, 1
  007e7	d1 e0		 shl	 eax, 1
  007e9	8a 4d f6	 mov	 cl, BYTE PTR _Surf$[ebp+6]
  007ec	88 8c 05 78 ff
	ff ff		 mov	 BYTE PTR _color$[ebp+eax], cl

; 1259 : 		color[3] = Surf.FlatColor.s.alpha;

  007f3	b8 01 00 00 00	 mov	 eax, 1
  007f8	6b c8 03	 imul	 ecx, eax, 3
  007fb	8a 55 f7	 mov	 dl, BYTE PTR _Surf$[ebp+7]
  007fe	88 94 0d 78 ff
	ff ff		 mov	 BYTE PTR _color$[ebp+ecx], dl

; 1260 : 
; 1261 : 		// SRB2CBTODO: MD2 scaling support
; 1262 : 		float finalscale = md2->scale;

  00805	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  0080b	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  00810	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _finalscale$2[ebp], xmm0

; 1263 : 
; 1264 : 		if (spr->mobj->scale != 100)

  00818	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  0081b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0081e	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  00825	83 fa 64	 cmp	 edx, 100		; 00000064H
  00828	74 3c		 je	 SHORT $LN43@HWR_DrawMD

; 1265 : 		{
; 1266 : 			float normscale = md2->scale;

  0082a	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _md2$[ebp]
  00830	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  00835	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _normscale$1[ebp], xmm0

; 1267 : 			finalscale = (float)(normscale*(((float)spr->mobj->scale)/100.0f));

  0083d	8b 45 08	 mov	 eax, DWORD PTR _spr$[ebp]
  00840	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00843	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  0084a	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0084e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00856	f3 0f 59 85 2c
	ff ff ff	 mulss	 xmm0, DWORD PTR _normscale$1[ebp]
  0085e	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _finalscale$2[ebp], xmm0
$LN43@HWR_DrawMD:

; 1268 : 		}
; 1269 : 
; 1270 : 		HWD.pfnDrawMD2i(buff, curr, durs, tics, next, &p, finalscale, flip, color);

  00866	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _color$[ebp]
  0086c	50		 push	 eax
  0086d	0f b6 8d 4b ff
	ff ff		 movzx	 ecx, BYTE PTR _flip$8[ebp]
  00874	51		 push	 ecx
  00875	51		 push	 ecx
  00876	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _finalscale$2[ebp]
  0087e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00883	8d 55 80	 lea	 edx, DWORD PTR _p$[ebp]
  00886	52		 push	 edx
  00887	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _next$9[ebp]
  0088d	50		 push	 eax
  0088e	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _tics$11[ebp]
  00894	51		 push	 ecx
  00895	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _durs$12[ebp]
  0089b	52		 push	 edx
  0089c	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _curr$10[ebp]
  008a2	50		 push	 eax
  008a3	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _buff$13[ebp]
  008a9	51		 push	 ecx
  008aa	ff 15 34 00 00
	00		 call	 DWORD PTR _hwdriver+52
  008b0	90		 npad	 1
$LN18@HWR_DrawMD:

; 1271 : 
; 1272 : 	}
; 1273 : }

  008b1	5f		 pop	 edi
  008b2	5e		 pop	 esi
  008b3	5b		 pop	 ebx
  008b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008b7	33 cd		 xor	 ecx, ebp
  008b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008be	8b e5		 mov	 esp, ebp
  008c0	5d		 pop	 ebp
  008c1	c3		 ret	 0
_HWR_DrawMD2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\hardware\hw_md2.c
;	COMDAT _HWR_InitMD2
_TEXT	SEGMENT
_md2$ = -80						; size = 4
_offset$ = -76						; size = 4
_scale$ = -72						; size = 4
_filename$ = -68					; size = 32
_name$ = -36						; size = 18
_f$ = -16						; size = 4
_s$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_HWR_InitMD2 PROC					; COMDAT

; 883  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 884  : 	size_t i;
; 885  : 	INT32 s;
; 886  : 	FILE *f;
; 887  : 	char name[18], filename[32];
; 888  : 	float scale, offset;
; 889  : 
; 890  : 	CONS_Printf("InitMD2()...\n");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MLLNEMJJ@InitMD2?$CI?$CJ?4?4?4?6@
  0001b	e8 00 00 00 00	 call	 _CONS_Printf
  00020	83 c4 04	 add	 esp, 4

; 891  : 	for (s = 0; s < MAXSKINS; s++)

  00023	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  0002a	eb 09		 jmp	 SHORT $LN4@HWR_InitMD
$LN2@HWR_InitMD:
  0002c	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  0002f	83 c0 01	 add	 eax, 1
  00032	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
$LN4@HWR_InitMD:
  00035	83 7d f4 20	 cmp	 DWORD PTR _s$[ebp], 32	; 00000020H
  00039	7d 4e		 jge	 SHORT $LN3@HWR_InitMD

; 892  : 	{
; 893  : 		md2_playermodels[s].scale = -1.0f;

  0003b	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  0003f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00047	f3 0f 11 80 20
	00 00 00	 movss	 DWORD PTR _md2_playermodels[eax+32], xmm0

; 894  : 		md2_playermodels[s].model = NULL;

  0004f	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  00053	c7 80 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+40], 0

; 895  : 		md2_playermodels[s].grpatch = NULL;

  0005d	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  00061	c7 80 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+44], 0

; 896  : 		md2_playermodels[s].skin = -1;

  0006b	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  0006f	c7 80 34 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _md2_playermodels[eax+52], -1

; 897  : 		md2_playermodels[s].notfound = true;

  00079	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  0007d	c7 80 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+48], 1

; 898  : 	}

  00087	eb a3		 jmp	 SHORT $LN2@HWR_InitMD
$LN3@HWR_InitMD:

; 899  : 	for (i = 0; i < NUMSPRITES; i++)

  00089	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00090	eb 09		 jmp	 SHORT $LN7@HWR_InitMD
$LN5@HWR_InitMD:
  00092	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HWR_InitMD:
  0009b	81 7d f8 73 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 371	; 00000173H
  000a2	73 4e		 jae	 SHORT $LN6@HWR_InitMD

; 900  : 	{
; 901  : 		md2_models[i].scale = -1.0f;

  000a4	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  000a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000b0	f3 0f 11 80 20
	00 00 00	 movss	 DWORD PTR _md2_models[eax+32], xmm0

; 902  : 		md2_models[i].model = NULL;

  000b8	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  000bc	c7 80 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_models[eax+40], 0

; 903  : 		md2_models[i].grpatch = NULL;

  000c6	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  000ca	c7 80 2c 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_models[eax+44], 0

; 904  : 		md2_models[i].skin = -1;

  000d4	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  000d8	c7 80 34 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _md2_models[eax+52], -1

; 905  : 		md2_models[i].notfound = true;

  000e2	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  000e6	c7 80 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_models[eax+48], 1

; 906  : 	}

  000f0	eb a0		 jmp	 SHORT $LN5@HWR_InitMD
$LN6@HWR_InitMD:

; 907  : 	// read the md2.dat file
; 908  : 
; 909  : 	f = fopen("md2.dat", "rt");

  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_02BMJICGCB@rt@
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_07CPILLHHI@md2?4dat@
  000fc	e8 00 00 00 00	 call	 _fopen
  00101	83 c4 08	 add	 esp, 8
  00104	89 45 f0	 mov	 DWORD PTR _f$[ebp], eax

; 910  : 	if (!f)

  00107	83 7d f0 00	 cmp	 DWORD PTR _f$[ebp], 0
  0010b	75 12		 jne	 SHORT $LN16@HWR_InitMD

; 911  : 	{
; 912  : 		CONS_Printf("Error while loading md2.dat\n");

  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MJFIHCEA@Error?5while?5loading?5md2?4dat?6@
  00112	e8 00 00 00 00	 call	 _CONS_Printf
  00117	83 c4 04	 add	 esp, 4

; 913  : 		return;

  0011a	e9 d2 01 00 00	 jmp	 $LN1@HWR_InitMD
$LN16@HWR_InitMD:

; 914  : 	}
; 915  : 
; 916  : 	md2_t *md2;
; 917  : 
; 918  : 	while (fscanf(f, "%19s %31s %f %f", name, filename, &scale, &offset) == 4)

  0011f	8d 45 b4	 lea	 eax, DWORD PTR _offset$[ebp]
  00122	50		 push	 eax
  00123	8d 4d b8	 lea	 ecx, DWORD PTR _scale$[ebp]
  00126	51		 push	 ecx
  00127	8d 55 bc	 lea	 edx, DWORD PTR _filename$[ebp]
  0012a	52		 push	 edx
  0012b	8d 45 dc	 lea	 eax, DWORD PTR _name$[ebp]
  0012e	50		 push	 eax
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FNNGIIBC@?$CF19s?5?$CF31s?5?$CFf?5?$CFf@
  00134	8b 4d f0	 mov	 ecx, DWORD PTR _f$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _fscanf
  0013d	83 c4 18	 add	 esp, 24			; 00000018H
  00140	83 f8 04	 cmp	 eax, 4
  00143	0f 85 9c 01 00
	00		 jne	 $LN9@HWR_InitMD

; 919  : 	{
; 920  : 		for (i = 0; i < NUMSPRITES; i++)

  00149	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00150	eb 09		 jmp	 SHORT $LN12@HWR_InitMD
$LN10@HWR_InitMD:
  00152	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00155	83 c0 01	 add	 eax, 1
  00158	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN12@HWR_InitMD:
  0015b	81 7d f8 73 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 371	; 00000173H
  00162	0f 83 b3 00 00
	00		 jae	 $LN11@HWR_InitMD

; 921  : 		{
; 922  : 			if (stricmp(name, sprnames[i]) == 0)

  00168	6b 45 f8 05	 imul	 eax, DWORD PTR _i$[ebp], 5
  0016c	05 00 00 00 00	 add	 eax, OFFSET _sprnames
  00171	50		 push	 eax
  00172	8d 4d dc	 lea	 ecx, DWORD PTR _name$[ebp]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 _stricmp
  0017b	83 c4 08	 add	 esp, 8
  0017e	85 c0		 test	 eax, eax
  00180	75 6c		 jne	 SHORT $LN17@HWR_InitMD

; 923  : 			{
; 924  : 				if (stricmp(name, "PLAY") == 0)

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_04MKCNCBEG@PLAY@
  00187	8d 45 dc	 lea	 eax, DWORD PTR _name$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _stricmp
  00190	83 c4 08	 add	 esp, 8
  00193	85 c0		 test	 eax, eax
  00195	75 02		 jne	 SHORT $LN18@HWR_InitMD

; 925  : 					continue;

  00197	eb b9		 jmp	 SHORT $LN10@HWR_InitMD
$LN18@HWR_InitMD:

; 926  : 
; 927  : 				//CONS_Printf("  Found: %s %s %f %f\n", name, filename, scale, offset);
; 928  : 				md2_models[i].scale = scale;

  00199	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0019d	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _scale$[ebp]
  001a2	f3 0f 11 80 20
	00 00 00	 movss	 DWORD PTR _md2_models[eax+32], xmm0

; 929  : 				md2_models[i].offset = offset;

  001aa	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  001ae	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _offset$[ebp]
  001b3	f3 0f 11 80 24
	00 00 00	 movss	 DWORD PTR _md2_models[eax+36], xmm0

; 930  : 				md2_models[i].notfound = false;

  001bb	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  001bf	c7 80 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_models[eax+48], 0

; 931  : 				strcpy(md2_models[i].filename, filename);

  001c9	8d 45 bc	 lea	 eax, DWORD PTR _filename$[ebp]
  001cc	50		 push	 eax
  001cd	6b 4d f8 38	 imul	 ecx, DWORD PTR _i$[ebp], 56
  001d1	81 c1 00 00 00
	00		 add	 ecx, OFFSET _md2_models
  001d7	51		 push	 ecx
  001d8	e8 00 00 00 00	 call	 _strcpy
  001dd	83 c4 08	 add	 esp, 8

; 932  : 				md2 = &md2_models[i];

  001e0	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  001e4	05 00 00 00 00	 add	 eax, OFFSET _md2_models
  001e9	89 45 b0	 mov	 DWORD PTR _md2$[ebp], eax

; 933  : 				break;

  001ec	eb 2d		 jmp	 SHORT $LN11@HWR_InitMD
$LN17@HWR_InitMD:

; 934  : 			}
; 935  : 			if (i == NUMSPRITES)

  001ee	81 7d f8 73 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 371	; 00000173H
  001f5	75 1f		 jne	 SHORT $LN19@HWR_InitMD

; 936  : 			{
; 937  : 				CONS_Printf("MD2 for sprite %s not found\n", name);

  001f7	8d 45 dc	 lea	 eax, DWORD PTR _name$[ebp]
  001fa	50		 push	 eax
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MGIHOKNP@MD2?5for?5sprite?5?$CFs?5not?5found?6@
  00200	e8 00 00 00 00	 call	 _CONS_Printf
  00205	83 c4 08	 add	 esp, 8

; 938  : 				md2_models[i].notfound = true;

  00208	6b 45 f8 38	 imul	 eax, DWORD PTR _i$[ebp], 56
  0020c	c7 80 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_models[eax+48], 1
$LN19@HWR_InitMD:

; 939  : 			}
; 940  : 		}

  00216	e9 37 ff ff ff	 jmp	 $LN10@HWR_InitMD
$LN11@HWR_InitMD:

; 941  : 
; 942  : 		for (s = 0; s < MAXSKINS; s++)

  0021b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  00222	eb 09		 jmp	 SHORT $LN15@HWR_InitMD
$LN13@HWR_InitMD:
  00224	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00227	83 c0 01	 add	 eax, 1
  0022a	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax
$LN15@HWR_InitMD:
  0022d	83 7d f4 20	 cmp	 DWORD PTR _s$[ebp], 32	; 00000020H
  00231	0f 8d a9 00 00
	00		 jge	 $LN14@HWR_InitMD

; 943  : 		{
; 944  : 			if (stricmp(name, skins[s].name) == 0)

  00237	69 45 f4 ec 00
	00 00		 imul	 eax, DWORD PTR _s$[ebp], 236
  0023e	05 00 00 00 00	 add	 eax, OFFSET _skins
  00243	50		 push	 eax
  00244	8d 4d dc	 lea	 ecx, DWORD PTR _name$[ebp]
  00247	51		 push	 ecx
  00248	e8 00 00 00 00	 call	 _stricmp
  0024d	83 c4 08	 add	 esp, 8
  00250	85 c0		 test	 eax, eax
  00252	75 62		 jne	 SHORT $LN20@HWR_InitMD

; 945  : 			{
; 946  : 				//CONS_Printf("  Found: %s %s %f %f\n", name, filename, scale, offset);
; 947  : 				md2_playermodels[s].skin = s;

  00254	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  00258	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  0025b	89 88 34 00 00
	00		 mov	 DWORD PTR _md2_playermodels[eax+52], ecx

; 948  : 				md2_playermodels[s].scale = scale;

  00261	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  00265	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0026a	f3 0f 11 80 20
	00 00 00	 movss	 DWORD PTR _md2_playermodels[eax+32], xmm0

; 949  : 				md2_playermodels[s].offset = offset;

  00272	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  00276	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _offset$[ebp]
  0027b	f3 0f 11 80 24
	00 00 00	 movss	 DWORD PTR _md2_playermodels[eax+36], xmm0

; 950  : 				md2_playermodels[s].notfound = false;

  00283	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  00287	c7 80 30 00 00
	00 00 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+48], 0

; 951  : 				strcpy(md2_playermodels[s].filename, filename);

  00291	8d 45 bc	 lea	 eax, DWORD PTR _filename$[ebp]
  00294	50		 push	 eax
  00295	6b 4d f4 38	 imul	 ecx, DWORD PTR _s$[ebp], 56
  00299	81 c1 00 00 00
	00		 add	 ecx, OFFSET _md2_playermodels
  0029f	51		 push	 ecx
  002a0	e8 00 00 00 00	 call	 _strcpy
  002a5	83 c4 08	 add	 esp, 8

; 952  : 				md2 = &md2_playermodels[s];

  002a8	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  002ac	05 00 00 00 00	 add	 eax, OFFSET _md2_playermodels
  002b1	89 45 b0	 mov	 DWORD PTR _md2$[ebp], eax

; 953  : 				break;

  002b4	eb 2a		 jmp	 SHORT $LN14@HWR_InitMD
$LN20@HWR_InitMD:

; 954  : 			}
; 955  : 			if (s == MAXSKINS-1)

  002b6	83 7d f4 1f	 cmp	 DWORD PTR _s$[ebp], 31	; 0000001fH
  002ba	75 1f		 jne	 SHORT $LN21@HWR_InitMD

; 956  : 			{
; 957  : 				CONS_Printf("MD2 for player skin %s not found\n", name);

  002bc	8d 45 dc	 lea	 eax, DWORD PTR _name$[ebp]
  002bf	50		 push	 eax
  002c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KBIOMPJ@MD2?5for?5player?5skin?5?$CFs?5not?5foun@
  002c5	e8 00 00 00 00	 call	 _CONS_Printf
  002ca	83 c4 08	 add	 esp, 8

; 958  : 				md2_playermodels[s].notfound = true;

  002cd	6b 45 f4 38	 imul	 eax, DWORD PTR _s$[ebp], 56
  002d1	c7 80 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR _md2_playermodels[eax+48], 1
$LN21@HWR_InitMD:

; 959  : 			}
; 960  : 		}

  002db	e9 44 ff ff ff	 jmp	 $LN13@HWR_InitMD
$LN14@HWR_InitMD:

; 961  : 
; 962  : 	}

  002e0	e9 3a fe ff ff	 jmp	 $LN16@HWR_InitMD
$LN9@HWR_InitMD:

; 963  : 	fclose(f);

  002e5	8b 45 f0	 mov	 eax, DWORD PTR _f$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _fclose
  002ee	83 c4 04	 add	 esp, 4
$LN1@HWR_InitMD:

; 964  : }

  002f1	5f		 pop	 edi
  002f2	5e		 pop	 esi
  002f3	5b		 pop	 ebx
  002f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f7	33 cd		 xor	 ecx, ebp
  002f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fe	8b e5		 mov	 esp, ebp
  00300	5d		 pop	 ebp
  00301	c3		 ret	 0
_HWR_InitMD2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fscanf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fscanf	PROC						; COMDAT

; 1206 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1207 :         int _Result;
; 1208 :         va_list _ArgList;
; 1209 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1210 :         _Result = _vfscanf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfscanf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1211 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1212 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1213 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfscanf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfscanf_l PROC					; COMDAT

; 1064 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1065 :         return __stdio_common_vfscanf(

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfscanf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 1066 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1067 :             _Stream, _Format, _Locale, _ArgList);
; 1068 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 100  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
