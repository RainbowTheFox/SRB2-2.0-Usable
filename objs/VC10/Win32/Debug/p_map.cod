; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Downloads\SRB2-Public-master\objs\VC10\Win32\Debug\p_map.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_sector_list
PUBLIC	_precipsector_list
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
COMM	_tmbbox:DWORD:04H
COMM	_floatok:DWORD
COMM	_tmfloorz:DWORD
COMM	_tmceilingz:DWORD
COMM	_tmsectorceilingz:DWORD
COMM	_tmsprung:DWORD
COMM	_tmfloorthing:DWORD
COMM	_tmthing:DWORD
COMM	_ceilingline:DWORD
COMM	_blockingline:DWORD
_DATA	ENDS
_BSS	SEGMENT
_sector_list DD	01H DUP (?)
_precipsector_list DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_linetarget:DWORD
COMM	_attackrange:DWORD
COMM	_topslope:DWORD
COMM	_bottomslope:DWORD
_DATA	ENDS
CONST	SEGMENT
_hoopblockdist DD 0180000H
_hoophalfheight DD 01c0000H
CONST	ENDS
PUBLIC	_P_CreatePrecipSecNodeList
PUBLIC	_P_SceneryTryMove
PUBLIC	_P_TryCameraMove
PUBLIC	_P_SlideCameraMove
PUBLIC	_P_MapStart
PUBLIC	_P_MapEnd
PUBLIC	_P_CheckPosition
PUBLIC	_P_CheckCameraPosition
PUBLIC	_P_TryMove
PUBLIC	_P_TeleportMove
PUBLIC	_P_SlideMove
PUBLIC	_P_BounceMove
PUBLIC	_P_CheckHoopPosition
PUBLIC	_P_CheckSector
PUBLIC	_P_DelSeclist
PUBLIC	_P_DelPrecipSeclist
PUBLIC	_P_CreateSecNodeList
PUBLIC	_P_Initsecnode
PUBLIC	_P_AimLineAttack
PUBLIC	_P_RadiusAttack
PUBLIC	_P_FloorzAtPos
PUBLIC	_PIT_PushableMoved
PUBLIC	_P_CheckOnmobj
PUBLIC	??_C@_0BJ@MDPBEIDE@P_MapStart?3?5tmthing?5set?$CB@ ; `string'
EXTRN	_abs:PROC
EXTRN	_I_Error:PROC
EXTRN	_FixedMul:PROC
EXTRN	_FixedDiv2:PROC
EXTRN	_P_SetTarget:PROC
EXTRN	_P_PointInsidePolyobj:PROC
EXTRN	_P_BBoxInsidePolyobj:PROC
EXTRN	_P_PathTraverse:PROC
EXTRN	_P_AproxDistance:PROC
EXTRN	_P_PointOnLineSide:PROC
EXTRN	_P_CameraLineOpening:PROC
EXTRN	_P_BoxOnLineSide:PROC
EXTRN	_P_LineOpening:PROC
EXTRN	_P_BlockLinesIterator:PROC
EXTRN	_P_BlockThingsIterator:PROC
EXTRN	_P_ResetPlayer:PROC
EXTRN	_P_IsObjectOnGround:PROC
EXTRN	_P_ResetScore:PROC
EXTRN	_P_ReturnThrustX:PROC
EXTRN	_P_ReturnThrustY:PROC
EXTRN	_P_InstaThrustEvenIn2D:PROC
EXTRN	_P_RecalcPrecipInSector:PROC
EXTRN	_P_SetPlayerMobjState:PROC
EXTRN	_P_SetMobjState:PROC
EXTRN	_P_UnsetThingPosition:PROC
EXTRN	_P_SetThingPosition:PROC
EXTRN	_P_CheckSight:PROC
EXTRN	_P_DamageMobj:PROC
EXTRN	_P_TouchSpecialThing:PROC
EXTRN	_P_PlayerTouchingSectorSpecial:PROC
EXTRN	_P_ProcessSpecialSector:PROC
EXTRN	_T_StartCrumble:PROC
EXTRN	_P_Thrust:PROC
EXTRN	_P_CheckGravity:PROC
EXTRN	_R_PointToAngle2:PROC
EXTRN	_R_PointInSubsector:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_finesine:BYTE
EXTRN	_finecosine:DWORD
EXTRN	_finetangent:BYTE
EXTRN	_states:BYTE
EXTRN	_maptol:WORD
EXTRN	_netgame:DWORD
EXTRN	_gametype:WORD
EXTRN	_splitscreen:DWORD
EXTRN	_consoleplayer:DWORD
EXTRN	_displayplayer:DWORD
EXTRN	_secondarydisplayplayer:DWORD
EXTRN	_cv_tagtype:BYTE
EXTRN	_cv_touchtag:BYTE
EXTRN	_cv_matchtype:BYTE
EXTRN	_seenplayer:DWORD
EXTRN	_players:BYTE
EXTRN	_playeringame:BYTE
EXTRN	_localangle:DWORD
EXTRN	_localangle2:DWORD
EXTRN	_polyblocklinks:DWORD
EXTRN	_opentop:DWORD
EXTRN	_openbottom:DWORD
EXTRN	_openrange:DWORD
EXTRN	_lowfloor:DWORD
EXTRN	_thinkercap:BYTE
EXTRN	_camera:BYTE
EXTRN	_camera2:BYTE
EXTRN	_bmapwidth:DWORD
EXTRN	_bmapheight:DWORD
EXTRN	_bmaporgx:DWORD
EXTRN	_bmaporgy:DWORD
EXTRN	_sectors:DWORD
EXTRN	_lines:DWORD
EXTRN	_validcount:DWORD
EXTRN	_cv_chasecam:BYTE
EXTRN	_cv_chasecam2:BYTE
EXTRN	_cv_tailspickup:BYTE
EXTRN	_skyflatnum:DWORD
_BSS	SEGMENT
_tmflags DD	01H DUP (?)
_tmx	DD	01H DUP (?)
_tmy	DD	01H DUP (?)
_tmprecipthing DD 01H DUP (?)
_preciptmx DD	01H DUP (?)
_preciptmy DD	01H DUP (?)
_preciptmbbox DD 04H DUP (?)
_preciptmflags DD 01H DUP (?)
_tmdropoffz DD	01H DUP (?)
_tmsectorfloorz DD 01H DUP (?)
_mapcampointer DD 01H DUP (?)
_stand	DD	01H DUP (?)
_standx	DD	01H DUP (?)
_standy	DD	01H DUP (?)
_bestslidefrac DD 01H DUP (?)
_secondslidefrac DD 01H DUP (?)
_bestslideline DD 01H DUP (?)
_secondslideline DD 01H DUP (?)
_slidemo DD	01H DUP (?)
_tmxmove DD	01H DUP (?)
_tmymove DD	01H DUP (?)
_shootthing DD	01H DUP (?)
_shootz	DD	01H DUP (?)
_lastz	DD	01H DUP (?)
_aim_nofriends DD 01H DUP (?)
_aimslope DD	01H DUP (?)
_bombdamage DD	01H DUP (?)
_bombsource DD	01H DUP (?)
_bombspot DD	01H DUP (?)
_crushchange DD	01H DUP (?)
_nofit	DD	01H DUP (?)
_headsecnode DD	01H DUP (?)
_headprecipsecnode DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@MDPBEIDE@P_MapStart?3?5tmthing?5set?$CB@
CONST	SEGMENT
??_C@_0BJ@MDPBEIDE@P_MapStart?3?5tmthing?5set?$CB@ DB 'P_MapStart: tmthin'
	DB	'g set!', 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_FakeZMovement
_TEXT	SEGMENT
_thingtop$1 = -24					; size = 4
_delta2$2 = -20						; size = 4
_delta1$3 = -16						; size = 4
_rover$4 = -12						; size = 4
_delta$ = -8						; size = 4
_dist$ = -4						; size = 4
_mo$ = 8						; size = 4
_P_FakeZMovement PROC					; COMDAT

; 3767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3768 : 	fixed_t dist, delta;
; 3769 : 
; 3770 : 	if (!mo->health)

  00009	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0000c	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [eax+140], 0
  00013	75 05		 jne	 SHORT $LN5@P_FakeZMov

; 3771 : 		return;

  00015	e9 c6 04 00 00	 jmp	 $LN29@P_FakeZMov
$LN5@P_FakeZMov:

; 3772 : 
; 3773 : 	// Intercept the stupid 'fall through 3dfloors' bug Tails 03-17-2002
; 3774 : 	if (mo->subsector->sector->ffloors)

  0001a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0001d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	83 ba 90 00 00
	00 00		 cmp	 DWORD PTR [edx+144], 0
  00029	0f 84 a2 02 00
	00		 je	 $LN3@P_FakeZMov

; 3775 : 	{
; 3776 : 		ffloor_t *rover;
; 3777 : 		fixed_t delta1, delta2;
; 3778 : 		fixed_t thingtop = mo->z + mo->height;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00032	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00035	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00038	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0003b	89 4d e8	 mov	 DWORD PTR _thingtop$1[ebp], ecx

; 3779 : 
; 3780 : 		for (rover = mo->subsector->sector->ffloors; rover; rover = rover->next)

  0003e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00041	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  0004c	89 45 f4	 mov	 DWORD PTR _rover$4[ebp], eax
  0004f	eb 09		 jmp	 SHORT $LN4@P_FakeZMov
$LN2@P_FakeZMov:
  00051	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00054	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00057	89 4d f4	 mov	 DWORD PTR _rover$4[ebp], ecx
$LN4@P_FakeZMov:
  0005a	83 7d f4 00	 cmp	 DWORD PTR _rover$4[ebp], 0
  0005e	0f 84 6d 02 00
	00		 je	 $LN3@P_FakeZMov

; 3781 : 		{
; 3782 : 			if (!(rover->flags & FF_EXISTS))

  00064	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00067	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0006a	83 e1 01	 and	 ecx, 1
  0006d	75 02		 jne	 SHORT $LN7@P_FakeZMov

; 3783 : 				continue;

  0006f	eb e0		 jmp	 SHORT $LN2@P_FakeZMov
$LN7@P_FakeZMov:

; 3784 : /*
; 3785 : 			if ((rover->flags & FF_SWIMMABLE) && GETSECSPECIAL(rover->master->frontsector->special, 1) == 3
; 3786 : 				&&  ((rover->master->flags & ML_EFFECT3)
; 3787 : 				|| thing->z-thing->momz > *rover->topheight - 16*FRACUNIT))
; 3788 : 				;
; 3789 : 			else */if ((!((((rover->flags & FF_BLOCKPLAYER) && mo->player)
; 3790 : 				|| ((rover->flags & FF_BLOCKOTHERS) && !mo->player)) || rover->flags & FF_QUICKSAND) && !(mo->player && !(mo->player->pflags & PF_NIGHTSMODE) && !mo->player->homing && (((mo->player->charability == CA_SWIM) || mo->player->powers[pw_super]) && mo->ceilingz-*rover->topheight >= mo->height) && (rover->flags & FF_SWIMMABLE) && !(mo->player->pflags & PF_SPINNING) && mo->player->speed > mo->player->runspeed && /*mo->ceilingz - *rover->topheight >= mo->height && */mo->z < *rover->topheight + 30*FRACUNIT && mo->z > *rover->topheight - 30*FRACUNIT)))

  00071	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00074	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00077	83 e1 02	 and	 ecx, 2
  0007a	74 10		 je	 SHORT $LN9@P_FakeZMov
  0007c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0007f	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00086	0f 85 24 01 00
	00		 jne	 $LN8@P_FakeZMov
$LN9@P_FakeZMov:
  0008c	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0008f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00092	83 e1 04	 and	 ecx, 4
  00095	74 10		 je	 SHORT $LN10@P_FakeZMov
  00097	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0009a	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000a1	0f 84 09 01 00
	00		 je	 $LN8@P_FakeZMov
$LN10@P_FakeZMov:
  000a7	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000aa	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000ad	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  000b3	0f 85 f7 00 00
	00		 jne	 $LN8@P_FakeZMov
  000b9	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000bc	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000c3	0f 84 e2 00 00
	00		 je	 $LN11@P_FakeZMov
  000c9	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000cc	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000d2	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  000d8	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  000de	0f 85 c7 00 00
	00		 jne	 $LN11@P_FakeZMov
  000e4	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000e7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000ed	0f b6 91 38 01
	00 00		 movzx	 edx, BYTE PTR [ecx+312]
  000f4	85 d2		 test	 edx, edx
  000f6	0f 85 af 00 00
	00		 jne	 $LN11@P_FakeZMov
  000fc	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000ff	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00105	83 b9 d8 00 00
	00 06		 cmp	 DWORD PTR [ecx+216], 6
  0010c	74 1c		 je	 SHORT $LN12@P_FakeZMov
  0010e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00111	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00117	ba 04 00 00 00	 mov	 edx, 4
  0011c	6b c2 0f	 imul	 eax, edx, 15
  0011f	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00124	0f 84 81 00 00
	00		 je	 $LN11@P_FakeZMov
$LN12@P_FakeZMov:
  0012a	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00132	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00135	2b 01		 sub	 eax, DWORD PTR [ecx]
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  0013a	3b 41 44	 cmp	 eax, DWORD PTR [ecx+68]
  0013d	7c 6c		 jl	 SHORT $LN11@P_FakeZMov
  0013f	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00142	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00145	83 e1 20	 and	 ecx, 32			; 00000020H
  00148	74 61		 je	 SHORT $LN11@P_FakeZMov
  0014a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0014d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00153	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00159	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  0015f	75 4a		 jne	 SHORT $LN11@P_FakeZMov
  00161	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00164	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0016a	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0016d	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00173	8b 89 0c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+268]
  00179	3b 88 c8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+200]
  0017f	7e 2a		 jle	 SHORT $LN11@P_FakeZMov
  00181	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00184	8b 08		 mov	 ecx, DWORD PTR [eax]
  00186	8b 11		 mov	 edx, DWORD PTR [ecx]
  00188	81 c2 00 00 1e
	00		 add	 edx, 1966080		; 001e0000H
  0018e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00191	39 50 18	 cmp	 DWORD PTR [eax+24], edx
  00194	7d 15		 jge	 SHORT $LN11@P_FakeZMov
  00196	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00199	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019d	81 ea 00 00 1e
	00		 sub	 edx, 1966080		; 001e0000H
  001a3	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001a6	39 50 18	 cmp	 DWORD PTR [eax+24], edx
  001a9	7f 05		 jg	 SHORT $LN8@P_FakeZMov
$LN11@P_FakeZMov:

; 3791 : 				continue;

  001ab	e9 a1 fe ff ff	 jmp	 $LN2@P_FakeZMov
$LN8@P_FakeZMov:

; 3792 : 
; 3793 : 			if (rover->flags & FF_QUICKSAND)

  001b0	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  001b3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001b6	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  001bc	74 2d		 je	 SHORT $LN13@P_FakeZMov

; 3794 : 			{
; 3795 : 				if (mo->z < *rover->topheight && *rover->bottomheight < thingtop)

  001be	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  001c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c3	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001c6	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001c9	3b 01		 cmp	 eax, DWORD PTR [ecx]
  001cb	7d 19		 jge	 SHORT $LN14@P_FakeZMov
  001cd	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  001d0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d5	3b 55 e8	 cmp	 edx, DWORD PTR _thingtop$1[ebp]
  001d8	7d 0c		 jge	 SHORT $LN14@P_FakeZMov

; 3796 : 				{
; 3797 : 					mo->floorz = mo->z;

  001da	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001dd	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  001e0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001e3	89 50 38	 mov	 DWORD PTR [eax+56], edx
$LN14@P_FakeZMov:

; 3798 : 				}
; 3799 : 				continue; // This is so you can jump/spring up through quicksand from below.

  001e6	e9 66 fe ff ff	 jmp	 $LN2@P_FakeZMov
$LN13@P_FakeZMov:

; 3800 : 			}
; 3801 : 
; 3802 : 			delta1 = mo->z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2));

  001eb	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  001ee	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001f1	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  001f4	8b 02		 mov	 eax, DWORD PTR [edx]
  001f6	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  001f9	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001fc	8b 00		 mov	 eax, DWORD PTR [eax]
  001fe	2b 02		 sub	 eax, DWORD PTR [edx]
  00200	99		 cdq
  00201	2b c2		 sub	 eax, edx
  00203	d1 f8		 sar	 eax, 1
  00205	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00207	03 c8		 add	 ecx, eax
  00209	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0020c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0020f	2b c1		 sub	 eax, ecx
  00211	89 45 f0	 mov	 DWORD PTR _delta1$3[ebp], eax

; 3803 : 			delta2 = thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2));

  00214	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00217	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0021a	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  0021d	8b 02		 mov	 eax, DWORD PTR [edx]
  0021f	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  00222	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00225	8b 00		 mov	 eax, DWORD PTR [eax]
  00227	2b 02		 sub	 eax, DWORD PTR [edx]
  00229	99		 cdq
  0022a	2b c2		 sub	 eax, edx
  0022c	d1 f8		 sar	 eax, 1
  0022e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00230	03 c8		 add	 ecx, eax
  00232	8b 55 e8	 mov	 edx, DWORD PTR _thingtop$1[ebp]
  00235	2b d1		 sub	 edx, ecx
  00237	89 55 ec	 mov	 DWORD PTR _delta2$2[ebp], edx

; 3804 : 			if (*rover->topheight > mo->floorz && abs(delta1) < abs(delta2)
; 3805 : 				&& (!(rover->flags & FF_REVERSEPLATFORM)))

  0023a	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00242	8b 01		 mov	 eax, DWORD PTR [ecx]
  00244	3b 42 38	 cmp	 eax, DWORD PTR [edx+56]
  00247	7e 39		 jle	 SHORT $LN15@P_FakeZMov
  00249	8b 45 f0	 mov	 eax, DWORD PTR _delta1$3[ebp]
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 _abs
  00252	83 c4 04	 add	 esp, 4
  00255	8b f0		 mov	 esi, eax
  00257	8b 4d ec	 mov	 ecx, DWORD PTR _delta2$2[ebp]
  0025a	51		 push	 ecx
  0025b	e8 00 00 00 00	 call	 _abs
  00260	83 c4 04	 add	 esp, 4
  00263	3b f0		 cmp	 esi, eax
  00265	7d 1b		 jge	 SHORT $LN15@P_FakeZMov
  00267	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0026a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0026d	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  00273	75 0d		 jne	 SHORT $LN15@P_FakeZMov

; 3806 : 			{
; 3807 : 				mo->floorz = *rover->topheight;

  00275	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00278	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027a	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0027d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0027f	89 42 38	 mov	 DWORD PTR [edx+56], eax
$LN15@P_FakeZMov:

; 3808 : 			}
; 3809 : 			if (*rover->bottomheight < mo->ceilingz && abs(delta1) >= abs(delta2)
; 3810 : 				&& (/*mo->z + mo->height <= *rover->bottomheight ||*/ !(rover->flags & FF_PLATFORM)))

  00282	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00285	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00288	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0028b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0028d	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  00290	7d 3a		 jge	 SHORT $LN16@P_FakeZMov
  00292	8b 45 f0	 mov	 eax, DWORD PTR _delta1$3[ebp]
  00295	50		 push	 eax
  00296	e8 00 00 00 00	 call	 _abs
  0029b	83 c4 04	 add	 esp, 4
  0029e	8b f0		 mov	 esi, eax
  002a0	8b 4d ec	 mov	 ecx, DWORD PTR _delta2$2[ebp]
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 _abs
  002a9	83 c4 04	 add	 esp, 4
  002ac	3b f0		 cmp	 esi, eax
  002ae	7c 1c		 jl	 SHORT $LN16@P_FakeZMov
  002b0	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  002b3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002b6	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  002bc	75 0e		 jne	 SHORT $LN16@P_FakeZMov

; 3811 : 			{
; 3812 : 				mo->ceilingz = *rover->bottomheight;

  002be	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  002c1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002c4	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  002c7	8b 01		 mov	 eax, DWORD PTR [ecx]
  002c9	89 42 3c	 mov	 DWORD PTR [edx+60], eax
$LN16@P_FakeZMov:

; 3813 : 			}
; 3814 : 		}

  002cc	e9 80 fd ff ff	 jmp	 $LN2@P_FakeZMov
$LN3@P_FakeZMov:

; 3815 : 	}
; 3816 : 
; 3817 : 	// adjust height
; 3818 : 	mo->z += mo->momz;

  002d1	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002d4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002d7	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  002da	03 4a 50	 add	 ecx, DWORD PTR [edx+80]
  002dd	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002e0	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 3819 : 	if (mo->flags & MF_FLOAT && mo->target && mo->type != MT_JETJAW && mo->type != MT_EGGMOBILE
; 3820 : 		&& mo->type != MT_EGGMOBILE2 && mo->type != MT_RING && mo->type != MT_COIN) // Tails

  002e3	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002e6	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  002e9	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  002ef	0f 84 0d 01 00
	00		 je	 $LN21@P_FakeZMov
  002f5	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002f8	83 b8 98 00 00
	00 00		 cmp	 DWORD PTR [eax+152], 0
  002ff	0f 84 fd 00 00
	00		 je	 $LN21@P_FakeZMov
  00305	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00308	83 78 7c 0e	 cmp	 DWORD PTR [eax+124], 14	; 0000000eH
  0030c	0f 84 f0 00 00
	00		 je	 $LN21@P_FakeZMov
  00312	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00315	83 78 7c 1d	 cmp	 DWORD PTR [eax+124], 29	; 0000001dH
  00319	0f 84 e3 00 00
	00		 je	 $LN21@P_FakeZMov
  0031f	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00322	83 78 7c 1f	 cmp	 DWORD PTR [eax+124], 31	; 0000001fH
  00326	0f 84 d6 00 00
	00		 je	 $LN21@P_FakeZMov
  0032c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0032f	83 78 7c 2b	 cmp	 DWORD PTR [eax+124], 43	; 0000002bH
  00333	0f 84 c9 00 00
	00		 je	 $LN21@P_FakeZMov
  00339	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0033c	81 78 7c e1 00
	00 00		 cmp	 DWORD PTR [eax+124], 225 ; 000000e1H
  00343	0f 84 b9 00 00
	00		 je	 $LN21@P_FakeZMov

; 3821 : 	{ // float down towards target if too close
; 3822 : 		if (!(mo->flags2&MF2_SKULLFLY) && !(mo->flags2&MF2_INFLOAT))

  00349	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0034c	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00352	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00358	0f 85 a4 00 00
	00		 jne	 $LN21@P_FakeZMov
  0035e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00361	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00367	83 e1 20	 and	 ecx, 32			; 00000020H
  0036a	0f 85 92 00 00
	00		 jne	 $LN21@P_FakeZMov

; 3823 : 		{
; 3824 : 			dist = P_AproxDistance(mo->x-mo->target->x, mo->y-mo->target->y);

  00370	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00373	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00379	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0037c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0037f	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]
  00382	50		 push	 eax
  00383	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00386	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0038c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0038f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00392	2b 4a 10	 sub	 ecx, DWORD PTR [edx+16]
  00395	51		 push	 ecx
  00396	e8 00 00 00 00	 call	 _P_AproxDistance
  0039b	83 c4 08	 add	 esp, 8
  0039e	89 45 fc	 mov	 DWORD PTR _dist$[ebp], eax

; 3825 : 			delta = (mo->target->z + (mo->height>>1)) - mo->z;

  003a1	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  003a4	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  003aa	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  003ad	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  003b0	d1 f8		 sar	 eax, 1
  003b2	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  003b5	03 c8		 add	 ecx, eax
  003b7	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  003ba	2b 4a 18	 sub	 ecx, DWORD PTR [edx+24]
  003bd	89 4d f8	 mov	 DWORD PTR _delta$[ebp], ecx

; 3826 : 			if (delta < 0 && dist < -(delta*3))

  003c0	79 1f		 jns	 SHORT $LN19@P_FakeZMov
  003c2	6b 45 f8 03	 imul	 eax, DWORD PTR _delta$[ebp], 3
  003c6	f7 d8		 neg	 eax
  003c8	39 45 fc	 cmp	 DWORD PTR _dist$[ebp], eax
  003cb	7d 14		 jge	 SHORT $LN19@P_FakeZMov

; 3827 : 				mo->z -= FLOATSPEED;

  003cd	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  003d0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003d3	81 e9 00 00 04
	00		 sub	 ecx, 262144		; 00040000H
  003d9	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  003dc	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  003df	eb 21		 jmp	 SHORT $LN21@P_FakeZMov
$LN19@P_FakeZMov:

; 3828 : 			else if (delta > 0 && dist < (delta*3))

  003e1	83 7d f8 00	 cmp	 DWORD PTR _delta$[ebp], 0
  003e5	7e 1b		 jle	 SHORT $LN21@P_FakeZMov
  003e7	6b 45 f8 03	 imul	 eax, DWORD PTR _delta$[ebp], 3
  003eb	39 45 fc	 cmp	 DWORD PTR _dist$[ebp], eax
  003ee	7d 12		 jge	 SHORT $LN21@P_FakeZMov

; 3829 : 				mo->z += FLOATSPEED;

  003f0	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  003f3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003f6	81 c1 00 00 04
	00		 add	 ecx, 262144		; 00040000H
  003fc	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  003ff	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN21@P_FakeZMov:

; 3830 : 		}
; 3831 : 	}
; 3832 : 
; 3833 : 	// clip movement
; 3834 : 	if (mo->z <= mo->floorz && !(mo->flags & MF_NOCLIPHEIGHT))

  00402	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00405	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00408	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0040b	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  0040e	7f 4e		 jg	 SHORT $LN22@P_FakeZMov
  00410	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00413	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00416	81 e1 00 00 80
	00		 and	 ecx, 8388608		; 00800000H
  0041c	75 40		 jne	 SHORT $LN22@P_FakeZMov

; 3835 : 	{ // Hit the floor
; 3836 : 		mo->z = mo->floorz;

  0041e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00421	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00424	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00427	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 3837 : 		if (mo->momz < 0)

  0042a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0042d	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00431	7d 0a		 jge	 SHORT $LN24@P_FakeZMov

; 3838 : 			mo->momz = 0;

  00433	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00436	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
$LN24@P_FakeZMov:

; 3839 : 
; 3840 : 		if (mo->flags2 & MF2_SKULLFLY) // The skull slammed into something

  0043d	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00440	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00446	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0044c	74 0e		 je	 SHORT $LN25@P_FakeZMov

; 3841 : 			mo->momz = -mo->momz;

  0044e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00451	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00454	f7 d9		 neg	 ecx
  00456	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00459	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$LN25@P_FakeZMov:

; 3842 : 	}

  0045c	eb 1c		 jmp	 SHORT $LN26@P_FakeZMov
$LN22@P_FakeZMov:

; 3843 : 	else if (!(mo->flags & MF_NOGRAVITY))

  0045e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00461	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00464	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0046a	75 0e		 jne	 SHORT $LN26@P_FakeZMov

; 3844 : 	{
; 3845 : 		P_CheckGravity (mo, true);

  0046c	6a 01		 push	 1
  0046e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00471	50		 push	 eax
  00472	e8 00 00 00 00	 call	 _P_CheckGravity
  00477	83 c4 08	 add	 esp, 8
$LN26@P_FakeZMov:

; 3846 : 	}
; 3847 : 
; 3848 : 	if (mo->z + mo->height > mo->ceilingz && !(mo->flags & MF_NOCLIPHEIGHT)) // hit the ceiling

  0047a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0047d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00480	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00483	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00486	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00489	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  0048c	7e 52		 jle	 SHORT $LN29@P_FakeZMov
  0048e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00491	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00494	81 e1 00 00 80
	00		 and	 ecx, 8388608		; 00800000H
  0049a	75 44		 jne	 SHORT $LN29@P_FakeZMov

; 3849 : 	{
; 3850 : 		if (mo->momz > 0)

  0049c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0049f	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  004a3	7e 0a		 jle	 SHORT $LN28@P_FakeZMov

; 3851 : 			mo->momz = 0;

  004a5	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  004a8	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
$LN28@P_FakeZMov:

; 3852 : 		mo->z = mo->ceilingz - mo->height;

  004af	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  004b2	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  004b5	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  004b8	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  004bb	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  004be	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 3853 : 		if (mo->flags2 & MF2_SKULLFLY) // the skull slammed into something

  004c1	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  004c4	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  004ca	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  004d0	74 0e		 je	 SHORT $LN29@P_FakeZMov

; 3854 : 			mo->momz = -mo->momz;

  004d2	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  004d5	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  004d8	f7 d9		 neg	 ecx
  004da	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  004dd	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$LN29@P_FakeZMov:

; 3855 : 	}
; 3856 : }

  004e0	5f		 pop	 edi
  004e1	5e		 pop	 esi
  004e2	5b		 pop	 ebx
  004e3	8b e5		 mov	 esp, ebp
  004e5	5d		 pop	 ebp
  004e6	c3		 ret	 0
_P_FakeZMovement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_GetPrecipSectors
_TEXT	SEGMENT
_ld$ = 8						; size = 4
_PIT_GetPrecipSectors PROC				; COMDAT

; 3524 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3525 : 	if (preciptmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] ||
; 3526 : 		preciptmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT] ||
; 3527 : 		preciptmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] ||

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 03	 imul	 ecx, eax, 3
  00011	ba 04 00 00 00	 mov	 edx, 4
  00016	d1 e2		 shl	 edx, 1
  00018	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0001b	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _preciptmbbox[ecx]
  00021	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00025	7e 5c		 jle	 SHORT $LN3@PIT_GetPre
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	d1 e0		 shl	 eax, 1
  0002e	b9 04 00 00 00	 mov	 ecx, 4
  00033	6b d1 03	 imul	 edx, ecx, 3
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00039	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _preciptmbbox[eax]
  0003f	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  00043	7d 3e		 jge	 SHORT $LN3@PIT_GetPre
  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	6b c8 00	 imul	 ecx, eax, 0
  0004d	ba 04 00 00 00	 mov	 edx, 4
  00052	c1 e2 00	 shl	 edx, 0
  00055	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00058	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _preciptmbbox[ecx]
  0005e	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00062	7e 1f		 jle	 SHORT $LN3@PIT_GetPre
  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	c1 e0 00	 shl	 eax, 0
  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	6b d1 00	 imul	 edx, ecx, 0
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00077	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _preciptmbbox[eax]
  0007d	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  00081	7c 07		 jl	 SHORT $LN2@PIT_GetPre
$LN3@PIT_GetPre:

; 3528 : 		preciptmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])
; 3529 : 	return true;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	eb 6d		 jmp	 SHORT $LN1@PIT_GetPre
$LN2@PIT_GetPre:

; 3530 : 
; 3531 : 	if (P_BoxOnLineSide(preciptmbbox, ld) != -1)

  0008a	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET _preciptmbbox
  00093	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 07		 je	 SHORT $LN4@PIT_GetPre

; 3532 : 		return true;

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	eb 50		 jmp	 SHORT $LN1@PIT_GetPre
$LN4@PIT_GetPre:

; 3533 : 
; 3534 : 	// This line crosses through the object.
; 3535 : 
; 3536 : 	// Collect the sector(s) from the line and add to the
; 3537 : 	// sector_list you're examining. If the Thing ends up being
; 3538 : 	// allowed to move to this position, then the sector_list
; 3539 : 	// will be attached to the Thing's mobj_t at touching_sectorlist.
; 3540 : 
; 3541 : 	precipsector_list = P_AddPrecipSecnode(ld->frontsector, tmprecipthing, precipsector_list);

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _precipsector_list
  000ac	50		 push	 eax
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmprecipthing
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000b7	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _P_AddPrecipSecnode
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _precipsector_list, eax

; 3542 : 
; 3543 : 	// Don't assume all lines are 2-sided, since some Things
; 3544 : 	// like MT_TFOG are allowed regardless of whether their radius takes
; 3545 : 	// them beyond an impassable linedef.
; 3546 : 
; 3547 : 	// Use sidedefs instead of 2s flag to determine two-sidedness.
; 3548 : 	if (ld->backsector)

  000c8	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000cb	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  000cf	74 21		 je	 SHORT $LN5@PIT_GetPre

; 3549 : 		precipsector_list = P_AddPrecipSecnode(ld->backsector, tmprecipthing, precipsector_list);

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _precipsector_list
  000d6	50		 push	 eax
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmprecipthing
  000dd	51		 push	 ecx
  000de	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000e1	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _P_AddPrecipSecnode
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ed	a3 00 00 00 00	 mov	 DWORD PTR _precipsector_list, eax
$LN5@PIT_GetPre:

; 3550 : 
; 3551 : 	return true;

  000f2	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_GetPre:

; 3552 : }

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
_PIT_GetPrecipSectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_GetSectors
_TEXT	SEGMENT
_ld$ = 8						; size = 4
_PIT_GetSectors PROC					; COMDAT

; 3492 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3493 : 	if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] ||
; 3494 : 		tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT] ||
; 3495 : 		tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] ||

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	6b c8 03	 imul	 ecx, eax, 3
  00011	ba 04 00 00 00	 mov	 edx, 4
  00016	d1 e2		 shl	 edx, 1
  00018	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0001b	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[ecx]
  00021	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00025	7e 5c		 jle	 SHORT $LN3@PIT_GetSec
  00027	b8 04 00 00 00	 mov	 eax, 4
  0002c	d1 e0		 shl	 eax, 1
  0002e	b9 04 00 00 00	 mov	 ecx, 4
  00033	6b d1 03	 imul	 edx, ecx, 3
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00039	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _tmbbox[eax]
  0003f	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  00043	7d 3e		 jge	 SHORT $LN3@PIT_GetSec
  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	6b c8 00	 imul	 ecx, eax, 0
  0004d	ba 04 00 00 00	 mov	 edx, 4
  00052	c1 e2 00	 shl	 edx, 0
  00055	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00058	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[ecx]
  0005e	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00062	7e 1f		 jle	 SHORT $LN3@PIT_GetSec
  00064	b8 04 00 00 00	 mov	 eax, 4
  00069	c1 e0 00	 shl	 eax, 0
  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	6b d1 00	 imul	 edx, ecx, 0
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  00077	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _tmbbox[eax]
  0007d	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  00081	7c 07		 jl	 SHORT $LN2@PIT_GetSec
$LN3@PIT_GetSec:

; 3496 : 		tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])
; 3497 : 	return true;

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	eb 6d		 jmp	 SHORT $LN1@PIT_GetSec
$LN2@PIT_GetSec:

; 3498 : 
; 3499 : 	if (P_BoxOnLineSide(tmbbox, ld) != -1)

  0008a	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET _tmbbox
  00093	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  00098	83 c4 08	 add	 esp, 8
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 07		 je	 SHORT $LN4@PIT_GetSec

; 3500 : 		return true;

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	eb 50		 jmp	 SHORT $LN1@PIT_GetSec
$LN4@PIT_GetSec:

; 3501 : 
; 3502 : 	// This line crosses through the object.
; 3503 : 
; 3504 : 	// Collect the sector(s) from the line and add to the
; 3505 : 	// sector_list you're examining. If the Thing ends up being
; 3506 : 	// allowed to move to this position, then the sector_list
; 3507 : 	// will be attached to the Thing's mobj_t at touching_sectorlist.
; 3508 : 
; 3509 : 	sector_list = P_AddSecnode(ld->frontsector,tmthing,sector_list);

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  000ac	50		 push	 eax
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000b7	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _P_AddSecnode
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _sector_list, eax

; 3510 : 
; 3511 : 	// Don't assume all lines are 2-sided, since some Things
; 3512 : 	// like MT_TFOG are allowed regardless of whether their radius takes
; 3513 : 	// them beyond an impassable linedef.
; 3514 : 
; 3515 : 	// Use sidedefs instead of 2s flag to determine two-sidedness.
; 3516 : 	if (ld->backsector)

  000c8	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000cb	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  000cf	74 21		 je	 SHORT $LN5@PIT_GetSec

; 3517 : 		sector_list = P_AddSecnode(ld->backsector, tmthing, sector_list);

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  000d6	50		 push	 eax
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  000dd	51		 push	 ecx
  000de	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  000e1	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _P_AddSecnode
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ed	a3 00 00 00 00	 mov	 DWORD PTR _sector_list, eax
$LN5@PIT_GetSec:

; 3518 : 
; 3519 : 	return true;

  000f2	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_GetSec:

; 3520 : }

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
_PIT_GetSectors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_DelPrecipSecnode
_TEXT	SEGMENT
_sn$ = -16						; size = 4
_sp$ = -12						; size = 4
_tn$ = -8						; size = 4
_tp$ = -4						; size = 4
_node$ = 8						; size = 4
_P_DelPrecipSecnode PROC				; COMDAT

; 3434 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3435 : 	mprecipsecnode_t *tp; // prev node on thing thread
; 3436 : 	mprecipsecnode_t *tn; // next node on thing thread
; 3437 : 	mprecipsecnode_t *sp; // prev node on sector thread
; 3438 : 	mprecipsecnode_t *sn; // next node on sector thread
; 3439 : 
; 3440 : 	if (!node)

  00009	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN2@P_DelPreci

; 3441 : 		return NULL;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 7f		 jmp	 SHORT $LN1@P_DelPreci
$LN2@P_DelPreci:

; 3442 : 
; 3443 : 	// Unlink from the Thing thread. The Thing thread begins at
; 3444 : 	// sector_list and not from mobj_t->touching_sectorlist.
; 3445 : 
; 3446 : 	tp = node->m_tprev;

  00013	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	89 4d fc	 mov	 DWORD PTR _tp$[ebp], ecx

; 3447 : 	tn = node->m_tnext;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0001f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00022	89 4d f8	 mov	 DWORD PTR _tn$[ebp], ecx

; 3448 : 	if (tp)

  00025	83 7d fc 00	 cmp	 DWORD PTR _tp$[ebp], 0
  00029	74 09		 je	 SHORT $LN3@P_DelPreci

; 3449 : 		tp->m_tnext = tn;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _tp$[ebp]
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _tn$[ebp]
  00031	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN3@P_DelPreci:

; 3450 : 	if (tn)

  00034	83 7d f8 00	 cmp	 DWORD PTR _tn$[ebp], 0
  00038	74 09		 je	 SHORT $LN4@P_DelPreci

; 3451 : 		tn->m_tprev = tp;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _tn$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _tp$[ebp]
  00040	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@P_DelPreci:

; 3452 : 
; 3453 : 	// Unlink from the sector thread. This thread begins at
; 3454 : 	// sector_t->touching_thinglist.
; 3455 : 
; 3456 : 	sp = node->m_sprev;

  00043	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00046	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00049	89 4d f4	 mov	 DWORD PTR _sp$[ebp], ecx

; 3457 : 	sn = node->m_snext;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0004f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00052	89 4d f0	 mov	 DWORD PTR _sn$[ebp], ecx

; 3458 : 	if (sp)

  00055	83 7d f4 00	 cmp	 DWORD PTR _sp$[ebp], 0
  00059	74 0b		 je	 SHORT $LN5@P_DelPreci

; 3459 : 		sp->m_snext = sn;

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _sp$[ebp]
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _sn$[ebp]
  00061	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00064	eb 0e		 jmp	 SHORT $LN6@P_DelPreci
$LN5@P_DelPreci:

; 3460 : 	else
; 3461 : 		node->m_sector->touching_preciplist = sn;

  00066	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 55 f0	 mov	 edx, DWORD PTR _sn$[ebp]
  0006e	89 91 f4 00 00
	00		 mov	 DWORD PTR [ecx+244], edx
$LN6@P_DelPreci:

; 3462 : 	if (sn)

  00074	83 7d f0 00	 cmp	 DWORD PTR _sn$[ebp], 0
  00078	74 09		 je	 SHORT $LN7@P_DelPreci

; 3463 : 		sn->m_sprev = sp;

  0007a	8b 45 f0	 mov	 eax, DWORD PTR _sn$[ebp]
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _sp$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN7@P_DelPreci:

; 3464 : 
; 3465 : 	// Return this node to the freelist
; 3466 : 
; 3467 : 	P_PutPrecipSecnode(node);

  00083	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _P_PutPrecipSecnode
  0008c	83 c4 04	 add	 esp, 4

; 3468 : 	return tn;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _tn$[ebp]
$LN1@P_DelPreci:

; 3469 : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_P_DelPrecipSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_DelSecnode
_TEXT	SEGMENT
_sn$ = -16						; size = 4
_sp$ = -12						; size = 4
_tn$ = -8						; size = 4
_tp$ = -4						; size = 4
_node$ = 8						; size = 4
_P_DelSecnode PROC					; COMDAT

; 3395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3396 : 	msecnode_t *tp; // prev node on thing thread
; 3397 : 	msecnode_t *tn; // next node on thing thread
; 3398 : 	msecnode_t *sp; // prev node on sector thread
; 3399 : 	msecnode_t *sn; // next node on sector thread
; 3400 : 
; 3401 : 	if (!node)

  00009	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN2@P_DelSecno

; 3402 : 		return NULL;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 7f		 jmp	 SHORT $LN1@P_DelSecno
$LN2@P_DelSecno:

; 3403 : 
; 3404 : 	// Unlink from the Thing thread. The Thing thread begins at
; 3405 : 	// sector_list and not from mobj_t->touching_sectorlist.
; 3406 : 
; 3407 : 	tp = node->m_tprev;

  00013	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00016	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00019	89 4d fc	 mov	 DWORD PTR _tp$[ebp], ecx

; 3408 : 	tn = node->m_tnext;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0001f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00022	89 4d f8	 mov	 DWORD PTR _tn$[ebp], ecx

; 3409 : 	if (tp)

  00025	83 7d fc 00	 cmp	 DWORD PTR _tp$[ebp], 0
  00029	74 09		 je	 SHORT $LN3@P_DelSecno

; 3410 : 		tp->m_tnext = tn;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _tp$[ebp]
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _tn$[ebp]
  00031	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN3@P_DelSecno:

; 3411 : 	if (tn)

  00034	83 7d f8 00	 cmp	 DWORD PTR _tn$[ebp], 0
  00038	74 09		 je	 SHORT $LN4@P_DelSecno

; 3412 : 		tn->m_tprev = tp;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _tn$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _tp$[ebp]
  00040	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@P_DelSecno:

; 3413 : 
; 3414 : 	// Unlink from the sector thread. This thread begins at
; 3415 : 	// sector_t->touching_thinglist.
; 3416 : 
; 3417 : 	sp = node->m_sprev;

  00043	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00046	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00049	89 4d f4	 mov	 DWORD PTR _sp$[ebp], ecx

; 3418 : 	sn = node->m_snext;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0004f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00052	89 4d f0	 mov	 DWORD PTR _sn$[ebp], ecx

; 3419 : 	if (sp)

  00055	83 7d f4 00	 cmp	 DWORD PTR _sp$[ebp], 0
  00059	74 0b		 je	 SHORT $LN5@P_DelSecno

; 3420 : 		sp->m_snext = sn;

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _sp$[ebp]
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _sn$[ebp]
  00061	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00064	eb 0e		 jmp	 SHORT $LN6@P_DelSecno
$LN5@P_DelSecno:

; 3421 : 	else
; 3422 : 		node->m_sector->touching_thinglist = sn;

  00066	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 55 f0	 mov	 edx, DWORD PTR _sn$[ebp]
  0006e	89 91 84 00 00
	00		 mov	 DWORD PTR [ecx+132], edx
$LN6@P_DelSecno:

; 3423 : 	if (sn)

  00074	83 7d f0 00	 cmp	 DWORD PTR _sn$[ebp], 0
  00078	74 09		 je	 SHORT $LN7@P_DelSecno

; 3424 : 		sn->m_sprev = sp;

  0007a	8b 45 f0	 mov	 eax, DWORD PTR _sn$[ebp]
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _sp$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN7@P_DelSecno:

; 3425 : 
; 3426 : 	// Return this node to the freelist
; 3427 : 
; 3428 : 	P_PutSecnode(node);

  00083	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _P_PutSecnode
  0008c	83 c4 04	 add	 esp, 4

; 3429 : 	return tn;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _tn$[ebp]
$LN1@P_DelSecno:

; 3430 : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_P_DelSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_AddPrecipSecnode
_TEXT	SEGMENT
_node$ = -4						; size = 4
_s$ = 8							; size = 4
_thing$ = 12						; size = 4
_nextnode$ = 16						; size = 4
_P_AddPrecipSecnode PROC				; COMDAT

; 3351 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3352 : 	mprecipsecnode_t *node;
; 3353 : 
; 3354 : 	node = nextnode;

  00009	8b 45 10	 mov	 eax, DWORD PTR _nextnode$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$LN2@P_AddPreci:

; 3355 : 	while (node)

  0000f	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  00013	74 26		 je	 SHORT $LN3@P_AddPreci

; 3356 : 	{
; 3357 : 		if (node->m_sector == s) // Already have a node for this sector?

  00015	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	3b 4d 08	 cmp	 ecx, DWORD PTR _s$[ebp]
  0001d	75 11		 jne	 SHORT $LN4@P_AddPreci

; 3358 : 		{
; 3359 : 			node->m_thing = thing; // Yes. Setting m_thing says 'keep it'.

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _thing$[ebp]
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3360 : 			return nextnode;

  00028	8b 45 10	 mov	 eax, DWORD PTR _nextnode$[ebp]
  0002b	e9 90 00 00 00	 jmp	 $LN1@P_AddPreci
$LN4@P_AddPreci:

; 3361 : 		}
; 3362 : 		node = node->m_tnext;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00033	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00036	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx

; 3363 : 	}

  00039	eb d4		 jmp	 SHORT $LN2@P_AddPreci
$LN3@P_AddPreci:

; 3364 : 
; 3365 : 	// Couldn't find an existing node for this sector. Add one at the head
; 3366 : 	// of the list.
; 3367 : 
; 3368 : 	node = P_GetPrecipSecnode();

  0003b	e8 00 00 00 00	 call	 _P_GetPrecipSecnode
  00040	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 3369 : 
; 3370 : 	// mark new nodes unvisited.
; 3371 : 	node->visited = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 3372 : 
; 3373 : 	node->m_sector = s; // sector

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 3374 : 	node->m_thing = thing; // mobj

  00055	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _thing$[ebp]
  0005b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3375 : 	node->m_tprev = NULL; // prev node on Thing thread

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00061	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 3376 : 	node->m_tnext = nextnode; // next node on Thing thread

  00068	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0006b	8b 4d 10	 mov	 ecx, DWORD PTR _nextnode$[ebp]
  0006e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3377 : 	if (nextnode)

  00071	83 7d 10 00	 cmp	 DWORD PTR _nextnode$[ebp], 0
  00075	74 09		 je	 SHORT $LN5@P_AddPreci

; 3378 : 		nextnode->m_tprev = node; // set back link on Thing

  00077	8b 45 10	 mov	 eax, DWORD PTR _nextnode$[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN5@P_AddPreci:

; 3379 : 
; 3380 : 	// Add new node at head of sector thread starting at s->touching_thinglist
; 3381 : 
; 3382 : 	node->m_sprev = NULL; // prev node on sector thread

  00080	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00083	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3383 : 	node->m_snext = s->touching_preciplist; // next node on sector thread

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00090	8b 91 f4 00 00
	00		 mov	 edx, DWORD PTR [ecx+244]
  00096	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 3384 : 	if (s->touching_preciplist)

  00099	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009c	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  000a3	74 0c		 je	 SHORT $LN6@P_AddPreci

; 3385 : 		node->m_snext->m_sprev = node;

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000a8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  000ae	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN6@P_AddPreci:

; 3386 : 	s->touching_preciplist = node;

  000b1	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  000b7	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx

; 3387 : 	return node;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
$LN1@P_AddPreci:

; 3388 : }

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
_P_AddPrecipSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_AddSecnode
_TEXT	SEGMENT
_node$ = -4						; size = 4
_s$ = 8							; size = 4
_thing$ = 12						; size = 4
_nextnode$ = 16						; size = 4
_P_AddSecnode PROC					; COMDAT

; 3310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3311 : 	msecnode_t *node;
; 3312 : 
; 3313 : 	node = nextnode;

  00009	8b 45 10	 mov	 eax, DWORD PTR _nextnode$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$LN2@P_AddSecno:

; 3314 : 	while (node)

  0000f	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  00013	74 26		 je	 SHORT $LN3@P_AddSecno

; 3315 : 	{
; 3316 : 		if (node->m_sector == s) // Already have a node for this sector?

  00015	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	3b 4d 08	 cmp	 ecx, DWORD PTR _s$[ebp]
  0001d	75 11		 jne	 SHORT $LN4@P_AddSecno

; 3317 : 		{
; 3318 : 			node->m_thing = thing; // Yes. Setting m_thing says 'keep it'.

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _thing$[ebp]
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3319 : 			return nextnode;

  00028	8b 45 10	 mov	 eax, DWORD PTR _nextnode$[ebp]
  0002b	e9 90 00 00 00	 jmp	 $LN1@P_AddSecno
$LN4@P_AddSecno:

; 3320 : 		}
; 3321 : 		node = node->m_tnext;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00033	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00036	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx

; 3322 : 	}

  00039	eb d4		 jmp	 SHORT $LN2@P_AddSecno
$LN3@P_AddSecno:

; 3323 : 
; 3324 : 	// Couldn't find an existing node for this sector. Add one at the head
; 3325 : 	// of the list.
; 3326 : 
; 3327 : 	node = P_GetSecnode();

  0003b	e8 00 00 00 00	 call	 _P_GetSecnode
  00040	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 3328 : 
; 3329 : 	// mark new nodes unvisited.
; 3330 : 	node->visited = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 3331 : 
; 3332 : 	node->m_sector = s; // sector

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 3333 : 	node->m_thing = thing; // mobj

  00055	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _thing$[ebp]
  0005b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3334 : 	node->m_tprev = NULL; // prev node on Thing thread

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00061	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 3335 : 	node->m_tnext = nextnode; // next node on Thing thread

  00068	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0006b	8b 4d 10	 mov	 ecx, DWORD PTR _nextnode$[ebp]
  0006e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3336 : 	if (nextnode)

  00071	83 7d 10 00	 cmp	 DWORD PTR _nextnode$[ebp], 0
  00075	74 09		 je	 SHORT $LN5@P_AddSecno

; 3337 : 		nextnode->m_tprev = node; // set back link on Thing

  00077	8b 45 10	 mov	 eax, DWORD PTR _nextnode$[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN5@P_AddSecno:

; 3338 : 
; 3339 : 	// Add new node at head of sector thread starting at s->touching_thinglist
; 3340 : 
; 3341 : 	node->m_sprev = NULL; // prev node on sector thread

  00080	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00083	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3342 : 	node->m_snext = s->touching_thinglist; // next node on sector thread

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00090	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00096	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 3343 : 	if (s->touching_thinglist)

  00099	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009c	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [eax+132], 0
  000a3	74 0c		 je	 SHORT $LN6@P_AddSecno

; 3344 : 		node->m_snext->m_sprev = node;

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000a8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  000ae	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN6@P_AddSecno:

; 3345 : 	s->touching_thinglist = node;

  000b1	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  000b7	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx

; 3346 : 	return node;

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
$LN1@P_AddSecno:

; 3347 : }

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
_P_AddSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_PutPrecipSecnode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_P_PutPrecipSecnode PROC				; COMDAT

; 3299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3300 : 	node->m_snext = headprecipsecnode;

  00009	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _headprecipsecnode
  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3301 : 	headprecipsecnode = node;

  00015	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00018	a3 00 00 00 00	 mov	 DWORD PTR _headprecipsecnode, eax

; 3302 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_P_PutPrecipSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_PutSecnode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_P_PutSecnode PROC					; COMDAT

; 3292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3293 : 	node->m_snext = headsecnode;

  00009	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _headsecnode
  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3294 : 	headsecnode = node;

  00015	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00018	a3 00 00 00 00	 mov	 DWORD PTR _headsecnode, eax

; 3295 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_P_PutSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_GetPrecipSecnode
_TEXT	SEGMENT
_node$ = -4						; size = 4
_P_GetPrecipSecnode PROC				; COMDAT

; 3276 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3277 : 	mprecipsecnode_t *node;
; 3278 : 
; 3279 : 	if (headprecipsecnode)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _headprecipsecnode, 0
  00010	74 18		 je	 SHORT $LN2@P_GetPreci

; 3280 : 	{
; 3281 : 		node = headprecipsecnode;

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _headprecipsecnode
  00017	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 3282 : 		headprecipsecnode = headprecipsecnode->m_snext;

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _headprecipsecnode
  0001f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00022	89 0d 00 00 00
	00		 mov	 DWORD PTR _headprecipsecnode, ecx

; 3283 : 	}

  00028	eb 13		 jmp	 SHORT $LN3@P_GetPreci
$LN2@P_GetPreci:

; 3284 : 	else
; 3285 : 		node = Z_Calloc(sizeof (*node), PU_LEVEL, NULL);

  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	6a 32		 push	 50			; 00000032H
  00030	6a 1c		 push	 28			; 0000001cH
  00032	e8 00 00 00 00	 call	 _Z_CallocAlign
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$LN3@P_GetPreci:

; 3286 : 	return node;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]

; 3287 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_P_GetPrecipSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_GetSecnode
_TEXT	SEGMENT
_node$ = -4						; size = 4
_P_GetSecnode PROC					; COMDAT

; 3262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3263 : 	msecnode_t *node;
; 3264 : 
; 3265 : 	if (headsecnode)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _headsecnode, 0
  00010	74 18		 je	 SHORT $LN2@P_GetSecno

; 3266 : 	{
; 3267 : 		node = headsecnode;

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _headsecnode
  00017	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 3268 : 		headsecnode = headsecnode->m_snext;

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _headsecnode
  0001f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00022	89 0d 00 00 00
	00		 mov	 DWORD PTR _headsecnode, ecx

; 3269 : 	}

  00028	eb 13		 jmp	 SHORT $LN3@P_GetSecno
$LN2@P_GetSecno:

; 3270 : 	else
; 3271 : 		node = Z_Calloc(sizeof (*node), PU_LEVEL, NULL);

  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	6a 32		 push	 50			; 00000032H
  00030	6a 1c		 push	 28			; 0000001cH
  00032	e8 00 00 00 00	 call	 _Z_CallocAlign
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
$LN3@P_GetSecno:

; 3272 : 	return node;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]

; 3273 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_P_GetSecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_ChangeSector
_TEXT	SEGMENT
_crumbler$1 = -24					; size = 4
_think$2 = -20						; size = 4
_thingtop$3 = -16					; size = 4
_delta2$4 = -12						; size = 4
_delta1$5 = -8						; size = 4
_rover$6 = -4						; size = 4
_thing$ = 8						; size = 4
_realcrush$ = 12					; size = 4
_PIT_ChangeSector PROC					; COMDAT

; 3020 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3021 : 	if (P_ThingHeightClip(thing))

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _P_ThingHeightClip
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	74 0a		 je	 SHORT $LN8@PIT_Change

; 3022 : 	{
; 3023 : 		// keep checking
; 3024 : 		return true;

  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	e9 fa 02 00 00	 jmp	 $LN1@PIT_Change
$LN8@PIT_Change:

; 3025 : 	}
; 3026 : 
; 3027 : 	if (!(thing->flags & MF_SHOOTABLE) && !(thing->flags & MF_PUSHABLE))

  00023	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00026	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00029	83 e1 04	 and	 ecx, 4
  0002c	75 15		 jne	 SHORT $LN9@PIT_Change
  0002e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00031	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00034	83 e1 40	 and	 ecx, 64			; 00000040H
  00037	75 0a		 jne	 SHORT $LN9@PIT_Change

; 3028 : 	{
; 3029 : 		// assume it is bloody gibs or something
; 3030 : 		return true;

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	e9 da 02 00 00	 jmp	 $LN1@PIT_Change
$LN9@PIT_Change:

; 3031 : 	}
; 3032 : 
; 3033 : 	// Crush the thing if necessary, and if it's a crumbling FOF that did it,
; 3034 : 	// reward the player who made it crumble!
; 3035 : 	if (thing->z + thing->height > thing->ceilingz && thing->z <= thing->ceilingz)

  00043	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00046	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00049	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0004c	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0004f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00052	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  00055	0f 8e 9c 02 00
	00		 jle	 $LN25@PIT_Change
  0005b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00061	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00064	3b 51 3c	 cmp	 edx, DWORD PTR [ecx+60]
  00067	0f 8f 8a 02 00
	00		 jg	 $LN25@PIT_Change

; 3036 : 	{
; 3037 : 		if (realcrush && thing->subsector->sector->ffloors)

  0006d	83 7d 0c 00	 cmp	 DWORD PTR _realcrush$[ebp], 0
  00071	0f 84 09 02 00
	00		 je	 $LN3@PIT_Change
  00077	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0007a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0007d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007f	83 ba 90 00 00
	00 00		 cmp	 DWORD PTR [edx+144], 0
  00086	0f 84 f4 01 00
	00		 je	 $LN3@PIT_Change

; 3038 : 		{
; 3039 : 			ffloor_t *rover;
; 3040 : 			fixed_t delta1, delta2;
; 3041 : 			INT32 thingtop = thing->z + thing->height;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0008f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00092	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00095	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00098	89 4d f0	 mov	 DWORD PTR _thingtop$3[ebp], ecx

; 3042 : 
; 3043 : 			for (rover = thing->subsector->sector->ffloors; rover; rover = rover->next)

  0009b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0009e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a3	8b 82 90 00 00
	00		 mov	 eax, DWORD PTR [edx+144]
  000a9	89 45 fc	 mov	 DWORD PTR _rover$6[ebp], eax
  000ac	eb 09		 jmp	 SHORT $LN4@PIT_Change
$LN2@PIT_Change:
  000ae	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  000b1	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000b4	89 4d fc	 mov	 DWORD PTR _rover$6[ebp], ecx
$LN4@PIT_Change:
  000b7	83 7d fc 00	 cmp	 DWORD PTR _rover$6[ebp], 0
  000bb	0f 84 bf 01 00
	00		 je	 $LN3@PIT_Change

; 3044 : 			{
; 3045 : 				if (!(((rover->flags & FF_BLOCKPLAYER) && thing->player)
; 3046 : 				|| ((rover->flags & FF_BLOCKOTHERS) && !thing->player)) || !(rover->flags & FF_EXISTS))

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  000c4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000c7	83 e1 02	 and	 ecx, 2
  000ca	74 0c		 je	 SHORT $LN15@PIT_Change
  000cc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000cf	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000d6	75 17		 jne	 SHORT $LN14@PIT_Change
$LN15@PIT_Change:
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  000db	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000de	83 e1 04	 and	 ecx, 4
  000e1	74 17		 je	 SHORT $LN13@PIT_Change
  000e3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000e6	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000ed	75 0b		 jne	 SHORT $LN13@PIT_Change
$LN14@PIT_Change:
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  000f2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000f5	83 e1 01	 and	 ecx, 1
  000f8	75 02		 jne	 SHORT $LN12@PIT_Change
$LN13@PIT_Change:

; 3047 : 					continue;

  000fa	eb b2		 jmp	 SHORT $LN2@PIT_Change
$LN12@PIT_Change:

; 3048 : 
; 3049 : 				delta1 = thing->z - (*rover->bottomheight + *rover->topheight)/2;

  000fc	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  000ff	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00102	8b 55 fc	 mov	 edx, DWORD PTR _rover$6[ebp]
  00105	8b 02		 mov	 eax, DWORD PTR [edx]
  00107	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00109	03 08		 add	 ecx, DWORD PTR [eax]
  0010b	8b c1		 mov	 eax, ecx
  0010d	99		 cdq
  0010e	2b c2		 sub	 eax, edx
  00110	d1 f8		 sar	 eax, 1
  00112	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00115	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00118	2b c8		 sub	 ecx, eax
  0011a	89 4d f8	 mov	 DWORD PTR _delta1$5[ebp], ecx

; 3050 : 				delta2 = thingtop - (*rover->bottomheight + *rover->topheight)/2;

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00120	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00123	8b 55 fc	 mov	 edx, DWORD PTR _rover$6[ebp]
  00126	8b 02		 mov	 eax, DWORD PTR [edx]
  00128	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0012a	03 08		 add	 ecx, DWORD PTR [eax]
  0012c	8b c1		 mov	 eax, ecx
  0012e	99		 cdq
  0012f	2b c2		 sub	 eax, edx
  00131	d1 f8		 sar	 eax, 1
  00133	8b 55 f0	 mov	 edx, DWORD PTR _thingtop$3[ebp]
  00136	2b d0		 sub	 edx, eax
  00138	89 55 f4	 mov	 DWORD PTR _delta2$4[ebp], edx

; 3051 : 				if (*rover->bottomheight <= thing->ceilingz && abs(delta1) >= abs(delta2))

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0013e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00141	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00144	8b 01		 mov	 eax, DWORD PTR [ecx]
  00146	3b 42 3c	 cmp	 eax, DWORD PTR [edx+60]
  00149	0f 8f 2c 01 00
	00		 jg	 $LN6@PIT_Change
  0014f	8b 45 f8	 mov	 eax, DWORD PTR _delta1$5[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _abs
  00158	83 c4 04	 add	 esp, 4
  0015b	8b f0		 mov	 esi, eax
  0015d	8b 4d f4	 mov	 ecx, DWORD PTR _delta2$4[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _abs
  00166	83 c4 04	 add	 esp, 4
  00169	3b f0		 cmp	 esi, eax
  0016b	0f 8c 0a 01 00
	00		 jl	 $LN6@PIT_Change

; 3052 : 				{
; 3053 : 					thinker_t *think;
; 3054 : 					elevator_t *crumbler;
; 3055 : 
; 3056 : 					for (think = thinkercap.next; think != &thinkercap; think = think->next)

  00171	a1 04 00 00 00	 mov	 eax, DWORD PTR _thinkercap+4
  00176	89 45 ec	 mov	 DWORD PTR _think$2[ebp], eax
  00179	eb 09		 jmp	 SHORT $LN7@PIT_Change
$LN5@PIT_Change:
  0017b	8b 45 ec	 mov	 eax, DWORD PTR _think$2[ebp]
  0017e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00181	89 4d ec	 mov	 DWORD PTR _think$2[ebp], ecx
$LN7@PIT_Change:
  00184	81 7d ec 00 00
	00 00		 cmp	 DWORD PTR _think$2[ebp], OFFSET _thinkercap
  0018b	0f 84 ea 00 00
	00		 je	 $LN6@PIT_Change

; 3057 : 					{
; 3058 : 						if (think->function.acp1 != (actionf_p1)T_StartCrumble)

  00191	8b 45 ec	 mov	 eax, DWORD PTR _think$2[ebp]
  00194	81 78 08 00 00
	00 00		 cmp	 DWORD PTR [eax+8], OFFSET _T_StartCrumble
  0019b	74 02		 je	 SHORT $LN17@PIT_Change

; 3059 : 							continue;

  0019d	eb dc		 jmp	 SHORT $LN5@PIT_Change
$LN17@PIT_Change:

; 3060 : 
; 3061 : 						crumbler = (elevator_t *)think;

  0019f	8b 45 ec	 mov	 eax, DWORD PTR _think$2[ebp]
  001a2	89 45 e8	 mov	 DWORD PTR _crumbler$1[ebp], eax

; 3062 : 
; 3063 : 						if (crumbler->player && crumbler->player->mo
; 3064 : 							&& crumbler->player->mo != thing
; 3065 : 							&& crumbler->actionsector == thing->subsector->sector
; 3066 : 							&& crumbler->sector == rover->master->frontsector
; 3067 : 							&& (crumbler->type == elevateBounce

  001a5	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  001a8	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  001ac	0f 84 c4 00 00
	00		 je	 $LN18@PIT_Change
  001b2	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  001b5	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  001b8	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001bb	0f 84 b5 00 00
	00		 je	 $LN18@PIT_Change
  001c1	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  001c4	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  001c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c9	3b 55 08	 cmp	 edx, DWORD PTR _thing$[ebp]
  001cc	0f 84 a4 00 00
	00		 je	 $LN18@PIT_Change
  001d2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001d5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001d8	8b 55 e8	 mov	 edx, DWORD PTR _crumbler$1[ebp]
  001db	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001de	3b 01		 cmp	 eax, DWORD PTR [ecx]
  001e0	0f 85 90 00 00
	00		 jne	 $LN18@PIT_Change
  001e6	8b 45 fc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001e9	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001ec	8b 55 e8	 mov	 edx, DWORD PTR _crumbler$1[ebp]
  001ef	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001f2	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  001f5	75 7f		 jne	 SHORT $LN18@PIT_Change
  001f7	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  001fa	83 78 10 04	 cmp	 DWORD PTR [eax+16], 4
  001fe	74 09		 je	 SHORT $LN19@PIT_Change
  00200	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  00203	83 78 10 03	 cmp	 DWORD PTR [eax+16], 3
  00207	75 6d		 jne	 SHORT $LN18@PIT_Change
$LN19@PIT_Change:

; 3068 : 							|| crumbler->type == elevateContinuous))
; 3069 : 						{
; 3070 : 							if (netgame && thing->player && thing->player->spectator)

  00209	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00210	74 37		 je	 SHORT $LN20@PIT_Change
  00212	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00215	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0021c	74 2b		 je	 SHORT $LN20@PIT_Change
  0021e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00221	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00227	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  0022e	85 d2		 test	 edx, edx
  00230	74 17		 je	 SHORT $LN20@PIT_Change

; 3071 : 								P_DamageMobj(thing, NULL, NULL, 42000); // Respawn crushed spectators

  00232	68 10 a4 00 00	 push	 42000			; 0000a410H
  00237	6a 00		 push	 0
  00239	6a 00		 push	 0
  0023b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 _P_DamageMobj
  00244	83 c4 10	 add	 esp, 16			; 00000010H
  00247	eb 23		 jmp	 SHORT $LN21@PIT_Change
$LN20@PIT_Change:

; 3072 : 							else
; 3073 : 								P_DamageMobj(thing, crumbler->player->mo, crumbler->player->mo, 10000);

  00249	68 10 27 00 00	 push	 10000			; 00002710H
  0024e	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  00251	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00254	8b 11		 mov	 edx, DWORD PTR [ecx]
  00256	52		 push	 edx
  00257	8b 45 e8	 mov	 eax, DWORD PTR _crumbler$1[ebp]
  0025a	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0025d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025f	52		 push	 edx
  00260	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 _P_DamageMobj
  00269	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@PIT_Change:

; 3074 : 							return true;

  0026c	b8 01 00 00 00	 mov	 eax, 1
  00271	e9 a7 00 00 00	 jmp	 $LN1@PIT_Change
$LN18@PIT_Change:

; 3075 : 						}
; 3076 : 					}

  00276	e9 00 ff ff ff	 jmp	 $LN5@PIT_Change
$LN6@PIT_Change:

; 3077 : 				}
; 3078 : 			}

  0027b	e9 2e fe ff ff	 jmp	 $LN2@PIT_Change
$LN3@PIT_Change:

; 3079 : 		}
; 3080 : 
; 3081 : 		if (thing->flags & MF_PUSHABLE)

  00280	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00283	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00286	83 e1 40	 and	 ecx, 64			; 00000040H
  00289	74 11		 je	 SHORT $LN22@PIT_Change

; 3082 : 		{
; 3083 : 			nofit = true;

  0028b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nofit, 1

; 3084 : 			return false;

  00295	33 c0		 xor	 eax, eax
  00297	e9 81 00 00 00	 jmp	 $LN1@PIT_Change
$LN22@PIT_Change:

; 3085 : 		}
; 3086 : 
; 3087 : 		if (realcrush)

  0029c	83 7d 0c 00	 cmp	 DWORD PTR _realcrush$[ebp], 0
  002a0	74 55		 je	 SHORT $LN25@PIT_Change

; 3088 : 		{
; 3089 : 			// Instant-death, but no one to blame
; 3090 : 			if (netgame && thing->player && thing->player->spectator)

  002a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  002a9	74 37		 je	 SHORT $LN24@PIT_Change
  002ab	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002ae	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  002b5	74 2b		 je	 SHORT $LN24@PIT_Change
  002b7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002ba	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002c0	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  002c7	85 d2		 test	 edx, edx
  002c9	74 17		 je	 SHORT $LN24@PIT_Change

; 3091 : 				P_DamageMobj(thing, NULL, NULL, 42000); // Respawn crushed spectators

  002cb	68 10 a4 00 00	 push	 42000			; 0000a410H
  002d0	6a 00		 push	 0
  002d2	6a 00		 push	 0
  002d4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002d7	50		 push	 eax
  002d8	e8 00 00 00 00	 call	 _P_DamageMobj
  002dd	83 c4 10	 add	 esp, 16			; 00000010H
  002e0	eb 15		 jmp	 SHORT $LN25@PIT_Change
$LN24@PIT_Change:

; 3092 : 			else
; 3093 : 				P_DamageMobj(thing, NULL, NULL, 10000);

  002e2	68 10 27 00 00	 push	 10000			; 00002710H
  002e7	6a 00		 push	 0
  002e9	6a 00		 push	 0
  002eb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 _P_DamageMobj
  002f4	83 c4 10	 add	 esp, 16			; 00000010H
$LN25@PIT_Change:

; 3094 : 		}
; 3095 : 	}
; 3096 : 
; 3097 : 	if (realcrush && crushchange)

  002f7	83 7d 0c 00	 cmp	 DWORD PTR _realcrush$[ebp], 0
  002fb	74 1b		 je	 SHORT $LN26@PIT_Change
  002fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _crushchange, 0
  00304	74 12		 je	 SHORT $LN26@PIT_Change

; 3098 : 		P_DamageMobj(thing, NULL, NULL, 1);

  00306	6a 01		 push	 1
  00308	6a 00		 push	 0
  0030a	6a 00		 push	 0
  0030c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 _P_DamageMobj
  00315	83 c4 10	 add	 esp, 16			; 00000010H
$LN26@PIT_Change:

; 3099 : 
; 3100 : 	// keep checking (crush other things)
; 3101 : 	return true;

  00318	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_Change:

; 3102 : }

  0031d	5f		 pop	 edi
  0031e	5e		 pop	 esi
  0031f	5b		 pop	 ebx
  00320	8b e5		 mov	 esp, ebp
  00322	5d		 pop	 ebp
  00323	c3		 ret	 0
_PIT_ChangeSector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_RadiusAttack
_TEXT	SEGMENT
tv71 = -96						; size = 4
_momy$1 = -28						; size = 4
_momx$2 = -24						; size = 4
_damage$3 = -20						; size = 4
_dist$ = -16						; size = 4
_dz$ = -12						; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_thing$ = 8						; size = 4
_PIT_RadiusAttack PROC					; COMDAT

; 2918 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2919 : 	fixed_t dx, dy, dz, dist;
; 2920 : 
; 2921 : 	if (!(thing->flags & MF_SHOOTABLE))

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0000f	83 e1 04	 and	 ecx, 4
  00012	75 0a		 jne	 SHORT $LN4@PIT_Radius

; 2922 : 		return true;

  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	e9 dd 01 00 00	 jmp	 $LN1@PIT_Radius
$LN4@PIT_Radius:

; 2923 : 
; 2924 : 	if (thing->flags & MF_BOSS)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00021	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00024	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0002a	74 0a		 je	 SHORT $LN5@PIT_Radius

; 2925 : 		return true;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	e9 c5 01 00 00	 jmp	 $LN1@PIT_Radius
$LN5@PIT_Radius:

; 2926 : 
; 2927 : 	switch (thing->type)

  00036	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00039	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0003c	89 4d a0	 mov	 DWORD PTR tv71[ebp], ecx
  0003f	83 7d a0 06	 cmp	 DWORD PTR tv71[ebp], 6
  00043	74 08		 je	 SHORT $LN6@PIT_Radius
  00045	83 7d a0 0a	 cmp	 DWORD PTR tv71[ebp], 10	; 0000000aH
  00049	74 02		 je	 SHORT $LN6@PIT_Radius
  0004b	eb 0a		 jmp	 SHORT $LN8@PIT_Radius
$LN6@PIT_Radius:

; 2928 : 	{
; 2929 : 		case MT_SKIM:
; 2930 : 		case MT_JETTBOMBER: // Jetty-Syn Bomber
; 2931 : 			return true;

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	e9 a4 01 00 00	 jmp	 $LN1@PIT_Radius
$LN8@PIT_Radius:

; 2932 : 		default:
; 2933 : 			if (thing->flags & MF_MONITOR)

  00057	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0005a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0005d	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  00063	74 0a		 je	 SHORT $LN9@PIT_Radius

; 2934 : 				return true;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	e9 8c 01 00 00	 jmp	 $LN1@PIT_Radius
$LN9@PIT_Radius:

; 2935 : 			break;
; 2936 : 	}
; 2937 : 
; 2938 : 	dx = abs(thing->x - bombspot->x);

  0006f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  00078	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0007b	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _abs
  00084	83 c4 04	 add	 esp, 4
  00087	89 45 fc	 mov	 DWORD PTR _dx$[ebp], eax

; 2939 : 	dy = abs(thing->y - bombspot->y);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  00093	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00096	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 _abs
  0009f	83 c4 04	 add	 esp, 4
  000a2	89 45 f8	 mov	 DWORD PTR _dy$[ebp], eax

; 2940 : 	dz = abs(thing->z + (thing->height>>1) - bombspot->z);

  000a5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000a8	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000ab	d1 f9		 sar	 ecx, 1
  000ad	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000b0	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b3	03 c1		 add	 eax, ecx
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  000bb	2b 41 18	 sub	 eax, DWORD PTR [ecx+24]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _abs
  000c4	83 c4 04	 add	 esp, 4
  000c7	89 45 f4	 mov	 DWORD PTR _dz$[ebp], eax

; 2941 : 
; 2942 : 	dist = P_AproxDistance(P_AproxDistance(dx, dy), dz);

  000ca	8b 45 f4	 mov	 eax, DWORD PTR _dz$[ebp]
  000cd	50		 push	 eax
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _dy$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 fc	 mov	 edx, DWORD PTR _dx$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 _P_AproxDistance
  000db	83 c4 08	 add	 esp, 8
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _P_AproxDistance
  000e4	83 c4 08	 add	 esp, 8
  000e7	89 45 f0	 mov	 DWORD PTR _dist$[ebp], eax

; 2943 : 	dist -= thing->radius;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ed	8b 4d f0	 mov	 ecx, DWORD PTR _dist$[ebp]
  000f0	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  000f3	89 4d f0	 mov	 DWORD PTR _dist$[ebp], ecx

; 2944 : 
; 2945 : 	dist >>= FRACBITS;

  000f6	8b 45 f0	 mov	 eax, DWORD PTR _dist$[ebp]
  000f9	c1 f8 10	 sar	 eax, 16			; 00000010H
  000fc	89 45 f0	 mov	 DWORD PTR _dist$[ebp], eax

; 2946 : 
; 2947 : 	if (dist < 0)

  000ff	83 7d f0 00	 cmp	 DWORD PTR _dist$[ebp], 0
  00103	7d 07		 jge	 SHORT $LN10@PIT_Radius

; 2948 : 		dist = 0;

  00105	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dist$[ebp], 0
$LN10@PIT_Radius:

; 2949 : 
; 2950 : 	if (dist >= bombdamage)

  0010c	8b 45 f0	 mov	 eax, DWORD PTR _dist$[ebp]
  0010f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bombdamage
  00115	7c 0a		 jl	 SHORT $LN11@PIT_Radius

; 2951 : 		return true; // out of range

  00117	b8 01 00 00 00	 mov	 eax, 1
  0011c	e9 da 00 00 00	 jmp	 $LN1@PIT_Radius
$LN11@PIT_Radius:

; 2952 : 
; 2953 : 	if (thing->floorz > bombspot->z && bombspot->ceilingz < thing->z)

  00121	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  0012a	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  0012d	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  00130	7e 1a		 jle	 SHORT $LN12@PIT_Radius
  00132	a1 00 00 00 00	 mov	 eax, DWORD PTR _bombspot
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0013a	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  0013d	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  00140	7d 0a		 jge	 SHORT $LN12@PIT_Radius

; 2954 : 		return true;

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	e9 af 00 00 00	 jmp	 $LN1@PIT_Radius
$LN12@PIT_Radius:

; 2955 : 
; 2956 : 	if (thing->ceilingz < bombspot->z && bombspot->floorz > thing->z)

  0014c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  00155	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00158	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0015b	7d 1a		 jge	 SHORT $LN13@PIT_Radius
  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bombspot
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00165	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00168	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  0016b	7e 0a		 jle	 SHORT $LN13@PIT_Radius

; 2957 : 		return true;

  0016d	b8 01 00 00 00	 mov	 eax, 1
  00172	e9 84 00 00 00	 jmp	 $LN1@PIT_Radius
$LN13@PIT_Radius:

; 2958 : 
; 2959 : 	if (P_CheckSight(thing, bombspot))

  00177	a1 00 00 00 00	 mov	 eax, DWORD PTR _bombspot
  0017c	50		 push	 eax
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 _P_CheckSight
  00186	83 c4 08	 add	 esp, 8
  00189	85 c0		 test	 eax, eax
  0018b	74 69		 je	 SHORT $LN14@PIT_Radius

; 2960 : 	{
; 2961 : 		INT32 damage = bombdamage - dist;

  0018d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bombdamage
  00192	2b 45 f0	 sub	 eax, DWORD PTR _dist$[ebp]
  00195	89 45 ec	 mov	 DWORD PTR _damage$3[ebp], eax

; 2962 : 		INT32 momx = 0, momy = 0;

  00198	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _momx$2[ebp], 0
  0019f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _momy$1[ebp], 0

; 2963 : 		if (dist)

  001a6	83 7d f0 00	 cmp	 DWORD PTR _dist$[ebp], 0
  001aa	74 2c		 je	 SHORT $LN15@PIT_Radius

; 2964 : 		{
; 2965 : 			momx = (thing->x - bombspot->x)/dist;

  001ac	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  001b5	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  001b8	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  001bb	99		 cdq
  001bc	f7 7d f0	 idiv	 DWORD PTR _dist$[ebp]
  001bf	89 45 e8	 mov	 DWORD PTR _momx$2[ebp], eax

; 2966 : 			momy = (thing->y - bombspot->y)/dist;

  001c2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombspot
  001cb	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  001ce	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]
  001d1	99		 cdq
  001d2	f7 7d f0	 idiv	 DWORD PTR _dist$[ebp]
  001d5	89 45 e4	 mov	 DWORD PTR _momy$1[ebp], eax
$LN15@PIT_Radius:

; 2967 : 		}
; 2968 : 		// must be in direct path
; 2969 : 		P_DamageMobj(thing, bombspot, bombsource, damage); // Tails 01-11-2001

  001d8	8b 45 ec	 mov	 eax, DWORD PTR _damage$3[ebp]
  001db	50		 push	 eax
  001dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bombsource
  001e2	51		 push	 ecx
  001e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bombspot
  001e9	52		 push	 edx
  001ea	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _P_DamageMobj
  001f3	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@PIT_Radius:

; 2970 : 	}
; 2971 : 
; 2972 : 	return true;

  001f6	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_Radius:

; 2973 : }

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b e5		 mov	 esp, ebp
  00200	5d		 pop	 ebp
  00201	c3		 ret	 0
_PIT_RadiusAttack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PTR_AimTraverse
_TEXT	SEGMENT
tv144 = -128						; size = 4
tv145 = -124						; size = 4
_lowslope$1 = -56					; size = 4
_highslope$2 = -52					; size = 4
_rover$3 = -48						; size = 4
_lowslope$4 = -44					; size = 4
_highslope$5 = -40					; size = 4
_rover$6 = -36						; size = 4
_frontflag$7 = -32					; size = 4
_dir$ = -28						; size = 4
_dist$ = -24						; size = 4
_thingbottomslope$ = -20				; size = 4
_thingtopslope$ = -16					; size = 4
_slope$ = -12						; size = 4
_th$ = -8						; size = 4
_li$ = -4						; size = 4
_in$ = 8						; size = 4
_PTR_AimTraverse PROC					; COMDAT

; 2689 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2690 : 	line_t *li;
; 2691 : 	mobj_t *th;
; 2692 : 	fixed_t slope, thingtopslope, thingbottomslope, dist;
; 2693 : 	INT32 dir;
; 2694 : 
; 2695 : 	if (in->isaline)

  0000c	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	0f 84 b6 03 00
	00		 je	 $LN8@PTR_AimTra

; 2696 : 	{
; 2697 : 		li = in->d.line;

  00019	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0001c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001f	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 2698 : 
; 2699 : 		if (!(li->flags & ML_TWOSIDED))

  00022	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00025	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00029	83 e1 04	 and	 ecx, 4
  0002c	75 07		 jne	 SHORT $LN9@PTR_AimTra

; 2700 : 			return false; // stop

  0002e	33 c0		 xor	 eax, eax
  00030	e9 48 05 00 00	 jmp	 $LN1@PTR_AimTra
$LN9@PTR_AimTra:

; 2701 : 
; 2702 : 		// Crosses a two sided line.
; 2703 : 		// A two sided line will restrict
; 2704 : 		// the possible target ranges.
; 2705 : 		tmthing = NULL;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmthing, 0

; 2706 : 		P_LineOpening(li);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _P_LineOpening
  00048	83 c4 04	 add	 esp, 4

; 2707 : 
; 2708 : 		if (openbottom >= opentop)

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  00050	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _opentop
  00056	7c 07		 jl	 SHORT $LN10@PTR_AimTra

; 2709 : 			return false; // stop

  00058	33 c0		 xor	 eax, eax
  0005a	e9 1e 05 00 00	 jmp	 $LN1@PTR_AimTra
$LN10@PTR_AimTra:

; 2710 : 
; 2711 : 		dist = FixedMul(attackrange, in->frac);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	51		 push	 ecx
  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _attackrange
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _FixedMul
  00071	83 c4 08	 add	 esp, 8
  00074	89 45 e8	 mov	 DWORD PTR _dist$[ebp], eax

; 2712 : 
; 2713 : 		if (li->frontsector->floorheight != li->backsector->floorheight)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  0007a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _li$[ebp]
  00080	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00083	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00085	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00087	74 2f		 je	 SHORT $LN12@PTR_AimTra

; 2714 : 		{
; 2715 : 			slope = FixedDiv(openbottom - shootz, dist);

  00089	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  0008c	50		 push	 eax
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _openbottom
  00093	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _shootz
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 _FixedDiv
  0009f	83 c4 08	 add	 esp, 8
  000a2	89 45 f4	 mov	 DWORD PTR _slope$[ebp], eax

; 2716 : 			if (slope > bottomslope)

  000a5	8b 45 f4	 mov	 eax, DWORD PTR _slope$[ebp]
  000a8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bottomslope
  000ae	7e 08		 jle	 SHORT $LN12@PTR_AimTra

; 2717 : 				bottomslope = slope;

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _slope$[ebp]
  000b3	a3 00 00 00 00	 mov	 DWORD PTR _bottomslope, eax
$LN12@PTR_AimTra:

; 2718 : 		}
; 2719 : 
; 2720 : 		if (li->frontsector->ceilingheight != li->backsector->ceilingheight)

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  000bb	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000be	8b 55 fc	 mov	 edx, DWORD PTR _li$[ebp]
  000c1	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  000c4	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c7	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000ca	74 2f		 je	 SHORT $LN14@PTR_AimTra

; 2721 : 		{
; 2722 : 			slope = FixedDiv(opentop - shootz, dist);

  000cc	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  000cf	50		 push	 eax
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opentop
  000d6	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _shootz
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _FixedDiv
  000e2	83 c4 08	 add	 esp, 8
  000e5	89 45 f4	 mov	 DWORD PTR _slope$[ebp], eax

; 2723 : 			if (slope < topslope)

  000e8	8b 45 f4	 mov	 eax, DWORD PTR _slope$[ebp]
  000eb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _topslope
  000f1	7d 08		 jge	 SHORT $LN14@PTR_AimTra

; 2724 : 				topslope = slope;

  000f3	8b 45 f4	 mov	 eax, DWORD PTR _slope$[ebp]
  000f6	a3 00 00 00 00	 mov	 DWORD PTR _topslope, eax
$LN14@PTR_AimTra:

; 2725 : 		}
; 2726 : 
; 2727 : 		if (topslope <= bottomslope)

  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _topslope
  00100	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bottomslope
  00106	7f 07		 jg	 SHORT $LN15@PTR_AimTra

; 2728 : 			return false; // stop

  00108	33 c0		 xor	 eax, eax
  0010a	e9 6e 04 00 00	 jmp	 $LN1@PTR_AimTra
$LN15@PTR_AimTra:

; 2729 : 
; 2730 : 		if (li->frontsector->ffloors || li->backsector->ffloors)

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00112	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00115	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  0011c	75 13		 jne	 SHORT $LN17@PTR_AimTra
  0011e	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00121	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00124	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  0012b	0f 84 76 02 00
	00		 je	 $LN30@PTR_AimTra
$LN17@PTR_AimTra:

; 2731 : 		{
; 2732 : 			INT32 frontflag = P_PointOnLineSide(shootthing->x, shootthing->y, li);

  00131	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00134	50		 push	 eax
  00135	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _shootthing
  0013b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0013e	52		 push	 edx
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR _shootthing
  00144	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00150	89 45 e0	 mov	 DWORD PTR _frontflag$7[ebp], eax

; 2733 : 
; 2734 : 			dir = aimslope > 0 ? 1 : aimslope < 0 ? -1 : 0;

  00153	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _aimslope, 0
  0015a	7e 09		 jle	 SHORT $LN49@PTR_AimTra
  0015c	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv145[ebp], 1
  00163	eb 1f		 jmp	 SHORT $LN50@PTR_AimTra
$LN49@PTR_AimTra:
  00165	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _aimslope, 0
  0016c	7d 09		 jge	 SHORT $LN47@PTR_AimTra
  0016e	c7 45 80 ff ff
	ff ff		 mov	 DWORD PTR tv144[ebp], -1
  00175	eb 07		 jmp	 SHORT $LN48@PTR_AimTra
$LN47@PTR_AimTra:
  00177	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv144[ebp], 0
$LN48@PTR_AimTra:
  0017e	8b 45 80	 mov	 eax, DWORD PTR tv144[ebp]
  00181	89 45 84	 mov	 DWORD PTR tv145[ebp], eax
$LN50@PTR_AimTra:
  00184	8b 4d 84	 mov	 ecx, DWORD PTR tv145[ebp]
  00187	89 4d e4	 mov	 DWORD PTR _dir$[ebp], ecx

; 2735 : 
; 2736 : 			//SoM: Check 3D FLOORS!
; 2737 : 			if (li->frontsector->ffloors)

  0018a	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  0018d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00190	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  00197	0f 84 e8 00 00
	00		 je	 $LN3@PTR_AimTra

; 2738 : 			{
; 2739 : 				ffloor_t *rover = li->frontsector->ffloors;

  0019d	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  001a0	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001a3	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  001a9	89 55 dc	 mov	 DWORD PTR _rover$6[ebp], edx

; 2740 : 				fixed_t highslope, lowslope;
; 2741 : 
; 2742 : 				for (; rover; rover = rover->next)

  001ac	eb 09		 jmp	 SHORT $LN4@PTR_AimTra
$LN2@PTR_AimTra:
  001ae	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001b1	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  001b4	89 4d dc	 mov	 DWORD PTR _rover$6[ebp], ecx
$LN4@PTR_AimTra:
  001b7	83 7d dc 00	 cmp	 DWORD PTR _rover$6[ebp], 0
  001bb	0f 84 c4 00 00
	00		 je	 $LN3@PTR_AimTra

; 2743 : 				{
; 2744 : 					if (!(rover->flags & FF_SOLID) || !(rover->flags & FF_EXISTS))

  001c1	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001c4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001c7	83 e1 06	 and	 ecx, 6
  001ca	74 0b		 je	 SHORT $LN20@PTR_AimTra
  001cc	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  001cf	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001d2	83 e1 01	 and	 ecx, 1
  001d5	75 02		 jne	 SHORT $LN19@PTR_AimTra
$LN20@PTR_AimTra:

; 2745 : 						continue;

  001d7	eb d5		 jmp	 SHORT $LN2@PTR_AimTra
$LN19@PTR_AimTra:

; 2746 : 
; 2747 : 					highslope = FixedDiv(*rover->topheight - shootz, dist);

  001d9	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  001dc	50		 push	 eax
  001dd	8b 4d dc	 mov	 ecx, DWORD PTR _rover$6[ebp]
  001e0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e2	8b 02		 mov	 eax, DWORD PTR [edx]
  001e4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _shootz
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 _FixedDiv
  001f0	83 c4 08	 add	 esp, 8
  001f3	89 45 d8	 mov	 DWORD PTR _highslope$5[ebp], eax

; 2748 : 					lowslope = FixedDiv(*rover->bottomheight - shootz, dist);

  001f6	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  001f9	50		 push	 eax
  001fa	8b 4d dc	 mov	 ecx, DWORD PTR _rover$6[ebp]
  001fd	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00200	8b 02		 mov	 eax, DWORD PTR [edx]
  00202	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _shootz
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 _FixedDiv
  0020e	83 c4 08	 add	 esp, 8
  00211	89 45 d4	 mov	 DWORD PTR _lowslope$4[ebp], eax

; 2749 : 					if ((aimslope >= lowslope && aimslope <= highslope))

  00214	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  00219	3b 45 d4	 cmp	 eax, DWORD PTR _lowslope$4[ebp]
  0021c	7c 11		 jl	 SHORT $LN21@PTR_AimTra
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  00223	3b 45 d8	 cmp	 eax, DWORD PTR _highslope$5[ebp]
  00226	7f 07		 jg	 SHORT $LN21@PTR_AimTra

; 2750 : 						return false;

  00228	33 c0		 xor	 eax, eax
  0022a	e9 4e 03 00 00	 jmp	 $LN1@PTR_AimTra
$LN21@PTR_AimTra:

; 2751 : 
; 2752 : 					if (lastz > *rover->topheight && dir == -1 && aimslope < highslope)

  0022f	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  00232	8b 08		 mov	 ecx, DWORD PTR [eax]
  00234	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lastz
  0023a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0023c	7e 19		 jle	 SHORT $LN22@PTR_AimTra
  0023e	83 7d e4 ff	 cmp	 DWORD PTR _dir$[ebp], -1
  00242	75 13		 jne	 SHORT $LN22@PTR_AimTra
  00244	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  00249	3b 45 d8	 cmp	 eax, DWORD PTR _highslope$5[ebp]
  0024c	7d 09		 jge	 SHORT $LN22@PTR_AimTra

; 2753 : 						frontflag |= 0x2;

  0024e	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  00251	83 c8 02	 or	 eax, 2
  00254	89 45 e0	 mov	 DWORD PTR _frontflag$7[ebp], eax
$LN22@PTR_AimTra:

; 2754 : 
; 2755 : 					if (lastz < *rover->bottomheight && dir == 1 && aimslope > lowslope)

  00257	8b 45 dc	 mov	 eax, DWORD PTR _rover$6[ebp]
  0025a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0025d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lastz
  00263	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00265	7d 19		 jge	 SHORT $LN23@PTR_AimTra
  00267	83 7d e4 01	 cmp	 DWORD PTR _dir$[ebp], 1
  0026b	75 13		 jne	 SHORT $LN23@PTR_AimTra
  0026d	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  00272	3b 45 d4	 cmp	 eax, DWORD PTR _lowslope$4[ebp]
  00275	7e 09		 jle	 SHORT $LN23@PTR_AimTra

; 2756 : 						frontflag |= 0x2;

  00277	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  0027a	83 c8 02	 or	 eax, 2
  0027d	89 45 e0	 mov	 DWORD PTR _frontflag$7[ebp], eax
$LN23@PTR_AimTra:

; 2757 : 				}

  00280	e9 29 ff ff ff	 jmp	 $LN2@PTR_AimTra
$LN3@PTR_AimTra:

; 2758 : 			}
; 2759 : 
; 2760 : 			if (li->backsector->ffloors)

  00285	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00288	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0028b	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  00292	0f 84 e8 00 00
	00		 je	 $LN6@PTR_AimTra

; 2761 : 			{
; 2762 : 				ffloor_t *rover = li->backsector->ffloors;

  00298	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  0029b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0029e	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  002a4	89 55 d0	 mov	 DWORD PTR _rover$3[ebp], edx

; 2763 : 				fixed_t highslope, lowslope;
; 2764 : 
; 2765 : 				for (; rover; rover = rover->next)

  002a7	eb 09		 jmp	 SHORT $LN7@PTR_AimTra
$LN5@PTR_AimTra:
  002a9	8b 45 d0	 mov	 eax, DWORD PTR _rover$3[ebp]
  002ac	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  002af	89 4d d0	 mov	 DWORD PTR _rover$3[ebp], ecx
$LN7@PTR_AimTra:
  002b2	83 7d d0 00	 cmp	 DWORD PTR _rover$3[ebp], 0
  002b6	0f 84 c4 00 00
	00		 je	 $LN6@PTR_AimTra

; 2766 : 				{
; 2767 : 					if (!(rover->flags & FF_SOLID) || !(rover->flags & FF_EXISTS))

  002bc	8b 45 d0	 mov	 eax, DWORD PTR _rover$3[ebp]
  002bf	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002c2	83 e1 06	 and	 ecx, 6
  002c5	74 0b		 je	 SHORT $LN26@PTR_AimTra
  002c7	8b 45 d0	 mov	 eax, DWORD PTR _rover$3[ebp]
  002ca	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002cd	83 e1 01	 and	 ecx, 1
  002d0	75 02		 jne	 SHORT $LN25@PTR_AimTra
$LN26@PTR_AimTra:

; 2768 : 						continue;

  002d2	eb d5		 jmp	 SHORT $LN5@PTR_AimTra
$LN25@PTR_AimTra:

; 2769 : 
; 2770 : 					highslope = FixedDiv(*rover->topheight - shootz, dist);

  002d4	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  002d7	50		 push	 eax
  002d8	8b 4d d0	 mov	 ecx, DWORD PTR _rover$3[ebp]
  002db	8b 11		 mov	 edx, DWORD PTR [ecx]
  002dd	8b 02		 mov	 eax, DWORD PTR [edx]
  002df	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _shootz
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 _FixedDiv
  002eb	83 c4 08	 add	 esp, 8
  002ee	89 45 cc	 mov	 DWORD PTR _highslope$2[ebp], eax

; 2771 : 					lowslope = FixedDiv(*rover->bottomheight - shootz, dist);

  002f1	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  002f4	50		 push	 eax
  002f5	8b 4d d0	 mov	 ecx, DWORD PTR _rover$3[ebp]
  002f8	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  002fb	8b 02		 mov	 eax, DWORD PTR [edx]
  002fd	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _shootz
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 _FixedDiv
  00309	83 c4 08	 add	 esp, 8
  0030c	89 45 c8	 mov	 DWORD PTR _lowslope$1[ebp], eax

; 2772 : 					if ((aimslope >= lowslope && aimslope <= highslope))

  0030f	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  00314	3b 45 c8	 cmp	 eax, DWORD PTR _lowslope$1[ebp]
  00317	7c 11		 jl	 SHORT $LN27@PTR_AimTra
  00319	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  0031e	3b 45 cc	 cmp	 eax, DWORD PTR _highslope$2[ebp]
  00321	7f 07		 jg	 SHORT $LN27@PTR_AimTra

; 2773 : 						return false;

  00323	33 c0		 xor	 eax, eax
  00325	e9 53 02 00 00	 jmp	 $LN1@PTR_AimTra
$LN27@PTR_AimTra:

; 2774 : 
; 2775 : 					if (lastz > *rover->topheight && dir == -1 && aimslope < highslope)

  0032a	8b 45 d0	 mov	 eax, DWORD PTR _rover$3[ebp]
  0032d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lastz
  00335	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00337	7e 19		 jle	 SHORT $LN28@PTR_AimTra
  00339	83 7d e4 ff	 cmp	 DWORD PTR _dir$[ebp], -1
  0033d	75 13		 jne	 SHORT $LN28@PTR_AimTra
  0033f	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  00344	3b 45 cc	 cmp	 eax, DWORD PTR _highslope$2[ebp]
  00347	7d 09		 jge	 SHORT $LN28@PTR_AimTra

; 2776 : 						frontflag |= 0x4;

  00349	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  0034c	83 c8 04	 or	 eax, 4
  0034f	89 45 e0	 mov	 DWORD PTR _frontflag$7[ebp], eax
$LN28@PTR_AimTra:

; 2777 : 
; 2778 : 					if (lastz < *rover->bottomheight && dir == 1 && aimslope > lowslope)

  00352	8b 45 d0	 mov	 eax, DWORD PTR _rover$3[ebp]
  00355	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00358	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lastz
  0035e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00360	7d 19		 jge	 SHORT $LN29@PTR_AimTra
  00362	83 7d e4 01	 cmp	 DWORD PTR _dir$[ebp], 1
  00366	75 13		 jne	 SHORT $LN29@PTR_AimTra
  00368	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  0036d	3b 45 c8	 cmp	 eax, DWORD PTR _lowslope$1[ebp]
  00370	7e 09		 jle	 SHORT $LN29@PTR_AimTra

; 2779 : 						frontflag |= 0x4;

  00372	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  00375	83 c8 04	 or	 eax, 4
  00378	89 45 e0	 mov	 DWORD PTR _frontflag$7[ebp], eax
$LN29@PTR_AimTra:

; 2780 : 				}

  0037b	e9 29 ff ff ff	 jmp	 $LN5@PTR_AimTra
$LN6@PTR_AimTra:

; 2781 : 			}
; 2782 : 			if ((!(frontflag & 0x1) && frontflag & 0x2) || (frontflag & 0x1 && frontflag & 0x4))

  00380	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  00383	83 e0 01	 and	 eax, 1
  00386	75 08		 jne	 SHORT $LN32@PTR_AimTra
  00388	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  0038b	83 e0 02	 and	 eax, 2
  0038e	75 10		 jne	 SHORT $LN31@PTR_AimTra
$LN32@PTR_AimTra:
  00390	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  00393	83 e0 01	 and	 eax, 1
  00396	74 0f		 je	 SHORT $LN30@PTR_AimTra
  00398	8b 45 e0	 mov	 eax, DWORD PTR _frontflag$7[ebp]
  0039b	83 e0 04	 and	 eax, 4
  0039e	74 07		 je	 SHORT $LN30@PTR_AimTra
$LN31@PTR_AimTra:

; 2783 : 				return false;

  003a0	33 c0		 xor	 eax, eax
  003a2	e9 d6 01 00 00	 jmp	 $LN1@PTR_AimTra
$LN30@PTR_AimTra:

; 2784 : 		}
; 2785 : 
; 2786 : 		lastz = FixedMul(aimslope, dist) + shootz;

  003a7	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  003aa	50		 push	 eax
  003ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _aimslope
  003b1	51		 push	 ecx
  003b2	e8 00 00 00 00	 call	 _FixedMul
  003b7	83 c4 08	 add	 esp, 8
  003ba	03 05 00 00 00
	00		 add	 eax, DWORD PTR _shootz
  003c0	a3 00 00 00 00	 mov	 DWORD PTR _lastz, eax

; 2787 : 
; 2788 : 		return true; // shot continues

  003c5	b8 01 00 00 00	 mov	 eax, 1
  003ca	e9 ae 01 00 00	 jmp	 $LN1@PTR_AimTra
$LN8@PTR_AimTra:

; 2789 : 	}
; 2790 : 
; 2791 : 	// shoot a thing
; 2792 : 	th = in->d.thing;

  003cf	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  003d2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003d5	89 4d f8	 mov	 DWORD PTR _th$[ebp], ecx

; 2793 : 	if (th == shootthing)

  003d8	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  003db	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _shootthing
  003e1	75 0a		 jne	 SHORT $LN33@PTR_AimTra

; 2794 : 		return true; // can't shoot self

  003e3	b8 01 00 00 00	 mov	 eax, 1
  003e8	e9 90 01 00 00	 jmp	 $LN1@PTR_AimTra
$LN33@PTR_AimTra:

; 2795 : 
; 2796 : 	if (!(th->flags & MF_SHOOTABLE))

  003ed	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  003f0	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  003f3	83 e1 04	 and	 ecx, 4
  003f6	75 0a		 jne	 SHORT $LN34@PTR_AimTra

; 2797 : 		return true; // corpse or something

  003f8	b8 01 00 00 00	 mov	 eax, 1
  003fd	e9 7b 01 00 00	 jmp	 $LN1@PTR_AimTra
$LN34@PTR_AimTra:

; 2798 : 
; 2799 : 	// friends don't autoaim at friends
; 2800 : 	if (aim_nofriends
; 2801 : 		&& th->player
; 2802 : 		&& (((gametype == GT_CTF || (gametype == GT_MATCH && cv_matchtype.value)) && th->player->ctfteam == aim_nofriends)

  00402	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _aim_nofriends, 0
  00409	74 57		 je	 SHORT $LN35@PTR_AimTra
  0040b	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0040e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00415	74 4b		 je	 SHORT $LN35@PTR_AimTra
  00417	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  0041e	83 f8 04	 cmp	 eax, 4
  00421	74 15		 je	 SHORT $LN38@PTR_AimTra
  00423	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  0042a	83 f8 01	 cmp	 eax, 1
  0042d	75 20		 jne	 SHORT $LN37@PTR_AimTra
  0042f	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  00436	74 17		 je	 SHORT $LN37@PTR_AimTra
$LN38@PTR_AimTra:
  00438	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0043b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00441	8b 91 60 01 00
	00		 mov	 edx, DWORD PTR [ecx+352]
  00447	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _aim_nofriends
  0044d	74 09		 je	 SHORT $LN36@PTR_AimTra
$LN37@PTR_AimTra:
  0044f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _aim_nofriends, -1
  00456	75 0a		 jne	 SHORT $LN35@PTR_AimTra
$LN36@PTR_AimTra:

; 2803 : 		|| aim_nofriends == -1))
; 2804 : 		return true;

  00458	b8 01 00 00 00	 mov	 eax, 1
  0045d	e9 1b 01 00 00	 jmp	 $LN1@PTR_AimTra
$LN35@PTR_AimTra:

; 2805 : 
; 2806 : 	if (th->flags & MF_MONITOR)

  00462	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00465	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00468	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  0046e	74 0a		 je	 SHORT $LN39@PTR_AimTra

; 2807 : 		return true; // don't autoaim at monitors

  00470	b8 01 00 00 00	 mov	 eax, 1
  00475	e9 03 01 00 00	 jmp	 $LN1@PTR_AimTra
$LN39@PTR_AimTra:

; 2808 : 
; 2809 : 	if (th->type == MT_THROWNGRENADE)

  0047a	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0047d	81 78 7c e0 00
	00 00		 cmp	 DWORD PTR [eax+124], 224 ; 000000e0H
  00484	75 0a		 jne	 SHORT $LN40@PTR_AimTra

; 2810 : 		return true; // don't autoaim at grenades

  00486	b8 01 00 00 00	 mov	 eax, 1
  0048b	e9 ed 00 00 00	 jmp	 $LN1@PTR_AimTra
$LN40@PTR_AimTra:

; 2811 : 
; 2812 : 	if (netgame && th->player && th->player->spectator)

  00490	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00497	74 2a		 je	 SHORT $LN41@PTR_AimTra
  00499	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  0049c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  004a3	74 1e		 je	 SHORT $LN41@PTR_AimTra
  004a5	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  004a8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004ae	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  004b5	85 d2		 test	 edx, edx
  004b7	74 0a		 je	 SHORT $LN41@PTR_AimTra

; 2813 : 		return true; // don't autoaim at spectators

  004b9	b8 01 00 00 00	 mov	 eax, 1
  004be	e9 ba 00 00 00	 jmp	 $LN1@PTR_AimTra
$LN41@PTR_AimTra:

; 2814 : 
; 2815 : 	// check angles to see if the thing can be aimed at
; 2816 : 	dist = FixedMul(attackrange, in->frac);

  004c3	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  004c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  004c8	51		 push	 ecx
  004c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _attackrange
  004cf	52		 push	 edx
  004d0	e8 00 00 00 00	 call	 _FixedMul
  004d5	83 c4 08	 add	 esp, 8
  004d8	89 45 e8	 mov	 DWORD PTR _dist$[ebp], eax

; 2817 : 	thingtopslope = FixedDiv(th->z+th->height - shootz, dist);

  004db	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  004de	50		 push	 eax
  004df	8b 4d f8	 mov	 ecx, DWORD PTR _th$[ebp]
  004e2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  004e5	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  004e8	03 50 44	 add	 edx, DWORD PTR [eax+68]
  004eb	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _shootz
  004f1	52		 push	 edx
  004f2	e8 00 00 00 00	 call	 _FixedDiv
  004f7	83 c4 08	 add	 esp, 8
  004fa	89 45 f0	 mov	 DWORD PTR _thingtopslope$[ebp], eax

; 2818 : 
; 2819 : 	//added : 15-02-98: bottomslope is negative!
; 2820 : 	if (thingtopslope < bottomslope)

  004fd	8b 45 f0	 mov	 eax, DWORD PTR _thingtopslope$[ebp]
  00500	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bottomslope
  00506	7d 07		 jge	 SHORT $LN42@PTR_AimTra

; 2821 : 		return true; // shot over the thing

  00508	b8 01 00 00 00	 mov	 eax, 1
  0050d	eb 6e		 jmp	 SHORT $LN1@PTR_AimTra
$LN42@PTR_AimTra:

; 2822 : 
; 2823 : 	thingbottomslope = FixedDiv(th->z - shootz, dist);

  0050f	8b 45 e8	 mov	 eax, DWORD PTR _dist$[ebp]
  00512	50		 push	 eax
  00513	8b 4d f8	 mov	 ecx, DWORD PTR _th$[ebp]
  00516	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00519	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _shootz
  0051f	52		 push	 edx
  00520	e8 00 00 00 00	 call	 _FixedDiv
  00525	83 c4 08	 add	 esp, 8
  00528	89 45 ec	 mov	 DWORD PTR _thingbottomslope$[ebp], eax

; 2824 : 
; 2825 : 	if (thingbottomslope > topslope)

  0052b	8b 45 ec	 mov	 eax, DWORD PTR _thingbottomslope$[ebp]
  0052e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _topslope
  00534	7e 07		 jle	 SHORT $LN43@PTR_AimTra

; 2826 : 		return true; // shot under the thing

  00536	b8 01 00 00 00	 mov	 eax, 1
  0053b	eb 40		 jmp	 SHORT $LN1@PTR_AimTra
$LN43@PTR_AimTra:

; 2827 : 
; 2828 : 	// this thing can be hit!
; 2829 : 	if (thingtopslope > topslope)

  0053d	8b 45 f0	 mov	 eax, DWORD PTR _thingtopslope$[ebp]
  00540	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _topslope
  00546	7e 08		 jle	 SHORT $LN44@PTR_AimTra

; 2830 : 		thingtopslope = topslope;

  00548	a1 00 00 00 00	 mov	 eax, DWORD PTR _topslope
  0054d	89 45 f0	 mov	 DWORD PTR _thingtopslope$[ebp], eax
$LN44@PTR_AimTra:

; 2831 : 
; 2832 : 	if (thingbottomslope < bottomslope)

  00550	8b 45 ec	 mov	 eax, DWORD PTR _thingbottomslope$[ebp]
  00553	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bottomslope
  00559	7d 08		 jge	 SHORT $LN45@PTR_AimTra

; 2833 : 		thingbottomslope = bottomslope;

  0055b	a1 00 00 00 00	 mov	 eax, DWORD PTR _bottomslope
  00560	89 45 ec	 mov	 DWORD PTR _thingbottomslope$[ebp], eax
$LN45@PTR_AimTra:

; 2834 : 
; 2835 : 	//added : 15-02-98: find the slope just in the middle(y) of the thing!
; 2836 : 	aimslope = (thingtopslope + thingbottomslope)/2;

  00563	8b 45 f0	 mov	 eax, DWORD PTR _thingtopslope$[ebp]
  00566	03 45 ec	 add	 eax, DWORD PTR _thingbottomslope$[ebp]
  00569	99		 cdq
  0056a	2b c2		 sub	 eax, edx
  0056c	d1 f8		 sar	 eax, 1
  0056e	a3 00 00 00 00	 mov	 DWORD PTR _aimslope, eax

; 2837 : 	linetarget = th;

  00573	8b 45 f8	 mov	 eax, DWORD PTR _th$[ebp]
  00576	a3 00 00 00 00	 mov	 DWORD PTR _linetarget, eax

; 2838 : 
; 2839 : 	return false; // don't go any farther

  0057b	33 c0		 xor	 eax, eax
$LN1@PTR_AimTra:

; 2840 : }

  0057d	5f		 pop	 edi
  0057e	5e		 pop	 esi
  0057f	5b		 pop	 ebx
  00580	8b e5		 mov	 esp, ebp
  00582	5d		 pop	 ebp
  00583	c3		 ret	 0
_PTR_AimTraverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PTR_SlideTraverse
_TEXT	SEGMENT
tv275 = -108						; size = 4
_whichside$1 = -40					; size = 4
_climbline$2 = -36					; size = 4
_climbangle$3 = -32					; size = 4
_linenum$4 = -28					; size = 4
_side$5 = -24						; size = 4
_fofline$6 = -20					; size = 4
_rover$7 = -16						; size = 4
_checksector$8 = -12					; size = 4
_checkline$9 = -8					; size = 4
_li$ = -4						; size = 4
_in$ = 8						; size = 4
_PTR_SlideTraverse PROC					; COMDAT

; 2170 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2171 : 	line_t *li;
; 2172 : 
; 2173 : 	I_Assert(in->isaline);
; 2174 : 
; 2175 : 	li = in->d.line;

  00009	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 2176 : 
; 2177 : 	if (!(li->flags & ML_TWOSIDED))

  00012	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00015	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00019	83 e1 04	 and	 ecx, 4
  0001c	75 32		 jne	 SHORT $LN5@PTR_SlideT

; 2178 : 	{
; 2179 : 		if (P_PointOnLineSide(slidemo->x, slidemo->y, li))

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00021	50		 push	 eax
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  00028	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0002b	52		 push	 edx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00031	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	85 c0		 test	 eax, eax
  0003f	74 0a		 je	 SHORT $LN6@PTR_SlideT

; 2180 : 			return true; // don't hit the back side

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	e9 53 06 00 00	 jmp	 $LN1@PTR_SlideT
$LN6@PTR_SlideT:

; 2181 : 		goto isblocking;

  0004b	e9 83 00 00 00	 jmp	 $isblocking$39
$LN5@PTR_SlideT:

; 2182 : 	}
; 2183 : 
; 2184 : 	// set openrange, opentop, openbottom
; 2185 : 	P_LineOpening(li);

  00050	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _P_LineOpening
  00059	83 c4 04	 add	 esp, 4

; 2186 : 
; 2187 : 	if (openrange < slidemo->height)

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _openrange
  00067	3b 48 44	 cmp	 ecx, DWORD PTR [eax+68]
  0006a	7d 02		 jge	 SHORT $LN7@PTR_SlideT

; 2188 : 		goto isblocking; // doesn't fit

  0006c	eb 65		 jmp	 SHORT $isblocking$39
$LN7@PTR_SlideT:

; 2189 : 
; 2190 : 	if (opentop - slidemo->z < slidemo->height)

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opentop
  00079	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  00082	3b 4a 44	 cmp	 ecx, DWORD PTR [edx+68]
  00085	7d 02		 jge	 SHORT $LN8@PTR_SlideT

; 2191 : 		goto isblocking; // mobj is too high

  00087	eb 4a		 jmp	 SHORT $isblocking$39
$LN8@PTR_SlideT:

; 2192 : 
; 2193 : 	if (openbottom - slidemo->z > FIXEDSCALE(MAXSTEPMOVE, slidemo->scale))

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0008e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _openbottom
  00094	2b 70 18	 sub	 esi, DWORD PTR [eax+24]
  00097	68 00 00 18 00	 push	 1572864			; 00180000H
  0009c	68 00 00 64 00	 push	 6553600			; 00640000H
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  000a7	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  000ae	c1 e2 10	 shl	 edx, 16			; 00000010H
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _FixedDiv
  000b7	83 c4 08	 add	 esp, 8
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _FixedMul
  000c0	83 c4 08	 add	 esp, 8
  000c3	3b f0		 cmp	 esi, eax
  000c5	7e 02		 jle	 SHORT $LN9@PTR_SlideT

; 2194 : 		goto isblocking; // too big a step up

  000c7	eb 0a		 jmp	 SHORT $isblocking$39
$LN9@PTR_SlideT:

; 2195 : 
; 2196 : 	// this line doesn't block movement
; 2197 : 	return true;

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	e9 cb 05 00 00	 jmp	 $LN1@PTR_SlideT
$isblocking$39:

; 2198 : 
; 2199 : 	// the line does block movement,
; 2200 : 	// see if it is closer than best so far
; 2201 : isblocking:
; 2202 : 	if (li->polyobj && slidemo->player)

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  000d6	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  000da	74 7d		 je	 SHORT $LN11@PTR_SlideT
  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  000e1	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000e8	74 6f		 je	 SHORT $LN11@PTR_SlideT

; 2203 : 	{
; 2204 : 		if ((li->polyobj->lines[0]->backsector->flags & SF_TRIGGERSPECIAL_TOUCH) && !(li->polyobj->flags & POF_NOSPECIALS))

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  000ed	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000f0	ba 04 00 00 00	 mov	 edx, 4
  000f5	6b c2 00	 imul	 eax, edx, 0
  000f8	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  000fb	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000fe	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00101	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00107	83 e1 04	 and	 ecx, 4
  0010a	74 4d		 je	 SHORT $LN11@PTR_SlideT
  0010c	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  0010f	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00112	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00118	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  0011e	75 39		 jne	 SHORT $LN11@PTR_SlideT

; 2205 : 			P_ProcessSpecialSector(slidemo->player, slidemo->subsector->sector, li->polyobj->lines[0]->backsector);

  00120	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00123	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00126	ba 04 00 00 00	 mov	 edx, 4
  0012b	6b c2 00	 imul	 eax, edx, 0
  0012e	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00131	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00134	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00137	50		 push	 eax
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  0013e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00141	8b 02		 mov	 eax, DWORD PTR [edx]
  00143	50		 push	 eax
  00144	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  0014a	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _P_ProcessSpecialSector
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@PTR_SlideT:

; 2206 : 	}
; 2207 : 
; 2208 : 	if (slidemo->player && ((slidemo->player->pflags & PF_GLIDING) || slidemo->player->climbing)
; 2209 : 		&& (slidemo->player->charability == CA_GLIDEANDCLIMB))

  00159	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0015e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00165	0f 84 db 04 00
	00		 je	 $LN24@PTR_SlideT
  0016b	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00170	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00176	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0017c	81 e2 00 00 01
	00		 and	 edx, 65536		; 00010000H
  00182	75 18		 jne	 SHORT $LN13@PTR_SlideT
  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00189	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0018f	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  00196	0f 84 aa 04 00
	00		 je	 $LN24@PTR_SlideT
$LN13@PTR_SlideT:
  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  001a1	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001a7	83 b9 d8 00 00
	00 02		 cmp	 DWORD PTR [ecx+216], 2
  001ae	0f 85 92 04 00
	00		 jne	 $LN24@PTR_SlideT

; 2210 : 	{
; 2211 : 		line_t *checkline = li;

  001b4	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  001b7	89 45 f8	 mov	 DWORD PTR _checkline$9[ebp], eax

; 2212 : 		sector_t *checksector;
; 2213 : 		ffloor_t *rover;
; 2214 : 		boolean fofline = false;

  001ba	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fofline$6[ebp], 0

; 2215 : 		INT32 side = P_PointOnLineSide(slidemo->x, slidemo->y, li);

  001c1	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  001c4	50		 push	 eax
  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  001cb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001ce	52		 push	 edx
  001cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  001d4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001d7	51		 push	 ecx
  001d8	e8 00 00 00 00	 call	 _P_PointOnLineSide
  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e0	89 45 e8	 mov	 DWORD PTR _side$5[ebp], eax

; 2216 : 
; 2217 : 		if (!side && li->backsector)

  001e3	83 7d e8 00	 cmp	 DWORD PTR _side$5[ebp], 0
  001e7	75 14		 jne	 SHORT $LN14@PTR_SlideT
  001e9	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  001ec	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  001f0	74 0b		 je	 SHORT $LN14@PTR_SlideT

; 2218 : 			checksector = li->backsector;

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  001f5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001f8	89 4d f4	 mov	 DWORD PTR _checksector$8[ebp], ecx
  001fb	eb 09		 jmp	 SHORT $LN15@PTR_SlideT
$LN14@PTR_SlideT:

; 2219 : 		else
; 2220 : 			checksector = li->frontsector;

  001fd	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00200	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00203	89 4d f4	 mov	 DWORD PTR _checksector$8[ebp], ecx
$LN15@PTR_SlideT:

; 2221 : 
; 2222 : 		if (checksector->ffloors)

  00206	8b 45 f4	 mov	 eax, DWORD PTR _checksector$8[ebp]
  00209	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00210	0f 84 de 00 00
	00		 je	 $LN3@PTR_SlideT

; 2223 : 		{
; 2224 : 			for (rover = checksector->ffloors; rover; rover = rover->next)

  00216	8b 45 f4	 mov	 eax, DWORD PTR _checksector$8[ebp]
  00219	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0021f	89 4d f0	 mov	 DWORD PTR _rover$7[ebp], ecx
  00222	eb 09		 jmp	 SHORT $LN4@PTR_SlideT
$LN2@PTR_SlideT:
  00224	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  00227	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0022a	89 4d f0	 mov	 DWORD PTR _rover$7[ebp], ecx
$LN4@PTR_SlideT:
  0022d	83 7d f0 00	 cmp	 DWORD PTR _rover$7[ebp], 0
  00231	0f 84 bd 00 00
	00		 je	 $LN3@PTR_SlideT

; 2225 : 			{
; 2226 : 				if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_BLOCKPLAYER) || (rover->flags & FF_BUSTUP))

  00237	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  0023a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0023d	83 e1 01	 and	 ecx, 1
  00240	74 19		 je	 SHORT $LN18@PTR_SlideT
  00242	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  00245	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00248	83 e1 02	 and	 ecx, 2
  0024b	74 0e		 je	 SHORT $LN18@PTR_SlideT
  0024d	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  00250	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00253	81 e1 00 00 80
	00		 and	 ecx, 8388608		; 00800000H
  00259	74 02		 je	 SHORT $LN17@PTR_SlideT
$LN18@PTR_SlideT:

; 2227 : 					continue;

  0025b	eb c7		 jmp	 SHORT $LN2@PTR_SlideT
$LN17@PTR_SlideT:

; 2228 : 
; 2229 : 				if (*rover->topheight < slidemo->z)

  0025d	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  00260	8b 08		 mov	 ecx, DWORD PTR [eax]
  00262	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  00268	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026a	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0026d	7d 02		 jge	 SHORT $LN19@PTR_SlideT

; 2230 : 					continue;

  0026f	eb b3		 jmp	 SHORT $LN2@PTR_SlideT
$LN19@PTR_SlideT:

; 2231 : 
; 2232 : 				if (*rover->bottomheight > slidemo->z + slidemo->height)

  00271	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  00274	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00277	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  0027d	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00280	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  00286	03 42 44	 add	 eax, DWORD PTR [edx+68]
  00289	39 01		 cmp	 DWORD PTR [ecx], eax
  0028b	7e 02		 jle	 SHORT $LN20@PTR_SlideT

; 2233 : 					continue;

  0028d	eb 95		 jmp	 SHORT $LN2@PTR_SlideT
$LN20@PTR_SlideT:

; 2234 : 
; 2235 : 				// Got this far, so I guess it's climbable.
; 2236 : 				if (rover->master->flags & ML_TFERLINE)

  0028f	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  00292	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00295	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00299	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  0029f	74 4c		 je	 SHORT $LN21@PTR_SlideT

; 2237 : 				{
; 2238 : 					size_t linenum = li-checksector->lines[0];

  002a1	b8 04 00 00 00	 mov	 eax, 4
  002a6	6b c8 00	 imul	 ecx, eax, 0
  002a9	8b 55 f4	 mov	 edx, DWORD PTR _checksector$8[ebp]
  002ac	8b 82 8c 00 00
	00		 mov	 eax, DWORD PTR [edx+140]
  002b2	8b 55 fc	 mov	 edx, DWORD PTR _li$[ebp]
  002b5	2b 14 08	 sub	 edx, DWORD PTR [eax+ecx]
  002b8	8b c2		 mov	 eax, edx
  002ba	99		 cdq
  002bb	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  002c0	f7 f9		 idiv	 ecx
  002c2	89 45 e4	 mov	 DWORD PTR _linenum$4[ebp], eax

; 2239 : 					checkline = rover->master->frontsector->lines[0] + linenum;

  002c5	8b 45 f0	 mov	 eax, DWORD PTR _rover$7[ebp]
  002c8	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  002cb	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  002ce	b8 04 00 00 00	 mov	 eax, 4
  002d3	6b c8 00	 imul	 ecx, eax, 0
  002d6	8b 92 8c 00 00
	00		 mov	 edx, DWORD PTR [edx+140]
  002dc	6b 45 e4 4c	 imul	 eax, DWORD PTR _linenum$4[ebp], 76
  002e0	03 04 0a	 add	 eax, DWORD PTR [edx+ecx]
  002e3	89 45 f8	 mov	 DWORD PTR _checkline$9[ebp], eax

; 2240 : 					fofline = true;

  002e6	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _fofline$6[ebp], 1
$LN21@PTR_SlideT:

; 2241 : 				}
; 2242 : 
; 2243 : 				break;

  002ed	eb 05		 jmp	 SHORT $LN3@PTR_SlideT

; 2244 : 			}

  002ef	e9 30 ff ff ff	 jmp	 $LN2@PTR_SlideT
$LN3@PTR_SlideT:

; 2245 : 		}
; 2246 : 
; 2247 : 		// see about climbing on the wall
; 2248 : 		if (!(checkline->flags & ML_NOCLIMB))

  002f4	8b 45 f8	 mov	 eax, DWORD PTR _checkline$9[ebp]
  002f7	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  002fb	83 e1 40	 and	 ecx, 64			; 00000040H
  002fe	0f 85 42 03 00
	00		 jne	 $LN24@PTR_SlideT

; 2249 : 		{
; 2250 : 			angle_t climbangle, climbline = R_PointToAngle2(li->v1->x, li->v1->y, li->v2->x, li->v2->y);

  00304	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00307	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0030a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0030d	52		 push	 edx
  0030e	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00311	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00314	8b 11		 mov	 edx, DWORD PTR [ecx]
  00316	52		 push	 edx
  00317	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  0031a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0031f	52		 push	 edx
  00320	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00323	8b 08		 mov	 ecx, DWORD PTR [eax]
  00325	8b 11		 mov	 edx, DWORD PTR [ecx]
  00327	52		 push	 edx
  00328	e8 00 00 00 00	 call	 _R_PointToAngle2
  0032d	83 c4 10	 add	 esp, 16			; 00000010H
  00330	89 45 dc	 mov	 DWORD PTR _climbline$2[ebp], eax

; 2251 : 			INT32 whichside = P_PointOnLineSide(slidemo->x, slidemo->y, li);

  00333	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00336	50		 push	 eax
  00337	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  0033d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00340	52		 push	 edx
  00341	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00346	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00349	51		 push	 ecx
  0034a	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0034f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00352	89 45 d8	 mov	 DWORD PTR _whichside$1[ebp], eax

; 2252 : 
; 2253 : 			if (whichside) // on second side?

  00355	83 7d d8 00	 cmp	 DWORD PTR _whichside$1[ebp], 0
  00359	74 0b		 je	 SHORT $LN23@PTR_SlideT

; 2254 : 				climbline += ANGLE_180;

  0035b	8b 45 dc	 mov	 eax, DWORD PTR _climbline$2[ebp]
  0035e	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  00363	89 45 dc	 mov	 DWORD PTR _climbline$2[ebp], eax
$LN23@PTR_SlideT:

; 2255 : 
; 2256 : 			if (((!slidemo->player->climbing
; 2257 : 				&& abs(slidemo->angle - ANGLE_90 - climbline) < ANGLE_45) ||
; 2258 : 
; 2259 : 				(slidemo->player->climbing == 1
; 2260 : 				&& abs(slidemo->angle - climbline) < ANGLE_135))
; 2261 : 
; 2262 : 				&& P_IsClimbingValid(slidemo->player, climbangle =

  00366	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0036b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00371	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  00378	75 21		 jne	 SHORT $LN26@PTR_SlideT
  0037a	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0037f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00382	81 e9 00 00 00
	40		 sub	 ecx, 1073741824		; 40000000H
  00388	2b 4d dc	 sub	 ecx, DWORD PTR _climbline$2[ebp]
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 _abs
  00391	83 c4 04	 add	 esp, 4
  00394	3d 00 00 00 20	 cmp	 eax, 536870912		; 20000000H
  00399	7c 37		 jl	 SHORT $LN25@PTR_SlideT
$LN26@PTR_SlideT:
  0039b	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  003a0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  003a6	83 b9 24 01 00
	00 01		 cmp	 DWORD PTR [ecx+292], 1
  003ad	0f 85 93 02 00
	00		 jne	 $LN24@PTR_SlideT
  003b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  003b8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  003bb	2b 4d dc	 sub	 ecx, DWORD PTR _climbline$2[ebp]
  003be	51		 push	 ecx
  003bf	e8 00 00 00 00	 call	 _abs
  003c4	83 c4 04	 add	 esp, 4
  003c7	3d 00 00 00 60	 cmp	 eax, 1610612736		; 60000000H
  003cc	0f 8d 74 02 00
	00		 jge	 $LN24@PTR_SlideT
$LN25@PTR_SlideT:
  003d2	83 7d d8 00	 cmp	 DWORD PTR _whichside$1[ebp], 0
  003d6	74 09		 je	 SHORT $LN37@PTR_SlideT
  003d8	c7 45 94 ff ff
	ff ff		 mov	 DWORD PTR tv275[ebp], -1
  003df	eb 07		 jmp	 SHORT $LN38@PTR_SlideT
$LN37@PTR_SlideT:
  003e1	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv275[ebp], 1
$LN38@PTR_SlideT:
  003e8	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  003eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003ee	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003f1	52		 push	 edx
  003f2	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  003f5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  003fa	52		 push	 edx
  003fb	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  003fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00400	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00403	52		 push	 edx
  00404	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00407	8b 08		 mov	 ecx, DWORD PTR [eax]
  00409	8b 11		 mov	 edx, DWORD PTR [ecx]
  0040b	52		 push	 edx
  0040c	e8 00 00 00 00	 call	 _R_PointToAngle2
  00411	83 c4 10	 add	 esp, 16			; 00000010H
  00414	8b 4d 94	 mov	 ecx, DWORD PTR tv275[ebp]
  00417	c1 e1 1e	 shl	 ecx, 30			; 0000001eH
  0041a	03 c1		 add	 eax, ecx
  0041c	89 45 e0	 mov	 DWORD PTR _climbangle$3[ebp], eax
  0041f	8b 55 e0	 mov	 edx, DWORD PTR _climbangle$3[ebp]
  00422	52		 push	 edx
  00423	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00428	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0042e	51		 push	 ecx
  0042f	e8 00 00 00 00	 call	 _P_IsClimbingValid
  00434	83 c4 08	 add	 esp, 8
  00437	85 c0		 test	 eax, eax
  00439	0f 84 07 02 00
	00		 je	 $LN24@PTR_SlideT

; 2263 : 				R_PointToAngle2(li->v1->x, li->v1->y, li->v2->x, li->v2->y)
; 2264 : 				+ (ANGLE_90 * (whichside ? -1 : 1))))
; 2265 : 			{
; 2266 : 				slidemo->angle = climbangle;

  0043f	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00444	8b 4d e0	 mov	 ecx, DWORD PTR _climbangle$3[ebp]
  00447	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 2267 : 				if (slidemo->player == &players[consoleplayer])

  0044a	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00454	05 00 00 00 00	 add	 eax, OFFSET _players
  00459	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  0045f	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  00465	75 10		 jne	 SHORT $LN27@PTR_SlideT

; 2268 : 					localangle = slidemo->angle;

  00467	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0046c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0046f	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle, ecx
  00475	eb 34		 jmp	 SHORT $LN29@PTR_SlideT
$LN27@PTR_SlideT:

; 2269 : 				else if (splitscreen && slidemo->player ==

  00477	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0047e	74 2b		 je	 SHORT $LN29@PTR_SlideT
  00480	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0048a	05 00 00 00 00	 add	 eax, OFFSET _players
  0048f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  00495	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  0049b	75 0e		 jne	 SHORT $LN29@PTR_SlideT

; 2270 : 					&players[secondarydisplayplayer])
; 2271 : 				{
; 2272 : 					localangle2 = slidemo->angle;

  0049d	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  004a2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  004a5	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle2, ecx
$LN29@PTR_SlideT:

; 2273 : 				}
; 2274 : 
; 2275 : 				if (!slidemo->player->climbing)

  004ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  004b0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004b6	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  004bd	75 15		 jne	 SHORT $LN30@PTR_SlideT

; 2276 : 					slidemo->player->climbing = 5;

  004bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  004c4	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004ca	c7 81 24 01 00
	00 05 00 00 00	 mov	 DWORD PTR [ecx+292], 5
$LN30@PTR_SlideT:

; 2277 : 
; 2278 : 				slidemo->player->pflags &= ~PF_GLIDING;

  004d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  004d9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004df	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  004e5	81 e2 ff ff fe
	ff		 and	 edx, -65537		; fffeffffH
  004eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  004f0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004f6	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 2279 : 				slidemo->player->pflags &= ~PF_SPINNING;

  004fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00501	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00507	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0050d	81 e2 ff df ff
	ff		 and	 edx, -8193		; ffffdfffH
  00513	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00518	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0051e	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 2280 : 				slidemo->player->pflags &= ~PF_JUMPED;

  00524	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00529	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0052f	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00535	81 e2 ff ef ff
	ff		 and	 edx, -4097		; ffffefffH
  0053b	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00540	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00546	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 2281 : 				slidemo->player->pflags &= ~PF_THOKKED;

  0054c	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00551	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00557	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0055d	81 e2 ff 7f ff
	ff		 and	 edx, -32769		; ffff7fffH
  00563	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00568	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0056e	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 2282 : 				slidemo->player->glidetime = 0;

  00574	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00579	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0057f	c7 81 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+288], 0

; 2283 : 				slidemo->player->secondjump = 0;

  00589	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0058e	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00594	c6 81 14 01 00
	00 00		 mov	 BYTE PTR [ecx+276], 0

; 2284 : 
; 2285 : 				if (slidemo->player->climbing > 1)

  0059b	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  005a0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005a6	83 b9 24 01 00
	00 01		 cmp	 DWORD PTR [ecx+292], 1
  005ad	7e 26		 jle	 SHORT $LN31@PTR_SlideT

; 2286 : 					slidemo->momz = slidemo->momx = slidemo->momy = 0;

  005af	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  005b4	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  005bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  005c1	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0
  005c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  005ce	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0
$LN31@PTR_SlideT:

; 2287 : 
; 2288 : 				if (fofline)

  005d5	83 7d ec 00	 cmp	 DWORD PTR _fofline$6[ebp], 0
  005d9	74 07		 je	 SHORT $LN32@PTR_SlideT

; 2289 : 					whichside = 0;

  005db	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _whichside$1[ebp], 0
$LN32@PTR_SlideT:

; 2290 : 
; 2291 : 				if (!whichside)

  005e2	83 7d d8 00	 cmp	 DWORD PTR _whichside$1[ebp], 0
  005e6	75 41		 jne	 SHORT $LN33@PTR_SlideT

; 2292 : 				{
; 2293 : 					slidemo->player->lastsidehit = checkline->sidenum[whichside];

  005e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  005ed	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  005f3	8b 55 d8	 mov	 edx, DWORD PTR _whichside$1[ebp]
  005f6	8b 45 f8	 mov	 eax, DWORD PTR _checkline$9[ebp]
  005f9	66 8b 54 50 16	 mov	 dx, WORD PTR [eax+edx*2+22]
  005fe	66 89 91 d6 01
	00 00		 mov	 WORD PTR [ecx+470], dx

; 2294 : 					slidemo->player->lastlinehit = (INT16)(checkline - lines);

  00605	8b 45 f8	 mov	 eax, DWORD PTR _checkline$9[ebp]
  00608	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _lines
  0060e	99		 cdq
  0060f	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00614	f7 f9		 idiv	 ecx
  00616	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  0061c	8b 8a a4 00 00
	00		 mov	 ecx, DWORD PTR [edx+164]
  00622	66 89 81 d8 01
	00 00		 mov	 WORD PTR [ecx+472], ax
$LN33@PTR_SlideT:

; 2295 : 				}
; 2296 : 
; 2297 : 				P_Thrust(slidemo, slidemo->angle, 5*FRACUNIT);

  00629	68 00 00 05 00	 push	 327680			; 00050000H
  0062e	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00633	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00636	51		 push	 ecx
  00637	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _slidemo
  0063d	52		 push	 edx
  0063e	e8 00 00 00 00	 call	 _P_Thrust
  00643	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@PTR_SlideT:

; 2298 : 			}
; 2299 : 		}
; 2300 : 	}
; 2301 : 
; 2302 : 	if (in->frac < bestslidefrac && (!slidemo->player || !slidemo->player->climbing))

  00646	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00649	8b 08		 mov	 ecx, DWORD PTR [eax]
  0064b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _bestslidefrac
  00651	7d 49		 jge	 SHORT $LN34@PTR_SlideT
  00653	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00658	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0065f	74 14		 je	 SHORT $LN35@PTR_SlideT
  00661	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00666	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0066c	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  00673	75 27		 jne	 SHORT $LN34@PTR_SlideT
$LN35@PTR_SlideT:

; 2303 : 	{
; 2304 : 		secondslidefrac = bestslidefrac;

  00675	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  0067a	a3 00 00 00 00	 mov	 DWORD PTR _secondslidefrac, eax

; 2305 : 		secondslideline = bestslideline;

  0067f	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslideline
  00684	a3 00 00 00 00	 mov	 DWORD PTR _secondslideline, eax

; 2306 : 		bestslidefrac = in->frac;

  00689	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0068c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0068e	89 0d 00 00 00
	00		 mov	 DWORD PTR _bestslidefrac, ecx

; 2307 : 		bestslideline = li;

  00694	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00697	a3 00 00 00 00	 mov	 DWORD PTR _bestslideline, eax
$LN34@PTR_SlideT:

; 2308 : 	}
; 2309 : 
; 2310 : 	return false; // stop

  0069c	33 c0		 xor	 eax, eax
$LN1@PTR_SlideT:

; 2311 : }

  0069e	5f		 pop	 edi
  0069f	5e		 pop	 esi
  006a0	5b		 pop	 ebx
  006a1	8b e5		 mov	 esp, ebp
  006a3	5d		 pop	 ebp
  006a4	c3		 ret	 0
_PTR_SlideTraverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_IsClimbingValid
_TEXT	SEGMENT
_rover$1 = -32						; size = 4
_boostup$2 = -28					; size = 4
_thrust$3 = -24						; size = 4
_floorclimb$4 = -20					; size = 4
_climb$ = -16						; size = 4
_glidesector$ = -12					; size = 4
_platy$ = -8						; size = 4
_platx$ = -4						; size = 4
_player$ = 8						; size = 4
_angle$ = 12						; size = 4
_P_IsClimbingValid PROC					; COMDAT

; 2036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2037 : 	fixed_t platx, platy;
; 2038 : 	subsector_t *glidesector;
; 2039 : 	boolean climb = true;

  00009	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _climb$[ebp], 1

; 2040 : 
; 2041 : 	platx = P_ReturnThrustX(player->mo, angle, player->mo->radius + FIXEDSCALE(8*FRACUNIT, player->mo->scale));

  00010	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00013	8b 30		 mov	 esi, DWORD PTR [eax]
  00015	68 00 00 08 00	 push	 524288			; 00080000H
  0001a	68 00 00 64 00	 push	 6553600			; 00640000H
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	0f b7 82 cc 00
	00 00		 movzx	 eax, WORD PTR [edx+204]
  0002b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _FixedDiv
  00034	83 c4 08	 add	 esp, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _FixedMul
  0003d	83 c4 08	 add	 esp, 8
  00040	03 46 40	 add	 eax, DWORD PTR [esi+64]
  00043	50		 push	 eax
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _angle$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0004b	8b 02		 mov	 eax, DWORD PTR [edx]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _P_ReturnThrustX
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 fc	 mov	 DWORD PTR _platx$[ebp], eax

; 2042 : 	platy = P_ReturnThrustY(player->mo, angle, player->mo->radius + FIXEDSCALE(8*FRACUNIT, player->mo->scale));

  00059	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0005c	8b 30		 mov	 esi, DWORD PTR [eax]
  0005e	68 00 00 08 00	 push	 524288			; 00080000H
  00063	68 00 00 64 00	 push	 6553600			; 00640000H
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0006b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006d	0f b7 82 cc 00
	00 00		 movzx	 eax, WORD PTR [edx+204]
  00074	c1 e0 10	 shl	 eax, 16			; 00000010H
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _FixedDiv
  0007d	83 c4 08	 add	 esp, 8
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _FixedMul
  00086	83 c4 08	 add	 esp, 8
  00089	03 46 40	 add	 eax, DWORD PTR [esi+64]
  0008c	50		 push	 eax
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR _angle$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00094	8b 02		 mov	 eax, DWORD PTR [edx]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _P_ReturnThrustY
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	89 45 f8	 mov	 DWORD PTR _platy$[ebp], eax

; 2043 : 
; 2044 : 	glidesector = R_PointInSubsector(player->mo->x + platx, player->mo->y + platy);

  000a2	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000aa	03 55 f8	 add	 edx, DWORD PTR _platy$[ebp]
  000ad	52		 push	 edx
  000ae	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000b6	03 55 fc	 add	 edx, DWORD PTR _platx$[ebp]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _R_PointInSubsector
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 45 f4	 mov	 DWORD PTR _glidesector$[ebp], eax

; 2045 : 
; 2046 : 	if (glidesector->sector != player->mo->subsector->sector)

  000c5	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000cd	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  000d0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d2	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  000d4	0f 84 12 05 00
	00		 je	 $LN5@P_IsClimbi

; 2047 : 	{
; 2048 : 		boolean floorclimb = false, thrust = false, boostup = false;

  000da	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 0
  000e1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 0
  000e8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 0

; 2049 : 
; 2050 : 		if (glidesector->sector->ffloors)

  000ef	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  000f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f4	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  000fb	0f 84 ec 01 00
	00		 je	 $LN3@P_IsClimbi

; 2051 : 		{
; 2052 : 			ffloor_t *rover;
; 2053 : 			for (rover = glidesector->sector->ffloors; rover; rover = rover->next)

  00101	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  0010c	89 55 e0	 mov	 DWORD PTR _rover$1[ebp], edx
  0010f	eb 09		 jmp	 SHORT $LN4@P_IsClimbi
$LN2@P_IsClimbi:
  00111	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00114	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00117	89 4d e0	 mov	 DWORD PTR _rover$1[ebp], ecx
$LN4@P_IsClimbi:
  0011a	83 7d e0 00	 cmp	 DWORD PTR _rover$1[ebp], 0
  0011e	0f 84 c9 01 00
	00		 je	 $LN3@P_IsClimbi

; 2054 : 			{
; 2055 : 				if (!(rover->flags & FF_EXISTS) || !(rover->flags & FF_BLOCKPLAYER))

  00124	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00127	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0012a	83 e1 01	 and	 ecx, 1
  0012d	74 0b		 je	 SHORT $LN8@P_IsClimbi
  0012f	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00132	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00135	83 e1 02	 and	 ecx, 2
  00138	75 02		 jne	 SHORT $LN7@P_IsClimbi
$LN8@P_IsClimbi:

; 2056 : 					continue;

  0013a	eb d5		 jmp	 SHORT $LN2@P_IsClimbi
$LN7@P_IsClimbi:

; 2057 : 
; 2058 : 				floorclimb = true;

  0013c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1

; 2059 : 
; 2060 : 				if (player->mo->eflags & MFE_VERTICALFLIP)

  00143	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00146	8b 08		 mov	 ecx, DWORD PTR [eax]
  00148	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  0014e	83 e2 20	 and	 edx, 32			; 00000020H
  00151	0f 84 cf 00 00
	00		 je	 $LN9@P_IsClimbi

; 2061 : 				{
; 2062 : 					if ((*rover->topheight < player->mo->z + player->mo->height) && ((player->mo->z + player->mo->height + player->mo->momz) < *rover->topheight))

  00157	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  0015a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0015f	8b 02		 mov	 eax, DWORD PTR [edx]
  00161	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00164	8b 12		 mov	 edx, DWORD PTR [edx]
  00166	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00169	03 42 44	 add	 eax, DWORD PTR [edx+68]
  0016c	39 01		 cmp	 DWORD PTR [ecx], eax
  0016e	7d 2f		 jge	 SHORT $LN11@P_IsClimbi
  00170	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00173	8b 08		 mov	 ecx, DWORD PTR [eax]
  00175	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00178	8b 02		 mov	 eax, DWORD PTR [edx]
  0017a	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0017d	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00180	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00183	8b 02		 mov	 eax, DWORD PTR [edx]
  00185	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  00188	8b 55 e0	 mov	 edx, DWORD PTR _rover$1[ebp]
  0018b	8b 02		 mov	 eax, DWORD PTR [edx]
  0018d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0018f	7d 0e		 jge	 SHORT $LN11@P_IsClimbi

; 2063 : 					{
; 2064 : 						floorclimb = true;

  00191	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1

; 2065 : 						boostup = false;

  00198	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 0
$LN11@P_IsClimbi:

; 2066 : 					}
; 2067 : 					if (*rover->topheight < player->mo->z) // Waaaay below the ledge.

  0019f	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  001a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a4	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  001a7	8b 02		 mov	 eax, DWORD PTR [edx]
  001a9	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001ab	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  001ae	7d 15		 jge	 SHORT $LN12@P_IsClimbi

; 2068 : 					{
; 2069 : 						floorclimb = false;

  001b0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 0

; 2070 : 						boostup = false;

  001b7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 0

; 2071 : 						thrust = false;

  001be	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 0
$LN12@P_IsClimbi:

; 2072 : 					}
; 2073 : 					if (*rover->bottomheight > player->mo->z + player->mo->height - FIXEDSCALE(16*FRACUNIT,player->mo->scale))

  001c5	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  001c8	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  001ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d0	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  001d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d5	8b 7a 18	 mov	 edi, DWORD PTR [edx+24]
  001d8	03 79 44	 add	 edi, DWORD PTR [ecx+68]
  001db	68 00 00 10 00	 push	 1048576			; 00100000H
  001e0	68 00 00 64 00	 push	 6553600			; 00640000H
  001e5	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  001e8	8b 02		 mov	 eax, DWORD PTR [edx]
  001ea	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  001f1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _FixedDiv
  001fa	83 c4 08	 add	 esp, 8
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 _FixedMul
  00203	83 c4 08	 add	 esp, 8
  00206	2b f8		 sub	 edi, eax
  00208	39 3e		 cmp	 DWORD PTR [esi], edi
  0020a	7e 15		 jle	 SHORT $LN13@P_IsClimbi

; 2074 : 					{
; 2075 : 						floorclimb = false;

  0020c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 0

; 2076 : 						thrust = true;

  00213	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 1

; 2077 : 						boostup = true;

  0021a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 1
$LN13@P_IsClimbi:

; 2078 : 					}
; 2079 : 				}

  00221	e9 ba 00 00 00	 jmp	 $LN16@P_IsClimbi
$LN9@P_IsClimbi:

; 2080 : 				else
; 2081 : 				{
; 2082 : 					if ((*rover->bottomheight > player->mo->z) && ((player->mo->z - player->mo->momz) > *rover->bottomheight))

  00226	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00229	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0022c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0022f	8b 02		 mov	 eax, DWORD PTR [edx]
  00231	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00233	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00236	7e 28		 jle	 SHORT $LN14@P_IsClimbi
  00238	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0023b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023d	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00240	8b 02		 mov	 eax, DWORD PTR [edx]
  00242	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00245	2b 48 50	 sub	 ecx, DWORD PTR [eax+80]
  00248	8b 55 e0	 mov	 edx, DWORD PTR _rover$1[ebp]
  0024b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0024e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00250	7e 0e		 jle	 SHORT $LN14@P_IsClimbi

; 2083 : 					{
; 2084 : 						floorclimb = true;

  00252	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1

; 2085 : 						boostup = false;

  00259	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 0
$LN14@P_IsClimbi:

; 2086 : 					}
; 2087 : 					if (*rover->bottomheight > player->mo->z + player->mo->height) // Waaaay below the ledge.

  00260	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00263	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00266	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00269	8b 02		 mov	 eax, DWORD PTR [edx]
  0026b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0026e	8b 12		 mov	 edx, DWORD PTR [edx]
  00270	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00273	03 42 44	 add	 eax, DWORD PTR [edx+68]
  00276	39 01		 cmp	 DWORD PTR [ecx], eax
  00278	7e 15		 jle	 SHORT $LN15@P_IsClimbi

; 2088 : 					{
; 2089 : 						floorclimb = false;

  0027a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 0

; 2090 : 						boostup = false;

  00281	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 0

; 2091 : 						thrust = false;

  00288	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 0
$LN15@P_IsClimbi:

; 2092 : 					}
; 2093 : 					if (*rover->topheight < player->mo->z + FIXEDSCALE(16*FRACUNIT,player->mo->scale))

  0028f	8b 45 e0	 mov	 eax, DWORD PTR _rover$1[ebp]
  00292	8b 30		 mov	 esi, DWORD PTR [eax]
  00294	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00297	8b 39		 mov	 edi, DWORD PTR [ecx]
  00299	68 00 00 10 00	 push	 1048576			; 00100000H
  0029e	68 00 00 64 00	 push	 6553600			; 00640000H
  002a3	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  002a6	8b 02		 mov	 eax, DWORD PTR [edx]
  002a8	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  002af	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 _FixedDiv
  002b8	83 c4 08	 add	 esp, 8
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 _FixedMul
  002c1	83 c4 08	 add	 esp, 8
  002c4	03 47 18	 add	 eax, DWORD PTR [edi+24]
  002c7	39 06		 cmp	 DWORD PTR [esi], eax
  002c9	7d 15		 jge	 SHORT $LN16@P_IsClimbi

; 2094 : 					{
; 2095 : 						floorclimb = false;

  002cb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 0

; 2096 : 						thrust = true;

  002d2	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 1

; 2097 : 						boostup = true;

  002d9	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 1
$LN16@P_IsClimbi:

; 2098 : 					}
; 2099 : 				}
; 2100 : 
; 2101 : 				if (floorclimb)

  002e0	83 7d ec 00	 cmp	 DWORD PTR _floorclimb$4[ebp], 0
  002e4	74 02		 je	 SHORT $LN17@P_IsClimbi

; 2102 : 					break;

  002e6	eb 05		 jmp	 SHORT $LN3@P_IsClimbi
$LN17@P_IsClimbi:

; 2103 : 			}

  002e8	e9 24 fe ff ff	 jmp	 $LN2@P_IsClimbi
$LN3@P_IsClimbi:

; 2104 : 		}
; 2105 : 
; 2106 : 		if (player->mo->eflags & MFE_VERTICALFLIP)

  002ed	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  002f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f2	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  002f8	83 e2 20	 and	 edx, 32			; 00000020H
  002fb	0f 84 72 01 00
	00		 je	 $LN18@P_IsClimbi

; 2107 : 		{
; 2108 : 			if ((glidesector->sector->floorheight <= player->mo->z + player->mo->height)
; 2109 : 				&& ((player->mo->z + player->mo->momz) <= glidesector->sector->floorheight))

  00301	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00304	8b 08		 mov	 ecx, DWORD PTR [eax]
  00306	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00309	8b 02		 mov	 eax, DWORD PTR [edx]
  0030b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0030e	8b 12		 mov	 edx, DWORD PTR [edx]
  00310	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00313	03 42 44	 add	 eax, DWORD PTR [edx+68]
  00316	39 01		 cmp	 DWORD PTR [ecx], eax
  00318	7f 20		 jg	 SHORT $LN20@P_IsClimbi
  0031a	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0031d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031f	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00322	8b 02		 mov	 eax, DWORD PTR [edx]
  00324	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00327	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  0032a	8b 55 f4	 mov	 edx, DWORD PTR _glidesector$[ebp]
  0032d	8b 02		 mov	 eax, DWORD PTR [edx]
  0032f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00331	7f 07		 jg	 SHORT $LN20@P_IsClimbi

; 2110 : 				floorclimb = true;

  00333	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1
$LN20@P_IsClimbi:

; 2111 : 
; 2112 : 			if (!floorclimb && glidesector->sector->ceilingheight > player->mo->z - FIXEDSCALE(16*FRACUNIT,player->mo->scale)
; 2113 : 				&& (glidesector->sector->floorpic == skyflatnum

  0033a	83 7d ec 00	 cmp	 DWORD PTR _floorclimb$4[ebp], 0
  0033e	0f 85 9b 00 00
	00		 jne	 $LN21@P_IsClimbi
  00344	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00347	8b 30		 mov	 esi, DWORD PTR [eax]
  00349	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0034c	8b 39		 mov	 edi, DWORD PTR [ecx]
  0034e	68 00 00 10 00	 push	 1048576			; 00100000H
  00353	68 00 00 64 00	 push	 6553600			; 00640000H
  00358	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0035b	8b 02		 mov	 eax, DWORD PTR [edx]
  0035d	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00364	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00367	51		 push	 ecx
  00368	e8 00 00 00 00	 call	 _FixedDiv
  0036d	83 c4 08	 add	 esp, 8
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _FixedMul
  00376	83 c4 08	 add	 esp, 8
  00379	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0037c	2b d0		 sub	 edx, eax
  0037e	39 56 04	 cmp	 DWORD PTR [esi+4], edx
  00381	7e 5c		 jle	 SHORT $LN21@P_IsClimbi
  00383	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00386	8b 08		 mov	 ecx, DWORD PTR [eax]
  00388	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0038b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _skyflatnum
  00391	74 3e		 je	 SHORT $LN22@P_IsClimbi
  00393	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00396	8b 30		 mov	 esi, DWORD PTR [eax]
  00398	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  0039b	8b 39		 mov	 edi, DWORD PTR [ecx]
  0039d	68 00 00 08 00	 push	 524288			; 00080000H
  003a2	68 00 00 64 00	 push	 6553600			; 00640000H
  003a7	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  003aa	8b 02		 mov	 eax, DWORD PTR [edx]
  003ac	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  003b3	c1 e1 10	 shl	 ecx, 16			; 00000010H
  003b6	51		 push	 ecx
  003b7	e8 00 00 00 00	 call	 _FixedDiv
  003bc	83 c4 08	 add	 esp, 8
  003bf	50		 push	 eax
  003c0	e8 00 00 00 00	 call	 _FixedMul
  003c5	83 c4 08	 add	 esp, 8
  003c8	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  003cb	2b d0		 sub	 edx, eax
  003cd	39 16		 cmp	 DWORD PTR [esi], edx
  003cf	7d 0e		 jge	 SHORT $LN21@P_IsClimbi
$LN22@P_IsClimbi:

; 2114 : 				|| glidesector->sector->floorheight
; 2115 : 				< (player->mo->z - FIXEDSCALE(8*FRACUNIT,player->mo->scale))))
; 2116 : 			{
; 2117 : 				thrust = true;

  003d1	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 1

; 2118 : 				boostup = true;

  003d8	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 1
$LN21@P_IsClimbi:

; 2119 : 				// Play climb-up animation here
; 2120 : 			}
; 2121 : 
; 2122 : 			if ((glidesector->sector->floorheight > player->mo->z)
; 2123 : 				&& glidesector->sector->floorpic == skyflatnum)

  003df	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  003e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e4	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  003e7	8b 02		 mov	 eax, DWORD PTR [edx]
  003e9	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003eb	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  003ee	7e 17		 jle	 SHORT $LN23@P_IsClimbi
  003f0	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003f8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _skyflatnum
  003fe	75 07		 jne	 SHORT $LN23@P_IsClimbi

; 2124 : 				return false;

  00400	33 c0		 xor	 eax, eax
  00402	e9 e7 01 00 00	 jmp	 $LN1@P_IsClimbi
$LN23@P_IsClimbi:

; 2125 : 
; 2126 : 			if ((player->mo->z + player->mo->height - FIXEDSCALE(16*FRACUNIT,player->mo->scale) > glidesector->sector->ceilingheight)
; 2127 : 				|| (player->mo->z + player->mo->height <= glidesector->sector->floorheight))

  00407	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  0040a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0040c	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0040f	8b 02		 mov	 eax, DWORD PTR [edx]
  00411	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  00414	03 70 44	 add	 esi, DWORD PTR [eax+68]
  00417	68 00 00 10 00	 push	 1048576			; 00100000H
  0041c	68 00 00 64 00	 push	 6553600			; 00640000H
  00421	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00424	8b 11		 mov	 edx, DWORD PTR [ecx]
  00426	0f b7 82 cc 00
	00 00		 movzx	 eax, WORD PTR [edx+204]
  0042d	c1 e0 10	 shl	 eax, 16			; 00000010H
  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 _FixedDiv
  00436	83 c4 08	 add	 esp, 8
  00439	50		 push	 eax
  0043a	e8 00 00 00 00	 call	 _FixedMul
  0043f	83 c4 08	 add	 esp, 8
  00442	2b f0		 sub	 esi, eax
  00444	8b 4d f4	 mov	 ecx, DWORD PTR _glidesector$[ebp]
  00447	8b 11		 mov	 edx, DWORD PTR [ecx]
  00449	3b 72 04	 cmp	 esi, DWORD PTR [edx+4]
  0044c	7f 19		 jg	 SHORT $LN25@P_IsClimbi
  0044e	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00451	8b 08		 mov	 ecx, DWORD PTR [eax]
  00453	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00456	8b 02		 mov	 eax, DWORD PTR [edx]
  00458	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0045b	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  0045e	8b 55 f4	 mov	 edx, DWORD PTR _glidesector$[ebp]
  00461	8b 02		 mov	 eax, DWORD PTR [edx]
  00463	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00465	7f 07		 jg	 SHORT $LN24@P_IsClimbi
$LN25@P_IsClimbi:

; 2128 : 				floorclimb = true;

  00467	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1
$LN24@P_IsClimbi:

; 2129 : 		}

  0046e	e9 61 01 00 00	 jmp	 $LN30@P_IsClimbi
$LN18@P_IsClimbi:

; 2130 : 		else
; 2131 : 		{
; 2132 : 			if ((glidesector->sector->ceilingheight >= player->mo->z)
; 2133 : 				&& ((player->mo->z - player->mo->momz) >= glidesector->sector->ceilingheight))

  00473	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00476	8b 08		 mov	 ecx, DWORD PTR [eax]
  00478	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0047b	8b 02		 mov	 eax, DWORD PTR [edx]
  0047d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00480	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00483	7c 21		 jl	 SHORT $LN26@P_IsClimbi
  00485	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00488	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048a	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0048d	8b 02		 mov	 eax, DWORD PTR [edx]
  0048f	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00492	2b 48 50	 sub	 ecx, DWORD PTR [eax+80]
  00495	8b 55 f4	 mov	 edx, DWORD PTR _glidesector$[ebp]
  00498	8b 02		 mov	 eax, DWORD PTR [edx]
  0049a	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0049d	7c 07		 jl	 SHORT $LN26@P_IsClimbi

; 2134 : 				floorclimb = true;

  0049f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1
$LN26@P_IsClimbi:

; 2135 : 
; 2136 : 			if (!floorclimb && glidesector->sector->floorheight < player->mo->z + FIXEDSCALE(16*FRACUNIT,player->mo->scale)
; 2137 : 				&& (glidesector->sector->ceilingpic == skyflatnum

  004a6	83 7d ec 00	 cmp	 DWORD PTR _floorclimb$4[ebp], 0
  004aa	0f 85 a1 00 00
	00		 jne	 $LN27@P_IsClimbi
  004b0	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  004b3	8b 30		 mov	 esi, DWORD PTR [eax]
  004b5	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  004b8	8b 39		 mov	 edi, DWORD PTR [ecx]
  004ba	68 00 00 10 00	 push	 1048576			; 00100000H
  004bf	68 00 00 64 00	 push	 6553600			; 00640000H
  004c4	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  004c7	8b 02		 mov	 eax, DWORD PTR [edx]
  004c9	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  004d0	c1 e1 10	 shl	 ecx, 16			; 00000010H
  004d3	51		 push	 ecx
  004d4	e8 00 00 00 00	 call	 _FixedDiv
  004d9	83 c4 08	 add	 esp, 8
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 _FixedMul
  004e2	83 c4 08	 add	 esp, 8
  004e5	03 47 18	 add	 eax, DWORD PTR [edi+24]
  004e8	39 06		 cmp	 DWORD PTR [esi], eax
  004ea	7d 65		 jge	 SHORT $LN27@P_IsClimbi
  004ec	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  004ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f1	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  004f4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _skyflatnum
  004fa	74 47		 je	 SHORT $LN28@P_IsClimbi
  004fc	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  004ff	8b 30		 mov	 esi, DWORD PTR [eax]
  00501	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00504	8b 11		 mov	 edx, DWORD PTR [ecx]
  00506	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00509	8b 08		 mov	 ecx, DWORD PTR [eax]
  0050b	8b 7a 18	 mov	 edi, DWORD PTR [edx+24]
  0050e	03 79 44	 add	 edi, DWORD PTR [ecx+68]
  00511	68 00 00 08 00	 push	 524288			; 00080000H
  00516	68 00 00 64 00	 push	 6553600			; 00640000H
  0051b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0051e	8b 02		 mov	 eax, DWORD PTR [edx]
  00520	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00527	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0052a	51		 push	 ecx
  0052b	e8 00 00 00 00	 call	 _FixedDiv
  00530	83 c4 08	 add	 esp, 8
  00533	50		 push	 eax
  00534	e8 00 00 00 00	 call	 _FixedMul
  00539	83 c4 08	 add	 esp, 8
  0053c	03 f8		 add	 edi, eax
  0053e	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  00541	7e 0e		 jle	 SHORT $LN27@P_IsClimbi
$LN28@P_IsClimbi:

; 2138 : 				|| glidesector->sector->ceilingheight
; 2139 : 				> (player->mo->z + player->mo->height + FIXEDSCALE(8*FRACUNIT,player->mo->scale))))
; 2140 : 			{
; 2141 : 				thrust = true;

  00543	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _thrust$3[ebp], 1

; 2142 : 				boostup = true;

  0054a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _boostup$2[ebp], 1
$LN27@P_IsClimbi:

; 2143 : 				// Play climb-up animation here
; 2144 : 			}
; 2145 : 
; 2146 : 			if ((glidesector->sector->ceilingheight < player->mo->z+player->mo->height)
; 2147 : 				&& glidesector->sector->ceilingpic == skyflatnum)

  00551	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  00554	8b 08		 mov	 ecx, DWORD PTR [eax]
  00556	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  00559	8b 02		 mov	 eax, DWORD PTR [edx]
  0055b	8b 55 08	 mov	 edx, DWORD PTR _player$[ebp]
  0055e	8b 12		 mov	 edx, DWORD PTR [edx]
  00560	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00563	03 42 44	 add	 eax, DWORD PTR [edx+68]
  00566	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00569	7d 14		 jge	 SHORT $LN29@P_IsClimbi
  0056b	8b 45 f4	 mov	 eax, DWORD PTR _glidesector$[ebp]
  0056e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00570	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00573	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _skyflatnum
  00579	75 04		 jne	 SHORT $LN29@P_IsClimbi

; 2148 : 				return false;

  0057b	33 c0		 xor	 eax, eax
  0057d	eb 6f		 jmp	 SHORT $LN1@P_IsClimbi
$LN29@P_IsClimbi:

; 2149 : 
; 2150 : 			if ((player->mo->z + FIXEDSCALE(16*FRACUNIT,player->mo->scale) < glidesector->sector->floorheight)
; 2151 : 				|| (player->mo->z >= glidesector->sector->ceilingheight))

  0057f	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  00582	8b 30		 mov	 esi, DWORD PTR [eax]
  00584	68 00 00 10 00	 push	 1048576			; 00100000H
  00589	68 00 00 64 00	 push	 6553600			; 00640000H
  0058e	8b 4d 08	 mov	 ecx, DWORD PTR _player$[ebp]
  00591	8b 11		 mov	 edx, DWORD PTR [ecx]
  00593	0f b7 82 cc 00
	00 00		 movzx	 eax, WORD PTR [edx+204]
  0059a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0059d	50		 push	 eax
  0059e	e8 00 00 00 00	 call	 _FixedDiv
  005a3	83 c4 08	 add	 esp, 8
  005a6	50		 push	 eax
  005a7	e8 00 00 00 00	 call	 _FixedMul
  005ac	83 c4 08	 add	 esp, 8
  005af	03 46 18	 add	 eax, DWORD PTR [esi+24]
  005b2	8b 4d f4	 mov	 ecx, DWORD PTR _glidesector$[ebp]
  005b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  005b7	3b 02		 cmp	 eax, DWORD PTR [edx]
  005b9	7c 12		 jl	 SHORT $LN31@P_IsClimbi
  005bb	8b 45 08	 mov	 eax, DWORD PTR _player$[ebp]
  005be	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c0	8b 55 f4	 mov	 edx, DWORD PTR _glidesector$[ebp]
  005c3	8b 02		 mov	 eax, DWORD PTR [edx]
  005c5	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  005c8	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  005cb	7c 07		 jl	 SHORT $LN30@P_IsClimbi
$LN31@P_IsClimbi:

; 2152 : 				floorclimb = true;

  005cd	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _floorclimb$4[ebp], 1
$LN30@P_IsClimbi:

; 2153 : 		}
; 2154 : 
; 2155 : 		climb = false;

  005d4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _climb$[ebp], 0

; 2156 : 
; 2157 : 		if (!floorclimb)

  005db	83 7d ec 00	 cmp	 DWORD PTR _floorclimb$4[ebp], 0
  005df	75 04		 jne	 SHORT $LN32@P_IsClimbi

; 2158 : 			return false;

  005e1	33 c0		 xor	 eax, eax
  005e3	eb 09		 jmp	 SHORT $LN1@P_IsClimbi
$LN32@P_IsClimbi:

; 2159 : 
; 2160 : 		return true;

  005e5	b8 01 00 00 00	 mov	 eax, 1
  005ea	eb 02		 jmp	 SHORT $LN1@P_IsClimbi
$LN5@P_IsClimbi:

; 2161 : 	}
; 2162 : 
; 2163 : 	return false;

  005ec	33 c0		 xor	 eax, eax
$LN1@P_IsClimbi:

; 2164 : }

  005ee	5f		 pop	 edi
  005ef	5e		 pop	 esi
  005f0	5b		 pop	 ebx
  005f1	8b e5		 mov	 esp, ebp
  005f3	5d		 pop	 ebp
  005f4	c3		 ret	 0
_P_IsClimbingValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PTR_SlideCameraTraverse
_TEXT	SEGMENT
_li$ = -4						; size = 4
_in$ = 8						; size = 4
_PTR_SlideCameraTraverse PROC				; COMDAT

; 1987 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1988 : 	line_t *li;
; 1989 : 
; 1990 : 	I_Assert(in->isaline);
; 1991 : 
; 1992 : 	li = in->d.line;

  00009	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d fc	 mov	 DWORD PTR _li$[ebp], ecx

; 1993 : 
; 1994 : 	if (!(li->flags & ML_TWOSIDED))

  00012	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00015	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00019	83 e1 04	 and	 ecx, 4
  0001c	75 2f		 jne	 SHORT $LN2@PTR_SlideC

; 1995 : 	{
; 1996 : 		if (P_PointOnLineSide(mapcampointer->x, mapcampointer->y, li))

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00021	50		 push	 eax
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _mapcampointer
  00028	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0002b	52		 push	 edx
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapcampointer
  00031	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _P_PointOnLineSide
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	85 c0		 test	 eax, eax
  0003f	74 0a		 je	 SHORT $LN3@PTR_SlideC

; 1997 : 			return true; // don't hit the back side

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	e9 8c 00 00 00	 jmp	 $LN1@PTR_SlideC
$LN3@PTR_SlideC:

; 1998 : 		goto isblocking;

  0004b	eb 54		 jmp	 SHORT $isblocking$9
$LN2@PTR_SlideC:

; 1999 : 	}
; 2000 : 
; 2001 : 	// set openrange, opentop, openbottom
; 2002 : 	P_CameraLineOpening(li);

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _P_CameraLineOpening
  00056	83 c4 04	 add	 esp, 4

; 2003 : 
; 2004 : 	if (openrange < mapcampointer->height)

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapcampointer
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _openrange
  00064	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  00067	7d 02		 jge	 SHORT $LN4@PTR_SlideC

; 2005 : 		goto isblocking; // doesn't fit

  00069	eb 36		 jmp	 SHORT $isblocking$9
$LN4@PTR_SlideC:

; 2006 : 
; 2007 : 	if (opentop - mapcampointer->z < mapcampointer->height)

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapcampointer
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opentop
  00076	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00079	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _mapcampointer
  0007f	3b 4a 30	 cmp	 ecx, DWORD PTR [edx+48]
  00082	7d 02		 jge	 SHORT $LN5@PTR_SlideC

; 2008 : 		goto isblocking; // mobj is too high

  00084	eb 1b		 jmp	 SHORT $isblocking$9
$LN5@PTR_SlideC:

; 2009 : 
; 2010 : 	if (openbottom - mapcampointer->z > 0) // We don't want to make the camera step up.

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR _mapcampointer
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _openbottom
  00091	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00094	85 c9		 test	 ecx, ecx
  00096	7e 02		 jle	 SHORT $LN6@PTR_SlideC

; 2011 : 		goto isblocking; // too big a step up

  00098	eb 07		 jmp	 SHORT $isblocking$9
$LN6@PTR_SlideC:

; 2012 : 
; 2013 : 	// this line doesn't block movement
; 2014 : 	return true;

  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	eb 36		 jmp	 SHORT $LN1@PTR_SlideC
$isblocking$9:

; 2015 : 
; 2016 : 	// the line does block movement,
; 2017 : 	// see if it is closer than best so far
; 2018 : isblocking:
; 2019 : 	{
; 2020 : 		if (in->frac < bestslidefrac)

  000a1	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _bestslidefrac
  000ac	7d 27		 jge	 SHORT $LN7@PTR_SlideC

; 2021 : 		{
; 2022 : 			secondslidefrac = bestslidefrac;

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  000b3	a3 00 00 00 00	 mov	 DWORD PTR _secondslidefrac, eax

; 2023 : 			secondslideline = bestslideline;

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslideline
  000bd	a3 00 00 00 00	 mov	 DWORD PTR _secondslideline, eax

; 2024 : 			bestslidefrac = in->frac;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c7	89 0d 00 00 00
	00		 mov	 DWORD PTR _bestslidefrac, ecx

; 2025 : 			bestslideline = li;

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _li$[ebp]
  000d0	a3 00 00 00 00	 mov	 DWORD PTR _bestslideline, eax
$LN7@PTR_SlideC:

; 2026 : 		}
; 2027 : 	}
; 2028 : 
; 2029 : 	return false; // stop

  000d5	33 c0		 xor	 eax, eax
$LN1@PTR_SlideC:

; 2030 : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_PTR_SlideCameraTraverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_HitBounceLine
_TEXT	SEGMENT
_movelen$ = -20						; size = 4
_deltaangle$ = -16					; size = 4
_moveangle$ = -12					; size = 4
_lineangle$ = -8					; size = 4
_side$ = -4						; size = 4
_ld$ = 8						; size = 4
_P_HitBounceLine PROC					; COMDAT

; 1945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1946 : 	INT32 side;
; 1947 : 	angle_t lineangle, moveangle, deltaangle;
; 1948 : 	fixed_t movelen;
; 1949 : 
; 1950 : 	if (ld->slopetype == ST_HORIZONTAL)

  00009	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00010	75 11		 jne	 SHORT $LN2@P_HitBounc

; 1951 : 	{
; 1952 : 		tmymove = -tmymove;

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  00017	f7 d8		 neg	 eax
  00019	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax

; 1953 : 		return;

  0001e	e9 18 01 00 00	 jmp	 $LN1@P_HitBounc
$LN2@P_HitBounc:

; 1954 : 	}
; 1955 : 
; 1956 : 	if (ld->slopetype == ST_VERTICAL)

  00023	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00026	83 78 2c 01	 cmp	 DWORD PTR [eax+44], 1
  0002a	75 11		 jne	 SHORT $LN3@P_HitBounc

; 1957 : 	{
; 1958 : 		tmxmove = -tmxmove;

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmxmove
  00031	f7 d8		 neg	 eax
  00033	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 1959 : 		return;

  00038	e9 fe 00 00 00	 jmp	 $LN1@P_HitBounc
$LN3@P_HitBounc:

; 1960 : 	}
; 1961 : 
; 1962 : 	side = P_PointOnLineSide(slidemo->x, slidemo->y, ld);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00040	50		 push	 eax
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  00047	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004a	52		 push	 edx
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  00050	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	89 45 fc	 mov	 DWORD PTR _side$[ebp], eax

; 1963 : 
; 1964 : 	lineangle = R_PointToAngle2(0, 0, ld->dx, ld->dy);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00062	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00065	51		 push	 ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  00069	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006c	50		 push	 eax
  0006d	6a 00		 push	 0
  0006f	6a 00		 push	 0
  00071	e8 00 00 00 00	 call	 _R_PointToAngle2
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 1965 : 
; 1966 : 	if (lineangle >= ANGLE_180)

  0007c	81 7d f8 00 00
	00 80		 cmp	 DWORD PTR _lineangle$[ebp], -2147483648 ; 80000000H
  00083	72 0b		 jb	 SHORT $LN4@P_HitBounc

; 1967 : 		lineangle -= ANGLE_180;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00088	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  0008d	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax
$LN4@P_HitBounc:

; 1968 : 
; 1969 : 	moveangle = R_PointToAngle2(0, 0, tmxmove, tmymove);

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  00095	50		 push	 eax
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  0009c	51		 push	 ecx
  0009d	6a 00		 push	 0
  0009f	6a 00		 push	 0
  000a1	e8 00 00 00 00	 call	 _R_PointToAngle2
  000a6	83 c4 10	 add	 esp, 16			; 00000010H
  000a9	89 45 f4	 mov	 DWORD PTR _moveangle$[ebp], eax

; 1970 : 	deltaangle = moveangle + 2*(lineangle - moveangle);

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  000af	2b 45 f4	 sub	 eax, DWORD PTR _moveangle$[ebp]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _moveangle$[ebp]
  000b5	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000b8	89 55 f0	 mov	 DWORD PTR _deltaangle$[ebp], edx

; 1971 : 
; 1972 : 	lineangle >>= ANGLETOFINESHIFT;

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  000be	c1 e8 13	 shr	 eax, 19			; 00000013H
  000c1	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 1973 : 	deltaangle >>= ANGLETOFINESHIFT;

  000c4	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000c7	c1 e8 13	 shr	 eax, 19			; 00000013H
  000ca	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax

; 1974 : 
; 1975 : 	movelen = P_AproxDistance(tmxmove, tmymove);

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  000d2	50		 push	 eax
  000d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _P_AproxDistance
  000df	83 c4 08	 add	 esp, 8
  000e2	89 45 ec	 mov	 DWORD PTR _movelen$[ebp], eax

; 1976 : 
; 1977 : 	tmxmove = FixedMul(movelen, FINECOSINE(deltaangle));

  000e5	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  000ee	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000f1	52		 push	 edx
  000f2	8b 45 ec	 mov	 eax, DWORD PTR _movelen$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _FixedMul
  000fb	83 c4 08	 add	 esp, 8
  000fe	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 1978 : 	tmymove = FixedMul(movelen, FINESINE(deltaangle));

  00103	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  00106	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  0010d	51		 push	 ecx
  0010e	8b 55 ec	 mov	 edx, DWORD PTR _movelen$[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 _FixedMul
  00117	83 c4 08	 add	 esp, 8
  0011a	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax

; 1979 : 
; 1980 : 	deltaangle = R_PointToAngle2(0, 0, tmxmove, tmymove);

  0011f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  00124	50		 push	 eax
  00125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  0012b	51		 push	 ecx
  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	e8 00 00 00 00	 call	 _R_PointToAngle2
  00135	83 c4 10	 add	 esp, 16			; 00000010H
  00138	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax
$LN1@P_HitBounc:

; 1981 : }

  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
_P_HitBounceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_HitSlideLine
_TEXT	SEGMENT
_newlen$ = -24						; size = 4
_movelen$ = -20						; size = 4
_deltaangle$ = -16					; size = 4
_moveangle$ = -12					; size = 4
_lineangle$ = -8					; size = 4
_side$ = -4						; size = 4
_ld$ = 8						; size = 4
_P_HitSlideLine PROC					; COMDAT

; 1899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1900 : 	INT32 side;
; 1901 : 	angle_t lineangle, moveangle, deltaangle;
; 1902 : 	fixed_t movelen, newlen;
; 1903 : 
; 1904 : 	if (ld->slopetype == ST_HORIZONTAL)

  00009	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00010	75 0f		 jne	 SHORT $LN2@P_HitSlide

; 1905 : 	{
; 1906 : 		tmymove = 0;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmymove, 0

; 1907 : 		return;

  0001c	e9 21 01 00 00	 jmp	 $LN1@P_HitSlide
$LN2@P_HitSlide:

; 1908 : 	}
; 1909 : 
; 1910 : 	if (ld->slopetype == ST_VERTICAL)

  00021	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00024	83 78 2c 01	 cmp	 DWORD PTR [eax+44], 1
  00028	75 0f		 jne	 SHORT $LN3@P_HitSlide

; 1911 : 	{
; 1912 : 		tmxmove = 0;

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmxmove, 0

; 1913 : 		return;

  00034	e9 09 01 00 00	 jmp	 $LN1@P_HitSlide
$LN3@P_HitSlide:

; 1914 : 	}
; 1915 : 
; 1916 : 	side = P_PointOnLineSide(slidemo->x, slidemo->y, ld);

  00039	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0003c	50		 push	 eax
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _slidemo
  00043	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00046	52		 push	 edx
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _slidemo
  0004c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	89 45 fc	 mov	 DWORD PTR _side$[ebp], eax

; 1917 : 
; 1918 : 	lineangle = R_PointToAngle2(0, 0, ld->dx, ld->dy);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0005e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00061	51		 push	 ecx
  00062	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  00065	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00068	50		 push	 eax
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	e8 00 00 00 00	 call	 _R_PointToAngle2
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 1919 : 
; 1920 : 	if (side == 1)

  00078	83 7d fc 01	 cmp	 DWORD PTR _side$[ebp], 1
  0007c	75 0b		 jne	 SHORT $LN4@P_HitSlide

; 1921 : 		lineangle += ANGLE_180;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00081	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  00086	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax
$LN4@P_HitSlide:

; 1922 : 
; 1923 : 	moveangle = R_PointToAngle2(0, 0, tmxmove, tmymove);

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  0008e	50		 push	 eax
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  00095	51		 push	 ecx
  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	e8 00 00 00 00	 call	 _R_PointToAngle2
  0009f	83 c4 10	 add	 esp, 16			; 00000010H
  000a2	89 45 f4	 mov	 DWORD PTR _moveangle$[ebp], eax

; 1924 : 	deltaangle = moveangle-lineangle;

  000a5	8b 45 f4	 mov	 eax, DWORD PTR _moveangle$[ebp]
  000a8	2b 45 f8	 sub	 eax, DWORD PTR _lineangle$[ebp]
  000ab	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax

; 1925 : 
; 1926 : 	if (deltaangle > ANGLE_180)

  000ae	81 7d f0 00 00
	00 80		 cmp	 DWORD PTR _deltaangle$[ebp], -2147483648 ; 80000000H
  000b5	76 0b		 jbe	 SHORT $LN5@P_HitSlide

; 1927 : 		deltaangle += ANGLE_180;

  000b7	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000ba	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  000bf	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax
$LN5@P_HitSlide:

; 1928 : 
; 1929 : 	lineangle >>= ANGLETOFINESHIFT;

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  000c5	c1 e8 13	 shr	 eax, 19			; 00000013H
  000c8	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 1930 : 	deltaangle >>= ANGLETOFINESHIFT;

  000cb	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000ce	c1 e8 13	 shr	 eax, 19			; 00000013H
  000d1	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax

; 1931 : 
; 1932 : 	movelen = P_AproxDistance(tmxmove, tmymove);

  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  000d9	50		 push	 eax
  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _P_AproxDistance
  000e6	83 c4 08	 add	 esp, 8
  000e9	89 45 ec	 mov	 DWORD PTR _movelen$[ebp], eax

; 1933 : 	newlen = FixedMul(movelen, FINECOSINE(deltaangle));

  000ec	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  000f5	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000f8	52		 push	 edx
  000f9	8b 45 ec	 mov	 eax, DWORD PTR _movelen$[ebp]
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _FixedMul
  00102	83 c4 08	 add	 esp, 8
  00105	89 45 e8	 mov	 DWORD PTR _newlen$[ebp], eax

; 1934 : 
; 1935 : 	tmxmove = FixedMul(newlen, FINECOSINE(lineangle));

  00108	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  00111	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00114	52		 push	 edx
  00115	8b 45 e8	 mov	 eax, DWORD PTR _newlen$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _FixedMul
  0011e	83 c4 08	 add	 esp, 8
  00121	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 1936 : 	tmymove = FixedMul(newlen, FINESINE(lineangle));

  00126	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00129	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  00130	51		 push	 ecx
  00131	8b 55 e8	 mov	 edx, DWORD PTR _newlen$[ebp]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _FixedMul
  0013a	83 c4 08	 add	 esp, 8
  0013d	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax
$LN1@P_HitSlide:

; 1937 : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
_P_HitSlideLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_HitCameraSlideLine
_TEXT	SEGMENT
_newlen$ = -24						; size = 4
_movelen$ = -20						; size = 4
_deltaangle$ = -16					; size = 4
_moveangle$ = -12					; size = 4
_lineangle$ = -8					; size = 4
_side$ = -4						; size = 4
_ld$ = 8						; size = 4
_thiscam$ = 12						; size = 4
_P_HitCameraSlideLine PROC				; COMDAT

; 1854 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1855 : 	INT32 side;
; 1856 : 	angle_t lineangle, moveangle, deltaangle;
; 1857 : 	fixed_t movelen, newlen;
; 1858 : 
; 1859 : 	if (ld->slopetype == ST_HORIZONTAL)

  00009	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00010	75 0f		 jne	 SHORT $LN2@P_HitCamer

; 1860 : 	{
; 1861 : 		tmymove = 0;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmymove, 0

; 1862 : 		return;

  0001c	e9 1c 01 00 00	 jmp	 $LN1@P_HitCamer
$LN2@P_HitCamer:

; 1863 : 	}
; 1864 : 
; 1865 : 	if (ld->slopetype == ST_VERTICAL)

  00021	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00024	83 78 2c 01	 cmp	 DWORD PTR [eax+44], 1
  00028	75 0f		 jne	 SHORT $LN3@P_HitCamer

; 1866 : 	{
; 1867 : 		tmxmove = 0;

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmxmove, 0

; 1868 : 		return;

  00034	e9 04 01 00 00	 jmp	 $LN1@P_HitCamer
$LN3@P_HitCamer:

; 1869 : 	}
; 1870 : 
; 1871 : 	side = P_PointOnLineSide(thiscam->x, thiscam->y, ld);

  00039	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00040	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00043	52		 push	 edx
  00044	8b 45 0c	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00047	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _P_PointOnLineSide
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	89 45 fc	 mov	 DWORD PTR _side$[ebp], eax

; 1872 : 	lineangle = R_PointToAngle2(0, 0, ld->dx, ld->dy);

  00056	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00059	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005c	51		 push	 ecx
  0005d	8b 55 08	 mov	 edx, DWORD PTR _ld$[ebp]
  00060	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00063	50		 push	 eax
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 _R_PointToAngle2
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 1873 : 
; 1874 : 	if (side == 1)

  00073	83 7d fc 01	 cmp	 DWORD PTR _side$[ebp], 1
  00077	75 0b		 jne	 SHORT $LN4@P_HitCamer

; 1875 : 		lineangle += ANGLE_180;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  0007c	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  00081	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax
$LN4@P_HitCamer:

; 1876 : 
; 1877 : 	moveangle = R_PointToAngle2(0, 0, tmxmove, tmymove);

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  00089	50		 push	 eax
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  00090	51		 push	 ecx
  00091	6a 00		 push	 0
  00093	6a 00		 push	 0
  00095	e8 00 00 00 00	 call	 _R_PointToAngle2
  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	89 45 f4	 mov	 DWORD PTR _moveangle$[ebp], eax

; 1878 : 	deltaangle = moveangle-lineangle;

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _moveangle$[ebp]
  000a3	2b 45 f8	 sub	 eax, DWORD PTR _lineangle$[ebp]
  000a6	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax

; 1879 : 
; 1880 : 	if (deltaangle > ANGLE_180)

  000a9	81 7d f0 00 00
	00 80		 cmp	 DWORD PTR _deltaangle$[ebp], -2147483648 ; 80000000H
  000b0	76 0b		 jbe	 SHORT $LN5@P_HitCamer

; 1881 : 		deltaangle += ANGLE_180;

  000b2	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000b5	2d 00 00 00 80	 sub	 eax, -2147483648	; 80000000H
  000ba	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax
$LN5@P_HitCamer:

; 1882 : 
; 1883 : 	lineangle >>= ANGLETOFINESHIFT;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  000c0	c1 e8 13	 shr	 eax, 19			; 00000013H
  000c3	89 45 f8	 mov	 DWORD PTR _lineangle$[ebp], eax

; 1884 : 	deltaangle >>= ANGLETOFINESHIFT;

  000c6	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000c9	c1 e8 13	 shr	 eax, 19			; 00000013H
  000cc	89 45 f0	 mov	 DWORD PTR _deltaangle$[ebp], eax

; 1885 : 
; 1886 : 	movelen = P_AproxDistance(tmxmove, tmymove);

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmymove
  000d4	50		 push	 eax
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _P_AproxDistance
  000e1	83 c4 08	 add	 esp, 8
  000e4	89 45 ec	 mov	 DWORD PTR _movelen$[ebp], eax

; 1887 : 	newlen = FixedMul(movelen, FINECOSINE(deltaangle));

  000e7	8b 45 f0	 mov	 eax, DWORD PTR _deltaangle$[ebp]
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  000f0	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000f3	52		 push	 edx
  000f4	8b 45 ec	 mov	 eax, DWORD PTR _movelen$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _FixedMul
  000fd	83 c4 08	 add	 esp, 8
  00100	89 45 e8	 mov	 DWORD PTR _newlen$[ebp], eax

; 1888 : 
; 1889 : 	tmxmove = FixedMul(newlen, FINECOSINE(lineangle));

  00103	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  0010c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0010f	52		 push	 edx
  00110	8b 45 e8	 mov	 eax, DWORD PTR _newlen$[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _FixedMul
  00119	83 c4 08	 add	 esp, 8
  0011c	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 1890 : 	tmymove = FixedMul(newlen, FINESINE(lineangle));

  00121	8b 45 f8	 mov	 eax, DWORD PTR _lineangle$[ebp]
  00124	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finesine[eax*4]
  0012b	51		 push	 ecx
  0012c	8b 55 e8	 mov	 edx, DWORD PTR _newlen$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 _FixedMul
  00135	83 c4 08	 add	 esp, 8
  00138	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax
$LN1@P_HitCamer:

; 1891 : }

  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
_P_HitCameraSlideLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_ThingHeightClip
_TEXT	SEGMENT
_onfloor$ = -8						; size = 4
_oldfloorz$ = -4					; size = 4
_thing$ = 8						; size = 4
_P_ThingHeightClip PROC					; COMDAT

; 1774 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1775 : 	fixed_t oldfloorz = thing->floorz;

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0000f	89 4d fc	 mov	 DWORD PTR _oldfloorz$[ebp], ecx

; 1776 : 	boolean onfloor = P_IsObjectOnGround(thing);//(thing->z <= thing->floorz);

  00012	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _P_IsObjectOnGround
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 45 f8	 mov	 DWORD PTR _onfloor$[ebp], eax

; 1777 : 
; 1778 : 	if (thing->flags & MF_NOCLIPHEIGHT)

  00021	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00024	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00027	81 e1 00 00 80
	00		 and	 ecx, 8388608		; 00800000H
  0002d	74 0a		 je	 SHORT $LN2@P_ThingHei

; 1779 : 		return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	e9 2b 02 00 00	 jmp	 $LN1@P_ThingHei
$LN2@P_ThingHei:

; 1780 : 
; 1781 : 	// Have player fall through floor?
; 1782 : 	if (thing->player && thing->player->playerstate == PST_DEAD)

  00039	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0003c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00043	74 19		 je	 SHORT $LN3@P_ThingHei
  00045	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00048	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0004e	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  00052	75 0a		 jne	 SHORT $LN3@P_ThingHei

; 1783 : 		return true;

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	e9 06 02 00 00	 jmp	 $LN1@P_ThingHei
$LN3@P_ThingHei:

; 1784 : 
; 1785 : 	P_CheckPosition(thing, thing->x, thing->y);

  0005e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00061	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00064	51		 push	 ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00068	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0006b	50		 push	 eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _P_CheckPosition
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1786 : 
; 1787 : 	thing->floorz = tmfloorz;

  00078	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00081	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 1788 : 	thing->ceilingz = tmceilingz;

  00084	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0008d	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1789 : 
; 1790 : 	// Ugly hack?!?! As long as just ceilingz is the lowest,
; 1791 : 	// you'll still get crushed, right?
; 1792 : 	if (tmfloorz > oldfloorz+thing->height)

  00090	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _oldfloorz$[ebp]
  00096	03 48 44	 add	 ecx, DWORD PTR [eax+68]
  00099	39 0d 00 00 00
	00		 cmp	 DWORD PTR _tmfloorz, ecx
  0009f	7e 0a		 jle	 SHORT $LN4@P_ThingHei

; 1793 : 		return true;

  000a1	b8 01 00 00 00	 mov	 eax, 1
  000a6	e9 b9 01 00 00	 jmp	 $LN1@P_ThingHei
$LN4@P_ThingHei:

; 1794 : 
; 1795 : 	if (!tmfloorthing && onfloor && !(thing->flags & MF_NOGRAVITY))

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmfloorthing, 0
  000b2	0f 85 07 01 00
	00		 jne	 $LN5@P_ThingHei
  000b8	83 7d f8 00	 cmp	 DWORD PTR _onfloor$[ebp], 0
  000bc	0f 84 fd 00 00
	00		 je	 $LN5@P_ThingHei
  000c2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000c5	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000c8	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  000ce	0f 85 eb 00 00
	00		 jne	 $LN5@P_ThingHei

; 1796 : 	{
; 1797 : 		if (thing->eflags & MFE_VERTICALFLIP)

  000d4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000d7	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000dd	83 e1 20	 and	 ecx, 32			; 00000020H
  000e0	74 1a		 je	 SHORT $LN7@P_ThingHei

; 1798 : 			thing->pmomz = thing->z + thing->height - thing->ceilingz;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000e5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000e8	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000eb	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  000ee	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000f1	2b 48 3c	 sub	 ecx, DWORD PTR [eax+60]
  000f4	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000f7	89 4a 54	 mov	 DWORD PTR [edx+84], ecx
  000fa	eb 12		 jmp	 SHORT $LN8@P_ThingHei
$LN7@P_ThingHei:

; 1799 : 		else
; 1800 : 			thing->pmomz = thing->floorz - thing->z;

  000fc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00102	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00105	2b 51 18	 sub	 edx, DWORD PTR [ecx+24]
  00108	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0010b	89 50 54	 mov	 DWORD PTR [eax+84], edx
$LN8@P_ThingHei:

; 1801 : 
; 1802 : 		if (thing->player)

  0010e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00111	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00118	74 75		 je	 SHORT $LN12@P_ThingHei

; 1803 : 		{
; 1804 : 			if (splitscreen && cv_chasecam2.value && thing->player == &players[secondarydisplayplayer])

  0011a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  00121	74 37		 je	 SHORT $LN10@P_ThingHei
  00123	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam2+20, 0
  0012a	74 2e		 je	 SHORT $LN10@P_ThingHei
  0012c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00136	05 00 00 00 00	 add	 eax, OFFSET _players
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0013e	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  00144	75 14		 jne	 SHORT $LN10@P_ThingHei

; 1805 : 				camera2.z += thing->pmomz;

  00146	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00149	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR _camera2+24
  0014f	03 48 54	 add	 ecx, DWORD PTR [eax+84]
  00152	89 0d 18 00 00
	00		 mov	 DWORD PTR _camera2+24, ecx
  00158	eb 35		 jmp	 SHORT $LN12@P_ThingHei
$LN10@P_ThingHei:

; 1806 : 			else if (cv_chasecam.value && thing->player == &players[displayplayer])

  0015a	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_chasecam+20, 0
  00161	74 2c		 je	 SHORT $LN12@P_ThingHei
  00163	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  0016d	05 00 00 00 00	 add	 eax, OFFSET _players
  00172	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00175	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  0017b	75 12		 jne	 SHORT $LN12@P_ThingHei

; 1807 : 				camera.z += thing->pmomz;

  0017d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00180	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR _camera+24
  00186	03 48 54	 add	 ecx, DWORD PTR [eax+84]
  00189	89 0d 18 00 00
	00		 mov	 DWORD PTR _camera+24, ecx
$LN12@P_ThingHei:

; 1808 : 		}
; 1809 : 
; 1810 : 		if (thing->eflags & MFE_VERTICALFLIP)

  0018f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00192	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00198	83 e1 20	 and	 ecx, 32			; 00000020H
  0019b	74 14		 je	 SHORT $LN13@P_ThingHei

; 1811 : 			thing->z = thing->ceilingz - thing->height;

  0019d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001a0	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  001a3	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  001a6	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  001a9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001ac	89 50 18	 mov	 DWORD PTR [eax+24], edx
  001af	eb 0c		 jmp	 SHORT $LN14@P_ThingHei
$LN13@P_ThingHei:

; 1812 : 		else
; 1813 : 			thing->z = thing->floorz;

  001b1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  001b7	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001ba	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN14@P_ThingHei:

; 1814 : 	}

  001bd	eb 65		 jmp	 SHORT $LN19@P_ThingHei
$LN5@P_ThingHei:

; 1815 : 	else if (!tmfloorthing)

  001bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmfloorthing, 0
  001c6	75 5c		 jne	 SHORT $LN19@P_ThingHei

; 1816 : 	{
; 1817 : 		// don't adjust a floating monster unless forced to
; 1818 : 		if (thing->eflags & MFE_VERTICALFLIP)

  001c8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001cb	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  001d1	83 e1 20	 and	 ecx, 32			; 00000020H
  001d4	74 22		 je	 SHORT $LN16@P_ThingHei

; 1819 : 		{
; 1820 : 			if (!onfloor && thing->z < tmfloorz)

  001d6	83 7d f8 00	 cmp	 DWORD PTR _onfloor$[ebp], 0
  001da	75 1a		 jne	 SHORT $LN18@P_ThingHei
  001dc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001df	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001e2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmfloorz
  001e8	7d 0c		 jge	 SHORT $LN18@P_ThingHei

; 1821 : 				thing->z = thing->floorz;

  001ea	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  001f0	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001f3	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN18@P_ThingHei:

; 1822 : 		}

  001f6	eb 2c		 jmp	 SHORT $LN19@P_ThingHei
$LN16@P_ThingHei:

; 1823 : 		else if (!onfloor && thing->z + thing->height > tmceilingz)

  001f8	83 7d f8 00	 cmp	 DWORD PTR _onfloor$[ebp], 0
  001fc	75 26		 jne	 SHORT $LN19@P_ThingHei
  001fe	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00201	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00204	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00207	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0020a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmceilingz
  00210	7e 12		 jle	 SHORT $LN19@P_ThingHei

; 1824 : 			thing->z = thing->ceilingz - thing->height;

  00212	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00215	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00218	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  0021b	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  0021e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00221	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN19@P_ThingHei:

; 1825 : 	}
; 1826 : 
; 1827 : 	// debug: be sure it falls to the floor
; 1828 : 	thing->eflags &= ~MFE_ONGROUND;

  00224	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00227	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0022d	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00230	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00233	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx

; 1829 : 
; 1830 : 	if (thing->ceilingz - thing->floorz < thing->height && thing->z >= thing->floorz)

  00239	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0023c	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0023f	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00242	2b 51 38	 sub	 edx, DWORD PTR [ecx+56]
  00245	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00248	3b 50 44	 cmp	 edx, DWORD PTR [eax+68]
  0024b	7d 12		 jge	 SHORT $LN20@P_ThingHei
  0024d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00250	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00253	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00256	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  00259	7c 04		 jl	 SHORT $LN20@P_ThingHei

; 1831 : 		// BP: i know that this code cause many trouble but this also fixes
; 1832 : 		// a lot of problems, mainly this is implementation of the stepping
; 1833 : 		// for mobj (walk on solid corpse without jumping or fake 3d bridge)
; 1834 : 		// problem is imp into imp at map01 and monster going at top of others
; 1835 : 		return false;

  0025b	33 c0		 xor	 eax, eax
  0025d	eb 05		 jmp	 SHORT $LN1@P_ThingHei
$LN20@P_ThingHei:

; 1836 : 
; 1837 : 	return true;

  0025f	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_ThingHei:

; 1838 : }

  00264	5f		 pop	 edi
  00265	5e		 pop	 esi
  00266	5b		 pop	 ebx
  00267	8b e5		 mov	 esp, ebp
  00269	5d		 pop	 ebp
  0026a	c3		 ret	 0
_P_ThingHeightClip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _CheckMissileImpact
_TEXT	SEGMENT
_mobj$ = 8						; size = 4
_CheckMissileImpact PROC				; COMDAT

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1380 : 	if (!(mobj->flags & MF_MISSILE) || !mobj->target)
; 1381 : 		return;
; 1382 : 
; 1383 : 	if (!mobj->target->player)
; 1384 : 		return;
; 1385 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_CheckMissileImpact ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_CheckLine
_TEXT	SEGMENT
_ld$ = 8						; size = 4
_PIT_CheckLine PROC					; COMDAT

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 903  : 	if (ld->polyobj && !(ld->polyobj->flags & POF_SOLID))

  00009	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00010	74 1b		 je	 SHORT $LN2@PIT_CheckL
  00012	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00015	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00018	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0001e	83 e2 03	 and	 edx, 3
  00021	75 0a		 jne	 SHORT $LN2@PIT_CheckL

; 904  : 		return true;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	e9 7d 01 00 00	 jmp	 $LN1@PIT_CheckL
$LN2@PIT_CheckL:

; 905  : 
; 906  : 	if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] || tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT]
; 907  : 		|| tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] || tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])

  0002d	b8 04 00 00 00	 mov	 eax, 4
  00032	6b c8 03	 imul	 ecx, eax, 3
  00035	ba 04 00 00 00	 mov	 edx, 4
  0003a	d1 e2		 shl	 edx, 1
  0003c	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0003f	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[ecx]
  00045	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00049	7e 5c		 jle	 SHORT $LN4@PIT_CheckL
  0004b	b8 04 00 00 00	 mov	 eax, 4
  00050	d1 e0		 shl	 eax, 1
  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  0005d	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _tmbbox[eax]
  00063	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  00067	7d 3e		 jge	 SHORT $LN4@PIT_CheckL
  00069	b8 04 00 00 00	 mov	 eax, 4
  0006e	6b c8 00	 imul	 ecx, eax, 0
  00071	ba 04 00 00 00	 mov	 edx, 4
  00076	c1 e2 00	 shl	 edx, 0
  00079	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0007c	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[ecx]
  00082	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00086	7e 1f		 jle	 SHORT $LN4@PIT_CheckL
  00088	b8 04 00 00 00	 mov	 eax, 4
  0008d	c1 e0 00	 shl	 eax, 0
  00090	b9 04 00 00 00	 mov	 ecx, 4
  00095	6b d1 00	 imul	 edx, ecx, 0
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  0009b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _tmbbox[eax]
  000a1	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  000a5	7c 0a		 jl	 SHORT $LN3@PIT_CheckL
$LN4@PIT_CheckL:

; 908  : 	{
; 909  : 		return true;

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	e9 f9 00 00 00	 jmp	 $LN1@PIT_CheckL
$LN3@PIT_CheckL:

; 910  : 	}
; 911  : 
; 912  : 	if (P_BoxOnLineSide(tmbbox, ld) != -1)

  000b1	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET _tmbbox
  000ba	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  000bf	83 c4 08	 add	 esp, 8
  000c2	83 f8 ff	 cmp	 eax, -1
  000c5	74 0a		 je	 SHORT $LN5@PIT_CheckL

; 913  : 		return true;

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	e9 d9 00 00 00	 jmp	 $LN1@PIT_CheckL
$LN5@PIT_CheckL:

; 914  : 
; 915  : 	// A line has been hit
; 916  : 
; 917  : 	// The moving thing's destination position will cross
; 918  : 	// the given line.
; 919  : 	// If this should not be allowed, return false.
; 920  : 	// If the line is special, keep track of it
; 921  : 	// to process later if the move is proven ok.
; 922  : 	// NOTE: specials are NOT sorted by order,
; 923  : 	// so two special lines that are only 8 pixels apart
; 924  : 	// could be crossed in either order.
; 925  : 
; 926  : 	// this line is out of the if so upper and lower textures can be hit by a splat
; 927  : 	blockingline = ld;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000d4	a3 00 00 00 00	 mov	 DWORD PTR _blockingline, eax

; 928  : 	if (!ld->backsector)

  000d9	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000dc	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  000e0	75 07		 jne	 SHORT $LN6@PIT_CheckL

; 929  : 		return false; // one sided line

  000e2	33 c0		 xor	 eax, eax
  000e4	e9 c1 00 00 00	 jmp	 $LN1@PIT_CheckL
$LN6@PIT_CheckL:

; 930  : 
; 931  : 	// missiles can cross uncrossable lines
; 932  : 	if (!(tmthing->flags & MF_MISSILE))

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  000ee	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  000f1	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  000f7	75 3b		 jne	 SHORT $LN8@PIT_CheckL

; 933  : 	{
; 934  : 		if (((tmthing->flags & MF_ENEMY) || (tmthing->flags & MF_BOSS) || (tmthing->type == MT_EGGGUARD)) && ld->flags & ML_BLOCKMONSTERS)

  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  000fe	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00101	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00107	75 1b		 jne	 SHORT $LN9@PIT_CheckL
  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0010e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00111	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00117	75 0b		 jne	 SHORT $LN9@PIT_CheckL
  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0011e	83 78 7c 15	 cmp	 DWORD PTR [eax+124], 21	; 00000015H
  00122	75 10		 jne	 SHORT $LN8@PIT_CheckL
$LN9@PIT_CheckL:
  00124	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00127	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0012b	83 e1 02	 and	 ecx, 2
  0012e	74 04		 je	 SHORT $LN8@PIT_CheckL

; 935  : 			return false; // block monsters only

  00130	33 c0		 xor	 eax, eax
  00132	eb 76		 jmp	 SHORT $LN1@PIT_CheckL
$LN8@PIT_CheckL:

; 936  : 	}
; 937  : 
; 938  : 	// set openrange, opentop, openbottom
; 939  : 	P_LineOpening(ld);

  00134	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _P_LineOpening
  0013d	83 c4 04	 add	 esp, 4

; 940  : 
; 941  : 	// adjust floor / ceiling heights
; 942  : 	if (opentop < tmceilingz)

  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  00145	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmceilingz
  0014b	7d 1e		 jge	 SHORT $LN10@PIT_CheckL

; 943  : 	{
; 944  : 		tmsectorceilingz = tmceilingz = opentop;

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  00152	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0015d	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmsectorceilingz, ecx

; 945  : 		ceilingline = ld;

  00163	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00166	a3 00 00 00 00	 mov	 DWORD PTR _ceilingline, eax
$LN10@PIT_CheckL:

; 946  : 	}
; 947  : 
; 948  : 	if (openbottom > tmfloorz)

  0016b	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  00170	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmfloorz
  00176	7e 16		 jle	 SHORT $LN11@PIT_CheckL

; 949  : 	{
; 950  : 		tmsectorfloorz = tmfloorz = openbottom;

  00178	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  0017d	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00188	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmsectorfloorz, ecx
$LN11@PIT_CheckL:

; 951  : 	}
; 952  : 
; 953  : 	if (lowfloor < tmdropoffz)

  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowfloor
  00193	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmdropoffz
  00199	7d 0a		 jge	 SHORT $LN12@PIT_CheckL

; 954  : 		tmdropoffz = lowfloor;

  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowfloor
  001a0	a3 00 00 00 00	 mov	 DWORD PTR _tmdropoffz, eax
$LN12@PIT_CheckL:

; 955  : 
; 956  : 	return true;

  001a5	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_CheckL:

; 957  : }

  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5b		 pop	 ebx
  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
_PIT_CheckLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_CheckCameraLine
_TEXT	SEGMENT
_ld$ = 8						; size = 4
_PIT_CheckCameraLine PROC				; COMDAT

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 848  : 	if (ld->polyobj && !(ld->polyobj->flags & POF_SOLID))

  00009	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0000c	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00010	74 1b		 je	 SHORT $LN2@PIT_CheckC
  00012	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00015	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00018	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  0001e	83 e2 03	 and	 edx, 3
  00021	75 0a		 jne	 SHORT $LN2@PIT_CheckC

; 849  : 		return true;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	e9 2f 01 00 00	 jmp	 $LN1@PIT_CheckC
$LN2@PIT_CheckC:

; 850  : 
; 851  : 	if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] || tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT]
; 852  : 		|| tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] || tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])

  0002d	b8 04 00 00 00	 mov	 eax, 4
  00032	6b c8 03	 imul	 ecx, eax, 3
  00035	ba 04 00 00 00	 mov	 edx, 4
  0003a	d1 e2		 shl	 edx, 1
  0003c	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0003f	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[ecx]
  00045	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00049	7e 5c		 jle	 SHORT $LN4@PIT_CheckC
  0004b	b8 04 00 00 00	 mov	 eax, 4
  00050	d1 e0		 shl	 eax, 1
  00052	b9 04 00 00 00	 mov	 ecx, 4
  00057	6b d1 03	 imul	 edx, ecx, 3
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  0005d	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _tmbbox[eax]
  00063	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  00067	7d 3e		 jge	 SHORT $LN4@PIT_CheckC
  00069	b8 04 00 00 00	 mov	 eax, 4
  0006e	6b c8 00	 imul	 ecx, eax, 0
  00071	ba 04 00 00 00	 mov	 edx, 4
  00076	c1 e2 00	 shl	 edx, 0
  00079	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  0007c	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[ecx]
  00082	3b 4c 10 1c	 cmp	 ecx, DWORD PTR [eax+edx+28]
  00086	7e 1f		 jle	 SHORT $LN4@PIT_CheckC
  00088	b8 04 00 00 00	 mov	 eax, 4
  0008d	c1 e0 00	 shl	 eax, 0
  00090	b9 04 00 00 00	 mov	 ecx, 4
  00095	6b d1 00	 imul	 edx, ecx, 0
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _ld$[ebp]
  0009b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _tmbbox[eax]
  000a1	3b 44 11 1c	 cmp	 eax, DWORD PTR [ecx+edx+28]
  000a5	7c 0a		 jl	 SHORT $LN3@PIT_CheckC
$LN4@PIT_CheckC:

; 853  : 	{
; 854  : 		return true;

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	e9 ab 00 00 00	 jmp	 $LN1@PIT_CheckC
$LN3@PIT_CheckC:

; 855  : 	}
; 856  : 
; 857  : 	if (P_BoxOnLineSide(tmbbox, ld) != -1)

  000b1	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET _tmbbox
  000ba	e8 00 00 00 00	 call	 _P_BoxOnLineSide
  000bf	83 c4 08	 add	 esp, 8
  000c2	83 f8 ff	 cmp	 eax, -1
  000c5	74 0a		 je	 SHORT $LN5@PIT_CheckC

; 858  : 		return true;

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	e9 8b 00 00 00	 jmp	 $LN1@PIT_CheckC
$LN5@PIT_CheckC:

; 859  : 
; 860  : 	// A line has been hit
; 861  : 
; 862  : 	// The moving thing's destination position will cross
; 863  : 	// the given line.
; 864  : 	// If this should not be allowed, return false.
; 865  : 	// If the line is special, keep track of it
; 866  : 	// to process later if the move is proven ok.
; 867  : 	// NOTE: specials are NOT sorted by order,
; 868  : 	// so two special lines that are only 8 pixels apart
; 869  : 	// could be crossed in either order.
; 870  : 
; 871  : 	// this line is out of the if so upper and lower textures can be hit by a splat
; 872  : 	blockingline = ld;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000d4	a3 00 00 00 00	 mov	 DWORD PTR _blockingline, eax

; 873  : 	if (!ld->backsector)

  000d9	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000dc	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  000e0	75 04		 jne	 SHORT $LN6@PIT_CheckC

; 874  : 		return false; // one sided line

  000e2	33 c0		 xor	 eax, eax
  000e4	eb 76		 jmp	 SHORT $LN1@PIT_CheckC
$LN6@PIT_CheckC:

; 875  : 
; 876  : 	// set openrange, opentop, openbottom
; 877  : 	P_CameraLineOpening(ld);

  000e6	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _P_CameraLineOpening
  000ef	83 c4 04	 add	 esp, 4

; 878  : 
; 879  : 	// adjust floor / ceiling heights
; 880  : 	if (opentop < tmceilingz)

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  000f7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmceilingz
  000fd	7d 1e		 jge	 SHORT $LN7@PIT_CheckC

; 881  : 	{
; 882  : 		tmsectorceilingz = tmceilingz = opentop;

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _opentop
  00104	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax
  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0010f	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmsectorceilingz, ecx

; 883  : 		ceilingline = ld;

  00115	8b 45 08	 mov	 eax, DWORD PTR _ld$[ebp]
  00118	a3 00 00 00 00	 mov	 DWORD PTR _ceilingline, eax
$LN7@PIT_CheckC:

; 884  : 	}
; 885  : 
; 886  : 	if (openbottom > tmfloorz)

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  00122	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmfloorz
  00128	7e 16		 jle	 SHORT $LN8@PIT_CheckC

; 887  : 	{
; 888  : 		tmsectorfloorz = tmfloorz = openbottom;

  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR _openbottom
  0012f	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  0013a	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmsectorfloorz, ecx
$LN8@PIT_CheckC:

; 889  : 	}
; 890  : 
; 891  : 	if (lowfloor < tmdropoffz)

  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowfloor
  00145	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmdropoffz
  0014b	7d 0a		 jge	 SHORT $LN9@PIT_CheckC

; 892  : 		tmdropoffz = lowfloor;

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowfloor
  00152	a3 00 00 00 00	 mov	 DWORD PTR _tmdropoffz, eax
$LN9@PIT_CheckC:

; 893  : 
; 894  : 	return true;

  00157	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_CheckC:

; 895  : }

  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
_PIT_CheckCameraLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_CheckThing
_TEXT	SEGMENT
tv824 = -84						; size = 4
tv239 = -80						; size = 4
tv819 = -80						; size = 4
tv942 = -80						; size = 4
tv1072 = -80						; size = 4
tv1157 = -80						; size = 4
tv1347 = -80						; size = 4
_tmtopz$ = -12						; size = 4
_topz$ = -8						; size = 4
_blockdist$ = -4					; size = 4
_thing$ = 8						; size = 4
_PIT_CheckThing PROC					; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 193  : 	fixed_t blockdist, topz, tmtopz;
; 194  : 
; 195  : 	// don't clip against self
; 196  : 	tmsprung = false;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmsprung, 0

; 197  : 
; 198  : 	// Ignore spectators, except when using a spring.
; 199  : 	if ((tmthing->player && tmthing->player->spectator && !(thing->flags & MF_SPRING)) ||

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00018	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0001f	74 24		 je	 SHORT $LN10@PIT_CheckT
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00026	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0002c	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  00033	85 d2		 test	 edx, edx
  00035	74 0e		 je	 SHORT $LN10@PIT_CheckT
  00037	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0003a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0003d	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  00043	74 20		 je	 SHORT $LN9@PIT_CheckT
$LN10@PIT_CheckT:
  00045	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00048	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0004f	74 1e		 je	 SHORT $LN8@PIT_CheckT
  00051	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00054	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0005a	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  00061	85 d2		 test	 edx, edx
  00063	74 0a		 je	 SHORT $LN8@PIT_CheckT
$LN9@PIT_CheckT:

; 200  : 		(thing->player && thing->player->spectator))
; 201  : 		return true;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	e9 b3 21 00 00	 jmp	 $LN1@PIT_CheckT
$LN8@PIT_CheckT:

; 202  : 
; 203  : 	if (!(thing->flags & (MF_SOLID|MF_SPECIAL|MF_SHOOTABLE)))

  0006f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00072	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00075	83 e1 07	 and	 ecx, 7
  00078	75 0a		 jne	 SHORT $LN11@PIT_CheckT

; 204  : 		return true;

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	e9 9e 21 00 00	 jmp	 $LN1@PIT_CheckT
$LN11@PIT_CheckT:

; 205  : 
; 206  : 	if (!tmthing || !thing || thing == tmthing || !thing->state || thing->state == &states[S_DISS])

  00084	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmthing, 0
  0008b	74 33		 je	 SHORT $LN13@PIT_CheckT
  0008d	83 7d 08 00	 cmp	 DWORD PTR _thing$[ebp], 0
  00091	74 2d		 je	 SHORT $LN13@PIT_CheckT
  00093	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00096	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmthing
  0009c	74 22		 je	 SHORT $LN13@PIT_CheckT
  0009e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000a1	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  000a5	74 19		 je	 SHORT $LN13@PIT_CheckT
  000a7	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  000ac	69 c8 4f 06 00
	00		 imul	 ecx, eax, 1615
  000b2	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  000b8	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000bb	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  000be	75 0a		 jne	 SHORT $LN12@PIT_CheckT
$LN13@PIT_CheckT:

; 207  : 		return true;

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	e9 58 21 00 00	 jmp	 $LN1@PIT_CheckT
$LN12@PIT_CheckT:

; 208  : 
; 209  : 	// Don't collide with your buddies while NiGHTS-flying.
; 210  : 	if (tmthing->player && thing->player && (maptol & TOL_NIGHTS)
; 211  : 		&& ((tmthing->player->pflags & PF_NIGHTSMODE) || (thing->player->pflags & PF_NIGHTSMODE)))

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  000cf	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000d6	74 52		 je	 SHORT $LN14@PIT_CheckT
  000d8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000db	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000e2	74 46		 je	 SHORT $LN14@PIT_CheckT
  000e4	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  000eb	83 e0 40	 and	 eax, 64			; 00000040H
  000ee	74 3a		 je	 SHORT $LN14@PIT_CheckT
  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  000f5	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000fb	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00101	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  00107	75 17		 jne	 SHORT $LN15@PIT_CheckT
  00109	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0010c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00112	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00118	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  0011e	74 0a		 je	 SHORT $LN14@PIT_CheckT
$LN15@PIT_CheckT:

; 212  : 		return true;

  00120	b8 01 00 00 00	 mov	 eax, 1
  00125	e9 f8 20 00 00	 jmp	 $LN1@PIT_CheckT
$LN14@PIT_CheckT:

; 213  : 
; 214  : 	blockdist = thing->radius + tmthing->radius;

  0012a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0012d	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00130	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00136	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00139	89 4d fc	 mov	 DWORD PTR _blockdist$[ebp], ecx

; 215  : 
; 216  : 	if (abs(thing->x - tmx) >= blockdist || abs(thing->y - tmy) >= blockdist)

  0013c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0013f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00142	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _tmx
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 _abs
  0014e	83 c4 04	 add	 esp, 4
  00151	3b 45 fc	 cmp	 eax, DWORD PTR _blockdist$[ebp]
  00154	7d 1a		 jge	 SHORT $LN17@PIT_CheckT
  00156	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00159	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015c	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _tmy
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 _abs
  00168	83 c4 04	 add	 esp, 4
  0016b	3b 45 fc	 cmp	 eax, DWORD PTR _blockdist$[ebp]
  0016e	7c 0a		 jl	 SHORT $LN16@PIT_CheckT
$LN17@PIT_CheckT:

; 217  : 		return true; // didn't hit it

  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	e9 a8 20 00 00	 jmp	 $LN1@PIT_CheckT
$LN16@PIT_CheckT:

; 218  : 
; 219  : 	if (thing->type == MT_HOOPCOLLIDE)

  0017a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0017d	81 78 7c f9 00
	00 00		 cmp	 DWORD PTR [eax+124], 249 ; 000000f9H
  00184	75 29		 jne	 SHORT $LN18@PIT_CheckT

; 220  : 	{
; 221  : 		if (thing->flags & MF_SPECIAL)

  00186	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00189	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0018c	83 e1 01	 and	 ecx, 1
  0018f	74 14		 je	 SHORT $LN19@PIT_CheckT

; 222  : 			P_TouchSpecialThing(thing, tmthing, true);

  00191	6a 01		 push	 1
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00198	50		 push	 eax
  00199	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0019c	51		 push	 ecx
  0019d	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@PIT_CheckT:

; 223  : 		return true;

  001a5	b8 01 00 00 00	 mov	 eax, 1
  001aa	e9 73 20 00 00	 jmp	 $LN1@PIT_CheckT
$LN18@PIT_CheckT:

; 224  : 	}
; 225  : 	if (tmthing->type == MT_HOOPCOLLIDE)

  001af	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  001b4	81 78 7c f9 00
	00 00		 cmp	 DWORD PTR [eax+124], 249 ; 000000f9H
  001bb	75 2c		 jne	 SHORT $LN20@PIT_CheckT

; 226  : 	{
; 227  : 		if (tmthing->flags & MF_SPECIAL)

  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  001c2	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  001c5	83 e1 01	 and	 ecx, 1
  001c8	74 15		 je	 SHORT $LN21@PIT_CheckT

; 228  : 			P_TouchSpecialThing(tmthing, thing, true);

  001ca	6a 01		 push	 1
  001cc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001cf	50		 push	 eax
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  001d6	51		 push	 ecx
  001d7	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@PIT_CheckT:

; 229  : 		return true;

  001df	b8 01 00 00 00	 mov	 eax, 1
  001e4	e9 39 20 00 00	 jmp	 $LN1@PIT_CheckT
$LN20@PIT_CheckT:

; 230  : 	}
; 231  : 
; 232  : 	// check for skulls slamming into things
; 233  : 	if (tmthing->flags2 & MF2_SKULLFLY)

  001e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  001ee	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  001f4	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  001fa	0f 84 90 00 00
	00		 je	 $LN24@PIT_CheckT

; 234  : 	{
; 235  : 		if (tmthing->type == MT_EGGMOBILE) // Don't make Eggman stop!

  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00205	83 78 7c 1d	 cmp	 DWORD PTR [eax+124], 29	; 0000001dH
  00209	75 3b		 jne	 SHORT $LN23@PIT_CheckT

; 236  : 		{
; 237  : 			tmthing->momx = -tmthing->momx;

  0020b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00210	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00213	f7 d9		 neg	 ecx
  00215	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0021b	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 238  : 			tmthing->momy = -tmthing->momy;

  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00223	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00226	f7 d9		 neg	 ecx
  00228	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0022e	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 239  : 			tmthing->momz = -tmthing->momz;

  00231	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00236	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00239	f7 d9		 neg	 ecx
  0023b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00241	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 240  : 		}

  00244	eb 4a		 jmp	 SHORT $LN24@PIT_CheckT
$LN23@PIT_CheckT:

; 241  : 		else
; 242  : 		{
; 243  : 			tmthing->flags2 &= ~MF2_SKULLFLY;

  00246	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0024b	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  00251	81 e1 ff ef ff
	ff		 and	 ecx, -4097		; ffffefffH
  00257	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0025d	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 244  : 			tmthing->momx = tmthing->momy = tmthing->momz = 0;

  00263	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00268	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00275	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  0027c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00282	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 245  : 			return false; // stop moving

  00289	33 c0		 xor	 eax, eax
  0028b	e9 92 1f 00 00	 jmp	 $LN1@PIT_CheckT
$LN24@PIT_CheckT:

; 246  : 		}
; 247  : 	}
; 248  : 
; 249  : 	// missiles can hit other things
; 250  : 	if (tmthing->flags & MF_MISSILE || tmthing->type == MT_SHELL || tmthing->type == MT_FIREBALL)

  00290	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00295	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00298	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  0029e	75 20		 jne	 SHORT $LN26@PIT_CheckT
  002a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  002a5	81 78 7c e8 00
	00 00		 cmp	 DWORD PTR [eax+124], 232 ; 000000e8H
  002ac	74 12		 je	 SHORT $LN26@PIT_CheckT
  002ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  002b3	81 78 7c e7 00
	00 00		 cmp	 DWORD PTR [eax+124], 231 ; 000000e7H
  002ba	0f 85 61 04 00
	00		 jne	 $LN52@PIT_CheckT
$LN26@PIT_CheckT:

; 251  : 	{
; 252  : 		// see if it went over / under
; 253  : 		if (tmthing->z > thing->z + thing->height)

  002c0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002c3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002c6	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  002c9	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  002cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  002d1	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  002d4	7e 0a		 jle	 SHORT $LN27@PIT_CheckT

; 254  : 			return true; // overhead

  002d6	b8 01 00 00 00	 mov	 eax, 1
  002db	e9 42 1f 00 00	 jmp	 $LN1@PIT_CheckT
$LN27@PIT_CheckT:

; 255  : 		if (tmthing->z + tmthing->height < thing->z)

  002e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  002e5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  002ee	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  002f1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002f4	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  002f7	7d 0a		 jge	 SHORT $LN28@PIT_CheckT

; 256  : 			return true; // underneath

  002f9	b8 01 00 00 00	 mov	 eax, 1
  002fe	e9 1f 1f 00 00	 jmp	 $LN1@PIT_CheckT
$LN28@PIT_CheckT:

; 257  : 
; 258  : 		if (tmthing->type != MT_SHELL && tmthing->target && tmthing->target->type == thing->type)

  00303	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00308	81 78 7c e8 00
	00 00		 cmp	 DWORD PTR [eax+124], 232 ; 000000e8H
  0030f	74 4e		 je	 SHORT $LN31@PIT_CheckT
  00311	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00316	83 b8 98 00 00
	00 00		 cmp	 DWORD PTR [eax+152], 0
  0031d	74 40		 je	 SHORT $LN31@PIT_CheckT
  0031f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00324	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0032a	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0032d	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  00330	3b 42 7c	 cmp	 eax, DWORD PTR [edx+124]
  00333	75 2a		 jne	 SHORT $LN31@PIT_CheckT

; 259  : 		{
; 260  : 			// Don't hit same species as originator.
; 261  : 			if (thing == tmthing->target)

  00335	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0033a	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0033d	3b 88 98 00 00
	00		 cmp	 ecx, DWORD PTR [eax+152]
  00343	75 0a		 jne	 SHORT $LN30@PIT_CheckT

; 262  : 				return true;

  00345	b8 01 00 00 00	 mov	 eax, 1
  0034a	e9 d3 1e 00 00	 jmp	 $LN1@PIT_CheckT
$LN30@PIT_CheckT:

; 263  : 
; 264  : 			if (thing->type != MT_PLAYER)

  0034f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00352	83 78 7c 00	 cmp	 DWORD PTR [eax+124], 0
  00356	74 07		 je	 SHORT $LN31@PIT_CheckT

; 265  : 			{
; 266  : 				// Explode, but do no damage.
; 267  : 				// Let players missile other players.
; 268  : 				return false;

  00358	33 c0		 xor	 eax, eax
  0035a	e9 c3 1e 00 00	 jmp	 $LN1@PIT_CheckT
$LN31@PIT_CheckT:

; 269  : 			}
; 270  : 		}
; 271  : 
; 272  : 		// Special case for bounce rings so they don't get caught behind solid objects.
; 273  : 		if ((tmthing->type == MT_THROWNBOUNCE && tmthing->fuse > 8*TICRATE) && thing->flags & MF_SOLID)

  0035f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00364	81 78 7c dc 00
	00 00		 cmp	 DWORD PTR [eax+124], 220 ; 000000dcH
  0036b	75 26		 jne	 SHORT $LN32@PIT_CheckT
  0036d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00372	81 b8 bc 00 00
	00 18 01 00 00	 cmp	 DWORD PTR [eax+188], 280 ; 00000118H
  0037c	7e 15		 jle	 SHORT $LN32@PIT_CheckT
  0037e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00381	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00384	83 e1 02	 and	 ecx, 2
  00387	74 0a		 je	 SHORT $LN32@PIT_CheckT

; 274  : 			return true;

  00389	b8 01 00 00 00	 mov	 eax, 1
  0038e	e9 8f 1e 00 00	 jmp	 $LN1@PIT_CheckT
$LN32@PIT_CheckT:

; 275  : 
; 276  : 		if (tmthing->type == MT_BLACKEGGMAN_MISSILE
; 277  : 			&& thing->type == MT_BLACKEGGMAN
; 278  : 			&& tmthing->target != thing)

  00393	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00398	83 78 7c 2a	 cmp	 DWORD PTR [eax+124], 42	; 0000002aH
  0039c	75 39		 jne	 SHORT $LN33@PIT_CheckT
  0039e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003a1	83 78 7c 27	 cmp	 DWORD PTR [eax+124], 39	; 00000027H
  003a5	75 30		 jne	 SHORT $LN33@PIT_CheckT
  003a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  003ac	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  003b2	3b 4d 08	 cmp	 ecx, DWORD PTR _thing$[ebp]
  003b5	74 20		 je	 SHORT $LN33@PIT_CheckT

; 279  : 		{
; 280  : 			P_SetMobjState(thing, thing->info->painstate);

  003b7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003ba	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  003c0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003c3	52		 push	 edx
  003c4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 _P_SetMobjState
  003cd	83 c4 08	 add	 esp, 8

; 281  : 			return false;

  003d0	33 c0		 xor	 eax, eax
  003d2	e9 4b 1e 00 00	 jmp	 $LN1@PIT_CheckT
$LN33@PIT_CheckT:

; 282  : 		}
; 283  : 
; 284  : 		if (!(thing->flags & MF_SHOOTABLE))

  003d7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003da	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  003dd	83 e1 04	 and	 ecx, 4
  003e0	75 23		 jne	 SHORT $LN34@PIT_CheckT

; 285  : 		{
; 286  : 			// didn't do any damage
; 287  : 			return !(thing->flags & MF_SOLID);

  003e2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003e5	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  003e8	83 e1 02	 and	 ecx, 2
  003eb	75 09		 jne	 SHORT $LN219@PIT_CheckT
  003ed	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv239[ebp], 1
  003f4	eb 07		 jmp	 SHORT $LN220@PIT_CheckT
$LN219@PIT_CheckT:
  003f6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv239[ebp], 0
$LN220@PIT_CheckT:
  003fd	8b 45 b0	 mov	 eax, DWORD PTR tv239[ebp]
  00400	e9 1d 1e 00 00	 jmp	 $LN1@PIT_CheckT
$LN34@PIT_CheckT:

; 288  : 		}
; 289  : 
; 290  : 		if (tmthing->type == MT_SHELL && tmthing->threshold > TICRATE)

  00405	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0040a	81 78 7c e8 00
	00 00		 cmp	 DWORD PTR [eax+124], 232 ; 000000e8H
  00411	75 18		 jne	 SHORT $LN35@PIT_CheckT
  00413	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00418	83 b8 a0 00 00
	00 23		 cmp	 DWORD PTR [eax+160], 35	; 00000023H
  0041f	7e 0a		 jle	 SHORT $LN35@PIT_CheckT

; 291  : 			return true;

  00421	b8 01 00 00 00	 mov	 eax, 1
  00426	e9 f7 1d 00 00	 jmp	 $LN1@PIT_CheckT
$LN35@PIT_CheckT:

; 292  : #ifdef SEENAMES
; 293  : 		if (tmthing->type == MT_NAMECHECK)

  0042b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00430	81 78 7c 3d 01
	00 00		 cmp	 DWORD PTR [eax+124], 317 ; 0000013dH
  00437	75 66		 jne	 SHORT $LN36@PIT_CheckT

; 294  : 		{
; 295  : 			if (thing->player && tmthing->target->player && thing->player != tmthing->target->player) // Don't hit yourself

  00439	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0043c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00443	74 53		 je	 SHORT $LN38@PIT_CheckT
  00445	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0044a	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00450	83 b9 a4 00 00
	00 00		 cmp	 DWORD PTR [ecx+164], 0
  00457	74 3f		 je	 SHORT $LN38@PIT_CheckT
  00459	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0045e	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00464	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00467	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0046d	3b 81 a4 00 00
	00		 cmp	 eax, DWORD PTR [ecx+164]
  00473	74 23		 je	 SHORT $LN38@PIT_CheckT

; 296  : 				if (!thing->player->spectator) // Can't see spectators

  00475	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00478	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0047e	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  00485	85 d2		 test	 edx, edx
  00487	75 0f		 jne	 SHORT $LN38@PIT_CheckT

; 297  : 					seenplayer = thing->player;

  00489	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0048c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00492	89 0d 00 00 00
	00		 mov	 DWORD PTR _seenplayer, ecx
$LN38@PIT_CheckT:

; 298  : 			return false;

  00498	33 c0		 xor	 eax, eax
  0049a	e9 83 1d 00 00	 jmp	 $LN1@PIT_CheckT
$LN36@PIT_CheckT:

; 299  : 		}
; 300  : #endif
; 301  : 		// damage / explode
; 302  : 		if (tmthing->flags & MF_ENEMY) // An actual ENEMY! (Like the deton, for example)

  0049f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  004a4	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  004a7	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  004ad	74 20		 je	 SHORT $LN39@PIT_CheckT

; 303  : 			P_DamageMobj(thing, tmthing, tmthing, 1);

  004af	6a 01		 push	 1
  004b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  004b6	50		 push	 eax
  004b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  004bd	51		 push	 ecx
  004be	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  004c1	52		 push	 edx
  004c2	e8 00 00 00 00	 call	 _P_DamageMobj
  004c7	83 c4 10	 add	 esp, 16			; 00000010H
  004ca	e9 31 02 00 00	 jmp	 $LN50@PIT_CheckT
$LN39@PIT_CheckT:

; 304  : 		else if (tmthing->type == MT_BLACKEGGMAN_MISSILE && thing->player
; 305  : 			&& (thing->player->pflags & PF_JUMPED)
; 306  : 			&& !thing->player->powers[pw_flashing]
; 307  : 			&& thing->tracer != tmthing
; 308  : 			&& tmthing->target != thing)

  004cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  004d4	83 78 7c 2a	 cmp	 DWORD PTR [eax+124], 42	; 0000002aH
  004d8	0f 85 75 01 00
	00		 jne	 $LN41@PIT_CheckT
  004de	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004e1	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  004e8	0f 84 65 01 00
	00		 je	 $LN41@PIT_CheckT
  004ee	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004f1	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004f7	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  004fd	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  00503	0f 84 4a 01 00
	00		 je	 $LN41@PIT_CheckT
  00509	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0050c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00512	ba 04 00 00 00	 mov	 edx, 4
  00517	d1 e2		 shl	 edx, 1
  00519	83 7c 11 38 00	 cmp	 DWORD PTR [ecx+edx+56], 0
  0051e	0f 85 2f 01 00
	00		 jne	 $LN41@PIT_CheckT
  00524	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00527	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0052d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmthing
  00533	0f 84 1a 01 00
	00		 je	 $LN41@PIT_CheckT
  00539	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0053e	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00544	3b 4d 08	 cmp	 ecx, DWORD PTR _thing$[ebp]
  00547	0f 84 06 01 00
	00		 je	 $LN41@PIT_CheckT

; 309  : 		{
; 310  : 			// Hop on the missile for a ride!
; 311  : 			thing->player->pflags |= PF_ITEMHANG;

  0054d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00550	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00556	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0055c	81 ca 00 00 08
	00		 or	 edx, 524288		; 00080000H
  00562	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00565	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0056b	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 312  : 			thing->player->pflags &= ~PF_JUMPED;

  00571	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00574	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0057a	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00580	81 e2 ff ef ff
	ff		 and	 edx, -4097		; ffffefffH
  00586	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00589	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0058f	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 313  : 			P_SetTarget(&thing->tracer, tmthing);

  00595	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0059a	50		 push	 eax
  0059b	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0059e	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  005a4	51		 push	 ecx
  005a5	e8 00 00 00 00	 call	 _P_SetTarget
  005aa	83 c4 08	 add	 esp, 8

; 314  : 			P_SetTarget(&tmthing->target, thing); // Set owner to the player

  005ad	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005b0	50		 push	 eax
  005b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  005b7	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  005bd	51		 push	 ecx
  005be	e8 00 00 00 00	 call	 _P_SetTarget
  005c3	83 c4 08	 add	 esp, 8

; 315  : 			P_SetTarget(&tmthing->tracer, NULL); // Disable homing-ness

  005c6	6a 00		 push	 0
  005c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  005cd	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  005d2	50		 push	 eax
  005d3	e8 00 00 00 00	 call	 _P_SetTarget
  005d8	83 c4 08	 add	 esp, 8

; 316  : 			tmthing->momz = 0;

  005db	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  005e0	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 317  : 
; 318  : 			thing->angle = tmthing->angle;

  005e7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  005f0	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  005f3	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 319  : 
; 320  : 			if (thing->player == &players[consoleplayer])

  005f6	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00600	05 00 00 00 00	 add	 eax, OFFSET _players
  00605	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00608	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  0060e	75 0e		 jne	 SHORT $LN43@PIT_CheckT

; 321  : 				localangle = thing->angle;

  00610	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00613	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00616	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle, ecx
  0061c	eb 26		 jmp	 SHORT $LN45@PIT_CheckT
$LN43@PIT_CheckT:

; 322  : 			else if (thing->player == &players[secondarydisplayplayer])

  0061e	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00628	05 00 00 00 00	 add	 eax, OFFSET _players
  0062d	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00630	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  00636	75 0c		 jne	 SHORT $LN45@PIT_CheckT

; 323  : 				localangle2 = thing->angle;

  00638	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0063b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0063e	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle2, ecx
$LN45@PIT_CheckT:

; 324  : 
; 325  : 			return true;

  00644	b8 01 00 00 00	 mov	 eax, 1
  00649	e9 d4 1b 00 00	 jmp	 $LN1@PIT_CheckT

; 326  : 		}

  0064e	e9 ad 00 00 00	 jmp	 $LN50@PIT_CheckT
$LN41@PIT_CheckT:

; 327  : 		else if (tmthing->type == MT_BLACKEGGMAN_MISSILE && thing->player && ((thing->player->pflags & PF_ITEMHANG) || (thing->player->pflags & PF_JUMPED)))

  00653	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00658	83 78 7c 2a	 cmp	 DWORD PTR [eax+124], 42	; 0000002aH
  0065c	75 3c		 jne	 SHORT $LN46@PIT_CheckT
  0065e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00661	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00668	74 30		 je	 SHORT $LN46@PIT_CheckT
  0066a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0066d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00673	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00679	81 e2 00 00 08
	00		 and	 edx, 524288		; 00080000H
  0067f	75 17		 jne	 SHORT $LN48@PIT_CheckT
  00681	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00684	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0068a	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00690	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  00696	74 02		 je	 SHORT $LN46@PIT_CheckT
$LN48@PIT_CheckT:

; 328  : 		{
; 329  : 			// Ignore
; 330  : 		}

  00698	eb 66		 jmp	 SHORT $LN50@PIT_CheckT
$LN46@PIT_CheckT:

; 331  : 		else if (tmthing->type == MT_BLACKEGGMAN_GOOPFIRE)

  0069a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0069f	83 78 7c 29	 cmp	 DWORD PTR [eax+124], 41	; 00000029H
  006a3	75 3a		 jne	 SHORT $LN49@PIT_CheckT

; 332  : 		{
; 333  : 			P_UnsetThingPosition(tmthing);

  006a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  006b0	83 c4 04	 add	 esp, 4

; 334  : 			tmthing->x = thing->x;

  006b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  006b8	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  006bb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  006be	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 335  : 			tmthing->y = thing->y;

  006c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  006c6	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  006c9	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  006cc	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 336  : 			P_SetThingPosition(tmthing);

  006cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  006d4	50		 push	 eax
  006d5	e8 00 00 00 00	 call	 _P_SetThingPosition
  006da	83 c4 04	 add	 esp, 4

; 337  : 		}

  006dd	eb 21		 jmp	 SHORT $LN50@PIT_CheckT
$LN49@PIT_CheckT:

; 338  : 		else
; 339  : 			P_DamageMobj(thing, tmthing, tmthing->target, 1);

  006df	6a 01		 push	 1
  006e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  006e6	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  006ec	51		 push	 ecx
  006ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  006f3	52		 push	 edx
  006f4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  006f7	50		 push	 eax
  006f8	e8 00 00 00 00	 call	 _P_DamageMobj
  006fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN50@PIT_CheckT:

; 340  : 
; 341  : 		// don't traverse any more
; 342  : 
; 343  : 		if (tmthing->type == MT_SHELL)

  00700	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00705	81 78 7c e8 00
	00 00		 cmp	 DWORD PTR [eax+124], 232 ; 000000e8H
  0070c	75 0c		 jne	 SHORT $LN51@PIT_CheckT

; 344  : 			return true;

  0070e	b8 01 00 00 00	 mov	 eax, 1
  00713	e9 0a 1b 00 00	 jmp	 $LN1@PIT_CheckT
  00718	eb 07		 jmp	 SHORT $LN52@PIT_CheckT
$LN51@PIT_CheckT:

; 345  : 		else
; 346  : 			return false;

  0071a	33 c0		 xor	 eax, eax
  0071c	e9 01 1b 00 00	 jmp	 $LN1@PIT_CheckT
$LN52@PIT_CheckT:

; 347  : 	}
; 348  : 
; 349  : 	if ((thing->flags & MF_PUSHABLE) && (tmthing->player || tmthing->flags & MF_PUSHABLE)
; 350  : 		&& tmthing->z + tmthing->height > thing->z && tmthing->z < thing->z + thing->height
; 351  : 		&& !(netgame && tmthing->player && tmthing->player->spectator)) // Push thing!

  00721	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00724	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00727	83 e1 40	 and	 ecx, 64			; 00000040H
  0072a	0f 84 78 03 00
	00		 je	 $LN53@PIT_CheckT
  00730	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00735	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0073c	75 11		 jne	 SHORT $LN54@PIT_CheckT
  0073e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00743	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00746	83 e1 40	 and	 ecx, 64			; 00000040H
  00749	0f 84 59 03 00
	00		 je	 $LN53@PIT_CheckT
$LN54@PIT_CheckT:
  0074f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00754	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00757	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0075d	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00760	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00763	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00766	0f 8e 3c 03 00
	00		 jle	 $LN53@PIT_CheckT
  0076c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0076f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00772	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00775	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00778	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0077d	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  00780	0f 8d 22 03 00
	00		 jge	 $LN53@PIT_CheckT
  00786	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0078d	74 28		 je	 SHORT $LN55@PIT_CheckT
  0078f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00794	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0079b	74 1a		 je	 SHORT $LN55@PIT_CheckT
  0079d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  007a2	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  007a8	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  007af	85 d2		 test	 edx, edx
  007b1	0f 85 f1 02 00
	00		 jne	 $LN53@PIT_CheckT
$LN55@PIT_CheckT:

; 352  : 	{
; 353  : 		if (thing->flags2 & MF2_SLIDEPUSH) // Make it slide

  007b7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  007ba	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  007c0	81 e1 00 00 80
	00		 and	 ecx, 8388608		; 00800000H
  007c6	0f 84 f5 01 00
	00		 je	 $LN56@PIT_CheckT

; 354  : 		{
; 355  : 			if (tmthing->momy > 0 && tmthing->momy > 4*FRACUNIT && tmthing->momy > thing->momy)

  007cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  007d1	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  007d5	7e 49		 jle	 SHORT $LN58@PIT_CheckT
  007d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  007dc	81 78 4c 00 00
	04 00		 cmp	 DWORD PTR [eax+76], 262144 ; 00040000H
  007e3	7e 3b		 jle	 SHORT $LN58@PIT_CheckT
  007e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  007ea	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  007ed	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  007f0	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  007f3	7e 2b		 jle	 SHORT $LN58@PIT_CheckT

; 356  : 			{
; 357  : 				thing->momy += PUSHACCEL;

  007f5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  007f8	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  007fb	81 c1 00 00 02
	00		 add	 ecx, 131072		; 00020000H
  00801	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00804	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 358  : 				tmthing->momy -= PUSHACCEL;

  00807	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0080c	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0080f	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  00815	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0081b	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 359  : 			}

  0081e	eb 52		 jmp	 SHORT $LN60@PIT_CheckT
$LN58@PIT_CheckT:

; 360  : 			else if (tmthing->momy < 0 && tmthing->momy < -4*FRACUNIT
; 361  : 				&& tmthing->momy < thing->momy)

  00820	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00825	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00829	7d 47		 jge	 SHORT $LN60@PIT_CheckT
  0082b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00830	81 78 4c 00 00
	fc ff		 cmp	 DWORD PTR [eax+76], -262144 ; fffc0000H
  00837	7d 39		 jge	 SHORT $LN60@PIT_CheckT
  00839	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0083e	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00841	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  00844	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  00847	7d 29		 jge	 SHORT $LN60@PIT_CheckT

; 362  : 			{
; 363  : 				thing->momy -= PUSHACCEL;

  00849	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0084c	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0084f	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  00855	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00858	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 364  : 				tmthing->momy += PUSHACCEL;

  0085b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00860	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00863	81 c1 00 00 02
	00		 add	 ecx, 131072		; 00020000H
  00869	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0086f	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx
$LN60@PIT_CheckT:

; 365  : 			}
; 366  : 			if (tmthing->momx > 0 && tmthing->momx > 4*FRACUNIT
; 367  : 				&& tmthing->momx > thing->momx)

  00872	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00877	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  0087b	7e 49		 jle	 SHORT $LN61@PIT_CheckT
  0087d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00882	81 78 48 00 00
	04 00		 cmp	 DWORD PTR [eax+72], 262144 ; 00040000H
  00889	7e 3b		 jle	 SHORT $LN61@PIT_CheckT
  0088b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00890	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00893	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  00896	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00899	7e 2b		 jle	 SHORT $LN61@PIT_CheckT

; 368  : 			{
; 369  : 				thing->momx += PUSHACCEL;

  0089b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0089e	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  008a1	81 c1 00 00 02
	00		 add	 ecx, 131072		; 00020000H
  008a7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  008aa	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 370  : 				tmthing->momx -= PUSHACCEL;

  008ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  008b2	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  008b5	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  008bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  008c1	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 371  : 			}

  008c4	eb 52		 jmp	 SHORT $LN63@PIT_CheckT
$LN61@PIT_CheckT:

; 372  : 			else if (tmthing->momx < 0 && tmthing->momx < -4*FRACUNIT
; 373  : 				&& tmthing->momx < thing->momx)

  008c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  008cb	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  008cf	7d 47		 jge	 SHORT $LN63@PIT_CheckT
  008d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  008d6	81 78 48 00 00
	fc ff		 cmp	 DWORD PTR [eax+72], -262144 ; fffc0000H
  008dd	7d 39		 jge	 SHORT $LN63@PIT_CheckT
  008df	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  008e4	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  008e7	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  008ea	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  008ed	7d 29		 jge	 SHORT $LN63@PIT_CheckT

; 374  : 			{
; 375  : 				thing->momx -= PUSHACCEL;

  008ef	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  008f2	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  008f5	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  008fb	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  008fe	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 376  : 				tmthing->momx += PUSHACCEL;

  00901	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00906	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00909	81 c1 00 00 02
	00		 add	 ecx, 131072		; 00020000H
  0090f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00915	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
$LN63@PIT_CheckT:

; 377  : 			}
; 378  : 
; 379  : 			if (thing->momx > thing->info->speed)

  00918	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0091b	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00921	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00924	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00927	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  0092a	7e 14		 jle	 SHORT $LN64@PIT_CheckT

; 380  : 				thing->momx = thing->info->speed;

  0092c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0092f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00935	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00938	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  0093b	89 42 48	 mov	 DWORD PTR [edx+72], eax
  0093e	eb 2a		 jmp	 SHORT $LN66@PIT_CheckT
$LN64@PIT_CheckT:

; 381  : 			else if (thing->momx < -(thing->info->speed))

  00940	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00943	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00949	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0094c	f7 da		 neg	 edx
  0094e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00951	39 50 48	 cmp	 DWORD PTR [eax+72], edx
  00954	7d 14		 jge	 SHORT $LN66@PIT_CheckT

; 382  : 				thing->momx = -(thing->info->speed);

  00956	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00959	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0095f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00962	f7 da		 neg	 edx
  00964	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00967	89 50 48	 mov	 DWORD PTR [eax+72], edx
$LN66@PIT_CheckT:

; 383  : 			if (thing->momy > thing->info->speed)

  0096a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0096d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00973	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00976	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00979	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  0097c	7e 14		 jle	 SHORT $LN67@PIT_CheckT

; 384  : 				thing->momy = thing->info->speed;

  0097e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00981	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00987	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0098a	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  0098d	89 42 4c	 mov	 DWORD PTR [edx+76], eax
  00990	eb 2a		 jmp	 SHORT $LN69@PIT_CheckT
$LN67@PIT_CheckT:

; 385  : 			else if (thing->momy < -(thing->info->speed))

  00992	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00995	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0099b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0099e	f7 da		 neg	 edx
  009a0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  009a3	39 50 4c	 cmp	 DWORD PTR [eax+76], edx
  009a6	7d 14		 jge	 SHORT $LN69@PIT_CheckT

; 386  : 				thing->momy = -(thing->info->speed);

  009a8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  009ab	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  009b1	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  009b4	f7 da		 neg	 edx
  009b6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  009b9	89 50 4c	 mov	 DWORD PTR [eax+76], edx
$LN69@PIT_CheckT:

; 387  : 		}

  009bc	e9 b6 00 00 00	 jmp	 $LN57@PIT_CheckT
$LN56@PIT_CheckT:

; 388  : 		else
; 389  : 		{
; 390  : 			if (tmthing->momy > 0 && tmthing->momy > 4*FRACUNIT)

  009c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  009c6	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  009ca	7e 1c		 jle	 SHORT $LN70@PIT_CheckT
  009cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  009d1	81 78 4c 00 00
	04 00		 cmp	 DWORD PTR [eax+76], 262144 ; 00040000H
  009d8	7e 0e		 jle	 SHORT $LN70@PIT_CheckT

; 391  : 				tmthing->momy = 4*FRACUNIT;

  009da	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  009df	c7 40 4c 00 00
	04 00		 mov	 DWORD PTR [eax+76], 262144 ; 00040000H
  009e6	eb 25		 jmp	 SHORT $LN72@PIT_CheckT
$LN70@PIT_CheckT:

; 392  : 			else if (tmthing->momy < 0 && tmthing->momy < -4*FRACUNIT)

  009e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  009ed	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  009f1	7d 1a		 jge	 SHORT $LN72@PIT_CheckT
  009f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  009f8	81 78 4c 00 00
	fc ff		 cmp	 DWORD PTR [eax+76], -262144 ; fffc0000H
  009ff	7d 0c		 jge	 SHORT $LN72@PIT_CheckT

; 393  : 				tmthing->momy = -4*FRACUNIT;

  00a01	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a06	c7 40 4c 00 00
	fc ff		 mov	 DWORD PTR [eax+76], -262144 ; fffc0000H
$LN72@PIT_CheckT:

; 394  : 			if (tmthing->momx > 0 && tmthing->momx > 4*FRACUNIT)

  00a0d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a12	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00a16	7e 1c		 jle	 SHORT $LN73@PIT_CheckT
  00a18	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a1d	81 78 48 00 00
	04 00		 cmp	 DWORD PTR [eax+72], 262144 ; 00040000H
  00a24	7e 0e		 jle	 SHORT $LN73@PIT_CheckT

; 395  : 				tmthing->momx = 4*FRACUNIT;

  00a26	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a2b	c7 40 48 00 00
	04 00		 mov	 DWORD PTR [eax+72], 262144 ; 00040000H
  00a32	eb 25		 jmp	 SHORT $LN75@PIT_CheckT
$LN73@PIT_CheckT:

; 396  : 			else if (tmthing->momx < 0 && tmthing->momx < -4*FRACUNIT)

  00a34	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a39	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00a3d	7d 1a		 jge	 SHORT $LN75@PIT_CheckT
  00a3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a44	81 78 48 00 00
	fc ff		 cmp	 DWORD PTR [eax+72], -262144 ; fffc0000H
  00a4b	7d 0c		 jge	 SHORT $LN75@PIT_CheckT

; 397  : 				tmthing->momx = -4*FRACUNIT;

  00a4d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a52	c7 40 48 00 00
	fc ff		 mov	 DWORD PTR [eax+72], -262144 ; fffc0000H
$LN75@PIT_CheckT:

; 398  : 
; 399  : 			thing->momx = tmthing->momx;

  00a59	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00a5c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00a62	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00a65	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 400  : 			thing->momy = tmthing->momy;

  00a68	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00a6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00a71	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00a74	89 50 4c	 mov	 DWORD PTR [eax+76], edx
$LN57@PIT_CheckT:

; 401  : 		}
; 402  : 
; 403  : 		S_StartSound(thing, thing->info->activesound);

  00a77	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00a7a	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00a80	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00a83	52		 push	 edx
  00a84	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00a87	50		 push	 eax
  00a88	e8 00 00 00 00	 call	 _S_StartSound
  00a8d	83 c4 08	 add	 esp, 8

; 404  : 
; 405  : 		P_SetTarget(&thing->target, tmthing);

  00a90	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00a95	50		 push	 eax
  00a96	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00a99	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  00a9f	51		 push	 ecx
  00aa0	e8 00 00 00 00	 call	 _P_SetTarget
  00aa5	83 c4 08	 add	 esp, 8
$LN53@PIT_CheckT:

; 406  : 	}
; 407  : 
; 408  : 	if (tmthing->type == MT_SPIKEBALL && thing->player)

  00aa8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00aad	83 78 7c 45	 cmp	 DWORD PTR [eax+124], 69	; 00000045H
  00ab1	75 23		 jne	 SHORT $LN76@PIT_CheckT
  00ab3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ab6	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00abd	74 17		 je	 SHORT $LN76@PIT_CheckT

; 409  : 		P_TouchSpecialThing(tmthing, thing, true);

  00abf	6a 01		 push	 1
  00ac1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ac4	50		 push	 eax
  00ac5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00acb	51		 push	 ecx
  00acc	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  00ad1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ad4	eb 2b		 jmp	 SHORT $LN78@PIT_CheckT
$LN76@PIT_CheckT:

; 410  : 	else if (thing->type == MT_SPIKEBALL && tmthing->player)

  00ad6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ad9	83 78 7c 45	 cmp	 DWORD PTR [eax+124], 69	; 00000045H
  00add	75 22		 jne	 SHORT $LN78@PIT_CheckT
  00adf	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00ae4	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00aeb	74 14		 je	 SHORT $LN78@PIT_CheckT

; 411  : 		P_TouchSpecialThing(thing, tmthing, true);

  00aed	6a 01		 push	 1
  00aef	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00af4	50		 push	 eax
  00af5	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00af8	51		 push	 ecx
  00af9	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  00afe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN78@PIT_CheckT:

; 412  : 
; 413  : 	// check for special pickup
; 414  : 	if (thing->flags & MF_SPECIAL)

  00b01	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00b04	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00b07	83 e1 01	 and	 ecx, 1
  00b0a	74 2c		 je	 SHORT $LN79@PIT_CheckT

; 415  : 	{
; 416  : 		if (tmthing->player)

  00b0c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00b11	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00b18	74 14		 je	 SHORT $LN80@PIT_CheckT

; 417  : 		{
; 418  : 			P_TouchSpecialThing(thing, tmthing, true); // can remove thing

  00b1a	6a 01		 push	 1
  00b1c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00b21	50		 push	 eax
  00b22	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00b25	51		 push	 ecx
  00b26	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  00b2b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN80@PIT_CheckT:

; 419  : 		}
; 420  : 		return true;

  00b2e	b8 01 00 00 00	 mov	 eax, 1
  00b33	e9 ea 16 00 00	 jmp	 $LN1@PIT_CheckT
$LN79@PIT_CheckT:

; 421  : 	}
; 422  : 	// check again for special pickup
; 423  : 	if (tmthing->flags & MF_SPECIAL)

  00b38	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00b3d	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00b40	83 e1 01	 and	 ecx, 1
  00b43	74 2b		 je	 SHORT $LN81@PIT_CheckT

; 424  : 	{
; 425  : 		if (thing->player)

  00b45	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00b48	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00b4f	74 15		 je	 SHORT $LN82@PIT_CheckT

; 426  : 		{
; 427  : 			P_TouchSpecialThing(tmthing, thing, true); // can remove thing

  00b51	6a 01		 push	 1
  00b53	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00b56	50		 push	 eax
  00b57	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00b5d	51		 push	 ecx
  00b5e	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  00b63	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN82@PIT_CheckT:

; 428  : 		}
; 429  : 		return true;

  00b66	b8 01 00 00 00	 mov	 eax, 1
  00b6b	e9 b2 16 00 00	 jmp	 $LN1@PIT_CheckT
$LN81@PIT_CheckT:

; 430  : 	}
; 431  : 
; 432  : 	if (tmthing->type == MT_EGGGUARD && thing->player)

  00b70	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00b75	83 78 7c 15	 cmp	 DWORD PTR [eax+124], 21	; 00000015H
  00b79	75 16		 jne	 SHORT $LN83@PIT_CheckT
  00b7b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00b7e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00b85	74 0a		 je	 SHORT $LN83@PIT_CheckT

; 433  : 		return true;

  00b87	b8 01 00 00 00	 mov	 eax, 1
  00b8c	e9 91 16 00 00	 jmp	 $LN1@PIT_CheckT
$LN83@PIT_CheckT:

; 434  : 
; 435  : 	// Sprite Spikes!
; 436  : 	if (tmthing->type == MT_CEILINGSPIKE)

  00b91	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00b96	83 78 7c 48	 cmp	 DWORD PTR [eax+124], 72	; 00000048H
  00b9a	75 3f		 jne	 SHORT $LN84@PIT_CheckT

; 437  : 	{
; 438  : 		if (thing->z + thing->height == tmthing->z && thing->momz >= 0)

  00b9c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00b9f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00ba2	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00ba5	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00ba8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00bad	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00bb0	75 24		 jne	 SHORT $LN86@PIT_CheckT
  00bb2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00bb5	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00bb9	7c 1b		 jl	 SHORT $LN86@PIT_CheckT

; 439  : 			P_DamageMobj(thing, tmthing, tmthing, 1); // Ouch!

  00bbb	6a 01		 push	 1
  00bbd	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00bc2	50		 push	 eax
  00bc3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00bc9	51		 push	 ecx
  00bca	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00bcd	52		 push	 edx
  00bce	e8 00 00 00 00	 call	 _P_DamageMobj
  00bd3	83 c4 10	 add	 esp, 16			; 00000010H
$LN86@PIT_CheckT:

; 440  : 	}

  00bd6	e9 03 01 00 00	 jmp	 $LN94@PIT_CheckT
$LN84@PIT_CheckT:

; 441  : 	else if (thing->type == MT_CEILINGSPIKE)

  00bdb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00bde	83 78 7c 48	 cmp	 DWORD PTR [eax+124], 72	; 00000048H
  00be2	75 42		 jne	 SHORT $LN87@PIT_CheckT

; 442  : 	{
; 443  : 		if (tmthing->z + tmthing->height == thing->z && tmthing->momz >= 0)

  00be4	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00be9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00bec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00bf2	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00bf5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00bf8	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00bfb	75 24		 jne	 SHORT $LN89@PIT_CheckT
  00bfd	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00c02	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00c06	7c 19		 jl	 SHORT $LN89@PIT_CheckT

; 444  : 			P_DamageMobj(tmthing, thing, thing, 1);

  00c08	6a 01		 push	 1
  00c0a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00c0d	50		 push	 eax
  00c0e	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00c11	51		 push	 ecx
  00c12	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00c18	52		 push	 edx
  00c19	e8 00 00 00 00	 call	 _P_DamageMobj
  00c1e	83 c4 10	 add	 esp, 16			; 00000010H
$LN89@PIT_CheckT:

; 445  : 	}

  00c21	e9 b8 00 00 00	 jmp	 $LN94@PIT_CheckT
$LN87@PIT_CheckT:

; 446  : 	else if (tmthing->type == MT_FLOORSPIKE)

  00c26	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00c2b	83 78 7c 49	 cmp	 DWORD PTR [eax+124], 73	; 00000049H
  00c2f	75 55		 jne	 SHORT $LN90@PIT_CheckT

; 447  : 	{
; 448  : 		if (thing->z == tmthing->z + tmthing->height + FRACUNIT && thing->momz <= 0)

  00c31	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00c36	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c39	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00c3f	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00c42	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  00c49	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00c4c	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  00c4f	75 33		 jne	 SHORT $LN92@PIT_CheckT
  00c51	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00c54	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00c58	7f 2a		 jg	 SHORT $LN92@PIT_CheckT

; 449  : 		{
; 450  : 			tmthing->threshold = 43;

  00c5a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00c5f	c7 80 a0 00 00
	00 2b 00 00 00	 mov	 DWORD PTR [eax+160], 43	; 0000002bH

; 451  : 			P_DamageMobj(thing, tmthing, tmthing, 1);

  00c69	6a 01		 push	 1
  00c6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00c70	50		 push	 eax
  00c71	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00c77	51		 push	 ecx
  00c78	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00c7b	52		 push	 edx
  00c7c	e8 00 00 00 00	 call	 _P_DamageMobj
  00c81	83 c4 10	 add	 esp, 16			; 00000010H
$LN92@PIT_CheckT:

; 452  : 		}
; 453  : 	}

  00c84	eb 58		 jmp	 SHORT $LN94@PIT_CheckT
$LN90@PIT_CheckT:

; 454  : 	else if (thing->type == MT_FLOORSPIKE)

  00c86	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00c89	83 78 7c 49	 cmp	 DWORD PTR [eax+124], 73	; 00000049H
  00c8d	75 4f		 jne	 SHORT $LN94@PIT_CheckT

; 455  : 	{
; 456  : 		if (tmthing->z == thing->z + thing->height + FRACUNIT
; 457  : 			&& tmthing->momz <= 0)

  00c8f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00c92	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c95	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00c98	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00c9b	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  00ca2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00ca8	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  00cab	75 31		 jne	 SHORT $LN94@PIT_CheckT
  00cad	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00cb2	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00cb6	7f 26		 jg	 SHORT $LN94@PIT_CheckT

; 458  : 		{
; 459  : 			thing->threshold = 43;

  00cb8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00cbb	c7 80 a0 00 00
	00 2b 00 00 00	 mov	 DWORD PTR [eax+160], 43	; 0000002bH

; 460  : 			P_DamageMobj(tmthing, thing, thing, 1);

  00cc5	6a 01		 push	 1
  00cc7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00cca	50		 push	 eax
  00ccb	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00cce	51		 push	 ecx
  00ccf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00cd5	52		 push	 edx
  00cd6	e8 00 00 00 00	 call	 _P_DamageMobj
  00cdb	83 c4 10	 add	 esp, 16			; 00000010H
$LN94@PIT_CheckT:

; 461  : 		}
; 462  : 	}
; 463  : 
; 464  : 	if ((tmthing->flags & MF_PUSHABLE) && tmthing->z <= (thing->z + thing->height + FRACUNIT)
; 465  : 		&& (tmthing->z + tmthing->height) >= thing->z)

  00cde	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00ce3	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00ce6	83 e1 40	 and	 ecx, 64			; 00000040H
  00ce9	0f 84 8a 00 00
	00		 je	 $LN98@PIT_CheckT
  00cef	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00cf2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00cf5	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00cf8	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00cfb	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  00d02	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00d08	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  00d0b	7f 6c		 jg	 SHORT $LN98@PIT_CheckT
  00d0d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00d12	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00d15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00d1b	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00d1e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00d21	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00d24	7c 53		 jl	 SHORT $LN98@PIT_CheckT

; 466  : 	{
; 467  : 		if (thing->flags & MF_SPRING)

  00d26	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00d29	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00d2c	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  00d32	74 45		 je	 SHORT $LN98@PIT_CheckT

; 468  : 		{
; 469  : 			if (tmthing->player && (tmthing->player->pflags & PF_NIGHTSMODE));

  00d34	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00d39	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00d40	74 1b		 je	 SHORT $LN97@PIT_CheckT
  00d42	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00d47	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00d4d	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00d53	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  00d59	74 02		 je	 SHORT $LN97@PIT_CheckT
  00d5b	eb 1c		 jmp	 SHORT $LN98@PIT_CheckT
$LN97@PIT_CheckT:

; 470  : 			else
; 471  : 			{
; 472  : 				P_DoSpring(thing, tmthing);

  00d5d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00d62	50		 push	 eax
  00d63	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00d66	51		 push	 ecx
  00d67	e8 00 00 00 00	 call	 _P_DoSpring
  00d6c	83 c4 08	 add	 esp, 8

; 473  : 				tmsprung = true;

  00d6f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _tmsprung, 1
$LN98@PIT_CheckT:

; 474  : 			}
; 475  : 		}
; 476  : 	}
; 477  : 
; 478  : 	// Damage other players when invincible
; 479  : 	if (tmthing->player && thing->player
; 480  : 	// Make sure they aren't able to damage you ANYWHERE along the Z axis, you have to be TOUCHING the person.
; 481  : 		&& !(thing->z + thing->height < tmthing->z || thing->z > tmthing->z + tmthing->height))

  00d79	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00d7e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00d85	0f 84 63 02 00
	00		 je	 $LN113@PIT_CheckT
  00d8b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00d8e	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00d95	0f 84 53 02 00
	00		 je	 $LN113@PIT_CheckT
  00d9b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00d9e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00da1	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00da4	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00da7	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00dac	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00daf	0f 8c 39 02 00
	00		 jl	 $LN113@PIT_CheckT
  00db5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00dba	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00dbd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00dc3	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00dc6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00dc9	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  00dcc	0f 8f 1c 02 00
	00		 jg	 $LN113@PIT_CheckT

; 482  : 	{
; 483  : 		if ((gametype == GT_MATCH && (!cv_matchtype.value))
; 484  : 			|| ((gametype == GT_CTF || (gametype == GT_MATCH && cv_matchtype.value)) && tmthing->player->ctfteam != thing->player->ctfteam)
; 485  : 			|| (gametype == GT_RACE))

  00dd2	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00dd9	83 f8 01	 cmp	 eax, 1
  00ddc	75 09		 jne	 SHORT $LN102@PIT_CheckT
  00dde	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  00de5	74 53		 je	 SHORT $LN101@PIT_CheckT
$LN102@PIT_CheckT:
  00de7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00dee	83 f8 04	 cmp	 eax, 4
  00df1	74 15		 je	 SHORT $LN104@PIT_CheckT
  00df3	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00dfa	83 f8 01	 cmp	 eax, 1
  00dfd	75 2b		 jne	 SHORT $LN103@PIT_CheckT
  00dff	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  00e06	74 22		 je	 SHORT $LN103@PIT_CheckT
$LN104@PIT_CheckT:
  00e08	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00e0d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00e13	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00e16	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00e1c	8b 89 60 01 00
	00		 mov	 ecx, DWORD PTR [ecx+352]
  00e22	3b 88 60 01 00
	00		 cmp	 ecx, DWORD PTR [eax+352]
  00e28	75 10		 jne	 SHORT $LN101@PIT_CheckT
$LN103@PIT_CheckT:
  00e2a	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00e31	83 f8 02	 cmp	 eax, 2
  00e34	0f 85 cc 00 00
	00		 jne	 $LN108@PIT_CheckT
$LN101@PIT_CheckT:

; 486  : 		{
; 487  : 			if ((tmthing->player->powers[pw_invulnerability] || tmthing->player->powers[pw_super])
; 488  : 				&& !thing->player->powers[pw_super])

  00e3a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00e3f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00e45	ba 04 00 00 00	 mov	 edx, 4
  00e4a	6b c2 00	 imul	 eax, edx, 0
  00e4d	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00e52	75 1a		 jne	 SHORT $LN107@PIT_CheckT
  00e54	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00e59	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00e5f	ba 04 00 00 00	 mov	 edx, 4
  00e64	6b c2 0f	 imul	 eax, edx, 15
  00e67	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00e6c	74 35		 je	 SHORT $LN105@PIT_CheckT
$LN107@PIT_CheckT:
  00e6e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00e71	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00e77	ba 04 00 00 00	 mov	 edx, 4
  00e7c	6b c2 0f	 imul	 eax, edx, 15
  00e7f	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00e84	75 1d		 jne	 SHORT $LN105@PIT_CheckT

; 489  : 				P_DamageMobj(thing, tmthing, tmthing, 1);

  00e86	6a 01		 push	 1
  00e88	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00e8d	50		 push	 eax
  00e8e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00e94	51		 push	 ecx
  00e95	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00e98	52		 push	 edx
  00e99	e8 00 00 00 00	 call	 _P_DamageMobj
  00e9e	83 c4 10	 add	 esp, 16			; 00000010H
  00ea1	eb 63		 jmp	 SHORT $LN108@PIT_CheckT
$LN105@PIT_CheckT:

; 490  : 			else if ((thing->player->powers[pw_invulnerability] || thing->player->powers[pw_super])
; 491  : 				&& !tmthing->player->powers[pw_super])

  00ea3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ea6	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00eac	ba 04 00 00 00	 mov	 edx, 4
  00eb1	6b c2 00	 imul	 eax, edx, 0
  00eb4	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00eb9	75 18		 jne	 SHORT $LN109@PIT_CheckT
  00ebb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ebe	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00ec4	ba 04 00 00 00	 mov	 edx, 4
  00ec9	6b c2 0f	 imul	 eax, edx, 15
  00ecc	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00ed1	74 33		 je	 SHORT $LN108@PIT_CheckT
$LN109@PIT_CheckT:
  00ed3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00ed8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00ede	ba 04 00 00 00	 mov	 edx, 4
  00ee3	6b c2 0f	 imul	 eax, edx, 15
  00ee6	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00eeb	75 19		 jne	 SHORT $LN108@PIT_CheckT

; 492  : 				P_DamageMobj(tmthing, thing, thing, 1);

  00eed	6a 01		 push	 1
  00eef	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00ef2	50		 push	 eax
  00ef3	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00ef6	51		 push	 ecx
  00ef7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00efd	52		 push	 edx
  00efe	e8 00 00 00 00	 call	 _P_DamageMobj
  00f03	83 c4 10	 add	 esp, 16			; 00000010H
$LN108@PIT_CheckT:

; 493  : 		}
; 494  : 
; 495  : 		// If players are using touch tag, seekers damage hiders.
; 496  : 		if (gametype == GT_TAG && cv_touchtag.value &&

  00f06	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00f0d	83 f8 03	 cmp	 eax, 3
  00f10	0f 85 d8 00 00
	00		 jne	 $LN113@PIT_CheckT
  00f16	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_touchtag+20, 0
  00f1d	0f 84 cb 00 00
	00		 je	 $LN113@PIT_CheckT
  00f23	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00f26	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00f2c	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00f32	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00f38	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00f3d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00f43	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00f49	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00f4e	3b d0		 cmp	 edx, eax
  00f50	0f 84 98 00 00
	00		 je	 $LN113@PIT_CheckT

; 497  : 			((thing->player->pflags & PF_TAGIT) != (tmthing->player->pflags & PF_TAGIT)))
; 498  : 		{
; 499  : 			if ((tmthing->player->pflags & PF_TAGIT) && !(thing->player->pflags & PF_TAGIT))

  00f56	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00f5b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00f61	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00f67	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00f6d	74 34		 je	 SHORT $LN111@PIT_CheckT
  00f6f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00f72	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00f78	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00f7e	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00f84	75 1d		 jne	 SHORT $LN111@PIT_CheckT

; 500  : 				P_DamageMobj(thing, tmthing, tmthing, 1);

  00f86	6a 01		 push	 1
  00f88	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00f8d	50		 push	 eax
  00f8e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  00f94	51		 push	 ecx
  00f95	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00f98	52		 push	 edx
  00f99	e8 00 00 00 00	 call	 _P_DamageMobj
  00f9e	83 c4 10	 add	 esp, 16			; 00000010H
  00fa1	eb 4b		 jmp	 SHORT $LN113@PIT_CheckT
$LN111@PIT_CheckT:

; 501  : 			else if ((thing->player->pflags & PF_TAGIT) && !(tmthing->player->pflags & PF_TAGIT))

  00fa3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00fa6	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00fac	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00fb2	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00fb8	74 34		 je	 SHORT $LN113@PIT_CheckT
  00fba	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00fbf	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00fc5	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00fcb	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00fd1	75 1b		 jne	 SHORT $LN113@PIT_CheckT

; 502  : 				P_DamageMobj(tmthing, thing, tmthing, 1);

  00fd3	6a 01		 push	 1
  00fd5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00fda	50		 push	 eax
  00fdb	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00fde	51		 push	 ecx
  00fdf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  00fe5	52		 push	 edx
  00fe6	e8 00 00 00 00	 call	 _P_DamageMobj
  00feb	83 c4 10	 add	 esp, 16			; 00000010H
$LN113@PIT_CheckT:

; 503  : 		}
; 504  : 	}
; 505  : 
; 506  : 	// Force solid players in hide and seek to avoid corner stacking.
; 507  : 	if (cv_tailspickup.value && !(gametype == GT_TAG && cv_tagtype.value))

  00fee	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_tailspickup+20, 0
  00ff5	0f 84 e4 04 00
	00		 je	 $LN114@PIT_CheckT
  00ffb	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  01002	83 f8 03	 cmp	 eax, 3
  01005	75 0d		 jne	 SHORT $LN116@PIT_CheckT
  01007	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_tagtype+20, 0
  0100e	0f 85 cb 04 00
	00		 jne	 $LN114@PIT_CheckT
$LN116@PIT_CheckT:

; 508  : 	{
; 509  : 		if (tmthing->player && thing->player)

  01014	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01019	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01020	0f 84 b7 04 00
	00		 je	 $LN117@PIT_CheckT
  01026	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01029	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01030	0f 84 a7 04 00
	00		 je	 $LN117@PIT_CheckT

; 510  : 		{
; 511  : 			if ((tmthing->player->pflags & PF_CARRIED) && tmthing->tracer == thing)

  01036	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0103b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01041	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01047	81 e2 00 00 02
	00		 and	 edx, 131072		; 00020000H
  0104d	74 1f		 je	 SHORT $LN118@PIT_CheckT
  0104f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01054	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0105a	3b 4d 08	 cmp	 ecx, DWORD PTR _thing$[ebp]
  0105d	75 0f		 jne	 SHORT $LN118@PIT_CheckT

; 512  : 				return true;

  0105f	b8 01 00 00 00	 mov	 eax, 1
  01064	e9 b9 11 00 00	 jmp	 $LN1@PIT_CheckT
  01069	e9 65 04 00 00	 jmp	 $LN123@PIT_CheckT
$LN118@PIT_CheckT:

; 513  : 			else if ((thing->player->pflags & PF_CARRIED) && thing->tracer == tmthing)

  0106e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01071	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01077	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0107d	81 e2 00 00 02
	00		 and	 edx, 131072		; 00020000H
  01083	74 20		 je	 SHORT $LN120@PIT_CheckT
  01085	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01088	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0108e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmthing
  01094	75 0f		 jne	 SHORT $LN120@PIT_CheckT

; 514  : 				return true;

  01096	b8 01 00 00 00	 mov	 eax, 1
  0109b	e9 82 11 00 00	 jmp	 $LN1@PIT_CheckT
  010a0	e9 2e 04 00 00	 jmp	 $LN123@PIT_CheckT
$LN120@PIT_CheckT:

; 515  : 			else if (tmthing->player->powers[pw_tailsfly]
; 516  : 					|| (tmthing->player->charability == CA_FLY && (tmthing->state == &states[S_PLAY_SPC1] || tmthing->state == &states[S_PLAY_SPC2] || tmthing->state == &states[S_PLAY_SPC3] || tmthing->state == &states[S_PLAY_SPC4])))

  010a5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  010aa	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  010b0	ba 04 00 00 00	 mov	 edx, 4
  010b5	6b c2 05	 imul	 eax, edx, 5
  010b8	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  010bd	0f 85 80 00 00
	00		 jne	 $LN125@PIT_CheckT
  010c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  010c8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  010ce	83 b9 d8 00 00
	00 01		 cmp	 DWORD PTR [ecx+216], 1
  010d5	0f 85 d4 03 00
	00		 jne	 $LN122@PIT_CheckT
  010db	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  010e0	6b c8 17	 imul	 ecx, eax, 23
  010e3	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  010e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  010ef	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  010f2	74 4f		 je	 SHORT $LN125@PIT_CheckT
  010f4	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  010f9	6b c8 18	 imul	 ecx, eax, 24
  010fc	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01102	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01108	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  0110b	74 36		 je	 SHORT $LN125@PIT_CheckT
  0110d	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01112	6b c8 19	 imul	 ecx, eax, 25
  01115	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  0111b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01121	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01124	74 1d		 je	 SHORT $LN125@PIT_CheckT
  01126	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  0112b	6b c8 1a	 imul	 ecx, eax, 26
  0112e	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01134	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0113a	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  0113d	0f 85 6c 03 00
	00		 jne	 $LN122@PIT_CheckT
$LN125@PIT_CheckT:

; 517  : 			{
; 518  : 				if (thing->player->pflags & PF_NIGHTSMODE)

  01143	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01146	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0114c	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01152	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  01158	74 0a		 je	 SHORT $LN126@PIT_CheckT

; 519  : 					return true;

  0115a	b8 01 00 00 00	 mov	 eax, 1
  0115f	e9 be 10 00 00	 jmp	 $LN1@PIT_CheckT
$LN126@PIT_CheckT:

; 520  : 
; 521  : 				if ((thing->eflags & MFE_VERTICALFLIP) && !(tmthing->eflags & MFE_VERTICALFLIP))

  01164	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01167	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0116d	83 e1 20	 and	 ecx, 32			; 00000020H
  01170	74 1a		 je	 SHORT $LN127@PIT_CheckT
  01172	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01177	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0117d	83 e1 20	 and	 ecx, 32			; 00000020H
  01180	75 0a		 jne	 SHORT $LN127@PIT_CheckT

; 522  : 					return true;

  01182	b8 01 00 00 00	 mov	 eax, 1
  01187	e9 96 10 00 00	 jmp	 $LN1@PIT_CheckT
$LN127@PIT_CheckT:

; 523  : 
; 524  : 				if (!(thing->eflags & MFE_VERTICALFLIP) && (tmthing->eflags & MFE_VERTICALFLIP))

  0118c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0118f	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01195	83 e1 20	 and	 ecx, 32			; 00000020H
  01198	75 1a		 jne	 SHORT $LN128@PIT_CheckT
  0119a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0119f	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  011a5	83 e1 20	 and	 ecx, 32			; 00000020H
  011a8	74 0a		 je	 SHORT $LN128@PIT_CheckT

; 525  : 					return true;

  011aa	b8 01 00 00 00	 mov	 eax, 1
  011af	e9 6e 10 00 00	 jmp	 $LN1@PIT_CheckT
$LN128@PIT_CheckT:

; 526  : 
; 527  : 				if ((!(tmthing->eflags & MFE_VERTICALFLIP) && (tmthing->z <= thing->z + thing->height + FRACUNIT)
; 528  : 					&& tmthing->z > thing->z + thing->height*2/3
; 529  : 					&& thing->momz <= 0)
; 530  : 					|| ((tmthing->eflags & MFE_VERTICALFLIP) && (tmthing->z + tmthing->height >= thing->z - FRACUNIT)

  011b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  011b9	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  011bf	83 e1 20	 and	 ecx, 32			; 00000020H
  011c2	75 48		 jne	 SHORT $LN132@PIT_CheckT
  011c4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  011c7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  011ca	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  011cd	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  011d0	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  011d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  011dd	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  011e0	7f 2a		 jg	 SHORT $LN132@PIT_CheckT
  011e2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  011e5	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  011e8	d1 e0		 shl	 eax, 1
  011ea	99		 cdq
  011eb	b9 03 00 00 00	 mov	 ecx, 3
  011f0	f7 f9		 idiv	 ecx
  011f2	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  011f5	03 42 18	 add	 eax, DWORD PTR [edx+24]
  011f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  011fe	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  01201	7e 09		 jle	 SHORT $LN132@PIT_CheckT
  01203	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01206	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  0120a	7e 7d		 jle	 SHORT $LN131@PIT_CheckT
$LN132@PIT_CheckT:
  0120c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01211	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01217	83 e1 20	 and	 ecx, 32			; 00000020H
  0121a	0f 84 69 02 00
	00		 je	 $LN129@PIT_CheckT
  01220	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01225	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01228	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0122e	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01231	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01234	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  01237	81 ea 00 00 01
	00		 sub	 edx, 65536		; 00010000H
  0123d	3b ca		 cmp	 ecx, edx
  0123f	0f 8c 44 02 00
	00		 jl	 $LN129@PIT_CheckT
  01245	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0124a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0124d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01253	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01256	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01259	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  0125c	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0125f	03 72 44	 add	 esi, DWORD PTR [edx+68]
  01262	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01265	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  01268	d1 e0		 shl	 eax, 1
  0126a	99		 cdq
  0126b	bf 03 00 00 00	 mov	 edi, 3
  01270	f7 ff		 idiv	 edi
  01272	2b f0		 sub	 esi, eax
  01274	3b ce		 cmp	 ecx, esi
  01276	0f 8d 0d 02 00
	00		 jge	 $LN129@PIT_CheckT
  0127c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0127f	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  01283	0f 8c 00 02 00
	00		 jl	 $LN129@PIT_CheckT
$LN131@PIT_CheckT:

; 531  : 					&& tmthing->z + tmthing->height < thing->z + thing->height - thing->height*2/3
; 532  : 					&& thing->momz >= 0))
; 533  : 				{
; 534  : 					if (gametype == GT_RACE
; 535  : 						|| (netgame && (tmthing->player->spectator || thing->player->spectator))
; 536  : 						|| (gametype == GT_TAG && (!(tmthing->player->pflags & PF_TAGIT) != !(thing->player->pflags & PF_TAGIT)))
; 537  : 						|| (gametype == GT_MATCH && !cv_matchtype.value)
; 538  : 						|| ((gametype == GT_CTF || (gametype == GT_MATCH && cv_matchtype.value)) && tmthing->player->ctfteam != thing->player->ctfteam))

  01289	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  01290	83 f8 02	 cmp	 eax, 2
  01293	0f 84 f7 00 00
	00		 je	 $LN135@PIT_CheckT
  01299	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  012a0	74 32		 je	 SHORT $LN136@PIT_CheckT
  012a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  012a7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  012ad	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  012b4	85 d2		 test	 edx, edx
  012b6	0f 85 d4 00 00
	00		 jne	 $LN135@PIT_CheckT
  012bc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  012bf	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  012c5	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  012cc	85 d2		 test	 edx, edx
  012ce	0f 85 bc 00 00
	00		 jne	 $LN135@PIT_CheckT
$LN136@PIT_CheckT:
  012d4	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  012db	83 f8 03	 cmp	 eax, 3
  012de	75 58		 jne	 SHORT $LN137@PIT_CheckT
  012e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  012e5	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  012eb	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  012f1	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  012f7	75 09		 jne	 SHORT $LN221@PIT_CheckT
  012f9	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv819[ebp], 1
  01300	eb 07		 jmp	 SHORT $LN222@PIT_CheckT
$LN221@PIT_CheckT:
  01302	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv819[ebp], 0
$LN222@PIT_CheckT:
  01309	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0130c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01312	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01318	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  0131e	75 09		 jne	 SHORT $LN223@PIT_CheckT
  01320	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv824[ebp], 1
  01327	eb 07		 jmp	 SHORT $LN224@PIT_CheckT
$LN223@PIT_CheckT:
  01329	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv824[ebp], 0
$LN224@PIT_CheckT:
  01330	8b 45 b0	 mov	 eax, DWORD PTR tv819[ebp]
  01333	3b 45 ac	 cmp	 eax, DWORD PTR tv824[ebp]
  01336	75 58		 jne	 SHORT $LN135@PIT_CheckT
$LN137@PIT_CheckT:
  01338	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  0133f	83 f8 01	 cmp	 eax, 1
  01342	75 09		 jne	 SHORT $LN138@PIT_CheckT
  01344	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  0134b	74 43		 je	 SHORT $LN135@PIT_CheckT
$LN138@PIT_CheckT:
  0134d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  01354	83 f8 04	 cmp	 eax, 4
  01357	74 15		 je	 SHORT $LN139@PIT_CheckT
  01359	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  01360	83 f8 01	 cmp	 eax, 1
  01363	75 54		 jne	 SHORT $LN133@PIT_CheckT
  01365	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  0136c	74 4b		 je	 SHORT $LN133@PIT_CheckT
$LN139@PIT_CheckT:
  0136e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01373	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01379	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0137c	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  01382	8b 89 60 01 00
	00		 mov	 ecx, DWORD PTR [ecx+352]
  01388	3b 88 60 01 00
	00		 cmp	 ecx, DWORD PTR [eax+352]
  0138e	74 29		 je	 SHORT $LN133@PIT_CheckT
$LN135@PIT_CheckT:

; 539  : 						thing->player->pflags &= ~PF_CARRIED;

  01390	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01393	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01399	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0139f	81 e2 ff ff fd
	ff		 and	 edx, -131073		; fffdffffH
  013a5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  013a8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  013ae	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx
  013b4	e9 ce 00 00 00	 jmp	 $LN134@PIT_CheckT
$LN133@PIT_CheckT:

; 540  : 					else
; 541  : 					{
; 542  : 						P_ResetPlayer(thing->player);

  013b9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  013bc	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  013c2	51		 push	 ecx
  013c3	e8 00 00 00 00	 call	 _P_ResetPlayer
  013c8	83 c4 04	 add	 esp, 4

; 543  : 						P_ResetScore(thing->player);

  013cb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  013ce	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  013d4	51		 push	 ecx
  013d5	e8 00 00 00 00	 call	 _P_ResetScore
  013da	83 c4 04	 add	 esp, 4

; 544  : 						P_SetTarget(&thing->tracer, tmthing);

  013dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  013e2	50		 push	 eax
  013e3	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  013e6	81 c1 b0 00 00
	00		 add	 ecx, 176		; 000000b0H
  013ec	51		 push	 ecx
  013ed	e8 00 00 00 00	 call	 _P_SetTarget
  013f2	83 c4 08	 add	 esp, 8

; 545  : 						thing->player->pflags |= PF_CARRIED;

  013f5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  013f8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  013fe	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01404	81 ca 00 00 02
	00		 or	 edx, 131072		; 00020000H
  0140a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0140d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01413	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 546  : 						S_StartSound(thing->player, sfx_s3k_25);

  01419	68 8d 00 00 00	 push	 141			; 0000008dH
  0141e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01421	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01427	51		 push	 ecx
  01428	e8 00 00 00 00	 call	 _S_StartSound
  0142d	83 c4 08	 add	 esp, 8

; 547  : 						P_UnsetThingPosition(thing);

  01430	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01433	50		 push	 eax
  01434	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  01439	83 c4 04	 add	 esp, 4

; 548  : 						if (sector_list)

  0143c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sector_list, 0
  01443	74 18		 je	 SHORT $LN140@PIT_CheckT

; 549  : 						{
; 550  : 							P_DelSeclist(sector_list);

  01445	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  0144a	50		 push	 eax
  0144b	e8 00 00 00 00	 call	 _P_DelSeclist
  01450	83 c4 04	 add	 esp, 4

; 551  : 							sector_list = NULL;

  01453	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _sector_list, 0
$LN140@PIT_CheckT:

; 552  : 						}
; 553  : 						thing->x = tmthing->x;

  0145d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01460	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  01466	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  01469	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 554  : 						thing->y = tmthing->y;

  0146c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0146f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  01475	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01478	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 555  : 						P_SetThingPosition(thing);

  0147b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0147e	50		 push	 eax
  0147f	e8 00 00 00 00	 call	 _P_SetThingPosition
  01484	83 c4 04	 add	 esp, 4
$LN134@PIT_CheckT:

; 556  : 					}
; 557  : 				}

  01487	eb 24		 jmp	 SHORT $LN130@PIT_CheckT
$LN129@PIT_CheckT:

; 558  : 				else
; 559  : 					thing->player->pflags &= ~PF_CARRIED;

  01489	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0148c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01492	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01498	81 e2 ff ff fd
	ff		 and	 edx, -131073		; fffdffffH
  0149e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  014a1	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  014a7	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx
$LN130@PIT_CheckT:

; 560  : 			}

  014ad	eb 24		 jmp	 SHORT $LN123@PIT_CheckT
$LN122@PIT_CheckT:

; 561  : 			else
; 562  : 				thing->player->pflags &= ~PF_CARRIED;

  014af	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  014b2	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  014b8	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  014be	81 e2 ff ff fd
	ff		 and	 edx, -131073		; fffdffffH
  014c4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  014c7	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  014cd	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx
$LN123@PIT_CheckT:

; 563  : 
; 564  : 			return true;

  014d3	b8 01 00 00 00	 mov	 eax, 1
  014d8	e9 45 0d 00 00	 jmp	 $LN1@PIT_CheckT
$LN117@PIT_CheckT:

; 565  : 		}
; 566  : 	}

  014dd	eb 30		 jmp	 SHORT $LN141@PIT_CheckT
$LN114@PIT_CheckT:

; 567  : 	else if (thing->player)

  014df	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  014e2	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  014e9	74 24		 je	 SHORT $LN141@PIT_CheckT

; 568  : 		thing->player->pflags &= ~PF_CARRIED;

  014eb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  014ee	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  014f4	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  014fa	81 e2 ff ff fd
	ff		 and	 edx, -131073		; fffdffffH
  01500	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01503	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01509	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx
$LN141@PIT_CheckT:

; 569  : 
; 570  : 	if (thing->player)

  0150f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01512	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01519	0f 84 0d 06 00
	00		 je	 $LN4@PIT_CheckT

; 571  : 	{
; 572  : 		if (thing->eflags & MFE_VERTICALFLIP && tmthing->eflags & MFE_VERTICALFLIP)

  0151f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01522	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01528	83 e1 20	 and	 ecx, 32			; 00000020H
  0152b	0f 84 29 03 00
	00		 je	 $LN143@PIT_CheckT
  01531	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01536	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0153c	83 e1 20	 and	 ecx, 32			; 00000020H
  0153f	0f 84 15 03 00
	00		 je	 $LN143@PIT_CheckT

; 573  : 		{
; 574  : 			// Objects kill you if it falls from above.
; 575  : 			if (tmthing->z + tmthing->height + tmthing->momz >= thing->z
; 576  : 				&& tmthing->z + tmthing->height + tmthing->momz < thing->z + thing->height
; 577  : 				&& P_IsObjectOnGround(thing))

  01545	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0154a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0154d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01553	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01556	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0155b	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  0155e	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01561	3b 4a 18	 cmp	 ecx, DWORD PTR [edx+24]
  01564	0f 8c a2 00 00
	00		 jl	 $LN146@PIT_CheckT
  0156a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0156f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01572	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01578	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0157b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01580	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  01583	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01586	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01589	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0158c	03 42 44	 add	 eax, DWORD PTR [edx+68]
  0158f	3b c8		 cmp	 ecx, eax
  01591	7d 79		 jge	 SHORT $LN146@PIT_CheckT
  01593	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01596	50		 push	 eax
  01597	e8 00 00 00 00	 call	 _P_IsObjectOnGround
  0159c	83 c4 04	 add	 esp, 4
  0159f	85 c0		 test	 eax, eax
  015a1	74 69		 je	 SHORT $LN146@PIT_CheckT

; 578  : 			{
; 579  : 				if ((tmthing->flags & MF_MONITOR) || (tmthing->flags & MF_PUSHABLE))

  015a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  015a8	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  015ab	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  015b1	75 0d		 jne	 SHORT $LN147@PIT_CheckT
  015b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  015b8	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  015bb	83 e1 40	 and	 ecx, 64			; 00000040H
  015be	74 4c		 je	 SHORT $LN146@PIT_CheckT
$LN147@PIT_CheckT:

; 580  : 				{
; 581  : 					if (thing != tmthing->target)

  015c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  015c5	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  015c8	3b 88 98 00 00
	00		 cmp	 ecx, DWORD PTR [eax+152]
  015ce	74 24		 je	 SHORT $LN148@PIT_CheckT

; 582  : 						P_DamageMobj(thing, tmthing, tmthing->target, 10000);

  015d0	68 10 27 00 00	 push	 10000			; 00002710H
  015d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  015da	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  015e0	51		 push	 ecx
  015e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  015e7	52		 push	 edx
  015e8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  015eb	50		 push	 eax
  015ec	e8 00 00 00 00	 call	 _P_DamageMobj
  015f1	83 c4 10	 add	 esp, 16			; 00000010H
$LN148@PIT_CheckT:

; 583  : 
; 584  : 					tmthing->momz = -tmthing->momz/2; // Bounce, just for fun!

  015f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  015f9	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  015fc	f7 d8		 neg	 eax
  015fe	99		 cdq
  015ff	2b c2		 sub	 eax, edx
  01601	d1 f8		 sar	 eax, 1
  01603	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  01609	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN146@PIT_CheckT:

; 585  : 					// The tmthing->target allows the pusher of the object
; 586  : 					// to get the point if he topples it on an opponent.
; 587  : 				}
; 588  : 			}
; 589  : 
; 590  : 			if (thing->z + thing->height <= tmthing->z + tmthing->height && !(thing->state == &states[thing->info->painstate])) // Stuff where da player don't gotta move

  0160c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0160f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01612	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01615	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01618	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0161d	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  01620	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01625	03 50 44	 add	 edx, DWORD PTR [eax+68]
  01628	3b ca		 cmp	 ecx, edx
  0162a	0f 8f 25 02 00
	00		 jg	 $LN2@PIT_CheckT
  01630	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01633	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01639	6b 51 1c 1c	 imul	 edx, DWORD PTR [ecx+28], 28
  0163d	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  01643	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01646	39 50 5c	 cmp	 DWORD PTR [eax+92], edx
  01649	0f 84 06 02 00
	00		 je	 $LN2@PIT_CheckT

; 591  : 			{
; 592  : 				switch (tmthing->type)

  0164f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01654	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  01657	89 4d b0	 mov	 DWORD PTR tv942[ebp], ecx
  0165a	83 7d b0 41	 cmp	 DWORD PTR tv942[ebp], 65 ; 00000041H
  0165e	74 0f		 je	 SHORT $LN150@PIT_CheckT
  01660	83 7d b0 44	 cmp	 DWORD PTR tv942[ebp], 68 ; 00000044H
  01664	0f 84 42 01 00
	00		 je	 $LN155@PIT_CheckT
  0166a	e9 e6 01 00 00	 jmp	 $LN158@PIT_CheckT
$LN150@PIT_CheckT:

; 593  : 				{
; 594  : 					case MT_FAN: // fan
; 595  : 						if (thing->z + thing->height >= tmthing->z + tmthing->height - (tmthing->health << FRACBITS) && thing->momz > -tmthing->info->speed && !(thing->player->climbing || (thing->player->pflags & PF_GLIDING)))

  0166f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01672	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01675	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01678	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0167b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01680	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  01683	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01688	03 50 44	 add	 edx, DWORD PTR [eax+68]
  0168b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01690	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [eax+140]
  01696	c1 e0 10	 shl	 eax, 16			; 00000010H
  01699	2b d0		 sub	 edx, eax
  0169b	3b ca		 cmp	 ecx, edx
  0169d	0f 8c 04 01 00
	00		 jl	 $LN154@PIT_CheckT
  016a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  016a8	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  016ae	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  016b1	f7 da		 neg	 edx
  016b3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  016b6	39 50 50	 cmp	 DWORD PTR [eax+80], edx
  016b9	0f 8e e8 00 00
	00		 jle	 $LN154@PIT_CheckT
  016bf	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  016c2	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  016c8	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  016cf	0f 85 d2 00 00
	00		 jne	 $LN154@PIT_CheckT
  016d5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  016d8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  016de	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  016e4	81 e2 00 00 01
	00		 and	 edx, 65536		; 00010000H
  016ea	0f 85 b7 00 00
	00		 jne	 $LN154@PIT_CheckT

; 596  : 						{
; 597  : 							thing->momz -= tmthing->info->speed/4;

  016f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  016f5	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  016fb	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  016fe	99		 cdq
  016ff	83 e2 03	 and	 edx, 3
  01702	03 c2		 add	 eax, edx
  01704	c1 f8 02	 sar	 eax, 2
  01707	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0170a	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  0170d	2b c8		 sub	 ecx, eax
  0170f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01712	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 598  : 
; 599  : 							if (thing->momz < -tmthing->info->speed)

  01715	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0171a	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01720	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  01723	f7 da		 neg	 edx
  01725	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01728	39 50 50	 cmp	 DWORD PTR [eax+80], edx
  0172b	7d 16		 jge	 SHORT $LN152@PIT_CheckT

; 600  : 								thing->momz = -tmthing->info->speed;

  0172d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01732	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01738	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0173b	f7 da		 neg	 edx
  0173d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01740	89 50 50	 mov	 DWORD PTR [eax+80], edx
$LN152@PIT_CheckT:

; 601  : 
; 602  : 							if (!thing->player->powers[pw_tailsfly])

  01743	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01746	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0174c	ba 04 00 00 00	 mov	 edx, 4
  01751	6b c2 05	 imul	 eax, edx, 5
  01754	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  01759	75 4c		 jne	 SHORT $LN154@PIT_CheckT

; 603  : 							{
; 604  : 								P_ResetPlayer(thing->player);

  0175b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0175e	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01764	51		 push	 ecx
  01765	e8 00 00 00 00	 call	 _P_ResetPlayer
  0176a	83 c4 04	 add	 esp, 4

; 605  : 								if (!(thing->state == &states[S_PLAY_FALL1] || thing->state == &states[S_PLAY_FALL2]))

  0176d	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01772	6b c8 27	 imul	 ecx, eax, 39
  01775	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  0177b	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0177e	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01781	74 24		 je	 SHORT $LN154@PIT_CheckT
  01783	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01788	6b c8 28	 imul	 ecx, eax, 40
  0178b	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01791	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01794	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01797	74 0e		 je	 SHORT $LN154@PIT_CheckT

; 606  : 									P_SetPlayerMobjState(thing, S_PLAY_FALL1);

  01799	6a 27		 push	 39			; 00000027H
  0179b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0179e	50		 push	 eax
  0179f	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  017a4	83 c4 08	 add	 esp, 8
$LN154@PIT_CheckT:

; 607  : 							}
; 608  : 						}
; 609  : 						break;

  017a7	e9 a9 00 00 00	 jmp	 $LN2@PIT_CheckT
$LN155@PIT_CheckT:

; 610  : 					case MT_STEAM: // Steam
; 611  : 						if (tmthing->state == &states[S_STEAM1] && thing->z + thing->height >= tmthing->z + tmthing->height - 16*FRACUNIT) // Only when it bursts

  017ac	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  017b1	69 c8 57 02 00
	00		 imul	 ecx, eax, 599
  017b7	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  017bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  017c3	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  017c6	0f 85 89 00 00
	00		 jne	 $LN157@PIT_CheckT
  017cc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  017cf	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  017d2	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  017d5	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  017d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  017dd	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  017e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  017e5	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  017e8	8d 94 02 00 00
	f0 ff		 lea	 edx, DWORD PTR [edx+eax-1048576]
  017ef	3b ca		 cmp	 ecx, edx
  017f1	7c 62		 jl	 SHORT $LN157@PIT_CheckT

; 612  : 						{
; 613  : 							thing->momz = -tmthing->info->speed;

  017f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  017f8	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  017fe	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  01801	f7 da		 neg	 edx
  01803	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01806	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 614  : 							P_ResetPlayer(thing->player);

  01809	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0180c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01812	51		 push	 ecx
  01813	e8 00 00 00 00	 call	 _P_ResetPlayer
  01818	83 c4 04	 add	 esp, 4

; 615  : 							if (!(thing->state == &states[S_PLAY_FALL1] || thing->state == &states[S_PLAY_FALL2]))

  0181b	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01820	6b c8 27	 imul	 ecx, eax, 39
  01823	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01829	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0182c	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  0182f	74 24		 je	 SHORT $LN157@PIT_CheckT
  01831	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01836	6b c8 28	 imul	 ecx, eax, 40
  01839	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  0183f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01842	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01845	74 0e		 je	 SHORT $LN157@PIT_CheckT

; 616  : 								P_SetPlayerMobjState(thing, S_PLAY_FALL1);

  01847	6a 27		 push	 39			; 00000027H
  01849	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0184c	50		 push	 eax
  0184d	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  01852	83 c4 08	 add	 esp, 8
$LN157@PIT_CheckT:
$LN158@PIT_CheckT:
$LN2@PIT_CheckT:

; 617  : 						}
; 618  : 						break;
; 619  : 					default:
; 620  : 						break;
; 621  : 				}
; 622  : 			}
; 623  : 		}

  01855	e9 d2 02 00 00	 jmp	 $LN4@PIT_CheckT
$LN143@PIT_CheckT:

; 624  : 		else
; 625  : 		{
; 626  : 			// Objects kill you if it falls from above.
; 627  : 			if (tmthing->z + tmthing->momz <= thing->z + thing->height
; 628  : 				&& tmthing->z + tmthing->momz > thing->z
; 629  : 				&& P_IsObjectOnGround(thing)
; 630  : 				&& (tmthing->flags & MF_SOLID))

  0185a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0185f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01862	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01868	03 4a 50	 add	 ecx, DWORD PTR [edx+80]
  0186b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0186e	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  01871	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01874	03 50 44	 add	 edx, DWORD PTR [eax+68]
  01877	3b ca		 cmp	 ecx, edx
  01879	0f 8f a3 00 00
	00		 jg	 $LN160@PIT_CheckT
  0187f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01884	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01887	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0188d	03 4a 50	 add	 ecx, DWORD PTR [edx+80]
  01890	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01893	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  01896	0f 8e 86 00 00
	00		 jle	 $LN160@PIT_CheckT
  0189c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0189f	50		 push	 eax
  018a0	e8 00 00 00 00	 call	 _P_IsObjectOnGround
  018a5	83 c4 04	 add	 esp, 4
  018a8	85 c0		 test	 eax, eax
  018aa	74 76		 je	 SHORT $LN160@PIT_CheckT
  018ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  018b1	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  018b4	83 e1 02	 and	 ecx, 2
  018b7	74 69		 je	 SHORT $LN160@PIT_CheckT

; 631  : 			{
; 632  : 				if ((tmthing->flags & MF_MONITOR) || (tmthing->flags & MF_PUSHABLE))

  018b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  018be	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  018c1	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  018c7	75 0d		 jne	 SHORT $LN161@PIT_CheckT
  018c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  018ce	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  018d1	83 e1 40	 and	 ecx, 64			; 00000040H
  018d4	74 4c		 je	 SHORT $LN160@PIT_CheckT
$LN161@PIT_CheckT:

; 633  : 				{
; 634  : 					if (thing != tmthing->target)

  018d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  018db	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  018de	3b 88 98 00 00
	00		 cmp	 ecx, DWORD PTR [eax+152]
  018e4	74 24		 je	 SHORT $LN162@PIT_CheckT

; 635  : 						P_DamageMobj(thing, tmthing, tmthing->target, 10000);

  018e6	68 10 27 00 00	 push	 10000			; 00002710H
  018eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  018f0	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  018f6	51		 push	 ecx
  018f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  018fd	52		 push	 edx
  018fe	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01901	50		 push	 eax
  01902	e8 00 00 00 00	 call	 _P_DamageMobj
  01907	83 c4 10	 add	 esp, 16			; 00000010H
$LN162@PIT_CheckT:

; 636  : 
; 637  : 					tmthing->momz = -tmthing->momz/2; // Bounce, just for fun!

  0190a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0190f	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  01912	f7 d8		 neg	 eax
  01914	99		 cdq
  01915	2b c2		 sub	 eax, edx
  01917	d1 f8		 sar	 eax, 1
  01919	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  0191f	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN160@PIT_CheckT:

; 638  : 					// The tmthing->target allows the pusher of the object
; 639  : 					// to get the point if he topples it on an opponent.
; 640  : 				}
; 641  : 			}
; 642  : 
; 643  : 			if (thing->z >= tmthing->z && !(thing->state == &states[thing->info->painstate])) // Stuff where da player don't gotta move

  01922	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01925	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  0192b	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0192e	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  01931	0f 8c f5 01 00
	00		 jl	 $LN4@PIT_CheckT
  01937	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0193a	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01940	6b 51 1c 1c	 imul	 edx, DWORD PTR [ecx+28], 28
  01944	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  0194a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0194d	39 50 5c	 cmp	 DWORD PTR [eax+92], edx
  01950	0f 84 d6 01 00
	00		 je	 $LN4@PIT_CheckT

; 644  : 			{
; 645  : 				switch (tmthing->type)

  01956	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0195b	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0195e	89 4d b0	 mov	 DWORD PTR tv1072[ebp], ecx
  01961	83 7d b0 41	 cmp	 DWORD PTR tv1072[ebp], 65 ; 00000041H
  01965	74 0f		 je	 SHORT $LN164@PIT_CheckT
  01967	83 7d b0 44	 cmp	 DWORD PTR tv1072[ebp], 68 ; 00000044H
  0196b	0f 84 29 01 00
	00		 je	 $LN169@PIT_CheckT
  01971	e9 b6 01 00 00	 jmp	 $LN172@PIT_CheckT
$LN164@PIT_CheckT:

; 646  : 				{
; 647  : 					case MT_FAN: // fan
; 648  : 						if (thing->z <= tmthing->z + (tmthing->health << FRACBITS) && thing->momz < tmthing->info->speed && !(thing->player->climbing || (thing->player->pflags & PF_GLIDING)))

  01976	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0197b	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  01981	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01984	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0198a	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  0198d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01990	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  01993	0f 8f fc 00 00
	00		 jg	 $LN168@PIT_CheckT
  01999	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0199e	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  019a4	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  019a7	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  019aa	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  019ad	0f 8d e2 00 00
	00		 jge	 $LN168@PIT_CheckT
  019b3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  019b6	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  019bc	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  019c3	0f 85 cc 00 00
	00		 jne	 $LN168@PIT_CheckT
  019c9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  019cc	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  019d2	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  019d8	81 e2 00 00 01
	00		 and	 edx, 65536		; 00010000H
  019de	0f 85 b1 00 00
	00		 jne	 $LN168@PIT_CheckT

; 649  : 						{
; 650  : 							thing->momz += tmthing->info->speed/4;

  019e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  019e9	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  019ef	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  019f2	99		 cdq
  019f3	83 e2 03	 and	 edx, 3
  019f6	03 c2		 add	 eax, edx
  019f8	c1 f8 02	 sar	 eax, 2
  019fb	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  019fe	03 42 50	 add	 eax, DWORD PTR [edx+80]
  01a01	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  01a04	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 651  : 
; 652  : 							if (thing->momz > tmthing->info->speed)

  01a07	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01a0c	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01a12	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01a15	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01a18	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  01a1b	7e 14		 jle	 SHORT $LN166@PIT_CheckT

; 653  : 								thing->momz = tmthing->info->speed;

  01a1d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01a22	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01a28	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01a2b	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  01a2e	89 42 50	 mov	 DWORD PTR [edx+80], eax
$LN166@PIT_CheckT:

; 654  : 
; 655  : 							if (!thing->player->powers[pw_tailsfly])

  01a31	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01a34	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01a3a	ba 04 00 00 00	 mov	 edx, 4
  01a3f	6b c2 05	 imul	 eax, edx, 5
  01a42	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  01a47	75 4c		 jne	 SHORT $LN168@PIT_CheckT

; 656  : 							{
; 657  : 								P_ResetPlayer(thing->player);

  01a49	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01a4c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01a52	51		 push	 ecx
  01a53	e8 00 00 00 00	 call	 _P_ResetPlayer
  01a58	83 c4 04	 add	 esp, 4

; 658  : 								if (!(thing->state == &states[S_PLAY_FALL1] || thing->state == &states[S_PLAY_FALL2]))

  01a5b	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01a60	6b c8 27	 imul	 ecx, eax, 39
  01a63	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01a69	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01a6c	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01a6f	74 24		 je	 SHORT $LN168@PIT_CheckT
  01a71	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01a76	6b c8 28	 imul	 ecx, eax, 40
  01a79	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01a7f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01a82	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01a85	74 0e		 je	 SHORT $LN168@PIT_CheckT

; 659  : 									P_SetPlayerMobjState(thing, S_PLAY_FALL1);

  01a87	6a 27		 push	 39			; 00000027H
  01a89	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01a8c	50		 push	 eax
  01a8d	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  01a92	83 c4 08	 add	 esp, 8
$LN168@PIT_CheckT:

; 660  : 							}
; 661  : 						}
; 662  : 						break;

  01a95	e9 92 00 00 00	 jmp	 $LN4@PIT_CheckT
$LN169@PIT_CheckT:

; 663  : 					case MT_STEAM: // Steam
; 664  : 						if (tmthing->state == &states[S_STEAM1] && thing->z <= tmthing->z + 16*FRACUNIT) // Only when it bursts

  01a9a	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01a9f	69 c8 57 02 00
	00		 imul	 ecx, eax, 599
  01aa5	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01aab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01ab1	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01ab4	75 76		 jne	 SHORT $LN171@PIT_CheckT
  01ab6	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01abb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01abe	81 c1 00 00 10
	00		 add	 ecx, 1048576		; 00100000H
  01ac4	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01ac7	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  01aca	7f 60		 jg	 SHORT $LN171@PIT_CheckT

; 665  : 						{
; 666  : 							thing->momz = tmthing->info->speed;

  01acc	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01ad1	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01ad7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01ada	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  01add	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 667  : 							P_ResetPlayer(thing->player);

  01ae0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01ae3	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01ae9	51		 push	 ecx
  01aea	e8 00 00 00 00	 call	 _P_ResetPlayer
  01aef	83 c4 04	 add	 esp, 4

; 668  : 							if (!(thing->state == &states[S_PLAY_FALL1] || thing->state == &states[S_PLAY_FALL2]))

  01af2	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01af7	6b c8 27	 imul	 ecx, eax, 39
  01afa	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01b00	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01b03	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01b06	74 24		 je	 SHORT $LN171@PIT_CheckT
  01b08	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01b0d	6b c8 28	 imul	 ecx, eax, 40
  01b10	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01b16	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01b19	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01b1c	74 0e		 je	 SHORT $LN171@PIT_CheckT

; 669  : 								P_SetPlayerMobjState(thing, S_PLAY_FALL1);

  01b1e	6a 27		 push	 39			; 00000027H
  01b20	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01b23	50		 push	 eax
  01b24	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  01b29	83 c4 08	 add	 esp, 8
$LN171@PIT_CheckT:
$LN172@PIT_CheckT:
$LN4@PIT_CheckT:

; 670  : 						}
; 671  : 						break;
; 672  : 					default:
; 673  : 						break;
; 674  : 				}
; 675  : 			}
; 676  : 		}
; 677  : 	}
; 678  : 
; 679  : 	if (tmthing->player) // Is the moving/interacting object the player?

  01b2c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01b31	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01b38	0f 84 d5 04 00
	00		 je	 $LN200@PIT_CheckT

; 680  : 	{
; 681  : 		if (tmthing->z >= thing->z && !(tmthing->state == &states[tmthing->info->painstate]))

  01b3e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01b43	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  01b46	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  01b49	3b 51 18	 cmp	 edx, DWORD PTR [ecx+24]
  01b4c	0f 8c 18 02 00
	00		 jl	 $LN6@PIT_CheckT
  01b52	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01b57	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01b5d	6b 51 1c 1c	 imul	 edx, DWORD PTR [ecx+28], 28
  01b61	81 c2 00 00 00
	00		 add	 edx, OFFSET _states
  01b67	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01b6c	39 50 5c	 cmp	 DWORD PTR [eax+92], edx
  01b6f	0f 84 f5 01 00
	00		 je	 $LN6@PIT_CheckT

; 682  : 		{
; 683  : 			switch (thing->type)

  01b75	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01b78	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  01b7b	89 4d b0	 mov	 DWORD PTR tv1157[ebp], ecx
  01b7e	83 7d b0 41	 cmp	 DWORD PTR tv1157[ebp], 65 ; 00000041H
  01b82	74 0f		 je	 SHORT $LN175@PIT_CheckT
  01b84	83 7d b0 44	 cmp	 DWORD PTR tv1157[ebp], 68 ; 00000044H
  01b88	0f 84 3d 01 00
	00		 je	 $LN180@PIT_CheckT
  01b8e	e9 d7 01 00 00	 jmp	 $LN183@PIT_CheckT
$LN175@PIT_CheckT:

; 684  : 			{
; 685  : 				case MT_FAN: // fan
; 686  : 					if (tmthing->z <= thing->z + (thing->health << FRACBITS) && tmthing->momz < thing->info->speed && !(tmthing->player->climbing || (tmthing->player->pflags & PF_GLIDING)))

  01b93	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01b96	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  01b9c	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01b9f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01ba2	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  01ba5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01baa	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  01bad	0f 8f 13 01 00
	00		 jg	 $LN179@PIT_CheckT
  01bb3	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01bb6	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01bbc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01bc2	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01bc5	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  01bc8	0f 8d f8 00 00
	00		 jge	 $LN179@PIT_CheckT
  01bce	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01bd3	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01bd9	83 b9 24 01 00
	00 00		 cmp	 DWORD PTR [ecx+292], 0
  01be0	0f 85 e0 00 00
	00		 jne	 $LN179@PIT_CheckT
  01be6	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01beb	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01bf1	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01bf7	81 e2 00 00 01
	00		 and	 edx, 65536		; 00010000H
  01bfd	0f 85 c3 00 00
	00		 jne	 $LN179@PIT_CheckT

; 687  : 					{
; 688  : 						tmthing->momz += thing->info->speed/4;

  01c03	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01c06	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01c0c	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  01c0f	99		 cdq
  01c10	83 e2 03	 and	 edx, 3
  01c13	03 c2		 add	 eax, edx
  01c15	c1 f8 02	 sar	 eax, 2
  01c18	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01c1e	03 42 50	 add	 eax, DWORD PTR [edx+80]
  01c21	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  01c27	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 689  : 
; 690  : 						if (tmthing->momz > thing->info->speed)

  01c2a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01c2d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01c33	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01c39	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01c3c	3b 41 3c	 cmp	 eax, DWORD PTR [ecx+60]
  01c3f	7e 15		 jle	 SHORT $LN177@PIT_CheckT

; 691  : 							tmthing->momz = thing->info->speed;

  01c41	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01c44	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01c4a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01c50	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  01c53	89 42 50	 mov	 DWORD PTR [edx+80], eax
$LN177@PIT_CheckT:

; 692  : 
; 693  : 						if (!tmthing->player->powers[pw_tailsfly])

  01c56	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01c5b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01c61	ba 04 00 00 00	 mov	 edx, 4
  01c66	6b c2 05	 imul	 eax, edx, 5
  01c69	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  01c6e	75 56		 jne	 SHORT $LN179@PIT_CheckT

; 694  : 						{
; 695  : 							P_ResetPlayer(tmthing->player);

  01c70	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01c75	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01c7b	51		 push	 ecx
  01c7c	e8 00 00 00 00	 call	 _P_ResetPlayer
  01c81	83 c4 04	 add	 esp, 4

; 696  : 							if (!(tmthing->state == &states[S_PLAY_FALL1] || tmthing->state == &states[S_PLAY_FALL2]))

  01c84	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01c89	6b c8 27	 imul	 ecx, eax, 39
  01c8c	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01c92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01c98	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01c9b	74 29		 je	 SHORT $LN179@PIT_CheckT
  01c9d	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01ca2	6b c8 28	 imul	 ecx, eax, 40
  01ca5	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01cab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01cb1	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01cb4	74 10		 je	 SHORT $LN179@PIT_CheckT

; 697  : 								P_SetPlayerMobjState(tmthing, S_PLAY_FALL1);

  01cb6	6a 27		 push	 39			; 00000027H
  01cb8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01cbd	50		 push	 eax
  01cbe	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  01cc3	83 c4 08	 add	 esp, 8
$LN179@PIT_CheckT:

; 698  : 						}
; 699  : 					}
; 700  : 					break;

  01cc6	e9 9f 00 00 00	 jmp	 $LN6@PIT_CheckT
$LN180@PIT_CheckT:

; 701  : 				case MT_STEAM: // Steam
; 702  : 					if (thing->state == &states[S_STEAM1] && tmthing->z <= thing->z + 16*FRACUNIT) // Only when it bursts

  01ccb	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01cd0	69 c8 57 02 00
	00		 imul	 ecx, eax, 599
  01cd6	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01cdc	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01cdf	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01ce2	0f 85 82 00 00
	00		 jne	 $LN182@PIT_CheckT
  01ce8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01ceb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01cee	81 c1 00 00 10
	00		 add	 ecx, 1048576		; 00100000H
  01cf4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01cfa	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  01cfd	7f 6b		 jg	 SHORT $LN182@PIT_CheckT

; 703  : 					{
; 704  : 						tmthing->momz = thing->info->speed;

  01cff	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01d02	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  01d08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01d0e	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  01d11	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 705  : 						P_ResetPlayer(tmthing->player);

  01d14	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01d19	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01d1f	51		 push	 ecx
  01d20	e8 00 00 00 00	 call	 _P_ResetPlayer
  01d25	83 c4 04	 add	 esp, 4

; 706  : 						if (!(tmthing->state == &states[S_PLAY_FALL1] || tmthing->state == &states[S_PLAY_FALL2]))

  01d28	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01d2d	6b c8 27	 imul	 ecx, eax, 39
  01d30	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01d36	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01d3c	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01d3f	74 29		 je	 SHORT $LN182@PIT_CheckT
  01d41	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  01d46	6b c8 28	 imul	 ecx, eax, 40
  01d49	81 c1 00 00 00
	00		 add	 ecx, OFFSET _states
  01d4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01d55	39 4a 5c	 cmp	 DWORD PTR [edx+92], ecx
  01d58	74 10		 je	 SHORT $LN182@PIT_CheckT

; 707  : 							P_SetPlayerMobjState(tmthing, S_PLAY_FALL1);

  01d5a	6a 27		 push	 39			; 00000027H
  01d5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01d61	50		 push	 eax
  01d62	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  01d67	83 c4 08	 add	 esp, 8
$LN182@PIT_CheckT:
$LN183@PIT_CheckT:
$LN6@PIT_CheckT:

; 708  : 					}
; 709  : 					break;
; 710  : 				default:
; 711  : 					break;
; 712  : 			}
; 713  : 		}
; 714  : 
; 715  : 		// Are you touching the side of the object you're interacting with?
; 716  : 		if ((thing->z <= tmthing->z + tmthing->height
; 717  : 			&& thing->z + thing->height >= tmthing->z)
; 718  : 			|| ((!(tmthing->eflags & MFE_VERTICALFLIP) && tmthing->z == thing->z + thing->height + FRACUNIT)

  01d6a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01d6f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01d72	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01d78	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01d7b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01d7e	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  01d81	7f 16		 jg	 SHORT $LN186@PIT_CheckT
  01d83	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01d86	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01d89	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01d8c	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01d8f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01d94	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  01d97	7d 67		 jge	 SHORT $LN187@PIT_CheckT
$LN186@PIT_CheckT:
  01d99	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01d9e	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01da4	83 e1 20	 and	 ecx, 32			; 00000020H
  01da7	75 1e		 jne	 SHORT $LN188@PIT_CheckT
  01da9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01dac	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01daf	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01db2	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  01db5	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  01dbc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01dc2	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  01dc5	74 39		 je	 SHORT $LN187@PIT_CheckT
$LN188@PIT_CheckT:
  01dc7	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01dcc	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01dd2	83 e1 20	 and	 ecx, 32			; 00000020H
  01dd5	0f 84 38 02 00
	00		 je	 $LN200@PIT_CheckT
  01ddb	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01de0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01de3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01de9	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  01dec	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01def	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  01df2	81 ea 00 00 01
	00		 sub	 edx, 65536		; 00010000H
  01df8	3b ca		 cmp	 ecx, edx
  01dfa	0f 85 13 02 00
	00		 jne	 $LN200@PIT_CheckT
$LN187@PIT_CheckT:

; 719  : 				|| ((tmthing->eflags & MFE_VERTICALFLIP) && tmthing->z + tmthing->height == thing->z - FRACUNIT)))
; 720  : 		{
; 721  : 			if (thing->flags & MF_SPRING)

  01e00	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01e03	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01e06	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  01e0c	74 48		 je	 SHORT $LN189@PIT_CheckT

; 722  : 			{
; 723  : 				if (!(tmthing->player && (tmthing->player->pflags & PF_NIGHTSMODE)))

  01e0e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01e13	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  01e1a	74 19		 je	 SHORT $LN192@PIT_CheckT
  01e1c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01e21	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01e27	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01e2d	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  01e33	75 1c		 jne	 SHORT $LN191@PIT_CheckT
$LN192@PIT_CheckT:

; 724  : 				{
; 725  : 					P_DoSpring(thing, tmthing);

  01e35	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01e3a	50		 push	 eax
  01e3b	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  01e3e	51		 push	 ecx
  01e3f	e8 00 00 00 00	 call	 _P_DoSpring
  01e44	83 c4 08	 add	 esp, 8

; 726  : 					tmsprung = true;

  01e47	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _tmsprung, 1
$LN191@PIT_CheckT:

; 727  : 				}
; 728  : 			}

  01e51	e9 bd 01 00 00	 jmp	 $LN200@PIT_CheckT
$LN189@PIT_CheckT:

; 729  : 			else if (thing->flags & MF_MONITOR
; 730  : 				&& ((tmthing->player->pflags & PF_JUMPED) || (tmthing->player->pflags & PF_SPINNING)))

  01e56	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01e59	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01e5c	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  01e62	0f 84 a0 00 00
	00		 je	 $LN193@PIT_CheckT
  01e68	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01e6d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01e73	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01e79	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  01e7f	75 19		 jne	 SHORT $LN195@PIT_CheckT
  01e81	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01e86	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01e8c	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01e92	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  01e98	74 6e		 je	 SHORT $LN193@PIT_CheckT
$LN195@PIT_CheckT:

; 731  : 			{
; 732  : 				// Going down? Then bounce back up.
; 733  : 				if (tmthing->eflags & MFE_VERTICALFLIP)

  01e9a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01e9f	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01ea5	83 e1 20	 and	 ecx, 32			; 00000020H
  01ea8	74 20		 je	 SHORT $LN196@PIT_CheckT

; 734  : 				{
; 735  : 					if (tmthing->momz > 0)

  01eaa	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01eaf	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  01eb3	7e 13		 jle	 SHORT $LN198@PIT_CheckT

; 736  : 						tmthing->momz = -tmthing->momz;

  01eb5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01eba	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01ebd	f7 d9		 neg	 ecx
  01ebf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01ec5	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$LN198@PIT_CheckT:

; 737  : 				}

  01ec8	eb 1e		 jmp	 SHORT $LN199@PIT_CheckT
$LN196@PIT_CheckT:

; 738  : 				else
; 739  : 				{
; 740  : 					if (tmthing->momz < 0)

  01eca	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01ecf	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  01ed3	7d 13		 jge	 SHORT $LN199@PIT_CheckT

; 741  : 						tmthing->momz = -tmthing->momz;

  01ed5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01eda	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01edd	f7 d9		 neg	 ecx
  01edf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01ee5	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$LN199@PIT_CheckT:

; 742  : 				}
; 743  : 
; 744  : 				P_DamageMobj(thing, tmthing, tmthing, 1); // break the monitor

  01ee8	6a 01		 push	 1
  01eea	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01eef	50		 push	 eax
  01ef0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  01ef6	51		 push	 ecx
  01ef7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  01efa	52		 push	 edx
  01efb	e8 00 00 00 00	 call	 _P_DamageMobj
  01f00	83 c4 10	 add	 esp, 16			; 00000010H

; 745  : 			}

  01f03	e9 0b 01 00 00	 jmp	 $LN200@PIT_CheckT
$LN193@PIT_CheckT:

; 746  : 			else if (thing->flags & MF_BOSS
; 747  : 				&& ((tmthing->player->pflags & PF_JUMPED) || (tmthing->player->pflags & PF_SPINNING)

  01f08	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  01f0b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01f0e	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01f14	0f 84 f9 00 00
	00		 je	 $LN200@PIT_CheckT
  01f1a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01f1f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01f25	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01f2b	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  01f31	75 51		 jne	 SHORT $LN201@PIT_CheckT
  01f33	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01f38	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01f3e	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01f44	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  01f4a	75 38		 jne	 SHORT $LN201@PIT_CheckT
  01f4c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01f51	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01f57	ba 04 00 00 00	 mov	 edx, 4
  01f5c	6b c2 00	 imul	 eax, edx, 0
  01f5f	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  01f64	75 1e		 jne	 SHORT $LN201@PIT_CheckT
  01f66	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01f6b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  01f71	ba 04 00 00 00	 mov	 edx, 4
  01f76	6b c2 0f	 imul	 eax, edx, 15
  01f79	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  01f7e	0f 84 8f 00 00
	00		 je	 $LN200@PIT_CheckT
$LN201@PIT_CheckT:

; 748  : 				|| tmthing->player->powers[pw_invulnerability]
; 749  : 				|| tmthing->player->powers[pw_super]))
; 750  : 			{
; 751  : 				// Going down? Then bounce back up.
; 752  : 				if (tmthing->eflags & MFE_VERTICALFLIP)

  01f84	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01f89	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  01f8f	83 e1 20	 and	 ecx, 32			; 00000020H
  01f92	74 20		 je	 SHORT $LN202@PIT_CheckT

; 753  : 				{
; 754  : 					if (tmthing->momz > 0)

  01f94	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01f99	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  01f9d	7e 13		 jle	 SHORT $LN204@PIT_CheckT

; 755  : 						tmthing->momz = -tmthing->momz;

  01f9f	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01fa4	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01fa7	f7 d9		 neg	 ecx
  01fa9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01faf	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$LN204@PIT_CheckT:

; 756  : 				}

  01fb2	eb 1e		 jmp	 SHORT $LN205@PIT_CheckT
$LN202@PIT_CheckT:

; 757  : 				else
; 758  : 				{
; 759  : 					if (tmthing->momz < 0)

  01fb4	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01fb9	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  01fbd	7d 13		 jge	 SHORT $LN205@PIT_CheckT

; 760  : 						tmthing->momz = -tmthing->momz;

  01fbf	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01fc4	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01fc7	f7 d9		 neg	 ecx
  01fc9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01fcf	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
$LN205@PIT_CheckT:

; 761  : 				}
; 762  : 
; 763  : 				// Also, bounce back.
; 764  : 				tmthing->momx = -tmthing->momx;

  01fd2	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01fd7	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  01fda	f7 d9		 neg	 ecx
  01fdc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01fe2	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 765  : 				tmthing->momy = -tmthing->momy;

  01fe5	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01fea	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01fed	f7 d9		 neg	 ecx
  01fef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  01ff5	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 766  : 				P_DamageMobj(thing, tmthing, tmthing, 1); // fight the boss!

  01ff8	6a 01		 push	 1
  01ffa	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  01fff	50		 push	 eax
  02000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  02006	51		 push	 ecx
  02007	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0200a	52		 push	 edx
  0200b	e8 00 00 00 00	 call	 _P_DamageMobj
  02010	83 c4 10	 add	 esp, 16			; 00000010H
$LN200@PIT_CheckT:

; 767  : 			}
; 768  : 		}
; 769  : 	}
; 770  : 
; 771  : 	// compatibility with old demos, it used to return with...
; 772  : 	// for version 112+, nonsolid things pass through other things
; 773  : 	if (!(tmthing->flags & MF_SOLID))

  02013	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  02018	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0201b	83 e1 02	 and	 ecx, 2
  0201e	75 23		 jne	 SHORT $LN206@PIT_CheckT

; 774  : 		return !(thing->flags & MF_SOLID);

  02020	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02023	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  02026	83 e1 02	 and	 ecx, 2
  02029	75 09		 jne	 SHORT $LN225@PIT_CheckT
  0202b	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv1347[ebp], 1
  02032	eb 07		 jmp	 SHORT $LN226@PIT_CheckT
$LN225@PIT_CheckT:
  02034	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv1347[ebp], 0
$LN226@PIT_CheckT:
  0203b	8b 45 b0	 mov	 eax, DWORD PTR tv1347[ebp]
  0203e	e9 df 01 00 00	 jmp	 $LN1@PIT_CheckT
$LN206@PIT_CheckT:

; 775  : 
; 776  : 	// z checking at last
; 777  : 	// Treat noclip things as non-solid!
; 778  : 	if ((thing->flags & MF_SOLID) && (tmthing->flags & MF_SOLID) &&
; 779  : 		!(thing->flags & MF_NOCLIP) && !(tmthing->flags & MF_NOCLIP))

  02043	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02046	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  02049	83 e1 02	 and	 ecx, 2
  0204c	0f 84 cb 01 00
	00		 je	 $LN217@PIT_CheckT
  02052	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  02057	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0205a	83 e1 02	 and	 ecx, 2
  0205d	0f 84 ba 01 00
	00		 je	 $LN217@PIT_CheckT
  02063	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02066	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  02069	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0206f	0f 85 a8 01 00
	00		 jne	 $LN217@PIT_CheckT
  02075	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0207a	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0207d	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  02083	0f 85 94 01 00
	00		 jne	 $LN217@PIT_CheckT

; 780  : 	{
; 781  : 		if (tmthing->eflags & MFE_VERTICALFLIP)

  02089	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0208e	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  02094	83 e1 20	 and	 ecx, 32			; 00000020H
  02097	0f 84 cf 00 00
	00		 je	 $LN208@PIT_CheckT

; 782  : 		{
; 783  : 			// pass under
; 784  : 			tmtopz = tmthing->z;

  0209d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  020a2	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  020a5	89 4d f4	 mov	 DWORD PTR _tmtopz$[ebp], ecx

; 785  : 
; 786  : 			if (tmtopz > thing->z + thing->height)

  020a8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  020ab	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  020ae	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  020b1	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  020b4	39 4d f4	 cmp	 DWORD PTR _tmtopz$[ebp], ecx
  020b7	7e 30		 jle	 SHORT $LN210@PIT_CheckT

; 787  : 			{
; 788  : 				if (thing->z + thing->height > tmfloorz)

  020b9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  020bc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  020bf	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  020c2	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  020c5	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmfloorz
  020cb	7e 12		 jle	 SHORT $LN211@PIT_CheckT

; 789  : 				{
; 790  : 					tmfloorz = thing->z + thing->height;

  020cd	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  020d0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  020d3	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  020d6	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  020d9	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmfloorz, ecx
$LN211@PIT_CheckT:

; 791  : 				}
; 792  : 				return true;

  020df	b8 01 00 00 00	 mov	 eax, 1
  020e4	e9 39 01 00 00	 jmp	 $LN1@PIT_CheckT
$LN210@PIT_CheckT:

; 793  : 			}
; 794  : 
; 795  : 			topz = thing->z - FRACUNIT;

  020e9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  020ec	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  020ef	81 e9 00 00 01
	00		 sub	 ecx, 65536		; 00010000H
  020f5	89 4d f8	 mov	 DWORD PTR _topz$[ebp], ecx

; 796  : 
; 797  : 			// block only when jumping not high enough,
; 798  : 			// (dont climb max. 24units while already in air)
; 799  : 			// if not in air, let P_TryMove() decide if it's not too high
; 800  : 			if (tmthing->player && tmthing->z + tmthing->height > topz
; 801  : 				&& tmthing->z + tmthing->height < tmthing->ceilingz)

  020f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  020fd	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  02104	74 38		 je	 SHORT $LN212@PIT_CheckT
  02106	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0210b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0210e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  02114	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  02117	3b 4d f8	 cmp	 ecx, DWORD PTR _topz$[ebp]
  0211a	7e 22		 jle	 SHORT $LN212@PIT_CheckT
  0211c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  02121	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02124	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0212a	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0212d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  02132	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  02135	7d 07		 jge	 SHORT $LN212@PIT_CheckT

; 802  : 				return false; // block while in air

  02137	33 c0		 xor	 eax, eax
  02139	e9 e4 00 00 00	 jmp	 $LN1@PIT_CheckT
$LN212@PIT_CheckT:

; 803  : 
; 804  : 			if (topz < tmceilingz && !(thing->flags & MF_SPRING))

  0213e	8b 45 f8	 mov	 eax, DWORD PTR _topz$[ebp]
  02141	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmceilingz
  02147	7d 1e		 jge	 SHORT $LN213@PIT_CheckT
  02149	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0214c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0214f	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  02155	75 10		 jne	 SHORT $LN213@PIT_CheckT

; 805  : 			{
; 806  : 				tmceilingz = topz;

  02157	8b 45 f8	 mov	 eax, DWORD PTR _topz$[ebp]
  0215a	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax

; 807  : 				tmfloorthing = thing; // thing we may stand on

  0215f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02162	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorthing, eax
$LN213@PIT_CheckT:

; 808  : 			}
; 809  : 		}

  02167	e9 b1 00 00 00	 jmp	 $LN217@PIT_CheckT
$LN208@PIT_CheckT:

; 810  : 		else
; 811  : 		{
; 812  : 			// pass under
; 813  : 			tmtopz = tmthing->z + tmthing->height;

  0216c	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  02171	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02174	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmthing
  0217a	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0217d	89 4d f4	 mov	 DWORD PTR _tmtopz$[ebp], ecx

; 814  : 
; 815  : 			if (tmtopz < thing->z)

  02180	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02183	8b 4d f4	 mov	 ecx, DWORD PTR _tmtopz$[ebp]
  02186	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  02189	7d 21		 jge	 SHORT $LN214@PIT_CheckT

; 816  : 			{
; 817  : 				if (thing->z < tmceilingz)

  0218b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0218e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02191	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmceilingz
  02197	7d 0c		 jge	 SHORT $LN215@PIT_CheckT

; 818  : 				{
; 819  : 					tmceilingz = thing->z;

  02199	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0219c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0219f	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmceilingz, ecx
$LN215@PIT_CheckT:

; 820  : 				}
; 821  : 				return true;

  021a5	b8 01 00 00 00	 mov	 eax, 1
  021aa	eb 76		 jmp	 SHORT $LN1@PIT_CheckT
$LN214@PIT_CheckT:

; 822  : 			}
; 823  : 
; 824  : 			topz = thing->z + thing->height + FRACUNIT;

  021ac	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  021af	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  021b2	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  021b5	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  021b8	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  021bf	89 4d f8	 mov	 DWORD PTR _topz$[ebp], ecx

; 825  : 
; 826  : 			// block only when jumping not high enough,
; 827  : 			// (dont climb max. 24units while already in air)
; 828  : 			// if not in air, let P_TryMove() decide if it's not too high
; 829  : 			if (tmthing->player && tmthing->z < topz && tmthing->z > tmthing->floorz)

  021c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  021c7	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  021ce	74 24		 je	 SHORT $LN216@PIT_CheckT
  021d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  021d5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  021d8	3b 4d f8	 cmp	 ecx, DWORD PTR _topz$[ebp]
  021db	7d 17		 jge	 SHORT $LN216@PIT_CheckT
  021dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  021e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmthing
  021e8	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  021eb	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  021ee	7e 04		 jle	 SHORT $LN216@PIT_CheckT

; 830  : 				return false; // block while in air

  021f0	33 c0		 xor	 eax, eax
  021f2	eb 2e		 jmp	 SHORT $LN1@PIT_CheckT
$LN216@PIT_CheckT:

; 831  : 
; 832  : 			if (topz > tmfloorz && !(thing->flags & MF_SPRING))

  021f4	8b 45 f8	 mov	 eax, DWORD PTR _topz$[ebp]
  021f7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmfloorz
  021fd	7e 1e		 jle	 SHORT $LN217@PIT_CheckT
  021ff	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02202	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  02205	81 e1 00 00 02
	00		 and	 ecx, 131072		; 00020000H
  0220b	75 10		 jne	 SHORT $LN217@PIT_CheckT

; 833  : 			{
; 834  : 				tmfloorz = topz;

  0220d	8b 45 f8	 mov	 eax, DWORD PTR _topz$[ebp]
  02210	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax

; 835  : 				tmfloorthing = thing; // thing we may stand on

  02215	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  02218	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorthing, eax
$LN217@PIT_CheckT:

; 836  : 			}
; 837  : 		}
; 838  : 	}
; 839  : 
; 840  : 	// not solid not blocked
; 841  : 	return true;

  0221d	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_CheckT:

; 842  : }

  02222	5f		 pop	 edi
  02223	5e		 pop	 esi
  02224	5b		 pop	 ebx
  02225	8b e5		 mov	 esp, ebp
  02227	5d		 pop	 ebp
  02228	c3		 ret	 0
_PIT_CheckThing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_DoSpring
_TEXT	SEGMENT
_spring$ = 8						; size = 4
_object$ = 12						; size = 4
_P_DoSpring PROC					; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 116  : 	// Spectators don't trigger springs.
; 117  : 	if (object->player && object->player->spectator)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  0000c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00013	74 19		 je	 SHORT $LN2@P_DoSpring
  00015	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00018	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0001e	0f b6 91 f0 01
	00 00		 movzx	 edx, BYTE PTR [ecx+496]
  00025	85 d2		 test	 edx, edx
  00027	74 05		 je	 SHORT $LN2@P_DoSpring

; 118  : 		return;

  00029	e9 b4 03 00 00	 jmp	 $LN17@P_DoSpring
$LN2@P_DoSpring:

; 119  : 
; 120  : 	if (object->player && (object->player->pflags & PF_NIGHTSMODE))

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00031	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00038	74 1c		 je	 SHORT $LN3@P_DoSpring
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  0003d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00043	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00049	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  0004f	74 05		 je	 SHORT $LN3@P_DoSpring

; 121  : 	{
; 122  : 		/*Someone want to make these work like bumpers?*/
; 123  : 		return;

  00051	e9 8c 03 00 00	 jmp	 $LN17@P_DoSpring
$LN3@P_DoSpring:

; 124  : 	}
; 125  : 
; 126  : 	spring->flags &= ~MF_SOLID; // De-solidify

  00056	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00059	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0005c	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0005f	8b 55 08	 mov	 edx, DWORD PTR _spring$[ebp]
  00062	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 127  : 
; 128  : 	if (spring->info->damage) // Mimic SA

  00065	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00068	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0006e	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  00072	74 44		 je	 SHORT $LN4@P_DoSpring

; 129  : 	{
; 130  : 		object->momx = object->momy = 0;

  00074	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00077	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  00081	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 131  : 		P_UnsetThingPosition(object);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  00091	83 c4 04	 add	 esp, 4

; 132  : 		object->x = spring->x;

  00094	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _spring$[ebp]
  0009a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0009d	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 133  : 		object->y = spring->y;

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _spring$[ebp]
  000a6	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a9	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 134  : 		P_SetThingPosition(object);

  000ac	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _P_SetThingPosition
  000b5	83 c4 04	 add	 esp, 4
$LN4@P_DoSpring:

; 135  : 	}
; 136  : 
; 137  : 	if (spring->info->speed > 0)

  000b8	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  000bb	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  000c1	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  000c5	7e 18		 jle	 SHORT $LN5@P_DoSpring

; 138  : 		object->z = spring->z + spring->height + 1;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  000ca	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000cd	8b 55 08	 mov	 edx, DWORD PTR _spring$[ebp]
  000d0	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000d3	8d 4c 01 01	 lea	 ecx, DWORD PTR [ecx+eax+1]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR _object$[ebp]
  000da	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  000dd	eb 15		 jmp	 SHORT $LN6@P_DoSpring
$LN5@P_DoSpring:

; 139  : 	else
; 140  : 		object->z = spring->z - object->height - 1;

  000df	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  000e2	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  000e5	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000e8	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  000eb	83 ea 01	 sub	 edx, 1
  000ee	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  000f1	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN6@P_DoSpring:

; 141  : 
; 142  : 	// You could have a non-ceiling spring flipped upside down, if you really wanted to...
; 143  : 	if (!(spring->eflags & MFE_VERTICALFLIP))

  000f4	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  000f7	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000fd	83 e1 20	 and	 ecx, 32			; 00000020H
  00100	75 4d		 jne	 SHORT $LN7@P_DoSpring

; 144  : 		object->momz = FIXEDSCALE(spring->info->speed,(object->scale+spring->scale)/2);

  00102	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00105	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0010b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0010e	52		 push	 edx
  0010f	68 00 00 64 00	 push	 6553600			; 00640000H
  00114	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00117	0f b7 80 cc 00
	00 00		 movzx	 eax, WORD PTR [eax+204]
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _spring$[ebp]
  00121	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  00128	03 c2		 add	 eax, edx
  0012a	99		 cdq
  0012b	2b c2		 sub	 eax, edx
  0012d	d1 f8		 sar	 eax, 1
  0012f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _FixedDiv
  00138	83 c4 08	 add	 esp, 8
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _FixedMul
  00141	83 c4 08	 add	 esp, 8
  00144	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  00147	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  0014a	e9 89 00 00 00	 jmp	 $LN8@P_DoSpring
$LN7@P_DoSpring:

; 145  : 	else
; 146  : 	{
; 147  : 		object->momz = FIXEDSCALE(-(spring->info->speed),(object->scale+spring->scale)/2);

  0014f	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00152	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00158	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0015b	f7 da		 neg	 edx
  0015d	52		 push	 edx
  0015e	68 00 00 64 00	 push	 6553600			; 00640000H
  00163	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00166	0f b7 80 cc 00
	00 00		 movzx	 eax, WORD PTR [eax+204]
  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _spring$[ebp]
  00170	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  00177	03 c2		 add	 eax, edx
  00179	99		 cdq
  0017a	2b c2		 sub	 eax, edx
  0017c	d1 f8		 sar	 eax, 1
  0017e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _FixedDiv
  00187	83 c4 08	 add	 esp, 8
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _FixedMul
  00190	83 c4 08	 add	 esp, 8
  00193	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  00196	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 148  : 		object->z -= FIXEDSCALE(spring->height, spring->scale) + object->height;

  00199	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  0019c	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0019f	51		 push	 ecx
  001a0	68 00 00 64 00	 push	 6553600			; 00640000H
  001a5	8b 55 08	 mov	 edx, DWORD PTR _spring$[ebp]
  001a8	0f b7 82 cc 00
	00 00		 movzx	 eax, WORD PTR [edx+204]
  001af	c1 e0 10	 shl	 eax, 16			; 00000010H
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 _FixedDiv
  001b8	83 c4 08	 add	 esp, 8
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _FixedMul
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  001c7	03 41 44	 add	 eax, DWORD PTR [ecx+68]
  001ca	8b 55 0c	 mov	 edx, DWORD PTR _object$[ebp]
  001cd	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  001d0	2b c8		 sub	 ecx, eax
  001d2	8b 55 0c	 mov	 edx, DWORD PTR _object$[ebp]
  001d5	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN8@P_DoSpring:

; 149  : 	}
; 150  : 
; 151  : 	object->momz = FIXEDSCALE(object->momz, spring->scale);

  001d8	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  001db	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  001de	51		 push	 ecx
  001df	68 00 00 64 00	 push	 6553600			; 00640000H
  001e4	8b 55 08	 mov	 edx, DWORD PTR _spring$[ebp]
  001e7	0f b7 82 cc 00
	00 00		 movzx	 eax, WORD PTR [edx+204]
  001ee	c1 e0 10	 shl	 eax, 16			; 00000010H
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _FixedDiv
  001f7	83 c4 08	 add	 esp, 8
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 _FixedMul
  00200	83 c4 08	 add	 esp, 8
  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  00206	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 152  : 
; 153  : 	P_TryMove(object, object->x, object->y, true);

  00209	6a 01		 push	 1
  0020b	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  0020e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00211	51		 push	 ecx
  00212	8b 55 0c	 mov	 edx, DWORD PTR _object$[ebp]
  00215	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00218	50		 push	 eax
  00219	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  0021c	51		 push	 ecx
  0021d	e8 00 00 00 00	 call	 _P_TryMove
  00222	83 c4 10	 add	 esp, 16			; 00000010H

; 154  : 
; 155  : 	if (spring->info->damage)

  00225	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00228	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0022e	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  00232	74 56		 je	 SHORT $LN9@P_DoSpring

; 156  : 		P_InstaThrustEvenIn2D(object, spring->angle, FIXEDSCALE(spring->info->damage,(object->scale+spring->scale)/2));

  00234	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00237	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0023d	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00240	52		 push	 edx
  00241	68 00 00 64 00	 push	 6553600			; 00640000H
  00246	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00249	0f b7 80 cc 00
	00 00		 movzx	 eax, WORD PTR [eax+204]
  00250	8b 4d 08	 mov	 ecx, DWORD PTR _spring$[ebp]
  00253	0f b7 91 cc 00
	00 00		 movzx	 edx, WORD PTR [ecx+204]
  0025a	03 c2		 add	 eax, edx
  0025c	99		 cdq
  0025d	2b c2		 sub	 eax, edx
  0025f	d1 f8		 sar	 eax, 1
  00261	c1 e0 10	 shl	 eax, 16			; 00000010H
  00264	50		 push	 eax
  00265	e8 00 00 00 00	 call	 _FixedDiv
  0026a	83 c4 08	 add	 esp, 8
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 _FixedMul
  00273	83 c4 08	 add	 esp, 8
  00276	50		 push	 eax
  00277	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  0027a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0027d	51		 push	 ecx
  0027e	8b 55 0c	 mov	 edx, DWORD PTR _object$[ebp]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 _P_InstaThrustEvenIn2D
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@P_DoSpring:

; 157  : 
; 158  : 	P_SetMobjState(spring, spring->info->seestate);

  0028a	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  0028d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  00293	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00296	52		 push	 edx
  00297	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 _P_SetMobjState
  002a0	83 c4 08	 add	 esp, 8

; 159  : 
; 160  : 	spring->flags |= MF_SOLID; // Re-solidify

  002a3	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  002a6	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  002a9	83 c9 02	 or	 ecx, 2
  002ac	8b 55 08	 mov	 edx, DWORD PTR _spring$[ebp]
  002af	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 161  : 	if (object->player)

  002b2	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  002b5	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  002bc	0f 84 20 01 00
	00		 je	 $LN17@P_DoSpring

; 162  : 	{
; 163  : 		if (spring->info->damage && !(object->player->cmd.forwardmove != 0 || object->player->cmd.sidemove != 0))

  002c2	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  002c5	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  002cb	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  002cf	0f 84 8d 00 00
	00		 je	 $LN14@P_DoSpring
  002d5	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  002d8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002de	0f be 51 08	 movsx	 edx, BYTE PTR [ecx+8]
  002e2	85 d2		 test	 edx, edx
  002e4	75 7c		 jne	 SHORT $LN14@P_DoSpring
  002e6	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  002e9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  002ef	0f be 51 09	 movsx	 edx, BYTE PTR [ecx+9]
  002f3	85 d2		 test	 edx, edx
  002f5	75 6b		 jne	 SHORT $LN14@P_DoSpring

; 164  : 		{
; 165  : 			object->player->mo->angle = spring->angle;

  002f7	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  002fa	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00300	8b 11		 mov	 edx, DWORD PTR [ecx]
  00302	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00305	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00308	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 166  : 
; 167  : 			if (object->player == &players[consoleplayer])

  0030b	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _consoleplayer, 508
  00315	05 00 00 00 00	 add	 eax, OFFSET _players
  0031a	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  0031d	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  00323	75 0e		 jne	 SHORT $LN12@P_DoSpring

; 168  : 				localangle = spring->angle;

  00325	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00328	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0032b	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle, ecx
  00331	eb 2f		 jmp	 SHORT $LN14@P_DoSpring
$LN12@P_DoSpring:

; 169  : 			else if (splitscreen && object->player == &players[secondarydisplayplayer])

  00333	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _splitscreen, 0
  0033a	74 26		 je	 SHORT $LN14@P_DoSpring
  0033c	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  00346	05 00 00 00 00	 add	 eax, OFFSET _players
  0034b	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp]
  0034e	39 81 a4 00 00
	00		 cmp	 DWORD PTR [ecx+164], eax
  00354	75 0c		 jne	 SHORT $LN14@P_DoSpring

; 170  : 				localangle2 = spring->angle;

  00356	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00359	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0035c	89 0d 00 00 00
	00		 mov	 DWORD PTR _localangle2, ecx
$LN14@P_DoSpring:

; 171  : 		}
; 172  : 
; 173  : 		P_ResetPlayer(object->player);

  00362	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00365	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0036b	51		 push	 ecx
  0036c	e8 00 00 00 00	 call	 _P_ResetPlayer
  00371	83 c4 04	 add	 esp, 4

; 174  : 
; 175  : 		if (spring->info->speed > 0)

  00374	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  00377	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  0037d	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00381	7e 10		 jle	 SHORT $LN15@P_DoSpring

; 176  : 			P_SetPlayerMobjState(object, S_PLAY_PLG1);

  00383	6a 10		 push	 16			; 00000010H
  00385	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  0038e	83 c4 08	 add	 esp, 8
  00391	eb 0e		 jmp	 SHORT $LN16@P_DoSpring
$LN15@P_DoSpring:

; 177  : 		else
; 178  : 			P_SetPlayerMobjState(object, S_PLAY_FALL1);

  00393	6a 27		 push	 39			; 00000027H
  00395	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  00398	50		 push	 eax
  00399	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  0039e	83 c4 08	 add	 esp, 8
$LN16@P_DoSpring:

; 179  : 
; 180  : 		if (spring->info->painchance)

  003a1	8b 45 08	 mov	 eax, DWORD PTR _spring$[ebp]
  003a4	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [eax+128]
  003aa	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  003ae	74 32		 je	 SHORT $LN17@P_DoSpring

; 181  : 		{
; 182  : 			object->player->pflags |= PF_JUMPED;

  003b0	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  003b3	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  003b9	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  003bf	81 ca 00 10 00
	00		 or	 edx, 4096		; 00001000H
  003c5	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  003c8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  003ce	89 91 ac 00 00
	00		 mov	 DWORD PTR [ecx+172], edx

; 183  : 			P_SetPlayerMobjState(object, S_PLAY_ATK1);

  003d4	6a 0c		 push	 12			; 0000000cH
  003d6	8b 45 0c	 mov	 eax, DWORD PTR _object$[ebp]
  003d9	50		 push	 eax
  003da	e8 00 00 00 00	 call	 _P_SetPlayerMobjState
  003df	83 c4 08	 add	 esp, 8
$LN17@P_DoSpring:

; 184  : 		}
; 185  : 	}
; 186  : }

  003e2	5f		 pop	 edi
  003e3	5e		 pop	 esi
  003e4	5b		 pop	 ebx
  003e5	8b e5		 mov	 esp, ebp
  003e7	5d		 pop	 ebp
  003e8	c3		 ret	 0
_P_DoSpring ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CheckOnmobj
_TEXT	SEGMENT
_oldmo$ = -224						; size = 212
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_newsubsec$ = -4					; size = 4
_thing$ = 8						; size = 4
_P_CheckOnmobj PROC					; COMDAT

; 3863 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3864 : 	subsector_t *newsubsec;
; 3865 : 	fixed_t x = thing->x, y = thing->y;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx
  00015	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00018	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001b	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx

; 3866 : 	mobj_t oldmo = *thing;

  0001e	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00023	8b 75 08	 mov	 esi, DWORD PTR _thing$[ebp]
  00026	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR _oldmo$[ebp]
  0002c	f3 a5		 rep movsd

; 3867 : 
; 3868 : 	tmthing = thing;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00031	a3 00 00 00 00	 mov	 DWORD PTR _tmthing, eax

; 3869 : 	tmflags = thing->flags;

  00036	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00039	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0003c	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmflags, ecx

; 3870 : 	P_FakeZMovement(tmthing);

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _P_FakeZMovement
  0004d	83 c4 04	 add	 esp, 4

; 3871 : 
; 3872 : 	tmx = x;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00053	a3 00 00 00 00	 mov	 DWORD PTR _tmx, eax

; 3873 : 	tmy = y;

  00058	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _tmy, eax

; 3874 : 
; 3875 : 	tmbbox[BOXTOP] = y + tmthing->radius;

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  00068	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0006b	ba 04 00 00 00	 mov	 edx, 4
  00070	6b c2 00	 imul	 eax, edx, 0
  00073	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 3876 : 	tmbbox[BOXBOTTOM] = y - tmthing->radius;

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  00081	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	c1 e2 00	 shl	 edx, 0
  0008c	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 3877 : 	tmbbox[BOXRIGHT] = x + tmthing->radius;

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0009a	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0009d	ba 04 00 00 00	 mov	 edx, 4
  000a2	6b c2 03	 imul	 eax, edx, 3
  000a5	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 3878 : 	tmbbox[BOXLEFT] = x - tmthing->radius;

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  000b3	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  000b6	ba 04 00 00 00	 mov	 edx, 4
  000bb	d1 e2		 shl	 edx, 1
  000bd	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 3879 : 
; 3880 : 	newsubsec = R_PointInSubsector(x, y);

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  000ca	51		 push	 ecx
  000cb	e8 00 00 00 00	 call	 _R_PointInSubsector
  000d0	83 c4 08	 add	 esp, 8
  000d3	89 45 fc	 mov	 DWORD PTR _newsubsec$[ebp], eax

; 3881 : 	ceilingline = NULL;

  000d6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ceilingline, 0

; 3882 : 
; 3883 : 	//
; 3884 : 	// the base floor / ceiling is from the subsector that contains the
; 3885 : 	// point. Any contacted lines the step closer together will adjust them
; 3886 : 	//
; 3887 : 	tmfloorz = tmdropoffz = newsubsec->sector->floorheight;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e7	89 15 00 00 00
	00		 mov	 DWORD PTR _tmdropoffz, edx
  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmdropoffz
  000f2	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax

; 3888 : 	tmceilingz = newsubsec->sector->ceilingheight;

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ff	89 15 00 00 00
	00		 mov	 DWORD PTR _tmceilingz, edx

; 3889 : 
; 3890 : 	validcount++;

  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  0010a	83 c0 01	 add	 eax, 1
  0010d	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 3891 : 
; 3892 : 	//Exempt ghosts from momentum truncation. Jazz 2/21/09
; 3893 : 	if (tmflags & MF_NOCLIP && tmthing->type != MT_GHOST)

  00112	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmflags
  00117	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0011c	74 12		 je	 SHORT $LN2@P_CheckOnm
  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00123	81 78 7c 09 01
	00 00		 cmp	 DWORD PTR [eax+124], 265 ; 00000109H
  0012a	74 04		 je	 SHORT $LN2@P_CheckOnm

; 3894 : 		return NULL;

  0012c	33 c0		 xor	 eax, eax
  0012e	eb 15		 jmp	 SHORT $LN1@P_CheckOnm
$LN2@P_CheckOnm:

; 3895 : 
; 3896 : 	*tmthing = oldmo;

  00130	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00135	8d b5 20 ff ff
	ff		 lea	 esi, DWORD PTR _oldmo$[ebp]
  0013b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _tmthing
  00141	f3 a5		 rep movsd

; 3897 : 	return NULL;

  00143	33 c0		 xor	 eax, eax
$LN1@P_CheckOnm:

; 3898 : }

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
_P_CheckOnmobj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _PIT_PushableMoved
_TEXT	SEGMENT
_blockdist$ = -4					; size = 4
_thing$ = 8						; size = 4
_PIT_PushableMoved PROC					; COMDAT

; 1541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1542 : 	fixed_t blockdist;
; 1543 : 
; 1544 : 	if (!(thing->flags & MF_SOLID)
; 1545 : 		|| (thing->flags & MF_NOGRAVITY))

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0000f	83 e1 02	 and	 ecx, 2
  00012	74 0e		 je	 SHORT $LN3@PIT_Pushab
  00014	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00017	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0001a	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00020	74 0a		 je	 SHORT $LN2@PIT_Pushab
$LN3@PIT_Pushab:

; 1546 : 		return true; // Don't move something non-solid!

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	e9 e3 00 00 00	 jmp	 $LN1@PIT_Pushab
$LN2@PIT_Pushab:

; 1547 : 
; 1548 : 	// Only pushables are supported... for now.
; 1549 : 	if (!(thing->flags & MF_PUSHABLE))

  0002c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0002f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00032	83 e1 40	 and	 ecx, 64			; 00000040H
  00035	75 0a		 jne	 SHORT $LN4@PIT_Pushab

; 1550 : 		return true;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	e9 ce 00 00 00	 jmp	 $LN1@PIT_Pushab
$LN4@PIT_Pushab:

; 1551 : 
; 1552 : 	if (thing == stand)

  00041	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00044	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _stand
  0004a	75 0a		 jne	 SHORT $LN5@PIT_Pushab

; 1553 : 		return true;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	e9 b9 00 00 00	 jmp	 $LN1@PIT_Pushab
$LN5@PIT_Pushab:

; 1554 : 
; 1555 : 	blockdist = stand->radius + thing->radius;

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR _stand
  0005b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00061	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00064	89 4d fc	 mov	 DWORD PTR _blockdist$[ebp], ecx

; 1556 : 
; 1557 : 	if (abs(thing->x - stand->x) >= blockdist || abs(thing->y - stand->y) >= blockdist)

  00067	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stand
  00070	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00073	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _abs
  0007c	83 c4 04	 add	 esp, 4
  0007f	3b 45 fc	 cmp	 eax, DWORD PTR _blockdist$[ebp]
  00082	7d 1d		 jge	 SHORT $LN7@PIT_Pushab
  00084	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stand
  0008d	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00090	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 _abs
  00099	83 c4 04	 add	 esp, 4
  0009c	3b 45 fc	 cmp	 eax, DWORD PTR _blockdist$[ebp]
  0009f	7c 07		 jl	 SHORT $LN6@PIT_Pushab
$LN7@PIT_Pushab:

; 1558 : 		return true; // didn't hit it

  000a1	b8 01 00 00 00	 mov	 eax, 1
  000a6	eb 67		 jmp	 SHORT $LN1@PIT_Pushab
$LN6@PIT_Pushab:

; 1559 : 
; 1560 : 	if (thing->z != stand->z + stand->height + FRACUNIT)

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _stand
  000ad	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stand
  000b6	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000b9	8d 8c 01 00 00
	01 00		 lea	 ecx, DWORD PTR [ecx+eax+65536]
  000c0	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000c3	39 4a 18	 cmp	 DWORD PTR [edx+24], ecx
  000c6	74 07		 je	 SHORT $LN8@PIT_Pushab

; 1561 : 		return true; // Not standing on top

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	eb 40		 jmp	 SHORT $LN1@PIT_Pushab
$LN8@PIT_Pushab:

; 1562 : 
; 1563 : 	if (!stand->momx && !stand->momy)

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _stand
  000d4	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  000d8	75 12		 jne	 SHORT $LN9@PIT_Pushab
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR _stand
  000df	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000e3	75 07		 jne	 SHORT $LN9@PIT_Pushab

; 1564 : 		return true;

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	eb 23		 jmp	 SHORT $LN1@PIT_Pushab
$LN9@PIT_Pushab:

; 1565 : 
; 1566 : 	// Move this guy!
; 1567 : 	thing->momx = stand->momx;

  000ec	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stand
  000f5	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  000f8	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1568 : 	thing->momy = stand->momy;

  000fb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stand
  00104	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00107	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 1569 : 	return true;

  0010a	b8 01 00 00 00	 mov	 eax, 1
$LN1@PIT_Pushab:

; 1570 : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_PIT_PushableMoved ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_FloorzAtPos
_TEXT	SEGMENT
_thingtop$1 = -24					; size = 4
_delta2$2 = -20						; size = 4
_delta1$3 = -16						; size = 4
_rover$4 = -12						; size = 4
_floorz$ = -8						; size = 4
_sec$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_height$ = 20						; size = 4
_P_FloorzAtPos PROC					; COMDAT

; 3724 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3725 : 	sector_t *sec = R_PointInSubsector(x, y)->sector;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _R_PointInSubsector
  00016	83 c4 08	 add	 esp, 8
  00019	8b 10		 mov	 edx, DWORD PTR [eax]
  0001b	89 55 fc	 mov	 DWORD PTR _sec$[ebp], edx

; 3726 : 	fixed_t floorz = sec->floorheight;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f8	 mov	 DWORD PTR _floorz$[ebp], ecx

; 3727 : 
; 3728 : 	// Intercept the stupid 'fall through 3dfloors' bug Tails 03-17-2002
; 3729 : 	if (sec->ffloors)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00029	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [eax+144], 0
  00030	0f 84 11 01 00
	00		 je	 $LN3@P_FloorzAt

; 3730 : 	{
; 3731 : 		ffloor_t *rover;
; 3732 : 		fixed_t delta1, delta2, thingtop = z + height;

  00036	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  00039	03 45 14	 add	 eax, DWORD PTR _height$[ebp]
  0003c	89 45 e8	 mov	 DWORD PTR _thingtop$1[ebp], eax

; 3733 : 
; 3734 : 		for (rover = sec->ffloors; rover; rover = rover->next)

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _sec$[ebp]
  00042	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00048	89 4d f4	 mov	 DWORD PTR _rover$4[ebp], ecx
  0004b	eb 09		 jmp	 SHORT $LN4@P_FloorzAt
$LN2@P_FloorzAt:
  0004d	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00050	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00053	89 4d f4	 mov	 DWORD PTR _rover$4[ebp], ecx
$LN4@P_FloorzAt:
  00056	83 7d f4 00	 cmp	 DWORD PTR _rover$4[ebp], 0
  0005a	0f 84 e7 00 00
	00		 je	 $LN3@P_FloorzAt

; 3735 : 		{
; 3736 : 			if (!(rover->flags & FF_EXISTS))

  00060	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00063	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00066	83 e1 01	 and	 ecx, 1
  00069	75 02		 jne	 SHORT $LN6@P_FloorzAt

; 3737 : 				continue;

  0006b	eb e0		 jmp	 SHORT $LN2@P_FloorzAt
$LN6@P_FloorzAt:

; 3738 : 
; 3739 : 			if ((!(rover->flags & FF_SOLID || rover->flags & FF_QUICKSAND) || (rover->flags & FF_SWIMMABLE)))

  0006d	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00070	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00073	83 e1 06	 and	 ecx, 6
  00076	75 0e		 jne	 SHORT $LN9@P_FloorzAt
  00078	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0007b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0007e	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00084	74 0b		 je	 SHORT $LN8@P_FloorzAt
$LN9@P_FloorzAt:
  00086	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00089	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0008c	83 e1 20	 and	 ecx, 32			; 00000020H
  0008f	74 02		 je	 SHORT $LN7@P_FloorzAt
$LN8@P_FloorzAt:

; 3740 : 				continue;

  00091	eb ba		 jmp	 SHORT $LN2@P_FloorzAt
$LN7@P_FloorzAt:

; 3741 : 
; 3742 : 			if (rover->flags & FF_QUICKSAND)

  00093	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00096	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00099	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  0009f	74 21		 je	 SHORT $LN11@P_FloorzAt

; 3743 : 			{
; 3744 : 				if (z < *rover->topheight && *rover->bottomheight < thingtop)

  000a1	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a6	8b 55 10	 mov	 edx, DWORD PTR _z$[ebp]
  000a9	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000ab	7d 15		 jge	 SHORT $LN11@P_FloorzAt
  000ad	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000b0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b5	3b 55 e8	 cmp	 edx, DWORD PTR _thingtop$1[ebp]
  000b8	7d 08		 jge	 SHORT $LN11@P_FloorzAt

; 3745 : 				{
; 3746 : 					floorz = z;

  000ba	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  000bd	89 45 f8	 mov	 DWORD PTR _floorz$[ebp], eax

; 3747 : 					continue;

  000c0	eb 8b		 jmp	 SHORT $LN2@P_FloorzAt
$LN11@P_FloorzAt:

; 3748 : 				}
; 3749 : 			}
; 3750 : 
; 3751 : 			delta1 = z - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2));

  000c2	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000c5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c8	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000cb	8b 02		 mov	 eax, DWORD PTR [edx]
  000cd	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000d0	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000d3	8b 00		 mov	 eax, DWORD PTR [eax]
  000d5	2b 02		 sub	 eax, DWORD PTR [edx]
  000d7	99		 cdq
  000d8	2b c2		 sub	 eax, edx
  000da	d1 f8		 sar	 eax, 1
  000dc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000de	03 c8		 add	 ecx, eax
  000e0	8b 55 10	 mov	 edx, DWORD PTR _z$[ebp]
  000e3	2b d1		 sub	 edx, ecx
  000e5	89 55 f0	 mov	 DWORD PTR _delta1$3[ebp], edx

; 3752 : 			delta2 = thingtop - (*rover->bottomheight + ((*rover->topheight - *rover->bottomheight)/2));

  000e8	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  000eb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ee	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000f1	8b 02		 mov	 eax, DWORD PTR [edx]
  000f3	8b 55 f4	 mov	 edx, DWORD PTR _rover$4[ebp]
  000f6	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  000f9	8b 00		 mov	 eax, DWORD PTR [eax]
  000fb	2b 02		 sub	 eax, DWORD PTR [edx]
  000fd	99		 cdq
  000fe	2b c2		 sub	 eax, edx
  00100	d1 f8		 sar	 eax, 1
  00102	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00104	03 c8		 add	 ecx, eax
  00106	8b 55 e8	 mov	 edx, DWORD PTR _thingtop$1[ebp]
  00109	2b d1		 sub	 edx, ecx
  0010b	89 55 ec	 mov	 DWORD PTR _delta2$2[ebp], edx

; 3753 : 			if (*rover->topheight > floorz && abs(delta1) < abs(delta2))

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  00111	8b 08		 mov	 ecx, DWORD PTR [eax]
  00113	8b 11		 mov	 edx, DWORD PTR [ecx]
  00115	3b 55 f8	 cmp	 edx, DWORD PTR _floorz$[ebp]
  00118	7e 28		 jle	 SHORT $LN12@P_FloorzAt
  0011a	8b 45 f0	 mov	 eax, DWORD PTR _delta1$3[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _abs
  00123	83 c4 04	 add	 esp, 4
  00126	8b f0		 mov	 esi, eax
  00128	8b 4d ec	 mov	 ecx, DWORD PTR _delta2$2[ebp]
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 _abs
  00131	83 c4 04	 add	 esp, 4
  00134	3b f0		 cmp	 esi, eax
  00136	7d 0a		 jge	 SHORT $LN12@P_FloorzAt

; 3754 : 				floorz = *rover->topheight;

  00138	8b 45 f4	 mov	 eax, DWORD PTR _rover$4[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013f	89 55 f8	 mov	 DWORD PTR _floorz$[ebp], edx
$LN12@P_FloorzAt:

; 3755 : 		}

  00142	e9 06 ff ff ff	 jmp	 $LN2@P_FloorzAt
$LN3@P_FloorzAt:

; 3756 : 	}
; 3757 : 
; 3758 : 	return floorz;

  00147	8b 45 f8	 mov	 eax, DWORD PTR _floorz$[ebp]

; 3759 : }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
_P_FloorzAtPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_RadiusAttack
_TEXT	SEGMENT
_dist$ = -28						; size = 4
_yh$ = -24						; size = 4
_yl$ = -20						; size = 4
_xh$ = -16						; size = 4
_xl$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_spot$ = 8						; size = 4
_source$ = 12						; size = 4
_damage$ = 16						; size = 4
_P_RadiusAttack PROC					; COMDAT

; 2980 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2981 : 	INT32 x, y;
; 2982 : 	INT32 xl, xh, yl, yh;
; 2983 : 	fixed_t dist;
; 2984 : 
; 2985 : 	dist = (damage + MAXRADIUS)<<FRACBITS;

  00009	8b 45 10	 mov	 eax, DWORD PTR _damage$[ebp]
  0000c	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  00011	c1 e0 10	 shl	 eax, 16			; 00000010H
  00014	89 45 e4	 mov	 DWORD PTR _dist$[ebp], eax

; 2986 : 	yh = (unsigned)(spot->y + dist - bmaporgy)>>MAPBLOCKSHIFT;

  00017	8b 45 08	 mov	 eax, DWORD PTR _spot$[ebp]
  0001a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001d	03 4d e4	 add	 ecx, DWORD PTR _dist$[ebp]
  00020	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  00026	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00029	89 4d e8	 mov	 DWORD PTR _yh$[ebp], ecx

; 2987 : 	yl = (unsigned)(spot->y - dist - bmaporgy)>>MAPBLOCKSHIFT;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _spot$[ebp]
  0002f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00032	2b 4d e4	 sub	 ecx, DWORD PTR _dist$[ebp]
  00035	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  0003b	c1 e9 17	 shr	 ecx, 23			; 00000017H
  0003e	89 4d ec	 mov	 DWORD PTR _yl$[ebp], ecx

; 2988 : 	xh = (unsigned)(spot->x + dist - bmaporgx)>>MAPBLOCKSHIFT;

  00041	8b 45 08	 mov	 eax, DWORD PTR _spot$[ebp]
  00044	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00047	03 4d e4	 add	 ecx, DWORD PTR _dist$[ebp]
  0004a	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  00050	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00053	89 4d f0	 mov	 DWORD PTR _xh$[ebp], ecx

; 2989 : 	xl = (unsigned)(spot->x - dist - bmaporgx)>>MAPBLOCKSHIFT;

  00056	8b 45 08	 mov	 eax, DWORD PTR _spot$[ebp]
  00059	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005c	2b 4d e4	 sub	 ecx, DWORD PTR _dist$[ebp]
  0005f	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  00065	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00068	89 4d f4	 mov	 DWORD PTR _xl$[ebp], ecx

; 2990 : 	bombspot = spot;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _spot$[ebp]
  0006e	a3 00 00 00 00	 mov	 DWORD PTR _bombspot, eax

; 2991 : 
; 2992 : 	bombsource = source;

  00073	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00076	a3 00 00 00 00	 mov	 DWORD PTR _bombsource, eax

; 2993 : 	bombdamage = damage;

  0007b	8b 45 10	 mov	 eax, DWORD PTR _damage$[ebp]
  0007e	a3 00 00 00 00	 mov	 DWORD PTR _bombdamage, eax

; 2994 : 
; 2995 : 	for (y = yl; y <= yh; y++)

  00083	8b 45 ec	 mov	 eax, DWORD PTR _yl$[ebp]
  00086	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
  00089	eb 09		 jmp	 SHORT $LN4@P_RadiusAt
$LN2@P_RadiusAt:
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@P_RadiusAt:
  00094	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00097	3b 45 e8	 cmp	 eax, DWORD PTR _yh$[ebp]
  0009a	7f 32		 jg	 SHORT $LN3@P_RadiusAt

; 2996 : 		for (x = xl; x <= xh; x++)

  0009c	8b 45 f4	 mov	 eax, DWORD PTR _xl$[ebp]
  0009f	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
  000a2	eb 09		 jmp	 SHORT $LN7@P_RadiusAt
$LN5@P_RadiusAt:
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@P_RadiusAt:
  000ad	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  000b0	3b 45 f0	 cmp	 eax, DWORD PTR _xh$[ebp]
  000b3	7f 17		 jg	 SHORT $LN6@P_RadiusAt

; 2997 : 			P_BlockThingsIterator(x, y, PIT_RadiusAttack);

  000b5	68 00 00 00 00	 push	 OFFSET _PIT_RadiusAttack
  000ba	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 _P_BlockThingsIterator
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	eb d8		 jmp	 SHORT $LN5@P_RadiusAt
$LN6@P_RadiusAt:
  000cc	eb bd		 jmp	 SHORT $LN2@P_RadiusAt
$LN3@P_RadiusAt:

; 2998 : }

  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
_P_RadiusAttack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_AimLineAttack
_TEXT	SEGMENT
_slopeaiming$1 = -24					; size = 4
_cosineaiming$2 = -20					; size = 4
_aiming$3 = -16						; size = 4
_baseaiming$ = -12					; size = 4
_y2$ = -8						; size = 4
_x2$ = -4						; size = 4
_t1$ = 8						; size = 4
_angle$ = 12						; size = 4
_distance$ = 16						; size = 4
_P_AimLineAttack PROC					; COMDAT

; 2846 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2847 : 	fixed_t x2, y2;
; 2848 : 	const fixed_t baseaiming = 10*FRACUNIT/16;

  00009	c7 45 f4 00 a0
	00 00		 mov	 DWORD PTR _baseaiming$[ebp], 40960 ; 0000a000H

; 2849 : 
; 2850 : 	I_Assert(t1 != NULL);
; 2851 : 
; 2852 : 	angle >>= ANGLETOFINESHIFT;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _angle$[ebp]
  00013	c1 e8 13	 shr	 eax, 19			; 00000013H
  00016	89 45 0c	 mov	 DWORD PTR _angle$[ebp], eax

; 2853 : 	shootthing = t1;

  00019	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _shootthing, eax

; 2854 : 
; 2855 : 	topslope = baseaiming;

  00021	8b 45 f4	 mov	 eax, DWORD PTR _baseaiming$[ebp]
  00024	a3 00 00 00 00	 mov	 DWORD PTR _topslope, eax

; 2856 : 	bottomslope = -baseaiming;

  00029	8b 45 f4	 mov	 eax, DWORD PTR _baseaiming$[ebp]
  0002c	f7 d8		 neg	 eax
  0002e	a3 00 00 00 00	 mov	 DWORD PTR _bottomslope, eax

; 2857 : 
; 2858 : 	if (t1->player)

  00033	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00036	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0003d	0f 84 fd 00 00
	00		 je	 $LN2@P_AimLineA

; 2859 : 	{
; 2860 : 		const angle_t aiming = t1->player->aiming>>ANGLETOFINESHIFT;

  00043	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00046	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0004c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0004f	c1 ea 13	 shr	 edx, 19			; 00000013H
  00052	89 55 f0	 mov	 DWORD PTR _aiming$3[ebp], edx

; 2861 : 		const fixed_t cosineaiming = FINECOSINE(aiming);

  00055	8b 45 f0	 mov	 eax, DWORD PTR _aiming$3[ebp]
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _finecosine
  0005e	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00061	89 55 ec	 mov	 DWORD PTR _cosineaiming$2[ebp], edx

; 2862 : 		const fixed_t slopeaiming = FINETANGENT((FINEANGLES/4+aiming) & FINEMASK);

  00064	8b 45 f0	 mov	 eax, DWORD PTR _aiming$3[ebp]
  00067	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  0006c	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  00071	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _finetangent[eax*4]
  00078	89 4d e8	 mov	 DWORD PTR _slopeaiming$1[ebp], ecx

; 2863 : 		x2 = t1->x + FixedMul(FixedMul(distance, FINECOSINE(angle)), cosineaiming);

  0007b	8b 45 ec	 mov	 eax, DWORD PTR _cosineaiming$2[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _angle$[ebp]
  00082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _finecosine
  00088	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0008b	50		 push	 eax
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR _distance$[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _FixedMul
  00095	83 c4 08	 add	 esp, 8
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _FixedMul
  0009e	83 c4 08	 add	 esp, 8
  000a1	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  000a4	03 42 10	 add	 eax, DWORD PTR [edx+16]
  000a7	89 45 fc	 mov	 DWORD PTR _x2$[ebp], eax

; 2864 : 		y2 = t1->y + FixedMul(FixedMul(distance, FINESINE(angle)), cosineaiming);

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _cosineaiming$2[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _angle$[ebp]
  000b1	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _finesine[ecx*4]
  000b8	52		 push	 edx
  000b9	8b 45 10	 mov	 eax, DWORD PTR _distance$[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _FixedMul
  000c2	83 c4 08	 add	 esp, 8
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _FixedMul
  000cb	83 c4 08	 add	 esp, 8
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _t1$[ebp]
  000d1	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  000d4	89 45 f8	 mov	 DWORD PTR _y2$[ebp], eax

; 2865 : 
; 2866 : 		topslope += slopeaiming;

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _topslope
  000dc	03 45 e8	 add	 eax, DWORD PTR _slopeaiming$1[ebp]
  000df	a3 00 00 00 00	 mov	 DWORD PTR _topslope, eax

; 2867 : 		bottomslope += slopeaiming;

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _bottomslope
  000e9	03 45 e8	 add	 eax, DWORD PTR _slopeaiming$1[ebp]
  000ec	a3 00 00 00 00	 mov	 DWORD PTR _bottomslope, eax

; 2868 : 
; 2869 : 		if (gametype == GT_CTF || (gametype == GT_MATCH && cv_matchtype.value)) // Team

  000f1	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  000f8	83 f8 04	 cmp	 eax, 4
  000fb	74 15		 je	 SHORT $LN6@P_AimLineA
  000fd	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00104	83 f8 01	 cmp	 eax, 1
  00107	75 20		 jne	 SHORT $LN4@P_AimLineA
  00109	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR _cv_matchtype+20, 0
  00110	74 17		 je	 SHORT $LN4@P_AimLineA
$LN6@P_AimLineA:

; 2870 : 			aim_nofriends = t1->player->ctfteam;

  00112	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00115	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0011b	8b 91 60 01 00
	00		 mov	 edx, DWORD PTR [ecx+352]
  00121	89 15 00 00 00
	00		 mov	 DWORD PTR _aim_nofriends, edx
  00127	eb 15		 jmp	 SHORT $LN7@P_AimLineA
$LN4@P_AimLineA:

; 2871 : 		else if (gametype == GT_COOP)

  00129	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _gametype
  00130	85 c0		 test	 eax, eax
  00132	75 0a		 jne	 SHORT $LN7@P_AimLineA

; 2872 : 			aim_nofriends = -1; // Don't shoot any players

  00134	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _aim_nofriends, -1
$LN7@P_AimLineA:

; 2873 : 	}

  0013e	eb 40		 jmp	 SHORT $LN3@P_AimLineA
$LN2@P_AimLineA:

; 2874 : 	else
; 2875 : 	{
; 2876 : 		x2 = t1->x + (distance>>FRACBITS)*FINECOSINE(angle);

  00140	8b 45 10	 mov	 eax, DWORD PTR _distance$[ebp]
  00143	c1 f8 10	 sar	 eax, 16			; 00000010H
  00146	8b 4d 0c	 mov	 ecx, DWORD PTR _angle$[ebp]
  00149	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _finecosine
  0014f	0f af 04 8a	 imul	 eax, DWORD PTR [edx+ecx*4]
  00153	8b 4d 08	 mov	 ecx, DWORD PTR _t1$[ebp]
  00156	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00159	89 45 fc	 mov	 DWORD PTR _x2$[ebp], eax

; 2877 : 		y2 = t1->y + (distance>>FRACBITS)*FINESINE(angle);

  0015c	8b 45 10	 mov	 eax, DWORD PTR _distance$[ebp]
  0015f	c1 f8 10	 sar	 eax, 16			; 00000010H
  00162	8b 4d 0c	 mov	 ecx, DWORD PTR _angle$[ebp]
  00165	0f af 04 8d 00
	00 00 00	 imul	 eax, DWORD PTR _finesine[ecx*4]
  0016d	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  00170	03 42 14	 add	 eax, DWORD PTR [edx+20]
  00173	89 45 f8	 mov	 DWORD PTR _y2$[ebp], eax

; 2878 : 
; 2879 : 		//added : 15-02-98: Fab comments...
; 2880 : 		// Doom's base engine says that at a distance of 160,
; 2881 : 		// the 2d graphics on the plane x, y correspond 1/1 with plane units
; 2882 : 		aim_nofriends = 0;

  00176	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _aim_nofriends, 0
$LN3@P_AimLineA:

; 2883 : 	}
; 2884 : 
; 2885 : 	shootz = lastz = t1->z + (t1->height>>1) + 8*FRACUNIT;

  00180	8b 45 08	 mov	 eax, DWORD PTR _t1$[ebp]
  00183	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00186	d1 f9		 sar	 ecx, 1
  00188	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  0018b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0018e	8d 8c 08 00 00
	08 00		 lea	 ecx, DWORD PTR [eax+ecx+524288]
  00195	89 0d 00 00 00
	00		 mov	 DWORD PTR _lastz, ecx
  0019b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _lastz
  001a1	89 15 00 00 00
	00		 mov	 DWORD PTR _shootz, edx

; 2886 : 
; 2887 : 	// can't shoot outside view angles
; 2888 : 	attackrange = distance;

  001a7	8b 45 10	 mov	 eax, DWORD PTR _distance$[ebp]
  001aa	a3 00 00 00 00	 mov	 DWORD PTR _attackrange, eax

; 2889 : 	linetarget = NULL;

  001af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _linetarget, 0

; 2890 : 
; 2891 : 	//added : 15-02-98: comments
; 2892 : 	// traverse all linedefs and mobjs from the blockmap containing t1,
; 2893 : 	// to the blockmap containing the dest. point.
; 2894 : 	// Call the function for each mobj/line on the way,
; 2895 : 	// starting with the mobj/linedef at the shortest distance...
; 2896 : 	P_PathTraverse(t1->x, t1->y, x2, y2, PT_ADDLINES|PT_ADDTHINGS, PTR_AimTraverse);

  001b9	68 00 00 00 00	 push	 OFFSET _PTR_AimTraverse
  001be	6a 03		 push	 3
  001c0	8b 45 f8	 mov	 eax, DWORD PTR _y2$[ebp]
  001c3	50		 push	 eax
  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _x2$[ebp]
  001c7	51		 push	 ecx
  001c8	8b 55 08	 mov	 edx, DWORD PTR _t1$[ebp]
  001cb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001ce	50		 push	 eax
  001cf	8b 4d 08	 mov	 ecx, DWORD PTR _t1$[ebp]
  001d2	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001d5	52		 push	 edx
  001d6	e8 00 00 00 00	 call	 _P_PathTraverse
  001db	83 c4 18	 add	 esp, 24			; 00000018H

; 2897 : 
; 2898 : 	//added : 15-02-98: linetarget is only for mobjs, not for linedefs
; 2899 : 	if (linetarget)

  001de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _linetarget, 0
  001e5	74 07		 je	 SHORT $LN8@P_AimLineA

; 2900 : 		return aimslope;

  001e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _aimslope
  001ec	eb 02		 jmp	 SHORT $LN1@P_AimLineA
$LN8@P_AimLineA:

; 2901 : 
; 2902 : 	return 0;

  001ee	33 c0		 xor	 eax, eax
$LN1@P_AimLineA:

; 2903 : }

  001f0	5f		 pop	 edi
  001f1	5e		 pop	 esi
  001f2	5b		 pop	 ebx
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
_P_AimLineAttack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_Initsecnode
_TEXT	SEGMENT
_P_Initsecnode PROC					; COMDAT

; 3253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3254 : 	headsecnode = NULL;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _headsecnode, 0

; 3255 : 	headprecipsecnode = NULL;

  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _headprecipsecnode, 0

; 3256 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_P_Initsecnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CreateSecNodeList
_TEXT	SEGMENT
_saved_tmy$ = -40					; size = 4
_saved_tmx$ = -36					; size = 4
_saved_tmthing$ = -32					; size = 4
_node$ = -28						; size = 4
_by$ = -24						; size = 4
_bx$ = -20						; size = 4
_yh$ = -16						; size = 4
_yl$ = -12						; size = 4
_xh$ = -8						; size = 4
_xl$ = -4						; size = 4
_thing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_P_CreateSecNodeList PROC				; COMDAT

; 3558 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3559 : 	INT32 xl, xh, yl, yh, bx, by;
; 3560 : 	msecnode_t *node = sector_list;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  0000e	89 45 e4	 mov	 DWORD PTR _node$[ebp], eax

; 3561 : 	mobj_t *saved_tmthing = tmthing; /* cph - see comment at func end */

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00016	89 45 e0	 mov	 DWORD PTR _saved_tmthing$[ebp], eax

; 3562 : 	fixed_t saved_tmx = tmx, saved_tmy = tmy; /* ditto */

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmx
  0001e	89 45 dc	 mov	 DWORD PTR _saved_tmx$[ebp], eax
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmy
  00026	89 45 d8	 mov	 DWORD PTR _saved_tmy$[ebp], eax
$LN2@P_CreateSe:

; 3563 : 
; 3564 : 	// First, clear out the existing m_thing fields. As each node is
; 3565 : 	// added or verified as needed, m_thing will be set properly. When
; 3566 : 	// finished, delete all nodes where m_thing is still NULL. These
; 3567 : 	// represent the sectors the Thing has vacated.
; 3568 : 
; 3569 : 	while (node)

  00029	83 7d e4 00	 cmp	 DWORD PTR _node$[ebp], 0
  0002d	74 15		 je	 SHORT $LN3@P_CreateSe

; 3570 : 	{
; 3571 : 		node->m_thing = NULL;

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3572 : 		node = node->m_tnext;

  00039	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0003c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003f	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx

; 3573 : 	}

  00042	eb e5		 jmp	 SHORT $LN2@P_CreateSe
$LN3@P_CreateSe:

; 3574 : 
; 3575 : 	tmthing = thing;

  00044	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00047	a3 00 00 00 00	 mov	 DWORD PTR _tmthing, eax

; 3576 : 	tmflags = thing->flags;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0004f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00052	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmflags, ecx

; 3577 : 
; 3578 : 	tmx = x;

  00058	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _tmx, eax

; 3579 : 	tmy = y;

  00060	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00063	a3 00 00 00 00	 mov	 DWORD PTR _tmy, eax

; 3580 : 
; 3581 : 	tmbbox[BOXTOP] = y + tmthing->radius;

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00070	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  00073	ba 04 00 00 00	 mov	 edx, 4
  00078	6b c2 00	 imul	 eax, edx, 0
  0007b	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 3582 : 	tmbbox[BOXBOTTOM] = y - tmthing->radius;

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00089	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  0008c	ba 04 00 00 00	 mov	 edx, 4
  00091	c1 e2 00	 shl	 edx, 0
  00094	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 3583 : 	tmbbox[BOXRIGHT] = x + tmthing->radius;

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0009f	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000a2	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  000a5	ba 04 00 00 00	 mov	 edx, 4
  000aa	6b c2 03	 imul	 eax, edx, 3
  000ad	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 3584 : 	tmbbox[BOXLEFT] = x - tmthing->radius;

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000bb	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  000be	ba 04 00 00 00	 mov	 edx, 4
  000c3	d1 e2		 shl	 edx, 1
  000c5	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 3585 : 
; 3586 : 	validcount++; // used to make sure we only process a line once

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  000d0	83 c0 01	 add	 eax, 1
  000d3	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 3587 : 
; 3588 : 	xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx)>>MAPBLOCKSHIFT;

  000d8	b8 04 00 00 00	 mov	 eax, 4
  000dd	d1 e0		 shl	 eax, 1
  000df	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  000e5	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  000eb	c1 e9 17	 shr	 ecx, 23			; 00000017H
  000ee	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 3589 : 	xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx)>>MAPBLOCKSHIFT;

  000f1	b8 04 00 00 00	 mov	 eax, 4
  000f6	6b c8 03	 imul	 ecx, eax, 3
  000f9	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  000ff	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  00105	c1 ea 17	 shr	 edx, 23			; 00000017H
  00108	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 3590 : 	yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy)>>MAPBLOCKSHIFT;

  0010b	b8 04 00 00 00	 mov	 eax, 4
  00110	c1 e0 00	 shl	 eax, 0
  00113	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  00119	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  0011f	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00122	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 3591 : 	yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy)>>MAPBLOCKSHIFT;

  00125	b8 04 00 00 00	 mov	 eax, 4
  0012a	6b c8 00	 imul	 ecx, eax, 0
  0012d	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  00133	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  00139	c1 ea 17	 shr	 edx, 23			; 00000017H
  0013c	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 3592 : 
; 3593 : 	for (bx = xl; bx <= xh; bx++)

  0013f	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  00142	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  00145	eb 09		 jmp	 SHORT $LN6@P_CreateSe
$LN4@P_CreateSe:
  00147	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0014a	83 c0 01	 add	 eax, 1
  0014d	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN6@P_CreateSe:
  00150	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00153	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  00156	7f 32		 jg	 SHORT $LN5@P_CreateSe

; 3594 : 		for (by = yl; by <= yh; by++)

  00158	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  0015b	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  0015e	eb 09		 jmp	 SHORT $LN9@P_CreateSe
$LN7@P_CreateSe:
  00160	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00163	83 c0 01	 add	 eax, 1
  00166	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN9@P_CreateSe:
  00169	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0016c	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  0016f	7f 17		 jg	 SHORT $LN8@P_CreateSe

; 3595 : 			P_BlockLinesIterator(bx, by, PIT_GetSectors);

  00171	68 00 00 00 00	 push	 OFFSET _PIT_GetSectors
  00176	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00179	50		 push	 eax
  0017a	8b 4d ec	 mov	 ecx, DWORD PTR _bx$[ebp]
  0017d	51		 push	 ecx
  0017e	e8 00 00 00 00	 call	 _P_BlockLinesIterator
  00183	83 c4 0c	 add	 esp, 12			; 0000000cH
  00186	eb d8		 jmp	 SHORT $LN7@P_CreateSe
$LN8@P_CreateSe:
  00188	eb bd		 jmp	 SHORT $LN4@P_CreateSe
$LN5@P_CreateSe:

; 3596 : 
; 3597 : 	// Add the sector of the (x, y) point to sector_list.
; 3598 : 	sector_list = P_AddSecnode(thing->subsector->sector, thing, sector_list);

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  0018f	50		 push	 eax
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00193	51		 push	 ecx
  00194	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00197	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0019a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019c	51		 push	 ecx
  0019d	e8 00 00 00 00	 call	 _P_AddSecnode
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a5	a3 00 00 00 00	 mov	 DWORD PTR _sector_list, eax

; 3599 : 
; 3600 : 	// Now delete any nodes that won't be used. These are the ones where
; 3601 : 	// m_thing is still NULL.
; 3602 : 	node = sector_list;

  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  001af	89 45 e4	 mov	 DWORD PTR _node$[ebp], eax
$LN10@P_CreateSe:

; 3603 : 	while (node)

  001b2	83 7d e4 00	 cmp	 DWORD PTR _node$[ebp], 0
  001b6	74 3c		 je	 SHORT $LN11@P_CreateSe

; 3604 : 	{
; 3605 : 		if (!node->m_thing)

  001b8	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001bb	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001bf	75 28		 jne	 SHORT $LN12@P_CreateSe

; 3606 : 		{
; 3607 : 			if (node == sector_list)

  001c1	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001c4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _sector_list
  001ca	75 0c		 jne	 SHORT $LN14@P_CreateSe

; 3608 : 				sector_list = node->m_tnext;

  001cc	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001cf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001d2	89 0d 00 00 00
	00		 mov	 DWORD PTR _sector_list, ecx
$LN14@P_CreateSe:

; 3609 : 			node = P_DelSecnode(node);

  001d8	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 _P_DelSecnode
  001e1	83 c4 04	 add	 esp, 4
  001e4	89 45 e4	 mov	 DWORD PTR _node$[ebp], eax

; 3610 : 		}

  001e7	eb 09		 jmp	 SHORT $LN13@P_CreateSe
$LN12@P_CreateSe:

; 3611 : 		else
; 3612 : 			node = node->m_tnext;

  001e9	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001ec	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001ef	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx
$LN13@P_CreateSe:

; 3613 : 	}

  001f2	eb be		 jmp	 SHORT $LN10@P_CreateSe
$LN11@P_CreateSe:

; 3614 : 
; 3615 : 	/* cph -
; 3616 : 	* This is the strife we get into for using global variables. tmthing
; 3617 : 	*  is being used by several different functions calling
; 3618 : 	*  P_BlockThingIterator, including functions that can be called *from*
; 3619 : 	*  P_BlockThingIterator. Using a global tmthing is not reentrant.
; 3620 : 	* OTOH for Boom/MBF demos we have to preserve the buggy behavior.
; 3621 : 	*  Fun. We restore its previous value unless we're in a Boom/MBF demo.
; 3622 : 	*/
; 3623 : 	tmthing = saved_tmthing;

  001f4	8b 45 e0	 mov	 eax, DWORD PTR _saved_tmthing$[ebp]
  001f7	a3 00 00 00 00	 mov	 DWORD PTR _tmthing, eax

; 3624 : 
; 3625 : 	/* And, duh, the same for tmx/y - cph 2002/09/22
; 3626 : 	* And for tmbbox - cph 2003/08/10 */
; 3627 : 	tmx = saved_tmx, tmy = saved_tmy;

  001fc	8b 45 dc	 mov	 eax, DWORD PTR _saved_tmx$[ebp]
  001ff	a3 00 00 00 00	 mov	 DWORD PTR _tmx, eax
  00204	8b 4d d8	 mov	 ecx, DWORD PTR _saved_tmy$[ebp]
  00207	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmy, ecx

; 3628 : 
; 3629 : 	if (tmthing)

  0020d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmthing, 0
  00214	74 6f		 je	 SHORT $LN15@P_CreateSe

; 3630 : 	{
; 3631 : 		tmbbox[BOXTOP]  = tmy + tmthing->radius;

  00216	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0021b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmy
  00221	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  00224	ba 04 00 00 00	 mov	 edx, 4
  00229	6b c2 00	 imul	 eax, edx, 0
  0022c	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 3632 : 		tmbbox[BOXBOTTOM] = tmy - tmthing->radius;

  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmy
  0023d	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00240	ba 04 00 00 00	 mov	 edx, 4
  00245	c1 e2 00	 shl	 edx, 0
  00248	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 3633 : 		tmbbox[BOXRIGHT]  = tmx + tmthing->radius;

  0024e	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00253	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmx
  00259	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  0025c	ba 04 00 00 00	 mov	 edx, 4
  00261	6b c2 03	 imul	 eax, edx, 3
  00264	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 3634 : 		tmbbox[BOXLEFT]   = tmx - tmthing->radius;

  0026a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmx
  00275	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00278	ba 04 00 00 00	 mov	 edx, 4
  0027d	d1 e2		 shl	 edx, 1
  0027f	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx
$LN15@P_CreateSe:

; 3635 : 	}
; 3636 : }

  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
  00287	5b		 pop	 ebx
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
_P_CreateSecNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_DelPrecipSeclist
_TEXT	SEGMENT
_node$ = 8						; size = 4
_P_DelPrecipSeclist PROC				; COMDAT

; 3480 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@P_DelPreci:

; 3481 : 	while (node)

  00009	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  0000d	74 11		 je	 SHORT $LN3@P_DelPreci

; 3482 : 		node = P_DelPrecipSecnode(node);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _P_DelPrecipSecnode
  00018	83 c4 04	 add	 esp, 4
  0001b	89 45 08	 mov	 DWORD PTR _node$[ebp], eax
  0001e	eb e9		 jmp	 SHORT $LN2@P_DelPreci
$LN3@P_DelPreci:

; 3483 : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_P_DelPrecipSeclist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_DelSeclist
_TEXT	SEGMENT
_node$ = 8						; size = 4
_P_DelSeclist PROC					; COMDAT

; 3473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@P_DelSecli:

; 3474 : 	while (node)

  00009	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  0000d	74 11		 je	 SHORT $LN3@P_DelSecli

; 3475 : 		node = P_DelSecnode(node);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _P_DelSecnode
  00018	83 c4 04	 add	 esp, 4
  0001b	89 45 08	 mov	 DWORD PTR _node$[ebp], eax
  0001e	eb e9		 jmp	 SHORT $LN2@P_DelSecli
$LN3@P_DelSecli:

; 3476 : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_P_DelSeclist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CheckSector
_TEXT	SEGMENT
_sec$1 = -20						; size = 4
_i$2 = -16						; size = 4
_sec$3 = -12						; size = 4
_i$4 = -8						; size = 4
_n$ = -4						; size = 4
_sector$ = 8						; size = 4
_crunch$ = 12						; size = 4
_P_CheckSector PROC					; COMDAT

; 3108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3109 : 	msecnode_t *n;
; 3110 : 
; 3111 : 	nofit = false;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nofit, 0

; 3112 : 	crushchange = crunch;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _crunch$[ebp]
  00016	a3 00 00 00 00	 mov	 DWORD PTR _crushchange, eax

; 3113 : 
; 3114 : 	// killough 4/4/98: scan list front-to-back until empty or exhausted,
; 3115 : 	// restarting from beginning after each thing is processed. Avoids
; 3116 : 	// crashes, and is sure to examine all things in the sector, and only
; 3117 : 	// the things which are in the sector, until a steady-state is reached.
; 3118 : 	// Things can arbitrarily be inserted and removed and it won't mess up.
; 3119 : 	//
; 3120 : 	// killough 4/7/98: simplified to avoid using complicated counter
; 3121 : 
; 3122 : 
; 3123 : 	// First, let's see if anything will keep it from crushing.
; 3124 : 	if (sector->numattached)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0001e	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00025	0f 84 0f 01 00
	00		 je	 $LN3@P_CheckSec

; 3125 : 	{
; 3126 : 		size_t i;
; 3127 : 		sector_t *sec;
; 3128 : 		for (i = 0; i < sector->numattached; i++)

  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN4@P_CheckSec
$LN2@P_CheckSec:
  00034	8b 45 f8	 mov	 eax, DWORD PTR _i$4[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 f8	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@P_CheckSec:
  0003d	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _i$4[ebp]
  00043	3b 88 9c 00 00
	00		 cmp	 ecx, DWORD PTR [eax+156]
  00049	0f 83 eb 00 00
	00		 jae	 $LN3@P_CheckSec

; 3129 : 		{
; 3130 : 			sec = &sectors[sector->attached[i]];

  0004f	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00052	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00058	8b 55 f8	 mov	 edx, DWORD PTR _i$4[ebp]
  0005b	69 04 91 f8 00
	00 00		 imul	 eax, DWORD PTR [ecx+edx*4], 248
  00062	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  00068	89 45 f4	 mov	 DWORD PTR _sec$3[ebp], eax

; 3131 : 			for (n = sec->touching_thinglist; n; n = n->m_snext)

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _sec$3[ebp]
  0006e	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00074	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  00077	eb 09		 jmp	 SHORT $LN7@P_CheckSec
$LN5@P_CheckSec:
  00079	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0007c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0007f	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN7@P_CheckSec:
  00082	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00086	74 0c		 je	 SHORT $LN6@P_CheckSec

; 3132 : 				n->visited = false;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0008b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00092	eb e5		 jmp	 SHORT $LN5@P_CheckSec
$LN6@P_CheckSec:

; 3133 : 
; 3134 : 			sec->moved = true;

  00094	8b 45 f4	 mov	 eax, DWORD PTR _sec$3[ebp]
  00097	c7 80 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+172], 1

; 3135 : 
; 3136 : 			P_RecalcPrecipInSector(sec);

  000a1	8b 45 f4	 mov	 eax, DWORD PTR _sec$3[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _P_RecalcPrecipInSector
  000aa	83 c4 04	 add	 esp, 4

; 3137 : 
; 3138 : 			if (!sector->attachedsolid[i])

  000ad	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  000b0	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _i$4[ebp]
  000b9	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  000bd	75 05		 jne	 SHORT $LN45@P_CheckSec

; 3139 : 				continue;

  000bf	e9 70 ff ff ff	 jmp	 $LN2@P_CheckSec
$LN45@P_CheckSec:

; 3140 : 
; 3141 : 			do
; 3142 : 			{
; 3143 : 				for (n = sec->touching_thinglist; n; n = n->m_snext)

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _sec$3[ebp]
  000c7	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000cd	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  000d0	eb 09		 jmp	 SHORT $LN13@P_CheckSec
$LN11@P_CheckSec:
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000d5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d8	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN13@P_CheckSec:
  000db	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  000df	74 4e		 je	 SHORT $LN12@P_CheckSec

; 3144 : 				if (!n->visited)

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000e4	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000e8	75 43		 jne	 SHORT $LN46@P_CheckSec

; 3145 : 				{
; 3146 : 					n->visited = true;

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000ed	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 3147 : 					if (!(n->m_thing->flags & MF_NOBLOCKMAP))

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fa	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000fd	83 e2 10	 and	 edx, 16			; 00000010H
  00100	75 29		 jne	 SHORT $LN48@P_CheckSec

; 3148 : 					{
; 3149 : 						if (!PIT_ChangeSector(n->m_thing, false))

  00102	6a 00		 push	 0
  00104	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00107	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 _PIT_ChangeSector
  00110	83 c4 08	 add	 esp, 8
  00113	85 c0		 test	 eax, eax
  00115	75 14		 jne	 SHORT $LN48@P_CheckSec

; 3150 : 						{
; 3151 : 							nofit = true;

  00117	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nofit, 1

; 3152 : 							return nofit;

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _nofit
  00126	e9 62 02 00 00	 jmp	 $LN1@P_CheckSec
$LN48@P_CheckSec:

; 3153 : 						}
; 3154 : 					}
; 3155 : 					break;

  0012b	eb 02		 jmp	 SHORT $LN12@P_CheckSec
$LN46@P_CheckSec:

; 3156 : 				}

  0012d	eb a3		 jmp	 SHORT $LN11@P_CheckSec
$LN12@P_CheckSec:

; 3157 : 			} while (n);

  0012f	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00133	75 8f		 jne	 SHORT $LN45@P_CheckSec

; 3158 : 		}

  00135	e9 fa fe ff ff	 jmp	 $LN2@P_CheckSec
$LN3@P_CheckSec:

; 3159 : 	}
; 3160 : 
; 3161 : 	// Mark all things invalid
; 3162 : 	sector->moved = true;

  0013a	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0013d	c7 80 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+172], 1

; 3163 : 
; 3164 : 	for (n = sector->touching_thinglist; n; n = n->m_snext)

  00147	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0014a	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00150	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  00153	eb 09		 jmp	 SHORT $LN16@P_CheckSec
$LN14@P_CheckSec:
  00155	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00158	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015b	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN16@P_CheckSec:
  0015e	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00162	74 0c		 je	 SHORT $LN15@P_CheckSec

; 3165 : 		n->visited = false;

  00164	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00167	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  0016e	eb e5		 jmp	 SHORT $LN14@P_CheckSec
$LN15@P_CheckSec:

; 3166 : 
; 3167 : 	do
; 3168 : 	{
; 3169 : 		for (n = sector->touching_thinglist; n; n = n->m_snext) // go through list

  00170	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00173	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00179	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  0017c	eb 09		 jmp	 SHORT $LN22@P_CheckSec
$LN20@P_CheckSec:
  0017e	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00181	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00184	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN22@P_CheckSec:
  00187	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  0018b	74 4e		 je	 SHORT $LN21@P_CheckSec

; 3170 : 			if (!n->visited) // unprocessed thing found

  0018d	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00190	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00194	75 43		 jne	 SHORT $LN49@P_CheckSec

; 3171 : 			{
; 3172 : 				n->visited = true; // mark thing as processed

  00196	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00199	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 3173 : 				if (!(n->m_thing->flags & MF_NOBLOCKMAP)) //jff 4/7/98 don't do these

  001a0	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  001a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a6	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  001a9	83 e2 10	 and	 edx, 16			; 00000010H
  001ac	75 29		 jne	 SHORT $LN51@P_CheckSec

; 3174 : 				{
; 3175 : 					if (!PIT_ChangeSector(n->m_thing, false)) // process it

  001ae	6a 00		 push	 0
  001b0	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  001b3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b6	51		 push	 ecx
  001b7	e8 00 00 00 00	 call	 _PIT_ChangeSector
  001bc	83 c4 08	 add	 esp, 8
  001bf	85 c0		 test	 eax, eax
  001c1	75 14		 jne	 SHORT $LN51@P_CheckSec

; 3176 : 					{
; 3177 : 						nofit = true;

  001c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nofit, 1

; 3178 : 						return nofit;

  001cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _nofit
  001d2	e9 b6 01 00 00	 jmp	 $LN1@P_CheckSec
$LN51@P_CheckSec:

; 3179 : 					}
; 3180 : 				}
; 3181 : 				break; // exit and start over

  001d7	eb 02		 jmp	 SHORT $LN21@P_CheckSec
$LN49@P_CheckSec:

; 3182 : 			}

  001d9	eb a3		 jmp	 SHORT $LN20@P_CheckSec
$LN21@P_CheckSec:

; 3183 : 	} while (n); // repeat from scratch until all things left are marked valid

  001db	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  001df	75 8f		 jne	 SHORT $LN15@P_CheckSec

; 3184 : 
; 3185 : 	// Nothing blocked us, so lets crush for real!
; 3186 : 	if (sector->numattached)

  001e1	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  001e4	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  001eb	0f 84 01 01 00
	00		 je	 $LN24@P_CheckSec

; 3187 : 	{
; 3188 : 		size_t i;
; 3189 : 		sector_t *sec;
; 3190 : 		for (i = 0; i < sector->numattached; i++)

  001f1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  001f8	eb 09		 jmp	 SHORT $LN25@P_CheckSec
$LN23@P_CheckSec:
  001fa	8b 45 f0	 mov	 eax, DWORD PTR _i$2[ebp]
  001fd	83 c0 01	 add	 eax, 1
  00200	89 45 f0	 mov	 DWORD PTR _i$2[ebp], eax
$LN25@P_CheckSec:
  00203	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00206	8b 4d f0	 mov	 ecx, DWORD PTR _i$2[ebp]
  00209	3b 88 9c 00 00
	00		 cmp	 ecx, DWORD PTR [eax+156]
  0020f	0f 83 dd 00 00
	00		 jae	 $LN24@P_CheckSec

; 3191 : 		{
; 3192 : 			sec = &sectors[sector->attached[i]];

  00215	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00218	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  0021e	8b 55 f0	 mov	 edx, DWORD PTR _i$2[ebp]
  00221	69 04 91 f8 00
	00 00		 imul	 eax, DWORD PTR [ecx+edx*4], 248
  00228	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sectors
  0022e	89 45 ec	 mov	 DWORD PTR _sec$1[ebp], eax

; 3193 : 			for (n = sec->touching_thinglist; n; n = n->m_snext)

  00231	8b 45 ec	 mov	 eax, DWORD PTR _sec$1[ebp]
  00234	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  0023a	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  0023d	eb 09		 jmp	 SHORT $LN28@P_CheckSec
$LN26@P_CheckSec:
  0023f	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00242	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00245	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN28@P_CheckSec:
  00248	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  0024c	74 0c		 je	 SHORT $LN27@P_CheckSec

; 3194 : 				n->visited = false;

  0024e	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00251	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00258	eb e5		 jmp	 SHORT $LN26@P_CheckSec
$LN27@P_CheckSec:

; 3195 : 
; 3196 : 			sec->moved = true;

  0025a	8b 45 ec	 mov	 eax, DWORD PTR _sec$1[ebp]
  0025d	c7 80 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+172], 1

; 3197 : 
; 3198 : 			P_RecalcPrecipInSector(sec);

  00267	8b 45 ec	 mov	 eax, DWORD PTR _sec$1[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _P_RecalcPrecipInSector
  00270	83 c4 04	 add	 esp, 4

; 3199 : 
; 3200 : 			if (!sector->attachedsolid[i])

  00273	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00276	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  0027c	8b 55 f0	 mov	 edx, DWORD PTR _i$2[ebp]
  0027f	83 3c 91 00	 cmp	 DWORD PTR [ecx+edx*4], 0
  00283	75 05		 jne	 SHORT $LN53@P_CheckSec

; 3201 : 				continue;

  00285	e9 70 ff ff ff	 jmp	 $LN23@P_CheckSec
$LN53@P_CheckSec:

; 3202 : 
; 3203 : 			do
; 3204 : 			{
; 3205 : 				for (n = sec->touching_thinglist; n; n = n->m_snext)

  0028a	8b 45 ec	 mov	 eax, DWORD PTR _sec$1[ebp]
  0028d	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00293	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  00296	eb 09		 jmp	 SHORT $LN34@P_CheckSec
$LN32@P_CheckSec:
  00298	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0029b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0029e	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN34@P_CheckSec:
  002a1	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  002a5	74 40		 je	 SHORT $LN33@P_CheckSec

; 3206 : 				if (!n->visited)

  002a7	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002aa	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  002ae	75 35		 jne	 SHORT $LN54@P_CheckSec

; 3207 : 				{
; 3208 : 					n->visited = true;

  002b0	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002b3	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 3209 : 					if (!(n->m_thing->flags & MF_NOBLOCKMAP))

  002ba	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002c0	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  002c3	83 e2 10	 and	 edx, 16			; 00000010H
  002c6	75 1b		 jne	 SHORT $LN55@P_CheckSec

; 3210 : 					{
; 3211 : 						PIT_ChangeSector(n->m_thing, true);

  002c8	6a 01		 push	 1
  002ca	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002cd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002d0	51		 push	 ecx
  002d1	e8 00 00 00 00	 call	 _PIT_ChangeSector
  002d6	83 c4 08	 add	 esp, 8

; 3212 : 						return nofit;

  002d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _nofit
  002de	e9 aa 00 00 00	 jmp	 $LN1@P_CheckSec
$LN55@P_CheckSec:

; 3213 : 					}
; 3214 : 					break;

  002e3	eb 02		 jmp	 SHORT $LN33@P_CheckSec
$LN54@P_CheckSec:

; 3215 : 				}

  002e5	eb b1		 jmp	 SHORT $LN32@P_CheckSec
$LN33@P_CheckSec:

; 3216 : 			} while (n);

  002e7	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  002eb	75 9d		 jne	 SHORT $LN53@P_CheckSec

; 3217 : 		}

  002ed	e9 08 ff ff ff	 jmp	 $LN23@P_CheckSec
$LN24@P_CheckSec:

; 3218 : 	}
; 3219 : 
; 3220 : 	// Mark all things invalid
; 3221 : 	sector->moved = true;

  002f2	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  002f5	c7 80 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+172], 1

; 3222 : 
; 3223 : 	for (n = sector->touching_thinglist; n; n = n->m_snext)

  002ff	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  00302	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00308	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  0030b	eb 09		 jmp	 SHORT $LN37@P_CheckSec
$LN35@P_CheckSec:
  0030d	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00310	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00313	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN37@P_CheckSec:
  00316	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  0031a	74 0c		 je	 SHORT $LN36@P_CheckSec

; 3224 : 		n->visited = false;

  0031c	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0031f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00326	eb e5		 jmp	 SHORT $LN35@P_CheckSec
$LN36@P_CheckSec:

; 3225 : 
; 3226 : 	do
; 3227 : 	{
; 3228 : 		for (n = sector->touching_thinglist; n; n = n->m_snext) // go through list

  00328	8b 45 08	 mov	 eax, DWORD PTR _sector$[ebp]
  0032b	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00331	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  00334	eb 09		 jmp	 SHORT $LN43@P_CheckSec
$LN41@P_CheckSec:
  00336	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00339	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0033c	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
$LN43@P_CheckSec:
  0033f	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00343	74 3d		 je	 SHORT $LN42@P_CheckSec

; 3229 : 			if (!n->visited) // unprocessed thing found

  00345	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00348	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0034c	75 32		 jne	 SHORT $LN56@P_CheckSec

; 3230 : 			{
; 3231 : 				n->visited = true; // mark thing as processed

  0034e	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00351	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 3232 : 				if (!(n->m_thing->flags & MF_NOBLOCKMAP)) //jff 4/7/98 don't do these

  00358	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0035b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0035e	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00361	83 e2 10	 and	 edx, 16			; 00000010H
  00364	75 18		 jne	 SHORT $LN57@P_CheckSec

; 3233 : 				{
; 3234 : 					PIT_ChangeSector(n->m_thing, true); // process it

  00366	6a 01		 push	 1
  00368	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0036b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0036e	51		 push	 ecx
  0036f	e8 00 00 00 00	 call	 _PIT_ChangeSector
  00374	83 c4 08	 add	 esp, 8

; 3235 : 					return nofit;

  00377	a1 00 00 00 00	 mov	 eax, DWORD PTR _nofit
  0037c	eb 0f		 jmp	 SHORT $LN1@P_CheckSec
$LN57@P_CheckSec:

; 3236 : 				}
; 3237 : 				break; // exit and start over

  0037e	eb 02		 jmp	 SHORT $LN42@P_CheckSec
$LN56@P_CheckSec:

; 3238 : 			}

  00380	eb b4		 jmp	 SHORT $LN41@P_CheckSec
$LN42@P_CheckSec:

; 3239 : 	} while (n); // repeat from scratch until all things left are marked valid

  00382	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00386	75 a0		 jne	 SHORT $LN36@P_CheckSec

; 3240 : 
; 3241 : 	return nofit;

  00388	a1 00 00 00 00	 mov	 eax, DWORD PTR _nofit
$LN1@P_CheckSec:

; 3242 : }

  0038d	5f		 pop	 edi
  0038e	5e		 pop	 esi
  0038f	5b		 pop	 ebx
  00390	8b e5		 mov	 esp, ebp
  00392	5d		 pop	 ebp
  00393	c3		 ret	 0
_P_CheckSector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CheckHoopPosition
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hoopthing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_radius$ = 24						; size = 4
_P_CheckHoopPosition PROC				; COMDAT

; 1200 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1201 : 	INT32 i;
; 1202 : 
; 1203 : 	for (i = 0; i < MAXPLAYERS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@P_CheckHoo
$LN2@P_CheckHoo:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@P_CheckHoo:
  0001b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0001f	0f 8d b9 00 00
	00		 jge	 $LN3@P_CheckHoo

; 1204 : 	{
; 1205 : 		if (!playeringame[i] || !players[i].mo)

  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  00030	74 10		 je	 SHORT $LN6@P_CheckHoo
  00032	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00039	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00040	75 02		 jne	 SHORT $LN5@P_CheckHoo
$LN6@P_CheckHoo:

; 1206 : 			continue;

  00042	eb ce		 jmp	 SHORT $LN2@P_CheckHoo
$LN5@P_CheckHoo:

; 1207 : 
; 1208 : 		if (abs(players[i].mo->x - x) >= hoopblockdist ||
; 1209 : 			abs(players[i].mo->y - y) >= hoopblockdist ||

  00044	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0004b	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00051	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00054	2b 55 0c	 sub	 edx, DWORD PTR _x$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _abs
  0005d	83 c4 04	 add	 esp, 4
  00060	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _hoopblockdist
  00066	7d 4e		 jge	 SHORT $LN8@P_CheckHoo
  00068	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  0006f	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00075	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00078	2b 55 10	 sub	 edx, DWORD PTR _y$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _abs
  00081	83 c4 04	 add	 esp, 4
  00084	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _hoopblockdist
  0008a	7d 2a		 jge	 SHORT $LN8@P_CheckHoo
  0008c	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  00093	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  00099	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0009c	03 15 00 00 00
	00		 add	 edx, DWORD PTR _hoophalfheight
  000a2	2b 55 14	 sub	 edx, DWORD PTR _z$[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _abs
  000ab	83 c4 04	 add	 esp, 4
  000ae	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _hoopblockdist
  000b4	7c 05		 jl	 SHORT $LN7@P_CheckHoo
$LN8@P_CheckHoo:

; 1210 : 			abs((players[i].mo->z+hoophalfheight) - z) >= hoopblockdist)
; 1211 : 			continue; // didn't hit it

  000b6	e9 57 ff ff ff	 jmp	 $LN2@P_CheckHoo
$LN7@P_CheckHoo:

; 1212 : 
; 1213 : 		// can remove thing
; 1214 : 		P_TouchSpecialThing(hoopthing, players[i].mo, false);

  000bb	6a 00		 push	 0
  000bd	69 45 fc fc 01
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 508
  000c4	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000ca	51		 push	 ecx
  000cb	8b 55 08	 mov	 edx, DWORD PTR _hoopthing$[ebp]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _P_TouchSpecialThing
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1215 : 		break;

  000d7	eb 05		 jmp	 SHORT $LN3@P_CheckHoo

; 1216 : 	}

  000d9	e9 34 ff ff ff	 jmp	 $LN2@P_CheckHoo
$LN3@P_CheckHoo:

; 1217 : 
; 1218 : 	radius = 0; //unused

  000de	c7 45 18 00 00
	00 00		 mov	 DWORD PTR _radius$[ebp], 0

; 1219 : 	return;
; 1220 : }

  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_P_CheckHoopPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_BounceMove
_TEXT	SEGMENT
_mmomy$ = -36						; size = 4
_mmomx$ = -32						; size = 4
_hitcount$ = -28					; size = 4
_newy$ = -24						; size = 4
_newx$ = -20						; size = 4
_traily$ = -16						; size = 4
_trailx$ = -12						; size = 4
_leady$ = -8						; size = 4
_leadx$ = -4						; size = 4
_mo$ = 8						; size = 4
_P_BounceMove PROC					; COMDAT

; 2530 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2531 : 	fixed_t leadx, leady;
; 2532 : 	fixed_t trailx, traily;
; 2533 : 	fixed_t newx, newy;
; 2534 : 	INT32 hitcount;
; 2535 : 	fixed_t mmomx = 0, mmomy = 0;

  00009	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _mmomx$[ebp], 0
  00010	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _mmomy$[ebp], 0

; 2536 : 
; 2537 : 	slidemo = mo;

  00017	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0001a	a3 00 00 00 00	 mov	 DWORD PTR _slidemo, eax

; 2538 : 	hitcount = 0;

  0001f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hitcount$[ebp], 0
$retry$23:

; 2539 : 
; 2540 : retry:
; 2541 : 	if (++hitcount == 3)

  00026	8b 45 e4	 mov	 eax, DWORD PTR _hitcount$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 e4	 mov	 DWORD PTR _hitcount$[ebp], eax
  0002f	83 7d e4 03	 cmp	 DWORD PTR _hitcount$[ebp], 3
  00033	75 05		 jne	 SHORT $LN2@P_BounceMo

; 2542 : 		goto bounceback; // don't loop forever

  00035	e9 5b 01 00 00	 jmp	 $bounceback$24
$LN2@P_BounceMo:

; 2543 : 
; 2544 : 	if (mo->player)

  0003a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0003d	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00044	74 26		 je	 SHORT $LN3@P_BounceMo

; 2545 : 	{
; 2546 : 		mmomx = mo->player->rmomx;

  00046	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00049	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0004f	8b 91 44 01 00
	00		 mov	 edx, DWORD PTR [ecx+324]
  00055	89 55 e0	 mov	 DWORD PTR _mmomx$[ebp], edx

; 2547 : 		mmomy = mo->player->rmomy;

  00058	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0005b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00061	8b 91 48 01 00
	00		 mov	 edx, DWORD PTR [ecx+328]
  00067	89 55 dc	 mov	 DWORD PTR _mmomy$[ebp], edx

; 2548 : 	}

  0006a	eb 12		 jmp	 SHORT $LN4@P_BounceMo
$LN3@P_BounceMo:

; 2549 : 	else
; 2550 : 	{
; 2551 : 		mmomx = mo->momx;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0006f	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00072	89 4d e0	 mov	 DWORD PTR _mmomx$[ebp], ecx

; 2552 : 		mmomy = mo->momy;

  00075	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00078	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0007b	89 4d dc	 mov	 DWORD PTR _mmomy$[ebp], ecx
$LN4@P_BounceMo:

; 2553 : 	}
; 2554 : 
; 2555 : 	// trace along the three leading corners
; 2556 : 	if (mo->momx > 0)

  0007e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00081	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00085	7e 20		 jle	 SHORT $LN5@P_BounceMo

; 2557 : 	{
; 2558 : 		leadx = mo->x + mo->radius;

  00087	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0008a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0008d	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00090	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00093	89 4d fc	 mov	 DWORD PTR _leadx$[ebp], ecx

; 2559 : 		trailx = mo->x - mo->radius;

  00096	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  0009c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0009f	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000a2	89 55 f4	 mov	 DWORD PTR _trailx$[ebp], edx

; 2560 : 	}

  000a5	eb 1e		 jmp	 SHORT $LN6@P_BounceMo
$LN5@P_BounceMo:

; 2561 : 	else
; 2562 : 	{
; 2563 : 		leadx = mo->x - mo->radius;

  000a7	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  000ad	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000b0	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000b3	89 55 fc	 mov	 DWORD PTR _leadx$[ebp], edx

; 2564 : 		trailx = mo->x + mo->radius;

  000b6	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000b9	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000bc	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  000bf	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  000c2	89 4d f4	 mov	 DWORD PTR _trailx$[ebp], ecx
$LN6@P_BounceMo:

; 2565 : 	}
; 2566 : 
; 2567 : 	if (mo->momy > 0)

  000c5	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000c8	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000cc	7e 20		 jle	 SHORT $LN7@P_BounceMo

; 2568 : 	{
; 2569 : 		leady = mo->y + mo->radius;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000d1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d4	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  000d7	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  000da	89 4d f8	 mov	 DWORD PTR _leady$[ebp], ecx

; 2570 : 		traily = mo->y - mo->radius;

  000dd	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  000e3	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000e6	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000e9	89 55 f0	 mov	 DWORD PTR _traily$[ebp], edx

; 2571 : 	}

  000ec	eb 1e		 jmp	 SHORT $LN8@P_BounceMo
$LN7@P_BounceMo:

; 2572 : 	else
; 2573 : 	{
; 2574 : 		leady = mo->y - mo->radius;

  000ee	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  000f4	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000f7	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000fa	89 55 f8	 mov	 DWORD PTR _leady$[ebp], edx

; 2575 : 		traily = mo->y + mo->radius;

  000fd	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00100	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00103	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00106	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00109	89 4d f0	 mov	 DWORD PTR _traily$[ebp], ecx
$LN8@P_BounceMo:

; 2576 : 	}
; 2577 : 
; 2578 : 	bestslidefrac = FRACUNIT + 1;

  0010c	c7 05 00 00 00
	00 01 00 01 00	 mov	 DWORD PTR _bestslidefrac, 65537 ; 00010001H

; 2579 : 
; 2580 : 	P_PathTraverse(leadx, leady, leadx + mmomx, leady + mmomy, PT_ADDLINES, PTR_SlideTraverse);

  00116	68 00 00 00 00	 push	 OFFSET _PTR_SlideTraverse
  0011b	6a 01		 push	 1
  0011d	8b 45 f8	 mov	 eax, DWORD PTR _leady$[ebp]
  00120	03 45 dc	 add	 eax, DWORD PTR _mmomy$[ebp]
  00123	50		 push	 eax
  00124	8b 4d fc	 mov	 ecx, DWORD PTR _leadx$[ebp]
  00127	03 4d e0	 add	 ecx, DWORD PTR _mmomx$[ebp]
  0012a	51		 push	 ecx
  0012b	8b 55 f8	 mov	 edx, DWORD PTR _leady$[ebp]
  0012e	52		 push	 edx
  0012f	8b 45 fc	 mov	 eax, DWORD PTR _leadx$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _P_PathTraverse
  00138	83 c4 18	 add	 esp, 24			; 00000018H

; 2581 : 	P_PathTraverse(trailx, leady, trailx + mmomx, leady + mmomy, PT_ADDLINES, PTR_SlideTraverse);

  0013b	68 00 00 00 00	 push	 OFFSET _PTR_SlideTraverse
  00140	6a 01		 push	 1
  00142	8b 45 f8	 mov	 eax, DWORD PTR _leady$[ebp]
  00145	03 45 dc	 add	 eax, DWORD PTR _mmomy$[ebp]
  00148	50		 push	 eax
  00149	8b 4d f4	 mov	 ecx, DWORD PTR _trailx$[ebp]
  0014c	03 4d e0	 add	 ecx, DWORD PTR _mmomx$[ebp]
  0014f	51		 push	 ecx
  00150	8b 55 f8	 mov	 edx, DWORD PTR _leady$[ebp]
  00153	52		 push	 edx
  00154	8b 45 f4	 mov	 eax, DWORD PTR _trailx$[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 _P_PathTraverse
  0015d	83 c4 18	 add	 esp, 24			; 00000018H

; 2582 : 	P_PathTraverse(leadx, traily, leadx + mmomx, traily + mmomy, PT_ADDLINES, PTR_SlideTraverse);

  00160	68 00 00 00 00	 push	 OFFSET _PTR_SlideTraverse
  00165	6a 01		 push	 1
  00167	8b 45 f0	 mov	 eax, DWORD PTR _traily$[ebp]
  0016a	03 45 dc	 add	 eax, DWORD PTR _mmomy$[ebp]
  0016d	50		 push	 eax
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _leadx$[ebp]
  00171	03 4d e0	 add	 ecx, DWORD PTR _mmomx$[ebp]
  00174	51		 push	 ecx
  00175	8b 55 f0	 mov	 edx, DWORD PTR _traily$[ebp]
  00178	52		 push	 edx
  00179	8b 45 fc	 mov	 eax, DWORD PTR _leadx$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _P_PathTraverse
  00182	83 c4 18	 add	 esp, 24			; 00000018H

; 2583 : 
; 2584 : 	// move up to the wall
; 2585 : 	if (bestslidefrac == FRACUNIT + 1)

  00185	81 3d 00 00 00
	00 01 00 01 00	 cmp	 DWORD PTR _bestslidefrac, 65537 ; 00010001H
  0018f	0f 85 23 01 00
	00		 jne	 $LN9@P_BounceMo
$bounceback$24:

; 2586 : 	{
; 2587 : 		// the move must have hit the middle, so bounce straight back
; 2588 : bounceback:
; 2589 : 		if (P_TryMove(mo, mo->x - mmomx, mo->y - mmomy, true))

  00195	6a 01		 push	 1
  00197	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0019a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0019d	2b 4d dc	 sub	 ecx, DWORD PTR _mmomy$[ebp]
  001a0	51		 push	 ecx
  001a1	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001a4	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001a7	2b 45 e0	 sub	 eax, DWORD PTR _mmomx$[ebp]
  001aa	50		 push	 eax
  001ab	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 _P_TryMove
  001b4	83 c4 10	 add	 esp, 16			; 00000010H
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 f4 00 00
	00		 je	 $LN11@P_BounceMo

; 2590 : 		{
; 2591 : 			mo->momx *= -1;

  001bf	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001c2	6b 48 48 ff	 imul	 ecx, DWORD PTR [eax+72], -1
  001c6	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001c9	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 2592 : 			mo->momy *= -1;

  001cc	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001cf	6b 48 4c ff	 imul	 ecx, DWORD PTR [eax+76], -1
  001d3	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001d6	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 2593 : 			mo->momx = FixedMul(mo->momx, (FRACUNIT - (FRACUNIT>>2) - (FRACUNIT>>3)));

  001d9	68 00 a0 00 00	 push	 40960			; 0000a000H
  001de	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001e1	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  001e4	51		 push	 ecx
  001e5	e8 00 00 00 00	 call	 _FixedMul
  001ea	83 c4 08	 add	 esp, 8
  001ed	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001f0	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 2594 : 			mo->momy = FixedMul(mo->momy, (FRACUNIT - (FRACUNIT>>2) - (FRACUNIT>>3)));

  001f3	68 00 a0 00 00	 push	 40960			; 0000a000H
  001f8	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001fb	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  001fe	51		 push	 ecx
  001ff	e8 00 00 00 00	 call	 _FixedMul
  00204	83 c4 08	 add	 esp, 8
  00207	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0020a	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 2595 : 
; 2596 : 			if (mo->player)

  0020d	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00210	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00217	0f 84 96 00 00
	00		 je	 $LN11@P_BounceMo

; 2597 : 			{
; 2598 : 				mo->player->cmomx *= -1;

  0021d	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00220	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00226	6b 91 3c 01 00
	00 ff		 imul	 edx, DWORD PTR [ecx+316], -1
  0022d	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00230	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00236	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 2599 : 				mo->player->cmomy *= -1;

  0023c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0023f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00245	6b 91 40 01 00
	00 ff		 imul	 edx, DWORD PTR [ecx+320], -1
  0024c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0024f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00255	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx

; 2600 : 				mo->player->cmomx = FixedMul(mo->player->cmomx,

  0025b	68 00 a0 00 00	 push	 40960			; 0000a000H
  00260	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00263	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00269	8b 91 3c 01 00
	00		 mov	 edx, DWORD PTR [ecx+316]
  0026f	52		 push	 edx
  00270	e8 00 00 00 00	 call	 _FixedMul
  00275	83 c4 08	 add	 esp, 8
  00278	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  0027b	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00281	89 82 3c 01 00
	00		 mov	 DWORD PTR [edx+316], eax

; 2601 : 					(FRACUNIT - (FRACUNIT>>2) - (FRACUNIT>>3)));
; 2602 : 				mo->player->cmomy = FixedMul(mo->player->cmomy,

  00287	68 00 a0 00 00	 push	 40960			; 0000a000H
  0028c	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0028f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00295	8b 91 40 01 00
	00		 mov	 edx, DWORD PTR [ecx+320]
  0029b	52		 push	 edx
  0029c	e8 00 00 00 00	 call	 _FixedMul
  002a1	83 c4 08	 add	 esp, 8
  002a4	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  002a7	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  002ad	89 82 40 01 00
	00		 mov	 DWORD PTR [edx+320], eax
$LN11@P_BounceMo:

; 2603 : 					(FRACUNIT - (FRACUNIT>>2) - (FRACUNIT>>3)));
; 2604 : 			}
; 2605 : 		}
; 2606 : 		return;

  002b3	e9 b2 01 00 00	 jmp	 $LN21@P_BounceMo
$LN9@P_BounceMo:

; 2607 : 	}
; 2608 : 
; 2609 : 	// fudge a bit to make sure it doesn't hit
; 2610 : 	bestslidefrac -= 0x800;

  002b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  002bd	2d 00 08 00 00	 sub	 eax, 2048		; 00000800H
  002c2	a3 00 00 00 00	 mov	 DWORD PTR _bestslidefrac, eax

; 2611 : 	if (bestslidefrac > 0)

  002c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslidefrac, 0
  002ce	7e 55		 jle	 SHORT $LN13@P_BounceMo

; 2612 : 	{
; 2613 : 		newx = FixedMul(mmomx, bestslidefrac);

  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  002d5	50		 push	 eax
  002d6	8b 4d e0	 mov	 ecx, DWORD PTR _mmomx$[ebp]
  002d9	51		 push	 ecx
  002da	e8 00 00 00 00	 call	 _FixedMul
  002df	83 c4 08	 add	 esp, 8
  002e2	89 45 ec	 mov	 DWORD PTR _newx$[ebp], eax

; 2614 : 		newy = FixedMul(mmomy, bestslidefrac);

  002e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  002ea	50		 push	 eax
  002eb	8b 4d dc	 mov	 ecx, DWORD PTR _mmomy$[ebp]
  002ee	51		 push	 ecx
  002ef	e8 00 00 00 00	 call	 _FixedMul
  002f4	83 c4 08	 add	 esp, 8
  002f7	89 45 e8	 mov	 DWORD PTR _newy$[ebp], eax

; 2615 : 
; 2616 : 		if (!P_TryMove(mo, mo->x + newx, mo->y + newy, true))

  002fa	6a 01		 push	 1
  002fc	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002ff	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00302	03 4d e8	 add	 ecx, DWORD PTR _newy$[ebp]
  00305	51		 push	 ecx
  00306	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00309	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0030c	03 45 ec	 add	 eax, DWORD PTR _newx$[ebp]
  0030f	50		 push	 eax
  00310	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00313	51		 push	 ecx
  00314	e8 00 00 00 00	 call	 _P_TryMove
  00319	83 c4 10	 add	 esp, 16			; 00000010H
  0031c	85 c0		 test	 eax, eax
  0031e	75 05		 jne	 SHORT $LN13@P_BounceMo

; 2617 : 			goto bounceback;

  00320	e9 70 fe ff ff	 jmp	 $bounceback$24
$LN13@P_BounceMo:

; 2618 : 	}
; 2619 : 
; 2620 : 	// Now continue along the wall.
; 2621 : 	// First calculate remainder.
; 2622 : 	bestslidefrac = FRACUNIT - bestslidefrac;

  00325	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  0032a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _bestslidefrac
  00330	a3 00 00 00 00	 mov	 DWORD PTR _bestslidefrac, eax

; 2623 : 
; 2624 : 	if (bestslidefrac > FRACUNIT)

  00335	81 3d 00 00 00
	00 00 00 01 00	 cmp	 DWORD PTR _bestslidefrac, 65536 ; 00010000H
  0033f	7e 0a		 jle	 SHORT $LN14@P_BounceMo

; 2625 : 		bestslidefrac = FRACUNIT;

  00341	c7 05 00 00 00
	00 00 00 01 00	 mov	 DWORD PTR _bestslidefrac, 65536 ; 00010000H
$LN14@P_BounceMo:

; 2626 : 
; 2627 : 	if (bestslidefrac <= 0)

  0034b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslidefrac, 0
  00352	7f 05		 jg	 SHORT $LN15@P_BounceMo

; 2628 : 		return;

  00354	e9 11 01 00 00	 jmp	 $LN21@P_BounceMo
$LN15@P_BounceMo:

; 2629 : 
; 2630 : 	if (mo->type == MT_SHELL)

  00359	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0035c	81 78 7c e8 00
	00 00		 cmp	 DWORD PTR [eax+124], 232 ; 000000e8H
  00363	75 12		 jne	 SHORT $LN16@P_BounceMo

; 2631 : 	{
; 2632 : 		tmxmove = mmomx;

  00365	8b 45 e0	 mov	 eax, DWORD PTR _mmomx$[ebp]
  00368	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 2633 : 		tmymove = mmomy;

  0036d	8b 45 dc	 mov	 eax, DWORD PTR _mmomy$[ebp]
  00370	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax

; 2634 : 	}

  00375	eb 66		 jmp	 SHORT $LN19@P_BounceMo
$LN16@P_BounceMo:

; 2635 : 	else if (mo->type == MT_THROWNBOUNCE)

  00377	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0037a	81 78 7c dc 00
	00 00		 cmp	 DWORD PTR [eax+124], 220 ; 000000dcH
  00381	75 2e		 jne	 SHORT $LN18@P_BounceMo

; 2636 : 	{
; 2637 : 		tmxmove = FixedMul(mmomx, (FRACUNIT - (FRACUNIT>>6) - (FRACUNIT>>5)));

  00383	68 00 f4 00 00	 push	 62464			; 0000f400H
  00388	8b 45 e0	 mov	 eax, DWORD PTR _mmomx$[ebp]
  0038b	50		 push	 eax
  0038c	e8 00 00 00 00	 call	 _FixedMul
  00391	83 c4 08	 add	 esp, 8
  00394	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 2638 : 		tmymove = FixedMul(mmomy, (FRACUNIT - (FRACUNIT>>6) - (FRACUNIT>>5)));

  00399	68 00 f4 00 00	 push	 62464			; 0000f400H
  0039e	8b 45 dc	 mov	 eax, DWORD PTR _mmomy$[ebp]
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 _FixedMul
  003a7	83 c4 08	 add	 esp, 8
  003aa	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax

; 2639 : 	}

  003af	eb 2c		 jmp	 SHORT $LN19@P_BounceMo
$LN18@P_BounceMo:

; 2640 : 	else
; 2641 : 	{
; 2642 : 		tmxmove = FixedMul(mmomx, (FRACUNIT - (FRACUNIT>>2) - (FRACUNIT>>3)));

  003b1	68 00 a0 00 00	 push	 40960			; 0000a000H
  003b6	8b 45 e0	 mov	 eax, DWORD PTR _mmomx$[ebp]
  003b9	50		 push	 eax
  003ba	e8 00 00 00 00	 call	 _FixedMul
  003bf	83 c4 08	 add	 esp, 8
  003c2	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 2643 : 		tmymove = FixedMul(mmomy, (FRACUNIT - (FRACUNIT>>2) - (FRACUNIT>>3)));

  003c7	68 00 a0 00 00	 push	 40960			; 0000a000H
  003cc	8b 45 dc	 mov	 eax, DWORD PTR _mmomy$[ebp]
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 _FixedMul
  003d5	83 c4 08	 add	 esp, 8
  003d8	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax
$LN19@P_BounceMo:

; 2644 : 	}
; 2645 : 
; 2646 : 	P_HitBounceLine(bestslideline); // clip the moves

  003dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslideline
  003e2	50		 push	 eax
  003e3	e8 00 00 00 00	 call	 _P_HitBounceLine
  003e8	83 c4 04	 add	 esp, 4

; 2647 : 
; 2648 : 	mo->momx = tmxmove;

  003eb	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  003ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  003f4	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 2649 : 	mo->momy = tmymove;

  003f7	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmymove
  00400	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 2650 : 
; 2651 : 	if (mo->player)

  00403	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00406	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0040d	74 2a		 je	 SHORT $LN20@P_BounceMo

; 2652 : 	{
; 2653 : 		mo->player->cmomx = tmxmove;

  0040f	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00412	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00418	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmxmove
  0041e	89 91 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], edx

; 2654 : 		mo->player->cmomy = tmymove;

  00424	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00427	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0042d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmymove
  00433	89 91 40 01 00
	00		 mov	 DWORD PTR [ecx+320], edx
$LN20@P_BounceMo:

; 2655 : 	}
; 2656 : 
; 2657 : 	if (!P_TryMove(mo, mo->x + tmxmove, mo->y + tmymove, true))

  00439	6a 01		 push	 1
  0043b	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0043e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00441	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _tmymove
  00447	51		 push	 ecx
  00448	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0044b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0044e	03 05 00 00 00
	00		 add	 eax, DWORD PTR _tmxmove
  00454	50		 push	 eax
  00455	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00458	51		 push	 ecx
  00459	e8 00 00 00 00	 call	 _P_TryMove
  0045e	83 c4 10	 add	 esp, 16			; 00000010H
  00461	85 c0		 test	 eax, eax
  00463	75 05		 jne	 SHORT $LN21@P_BounceMo

; 2658 : 		goto retry;

  00465	e9 bc fb ff ff	 jmp	 $retry$23
$LN21@P_BounceMo:

; 2659 : }

  0046a	5f		 pop	 edi
  0046b	5e		 pop	 esi
  0046c	5b		 pop	 ebx
  0046d	8b e5		 mov	 esp, ebp
  0046f	5d		 pop	 ebp
  00470	c3		 ret	 0
_P_BounceMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_SlideMove
_TEXT	SEGMENT
_hitcount$ = -28					; size = 2
_newy$ = -24						; size = 4
_newx$ = -20						; size = 4
_traily$ = -16						; size = 4
_trailx$ = -12						; size = 4
_leady$ = -8						; size = 4
_leadx$ = -4						; size = 4
_mo$ = 8						; size = 4
_P_SlideMove PROC					; COMDAT

; 2422 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2423 : 	fixed_t leadx, leady, trailx, traily, newx, newy;
; 2424 : 	INT16 hitcount = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 45 e4	 mov	 WORD PTR _hitcount$[ebp], ax

; 2425 : 
; 2426 : 	slidemo = mo;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00012	a3 00 00 00 00	 mov	 DWORD PTR _slidemo, eax

; 2427 : 
; 2428 : 	bestslideline = NULL;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bestslideline, 0
$retry$19:

; 2429 : 
; 2430 : retry:
; 2431 : 	if (++hitcount == 3)

  00021	66 8b 45 e4	 mov	 ax, WORD PTR _hitcount$[ebp]
  00025	66 83 c0 01	 add	 ax, 1
  00029	66 89 45 e4	 mov	 WORD PTR _hitcount$[ebp], ax
  0002d	0f bf 4d e4	 movsx	 ecx, WORD PTR _hitcount$[ebp]
  00031	83 f9 03	 cmp	 ecx, 3
  00034	75 05		 jne	 SHORT $LN2@P_SlideMov

; 2432 : 		goto stairstep; // don't loop forever

  00036	e9 50 01 00 00	 jmp	 $stairstep$20
$LN2@P_SlideMov:

; 2433 : 
; 2434 : 	// trace along the three leading corners
; 2435 : 	if (mo->momx > 0)

  0003b	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0003e	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00042	7e 20		 jle	 SHORT $LN3@P_SlideMov

; 2436 : 	{
; 2437 : 		leadx = mo->x + mo->radius;

  00044	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00047	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0004d	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00050	89 4d fc	 mov	 DWORD PTR _leadx$[ebp], ecx

; 2438 : 		trailx = mo->x - mo->radius;

  00053	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00059	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0005c	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  0005f	89 55 f4	 mov	 DWORD PTR _trailx$[ebp], edx

; 2439 : 	}

  00062	eb 1e		 jmp	 SHORT $LN4@P_SlideMov
$LN3@P_SlideMov:

; 2440 : 	else
; 2441 : 	{
; 2442 : 		leadx = mo->x - mo->radius;

  00064	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  0006a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0006d	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00070	89 55 fc	 mov	 DWORD PTR _leadx$[ebp], edx

; 2443 : 		trailx = mo->x + mo->radius;

  00073	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00076	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00079	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0007c	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  0007f	89 4d f4	 mov	 DWORD PTR _trailx$[ebp], ecx
$LN4@P_SlideMov:

; 2444 : 	}
; 2445 : 
; 2446 : 	if (mo->momy > 0)

  00082	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00085	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00089	7e 20		 jle	 SHORT $LN5@P_SlideMov

; 2447 : 	{
; 2448 : 		leady = mo->y + mo->radius;

  0008b	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0008e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00091	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00094	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  00097	89 4d f8	 mov	 DWORD PTR _leady$[ebp], ecx

; 2449 : 		traily = mo->y - mo->radius;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  000a0	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000a3	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000a6	89 55 f0	 mov	 DWORD PTR _traily$[ebp], edx

; 2450 : 	}

  000a9	eb 1e		 jmp	 SHORT $LN6@P_SlideMov
$LN5@P_SlideMov:

; 2451 : 	else
; 2452 : 	{
; 2453 : 		leady = mo->y - mo->radius;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  000b1	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000b4	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  000b7	89 55 f8	 mov	 DWORD PTR _leady$[ebp], edx

; 2454 : 		traily = mo->y + mo->radius;

  000ba	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000bd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c0	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  000c3	03 4a 40	 add	 ecx, DWORD PTR [edx+64]
  000c6	89 4d f0	 mov	 DWORD PTR _traily$[ebp], ecx
$LN6@P_SlideMov:

; 2455 : 	}
; 2456 : 
; 2457 : 	bestslidefrac = FRACUNIT+1;

  000c9	c7 05 00 00 00
	00 01 00 01 00	 mov	 DWORD PTR _bestslidefrac, 65537 ; 00010001H

; 2458 : 
; 2459 : 	P_PathTraverse(leadx, leady, leadx + mo->momx, leady + mo->momy,

  000d3	68 00 00 00 00	 push	 OFFSET _PTR_SlideTraverse
  000d8	6a 01		 push	 1
  000da	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  000e0	03 48 4c	 add	 ecx, DWORD PTR [eax+76]
  000e3	51		 push	 ecx
  000e4	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  000e7	8b 45 fc	 mov	 eax, DWORD PTR _leadx$[ebp]
  000ea	03 42 48	 add	 eax, DWORD PTR [edx+72]
  000ed	50		 push	 eax
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 55 fc	 mov	 edx, DWORD PTR _leadx$[ebp]
  000f5	52		 push	 edx
  000f6	e8 00 00 00 00	 call	 _P_PathTraverse
  000fb	83 c4 18	 add	 esp, 24			; 00000018H

; 2460 : 		PT_ADDLINES, PTR_SlideTraverse);
; 2461 : 	P_PathTraverse(trailx, leady, trailx + mo->momx, leady + mo->momy,

  000fe	68 00 00 00 00	 push	 OFFSET _PTR_SlideTraverse
  00103	6a 01		 push	 1
  00105	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00108	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  0010b	03 48 4c	 add	 ecx, DWORD PTR [eax+76]
  0010e	51		 push	 ecx
  0010f	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00112	8b 45 f4	 mov	 eax, DWORD PTR _trailx$[ebp]
  00115	03 42 48	 add	 eax, DWORD PTR [edx+72]
  00118	50		 push	 eax
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 f4	 mov	 edx, DWORD PTR _trailx$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _P_PathTraverse
  00126	83 c4 18	 add	 esp, 24			; 00000018H

; 2462 : 		PT_ADDLINES, PTR_SlideTraverse);
; 2463 : 	P_PathTraverse(leadx, traily, leadx + mo->momx, traily + mo->momy,

  00129	68 00 00 00 00	 push	 OFFSET _PTR_SlideTraverse
  0012e	6a 01		 push	 1
  00130	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00133	8b 4d f0	 mov	 ecx, DWORD PTR _traily$[ebp]
  00136	03 48 4c	 add	 ecx, DWORD PTR [eax+76]
  00139	51		 push	 ecx
  0013a	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0013d	8b 45 fc	 mov	 eax, DWORD PTR _leadx$[ebp]
  00140	03 42 48	 add	 eax, DWORD PTR [edx+72]
  00143	50		 push	 eax
  00144	8b 4d f0	 mov	 ecx, DWORD PTR _traily$[ebp]
  00147	51		 push	 ecx
  00148	8b 55 fc	 mov	 edx, DWORD PTR _leadx$[ebp]
  0014b	52		 push	 edx
  0014c	e8 00 00 00 00	 call	 _P_PathTraverse
  00151	83 c4 18	 add	 esp, 24			; 00000018H

; 2464 : 		PT_ADDLINES, PTR_SlideTraverse);
; 2465 : 
; 2466 : 	// Some walls are bouncy even if you're not
; 2467 : 	if (bestslideline && bestslideline->flags & ML_BOUNCY)

  00154	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslideline, 0
  0015b	74 22		 je	 SHORT $LN7@P_SlideMov
  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslideline
  00162	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00166	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  0016c	74 11		 je	 SHORT $LN7@P_SlideMov

; 2468 : 	{
; 2469 : 		P_BounceMove(mo);

  0016e	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _P_BounceMove
  00177	83 c4 04	 add	 esp, 4

; 2470 : 		return;

  0017a	e9 d5 01 00 00	 jmp	 $LN17@P_SlideMov
$LN7@P_SlideMov:

; 2471 : 	}
; 2472 : 
; 2473 : 	// move up to the wall
; 2474 : 	if (bestslidefrac == FRACUNIT+1)

  0017f	81 3d 00 00 00
	00 01 00 01 00	 cmp	 DWORD PTR _bestslidefrac, 65537 ; 00010001H
  00189	75 4d		 jne	 SHORT $LN8@P_SlideMov
$stairstep$20:

; 2475 : 	{
; 2476 : 		// the move must have hit the middle, so stairstep
; 2477 : stairstep:
; 2478 : 		if (!P_TryMove(mo, mo->x, mo->y + mo->momy, true))

  0018b	6a 01		 push	 1
  0018d	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00190	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00193	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00196	03 4a 4c	 add	 ecx, DWORD PTR [edx+76]
  00199	51		 push	 ecx
  0019a	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0019d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001a0	51		 push	 ecx
  001a1	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 _P_TryMove
  001aa	83 c4 10	 add	 esp, 16			; 00000010H
  001ad	85 c0		 test	 eax, eax
  001af	75 22		 jne	 SHORT $LN9@P_SlideMov

; 2479 : 			P_TryMove(mo, mo->x + mo->momx, mo->y, true); //Allow things to drop off.

  001b1	6a 01		 push	 1
  001b3	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  001b6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001b9	51		 push	 ecx
  001ba	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001bd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  001c3	03 41 48	 add	 eax, DWORD PTR [ecx+72]
  001c6	50		 push	 eax
  001c7	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  001ca	52		 push	 edx
  001cb	e8 00 00 00 00	 call	 _P_TryMove
  001d0	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@P_SlideMov:

; 2480 : 		return;

  001d3	e9 7c 01 00 00	 jmp	 $LN17@P_SlideMov
$LN8@P_SlideMov:

; 2481 : 	}
; 2482 : 
; 2483 : 	// fudge a bit to make sure it doesn't hit
; 2484 : 	bestslidefrac -= 0x800;

  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  001dd	2d 00 08 00 00	 sub	 eax, 2048		; 00000800H
  001e2	a3 00 00 00 00	 mov	 DWORD PTR _bestslidefrac, eax

; 2485 : 	if (bestslidefrac > 0)

  001e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslidefrac, 0
  001ee	7e 5b		 jle	 SHORT $LN11@P_SlideMov

; 2486 : 	{
; 2487 : 		newx = FixedMul(mo->momx, bestslidefrac);

  001f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  001f5	50		 push	 eax
  001f6	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  001f9	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  001fc	52		 push	 edx
  001fd	e8 00 00 00 00	 call	 _FixedMul
  00202	83 c4 08	 add	 esp, 8
  00205	89 45 ec	 mov	 DWORD PTR _newx$[ebp], eax

; 2488 : 		newy = FixedMul(mo->momy, bestslidefrac);

  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  0020d	50		 push	 eax
  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00211	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00214	52		 push	 edx
  00215	e8 00 00 00 00	 call	 _FixedMul
  0021a	83 c4 08	 add	 esp, 8
  0021d	89 45 e8	 mov	 DWORD PTR _newy$[ebp], eax

; 2489 : 
; 2490 : 		if (!P_TryMove(mo, mo->x + newx, mo->y + newy, true))

  00220	6a 01		 push	 1
  00222	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00225	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00228	03 4d e8	 add	 ecx, DWORD PTR _newy$[ebp]
  0022b	51		 push	 ecx
  0022c	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  0022f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00232	03 45 ec	 add	 eax, DWORD PTR _newx$[ebp]
  00235	50		 push	 eax
  00236	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00239	51		 push	 ecx
  0023a	e8 00 00 00 00	 call	 _P_TryMove
  0023f	83 c4 10	 add	 esp, 16			; 00000010H
  00242	85 c0		 test	 eax, eax
  00244	75 05		 jne	 SHORT $LN11@P_SlideMov

; 2491 : 			goto stairstep;

  00246	e9 40 ff ff ff	 jmp	 $stairstep$20
$LN11@P_SlideMov:

; 2492 : 	}
; 2493 : 
; 2494 : 	// Now continue along the wall.
; 2495 : 	// First calculate remainder.
; 2496 : 	bestslidefrac = FRACUNIT - (bestslidefrac+0x800);

  0024b	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  00250	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00255	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0025a	2b c8		 sub	 ecx, eax
  0025c	89 0d 00 00 00
	00		 mov	 DWORD PTR _bestslidefrac, ecx

; 2497 : 
; 2498 : 	if (bestslidefrac > FRACUNIT)

  00262	81 3d 00 00 00
	00 00 00 01 00	 cmp	 DWORD PTR _bestslidefrac, 65536 ; 00010000H
  0026c	7e 0a		 jle	 SHORT $LN12@P_SlideMov

; 2499 : 		bestslidefrac = FRACUNIT;

  0026e	c7 05 00 00 00
	00 00 00 01 00	 mov	 DWORD PTR _bestslidefrac, 65536 ; 00010000H
$LN12@P_SlideMov:

; 2500 : 
; 2501 : 	if (bestslidefrac <= 0)

  00278	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslidefrac, 0
  0027f	7f 05		 jg	 SHORT $LN13@P_SlideMov

; 2502 : 		return;

  00281	e9 ce 00 00 00	 jmp	 $LN17@P_SlideMov
$LN13@P_SlideMov:

; 2503 : 
; 2504 : 	tmxmove = FixedMul(mo->momx, bestslidefrac);

  00286	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  0028b	50		 push	 eax
  0028c	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  0028f	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00292	52		 push	 edx
  00293	e8 00 00 00 00	 call	 _FixedMul
  00298	83 c4 08	 add	 esp, 8
  0029b	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 2505 : 	tmymove = FixedMul(mo->momy, bestslidefrac);

  002a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  002a5	50		 push	 eax
  002a6	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  002a9	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  002ac	52		 push	 edx
  002ad	e8 00 00 00 00	 call	 _FixedMul
  002b2	83 c4 08	 add	 esp, 8
  002b5	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax

; 2506 : 
; 2507 : 	P_HitSlideLine(bestslideline); // clip the moves

  002ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslideline
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 _P_HitSlideLine
  002c5	83 c4 04	 add	 esp, 4

; 2508 : 
; 2509 : 	if ((twodlevel || (mo->flags2 & MF2_TWOD)) && mo->player)

  002c8	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  002cf	25 00 02 00 00	 and	 eax, 512		; 00000200H
  002d4	75 11		 jne	 SHORT $LN16@P_SlideMov
  002d6	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002d9	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  002df	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  002e5	74 24		 je	 SHORT $LN14@P_SlideMov
$LN16@P_SlideMov:
  002e7	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002ea	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  002f1	74 18		 je	 SHORT $LN14@P_SlideMov

; 2510 : 	{
; 2511 : 		mo->momx = tmxmove;

  002f3	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  002f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  002fc	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 2512 : 		tmymove = 0;

  002ff	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmymove, 0

; 2513 : 	}

  00309	eb 18		 jmp	 SHORT $LN15@P_SlideMov
$LN14@P_SlideMov:

; 2514 : 	else
; 2515 : 	{
; 2516 : 		mo->momx = tmxmove;

  0030b	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  00314	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 2517 : 		mo->momy = tmymove;

  00317	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  0031a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmymove
  00320	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
$LN15@P_SlideMov:

; 2518 : 	}
; 2519 : 
; 2520 : 	if (!P_TryMove(mo, mo->x + tmxmove, mo->y + tmymove, true))

  00323	6a 01		 push	 1
  00325	8b 45 08	 mov	 eax, DWORD PTR _mo$[ebp]
  00328	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0032b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _tmymove
  00331	51		 push	 ecx
  00332	8b 55 08	 mov	 edx, DWORD PTR _mo$[ebp]
  00335	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00338	03 05 00 00 00
	00		 add	 eax, DWORD PTR _tmxmove
  0033e	50		 push	 eax
  0033f	8b 4d 08	 mov	 ecx, DWORD PTR _mo$[ebp]
  00342	51		 push	 ecx
  00343	e8 00 00 00 00	 call	 _P_TryMove
  00348	83 c4 10	 add	 esp, 16			; 00000010H
  0034b	85 c0		 test	 eax, eax
  0034d	75 05		 jne	 SHORT $LN17@P_SlideMov

; 2521 : 		goto retry;

  0034f	e9 cd fc ff ff	 jmp	 $retry$19
$LN17@P_SlideMov:

; 2522 : }

  00354	5f		 pop	 edi
  00355	5e		 pop	 esi
  00356	5b		 pop	 ebx
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c3		 ret	 0
_P_SlideMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_TeleportMove
_TEXT	SEGMENT
_thing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_P_TeleportMove PROC					; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 85   : 	// the move is ok,
; 86   : 	// so link the thing into its new position
; 87   : 	P_UnsetThingPosition(thing);

  00009	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  00012	83 c4 04	 add	 esp, 4

; 88   : 
; 89   : 	// Remove touching_sectorlist from mobj.
; 90   : 	if (sector_list)

  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sector_list, 0
  0001c	74 18		 je	 SHORT $LN2@P_Teleport

; 91   : 	{
; 92   : 		P_DelSeclist(sector_list);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _sector_list
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _P_DelSeclist
  00029	83 c4 04	 add	 esp, 4

; 93   : 		sector_list = NULL;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _sector_list, 0
$LN2@P_Teleport:

; 94   : 	}
; 95   : 
; 96   : 	thing->x = x;

  00036	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0003c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 97   : 	thing->y = y;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00045	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 98   : 	thing->z = z;

  00048	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0004b	8b 4d 14	 mov	 ecx, DWORD PTR _z$[ebp]
  0004e	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 99   : 
; 100  : 	P_SetThingPosition(thing);

  00051	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _P_SetThingPosition
  0005a	83 c4 04	 add	 esp, 4

; 101  : 
; 102  : 	P_CheckPosition(thing, thing->x, thing->y);

  0005d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00060	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00063	51		 push	 ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00067	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0006a	50		 push	 eax
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _P_CheckPosition
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 103  : 
; 104  : 	thing->floorz = tmfloorz;

  00077	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00080	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 105  : 	thing->ceilingz = tmceilingz;

  00083	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0008c	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 106  : 
; 107  : 	return true;

  0008f	b8 01 00 00 00	 mov	 eax, 1

; 108  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_P_TeleportMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_TryMove
_TEXT	SEGMENT
_yh$1 = -36						; size = 4
_yl$2 = -32						; size = 4
_xh$3 = -28						; size = 4
_xl$4 = -24						; size = 4
_by$5 = -20						; size = 4
_bx$6 = -16						; size = 4
_maxstep$7 = -12					; size = 4
_oldy$ = -8						; size = 4
_oldx$ = -4						; size = 4
_thing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_allowdropoff$ = 20					; size = 4
_P_TryMove PROC						; COMDAT

; 1577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1578 : 	fixed_t oldx, oldy;
; 1579 : 
; 1580 : 	floatok = false;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _floatok, 0

; 1581 : 
; 1582 : 	if (!P_CheckPosition(thing, x, y))

  00013	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _P_CheckPosition
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	85 c0		 test	 eax, eax
  00029	75 13		 jne	 SHORT $LN8@P_TryMove

; 1583 : 	{
; 1584 : 		CheckMissileImpact(thing);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _CheckMissileImpact
  00034	83 c4 04	 add	 esp, 4

; 1585 : 		return false; // solid wall or thing

  00037	33 c0		 xor	 eax, eax
  00039	e9 b8 04 00 00	 jmp	 $LN1@P_TryMove
$LN8@P_TryMove:

; 1586 : 	}
; 1587 : 
; 1588 : 	if (!(thing->flags & MF_NOCLIP))

  0003e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00041	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00044	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0004a	0f 85 46 03 00
	00		 jne	 $LN34@P_TryMove

; 1589 : 	{
; 1590 : 		//All things are affected by their scale.
; 1591 : 		fixed_t maxstep = FIXEDSCALE(MAXSTEPMOVE, thing->scale);

  00050	68 00 00 18 00	 push	 1572864			; 00180000H
  00055	68 00 00 64 00	 push	 6553600			; 00640000H
  0005a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0005d	0f b7 88 cc 00
	00 00		 movzx	 ecx, WORD PTR [eax+204]
  00064	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _FixedDiv
  0006d	83 c4 08	 add	 esp, 8
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _FixedMul
  00076	83 c4 08	 add	 esp, 8
  00079	89 45 f4	 mov	 DWORD PTR _maxstep$7[ebp], eax

; 1592 : 
; 1593 : 		if (thing->player)

  0007c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0007f	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00086	74 50		 je	 SHORT $LN11@P_TryMove

; 1594 : 		{
; 1595 : 			// Don't 'step up' while springing,
; 1596 : 			// Only step up "if needed".
; 1597 : 			if (thing->state == &states[S_PLAY_PLG1]
; 1598 : 				&& ((!(thing->eflags & MFE_VERTICALFLIP) && thing->momz > FRACUNIT)

  00088	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  0008d	c1 e0 04	 shl	 eax, 4
  00090	05 00 00 00 00	 add	 eax, OFFSET _states
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00098	39 41 5c	 cmp	 DWORD PTR [ecx+92], eax
  0009b	75 3b		 jne	 SHORT $LN11@P_TryMove
  0009d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000a0	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000a6	83 e1 20	 and	 ecx, 32			; 00000020H
  000a9	75 0c		 jne	 SHORT $LN13@P_TryMove
  000ab	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ae	81 78 50 00 00
	01 00		 cmp	 DWORD PTR [eax+80], 65536 ; 00010000H
  000b5	7f 1a		 jg	 SHORT $LN12@P_TryMove
$LN13@P_TryMove:
  000b7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ba	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000c0	83 e1 20	 and	 ecx, 32			; 00000020H
  000c3	74 13		 je	 SHORT $LN11@P_TryMove
  000c5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000c8	81 78 50 00 00
	ff ff		 cmp	 DWORD PTR [eax+80], -65536 ; ffff0000H
  000cf	7d 07		 jge	 SHORT $LN11@P_TryMove
$LN12@P_TryMove:

; 1599 : 				|| ((thing->eflags & MFE_VERTICALFLIP && thing->momz < -FRACUNIT))))
; 1600 : 				maxstep = 0;

  000d1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _maxstep$7[ebp], 0
$LN11@P_TryMove:

; 1601 : 		}
; 1602 : 
; 1603 : 		if (thing->type == MT_SKIM)

  000d8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000db	83 78 7c 0a	 cmp	 DWORD PTR [eax+124], 10	; 0000000aH
  000df	75 07		 jne	 SHORT $LN14@P_TryMove

; 1604 : 			maxstep = 0;

  000e1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _maxstep$7[ebp], 0
$LN14@P_TryMove:

; 1605 : 
; 1606 : 		if (tmceilingz - tmfloorz < thing->height)

  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmceilingz
  000ed	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _tmfloorz
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  000f6	3b 41 44	 cmp	 eax, DWORD PTR [ecx+68]
  000f9	7d 13		 jge	 SHORT $LN15@P_TryMove

; 1607 : 		{
; 1608 : 			CheckMissileImpact(thing);

  000fb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 _CheckMissileImpact
  00104	83 c4 04	 add	 esp, 4

; 1609 : 			return false; // doesn't fit

  00107	33 c0		 xor	 eax, eax
  00109	e9 e8 03 00 00	 jmp	 $LN1@P_TryMove
$LN15@P_TryMove:

; 1610 : 		}
; 1611 : 
; 1612 : 		floatok = true;

  0010e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1613 : 
; 1614 : 		if (thing->eflags & MFE_VERTICALFLIP)

  00118	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0011b	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00121	83 e1 20	 and	 ecx, 32			; 00000020H
  00124	74 23		 je	 SHORT $LN16@P_TryMove

; 1615 : 		{
; 1616 : 			if (thing->z < tmfloorz)

  00126	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00129	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0012c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _tmfloorz
  00132	7d 13		 jge	 SHORT $LN18@P_TryMove

; 1617 : 			{
; 1618 : 				CheckMissileImpact(thing);

  00134	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _CheckMissileImpact
  0013d	83 c4 04	 add	 esp, 4

; 1619 : 				return false; // mobj must raise itself to fit

  00140	33 c0		 xor	 eax, eax
  00142	e9 af 03 00 00	 jmp	 $LN1@P_TryMove
$LN18@P_TryMove:

; 1620 : 			}
; 1621 : 		}

  00147	eb 27		 jmp	 SHORT $LN19@P_TryMove
$LN16@P_TryMove:

; 1622 : 		else if (tmceilingz - thing->z < thing->height)

  00149	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0014c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  00152	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00155	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00158	3b 4a 44	 cmp	 ecx, DWORD PTR [edx+68]
  0015b	7d 13		 jge	 SHORT $LN19@P_TryMove

; 1623 : 		{
; 1624 : 			CheckMissileImpact(thing);

  0015d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _CheckMissileImpact
  00166	83 c4 04	 add	 esp, 4

; 1625 : 			return false; // mobj must lower itself to fit

  00169	33 c0		 xor	 eax, eax
  0016b	e9 86 03 00 00	 jmp	 $LN1@P_TryMove
$LN19@P_TryMove:

; 1626 : 		}
; 1627 : 
; 1628 : 		// If using type Section1:13, double the maxstep.
; 1629 : 		if (thing->player && (P_PlayerTouchingSectorSpecial(thing->player, 1, 13)

  00170	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00173	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0017a	74 40		 je	 SHORT $LN20@P_TryMove
  0017c	6a 0d		 push	 13			; 0000000dH
  0017e	6a 01		 push	 1
  00180	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00183	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 _P_PlayerTouchingSectorSpecial
  0018f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00192	85 c0		 test	 eax, eax
  00194	75 1e		 jne	 SHORT $LN21@P_TryMove
  00196	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00199	50		 push	 eax
  0019a	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 _R_PointInSubsector
  001a3	83 c4 08	 add	 esp, 8
  001a6	8b 10		 mov	 edx, DWORD PTR [eax]
  001a8	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  001ac	83 e0 0f	 and	 eax, 15			; 0000000fH
  001af	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  001b2	75 08		 jne	 SHORT $LN20@P_TryMove
$LN21@P_TryMove:

; 1630 : 			|| GETSECSPECIAL(R_PointInSubsector(x, y)->sector->special, 1) == 13))
; 1631 : 			maxstep <<= 1;

  001b4	8b 45 f4	 mov	 eax, DWORD PTR _maxstep$7[ebp]
  001b7	d1 e0		 shl	 eax, 1
  001b9	89 45 f4	 mov	 DWORD PTR _maxstep$7[ebp], eax
$LN20@P_TryMove:

; 1632 : 
; 1633 : 		// Ramp test
; 1634 : 		if (thing->player && !P_PlayerTouchingSectorSpecial(thing->player, 1, 14)
; 1635 : 							&& GETSECSPECIAL(R_PointInSubsector(x, y)->sector->special, 1) != 14)

  001bc	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001bf	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001c6	0f 84 04 01 00
	00		 je	 $LN26@P_TryMove
  001cc	6a 0e		 push	 14			; 0000000eH
  001ce	6a 01		 push	 1
  001d0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001d3	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001d9	51		 push	 ecx
  001da	e8 00 00 00 00	 call	 _P_PlayerTouchingSectorSpecial
  001df	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e2	85 c0		 test	 eax, eax
  001e4	0f 85 e6 00 00
	00		 jne	 $LN26@P_TryMove
  001ea	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  001ed	50		 push	 eax
  001ee	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 _R_PointInSubsector
  001f7	83 c4 08	 add	 esp, 8
  001fa	8b 10		 mov	 edx, DWORD PTR [eax]
  001fc	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  00200	83 e0 0f	 and	 eax, 15			; 0000000fH
  00203	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00206	0f 84 c4 00 00
	00		 je	 $LN26@P_TryMove

; 1636 : 		{
; 1637 : 			// If the floor difference is MAXSTEPMOVE or less, and the sector isn't Section1:14, ALWAYS
; 1638 : 			// step down! Formerly required a Section1:13 sector for the full MAXSTEPMOVE, but no more.
; 1639 : 
; 1640 : 			if (thing->eflags & MFE_VERTICALFLIP)

  0020c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0020f	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00215	83 e1 20	 and	 ecx, 32			; 00000020H
  00218	74 68		 je	 SHORT $LN23@P_TryMove

; 1641 : 			{
; 1642 : 				if (thing->z+thing->height == thing->ceilingz && tmceilingz > thing->z+thing->height && tmceilingz - thing->z+thing->height <= maxstep)

  0021a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0021d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00220	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00223	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00226	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00229	3b 48 3c	 cmp	 ecx, DWORD PTR [eax+60]
  0022c	75 52		 jne	 SHORT $LN25@P_TryMove
  0022e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00231	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00234	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00237	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0023a	39 0d 00 00 00
	00		 cmp	 DWORD PTR _tmceilingz, ecx
  00240	7e 3e		 jle	 SHORT $LN25@P_TryMove
  00242	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0024b	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  0024e	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00251	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  00254	3b 4d f4	 cmp	 ecx, DWORD PTR _maxstep$7[ebp]
  00257	7f 27		 jg	 SHORT $LN25@P_TryMove

; 1643 : 				{
; 1644 : 					thing->z = tmceilingz - thing->height;

  00259	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0025c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  00262	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00265	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00268	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 1645 : 					thing->eflags |= MFE_JUSTSTEPPEDDOWN;

  0026b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0026e	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  00274	83 c9 10	 or	 ecx, 16			; 00000010H
  00277	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0027a	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
$LN25@P_TryMove:

; 1646 : 				}
; 1647 : 			}

  00280	eb 4e		 jmp	 SHORT $LN26@P_TryMove
$LN23@P_TryMove:

; 1648 : 			else if (thing->z == thing->floorz && tmfloorz < thing->z && thing->z - tmfloorz <= maxstep)

  00282	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00288	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0028b	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  0028e	75 40		 jne	 SHORT $LN26@P_TryMove
  00290	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00299	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0029c	7d 32		 jge	 SHORT $LN26@P_TryMove
  0029e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002a1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002a4	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _tmfloorz
  002aa	3b 4d f4	 cmp	 ecx, DWORD PTR _maxstep$7[ebp]
  002ad	7f 21		 jg	 SHORT $LN26@P_TryMove

; 1649 : 			{
; 1650 : 				thing->z = tmfloorz;

  002af	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  002b8	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1651 : 				thing->eflags |= MFE_JUSTSTEPPEDDOWN;

  002bb	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002be	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  002c4	83 c9 10	 or	 ecx, 16			; 00000010H
  002c7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  002ca	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
$LN26@P_TryMove:

; 1652 : 			}
; 1653 : 		}
; 1654 : 
; 1655 : 		if (thing->eflags & MFE_VERTICALFLIP)

  002d0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002d3	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  002d9	83 e1 20	 and	 ecx, 32			; 00000020H
  002dc	74 2d		 je	 SHORT $LN27@P_TryMove

; 1656 : 		{
; 1657 : 			if (thing->z + thing->height > tmceilingz + maxstep)

  002de	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002e1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002e4	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  002e7	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  002ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmceilingz
  002ef	03 45 f4	 add	 eax, DWORD PTR _maxstep$7[ebp]
  002f2	3b c8		 cmp	 ecx, eax
  002f4	7e 13		 jle	 SHORT $LN29@P_TryMove

; 1658 : 			{
; 1659 : 				CheckMissileImpact(thing);

  002f6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002f9	50		 push	 eax
  002fa	e8 00 00 00 00	 call	 _CheckMissileImpact
  002ff	83 c4 04	 add	 esp, 4

; 1660 : 				return false; // too big a step up

  00302	33 c0		 xor	 eax, eax
  00304	e9 ed 01 00 00	 jmp	 $LN1@P_TryMove
$LN29@P_TryMove:

; 1661 : 			}
; 1662 : 		}

  00309	eb 24		 jmp	 SHORT $LN30@P_TryMove
$LN27@P_TryMove:

; 1663 : 		else if (tmfloorz - thing->z > maxstep)

  0030b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00314	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00317	3b 4d f4	 cmp	 ecx, DWORD PTR _maxstep$7[ebp]
  0031a	7e 13		 jle	 SHORT $LN30@P_TryMove

; 1664 : 		{
; 1665 : 			CheckMissileImpact(thing);

  0031c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0031f	50		 push	 eax
  00320	e8 00 00 00 00	 call	 _CheckMissileImpact
  00325	83 c4 04	 add	 esp, 4

; 1666 : 			return false; // too big a step up

  00328	33 c0		 xor	 eax, eax
  0032a	e9 c7 01 00 00	 jmp	 $LN1@P_TryMove
$LN30@P_TryMove:

; 1667 : 		}
; 1668 : 
; 1669 : 		if (tmfloorz > thing->z)

  0032f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00338	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0033b	7e 1a		 jle	 SHORT $LN32@P_TryMove

; 1670 : 		{
; 1671 : 			if ((thing->flags & MF_MISSILE))

  0033d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00340	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00343	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  00349	74 0c		 je	 SHORT $LN32@P_TryMove

; 1672 : 				CheckMissileImpact(thing);

  0034b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 _CheckMissileImpact
  00354	83 c4 04	 add	 esp, 4
$LN32@P_TryMove:

; 1673 : 		}
; 1674 : 
; 1675 : 		if (!allowdropoff)

  00357	83 7d 14 00	 cmp	 DWORD PTR _allowdropoff$[ebp], 0
  0035b	75 39		 jne	 SHORT $LN34@P_TryMove

; 1676 : 			if (!(thing->flags & (MF_FLOAT)) && thing->type != MT_SKIM && !tmfloorthing
; 1677 : 				&& tmfloorz - tmdropoffz > MAXSTEPMOVE)

  0035d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00360	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00363	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00369	75 2b		 jne	 SHORT $LN34@P_TryMove
  0036b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0036e	83 78 7c 0a	 cmp	 DWORD PTR [eax+124], 10	; 0000000aH
  00372	74 22		 je	 SHORT $LN34@P_TryMove
  00374	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmfloorthing, 0
  0037b	75 19		 jne	 SHORT $LN34@P_TryMove
  0037d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmfloorz
  00382	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _tmdropoffz
  00388	3d 00 00 18 00	 cmp	 eax, 1572864		; 00180000H
  0038d	7e 07		 jle	 SHORT $LN34@P_TryMove

; 1678 : 				return false; // don't stand over a dropoff

  0038f	33 c0		 xor	 eax, eax
  00391	e9 60 01 00 00	 jmp	 $LN1@P_TryMove
$LN34@P_TryMove:

; 1679 : 	}
; 1680 : 
; 1681 : 	// The move is ok!
; 1682 : 
; 1683 : 	// If it's a pushable object, check if anything is
; 1684 : 	// standing on top and move it, too.
; 1685 : 	if (thing->flags & MF_PUSHABLE)

  00396	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00399	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0039c	83 e1 40	 and	 ecx, 64			; 00000040H
  0039f	0f 84 c3 00 00
	00		 je	 $LN3@P_TryMove

; 1686 : 	{
; 1687 : 		INT32 bx, by, xl, xh, yl, yh;
; 1688 : 
; 1689 : 		yh = (unsigned)(thing->y + MAXRADIUS - bmaporgy)>>MAPBLOCKSHIFT;

  003a5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003a8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003ab	81 c1 00 00 20
	00		 add	 ecx, 2097152		; 00200000H
  003b1	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  003b7	c1 e9 17	 shr	 ecx, 23			; 00000017H
  003ba	89 4d dc	 mov	 DWORD PTR _yh$1[ebp], ecx

; 1690 : 		yl = (unsigned)(thing->y - MAXRADIUS - bmaporgy)>>MAPBLOCKSHIFT;

  003bd	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003c0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003c3	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  003c9	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  003cf	c1 e9 17	 shr	 ecx, 23			; 00000017H
  003d2	89 4d e0	 mov	 DWORD PTR _yl$2[ebp], ecx

; 1691 : 		xh = (unsigned)(thing->x + MAXRADIUS - bmaporgx)>>MAPBLOCKSHIFT;

  003d5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003d8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003db	81 c1 00 00 20
	00		 add	 ecx, 2097152		; 00200000H
  003e1	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  003e7	c1 e9 17	 shr	 ecx, 23			; 00000017H
  003ea	89 4d e4	 mov	 DWORD PTR _xh$3[ebp], ecx

; 1692 : 		xl = (unsigned)(thing->x - MAXRADIUS - bmaporgx)>>MAPBLOCKSHIFT;

  003ed	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  003f0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003f3	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  003f9	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  003ff	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00402	89 4d e8	 mov	 DWORD PTR _xl$4[ebp], ecx

; 1693 : 
; 1694 : 		stand = thing;

  00405	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00408	a3 00 00 00 00	 mov	 DWORD PTR _stand, eax

; 1695 : 		standx = x;

  0040d	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00410	a3 00 00 00 00	 mov	 DWORD PTR _standx, eax

; 1696 : 		standy = y;

  00415	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00418	a3 00 00 00 00	 mov	 DWORD PTR _standy, eax

; 1697 : 
; 1698 : 		for (by = yl; by <= yh; by++)

  0041d	8b 45 e0	 mov	 eax, DWORD PTR _yl$2[ebp]
  00420	89 45 ec	 mov	 DWORD PTR _by$5[ebp], eax
  00423	eb 09		 jmp	 SHORT $LN4@P_TryMove
$LN2@P_TryMove:
  00425	8b 45 ec	 mov	 eax, DWORD PTR _by$5[ebp]
  00428	83 c0 01	 add	 eax, 1
  0042b	89 45 ec	 mov	 DWORD PTR _by$5[ebp], eax
$LN4@P_TryMove:
  0042e	8b 45 ec	 mov	 eax, DWORD PTR _by$5[ebp]
  00431	3b 45 dc	 cmp	 eax, DWORD PTR _yh$1[ebp]
  00434	7f 32		 jg	 SHORT $LN3@P_TryMove

; 1699 : 			for (bx = xl; bx <= xh; bx++)

  00436	8b 45 e8	 mov	 eax, DWORD PTR _xl$4[ebp]
  00439	89 45 f0	 mov	 DWORD PTR _bx$6[ebp], eax
  0043c	eb 09		 jmp	 SHORT $LN7@P_TryMove
$LN5@P_TryMove:
  0043e	8b 45 f0	 mov	 eax, DWORD PTR _bx$6[ebp]
  00441	83 c0 01	 add	 eax, 1
  00444	89 45 f0	 mov	 DWORD PTR _bx$6[ebp], eax
$LN7@P_TryMove:
  00447	8b 45 f0	 mov	 eax, DWORD PTR _bx$6[ebp]
  0044a	3b 45 e4	 cmp	 eax, DWORD PTR _xh$3[ebp]
  0044d	7f 17		 jg	 SHORT $LN6@P_TryMove

; 1700 : 				P_BlockThingsIterator(bx, by, PIT_PushableMoved);

  0044f	68 00 00 00 00	 push	 OFFSET _PIT_PushableMoved
  00454	8b 45 ec	 mov	 eax, DWORD PTR _by$5[ebp]
  00457	50		 push	 eax
  00458	8b 4d f0	 mov	 ecx, DWORD PTR _bx$6[ebp]
  0045b	51		 push	 ecx
  0045c	e8 00 00 00 00	 call	 _P_BlockThingsIterator
  00461	83 c4 0c	 add	 esp, 12			; 0000000cH
  00464	eb d8		 jmp	 SHORT $LN5@P_TryMove
$LN6@P_TryMove:
  00466	eb bd		 jmp	 SHORT $LN2@P_TryMove
$LN3@P_TryMove:

; 1701 : 	}
; 1702 : 
; 1703 : 	// Link the thing into its new position
; 1704 : 	P_UnsetThingPosition(thing);

  00468	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0046b	50		 push	 eax
  0046c	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  00471	83 c4 04	 add	 esp, 4

; 1705 : 
; 1706 : 	oldx = thing->x;

  00474	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00477	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0047a	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1707 : 	oldy = thing->y;

  0047d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00480	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00483	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1708 : 	thing->floorz = tmfloorz;

  00486	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00489	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  0048f	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 1709 : 	thing->ceilingz = tmceilingz;

  00492	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00495	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0049b	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1710 : 	thing->x = x;

  0049e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004a1	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  004a4	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1711 : 	thing->y = y;

  004a7	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004aa	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  004ad	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1712 : 
; 1713 : 	if (tmfloorthing)

  004b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmfloorthing, 0
  004b7	74 17		 je	 SHORT $LN36@P_TryMove

; 1714 : 		thing->eflags &= ~MFE_ONGROUND; // not on real floor

  004b9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004bc	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  004c2	83 e1 fe	 and	 ecx, -2			; fffffffeH
  004c5	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  004c8	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
  004ce	eb 15		 jmp	 SHORT $LN37@P_TryMove
$LN36@P_TryMove:

; 1715 : 	else
; 1716 : 		thing->eflags |= MFE_ONGROUND;

  004d0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004d3	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  004d9	83 c9 01	 or	 ecx, 1
  004dc	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  004df	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
$LN37@P_TryMove:

; 1717 : 
; 1718 : 	P_SetThingPosition(thing);

  004e5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  004e8	50		 push	 eax
  004e9	e8 00 00 00 00	 call	 _P_SetThingPosition
  004ee	83 c4 04	 add	 esp, 4

; 1719 : 	return true;

  004f1	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_TryMove:

; 1720 : }

  004f6	5f		 pop	 edi
  004f7	5e		 pop	 esi
  004f8	5b		 pop	 ebx
  004f9	8b e5		 mov	 esp, ebp
  004fb	5d		 pop	 ebp
  004fc	c3		 ret	 0
_P_TryMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CheckCameraPosition
_TEXT	SEGMENT
_polybottom$1 = -80					; size = 4
_polytop$2 = -76					; size = 4
_thingtop$3 = -72					; size = 4
_delta2$4 = -68						; size = 4
_delta1$5 = -64						; size = 4
_polysec$6 = -60					; size = 4
_po$7 = -56						; size = 4
_plink$8 = -52						; size = 4
_offset$9 = -48						; size = 4
_thingtop$10 = -44					; size = 4
_delta2$11 = -40					; size = 4
_delta1$12 = -36					; size = 4
_rover$13 = -32						; size = 4
_newsubsec$ = -28					; size = 4
_by$ = -24						; size = 4
_bx$ = -20						; size = 4
_yh$ = -16						; size = 4
_yl$ = -12						; size = 4
_xh$ = -8						; size = 4
_xl$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_thiscam$ = 16						; size = 4
_P_CheckCameraPosition PROC				; COMDAT

; 1226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1227 : 	INT32 xl, xh, yl, yh, bx, by;
; 1228 : 	subsector_t *newsubsec;
; 1229 : 
; 1230 : 	tmx = x;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000f	a3 00 00 00 00	 mov	 DWORD PTR _tmx, eax

; 1231 : 	tmy = y;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00017	a3 00 00 00 00	 mov	 DWORD PTR _tmy, eax

; 1232 : 
; 1233 : 	tmbbox[BOXTOP] = y + thiscam->radius;

  0001c	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00022	03 48 2c	 add	 ecx, DWORD PTR [eax+44]
  00025	ba 04 00 00 00	 mov	 edx, 4
  0002a	6b c2 00	 imul	 eax, edx, 0
  0002d	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 1234 : 	tmbbox[BOXBOTTOM] = y - thiscam->radius;

  00033	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00039	2b 48 2c	 sub	 ecx, DWORD PTR [eax+44]
  0003c	ba 04 00 00 00	 mov	 edx, 4
  00041	c1 e2 00	 shl	 edx, 0
  00044	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 1235 : 	tmbbox[BOXRIGHT] = x + thiscam->radius;

  0004a	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00050	03 48 2c	 add	 ecx, DWORD PTR [eax+44]
  00053	ba 04 00 00 00	 mov	 edx, 4
  00058	6b c2 03	 imul	 eax, edx, 3
  0005b	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 1236 : 	tmbbox[BOXLEFT] = x - thiscam->radius;

  00061	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00067	2b 48 2c	 sub	 ecx, DWORD PTR [eax+44]
  0006a	ba 04 00 00 00	 mov	 edx, 4
  0006f	d1 e2		 shl	 edx, 1
  00071	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 1237 : 
; 1238 : 	newsubsec = R_PointInSubsector(x, y);

  00077	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _R_PointInSubsector
  00084	83 c4 08	 add	 esp, 8
  00087	89 45 e4	 mov	 DWORD PTR _newsubsec$[ebp], eax

; 1239 : 	ceilingline = blockingline = NULL;

  0008a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _blockingline, 0
  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockingline
  00099	a3 00 00 00 00	 mov	 DWORD PTR _ceilingline, eax

; 1240 : 
; 1241 : 	// The base floor / ceiling is from the subsector
; 1242 : 	// that contains the point.
; 1243 : 	// Any contacted lines the step closer together
; 1244 : 	// will adjust them.
; 1245 : 	tmfloorz = tmsectorfloorz = tmdropoffz = newsubsec->sector->floorheight;

  0009e	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a5	89 15 00 00 00
	00		 mov	 DWORD PTR _tmdropoffz, edx
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmdropoffz
  000b0	a3 00 00 00 00	 mov	 DWORD PTR _tmsectorfloorz, eax
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmsectorfloorz
  000bb	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmfloorz, ecx

; 1246 : 	tmceilingz = tmsectorceilingz = newsubsec->sector->ceilingheight;

  000c1	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c9	89 15 00 00 00
	00		 mov	 DWORD PTR _tmsectorceilingz, edx
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmsectorceilingz
  000d4	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax

; 1247 : 
; 1248 : 	// Cameras use the heightsec's heights rather then the actual sector heights.
; 1249 : 	// If you can see through it, why not move the camera through it too?
; 1250 : 	if (newsubsec->sector->heightsec >= 0)

  000d9	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  000e2	7c 57		 jl	 SHORT $LN19@P_CheckCam

; 1251 : 	{
; 1252 : 		tmfloorz = tmsectorfloorz = tmdropoffz = sectors[newsubsec->sector->heightsec].floorheight;

  000e4	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	69 51 68 f8 00
	00 00		 imul	 edx, DWORD PTR [ecx+104], 248
  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  000f5	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  000f8	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmdropoffz, ecx
  000fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmdropoffz
  00104	89 15 00 00 00
	00		 mov	 DWORD PTR _tmsectorfloorz, edx
  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmsectorfloorz
  0010f	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax

; 1253 : 		tmceilingz = tmsectorceilingz = sectors[newsubsec->sector->heightsec].ceilingheight;

  00114	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  00117	8b 08		 mov	 ecx, DWORD PTR [eax]
  00119	69 51 68 f8 00
	00 00		 imul	 edx, DWORD PTR [ecx+104], 248
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR _sectors
  00125	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00129	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmsectorceilingz, ecx
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tmsectorceilingz
  00135	89 15 00 00 00
	00		 mov	 DWORD PTR _tmceilingz, edx
$LN19@P_CheckCam:

; 1254 : 	}
; 1255 : 
; 1256 : 	// Check list of fake floors and see if tmfloorz/tmceilingz need to be altered.
; 1257 : 	if (newsubsec->sector->ffloors)

  0013b	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  0013e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00140	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  00147	0f 84 29 01 00
	00		 je	 $LN3@P_CheckCam

; 1258 : 	{
; 1259 : 		ffloor_t *rover;
; 1260 : 		fixed_t delta1, delta2;
; 1261 : 		INT32 thingtop = thiscam->z + thiscam->height;

  0014d	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00150	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00153	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00156	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  00159	89 4d d4	 mov	 DWORD PTR _thingtop$10[ebp], ecx

; 1262 : 
; 1263 : 		for (rover = newsubsec->sector->ffloors; rover; rover = rover->next)

  0015c	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  0015f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00161	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00167	89 55 e0	 mov	 DWORD PTR _rover$13[ebp], edx
  0016a	eb 09		 jmp	 SHORT $LN4@P_CheckCam
$LN2@P_CheckCam:
  0016c	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  0016f	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00172	89 4d e0	 mov	 DWORD PTR _rover$13[ebp], ecx
$LN4@P_CheckCam:
  00175	83 7d e0 00	 cmp	 DWORD PTR _rover$13[ebp], 0
  00179	0f 84 f7 00 00
	00		 je	 $LN3@P_CheckCam

; 1264 : 		{
; 1265 : 			if (!(rover->flags & FF_BLOCKOTHERS) || !(rover->flags & FF_EXISTS) || !(rover->flags & FF_RENDERALL))

  0017f	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  00182	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00185	83 e1 04	 and	 ecx, 4
  00188	74 16		 je	 SHORT $LN22@P_CheckCam
  0018a	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  0018d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00190	83 e1 01	 and	 ecx, 1
  00193	74 0b		 je	 SHORT $LN22@P_CheckCam
  00195	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  00198	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0019b	83 e1 18	 and	 ecx, 24			; 00000018H
  0019e	75 02		 jne	 SHORT $LN21@P_CheckCam
$LN22@P_CheckCam:

; 1266 : 				continue;

  001a0	eb ca		 jmp	 SHORT $LN2@P_CheckCam
$LN21@P_CheckCam:

; 1267 : 
; 1268 : 			delta1 = thiscam->z - (*rover->bottomheight

  001a2	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  001a5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001a8	8b 55 e0	 mov	 edx, DWORD PTR _rover$13[ebp]
  001ab	8b 02		 mov	 eax, DWORD PTR [edx]
  001ad	8b 55 e0	 mov	 edx, DWORD PTR _rover$13[ebp]
  001b0	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001b3	8b 00		 mov	 eax, DWORD PTR [eax]
  001b5	2b 02		 sub	 eax, DWORD PTR [edx]
  001b7	99		 cdq
  001b8	2b c2		 sub	 eax, edx
  001ba	d1 f8		 sar	 eax, 1
  001bc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001be	03 c8		 add	 ecx, eax
  001c0	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  001c3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001c6	2b c1		 sub	 eax, ecx
  001c8	89 45 dc	 mov	 DWORD PTR _delta1$12[ebp], eax

; 1269 : 				+ ((*rover->topheight - *rover->bottomheight)/2));
; 1270 : 			delta2 = thingtop - (*rover->bottomheight

  001cb	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  001ce	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001d1	8b 55 e0	 mov	 edx, DWORD PTR _rover$13[ebp]
  001d4	8b 02		 mov	 eax, DWORD PTR [edx]
  001d6	8b 55 e0	 mov	 edx, DWORD PTR _rover$13[ebp]
  001d9	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  001dc	8b 00		 mov	 eax, DWORD PTR [eax]
  001de	2b 02		 sub	 eax, DWORD PTR [edx]
  001e0	99		 cdq
  001e1	2b c2		 sub	 eax, edx
  001e3	d1 f8		 sar	 eax, 1
  001e5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001e7	03 c8		 add	 ecx, eax
  001e9	8b 55 d4	 mov	 edx, DWORD PTR _thingtop$10[ebp]
  001ec	2b d1		 sub	 edx, ecx
  001ee	89 55 d8	 mov	 DWORD PTR _delta2$11[ebp], edx

; 1271 : 				+ ((*rover->topheight - *rover->bottomheight)/2));
; 1272 : 			if (*rover->topheight > tmfloorz && abs(delta1) < abs(delta2))

  001f1	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  001f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _tmfloorz
  001fe	7e 35		 jle	 SHORT $LN23@P_CheckCam
  00200	8b 45 dc	 mov	 eax, DWORD PTR _delta1$12[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 _abs
  00209	83 c4 04	 add	 esp, 4
  0020c	8b f0		 mov	 esi, eax
  0020e	8b 4d d8	 mov	 ecx, DWORD PTR _delta2$11[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 _abs
  00217	83 c4 04	 add	 esp, 4
  0021a	3b f0		 cmp	 esi, eax
  0021c	7d 17		 jge	 SHORT $LN23@P_CheckCam

; 1273 : 			{
; 1274 : 				tmfloorz = tmdropoffz = *rover->topheight;

  0021e	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	8b 11		 mov	 edx, DWORD PTR [ecx]
  00225	89 15 00 00 00
	00		 mov	 DWORD PTR _tmdropoffz, edx
  0022b	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmdropoffz
  00230	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax
$LN23@P_CheckCam:

; 1275 : 			}
; 1276 : 			if (*rover->bottomheight < tmceilingz && abs(delta1) >= abs(delta2))

  00235	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  00238	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0023b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _tmceilingz
  00243	7d 2c		 jge	 SHORT $LN24@P_CheckCam
  00245	8b 45 dc	 mov	 eax, DWORD PTR _delta1$12[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 _abs
  0024e	83 c4 04	 add	 esp, 4
  00251	8b f0		 mov	 esi, eax
  00253	8b 4d d8	 mov	 ecx, DWORD PTR _delta2$11[ebp]
  00256	51		 push	 ecx
  00257	e8 00 00 00 00	 call	 _abs
  0025c	83 c4 04	 add	 esp, 4
  0025f	3b f0		 cmp	 esi, eax
  00261	7c 0e		 jl	 SHORT $LN24@P_CheckCam

; 1277 : 			{
; 1278 : 				tmceilingz = *rover->bottomheight;

  00263	8b 45 e0	 mov	 eax, DWORD PTR _rover$13[ebp]
  00266	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00269	8b 11		 mov	 edx, DWORD PTR [ecx]
  0026b	89 15 00 00 00
	00		 mov	 DWORD PTR _tmceilingz, edx
$LN24@P_CheckCam:

; 1279 : 			}
; 1280 : 		}

  00271	e9 f6 fe ff ff	 jmp	 $LN2@P_CheckCam
$LN3@P_CheckCam:

; 1281 : 	}
; 1282 : 
; 1283 : #ifdef POLYOBJECTS
; 1284 : 	// Check polyobjects and see if tmfloorz/tmceilingz need to be altered
; 1285 : 	{
; 1286 : 		validcount++;

  00276	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  0027b	83 c0 01	 add	 eax, 1
  0027e	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 1287 : 
; 1288 : 		xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx)>>MAPBLOCKSHIFT;

  00283	b8 04 00 00 00	 mov	 eax, 4
  00288	d1 e0		 shl	 eax, 1
  0028a	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  00290	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  00296	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00299	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 1289 : 		xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx)>>MAPBLOCKSHIFT;

  0029c	b8 04 00 00 00	 mov	 eax, 4
  002a1	6b c8 03	 imul	 ecx, eax, 3
  002a4	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  002aa	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  002b0	c1 ea 17	 shr	 edx, 23			; 00000017H
  002b3	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 1290 : 		yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy)>>MAPBLOCKSHIFT;

  002b6	b8 04 00 00 00	 mov	 eax, 4
  002bb	c1 e0 00	 shl	 eax, 0
  002be	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  002c4	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  002ca	c1 e9 17	 shr	 ecx, 23			; 00000017H
  002cd	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 1291 : 		yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy)>>MAPBLOCKSHIFT;

  002d0	b8 04 00 00 00	 mov	 eax, 4
  002d5	6b c8 00	 imul	 ecx, eax, 0
  002d8	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  002de	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  002e4	c1 ea 17	 shr	 edx, 23			; 00000017H
  002e7	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 1292 : 
; 1293 : 		for (by = yl; by <= yh; by++)

  002ea	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  002ed	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  002f0	eb 09		 jmp	 SHORT $LN7@P_CheckCam
$LN5@P_CheckCam:
  002f2	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  002f5	83 c0 01	 add	 eax, 1
  002f8	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN7@P_CheckCam:
  002fb	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  002fe	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  00301	0f 8f c2 01 00
	00		 jg	 $LN6@P_CheckCam

; 1294 : 			for (bx = xl; bx <= xh; bx++)

  00307	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  0030a	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  0030d	eb 09		 jmp	 SHORT $LN10@P_CheckCam
$LN8@P_CheckCam:
  0030f	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00312	83 c0 01	 add	 eax, 1
  00315	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN10@P_CheckCam:
  00318	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0031b	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  0031e	0f 8f a0 01 00
	00		 jg	 $LN9@P_CheckCam

; 1295 : 			{
; 1296 : 				INT32 offset;
; 1297 : 				polymaplink_t *plink; // haleyjd 02/22/06
; 1298 : 
; 1299 : 				if (bx < 0 || by < 0 || bx >= bmapwidth || by >= bmapheight)

  00324	83 7d ec 00	 cmp	 DWORD PTR _bx$[ebp], 0
  00328	7c 1c		 jl	 SHORT $LN26@P_CheckCam
  0032a	83 7d e8 00	 cmp	 DWORD PTR _by$[ebp], 0
  0032e	7c 16		 jl	 SHORT $LN26@P_CheckCam
  00330	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00333	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  00339	7d 0b		 jge	 SHORT $LN26@P_CheckCam
  0033b	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0033e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  00344	7c 02		 jl	 SHORT $LN25@P_CheckCam
$LN26@P_CheckCam:

; 1300 : 					continue;

  00346	eb c7		 jmp	 SHORT $LN8@P_CheckCam
$LN25@P_CheckCam:

; 1301 : 
; 1302 : 				offset = by*bmapwidth + bx;

  00348	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0034b	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  00352	03 45 ec	 add	 eax, DWORD PTR _bx$[ebp]
  00355	89 45 d0	 mov	 DWORD PTR _offset$9[ebp], eax

; 1303 : 
; 1304 : 				// haleyjd 02/22/06: consider polyobject lines
; 1305 : 				plink = polyblocklinks[offset];

  00358	8b 45 d0	 mov	 eax, DWORD PTR _offset$9[ebp]
  0035b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _polyblocklinks
  00361	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00364	89 55 cc	 mov	 DWORD PTR _plink$8[ebp], edx
$LN35@P_CheckCam:

; 1306 : 
; 1307 : 				while (plink)

  00367	83 7d cc 00	 cmp	 DWORD PTR _plink$8[ebp], 0
  0036b	0f 84 4e 01 00
	00		 je	 $LN12@P_CheckCam

; 1308 : 				{
; 1309 : 					polyobj_t *po = plink->po;

  00371	8b 45 cc	 mov	 eax, DWORD PTR _plink$8[ebp]
  00374	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00377	89 4d c8	 mov	 DWORD PTR _po$7[ebp], ecx

; 1310 : 
; 1311 : 					if (po->validcount != validcount) // if polyobj hasn't been checked

  0037a	8b 45 c8	 mov	 eax, DWORD PTR _po$7[ebp]
  0037d	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  00383	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00389	0f 84 23 01 00
	00		 je	 $LN32@P_CheckCam

; 1312 : 					{
; 1313 : 						sector_t *polysec;
; 1314 : 						fixed_t delta1, delta2, thingtop;
; 1315 : 						fixed_t polytop, polybottom;
; 1316 : 
; 1317 : 						po->validcount = validcount;

  0038f	8b 45 c8	 mov	 eax, DWORD PTR _po$7[ebp]
  00392	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  00398	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx

; 1318 : 
; 1319 : 						if (!P_PointInsidePolyobj(po, x, y))

  0039e	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  003a1	50		 push	 eax
  003a2	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  003a5	51		 push	 ecx
  003a6	8b 55 c8	 mov	 edx, DWORD PTR _po$7[ebp]
  003a9	52		 push	 edx
  003aa	e8 00 00 00 00	 call	 _P_PointInsidePolyobj
  003af	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b2	85 c0		 test	 eax, eax
  003b4	75 0a		 jne	 SHORT $LN28@P_CheckCam

; 1320 : 						{
; 1321 : 							plink = (polymaplink_t *)(plink->link.next);

  003b6	8b 45 cc	 mov	 eax, DWORD PTR _plink$8[ebp]
  003b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003bb	89 4d cc	 mov	 DWORD PTR _plink$8[ebp], ecx

; 1322 : 							continue;

  003be	eb a7		 jmp	 SHORT $LN35@P_CheckCam
$LN28@P_CheckCam:

; 1323 : 						}
; 1324 : 
; 1325 : 						// We're inside it! Yess...
; 1326 : 						polysec = po->lines[0]->backsector;

  003c0	b8 04 00 00 00	 mov	 eax, 4
  003c5	6b c8 00	 imul	 ecx, eax, 0
  003c8	8b 55 c8	 mov	 edx, DWORD PTR _po$7[ebp]
  003cb	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  003ce	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  003d1	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  003d4	89 55 c4	 mov	 DWORD PTR _polysec$6[ebp], edx

; 1327 : 
; 1328 : 						if (po->flags & POF_CLIPPLANES)

  003d7	8b 45 c8	 mov	 eax, DWORD PTR _po$7[ebp]
  003da	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  003e0	83 e1 02	 and	 ecx, 2
  003e3	74 13		 je	 SHORT $LN29@P_CheckCam

; 1329 : 						{
; 1330 : 							polytop = polysec->ceilingheight;

  003e5	8b 45 c4	 mov	 eax, DWORD PTR _polysec$6[ebp]
  003e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003eb	89 4d b4	 mov	 DWORD PTR _polytop$2[ebp], ecx

; 1331 : 							polybottom = polysec->floorheight;

  003ee	8b 45 c4	 mov	 eax, DWORD PTR _polysec$6[ebp]
  003f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f3	89 4d b0	 mov	 DWORD PTR _polybottom$1[ebp], ecx

; 1332 : 						}

  003f6	eb 0e		 jmp	 SHORT $LN30@P_CheckCam
$LN29@P_CheckCam:

; 1333 : 						else
; 1334 : 						{
; 1335 : 							polytop = INT32_MAX;

  003f8	c7 45 b4 ff ff
	ff 7f		 mov	 DWORD PTR _polytop$2[ebp], 2147483647 ; 7fffffffH

; 1336 : 							polybottom = INT32_MIN;

  003ff	c7 45 b0 00 00
	00 80		 mov	 DWORD PTR _polybottom$1[ebp], -2147483648 ; 80000000H
$LN30@P_CheckCam:

; 1337 : 						}
; 1338 : 
; 1339 : 						thingtop = thiscam->z + thiscam->height;

  00406	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00409	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0040c	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  0040f	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  00412	89 4d b8	 mov	 DWORD PTR _thingtop$3[ebp], ecx

; 1340 : 						delta1 = thiscam->z - (polybottom + ((polytop - polybottom)/2));

  00415	8b 45 b4	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00418	2b 45 b0	 sub	 eax, DWORD PTR _polybottom$1[ebp]
  0041b	99		 cdq
  0041c	2b c2		 sub	 eax, edx
  0041e	d1 f8		 sar	 eax, 1
  00420	03 45 b0	 add	 eax, DWORD PTR _polybottom$1[ebp]
  00423	8b 4d 10	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00426	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00429	2b d0		 sub	 edx, eax
  0042b	89 55 c0	 mov	 DWORD PTR _delta1$5[ebp], edx

; 1341 : 						delta2 = thingtop - (polybottom + ((polytop - polybottom)/2));

  0042e	8b 45 b4	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00431	2b 45 b0	 sub	 eax, DWORD PTR _polybottom$1[ebp]
  00434	99		 cdq
  00435	2b c2		 sub	 eax, edx
  00437	d1 f8		 sar	 eax, 1
  00439	03 45 b0	 add	 eax, DWORD PTR _polybottom$1[ebp]
  0043c	8b 4d b8	 mov	 ecx, DWORD PTR _thingtop$3[ebp]
  0043f	2b c8		 sub	 ecx, eax
  00441	89 4d bc	 mov	 DWORD PTR _delta2$4[ebp], ecx

; 1342 : 
; 1343 : 						if (polytop > tmfloorz && abs(delta1) < abs(delta2))

  00444	8b 45 b4	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00447	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmfloorz
  0044d	7e 32		 jle	 SHORT $LN31@P_CheckCam
  0044f	8b 45 c0	 mov	 eax, DWORD PTR _delta1$5[ebp]
  00452	50		 push	 eax
  00453	e8 00 00 00 00	 call	 _abs
  00458	83 c4 04	 add	 esp, 4
  0045b	8b f0		 mov	 esi, eax
  0045d	8b 4d bc	 mov	 ecx, DWORD PTR _delta2$4[ebp]
  00460	51		 push	 ecx
  00461	e8 00 00 00 00	 call	 _abs
  00466	83 c4 04	 add	 esp, 4
  00469	3b f0		 cmp	 esi, eax
  0046b	7d 14		 jge	 SHORT $LN31@P_CheckCam

; 1344 : 							tmfloorz = tmdropoffz = polytop;

  0046d	8b 45 b4	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00470	a3 00 00 00 00	 mov	 DWORD PTR _tmdropoffz, eax
  00475	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmdropoffz
  0047b	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmfloorz, ecx
$LN31@P_CheckCam:

; 1345 : 
; 1346 : 						if (polybottom < tmceilingz && abs(delta1) >= abs(delta2))

  00481	8b 45 b0	 mov	 eax, DWORD PTR _polybottom$1[ebp]
  00484	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmceilingz
  0048a	7d 26		 jge	 SHORT $LN32@P_CheckCam
  0048c	8b 45 c0	 mov	 eax, DWORD PTR _delta1$5[ebp]
  0048f	50		 push	 eax
  00490	e8 00 00 00 00	 call	 _abs
  00495	83 c4 04	 add	 esp, 4
  00498	8b f0		 mov	 esi, eax
  0049a	8b 4d bc	 mov	 ecx, DWORD PTR _delta2$4[ebp]
  0049d	51		 push	 ecx
  0049e	e8 00 00 00 00	 call	 _abs
  004a3	83 c4 04	 add	 esp, 4
  004a6	3b f0		 cmp	 esi, eax
  004a8	7c 08		 jl	 SHORT $LN32@P_CheckCam

; 1347 : 							tmceilingz = polybottom;

  004aa	8b 45 b0	 mov	 eax, DWORD PTR _polybottom$1[ebp]
  004ad	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax
$LN32@P_CheckCam:

; 1348 : 					}
; 1349 : 					plink = (polymaplink_t *)(plink->link.next);

  004b2	8b 45 cc	 mov	 eax, DWORD PTR _plink$8[ebp]
  004b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b7	89 4d cc	 mov	 DWORD PTR _plink$8[ebp], ecx

; 1350 : 				}

  004ba	e9 a8 fe ff ff	 jmp	 $LN35@P_CheckCam
$LN12@P_CheckCam:

; 1351 : 			}

  004bf	e9 4b fe ff ff	 jmp	 $LN8@P_CheckCam
$LN9@P_CheckCam:
  004c4	e9 29 fe ff ff	 jmp	 $LN5@P_CheckCam
$LN6@P_CheckCam:

; 1352 : 	}
; 1353 : #endif
; 1354 : 
; 1355 : 	// Check things.
; 1356 : 	// The bounding box is extended by MAXRADIUS
; 1357 : 	// because mobj_ts are grouped into mapblocks
; 1358 : 	// based on their origin point, and can overlap
; 1359 : 	// into adjacent blocks by up to MAXRADIUS units.
; 1360 : 
; 1361 : 	// check lines
; 1362 : 	xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx)>>MAPBLOCKSHIFT;

  004c9	b8 04 00 00 00	 mov	 eax, 4
  004ce	d1 e0		 shl	 eax, 1
  004d0	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  004d6	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  004dc	c1 e9 17	 shr	 ecx, 23			; 00000017H
  004df	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 1363 : 	xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx)>>MAPBLOCKSHIFT;

  004e2	b8 04 00 00 00	 mov	 eax, 4
  004e7	6b c8 03	 imul	 ecx, eax, 3
  004ea	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  004f0	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  004f6	c1 ea 17	 shr	 edx, 23			; 00000017H
  004f9	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 1364 : 	yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy)>>MAPBLOCKSHIFT;

  004fc	b8 04 00 00 00	 mov	 eax, 4
  00501	c1 e0 00	 shl	 eax, 0
  00504	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  0050a	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  00510	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00513	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 1365 : 	yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy)>>MAPBLOCKSHIFT;

  00516	b8 04 00 00 00	 mov	 eax, 4
  0051b	6b c8 00	 imul	 ecx, eax, 0
  0051e	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  00524	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  0052a	c1 ea 17	 shr	 edx, 23			; 00000017H
  0052d	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 1366 : 
; 1367 : 	for (bx = xl; bx <= xh; bx++)

  00530	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  00533	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  00536	eb 09		 jmp	 SHORT $LN15@P_CheckCam
$LN13@P_CheckCam:
  00538	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0053b	83 c0 01	 add	 eax, 1
  0053e	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN15@P_CheckCam:
  00541	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00544	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  00547	7f 3a		 jg	 SHORT $LN14@P_CheckCam

; 1368 : 		for (by = yl; by <= yh; by++)

  00549	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  0054c	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  0054f	eb 09		 jmp	 SHORT $LN18@P_CheckCam
$LN16@P_CheckCam:
  00551	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00554	83 c0 01	 add	 eax, 1
  00557	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN18@P_CheckCam:
  0055a	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0055d	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  00560	7f 1f		 jg	 SHORT $LN17@P_CheckCam

; 1369 : 			if (!P_BlockLinesIterator(bx, by, PIT_CheckCameraLine))

  00562	68 00 00 00 00	 push	 OFFSET _PIT_CheckCameraLine
  00567	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0056a	50		 push	 eax
  0056b	8b 4d ec	 mov	 ecx, DWORD PTR _bx$[ebp]
  0056e	51		 push	 ecx
  0056f	e8 00 00 00 00	 call	 _P_BlockLinesIterator
  00574	83 c4 0c	 add	 esp, 12			; 0000000cH
  00577	85 c0		 test	 eax, eax
  00579	75 04		 jne	 SHORT $LN33@P_CheckCam

; 1370 : 				return false;

  0057b	33 c0		 xor	 eax, eax
  0057d	eb 09		 jmp	 SHORT $LN1@P_CheckCam
$LN33@P_CheckCam:
  0057f	eb d0		 jmp	 SHORT $LN16@P_CheckCam
$LN17@P_CheckCam:

; 1371 : 
; 1372 : 	return true;

  00581	eb b5		 jmp	 SHORT $LN13@P_CheckCam
$LN14@P_CheckCam:
  00583	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_CheckCam:

; 1373 : }

  00588	5f		 pop	 edi
  00589	5e		 pop	 esi
  0058a	5b		 pop	 ebx
  0058b	8b e5		 mov	 esp, ebp
  0058d	5d		 pop	 ebp
  0058e	c3		 ret	 0
_P_CheckCameraPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CheckPosition
_TEXT	SEGMENT
_polybottom$1 = -84					; size = 4
_polytop$2 = -80					; size = 4
_thingtop$3 = -76					; size = 4
_delta2$4 = -72						; size = 4
_delta1$5 = -68						; size = 4
_polysec$6 = -64					; size = 4
_po$7 = -60						; size = 4
_plink$8 = -56						; size = 4
_offset$9 = -52						; size = 4
_thingtop$10 = -48					; size = 4
_delta2$11 = -44					; size = 4
_delta1$12 = -40					; size = 4
_rover$13 = -36						; size = 4
_blockval$ = -32					; size = 4
_newsubsec$ = -28					; size = 4
_by$ = -24						; size = 4
_bx$ = -20						; size = 4
_yh$ = -16						; size = 4
_yl$ = -12						; size = 4
_xh$ = -8						; size = 4
_xl$ = -4						; size = 4
_thing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_P_CheckPosition PROC					; COMDAT

; 994  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 995  : 	INT32 xl, xh, yl, yh, bx, by;
; 996  : 	subsector_t *newsubsec;
; 997  : 	boolean blockval = true;

  0000c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _blockval$[ebp], 1

; 998  : 
; 999  : 	tmthing = thing;

  00013	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00016	a3 00 00 00 00	 mov	 DWORD PTR _tmthing, eax

; 1000 : 	tmflags = thing->flags;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0001e	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00021	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmflags, ecx

; 1001 : 
; 1002 : 	tmx = x;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR _tmx, eax

; 1003 : 	tmy = y;

  0002f	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00032	a3 00 00 00 00	 mov	 DWORD PTR _tmy, eax

; 1004 : 
; 1005 : 	tmbbox[BOXTOP] = y + tmthing->radius;

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0003f	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	6b c2 00	 imul	 eax, edx, 0
  0004a	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 1006 : 	tmbbox[BOXBOTTOM] = y - tmthing->radius;

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00058	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  0005b	ba 04 00 00 00	 mov	 edx, 4
  00060	c1 e2 00	 shl	 edx, 0
  00063	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 1007 : 	tmbbox[BOXRIGHT] = x + tmthing->radius;

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00071	03 48 40	 add	 ecx, DWORD PTR [eax+64]
  00074	ba 04 00 00 00	 mov	 edx, 4
  00079	6b c2 03	 imul	 eax, edx, 3
  0007c	89 88 00 00 00
	00		 mov	 DWORD PTR _tmbbox[eax], ecx

; 1008 : 	tmbbox[BOXLEFT] = x - tmthing->radius;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmthing
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0008a	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  0008d	ba 04 00 00 00	 mov	 edx, 4
  00092	d1 e2		 shl	 edx, 1
  00094	89 8a 00 00 00
	00		 mov	 DWORD PTR _tmbbox[edx], ecx

; 1009 : 
; 1010 : 	newsubsec = R_PointInSubsector(x, y);

  0009a	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 _R_PointInSubsector
  000a7	83 c4 08	 add	 esp, 8
  000aa	89 45 e4	 mov	 DWORD PTR _newsubsec$[ebp], eax

; 1011 : 	ceilingline = blockingline = NULL;

  000ad	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _blockingline, 0
  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _blockingline
  000bc	a3 00 00 00 00	 mov	 DWORD PTR _ceilingline, eax

; 1012 : 
; 1013 : 	// The base floor / ceiling is from the subsector
; 1014 : 	// that contains the point.
; 1015 : 	// Any contacted lines the step closer together
; 1016 : 	// will adjust them.
; 1017 : 	tmfloorz = tmsectorfloorz = tmdropoffz = newsubsec->sector->floorheight;

  000c1	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c8	89 15 00 00 00
	00		 mov	 DWORD PTR _tmdropoffz, edx
  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmdropoffz
  000d3	a3 00 00 00 00	 mov	 DWORD PTR _tmsectorfloorz, eax
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmsectorfloorz
  000de	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmfloorz, ecx

; 1018 : 	tmceilingz = tmsectorceilingz = newsubsec->sector->ceilingheight;

  000e4	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ec	89 15 00 00 00
	00		 mov	 DWORD PTR _tmsectorceilingz, edx
  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmsectorceilingz
  000f7	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax

; 1019 : 
; 1020 : 	// Check list of fake floors and see if tmfloorz/tmceilingz need to be altered.
; 1021 : 	if (newsubsec->sector->ffloors)

  000fc	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  000ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00101	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [ecx+144], 0
  00108	0f 84 27 03 00
	00		 je	 $LN3@P_CheckPos

; 1022 : 	{
; 1023 : 		ffloor_t *rover;
; 1024 : 		fixed_t delta1, delta2;
; 1025 : 		INT32 thingtop = thing->z + thing->height;

  0010e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00111	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00114	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00117	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  0011a	89 4d d0	 mov	 DWORD PTR _thingtop$10[ebp], ecx

; 1026 : 
; 1027 : 		for (rover = newsubsec->sector->ffloors; rover; rover = rover->next)

  0011d	8b 45 e4	 mov	 eax, DWORD PTR _newsubsec$[ebp]
  00120	8b 08		 mov	 ecx, DWORD PTR [eax]
  00122	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00128	89 55 dc	 mov	 DWORD PTR _rover$13[ebp], edx
  0012b	eb 09		 jmp	 SHORT $LN4@P_CheckPos
$LN2@P_CheckPos:
  0012d	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00130	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00133	89 4d dc	 mov	 DWORD PTR _rover$13[ebp], ecx
$LN4@P_CheckPos:
  00136	83 7d dc 00	 cmp	 DWORD PTR _rover$13[ebp], 0
  0013a	0f 84 f5 02 00
	00		 je	 $LN3@P_CheckPos

; 1028 : 		{
; 1029 : 			if (!(rover->flags & FF_EXISTS))

  00140	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00143	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00146	83 e1 01	 and	 ecx, 1
  00149	75 02		 jne	 SHORT $LN26@P_CheckPos

; 1030 : 				continue;

  0014b	eb e0		 jmp	 SHORT $LN2@P_CheckPos
$LN26@P_CheckPos:

; 1031 : 
; 1032 : 			if (thing->player && (rover->flags & FF_SWIMMABLE) && GETSECSPECIAL(rover->master->frontsector->special, 1) == 3
; 1033 : 				&& !(rover->master->flags & ML_BLOCKMONSTERS) && ((rover->master->flags & ML_EFFECT3)

  0014d	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00150	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00157	74 62		 je	 SHORT $LN27@P_CheckPos
  00159	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  0015c	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0015f	83 e1 20	 and	 ecx, 32			; 00000020H
  00162	74 57		 je	 SHORT $LN27@P_CheckPos
  00164	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00167	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0016a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0016d	0f bf 42 12	 movsx	 eax, WORD PTR [edx+18]
  00171	83 e0 0f	 and	 eax, 15			; 0000000fH
  00174	83 f8 03	 cmp	 eax, 3
  00177	75 42		 jne	 SHORT $LN27@P_CheckPos
  00179	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  0017c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0017f	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00183	83 e2 02	 and	 edx, 2
  00186	75 33		 jne	 SHORT $LN27@P_CheckPos
  00188	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  0018b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0018e	0f bf 51 10	 movsx	 edx, WORD PTR [ecx+16]
  00192	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00198	75 1c		 jne	 SHORT $LN29@P_CheckPos
  0019a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0019d	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  001a0	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  001a3	2b 51 50	 sub	 edx, DWORD PTR [ecx+80]
  001a6	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  001a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  001ad	2d 00 00 10 00	 sub	 eax, 1048576		; 00100000H
  001b2	3b d0		 cmp	 edx, eax
  001b4	7e 05		 jle	 SHORT $LN27@P_CheckPos
$LN29@P_CheckPos:

; 1034 : 				|| thing->z-thing->momz > *rover->topheight - 16*FRACUNIT))
; 1035 : 				;

  001b6	e9 3b 01 00 00	 jmp	 $LN33@P_CheckPos
$LN27@P_CheckPos:

; 1036 : 			else if (!((((rover->flags & FF_BLOCKPLAYER) && thing->player)

  001bb	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  001be	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001c1	83 e1 02	 and	 ecx, 2
  001c4	74 10		 je	 SHORT $LN31@P_CheckPos
  001c6	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001c9	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001d0	0f 85 20 01 00
	00		 jne	 $LN33@P_CheckPos
$LN31@P_CheckPos:
  001d6	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  001d9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001dc	83 e1 04	 and	 ecx, 4
  001df	74 10		 je	 SHORT $LN32@P_CheckPos
  001e1	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  001e4	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  001eb	0f 84 05 01 00
	00		 je	 $LN33@P_CheckPos
$LN32@P_CheckPos:
  001f1	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  001f4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001f7	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  001fd	0f 85 f3 00 00
	00		 jne	 $LN33@P_CheckPos

; 1037 : 				|| ((rover->flags & FF_BLOCKOTHERS) && !thing->player)) || rover->flags & FF_QUICKSAND))
; 1038 : 			{
; 1039 : 				if (!(thing->player && !(thing->player->pflags & PF_NIGHTSMODE) && (((thing->player->charability == CA_SWIM) || thing->player->powers[pw_super]) && thing->ceilingz-*rover->topheight >= thing->height)
; 1040 : 					&& !(thing->player->pflags & PF_SPINNING) && thing->player->speed > thing->player->runspeed
; 1041 : /*					&& thing->ceilingz - *rover->topheight >= thing->height*/
; 1042 : 					&& thing->z < *rover->topheight + 30*FRACUNIT
; 1043 : 					&& thing->z > *rover->topheight - 30*FRACUNIT
; 1044 : 					&& (rover->flags & FF_SWIMMABLE))
; 1045 : 					&& (!(thing->type == MT_SKIM && (rover->flags & FF_SWIMMABLE))))

  00203	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00206	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  0020d	0f 84 ca 00 00
	00		 je	 $LN34@P_CheckPos
  00213	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00216	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0021c	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00222	81 e2 00 00 20
	00		 and	 edx, 2097152		; 00200000H
  00228	0f 85 af 00 00
	00		 jne	 $LN34@P_CheckPos
  0022e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00231	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00237	83 b9 d8 00 00
	00 06		 cmp	 DWORD PTR [ecx+216], 6
  0023e	74 1c		 je	 SHORT $LN35@P_CheckPos
  00240	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00243	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00249	ba 04 00 00 00	 mov	 edx, 4
  0024e	6b c2 0f	 imul	 eax, edx, 15
  00251	83 7c 01 38 00	 cmp	 DWORD PTR [ecx+eax+56], 0
  00256	0f 84 81 00 00
	00		 je	 $LN34@P_CheckPos
$LN35@P_CheckPos:
  0025c	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  0025f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00261	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00264	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00267	2b 01		 sub	 eax, DWORD PTR [ecx]
  00269	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0026c	3b 41 44	 cmp	 eax, DWORD PTR [ecx+68]
  0026f	7c 6c		 jl	 SHORT $LN34@P_CheckPos
  00271	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00274	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0027a	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00280	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00286	75 55		 jne	 SHORT $LN34@P_CheckPos
  00288	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0028b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00291	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00294	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0029a	8b 89 0c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+268]
  002a0	3b 88 c8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+200]
  002a6	7e 35		 jle	 SHORT $LN34@P_CheckPos
  002a8	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  002ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  002af	81 c2 00 00 1e
	00		 add	 edx, 1966080		; 001e0000H
  002b5	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002b8	39 50 18	 cmp	 DWORD PTR [eax+24], edx
  002bb	7d 20		 jge	 SHORT $LN34@P_CheckPos
  002bd	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  002c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c4	81 ea 00 00 1e
	00		 sub	 edx, 1966080		; 001e0000H
  002ca	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002cd	39 50 18	 cmp	 DWORD PTR [eax+24], edx
  002d0	7e 0b		 jle	 SHORT $LN34@P_CheckPos
  002d2	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  002d5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002d8	83 e1 20	 and	 ecx, 32			; 00000020H
  002db	75 19		 jne	 SHORT $LN33@P_CheckPos
$LN34@P_CheckPos:
  002dd	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  002e0	83 78 7c 0a	 cmp	 DWORD PTR [eax+124], 10	; 0000000aH
  002e4	75 0b		 jne	 SHORT $LN36@P_CheckPos
  002e6	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  002e9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002ec	83 e1 20	 and	 ecx, 32			; 00000020H
  002ef	75 05		 jne	 SHORT $LN33@P_CheckPos
$LN36@P_CheckPos:

; 1046 : 					continue;

  002f1	e9 37 fe ff ff	 jmp	 $LN2@P_CheckPos
$LN33@P_CheckPos:

; 1047 : 			}
; 1048 : 
; 1049 : 			if (rover->flags & FF_QUICKSAND)

  002f6	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  002f9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002fc	81 e1 00 00 00
	01		 and	 ecx, 16777216		; 01000000H
  00302	74 2d		 je	 SHORT $LN38@P_CheckPos

; 1050 : 			{
; 1051 : 				if (thing->z < *rover->topheight && *rover->bottomheight < thingtop)

  00304	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00307	8b 08		 mov	 ecx, DWORD PTR [eax]
  00309	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0030c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0030f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00311	7d 1e		 jge	 SHORT $LN38@P_CheckPos
  00313	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00316	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00319	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031b	3b 55 d0	 cmp	 edx, DWORD PTR _thingtop$10[ebp]
  0031e	7d 11		 jge	 SHORT $LN38@P_CheckPos

; 1052 : 				{
; 1053 : 					tmfloorz = thing->z;

  00320	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00323	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00326	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmfloorz, ecx

; 1054 : 					continue;

  0032c	e9 fc fd ff ff	 jmp	 $LN2@P_CheckPos
$LN38@P_CheckPos:

; 1055 : 				}
; 1056 : 			}
; 1057 : 
; 1058 : 			delta1 = thing->z - (*rover->bottomheight

  00331	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00334	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00337	8b 55 dc	 mov	 edx, DWORD PTR _rover$13[ebp]
  0033a	8b 02		 mov	 eax, DWORD PTR [edx]
  0033c	8b 55 dc	 mov	 edx, DWORD PTR _rover$13[ebp]
  0033f	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00342	8b 00		 mov	 eax, DWORD PTR [eax]
  00344	2b 02		 sub	 eax, DWORD PTR [edx]
  00346	99		 cdq
  00347	2b c2		 sub	 eax, edx
  00349	d1 f8		 sar	 eax, 1
  0034b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0034d	03 c8		 add	 ecx, eax
  0034f	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00352	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00355	2b c1		 sub	 eax, ecx
  00357	89 45 d8	 mov	 DWORD PTR _delta1$12[ebp], eax

; 1059 : 				+ ((*rover->topheight - *rover->bottomheight)/2));
; 1060 : 			delta2 = thingtop - (*rover->bottomheight

  0035a	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  0035d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00360	8b 55 dc	 mov	 edx, DWORD PTR _rover$13[ebp]
  00363	8b 02		 mov	 eax, DWORD PTR [edx]
  00365	8b 55 dc	 mov	 edx, DWORD PTR _rover$13[ebp]
  00368	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  0036b	8b 00		 mov	 eax, DWORD PTR [eax]
  0036d	2b 02		 sub	 eax, DWORD PTR [edx]
  0036f	99		 cdq
  00370	2b c2		 sub	 eax, edx
  00372	d1 f8		 sar	 eax, 1
  00374	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00376	03 c8		 add	 ecx, eax
  00378	8b 55 d0	 mov	 edx, DWORD PTR _thingtop$10[ebp]
  0037b	2b d1		 sub	 edx, ecx
  0037d	89 55 d4	 mov	 DWORD PTR _delta2$11[ebp], edx

; 1061 : 				+ ((*rover->topheight - *rover->bottomheight)/2));
; 1062 : 
; 1063 : 			if (*rover->topheight > tmfloorz && abs(delta1) < abs(delta2)
; 1064 : 				&& (!(rover->flags & FF_REVERSEPLATFORM)))

  00380	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00383	8b 08		 mov	 ecx, DWORD PTR [eax]
  00385	8b 11		 mov	 edx, DWORD PTR [ecx]
  00387	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _tmfloorz
  0038d	7e 43		 jle	 SHORT $LN39@P_CheckPos
  0038f	8b 45 d8	 mov	 eax, DWORD PTR _delta1$12[ebp]
  00392	50		 push	 eax
  00393	e8 00 00 00 00	 call	 _abs
  00398	83 c4 04	 add	 esp, 4
  0039b	8b f0		 mov	 esi, eax
  0039d	8b 4d d4	 mov	 ecx, DWORD PTR _delta2$11[ebp]
  003a0	51		 push	 ecx
  003a1	e8 00 00 00 00	 call	 _abs
  003a6	83 c4 04	 add	 esp, 4
  003a9	3b f0		 cmp	 esi, eax
  003ab	7d 25		 jge	 SHORT $LN39@P_CheckPos
  003ad	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  003b0	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003b3	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  003b9	75 17		 jne	 SHORT $LN39@P_CheckPos

; 1065 : 			{
; 1066 : 				tmfloorz = tmdropoffz = *rover->topheight;

  003bb	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  003be	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  003c2	89 15 00 00 00
	00		 mov	 DWORD PTR _tmdropoffz, edx
  003c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmdropoffz
  003cd	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax
$LN39@P_CheckPos:

; 1067 : 			}
; 1068 : 			if (*rover->bottomheight < tmceilingz && abs(delta1) >= abs(delta2)
; 1069 : 				&& (/*thing->z + thing->height <= *rover->bottomheight
; 1070 : 					|| */!(rover->flags & FF_PLATFORM))
; 1071 : 				&& !(thing->type == MT_SKIM	&& (rover->flags & FF_SWIMMABLE)))

  003d2	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  003d5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  003da	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _tmceilingz
  003e0	7d 4e		 jge	 SHORT $LN40@P_CheckPos
  003e2	8b 45 d8	 mov	 eax, DWORD PTR _delta1$12[ebp]
  003e5	50		 push	 eax
  003e6	e8 00 00 00 00	 call	 _abs
  003eb	83 c4 04	 add	 esp, 4
  003ee	8b f0		 mov	 esi, eax
  003f0	8b 4d d4	 mov	 ecx, DWORD PTR _delta2$11[ebp]
  003f3	51		 push	 ecx
  003f4	e8 00 00 00 00	 call	 _abs
  003f9	83 c4 04	 add	 esp, 4
  003fc	3b f0		 cmp	 esi, eax
  003fe	7c 30		 jl	 SHORT $LN40@P_CheckPos
  00400	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00403	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00406	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  0040c	75 22		 jne	 SHORT $LN40@P_CheckPos
  0040e	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00411	83 78 7c 0a	 cmp	 DWORD PTR [eax+124], 10	; 0000000aH
  00415	75 0b		 jne	 SHORT $LN41@P_CheckPos
  00417	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  0041a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0041d	83 e1 20	 and	 ecx, 32			; 00000020H
  00420	75 0e		 jne	 SHORT $LN40@P_CheckPos
$LN41@P_CheckPos:

; 1072 : 			{
; 1073 : 				tmceilingz = *rover->bottomheight;

  00422	8b 45 dc	 mov	 eax, DWORD PTR _rover$13[ebp]
  00425	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00428	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042a	89 15 00 00 00
	00		 mov	 DWORD PTR _tmceilingz, edx
$LN40@P_CheckPos:

; 1074 : 			}
; 1075 : 		}

  00430	e9 f8 fc ff ff	 jmp	 $LN2@P_CheckPos
$LN3@P_CheckPos:

; 1076 : 	}
; 1077 : 
; 1078 : #ifdef POLYOBJECTS
; 1079 : 	// Check polyobjects and see if tmfloorz/tmceilingz need to be altered
; 1080 : 	{
; 1081 : 		validcount++;

  00435	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  0043a	83 c0 01	 add	 eax, 1
  0043d	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 1082 : 
; 1083 : 		xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;

  00442	b8 04 00 00 00	 mov	 eax, 4
  00447	d1 e0		 shl	 eax, 1
  00449	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  0044f	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  00455	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  0045b	c1 e9 17	 shr	 ecx, 23			; 00000017H
  0045e	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 1084 : 		xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;

  00461	b8 04 00 00 00	 mov	 eax, 4
  00466	6b c8 03	 imul	 ecx, eax, 3
  00469	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  0046f	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  00475	81 c2 00 00 20
	00		 add	 edx, 2097152		; 00200000H
  0047b	c1 ea 17	 shr	 edx, 23			; 00000017H
  0047e	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 1085 : 		yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;

  00481	b8 04 00 00 00	 mov	 eax, 4
  00486	c1 e0 00	 shl	 eax, 0
  00489	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  0048f	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  00495	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  0049b	c1 e9 17	 shr	 ecx, 23			; 00000017H
  0049e	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 1086 : 		yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;

  004a1	b8 04 00 00 00	 mov	 eax, 4
  004a6	6b c8 00	 imul	 ecx, eax, 0
  004a9	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  004af	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  004b5	81 c2 00 00 20
	00		 add	 edx, 2097152		; 00200000H
  004bb	c1 ea 17	 shr	 edx, 23			; 00000017H
  004be	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 1087 : 
; 1088 : 		for (by = yl; by <= yh; by++)

  004c1	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  004c4	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  004c7	eb 09		 jmp	 SHORT $LN7@P_CheckPos
$LN5@P_CheckPos:
  004c9	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  004cc	83 c0 01	 add	 eax, 1
  004cf	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN7@P_CheckPos:
  004d2	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  004d5	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  004d8	0f 8f cd 01 00
	00		 jg	 $LN6@P_CheckPos

; 1089 : 			for (bx = xl; bx <= xh; bx++)

  004de	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  004e1	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  004e4	eb 09		 jmp	 SHORT $LN10@P_CheckPos
$LN8@P_CheckPos:
  004e6	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  004e9	83 c0 01	 add	 eax, 1
  004ec	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN10@P_CheckPos:
  004ef	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  004f2	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  004f5	0f 8f ab 01 00
	00		 jg	 $LN9@P_CheckPos

; 1090 : 			{
; 1091 : 				INT32 offset;
; 1092 : 				polymaplink_t *plink; // haleyjd 02/22/06
; 1093 : 
; 1094 : 				if (bx < 0 || by < 0 || bx >= bmapwidth || by >= bmapheight)

  004fb	83 7d ec 00	 cmp	 DWORD PTR _bx$[ebp], 0
  004ff	7c 1c		 jl	 SHORT $LN43@P_CheckPos
  00501	83 7d e8 00	 cmp	 DWORD PTR _by$[ebp], 0
  00505	7c 16		 jl	 SHORT $LN43@P_CheckPos
  00507	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0050a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapwidth
  00510	7d 0b		 jge	 SHORT $LN43@P_CheckPos
  00512	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00515	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _bmapheight
  0051b	7c 02		 jl	 SHORT $LN42@P_CheckPos
$LN43@P_CheckPos:

; 1095 : 					continue;

  0051d	eb c7		 jmp	 SHORT $LN8@P_CheckPos
$LN42@P_CheckPos:

; 1096 : 
; 1097 : 				offset = by*bmapwidth + bx;

  0051f	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00522	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR _bmapwidth
  00529	03 45 ec	 add	 eax, DWORD PTR _bx$[ebp]
  0052c	89 45 cc	 mov	 DWORD PTR _offset$9[ebp], eax

; 1098 : 
; 1099 : 				// haleyjd 02/22/06: consider polyobject lines
; 1100 : 				plink = polyblocklinks[offset];

  0052f	8b 45 cc	 mov	 eax, DWORD PTR _offset$9[ebp]
  00532	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _polyblocklinks
  00538	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0053b	89 55 c8	 mov	 DWORD PTR _plink$8[ebp], edx
$LN56@P_CheckPos:

; 1101 : 
; 1102 : 				while (plink)

  0053e	83 7d c8 00	 cmp	 DWORD PTR _plink$8[ebp], 0
  00542	0f 84 59 01 00
	00		 je	 $LN12@P_CheckPos

; 1103 : 				{
; 1104 : 					polyobj_t *po = plink->po;

  00548	8b 45 c8	 mov	 eax, DWORD PTR _plink$8[ebp]
  0054b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0054e	89 4d c4	 mov	 DWORD PTR _po$7[ebp], ecx

; 1105 : 
; 1106 : 					if (po->validcount != validcount) // if polyobj hasn't been checked

  00551	8b 45 c4	 mov	 eax, DWORD PTR _po$7[ebp]
  00554	8b 88 8c 00 00
	00		 mov	 ecx, DWORD PTR [eax+140]
  0055a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _validcount
  00560	0f 84 2e 01 00
	00		 je	 $LN50@P_CheckPos

; 1107 : 					{
; 1108 : 						sector_t *polysec;
; 1109 : 						fixed_t delta1, delta2, thingtop;
; 1110 : 						fixed_t polytop, polybottom;
; 1111 : 
; 1112 : 						po->validcount = validcount;

  00566	8b 45 c4	 mov	 eax, DWORD PTR _po$7[ebp]
  00569	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _validcount
  0056f	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx

; 1113 : 
; 1114 : 						if (!P_BBoxInsidePolyobj(po, tmbbox)
; 1115 : 							|| !(po->flags & POF_SOLID))

  00575	68 00 00 00 00	 push	 OFFSET _tmbbox
  0057a	8b 45 c4	 mov	 eax, DWORD PTR _po$7[ebp]
  0057d	50		 push	 eax
  0057e	e8 00 00 00 00	 call	 _P_BBoxInsidePolyobj
  00583	83 c4 08	 add	 esp, 8
  00586	85 c0		 test	 eax, eax
  00588	74 0e		 je	 SHORT $LN46@P_CheckPos
  0058a	8b 45 c4	 mov	 eax, DWORD PTR _po$7[ebp]
  0058d	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  00593	83 e1 03	 and	 ecx, 3
  00596	75 0a		 jne	 SHORT $LN45@P_CheckPos
$LN46@P_CheckPos:

; 1116 : 						{
; 1117 : 							plink = (polymaplink_t *)(plink->link.next);

  00598	8b 45 c8	 mov	 eax, DWORD PTR _plink$8[ebp]
  0059b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0059d	89 4d c8	 mov	 DWORD PTR _plink$8[ebp], ecx

; 1118 : 							continue;

  005a0	eb 9c		 jmp	 SHORT $LN56@P_CheckPos
$LN45@P_CheckPos:

; 1119 : 						}
; 1120 : 
; 1121 : 						// We're inside it! Yess...
; 1122 : 						polysec = po->lines[0]->backsector;

  005a2	b8 04 00 00 00	 mov	 eax, 4
  005a7	6b c8 00	 imul	 ecx, eax, 0
  005aa	8b 55 c4	 mov	 edx, DWORD PTR _po$7[ebp]
  005ad	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  005b0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  005b3	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  005b6	89 55 c0	 mov	 DWORD PTR _polysec$6[ebp], edx

; 1123 : 
; 1124 : 						if (po->flags & POF_CLIPPLANES)

  005b9	8b 45 c4	 mov	 eax, DWORD PTR _po$7[ebp]
  005bc	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  005c2	83 e1 02	 and	 ecx, 2
  005c5	74 13		 je	 SHORT $LN47@P_CheckPos

; 1125 : 						{
; 1126 : 							polytop = polysec->ceilingheight;

  005c7	8b 45 c0	 mov	 eax, DWORD PTR _polysec$6[ebp]
  005ca	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005cd	89 4d b0	 mov	 DWORD PTR _polytop$2[ebp], ecx

; 1127 : 							polybottom = polysec->floorheight;

  005d0	8b 45 c0	 mov	 eax, DWORD PTR _polysec$6[ebp]
  005d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  005d5	89 4d ac	 mov	 DWORD PTR _polybottom$1[ebp], ecx

; 1128 : 						}

  005d8	eb 0e		 jmp	 SHORT $LN48@P_CheckPos
$LN47@P_CheckPos:

; 1129 : 						else
; 1130 : 						{
; 1131 : 							polytop = INT32_MAX;

  005da	c7 45 b0 ff ff
	ff 7f		 mov	 DWORD PTR _polytop$2[ebp], 2147483647 ; 7fffffffH

; 1132 : 							polybottom = INT32_MIN;

  005e1	c7 45 ac 00 00
	00 80		 mov	 DWORD PTR _polybottom$1[ebp], -2147483648 ; 80000000H
$LN48@P_CheckPos:

; 1133 : 						}
; 1134 : 
; 1135 : 						thingtop = thing->z + thing->height;

  005e8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  005eb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005ee	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  005f1	03 4a 44	 add	 ecx, DWORD PTR [edx+68]
  005f4	89 4d b4	 mov	 DWORD PTR _thingtop$3[ebp], ecx

; 1136 : 						delta1 = thing->z - (polybottom + ((polytop - polybottom)/2));

  005f7	8b 45 b0	 mov	 eax, DWORD PTR _polytop$2[ebp]
  005fa	2b 45 ac	 sub	 eax, DWORD PTR _polybottom$1[ebp]
  005fd	99		 cdq
  005fe	2b c2		 sub	 eax, edx
  00600	d1 f8		 sar	 eax, 1
  00602	03 45 ac	 add	 eax, DWORD PTR _polybottom$1[ebp]
  00605	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00608	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0060b	2b d0		 sub	 edx, eax
  0060d	89 55 bc	 mov	 DWORD PTR _delta1$5[ebp], edx

; 1137 : 						delta2 = thingtop - (polybottom + ((polytop - polybottom)/2));

  00610	8b 45 b0	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00613	2b 45 ac	 sub	 eax, DWORD PTR _polybottom$1[ebp]
  00616	99		 cdq
  00617	2b c2		 sub	 eax, edx
  00619	d1 f8		 sar	 eax, 1
  0061b	03 45 ac	 add	 eax, DWORD PTR _polybottom$1[ebp]
  0061e	8b 4d b4	 mov	 ecx, DWORD PTR _thingtop$3[ebp]
  00621	2b c8		 sub	 ecx, eax
  00623	89 4d b8	 mov	 DWORD PTR _delta2$4[ebp], ecx

; 1138 : 
; 1139 : 						if (polytop > tmfloorz && abs(delta1) < abs(delta2))

  00626	8b 45 b0	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00629	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmfloorz
  0062f	7e 32		 jle	 SHORT $LN49@P_CheckPos
  00631	8b 45 bc	 mov	 eax, DWORD PTR _delta1$5[ebp]
  00634	50		 push	 eax
  00635	e8 00 00 00 00	 call	 _abs
  0063a	83 c4 04	 add	 esp, 4
  0063d	8b f0		 mov	 esi, eax
  0063f	8b 4d b8	 mov	 ecx, DWORD PTR _delta2$4[ebp]
  00642	51		 push	 ecx
  00643	e8 00 00 00 00	 call	 _abs
  00648	83 c4 04	 add	 esp, 4
  0064b	3b f0		 cmp	 esi, eax
  0064d	7d 14		 jge	 SHORT $LN49@P_CheckPos

; 1140 : 							tmfloorz = tmdropoffz = polytop;

  0064f	8b 45 b0	 mov	 eax, DWORD PTR _polytop$2[ebp]
  00652	a3 00 00 00 00	 mov	 DWORD PTR _tmdropoffz, eax
  00657	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmdropoffz
  0065d	89 0d 00 00 00
	00		 mov	 DWORD PTR _tmfloorz, ecx
$LN49@P_CheckPos:

; 1141 : 
; 1142 : 						if (polybottom < tmceilingz && abs(delta1) >= abs(delta2))

  00663	8b 45 ac	 mov	 eax, DWORD PTR _polybottom$1[ebp]
  00666	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _tmceilingz
  0066c	7d 26		 jge	 SHORT $LN50@P_CheckPos
  0066e	8b 45 bc	 mov	 eax, DWORD PTR _delta1$5[ebp]
  00671	50		 push	 eax
  00672	e8 00 00 00 00	 call	 _abs
  00677	83 c4 04	 add	 esp, 4
  0067a	8b f0		 mov	 esi, eax
  0067c	8b 4d b8	 mov	 ecx, DWORD PTR _delta2$4[ebp]
  0067f	51		 push	 ecx
  00680	e8 00 00 00 00	 call	 _abs
  00685	83 c4 04	 add	 esp, 4
  00688	3b f0		 cmp	 esi, eax
  0068a	7c 08		 jl	 SHORT $LN50@P_CheckPos

; 1143 : 							tmceilingz = polybottom;

  0068c	8b 45 ac	 mov	 eax, DWORD PTR _polybottom$1[ebp]
  0068f	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax
$LN50@P_CheckPos:

; 1144 : 					}
; 1145 : 					plink = (polymaplink_t *)(plink->link.next);

  00694	8b 45 c8	 mov	 eax, DWORD PTR _plink$8[ebp]
  00697	8b 08		 mov	 ecx, DWORD PTR [eax]
  00699	89 4d c8	 mov	 DWORD PTR _plink$8[ebp], ecx

; 1146 : 				}

  0069c	e9 9d fe ff ff	 jmp	 $LN56@P_CheckPos
$LN12@P_CheckPos:

; 1147 : 			}

  006a1	e9 40 fe ff ff	 jmp	 $LN8@P_CheckPos
$LN9@P_CheckPos:
  006a6	e9 1e fe ff ff	 jmp	 $LN5@P_CheckPos
$LN6@P_CheckPos:

; 1148 : 	}
; 1149 : #endif
; 1150 : 
; 1151 : 	// tmfloorthing is set when tmfloorz comes from a thing's top
; 1152 : 	tmfloorthing = NULL;

  006ab	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmfloorthing, 0

; 1153 : 
; 1154 : 	validcount++;

  006b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  006ba	83 c0 01	 add	 eax, 1
  006bd	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 1155 : 
; 1156 : 	if (tmflags & MF_NOCLIP)

  006c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmflags
  006c7	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  006cc	74 0a		 je	 SHORT $LN51@P_CheckPos

; 1157 : 		return true;

  006ce	b8 01 00 00 00	 mov	 eax, 1
  006d3	e9 cc 01 00 00	 jmp	 $LN1@P_CheckPos
$LN51@P_CheckPos:

; 1158 : 
; 1159 : 	// Check things first, possibly picking things up.
; 1160 : 	// The bounding box is extended by MAXRADIUS
; 1161 : 	// because mobj_ts are grouped into mapblocks
; 1162 : 	// based on their origin point, and can overlap
; 1163 : 	// into adjacent blocks by up to MAXRADIUS units.
; 1164 : 
; 1165 : 	// MF_NOCLIPTHING: used by camera to not be blocked by things
; 1166 : 	if (!(thing->flags & MF_NOCLIPTHING))

  006d8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  006db	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  006de	81 e1 00 00 00
	40		 and	 ecx, 1073741824		; 40000000H
  006e4	0f 85 d5 00 00
	00		 jne	 $LN14@P_CheckPos

; 1167 : 	{
; 1168 : 		xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;

  006ea	b8 04 00 00 00	 mov	 eax, 4
  006ef	d1 e0		 shl	 eax, 1
  006f1	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  006f7	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  006fd	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  00703	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00706	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 1169 : 		xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;

  00709	b8 04 00 00 00	 mov	 eax, 4
  0070e	6b c8 03	 imul	 ecx, eax, 3
  00711	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  00717	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  0071d	81 c2 00 00 20
	00		 add	 edx, 2097152		; 00200000H
  00723	c1 ea 17	 shr	 edx, 23			; 00000017H
  00726	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 1170 : 		yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;

  00729	b8 04 00 00 00	 mov	 eax, 4
  0072e	c1 e0 00	 shl	 eax, 0
  00731	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  00737	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  0073d	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  00743	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00746	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 1171 : 		yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;

  00749	b8 04 00 00 00	 mov	 eax, 4
  0074e	6b c8 00	 imul	 ecx, eax, 0
  00751	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  00757	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  0075d	81 c2 00 00 20
	00		 add	 edx, 2097152		; 00200000H
  00763	c1 ea 17	 shr	 edx, 23			; 00000017H
  00766	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 1172 : 
; 1173 : 		for (bx = xl; bx <= xh; bx++)

  00769	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  0076c	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  0076f	eb 09		 jmp	 SHORT $LN15@P_CheckPos
$LN13@P_CheckPos:
  00771	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00774	83 c0 01	 add	 eax, 1
  00777	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN15@P_CheckPos:
  0077a	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0077d	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  00780	7f 3d		 jg	 SHORT $LN14@P_CheckPos

; 1174 : 			for (by = yl; by <= yh; by++)

  00782	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  00785	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  00788	eb 09		 jmp	 SHORT $LN18@P_CheckPos
$LN16@P_CheckPos:
  0078a	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0078d	83 c0 01	 add	 eax, 1
  00790	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN18@P_CheckPos:
  00793	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00796	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  00799	7f 22		 jg	 SHORT $LN17@P_CheckPos

; 1175 : 				if (!P_BlockThingsIterator(bx, by, PIT_CheckThing))

  0079b	68 00 00 00 00	 push	 OFFSET _PIT_CheckThing
  007a0	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  007a3	50		 push	 eax
  007a4	8b 4d ec	 mov	 ecx, DWORD PTR _bx$[ebp]
  007a7	51		 push	 ecx
  007a8	e8 00 00 00 00	 call	 _P_BlockThingsIterator
  007ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  007b0	85 c0		 test	 eax, eax
  007b2	75 07		 jne	 SHORT $LN53@P_CheckPos

; 1176 : 					blockval = false;

  007b4	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _blockval$[ebp], 0
$LN53@P_CheckPos:
  007bb	eb cd		 jmp	 SHORT $LN16@P_CheckPos
$LN17@P_CheckPos:

; 1177 : 	}

  007bd	eb b2		 jmp	 SHORT $LN13@P_CheckPos
$LN14@P_CheckPos:

; 1178 : 
; 1179 : 	validcount++;

  007bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  007c4	83 c0 01	 add	 eax, 1
  007c7	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 1180 : 
; 1181 : 	// check lines
; 1182 : 	xl = (unsigned)(tmbbox[BOXLEFT] - bmaporgx - MAXMOVE)>>MAPBLOCKSHIFT;

  007cc	b8 04 00 00 00	 mov	 eax, 4
  007d1	d1 e0		 shl	 eax, 1
  007d3	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  007d9	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  007df	81 e9 00 00 3c
	00		 sub	 ecx, 3932160		; 003c0000H
  007e5	c1 e9 17	 shr	 ecx, 23			; 00000017H
  007e8	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 1183 : 	xh = (unsigned)(tmbbox[BOXRIGHT] - bmaporgx + MAXMOVE)>>MAPBLOCKSHIFT;

  007eb	b8 04 00 00 00	 mov	 eax, 4
  007f0	6b c8 03	 imul	 ecx, eax, 3
  007f3	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  007f9	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  007ff	81 c2 00 00 3c
	00		 add	 edx, 3932160		; 003c0000H
  00805	c1 ea 17	 shr	 edx, 23			; 00000017H
  00808	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 1184 : 	yl = (unsigned)(tmbbox[BOXBOTTOM] - bmaporgy - MAXMOVE)>>MAPBLOCKSHIFT;

  0080b	b8 04 00 00 00	 mov	 eax, 4
  00810	c1 e0 00	 shl	 eax, 0
  00813	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _tmbbox[eax]
  00819	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  0081f	81 e9 00 00 3c
	00		 sub	 ecx, 3932160		; 003c0000H
  00825	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00828	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 1185 : 	yh = (unsigned)(tmbbox[BOXTOP] - bmaporgy + MAXMOVE)>>MAPBLOCKSHIFT;

  0082b	b8 04 00 00 00	 mov	 eax, 4
  00830	6b c8 00	 imul	 ecx, eax, 0
  00833	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _tmbbox[ecx]
  00839	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  0083f	81 c2 00 00 3c
	00		 add	 edx, 3932160		; 003c0000H
  00845	c1 ea 17	 shr	 edx, 23			; 00000017H
  00848	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 1186 : 
; 1187 : 	for (bx = xl; bx <= xh; bx++)

  0084b	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  0084e	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  00851	eb 09		 jmp	 SHORT $LN21@P_CheckPos
$LN19@P_CheckPos:
  00853	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00856	83 c0 01	 add	 eax, 1
  00859	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN21@P_CheckPos:
  0085c	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0085f	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  00862	7f 3d		 jg	 SHORT $LN20@P_CheckPos

; 1188 : 		for (by = yl; by <= yh; by++)

  00864	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  00867	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  0086a	eb 09		 jmp	 SHORT $LN24@P_CheckPos
$LN22@P_CheckPos:
  0086c	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0086f	83 c0 01	 add	 eax, 1
  00872	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN24@P_CheckPos:
  00875	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00878	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  0087b	7f 22		 jg	 SHORT $LN23@P_CheckPos

; 1189 : 			if (!P_BlockLinesIterator(bx, by, PIT_CheckLine))

  0087d	68 00 00 00 00	 push	 OFFSET _PIT_CheckLine
  00882	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00885	50		 push	 eax
  00886	8b 4d ec	 mov	 ecx, DWORD PTR _bx$[ebp]
  00889	51		 push	 ecx
  0088a	e8 00 00 00 00	 call	 _P_BlockLinesIterator
  0088f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00892	85 c0		 test	 eax, eax
  00894	75 07		 jne	 SHORT $LN54@P_CheckPos

; 1190 : 				blockval = false;

  00896	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _blockval$[ebp], 0
$LN54@P_CheckPos:
  0089d	eb cd		 jmp	 SHORT $LN22@P_CheckPos
$LN23@P_CheckPos:

; 1191 : 
; 1192 : 	return blockval;

  0089f	eb b2		 jmp	 SHORT $LN19@P_CheckPos
$LN20@P_CheckPos:
  008a1	8b 45 e0	 mov	 eax, DWORD PTR _blockval$[ebp]
$LN1@P_CheckPos:

; 1193 : }

  008a4	5f		 pop	 edi
  008a5	5e		 pop	 esi
  008a6	5b		 pop	 ebx
  008a7	8b e5		 mov	 esp, ebp
  008a9	5d		 pop	 ebp
  008aa	c3		 ret	 0
_P_CheckPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_MapEnd
_TEXT	SEGMENT
_P_MapEnd PROC						; COMDAT

; 3716 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3717 : 	tmthing = NULL;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tmthing, 0

; 3718 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_P_MapEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_MapStart
_TEXT	SEGMENT
_P_MapStart PROC					; COMDAT

; 3710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3711 : 	if (tmthing)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmthing, 0
  00010	74 0d		 je	 SHORT $LN2@P_MapStart

; 3712 : 		I_Error("P_MapStart: tmthing set!");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MDPBEIDE@P_MapStart?3?5tmthing?5set?$CB@
  00017	e8 00 00 00 00	 call	 _I_Error
  0001c	83 c4 04	 add	 esp, 4
$LN2@P_MapStart:

; 3713 : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_P_MapStart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_SlideCameraMove
_TEXT	SEGMENT
_retval$ = -32						; size = 4
_hitcount$ = -28					; size = 4
_newy$ = -24						; size = 4
_newx$ = -20						; size = 4
_traily$ = -16						; size = 4
_trailx$ = -12						; size = 4
_leady$ = -8						; size = 4
_leadx$ = -4						; size = 4
_thiscam$ = 8						; size = 4
_P_SlideCameraMove PROC					; COMDAT

; 2319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2320 : 	fixed_t leadx, leady, trailx, traily, newx, newy;
; 2321 : 	INT32 hitcount = 0;

  00009	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hitcount$[ebp], 0

; 2322 : 	INT32 retval = 0;

  00010	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 0

; 2323 : 
; 2324 : 	bestslideline = NULL;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bestslideline, 0
$retry$15:

; 2325 : 
; 2326 : retry:
; 2327 : 	if (++hitcount == 3)

  00021	8b 45 e4	 mov	 eax, DWORD PTR _hitcount$[ebp]
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 e4	 mov	 DWORD PTR _hitcount$[ebp], eax
  0002a	83 7d e4 03	 cmp	 DWORD PTR _hitcount$[ebp], 3
  0002e	75 05		 jne	 SHORT $LN2@P_SlideCam

; 2328 : 		goto stairstep; // don't loop forever

  00030	e9 50 01 00 00	 jmp	 $stairstep$16
$LN2@P_SlideCam:

; 2329 : 
; 2330 : 	// trace along the three leading corners
; 2331 : 	if (thiscam->momx > 0)

  00035	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00038	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0003c	7e 20		 jle	 SHORT $LN3@P_SlideCam

; 2332 : 	{
; 2333 : 		leadx = thiscam->x + thiscam->radius;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00041	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00044	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00047	03 4a 2c	 add	 ecx, DWORD PTR [edx+44]
  0004a	89 4d fc	 mov	 DWORD PTR _leadx$[ebp], ecx

; 2334 : 		trailx = thiscam->x - thiscam->radius;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00053	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00056	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  00059	89 55 f4	 mov	 DWORD PTR _trailx$[ebp], edx

; 2335 : 	}

  0005c	eb 1e		 jmp	 SHORT $LN4@P_SlideCam
$LN3@P_SlideCam:

; 2336 : 	else
; 2337 : 	{
; 2338 : 		leadx = thiscam->x - thiscam->radius;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00064	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00067	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  0006a	89 55 fc	 mov	 DWORD PTR _leadx$[ebp], edx

; 2339 : 		trailx = thiscam->x + thiscam->radius;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00070	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00073	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00076	03 4a 2c	 add	 ecx, DWORD PTR [edx+44]
  00079	89 4d f4	 mov	 DWORD PTR _trailx$[ebp], ecx
$LN4@P_SlideCam:

; 2340 : 	}
; 2341 : 
; 2342 : 	if (thiscam->momy > 0)

  0007c	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0007f	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00083	7e 20		 jle	 SHORT $LN5@P_SlideCam

; 2343 : 	{
; 2344 : 		leady = thiscam->y + thiscam->radius;

  00085	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00088	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0008b	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  0008e	03 4a 2c	 add	 ecx, DWORD PTR [edx+44]
  00091	89 4d f8	 mov	 DWORD PTR _leady$[ebp], ecx

; 2345 : 		traily = thiscam->y - thiscam->radius;

  00094	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  0009a	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0009d	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  000a0	89 55 f0	 mov	 DWORD PTR _traily$[ebp], edx

; 2346 : 	}

  000a3	eb 1e		 jmp	 SHORT $LN6@P_SlideCam
$LN5@P_SlideCam:

; 2347 : 	else
; 2348 : 	{
; 2349 : 		leady = thiscam->y - thiscam->radius;

  000a5	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  000ab	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ae	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  000b1	89 55 f8	 mov	 DWORD PTR _leady$[ebp], edx

; 2350 : 		traily = thiscam->y + thiscam->radius;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  000b7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ba	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  000bd	03 4a 2c	 add	 ecx, DWORD PTR [edx+44]
  000c0	89 4d f0	 mov	 DWORD PTR _traily$[ebp], ecx
$LN6@P_SlideCam:

; 2351 : 	}
; 2352 : 
; 2353 : 	bestslidefrac = FRACUNIT+1;

  000c3	c7 05 00 00 00
	00 01 00 01 00	 mov	 DWORD PTR _bestslidefrac, 65537 ; 00010001H

; 2354 : 
; 2355 : 	mapcampointer = thiscam;

  000cd	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  000d0	a3 00 00 00 00	 mov	 DWORD PTR _mapcampointer, eax

; 2356 : 
; 2357 : 	P_PathTraverse(leadx, leady, leadx + thiscam->momx, leady + thiscam->momy,

  000d5	68 00 00 00 00	 push	 OFFSET _PTR_SlideCameraTraverse
  000da	6a 01		 push	 1
  000dc	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  000df	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  000e2	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  000e5	51		 push	 ecx
  000e6	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  000e9	8b 45 fc	 mov	 eax, DWORD PTR _leadx$[ebp]
  000ec	03 42 38	 add	 eax, DWORD PTR [edx+56]
  000ef	50		 push	 eax
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 fc	 mov	 edx, DWORD PTR _leadx$[ebp]
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 _P_PathTraverse
  000fd	83 c4 18	 add	 esp, 24			; 00000018H

; 2358 : 		PT_ADDLINES, PTR_SlideCameraTraverse);
; 2359 : 	P_PathTraverse(trailx, leady, trailx + thiscam->momx, leady + thiscam->momy,

  00100	68 00 00 00 00	 push	 OFFSET _PTR_SlideCameraTraverse
  00105	6a 01		 push	 1
  00107	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  0010d	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  00110	51		 push	 ecx
  00111	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00114	8b 45 f4	 mov	 eax, DWORD PTR _trailx$[ebp]
  00117	03 42 38	 add	 eax, DWORD PTR [edx+56]
  0011a	50		 push	 eax
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _leady$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 55 f4	 mov	 edx, DWORD PTR _trailx$[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _P_PathTraverse
  00128	83 c4 18	 add	 esp, 24			; 00000018H

; 2360 : 		PT_ADDLINES, PTR_SlideCameraTraverse);
; 2361 : 	P_PathTraverse(leadx, traily, leadx + thiscam->momx, traily + thiscam->momy,

  0012b	68 00 00 00 00	 push	 OFFSET _PTR_SlideCameraTraverse
  00130	6a 01		 push	 1
  00132	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00135	8b 4d f0	 mov	 ecx, DWORD PTR _traily$[ebp]
  00138	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  0013b	51		 push	 ecx
  0013c	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _leadx$[ebp]
  00142	03 42 38	 add	 eax, DWORD PTR [edx+56]
  00145	50		 push	 eax
  00146	8b 4d f0	 mov	 ecx, DWORD PTR _traily$[ebp]
  00149	51		 push	 ecx
  0014a	8b 55 fc	 mov	 edx, DWORD PTR _leadx$[ebp]
  0014d	52		 push	 edx
  0014e	e8 00 00 00 00	 call	 _P_PathTraverse
  00153	83 c4 18	 add	 esp, 24			; 00000018H

; 2362 : 		PT_ADDLINES, PTR_SlideCameraTraverse);
; 2363 : 
; 2364 : 	// move up to the wall
; 2365 : 	if (bestslidefrac == FRACUNIT+1)

  00156	81 3d 00 00 00
	00 01 00 01 00	 cmp	 DWORD PTR _bestslidefrac, 65537 ; 00010001H
  00160	75 4e		 jne	 SHORT $LN7@P_SlideCam

; 2366 : 	{
; 2367 : 		retval = P_TryCameraMove(thiscam->x, thiscam->y + thiscam->momy, thiscam);

  00162	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00165	50		 push	 eax
  00166	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00169	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0016c	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0016f	03 50 3c	 add	 edx, DWORD PTR [eax+60]
  00172	52		 push	 edx
  00173	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00176	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 _P_TryCameraMove
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	89 45 e0	 mov	 DWORD PTR _retval$[ebp], eax
$stairstep$16:

; 2368 : 		// the move must have hit the middle, so stairstep
; 2369 : stairstep:
; 2370 : 		if (!retval) // Allow things to drop off.

  00185	83 7d e0 00	 cmp	 DWORD PTR _retval$[ebp], 0
  00189	75 20		 jne	 SHORT $LN8@P_SlideCam

; 2371 : 			P_TryCameraMove(thiscam->x + thiscam->momx, thiscam->y, thiscam);

  0018b	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00192	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00195	52		 push	 edx
  00196	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00199	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0019c	8b 55 08	 mov	 edx, DWORD PTR _thiscam$[ebp]
  0019f	03 4a 38	 add	 ecx, DWORD PTR [edx+56]
  001a2	51		 push	 ecx
  001a3	e8 00 00 00 00	 call	 _P_TryCameraMove
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@P_SlideCam:

; 2372 : 		return;

  001ab	e9 44 01 00 00	 jmp	 $LN13@P_SlideCam
$LN7@P_SlideCam:

; 2373 : 	}
; 2374 : 
; 2375 : 	// fudge a bit to make sure it doesn't hit
; 2376 : 	bestslidefrac -= 0x800;

  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  001b5	2d 00 08 00 00	 sub	 eax, 2048		; 00000800H
  001ba	a3 00 00 00 00	 mov	 DWORD PTR _bestslidefrac, eax

; 2377 : 	if (bestslidefrac > 0)

  001bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslidefrac, 0
  001c6	7e 5e		 jle	 SHORT $LN10@P_SlideCam

; 2378 : 	{
; 2379 : 		newx = FixedMul(thiscam->momx, bestslidefrac);

  001c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  001cd	50		 push	 eax
  001ce	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  001d1	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001d4	52		 push	 edx
  001d5	e8 00 00 00 00	 call	 _FixedMul
  001da	83 c4 08	 add	 esp, 8
  001dd	89 45 ec	 mov	 DWORD PTR _newx$[ebp], eax

; 2380 : 		newy = FixedMul(thiscam->momy, bestslidefrac);

  001e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  001e5	50		 push	 eax
  001e6	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  001e9	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  001ec	52		 push	 edx
  001ed	e8 00 00 00 00	 call	 _FixedMul
  001f2	83 c4 08	 add	 esp, 8
  001f5	89 45 e8	 mov	 DWORD PTR _newy$[ebp], eax

; 2381 : 
; 2382 : 		retval = P_TryCameraMove(thiscam->x + newx, thiscam->y + newy, thiscam);

  001f8	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001fb	50		 push	 eax
  001fc	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  001ff	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00202	03 55 e8	 add	 edx, DWORD PTR _newy$[ebp]
  00205	52		 push	 edx
  00206	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00209	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0020c	03 4d ec	 add	 ecx, DWORD PTR _newx$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _P_TryCameraMove
  00215	83 c4 0c	 add	 esp, 12			; 0000000cH
  00218	89 45 e0	 mov	 DWORD PTR _retval$[ebp], eax

; 2383 : 
; 2384 : 		if (!retval)

  0021b	83 7d e0 00	 cmp	 DWORD PTR _retval$[ebp], 0
  0021f	75 05		 jne	 SHORT $LN10@P_SlideCam

; 2385 : 			goto stairstep;

  00221	e9 5f ff ff ff	 jmp	 $stairstep$16
$LN10@P_SlideCam:

; 2386 : 	}
; 2387 : 
; 2388 : 	// Now continue along the wall.
; 2389 : 	// First calculate remainder.
; 2390 : 	bestslidefrac = FRACUNIT - (bestslidefrac+0x800);

  00226	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  0022b	05 00 08 00 00	 add	 eax, 2048		; 00000800H
  00230	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00235	2b c8		 sub	 ecx, eax
  00237	89 0d 00 00 00
	00		 mov	 DWORD PTR _bestslidefrac, ecx

; 2391 : 
; 2392 : 	if (bestslidefrac > FRACUNIT)

  0023d	81 3d 00 00 00
	00 00 00 01 00	 cmp	 DWORD PTR _bestslidefrac, 65536 ; 00010000H
  00247	7e 0a		 jle	 SHORT $LN11@P_SlideCam

; 2393 : 		bestslidefrac = FRACUNIT;

  00249	c7 05 00 00 00
	00 00 00 01 00	 mov	 DWORD PTR _bestslidefrac, 65536 ; 00010000H
$LN11@P_SlideCam:

; 2394 : 
; 2395 : 	if (bestslidefrac <= 0)

  00253	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bestslidefrac, 0
  0025a	7f 05		 jg	 SHORT $LN12@P_SlideCam

; 2396 : 		return;

  0025c	e9 93 00 00 00	 jmp	 $LN13@P_SlideCam
$LN12@P_SlideCam:

; 2397 : 
; 2398 : 	tmxmove = FixedMul(thiscam->momx, bestslidefrac);

  00261	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  00266	50		 push	 eax
  00267	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  0026a	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0026d	52		 push	 edx
  0026e	e8 00 00 00 00	 call	 _FixedMul
  00273	83 c4 08	 add	 esp, 8
  00276	a3 00 00 00 00	 mov	 DWORD PTR _tmxmove, eax

; 2399 : 	tmymove = FixedMul(thiscam->momy, bestslidefrac);

  0027b	a1 00 00 00 00	 mov	 eax, DWORD PTR _bestslidefrac
  00280	50		 push	 eax
  00281	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00284	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00287	52		 push	 edx
  00288	e8 00 00 00 00	 call	 _FixedMul
  0028d	83 c4 08	 add	 esp, 8
  00290	a3 00 00 00 00	 mov	 DWORD PTR _tmymove, eax

; 2400 : 
; 2401 : 	P_HitCameraSlideLine(bestslideline, thiscam); // clip the moves

  00295	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00298	50		 push	 eax
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bestslideline
  0029f	51		 push	 ecx
  002a0	e8 00 00 00 00	 call	 _P_HitCameraSlideLine
  002a5	83 c4 08	 add	 esp, 8

; 2402 : 
; 2403 : 	thiscam->momx = tmxmove;

  002a8	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmxmove
  002b1	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 2404 : 	thiscam->momy = tmymove;

  002b4	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmymove
  002bd	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 2405 : 
; 2406 : 	retval = P_TryCameraMove(thiscam->x + tmxmove, thiscam->y + tmymove, thiscam);

  002c0	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002c3	50		 push	 eax
  002c4	8b 4d 08	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  002c7	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002ca	03 15 00 00 00
	00		 add	 edx, DWORD PTR _tmymove
  002d0	52		 push	 edx
  002d1	8b 45 08	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002d4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002d7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _tmxmove
  002dd	51		 push	 ecx
  002de	e8 00 00 00 00	 call	 _P_TryCameraMove
  002e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e6	89 45 e0	 mov	 DWORD PTR _retval$[ebp], eax

; 2407 : 
; 2408 : 	if (!retval)

  002e9	83 7d e0 00	 cmp	 DWORD PTR _retval$[ebp], 0
  002ed	75 05		 jne	 SHORT $LN13@P_SlideCam

; 2409 : 		goto retry;

  002ef	e9 2d fd ff ff	 jmp	 $retry$15
$LN13@P_SlideCam:

; 2410 : }

  002f4	5f		 pop	 edi
  002f5	5e		 pop	 esi
  002f6	5b		 pop	 ebx
  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c3		 ret	 0
_P_SlideCameraMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_TryCameraMove
_TEXT	SEGMENT
_cameranoclip$1 = -24					; size = 4
_itsatwodlevel$ = -20					; size = 4
_retval$ = -16						; size = 4
_s$ = -12						; size = 4
_oldy$ = -8						; size = 4
_oldx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_thiscam$ = 16						; size = 4
_P_TryCameraMove PROC					; COMDAT

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1399 : 	fixed_t oldx, oldy;
; 1400 : 	subsector_t *s = R_PointInSubsector(x, y);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _R_PointInSubsector
  00016	83 c4 08	 add	 esp, 8
  00019	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax

; 1401 : 	INT32 retval = 1;

  0001c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _retval$[ebp], 1

; 1402 : 	boolean itsatwodlevel = false;

  00023	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _itsatwodlevel$[ebp], 0

; 1403 : 
; 1404 : 	floatok = false;

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _floatok, 0

; 1405 : 
; 1406 : 	if (twodlevel
; 1407 : 		|| (thiscam == &camera && players[displayplayer].mo && (players[displayplayer].mo->flags2 & MF2_TWOD))
; 1408 : 		|| (thiscam == &camera2 && players[secondarydisplayplayer].mo && (players[secondarydisplayplayer].mo->flags2 & MF2_TWOD)))

  00034	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _maptol
  0003b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00040	75 74		 jne	 SHORT $LN3@P_TryCamer
  00042	81 7d 10 00 00
	00 00		 cmp	 DWORD PTR _thiscam$[ebp], OFFSET _camera
  00049	75 31		 jne	 SHORT $LN4@P_TryCamer
  0004b	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00055	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  0005c	74 1e		 je	 SHORT $LN4@P_TryCamer
  0005e	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  00068	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  0006e	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  00074	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0007a	75 3a		 jne	 SHORT $LN3@P_TryCamer
$LN4@P_TryCamer:
  0007c	81 7d 10 00 00
	00 00		 cmp	 DWORD PTR _thiscam$[ebp], OFFSET _camera2
  00083	75 38		 jne	 SHORT $LN2@P_TryCamer
  00085	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  0008f	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR _players[eax], 0
  00096	74 25		 je	 SHORT $LN2@P_TryCamer
  00098	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  000a2	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _players[eax]
  000a8	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  000ae	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  000b4	74 07		 je	 SHORT $LN2@P_TryCamer
$LN3@P_TryCamer:

; 1409 : 		itsatwodlevel = true;

  000b6	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _itsatwodlevel$[ebp], 1
$LN2@P_TryCamer:

; 1410 : 
; 1411 : 	if (!itsatwodlevel)

  000bd	83 7d ec 00	 cmp	 DWORD PTR _itsatwodlevel$[ebp], 0
  000c1	0f 85 de 02 00
	00		 jne	 $LN5@P_TryCamer

; 1412 : 	{
; 1413 : 		boolean cameranoclip;
; 1414 : 
; 1415 : 		if ((thiscam == &camera && (players[displayplayer].pflags & PF_NOCLIP))
; 1416 : 		|| (thiscam == &camera2 && (players[secondarydisplayplayer].pflags & PF_NOCLIP)))

  000c7	81 7d 10 00 00
	00 00		 cmp	 DWORD PTR _thiscam$[ebp], OFFSET _camera
  000ce	75 15		 jne	 SHORT $LN10@P_TryCamer
  000d0	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _displayplayer, 508
  000da	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  000e0	83 e1 40	 and	 ecx, 64			; 00000040H
  000e3	75 1e		 jne	 SHORT $LN9@P_TryCamer
$LN10@P_TryCamer:
  000e5	81 7d 10 00 00
	00 00		 cmp	 DWORD PTR _thiscam$[ebp], OFFSET _camera2
  000ec	75 1e		 jne	 SHORT $LN7@P_TryCamer
  000ee	69 05 00 00 00
	00 fc 01 00 00	 imul	 eax, DWORD PTR _secondarydisplayplayer, 508
  000f8	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR _players[eax+172]
  000fe	83 e1 40	 and	 ecx, 64			; 00000040H
  00101	74 09		 je	 SHORT $LN7@P_TryCamer
$LN9@P_TryCamer:

; 1417 : 		{ // Noclipping player camera noclips too!!
; 1418 : 			cameranoclip = true;

  00103	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _cameranoclip$1[ebp], 1

; 1419 : 		}

  0010a	eb 07		 jmp	 SHORT $LN8@P_TryCamer
$LN7@P_TryCamer:

; 1420 : 		else
; 1421 : 			cameranoclip = false;

  0010c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _cameranoclip$1[ebp], 0
$LN8@P_TryCamer:

; 1422 : 
; 1423 : 		if (!P_CheckCameraPosition(x, y, thiscam))

  00113	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00116	50		 push	 eax
  00117	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0011a	51		 push	 ecx
  0011b	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _P_CheckCameraPosition
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
  00127	85 c0		 test	 eax, eax
  00129	75 6e		 jne	 SHORT $LN13@P_TryCamer

; 1424 : 		{
; 1425 : 			if (cameranoclip)

  0012b	83 7d e8 00	 cmp	 DWORD PTR _cameranoclip$1[ebp], 0
  0012f	74 61		 je	 SHORT $LN12@P_TryCamer

; 1426 : 			{
; 1427 : 				floatok = true;

  00131	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1428 : 				oldx = thiscam->x;

  0013b	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0013e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00141	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1429 : 				oldy = thiscam->y;

  00144	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00147	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0014a	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1430 : 				thiscam->floorz = thiscam->z;

  0014d	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00150	8b 4d 10	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00153	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00156	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1431 : 				thiscam->ceilingz = thiscam->z + thiscam->height;

  00159	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0015c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0015f	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00162	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  00165	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00168	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1432 : 				thiscam->x = x;

  0016b	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00171	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1433 : 				thiscam->y = y;

  00174	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0017a	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1434 : 				thiscam->subsector = s;

  0017d	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00180	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00183	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1435 : 				return true;

  00186	b8 01 00 00 00	 mov	 eax, 1
  0018b	e9 7c 02 00 00	 jmp	 $LN1@P_TryCamer

; 1436 : 			}

  00190	eb 07		 jmp	 SHORT $LN13@P_TryCamer
$LN12@P_TryCamer:

; 1437 : 			else
; 1438 : 				return 0; // solid wall or thing

  00192	33 c0		 xor	 eax, eax
  00194	e9 73 02 00 00	 jmp	 $LN1@P_TryCamer
$LN13@P_TryCamer:

; 1439 : 		}
; 1440 : 
; 1441 : 		if (tmceilingz - tmfloorz < thiscam->height)

  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmceilingz
  0019e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _tmfloorz
  001a4	8b 4d 10	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  001a7	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  001aa	7d 6e		 jge	 SHORT $LN16@P_TryCamer

; 1442 : 		{
; 1443 : 			if (cameranoclip)

  001ac	83 7d e8 00	 cmp	 DWORD PTR _cameranoclip$1[ebp], 0
  001b0	74 61		 je	 SHORT $LN15@P_TryCamer

; 1444 : 			{
; 1445 : 				floatok = true;

  001b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1446 : 				oldx = thiscam->x;

  001bc	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001bf	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001c2	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1447 : 				oldy = thiscam->y;

  001c5	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001c8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001cb	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1448 : 				thiscam->floorz = thiscam->z;

  001ce	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001d1	8b 4d 10	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  001d4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001d7	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1449 : 				thiscam->ceilingz = thiscam->z + thiscam->height;

  001da	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001dd	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001e0	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  001e3	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  001e6	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001e9	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1450 : 				thiscam->x = x;

  001ec	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  001f2	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1451 : 				thiscam->y = y;

  001f5	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  001f8	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  001fb	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1452 : 				thiscam->subsector = s;

  001fe	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00201	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00204	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1453 : 				return true;

  00207	b8 01 00 00 00	 mov	 eax, 1
  0020c	e9 fb 01 00 00	 jmp	 $LN1@P_TryCamer

; 1454 : 			}

  00211	eb 07		 jmp	 SHORT $LN16@P_TryCamer
$LN15@P_TryCamer:

; 1455 : 			else
; 1456 : 				return 0; // doesn't fit

  00213	33 c0		 xor	 eax, eax
  00215	e9 f2 01 00 00	 jmp	 $LN1@P_TryCamer
$LN16@P_TryCamer:

; 1457 : 		}
; 1458 : 
; 1459 : 		floatok = true;

  0021a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1460 : 
; 1461 : 		if (tmceilingz - thiscam->z < thiscam->height)

  00224	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  0022d	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00230	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00233	3b 4a 30	 cmp	 ecx, DWORD PTR [edx+48]
  00236	0f 8d eb 00 00
	00		 jge	 $LN21@P_TryCamer

; 1462 : 		{
; 1463 : 			if (cameranoclip)

  0023c	83 7d e8 00	 cmp	 DWORD PTR _cameranoclip$1[ebp], 0
  00240	74 64		 je	 SHORT $LN18@P_TryCamer

; 1464 : 			{
; 1465 : 				floatok = true;

  00242	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1466 : 				oldx = thiscam->x;

  0024c	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0024f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00252	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1467 : 				oldy = thiscam->y;

  00255	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00258	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0025b	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1468 : 				thiscam->floorz = thiscam->z;

  0025e	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00261	8b 4d 10	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00264	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00267	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1469 : 				thiscam->ceilingz = thiscam->z + thiscam->height;

  0026a	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0026d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00270	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00273	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  00276	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00279	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1470 : 				thiscam->x = x;

  0027c	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0027f	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00282	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1471 : 				thiscam->y = y;

  00285	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00288	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0028b	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1472 : 				thiscam->subsector = s;

  0028e	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00291	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00294	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1473 : 				return true;

  00297	b8 01 00 00 00	 mov	 eax, 1
  0029c	e9 6b 01 00 00	 jmp	 $LN1@P_TryCamer

; 1474 : 			}

  002a1	e9 81 00 00 00	 jmp	 $LN21@P_TryCamer
$LN18@P_TryCamer:

; 1475 : 			else if (s == thiscam->subsector && tmceilingz >= thiscam->z)

  002a6	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002a9	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  002ac	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  002af	75 6f		 jne	 SHORT $LN20@P_TryCamer
  002b1	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  002ba	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  002bd	7c 61		 jl	 SHORT $LN20@P_TryCamer

; 1476 : 			{
; 1477 : 				floatok = true;

  002bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1478 : 				oldx = thiscam->x;

  002c9	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002cc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002cf	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1479 : 				oldy = thiscam->y;

  002d2	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002d5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002d8	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1480 : 				thiscam->floorz = tmfloorz;

  002db	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  002e4	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 1481 : 				thiscam->ceilingz = tmfloorz + thiscam->height;

  002e7	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  002f0	03 48 30	 add	 ecx, DWORD PTR [eax+48]
  002f3	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  002f6	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 1482 : 				thiscam->x = x;

  002f9	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  002fc	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  002ff	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1483 : 				thiscam->y = y;

  00302	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00305	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00308	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1484 : 				thiscam->subsector = s;

  0030b	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0030e	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00311	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1485 : 				return true;

  00314	b8 01 00 00 00	 mov	 eax, 1
  00319	e9 ee 00 00 00	 jmp	 $LN1@P_TryCamer

; 1486 : 			}

  0031e	eb 07		 jmp	 SHORT $LN21@P_TryCamer
$LN20@P_TryCamer:

; 1487 : 			else
; 1488 : 			{
; 1489 : 				return 0; // mobj must lower itself to fit

  00320	33 c0		 xor	 eax, eax
  00322	e9 e5 00 00 00	 jmp	 $LN1@P_TryCamer
$LN21@P_TryCamer:

; 1490 : 			}
; 1491 : 		}
; 1492 : 
; 1493 : 		if ((tmfloorz - thiscam->z > MAXCAMERASTEPMOVE))

  00327	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0032a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  00330	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00333	81 f9 00 00 18
	00		 cmp	 ecx, 1572864		; 00180000H
  00339	7e 68		 jle	 SHORT $LN24@P_TryCamer

; 1494 : 		{
; 1495 : 			if (cameranoclip)

  0033b	83 7d e8 00	 cmp	 DWORD PTR _cameranoclip$1[ebp], 0
  0033f	74 5e		 je	 SHORT $LN23@P_TryCamer

; 1496 : 			{
; 1497 : 				floatok = true;

  00341	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _floatok, 1

; 1498 : 				oldx = thiscam->x;

  0034b	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0034e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00351	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1499 : 				oldy = thiscam->y;

  00354	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00357	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0035a	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1500 : 				thiscam->floorz = thiscam->z;

  0035d	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00360	8b 4d 10	 mov	 ecx, DWORD PTR _thiscam$[ebp]
  00363	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00366	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1501 : 				thiscam->ceilingz = thiscam->z + thiscam->height;

  00369	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0036c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0036f	8b 55 10	 mov	 edx, DWORD PTR _thiscam$[ebp]
  00372	03 4a 30	 add	 ecx, DWORD PTR [edx+48]
  00375	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00378	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1502 : 				thiscam->x = x;

  0037b	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  0037e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00381	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1503 : 				thiscam->y = y;

  00384	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00387	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0038a	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1504 : 				thiscam->subsector = s;

  0038d	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00390	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00393	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1505 : 				return true;

  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	eb 6f		 jmp	 SHORT $LN1@P_TryCamer

; 1506 : 			}

  0039d	eb 04		 jmp	 SHORT $LN24@P_TryCamer
$LN23@P_TryCamer:

; 1507 : 			else
; 1508 : 				return 0; // too big a step up

  0039f	33 c0		 xor	 eax, eax
  003a1	eb 69		 jmp	 SHORT $LN1@P_TryCamer
$LN24@P_TryCamer:

; 1509 : 		}
; 1510 : 	}

  003a3	eb 1f		 jmp	 SHORT $LN6@P_TryCamer
$LN5@P_TryCamer:

; 1511 : 	else
; 1512 : 	{
; 1513 : 		tmfloorz = thiscam->subsector->sector->floorheight;

  003a5	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003a8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  003ad	8b 02		 mov	 eax, DWORD PTR [edx]
  003af	a3 00 00 00 00	 mov	 DWORD PTR _tmfloorz, eax

; 1514 : 		tmceilingz = thiscam->subsector->sector->ceilingheight;

  003b4	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003b7	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  003bc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003bf	a3 00 00 00 00	 mov	 DWORD PTR _tmceilingz, eax
$LN6@P_TryCamer:

; 1515 : 	}
; 1516 : 
; 1517 : 	// the move is ok,
; 1518 : 	// so link the thing into its new position
; 1519 : 
; 1520 : 	oldx = thiscam->x;

  003c4	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003c7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003ca	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1521 : 	oldy = thiscam->y;

  003cd	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003d0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003d3	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1522 : 	thiscam->floorz = tmfloorz;

  003d6	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  003df	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 1523 : 	thiscam->ceilingz = tmceilingz;

  003e2	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  003eb	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1524 : 	thiscam->x = x;

  003ee	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003f1	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  003f4	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1525 : 	thiscam->y = y;

  003f7	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  003fa	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  003fd	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1526 : 	thiscam->subsector = s;

  00400	8b 45 10	 mov	 eax, DWORD PTR _thiscam$[ebp]
  00403	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00406	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1527 : 
; 1528 : 	return retval;

  00409	8b 45 f0	 mov	 eax, DWORD PTR _retval$[ebp]
$LN1@P_TryCamer:

; 1529 : }

  0040c	5f		 pop	 edi
  0040d	5e		 pop	 esi
  0040e	5b		 pop	 ebx
  0040f	8b e5		 mov	 esp, ebp
  00411	5d		 pop	 ebp
  00412	c3		 ret	 0
_P_TryCameraMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_SceneryTryMove
_TEXT	SEGMENT
_maxstep$1 = -12					; size = 4
_oldy$ = -8						; size = 4
_oldx$ = -4						; size = 4
_thing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_P_SceneryTryMove PROC					; COMDAT

; 1723 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1724 : 	fixed_t oldx, oldy;
; 1725 : 
; 1726 : 	if (!P_CheckPosition(thing, x, y))

  00009	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _P_CheckPosition
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@P_SceneryT

; 1727 : 		return false; // solid wall or thing

  00021	33 c0		 xor	 eax, eax
  00023	e9 f0 00 00 00	 jmp	 $LN1@P_SceneryT
$LN2@P_SceneryT:

; 1728 : 
; 1729 : 	if (!(thing->flags & MF_NOCLIP))

  00028	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0002b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0002e	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00034	75 54		 jne	 SHORT $LN6@P_SceneryT

; 1730 : 	{
; 1731 : 		const fixed_t maxstep = MAXSTEPMOVE;

  00036	c7 45 f4 00 00
	18 00		 mov	 DWORD PTR _maxstep$1[ebp], 1572864 ; 00180000H

; 1732 : 
; 1733 : 		if (tmceilingz - tmfloorz < thing->height)

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmceilingz
  00042	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _tmfloorz
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  0004b	3b 41 44	 cmp	 eax, DWORD PTR [ecx+68]
  0004e	7d 07		 jge	 SHORT $LN4@P_SceneryT

; 1734 : 			return false; // doesn't fit

  00050	33 c0		 xor	 eax, eax
  00052	e9 c1 00 00 00	 jmp	 $LN1@P_SceneryT
$LN4@P_SceneryT:

; 1735 : 
; 1736 : 		if (tmceilingz - thing->z < thing->height)

  00057	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  00060	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  00063	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00066	3b 4a 44	 cmp	 ecx, DWORD PTR [edx+68]
  00069	7d 07		 jge	 SHORT $LN5@P_SceneryT

; 1737 : 			return false; // mobj must lower itself to fit

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 a6 00 00 00	 jmp	 $LN1@P_SceneryT
$LN5@P_SceneryT:

; 1738 : 
; 1739 : 		if (tmfloorz - thing->z > maxstep)

  00072	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  0007b	2b 48 18	 sub	 ecx, DWORD PTR [eax+24]
  0007e	3b 4d f4	 cmp	 ecx, DWORD PTR _maxstep$1[ebp]
  00081	7e 07		 jle	 SHORT $LN6@P_SceneryT

; 1740 : 			return false; // too big a step up

  00083	33 c0		 xor	 eax, eax
  00085	e9 8e 00 00 00	 jmp	 $LN1@P_SceneryT
$LN6@P_SceneryT:

; 1741 : 	}
; 1742 : 
; 1743 : 	// the move is ok,
; 1744 : 	// so link the thing into its new position
; 1745 : 	P_UnsetThingPosition(thing);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _P_UnsetThingPosition
  00093	83 c4 04	 add	 esp, 4

; 1746 : 
; 1747 : 	oldx = thing->x;

  00096	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00099	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0009c	89 4d fc	 mov	 DWORD PTR _oldx$[ebp], ecx

; 1748 : 	oldy = thing->y;

  0009f	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000a2	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a5	89 4d f8	 mov	 DWORD PTR _oldy$[ebp], ecx

; 1749 : 	thing->floorz = tmfloorz;

  000a8	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmfloorz
  000b1	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 1750 : 	thing->ceilingz = tmceilingz;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tmceilingz
  000bd	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1751 : 	thing->x = x;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000c6	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1752 : 	thing->y = y;

  000c9	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  000cf	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1753 : 
; 1754 : 	if (tmfloorthing)

  000d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tmfloorthing, 0
  000d9	74 17		 je	 SHORT $LN7@P_SceneryT

; 1755 : 		thing->eflags &= ~MFE_ONGROUND; // not on real floor

  000db	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000de	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000e4	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000e7	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  000ea	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
  000f0	eb 15		 jmp	 SHORT $LN8@P_SceneryT
$LN7@P_SceneryT:

; 1756 : 	else
; 1757 : 		thing->eflags |= MFE_ONGROUND;

  000f2	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  000f5	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [eax+132]
  000fb	83 c9 01	 or	 ecx, 1
  000fe	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  00101	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
$LN8@P_SceneryT:

; 1758 : 
; 1759 : 	P_SetThingPosition(thing);

  00107	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _P_SetThingPosition
  00110	83 c4 04	 add	 esp, 4

; 1760 : 	return true;

  00113	b8 01 00 00 00	 mov	 eax, 1
$LN1@P_SceneryT:

; 1761 : }

  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_P_SceneryTryMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\p_map.c
;	COMDAT _P_CreatePrecipSecNodeList
_TEXT	SEGMENT
_saved_tmthing$ = -32					; size = 4
_node$ = -28						; size = 4
_by$ = -24						; size = 4
_bx$ = -20						; size = 4
_yh$ = -16						; size = 4
_yl$ = -12						; size = 4
_xh$ = -8						; size = 4
_xl$ = -4						; size = 4
_thing$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_P_CreatePrecipSecNodeList PROC				; COMDAT

; 3640 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3641 : 	INT32 xl, xh, yl, yh, bx, by;
; 3642 : 	mprecipsecnode_t *node = precipsector_list;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _precipsector_list
  0000e	89 45 e4	 mov	 DWORD PTR _node$[ebp], eax

; 3643 : 	precipmobj_t *saved_tmthing = tmprecipthing; /* cph - see comment at func end */

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _tmprecipthing
  00016	89 45 e0	 mov	 DWORD PTR _saved_tmthing$[ebp], eax
$LN2@P_CreatePr:

; 3644 : 
; 3645 : 	// First, clear out the existing m_thing fields. As each node is
; 3646 : 	// added or verified as needed, m_thing will be set properly. When
; 3647 : 	// finished, delete all nodes where m_thing is still NULL. These
; 3648 : 	// represent the sectors the Thing has vacated.
; 3649 : 
; 3650 : 	while (node)

  00019	83 7d e4 00	 cmp	 DWORD PTR _node$[ebp], 0
  0001d	74 15		 je	 SHORT $LN3@P_CreatePr

; 3651 : 	{
; 3652 : 		node->m_thing = NULL;

  0001f	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  00022	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3653 : 		node = node->m_tnext;

  00029	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0002c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002f	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx

; 3654 : 	}

  00032	eb e5		 jmp	 SHORT $LN2@P_CreatePr
$LN3@P_CreatePr:

; 3655 : 
; 3656 : 	tmprecipthing = thing;

  00034	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  00037	a3 00 00 00 00	 mov	 DWORD PTR _tmprecipthing, eax

; 3657 : 	preciptmflags = thing->flags;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _thing$[ebp]
  0003f	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00042	89 0d 00 00 00
	00		 mov	 DWORD PTR _preciptmflags, ecx

; 3658 : 
; 3659 : 	preciptmx = x;

  00048	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0004b	a3 00 00 00 00	 mov	 DWORD PTR _preciptmx, eax

; 3660 : 	preciptmy = y;

  00050	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00053	a3 00 00 00 00	 mov	 DWORD PTR _preciptmy, eax

; 3661 : 
; 3662 : 	preciptmbbox[BOXTOP] = y + 2*FRACUNIT;

  00058	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0005b	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  00060	b9 04 00 00 00	 mov	 ecx, 4
  00065	6b d1 00	 imul	 edx, ecx, 0
  00068	89 82 00 00 00
	00		 mov	 DWORD PTR _preciptmbbox[edx], eax

; 3663 : 	preciptmbbox[BOXBOTTOM] = y - 2*FRACUNIT;

  0006e	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00071	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
  00076	b9 04 00 00 00	 mov	 ecx, 4
  0007b	c1 e1 00	 shl	 ecx, 0
  0007e	89 81 00 00 00
	00		 mov	 DWORD PTR _preciptmbbox[ecx], eax

; 3664 : 	preciptmbbox[BOXRIGHT] = x + 2*FRACUNIT;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00087	05 00 00 02 00	 add	 eax, 131072		; 00020000H
  0008c	b9 04 00 00 00	 mov	 ecx, 4
  00091	6b d1 03	 imul	 edx, ecx, 3
  00094	89 82 00 00 00
	00		 mov	 DWORD PTR _preciptmbbox[edx], eax

; 3665 : 	preciptmbbox[BOXLEFT] = x - 2*FRACUNIT;

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0009d	2d 00 00 02 00	 sub	 eax, 131072		; 00020000H
  000a2	b9 04 00 00 00	 mov	 ecx, 4
  000a7	d1 e1		 shl	 ecx, 1
  000a9	89 81 00 00 00
	00		 mov	 DWORD PTR _preciptmbbox[ecx], eax

; 3666 : 
; 3667 : 	validcount++; // used to make sure we only process a line once

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _validcount
  000b4	83 c0 01	 add	 eax, 1
  000b7	a3 00 00 00 00	 mov	 DWORD PTR _validcount, eax

; 3668 : 
; 3669 : 	xl = (unsigned)(preciptmbbox[BOXLEFT] - bmaporgx)>>MAPBLOCKSHIFT;

  000bc	b8 04 00 00 00	 mov	 eax, 4
  000c1	d1 e0		 shl	 eax, 1
  000c3	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _preciptmbbox[eax]
  000c9	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgx
  000cf	c1 e9 17	 shr	 ecx, 23			; 00000017H
  000d2	89 4d fc	 mov	 DWORD PTR _xl$[ebp], ecx

; 3670 : 	xh = (unsigned)(preciptmbbox[BOXRIGHT] - bmaporgx)>>MAPBLOCKSHIFT;

  000d5	b8 04 00 00 00	 mov	 eax, 4
  000da	6b c8 03	 imul	 ecx, eax, 3
  000dd	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _preciptmbbox[ecx]
  000e3	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgx
  000e9	c1 ea 17	 shr	 edx, 23			; 00000017H
  000ec	89 55 f8	 mov	 DWORD PTR _xh$[ebp], edx

; 3671 : 	yl = (unsigned)(preciptmbbox[BOXBOTTOM] - bmaporgy)>>MAPBLOCKSHIFT;

  000ef	b8 04 00 00 00	 mov	 eax, 4
  000f4	c1 e0 00	 shl	 eax, 0
  000f7	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _preciptmbbox[eax]
  000fd	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _bmaporgy
  00103	c1 e9 17	 shr	 ecx, 23			; 00000017H
  00106	89 4d f4	 mov	 DWORD PTR _yl$[ebp], ecx

; 3672 : 	yh = (unsigned)(preciptmbbox[BOXTOP] - bmaporgy)>>MAPBLOCKSHIFT;

  00109	b8 04 00 00 00	 mov	 eax, 4
  0010e	6b c8 00	 imul	 ecx, eax, 0
  00111	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _preciptmbbox[ecx]
  00117	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _bmaporgy
  0011d	c1 ea 17	 shr	 edx, 23			; 00000017H
  00120	89 55 f0	 mov	 DWORD PTR _yh$[ebp], edx

; 3673 : 
; 3674 : 	for (bx = xl; bx <= xh; bx++)

  00123	8b 45 fc	 mov	 eax, DWORD PTR _xl$[ebp]
  00126	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
  00129	eb 09		 jmp	 SHORT $LN6@P_CreatePr
$LN4@P_CreatePr:
  0012b	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  0012e	83 c0 01	 add	 eax, 1
  00131	89 45 ec	 mov	 DWORD PTR _bx$[ebp], eax
$LN6@P_CreatePr:
  00134	8b 45 ec	 mov	 eax, DWORD PTR _bx$[ebp]
  00137	3b 45 f8	 cmp	 eax, DWORD PTR _xh$[ebp]
  0013a	7f 32		 jg	 SHORT $LN5@P_CreatePr

; 3675 : 		for (by = yl; by <= yh; by++)

  0013c	8b 45 f4	 mov	 eax, DWORD PTR _yl$[ebp]
  0013f	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
  00142	eb 09		 jmp	 SHORT $LN9@P_CreatePr
$LN7@P_CreatePr:
  00144	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00147	83 c0 01	 add	 eax, 1
  0014a	89 45 e8	 mov	 DWORD PTR _by$[ebp], eax
$LN9@P_CreatePr:
  0014d	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  00150	3b 45 f0	 cmp	 eax, DWORD PTR _yh$[ebp]
  00153	7f 17		 jg	 SHORT $LN8@P_CreatePr

; 3676 : 			P_BlockLinesIterator(bx, by, PIT_GetPrecipSectors);

  00155	68 00 00 00 00	 push	 OFFSET _PIT_GetPrecipSectors
  0015a	8b 45 e8	 mov	 eax, DWORD PTR _by$[ebp]
  0015d	50		 push	 eax
  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _bx$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _P_BlockLinesIterator
  00167	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016a	eb d8		 jmp	 SHORT $LN7@P_CreatePr
$LN8@P_CreatePr:
  0016c	eb bd		 jmp	 SHORT $LN4@P_CreatePr
$LN5@P_CreatePr:

; 3677 : 
; 3678 : 	// Add the sector of the (x, y) point to sector_list.
; 3679 : 	precipsector_list = P_AddPrecipSecnode(thing->subsector->sector, thing, precipsector_list);

  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR _precipsector_list
  00173	50		 push	 eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _thing$[ebp]
  00177	51		 push	 ecx
  00178	8b 55 08	 mov	 edx, DWORD PTR _thing$[ebp]
  0017b	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0017e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 _P_AddPrecipSecnode
  00186	83 c4 0c	 add	 esp, 12			; 0000000cH
  00189	a3 00 00 00 00	 mov	 DWORD PTR _precipsector_list, eax

; 3680 : 
; 3681 : 	// Now delete any nodes that won't be used. These are the ones where
; 3682 : 	// m_thing is still NULL.
; 3683 : 	node = precipsector_list;

  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR _precipsector_list
  00193	89 45 e4	 mov	 DWORD PTR _node$[ebp], eax
$LN10@P_CreatePr:

; 3684 : 	while (node)

  00196	83 7d e4 00	 cmp	 DWORD PTR _node$[ebp], 0
  0019a	74 3c		 je	 SHORT $LN11@P_CreatePr

; 3685 : 	{
; 3686 : 		if (!node->m_thing)

  0019c	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0019f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001a3	75 28		 jne	 SHORT $LN12@P_CreatePr

; 3687 : 		{
; 3688 : 			if (node == precipsector_list)

  001a5	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001a8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _precipsector_list
  001ae	75 0c		 jne	 SHORT $LN14@P_CreatePr

; 3689 : 				precipsector_list = node->m_tnext;

  001b0	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001b3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _precipsector_list, ecx
$LN14@P_CreatePr:

; 3690 : 			node = P_DelPrecipSecnode(node);

  001bc	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _P_DelPrecipSecnode
  001c5	83 c4 04	 add	 esp, 4
  001c8	89 45 e4	 mov	 DWORD PTR _node$[ebp], eax

; 3691 : 		}

  001cb	eb 09		 jmp	 SHORT $LN13@P_CreatePr
$LN12@P_CreatePr:

; 3692 : 		else
; 3693 : 			node = node->m_tnext;

  001cd	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  001d0	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001d3	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx
$LN13@P_CreatePr:

; 3694 : 	}

  001d6	eb be		 jmp	 SHORT $LN10@P_CreatePr
$LN11@P_CreatePr:

; 3695 : 
; 3696 : 	/* cph -
; 3697 : 	* This is the strife we get into for using global variables. tmthing
; 3698 : 	*  is being used by several different functions calling
; 3699 : 	*  P_BlockThingIterator, including functions that can be called *from*
; 3700 : 	*  P_BlockThingIterator. Using a global tmthing is not reentrant.
; 3701 : 	* OTOH for Boom/MBF demos we have to preserve the buggy behavior.
; 3702 : 	*  Fun. We restore its previous value unless we're in a Boom/MBF demo.
; 3703 : 	*/
; 3704 : 	tmprecipthing = saved_tmthing;

  001d8	8b 45 e0	 mov	 eax, DWORD PTR _saved_tmthing$[ebp]
  001db	a3 00 00 00 00	 mov	 DWORD PTR _tmprecipthing, eax

; 3705 : }

  001e0	5f		 pop	 edi
  001e1	5e		 pop	 esi
  001e2	5b		 pop	 ebx
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
_P_CreatePrecipSecNodeList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Downloads\SRB2-Public-master\src\m_fixed.h
;	COMDAT _FixedDiv
_TEXT	SEGMENT
tv72 = -68						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_FixedDiv PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 236  : 	if ((abs(a) >> (FRACBITS-2)) >= abs(b))

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _abs
  00012	83 c4 04	 add	 esp, 4
  00015	8b f0		 mov	 esi, eax
  00017	c1 fe 0e	 sar	 esi, 14			; 0000000eH
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _abs
  00023	83 c4 04	 add	 esp, 4
  00026	3b f0		 cmp	 esi, eax
  00028	7c 1d		 jl	 SHORT $LN2@FixedDiv

; 237  : 		return (a^b) < 0 ? INT32_MIN : INT32_MAX;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002d	33 45 0c	 xor	 eax, DWORD PTR _b$[ebp]
  00030	7d 09		 jge	 SHORT $LN4@FixedDiv
  00032	c7 45 bc 00 00
	00 80		 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00039	eb 07		 jmp	 SHORT $LN5@FixedDiv
$LN4@FixedDiv:
  0003b	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN5@FixedDiv:
  00042	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  00045	eb 10		 jmp	 SHORT $LN1@FixedDiv
$LN2@FixedDiv:

; 238  : 
; 239  : 	return FixedDiv2(a, b);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _FixedDiv2
  00054	83 c4 08	 add	 esp, 8
$LN1@FixedDiv:

; 240  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_FixedDiv ENDP
_TEXT	ENDS
END
