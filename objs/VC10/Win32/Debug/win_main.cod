; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\win_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_hWndMain
PUBLIC	_logstream
PUBLIC	_appActive
PUBLIC	_nodinput
PUBLIC	??_C@_06PLFOGFKH@SRB2WC@			; `string'
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_hWndMain DD	01H DUP (?)
_appActive DD	01H DUP (?)
_nodinput DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06PLFOGFKH@SRB2WC@
CONST	SEGMENT
??_C@_06PLFOGFKH@SRB2WC@ DB 'SRB2WC', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_logstream DD	0ffffffffH
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	??_C@_09DPOKLOFF@?9nodinput@			; `string'
PUBLIC	??_C@_0M@HNFIPFIH@Game?5Paused@			; `string'
PUBLIC	??_C@_0L@JANDOH@?9noconsole@			; `string'
PUBLIC	??_C@_0L@NMOFPIPP@?9dedicated@			; `string'
PUBLIC	??_C@_0P@CECDJDNL@?9detachconsole@		; `string'
PUBLIC	??_C@_0DB@HEBJFNLA@We?5lost?5a?5Console?0?5let?5hope?5it?5@ ; `string'
PUBLIC	??_C@_0BL@GPNIOAKO@We?5did?5not?5lost?5a?5Console?6@ ; `string'
PUBLIC	??_C@_0N@JIDKBBBN@SRB2?5Console@		; `string'
PUBLIC	??_C@_0CH@COCNADMK@Hello?0?5it?8s?5me?0?5SRB2?8s?5Console?5@ ; `string'
PUBLIC	??_C@_0CB@HAKLCOOF@We?5have?5a?5Console?5Already?$DP?5Why?$DP@ ; `string'
PUBLIC	??_C@_06GDENEHCP@CONIN$@			; `string'
PUBLIC	??_C@_0DD@OLGGCOEK@Old?5STD_INPUT_HANDLE?3?5?$CFp?6New?5ST@ ; `string'
PUBLIC	??_C@_0CE@NFGODDED@STD_INPUT_HANDLE?5already?5set?5at@ ; `string'
PUBLIC	??_C@_0CH@BEJLDKHN@Handle?5CONIN$?5in?5not?5a?5Console?5@ ; `string'
PUBLIC	??_C@_0BP@CPLJDKEN@Could?5not?5get?5a?5CONIN$?5HANDLE?6@ ; `string'
PUBLIC	??_C@_07GPDNMNG@CONOUT$@			; `string'
PUBLIC	??_C@_0DF@LAENPMOH@Old?5STD_OUTPUT_HANDLE?3?5?$CFp?6New?5S@ ; `string'
PUBLIC	??_C@_0CF@IGEPLCKP@STD_OUTPUT_HANDLE?5already?5set?5a@ ; `string'
PUBLIC	??_C@_0DD@DEEGLGIO@Old?5STD_ERROR_HANDLE?3?5?$CFp?6New?5ST@ ; `string'
PUBLIC	??_C@_0CE@HGEIEHFA@STD_ERROR_HANDLE?5already?5set?5at@ ; `string'
PUBLIC	??_C@_0CA@EBJCKNJF@Could?5not?5get?5a?5CONOUT$?5HANDLE?6@ ; `string'
PUBLIC	??_C@_0BO@JNBPKNBE@Error?5doing?5RegisterClassExA?6@ ; `string'
PUBLIC	??_C@_06EGEBBOP@?9width@			; `string'
PUBLIC	??_C@_0BN@HJNCEGB@Error?5doing?5CreateWindowExA?6@ ; `string'
PUBLIC	??_C@_0M@LLMIPDBE@Error?5?$CFs?4?4?6@		; `string'
PUBLIC	??_C@_05MBDEGLCK@ERROR@				; `string'
PUBLIC	??_C@_07BLMAKGOG@?4text?$AA?$AA@		; `string'
PUBLIC	??_C@_0BO@LJIPKKNI@Could?5not?5make?5code?5writable?6@ ; `string'
PUBLIC	??_C@_07POILLFDI@log?4txt@			; `string'
PUBLIC	??_C@_0BD@HOJJPBLO@GetArgcArgv?$CI?$CJ?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BD@GMJFHDAM@lpCmdLine?5is?5?8?$CFs?8?6@	; `string'
PUBLIC	??_C@_0M@GJHEEHIK@Myargc?3?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BD@BJLEBCJO@myargv?$FL?$CFd?$FN?5?3?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0M@GGOHGJLL@SRB2?5v2?40?47@		; `string'
PUBLIC	??_C@_0BF@NMMEIJPD@Couldn?8t?5open?5window@	; `string'
PUBLIC	??_C@_0BH@ENLJEGJK@I_StartupSystem?$CI?$CJ?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BC@KCNHFKHN@D_SRB2Main?$CI?$CJ?5?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BL@LNMADEIA@Entering?5main?5app?5loop?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BC@KNBMEBEO@IsDebuggerPresent@		; `string'
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll@		; `string'
PUBLIC	??_C@_0M@CKMPPPHB@exchndl?4dll@			; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__SetStdHandle@8:PROC
EXTRN	__imp__GetCommandLineA@0:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetFileType@4:PROC
EXTRN	__imp__SetUnhandledExceptionFilter@4:PROC
EXTRN	__imp__VirtualProtect@16:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__MapVirtualKeyA@8:PROC
EXTRN	__imp__DrawTextA@20:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__AllocConsole@0:PROC
EXTRN	__imp__FreeConsole@0:PROC
EXTRN	__imp__GetConsoleMode@8:PROC
EXTRN	__imp__SetConsoleTitleA@4:PROC
EXTRN	_atoi:PROC
EXTRN	_strlcpy:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fflush:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_COM_BufAddText:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_D_SRB2Loop:PROC
EXTRN	_D_SRB2Main:PROC
EXTRN	_D_PostEvent:PROC
EXTRN	_I_StartupSystem:PROC
EXTRN	_RestoreDDPalette:PROC
EXTRN	_I_SetMidiChannelVolume:PROC
EXTRN	_I_GetSysMouseEvents:PROC
EXTRN	_LoadDirectInput:PROC
EXTRN	_I_ShowLastError:PROC
EXTRN	_RecordExceptionInfo@4:PROC
EXTRN	_I_PauseSong:PROC
EXTRN	_I_ResumeSong:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_netgame:DWORD
EXTRN	_paused:BYTE
EXTRN	_dedicated:DWORD
EXTRN	_myargc:DWORD
EXTRN	_myargv:DWORD
EXTRN	_specialmodes:BYTE
EXTRN	_vid:BYTE
EXTRN	_keyboard_started:BYTE
EXTRN	_bAppFullScreen:DWORD
EXTRN	_windowPosX:DWORD
EXTRN	_windowPosY:DWORD
EXTRN	_dwVolumePercent:DWORD
EXTRN	_MSHWheelMessage:DWORD
EXTRN	_win9x:DWORD
EXTRN	_prevExceptionFilter:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_windowCursor DD 01H DUP (?)
_myWargv DD	041H DUP (?)
_myCmdline DB	0200H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@CKMPPPHB@exchndl?4dll@
CONST	SEGMENT
??_C@_0M@CKMPPPHB@exchndl?4dll@ DB 'exchndl.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll@ DB 'kernel32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNBMEBEO@IsDebuggerPresent@
CONST	SEGMENT
??_C@_0BC@KNBMEBEO@IsDebuggerPresent@ DB 'IsDebuggerPresent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LNMADEIA@Entering?5main?5app?5loop?4?4?4?6@
CONST	SEGMENT
??_C@_0BL@LNMADEIA@Entering?5main?5app?5loop?4?4?4?6@ DB 'Entering main a'
	DB	'pp loop...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCNHFKHN@D_SRB2Main?$CI?$CJ?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BC@KCNHFKHN@D_SRB2Main?$CI?$CJ?5?4?4?4?6@ DB 'D_SRB2Main() ...', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENLJEGJK@I_StartupSystem?$CI?$CJ?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BH@ENLJEGJK@I_StartupSystem?$CI?$CJ?5?4?4?4?6@ DB 'I_StartupSystem'
	DB	'() ...', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NMMEIJPD@Couldn?8t?5open?5window@
CONST	SEGMENT
??_C@_0BF@NMMEIJPD@Couldn?8t?5open?5window@ DB 'Couldn''t open window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGOHGJLL@SRB2?5v2?40?47@
CONST	SEGMENT
??_C@_0M@GGOHGJLL@SRB2?5v2?40?47@ DB 'SRB2 v2.0.7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJLEBCJO@myargv?$FL?$CFd?$FN?5?3?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BD@BJLEBCJO@myargv?$FL?$CFd?$FN?5?3?5?8?$CFs?8?6@ DB 'myargv[%d] :'
	DB	' ''%s''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GJHEEHIK@Myargc?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0M@GJHEEHIK@Myargc?3?5?$CFd?6@ DB 'Myargc: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMJFHDAM@lpCmdLine?5is?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0BD@GMJFHDAM@lpCmdLine?5is?5?8?$CFs?8?6@ DB 'lpCmdLine is ''%s''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HOJJPBLO@GetArgcArgv?$CI?$CJ?5?4?4?4?6@
CONST	SEGMENT
??_C@_0BD@HOJJPBLO@GetArgcArgv?$CI?$CJ?5?4?4?4?6@ DB 'GetArgcArgv() ...', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07POILLFDI@log?4txt@
CONST	SEGMENT
??_C@_07POILLFDI@log?4txt@ DB 'log.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LJIPKKNI@Could?5not?5make?5code?5writable?6@
CONST	SEGMENT
??_C@_0BO@LJIPKKNI@Could?5not?5make?5code?5writable?6@ DB 'Could not make'
	DB	' code writable', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BLMAKGOG@?4text?$AA?$AA@
CONST	SEGMENT
??_C@_07BLMAKGOG@?4text?$AA?$AA@ DB '.text', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDEGLCK@ERROR@
CONST	SEGMENT
??_C@_05MBDEGLCK@ERROR@ DB 'ERROR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLMIPDBE@Error?5?$CFs?4?4?6@
CONST	SEGMENT
??_C@_0M@LLMIPDBE@Error?5?$CFs?4?4?6@ DB 'Error %s..', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HJNCEGB@Error?5doing?5CreateWindowExA?6@
CONST	SEGMENT
??_C@_0BN@HJNCEGB@Error?5doing?5CreateWindowExA?6@ DB 'Error doing Create'
	DB	'WindowExA', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGEBBOP@?9width@
CONST	SEGMENT
??_C@_06EGEBBOP@?9width@ DB '-width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JNBPKNBE@Error?5doing?5RegisterClassExA?6@
CONST	SEGMENT
??_C@_0BO@JNBPKNBE@Error?5doing?5RegisterClassExA?6@ DB 'Error doing Regi'
	DB	'sterClassExA', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EBJCKNJF@Could?5not?5get?5a?5CONOUT$?5HANDLE?6@
CONST	SEGMENT
??_C@_0CA@EBJCKNJF@Could?5not?5get?5a?5CONOUT$?5HANDLE?6@ DB 'Could not g'
	DB	'et a CONOUT$ HANDLE', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HGEIEHFA@STD_ERROR_HANDLE?5already?5set?5at@
CONST	SEGMENT
??_C@_0CE@HGEIEHFA@STD_ERROR_HANDLE?5already?5set?5at@ DB 'STD_ERROR_HAND'
	DB	'LE already set at %p', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DEEGLGIO@Old?5STD_ERROR_HANDLE?3?5?$CFp?6New?5ST@
CONST	SEGMENT
??_C@_0DD@DEEGLGIO@Old?5STD_ERROR_HANDLE?3?5?$CFp?6New?5ST@ DB 'Old STD_E'
	DB	'RROR_HANDLE: %p', 0aH, 'New STD_ERROR_HANDLE: %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IGEPLCKP@STD_OUTPUT_HANDLE?5already?5set?5a@
CONST	SEGMENT
??_C@_0CF@IGEPLCKP@STD_OUTPUT_HANDLE?5already?5set?5a@ DB 'STD_OUTPUT_HAN'
	DB	'DLE already set at %p', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LAENPMOH@Old?5STD_OUTPUT_HANDLE?3?5?$CFp?6New?5S@
CONST	SEGMENT
??_C@_0DF@LAENPMOH@Old?5STD_OUTPUT_HANDLE?3?5?$CFp?6New?5S@ DB 'Old STD_O'
	DB	'UTPUT_HANDLE: %p', 0aH, 'New STD_OUTPUT_HANDLE: %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GPDNMNG@CONOUT$@
CONST	SEGMENT
??_C@_07GPDNMNG@CONOUT$@ DB 'CONOUT$', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CPLJDKEN@Could?5not?5get?5a?5CONIN$?5HANDLE?6@
CONST	SEGMENT
??_C@_0BP@CPLJDKEN@Could?5not?5get?5a?5CONIN$?5HANDLE?6@ DB 'Could not ge'
	DB	't a CONIN$ HANDLE', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BEJLDKHN@Handle?5CONIN$?5in?5not?5a?5Console?5@
CONST	SEGMENT
??_C@_0CH@BEJLDKHN@Handle?5CONIN$?5in?5not?5a?5Console?5@ DB 'Handle CONI'
	DB	'N$ in not a Console HANDLE', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NFGODDED@STD_INPUT_HANDLE?5already?5set?5at@
CONST	SEGMENT
??_C@_0CE@NFGODDED@STD_INPUT_HANDLE?5already?5set?5at@ DB 'STD_INPUT_HAND'
	DB	'LE already set at %p', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OLGGCOEK@Old?5STD_INPUT_HANDLE?3?5?$CFp?6New?5ST@
CONST	SEGMENT
??_C@_0DD@OLGGCOEK@Old?5STD_INPUT_HANDLE?3?5?$CFp?6New?5ST@ DB 'Old STD_I'
	DB	'NPUT_HANDLE: %p', 0aH, 'New STD_INPUT_HANDLE: %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDENEHCP@CONIN$@
CONST	SEGMENT
??_C@_06GDENEHCP@CONIN$@ DB 'CONIN$', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HAKLCOOF@We?5have?5a?5Console?5Already?$DP?5Why?$DP@
CONST	SEGMENT
??_C@_0CB@HAKLCOOF@We?5have?5a?5Console?5Already?$DP?5Why?$DP@ DB 'We hav'
	DB	'e a Console Already? Why?', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@COCNADMK@Hello?0?5it?8s?5me?0?5SRB2?8s?5Console?5@
CONST	SEGMENT
??_C@_0CH@COCNADMK@Hello?0?5it?8s?5me?0?5SRB2?8s?5Console?5@ DB 'Hello, i'
	DB	't''s me, SRB2''s Console Window', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIDKBBBN@SRB2?5Console@
CONST	SEGMENT
??_C@_0N@JIDKBBBN@SRB2?5Console@ DB 'SRB2 Console', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GPNIOAKO@We?5did?5not?5lost?5a?5Console?6@
CONST	SEGMENT
??_C@_0BL@GPNIOAKO@We?5did?5not?5lost?5a?5Console?6@ DB 'We did not lost '
	DB	'a Console', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HEBJFNLA@We?5lost?5a?5Console?0?5let?5hope?5it?5@
CONST	SEGMENT
??_C@_0DB@HEBJFNLA@We?5lost?5a?5Console?0?5let?5hope?5it?5@ DB 'We lost a'
	DB	' Console, let hope it was Mingw''s Bash', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CECDJDNL@?9detachconsole@
CONST	SEGMENT
??_C@_0P@CECDJDNL@?9detachconsole@ DB '-detachconsole', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMOFPIPP@?9dedicated@
CONST	SEGMENT
??_C@_0L@NMOFPIPP@?9dedicated@ DB '-dedicated', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JANDOH@?9noconsole@
CONST	SEGMENT
??_C@_0L@JANDOH@?9noconsole@ DB '-noconsole', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HNFIPFIH@Game?5Paused@
CONST	SEGMENT
??_C@_0M@HNFIPFIH@Game?5Paused@ DB 'Game Paused', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPOKLOFF@?9nodinput@
CONST	SEGMENT
??_C@_09DPOKLOFF@?9nodinput@ DB '-nodinput', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_wClassName DD	FLAT:??_C@_06PLFOGFKH@SRB2WC@
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0562H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _HandledWinMain@4
_TEXT	SEGMENT
_args$ = -8						; size = 4
_i$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_HandledWinMain@4 PROC					; COMDAT

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 646  : 	int             i;
; 647  : 	LPSTR          args;
; 648  : #ifdef PHONE_HOME
; 649  : 	WSADATA wsaData;
; 650  : 	char szBuffer[100];
; 651  : 	SOCKET sock;
; 652  : #endif
; 653  : 
; 654  : #ifdef LOGMESSAGES
; 655  : 	// DEBUG!!! - set logstream to NULL to disable debug log
; 656  : 	logstream = CreateFile (TEXT("log.txt"), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,

  00009	6a 00		 push	 0
  0000b	68 80 00 00 00	 push	 128			; 00000080H
  00010	6a 02		 push	 2
  00012	6a 00		 push	 0
  00014	6a 01		 push	 1
  00016	68 00 00 00 40	 push	 1073741824		; 40000000H
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_07POILLFDI@log?4txt@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00026	a3 00 00 00 00	 mov	 DWORD PTR _logstream, eax

; 657  : 	                        FILE_ATTRIBUTE_NORMAL, NULL);  //file flag writethrough?
; 658  : #endif
; 659  : 
; 660  : #ifdef PHONE_HOME
; 661  : 	// Initialize WinSock
; 662  : 	if(WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
; 663  : 	{
; 664  : 		MessageBox(NULL, "Could not initialize sockets.", "Error", MB_OK|MB_APPLMODAL);
; 665  : 		return FALSE;
; 666  : 	}
; 667  : 
; 668  : 	// Create socket and connect to server
; 669  : 	sock = ConnectSocket("ssntails.isa-geek.net");
; 670  : 	if(sock == INVALID_SOCKET)
; 671  : 	{
; 672  : 		MessageBox(NULL, "Invalid socket error.", "Error", MB_OK|MB_APPLMODAL);
; 673  : 		return FALSE;
; 674  : 	}
; 675  : 
; 676  : 	// We're connected!
; 677  : 	// Now send information to server
; 678  : 	{
; 679  : 		int nSent, nToSend, nRecv, nReceived;
; 680  : 		strcpy(szBuffer, "SRB2");
; 681  : 		strcat(szBuffer, VERSIONSTRING);
; 682  : 		nToSend = strlen(szBuffer) + 1;
; 683  : 		// send this line to the server
; 684  : 		nSent = send(sock, szBuffer, nToSend, 0);
; 685  : 
; 686  : 		if(nSent == SOCKET_ERROR)
; 687  : 		{
; 688  : 			MessageBox(NULL, "Connection broken.", "Error", MB_OK|MB_APPLMODAL);
; 689  : 			return FALSE;
; 690  : 		}
; 691  : 
; 692  : 		// Now read back the number of chars received.
; 693  : 		nRecv = recv(sock, (char*)&nReceived, sizeof(nReceived), 0);
; 694  : 
; 695  : 		if(nRecv != sizeof(nReceived))
; 696  : 		{
; 697  : 			MessageBox(NULL, "You aren't allowed to have this.", "Error", MB_OK|MB_APPLMODAL);
; 698  : 			return FALSE;
; 699  : 		}
; 700  : 
; 701  : 		if(nReceived != 42)
; 702  : 		{
; 703  : 			MessageBox(NULL, "You aren't allowed to have this.", "Error", MB_OK|MB_APPLMODAL);
; 704  : 			return FALSE;
; 705  : 		}
; 706  : 	}
; 707  : 
; 708  : 	if (shutdown(sock, 2) == SOCKET_ERROR)
; 709  : 	{
; 710  : 		MessageBox(NULL, "shutdown(): Error cleaning up sockets.", "Error", MB_OK|MB_APPLMODAL);
; 711  : 		return FALSE;
; 712  : 	}
; 713  : 
; 714  : 	// close socket
; 715  : 	closesocket(sock);
; 716  : 
; 717  : 	// Clean up WinSock
; 718  : 	if(WSACleanup() == SOCKET_ERROR)
; 719  : 	{
; 720  : 		MessageBox(NULL, "WSACleanup(): Error cleaning up sockets.", "Error", MB_OK|MB_APPLMODAL);
; 721  : 		return FALSE;
; 722  : 	}
; 723  : #endif
; 724  : 
; 725  : 	// fill myargc,myargv for m_argv.c retrieval of cmdline arguments
; 726  : 	CONS_Printf("GetArgcArgv() ...\n");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HOJJPBLO@GetArgcArgv?$CI?$CJ?5?4?4?4?6@
  00030	e8 00 00 00 00	 call	 _CONS_Printf
  00035	83 c4 04	 add	 esp, 4

; 727  : 	args = GetCommandLineA();

  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineA@0
  0003e	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 728  : 	CONS_Printf("lpCmdLine is '%s'\n", args);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GMJFHDAM@lpCmdLine?5is?5?8?$CFs?8?6@
  0004a	e8 00 00 00 00	 call	 _CONS_Printf
  0004f	83 c4 08	 add	 esp, 8

; 729  : 	GetArgcArgv(args);

  00052	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _GetArgcArgv
  0005b	83 c4 04	 add	 esp, 4

; 730  : 	// Create a text console window
; 731  : 	OpenTextConsole();

  0005e	e8 00 00 00 00	 call	 _OpenTextConsole
  00063	90		 npad	 1

; 732  : 
; 733  : 	CONS_Printf("Myargc: %d\n", myargc);

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargc
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GJHEEHIK@Myargc?3?5?$CFd?6@
  0006f	e8 00 00 00 00	 call	 _CONS_Printf
  00074	83 c4 08	 add	 esp, 8

; 734  : 	for (i = 0; i < myargc; i++)

  00077	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0007e	eb 09		 jmp	 SHORT $LN4@HandledWin
$LN2@HandledWin:
  00080	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HandledWin:
  00089	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _myargc
  00092	7d 20		 jge	 SHORT $LN3@HandledWin

; 735  : 		CONS_Printf("myargv[%d] : '%s'\n", i, myargv[i]);

  00094	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _myargv
  0009d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000a0	52		 push	 edx
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BJLEBCJO@myargv?$FL?$CFd?$FN?5?3?5?8?$CFs?8?6@
  000aa	e8 00 00 00 00	 call	 _CONS_Printf
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	eb cc		 jmp	 SHORT $LN2@HandledWin
$LN3@HandledWin:

; 736  : 
; 737  : 	// open a dummy window, both OpenGL and DirectX need one.
; 738  : 	if ((hWndMain = OpenMainWindow(hInstance, va("SRB2"VERSIONSTRING))) == INVALID_HANDLE_VALUE)

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GGOHGJLL@SRB2?5v2?40?47@
  000b9	e8 00 00 00 00	 call	 _va
  000be	83 c4 04	 add	 esp, 4
  000c1	50		 push	 eax
  000c2	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _OpenMainWindow
  000cb	83 c4 08	 add	 esp, 8
  000ce	a3 00 00 00 00	 mov	 DWORD PTR _hWndMain, eax
  000d3	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _hWndMain, -1
  000da	75 11		 jne	 SHORT $LN5@HandledWin

; 739  : 	{
; 740  : 		tlErrorMessage(TEXT("Couldn't open window"));

  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NMMEIJPD@Couldn?8t?5open?5window@
  000e1	e8 00 00 00 00	 call	 _tlErrorMessage
  000e6	83 c4 04	 add	 esp, 4

; 741  : 		return FALSE;

  000e9	33 c0		 xor	 eax, eax
  000eb	eb 41		 jmp	 SHORT $LN1@HandledWin
$LN5@HandledWin:

; 742  : 	}
; 743  : 
; 744  : 	// currently starts DirectInput
; 745  : 	CONS_Printf("I_StartupSystem() ...\n");

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ENLJEGJK@I_StartupSystem?$CI?$CJ?5?4?4?4?6@
  000f2	e8 00 00 00 00	 call	 _CONS_Printf
  000f7	83 c4 04	 add	 esp, 4

; 746  : 	I_StartupSystem();

  000fa	e8 00 00 00 00	 call	 _I_StartupSystem
  000ff	90		 npad	 1

; 747  : 	MakeCodeWritable();

  00100	e8 00 00 00 00	 call	 _MakeCodeWritable
  00105	90		 npad	 1

; 748  : 
; 749  : 	// startup SRB2
; 750  : 	CONS_Printf("D_SRB2Main() ...\n");

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KCNHFKHN@D_SRB2Main?$CI?$CJ?5?4?4?4?6@
  0010b	e8 00 00 00 00	 call	 _CONS_Printf
  00110	83 c4 04	 add	 esp, 4

; 751  : 	D_SRB2Main();

  00113	e8 00 00 00 00	 call	 _D_SRB2Main
  00118	90		 npad	 1

; 752  : 	CONS_Printf("Entering main app loop...\n");

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LNMADEIA@Entering?5main?5app?5loop?4?4?4?6@
  0011e	e8 00 00 00 00	 call	 _CONS_Printf
  00123	83 c4 04	 add	 esp, 4

; 753  : 	// never return
; 754  : 	D_SRB2Loop();

  00126	e8 00 00 00 00	 call	 _D_SRB2Loop
  0012b	90		 npad	 1

; 755  : 
; 756  : 	// back to Windoze
; 757  : 	return 0;

  0012c	33 c0		 xor	 eax, eax
$LN1@HandledWin:

; 758  : }

  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c2 04 00	 ret	 4
_HandledWinMain@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _MakeCodeWritable
_TEXT	SEGMENT
_s$ = -40						; size = 2
_ntS$ = -36						; size = 4
_pS$ = -32						; size = 4
_pA$ = -28						; size = 4
_oH$ = -24						; size = 4
_ntH$ = -20						; size = 4
_dosH$ = -16						; size = 4
_pBaseOfImage$ = -12					; size = 4
_NewRights$ = -8					; size = 4
_OldRights$ = -4					; size = 4
_MakeCodeWritable PROC					; COMDAT

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 567  : #ifdef USEASM // Disable write-protection of code segment
; 568  : 	DWORD OldRights;
; 569  : 	const DWORD NewRights = PAGE_EXECUTE_READWRITE;

  00009	c7 45 f8 40 00
	00 00		 mov	 DWORD PTR _NewRights$[ebp], 64 ; 00000040H

; 570  : 	PBYTE pBaseOfImage = (PBYTE)GetModuleHandle(NULL);

  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00018	89 45 f4	 mov	 DWORD PTR _pBaseOfImage$[ebp], eax

; 571  : 	PIMAGE_DOS_HEADER dosH =(PIMAGE_DOS_HEADER)pBaseOfImage;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _pBaseOfImage$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _dosH$[ebp], eax

; 572  : 	PIMAGE_NT_HEADERS ntH = (PIMAGE_NT_HEADERS)(pBaseOfImage + dosH->e_lfanew);

  00021	8b 45 f0	 mov	 eax, DWORD PTR _dosH$[ebp]
  00024	8b 4d f4	 mov	 ecx, DWORD PTR _pBaseOfImage$[ebp]
  00027	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  0002a	89 4d ec	 mov	 DWORD PTR _ntH$[ebp], ecx

; 573  : 	PIMAGE_OPTIONAL_HEADER oH = (PIMAGE_OPTIONAL_HEADER)

  0002d	8b 45 ec	 mov	 eax, DWORD PTR _ntH$[ebp]
  00030	83 c0 18	 add	 eax, 24			; 00000018H
  00033	89 45 e8	 mov	 DWORD PTR _oH$[ebp], eax

; 574  : 		((PBYTE)ntH + sizeof (IMAGE_NT_SIGNATURE) + sizeof (IMAGE_FILE_HEADER));
; 575  : 	LPVOID pA = pBaseOfImage+oH->BaseOfCode;

  00036	8b 45 e8	 mov	 eax, DWORD PTR _oH$[ebp]
  00039	8b 4d f4	 mov	 ecx, DWORD PTR _pBaseOfImage$[ebp]
  0003c	03 48 14	 add	 ecx, DWORD PTR [eax+20]
  0003f	89 4d e4	 mov	 DWORD PTR _pA$[ebp], ecx

; 576  : 	SIZE_T pS = oH->SizeOfCode;

  00042	8b 45 e8	 mov	 eax, DWORD PTR _oH$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	89 4d e0	 mov	 DWORD PTR _pS$[ebp], ecx

; 577  : #if 1 // try to find the text section
; 578  : 	PIMAGE_SECTION_HEADER ntS = IMAGE_FIRST_SECTION (ntH);

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _ntH$[ebp]
  0004e	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00052	8b 55 ec	 mov	 edx, DWORD PTR _ntH$[ebp]
  00055	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  00059	89 45 dc	 mov	 DWORD PTR _ntS$[ebp], eax

; 579  : 	WORD s;
; 580  : 	for (s = 0; s < ntH->FileHeader.NumberOfSections; s++)

  0005c	33 c0		 xor	 eax, eax
  0005e	66 89 45 d8	 mov	 WORD PTR _s$[ebp], ax
  00062	eb 0c		 jmp	 SHORT $LN4@MakeCodeWr
$LN2@MakeCodeWr:
  00064	66 8b 45 d8	 mov	 ax, WORD PTR _s$[ebp]
  00068	66 83 c0 01	 add	 ax, 1
  0006c	66 89 45 d8	 mov	 WORD PTR _s$[ebp], ax
$LN4@MakeCodeWr:
  00070	0f b7 45 d8	 movzx	 eax, WORD PTR _s$[ebp]
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _ntH$[ebp]
  00077	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0007b	3b c2		 cmp	 eax, edx
  0007d	7d 47		 jge	 SHORT $LN3@MakeCodeWr

; 581  : 	{
; 582  : 		if (memcmp (ntS[s].Name, ".text\0\0", 8) == 0)

  0007f	6a 08		 push	 8
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_07BLMAKGOG@?4text?$AA?$AA@
  00086	0f b7 45 d8	 movzx	 eax, WORD PTR _s$[ebp]
  0008a	6b c8 28	 imul	 ecx, eax, 40
  0008d	03 4d dc	 add	 ecx, DWORD PTR _ntS$[ebp]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _memcmp
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	85 c0		 test	 eax, eax
  0009b	75 27		 jne	 SHORT $LN5@MakeCodeWr

; 583  : 		{
; 584  : 			pA = pBaseOfImage+ntS[s].VirtualAddress;

  0009d	0f b7 45 d8	 movzx	 eax, WORD PTR _s$[ebp]
  000a1	6b c8 28	 imul	 ecx, eax, 40
  000a4	8b 55 dc	 mov	 edx, DWORD PTR _ntS$[ebp]
  000a7	8b 45 f4	 mov	 eax, DWORD PTR _pBaseOfImage$[ebp]
  000aa	03 44 0a 0c	 add	 eax, DWORD PTR [edx+ecx+12]
  000ae	89 45 e4	 mov	 DWORD PTR _pA$[ebp], eax

; 585  : 			pS = ntS[s].Misc.VirtualSize;

  000b1	0f b7 45 d8	 movzx	 eax, WORD PTR _s$[ebp]
  000b5	6b c8 28	 imul	 ecx, eax, 40
  000b8	8b 55 dc	 mov	 edx, DWORD PTR _ntS$[ebp]
  000bb	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  000bf	89 45 e0	 mov	 DWORD PTR _pS$[ebp], eax

; 586  : 			break;

  000c2	eb 02		 jmp	 SHORT $LN3@MakeCodeWr
$LN5@MakeCodeWr:

; 587  : 		}
; 588  : 	}

  000c4	eb 9e		 jmp	 SHORT $LN2@MakeCodeWr
$LN3@MakeCodeWr:

; 589  : #endif
; 590  : 
; 591  : 	if (!VirtualProtect(pA,pS,NewRights,&OldRights))

  000c6	8d 45 fc	 lea	 eax, DWORD PTR _OldRights$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _NewRights$[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 e0	 mov	 edx, DWORD PTR _pS$[ebp]
  000d1	52		 push	 edx
  000d2	8b 45 e4	 mov	 eax, DWORD PTR _pA$[ebp]
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualProtect@16
  000dc	85 c0		 test	 eax, eax
  000de	75 0d		 jne	 SHORT $LN6@MakeCodeWr

; 592  : 		I_Error("Could not make code writable\n");

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LJIPKKNI@Could?5not?5make?5code?5writable?6@
  000e5	e8 00 00 00 00	 call	 _I_Error
  000ea	83 c4 04	 add	 esp, 4
$LN6@MakeCodeWr:

; 593  : #endif
; 594  : }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
_MakeCodeWritable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _GetArgcArgv
_TEXT	SEGMENT
$T1 = -92						; size = 4
_prevCvar$ = -24					; size = 4
_bCvar$ = -20						; size = 4
_cSep$ = -13						; size = 1
_len$ = -12						; size = 4
_i$ = -8						; size = 4
_tokenstr$ = -4						; size = 4
_cmdline$ = 8						; size = 4
_GetArgcArgv PROC					; COMDAT

; 500  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 501  : 	LPSTR   tokenstr;
; 502  : 	size_t  i = 0, len;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 503  : 	char    cSep = ' ';

  00010	c6 45 f3 20	 mov	 BYTE PTR _cSep$[ebp], 32 ; 00000020H

; 504  : 	BOOL    bCvar = FALSE, prevCvar = FALSE;

  00014	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bCvar$[ebp], 0
  0001b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _prevCvar$[ebp], 0

; 505  : 
; 506  : 	// split arguments of command line into argv
; 507  : 	strlcpy (myCmdline, cmdline, sizeof(myCmdline));      // in case window's cmdline is in protected memory..for strtok

  00022	68 00 02 00 00	 push	 512			; 00000200H
  00027	8b 45 08	 mov	 eax, DWORD PTR _cmdline$[ebp]
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET _myCmdline
  00030	e8 00 00 00 00	 call	 _strlcpy
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 508  : 	len = strlen (myCmdline);

  00038	68 00 00 00 00	 push	 OFFSET _myCmdline
  0003d	e8 00 00 00 00	 call	 _strlen
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax

; 509  : 
; 510  : 	myargc = 0;

  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _myargc, 0
$LN2@GetArgcArg:

; 511  : 	while (myargc < MAXCMDLINEARGS)

  00052	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR _myargc, 64	; 00000040H
  00059	0f 8d 53 01 00
	00		 jge	 $LN3@GetArgcArg
$LN4@GetArgcArg:

; 512  : 	{
; 513  : 		// get token
; 514  : 		while (myCmdline[i] == cSep)

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00062	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  00069	0f be 55 f3	 movsx	 edx, BYTE PTR _cSep$[ebp]
  0006d	3b ca		 cmp	 ecx, edx
  0006f	75 0b		 jne	 SHORT $LN5@GetArgcArg

; 515  : 			i++;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0007a	eb e3		 jmp	 SHORT $LN4@GetArgcArg
$LN5@GetArgcArg:

; 516  : 		if (i >= len)

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	3b 45 f4	 cmp	 eax, DWORD PTR _len$[ebp]
  00082	72 05		 jb	 SHORT $LN8@GetArgcArg

; 517  : 			break;

  00084	e9 29 01 00 00	 jmp	 $LN3@GetArgcArg
$LN8@GetArgcArg:

; 518  : 		tokenstr = myCmdline + i;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	05 00 00 00 00	 add	 eax, OFFSET _myCmdline
  00091	89 45 fc	 mov	 DWORD PTR _tokenstr$[ebp], eax

; 519  : 		if (myCmdline[i] == '"')

  00094	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00097	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  0009e	83 f9 22	 cmp	 ecx, 34			; 00000022H
  000a1	75 1e		 jne	 SHORT $LN9@GetArgcArg

; 520  : 		{
; 521  : 			cSep = '"';

  000a3	c6 45 f3 22	 mov	 BYTE PTR _cSep$[ebp], 34 ; 00000022H

; 522  : 			i++;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	83 c0 01	 add	 eax, 1
  000ad	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 523  : 			if (!prevCvar)    //cvar leave the "" in

  000b0	83 7d e8 00	 cmp	 DWORD PTR _prevCvar$[ebp], 0
  000b4	75 09		 jne	 SHORT $LN11@GetArgcArg

; 524  : 				tokenstr++;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _tokenstr$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 fc	 mov	 DWORD PTR _tokenstr$[ebp], eax
$LN11@GetArgcArg:

; 525  : 		}

  000bf	eb 04		 jmp	 SHORT $LN10@GetArgcArg
$LN9@GetArgcArg:

; 526  : 		else
; 527  : 			cSep = ' ';

  000c1	c6 45 f3 20	 mov	 BYTE PTR _cSep$[ebp], 32 ; 00000020H
$LN10@GetArgcArg:

; 528  : 
; 529  : 		//cvar
; 530  : 		if (myCmdline[i] == '+' && cSep == ' ')   //a + begins a cvarname, but not after quotes

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c8	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  000cf	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  000d2	75 12		 jne	 SHORT $LN12@GetArgcArg
  000d4	0f be 45 f3	 movsx	 eax, BYTE PTR _cSep$[ebp]
  000d8	83 f8 20	 cmp	 eax, 32			; 00000020H
  000db	75 09		 jne	 SHORT $LN12@GetArgcArg

; 531  : 			bCvar = TRUE;

  000dd	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bCvar$[ebp], 1
  000e4	eb 07		 jmp	 SHORT $LN13@GetArgcArg
$LN12@GetArgcArg:

; 532  : 		else
; 533  : 			bCvar = FALSE;

  000e6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bCvar$[ebp], 0
$LN13@GetArgcArg:

; 534  : 
; 535  : 		while (myCmdline[i] &&

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f0	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  000f7	85 c9		 test	 ecx, ecx
  000f9	74 1d		 je	 SHORT $LN7@GetArgcArg
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000fe	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  00105	0f be 55 f3	 movsx	 edx, BYTE PTR _cSep$[ebp]
  00109	3b ca		 cmp	 ecx, edx
  0010b	74 0b		 je	 SHORT $LN7@GetArgcArg

; 536  : 				myCmdline[i] != cSep)
; 537  : 			i++;

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00116	eb d5		 jmp	 SHORT $LN13@GetArgcArg
$LN7@GetArgcArg:

; 538  : 
; 539  : 		if (myCmdline[i] == '"')

  00118	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0011b	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  00122	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00125	75 13		 jne	 SHORT $LN15@GetArgcArg

; 540  : 		{
; 541  : 			cSep = ' ';

  00127	c6 45 f3 20	 mov	 BYTE PTR _cSep$[ebp], 32 ; 00000020H

; 542  : 			if (prevCvar)

  0012b	83 7d e8 00	 cmp	 DWORD PTR _prevCvar$[ebp], 0
  0012f	74 09		 je	 SHORT $LN15@GetArgcArg

; 543  : 				i++; // get ending " quote in arg

  00131	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00134	83 c0 01	 add	 eax, 1
  00137	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN15@GetArgcArg:

; 544  : 		}
; 545  : 
; 546  : 		prevCvar = bCvar;

  0013a	8b 45 ec	 mov	 eax, DWORD PTR _bCvar$[ebp]
  0013d	89 45 e8	 mov	 DWORD PTR _prevCvar$[ebp], eax

; 547  : 
; 548  : 		if (myCmdline + i > tokenstr)

  00140	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00143	05 00 00 00 00	 add	 eax, OFFSET _myCmdline
  00148	3b 45 fc	 cmp	 eax, DWORD PTR _tokenstr$[ebp]
  0014b	76 1e		 jbe	 SHORT $LN16@GetArgcArg

; 549  : 		{
; 550  : 			myWargv[myargc++] = tokenstr;

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargc
  00152	8b 4d fc	 mov	 ecx, DWORD PTR _tokenstr$[ebp]
  00155	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _myWargv[eax*4], ecx
  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _myargc
  00162	83 c2 01	 add	 edx, 1
  00165	89 15 00 00 00
	00		 mov	 DWORD PTR _myargc, edx
$LN16@GetArgcArg:

; 551  : 		}
; 552  : 
; 553  : 		if (!myCmdline[i] || i >= len)

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0016e	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR _myCmdline[eax]
  00175	85 c9		 test	 ecx, ecx
  00177	74 08		 je	 SHORT $LN18@GetArgcArg
  00179	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0017c	3b 45 f4	 cmp	 eax, DWORD PTR _len$[ebp]
  0017f	72 02		 jb	 SHORT $LN17@GetArgcArg
$LN18@GetArgcArg:

; 554  : 			break;

  00181	eb 2f		 jmp	 SHORT $LN3@GetArgcArg
$LN17@GetArgcArg:

; 555  : 
; 556  : 		myCmdline[i++] = '\0';

  00183	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00186	89 45 a4	 mov	 DWORD PTR $T1[ebp], eax
  00189	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0018c	83 c1 01	 add	 ecx, 1
  0018f	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  00192	81 7d a4 00 02
	00 00		 cmp	 DWORD PTR $T1[ebp], 512	; 00000200H
  00199	73 02		 jae	 SHORT $LN20@GetArgcArg
  0019b	eb 06		 jmp	 SHORT $LN21@GetArgcArg
$LN20@GetArgcArg:
  0019d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
  001a2	90		 npad	 1
$LN21@GetArgcArg:
  001a3	8b 55 a4	 mov	 edx, DWORD PTR $T1[ebp]
  001a6	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _myCmdline[edx], 0

; 557  : 	}

  001ad	e9 a0 fe ff ff	 jmp	 $LN2@GetArgcArg
$LN3@GetArgcArg:

; 558  : 	myWargv[myargc] = NULL;

  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _myargc
  001b7	c7 04 85 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _myWargv[eax*4], 0

; 559  : 
; 560  : 	// m_argv.c uses myargv[], we used myWargv because we fill the arguments ourselves
; 561  : 	// and myargv is just a pointer, so we set it to point myWargv
; 562  : 	myargv = myWargv;

  001c2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _myargv, OFFSET _myWargv
$LN1@GetArgcArg:

; 563  : }

  001cc	5f		 pop	 edi
  001cd	5e		 pop	 esi
  001ce	5b		 pop	 ebx
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
_GetArgcArgv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _tlErrorMessage
_TEXT	SEGMENT
_err$ = 8						; size = 4
_tlErrorMessage PROC					; COMDAT

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 478  : 	/* make the cursor visible */
; 479  : 	SetCursor(LoadCursor(NULL, IDC_ARROW));

  00009	68 00 7f 00 00	 push	 32512			; 00007f00H
  0000e	6a 00		 push	 0
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  0001d	90		 npad	 1

; 480  : 
; 481  : 	//
; 482  : 	// warn user if there is one
; 483  : 	//
; 484  : 	printf("Error %s..\n", err);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _err$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LLMIPDBE@Error?5?$CFs?4?4?6@
  00027	e8 00 00 00 00	 call	 _printf
  0002c	83 c4 08	 add	 esp, 8

; 485  : 	fflush(stdout);

  0002f	6a 01		 push	 1
  00031	e8 00 00 00 00	 call	 ___acrt_iob_func
  00036	83 c4 04	 add	 esp, 4
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _fflush
  0003f	83 c4 04	 add	 esp, 4

; 486  : 
; 487  : 	MessageBox(hWndMain, err, TEXT("ERROR"), MB_OK);

  00042	6a 00		 push	 0
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_05MBDEGLCK@ERROR@
  00049	8b 45 08	 mov	 eax, DWORD PTR _err$[ebp]
  0004c	50		 push	 eax
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hWndMain
  00053	51		 push	 ecx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  0005a	90		 npad	 1

; 488  : 	return FALSE;

  0005b	33 c0		 xor	 eax, eax

; 489  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_tlErrorMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _OpenMainWindow
_TEXT	SEGMENT
tv137 = -128						; size = 4
tv131 = -124						; size = 4
_specialmode$ = -56					; size = 4
_wc$ = -52						; size = 48
_hWnd$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_wTitle$ = 12						; size = 4
_OpenMainWindow PROC					; COMDAT

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 418  : 	HWND        hWnd;
; 419  : 	WNDCLASSEXA wc;
; 420  : 	int specialmode = 0;

  0000c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _specialmode$[ebp], 0

; 421  : 
; 422  : 	// Set up and register window class
; 423  : 	ZeroMemory(&wc, sizeof(wc));

  00013	6a 30		 push	 48			; 00000030H
  00015	6a 00		 push	 0
  00017	8d 45 cc	 lea	 eax, DWORD PTR _wc$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 424  : 	wc.cbSize        = sizeof(wc);

  00023	c7 45 cc 30 00
	00 00		 mov	 DWORD PTR _wc$[ebp], 48	; 00000030H

; 425  : 	wc.style         = CS_HREDRAW | CS_VREDRAW /*| CS_DBLCLKS*/;

  0002a	c7 45 d0 03 00
	00 00		 mov	 DWORD PTR _wc$[ebp+4], 3

; 426  : 	wc.lpfnWndProc   = MainWndproc;

  00031	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+8], OFFSET _MainWndproc@16

; 427  : 	wc.hInstance     = hInstance;

  00038	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR _wc$[ebp+20], eax

; 428  : 	wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DLICON1));

  0003e	6a 65		 push	 101			; 00000065H
  00040	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0004a	89 45 e4	 mov	 DWORD PTR _wc$[ebp+24], eax

; 429  : 	windowCursor     = LoadCursor(NULL, IDC_WAIT); //LoadCursor(hInstance, MAKEINTRESOURCE(IDC_DLCURSOR1));

  0004d	68 02 7f 00 00	 push	 32514			; 00007f02H
  00052	6a 00		 push	 0
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  0005a	a3 00 00 00 00	 mov	 DWORD PTR _windowCursor, eax

; 430  : 	wc.hCursor       = windowCursor;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowCursor
  00064	89 45 e8	 mov	 DWORD PTR _wc$[ebp+28], eax

; 431  : 	wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);

  00067	6a 04		 push	 4
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  0006f	89 45 ec	 mov	 DWORD PTR _wc$[ebp+32], eax

; 432  : 	wc.lpszClassName = wClassName;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR _wClassName
  00077	89 45 f4	 mov	 DWORD PTR _wc$[ebp+40], eax

; 433  : 
; 434  : 	if (!RegisterClassExA(&wc))

  0007a	8d 45 cc	 lea	 eax, DWORD PTR _wc$[ebp]
  0007d	50		 push	 eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExA@4
  00084	0f b7 c8	 movzx	 ecx, ax
  00087	85 c9		 test	 ecx, ecx
  00089	75 1f		 jne	 SHORT $LN2@OpenMainWi

; 435  : 	{
; 436  : 		CONS_Printf("Error doing RegisterClassExA\n");

  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JNBPKNBE@Error?5doing?5RegisterClassExA?6@
  00090	e8 00 00 00 00	 call	 _CONS_Printf
  00095	83 c4 04	 add	 esp, 4

; 437  : 		I_ShowLastError(TRUE);

  00098	6a 01		 push	 1
  0009a	e8 00 00 00 00	 call	 _I_ShowLastError
  0009f	83 c4 04	 add	 esp, 4

; 438  : 		return INVALID_HANDLE_VALUE;

  000a2	83 c8 ff	 or	 eax, -1
  000a5	e9 d3 00 00 00	 jmp	 $LN1@OpenMainWi
$LN2@OpenMainWi:

; 439  : 	}
; 440  : 
; 441  : 	// Create a window
; 442  : 	// CreateWindowEx - seems to create just the interior, not the borders
; 443  : 
; 444  : 	if (M_CheckParm("-width") && M_IsNextParm())

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_06EGEBBOP@?9width@
  000af	e8 00 00 00 00	 call	 _M_CheckParm
  000b4	83 c4 04	 add	 esp, 4
  000b7	85 c0		 test	 eax, eax
  000b9	74 1a		 je	 SHORT $LN3@OpenMainWi
  000bb	e8 00 00 00 00	 call	 _M_IsNextParm
  000c0	85 c0		 test	 eax, eax
  000c2	74 11		 je	 SHORT $LN3@OpenMainWi

; 445  : 		specialmode = atoi(M_GetNextParm());

  000c4	e8 00 00 00 00	 call	 _M_GetNextParm
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _atoi
  000cf	83 c4 04	 add	 esp, 4
  000d2	89 45 c8	 mov	 DWORD PTR _specialmode$[ebp], eax
$LN3@OpenMainWi:

; 446  : 
; 447  : 	if (specialmode > BASEVIDWIDTH)

  000d5	81 7d c8 40 01
	00 00		 cmp	 DWORD PTR _specialmode$[ebp], 320 ; 00000140H
  000dc	7e 09		 jle	 SHORT $LN4@OpenMainWi

; 448  : 		specialmode = 1;

  000de	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _specialmode$[ebp], 1
  000e5	eb 07		 jmp	 SHORT $LN5@OpenMainWi
$LN4@OpenMainWi:

; 449  : 	else
; 450  : 		specialmode = 0;

  000e7	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _specialmode$[ebp], 0
$LN5@OpenMainWi:

; 451  : 
; 452  : 	hWnd = CreateWindowExA(

  000ee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  000f5	74 09		 je	 SHORT $LN8@OpenMainWi
  000f7	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
  000fe	eb 0d		 jmp	 SHORT $LN9@OpenMainWi
$LN8@OpenMainWi:
  00100	6b 45 c8 2c	 imul	 eax, DWORD PTR _specialmode$[ebp], 44
  00104	8b 88 0c 00 00
	00		 mov	 ecx, DWORD PTR _specialmodes[eax+12]
  0010a	89 4d 84	 mov	 DWORD PTR tv131[ebp], ecx
$LN9@OpenMainWi:
  0010d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  00114	74 09		 je	 SHORT $LN10@OpenMainWi
  00116	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  0011d	eb 0d		 jmp	 SHORT $LN11@OpenMainWi
$LN10@OpenMainWi:
  0011f	6b 55 c8 2c	 imul	 edx, DWORD PTR _specialmode$[ebp], 44
  00123	8b 82 08 00 00
	00		 mov	 eax, DWORD PTR _specialmodes[edx+8]
  00129	89 45 80	 mov	 DWORD PTR tv137[ebp], eax
$LN11@OpenMainWi:
  0012c	6a 00		 push	 0
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00131	51		 push	 ecx
  00132	6a 00		 push	 0
  00134	6a 00		 push	 0
  00136	8b 55 84	 mov	 edx, DWORD PTR tv131[ebp]
  00139	52		 push	 edx
  0013a	8b 45 80	 mov	 eax, DWORD PTR tv137[ebp]
  0013d	50		 push	 eax
  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	68 00 00 c8 80	 push	 -2134376448		; 80c80000H
  00147	8b 4d 0c	 mov	 ecx, DWORD PTR _wTitle$[ebp]
  0014a	51		 push	 ecx
  0014b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wClassName
  00151	52		 push	 edx
  00152	6a 00		 push	 0
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  0015a	89 45 fc	 mov	 DWORD PTR _hWnd$[ebp], eax

; 453  : 	       0,                                 //ExStyle
; 454  : 	       wClassName,                        //Classname
; 455  : 	       wTitle,                            //Windowname
; 456  : 	       WS_CAPTION|WS_POPUP|WS_SYSMENU,    //dwStyle       //WS_VISIBLE|WS_POPUP for bAppFullScreen
; 457  : 	       0,
; 458  : 	       0,
; 459  : 	       dedicated ? 0:specialmodes[specialmode].width,        //GetSystemMetrics(SM_CXSCREEN),
; 460  : 	       dedicated ? 0:specialmodes[specialmode].height,       //GetSystemMetrics(SM_CYSCREEN),
; 461  : 	       NULL,                              //hWnd Parent
; 462  : 	       NULL,                              //hMenu Menu
; 463  : 	       hInstance,
; 464  : 	       NULL);
; 465  : 
; 466  : 	if (hWnd == INVALID_HANDLE_VALUE)

  0015d	83 7d fc ff	 cmp	 DWORD PTR _hWnd$[ebp], -1
  00161	75 17		 jne	 SHORT $LN6@OpenMainWi

; 467  : 	{
; 468  : 		CONS_Printf("Error doing CreateWindowExA\n");

  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HJNCEGB@Error?5doing?5CreateWindowExA?6@
  00168	e8 00 00 00 00	 call	 _CONS_Printf
  0016d	83 c4 04	 add	 esp, 4

; 469  : 		I_ShowLastError(TRUE);

  00170	6a 01		 push	 1
  00172	e8 00 00 00 00	 call	 _I_ShowLastError
  00177	83 c4 04	 add	 esp, 4
$LN6@OpenMainWi:

; 470  : 	}
; 471  : 
; 472  : 	return hWnd;

  0017a	8b 45 fc	 mov	 eax, DWORD PTR _hWnd$[ebp]
$LN1@OpenMainWi:

; 473  : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_OpenMainWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _OpenTextConsole
_TEXT	SEGMENT
tv67 = -92						; size = 4
tv71 = -92						; size = 4
_seh$1 = -24						; size = 4
_soh$2 = -20						; size = 4
_sih$3 = -16						; size = 4
_console$ = -12						; size = 4
_co$ = -8						; size = 4
_ci$ = -4						; size = 4
_OpenTextConsole PROC					; COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 311  : 	HANDLE ci, co;
; 312  : 	BOOL console;
; 313  : 
; 314  : #ifdef _DEBUG
; 315  : 	console = M_CheckParm("-noconsole") == 0;

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JANDOH@?9noconsole@
  0000e	e8 00 00 00 00	 call	 _M_CheckParm
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN23@OpenTextCo
  0001a	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00021	eb 07		 jmp	 SHORT $LN24@OpenTextCo
$LN23@OpenTextCo:
  00023	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN24@OpenTextCo:
  0002a	8b 45 a4	 mov	 eax, DWORD PTR tv67[ebp]
  0002d	89 45 f4	 mov	 DWORD PTR _console$[ebp], eax

; 316  : #else
; 317  : 	console = M_CheckParm("-console") != 0;
; 318  : #endif
; 319  : 
; 320  : 	dedicated = M_CheckParm("-dedicated") != 0;

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NMOFPIPP@?9dedicated@
  00035	e8 00 00 00 00	 call	 _M_CheckParm
  0003a	83 c4 04	 add	 esp, 4
  0003d	85 c0		 test	 eax, eax
  0003f	74 09		 je	 SHORT $LN25@OpenTextCo
  00041	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00048	eb 07		 jmp	 SHORT $LN26@OpenTextCo
$LN25@OpenTextCo:
  0004a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN26@OpenTextCo:
  00051	8b 45 a4	 mov	 eax, DWORD PTR tv71[ebp]
  00054	a3 00 00 00 00	 mov	 DWORD PTR _dedicated, eax

; 321  : 
; 322  : 	if (M_CheckParm("-detachconsole"))

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CECDJDNL@?9detachconsole@
  0005e	e8 00 00 00 00	 call	 _M_CheckParm
  00063	83 c4 04	 add	 esp, 4
  00066	85 c0		 test	 eax, eax
  00068	74 37		 je	 SHORT $LN4@OpenTextCo

; 323  : 	{
; 324  : 		if (FreeConsole())

  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeConsole@0
  00070	85 c0		 test	 eax, eax
  00072	74 16		 je	 SHORT $LN3@OpenTextCo

; 325  : 		{
; 326  : 			CONS_Printf("We lost a Console, let hope it was Mingw's Bash\n");

  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HEBJFNLA@We?5lost?5a?5Console?0?5let?5hope?5it?5@
  00079	e8 00 00 00 00	 call	 _CONS_Printf
  0007e	83 c4 04	 add	 esp, 4

; 327  : 			console = TRUE; //lets get back a console

  00081	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _console$[ebp], 1

; 328  : 		}

  00088	eb 17		 jmp	 SHORT $LN4@OpenTextCo
$LN3@OpenTextCo:

; 329  : #if 1
; 330  : 		else
; 331  : 		{
; 332  : 			CONS_Printf("We did not lost a Console\n");

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GPNIOAKO@We?5did?5not?5lost?5a?5Console?6@
  0008f	e8 00 00 00 00	 call	 _CONS_Printf
  00094	83 c4 04	 add	 esp, 4

; 333  : 			I_ShowLastError(FALSE);

  00097	6a 00		 push	 0
  00099	e8 00 00 00 00	 call	 _I_ShowLastError
  0009e	83 c4 04	 add	 esp, 4
$LN4@OpenTextCo:

; 334  : 		}
; 335  : #endif
; 336  : 	}
; 337  : 
; 338  : 	if (dedicated || console)

  000a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _dedicated, 0
  000a8	75 06		 jne	 SHORT $LN7@OpenTextCo
  000aa	83 7d f4 00	 cmp	 DWORD PTR _console$[ebp], 0
  000ae	74 43		 je	 SHORT $LN5@OpenTextCo
$LN7@OpenTextCo:

; 339  : 	{
; 340  : 		if (AllocConsole()) //Let get the real console HANDLEs, because Mingw's Bash is bad!

  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AllocConsole@0
  000b6	85 c0		 test	 eax, eax
  000b8	74 1b		 je	 SHORT $LN8@OpenTextCo

; 341  : 		{
; 342  : 			SetConsoleTitleA("SRB2 Console");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JIDKBBBN@SRB2?5Console@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleTitleA@4
  000c5	90		 npad	 1

; 343  : 			CONS_Printf("Hello, it's me, SRB2's Console Window\n");

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@COCNADMK@Hello?0?5it?8s?5me?0?5SRB2?8s?5Console?5@
  000cb	e8 00 00 00 00	 call	 _CONS_Printf
  000d0	83 c4 04	 add	 esp, 4

; 344  : 		}

  000d3	eb 1c		 jmp	 SHORT $LN9@OpenTextCo
$LN8@OpenTextCo:

; 345  : 		else
; 346  : 		{
; 347  : 			CONS_Printf("We have a Console Already? Why?\n");

  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HAKLCOOF@We?5have?5a?5Console?5Already?$DP?5Why?$DP@
  000da	e8 00 00 00 00	 call	 _CONS_Printf
  000df	83 c4 04	 add	 esp, 4

; 348  : 			I_ShowLastError(FALSE);

  000e2	6a 00		 push	 0
  000e4	e8 00 00 00 00	 call	 _I_ShowLastError
  000e9	83 c4 04	 add	 esp, 4

; 349  : 			return;

  000ec	e9 75 01 00 00	 jmp	 $LN17@OpenTextCo
$LN9@OpenTextCo:

; 350  : 		}
; 351  : 	}

  000f1	eb 05		 jmp	 SHORT $LN6@OpenTextCo
$LN5@OpenTextCo:

; 352  : 	else
; 353  : 		return;

  000f3	e9 6e 01 00 00	 jmp	 $LN17@OpenTextCo
$LN6@OpenTextCo:

; 354  : 
; 355  : 	ci = CreateFile(TEXT("CONIN$") ,               GENERIC_READ, FILE_SHARE_READ,  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  000f8	6a 00		 push	 0
  000fa	68 80 00 00 00	 push	 128			; 00000080H
  000ff	6a 03		 push	 3
  00101	6a 00		 push	 0
  00103	6a 01		 push	 1
  00105	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_06GDENEHCP@CONIN$@
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00115	89 45 fc	 mov	 DWORD PTR _ci$[ebp], eax

; 356  : 	if (ci != INVALID_HANDLE_VALUE)

  00118	83 7d fc ff	 cmp	 DWORD PTR _ci$[ebp], -1
  0011c	74 68		 je	 SHORT $LN10@OpenTextCo

; 357  : 	{
; 358  : 		HANDLE sih = GetStdHandle(STD_INPUT_HANDLE);

  0011e	6a f6		 push	 -10			; fffffff6H
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  00126	89 45 f0	 mov	 DWORD PTR _sih$3[ebp], eax

; 359  : 		if (sih != ci)

  00129	8b 45 f0	 mov	 eax, DWORD PTR _sih$3[ebp]
  0012c	3b 45 fc	 cmp	 eax, DWORD PTR _ci$[ebp]
  0012f	74 24		 je	 SHORT $LN12@OpenTextCo

; 360  : 		{
; 361  : 			CONS_Printf("Old STD_INPUT_HANDLE: %p\nNew STD_INPUT_HANDLE: %p\n", sih, ci);

  00131	8b 45 fc	 mov	 eax, DWORD PTR _ci$[ebp]
  00134	50		 push	 eax
  00135	8b 4d f0	 mov	 ecx, DWORD PTR _sih$3[ebp]
  00138	51		 push	 ecx
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@OLGGCOEK@Old?5STD_INPUT_HANDLE?3?5?$CFp?6New?5ST@
  0013e	e8 00 00 00 00	 call	 _CONS_Printf
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 			SetStdHandle(STD_INPUT_HANDLE,ci);

  00146	8b 45 fc	 mov	 eax, DWORD PTR _ci$[ebp]
  00149	50		 push	 eax
  0014a	6a f6		 push	 -10			; fffffff6H
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetStdHandle@8
  00152	90		 npad	 1

; 363  : 		}

  00153	eb 11		 jmp	 SHORT $LN13@OpenTextCo
$LN12@OpenTextCo:

; 364  : 		else
; 365  : 			CONS_Printf("STD_INPUT_HANDLE already set at %p\n", ci);

  00155	8b 45 fc	 mov	 eax, DWORD PTR _ci$[ebp]
  00158	50		 push	 eax
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NFGODDED@STD_INPUT_HANDLE?5already?5set?5at@
  0015e	e8 00 00 00 00	 call	 _CONS_Printf
  00163	83 c4 08	 add	 esp, 8
$LN13@OpenTextCo:

; 366  : 
; 367  : 		if (GetFileType(ci) == FILE_TYPE_CHAR)

  00166	8b 45 fc	 mov	 eax, DWORD PTR _ci$[ebp]
  00169	50		 push	 eax
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileType@4
  00170	83 f8 02	 cmp	 eax, 2
  00173	75 02		 jne	 SHORT $LN14@OpenTextCo

; 368  : 		{
; 369  : #if 0
; 370  : 			const DWORD CM = ENABLE_LINE_INPUT|ENABLE_ECHO_INPUT|ENABLE_PROCESSED_INPUT; //default mode but no ENABLE_MOUSE_INPUT
; 371  : 			if (SetConsoleMode(ci,CM))
; 372  : 				CONS_Printf("Disabled mouse input on the console\n");
; 373  : 			else
; 374  : 			{
; 375  : 				CONS_Printf("Could not disable mouse input on the console\n");
; 376  : 				I_ShowLastError(FALSE);
; 377  : 			}
; 378  : #endif
; 379  : 		}

  00175	eb 0d		 jmp	 SHORT $LN15@OpenTextCo
$LN14@OpenTextCo:

; 380  : 		else
; 381  : 			CONS_Printf("Handle CONIN$ in not a Console HANDLE\n");

  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BEJLDKHN@Handle?5CONIN$?5in?5not?5a?5Console?5@
  0017c	e8 00 00 00 00	 call	 _CONS_Printf
  00181	83 c4 04	 add	 esp, 4
$LN15@OpenTextCo:

; 382  : 	}

  00184	eb 17		 jmp	 SHORT $LN11@OpenTextCo
$LN10@OpenTextCo:

; 383  : 	else
; 384  : 	{
; 385  : 		CONS_Printf("Could not get a CONIN$ HANDLE\n");

  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CPLJDKEN@Could?5not?5get?5a?5CONIN$?5HANDLE?6@
  0018b	e8 00 00 00 00	 call	 _CONS_Printf
  00190	83 c4 04	 add	 esp, 4

; 386  : 		I_ShowLastError(FALSE);

  00193	6a 00		 push	 0
  00195	e8 00 00 00 00	 call	 _I_ShowLastError
  0019a	83 c4 04	 add	 esp, 4
$LN11@OpenTextCo:

; 387  : 	}
; 388  : 
; 389  : 	co = CreateFile(TEXT("CONOUT$"), GENERIC_WRITE|GENERIC_READ, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  0019d	6a 00		 push	 0
  0019f	68 80 00 00 00	 push	 128			; 00000080H
  001a4	6a 03		 push	 3
  001a6	6a 00		 push	 0
  001a8	6a 02		 push	 2
  001aa	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_07GPDNMNG@CONOUT$@
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  001ba	89 45 f8	 mov	 DWORD PTR _co$[ebp], eax

; 390  : 	if (co != INVALID_HANDLE_VALUE)

  001bd	83 7d f8 ff	 cmp	 DWORD PTR _co$[ebp], -1
  001c1	0f 84 92 00 00
	00		 je	 $LN16@OpenTextCo

; 391  : 	{
; 392  : 		HANDLE soh = GetStdHandle(STD_OUTPUT_HANDLE);

  001c7	6a f5		 push	 -11			; fffffff5H
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  001cf	89 45 ec	 mov	 DWORD PTR _soh$2[ebp], eax

; 393  : 		HANDLE seh = GetStdHandle(STD_ERROR_HANDLE);

  001d2	6a f4		 push	 -12			; fffffff4H
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  001da	89 45 e8	 mov	 DWORD PTR _seh$1[ebp], eax

; 394  : 		if (soh != co)

  001dd	8b 45 ec	 mov	 eax, DWORD PTR _soh$2[ebp]
  001e0	3b 45 f8	 cmp	 eax, DWORD PTR _co$[ebp]
  001e3	74 24		 je	 SHORT $LN18@OpenTextCo

; 395  : 		{
; 396  : 			CONS_Printf("Old STD_OUTPUT_HANDLE: %p\nNew STD_OUTPUT_HANDLE: %p\n", soh, co);

  001e5	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d ec	 mov	 ecx, DWORD PTR _soh$2[ebp]
  001ec	51		 push	 ecx
  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LAENPMOH@Old?5STD_OUTPUT_HANDLE?3?5?$CFp?6New?5S@
  001f2	e8 00 00 00 00	 call	 _CONS_Printf
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 397  : 			SetStdHandle(STD_OUTPUT_HANDLE,co);

  001fa	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  001fd	50		 push	 eax
  001fe	6a f5		 push	 -11			; fffffff5H
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetStdHandle@8
  00206	90		 npad	 1

; 398  : 		}

  00207	eb 11		 jmp	 SHORT $LN19@OpenTextCo
$LN18@OpenTextCo:

; 399  : 		else
; 400  : 			CONS_Printf("STD_OUTPUT_HANDLE already set at %p\n", co);

  00209	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  0020c	50		 push	 eax
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IGEPLCKP@STD_OUTPUT_HANDLE?5already?5set?5a@
  00212	e8 00 00 00 00	 call	 _CONS_Printf
  00217	83 c4 08	 add	 esp, 8
$LN19@OpenTextCo:

; 401  : 		if (seh != co)

  0021a	8b 45 e8	 mov	 eax, DWORD PTR _seh$1[ebp]
  0021d	3b 45 f8	 cmp	 eax, DWORD PTR _co$[ebp]
  00220	74 24		 je	 SHORT $LN20@OpenTextCo

; 402  : 		{
; 403  : 			CONS_Printf("Old STD_ERROR_HANDLE: %p\nNew STD_ERROR_HANDLE: %p\n", seh, co);

  00222	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  00225	50		 push	 eax
  00226	8b 4d e8	 mov	 ecx, DWORD PTR _seh$1[ebp]
  00229	51		 push	 ecx
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@DEEGLGIO@Old?5STD_ERROR_HANDLE?3?5?$CFp?6New?5ST@
  0022f	e8 00 00 00 00	 call	 _CONS_Printf
  00234	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  : 			SetStdHandle(STD_ERROR_HANDLE,co);

  00237	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  0023a	50		 push	 eax
  0023b	6a f4		 push	 -12			; fffffff4H
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetStdHandle@8
  00243	90		 npad	 1

; 405  : 		}

  00244	eb 11		 jmp	 SHORT $LN21@OpenTextCo
$LN20@OpenTextCo:

; 406  : 		else
; 407  : 			CONS_Printf("STD_ERROR_HANDLE already set at %p\n", co);

  00246	8b 45 f8	 mov	 eax, DWORD PTR _co$[ebp]
  00249	50		 push	 eax
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HGEIEHFA@STD_ERROR_HANDLE?5already?5set?5at@
  0024f	e8 00 00 00 00	 call	 _CONS_Printf
  00254	83 c4 08	 add	 esp, 8
$LN21@OpenTextCo:

; 408  : 	}

  00257	eb 0d		 jmp	 SHORT $LN17@OpenTextCo
$LN16@OpenTextCo:

; 409  : 	else
; 410  : 		CONS_Printf("Could not get a CONOUT$ HANDLE\n");

  00259	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EBJCKNJF@Could?5not?5get?5a?5CONOUT$?5HANDLE?6@
  0025e	e8 00 00 00 00	 call	 _CONS_Printf
  00263	83 c4 04	 add	 esp, 4
$LN17@OpenTextCo:

; 411  : }

  00266	5f		 pop	 edi
  00267	5e		 pop	 esi
  00268	5b		 pop	 ebx
  00269	8b e5		 mov	 esp, ebp
  0026b	5d		 pop	 ebp
  0026c	c3		 ret	 0
_OpenTextConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _MainWndproc@16
_TEXT	SEGMENT
tv67 = -184						; size = 4
tv165 = -184						; size = 4
_hdc$1 = -116						; size = 4
_rect$2 = -112						; size = 16
_ps$3 = -96						; size = 64
_mode$4 = -32						; size = 4
_ci$5 = -28						; size = 4
_mouse_keys$ = -24					; size = 4
_ev$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainWndproc@16 PROC					; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 88   : 	event_t ev; //Doom input event
; 89   : 	int mouse_keys;
; 90   : 
; 91   : 	// judgecutor:
; 92   : 	// Response MSH Mouse Wheel event
; 93   : 
; 94   : 	if (message == MSHWheelMessage)

  00016	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00019	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _MSHWheelMessage
  0001f	75 19		 jne	 SHORT $LN7@MainWndpro

; 95   : 	{
; 96   : 		message = WM_MOUSEWHEEL;

  00021	c7 45 0c 0a 02
	00 00		 mov	 DWORD PTR _message$[ebp], 522 ; 0000020aH

; 97   : 		if (win9x)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _win9x, 0
  0002f	74 09		 je	 SHORT $LN7@MainWndpro

; 98   : 			wParam <<= 16;

  00031	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00034	c1 e0 10	 shl	 eax, 16			; 00000010H
  00037	89 45 10	 mov	 DWORD PTR _wParam$[ebp], eax
$LN7@MainWndpro:

; 99   : 	}
; 100  : 
; 101  : 	//CONS_Printf("MainWndproc: %p,%i,%i,%i",hWnd, message, wParam, (UINT)lParam);
; 102  : 
; 103  : 	switch (message)

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  0003d	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  00043	81 bd 48 ff ff
	ff 12 01 00 00	 cmp	 DWORD PTR tv67[ebp], 274 ; 00000112H
  0004d	0f 87 89 00 00
	00		 ja	 $LN65@MainWndpro
  00053	81 bd 48 ff ff
	ff 12 01 00 00	 cmp	 DWORD PTR tv67[ebp], 274 ; 00000112H
  0005d	0f 84 d9 04 00
	00		 je	 $LN61@MainWndpro
  00063	83 bd 48 ff ff
	ff 10		 cmp	 DWORD PTR tv67[ebp], 16	; 00000010H
  0006a	77 3d		 ja	 SHORT $LN66@MainWndpro
  0006c	83 bd 48 ff ff
	ff 10		 cmp	 DWORD PTR tv67[ebp], 16	; 00000010H
  00073	0f 84 91 04 00
	00		 je	 $LN59@MainWndpro
  00079	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  0007f	83 e9 01	 sub	 ecx, 1
  00082	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  00088	83 bd 48 ff ff
	ff 0e		 cmp	 DWORD PTR tv67[ebp], 14	; 0000000eH
  0008f	0f 87 b4 04 00
	00		 ja	 $LN63@MainWndpro
  00095	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  0009b	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN68@MainWndpro[edx]
  000a2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN69@MainWndpro[eax*4]
$LN66@MainWndpro:
  000a9	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  000af	83 e9 1c	 sub	 ecx, 28			; 0000001cH
  000b2	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  000b8	81 bd 48 ff ff
	ff e5 00 00 00	 cmp	 DWORD PTR tv67[ebp], 229 ; 000000e5H
  000c2	0f 87 81 04 00
	00		 ja	 $LN63@MainWndpro
  000c8	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  000ce	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN70@MainWndpro[edx]
  000d5	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN71@MainWndpro[eax*4]
$LN65@MainWndpro:
  000dc	81 bd 48 ff ff
	ff 0f 03 00 00	 cmp	 DWORD PTR tv67[ebp], 783 ; 0000030fH
  000e6	77 3c		 ja	 SHORT $LN67@MainWndpro
  000e8	81 bd 48 ff ff
	ff 0f 03 00 00	 cmp	 DWORD PTR tv67[ebp], 783 ; 0000030fH
  000f2	0f 84 a9 01 00
	00		 je	 $LN19@MainWndpro
  000f8	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  000fe	81 e9 00 02 00
	00		 sub	 ecx, 512		; 00000200H
  00104	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  0010a	83 bd 48 ff ff
	ff 0c		 cmp	 DWORD PTR tv67[ebp], 12	; 0000000cH
  00111	0f 87 32 04 00
	00		 ja	 $LN63@MainWndpro
  00117	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  0011d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN72@MainWndpro[edx*4]
$LN67@MainWndpro:
  00124	81 bd 48 ff ff
	ff 11 03 00 00	 cmp	 DWORD PTR tv67[ebp], 785 ; 00000311H
  0012e	0f 84 7d 01 00
	00		 je	 $LN20@MainWndpro
  00134	81 bd 48 ff ff
	ff 65 04 00 00	 cmp	 DWORD PTR tv67[ebp], 1125 ; 00000465H
  0013e	0f 84 d8 00 00
	00		 je	 $LN16@MainWndpro
  00144	e9 00 04 00 00	 jmp	 $LN63@MainWndpro
$LN8@MainWndpro:

; 104  : 	{
; 105  : 		case WM_CREATE:
; 106  : 			nodinput = M_CheckParm("-nodinput");

  00149	68 00 00 00 00	 push	 OFFSET ??_C@_09DPOKLOFF@?9nodinput@
  0014e	e8 00 00 00 00	 call	 _M_CheckParm
  00153	83 c4 04	 add	 esp, 4
  00156	a3 00 00 00 00	 mov	 DWORD PTR _nodinput, eax

; 107  : 			if (!nodinput && !LoadDirectInput())

  0015b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  00162	75 13		 jne	 SHORT $LN9@MainWndpro
  00164	e8 00 00 00 00	 call	 _LoadDirectInput
  00169	85 c0		 test	 eax, eax
  0016b	75 0a		 jne	 SHORT $LN9@MainWndpro

; 108  : 				nodinput = true;

  0016d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _nodinput, 1
$LN9@MainWndpro:

; 109  : 			break;

  00177	e9 cd 03 00 00	 jmp	 $LN2@MainWndpro
$LN10@MainWndpro:

; 110  : 
; 111  : 		case WM_ACTIVATEAPP:           // Handle task switching
; 112  : 			appActive = (int)wParam;

  0017c	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0017f	a3 00 00 00 00	 mov	 DWORD PTR _appActive, eax

; 113  : 
; 114  : 			//coming back from alt-tab?  reset the palette.
; 115  : 			if (appActive)

  00184	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _appActive, 0
  0018b	74 0a		 je	 SHORT $LN11@MainWndpro

; 116  : 				vid.recalc = true;

  0018d	c7 05 18 00 00
	00 01 00 00 00	 mov	 DWORD PTR _vid+24, 1
$LN11@MainWndpro:

; 117  : 
; 118  : 			// pause music when alt-tab
; 119  : 			if (appActive  && !paused)

  00197	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _appActive, 0
  0019e	74 17		 je	 SHORT $LN12@MainWndpro
  001a0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  001a7	85 c0		 test	 eax, eax
  001a9	75 0c		 jne	 SHORT $LN12@MainWndpro

; 120  : 				I_ResumeSong(0);

  001ab	6a 00		 push	 0
  001ad	e8 00 00 00 00	 call	 _I_ResumeSong
  001b2	83 c4 04	 add	 esp, 4
  001b5	eb 15		 jmp	 SHORT $LN14@MainWndpro
$LN12@MainWndpro:

; 121  : 			else if (!paused)

  001b7	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _paused
  001be	85 c0		 test	 eax, eax
  001c0	75 0a		 jne	 SHORT $LN14@MainWndpro

; 122  : 				I_PauseSong(0);

  001c2	6a 00		 push	 0
  001c4	e8 00 00 00 00	 call	 _I_PauseSong
  001c9	83 c4 04	 add	 esp, 4
$LN14@MainWndpro:

; 123  : 			{
; 124  : 				HANDLE ci = GetStdHandle(STD_INPUT_HANDLE);

  001cc	6a f6		 push	 -10			; fffffff6H
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStdHandle@4
  001d4	89 45 e4	 mov	 DWORD PTR _ci$5[ebp], eax

; 125  : 				DWORD mode;
; 126  : 				if (ci != INVALID_HANDLE_VALUE && GetFileType(ci) == FILE_TYPE_CHAR && GetConsoleMode(ci, &mode))

  001d7	83 7d e4 ff	 cmp	 DWORD PTR _ci$5[ebp], -1
  001db	74 2b		 je	 SHORT $LN15@MainWndpro
  001dd	8b 45 e4	 mov	 eax, DWORD PTR _ci$5[ebp]
  001e0	50		 push	 eax
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileType@4
  001e7	83 f8 02	 cmp	 eax, 2
  001ea	75 1c		 jne	 SHORT $LN15@MainWndpro
  001ec	8d 45 e0	 lea	 eax, DWORD PTR _mode$4[ebp]
  001ef	50		 push	 eax
  001f0	8b 4d e4	 mov	 ecx, DWORD PTR _ci$5[ebp]
  001f3	51		 push	 ecx
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetConsoleMode@8
  001fa	85 c0		 test	 eax, eax
  001fc	74 0a		 je	 SHORT $LN15@MainWndpro

; 127  : 					appActive = true;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _appActive, 1
$LN15@MainWndpro:

; 128  : 			}
; 129  : 			InvalidateRect (hWnd, NULL, TRUE);

  00208	6a 01		 push	 1
  0020a	6a 00		 push	 0
  0020c	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0020f	50		 push	 eax
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  00216	90		 npad	 1

; 130  : 			break;

  00217	e9 2d 03 00 00	 jmp	 $LN2@MainWndpro
$LN16@MainWndpro:

; 131  : 
; 132  : 		//for MIDI music
; 133  : 		case WM_MSTREAM_UPDATEVOLUME:
; 134  : 			I_SetMidiChannelVolume((DWORD)wParam, dwVolumePercent);

  0021c	a1 00 00 00 00	 mov	 eax, DWORD PTR _dwVolumePercent
  00221	50		 push	 eax
  00222	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 _I_SetMidiChannelVolume
  0022b	83 c4 08	 add	 esp, 8

; 135  : 			break;

  0022e	e9 16 03 00 00	 jmp	 $LN2@MainWndpro
$LN17@MainWndpro:

; 136  : 
; 137  : 		case WM_PAINT:
; 138  : 			if (!appActive && !bAppFullScreen && !netgame)

  00233	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _appActive, 0
  0023a	75 60		 jne	 SHORT $LN18@MainWndpro
  0023c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  00243	75 57		 jne	 SHORT $LN18@MainWndpro
  00245	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0024c	75 4e		 jne	 SHORT $LN18@MainWndpro

; 139  : 				// app becomes inactive (if windowed)
; 140  : 			{
; 141  : 				// Paint "Game Paused" in the middle of the screen
; 142  : 				PAINTSTRUCT ps;
; 143  : 				RECT        rect;
; 144  : 				HDC hdc = BeginPaint (hWnd, &ps);

  0024e	8d 45 a0	 lea	 eax, DWORD PTR _ps$3[ebp]
  00251	50		 push	 eax
  00252	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00255	51		 push	 ecx
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  0025c	89 45 8c	 mov	 DWORD PTR _hdc$1[ebp], eax

; 145  : 				GetClientRect (hWnd, &rect);

  0025f	8d 45 90	 lea	 eax, DWORD PTR _rect$2[ebp]
  00262	50		 push	 eax
  00263	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00266	51		 push	 ecx
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  0026d	90		 npad	 1

; 146  : 				DrawText (hdc, TEXT("Game Paused"), -1, &rect,

  0026e	6a 25		 push	 37			; 00000025H
  00270	8d 45 90	 lea	 eax, DWORD PTR _rect$2[ebp]
  00273	50		 push	 eax
  00274	6a ff		 push	 -1
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HNFIPFIH@Game?5Paused@
  0027b	8b 4d 8c	 mov	 ecx, DWORD PTR _hdc$1[ebp]
  0027e	51		 push	 ecx
  0027f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawTextA@20
  00285	90		 npad	 1

; 147  : 					DT_SINGLELINE | DT_CENTER | DT_VCENTER);
; 148  : 				EndPaint (hWnd, &ps);

  00286	8d 45 a0	 lea	 eax, DWORD PTR _ps$3[ebp]
  00289	50		 push	 eax
  0028a	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  0028d	51		 push	 ecx
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8
  00294	90		 npad	 1

; 149  : 				return 0;

  00295	33 c0		 xor	 eax, eax
  00297	e9 c3 02 00 00	 jmp	 $LN1@MainWndpro
$LN18@MainWndpro:

; 150  : 			}
; 151  : 
; 152  : 			break;

  0029c	e9 a8 02 00 00	 jmp	 $LN2@MainWndpro
$LN19@MainWndpro:

; 153  : 
; 154  : 		case WM_QUERYNEWPALETTE:
; 155  : 			RestoreDDPalette();

  002a1	e8 00 00 00 00	 call	 _RestoreDDPalette
  002a6	90		 npad	 1

; 156  : 			return TRUE;

  002a7	b8 01 00 00 00	 mov	 eax, 1
  002ac	e9 ae 02 00 00	 jmp	 $LN1@MainWndpro
$LN20@MainWndpro:

; 157  : 
; 158  : 		case WM_PALETTECHANGED:
; 159  : 			if((HWND)wParam != hWnd)

  002b1	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  002b4	3b 45 08	 cmp	 eax, DWORD PTR _hWnd$[ebp]
  002b7	74 06		 je	 SHORT $LN21@MainWndpro

; 160  : 				RestoreDDPalette();

  002b9	e8 00 00 00 00	 call	 _RestoreDDPalette
  002be	90		 npad	 1
$LN21@MainWndpro:

; 161  : 			break;

  002bf	e9 85 02 00 00	 jmp	 $LN2@MainWndpro
$LN22@MainWndpro:

; 162  : 
; 163  : 		//case WM_RBUTTONDOWN:
; 164  : 		//case WM_LBUTTONDOWN:
; 165  : 
; 166  : 		case WM_MOVE:
; 167  : 			if (bAppFullScreen)

  002c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  002cb	74 20		 je	 SHORT $LN23@MainWndpro

; 168  : 			{
; 169  : 				SetWindowPos(hWnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOSIZE);

  002cd	6a 05		 push	 5
  002cf	6a 00		 push	 0
  002d1	6a 00		 push	 0
  002d3	6a 00		 push	 0
  002d5	6a 00		 push	 0
  002d7	6a 00		 push	 0
  002d9	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  002dc	50		 push	 eax
  002dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
  002e3	90		 npad	 1

; 170  : 				return 0;

  002e4	33 c0		 xor	 eax, eax
  002e6	e9 74 02 00 00	 jmp	 $LN1@MainWndpro

; 171  : 			}

  002eb	eb 2a		 jmp	 SHORT $LN24@MainWndpro
$LN23@MainWndpro:

; 172  : 			else
; 173  : 			{
; 174  : 				windowPosX = (SHORT) LOWORD(lParam);    // horizontal position

  002ed	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  002f0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002f5	0f bf c8	 movsx	 ecx, ax
  002f8	89 0d 00 00 00
	00		 mov	 DWORD PTR _windowPosX, ecx

; 175  : 				windowPosY = (SHORT) HIWORD(lParam);    // vertical position

  002fe	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00301	c1 e8 10	 shr	 eax, 16			; 00000010H
  00304	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00309	0f bf c8	 movsx	 ecx, ax
  0030c	89 0d 00 00 00
	00		 mov	 DWORD PTR _windowPosY, ecx

; 176  : 				break;

  00312	e9 32 02 00 00	 jmp	 $LN2@MainWndpro
$LN24@MainWndpro:

; 177  : 			}
; 178  : 			break;

  00317	e9 2d 02 00 00	 jmp	 $LN2@MainWndpro

; 179  : 
; 180  : 			// This is where switching windowed/fullscreen is handled. DirectDraw
; 181  : 			// objects must be destroyed, recreated, and artwork reloaded.
; 182  : 
; 183  : 		case WM_DISPLAYCHANGE:
; 184  : 		case WM_SIZE:
; 185  : 			break;

  0031c	e9 28 02 00 00	 jmp	 $LN2@MainWndpro
$LN27@MainWndpro:

; 186  : 
; 187  : 		case WM_SETCURSOR:
; 188  : 			if (bAppFullScreen)

  00321	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bAppFullScreen, 0
  00328	74 0b		 je	 SHORT $LN28@MainWndpro

; 189  : 				SetCursor(NULL);

  0032a	6a 00		 push	 0
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  00332	90		 npad	 1
  00333	eb 0d		 jmp	 SHORT $LN29@MainWndpro
$LN28@MainWndpro:

; 190  : 			else
; 191  : 				SetCursor(windowCursor);

  00335	a1 00 00 00 00	 mov	 eax, DWORD PTR _windowCursor
  0033a	50		 push	 eax
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  00341	90		 npad	 1
$LN29@MainWndpro:

; 192  : 			return TRUE;

  00342	b8 01 00 00 00	 mov	 eax, 1
  00347	e9 13 02 00 00	 jmp	 $LN1@MainWndpro
$LN30@MainWndpro:

; 193  : 
; 194  : 		case WM_KEYUP:
; 195  : 			ev.type = ev_keyup;

  0034c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 1

; 196  : 			goto handleKeyDoom;

  00353	eb 0c		 jmp	 SHORT $handleKeyDoom$73

; 197  : 			break;

  00355	e9 ef 01 00 00	 jmp	 $LN2@MainWndpro
$LN31@MainWndpro:

; 198  : 
; 199  : 		case WM_KEYDOWN:
; 200  : 			ev.type = ev_keydown;

  0035a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 0
$handleKeyDoom$73:

; 201  : 
; 202  : 	handleKeyDoom:
; 203  : 			ev.data1 = 0;

  00361	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 0

; 204  : 			if (wParam == VK_PAUSE)

  00368	83 7d 10 13	 cmp	 DWORD PTR _wParam$[ebp], 19 ; 00000013H
  0036c	75 09		 jne	 SHORT $LN32@MainWndpro

; 205  : 			// intercept PAUSE key
; 206  : 			{
; 207  : 				ev.data1 = KEY_PAUSE;

  0036e	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 255 ; 000000ffH

; 208  : 			}

  00375	eb 5b		 jmp	 SHORT $LN4@MainWndpro
$LN32@MainWndpro:

; 209  : 			else if (!keyboard_started)

  00377	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _keyboard_started
  0037e	85 c0		 test	 eax, eax
  00380	75 50		 jne	 SHORT $LN4@MainWndpro

; 210  : 			// post some keys during the game startup
; 211  : 			// (allow escaping from network synchronization, or pressing enter after
; 212  : 			//  an error message in the console)
; 213  : 			{
; 214  : 				switch (wParam)

  00382	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00385	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv165[ebp], eax
  0038b	83 bd 48 ff ff
	ff 0d		 cmp	 DWORD PTR tv165[ebp], 13 ; 0000000dH
  00392	74 1d		 je	 SHORT $LN36@MainWndpro
  00394	83 bd 48 ff ff
	ff 10		 cmp	 DWORD PTR tv165[ebp], 16 ; 00000010H
  0039b	74 1d		 je	 SHORT $LN37@MainWndpro
  0039d	83 bd 48 ff ff
	ff 1b		 cmp	 DWORD PTR tv165[ebp], 27 ; 0000001bH
  003a4	74 02		 je	 SHORT $LN35@MainWndpro
  003a6	eb 1b		 jmp	 SHORT $LN38@MainWndpro
$LN35@MainWndpro:

; 215  : 				{
; 216  : 					case VK_ESCAPE: ev.data1 = KEY_ESCAPE;  break;

  003a8	c7 45 f0 1b 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 27 ; 0000001bH
  003af	eb 21		 jmp	 SHORT $LN4@MainWndpro
$LN36@MainWndpro:

; 217  : 					case VK_RETURN: ev.data1 = KEY_ENTER;   break;

  003b1	c7 45 f0 0d 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 13 ; 0000000dH
  003b8	eb 18		 jmp	 SHORT $LN4@MainWndpro
$LN37@MainWndpro:

; 218  : 					case VK_SHIFT:  ev.data1 = KEY_LSHIFT;  break;

  003ba	c7 45 f0 b6 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 182 ; 000000b6H
  003c1	eb 0f		 jmp	 SHORT $LN4@MainWndpro
$LN38@MainWndpro:

; 219  : 					default: ev.data1 = MapVirtualKey((DWORD)wParam,2); // convert in to char

  003c3	6a 02		 push	 2
  003c5	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  003c8	50		 push	 eax
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapVirtualKeyA@8
  003cf	89 45 f0	 mov	 DWORD PTR _ev$[ebp+4], eax
$LN4@MainWndpro:

; 220  : 				}
; 221  : 			}
; 222  : 
; 223  : 			if (ev.data1)

  003d2	83 7d f0 00	 cmp	 DWORD PTR _ev$[ebp+4], 0
  003d6	74 0c		 je	 SHORT $LN39@MainWndpro

; 224  : 				D_PostEvent (&ev);

  003d8	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  003db	50		 push	 eax
  003dc	e8 00 00 00 00	 call	 _D_PostEvent
  003e1	83 c4 04	 add	 esp, 4
$LN39@MainWndpro:

; 225  : 
; 226  : 			return 0;

  003e4	33 c0		 xor	 eax, eax
  003e6	e9 74 01 00 00	 jmp	 $LN1@MainWndpro

; 227  : 			break;

  003eb	e9 59 01 00 00	 jmp	 $LN2@MainWndpro
$LN40@MainWndpro:

; 228  : 
; 229  : 		// judgecutor:
; 230  : 		// Handle mouse events
; 231  : 		case WM_LBUTTONDOWN:
; 232  : 		case WM_LBUTTONUP:
; 233  : 		case WM_RBUTTONDOWN:
; 234  : 		case WM_RBUTTONUP:
; 235  : 		case WM_MBUTTONDOWN:
; 236  : 		case WM_MBUTTONUP:
; 237  : 		case WM_MOUSEMOVE:
; 238  : 			if (nodinput)

  003f0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  003f7	74 46		 je	 SHORT $LN47@MainWndpro

; 239  : 			{
; 240  : 				mouse_keys = 0;

  003f9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _mouse_keys$[ebp], 0

; 241  : 				if (wParam & MK_LBUTTON)

  00400	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00403	83 e0 01	 and	 eax, 1
  00406	74 09		 je	 SHORT $LN48@MainWndpro

; 242  : 					mouse_keys |= 1;

  00408	8b 45 e8	 mov	 eax, DWORD PTR _mouse_keys$[ebp]
  0040b	83 c8 01	 or	 eax, 1
  0040e	89 45 e8	 mov	 DWORD PTR _mouse_keys$[ebp], eax
$LN48@MainWndpro:

; 243  : 				if (wParam & MK_RBUTTON)

  00411	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00414	83 e0 02	 and	 eax, 2
  00417	74 09		 je	 SHORT $LN49@MainWndpro

; 244  : 					mouse_keys |= 2;

  00419	8b 45 e8	 mov	 eax, DWORD PTR _mouse_keys$[ebp]
  0041c	83 c8 02	 or	 eax, 2
  0041f	89 45 e8	 mov	 DWORD PTR _mouse_keys$[ebp], eax
$LN49@MainWndpro:

; 245  : 				if (wParam & MK_MBUTTON)

  00422	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00425	83 e0 10	 and	 eax, 16			; 00000010H
  00428	74 09		 je	 SHORT $LN50@MainWndpro

; 246  : 					mouse_keys |= 4;

  0042a	8b 45 e8	 mov	 eax, DWORD PTR _mouse_keys$[ebp]
  0042d	83 c8 04	 or	 eax, 4
  00430	89 45 e8	 mov	 DWORD PTR _mouse_keys$[ebp], eax
$LN50@MainWndpro:

; 247  : 				I_GetSysMouseEvents(mouse_keys);

  00433	8b 45 e8	 mov	 eax, DWORD PTR _mouse_keys$[ebp]
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 _I_GetSysMouseEvents
  0043c	83 c4 04	 add	 esp, 4
$LN47@MainWndpro:

; 248  : 			}
; 249  : 			break;

  0043f	e9 05 01 00 00	 jmp	 $LN2@MainWndpro
$LN51@MainWndpro:

; 250  : 
; 251  : 		case WM_XBUTTONUP:
; 252  : 			if (nodinput)

  00444	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  0044b	74 34		 je	 SHORT $LN52@MainWndpro

; 253  : 			{
; 254  : 				ev.type = ev_keyup;

  0044d	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 1

; 255  : 				ev.data1 = KEY_MOUSE1 + 3 + HIWORD(wParam);

  00454	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00457	c1 e8 10	 shr	 eax, 16			; 00000010H
  0045a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0045f	0f b7 c8	 movzx	 ecx, ax
  00462	81 c1 03 01 00
	00		 add	 ecx, 259		; 00000103H
  00468	89 4d f0	 mov	 DWORD PTR _ev$[ebp+4], ecx

; 256  : 				D_PostEvent(&ev);

  0046b	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  0046e	50		 push	 eax
  0046f	e8 00 00 00 00	 call	 _D_PostEvent
  00474	83 c4 04	 add	 esp, 4

; 257  : 				return TRUE;

  00477	b8 01 00 00 00	 mov	 eax, 1
  0047c	e9 de 00 00 00	 jmp	 $LN1@MainWndpro
$LN52@MainWndpro:

; 258  : 			}
; 259  : 
; 260  : 		case WM_XBUTTONDOWN:
; 261  : 			if (nodinput)

  00481	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nodinput, 0
  00488	74 34		 je	 SHORT $LN54@MainWndpro

; 262  : 			{
; 263  : 				ev.type = ev_keydown;

  0048a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 0

; 264  : 				ev.data1 = KEY_MOUSE1 + 3 + HIWORD(wParam);

  00491	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00494	c1 e8 10	 shr	 eax, 16			; 00000010H
  00497	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0049c	0f b7 c8	 movzx	 ecx, ax
  0049f	81 c1 03 01 00
	00		 add	 ecx, 259		; 00000103H
  004a5	89 4d f0	 mov	 DWORD PTR _ev$[ebp+4], ecx

; 265  : 				D_PostEvent(&ev);

  004a8	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  004ab	50		 push	 eax
  004ac	e8 00 00 00 00	 call	 _D_PostEvent
  004b1	83 c4 04	 add	 esp, 4

; 266  : 				return TRUE;

  004b4	b8 01 00 00 00	 mov	 eax, 1
  004b9	e9 a1 00 00 00	 jmp	 $LN1@MainWndpro
$LN54@MainWndpro:

; 267  : 			}
; 268  : 
; 269  : 		case WM_MOUSEWHEEL:
; 270  : 			//CONS_Printf("MW_WHEEL dispatched.\n");
; 271  : 			ev.type = ev_keydown;

  004be	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 0

; 272  : 			if ((INT16)HIWORD(wParam) > 0)

  004c5	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  004c8	c1 e8 10	 shr	 eax, 16			; 00000010H
  004cb	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  004d0	0f bf c8	 movsx	 ecx, ax
  004d3	85 c9		 test	 ecx, ecx
  004d5	7e 09		 jle	 SHORT $LN56@MainWndpro

; 273  : 				ev.data1 = KEY_MOUSEWHEELUP;

  004d7	c7 45 f0 e0 01
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 480 ; 000001e0H
  004de	eb 07		 jmp	 SHORT $LN57@MainWndpro
$LN56@MainWndpro:

; 274  : 			else
; 275  : 				ev.data1 = KEY_MOUSEWHEELDOWN;

  004e0	c7 45 f0 e1 01
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 481 ; 000001e1H
$LN57@MainWndpro:

; 276  : 			D_PostEvent(&ev);

  004e7	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  004ea	50		 push	 eax
  004eb	e8 00 00 00 00	 call	 _D_PostEvent
  004f0	83 c4 04	 add	 esp, 4

; 277  : 			break;

  004f3	eb 54		 jmp	 SHORT $LN2@MainWndpro
$LN58@MainWndpro:

; 278  : 
; 279  : 		case WM_SETTEXT:
; 280  : 			COM_BufAddText((LPCSTR)lParam);

  004f5	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 _COM_BufAddText
  004fe	83 c4 04	 add	 esp, 4

; 281  : 			return TRUE;

  00501	b8 01 00 00 00	 mov	 eax, 1
  00506	eb 57		 jmp	 SHORT $LN1@MainWndpro

; 282  : 			break;

  00508	eb 3f		 jmp	 SHORT $LN2@MainWndpro
$LN59@MainWndpro:

; 283  : 
; 284  : 		case WM_CLOSE:
; 285  : 			PostQuitMessage(0);         //to quit while in-game

  0050a	6a 00		 push	 0
  0050c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
  00512	90		 npad	 1

; 286  : 			ev.data1 = KEY_ESCAPE;      //to exit network synchronization

  00513	c7 45 f0 1b 00
	00 00		 mov	 DWORD PTR _ev$[ebp+4], 27 ; 0000001bH

; 287  : 			ev.type = ev_keydown;

  0051a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ev$[ebp], 0

; 288  : 			D_PostEvent (&ev);

  00521	8d 45 ec	 lea	 eax, DWORD PTR _ev$[ebp]
  00524	50		 push	 eax
  00525	e8 00 00 00 00	 call	 _D_PostEvent
  0052a	83 c4 04	 add	 esp, 4

; 289  : 			return 0;

  0052d	33 c0		 xor	 eax, eax
  0052f	eb 2e		 jmp	 SHORT $LN1@MainWndpro
$LN60@MainWndpro:

; 290  : 		case WM_DESTROY:
; 291  : 			//faB: main app loop will exit the loop and proceed with I_Quit()
; 292  : 			PostQuitMessage(0);

  00531	6a 00		 push	 0
  00533	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
  00539	90		 npad	 1

; 293  : 			break;

  0053a	eb 0d		 jmp	 SHORT $LN2@MainWndpro
$LN61@MainWndpro:

; 294  : 
; 295  : 		case WM_SYSCOMMAND:
; 296  : 			// Don't allow the keyboard to activate the menu.
; 297  : 			if(wParam == SC_KEYMENU)

  0053c	81 7d 10 00 f1
	00 00		 cmp	 DWORD PTR _wParam$[ebp], 61696 ; 0000f100H
  00543	75 04		 jne	 SHORT $LN62@MainWndpro

; 298  : 				return 0;

  00545	33 c0		 xor	 eax, eax
  00547	eb 16		 jmp	 SHORT $LN1@MainWndpro
$LN62@MainWndpro:
$LN63@MainWndpro:
$LN2@MainWndpro:

; 299  : 
; 300  : 			break;
; 301  : 
; 302  : 		default:
; 303  : 			break;
; 304  : 	}
; 305  : 
; 306  : 	return DefWindowProc(hWnd, message, wParam, lParam);

  00549	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0054c	50		 push	 eax
  0054d	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00550	51		 push	 ecx
  00551	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  00554	52		 push	 edx
  00555	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00558	50		 push	 eax
  00559	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
$LN1@MainWndpro:

; 307  : }

  0055f	5f		 pop	 edi
  00560	5e		 pop	 esi
  00561	5b		 pop	 ebx
  00562	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00565	33 cd		 xor	 ecx, ebp
  00567	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0056c	8b e5		 mov	 esp, ebp
  0056e	5d		 pop	 ebp
  0056f	c2 10 00	 ret	 16			; 00000010H
  00572	66 90		 npad	 2
$LN69@MainWndpro:
  00574	00 00 00 00	 DD	 $LN8@MainWndpro
  00578	00 00 00 00	 DD	 $LN60@MainWndpro
  0057c	00 00 00 00	 DD	 $LN22@MainWndpro
  00580	00 00 00 00	 DD	 $LN58@MainWndpro
  00584	00 00 00 00	 DD	 $LN17@MainWndpro
  00588	00 00 00 00	 DD	 $LN63@MainWndpro
$LN68@MainWndpro:
  0058c	00		 DB	 0
  0058d	01		 DB	 1
  0058e	02		 DB	 2
  0058f	05		 DB	 5
  00590	05		 DB	 5
  00591	05		 DB	 5
  00592	05		 DB	 5
  00593	05		 DB	 5
  00594	05		 DB	 5
  00595	05		 DB	 5
  00596	05		 DB	 5
  00597	03		 DB	 3
  00598	05		 DB	 5
  00599	05		 DB	 5
  0059a	04		 DB	 4
  0059b	90		 npad	 1
$LN71@MainWndpro:
  0059c	00 00 00 00	 DD	 $LN10@MainWndpro
  005a0	00 00 00 00	 DD	 $LN27@MainWndpro
  005a4	00 00 00 00	 DD	 $LN31@MainWndpro
  005a8	00 00 00 00	 DD	 $LN30@MainWndpro
  005ac	00 00 00 00	 DD	 $LN63@MainWndpro
$LN70@MainWndpro:
  005b0	00		 DB	 0
  005b1	04		 DB	 4
  005b2	04		 DB	 4
  005b3	04		 DB	 4
  005b4	01		 DB	 1
  005b5	04		 DB	 4
  005b6	04		 DB	 4
  005b7	04		 DB	 4
  005b8	04		 DB	 4
  005b9	04		 DB	 4
  005ba	04		 DB	 4
  005bb	04		 DB	 4
  005bc	04		 DB	 4
  005bd	04		 DB	 4
  005be	04		 DB	 4
  005bf	04		 DB	 4
  005c0	04		 DB	 4
  005c1	04		 DB	 4
  005c2	04		 DB	 4
  005c3	04		 DB	 4
  005c4	04		 DB	 4
  005c5	04		 DB	 4
  005c6	04		 DB	 4
  005c7	04		 DB	 4
  005c8	04		 DB	 4
  005c9	04		 DB	 4
  005ca	04		 DB	 4
  005cb	04		 DB	 4
  005cc	04		 DB	 4
  005cd	04		 DB	 4
  005ce	04		 DB	 4
  005cf	04		 DB	 4
  005d0	04		 DB	 4
  005d1	04		 DB	 4
  005d2	04		 DB	 4
  005d3	04		 DB	 4
  005d4	04		 DB	 4
  005d5	04		 DB	 4
  005d6	04		 DB	 4
  005d7	04		 DB	 4
  005d8	04		 DB	 4
  005d9	04		 DB	 4
  005da	04		 DB	 4
  005db	04		 DB	 4
  005dc	04		 DB	 4
  005dd	04		 DB	 4
  005de	04		 DB	 4
  005df	04		 DB	 4
  005e0	04		 DB	 4
  005e1	04		 DB	 4
  005e2	04		 DB	 4
  005e3	04		 DB	 4
  005e4	04		 DB	 4
  005e5	04		 DB	 4
  005e6	04		 DB	 4
  005e7	04		 DB	 4
  005e8	04		 DB	 4
  005e9	04		 DB	 4
  005ea	04		 DB	 4
  005eb	04		 DB	 4
  005ec	04		 DB	 4
  005ed	04		 DB	 4
  005ee	04		 DB	 4
  005ef	04		 DB	 4
  005f0	04		 DB	 4
  005f1	04		 DB	 4
  005f2	04		 DB	 4
  005f3	04		 DB	 4
  005f4	04		 DB	 4
  005f5	04		 DB	 4
  005f6	04		 DB	 4
  005f7	04		 DB	 4
  005f8	04		 DB	 4
  005f9	04		 DB	 4
  005fa	04		 DB	 4
  005fb	04		 DB	 4
  005fc	04		 DB	 4
  005fd	04		 DB	 4
  005fe	04		 DB	 4
  005ff	04		 DB	 4
  00600	04		 DB	 4
  00601	04		 DB	 4
  00602	04		 DB	 4
  00603	04		 DB	 4
  00604	04		 DB	 4
  00605	04		 DB	 4
  00606	04		 DB	 4
  00607	04		 DB	 4
  00608	04		 DB	 4
  00609	04		 DB	 4
  0060a	04		 DB	 4
  0060b	04		 DB	 4
  0060c	04		 DB	 4
  0060d	04		 DB	 4
  0060e	04		 DB	 4
  0060f	04		 DB	 4
  00610	04		 DB	 4
  00611	04		 DB	 4
  00612	04		 DB	 4
  00613	04		 DB	 4
  00614	04		 DB	 4
  00615	04		 DB	 4
  00616	04		 DB	 4
  00617	04		 DB	 4
  00618	04		 DB	 4
  00619	04		 DB	 4
  0061a	04		 DB	 4
  0061b	04		 DB	 4
  0061c	04		 DB	 4
  0061d	04		 DB	 4
  0061e	04		 DB	 4
  0061f	04		 DB	 4
  00620	04		 DB	 4
  00621	04		 DB	 4
  00622	04		 DB	 4
  00623	04		 DB	 4
  00624	04		 DB	 4
  00625	04		 DB	 4
  00626	04		 DB	 4
  00627	04		 DB	 4
  00628	04		 DB	 4
  00629	04		 DB	 4
  0062a	04		 DB	 4
  0062b	04		 DB	 4
  0062c	04		 DB	 4
  0062d	04		 DB	 4
  0062e	04		 DB	 4
  0062f	04		 DB	 4
  00630	04		 DB	 4
  00631	04		 DB	 4
  00632	04		 DB	 4
  00633	04		 DB	 4
  00634	04		 DB	 4
  00635	04		 DB	 4
  00636	04		 DB	 4
  00637	04		 DB	 4
  00638	04		 DB	 4
  00639	04		 DB	 4
  0063a	04		 DB	 4
  0063b	04		 DB	 4
  0063c	04		 DB	 4
  0063d	04		 DB	 4
  0063e	04		 DB	 4
  0063f	04		 DB	 4
  00640	04		 DB	 4
  00641	04		 DB	 4
  00642	04		 DB	 4
  00643	04		 DB	 4
  00644	04		 DB	 4
  00645	04		 DB	 4
  00646	04		 DB	 4
  00647	04		 DB	 4
  00648	04		 DB	 4
  00649	04		 DB	 4
  0064a	04		 DB	 4
  0064b	04		 DB	 4
  0064c	04		 DB	 4
  0064d	04		 DB	 4
  0064e	04		 DB	 4
  0064f	04		 DB	 4
  00650	04		 DB	 4
  00651	04		 DB	 4
  00652	04		 DB	 4
  00653	04		 DB	 4
  00654	04		 DB	 4
  00655	04		 DB	 4
  00656	04		 DB	 4
  00657	04		 DB	 4
  00658	04		 DB	 4
  00659	04		 DB	 4
  0065a	04		 DB	 4
  0065b	04		 DB	 4
  0065c	04		 DB	 4
  0065d	04		 DB	 4
  0065e	04		 DB	 4
  0065f	04		 DB	 4
  00660	04		 DB	 4
  00661	04		 DB	 4
  00662	04		 DB	 4
  00663	04		 DB	 4
  00664	04		 DB	 4
  00665	04		 DB	 4
  00666	04		 DB	 4
  00667	04		 DB	 4
  00668	04		 DB	 4
  00669	04		 DB	 4
  0066a	04		 DB	 4
  0066b	04		 DB	 4
  0066c	04		 DB	 4
  0066d	04		 DB	 4
  0066e	04		 DB	 4
  0066f	04		 DB	 4
  00670	04		 DB	 4
  00671	04		 DB	 4
  00672	04		 DB	 4
  00673	04		 DB	 4
  00674	04		 DB	 4
  00675	04		 DB	 4
  00676	04		 DB	 4
  00677	04		 DB	 4
  00678	04		 DB	 4
  00679	04		 DB	 4
  0067a	04		 DB	 4
  0067b	04		 DB	 4
  0067c	04		 DB	 4
  0067d	04		 DB	 4
  0067e	04		 DB	 4
  0067f	04		 DB	 4
  00680	04		 DB	 4
  00681	04		 DB	 4
  00682	04		 DB	 4
  00683	04		 DB	 4
  00684	04		 DB	 4
  00685	04		 DB	 4
  00686	04		 DB	 4
  00687	04		 DB	 4
  00688	04		 DB	 4
  00689	04		 DB	 4
  0068a	04		 DB	 4
  0068b	04		 DB	 4
  0068c	04		 DB	 4
  0068d	04		 DB	 4
  0068e	04		 DB	 4
  0068f	04		 DB	 4
  00690	04		 DB	 4
  00691	04		 DB	 4
  00692	04		 DB	 4
  00693	04		 DB	 4
  00694	02		 DB	 2
  00695	03		 DB	 3
  00696	66 90		 npad	 2
$LN72@MainWndpro:
  00698	00 00 00 00	 DD	 $LN40@MainWndpro
  0069c	00 00 00 00	 DD	 $LN40@MainWndpro
  006a0	00 00 00 00	 DD	 $LN40@MainWndpro
  006a4	00 00 00 00	 DD	 $LN63@MainWndpro
  006a8	00 00 00 00	 DD	 $LN40@MainWndpro
  006ac	00 00 00 00	 DD	 $LN40@MainWndpro
  006b0	00 00 00 00	 DD	 $LN63@MainWndpro
  006b4	00 00 00 00	 DD	 $LN40@MainWndpro
  006b8	00 00 00 00	 DD	 $LN40@MainWndpro
  006bc	00 00 00 00	 DD	 $LN63@MainWndpro
  006c0	00 00 00 00	 DD	 $LN54@MainWndpro
  006c4	00 00 00 00	 DD	 $LN52@MainWndpro
  006c8	00 00 00 00	 DD	 $LN51@MainWndpro
_MainWndproc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	e8 00 00 00 00	 call	 ___acrt_iob_func
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __vfprintf_l
  00029	83 c4 10	 add	 esp, 16			; 00000010H
  0002c	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\win32\win_main.c
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_pfnIsDebuggerPresent$ = -8				; size = 4
_Result$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 767  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 768  : 	int Result = -1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _Result$[ebp], -1

; 769  : 
; 770  : 	// Win95 and NT <4 don't have this, so link at runtime.
; 771  : 	p_IsDebuggerPresent pfnIsDebuggerPresent = (p_IsDebuggerPresent)GetProcAddress(GetModuleHandleA("kernel32.dll"),"IsDebuggerPresent");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KNBMEBEO@IsDebuggerPresent@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00027	89 45 f8	 mov	 DWORD PTR _pfnIsDebuggerPresent$[ebp], eax

; 772  : 
; 773  : 	UNREFERENCED_PARAMETER(hPrevInstance);
; 774  : 	UNREFERENCED_PARAMETER(lpCmdLine);
; 775  : 	UNREFERENCED_PARAMETER(nCmdShow);
; 776  : 
; 777  : #ifdef BUGTRAP
; 778  : 	// Try BugTrap first.
; 779  : 	if((!pfnIsDebuggerPresent || !pfnIsDebuggerPresent()) && InitBugTrap())
; 780  : 		Result = HandledWinMain(hInstance);
; 781  : 	else
; 782  : 	{
; 783  : #endif
; 784  : 		// Try Dr MinGW's exception handler.
; 785  : 		if (!pfnIsDebuggerPresent || !pfnIsDebuggerPresent())

  0002a	83 7d f8 00	 cmp	 DWORD PTR _pfnIsDebuggerPresent$[ebp], 0
  0002e	74 07		 je	 SHORT $LN3@WinMain
  00030	ff 55 f8	 call	 DWORD PTR _pfnIsDebuggerPresent$[ebp]
  00033	85 c0		 test	 eax, eax
  00035	75 0c		 jne	 SHORT $LN2@WinMain
$LN3@WinMain:

; 786  : 			LoadLibraryA("exchndl.dll");

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CKMPPPHB@exchndl?4dll@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00042	90		 npad	 1
$LN2@WinMain:

; 787  : 
; 788  : 		prevExceptionFilter = SetUnhandledExceptionFilter(RecordExceptionInfo);

  00043	68 00 00 00 00	 push	 OFFSET _RecordExceptionInfo@4
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetUnhandledExceptionFilter@4
  0004e	a3 00 00 00 00	 mov	 DWORD PTR _prevExceptionFilter, eax

; 789  : 
; 790  : 		Result = HandledWinMain(hInstance);

  00053	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _HandledWinMain@4
  0005c	89 45 fc	 mov	 DWORD PTR _Result$[ebp], eax

; 791  : #ifdef BUGTRAP
; 792  : 	}	// BT failure clause.
; 793  : 
; 794  : 	// This is safe even if BT didn't start.
; 795  : 	ShutdownBugTrap();
; 796  : #endif
; 797  : 
; 798  : 	return Result;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _Result$[ebp]

; 799  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
