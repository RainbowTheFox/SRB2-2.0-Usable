; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

	TITLE	C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\objs\VC10\Win32\Debug\d_net.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_debugfile
PUBLIC	_netbuffer
PUBLIC	_connectiontimeout
PUBLIC	_doomcom
PUBLIC	_I_NetGet
PUBLIC	_I_NetCanGet
PUBLIC	_I_NetSend
PUBLIC	_I_NetCanSend
PUBLIC	_I_NetFreeNodenum
PUBLIC	_I_NetMakeNode
PUBLIC	_I_NetOpenSocket
PUBLIC	_I_NetCloseSocket
PUBLIC	_I_Ban
PUBLIC	_I_Shun
PUBLIC	_I_ClearBans
PUBLIC	_I_GetNodeAddress
PUBLIC	_I_GetBanAddress
PUBLIC	_I_GetBanMask
PUBLIC	_I_SetBanAddress
PUBLIC	_bannednode
PUBLIC	_ticruned
PUBLIC	_ticmiss
PUBLIC	_getbytes
PUBLIC	_sendbytes
PUBLIC	??_C@_07MIDFMCAP@NOTHING@			; `string'
PUBLIC	??_C@_09NCJNBMKL@SERVERCFG@			; `string'
PUBLIC	??_C@_09OMIIDJHH@CLIENTCMD@			; `string'
PUBLIC	??_C@_09ONNGCAO@CLIENTMIS@			; `string'
PUBLIC	??_C@_0L@HBCEGDGE@CLIENT2CMD@			; `string'
PUBLIC	??_C@_0L@JDHBDIBN@CLIENT2MIS@			; `string'
PUBLIC	??_C@_0O@EADCFEKA@NODEKEEPALIVE@		; `string'
PUBLIC	??_C@_0BB@EINLKMMI@NODEKEEPALIVEMIS@		; `string'
PUBLIC	??_C@_0L@FNOKBKPD@SERVERTICS@			; `string'
PUBLIC	??_C@_0N@NIJOBIKK@SERVERREFUSE@			; `string'
PUBLIC	??_C@_0P@OMOELBIH@SERVERSHUTDOWN@		; `string'
PUBLIC	??_C@_0L@JHAPNMDH@CLIENTQUIT@			; `string'
PUBLIC	??_C@_07CFJGFMOO@ASKINFO@			; `string'
PUBLIC	??_C@_0L@LIPBOOMP@SERVERINFO@			; `string'
PUBLIC	??_C@_0M@LMBIKBBJ@REQUESTFILE@			; `string'
PUBLIC	??_C@_0N@ECBKCDIP@ASKINFOVIAMS@			; `string'
PUBLIC	??_C@_0N@GDIPLOE@FILEFRAGMENT@			; `string'
PUBLIC	??_C@_07BFDKAHKE@TEXTCMD@			; `string'
PUBLIC	??_C@_08DMNOAJIH@TEXTCMD2@			; `string'
PUBLIC	??_C@_0L@PLGDHIE@CLIENTJOIN@			; `string'
PUBLIC	??_C@_0M@EPGBGOLI@NODETIMEOUT@			; `string'
_DATA	SEGMENT
COMM	_ATTRPACK:DWORD
_DATA	ENDS
_BSS	SEGMENT
_debugfile DD	01H DUP (?)
_netbuffer DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_hardware_MAXPACKETLENGTH:WORD
COMM	_net_bandwidth:DWORD
_DATA	ENDS
_BSS	SEGMENT
_doomcom DD	01H DUP (?)
_I_NetGet DD	01H DUP (?)
_I_NetCanGet DD	01H DUP (?)
_I_NetSend DD	01H DUP (?)
_I_NetCanSend DD 01H DUP (?)
_I_NetFreeNodenum DD 01H DUP (?)
_I_NetMakeNode DD 01H DUP (?)
_I_NetOpenSocket DD 01H DUP (?)
_I_NetCloseSocket DD 01H DUP (?)
_I_Ban	DD	01H DUP (?)
_I_Shun	DD	01H DUP (?)
_I_ClearBans DD	01H DUP (?)
_I_GetNodeAddress DD 01H DUP (?)
_I_GetBanAddress DD 01H DUP (?)
_I_GetBanMask DD 01H DUP (?)
_I_SetBanAddress DD 01H DUP (?)
_bannednode DD	01H DUP (?)
_ticruned DD	01H DUP (?)
_ticmiss DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_getbps:DWORD
COMM	_sendbps:DWORD
COMM	_lostpercent:DWORD
COMM	_duppercent:DWORD
COMM	_gamelostpercent:DWORD
COMM	_packetheaderlength:DWORD
_DATA	ENDS
_BSS	SEGMENT
_getbytes DD	01H DUP (?)
_sendbytes DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@EPGBGOLI@NODETIMEOUT@
CONST	SEGMENT
??_C@_0M@EPGBGOLI@NODETIMEOUT@ DB 'NODETIMEOUT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PLGDHIE@CLIENTJOIN@
CONST	SEGMENT
??_C@_0L@PLGDHIE@CLIENTJOIN@ DB 'CLIENTJOIN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMNOAJIH@TEXTCMD2@
CONST	SEGMENT
??_C@_08DMNOAJIH@TEXTCMD2@ DB 'TEXTCMD2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BFDKAHKE@TEXTCMD@
CONST	SEGMENT
??_C@_07BFDKAHKE@TEXTCMD@ DB 'TEXTCMD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GDIPLOE@FILEFRAGMENT@
CONST	SEGMENT
??_C@_0N@GDIPLOE@FILEFRAGMENT@ DB 'FILEFRAGMENT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECBKCDIP@ASKINFOVIAMS@
CONST	SEGMENT
??_C@_0N@ECBKCDIP@ASKINFOVIAMS@ DB 'ASKINFOVIAMS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMBIKBBJ@REQUESTFILE@
CONST	SEGMENT
??_C@_0M@LMBIKBBJ@REQUESTFILE@ DB 'REQUESTFILE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIPBOOMP@SERVERINFO@
CONST	SEGMENT
??_C@_0L@LIPBOOMP@SERVERINFO@ DB 'SERVERINFO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFJGFMOO@ASKINFO@
CONST	SEGMENT
??_C@_07CFJGFMOO@ASKINFO@ DB 'ASKINFO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JHAPNMDH@CLIENTQUIT@
CONST	SEGMENT
??_C@_0L@JHAPNMDH@CLIENTQUIT@ DB 'CLIENTQUIT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OMOELBIH@SERVERSHUTDOWN@
CONST	SEGMENT
??_C@_0P@OMOELBIH@SERVERSHUTDOWN@ DB 'SERVERSHUTDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NIJOBIKK@SERVERREFUSE@
CONST	SEGMENT
??_C@_0N@NIJOBIKK@SERVERREFUSE@ DB 'SERVERREFUSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNOKBKPD@SERVERTICS@
CONST	SEGMENT
??_C@_0L@FNOKBKPD@SERVERTICS@ DB 'SERVERTICS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EINLKMMI@NODEKEEPALIVEMIS@
CONST	SEGMENT
??_C@_0BB@EINLKMMI@NODEKEEPALIVEMIS@ DB 'NODEKEEPALIVEMIS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EADCFEKA@NODEKEEPALIVE@
CONST	SEGMENT
??_C@_0O@EADCFEKA@NODEKEEPALIVE@ DB 'NODEKEEPALIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDHBDIBN@CLIENT2MIS@
CONST	SEGMENT
??_C@_0L@JDHBDIBN@CLIENT2MIS@ DB 'CLIENT2MIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HBCEGDGE@CLIENT2CMD@
CONST	SEGMENT
??_C@_0L@HBCEGDGE@CLIENT2CMD@ DB 'CLIENT2CMD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONNGCAO@CLIENTMIS@
CONST	SEGMENT
??_C@_09ONNGCAO@CLIENTMIS@ DB 'CLIENTMIS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMIIDJHH@CLIENTCMD@
CONST	SEGMENT
??_C@_09OMIIDJHH@CLIENTCMD@ DB 'CLIENTCMD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NCJNBMKL@SERVERCFG@
CONST	SEGMENT
??_C@_09NCJNBMKL@SERVERCFG@ DB 'SERVERCFG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIDFMCAP@NOTHING@
CONST	SEGMENT
??_C@_07MIDFMCAP@NOTHING@ DB 'NOTHING', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_connectiontimeout DD 020dH
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_Command_Ping_f
PUBLIC	_Net_GetNetStat
PUBLIC	_Net_AckTicker
PUBLIC	_Net_AllAckReceived
PUBLIC	_HSendPacket
PUBLIC	_HGetPacket
PUBLIC	_D_SetDoomcom
PUBLIC	_D_CheckNetGame
PUBLIC	_D_CloseConnection
PUBLIC	_Net_UnAcknowledgPacket
PUBLIC	_Net_CloseConnection
PUBLIC	_Net_AbortPacketType
PUBLIC	_Net_SendAcks
PUBLIC	_Net_WaitAllAckReceived
PUBLIC	??_C@_0BA@JFBMFDGN@too?5fast?5?$CFd?5?$CFd?6@	; `string'
PUBLIC	??_C@_0BB@HFLKEJGH@Connection?5lost?6@		; `string'
PUBLIC	??_C@_0P@JBMMCGDL@Remove?5ack?5?$CFd?6@		; `string'
PUBLIC	??_C@_0CA@KNBBKEDA@Discard?$CI1?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@ ; `string'
PUBLIC	??_C@_0CA@PFAPANBI@Discard?$CI2?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@ ; `string'
PUBLIC	??_C@_0CD@NOHOOIMJ@out?5of?5order?5packet?5?$CI?$CFd?5expecte@ ; `string'
PUBLIC	??_C@_0BE@NCGDAILO@no?5more?5freeackret?6@	; `string'
PUBLIC	??_C@_0DO@EJHHDHPA@ack?5?$CFd?5sent?510?5times?5so?5connect@ ; `string'
PUBLIC	??_C@_0BM@JNCPMDIE@Resend?5ack?5?$CFd?0?5?$CFu?$DM?$CFd?5at?5?$CFu?6@ ; `string'
PUBLIC	??_C@_0BH@HCAFKBCE@UnAcknowledge?5node?5?$CFd?6@ ; `string'
PUBLIC	??_C@_03PNKAICOI@?$FL?$CFd@			; `string'
PUBLIC	??_C@_03LEIBKMN@?0?$CFd@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0DI@HPNMNKDD@?$CF?912s?5?$CInode?5?$CFd?0ack?5?$CFd?0ackret?5?$CFd@ ; `string'
PUBLIC	??_C@_0N@LMEOANML@?5?5?5?5time?5?$CFu?6@	; `string'
PUBLIC	??_C@_0BH@BPHEBLM@?5?5?5?5number?5?$CFd?5mode?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0DA@MLBILJFD@?5?5?5?5firsttic?5?$CFu?5ply?5?$CFd?5tics?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CJ@KNCOBNPE@?5?5?5?5randomseed?5?$CFd?5playernum?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CM@EHADDGJE@?5?5?5?5x?5?$CFd?5y?5?$CFd?5z?5?$CFd?5momx?5?$CFd?5momy@ ; `string'
PUBLIC	??_C@_0DF@GCJNPLHF@?5?5?5?5angle?5?$CFd?5health?5?$CFd?5eflags?5?$CF@ ; `string'
PUBLIC	??_C@_0DD@COCBHAH@?5?5?5?5friction?5?$CFd?5movefactor?5?$CFd?5t@ ; `string'
PUBLIC	??_C@_0BL@KKPCPFOM@?5?5?5?5tic?5?$CF4u?5resendfrom?5?$CFu?6@ ; `string'
PUBLIC	??_C@_0BD@GNDHMNJF@?5?5?5?5length?5?$CFd?6?5?5?5?5@ ; `string'
PUBLIC	??_C@_0HE@MJPKBPHO@?5?5?5?5playermask?5?$CFx?5playerslots?5?$CF@ ; `string'
PUBLIC	??_C@_0DF@BDCPIPFB@?5?5?5?5?8?$CFs?8?5player?5?$CFd?1?$CFd?0?5map?5?$CFs?0?5@ ; `string'
PUBLIC	??_C@_0P@ILPABBGM@?5?5?5?5reason?5?$CFs?6@	; `string'
PUBLIC	??_C@_0CH@CMLNPOCJ@?5?5?5?5fileid?5?$CFd?5datasize?5?$CFd?5posit@ ; `string'
PUBLIC	??_C@_09FAAMHIJN@SENDLOCAL@			; `string'
PUBLIC	??_C@_0CC@FEPCJHGI@Tried?5to?5transmit?5to?5another?5no@ ; `string'
PUBLIC	??_C@_0BO@LFPMEAGK@HSendPacket?3?5nothing?5to?5send?6@ ; `string'
PUBLIC	??_C@_07OKMEEJEP@TRISEND@			; `string'
PUBLIC	??_C@_0BP@EGECDOJ@HSendPacket?3?5Out?5of?5bandwidth?6@ ; `string'
PUBLIC	??_C@_04ELFDPDN@SEND@				; `string'
PUBLIC	??_C@_07LOPOIIOH@NOTSEND@			; `string'
PUBLIC	??_C@_08BDOOJBBA@GETLOCAL@			; `string'
PUBLIC	??_C@_0BP@ELCNABGA@receive?5packet?5from?5node?5?$CFd?5?$CB?6@ ; `string'
PUBLIC	??_C@_0BF@CPFGGGNO@Bad?5packet?5checksum?6@	; `string'
PUBLIC	??_C@_03HAPOJHBM@GET@				; `string'
PUBLIC	??_C@_0BG@NFKGJKIP@Send?5without?5netgame?6@	; `string'
PUBLIC	??_C@_09NIIDKICI@?9extratic@			; `string'
PUBLIC	??_C@_0L@DFHPHOCE@?9bandwidth@			; `string'
PUBLIC	??_C@_0CB@GHBDLABC@usage?3?5?9bandwidth?5?$DMbyte_per_sec@ ; `string'
PUBLIC	??_C@_0M@NKFBKDNA@?9packetsize@			; `string'
PUBLIC	??_C@_0CG@CPJJPCGI@usage?3?5?9packetsize?5?$DMbytes_per_p@ ; `string'
PUBLIC	??_C@_0BI@NMIECCI@Doomcom?5buffer?5invalid?$CB@	; `string'
PUBLIC	??_C@_0BM@JIKKJDAF@Too?5many?5nodes?5?$CI?$CFd?$CJ?0?5max?3?$CFd@ ; `string'
PUBLIC	??_C@_0L@CHPMBMEI@?9debugfile@			; `string'
PUBLIC	??_C@_0M@LOAINHCL@debug?$CFd?4txt@		; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	__real@42c80000
EXTRN	_atoi:PROC
EXTRN	_fflush:PROC
EXTRN	_fopen:PROC
EXTRN	_fputs:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_I_Error:PROC
EXTRN	_CONS_Printf:PROC
EXTRN	_va:PROC
EXTRN	_ExpandTics:PROC
EXTRN	_D_ClientServerInit:PROC
EXTRN	_I_InitNetwork:PROC
EXTRN	_I_GetTime:PROC
EXTRN	_I_Sleep:PROC
EXTRN	_M_CheckParm:PROC
EXTRN	_M_IsNextParm:PROC
EXTRN	_M_GetNextParm:PROC
EXTRN	_AbortSendFiles:PROC
EXTRN	_Z_CallocAlign:PROC
EXTRN	_I_InitTcpNetwork:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__allmul:PROC
EXTRN	_M_Memcpy:DWORD
EXTRN	_text:BYTE
EXTRN	_netgame:DWORD
EXTRN	_addedtogame:DWORD
EXTRN	_multiplayer:DWORD
EXTRN	_server:DWORD
EXTRN	_software_MAXPACKETLENGTH:WORD
EXTRN	_playerpingtable:BYTE
EXTRN	_player_names:BYTE
EXTRN	_playeringame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_reboundstore DB 02440H DUP (?)
_reboundsize DW	08H DUP (?)
_rebound_head DD 01H DUP (?)
_rebound_tail DD 01H DUP (?)
_statstarttic DD 01H DUP (?)
_retransmit DD	01H DUP (?)
_duppacket DD	01H DUP (?)
_sendackpacket DD 01H DUP (?)
_getackpacket DD 01H DUP (?)
	ALIGN	8

?oldsendbyte@?1??Net_GetNetStat@@9@9 DQ 01H DUP (?)	; `Net_GetNetStat'::`2'::oldsendbyte
_ackpak	DB	016e00H DUP (?)
_nodes	DB	0a00H DUP (?)
_BSS	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOAINHCL@debug?$CFd?4txt@
CONST	SEGMENT
??_C@_0M@LOAINHCL@debug?$CFd?4txt@ DB 'debug%d.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CHPMBMEI@?9debugfile@
CONST	SEGMENT
??_C@_0L@CHPMBMEI@?9debugfile@ DB '-debugfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JIKKJDAF@Too?5many?5nodes?5?$CI?$CFd?$CJ?0?5max?3?$CFd@
CONST	SEGMENT
??_C@_0BM@JIKKJDAF@Too?5many?5nodes?5?$CI?$CFd?$CJ?0?5max?3?$CFd@ DB 'Too'
	DB	' many nodes (%d), max:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMIECCI@Doomcom?5buffer?5invalid?$CB@
CONST	SEGMENT
??_C@_0BI@NMIECCI@Doomcom?5buffer?5invalid?$CB@ DB 'Doomcom buffer invali'
	DB	'd!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CPJJPCGI@usage?3?5?9packetsize?5?$DMbytes_per_p@
CONST	SEGMENT
??_C@_0CG@CPJJPCGI@usage?3?5?9packetsize?5?$DMbytes_per_p@ DB 'usage: -pa'
	DB	'cketsize <bytes_per_packet>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKFBKDNA@?9packetsize@
CONST	SEGMENT
??_C@_0M@NKFBKDNA@?9packetsize@ DB '-packetsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GHBDLABC@usage?3?5?9bandwidth?5?$DMbyte_per_sec@
CONST	SEGMENT
??_C@_0CB@GHBDLABC@usage?3?5?9bandwidth?5?$DMbyte_per_sec@ DB 'usage: -ba'
	DB	'ndwidth <byte_per_sec>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DFHPHOCE@?9bandwidth@
CONST	SEGMENT
??_C@_0L@DFHPHOCE@?9bandwidth@ DB '-bandwidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NIIDKICI@?9extratic@
CONST	SEGMENT
??_C@_09NIIDKICI@?9extratic@ DB '-extratic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NFKGJKIP@Send?5without?5netgame?6@
CONST	SEGMENT
??_C@_0BG@NFKGJKIP@Send?5without?5netgame?6@ DB 'Send without netgame', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAPOJHBM@GET@
CONST	SEGMENT
??_C@_03HAPOJHBM@GET@ DB 'GET', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CPFGGGNO@Bad?5packet?5checksum?6@
CONST	SEGMENT
??_C@_0BF@CPFGGGNO@Bad?5packet?5checksum?6@ DB 'Bad packet checksum', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ELCNABGA@receive?5packet?5from?5node?5?$CFd?5?$CB?6@
CONST	SEGMENT
??_C@_0BP@ELCNABGA@receive?5packet?5from?5node?5?$CFd?5?$CB?6@ DB 'receiv'
	DB	'e packet from node %d !', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BDOOJBBA@GETLOCAL@
CONST	SEGMENT
??_C@_08BDOOJBBA@GETLOCAL@ DB 'GETLOCAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LOPOIIOH@NOTSEND@
CONST	SEGMENT
??_C@_07LOPOIIOH@NOTSEND@ DB 'NOTSEND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ELFDPDN@SEND@
CONST	SEGMENT
??_C@_04ELFDPDN@SEND@ DB 'SEND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EGECDOJ@HSendPacket?3?5Out?5of?5bandwidth?6@
CONST	SEGMENT
??_C@_0BP@EGECDOJ@HSendPacket?3?5Out?5of?5bandwidth?6@ DB 'HSendPacket: O'
	DB	'ut of bandwidth', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OKMEEJEP@TRISEND@
CONST	SEGMENT
??_C@_07OKMEEJEP@TRISEND@ DB 'TRISEND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFPMEAGK@HSendPacket?3?5nothing?5to?5send?6@
CONST	SEGMENT
??_C@_0BO@LFPMEAGK@HSendPacket?3?5nothing?5to?5send?6@ DB 'HSendPacket: n'
	DB	'othing to send', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FEPCJHGI@Tried?5to?5transmit?5to?5another?5no@
CONST	SEGMENT
??_C@_0CC@FEPCJHGI@Tried?5to?5transmit?5to?5another?5no@ DB 'Tried to tra'
	DB	'nsmit to another node', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAAMHIJN@SENDLOCAL@
CONST	SEGMENT
??_C@_09FAAMHIJN@SENDLOCAL@ DB 'SENDLOCAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CMLNPOCJ@?5?5?5?5fileid?5?$CFd?5datasize?5?$CFd?5posit@
CONST	SEGMENT
??_C@_0CH@CMLNPOCJ@?5?5?5?5fileid?5?$CFd?5datasize?5?$CFd?5posit@ DB '   '
	DB	' fileid %d datasize %d position %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ILPABBGM@?5?5?5?5reason?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@ILPABBGM@?5?5?5?5reason?5?$CFs?6@ DB '    reason %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BDCPIPFB@?5?5?5?5?8?$CFs?8?5player?5?$CFd?1?$CFd?0?5map?5?$CFs?0?5@
CONST	SEGMENT
??_C@_0DF@BDCPIPFB@?5?5?5?5?8?$CFs?8?5player?5?$CFd?1?$CFd?0?5map?5?$CFs?0?5@ DB ' '
	DB	'   ''%s'' player %d/%d, map %s, filenum %d, time %u ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@MJPKBPHO@?5?5?5?5playermask?5?$CFx?5playerslots?5?$CF@
CONST	SEGMENT
??_C@_0HE@MJPKBPHO@?5?5?5?5playermask?5?$CFx?5playerslots?5?$CF@ DB '    '
	DB	'playermask %x playerslots %d clientnode %d serverplayer %d ga'
	DB	'metic %u gamestate %d gametype %d modifiedgame %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNDHMNJF@?5?5?5?5length?5?$CFd?6?5?5?5?5@
CONST	SEGMENT
??_C@_0BD@GNDHMNJF@?5?5?5?5length?5?$CFd?6?5?5?5?5@ DB '    length %d', 0aH
	DB	'    ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KKPCPFOM@?5?5?5?5tic?5?$CF4u?5resendfrom?5?$CFu?6@
CONST	SEGMENT
??_C@_0BL@KKPCPFOM@?5?5?5?5tic?5?$CF4u?5resendfrom?5?$CFu?6@ DB '    tic '
	DB	'%4u resendfrom %u', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@COCBHAH@?5?5?5?5friction?5?$CFd?5movefactor?5?$CFd?5t@
CONST	SEGMENT
??_C@_0DD@COCBHAH@?5?5?5?5friction?5?$CFd?5movefactor?5?$CFd?5t@ DB '    '
	DB	'friction %d movefactor %d tics %d statenum %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GCJNPLHF@?5?5?5?5angle?5?$CFd?5health?5?$CFd?5eflags?5?$CF@
CONST	SEGMENT
??_C@_0DF@GCJNPLHF@?5?5?5?5angle?5?$CFd?5health?5?$CFd?5eflags?5?$CF@ DB ' '
	DB	'   angle %d health %d eflags %d flags %d flags2 %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EHADDGJE@?5?5?5?5x?5?$CFd?5y?5?$CFd?5z?5?$CFd?5momx?5?$CFd?5momy@
CONST	SEGMENT
??_C@_0CM@EHADDGJE@?5?5?5?5x?5?$CFd?5y?5?$CFd?5z?5?$CFd?5momx?5?$CFd?5momy@ DB ' '
	DB	'   x %d y %d z %d momx %d momy %d momz %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KNCOBNPE@?5?5?5?5randomseed?5?$CFd?5playernum?5?$CFd?5@
CONST	SEGMENT
??_C@_0CJ@KNCOBNPE@?5?5?5?5randomseed?5?$CFd?5playernum?5?$CFd?5@ DB '   '
	DB	' randomseed %d playernum %d hasmo %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MLBILJFD@?5?5?5?5firsttic?5?$CFu?5ply?5?$CFd?5tics?5?$CFd?5@
CONST	SEGMENT
??_C@_0DA@MLBILJFD@?5?5?5?5firsttic?5?$CFu?5ply?5?$CFd?5tics?5?$CFd?5@ DB ' '
	DB	'   firsttic %u ply %d tics %d ntxtcmd %Iu', 0aH, '    ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BPHEBLM@?5?5?5?5number?5?$CFd?5mode?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@BPHEBLM@?5?5?5?5number?5?$CFd?5mode?5?$CFd?6@ DB '    number %d'
	DB	' mode %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMEOANML@?5?5?5?5time?5?$CFu?6@
CONST	SEGMENT
??_C@_0N@LMEOANML@?5?5?5?5time?5?$CFu?6@ DB '    time %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HPNMNKDD@?$CF?912s?5?$CInode?5?$CFd?0ack?5?$CFd?0ackret?5?$CFd@
CONST	SEGMENT
??_C@_0DI@HPNMNKDD@?$CF?912s?5?$CInode?5?$CFd?0ack?5?$CFd?0ackret?5?$CFd@ DB '%'
	DB	'-12s (node %d,ack %d,ackret %d,size %d) type(%d) : %s', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
	ORG $+4
_packettypename DD FLAT:??_C@_07MIDFMCAP@NOTHING@
	DD	FLAT:??_C@_09NCJNBMKL@SERVERCFG@
	DD	FLAT:??_C@_09OMIIDJHH@CLIENTCMD@
	DD	FLAT:??_C@_09ONNGCAO@CLIENTMIS@
	DD	FLAT:??_C@_0L@HBCEGDGE@CLIENT2CMD@
	DD	FLAT:??_C@_0L@JDHBDIBN@CLIENT2MIS@
	DD	FLAT:??_C@_0O@EADCFEKA@NODEKEEPALIVE@
	DD	FLAT:??_C@_0BB@EINLKMMI@NODEKEEPALIVEMIS@
	DD	FLAT:??_C@_0L@FNOKBKPD@SERVERTICS@
	DD	FLAT:??_C@_0N@NIJOBIKK@SERVERREFUSE@
	DD	FLAT:??_C@_0P@OMOELBIH@SERVERSHUTDOWN@
	DD	FLAT:??_C@_0L@JHAPNMDH@CLIENTQUIT@
	DD	FLAT:??_C@_07CFJGFMOO@ASKINFO@
	DD	FLAT:??_C@_0L@LIPBOOMP@SERVERINFO@
	DD	FLAT:??_C@_0M@LMBIKBBJ@REQUESTFILE@
	DD	FLAT:??_C@_0N@ECBKCDIP@ASKINFOVIAMS@
	DD	FLAT:??_C@_0N@GDIPLOE@FILEFRAGMENT@
	DD	FLAT:??_C@_07BFDKAHKE@TEXTCMD@
	DD	FLAT:??_C@_08DMNOAJIH@TEXTCMD2@
	DD	FLAT:??_C@_0L@PLGDHIE@CLIENTJOIN@
	DD	FLAT:??_C@_0M@EPGBGOLI@NODETIMEOUT@
	ORG $+12
_DATA	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc@ DB '%c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEIBKMN@?0?$CFd@
CONST	SEGMENT
??_C@_03LEIBKMN@?0?$CFd@ DB ',%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PNKAICOI@?$FL?$CFd@
CONST	SEGMENT
??_C@_03PNKAICOI@?$FL?$CFd@ DB '[%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HCAFKBCE@UnAcknowledge?5node?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@HCAFKBCE@UnAcknowledge?5node?5?$CFd?6@ DB 'UnAcknowledge node %'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JNCPMDIE@Resend?5ack?5?$CFd?0?5?$CFu?$DM?$CFd?5at?5?$CFu?6@
CONST	SEGMENT
??_C@_0BM@JNCPMDIE@Resend?5ack?5?$CFd?0?5?$CFu?$DM?$CFd?5at?5?$CFu?6@ DB 'R'
	DB	'esend ack %d, %u<%d at %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EJHHDHPA@ack?5?$CFd?5sent?510?5times?5so?5connect@
CONST	SEGMENT
??_C@_0DO@EJHHDHPA@ack?5?$CFd?5sent?510?5times?5so?5connect@ DB 'ack %d s'
	DB	'ent 10 times so connection is supposed lost: node %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NCGDAILO@no?5more?5freeackret?6@
CONST	SEGMENT
??_C@_0BE@NCGDAILO@no?5more?5freeackret?6@ DB 'no more freeackret', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NOHOOIMJ@out?5of?5order?5packet?5?$CI?$CFd?5expecte@
CONST	SEGMENT
??_C@_0CD@NOHOOIMJ@out?5of?5order?5packet?5?$CI?$CFd?5expecte@ DB 'out of'
	DB	' order packet (%d expected)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PFAPANBI@Discard?$CI2?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@
CONST	SEGMENT
??_C@_0CA@PFAPANBI@Discard?$CI2?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@ DB 'D'
	DB	'iscard(2) ack %d (duplicated)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KNBBKEDA@Discard?$CI1?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@
CONST	SEGMENT
??_C@_0CA@KNBBKEDA@Discard?$CI1?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@ DB 'D'
	DB	'iscard(1) ack %d (duplicated)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JBMMCGDL@Remove?5ack?5?$CFd?6@
CONST	SEGMENT
??_C@_0P@JBMMCGDL@Remove?5ack?5?$CFd?6@ DB 'Remove ack %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFLKEJGH@Connection?5lost?6@
CONST	SEGMENT
??_C@_0BB@HFLKEJGH@Connection?5lost?6@ DB 'Connection lost', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFBMFDGN@too?5fast?5?$CFd?5?$CFd?6@
CONST	SEGMENT
??_C@_0BA@JFBMFDGN@too?5fast?5?$CFd?5?$CFd?6@ DB 'too fast %d %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	039bH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Internal_FreeNodenum
_TEXT	SEGMENT
_nodenum$ = 8						; size = 4
_Internal_FreeNodenum PROC				; COMDAT

; 992  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 993  : 	(void)nodenum;
; 994  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_Internal_FreeNodenum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Internal_Send
_TEXT	SEGMENT
_Internal_Send PROC					; COMDAT

; 987  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 988  : 	I_Error("Send without netgame\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NFKGJKIP@Send?5without?5netgame?6@
  0000e	e8 00 00 00 00	 call	 _I_Error
  00013	83 c4 04	 add	 esp, 4

; 989  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_Internal_Send ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Internal_Get
_TEXT	SEGMENT
_Internal_Get PROC					; COMDAT

; 982  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 983  : 	doomcom->remotenode = -1;

  00009	83 c8 ff	 or	 eax, -1
  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00012	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 984  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_Internal_Get ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _DebugPrintpacket
_TEXT	SEGMENT
tv89 = -68						; size = 4
_header$ = 8						; size = 4
_DebugPrintpacket PROC					; COMDAT

; 736  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 737  : 	fprintf(debugfile, "%-12s (node %d,ack %d,ackret %d,size %d) type(%d) : %s\n",

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0000e	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00012	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _packettypename[ecx*4]
  00019	52		 push	 edx
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0001f	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00023	51		 push	 ecx
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _doomcom
  0002a	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  0002e	50		 push	 eax
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00035	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00039	52		 push	 edx
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0003f	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00043	51		 push	 ecx
  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _doomcom
  0004a	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  00052	51		 push	 ecx
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HPNMNKDD@?$CF?912s?5?$CInode?5?$CFd?0ack?5?$CFd?0ackret?5?$CFd@
  00058	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _debugfile
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _fprintf
  00064	83 c4 24	 add	 esp, 36			; 00000024H

; 738  : 		header, doomcom->remotenode, netbuffer->ack, netbuffer->ackreturn, doomcom->datalength,
; 739  : 		netbuffer->packettype, packettypename[netbuffer->packettype]);
; 740  : 
; 741  : 	switch (netbuffer->packettype)

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0006c	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00070	89 4d bc	 mov	 DWORD PTR tv89[ebp], ecx
  00073	8b 55 bc	 mov	 edx, DWORD PTR tv89[ebp]
  00076	83 ea 01	 sub	 edx, 1
  00079	89 55 bc	 mov	 DWORD PTR tv89[ebp], edx
  0007c	83 7d bc 15	 cmp	 DWORD PTR tv89[ebp], 21	; 00000015H
  00080	0f 87 30 04 00
	00		 ja	 $LN21@DebugPrint
  00086	8b 45 bc	 mov	 eax, DWORD PTR tv89[ebp]
  00089	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@DebugPrint[eax*4]
$LN4@DebugPrint:

; 742  : 	{
; 743  : 		case PT_ASKINFO:
; 744  : 		case PT_ASKINFOVIAMS:
; 745  : 			fprintf(debugfile, "    time %u\n", (tic_t)LONG(netbuffer->u.askinfo.time)				);

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00095	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00098	51		 push	 ecx
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LMEOANML@?5?5?5?5time?5?$CFu?6@
  0009e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _debugfile
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _fprintf
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 746  : 			break;

  000ad	e9 34 04 00 00	 jmp	 $LN2@DebugPrint
$LN6@DebugPrint:

; 747  : 		case PT_CLIENTJOIN:
; 748  : 			fprintf(debugfile, "    number %d mode %d\n", netbuffer->u.clientcfg.localplayers,

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  000b7	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  000bb	51		 push	 ecx
  000bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  000c2	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  000c6	50		 push	 eax
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@BPHEBLM@?5?5?5?5number?5?$CFd?5mode?5?$CFd?6@
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  000d2	51		 push	 ecx
  000d3	e8 00 00 00 00	 call	 _fprintf
  000d8	83 c4 10	 add	 esp, 16			; 00000010H

; 749  : 				netbuffer->u.clientcfg.mode);
; 750  : 			break;

  000db	e9 06 04 00 00	 jmp	 $LN2@DebugPrint
$LN7@DebugPrint:

; 751  : 		case PT_SERVERTICS:
; 752  : 			fprintf(debugfile, "    firsttic %u ply %d tics %d ntxtcmd %"PRIdS"\n    ",

  000e0	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000e5	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  000e9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _netbuffer
  000ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  000f5	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  000f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  000ff	0f b6 52 09	 movzx	 edx, BYTE PTR [edx+9]
  00103	0f af c2	 imul	 eax, edx
  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0010c	8d 44 c2 0c	 lea	 eax, DWORD PTR [edx+eax*8+12]
  00110	2b c8		 sub	 ecx, eax
  00112	51		 push	 ecx
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00119	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  0011d	52		 push	 edx
  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00123	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00127	51		 push	 ecx
  00128	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0012e	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 _ExpandTics
  00138	83 c4 04	 add	 esp, 4
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MLBILJFD@?5?5?5?5firsttic?5?$CFu?5ply?5?$CFd?5tics?5?$CFd?5@
  00141	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 _fprintf
  0014d	83 c4 18	 add	 esp, 24			; 00000018H

; 753  : 				(UINT32)ExpandTics(netbuffer->u.serverpak.starttic), netbuffer->u.serverpak.numslots,
; 754  : 				netbuffer->u.serverpak.numtics,
; 755  : 				(size_t)(&((UINT8 *)netbuffer)[doomcom->datalength] - (UINT8 *)&netbuffer->u.serverpak.cmds[netbuffer->u.serverpak.numslots*netbuffer->u.serverpak.numtics]));
; 756  : 			fprintfstring((char *)&netbuffer->u.serverpak.cmds[netbuffer->u.serverpak.numslots*netbuffer->u.serverpak.numtics],(size_t)(

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00155	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00159	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _netbuffer
  0015f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00165	0f b6 42 0a	 movzx	 eax, BYTE PTR [edx+10]
  00169	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0016f	0f b6 52 09	 movzx	 edx, BYTE PTR [edx+9]
  00173	0f af c2	 imul	 eax, edx
  00176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0017c	8d 44 c2 0c	 lea	 eax, DWORD PTR [edx+eax*8+12]
  00180	2b c8		 sub	 ecx, eax
  00182	51		 push	 ecx
  00183	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00189	0f b6 51 0a	 movzx	 edx, BYTE PTR [ecx+10]
  0018d	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00192	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00196	0f af d1	 imul	 edx, ecx
  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0019e	8d 4c d0 0c	 lea	 ecx, DWORD PTR [eax+edx*8+12]
  001a2	51		 push	 ecx
  001a3	e8 00 00 00 00	 call	 _fprintfstring
  001a8	83 c4 08	 add	 esp, 8

; 757  : 				&((UINT8 *)netbuffer)[doomcom->datalength] - (UINT8 *)&netbuffer->u.serverpak.cmds[netbuffer->u.serverpak.numslots*netbuffer->u.serverpak.numtics]));
; 758  : 			break;

  001ab	e9 36 03 00 00	 jmp	 $LN2@DebugPrint
$LN8@DebugPrint:

; 759  : 		case PT_CONSISTENCY:
; 760  : 			fprintf(debugfile, "    randomseed %d playernum %d hasmo %d\n",

  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  001b5	0f b6 88 f1 01
	00 00		 movzx	 ecx, BYTE PTR [eax+497]
  001bc	51		 push	 ecx
  001bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  001c3	0f b6 42 27	 movzx	 eax, BYTE PTR [edx+39]
  001c7	50		 push	 eax
  001c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  001ce	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  001d2	52		 push	 edx
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KNCOBNPE@?5?5?5?5randomseed?5?$CFd?5playernum?5?$CFd?5@
  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 _fprintf
  001e3	83 c4 14	 add	 esp, 20			; 00000014H

; 761  : 				netbuffer->u.consistency.randomseed, netbuffer->u.consistency.playernum, netbuffer->u.consistency.hasmo);
; 762  : 			fprintf(debugfile, "    x %d y %d z %d momx %d momy %d momz %d\n",

  001e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  001eb	8b 88 0a 02 00
	00		 mov	 ecx, DWORD PTR [eax+522]
  001f1	51		 push	 ecx
  001f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  001f8	8b 82 06 02 00
	00		 mov	 eax, DWORD PTR [edx+518]
  001fe	50		 push	 eax
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00205	8b 91 02 02 00
	00		 mov	 edx, DWORD PTR [ecx+514]
  0020b	52		 push	 edx
  0020c	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00211	8b 88 fe 01 00
	00		 mov	 ecx, DWORD PTR [eax+510]
  00217	51		 push	 ecx
  00218	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0021e	8b 82 fa 01 00
	00		 mov	 eax, DWORD PTR [edx+506]
  00224	50		 push	 eax
  00225	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  0022b	8b 91 f6 01 00
	00		 mov	 edx, DWORD PTR [ecx+502]
  00231	52		 push	 edx
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@EHADDGJE@?5?5?5?5x?5?$CFd?5y?5?$CFd?5z?5?$CFd?5momx?5?$CFd?5momy@
  00237	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 _fprintf
  00242	83 c4 20	 add	 esp, 32			; 00000020H

; 763  : 				netbuffer->u.consistency.x, netbuffer->u.consistency.y, netbuffer->u.consistency.z,
; 764  : 				netbuffer->u.consistency.momx, netbuffer->u.consistency.momy, netbuffer->u.consistency.momz);
; 765  : 			fprintf(debugfile, "    angle %d health %d eflags %d flags %d flags2 %d\n",

  00245	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0024a	8b 88 22 02 00
	00		 mov	 ecx, DWORD PTR [eax+546]
  00250	51		 push	 ecx
  00251	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00257	8b 82 1e 02 00
	00		 mov	 eax, DWORD PTR [edx+542]
  0025d	50		 push	 eax
  0025e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00264	8b 91 26 02 00
	00		 mov	 edx, DWORD PTR [ecx+550]
  0026a	52		 push	 edx
  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00270	8b 88 2a 02 00
	00		 mov	 ecx, DWORD PTR [eax+554]
  00276	51		 push	 ecx
  00277	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0027d	8b 82 f2 01 00
	00		 mov	 eax, DWORD PTR [edx+498]
  00283	50		 push	 eax
  00284	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GCJNPLHF@?5?5?5?5angle?5?$CFd?5health?5?$CFd?5eflags?5?$CF@
  00289	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 _fprintf
  00295	83 c4 1c	 add	 esp, 28			; 0000001cH

; 766  : 				netbuffer->u.consistency.angle, netbuffer->u.consistency.health, netbuffer->u.consistency.eflags,
; 767  : 				netbuffer->u.consistency.flags, netbuffer->u.consistency.flags2);
; 768  : 			fprintf(debugfile, "    friction %d movefactor %d tics %d statenum %d\n",

  00298	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0029d	8b 88 1a 02 00
	00		 mov	 ecx, DWORD PTR [eax+538]
  002a3	51		 push	 ecx
  002a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  002aa	8b 82 16 02 00
	00		 mov	 eax, DWORD PTR [edx+534]
  002b0	50		 push	 eax
  002b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  002b7	8b 91 12 02 00
	00		 mov	 edx, DWORD PTR [ecx+530]
  002bd	52		 push	 edx
  002be	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  002c3	8b 88 0e 02 00
	00		 mov	 ecx, DWORD PTR [eax+526]
  002c9	51		 push	 ecx
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@COCBHAH@?5?5?5?5friction?5?$CFd?5movefactor?5?$CFd?5t@
  002cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _debugfile
  002d5	52		 push	 edx
  002d6	e8 00 00 00 00	 call	 _fprintf
  002db	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@DebugPrint:

; 769  : 				netbuffer->u.consistency.friction, netbuffer->u.consistency.movefactor,
; 770  : 				netbuffer->u.consistency.tics, (INT32)netbuffer->u.consistency.statenum);
; 771  : 		case PT_CLIENTCMD:
; 772  : 		case PT_CLIENT2CMD:
; 773  : 		case PT_CLIENTMIS:
; 774  : 		case PT_CLIENT2MIS:
; 775  : 		case PT_NODEKEEPALIVE:
; 776  : 		case PT_NODEKEEPALIVEMIS:
; 777  : 			fprintf(debugfile, "    tic %4u resendfrom %u\n",

  002de	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  002e3	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  002e7	51		 push	 ecx
  002e8	e8 00 00 00 00	 call	 _ExpandTics
  002ed	83 c4 04	 add	 esp, 4
  002f0	50		 push	 eax
  002f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  002f7	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _ExpandTics
  00301	83 c4 04	 add	 esp, 4
  00304	50		 push	 eax
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KKPCPFOM@?5?5?5?5tic?5?$CF4u?5resendfrom?5?$CFu?6@
  0030a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  00310	51		 push	 ecx
  00311	e8 00 00 00 00	 call	 _fprintf
  00316	83 c4 10	 add	 esp, 16			; 00000010H

; 778  : 				(UINT32)ExpandTics(netbuffer->u.clientpak.client_tic),
; 779  : 				(UINT32)ExpandTics (netbuffer->u.clientpak.resendfrom));
; 780  : 			break;

  00319	e9 c8 01 00 00	 jmp	 $LN2@DebugPrint
$LN15@DebugPrint:

; 781  : 		case PT_TEXTCMD:
; 782  : 		case PT_TEXTCMD2:
; 783  : 			fprintf(debugfile, "    length %d\n    ", netbuffer->u.textcmd[0]);

  0031e	b8 01 00 00 00	 mov	 eax, 1
  00323	6b c8 00	 imul	 ecx, eax, 0
  00326	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0032c	0f b6 44 0a 08	 movzx	 eax, BYTE PTR [edx+ecx+8]
  00331	50		 push	 eax
  00332	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GNDHMNJF@?5?5?5?5length?5?$CFd?6?5?5?5?5@
  00337	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  0033d	51		 push	 ecx
  0033e	e8 00 00 00 00	 call	 _fprintf
  00343	83 c4 0c	 add	 esp, 12			; 0000000cH

; 784  : 			fprintfstring((char *)netbuffer->u.textcmd+1, netbuffer->u.textcmd[0]);

  00346	b8 01 00 00 00	 mov	 eax, 1
  0034b	6b c8 00	 imul	 ecx, eax, 0
  0034e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00354	0f b6 44 0a 08	 movzx	 eax, BYTE PTR [edx+ecx+8]
  00359	50		 push	 eax
  0035a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00360	83 c1 09	 add	 ecx, 9
  00363	51		 push	 ecx
  00364	e8 00 00 00 00	 call	 _fprintfstring
  00369	83 c4 08	 add	 esp, 8

; 785  : 			break;

  0036c	e9 75 01 00 00	 jmp	 $LN2@DebugPrint
$LN17@DebugPrint:

; 786  : 		case PT_SERVERCFG:
; 787  : 			fprintf(debugfile, "    playermask %x playerslots %d clientnode %d serverplayer %d "

  00371	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00376	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0037a	51		 push	 ecx
  0037b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00381	0f b6 42 20	 movzx	 eax, BYTE PTR [edx+32]
  00385	50		 push	 eax
  00386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  0038c	0f b6 51 19	 movzx	 edx, BYTE PTR [ecx+25]
  00390	52		 push	 edx
  00391	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00396	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00399	51		 push	 ecx
  0039a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  003a0	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  003a4	50		 push	 eax
  003a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  003ab	0f b6 51 18	 movzx	 edx, BYTE PTR [ecx+24]
  003af	52		 push	 edx
  003b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  003b5	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  003b9	51		 push	 ecx
  003ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  003c0	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  003c3	50		 push	 eax
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_0HE@MJPKBPHO@?5?5?5?5playermask?5?$CFx?5playerslots?5?$CF@
  003c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  003cf	51		 push	 ecx
  003d0	e8 00 00 00 00	 call	 _fprintf
  003d5	83 c4 28	 add	 esp, 40			; 00000028H

; 788  : 				"gametic %u gamestate %d gametype %d modifiedgame %d\n",
; 789  : 				(UINT32)LONG(netbuffer->u.servercfg.playerdetected),
; 790  : 				netbuffer->u.servercfg.totalslotnum, netbuffer->u.servercfg.clientnode,
; 791  : 				netbuffer->u.servercfg.serverplayer, (UINT32)LONG(netbuffer->u.servercfg.gametic),
; 792  : 				netbuffer->u.servercfg.gamestate, netbuffer->u.servercfg.gametype,
; 793  : 				netbuffer->u.servercfg.modifiedgame);
; 794  : 			break;

  003d8	e9 09 01 00 00	 jmp	 $LN2@DebugPrint
$LN18@DebugPrint:

; 795  : 		case PT_SERVERINFO:
; 796  : 			fprintf(debugfile, "    '%s' player %d/%d, map %s, filenum %d, time %u \n",

  003dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  003e2	8b 48 12	 mov	 ecx, DWORD PTR [eax+18]
  003e5	51		 push	 ecx
  003e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  003ec	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  003f0	50		 push	 eax
  003f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  003f7	83 c1 3a	 add	 ecx, 58			; 0000003aH
  003fa	51		 push	 ecx
  003fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00401	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  00405	50		 push	 eax
  00406	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  0040c	0f b6 51 0a	 movzx	 edx, BYTE PTR [ecx+10]
  00410	52		 push	 edx
  00411	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00416	83 c0 1a	 add	 eax, 26			; 0000001aH
  00419	50		 push	 eax
  0041a	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BDCPIPFB@?5?5?5?5?8?$CFs?8?5player?5?$CFd?1?$CFd?0?5map?5?$CFs?0?5@
  0041f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  00425	51		 push	 ecx
  00426	e8 00 00 00 00	 call	 _fprintf
  0042b	83 c4 20	 add	 esp, 32			; 00000020H

; 797  : 				netbuffer->u.serverinfo.servername, netbuffer->u.serverinfo.numberofplayer,
; 798  : 				netbuffer->u.serverinfo.maxplayer, netbuffer->u.serverinfo.mapname,
; 799  : 				netbuffer->u.serverinfo.fileneedednum,
; 800  : 				(UINT32)LONG(netbuffer->u.serverinfo.time));
; 801  : 			fprintfstring((char *)netbuffer->u.serverinfo.fileneeded,

  0042e	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00433	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00437	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _netbuffer
  0043d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00443	83 c2 75	 add	 edx, 117		; 00000075H
  00446	2b ca		 sub	 ecx, edx
  00448	0f b6 c1	 movzx	 eax, cl
  0044b	50		 push	 eax
  0044c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00452	83 c1 75	 add	 ecx, 117		; 00000075H
  00455	51		 push	 ecx
  00456	e8 00 00 00 00	 call	 _fprintfstring
  0045b	83 c4 08	 add	 esp, 8

; 802  : 				(UINT8)((UINT8 *)netbuffer + doomcom->datalength
; 803  : 				- (UINT8 *)netbuffer->u.serverinfo.fileneeded));
; 804  : 			break;

  0045e	e9 83 00 00 00	 jmp	 $LN2@DebugPrint
$LN19@DebugPrint:

; 805  : 		case PT_SERVERREFUSE:
; 806  : 			fprintf(debugfile, "    reason %s\n", netbuffer->u.serverrefuse.reason);

  00463	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00468	83 c0 08	 add	 eax, 8
  0046b	50		 push	 eax
  0046c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ILPABBGM@?5?5?5?5reason?5?$CFs?6@
  00471	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _debugfile
  00477	51		 push	 ecx
  00478	e8 00 00 00 00	 call	 _fprintf
  0047d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 807  : 			break;

  00480	eb 64		 jmp	 SHORT $LN2@DebugPrint
$LN20@DebugPrint:

; 808  : 		case PT_FILEFRAGMENT:
; 809  : 			fprintf(debugfile, "    fileid %d datasize %d position %u\n",

  00482	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00487	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0048a	51		 push	 ecx
  0048b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00491	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  00495	50		 push	 eax
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  0049c	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  004a0	52		 push	 edx
  004a1	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CMLNPOCJ@?5?5?5?5fileid?5?$CFd?5datasize?5?$CFd?5posit@
  004a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  004ab	50		 push	 eax
  004ac	e8 00 00 00 00	 call	 _fprintf
  004b1	83 c4 14	 add	 esp, 20			; 00000014H

; 810  : 				netbuffer->u.filetxpak.fileid, (UINT16)SHORT(netbuffer->u.filetxpak.size),
; 811  : 				(UINT32)LONG(netbuffer->u.filetxpak.position));
; 812  : 			break;

  004b4	eb 30		 jmp	 SHORT $LN2@DebugPrint
$LN21@DebugPrint:

; 813  : 		case PT_REQUESTFILE:
; 814  : 		default: // write as a raw packet
; 815  : 			fprintfstring((char *)netbuffer->u.textcmd,

  004b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  004bb	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  004bf	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _netbuffer
  004c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  004cb	83 c2 08	 add	 edx, 8
  004ce	2b ca		 sub	 ecx, edx
  004d0	0f b6 c1	 movzx	 eax, cl
  004d3	50		 push	 eax
  004d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  004da	83 c1 08	 add	 ecx, 8
  004dd	51		 push	 ecx
  004de	e8 00 00 00 00	 call	 _fprintfstring
  004e3	83 c4 08	 add	 esp, 8
$LN2@DebugPrint:

; 816  : 				(UINT8)((UINT8 *)netbuffer + doomcom->datalength - (UINT8 *)netbuffer->u.textcmd));
; 817  : 			break;
; 818  : 	}
; 819  : }

  004e6	5f		 pop	 edi
  004e7	5e		 pop	 esi
  004e8	5b		 pop	 ebx
  004e9	8b e5		 mov	 esp, ebp
  004eb	5d		 pop	 ebp
  004ec	c3		 ret	 0
  004ed	0f 1f 00	 npad	 3
$LN24@DebugPrint:
  004f0	00 00 00 00	 DD	 $LN17@DebugPrint
  004f4	00 00 00 00	 DD	 $LN9@DebugPrint
  004f8	00 00 00 00	 DD	 $LN9@DebugPrint
  004fc	00 00 00 00	 DD	 $LN9@DebugPrint
  00500	00 00 00 00	 DD	 $LN9@DebugPrint
  00504	00 00 00 00	 DD	 $LN9@DebugPrint
  00508	00 00 00 00	 DD	 $LN9@DebugPrint
  0050c	00 00 00 00	 DD	 $LN7@DebugPrint
  00510	00 00 00 00	 DD	 $LN19@DebugPrint
  00514	00 00 00 00	 DD	 $LN21@DebugPrint
  00518	00 00 00 00	 DD	 $LN21@DebugPrint
  0051c	00 00 00 00	 DD	 $LN4@DebugPrint
  00520	00 00 00 00	 DD	 $LN18@DebugPrint
  00524	00 00 00 00	 DD	 $LN21@DebugPrint
  00528	00 00 00 00	 DD	 $LN21@DebugPrint
  0052c	00 00 00 00	 DD	 $LN4@DebugPrint
  00530	00 00 00 00	 DD	 $LN20@DebugPrint
  00534	00 00 00 00	 DD	 $LN15@DebugPrint
  00538	00 00 00 00	 DD	 $LN15@DebugPrint
  0053c	00 00 00 00	 DD	 $LN6@DebugPrint
  00540	00 00 00 00	 DD	 $LN21@DebugPrint
  00544	00 00 00 00	 DD	 $LN8@DebugPrint
_DebugPrintpacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _fprintfstring
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mode$ = -4						; size = 4
_s$ = 8							; size = 4
_len$ = 12						; size = 4
_fprintfstring PROC					; COMDAT

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 680  : 	INT32 mode = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mode$[ebp], 0

; 681  : 	size_t i;
; 682  : 
; 683  : 	for (i = 0; i < len; i++)

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@fprintfstr
$LN2@fprintfstr:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@fprintfstr:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00028	0f 83 9e 00 00
	00		 jae	 $LN3@fprintfstr

; 684  : 		if (s[i] < 32)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00031	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00037	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0003a	7d 4d		 jge	 SHORT $LN5@fprintfstr

; 685  : 		{
; 686  : 			if (!mode)

  0003c	83 7d fc 00	 cmp	 DWORD PTR _mode$[ebp], 0
  00040	75 27		 jne	 SHORT $LN7@fprintfstr

; 687  : 			{
; 688  : 				fprintf(debugfile, "[%d", (UINT8)s[i]);

  00042	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00045	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00048	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_03PNKAICOI@?$FL?$CFd@
  00051	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _debugfile
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _fprintf
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 689  : 				mode = 1;

  00060	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _mode$[ebp], 1

; 690  : 			}

  00067	eb 1e		 jmp	 SHORT $LN8@fprintfstr
$LN7@fprintfstr:

; 691  : 			else
; 692  : 				fprintf(debugfile, ",%d", (UINT8)s[i]);

  00069	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0006c	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0006f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00072	51		 push	 ecx
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_03LEIBKMN@?0?$CFd@
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _debugfile
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _fprintf
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@fprintfstr:

; 693  : 		}

  00087	eb 3e		 jmp	 SHORT $LN6@fprintfstr
$LN5@fprintfstr:

; 694  : 		else
; 695  : 		{
; 696  : 			if (mode)

  00089	83 7d fc 00	 cmp	 DWORD PTR _mode$[ebp], 0
  0008d	74 1a		 je	 SHORT $LN9@fprintfstr

; 697  : 			{
; 698  : 				fprintf(debugfile, "]");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_01LBDDMOBJ@?$FN@
  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _fprintf
  0009f	83 c4 08	 add	 esp, 8

; 699  : 				mode = 0;

  000a2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mode$[ebp], 0
$LN9@fprintfstr:

; 700  : 			}
; 701  : 			fprintf(debugfile, "%c", s[i]);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000ac	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000af	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b2	51		 push	 ecx
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc@
  000b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _debugfile
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 _fprintf
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@fprintfstr:

; 702  : 		}

  000c7	e9 4d ff ff ff	 jmp	 $LN2@fprintfstr
$LN3@fprintfstr:

; 703  : 	if (mode)

  000cc	83 7d fc 00	 cmp	 DWORD PTR _mode$[ebp], 0
  000d0	74 13		 je	 SHORT $LN10@fprintfstr

; 704  : 		fprintf(debugfile, "]");

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_01LBDDMOBJ@?$FN@
  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _fprintf
  000e2	83 c4 08	 add	 esp, 8
$LN10@fprintfstr:

; 705  : 	fprintf(debugfile, "\n");

  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 _fprintf
  000f5	83 c4 08	 add	 esp, 8

; 706  : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_fprintfstring ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _NetbufferChecksum
_TEXT	SEGMENT
_i$ = -16						; size = 4
_buf$ = -12						; size = 4
_l$ = -8						; size = 4
_c$ = -4						; size = 4
_NetbufferChecksum PROC					; COMDAT

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 665  : 	UINT32 c = 0x1234567;

  00009	c7 45 fc 67 45
	23 01		 mov	 DWORD PTR _c$[ebp], 19088743 ; 01234567H

; 666  : 	const INT32 l = doomcom->datalength - 4;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00015	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00019	83 e9 04	 sub	 ecx, 4
  0001c	89 4d f8	 mov	 DWORD PTR _l$[ebp], ecx

; 667  : 	const UINT8 *buf = (UINT8 *)netbuffer + 4;

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00024	83 c0 04	 add	 eax, 4
  00027	89 45 f4	 mov	 DWORD PTR _buf$[ebp], eax

; 668  : 	INT32 i;
; 669  : 
; 670  : 	for (i = 0; i < l; i++, buf++)

  0002a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 12		 jmp	 SHORT $LN4@NetbufferC
$LN2@NetbufferC:
  00033	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _buf$[ebp]
  0003f	83 c1 01	 add	 ecx, 1
  00042	89 4d f4	 mov	 DWORD PTR _buf$[ebp], ecx
$LN4@NetbufferC:
  00045	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00048	3b 45 f8	 cmp	 eax, DWORD PTR _l$[ebp]
  0004b	7d 17		 jge	 SHORT $LN3@NetbufferC

; 671  : 		c += (*buf) * (i+1);

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _buf$[ebp]
  00050	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00053	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00056	83 c2 01	 add	 edx, 1
  00059	0f af ca	 imul	 ecx, edx
  0005c	03 4d fc	 add	 ecx, DWORD PTR _c$[ebp]
  0005f	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  00062	eb cf		 jmp	 SHORT $LN2@NetbufferC
$LN3@NetbufferC:

; 672  : 
; 673  : 	return LONG(c);

  00064	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]

; 674  : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_NetbufferChecksum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _InitAck
_TEXT	SEGMENT
_i$ = -4						; size = 4
_InitAck PROC						; COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 602  : 	INT32 i;
; 603  : 
; 604  : 	for (i = 0; i < MAXACKPACKETS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@InitAck
$LN2@InitAck:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@InitAck:
  0001b	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0001f	7d 10		 jge	 SHORT $LN3@InitAck

; 605  : 		ackpak[i].acknum = 0;

  00021	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00028	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _ackpak[eax], 0
  0002f	eb e1		 jmp	 SHORT $LN2@InitAck
$LN3@InitAck:

; 606  : 
; 607  : 	for (i = 0; i < MAXNETNODES; i++)

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00038	eb 09		 jmp	 SHORT $LN7@InitAck
$LN5@InitAck:
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	83 c0 01	 add	 eax, 1
  00040	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@InitAck:
  00043	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00047	7d 0e		 jge	 SHORT $LN6@InitAck

; 608  : 		InitNode(i);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _InitNode
  00052	83 c4 04	 add	 esp, 4
  00055	eb e3		 jmp	 SHORT $LN5@InitAck
$LN6@InitAck:

; 609  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_InitAck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _InitNode
_TEXT	SEGMENT
_node$ = 8						; size = 4
_InitNode PROC						; COMDAT

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 588  : 	nodes[node].acktosend_head = nodes[node].acktosend_tail = 0;

  00009	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0000d	c6 80 02 00 00
	00 00		 mov	 BYTE PTR _nodes[eax+2], 0
  00014	6b 4d 08 50	 imul	 ecx, DWORD PTR _node$[ebp], 80
  00018	c6 81 01 00 00
	00 00		 mov	 BYTE PTR _nodes[ecx+1], 0

; 589  : #ifndef NEWPING
; 590  : 	nodes[node].ping = PINGDEFAULT;
; 591  : 	nodes[node].varping = VARPINGDEFAULT;
; 592  : 	nodes[node].timeout = TIMEOUT(nodes[node].ping,nodes[node].varping);
; 593  : #endif
; 594  : 	nodes[node].firstacktosend = 0;

  0001f	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00023	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _nodes[eax], 0

; 595  : 	nodes[node].nextacknum = 1;

  0002a	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0002e	c6 80 4d 00 00
	00 01		 mov	 BYTE PTR _nodes[eax+77], 1

; 596  : 	nodes[node].remotefirstack = 0;

  00035	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00039	c6 80 4c 00 00
	00 00		 mov	 BYTE PTR _nodes[eax+76], 0

; 597  : 	nodes[node].flags = 0;

  00040	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00044	c6 80 4e 00 00
	00 00		 mov	 BYTE PTR _nodes[eax+78], 0

; 598  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_InitNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_ConnectionTimeout
_TEXT	SEGMENT
_node$ = 8						; size = 4
_Net_ConnectionTimeout PROC				; COMDAT

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 447  : 	// send a very special packet to self (hack the reboundstore queue)
; 448  : 	// main code will handle it
; 449  : 	reboundstore[rebound_head].packettype = PT_NODETIMEOUT;

  00009	69 05 00 00 00
	00 88 04 00 00	 imul	 eax, DWORD PTR _rebound_head, 1160
  00013	c6 80 06 00 00
	00 15		 mov	 BYTE PTR _reboundstore[eax+6], 21 ; 00000015H

; 450  : 	reboundstore[rebound_head].ack = 0;

  0001a	69 05 00 00 00
	00 88 04 00 00	 imul	 eax, DWORD PTR _rebound_head, 1160
  00024	c6 80 04 00 00
	00 00		 mov	 BYTE PTR _reboundstore[eax+4], 0

; 451  : 	reboundstore[rebound_head].ackreturn = 0;

  0002b	69 05 00 00 00
	00 88 04 00 00	 imul	 eax, DWORD PTR _rebound_head, 1160
  00035	c6 80 05 00 00
	00 00		 mov	 BYTE PTR _reboundstore[eax+5], 0

; 452  : 	reboundstore[rebound_head].u.textcmd[0] = (UINT8)node;

  0003c	69 05 00 00 00
	00 88 04 00 00	 imul	 eax, DWORD PTR _rebound_head, 1160
  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	6b d1 00	 imul	 edx, ecx, 0
  0004e	8a 4d 08	 mov	 cl, BYTE PTR _node$[ebp]
  00051	88 8c 10 08 00
	00 00		 mov	 BYTE PTR _reboundstore[eax+edx+8], cl

; 453  : 	reboundsize[rebound_head] = (INT16)(BASEPACKETSIZE + 1);

  00058	b8 09 00 00 00	 mov	 eax, 9
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rebound_head
  00063	66 89 04 4d 00
	00 00 00	 mov	 WORD PTR _reboundsize[ecx*2], ax

; 454  : 	rebound_head = (rebound_head+1) % MAXREBOUND;

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_head
  00070	83 c0 01	 add	 eax, 1
  00073	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00078	79 05		 jns	 SHORT $LN3@Net_Connec
  0007a	48		 dec	 eax
  0007b	83 c8 f8	 or	 eax, -8			; fffffff8H
  0007e	40		 inc	 eax
$LN3@Net_Connec:
  0007f	a3 00 00 00 00	 mov	 DWORD PTR _rebound_head, eax

; 455  : 
; 456  : 	// do not redo it quickly (if we do not close connection it is
; 457  : 	// for a good reason!)
; 458  : 	nodes[node].lasttimepacketreceived = I_GetTime();

  00084	e8 00 00 00 00	 call	 _I_GetTime
  00089	6b 4d 08 50	 imul	 ecx, DWORD PTR _node$[ebp], 80
  0008d	89 81 48 00 00
	00		 mov	 DWORD PTR _nodes[ecx+72], eax

; 459  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_Net_ConnectionTimeout ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _GotAcks
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_GotAcks PROC						; COMDAT

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 423  : 	INT32 i, j;
; 424  : 
; 425  : 	for (j = 0; j < MAXACKTOSEND; j++)

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@GotAcks
$LN2@GotAcks:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@GotAcks:
  0001b	83 7d f8 40	 cmp	 DWORD PTR _j$[ebp], 64	; 00000040H
  0001f	0f 8d f2 00 00
	00		 jge	 $LN3@GotAcks

; 426  : 		if (netbuffer->u.textcmd[j])

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0002a	03 45 f8	 add	 eax, DWORD PTR _j$[ebp]
  0002d	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00031	85 c9		 test	 ecx, ecx
  00033	0f 84 d9 00 00
	00		 je	 $LN6@GotAcks

; 427  : 			for (i = 0; i < MAXACKPACKETS; i++)

  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00040	eb 09		 jmp	 SHORT $LN7@GotAcks
$LN5@GotAcks:
  00042	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@GotAcks:
  0004b	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0004f	0f 8d bd 00 00
	00		 jge	 $LN6@GotAcks

; 428  : 				if (ackpak[i].acknum && ackpak[i].destinationnode == doomcom->remotenode)

  00055	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0005c	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  00063	85 c9		 test	 ecx, ecx
  00065	0f 84 a2 00 00
	00		 je	 $LN12@GotAcks
  0006b	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00072	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax+2]
  00079	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _doomcom
  0007f	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00083	3b c8		 cmp	 ecx, eax
  00085	0f 85 82 00 00
	00		 jne	 $LN12@GotAcks

; 429  : 				{
; 430  : 					if (ackpak[i].acknum == netbuffer->u.textcmd[j])

  0008b	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00092	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  00099	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0009f	03 55 f8	 add	 edx, DWORD PTR _j$[ebp]
  000a2	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  000a6	3b c8		 cmp	 ecx, eax
  000a8	75 0e		 jne	 SHORT $LN10@GotAcks

; 431  : 						Removeack(i);

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _Removeack
  000b3	83 c4 04	 add	 esp, 4
  000b6	eb 55		 jmp	 SHORT $LN12@GotAcks
$LN10@GotAcks:

; 432  : 					else
; 433  : 						// nextacknum is first equal to acknum, then when receiving bigger ack
; 434  : 						// there is big chance the packet is lost
; 435  : 						// when resent, nextacknum = nodes[node].nextacknum
; 436  : 						//    will redo the same but with different value
; 437  : 					if (cmpack(ackpak[i].nextacknum, netbuffer->u.textcmd[j]) <= 0
; 438  : 						&& ackpak[i].senttime > 0)

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  000bd	03 45 f8	 add	 eax, DWORD PTR _j$[ebp]
  000c0	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  000c4	51		 push	 ecx
  000c5	69 55 fc b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  000cc	0f b6 82 01 00
	00 00		 movzx	 eax, BYTE PTR _ackpak[edx+1]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _cmpack
  000d9	83 c4 08	 add	 esp, 8
  000dc	85 c0		 test	 eax, eax
  000de	7f 2d		 jg	 SHORT $LN12@GotAcks
  000e0	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000e7	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _ackpak[eax+4], 0
  000ee	76 1d		 jbe	 SHORT $LN12@GotAcks

; 439  : 					{
; 440  : 						ackpak[i].senttime--; // hurry up

  000f0	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000f7	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR _ackpak[eax+4]
  000fd	83 e9 01	 sub	 ecx, 1
  00100	69 55 fc b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  00107	89 8a 04 00 00
	00		 mov	 DWORD PTR _ackpak[edx+4], ecx
$LN12@GotAcks:

; 441  : 					}
; 442  : 				}

  0010d	e9 30 ff ff ff	 jmp	 $LN5@GotAcks
$LN6@GotAcks:

; 443  : }

  00112	e9 fb fe ff ff	 jmp	 $LN2@GotAcks
$LN3@GotAcks:
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_GotAcks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Processackpak
_TEXT	SEGMENT
_newhead$1 = -21					; size = 1
_change$2 = -20						; size = 4
_hm1$3 = -15						; size = 1
_nextfirstack$4 = -14					; size = 1
_ack$5 = -13						; size = 1
_node$ = -12						; size = 4
_goodpacket$ = -8					; size = 4
_i$ = -4						; size = 4
_Processackpak PROC					; COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 304  : 	INT32 i;
; 305  : 	boolean goodpacket = true;

  00009	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _goodpacket$[ebp], 1

; 306  : 	node_t *node = &nodes[doomcom->remotenode];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00015	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00019	6b d1 50	 imul	 edx, ecx, 80
  0001c	81 c2 00 00 00
	00		 add	 edx, OFFSET _nodes
  00022	89 55 f4	 mov	 DWORD PTR _node$[ebp], edx

; 307  : 
; 308  : 	// received an ack return, so remove the ack in the list
; 309  : 	if (netbuffer->ackreturn && cmpack(node->remotefirstack, netbuffer->ackreturn) < 0)

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0002a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0002e	85 c9		 test	 ecx, ecx
  00030	0f 84 b0 00 00
	00		 je	 $LN3@Processack
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0003b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR _node$[ebp]
  00043	0f b6 42 4c	 movzx	 eax, BYTE PTR [edx+76]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _cmpack
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	0f 8d 8e 00 00
	00		 jge	 $LN3@Processack

; 310  : 	{
; 311  : 		node->remotefirstack = netbuffer->ackreturn;

  00058	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00061	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00064	88 50 4c	 mov	 BYTE PTR [eax+76], dl

; 312  : 		// search the ackbuffer and free it
; 313  : 		for (i = 0; i < MAXACKPACKETS; i++)

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006e	eb 09		 jmp	 SHORT $LN4@Processack
$LN2@Processack:
  00070	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00073	83 c0 01	 add	 eax, 1
  00076	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Processack:
  00079	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0007d	7d 67		 jge	 SHORT $LN3@Processack

; 314  : 			if (ackpak[i].acknum && ackpak[i].destinationnode == node - nodes
; 315  : 				&& cmpack(ackpak[i].acknum, netbuffer->ackreturn) <= 0)

  0007f	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00086	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  0008d	85 c9		 test	 ecx, ecx
  0008f	74 53		 je	 SHORT $LN14@Processack
  00091	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00098	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax+2]
  0009f	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  000a2	2d 00 00 00 00	 sub	 eax, OFFSET _nodes
  000a7	99		 cdq
  000a8	be 50 00 00 00	 mov	 esi, 80			; 00000050H
  000ad	f7 fe		 idiv	 esi
  000af	3b c8		 cmp	 ecx, eax
  000b1	75 31		 jne	 SHORT $LN14@Processack
  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  000b8	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000bc	51		 push	 ecx
  000bd	69 55 fc b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  000c4	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _ackpak[edx]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _cmpack
  000d1	83 c4 08	 add	 esp, 8
  000d4	85 c0		 test	 eax, eax
  000d6	7f 0c		 jg	 SHORT $LN14@Processack

; 316  : 			{
; 317  : 				Removeack(i);

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _Removeack
  000e1	83 c4 04	 add	 esp, 4
$LN14@Processack:

; 318  : 			}

  000e4	eb 8a		 jmp	 SHORT $LN2@Processack
$LN3@Processack:

; 319  : 	}
; 320  : 
; 321  : 	// received a packet with ack, queue it to send the ack back
; 322  : 	if (netbuffer->ack)

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  000eb	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000ef	85 c9		 test	 ecx, ecx
  000f1	0f 84 41 03 00
	00		 je	 $LN34@Processack

; 323  : 	{
; 324  : 		UINT8 ack = netbuffer->ack;

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  000fc	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000ff	88 4d f3	 mov	 BYTE PTR _ack$5[ebp], cl

; 325  : 		getackpacket++;

  00102	a1 00 00 00 00	 mov	 eax, DWORD PTR _getackpacket
  00107	83 c0 01	 add	 eax, 1
  0010a	a3 00 00 00 00	 mov	 DWORD PTR _getackpacket, eax

; 326  : 		if (cmpack(ack, node->firstacktosend) <= 0)

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00112	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00115	51		 push	 ecx
  00116	0f b6 55 f3	 movzx	 edx, BYTE PTR _ack$5[ebp]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 _cmpack
  00120	83 c4 08	 add	 esp, 8
  00123	85 c0		 test	 eax, eax
  00125	7f 51		 jg	 SHORT $LN16@Processack

; 327  : 		{
; 328  : 			DEBFILE(va("Discard(1) ack %d (duplicated)\n", ack));

  00127	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0012e	74 2f		 je	 SHORT $LN18@Processack
  00130	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00135	50		 push	 eax
  00136	0f b6 4d f3	 movzx	 ecx, BYTE PTR _ack$5[ebp]
  0013a	51		 push	 ecx
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KNBBKEDA@Discard?$CI1?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@
  00140	e8 00 00 00 00	 call	 _va
  00145	83 c4 08	 add	 esp, 8
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _fputs
  0014e	83 c4 08	 add	 esp, 8
  00151	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _fflush
  0015c	83 c4 04	 add	 esp, 4
$LN18@Processack:

; 329  : 			duppacket++;

  0015f	a1 00 00 00 00	 mov	 eax, DWORD PTR _duppacket
  00164	83 c0 01	 add	 eax, 1
  00167	a3 00 00 00 00	 mov	 DWORD PTR _duppacket, eax

; 330  : 			goodpacket = false; // discard packet (duplicate)

  0016c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _goodpacket$[ebp], 0

; 331  : 		}

  00173	e9 c0 02 00 00	 jmp	 $LN34@Processack
$LN16@Processack:

; 332  : 		else
; 333  : 		{
; 334  : 			// check if it is not already in the queue
; 335  : 			for (i = node->acktosend_tail; i != node->acktosend_head; i = (i+1) % MAXACKTOSEND)

  00178	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0017b	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0017f	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00182	eb 15		 jmp	 SHORT $LN7@Processack
$LN5@Processack:
  00184	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00187	83 c0 01	 add	 eax, 1
  0018a	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0018f	79 05		 jns	 SHORT $LN37@Processack
  00191	48		 dec	 eax
  00192	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00195	40		 inc	 eax
$LN37@Processack:
  00196	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Processack:
  00199	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0019c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001a0	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  001a3	74 65		 je	 SHORT $LN6@Processack

; 336  : 				if (node->acktosend[i] == ack)

  001a5	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  001a8	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  001ab	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001af	0f b6 55 f3	 movzx	 edx, BYTE PTR _ack$5[ebp]
  001b3	3b ca		 cmp	 ecx, edx
  001b5	75 4e		 jne	 SHORT $LN19@Processack

; 337  : 				{
; 338  : 					DEBFILE(va("Discard(2) ack %d (duplicated)\n", ack));

  001b7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  001be	74 2f		 je	 SHORT $LN20@Processack
  001c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001c5	50		 push	 eax
  001c6	0f b6 4d f3	 movzx	 ecx, BYTE PTR _ack$5[ebp]
  001ca	51		 push	 ecx
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PFAPANBI@Discard?$CI2?$CJ?5ack?5?$CFd?5?$CIduplicated?$CJ?6@
  001d0	e8 00 00 00 00	 call	 _va
  001d5	83 c4 08	 add	 esp, 8
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 _fputs
  001de	83 c4 08	 add	 esp, 8
  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001e6	50		 push	 eax
  001e7	e8 00 00 00 00	 call	 _fflush
  001ec	83 c4 04	 add	 esp, 4
$LN20@Processack:

; 339  : 					duppacket++;

  001ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _duppacket
  001f4	83 c0 01	 add	 eax, 1
  001f7	a3 00 00 00 00	 mov	 DWORD PTR _duppacket, eax

; 340  : 					goodpacket = false; // discard packet (duplicate)

  001fc	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _goodpacket$[ebp], 0

; 341  : 					break;

  00203	eb 05		 jmp	 SHORT $LN6@Processack
$LN19@Processack:

; 342  : 				}

  00205	e9 7a ff ff ff	 jmp	 $LN5@Processack
$LN6@Processack:

; 343  : 			if (goodpacket)

  0020a	83 7d f8 00	 cmp	 DWORD PTR _goodpacket$[ebp], 0
  0020e	0f 84 24 02 00
	00		 je	 $LN34@Processack

; 344  : 			{
; 345  : 				// is a good packet so increment the acknowledge number,
; 346  : 				// then search for a "hole" in the queue
; 347  : 				UINT8 nextfirstack = (UINT8)(node->firstacktosend + 1);

  00214	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00217	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0021a	83 c1 01	 add	 ecx, 1
  0021d	88 4d f2	 mov	 BYTE PTR _nextfirstack$4[ebp], cl

; 348  : 				if (!nextfirstack)

  00220	0f b6 45 f2	 movzx	 eax, BYTE PTR _nextfirstack$4[ebp]
  00224	85 c0		 test	 eax, eax
  00226	75 04		 jne	 SHORT $LN22@Processack

; 349  : 					nextfirstack = 1;

  00228	c6 45 f2 01	 mov	 BYTE PTR _nextfirstack$4[ebp], 1
$LN22@Processack:

; 350  : 
; 351  : 				if (ack == nextfirstack)

  0022c	0f b6 45 f3	 movzx	 eax, BYTE PTR _ack$5[ebp]
  00230	0f b6 4d f2	 movzx	 ecx, BYTE PTR _nextfirstack$4[ebp]
  00234	3b c1		 cmp	 eax, ecx
  00236	0f 85 4e 01 00
	00		 jne	 $LN23@Processack

; 352  : 				{
; 353  : 					UINT8 hm1; // head - 1
; 354  : 					boolean change = true;

  0023c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _change$2[ebp], 1

; 355  : 
; 356  : 					node->firstacktosend = nextfirstack++;

  00243	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00246	8a 4d f2	 mov	 cl, BYTE PTR _nextfirstack$4[ebp]
  00249	88 08		 mov	 BYTE PTR [eax], cl
  0024b	8a 55 f2	 mov	 dl, BYTE PTR _nextfirstack$4[ebp]
  0024e	80 c2 01	 add	 dl, 1
  00251	88 55 f2	 mov	 BYTE PTR _nextfirstack$4[ebp], dl

; 357  : 					if (!nextfirstack)

  00254	0f b6 45 f2	 movzx	 eax, BYTE PTR _nextfirstack$4[ebp]
  00258	85 c0		 test	 eax, eax
  0025a	75 04		 jne	 SHORT $LN25@Processack

; 358  : 						nextfirstack = 1;

  0025c	c6 45 f2 01	 mov	 BYTE PTR _nextfirstack$4[ebp], 1
$LN25@Processack:

; 359  : 					hm1 = (UINT8)((node->acktosend_head-1+MAXACKTOSEND) % MAXACKTOSEND);

  00260	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00263	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00267	83 c1 3f	 add	 ecx, 63			; 0000003fH
  0026a	81 e1 3f 00 00
	80		 and	 ecx, -2147483585	; 8000003fH
  00270	79 05		 jns	 SHORT $LN38@Processack
  00272	49		 dec	 ecx
  00273	83 c9 c0	 or	 ecx, -64		; ffffffc0H
  00276	41		 inc	 ecx
$LN38@Processack:
  00277	88 4d f1	 mov	 BYTE PTR _hm1$3[ebp], cl
$LN8@Processack:

; 360  : 					while (change)

  0027a	83 7d ec 00	 cmp	 DWORD PTR _change$2[ebp], 0
  0027e	0f 84 01 01 00
	00		 je	 $LN9@Processack

; 361  : 					{
; 362  : 						change = false;

  00284	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _change$2[ebp], 0

; 363  : 						for (i = node->acktosend_tail; i != node->acktosend_head;

  0028b	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0028e	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00292	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00295	eb 15		 jmp	 SHORT $LN12@Processack
$LN10@Processack:

; 364  : 							i = (i+1) % MAXACKTOSEND)

  00297	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0029a	83 c0 01	 add	 eax, 1
  0029d	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  002a2	79 05		 jns	 SHORT $LN39@Processack
  002a4	48		 dec	 eax
  002a5	83 c8 c0	 or	 eax, -64		; ffffffc0H
  002a8	40		 inc	 eax
$LN39@Processack:
  002a9	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN12@Processack:

; 363  : 						for (i = node->acktosend_tail; i != node->acktosend_head;

  002ac	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  002af	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002b3	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  002b6	0f 84 c4 00 00
	00		 je	 $LN11@Processack

; 365  : 						{
; 366  : 							if (cmpack(node->acktosend[i], nextfirstack) <= 0)

  002bc	0f b6 45 f2	 movzx	 eax, BYTE PTR _nextfirstack$4[ebp]
  002c0	50		 push	 eax
  002c1	8b 4d f4	 mov	 ecx, DWORD PTR _node$[ebp]
  002c4	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  002c7	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  002cb	52		 push	 edx
  002cc	e8 00 00 00 00	 call	 _cmpack
  002d1	83 c4 08	 add	 esp, 8
  002d4	85 c0		 test	 eax, eax
  002d6	0f 8f 9f 00 00
	00		 jg	 $LN31@Processack

; 367  : 							{
; 368  : 								if (node->acktosend[i] == nextfirstack)

  002dc	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  002df	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  002e2	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002e6	0f b6 55 f2	 movzx	 edx, BYTE PTR _nextfirstack$4[ebp]
  002ea	3b ca		 cmp	 ecx, edx
  002ec	75 24		 jne	 SHORT $LN27@Processack

; 369  : 								{
; 370  : 									node->firstacktosend = nextfirstack++;

  002ee	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  002f1	8a 4d f2	 mov	 cl, BYTE PTR _nextfirstack$4[ebp]
  002f4	88 08		 mov	 BYTE PTR [eax], cl
  002f6	8a 55 f2	 mov	 dl, BYTE PTR _nextfirstack$4[ebp]
  002f9	80 c2 01	 add	 dl, 1
  002fc	88 55 f2	 mov	 BYTE PTR _nextfirstack$4[ebp], dl

; 371  : 									if (!nextfirstack)

  002ff	0f b6 45 f2	 movzx	 eax, BYTE PTR _nextfirstack$4[ebp]
  00303	85 c0		 test	 eax, eax
  00305	75 04		 jne	 SHORT $LN28@Processack

; 372  : 										nextfirstack = 1;

  00307	c6 45 f2 01	 mov	 BYTE PTR _nextfirstack$4[ebp], 1
$LN28@Processack:

; 373  : 									change = true;

  0030b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _change$2[ebp], 1
$LN27@Processack:

; 374  : 								}
; 375  : 								if (i == node->acktosend_tail)

  00312	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00315	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00319	39 4d fc	 cmp	 DWORD PTR _i$[ebp], ecx
  0031c	75 29		 jne	 SHORT $LN29@Processack

; 376  : 								{
; 377  : 									node->acktosend[node->acktosend_tail] = 0;

  0031e	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00321	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00325	8b 55 f4	 mov	 edx, DWORD PTR _node$[ebp]
  00328	c6 44 0a 03 00	 mov	 BYTE PTR [edx+ecx+3], 0

; 378  : 									node->acktosend_tail = (UINT8)((i+1) % MAXACKTOSEND);

  0032d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00330	83 c0 01	 add	 eax, 1
  00333	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00338	79 05		 jns	 SHORT $LN40@Processack
  0033a	48		 dec	 eax
  0033b	83 c8 c0	 or	 eax, -64		; ffffffc0H
  0033e	40		 inc	 eax
$LN40@Processack:
  0033f	8b 4d f4	 mov	 ecx, DWORD PTR _node$[ebp]
  00342	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 379  : 								}

  00345	eb 34		 jmp	 SHORT $LN31@Processack
$LN29@Processack:

; 380  : 								else if (i == hm1)

  00347	0f b6 45 f1	 movzx	 eax, BYTE PTR _hm1$3[ebp]
  0034b	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  0034e	75 2b		 jne	 SHORT $LN31@Processack

; 381  : 								{
; 382  : 									node->acktosend[hm1] = 0;

  00350	0f b6 45 f1	 movzx	 eax, BYTE PTR _hm1$3[ebp]
  00354	8b 4d f4	 mov	 ecx, DWORD PTR _node$[ebp]
  00357	c6 44 01 03 00	 mov	 BYTE PTR [ecx+eax+3], 0

; 383  : 									node->acktosend_head = hm1;

  0035c	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0035f	8a 4d f1	 mov	 cl, BYTE PTR _hm1$3[ebp]
  00362	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 384  : 									hm1 = (UINT8)((hm1-1+MAXACKTOSEND) % MAXACKTOSEND);

  00365	0f b6 45 f1	 movzx	 eax, BYTE PTR _hm1$3[ebp]
  00369	83 c0 3f	 add	 eax, 63			; 0000003fH
  0036c	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00371	79 05		 jns	 SHORT $LN41@Processack
  00373	48		 dec	 eax
  00374	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00377	40		 inc	 eax
$LN41@Processack:
  00378	88 45 f1	 mov	 BYTE PTR _hm1$3[ebp], al
$LN31@Processack:

; 385  : 								}
; 386  : 							}
; 387  : 						}

  0037b	e9 17 ff ff ff	 jmp	 $LN10@Processack
$LN11@Processack:

; 388  : 					}

  00380	e9 f5 fe ff ff	 jmp	 $LN8@Processack
$LN9@Processack:

; 389  : 				}

  00385	e9 ae 00 00 00	 jmp	 $LN34@Processack
$LN23@Processack:

; 390  : 				else // out of order packet
; 391  : 				{
; 392  : 					// don't increment firsacktosend, put it in asktosend queue
; 393  : 					// will be incremented when the nextfirstack comes (code above)
; 394  : 					UINT8 newhead = (UINT8)((node->acktosend_head+1) % MAXACKTOSEND);

  0038a	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0038d	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00391	83 c1 01	 add	 ecx, 1
  00394	81 e1 3f 00 00
	80		 and	 ecx, -2147483585	; 8000003fH
  0039a	79 05		 jns	 SHORT $LN42@Processack
  0039c	49		 dec	 ecx
  0039d	83 c9 c0	 or	 ecx, -64		; ffffffc0H
  003a0	41		 inc	 ecx
$LN42@Processack:
  003a1	88 4d eb	 mov	 BYTE PTR _newhead$1[ebp], cl

; 395  : 					DEBFILE(va("out of order packet (%d expected)\n", nextfirstack));

  003a4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  003ab	74 2f		 je	 SHORT $LN32@Processack
  003ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  003b2	50		 push	 eax
  003b3	0f b6 4d f2	 movzx	 ecx, BYTE PTR _nextfirstack$4[ebp]
  003b7	51		 push	 ecx
  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NOHOOIMJ@out?5of?5order?5packet?5?$CI?$CFd?5expecte@
  003bd	e8 00 00 00 00	 call	 _va
  003c2	83 c4 08	 add	 esp, 8
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 _fputs
  003cb	83 c4 08	 add	 esp, 8
  003ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  003d3	50		 push	 eax
  003d4	e8 00 00 00 00	 call	 _fflush
  003d9	83 c4 04	 add	 esp, 4
$LN32@Processack:

; 396  : 					if (newhead != node->acktosend_tail)

  003dc	0f b6 45 eb	 movzx	 eax, BYTE PTR _newhead$1[ebp]
  003e0	8b 4d f4	 mov	 ecx, DWORD PTR _node$[ebp]
  003e3	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  003e7	3b c2		 cmp	 eax, edx
  003e9	74 1c		 je	 SHORT $LN33@Processack

; 397  : 					{
; 398  : 						node->acktosend[node->acktosend_head] = ack;

  003eb	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  003ee	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  003f2	8b 55 f4	 mov	 edx, DWORD PTR _node$[ebp]
  003f5	8a 45 f3	 mov	 al, BYTE PTR _ack$5[ebp]
  003f8	88 44 0a 03	 mov	 BYTE PTR [edx+ecx+3], al

; 399  : 						node->acktosend_head = newhead;

  003fc	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  003ff	8a 4d eb	 mov	 cl, BYTE PTR _newhead$1[ebp]
  00402	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 400  : 					}

  00405	eb 31		 jmp	 SHORT $LN34@Processack
$LN33@Processack:

; 401  : 					else // buffer full discard packet, sender will resend it
; 402  : 					{ // we can admit the packet but we will not detect the duplication after :(
; 403  : 						DEBFILE("no more freeackret\n");

  00407	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0040e	74 21		 je	 SHORT $LN35@Processack
  00410	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00415	50		 push	 eax
  00416	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NCGDAILO@no?5more?5freeackret?6@
  0041b	e8 00 00 00 00	 call	 _fputs
  00420	83 c4 08	 add	 esp, 8
  00423	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00428	50		 push	 eax
  00429	e8 00 00 00 00	 call	 _fflush
  0042e	83 c4 04	 add	 esp, 4
$LN35@Processack:

; 404  : 						goodpacket = false;

  00431	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _goodpacket$[ebp], 0
$LN34@Processack:

; 405  : 					}
; 406  : 				}
; 407  : 			}
; 408  : 		}
; 409  : 	}
; 410  : 	return goodpacket;

  00438	8b 45 f8	 mov	 eax, DWORD PTR _goodpacket$[ebp]

; 411  : }

  0043b	5f		 pop	 edi
  0043c	5e		 pop	 esi
  0043d	5b		 pop	 ebx
  0043e	8b e5		 mov	 esp, ebp
  00440	5d		 pop	 ebp
  00441	c3		 ret	 0
_Processackpak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Removeack
_TEXT	SEGMENT
_node$ = -4						; size = 4
_i$ = 8							; size = 4
_Removeack PROC						; COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 282  : 	INT32 node = ackpak[i].destinationnode;

  00009	69 45 08 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00010	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax+2]
  00017	89 4d fc	 mov	 DWORD PTR _node$[ebp], ecx

; 283  : #ifndef NEWPING
; 284  : 	fixed_t trueping = (I_GetTime() - ackpak[i].senttime)<<FRACBITS;
; 285  : 	if (ackpak[i].resentnum)
; 286  : 	{
; 287  : 		// +FRACUNIT/2 for round
; 288  : 		nodes[node].ping = (nodes[node].ping*7 + trueping)/8;
; 289  : 		nodes[node].varping = (nodes[node].varping*7 + abs(nodes[node].ping-trueping))/8;
; 290  : 		nodes[node].timeout = TIMEOUT(nodes[node].ping,nodes[node].varping);
; 291  : 	}
; 292  : 	DEBFILE(va("Remove ack %d trueping %d ping %f var %f timeout %d\n",ackpak[i].acknum,trueping>>FRACBITS,(double)FIXED_TO_FLOAT(nodes[node].ping),(double)FIXED_TO_FLOAT(nodes[node].varping),nodes[node].timeout));
; 293  : #else
; 294  : 	DEBFILE(va("Remove ack %d\n",ackpak[i].acknum));

  0001a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00021	74 39		 je	 SHORT $LN2@Removeack
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00028	50		 push	 eax
  00029	69 4d 08 b8 05
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 1464
  00030	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _ackpak[ecx]
  00037	52		 push	 edx
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JBMMCGDL@Remove?5ack?5?$CFd?6@
  0003d	e8 00 00 00 00	 call	 _va
  00042	83 c4 08	 add	 esp, 8
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _fputs
  0004b	83 c4 08	 add	 esp, 8
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _fflush
  00059	83 c4 04	 add	 esp, 4
$LN2@Removeack:

; 295  : #endif
; 296  : 	ackpak[i].acknum = 0;

  0005c	69 45 08 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00063	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _ackpak[eax], 0

; 297  : 	if (nodes[node].flags & CLOSE)

  0006a	6b 45 fc 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0006e	0f b6 88 4e 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax+78]
  00075	83 e1 01	 and	 ecx, 1
  00078	74 0c		 je	 SHORT $LN3@Removeack

; 298  : 		Net_CloseConnection(node);

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _Net_CloseConnection
  00083	83 c4 04	 add	 esp, 4
$LN3@Removeack:

; 299  : }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_Removeack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _GetAcktosend
_TEXT	SEGMENT
_node$ = 8						; size = 4
_GetAcktosend PROC					; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 276  : 	nodes[node].lasttimeacktosend_sent = I_GetTime();

  00009	e8 00 00 00 00	 call	 _I_GetTime
  0000e	6b 4d 08 50	 imul	 ecx, DWORD PTR _node$[ebp], 80
  00012	89 81 44 00 00
	00		 mov	 DWORD PTR _nodes[ecx+68], eax

; 277  : 	return nodes[node].firstacktosend;

  00018	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0001c	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _nodes[eax]

; 278  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_GetAcktosend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _GetFreeAcknum
_TEXT	SEGMENT
_numfreeslote$ = -12					; size = 4
_i$ = -8						; size = 4
_node$ = -4						; size = 4
_freeack$ = 8						; size = 4
_lowtimer$ = 12						; size = 4
_GetFreeAcknum PROC					; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 221  : 	node_t *node = &nodes[doomcom->remotenode];

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0000e	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00012	6b d1 50	 imul	 edx, ecx, 80
  00015	81 c2 00 00 00
	00		 add	 edx, OFFSET _nodes
  0001b	89 55 fc	 mov	 DWORD PTR _node$[ebp], edx

; 222  : 	INT32 i, numfreeslote = 0;

  0001e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _numfreeslote$[ebp], 0

; 223  : 
; 224  : 	if (cmpack((UINT8)((node->remotefirstack + MAXACKTOSEND) % 256), node->nextacknum) < 0)

  00025	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00028	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  0002c	51		 push	 ecx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  00030	0f b6 42 4c	 movzx	 eax, BYTE PTR [edx+76]
  00034	83 c0 40	 add	 eax, 64			; 00000040H
  00037	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  0003c	79 07		 jns	 SHORT $LN14@GetFreeAck
  0003e	48		 dec	 eax
  0003f	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00044	40		 inc	 eax
$LN14@GetFreeAck:
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _cmpack
  0004b	83 c4 08	 add	 esp, 8
  0004e	85 c0		 test	 eax, eax
  00050	7d 4a		 jge	 SHORT $LN5@GetFreeAck

; 225  : 	{
; 226  : 		DEBFILE(va("too fast %d %d\n",node->remotefirstack,node->nextacknum));

  00052	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00059	74 3a		 je	 SHORT $LN6@GetFreeAck
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  00064	0f b6 51 4d	 movzx	 edx, BYTE PTR [ecx+77]
  00068	52		 push	 edx
  00069	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0006c	0f b6 48 4c	 movzx	 ecx, BYTE PTR [eax+76]
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFBMFDGN@too?5fast?5?$CFd?5?$CFd?6@
  00076	e8 00 00 00 00	 call	 _va
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _fputs
  00084	83 c4 08	 add	 esp, 8
  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _fflush
  00092	83 c4 04	 add	 esp, 4
$LN6@GetFreeAck:

; 227  : 		return false;

  00095	33 c0		 xor	 eax, eax
  00097	e9 97 01 00 00	 jmp	 $LN1@GetFreeAck
$LN5@GetFreeAck:

; 228  : 	}
; 229  : 
; 230  : 	for (i = 0; i < MAXACKPACKETS; i++)

  0009c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a3	eb 09		 jmp	 SHORT $LN4@GetFreeAck
$LN2@GetFreeAck:
  000a5	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetFreeAck:
  000ae	83 7d f8 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  000b2	0f 8d 5e 01 00
	00		 jge	 $LN3@GetFreeAck

; 231  : 		if (!ackpak[i].acknum)

  000b8	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000bf	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  000c6	85 c9		 test	 ecx, ecx
  000c8	0f 85 43 01 00
	00		 jne	 $LN7@GetFreeAck

; 232  : 		{
; 233  : 			// for low priority packet, make sure let freeslotes so urgents packets can be sent
; 234  : 			numfreeslote++;

  000ce	8b 45 f4	 mov	 eax, DWORD PTR _numfreeslote$[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 f4	 mov	 DWORD PTR _numfreeslote$[ebp], eax

; 235  : 			if (netbuffer->packettype >= PT_CANFAIL && numfreeslote < URGENTFREESLOTENUM)

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  000dc	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  000e0	83 f9 11	 cmp	 ecx, 17			; 00000011H
  000e3	7c 08		 jl	 SHORT $LN8@GetFreeAck
  000e5	83 7d f4 06	 cmp	 DWORD PTR _numfreeslote$[ebp], 6
  000e9	7d 02		 jge	 SHORT $LN8@GetFreeAck

; 236  : 				continue;

  000eb	eb b8		 jmp	 SHORT $LN2@GetFreeAck
$LN8@GetFreeAck:

; 237  : 
; 238  : 			ackpak[i].acknum = node->nextacknum;

  000ed	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  000f7	8a 51 4d	 mov	 dl, BYTE PTR [ecx+77]
  000fa	88 90 00 00 00
	00		 mov	 BYTE PTR _ackpak[eax], dl

; 239  : 			ackpak[i].nextacknum = node->nextacknum;

  00100	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  0010a	8a 51 4d	 mov	 dl, BYTE PTR [ecx+77]
  0010d	88 90 01 00 00
	00		 mov	 BYTE PTR _ackpak[eax+1], dl

; 240  : 			node->nextacknum++;

  00113	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00116	8a 48 4d	 mov	 cl, BYTE PTR [eax+77]
  00119	80 c1 01	 add	 cl, 1
  0011c	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  0011f	88 4a 4d	 mov	 BYTE PTR [edx+77], cl

; 241  : 			if (!node->nextacknum)

  00122	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00125	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  00129	85 c9		 test	 ecx, ecx
  0012b	75 0f		 jne	 SHORT $LN9@GetFreeAck

; 242  : 				node->nextacknum++;

  0012d	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00130	8a 48 4d	 mov	 cl, BYTE PTR [eax+77]
  00133	80 c1 01	 add	 cl, 1
  00136	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  00139	88 4a 4d	 mov	 BYTE PTR [edx+77], cl
$LN9@GetFreeAck:

; 243  : 			ackpak[i].destinationnode = (UINT8)(node - nodes);

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0013f	2d 00 00 00 00	 sub	 eax, OFFSET _nodes
  00144	99		 cdq
  00145	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0014a	f7 f9		 idiv	 ecx
  0014c	69 55 f8 b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  00153	88 82 02 00 00
	00		 mov	 BYTE PTR _ackpak[edx+2], al

; 244  : 			ackpak[i].length = doomcom->datalength;

  00159	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00166	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  0016a	66 89 90 08 00
	00 00		 mov	 WORD PTR _ackpak[eax+8], dx

; 245  : 			if (lowtimer)

  00171	83 7d 0c 00	 cmp	 DWORD PTR _lowtimer$[ebp], 0
  00175	74 26		 je	 SHORT $LN10@GetFreeAck

; 246  : 			{
; 247  : 				// lowtime mean can't be sent now so try it soon as possible
; 248  : 				ackpak[i].senttime = 0;

  00177	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0017e	c7 80 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ackpak[eax+4], 0

; 249  : 				ackpak[i].resentnum = 1;

  00188	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0018f	b9 01 00 00 00	 mov	 ecx, 1
  00194	66 89 88 0a 00
	00 00		 mov	 WORD PTR _ackpak[eax+10], cx

; 250  : 			}

  0019b	eb 22		 jmp	 SHORT $LN11@GetFreeAck
$LN10@GetFreeAck:

; 251  : 			else
; 252  : 			{
; 253  : 				ackpak[i].senttime = I_GetTime();

  0019d	e8 00 00 00 00	 call	 _I_GetTime
  001a2	69 4d f8 b8 05
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 1464
  001a9	89 81 04 00 00
	00		 mov	 DWORD PTR _ackpak[ecx+4], eax

; 254  : 				ackpak[i].resentnum = 0;

  001af	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  001b6	33 c9		 xor	 ecx, ecx
  001b8	66 89 88 0a 00
	00 00		 mov	 WORD PTR _ackpak[eax+10], cx
$LN11@GetFreeAck:

; 255  : 			}
; 256  : 			M_Memcpy(ackpak[i].pak.raw, netbuffer, ackpak[i].length);

  001bf	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  001c6	0f b7 88 08 00
	00 00		 movzx	 ecx, WORD PTR _ackpak[eax+8]
  001cd	51		 push	 ecx
  001ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  001d4	52		 push	 edx
  001d5	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  001dc	05 0c 00 00 00	 add	 eax, OFFSET _ackpak+12
  001e1	50		 push	 eax
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 257  : 
; 258  : 			*freeack = ackpak[i].acknum;

  001eb	69 45 f8 b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  001f2	8b 4d 08	 mov	 ecx, DWORD PTR _freeack$[ebp]
  001f5	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _ackpak[eax]
  001fb	88 11		 mov	 BYTE PTR [ecx], dl

; 259  : 
; 260  : 			sendackpacket++; // for stat

  001fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _sendackpacket
  00202	83 c0 01	 add	 eax, 1
  00205	a3 00 00 00 00	 mov	 DWORD PTR _sendackpacket, eax

; 261  : 
; 262  : 			return true;

  0020a	b8 01 00 00 00	 mov	 eax, 1
  0020f	eb 22		 jmp	 SHORT $LN1@GetFreeAck
$LN7@GetFreeAck:

; 263  : 		}

  00211	e9 8f fe ff ff	 jmp	 $LN2@GetFreeAck
$LN3@GetFreeAck:

; 264  : #ifdef PARANOIA
; 265  : 	if (devparm)
; 266  : 		I_OutputMsg("No more free ackpacket\n");
; 267  : #endif
; 268  : 	if (netbuffer->packettype < PT_CANFAIL)

  00216	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0021b	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0021f	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00222	7d 0d		 jge	 SHORT $LN12@GetFreeAck

; 269  : 		I_Error("Connection lost\n");

  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HFLKEJGH@Connection?5lost?6@
  00229	e8 00 00 00 00	 call	 _I_Error
  0022e	83 c4 04	 add	 esp, 4
$LN12@GetFreeAck:

; 270  : 	return false;

  00231	33 c0		 xor	 eax, eax
$LN1@GetFreeAck:

; 271  : }

  00233	5f		 pop	 edi
  00234	5e		 pop	 esi
  00235	5b		 pop	 ebx
  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c3		 ret	 0
_GetFreeAcknum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _cmpack
_TEXT	SEGMENT
_d$ = -4						; size = 4
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_cmpack	PROC						; COMDAT

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 211  : 	register INT32 d = a - b;

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0000d	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _b$[ebp]
  00011	2b c1		 sub	 eax, ecx
  00013	89 45 fc	 mov	 DWORD PTR _d$[ebp], eax

; 212  : 
; 213  : 	if (d >= 127 || d < -128)

  00016	83 7d fc 7f	 cmp	 DWORD PTR _d$[ebp], 127	; 0000007fH
  0001a	7d 06		 jge	 SHORT $LN3@cmpack
  0001c	83 7d fc 80	 cmp	 DWORD PTR _d$[ebp], -128 ; ffffff80H
  00020	7d 07		 jge	 SHORT $LN2@cmpack
$LN3@cmpack:

; 214  : 		return -d;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
  00025	f7 d8		 neg	 eax
  00027	eb 03		 jmp	 SHORT $LN1@cmpack
$LN2@cmpack:

; 215  : 	return d;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _d$[ebp]
$LN1@cmpack:

; 216  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_cmpack	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_WaitAllAckReceived
_TEXT	SEGMENT
_tictac$ = -4						; size = 4
_timeout$ = 8						; size = 4
_Net_WaitAllAckReceived PROC				; COMDAT

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 572  : 	tic_t tictac = I_GetTime();

  00009	e8 00 00 00 00	 call	 _I_GetTime
  0000e	89 45 fc	 mov	 DWORD PTR _tictac$[ebp], eax

; 573  : 	timeout = tictac + timeout*TICRATE;

  00011	6b 45 08 23	 imul	 eax, DWORD PTR _timeout$[ebp], 35
  00015	03 45 fc	 add	 eax, DWORD PTR _tictac$[ebp]
  00018	89 45 08	 mov	 DWORD PTR _timeout$[ebp], eax

; 574  : 
; 575  : 	HGetPacket();

  0001b	e8 00 00 00 00	 call	 _HGetPacket
  00020	90		 npad	 1
$LN2@Net_WaitAl:

; 576  : 	while (timeout > I_GetTime() && !Net_AllAckReceived())

  00021	e8 00 00 00 00	 call	 _I_GetTime
  00026	39 45 08	 cmp	 DWORD PTR _timeout$[ebp], eax
  00029	76 31		 jbe	 SHORT $LN3@Net_WaitAl
  0002b	e8 00 00 00 00	 call	 _Net_AllAckReceived
  00030	85 c0		 test	 eax, eax
  00032	75 28		 jne	 SHORT $LN3@Net_WaitAl
$LN4@Net_WaitAl:

; 577  : 	{
; 578  : 		while (tictac == I_GetTime())

  00034	e8 00 00 00 00	 call	 _I_GetTime
  00039	39 45 fc	 cmp	 DWORD PTR _tictac$[ebp], eax
  0003c	75 08		 jne	 SHORT $LN5@Net_WaitAl

; 579  : 			I_Sleep();

  0003e	e8 00 00 00 00	 call	 _I_Sleep
  00043	90		 npad	 1
  00044	eb ee		 jmp	 SHORT $LN4@Net_WaitAl
$LN5@Net_WaitAl:

; 580  : 		tictac = I_GetTime();

  00046	e8 00 00 00 00	 call	 _I_GetTime
  0004b	89 45 fc	 mov	 DWORD PTR _tictac$[ebp], eax

; 581  : 		HGetPacket();

  0004e	e8 00 00 00 00	 call	 _HGetPacket
  00053	90		 npad	 1

; 582  : 		Net_AckTicker();

  00054	e8 00 00 00 00	 call	 _Net_AckTicker
  00059	90		 npad	 1

; 583  : 	}

  0005a	eb c5		 jmp	 SHORT $LN2@Net_WaitAl
$LN3@Net_WaitAl:

; 584  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_Net_WaitAllAckReceived ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_SendAcks
_TEXT	SEGMENT
_node$ = 8						; size = 4
_Net_SendAcks PROC					; COMDAT

; 415  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 416  : 	netbuffer->packettype = PT_NOTHING;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0000e	c6 40 06 00	 mov	 BYTE PTR [eax+6], 0

; 417  : 	M_Memcpy(netbuffer->u.textcmd, nodes[node].acktosend, MAXACKTOSEND);

  00012	6a 40		 push	 64			; 00000040H
  00014	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00018	05 03 00 00 00	 add	 eax, OFFSET _nodes+3
  0001d	50		 push	 eax
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00024	83 c1 08	 add	 ecx, 8
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 418  : 	HSendPacket(node, false, 0, MAXACKTOSEND);

  00031	6a 40		 push	 64			; 00000040H
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _HSendPacket
  00040	83 c4 10	 add	 esp, 16			; 00000010H

; 419  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_Net_SendAcks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_AbortPacketType
_TEXT	SEGMENT
_i$ = -4						; size = 4
_packettype$ = 8					; size = 1
_Net_AbortPacketType PROC				; COMDAT

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 613  : 	INT32 i;
; 614  : 	for (i = 0; i < MAXACKPACKETS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Net_AbortP
$LN2@Net_AbortP:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Net_AbortP:
  0001b	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0001f	7d 43		 jge	 SHORT $LN3@Net_AbortP

; 615  : 		if (ackpak[i].acknum && (ackpak[i].pak.data.packettype == packettype

  00021	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00028	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 2f		 je	 SHORT $LN5@Net_AbortP
  00033	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0003a	0f b6 88 12 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax+18]
  00041	0f b6 55 08	 movzx	 edx, BYTE PTR _packettype$[ebp]
  00045	3b ca		 cmp	 ecx, edx
  00047	74 0b		 je	 SHORT $LN6@Net_AbortP
  00049	0f b6 45 08	 movzx	 eax, BYTE PTR _packettype$[ebp]
  0004d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00052	75 0e		 jne	 SHORT $LN5@Net_AbortP
$LN6@Net_AbortP:

; 616  : 			|| packettype == UINT8_MAX))
; 617  : 		{
; 618  : 			ackpak[i].acknum = 0;

  00054	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0005b	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _ackpak[eax], 0
$LN5@Net_AbortP:

; 619  : 		}

  00062	eb ae		 jmp	 SHORT $LN2@Net_AbortP
$LN3@Net_AbortP:

; 620  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_Net_AbortPacketType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_CloseConnection
_TEXT	SEGMENT
tv66 = -76						; size = 4
_forceclose$ = -8					; size = 4
_i$ = -4						; size = 4
_node$ = 8						; size = 4
_Net_CloseConnection PROC				; COMDAT

; 628  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 629  : 	INT32 i;
; 630  : 	boolean forceclose = (node & FORCECLOSE) != 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0000c	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00011	74 09		 je	 SHORT $LN11@Net_CloseC
  00013	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN12@Net_CloseC
$LN11@Net_CloseC:
  0001c	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN12@Net_CloseC:
  00023	8b 4d b4	 mov	 ecx, DWORD PTR tv66[ebp]
  00026	89 4d f8	 mov	 DWORD PTR _forceclose$[ebp], ecx

; 631  : 	node &= ~FORCECLOSE;

  00029	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0002c	25 ff 7f ff ff	 and	 eax, -32769		; ffff7fffH
  00031	89 45 08	 mov	 DWORD PTR _node$[ebp], eax

; 632  : 
; 633  : 	if (!node)

  00034	75 05		 jne	 SHORT $LN5@Net_CloseC

; 634  : 		return;

  00036	e9 bf 00 00 00	 jmp	 $LN1@Net_CloseC
$LN5@Net_CloseC:

; 635  : 
; 636  : 	nodes[node].flags |= CLOSE;

  0003b	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0003f	0f b6 88 4e 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax+78]
  00046	83 c9 01	 or	 ecx, 1
  00049	6b 55 08 50	 imul	 edx, DWORD PTR _node$[ebp], 80
  0004d	88 8a 4e 00 00
	00		 mov	 BYTE PTR _nodes[edx+78], cl

; 637  : 
; 638  : 	// try to Send ack back (two army problem)
; 639  : 	if (GetAcktosend(node))

  00053	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _GetAcktosend
  0005c	83 c4 04	 add	 esp, 4
  0005f	0f b6 c8	 movzx	 ecx, al
  00062	85 c9		 test	 ecx, ecx
  00064	74 18		 je	 SHORT $LN6@Net_CloseC

; 640  : 	{
; 641  : 		Net_SendAcks(node);

  00066	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _Net_SendAcks
  0006f	83 c4 04	 add	 esp, 4

; 642  : 		Net_SendAcks(node);

  00072	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _Net_SendAcks
  0007b	83 c4 04	 add	 esp, 4
$LN6@Net_CloseC:

; 643  : 	}
; 644  : 
; 645  : 	// check if we are waiting for an ack from this node
; 646  : 	for (i = 0; i < MAXACKPACKETS; i++)

  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00085	eb 09		 jmp	 SHORT $LN4@Net_CloseC
$LN2@Net_CloseC:
  00087	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Net_CloseC:
  00090	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00094	7d 3f		 jge	 SHORT $LN3@Net_CloseC

; 647  : 		if (ackpak[i].acknum && ackpak[i].destinationnode == node)

  00096	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0009d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  000a4	85 c9		 test	 ecx, ecx
  000a6	74 2b		 je	 SHORT $LN9@Net_CloseC
  000a8	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000af	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax+2]
  000b6	3b 4d 08	 cmp	 ecx, DWORD PTR _node$[ebp]
  000b9	75 18		 jne	 SHORT $LN9@Net_CloseC

; 648  : 		{
; 649  : 			if (!forceclose)

  000bb	83 7d f8 00	 cmp	 DWORD PTR _forceclose$[ebp], 0
  000bf	75 04		 jne	 SHORT $LN8@Net_CloseC

; 650  : 				return; // connection will be closed when ack is returned

  000c1	eb 37		 jmp	 SHORT $LN1@Net_CloseC
  000c3	eb 0e		 jmp	 SHORT $LN9@Net_CloseC
$LN8@Net_CloseC:

; 651  : 			else
; 652  : 				ackpak[i].acknum = 0;

  000c5	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000cc	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _ackpak[eax], 0
$LN9@Net_CloseC:

; 653  : 		}

  000d3	eb b2		 jmp	 SHORT $LN2@Net_CloseC
$LN3@Net_CloseC:

; 654  : 
; 655  : 	InitNode(node);

  000d5	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _InitNode
  000de	83 c4 04	 add	 esp, 4

; 656  : 	AbortSendFiles(node);

  000e1	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _AbortSendFiles
  000ea	83 c4 04	 add	 esp, 4

; 657  : 	I_NetFreeNodenum(node);

  000ed	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  000f0	50		 push	 eax
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetFreeNodenum
  000f7	83 c4 04	 add	 esp, 4
$LN1@Net_CloseC:

; 658  : }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
_Net_CloseConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_UnAcknowledgPacket
_TEXT	SEGMENT
_hm1$ = -4						; size = 4
_node$ = 8						; size = 4
_Net_UnAcknowledgPacket PROC				; COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 525  : 	INT32 hm1 = (nodes[node].acktosend_head-1+MAXACKTOSEND) % MAXACKTOSEND;

  00009	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0000d	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax+1]
  00014	83 c1 3f	 add	 ecx, 63			; 0000003fH
  00017	81 e1 3f 00 00
	80		 and	 ecx, -2147483585	; 8000003fH
  0001d	79 05		 jns	 SHORT $LN14@Net_UnAckn
  0001f	49		 dec	 ecx
  00020	83 c9 c0	 or	 ecx, -64		; ffffffc0H
  00023	41		 inc	 ecx
$LN14@Net_UnAckn:
  00024	89 4d fc	 mov	 DWORD PTR _hm1$[ebp], ecx

; 526  : 	DEBFILE(va("UnAcknowledge node %d\n", node));

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0002e	74 2e		 je	 SHORT $LN4@Net_UnAckn
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _node$[ebp]
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HCAFKBCE@UnAcknowledge?5node?5?$CFd?6@
  0003f	e8 00 00 00 00	 call	 _va
  00044	83 c4 08	 add	 esp, 8
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _fputs
  0004d	83 c4 08	 add	 esp, 8
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _fflush
  0005b	83 c4 04	 add	 esp, 4
$LN4@Net_UnAckn:

; 527  : 	if (!node)

  0005e	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  00062	75 05		 jne	 SHORT $LN5@Net_UnAckn

; 528  : 		return;

  00064	e9 51 01 00 00	 jmp	 $LN12@Net_UnAckn
$LN5@Net_UnAckn:

; 529  : 	if (nodes[node].acktosend[hm1] == netbuffer->ack)

  00069	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _hm1$[ebp]
  00070	0f b6 94 08 03
	00 00 00	 movzx	 edx, BYTE PTR _nodes[eax+ecx+3]
  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0007d	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00081	3b d1		 cmp	 edx, ecx
  00083	75 21		 jne	 SHORT $LN6@Net_UnAckn

; 530  : 	{
; 531  : 		nodes[node].acktosend[hm1] = 0;

  00085	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _hm1$[ebp]
  0008c	c6 84 08 03 00
	00 00 00	 mov	 BYTE PTR _nodes[eax+ecx+3], 0

; 532  : 		nodes[node].acktosend_head = (UINT8)hm1;

  00094	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00098	8a 4d fc	 mov	 cl, BYTE PTR _hm1$[ebp]
  0009b	88 88 01 00 00
	00		 mov	 BYTE PTR _nodes[eax+1], cl

; 533  : 	}

  000a1	e9 14 01 00 00	 jmp	 $LN12@Net_UnAckn
$LN6@Net_UnAckn:

; 534  : 	else if (nodes[node].firstacktosend == netbuffer->ack)

  000a6	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  000aa	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax]
  000b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  000b7	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000bb	3b c8		 cmp	 ecx, eax
  000bd	75 36		 jne	 SHORT $LN8@Net_UnAckn

; 535  : 	{
; 536  : 		nodes[node].firstacktosend--;

  000bf	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  000c3	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _nodes[eax]
  000c9	80 e9 01	 sub	 cl, 1
  000cc	6b 55 08 50	 imul	 edx, DWORD PTR _node$[ebp], 80
  000d0	88 8a 00 00 00
	00		 mov	 BYTE PTR _nodes[edx], cl

; 537  : 		if (!nodes[node].firstacktosend)

  000d6	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  000da	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax]
  000e1	85 c9		 test	 ecx, ecx
  000e3	75 0b		 jne	 SHORT $LN10@Net_UnAckn

; 538  : 			nodes[node].firstacktosend = UINT8_MAX;

  000e5	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  000e9	c6 80 00 00 00
	00 ff		 mov	 BYTE PTR _nodes[eax], 255 ; 000000ffH
$LN10@Net_UnAckn:

; 539  : 	}

  000f0	e9 c5 00 00 00	 jmp	 $LN12@Net_UnAckn
$LN8@Net_UnAckn:

; 540  : 	else
; 541  : 	{
; 542  : 		while (nodes[node].firstacktosend != netbuffer->ack)

  000f5	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  000f9	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax]
  00100	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00106	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0010a	3b c8		 cmp	 ecx, eax
  0010c	74 7b		 je	 SHORT $LN3@Net_UnAckn

; 543  : 		{
; 544  : 			nodes[node].acktosend_tail = (UINT8)

  0010e	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00112	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax+2]
  00119	83 c1 3f	 add	 ecx, 63			; 0000003fH
  0011c	81 e1 3f 00 00
	80		 and	 ecx, -2147483585	; 8000003fH
  00122	79 05		 jns	 SHORT $LN15@Net_UnAckn
  00124	49		 dec	 ecx
  00125	83 c9 c0	 or	 ecx, -64		; ffffffc0H
  00128	41		 inc	 ecx
$LN15@Net_UnAckn:
  00129	6b 55 08 50	 imul	 edx, DWORD PTR _node$[ebp], 80
  0012d	88 8a 02 00 00
	00		 mov	 BYTE PTR _nodes[edx+2], cl

; 545  : 				((nodes[node].acktosend_tail-1+MAXACKTOSEND) % MAXACKTOSEND);
; 546  : 			nodes[node].acktosend[nodes[node].acktosend_tail] = nodes[node].firstacktosend;

  00133	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00137	6b 4d 08 50	 imul	 ecx, DWORD PTR _node$[ebp], 80
  0013b	6b 55 08 50	 imul	 edx, DWORD PTR _node$[ebp], 80
  0013f	0f b6 92 02 00
	00 00		 movzx	 edx, BYTE PTR _nodes[edx+2]
  00146	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _nodes[eax]
  0014c	88 84 11 03 00
	00 00		 mov	 BYTE PTR _nodes[ecx+edx+3], al

; 547  : 
; 548  : 			nodes[node].firstacktosend--;

  00153	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  00157	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _nodes[eax]
  0015d	80 e9 01	 sub	 cl, 1
  00160	6b 55 08 50	 imul	 edx, DWORD PTR _node$[ebp], 80
  00164	88 8a 00 00 00
	00		 mov	 BYTE PTR _nodes[edx], cl

; 549  : 			if (!nodes[node].firstacktosend)

  0016a	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0016e	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax]
  00175	85 c9		 test	 ecx, ecx
  00177	75 0b		 jne	 SHORT $LN11@Net_UnAckn

; 550  : 				nodes[node].firstacktosend = UINT8_MAX;

  00179	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0017d	c6 80 00 00 00
	00 ff		 mov	 BYTE PTR _nodes[eax], 255 ; 000000ffH
$LN11@Net_UnAckn:

; 551  : 		}

  00184	e9 6c ff ff ff	 jmp	 $LN8@Net_UnAckn
$LN3@Net_UnAckn:

; 552  : 		nodes[node].firstacktosend++;

  00189	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  0018d	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _nodes[eax]
  00193	80 c1 01	 add	 cl, 1
  00196	6b 55 08 50	 imul	 edx, DWORD PTR _node$[ebp], 80
  0019a	88 8a 00 00 00
	00		 mov	 BYTE PTR _nodes[edx], cl

; 553  : 		if (!nodes[node].firstacktosend)

  001a0	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  001a4	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax]
  001ab	85 c9		 test	 ecx, ecx
  001ad	75 0b		 jne	 SHORT $LN12@Net_UnAckn

; 554  : 			nodes[node].firstacktosend = 1;

  001af	6b 45 08 50	 imul	 eax, DWORD PTR _node$[ebp], 80
  001b3	c6 80 00 00 00
	00 01		 mov	 BYTE PTR _nodes[eax], 1
$LN12@Net_UnAckn:

; 555  : 	}
; 556  : }

  001ba	5f		 pop	 edi
  001bb	5e		 pop	 esi
  001bc	5b		 pop	 ebx
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
_Net_UnAcknowledgPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _D_CloseConnection
_TEXT	SEGMENT
_i$ = -4						; size = 4
_D_CloseConnection PROC					; COMDAT

; 1157 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1158 : 	INT32 i;
; 1159 : 
; 1160 : 	if (netgame)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  00010	0f 84 9b 00 00
	00		 je	 $LN5@D_CloseCon

; 1161 : 	{
; 1162 : 		// wait the ackreturn with timout of 5 Sec
; 1163 : 		Net_WaitAllAckReceived(5);

  00016	6a 05		 push	 5
  00018	e8 00 00 00 00	 call	 _Net_WaitAllAckReceived
  0001d	83 c4 04	 add	 esp, 4

; 1164 : 
; 1165 : 		// close all connection
; 1166 : 		for (i = 0; i < MAXNETNODES; i++)

  00020	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@D_CloseCon
$LN2@D_CloseCon:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@D_CloseCon:
  00032	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00036	7d 13		 jge	 SHORT $LN3@D_CloseCon

; 1167 : 			Net_CloseConnection(i|FORCECLOSE);

  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _Net_CloseConnection
  00046	83 c4 04	 add	 esp, 4
  00049	eb de		 jmp	 SHORT $LN2@D_CloseCon
$LN3@D_CloseCon:

; 1168 : 
; 1169 : 		InitAck();

  0004b	e8 00 00 00 00	 call	 _InitAck
  00050	90		 npad	 1

; 1170 : 
; 1171 : 		if (I_NetCloseSocket)

  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _I_NetCloseSocket, 0
  00058	74 07		 je	 SHORT $LN6@D_CloseCon

; 1172 : 			I_NetCloseSocket();

  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetCloseSocket
  00060	90		 npad	 1
$LN6@D_CloseCon:

; 1173 : 
; 1174 : 		I_NetGet = Internal_Get;

  00061	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetGet, OFFSET _Internal_Get

; 1175 : 		I_NetSend = Internal_Send;

  0006b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetSend, OFFSET _Internal_Send

; 1176 : 		I_NetCanSend = NULL;

  00075	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCanSend, 0

; 1177 : 		I_NetCloseSocket = NULL;

  0007f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCloseSocket, 0

; 1178 : 		I_NetFreeNodenum = Internal_FreeNodenum;

  00089	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetFreeNodenum, OFFSET _Internal_FreeNodenum

; 1179 : 		I_NetMakeNode = NULL;

  00093	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetMakeNode, 0

; 1180 : 		netgame = false;

  0009d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _netgame, 0

; 1181 : 		addedtogame = false;

  000a7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _addedtogame, 0
$LN5@D_CloseCon:

; 1182 : 	}
; 1183 : }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_D_CloseConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _D_CheckNetGame
_TEXT	SEGMENT
_k$1 = -36						; size = 4
_filename$2 = -32					; size = 20
_p$3 = -12						; size = 4
_ret$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_D_CheckNetGame PROC					; COMDAT

; 1012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1013 : 	boolean ret = false;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 1014 : 
; 1015 : 	InitAck();

  0001a	e8 00 00 00 00	 call	 _InitAck
  0001f	90		 npad	 1

; 1016 : 	rebound_tail = rebound_head = 0;

  00020	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _rebound_head, 0
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_head
  0002f	a3 00 00 00 00	 mov	 DWORD PTR _rebound_tail, eax

; 1017 : 
; 1018 : 	statstarttic = I_GetTime();

  00034	e8 00 00 00 00	 call	 _I_GetTime
  00039	a3 00 00 00 00	 mov	 DWORD PTR _statstarttic, eax

; 1019 : 
; 1020 : 	I_NetGet = Internal_Get;

  0003e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetGet, OFFSET _Internal_Get

; 1021 : 	I_NetSend = Internal_Send;

  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetSend, OFFSET _Internal_Send

; 1022 : 	I_NetCanSend = NULL;

  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCanSend, 0

; 1023 : 	I_NetCloseSocket = NULL;

  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetCloseSocket, 0

; 1024 : 	I_NetFreeNodenum = Internal_FreeNodenum;

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetFreeNodenum, OFFSET _Internal_FreeNodenum

; 1025 : 	I_NetMakeNode = NULL;

  00070	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _I_NetMakeNode, 0

; 1026 : 
; 1027 : 	hardware_MAXPACKETLENGTH = MAXPACKETLENGTH;

  0007a	b8 aa 05 00 00	 mov	 eax, 1450		; 000005aaH
  0007f	66 a3 00 00 00
	00		 mov	 WORD PTR _hardware_MAXPACKETLENGTH, ax

; 1028 : 	net_bandwidth = 30000;

  00085	c7 05 00 00 00
	00 30 75 00 00	 mov	 DWORD PTR _net_bandwidth, 30000 ; 00007530H

; 1029 : 	// I_InitNetwork sets doomcom and netgame
; 1030 : 	// check and initialize the network driver
; 1031 : 	multiplayer = false;

  0008f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _multiplayer, 0

; 1032 : 
; 1033 : 	// only dos version with external driver will return true
; 1034 : 	netgame = I_InitNetwork();

  00099	e8 00 00 00 00	 call	 _I_InitNetwork
  0009e	a3 00 00 00 00	 mov	 DWORD PTR _netgame, eax

; 1035 : 	if (!netgame && !I_NetOpenSocket)

  000a3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000aa	75 19		 jne	 SHORT $LN4@D_CheckNet
  000ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _I_NetOpenSocket, 0
  000b3	75 10		 jne	 SHORT $LN4@D_CheckNet

; 1036 : 	{
; 1037 : 		D_SetDoomcom();

  000b5	e8 00 00 00 00	 call	 _D_SetDoomcom
  000ba	90		 npad	 1

; 1038 : 		netgame = I_InitTcpNetwork();

  000bb	e8 00 00 00 00	 call	 _I_InitTcpNetwork
  000c0	a3 00 00 00 00	 mov	 DWORD PTR _netgame, eax
$LN4@D_CheckNet:

; 1039 : 	}
; 1040 : 
; 1041 : 	if (netgame)

  000c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000cc	74 07		 je	 SHORT $LN5@D_CheckNet

; 1042 : 		ret = true;

  000ce	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1
$LN5@D_CheckNet:

; 1043 : 	if (!server && netgame)

  000d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _server, 0
  000dc	75 13		 jne	 SHORT $LN6@D_CheckNet
  000de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000e5	74 0a		 je	 SHORT $LN6@D_CheckNet

; 1044 : 		netgame = false;

  000e7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _netgame, 0
$LN6@D_CheckNet:

; 1045 : 	server = true; // WTF? server always true???

  000f1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _server, 1

; 1046 : 		// no! The deault mode is server. Client is set elsewhere
; 1047 : 		// when the client executes connect command.
; 1048 : 	doomcom->ticdup = 1;

  000fb	b8 01 00 00 00	 mov	 eax, 1
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00106	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 1049 : 
; 1050 : 	if (M_CheckParm("-extratic"))

  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_09NIIDKICI@?9extratic@
  0010f	e8 00 00 00 00	 call	 _M_CheckParm
  00114	83 c4 04	 add	 esp, 4
  00117	85 c0		 test	 eax, eax
  00119	74 53		 je	 SHORT $LN7@D_CheckNet

; 1051 : 	{
; 1052 : 		if (M_IsNextParm())

  0011b	e8 00 00 00 00	 call	 _M_IsNextParm
  00120	85 c0		 test	 eax, eax
  00122	74 1a		 je	 SHORT $LN8@D_CheckNet

; 1053 : 			doomcom->extratics = (INT16)atoi(M_GetNextParm());

  00124	e8 00 00 00 00	 call	 _M_GetNextParm
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _atoi
  0012f	83 c4 04	 add	 esp, 4
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00138	66 89 41 10	 mov	 WORD PTR [ecx+16], ax
  0013c	eb 0f		 jmp	 SHORT $LN9@D_CheckNet
$LN8@D_CheckNet:

; 1054 : 		else
; 1055 : 			doomcom->extratics = 1;

  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00149	66 89 41 10	 mov	 WORD PTR [ecx+16], ax
$LN9@D_CheckNet:

; 1056 : 		CONS_Printf(text[SET_EXTRATICS], doomcom->extratics);

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00152	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00156	51		 push	 ecx
  00157	ba 04 00 00 00	 mov	 edx, 4
  0015c	6b c2 54	 imul	 eax, edx, 84
  0015f	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR _text[eax]
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _CONS_Printf
  0016b	83 c4 08	 add	 esp, 8
$LN7@D_CheckNet:

; 1057 : 	}
; 1058 : 
; 1059 : 	if (M_CheckParm("-bandwidth"))

  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DFHPHOCE@?9bandwidth@
  00173	e8 00 00 00 00	 call	 _M_CheckParm
  00178	83 c4 04	 add	 esp, 4
  0017b	85 c0		 test	 eax, eax
  0017d	74 75		 je	 SHORT $LN12@D_CheckNet

; 1060 : 	{
; 1061 : 		if (M_IsNextParm())

  0017f	e8 00 00 00 00	 call	 _M_IsNextParm
  00184	85 c0		 test	 eax, eax
  00186	74 5f		 je	 SHORT $LN11@D_CheckNet

; 1062 : 		{
; 1063 : 			net_bandwidth = atoi(M_GetNextParm());

  00188	e8 00 00 00 00	 call	 _M_GetNextParm
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 _atoi
  00193	83 c4 04	 add	 esp, 4
  00196	a3 00 00 00 00	 mov	 DWORD PTR _net_bandwidth, eax

; 1064 : 			if (net_bandwidth < 1000)

  0019b	81 3d 00 00 00
	00 e8 03 00 00	 cmp	 DWORD PTR _net_bandwidth, 1000 ; 000003e8H
  001a5	7d 0a		 jge	 SHORT $LN13@D_CheckNet

; 1065 : 				net_bandwidth = 1000;

  001a7	c7 05 00 00 00
	00 e8 03 00 00	 mov	 DWORD PTR _net_bandwidth, 1000 ; 000003e8H
$LN13@D_CheckNet:

; 1066 : 			if (net_bandwidth > 100000)

  001b1	81 3d 00 00 00
	00 a0 86 01 00	 cmp	 DWORD PTR _net_bandwidth, 100000 ; 000186a0H
  001bb	7e 0b		 jle	 SHORT $LN14@D_CheckNet

; 1067 : 				hardware_MAXPACKETLENGTH = MAXPACKETLENGTH;

  001bd	b8 aa 05 00 00	 mov	 eax, 1450		; 000005aaH
  001c2	66 a3 00 00 00
	00		 mov	 WORD PTR _hardware_MAXPACKETLENGTH, ax
$LN14@D_CheckNet:

; 1068 : 			CONS_Printf(text[SET_BANDWIDTH], net_bandwidth);

  001c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _net_bandwidth
  001cd	50		 push	 eax
  001ce	b9 04 00 00 00	 mov	 ecx, 4
  001d3	6b d1 55	 imul	 edx, ecx, 85
  001d6	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _CONS_Printf
  001e2	83 c4 08	 add	 esp, 8

; 1069 : 		}

  001e5	eb 0d		 jmp	 SHORT $LN12@D_CheckNet
$LN11@D_CheckNet:

; 1070 : 		else
; 1071 : 			I_Error("usage: -bandwidth <byte_per_sec>");

  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GHBDLABC@usage?3?5?9bandwidth?5?$DMbyte_per_sec@
  001ec	e8 00 00 00 00	 call	 _I_Error
  001f1	83 c4 04	 add	 esp, 4
$LN12@D_CheckNet:

; 1072 : 	}
; 1073 : 
; 1074 : 	software_MAXPACKETLENGTH = hardware_MAXPACKETLENGTH;

  001f4	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _hardware_MAXPACKETLENGTH
  001fa	66 a3 00 00 00
	00		 mov	 WORD PTR _software_MAXPACKETLENGTH, ax

; 1075 : 	if (M_CheckParm("-packetsize"))

  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NKFBKDNA@?9packetsize@
  00205	e8 00 00 00 00	 call	 _M_CheckParm
  0020a	83 c4 04	 add	 esp, 4
  0020d	85 c0		 test	 eax, eax
  0020f	74 56		 je	 SHORT $LN17@D_CheckNet

; 1076 : 	{
; 1077 : 		if (M_IsNextParm())

  00211	e8 00 00 00 00	 call	 _M_IsNextParm
  00216	85 c0		 test	 eax, eax
  00218	74 40		 je	 SHORT $LN16@D_CheckNet

; 1078 : 		{
; 1079 : 			INT32 p = atoi(M_GetNextParm());

  0021a	e8 00 00 00 00	 call	 _M_GetNextParm
  0021f	50		 push	 eax
  00220	e8 00 00 00 00	 call	 _atoi
  00225	83 c4 04	 add	 esp, 4
  00228	89 45 f4	 mov	 DWORD PTR _p$3[ebp], eax

; 1080 : 			if (p < 75)

  0022b	83 7d f4 4b	 cmp	 DWORD PTR _p$3[ebp], 75	; 0000004bH
  0022f	7d 07		 jge	 SHORT $LN18@D_CheckNet

; 1081 : 				p = 75;

  00231	c7 45 f4 4b 00
	00 00		 mov	 DWORD PTR _p$3[ebp], 75	; 0000004bH
$LN18@D_CheckNet:

; 1082 : 			if (p > hardware_MAXPACKETLENGTH)

  00238	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _hardware_MAXPACKETLENGTH
  0023f	39 45 f4	 cmp	 DWORD PTR _p$3[ebp], eax
  00242	7e 0a		 jle	 SHORT $LN19@D_CheckNet

; 1083 : 				p = hardware_MAXPACKETLENGTH;

  00244	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _hardware_MAXPACKETLENGTH
  0024b	89 45 f4	 mov	 DWORD PTR _p$3[ebp], eax
$LN19@D_CheckNet:

; 1084 : 			software_MAXPACKETLENGTH = (UINT16)p;

  0024e	66 8b 45 f4	 mov	 ax, WORD PTR _p$3[ebp]
  00252	66 a3 00 00 00
	00		 mov	 WORD PTR _software_MAXPACKETLENGTH, ax

; 1085 : 		}

  00258	eb 0d		 jmp	 SHORT $LN17@D_CheckNet
$LN16@D_CheckNet:

; 1086 : 		else
; 1087 : 			I_Error("usage: -packetsize <bytes_per_packet>");

  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CPJJPCGI@usage?3?5?9packetsize?5?$DMbytes_per_p@
  0025f	e8 00 00 00 00	 call	 _I_Error
  00264	83 c4 04	 add	 esp, 4
$LN17@D_CheckNet:

; 1088 : 	}
; 1089 : 
; 1090 : 	if (netgame)

  00267	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  0026e	74 0a		 je	 SHORT $LN20@D_CheckNet

; 1091 : 		multiplayer = true;

  00270	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _multiplayer, 1
$LN20@D_CheckNet:

; 1092 : 
; 1093 : 	if (doomcom->id != DOOMCOM_ID)

  0027a	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0027f	81 38 78 56 34
	12		 cmp	 DWORD PTR [eax], 305419896 ; 12345678H
  00285	74 0d		 je	 SHORT $LN21@D_CheckNet

; 1094 : 		I_Error("Doomcom buffer invalid!");

  00287	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NMIECCI@Doomcom?5buffer?5invalid?$CB@
  0028c	e8 00 00 00 00	 call	 _I_Error
  00291	83 c4 04	 add	 esp, 4
$LN21@D_CheckNet:

; 1095 : 	if (doomcom->numnodes > MAXNETNODES)

  00294	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00299	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  0029d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  002a0	7e 19		 jle	 SHORT $LN22@D_CheckNet

; 1096 : 		I_Error("Too many nodes (%d), max:%d", doomcom->numnodes, MAXNETNODES);

  002a2	6a 20		 push	 32			; 00000020H
  002a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  002a9	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  002ad	51		 push	 ecx
  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JIKKJDAF@Too?5many?5nodes?5?$CI?$CFd?$CJ?0?5max?3?$CFd@
  002b3	e8 00 00 00 00	 call	 _I_Error
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@D_CheckNet:

; 1097 : 
; 1098 : 	netbuffer = (doomdata_t *)(void *)&doomcom->data;

  002bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  002c0	83 c0 1c	 add	 eax, 28			; 0000001cH
  002c3	a3 00 00 00 00	 mov	 DWORD PTR _netbuffer, eax

; 1099 : 
; 1100 : #ifdef DEBUGFILE
; 1101 : #ifdef _arch_dreamcast
; 1102 : 	//debugfile = stderr;
; 1103 : 	if (debugfile)
; 1104 : 			CONS_Printf("debug output to: strerr\n");
; 1105 : #else
; 1106 : 	if (M_CheckParm("-debugfile"))

  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CHPMBMEI@?9debugfile@
  002cd	e8 00 00 00 00	 call	 _M_CheckParm
  002d2	83 c4 04	 add	 esp, 4
  002d5	85 c0		 test	 eax, eax
  002d7	0f 84 b2 00 00
	00		 je	 $LN26@D_CheckNet

; 1107 : 	{
; 1108 : 		char filename[20];
; 1109 : 		INT32 k = doomcom->consoleplayer - 1;

  002dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  002e2	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  002e6	83 e9 01	 sub	 ecx, 1
  002e9	89 4d dc	 mov	 DWORD PTR _k$1[ebp], ecx

; 1110 : 		if (M_IsNextParm())

  002ec	e8 00 00 00 00	 call	 _M_IsNextParm
  002f1	85 c0		 test	 eax, eax
  002f3	74 14		 je	 SHORT $LN24@D_CheckNet

; 1111 : 			k = atoi(M_GetNextParm()) - 1;

  002f5	e8 00 00 00 00	 call	 _M_GetNextParm
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 _atoi
  00300	83 c4 04	 add	 esp, 4
  00303	83 e8 01	 sub	 eax, 1
  00306	89 45 dc	 mov	 DWORD PTR _k$1[ebp], eax
$LN24@D_CheckNet:

; 1112 : 		while (!debugfile && k < MAXPLAYERS)

  00309	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00310	75 3c		 jne	 SHORT $LN3@D_CheckNet
  00312	83 7d dc 20	 cmp	 DWORD PTR _k$1[ebp], 32	; 00000020H
  00316	7d 36		 jge	 SHORT $LN3@D_CheckNet

; 1113 : 		{
; 1114 : 			k++;

  00318	8b 45 dc	 mov	 eax, DWORD PTR _k$1[ebp]
  0031b	83 c0 01	 add	 eax, 1
  0031e	89 45 dc	 mov	 DWORD PTR _k$1[ebp], eax

; 1115 : 			sprintf(filename, "debug%d.txt", k);

  00321	8b 45 dc	 mov	 eax, DWORD PTR _k$1[ebp]
  00324	50		 push	 eax
  00325	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LOAINHCL@debug?$CFd?4txt@
  0032a	8d 4d e0	 lea	 ecx, DWORD PTR _filename$2[ebp]
  0032d	51		 push	 ecx
  0032e	e8 00 00 00 00	 call	 _sprintf
  00333	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1116 : 			debugfile = fopen(filename, "w");

  00336	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  0033b	8d 45 e0	 lea	 eax, DWORD PTR _filename$2[ebp]
  0033e	50		 push	 eax
  0033f	e8 00 00 00 00	 call	 _fopen
  00344	83 c4 08	 add	 esp, 8
  00347	a3 00 00 00 00	 mov	 DWORD PTR _debugfile, eax

; 1117 : 		}

  0034c	eb bb		 jmp	 SHORT $LN24@D_CheckNet
$LN3@D_CheckNet:

; 1118 : 		if (debugfile)

  0034e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00355	74 1d		 je	 SHORT $LN25@D_CheckNet

; 1119 : 			CONS_Printf(text[DEBUG_OUTPUT], filename);

  00357	8d 45 e0	 lea	 eax, DWORD PTR _filename$2[ebp]
  0035a	50		 push	 eax
  0035b	b9 04 00 00 00	 mov	 ecx, 4
  00360	6b d1 56	 imul	 edx, ecx, 86
  00363	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 _CONS_Printf
  0036f	83 c4 08	 add	 esp, 8
  00372	eb 1b		 jmp	 SHORT $LN26@D_CheckNet
$LN25@D_CheckNet:

; 1120 : 		else
; 1121 : 			CONS_Printf(text[NODEBUG_OUTPUT], filename);

  00374	8d 45 e0	 lea	 eax, DWORD PTR _filename$2[ebp]
  00377	50		 push	 eax
  00378	b9 04 00 00 00	 mov	 ecx, 4
  0037d	6b d1 57	 imul	 edx, ecx, 87
  00380	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 _CONS_Printf
  0038c	83 c4 08	 add	 esp, 8
$LN26@D_CheckNet:

; 1122 : 	}
; 1123 : #endif
; 1124 : #endif
; 1125 : 
; 1126 : 	D_ClientServerInit();

  0038f	e8 00 00 00 00	 call	 _D_ClientServerInit
  00394	90		 npad	 1

; 1127 : 
; 1128 : 	return ret;

  00395	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 1129 : }

  00398	5f		 pop	 edi
  00399	5e		 pop	 esi
  0039a	5b		 pop	 ebx
  0039b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039e	33 cd		 xor	 ecx, ebp
  003a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a5	8b e5		 mov	 esp, ebp
  003a7	5d		 pop	 ebp
  003a8	c3		 ret	 0
_D_CheckNetGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _D_SetDoomcom
_TEXT	SEGMENT
_D_SetDoomcom PROC					; COMDAT

; 997  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 998  : 	if (doomcom) return;

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _doomcom, 0
  00010	74 02		 je	 SHORT $LN2@D_SetDoomc
  00012	eb 64		 jmp	 SHORT $LN1@D_SetDoomc
$LN2@D_SetDoomc:

; 999  : 	doomcom = Z_Calloc(sizeof (doomcom_t), PU_STATIC, NULL);

  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 01		 push	 1
  0001a	68 c6 05 00 00	 push	 1478			; 000005c6H
  0001f	e8 00 00 00 00	 call	 _Z_CallocAlign
  00024	83 c4 10	 add	 esp, 16			; 00000010H
  00027	a3 00 00 00 00	 mov	 DWORD PTR _doomcom, eax

; 1000 : 	doomcom->id = DOOMCOM_ID;

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00031	c7 00 78 56 34
	12		 mov	 DWORD PTR [eax], 305419896 ; 12345678H

; 1001 : 	doomcom->numslots = doomcom->numnodes = 1;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00042	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
  00046	ba 01 00 00 00	 mov	 edx, 1
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00050	66 89 50 1a	 mov	 WORD PTR [eax+26], dx

; 1002 : 	doomcom->gametype = 0;

  00054	33 c0		 xor	 eax, eax
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  0005c	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1003 : 	doomcom->consoleplayer = 0;

  00060	33 c0		 xor	 eax, eax
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00068	66 89 41 18	 mov	 WORD PTR [ecx+24], ax

; 1004 : 	doomcom->extratics = 0;

  0006c	33 c0		 xor	 eax, eax
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00074	66 89 41 10	 mov	 WORD PTR [ecx+16], ax
$LN1@D_SetDoomc:

; 1005 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_D_SetDoomcom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _HGetPacket
_TEXT	SEGMENT
_HGetPacket PROC					; COMDAT

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 913  : 	// get a packet from self
; 914  : 	if (rebound_tail != rebound_head)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_tail
  0000e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rebound_head
  00014	0f 84 b8 00 00
	00		 je	 $LN4@HGetPacket

; 915  : 	{
; 916  : 		M_Memcpy(netbuffer, &reboundstore[rebound_tail], reboundsize[rebound_tail]);

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_tail
  0001f	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _reboundsize[eax*2]
  00027	51		 push	 ecx
  00028	69 15 00 00 00
	00 88 04 00 00	 imul	 edx, DWORD PTR _rebound_tail, 1160
  00032	81 c2 00 00 00
	00		 add	 edx, OFFSET _reboundstore
  00038	52		 push	 edx
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 917  : 		doomcom->datalength = reboundsize[rebound_tail];

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _rebound_tail
  00053	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _reboundsize[ecx*2]
  0005b	66 89 50 0a	 mov	 WORD PTR [eax+10], dx

; 918  : 		if (netbuffer->packettype == PT_NODETIMEOUT)

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00064	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00068	83 f9 15	 cmp	 ecx, 21			; 00000015H
  0006b	75 20		 jne	 SHORT $LN5@HGetPacket

; 919  : 			doomcom->remotenode = netbuffer->u.textcmd[0];

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	6b c8 00	 imul	 ecx, eax, 0
  00075	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  0007b	66 0f b6 44 0a
	08		 movzx	 ax, BYTE PTR [edx+ecx+8]
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00087	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  0008b	eb 0c		 jmp	 SHORT $LN6@HGetPacket
$LN5@HGetPacket:

; 920  : 		else
; 921  : 			doomcom->remotenode = 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00095	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
$LN6@HGetPacket:

; 922  : 
; 923  : 		rebound_tail = (rebound_tail+1) % MAXREBOUND;

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_tail
  0009e	83 c0 01	 add	 eax, 1
  000a1	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000a6	79 05		 jns	 SHORT $LN22@HGetPacket
  000a8	48		 dec	 eax
  000a9	83 c8 f8	 or	 eax, -8			; fffffff8H
  000ac	40		 inc	 eax
$LN22@HGetPacket:
  000ad	a3 00 00 00 00	 mov	 DWORD PTR _rebound_tail, eax

; 924  : #ifdef DEBUGFILE
; 925  : 		if (debugfile)

  000b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  000b9	74 0d		 je	 SHORT $LN7@HGetPacket

; 926  : 			DebugPrintpacket("GETLOCAL");

  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_08BDOOJBBA@GETLOCAL@
  000c0	e8 00 00 00 00	 call	 _DebugPrintpacket
  000c5	83 c4 04	 add	 esp, 4
$LN7@HGetPacket:

; 927  : #endif
; 928  : 		return true;

  000c8	b8 01 00 00 00	 mov	 eax, 1
  000cd	e9 71 01 00 00	 jmp	 $LN1@HGetPacket
$LN4@HGetPacket:

; 929  : 	}
; 930  : 
; 931  : 	if (!netgame)

  000d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000d9	75 07		 jne	 SHORT $LN8@HGetPacket

; 932  : 		return false;

  000db	33 c0		 xor	 eax, eax
  000dd	e9 61 01 00 00	 jmp	 $LN1@HGetPacket
$LN8@HGetPacket:

; 933  : 
; 934  : 	while(true)

  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	85 c0		 test	 eax, eax
  000e9	0f 84 4f 01 00
	00		 je	 $LN3@HGetPacket

; 935  : 	{
; 936  : 		I_NetGet();

  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetGet
  000f5	90		 npad	 1

; 937  : 
; 938  : 		if (doomcom->remotenode == -1)

  000f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000fb	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  000ff	83 f9 ff	 cmp	 ecx, -1
  00102	75 07		 jne	 SHORT $LN9@HGetPacket

; 939  : 			return false;

  00104	33 c0		 xor	 eax, eax
  00106	e9 38 01 00 00	 jmp	 $LN1@HGetPacket
$LN9@HGetPacket:

; 940  : 
; 941  : 		getbytes += packetheaderlength + doomcom->datalength; // for stat

  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00110	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00114	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _packetheaderlength
  0011a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _getbytes
  00120	89 0d 00 00 00
	00		 mov	 DWORD PTR _getbytes, ecx

; 942  : 
; 943  : 		if (doomcom->remotenode >= MAXNETNODES)

  00126	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0012b	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0012f	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00132	7c 43		 jl	 SHORT $LN10@HGetPacket

; 944  : 		{
; 945  : 			DEBFILE(va("receive packet from node %d !\n", doomcom->remotenode));

  00134	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0013b	74 35		 je	 SHORT $LN11@HGetPacket
  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00142	50		 push	 eax
  00143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00149	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0014d	52		 push	 edx
  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@ELCNABGA@receive?5packet?5from?5node?5?$CFd?5?$CB?6@
  00153	e8 00 00 00 00	 call	 _va
  00158	83 c4 08	 add	 esp, 8
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _fputs
  00161	83 c4 08	 add	 esp, 8
  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _fflush
  0016f	83 c4 04	 add	 esp, 4
$LN11@HGetPacket:

; 946  : 			continue;

  00172	e9 6b ff ff ff	 jmp	 $LN8@HGetPacket
$LN10@HGetPacket:

; 947  : 		}
; 948  : 
; 949  : 		nodes[doomcom->remotenode].lasttimepacketreceived = I_GetTime();

  00177	e8 00 00 00 00	 call	 _I_GetTime
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00182	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00186	6b ca 50	 imul	 ecx, edx, 80
  00189	89 81 48 00 00
	00		 mov	 DWORD PTR _nodes[ecx+72], eax

; 950  : 
; 951  : 		if (netbuffer->checksum != NetbufferChecksum())

  0018f	e8 00 00 00 00	 call	 _NetbufferChecksum
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  0019a	39 01		 cmp	 DWORD PTR [ecx], eax
  0019c	74 5d		 je	 SHORT $LN12@HGetPacket

; 952  : 		{
; 953  : 			DEBFILE("Bad packet checksum\n");

  0019e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  001a5	74 21		 je	 SHORT $LN13@HGetPacket
  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CPFGGGNO@Bad?5packet?5checksum?6@
  001b2	e8 00 00 00 00	 call	 _fputs
  001b7	83 c4 08	 add	 esp, 8
  001ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _fflush
  001c5	83 c4 04	 add	 esp, 4
$LN13@HGetPacket:

; 954  : 			if (I_Shun)

  001c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _I_Shun, 0
  001cf	74 13		 je	 SHORT $LN14@HGetPacket

; 955  : 				I_Shun(doomcom->remotenode);

  001d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  001d6	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  001da	51		 push	 ecx
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR _I_Shun
  001e1	83 c4 04	 add	 esp, 4
$LN14@HGetPacket:

; 956  : 			Net_CloseConnection(doomcom->remotenode);

  001e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  001e9	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  001ed	51		 push	 ecx
  001ee	e8 00 00 00 00	 call	 _Net_CloseConnection
  001f3	83 c4 04	 add	 esp, 4

; 957  : 			continue;

  001f6	e9 e7 fe ff ff	 jmp	 $LN8@HGetPacket
$LN12@HGetPacket:

; 958  : 		}
; 959  : 
; 960  : #ifdef DEBUGFILE
; 961  : 		if (debugfile)

  001fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00202	74 0d		 je	 SHORT $LN15@HGetPacket

; 962  : 			DebugPrintpacket("GET");

  00204	68 00 00 00 00	 push	 OFFSET ??_C@_03HAPOJHBM@GET@
  00209	e8 00 00 00 00	 call	 _DebugPrintpacket
  0020e	83 c4 04	 add	 esp, 4
$LN15@HGetPacket:

; 963  : #endif
; 964  : 
; 965  : 		// proceed the ack and ackreturn field
; 966  : 		if (!Processackpak())

  00211	e8 00 00 00 00	 call	 _Processackpak
  00216	85 c0		 test	 eax, eax
  00218	75 05		 jne	 SHORT $LN16@HGetPacket

; 967  : 			continue; // discarded (duplicated)

  0021a	e9 c3 fe ff ff	 jmp	 $LN8@HGetPacket
$LN16@HGetPacket:

; 968  : 
; 969  : 		// a packet with just ackreturn
; 970  : 		if (netbuffer->packettype == PT_NOTHING)

  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00224	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00228	85 c9		 test	 ecx, ecx
  0022a	75 0b		 jne	 SHORT $LN17@HGetPacket

; 971  : 		{
; 972  : 			GotAcks();

  0022c	e8 00 00 00 00	 call	 _GotAcks
  00231	90		 npad	 1

; 973  : 			continue;

  00232	e9 ab fe ff ff	 jmp	 $LN8@HGetPacket
$LN17@HGetPacket:

; 974  : 		}
; 975  : 	break;

  00237	eb 05		 jmp	 SHORT $LN3@HGetPacket

; 976  : 	}

  00239	e9 a4 fe ff ff	 jmp	 $LN8@HGetPacket
$LN3@HGetPacket:

; 977  : 
; 978  : 	return true;

  0023e	b8 01 00 00 00	 mov	 eax, 1
$LN1@HGetPacket:

; 979  : }

  00243	5f		 pop	 edi
  00244	5e		 pop	 esi
  00245	5b		 pop	 ebx
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
_HGetPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _HSendPacket
_TEXT	SEGMENT
_node$ = 8						; size = 4
_reliable$ = 12						; size = 4
_acknum$ = 16						; size = 1
_packetlength$ = 20					; size = 4
_HSendPacket PROC					; COMDAT

; 826  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 827  : 	doomcom->datalength = (INT16)(packetlength + BASEPACKETSIZE);

  00009	8b 45 14	 mov	 eax, DWORD PTR _packetlength$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  00015	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 828  : 	if (node == 0) // packet is to go back to us

  00019	83 7d 08 00	 cmp	 DWORD PTR _node$[ebp], 0
  0001d	0f 85 aa 00 00
	00		 jne	 $LN2@HSendPacke

; 829  : 	{
; 830  : 		if ((rebound_head+1) % MAXREBOUND == rebound_tail)

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_head
  00028	83 c0 01	 add	 eax, 1
  0002b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00030	79 05		 jns	 SHORT $LN23@HSendPacke
  00032	48		 dec	 eax
  00033	83 c8 f8	 or	 eax, -8			; fffffff8H
  00036	40		 inc	 eax
$LN23@HSendPacke:
  00037	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rebound_tail
  0003d	75 07		 jne	 SHORT $LN3@HSendPacke

; 831  : 		{
; 832  : #ifdef PARANOIA
; 833  : 			CONS_Printf("No more rebound buf\n");
; 834  : #endif
; 835  : 			return false;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 37 02 00 00	 jmp	 $LN1@HSendPacke
$LN3@HSendPacke:

; 836  : 		}
; 837  : 		M_Memcpy(&reboundstore[rebound_head], netbuffer,

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  0004b	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  0004f	51		 push	 ecx
  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _netbuffer
  00056	52		 push	 edx
  00057	69 05 00 00 00
	00 88 04 00 00	 imul	 eax, DWORD PTR _rebound_head, 1160
  00061	05 00 00 00 00	 add	 eax, OFFSET _reboundstore
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 838  : 			doomcom->datalength);
; 839  : 		reboundsize[rebound_head] = doomcom->datalength;

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_head
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _doomcom
  0007b	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  0007f	66 89 14 45 00
	00 00 00	 mov	 WORD PTR _reboundsize[eax*2], dx

; 840  : 		rebound_head = (rebound_head+1) % MAXREBOUND;

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR _rebound_head
  0008c	83 c0 01	 add	 eax, 1
  0008f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00094	79 05		 jns	 SHORT $LN24@HSendPacke
  00096	48		 dec	 eax
  00097	83 c8 f8	 or	 eax, -8			; fffffff8H
  0009a	40		 inc	 eax
$LN24@HSendPacke:
  0009b	a3 00 00 00 00	 mov	 DWORD PTR _rebound_head, eax

; 841  : #ifdef DEBUGFILE
; 842  : 		if (debugfile)

  000a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  000a7	74 1a		 je	 SHORT $LN4@HSendPacke

; 843  : 		{
; 844  : 			doomcom->remotenode = (INT16)node;

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000ae	66 8b 4d 08	 mov	 cx, WORD PTR _node$[ebp]
  000b2	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 845  : 			DebugPrintpacket("SENDLOCAL");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_09FAAMHIJN@SENDLOCAL@
  000bb	e8 00 00 00 00	 call	 _DebugPrintpacket
  000c0	83 c4 04	 add	 esp, 4
$LN4@HSendPacke:

; 846  : 		}
; 847  : #endif
; 848  : 		return true;

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	e9 b0 01 00 00	 jmp	 $LN1@HSendPacke
$LN2@HSendPacke:

; 849  : 	}
; 850  : 
; 851  : 	if (!netgame)

  000cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _netgame, 0
  000d4	75 0d		 jne	 SHORT $LN5@HSendPacke

; 852  : 		I_Error("Tried to transmit to another node");

  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FEPCJHGI@Tried?5to?5transmit?5to?5another?5no@
  000db	e8 00 00 00 00	 call	 _I_Error
  000e0	83 c4 04	 add	 esp, 4
$LN5@HSendPacke:

; 853  : 
; 854  : 	// do this before GetFreeAcknum because this function backup
; 855  : 	// the current packet
; 856  : 	doomcom->remotenode = (INT16)node;

  000e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000e8	66 8b 4d 08	 mov	 cx, WORD PTR _node$[ebp]
  000ec	66 89 48 08	 mov	 WORD PTR [eax+8], cx

; 857  : 	if (doomcom->datalength <= 0)

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  000f5	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  000f9	85 c9		 test	 ecx, ecx
  000fb	7f 47		 jg	 SHORT $LN6@HSendPacke

; 858  : 	{
; 859  : 		DEBFILE("HSendPacket: nothing to send\n");

  000fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00104	74 21		 je	 SHORT $LN7@HSendPacke
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0010b	50		 push	 eax
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LFPMEAGK@HSendPacket?3?5nothing?5to?5send?6@
  00111	e8 00 00 00 00	 call	 _fputs
  00116	83 c4 08	 add	 esp, 8
  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _fflush
  00124	83 c4 04	 add	 esp, 4
$LN7@HSendPacke:

; 860  : #ifdef DEBUGFILE
; 861  : 		if (debugfile)

  00127	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0012e	74 0d		 je	 SHORT $LN8@HSendPacke

; 862  : 			DebugPrintpacket("TRISEND");

  00130	68 00 00 00 00	 push	 OFFSET ??_C@_07OKMEEJEP@TRISEND@
  00135	e8 00 00 00 00	 call	 _DebugPrintpacket
  0013a	83 c4 04	 add	 esp, 4
$LN8@HSendPacke:

; 863  : #endif
; 864  : 		return false;

  0013d	33 c0		 xor	 eax, eax
  0013f	e9 39 01 00 00	 jmp	 $LN1@HSendPacke
$LN6@HSendPacke:

; 865  : 	}
; 866  : 
; 867  : 	if (node < MAXNETNODES) // can be a broadcast

  00144	83 7d 08 20	 cmp	 DWORD PTR _node$[ebp], 32 ; 00000020H
  00148	7d 17		 jge	 SHORT $LN9@HSendPacke

; 868  : 		netbuffer->ackreturn = GetAcktosend(node);

  0014a	8b 45 08	 mov	 eax, DWORD PTR _node$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _GetAcktosend
  00153	83 c4 04	 add	 esp, 4
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  0015c	88 41 05	 mov	 BYTE PTR [ecx+5], al
  0015f	eb 09		 jmp	 SHORT $LN10@HSendPacke
$LN9@HSendPacke:

; 869  : 	else
; 870  : 		netbuffer->ackreturn = 0;

  00161	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00166	c6 40 05 00	 mov	 BYTE PTR [eax+5], 0
$LN10@HSendPacke:

; 871  : 	if (reliable)

  0016a	83 7d 0c 00	 cmp	 DWORD PTR _reliable$[ebp], 0
  0016e	0f 84 87 00 00
	00		 je	 $LN11@HSendPacke

; 872  : 	{
; 873  : 		if (I_NetCanSend && !I_NetCanSend())

  00174	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _I_NetCanSend, 0
  0017b	74 5e		 je	 SHORT $LN13@HSendPacke
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetCanSend
  00183	85 c0		 test	 eax, eax
  00185	75 54		 jne	 SHORT $LN13@HSendPacke

; 874  : 		{
; 875  : 			if (netbuffer->packettype < PT_CANFAIL)

  00187	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0018c	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00190	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00193	7d 13		 jge	 SHORT $LN15@HSendPacke

; 876  : 				GetFreeAcknum(&netbuffer->ack, true);

  00195	6a 01		 push	 1
  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0019c	83 c0 04	 add	 eax, 4
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _GetFreeAcknum
  001a5	83 c4 08	 add	 esp, 8
$LN15@HSendPacke:

; 877  : 
; 878  : 			DEBFILE("HSendPacket: Out of bandwidth\n");

  001a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  001af	74 21		 je	 SHORT $LN16@HSendPacke
  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001b6	50		 push	 eax
  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EGECDOJ@HSendPacket?3?5Out?5of?5bandwidth?6@
  001bc	e8 00 00 00 00	 call	 _fputs
  001c1	83 c4 08	 add	 esp, 8
  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 _fflush
  001cf	83 c4 04	 add	 esp, 4
$LN16@HSendPacke:

; 879  : 			return false;

  001d2	33 c0		 xor	 eax, eax
  001d4	e9 a4 00 00 00	 jmp	 $LN1@HSendPacke

; 880  : 		}

  001d9	eb 1e		 jmp	 SHORT $LN17@HSendPacke
$LN13@HSendPacke:

; 881  : 		else if (!GetFreeAcknum(&netbuffer->ack, false))

  001db	6a 00		 push	 0
  001dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  001e2	83 c0 04	 add	 eax, 4
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 _GetFreeAcknum
  001eb	83 c4 08	 add	 esp, 8
  001ee	85 c0		 test	 eax, eax
  001f0	75 07		 jne	 SHORT $LN17@HSendPacke

; 882  : 			return false;

  001f2	33 c0		 xor	 eax, eax
  001f4	e9 84 00 00 00	 jmp	 $LN1@HSendPacke
$LN17@HSendPacke:

; 883  : 	}

  001f9	eb 0b		 jmp	 SHORT $LN12@HSendPacke
$LN11@HSendPacke:

; 884  : 	else
; 885  : 		netbuffer->ack = acknum;

  001fb	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  00200	8a 4d 10	 mov	 cl, BYTE PTR _acknum$[ebp]
  00203	88 48 04	 mov	 BYTE PTR [eax+4], cl
$LN12@HSendPacke:

; 886  : 
; 887  : 	netbuffer->checksum = NetbufferChecksum();

  00206	e8 00 00 00 00	 call	 _NetbufferChecksum
  0020b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _netbuffer
  00211	89 01		 mov	 DWORD PTR [ecx], eax

; 888  : 	sendbytes += packetheaderlength + doomcom->datalength; // for stat

  00213	a1 00 00 00 00	 mov	 eax, DWORD PTR _doomcom
  00218	0f bf 40 0a	 movsx	 eax, WORD PTR [eax+10]
  0021c	03 05 00 00 00
	00		 add	 eax, DWORD PTR _packetheaderlength
  00222	99		 cdq
  00223	03 05 00 00 00
	00		 add	 eax, DWORD PTR _sendbytes
  00229	13 15 04 00 00
	00		 adc	 edx, DWORD PTR _sendbytes+4
  0022f	a3 00 00 00 00	 mov	 DWORD PTR _sendbytes, eax
  00234	89 15 04 00 00
	00		 mov	 DWORD PTR _sendbytes+4, edx

; 889  : 
; 890  : 	// simulate internet :)
; 891  : 	if (true || rand()<(INT32)RAND_MAX/5)

  0023a	b8 01 00 00 00	 mov	 eax, 1
  0023f	85 c0		 test	 eax, eax
  00241	74 1f		 je	 SHORT $LN18@HSendPacke

; 892  : 	{
; 893  : #ifdef DEBUGFILE
; 894  : 		if (debugfile)

  00243	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0024a	74 0d		 je	 SHORT $LN20@HSendPacke

; 895  : 			DebugPrintpacket("SEND");

  0024c	68 00 00 00 00	 push	 OFFSET ??_C@_04ELFDPDN@SEND@
  00251	e8 00 00 00 00	 call	 _DebugPrintpacket
  00256	83 c4 04	 add	 esp, 4
$LN20@HSendPacke:

; 896  : #endif
; 897  : 		I_NetSend();

  00259	ff 15 00 00 00
	00		 call	 DWORD PTR _I_NetSend
  0025f	90		 npad	 1

; 898  : 	}

  00260	eb 16		 jmp	 SHORT $LN21@HSendPacke
$LN18@HSendPacke:

; 899  : #ifdef DEBUGFILE
; 900  : 	else if (debugfile)

  00262	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  00269	74 0d		 je	 SHORT $LN21@HSendPacke

; 901  : 		DebugPrintpacket("NOTSEND");

  0026b	68 00 00 00 00	 push	 OFFSET ??_C@_07LOPOIIOH@NOTSEND@
  00270	e8 00 00 00 00	 call	 _DebugPrintpacket
  00275	83 c4 04	 add	 esp, 4
$LN21@HSendPacke:

; 902  : #endif
; 903  : 	return true;

  00278	b8 01 00 00 00	 mov	 eax, 1
$LN1@HSendPacke:

; 904  : }

  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	5b		 pop	 ebx
  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c3		 ret	 0
_HSendPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_AllAckReceived
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Net_AllAckReceived PROC				; COMDAT

; 559  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 560  : 	INT32 i;
; 561  : 
; 562  : 	for (i = 0; i < MAXACKPACKETS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Net_AllAck
$LN2@Net_AllAck:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Net_AllAck:
  0001b	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0001f	7d 18		 jge	 SHORT $LN3@Net_AllAck

; 563  : 		if (ackpak[i].acknum)

  00021	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00028	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 04		 je	 SHORT $LN5@Net_AllAck

; 564  : 			return false;

  00033	33 c0		 xor	 eax, eax
  00035	eb 07		 jmp	 SHORT $LN1@Net_AllAck
$LN5@Net_AllAck:
  00037	eb d9		 jmp	 SHORT $LN2@Net_AllAck
$LN3@Net_AllAck:

; 565  : 
; 566  : 	return true;

  00039	b8 01 00 00 00	 mov	 eax, 1
$LN1@Net_AllAck:

; 567  : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_Net_AllAckReceived ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_AckTicker
_TEXT	SEGMENT
_node$1 = -12						; size = 4
_nodei$2 = -8						; size = 4
_i$ = -4						; size = 4
_Net_AckTicker PROC					; COMDAT

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 464  : 	INT32 i;
; 465  : 
; 466  : 	for (i = 0; i < MAXACKPACKETS; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Net_AckTic
$LN2@Net_AckTic:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Net_AckTic:
  0001b	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0001f	0f 8d e5 01 00
	00		 jge	 $LN3@Net_AckTic

; 467  : 	{
; 468  : 		const INT32 nodei = ackpak[i].destinationnode;

  00025	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0002c	0f b6 88 02 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax+2]
  00033	89 4d f8	 mov	 DWORD PTR _nodei$2[ebp], ecx

; 469  : 		node_t *node = &nodes[nodei];

  00036	6b 45 f8 50	 imul	 eax, DWORD PTR _nodei$2[ebp], 80
  0003a	05 00 00 00 00	 add	 eax, OFFSET _nodes
  0003f	89 45 f4	 mov	 DWORD PTR _node$1[ebp], eax

; 470  : #ifdef NEWPING
; 471  : 		if (ackpak[i].acknum && ackpak[i].senttime + NODETIMEOUT < I_GetTime())

  00042	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00049	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  00050	85 c9		 test	 ecx, ecx
  00052	0f 84 ad 01 00
	00		 je	 $LN8@Net_AckTic
  00058	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0005f	8b b0 04 00 00
	00		 mov	 esi, DWORD PTR _ackpak[eax+4]
  00065	83 c6 0e	 add	 esi, 14			; 0000000eH
  00068	e8 00 00 00 00	 call	 _I_GetTime
  0006d	3b f0		 cmp	 esi, eax
  0006f	0f 83 90 01 00
	00		 jae	 $LN8@Net_AckTic

; 472  : #else
; 473  : 		if (ackpak[i].acknum && ackpak[i].senttime + node->timeout < I_GetTime())
; 474  : #endif
; 475  : 		{
; 476  : 			if (ackpak[i].resentnum > 10 && (node->flags & CLOSE))

  00075	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0007c	0f b7 88 0a 00
	00 00		 movzx	 ecx, WORD PTR _ackpak[eax+10]
  00083	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00086	7e 6b		 jle	 SHORT $LN9@Net_AckTic
  00088	8b 45 f4	 mov	 eax, DWORD PTR _node$1[ebp]
  0008b	0f b6 48 4e	 movzx	 ecx, BYTE PTR [eax+78]
  0008f	83 e1 01	 and	 ecx, 1
  00092	74 5f		 je	 SHORT $LN9@Net_AckTic

; 477  : 			{
; 478  : 				DEBFILE(va("ack %d sent 10 times so connection is supposed lost: node %d\n",

  00094	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  0009b	74 32		 je	 SHORT $LN10@Net_AckTic
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000a2	50		 push	 eax
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _nodei$2[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000aa	52		 push	 edx
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@EJHHDHPA@ack?5?$CFd?5sent?510?5times?5so?5connect@
  000b0	e8 00 00 00 00	 call	 _va
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _fputs
  000be	83 c4 08	 add	 esp, 8
  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _fflush
  000cc	83 c4 04	 add	 esp, 4
$LN10@Net_AckTic:

; 479  : 					i, nodei));
; 480  : 				Net_CloseConnection(nodei | FORCECLOSE);

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _nodei$2[ebp]
  000d2	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _Net_CloseConnection
  000dd	83 c4 04	 add	 esp, 4

; 481  : 
; 482  : 				ackpak[i].acknum = 0;

  000e0	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  000e7	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _ackpak[eax], 0

; 483  : 				continue;

  000ee	e9 1f ff ff ff	 jmp	 $LN2@Net_AckTic
$LN9@Net_AckTic:

; 484  : 			}
; 485  : #ifdef NEWPING
; 486  : 			DEBFILE(va("Resend ack %d, %u<%d at %u\n", ackpak[i].acknum, ackpak[i].senttime,

  000f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _debugfile, 0
  000fa	74 4f		 je	 SHORT $LN11@Net_AckTic
  000fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _I_GetTime
  00107	50		 push	 eax
  00108	6a 0e		 push	 14			; 0000000eH
  0010a	69 4d fc b8 05
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 1464
  00111	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR _ackpak[ecx+4]
  00117	52		 push	 edx
  00118	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  0011f	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _ackpak[eax]
  00126	51		 push	 ecx
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JNCPMDIE@Resend?5ack?5?$CFd?0?5?$CFu?$DM?$CFd?5at?5?$CFu?6@
  0012c	e8 00 00 00 00	 call	 _va
  00131	83 c4 14	 add	 esp, 20			; 00000014H
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 _fputs
  0013a	83 c4 08	 add	 esp, 8
  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR _debugfile
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _fflush
  00148	83 c4 04	 add	 esp, 4
$LN11@Net_AckTic:

; 487  : 				NODETIMEOUT, I_GetTime()));
; 488  : #else
; 489  : 			DEBFILE(va("Resend ack %d, %u<%d at %u\n", ackpak[i].acknum, ackpak[i].senttime,
; 490  : 				node->timeout, I_GetTime()));
; 491  : #endif
; 492  : 			M_Memcpy(netbuffer, ackpak[i].pak.raw, ackpak[i].length);

  0014b	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00152	0f b7 88 08 00
	00 00		 movzx	 ecx, WORD PTR _ackpak[eax+8]
  00159	51		 push	 ecx
  0015a	69 55 fc b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  00161	81 c2 0c 00 00
	00		 add	 edx, OFFSET _ackpak+12
  00167	52		 push	 edx
  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR _netbuffer
  0016d	50		 push	 eax
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR _M_Memcpy
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH

; 493  : 			ackpak[i].senttime = I_GetTime();

  00177	e8 00 00 00 00	 call	 _I_GetTime
  0017c	69 4d fc b8 05
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 1464
  00183	89 81 04 00 00
	00		 mov	 DWORD PTR _ackpak[ecx+4], eax

; 494  : 			ackpak[i].resentnum++;

  00189	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  00190	66 8b 88 0a 00
	00 00		 mov	 cx, WORD PTR _ackpak[eax+10]
  00197	66 83 c1 01	 add	 cx, 1
  0019b	69 55 fc b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  001a2	66 89 8a 0a 00
	00 00		 mov	 WORD PTR _ackpak[edx+10], cx

; 495  : 			ackpak[i].nextacknum = node->nextacknum;

  001a9	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  001b0	8b 4d f4	 mov	 ecx, DWORD PTR _node$1[ebp]
  001b3	8a 51 4d	 mov	 dl, BYTE PTR [ecx+77]
  001b6	88 90 01 00 00
	00		 mov	 BYTE PTR _ackpak[eax+1], dl

; 496  : 			retransmit++; // for stat

  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _retransmit
  001c1	83 c0 01	 add	 eax, 1
  001c4	a3 00 00 00 00	 mov	 DWORD PTR _retransmit, eax

; 497  : 			HSendPacket((INT32)(node - nodes), false, ackpak[i].acknum,

  001c9	69 45 fc b8 05
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 1464
  001d0	0f b7 88 08 00
	00 00		 movzx	 ecx, WORD PTR _ackpak[eax+8]
  001d7	83 e9 08	 sub	 ecx, 8
  001da	51		 push	 ecx
  001db	69 55 fc b8 05
	00 00		 imul	 edx, DWORD PTR _i$[ebp], 1464
  001e2	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _ackpak[edx]
  001e9	50		 push	 eax
  001ea	6a 00		 push	 0
  001ec	8b 45 f4	 mov	 eax, DWORD PTR _node$1[ebp]
  001ef	2d 00 00 00 00	 sub	 eax, OFFSET _nodes
  001f4	99		 cdq
  001f5	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  001fa	f7 f9		 idiv	 ecx
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 _HSendPacket
  00202	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Net_AckTic:

; 498  : 				(size_t)(ackpak[i].length - BASEPACKETSIZE));
; 499  : 		}
; 500  : 	}

  00205	e9 08 fe ff ff	 jmp	 $LN2@Net_AckTic
$LN3@Net_AckTic:

; 501  : 
; 502  : 	for (i = 1; i < MAXNETNODES; i++)

  0020a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00211	eb 09		 jmp	 SHORT $LN7@Net_AckTic
$LN5@Net_AckTic:
  00213	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00216	83 c0 01	 add	 eax, 1
  00219	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Net_AckTic:
  0021c	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00220	7d 68		 jge	 SHORT $LN6@Net_AckTic

; 503  : 	{
; 504  : 		// this is something like node open flag
; 505  : 		if (nodes[i].firstacktosend)

  00222	6b 45 fc 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00226	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax]
  0022d	85 c9		 test	 ecx, ecx
  0022f	74 57		 je	 SHORT $LN14@Net_AckTic

; 506  : 		{
; 507  : 			// we haven't sent a packet for a long time
; 508  : 			// acknowledge packet if needed
; 509  : 			if (nodes[i].lasttimeacktosend_sent + ACKTOSENDTIMEOUT < I_GetTime())

  00231	6b 45 fc 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00235	8b b0 44 00 00
	00		 mov	 esi, DWORD PTR _nodes[eax+68]
  0023b	83 c6 02	 add	 esi, 2
  0023e	e8 00 00 00 00	 call	 _I_GetTime
  00243	3b f0		 cmp	 esi, eax
  00245	73 0c		 jae	 SHORT $LN13@Net_AckTic

; 510  : 				Net_SendAcks(i);

  00247	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 _Net_SendAcks
  00250	83 c4 04	 add	 esp, 4
$LN13@Net_AckTic:

; 511  : 
; 512  : 			if (!(nodes[i].flags & CLOSE)
; 513  : 				&& nodes[i].lasttimepacketreceived + connectiontimeout < I_GetTime())

  00253	6b 45 fc 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00257	0f b6 88 4e 00
	00 00		 movzx	 ecx, BYTE PTR _nodes[eax+78]
  0025e	83 e1 01	 and	 ecx, 1
  00261	75 25		 jne	 SHORT $LN14@Net_AckTic
  00263	6b 45 fc 50	 imul	 eax, DWORD PTR _i$[ebp], 80
  00267	8b b0 48 00 00
	00		 mov	 esi, DWORD PTR _nodes[eax+72]
  0026d	03 35 00 00 00
	00		 add	 esi, DWORD PTR _connectiontimeout
  00273	e8 00 00 00 00	 call	 _I_GetTime
  00278	3b f0		 cmp	 esi, eax
  0027a	73 0c		 jae	 SHORT $LN14@Net_AckTic

; 514  : 			{
; 515  : 				Net_ConnectionTimeout(i);

  0027c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 _Net_ConnectionTimeout
  00285	83 c4 04	 add	 esp, 4
$LN14@Net_AckTic:

; 516  : 			}
; 517  : 		}
; 518  : 	}

  00288	eb 89		 jmp	 SHORT $LN5@Net_AckTic
$LN6@Net_AckTic:

; 519  : }

  0028a	5f		 pop	 edi
  0028b	5e		 pop	 esi
  0028c	5b		 pop	 ebx
  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c3		 ret	 0
_Net_AckTicker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Net_GetNetStat
_TEXT	SEGMENT
_newsendbyte$1 = -16					; size = 8
_df$2 = -8						; size = 4
_t$ = -4						; size = 4
_Net_GetNetStat PROC					; COMDAT

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 105  : 	const tic_t t = I_GetTime();

  00009	e8 00 00 00 00	 call	 _I_GetTime
  0000e	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 106  : 	static INT64 oldsendbyte = 0;
; 107  : 	if (statstarttic+STATLENGTH <= t)

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _statstarttic
  00016	83 c0 46	 add	 eax, 70			; 00000046H
  00019	3b 45 fc	 cmp	 eax, DWORD PTR _t$[ebp]
  0001c	0f 87 72 01 00
	00		 ja	 $LN2@Net_GetNet

; 108  : 	{
; 109  : 		const tic_t df = t-statstarttic;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00025	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _statstarttic
  0002b	89 45 f8	 mov	 DWORD PTR _df$2[ebp], eax

; 110  : 		const INT64 newsendbyte = sendbytes - oldsendbyte;

  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR _sendbytes
  00033	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?oldsendbyte@?1??Net_GetNetStat@@9@9
  00039	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _sendbytes+4
  0003f	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR ?oldsendbyte@?1??Net_GetNetStat@@9@9+4
  00045	89 45 f0	 mov	 DWORD PTR _newsendbyte$1[ebp], eax
  00048	89 4d f4	 mov	 DWORD PTR _newsendbyte$1[ebp+4], ecx

; 111  : 		sendbps = (INT32)(newsendbyte*TICRATE)/df;

  0004b	6a 00		 push	 0
  0004d	6a 23		 push	 35			; 00000023H
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _newsendbyte$1[ebp+4]
  00052	50		 push	 eax
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _newsendbyte$1[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 __allmul
  0005c	33 d2		 xor	 edx, edx
  0005e	f7 75 f8	 div	 DWORD PTR _df$2[ebp]
  00061	a3 00 00 00 00	 mov	 DWORD PTR _sendbps, eax

; 112  : 		getbps = (getbytes*TICRATE)/df;

  00066	6b 05 00 00 00
	00 23		 imul	 eax, DWORD PTR _getbytes, 35
  0006d	33 d2		 xor	 edx, edx
  0006f	f7 75 f8	 div	 DWORD PTR _df$2[ebp]
  00072	a3 00 00 00 00	 mov	 DWORD PTR _getbps, eax

; 113  : 		if (sendackpacket)

  00077	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _sendackpacket, 0
  0007e	74 26		 je	 SHORT $LN3@Net_GetNet

; 114  : 			lostpercent = 100.0f*(float)retransmit/(float)sendackpacket;

  00080	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _retransmit
  00088	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  00090	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _sendackpacket
  00098	f3 0f 5e c1	 divss	 xmm0, xmm1
  0009c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _lostpercent, xmm0
  000a4	eb 0b		 jmp	 SHORT $LN4@Net_GetNet
$LN3@Net_GetNet:

; 115  : 		else
; 116  : 			lostpercent = 0.0f;

  000a6	0f 57 c0	 xorps	 xmm0, xmm0
  000a9	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _lostpercent, xmm0
$LN4@Net_GetNet:

; 117  : 		if (getackpacket)

  000b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _getackpacket, 0
  000b8	74 26		 je	 SHORT $LN5@Net_GetNet

; 118  : 			duppercent = 100.0f*(float)duppacket/(float)getackpacket;

  000ba	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _duppacket
  000c2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  000ca	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _getackpacket
  000d2	f3 0f 5e c1	 divss	 xmm0, xmm1
  000d6	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _duppercent, xmm0
  000de	eb 0b		 jmp	 SHORT $LN6@Net_GetNet
$LN5@Net_GetNet:

; 119  : 		else
; 120  : 			duppercent = 0.0f;

  000e0	0f 57 c0	 xorps	 xmm0, xmm0
  000e3	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _duppercent, xmm0
$LN6@Net_GetNet:

; 121  : 		if (ticruned)

  000eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ticruned, 0
  000f2	74 26		 je	 SHORT $LN7@Net_GetNet

; 122  : 			gamelostpercent = 100.0f*(float)ticmiss/(float)ticruned;

  000f4	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR _ticmiss
  000fc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  00104	f3 0f 2a 0d 00
	00 00 00	 cvtsi2ss xmm1, DWORD PTR _ticruned
  0010c	f3 0f 5e c1	 divss	 xmm0, xmm1
  00110	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gamelostpercent, xmm0
  00118	eb 0b		 jmp	 SHORT $LN8@Net_GetNet
$LN7@Net_GetNet:

; 123  : 		else
; 124  : 			gamelostpercent = 0.0f;

  0011a	0f 57 c0	 xorps	 xmm0, xmm0
  0011d	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR _gamelostpercent, xmm0
$LN8@Net_GetNet:

; 125  : 
; 126  : 		ticmiss = ticruned = 0;

  00125	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ticruned, 0
  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR _ticruned
  00134	a3 00 00 00 00	 mov	 DWORD PTR _ticmiss, eax

; 127  : 		oldsendbyte = sendbytes;

  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR _sendbytes
  0013e	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _sendbytes+4
  00144	a3 00 00 00 00	 mov	 DWORD PTR ?oldsendbyte@?1??Net_GetNetStat@@9@9, eax
  00149	89 0d 04 00 00
	00		 mov	 DWORD PTR ?oldsendbyte@?1??Net_GetNetStat@@9@9+4, ecx

; 128  : 		getbytes = 0;

  0014f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _getbytes, 0

; 129  : 		sendackpacket = getackpacket = duppacket = retransmit = 0;

  00159	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _retransmit, 0
  00163	a1 00 00 00 00	 mov	 eax, DWORD PTR _retransmit
  00168	a3 00 00 00 00	 mov	 DWORD PTR _duppacket, eax
  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _duppacket
  00173	89 0d 00 00 00
	00		 mov	 DWORD PTR _getackpacket, ecx
  00179	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _getackpacket
  0017f	89 15 00 00 00
	00		 mov	 DWORD PTR _sendackpacket, edx

; 130  : 		statstarttic = t;

  00185	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  00188	a3 00 00 00 00	 mov	 DWORD PTR _statstarttic, eax

; 131  : 
; 132  : 		return 1;

  0018d	b8 01 00 00 00	 mov	 eax, 1
  00192	eb 02		 jmp	 SHORT $LN1@Net_GetNet
$LN2@Net_GetNet:

; 133  : 	}
; 134  : 	return 0;

  00194	33 c0		 xor	 eax, eax
$LN1@Net_GetNet:

; 135  : }

  00196	5f		 pop	 edi
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
_Net_GetNetStat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\RafaTheFox\Desktop\SRB2-Public-master (1)\SRB2-Public-master\src\d_net.c
;	COMDAT _Command_Ping_f
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Command_Ping_f PROC					; COMDAT

; 1132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1133 : #ifndef NEWPING
; 1134 : 	if(server)
; 1135 : 	{
; 1136 : #endif
; 1137 : 		INT32 i;
; 1138 : 		for (i = 0; i < MAXPLAYERS;i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@Command_Pi
$LN2@Command_Pi:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Command_Pi:
  0001b	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0001f	7d 46		 jge	 SHORT $LN3@Command_Pi

; 1139 : 		{
; 1140 : #ifndef NEWPING
; 1141 : 			const INT32 node = playernode[i];
; 1142 : 			if (playeringame[i] && node != 0)
; 1143 : 				CONS_Printf(text[CMD_PING], i, player_names[i],
; 1144 : 				GetLag(node), G_TicsToMilliseconds(GetLag(node)));
; 1145 : #else
; 1146 : 			if (playeringame[i] && i != 0)

  00021	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00024	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR _playeringame[eax*4], 0
  0002c	74 37		 je	 SHORT $LN5@Command_Pi
  0002e	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00032	74 31		 je	 SHORT $LN5@Command_Pi

; 1147 : 				CONS_Printf(text[CMD_PING], i, player_names[i], playerpingtable[i]);

  00034	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00037	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _playerpingtable[eax*4]
  0003e	51		 push	 ecx
  0003f	6b 55 fc 16	 imul	 edx, DWORD PTR _i$[ebp], 22
  00043	81 c2 00 00 00
	00		 add	 edx, OFFSET _player_names
  00049	52		 push	 edx
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004d	50		 push	 eax
  0004e	b9 04 00 00 00	 mov	 ecx, 4
  00053	6b d1 58	 imul	 edx, ecx, 88
  00056	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _text[edx]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _CONS_Printf
  00062	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Command_Pi:

; 1148 : #endif
; 1149 : 		}

  00065	eb ab		 jmp	 SHORT $LN2@Command_Pi
$LN3@Command_Pi:

; 1150 : #ifndef NEWPING
; 1151 : 	}
; 1152 : 	else CONS_Printf("%s", text[YOUARENOTTHESERVER]);
; 1153 : #endif
; 1154 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_Command_Ping_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1779 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1780 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1458 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1460 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1397 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Stream$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vfprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 844  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
